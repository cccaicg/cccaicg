{"docstring": "/*\n * check_empty --\n *     Check that the uri exists and has one entry.\n */\n", "func_signal": "static void\ncheck_one_entry(WT_SESSION *session, const char *uri, const char *key, const char *value)", "code": "{\n    WT_CURSOR *cursor;\n    WT_DECL_RET;\n    char *gotkey, *gotvalue;\n\n    testutil_check(session->open_cursor(session, uri, NULL, NULL, &cursor));\n    testutil_check(cursor->next(cursor));\n    testutil_check(cursor->get_key(cursor, &gotkey));\n    testutil_check(cursor->get_value(cursor, &gotvalue));\n    testutil_assert(WT_STREQ(key, gotkey));\n    testutil_assert(WT_STREQ(value, gotvalue));\n    ret = cursor->next(cursor);\n    testutil_assert(ret == WT_NOTFOUND);\n    testutil_check(cursor->close(cursor));\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __wt_cond_signal --\n *     Signal a waiting thread.\n */\n", "func_signal": "void\n__wt_cond_signal(WT_SESSION_IMPL *session, WT_CONDVAR *cond)", "code": "{\n    WT_DECL_RET;\n\n    __wt_verbose(session, WT_VERB_MUTEX, \"signal %s\", cond->name);\n\n    /*\n     * Our callers often set flags to cause a thread to exit. Add a barrier to ensure exit flags are\n     * seen by the sleeping threads, otherwise we can wake up a thread, it immediately goes back to\n     * sleep, and we'll hang. Use a full barrier (we may not write before waiting on thread join).\n     */\n    WT_FULL_BARRIER();\n\n    /*\n     * Fast path if we are in (or can enter), a state where the next waiter will return immediately\n     * as already signaled.\n     */\n    if (cond->waiters == -1 || (cond->waiters == 0 && __wt_atomic_casi32(&cond->waiters, 0, -1)))\n        return;\n\n    EnterCriticalSection(&cond->mtx);\n    WakeAllConditionVariable(&cond->cond);\n    LeaveCriticalSection(&cond->mtx);\n}", "path": "wiredtiger/src/os_win/os_mtx_cond.c", "commit_date": "2020-05-01 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __wt_curconfig_open --\n *     WT_SESSION->open_cursor method for config cursors.\n */\n", "func_signal": "int\n__wt_curconfig_open(\n  WT_SESSION_IMPL *session, const char *uri, const char *cfg[], WT_CURSOR **cursorp)", "code": "{\n    WT_CURSOR_STATIC_INIT(iface, __wt_cursor_get_key, /* get-key */\n      __wt_cursor_get_value,                          /* get-value */\n      __wt_cursor_set_key,                            /* set-key */\n      __wt_cursor_set_value,                          /* set-value */\n      __wt_cursor_compare_notsup,                     /* compare */\n      __wt_cursor_equals_notsup,                      /* equals */\n      __wt_cursor_notsup,                             /* next */\n      __wt_cursor_notsup,                             /* prev */\n      __wt_cursor_noop,                               /* reset */\n      __wt_cursor_notsup,                             /* search */\n      __wt_cursor_search_near_notsup,                 /* search-near */\n      __wt_cursor_notsup,                             /* insert */\n      __wt_cursor_modify_notsup,                      /* modify */\n      __wt_cursor_notsup,                             /* update */\n      __wt_cursor_notsup,                             /* remove */\n      __wt_cursor_notsup,                             /* reserve */\n      __wt_cursor_reconfigure_notsup,                 /* reconfigure */\n      __wt_cursor_notsup,                             /* cache */\n      __wt_cursor_reopen_notsup,                      /* reopen */\n      __curconfig_close);\n    WT_CURSOR_CONFIG *cconfig;\n    WT_CURSOR *cursor;\n    WT_DECL_RET;\n\n    WT_STATIC_ASSERT(offsetof(WT_CURSOR_CONFIG, iface) == 0);\n\n    WT_RET(__wt_calloc_one(session, &cconfig));\n    cursor = (WT_CURSOR *)cconfig;\n    *cursor = iface;\n    cursor->session = (WT_SESSION *)session;\n    cursor->key_format = cursor->value_format = \"S\";\n\n    WT_ERR(__wt_cursor_init(cursor, uri, NULL, cfg, cursorp));\n\n    if (0) {\nerr:\n        WT_TRET(__curconfig_close(cursor));\n        *cursorp = NULL;\n    }\n    return (ret);\n}", "path": "wiredtiger/src/cursor/cur_config.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * check_kv --\n *     Check that a key exists with a value, or does not exist.\n */\n", "func_signal": "static void\ncheck_kv(WT_CURSOR *cursor, const char *key, const char *value, bool exists)", "code": "{\n    WT_DECL_RET;\n    char *got;\n\n    cursor->set_key(cursor, key);\n    ret = cursor->search(cursor);\n    if ((ret = cursor->search(cursor)) == WT_NOTFOUND) {\n        if (exists) {\n            printf(\"FAIL: expected rev file to have: %s\\n\", key);\n            testutil_assert(!exists);\n        }\n    } else {\n        testutil_check(ret);\n        if (!exists) {\n            printf(\"FAIL: unexpected key in rev file: %s\\n\", key);\n            testutil_assert(exists);\n        }\n        testutil_check(cursor->get_value(cursor, &got));\n        TEST_STREQ(value, got, \"value\");\n    }\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __compact_rewrite --\n *     Return if a modified page needs to be re-written.\n */\n", "func_signal": "static int\n__compact_rewrite(WT_SESSION_IMPL *session, WT_REF *ref, bool *skipp)", "code": "{\n    WT_ADDR_COPY addr;\n    WT_BM *bm;\n    WT_MULTI *multi;\n    WT_PAGE_MODIFY *mod;\n    uint32_t i;\n\n    *skipp = true; /* Default skip. */\n\n    bm = S2BT(session)->bm;\n\n    /* If the page is clean, test the original addresses. */\n    if (__wt_page_evict_clean(ref->page))\n        return (__wt_ref_addr_copy(session, ref, &addr) ?\n            bm->compact_page_skip(bm, session, addr.addr, addr.size, skipp) :\n            0);\n\n    /*\n     * If the page is a replacement, test the replacement addresses. Ignore empty pages, they get\n     * merged into the parent.\n     */\n    mod = ref->page->modify;\n    if (mod->rec_result == WT_PM_REC_REPLACE)\n        return (\n          bm->compact_page_skip(bm, session, mod->mod_replace.addr, mod->mod_replace.size, skipp));\n\n    if (mod->rec_result == WT_PM_REC_MULTIBLOCK)\n        for (multi = mod->mod_multi, i = 0; i < mod->mod_multi_entries; ++multi, ++i) {\n            if (multi->addr.addr == NULL)\n                continue;\n            WT_RET(bm->compact_page_skip(bm, session, multi->addr.addr, multi->addr.size, skipp));\n            if (!*skipp)\n                break;\n        }\n\n    return (0);\n}", "path": "wiredtiger/src/btree/bt_compact.c", "commit_date": "2020-08-15 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * create_db --\n *     Creates the database and tables so they are fully ready to be accessed by subordinate\n *     threads, and copied/recovered.\n */\n", "func_signal": "static void\ncreate_db(const char *method)", "code": "{\n    WT_CONNECTION *conn;\n    WT_SESSION *session;\n    char envconf[512];\n\n    testutil_check(__wt_snprintf(envconf, sizeof(envconf), ENV_CONFIG, method));\n\n    testutil_check(wiredtiger_open(home, NULL, envconf, &conn));\n    testutil_check(conn->open_session(conn, NULL, NULL, &session));\n    testutil_check(session->create(session, uri_main, \"key_format=S,value_format=S\"));\n    testutil_check(session->create(session, uri_rev, \"key_format=S,value_format=S\"));\n    /*\n     * Checkpoint to help ensure that everything gets out to disk, so any direct I/O copy will have\n     * at least have tables that can be opened.\n     */\n    testutil_check(session->checkpoint(session, NULL));\n    testutil_check(session->close(session, NULL));\n    testutil_check(conn->close(conn, NULL));\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * check_empty --\n *     Check that the uri exists and is empty.\n */\n", "func_signal": "static void\ncheck_empty(WT_SESSION *session, const char *uri)", "code": "{\n    WT_CURSOR *cursor;\n    WT_DECL_RET;\n\n    testutil_check(session->open_cursor(session, uri, NULL, NULL, &cursor));\n    ret = cursor->next(cursor);\n    testutil_assert(ret == WT_NOTFOUND);\n    testutil_check(cursor->close(cursor));\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * check_schema\n *\tCheck that the database has the expected schema according to the\n *\tlast id seen for this thread.\n */\n", "func_signal": "static void\ncheck_schema(WT_SESSION *session, uint64_t lastid, uint32_t threadid, uint32_t flags)", "code": "{\n    char uri[50], uri2[50];\n\n    if (!LF_ISSET(SCHEMA_ALL) || !LF_ISSET(SCHEMA_INTEGRATED))\n        return;\n\n    if (LF_ISSET(SCHEMA_VERBOSE))\n        fprintf(stderr, \"check_schema(%\" PRIu64 \", thread=%\" PRIu32 \")\\n\", lastid, threadid);\n    if (has_schema_operation(lastid, 0)) {\n        /* Create table operation. */\n        gen_table_name(uri, sizeof(uri), lastid, threadid);\n        if (LF_ISSET(SCHEMA_VERBOSE))\n            fprintf(stderr, \" create %s\\n\", uri);\n        if (LF_ISSET(SCHEMA_CREATE_CHECK))\n            check_empty(session, uri);\n    }\n    if (has_schema_operation(lastid, 1)) {\n        /* Insert value operation. */\n        gen_table_name(uri, sizeof(uri), lastid - 1, threadid);\n        if (LF_ISSET(SCHEMA_VERBOSE))\n            fprintf(stderr, \" insert %s\\n\", uri);\n        if (LF_ISSET(SCHEMA_DATA_CHECK))\n            check_one_entry(session, uri, uri, uri);\n    }\n    if (LF_ISSET(SCHEMA_RENAME) && has_schema_operation(lastid, 2)) {\n        /* Table rename operation. */\n        gen_table_name(uri, sizeof(uri), lastid - 2, threadid);\n        gen_table2_name(uri2, sizeof(uri2), lastid - 2, threadid, flags);\n        if (LF_ISSET(SCHEMA_VERBOSE))\n            fprintf(stderr, \" rename %s,%s\\n\", uri, uri2);\n        if (LF_ISSET(SCHEMA_DROP_CHECK))\n            check_dropped(session, uri);\n        if (LF_ISSET(SCHEMA_CREATE_CHECK))\n            check_one_entry(session, uri2, uri, uri);\n    }\n    if (has_schema_operation(lastid, 3)) {\n        /* Value update operation. */\n        gen_table_name(uri, sizeof(uri), lastid - 2, threadid);\n        gen_table2_name(uri2, sizeof(uri2), lastid - 2, threadid, flags);\n        if (LF_ISSET(SCHEMA_VERBOSE))\n            fprintf(stderr, \" update %s\\n\", uri2);\n        if (LF_ISSET(SCHEMA_DATA_CHECK))\n            check_one_entry(session, uri2, uri, uri2);\n    }\n    if (LF_ISSET(SCHEMA_DROP_CHECK) && has_schema_operation(lastid, 4)) {\n        /* Drop table operation. */\n        gen_table2_name(uri2, sizeof(uri2), lastid - 2, threadid, flags);\n        if (LF_ISSET(SCHEMA_VERBOSE))\n            fprintf(stderr, \" drop %s\\n\", uri2);\n        check_dropped(session, uri2);\n    }\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * has_direct_io --\n *     Check for direct I/O support.\n */\n", "func_signal": "static bool\nhas_direct_io(void)", "code": "{\n#ifdef O_DIRECT\n    return (true);\n#else\n    return (false);\n#endif\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __curconfig_close --\n *     WT_CURSOR->close method for the config cursor type.\n */\n", "func_signal": "static int\n__curconfig_close(WT_CURSOR *cursor)", "code": "{\n    WT_DECL_RET;\n    WT_SESSION_IMPL *session;\n\n    CURSOR_API_CALL_PREPARE_ALLOWED(cursor, session, close, NULL);\nerr:\n\n    __wt_cursor_close(cursor);\n\n    API_END_RET(session, ret);\n}", "path": "wiredtiger/src/cursor/cur_config.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __clsm_close_bulk --\n *     WT_CURSOR->close method for LSM bulk cursors.\n */\n", "func_signal": "static int\n__clsm_close_bulk(WT_CURSOR *cursor)", "code": "{\n    WT_CURSOR *bulk_cursor;\n    WT_CURSOR_LSM *clsm;\n    WT_LSM_CHUNK *chunk;\n    WT_LSM_TREE *lsm_tree;\n    WT_SESSION_IMPL *session;\n    uint64_t avg_chunks, total_chunks;\n\n    clsm = (WT_CURSOR_LSM *)cursor;\n    lsm_tree = clsm->lsm_tree;\n    chunk = lsm_tree->chunk[0];\n    session = CUR2S(clsm);\n\n    /* Close the bulk cursor to ensure the chunk is written to disk. */\n    bulk_cursor = clsm->chunks[0]->cursor;\n    WT_RET(bulk_cursor->close(bulk_cursor));\n    clsm->nchunks = 0;\n\n    /* Set ondisk, and flush the metadata */\n    F_SET(chunk, WT_LSM_CHUNK_ONDISK);\n    /*\n     * Setup a generation in our chunk based on how many chunk_size pieces fit into a chunk of a\n     * given generation. This allows future LSM merges choose reasonable sets of chunks.\n     */\n    avg_chunks = (lsm_tree->merge_min + lsm_tree->merge_max) / 2;\n    for (total_chunks = chunk->size / lsm_tree->chunk_size; total_chunks > 1;\n         total_chunks /= avg_chunks)\n        ++chunk->generation;\n\n    WT_RET(__wt_lsm_meta_write(session, lsm_tree, NULL));\n    ++lsm_tree->dsk_gen;\n\n    /* Close the LSM cursor */\n    WT_RET(__wt_clsm_close(cursor));\n\n    return (0);\n}", "path": "wiredtiger/src/lsm/lsm_cursor_bulk.c", "commit_date": "2020-05-01 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * gen_table2_name --\n *     Generate a second table name used for the schema test.\n */\n", "func_signal": "static void\ngen_table2_name(char *buf, size_t buf_size, uint64_t id, uint32_t threadid, uint32_t flags)", "code": "{\n    if (!LF_ISSET(SCHEMA_RENAME))\n        /* table is not renamed, so use original table name */\n        gen_table_name(buf, buf_size, id, threadid);\n    else\n        testutil_check(__wt_snprintf(buf, buf_size, \"table:B%\" PRIu64 \"-%\" PRIu32, id, threadid));\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __wt_compact --\n *     Compact a file.\n */\n", "func_signal": "int\n__wt_compact(WT_SESSION_IMPL *session)", "code": "{\n    WT_BM *bm;\n    WT_DECL_RET;\n    WT_REF *ref;\n    u_int i;\n    bool skip;\n\n    bm = S2BT(session)->bm;\n    ref = NULL;\n\n    WT_STAT_DATA_INCR(session, session_compact);\n\n    /*\n     * Check if compaction might be useful -- the API layer will quit trying to compact the data\n     * source if we make no progress, set a flag if the block layer thinks compaction is possible.\n     */\n    WT_RET(bm->compact_skip(bm, session, &skip));\n    if (skip)\n        return (0);\n\n    /* Walk the tree reviewing pages to see if they should be re-written. */\n    for (i = 0;;) {\n        /*\n         * Periodically check if we've timed out or eviction is stuck. Quit if eviction is stuck,\n         * we're making the problem worse.\n         */\n        if (++i > 100) {\n            __compact_progress(session);\n            WT_ERR(__wt_session_compact_check_timeout(session));\n\n            if (__wt_cache_stuck(session))\n                WT_ERR(EBUSY);\n\n            i = 0;\n        }\n\n        /*\n         * Compact pulls pages into cache during the walk without checking whether the cache is\n         * full. Check now to throttle compact to match eviction speed.\n         */\n        WT_ERR(__wt_cache_eviction_check(session, false, false, NULL));\n\n        /*\n         * Pages read for compaction aren't \"useful\"; don't update the read generation of pages\n         * already in memory, and if a page is read, set its generation to a low value so it is\n         * evicted quickly.\n         */\n        WT_ERR(__wt_tree_walk_custom_skip(\n          session, &ref, __wt_compact_page_skip, NULL, WT_READ_NO_GEN | WT_READ_WONT_NEED));\n        if (ref == NULL)\n            break;\n\n        /*\n         * Cheap checks that don't require locking.\n         *\n         * Ignore the root: it may not have a replacement address, and besides, if anything else\n         * gets written, so will it.\n         *\n         * Ignore dirty pages, checkpoint will likely write them. There are cases where checkpoint\n         * can skip dirty pages: to avoid that, we could alter the transactional information of the\n         * page, which is what checkpoint reviews to decide if a page can be skipped. Not doing that\n         * for now, the repeated checkpoints that compaction requires are more than likely to pick\n         * up all dirty pages at some point.\n         */\n        if (__wt_ref_is_root(ref))\n            continue;\n        if (__wt_page_is_modified(ref->page))\n            continue;\n\n        WT_ERR(__compact_rewrite_lock(session, ref, &skip));\n        if (skip)\n            continue;\n\n        /* Rewrite the page: mark the page and tree dirty. */\n        WT_ERR(__wt_page_modify_init(session, ref->page));\n        __wt_page_modify_set(session, ref->page);\n\n        session->compact_state = WT_COMPACT_SUCCESS;\n        WT_STAT_DATA_INCR(session, btree_compact_rewrite);\n    }\n\nerr:\n    if (ref != NULL)\n        WT_TRET(__wt_page_release(session, ref, 0));\n\n    return (ret);\n}", "path": "wiredtiger/src/btree/bt_compact.c", "commit_date": "2020-08-15 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __wt_cond_wait_signal --\n *     Wait on a mutex, optionally timing out. If we get it before the time out period expires, let\n *     the caller know.\n */\n", "func_signal": "void\n__wt_cond_wait_signal(WT_SESSION_IMPL *session, WT_CONDVAR *cond, uint64_t usecs,\n  bool (*run_func)(WT_SESSION_IMPL *), bool *signalled)", "code": "{\n    BOOL sleepret;\n    DWORD milliseconds, windows_error;\n    bool locked;\n    uint64_t milliseconds64;\n\n    locked = false;\n\n    /* Fast path if already signalled. */\n    *signalled = true;\n    if (__wt_atomic_addi32(&cond->waiters, 1) == 0)\n        return;\n\n    __wt_verbose(session, WT_VERB_MUTEX, \"wait %s\", cond->name);\n    WT_STAT_CONN_INCR(session, cond_wait);\n\n    EnterCriticalSection(&cond->mtx);\n    locked = true;\n\n    /*\n     * It's possible to race with threads waking us up. That's not a problem if there are multiple\n     * wakeups because the next wakeup will get us, or if we're only pausing for a short period.\n     * It's a problem if there's only a single wakeup, our waker is likely waiting for us to exit.\n     * After acquiring the mutex (so we're guaranteed to be awakened by any future wakeup call),\n     * optionally check if we're OK to keep running. This won't ensure our caller won't just loop\n     * and call us again, but at least it's not our fault.\n     *\n     * Assert we're not waiting longer than a second if not checking the run status.\n     */\n    WT_ASSERT(session, run_func != NULL || usecs <= WT_MILLION);\n\n    if (run_func != NULL && !run_func(session))\n        goto skipping;\n\n    if (usecs > 0) {\n        milliseconds64 = usecs / WT_THOUSAND;\n\n        /*\n         * Check for 32-bit unsigned integer overflow INFINITE is max unsigned int on Windows\n         */\n        if (milliseconds64 >= INFINITE)\n            milliseconds64 = INFINITE - 1;\n        milliseconds = (DWORD)milliseconds64;\n\n        /*\n         * 0 would mean the CV sleep becomes a TryCV which we do not\n         * want\n         */\n        if (milliseconds == 0)\n            milliseconds = 1;\n\n        sleepret = SleepConditionVariableCS(&cond->cond, &cond->mtx, milliseconds);\n    } else\n        sleepret = SleepConditionVariableCS(&cond->cond, &cond->mtx, INFINITE);\n\n    /*\n     * SleepConditionVariableCS returns non-zero on success, 0 on timeout or failure.\n     */\n    if (sleepret == 0) {\n        windows_error = __wt_getlasterror();\n        if (windows_error == ERROR_TIMEOUT) {\nskipping:\n            *signalled = false;\n            sleepret = 1;\n        }\n    }\n\n    (void)__wt_atomic_subi32(&cond->waiters, 1);\n\n    if (locked)\n        LeaveCriticalSection(&cond->mtx);\n\n    if (sleepret != 0)\n        return;\n\n    __wt_err(session, __wt_map_windows_error(windows_error), \"SleepConditionVariableCS: %s: %s\",\n      cond->name, __wt_formatmessage(session, windows_error));\n    WT_IGNORE_RET(__wt_panic(\n      session, __wt_map_windows_error(windows_error), \"SleepConditionVariableCS: %s\", cond->name));\n}", "path": "wiredtiger/src/os_win/os_mtx_cond.c", "commit_date": "2020-05-01 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __compact_rewrite_lock --\n *     Return if a page needs to be re-written.\n */\n", "func_signal": "static int\n__compact_rewrite_lock(WT_SESSION_IMPL *session, WT_REF *ref, bool *skipp)", "code": "{\n    WT_BTREE *btree;\n    WT_DECL_RET;\n\n    btree = S2BT(session);\n\n    /*\n     * Reviewing in-memory pages requires looking at page reconciliation results, because we care\n     * about where the page is stored now, not where the page was stored when we first read it into\n     * the cache. We need to ensure we don't race with page reconciliation as it's writing the page\n     * modify information. There are two ways we call reconciliation: checkpoints and eviction. We\n     * are holding a hazard pointer that blocks eviction, but there's nothing blocking a checkpoint.\n     * Get the tree's flush lock which blocks threads writing pages for checkpoints. If checkpoint\n     * is holding the lock, quit working this file, we'll visit it again in our next pass.\n     */\n    WT_RET(__wt_spin_trylock(session, &btree->flush_lock));\n\n    ret = __compact_rewrite(session, ref, skipp);\n\n    /* Unblock threads writing leaf pages. */\n    __wt_spin_unlock(session, &btree->flush_lock);\n\n    return (ret);\n}", "path": "wiredtiger/src/btree/bt_compact.c", "commit_date": "2020-08-15 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * check_dropped --\n *     Check that the uri has been dropped.\n */\n", "func_signal": "static void\ncheck_dropped(WT_SESSION *session, const char *uri)", "code": "{\n    WT_CURSOR *cursor;\n    WT_DECL_RET;\n\n    ret = session->open_cursor(session, uri, NULL, NULL, &cursor);\n    testutil_assert(ret == WT_NOTFOUND);\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * check_db --\n *     Make a copy of the database and verify its contents.\n */\n", "func_signal": "static bool\ncheck_db(uint32_t nth, uint32_t datasize, pid_t pid, bool directio, uint32_t flags)", "code": "{\n    WT_CONNECTION *conn;\n    WT_CURSOR *cursor, *meta, *rev;\n    WT_DECL_RET;\n    WT_SESSION *session;\n    uint64_t gotid, id;\n    uint64_t *lastid;\n    uint32_t gotth, kvsize, th, threadmap;\n    char checkdir[4096], dbgdir[4096], savedir[4096];\n    char *gotkey, *gotvalue, *keybuf, *p;\n    char **large_arr;\n\n    keybuf = dcalloc(datasize, 1);\n    lastid = dcalloc(nth, sizeof(uint64_t));\n\n    large_arr = dcalloc(nth, sizeof(char *));\n    for (th = 0; th < nth; th++) {\n        large_arr[th] = dcalloc(LARGE_WRITE_SIZE, 1);\n        large_buf(large_arr[th], LARGE_WRITE_SIZE, th, true);\n    }\n    testutil_check(__wt_snprintf(checkdir, sizeof(checkdir), \"%s.CHECK\", home));\n    testutil_check(__wt_snprintf(dbgdir, sizeof(savedir), \"%s.DEBUG\", home));\n    testutil_check(__wt_snprintf(savedir, sizeof(savedir), \"%s.SAVE\", home));\n\n    /*\n     * We make a copy of the directory (possibly using direct I/O) for recovery and checking, and an\n     * identical copy that keeps the state of all files before recovery starts.\n     */\n    printf(\n      \"Copy database home directory using direct I/O to run recovery,\\n\"\n      \"along with a saved 'pre-recovery' copy.\\n\");\n    /*\n     * Copy the original home directory explicitly without direct I/O. Copy this first because\n     * copying with directio may abort and we want to see what the original copy saw.\n     */\n    copy_directory(home, dbgdir, false);\n    copy_directory(home, checkdir, directio);\n    copy_directory(checkdir, savedir, false);\n\n    printf(\"Open database, run recovery and verify content\\n\");\n    ret = wiredtiger_open(checkdir, NULL, ENV_CONFIG_REC, &conn);\n    /* If this fails, abort the child process before we die so we can see what it was doing. */\n    if (ret != 0) {\n        if (pid != 0)\n            kill_child(pid);\n        testutil_check(ret);\n    }\n    testutil_check(conn->open_session(conn, NULL, NULL, &session));\n    testutil_check(session->open_cursor(session, uri_main, NULL, NULL, &cursor));\n    testutil_check(session->open_cursor(session, uri_rev, NULL, NULL, &rev));\n    kvsize = datasize / 2;\n\n/*\n * We're most interested in the final records on disk. Rather than walk all records, we do a quick\n * scan to find the last complete set of written ids. Each thread writes each id, along with the\n * thread id, so they are interleaved. Once we have the neighborhood where some keys may be missing,\n * we'll back up to do a scan from that point.\n */\n#define CHECK_INCR 1000\n    for (id = 0;; id += CHECK_INCR) {\n        gen_kv(keybuf, kvsize, id, 0, large_arr[0], true);\n        cursor->set_key(cursor, keybuf);\n        if ((ret = cursor->search(cursor)) == WT_NOTFOUND)\n            break;\n        testutil_check(ret);\n        for (th = 1; th < nth; th++) {\n            gen_kv(keybuf, kvsize, id, th, large_arr[th], true);\n            cursor->set_key(cursor, keybuf);\n            if ((ret = cursor->search(cursor)) == WT_NOTFOUND)\n                break;\n            testutil_check(ret);\n        }\n        if (ret == WT_NOTFOUND)\n            break;\n    }\n    if (id < CHECK_INCR * 2)\n        id = 0;\n    else\n        id -= CHECK_INCR * 2;\n\n    printf(\"starting full scan at %\" PRIu64 \"\\n\", id);\n    gen_kv(keybuf, kvsize, id, 0, large_arr[0], true);\n    cursor->set_key(cursor, keybuf);\n    th = 0;\n\n    /* Keep bitmap of \"active\" threads. */\n    threadmap = (0x1U << nth) - 1;\n    for (ret = cursor->search(cursor); ret != WT_NOTFOUND && threadmap != 0;\n         ret = cursor->next(cursor)) {\n        testutil_check(ret);\n        testutil_check(cursor->get_key(cursor, &gotkey));\n        gotid = (uint64_t)strtol(gotkey, &p, 10);\n        testutil_assert(*p == KEY_SEP[0]);\n        p++;\n        testutil_assert(isxdigit(*p));\n        if (isdigit(*p))\n            gotth = (uint32_t)(*p - '0');\n        else if (*p >= 'a' && *p <= 'f')\n            gotth = (uint32_t)((*p - 'a') + 10);\n        else\n            gotth = (uint32_t)((*p - 'A') + 10);\n        p++;\n        testutil_assert(*p == KEY_SEP[0]);\n        p++;\n\n        /*\n         * See if the expected thread has finished at this point. If so, remove it from the thread\n         * map.\n         */\n        while (gotth != th) {\n            if ((threadmap & (0x1U << th)) != 0) {\n                threadmap &= ~(0x1U << th);\n                lastid[th] = id - 1;\n                /*\n                 * Any newly removed value in the main table should not be present as a key in the\n                 * reverse table, since they were transactionally inserted at the same time.\n                 */\n                gen_kv(keybuf, kvsize, id, th, large_arr[th], false);\n                check_kv(rev, keybuf, NULL, false);\n                check_schema(session, id - 1, th, flags);\n            }\n            th = (th + 1) % nth;\n            if (th == 0)\n                id++;\n        }\n        testutil_assert(gotid == id);\n        /*\n         * Check that the key and value fully match.\n         */\n        gen_kv(keybuf, kvsize, id, th, large_arr[th], true);\n        gen_kv(&keybuf[kvsize], kvsize, id, th, large_arr[th], false);\n        testutil_check(cursor->get_value(cursor, &gotvalue));\n        TEST_STREQ(keybuf, gotkey, \"main table key\");\n\n        /*\n         * Every 1000th record is large.\n         */\n        if (id % 1000 == 0)\n            TEST_STREQ(large_arr[th], gotvalue, \"main table large value\");\n        else\n            TEST_STREQ(&keybuf[kvsize], gotvalue, \"main table value\");\n\n        /*\n         * Check the reverse file, with key/value reversed.\n         */\n        check_kv(rev, &keybuf[kvsize], keybuf, true);\n\n        check_schema(session, id, th, flags);\n\n        /* Bump thread number and id to the next expected key. */\n        th = (th + 1) % nth;\n        if (th == 0)\n            id++;\n    }\n    printf(\"scanned to %\" PRIu64 \"\\n\", id);\n\n    if (LF_ISSET(SCHEMA_ALL)) {\n        /*\n         * Check metadata to see if there are any tables present that shouldn't be there.\n         */\n        testutil_check(session->open_cursor(session, \"metadata:\", NULL, NULL, &meta));\n        while ((ret = meta->next(meta)) != WT_NOTFOUND) {\n            testutil_check(ret);\n            testutil_check(meta->get_key(meta, &gotkey));\n            /*\n             * Names involved in schema testing are of the form:\n             *   table:Axxx-t\n             *   table:Bxxx-t\n             * xxx corresponds to the id inserted into the main\n             * table when the table was created, and t corresponds\n             * to the thread id that did this.\n             */\n            if (WT_PREFIX_SKIP(gotkey, \"table:\") && (*gotkey == 'A' || *gotkey == 'B')) {\n                gotid = (uint64_t)strtol(gotkey + 1, &p, 10);\n                testutil_assert(*p == '-');\n                th = (uint32_t)strtol(p + 1, &p, 10);\n                testutil_assert(*p == '\\0');\n                /*\n                 * If table operations are truly transactional, then there shouldn't be any extra\n                 * files that unaccounted for.\n                 */\n                if (LF_ISSET(SCHEMA_DROP_CHECK))\n                    testutil_assert(gotid == lastid[th]);\n            }\n        }\n        testutil_check(meta->close(meta));\n    }\n\n    testutil_check(cursor->close(cursor));\n    testutil_check(rev->close(rev));\n    testutil_check(session->close(session, NULL));\n    testutil_check(conn->close(conn, NULL));\n\n    for (th = 0; th < nth; th++)\n        free(large_arr[th]);\n    free(large_arr);\n    free(keybuf);\n    free(lastid);\n    return (true);\n}", "path": "wiredtiger/test/csuite/random_directio/main.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __wt_cond_destroy --\n *     Destroy a condition variable.\n */\n", "func_signal": "void\n__wt_cond_destroy(WT_SESSION_IMPL *session, WT_CONDVAR **condp)", "code": "{\n    WT_CONDVAR *cond;\n\n    cond = *condp;\n    if (cond == NULL)\n        return;\n\n    /* Do nothing to delete Condition Variable */\n    DeleteCriticalSection(&cond->mtx);\n    __wt_free(session, *condp);\n}", "path": "wiredtiger/src/os_win/os_mtx_cond.c", "commit_date": "2020-05-01 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __clsm_insert_bulk --\n *     WT_CURSOR->insert method for LSM bulk cursors.\n */\n", "func_signal": "static int\n__clsm_insert_bulk(WT_CURSOR *cursor)", "code": "{\n    WT_CURSOR *bulk_cursor;\n    WT_CURSOR_LSM *clsm;\n    WT_LSM_CHUNK *chunk;\n    WT_LSM_TREE *lsm_tree;\n    WT_SESSION_IMPL *session;\n\n    clsm = (WT_CURSOR_LSM *)cursor;\n    lsm_tree = clsm->lsm_tree;\n    chunk = lsm_tree->chunk[0];\n    session = CUR2S(clsm);\n\n    WT_ASSERT(session, lsm_tree->nchunks == 1 && clsm->nchunks == 1);\n    ++chunk->count;\n    chunk->size += cursor->key.size + cursor->value.size;\n    bulk_cursor = clsm->chunks[0]->cursor;\n    bulk_cursor->set_key(bulk_cursor, &cursor->key);\n    bulk_cursor->set_value(bulk_cursor, &cursor->value);\n    WT_RET(bulk_cursor->insert(bulk_cursor));\n\n    return (0);\n}", "path": "wiredtiger/src/lsm/lsm_cursor_bulk.c", "commit_date": "2020-05-01 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/*\n * __compact_progress --\n *     Output a compact progress message.\n */\n", "func_signal": "static void\n__compact_progress(WT_SESSION_IMPL *session)", "code": "{\n    struct timespec cur_time;\n    WT_BM *bm;\n    uint64_t time_diff;\n\n    if (!WT_VERBOSE_ISSET(session, WT_VERB_COMPACT_PROGRESS))\n        return;\n\n    bm = S2BT(session)->bm;\n    __wt_epoch(session, &cur_time);\n\n    /* Log one progress message every twenty seconds. */\n    time_diff = WT_TIMEDIFF_SEC(cur_time, session->compact->begin);\n    if (time_diff / WT_PROGRESS_MSG_PERIOD > session->compact->prog_msg_count) {\n        __wt_verbose(session, WT_VERB_COMPACT_PROGRESS,\n          \"Compact running for %\" PRIu64 \" seconds; reviewed %\" PRIu64 \" pages, skipped %\" PRIu64\n          \" pages, wrote %\" PRIu64 \" pages\",\n          time_diff, bm->block->compact_pages_reviewed, bm->block->compact_pages_skipped,\n          bm->block->compact_pages_written);\n        session->compact->prog_msg_count++;\n    }\n}", "path": "wiredtiger/src/btree/bt_compact.c", "commit_date": "2020-08-15 00:00:00", "repo_name": "wiredtiger/wiredtiger", "stars": 2121, "license": "other", "language": "c", "size": 145694}
{"docstring": "/* cleanup linked image by unrefing */\n", "func_signal": "static void cleanup_ref (zbar_image_t *img)", "code": "{\n    if(img->next)\n        _zbar_image_refcnt(img->next, -1);\n}", "path": "ZBar/zbar/convert.c", "commit_date": "2010-06-07 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Searches for an arrangement of these three finder centers that yields a valid\n   configuration.\n  _c: On input, the three finder centers to consider in any order.\n  Return: The detected version number, or a negative value on error.*/\n", "func_signal": "static int qr_reader_try_configuration(qr_reader *_reader,\n qr_code_data *_qrdata,const unsigned char *_img,int _width,int _height,\n qr_finder_center *_c[3])", "code": "{\n  int      ci[7];\n  unsigned maxd;\n  int      ccw;\n  int      i0;\n  int      i;\n  /*Sort the points in counter-clockwise order.*/\n  ccw=qr_point_ccw(_c[0]->pos,_c[1]->pos,_c[2]->pos);\n  /*Colinear points can't be the corners of a quadrilateral.*/\n  if(!ccw)return -1;\n  /*Include a few extra copies of the cyclical list to avoid mods.*/\n  ci[6]=ci[3]=ci[0]=0;\n  ci[4]=ci[1]=1+(ccw<0);\n  ci[5]=ci[2]=2-(ccw<0);\n  /*Assume the points farthest from each other are the opposite corners, and\n     find the top-left point.*/\n  maxd=qr_point_distance2(_c[1]->pos,_c[2]->pos);\n  i0=0;\n  for(i=1;i<3;i++){\n    unsigned d;\n    d=qr_point_distance2(_c[ci[i+1]]->pos,_c[ci[i+2]]->pos);\n    if(d>maxd){\n      i0=i;\n      maxd=d;\n    }\n  }\n  /*However, try all three possible orderings, just to be sure (a severely\n     skewed projection could move opposite corners closer than adjacent).*/\n  for(i=i0;i<i0+3;i++){\n    qr_aff    aff;\n    qr_hom    hom;\n    qr_finder ul;\n    qr_finder ur;\n    qr_finder dl;\n    qr_point  bbox[4];\n    int       res;\n    int       ur_version;\n    int       dl_version;\n    int       fmt_info;\n    ul.c=_c[ci[i]];\n    ur.c=_c[ci[i+1]];\n    dl.c=_c[ci[i+2]];\n    /*Estimate the module size and version number from the two opposite corners.\n      The module size is not constant in the image, so we compute an affine\n       projection from the three points we have to a square domain, and\n       estimate it there.\n      Although it should be the same along both axes, we keep separate\n       estimates to account for any remaining projective distortion.*/\n    res=QR_INT_BITS-2-QR_FINDER_SUBPREC-qr_ilog(QR_MAXI(_width,_height)-1);\n    qr_aff_init(&aff,ul.c->pos,ur.c->pos,dl.c->pos,res);\n    qr_aff_unproject(ur.o,&aff,ur.c->pos[0],ur.c->pos[1]);\n    qr_finder_edge_pts_aff_classify(&ur,&aff);\n    if(qr_finder_estimate_module_size_and_version(&ur,1<<res,1<<res)<0)continue;\n    qr_aff_unproject(dl.o,&aff,dl.c->pos[0],dl.c->pos[1]);\n    qr_finder_edge_pts_aff_classify(&dl,&aff);\n    if(qr_finder_estimate_module_size_and_version(&dl,1<<res,1<<res)<0)continue;\n    /*If the estimated versions are significantly different, reject the\n       configuration.*/\n    if(abs(ur.eversion[1]-dl.eversion[0])>QR_LARGE_VERSION_SLACK)continue;\n    qr_aff_unproject(ul.o,&aff,ul.c->pos[0],ul.c->pos[1]);\n    qr_finder_edge_pts_aff_classify(&ul,&aff);\n    if(qr_finder_estimate_module_size_and_version(&ul,1<<res,1<<res)<0||\n     abs(ul.eversion[1]-ur.eversion[1])>QR_LARGE_VERSION_SLACK||\n     abs(ul.eversion[0]-dl.eversion[0])>QR_LARGE_VERSION_SLACK){\n      continue;\n    }\n#if defined(QR_DEBUG)\n    qr_finder_dump_aff_undistorted(&ul,&ur,&dl,&aff,_img,_width,_height);\n#endif\n    /*If we made it this far, upgrade the affine homography to a full\n       homography.*/\n    if(qr_hom_fit(&hom,&ul,&ur,&dl,bbox,&aff,\n     &_reader->isaac,_img,_width,_height)<0){\n      continue;\n    }\n    memcpy(_qrdata->bbox,bbox,sizeof(bbox));\n    qr_hom_unproject(ul.o,&hom,ul.c->pos[0],ul.c->pos[1]);\n    qr_hom_unproject(ur.o,&hom,ur.c->pos[0],ur.c->pos[1]);\n    qr_hom_unproject(dl.o,&hom,dl.c->pos[0],dl.c->pos[1]);\n    qr_finder_edge_pts_hom_classify(&ur,&hom);\n    if(qr_finder_estimate_module_size_and_version(&ur,\n     ur.o[0]-ul.o[0],ur.o[0]-ul.o[0])<0){\n      continue;\n    }\n    qr_finder_edge_pts_hom_classify(&dl,&hom);\n    if(qr_finder_estimate_module_size_and_version(&dl,\n     dl.o[1]-ul.o[1],dl.o[1]-ul.o[1])<0){\n      continue;\n    }\n#if defined(QR_DEBUG)\n    qr_finder_dump_hom_undistorted(&ul,&ur,&dl,&hom,_img,_width,_height);\n#endif\n    /*If we have a small version (less than 7), there's no encoded version\n       information.\n      If the estimated version on the two corners matches and is sufficiently\n       small, we assume this is the case.*/\n    if(ur.eversion[1]==dl.eversion[0]&&ur.eversion[1]<7){\n      /*We used to do a whole bunch of extra geometric checks for small\n         versions, because with just an affine correction, it was fairly easy\n         to estimate two consistent module sizes given a random configuration.\n        However, now that we're estimating a full homography, these appear to\n         be unnecessary.*/\n#if 0\n      static const signed char LINE_TESTS[12][6]={\n        /*DL left, UL > 0, UR > 0*/\n        {2,0,0, 1,1, 1},\n        /*DL right, UL > 0, UR < 0*/\n        {2,1,0, 1,1,-1},\n        /*UR top, UL > 0, DL > 0*/\n        {1,2,0, 1,2, 1},\n        /*UR bottom, UL > 0, DL < 0*/\n        {1,3,0, 1,2,-1},\n        /*UR left, DL < 0, UL < 0*/\n        {1,0,2,-1,0,-1},\n        /*UR right, DL > 0, UL > 0*/\n        {1,1,2, 1,0, 1},\n        /*DL top, UR < 0, UL < 0*/\n        {2,2,1,-1,0,-1},\n        /*DL bottom, UR > 0, UL > 0*/\n        {2,3,1, 1,0, 1},\n        /*UL left, DL > 0, UR > 0*/\n        {0,0,2, 1,1, 1},\n        /*UL right, DL > 0, UR < 0*/\n        {0,1,2, 1,1,-1},\n        /*UL top, UR > 0, DL > 0*/\n        {0,2,1, 1,2, 1},\n        /*UL bottom, UR > 0, DL < 0*/\n        {0,3,1, 1,2,-1}\n      };\n      qr_finder *f[3];\n      int        j;\n      /*Start by decoding the format information.\n        This is cheap, but unlikely to reject invalid configurations.\n        56.25% of all bitstrings are valid, and we mix and match several pieces\n         until we find a valid combination, so our real chances of finding a\n         valid codeword in random bits are even higher.*/\n      fmt_info=qr_finder_fmt_info_decode(&ul,&ur,&dl,&aff,_img,_width,_height);\n      if(fmt_info<0)continue;\n      /*Now we fit lines to the edges of each finder pattern and check to make\n         sure the centers of the other finder patterns lie on the proper side.*/\n      f[0]=&ul;\n      f[1]=&ur;\n      f[2]=&dl;\n      for(j=0;j<12;j++){\n        const signed char *t;\n        qr_line            l0;\n        int               *p;\n        t=LINE_TESTS[j];\n        qr_finder_ransac(f[t[0]],&aff,&_reader->isaac,t[1]);\n        /*We may not have enough points to fit a line accurately here.\n          If not, we just skip the test.*/\n        if(qr_line_fit_finder_edge(l0,f[t[0]],t[1],res)<0)continue;\n        p=f[t[2]]->c->pos;\n        if(qr_line_eval(l0,p[0],p[1])*t[3]<0)break;\n        p=f[t[4]]->c->pos;\n        if(qr_line_eval(l0,p[0],p[1])*t[5]<0)break;\n      }\n      if(j<12)continue;\n      /*All tests passed.*/\n#endif\n      ur_version=ur.eversion[1];\n    }\n    else{\n      /*If the estimated versions are significantly different, reject the\n         configuration.*/\n      if(abs(ur.eversion[1]-dl.eversion[0])>QR_LARGE_VERSION_SLACK)continue;\n      /*Otherwise we try to read the actual version data from the image.\n        If the real version is not sufficiently close to our estimated version,\n         then we assume there was an unrecoverable decoding error (so many bit\n         errors we were within 3 errors of another valid code), and throw that\n         value away.\n        If no decoded version could be sufficiently close, we don't even try.*/\n      if(ur.eversion[1]>=7-QR_LARGE_VERSION_SLACK){\n        ur_version=qr_finder_version_decode(&ur,&hom,_img,_width,_height,0);\n        if(abs(ur_version-ur.eversion[1])>QR_LARGE_VERSION_SLACK)ur_version=-1;\n      }\n      else ur_version=-1;\n      if(dl.eversion[0]>=7-QR_LARGE_VERSION_SLACK){\n        dl_version=qr_finder_version_decode(&dl,&hom,_img,_width,_height,1);\n        if(abs(dl_version-dl.eversion[0])>QR_LARGE_VERSION_SLACK)dl_version=-1;\n      }\n      else dl_version=-1;\n      /*If we got at least one valid version, or we got two and they match,\n         then we found a valid configuration.*/\n      if(ur_version>=0){\n        if(dl_version>=0&&dl_version!=ur_version)continue;\n      }\n      else if(dl_version<0)continue;\n      else ur_version=dl_version;\n    }\n    qr_finder_edge_pts_hom_classify(&ul,&hom);\n    if(qr_finder_estimate_module_size_and_version(&ul,\n     ur.o[0]-dl.o[0],dl.o[1]-ul.o[1])<0||\n     abs(ul.eversion[1]-ur.eversion[1])>QR_SMALL_VERSION_SLACK||\n     abs(ul.eversion[0]-dl.eversion[0])>QR_SMALL_VERSION_SLACK){\n      continue;\n    }\n    fmt_info=qr_finder_fmt_info_decode(&ul,&ur,&dl,&hom,_img,_width,_height);\n    if(fmt_info<0||\n     qr_code_decode(_qrdata,&_reader->gf,ul.c->pos,ur.c->pos,dl.c->pos,\n     ur_version,fmt_info,_img,_width,_height)<0){\n      /*The code may be flipped.\n        Try again, swapping the UR and DL centers.\n        We should get a valid version either way, so it's relatively cheap to\n         check this, as we've already filtered out a lot of invalid\n         configurations.*/\n      QR_SWAP2I(hom.inv[0][0],hom.inv[1][0]);\n      QR_SWAP2I(hom.inv[0][1],hom.inv[1][1]);\n      QR_SWAP2I(hom.fwd[0][0],hom.fwd[0][1]);\n      QR_SWAP2I(hom.fwd[1][0],hom.fwd[1][1]);\n      QR_SWAP2I(hom.fwd[2][0],hom.fwd[2][1]);\n      QR_SWAP2I(ul.o[0],ul.o[1]);\n      QR_SWAP2I(ul.size[0],ul.size[1]);\n      QR_SWAP2I(ur.o[0],ur.o[1]);\n      QR_SWAP2I(ur.size[0],ur.size[1]);\n      QR_SWAP2I(dl.o[0],dl.o[1]);\n      QR_SWAP2I(dl.size[0],dl.size[1]);\n#if defined(QR_DEBUG)\n      qr_finder_dump_hom_undistorted(&ul,&dl,&ur,&hom,_img,_width,_height);\n#endif\n      fmt_info=qr_finder_fmt_info_decode(&ul,&dl,&ur,&hom,_img,_width,_height);\n      if(fmt_info<0)continue;\n      QR_SWAP2I(bbox[1][0],bbox[2][0]);\n      QR_SWAP2I(bbox[1][1],bbox[2][1]);\n      memcpy(_qrdata->bbox,bbox,sizeof(bbox));\n      if(qr_code_decode(_qrdata,&_reader->gf,ul.c->pos,dl.c->pos,ur.c->pos,\n       ur_version,fmt_info,_img,_width,_height)<0){\n        continue;\n      }\n    }\n    return ur_version;\n  }\n  return -1;\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Initializes a client reader handle.*/\n", "func_signal": "static void qr_reader_init (qr_reader *reader)", "code": "{\n    /*time_t now;\n      now=time(NULL);\n      isaac_init(&_reader->isaac,&now,sizeof(now));*/\n    isaac_init(&reader->isaac, NULL, 0);\n    rs_gf256_init(&reader->gf, QR_PPOLY);\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Computes the Hamming distance between two bit patterns (the number of bits\n   that differ).\n  May stop counting after _maxdiff differences.*/\n", "func_signal": "static int qr_hamming_dist(unsigned _y1,unsigned _y2,int _maxdiff)", "code": "{\n  unsigned y;\n  int      ret;\n  y=_y1^_y2;\n  for(ret=0;ret<_maxdiff&&y;ret++)y&=y-1;\n  return ret;\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Estimates the size of a module after classifying the edge points.\n  _width:  The distance between UL and UR in the square domain.\n  _height: The distance between UL and DL in the square domain.*/\n", "func_signal": "static int qr_finder_estimate_module_size_and_version(qr_finder *_f,\n int _width,int _height)", "code": "{\n  qr_point offs;\n  int      sums[4];\n  int      nsums[4];\n  int      usize;\n  int      nusize;\n  int      vsize;\n  int      nvsize;\n  int      uversion;\n  int      vversion;\n  int      e;\n  offs[0]=offs[1]=0;\n  for(e=0;e<4;e++)if(_f->nedge_pts[e]>0){\n    qr_finder_edge_pt *edge_pts;\n    int                sum;\n    int                mean;\n    int                n;\n    int                i;\n    /*Average the samples for this edge, dropping the top and bottom 25%.*/\n    edge_pts=_f->edge_pts[e];\n    n=_f->nedge_pts[e];\n    sum=0;\n    for(i=(n>>2);i<n-(n>>2);i++)sum+=edge_pts[i].extent;\n    n=n-((n>>2)<<1);\n    mean=QR_DIVROUND(sum,n);\n    offs[e>>1]+=mean;\n    sums[e]=sum;\n    nsums[e]=n;\n  }\n  else nsums[e]=sums[e]=0;\n  /*If we have samples on both sides of an axis, refine our idea of where the\n     unprojected finder center is located.*/\n  if(_f->nedge_pts[0]>0&&_f->nedge_pts[1]>0){\n    _f->o[0]-=offs[0]>>1;\n    sums[0]-=offs[0]*nsums[0]>>1;\n    sums[1]-=offs[0]*nsums[1]>>1;\n  }\n  if(_f->nedge_pts[2]>0&&_f->nedge_pts[3]>0){\n    _f->o[1]-=offs[1]>>1;\n    sums[2]-=offs[1]*nsums[2]>>1;\n    sums[3]-=offs[1]*nsums[3]>>1;\n  }\n  /*We must have _some_ samples along each axis... if we don't, our transform\n     must be pretty severely distorting the original square (e.g., with\n     coordinates so large as to cause overflow).*/\n  nusize=nsums[0]+nsums[1];\n  if(nusize<=0)return -1;\n  /*The module size is 1/3 the average edge extent.*/\n  nusize*=3;\n  usize=sums[1]-sums[0];\n  usize=((usize<<1)+nusize)/(nusize<<1);\n  if(usize<=0)return -1;\n  /*Now estimate the version directly from the module size and the distance\n     between the finder patterns.\n    This is done independently using the extents along each axis.\n    If either falls significantly outside the valid range (1 to 40), reject the\n     configuration.*/\n  uversion=(_width-8*usize)/(usize<<2);\n  if(uversion<1||uversion>40+QR_LARGE_VERSION_SLACK)return -1;\n  /*Now do the same for the other axis.*/\n  nvsize=nsums[2]+nsums[3];\n  if(nvsize<=0)return -1;\n  nvsize*=3;\n  vsize=sums[3]-sums[2];\n  vsize=((vsize<<1)+nvsize)/(nvsize<<1);\n  if(vsize<=0)return -1;\n  vversion=(_height-8*vsize)/(vsize<<2);\n  if(vversion<1||vversion>40+QR_LARGE_VERSION_SLACK)return -1;\n  /*If the estimated version using extents along one axis is significantly\n     different than the estimated version along the other axis, then the axes\n     have significantly different scalings (relative to the grid).\n    This can happen, e.g., when we have multiple adjacent QR codes, and we've\n     picked two finder patterns from one and the third finder pattern from\n     another, e.g.:\n      X---DL UL---X\n      |....   |....\n      X....  UR....\n    Such a configuration might even pass any other geometric checks if we\n     didn't reject it here.*/\n  if(abs(uversion-vversion)>QR_LARGE_VERSION_SLACK)return -1;\n  _f->size[0]=usize;\n  _f->size[1]=vsize;\n  /*We intentionally do not compute an average version from the sizes along\n     both axes.\n    In the presence of projective distortion, one of them will be much more\n     accurate than the other.*/\n  _f->eversion[0]=uversion;\n  _f->eversion[1]=vversion;\n  return 0;\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/* packed RGB to packed YUV\n * FIXME currently ignores color and grayscales the image\n */\n", "func_signal": "static void convert_rgb_to_yuv (zbar_image_t *dst,\n                                const zbar_format_def_t *dstfmt,\n                                const zbar_image_t *src,\n                                const zbar_format_def_t *srcfmt)", "code": "{\n    uint8_t *dstp, flags;\n    const uint8_t *srcp;\n    int rbits, rbit0, gbits, gbit0, bbits, bbit0;\n    unsigned srcl, x, y;\n    uint16_t y0 = 0;\n\n    uv_roundup(dst, dstfmt);\n    dst->datalen = dst->width * dst->height + uvp_size(dst, dstfmt) * 2;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n    flags = dstfmt->p.yuv.packorder & 2;\n\n    assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));\n    srcp = src->data;\n\n    rbits = RGB_SIZE(srcfmt->p.rgb.red);\n    rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);\n    gbits = RGB_SIZE(srcfmt->p.rgb.green);\n    gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);\n    bbits = RGB_SIZE(srcfmt->p.rgb.blue);\n    bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);\n\n    srcl = src->width * srcfmt->p.rgb.bpp;\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcp -= srcl;\n        for(x = 0; x < dst->width; x++) {\n            if(x < src->width) {\n                uint8_t r, g, b;\n                uint32_t p = convert_read_rgb(srcp, srcfmt->p.rgb.bpp);\n                srcp += srcfmt->p.rgb.bpp;\n\n                /* FIXME endianness? */\n                r = ((p >> rbit0) << rbits) & 0xff;\n                g = ((p >> gbit0) << gbits) & 0xff;\n                b = ((p >> bbit0) << bbits) & 0xff;\n\n                /* FIXME color space? */\n                y0 = ((77 * r + 150 * g + 29 * b) + 0x80) >> 8;\n            }\n            if(flags) {\n                *(dstp++) = 0x80;  *(dstp++) = y0;\n            }\n            else {\n                *(dstp++) = y0;  *(dstp++) = 0x80;\n            }\n        }\n        if(x < src->width)\n            srcp += (src->width - x) * srcfmt->p.rgb.bpp;\n    }\n}", "path": "ZBar/zbar/convert.c", "commit_date": "2010-06-07 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Searches for an alignment pattern near the given location.*/\n", "func_signal": "static int qr_alignment_pattern_search(qr_point _p,const qr_hom_cell *_cell,\n int _u,int _v,int _r,const unsigned char *_img,int _width,int _height)", "code": "{\n  qr_point c[4];\n  int      nc[4];\n  qr_point p[5][5];\n  qr_point pc;\n  unsigned best_match;\n  int      best_dist;\n  int      bestx;\n  int      besty;\n  unsigned match;\n  int      dist;\n  int      u;\n  int      v;\n  int      x0;\n  int      y0;\n  int      w0;\n  int      x;\n  int      y;\n  int      w;\n  int      dxdu;\n  int      dydu;\n  int      dwdu;\n  int      dxdv;\n  int      dydv;\n  int      dwdv;\n  int      dx;\n  int      dy;\n  int      i;\n  int      j;\n  /*Build up a basic template using _cell to control shape and scale.\n    We project the points in the template back to the image just once, since if\n     the alignment pattern has moved, we don't really know why.\n    If it's because of radial distortion, or the code wasn't flat, or something\n     else, there's no reason to expect that a re-projection around each\n     subsequent search point would be any closer to the actual shape than our\n     first projection.\n    Therefore we simply slide this template around, as is.*/\n  u=(_u-2)-_cell->u0;\n  v=(_v-2)-_cell->v0;\n  x0=_cell->fwd[0][0]*u+_cell->fwd[0][1]*v+_cell->fwd[0][2];\n  y0=_cell->fwd[1][0]*u+_cell->fwd[1][1]*v+_cell->fwd[1][2];\n  w0=_cell->fwd[2][0]*u+_cell->fwd[2][1]*v+_cell->fwd[2][2];\n  dxdu=_cell->fwd[0][0];\n  dydu=_cell->fwd[1][0];\n  dwdu=_cell->fwd[2][0];\n  dxdv=_cell->fwd[0][1];\n  dydv=_cell->fwd[1][1];\n  dwdv=_cell->fwd[2][1];\n  for(i=0;i<5;i++){\n    x=x0;\n    y=y0;\n    w=w0;\n    for(j=0;j<5;j++){\n      qr_hom_cell_fproject(p[i][j],_cell,x,y,w);\n      x+=dxdu;\n      y+=dydu;\n      w+=dwdu;\n    }\n    x0+=dxdv;\n    y0+=dydv;\n    w0+=dwdv;\n  }\n  bestx=p[2][2][0];\n  besty=p[2][2][1];\n  best_match=qr_alignment_pattern_fetch(p,bestx,besty,_img,_width,_height);\n  best_dist=qr_hamming_dist(best_match,0x1F8D63F,25);\n  if(best_dist>0){\n    u=_u-_cell->u0;\n    v=_v-_cell->v0;\n    x=_cell->fwd[0][0]*u+_cell->fwd[0][1]*v+_cell->fwd[0][2]<<QR_ALIGN_SUBPREC;\n    y=_cell->fwd[1][0]*u+_cell->fwd[1][1]*v+_cell->fwd[1][2]<<QR_ALIGN_SUBPREC;\n    w=_cell->fwd[2][0]*u+_cell->fwd[2][1]*v+_cell->fwd[2][2]<<QR_ALIGN_SUBPREC;\n    /*Search an area at most _r modules around the target location, in\n       concentric squares..*/\n    for(i=1;i<_r<<QR_ALIGN_SUBPREC;i++){\n      int side_len;\n      side_len=(i<<1)-1;\n      x-=dxdu+dxdv;\n      y-=dydu+dydv;\n      w-=dwdu+dwdv;\n      for(j=0;j<4*side_len;j++){\n        int      dir;\n        qr_hom_cell_fproject(pc,_cell,x,y,w);\n        match=qr_alignment_pattern_fetch(p,pc[0],pc[1],_img,_width,_height);\n        dist=qr_hamming_dist(match,0x1F8D63F,best_dist+1);\n        if(dist<best_dist){\n          best_match=match;\n          best_dist=dist;\n          bestx=pc[0];\n          besty=pc[1];\n        }\n        if(j<2*side_len){\n          dir=j>=side_len;\n          x+=_cell->fwd[0][dir];\n          y+=_cell->fwd[1][dir];\n          w+=_cell->fwd[2][dir];\n        }\n        else{\n          dir=j>=3*side_len;\n          x-=_cell->fwd[0][dir];\n          y-=_cell->fwd[1][dir];\n          w-=_cell->fwd[2][dir];\n        }\n        if(!best_dist)break;\n      }\n      if(!best_dist)break;\n    }\n  }\n  /*If the best result we got was sufficiently bad, reject the match.\n    If we're wrong and we include it, we can grossly distort the nearby\n     region, whereas using the initial starting point should at least be\n     consistent with the geometry we already have.*/\n  if(best_dist>6){\n    _p[0]=p[2][2][0];\n    _p[1]=p[2][2][1];\n    return -1;\n  }\n  /*Now try to get a more accurate location of the pattern center.*/\n  dx=bestx-p[2][2][0];\n  dy=besty-p[2][2][1];\n  memset(nc,0,sizeof(nc));\n  memset(c,0,sizeof(c));\n  /*We consider 8 lines across the finder pattern in turn.\n    If we actually found a symmetric pattern along that line, search for its\n     exact center in the image.\n    There are plenty more lines we could use if these don't work, but if we've\n     found anything remotely close to an alignment pattern, we should be able\n     to use most of these.*/\n  for(i=0;i<8;i++){\n    static const unsigned MASK_TESTS[8][2]={\n      {0x1040041,0x1000001},{0x0041040,0x0001000},\n      {0x0110110,0x0100010},{0x0011100,0x0001000},\n      {0x0420084,0x0400004},{0x0021080,0x0001000},\n      {0x0006C00,0x0004400},{0x0003800,0x0001000},\n    };\n    static const unsigned char MASK_COORDS[8][2]={\n      {0,0},{1,1},{4,0},{3,1},{2,0},{2,1},{0,2},{1,2}\n    };\n    if((best_match&MASK_TESTS[i][0])==MASK_TESTS[i][1]){\n      int x0;\n      int y0;\n      int x1;\n      int y1;\n      x0=p[MASK_COORDS[i][1]][MASK_COORDS[i][0]][0]+dx>>QR_FINDER_SUBPREC;\n      if(x0<0||x0>=_width)continue;\n      y0=p[MASK_COORDS[i][1]][MASK_COORDS[i][0]][1]+dy>>QR_FINDER_SUBPREC;\n      if(y0<0||y0>=_height)continue;\n      x1=p[4-MASK_COORDS[i][1]][4-MASK_COORDS[i][0]][0]+dx>>QR_FINDER_SUBPREC;\n      if(x1<0||x1>=_width)continue;\n      y1=p[4-MASK_COORDS[i][1]][4-MASK_COORDS[i][0]][1]+dy>>QR_FINDER_SUBPREC;\n      if(y1<0||y1>=_height)continue;\n      if(!qr_finder_locate_crossing(_img,_width,_height,x0,y0,x1,y1,i&1,pc)){\n        int w;\n        int cx;\n        int cy;\n        cx=pc[0]-bestx;\n        cy=pc[1]-besty;\n        if(i&1){\n          /*Weight crossings around the center dot more highly, as they are\n             generally more reliable.*/\n          w=3;\n          cx+=cx<<1;\n          cy+=cy<<1;\n        }\n        else w=1;\n        nc[i>>1]+=w;\n        c[i>>1][0]+=cx;\n        c[i>>1][1]+=cy;\n      }\n    }\n  }\n  /*Sum offsets from lines in orthogonal directions.*/\n  for(i=0;i<2;i++){\n    int a;\n    int b;\n    a=nc[i<<1];\n    b=nc[i<<1|1];\n    if(a&&b){\n      int w;\n      w=QR_MAXI(a,b);\n      c[i<<1][0]=QR_DIVROUND(w*(b*c[i<<1][0]+a*c[i<<1|1][0]),a*b);\n      c[i<<1][1]=QR_DIVROUND(w*(b*c[i<<1][1]+a*c[i<<1|1][1]),a*b);\n      nc[i<<1]=w<<1;\n    }\n    else{\n      c[i<<1][0]+=c[i<<1|1][0];\n      c[i<<1][1]+=c[i<<1|1][1];\n      nc[i<<1]+=b;\n    }\n  }\n  /*Average offsets from pairs of orthogonal lines.*/\n  c[0][0]+=c[2][0];\n  c[0][1]+=c[2][1];\n  nc[0]+=nc[2];\n  /*If we actually found any such lines, apply the adjustment.*/\n  if(nc[0]){\n    dx=QR_DIVROUND(c[0][0],nc[0]);\n    dy=QR_DIVROUND(c[0][1],nc[0]);\n    /*But only if it doesn't make things too much worse.*/\n    match=qr_alignment_pattern_fetch(p,bestx+dx,besty+dy,_img,_width,_height);\n    dist=qr_hamming_dist(match,0x1F8D63F,best_dist+1);\n    if(dist<=best_dist+1){\n      bestx+=dx;\n      besty+=dy;\n    }\n  }\n  _p[0]=bestx;\n  _p[1]=besty;\n  return 0;\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Initialize the sampling grid for each region of the code.\n  _version:  The (decoded) version number.\n  _ul_pos:   The location of the UL finder pattern.\n  _ur_pos:   The location of the UR finder pattern.\n  _dl_pos:   The location of the DL finder pattern.\n  _p:        On input, contains estimated positions of the four corner modules.\n             On output, contains a bounding quadrilateral for the code.\n  _img:      The binary input image.\n  _width:    The width of the input image.\n  _height:   The height of the input image.\n  Return: 0 on success, or a negative value on error.*/\n", "func_signal": "static void qr_sampling_grid_init(qr_sampling_grid *_grid,int _version,\n const qr_point _ul_pos,const qr_point _ur_pos,const qr_point _dl_pos,\n qr_point _p[4],const unsigned char *_img,int _width,int _height)", "code": "{\n  qr_hom_cell          base_cell;\n  int                  align_pos[7];\n  int                  dim;\n  int                  nalign;\n  int                  i;\n  dim=17+(_version<<2);\n  nalign=(_version/7)+2;\n  /*Create a base cell to bootstrap the alignment pattern search.*/\n  qr_hom_cell_init(&base_cell,0,0,dim-1,0,0,dim-1,dim-1,dim-1,\n   _p[0][0],_p[0][1],_p[1][0],_p[1][1],_p[2][0],_p[2][1],_p[3][0],_p[3][1]);\n  /*Allocate the array of cells.*/\n  _grid->ncells=nalign-1;\n  _grid->cells[0]=(qr_hom_cell *)malloc(\n   (nalign-1)*(nalign-1)*sizeof(*_grid->cells[0]));\n  for(i=1;i<_grid->ncells;i++)_grid->cells[i]=_grid->cells[i-1]+_grid->ncells;\n  /*Initialize the function pattern mask.*/\n  _grid->fpmask=(unsigned *)calloc(dim,\n   (dim+QR_INT_BITS-1>>QR_INT_LOGBITS)*sizeof(*_grid->fpmask));\n  /*Mask out the finder patterns (and separators and format info bits).*/\n  qr_sampling_grid_fp_mask_rect(_grid,dim,0,0,9,9);\n  qr_sampling_grid_fp_mask_rect(_grid,dim,0,dim-8,9,8);\n  qr_sampling_grid_fp_mask_rect(_grid,dim,dim-8,0,8,9);\n  /*Mask out the version number bits.*/\n  if(_version>6){\n    qr_sampling_grid_fp_mask_rect(_grid,dim,0,dim-11,6,3);\n    qr_sampling_grid_fp_mask_rect(_grid,dim,dim-11,0,3,6);\n  }\n  /*Mask out the timing patterns.*/\n  qr_sampling_grid_fp_mask_rect(_grid,dim,9,6,dim-17,1);\n  qr_sampling_grid_fp_mask_rect(_grid,dim,6,9,1,dim-17);\n  /*If we have no alignment patterns (e.g., this is a version 1 code), just use\n     the base cell and hope it's good enough.*/\n  if(_version<2)memcpy(_grid->cells[0],&base_cell,sizeof(base_cell));\n  else{\n    qr_point *q;\n    qr_point *p;\n    int       j;\n    int       k;\n    q=(qr_point *)malloc(nalign*nalign*sizeof(*q));\n    p=(qr_point *)malloc(nalign*nalign*sizeof(*p));\n    /*Initialize the alignment pattern position list.*/\n    align_pos[0]=6;\n    align_pos[nalign-1]=dim-7;\n    if(_version>6){\n      int d;\n      d=QR_ALIGNMENT_SPACING[_version-7];\n      for(i=nalign-1;i-->1;)align_pos[i]=align_pos[i+1]-d;\n    }\n    /*Three of the corners use a finder pattern instead of a separate\n       alignment pattern.*/\n    q[0][0]=3;\n    q[0][1]=3;\n    p[0][0]=_ul_pos[0];\n    p[0][1]=_ul_pos[1];\n    q[nalign-1][0]=dim-4;\n    q[nalign-1][1]=3;\n    p[nalign-1][0]=_ur_pos[0];\n    p[nalign-1][1]=_ur_pos[1];\n    q[(nalign-1)*nalign][0]=3;\n    q[(nalign-1)*nalign][1]=dim-4;\n    p[(nalign-1)*nalign][0]=_dl_pos[0];\n    p[(nalign-1)*nalign][1]=_dl_pos[1];\n    /*Scan for alignment patterns using a diagonal sweep.*/\n    for(k=1;k<2*nalign-1;k++){\n      int jmin;\n      int jmax;\n      jmax=QR_MINI(k,nalign-1)-(k==nalign-1);\n      jmin=QR_MAXI(0,k-(nalign-1))+(k==nalign-1);\n      for(j=jmin;j<=jmax;j++){\n        qr_hom_cell *cell;\n        int          u;\n        int          v;\n        int          k;\n        i=jmax-(j-jmin);\n        k=i*nalign+j;\n        u=align_pos[j];\n        v=align_pos[i];\n        q[k][0]=u;\n        q[k][1]=v;\n        /*Mask out the alignment pattern.*/\n        qr_sampling_grid_fp_mask_rect(_grid,dim,u-2,v-2,5,5);\n        /*Pick a cell to use to govern the alignment pattern search.*/\n        if(i>1&&j>1){\n          qr_point p0;\n          qr_point p1;\n          qr_point p2;\n          /*Each predictor is basically a straight-line extrapolation from two\n             neighboring alignment patterns (except possibly near the opposing\n             finder patterns).*/\n          qr_hom_cell_project(p0,_grid->cells[i-2]+j-1,u,v,0);\n          qr_hom_cell_project(p1,_grid->cells[i-2]+j-2,u,v,0);\n          qr_hom_cell_project(p2,_grid->cells[i-1]+j-2,u,v,0);\n          /*Take the median of the predictions as the search center.*/\n          QR_SORT2I(p0[0],p1[0]);\n          QR_SORT2I(p0[1],p1[1]);\n          QR_SORT2I(p1[0],p2[0]);\n          QR_SORT2I(p1[1],p2[1]);\n          QR_SORT2I(p0[0],p1[0]);\n          QR_SORT2I(p0[1],p1[1]);\n          /*We need a cell that has the target point at a known (u,v) location.\n            Since our cells don't have inverses, just construct one from our\n             neighboring points.*/\n          cell=_grid->cells[i-1]+j-1;\n          qr_hom_cell_init(cell,\n           q[k-nalign-1][0],q[k-nalign-1][1],q[k-nalign][0],q[k-nalign][1],\n           q[k-1][0],q[k-1][1],q[k][0],q[k][1],\n           p[k-nalign-1][0],p[k-nalign-1][1],p[k-nalign][0],p[k-nalign][1],\n           p[k-1][0],p[k-1][1],p1[0],p1[1]);\n        }\n        else if(i>1&&j>0)cell=_grid->cells[i-2]+j-1;\n        else if(i>0&&j>1)cell=_grid->cells[i-1]+j-2;\n        else cell=&base_cell;\n        /*Use a very small search radius.\n          A large displacement here usually means a false positive (e.g., when\n           the real alignment pattern is damaged or missing), which can\n           severely distort the projection.*/\n        qr_alignment_pattern_search(p[k],cell,u,v,2,_img,_width,_height);\n        if(i>0&&j>0){\n          qr_hom_cell_init(_grid->cells[i-1]+j-1,\n           q[k-nalign-1][0],q[k-nalign-1][1],q[k-nalign][0],q[k-nalign][1],\n           q[k-1][0],q[k-1][1],q[k][0],q[k][1],\n           p[k-nalign-1][0],p[k-nalign-1][1],p[k-nalign][0],p[k-nalign][1],\n           p[k-1][0],p[k-1][1],p[k][0],p[k][1]);\n        }\n      }\n    }\n    qr_svg_points(\"align\", p, nalign * nalign);\n    free(q);\n    free(p);\n  }\n  /*Set the limits over which each cell is used.*/\n  memcpy(_grid->cell_limits,align_pos+1,\n   (_grid->ncells-1)*sizeof(*_grid->cell_limits));\n  _grid->cell_limits[_grid->ncells-1]=dim;\n  /*Produce a bounding square for the code (to mark finder centers with).\n    Because of non-linear distortion, this might not actually bound the code,\n     but it should be good enough.\n    I don't think it's worth computing a convex hull or anything silly like\n     that.*/\n  qr_hom_cell_project(_p[0],_grid->cells[0]+0,-1,-1,1);\n  qr_hom_cell_project(_p[1],_grid->cells[0]+_grid->ncells-1,(dim<<1)-1,-1,1);\n  qr_hom_cell_project(_p[2],_grid->cells[_grid->ncells-1]+0,-1,(dim<<1)-1,1);\n  qr_hom_cell_project(_p[3],_grid->cells[_grid->ncells-1]+_grid->ncells-1,\n   (dim<<1)-1,(dim<<1)-1,1);\n  /*Clamp the points somewhere near the image (this is really just in case a\n     corner is near the plane at infinity).*/\n  for(i=0;i<4;i++){\n    _p[i][0]=QR_CLAMPI(-_width<<QR_FINDER_SUBPREC,_p[i][0],\n     _width<<QR_FINDER_SUBPREC+1);\n    _p[i][1]=QR_CLAMPI(-_height<<QR_FINDER_SUBPREC,_p[i][1],\n     _height<<QR_FINDER_SUBPREC+1);\n  }\n  /*TODO: Make fine adjustments using the timing patterns.\n    Possible strategy: scan the timing pattern at QR_ALIGN_SUBPREC (or finer)\n     resolution, use dynamic programming to match midpoints between\n     transitions to the ideal grid locations.*/\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*The total number of codewords in a QR code.*/\n", "func_signal": "static int qr_code_ncodewords(unsigned _version)", "code": "{\n  unsigned nalign;\n  /*This is 24-27 instructions on ARM in thumb mode, or a 26-32 byte savings\n     over just using a table (not counting the instructions that would be\n     needed to do the table lookup).*/\n  if(_version==1)return 26;\n  nalign=(_version/7)+2;\n  return (_version<<4)*(_version+8)\n   -(5*nalign)*(5*nalign-2)+36*(_version<7)+83>>3;\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/* verify that format list is in required sort order */\n", "func_signal": "static inline int verify_format_sort (void)", "code": "{\n    int i;\n    for(i = 0; i < num_format_defs; i++) {\n        int j = i * 2 + 1;\n        if((j < num_format_defs &&\n            format_defs[i].format < format_defs[j].format) ||\n           (j + 1 < num_format_defs &&\n            format_defs[j + 1].format < format_defs[i].format))\n            break;\n    }\n    if(i == num_format_defs)\n        return(0);\n\n    /* spew correct order for fix */\n    fprintf(stderr, \"ERROR: image format list is not sorted!?\\n\");\n\n#ifdef DEBUG_CONVERT\n    assert(num_format_defs);\n    uint32_t sorted[num_format_defs];\n    uint32_t ordered[num_format_defs];\n    for(i = 0; i < num_format_defs; i++)\n        sorted[i] = format_defs[i].format;\n    qsort(sorted, num_format_defs, sizeof(uint32_t), intsort);\n    for(i = 0; i < num_format_defs; i = i << 1 | 1);\n    i = (i - 1) / 2;\n    ordered[i] = sorted[0];\n    int j, k;\n    for(j = 1; j < num_format_defs; j++) {\n        k = i * 2 + 2;\n        if(k < num_format_defs) {\n            i = k;\n            for(k = k * 2 + 1; k < num_format_defs; k = k * 2 + 1)\n                i = k;\n        }\n        else {\n            for(k = (i - 1) / 2; i != k * 2 + 1; k = (i - 1) / 2) {\n                assert(i);\n                i = k;\n            }\n            i = k;\n        }\n        ordered[i] = sorted[j];\n    }\n    fprintf(stderr, \"correct sort order is:\");\n    for(i = 0; i < num_format_defs; i++)\n        fprintf(stderr, \" %4.4s\", (char*)&ordered[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    return(-1);\n}", "path": "ZBar/zbar/convert.c", "commit_date": "2010-06-07 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Perform a least-squares line fit to a list of points.\n  At least two points are required.*/\n", "func_signal": "static void qr_line_fit_points(qr_line _l,qr_point *_p,int _np,int _res)", "code": "{\n  int sx;\n  int sy;\n  int xmin;\n  int xmax;\n  int ymin;\n  int ymax;\n  int xbar;\n  int ybar;\n  int dx;\n  int dy;\n  int sxx;\n  int sxy;\n  int syy;\n  int sshift;\n  int sround;\n  int i;\n  sx=sy=0;\n  ymax=xmax=INT_MIN;\n  ymin=xmin=INT_MAX;\n  for(i=0;i<_np;i++){\n    sx+=_p[i][0];\n    xmin=QR_MINI(xmin,_p[i][0]);\n    xmax=QR_MAXI(xmax,_p[i][0]);\n    sy+=_p[i][1];\n    ymin=QR_MINI(ymin,_p[i][1]);\n    ymax=QR_MAXI(ymax,_p[i][1]);\n  }\n  xbar=(sx+(_np>>1))/_np;\n  ybar=(sy+(_np>>1))/_np;\n  sshift=QR_MAXI(0,qr_ilog(_np*QR_MAXI(QR_MAXI(xmax-xbar,xbar-xmin),\n   QR_MAXI(ymax-ybar,ybar-ymin)))-(QR_INT_BITS-1>>1));\n  sround=(1<<sshift)>>1;\n  sxx=sxy=syy=0;\n  for(i=0;i<_np;i++){\n    dx=_p[i][0]-xbar+sround>>sshift;\n    dy=_p[i][1]-ybar+sround>>sshift;\n    sxx+=dx*dx;\n    sxy+=dx*dy;\n    syy+=dy*dy;\n  }\n  qr_line_fit(_l,xbar,ybar,sxx,sxy,syy,_res);\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/* YUV planes to packed RGB\n * FIXME currently ignores color and grayscales the image\n */\n", "func_signal": "static void convert_yuvp_to_rgb (zbar_image_t *dst,\n                                 const zbar_format_def_t *dstfmt,\n                                 const zbar_image_t *src,\n                                 const zbar_format_def_t *srcfmt)", "code": "{\n    uint8_t *dstp, *srcy;\n    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;\n    unsigned long srcm, srcn;\n    unsigned x, y;\n    uint32_t p = 0;\n\n    dst->datalen = dst->width * dst->height * dstfmt->p.rgb.bpp;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n\n    drbits = RGB_SIZE(dstfmt->p.rgb.red);\n    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);\n    dgbits = RGB_SIZE(dstfmt->p.rgb.green);\n    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);\n    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);\n    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);\n\n    srcm = uvp_size(src, srcfmt);\n    srcn = src->width * src->height;\n    assert(src->datalen >= srcn + 2 * srcm);\n    srcy = (void*)src->data;\n\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcy -= src->width;\n        for(x = 0; x < dst->width; x++) {\n            if(x < src->width) {\n                /* FIXME color space? */\n                unsigned y0 = *(srcy++);\n                p = (((y0 >> drbits) << drbit0) |\n                     ((y0 >> dgbits) << dgbit0) |\n                     ((y0 >> dbbits) << dbbit0));\n            }\n            convert_write_rgb(dstp, p, dstfmt->p.rgb.bpp);\n            dstp += dstfmt->p.rgb.bpp;\n        }\n        if(x < src->width)\n            srcy += (src->width - x);\n    }\n}", "path": "ZBar/zbar/convert.c", "commit_date": "2010-06-07 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Arranges the sample bits read by qr_sampling_grid_sample() into bytes and\n   groups those bytes into Reed-Solomon blocks.\n  The individual block pointers are destroyed by this routine.*/\n", "func_signal": "static void qr_samples_unpack(unsigned char **_blocks,int _nblocks,\n int _nshort_data,int _nshort_blocks,const unsigned *_data_bits,\n const unsigned *_fp_mask,int _dim)", "code": "{\n  unsigned bits;\n  int      biti;\n  int      stride;\n  int      blocki;\n  int      blockj;\n  int      i;\n  int      j;\n  stride=_dim+QR_INT_BITS-1>>QR_INT_LOGBITS;\n  /*If _all_ the blocks are short, don't skip anything (see below).*/\n  if(_nshort_blocks>=_nblocks)_nshort_blocks=0;\n  /*Scan columns in pairs from right to left.*/\n  bits=0;\n  for(blocki=blockj=biti=0,j=_dim-1;j>0;j-=2){\n    unsigned data1;\n    unsigned data2;\n    unsigned fp_mask1;\n    unsigned fp_mask2;\n    int      nbits;\n    int      l;\n    /*Scan up a pair of columns.*/\n    nbits=(_dim-1&QR_INT_BITS-1)+1;\n    l=j*stride;\n    for(i=stride;i-->0;){\n      data1=_data_bits[l+i];\n      fp_mask1=_fp_mask[l+i];\n      data2=_data_bits[l+i-stride];\n      fp_mask2=_fp_mask[l+i-stride];\n      while(nbits-->0){\n        /*Pull a bit from the right column.*/\n        if(!(fp_mask1>>nbits&1)){\n          bits=bits<<1|data1>>nbits&1;\n          biti++;\n        }\n        /*Pull a bit from the left column.*/\n        if(!(fp_mask2>>nbits&1)){\n          bits=bits<<1|data2>>nbits&1;\n          biti++;\n        }\n        /*If we finished a byte, drop it in a block.*/\n        if(biti>=8){\n          biti-=8;\n          *_blocks[blocki++]++=(unsigned char)(bits>>biti);\n          /*For whatever reason, the long blocks are at the _end_ of the list,\n             instead of the beginning.\n            Even worse, the extra bytes they get come at the end of the data\n             bytes, before the parity bytes.\n            Hence the logic here: when we've filled up the data portion of the\n             short blocks, skip directly to the long blocks for the next byte.\n            It's also the reason we increment _blocks[blocki] on each store,\n             instead of just indexing with blockj (after this iteration the\n             number of bytes in each block differs).*/\n          if(blocki>=_nblocks)blocki=++blockj==_nshort_data?_nshort_blocks:0;\n        }\n      }\n      nbits=QR_INT_BITS;\n    }\n    j-=2;\n    /*Skip the column with the vertical timing pattern.*/\n    if(j==6)j--;\n    /*Scan down a pair of columns.*/\n    l=j*stride;\n    for(i=0;i<stride;i++){\n      data1=_data_bits[l+i];\n      fp_mask1=_fp_mask[l+i];\n      data2=_data_bits[l+i-stride];\n      fp_mask2=_fp_mask[l+i-stride];\n      nbits=QR_MINI(_dim-(i<<QR_INT_LOGBITS),QR_INT_BITS);\n      while(nbits-->0){\n        /*Pull a bit from the right column.*/\n        if(!(fp_mask1&1)){\n          bits=bits<<1|data1&1;\n          biti++;\n        }\n        data1>>=1;\n        fp_mask1>>=1;\n        /*Pull a bit from the left column.*/\n        if(!(fp_mask2&1)){\n          bits=bits<<1|data2&1;\n          biti++;\n        }\n        data2>>=1;\n        fp_mask2>>=1;\n        /*If we finished a byte, drop it in a block.*/\n        if(biti>=8){\n          biti-=8;\n          *_blocks[blocki++]++=(unsigned char)(bits>>biti);\n          /*See comments on the \"up\" loop for the reason behind this mess.*/\n          if(blocki>=_nblocks)blocki=++blockj==_nshort_data?_nshort_blocks:0;\n        }\n      }\n    }\n  }\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/* packed YUV to packed RGB */\n", "func_signal": "static void convert_yuv_to_rgb (zbar_image_t *dst,\n                                const zbar_format_def_t *dstfmt,\n                                const zbar_image_t *src,\n                                const zbar_format_def_t *srcfmt)", "code": "{\n    uint8_t *dstp;\n    unsigned long dstn = dst->width * dst->height;\n    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;\n    const uint8_t *srcp;\n    unsigned srcl, x, y;\n    uint32_t p = 0;\n\n    dst->datalen = dstn * dstfmt->p.rgb.bpp;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n\n    drbits = RGB_SIZE(dstfmt->p.rgb.red);\n    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);\n    dgbits = RGB_SIZE(dstfmt->p.rgb.green);\n    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);\n    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);\n    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);\n\n    assert(src->datalen >= (src->width * src->height +\n                            uvp_size(src, srcfmt) * 2));\n    srcp = src->data;\n    if(srcfmt->p.yuv.packorder & 2)\n        srcp++;\n\n    assert(srcfmt->p.yuv.xsub2 == 1);\n    srcl = src->width + (src->width >> 1);\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcp -= srcl;\n        for(x = 0; x < dst->width; x++) {\n            if(x < src->width) {\n                uint8_t y0 = *(srcp++);\n                srcp++;\n\n                if(y0 <= 16)\n                    y0 = 0;\n                else if(y0 >= 235)\n                    y0 = 255;\n                else\n                    y0 = (uint16_t)(y0 - 16) * 255 / 219;\n\n                p = (((y0 >> drbits) << drbit0) |\n                     ((y0 >> dgbits) << dgbit0) |\n                     ((y0 >> dbbits) << dbbit0));\n            }\n            convert_write_rgb(dstp, p, dstfmt->p.rgb.bpp);\n            dstp += dstfmt->p.rgb.bpp;\n        }\n        if(x < src->width)\n            srcp += (src->width - x) * 2;\n    }\n}", "path": "ZBar/zbar/convert.c", "commit_date": "2010-06-07 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Mark a given region as belonging to the function pattern.*/\n", "func_signal": "static void qr_sampling_grid_fp_mask_rect(qr_sampling_grid *_grid,int _dim,\n int _u,int _v,int _w,int _h)", "code": "{\n  int i;\n  int j;\n  int stride;\n  stride=_dim+QR_INT_BITS-1>>QR_INT_LOGBITS;\n  /*Note that we store bits column-wise, since that's how they're read out of\n     the grid.*/\n  for(j=_u;j<_u+_w;j++)for(i=_v;i<_v+_h;i++){\n    _grid->fpmask[j*stride+(i>>QR_INT_LOGBITS)]|=1<<(i&QR_INT_BITS-1);\n  }\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Determine if a given grid location is inside the function pattern.*/\n", "func_signal": "static int qr_sampling_grid_is_in_fp(const qr_sampling_grid *_grid,int _dim,\n int _u,int _v)", "code": "{\n  return _grid->fpmask[_u*(_dim+QR_INT_BITS-1>>QR_INT_LOGBITS)\n   +(_v>>QR_INT_LOGBITS)]>>(_v&QR_INT_BITS-1)&1;\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/* the processor api lock is a recursive mutex with added capabilities\n * to completely drop all lock levels before blocking and atomically\n * unblock a waiting set.  the lock is implemented using a variation\n * of the \"specific notification pattern\" [cargill], which makes it\n * easy to provide these features across platforms with consistent,\n * predictable semantics.  probably overkill, but additional overhead\n * associated with this mechanism should fall in the noise, as locks\n * are only exchanged O(frame/image)\n *\n * [cargill]\n * http://www.profcon.com/profcon/cargill/jgf/9809/SpecificNotification.html\n */\n", "func_signal": "static inline proc_waiter_t *proc_waiter_queue (zbar_processor_t *proc)", "code": "{\n    proc_waiter_t *waiter = proc->free_waiter;\n    if(waiter) {\n        proc->free_waiter = waiter->next;\n        waiter->events = 0;\n    }\n    else {\n        waiter = calloc(1, sizeof(proc_waiter_t));\n        _zbar_event_init(&waiter->notify);\n    }\n\n    waiter->next = NULL;\n    waiter->requester = _zbar_thread_self();\n\n    if(proc->wait_head)\n        proc->wait_tail->next = waiter;\n    else\n        proc->wait_head = waiter;\n    proc->wait_tail = waiter;\n    return(waiter);\n}", "path": "ZBar/zbar/processor/lock.c", "commit_date": "2009-10-21 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/*Finish a partial projection, converting from homogeneous coordinates to the\n   normal 2-D representation.\n  In loops, we can avoid many multiplies by computing the homogeneous _x, _y,\n   and _w incrementally, but we cannot avoid the divisions, done here.*/\n", "func_signal": "static void qr_hom_cell_fproject(qr_point _p,const qr_hom_cell *_cell,\n int _x,int _y,int _w)", "code": "{\n  if(_w==0){\n    _p[0]=_x<0?INT_MIN:INT_MAX;\n    _p[1]=_y<0?INT_MIN:INT_MAX;\n  }\n  else{\n    if(_w<0){\n      _x=-_x;\n      _y=-_y;\n      _w=-_w;\n    }\n    _p[0]=QR_DIVROUND(_x,_w)+_cell->x0;\n    _p[1]=QR_DIVROUND(_y,_w)+_cell->y0;\n  }\n}", "path": "ZBar/zbar/qrcode/qrdec.c", "commit_date": "2011-06-30 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/* strcmp */\n", "func_signal": "static int xv_cleanup (zbar_window_t *w)", "code": "{\n    window_state_t *x = w->state;\n    if(x->img.xv) {\n        XFree(x->img.xv);\n        x->img.xv = NULL;\n    }\n    int i;\n    for(i = 0; i < x->num_xv_adaptors; i++)\n        if(x->xv_adaptors[i]) {\n            XvUngrabPort(w->display, x->xv_adaptors[i], CurrentTime);\n            x->xv_adaptors[i] = 0;\n        }\n    free(x->xv_ports);\n    free(x->xv_adaptors);\n    x->xv_ports = NULL;\n    x->num_xv_adaptors = 0;\n    x->xv_adaptors = NULL;\n    return(0);\n}", "path": "ZBar/zbar/window/xv.c", "commit_date": "2009-10-22 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "/* resize y plane, drop extra columns/rows from the right/bottom,\n * or duplicate last column/row to pad missing data\n */\n", "func_signal": "static inline void convert_y_resize (zbar_image_t *dst,\n                                     const zbar_format_def_t *dstfmt,\n                                     const zbar_image_t *src,\n                                     const zbar_format_def_t *srcfmt,\n                                     size_t n)", "code": "{\n    uint8_t *psrc, *pdst;\n    unsigned width, height, xpad, y;\n\n    if(dst->width == src->width && dst->height == src->height) {\n        memcpy((void*)dst->data, src->data, n);\n        return;\n    }\n    psrc = (void*)src->data;\n    pdst = (void*)dst->data;\n    width = (dst->width > src->width) ? src->width : dst->width;\n    xpad = (dst->width > src->width) ? dst->width - src->width : 0;\n    height = (dst->height > src->height) ? src->height : dst->height;\n    for(y = 0; y < height; y++) {\n        memcpy(pdst, psrc, width);\n        pdst += width;\n        psrc += src->width;\n        if(xpad) {\n            memset(pdst, *(psrc - 1), xpad);\n            pdst += xpad;\n        }\n    }\n    psrc -= src->width;\n    for(; y < dst->height; y++) {\n        memcpy(pdst, psrc, width);\n        pdst += width;\n        if(xpad) {\n            memset(pdst, *(psrc - 1), xpad);\n            pdst += xpad;\n        }\n    }\n}", "path": "ZBar/zbar/convert.c", "commit_date": "2010-06-07 00:00:00", "repo_name": "ZBar/ZBar", "stars": 2449, "license": "lgpl-2.1", "language": "c", "size": 4272}
{"docstring": "// -------- func gif.config_decoder.decode_image_config\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__status\nwuffs_gif__config_decoder__decode_image_config(\n    wuffs_gif__config_decoder* self,\n    wuffs_base__image_config* a_dst,\n    wuffs_base__io_buffer* a_src)", "code": "{\n  if (!self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_receiver);\n  }\n  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {\n    return wuffs_base__make_status(\n        (self->private_impl.magic == WUFFS_BASE__DISABLED)\n        ? wuffs_base__error__disabled_by_previous_error\n        : wuffs_base__error__initialize_not_called);\n  }\n  if (!a_src) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__bad_argument);\n  }\n  if ((self->private_impl.active_coroutine != 0) &&\n      (self->private_impl.active_coroutine != 1)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__interleaved_coroutine_calls);\n  }\n  self->private_impl.active_coroutine = 0;\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  bool v_ffio = false;\n\n  uint32_t coro_susp_point = self->private_impl.p_decode_image_config[0];\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    if (self->private_impl.f_call_sequence == 0) {\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);\n      status = wuffs_gif__config_decoder__decode_header(self, a_src);\n      if (status.repr) {\n        goto suspend;\n      }\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);\n      status = wuffs_gif__config_decoder__decode_lsd(self, a_src);\n      if (status.repr) {\n        goto suspend;\n      }\n    } else if (self->private_impl.f_call_sequence != 2) {\n      status = wuffs_base__make_status(wuffs_base__error__bad_call_sequence);\n      goto exit;\n    }\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);\n    status = wuffs_gif__config_decoder__decode_up_to_id_part1(self, a_src);\n    if (status.repr) {\n      goto suspend;\n    }\n    v_ffio =  ! self->private_impl.f_gc_has_transparent_index;\n    if ( ! self->private_impl.f_quirks[2]) {\n      v_ffio = (v_ffio &&\n          (self->private_impl.f_frame_rect_x0 == 0) &&\n          (self->private_impl.f_frame_rect_y0 == 0) &&\n          (self->private_impl.f_frame_rect_x1 == self->private_impl.f_width) &&\n          (self->private_impl.f_frame_rect_y1 == self->private_impl.f_height));\n    } else if (v_ffio) {\n      self->private_impl.f_black_color_u32_argb_premul = 4278190080;\n    }\n    if (self->private_impl.f_background_color_u32_argb_premul == 77) {\n      self->private_impl.f_background_color_u32_argb_premul = self->private_impl.f_black_color_u32_argb_premul;\n    }\n    if (a_dst != NULL) {\n      wuffs_base__image_config__set(\n          a_dst,\n          2198077448,\n          0,\n          self->private_impl.f_width,\n          self->private_impl.f_height,\n          self->private_impl.f_frame_config_io_position,\n          v_ffio);\n    }\n    self->private_impl.f_call_sequence = 3;\n\n    goto ok;\n    ok:\n    self->private_impl.p_decode_image_config[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_decode_image_config[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n  self->private_impl.active_coroutine = wuffs_base__status__is_suspension(&status) ? 1 : 0;\n\n  goto exit;\n  exit:\n  if (wuffs_base__status__is_error(&status)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n  }\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// ---------------- Initializer Implementations\n", "func_signal": "wuffs_base__status WUFFS_BASE__WARN_UNUSED_RESULT\nwuffs_deflate__decoder__initialize(\n    wuffs_deflate__decoder* self,\n    size_t sizeof_star_self,\n    uint64_t wuffs_version,\n    uint32_t options)", "code": "{\n  if (!self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_receiver);\n  }\n  if (sizeof(*self) != sizeof_star_self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_sizeof_receiver);\n  }\n  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||\n      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {\n    return wuffs_base__make_status(wuffs_base__error__bad_wuffs_version);\n  }\n\n  if ((options & WUFFS_INITIALIZE__ALREADY_ZEROED) != 0) {\n    // The whole point of this if-check is to detect an uninitialized *self.\n    // We disable the warning on GCC. Clang-5.0 does not have this warning.\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n    if (self->private_impl.magic != 0) {\n      return wuffs_base__make_status(wuffs_base__error__initialize_falsely_claimed_already_zeroed);\n    }\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n  } else {\n    if ((options & WUFFS_INITIALIZE__LEAVE_INTERNAL_BUFFERS_UNINITIALIZED) == 0) {\n      memset(self, 0, sizeof(*self));\n      options |= WUFFS_INITIALIZE__ALREADY_ZEROED;\n    } else {\n      memset(&(self->private_impl), 0, sizeof(self->private_impl));\n    }\n  }\n\n  self->private_impl.magic = WUFFS_BASE__MAGIC;\n  self->private_impl.vtable_for__wuffs_base__io_transformer.vtable_name =\n      wuffs_base__io_transformer__vtable_name;\n  self->private_impl.vtable_for__wuffs_base__io_transformer.function_pointers =\n      (const void*)(&wuffs_deflate__decoder__func_ptrs_for__wuffs_base__io_transformer);\n  return wuffs_base__make_status(NULL);\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func lzw.decoder.transform_io\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__status\nwuffs_lzw__decoder__transform_io(\n    wuffs_lzw__decoder* self,\n    wuffs_base__io_buffer* a_dst,\n    wuffs_base__io_buffer* a_src,\n    wuffs_base__slice_u8 a_workbuf)", "code": "{\n  if (!self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_receiver);\n  }\n  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {\n    return wuffs_base__make_status(\n        (self->private_impl.magic == WUFFS_BASE__DISABLED)\n        ? wuffs_base__error__disabled_by_previous_error\n        : wuffs_base__error__initialize_not_called);\n  }\n  if (!a_dst || !a_src) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__bad_argument);\n  }\n  if ((self->private_impl.active_coroutine != 0) &&\n      (self->private_impl.active_coroutine != 1)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__interleaved_coroutine_calls);\n  }\n  self->private_impl.active_coroutine = 0;\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  uint32_t v_i = 0;\n\n  uint32_t coro_susp_point = self->private_impl.p_transform_io[0];\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    self->private_impl.f_literal_width = 8;\n    if (self->private_impl.f_set_literal_width_arg > 0) {\n      self->private_impl.f_literal_width = (self->private_impl.f_set_literal_width_arg - 1);\n    }\n    self->private_impl.f_clear_code = (((uint32_t)(1)) << self->private_impl.f_literal_width);\n    self->private_impl.f_end_code = (self->private_impl.f_clear_code + 1);\n    self->private_impl.f_save_code = self->private_impl.f_end_code;\n    self->private_impl.f_prev_code = self->private_impl.f_end_code;\n    self->private_impl.f_width = (self->private_impl.f_literal_width + 1);\n    self->private_impl.f_bits = 0;\n    self->private_impl.f_n_bits = 0;\n    self->private_impl.f_output_ri = 0;\n    self->private_impl.f_output_wi = 0;\n    v_i = 0;\n    while (v_i < self->private_impl.f_clear_code) {\n      self->private_data.f_lm1s[v_i] = 0;\n      self->private_data.f_suffixes[v_i][0] = ((uint8_t)(v_i));\n      v_i += 1;\n    }\n    label__0__continue:;\n    while (true) {\n      wuffs_lzw__decoder__read_from(self, a_src);\n      if (self->private_impl.f_output_wi > 0) {\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);\n        status = wuffs_lzw__decoder__write_to(self, a_dst);\n        if (status.repr) {\n          goto suspend;\n        }\n      }\n      if (self->private_impl.f_read_from_return_value == 0) {\n        goto label__0__break;\n      } else if (self->private_impl.f_read_from_return_value == 1) {\n        goto label__0__continue;\n      } else if (self->private_impl.f_read_from_return_value == 2) {\n        status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(2);\n      } else if (self->private_impl.f_read_from_return_value == 3) {\n        status = wuffs_base__make_status(wuffs_lzw__error__bad_code);\n        goto exit;\n      } else {\n        status = wuffs_base__make_status(wuffs_lzw__error__internal_error_inconsistent_i_o);\n        goto exit;\n      }\n    }\n    label__0__break:;\n\n    goto ok;\n    ok:\n    self->private_impl.p_transform_io[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_transform_io[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n  self->private_impl.active_coroutine = wuffs_base__status__is_suspension(&status) ? 1 : 0;\n\n  goto exit;\n  exit:\n  if (wuffs_base__status__is_error(&status)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n  }\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func zlib.decoder.dictionary_id\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC uint32_t\nwuffs_zlib__decoder__dictionary_id(\n    const wuffs_zlib__decoder* self)", "code": "{\n  if (!self) {\n    return 0;\n  }\n  if ((self->private_impl.magic != WUFFS_BASE__MAGIC) &&\n      (self->private_impl.magic != WUFFS_BASE__DISABLED)) {\n    return 0;\n  }\n\n  return self->private_impl.f_dict_id_want;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// ---------------- Initializer Implementations\n", "func_signal": "wuffs_base__status WUFFS_BASE__WARN_UNUSED_RESULT\nwuffs_lzw__decoder__initialize(\n    wuffs_lzw__decoder* self,\n    size_t sizeof_star_self,\n    uint64_t wuffs_version,\n    uint32_t options)", "code": "{\n  if (!self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_receiver);\n  }\n  if (sizeof(*self) != sizeof_star_self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_sizeof_receiver);\n  }\n  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||\n      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {\n    return wuffs_base__make_status(wuffs_base__error__bad_wuffs_version);\n  }\n\n  if ((options & WUFFS_INITIALIZE__ALREADY_ZEROED) != 0) {\n    // The whole point of this if-check is to detect an uninitialized *self.\n    // We disable the warning on GCC. Clang-5.0 does not have this warning.\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n    if (self->private_impl.magic != 0) {\n      return wuffs_base__make_status(wuffs_base__error__initialize_falsely_claimed_already_zeroed);\n    }\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n  } else {\n    if ((options & WUFFS_INITIALIZE__LEAVE_INTERNAL_BUFFERS_UNINITIALIZED) == 0) {\n      memset(self, 0, sizeof(*self));\n      options |= WUFFS_INITIALIZE__ALREADY_ZEROED;\n    } else {\n      memset(&(self->private_impl), 0, sizeof(self->private_impl));\n    }\n  }\n\n  self->private_impl.magic = WUFFS_BASE__MAGIC;\n  self->private_impl.vtable_for__wuffs_base__io_transformer.vtable_name =\n      wuffs_base__io_transformer__vtable_name;\n  self->private_impl.vtable_for__wuffs_base__io_transformer.function_pointers =\n      (const void*)(&wuffs_lzw__decoder__func_ptrs_for__wuffs_base__io_transformer);\n  return wuffs_base__make_status(NULL);\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func gif.decoder.tell_me_more\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__status\nwuffs_gif__decoder__tell_me_more(\n    wuffs_gif__decoder* self,\n    wuffs_base__io_buffer* a_dst,\n    wuffs_base__more_information* a_minfo,\n    wuffs_base__io_buffer* a_src)", "code": "{\n  if (!self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_receiver);\n  }\n  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {\n    return wuffs_base__make_status(\n        (self->private_impl.magic == WUFFS_BASE__DISABLED)\n        ? wuffs_base__error__disabled_by_previous_error\n        : wuffs_base__error__initialize_not_called);\n  }\n  if (!a_dst || !a_src) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__bad_argument);\n  }\n  if ((self->private_impl.active_coroutine != 0) &&\n      (self->private_impl.active_coroutine != 2)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__interleaved_coroutine_calls);\n  }\n  self->private_impl.active_coroutine = 0;\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  uint64_t v_chunk_length = 0;\n\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  uint32_t coro_susp_point = self->private_impl.p_tell_me_more[0];\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    if (self->private_impl.f_call_sequence != 1) {\n      status = wuffs_base__make_status(wuffs_base__error__bad_call_sequence);\n      goto exit;\n    }\n    if (self->private_impl.f_metadata_fourcc == 0) {\n      status = wuffs_base__make_status(wuffs_base__error__no_more_information);\n      goto exit;\n    }\n    while (true) {\n      label__0__continue:;\n      while (true) {\n        if (wuffs_base__u64__sat_add(a_src->meta.pos, ((uint64_t)(iop_a_src - io0_a_src))) != self->private_impl.f_metadata_io_position) {\n          if (a_minfo != NULL) {\n            wuffs_base__more_information__set(a_minfo,\n                2,\n                0,\n                self->private_impl.f_metadata_io_position,\n                0,\n                0);\n          }\n          status = wuffs_base__make_status(wuffs_base__suspension__mispositioned_read);\n          WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(1);\n          goto label__0__continue;\n        }\n        if (((uint64_t)(io2_a_src - iop_a_src)) <= 0) {\n          if (a_minfo != NULL) {\n            wuffs_base__more_information__set(a_minfo,\n                0,\n                0,\n                0,\n                0,\n                0);\n          }\n          status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n          WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(2);\n          goto label__0__continue;\n        }\n        goto label__0__break;\n      }\n      label__0__break:;\n      v_chunk_length = ((uint64_t)(wuffs_base__load_u8be__no_bounds_check(iop_a_src)));\n      if (v_chunk_length <= 0) {\n        (iop_a_src += 1, wuffs_base__make_empty_struct());\n        goto label__1__break;\n      }\n      if (self->private_impl.f_metadata_fourcc == 1481461792) {\n        v_chunk_length += 1;\n      } else {\n        (iop_a_src += 1, wuffs_base__make_empty_struct());\n      }\n      self->private_impl.f_metadata_io_position = wuffs_base__u64__sat_add(wuffs_base__u64__sat_add(a_src->meta.pos, ((uint64_t)(iop_a_src - io0_a_src))), v_chunk_length);\n      if (a_minfo != NULL) {\n        wuffs_base__more_information__set(a_minfo,\n            3,\n            self->private_impl.f_metadata_fourcc,\n            0,\n            wuffs_base__u64__sat_add(a_src->meta.pos, ((uint64_t)(iop_a_src - io0_a_src))),\n            self->private_impl.f_metadata_io_position);\n      }\n      status = wuffs_base__make_status(wuffs_base__suspension__even_more_information);\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);\n    }\n    label__1__break:;\n    if (a_minfo != NULL) {\n      wuffs_base__more_information__set(a_minfo,\n          3,\n          self->private_impl.f_metadata_fourcc,\n          0,\n          self->private_impl.f_metadata_io_position,\n          self->private_impl.f_metadata_io_position);\n    }\n    self->private_impl.f_call_sequence = 2;\n    self->private_impl.f_metadata_fourcc = 0;\n    self->private_impl.f_metadata_io_position = 0;\n    status = wuffs_base__make_status(NULL);\n    goto ok;\n\n    goto ok;\n    ok:\n    self->private_impl.p_tell_me_more[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_tell_me_more[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n  self->private_impl.active_coroutine = wuffs_base__status__is_suspension(&status) ? 2 : 0;\n\n  goto exit;\n  exit:\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  if (wuffs_base__status__is_error(&status)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n  }\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func crc32.ieee_hasher.update_u32\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC uint32_t\nwuffs_crc32__ieee_hasher__update_u32(\n    wuffs_crc32__ieee_hasher* self,\n    wuffs_base__slice_u8 a_x)", "code": "{\n  if (!self) {\n    return 0;\n  }\n  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {\n    return 0;\n  }\n\n  uint32_t v_s = 0;\n  wuffs_base__slice_u8 v_p = {0};\n\n  v_s = (4294967295 ^ self->private_impl.f_state);\n  {\n    wuffs_base__slice_u8 i_slice_p = a_x;\n    v_p = i_slice_p;\n    v_p.len = 16;\n    uint8_t* i_end0_p = i_slice_p.ptr + (i_slice_p.len / 32) * 32;\n    while (v_p.ptr < i_end0_p) {\n      v_s ^= ((((uint32_t)(v_p.ptr[0])) << 0) |\n          (((uint32_t)(v_p.ptr[1])) << 8) |\n          (((uint32_t)(v_p.ptr[2])) << 16) |\n          (((uint32_t)(v_p.ptr[3])) << 24));\n      v_s = (WUFFS_CRC32__IEEE_TABLE[0][v_p.ptr[15]] ^\n          WUFFS_CRC32__IEEE_TABLE[1][v_p.ptr[14]] ^\n          WUFFS_CRC32__IEEE_TABLE[2][v_p.ptr[13]] ^\n          WUFFS_CRC32__IEEE_TABLE[3][v_p.ptr[12]] ^\n          WUFFS_CRC32__IEEE_TABLE[4][v_p.ptr[11]] ^\n          WUFFS_CRC32__IEEE_TABLE[5][v_p.ptr[10]] ^\n          WUFFS_CRC32__IEEE_TABLE[6][v_p.ptr[9]] ^\n          WUFFS_CRC32__IEEE_TABLE[7][v_p.ptr[8]] ^\n          WUFFS_CRC32__IEEE_TABLE[8][v_p.ptr[7]] ^\n          WUFFS_CRC32__IEEE_TABLE[9][v_p.ptr[6]] ^\n          WUFFS_CRC32__IEEE_TABLE[10][v_p.ptr[5]] ^\n          WUFFS_CRC32__IEEE_TABLE[11][v_p.ptr[4]] ^\n          WUFFS_CRC32__IEEE_TABLE[12][(255 & (v_s >> 24))] ^\n          WUFFS_CRC32__IEEE_TABLE[13][(255 & (v_s >> 16))] ^\n          WUFFS_CRC32__IEEE_TABLE[14][(255 & (v_s >> 8))] ^\n          WUFFS_CRC32__IEEE_TABLE[15][(255 & (v_s >> 0))]);\n      v_p.ptr += 16;\n      v_s ^= ((((uint32_t)(v_p.ptr[0])) << 0) |\n          (((uint32_t)(v_p.ptr[1])) << 8) |\n          (((uint32_t)(v_p.ptr[2])) << 16) |\n          (((uint32_t)(v_p.ptr[3])) << 24));\n      v_s = (WUFFS_CRC32__IEEE_TABLE[0][v_p.ptr[15]] ^\n          WUFFS_CRC32__IEEE_TABLE[1][v_p.ptr[14]] ^\n          WUFFS_CRC32__IEEE_TABLE[2][v_p.ptr[13]] ^\n          WUFFS_CRC32__IEEE_TABLE[3][v_p.ptr[12]] ^\n          WUFFS_CRC32__IEEE_TABLE[4][v_p.ptr[11]] ^\n          WUFFS_CRC32__IEEE_TABLE[5][v_p.ptr[10]] ^\n          WUFFS_CRC32__IEEE_TABLE[6][v_p.ptr[9]] ^\n          WUFFS_CRC32__IEEE_TABLE[7][v_p.ptr[8]] ^\n          WUFFS_CRC32__IEEE_TABLE[8][v_p.ptr[7]] ^\n          WUFFS_CRC32__IEEE_TABLE[9][v_p.ptr[6]] ^\n          WUFFS_CRC32__IEEE_TABLE[10][v_p.ptr[5]] ^\n          WUFFS_CRC32__IEEE_TABLE[11][v_p.ptr[4]] ^\n          WUFFS_CRC32__IEEE_TABLE[12][(255 & (v_s >> 24))] ^\n          WUFFS_CRC32__IEEE_TABLE[13][(255 & (v_s >> 16))] ^\n          WUFFS_CRC32__IEEE_TABLE[14][(255 & (v_s >> 8))] ^\n          WUFFS_CRC32__IEEE_TABLE[15][(255 & (v_s >> 0))]);\n      v_p.ptr += 16;\n    }\n    v_p.len = 16;\n    uint8_t* i_end1_p = i_slice_p.ptr + (i_slice_p.len / 16) * 16;\n    while (v_p.ptr < i_end1_p) {\n      v_s ^= ((((uint32_t)(v_p.ptr[0])) << 0) |\n          (((uint32_t)(v_p.ptr[1])) << 8) |\n          (((uint32_t)(v_p.ptr[2])) << 16) |\n          (((uint32_t)(v_p.ptr[3])) << 24));\n      v_s = (WUFFS_CRC32__IEEE_TABLE[0][v_p.ptr[15]] ^\n          WUFFS_CRC32__IEEE_TABLE[1][v_p.ptr[14]] ^\n          WUFFS_CRC32__IEEE_TABLE[2][v_p.ptr[13]] ^\n          WUFFS_CRC32__IEEE_TABLE[3][v_p.ptr[12]] ^\n          WUFFS_CRC32__IEEE_TABLE[4][v_p.ptr[11]] ^\n          WUFFS_CRC32__IEEE_TABLE[5][v_p.ptr[10]] ^\n          WUFFS_CRC32__IEEE_TABLE[6][v_p.ptr[9]] ^\n          WUFFS_CRC32__IEEE_TABLE[7][v_p.ptr[8]] ^\n          WUFFS_CRC32__IEEE_TABLE[8][v_p.ptr[7]] ^\n          WUFFS_CRC32__IEEE_TABLE[9][v_p.ptr[6]] ^\n          WUFFS_CRC32__IEEE_TABLE[10][v_p.ptr[5]] ^\n          WUFFS_CRC32__IEEE_TABLE[11][v_p.ptr[4]] ^\n          WUFFS_CRC32__IEEE_TABLE[12][(255 & (v_s >> 24))] ^\n          WUFFS_CRC32__IEEE_TABLE[13][(255 & (v_s >> 16))] ^\n          WUFFS_CRC32__IEEE_TABLE[14][(255 & (v_s >> 8))] ^\n          WUFFS_CRC32__IEEE_TABLE[15][(255 & (v_s >> 0))]);\n      v_p.ptr += 16;\n    }\n    v_p.len = 1;\n    uint8_t* i_end2_p = i_slice_p.ptr + (i_slice_p.len / 1) * 1;\n    while (v_p.ptr < i_end2_p) {\n      v_s = (WUFFS_CRC32__IEEE_TABLE[0][(((uint8_t)((v_s & 255))) ^ v_p.ptr[0])] ^ (v_s >> 8));\n      v_p.ptr += 1;\n    }\n  }\n  self->private_impl.f_state = (4294967295 ^ v_s);\n  return self->private_impl.f_state;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func gif.config_decoder.skip_blocks\n", "func_signal": "static wuffs_base__status\nwuffs_gif__config_decoder__skip_blocks(\n    wuffs_gif__config_decoder* self,\n    wuffs_base__io_buffer* a_src)", "code": "{\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  uint8_t v_block_size = 0;\n\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  uint32_t coro_susp_point = self->private_impl.p_skip_blocks[0];\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    while (true) {\n      {\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);\n        if (WUFFS_BASE__UNLIKELY(iop_a_src == io2_a_src)) {\n          status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n          goto suspend;\n        }\n        uint8_t t_0 = *iop_a_src++;\n        v_block_size = t_0;\n      }\n      if (v_block_size == 0) {\n        status = wuffs_base__make_status(NULL);\n        goto ok;\n      }\n      self->private_data.s_skip_blocks[0].scratch = ((uint32_t)(v_block_size));\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);\n      if (self->private_data.s_skip_blocks[0].scratch > ((uint64_t)(io2_a_src - iop_a_src))) {\n        self->private_data.s_skip_blocks[0].scratch -= ((uint64_t)(io2_a_src - iop_a_src));\n        iop_a_src = io2_a_src;\n        status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n        goto suspend;\n      }\n      iop_a_src += self->private_data.s_skip_blocks[0].scratch;\n    }\n\n    goto ok;\n    ok:\n    self->private_impl.p_skip_blocks[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_skip_blocks[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n\n  goto exit;\n  exit:\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func wbmp.decoder.decode_frame\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__status\nwuffs_wbmp__decoder__decode_frame(\n    wuffs_wbmp__decoder* self,\n    wuffs_base__pixel_buffer* a_dst,\n    wuffs_base__io_buffer* a_src,\n    wuffs_base__pixel_blend a_blend,\n    wuffs_base__slice_u8 a_workbuf,\n    wuffs_base__decode_frame_options* a_opts)", "code": "{\n  if (!self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_receiver);\n  }\n  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {\n    return wuffs_base__make_status(\n        (self->private_impl.magic == WUFFS_BASE__DISABLED)\n        ? wuffs_base__error__disabled_by_previous_error\n        : wuffs_base__error__initialize_not_called);\n  }\n  if (!a_dst || !a_src) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__bad_argument);\n  }\n  if ((self->private_impl.active_coroutine != 0) &&\n      (self->private_impl.active_coroutine != 3)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__interleaved_coroutine_calls);\n  }\n  self->private_impl.active_coroutine = 0;\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  wuffs_base__status v_status = wuffs_base__make_status(NULL);\n  wuffs_base__pixel_format v_dst_pixfmt = {0};\n  uint32_t v_dst_bits_per_pixel = 0;\n  uint64_t v_dst_bytes_per_pixel = 0;\n  uint64_t v_dst_x_in_bytes = 0;\n  uint32_t v_dst_x = 0;\n  uint32_t v_dst_y = 0;\n  wuffs_base__table_u8 v_tab = {0};\n  wuffs_base__slice_u8 v_dst = {0};\n  uint8_t v_src[1] = {0};\n  uint8_t v_c = 0;\n\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  uint32_t coro_susp_point = self->private_impl.p_decode_frame[0];\n  if (coro_susp_point) {\n    v_dst_bytes_per_pixel = self->private_data.s_decode_frame[0].v_dst_bytes_per_pixel;\n    v_dst_x = self->private_data.s_decode_frame[0].v_dst_x;\n    v_dst_y = self->private_data.s_decode_frame[0].v_dst_y;\n    memcpy(v_src, self->private_data.s_decode_frame[0].v_src, sizeof(v_src));\n    v_c = self->private_data.s_decode_frame[0].v_c;\n  }\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    if (self->private_impl.f_call_sequence < 2) {\n      if (a_src) {\n        a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n      }\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);\n      status = wuffs_wbmp__decoder__decode_frame_config(self, NULL, a_src);\n      if (a_src) {\n        iop_a_src = a_src->data.ptr + a_src->meta.ri;\n      }\n      if (status.repr) {\n        goto suspend;\n      }\n    } else if (self->private_impl.f_call_sequence == 2) {\n    } else {\n      status = wuffs_base__make_status(wuffs_base__note__end_of_data);\n      goto ok;\n    }\n    v_status = wuffs_base__pixel_swizzler__prepare(&self->private_impl.f_swizzler,\n        wuffs_base__pixel_buffer__pixel_format(a_dst),\n        wuffs_base__pixel_buffer__palette(a_dst),\n        wuffs_base__utility__make_pixel_format(536870920),\n        wuffs_base__utility__empty_slice_u8(),\n        a_blend);\n    if ( ! wuffs_base__status__is_ok(&v_status)) {\n      status = v_status;\n      if (wuffs_base__status__is_error(&status)) {\n        goto exit;\n      } else if (wuffs_base__status__is_suspension(&status)) {\n        status = wuffs_base__make_status(wuffs_base__error__cannot_return_a_suspension);\n        goto exit;\n      }\n      goto ok;\n    }\n    v_dst_pixfmt = wuffs_base__pixel_buffer__pixel_format(a_dst);\n    v_dst_bits_per_pixel = wuffs_base__pixel_format__bits_per_pixel(&v_dst_pixfmt);\n    if ((v_dst_bits_per_pixel & 7) != 0) {\n      status = wuffs_base__make_status(wuffs_base__error__unsupported_option);\n      goto exit;\n    }\n    v_dst_bytes_per_pixel = ((uint64_t)((v_dst_bits_per_pixel / 8)));\n    if (self->private_impl.f_width > 0) {\n      v_tab = wuffs_base__pixel_buffer__plane(a_dst, 0);\n      while (v_dst_y < self->private_impl.f_height) {\n        v_dst = wuffs_base__table_u8__row(v_tab, v_dst_y);\n        v_dst_x = 0;\n        while (v_dst_x < self->private_impl.f_width) {\n          if ((v_dst_x & 7) == 0) {\n            while (((uint64_t)(io2_a_src - iop_a_src)) <= 0) {\n              status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n              WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(2);\n              v_tab = wuffs_base__pixel_buffer__plane(a_dst, 0);\n              v_dst = wuffs_base__table_u8__row(v_tab, v_dst_y);\n              v_dst_x_in_bytes = (((uint64_t)(v_dst_x)) * v_dst_bytes_per_pixel);\n              if (v_dst_x_in_bytes <= ((uint64_t)(v_dst.len))) {\n                v_dst = wuffs_base__slice_u8__subslice_i(v_dst, v_dst_x_in_bytes);\n              }\n            }\n            v_c = wuffs_base__load_u8be__no_bounds_check(iop_a_src);\n            (iop_a_src += 1, wuffs_base__make_empty_struct());\n          }\n          if ((v_c & 128) == 0) {\n            v_src[0] = 0;\n          } else {\n            v_src[0] = 255;\n          }\n          v_c = ((uint8_t)(((((uint32_t)(v_c)) << 1) & 255)));\n          wuffs_base__pixel_swizzler__swizzle_interleaved_from_slice(&self->private_impl.f_swizzler, v_dst, wuffs_base__utility__empty_slice_u8(), wuffs_base__make_slice_u8(v_src, 1));\n          if (v_dst_bytes_per_pixel <= ((uint64_t)(v_dst.len))) {\n            v_dst = wuffs_base__slice_u8__subslice_i(v_dst, v_dst_bytes_per_pixel);\n          }\n          v_dst_x += 1;\n        }\n        v_dst_y += 1;\n      }\n    }\n    self->private_impl.f_call_sequence = 3;\n\n    goto ok;\n    ok:\n    self->private_impl.p_decode_frame[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_decode_frame[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n  self->private_impl.active_coroutine = wuffs_base__status__is_suspension(&status) ? 3 : 0;\n  self->private_data.s_decode_frame[0].v_dst_bytes_per_pixel = v_dst_bytes_per_pixel;\n  self->private_data.s_decode_frame[0].v_dst_x = v_dst_x;\n  self->private_data.s_decode_frame[0].v_dst_y = v_dst_y;\n  memcpy(self->private_data.s_decode_frame[0].v_src, v_src, sizeof(v_src));\n  self->private_data.s_decode_frame[0].v_c = v_c;\n\n  goto exit;\n  exit:\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  if (wuffs_base__status__is_error(&status)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n  }\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func bmp.decoder.swizzle_low_bit_depth\n", "func_signal": "static wuffs_base__status\nwuffs_bmp__decoder__swizzle_low_bit_depth(\n    wuffs_bmp__decoder* self,\n    wuffs_base__pixel_buffer* a_dst,\n    wuffs_base__io_buffer* a_src)", "code": "{\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  wuffs_base__pixel_format v_dst_pixfmt = {0};\n  uint32_t v_dst_bits_per_pixel = 0;\n  uint64_t v_dst_bytes_per_pixel = 0;\n  uint64_t v_dst_bytes_per_row = 0;\n  wuffs_base__slice_u8 v_dst_palette = {0};\n  wuffs_base__table_u8 v_tab = {0};\n  wuffs_base__slice_u8 v_dst = {0};\n  uint64_t v_i = 0;\n  uint64_t v_n = 0;\n  uint32_t v_p0 = 0;\n  uint32_t v_chunk_bits = 0;\n  uint32_t v_chunk_count = 0;\n\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  v_dst_pixfmt = wuffs_base__pixel_buffer__pixel_format(a_dst);\n  v_dst_bits_per_pixel = wuffs_base__pixel_format__bits_per_pixel(&v_dst_pixfmt);\n  if ((v_dst_bits_per_pixel & 7) != 0) {\n    status = wuffs_base__make_status(wuffs_base__error__unsupported_option);\n    goto exit;\n  }\n  v_dst_bytes_per_pixel = ((uint64_t)((v_dst_bits_per_pixel / 8)));\n  v_dst_bytes_per_row = (((uint64_t)(self->private_impl.f_width)) * v_dst_bytes_per_pixel);\n  v_dst_palette = wuffs_base__pixel_buffer__palette_or_else(a_dst, wuffs_base__make_slice_u8((self->private_data.f_scratch) + 1024, 1024));\n  v_tab = wuffs_base__pixel_buffer__plane(a_dst, 0);\n  label__loop__continue:;\n  while (true) {\n    if (self->private_impl.f_dst_x == self->private_impl.f_width) {\n      self->private_impl.f_dst_x = 0;\n      self->private_impl.f_dst_y += self->private_impl.f_dst_y_inc;\n      if (self->private_impl.f_dst_y >= self->private_impl.f_height) {\n        goto label__loop__break;\n      }\n    }\n    v_dst = wuffs_base__table_u8__row(v_tab, self->private_impl.f_dst_y);\n    if (v_dst_bytes_per_row < ((uint64_t)(v_dst.len))) {\n      v_dst = wuffs_base__slice_u8__subslice_j(v_dst, v_dst_bytes_per_row);\n    }\n    v_i = (((uint64_t)(self->private_impl.f_dst_x)) * v_dst_bytes_per_pixel);\n    if (v_i >= ((uint64_t)(v_dst.len))) {\n      goto label__loop__continue;\n    }\n    v_dst = wuffs_base__slice_u8__subslice_i(v_dst, v_i);\n    v_p0 = 0;\n    if (self->private_impl.f_bits_per_pixel == 1) {\n      v_chunk_count = ((wuffs_base__u32__sat_sub(self->private_impl.f_width, self->private_impl.f_dst_x) + 31) / 32);\n      v_chunk_count = wuffs_base__u32__min(v_chunk_count, 16);\n      while ((v_chunk_count > 0) && (((uint64_t)(io2_a_src - iop_a_src)) >= 4)) {\n        v_chunk_bits = wuffs_base__load_u32be__no_bounds_check(iop_a_src);\n        (iop_a_src += 4, wuffs_base__make_empty_struct());\n        self->private_data.f_scratch[(v_p0 + 0)] = ((uint8_t)((1 & (v_chunk_bits >> 31))));\n        self->private_data.f_scratch[(v_p0 + 1)] = ((uint8_t)((1 & (v_chunk_bits >> 30))));\n        self->private_data.f_scratch[(v_p0 + 2)] = ((uint8_t)((1 & (v_chunk_bits >> 29))));\n        self->private_data.f_scratch[(v_p0 + 3)] = ((uint8_t)((1 & (v_chunk_bits >> 28))));\n        self->private_data.f_scratch[(v_p0 + 4)] = ((uint8_t)((1 & (v_chunk_bits >> 27))));\n        self->private_data.f_scratch[(v_p0 + 5)] = ((uint8_t)((1 & (v_chunk_bits >> 26))));\n        self->private_data.f_scratch[(v_p0 + 6)] = ((uint8_t)((1 & (v_chunk_bits >> 25))));\n        self->private_data.f_scratch[(v_p0 + 7)] = ((uint8_t)((1 & (v_chunk_bits >> 24))));\n        self->private_data.f_scratch[(v_p0 + 8)] = ((uint8_t)((1 & (v_chunk_bits >> 23))));\n        self->private_data.f_scratch[(v_p0 + 9)] = ((uint8_t)((1 & (v_chunk_bits >> 22))));\n        self->private_data.f_scratch[(v_p0 + 10)] = ((uint8_t)((1 & (v_chunk_bits >> 21))));\n        self->private_data.f_scratch[(v_p0 + 11)] = ((uint8_t)((1 & (v_chunk_bits >> 20))));\n        self->private_data.f_scratch[(v_p0 + 12)] = ((uint8_t)((1 & (v_chunk_bits >> 19))));\n        self->private_data.f_scratch[(v_p0 + 13)] = ((uint8_t)((1 & (v_chunk_bits >> 18))));\n        self->private_data.f_scratch[(v_p0 + 14)] = ((uint8_t)((1 & (v_chunk_bits >> 17))));\n        self->private_data.f_scratch[(v_p0 + 15)] = ((uint8_t)((1 & (v_chunk_bits >> 16))));\n        self->private_data.f_scratch[(v_p0 + 16)] = ((uint8_t)((1 & (v_chunk_bits >> 15))));\n        self->private_data.f_scratch[(v_p0 + 17)] = ((uint8_t)((1 & (v_chunk_bits >> 14))));\n        self->private_data.f_scratch[(v_p0 + 18)] = ((uint8_t)((1 & (v_chunk_bits >> 13))));\n        self->private_data.f_scratch[(v_p0 + 19)] = ((uint8_t)((1 & (v_chunk_bits >> 12))));\n        self->private_data.f_scratch[(v_p0 + 20)] = ((uint8_t)((1 & (v_chunk_bits >> 11))));\n        self->private_data.f_scratch[(v_p0 + 21)] = ((uint8_t)((1 & (v_chunk_bits >> 10))));\n        self->private_data.f_scratch[(v_p0 + 22)] = ((uint8_t)((1 & (v_chunk_bits >> 9))));\n        self->private_data.f_scratch[(v_p0 + 23)] = ((uint8_t)((1 & (v_chunk_bits >> 8))));\n        self->private_data.f_scratch[(v_p0 + 24)] = ((uint8_t)((1 & (v_chunk_bits >> 7))));\n        self->private_data.f_scratch[(v_p0 + 25)] = ((uint8_t)((1 & (v_chunk_bits >> 6))));\n        self->private_data.f_scratch[(v_p0 + 26)] = ((uint8_t)((1 & (v_chunk_bits >> 5))));\n        self->private_data.f_scratch[(v_p0 + 27)] = ((uint8_t)((1 & (v_chunk_bits >> 4))));\n        self->private_data.f_scratch[(v_p0 + 28)] = ((uint8_t)((1 & (v_chunk_bits >> 3))));\n        self->private_data.f_scratch[(v_p0 + 29)] = ((uint8_t)((1 & (v_chunk_bits >> 2))));\n        self->private_data.f_scratch[(v_p0 + 30)] = ((uint8_t)((1 & (v_chunk_bits >> 1))));\n        self->private_data.f_scratch[(v_p0 + 31)] = ((uint8_t)((1 & (v_chunk_bits >> 0))));\n        v_p0 = ((v_p0 & 511) + 32);\n        v_chunk_count -= 1;\n      }\n    } else if (self->private_impl.f_bits_per_pixel == 2) {\n      v_chunk_count = ((wuffs_base__u32__sat_sub(self->private_impl.f_width, self->private_impl.f_dst_x) + 15) / 16);\n      v_chunk_count = wuffs_base__u32__min(v_chunk_count, 32);\n      while ((v_chunk_count > 0) && (((uint64_t)(io2_a_src - iop_a_src)) >= 4)) {\n        v_chunk_bits = wuffs_base__load_u32be__no_bounds_check(iop_a_src);\n        (iop_a_src += 4, wuffs_base__make_empty_struct());\n        self->private_data.f_scratch[(v_p0 + 0)] = ((uint8_t)((3 & (v_chunk_bits >> 30))));\n        self->private_data.f_scratch[(v_p0 + 1)] = ((uint8_t)((3 & (v_chunk_bits >> 28))));\n        self->private_data.f_scratch[(v_p0 + 2)] = ((uint8_t)((3 & (v_chunk_bits >> 26))));\n        self->private_data.f_scratch[(v_p0 + 3)] = ((uint8_t)((3 & (v_chunk_bits >> 24))));\n        self->private_data.f_scratch[(v_p0 + 4)] = ((uint8_t)((3 & (v_chunk_bits >> 22))));\n        self->private_data.f_scratch[(v_p0 + 5)] = ((uint8_t)((3 & (v_chunk_bits >> 20))));\n        self->private_data.f_scratch[(v_p0 + 6)] = ((uint8_t)((3 & (v_chunk_bits >> 18))));\n        self->private_data.f_scratch[(v_p0 + 7)] = ((uint8_t)((3 & (v_chunk_bits >> 16))));\n        self->private_data.f_scratch[(v_p0 + 8)] = ((uint8_t)((3 & (v_chunk_bits >> 14))));\n        self->private_data.f_scratch[(v_p0 + 9)] = ((uint8_t)((3 & (v_chunk_bits >> 12))));\n        self->private_data.f_scratch[(v_p0 + 10)] = ((uint8_t)((3 & (v_chunk_bits >> 10))));\n        self->private_data.f_scratch[(v_p0 + 11)] = ((uint8_t)((3 & (v_chunk_bits >> 8))));\n        self->private_data.f_scratch[(v_p0 + 12)] = ((uint8_t)((3 & (v_chunk_bits >> 6))));\n        self->private_data.f_scratch[(v_p0 + 13)] = ((uint8_t)((3 & (v_chunk_bits >> 4))));\n        self->private_data.f_scratch[(v_p0 + 14)] = ((uint8_t)((3 & (v_chunk_bits >> 2))));\n        self->private_data.f_scratch[(v_p0 + 15)] = ((uint8_t)((3 & (v_chunk_bits >> 0))));\n        v_p0 = ((v_p0 & 511) + 16);\n        v_chunk_count -= 1;\n      }\n    } else if (self->private_impl.f_bits_per_pixel == 4) {\n      v_chunk_count = ((wuffs_base__u32__sat_sub(self->private_impl.f_width, self->private_impl.f_dst_x) + 7) / 8);\n      v_chunk_count = wuffs_base__u32__min(v_chunk_count, 64);\n      while ((v_chunk_count > 0) && (((uint64_t)(io2_a_src - iop_a_src)) >= 4)) {\n        v_chunk_bits = wuffs_base__load_u32be__no_bounds_check(iop_a_src);\n        (iop_a_src += 4, wuffs_base__make_empty_struct());\n        self->private_data.f_scratch[(v_p0 + 0)] = ((uint8_t)((15 & (v_chunk_bits >> 28))));\n        self->private_data.f_scratch[(v_p0 + 1)] = ((uint8_t)((15 & (v_chunk_bits >> 24))));\n        self->private_data.f_scratch[(v_p0 + 2)] = ((uint8_t)((15 & (v_chunk_bits >> 20))));\n        self->private_data.f_scratch[(v_p0 + 3)] = ((uint8_t)((15 & (v_chunk_bits >> 16))));\n        self->private_data.f_scratch[(v_p0 + 4)] = ((uint8_t)((15 & (v_chunk_bits >> 12))));\n        self->private_data.f_scratch[(v_p0 + 5)] = ((uint8_t)((15 & (v_chunk_bits >> 8))));\n        self->private_data.f_scratch[(v_p0 + 6)] = ((uint8_t)((15 & (v_chunk_bits >> 4))));\n        self->private_data.f_scratch[(v_p0 + 7)] = ((uint8_t)((15 & (v_chunk_bits >> 0))));\n        v_p0 = ((v_p0 & 511) + 8);\n        v_chunk_count -= 1;\n      }\n    }\n    v_p0 = wuffs_base__u32__min(v_p0, wuffs_base__u32__sat_sub(self->private_impl.f_width, self->private_impl.f_dst_x));\n    v_n = wuffs_base__pixel_swizzler__swizzle_interleaved_from_slice(&self->private_impl.f_swizzler, v_dst, v_dst_palette, wuffs_base__slice_u8__subslice_j(wuffs_base__make_slice_u8(self->private_data.f_scratch, 2048), v_p0));\n    if (v_n == 0) {\n      status = wuffs_base__make_status(wuffs_bmp__note__internal_note_short_read);\n      goto ok;\n    }\n    wuffs_base__u32__sat_add_indirect(&self->private_impl.f_dst_x, ((uint32_t)((v_n & 4294967295))));\n  }\n  label__loop__break:;\n  status = wuffs_base__make_status(NULL);\n  goto ok;\n\n  goto ok;\n  ok:\n  goto exit;\n  exit:\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func gif.config_decoder.decode_header\n", "func_signal": "static wuffs_base__status\nwuffs_gif__config_decoder__decode_header(\n    wuffs_gif__config_decoder* self,\n    wuffs_base__io_buffer* a_src)", "code": "{\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  uint8_t v_c[6] = {0};\n  uint32_t v_i = 0;\n\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  uint32_t coro_susp_point = self->private_impl.p_decode_header[0];\n  if (coro_susp_point) {\n    memcpy(v_c, self->private_data.s_decode_header[0].v_c, sizeof(v_c));\n    v_i = self->private_data.s_decode_header[0].v_i;\n  }\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    while (v_i < 6) {\n      {\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);\n        if (WUFFS_BASE__UNLIKELY(iop_a_src == io2_a_src)) {\n          status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n          goto suspend;\n        }\n        uint8_t t_0 = *iop_a_src++;\n        v_c[v_i] = t_0;\n      }\n      v_i += 1;\n    }\n    if ((v_c[0] != 71) ||\n        (v_c[1] != 73) ||\n        (v_c[2] != 70) ||\n        (v_c[3] != 56) ||\n        ((v_c[4] != 55) && (v_c[4] != 57)) ||\n        (v_c[5] != 97)) {\n      status = wuffs_base__make_status(wuffs_gif__error__bad_header);\n      goto exit;\n    }\n\n    goto ok;\n    ok:\n    self->private_impl.p_decode_header[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_decode_header[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n  memcpy(self->private_data.s_decode_header[0].v_c, v_c, sizeof(v_c));\n  self->private_data.s_decode_header[0].v_i = v_i;\n\n  goto exit;\n  exit:\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func deflate.decoder.decode_uncompressed\n", "func_signal": "static wuffs_base__status\nwuffs_deflate__decoder__decode_uncompressed(\n    wuffs_deflate__decoder* self,\n    wuffs_base__io_buffer* a_dst,\n    wuffs_base__io_buffer* a_src)", "code": "{\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  uint32_t v_length = 0;\n  uint32_t v_n_copied = 0;\n\n  uint8_t* iop_a_dst = NULL;\n  uint8_t* io0_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  uint8_t* io1_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  uint8_t* io2_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_dst) {\n    io0_a_dst = a_dst->data.ptr;\n    io1_a_dst = io0_a_dst + a_dst->meta.wi;\n    iop_a_dst = io1_a_dst;\n    io2_a_dst = io0_a_dst + a_dst->data.len;\n    if (a_dst->meta.closed) {\n      io2_a_dst = iop_a_dst;\n    }\n  }\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  uint32_t coro_susp_point = self->private_impl.p_decode_uncompressed[0];\n  if (coro_susp_point) {\n    v_length = self->private_data.s_decode_uncompressed[0].v_length;\n  }\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    if ((self->private_impl.f_n_bits >= 8) || ((self->private_impl.f_bits >> (self->private_impl.f_n_bits & 7)) != 0)) {\n      status = wuffs_base__make_status(wuffs_deflate__error__internal_error_inconsistent_n_bits);\n      goto exit;\n    }\n    self->private_impl.f_n_bits = 0;\n    self->private_impl.f_bits = 0;\n    {\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);\n      uint32_t t_0;\n      if (WUFFS_BASE__LIKELY(io2_a_src - iop_a_src >= 4)) {\n        t_0 = wuffs_base__load_u32le__no_bounds_check(iop_a_src);\n        iop_a_src += 4;\n      } else {\n        self->private_data.s_decode_uncompressed[0].scratch = 0;\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);\n        while (true) {\n          if (WUFFS_BASE__UNLIKELY(iop_a_src == io2_a_src)) {\n            status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n            goto suspend;\n          }\n          uint64_t* scratch = &self->private_data.s_decode_uncompressed[0].scratch;\n          uint32_t num_bits_0 = ((uint32_t)(*scratch >> 56));\n          *scratch <<= 8;\n          *scratch >>= 8;\n          *scratch |= ((uint64_t)(*iop_a_src++)) << num_bits_0;\n          if (num_bits_0 == 24) {\n            t_0 = ((uint32_t)(*scratch));\n            break;\n          }\n          num_bits_0 += 8;\n          *scratch |= ((uint64_t)(num_bits_0)) << 56;\n        }\n      }\n      v_length = t_0;\n    }\n    if ((((v_length) & 0xFFFF) + ((v_length) >> (32 - (16)))) != 65535) {\n      status = wuffs_base__make_status(wuffs_deflate__error__inconsistent_stored_block_length);\n      goto exit;\n    }\n    v_length = ((v_length) & 0xFFFF);\n    while (true) {\n      v_n_copied = wuffs_base__io_writer__limited_copy_u32_from_reader(\n          &iop_a_dst, io2_a_dst,v_length, &iop_a_src, io2_a_src);\n      if (v_length <= v_n_copied) {\n        status = wuffs_base__make_status(NULL);\n        goto ok;\n      }\n      v_length -= v_n_copied;\n      if (((uint64_t)(io2_a_dst - iop_a_dst)) == 0) {\n        status = wuffs_base__make_status(wuffs_base__suspension__short_write);\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);\n      } else {\n        status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(4);\n      }\n    }\n\n    goto ok;\n    ok:\n    self->private_impl.p_decode_uncompressed[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_decode_uncompressed[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n  self->private_data.s_decode_uncompressed[0].v_length = v_length;\n\n  goto exit;\n  exit:\n  if (a_dst) {\n    a_dst->meta.wi = ((size_t)(iop_a_dst - a_dst->data.ptr));\n  }\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func json.decoder.decode_comment\n", "func_signal": "static wuffs_base__status\nwuffs_json__decoder__decode_comment(\n    wuffs_json__decoder* self,\n    wuffs_base__token_buffer* a_dst,\n    wuffs_base__io_buffer* a_src)", "code": "{\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  uint8_t v_c = 0;\n  uint16_t v_c2 = 0;\n  uint32_t v_length = 0;\n\n  wuffs_base__token* iop_a_dst = NULL;\n  wuffs_base__token* io0_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  wuffs_base__token* io1_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  wuffs_base__token* io2_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_dst) {\n    io0_a_dst = a_dst->data.ptr;\n    io1_a_dst = io0_a_dst + a_dst->meta.wi;\n    iop_a_dst = io1_a_dst;\n    io2_a_dst = io0_a_dst + a_dst->data.len;\n    if (a_dst->meta.closed) {\n      io2_a_dst = iop_a_dst;\n    }\n  }\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  uint32_t coro_susp_point = self->private_impl.p_decode_comment[0];\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    self->private_impl.f_comment_type = 0;\n    label__0__continue:;\n    while ((((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) || (((uint64_t)(io2_a_src - iop_a_src)) <= 1)) {\n      if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n        status = wuffs_base__make_status(wuffs_base__suspension__short_write);\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(1);\n        goto label__0__continue;\n      }\n      if (a_src && a_src->meta.closed) {\n        status = wuffs_base__make_status(NULL);\n        goto ok;\n      }\n      status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(2);\n    }\n    v_c2 = wuffs_base__load_u16le__no_bounds_check(iop_a_src);\n    if ((v_c2 == 10799) && self->private_impl.f_quirks[11]) {\n      (iop_a_src += 2, wuffs_base__make_empty_struct());\n      v_length = 2;\n      label__comment_block__continue:;\n      while (true) {\n        if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n          status = wuffs_base__make_status(wuffs_base__suspension__short_write);\n          WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);\n          v_length = 0;\n          goto label__comment_block__continue;\n        }\n        while (true) {\n          if (((uint64_t)(io2_a_src - iop_a_src)) <= 1) {\n            if (v_length > 0) {\n              *iop_a_dst++ = wuffs_base__make_token(\n                  (((uint64_t)(2)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                  (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                  (((uint64_t)(v_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            }\n            if (a_src && a_src->meta.closed) {\n              status = wuffs_base__make_status(wuffs_json__error__bad_input);\n              goto exit;\n            }\n            status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n            WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(4);\n            v_length = 0;\n            goto label__comment_block__continue;\n          }\n          v_c2 = wuffs_base__load_u16le__no_bounds_check(iop_a_src);\n          if (v_c2 == 12074) {\n            (iop_a_src += 2, wuffs_base__make_empty_struct());\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(2)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)((v_length + 2))) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            self->private_impl.f_comment_type = 1;\n            status = wuffs_base__make_status(NULL);\n            goto ok;\n          }\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          if (v_length >= 65533) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(2)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                (((uint64_t)((v_length + 1))) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            v_length = 0;\n            goto label__comment_block__continue;\n          }\n          v_length += 1;\n        }\n      }\n    } else if ((v_c2 == 12079) && self->private_impl.f_quirks[12]) {\n      (iop_a_src += 2, wuffs_base__make_empty_struct());\n      v_length = 2;\n      label__comment_line__continue:;\n      while (true) {\n        if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n          status = wuffs_base__make_status(wuffs_base__suspension__short_write);\n          WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(5);\n          v_length = 0;\n          goto label__comment_line__continue;\n        }\n        while (true) {\n          if (((uint64_t)(io2_a_src - iop_a_src)) <= 0) {\n            if (v_length > 0) {\n              *iop_a_dst++ = wuffs_base__make_token(\n                  (((uint64_t)(4)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                  (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                  (((uint64_t)(v_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            }\n            if (a_src && a_src->meta.closed) {\n              status = wuffs_base__make_status(wuffs_json__error__bad_input);\n              goto exit;\n            }\n            status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n            WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(6);\n            v_length = 0;\n            goto label__comment_line__continue;\n          }\n          v_c = wuffs_base__load_u8be__no_bounds_check(iop_a_src);\n          if (v_c == 10) {\n            (iop_a_src += 1, wuffs_base__make_empty_struct());\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(4)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)((v_length + 1))) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            self->private_impl.f_comment_type = 2;\n            status = wuffs_base__make_status(NULL);\n            goto ok;\n          }\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          if (v_length >= 65533) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(4)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                (((uint64_t)((v_length + 1))) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            v_length = 0;\n            goto label__comment_line__continue;\n          }\n          v_length += 1;\n        }\n      }\n    }\n\n    goto ok;\n    ok:\n    self->private_impl.p_decode_comment[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_decode_comment[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n\n  goto exit;\n  exit:\n  if (a_dst) {\n    a_dst->meta.wi = ((size_t)(iop_a_dst - a_dst->data.ptr));\n  }\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func zlib.decoder.workbuf_len\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__range_ii_u64\nwuffs_zlib__decoder__workbuf_len(\n    const wuffs_zlib__decoder* self)", "code": "{\n  if (!self) {\n    return wuffs_base__utility__empty_range_ii_u64();\n  }\n  if ((self->private_impl.magic != WUFFS_BASE__MAGIC) &&\n      (self->private_impl.magic != WUFFS_BASE__DISABLED)) {\n    return wuffs_base__utility__empty_range_ii_u64();\n  }\n\n  return wuffs_base__utility__make_range_ii_u64(1, 1);\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func gif.config_decoder.workbuf_len\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__range_ii_u64\nwuffs_gif__config_decoder__workbuf_len(\n    const wuffs_gif__config_decoder* self)", "code": "{\n  if (!self) {\n    return wuffs_base__utility__empty_range_ii_u64();\n  }\n  if ((self->private_impl.magic != WUFFS_BASE__MAGIC) &&\n      (self->private_impl.magic != WUFFS_BASE__DISABLED)) {\n    return wuffs_base__utility__empty_range_ii_u64();\n  }\n\n  return wuffs_base__utility__empty_range_ii_u64();\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func bmp.decoder.frame_dirty_rect\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__rect_ie_u32\nwuffs_bmp__decoder__frame_dirty_rect(\n    const wuffs_bmp__decoder* self)", "code": "{\n  if (!self) {\n    return wuffs_base__utility__empty_rect_ie_u32();\n  }\n  if ((self->private_impl.magic != WUFFS_BASE__MAGIC) &&\n      (self->private_impl.magic != WUFFS_BASE__DISABLED)) {\n    return wuffs_base__utility__empty_rect_ie_u32();\n  }\n\n  return wuffs_base__utility__make_rect_ie_u32(\n      0,\n      0,\n      self->private_impl.f_width,\n      self->private_impl.f_height);\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func gif.config_decoder.decode_up_to_id_part1\n", "func_signal": "static wuffs_base__status\nwuffs_gif__config_decoder__decode_up_to_id_part1(\n    wuffs_gif__config_decoder* self,\n    wuffs_base__io_buffer* a_src)", "code": "{\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  uint8_t v_block_type = 0;\n\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  uint32_t coro_susp_point = self->private_impl.p_decode_up_to_id_part1[0];\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    if ( ! self->private_impl.f_restarted) {\n      if (self->private_impl.f_call_sequence != 2) {\n        self->private_impl.f_frame_config_io_position = wuffs_base__u64__sat_add(a_src->meta.pos, ((uint64_t)(iop_a_src - io0_a_src)));\n      }\n    } else if (self->private_impl.f_frame_config_io_position != wuffs_base__u64__sat_add(a_src->meta.pos, ((uint64_t)(iop_a_src - io0_a_src)))) {\n      status = wuffs_base__make_status(wuffs_base__error__bad_restart);\n      goto exit;\n    } else {\n      self->private_impl.f_restarted = false;\n    }\n    while (true) {\n      {\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);\n        if (WUFFS_BASE__UNLIKELY(iop_a_src == io2_a_src)) {\n          status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n          goto suspend;\n        }\n        uint8_t t_0 = *iop_a_src++;\n        v_block_type = t_0;\n      }\n      if (v_block_type == 33) {\n        if (a_src) {\n          a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n        }\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);\n        status = wuffs_gif__config_decoder__decode_extension(self, a_src);\n        if (a_src) {\n          iop_a_src = a_src->data.ptr + a_src->meta.ri;\n        }\n        if (status.repr) {\n          goto suspend;\n        }\n      } else if (v_block_type == 44) {\n        if (self->private_impl.f_delayed_num_decoded_frames) {\n          self->private_impl.f_delayed_num_decoded_frames = false;\n          wuffs_base__u64__sat_add_indirect(&self->private_impl.f_num_decoded_frames_value, 1);\n        }\n        if (a_src) {\n          a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n        }\n        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);\n        status = wuffs_gif__config_decoder__decode_id_part0(self, a_src);\n        if (a_src) {\n          iop_a_src = a_src->data.ptr + a_src->meta.ri;\n        }\n        if (status.repr) {\n          goto suspend;\n        }\n        goto label__0__break;\n      } else {\n        if (self->private_impl.f_delayed_num_decoded_frames) {\n          self->private_impl.f_delayed_num_decoded_frames = false;\n          wuffs_base__u64__sat_add_indirect(&self->private_impl.f_num_decoded_frames_value, 1);\n        }\n        self->private_impl.f_end_of_data = true;\n        goto label__0__break;\n      }\n    }\n    label__0__break:;\n\n    goto ok;\n    ok:\n    self->private_impl.p_decode_up_to_id_part1[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_decode_up_to_id_part1[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n\n  goto exit;\n  exit:\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func deflate.decoder.workbuf_len\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__range_ii_u64\nwuffs_deflate__decoder__workbuf_len(\n    const wuffs_deflate__decoder* self)", "code": "{\n  if (!self) {\n    return wuffs_base__utility__empty_range_ii_u64();\n  }\n  if ((self->private_impl.magic != WUFFS_BASE__MAGIC) &&\n      (self->private_impl.magic != WUFFS_BASE__DISABLED)) {\n    return wuffs_base__utility__empty_range_ii_u64();\n  }\n\n  return wuffs_base__utility__make_range_ii_u64(1, 1);\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func json.decoder.decode_tokens\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC wuffs_base__status\nwuffs_json__decoder__decode_tokens(\n    wuffs_json__decoder* self,\n    wuffs_base__token_buffer* a_dst,\n    wuffs_base__io_buffer* a_src,\n    wuffs_base__slice_u8 a_workbuf)", "code": "{\n  if (!self) {\n    return wuffs_base__make_status(wuffs_base__error__bad_receiver);\n  }\n  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {\n    return wuffs_base__make_status(\n        (self->private_impl.magic == WUFFS_BASE__DISABLED)\n        ? wuffs_base__error__disabled_by_previous_error\n        : wuffs_base__error__initialize_not_called);\n  }\n  if (!a_dst || !a_src) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__bad_argument);\n  }\n  if ((self->private_impl.active_coroutine != 0) &&\n      (self->private_impl.active_coroutine != 1)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n    return wuffs_base__make_status(wuffs_base__error__interleaved_coroutine_calls);\n  }\n  self->private_impl.active_coroutine = 0;\n  wuffs_base__status status = wuffs_base__make_status(NULL);\n\n  uint32_t v_vminor = 0;\n  uint32_t v_number_length = 0;\n  uint32_t v_number_status = 0;\n  uint32_t v_string_length = 0;\n  uint32_t v_whitespace_length = 0;\n  uint32_t v_depth = 0;\n  uint32_t v_stack_byte = 0;\n  uint32_t v_stack_bit = 0;\n  uint32_t v_match = 0;\n  uint32_t v_c4 = 0;\n  uint8_t v_c = 0;\n  uint8_t v_backslash = 0;\n  uint8_t v_char = 0;\n  uint8_t v_class = 0;\n  uint32_t v_multi_byte_utf8 = 0;\n  uint8_t v_backslash_x_ok = 0;\n  uint8_t v_backslash_x_value = 0;\n  uint32_t v_backslash_x_string = 0;\n  uint8_t v_uni4_ok = 0;\n  uint64_t v_uni4_string = 0;\n  uint32_t v_uni4_value = 0;\n  uint32_t v_uni4_high_surrogate = 0;\n  uint8_t v_uni8_ok = 0;\n  uint64_t v_uni8_string = 0;\n  uint32_t v_uni8_value = 0;\n  uint32_t v_expect = 0;\n  uint32_t v_expect_after_value = 0;\n\n  wuffs_base__token* iop_a_dst = NULL;\n  wuffs_base__token* io0_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  wuffs_base__token* io1_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  wuffs_base__token* io2_a_dst WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_dst) {\n    io0_a_dst = a_dst->data.ptr;\n    io1_a_dst = io0_a_dst + a_dst->meta.wi;\n    iop_a_dst = io1_a_dst;\n    io2_a_dst = io0_a_dst + a_dst->data.len;\n    if (a_dst->meta.closed) {\n      io2_a_dst = iop_a_dst;\n    }\n  }\n  const uint8_t* iop_a_src = NULL;\n  const uint8_t* io0_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io1_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  const uint8_t* io2_a_src WUFFS_BASE__POTENTIALLY_UNUSED = NULL;\n  if (a_src) {\n    io0_a_src = a_src->data.ptr;\n    io1_a_src = io0_a_src + a_src->meta.ri;\n    iop_a_src = io1_a_src;\n    io2_a_src = io0_a_src + a_src->meta.wi;\n  }\n\n  uint32_t coro_susp_point = self->private_impl.p_decode_tokens[0];\n  if (coro_susp_point) {\n    v_depth = self->private_data.s_decode_tokens[0].v_depth;\n    v_expect = self->private_data.s_decode_tokens[0].v_expect;\n    v_expect_after_value = self->private_data.s_decode_tokens[0].v_expect_after_value;\n  }\n  switch (coro_susp_point) {\n    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;\n\n    if (self->private_impl.f_end_of_data) {\n      status = wuffs_base__make_status(wuffs_base__note__end_of_data);\n      goto ok;\n    }\n    if (self->private_impl.f_quirks[18]) {\n      if (self->private_impl.f_quirks[11] || self->private_impl.f_quirks[12] || self->private_impl.f_quirks[17]) {\n        status = wuffs_base__make_status(wuffs_json__error__bad_quirk_combination);\n        goto exit;\n      }\n    }\n    if (self->private_impl.f_quirks[15] || self->private_impl.f_quirks[16]) {\n      if (a_dst) {\n        a_dst->meta.wi = ((size_t)(iop_a_dst - a_dst->data.ptr));\n      }\n      if (a_src) {\n        a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n      }\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);\n      status = wuffs_json__decoder__decode_leading(self, a_dst, a_src);\n      if (a_dst) {\n        iop_a_dst = a_dst->data.ptr + a_dst->meta.wi;\n      }\n      if (a_src) {\n        iop_a_src = a_src->data.ptr + a_src->meta.ri;\n      }\n      if (status.repr) {\n        goto suspend;\n      }\n    }\n    v_expect = 7858;\n    label__outer__continue:;\n    while (true) {\n      while (true) {\n        if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n          status = wuffs_base__make_status(wuffs_base__suspension__short_write);\n          WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(2);\n          goto label__outer__continue;\n        }\n        v_whitespace_length = 0;\n        v_c = 0;\n        v_class = 0;\n        while (true) {\n          if (((uint64_t)(io2_a_src - iop_a_src)) <= 0) {\n            if (v_whitespace_length > 0) {\n              *iop_a_dst++ = wuffs_base__make_token(\n                  (((uint64_t)(0)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                  (((uint64_t)(v_whitespace_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n              v_whitespace_length = 0;\n            }\n            if (a_src && a_src->meta.closed) {\n              status = wuffs_base__make_status(wuffs_json__error__bad_input);\n              goto exit;\n            }\n            status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n            WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);\n            v_whitespace_length = 0;\n            goto label__outer__continue;\n          }\n          v_c = wuffs_base__load_u8be__no_bounds_check(iop_a_src);\n          v_class = WUFFS_JSON__LUT_CLASSES[v_c];\n          if (v_class != 0) {\n            goto label__ws__break;\n          }\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          if (v_whitespace_length >= 65534) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(0)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(65535)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            v_whitespace_length = 0;\n            goto label__outer__continue;\n          }\n          v_whitespace_length += 1;\n        }\n        label__ws__break:;\n        if (v_whitespace_length > 0) {\n          *iop_a_dst++ = wuffs_base__make_token(\n              (((uint64_t)(0)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n              (((uint64_t)(v_whitespace_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n          v_whitespace_length = 0;\n          if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n            goto label__outer__continue;\n          }\n        }\n        if (0 == (v_expect & (((uint32_t)(1)) << v_class))) {\n          status = wuffs_base__make_status(wuffs_json__error__bad_input);\n          goto exit;\n        }\n        if (v_class == 1) {\n          *iop_a_dst++ = wuffs_base__make_token(\n              (((uint64_t)(4194579)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          label__string_loop_outer__continue:;\n          while (true) {\n            if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n              status = wuffs_base__make_status(wuffs_base__suspension__short_write);\n              WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(4);\n              goto label__string_loop_outer__continue;\n            }\n            v_string_length = 0;\n            label__string_loop_inner__continue:;\n            while (true) {\n              if (((uint64_t)(io2_a_src - iop_a_src)) <= 0) {\n                if (v_string_length > 0) {\n                  *iop_a_dst++ = wuffs_base__make_token(\n                      (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                      (((uint64_t)(v_string_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                  v_string_length = 0;\n                }\n                if (a_src && a_src->meta.closed) {\n                  status = wuffs_base__make_status(wuffs_json__error__bad_input);\n                  goto exit;\n                }\n                status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(5);\n                v_string_length = 0;\n                goto label__string_loop_outer__continue;\n              }\n              while (((uint64_t)(io2_a_src - iop_a_src)) > 4) {\n                v_c4 = wuffs_base__load_u32le__no_bounds_check(iop_a_src);\n                if (0 != (WUFFS_JSON__LUT_CHARS[(255 & (v_c4 >> 0))] |\n                    WUFFS_JSON__LUT_CHARS[(255 & (v_c4 >> 8))] |\n                    WUFFS_JSON__LUT_CHARS[(255 & (v_c4 >> 16))] |\n                    WUFFS_JSON__LUT_CHARS[(255 & (v_c4 >> 24))])) {\n                  goto label__0__break;\n                }\n                (iop_a_src += 4, wuffs_base__make_empty_struct());\n                if (v_string_length > 65527) {\n                  *iop_a_dst++ = wuffs_base__make_token(\n                      (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                      (((uint64_t)((v_string_length + 4))) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                  v_string_length = 0;\n                  goto label__string_loop_outer__continue;\n                }\n                v_string_length += 4;\n              }\n              label__0__break:;\n              v_c = wuffs_base__load_u8be__no_bounds_check(iop_a_src);\n              v_char = WUFFS_JSON__LUT_CHARS[v_c];\n              if (v_char == 0) {\n                (iop_a_src += 1, wuffs_base__make_empty_struct());\n                if (v_string_length >= 65531) {\n                  *iop_a_dst++ = wuffs_base__make_token(\n                      (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                      (((uint64_t)(65532)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                  v_string_length = 0;\n                  goto label__string_loop_outer__continue;\n                }\n                v_string_length += 1;\n                goto label__string_loop_inner__continue;\n              } else if (v_char == 1) {\n                if (v_string_length != 0) {\n                  *iop_a_dst++ = wuffs_base__make_token(\n                      (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                      (((uint64_t)(v_string_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                  v_string_length = 0;\n                }\n                goto label__string_loop_outer__break;\n              } else if (v_char == 2) {\n                if (v_string_length > 0) {\n                  *iop_a_dst++ = wuffs_base__make_token(\n                      (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                      (((uint64_t)(v_string_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                  v_string_length = 0;\n                  if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n                    goto label__string_loop_outer__continue;\n                  }\n                }\n                if (((uint64_t)(io2_a_src - iop_a_src)) < 2) {\n                  if (a_src && a_src->meta.closed) {\n                    status = wuffs_base__make_status(wuffs_json__error__bad_backslash_escape);\n                    goto exit;\n                  }\n                  status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                  WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(6);\n                  v_string_length = 0;\n                  v_char = 0;\n                  goto label__string_loop_outer__continue;\n                }\n                v_c = ((uint8_t)((wuffs_base__load_u16le__no_bounds_check(iop_a_src) >> 8)));\n                v_backslash = WUFFS_JSON__LUT_BACKSLASHES[v_c];\n                if ((v_backslash & 128) != 0) {\n                  (iop_a_src += 2, wuffs_base__make_empty_struct());\n                  *iop_a_dst++ = wuffs_base__make_token(\n                      (((uint64_t)((6291456 | ((uint32_t)((v_backslash & 127)))))) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                      (((uint64_t)(2)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                  goto label__string_loop_outer__continue;\n                } else if (v_backslash != 0) {\n                  if (self->private_impl.f_quirks[WUFFS_JSON__LUT_QUIRKY_BACKSLASHES_QUIRKS[(v_backslash & 7)]]) {\n                    (iop_a_src += 2, wuffs_base__make_empty_struct());\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)((6291456 | ((uint32_t)(WUFFS_JSON__LUT_QUIRKY_BACKSLASHES_CHARS[(v_backslash & 7)]))))) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)(2)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    goto label__string_loop_outer__continue;\n                  }\n                } else if (v_c == 117) {\n                  if (((uint64_t)(io2_a_src - iop_a_src)) < 6) {\n                    if (a_src && a_src->meta.closed) {\n                      status = wuffs_base__make_status(wuffs_json__error__bad_backslash_escape);\n                      goto exit;\n                    }\n                    status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(7);\n                    v_string_length = 0;\n                    v_char = 0;\n                    goto label__string_loop_outer__continue;\n                  }\n                  v_uni4_string = (((uint64_t)(wuffs_base__load_u48le__no_bounds_check(iop_a_src))) >> 16);\n                  v_uni4_value = 0;\n                  v_uni4_ok = 128;\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni4_string >> 0))];\n                  v_uni4_ok &= v_c;\n                  v_uni4_value |= (((uint32_t)((v_c & 15))) << 12);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni4_string >> 8))];\n                  v_uni4_ok &= v_c;\n                  v_uni4_value |= (((uint32_t)((v_c & 15))) << 8);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni4_string >> 16))];\n                  v_uni4_ok &= v_c;\n                  v_uni4_value |= (((uint32_t)((v_c & 15))) << 4);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni4_string >> 24))];\n                  v_uni4_ok &= v_c;\n                  v_uni4_value |= (((uint32_t)((v_c & 15))) << 0);\n                  if (v_uni4_ok == 0) {\n                  } else if ((v_uni4_value < 55296) || (57343 < v_uni4_value)) {\n                    (iop_a_src += 6, wuffs_base__make_empty_struct());\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)((6291456 | v_uni4_value))) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)(6)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    goto label__string_loop_outer__continue;\n                  } else if (v_uni4_value >= 56320) {\n                  } else {\n                    if (((uint64_t)(io2_a_src - iop_a_src)) < 12) {\n                      if (a_src && a_src->meta.closed) {\n                        if (self->private_impl.f_quirks[20]) {\n                          (iop_a_src += 6, wuffs_base__make_empty_struct());\n                          *iop_a_dst++ = wuffs_base__make_token(\n                              (((uint64_t)(6356989)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                              (((uint64_t)(6)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                          goto label__string_loop_outer__continue;\n                        }\n                        status = wuffs_base__make_status(wuffs_json__error__bad_backslash_escape);\n                        goto exit;\n                      }\n                      status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                      WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(8);\n                      v_string_length = 0;\n                      v_uni4_value = 0;\n                      v_char = 0;\n                      goto label__string_loop_outer__continue;\n                    }\n                    v_uni4_string = (wuffs_base__load_u64le__no_bounds_check(iop_a_src + 4) >> 16);\n                    if (((255 & (v_uni4_string >> 0)) != 92) || ((255 & (v_uni4_string >> 8)) != 117)) {\n                      v_uni4_high_surrogate = 0;\n                      v_uni4_value = 0;\n                      v_uni4_ok = 0;\n                    } else {\n                      v_uni4_high_surrogate = (65536 + ((v_uni4_value - 55296) << 10));\n                      v_uni4_value = 0;\n                      v_uni4_ok = 128;\n                      v_uni4_string >>= 16;\n                      v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni4_string >> 0))];\n                      v_uni4_ok &= v_c;\n                      v_uni4_value |= (((uint32_t)((v_c & 15))) << 12);\n                      v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni4_string >> 8))];\n                      v_uni4_ok &= v_c;\n                      v_uni4_value |= (((uint32_t)((v_c & 15))) << 8);\n                      v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni4_string >> 16))];\n                      v_uni4_ok &= v_c;\n                      v_uni4_value |= (((uint32_t)((v_c & 15))) << 4);\n                      v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni4_string >> 24))];\n                      v_uni4_ok &= v_c;\n                      v_uni4_value |= (((uint32_t)((v_c & 15))) << 0);\n                    }\n                    if ((v_uni4_ok != 0) && (56320 <= v_uni4_value) && (v_uni4_value <= 57343)) {\n                      v_uni4_value -= 56320;\n                      (iop_a_src += 12, wuffs_base__make_empty_struct());\n                      *iop_a_dst++ = wuffs_base__make_token(\n                          (((uint64_t)((6291456 | v_uni4_high_surrogate | v_uni4_value))) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                          (((uint64_t)(12)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                      goto label__string_loop_outer__continue;\n                    }\n                  }\n                  if (self->private_impl.f_quirks[20]) {\n                    if (((uint64_t)(io2_a_src - iop_a_src)) < 6) {\n                      status = wuffs_base__make_status(wuffs_json__error__internal_error_inconsistent_i_o);\n                      goto exit;\n                    }\n                    (iop_a_src += 6, wuffs_base__make_empty_struct());\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)(6356989)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)(6)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    goto label__string_loop_outer__continue;\n                  }\n                } else if ((v_c == 85) && self->private_impl.f_quirks[2]) {\n                  if (((uint64_t)(io2_a_src - iop_a_src)) < 10) {\n                    if (a_src && a_src->meta.closed) {\n                      status = wuffs_base__make_status(wuffs_json__error__bad_backslash_escape);\n                      goto exit;\n                    }\n                    status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(9);\n                    v_string_length = 0;\n                    v_char = 0;\n                    goto label__string_loop_outer__continue;\n                  }\n                  v_uni8_string = wuffs_base__load_u64le__no_bounds_check(iop_a_src + 2);\n                  v_uni8_value = 0;\n                  v_uni8_ok = 128;\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni8_string >> 0))];\n                  v_uni8_ok &= v_c;\n                  v_uni8_value |= (((uint32_t)((v_c & 15))) << 28);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni8_string >> 8))];\n                  v_uni8_ok &= v_c;\n                  v_uni8_value |= (((uint32_t)((v_c & 15))) << 24);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni8_string >> 16))];\n                  v_uni8_ok &= v_c;\n                  v_uni8_value |= (((uint32_t)((v_c & 15))) << 20);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni8_string >> 24))];\n                  v_uni8_ok &= v_c;\n                  v_uni8_value |= (((uint32_t)((v_c & 15))) << 16);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni8_string >> 32))];\n                  v_uni8_ok &= v_c;\n                  v_uni8_value |= (((uint32_t)((v_c & 15))) << 12);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni8_string >> 40))];\n                  v_uni8_ok &= v_c;\n                  v_uni8_value |= (((uint32_t)((v_c & 15))) << 8);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni8_string >> 48))];\n                  v_uni8_ok &= v_c;\n                  v_uni8_value |= (((uint32_t)((v_c & 15))) << 4);\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_uni8_string >> 56))];\n                  v_uni8_ok &= v_c;\n                  v_uni8_value |= (((uint32_t)((v_c & 15))) << 0);\n                  if (v_uni8_ok == 0) {\n                  } else if ((v_uni8_value < 55296) || ((57343 < v_uni8_value) && (v_uni8_value <= 1114111))) {\n                    (iop_a_src += 10, wuffs_base__make_empty_struct());\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)((6291456 | (v_uni8_value & 2097151)))) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)(10)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    goto label__string_loop_outer__continue;\n                  } else if (self->private_impl.f_quirks[20]) {\n                    (iop_a_src += 10, wuffs_base__make_empty_struct());\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)(6356989)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)(10)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    goto label__string_loop_outer__continue;\n                  }\n                } else if ((v_c == 120) && self->private_impl.f_quirks[9]) {\n                  if (((uint64_t)(io2_a_src - iop_a_src)) < 4) {\n                    if (a_src && a_src->meta.closed) {\n                      status = wuffs_base__make_status(wuffs_json__error__bad_backslash_escape);\n                      goto exit;\n                    }\n                    status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(10);\n                    v_string_length = 0;\n                    v_char = 0;\n                    goto label__string_loop_outer__continue;\n                  }\n                  v_backslash_x_string = wuffs_base__load_u32le__no_bounds_check(iop_a_src);\n                  v_backslash_x_ok = 128;\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_backslash_x_string >> 16))];\n                  v_backslash_x_ok &= v_c;\n                  v_backslash_x_value = ((uint8_t)(((v_c & 15) << 4)));\n                  v_c = WUFFS_JSON__LUT_HEXADECIMAL_DIGITS[(255 & (v_backslash_x_string >> 24))];\n                  v_backslash_x_ok &= v_c;\n                  v_backslash_x_value = ((uint8_t)((v_backslash_x_value | (v_c & 15))));\n                  if ((v_backslash_x_ok == 0) || ((v_backslash_x_string & 65535) != 30812)) {\n                    status = wuffs_base__make_status(wuffs_json__error__bad_backslash_escape);\n                    goto exit;\n                  }\n                  (iop_a_src += 4, wuffs_base__make_empty_struct());\n                  *iop_a_dst++ = wuffs_base__make_token(\n                      (((uint64_t)((6291456 | ((uint32_t)(v_backslash_x_value))))) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                      (((uint64_t)(4)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                  goto label__string_loop_outer__continue;\n                }\n                status = wuffs_base__make_status(wuffs_json__error__bad_backslash_escape);\n                goto exit;\n              } else if (v_char == 3) {\n                if (((uint64_t)(io2_a_src - iop_a_src)) < 2) {\n                  if (v_string_length > 0) {\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)(v_string_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    v_string_length = 0;\n                    if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n                      goto label__string_loop_outer__continue;\n                    }\n                  }\n                  if (a_src && a_src->meta.closed) {\n                    if (self->private_impl.f_quirks[20]) {\n                      *iop_a_dst++ = wuffs_base__make_token(\n                          (((uint64_t)(6356989)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                      (iop_a_src += 1, wuffs_base__make_empty_struct());\n                      goto label__string_loop_outer__continue;\n                    }\n                    status = wuffs_base__make_status(wuffs_json__error__bad_utf_8);\n                    goto exit;\n                  }\n                  status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                  WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(11);\n                  v_string_length = 0;\n                  v_char = 0;\n                  goto label__string_loop_outer__continue;\n                }\n                v_multi_byte_utf8 = ((uint32_t)(wuffs_base__load_u16le__no_bounds_check(iop_a_src)));\n                if ((v_multi_byte_utf8 & 49152) == 32768) {\n                  v_multi_byte_utf8 = ((1984 & (v_multi_byte_utf8 << 6)) | (63 & (v_multi_byte_utf8 >> 8)));\n                  (iop_a_src += 2, wuffs_base__make_empty_struct());\n                  if (v_string_length >= 65528) {\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)((v_string_length + 2))) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    v_string_length = 0;\n                    goto label__string_loop_outer__continue;\n                  }\n                  v_string_length += 2;\n                  goto label__string_loop_inner__continue;\n                }\n              } else if (v_char == 4) {\n                if (((uint64_t)(io2_a_src - iop_a_src)) < 3) {\n                  if (v_string_length > 0) {\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)(v_string_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    v_string_length = 0;\n                    if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n                      goto label__string_loop_outer__continue;\n                    }\n                  }\n                  if (a_src && a_src->meta.closed) {\n                    if (self->private_impl.f_quirks[20]) {\n                      *iop_a_dst++ = wuffs_base__make_token(\n                          (((uint64_t)(6356989)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                      (iop_a_src += 1, wuffs_base__make_empty_struct());\n                      goto label__string_loop_outer__continue;\n                    }\n                    status = wuffs_base__make_status(wuffs_json__error__bad_utf_8);\n                    goto exit;\n                  }\n                  status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                  WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(12);\n                  v_string_length = 0;\n                  v_char = 0;\n                  goto label__string_loop_outer__continue;\n                }\n                v_multi_byte_utf8 = ((uint32_t)(wuffs_base__load_u24le__no_bounds_check(iop_a_src)));\n                if ((v_multi_byte_utf8 & 12632064) == 8421376) {\n                  v_multi_byte_utf8 = ((61440 & (v_multi_byte_utf8 << 12)) | (4032 & (v_multi_byte_utf8 >> 2)) | (63 & (v_multi_byte_utf8 >> 16)));\n                  if ((2047 < v_multi_byte_utf8) && ((v_multi_byte_utf8 < 55296) || (57343 < v_multi_byte_utf8))) {\n                    (iop_a_src += 3, wuffs_base__make_empty_struct());\n                    if (v_string_length >= 65528) {\n                      *iop_a_dst++ = wuffs_base__make_token(\n                          (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                          (((uint64_t)((v_string_length + 3))) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                      v_string_length = 0;\n                      goto label__string_loop_outer__continue;\n                    }\n                    v_string_length += 3;\n                    goto label__string_loop_inner__continue;\n                  }\n                }\n              } else if (v_char == 5) {\n                if (((uint64_t)(io2_a_src - iop_a_src)) < 4) {\n                  if (v_string_length > 0) {\n                    *iop_a_dst++ = wuffs_base__make_token(\n                        (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                        (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                        (((uint64_t)(v_string_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                    v_string_length = 0;\n                    if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n                      goto label__string_loop_outer__continue;\n                    }\n                  }\n                  if (a_src && a_src->meta.closed) {\n                    if (self->private_impl.f_quirks[20]) {\n                      *iop_a_dst++ = wuffs_base__make_token(\n                          (((uint64_t)(6356989)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                      (iop_a_src += 1, wuffs_base__make_empty_struct());\n                      goto label__string_loop_outer__continue;\n                    }\n                    status = wuffs_base__make_status(wuffs_json__error__bad_utf_8);\n                    goto exit;\n                  }\n                  status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n                  WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(13);\n                  v_string_length = 0;\n                  v_char = 0;\n                  goto label__string_loop_outer__continue;\n                }\n                v_multi_byte_utf8 = wuffs_base__load_u32le__no_bounds_check(iop_a_src);\n                if ((v_multi_byte_utf8 & 3233857536) == 2155905024) {\n                  v_multi_byte_utf8 = ((1835008 & (v_multi_byte_utf8 << 18)) |\n                      (258048 & (v_multi_byte_utf8 << 4)) |\n                      (4032 & (v_multi_byte_utf8 >> 10)) |\n                      (63 & (v_multi_byte_utf8 >> 24)));\n                  if ((65535 < v_multi_byte_utf8) && (v_multi_byte_utf8 <= 1114111)) {\n                    (iop_a_src += 4, wuffs_base__make_empty_struct());\n                    if (v_string_length >= 65528) {\n                      *iop_a_dst++ = wuffs_base__make_token(\n                          (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                          (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                          (((uint64_t)((v_string_length + 4))) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                      v_string_length = 0;\n                      goto label__string_loop_outer__continue;\n                    }\n                    v_string_length += 4;\n                    goto label__string_loop_inner__continue;\n                  }\n                }\n              }\n              if (v_string_length > 0) {\n                *iop_a_dst++ = wuffs_base__make_token(\n                    (((uint64_t)(4194819)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                    (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                    (((uint64_t)(v_string_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                v_string_length = 0;\n                if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n                  goto label__string_loop_outer__continue;\n                }\n              }\n              if ((v_char & 128) != 0) {\n                if (self->private_impl.f_quirks[0]) {\n                  *iop_a_dst++ = wuffs_base__make_token(\n                      (((uint64_t)((6291456 | ((uint32_t)((v_char & 127)))))) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                      (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                  (iop_a_src += 1, wuffs_base__make_empty_struct());\n                  goto label__string_loop_outer__continue;\n                }\n                if (v_char == 138) {\n                  status = wuffs_base__make_status(wuffs_json__error__bad_new_line_in_a_string);\n                  goto exit;\n                }\n                status = wuffs_base__make_status(wuffs_json__error__bad_c0_control_code);\n                goto exit;\n              }\n              if (self->private_impl.f_quirks[20]) {\n                *iop_a_dst++ = wuffs_base__make_token(\n                    (((uint64_t)(6356989)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                    (((uint64_t)(1)) << WUFFS_BASE__TOKEN__CONTINUED__SHIFT) |\n                    (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n                (iop_a_src += 1, wuffs_base__make_empty_struct());\n                goto label__string_loop_outer__continue;\n              }\n              status = wuffs_base__make_status(wuffs_json__error__bad_utf_8);\n              goto exit;\n            }\n          }\n          label__string_loop_outer__break:;\n          label__1__continue:;\n          while (true) {\n            if (((uint64_t)(io2_a_src - iop_a_src)) <= 0) {\n              if (a_src && a_src->meta.closed) {\n                status = wuffs_base__make_status(wuffs_json__error__bad_input);\n                goto exit;\n              }\n              status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n              WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(14);\n              goto label__1__continue;\n            }\n            if (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n              status = wuffs_base__make_status(wuffs_base__suspension__short_write);\n              WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(15);\n              goto label__1__continue;\n            }\n            (iop_a_src += 1, wuffs_base__make_empty_struct());\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(4194579)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            goto label__1__break;\n          }\n          label__1__break:;\n          if (0 == (v_expect & (((uint32_t)(1)) << 4))) {\n            v_expect = 4104;\n            goto label__outer__continue;\n          }\n          goto label__goto_parsed_a_leaf_value__break;\n        } else if (v_class == 2) {\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          *iop_a_dst++ = wuffs_base__make_token(\n              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n          if (0 == (v_expect & (((uint32_t)(1)) << 8))) {\n            if (self->private_impl.f_quirks[13]) {\n              v_expect = 4162;\n            } else {\n              v_expect = 4098;\n            }\n          } else {\n            if (self->private_impl.f_quirks[13]) {\n              v_expect = 8114;\n            } else {\n              v_expect = 7858;\n            }\n          }\n          goto label__outer__continue;\n        } else if (v_class == 3) {\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          *iop_a_dst++ = wuffs_base__make_token(\n              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n          v_expect = 7858;\n          goto label__outer__continue;\n        } else if (v_class == 4) {\n          while (true) {\n            if (a_src) {\n              a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n            }\n            v_number_length = wuffs_json__decoder__decode_number(self, a_src);\n            if (a_src) {\n              iop_a_src = a_src->data.ptr + a_src->meta.ri;\n            }\n            v_number_status = (v_number_length >> 8);\n            v_vminor = 10486787;\n            if ((v_number_length & 128) != 0) {\n              v_vminor = 10486785;\n            }\n            v_number_length = (v_number_length & 127);\n            if (v_number_status == 0) {\n              *iop_a_dst++ = wuffs_base__make_token(\n                  (((uint64_t)(v_vminor)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                  (((uint64_t)(v_number_length)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n              goto label__2__break;\n            }\n            while (v_number_length > 0) {\n              v_number_length -= 1;\n              if (iop_a_src > io1_a_src) {\n                (iop_a_src--, wuffs_base__make_empty_struct());\n              } else {\n                status = wuffs_base__make_status(wuffs_json__error__internal_error_inconsistent_i_o);\n                goto exit;\n              }\n            }\n            if (v_number_status == 1) {\n              if (self->private_impl.f_quirks[14]) {\n                if (a_dst) {\n                  a_dst->meta.wi = ((size_t)(iop_a_dst - a_dst->data.ptr));\n                }\n                if (a_src) {\n                  a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n                }\n                WUFFS_BASE__COROUTINE_SUSPENSION_POINT(16);\n                status = wuffs_json__decoder__decode_inf_nan(self, a_dst, a_src);\n                if (a_dst) {\n                  iop_a_dst = a_dst->data.ptr + a_dst->meta.wi;\n                }\n                if (a_src) {\n                  iop_a_src = a_src->data.ptr + a_src->meta.ri;\n                }\n                if (status.repr) {\n                  goto suspend;\n                }\n                goto label__2__break;\n              }\n              status = wuffs_base__make_status(wuffs_json__error__bad_input);\n              goto exit;\n            } else if (v_number_status == 2) {\n              status = wuffs_base__make_status(wuffs_json__error__unsupported_number_length);\n              goto exit;\n            } else {\n              status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n              WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(17);\n              while (((uint64_t)(io2_a_dst - iop_a_dst)) <= 0) {\n                status = wuffs_base__make_status(wuffs_base__suspension__short_write);\n                WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(18);\n              }\n            }\n          }\n          label__2__break:;\n          goto label__goto_parsed_a_leaf_value__break;\n        } else if (v_class == 5) {\n          v_vminor = 2113553;\n          if (v_depth == 0) {\n          } else if (0 != (v_expect_after_value & (((uint32_t)(1)) << 6))) {\n            v_vminor = 2113601;\n          } else {\n            v_vminor = 2113569;\n          }\n          if (v_depth >= 1024) {\n            status = wuffs_base__make_status(wuffs_json__error__unsupported_recursion_depth);\n            goto exit;\n          }\n          v_stack_byte = (v_depth / 32);\n          v_stack_bit = (v_depth & 31);\n          self->private_data.f_stack[v_stack_byte] |= (((uint32_t)(1)) << v_stack_bit);\n          v_depth += 1;\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          *iop_a_dst++ = wuffs_base__make_token(\n              (((uint64_t)(v_vminor)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n          v_expect = 4162;\n          v_expect_after_value = 4164;\n          goto label__outer__continue;\n        } else if (v_class == 6) {\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          if (v_depth <= 1) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(2101314)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            goto label__outer__break;\n          }\n          v_depth -= 1;\n          v_stack_byte = ((v_depth - 1) / 32);\n          v_stack_bit = ((v_depth - 1) & 31);\n          if (0 == (self->private_data.f_stack[v_stack_byte] & (((uint32_t)(1)) << v_stack_bit))) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(2105410)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            v_expect = 4356;\n            v_expect_after_value = 4356;\n          } else {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(2113602)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            v_expect = 4164;\n            v_expect_after_value = 4164;\n          }\n          goto label__outer__continue;\n        } else if (v_class == 7) {\n          v_vminor = 2105361;\n          if (v_depth == 0) {\n          } else if (0 != (v_expect_after_value & (((uint32_t)(1)) << 6))) {\n            v_vminor = 2105409;\n          } else {\n            v_vminor = 2105377;\n          }\n          if (v_depth >= 1024) {\n            status = wuffs_base__make_status(wuffs_json__error__unsupported_recursion_depth);\n            goto exit;\n          }\n          v_stack_byte = (v_depth / 32);\n          v_stack_bit = (v_depth & 31);\n          self->private_data.f_stack[v_stack_byte] &= (4294967295 ^ (((uint32_t)(1)) << v_stack_bit));\n          v_depth += 1;\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          *iop_a_dst++ = wuffs_base__make_token(\n              (((uint64_t)(v_vminor)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n              (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n          v_expect = 8114;\n          v_expect_after_value = 4356;\n          goto label__outer__continue;\n        } else if (v_class == 8) {\n          (iop_a_src += 1, wuffs_base__make_empty_struct());\n          if (v_depth <= 1) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(2101282)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            goto label__outer__break;\n          }\n          v_depth -= 1;\n          v_stack_byte = ((v_depth - 1) / 32);\n          v_stack_bit = ((v_depth - 1) & 31);\n          if (0 == (self->private_data.f_stack[v_stack_byte] & (((uint32_t)(1)) << v_stack_bit))) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(2105378)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            v_expect = 4356;\n            v_expect_after_value = 4356;\n          } else {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(2113570)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(1)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            v_expect = 4164;\n            v_expect_after_value = 4164;\n          }\n          goto label__outer__continue;\n        } else if (v_class == 9) {\n          v_match = wuffs_base__io_reader__match7(iop_a_src, io2_a_src, a_src,111546413966853);\n          if (v_match == 0) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(8388612)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(5)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            if (((uint64_t)(io2_a_src - iop_a_src)) < 5) {\n              status = wuffs_base__make_status(wuffs_json__error__internal_error_inconsistent_i_o);\n              goto exit;\n            }\n            (iop_a_src += 5, wuffs_base__make_empty_struct());\n            goto label__goto_parsed_a_leaf_value__break;\n          } else if (v_match == 1) {\n            status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n            WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(19);\n            goto label__outer__continue;\n          }\n        } else if (v_class == 10) {\n          v_match = wuffs_base__io_reader__match7(iop_a_src, io2_a_src, a_src,435762131972);\n          if (v_match == 0) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(8388616)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(4)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            if (((uint64_t)(io2_a_src - iop_a_src)) < 4) {\n              status = wuffs_base__make_status(wuffs_json__error__internal_error_inconsistent_i_o);\n              goto exit;\n            }\n            (iop_a_src += 4, wuffs_base__make_empty_struct());\n            goto label__goto_parsed_a_leaf_value__break;\n          } else if (v_match == 1) {\n            status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n            WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(20);\n            goto label__outer__continue;\n          }\n        } else if (v_class == 11) {\n          v_match = wuffs_base__io_reader__match7(iop_a_src, io2_a_src, a_src,465676103172);\n          if (v_match == 0) {\n            *iop_a_dst++ = wuffs_base__make_token(\n                (((uint64_t)(8388610)) << WUFFS_BASE__TOKEN__VALUE_MINOR__SHIFT) |\n                (((uint64_t)(4)) << WUFFS_BASE__TOKEN__LENGTH__SHIFT));\n            if (((uint64_t)(io2_a_src - iop_a_src)) < 4) {\n              status = wuffs_base__make_status(wuffs_json__error__internal_error_inconsistent_i_o);\n              goto exit;\n            }\n            (iop_a_src += 4, wuffs_base__make_empty_struct());\n            goto label__goto_parsed_a_leaf_value__break;\n          } else if (v_match == 1) {\n            status = wuffs_base__make_status(wuffs_base__suspension__short_read);\n            WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(21);\n            goto label__outer__continue;\n          }\n          if (self->private_impl.f_quirks[14]) {\n            if (a_dst) {\n              a_dst->meta.wi = ((size_t)(iop_a_dst - a_dst->data.ptr));\n            }\n            if (a_src) {\n              a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n            }\n            WUFFS_BASE__COROUTINE_SUSPENSION_POINT(22);\n            status = wuffs_json__decoder__decode_inf_nan(self, a_dst, a_src);\n            if (a_dst) {\n              iop_a_dst = a_dst->data.ptr + a_dst->meta.wi;\n            }\n            if (a_src) {\n              iop_a_src = a_src->data.ptr + a_src->meta.ri;\n            }\n            if (status.repr) {\n              goto suspend;\n            }\n            goto label__goto_parsed_a_leaf_value__break;\n          }\n        } else if (v_class == 12) {\n          if (self->private_impl.f_quirks[11] || self->private_impl.f_quirks[12]) {\n            if (a_dst) {\n              a_dst->meta.wi = ((size_t)(iop_a_dst - a_dst->data.ptr));\n            }\n            if (a_src) {\n              a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n            }\n            WUFFS_BASE__COROUTINE_SUSPENSION_POINT(23);\n            status = wuffs_json__decoder__decode_comment(self, a_dst, a_src);\n            if (a_dst) {\n              iop_a_dst = a_dst->data.ptr + a_dst->meta.wi;\n            }\n            if (a_src) {\n              iop_a_src = a_src->data.ptr + a_src->meta.ri;\n            }\n            if (status.repr) {\n              goto suspend;\n            }\n            if (self->private_impl.f_comment_type > 0) {\n              goto label__outer__continue;\n            }\n          }\n        }\n        status = wuffs_base__make_status(wuffs_json__error__bad_input);\n        goto exit;\n      }\n      label__goto_parsed_a_leaf_value__break:;\n      if (v_depth == 0) {\n        goto label__outer__break;\n      }\n      v_expect = v_expect_after_value;\n    }\n    label__outer__break:;\n    if (self->private_impl.f_quirks[17] || self->private_impl.f_quirks[18]) {\n      if (a_dst) {\n        a_dst->meta.wi = ((size_t)(iop_a_dst - a_dst->data.ptr));\n      }\n      if (a_src) {\n        a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n      }\n      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(24);\n      status = wuffs_json__decoder__decode_trailer(self, a_dst, a_src);\n      if (a_dst) {\n        iop_a_dst = a_dst->data.ptr + a_dst->meta.wi;\n      }\n      if (a_src) {\n        iop_a_src = a_src->data.ptr + a_src->meta.ri;\n      }\n      if (status.repr) {\n        goto suspend;\n      }\n    }\n    self->private_impl.f_end_of_data = true;\n\n    goto ok;\n    ok:\n    self->private_impl.p_decode_tokens[0] = 0;\n    goto exit;\n  }\n\n  goto suspend;\n  suspend:\n  self->private_impl.p_decode_tokens[0] = wuffs_base__status__is_suspension(&status) ? coro_susp_point : 0;\n  self->private_impl.active_coroutine = wuffs_base__status__is_suspension(&status) ? 1 : 0;\n  self->private_data.s_decode_tokens[0].v_depth = v_depth;\n  self->private_data.s_decode_tokens[0].v_expect = v_expect;\n  self->private_data.s_decode_tokens[0].v_expect_after_value = v_expect_after_value;\n\n  goto exit;\n  exit:\n  if (a_dst) {\n    a_dst->meta.wi = ((size_t)(iop_a_dst - a_dst->data.ptr));\n  }\n  if (a_src) {\n    a_src->meta.ri = ((size_t)(iop_a_src - a_src->data.ptr));\n  }\n\n  if (wuffs_base__status__is_error(&status)) {\n    self->private_impl.magic = WUFFS_BASE__DISABLED;\n  }\n  return status;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "// -------- func bmp.decoder.num_decoded_frames\n", "func_signal": "WUFFS_BASE__MAYBE_STATIC uint64_t\nwuffs_bmp__decoder__num_decoded_frames(\n    const wuffs_bmp__decoder* self)", "code": "{\n  if (!self) {\n    return 0;\n  }\n  if ((self->private_impl.magic != WUFFS_BASE__MAGIC) &&\n      (self->private_impl.magic != WUFFS_BASE__DISABLED)) {\n    return 0;\n  }\n\n  if (self->private_impl.f_call_sequence > 2) {\n    return 1;\n  }\n  return 0;\n}", "path": "wuffs/release/c/wuffs-v0.3.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "google/wuffs", "stars": 3686, "license": "other", "language": "c", "size": 35625}
{"docstring": "/**\n * Function to clean up things.\n */\n", "func_signal": "GLUSvoid terminate(GLUSvoid)", "code": "{\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\tif (g_texture)\n\t{\n\t\tglDeleteTextures(1, &g_texture);\n\n\t\tg_texture = 0;\n\t}\n\n\t//\n\n\tglBindVertexArray(0);\n\n\tif (g_vao)\n\t{\n\t\tglDeleteVertexArrays(1, &g_vao);\n\n\t\tg_vao = 0;\n\t}\n\n\t//\n\n\tglUseProgram(0);\n\n\tglusProgramDestroy(&g_program);\n}", "path": "OpenGL/Example37/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Function for initialization.\n */\n", "func_signal": "GLUSboolean init(GLUSvoid)", "code": "{\n    // The background will just cleared with blue color.\n    glClearColor(0.0f, 0.0f, 1.0f, 0.0f);\n\n    return GLUS_TRUE;\n}", "path": "OpenGL/Example01/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Function to render and display content. Swapping of the buffers is automatically done.\n *\n * @return true for continuing, false to exit the application\n */\n", "func_signal": "GLUSboolean update(GLUSfloat time)", "code": "{\n\tglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n\n\treturn GLUS_TRUE;\n}", "path": "OpenGL/Example37/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "// see http://mathworld.wolfram.com/Box-MullerTransformation.html\n", "func_signal": "GLUSfloat GLUSAPIENTRY glusRandomNormalf(const GLUSfloat mean, const GLUSfloat standardDeviation)", "code": "{\n\tGLUSfloat x1, x2;\n\n\t// Avoid logf(0.0f) and logf(1.0f)\n\tx1 = glusRandomUniformf(GLUS_UNIFORM_RANDOM_BIAS, 1.0f - GLUS_UNIFORM_RANDOM_BIAS);\n\tx2 = glusRandomUniformf(0.0f, 1.0f);\n\n\treturn mean + standardDeviation * (sqrtf(-2.0f * logf(x1)) * cosf(2.0f * GLUS_PI * x2));\n}", "path": "OpenGL/GLUS/src/glus_random.c", "commit_date": "2014-08-26 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Function for initialization.\n */\n", "func_signal": "GLUSboolean init(GLUSvoid)", "code": "{\n\tGLubyte pixels[WIDTH * HEIGHT * BYTES_PER_PIXEL];\n\n\t//\n\n\tGLUStextfile vertexSource;\n\tGLUStextfile fragmentSource;\n\n\t// Render (CPU) into pixel buffer\n\n\tif (!renderToPixelBuffer(pixels, WIDTH, HEIGHT))\n\t{\n\t\tprintf(\"Error: Could not render to pixel buffer.\\n\");\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Load full screen rendering shaders\n\n\tglusFileLoadText(\"../Example37/shader/fullscreen.vert.glsl\", &vertexSource);\n\tglusFileLoadText(\"../Example37/shader/texture.frag.glsl\", &fragmentSource);\n\n\tglusProgramBuildFromSource(&g_program, (const GLchar**)&vertexSource.text, 0, 0, 0, (const GLchar**)&fragmentSource.text);\n\n\tglusFileDestroyText(&vertexSource);\n\tglusFileDestroyText(&fragmentSource);\n\n\tg_textureLocation = glGetUniformLocation(g_program.program, \"u_texture\");\n\n\t// Generate texture\n\n\tglGenTextures(1, &g_texture);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, WIDTH, HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\t//\n\n\tglUseProgram(g_program.program);\n\n\t//\n\n    glGenVertexArrays(1, &g_vao);\n    glBindVertexArray(g_vao);\n\n\t//\n\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\tglUniform1i(g_textureLocation, 0);\n\n\treturn GLUS_TRUE;\n}", "path": "OpenGL/Example37/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "// Map, if possible, to GLFW keys\n", "func_signal": "static int glusOsTranslateKey(SDLKey key)", "code": "{\n\n\tswitch (key)\n\t{\n\t\tcase SDLK_SPACE:\n\t\t\treturn GLFW_KEY_SPACE;\n\t\tcase SDLK_ESCAPE:\n\t\t\treturn GLFW_KEY_ESCAPE;\n\t\tcase SDLK_F1:\n\t\t\treturn GLFW_KEY_F1;\n\t\tcase SDLK_F2:\n\t\t\treturn GLFW_KEY_F2;\n\t\tcase SDLK_F3:\n\t\t\treturn GLFW_KEY_F3;\n\t\tcase SDLK_F4:\n\t\t\treturn GLFW_KEY_F4;\n\t\tcase SDLK_F5:\n\t\t\treturn GLFW_KEY_F5;\n\t\tcase SDLK_F6:\n\t\t\treturn GLFW_KEY_F6;\n\t\tcase SDLK_F7:\n\t\t\treturn GLFW_KEY_F7;\n\t\tcase SDLK_F8:\n\t\t\treturn GLFW_KEY_F8;\n\t\tcase SDLK_F9:\n\t\t\treturn GLFW_KEY_F9;\n\t\tcase SDLK_F10:\n\t\t\treturn GLFW_KEY_F10;\n\t\tcase SDLK_F11:\n\t\t\treturn GLFW_KEY_F11;\n\t\tcase SDLK_F12:\n\t\t\treturn GLFW_KEY_F12;\n\t\tcase SDLK_F13:\n\t\t\treturn GLFW_KEY_F13;\n\t\tcase SDLK_F14:\n\t\t\treturn GLFW_KEY_F14;\n\t\tcase SDLK_F15:\n\t\t\treturn GLFW_KEY_F15;\n\t\tcase SDLK_UP:\n\t\t\treturn GLFW_KEY_UP;\n\t\tcase SDLK_DOWN:\n\t\t\treturn GLFW_KEY_DOWN;\n\t\tcase SDLK_LEFT:\n\t\t\treturn GLFW_KEY_LEFT;\n\t\tcase SDLK_RIGHT:\n\t\t\treturn GLFW_KEY_RIGHT;\n\t\tcase SDLK_LSHIFT:\n\t\t\treturn GLFW_KEY_LEFT_SHIFT;\n\t\tcase SDLK_RSHIFT:\n\t\t\treturn GLFW_KEY_RIGHT_SHIFT;\n\t\tcase SDLK_LCTRL:\n\t\t\treturn GLFW_KEY_LEFT_CONTROL;\n\t\tcase SDLK_RCTRL:\n\t\t\treturn GLFW_KEY_RIGHT_CONTROL;\n\t\tcase SDLK_LALT:\n\t\t\treturn GLFW_KEY_LEFT_ALT;\n\t\tcase SDLK_RALT:\n\t\t\treturn GLFW_KEY_RIGHT_ALT;\n\t\tcase SDLK_TAB:\n\t\t\treturn GLFW_KEY_TAB;\n\t\tcase SDLK_RETURN:\n\t\t\treturn GLFW_KEY_ENTER;\n\t\tcase SDLK_BACKSPACE:\n\t\t\treturn GLFW_KEY_BACKSPACE;\n\t\tcase SDLK_INSERT:\n\t\t\treturn GLFW_KEY_INSERT;\n\t\tcase SDLK_DELETE:\n\t\t\treturn GLFW_KEY_DELETE;\n\t\tcase SDLK_PAGEUP:\n\t\t\treturn GLFW_KEY_PAGE_UP;\n\t\tcase SDLK_PAGEDOWN:\n\t\t\treturn GLFW_KEY_PAGE_DOWN;\n\t\tcase SDLK_HOME:\n\t\t\treturn GLFW_KEY_HOME;\n\t\tcase SDLK_END:\n\t\t\treturn GLFW_KEY_END;\n\t\tcase SDLK_KP0:\n\t\t\treturn GLFW_KEY_KP_0;\n\t\tcase SDLK_KP1:\n\t\t\treturn GLFW_KEY_KP_1;\n\t\tcase SDLK_KP2:\n\t\t\treturn GLFW_KEY_KP_2;\n\t\tcase SDLK_KP3:\n\t\t\treturn GLFW_KEY_KP_3;\n\t\tcase SDLK_KP4:\n\t\t\treturn GLFW_KEY_KP_4;\n\t\tcase SDLK_KP5:\n\t\t\treturn GLFW_KEY_KP_5;\n\t\tcase SDLK_KP6:\n\t\t\treturn GLFW_KEY_KP_6;\n\t\tcase SDLK_KP7:\n\t\t\treturn GLFW_KEY_KP_7;\n\t\tcase SDLK_KP8:\n\t\t\treturn GLFW_KEY_KP_8;\n\t\tcase SDLK_KP9:\n\t\t\treturn GLFW_KEY_KP_9;\n\t\tcase SDLK_KP_DIVIDE:\n\t\t\treturn GLFW_KEY_KP_DIVIDE;\n\t\tcase SDLK_KP_MULTIPLY:\n\t\t\treturn GLFW_KEY_KP_MULTIPLY;\n\t\tcase SDLK_KP_MINUS:\n\t\t\treturn GLFW_KEY_KP_SUBTRACT;\n\t\tcase SDLK_KP_PLUS:\n\t\t\treturn GLFW_KEY_KP_ADD;\n\t\tcase SDLK_KP_PERIOD:\n\t\t\treturn GLFW_KEY_KP_DECIMAL;\n\t\tcase SDLK_KP_EQUALS:\n\t\t\treturn GLFW_KEY_KP_EQUAL;\n\t\tcase SDLK_KP_ENTER:\n\t\t\treturn GLFW_KEY_KP_ENTER;\n\t\tcase SDLK_NUMLOCK:\n\t\t\treturn GLFW_KEY_NUM_LOCK;\n\t\tcase SDLK_CAPSLOCK:\n\t\t\treturn GLFW_KEY_CAPS_LOCK;\n\t\tcase SDLK_SCROLLOCK:\n\t\t\treturn GLFW_KEY_SCROLL_LOCK;\n\t\tcase SDLK_PAUSE:\n\t\t\treturn GLFW_KEY_PAUSE;\n\t\tcase SDLK_LSUPER:\n\t\t\treturn GLFW_KEY_LEFT_SUPER;\n\t\tcase SDLK_RSUPER:\n\t\t\treturn GLFW_KEY_RIGHT_SUPER;\n\t\tcase SDLK_MENU:\n\t\t\treturn GLFW_KEY_MENU;\n\t\tdefault:\n\t\t\treturn (int)key;\n\t}\n\n\treturn GLFW_KEY_UNKNOWN;\n}", "path": "OpenGL/GLUS/src/glus_os_linux_raspberrypi_es.c", "commit_date": "2014-10-20 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Function to render and display content.\n */\n", "func_signal": "GLUSboolean renderWaterTexture(GLUSfloat passedTime)", "code": "{\n\tstatic WaveParameters waveParameters[NUMBERWAVES];\n\tstatic WaveDirections waveDirections[NUMBERWAVES];\n\n\tstatic GLfloat overallSteepness = 0.2f;\n\n\t// Waves\n\n    memset(waveParameters, 0, sizeof(waveParameters));\n    memset(waveDirections, 0, sizeof(waveDirections));\n\n\t// Wave One\n\twaveParameters[0].speed = 0.05f;\n\twaveParameters[0].amplitude = 0.02f;\n\twaveParameters[0].wavelength = 0.3f;\n\twaveParameters[0].steepness = overallSteepness / (waveParameters[0].wavelength * waveParameters[0].amplitude * (GLfloat) NUMBERWAVES);\n\twaveDirections[0].x = +1.0f;\n\twaveDirections[0].z = +1.5f;\n\n\t// Wave Two\n\twaveParameters[1].speed = 0.1f;\n\twaveParameters[1].amplitude = 0.01f;\n\twaveParameters[1].wavelength = 0.4f;\n\twaveParameters[1].steepness = overallSteepness / (waveParameters[1].wavelength * waveParameters[1].amplitude * (GLfloat) NUMBERWAVES);\n\twaveDirections[1].x = +0.8f;\n\twaveDirections[1].z = +0.2f;\n\n\t// Wave Thre\n\twaveParameters[2].speed = 0.04f;\n\twaveParameters[2].amplitude = 0.035f;\n\twaveParameters[2].wavelength = 0.1f;\n\twaveParameters[2].steepness = overallSteepness / (waveParameters[1].wavelength * waveParameters[1].amplitude * (GLfloat) NUMBERWAVES);\n\twaveDirections[2].x = -0.2f;\n\twaveDirections[2].z = -0.1f;\n\n\t// Wave Four\n\twaveParameters[3].speed = 0.05f;\n\twaveParameters[3].amplitude = 0.007f;\n\twaveParameters[3].wavelength = 0.2f;\n\twaveParameters[3].steepness = overallSteepness / (waveParameters[1].wavelength * waveParameters[1].amplitude * (GLfloat) NUMBERWAVES);\n\twaveDirections[3].x = -0.4f;\n\twaveDirections[3].z = -0.3f;\n\n    glViewport(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);\n\n    glBindFramebuffer(GL_FRAMEBUFFER, g_fboWaterTexture);\n\n    //\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\tglUseProgram(g_programWaterTexture.program);\n\n\tglUniform1f(g_passedTimeWaterTextureLocation, passedTime);\n\tglUniform4fv(g_waveParametersWaterTextureLocation, 4 * NUMBERWAVES, (GLfloat*) waveParameters);\n\tglUniform2fv(g_waveDirectionsWaterTextureLocation, 2 * NUMBERWAVES, (GLfloat*) waveDirections);\n\n    glFrontFace(GL_CCW);\n\n\tglBindVertexArray(g_vaoWaterTexture);\n\tglDrawElements(GL_TRIANGLES, g_numberIndicesWaterTexture, GL_UNSIGNED_INT, 0);\n\n\t//\n\n\tglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\tglViewport(0, 0, g_parentWidth, g_parentHeight);\n\n\treturn GLUS_TRUE;\n}", "path": "OpenGL/Example15/src/renderWaterTexture.c", "commit_date": "2014-08-21 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Main entry point.\n */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\tEGLint eglConfigAttributes[] = {\n\t        EGL_RED_SIZE, 8,\n\t        EGL_GREEN_SIZE, 8,\n\t        EGL_BLUE_SIZE, 8,\n\t        EGL_DEPTH_SIZE, 0,\n\t        EGL_STENCIL_SIZE, 0,\n\t        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,\n\t        EGL_NONE\n\t};\n\n    EGLint eglContextAttributes[] = {\n    \t\tEGL_CONTEXT_MAJOR_VERSION, 3,\n    \t\tEGL_CONTEXT_MINOR_VERSION, 2,\n    \t\tEGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE, EGL_TRUE,\n    \t\tEGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT,\n    \t\tEGL_NONE\n    };\n\n    glusWindowSetInitFunc(init);\n\n    glusWindowSetReshapeFunc(reshape);\n\n    glusWindowSetUpdateFunc(update);\n\n    glusWindowSetTerminateFunc(terminate);\n\n\t// To keep the program simple, no resize of the window.\n    if (!glusWindowCreate(\"GLUS Example Window\", WIDTH, HEIGHT, GLUS_FALSE, GLUS_TRUE, eglConfigAttributes, eglContextAttributes, 0))\n    {\n        printf(\"Could not create window!\\n\");\n        return -1;\n    }\n\n    glusWindowRun();\n\n    return 0;\n}", "path": "OpenGL/Example37/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "// Distance functions for sphere and oriented box.\n// see http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n", "func_signal": "static GLfloat distanceFunctionSphere(const GLfloat point[4], const Primitive* primitive)", "code": "{\n\tSphere* sphere = (Sphere*)primitive->data;\n\n\treturn glusSphereDistancePoint4f(sphere->center, sphere->radius, point);\n}", "path": "OpenGL/Example37/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Function for initialization.\n */\n", "func_signal": "GLUSboolean init(GLUSvoid)", "code": "{\n\tGLubyte pixels[WIDTH * HEIGHT * BYTES_PER_PIXEL];\n\n\t//\n\n\tGLUStextfile vertexSource;\n\tGLUStextfile fragmentSource;\n\n\t// Render (CPU) into pixel buffer\n\n\tif (!renderToPixelBuffer(pixels, WIDTH, HEIGHT))\n\t{\n\t\tprintf(\"Error: Could not render to pixel buffer.\\n\");\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Load full screen rendering shaders\n\n\tglusFileLoadText(\"../Example29/shader/fullscreen.vert.glsl\", &vertexSource);\n\tglusFileLoadText(\"../Example29/shader/texture.frag.glsl\", &fragmentSource);\n\n\tglusProgramBuildFromSource(&g_program, (const GLchar**)&vertexSource.text, 0, 0, 0, (const GLchar**)&fragmentSource.text);\n\n\tglusFileDestroyText(&vertexSource);\n\tglusFileDestroyText(&fragmentSource);\n\n\tg_textureLocation = glGetUniformLocation(g_program.program, \"u_texture\");\n\n\t// Generate texture\n\n\tglGenTextures(1, &g_texture);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, WIDTH, HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\t//\n\n\tglUseProgram(g_program.program);\n\n\t//\n\n    glGenVertexArrays(1, &g_vao);\n    glBindVertexArray(g_vao);\n\n\t//\n\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\tglUniform1i(g_textureLocation, 0);\n\n\treturn GLUS_TRUE;\n}", "path": "OpenGL/Example29/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/*\n * @author Pablo Alonso-Villaverde Roza\n * @author Norbert Nopper\n */\n", "func_signal": "GLUSboolean GLUSAPIENTRY glusShapeCreateTorusf(GLUSshape* shape, const GLUSfloat innerRadius, const GLUSfloat outerRadius, const GLUSuint numberSlices, const GLUSuint numberStacks)", "code": "{\n    // s, t = parametric values of the equations, in the range [0,1]\n    GLUSfloat s = 0;\n    GLUSfloat t = 0;\n\n    // sIncr, tIncr are increment values aplied to s and t on each loop iteration to generate the torus\n    GLUSfloat sIncr;\n    GLUSfloat tIncr;\n\n    // to store precomputed sin and cos values\n    GLUSfloat cos2PIs, sin2PIs, cos2PIt, sin2PIt;\n\n    GLUSuint numberVertices;\n    GLUSuint numberIndices;\n\n    // used later to help us calculating tangents vectors\n    GLUSfloat helpVector[3] = { 0.0f, 1.0f, 0.0f };\n    GLUSfloat helpQuaternion[4];\n    GLUSfloat helpMatrix[16];\n\n    // indices for each type of buffer (of vertices, indices, normals...)\n    GLUSuint indexVertices, indexIndices, indexNormals, indexTangents, indexTexCoords;\n\n    // loop counters\n    GLUSuint sideCount, faceCount;\n\n    // used to generate the indices\n    GLUSuint v0, v1, v2, v3;\n\n    GLUSfloat torusRadius = (outerRadius - innerRadius) / 2.0f;\n    GLUSfloat centerRadius = outerRadius - torusRadius;\n\n    numberVertices = (numberStacks + 1) * (numberSlices + 1);\n    numberIndices = numberStacks * numberSlices * 2 * 3; // 2 triangles per face * 3 indices per triangle\n\n    if (numberSlices < 3 || numberStacks < 3 || numberVertices > GLUS_MAX_VERTICES || numberIndices > GLUS_MAX_INDICES)\n    {\n        return GLUS_FALSE;\n    }\n\n    if (!shape)\n    {\n        return GLUS_FALSE;\n    }\n    glusShapeInitf(shape);\n\n    shape->numberVertices = numberVertices;\n    shape->numberIndices = numberIndices;\n\n    shape->vertices = (GLUSfloat*) glusMemoryMalloc(4 * numberVertices * sizeof(GLUSfloat));\n    shape->normals = (GLUSfloat*) glusMemoryMalloc(3 * numberVertices * sizeof(GLUSfloat));\n    shape->tangents = (GLUSfloat*) glusMemoryMalloc(3 * numberVertices * sizeof(GLUSfloat));\n    shape->texCoords = (GLUSfloat*) glusMemoryMalloc(2 * numberVertices * sizeof(GLUSfloat));\n    shape->indices = (GLUSindex*) glusMemoryMalloc(numberIndices * sizeof(GLUSindex));\n\n    if (!glusShapeCheckf(shape))\n    {\n        glusShapeDestroyf(shape);\n\n        return GLUS_FALSE;\n    }\n\n    sIncr = 1.0f / (GLUSfloat) numberSlices;\n    tIncr = 1.0f / (GLUSfloat) numberStacks;\n\n    // generate vertices and its attributes\n    for (sideCount = 0; sideCount <= numberSlices; ++sideCount, s += sIncr)\n    {\n        // precompute some values\n        cos2PIs = (GLUSfloat) cosf(2.0f * GLUS_PI * s);\n        sin2PIs = (GLUSfloat) sinf(2.0f * GLUS_PI * s);\n\n        t = 0.0f;\n        for (faceCount = 0; faceCount <= numberStacks; ++faceCount, t += tIncr)\n        {\n            // precompute some values\n            cos2PIt = (GLUSfloat) cosf(2.0f * GLUS_PI * t);\n            sin2PIt = (GLUSfloat) sinf(2.0f * GLUS_PI * t);\n\n            // generate vertex and stores it in the right position\n            indexVertices = ((sideCount * (numberStacks + 1)) + faceCount) * 4;\n            shape->vertices[indexVertices + 0] = (centerRadius + torusRadius * cos2PIt) * cos2PIs;\n            shape->vertices[indexVertices + 1] = (centerRadius + torusRadius * cos2PIt) * sin2PIs;\n            shape->vertices[indexVertices + 2] = torusRadius * sin2PIt;\n            shape->vertices[indexVertices + 3] = 1.0f;\n\n            // generate normal and stores it in the right position\n            // NOTE: cos (2PIx) = cos (x) and sin (2PIx) = sin (x) so, we can use this formula\n            //       normal = {cos(2PIs)cos(2PIt) , sin(2PIs)cos(2PIt) ,sin(2PIt)}\n            indexNormals = ((sideCount * (numberStacks + 1)) + faceCount) * 3;\n            shape->normals[indexNormals + 0] = cos2PIs * cos2PIt;\n            shape->normals[indexNormals + 1] = sin2PIs * cos2PIt;\n            shape->normals[indexNormals + 2] = sin2PIt;\n\n            // generate texture coordinates and stores it in the right position\n            indexTexCoords = ((sideCount * (numberStacks + 1)) + faceCount) * 2;\n            shape->texCoords[indexTexCoords + 0] = s;\n            shape->texCoords[indexTexCoords + 1] = t;\n\n            // use quaternion to get the tangent vector\n            glusQuaternionRotateRzf(helpQuaternion, 360.0f * s);\n            glusQuaternionGetMatrix4x4f(helpMatrix, helpQuaternion);\n\n            indexTangents = ((sideCount * (numberStacks + 1)) + faceCount) * 3;\n\n            glusMatrix4x4MultiplyVector3f(&shape->tangents[indexTangents], helpMatrix, helpVector);\n        }\n    }\n\n    // generate indices\n    indexIndices = 0;\n    for (sideCount = 0; sideCount < numberSlices; ++sideCount)\n    {\n        for (faceCount = 0; faceCount < numberStacks; ++faceCount)\n        {\n            // get the number of the vertices for a face of the torus. They must be < numVertices\n            v0 = ((sideCount * (numberStacks + 1)) + faceCount);\n            v1 = (((sideCount + 1) * (numberStacks + 1)) + faceCount);\n            v2 = (((sideCount + 1) * (numberStacks + 1)) + (faceCount + 1));\n            v3 = ((sideCount * (numberStacks + 1)) + (faceCount + 1));\n\n            // first triangle of the face, counter clock wise winding\n            shape->indices[indexIndices++] = v0;\n            shape->indices[indexIndices++] = v1;\n            shape->indices[indexIndices++] = v2;\n\n            // second triangle of the face, counter clock wise winding\n            shape->indices[indexIndices++] = v0;\n            shape->indices[indexIndices++] = v2;\n            shape->indices[indexIndices++] = v3;\n        }\n    }\n\n    if (!glusShapeFinalizef(shape))\n    {\n        glusShapeDestroyf(shape);\n\n        return GLUS_FALSE;\n    }\n\n    return GLUS_TRUE;\n}", "path": "OpenGL/GLUS/src/glus_shape.c", "commit_date": "2014-09-04 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "//\n// HDR Image loading\n//\n// see http://radsite.lbl.gov/radiance/refer/filefmts.pdf\n// see http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html\n// see http://radiance-online.org/cgi-bin/viewcvs.cgi/ray/src/common/color.c?view=markup\n// see http://www.flipcode.com/archives/HDR_Image_Reader.shtml\n", "func_signal": "GLUSboolean GLUSAPIENTRY glusImageLoadHdr(const GLUSchar* filename, GLUShdrimage* hdrimage)", "code": "{\n\tFILE* file;\n\n\tGLUSchar buffer[256];\n\tGLUSchar currentChar, oldChar;\n\n\tGLUSint width, height, x, y, repeat, factor, i;\n\n\tGLUSubyte* scanline;\n\tGLUSubyte rgbe[4];\n\tGLUSubyte prevRgbe[4];\n\n\tGLUSfloat rgb[3];\n\n\tsize_t elementsRead;\n\n\t// check, if we have a valid pointer\n\tif (!filename || !hdrimage)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\thdrimage->width = 0;\n\thdrimage->height = 0;\n\thdrimage->depth = 0;\n\thdrimage->data = 0;\n\n\t// open filename in \"read binary\" mode\n\tfile = glusFileOpen(filename, \"rb\");\n\n\tif (!file)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\telementsRead = fread(buffer, 10, 1, file);\n\n\tif (!_glusFileCheckRead(file, elementsRead, 1))\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\t//\n\t// Information header\n\t//\n\n\t// Identifier\n\tif (strncmp(buffer, \"#?RADIANCE\", 10))\n\t{\n\t\tglusFileClose(file);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Go to variables\n\tif (fseek(file, 1, SEEK_CUR))\n\t{\n\t\tglusFileClose(file);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Variables\n\tcurrentChar = 0;\n\twhile (GLUS_TRUE)\n\t{\n\t\toldChar = currentChar;\n\n\t\telementsRead = fread(&currentChar, 1, 1, file);\n\n\t\tif (!_glusFileCheckRead(file, elementsRead, 1))\n\t\t{\n\t\t\treturn GLUS_FALSE;\n\t\t}\n\n\t\t// Empty line indicates end of header\n\t\tif (currentChar == '\\n' && oldChar == '\\n')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Resolution\n\ti = 0;\n\twhile (GLUS_TRUE)\n\t{\n\t\telementsRead = fread(&currentChar, 1, 1, file);\n\n\t\tif (!_glusFileCheckRead(file, elementsRead, 1))\n\t\t{\n\t\t\treturn GLUS_FALSE;\n\t\t}\n\n\t\tbuffer[i++] = currentChar;\n\n\t\tif (currentChar == '\\n')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!sscanf(buffer, \"-Y %d +X %d\", &height, &width))\n\t{\n\t\tglusFileClose(file);\n\n\t\tglusImageDestroyHdr(hdrimage);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\thdrimage->width = (GLUSushort)width;\n\thdrimage->height = (GLUSushort)height;\n\thdrimage->depth = 1;\n\thdrimage->format = GLUS_RGB;\n\n\thdrimage->data = (GLUSfloat*)glusMemoryMalloc(width * height * 3 * sizeof(GLUSfloat));\n\n\tif (!hdrimage->data)\n\t{\n\t\tglusFileClose(file);\n\n\t\tglusImageDestroyHdr(hdrimage);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Scanlines\n\tscanline = (GLUSubyte*)glusMemoryMalloc(width * 4 * sizeof(GLUSubyte));\n\n\tif (!scanline)\n\t{\n\t\tglusMemoryFree(scanline);\n\n\t\tglusFileClose(file);\n\n\t\tglusImageDestroyHdr(hdrimage);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\tprevRgbe[0] = 0;\n\tprevRgbe[1] = 0;\n\tprevRgbe[2] = 0;\n\tprevRgbe[3] = 0;\n\n\tfactor = 1;\n\tx = 0;\n\ty = height - 1;\n\twhile (y >= 0)\n\t{\n\t\telementsRead = fread(buffer, 4, 1, file);\n\n\t\tif (!_glusFileCheckRead(file, elementsRead, 1))\n\t\t{\n\t\t\tglusMemoryFree(scanline);\n\n\t\t\tglusImageDestroyHdr(hdrimage);\n\n\t\t\treturn GLUS_FALSE;\n\t\t}\n\n\t\trepeat = 0;\n\n\t\t// Examine value\n\t\tif (width < 32768 && buffer[0] == 2 && buffer[1] == 2 && buffer[2] == ((width >> 8) & 0xFF) && buffer[3] == (width & 0xFF))\n\t\t{\n\t\t\t// New RLE decoding\n\n\t\t\tGLUSint scanlinePixels = glusImageDecodeNewRLE(file, scanline, width);\n\n\t\t\tif (scanlinePixels < 0)\n\t\t\t{\n\t\t\t\tglusMemoryFree(scanline);\n\n\t\t\t\t// File already closed\n\n\t\t\t\tglusImageDestroyHdr(hdrimage);\n\n\t\t\t\treturn GLUS_FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < scanlinePixels; i++)\n\t\t\t{\n\t\t\t\tif (y < 0)\n\t\t\t\t{\n\t\t\t\t\tglusMemoryFree(scanline);\n\n\t\t\t\t\tglusFileClose(file);\n\n\t\t\t\t\tglusImageDestroyHdr(hdrimage);\n\n\t\t\t\t\treturn GLUS_FALSE;\n\t\t\t\t}\n\n\t\t\t\tglusImageConvertRGBE(rgb, &scanline[i * 4]);\n\n\t\t\t\thdrimage->data[(width * y + x) * 3 + 0] = rgb[0];\n\t\t\t\thdrimage->data[(width * y + x) * 3 + 1] = rgb[1];\n\t\t\t\thdrimage->data[(width * y + x) * 3 + 2] = rgb[2];\n\n\t\t\t\tx++;\n\t\t\t\tif (x >= width)\n\t\t\t\t{\n\t\t\t\t\ty--;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfactor = 1;\n\n\t\t\tprevRgbe[0] = scanline[(scanlinePixels - 1) * 4 + 0];\n\t\t\tprevRgbe[1] = scanline[(scanlinePixels - 1) * 4 + 1];\n\t\t\tprevRgbe[2] = scanline[(scanlinePixels - 1) * 4 + 2];\n\t\t\tprevRgbe[3] = scanline[(scanlinePixels - 1) * 4 + 3];\n\n\t\t\tcontinue;\n\t\t}\n\t\telse if (buffer[0] == 1 && buffer[1] == 1 && buffer[2] == 1)\n\t\t{\n\t\t\t// Old RLE decoding\n\n\t\t\trepeat = buffer[3] * factor;\n\n\t\t\trgbe[0] = prevRgbe[0];\n\t\t\trgbe[1] = prevRgbe[1];\n\t\t\trgbe[2] = prevRgbe[2];\n\t\t\trgbe[3] = prevRgbe[3];\n\n\t\t\tfactor *= 256;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// No RLE decoding\n\n\t\t\trepeat = 1;\n\n\t\t\trgbe[0] = buffer[0];\n\t\t\trgbe[1] = buffer[1];\n\t\t\trgbe[2] = buffer[2];\n\t\t\trgbe[3] = buffer[3];\n\n\t\t\tfactor = 1;\n\t\t}\n\n\t\tglusImageConvertRGBE(rgb, rgbe);\n\n\t\twhile (repeat)\n\t\t{\n\t\t\tif (y < 0)\n\t\t\t{\n\t\t\t\tglusMemoryFree(scanline);\n\n\t\t\t\tglusFileClose(file);\n\n\t\t\t\tglusImageDestroyHdr(hdrimage);\n\n\t\t\t\treturn GLUS_FALSE;\n\t\t\t}\n\n\t\t\thdrimage->data[(width * y + x) * 3 + 0] = rgb[0];\n\t\t\thdrimage->data[(width * y + x) * 3 + 1] = rgb[1];\n\t\t\thdrimage->data[(width * y + x) * 3 + 2] = rgb[2];\n\n\t\t\tx++;\n\t\t\tif (x >= width)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tx = 0;\n\t\t\t}\n\n\t\t\trepeat--;\n\t\t}\n\n\t\tprevRgbe[0] = rgbe[0];\n\t\tprevRgbe[1] = rgbe[1];\n\t\tprevRgbe[2] = rgbe[2];\n\t\tprevRgbe[3] = rgbe[3];\n\t}\n\n\tglusMemoryFree(scanline);\n\n\tglusFileClose(file);\n\n\treturn GLUS_TRUE;\n}", "path": "OpenGL/GLUS/src/glus_image_hdr.c", "commit_date": "2015-09-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Main entry point.\n */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\tEGLint eglConfigAttributes[] = {\n\t        EGL_RED_SIZE, 8,\n\t        EGL_GREEN_SIZE, 8,\n\t        EGL_BLUE_SIZE, 8,\n\t        EGL_DEPTH_SIZE, 24,\n\t        EGL_STENCIL_SIZE, 0,\n\t        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,\n\t        EGL_NONE\n\t};\n\n    EGLint eglContextAttributes[] = {\n    \t\tEGL_CONTEXT_MAJOR_VERSION, 3,\n    \t\tEGL_CONTEXT_MINOR_VERSION, 2,\n    \t\tEGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE, EGL_TRUE,\n    \t\tEGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT,\n    \t\tEGL_NONE\n    };\n\n    glusWindowSetInitFunc(init);\n\n    glusWindowSetReshapeFunc(reshape);\n\n    glusWindowSetUpdateFunc(update);\n\n    glusWindowSetTerminateFunc(terminate);\n\n    if (!glusWindowCreate(\"GLUS Example Window\", 640, 480, GLUS_FALSE, GLUS_FALSE, eglConfigAttributes, eglContextAttributes, 0))\n    {\n        printf(\"Could not create window!\\n\");\n        return -1;\n    }\n\n    glusWindowRun();\n\n    return 0;\n}", "path": "OpenGL/Example15/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Function to render and display content. Swapping of the buffers is automatically done.\n *\n * @return true for continuing, false to exit the application\n */\n", "func_signal": "GLUSboolean update(GLUSfloat time)", "code": "{\n    // Now, the background is painted blue.\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    return GLUS_TRUE;\n}", "path": "OpenGL/Example01/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "// Map, if possible, to GLFW keys\n", "func_signal": "static int glusOsTranslateKey(int key)", "code": "{\n\tswitch (key)\n\t{\n\t\tcase KEY_SPACE:\n\t\t\treturn GLFW_KEY_SPACE;\n\t\tcase KEY_APOSTROPHE:\n\t\t\treturn GLFW_KEY_APOSTROPHE;\n\t\tcase KEY_COMMA:\n\t\t\treturn GLFW_KEY_COMMA;\n\t\tcase KEY_MINUS:\n\t\t\treturn GLFW_KEY_MINUS;\n\t\tcase KEY_DOT:\n\t\t\treturn GLFW_KEY_PERIOD;\n\t\tcase KEY_SLASH:\n\t\t\treturn GLFW_KEY_SLASH;\n\t\tcase KEY_0:\n\t\t\treturn GLFW_KEY_0;\n\t\tcase KEY_1:\n\t\t\treturn GLFW_KEY_1;\n\t\tcase KEY_2:\n\t\t\treturn GLFW_KEY_2;\n\t\tcase KEY_3:\n\t\t\treturn GLFW_KEY_3;\n\t\tcase KEY_4:\n\t\t\treturn GLFW_KEY_4;\n\t\tcase KEY_5:\n\t\t\treturn GLFW_KEY_5;\n\t\tcase KEY_6:\n\t\t\treturn GLFW_KEY_6;\n\t\tcase KEY_7:\n\t\t\treturn GLFW_KEY_7;\n\t\tcase KEY_8:\n\t\t\treturn GLFW_KEY_8;\n\t\tcase KEY_9:\n\t\t\treturn GLFW_KEY_9;\n\t\tcase KEY_SEMICOLON:\n\t\t\treturn GLFW_KEY_SEMICOLON;\n\t\tcase KEY_EQUAL:\n\t\t\treturn GLFW_KEY_EQUAL;\n\t\tcase KEY_A:\n\t\t\treturn GLFW_KEY_A;\n\t\tcase KEY_B:\n\t\t\treturn GLFW_KEY_B;\n\t\tcase KEY_C:\n\t\t\treturn GLFW_KEY_C;\n\t\tcase KEY_D:\n\t\t\treturn GLFW_KEY_D;\n\t\tcase KEY_E:\n\t\t\treturn GLFW_KEY_E;\n\t\tcase KEY_F:\n\t\t\treturn GLFW_KEY_F;\n\t\tcase KEY_G:\n\t\t\treturn GLFW_KEY_G;\n\t\tcase KEY_H:\n\t\t\treturn GLFW_KEY_H;\n\t\tcase KEY_I:\n\t\t\treturn GLFW_KEY_I;\n\t\tcase KEY_J:\n\t\t\treturn GLFW_KEY_J;\n\t\tcase KEY_K:\n\t\t\treturn GLFW_KEY_K;\n\t\tcase KEY_L:\n\t\t\treturn GLFW_KEY_L;\n\t\tcase KEY_M:\n\t\t\treturn GLFW_KEY_M;\n\t\tcase KEY_N:\n\t\t\treturn GLFW_KEY_N;\n\t\tcase KEY_O:\n\t\t\treturn GLFW_KEY_O;\n\t\tcase KEY_P:\n\t\t\treturn GLFW_KEY_P;\n\t\tcase KEY_Q:\n\t\t\treturn GLFW_KEY_Q;\n\t\tcase KEY_R:\n\t\t\treturn GLFW_KEY_R;\n\t\tcase KEY_S:\n\t\t\treturn GLFW_KEY_S;\n\t\tcase KEY_T:\n\t\t\treturn GLFW_KEY_T;\n\t\tcase KEY_U:\n\t\t\treturn GLFW_KEY_U;\n\t\tcase KEY_V:\n\t\t\treturn GLFW_KEY_V;\n\t\tcase KEY_W:\n\t\t\treturn GLFW_KEY_W;\n\t\tcase KEY_X:\n\t\t\treturn GLFW_KEY_X;\n\t\tcase KEY_Y:\n\t\t\treturn GLFW_KEY_Y;\n\t\tcase KEY_Z:\n\t\t\treturn GLFW_KEY_Z;\n\t\tcase KEY_LEFTBRACE:\n\t\t\treturn GLFW_KEY_LEFT_BRACKET;\n\t\tcase KEY_BACKSLASH:\n\t\t\treturn GLFW_KEY_BACKSLASH;\n\t\tcase KEY_RIGHTBRACE:\n\t\t\treturn GLFW_KEY_RIGHT_BRACKET;\n\t\tcase KEY_GRAVE:\n\t\t\treturn GLFW_KEY_GRAVE_ACCENT;\n\t\tcase KEY_ESC:\n\t\t\treturn GLFW_KEY_ESCAPE;\n\t\tcase KEY_F1:\n\t\t\treturn GLFW_KEY_F1;\n\t\tcase KEY_F2:\n\t\t\treturn GLFW_KEY_F2;\n\t\tcase KEY_F3:\n\t\t\treturn GLFW_KEY_F3;\n\t\tcase KEY_F4:\n\t\t\treturn GLFW_KEY_F4;\n\t\tcase KEY_F5:\n\t\t\treturn GLFW_KEY_F5;\n\t\tcase KEY_F6:\n\t\t\treturn GLFW_KEY_F6;\n\t\tcase KEY_F7:\n\t\t\treturn GLFW_KEY_F7;\n\t\tcase KEY_F8:\n\t\t\treturn GLFW_KEY_F8;\n\t\tcase KEY_F9:\n\t\t\treturn GLFW_KEY_F9;\n\t\tcase KEY_F10:\n\t\t\treturn GLFW_KEY_F10;\n\t\tcase KEY_F11:\n\t\t\treturn GLFW_KEY_F11;\n\t\tcase KEY_F12:\n\t\t\treturn GLFW_KEY_F12;\n\t\tcase KEY_F13:\n\t\t\treturn GLFW_KEY_F13;\n\t\tcase KEY_F14:\n\t\t\treturn GLFW_KEY_F14;\n\t\tcase KEY_F15:\n\t\t\treturn GLFW_KEY_F15;\n\t\tcase KEY_UP:\n\t\t\treturn GLFW_KEY_UP;\n\t\tcase KEY_DOWN:\n\t\t\treturn GLFW_KEY_DOWN;\n\t\tcase KEY_LEFT:\n\t\t\treturn GLFW_KEY_LEFT;\n\t\tcase KEY_RIGHT:\n\t\t\treturn GLFW_KEY_RIGHT;\n\t\tcase KEY_LEFTSHIFT:\n\t\t\treturn GLFW_KEY_LEFT_SHIFT;\n\t\tcase KEY_RIGHTSHIFT:\n\t\t\treturn GLFW_KEY_RIGHT_SHIFT;\n\t\tcase KEY_LEFTCTRL:\n\t\t\treturn GLFW_KEY_LEFT_CONTROL;\n\t\tcase KEY_RIGHTCTRL:\n\t\t\treturn GLFW_KEY_RIGHT_CONTROL;\n\t\tcase KEY_LEFTALT:\n\t\t\treturn GLFW_KEY_LEFT_ALT;\n\t\tcase KEY_RIGHTALT:\n\t\t\treturn GLFW_KEY_RIGHT_ALT;\n\t\tcase KEY_TAB:\n\t\t\treturn GLFW_KEY_TAB;\n\t\tcase KEY_ENTER:\n\t\t\treturn GLFW_KEY_ENTER;\n\t\tcase KEY_BACKSPACE:\n\t\t\treturn GLFW_KEY_BACKSPACE;\n\t\tcase KEY_INSERT:\n\t\t\treturn GLFW_KEY_INSERT;\n\t\tcase KEY_DELETE:\n\t\t\treturn GLFW_KEY_DELETE;\n\t\tcase KEY_PAGEUP:\n\t\t\treturn GLFW_KEY_PAGE_UP;\n\t\tcase KEY_PAGEDOWN:\n\t\t\treturn GLFW_KEY_PAGE_DOWN;\n\t\tcase KEY_HOME:\n\t\t\treturn GLFW_KEY_HOME;\n\t\tcase KEY_END:\n\t\t\treturn GLFW_KEY_END;\n\t\tcase KEY_KP0:\n\t\t\treturn GLFW_KEY_KP_0;\n\t\tcase KEY_KP1:\n\t\t\treturn GLFW_KEY_KP_1;\n\t\tcase KEY_KP2:\n\t\t\treturn GLFW_KEY_KP_2;\n\t\tcase KEY_KP3:\n\t\t\treturn GLFW_KEY_KP_3;\n\t\tcase KEY_KP4:\n\t\t\treturn GLFW_KEY_KP_4;\n\t\tcase KEY_KP5:\n\t\t\treturn GLFW_KEY_KP_5;\n\t\tcase KEY_KP6:\n\t\t\treturn GLFW_KEY_KP_6;\n\t\tcase KEY_KP7:\n\t\t\treturn GLFW_KEY_KP_7;\n\t\tcase KEY_KP8:\n\t\t\treturn GLFW_KEY_KP_8;\n\t\tcase KEY_KP9:\n\t\t\treturn GLFW_KEY_KP_9;\n\t\tcase KEY_KPSLASH:\n\t\t\treturn GLFW_KEY_KP_DIVIDE;\n\t\tcase KEY_KPASTERISK:\n\t\t\treturn GLFW_KEY_KP_MULTIPLY;\n\t\tcase KEY_KPMINUS:\n\t\t\treturn GLFW_KEY_KP_SUBTRACT;\n\t\tcase KEY_KPPLUS:\n\t\t\treturn GLFW_KEY_KP_ADD;\n\t\tcase KEY_KPDOT:\n\t\t\treturn GLFW_KEY_KP_DECIMAL;\n\t\tcase KEY_KPEQUAL:\n\t\t\treturn GLFW_KEY_KP_EQUAL;\n\t\tcase KEY_KPENTER:\n\t\t\treturn GLFW_KEY_KP_ENTER;\n\t\tcase KEY_NUMLOCK:\n\t\t\treturn GLFW_KEY_NUM_LOCK;\n\t\tcase KEY_CAPSLOCK:\n\t\t\treturn GLFW_KEY_CAPS_LOCK;\n\t\tcase KEY_SCROLLLOCK:\n\t\t\treturn GLFW_KEY_SCROLL_LOCK;\n\t\tcase KEY_PAUSE:\n\t\t\treturn GLFW_KEY_PAUSE;\n\t\tcase KEY_LEFTMETA:\n\t\t\treturn GLFW_KEY_LEFT_SUPER;\n\t\tcase KEY_RIGHTMETA:\n\t\t\treturn GLFW_KEY_RIGHT_SUPER;\n\t\tcase KEY_MENU:\n\t\t\treturn GLFW_KEY_MENU;\n\t\tdefault:\n\t\t\treturn key;\n\t}\n\n\treturn GLFW_KEY_UNKNOWN;\n}", "path": "OpenGL/GLUS/src/glus_os_linux_imx6_es.c", "commit_date": "2015-12-15 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Main entry point.\n */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\tEGLint eglConfigAttributes[] = {\n\t        EGL_RED_SIZE, 8,\n\t        EGL_GREEN_SIZE, 8,\n\t        EGL_BLUE_SIZE, 8,\n\t        EGL_DEPTH_SIZE, 0,\n\t        EGL_STENCIL_SIZE, 0,\n\t        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,\n\t        EGL_NONE\n\t};\n\n    EGLint eglContextAttributes[] = {\n    \t\tEGL_CONTEXT_MAJOR_VERSION, 3,\n    \t\tEGL_CONTEXT_MINOR_VERSION, 2,\n    \t\tEGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE, EGL_TRUE,\n    \t\tEGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT,\n    \t\tEGL_NONE\n    };\n\n    glusWindowSetInitFunc(init);\n\n    glusWindowSetReshapeFunc(reshape);\n\n    glusWindowSetUpdateFunc(update);\n\n    glusWindowSetTerminateFunc(terminate);\n\n\t// To keep the program simple, no resize of the window.\n    if (!glusWindowCreate(\"GLUS Example Window\", WIDTH, HEIGHT, GLUS_FALSE, GLUS_TRUE, eglConfigAttributes, eglContextAttributes, 0))\n    {\n        printf(\"Could not create window!\\n\");\n        return -1;\n    }\n\n    glusWindowRun();\n\n    return 0;\n}", "path": "OpenGL/Example29/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Function to clean up things.\n */\n", "func_signal": "GLUSvoid terminate(GLUSvoid)", "code": "{\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\tif (g_texture)\n\t{\n\t\tglDeleteTextures(1, &g_texture);\n\n\t\tg_texture = 0;\n\t}\n\n\t//\n\n\tglBindVertexArray(0);\n\n\tif (g_vao)\n\t{\n\t\tglDeleteVertexArrays(1, &g_vao);\n\n\t\tg_vao = 0;\n\t}\n\n\t//\n\n\tglUseProgram(0);\n\n\tglusProgramDestroy(&g_program);\n}", "path": "OpenGL/Example29/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "// see http://mathworld.wolfram.com/HammersleyPointSet.html\n// see https://github.com/wdas/brdf/blob/master/src/shaderTemplates/brdfIBL.frag\n", "func_signal": "GLUSboolean GLUSAPIENTRY glusRandomHammersleyf(GLUSfloat result[2], const GLUSuint sample, const GLUSubyte m)", "code": "{\n\tGLUSuint revertSample;\n\tGLUSfloat binaryFractionFactor;\n\n\tif (!result)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Check, if m is in the allowed range, as only 32bit unsigned integer is supported.\n\tif (m == 0 || m > 32)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// If not all bits are used: Check, if sample is out of bounds.\n\tif (m < 32 && sample >= (GLUSuint)(1 << m))\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Revert bits by swapping blockwise. Lower bits are moved up and higher bits down.\n\trevertSample = (sample << 16u) | (sample >> 16u);\n\trevertSample = ((revertSample & 0x00ff00ffu) << 8u) | ((revertSample & 0xff00ff00u) >> 8u);\n\trevertSample = ((revertSample & 0x0f0f0f0fu) << 4u) | ((revertSample & 0xf0f0f0f0u) >> 4u);\n\trevertSample = ((revertSample & 0x33333333u) << 2u) | ((revertSample & 0xccccccccu) >> 2u);\n\trevertSample = ((revertSample & 0x55555555u) << 1u) | ((revertSample & 0xaaaaaaaau) >> 1u);\n\n\t// Shift back, as only m bits are used.\n\trevertSample = revertSample >> (32 - m);\n\n\t// Results are in range [0.0 1.0] and not [0.0, 1.0[.\n\tbinaryFractionFactor = 1.0f / (powf(2.0f, (GLUSfloat)m) - 1.0f);\n\n\tresult[0] = (GLUSfloat)revertSample * binaryFractionFactor;\n\tresult[1] = (GLUSfloat)sample * binaryFractionFactor;\n\n\treturn GLUS_TRUE;\n}", "path": "OpenGL/GLUS/src/glus_random.c", "commit_date": "2014-08-26 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Main entry point.\n */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\tEGLint eglConfigAttributes[] = {\n\t        EGL_RED_SIZE, 8,\n\t        EGL_GREEN_SIZE, 8,\n\t        EGL_BLUE_SIZE, 8,\n\t        EGL_DEPTH_SIZE, 0,\n\t        EGL_STENCIL_SIZE, 0,\n\t        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,\n\t        EGL_NONE\n\t};\n\n    EGLint eglContextAttributes[] = {\n    \t\tEGL_CONTEXT_MAJOR_VERSION, 3,\n    \t\tEGL_CONTEXT_MINOR_VERSION, 2,\n    \t\tEGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE, EGL_TRUE,\n    \t\tEGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT,\n    \t\tEGL_NONE\n    };\n\n    glusWindowSetInitFunc(init);\n\n    glusWindowSetReshapeFunc(reshape);\n\n    glusWindowSetUpdateFunc(update);\n\n    glusWindowSetTerminateFunc(terminate);\n\n    if (!glusWindowCreate(\"GLUS Example Window\", 640, 480, GLUS_FALSE, GLUS_FALSE, eglConfigAttributes, eglContextAttributes, 0))\n    {\n        printf(\"Could not create window!\\n\");\n        return -1;\n    }\n\n    glusWindowRun();\n\n    return 0;\n}", "path": "OpenGL/Example01/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/**\n * Function to render and display content. Swapping of the buffers is automatically done.\n *\n * @return true for continuing, false to exit the application\n */\n", "func_signal": "GLUSboolean update(GLUSfloat time)", "code": "{\n\tglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n\n\treturn GLUS_TRUE;\n}", "path": "OpenGL/Example29/src/main.c", "commit_date": "2015-02-10 00:00:00", "repo_name": "McNopper/OpenGL", "stars": 2247, "license": "apache-2.0", "language": "c", "size": 233228}
{"docstring": "/* int args_main(int, char **) */\n", "func_signal": "int cmd_help(context_t *context)", "code": "{\n  int i;\n  printf(\"Available commands:\\n\");\n  for (i = 0; dispatch[i].name != NULL; i++)\n    printf(\"  %s\\n\", dispatch[i].name);\n\n  /* \"help\" can be invoked on errors, like when xdotool is given no arguments,\n   * so let's make sure we only consume if we have a context */\n  if (context != NULL) {\n    consume_args(context, 1);\n  }\n\n  return 0;\n}", "path": "xdotool/xdotool.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* Add by Lee Pumphret 2007-07-28\n * Modified slightly by Jordan Sissel */\n", "func_signal": "int xdo_get_focused_window(const xdo_t *xdo, Window *window_ret)", "code": "{\n  int ret = 0;\n  int unused_revert_ret;\n\n  ret = XGetInputFocus(xdo->xdpy, window_ret, &unused_revert_ret);\n\n  /* Xvfb with no window manager and given otherwise no input, with \n   * a single client, will return the current focused window as '1'\n   * I think this is a bug, so let's alert the user. */\n  if (*window_ret == 1) {\n    fprintf(stderr, \n            \"XGetInputFocus returned the focused window of %ld. \"\n            \"This is likely a bug in the X server.\\n\", *window_ret);\n  }\n  return _is_success(\"XGetInputFocus\", ret == 0, xdo);\n}", "path": "xdotool/xdo.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* Arbitrary window property retrieval\n * slightly modified version from xprop.c from Xorg */\n", "func_signal": "unsigned char *xdo_get_window_property_by_atom(const xdo_t *xdo, Window window, Atom atom,\n                                            long *nitems, Atom *type, int *size)", "code": "{\n  Atom actual_type;\n  int actual_format;\n  unsigned long _nitems;\n  /*unsigned long nbytes;*/\n  unsigned long bytes_after; /* unused */\n  unsigned char *prop;\n  int status;\n\n  status = XGetWindowProperty(xdo->xdpy, window, atom, 0, (~0L),\n                              False, AnyPropertyType, &actual_type,\n                              &actual_format, &_nitems, &bytes_after,\n                              &prop);\n  if (status == BadWindow) {\n    fprintf(stderr, \"window id # 0x%lx does not exists!\", window);\n    return NULL;\n  } if (status != Success) {\n    fprintf(stderr, \"XGetWindowProperty failed!\");\n    return NULL;\n  }\n\n  /*\n   *if (actual_format == 32)\n   *  nbytes = sizeof(long);\n   *else if (actual_format == 16)\n   *  nbytes = sizeof(short);\n   *else if (actual_format == 8)\n   *  nbytes = 1;\n   *else if (actual_format == 0)\n   *  nbytes = 0;\n   */\n\n  if (nitems != NULL) {\n    *nitems = _nitems;\n  }\n\n  if (type != NULL) {\n    *type = actual_type;\n  }\n\n  if (size != NULL) {\n    *size = actual_format;\n  }\n  return prop;\n}", "path": "xdotool/xdo.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* xdotool_debug */\n", "func_signal": "void xdotool_output(context_t *context, const char *format, ...)", "code": "{\n  context = context; /* Do something with context to avoid warnings */\n  va_list args;\n\n  va_start(args, format);\n  vfprintf(stdout, format, args);\n  fprintf(stdout, \"\\n\");\n  fflush(stdout);\n}", "path": "xdotool/xdotool.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* int _xdo_is_window_visible */\n", "func_signal": "static int check_window_match(const xdo_t *xdo, Window wid,\n                              const xdo_search_t *search)", "code": "{\n  regex_t title_re;\n  regex_t class_re;\n  regex_t classname_re;\n  regex_t name_re;\n\n\n  if (!compile_re(search->title, &title_re) \\\n      || !compile_re(search->winclass, &class_re) \\\n      || !compile_re(search->winclassname, &classname_re) \\\n      || !compile_re(search->winname, &name_re)) {\n\n    regfree(&title_re);\n    regfree(&class_re);\n    regfree(&classname_re);\n    regfree(&name_re);\n\n    return False;\n  }\n\n  /* Set this to 1 for dev debugging */\n  static const int debug = 0;\n\n  int visible_ok, pid_ok, title_ok, name_ok, class_ok, classname_ok, desktop_ok;\n  int visible_want, pid_want, title_want, name_want, class_want, classname_want, desktop_want;\n\n  visible_ok = pid_ok = title_ok = name_ok = class_ok = classname_ok = desktop_ok = True;\n    //(search->require == SEARCH_ANY ? False : True);\n\n  desktop_want = search->searchmask & SEARCH_DESKTOP;\n  visible_want = search->searchmask & SEARCH_ONLYVISIBLE;\n  pid_want = search->searchmask & SEARCH_PID;\n  title_want = search->searchmask & SEARCH_TITLE;\n  name_want = search->searchmask & SEARCH_NAME;\n  class_want = search->searchmask & SEARCH_CLASS;\n  classname_want = search->searchmask & SEARCH_CLASSNAME;\n\n  do {\n    if (desktop_want) {\n      long desktop = -1;\n\n      /* We're modifying xdo here, but since we restore it, we're still \n       * obeying the \"const\" contract. */\n      int old_quiet = xdo->quiet;\n      xdo_t *xdo2 = (xdo_t *)xdo;\n      xdo2->quiet = 1;\n      int ret = xdo_get_desktop_for_window(xdo2, wid, &desktop);\n      xdo2->quiet = old_quiet;\n\n      /* Desktop matched if we support desktop queries *and* the desktop is\n       * equal */\n      desktop_ok = (ret == XDO_SUCCESS && desktop == search->desktop);\n    }\n\n    /* Visibility is a hard condition, fail always if we wanted \n     * only visible windows and this one isn't */\n    if (visible_want && !_xdo_is_window_visible(xdo, wid)) {\n      if (debug) fprintf(stderr, \"skip %ld visible\\n\", wid); \n      visible_ok = False;\n      break;\n    }\n\n    if (pid_want && !_xdo_match_window_pid(xdo, wid, search->pid)) {\n      if (debug) fprintf(stderr, \"skip %ld pid\\n\", wid); \n      pid_ok = False;\n    }\n\n    if (title_want && !_xdo_match_window_title(xdo, wid, &title_re)) {\n      if (debug) fprintf(stderr, \"skip %ld title\\n\", wid);\n      title_ok = False;\n    }\n\n    if (name_want && !_xdo_match_window_name(xdo, wid, &name_re)) {\n      if (debug) fprintf(stderr, \"skip %ld winname\\n\", wid);\n      name_ok = False;\n    }\n\n    if (class_want && !_xdo_match_window_class(xdo, wid, &class_re)) {\n      if (debug) fprintf(stderr, \"skip %ld winclass\\n\", wid);\n      class_ok = False;\n    }\n\n    if (classname_want && !_xdo_match_window_classname(xdo, wid, &classname_re)) {\n      if (debug) fprintf(stderr, \"skip %ld winclassname\\n\", wid);\n      classname_ok = False;\n    }\n  } while (0);\n\n  regfree(&title_re);\n  regfree(&class_re);\n  regfree(&classname_re);\n  regfree(&name_re);\n\n  if (debug) {\n    fprintf(stderr, \"win: %ld, pid:%d, title:%d, name:%d, class:%d, visible:%d\\n\",\n            wid, pid_ok, title_ok, name_ok, class_ok, visible_ok);\n  }\n\n  switch (search->require) {\n    case SEARCH_ALL:\n      return visible_ok && pid_ok && title_ok && name_ok && class_ok && classname_ok && desktop_ok;\n      break;\n    case SEARCH_ANY:\n      return visible_ok && ((pid_want && pid_ok) || (title_want && title_ok) \\\n                            || (name_want && name_ok) \\\n                            || (class_want && class_ok) \\\n                            || (classname_want && classname_ok)) \\\n                         && desktop_ok;\n      break;\n  }\n  \n  fprintf(stderr, \n          \"Unexpected code reached. search->require is not valid? (%d); \"\n          \"this may be a bug?\\n\",\n          search->require);\n  return False;\n}", "path": "xdotool/xdo_search.c", "commit_date": "2015-05-21 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* int _xdo_match_window_classname */\n", "func_signal": "static int _xdo_match_window_pid(const xdo_t *xdo, Window window, const int pid)", "code": "{\n  int window_pid;\n\n  window_pid = xdo_get_pid_window(xdo, window);\n  if (pid == window_pid) {\n    return True;\n  } else {\n    return False;\n  }\n}", "path": "xdotool/xdo_search.c", "commit_date": "2015-05-21 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* void window_save(context_t *, Window) */\n", "func_signal": "int window_is_valid(context_t *context, const char *window_arg)", "code": "{\n  if (window_arg == NULL) {\n    return True;\n  }\n\n  if (window_arg[0] != '%') {\n    return True;\n  }\n\n  /* Selected a window with %N or %@, but are there windows on the stack? */\n  if (context->nwindows == 0) {\n    fprintf(stderr, \"There are no windows in the stack\\n\");\n    return False;\n  }\n\n  if (window_arg[1] == '\\0') {\n    fprintf(stderr, \"Invalid window stack selection '%s'\\n\", window_arg);\n    return False;\n  }\n\n  if (window_arg[1] == '@') {\n    return True;\n  }\n\n  int window_index = atoi(window_arg + 1);\n  if (abs(window_index - 1) >= context->nwindows || (window_index == 0)) {\n    fprintf(stderr, \"Invalid window stack selection '%s' (out of range)\\n\", window_arg);\n    return False;\n  }\n\n  return True;\n}", "path": "xdotool/xdotool.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* int _xdo_match_window_class */\n", "func_signal": "static int _xdo_match_window_classname(const xdo_t *xdo, Window window, regex_t *re)", "code": "{\n  XWindowAttributes attr;\n  XClassHint classhint;\n  XGetWindowAttributes(xdo->xdpy, window, &attr);\n\n  if (XGetClassHint(xdo->xdpy, window, &classhint)) {\n    if ((classhint.res_name) && (regexec(re, classhint.res_name, 0, NULL, 0) == 0)) {\n      XFree(classhint.res_name);\n      XFree(classhint.res_class);\n      return True;\n    }\n    XFree(classhint.res_name);\n    XFree(classhint.res_class);\n  } else {\n    /* Treat windows with no class name as empty strings */\n    if (regexec(re, \"\", 0, NULL, 0) == 0) {\n      return True;\n    }\n  }\n  return False;\n}", "path": "xdotool/xdo_search.c", "commit_date": "2015-05-21 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* int args_main(int, char **) */\n", "func_signal": "int context_execute(context_t *context)", "code": "{\n  int cmd_found = 0;\n  int i = 0;\n  char *cmd = NULL;\n  int ret = XDO_SUCCESS;\n\n  /* Loop until all argv is consumed. */\n  while (context->argc > 0 && ret == XDO_SUCCESS) {\n    cmd = context->argv[0];\n    cmd_found = 0;\n    for (i = 0; dispatch[i].name != NULL && !cmd_found; i++) {\n      if (!strcasecmp(dispatch[i].name, cmd)) {\n        cmd_found = 1;\n        optind = 0;\n        if (context->debug) {\n          fprintf(stderr, \"command: %s\\n\", cmd);\n        }\n        ret = dispatch[i].func(context);\n      }\n    }\n\n    if (!cmd_found) {\n      fprintf(stderr, \"%s: Unknown command: %s\\n\", context->prog, cmd);\n      fprintf(stderr, \"Run '%s help' if you want a command list\\n\", context->prog);\n      ret = 1;\n    }\n  } /* while ... */\n  return ret;\n}", "path": "xdotool/xdotool.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* Like xdo_get_focused_window, but return the first ancestor-or-self window\n * having a property of WM_CLASS. This allows you to get the \"real\" or\n * top-level-ish window having focus rather than something you may\n * not expect to be the window having focused. */\n", "func_signal": "int xdo_get_focused_window_sane(const xdo_t *xdo, Window *window_ret)", "code": "{\n  xdo_get_focused_window(xdo, window_ret);\n  xdo_find_window_client(xdo, *window_ret, window_ret, XDO_FIND_PARENTS);\n  return _is_success(\"xdo_get_focused_window_sane\", *window_ret == 0, xdo);\n}", "path": "xdotool/xdo.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* int window_is_valid(context_t *, const char *) */\n", "func_signal": "int window_get_arg(context_t *context, int min_arg, int window_arg_pos,\n                   const char **window_arg)", "code": "{\n  if (context->argc < min_arg) {\n    fprintf(stderr, \"Too few arguments (got %d, minimum is %d)\\n\",\n            context->argc, min_arg);\n    return False;\n  } else if (context->argc == min_arg) {\n    /* nothing, keep default */\n  } else if (context->argc > min_arg) {\n    if (is_command(context->argv[min_arg])) {\n      /* keep default */\n    } else {\n      /* got enough args, let's use the window you asked for */\n      *window_arg = context->argv[window_arg_pos];\n      consume_args(context, 1);\n    }\n  }\n\n  if (!window_is_valid(context, *window_arg)) {\n    fprintf(stderr, \"Invalid window '%s'\\n\", *window_arg);\n    return False;\n  }\n\n  return True;\n}", "path": "xdotool/xdotool.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* int _xdo_match_window_name */\n", "func_signal": "static int _xdo_match_window_class(const xdo_t *xdo, Window window, regex_t *re)", "code": "{\n  XWindowAttributes attr;\n  XClassHint classhint;\n  XGetWindowAttributes(xdo->xdpy, window, &attr);\n\n  if (XGetClassHint(xdo->xdpy, window, &classhint)) {\n    //printf(\"%d: class %s\\n\", window, classhint.res_class);\n    if ((classhint.res_class) && (regexec(re, classhint.res_class, 0, NULL, 0) == 0)) {\n      XFree(classhint.res_name);\n      XFree(classhint.res_class);\n      return True;\n    }\n    XFree(classhint.res_name);\n    XFree(classhint.res_class);\n  } else {\n    /* Treat windows with no class as empty strings */\n    if (regexec(re, \"\", 0, NULL, 0) == 0) {\n      return True;\n    }\n  }\n  return False;\n}", "path": "xdotool/xdo_search.c", "commit_date": "2015-05-21 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* XXX: Return proper code if errors found */\n", "func_signal": "int xdo_enter_text_window(const xdo_t *xdo, Window window, const char *string, useconds_t delay)", "code": "{\n\n  /* Since we're doing down/up, the delay should be based on the number\n   * of keys pressed (including shift). Since up/down is two calls,\n   * divide by two. */\n  delay /= 2;\n\n  /* XXX: Add error handling */\n  //int nkeys = strlen(string);\n  //charcodemap_t *keys = calloc(nkeys, sizeof(charcodemap_t));\n  charcodemap_t key;\n  //int modifier = 0;\n  setlocale(LC_CTYPE,\"\");\n  mbstate_t ps = { 0 };\n  ssize_t len;\n  while ( (len = mbsrtowcs(&key.key, &string, 1, &ps)) ) {\n    if (len == -1) {\n      fprintf(stderr, \"Invalid multi-byte sequence encountered\\n\");\n      return XDO_ERROR;\n    }\n    _xdo_charcodemap_from_char(xdo, &key);\n    if (key.code == 0 && key.symbol == NoSymbol) {\n      fprintf(stderr, \"I don't know which key produces '%lc', skipping.\\n\",\n              key.key);\n      continue;\n    } else {\n      //printf(\"Found key for %c\\n\", key.key);\n      //printf(\"code: %d\\n\", key.code);\n      //printf(\"sym: %s\\n\", XKeysymToString(key.symbol));\n    }\n\n    //printf(stderr,\n            //\"Key '%c' maps to code %d / sym %lu in group %d / mods %d (%s)\\n\",\n            //key.key, key.code, key.symbol, key.group, key.modmask,\n            //(key.needs_binding == 1) ? \"needs binding\" : \"ok\");\n\n    //_xdo_send_key(xdo, window, keycode, modstate, True, delay);\n    //_xdo_send_key(xdo, window, keycode, modstate, False, delay);\n    xdo_send_keysequence_window_list_do(xdo, window, &key, 1, True, NULL, delay / 2);\n    key.needs_binding = 0;\n    xdo_send_keysequence_window_list_do(xdo, window, &key, 1, False, NULL, delay / 2);\n\n    /* XXX: Flush here or at the end? or never? */\n    //XFlush(xdo->xdpy);\n  } /* walk string generating a keysequence */\n\n  //free(keys);\n  return XDO_SUCCESS;\n}", "path": "xdotool/xdo.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* XRaiseWindow is ignored in ion3 and Gnome2. Is it even useful? */\n", "func_signal": "int xdo_raise_window(const xdo_t *xdo, Window wid)", "code": "{\n  int ret = 0;\n  ret = XRaiseWindow(xdo->xdpy, wid);\n  XFlush(xdo->xdpy);\n  return _is_success(\"XRaiseWindow\", ret == 0, xdo);\n}", "path": "xdotool/xdo.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* Helper functions */\n", "func_signal": "static KeySym _xdo_keysym_from_char(const xdo_t *xdo, wchar_t key)", "code": "{\n  int i = 0;\n  int len = xdo->charcodes_len;\n\n  //printf(\"Finding symbol for key '%c'\\n\", key);\n  for (i = 0; i < len; i++) {\n    //printf(\"  => %c vs %c (%d)\\n\",\n           //key, xdo->charcodes[i].key, (xdo->charcodes[i].key == key));\n    if (xdo->charcodes[i].key == key) {\n      //printf(\"  => MATCH to symbol: %lu\\n\", xdo->charcodes[i].symbol);\n      return xdo->charcodes[i].symbol;\n    }\n  }\n\n  if (key >= 0x100) key += 0x01000000;\n  if (XKeysymToString(key)) return key;\n  return NoSymbol;\n}", "path": "xdotool/xdo.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* Used for printing things conditionally based on xdo->quiet */\n", "func_signal": "void _xdo_eprintf(const xdo_t *xdo, int hushable, const char *format, ...)", "code": "{\n  va_list args;\n\n  va_start(args, format);\n  if (xdo->quiet == True && hushable) {\n    return;\n  }\n\n  vfprintf(stderr, format, args);\n  fprintf(stderr, \"\\n\");\n}", "path": "xdotool/xdo.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* void consume_args(context_t *, int) */\n", "func_signal": "void window_save(context_t *context, Window window)", "code": "{\n  if (context->windows != NULL) {\n    free(context->windows);\n  }\n\n  context->windows = calloc(1, sizeof(Window));\n  context->nwindows = 1;\n  context->windows[0] = window;\n}", "path": "xdotool/xdotool.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* int _xdo_match_window_pid */\n", "func_signal": "static int compile_re(const char *pattern, regex_t *re)", "code": "{\n  int ret;\n  if (pattern == NULL) {\n    regcomp(re, \"^$\", REG_EXTENDED | REG_ICASE);\n    return True;\n  }\n\n  ret = regcomp(re, pattern, REG_EXTENDED | REG_ICASE);\n  if (ret != 0) {\n    fprintf(stderr, \"Failed to compile regex (return code %d): '%s'\\n\", ret, pattern);\n    return False;\n  }\n  return True;\n}", "path": "xdotool/xdo_search.c", "commit_date": "2015-05-21 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* int _xdo_match_window_title */\n", "func_signal": "static int _xdo_match_window_name(const xdo_t *xdo, Window window, regex_t *re)", "code": "{\n  /* historically in xdo, 'match_name' matched the classhint 'name' which we\n   * match in _xdo_match_window_classname. But really, most of the time 'name'\n   * refers to the window manager name for the window, which is displayed in\n   * the titlebar */\n  int i;\n  int count = 0;\n  char **list = NULL;\n  XTextProperty tp;\n\n\n  XGetWMName(xdo->xdpy, window, &tp);\n  if (tp.nitems > 0) {\n    //XmbTextPropertyToTextList(xdo->xdpy, &tp, &list, &count);\n    Xutf8TextPropertyToTextList(xdo->xdpy, &tp, &list, &count);\n    for (i = 0; i < count; i++) {\n      if (regexec(re, list[i], 0, NULL, 0) == 0) {\n        XFreeStringList(list);\n        XFree(tp.value);\n        return True;\n      }\n    }\n  } else {\n    /* Treat windows with no names as empty strings */\n    if (regexec(re, \"\", 0, NULL, 0) == 0) {\n      XFreeStringList(list);\n      XFree(tp.value);\n      return True;\n    }\n  }\n  XFreeStringList(list);\n  XFree(tp.value);\n  return False;\n}", "path": "xdotool/xdo_search.c", "commit_date": "2015-05-21 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/* Added 2007-07-28 - Lee Pumphret */\n", "func_signal": "int cmd_getwindowfocus(context_t *context)", "code": "{\n  int ret = 0;\n  int get_toplevel_focus = 1;\n  Window window = 0;\n  char *cmd = context->argv[0];\n\n  int c;\n  static struct option longopts[] = {\n    { \"help\", no_argument, NULL, 'h' },\n    { NULL, no_argument, NULL, 'f' },\n    { 0, 0, 0, 0 },\n  };\n  static const char *usage = \n    \"Usage: %s [-f]\\n\"\n    \"-f     - Report the window with focus even if we don't think it is a \\n\"\n    \"         top-level window. The default is to find the top-level window\\n\"\n    \"         that has focus.\\n\";\n  int option_index;\n\n  while ((c = getopt_long_only(context->argc, context->argv, \"+fh\",\n                               longopts, &option_index)) != -1) {\n    switch (c) {\n      case 'h':\n        printf(usage, cmd);\n        consume_args(context, context->argc);\n        return EXIT_SUCCESS;\n        break;\n      case 'f':\n        get_toplevel_focus = 0;\n        break;\n      default:\n        fprintf(stderr, usage, cmd);\n        return EXIT_FAILURE;\n    }\n  }\n\n  consume_args(context, optind);\n\n  //if (context->argc > 0) {\n    //fprintf(stderr, usage, cmd);\n    //return 1;\n  //}\n\n  if (get_toplevel_focus) {\n    ret = xdo_get_focused_window_sane(context->xdo, &window);\n  } else {\n    ret = xdo_get_focused_window(context->xdo, &window);\n  }\n\n  if (ret) {\n    fprintf(stderr, \"xdo_focus_window reported an error\\n\");\n  } else { \n    /* only print if we're the last command */\n    if (context->argc == 0) {\n      window_print(window);\n    }\n    window_save(context, window);\n  }\n\n  return ret;\n}", "path": "xdotool/cmd_getwindowfocus.c", "commit_date": "2012-06-07 00:00:00", "repo_name": "jordansissel/xdotool", "stars": 2949, "license": "other", "language": "c", "size": 1087}
{"docstring": "/** See dropt_vsnprintf. */\n", "func_signal": "int\ndropt_snprintf(dropt_char* s, size_t n, const dropt_char* format, ...)", "code": "{\n    int ret;\n    va_list args;\n    va_start(args, format);\n    ret = dropt_vsnprintf(s, n, format, args);\n    va_end(args);\n    return ret;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_ssgetfreespace\n  *\n  * RETURNS:\n  *     The amount of free space in the dropt_stringstream's internal\n  *       buffer, measured in dropt_char-s.  Space used for the\n  *       NUL-terminator is considered free. (The amount of free space\n  *       therefore is always positive.)\n  */\n", "func_signal": "static size_t\ndropt_ssgetfreespace(const dropt_stringstream* ss)", "code": "{\n    assert(ss != NULL);\n    assert(ss->maxSize > 0);\n    assert(ss->maxSize > ss->used);\n    return ss->maxSize - ss->used;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** See dropt_vasprintf. */\n", "func_signal": "dropt_char*\ndropt_asprintf(const dropt_char* format, ...)", "code": "{\n    dropt_char* s;\n\n    va_list args;\n    va_start(args, format);\n    s = dropt_vasprintf(format, args);\n    va_end(args);\n\n    return s;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_ssresize\n  *\n  *     Resizes a dropt_stringstream's internal buffer.  If the requested\n  *     size is less than the amount of buffer already in use, the buffer\n  *     will be shrunk to the minimum size necessary.\n  *\n  * PARAMETERS:\n  *     IN/OUT ss : The dropt_stringstream.\n  *     IN n      : The desired buffer size, in dropt_char-s.\n  *\n  * RETURNS:\n  *     The new size of the dropt_stringstream's buffer in dropt_char-s,\n  *       including space for a terminating NUL.\n  */\n", "func_signal": "static size_t\ndropt_ssresize(dropt_stringstream* ss, size_t n)", "code": "{\n    assert(ss != NULL);\n\n    /* Don't allow shrinking if it will truncate the string. */\n    if (n < ss->maxSize) { n = MAX(n, ss->used + 1 /* NUL */); }\n\n    /* There should always be a buffer to point to. */\n    assert(n > 0);\n\n    if (n != ss->maxSize)\n    {\n        dropt_char* p = dropt_safe_realloc(ss->string, n, sizeof *ss->string);\n        if (p != NULL)\n        {\n            ss->string = p;\n            ss->maxSize = n;\n            assert(ss->maxSize > 0);\n         }\n    }\n    return ss->maxSize;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_strndup\n  *\n  *     Duplicates the first n characters of a string.\n  *\n  * PARAMETERS:\n  *     IN s : The string to duplicate.\n  *     IN n : The maximum number of dropt_char-s to copy, excluding the\n  *              NUL-terminator.\n  *\n  * RETURNS:\n  *     The duplicated string, which is always NUL-terminated.  The caller\n  *       is responsible for calling free() on it when no longer needed.\n  *     Returns NULL on error.\n  */\n", "func_signal": "dropt_char*\ndropt_strndup(const dropt_char* s, size_t n)", "code": "{\n    dropt_char* copy;\n    size_t len = 0;\n\n    assert(s != NULL);\n\n    while (len < n && s[len] != DROPT_TEXT_LITERAL('\\0'))\n    {\n        len++;\n    }\n\n    if (len + 1 < len)\n    {\n        /* This overflow check shouldn't be strictly necessary.  len can be\n         * at most SIZE_MAX, so SIZE_MAX + 1 can wrap around to 0, but\n         * dropt_safe_malloc will return NULL for a 0-sized allocation.\n         * However, favor defensive paranoia.\n         */\n        return NULL;\n    }\n\n    copy = dropt_safe_malloc(len + 1 /* NUL */, sizeof *copy);\n    if (copy != NULL)\n    {\n        memcpy(copy, s, len * sizeof *copy);\n        copy[len] = DROPT_TEXT_LITERAL('\\0');\n    }\n\n    return copy;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** handle_face\n  *\n  *     An example of a custom option handler.  Usually the stock callbacks\n  *     (e.g. dropt_handle_bool, dropt_handle_int, dropt_handle_string,\n  *     etc.) should be sufficient for most purposes.\n  */\n", "func_signal": "static dropt_error\nhandle_face(dropt_context* context, const char* optionArgument, void* handlerData)", "code": "{\n    dropt_error err = dropt_error_none;\n    face_type* face = handlerData;\n    assert(face != NULL);\n\n    /* Option handlers should handle 'optionArgument' being NULL (if the\n     * option's argument is optional and wasn't supplied) or being the\n     * empty string (if a user explicitly passed an empty string (e.g.\n     * --face=\"\").\n     */\n    if (optionArgument == NULL || optionArgument[0] == '\\0')\n    {\n        err = dropt_error_insufficient_arguments;\n    }\n    else if (strcmp(optionArgument, \"heads\") == 0)\n    {\n        *face = heads;\n    }\n    else if (strcmp(optionArgument, \"tails\") == 0)\n    {\n        *face = tails;\n    }\n    else\n    {\n        /* Reject the value as being inappropriate for this handler. */\n        err = dropt_error_mismatch;\n    }\n\n    return err;\n}", "path": "packr/DrOpt/dropt/dropt_example.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_vsnprintf\n  *\n  *     vsnprintf wrapper to provide ISO C99-compliant behavior.\n  *\n  * PARAMETERS:\n  *     OUT s     : The destination buffer.  May be NULL if n is 0.\n  *                 If non-NULL, always NUL-terminated.\n  *     IN n      : The size of the destination buffer, measured in\n  *                   dropt_char-s.\n  *     IN format : printf-style format specifier.  Must not be NULL.\n  *     IN args   : Arguments to insert into the formatted string.\n  *\n  * RETURNS:\n  *     The number of characters that would be written to the destination\n  *       buffer if it's sufficiently large, excluding the NUL-terminator.\n  *     Returns -1 on error.\n  */\n", "func_signal": "int\ndropt_vsnprintf(dropt_char* s, size_t n, const dropt_char* format, va_list args)", "code": "{\n#if __STDC_VERSION__ >= 199901L || __GNUC__\n    /* ISO C99-compliant.\n     *\n     * As far as I can tell, gcc's implementation of vsnprintf has always\n     * matched the behavior required by the C99 standard (which is to\n     * return the necessary buffer size).\n     *\n     * Note that this won't work with wchar_t because there is no true,\n     * standard wchar_t equivalent of snprintf.  swprintf comes close but\n     * doesn't return the necessary buffer size (and the standard does not\n     * provide a guaranteed way to test if truncation occurred), and its\n     * format string can't be used interchangeably with snprintf.\n     *\n     * It's simpler not to support wchar_t on non-Windows platforms.\n     */\n    assert(format != NULL);\n    return vsnprintf(s, n, format, args);\n#elif defined __BORLANDC__\n    /* Borland's compiler neglects to NUL-terminate. */\n    int ret;\n    assert(format != NULL);\n    ret = vsnprintf(s, n, format, args);\n    if (n != 0) { s[n - 1] = DROPT_TEXT_LITERAL('\\0'); }\n    return ret;\n#elif defined _MSC_VER\n    /* _vsntprintf and _vsnprintf_s on Windows don't have C99 semantics;\n     * they return -1 if truncation occurs.\n     */\n    va_list argsCopy;\n    int ret;\n\n    assert(format != NULL);\n\n    va_copy(argsCopy, args);\n    ret = _vsctprintf(format, argsCopy);\n    va_end(argsCopy);\n\n    if (n != 0)\n    {\n        assert(s != NULL);\n\n    #if _MSC_VER >= 1400\n        (void) _vsntprintf_s(s, n, _TRUNCATE, format, args);\n    #else\n        /* This version doesn't necessarily NUL-terminate.  Sigh. */\n        (void) _vsnprintf(s, n, format, args);\n        s[n - 1] = DROPT_TEXT_LITERAL('\\0');\n    #endif\n    }\n\n    return ret;\n\n#else\n    #error Unsupported platform.  dropt_vsnprintf unimplemented.\n    return -1;\n#endif\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_vasprintf\n  *\n  *     Allocates a formatted string with vprintf semantics.\n  *\n  * PARAMETERS:\n  *     IN format : printf-style format specifier.  Must not be NULL.\n  *     IN args   : Arguments to insert into the formatted string.\n  *\n  * RETURNS:\n  *     The formatted string, which is always NUL-terminated.  The caller\n  *       is responsible for calling free() on it when no longer needed.\n  *     Returns NULL on error.\n  */\n", "func_signal": "dropt_char*\ndropt_vasprintf(const dropt_char* format, va_list args)", "code": "{\n    dropt_char* s = NULL;\n    int len;\n    va_list argsCopy;\n    assert(format != NULL);\n\n    va_copy(argsCopy, args);\n    len = dropt_vsnprintf(NULL, 0, format, argsCopy);\n    va_end(argsCopy);\n\n    if (len >= 0)\n    {\n        size_t n = len + 1 /* NUL */;\n        s = dropt_safe_malloc(n, sizeof *s);\n        if (s != NULL)\n        {\n            dropt_vsnprintf(s, n, format, args);\n        }\n    }\n\n    return s;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** See dropt_vssprintf. */\n", "func_signal": "int\ndropt_ssprintf(dropt_stringstream* ss, const dropt_char* format, ...)", "code": "{\n    int n;\n\n    va_list args;\n    va_start(args, format);\n    n = dropt_vssprintf(ss, format, args);\n    va_end(args);\n\n    return n;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_ssclear\n  *\n  *     Clears and re-initializes a dropt_stringstream.\n  *\n  * PARAMETERS:\n  *     IN/OUT ss : The dropt_stringstream\n  */\n", "func_signal": "void\ndropt_ssclear(dropt_stringstream* ss)", "code": "{\n    assert(ss != NULL);\n\n    ss->string[0] = DROPT_TEXT_LITERAL('\\0');\n    ss->used = 0;\n\n    dropt_ssresize(ss, default_stringstream_buffer_size);\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_ssclose\n  *\n  *     Destroys a dropt_stringstream.\n  *\n  * PARAMETERS:\n  *     IN/OUT ss : The dropt_stringstream.\n  */\n", "func_signal": "void\ndropt_ssclose(dropt_stringstream* ss)", "code": "{\n    if (ss != NULL)\n    {\n        free(ss->string);\n        free(ss);\n    }\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_ssopen\n  *\n  *     Constructs a new dropt_stringstream.\n  *\n  * RETURNS:\n  *     An initialized dropt_stringstream.  The caller is responsible for\n  *       calling either dropt_ssclose() or dropt_ssfinalize() on it when\n  *       no longer needed.\n  *     Returns NULL on error.\n  */\n", "func_signal": "dropt_stringstream*\ndropt_ssopen(void)", "code": "{\n    dropt_stringstream* ss = malloc(sizeof *ss);\n    if (ss != NULL)\n    {\n        ss->used = 0;\n        ss->maxSize = default_stringstream_buffer_size;\n        ss->string = dropt_safe_malloc(ss->maxSize, sizeof *ss->string);\n        if (ss->string == NULL)\n        {\n            free(ss);\n            ss = NULL;\n        }\n        else\n        {\n            ss->string[0] = DROPT_TEXT_LITERAL('\\0');\n        }\n    }\n    return ss;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_handle_int\n  *\n  *     Parses an integer from the given string.\n  *\n  * PARAMETERS:\n  *     IN/OUT context    : The options context.\n  *     IN optionArgument : A string representing a base-10 integer.\n  *                         If NULL, returns dropt_error_insufficient_arguments.\n  *     OUT handlerData   : An int*.\n  *                         On success, set to the interpreted integer.\n  *                         On error, left untouched.\n  *\n  * RETURNS:\n  *     dropt_error_none\n  *     dropt_error_unknown\n  *     dropt_error_bad_configuration\n  *     dropt_error_insufficient_arguments\n  *     dropt_error_mismatch\n  *     dropt_error_overflow\n  */\n", "func_signal": "dropt_error\ndropt_handle_int(dropt_context* context, const dropt_char* optionArgument,\n                 void* handlerData)", "code": "{\n    dropt_error err = dropt_error_none;\n    int val = 0;\n    int* out = handlerData;\n\n    if (out == NULL)\n    {\n        DROPT_MISUSE(\"No handler data specified.\");\n        err = dropt_error_bad_configuration;\n    }\n    else if (optionArgument == NULL || optionArgument[0] == DROPT_TEXT_LITERAL('\\0'))\n    {\n        err = dropt_error_insufficient_arguments;\n    }\n    else\n    {\n        dropt_char* end;\n        long n;\n        errno = 0;\n        n = dropt_strtol(optionArgument, &end, 10);\n\n        /* Check that we matched at least one digit.\n         * (strtol/strtoul will return 0 if fed a string with no digits.)\n         */\n        if (*end == DROPT_TEXT_LITERAL('\\0') && end > optionArgument)\n        {\n            if (errno == ERANGE || n < INT_MIN || n > INT_MAX)\n            {\n                err = dropt_error_overflow;\n                val = (n < 0) ? INT_MIN : INT_MAX;\n            }\n            else if (errno == 0)\n            {\n                val = (int) n;\n            }\n            else\n            {\n                err = dropt_error_unknown;\n            }\n        }\n        else\n        {\n            err = dropt_error_mismatch;\n        }\n    }\n\n    if (err == dropt_error_none) { *out = val; }\n    return err;\n}", "path": "packr/DrOpt/dropt/src/dropt_handlers.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_strnicmp\n  *\n  *     Compares the first n characters of two strings, ignoring case\n  *       differences.  Not recommended for non-ASCII strings.\n  *\n  * PARAMETERS:\n  *     IN s, t : The strings to compare.\n  *     IN n    : The maximum number of dropt_char-s to compare.\n  *\n  * RETURNS:\n  *     0 if the strings are equivalent,\n  *     < 0 if s is lexically less than t,\n  *     > 0 if s is lexically greater than t.\n  */\n", "func_signal": "int\ndropt_strnicmp(const dropt_char* s, const dropt_char* t, size_t n)", "code": "{\n    assert(s != NULL);\n    assert(t != NULL);\n\n    if (s == t) { return 0; }\n\n    while (n--)\n    {\n        if (*s == DROPT_TEXT_LITERAL('\\0') && *t == DROPT_TEXT_LITERAL('\\0'))\n        {\n            break;\n        }\n        else if (*s == *t || dropt_tolower(*s) == dropt_tolower(*t))\n        {\n            s++;\n            t++;\n        }\n        else\n        {\n            return (dropt_tolower(*s) < dropt_tolower(*t))\n                   ? -1\n                   : +1;\n        }\n    }\n\n    return 0;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_handle_verbose_bool\n  *\n  *     Like dropt_handle_bool but accepts \"true\" and \"false\" string\n  *     values.\n  *\n  * PARAMETERS:\n  *     IN/OUT context    : The options context.\n  *     IN optionArgument : A string representing a boolean value.\n  *                         If NULL, the boolean value is assumed to be\n  *                           true.\n  *     OUT handlerData   : A dropt_bool*.\n  *                         On success, set to the interpreted boolean\n  *                           value.\n  *                         On error, left untouched.\n  *\n  * RETURNS:\n  *     See dropt_handle_bool.\n  */\n", "func_signal": "dropt_error\ndropt_handle_verbose_bool(dropt_context* context, const dropt_char* optionArgument,\n                          void* handlerData)", "code": "{\n    dropt_error err = dropt_handle_bool(context, optionArgument, handlerData);\n    if (err == dropt_error_mismatch)\n    {\n        bool val = false;\n        dropt_bool* out = handlerData;\n\n        /* dropt_handle_bool already checks for this. */\n        assert(out != NULL);\n\n        if (dropt_stricmp(optionArgument, DROPT_TEXT_LITERAL(\"false\")) == 0)\n        {\n            val = false;\n            err = dropt_error_none;\n        }\n        else if (dropt_stricmp(optionArgument, DROPT_TEXT_LITERAL(\"true\")) == 0)\n        {\n            val = true;\n            err = dropt_error_none;\n        }\n\n        if (err == dropt_error_none) { *out = val; }\n    }\n    return err;\n}", "path": "packr/DrOpt/dropt/src/dropt_handlers.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_handle_double\n  *\n  *     Parses a double from the given string.\n  *\n  * PARAMETERS:\n  *     IN/OUT context    : The options context.\n  *     IN optionArgument : A string representing a base-10 floating-point\n  *                           number.\n  *                         If NULL, returns dropt_error_insufficient_arguments.\n  *     OUT handlerData   : A double*.\n  *                         On success, set to the interpreted double.\n  *                         On error, left untouched.\n  *\n  * RETURNS:\n  *     dropt_error_none\n  *     dropt_error_unknown\n  *     dropt_error_bad_configuration\n  *     dropt_error_insufficient_arguments\n  *     dropt_error_mismatch\n  *     dropt_error_overflow\n  *     dropt_error_underflow\n  */\n", "func_signal": "dropt_error\ndropt_handle_double(dropt_context* context, const dropt_char* optionArgument,\n                    void* handlerData)", "code": "{\n    dropt_error err = dropt_error_none;\n    double val = 0.0;\n    double* out = handlerData;\n\n    if (out == NULL)\n    {\n        DROPT_MISUSE(\"No handler data specified.\");\n        err = dropt_error_bad_configuration;\n    }\n    else if (   optionArgument == NULL\n             || optionArgument[0] == DROPT_TEXT_LITERAL('\\0'))\n    {\n        err = dropt_error_insufficient_arguments;\n    }\n    else\n    {\n        dropt_char* end;\n        errno = 0;\n        val = dropt_strtod(optionArgument, &end);\n\n        /* Check that we matched at least one digit.\n         * (strtod will return 0 if fed a string with no digits.)\n         */\n        if (*end == DROPT_TEXT_LITERAL('\\0') && end > optionArgument)\n        {\n            if (errno == ERANGE)\n            {\n                /* Note that setting errno to ERANGE for underflow errors\n                 * is implementation-defined behavior, but glibc, BSD's\n                 * libc, and Microsoft's CRT all have implementations of\n                 * strtod documented to return 0 and to set errno to ERANGE\n                 * for such cases.\n                 */\n                err = (ABS(val) <= DBL_MIN)\n                      ? dropt_error_underflow\n                      : dropt_error_overflow;\n            }\n            else if (errno != 0)\n            {\n                err = dropt_error_unknown;\n            }\n        }\n        else\n        {\n            err = dropt_error_mismatch;\n        }\n    }\n\n    if (err == dropt_error_none) { *out = val; }\n    return err;\n}", "path": "packr/DrOpt/dropt/src/dropt_handlers.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_safe_realloc\n  *\n  *     Wrapper around realloc to check for integer overflow.\n  *\n  * PARAMETERS:\n  *     IN/OUT p       : A pointer to the memory block to resize.\n  *                      If NULL, a new memory block of the specified size\n  *                        will be allocated.\n  *     IN numElements : The number of elements to allocate.\n  *                      If 0, frees p.\n  *     IN elementSize : The size of each element, in bytes.\n  *\n  * RETURNS:\n  *     A pointer to the allocated memory.\n  *     Returns NULL if numElements is 0.\n  *     Returns NULL on error.\n  */\n", "func_signal": "void*\ndropt_safe_realloc(void* p, size_t numElements, size_t elementSize)", "code": "{\n    size_t numBytes;\n\n    /* elementSize shouldn't legally be 0, but we check for it in case a\n     * caller got the argument order wrong.\n     */\n    if (numElements == 0 || elementSize == 0)\n    {\n        /* The behavior of realloc(p, 0) is implementation-defined.  Let's\n         * enforce a particular behavior.\n         */\n        free(p);\n\n        assert(elementSize != 0);\n        return NULL;\n    }\n\n    numBytes = numElements * elementSize;\n    if (numBytes / elementSize != numElements)\n    {\n        /* Overflow. */\n        return NULL;\n    }\n\n    return realloc(p, numBytes);\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_handle_string\n  *\n  *     Obtains a string.\n  *\n  * PARAMETERS:\n  *     IN/OUT context    : The options context.\n  *     IN optionArgument : A string.\n  *                         If NULL, returns dropt_error_insufficient_arguments.\n  *     OUT handlerData   : A dropt_char**.\n  *                         On success, set to the input string.  The\n  *                           string is NOT copied from the original argv\n  *                           array, so do not free it.\n  *                         On error, left untouched.\n  *\n  * RETURNS:\n  *     dropt_error_none\n  *     dropt_error_bad_configuration\n  *     dropt_error_insufficient_arguments\n  */\n", "func_signal": "dropt_error\ndropt_handle_string(dropt_context* context, const dropt_char* optionArgument,\n                    void* handlerData)", "code": "{\n    dropt_error err = dropt_error_none;\n    const dropt_char** out = handlerData;\n\n    if (out == NULL)\n    {\n        DROPT_MISUSE(\"No handler data specified.\");\n        err = dropt_error_bad_configuration;\n    }\n    else if (optionArgument == NULL)\n    {\n        err = dropt_error_insufficient_arguments;\n    }\n\n    if (err == dropt_error_none) { *out = optionArgument; }\n    return err;\n}", "path": "packr/DrOpt/dropt/src/dropt_handlers.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_ssfinalize\n  *\n  *     Finalizes a dropt_stringstream; returns the contained string and\n  *     destroys the dropt_stringstream.\n  *\n  * PARAMETERS:\n  *     IN/OUT ss : The dropt_stringstream.\n  *\n  * RETURNS:\n  *     The dropt_stringstream's string, which is always NUL-terminated.\n  *       Note that the caller assumes ownership of the returned string and\n  *       is responsible for calling free() on it when no longer needed.\n  */\n", "func_signal": "dropt_char*\ndropt_ssfinalize(dropt_stringstream* ss)", "code": "{\n    dropt_char* s;\n    assert(ss != NULL);\n\n    /* Shrink to fit. */\n    dropt_ssresize(ss, 0);\n\n    s = ss->string;\n    ss->string = NULL;\n\n    dropt_ssclose(ss);\n\n    return s;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/** dropt_ssgetstring\n  *\n  * PARAMETERS:\n  *     IN ss : The dropt_stringstream.\n  *\n  * RETURNS:\n  *     The dropt_stringstream's string, which is always NUL-terminated.\n  *       The returned string will no longer be valid if further operations\n  *       are performed on the dropt_stringstream or if the\n  *       dropt_stringstream is closed.\n  */\n", "func_signal": "const dropt_char*\ndropt_ssgetstring(const dropt_stringstream* ss)", "code": "{\n    assert(ss != NULL);\n    return ss->string;\n}", "path": "packr/DrOpt/dropt/src/dropt_string.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "libgdx/packr", "stars": 2523, "license": "apache-2.0", "language": "c", "size": 3368}
{"docstring": "/*\n * These are checking routines calls to which could be inserted by a\n * preprocessor to validate C pointer arithmetic.\n */\n", "func_signal": "STATIC void GC_CALLBACK GC_default_same_obj_print_proc(void * p, void * q)", "code": "{\n    ABORT_ARG2(\"GC_same_obj test failed\",\n               \": %p and %p are not in the same object\", p, q);\n}", "path": "bdwgc/ptr_chck.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Return the argument with all control characters replaced by blanks.  */\n", "func_signal": "char * plain_chars(char * text, size_t len)", "code": "{\n    char * result = (char *)GC_MALLOC_ATOMIC(len + 1);\n    size_t i;\n\n    if (NULL == result) return NULL;\n    for (i = 0; i < len; i++) {\n       if (iscntrl(((unsigned char *)text)[i])) {\n           result[i] = ' ';\n       } else {\n           result[i] = text[i];\n       }\n    }\n    result[len] = '\\0';\n    return(result);\n}", "path": "bdwgc/cord/tests/de_win.c", "commit_date": "2019-07-16 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Reduce the number of map entries to save space for huge files. */\n/* This also affects maps in histories.                           */\n", "func_signal": "void prune_map(void)", "code": "{\n    line_map map = current_map;\n    int start_line = map -> line;\n\n    current_map_size = 0;\n    do {\n        current_map_size++;\n        if (map -> line < start_line - LINES && map -> previous != 0) {\n            line_map pred = map -> previous -> previous;\n\n            GC_PTR_STORE_AND_DIRTY(&map->previous, pred);\n        }\n        map = map -> previous;\n    } while (map != 0);\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Make sure line, col, and dis_pos are somewhere inside file.  */\n/* Recompute file_pos.  Assumes dis_pos is accurate or past eof */\n", "func_signal": "void fix_pos(void)", "code": "{\n    int my_col = col;\n\n    if ((size_t)line > current_len)\n        line = (int)current_len;\n    file_pos = line_pos(line, &my_col);\n    if (file_pos == CORD_NOT_FOUND) {\n        for (line = current_map -> line, file_pos = current_map -> pos;\n             file_pos < current_len;\n             line++, file_pos = CORD_chr(current, file_pos, '\\n') + 1);\n        line--;\n        file_pos = line_pos(line, &col);\n    } else {\n        col = my_col;\n    }\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* We hold the allocator lock.  */\n", "func_signal": "GC_INNER void GC_destroy_thread_local(GC_tlfs p)", "code": "{\n    int k;\n\n    /* We currently only do this from the thread itself.        */\n    GC_STATIC_ASSERT(THREAD_FREELISTS_KINDS <= MAXOBJKINDS);\n    for (k = 0; k < THREAD_FREELISTS_KINDS; ++k) {\n        if (k == (int)GC_n_kinds)\n            break; /* kind is not created */\n        return_freelists(p -> _freelists[k], GC_obj_kinds[k].ok_freelist);\n    }\n#   ifdef GC_GCJ_SUPPORT\n        return_freelists(p -> gcj_freelists, (void **)GC_gcjobjfreelist);\n#   endif\n}", "path": "bdwgc/thread_local_alloc.c", "commit_date": "2020-06-21 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Return a single nonempty freelist fl to the global one pointed to    */\n/* by gfl.                                                              */\n", "func_signal": "static void return_single_freelist(void *fl, void **gfl)", "code": "{\n    if (*gfl == 0) {\n      *gfl = fl;\n    } else {\n      void *q, **qptr;\n\n      GC_ASSERT(GC_size(fl) == GC_size(*gfl));\n      /* Concatenate: */\n        qptr = &(obj_link(fl));\n        while ((word)(q = *qptr) >= HBLKSIZE)\n          qptr = &(obj_link(q));\n        GC_ASSERT(0 == q);\n        *qptr = *gfl;\n        *gfl = fl;\n    }\n}", "path": "bdwgc/thread_local_alloc.c", "commit_date": "2020-06-21 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Check that if p is a pointer to a heap page, then it points to       */\n/* a valid displacement within a heap object.                           */\n/* Uninteresting with GC_all_interior_pointers.                         */\n/* Always returns its argument.                                         */\n/* Note that we don't lock, since nothing relevant about the header     */\n/* should change while we have a valid object pointer to the block.     */\n", "func_signal": "GC_API void * GC_CALL GC_is_valid_displacement(void *p)", "code": "{\n    hdr *hhdr;\n    word pdispl;\n    word offset;\n    struct hblk *h;\n    word sz;\n\n    if (!EXPECT(GC_is_initialized, TRUE)) GC_init();\n    hhdr = HDR((word)p);\n    if (hhdr == 0) return(p);\n    h = HBLKPTR(p);\n    if (GC_all_interior_pointers) {\n        while (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n           h = FORWARDED_ADDR(h, hhdr);\n           hhdr = HDR(h);\n        }\n    } else if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n        goto fail;\n    }\n    sz = hhdr -> hb_sz;\n    pdispl = HBLKDISPL(p);\n    offset = pdispl % sz;\n    if ((sz > MAXOBJBYTES && (word)p >= (word)h + sz)\n        || !GC_valid_offsets[offset]\n        || ((word)p + (sz - offset) > (word)(h + 1)\n            && !IS_FORWARDING_ADDR_OR_NIL(HDR(h + 1)))) {\n        goto fail;\n    }\n    return(p);\nfail:\n    (*GC_is_valid_displacement_print_proc)((ptr_t)p);\n    return(p);\n}", "path": "bdwgc/ptr_chck.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Invalidate line map for lines > i */\n", "func_signal": "void invalidate_map(int i)", "code": "{\n    while(current_map -> line > i) {\n        current_map = current_map -> previous;\n        current_map_size--;\n    }\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* the next freelist entry (which it thinks is a vtable pointer), get   */\n/* suspended for a while, and then see an allocated object instead      */\n/* of the vtable.  This may be avoidable with either a handshake with   */\n/* the collector or, probably more easily, by moving the free list      */\n/* links to the second word of each object.  The latter isn't a         */\n/* universal win, since on architecture like Itanium, nonzero offsets   */\n/* are not necessarily free.  And there may be cache fill order issues. */\n/* For now, we punt with incremental GC.  This probably means that      */\n/* incremental GC should be enabled before we fork a second thread.     */\n/* Unlike the other thread local allocation calls, we assume that the   */\n/* collector has been explicitly initialized.                           */\n", "func_signal": "GC_API GC_ATTR_MALLOC void * GC_CALL GC_gcj_malloc(size_t bytes,\n                                    void * ptr_to_struct_containing_descr)", "code": "{\n  if (EXPECT(GC_incremental, FALSE)) {\n    return GC_core_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n  } else {\n    size_t granules = ROUNDED_UP_GRANULES(bytes);\n    void *result;\n    void **tiny_fl;\n\n    GC_ASSERT(GC_gcjobjfreelist != NULL);\n    tiny_fl = ((GC_tlfs)GC_getspecific(GC_thread_key))->gcj_freelists;\n    GC_FAST_MALLOC_GRANS(result, granules, tiny_fl, DIRECT_GRANULES,\n                         GC_gcj_kind,\n                         GC_core_gcj_malloc(bytes,\n                                            ptr_to_struct_containing_descr),\n                         {AO_compiler_barrier();\n                          *(void **)result = ptr_to_struct_containing_descr;});\n        /* This forces the initialization of the \"method ptr\".          */\n        /* This is necessary to ensure some very subtle properties      */\n        /* required if a GC is run in the middle of such an allocation. */\n        /* Here we implicitly also assume atomicity for the free list.  */\n        /* and method pointer assignments.                              */\n        /* We must update the freelist before we store the pointer.     */\n        /* Otherwise a GC at this point would see a corrupted           */\n        /* free list.                                                   */\n        /* A real memory barrier is not needed, since the               */\n        /* action of stopping this thread will cause prior writes       */\n        /* to complete.                                                 */\n        /* We assert that any concurrent marker will stop us.           */\n        /* Thus it is impossible for a mark procedure to see the        */\n        /* allocation of the next object, but to see this object        */\n        /* still containing a free list pointer.  Otherwise the         */\n        /* marker, by misinterpreting the freelist link as a vtable     */\n        /* pointer, might find a random \"mark descriptor\" in the next   */\n        /* object.                                                      */\n    return result;\n  }\n}", "path": "bdwgc/thread_local_alloc.c", "commit_date": "2020-06-21 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Could p be a stack address? */\n", "func_signal": "STATIC GC_bool GC_on_stack(void *p)", "code": "{\n#    ifdef STACK_GROWS_DOWN\n       if ((word)p >= (word)GC_approx_sp()\n           && (word)p < (word)GC_stackbottom) {\n         return(TRUE);\n       }\n#    else\n       if ((word)p <= (word)GC_approx_sp()\n           && (word)p > (word)GC_stackbottom) {\n         return(TRUE);\n       }\n#    endif\n     return(FALSE);\n   }\n#endif\n\n/* Check that p is visible                                              */\n/* to the collector as a possibly pointer containing location.          */\n/* If it isn't, invoke *GC_is_visible_print_proc.                       */\n/* Returns the argument in all cases.  May erroneously succeed          */\n/* in hard cases.  (This is intended for debugging use with             */\n/* untyped allocations.  The idea is that it should be possible, though */\n/* slow, to add such a call to all indirect pointer stores.)            */\n/* Currently useless for the multi-threaded worlds.                     */\nGC_API void * GC_CALL GC_is_visible(void *p)\n{\n    hdr *hhdr;\n\n    if ((word)p & (ALIGNMENT - 1)) goto fail;\n    if (!EXPECT(GC_is_initialized, TRUE)) GC_init();\n#   ifdef THREADS\n        hhdr = HDR((word)p);\n        if (hhdr != 0 && GC_base(p) == 0) {\n            goto fail;\n        } else {\n            /* May be inside thread stack.  We can't do much. */\n            return(p);\n        }\n#   else\n        /* Check stack first: */\n          if (GC_on_stack(p)) return(p);\n        hhdr = HDR((word)p);\n        if (hhdr == 0) {\n            if (GC_is_static_root(p)) return(p);\n            /* Else do it again correctly:      */\n#           if defined(DYNAMIC_LOADING) || defined(MSWIN32) \\\n                || defined(MSWINCE) || defined(CYGWIN32) || defined(PCR)\n              GC_register_dynamic_libraries();\n              if (GC_is_static_root(p))\n                return(p);\n#           endif\n            goto fail;\n        } else {\n            /* p points to the heap. */\n            word descr;\n            ptr_t base = (ptr_t)GC_base(p);\n                        /* TODO: should GC_base be manually inlined? */\n\n            if (NULL == base) goto fail;\n            if (HBLKPTR(base) != HBLKPTR(p))\n                hhdr = HDR(base);\n            descr = hhdr -> hb_descr;\n    retry:\n            switch(descr & GC_DS_TAGS) {\n                case GC_DS_LENGTH:\n                    if ((word)p - (word)base > descr) goto fail;\n                    break;\n                case GC_DS_BITMAP:\n                    if ((word)p - (word)base >= WORDS_TO_BYTES(BITMAP_BITS)\n                        || ((word)p & (sizeof(word) - 1))) goto fail;\n                    if (!(((word)1 << (WORDSZ - ((ptr_t)p - (ptr_t)base) - 1))\n                          & descr)) goto fail;\n                    break;\n                case GC_DS_PROC:\n                    /* We could try to decipher this partially.         */\n                    /* For now we just punt.                            */\n                    break;\n                case GC_DS_PER_OBJECT:\n                    if ((signed_word)descr >= 0) {\n                      descr = *(word *)((ptr_t)base + (descr & ~GC_DS_TAGS));\n                    } else {\n                      ptr_t type_descr = *(ptr_t *)base;\n                      descr = *(word *)(type_descr\n                                        - (descr - (word)(GC_DS_PER_OBJECT\n                                           - GC_INDIR_PER_OBJ_BIAS)));\n                    }\n                    goto retry;\n            }\n            return(p);\n        }\n#   endif\nfail:\n    (*GC_is_visible_print_proc)((ptr_t)p);\n    return(p);\n}", "path": "bdwgc/ptr_chck.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Return the argument with all non-control-characters replaced by      */\n/* blank, and all control characters c replaced by c + 64.              */\n", "func_signal": "char * control_chars(char * text, size_t len)", "code": "{\n    char * result = (char *)GC_MALLOC_ATOMIC(len + 1);\n    size_t i;\n\n    if (NULL == result) return NULL;\n    for (i = 0; i < len; i++) {\n       if (iscntrl(((unsigned char *)text)[i])) {\n           result[i] = (char)(text[i] + 0x40);\n       } else {\n           result[i] = ' ';\n       }\n    }\n    result[len] = '\\0';\n    return(result);\n}", "path": "bdwgc/cord/tests/de_win.c", "commit_date": "2019-07-16 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* OS independent initialization */\n", "func_signal": "void generic_init(void)", "code": "{\n    FILE * f;\n    CORD initial;\n\n    if ((f = fopen(arg_file_name, \"rb\")) == NULL) {\n        initial = \"\\n\";\n    } else {\n        size_t len;\n\n        initial = CORD_from_file(f);\n        len = CORD_len(initial);\n        if (0 == len || CORD_fetch(initial, len - 1) != '\\n') {\n            initial = CORD_cat(initial, \"\\n\");\n        }\n    }\n    add_map(0,0);\n    add_hist(initial);\n    now -> map = current_map;\n    now -> previous = now;  /* Can't back up further: beginning of the world */\n    GC_END_STUBBORN_CHANGE(now);\n    need_redisplay = ALL;\n    fix_cursor();\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Replace a line in the curses stdscr. All control characters are      */\n/* displayed as upper case characters in standout mode.  This isn't     */\n/* terribly appropriate for tabs.                                                                       */\n", "func_signal": "void replace_line(int i, CORD s)", "code": "{\n    CORD_pos p;\n#   if !defined(MACINTOSH)\n        size_t len = CORD_len(s);\n#   endif\n\n    if (screen == 0 || LINES > screen_size) {\n        screen_size = LINES;\n        screen = (CORD *)GC_MALLOC(screen_size * sizeof(CORD));\n        if (NULL == screen) OUT_OF_MEMORY;\n    }\n#   if !defined(MACINTOSH)\n        /* A gross workaround for an apparent curses bug: */\n        if (i == LINES-1 && len == (unsigned)COLS) {\n            s = CORD_substr(s, 0, len - 1);\n        }\n#   endif\n    if (CORD_cmp(screen[i], s) != 0) {\n        move(i, 0); clrtoeol(); move(i,0);\n\n        CORD_FOR (p, s) {\n            int c = CORD_pos_fetch(p) & 0x7f;\n\n            if (iscntrl(c)) {\n                standout(); addch(c + 0x40); standend();\n            } else {\n                addch(c);\n            }\n        }\n        GC_PTR_STORE_AND_DIRTY(screen + i, s);\n    }\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Allocate a new heapblock for small objects of size gran granules.    */\n/* Add all of the heapblock's objects to the free list for objects      */\n/* of that size.  Set all mark bits if objects are uncollectible.       */\n/* Will fail to do anything if we are out of memory.                    */\n", "func_signal": "GC_INNER void GC_new_hblk(size_t gran, int kind)", "code": "{\n  struct hblk *h;       /* the new heap block */\n  GC_bool clear = GC_obj_kinds[kind].ok_init;\n\n  GC_STATIC_ASSERT((sizeof (struct hblk)) == HBLKSIZE);\n\n  if (GC_debugging_started) clear = TRUE;\n\n  /* Allocate a new heap block */\n    h = GC_allochblk(GRANULES_TO_BYTES(gran), kind, 0);\n    if (h == 0) return;\n\n  /* Mark all objects if appropriate. */\n      if (IS_UNCOLLECTABLE(kind)) GC_set_hdr_marks(HDR(h));\n\n  /* Build the free list */\n      GC_obj_kinds[kind].ok_freelist[gran] =\n        GC_build_fl(h, GRANULES_TO_WORDS(gran), clear,\n                    (ptr_t)GC_obj_kinds[kind].ok_freelist[gran]);\n}", "path": "bdwgc/new_hblk.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Update dis_line, dis_col, and dis_pos to make cursor visible.        */\n/* Assumes line, col, dis_line, dis_pos are in bounds.                  */\n", "func_signal": "void normalize_display(void)", "code": "{\n    int old_line = dis_line;\n    int old_col = dis_col;\n\n    dis_granularity = 1;\n    if (LINES > 15 && COLS > 15) dis_granularity = 2;\n    while (dis_line > line) dis_line -= dis_granularity;\n    while (dis_col > col) dis_col -= dis_granularity;\n    while (line >= dis_line + LINES) dis_line += dis_granularity;\n    while (col >= dis_col + COLS) dis_col += dis_granularity;\n    if (old_line != dis_line || old_col != dis_col) {\n        need_redisplay = ALL;\n    }\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/*\n * beep() is part of some curses packages and not others.\n * We try to match the type of the builtin one, if any.\n */\n", "func_signal": "int beep(void)", "code": "{\n    putc('\\007', stderr);\n    return(0);\n  }\n#endif /* !WIN32 && !MACINTOSH */\n\n#   define NO_PREFIX -1\n#   define BARE_PREFIX -2\nint repeat_count = NO_PREFIX;   /* Current command prefix. */\n\nint locate_mode = 0;                    /* Currently between 2 ^Ls      */\nCORD locate_string = CORD_EMPTY;        /* Current search string.       */\n\nchar * arg_file_name;\n\n#ifdef WIN32\n/* Change the current position to whatever is currently displayed at    */\n/* the given SCREEN coordinates.                                        */\nvoid set_position(int c, int l)\n{\n    line = l + dis_line;\n    col = c + dis_col;\n    fix_pos();\n    move_cursor(col - dis_col, line - dis_line);\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Adjust display so that cursor is visible; move cursor into position  */\n/* Update screen if necessary.                                          */\n", "func_signal": "void fix_cursor(void)", "code": "{\n    normalize_display();\n    if (need_redisplay != NONE) redisplay();\n    move_cursor(col - dis_col, line - dis_line);\n    refresh();\n#   ifndef WIN32\n      fflush(stdout);\n#   endif\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Return up to COLS characters of the line of s starting at pos,       */\n/* returning only characters after the given column.                    */\n", "func_signal": "CORD retrieve_line(CORD s, size_t pos, unsigned column)", "code": "{\n    CORD candidate = CORD_substr(s, pos, column + COLS);\n                        /* avoids scanning very long lines      */\n    size_t eol = CORD_chr(candidate, 0, '\\n');\n    int len;\n\n    if (eol == CORD_NOT_FOUND) eol = CORD_len(candidate);\n    len = (int)eol - (int)column;\n    if (len < 0) len = 0;\n    return(CORD_substr(s, pos + column, len));\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* The thread support layer must arrange to mark thread-local   */\n/* free lists explicitly, since the link field is often         */\n/* invisible to the marker.  It knows how to find all threads;  */\n/* we take care of an individual thread freelist structure.     */\n", "func_signal": "GC_INNER void GC_mark_thread_local_fls_for(GC_tlfs p)", "code": "{\n    ptr_t q;\n    int i, j;\n\n    for (j = 0; j < TINY_FREELISTS; ++j) {\n      for (i = 0; i < THREAD_FREELISTS_KINDS; ++i) {\n        /* Load the pointer atomically as it might be updated   */\n        /* concurrently by GC_FAST_MALLOC_GRANS.                */\n        q = (ptr_t)AO_load((volatile AO_t *)&p->_freelists[i][j]);\n        if ((word)q > HBLKSIZE)\n          GC_set_fl_marks(q);\n      }\n#     ifdef GC_GCJ_SUPPORT\n        if (EXPECT(j > 0, TRUE)) {\n          q = (ptr_t)AO_load((volatile AO_t *)&p->gcj_freelists[j]);\n          if ((word)q > HBLKSIZE)\n            GC_set_fl_marks(q);\n        }\n#     endif\n    }\n}", "path": "bdwgc/thread_local_alloc.c", "commit_date": "2020-06-21 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "/* Return position of column *c of ith line in   */\n/* current file. Adjust *c to be within the line.*/\n/* A 0 pointer is taken as 0 column.             */\n/* Returns CORD_NOT_FOUND if i is too big.       */\n/* Assumes i > dis_line.                         */\n", "func_signal": "size_t line_pos(int i, int *c)", "code": "{\n    int j;\n    size_t cur;\n    line_map map = current_map;\n\n    while (map -> line > i) map = map -> previous;\n    if (map -> line < i - 2) /* rebuild */ invalidate_map(i);\n    for (j = map -> line, cur = map -> pos; j < i;) {\n        cur = CORD_chr(current, cur, '\\n');\n        if (cur == current_len-1) return(CORD_NOT_FOUND);\n        cur++;\n        if (++j > current_map -> line) add_map(j, cur);\n    }\n    if (c != 0) {\n        size_t next = CORD_chr(current, cur, '\\n');\n\n        if (next == CORD_NOT_FOUND) next = current_len - 1;\n        if (next < cur + *c) {\n            *c = (int)(next - cur);\n        }\n        cur += *c;\n    }\n    return(cur);\n}", "path": "bdwgc/cord/tests/de.c", "commit_date": "2019-10-04 00:00:00", "repo_name": "ivmai/bdwgc", "stars": 2719, "license": "other", "language": "c", "size": 27238}
{"docstring": "// Read data byte and send ACK if ack=1\n", "func_signal": "static unsigned char i2c_receive_byte(bool ack)", "code": "{\n\tint i;\n\tunsigned char data = 0;\n\n\tfor (i = 0; i < 8; ++i) {\n\t\tdata <<= 1;\n\t\tdata |= i2c_receive_bit();\n\t}\n\ti2c_transmit_bit(!ack);\n\n\treturn data;\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/*\n * Write slave memory over I2C starting at given address\n *\n * First writes the memory starting address, then writes the data:\n *   START WR(slaveaddr) WR(addr) WR(data) WR(data) ... STOP\n */\n", "func_signal": "bool i2c_write(unsigned char slave_addr, unsigned char addr, const unsigned char *data, unsigned int len)", "code": "{\n\tint i;\n\n\ti2c_start();\n\n\tif(!i2c_transmit_byte(I2C_ADDR_WR(slave_addr))) {\n\t\ti2c_stop();\n\t\treturn false;\n\t}\n\tif(!i2c_transmit_byte(addr)) {\n\t\ti2c_stop();\n\t\treturn false;\n\t}\n\tfor (i = 0; i < len; ++i) {\n\t\tif(!i2c_transmit_byte(data[i])) {\n\t\t\ti2c_stop();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\ti2c_stop();\n\n\treturn true;\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/* round up to closest power-of-two */\n", "func_signal": "static inline uint32_t pow2_round_up(uint32_t r)", "code": "{\n\tr--;\n\tr |= r >>  1;\n\tr |= r >>  2;\n\tr |= r >>  4;\n\tr |= r >>  8;\n\tr |= r >> 16;\n\tr++;\n\treturn r;\n}", "path": "litex/litex/soc/software/liblitesdcard/sdcard.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "// All platforms\n", "func_signal": "LIBDYLIB_DEFINE(dylib_ref, open)(const char *path)", "code": "{\n    check_null_path(path, NULL);\n    dylib_ref lib = dylib_ref_alloc(platform_raw_open(path), path);\n    if (lib == NULL)\n        platform_set_last_error();\n    return lib;\n}", "path": "litex/litex/build/sim/core/libdylib.c", "commit_date": "2018-10-04 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "// STOP condition: 0-to-1 transition of SDA when SCL is 1\n", "func_signal": "static void i2c_stop(void)", "code": "{\n\ti2c_oe_scl_sda(1, 0, 0);\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(1, 1, 0);\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(1, 1, 1);\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(0, 1, 1);\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "// Call when in the middle of SCL low, advances one clk period\n", "func_signal": "static int i2c_receive_bit(void)", "code": "{\n\tint value;\n\ti2c_oe_scl_sda(0, 0, 0);\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(0, 1, 0);\n\tI2C_DELAY(1);\n\t// read in the middle of SCL high\n\tvalue = i2c_r_read() & 1;\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(0, 0, 0);\n\tI2C_DELAY(1);\n\treturn value;\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/*\n * Read slave memory over I2C starting at given address\n *\n * First writes the memory starting address, then reads the data:\n *   START WR(slaveaddr) WR(addr) STOP START WR(slaveaddr) RD(data) RD(data) ... STOP\n * Some chips require that after transmiting the address, there will be no STOP in between:\n *   START WR(slaveaddr) WR(addr) START WR(slaveaddr) RD(data) RD(data) ... STOP\n */\n", "func_signal": "bool i2c_read(unsigned char slave_addr, unsigned char addr, unsigned char *data, unsigned int len, bool send_stop)", "code": "{\n\tint i;\n\n\ti2c_start();\n\n\tif(!i2c_transmit_byte(I2C_ADDR_WR(slave_addr))) {\n\t\ti2c_stop();\n\t\treturn false;\n\t}\n\tif(!i2c_transmit_byte(addr)) {\n\t\ti2c_stop();\n\t\treturn false;\n\t}\n\n\tif (send_stop) {\n\t\ti2c_stop();\n\t}\n\ti2c_start();\n\n\tif(!i2c_transmit_byte(I2C_ADDR_RD(slave_addr))) {\n\t\ti2c_stop();\n\t\treturn false;\n\t}\n\tfor (i = 0; i < len; ++i) {\n\t\tdata[i] = i2c_receive_byte(i != len - 1);\n\t}\n\n\ti2c_stop();\n\n\treturn true;\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/**\n * Command \"sdram_force_wrphase\"\n *\n * Force write phase\n *\n */\n", "func_signal": "static void sdram_force_wrphase_handler(int nb_params, char **params)", "code": "{\n\tchar *c;\n\tint phase;\n\tif (nb_params < 1) {\n\t\tprintf(\"sdram_force_wrphase <phase>\");\n\t\treturn;\n\t}\n\tphase = strtoul(params[0], &c, 0);\n\tif (*c != 0) {\n\t\tprintf(\"Incorrect phase\");\n\t\treturn;\n\t}\n\tprintf(\"Forcing write phase to %d\\n\", phase);\n\tddrphy_wrphase_write(phase);\n}", "path": "litex/litex/soc/software/bios/cmds/cmd_litedram.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* SDCard command helpers                                                */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "int sdcard_wait_cmd_done(void)", "code": "{\n\tunsigned int event;\n#ifdef SDCARD_DEBUG\n\tuint32_t r[SD_CMD_RESPONSE_SIZE/4];\n#endif\n\tfor (;;) {\n\t\tevent = sdcore_cmd_event_read();\n#ifdef SDCARD_DEBUG\n\t\tprintf(\"cmdevt: %08x\\n\", event);\n#endif\n\t\tbusy_wait_us(10);\n\t\tif (event & 0x1)\n\t\t\tbreak;\n\t}\n#ifdef SDCARD_DEBUG\n\tcsr_rd_buf_uint32(CSR_SDCORE_CMD_RESPONSE_ADDR,\n\t\t\t  r, SD_CMD_RESPONSE_SIZE/4);\n\tprintf(\"%08x %08x %08x %08x\\n\", r[0], r[1], r[2], r[3]);\n#endif\n\tif (event & 0x4)\n\t\treturn SD_TIMEOUT;\n\tif (event & 0x8)\n\t\treturn SD_CRCERROR;\n\treturn SD_OK;\n}", "path": "litex/litex/soc/software/liblitesdcard/sdcard.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/*** Helper functions *****************************************************************************/\n", "func_signal": "static void spdeeprom_from_file(struct session_s *s, FILE *file)", "code": "{\n  size_t bufsize = 0;\n  ssize_t n_read;\n  char *line = NULL;\n  char *c;\n  unsigned int byte;\n  int i;\n\n  for (i = 0; i < sizeof(s->mem) / sizeof(s->mem[0]); ++i) {\n    if ((n_read = getline(&line, &bufsize, file)) < 0) {\n      break;\n    }\n    byte = strtoul(line, &c, 16);\n    if (c == line) {\n      DBG(\"[spdeeprom] Incorrect value at line %d\\n\", i);\n    } else {\n      s->mem[i] = byte;\n    }\n  }\n\n  if (line != NULL)\n    free(line);\n}", "path": "litex/litex/build/sim/core/modules/spdeeprom/spdeeprom.c", "commit_date": "2020-08-04 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "// Send data byte and return 1 if slave sends ACK\n", "func_signal": "static bool i2c_transmit_byte(unsigned char data)", "code": "{\n\tint i;\n\tint ack;\n\n\t// SCL should have already been low for 1/4 cycle\n\ti2c_oe_scl_sda(0, 0, 0);\n\tfor (i = 0; i < 8; ++i) {\n\t\t// MSB first\n\t\ti2c_transmit_bit((data & (1 << 7)) != 0);\n\t\tdata <<= 1;\n\t}\n\tack = i2c_receive_bit();\n\n\t// 0 from slave means ack\n\treturn ack == 0;\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "// START condition: 1-to-0 transition of SDA when SCL is 1\n", "func_signal": "static void i2c_start(void)", "code": "{\n\ti2c_oe_scl_sda(1, 1, 1);\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(1, 1, 0);\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(1, 0, 0);\n\tI2C_DELAY(1);\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/*\n * Poll I2C slave at given address, return true if it sends an ACK back\n */\n", "func_signal": "bool i2c_poll(unsigned char slave_addr)", "code": "{\n    bool result;\n\n    i2c_start();\n    result = i2c_transmit_byte(I2C_ADDR_RD(slave_addr));\n    i2c_stop();\n\n    return result;\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "// Call when in the middle of SCL low, advances one clk period\n", "func_signal": "static void i2c_transmit_bit(int value)", "code": "{\n\ti2c_oe_scl_sda(1, 0, value);\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(1, 1, value);\n\tI2C_DELAY(2);\n\ti2c_oe_scl_sda(1, 0, value);\n\tI2C_DELAY(1);\n\ti2c_oe_scl_sda(0, 0, 0);  // release line\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/**\n * Command \"sdram_force_rdphase\"\n *\n * Force read phase\n *\n */\n", "func_signal": "static void sdram_force_rdphase_handler(int nb_params, char **params)", "code": "{\n\tchar *c;\n\tint phase;\n\tif (nb_params < 1) {\n\t\tprintf(\"sdram_force_rdphase <phase>\");\n\t\treturn;\n\t}\n\tphase = strtoul(params[0], &c, 0);\n\tif (*c != 0) {\n\t\tprintf(\"Incorrect phase\");\n\t\treturn;\n\t}\n\tprintf(\"Forcing read phase to %d\\n\", phase);\n\tddrphy_rdphase_write(phase);\n}", "path": "litex/litex/soc/software/bios/cmds/cmd_litedram.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/* block size in bytes */\n", "func_signal": "static int format_request(uint8_t *buf, uint16_t op, const char *filename)", "code": "{\n\tint len = strlen(filename);\n\n\t*buf++ = op >> 8; /* Opcode */\n\t*buf++ = op;\n\tmemcpy(buf, filename, len);\n\tbuf += len;\n\t*buf++ = 0x00;\n\t*buf++ = 'o';\n\t*buf++ = 'c';\n\t*buf++ = 't';\n\t*buf++ = 'e';\n\t*buf++ = 't';\n\t*buf++ = 0x00;\n\treturn 9+strlen(filename);\n}", "path": "litex/litex/soc/software/libliteeth/tftp.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "// Reset line state\n", "func_signal": "void i2c_reset(void)", "code": "{\n\tint i;\n\ti2c_oe_scl_sda(1, 1, 1);\n\tI2C_DELAY(8);\n\tfor (i = 0; i < 9; ++i) {\n\t\ti2c_oe_scl_sda(1, 0, 1);\n\t\tI2C_DELAY(2);\n\t\ti2c_oe_scl_sda(1, 1, 1);\n\t\tI2C_DELAY(2);\n\t}\n\ti2c_oe_scl_sda(0, 0, 1);\n\tI2C_DELAY(1);\n\ti2c_stop();\n\ti2c_oe_scl_sda(0, 1, 1);\n\tI2C_DELAY(8);\n}", "path": "litex/litex/soc/software/libbase/i2c.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* SDCard user functions                                                 */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "int sdcard_init(void)", "code": "{\n\tuint16_t rca, timeout;\n\n\t/* Set SD clk freq to Initialization frequency */\n\tsdcard_set_clk_freq(SDCARD_CLK_FREQ_INIT, 0);\n\tbusy_wait(1);\n\n\tfor (timeout=1000; timeout>0; timeout--) {\n\t\t/* Set SDCard in SPI Mode (generate 80 dummy clocks) */\n\t\tsdphy_init_initialize_write(1);\n\t\tbusy_wait(1);\n\n\t\t/* Set SDCard in Idle state */\n\t\tif (sdcard_go_idle() == SD_OK)\n\t\t\tbreak;\n\t\tbusy_wait(1);\n\t}\n\tif (timeout == 0)\n\t\treturn 0;\n\n\t/* Set SDCard voltages, only supported by ver2.00+ SDCards */\n\tif (sdcard_send_ext_csd() != SD_OK)\n\t\treturn 0;\n\n\t/* Set SD clk freq to Operational frequency */\n\tsdcard_set_clk_freq(SDCARD_CLK_FREQ, 0);\n\tbusy_wait(1);\n\n\t/* Set SDCard in Operational state */\n\tfor (timeout=1000; timeout>0; timeout--) {\n\t\tsdcard_app_cmd(0);\n\t\tif (sdcard_app_send_op_cond(1) != SD_OK)\n\t\t\tbreak;\n\t\tbusy_wait(1);\n\t}\n\tif (timeout == 0)\n\t\treturn 0;\n\n\t/* Send identification */\n\tif (sdcard_all_send_cid() != SD_OK)\n\t\treturn 0;\n#ifdef SDCARD_DEBUG\n\tsdcard_decode_cid();\n#endif\n\t/* Set Relative Card Address (RCA) */\n\tif (sdcard_set_relative_address() != SD_OK)\n\t\treturn 0;\n\trca = sdcard_decode_rca();\n\n\t/* Set CID */\n\tif (sdcard_send_cid(rca) != SD_OK)\n\t\treturn 0;\n#ifdef SDCARD_DEBUG\n\t/* FIXME: add cid decoding (optional) */\n#endif\n\n\t/* Set CSD */\n\tif (sdcard_send_csd(rca) != SD_OK)\n\t\treturn 0;\n#ifdef SDCARD_DEBUG\n\tsdcard_decode_csd();\n#endif\n\n\t/* Select card */\n\tif (sdcard_select_card(rca) != SD_OK)\n\t\treturn 0;\n\n\t/* Set bus width */\n\tif (sdcard_app_cmd(rca) != SD_OK)\n\t\treturn 0;\n\tif(sdcard_app_set_bus_width() != SD_OK)\n\t\treturn 0;\n\n\t/* Switch speed */\n\tif (sdcard_switch(SD_SWITCH_SWITCH, SD_GROUP_ACCESSMODE, SD_SPEED_SDR25) != SD_OK)\n\t\treturn 0;\n\n\t/* Send SCR */\n\t/* FIXME: add scr decoding (optional) */\n\tif (sdcard_app_cmd(rca) != SD_OK)\n\t\treturn 0;\n\tif (sdcard_app_send_scr() != SD_OK)\n\t\treturn 0;\n\n\t/* Set block length */\n\tif (sdcard_app_set_blocklen(512) != SD_OK)\n\t\treturn 0;\n\n\treturn 1;\n}", "path": "litex/litex/soc/software/liblitesdcard/sdcard.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* SDCard commands functions                                             */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "static inline int sdcard_send_command(uint32_t arg, uint8_t cmd, uint8_t rsp)", "code": "{\n\tsdcore_cmd_argument_write(arg);\n\tsdcore_cmd_command_write((cmd << 8) | rsp);\n\tsdcore_cmd_send_write(1);\n\treturn sdcard_wait_cmd_done();\n}", "path": "litex/litex/soc/software/liblitesdcard/sdcard.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/*\nstatic dylib_ref dylib_ref_alloc_dynamic (void *handle, char *path)\n{\n    dylib_ref ref = dylib_ref_alloc(handle, path);\n    if (ref == NULL)\n        return NULL;\n    ref->dyn_path = true;\n    return ref;\n}\n*/\n", "func_signal": "static void dylib_ref_free (dylib_ref ref)", "code": "{\n    if (ref == NULL)\n        return;\n    if (ref->freed)\n        return;\n    ref->handle = NULL;\n    if (ref->dyn_path)\n        free((char*)ref->path);\n    ref->freed = true;\n    free((void*)ref);\n}", "path": "litex/litex/build/sim/core/libdylib.c", "commit_date": "2018-10-04 00:00:00", "repo_name": "enjoy-digital/litex", "stars": 2600, "license": "other", "language": "c", "size": 16665}
{"docstring": "/**\n * OpenDNIe implementation of Decipher() card driver operation.\n *\n * Engages the deciphering operation.  Card will use the\n * security environment set in a call to set_security_env or\n * restore_security_env.\n *\n * Notice that DNIe manual doesn't say anything about crypt/decrypt\n * operations. So this code is based on ISO standards and still needs\n * to be checked\n *\n * ADD: seems that DNIe supports a minimal cipher/decipher operation\n * but restricted to 1024 data chunks . Need more info and tests\n *\n * @param card Pointer to Card Driver Structure \n * @param crgram cryptogram to be (de)ciphered\n * @param crgram_len cryptogram length\n * @param out where to store result\n * @param outlen length of result buffer\n * @return SC_SUCCESS if OK; else error code\n */\n", "func_signal": "static int dnie_decipher(struct sc_card *card,\n\t\t\t const u8 * crgram, size_t crgram_len,\n\t\t\t u8 * out, size_t outlen)", "code": "{\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[MAX_RESP_BUFFER_SIZE];\n\tsize_t len;\n\tint result = SC_SUCCESS;\n\tif ((card == NULL) || (card->ctx == NULL))\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif ((crgram == NULL) || (out == NULL) || (crgram_len > 255)) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\t/* Secure Channel should be on. Elsewhere an error will be thrown */\n\t/*\n\tresult =\n\t    cwa_create_secure_channel(card, dnie_priv.provider, CWA_SM_WARM);\n\tLOG_TEST_RET(card->ctx, result, \"decipher(); Cannot establish SM\");\n\t*/\n\n\t/* Official driver uses an undocumented proprietary APDU\n\t * (90 74 40 keyID). This code uses standard 00 2A 80 8x one)\n\t * as shown in card-atrust-acos.c and card-jcop.c\n\t */\n\tdnie_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, \n\t\t\t0x2A,\t/* INS: 0x2A  perform security operation */\n\t\t\t0x80,\t/* P1: Response is plain value */\n\t\t\t0x86,\t/* P2: 8x: Padding indicator byte followed by cryptogram */\n\t\t\t256, crgram_len + 1, rbuf, sizeof(rbuf), sbuf, crgram_len + 1\n\t    );\n\n\tsbuf[0] = 0;\t\t/* padding indicator byte, 0x00 = No further indication */\n\tmemcpy(sbuf + 1, crgram, crgram_len);\n\t/* send apdu */\n\tresult = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, result, \"APDU transmit failed\");\n\t/* check response */\n\tresult = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, result, \"decipher returned error\");\n\t/* responde ok: fill result data and return */\n\tlen = apdu.resplen > outlen ? outlen : apdu.resplen;\n\tmemcpy(out, apdu.resp, len);\n\tLOG_FUNC_RETURN(card->ctx, result);\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * OpenDNIe implementation for Card_Ctl() card driver operation.\n *\n * This command provides access to non standard functions provided by\n * this card driver, as defined in cardctl.h\n *\n * @param card Pointer to card driver structure\n * @param request Operation requested\n * @param data where to get data/store response\n * @return SC_SUCCESS if ok; else error code\n * @see cardctl.h\n *\n * TODO: wait for GET_CARD_INFO generic cardctl to be implemented\n * in opensc and rewrite code according it\n */\n", "func_signal": "static int dnie_card_ctl(struct sc_card *card,\n\t\t\t unsigned long request, void *data)", "code": "{\n\tint result = SC_SUCCESS;\n\tif ((card == NULL) || (card->ctx == NULL))\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (data == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tswitch (request) {\n\t\t/* obtain lifecycle status by reading card->type */\n\tcase SC_CARDCTL_LIFECYCLE_GET:\n\t\tswitch (card->type) {\n\t\tcase SC_CARD_TYPE_DNIE_ADMIN:\n\t\t\tresult = SC_CARDCTRL_LIFECYCLE_ADMIN;\n\t\t\tbreak;\n\t\tcase SC_CARD_TYPE_DNIE_USER:\n\t\t\tresult = SC_CARDCTRL_LIFECYCLE_USER;\n\t\t\tbreak;\n\t\tcase SC_CARD_TYPE_DNIE_BLANK:\n\t\tcase SC_CARD_TYPE_DNIE_TERMINATED:\n\t\t\tresult = SC_CARDCTRL_LIFECYCLE_OTHER;\n\t\t\tbreak;\n\t\t}\n\t\t*(int *)data = result;\n\t\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n\t\t/* call card to obtain serial number */\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\tresult = dnie_get_serialnr(card, (sc_serial_number_t *) data);\n\t\tLOG_FUNC_RETURN(card->ctx, result);\n\tcase SC_CARDCTL_DNIE_GENERATE_KEY:\n\t\t/* some reports says that this card supports genkey */\n\t\tresult = dnie_generate_key(card, data);\n\t\tLOG_FUNC_RETURN(card->ctx, result);\n\tcase SC_CARDCTL_DNIE_GET_INFO:\n\t\t/* retrieve name, surname and eid number */\n\t\tresult = dnie_get_info(card, data);\n\t\tLOG_FUNC_RETURN(card->ctx, result);\n\tdefault:\n\t\t/* default: unsupported function */\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/*\n * Generate a new key.\n */\n", "func_signal": "static int\ngids_generate_key(sc_profile_t *profile, sc_pkcs15_card_t *p15card,\n                       sc_pkcs15_object_t *obj,\n                       sc_pkcs15_pubkey_t *pubkey)", "code": "{\n\tsc_card_t *card = p15card->card;\n\tstruct sc_cardctl_gids_genkey call = {obj, pubkey};\n\tLOG_FUNC_RETURN(card->ctx, sc_card_ctl(card, SC_CARDCTL_GIDS_GENERATE_KEY, &call));\n}", "path": "OpenSC/src/pkcs15init/pkcs15-gids.c", "commit_date": "2018-12-06 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * Analyze a buffer looking for provided data pattern.\n *\n * Commodity function for dnie_get_info() that searches a byte array\n * in provided buffer\n *\n * @param card pointer to card info data\n * @param pat data pattern to find in buffer\n * @param buf where to look for pattern\n * @param len buffer length\n * @return retrieved value or NULL if pattern not found\n * @see dnie_get_info()\n */\n", "func_signal": "static char *findPattern(u8 *pat, u8 *buf, size_t len)", "code": "{\n\tchar *res = NULL;\n\tu8 *from = buf;\n\tint size = 0;\n\t/* Locate pattern. Assume pattern length=6 */\n\tfor ( from = buf; from < buf+len-6; from++) {\n\t\tif (memcmp(from,pat,6) == 0 ) goto data_found;\n\t}\n\t/* arriving here means pattern not found */\n\treturn NULL;\n\ndata_found:\n\t/* assume length is less than 128 bytes, so is coded in 1 byte */\n\tsize = 0x000000ff & (int) *(from+6);\n\tif ( size == 0 ) return NULL; /* empty data */\n\tres = calloc( size+1, sizeof(char) );\n\tif ( res == NULL) return NULL; /* calloc() error */\n\tmemcpy(res,from+7,size);\n\treturn res;\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/* simclist helpers to locate interesting objects by ID */\n", "func_signal": "static int object_list_seeker(const void *el, const void *key)", "code": "{\n\tconst struct sc_pkcs11_object *object = (struct sc_pkcs11_object *)el;\n\n\tif ((el == NULL) || (key == NULL))\n\t\treturn 0;\n\tif (object->handle == *(CK_OBJECT_HANDLE*)key)\n\t\treturn 1;\n\treturn 0;\n}", "path": "OpenSC/src/pkcs11/slot.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * Retrieve serial number (7 bytes) from card.\n *\n * This is done by mean of an special APDU command described\n * in the DNIe Reference Manual\n *\n * @param card pointer to card description\n * @param serial where to store data retrieved\n * @return SC_SUCCESS if ok; else error code\n */\n", "func_signal": "static int dnie_get_serialnr(sc_card_t * card, sc_serial_number_t * serial)", "code": "{\n\tint result;\n\tsc_apdu_t apdu;\n\tu8 rbuf[MAX_RESP_BUFFER_SIZE];\n\tif ((card == NULL) || (card->ctx == NULL) || (serial == NULL))\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (card->type != SC_CARD_TYPE_DNIE_USER)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t/* if serial number is cached, use it */\n\tif (card->serialnr.len) {\n\t\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\t\tsc_log_hex(card->ctx, \"Serial Number (cached)\", serial->value, serial->len);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n\t}\n\t/* not cached, retrieve it by mean of an APDU */\n\t/* official driver read 0x11 bytes, but only uses 7. Manual says just 7 (for le) */\n\tdnie_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xb8, 0x00, 0x00, 0x07, 0,\n\t\t\t\t\trbuf, sizeof(rbuf), NULL, 0);\n\tapdu.cla = 0x90;\t/* proprietary cmd */\n\t/* send apdu */\n\tresult = sc_transmit_apdu(card, &apdu);\n\tif (result != SC_SUCCESS) {\n\t\tLOG_TEST_RET(card->ctx, result, \"APDU transmit failed\");\n\t}\n\tif (apdu.sw1 != 0x90 || apdu.sw2 != 0x00)\n\t\treturn SC_ERROR_INTERNAL;\n\t/* cache serial number */\n\tmemcpy(card->serialnr.value, apdu.resp, 7 * sizeof(u8));\n\tcard->serialnr.len = 7 * sizeof(u8);\n\t/* TODO: fill Issuer Identification Number data with proper (ATR?) info */\n\t/*\n\t   card->serialnr.iin.mii=;\n\t   card->serialnr.iin.country=;\n\t   card->serialnr.iin.issuer_id=;\n\t */\n\t/* copy and return serial number */\n\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\tsc_log_hex(card->ctx, \"Serial Number (apdu)\", serial->value, serial->len);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/** \n * Generate a public/private key pair.\n *\n * Manual says that generate_keys() is a reserved operation; that is: \n * only can be done at DGP offices. But several authors talk about \n * this operation is available also outside. So need to test :-)\n * Notice that write operations are not supported, so we can't use \n * created keys to generate and store new certificates into the card.\n * TODO: copy code from card-jcop.c::jcop_generate_keys()\n * @param card pointer to card info data\n * @param data where to store function results\n * @return SC_SUCCESS if ok, else error code\n */\n", "func_signal": "static int dnie_generate_key(sc_card_t * card, void *data)", "code": "{\n\tint result = SC_ERROR_NOT_SUPPORTED;\n\tif ((card == NULL) || (data == NULL))\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tLOG_FUNC_CALLED(card->ctx);\n\t/* TODO: write dnie_generate_key() */\n\tLOG_FUNC_RETURN(card->ctx, result);\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * Check if provided card can be handled by OpenDNIe.\n *\n * Called in sc_connect_card().  Must return 1, if the current\n * card can be handled with this driver, or 0 otherwise.  ATR\n * field of the sc_card struct is filled in before calling\n * this function.\n * do not declare static, as used by pkcs15-dnie module\n *\n * @param card Pointer to card structure\n * @return on card matching 0 if not match; negative return means error\n */\n", "func_signal": "int dnie_match_card(struct sc_card *card)", "code": "{\n\tint result = 0;\n\tint matched = -1;\n\tLOG_FUNC_CALLED(card->ctx);\n\tmatched = _sc_match_atr(card, dnie_atrs, &card->type);\n\tresult = (matched >= 0) ? 1 : 0;\n\tLOG_FUNC_RETURN(card->ctx, result);\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * Implementation of Set_Security_Environment card driver command.\n *\n * Initializes the security environment on card\n *   according to <env>, and stores the environment as <se_num> on the\n *   card. If se_num <= 0, the environment will not be stored. \n *   Notice that OpenDNIe SM handling requires a buffer longer than \n *   provided for this command; so special apdu is used in cwa code\n *\n * @param card Pointer to card driver Structure\n * @param env Pointer to security environment data\n * @param num: which Card Security environment to use (ignored in OpenDNIe)\n * @return SC_SUCCESS if OK; else error code\n *\n * TODO: mix these code with SM set_security_env operations\n *\n */\n", "func_signal": "static int dnie_set_security_env(struct sc_card *card,\n\t\t\t\t const struct sc_security_env *env, int se_num)", "code": "{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\t/* buffer to compose apdu data */\n\tu8 rbuf[MAX_RESP_BUFFER_SIZE];\n\tu8 *p = sbuf;\n\tint result = SC_SUCCESS;\n\tif ((card == NULL) || (card->ctx == NULL) || (env == NULL))\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (se_num!=0) {\n\t\tsc_log(card->ctx,\"DNIe cannot handle several security envs\");\n\t\tLOG_FUNC_RETURN(card->ctx,SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\t/* Secure Channel should be on here, if not means an error */\n\t/*\n\tresult =\n\t    cwa_create_secure_channel(card, dnie_priv.provider, CWA_SM_WARM);\n\tLOG_TEST_RET(card->ctx, result,\n\t\t     \"set_security_env(); Cannot establish SM\");\n\t*/\n\n\t/* check for algorithms */\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT) {\n\t\tsc_log(card->ctx, \"checking algorithms\");\n\t\tswitch (env->algorithm) {\n\t\tcase SC_ALGORITHM_RSA:\n\t\t\tresult = SC_SUCCESS;\n\t\t\tbreak;\n\t\tcase SC_ALGORITHM_DSA:\n\t\tcase SC_ALGORITHM_EC:\n\t\tcase SC_ALGORITHM_GOSTR3410:\n\t\tdefault:\n\t\t\tresult = SC_ERROR_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\tLOG_TEST_RET(card->ctx, result, \"Unsupported algorithm\");\n\t\tif ((env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1) == 0) {\n\t\t\tresult = SC_ERROR_NOT_SUPPORTED;\n\t\t\t/* TODO: \n\t\t\t * Manual says that only RSA with SHA1 is supported, but found\n\t\t\t * some docs where states that SHA256 is also handled\n\t\t\t */\n\t\t}\n\t\tLOG_TEST_RET(card->ctx, result,\n\t\t\t     \"Only RSA with SHA1 is supported\");\n\t\t/* ok: insert algorithm reference into buffer */\n\t\t*p++ = 0x80;\t/* algorithm reference tag */\n\t\t*p++ = 0x01;\t/* len */\n\t\t*p++ = env->algorithm_ref & 0xff;\t/* val */\n\t}\n\n\t/* check for key references */\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT) {\n\t\tsc_log(card->ctx, \"checking key references\");\n\t\tif (env->key_ref_len != 1) {\n\t\t\tsc_log(card->ctx, \"Null or invalid key ID reference\");\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t\t}\n\t\tsc_log(card->ctx, \"Using key reference '%s'\",\n\t\t       sc_dump_hex(env->key_ref, env->key_ref_len));\n\t\t/* ok: insert key reference into buffer */\n\t\t/* notice that DNIe uses same key reference for pubk and privk */\n\n\t\t/* see cwa14890-2 sect B.1 about Control Reference Template Tags */\n\t\t*p++ = 0x84;\t/* TODO: make proper detection of 0x83 /0x84 tag usage */\n\t\t*p++ = 0x02;\t/* len  */\n\t\t*p++ = 0x01;\t/* key ID prefix (MSB byte of keyFile ID) */\n\t\tmemcpy(p, env->key_ref, env->key_ref_len);\t/* in DNIe key_ref_len=1 */\n\t\tp += env->key_ref_len;\n\t\t/* store key reference into private data */\n\t\tGET_DNIE_PRIV_DATA(card)->rsa_key_ref = 0xff & env->key_ref[0];\n\t}\n\n\t/* create and format apdu */\n\tdnie_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x22, 0x00, 0x00, 255, p - sbuf,\n\t\t\t\t\trbuf, MAX_RESP_BUFFER_SIZE, sbuf, p - sbuf);\n\n\t/* check and perform operation */\n\tswitch (env->operation) {\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\t/* TODO: Manual is unsure about if (de)cipher() is supported */\n\t\tapdu.p1 = 0xC1;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tapdu.p1 = 0x41;\t/* SET; internal operation */\n\t\tapdu.p2 = 0xB6;\t/* Template for Digital Signature */\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\t/* Notice that Manual states that DNIE only allows handle of \n\t * current security environment, so se_num is ignored, and\n\t * store sec env apdu (00 22 F2 se_num) command will not be issued */\n\n\t/* send composed apdu and parse result */\n\tresult = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, result, \"Set Security Environment failed\");\n\tresult = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\n\tLOG_FUNC_RETURN(card->ctx, result);\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/* Print virtual_slots list. Called by DEBUG_VSS(S, C) */\n", "func_signal": "void _debug_virtual_slots(sc_pkcs11_slot_t *p)", "code": "{\n\tint i, vs_size;\n\tsc_pkcs11_slot_t * slot;\n\n\tvs_size = list_size(&virtual_slots);\n\t_sc_debug(context, 10,\n\t\t\t\"VSS size:%d\", vs_size);\n\t_sc_debug(context, 10,\n\t\t\t\"VSS  [i] id   flags LU events nsessions slot_info.flags reader p11card description\");\n\tfor (i = 0; i < vs_size; i++) {\n\t\tslot = (sc_pkcs11_slot_t *) list_get_at(&virtual_slots, i);\n\t\tif (slot) {\n\t\t\t_sc_debug(context, 10,\n\t\t\t\t\"VSS %s[%d] 0x%2.2lx 0x%4.4x %d  %d  %d %4.4lx  %p %p %.64s\",\n\t\t\t\t((slot == p) ? \"*\" : \" \"),\n\t\t\t\ti, slot->id, slot->flags, slot->login_user, slot->events, slot->nsessions,\n\t\t\t\tslot->slot_info.flags,\n\t\t\t\tslot->reader, slot->p11card,\n\t\t\t\tslot->slot_info.slotDescription);\n\t\t}\n\t}\n\t_sc_debug(context, 10, \"VSS END\");\n}", "path": "OpenSC/src/pkcs11/slot.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/*\n * Create a new key file.\n */\n", "func_signal": "static int\ngids_create_key(sc_profile_t *profile, sc_pkcs15_card_t *p15card, sc_pkcs15_object_t *obj)", "code": "{\n\tsc_card_t *card = p15card->card;\n\tLOG_FUNC_RETURN(card->ctx, sc_card_ctl(card, SC_CARDCTL_GIDS_CREATE_KEY, obj));\n}", "path": "OpenSC/src/pkcs15init/pkcs15-gids.c", "commit_date": "2018-12-06 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * Uncompress data if in compressed format.\n *\n * @param card pointer to sc_card_t structure\n * @param from buffer to get data from\n * @param len pointer to buffer length\n * @return uncompressed or original buffer; len points to new buffer length\n *        on error return null\n */\n", "func_signal": "static u8 *dnie_uncompress(sc_card_t * card, u8 * from, size_t *len)", "code": "{\n\tu8 *upt = from;\n#ifdef ENABLE_ZLIB\n\tint res = SC_SUCCESS;\n\tsize_t uncompressed = 0L;\n\tsize_t compressed = 0L;\n\n\tif (!card || !card->ctx || !from || !len)\n\t\treturn NULL;\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* if data size not enough for compression header assume uncompressed */\n\tif (*len < 8)\n\t\tgoto compress_exit;\n\t/* evaluate compressed an uncompressed sizes (little endian format) */\n\tuncompressed = lebytes2ulong(from);\n\tcompressed = lebytes2ulong(from + 4);\n\t/* if compressed size doesn't match data length assume not compressed */\n\tif (compressed != (*len) - 8)\n\t\tgoto compress_exit;\n\t/* if compressed size greater than uncompressed, assume uncompressed data */\n\tif (uncompressed < compressed)\n\t\tgoto compress_exit;\n\t/* Do not try to allocate insane size if we receive bogus data */\n\tif (uncompressed > MAX_FILE_SIZE)\n\t\tgoto compress_exit;\n\n\tsc_log(card->ctx, \"Data seems to be compressed. calling uncompress\");\n\t/* ok: data seems to be compressed */\n\tupt = calloc(uncompressed, sizeof(u8));\n\tif (!upt) {\n\t\tsc_log(card->ctx, \"alloc() for uncompressed buffer failed\");\n\t\treturn NULL;\n\t}\n\t*len = uncompressed;\n\tres = sc_decompress(upt,\t/* try to uncompress by calling sc_xx routine */\n\t\t\t    len,\n\t\t\t    from + 8, (size_t) compressed, COMPRESSION_ZLIB);\n\tif (res != SC_SUCCESS) {\n\t\tsc_log(card->ctx, \"Uncompress() failed or data not compressed\");\n\t\tgoto compress_exit;\t/* assume not need uncompression */\n\t}\n\t/* Done; update buffer len and return pt to uncompressed data */\n\tsc_log_hex(card->ctx, \"Compressed data\", from + 8, compressed);\n\tsc_log_hex(card->ctx, \"Uncompressed data\", upt, uncompressed);\n compress_exit:\n\n#endif\n\n\tsc_log(card->ctx, \"uncompress: returning with%s de-compression \",\n\t       (upt == from) ? \"out\" : \"\");\n\treturn upt;\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/*\n * Store a usable private key on the card.\n */\n", "func_signal": "static int\ngids_store_key(sc_profile_t *profile, sc_pkcs15_card_t *p15card, sc_pkcs15_object_t *object,\n                    sc_pkcs15_prkey_t *key)", "code": "{\n\tsc_card_t *card = p15card->card;\n\t\n\tstruct sc_cardctl_gids_importkey call = {object, key};\n\tLOG_FUNC_RETURN(card->ctx, sc_card_ctl(card, SC_CARDCTL_GIDS_IMPORT_KEY, &call));\n}", "path": "OpenSC/src/pkcs15init/pkcs15-gids.c", "commit_date": "2018-12-06 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/*\n * Select a PIN reference\n */\n", "func_signal": "static int\nrutoken_select_pin_reference(sc_profile_t *profile, sc_pkcs15_card_t *p15card,\n\t\t\tsc_pkcs15_auth_info_t *auth_info)", "code": "{\n\tint pin_ref;\n\tunsigned int so_pin_flag;\n\n\tif (!profile || !p15card || !p15card->card || !p15card->card->ctx || !auth_info)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tSC_FUNC_CALLED(p15card->card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (auth_info->auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)\n\t\treturn SC_ERROR_OBJECT_NOT_VALID;\n\n\tpin_ref = auth_info->attrs.pin.reference;\n\tso_pin_flag = auth_info->attrs.pin.flags & SC_PKCS15_PIN_FLAG_SO_PIN;\n\n\tsc_log(p15card->card->ctx,  \"PIN reference %i%s\\n\",\n\t\t\tpin_ref, so_pin_flag ? \" SO PIN flag\" : \"\");\n\n\tif ((pin_ref == SC_RUTOKEN_DEF_ID_GCHV_ADMIN && so_pin_flag)\n\t\t\t|| (pin_ref == SC_RUTOKEN_DEF_ID_GCHV_USER && !so_pin_flag)\n\t)\n\t\treturn SC_SUCCESS;\n\telse\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n}", "path": "OpenSC/src/pkcs15init/pkcs15-rutoken.c", "commit_date": "2018-12-06 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/*\n * Initialization routine\n */\n", "func_signal": "static int create_pins(sc_card_t *card)", "code": "{\n\tsc_DO_V2_t param_do;\n\tsize_t i;\n\tint r = SC_SUCCESS;\n\n\tfor (i = 0; i < sizeof(do_pins)/sizeof(do_pins[0]); ++i)\n\t{\n\t\tmemset(&param_do, 0, sizeof(param_do));\n\t\tparam_do.HDR.OTID.byObjectType  = SC_RUTOKEN_TYPE_CHV;\n\t\tparam_do.HDR.OTID.byObjectID    = do_pins[i].id;\n\t\tparam_do.HDR.OP.byObjectOptions = do_pins[i].options;\n\t\tparam_do.HDR.OP.byObjectFlags   = do_pins[i].flags;\n\t\tparam_do.HDR.OP.byObjectTry     = do_pins[i].try;\n\t\tparam_do.HDR.wDOBodyLen = sizeof(do_pins[i].pass);\n\t\t/* assert(do_pins[i].p_sattr != NULL); */\n\t\t/* assert(sizeof(*param_do.HDR.SA_V2)) */\n\t\t/* assert(sizeof(param_do.HDR.SA_V2) == sizeof(*do_pins[i].p_sattr)); */\n\t\tmemcpy(param_do.HDR.SA_V2, *do_pins[i].p_sattr,\n\t\t\t\tsizeof(*do_pins[i].p_sattr));\n\t\t/* assert(do_pins[i].pass); */\n\t\t/* assert(sizeof(*param_do.abyDOBody)) */\n\t\t/* assert(sizeof(param_do.abyDOBody) >= sizeof(do_pins[i].pass)); */\n\t\tmemcpy(param_do.abyDOBody, do_pins[i].pass, sizeof(do_pins[i].pass));\n\n\t\tr = sc_card_ctl(card, SC_CARDCTL_RUTOKEN_CREATE_DO, &param_do);\n\t\tif (r != SC_SUCCESS) break;\n\t}\n\treturn r;\n}", "path": "OpenSC/src/pkcs15init/pkcs15-rutoken.c", "commit_date": "2018-12-06 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * Internal function to initialize card driver function pointers.\n *\n * This is done by getting a copy for iso7816 card operations, \n * and replace every DNIe specific functions\n *\n * @return DNIe card driver data, or null on failure\n */\n", "func_signal": "static sc_card_driver_t *get_dnie_driver(void)", "code": "{\n\tsc_card_driver_t *iso_drv = sc_get_iso7816_driver();\n\n\t/* memcpy() from standard iso7816 declared operations */\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\tdnie_ops = *iso_drv->ops;\n\n\t/* fill card specific function pointers */\n\t/* NULL means that function is not supported neither by DNIe nor iso7816.c */\n\t/* if pointer is omitted, default ISO7816 function will be used */\n\n\t/* initialization */\n\tdnie_ops.match_card\t= dnie_match_card;\n\tdnie_ops.init\t\t= dnie_init;\n\tdnie_ops.finish\t\t= dnie_finish;\n\n\t/* iso7816-4 functions */\n\tdnie_ops.read_binary\t= dnie_read_binary;\n\tdnie_ops.write_binary\t= NULL;\n\tdnie_ops.update_binary\t= NULL;\n\tdnie_ops.erase_binary\t= NULL;\n\tdnie_ops.read_record\t= NULL;\n\tdnie_ops.write_record\t= NULL;\n\tdnie_ops.append_record\t= NULL;\n\tdnie_ops.update_record\t= NULL;\n\tdnie_ops.select_file\t= dnie_select_file;\n\tdnie_ops.get_challenge\t= dnie_get_challenge;\n\n\t/* iso7816-8 functions */\n\tdnie_ops.verify\t\t= NULL;\n\tdnie_ops.logout\t\t= dnie_logout;\n\t/* dnie_ops.restore_security_env */\n\tdnie_ops.set_security_env = dnie_set_security_env;\n\tdnie_ops.decipher\t= dnie_decipher;\n\tdnie_ops.compute_signature = dnie_compute_signature;\n\tdnie_ops.change_reference_data = NULL;\n\tdnie_ops.reset_retry_counter = NULL;\n\n\t/* iso7816-9 functions */\n\tdnie_ops.create_file\t= NULL;\n\tdnie_ops.delete_file\t= NULL;\n\tdnie_ops.list_files\t= dnie_list_files;\n\tdnie_ops.check_sw\t= dnie_check_sw;\n\tdnie_ops.card_ctl\t= dnie_card_ctl;\n\tdnie_ops.process_fci\t= dnie_process_fci;\n\t/* dnie_ops.construct_fci */\n\tdnie_ops.pin_cmd\t= dnie_pin_cmd;\n\tdnie_ops.get_data\t= NULL;\n\tdnie_ops.put_data\t= NULL;\n\tdnie_ops.delete_record\t= NULL;\n\n\treturn &dnie_driver;\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * Read first bytes of an EF to check for compression data.\n *\n * FCI info on compressed files provides the length of the compressed\n * data. When fci returns filetype = 0x24, needs to check if the\n * file is compressed, and set up properly correct file length, to let\n * the read_binary() file cache work\n *\n * Extract real file length from compressed file is done by mean of\n * reading 8 first bytes for uncompressed/compressed length. \n * Lengths are provided as two 4-byte little endian numbers\n *\n * Implemented just like a direct read binary apdu bypassing dnie file cache\n *\n * @param card sc_card_t structure pointer\n * @return <0: error code - ==0 not compressed - >0 file size\n */\n", "func_signal": "static int dnie_read_header(struct sc_card *card)", "code": "{\n\tsc_apdu_t apdu;\n\tint r;\n\tu8 buf[MAX_RESP_BUFFER_SIZE];\n\tunsigned long uncompressed = 0L;\n\tunsigned long compressed = 0L;\n\tsc_context_t *ctx = NULL;\n\n\tif (!card || !card->ctx)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\n\t/* initialize apdu */\n\tdnie_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, 0x00, 0x00, 8, 0,\n\t\t\t\t\tbuf, MAX_RESP_BUFFER_SIZE, NULL, 0);\n\t/* transmit apdu */\n\tr = sc_transmit_apdu(card, &apdu);\n\tif (r != SC_SUCCESS) {\n\t\tsc_log(ctx, \"read_header() APDU transmit failed\");\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\t/* check response */\n\tif (apdu.resplen != 8)\n\t\tgoto header_notcompressed;\n\tuncompressed = lebytes2ulong(apdu.resp);\n\tcompressed = lebytes2ulong(apdu.resp + 4);\n\tif (uncompressed < compressed)\n\t\tgoto header_notcompressed;\n\tif (uncompressed > 32767)\n\t\tgoto header_notcompressed;\n\t/* ok: assume data is correct */\n\tsc_log(ctx, \"read_header: uncompressed file size is %lu\", uncompressed);\n\treturn (int)(0x7FFF & uncompressed);\n\n header_notcompressed:\n\tsc_log(ctx, \"response doesn't match compressed file header\");\n\treturn 0;\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/*\n * Create a PIN object within the given DF\n */\n", "func_signal": "static int\nrutoken_create_pin(sc_profile_t *profile, sc_pkcs15_card_t *p15card,\n\t\t\tsc_file_t *df, sc_pkcs15_object_t *pin_obj,\n\t\t\tconst unsigned char *pin, size_t pin_len,\n\t\t\tconst unsigned char *puk, size_t puk_len)", "code": "{\n\tsc_context_t *ctx;\n\tsc_pkcs15_auth_info_t *auth_info;\n\tsize_t i;\n\n\t(void)puk; /* no warning */\n\tif (!profile || !p15card || !p15card->card || !p15card->card->ctx\n\t\t\t|| !df || !pin_obj || !pin_obj->data || !pin || !pin_len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tctx = p15card->card->ctx;\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (puk_len != 0)\n\t{\n\t\tsc_log(ctx, \n\t\t\t\t\"Do not enter User unblocking PIN (PUK): %s\\n\",\n\t\t\t\tsc_strerror(SC_ERROR_NOT_SUPPORTED));\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tauth_info = (sc_pkcs15_auth_info_t *)pin_obj->data;\n\tif (auth_info->auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)\n                return SC_ERROR_OBJECT_NOT_VALID;\n\n\tfor (i = 0; i < sizeof(do_pins)/sizeof(do_pins[0]); ++i)\n\t\tif (auth_info->attrs.pin.reference == do_pins[i].id)\n\t\t{\n\t\t\tif (pin_len == sizeof(do_pins[i].pass)\n\t\t\t\t\t&&  memcmp(do_pins[i].pass, pin, pin_len) == 0\n\t\t\t)\n\t\t\t\treturn SC_SUCCESS;\n\t\t\telse\n\t\t\t{\n\t\t\t\tsc_log(ctx,  \"Incorrect PIN\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tsc_log(ctx, \n\t\t\t\"PIN reference %i not found in standard (Rutoken) PINs\\n\",\n\t\t\tauth_info->attrs.pin.reference);\n\treturn SC_ERROR_NOT_SUPPORTED;\n}", "path": "OpenSC/src/pkcs15init/pkcs15-rutoken.c", "commit_date": "2018-12-06 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/* Called from C_WaitForSlotEvent */\n", "func_signal": "CK_RV slot_find_changed(CK_SLOT_ID_PTR idp, int mask)", "code": "{\n\tunsigned int i;\n\tLOG_FUNC_CALLED(context);\n\n\tcard_detect_all();\n\tfor (i=0; i<list_size(&virtual_slots); i++) {\n\t\tsc_pkcs11_slot_t *slot = (sc_pkcs11_slot_t *) list_get_at(&virtual_slots, i);\n\t\tsc_log(context, \"slot 0x%lx token: %lu events: 0x%02X\",\n\t\t       slot->id, (slot->slot_info.flags & CKF_TOKEN_PRESENT),\n\t\t       slot->events);\n\t\tif ((slot->events & SC_EVENT_CARD_INSERTED)\n\t\t\t\t&& !(slot->slot_info.flags & CKF_TOKEN_PRESENT)) {\n\t\t\t/* If a token has not been initialized, clear the inserted event */\n\t\t\tslot->events &= ~SC_EVENT_CARD_INSERTED;\n\t\t}\n\t\tsc_log(context, \"mask: 0x%02X events: 0x%02X result: %d\", mask, slot->events, (slot->events & mask));\n\n\t\tif (slot->events & mask) {\n\t\t\tslot->events &= ~mask;\n\t\t\t*idp = slot->id;\n\t\t\tLOG_FUNC_RETURN(context, CKR_OK);\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(context, CKR_NO_EVENT);\n}", "path": "OpenSC/src/pkcs11/slot.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * OpenDNIe implementation of Get_Challenge() command.\n *\n * Get challenge: retrieve 8 random bytes for any further use\n * (eg perform an external authenticate command)\n *\n * NOTE:\n * Official driver redundantly sets SM before execute this command\n * No reason to do it, as is needed to do SM handshake...\n * Also: official driver reads in blocks of 20 bytes. \n * Why? Manual and iso-7816-4 states that only 8 bytes \n * are required... so we will obey Manual\n *\n * @param card Pointer to card Structure\n * @param rnd Where to store challenge\n * @param len requested challenge length\n * @return SC_SUCCESS if OK; else error code\n */\n", "func_signal": "static int dnie_get_challenge(struct sc_card *card, u8 * rnd, size_t len)", "code": "{\n\t/* As DNIe cannot handle other data length than 0x08 and 0x14 */\n\tu8 rbuf[8];\n\tsize_t out_len;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = iso_ops->get_challenge(card, rbuf, sizeof rbuf);\n\tLOG_TEST_RET(card->ctx, r, \"GET CHALLENGE cmd failed\");\n\n\tif (len < (size_t) r) {\n\t\tout_len = len;\n\t} else {\n\t\tout_len = (size_t) r;\n\t}\n\tmemcpy(rnd, rbuf, out_len);\n\n\tLOG_FUNC_RETURN(card->ctx, (int) out_len);\n}", "path": "OpenSC/src/libopensc/card-dnie.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "OpenSC/OpenSC", "stars": 2370, "license": "lgpl-2.1", "language": "c", "size": 22549}
{"docstring": "/**\n * Close and free any _backend_ related information...\n * @param sl\n */\n", "func_signal": "void _stlink_sg_close(stlink_t *sl)", "code": "{\n    if (sl) {\n        struct stlink_libsg *slsg = sl->backend_data;\n        libusb_close(slsg->usb_handle);\n        libusb_exit(slsg->libusb_ctx);\n        free(slsg);\n    }\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// force the core exit the debug mode.\n", "func_signal": "int _stlink_sg_run(stlink_t *sl)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_DEBUG_RUNCORE;\n    sl->q_len = 2;\n    sg->q_addr = 0;\n\n    if (stlink_q(sl)) { return(-1); }\n\n    stlink_stat(sl, \"run core\");\n\n    return(0);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "/* A wrapper around the connect() function.\n * The purpose of this wrapper is to ensure that the global errno symbol is set if an error occurs,\n * even if we are using winsock.\n */\n", "func_signal": "int win32_connect(SOCKET fd, struct sockaddr *addr, socklen_t addr_len)", "code": "{\n    int rc = connect(fd, addr, addr_len);\n    assert(rc == 0 || rc == SOCKET_ERROR);\n\n    if (rc == SOCKET_ERROR) { set_connect_errno(WSAGetLastError()); }\n\n    return(rc);\n}", "path": "stlink/src/win32/win32_socket.c", "commit_date": "2020-06-13 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// write one DWORD data to memory\n", "func_signal": "int _stlink_sg_write_debug32(stlink_t *sl, uint32_t addr, uint32_t data)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_JTAG_WRITEDEBUG_32BIT;\n    // 2-5: addr\n    write_uint32(sg->cdb_cmd_blk + 2, addr);\n    write_uint32(sg->cdb_cmd_blk + 6, data);\n    sl->q_len = 2;\n    return(stlink_q(sl));\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "/**\n * Wraps a CDB mass storage command in the appropriate gunk to get it down\n * @param handle\n * @param endpoint\n * @param cdb\n * @param cdb_length\n * @param lun\n * @param flags\n * @param expected_rx_size\n * @return\n */\n", "func_signal": "int send_usb_mass_storage_command(libusb_device_handle *handle, uint8_t endpoint_out,\n                                  uint8_t *cdb, uint8_t cdb_length,\n                                  uint8_t lun, uint8_t flags, uint32_t expected_rx_size)", "code": "{\n    DLOG(\"Sending usb m-s cmd: cdblen:%d, rxsize=%d\\n\", cdb_length, expected_rx_size);\n    dump_CDB_command(cdb, cdb_length);\n\n    static uint32_t tag;\n\n    if (tag == 0) { tag = 1; }\n\n    int try = 0;\n    int ret = 0;\n    int real_transferred;\n    int i = 0;\n\n    uint8_t c_buf[STLINK_SG_SIZE];\n    // tag is allegedly ignored... TODO - verify\n    c_buf[i++] = 'U';\n    c_buf[i++] = 'S';\n    c_buf[i++] = 'B';\n    c_buf[i++] = 'C';\n    write_uint32(&c_buf[i], tag);\n    uint32_t this_tag = tag++;\n    write_uint32(&c_buf[i + 4], expected_rx_size);\n    i += 8;\n    c_buf[i++] = flags;\n    c_buf[i++] = lun;\n\n    c_buf[i++] = cdb_length;\n\n    // now the actual CDB request\n    assert(cdb_length <= CDB_SL);\n    memcpy(&(c_buf[i]), cdb, cdb_length);\n\n    int sending_length = STLINK_SG_SIZE;\n\n    // send....\n    do {\n        ret = libusb_bulk_transfer(handle, endpoint_out, c_buf, sending_length,\n                                   &real_transferred, SG_TIMEOUT_MSEC);\n\n        if (ret == LIBUSB_ERROR_PIPE) {\n            libusb_clear_halt(handle, endpoint_out);\n        }\n\n        try++;\n    } while ((ret == LIBUSB_ERROR_PIPE) && (try < 3));\n\n    if (ret != LIBUSB_SUCCESS) {\n        WLOG(\"sending failed: %d\\n\", ret);\n        return(-1);\n    }\n\n    return(this_tag);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "/* Simple gettimeofday implementation without converting Windows time to Linux time */\n", "func_signal": "int gettimeofday(struct timeval *tv, struct timezone *tz)", "code": "{\n    FILETIME ftime;\n    ULARGE_INTEGER ulint;\n    static int tzflag = 0;\n\n    if(NULL != tv) {\n        GetSystemTimeAsFileTime(&ftime);\n        ulint.LowPart = ftime.dwLowDateTime;\n        ulint.HighPart = ftime.dwHighDateTime;\n\n        tv->tv_sec = (long)(ulint.QuadPart / 10000000L);\n        tv->tv_usec = (long)(ulint.QuadPart % 10000000L);\n    }\n\n    if(NULL != tz) {\n        if (!tzflag) {\n            _tzset();\n            tzflag++;\n        }\n        tz->tz_minuteswest = _timezone / 60;\n        tz->tz_dsttime = _daylight;\n    }\n\n    return 0;\n}", "path": "stlink/src/win32/sys_time.c", "commit_date": "2020-12-05 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// write a register of the debug module of the core.\n// XXX ?(atomic writes)\n// TODO: test\n", "func_signal": "void stlink_write_dreg(stlink_t *sl, uint32_t reg, uint32_t addr)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    DLOG(\"\\n*** stlink_write_dreg ***\\n\");\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_DEBUG_APIV1_WRITEDEBUGREG;\n    // 2-5: address of reg of the debug module\n    // 6-9: reg content\n    write_uint32(sg->cdb_cmd_blk + 2, addr);\n    write_uint32(sg->cdb_cmd_blk + 6, reg);\n    sl->q_len = 2;\n    sg->q_addr = addr;\n    stlink_q(sl);\n    stlink_stat(sl, \"write debug reg\");\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// Get stlink mode:\n// STLINK_DEV_DFU_MODE || STLINK_DEV_MASS_MODE || STLINK_DEV_DEBUG_MODE\n// usb dfu             || usb mass             || jtag or swd\n", "func_signal": "int _stlink_sg_current_mode(stlink_t *stl)", "code": "{\n    struct stlink_libsg *sl = stl->backend_data;\n    clear_cdb(sl);\n    sl->cdb_cmd_blk[0] = STLINK_GET_CURRENT_MODE;\n    stl->q_len = 2;\n    sl->q_addr = 0;\n\n    if (stlink_q(stl)) { return(-1); }\n\n    return(stl->q_buf[0]);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// read one DWORD data from memory\n", "func_signal": "int _stlink_sg_read_debug32(stlink_t *sl, uint32_t addr, uint32_t *data)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_JTAG_READDEBUG_32BIT;\n    // 2-5: addr\n    write_uint32(sg->cdb_cmd_blk + 2, addr);\n    sl->q_len = 8;\n\n    if (stlink_q(sl)) { return(-1); }\n\n    *data = read_uint32(sl->q_buf, 4);\n    return(0);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// TODO: test and make delegate!\n", "func_signal": "void stlink_clr_hw_bp(stlink_t *sl, int fp_nr)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    DLOG(\"\\n*** stlink_clr_hw_bp ***\\n\");\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_DEBUG_APIV1_CLEARFP;\n    sg->cdb_cmd_blk[2] = fp_nr;\n\n    sl->q_len = 2;\n    stlink_q(sl);\n    stlink_stat(sl, \"clear flash breakpoint\");\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// read an arm-core register, the index must be in the range 0..20.\n//  0  |  1  | ... |  15   |  16   |   17    |   18       |  19   |  20\n// r0  | r1  | ... | r15   | xpsr  | main_sp | process_sp | rw    | rw2\n", "func_signal": "int _stlink_sg_read_reg(stlink_t *sl, int r_idx, struct stlink_reg *regp)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_DEBUG_APIV1_READREG;\n    sg->cdb_cmd_blk[2] = r_idx;\n    sl->q_len = 4;\n    sg->q_addr = 0;\n\n    if (stlink_q(sl)) { return(-1); }\n\n    //  0  |  1  | ... |  15   |  16   |   17    |   18       |  19   |  20\n    // 0-3 | 4-7 | ... | 60-63 | 64-67 | 68-71   | 72-75      | 76-79 | 80-83\n    // r0  | r1  | ... | r15   | xpsr  | main_sp | process_sp | rw    | rw2\n    stlink_print_data(sl);\n\n    uint32_t r = read_uint32(sl->q_buf, 0);\n    DLOG(\"r_idx (%2d) = 0x%08x\\n\", r_idx, r);\n\n    switch (r_idx) {\n    case 16:\n        regp->xpsr = r;\n        break;\n    case 17:\n        regp->main_sp = r;\n        break;\n    case 18:\n        regp->process_sp = r;\n        break;\n    case 19:\n        regp->rw = r; // XXX ?(primask, basemask etc.)\n        break;\n    case 20:\n        regp->rw2 = r; // XXX ?(primask, basemask etc.)\n        break;\n    default:\n        regp->r[r_idx] = r;\n    }\n\n    return(0);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "/**\n * Straight from stm8 stlink code...\n * @param handle\n * @param endpoint_in\n * @param endpoint_out\n */\n", "func_signal": "static void get_sense(libusb_device_handle *handle, uint8_t endpoint_in, uint8_t endpoint_out)", "code": "{\n    DLOG(\"Fetching sense...\\n\");\n    uint8_t cdb[16];\n    memset(cdb, 0, sizeof(cdb));\n#define REQUEST_SENSE 0x03\n#define REQUEST_SENSE_LENGTH 18\n    cdb[0] = REQUEST_SENSE;\n    cdb[4] = REQUEST_SENSE_LENGTH;\n    uint32_t tag = send_usb_mass_storage_command(handle, endpoint_out, cdb, sizeof(cdb), 0,\n                                                 LIBUSB_ENDPOINT_IN, REQUEST_SENSE_LENGTH);\n\n    if (tag == 0) {\n        WLOG(\"refusing to send request sense with tag 0\\n\");\n        return;\n    }\n\n    unsigned char sense[REQUEST_SENSE_LENGTH];\n    int transferred;\n    int ret;\n    int try = 0;\n\n    do {\n        ret = libusb_bulk_transfer(handle, endpoint_in, sense, sizeof(sense),\n                                   &transferred, SG_TIMEOUT_MSEC);\n\n        if (ret == LIBUSB_ERROR_PIPE) { libusb_clear_halt(handle, endpoint_in); }\n\n        try++;\n    } while ((ret == LIBUSB_ERROR_PIPE) && (try < 3));\n\n    if (ret != LIBUSB_SUCCESS) {\n        WLOG(\"receiving sense failed: %d\\n\", ret);\n        return;\n    }\n\n    if (transferred != sizeof(sense)) {\n        WLOG(\"received unexpected amount of sense: %d != %d\\n\", transferred, sizeof(sense));\n    }\n\n    uint32_t received_tag;\n    int status = get_usb_mass_storage_status(handle, endpoint_in, &received_tag);\n\n    if (status != 0) {\n        WLOG(\"receiving sense failed with status: %02x\\n\", status);\n        return;\n    }\n\n    if (sense[0] != 0x70 && sense[0] != 0x71) {\n        WLOG(\"No sense data\\n\");\n    } else {\n        WLOG(\"Sense KCQ: %02X %02X %02X\\n\", sense[2] & 0x0f, sense[12], sense[13]);\n    }\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "/* A wrapper around the socket() function.\n * The purpose of this wrapper is to ensure that the global errno symbol is set if an error occurs,\n * even if we are using winsock.\n */\n", "func_signal": "SOCKET win32_socket(int domain, int type, int protocol)", "code": "{\n    SOCKET fd = socket(domain, type, protocol);\n\n    if (fd == INVALID_SOCKET) { set_socket_errno(WSAGetLastError()); }\n\n    return(fd);\n}", "path": "stlink/src/win32/win32_socket.c", "commit_date": "2020-06-13 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// arm-core reset -> halted state.\n", "func_signal": "int _stlink_sg_jtag_reset(stlink_t *sl, int value)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_JTAG_DRIVE_NRST;\n    sg->cdb_cmd_blk[2] = (value) ? 0 : 1;\n    sl->q_len = 3;\n    sg->q_addr = 2;\n\n    if (stlink_q(sl)) { return(-1); }\n\n    stlink_stat(sl, \"core reset\");\n\n    return(0);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// XXX kernel driver performs reset, the device temporally disappears\n// Suspect this is no longer the case when we have ignore on? RECHECK\n", "func_signal": "int _stlink_sg_exit_dfu_mode(stlink_t *sl)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    DLOG(\"\\n*** stlink_exit_dfu_mode ***\\n\");\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[0] = STLINK_DFU_COMMAND;\n    sg->cdb_cmd_blk[1] = STLINK_DFU_EXIT;\n    sl->q_len = 0; // ??\n    return(stlink_q(sl));\n    /*\n       [135121.844564] sd 19:0:0:0: [sdb] Unhandled error code\n       [135121.844569] sd 19:0:0:0: [sdb] Result: hostbyte=DID_ERROR driverbyte=DRIVER_OK\n       [135121.844574] sd 19:0:0:0: [sdb] CDB: Read(10): 28 00 00 00 10 00 00 00 08 00\n       [135121.844584] end_request: I/O error, dev sdb, sector 4096\n       [135121.844590] Buffer I/O error on device sdb, logical block 512\n       [135130.122567] usb 6-1: reset full speed USB device using uhci_hcd and address 7\n       [135130.274551] usb 6-1: device firmware changed\n       [135130.274618] usb 6-1: USB disconnect, address 7\n       [135130.275186] VFS: busy inodes on changed media or resized disk sdb\n       [135130.275424] VFS: busy inodes on changed media or resized disk sdb\n       [135130.286758] VFS: busy inodes on changed media or resized disk sdb\n       [135130.292796] VFS: busy inodes on changed media or resized disk sdb\n       [135130.301481] VFS: busy inodes on changed media or resized disk sdb\n       [135130.304316] VFS: busy inodes on changed media or resized disk sdb\n       [135130.431113] usb 6-1: new full speed USB device using uhci_hcd and address 8\n       [135130.629444] usb-storage 6-1:1.0: Quirks match for vid 0483 pid 3744: 102a1\n       [135130.629492] scsi20 : usb-storage 6-1:1.0\n       [135131.625600] scsi 20:0:0:0: Direct-Access     STM32                          PQ: 0 ANSI: 0\n       [135131.627010] sd 20:0:0:0: Attached scsi generic sg2 type 0\n       [135131.633603] sd 20:0:0:0: [sdb] 64000 512-byte logical blocks: (32.7 MB/31.2 MiB)\n       [135131.633613] sd 20:0:0:0: [sdb] Assuming Write Enabled\n       [135131.633620] sd 20:0:0:0: [sdb] Assuming drive cache: write through\n       [135131.640584] sd 20:0:0:0: [sdb] Assuming Write Enabled\n       [135131.640592] sd 20:0:0:0: [sdb] Assuming drive cache: write through\n       [135131.640609]  sdb:\n       [135131.652634] sd 20:0:0:0: [sdb] Assuming Write Enabled\n       [135131.652639] sd 20:0:0:0: [sdb] Assuming drive cache: write through\n       [135131.652645] sd 20:0:0:0: [sdb] Attached SCSI removable disk\n       [135131.671536] sd 20:0:0:0: [sdb] Result: hostbyte=DID_OK driverbyte=DRIVER_SENSE\n       [135131.671548] sd 20:0:0:0: [sdb] Sense Key : Illegal Request [current]\n       [135131.671553] sd 20:0:0:0: [sdb] Add. Sense: Logical block address out of range\n       [135131.671560] sd 20:0:0:0: [sdb] CDB: Read(10): 28 00 00 00 f9 80 00 00 08 00\n       [135131.671570] end_request: I/O error, dev sdb, sector 63872\n       [135131.671575] Buffer I/O error on device sdb, logical block 7984\n       [135131.678527] sd 20:0:0:0: [sdb] Result: hostbyte=DID_OK driverbyte=DRIVER_SENSE\n       [135131.678532] sd 20:0:0:0: [sdb] Sense Key : Illegal Request [current]\n       [135131.678537] sd 20:0:0:0: [sdb] Add. Sense: Logical block address out of range\n       [135131.678542] sd 20:0:0:0: [sdb] CDB: Read(10): 28 00 00 00 f9 80 00 00 08 00\n       [135131.678551] end_request: I/O error, dev sdb, sector 63872\n       ...\n       [135131.853565] end_request: I/O error, dev sdb, sector 4096\n     */\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// write an arm-core register. Index:\n//  0  |  1  | ... |  15   |  16   |   17    |   18       |  19   |  20\n// r0  | r1  | ... | r15   | xpsr  | main_sp | process_sp | rw    | rw2\n", "func_signal": "int _stlink_sg_write_reg(stlink_t *sl, uint32_t reg, int idx)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_DEBUG_APIV1_WRITEREG;\n    //   2: reg index\n    // 3-6: reg content\n    sg->cdb_cmd_blk[2] = idx;\n    write_uint32(sg->cdb_cmd_blk + 3, reg);\n    sl->q_len = 2;\n    sg->q_addr = 0;\n\n    if (stlink_q(sl)) { return(-1); }\n\n    stlink_stat(sl, \"write reg\");\n    return(0);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// write a \"len\" bytes from the sl->q_buf to the memory, max Q_BUF_LEN bytes.\n", "func_signal": "int _stlink_sg_write_mem32(stlink_t *sl, uint32_t addr, uint16_t len)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    int ret;\n\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_DEBUG_WRITEMEM_32BIT;\n    // 2-5: addr\n    // 6-7: len \"unlimited\"\n    write_uint32(sg->cdb_cmd_blk + 2, addr);\n    write_uint16(sg->cdb_cmd_blk + 6, len);\n\n    // this sends the command...\n    ret = send_usb_mass_storage_command(sg->usb_handle,\n                                        sg->ep_req, sg->cdb_cmd_blk, CDB_SL, 0, 0, 0);\n\n    if (ret == -1) { return(ret); }\n\n    // This sends the data...\n    ret = send_usb_data_only(sg->usb_handle,\n                             sg->ep_req, sg->ep_rep, sl->q_buf, len);\n\n    if (ret == -1) { return(ret); }\n\n    stlink_print_data(sl);\n    return(0);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// read all arm-core registers.\n", "func_signal": "int _stlink_sg_read_all_regs(stlink_t *sl, struct stlink_reg *regp)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_DEBUG_APIV1_READALLREGS;\n    sl->q_len = 84;\n    sg->q_addr = 0;\n\n    if (stlink_q(sl)) { return(-1); }\n\n    stlink_print_data(sl);\n\n    // TODO: most of this should be re-extracted up....\n\n    // 0-3 | 4-7 | ... | 60-63 | 64-67 | 68-71   | 72-75      | 76-79 | 80-83\n    // r0  | r1  | ... | r15   | xpsr  | main_sp | process_sp | rw    | rw2\n    for (int i = 0; i < 16; i++) {\n        regp->r[i] = read_uint32(sl->q_buf, 4 * i);\n\n        if (sl->verbose > 1) { DLOG(\"r%2d = 0x%08x\\n\", i, regp->r[i]); }\n    }\n\n    regp->xpsr = read_uint32(sl->q_buf, 64);\n    regp->main_sp = read_uint32(sl->q_buf, 68);\n    regp->process_sp = read_uint32(sl->q_buf, 72);\n    regp->rw = read_uint32(sl->q_buf, 76);\n    regp->rw2 = read_uint32(sl->q_buf, 80);\n\n    if (sl->verbose < 2) { return(0); }\n\n    DLOG(\"xpsr       = 0x%08x\\n\", regp->xpsr);\n    DLOG(\"main_sp    = 0x%08x\\n\", regp->main_sp);\n    DLOG(\"process_sp = 0x%08x\\n\", regp->process_sp);\n    DLOG(\"rw         = 0x%08x\\n\", regp->rw);\n    DLOG(\"rw2        = 0x%08x\\n\", regp->rw2);\n\n    return(0);\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "/* A wrapper around the accept() function.\n * The purpose of this wrapper is to ensure that the global errno symbol is set if an error occurs,\n * even if we are using winsock.\n */\n", "func_signal": "SOCKET win32_accept(SOCKET fd, struct sockaddr *addr, socklen_t *addr_len)", "code": "{\n    SOCKET newfd = accept(fd, addr, addr_len);\n\n    if (newfd == INVALID_SOCKET) {\n        set_socket_errno(WSAGetLastError());\n        newfd = (SOCKET)-1;\n    }\n\n    return(newfd);\n}", "path": "stlink/src/win32/win32_socket.c", "commit_date": "2020-06-13 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "// exit the mass mode and enter the swd debug mode.\n", "func_signal": "int _stlink_sg_enter_swd_mode(stlink_t *sl)", "code": "{\n    struct stlink_libsg *sg = sl->backend_data;\n    clear_cdb(sg);\n    sg->cdb_cmd_blk[1] = STLINK_DEBUG_APIV1_ENTER;\n    sg->cdb_cmd_blk[2] = STLINK_DEBUG_ENTER_SWD;\n    sl->q_len = 0; // >0 -> aboard\n    return(stlink_q(sl));\n}", "path": "stlink/src/stlink-lib/sg.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "stlink-org/stlink", "stars": 4085, "license": "bsd-3-clause", "language": "c", "size": 17348}
{"docstring": "/**\n *\n * Main entry point.\n *\n * @param[in]  argc        Number of command line arguments.\n * @param[in]  argv        The command line arguments.\n *\n * @return 0 if the operation ran successfully, -1 if there was an error during\n *         execution.\n *\n ******************************************************************************\n */\n", "func_signal": "int\nmain(int argc,\n     char *argv[])", "code": "{\n   VGAuthError err;\n   VGAuthContext *ctx;\n\n   appName = g_path_get_basename(argv[0]);\n   if (argc != 1) {\n      Usage();\n   }\n\n   VGAuth_SetLogHandler(Log, NULL, 0, NULL);\n\n   err = VGAuth_Init(appName, 0, NULL, &ctx);\n   if (VGAUTH_E_OK != err) {\n      g_printerr(\"Failed to init VGAuth\");\n      return -1;\n   }\n\n   // make sure we start with a clean slate\n   err = CleanAliases(ctx, ALIAS_USER_NAME);\n   if (VGAUTH_E_OK != err) {\n      g_printerr(\"Failed to clean alias store\");\n      return -1;\n   }\n\n   err = AddAlias(ctx, smoketestPEMCert,\n                  ALIAS_USER_NAME, SUBJECT_NAME, COMMENT);\n   if (VGAUTH_E_OK != err) {\n      g_printerr(\"Failed to add alias\");\n      return -1;\n   }\n\n   err = ValidateToken(ctx, ALIAS_USER_NAME, token);\n   if (VGAUTH_E_OK != err) {\n      g_printerr(\"Failed to validate SAML token\");\n      return -1;\n   }\n\n   printf(\"PASSED!\\n\");\n\n   // make sure we end with a clean slate\n   err = CleanAliases(ctx, ALIAS_USER_NAME);\n   if (VGAUTH_E_OK != err) {\n      g_printerr(\"Failed to clean alias store\");\n      return -1;\n   }\n\n   VGAuth_Shutdown(ctx);\n   g_free(appName);\n   return 0;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/test/main.c", "commit_date": "2017-09-15 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Checks whether, given a start time and duration, the current time is\n * passed that duration.\n *\n * @param[in]  start     The start time.\n * @param[in]  duration  The timeout in seconds.\n *\n * @return  TRUE if the current time is passed the duration or FALSE otherwise.\n *\n ******************************************************************************\n */\n", "func_signal": "gboolean\nUtil_CheckExpiration(const GTimeVal *start,\n                     unsigned int duration)", "code": "{\n   GTimeVal now;\n   GTimeVal expire;\n\n   /*\n    * XXX blech.  Move to GDateTime as soon as the toolchain glib\n    * supports it (version 2.26).\n    */\n   g_get_current_time(&now);\n   expire = *start;\n\n   expire.tv_sec += duration;\n\n   /*\n    * We don't need the precision, so just ignore micros.\n    */\n   return now.tv_sec > expire.tv_sec;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/VGAuthUtil.c", "commit_date": "2016-11-14 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Check if the number is a 32bit number\n *\n * @param[in]   number     The number to check\n *\n * @note   size_t is 64bit on a 64bit system, and 32bit on a 32bit system\n *\n * @return TRUE if the number is a 32bit number, FALSE otherwise.\n *\n ******************************************************************************\n */\n", "func_signal": "gboolean\nCheck_Is32bitNumber(size_t number)", "code": "{\n   unsigned long long number64 = (unsigned long long)number;\n\n   /*\n    * Cast to 64bit to shift 32bit\n    * Otherwise, the C compiler warns and generates no-op code\n    */\n   number64 >>=32;\n\n   return (number64 == 0);\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/VGAuthUtil.c", "commit_date": "2016-11-14 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Hang the current thread.\n * Debug function to help diagnose IPC issues and unit tests such as pipe full.\n *\n * @param[in]   func       The function name\n * @param[in]   file       The file name\n * @param[in]   line       The line number\n *\n ******************************************************************************\n */\n", "func_signal": "void HangThread(const char *func,\n                const char *file,\n                unsigned line)", "code": "{\n   LogDebug(func, file, line, \"Hang the calling thread\");\n\n   do {\n      g_usleep(1000 * G_USEC_PER_SEC);\n   } while (TRUE);\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/VGAuthUtil.c", "commit_date": "2016-11-14 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Convert a NULL terminated UTF16 string to a NULL terminated UTF8 string\n * Log an error if the conversion fails.\n *\n * @param[in]   func       The function name\n * @param[in]   file       The file name\n * @param[in]   line       The line number\n * @param[in]   str        The input NULL terminated UTF16 string\n *\n * @return a utf8 string result\n *\n ******************************************************************************\n */\n", "func_signal": "gchar *\nConvert_Utf16ToUtf8(const char *func,\n                    const char *file,\n                    unsigned line,\n                    const gunichar2 *str)", "code": "{\n   glong nRead = 0;\n   glong nWritten = 0;\n   GError *pError = NULL;\n   gchar *result = g_utf16_to_utf8(str, -1, &nRead, &nWritten, &pError);\n\n   if (!result) {\n      LogWarning(func, file, line, \"g_utf16_to_utf8() failed, %s, \"\n                 \"read %d wchar(s), written %d byte(s)\", pError->message,\n                 (int)nRead, (int)nWritten);\n      g_clear_error(&pError);\n   }\n\n   return result;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/VGAuthUtil.c", "commit_date": "2016-11-14 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * While 'bufIn' points to a byte in 'sentinel', increment it.\n *\n * @param[in] bufIn     The input buffer.\n * @param[in] sentinel  The set of chars to Walk over.\n *\n * @return The incremented buffer.\n *\n ******************************************************************************\n */\n", "func_signal": "static void const *\nWalk(void const * const bufIn,\n     int const * const sentinel)", "code": "{\n   char const *buf;\n\n   buf = (char const *)bufIn;\n   ASSERT(buf);\n\n   /* Unsigned does matter --hpreg */\n   while (sentinel[(unsigned char)*buf]) {\n      buf++;\n   }\n\n   return buf;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Frees memory allocated for a MsgCatalog structure.\n *\n * @param[in] catalog    The catalog to free.\n *\n ******************************************************************************\n */\n", "func_signal": "static void\nMsgCatalogFree(gpointer c)", "code": "{\n   MsgCatalog *catalog = (MsgCatalog *) c;\n   ASSERT(catalog);\n   if (catalog->utf8 != NULL) {\n      g_hash_table_unref(catalog->utf8);\n   }\n   g_free(catalog);\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Loads the message catalog at the given path into a new hash table.\n * The catalog entries are a simple <key> = <value>.  Line continutatiom\n * is not supported.\n *\n * @param[in] path    Path containing the message catalog (encoding should be\n *                    UTF-8).\n *\n * @return A new message catalog on success, NULL otherwise.\n *\n ******************************************************************************\n */\n", "func_signal": "static MsgCatalog *\nMsgLoadCatalog(const char *path)", "code": "{\n   gchar *localPath;\n   GError *err = NULL;\n   GIOChannel *stream;\n   gboolean error = FALSE;\n   MsgCatalog *catalog = NULL;\n   GHashTable *dict;\n\n   localPath = GET_FILENAME_LOCAL(path, NULL);\n   ASSERT(localPath != NULL);\n\n   stream = g_io_channel_new_file(localPath, \"r\", &err);\n   g_debug(\"%s: loading message catalog '%s'\\n\", __FUNCTION__, localPath);\n   RELEASE_FILENAME_LOCAL(localPath);\n\n   if (err != NULL) {\n      g_debug(\"Unable to open '%s': %s\\n\", path, err->message);\n      g_clear_error(&err);\n      return NULL;\n   }\n\n   dict = g_hash_table_new_full(g_str_hash,\n                                g_str_equal,\n                                g_free,\n                                g_free);\n   for (;;) {\n      char *name = NULL;\n      char *value = NULL;\n      gchar *line;\n      gsize len;\n      gsize term;\n      char *unused = NULL;\n\n      /* Read the next key / value pair. */\n\n      g_io_channel_read_line(stream, &line, &len, &term, &err);\n\n      if (err != NULL) {\n         g_warning(\"Unable to read a line from '%s': %s\\n\",\n                   path, err->message);\n         g_clear_error(&err);\n         error = TRUE;\n         g_free(line);\n         break;\n      }\n\n      if (line == NULL) {\n         /* This signifies EOF. */\n         break;\n      }\n\n      /*\n       * Fix the line break to always be Unix-style, to make lib/dict\n       * happy.\n       */\n      if (line[term] == '\\r') {\n         line[term] = '\\n';\n         if (len > term) {\n            line[term + 1] = '\\0';\n         }\n      }\n\n      /*\n       * Try to parse the string using the dictionary library.\n       */\n      if (DictLL_UnmarshalLine(line, len, &unused, &name, &value) == NULL) {\n         g_warning(\"Couldn't parse line from catalog: %s\", line);\n         error = TRUE;\n      }\n      g_free(unused);\n      g_free(line);\n\n      if (error) {\n         /*\n          * If the local DictLL_UnmarshalLine() returns NULL, name and value\n          * will remain NULL pointers.  No malloc'ed memory to free here.\n          */\n         break;\n      }\n\n      if (name != NULL) {\n         gchar *val;\n         ASSERT(value);\n\n         if (!g_utf8_validate(name, -1, NULL) ||\n             !g_utf8_validate(value, -1, NULL)) {\n            g_warning(\"Invalid UTF-8 string in message catalog (key = %s)\\n\", name);\n            error = TRUE;\n            g_free(name);\n            g_free(value);\n            break;\n         }\n\n         // remove any escaped chars\n         val = g_strcompress(value);\n         g_free(value);\n\n         // the hashtable takes ownership of the memory for 'name' and 'val'\n         g_hash_table_insert(dict, name, val);\n      }\n   }\n\n   g_io_channel_unref(stream);\n\n   if (error) {\n      g_hash_table_unref(dict);\n      dict = NULL;\n   } else {\n      catalog = g_new0(MsgCatalog, 1);\n      catalog->utf8 = dict;\n   }\n\n   return catalog;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Returns a string describing the user's default language using the\n * \"language[_territory]\" format (ISO 639-1 and ISO 3166-1, respectively) as\n * described in the setlocale(3) man page.\n *\n * @return Language code (caller should free).\n *\n ******************************************************************************\n */\n", "func_signal": "static gchar *\nMsgGetUserLanguage(void)", "code": "{\n   gchar *lang;\n\n#if defined(_WIN32)\n   /*\n    * Windows implementation. Derive the ISO names from the user's current\n    * locale.\n    */\n   wchar_t ctryName[10]; /* MSDN says: max is nine characters + terminator. */\n   wchar_t langName[10]; /* MSDN says: max is nine characters + terminator. */\n\n   if (GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SISO3166CTRYNAME,\n                      ctryName, (sizeof(ctryName)/sizeof(langName[0]))) == 0 ||\n       GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME,\n                      langName, (sizeof(langName)/sizeof(langName[0]))) == 0) {\n      g_warning(\"Couldn't retrieve user locale data, error = %u.\", GetLastError());\n      lang = g_strdup(\"C\");\n   } else {\n      lang = g_strdup_printf(\"%S_%S\", langName, ctryName);\n   }\n#else\n   /*\n    * POSIX implementation: just use setlocale() to query the data. Ignore any\n    * codeset information.\n    */\n   char *tmp;\n   /*\n    * This is useful for testing, and also seems to be used by some\n    * distros (NeoKylin) rather than the setlocale() APIs.\n    * See PR 1672149\n    */\n   char *envLocale = getenv(\"LANG\");\n   if (envLocale != NULL) {\n      lang = g_strdup(envLocale);\n      g_debug(\"%s: Using LANG override of '%s'\\n\", __FUNCTION__, lang);\n      return lang;\n   }\n   tmp = setlocale(LC_MESSAGES, NULL);\n   if (tmp == NULL) {\n      lang = g_strdup(\"C\");\n   } else {\n      char *dot;\n\n      lang = g_strdup(tmp);\n      dot = strchr(lang, '.');\n      if (dot != NULL) {\n         *dot = '\\0';\n      }\n   }\n#endif\n\n   return lang;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Generates a SAMl token with a given Subject.\n *\n * @param[in]  ctx        VGAuth context\n * @param[in]  cert       The certificate for the alias.\n * @param[in]  user       The user whose alias store is to be updated.\n * @param[in]  subject    The Subject for the alias.\n * @param[in]  comment    The Comment for the alias.\n *\n * @return A SAMl token on success, NULL failure.\n *\n ******************************************************************************\n */\n", "func_signal": "static VGAuthError\nAddAlias(VGAuthContext *ctx,\n         const gchar *cert,\n         const gchar *user,\n         const gchar *subject,\n         const gchar *comment)", "code": "{\n   VGAuthError err;\n   VGAuthAliasInfo ai;\n\n   ai.subject.type = VGAUTH_SUBJECT_NAMED;\n   ai.subject.val.name = (gchar *)subject;\n   ai.comment = (gchar *)comment;\n   err = VGAuth_AddAlias(ctx, user, FALSE, cert, &ai, 0, NULL);\n   if (err != VGAUTH_E_OK) {\n      g_printerr(\"VGAuth_AddAlias() failed \"VGAUTHERR_FMT64\"\\n\",\n                 err);\n      return err;\n   }\n\n   return err;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/test/main.c", "commit_date": "2017-09-15 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Asserts after spewing some location data.\n *\n * @param[in]  cond      The assertion cause.\n * @param[in]  file      The file.\n * @param[in]  lineNum   The line number.\n *\n ******************************************************************************\n */\n", "func_signal": "void\nUtil_Assert(const char *cond,\n            const char *file,\n            int lineNum)", "code": "{\n   g_warning(\"Assertion '%s' failed at %s:%d\\n\", cond, file, lineNum);\n#ifdef _WIN32\n#ifdef VMX86_DEBUG\n   DebugBreak();\n#endif\n#endif\n   g_assert(0);\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/VGAuthUtil.c", "commit_date": "2016-11-14 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Set the message catalog for a given domain. A NULL catalog clears the\n * current one. This function is not thread-safe, so make sure calls to it\n * are properly protected.\n *\n * @param[in] domain    The text domain being bound.\n * @param[in] catalog   The new message catalog.\n *\n ******************************************************************************\n */\n", "func_signal": "static void\nMsgSetCatalog(const char *domain,\n              MsgCatalog *catalog)", "code": "{\n   MsgState *state = MsgGetState();\n\n   ASSERT(domain);\n\n   if (state->domains == NULL) {\n      state->domains = g_hash_table_new_full(g_str_hash,\n                                             g_str_equal,\n                                             g_free,\n                                             MsgCatalogFree);\n   }\n\n   g_hash_table_insert(state->domains, g_strdup(domain), catalog);\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Retrieves a localized string in the requested encoding.\n *\n * All messages are retrieved based on the catalog data loaded in UTF-8.\n * Strings in other encodings are lazily converted from the UTF-8 version\n * as they are queried.\n *\n * @param[in] domain       Domain from where to fetch the messages.\n * @param[in] msgid        The message id, including the default English text.\n *\n * @return The string in the desired encoding.\n *\n ******************************************************************************\n */\n", "func_signal": "const char *\nI18n_GetString(const char *domain,\n               const char *msgid)", "code": "{\n   const char *idp;\n   const char *strp;\n   char idBuf[MSG_MAX_ID];\n   size_t len;\n   GHashTable *source = NULL;\n   MsgCatalog *catalog;\n   MsgState *state = MsgGetState();\n\n   /* All message strings must be prefixed by the message ID. */\n   ASSERT(domain != NULL);\n   ASSERT(msgid != NULL);\n   ASSERT(MsgHasMsgID(msgid));\n\n   /*\n    * Find the beginning of the ID (idp) and the string (strp).\n    * The string should have the correct MSG_MAGIC(...)... form.\n    */\n\n   idp = msgid + MSG_MAGIC_LEN + 1;\n   strp = strchr(idp, ')') + 1;\n\n   len = strp - idp - 1;\n   ASSERT(len <= MSG_MAX_ID - 1);\n   memcpy(idBuf, idp, len);\n   idBuf[len] = '\\0';\n\n   g_mutex_lock(&state->lock);\n\n   catalog = MsgGetCatalog(domain);\n   if (catalog != NULL) {\n      source = catalog->utf8;\n   }\n\n   if (source != NULL) {\n      const void *retval = g_hash_table_lookup(source, idBuf);\n      if (NULL != retval) {\n         strp = retval;\n      }\n   }\n\n   g_mutex_unlock(&state->lock);\n\n   return strp;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Convert a NULL terminated UTF8 string to a NULL terminiated UTF16 string\n * Log an error if the conversion fails.\n *\n * @param[in]   func       The function name\n * @param[in]   file       The file name\n * @param[in]   line       The line number\n * @param[in]   str        The input NULL terminated UTF8 string\n *\n * @return a utf16 string result\n *\n ******************************************************************************\n */\n", "func_signal": "gunichar2 *\nConvert_Utf8ToUtf16(const char *func,\n                    const char *file,\n                    unsigned line,\n                    const gchar *str)", "code": "{\n   glong nRead = 0;\n   glong nWritten = 0;\n   GError *pError = NULL;\n   gunichar2 *result = g_utf8_to_utf16(str, -1, &nRead, &nWritten, &pError);\n\n   if (!result) {\n      LogWarning(func, file, line, \"g_utf8_to_utf16() failed, %s, \"\n                 \"read %d byte(s), written %d wchar(s)\", pError->message,\n                 (int)nRead, (int)nWritten);\n      g_clear_error(&pError);\n   }\n\n   return result;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/VGAuthUtil.c", "commit_date": "2016-11-14 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Retrives the message catalog for a specific domain. This function is not\n * thread-safe, so make sure calls to it are properly protected.\n *\n * @param[in] domain   The domain name (NULL for default).\n *\n * @return The catalog. If a specific catalog is not found, the default one\n *         is returned (which may be NULL).\n *\n ******************************************************************************\n */\n", "func_signal": "static MsgCatalog *\nMsgGetCatalog(const char *domain)", "code": "{\n   MsgState *state = MsgGetState();\n   MsgCatalog *catalog = NULL;\n\n   ASSERT(domain != NULL);\n\n   if (state->domains != NULL) {\n      catalog = g_hash_table_lookup(state->domains, domain);\n   }\n\n   return catalog;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Reads a dict line from the bufSize-byte buffer buf, which holds one or more\n * new-line delimited lines.  The buffer is not necessarily\n * null-terminated.\n *\n * @param[in]  buf     The input buffer.\n * @param[in]  bufsize The size of the input buffer.\n * @param[out] line    The complete line (must be g_free()d).\n * @param[out] name    The name (must be g_free()d).\n * @param[out] value   The value (must be g_free()d).\n *\n * @return The start of the next line, or NULL if at the end of buffer.\n ******************************************************************************\n */\n", "func_signal": "static const char *\nDictLL_UnmarshalLine(const char *buf,\n                     size_t bufSize,\n                     char **line,\n                     char **name,\n                     char **value)", "code": "{\n   /* Space and tab --hpreg */\n   static int const ws_in[] = {\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n   };\n   /* Everything but NUL, space, tab and pound --hpreg */\n   static int const wsp_out[] = {\n      0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n   };\n   /* Everything but NUL, space, tab, pound and equal --hpreg */\n   static int const wspe_out[] = {\n      0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n   };\n   /* Everything but NUL and double quote --hpreg */\n   static int const q_out[] = {\n      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n   };\n   char const *nBegin;\n   char const *nEnd;\n   char const *vBegin;\n   char const *vEnd;\n   char const *tmp;\n   char *myLine;\n   char *myName;\n   char *myValue;\n   const char *lineEnd;\n   const char *nextLine;\n\n   ASSERT(buf);\n   ASSERT(line);\n   ASSERT(name);\n   ASSERT(value);\n\n   /* Check for end of buffer. */\n   if (bufSize == 0) {\n      *line = NULL;\n      *name = NULL;\n      *value = NULL;\n      return NULL;\n   }\n\n   /* Find end of this line, beginning of next. */\n   lineEnd = memchr(buf, '\\n', bufSize);\n   if (lineEnd != NULL) {\n      nextLine = lineEnd + 1;\n   } else {\n      nextLine = lineEnd = buf + bufSize;\n   }\n\n   /* Make local copy of line. */\n   myLine = g_strndup(buf, lineEnd - buf);\n\n   /* Check if the line is well-formed --hpreg */\n   nBegin = Walk(myLine, ws_in);\n   nEnd = Walk(nBegin, wspe_out);\n   tmp = Walk(nEnd, ws_in);\n   if (nBegin == nEnd || *tmp != '=') {\n      goto weird;\n   }\n   tmp++;\n   tmp = Walk(tmp, ws_in);\n   if (*tmp == '\"') {\n      tmp++;\n      vBegin = tmp;\n      vEnd = Walk(vBegin, q_out);\n      tmp = vEnd;\n      if (*tmp != '\"') {\n         goto weird;\n      }\n      tmp++;\n   } else {\n      vBegin = tmp;\n      vEnd = Walk(vBegin, wsp_out);\n      tmp = vEnd;\n   }\n   tmp = Walk(tmp, ws_in);\n   if (*tmp != '\\0' && *tmp != '#') {\n      goto weird;\n   }\n\n   /* The line is well-formed. Extract the name and value --hpreg */\n\n   myName = g_strndup(nBegin, nEnd - nBegin);\n   myValue = g_strndup(vBegin, vEnd - vBegin);\n   ASSERT(myValue);\n\n   *line = myLine;\n   *name = myName;\n   *value = myValue;\n\n   return nextLine;\n\nweird:\n   /* The line is not well-formed. Let the upper layers handle it --hpreg */\n\n   *line = myLine;\n   *name = NULL;\n   *value = NULL;\n\n   return nextLine;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * DeployPkgLog_Close --\n *\n *    Close the log.\n *\n * Results:\n *    None.\n *\n * Side effects:\n *    File descriptor managed by _s is closed\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "void\nDeployPkgLog_Close()", "code": "{\n   if (_file != NULL) {\n      DeployPkgLog_Log(log_debug, \"## Closing log\");\n      fclose(_file);\n      _file = NULL;\n   }\n}", "path": "open-vm-tools/open-vm-tools/services/plugins/deployPkg/deployPkgLog.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/**\n *\n * Initializes the global message state.\n *\n * @param[in] unused   Unused.\n *\n * @return NULL.\n *\n ******************************************************************************\n */\n", "func_signal": "static gpointer\nMsgInitState(gpointer unused)", "code": "{\n   ASSERT(msgState == NULL);\n   msgState = g_new0(MsgState, 1);\n   g_mutex_init(&msgState->lock);\n   return NULL;\n}", "path": "open-vm-tools/open-vm-tools/vgauth/common/i18n.c", "commit_date": "2019-10-28 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/*\n *-----------------------------------------------------------------------------\n *\n * CodeSetGetModulePath --\n *\n *\tRetrieve the full path to the executable. Not supported under\n *\tVMvisor. Based on HostInfo_GetModulePath, simplified for safe\n *\tuse before ICU is initialized.\n *\n * Results:\n *      On success: The allocated, NUL-terminated file path.\n *         Note: This path can be a symbolic or hard link; it's just one\n *         possible path to access the executable.\n *\n *      On failure: NULL.\n *\n * Side effects:\n *\tNone\n *\n *-----------------------------------------------------------------------------\n */\n", "func_signal": "static char *\nCodeSetGetModulePath(uint32 priv)", "code": "{\n   char path[PATH_MAX];\n   Bool ret = FALSE;\n#if defined(__APPLE__)\n   uint32_t size;\n#else\n   ssize_t size;\n   uid_t uid = -1;\n#endif\n\n   if ((priv != HGMP_PRIVILEGE) && (priv != HGMP_NO_PRIVILEGE)) {\n      return NULL;\n   }\n\n#if defined(__APPLE__)\n   size = sizeof path;\n   if (_NSGetExecutablePath(path, &size)) {\n      goto exit;\n   }\n\n#else\n#if defined(VMX86_SERVER)\n   if (HostType_OSIsVMK()) {\n      goto exit;\n   }\n#endif\n\n   if (priv == HGMP_PRIVILEGE) {\n      uid = Id_BeginSuperUser();\n   }\n\n   size = readlink(\"/proc/self/exe\", path, sizeof path - 1);\n   if (size == -1) {\n      if (priv == HGMP_PRIVILEGE) {\n         Id_EndSuperUser(uid);\n      }\n      goto exit;\n   }\n\n   path[size] = '\\0';\n\n   if (priv == HGMP_PRIVILEGE) {\n      Id_EndSuperUser(uid);\n   }\n#endif\n\n   ret = TRUE;\n\n  exit:\n   if (ret) {\n      return strdup(path);\n   } else {\n      return NULL;\n   }\n}", "path": "open-vm-tools/open-vm-tools/lib/misc/codeset.c", "commit_date": "2020-08-18 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * DeployPkgLog_Open --\n *\n *    Init the log. Creates a file in %temp%/vmware and\n *    opens it for writing. On linux, only root own r/w right.\n *    On error, the file will not be opened and logging\n *    will be disabled.\n *\n * Results:\n *    None.\n *\n * Side effects:\n *    On success, the log file is opened and managed by _file.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "void\nDeployPkgLog_Open()", "code": "{\n   char logPath[2048];\n\n#ifdef _WIN32\n   DWORD ret = GetTempPathA(sizeof logPath, logPath);\n\n   if (ret == 0) {\n      return;\n   }\n\n   Str_Strcat(logPath, \"vmware-imc\", sizeof logPath);\n#else\n   Str_Strcpy(logPath, \"/var/log/vmware-imc\", sizeof logPath);\n#endif\n\n   if (File_CreateDirectoryHierarchy(logPath, NULL)) {\n      Str_Strcat(logPath, DIRSEPS \"toolsDeployPkg.log\", sizeof logPath);\n      _file = fopen(logPath, \"w\");\n      if (_file != NULL) {\n#ifndef _WIN32\n         setlinebuf(_file);\n         (void) chmod(logPath, 0600);\n#else\n         (void)Win32Access_SetFileOwnerRW(logPath);\n#endif\n         DeployPkgLog_Log(log_debug, \"## Starting deploy pkg operation\");\n      } else {\n         g_debug(\"%s: failed to open DeployPkg log file: %s\\n\",\n                   __FUNCTION__, logPath);\n      }\n   } else {\n      g_debug(\"%s: failed to create DeployPkg log directory: %s\\n\",\n                   __FUNCTION__, logPath);\n   }\n}", "path": "open-vm-tools/open-vm-tools/services/plugins/deployPkg/deployPkgLog.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "vmware/open-vm-tools", "stars": 2130, "license": "None", "language": "c", "size": 24066}
{"docstring": "/* \n * decode_moffset\n *    Decode offset-only memory operand\n */\n", "func_signal": "static void\ndecode_moffset(struct ud *u, unsigned int size, struct ud_operand *opr)", "code": "{\n  opr->type  = UD_OP_MEM;\n  opr->base  = UD_NONE;\n  opr->index = UD_NONE;\n  opr->scale = UD_NONE;\n  opr->size = (uint16_t)resolve_operand_size(u, (ud_operand_size_t)size);\n  decode_mem_disp(u, u->adr_mode, opr);\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/*\n * decode_modrm_reg\n *\n *    Decodes reg field of mod/rm byte\n * \n */\n", "func_signal": "static UD_INLINE void\ndecode_modrm_reg(struct ud         *u, \n                 struct ud_operand *operand,\n                 unsigned int       type,\n                 unsigned int       size)", "code": "{\n  uint8_t reg = (REX_R(u->_rex) << 3) | MODRM_REG(modrm(u));\n  decode_reg(u, operand, type, reg, size);\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/*\n * vex_l, vex_w\n *  Return the vex.L and vex.W bits\n */\n", "func_signal": "static UD_INLINE uint8_t\nvex_l(const struct ud *u)", "code": "{\n  UD_ASSERT(u->vex_op != 0);\n  return ((u->vex_op == 0xc4 ? u->vex_b2 : u->vex_b1) >> 2) & 1;\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/*\n * decode_ext()\n *\n *    Decode opcode extensions (if any)\n */\n", "func_signal": "static int\ndecode_ext(struct ud *u, uint16_t ptr)", "code": "{\n  uint8_t idx = 0;\n  if ((ptr & 0x8000) == 0) {\n    return decode_insn(u, ptr); \n  }\n  u->le = &ud_lookup_table_list[(~0x8000 & ptr)];\n  if (u->le->type == UD_TAB__OPC_3DNOW) {\n    return decode_3dnow(u);\n  }\n\n  switch (u->le->type) {\n    case UD_TAB__OPC_MOD:\n      /* !11 = 0, 11 = 1 */\n      idx = (MODRM_MOD(modrm(u)) + 1) / 4;\n      break;\n      /* disassembly mode/operand size/address size based tables.\n       * 16 = 0,, 32 = 1, 64 = 2\n       */\n    case UD_TAB__OPC_MODE:\n      idx = u->dis_mode != 64 ? 0 : 1;\n      break;\n    case UD_TAB__OPC_OSIZE:\n      idx = (uint8_t)(eff_opr_mode(u->dis_mode, REX_W(u->pfx_rex), u->pfx_opr) / 32);\n      break;\n    case UD_TAB__OPC_ASIZE:\n      idx = (uint8_t)(eff_adr_mode(u->dis_mode, u->pfx_adr) / 32);\n      break;\n    case UD_TAB__OPC_X87:\n      idx = modrm(u) - 0xC0;\n      break;\n    case UD_TAB__OPC_VENDOR:\n      if (u->vendor == UD_VENDOR_ANY) {\n        /* choose a valid entry */\n        idx = (u->le->table[idx] != 0) ? 0 : 1;\n      } else if (u->vendor == UD_VENDOR_AMD) {\n        idx = 0;\n      } else {\n        idx = 1;\n      }\n      break;\n    case UD_TAB__OPC_RM:\n      idx = MODRM_RM(modrm(u));\n      break;\n    case UD_TAB__OPC_REG:\n      idx = MODRM_REG(modrm(u));\n      break;\n    case UD_TAB__OPC_SSE:\n      return decode_ssepfx(u);\n    case UD_TAB__OPC_VEX:\n      return decode_vex(u);\n    case UD_TAB__OPC_VEX_W:\n      idx = vex_w(u);\n      break;\n    case UD_TAB__OPC_VEX_L:\n      idx = vex_l(u);\n      break;\n    case UD_TAB__OPC_TABLE:\n      inp_next(u);\n      return decode_opcode(u);\n    default:\n      UD_ASSERT(!\"not reached\");\n      break;\n  }\n\n  return decode_ext(u, u->le->table[idx]);\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/*\n * decode_imm \n *\n *    Decode Immediate values.\n */\n", "func_signal": "static void \ndecode_imm(struct ud* u, unsigned int size, struct ud_operand *op)", "code": "{\n  op->size = (uint16_t)resolve_operand_size(u, (ud_operand_size_t)size);\n  op->type = UD_OP_IMM;\n\n  switch (op->size) {\n  case  8: op->lval.sbyte = inp_uint8(u);   break;\n  case 16: op->lval.uword = inp_uint16(u);  break;\n  case 32: op->lval.udword = inp_uint32(u); break;\n  case 64: op->lval.uqword = inp_uint64(u); break;\n  default: return;\n  }\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/*\n * decode_3dnow()\n *\n *    Decoding 3dnow is a little tricky because of its strange opcode\n *    structure. The final opcode disambiguation depends on the last\n *    byte that comes after the operands have been decoded. Fortunately,\n *    all 3dnow instructions have the same set of operand types. So we\n *    go ahead and decode the instruction by picking an arbitrarily chosen\n *    valid entry in the table, decode the operands, and read the final\n *    byte to resolve the menmonic.\n */\n", "func_signal": "static UD_INLINE int\ndecode_3dnow(struct ud* u)", "code": "{\n  uint16_t ptr;\n  UD_ASSERT(u->le->type == UD_TAB__OPC_3DNOW);\n  UD_ASSERT(u->le->table[0xc] != 0);\n  decode_insn(u, u->le->table[0xc]);\n  inp_next(u); \n  if (u->error) {\n    return -1;\n  }\n  ptr = u->le->table[inp_curr(u)]; \n  UD_ASSERT((ptr & 0x8000) == 0);\n  u->mnemonic = ud_itab[ptr].mnemonic;\n  return 0;\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* \n * decode_operands\n *\n *    Disassemble upto 3 operands of the current instruction being\n *    disassembled. By the end of the function, the operand fields\n *    of the ud structure will have been filled.\n */\n", "func_signal": "static int\ndecode_operands(struct ud* u)", "code": "{\n  decode_operand(u, &u->operand[0],\n                    u->itab_entry->operand1.type,\n                    u->itab_entry->operand1.size);\n  if (u->operand[0].type != UD_NONE) {\n      decode_operand(u, &u->operand[1],\n                        u->itab_entry->operand2.type,\n                        u->itab_entry->operand2.size);\n  }\n  if (u->operand[1].type != UD_NONE) {\n      decode_operand(u, &u->operand[2],\n                        u->itab_entry->operand3.type,\n                        u->itab_entry->operand3.size);\n  }\n  if (u->operand[2].type != UD_NONE) {\n      decode_operand(u, &u->operand[3],\n                        u->itab_entry->operand4.type,\n                        u->itab_entry->operand4.size);\n  }\n  return 0;\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "// GetInstructionLength_x64/x86 were replaced with the Udis86 library\n// (http://udis86.sourceforge.net) see udis86.h/.c for appropriate\n// licensing and copyright notices.\n", "func_signal": "EASYHOOK_NT_INTERNAL LhGetInstructionLength(void* InPtr)", "code": "{\n/*\nDescription:\n\n    Takes a pointer to machine code and returns the length of the\n    referenced instruction in bytes.\n    \nReturns:\n    STATUS_INVALID_PARAMETER\n\n        The given pointer references invalid machine code.\n*/\n\tLONG\t\t\tlength = -1;\n\t// some exotic instructions might not be supported see the project\n    // at https://github.com/vmt/udis86 and the forums.\n\n    ud_t ud_obj;\n    ud_init(&ud_obj);\n#ifdef _M_X64\n    ud_set_mode(&ud_obj, 64);\n#else\n    ud_set_mode(&ud_obj, 32);\n#endif\n    ud_set_input_buffer(&ud_obj, (uint8_t *)InPtr, 32);\n    length = ud_disassemble(&ud_obj); // usually only between 1 and 5\n\n\tif(length > 0)\n\t\treturn length;\n\telse\n\t\treturn STATUS_INVALID_PARAMETER;\n}", "path": "EasyHook/DriverShared/LocalHook/reloc.c", "commit_date": "2018-07-06 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* \n * decode_operand\n *\n *      Decodes a single operand.\n *      Returns the type of the operand (UD_NONE if none)\n */\n", "func_signal": "static int\ndecode_operand(struct ud           *u, \n               struct ud_operand   *operand,\n               enum ud_operand_code type,\n               unsigned int         size)", "code": "{\n  operand->type = UD_NONE;\n  operand->_oprcode = type;\n\n  switch (type) {\n    case OP_A :\n      decode_a(u, operand);\n      break;\n    case OP_MR:\n      decode_modrm_rm(u, operand, REGCLASS_GPR, \n                      MODRM_MOD(modrm(u)) == 3 ? \n                      Mx_reg_size((ud_operand_size_t)size) : Mx_mem_size((ud_operand_size_t)size));\n      break;\n    case OP_F:\n      u->br_far  = 1;\n      /* intended fall through */\n    case OP_M:\n      if (MODRM_MOD(modrm(u)) == 3) {\n        UDERR(u, \"expected modrm.mod != 3\\n\");\n      }\n      /* intended fall through */\n    case OP_E:\n      decode_modrm_rm(u, operand, REGCLASS_GPR, size);\n      break;\n    case OP_G:\n      decode_modrm_reg(u, operand, REGCLASS_GPR, size);\n      break;\n    case OP_sI:\n    case OP_I:\n      decode_imm(u, size, operand);\n      break;\n    case OP_I1:\n      operand->type = UD_OP_CONST;\n      operand->lval.udword = 1;\n      break;\n    case OP_N:\n      if (MODRM_MOD(modrm(u)) != 3) {\n        UDERR(u, \"expected modrm.mod == 3\\n\");\n      }\n      /* intended fall through */\n    case OP_Q:\n      decode_modrm_rm(u, operand, REGCLASS_MMX, size);\n      break;\n    case OP_P:\n      decode_modrm_reg(u, operand, REGCLASS_MMX, size);\n      break;\n    case OP_U:\n      if (MODRM_MOD(modrm(u)) != 3) {\n        UDERR(u, \"expected modrm.mod == 3\\n\");\n      }\n      /* intended fall through */\n    case OP_W:\n      decode_modrm_rm(u, operand, REGCLASS_XMM, size);\n      break;\n    case OP_V:\n      decode_modrm_reg(u, operand, REGCLASS_XMM, size);\n      break;\n    case OP_H:\n      decode_vex_vvvv(u, operand, size);\n      break;\n    case OP_MU:\n      decode_modrm_rm(u, operand, REGCLASS_XMM, \n                      MODRM_MOD(modrm(u)) == 3 ? \n                        Mx_reg_size((ud_operand_size_t)size) : Mx_mem_size((ud_operand_size_t)size));\n      break;\n    case OP_S:\n      decode_modrm_reg(u, operand, REGCLASS_SEG, size);\n      break;\n    case OP_O:\n      decode_moffset(u, size, operand);\n      break;\n    case OP_R0: \n    case OP_R1: \n    case OP_R2: \n    case OP_R3: \n    case OP_R4: \n    case OP_R5: \n    case OP_R6: \n    case OP_R7:\n      decode_reg(u, operand, REGCLASS_GPR, \n                 (REX_B(u->_rex) << 3) | (type - OP_R0), size);\n      break;\n    case OP_AL:\n    case OP_AX:\n    case OP_eAX:\n    case OP_rAX:\n      decode_reg(u, operand, REGCLASS_GPR, 0, size);\n      break;\n    case OP_CL:\n    case OP_CX:\n    case OP_eCX:\n      decode_reg(u, operand, REGCLASS_GPR, 1, size);\n      break;\n    case OP_DL:\n    case OP_DX:\n    case OP_eDX:\n      decode_reg(u, operand, REGCLASS_GPR, 2, size);\n      break;\n    case OP_ES: \n    case OP_CS: \n    case OP_DS:\n    case OP_SS: \n    case OP_FS: \n    case OP_GS:\n      /* in 64bits mode, only fs and gs are allowed */\n      if (u->dis_mode == 64) {\n        if (type != OP_FS && type != OP_GS) {\n          UDERR(u, \"invalid segment register in 64bits\\n\");\n        }\n      }\n      operand->type = UD_OP_REG;\n      operand->base = (type - OP_ES) + UD_R_ES;\n      operand->size = 16;\n      break;\n    case OP_J :\n      decode_imm(u, size, operand);\n      operand->type = UD_OP_JIMM;\n      break ;\n    case OP_R :\n      if (MODRM_MOD(modrm(u)) != 3) {\n        UDERR(u, \"expected modrm.mod == 3\\n\");\n      }\n      decode_modrm_rm(u, operand, REGCLASS_GPR, size);\n      break;\n    case OP_C:\n      decode_modrm_reg(u, operand, REGCLASS_CR, size);\n      break;\n    case OP_D:\n      decode_modrm_reg(u, operand, REGCLASS_DB, size);\n      break;\n    case OP_I3 :\n      operand->type = UD_OP_CONST;\n      operand->lval.sbyte = 3;\n      break;\n    case OP_ST0: \n    case OP_ST1: \n    case OP_ST2: \n    case OP_ST3:\n    case OP_ST4:\n    case OP_ST5: \n    case OP_ST6: \n    case OP_ST7:\n      operand->type = UD_OP_REG;\n      operand->base = (type - OP_ST0) + UD_R_ST0;\n      operand->size = 80;\n      break;\n    case OP_L:\n      decode_vex_immreg(u, operand, size);\n      break;\n    default :\n      operand->type = UD_NONE;\n      break;\n  }\n  return operand->type;\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* -----------------------------------------------------------------------------\n * clear_insn() - clear instruction structure\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void\nclear_insn(register struct ud* u)", "code": "{\n  u->error     = 0;\n  u->pfx_seg   = 0;\n  u->pfx_opr   = 0;\n  u->pfx_adr   = 0;\n  u->pfx_lock  = 0;\n  u->pfx_repne = 0;\n  u->pfx_rep   = 0;\n  u->pfx_repe  = 0;\n  u->pfx_rex   = 0;\n  u->pfx_str   = 0;\n  u->mnemonic  = UD_Inone;\n  u->itab_entry = NULL;\n  u->have_modrm = 0;\n  u->br_far    = 0;\n  u->vex_op    = 0;\n  u->_rex      = 0;\n  u->operand[0].type = UD_NONE;\n  u->operand[1].type = UD_NONE;\n  u->operand[2].type = UD_NONE;\n  u->operand[3].type = UD_NONE;\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "//Write Protection On\n", "func_signal": "void RtlWPOn(KIRQL irql)", "code": "{\n\t// re-enable memory protection (enable WP bit of CR0)   \n\tUINT64 cr0 = __readcr0();\n\tcr0 |= 0x10000;\n\t// enable interrupts\n\t_enable();\n\t__writecr0(cr0);\n\t// lower irql again\n\tKeLowerIrql(irql);\n}", "path": "EasyHook/EasyHookSys/Rtl/memory.c", "commit_date": "2015-11-04 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "// Write Protection Off\n", "func_signal": "KIRQL RtlWPOff()", "code": "{\n\t// prevent rescheduling \n\tKIRQL irql = KeRaiseIrqlToDpcLevel();\n\t// disable memory protection (disable WP bit of CR0)   \n\tUINT64 cr0 = __readcr0();\n\tcr0 &= ~0x10000;\n\t__writecr0(cr0);\n\t// disable interrupts\n\t_disable();\n\treturn irql;\n}", "path": "EasyHook/EasyHookSys/Rtl/memory.c", "commit_date": "2015-11-04 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* \n * decode_prefixes\n *\n *  Extracts instruction prefixes.\n */\n", "func_signal": "static int \ndecode_prefixes(struct ud *u)", "code": "{\n  int done = 0;\n  uint8_t curr = 0, last = 0;\n  UD_RETURN_ON_ERROR(u);\n\n  do {\n    last = curr;\n    curr = inp_next(u); \n    UD_RETURN_ON_ERROR(u);\n    if (u->inp_ctr == MAX_INSN_LENGTH) {\n      UD_RETURN_WITH_ERROR(u, \"max instruction length\");\n    }\n   \n    switch (curr)  \n    {\n    case 0x2E: \n      u->pfx_seg = UD_R_CS; \n      break;\n    case 0x36:     \n      u->pfx_seg = UD_R_SS; \n      break;\n    case 0x3E: \n      u->pfx_seg = UD_R_DS; \n      break;\n    case 0x26: \n      u->pfx_seg = UD_R_ES; \n      break;\n    case 0x64: \n      u->pfx_seg = UD_R_FS; \n      break;\n    case 0x65: \n      u->pfx_seg = UD_R_GS; \n      break;\n    case 0x67: /* adress-size override prefix */ \n      u->pfx_adr = 0x67;\n      break;\n    case 0xF0: \n      u->pfx_lock = 0xF0;\n      break;\n    case 0x66: \n      u->pfx_opr = 0x66;\n      break;\n    case 0xF2:\n      u->pfx_str = 0xf2;\n      break;\n    case 0xF3:\n      u->pfx_str = 0xf3;\n      break;\n    default:\n      /* consume if rex */\n      done = (u->dis_mode == 64 && (curr & 0xF0) == 0x40) ? 0 : 1;\n      break;\n    }\n  } while (!done);\n  /* rex prefixes in 64bit mode, must be the last prefix */\n  if (u->dis_mode == 64 && (last & 0xF0) == 0x40) {\n    u->pfx_rex = last;  \n  }\n  return 0;\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "///////////////////////////////////////////////////////////////////////////////////\n/////////////////////// LhAllocateMemoryEx\n///////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "void* LhAllocateMemoryEx(void* InEntryPoint, ULONG* OutPageSize)", "code": "{\n/*\nDescription:\n\n    Allocates one page of hook specific memory. The page size is returned in OutPageSize\n\nParameters:\n\n    - InEntryPoint\n\n        Ignored for 32-Bit versions and drivers. In 64-Bit user mode, the returned\n        pointer will always be in a 31-bit boundary around this parameter. This way\n        a relative jumper can still be placed instead of having to consume much more entry\n        point bytes for an absolute jump!\n\n    - OutPageSize\n\n        Will be updated to contain the page size.\n\nReturns:\n\n    NULL if no memory could be allocated, a valid pointer otherwise.\n\n*/\n\n    UCHAR*\t\t\t    Res = NULL;\n\n#if defined(_M_X64) && !defined(DRIVER)\n    LONGLONG            Base;\n    LONGLONG\t\t    iStart;\n    LONGLONG\t\t    iEnd;\n    LONGLONG            Index;\n\n#endif\n\t\n#if !defined(DRIVER)\n    SYSTEM_INFO\t\t    SysInfo;\n    ULONG               PAGE_SIZE;\n\n    GetSystemInfo(&SysInfo);\n\n    PAGE_SIZE = SysInfo.dwPageSize;\n    *OutPageSize = PAGE_SIZE;\n#endif\n\n\n    // reserve page with execution privileges\n#if defined(_M_X64) && !defined(DRIVER)\n\n    /*\n        Reserve memory around entry point...\n    */\n    iStart = ((LONGLONG)InEntryPoint) - ((LONGLONG)0x7FFFFF00);\n    iEnd = ((LONGLONG)InEntryPoint) + ((LONGLONG)0x7FFFFF00);\n\n    if(iStart < (LONGLONG)SysInfo.lpMinimumApplicationAddress)\n        iStart = (LONGLONG)SysInfo.lpMinimumApplicationAddress; // shall not be null, because then VirtualAlloc() will not work as expected\n\n    if(iEnd > (LONGLONG)SysInfo.lpMaximumApplicationAddress)\n        iEnd = (LONGLONG)SysInfo.lpMaximumApplicationAddress;\n\n    // we are trying to get memory as near as possible to relocate most RIP-relative instructions\n    for(Base = (LONGLONG)InEntryPoint, Index = 0; ; Index += PAGE_SIZE)\n    {\n\t\tBOOLEAN end = TRUE;\n\t\tif(Base + Index < iEnd)\n\t\t{\n\t\t\tif((Res = (UCHAR*)VirtualAlloc((void*)(Base + Index), PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)) != NULL)\n\t\t\t\tbreak;\n\t\t\tend = FALSE;\n\t\t}\n\n        if(Base - Index > iStart)\n        {\n\t        if((Res = (BYTE*)VirtualAlloc((void*)(Base - Index), PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)) != NULL)\n\t\t        break;\n\t\t\tend = FALSE;\n        }\n\n\t\tif (end)\n\t\t\tbreak;\n    }\n\n    if(Res == NULL)\n\t    return NULL;\n#else\n    \n\t*OutPageSize = PAGE_SIZE;\n\t// in 32-bit mode the trampoline will always be reachable\n\t// In 64-bit driver mode we use an absolute address so the trampoline will always be reachable\n    if((Res = (UCHAR*)RtlAllocateMemory(TRUE, PAGE_SIZE)) == NULL)\n        return NULL;\n\n#endif\n\n    return Res;\n}", "path": "EasyHook/DriverShared/LocalHook/alloc.c", "commit_date": "2016-07-05 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* =============================================================================\n * ud_decode() - Instruction decoder. Returns the number of bytes decoded.\n * =============================================================================\n */\n", "func_signal": "unsigned int\nud_decode(struct ud *u)", "code": "{\n  inp_start(u);\n  clear_insn(u);\n  u->le = &ud_lookup_table_list[0];\n  u->error = decode_prefixes(u) == -1 || \n             decode_opcode(u)   == -1 ||\n             u->error;\n  /* Handle decode error. */\n  if (u->error) {\n    /* clear out the decode data. */\n    clear_insn(u);\n    /* mark the sequence of bytes as invalid. */\n    u->itab_entry = &ud_itab[0]; /* entry 0 is invalid */\n    u->mnemonic = u->itab_entry->mnemonic;\n  } \n\n    /* maybe this stray segment override byte\n     * should be spewed out?\n     */\n    if ( !P_SEG( u->itab_entry->prefix ) && \n            u->operand[0].type != UD_OP_MEM &&\n            u->operand[1].type != UD_OP_MEM )\n        u->pfx_seg = 0;\n\n  u->insn_offset = u->pc; /* set offset of instruction */\n  u->asm_buf_fill = 0;   /* set translation buffer index to 0 */\n  u->pc += u->inp_ctr;    /* move program counter by bytes decoded */\n\n  /* return number of bytes disassembled. */\n  return (unsigned int)u->inp_ctr;\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* \n * decode_vex_immreg\n *    Decode source operand encoded in immediate byte [7:4]\n */\n", "func_signal": "static int\ndecode_vex_immreg(struct ud *u, struct ud_operand *opr, unsigned size)", "code": "{\n  uint8_t imm  = inp_next(u);\n  uint8_t mask = u->dis_mode == 64 ? 0xf : 0x7;\n  UD_RETURN_ON_ERROR(u);\n  UD_ASSERT(u->vex_op != 0);\n  decode_reg(u, opr, REGCLASS_XMM, mask & (imm >> 4), size);\n  return 0;\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* =============================================================================\n * translates to intel syntax \n * =============================================================================\n */\n", "func_signal": "extern void\nud_translate_intel(struct ud* u)", "code": "{\n  /* check if P_OSO prefix is used */\n  if (!P_OSO(u->itab_entry->prefix) && u->pfx_opr) {\n    switch (u->dis_mode) {\n    case 16: ud_asmprintf(u, \"o32 \"); break;\n    case 32:\n    case 64: ud_asmprintf(u, \"o16 \"); break;\n    }\n  }\n\n  /* check if P_ASO prefix was used */\n  if (!P_ASO(u->itab_entry->prefix) && u->pfx_adr) {\n    switch (u->dis_mode) {\n    case 16: ud_asmprintf(u, \"a32 \"); break;\n    case 32: ud_asmprintf(u, \"a16 \"); break;\n    case 64: ud_asmprintf(u, \"a32 \"); break;\n    }\n  }\n\n  if (u->pfx_seg &&\n      u->operand[0].type != UD_OP_MEM &&\n      u->operand[1].type != UD_OP_MEM ) {\n    ud_asmprintf(u, \"%s \", ud_reg_tab[u->pfx_seg - UD_R_AL]);\n  }\n\n  if (u->pfx_lock) {\n    ud_asmprintf(u, \"lock \");\n  }\n  if (u->pfx_rep) {\n    ud_asmprintf(u, \"rep \");\n  } else if (u->pfx_repe) {\n    ud_asmprintf(u, \"repe \");\n  } else if (u->pfx_repne) {\n    ud_asmprintf(u, \"repne \");\n  }\n\n  /* print the instruction mnemonic */\n  ud_asmprintf(u, \"%s\", ud_lookup_mnemonic(u->mnemonic));\n\n  if (u->operand[0].type != UD_NONE) {\n    int cast = 0;\n    ud_asmprintf(u, \" \");\n    if (u->operand[0].type == UD_OP_MEM) {\n      if (u->operand[1].type == UD_OP_IMM   ||\n          u->operand[1].type == UD_OP_CONST ||\n          u->operand[1].type == UD_NONE     ||\n          (u->operand[0].size != u->operand[1].size)) {\n          cast = 1;\n      } else if (u->operand[1].type == UD_OP_REG &&\n                 u->operand[1].base == UD_R_CL) {\n          switch (u->mnemonic) {\n          case UD_Ircl:\n          case UD_Irol:\n          case UD_Iror:\n          case UD_Ircr:\n          case UD_Ishl:\n          case UD_Ishr:\n          case UD_Isar:\n              cast = 1;\n              break;\n          default: break;\n          }\n      }\n    }\n    gen_operand(u, &u->operand[0], cast);\n  }\n\n  if (u->operand[1].type != UD_NONE) {\n    int cast = 0;\n    ud_asmprintf(u, \", \");\n    if (u->operand[1].type == UD_OP_MEM &&\n        u->operand[0].size != u->operand[1].size && \n        !ud_opr_is_sreg(&u->operand[0])) {\n      cast = 1;\n    }\n    gen_operand(u, &u->operand[1], cast);\n  }\n\n  if (u->operand[2].type != UD_NONE) {\n    int cast = 0;\n    ud_asmprintf(u, \", \");\n    if (u->operand[2].type == UD_OP_MEM &&\n        u->operand[2].size != u->operand[1].size) {\n      cast = 1;\n    }\n    gen_operand(u, &u->operand[2], cast);\n  }\n\n  if (u->operand[3].type != UD_NONE) {\n    ud_asmprintf(u, \", \");\n    gen_operand(u, &u->operand[3], 0);\n  }\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/syn-intel.c", "commit_date": "2015-08-09 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* -----------------------------------------------------------------------------\n * gen_operand() - Generates assembly output for each operand.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void gen_operand(struct ud* u, struct ud_operand* op, int syn_cast)", "code": "{\n  switch(op->type) {\n  case UD_OP_REG:\n    ud_asmprintf(u, \"%s\", ud_reg_tab[op->base - UD_R_AL]);\n    break;\n\n  case UD_OP_MEM:\n    if (syn_cast) {\n      opr_cast(u, op);\n    }\n    ud_asmprintf(u, \"[\");\n    if (u->pfx_seg) {\n      ud_asmprintf(u, \"%s:\", ud_reg_tab[u->pfx_seg - UD_R_AL]);\n    }\n    if (op->base) {\n      ud_asmprintf(u, \"%s\", ud_reg_tab[op->base - UD_R_AL]);\n    }\n    if (op->index) {\n      ud_asmprintf(u, \"%s%s\", op->base != UD_NONE? \"+\" : \"\",\n                              ud_reg_tab[op->index - UD_R_AL]);\n      if (op->scale) {\n        ud_asmprintf(u, \"*%d\", op->scale);\n      }\n    }\n    if (op->offset != 0) {\n      ud_syn_print_mem_disp(u, op, (op->base  != UD_NONE || \n                                    op->index != UD_NONE) ? 1 : 0);\n    }\n    ud_asmprintf(u, \"]\");\n    break;\n      \n  case UD_OP_IMM:\n    ud_syn_print_imm(u, op);\n    break;\n\n\n  case UD_OP_JIMM:\n    ud_syn_print_addr(u, ud_syn_rel_target(u, op));\n    break;\n\n  case UD_OP_PTR:\n    switch (op->size) {\n      case 32:\n        ud_asmprintf(u, \"word 0x%x:0x%x\", op->lval.ptr.seg, \n          op->lval.ptr.off & 0xFFFF);\n        break;\n      case 48:\n        ud_asmprintf(u, \"dword 0x%x:0x%x\", op->lval.ptr.seg, \n          op->lval.ptr.off);\n        break;\n    }\n    break;\n\n  case UD_OP_CONST:\n    if (syn_cast) opr_cast(u, op);\n    ud_asmprintf(u, \"%d\", op->lval.udword);\n    break;\n\n  default: return;\n  }\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/syn-intel.c", "commit_date": "2015-08-09 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* -----------------------------------------------------------------------------\n * opr_cast() - Prints an operand cast.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \nopr_cast(struct ud* u, struct ud_operand* op)", "code": "{\n  if (u->br_far) {\n    ud_asmprintf(u, \"far \"); \n  }\n  switch(op->size) {\n  case  8:  ud_asmprintf(u, \"byte \" ); break;\n  case 16:  ud_asmprintf(u, \"word \" ); break;\n  case 32:  ud_asmprintf(u, \"dword \"); break;\n  case 64:  ud_asmprintf(u, \"qword \"); break;\n  case 80:  ud_asmprintf(u, \"tword \"); break;\n  case 128: ud_asmprintf(u, \"oword \"); break;\n  case 256: ud_asmprintf(u, \"yword \"); break;\n  default: break;\n  }\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/syn-intel.c", "commit_date": "2015-08-09 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_a()- Decodes operands of the type seg:offset\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_a(struct ud* u, struct ud_operand *op)", "code": "{\n  if (u->opr_mode == 16) {  \n    /* seg16:off16 */\n    op->type = UD_OP_PTR;\n    op->size = 32;\n    op->lval.ptr.off = inp_uint16(u);\n    op->lval.ptr.seg = inp_uint16(u);\n  } else {\n    /* seg16:off32 */\n    op->type = UD_OP_PTR;\n    op->size = 48;\n    op->lval.ptr.off = inp_uint32(u);\n    op->lval.ptr.seg = inp_uint16(u);\n  }\n}", "path": "EasyHook/DriverShared/Disassembler/libudis86/decode.c", "commit_date": "2015-08-30 00:00:00", "repo_name": "EasyHook/EasyHook", "stars": 2858, "license": "mit", "language": "c", "size": 1119}
{"docstring": "/*\n * Breathe some life into the CPU...\n *\n * Set up the memory map,\n * initialize a bunch of registers,\n * initialize the UPM's\n */\n", "func_signal": "void cpu_init_f(void)", "code": "{\n\t/*\n\t * if we come from RAM we assume the CPU is\n\t * already initialized.\n\t */\n\n#ifndef CONFIG_MONITOR_IS_IN_RAM\n\twdog_t *wdog_reg = (wdog_t *) (MMAP_WDOG);\n\tgpio_t *gpio_reg = (gpio_t *) (MMAP_GPIO);\n\n\t/* Kill watchdog so we can initialize the PLL */\n\tout_be16(&wdog_reg->wcr, 0);\n\n\t/* FlexBus Chipselect */\n\tinit_fbcs();\n#endif\t\t\t\t/* #ifndef CONFIG_MONITOR_IS_IN_RAM */\n\n#ifdef CONFIG_SYS_I2C_FSL\n\tCONFIG_SYS_I2C_PINMUX_REG &= CONFIG_SYS_I2C_PINMUX_CLR;\n\tCONFIG_SYS_I2C_PINMUX_REG |= CONFIG_SYS_I2C_PINMUX_SET;\n#endif\n\n\t/* enable instruction cache now */\n\ticache_enable();\n}", "path": "u-boot/arch/m68k/cpu/mcf52x2/cpu_init.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/* !CONFIG_FSL_LSCH3 */\n", "func_signal": "int adjust_vdd(ulong vdd_override)", "code": "{\n\tint re_enable = disable_interrupts();\n#if defined(CONFIG_FSL_LSCH2)\n\tstruct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);\n#else\n\tccsr_gur_t __iomem *gur =\n\t\t(void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);\n#endif\n\tu32 fusesr;\n\tu8 vid, buf;\n\tint vdd_target, vdd_current, vdd_last;\n\tint ret, i2caddress;\n\tunsigned long vdd_string_override;\n\tchar *vdd_string;\n\tstatic const uint16_t vdd[32] = {\n\t\t0,      /* unused */\n\t\t9875,   /* 0.9875V */\n\t\t9750,\n\t\t9625,\n\t\t9500,\n\t\t9375,\n\t\t9250,\n\t\t9125,\n\t\t9000,\n\t\t8875,\n\t\t8750,\n\t\t8625,\n\t\t8500,\n\t\t8375,\n\t\t8250,\n\t\t8125,\n\t\t10000,  /* 1.0000V */\n\t\t10125,\n\t\t10250,\n\t\t10375,\n\t\t10500,\n\t\t10625,\n\t\t10750,\n\t\t10875,\n\t\t11000,\n\t\t0,      /* reserved */\n\t};\n\tstruct vdd_drive {\n\t\tu8 vid;\n\t\tunsigned voltage;\n\t};\n\n\tret = i2c_multiplexer_select_vid_channel(I2C_MUX_CH_VOL_MONITOR);\n\tif (ret) {\n\t\tdebug(\"VID: I2C failed to switch channel\\n\");\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n#if defined(CONFIG_VOL_MONITOR_IR36021_SET) || \\\n\tdefined(CONFIG_VOL_MONITOR_IR36021_READ)\n\tret = find_ir_chip_on_i2c();\n\tif (ret < 0) {\n\t\tprintf(\"VID: Could not find voltage regulator on I2C.\\n\");\n\t\tret = -1;\n\t\tgoto exit;\n\t} else {\n\t\ti2caddress = ret;\n\t\tdebug(\"VID: IR Chip found on I2C address 0x%02x\\n\", i2caddress);\n\t}\n\n\t/* check IR chip work on Intel mode*/\n#ifndef CONFIG_DM_I2C\n\tret = i2c_read(i2caddress,\n\t\t       IR36021_INTEL_MODE_OOFSET,\n\t\t       1, (void *)&buf, 1);\n#else\n\tstruct udevice *dev;\n\n\tret = i2c_get_chip_for_busnum(0, i2caddress, 1, &dev);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, IR36021_INTEL_MODE_OOFSET,\n\t\t\t\t  (void *)&buf, 1);\n#endif\n\tif (ret) {\n\t\tprintf(\"VID: failed to read IR chip mode.\\n\");\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\tif ((buf & IR36021_MODE_MASK) != IR36021_INTEL_MODE) {\n\t\tprintf(\"VID: IR Chip is not used in Intel mode.\\n\");\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n#endif\n\n\t/* get the voltage ID from fuse status register */\n\tfusesr = in_be32(&gur->dcfg_fusesr);\n\t/*\n\t * VID is used according to the table below\n\t *                ---------------------------------------\n\t *                |                DA_V                 |\n\t *                |-------------------------------------|\n\t *                | 5b00000 | 5b00001-5b11110 | 5b11111 |\n\t * ---------------+---------+-----------------+---------|\n\t * | D | 5b00000  | NO VID  | VID = DA_V      | NO VID  |\n\t * | A |----------+---------+-----------------+---------|\n\t * | _ | 5b00001  |VID =    | VID =           |VID =    |\n\t * | V |   ~      | DA_V_ALT|   DA_V_ALT      | DA_A_VLT|\n\t * | _ | 5b11110  |         |                 |         |\n\t * | A |----------+---------+-----------------+---------|\n\t * | L | 5b11111  | No VID  | VID = DA_V      | NO VID  |\n\t * | T |          |         |                 |         |\n\t * ------------------------------------------------------\n\t */\n#ifdef CONFIG_FSL_LSCH2\n\tvid = (fusesr >> FSL_CHASSIS2_DCFG_FUSESR_ALTVID_SHIFT) &\n\t\tFSL_CHASSIS2_DCFG_FUSESR_ALTVID_MASK;\n\tif ((vid == 0) || (vid == FSL_CHASSIS2_DCFG_FUSESR_ALTVID_MASK)) {\n\t\tvid = (fusesr >> FSL_CHASSIS2_DCFG_FUSESR_VID_SHIFT) &\n\t\t\tFSL_CHASSIS2_DCFG_FUSESR_VID_MASK;\n\t}\n#else\n\tvid = (fusesr >> FSL_CORENET_DCFG_FUSESR_ALTVID_SHIFT) &\n\t\tFSL_CORENET_DCFG_FUSESR_ALTVID_MASK;\n\tif ((vid == 0) || (vid == FSL_CORENET_DCFG_FUSESR_ALTVID_MASK)) {\n\t\tvid = (fusesr >> FSL_CORENET_DCFG_FUSESR_VID_SHIFT) &\n\t\t\tFSL_CORENET_DCFG_FUSESR_VID_MASK;\n\t}\n#endif\n\tvdd_target = vdd[vid];\n\n\t/* check override variable for overriding VDD */\n\tvdd_string = env_get(CONFIG_VID_FLS_ENV);\n\tif (vdd_override == 0 && vdd_string &&\n\t    !strict_strtoul(vdd_string, 10, &vdd_string_override))\n\t\tvdd_override = vdd_string_override;\n\tif (vdd_override >= VDD_MV_MIN && vdd_override <= VDD_MV_MAX) {\n\t\tvdd_target = vdd_override * 10; /* convert to 1/10 mV */\n\t\tdebug(\"VDD override is %lu\\n\", vdd_override);\n\t} else if (vdd_override != 0) {\n\t\tprintf(\"Invalid value.\\n\");\n\t}\n\tif (vdd_target == 0) {\n\t\tdebug(\"VID: VID not used\\n\");\n\t\tret = 0;\n\t\tgoto exit;\n\t} else {\n\t\t/* divide and round up by 10 to get a value in mV */\n\t\tvdd_target = DIV_ROUND_UP(vdd_target, 10);\n\t\tdebug(\"VID: vid = %d mV\\n\", vdd_target);\n\t}\n\n\t/*\n\t * Read voltage monitor to check real voltage.\n\t */\n\tvdd_last = read_voltage(i2caddress);\n\tif (vdd_last < 0) {\n\t\tprintf(\"VID: Couldn't read sensor abort VID adjustment\\n\");\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\tvdd_current = vdd_last;\n\tdebug(\"VID: Core voltage is currently at %d mV\\n\", vdd_last);\n\t/*\n\t  * Adjust voltage to at or one step above target.\n\t  * As measurements are less precise than setting the values\n\t  * we may run through dummy steps that cancel each other\n\t  * when stepping up and then down.\n\t  */\n\twhile (vdd_last > 0 &&\n\t       vdd_last < vdd_target) {\n\t\tvdd_current += IR_VDD_STEP_UP;\n\t\tvdd_last = set_voltage(i2caddress, vdd_current);\n\t}\n\twhile (vdd_last > 0 &&\n\t       vdd_last > vdd_target + (IR_VDD_STEP_DOWN - 1)) {\n\t\tvdd_current -= IR_VDD_STEP_DOWN;\n\t\tvdd_last = set_voltage(i2caddress, vdd_current);\n\t}\n\n\tif (vdd_last > 0)\n\t\tprintf(\"VID: Core voltage after adjustment is at %d mV\\n\",\n\t\t       vdd_last);\n\telse\n\t\tret = -1;\nexit:\n\tif (re_enable)\n\t\tenable_interrupts();\n\n\ti2c_multiplexer_select_vid_channel(I2C_MUX_CH_DEFAULT);\n\n\treturn ret;\n}", "path": "u-boot/board/freescale/common/vid.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/* this function sets the VDD and returns the value set */\n", "func_signal": "static int set_voltage_to_LTC(int i2caddress, int vdd)", "code": "{\n\tint ret, vdd_last, vdd_target = vdd;\n\tint count = 100, temp = 0;\n\tunsigned char value;\n\n\t/* Scale up to the LTC resolution is 1/4096V */\n\tvdd = (vdd * 4096) / 1000;\n\n\t/* 5-byte buffer which needs to be sent following the\n\t * PMBus command PAGE_PLUS_WRITE.\n\t */\n\tu8 buff[5] = {0x04, PWM_CHANNEL0, PMBUS_CMD_VOUT_COMMAND,\n\t\t\tvdd & 0xFF, (vdd & 0xFF00) >> 8};\n\n\t/* Write the desired voltage code to the regulator */\n#ifndef CONFIG_DM_I2C\n\t/* Check write protect state */\n\tret = i2c_read(I2C_VOL_MONITOR_ADDR,\n\t\t       PMBUS_CMD_WRITE_PROTECT, 1,\n\t\t       (void *)&value, sizeof(value));\n\tif (ret)\n\t\tgoto exit;\n\n\tif (value != EN_WRITE_ALL_CMD) {\n\t\tvalue = EN_WRITE_ALL_CMD;\n\t\tret = i2c_write(I2C_VOL_MONITOR_ADDR,\n\t\t\t\tPMBUS_CMD_WRITE_PROTECT, 1,\n\t\t\t\t(void *)&value, sizeof(value));\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = i2c_write(I2C_VOL_MONITOR_ADDR,\n\t\t\tPMBUS_CMD_PAGE_PLUS_WRITE, 1,\n\t\t\t(void *)&buff, sizeof(buff));\n#else\n\tstruct udevice *dev;\n\n\tret = i2c_get_chip_for_busnum(0, I2C_VOL_MONITOR_ADDR, 1, &dev);\n\tif (!ret) {\n\t\t/* Check write protect state */\n\t\tret = dm_i2c_read(dev,\n\t\t\t\t  PMBUS_CMD_WRITE_PROTECT,\n\t\t\t\t  (void *)&value, sizeof(value));\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tif (value != EN_WRITE_ALL_CMD) {\n\t\t\tvalue = EN_WRITE_ALL_CMD;\n\t\t\tret = dm_i2c_write(dev,\n\t\t\t\t\t   PMBUS_CMD_WRITE_PROTECT,\n\t\t\t\t\t   (void *)&value, sizeof(value));\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\tret = dm_i2c_write(dev, PMBUS_CMD_PAGE_PLUS_WRITE,\n\t\t\t\t   (void *)&buff, sizeof(buff));\n\t}\n#endif\nexit:\n\tif (ret) {\n\t\tprintf(\"VID: I2C failed to write to the volatge regulator\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Wait for the volatge to get to the desired value */\n\tdo {\n\t\tvdd_last = read_voltage_from_LTC(i2caddress);\n\t\tif (vdd_last < 0) {\n\t\t\tprintf(\"VID: Couldn't read sensor abort VID adjust\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tcount--;\n\t\ttemp = vdd_last - vdd_target;\n\t} while ((abs(temp) > 2)  && (count > 0));\n\n\treturn vdd_last;\n}", "path": "u-boot/board/freescale/common/vid.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Reset MAC\n */\n", "func_signal": "static void ftgmac100_reset(struct ftgmac100_data *priv)", "code": "{\n\tstruct ftgmac100 *ftgmac100 = priv->iobase;\n\n\tdebug(\"%s()\\n\", __func__);\n\n\tsetbits_le32(&ftgmac100->maccr, FTGMAC100_MACCR_SW_RST);\n\n\twhile (readl(&ftgmac100->maccr) & FTGMAC100_MACCR_SW_RST)\n\t\t;\n}", "path": "u-boot/drivers/net/ftgmac100.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * We need to calculate how long before the voltage stops to drop\n * or increase. It returns with the loop count. Each loop takes\n * several readings (WAIT_FOR_ADC)\n */\n", "func_signal": "static int wait_for_new_voltage(int vdd, int i2caddress)", "code": "{\n\tint timeout, vdd_current;\n\n\tvdd_current = read_voltage(i2caddress);\n\t/* wait until voltage starts to reach the target. Voltage slew\n\t * rates by typical regulators will always lead to stable readings\n\t * within each fairly long ADC interval in comparison to the\n\t * intended voltage delta change until the target voltage is\n\t * reached. The fairly small voltage delta change to any target\n\t * VID voltage also means that this function will always complete\n\t * within few iterations. If the timeout was ever reached, it would\n\t * point to a serious failure in the regulator system.\n\t */\n\tfor (timeout = 0;\n\t     abs(vdd - vdd_current) > (IR_VDD_STEP_UP + IR_VDD_STEP_DOWN) &&\n\t     timeout < MAX_LOOP_WAIT_NEW_VOL; timeout++) {\n\t\tvdd_current = read_voltage(i2caddress);\n\t}\n\tif (timeout >= MAX_LOOP_WAIT_NEW_VOL) {\n\t\tprintf(\"VID: Voltage adjustment timeout\\n\");\n\t\treturn -1;\n\t}\n\treturn timeout;\n}", "path": "u-boot/board/freescale/common/vid.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/* Set the voltage to the IR chip */\n", "func_signal": "static int set_voltage_to_IR(int i2caddress, int vdd)", "code": "{\n\tint wait, vdd_last;\n\tint ret;\n\tu8 vid;\n\n\t/* Compensate for a board specific voltage drop between regulator and\n\t * SoC before converting into an IR VID value\n\t */\n\tvdd += board_vdd_drop_compensation();\n#ifdef CONFIG_FSL_LSCH2\n\tvid = DIV_ROUND_UP(vdd - 265, 5);\n#else\n\tvid = DIV_ROUND_UP(vdd - 245, 5);\n#endif\n\n#ifndef CONFIG_DM_I2C\n\tret = i2c_write(i2caddress, IR36021_LOOP1_MANUAL_ID_OFFSET,\n\t\t\t1, (void *)&vid, sizeof(vid));\n#else\n\tstruct udevice *dev;\n\n\tret = i2c_get_chip_for_busnum(0, i2caddress, 1, &dev);\n\tif (!ret)\n\t\tret = dm_i2c_write(dev, IR36021_LOOP1_MANUAL_ID_OFFSET,\n\t\t\t\t   (void *)&vid, sizeof(vid));\n\n#endif\n\tif (ret) {\n\t\tprintf(\"VID: failed to write VID\\n\");\n\t\treturn -1;\n\t}\n\twait = wait_for_new_voltage(vdd, i2caddress);\n\tif (wait < 0)\n\t\treturn -1;\n\tdebug(\"VID: Waited %d us\\n\", wait * NUM_READINGS * WAIT_FOR_ADC);\n\n\tvdd_last = wait_for_voltage_stable(i2caddress);\n\tif (vdd_last < 0)\n\t\treturn -1;\n\tdebug(\"VID: Current voltage is %d mV\\n\", vdd_last);\n\treturn vdd_last;\n}", "path": "u-boot/board/freescale/common/vid.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Get a data block via Ethernet\n */\n", "func_signal": "static int ftgmac100_recv(struct udevice *dev, int flags, uchar **packetp)", "code": "{\n\tstruct ftgmac100_data *priv = dev_get_priv(dev);\n\tstruct ftgmac100_rxdes *curr_des = &priv->rxdes[priv->rx_index];\n\tunsigned short rxlen;\n\tulong des_start = ((ulong)curr_des) & ~(ARCH_DMA_MINALIGN - 1);\n\tulong des_end = des_start +\n\t\troundup(sizeof(*curr_des), ARCH_DMA_MINALIGN);\n\tulong data_start = curr_des->rxdes3;\n\tulong data_end;\n\n\tinvalidate_dcache_range(des_start, des_end);\n\n\tif (!(curr_des->rxdes0 & FTGMAC100_RXDES0_RXPKT_RDY))\n\t\treturn -EAGAIN;\n\n\tif (curr_des->rxdes0 & (FTGMAC100_RXDES0_RX_ERR |\n\t\t\t\tFTGMAC100_RXDES0_CRC_ERR |\n\t\t\t\tFTGMAC100_RXDES0_FTL |\n\t\t\t\tFTGMAC100_RXDES0_RUNT |\n\t\t\t\tFTGMAC100_RXDES0_RX_ODD_NB)) {\n\t\treturn -EAGAIN;\n\t}\n\n\trxlen = FTGMAC100_RXDES0_VDBC(curr_des->rxdes0);\n\n\tdebug(\"%s(): RX buffer %d, %x received\\n\",\n\t       __func__, priv->rx_index, rxlen);\n\n\t/* Invalidate received data */\n\tdata_end = data_start + roundup(rxlen, ARCH_DMA_MINALIGN);\n\tinvalidate_dcache_range(data_start, data_end);\n\t*packetp = (uchar *)data_start;\n\n\treturn rxlen;\n}", "path": "u-boot/drivers/net/ftgmac100.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * this function keeps reading the voltage until it is stable or until the\n * timeout expires\n */\n", "func_signal": "static int wait_for_voltage_stable(int i2caddress)", "code": "{\n\tint timeout, vdd_current, vdd;\n\n\tvdd = read_voltage(i2caddress);\n\tudelay(NUM_READINGS * WAIT_FOR_ADC);\n\n\t/* wait until voltage is stable */\n\tvdd_current = read_voltage(i2caddress);\n\t/* The maximum timeout is\n\t * MAX_LOOP_WAIT_VOL_STABLE * NUM_READINGS * WAIT_FOR_ADC\n\t */\n\tfor (timeout = MAX_LOOP_WAIT_VOL_STABLE;\n\t     abs(vdd - vdd_current) > ADC_MIN_ACCURACY &&\n\t     timeout > 0; timeout--) {\n\t\tvdd = vdd_current;\n\t\tudelay(NUM_READINGS * WAIT_FOR_ADC);\n\t\tvdd_current = read_voltage(i2caddress);\n\t}\n\tif (timeout == 0)\n\t\treturn -1;\n\treturn vdd_current;\n}", "path": "u-boot/board/freescale/common/vid.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Breath some life into the CPU...\n *\n * Set up the memory map,\n * initialize a bunch of registers,\n * initialize the UPM's\n */\n", "func_signal": "void cpu_init_f(void)", "code": "{\n#ifndef CONFIG_WATCHDOG\n\t/* disable watchdog if we aren't using it */\n\tMCFWTM_WCR = 0;\n#endif\n\n#ifndef CONFIG_MONITOR_IS_IN_RAM\n\t/* Set speed /PLL */\n\tMCFCLOCK_SYNCR =\n\t    MCFCLOCK_SYNCR_MFD(CONFIG_SYS_MFD) |\n\t    MCFCLOCK_SYNCR_RFD(CONFIG_SYS_RFD);\n\twhile (!(MCFCLOCK_SYNSR & MCFCLOCK_SYNSR_LOCK)) ;\n\n\tMCFGPIO_PBCDPAR = 0xc0;\n\n\t/* Set up the GPIO ports */\n#ifdef CONFIG_SYS_PEPAR\n\tMCFGPIO_PEPAR = CONFIG_SYS_PEPAR;\n#endif\n#ifdef\tCONFIG_SYS_PFPAR\n\tMCFGPIO_PFPAR = CONFIG_SYS_PFPAR;\n#endif\n#ifdef CONFIG_SYS_PJPAR\n\tMCFGPIO_PJPAR = CONFIG_SYS_PJPAR;\n#endif\n#ifdef CONFIG_SYS_PSDPAR\n\tMCFGPIO_PSDPAR = CONFIG_SYS_PSDPAR;\n#endif\n#ifdef CONFIG_SYS_PASPAR\n\tMCFGPIO_PASPAR = CONFIG_SYS_PASPAR;\n#endif\n#ifdef CONFIG_SYS_PEHLPAR\n\tMCFGPIO_PEHLPAR = CONFIG_SYS_PEHLPAR;\n#endif\n#ifdef CONFIG_SYS_PQSPAR\n\tMCFGPIO_PQSPAR = CONFIG_SYS_PQSPAR;\n#endif\n#ifdef CONFIG_SYS_PTCPAR\n\tMCFGPIO_PTCPAR = CONFIG_SYS_PTCPAR;\n#endif\n#if defined(CONFIG_SYS_PORTTC)\n\tMCFGPIO_PORTTC = CONFIG_SYS_PORTTC;\n#endif\n#if defined(CONFIG_SYS_DDRTC)\n\tMCFGPIO_DDRTC  = CONFIG_SYS_DDRTC;\n#endif\n#ifdef CONFIG_SYS_PTDPAR\n\tMCFGPIO_PTDPAR = CONFIG_SYS_PTDPAR;\n#endif\n#ifdef CONFIG_SYS_PUAPAR\n\tMCFGPIO_PUAPAR = CONFIG_SYS_PUAPAR;\n#endif\n\n#if defined(CONFIG_SYS_DDRD)\n\tMCFGPIO_DDRD = CONFIG_SYS_DDRD;\n#endif\n#ifdef CONFIG_SYS_DDRUA\n\tMCFGPIO_DDRUA = CONFIG_SYS_DDRUA;\n#endif\n\n\t/* FlexBus Chipselect */\n\tinit_fbcs();\n\n#endif\t\t\t\t/* CONFIG_MONITOR_IS_IN_RAM */\n\n\t/* defer enabling cache until boot (see do_go) */\n\t/* icache_enable(); */\n}", "path": "u-boot/arch/m68k/cpu/mcf52x2/cpu_init.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/* read the current value of the LTC Regulator Voltage */\n", "func_signal": "static int read_voltage_from_LTC(int i2caddress)", "code": "{\n\tint  ret, vcode = 0;\n\tu8 chan = PWM_CHANNEL0;\n\n#ifndef CONFIG_DM_I2C\n\t/* select the PAGE 0 using PMBus commands PAGE for VDD*/\n\tret = i2c_write(I2C_VOL_MONITOR_ADDR,\n\t\t\tPMBUS_CMD_PAGE, 1, &chan, 1);\n#else\n\tstruct udevice *dev;\n\n\tret = i2c_get_chip_for_busnum(0, I2C_VOL_MONITOR_ADDR, 1, &dev);\n\tif (!ret)\n\t\tret = dm_i2c_write(dev, PMBUS_CMD_PAGE, &chan, 1);\n#endif\n\tif (ret) {\n\t\tprintf(\"VID: failed to select VDD Page 0\\n\");\n\t\treturn ret;\n\t}\n\n#ifndef CONFIG_DM_I2C\n\t/*read the output voltage using PMBus command READ_VOUT*/\n\tret = i2c_read(I2C_VOL_MONITOR_ADDR,\n\t\t       PMBUS_CMD_READ_VOUT, 1, (void *)&vcode, 2);\n#else\n\tret = dm_i2c_read(dev, PMBUS_CMD_READ_VOUT, (void *)&vcode, 2);\n\tif (ret) {\n\t\tprintf(\"VID: failed to read the volatge\\n\");\n\t\treturn ret;\n\t}\n#endif\n\tif (ret) {\n\t\tprintf(\"VID: failed to read the volatge\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Scale down to the real mV as LTC resolution is 1/4096V,rounding up */\n\tvcode = DIV_ROUND_UP(vcode * 1000, 4096);\n\n\treturn vcode;\n}", "path": "u-boot/board/freescale/common/vid.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Set MAC address\n */\n", "func_signal": "static int ftgmac100_set_mac(struct ftgmac100_data *priv,\n\t\t\t     const unsigned char *mac)", "code": "{\n\tstruct ftgmac100 *ftgmac100 = priv->iobase;\n\tunsigned int maddr = mac[0] << 8 | mac[1];\n\tunsigned int laddr = mac[2] << 24 | mac[3] << 16 | mac[4] << 8 | mac[5];\n\n\tdebug(\"%s(%x %x)\\n\", __func__, maddr, laddr);\n\n\twritel(maddr, &ftgmac100->mac_madr);\n\twritel(laddr, &ftgmac100->mac_ladr);\n\n\treturn 0;\n}", "path": "u-boot/drivers/net/ftgmac100.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Breath some life into the CPU...\n *\n * Set up the memory map,\n * initialize a bunch of registers,\n * initialize the UPM's\n */\n", "func_signal": "void cpu_init_f(void)", "code": "{\n\tmbar_writeByte(MCFSIM_MPARK, 0x40);\t/* 5249 Internal Core takes priority over DMA */\n\tmbar_writeByte(MCFSIM_SYPCR, 0x00);\n\tmbar_writeByte(MCFSIM_SWIVR, 0x0f);\n\tmbar_writeByte(MCFSIM_SWSR, 0x00);\n\tmbar_writeByte(MCFSIM_SWDICR, 0x00);\n\tmbar_writeByte(MCFSIM_TIMER1ICR, 0x00);\n\tmbar_writeByte(MCFSIM_TIMER2ICR, 0x88);\n\tmbar_writeByte(MCFSIM_I2CICR, 0x00);\n\tmbar_writeByte(MCFSIM_UART1ICR, 0x00);\n\tmbar_writeByte(MCFSIM_UART2ICR, 0x00);\n\tmbar_writeByte(MCFSIM_ICR6, 0x00);\n\tmbar_writeByte(MCFSIM_ICR7, 0x00);\n\tmbar_writeByte(MCFSIM_ICR8, 0x00);\n\tmbar_writeByte(MCFSIM_ICR9, 0x00);\n\tmbar_writeByte(MCFSIM_QSPIICR, 0x00);\n\n\tmbar2_writeLong(MCFSIM_GPIO_INT_EN, 0x00000080);\n\tmbar2_writeByte(MCFSIM_INTBASE, 0x40);\t/* Base interrupts at 64 */\n\tmbar2_writeByte(MCFSIM_SPURVEC, 0x00);\n\n\t/*mbar2_writeLong(MCFSIM_IDECONFIG1, 0x00000020); */ /* Enable a 1 cycle pre-drive cycle on CS1 */\n\n\t/* FlexBus Chipselect */\n\tinit_fbcs();\n\n#ifdef CONFIG_SYS_I2C_FSL\n\tCONFIG_SYS_I2C_PINMUX_REG =\n\t    CONFIG_SYS_I2C_PINMUX_REG & CONFIG_SYS_I2C_PINMUX_CLR;\n\tCONFIG_SYS_I2C_PINMUX_REG |= CONFIG_SYS_I2C_PINMUX_SET;\n#ifdef CONFIG_SYS_I2C2_OFFSET\n\tCONFIG_SYS_I2C2_PINMUX_REG &= CONFIG_SYS_I2C2_PINMUX_CLR;\n\tCONFIG_SYS_I2C2_PINMUX_REG |= CONFIG_SYS_I2C2_PINMUX_SET;\n#endif\n#endif\n\n\t/* enable instruction cache now */\n\ticache_enable();\n}", "path": "u-boot/arch/m68k/cpu/mcf52x2/cpu_init.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Get the i2c address configuration for the IR regulator chip\n *\n * There are some variance in the RDB HW regarding the I2C address configuration\n * for the IR regulator chip, which is likely a problem of external resistor\n * accuracy. So we just check each address in a hopefully non-intrusive mode\n * and use the first one that seems to work\n *\n * The IR chip can show up under the following addresses:\n * 0x08 (Verified on T1040RDB-PA,T4240RDB-PB,X-T4240RDB-16GPA)\n * 0x09 (Verified on T1040RDB-PA)\n * 0x38 (Verified on T2080QDS, T2081QDS, T4240RDB)\n */\n", "func_signal": "static int find_ir_chip_on_i2c(void)", "code": "{\n\tint i2caddress;\n\tint ret;\n\tu8 byte;\n\tint i;\n\tconst int ir_i2c_addr[] = {0x38, 0x08, 0x09};\n#ifdef CONFIG_DM_I2C\n\tstruct udevice *dev;\n#endif\n\n\t/* Check all the address */\n\tfor (i = 0; i < (sizeof(ir_i2c_addr)/sizeof(ir_i2c_addr[0])); i++) {\n\t\ti2caddress = ir_i2c_addr[i];\n#ifndef CONFIG_DM_I2C\n\t\tret = i2c_read(i2caddress,\n\t\t\t       IR36021_MFR_ID_OFFSET, 1, (void *)&byte,\n\t\t\t       sizeof(byte));\n#else\n\t\tret = i2c_get_chip_for_busnum(0, i2caddress, 1, &dev);\n\t\tif (!ret)\n\t\t\tret = dm_i2c_read(dev, IR36021_MFR_ID_OFFSET,\n\t\t\t\t\t  (void *)&byte, sizeof(byte));\n#endif\n\t\tif ((ret >= 0) && (byte == IR36021_MFR_ID))\n\t\t\treturn i2caddress;\n\t}\n\treturn -1;\n}", "path": "u-boot/board/freescale/common/vid.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Breath some life into the CPU...\n *\n * Set up the memory map,\n * initialize a bunch of registers,\n * initialize the UPM's\n */\n", "func_signal": "void cpu_init_f(void)", "code": "{\n\t/*\n\t *  NOTE: by setting the GPIO_FUNCTION registers, we ensure that the UART pins\n\t *        (UART0: gpio 30,27, UART1: gpio 31, 28) will be used as UART pins\n\t *        which is their primary function.\n\t *        ~Jeremy\n\t */\n\tmbar2_writeLong(MCFSIM_GPIO_FUNC, CONFIG_SYS_GPIO_FUNC);\n\tmbar2_writeLong(MCFSIM_GPIO1_FUNC, CONFIG_SYS_GPIO1_FUNC);\n\tmbar2_writeLong(MCFSIM_GPIO_EN, CONFIG_SYS_GPIO_EN);\n\tmbar2_writeLong(MCFSIM_GPIO1_EN, CONFIG_SYS_GPIO1_EN);\n\tmbar2_writeLong(MCFSIM_GPIO_OUT, CONFIG_SYS_GPIO_OUT);\n\tmbar2_writeLong(MCFSIM_GPIO1_OUT, CONFIG_SYS_GPIO1_OUT);\n\n\t/*\n\t *  dBug Compliance:\n\t *    You can verify these values by using dBug's 'ird'\n\t *    (Internal Register Display) command\n\t *    ~Jeremy\n\t *\n\t */\n\tmbar_writeByte(MCFSIM_MPARK, 0x30);\t/* 5249 Internal Core takes priority over DMA */\n\tmbar_writeByte(MCFSIM_SYPCR, 0x00);\n\tmbar_writeByte(MCFSIM_SWIVR, 0x0f);\n\tmbar_writeByte(MCFSIM_SWSR, 0x00);\n\tmbar_writeLong(MCFSIM_IMR, 0xfffffbff);\n\tmbar_writeByte(MCFSIM_SWDICR, 0x00);\n\tmbar_writeByte(MCFSIM_TIMER1ICR, 0x00);\n\tmbar_writeByte(MCFSIM_TIMER2ICR, 0x88);\n\tmbar_writeByte(MCFSIM_I2CICR, 0x00);\n\tmbar_writeByte(MCFSIM_UART1ICR, 0x00);\n\tmbar_writeByte(MCFSIM_UART2ICR, 0x00);\n\tmbar_writeByte(MCFSIM_ICR6, 0x00);\n\tmbar_writeByte(MCFSIM_ICR7, 0x00);\n\tmbar_writeByte(MCFSIM_ICR8, 0x00);\n\tmbar_writeByte(MCFSIM_ICR9, 0x00);\n\tmbar_writeByte(MCFSIM_QSPIICR, 0x00);\n\n\tmbar2_writeLong(MCFSIM_GPIO_INT_EN, 0x00000080);\n\tmbar2_writeByte(MCFSIM_INTBASE, 0x40);\t/* Base interrupts at 64 */\n\tmbar2_writeByte(MCFSIM_SPURVEC, 0x00);\n\tmbar2_writeLong(MCFSIM_IDECONFIG1, 0x00000020);\t/* Enable a 1 cycle pre-drive cycle on CS1 */\n\n\t/* Setup interrupt priorities for gpio7 */\n\t/* mbar2_writeLong(MCFSIM_INTLEV5, 0x70000000); */\n\n\t/* IDE Config registers */\n\tmbar2_writeLong(MCFSIM_IDECONFIG1, 0x00000020);\n\tmbar2_writeLong(MCFSIM_IDECONFIG2, 0x00000000);\n\n\t/* FlexBus Chipselect */\n\tinit_fbcs();\n\n\t/* enable instruction cache now */\n\ticache_enable();\n}", "path": "u-boot/arch/m68k/cpu/mcf52x2/cpu_init.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Send a data block via Ethernet\n */\n", "func_signal": "static int ftgmac100_send(struct udevice *dev, void *packet, int length)", "code": "{\n\tstruct ftgmac100_data *priv = dev_get_priv(dev);\n\tstruct ftgmac100 *ftgmac100 = priv->iobase;\n\tstruct ftgmac100_txdes *curr_des = &priv->txdes[priv->tx_index];\n\tulong des_start = ((ulong)curr_des) & ~(ARCH_DMA_MINALIGN - 1);\n\tulong des_end = des_start +\n\t\troundup(sizeof(*curr_des), ARCH_DMA_MINALIGN);\n\tulong data_start;\n\tulong data_end;\n\tint rc;\n\n\tinvalidate_dcache_range(des_start, des_end);\n\n\tif (curr_des->txdes0 & FTGMAC100_TXDES0_TXDMA_OWN) {\n\t\tdev_err(dev, \"no TX descriptor available\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tdebug(\"%s(%x, %x)\\n\", __func__, (int)packet, length);\n\n\tlength = (length < ETH_ZLEN) ? ETH_ZLEN : length;\n\n\tcurr_des->txdes3 = (unsigned int)packet;\n\n\t/* Flush data to be sent */\n\tdata_start = curr_des->txdes3;\n\tdata_end = data_start + roundup(length, ARCH_DMA_MINALIGN);\n\tflush_dcache_range(data_start, data_end);\n\n\t/* Only one segment on TXBUF */\n\tcurr_des->txdes0 &= priv->txdes0_edotr_mask;\n\tcurr_des->txdes0 |= FTGMAC100_TXDES0_FTS |\n\t\t\t    FTGMAC100_TXDES0_LTS |\n\t\t\t    FTGMAC100_TXDES0_TXBUF_SIZE(length) |\n\t\t\t    FTGMAC100_TXDES0_TXDMA_OWN ;\n\n\t/* Flush modified buffer descriptor */\n\tflush_dcache_range(des_start, des_end);\n\n\t/* Start transmit */\n\twritel(1, &ftgmac100->txpd);\n\n\trc = wait_for_bit_ftgmac100_txdone(curr_des,\n\t\t\t\t\t   FTGMAC100_TXDES0_TXDMA_OWN, false,\n\t\t\t\t\t   FTGMAC100_TX_TIMEOUT_MS, true);\n\tif (rc)\n\t\treturn rc;\n\n\tdebug(\"%s(): packet sent\\n\", __func__);\n\n\t/* Move to next descriptor */\n\tpriv->tx_index = (priv->tx_index + 1) % PKTBUFSTX;\n\n\treturn 0;\n}", "path": "u-boot/drivers/net/ftgmac100.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/* Now implement the generic default functions */\n", "func_signal": "__weak void bootcount_store(ulong a)", "code": "{\n\tvoid *reg = (void *)CONFIG_SYS_BOOTCOUNT_ADDR;\n\tuintptr_t flush_start = rounddown(CONFIG_SYS_BOOTCOUNT_ADDR,\n\t\t\t\t\t  CONFIG_SYS_CACHELINE_SIZE);\n\tuintptr_t flush_end;\n\n#if defined(CONFIG_SYS_BOOTCOUNT_SINGLEWORD)\n\traw_bootcount_store(reg, (CONFIG_SYS_BOOTCOUNT_MAGIC & 0xffff0000) | a);\n\n\tflush_end = roundup(CONFIG_SYS_BOOTCOUNT_ADDR + 4,\n\t\t\t    CONFIG_SYS_CACHELINE_SIZE);\n#else\n\traw_bootcount_store(reg, a);\n\traw_bootcount_store(reg + 4, CONFIG_SYS_BOOTCOUNT_MAGIC);\n\n\tflush_end = roundup(CONFIG_SYS_BOOTCOUNT_ADDR + 8,\n\t\t\t    CONFIG_SYS_CACHELINE_SIZE);\n#endif /* defined(CONFIG_SYS_BOOTCOUNT_SINGLEWORD */\n\tflush_dcache_range(flush_start, flush_end);\n}", "path": "u-boot/drivers/bootcount/bootcount.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * disable transmitter, receiver\n */\n", "func_signal": "static void ftgmac100_stop(struct udevice *dev)", "code": "{\n\tstruct ftgmac100_data *priv = dev_get_priv(dev);\n\tstruct ftgmac100 *ftgmac100 = priv->iobase;\n\n\tdebug(\"%s()\\n\", __func__);\n\n\twritel(0, &ftgmac100->maccr);\n\n\tphy_shutdown(priv->phydev);\n}", "path": "u-boot/drivers/net/ftgmac100.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * Breath some life into the CPU...\n *\n * Set up the memory map,\n * initialize a bunch of registers,\n * initialize the UPM's\n */\n", "func_signal": "void cpu_init_f(void)", "code": "{\n\t/* if we come from RAM we assume the CPU is\n\t * already initialized.\n\t */\n#ifndef CONFIG_MONITOR_IS_IN_RAM\n\tsysctrl_t *sysctrl = (sysctrl_t *) (CONFIG_SYS_MBAR);\n\tgpio_t *gpio = (gpio_t *) (MMAP_GPIO);\n\tcsctrl_t *csctrl = (csctrl_t *) (MMAP_FBCS);\n\n\tout_be16(&sysctrl->sc_scr, CONFIG_SYS_SCR);\n\tout_be16(&sysctrl->sc_spr, CONFIG_SYS_SPR);\n\n\t/* Setup Ports: */\n\tout_be32(&gpio->gpio_pacnt, CONFIG_SYS_PACNT);\n\tout_be16(&gpio->gpio_paddr, CONFIG_SYS_PADDR);\n\tout_be16(&gpio->gpio_padat, CONFIG_SYS_PADAT);\n\tout_be32(&gpio->gpio_pbcnt, CONFIG_SYS_PBCNT);\n\tout_be16(&gpio->gpio_pbddr, CONFIG_SYS_PBDDR);\n\tout_be16(&gpio->gpio_pbdat, CONFIG_SYS_PBDAT);\n\tout_be32(&gpio->gpio_pdcnt, CONFIG_SYS_PDCNT);\n\n\t/* Memory Controller: */\n\tout_be32(&csctrl->cs_br0, CONFIG_SYS_BR0_PRELIM);\n\tout_be32(&csctrl->cs_or0, CONFIG_SYS_OR0_PRELIM);\n\n#if (defined(CONFIG_SYS_OR1_PRELIM) && defined(CONFIG_SYS_BR1_PRELIM))\n\tout_be32(&csctrl->cs_br1, CONFIG_SYS_BR1_PRELIM);\n\tout_be32(&csctrl->cs_or1, CONFIG_SYS_OR1_PRELIM);\n#endif\n\n#if defined(CONFIG_SYS_OR2_PRELIM) && defined(CONFIG_SYS_BR2_PRELIM)\n\tout_be32(&csctrl->cs_br2, CONFIG_SYS_BR2_PRELIM);\n\tout_be32(&csctrl->cs_or2, CONFIG_SYS_OR2_PRELIM);\n#endif\n\n#if defined(CONFIG_SYS_OR3_PRELIM) && defined(CONFIG_SYS_BR3_PRELIM)\n\tout_be32(&csctrl->cs_br3, CONFIG_SYS_BR3_PRELIM);\n\tout_be32(&csctrl->cs_or3, CONFIG_SYS_OR3_PRELIM);\n#endif\n\n#if defined(CONFIG_SYS_OR4_PRELIM) && defined(CONFIG_SYS_BR4_PRELIM)\n\tout_be32(&csctrl->cs_br4, CONFIG_SYS_BR4_PRELIM);\n\tout_be32(&csctrl->cs_or4, CONFIG_SYS_OR4_PRELIM);\n#endif\n\n#if defined(CONFIG_SYS_OR5_PRELIM) && defined(CONFIG_SYS_BR5_PRELIM)\n\tout_be32(&csctrl->cs_br5, CONFIG_SYS_BR5_PRELIM);\n\tout_be32(&csctrl->cs_or5, CONFIG_SYS_OR5_PRELIM);\n#endif\n\n#if defined(CONFIG_SYS_OR6_PRELIM) && defined(CONFIG_SYS_BR6_PRELIM)\n\tout_be32(&csctrl->cs_br6, CONFIG_SYS_BR6_PRELIM);\n\tout_be32(&csctrl->cs_or6, CONFIG_SYS_OR6_PRELIM);\n#endif\n\n#if defined(CONFIG_SYS_OR7_PRELIM) && defined(CONFIG_SYS_BR7_PRELIM)\n\tout_be32(&csctrl->cs_br7, CONFIG_SYS_BR7_PRELIM);\n\tout_be32(&csctrl->cs_or7, CONFIG_SYS_OR7_PRELIM);\n#endif\n\n#endif\t\t\t\t/* #ifndef CONFIG_MONITOR_IS_IN_RAM */\n\n\t/* enable instruction cache now */\n\ticache_enable();\n\n}", "path": "u-boot/arch/m68k/cpu/mcf52x2/cpu_init.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/* Only 5272 Flexbus chipselect is different from the rest */\n", "func_signal": "void init_fbcs(void)", "code": "{\n\tfbcs_t *fbcs = (fbcs_t *) (MMAP_FBCS);\n\n#if (defined(CONFIG_SYS_CS0_BASE) && defined(CONFIG_SYS_CS0_MASK) \\\n     && defined(CONFIG_SYS_CS0_CTRL))\n\tout_be32(&fbcs->csar0, CONFIG_SYS_CS0_BASE);\n\tout_be32(&fbcs->cscr0, CONFIG_SYS_CS0_CTRL);\n\tout_be32(&fbcs->csmr0, CONFIG_SYS_CS0_MASK);\n#else\n#warning \"Chip Select 0 are not initialized/used\"\n#endif\n#if (defined(CONFIG_SYS_CS1_BASE) && defined(CONFIG_SYS_CS1_MASK) \\\n     && defined(CONFIG_SYS_CS1_CTRL))\n\tout_be32(&fbcs->csar1, CONFIG_SYS_CS1_BASE);\n\tout_be32(&fbcs->cscr1, CONFIG_SYS_CS1_CTRL);\n\tout_be32(&fbcs->csmr1, CONFIG_SYS_CS1_MASK);\n#endif\n#if (defined(CONFIG_SYS_CS2_BASE) && defined(CONFIG_SYS_CS2_MASK) \\\n     && defined(CONFIG_SYS_CS2_CTRL))\n\tout_be32(&fbcs->csar2, CONFIG_SYS_CS2_BASE);\n\tout_be32(&fbcs->cscr2, CONFIG_SYS_CS2_CTRL);\n\tout_be32(&fbcs->csmr2, CONFIG_SYS_CS2_MASK);\n#endif\n#if (defined(CONFIG_SYS_CS3_BASE) && defined(CONFIG_SYS_CS3_MASK) \\\n     && defined(CONFIG_SYS_CS3_CTRL))\n\tout_be32(&fbcs->csar3, CONFIG_SYS_CS3_BASE);\n\tout_be32(&fbcs->cscr3, CONFIG_SYS_CS3_CTRL);\n\tout_be32(&fbcs->csmr3, CONFIG_SYS_CS3_MASK);\n#endif\n#if (defined(CONFIG_SYS_CS4_BASE) && defined(CONFIG_SYS_CS4_MASK) \\\n     && defined(CONFIG_SYS_CS4_CTRL))\n\tout_be32(&fbcs->csar4, CONFIG_SYS_CS4_BASE);\n\tout_be32(&fbcs->cscr4, CONFIG_SYS_CS4_CTRL);\n\tout_be32(&fbcs->csmr4, CONFIG_SYS_CS4_MASK);\n#endif\n#if (defined(CONFIG_SYS_CS5_BASE) && defined(CONFIG_SYS_CS5_MASK) \\\n     && defined(CONFIG_SYS_CS5_CTRL))\n\tout_be32(&fbcs->csar5, CONFIG_SYS_CS5_BASE);\n\tout_be32(&fbcs->cscr5, CONFIG_SYS_CS5_CTRL);\n\tout_be32(&fbcs->csmr5, CONFIG_SYS_CS5_MASK);\n#endif\n#if (defined(CONFIG_SYS_CS6_BASE) && defined(CONFIG_SYS_CS6_MASK) \\\n     && defined(CONFIG_SYS_CS6_CTRL))\n\tout_be32(&fbcs->csar6, CONFIG_SYS_CS6_BASE);\n\tout_be32(&fbcs->cscr6, CONFIG_SYS_CS6_CTRL);\n\tout_be32(&fbcs->csmr6, CONFIG_SYS_CS6_MASK);\n#endif\n#if (defined(CONFIG_SYS_CS7_BASE) && defined(CONFIG_SYS_CS7_MASK) \\\n     && defined(CONFIG_SYS_CS7_CTRL))\n\tout_be32(&fbcs->csar7, CONFIG_SYS_CS7_BASE);\n\tout_be32(&fbcs->cscr7, CONFIG_SYS_CS7_CTRL);\n\tout_be32(&fbcs->csmr7, CONFIG_SYS_CS7_MASK);\n#endif\n}", "path": "u-boot/arch/m68k/cpu/mcf52x2/cpu_init.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "/*\n * struct mii_bus functions\n */\n", "func_signal": "static int ftgmac100_mdio_read(struct mii_dev *bus, int phy_addr, int dev_addr,\n\t\t\t       int reg_addr)", "code": "{\n\tstruct ftgmac100_data *priv = bus->priv;\n\tstruct ftgmac100 *ftgmac100 = priv->iobase;\n\tint phycr;\n\tint data;\n\tint ret;\n\n\tphycr = FTGMAC100_PHYCR_MDC_CYCTHR(MDC_CYCTHR) |\n\t\tFTGMAC100_PHYCR_PHYAD(phy_addr) |\n\t\tFTGMAC100_PHYCR_REGAD(reg_addr) |\n\t\tFTGMAC100_PHYCR_MIIRD;\n\twritel(phycr, &ftgmac100->phycr);\n\n\tret = readl_poll_timeout(&ftgmac100->phycr, phycr,\n\t\t\t\t !(phycr & FTGMAC100_PHYCR_MIIRD),\n\t\t\t\t FTGMAC100_MDIO_TIMEOUT_USEC);\n\tif (ret) {\n\t\tpr_err(\"%s: mdio read failed (phy:%d reg:%x)\\n\",\n\t\t       priv->phydev->dev->name, phy_addr, reg_addr);\n\t\treturn ret;\n\t}\n\n\tdata = readl(&ftgmac100->phydata);\n\n\treturn FTGMAC100_PHYDATA_MIIRDATA(data);\n}", "path": "u-boot/drivers/net/ftgmac100.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "u-boot/u-boot", "stars": 3493, "license": "None", "language": "c", "size": 277954}
{"docstring": "// Code to check the host state between vmluanch and vmexit\n", "func_signal": "static uint32_t get_seg_avail(uint32_t seg)", "code": "{\n    mword gdtr_base;\n    struct seg_desc_t *sd;\n\n    gdtr_base = get_kernel_gdtr_base();\n    sd = (struct seg_desc_t *)gdtr_base + (seg >> 3);\n\n    return sd->_avl;\n}", "path": "haxm/core/vcpu.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * Clear the pending irqs after injection.\n */\n", "func_signal": "static void vcpu_ack_intr(struct vcpu_t *vcpu, uint8_t vector)", "code": "{\n    uint32_t *intr_pending = vcpu->intr_pending;\n    uint8_t offset = vector % 32;\n    uint8_t nr_word = vector / 32;\n\n    hax_assert(intr_pending[nr_word] & (1 << offset));\n\n    intr_pending[nr_word] &= ~(1 << offset);\n    --vcpu->nr_pending_intrs;\n}", "path": "haxm/core/intr_exc.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/* Really have no idea of the unicode string, so no insertion string input */\n", "func_signal": "int write_event(NTSTATUS err_code, PVOID obj, void *dump_data, int dsize)", "code": "{\n    uint8_t dump_size = 0;\n    PIO_ERROR_LOG_PACKET packet;\n\n    if (dump_data)\n        dump_size = (dsize + sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1);\n    if ((dump_size + sizeof(IO_ERROR_LOG_PACKET)) > ERROR_LOG_MAXIMUM_SIZE)\n        return -1;\n    packet = IoAllocateErrorLogEntry(obj,\n                                     sizeof(IO_ERROR_LOG_PACKET) + dump_size);\n    if (packet == NULL)\n        return -1;\n    packet->ErrorCode = err_code;\n    packet->DumpDataSize = dump_size;\n    if (dump_data) {\n        memcpy_s(&packet->DumpData[0], sizeof(IO_ERROR_LOG_PACKET) + dump_size,\n                 dump_data, dump_size);\n    }\n    /* DumpData should be multiple of sizeof(ulong) */\n    IoWriteErrorLogEntry(packet);\n    return 0;\n}", "path": "haxm/platforms/windows/hax_event.c", "commit_date": "2018-10-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "// Simply to cause vmexit to vcpu, if any vcpu is running on this physical CPU\n", "func_signal": "static void _vcpu_take_off(void *param)", "code": "{\n    hax_cpu_pos_t *target = (hax_cpu_pos_t *)param;\n\n    hax_log(HAX_LOGD, \"[#%d] _vcpu_take_off\\n\", current_cpu_data()->cpu_id);\n    if (target)\n        hax_log(HAX_LOGD, \"_vcpu_take_off on cpu (group-%d bit-%d)\\n\",\n                target->group, target->bit);\n    else\n        hax_log(HAX_LOGD, \"_vcpu_take_off on all cpu\");\n\n    return;\n}", "path": "haxm/core/vcpu.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * Handle IDT-vectoring for interrupt injection\n */\n", "func_signal": "void hax_handle_idt_vectoring(struct vcpu_t *vcpu)", "code": "{\n    uint8_t vector;\n    uint32_t idt_vec = vmread(vcpu, VM_EXIT_INFO_IDT_VECTORING);\n\n    if (idt_vec & 0x80000000) {\n        if (!(idt_vec & 0x700)) {\n            /* One ext interrupt is pending ? Re-inject it ? */\n            vector = (uint8_t) (idt_vec & 0xff);\n            hax_set_pending_intr(vcpu, vector);\n            hax_log(HAX_LOGD, \"extern interrupt is vectoring....vector:%d\\n\",\n                    vector);\n        } else {\n            hax_log(HAX_LOGD, \"VM Exit @ IDT vectoring, type:%d, vector:%d, \"\n                    \"error code:%llx\\n\", (idt_vec & 0x700) >> 8, idt_vec & 0xff,\n                    vmread(vcpu, VM_EXIT_INFO_IDT_VECTORING_ERROR_CODE));\n        }\n    }\n}", "path": "haxm/core/intr_exc.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/* Ioctl will call this function to create a vm */\n", "func_signal": "struct vm_t * hax_create_vm(int *vm_id)", "code": "{\n    struct vm_t *hvm;\n    int id;\n    int ret;\n\n    if ((!hax->vmx_enable_flag) || (!hax->nx_enable_flag)) {\n        hax_log(HAX_LOGE, \"VT or NX is not enabled, can not setup VM!\\n\");\n        return NULL;\n    }\n\n    id = get_free_vm_mid();\n\n    if (!valid_vm_mid(id)) {\n        hax_log(HAX_LOGE, \"Failed to allocate vm id\\n\");\n        return NULL;\n    }\n    *vm_id = id;\n    hvm = hax_vmalloc(sizeof(struct vm_t), HAX_MEM_NONPAGE);\n    if (!hvm) {\n        hax_put_vm_mid(id);\n        hax_log(HAX_LOGE, \"Failed to allocate vm\\n\");\n        return NULL;\n    }\n    memset(hvm, 0, sizeof(struct vm_t));\n\n    hvm->vm_id = id;\n    memset(hvm->vpid_seed, 0, sizeof(hvm->vpid_seed));\n\n#ifdef HAX_ARCH_X86_32\n    hvm->hva_list = hax_vmalloc(((HVA_MAP_ARRAY_SIZE / 4096) *\n                                sizeof(struct hva_entry)), HAX_MEM_NONPAGE);\n    if (!hvm->hva_list)\n        goto fail;\n\n    memset((void *)(hvm->hva_list), 0,\n           ((HVA_MAP_ARRAY_SIZE / 4096) * sizeof(struct hva_entry)));\n\n    hvm->hva_list_1 = hax_vmalloc(((HVA_MAP_ARRAY_SIZE / 4096) *\n                                  sizeof(struct hva_entry)), HAX_MEM_NONPAGE);\n    if (!hvm->hva_list_1)\n        goto fail0;\n\n    memset((void *)(hvm->hva_list_1), 0,\n           ((HVA_MAP_ARRAY_SIZE / 4096) * sizeof(struct hva_entry)));\n#endif\n\n    ret = gpa_space_init(&hvm->gpa_space);\n    if (ret) {\n        hax_log(HAX_LOGE, \"%s: gpa_space_init() returned %d\\n\", __func__, ret);\n        goto fail1;\n    }\n    ret = ept_tree_init(&hvm->ept_tree);\n    if (ret) {\n        hax_log(HAX_LOGE, \"%s: ept_tree_init() returned %d\\n\", __func__, ret);\n        goto fail1;\n    }\n\n    hvm->gpa_space_listener.mapping_added = NULL;\n    hvm->gpa_space_listener.mapping_removed = ept_handle_mapping_removed;\n    hvm->gpa_space_listener.mapping_changed = ept_handle_mapping_changed;\n    hvm->gpa_space_listener.opaque = (void *)&hvm->ept_tree;\n    gpa_space_add_listener(&hvm->gpa_space, &hvm->gpa_space_listener);\n\n    hax_log(HAX_LOGI, \"%s: Invoking INVEPT for VM %d\\n\", __func__, hvm->vm_id);\n    invept(hvm, EPT_INVEPT_SINGLE_CONTEXT);\n\n    hvm->vm_lock = hax_mutex_alloc_init();\n    if (!hvm->vm_lock)\n        goto fail1;\n    hax_init_list_head(&hvm->vcpu_list);\n    if (hax_vm_create_host(hvm, id) < 0)\n        goto fail2;\n\n    /* Publish the VM */\n    hax_mutex_lock(hax->hax_lock);\n    hax_list_add(&hvm->hvm_list, &hax->hax_vmlist);\n    hvm->ref_count = 1;\n    hax_mutex_unlock(hax->hax_lock);\n    return hvm;\nfail2:\n    hax_mutex_free(hvm->vm_lock);\nfail1:\n#ifdef HAX_ARCH_X86_32\n    hax_vfree(hvm->hva_list_1,\n              ((HVA_MAP_ARRAY_SIZE / 4096) * sizeof(struct hva_entry)));\n\nfail0:\n    hax_vfree(hvm->hva_list,\n              ((HVA_MAP_ARRAY_SIZE / 4096) * sizeof(struct hva_entry)));\nfail:\n#endif\n    hax_vfree(hvm, sizeof(struct vm_t));\n    hax_put_vm_mid(id);\n    return NULL;\n}", "path": "haxm/core/vm.c", "commit_date": "2020-03-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * vcpu_vpid_alloc()\n *\n * Allocate a non-zero unique VPID for virtual processor.\n * The allocated VPID is stored in vcpu->vpid.\n * In the case of allocating failure, the vcpu->vpid will keeps zero, which\n * means \"do not enable VPID feature\".\n *\n * Param: vcpu - specify the virtual processor who will get the VPID\n * Return Value: 0 - means success.  Negative value - means failure.\n */\n", "func_signal": "static int vcpu_vpid_alloc(struct vcpu_t *vcpu)", "code": "{\n    uint32_t vpid_seed_bits = sizeof(vcpu->vm->vpid_seed) * 8;\n    uint8_t bit, max_bit;\n\n    max_bit = vpid_seed_bits > 0xff ? 0xff : vpid_seed_bits;\n\n    if (0 != vcpu->vpid) {\n        hax_log(HAX_LOGW, \"vcpu_vpid_alloc: vcpu %u in vm %d already has a \"\n                \"valid VPID 0x%x.\\n\", vcpu->vcpu_id, vcpu->vm->vm_id,\n                vcpu->vpid);\n        return -1;\n    }\n\n    for (bit = 0; bit < max_bit; bit++) {\n        if (!hax_test_and_set_bit(bit, (uint64_t *)vcpu->vm->vpid_seed))\n            break;\n    }\n\n    if (bit == max_bit) {\n        // No available VPID resource\n        hax_log(HAX_LOGE, \"vcpu_vpid_alloc: no available vpid resource. \"\n                \"vcpu: %u, vm: %d\\n\", vcpu->vcpu_id, vcpu->vm->vm_id);\n        return -2;\n    }\n\n    /*\n     * We split vpid as high byte and low byte, the vpid seed is used to\n     * generate low byte. We use the index of first zero bit in vpid seed plus 1\n     * as the value of low_byte, and use vcpu->vm->vm_id as the value of high\n     * byte.\n     * Note: vpid can't be zero.\n     */\n    vcpu->vpid = (uint16_t)(vcpu->vm->vm_id << 8) + (uint16_t)(bit + 1);\n    hax_log(HAX_LOGI, \"vcpu_vpid_alloc: succeed! vpid: 0x%x. vcpu_id: %u, \"\n            \"vm_id: %d.\\n\", vcpu->vpid, vcpu->vcpu_id, vcpu->vm->vm_id);\n\n    return 0;\n}", "path": "haxm/core/vcpu.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * vcpu_vpid_free()\n *\n * Free the VPID that stored in vcpu->vpid for virtual processor.\n * The value of vcpu->vpid will be reset to zero after freeing.\n *\n * Param: vcpu - specify the virtual processor whose VPID will be freed.\n * Return Value: 0 - means success.\n *               Negative value - means vcpu->vpid has been already freed.\n */\n", "func_signal": "static int vcpu_vpid_free(struct vcpu_t *vcpu)", "code": "{\n    uint8_t bit = (vcpu->vpid & 0xff) - 1;\n\n    if (0 == vcpu->vpid) {\n        hax_log(HAX_LOGW, \"vcpu_vpid_free: vcpu %u in vm %d does not have a \"\n                \"valid VPID.\\n\", vcpu->vcpu_id, vcpu->vm->vm_id);\n        return -1;\n    }\n\n    hax_log(HAX_LOGI, \"vcpu_vpid_free: Clearing bit: 0x%x, vpid_seed: 0x%llx. \"\n            \"vcpu_id: %u, vm_id: %d.\\n\", bit, *(uint64_t *)vcpu->vm->vpid_seed,\n            vcpu->vcpu_id, vcpu->vm->vm_id);\n    if (0 != hax_test_and_clear_bit(bit, (uint64_t *)(vcpu->vm->vpid_seed))) {\n        hax_log(HAX_LOGW, \"vcpu_vpid_free: bit for vpid 0x%x of vcpu %u in vm \"\n                \"%d was already clear.\\n\", vcpu->vpid, vcpu->vcpu_id,\n                vcpu->vm->vm_id);\n    }\n    vcpu->vpid = 0;\n\n    return 0;\n}", "path": "haxm/core/vcpu.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "// Pause the vcpu, wait till vcpu is not running, or back to QEMU\n", "func_signal": "int vcpu_pause(struct vcpu_t *vcpu)", "code": "{\n    if (!vcpu)\n        return -1;\n\n    vcpu->paused = 1;\n    hax_smp_mb();\n    if (vcpu->is_running) {\n        hax_smp_call_function(&cpu_online_map, _vcpu_take_off, NULL);\n    }\n\n    return 0;\n}", "path": "haxm/core/vcpu.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "// Maps the given GPA range to KVA space, and returns the number of bytes\n// actually mapped, which may be smaller than |len|, or a negative error code.\n// If successful, the caller will be able to read the buffer starting at |*buf|\n// (or write to it if |*writable| is true), with a size equal to the return\n// value. When it is done with the buffer, it must destroy |kmap| by calling\n// hax_unmap_user_pages().\n", "func_signal": "static int gpa_space_map_range(hax_gpa_space *gpa_space, uint64_t start_gpa,\n                               int len, uint8_t **buf, hax_kmap_user *kmap,\n                               bool *writable)", "code": "{\n    uint64_t gfn;\n    uint delta, size, npages;\n    hax_memslot *slot;\n    hax_ramblock *block;\n    uint64_t offset_within_block, offset_within_chunk;\n    hax_chunk *chunk;\n    void *kva;\n\n    if (len < 0) {\n        hax_log(HAX_LOGE, \"%s: len=%d < 0\\n\", __func__, len);\n        return -EINVAL;\n    }\n    if (!len) {\n        // Assuming buf != NULL\n        *buf = NULL;\n        return 0;\n    }\n\n    gfn = start_gpa >> PG_ORDER_4K;\n    delta = (uint) (start_gpa - (gfn << PG_ORDER_4K));\n    size = (uint) len + delta;\n    npages = (size + PAGE_SIZE_4K - 1) >> PG_ORDER_4K;\n    slot = memslot_find(gpa_space, gfn);\n    if (!slot) {\n        hax_log(HAX_LOGE, \"%s: start_gpa=0x%llx is reserved for MMIO\\n\",\n                __func__, start_gpa);\n        return -EINVAL;\n    }\n    if (writable) {\n        *writable = !(slot->flags & HAX_MEMSLOT_READONLY);\n    }\n    if (gfn + npages > slot->base_gfn + slot->npages) {\n        hax_log(HAX_LOGW, \"%s: GPA range spans more than one memslot:\"\n                \" start_gpa=0x%llx, len=%d, slot_base_gfn=0x%llx,\"\n                \" slot_npages=%llu, gfn=0x%llx, npages=%u\\n\", __func__,\n                start_gpa, len, slot->base_gfn, slot->npages, gfn, npages);\n        npages = (uint) (slot->base_gfn + slot->npages - gfn);\n        size = npages << PG_ORDER_4K;\n    }\n\n    block = slot->block;\n    offset_within_block = ((gfn - slot->base_gfn) << PG_ORDER_4K) +\n                          slot->offset_within_block;\n    chunk = ramblock_get_chunk(block, offset_within_block, true);\n    if (!chunk) {\n        hax_log(HAX_LOGE, \"%s: ramblock_get_chunk() failed: start_gpa=0x%llx\\n\",\n                __func__, start_gpa);\n        return -ENOMEM;\n    }\n    offset_within_chunk = offset_within_block - (chunk->base_uva -\n                          block->base_uva);\n    if (offset_within_chunk + size > chunk->size) {\n        hax_log(HAX_LOGW, \"%s: GPA range spans more than one chunk: \"\n                \"start_gpa=0x%llx, len=%d, offset_within_chunk=0x%llx, \"\n                \"size=0x%x, chunk_size=0x%llx\\n\", __func__, start_gpa, len,\n                offset_within_chunk, size, chunk->size);\n        size = (uint) (chunk->size - offset_within_chunk);\n    }\n\n    // Assuming kmap != NULL\n    kva = hax_map_user_pages(&chunk->memdesc, offset_within_chunk, size, kmap);\n    if (!kva) {\n        hax_log(HAX_LOGE, \"%s: hax_map_user_pages() failed: start_gpa=0x%llx,\"\n                \" len=%d\\n\", __func__, start_gpa, len);\n        return -ENOMEM;\n    }\n    // Assuming buf != NULL\n    *buf = (uint8_t *) kva + delta;\n    return (int) (size - delta);\n}", "path": "haxm/core/gpa_space.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/* When coming here, all vcpus should have been destroyed already. */\n", "func_signal": "int hax_vm_destroy_host(struct vm_t *cvm, void *host_pointer)", "code": "{\n    PDEVICE_OBJECT pDevObj;\n    DECLARE_UNICODE_STRING_SIZE(ntWin32NameString, 64);\n    struct hax_vm_windows *vm = (struct hax_vm_windows *)host_pointer;\n\n    RtlUnicodeStringPrintf(&ntWin32NameString, HAX_VM_DOS_DEV_FMT, vm->vm_id);\n    pDevObj = (PDEVICE_OBJECT)vm->ext;\n\n    IoDeleteSymbolicLink(&ntWin32NameString);\n\n    set_vm_host(cvm, NULL);\n    vm->cvm = NULL;\n    hax_win_destruct_ssdl(vm->ssdl);\n    hax_vm_free_all_ram(cvm);\n\n    /* The hax_vm_windows should be freed here */\n    IoDeleteDevice(pDevObj);\n\n    return 0;\n}", "path": "haxm/platforms/windows/components.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/* According the to SDM to check whether the pending vector and injecting vector\n * can generate a double fault.\n */\n", "func_signal": "static int is_double_fault(uint8_t first_vec, uint8_t second_vec)", "code": "{\n    uint32_t exc_bitmap1 = 0x7c01u;\n    uint32_t exc_bitmap2 = 0x3c01u;\n\n    if (is_extern_interrupt(first_vec))\n        return 0;\n\n    if ((first_vec == VECTOR_PF && (exc_bitmap1 & (1u << second_vec))) ||\n        ((exc_bitmap2 & (1u << first_vec)) && (exc_bitmap2 &\n        (1u << second_vec))))\n        return 1;\n    return 0;\n}", "path": "haxm/core/intr_exc.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * Enable interrupt window and give a chance to pick up\n * the pending interrupts in time\n */\n", "func_signal": "static void hax_enable_intr_window(struct vcpu_t *vcpu)", "code": "{\n    vmx(vcpu, pcpu_ctls) |= INTERRUPT_WINDOW_EXITING;\n    vmwrite(vcpu, VMX_PRIMARY_PROCESSOR_CONTROLS, vmx(vcpu, pcpu_ctls));\n}", "path": "haxm/core/intr_exc.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * Can we simply use RtlFreeUnicodeString? Not sure since we can't find\n * the implementation and the DDK stated it's for RtlAnsiStringToUnicodeString\n * Only used for unicode string setup with hax_init_unicodestring\n */\n", "func_signal": "int hax_free_unicodestring(PUNICODE_STRING str)", "code": "{\n    hax_vfree(str->Buffer, str->MaximumLength);\n    str->MaximumLength = 0;\n    str->Length  = 0;\n    str->Buffer = NULL;\n    return 0;\n}", "path": "haxm/platforms/windows/hax_winlog.c", "commit_date": "2018-10-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "// Returns the protection bitmap size in bytes, or 0 on error.\n", "func_signal": "static uint gpa_space_prot_bitmap_size(uint64_t npages)", "code": "{\n    uint bitmap_size;\n\n    if (npages >> 31) {\n        // Require |npages| to be < 2^31, which is reasonable, because 2^31\n        // pages implies a huge guest RAM size (8TB).\n        return 0;\n    }\n\n    bitmap_size = ((uint)npages + 7) / 8;\n    bitmap_size += 8;\n    return bitmap_size;\n}", "path": "haxm/core/gpa_space.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * Checking the pending interrupts and inject one once ready\n */\n", "func_signal": "void vcpu_inject_intr(struct vcpu_t *vcpu, struct hax_tunnel *htun)", "code": "{\n    uint32_t vector;\n    uint32_t intr_info;\n\n    intr_info = vmread(vcpu, VMX_ENTRY_INTERRUPT_INFO);\n    vector = vcpu_get_pending_intrs(vcpu);\n    if (hax_valid_vector(vector) && !vcpu->event_injected &&\n        !hax_intr_is_blocked(vcpu) && !(intr_info & (1 << 31)))\n        hax_inject_intr(vcpu, vector);\n    /* Check interrupt window's setting needed */\n    vector = vcpu_get_pending_intrs(vcpu);\n    if (hax_valid_vector(vector) || htun->request_interrupt_window)\n        hax_enable_intr_window(vcpu);\n}", "path": "haxm/core/intr_exc.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "// EPT misconfigurations should never happen, because we do not misconfigure\n// any EPT entry on purpose. However, they do happen, at least for one user\n// (ASUS N550JK laptop, Core i7-4700HQ, Windows 10):\n//  https://issuetracker.google.com/issues/66854191\n// Before root-causing the bug, the best we can do is try to identify and\n// fix any misconfigured EPT entries in the EPT misconfiguration handler, and\n// log more information for further debugging.\n", "func_signal": "int ept_handle_misconfiguration(hax_gpa_space *gpa_space, hax_ept_tree *tree,\n                                uint64_t gpa)", "code": "{\n    uint64_t gfn;\n    epte_fixer_bundle bundle = { NULL, 0, 0 };\n\n    gfn = gpa >> PG_ORDER_4K;\n    hax_assert(gpa_space != NULL);\n    bundle.slot = memslot_find(gpa_space, gfn);\n    if (!bundle.slot) {\n        // The GPA being accessed is reserved for MMIO\n        hax_log(HAX_LOGW, \"%s: gpa=0x%llx is reserved for MMIO\\n\",\n                __func__, gpa);\n    }\n\n    ept_tree_walk(tree, gfn, fix_epte, &bundle);\n    if (bundle.error_count) {\n        hax_log(HAX_LOGE, \"%s: Failed to fix %d/%d misconfigured entries for\"\n                \" gpa=0x%llx\\n\", __func__, bundle.error_count,\n                bundle.misconfigured_count, gpa);\n        return -bundle.error_count;\n    }\n    hax_log(HAX_LOGW, \"%s: Fixed %d misconfigured entries for gpa=0x%llx\\n\",\n            __func__, bundle.misconfigured_count, gpa);\n    return bundle.misconfigured_count;\n}", "path": "haxm/core/ept2.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * Check whether vcpu is ready for interrupt injection.\n * Maybe blocked by STI, MOV SS, Pending NMI etc.\n */\n", "func_signal": "uint hax_intr_is_blocked(struct vcpu_t *vcpu)", "code": "{\n    struct vcpu_state_t *state = vcpu->state;\n    uint32_t intr_status;\n    uint32_t intr_blocking = 0;\n\n    if (!(state->_eflags & EFLAGS_IF))\n        return 1;\n\n    intr_blocking |= GUEST_INTRSTAT_STI_BLOCKING;\n    intr_blocking |= GUEST_INTRSTAT_SS_BLOCKING;\n    intr_status = vmx(vcpu, interruptibility_state).raw;\n    if (intr_status & intr_blocking)\n        return 1;\n    return 0;\n}", "path": "haxm/core/intr_exc.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n * Returns 0 if handled, else returns 1\n * According to the caller, return 1 will cause GP to guest\n */\n", "func_signal": "static int misc_msr_read(struct vcpu_t *vcpu, uint32_t msr, uint64_t *val)", "code": "{\n    mtrr_var_t *v;\n\n    if (msr >= IA32_MTRR_PHYSBASE0 && msr <= IA32_MTRR_PHYSMASK9) {\n        hax_assert((msr >> 1 & 0x7f) < NUM_VARIABLE_MTRRS);\n        v = &vcpu->mtrr_current_state.mtrr_var[msr >> 1 & 0x7f];\n        *val = msr & 1 ? v->mask.raw : v->base.raw;\n        return 0;\n    } else if (msr >= MTRRFIX16K_80000 && msr <= MTRRFIX16K_A0000) {\n        *val = vcpu->mtrr_current_state.mtrr_fixed16k[msr & 0x1];\n        return 0;\n    } else if (msr >= MTRRFIX4K_C0000 && msr <= MTRRFIX4K_F8000) {\n        *val = vcpu->mtrr_current_state.mtrr_fixed4k[msr & 0x7];\n        return 0;\n    } else if ((msr >= IA32_MC0_CTL2 && msr <= IA32_MC8_CTL2) ||\n               (msr >= 0x300 && msr <= 0x3ff)) {\n        *val = 0;\n        return 0;\n    }\n\n    return 1;\n}", "path": "haxm/core/vcpu.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "// Sets or clears consecutive bits in a byte.\n", "func_signal": "static inline void set_bits_in_byte(uint8_t *byte, int start, int nbits, bool set)", "code": "{\n    uint mask;\n\n    hax_assert(byte != NULL);\n    hax_assert(start >= 0 && start < 8);\n    hax_assert(nbits >= 0 && start + nbits <= 8);\n\n    mask = ((1 << nbits) - 1) << start;\n    if (set) {\n        *byte = (uint8_t)(*byte | mask);\n    } else {\n        mask = ~mask & 0xff;\n        *byte = (uint8_t)(*byte & mask);\n    }\n}", "path": "haxm/core/gpa_space.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "intel/haxm", "stars": 3154, "license": "bsd-3-clause", "language": "c", "size": 1508}
{"docstring": "/*\n** Free all memory associated with foreign key definitions attached to\n** table pTab. Remove the deleted foreign keys from the Schema.fkeyHash\n** hash table.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3FkDelete(sqlite3 *db, Table *pTab)", "code": "{\n  FKey *pFKey;                    /* Iterator variable */\n  FKey *pNext;                    /* Copy of pFKey->pNextFrom */\n\n  assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pTab->pSchema) );\n  for(pFKey=pTab->pFKey; pFKey; pFKey=pNext){\n\n    /* Remove the FK from the fkeyHash hash table. */\n    if( !db || db->pnBytesFreed==0 ){\n      if( pFKey->pPrevTo ){\n        pFKey->pPrevTo->pNextTo = pFKey->pNextTo;\n      }else{\n        void *p = (void *)pFKey->pNextTo;\n        const char *z = (p ? pFKey->pNextTo->zTo : pFKey->zTo);\n        sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, sqlite3Strlen30(z), p);\n      }\n      if( pFKey->pNextTo ){\n        pFKey->pNextTo->pPrevTo = pFKey->pPrevTo;\n      }\n    }\n\n    /* EV: R-30323-21917 Each foreign key constraint in SQLite is\n    ** classified as either immediate or deferred.\n    */\n    assert( pFKey->isDeferred==0 || pFKey->isDeferred==1 );\n\n    /* Delete any triggers created to implement actions for this FK. */\n#ifndef SQLITE_OMIT_TRIGGER\n    fkTriggerDelete(db, pFKey->apTrigger[0]);\n    fkTriggerDelete(db, pFKey->apTrigger[1]);\n#endif\n\n    pNext = pFKey->pNextFrom;\n    sqlite3DbFree(db, pFKey);\n  }\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Read a 32-bit variable-length integer from memory starting at p[0].\n** Return the number of bytes read.  The value is stored in *v.\n**\n** If the varint stored in p[0] is larger than can fit in a 32-bit unsigned\n** integer, then set *v to 0xffffffff.\n**\n** A MACRO version, getVarint32, is provided which inlines the \n** single-byte case.  All code should use the MACRO version as \n** this function assumes the single-byte case has already been handled.\n*/\n", "func_signal": "SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v)", "code": "{\n  u32 a,b;\n\n  /* The 1-byte case.  Overwhelmingly the most common.  Handled inline\n  ** by the getVarin32() macro */\n  a = *p;\n  /* a: p0 (unmasked) */\n#ifndef getVarint32\n  if (!(a&0x80))\n  {\n    /* Values between 0 and 127 */\n    *v = a;\n    return 1;\n  }\n#endif\n\n  /* The 2-byte case */\n  p++;\n  b = *p;\n  /* b: p1 (unmasked) */\n  if (!(b&0x80))\n  {\n    /* Values between 128 and 16383 */\n    a &= 0x7f;\n    a = a<<7;\n    *v = a | b;\n    return 2;\n  }\n\n  /* The 3-byte case */\n  p++;\n  a = a<<14;\n  a |= *p;\n  /* a: p0<<14 | p2 (unmasked) */\n  if (!(a&0x80))\n  {\n    /* Values between 16384 and 2097151 */\n    a &= (0x7f<<14)|(0x7f);\n    b &= 0x7f;\n    b = b<<7;\n    *v = a | b;\n    return 3;\n  }\n\n  /* A 32-bit varint is used to store size information in btrees.\n  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.\n  ** A 3-byte varint is sufficient, for example, to record the size\n  ** of a 1048569-byte BLOB or string.\n  **\n  ** We only unroll the first 1-, 2-, and 3- byte cases.  The very\n  ** rare larger cases can be handled by the slower 64-bit varint\n  ** routine.\n  */\n#if 1\n  {\n    u64 v64;\n    u8 n;\n\n    p -= 2;\n    n = sqlite3GetVarint(p, &v64);\n    assert( n>3 && n<=9 );\n    if( (v64 & SQLITE_MAX_U32)!=v64 ){\n      *v = 0xffffffff;\n    }else{\n      *v = (u32)v64;\n    }\n    return n;\n  }\n\n#else\n  /* For following code (kept for historical record only) shows an\n  ** unrolling for the 3- and 4-byte varint cases.  This code is\n  ** slightly faster, but it is also larger and much harder to test.\n  */\n  p++;\n  b = b<<14;\n  b |= *p;\n  /* b: p1<<14 | p3 (unmasked) */\n  if (!(b&0x80))\n  {\n    /* Values between 2097152 and 268435455 */\n    b &= (0x7f<<14)|(0x7f);\n    a &= (0x7f<<14)|(0x7f);\n    a = a<<7;\n    *v = a | b;\n    return 4;\n  }\n\n  p++;\n  a = a<<14;\n  a |= *p;\n  /* a: p0<<28 | p2<<14 | p4 (unmasked) */\n  if (!(a&0x80))\n  {\n    /* Values  between 268435456 and 34359738367 */\n    a &= SLOT_4_2_0;\n    b &= SLOT_4_2_0;\n    b = b<<7;\n    *v = a | b;\n    return 5;\n  }\n\n  /* We can only reach this point when reading a corrupt database\n  ** file.  In that case we are not in any hurry.  Use the (relatively\n  ** slow) general-purpose sqlite3GetVarint() routine to extract the\n  ** value. */\n  {\n    u64 v64;\n    u8 n;\n\n    p -= 4;\n    n = sqlite3GetVarint(p, &v64);\n    assert( n>5 && n<=9 );\n    *v = (u32)v64;\n    return n;\n  }\n#endif\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Release all the table locks (locks obtained via calls to\n** the setSharedCacheTableLock() procedure) held by Btree object p.\n**\n** This function assumes that Btree p has an open read or write \n** transaction. If it does not, then the BtShared.isPending variable\n** may be incorrectly cleared.\n*/\n", "func_signal": "static void clearAllSharedCacheTableLocks(Btree *p)", "code": "{\n  BtShared *pBt = p->pBt;\n  BtLock **ppIter = &pBt->pLock;\n\n  assert( sqlite3BtreeHoldsMutex(p) );\n  assert( p->sharable || 0==*ppIter );\n  assert( p->inTrans>0 );\n\n  while( *ppIter ){\n    BtLock *pLock = *ppIter;\n    assert( pBt->isExclusive==0 || pBt->pWriter==pLock->pBtree );\n    assert( pLock->pBtree->inTrans>=pLock->eLock );\n    if( pLock->pBtree==p ){\n      *ppIter = pLock->pNext;\n      assert( pLock->iTable!=1 || pLock==&p->lock );\n      if( pLock->iTable!=1 ){\n        sqlite3_free(pLock);\n      }\n    }else{\n      ppIter = &pLock->pNext;\n    }\n  }\n\n  assert( pBt->isPending==0 || pBt->pWriter );\n  if( pBt->pWriter==p ){\n    pBt->pWriter = 0;\n    pBt->isExclusive = 0;\n    pBt->isPending = 0;\n  }else if( pBt->nTransaction==2 ){\n    /* This function is called when Btree p is concluding its \n    ** transaction. If there currently exists a writer, and p is not\n    ** that writer, then the number of locks held by connections other\n    ** than the writer must be about to drop to zero. In this case\n    ** set the isPending flag to 0.\n    **\n    ** If there is not currently a writer, then BtShared.isPending must\n    ** be zero already. So this next line is harmless in that case.\n    */\n    pBt->isPending = 0;\n  }\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Print a single opcode.  This routine is used for debugging only.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE *pOut, int pc, Op *pOp)", "code": "{\n  char *zP4;\n  char zPtr[50];\n  static const char *zFormat1 = \"%4d %-13s %4d %4d %4d %-4s %.2X %s\\n\";\n  if( pOut==0 ) pOut = stdout;\n  zP4 = displayP4(pOp, zPtr, sizeof(zPtr));\n  fprintf(pOut, zFormat1, pc, \n      sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3, zP4, pOp->p5,\n#ifdef SQLITE_DEBUG\n      pOp->zComment ? pOp->zComment : \"\"\n#else\n      \"\"\n#endif\n  );\n  fflush(pOut);\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Check schema cookies in all databases.  If any cookie is out\n** of date set pParse->rc to SQLITE_SCHEMA.  If all schema cookies\n** make no changes to pParse->rc.\n*/\n", "func_signal": "static void schemaIsValid(Parse *pParse)", "code": "{\n  sqlite3 *db = pParse->db;\n  int iDb;\n  int rc;\n  int cookie;\n\n  assert( pParse->checkSchema );\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(iDb=0; iDb<db->nDb; iDb++){\n    int openedTransaction = 0;         /* True if a transaction is opened */\n    Btree *pBt = db->aDb[iDb].pBt;     /* Btree database to read cookie from */\n    if( pBt==0 ) continue;\n\n    /* If there is not already a read-only (or read-write) transaction opened\n    ** on the b-tree database, open one now. If a transaction is opened, it \n    ** will be closed immediately after reading the meta-value. */\n    if( !sqlite3BtreeIsInReadTrans(pBt) ){\n      rc = sqlite3BtreeBeginTrans(pBt, 0);\n      if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n        db->mallocFailed = 1;\n      }\n      if( rc!=SQLITE_OK ) return;\n      openedTransaction = 1;\n    }\n\n    /* Read the schema cookie from the database. If it does not match the \n    ** value stored as part of the in-memory schema representation,\n    ** set Parse.rc to SQLITE_SCHEMA. */\n    sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&cookie);\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){\n      sqlite3ResetInternalSchema(db, iDb);\n      pParse->rc = SQLITE_SCHEMA;\n    }\n\n    /* Close the transaction, if one was opened. */\n    if( openedTransaction ){\n      sqlite3BtreeCommit(pBt);\n    }\n  }\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Free all structures in the Pager.aSavepoint[] array and set both\n** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journal\n** if it is open and the pager is not in exclusive mode.\n*/\n", "func_signal": "static void releaseAllSavepoints(Pager *pPager)", "code": "{\n  int ii;               /* Iterator for looping through Pager.aSavepoint */\n  for(ii=0; ii<pPager->nSavepoint; ii++){\n    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);\n  }\n  if( !pPager->exclusiveMode || sqlite3IsMemJournal(pPager->sjfd) ){\n    sqlite3OsClose(pPager->sjfd);\n  }\n  sqlite3_free(pPager->aSavepoint);\n  pPager->aSavepoint = 0;\n  pPager->nSavepoint = 0;\n  pPager->nSubRec = 0;\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** zIn is a UTF-16 encoded unicode string at least nChar characters long.\n** Return the number of bytes in the first nChar unicode characters\n** in pZ.  nChar must be non-negative.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar)", "code": "{\n  int c;\n  unsigned char const *z = zIn;\n  int n = 0;\n  \n  if( SQLITE_UTF16NATIVE==SQLITE_UTF16BE ){\n    while( n<nChar ){\n      READ_UTF16BE(z, 1, c);\n      n++;\n    }\n  }else{\n    while( n<nChar ){\n      READ_UTF16LE(z, 1, c);\n      n++;\n    }\n  }\n  return (int)(z-(unsigned char const *)zIn);\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Given a token, return a string that consists of the text of that\n** token.  Space to hold the returned string\n** is obtained from sqliteMalloc() and must be freed by the calling\n** function.\n**\n** Any quotation marks (ex:  \"name\", 'name', [name], or `name`) that\n** surround the body of the token are removed.\n**\n** Tokens are often just pointers into the original SQL text and so\n** are not \\000 terminated and are not persistent.  The returned string\n** is \\000 terminated and is persistent.\n*/\n", "func_signal": "SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3 *db, Token *pName)", "code": "{\n  char *zName;\n  if( pName ){\n    zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n);\n    sqlite3Dequote(zName);\n  }else{\n    zName = 0;\n  }\n  return zName;\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Generate a CREATE TABLE statement appropriate for the given\n** table.  Memory to hold the text of the statement is obtained\n** from sqliteMalloc() and must be freed by the calling function.\n*/\n", "func_signal": "static char *createTableStmt(sqlite3 *db, Table *p)", "code": "{\n  int i, k, n;\n  char *zStmt;\n  char *zSep, *zSep2, *zEnd;\n  Column *pCol;\n  n = 0;\n  for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){\n    n += identLength(pCol->zName) + 5;\n  }\n  n += identLength(p->zName);\n  if( n<50 ){ \n    zSep = \"\";\n    zSep2 = \",\";\n    zEnd = \")\";\n  }else{\n    zSep = \"\\n  \";\n    zSep2 = \",\\n  \";\n    zEnd = \"\\n)\";\n  }\n  n += 35 + 6*p->nCol;\n  zStmt = sqlite3DbMallocRaw(0, n);\n  if( zStmt==0 ){\n    db->mallocFailed = 1;\n    return 0;\n  }\n  sqlite3_snprintf(n, zStmt, \"CREATE TABLE \");\n  k = sqlite3Strlen30(zStmt);\n  identPut(zStmt, &k, p->zName);\n  zStmt[k++] = '(';\n  for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){\n    static const char * const azType[] = {\n        /* SQLITE_AFF_TEXT    */ \" TEXT\",\n        /* SQLITE_AFF_NONE    */ \"\",\n        /* SQLITE_AFF_NUMERIC */ \" NUM\",\n        /* SQLITE_AFF_INTEGER */ \" INT\",\n        /* SQLITE_AFF_REAL    */ \" REAL\"\n    };\n    int len;\n    const char *zType;\n\n    sqlite3_snprintf(n-k, &zStmt[k], zSep);\n    k += sqlite3Strlen30(&zStmt[k]);\n    zSep = zSep2;\n    identPut(zStmt, &k, pCol->zName);\n    assert( pCol->affinity-SQLITE_AFF_TEXT >= 0 );\n    assert( pCol->affinity-SQLITE_AFF_TEXT < ArraySize(azType) );\n    testcase( pCol->affinity==SQLITE_AFF_TEXT );\n    testcase( pCol->affinity==SQLITE_AFF_NONE );\n    testcase( pCol->affinity==SQLITE_AFF_NUMERIC );\n    testcase( pCol->affinity==SQLITE_AFF_INTEGER );\n    testcase( pCol->affinity==SQLITE_AFF_REAL );\n    \n    zType = azType[pCol->affinity - SQLITE_AFF_TEXT];\n    len = sqlite3Strlen30(zType);\n    assert( pCol->affinity==SQLITE_AFF_NONE \n            || pCol->affinity==sqlite3AffinityType(zType) );\n    memcpy(&zStmt[k], zType, len);\n    k += len;\n    assert( k<=n );\n  }\n  sqlite3_snprintf(n-k, &zStmt[k], \"%s\", zEnd);\n  return zStmt;\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Undo a readlock\n*/\n", "func_signal": "static int unlockReadLock( os2File *id )", "code": "{\n  FILELOCK  LockArea,\n            UnlockArea;\n  APIRET res;\n  memset(&LockArea, 0, sizeof(LockArea));\n  memset(&UnlockArea, 0, sizeof(UnlockArea));\n  LockArea.lOffset = 0L;\n  LockArea.lRange = 0L;\n  UnlockArea.lOffset = SHARED_FIRST;\n  UnlockArea.lRange = SHARED_SIZE;\n  res = DosSetFileLocks( id->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 1L );\n  OSTRACE(( \"UNLOCK-READLOCK file handle=%d res=%d?\\n\", id->h, res ));\n  return res;\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** This is called when the database connection passed as an argument is \n** being closed. The connection is removed from the blocked list.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ConnectionClosed(sqlite3 *db)", "code": "{\n  sqlite3ConnectionUnlocked(db);\n  enterMutex();\n  removeFromBlockedList(db);\n  checkListProperties(db);\n  leaveMutex();\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Return the value of the 'auto-vacuum' property. If auto-vacuum is \n** enabled 1 is returned. Otherwise 0.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *p)", "code": "{\n#ifdef SQLITE_OMIT_AUTOVACUUM\n  return BTREE_AUTOVACUUM_NONE;\n#else\n  int rc;\n  sqlite3BtreeEnter(p);\n  rc = (\n    (!p->pBt->autoVacuum)?BTREE_AUTOVACUUM_NONE:\n    (!p->pBt->incrVacuum)?BTREE_AUTOVACUUM_FULL:\n    BTREE_AUTOVACUUM_INCR\n  );\n  sqlite3BtreeLeave(p);\n  return rc;\n#endif\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Free the RtreeCursor.aConstraint[] array and its contents.\n*/\n", "func_signal": "static void freeCursorConstraints(RtreeCursor *pCsr)", "code": "{\n  if( pCsr->aConstraint ){\n    int i;                        /* Used to iterate through constraint array */\n    for(i=0; i<pCsr->nConstraint; i++){\n      sqlite3_rtree_geometry *pGeom = pCsr->aConstraint[i].pGeom;\n      if( pGeom ){\n        if( pGeom->xDelUser ) pGeom->xDelUser(pGeom->pUser);\n        sqlite3_free(pGeom);\n      }\n    }\n    sqlite3_free(pCsr->aConstraint);\n    pCsr->aConstraint = 0;\n  }\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** \"Special\" FTS4 arguments are column specifications of the following form:\n**\n**   <key> = <value>\n**\n** There may not be whitespace surrounding the \"=\" character. The <value> \n** term may be quoted, but the <key> may not.\n*/\n", "func_signal": "static int fts3IsSpecialColumn(\n  const char *z, \n  int *pnKey,\n  char **pzValue\n)", "code": "{\n  char *zValue;\n  const char *zCsr = z;\n\n  while( *zCsr!='=' ){\n    if( *zCsr=='\\0' ) return 0;\n    zCsr++;\n  }\n\n  *pnKey = (int)(zCsr-z);\n  zValue = sqlite3_mprintf(\"%s\", &zCsr[1]);\n  if( zValue ){\n    sqlite3Fts3Dequote(zValue);\n  }\n  *pzValue = zValue;\n  return 1;\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Close a blob handle that was previously created using\n** sqlite3_blob_open().\n*/\n", "func_signal": "SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob)", "code": "{\n  Incrblob *p = (Incrblob *)pBlob;\n  int rc;\n  sqlite3 *db;\n\n  if( p ){\n    db = p->db;\n    sqlite3_mutex_enter(db->mutex);\n    rc = sqlite3_finalize(p->pStmt);\n    sqlite3DbFree(db, p);\n    sqlite3_mutex_leave(db->mutex);\n  }else{\n    rc = SQLITE_OK;\n  }\n  return rc;\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Mark every prepared statement associated with a database connection\n** as expired.\n**\n** An expired statement means that recompilation of the statement is\n** recommend.  Statements expire when things happen that make their\n** programs obsolete.  Removing user-defined functions or collating\n** sequences, or changing an authorization function are the types of\n** things that make prepared statements obsolete.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3 *db)", "code": "{\n  Vdbe *p;\n  for(p = db->pVdbe; p; p=p->pNext){\n    p->expired = 1;\n  }\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Convert multibyte character string to UTF-8.  Space to hold the\n** returned string is obtained from malloc().\n*/\n", "func_signal": "SQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zFilename)", "code": "{\n  char *zFilenameUtf8;\n  WCHAR *zTmpWide;\n\n  zTmpWide = mbcsToUnicode(zFilename);\n  if( zTmpWide==0 ){\n    return 0;\n  }\n  zFilenameUtf8 = unicodeToUtf8(zTmpWide);\n  free(zTmpWide);\n  return zFilenameUtf8;\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Open the file indicated and write a log of all unfreed memory \n** allocations into that log.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3MemdebugDump(const char *zFilename)", "code": "{\n  FILE *out;\n  struct MemBlockHdr *pHdr;\n  void **pBt;\n  int i;\n  out = fopen(zFilename, \"w\");\n  if( out==0 ){\n    fprintf(stderr, \"** Unable to output memory debug output log: %s **\\n\",\n                    zFilename);\n    return;\n  }\n  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){\n    char *z = (char*)pHdr;\n    z -= pHdr->nBacktraceSlots*sizeof(void*) + pHdr->nTitle;\n    fprintf(out, \"**** %lld bytes at %p from %s ****\\n\", \n            pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : \"???\");\n    if( pHdr->nBacktrace ){\n      fflush(out);\n      pBt = (void**)pHdr;\n      pBt -= pHdr->nBacktraceSlots;\n      backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out));\n      fprintf(out, \"\\n\");\n    }\n  }\n  fprintf(out, \"COUNTS:\\n\");\n  for(i=0; i<NCSIZE-1; i++){\n    if( mem.nAlloc[i] ){\n      fprintf(out, \"   %5d: %10d %10d %10d\\n\", \n            i*8, mem.nAlloc[i], mem.nCurrent[i], mem.mxCurrent[i]);\n    }\n  }\n  if( mem.nAlloc[NCSIZE-1] ){\n    fprintf(out, \"   %5d: %10d %10d %10d\\n\",\n             NCSIZE*8-8, mem.nAlloc[NCSIZE-1],\n             mem.nCurrent[NCSIZE-1], mem.mxCurrent[NCSIZE-1]);\n  }\n  fclose(out);\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Generate code to move content from registers iFrom...iFrom+nReg-1\n** over to iTo..iTo+nReg-1. Keep the column cache up-to-date.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg)", "code": "{\n  int i;\n  struct yColCache *p;\n  if( NEVER(iFrom==iTo) ) return;\n  sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg);\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    int x = p->iReg;\n    if( x>=iFrom && x<iFrom+nReg ){\n      p->iReg += iTo-iFrom;\n    }\n  }\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/*\n** Like free() but works for allocations obtained from sqlite3MemMalloc()\n** or sqlite3MemRealloc().\n**\n** For this low-level routine, we already know that pPrior!=0 since\n** cases where pPrior==0 will have been intecepted and dealt with\n** by higher-level routines.\n*/\n", "func_signal": "static void sqlite3MemFree(void *pPrior)", "code": "{\n  sqlite3_int64 *p = (sqlite3_int64*)pPrior;\n  assert( pPrior!=0 );\n  p--;\n  free(p);\n}", "path": "WizQTClient/src/share/sqlite3.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "WizTeam/WizQTClient", "stars": 2602, "license": "other", "language": "c", "size": 91958}
{"docstring": "/* Initialize the board's EEPROM (NVR.) */\n", "func_signal": "static void\naha_setnvr(x54x_t *dev)", "code": "{\n    FILE *f;\n\n    /* Only if this device has an EEPROM. */\n    if (dev->nvr_path == NULL) return;\n\n    /* Allocate and initialize the EEPROM. */\n    dev->nvr = (uint8_t *)malloc(NVR_SIZE);\n    memset(dev->nvr, 0x00, NVR_SIZE);\n\n    f = nvr_fopen(dev->nvr_path, L\"rb\");\n    if (f) {\n\tif (fread(dev->nvr, 1, NVR_SIZE, f) != NVR_SIZE)\n\t\tfatal(\"aha_setnvr(): Error reading data\\n\");\n\tfclose(f);\n\tf = NULL;\n    } else\n\taha_initnvr(dev);\n}", "path": "86Box/src/scsi/scsi_aha154x.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Draw a line in CGA 320x200 mode. Here the CGA colours are converted to\n * dither patterns: colour 1 to 25% grey, colour 2 to 50% grey */\n", "func_signal": "static void t1000_cgaline4(t1000_t *t1000)", "code": "{\n\tint x, c;\n\tuint8_t dat, pattern;\n\tuint32_t ink0, ink1;\n\tuint16_t addr;\n\n\tuint16_t ma = (t1000->cga.crtc[13] | (t1000->cga.crtc[12] << 8)) & 0x3fff;\n\taddr = ((t1000->displine) & 1) * 0x2000 +\n\t       (t1000->displine >> 1) * 80 +\n\t       ((ma & ~1) << 1);\n\n\tfor (x = 0; x < 80; x++)\n\t{\n\t\tdat = t1000->vram[addr & 0x3FFF];\n\t\taddr++;\n\n\t\tfor (c = 0; c < 4; c++)\n\t\t{\n\t\t\tpattern = (dat & 0xC0) >> 6;\n\t\t\tif (!(t1000->cga.cgamode & 8)) pattern = 0;\n\n\t\t\tswitch (pattern & 3)\n\t\t\t{\n\t\t\t\tdefault:\n\t\t\t\tcase 0: ink0 = ink1 = grey; break;\n\t\t\t\tcase 1: if (t1000->displine & 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tink0 = grey; ink1 = grey;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tink0 = blue; ink1 = grey;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: if (t1000->displine & 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tink0 = grey; ink1 = blue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tink0 = blue; ink1 = grey;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3: ink0 = ink1 = blue; break;\n\n\t\t\t}\n\t\t\t((uint32_t *)buffer32->line[t1000->displine])[x*8+2*c] = ink0;\n\t\t\t((uint32_t *)buffer32->line[t1000->displine])[x*8+2*c+1] = ink1;\n\t\t\tdat = dat << 2;\n\t\t}\n\t}\n}", "path": "86Box/src/machine/m_xt_t1000_vid.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/*\n * Write data to the BIOS space.\n *\n * AHA-1542C's and up have a feature where they map a 128-byte\n * RAM space into the ROM BIOS' address space, and then use it\n * as working memory. This function implements the writing to\n * that memory.\n *\n * We enable/disable this memory through AHA command 0x24.\n */\n", "func_signal": "static void\naha_mem_write(uint32_t addr, uint8_t val, void *priv)", "code": "{\n    x54x_t *dev = (x54x_t *)priv;\n\n    addr &= 0x3fff;\n\n    if ((addr >= dev->rom_shram) && (dev->shram_mode & 1))\n\tdev->shadow_ram[addr & (dev->rom_shramsz - 1)] = val;\n}", "path": "86Box/src/scsi/scsi_aha154x.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Initialize the board's ROM BIOS. */\n", "func_signal": "static void\naha_setbios(x54x_t *dev)", "code": "{\n    uint32_t size;\n    uint32_t mask;\n    uint32_t temp;\n    FILE *f;\n    int i;\n\n    /* Only if this device has a BIOS ROM. */\n    if (dev->bios_path == NULL) return;\n\n    /* Open the BIOS image file and make sure it exists. */\n    aha_log(\"%s: loading BIOS from '%ls'\\n\", dev->name, dev->bios_path);\n    if ((f = rom_fopen(dev->bios_path, L\"rb\")) == NULL) {\n\taha_log(\"%s: BIOS ROM not found!\\n\", dev->name);\n\treturn;\n    }\n\n    /*\n     * Manually load and process the ROM image.\n     *\n     * We *could* use the system \"rom_init\" function here, but for\n     * this special case, we can't: we may need WRITE access to the\n     * memory later on.\n     */\n    (void)fseek(f, 0L, SEEK_END);\n    temp = ftell(f);\n    (void)fseek(f, 0L, SEEK_SET);\n\n    /* Load first chunk of BIOS (which is the main BIOS, aka ROM1.) */\n    dev->rom1 = malloc(ROM_SIZE);\n    (void)fread(dev->rom1, ROM_SIZE, 1, f);\n    temp -= ROM_SIZE;\n    if (temp > 0) {\n\tdev->rom2 = malloc(ROM_SIZE);\n\t(void)fread(dev->rom2, ROM_SIZE, 1, f);\n\ttemp -= ROM_SIZE;\n    } else {\n\tdev->rom2 = NULL;\n    }\n    if (temp != 0) {\n\taha_log(\"%s: BIOS ROM size invalid!\\n\", dev->name);\n\tfree(dev->rom1);\n\tif (dev->rom2 != NULL)\n\t\tfree(dev->rom2);\n\t(void)fclose(f);\n\treturn;\n    }\n    temp = ftell(f);\n    if (temp > ROM_SIZE)\n\ttemp = ROM_SIZE;\n    (void)fclose(f);\n\n    /* Adjust BIOS size in chunks of 2K, as per BIOS spec. */\n    size = 0x10000;\n    if (temp <= 0x8000)\n\tsize = 0x8000;\n    if (temp <= 0x4000)\n\tsize = 0x4000;\n    if (temp <= 0x2000)\n\tsize = 0x2000;\n    mask = (size - 1);\n    aha_log(\"%s: BIOS at 0x%06lX, size %lu, mask %08lx\\n\",\n\t\t\tdev->name, dev->rom_addr, size, mask);\n\n    /* Initialize the ROM entry for this BIOS. */\n    memset(&dev->bios, 0x00, sizeof(rom_t));\n\n    /* Enable ROM1 into the memory map. */\n    dev->bios.rom = dev->rom1;\n\n    /* Set up an address mask for this memory. */\n    dev->bios.mask = mask;\n\n    /* Map this system into the memory map. */\n    mem_mapping_add(&dev->bios.mapping, dev->rom_addr, size,\n\t\t    aha_mem_read, NULL, NULL, /* aha_mem_readw, aha_mem_readl, */\n\t\t    aha_mem_write, NULL, NULL,\n\t\t    dev->bios.rom, MEM_MAPPING_EXTERNAL, dev);\n    mem_mapping_disable(&dev->bios.mapping);\n\n    /*\n     * Patch the ROM BIOS image for stuff Adaptec deliberately\n     * made hard to understand. Well, maybe not, maybe it was\n     * their way of handling issues like these at the time..\n     *\n     * Patch 1: emulate the I/O ADDR SW setting by patching a\n     *\t    byte in the BIOS that indicates the I/O ADDR\n     *\t    switch setting on the board.\n     */\n    if (dev->rom_ioaddr != 0x0000) {\n\t/* Look up the I/O address in the table. */\n\tfor (i=0; i<8; i++)\n\t\tif (aha_ports[i] == dev->Base) break;\n\tif (i == 8) {\n\t\taha_log(\"%s: invalid I/O address %04x selected!\\n\",\n\t\t\t\t\tdev->name, dev->Base);\n\t\treturn;\n\t}\n\tdev->bios.rom[dev->rom_ioaddr] = (uint8_t)i;\n\t/* Negation of the DIP switches to satify the checksum. */\n\tdev->bios.rom[dev->rom_ioaddr + 1] = (uint8_t)((i ^ 0xff) + 1);\n    }\n}", "path": "86Box/src/scsi/scsi_aha154x.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Changes the SMRAM state. */\n", "func_signal": "void\nsmram_state_change(smram_t *smr, int smm, int flags)", "code": "{\n    if (smr == NULL) {\n\tfatal(\"smram_tate_change(): Invalid SMRAM mapping\\n\");\n\treturn;\n    }\n\n    smram_map(smm, smr->host_base, smr->size, flags);\n}", "path": "86Box/src/mem/smram.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Draw a line in CGA 640x200 mode */\n", "func_signal": "static void t1000_cgaline6(t1000_t *t1000)", "code": "{\n\tint x, c;\n\tuint8_t dat;\n\tuint32_t ink = 0;\n\tuint16_t addr;\n\tuint32_t fg = (t1000->cga.cgacol & 0x0F) ? blue : grey;\n\tuint32_t bg = grey;\n\n\tuint16_t ma = (t1000->cga.crtc[13] | (t1000->cga.crtc[12] << 8)) & 0x3fff;\n\n\taddr = ((t1000->displine) & 1) * 0x2000 +\n\t       (t1000->displine >> 1) * 80 +\n\t       ((ma & ~1) << 1);\n\n\tfor (x = 0; x < 80; x++)\n\t{\n\t\tdat = t1000->vram[addr & 0x3FFF];\n\t\taddr++;\n\n\t\tfor (c = 0; c < 8; c++)\n\t\t{\n\t\t\tink = (dat & 0x80) ? fg : bg;\n\t\t\tif (!(t1000->cga.cgamode & 8))\n                                ink = grey;\n\t\t\t((uint32_t *)buffer32->line[t1000->displine])[x*8+c] = ink;\n\t\t\tdat = dat << 1;\n\t\t}\n\t}\n}", "path": "86Box/src/machine/m_xt_t1000_vid.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Recalculate any mappings, including the backup if returning from SMM. */\n", "func_signal": "void\nsmram_recalc_all(int ret)", "code": "{\n    smram_t *temp_smram = base_smram, *next;\n\n    if (base_smram == NULL)\n\treturn;\n\n    if (ret) {\n\twhile (temp_smram != NULL) {\n\t\tif (temp_smram->old_size != 0x00000000)\n\t\t\tmem_mapping_recalc(temp_smram->old_host_base, temp_smram->old_size);\n\t\ttemp_smram->old_host_base = temp_smram->old_size = 0x00000000;\n\n\t\tnext = temp_smram->next;\n\t\ttemp_smram = next;\n\t}\n    }\n\n    temp_smram = base_smram;\n\n    while (temp_smram != NULL) {\n\tif (temp_smram->size != 0x00000000)\n\t\tmem_mapping_recalc(temp_smram->host_base, temp_smram->size);\n\n\tnext = temp_smram->next;\n\ttemp_smram = next;\n    }\n\n    flushmmucache();\n}", "path": "86Box/src/mem/smram.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Draw a row of text in 40-column mode */\n", "func_signal": "static void t1000_text_row40(t1000_t *t1000)", "code": "{\n\tuint32_t cols[2];\n\tint x, c;\n        uint8_t chr, attr;\n        int drawcursor;\n\tint cursorline;\n\tint bold;\n\tint blink;\n\tuint16_t addr;\n\tuint8_t sc;\n\tuint16_t ma = (t1000->cga.crtc[13] | (t1000->cga.crtc[12] << 8)) & 0x3fff;\n\tuint16_t ca = (t1000->cga.crtc[15] | (t1000->cga.crtc[14] << 8)) & 0x3fff;\n\n\tsc = (t1000->displine) & 7;\n\taddr = ((ma & ~1) + (t1000->displine >> 3) * 40) * 2;\n\tma += (t1000->displine >> 3) * 40;\n\n\tif ((t1000->cga.crtc[10] & 0x60) == 0x20)\n\t{\n\t\tcursorline = 0;\n\t}\n\telse\n\t{\n\t\tcursorline = ((t1000->cga.crtc[10] & 0x0F) <= sc) &&\n\t\t\t     ((t1000->cga.crtc[11] & 0x0F) >= sc);\n\t}\n\tfor (x = 0; x < 40; x++)\n        {\n\t\tchr  = t1000->vram[(addr + 2 * x) & 0x3FFF];\n\t\tattr = t1000->vram[(addr + 2 * x + 1) & 0x3FFF];\n                drawcursor = ((ma == ca) && cursorline &&\n\t\t\t(t1000->cga.cgamode & 8) && (t1000->cga.cgablink & 16));\n\n\t\tblink = ((t1000->cga.cgablink & 16) && (t1000->cga.cgamode & 0x20) &&\n\t\t\t(attr & 0x80) && !drawcursor);\n\n\t\tif (t1000->video_options & 1)\n\t\t\tbold = boldcols[attr] ? chr : chr + 256;\n\t\telse\n                        bold = boldcols[attr] ? chr + 256 : chr;\n\t\tif (t1000->video_options & 2)\n                        bold += 512;\n\n                if (t1000->cga.cgamode & 0x20)\t/* Blink */\n                {\n\t\t\tcols[1] = blinkcols[attr][1]; \t\t\n\t\t\tcols[0] = blinkcols[attr][0]; \t\t\n                        if (blink) cols[1] = cols[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcols[1] = normcols[attr][1];\n\t\t\tcols[0] = normcols[attr][0];\n\t\t}\n                if (drawcursor)\n                {\n                \tfor (c = 0; c < 8; c++)\n\t\t\t{\n                       \t\t((uint32_t *)buffer32->line[t1000->displine])[(x << 4) + c*2] = \n                       \t\t((uint32_t *)buffer32->line[t1000->displine])[(x << 4) + c*2 + 1] = cols[(fontdat[bold][sc] & (1 << (c ^ 7))) ? 1 : 0] ^ (blue ^ grey);\n\t\t\t}\n\t\t}\n                else\n                {\n                \tfor (c = 0; c < 8; c++)\n\t\t\t{\n\t\t\t\t((uint32_t *)buffer32->line[t1000->displine])[(x << 4) + c*2] = \n\t\t\t\t((uint32_t *)buffer32->line[t1000->displine])[(x << 4) + c*2+1] = cols[(fontdat[bold][sc] & (1 << (c ^ 7))) ? 1 : 0];\n\t\t\t}\n                }\n\t\t++ma;\n\t}\n}", "path": "86Box/src/machine/m_xt_t1000_vid.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/*Input handler for SysEx */\n", "func_signal": "int\nMPU401_InputSysex(void *p, uint8_t *buffer, uint32_t len, int abort)", "code": "{\n    mpu_t *mpu = (mpu_t *)p;\n    int i;\n    uint8_t val_ff = 0xff;\n\n    mpu401_log(\"MPU401 Input Sysex\\n\");\n\n    if (mpu->filter.sysex_in) {\n\tif (abort) {\n\t\tmpu->state.sysex_in_finished=1;\n\t\tmpu->rec_queue_used=0;/*reset also the input queue*/\n\t\treturn 0;\n\t}\n\tif (mpu->state.sysex_in_finished) {\n\t\tif (mpu->rec_queue_used>=MPU401_INPUT_QUEUE) \n\t\t\treturn len;\n\t\tMPU401_RecQueueBuffer(mpu, &val_ff, 1, 1);\n\t\tmpu->state.sysex_in_finished=0;\n\t\tmpu->clock.rec_counter=0;\n\t}\n\tif (mpu->rec_queue_used>=MPU401_INPUT_QUEUE) \n\t\treturn len;\n\tint available = MPU401_INPUT_QUEUE - mpu->rec_queue_used;\n\n\tif (available >= len) {\n\t\tMPU401_RecQueueBuffer(mpu, buffer, len, 1);\n\t\treturn 0;\n\t} else {\n\t\tMPU401_RecQueueBuffer(mpu,buffer, available, 1);\n\t\tif (mpu->state.sysex_in_finished) \n\t\t\treturn 0;\n\t\treturn (len - available);\n\t}\n    } else if (mpu->filter.sysex_thru && mpu->midi_thru) {\n\tmidi_raw_out_byte(0xf0);\n\tfor (i = 0; i < len; i++)\n\t\tmidi_raw_out_byte(*(buffer+i));\n    }\n    return 0;\n}", "path": "86Box/src/sound/snd_mpu401.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Enable SMRAM mappings according to flags for both normal and SMM modes. */\n", "func_signal": "void\nsmram_enable(smram_t *smr, uint32_t host_base, uint32_t ram_base, uint32_t size, int flags_normal, int flags_smm)", "code": "{\n    if (smr == NULL) {\n\tfatal(\"smram_add(): Invalid SMRAM mapping\\n\");\n\treturn;\n    }\n\n    if ((size != 0x00000000) && (flags_normal || flags_smm)) {\n\tsmr->host_base = host_base;\n\tsmr->ram_base = ram_base,\n\tsmr->size = size;\n\n\tmem_mapping_set_addr(&(smr->mapping), smr->host_base, smr->size);\n\tif (smr->ram_base < (1 << 30))\n\t\tmem_mapping_set_exec(&(smr->mapping), ram + smr->ram_base);\n\telse\n\t\tmem_mapping_set_exec(&(smr->mapping), ram2 + smr->ram_base - (1 << 30));\n\n\tsmram_map(0, host_base, size, flags_normal);\n\tsmram_map(1, host_base, size, flags_smm);\n    } else\n\tsmram_disable(smr);\n}", "path": "86Box/src/mem/smram.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Updates counters and requests new data on \"End of Input\" */\n", "func_signal": "static void\nMPU401_EOIHandler(void *priv)", "code": "{\n    mpu_t *mpu = (mpu_t *)priv;\n    uint8_t i;\n\n    mpu401_log(\"MPU-401 end of input callback\\n\");\n\t\n    timer_disable(&mpu->mpu401_eoi_callback);\n    mpu->state.eoi_scheduled = 0;\n    if (mpu->state.send_now) {\n\tmpu->state.send_now = 0;\n\tif (mpu->state.cond_req) {\n\t\tmpu->condbuf.counter = 0xf0;\n\t\tmpu->state.req_mask |= (1 << 9);\n\t} else UpdateTrack(mpu, mpu->state.track);\n    }\n\n    if (mpu->state.rec_copy || !mpu->state.sysex_in_finished) \n\treturn;\n\n    if (mpu->ext_irq_update)\n\tmpu->ext_irq_update(mpu->priv, 0);\n    else {\n\tmpu->state.irq_pending = 0;\n\tpicintc(1 << mpu->irq);\n    }\n\n    if (!(mpu->state.req_mask && mpu->clock.active))\n\treturn;\n\n    i = 0;\n    do {\n\tif (mpu->state.req_mask & (1 << i)) {\n\t\tMPU401_QueueByte(mpu, 0xf0 + i);\n\t\tmpu->state.req_mask &= ~(1 << i);\n\t\tbreak;\n\t}\n    } while ((i++) < 16);\n}", "path": "86Box/src/sound/snd_mpu401.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* update freq tree */\n", "func_signal": "static void\nstate_update(td0dsk_t *state, int c)", "code": "{\n    int i, j, k, l;\n\n    if (state->freq[R] == MAX_FREQ)\n\tstate_reconst(state);\n\n    c = state->prnt[c + T];\n\n    /* do it until reaching the root */\n    do {\n\tk = ++state->freq[c];\n\n\t/* swap nodes to keep the tree freq-ordered */\n\tif (k > state->freq[l = c + 1]) {\n\t\twhile (k > state->freq[++l]) {};\n\t\tl--;\n\t\tstate->freq[c] = state->freq[l];\n\t\tstate->freq[l] = k;\n\n\t\ti = state->son[c];\n\t\tstate->prnt[i] = l;\n\t\tif (i < T) state->prnt[i + 1] = l;\n\n\t\tj = state->son[l];\n\t\tstate->son[l] = i;\n\n\t\tstate->prnt[j] = c;\n\t\tif (j < T) state->prnt[j + 1] = c;\n\t\tstate->son[c] = j;\n\n\t\tc = l;\n\t}\n    } while ((c = state->prnt[c]) != 0);\n}", "path": "86Box/src/floppy/fdd_td0.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* DeCompression - split out initialization code to init_Decode() */\n", "func_signal": "static void\nstate_init_Decode(td0dsk_t *state)", "code": "{\n    int i;\n\n    state->getbuf = 0;\n    state->getlen = 0;\n    state->tdctl.ibufcnt= state->tdctl.ibufndx = 0; /* input buffer is empty */\n    state->tdctl.bufcnt = 0;\n\n    state_StartHuff(state);\n    for (i = 0; i < N - F; i++)\n\tstate->text_buf[i] = ' ';\n\n    state->tdctl.r = N - F;\n}", "path": "86Box/src/floppy/fdd_td0.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* reconstruct freq tree */\n", "func_signal": "static void\nstate_reconst(td0dsk_t *state)", "code": "{\n    int16_t i, j, k;\n    uint16_t f, l;\n\n    /* halven cumulative freq for leaf nodes */\n    j = 0;\n    for (i = 0; i < T; i++) {\n\tif (state->son[i] >= T) {\n\t\tstate->freq[j] = (state->freq[i] + 1) / 2;\n\t\tstate->son[j] = state->son[i];\n\t\tj++;\n\t}\n    }\n\n    /* make a tree : first, connect children nodes */\n    for (i = 0, j = N_CHAR; j < T; i += 2, j++) {\n\tk = i + 1;\n\tf = state->freq[j] = state->freq[i] + state->freq[k];\n\tfor (k = j - 1; f < state->freq[k]; k--) {};\n\tk++;\n\tl = (j - k) * 2;\n\n\t/* These *HAVE* to be memmove's as destination and source\n\t   can overlap, which memcpy can't handle. */\n\tmemmove(&state->freq[k + 1], &state->freq[k], l);\n\tstate->freq[k] = f;\n\tmemmove(&state->son[k + 1], &state->son[k], l);\n\tstate->son[k] = i;\n    }\n\n    /* connect parent nodes */\n    for (i = 0; i < T; i++) {\n\tif ((k = state->son[i]) >= T)\n\t\tstate->prnt[k] = i;\n\t  else\n\t\tstate->prnt[k] = state->prnt[k + 1] = i;\n    }\n}", "path": "86Box/src/floppy/fdd_td0.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Delete a SMRAM mapping. */\n", "func_signal": "void\nsmram_del(smram_t *smr)", "code": "{\n    /* Do a sanity check */\n    if ((base_smram == NULL) && (last_smram != NULL)) {\n\tfatal(\"smram_del(): NULL base SMRAM with non-NULL last SMRAM\\n\");\n\treturn;\n    } else if ((base_smram != NULL) && (last_smram == NULL)) {\n\tfatal(\"smram_del(): Non-NULL base SMRAM with NULL last SMRAM\\n\");\n\treturn;\n    } else if ((base_smram != NULL) && (base_smram->prev != NULL)) {\n\tfatal(\"smram_del(): Base SMRAM with a preceding SMRAM\\n\");\n\treturn;\n    } else if ((last_smram != NULL) && (last_smram->next != NULL)) {\n\tfatal(\"smram_del(): Last SMRAM with a following SMRAM\\n\");\n\treturn;\n    }\n\n    if (smr == NULL) {\n\tfatal(\"smram_del(): Invalid SMRAM mapping\\n\");\n\treturn;\n    }\n\n    /* Disable the entry. */\n    smram_disable(smr);\n\n    /* Zap it from the list. */\n    if (smr->prev != NULL)\n\tsmr->prev->next = smr->next;\n    if (smr->next != NULL)\n\tsmr->next->prev = smr->prev;\n\n    /* Check if it's the first or the last mapping. */\n    if (base_smram == smr)\n\tbase_smram = smr->next;\n    if (last_smram == smr)\n\tlast_smram = smr->prev;\n\n    free(smr);\n}", "path": "86Box/src/mem/smram.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* get a byte */\n", "func_signal": "static int\nstate_GetByte(td0dsk_t *state)", "code": "{\n    uint16_t i;\n\n    if (state_next_word(state) != 0)\n\treturn(-1);\n\n    i = state->getbuf;\n    state->getbuf <<= 8;\n    state->getlen -= 8;\n    i = i >> 8;\n\n    return((int) i);\n}", "path": "86Box/src/floppy/fdd_td0.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Checks if a SMRAM mapping is enabled or not. */\n", "func_signal": "int\nsmram_enabled(smram_t *smr)", "code": "{\n    int ret = 0;\n\n    if (smr == NULL)\n\tret = 0;\n    else\n\tret = (smr->size != 0x00000000);\n\n    return ret;\n}", "path": "86Box/src/mem/smram.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Disable all SMRAM mappings. */\n", "func_signal": "void\nsmram_disable_all(void)", "code": "{\n    smram_t *temp_smram = base_smram, *next;\n\n    while (temp_smram != NULL) {\n\tsmram_disable(temp_smram);\n\n\tnext = temp_smram->next;\n\ttemp_smram = next;\n    }\n}", "path": "86Box/src/mem/smram.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Map either the main or utility (Select) ROM into the memory space. */\n", "func_signal": "static uint8_t\naha154x_mmap(x54x_t *dev, uint8_t cmd)", "code": "{\n    aha_log(\"%s: MEMORY cmd=%02x\\n\", dev->name, cmd);\n\n    switch(cmd) {\n\tcase 0x26:\n\t\t/* Disable the mapper, so, set ROM1 active. */\n\t\tdev->bios.rom = dev->rom1;\n\t\tbreak;\n\n\tcase 0x27:\n\t\t/* Enable the mapper, so, set ROM2 active. */\n\t\tdev->bios.rom = dev->rom2;\n\t\tbreak;\n    }\n\n    return(0);\n}", "path": "86Box/src/scsi/scsi_aha154x.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/* Decoding/Uncompressing */\n", "func_signal": "static int\nstate_Decode(td0dsk_t *state, uint8_t *buf, int len)", "code": "{\n    int16_t c, pos;\n    int count;  /* was an unsigned long, seems unnecessary */\n\n    for (count = 0; count < len; ) {\n\tif (state->tdctl.bufcnt == 0) {\n\t\tif ((c = state_DecodeChar(state)) < 0)\n\t\t\treturn(count); /* fatal error */\n\t\tif (c < 256) {\n\t\t\t*(buf++) = c & 0xff;\n\t\t\tstate->text_buf[state->tdctl.r++] = c & 0xff;\n\t\t\tstate->tdctl.r &= (N - 1);\n\t\t\tcount++;\n\t\t} else {\n\t\t\tif ((pos = state_DecodePosition(state)) < 0)\n\t\t\t\treturn(count); /* fatal error */\n\t\t\tstate->tdctl.bufpos = (state->tdctl.r - pos - 1) & (N - 1);\n\t\t\tstate->tdctl.bufcnt = c - 255 + THRESHOLD;\n\t\t\tstate->tdctl.bufndx = 0;\n\t\t}\n\t} else {\n\t\t/* still chars from last string */\n\t\twhile (state->tdctl.bufndx < state->tdctl.bufcnt && count < len) {\n\t\t\tc = state->text_buf[(state->tdctl.bufpos + state->tdctl.bufndx) & (N - 1)];\n\t\t\t*(buf++) = c & 0xff;\n\t\t\tstate->tdctl.bufndx++;\n\t\t\tstate->text_buf[state->tdctl.r++] = c & 0xff;\n\t\t\tstate->tdctl.r &= (N - 1);\n\t\t\tcount++;\n\t\t}\n\n\t\t/* reset bufcnt after copy string from text_buf[] */\n\t\tif (state->tdctl.bufndx >= state->tdctl.bufcnt)\n\t\t\tstate->tdctl.bufndx = state->tdctl.bufcnt = 0;\n\t}\n    }\n\n    return(count); /* count == len, success */\n}", "path": "86Box/src/floppy/fdd_td0.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "86Box/86Box", "stars": 2229, "license": "gpl-2.0", "language": "c", "size": 129997}
{"docstring": "/**\n * Display a binary value in hexadecimal\n */\n", "func_signal": "void uart_hex(unsigned int d)", "code": "{\n    unsigned int n;\n    int c;\n    for(c=28;c>=0;c-=4) {\n        // get highest tetrad\n        n=(d>>c)&0xF;\n        // 0-9 => '0'-'9', 10-15 => 'A'-'F'\n        n+=n>9?0x37:0x30;\n        uart_send(n);\n    }\n}", "path": "raspi3-tutorial/05_uart0/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Get System Timer's counter\n */\n", "func_signal": "unsigned long get_system_timer()", "code": "{\n    unsigned int h=-1, l;\n    // we must read MMIO area as two separate 32 bit reads\n    h=*SYSTMR_HI;\n    l=*SYSTMR_LO;\n    // we have to repeat it if high word changed during read\n    if(h!=*SYSTMR_HI) {\n        h=*SYSTMR_HI;\n        l=*SYSTMR_LO;\n    }\n    // compose long int value\n    return ((unsigned long) h << 32) | l;\n}", "path": "raspi3-tutorial/15_writesector/delays.c", "commit_date": "2019-02-14 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Wait N microsec (ARM CPU only)\n */\n", "func_signal": "void wait_msec(unsigned int n)", "code": "{\n    register unsigned long f, t, r;\n    // get the current counter frequency\n    asm volatile (\"mrs %0, cntfrq_el0\" : \"=r\"(f));\n    // read the current counter\n    asm volatile (\"mrs %0, cntpct_el0\" : \"=r\"(t));\n    // calculate expire value for counter\n    t+=((f/1000)*n)/1000;\n    do{asm volatile (\"mrs %0, cntpct_el0\" : \"=r\"(r));}while(r<t);\n}", "path": "raspi3-tutorial/0D_readfile/delays.c", "commit_date": "2018-01-04 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Send a character\n */\n", "func_signal": "void uart_send(unsigned int c)", "code": "{\n    /* wait until we can send */\n    do{asm volatile(\"nop\");}while(*UART0_FR&0x20);\n    /* write the character to the buffer */\n    *UART0_DR=c;\n}", "path": "raspi3-tutorial/10_virtualmemory/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Wait N microsec (with BCM System Timer)\n */\n", "func_signal": "void wait_msec_st(unsigned int n)", "code": "{\n    unsigned long t=get_system_timer();\n    // we must check if it's non-zero, because qemu does not emulate\n    // system timer, and returning constant zero would mean infinite loop\n    if(t) while(get_system_timer() < t+n);\n}", "path": "raspi3-tutorial/15_writesector/delays.c", "commit_date": "2019-02-14 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Send a character\n */\n", "func_signal": "void uart_send(unsigned int c)", "code": "{\n    /* wait until we can send */\n    do{asm volatile(\"nop\");}while(*UART0_FR&0x20);\n    /* write the character to the buffer */\n    *UART0_DR=c;\n}", "path": "raspi3-tutorial/05_uart0/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Get System Timer's counter\n */\n", "func_signal": "unsigned long get_system_timer()", "code": "{\n    unsigned int h=-1, l;\n    // we must read MMIO area as two separate 32 bit reads\n    h=*SYSTMR_HI;\n    l=*SYSTMR_LO;\n    // we have to repeat it if high word changed during read\n    if(h!=*SYSTMR_HI) {\n        h=*SYSTMR_HI;\n        l=*SYSTMR_LO;\n    }\n    // compose long int value\n    return ((unsigned long) h << 32) | l;\n}", "path": "raspi3-tutorial/0D_readfile/delays.c", "commit_date": "2018-01-04 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Set baud rate and characteristics (115200 8N1) and map to GPIO\n */\n", "func_signal": "void uart_init()", "code": "{\n    register unsigned int r;\n\n    /* initialize UART */\n    *UART0_CR = 0;         // turn off UART0\n\n    /* set up clock for consistent divisor values */\n    mbox[0] = 9*4;\n    mbox[1] = MBOX_REQUEST;\n    mbox[2] = MBOX_TAG_SETCLKRATE; // set clock rate\n    mbox[3] = 12;\n    mbox[4] = 8;\n    mbox[5] = 2;           // UART clock\n    mbox[6] = 4000000;     // 4Mhz\n    mbox[7] = 0;           // clear turbo\n    mbox[8] = MBOX_TAG_LAST;\n    mbox_call(MBOX_CH_PROP);\n\n    /* map UART0 to GPIO pins */\n    r=*GPFSEL1;\n    r&=~((7<<12)|(7<<15)); // gpio14, gpio15\n    r|=(4<<12)|(4<<15);    // alt0\n    *GPFSEL1 = r;\n    *GPPUD = 0;            // enable pins 14 and 15\n    r=150; while(r--) { asm volatile(\"nop\"); }\n    *GPPUDCLK0 = (1<<14)|(1<<15);\n    r=150; while(r--) { asm volatile(\"nop\"); }\n    *GPPUDCLK0 = 0;        // flush GPIO setup\n\n    *UART0_ICR = 0x7FF;    // clear interrupts\n    *UART0_IBRD = 2;       // 115200 baud\n    *UART0_FBRD = 0xB;\n    *UART0_LCRH = 0b11<<5; // 8n1\n    *UART0_CR = 0x301;     // enable Tx, Rx, FIFO\n}", "path": "raspi3-tutorial/05_uart0/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Send a character\n */\n", "func_signal": "void uart_send(unsigned int c)", "code": "{\n    /* wait until we can send */\n    do{asm volatile(\"nop\");}while(*UART0_FR&0x20);\n    /* write the character to the buffer */\n    *UART0_DR=c;\n}", "path": "raspi3-tutorial/14_raspbootin64/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Display a string\n */\n", "func_signal": "void uart_puts(char *s)", "code": "{\n    while(*s) {\n        /* convert newline to carrige return + newline */\n        if(*s=='\\n')\n            uart_send('\\r');\n        uart_send(*s++);\n    }\n}", "path": "raspi3-tutorial/05_uart0/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Receive a character\n */\n", "func_signal": "char uart_getc()", "code": "{\n    char r;\n    /* wait until something is in the buffer */\n    do{asm volatile(\"nop\");}while(*UART0_FR&0x10);\n    /* read it and return */\n    r=(char)(*UART0_DR);\n    /* convert carrige return to newline */\n    return r=='\\r'?'\\n':r;\n}", "path": "raspi3-tutorial/10_virtualmemory/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Variable length arguments\n */\n", "func_signal": "unsigned int sprintf(char *dst, char* fmt, ...)", "code": "{\n    __builtin_va_list args;\n    __builtin_va_start(args, fmt);\n    return vsprintf(dst,fmt,args);\n}", "path": "raspi3-tutorial/13_debugger/sprintf.c", "commit_date": "2018-01-22 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Receive a character\n */\n", "func_signal": "char uart_getc()", "code": "{\n    char r;\n    /* wait until something is in the buffer */\n    do{asm volatile(\"nop\");}while(*UART0_FR&0x10);\n    /* read it and return */\n    r=(char)(*UART0_DR);\n    /* convert carrige return to newline */\n    return r=='\\r'?'\\n':r;\n}", "path": "raspi3-tutorial/05_uart0/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * minimal sprintf implementation\n */\n", "func_signal": "unsigned int vsprintf(char *dst, char* fmt, __builtin_va_list args)", "code": "{\n    long int arg;\n    int len, sign, i;\n    char *p, *orig=dst, tmpstr[19];\n\n    // failsafes\n    if(dst==(void*)0 || fmt==(void*)0) {\n        return 0;\n    }\n\n    // main loop\n    arg = 0;\n    while(*fmt) {\n        // argument access\n        if(*fmt=='%') {\n            fmt++;\n            // literal %\n            if(*fmt=='%') {\n                goto put;\n            }\n            len=0;\n            // size modifier\n            while(*fmt>='0' && *fmt<='9') {\n                len *= 10;\n                len += *fmt-'0';\n                fmt++;\n            }\n            // skip long modifier\n            if(*fmt=='l') {\n                fmt++;\n            }\n            // character\n            if(*fmt=='c') {\n                arg = __builtin_va_arg(args, int);\n                *dst++ = (char)arg;\n                fmt++;\n                continue;\n            } else\n            // decimal number\n            if(*fmt=='d') {\n                arg = __builtin_va_arg(args, int);\n                // check input\n                sign=0;\n                if((int)arg<0) {\n                    arg*=-1;\n                    sign++;\n                }\n                if(arg>99999999999999999L) {\n                    arg=99999999999999999L;\n                }\n                // convert to string\n                i=18;\n                tmpstr[i]=0;\n                do {\n                    tmpstr[--i]='0'+(arg%10);\n                    arg/=10;\n                } while(arg!=0 && i>0);\n                if(sign) {\n                    tmpstr[--i]='-';\n                }\n                // padding, only space\n                if(len>0 && len<18) {\n                    while(i>18-len) {\n                        tmpstr[--i]=' ';\n                    }\n                }\n                p=&tmpstr[i];\n                goto copystring;\n            } else\n            // hex number\n            if(*fmt=='x') {\n                arg = __builtin_va_arg(args, long int);\n                // convert to string\n                i=16;\n                tmpstr[i]=0;\n                do {\n                    char n=arg & 0xf;\n                    // 0-9 => '0'-'9', 10-15 => 'A'-'F'\n                    tmpstr[--i]=n+(n>9?0x37:0x30);\n                    arg>>=4;\n                } while(arg!=0 && i>0);\n                // padding, only leading zeros\n                if(len>0 && len<=16) {\n                    while(i>16-len) {\n                        tmpstr[--i]='0';\n                    }\n                }\n                p=&tmpstr[i];\n                goto copystring;\n            } else\n            // string\n            if(*fmt=='s') {\n                p = __builtin_va_arg(args, char*);\ncopystring:     if(p==(void*)0) {\n                    p=\"(null)\";\n                }\n                while(*p) {\n                    *dst++ = *p++;\n                }\n            }\n        } else {\nput:        *dst++ = *fmt;\n        }\n        fmt++;\n    }\n    *dst=0;\n    // number of bytes written\n    return dst-orig;\n}", "path": "raspi3-tutorial/13_debugger/sprintf.c", "commit_date": "2018-01-22 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Display a binary value in hexadecimal\n */\n", "func_signal": "void uart_hex(unsigned int d)", "code": "{\n    unsigned int n;\n    int c;\n    for(c=28;c>=0;c-=4) {\n        // get highest tetrad\n        n=(d>>c)&0xF;\n        // 0-9 => '0'-'9', 10-15 => 'A'-'F'\n        n+=n>9?0x37:0x30;\n        uart_send(n);\n    }\n}", "path": "raspi3-tutorial/10_virtualmemory/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Set baud rate and characteristics (115200 8N1) and map to GPIO\n */\n", "func_signal": "void uart_init()", "code": "{\n    register unsigned int r;\n\n    /* initialize UART */\n    *UART0_CR = 0;         // turn off UART0\n\n    /* set up clock for consistent divisor values */\n    mbox[0] = 9*4;\n    mbox[1] = MBOX_REQUEST;\n    mbox[2] = MBOX_TAG_SETCLKRATE; // set clock rate\n    mbox[3] = 12;\n    mbox[4] = 8;\n    mbox[5] = 2;           // UART clock\n    mbox[6] = 4000000;     // 4Mhz\n    mbox[7] = 0;           // clear turbo\n    mbox[8] = MBOX_TAG_LAST;\n    mbox_call(MBOX_CH_PROP);\n\n    /* map UART0 to GPIO pins */\n    r=*GPFSEL1;\n    r&=~((7<<12)|(7<<15)); // gpio14, gpio15\n    r|=(4<<12)|(4<<15);    // alt0\n    *GPFSEL1 = r;\n    *GPPUD = 0;            // enable pins 14 and 15\n    r=150; while(r--) { asm volatile(\"nop\"); }\n    *GPPUDCLK0 = (1<<14)|(1<<15);\n    r=150; while(r--) { asm volatile(\"nop\"); }\n    *GPPUDCLK0 = 0;        // flush GPIO setup\n\n    *UART0_ICR = 0x7FF;    // clear interrupts\n    *UART0_IBRD = 2;       // 115200 baud\n    *UART0_FBRD = 0xB;\n    *UART0_LCRH = 0b11<<5; // 8n1\n    *UART0_CR = 0x301;     // enable Tx, Rx, FIFO\n}", "path": "raspi3-tutorial/14_raspbootin64/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Wait N microsec (ARM CPU only)\n */\n", "func_signal": "void wait_msec(unsigned int n)", "code": "{\n    register unsigned long f, t, r;\n    // get the current counter frequency\n    asm volatile (\"mrs %0, cntfrq_el0\" : \"=r\"(f));\n    // read the current counter\n    asm volatile (\"mrs %0, cntpct_el0\" : \"=r\"(t));\n    // calculate expire value for counter\n    t+=((f/1000)*n)/1000;\n    do{asm volatile (\"mrs %0, cntpct_el0\" : \"=r\"(r));}while(r<t);\n}", "path": "raspi3-tutorial/15_writesector/delays.c", "commit_date": "2019-02-14 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Receive a character\n */\n", "func_signal": "char uart_getc()", "code": "{\n    /* wait until something is in the buffer */\n    do{asm volatile(\"nop\");}while(*UART0_FR&0x10);\n    /* read it and return */\n    return (char)(*UART0_DR);\n}", "path": "raspi3-tutorial/14_raspbootin64/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Wait N microsec (with BCM System Timer)\n */\n", "func_signal": "void wait_msec_st(unsigned int n)", "code": "{\n    unsigned long t=get_system_timer();\n    // we must check if it's non-zero, because qemu does not emulate\n    // system timer, and returning constant zero would mean infinite loop\n    if(t) while(get_system_timer() < t+n);\n}", "path": "raspi3-tutorial/0D_readfile/delays.c", "commit_date": "2018-01-04 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n * Set baud rate and characteristics (115200 8N1) and map to GPIO\n */\n", "func_signal": "void uart_init()", "code": "{\n    register unsigned int r;\n\n    /* initialize UART */\n    *UART0_CR = 0;         // turn off UART0\n\n    /* set up clock for consistent divisor values */\n    mbox[0] = 9*4;\n    mbox[1] = MBOX_REQUEST;\n    mbox[2] = MBOX_TAG_SETCLKRATE; // set clock rate\n    mbox[3] = 12;\n    mbox[4] = 8;\n    mbox[5] = 2;           // UART clock\n    mbox[6] = 4000000;     // 4Mhz\n    mbox[7] = 0;           // clear turbo\n    mbox[8] = MBOX_TAG_LAST;\n    mbox_call(MBOX_CH_PROP);\n\n    /* map UART0 to GPIO pins */\n    r=*GPFSEL1;\n    r&=~((7<<12)|(7<<15)); // gpio14, gpio15\n    r|=(4<<12)|(4<<15);    // alt0\n    *GPFSEL1 = r;\n    *GPPUD = 0;            // enable pins 14 and 15\n    r=150; while(r--) { asm volatile(\"nop\"); }\n    *GPPUDCLK0 = (1<<14)|(1<<15);\n    r=150; while(r--) { asm volatile(\"nop\"); }\n    *GPPUDCLK0 = 0;        // flush GPIO setup\n\n    *UART0_ICR = 0x7FF;    // clear interrupts\n    *UART0_IBRD = 2;       // 115200 baud\n    *UART0_FBRD = 0xB;\n    *UART0_LCRH = 0b11<<5; // 8n1\n    *UART0_CR = 0x301;     // enable Tx, Rx, FIFO\n}", "path": "raspi3-tutorial/10_virtualmemory/uart.c", "commit_date": "2018-11-10 00:00:00", "repo_name": "bztsrc/raspi3-tutorial", "stars": 2629, "license": "mit", "language": "c", "size": 535}
{"docstring": "/**\n  * @brief Run flash all one verification and get result.\n  * @param[in] u32addr   Starting flash address. It must be a page aligned address.\n  * @param[in] u32count  Byte count of flash to be calculated. It must be multiple of 512 bytes.\n  * @retval   READ_ALLONE_YES      The contents of verified flash area are 0xFFFFFFFF.\n  * @retval   READ_ALLONE_NOT  Some contents of verified flash area are not 0xFFFFFFFF.\n  * @retval   READ_ALLONE_CMD_FAIL  Unexpected error occurred.\n  */\n", "func_signal": "uint32_t  FMC_CheckAllOne(uint32_t u32addr, uint32_t u32count)", "code": "{\n    uint32_t  ret = READ_ALLONE_CMD_FAIL;\n    FMC->ISPSTS = 0x80UL;   /* clear check all one bit */\n    FMC->ISPCMD   = FMC_ISPCMD_RUN_ALL1;\n    FMC->ISPADDR  = u32addr;\n    FMC->ISPDAT   = u32count;\n    FMC->ISPTRG   = FMC_ISPTRG_ISPGO_Msk;\n\n    while (FMC->ISPSTS & FMC_ISPSTS_ISPBUSY_Msk) { }\n\n    do {\n        FMC->ISPCMD = FMC_ISPCMD_READ_ALL1;\n        FMC->ISPADDR    = u32addr;\n        FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n        while (FMC->ISPSTS & FMC_ISPSTS_ISPBUSY_Msk) { }\n    } while (FMC->ISPDAT == 0UL);\n\n    if (FMC->ISPDAT == READ_ALLONE_YES) {\n        ret = FMC->ISPDAT;\n    }\n\n    if (FMC->ISPDAT == READ_ALLONE_NOT) {\n        ret = FMC->ISPDAT;\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief      Set boot source from LDROM or APROM after next software reset\n  * @param[in]  i32BootSrc\n  *                1: Boot from LDROM\n  *                0: Boot from APROM\n  * @return    None\n  * @details   This function is used to switch APROM boot or LDROM boot. User need to call\n  *            FMC_SetBootSource to select boot source first, then use CPU reset or\n  *            System Reset Request to reset system.\n  */\n", "func_signal": "void FMC_SetBootSource(int32_t i32BootSrc)", "code": "{\n    if (i32BootSrc) {\n        FMC->ISPCTL |= FMC_ISPCTL_BS_Msk; /* Boot from LDROM */\n    } else {\n        FMC->ISPCTL &= ~FMC_ISPCTL_BS_Msk;/* Boot from APROM */\n    }\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute FMC_ISPCMD_READ command to read a word from flash.\n  * @param[in]  u32Addr Address of the flash location to be read.\n  *             It must be a word aligned address.\n  * @return The word data read from specified flash address.\n  */\n", "func_signal": "uint32_t FMC_Read(uint32_t u32Addr)", "code": "{\n    FMC->ISPCMD = FMC_ISPCMD_READ;\n    FMC->ISPADDR = u32Addr;\n    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n    while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n    return FMC->ISPDAT;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute FMC_ISPCMD_BANK_ERASE command to erase a flash block.\n  * @param[in]  u32BankAddr Base address of the flash bank to be erased.\n  * @return ISP page erase success or not.\n  * @retval   0  Success\n  * @retval   -1  Erase failed\n  */\n", "func_signal": "int32_t FMC_Erase_Bank(uint32_t u32BankAddr)", "code": "{\n    int32_t  ret = 0;\n    FMC->ISPCMD = FMC_ISPCMD_BANK_ERASE;\n    FMC->ISPADDR = u32BankAddr;\n    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n    while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n    if (FMC->ISPCTL & FMC_ISPCTL_ISPFF_Msk) {\n        FMC->ISPCTL |= FMC_ISPCTL_ISPFF_Msk;\n        ret = -1;\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief  Read the 64-bits data from the specified OTP.\n  * @param[in] otp_num    The OTP number.\n  * @param[in] low_word   Low word of the 64-bits data.\n  * @param[in] high_word   Low word of the 64-bits data.\n  * @retval   0   Success\n  * @retval   -1  Read failed.\n  * @retval   -2  Invalid OTP number.\n  */\n", "func_signal": "int32_t FMC_Read_OTP(uint32_t otp_num, uint32_t *low_word, uint32_t *high_word)", "code": "{\n    int32_t  ret = 0;\n\n    if (otp_num > 255UL) {\n        ret = -2;\n    }\n\n    if (ret == 0) {\n        FMC->ISPCMD = FMC_ISPCMD_READ_64;\n        FMC->ISPADDR    = FMC_OTP_BASE + otp_num * 8UL ;\n        FMC->ISPDAT = 0x0UL;\n        FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n        while (FMC->ISPSTS & FMC_ISPSTS_ISPBUSY_Msk) { }\n\n        if (FMC->ISPSTS & FMC_ISPSTS_ISPFF_Msk) {\n            FMC->ISPSTS |= FMC_ISPSTS_ISPFF_Msk;\n            ret = -1;\n        } else {\n            *low_word = FMC->MPDAT0;\n            *high_word = FMC->MPDAT1;\n        }\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief   Program Multi-Word data into specified address of flash.\n  * @param[in]  u32Addr    Start flash address in APROM where the data chunk to be programmed into.\n  *                        This address must be 8-bytes aligned to flash address.\n  * @param[in]  pu32Buf    Buffer that carry the data chunk.\n  * @param[in]  u32Len     Length of the data chunk in bytes.\n  * @retval   >=0  Number of data bytes were programmed.\n  * @return   -1   Invalid address.\n  */\n", "func_signal": "int32_t FMC_WriteMultiple(uint32_t u32Addr, uint32_t pu32Buf[], uint32_t u32Len)", "code": "{\n    int   i, idx, retval = 0;\n\n    if ((u32Addr >= FMC_APROM_END) || ((u32Addr % 8) != 0)) {\n        return -1;\n    }\n\n    u32Len = u32Len - (u32Len % 8);         /* u32Len must be multiple of 8. */\n    idx = 0;\n\n    while (u32Len >= 8) {\n        FMC->ISPADDR = u32Addr;\n        FMC->MPDAT0  = pu32Buf[idx++];\n        FMC->MPDAT1  = pu32Buf[idx++];\n        FMC->MPDAT2  = pu32Buf[idx++];\n        FMC->MPDAT3  = pu32Buf[idx++];\n        FMC->ISPCMD  = FMC_ISPCMD_PROGRAM_MUL;\n        FMC->ISPTRG  = FMC_ISPTRG_ISPGO_Msk;\n\n        for (i = 16; i < FMC_MULTI_WORD_PROG_LEN;) {\n            while (FMC->MPSTS & (FMC_MPSTS_D0_Msk | FMC_MPSTS_D1_Msk))\n                ;\n\n            retval += 8;\n            u32Len -= 8;\n\n            if (u32Len < 8) {\n                return retval;\n            }\n\n            if (!(FMC->MPSTS & FMC_MPSTS_MPBUSY_Msk)) {\n                /* printf(\"    [WARNING] busy cleared after D0D1 cleared!\\n\"); */\n                i += 8;\n                break;\n            }\n\n            FMC->MPDAT0 = pu32Buf[idx++];\n            FMC->MPDAT1 = pu32Buf[idx++];\n\n            if (i == FMC_MULTI_WORD_PROG_LEN / 4) {\n                break;    // done\n            }\n\n            while (FMC->MPSTS & (FMC_MPSTS_D2_Msk | FMC_MPSTS_D3_Msk))\n                ;\n\n            retval += 8;\n            u32Len -= 8;\n\n            if (u32Len < 8) {\n                return retval;\n            }\n\n            if (!(FMC->MPSTS & FMC_MPSTS_MPBUSY_Msk)) {\n                /* printf(\"    [WARNING] busy cleared after D2D3 cleared!\\n\"); */\n                i += 8;\n                break;\n            }\n\n            FMC->MPDAT2 = pu32Buf[idx++];\n            FMC->MPDAT3 = pu32Buf[idx++];\n        }\n\n        if (i != FMC_MULTI_WORD_PROG_LEN) {\n            /* printf(\"    [WARNING] Multi-word program interrupted at 0x%x !!\\n\", i); */\n            return retval;\n        }\n\n        while (FMC->MPSTS & FMC_MPSTS_MPBUSY_Msk) ;\n\n        u32Addr += FMC_MULTI_WORD_PROG_LEN;\n    }\n\n    return retval;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief  Lock the specified OTP.\n  * @param[in] otp_num    The OTP number.\n  * @retval   0   Success\n  * @retval   -1  Failed to write OTP lock bits.\n  * @retval   -2  Invalid OTP number.\n  */\n", "func_signal": "int32_t FMC_Lock_OTP(uint32_t otp_num)", "code": "{\n    int32_t  ret = 0;\n\n    if (otp_num > 255UL) {\n        ret = -2;\n    }\n\n    if (ret == 0) {\n        FMC->ISPCMD = FMC_ISPCMD_PROGRAM;\n        FMC->ISPADDR = FMC_OTP_BASE + 0x800UL + otp_num * 4UL;\n        FMC->ISPDAT = 0UL;\n        FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n        while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n        if (FMC->ISPSTS & FMC_ISPSTS_ISPFF_Msk) {\n            FMC->ISPSTS |= FMC_ISPSTS_ISPFF_Msk;\n            ret = -1;\n        }\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute FMC_ISPCMD_PAGE_ERASE command to erase a flash page. The page size is 4096 bytes.\n  * @param[in]  u32PageAddr Address of the flash page to be erased.\n  *             It must be a 4096 bytes aligned address.\n  * @return ISP page erase success or not.\n  * @retval   0  Success\n  * @retval   -1  Erase failed\n  */\n", "func_signal": "int32_t FMC_Erase(uint32_t u32PageAddr)", "code": "{\n    int32_t  ret = 0;\n\n    if (u32PageAddr == FMC_SPROM_BASE) {\n        ret = FMC_Erase_SPROM();\n    }\n\n    if (ret == 0) {\n        FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE;\n        FMC->ISPADDR = u32PageAddr;\n        FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n        while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n        if (FMC->ISPCTL & FMC_ISPCTL_ISPFF_Msk) {\n            FMC->ISPCTL |= FMC_ISPCTL_ISPFF_Msk;\n            ret = -1;\n        }\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/* This function resets some microcontroller peripherals to reset\n * hardware configuration to ensure that the USB In-System Programming module\n * will work properly. It is normally called from reset and assumes some reset\n * configuration settings for the MCU.\n * Some of the peripheral configurations may be redundant in your specific\n * project.\n */\n", "func_signal": "void iap_reinvoke(void)", "code": "{\n    /* make sure USB clock is turned on before calling ISP */\n    LPC_SYSCON->SYSAHBCLKCTRL |= 0x04000;\n    /* make sure 32-bit Timer 1 is turned on before calling ISP */\n    LPC_SYSCON->SYSAHBCLKCTRL |= 0x00400;\n    /* make sure GPIO clock is turned on before calling ISP */\n    LPC_SYSCON->SYSAHBCLKCTRL |= 0x00040;\n    /* make sure IO configuration clock is turned on before calling ISP */\n    LPC_SYSCON->SYSAHBCLKCTRL |= 0x10000;\n    /* make sure AHB clock divider is 1:1 */\n    LPC_SYSCON->SYSAHBCLKDIV = 1;\n    /* Send Reinvoke ISP command to ISP entry point*/\n    iap_op.cmd = 57;\n    init_msdstate();\t\t\t\t\t /* Initialize Storage state machine */\n    /* Set stack pointer to ROM value (reset default) This must be the last\n     * piece of code executed before calling ISP, because most C expressions\n     * and function returns will fail after the stack pointer is changed.\n     * In addition ensure the CONTROL register is set to 0 so the MSP is\n     * used rather than the PSP.\n     */\n    __set_MSP(*((volatile uint32_t *)0x00000000));\n    __set_CONTROL(0);\n    /* Enter ISP. We call \"iap_entry\" to enter ISP because the ISP entry is done\n     * through the same command interface as IAP.\n     */\n    iap_entry(&iap_op.cmd, &iap_op.stat);\n    // Not supposed to come back!\n}", "path": "DAPLink/source/hic_hal/nxp/lpc11u35/iap.c", "commit_date": "2017-04-04 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute FMC_ISPCMD_READ command to read User Configuration.\n  * @param[out]  u32Config A two-word array.\n  *              u32Config[0] holds CONFIG0, while u32Config[1] holds CONFIG1.\n  * @param[in] u32Count Available word count in u32Config.\n  * @return Success or not.\n  * @retval   0  Success.\n  * @retval   -1  Invalid parameter.\n  */\n", "func_signal": "int32_t FMC_ReadConfig(uint32_t u32Config[], uint32_t u32Count)", "code": "{\n    int32_t   ret = 0;\n    u32Config[0] = FMC_Read(FMC_CONFIG_BASE);\n\n    if (u32Count < 2UL) {\n        ret = -1;\n    } else {\n        u32Config[1] = FMC_Read(FMC_CONFIG_BASE + 4UL);\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute ISP FMC_ISPCMD_PROGRAM_64 to program a double-word to flash.\n  * @param[in]  u32addr Address of the flash location to be programmed.\n  *             It must be a double-word aligned address.\n  * @param[in]  u32data0   The word data to be programmed to flash address u32addr.\n  * @param[in]  u32data1   The word data to be programmed to flash address u32addr+4.\n  * @return   0   Success\n  * @return   -1  Failed\n  */\n", "func_signal": "int32_t FMC_Write8Bytes(uint32_t u32addr, uint32_t u32data0, uint32_t u32data1)", "code": "{\n    int32_t  ret = 0;\n    FMC->ISPCMD  = FMC_ISPCMD_PROGRAM_64;\n    FMC->ISPADDR = u32addr;\n    FMC->MPDAT0  = u32data0;\n    FMC->MPDAT1  = u32data1;\n    FMC->ISPTRG  = FMC_ISPTRG_ISPGO_Msk;\n\n    while (FMC->ISPSTS & FMC_ISPSTS_ISPBUSY_Msk) { }\n\n    if (FMC->ISPSTS & FMC_ISPSTS_ISPFF_Msk) {\n        FMC->ISPSTS |= FMC_ISPSTS_ISPFF_Msk;\n        ret = -1;\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Program a 64-bits data to the specified OTP.\n  * @param[in] otp_num    The OTP number.\n  * @param[in] low_word   Low word of the 64-bits data.\n  * @param[in] high_word   Low word of the 64-bits data.\n  * @retval   0   Success\n  * @retval   -1  Program failed.\n  * @retval   -2  Invalid OTP number.\n  */\n", "func_signal": "int32_t FMC_Write_OTP(uint32_t otp_num, uint32_t low_word, uint32_t high_word)", "code": "{\n    int32_t  ret = 0;\n\n    if (otp_num > 255UL) {\n        ret = -2;\n    }\n\n    if (ret == 0) {\n        FMC->ISPCMD = FMC_ISPCMD_PROGRAM;\n        FMC->ISPADDR = FMC_OTP_BASE + otp_num * 8UL;\n        FMC->ISPDAT = low_word;\n        FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n        while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n        if (FMC->ISPSTS & FMC_ISPSTS_ISPFF_Msk) {\n            FMC->ISPSTS |= FMC_ISPSTS_ISPFF_Msk;\n            ret = -1;\n        }\n    }\n\n    if (ret == 0) {\n        FMC->ISPCMD = FMC_ISPCMD_PROGRAM;\n        FMC->ISPADDR = FMC_OTP_BASE + otp_num * 8UL + 4UL;\n        FMC->ISPDAT = high_word;\n        FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n        while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n        if (FMC->ISPSTS & FMC_ISPSTS_ISPFF_Msk) {\n            FMC->ISPSTS |= FMC_ISPSTS_ISPFF_Msk;\n            ret = -1;\n        }\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute FMC_ISPCMD_BLOCK_ERASE command to erase a flash block. The block size is 4 pages.\n  * @param[in]  u32BlockAddr  Address of the flash block to be erased.\n  *             It must be a 4 pages aligned address.\n  * @return ISP page erase success or not.\n  * @retval   0  Success\n  * @retval   -1  Erase failed\n  */\n", "func_signal": "int32_t FMC_Erase_Block(uint32_t u32BlockAddr)", "code": "{\n    int32_t  ret = 0;\n    FMC->ISPCMD = FMC_ISPCMD_BLOCK_ERASE;\n    FMC->ISPADDR = u32BlockAddr;\n    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n    while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n    if (FMC->ISPCTL & FMC_ISPCTL_ISPFF_Msk) {\n        FMC->ISPCTL |= FMC_ISPCTL_ISPFF_Msk;\n        ret = -1;\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n * @brief \t\tConfigure pin function\n * @param[in]\tport\tPort number, should be: 0..15\n * @param[in]\tpin\tPin number, should be: 0..31\n * @param[in]\tmode\tPin mode, should be:\n * \t\t\t\t\t- MD_PUP\t:Pull-up enabled\n * \t\t\t\t\t- MD_BUK\t:Plain input\n * \t\t\t\t\t- MD_PLN\t:Repeater mode\n * \t\t\t\t\t- MD_PDN\t:Pull-down enabled\n * \t\t\t\t\t- MD_EHS        :Slew rate\n * \t\t\t\t\t- MD_EZI        :Input buffer enable\n * \t\t\t\t\t- MD_ZI         :Glitch filter enabled\n * \t\t\t\t\t- MD_EHD0       :High drive  8 mA\n * \t\t\t\t\t- MD_EHD1       :High drive 14 mA\n * \t\t\t\t\t- MD_EHD2       :High drive 20 mA\n * @param[in]\tfunc \tFunction mode, should be:\n * \t\t\t\t\t- FUNC0\t\t:Function 0\n * \t\t\t\t\t- FUNC1\t\t:Function 1\n * \t\t\t\t\t- FUNC2\t\t:Function 2\n * \t\t\t\t\t- FUNC3\t\t:Function 3\n * \t\t\t\t\t- FUNC4\t\t:Function 4\n * \t\t\t\t\t- FUNC5\t\t:Function 5\n * \t\t\t\t\t- FUNC6\t\t:Function 6\n * \t\t\t\t\t- FUNC7\t\t:Function 7\n * @return\t\tNone\n **********************************************************************/\n", "func_signal": "void scu_pinmux(uint8_t port, uint8_t pin, uint8_t mode, uint8_t func)", "code": "{\n    uint32_t *scu_base = (uint32_t *)(LPC_SCU_BASE);\n    scu_base[(PORT_OFFSET * port + PIN_OFFSET * pin) / 4] = mode + func;\n}", "path": "DAPLink/source/hic_hal/nxp/lpc4322/lpc43xx_scu.c", "commit_date": "2018-11-02 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Get the current boot source.\n  * @return The current boot source.\n  * @retval   0  Is boot from APROM.\n  * @retval   1  Is boot from LDROM.\n  */\n", "func_signal": "int32_t FMC_GetBootSource(void)", "code": "{\n    int32_t  ret = 0;\n\n    if (FMC->ISPCTL & FMC_ISPCTL_BS_Msk) {\n        ret = 1;\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute FMC_ISPCMD_PAGE_ERASE command to erase SPROM. The page size is 4096 bytes.\n  * @return   SPROM page erase success or not.\n  * @retval   0  Success\n  * @retval   -1  Erase failed\n  */\n", "func_signal": "int32_t FMC_Erase_SPROM(void)", "code": "{\n    int32_t  ret = 0;\n    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE;\n    FMC->ISPADDR = FMC_SPROM_BASE;\n    FMC->ISPDAT = 0x0055AA03UL;\n    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n    while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n    if (FMC->ISPCTL & FMC_ISPCTL_ISPFF_Msk) {\n        FMC->ISPCTL |= FMC_ISPCTL_ISPFF_Msk;\n        ret = -1;\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute ISP FMC_ISPCMD_PROGRAM to program a word to flash.\n  * @param[in]  u32Addr Address of the flash location to be programmed.\n  *             It must be a word aligned address.\n  * @param[in]  u32Data The word data to be programmed.\n  * @return None\n  */\n", "func_signal": "void FMC_Write(uint32_t u32Addr, uint32_t u32Data)", "code": "{\n    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;\n    FMC->ISPADDR = u32Addr;\n    FMC->ISPDAT = u32Data;\n    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n    while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief  Check the OTP is locked or not.\n  * @param[in] otp_num    The OTP number.\n  * @retval   1   OTP is locked.\n  * @retval   0   OTP is not locked.\n  * @retval   -1  Failed to read OTP lock bits.\n  * @retval   -2  Invalid OTP number.\n  */\n", "func_signal": "int32_t FMC_Is_OTP_Locked(uint32_t otp_num)", "code": "{\n    int32_t  ret = 0;\n\n    if (otp_num > 255UL) {\n        ret = -2;\n    }\n\n    if (ret == 0) {\n        FMC->ISPCMD = FMC_ISPCMD_READ;\n        FMC->ISPADDR = FMC_OTP_BASE + 0x800UL + otp_num * 4UL;\n        FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;\n\n        while (FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) { }\n\n        if (FMC->ISPSTS & FMC_ISPSTS_ISPFF_Msk) {\n            FMC->ISPSTS |= FMC_ISPSTS_ISPFF_Msk;\n            ret = -1;\n        } else {\n            if (FMC->ISPDAT != 0xFFFFFFFFUL) {\n                ret = 1;   /* Lock work was progrmmed. OTP was locked. */\n            }\n        }\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief Execute ISP commands to erase then write User Configuration.\n  * @param[in] u32Config   A two-word array.\n  *            u32Config[0] holds CONFIG0, while u32Config[1] holds CONFIG1.\n  * @param[in] u32Count  Always be 2 in this BSP.\n  * @return Success or not.\n  * @retval   0  Success.\n  * @retval   -1  Invalid parameter.\n  */\n", "func_signal": "int32_t FMC_WriteConfig(uint32_t u32Config[], uint32_t u32Count)", "code": "{\n    FMC_ENABLE_CFG_UPDATE();\n    FMC_Erase(FMC_CONFIG_BASE);\n    FMC_Write(FMC_CONFIG_BASE, u32Config[0]);\n    FMC_Write(FMC_CONFIG_BASE + 4UL, u32Config[1]);\n    FMC_DISABLE_CFG_UPDATE();\n    return 0;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/**\n  * @brief    Setup security key.\n  * @param[in] key      Key 0~2 to be setup.\n  * @param[in] kpmax    Maximum unmatched power-on counting number.\n  * @param[in] kemax    Maximum unmatched counting number.\n  * @param[in] lock_CONFIG   1: Security key lock CONFIG to write-protect. 0: Don't lock CONFIG.\n  * @param[in] lock_SPROM    1: Security key lock SPROM to write-protect. 0: Don't lock SPROM.\n  * @retval   0     Success.\n  * @retval   -1    Key is locked. Cannot overwrite the current key.\n  * @retval   -2    Failed to erase flash.\n  * @retval   -3    Failed to program key.\n  * @retval   -4    Key lock function failed.\n  * @retval   -5    CONFIG lock function failed.\n  * @retval   -6    SPROM lock function failed.\n  * @retval   -7    KPMAX function failed.\n  * @retval   -8    KEMAX function failed.\n  */\n", "func_signal": "int32_t  FMC_SetSPKey(uint32_t key[3], uint32_t kpmax, uint32_t kemax,\n                      const int32_t lock_CONFIG, const int32_t lock_SPROM)", "code": "{\n    uint32_t  lock_ctrl = 0UL;\n    uint32_t  u32KeySts;\n    int32_t   ret = 0;\n\n    if (FMC->KPKEYSTS != 0x200UL) {\n        ret = -1;\n    }\n\n    if (FMC_Erase(FMC_KPROM_BASE)) {\n        ret = -2;\n    }\n\n    if (FMC_Erase(FMC_KPROM_BASE + 0x200UL)) {\n        ret = -3;\n    }\n\n    if (!lock_CONFIG) {\n        lock_ctrl |= 0x1UL;\n    }\n\n    if (!lock_SPROM) {\n        lock_ctrl |= 0x2UL;\n    }\n\n    if (ret == 0) {\n        FMC_Write(FMC_KPROM_BASE, key[0]);\n        FMC_Write(FMC_KPROM_BASE + 0x4UL, key[1]);\n        FMC_Write(FMC_KPROM_BASE + 0x8UL, key[2]);\n        FMC_Write(FMC_KPROM_BASE + 0xCUL, kpmax);\n        FMC_Write(FMC_KPROM_BASE + 0x10UL, kemax);\n        FMC_Write(FMC_KPROM_BASE + 0x14UL, lock_ctrl);\n\n        while (FMC->KPKEYSTS & FMC_KPKEYSTS_KEYBUSY_Msk) { }\n\n        u32KeySts = FMC->KPKEYSTS;\n\n        if (!(u32KeySts & FMC_KPKEYSTS_KEYLOCK_Msk)) {\n            /* Security key lock failed! */\n            ret = -4;\n        } else if ((lock_CONFIG && (!(u32KeySts & FMC_KPKEYSTS_CFGFLAG_Msk))) ||\n                   ((!lock_CONFIG) && (u32KeySts & FMC_KPKEYSTS_CFGFLAG_Msk))) {\n            /* CONFIG lock failed! */\n            ret = -5;\n        } else if ((lock_SPROM && (!(u32KeySts & FMC_KPKEYSTS_SPFLAG_Msk))) ||\n                   ((!lock_SPROM) && (u32KeySts & FMC_KPKEYSTS_SPFLAG_Msk))) {\n            /* CONFIG lock failed! */\n            ret = -6;\n        } else if (((FMC->KPCNT & FMC_KPCNT_KPMAX_Msk) >> FMC_KPCNT_KPMAX_Pos) != kpmax) {\n            /* KPMAX failed! */\n            ret = -7;\n        } else if (((FMC->KPKEYCNT & FMC_KPKEYCNT_KPKEMAX_Msk) >> FMC_KPKEYCNT_KPKEMAX_Pos) != kemax) {\n            /* KEMAX failed! */\n            ret = -8;\n        }\n    }\n\n    return ret;\n}", "path": "DAPLink/source/hic_hal/nuvoton/m48ssidae/StdDriver/src/m480_fmc.c", "commit_date": "2019-11-05 00:00:00", "repo_name": "ARMmbed/DAPLink", "stars": 2107, "license": "apache-2.0", "language": "c", "size": 28791}
{"docstring": "/* ==================================================================== */\n/* Create a new context instance.                                       */\n/* IN ctx            : a context pointer to allow this instance to      */\n/*                     access the context fields                        */\n/* IN prev_ctx_inst  : the context instance whose option leading to the */\n/*                     creation of this new context instance is part of */\n/* Returns           : the new context.                                 */\n/* ==================================================================== */\n", "func_signal": "static ctx_inst_t *\nnew_ctx_inst(ctx_t * ctx, ctx_inst_t * prev_ctx_inst)", "code": "{\n  opt_t *      opt;\n  opt_inst_t * gen_opt_inst;\n  ctx_inst_t * ctx_inst;\n  seen_opt_t * seen_opt;\n  char *       str, *opt_name;\n  void *       bst;\n  bst_t *      bst_node;\n\n  /* Keep a trace of the opt_inst which was at the origin of the creation */\n  /* of this context instance.                                            */\n  /* This will serve during the evaluation of the option callbacks.       */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (prev_ctx_inst != NULL)\n  {\n    gen_opt_inst = (opt_inst_t *)(prev_ctx_inst->opt_inst_list->tail->data);\n\n    /* Update current_state. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    cur_state->opt_name = gen_opt_inst->opt->name;\n  }\n  else\n    gen_opt_inst = NULL;\n\n  /* Create and initialize the new context instance. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ctx_inst                  = xmalloc(sizeof(ctx_inst_t));\n  ctx_inst->ctx             = ctx;\n  ctx_inst->prev_ctx_inst   = prev_ctx_inst;\n  ctx_inst->gen_opt_inst    = gen_opt_inst;\n  ctx_inst->incomp_bst_list = ll_new();\n  ctx_inst->opt_inst_list   = ll_new();\n  ctx_inst->opt_req_list    = ll_new();\n  ctx_inst->seen_opt_bst    = NULL;\n\n  ll_node_t * node;\n\n  if (prev_ctx_inst == NULL)\n    first_ctx_inst = ctx_inst;\n\n  /* Initialize the occurrence counters of each opt allowed in the context. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->opt_list->head;\n  while (node != NULL)\n  {\n    opt              = node->data;\n    opt->occurrences = 0;\n\n    node = node->next;\n  }\n\n  /* Initialize the BST containing the seen indicator for all the options */\n  /* allowed in this context instance.                                    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->opt_list->head;\n  while (node != NULL)\n  {\n    opt            = node->data;\n    seen_opt       = xmalloc(sizeof(seen_opt_t));\n    seen_opt->opt  = opt;\n    seen_opt->par  = NULL;\n    seen_opt->seen = 0;\n\n    bst_search(seen_opt, &(ctx_inst->seen_opt_bst), seen_opt_compare);\n\n    node = node->next;\n  }\n\n  /* Initialize the BST containing the incompatibles options.              */\n  /* Incompatibles option names are read from strings found in the list    */\n  /* incomp_list present in each instance of ctx_t.                        */\n  /* These names are then used to search for the object of type seen_opt_t */\n  /* which is already present in the seen_opt_bst of the context instance. */\n  /* in the BST.                                                           */\n  /* Once found the seen_opt_t object in inserted in the new BST.          */\n  /* At the end the new BST in added to the list incomp_bst_list.          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->incomp_list->head;\n  while (node != NULL)\n  {\n    bst = NULL;\n    seen_opt_t tmp_seen_opt;\n\n    str = xstrdup(node->data);\n    ltrim(str, \" \\t\");\n    rtrim(str, \" \\t\", 0);\n    opt_name = strtok(str, \" \\t\"); /* Extract the first option name. */\n\n    while (opt_name != NULL) /* For each option name. */\n    {\n      if ((opt = locate_opt(opt_name)) != NULL)\n      {\n        /* The option found is searched in the tree of potential */\n        /* seen options.                                         */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        tmp_seen_opt.opt = opt;\n\n        bst_node = bst_find(&tmp_seen_opt, &(ctx_inst->seen_opt_bst),\n                            seen_opt_compare);\n\n        if (bst_node != NULL)\n        {\n          /* If found then it is added into the new BST tree. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          seen_opt = bst_node->key;\n          bst_search(seen_opt, &bst, seen_opt_compare);\n        }\n        else\n          /* Not found! That means that the option is unknown in this */\n          /* context as all options has have a seen_opt structure in  */\n          /* seen_opt_bst.                                            */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          fatal_internal(\"%s is not known in the context %s.\", opt->name,\n                         ctx->name);\n      }\n      else\n        fatal_internal(\"Unknown option %s.\", opt_name);\n\n      opt_name = strtok(NULL, \" \\t\");\n    }\n\n    free(str);\n    ll_append(ctx_inst->incomp_bst_list, bst);\n\n    node = node->next;\n  }\n\n  /* Initialize the list of res_t structures according to the     */\n  /* list set in the context by ctxopt_add_ctx_settings/required. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->req_list->head;\n  while (node != NULL)\n  {\n    req_t * req = xmalloc(sizeof(req_t));\n\n    str = xstrdup(node->data);\n    ltrim(str, \" \\t\");\n    rtrim(str, \" \\t\", 0);\n    opt_name = strtok(str, \" \\t\"); /* Extract the first option name. */\n\n    if ((opt = locate_opt(opt_name)) != NULL)\n    {\n      req->opt         = opt;\n      req->or_opt_list = ll_new();\n      while ((opt_name = strtok(NULL, \" \\t\")) != NULL)\n      {\n        if ((opt = locate_opt(opt_name)) != NULL)\n          ll_append(req->or_opt_list, opt);\n        else\n          fatal_internal(\"Unknown option %s.\", opt_name);\n      }\n      ll_append(ctx_inst->opt_req_list, req);\n    }\n    else\n      fatal_internal(\"Unknown option %s.\", opt_name);\n\n    free(str);\n\n    node = node->next;\n  }\n  return ctx_inst;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ============================= */\n/* Free a ctx_inst_list element. */\n/* ============================= */\n", "func_signal": "static void\nctx_inst_free(void * ci)", "code": "{\n  ctx_inst_t * ctx_inst = ci;\n\n  free(ctx_inst->par_name);\n  ll_destroy(ctx_inst->incomp_bst_list, incomp_bst_free);\n  bst_destroy(ctx_inst->seen_opt_bst, seen_opt_free);\n  ll_destroy(ctx_inst->opt_inst_list, opt_inst_free);\n  ll_destroy(ctx_inst->opt_req_list, req_free);\n\n  free(ci);\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ===================================================================== */\n/* Put the first word of str, truncated to len characters, in buf.       */\n/* Return a pointer in str pointing just after the word.                 */\n/* buf must have been pre-allocated to accept at least len+1 characters. */\n/* Note that buf can contains a sting full of spaces is str was not      */\n/* trimmed before the call.                                              */\n/* ===================================================================== */\n", "func_signal": "char *\nget_word(char * str, char * buf, size_t len)", "code": "{\n  char * s = str;\n\n  /* Skip spaces. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\" */\n  while (*s && isspace(*s))\n    s++;\n\n  /* Set the new string start. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  str = s;\n\n  /* Get the word. */\n  /*\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (*s && !isspace(*s) && s - str < len)\n    s++;\n\n  strncpy(buf, str, s - str);\n  buf[s - str] = 0;\n\n  return s;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* =============================================== */\n/* Is the string str2 a prefix of the string str1? */\n/* =============================================== */\n", "func_signal": "static int\nstrpref(char * str1, char * str2)", "code": "{\n  while (*str1 != '\\0' && *str1 == *str2)\n  {\n    str1++;\n    str2++;\n  }\n\n  return *str2 == '\\0';\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* option).                                                               */\n/*                                                                        */\n/* IN  word : the word to be checked.                                     */\n/* IN  ctx  : the context in which the flag indexed by the word is to be  */\n/*            checked.                                                    */\n/* OUT pos  : the offset in word pointing just after the matching prefix. */\n/* OUT opt  : a pointer to the option associated with the new parameter   */\n/*            or NULL if none is found.                                   */\n/*                                                                        */\n/* The returned pointer must be freed by the caller.                      */\n/* ====================================================================== */\n", "func_signal": "static char *\nlook_for_valid_prefix_in_word(char * word, ctx_t * ctx, int * pos, opt_t ** opt)", "code": "{\n  char * new = NULL;\n  int     len;\n  par_t * par;\n  par_t   tmp_par = { 0 };\n\n  len = strlen(word);\n\n  if (len > 2)\n  {\n    new = xstrdup(word);\n\n    do\n    {\n      new[--len]   = '\\0';\n      tmp_par.name = new;\n    } while ((par = locate_par(tmp_par.name, ctx)) == NULL && len > 2);\n\n    if (par != NULL)\n    {\n      *pos = len;\n      *opt = par->opt;\n    }\n    else\n    {\n      free(new);\n      new = NULL;\n    }\n  }\n  else\n    *pos = 0;\n\n  return new;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ========================= */\n/* Find a node, or return 0. */\n/* ========================= */\n", "func_signal": "static void *\nbst_find(const void * vkey, void * const * vrootp,\n         int (*compar)(const void *, const void *))", "code": "{\n  bst_t * const * rootp = (bst_t * const *)vrootp;\n\n  if (rootp == NULL)\n    return NULL;\n\n  while (*rootp != NULL)\n  { /* T1: */\n    int r;\n\n    if ((r = (*compar)(vkey, (*rootp)->key)) == 0) /* T2: */\n      return *rootp;                               /* key found */\n    rootp = (r < 0) ? &(*rootp)->llink             /* T3: follow left branch */\n                    : &(*rootp)->rlink;            /* T4: follow right branch */\n  }\n  return NULL;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ======================================================== */\n/* Insert a new node before the specified node in the list. */\n/* ======================================================== */\n", "func_signal": "static void\nll_insert_before(ll_t * const list, ll_node_t * node, void * const data)", "code": "{\n  ll_node_t * new_node;\n\n  if (node->prev == NULL)\n    ll_prepend(list, data);\n  else\n  {\n    new_node = ll_new_node(); /* ll_new_node cannot return NULL because it   *\n                               | uses xmalloc which does not return if there *\n                               | is an allocation error.                     */\n\n    new_node->data   = data;\n    new_node->next   = node;\n    new_node->prev   = node->prev;\n    node->prev->next = new_node;\n    node->prev       = new_node;\n\n    ++list->len;\n  }\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ================================================= */\n/* Trim trailing characters.                         */\n/* The resulting string will have at least min bytes */\n/* even if trailing spaces remain.                   */\n/* ================================================= */\n", "func_signal": "static void\nrtrim(char * str, const char * trim_str, size_t min)", "code": "{\n  size_t len = strlen(str);\n  while (len > min && strchr(trim_str, str[len - 1]))\n    str[--len] = '\\0';\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ====================================================================== */\n/* Helper function to display the dependency constraints between options. */\n/* These constraints are set with the ctxopt_add_opt_settings function    */\n/* using the 'before' and 'after' arguments.                              */\n/* IN  list  : a list of options.                                         */\n/* ====================================================================== */\n", "func_signal": "static void\nprint_before_constraints(ll_t * list)", "code": "{\n  ll_node_t * node = list->head;\n  ll_node_t * before_node;\n  opt_t *     opt, *before_opt;\n  int         msg = 0;\n\n  while (node != NULL)\n  {\n    opt = node->data;\n\n    if (opt->eval_before_list->len > 0)\n    {\n      if (!msg)\n      {\n        printf(\"\\n  If present in the command line,\");\n        msg = 1; /* Display this message only once. */\n      }\n\n      before_node = opt->eval_before_list->head;\n\n      printf(\"\\n  \");\n      while (before_node != NULL)\n      {\n        before_opt = before_node->data;\n        printf(\"%s\", before_opt->params);\n\n        before_node = before_node->next;\n\n        if (before_node != NULL)\n          printf(\" and\\n  \");\n      }\n      printf(\" will be evaluated after %s\\n\", opt->params);\n    }\n    node = node->next;\n  }\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ================================== */\n/* Compare two seen_opt_bst elements. */\n/* ================================== */\n", "func_signal": "static int\nseen_opt_compare(const void * so1, const void * so2)", "code": "{\n  opt_t *o1, *o2;\n\n  o1 = ((seen_opt_t *)so1)->opt;\n  o2 = ((seen_opt_t *)so2)->opt;\n\n  return strcmp(o1->name, o2->name);\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ================================================================== */\n/* This constraint checks if each arguments of the option instance is */\n/* between a minimum and a maximum (inclusive).                       */\n/* return 1 if yes and 0 if no.                                       */\n/* ================================================================== */\n", "func_signal": "int\nctxopt_range_constraint(int nb_args, char ** args, char * value, char * par)", "code": "{\n  long   min, max;\n  char   c;\n  char * ptr;\n  int    n;\n  long   v;\n  int    min_only = 0;\n  int    max_only = 0;\n\n  if (nb_args != 2)\n    fatal_internal(\"Range constraint, invalid number of parameters.\");\n\n  if (strcmp(args[0], \".\") == 0)\n    max_only = 1;\n  else\n    n = sscanf(args[0], \"%ld%c\", &min, &c);\n\n  if (!max_only && n != 1)\n    fatal_internal(\"Range constraint, min: invalid parameters.\");\n\n  if (strcmp(args[1], \".\") == 0)\n    min_only = 1;\n  else\n    n = sscanf(args[1], \"%ld%c\", &max, &c);\n\n  if (!min_only && n != 1)\n    fatal_internal(\"Range constraint, max: invalid parameters.\");\n\n  if (min_only && max_only)\n    fatal_internal(\"Range constraint, invalid parameters.\");\n\n  errno = 0;\n  v     = strtol(value, &ptr, 10);\n  if (errno || ptr == value)\n    return 0;\n\n  if (min_only)\n  {\n    if (v < min)\n    {\n      fprintf(stderr,\n              \"The argument %ld of %s is not greater than or equal to %ld.\", v,\n              par, min);\n      return 0;\n    }\n    else\n      return 1;\n  }\n  else if (max_only)\n  {\n    if (v > max)\n    {\n      fprintf(stderr,\n              \"The argument %ld of %s is not less than or equal to %ld.\", v,\n              par, max);\n      return 0;\n    }\n    else\n      return 1;\n  }\n  else if (v < min || v > max)\n  {\n    fprintf(stderr, \"The argument %ld of %s is not between %ld and %ld.\", v,\n            par, min, max);\n    return 0;\n  }\n\n  return 1; /* Check passed. */\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ================================================================== */\n/* Put a new node filled with its data at the beginning of the linked */\n/* list.                                                              */\n/* The user is responsible for the memory management of the data.     */\n/* ================================================================== */\n", "func_signal": "static void\nll_prepend(ll_t * const list, void * const data)", "code": "{\n  ll_node_t * node;\n\n  node = ll_new_node(); /* ll_new_node cannot return NULL because it   *\n                         | uses xmalloc which does not return if there *\n                         | is an allocation error.                     */\n\n  node->data = data;\n  node->prev = NULL;\n\n  node->next = list->head;\n  if (list->head)\n    list->head->prev = node;\n  else\n    list->tail = node;\n\n  list->head = node;\n\n  ++list->len;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/*          CTXOPTMISARG Missing argument.                                */\n/*          CTXOPTUXPARG Unexpected argument.                             */\n/*          CTXOPTDUPOPT Duplicated option.                               */\n/*          CTXOPTUNKPAR Unknown parameter.                               */\n/*          CTXOPTINCOPT Incompatible option.                             */\n/*          CTXOPTCTEOPT Option: bad number of occurrences.               */\n/*          CTXOPTCTLOPT Option: not enough occurrences.                  */\n/*          CTXOPTCTGOPT Option: too many occurrence of.                  */\n/*          CTXOPTCTEARG Arguments: bad number of occurrences.            */\n/*          CTXOPTCTLARG Arguments: not enough occurrences.               */\n/*          CTXOPTCTGARG Arguments: too many occurrences.                 */\n/* ====================================================================== */\n", "func_signal": "static void\nfatal(errors e, char * errmsg)", "code": "{\n  if (err_functions[e] != NULL)\n    err_functions[e](e, cur_state);\n  else\n  {\n    switch (e)\n    {\n      case CTXOPTNOERR:\n        break;\n\n      case CTXOPTMISPAR:\n        if (cur_state->ctx_par_name != NULL)\n          fprintf(stderr,\n                  \"the mandatory parameter(s) %s are missing in the context \"\n                  \"introduced by %s.\\n\",\n                  errmsg, cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The mandatory parameter(s) %s are missing \"\n                  \"in the main context.\\n\",\n                  errmsg);\n\n        free(errmsg);\n        break;\n\n      case CTXOPTREQPAR:\n        fprintf(stderr, errmsg, cur_state->req_opt_par_needed,\n                cur_state->req_opt_par);\n        break;\n\n      case CTXOPTUNXARG:\n        if (cur_state->cur_opt_par_name != NULL)\n          fprintf(stderr,\n                  \"The parameter %s takes no arguments \"\n                  \"or has too many arguments.\\n\",\n                  cur_state->cur_opt_par_name);\n        break;\n\n      case CTXOPTMISARG:\n        if (cur_state->pre_opt_par_name != NULL)\n          fprintf(stderr, \"%s requires argument(s).\\n\",\n                  cur_state->pre_opt_par_name);\n        else\n          fprintf(stderr, \"%s requires argument(s).\\n\",\n                  cur_state->cur_opt_par_name);\n        break;\n\n      case CTXOPTDUPOPT:\n        if (cur_state->pre_opt_par_name != NULL)\n          fprintf(stderr,\n                  \"The parameter %s can only appear once in the context \"\n                  \"introduced by %s.\\n\",\n                  cur_state->cur_opt_params, cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The parameter %s can only appear once \"\n                  \"in the main context.\\n\",\n                  cur_state->cur_opt_params);\n        break;\n\n      case CTXOPTUNKPAR:\n        fprintf(stderr, \"Unknown parameter %s.\\n%s\",\n                cur_state->cur_opt_par_name, errmsg);\n        break;\n\n      case CTXOPTINCOPT:\n        fprintf(stderr, \"The parameter %s is incompatible with %s.\\n\",\n                cur_state->cur_opt_par_name, errmsg);\n        break;\n\n      case CTXOPTCTEOPT:\n        if (cur_state->ctx_par_name)\n          fprintf(stderr,\n                  \"The parameter %s must appear exactly %d times \"\n                  \"in the context introduced by %s.\\n\",\n                  cur_state->cur_opt_params, cur_state->opts_count,\n                  cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The parameter %s must appear exactly %d times \"\n                  \"in the main context.\\n\",\n                  cur_state->cur_opt_params, cur_state->opts_count);\n        break;\n\n      case CTXOPTCTLOPT:\n        if (cur_state->ctx_par_name)\n          fprintf(stderr,\n                  \"The parameter %s must appear less than %d times \"\n                  \"in the context introduced by %s.\\n\",\n                  cur_state->cur_opt_params, cur_state->opts_count,\n                  cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The parameter %s must appear less than %d times \"\n                  \"in the main context.\\n\",\n                  cur_state->cur_opt_params, cur_state->opts_count);\n        break;\n\n      case CTXOPTCTGOPT:\n        if (cur_state->ctx_par_name)\n          fprintf(stderr,\n                  \"The parameter %s must appear more than %d times \"\n                  \"in the context introduced by %s.\\n\",\n                  cur_state->cur_opt_params, cur_state->opts_count,\n                  cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The parameter %s must appear more than %d times \"\n                  \"in the main context.\\n\",\n                  cur_state->cur_opt_params, cur_state->opts_count);\n        break;\n\n      case CTXOPTCTEARG:\n        fprintf(stderr, \"The parameter %s must have exactly %d arguments.\\n\",\n                cur_state->cur_opt_par_name, cur_state->opt_args_count);\n        break;\n\n      case CTXOPTCTLARG:\n        fprintf(stderr, \"The parameter %s must have less than %d arguments.\\n\",\n                cur_state->cur_opt_par_name, cur_state->opt_args_count);\n        break;\n\n      case CTXOPTCTGARG:\n        fprintf(stderr, \"The parameter %s must have more than %d arguments.\\n\",\n                cur_state->cur_opt_par_name, cur_state->opt_args_count);\n        break;\n\n      case CTXOPTERRSIZ:\n        break;\n    }\n  }\n\n  /* CTXOPTUNKPAR should display the full usage to help the user follow   */\n  /* the chaining of contexts when several possible contexts have been    */\n  /* identified. Otherwise, errmsg is the empty string and the display of */\n  /* the current usage is enough.                                         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (e == CTXOPTUNKPAR && *errmsg != '\\0')\n    ctxopt_disp_usage(continue_after);\n  else\n    ctxopt_ctx_disp_usage(cur_state->ctx_name, continue_after);\n\n  exit(e); /* Exit with the error id e as return code. */\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ====================================================================== */\n/* This function terminates the program if all the options which are part */\n/* of a group of required options by some other option are missing.       */\n/* ====================================================================== */\n", "func_signal": "static void\ncheck_for_requirement_issues(ctx_inst_t * ctx_inst)", "code": "{\n  ll_node_t * node;\n  ll_node_t * req_node;\n  req_t *     req;\n  opt_t *     opt;\n  opt_t *     req_opt;\n  bst_t *     bst_node;\n  seen_opt_t  tmp_seen_opt;\n  int         found;\n  char *      needed_params = NULL;\n\n  node = ctx_inst->opt_req_list->head;\n\n  while (node != NULL)\n  {\n    req = node->data;\n\n    opt              = req->opt;\n    tmp_seen_opt.opt = opt;\n\n    bst_node = bst_find(&tmp_seen_opt, &(ctx_inst->seen_opt_bst),\n                        seen_opt_compare);\n\n    if (((seen_opt_t *)(bst_node->key))->seen != 0)\n    {\n      found    = 0;\n      req_node = req->or_opt_list->head;\n\n      /* needed_params accumulates the params of the options in the group. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      free(needed_params); /* free can applied to the NULL pointer. */\n      needed_params = xstrdup(\"\");\n\n      /* Go through the list of the required group of options and */\n      /* succeed when one of them has been seen in the context.   */\n      /* otherwise a fatal error is triggered and the program is  */\n      /* terminated.                                              */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      while (req_node != NULL)\n      {\n        req_opt          = req_node->data;\n        tmp_seen_opt.opt = req_opt;\n        needed_params    = strappend(needed_params, req_opt->params, \"\\n  \",\n                                  (char *)0);\n\n        bst_node = bst_find(&tmp_seen_opt, &(ctx_inst->seen_opt_bst),\n                            seen_opt_compare);\n\n        if (((seen_opt_t *)(bst_node->key))->seen != 0)\n        {\n          found = 1; /* A required option has been seen, */\n          break;     /* accept the group.                */\n        }\n        req_node = req_node->next;\n      }\n\n      rtrim(needed_params, \"\\n \", 0);\n\n      /* This is a fatal error if none of the options in the required */\n      /* options group has been seen in the context.                  */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (!found)\n      {\n        char * errmsg;\n\n        if (req->or_opt_list->len > 1)\n          errmsg = xstrdup(\"At least one of the parameters among:\\n  %s\\n\"\n                           \"requested by %s must be present.\\n\");\n        else\n          errmsg = xstrdup(\"The parameter %s \"\n                           \"requested by %s must be present.\\n\");\n\n        cur_state->req_opt_par_needed = needed_params;\n        cur_state->req_opt_par        = opt->params;\n\n        fatal(CTXOPTREQPAR, errmsg);\n      }\n    }\n\n    node = node->next;\n  }\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ==================================================================== */\n/* Return 1 is value is \"1\" or \"yes\" (ignoring case).                   */\n/* Return 0 is value is \"0\" or \"no\" (ignoring case).                    */\n/* If value has another value, then set invalid to 1 and also return 0  */\n/* invalid is set to 0 in all the other cases.                          */\n/* ==================================================================== */\n", "func_signal": "static int\neval_yes(char * value, int * invalid)", "code": "{\n  *invalid = 0;\n\n  if (strcmp(value, \"1\") == 0 || stricmp(value, \"yes\") == 0)\n    return 1;\n  else if (strcmp(value, \"0\") != 0 && stricmp(value, \"no\") != 0)\n    *invalid = 1;\n\n  return 0;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ====================================================================== */\n/*  Public domain strtok_r() by Charlie Gordon.                           */\n/*   from comp.lang.c  9/14/2007                                          */\n/*      http://groups.google.com/group/comp.lang.c/msg/2ab1ecbb86646684   */\n/*                                                                        */\n/*     (Declaration that it's public domain):                             */\n/*      http://groups.google.com/group/comp.lang.c/msg/7c7b39328fefab9c   */\n/*                                                                        */\n/* Also, fixed by Fletcher T. Penney --- added the \"return NULL\" when     */\n/* *end == NULL.                                                          */\n/* ====================================================================== */\n", "func_signal": "static char *\nxstrtok_r(char * str, const char * delim, char ** end)", "code": "{\n  char * ret;\n\n  if (str == NULL)\n    str = *end;\n\n  if (str == NULL)\n    return NULL;\n\n  str += strspn(str, delim);\n\n  if (*str == '\\0')\n    return NULL;\n\n  ret = str;\n\n  str += strcspn(str, delim);\n\n  if (*str)\n    *str++ = '\\0';\n\n  *end = str;\n\n  return ret;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* =================================================== */\n/* strndup implementation using xmalloc.               */\n/* This version guarantees that there is a final '\\0'. */\n/* =================================================== */\n", "func_signal": "static char *\nxstrndup(const char * str, size_t len)", "code": "{\n  char * p;\n\n  p = memchr(str, '\\0', len);\n\n  if (p)\n    len = p - str;\n\n  p = xmalloc(len + 1);\n  memcpy(p, str, len);\n  p[len] = '\\0';\n\n  return p;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* =================== */\n/* Customized realloc. */\n/* =================== */\n", "func_signal": "static void *\nxrealloc(void * p, size_t size)", "code": "{\n  void * allocated;\n\n  allocated = realloc(p, size);\n  if (allocated == NULL && size > 0)\n    fatal_internal(\"Insufficient memory (attempt to xrealloc %lu bytes).\\n\",\n                   (unsigned long int)size);\n\n  return allocated;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* Unused yet. */\n/* =========================== */\n/* Delete node with given key. */\n/* =========================== */\n", "func_signal": "static void *\nbst_delete(const void * vkey, void ** vrootp,\n           int (*compar)(const void *, const void *))", "code": "{\n  bst_t ** rootp = (bst_t **)vrootp;\n  bst_t *  p, *q, *r;\n  int      cmp;\n\n  if (rootp == NULL || (p = *rootp) == NULL)\n    return NULL;\n\n  while ((cmp = (*compar)(vkey, (*rootp)->key)) != 0)\n  {\n    p     = *rootp;\n    rootp = (cmp < 0) ? &(*rootp)->llink  /* follow llink branch */\n                      : &(*rootp)->rlink; /* follow rlink branch */\n    if (*rootp == NULL)\n      return NULL; /* key not found */\n  }\n  r = (*rootp)->rlink;               /* D1: */\n  if ((q = (*rootp)->llink) == NULL) /* Left NULL? */\n    q = r;\n  else if (r != NULL)\n  { /* Right link is NULL? */\n    if (r->llink == NULL)\n    { /* D2: Find successor */\n      r->llink = q;\n      q        = r;\n    }\n    else\n    { /* D3: Find NULL link */\n      for (q = r->llink; q->llink != NULL; q = r->llink)\n        r = q;\n      r->llink = q->rlink;\n      q->llink = (*rootp)->llink;\n      q->rlink = (*rootp)->rlink;\n    }\n  }\n  if (p != *rootp)\n    free(*rootp); /* D4: Free node */\n  *rootp = q;     /* link parent to new node */\n  return p;\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/* ============================ */\n/* Free a seen_opt_bst element. */\n/* ============================ */\n", "func_signal": "void\nseen_opt_free(void * so)", "code": "{\n  seen_opt_t * seen_opt = so;\n\n  free(seen_opt->par);\n\n  free(so);\n}", "path": "smenu/ctxopt.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "p-gen/smenu", "stars": 2313, "license": "mpl-2.0", "language": "c", "size": 9096}
{"docstring": "/*\n*************************************************************************************************************\n-  : void LCD_FillCircle(U16 x0, U16 y0, U16 r)\n- \u02f5 : \u0532\n-  : x,y\n-  : \n*************************************************************************************************************\n*/\n", "func_signal": "void LCD_FillCircle       (U16 x0, U16 y0, U16 r)", "code": "{\n  \tU32 i;\n  \tU32 imax = ((int)((int)r*707))/1000+1;\n  \tU32 sqmax = (int)r*(int)r+(int)r/2;\n  \tU16 x = r;\n  \n  \tLCD_DrawHLine(x0-r,y0,x0+r);\n  \n  \tfor (i=1; i<= imax; i++) \n  \t{\n    \tif ((i*i+x*x) >sqmax) \n    \t{\n      \t\tif (x>imax) \n      \t\t{\n        \t\tLCD_DrawHLine (x0-i+1,y0+x, x0+i-1);\n        \t\tLCD_DrawHLine (x0-i+1,y0-x, x0+i-1);\n      \t\t}\n      \t\tx--;\n    \t}\n       \tLCD_DrawHLine(x0-x,y0+i, x0+x);\n    \tLCD_DrawHLine(x0-x,y0-i, x0+x);\n  \t}\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n * this stops the dma and clears the dma ptrs\n */\n", "func_signal": "static void audio_stop_dma(struct audio_stream *s)", "code": "{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->dma_lock, flags);\t\n\ts->active = 0;\n\ts->period = 0;\n\t/* this stops the dma channel and clears the buffer ptrs */\n#ifdef HH_VERSION\n\tsa1100_dma_flush_all(s->dmach);\n#else\n\tsa1100_clear_dma(s->dma_regs);\t\n#endif\n\tspin_unlock_irqrestore(&s->dma_lock, flags);\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/code/17/ALSA\u9a71\u52a8\u8303\u4f8b/sa11xx-uda1341.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n * Atomicly increment an index into shortp_in_buffer\n */\n", "func_signal": "static inline void shortp_incr_bp(volatile unsigned long *index, int delta)", "code": "{\n\tunsigned long new = *index + delta;\n\tbarrier ();  /* Don't optimize these two together */\n\t*index = (new >= (shortp_in_buffer + PAGE_SIZE)) ? shortp_in_buffer : new;\n}", "path": "LDD-LinuxDeviceDrivers/books/ldd/ldd4-master/shortprint/shortprint.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : void LCD_Clear(U16 x0, U16 y0, U16 x1, U16 y1)\n- \u02f5 :  \n-  : x0,y0,x1,y1\n-  : \n*************************************************************************************************************\n*/\n", "func_signal": "void LCD_Clear(U16 x0, U16 y0, U16 x1, U16 y1)", "code": "{\n\tLCD_COLOR = 0x00;\n\tfor (; y0 <= y1; y0++) \n\t{\n\t\t LCD_DrawHLine(x0,y0, x1);\n\t}\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : U32 GetPixelIndex(U16 x, U16 y)\n- \u02f5 : \u04f2\u0135\u00f5\u026b\u013a\n-  : x,y\n-  : color\n*************************************************************************************************************\n*/\n", "func_signal": "U32 GetPixelIndex(U16 x, U16 y)", "code": "{\n  \tU32 col;\n  \tU8 Data;\n  \ttOff Off = XY2OFF(x,y);\n  \tREAD_MEM(Off,Data);\n        col = Data;\n  \treturn col;\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : void LCD_DrawCircle(U16 x0, U16 y0, U16 r)\n- \u02f5 : \u0532\n-  : x,y\n-  : \n*************************************************************************************************************\n*/\n", "func_signal": "void LCD_DrawCircle(U32 x0, U32 y0, U32 r)", "code": "{\n  \tU32 i;\n  \tU32 imax = ((int)((int)r*707))/1000 + 1;\n  \tU32 sqmax = (int)r*(int)r + (int)r/2;\n  \tU16 y = r;\n  \t\n  \t_DrawPoint(x0,y0,r,0);\n  \t\n  \tfor (i=1; i<= imax; i++) \n  \t{\n    \tif ((i*i+y*y) > sqmax) \n    \t{\n      \t\t_DrawPoint(x0,y0,i,y);\n      \t\ty--;\n    \t}\n    \t_DrawPoint(x0,y0,i,y);\n  \t}\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : static  void DrawPoint(U16 x0,U16 y0, U16 xoff, U16 yoff)\n- \u02f5 : \u3eaf\n-  : x,y\n-  : \n*************************************************************************************************************\n*/\n", "func_signal": "static  void _DrawPoint(U32 x0,U32 y0, U32 xoff, U32 yoff)", "code": "{\n  \tLCD_DrawPixel(x0+xoff,y0+yoff);\n  \tLCD_DrawPixel(x0-xoff,y0+yoff);\n  \tLCD_DrawPixel(x0+yoff,y0+xoff);\n  \tLCD_DrawPixel(x0+yoff,y0-xoff);\n  \t\n  \tif (yoff) \n  \t{\n    \tLCD_DrawPixel(x0+xoff,y0-yoff);\n    \tLCD_DrawPixel(x0-xoff,y0-yoff);\n    \tLCD_DrawPixel(x0-yoff,y0+xoff);\n    \tLCD_DrawPixel(x0-yoff,y0-xoff);\n  \t}\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : static int LCDIoctl(struct inode *inode,struct file * file,unsigned int cmd,unsigned long arg)\n- \u02f5 : LCD\n-  : \n-  : 0\n*************************************************************************************************************\n*/\n", "func_signal": "static int LCDIoctl(struct inode *inode,struct file * file,unsigned long cmd,unsigned long arg)", "code": "{\n//char color;\n\tstruct para \n\t{\n\t    unsigned long a;\n\t    unsigned long b;\n\t    unsigned long c;\n\t    unsigned long d;\n\t}*p_arg;\n\n\n\t\n         switch(cmd) \n         {\n\t\tcase 0:\n                       \tprintk(\"set color\\n\");\n\t\n\t\t\tSet_Color(arg); \n\t                printk(\"LCD_COLOR =%x\\n\",LCD_COLOR);\n\t\t\treturn 1;\n\n\t\tcase 1:\n\t\t\tprintk(\"draw h_line\\n\");\n\t\t\tp_arg =(struct para *)arg;\n\t\t\tLCD_DrawHLine(p_arg->a,p_arg->b,p_arg->c);\t\t// draw h_line\n \t                LCD_DrawHLine(p_arg->a,p_arg->b+15,p_arg->c);\t\t// draw h_line\n\t                LCD_DrawHLine(p_arg->a,p_arg->b+30,p_arg->c);\t\t// draw h_line\n\t\t\treturn 1;\n\t\t\t\n\t       case 2:\n\t\t        printk(\"draw v_line\\n\");\t\n\t\t\tp_arg =(struct para *)arg;\n    \t\t        LCD_DrawVLine(p_arg->a,p_arg->b,p_arg->c); \t\t// draw v_line\n\t\t        LCD_DrawVLine(p_arg->a+15,p_arg->b,p_arg->c); \t\t// draw v_line\n\t\t        LCD_DrawVLine(p_arg->a+30,p_arg->b,p_arg->c); \t\t// draw v_line\n\t\t\treturn 1;\n\t\t\t\n\t \tcase 3 :\n\t        \tprintk(\"drwa circle\\n\");\n\t\t\tp_arg =(struct para *)arg;\n\t                LCD_DrawCircle(p_arg->a,p_arg->b,p_arg->c);\t\t// draw circle\n\t                return 1;\n\t       \n\t\tcase 4:\n\t\t\tprintk(\"draw rect\\n\");\n\t\t\tp_arg =(struct para *)arg;\n\t\t\tLCD_FillRect(p_arg->a,p_arg->b,p_arg->c,p_arg->d);      // draw rect\n\t\t\treturn 1;\n\t\t\t\n\t         case 5:\n     \t\t        printk(\"draw fillcircle\\n\");\n\t\t\tp_arg =(struct para *)arg;\n\t\t\tLCD_FillCircle(p_arg->a, p_arg->b, p_arg->c);// draw fillcircle\n\t\t\treturn 1;\n\t\t\t\n\t \tcase 6 :\n\t      \t        printk(\"LCD is clear\\n\");\n \t\t\tLCD_Clear(0,0,319,239);     // clear screen\n\t                return 1;\n\t\n \t        case 7:\n\t\t\tprintk(\"draw rect\\n\");\n\t\t\tp_arg =(struct para *)arg;\n\t\t\tLCD_FillRect(p_arg->a,p_arg->b,p_arg->c,p_arg->d);      // draw rect\n\t\t\treturn 1;\n                default:\n         \t        return -EINVAL;\n             }\n             return 1;\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n * The top-half interrupt handler.\n */\n", "func_signal": "static irqreturn_t shortp_interrupt(int irq, void *dev_id)", "code": "{\n\tif (! shortp_output_active) \n\t\treturn IRQ_NONE;\n\n\t/* Remember the time, and farm off the rest to the workqueue function */ \n\tdo_gettimeofday(&shortp_tv);\n\tqueue_work(shortp_workqueue, &shortp_work);\n\treturn IRQ_HANDLED;\n}", "path": "LDD-LinuxDeviceDrivers/books/ldd/ldd4-master/shortprint/shortprint.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n * Interrupt timeouts.\tJust because we got a timeout doesn't mean that\n * things have gone wrong, however; printers can spend an awful long time\n * just thinking about things.\n */\n", "func_signal": "static void shortp_timeout(unsigned long unused)", "code": "{\n\tunsigned long flags;\n\tunsigned char status;\n   \n\tif (! shortp_output_active)\n\t\treturn;\n\tspin_lock_irqsave(&shortp_out_lock, flags);\n\tstatus = inb(shortp_base + SP_STATUS);\n\n\t/* If the printer is still busy we just reset the timer */\n\tif ((status & SP_SR_BUSY) == 0 || (status & SP_SR_ACK)) {\n\t\tshortp_timer.expires = jiffies + TIMEOUT;\n\t\tadd_timer(&shortp_timer);\n\t\tspin_unlock_irqrestore(&shortp_out_lock, flags);\n\t\treturn;\n\t}\n\n\t/* Otherwise we must have dropped an interrupt. */\n\tspin_unlock_irqrestore(&shortp_out_lock, flags);\n\tshortp_interrupt(shortp_irq, NULL);\n}", "path": "LDD-LinuxDeviceDrivers/books/ldd/ldd4-master/shortprint/shortprint.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : LCD_Exit\n- \u02f5 : \u0436lcd\u8c78\n-  : \n-  : \n*************************************************************************************************************\n*/\n", "func_signal": "void __exit LCDdriver_Exit(void)", "code": "{\n        Lcd_CstnOnOff(0);\n        unregister_chrdev(LCD_MAJOR, \"S3C2410LCD\");\n        printk(\"You have uninstall The LCD Driver succesfully,\\n if you want to install again,please use the insmod command \\n\");\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : void LCD_FillRect(U16 x0, U16 y0, U16 x1, U16 y1)\n- \u02f5 : \u03ba\n-  : x0,y0,x1,y1\n-  : \n*************************************************************************************************************\n*/\n", "func_signal": "void LCD_FillRect(U16 x0, U16 y0, U16 x1, U16 y1)", "code": "{\n\tfor (; y0 <= y1; y0++) \n\t{\n\t\t LCD_DrawHLine(x0,y0, x1);\n\t}\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n * Write to the device.\n */\n", "func_signal": "static ssize_t shortp_write(struct file *filp, const char __user *buf, size_t count,\n\t\tloff_t *f_pos)", "code": "{\n\tint space, written = 0;\n\tunsigned long flags;\n\t/*\n\t * Take and hold the mutex for the entire duration of the operation.  The\n\t * consumer side ignores it, and it will keep other data from interleaving\n\t * with ours.\n\t */\n\tif (mutex_lock_interruptible(&shortp_out_mutex))\n\t\treturn -ERESTARTSYS;\n\t/*\n\t * Out with the data.\n\t */\n\twhile (written < count) {\n\t\t/* Hang out until some buffer space is available. */\n\t\tspace = shortp_out_space();\n\t\tif (space <= 0) {\n\t\t\tif (wait_event_interruptible(shortp_out_queue,\n\t\t\t\t\t    (space = shortp_out_space()) > 0))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Move data into the buffer. */\n\t\tif ((space + written) > count)\n\t\t\tspace = count - written;\n\t\tif (copy_from_user((char *) shortp_out_head, buf, space)) {\n\t\t\tmutex_unlock(&shortp_out_mutex);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tshortp_incr_out_bp(&shortp_out_head, space);\n\t\tbuf += space;\n\t\twritten += space;\n\n\t\t/* If no output is active, make it active. */\n\t\tspin_lock_irqsave(&shortp_out_lock, flags);\n\t\tif (! shortp_output_active)\n\t\t\tshortp_start_output();\n\t\tspin_unlock_irqrestore(&shortp_out_lock, flags);\n\t}\n\nout:\n\t*f_pos += written;\n\tmutex_unlock(&shortp_out_mutex);\n\treturn written;\n}", "path": "LDD-LinuxDeviceDrivers/books/ldd/ldd4-master/shortprint/shortprint.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : LCD_Log2Phy(int Color)\n- \u02f5 : \u07fc\u026b\u05ea\u02b5\u026b\u03f2\u3eaf\n-  : color\n-  : \n*************************************************************************************************************\n*/\n", "func_signal": "U16 LCD_Log2Phy(U32 Color)", "code": "{\n    U16 PhyColor;\n  \n  \tPhyColor = Log2Phy(Color);\n  \n  \treturn PhyColor;\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : Log2Phy(int Color)\n- \u02f5 : \u07fc\u026b\u05ea\u02b5\u026b\n-  : color\n-  : \n*************************************************************************************************************\n*/\n", "func_signal": "U16 Log2Phy(U32 Color)", "code": "{\n  \tU32 r,g,b;\n  \tb = Color & 255;\n  \tg = (Color >> 8 ) & 255;\n  \tr = Color >> 16;\n  \tb = (b + 42) / 85;\n  \tg = (g * 7 + 127) / 255;\n  \tr = (r * 7 + 127) / 255;\n  \treturn b + (g << 2) + (r << 5);\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n * The read routine, which doesn't return data from the device; instead, it\n * returns timing information just like the \"short\" device.\n */\n", "func_signal": "static ssize_t shortp_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)", "code": "{\n\tint count0;\n\tDEFINE_WAIT(wait);\n\n\twhile (shortp_in_head == shortp_in_tail) {\n\t\tprepare_to_wait(&shortp_in_queue, &wait, TASK_INTERRUPTIBLE);\n\t\tif (shortp_in_head == shortp_in_tail)\n\t\t\tschedule();\n\t\tfinish_wait(&shortp_in_queue, &wait);\n\t\tif (signal_pending (current))  /* a signal arrived */\n\t\t\treturn -ERESTARTSYS; /* tell the fs layer to handle it */\n\t}\n\n\t/* count0 is the number of readable data bytes */\n\tcount0 = shortp_in_head - shortp_in_tail;\n\tif (count0 < 0) /* wrapped */\n\t\tcount0 = shortp_in_buffer + PAGE_SIZE - shortp_in_tail;\n\tif (count0 < count)\n\t\tcount = count0;\n\n\tif (copy_to_user(buf, (char *)shortp_in_tail, count))\n\t\treturn -EFAULT;\n\tshortp_incr_bp(&shortp_in_tail, count);\n\treturn count;\n}", "path": "LDD-LinuxDeviceDrivers/books/ldd/ldd4-master/shortprint/shortprint.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : static int OpenLCD(struct inode * inode, struct file * file)\n- \u02f5 : LCD\n-  : struct inode * inode, struct file * file\n-  : 0\n*************************************************************************************************************\n*/\n", "func_signal": "static int OpenLCD(struct inode * inode, struct file * file)", "code": "{\n\tprintk(\"LCD is open\\n\");\n\treturn 0;\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n * Write the next character from the buffer.  There should *be* a next\n * character...\t The spinlock should be held when this routine is called.\n */\n", "func_signal": "static void shortp_do_write(void)", "code": "{\n\tunsigned char cr = inb(shortp_base + SP_CONTROL);\n\n\t/* Something happened; reset the timer */\n\tmod_timer(&shortp_timer, jiffies + TIMEOUT);\n\n\t/* Strobe a byte out to the device */\n\toutb(*shortp_out_tail, shortp_base+SP_DATA);\n\tshortp_incr_out_bp(&shortp_out_tail, 1);\n\tif (shortp_delay)\n\t\tudelay(shortp_delay);\n\toutb(cr | SP_CR_STROBE, shortp_base+SP_CONTROL);\n\tif (shortp_delay)\n\t\tudelay(shortp_delay);\n\toutb(cr & ~SP_CR_STROBE, shortp_base+SP_CONTROL);\n}", "path": "LDD-LinuxDeviceDrivers/books/ldd/ldd4-master/shortprint/shortprint.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n * Available space in the output buffer; should be called with the mutex\n * held.  Returns contiguous space, so caller need not worry about wraps.\n */\n", "func_signal": "static inline int shortp_out_space(void)", "code": "{\n\tif (shortp_out_head >= shortp_out_tail) {\n\t\tint space = PAGE_SIZE - (shortp_out_head - shortp_out_buffer);\n\t\treturn (shortp_out_tail == shortp_out_buffer) ? space - 1 : space;\n\t} else\n\t\treturn (shortp_out_tail - shortp_out_head) - 1;\n}", "path": "LDD-LinuxDeviceDrivers/books/ldd/ldd4-master/shortprint/shortprint.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/*\n*************************************************************************************************************\n-  : void CloseLCD(struct inode * inode, struct file * file)\n- \u02f5 : LCD\u0631\n-  : struct inode * inode, struct file * file\n-  : 0\n*************************************************************************************************************\n*/\n", "func_signal": "static void CloseLCD(struct inode * inode, struct file * file)", "code": "{\n\tprintk(\"LCD is closed\\n\");\n\treturn ;\n}", "path": "LDD-LinuxDeviceDrivers/books/21cnbao/\u5b9e\u4f8b\u4ee3\u7801/lcd/driver/Lcd_driver.c", "commit_date": "2016-07-30 00:00:00", "repo_name": "gatieme/LDD-LinuxDeviceDrivers", "stars": 2158, "license": "gpl-3.0", "language": "c", "size": 118453}
{"docstring": "/* Called to allocate a buffer for the next stream read. */\n", "func_signal": "static void alloc_cb(uv_handle_t *stream, size_t suggested_size, uv_buf_t *buf)", "code": "{\n\tstruct transport *t;\n\t(void)suggested_size;\n\tt = stream->data;\n\tassert(t->read.base != NULL);\n\tassert(t->read.len > 0);\n\t*buf = t->read;\n}", "path": "dqlite/src/lib/transport.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* If n is not 0, then it is the number of elements. */\n", "func_signal": "TEST_CASE(decoder, init, row, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tchar buf[] = {2, 0, 0, 0, 0, 0, 0, 0, 0};\n\tstruct cursor cursor = {buf, sizeof buf};\n\t(void)data;\n\t(void)params;\n\tDECODER_INIT(3);\n\tmunit_assert_int(decoder.n, ==, 3);\n\tmunit_assert_int(tuple_decoder__n(&decoder), ==, 3);\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* The buffer needs to double its size once. */\n", "func_signal": "TEST_CASE(advance, double, NULL)", "code": "{\n\tstruct fixture *f = data;\n\tvoid *cursor;\n\t(void)params;\n\tADVANCE(16 + f->buffer.page_size);\n\tASSERT_N_PAGES(2);\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/lib/test_buffer.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Encode a tuple with row format and two values. */\n", "func_signal": "TEST_CASE(encoder, row, two_values, NULL)", "code": "{\n\tstruct encoder_fixture *f = data;\n\tstruct value value;\n\tuint8_t(*buf)[8] = f->buffer.data;\n\t(void)params;\n\n\tENCODER_INIT(2, TUPLE__ROW);\n\n\tvalue.type = SQLITE_INTEGER;\n\tvalue.integer = 7;\n\tENCODER_NEXT;\n\n\tvalue.type = SQLITE_TEXT;\n\tvalue.text = \"hello\";\n\tENCODER_NEXT;\n\n\tmunit_assert_int(buf[0][0], ==, SQLITE_INTEGER | SQLITE_TEXT << 4);\n\tmunit_assert_int(*(uint64_t *)buf[1], ==, byte__flip64(7));\n\tmunit_assert_string_equal((const char *)buf[2], \"hello\");\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Decode a null value. */\n", "func_signal": "TEST_CASE(decoder, type, null, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tuint8_t buf[][8] = {\n\t    {SQLITE_NULL, 0, 0, 0, 0, 0, 0, 0},\n\t    {0, 0, 0, 0, 0, 0, 0, 0},\n\t};\n\tstruct cursor cursor = {buf, sizeof buf};\n\tstruct value value;\n\n\t(void)data;\n\t(void)params;\n\n\tDECODER_INIT(1);\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(SQLITE_NULL);\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Decode a date string in ISO8601 format. */\n", "func_signal": "TEST_CASE(decoder, type, iso8601, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tuint8_t buf[5][8] = {\n\t    {DQLITE_ISO8601, 0, 0, 0, 0, 0, 0, 0},\n\t};\n\tstruct cursor cursor = {buf, sizeof buf};\n\tstruct value value;\n\n\t(void)data;\n\t(void)params;\n\n\tstrcpy((char *)buf[1], \"2018-07-20 09:49:05+00:00\");\n\n\tDECODER_INIT(1);\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(DQLITE_ISO8601);\n\tmunit_assert_string_equal(value.iso8601, \"2018-07-20 09:49:05+00:00\");\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Encode an ISO8601 date string time parameter. */\n", "func_signal": "TEST_CASE(encoder, type, iso8601, NULL)", "code": "{\n\tstruct encoder_fixture *f = data;\n\tstruct value value;\n\tuint8_t(*buf)[8] = f->buffer.data;\n\t(void)params;\n\n\tENCODER_INIT(1, TUPLE__ROW);\n\n\tvalue.type = DQLITE_ISO8601;\n\tvalue.iso8601 = \"2018-07-20 09:49:05+00:00\";\n\tENCODER_NEXT;\n\n\tmunit_assert_int(buf[0][0], ==, DQLITE_ISO8601);\n\tmunit_assert_string_equal((char *)buf[1], \"2018-07-20 09:49:05+00:00\");\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Decode a boolean. */\n", "func_signal": "TEST_CASE(decoder, type, boolean, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tuint8_t buf[][8] = {\n\t    {DQLITE_BOOLEAN, 0, 0, 0, 0, 0, 0, 0},\n\t    {1, 0, 0, 0, 0, 0, 0, 0},\n\t};\n\tstruct cursor cursor = {buf, sizeof buf};\n\tstruct value value;\n\n\t(void)data;\n\t(void)params;\n\n\tDECODER_INIT(1);\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(DQLITE_BOOLEAN);\n\tmunit_assert_int(value.boolean, ==, 1);\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Decode a tuple with row format and only one value. */\n", "func_signal": "TEST_CASE(decoder, row, one_value, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tuint8_t buf[][8] = {\n\t    {SQLITE_INTEGER, 0, 0, 0, 0, 0, 0, 0},\n\t    {7, 0, 0, 0, 0, 0, 0, 0},\n\t};\n\tstruct cursor cursor = {buf, sizeof buf};\n\tstruct value value;\n\n\t(void)data;\n\t(void)params;\n\n\tDECODER_INIT(1);\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(SQLITE_INTEGER);\n\tmunit_assert_int(value.integer, ==, 7);\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Encode a float parameter. */\n", "func_signal": "TEST_CASE(encoder, type, float, NULL)", "code": "{\n\tstruct encoder_fixture *f = data;\n\tstruct value value;\n\tuint8_t(*buf)[8] = f->buffer.data;\n\t(void)params;\n\n\tENCODER_INIT(1, TUPLE__ROW);\n\n\tvalue.type = SQLITE_FLOAT;\n\tvalue.float_ = 3.1415;\n\tENCODER_NEXT;\n\n\tmunit_assert_int(buf[0][0], ==, SQLITE_FLOAT);\n\tmunit_assert_int(*(uint64_t *)buf[1], ==,\n\t\t\t byte__flip64(*(uint64_t *)&value.float_));\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Get a previously registered db. */\n", "func_signal": "TEST_CASE(db, get_existing, NULL)", "code": "{\n\tstruct db_fixture *f = data;\n\tstruct db *db1;\n\tstruct db *db2;\n\t(void)params;\n\tint rc;\n\trc = registry__db_get(&f->registry, \"test.db\", &db1);\n\tmunit_assert_int(rc, ==, 0);\n\trc = registry__db_get(&f->registry, \"test.db\", &db2);\n\tmunit_assert_int(rc, ==, 0);\n\tmunit_assert_ptr_equal(db1, db2);\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_registry.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Decode a floating point number. */\n", "func_signal": "TEST_CASE(decoder, type, float, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tuint8_t buf[][8] = {\n\t    {SQLITE_FLOAT, 0, 0, 0, 0, 0, 0, 0},\n\t    {0, 0, 0, 0, 0, 0, 0, 0},\n\t};\n\tstruct cursor cursor = {buf, sizeof buf};\n\tstruct value value;\n\tdouble pi = 3.1415;\n\n\t(void)data;\n\t(void)params;\n\n\tmemcpy(buf[1], &pi, sizeof pi);\n\t*(uint64_t *)buf[1] = byte__flip64(*(uint64_t *)buf[1]);\n\n\tDECODER_INIT(1);\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(SQLITE_FLOAT);\n\tmunit_assert_double(value.float_, ==, 3.1415);\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Decode a tuple with row format and two values. */\n", "func_signal": "TEST_CASE(decoder, row, two_values, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tuint8_t buf[][8] = {\n\t    {SQLITE_INTEGER | SQLITE_TEXT << 4, 0, 0, 0, 0, 0, 0, 0},\n\t    {7, 0, 0, 0, 0, 0, 0, 0},\n\t    {'h', 'e', 'l', 'l', 'o', 0, 0, 0},\n\t};\n\tstruct cursor cursor = {buf, sizeof buf};\n\tstruct value value;\n\n\t(void)data;\n\t(void)params;\n\n\tDECODER_INIT(2);\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(SQLITE_INTEGER);\n\tmunit_assert_int(value.integer, ==, 7);\n\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(SQLITE_TEXT);\n\tmunit_assert_string_equal(value.text, \"hello\");\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Get a db that didn't exist before. */\n", "func_signal": "TEST_CASE(db, get_new, NULL)", "code": "{\n\tstruct db_fixture *f = data;\n\tstruct db *db;\n\t(void)params;\n\tint rc;\n\trc = registry__db_get(&f->registry, \"test.db\", &db);\n\tmunit_assert_int(rc, ==, 0);\n\tmunit_assert_string_equal(db->filename, \"test.db\");\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_registry.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Decode a tuple with params format and only one value. */\n", "func_signal": "TEST_CASE(decoder, params, one_value, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tuint8_t buf[][8] = {\n\t    {1, SQLITE_INTEGER, 0, 0, 0, 0, 0, 0},\n\t    {7, 0, 0, 0, 0, 0, 0, 0},\n\t};\n\tstruct cursor cursor = {buf, sizeof buf};\n\tstruct value value;\n\n\t(void)data;\n\t(void)params;\n\n\tDECODER_INIT(0);\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(SQLITE_INTEGER);\n\tmunit_assert_int(value.integer, ==, 7);\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Encode a boolean parameter. */\n", "func_signal": "TEST_CASE(encoder, type, boolean, NULL)", "code": "{\n\tstruct encoder_fixture *f = data;\n\tstruct value value;\n\tuint8_t(*buf)[8] = f->buffer.data;\n\t(void)params;\n\n\tENCODER_INIT(1, TUPLE__ROW);\n\n\tvalue.type = DQLITE_BOOLEAN;\n\tvalue.boolean = 1;\n\tENCODER_NEXT;\n\n\tmunit_assert_int(buf[0][0], ==, DQLITE_BOOLEAN);\n\tmunit_assert_int(*(uint64_t *)buf[1], ==, byte__flip64(value.boolean));\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Encode a tuple with params format and only one value. */\n", "func_signal": "TEST_CASE(encoder, params, one_value, NULL)", "code": "{\n\tstruct encoder_fixture *f = data;\n\tstruct value value;\n\tuint8_t(*buf)[8] = f->buffer.data;\n\t(void)params;\n\n\tENCODER_INIT(1, TUPLE__PARAMS);\n\n\tvalue.type = SQLITE_INTEGER;\n\tvalue.integer = 7;\n\tENCODER_NEXT;\n\n\tmunit_assert_int(buf[0][0], ==, 1);\n\tmunit_assert_int(buf[0][1], ==, SQLITE_INTEGER);\n\tmunit_assert_int(*(uint64_t *)buf[1], ==, byte__flip64(7));\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Encode a unix time parameter. */\n", "func_signal": "TEST_CASE(encoder, type, unixtime, NULL)", "code": "{\n\tstruct encoder_fixture *f = data;\n\tstruct value value;\n\tuint8_t(*buf)[8] = f->buffer.data;\n\t(void)params;\n\n\tENCODER_INIT(1, TUPLE__ROW);\n\n\tvalue.type = DQLITE_UNIXTIME;\n\tvalue.unixtime = 12345;\n\tENCODER_NEXT;\n\n\tmunit_assert_int(buf[0][0], ==, DQLITE_UNIXTIME);\n\tmunit_assert_int(*(int64_t *)buf[1], ==, byte__flip64(value.unixtime));\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Decode a tuple with params format and two values. */\n", "func_signal": "TEST_CASE(decoder, params, two_values, NULL)", "code": "{\n\tstruct tuple_decoder decoder;\n\tuint8_t buf[][8] = {\n\t    {2, SQLITE_INTEGER, SQLITE_TEXT, 0, 0, 0, 0, 0},\n\t    {7, 0, 0, 0, 0, 0, 0, 0},\n\t    {'h', 'e', 'l', 'l', 'o', 0, 0, 0},\n\t};\n\tstruct cursor cursor = {buf, sizeof buf};\n\tstruct value value;\n\n\t(void)data;\n\t(void)params;\n\n\tDECODER_INIT(0);\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(SQLITE_INTEGER);\n\tmunit_assert_int(value.integer, ==, 7);\n\n\tDECODER_NEXT;\n\n\tASSERT_VALUE_TYPE(SQLITE_TEXT);\n\tmunit_assert_string_equal(value.text, \"hello\");\n\n\treturn MUNIT_OK;\n}", "path": "dqlite/test/unit/test_tuple.c", "commit_date": "2019-06-23 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Set an error message by rendering the given format against the given\n * parameters.\n *\n * Any previously set error message will be cleared. */\n", "func_signal": "static void dqlite__error_vprintf(dqlite__error *e,\n                                  const char *   fmt,\n                                  va_list        args)", "code": "{\n\tassert(fmt != NULL);\n\n\t/* If a previous error was set (other than the hard-coded OOM fallback\n\t * fallback), let's free it. */\n\tif (*e != NULL && *e != dqlite__error_oom_msg) {\n\t\tsqlite3_free(*e);\n\t}\n\n\t/* Render the message. In case of error we fallback to the hard-coded\n\t * OOM fallback message. */\n\t*e = sqlite3_vmprintf(fmt, args);\n\tif (*e == NULL) {\n\t\t*e = dqlite__error_oom_msg;\n\t}\n}", "path": "dqlite/src/error.c", "commit_date": "2020-07-24 00:00:00", "repo_name": "canonical/dqlite", "stars": 3668, "license": "other", "language": "c", "size": 3166}
{"docstring": "/* Create a new skiplist_node with given level and data. */\n", "func_signal": "static struct skiplist_node *\nskiplist_create_node(int level, const void *object)", "code": "{\n    struct skiplist_node *new_node;\n    size_t alloc_size = sizeof *new_node +\n                        (level + 1) * sizeof new_node->forward[0];\n\n    new_node = xmalloc(alloc_size);\n    new_node->data = object;\n    memset(new_node->forward, 0,\n           (level + 1) * sizeof new_node->forward[0]);\n\n    return new_node;\n}", "path": "ovs/lib/skiplist.c", "commit_date": "2019-02-05 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Removes all node from 'hmap', leaving it ready to accept more nodes.  Does\n * not free memory allocated for 'hmap'.\n *\n * This function is appropriate when 'hmap' will soon have about as many\n * elements as it did before.  If 'hmap' will likely have fewer elements than\n * before, use hmap_destroy() followed by hmap_init() to save memory and\n * iteration time. */\n", "func_signal": "void\nhmap_clear(struct hmap *hmap)", "code": "{\n    if (hmap->n > 0) {\n        hmap->n = 0;\n        memset(hmap->buckets, 0, (hmap->mask + 1) * sizeof *hmap->buckets);\n    }\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/*\n * Determine the level for a skiplist node by choosing a level N with\n * probability P(N) = 1/(2**(N+1)) in the range 0..32, with  the returned\n * level clamped at the current skiplist height plus 1.\n */\n", "func_signal": "static int\nskiplist_determine_level(struct skiplist *sl)", "code": "{\n    int lvl;\n\n    lvl = clz32(random_uint32());\n\n    return MIN(lvl, sl->level + 1);\n}", "path": "ovs/lib/skiplist.c", "commit_date": "2019-02-05 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/*\n * Destroy a skiplist and free all nodes in the list.  If the \"data_destroy\"\n * function pointer is non-NULL, it will be called for each node as it is\n * removed to allow any needed cleanups to be performed on the associated\n * data.\n */\n", "func_signal": "void\nskiplist_destroy(struct skiplist *sl, void (*data_destroy)(void *))", "code": "{\n    struct skiplist_node *node, *next;\n\n    next = node = sl->header;\n    while (next != NULL) {\n        next = node->forward[0];\n        if (data_destroy) {\n            data_destroy(CONST_CAST(void *, node->data));\n        }\n        free(node);\n        node = next;\n    }\n    free(sl);\n}", "path": "ovs/lib/skiplist.c", "commit_date": "2019-02-05 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/*\n * Create a new skiplist, configured with given data comparison function\n * and configuration.\n */\n", "func_signal": "struct skiplist *\nskiplist_create(skiplist_comparator object_comparator, void *configuration)", "code": "{\n    random_init();\n    struct skiplist *sl;\n\n    sl = xmalloc(sizeof (struct skiplist));\n    sl->cfg = configuration;\n    sl->size = 0;\n    sl->level = 0;\n    sl->cmp = object_comparator;\n    sl->header = skiplist_create_node(SKIPLIST_MAX_LEVELS, NULL);\n\n    return sl;\n}", "path": "ovs/lib/skiplist.c", "commit_date": "2019-02-05 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/*_________________---------------------------------__________________\n  _________________   sequence number reset         __________________\n  -----------------_________________________________------------------\n  Used to indicate a counter discontinuity\n  so that the sflow collector will know to ignore the next delta.\n*/\n", "func_signal": "void sfl_poller_resetCountersSeqNo(SFLPoller *poller)", "code": "{  poller->countersSampleSeqNo = 0; }\n\n/*_________________---------------------------__________________\n  _________________    sfl_poller_tick        __________________\n  -----------------___________________________------------------\n*/\n\nvoid sfl_poller_tick(SFLPoller *poller, time_t now)\n{\n    if(poller->countersCountdown == 0) return; /* counters retrieval was not enabled */\n    if(poller->sFlowCpReceiver == 0) return;\n\n    if(--poller->countersCountdown == 0) {\n\tif(poller->getCountersFn != NULL) {\n\t    /* call out for counters */\n\t    SFL_COUNTERS_SAMPLE_TYPE cs;\n\t    memset(&cs, 0, sizeof(cs));\n\t    poller->getCountersFn(poller->magic, poller, &cs);\n\t    /* this countersFn is expected to fill in some counter block elements\n\t       and then call sfl_poller_writeCountersSample(poller, &cs); */\n\t}\n\t/* reset the countdown */\n\tpoller->countersCountdown = poller->sFlowCpInterval;\n    }\n}", "path": "ovs/lib/sflow_poller.c", "commit_date": "2011-12-11 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/*\n * Move the cursor forward to the first node with associated data greater than\n * or equal to \"value\".\n */\n", "func_signal": "static struct skiplist_node *\nskiplist_forward_to_(struct skiplist *sl, const void *value,\n                     struct skiplist_node **update)", "code": "{\n    struct skiplist_node *x = sl->header;\n    int i;\n\n    /* Loop invariant: x < value */\n    for (i = sl->level; i >= 0; i--) {\n        while (x->forward[i] &&\n               sl->cmp(x->forward[i]->data, value, sl->cfg) < 0) {\n            x = x->forward[i];\n        }\n        /* x < value <= x->forward[1] */\n        if (update) {\n            update[i] = x;\n        }\n    }\n    /* x < value <= x->forward[1] */\n    x = x->forward[0];\n    return x;\n}", "path": "ovs/lib/skiplist.c", "commit_date": "2019-02-05 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Adjusts 'hmap' to compensate for 'old_node' having moved position in memory\n * to 'node' (e.g. due to realloc()). */\n", "func_signal": "void\nhmap_node_moved(struct hmap *hmap,\n                struct hmap_node *old_node, struct hmap_node *node)", "code": "{\n    struct hmap_node **bucket = &hmap->buckets[node->hash & hmap->mask];\n    while (*bucket != old_node) {\n        bucket = &(*bucket)->next;\n    }\n    *bucket = node;\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Expands 'hmap', if necessary, to optimize the performance of searches when\n * it has up to 'n' elements.  (But iteration will be slow in a hash map whose\n * allocated capacity is much higher than its current number of nodes.)\n *\n * ('where' is used in debug logging.  Commonly one would use hmap_reserve() to\n * automatically provide the caller's source file and line number for\n * 'where'.) */\n", "func_signal": "void\nhmap_reserve_at(struct hmap *hmap, size_t n, const char *where)", "code": "{\n    size_t new_mask = calc_mask(n);\n    if (new_mask > hmap->mask) {\n        COVERAGE_INC(hmap_reserve);\n        resize(hmap, new_mask, where);\n    }\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Returns true if 'node' is in 'hmap', false otherwise. */\n", "func_signal": "bool\nhmap_contains(const struct hmap *hmap, const struct hmap_node *node)", "code": "{\n    struct hmap_node *p;\n\n    for (p = hmap_first_in_bucket(hmap, node->hash); p; p = p->next) {\n        if (p == node) {\n            return true;\n        }\n    }\n\n    return false;\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Returns the next node in 'hmap' in hash order, or NULL if no nodes remain in\n * 'hmap'.  Uses '*pos' to determine where to begin iteration, and updates\n * '*pos' to pass on the next iteration into them before returning.\n *\n * It's better to use plain HMAP_FOR_EACH and related functions, since they are\n * faster and better at dealing with hmaps that change during iteration.\n *\n * Before beginning iteration, set '*pos' to all zeros. */\n", "func_signal": "struct hmap_node *\nhmap_at_position(const struct hmap *hmap,\n                 struct hmap_position *pos)", "code": "{\n    size_t offset;\n    size_t b_idx;\n\n    offset = pos->offset;\n    for (b_idx = pos->bucket; b_idx <= hmap->mask; b_idx++) {\n        struct hmap_node *node;\n        size_t n_idx;\n\n        for (n_idx = 0, node = hmap->buckets[b_idx]; node != NULL;\n             n_idx++, node = node->next) {\n            if (n_idx == offset) {\n                if (node->next) {\n                    pos->bucket = node->hash & hmap->mask;\n                    pos->offset = offset + 1;\n                } else {\n                    pos->bucket = (node->hash & hmap->mask) + 1;\n                    pos->offset = 0;\n                }\n                return node;\n            }\n        }\n        offset = 0;\n    }\n\n    pos->bucket = 0;\n    pos->offset = 0;\n    return NULL;\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Destroys 'q' and removes it from 'ps''s set of queues.\n * (The caller must ensure that 'q' is empty.) */\n", "func_signal": "static void\npinqueue_destroy(struct pinsched *ps, struct pinqueue *q)", "code": "{\n    if (ps->next_txq == q) {\n        advance_txq(ps);\n        if (ps->next_txq == q) {\n            ps->next_txq = NULL;\n        }\n    }\n    hmap_remove(&ps->queues, &q->node);\n    free(q);\n}", "path": "ovs/ofproto/pinsched.c", "commit_date": "2017-11-03 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Insert data into a skiplist. */\n", "func_signal": "void\nskiplist_insert(struct skiplist *list, const void *value)", "code": "{\n    struct skiplist_node *update[SKIPLIST_MAX_LEVELS + 1];\n    struct skiplist_node *x = skiplist_forward_to_(list, value, update);\n    int i, lvl;\n\n    if (x && list->cmp(x->data, value, list->cfg) == 0) {\n        x->data = value;\n    } else {\n        lvl = skiplist_determine_level(list);\n        if (lvl > list->level) {\n            for (i = list->level + 1; i <= lvl; i++) {\n                update[i] = list->header;\n            }\n            list->level = lvl;\n        }\n        x = skiplist_create_node(lvl, value);\n        for (i = 0; i <= lvl; i++) {\n            x->forward[i] = update[i]->forward[i];\n            update[i]->forward[i] = x;\n        }\n        list->size++;\n    }\n}", "path": "ovs/lib/skiplist.c", "commit_date": "2019-02-05 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/*_________________--------------------------__________________\n  _________________       reset              __________________\n  -----------------__________________________------------------\n*/\n", "func_signal": "static void reset(SFLPoller *poller)", "code": "{\n    SFLDataSource_instance dsi = poller->dsi;\n    sfl_poller_init(poller, poller->agent, &dsi, poller->magic, poller->getCountersFn);\n}", "path": "ovs/lib/sflow_poller.c", "commit_date": "2011-12-11 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Adjusts 'hmap' to compensate for having moved position in memory (e.g. due\n * to realloc()). */\n", "func_signal": "void\nhmap_moved(struct hmap *hmap)", "code": "{\n    if (!hmap->mask) {\n        hmap->buckets = &hmap->one;\n    }\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Expands 'hmap', if necessary, to optimize the performance of searches.\n *\n * ('where' is used in debug logging.  Commonly one would use hmap_expand() to\n * automatically provide the caller's source file and line number for\n * 'where'.) */\n", "func_signal": "void\nhmap_expand_at(struct hmap *hmap, const char *where)", "code": "{\n    size_t new_mask = calc_mask(hmap->n);\n    if (new_mask > hmap->mask) {\n        COVERAGE_INC(hmap_expand);\n        resize(hmap, new_mask, where);\n    }\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Remove first node with associated data equal to \"value\" from skiplist. */\n", "func_signal": "void *\nskiplist_delete(struct skiplist *list, const void *value)", "code": "{\n    struct skiplist_node *update[SKIPLIST_MAX_LEVELS + 1];\n    struct skiplist_node *x;\n    void *data = NULL;\n    int i;\n\n    x = skiplist_forward_to_(list, value, update);\n\n    if (x && list->cmp(x->data, value, list->cfg) == 0) {\n        for (i = 0; i <= list->level; i++) {\n            if (update[i]->forward[i] != x) {\n                break;\n            }\n            update[i]->forward[i] = x->forward[i];\n        }\n        data = CONST_CAST(void *, x->data);\n\n        free(x);\n\n        while (list->level > 0 && !list->header->forward[list->level]) {\n            list->level--;\n        }\n        list->size--;\n    }\n    return data;\n}", "path": "ovs/lib/skiplist.c", "commit_date": "2019-02-05 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Flush command */\n", "func_signal": "static void\ntest_nl_ct_flush(struct ovs_cmdl_context *ctx OVS_UNUSED)", "code": "{\n    int err;\n\n    if (ctx->argc >= 2) {\n        uint16_t zone;\n\n        if (ovs_scan(ctx->argv[1], \"zone=%\"SCNu16, &zone)) {\n            err = nl_ct_flush_zone(zone);\n        } else {\n            ovs_fatal(0, \"Error parsing zone= specifier\");\n        }\n    } else {\n        err = nl_ct_flush();\n    }\n    if (err) {\n        ovs_fatal(err, \"Error flushing conntrack netlink\");\n    }\n}", "path": "ovs/tests/test-netlink-conntrack.c", "commit_date": "2017-11-03 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Chooses and returns a randomly selected node from 'hmap', which must not be\n * empty.\n *\n * I wouldn't depend on this algorithm to be fair, since I haven't analyzed it.\n * But it does at least ensure that any node in 'hmap' can be chosen. */\n", "func_signal": "struct hmap_node *\nhmap_random_node(const struct hmap *hmap)", "code": "{\n    struct hmap_node *bucket, *node;\n    size_t n, i;\n\n    /* Choose a random non-empty bucket. */\n    for (;;) {\n        bucket = hmap->buckets[random_uint32() & hmap->mask];\n        if (bucket) {\n            break;\n        }\n    }\n\n    /* Count nodes in bucket. */\n    n = 0;\n    for (node = bucket; node; node = node->next) {\n        n++;\n    }\n\n    /* Choose random node from bucket. */\n    i = random_range(n);\n    for (node = bucket; i-- > 0; node = node->next) {\n        continue;\n    }\n    return node;\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* Frees memory reserved by 'hmap'.  It is the client's responsibility to free\n * the nodes themselves, if necessary. */\n", "func_signal": "void\nhmap_destroy(struct hmap *hmap)", "code": "{\n    if (hmap && hmap->buckets != &hmap->one) {\n        free(hmap->buckets);\n    }\n}", "path": "ovs/lib/hmap.c", "commit_date": "2019-03-26 00:00:00", "repo_name": "openvswitch/ovs", "stars": 3380, "license": "apache-2.0", "language": "c", "size": 125489}
{"docstring": "/* PFORMAT points to a '%' followed by a prefix of a format, all of\n   size PREFIX_LEN.  The flags allowed for this format are\n   ALLOWED_FLAGS; remove other printf flags from the prefix, then\n   append SUFFIX.  */\n", "func_signal": "static void\nmake_format (char *pformat, size_t prefix_len, char const *allowed_flags,\n             char const *suffix)", "code": "{\n  char *dst = pformat + 1;\n  char const *src;\n  char const *srclim = pformat + prefix_len;\n  for (src = dst; src < srclim && strchr (printf_flags, *src); src++)\n    if (strchr (allowed_flags, *src))\n      *dst++ = *src;\n  while (src < srclim)\n    *dst++ = *src++;\n  strcpy (dst, suffix);\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Print stat info.  Return zero upon success, nonzero upon failure.  */\n", "func_signal": "static bool\nprint_stat (char *pformat, size_t prefix_len, unsigned int m,\n            int fd, char const *filename, void const *data)", "code": "{\n  struct print_args *parg = (struct print_args *) data;\n  struct stat *statbuf = parg->st;\n  struct timespec btime = parg->btime;\n  struct passwd *pw_ent;\n  struct group *gw_ent;\n  bool fail = false;\n\n  switch (m)\n    {\n    case 'n':\n      out_string (pformat, prefix_len, filename);\n      break;\n    case 'N':\n      out_string (pformat, prefix_len, quoteN (filename));\n      if (S_ISLNK (statbuf->st_mode))\n        {\n          char *linkname = areadlink_with_size (filename, statbuf->st_size);\n          if (linkname == NULL)\n            {\n              error (0, errno, _(\"cannot read symbolic link %s\"),\n                     quoteaf (filename));\n              return true;\n            }\n          printf (\" -> \");\n          out_string (pformat, prefix_len, quoteN (linkname));\n          free (linkname);\n        }\n      break;\n    case 'd':\n      out_uint (pformat, prefix_len, statbuf->st_dev);\n      break;\n    case 'D':\n      out_uint_x (pformat, prefix_len, statbuf->st_dev);\n      break;\n    case 'i':\n      out_uint (pformat, prefix_len, statbuf->st_ino);\n      break;\n    case 'a':\n      out_uint_o (pformat, prefix_len, statbuf->st_mode & CHMOD_MODE_BITS);\n      break;\n    case 'A':\n      out_string (pformat, prefix_len, human_access (statbuf));\n      break;\n    case 'f':\n      out_uint_x (pformat, prefix_len, statbuf->st_mode);\n      break;\n    case 'F':\n      out_string (pformat, prefix_len, file_type (statbuf));\n      break;\n    case 'h':\n      out_uint (pformat, prefix_len, statbuf->st_nlink);\n      break;\n    case 'u':\n      out_uint (pformat, prefix_len, statbuf->st_uid);\n      break;\n    case 'U':\n      pw_ent = getpwuid (statbuf->st_uid);\n      out_string (pformat, prefix_len,\n                  pw_ent ? pw_ent->pw_name : \"UNKNOWN\");\n      break;\n    case 'g':\n      out_uint (pformat, prefix_len, statbuf->st_gid);\n      break;\n    case 'G':\n      gw_ent = getgrgid (statbuf->st_gid);\n      out_string (pformat, prefix_len,\n                  gw_ent ? gw_ent->gr_name : \"UNKNOWN\");\n      break;\n    case 'm':\n      fail |= out_mount_point (filename, pformat, prefix_len, statbuf);\n      break;\n    case 's':\n      out_int (pformat, prefix_len, statbuf->st_size);\n      break;\n    case 't':\n      out_uint_x (pformat, prefix_len, major (statbuf->st_rdev));\n      break;\n    case 'T':\n      out_uint_x (pformat, prefix_len, minor (statbuf->st_rdev));\n      break;\n    case 'B':\n      out_uint (pformat, prefix_len, ST_NBLOCKSIZE);\n      break;\n    case 'b':\n      out_uint (pformat, prefix_len, ST_NBLOCKS (*statbuf));\n      break;\n    case 'o':\n      out_uint (pformat, prefix_len, ST_BLKSIZE (*statbuf));\n      break;\n    case 'w':\n      {\n#if ! USE_STATX\n        btime = get_birthtime (fd, filename, statbuf);\n#endif\n        if (btime.tv_nsec < 0)\n          out_string (pformat, prefix_len, \"-\");\n        else\n          out_string (pformat, prefix_len, human_time (btime));\n      }\n      break;\n    case 'W':\n      {\n#if ! USE_STATX\n        btime = get_birthtime (fd, filename, statbuf);\n#endif\n        out_epoch_sec (pformat, prefix_len, neg_to_zero (btime));\n      }\n      break;\n    case 'x':\n      out_string (pformat, prefix_len, human_time (get_stat_atime (statbuf)));\n      break;\n    case 'X':\n      out_epoch_sec (pformat, prefix_len, get_stat_atime (statbuf));\n      break;\n    case 'y':\n      out_string (pformat, prefix_len, human_time (get_stat_mtime (statbuf)));\n      break;\n    case 'Y':\n      out_epoch_sec (pformat, prefix_len, get_stat_mtime (statbuf));\n      break;\n    case 'z':\n      out_string (pformat, prefix_len, human_time (get_stat_ctime (statbuf)));\n      break;\n    case 'Z':\n      out_epoch_sec (pformat, prefix_len, get_stat_ctime (statbuf));\n      break;\n    case 'C':\n      fail |= out_file_context (pformat, prefix_len, filename);\n      break;\n    default:\n      fputc ('?', stdout);\n      break;\n    }\n  return fail;\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Send signal SIGNUM to all the processes or process groups specified\n   by ARGV.  Return a suitable exit status.  */\n", "func_signal": "static int\nsend_signals (int signum, char *const *argv)", "code": "{\n  int status = EXIT_SUCCESS;\n  char const *arg = *argv;\n\n  do\n    {\n      char *endp;\n      intmax_t n = (errno = 0, strtoimax (arg, &endp, 10));\n      pid_t pid = n;\n\n      if (errno == ERANGE || pid != n || arg == endp || *endp)\n        {\n          error (0, 0, _(\"%s: invalid process id\"), quote (arg));\n          status = EXIT_FAILURE;\n        }\n      else if (kill (pid, signum) != 0)\n        {\n          error (0, errno, \"%s\", quote (arg));\n          status = EXIT_FAILURE;\n        }\n    }\n  while ((arg = *++argv));\n\n  return status;\n}", "path": "coreutils/src/kill.c", "commit_date": "2020-01-01 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Print the context information of FILENAME, and return true iff the\n   context could not be obtained.  */\n", "func_signal": "static bool ATTRIBUTE_WARN_UNUSED_RESULT\nout_file_context (char *pformat, size_t prefix_len, char const *filename)", "code": "{\n  char *scontext;\n  bool fail = false;\n\n  if ((follow_links\n       ? getfilecon (filename, &scontext)\n       : lgetfilecon (filename, &scontext)) < 0)\n    {\n      error (0, errno, _(\"failed to get security context of %s\"),\n             quoteaf (filename));\n      scontext = NULL;\n      fail = true;\n    }\n  strcpy (pformat + prefix_len, \"s\");\n  printf (pformat, (scontext ? scontext : \"?\"));\n  if (scontext)\n    freecon (scontext);\n  return fail;\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Output a single-character \\ escape.  */\n", "func_signal": "static void\nprint_esc_char (char c)", "code": "{\n  switch (c)\n    {\n    case 'a':\t\t\t/* Alert. */\n      c ='\\a';\n      break;\n    case 'b':\t\t\t/* Backspace. */\n      c ='\\b';\n      break;\n    case 'e':\t\t\t/* Escape. */\n      c ='\\x1B';\n      break;\n    case 'f':\t\t\t/* Form feed. */\n      c ='\\f';\n      break;\n    case 'n':\t\t\t/* New line. */\n      c ='\\n';\n      break;\n    case 'r':\t\t\t/* Carriage return. */\n      c ='\\r';\n      break;\n    case 't':\t\t\t/* Horizontal tab. */\n      c ='\\t';\n      break;\n    case 'v':\t\t\t/* Vertical tab. */\n      c ='\\v';\n      break;\n    case '\"':\n    case '\\\\':\n      break;\n    default:\n      error (0, 0, _(\"warning: unrecognized escape '\\\\%c'\"), c);\n      break;\n    }\n  putchar (c);\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Trim leading 0's from S, but if S is all 0's, leave one.\n   Return a pointer to the trimmed string.  */\n", "func_signal": "static char const * _GL_ATTRIBUTE_PURE\ntrim_leading_zeros (char const *s)", "code": "{\n  char const *p = s;\n  while (*s == '0')\n    ++s;\n\n  /* If there were only 0's, back up, to leave one.  */\n  if (!*s && s != p)\n    --s;\n  return s;\n}", "path": "coreutils/src/seq.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Print statfs info.  Return zero upon success, nonzero upon failure.  */\n", "func_signal": "static bool ATTRIBUTE_WARN_UNUSED_RESULT\nprint_statfs (char *pformat, size_t prefix_len, unsigned int m,\n              int fd, char const *filename,\n              void const *data)", "code": "{\n  STRUCT_STATVFS const *statfsbuf = data;\n  bool fail = false;\n\n  switch (m)\n    {\n    case 'n':\n      out_string (pformat, prefix_len, filename);\n      break;\n\n    case 'i':\n      {\n#if STRUCT_STATXFS_F_FSID_IS_INTEGER\n        uintmax_t fsid = statfsbuf->f_fsid;\n#else\n        typedef unsigned int fsid_word;\n        verify (alignof (STRUCT_STATVFS) % alignof (fsid_word) == 0);\n        verify (offsetof (STRUCT_STATVFS, f_fsid) % alignof (fsid_word) == 0);\n        verify (sizeof statfsbuf->f_fsid % alignof (fsid_word) == 0);\n        fsid_word const *p = (fsid_word *) &statfsbuf->f_fsid;\n\n        /* Assume a little-endian word order, as that is compatible\n           with glibc's statvfs implementation.  */\n        uintmax_t fsid = 0;\n        int words = sizeof statfsbuf->f_fsid / sizeof *p;\n        for (int i = 0; i < words && i * sizeof *p < sizeof fsid; i++)\n          {\n            uintmax_t u = p[words - 1 - i];\n            fsid |= u << (i * CHAR_BIT * sizeof *p);\n          }\n#endif\n        out_uint_x (pformat, prefix_len, fsid);\n      }\n      break;\n\n    case 'l':\n      OUT_NAMEMAX (pformat, prefix_len, SB_F_NAMEMAX (statfsbuf));\n      break;\n    case 't':\n#if HAVE_STRUCT_STATXFS_F_TYPE\n      out_uint_x (pformat, prefix_len, statfsbuf->f_type);\n#else\n      fputc ('?', stdout);\n#endif\n      break;\n    case 'T':\n      out_string (pformat, prefix_len, human_fstype (statfsbuf));\n      break;\n    case 'b':\n      out_int (pformat, prefix_len, statfsbuf->f_blocks);\n      break;\n    case 'f':\n      out_int (pformat, prefix_len, statfsbuf->f_bfree);\n      break;\n    case 'a':\n      out_int (pformat, prefix_len, statfsbuf->f_bavail);\n      break;\n    case 's':\n      out_uint (pformat, prefix_len, statfsbuf->f_bsize);\n      break;\n    case 'S':\n      {\n        uintmax_t frsize = STATFS_FRSIZE (statfsbuf);\n        if (! frsize)\n          frsize = statfsbuf->f_bsize;\n        out_uint (pformat, prefix_len, frsize);\n      }\n      break;\n    case 'c':\n      out_uint (pformat, prefix_len, statfsbuf->f_files);\n      break;\n    case 'd':\n      out_int (pformat, prefix_len, statfsbuf->f_ffree);\n      break;\n    default:\n      fputc ('?', stdout);\n      break;\n    }\n  return fail;\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Return the type of the specified file system.\n   Some systems have statfvs.f_basetype[FSTYPSZ] (AIX, HP-UX, and Solaris).\n   Others have statvfs.f_fstypename[_VFS_NAMELEN] (NetBSD 3.0).\n   Others have statfs.f_fstypename[MFSNAMELEN] (NetBSD 1.5.2).\n   Still others have neither and have to get by with f_type (GNU/Linux).\n   But f_type may only exist in statfs (Cygwin).  */\n", "func_signal": "static char const * ATTRIBUTE_WARN_UNUSED_RESULT\nhuman_fstype (STRUCT_STATVFS const *statfsbuf)", "code": "{\n#ifdef STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME\n  return statfsbuf->STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME;\n#else\n  switch (statfsbuf->f_type)\n    {\n# if defined __linux__ || defined __ANDROID__\n\n      /* Compare with what's in libc:\n         f=/a/libc/sysdeps/unix/sysv/linux/linux_fsinfo.h\n         sed -n '/ADFS_SUPER_MAGIC/,/SYSFS_MAGIC/p' $f \\\n           | perl -n -e '/#define (.*?)_(?:SUPER_)MAGIC\\s+0x(\\S+)/' \\\n             -e 'and print \"case S_MAGIC_$1: /\\* 0x\" . uc($2) . \" *\\/\\n\"' \\\n           | sort > sym_libc\n         perl -ne '/^\\s+(case S_MAGIC_.*?): \\/\\* 0x(\\S+) \\*\\//' \\\n             -e 'and do { $v=uc$2; print \"$1: /\\* 0x$v *\\/\\n\"}' stat.c \\\n           | sort > sym_stat\n         diff -u sym_stat sym_libc\n      */\n\n      /* Also compare with the list in \"man 2 statfs\" using the\n         fs-magic-compare make target.  */\n\n      /* IMPORTANT NOTE: Each of the following 'case S_MAGIC_...:'\n         statements must be followed by a hexadecimal constant in\n         a comment.  The S_MAGIC_... name and constant are automatically\n         combined to produce the #define directives in fs.h.  */\n\n    case S_MAGIC_AAFS: /* 0x5A3C69F0 local */\n      return \"aafs\";\n    case S_MAGIC_ACFS: /* 0x61636673 remote */\n      return \"acfs\";\n    case S_MAGIC_ADFS: /* 0xADF5 local */\n      return \"adfs\";\n    case S_MAGIC_AFFS: /* 0xADFF local */\n      return \"affs\";\n    case S_MAGIC_AFS: /* 0x5346414F remote */\n      return \"afs\";\n    case S_MAGIC_ANON_INODE_FS: /* 0x09041934 local */\n      return \"anon-inode FS\";\n    case S_MAGIC_AUFS: /* 0x61756673 remote */\n      /* FIXME: change syntax or add an optional attribute like \"inotify:no\".\n         The above is labeled as \"remote\" so that tail always uses polling,\n         but this isn't really a remote file system type.  */\n      return \"aufs\";\n    case S_MAGIC_AUTOFS: /* 0x0187 local */\n      return \"autofs\";\n    case S_MAGIC_BALLOON_KVM: /* 0x13661366 local */\n      return \"balloon-kvm-fs\";\n    case S_MAGIC_BEFS: /* 0x42465331 local */\n      return \"befs\";\n    case S_MAGIC_BDEVFS: /* 0x62646576 local */\n      return \"bdevfs\";\n    case S_MAGIC_BFS: /* 0x1BADFACE local */\n      return \"bfs\";\n    case S_MAGIC_BINDERFS: /* 0x6C6F6F70 local */\n      return \"binderfs\";\n    case S_MAGIC_BPF_FS: /* 0xCAFE4A11 local */\n      return \"bpf_fs\";\n    case S_MAGIC_BINFMTFS: /* 0x42494E4D local */\n      return \"binfmt_misc\";\n    case S_MAGIC_BTRFS: /* 0x9123683E local */\n      return \"btrfs\";\n    case S_MAGIC_BTRFS_TEST: /* 0x73727279 local */\n      return \"btrfs_test\";\n    case S_MAGIC_CEPH: /* 0x00C36400 remote */\n      return \"ceph\";\n    case S_MAGIC_CGROUP: /* 0x0027E0EB local */\n      return \"cgroupfs\";\n    case S_MAGIC_CGROUP2: /* 0x63677270 local */\n      return \"cgroup2fs\";\n    case S_MAGIC_CIFS: /* 0xFF534D42 remote */\n      return \"cifs\";\n    case S_MAGIC_CODA: /* 0x73757245 remote */\n      return \"coda\";\n    case S_MAGIC_COH: /* 0x012FF7B7 local */\n      return \"coh\";\n    case S_MAGIC_CONFIGFS: /* 0x62656570 local */\n      return \"configfs\";\n    case S_MAGIC_CRAMFS: /* 0x28CD3D45 local */\n      return \"cramfs\";\n    case S_MAGIC_CRAMFS_WEND: /* 0x453DCD28 local */\n      return \"cramfs-wend\";\n    case S_MAGIC_DAXFS: /* 0x64646178 local */\n      return \"daxfs\";\n    case S_MAGIC_DEBUGFS: /* 0x64626720 local */\n      return \"debugfs\";\n    case S_MAGIC_DEVFS: /* 0x1373 local */\n      return \"devfs\";\n    case S_MAGIC_DEVMEM: /* 0x454D444D local */\n      return \"devmem\";\n    case S_MAGIC_DEVPTS: /* 0x1CD1 local */\n      return \"devpts\";\n    case S_MAGIC_DMA_BUF: /* 0x444D4142 local */\n      return \"dma-buf-fs\";\n    case S_MAGIC_ECRYPTFS: /* 0xF15F local */\n      return \"ecryptfs\";\n    case S_MAGIC_EFIVARFS: /* 0xDE5E81E4 local */\n      return \"efivarfs\";\n    case S_MAGIC_EFS: /* 0x00414A53 local */\n      return \"efs\";\n    case S_MAGIC_EROFS_V1: /* 0xE0F5E1E2 local */\n      return \"erofs\";\n    case S_MAGIC_EXFS: /* 0x45584653 local */\n      return \"exfs\";\n    case S_MAGIC_EXOFS: /* 0x5DF5 local */\n      return \"exofs\";\n    case S_MAGIC_EXT: /* 0x137D local */\n      return \"ext\";\n    case S_MAGIC_EXT2: /* 0xEF53 local */\n      return \"ext2/ext3\";\n    case S_MAGIC_EXT2_OLD: /* 0xEF51 local */\n      return \"ext2\";\n    case S_MAGIC_F2FS: /* 0xF2F52010 local */\n      return \"f2fs\";\n    case S_MAGIC_FAT: /* 0x4006 local */\n      return \"fat\";\n    case S_MAGIC_FHGFS: /* 0x19830326 remote */\n      return \"fhgfs\";\n    case S_MAGIC_FUSEBLK: /* 0x65735546 remote */\n      return \"fuseblk\";\n    case S_MAGIC_FUSECTL: /* 0x65735543 remote */\n      return \"fusectl\";\n    case S_MAGIC_FUTEXFS: /* 0x0BAD1DEA local */\n      return \"futexfs\";\n    case S_MAGIC_GFS: /* 0x01161970 remote */\n      return \"gfs/gfs2\";\n    case S_MAGIC_GPFS: /* 0x47504653 remote */\n      return \"gpfs\";\n    case S_MAGIC_HFS: /* 0x4244 local */\n      return \"hfs\";\n    case S_MAGIC_HFS_PLUS: /* 0x482B local */\n      return \"hfs+\";\n    case S_MAGIC_HFS_X: /* 0x4858 local */\n      return \"hfsx\";\n    case S_MAGIC_HOSTFS: /* 0x00C0FFEE local */\n      return \"hostfs\";\n    case S_MAGIC_HPFS: /* 0xF995E849 local */\n      return \"hpfs\";\n    case S_MAGIC_HUGETLBFS: /* 0x958458F6 local */\n      return \"hugetlbfs\";\n    case S_MAGIC_MTD_INODE_FS: /* 0x11307854 local */\n      return \"inodefs\";\n    case S_MAGIC_IBRIX: /* 0x013111A8 remote */\n      return \"ibrix\";\n    case S_MAGIC_INOTIFYFS: /* 0x2BAD1DEA local */\n      return \"inotifyfs\";\n    case S_MAGIC_ISOFS: /* 0x9660 local */\n      return \"isofs\";\n    case S_MAGIC_ISOFS_R_WIN: /* 0x4004 local */\n      return \"isofs\";\n    case S_MAGIC_ISOFS_WIN: /* 0x4000 local */\n      return \"isofs\";\n    case S_MAGIC_JFFS: /* 0x07C0 local */\n      return \"jffs\";\n    case S_MAGIC_JFFS2: /* 0x72B6 local */\n      return \"jffs2\";\n    case S_MAGIC_JFS: /* 0x3153464A local */\n      return \"jfs\";\n    case S_MAGIC_KAFS: /* 0x6B414653 remote */\n      return \"k-afs\";\n    case S_MAGIC_LOGFS: /* 0xC97E8168 local */\n      return \"logfs\";\n    case S_MAGIC_LUSTRE: /* 0x0BD00BD0 remote */\n      return \"lustre\";\n    case S_MAGIC_M1FS: /* 0x5346314D local */\n      return \"m1fs\";\n    case S_MAGIC_MINIX: /* 0x137F local */\n      return \"minix\";\n    case S_MAGIC_MINIX_30: /* 0x138F local */\n      return \"minix (30 char.)\";\n    case S_MAGIC_MINIX_V2: /* 0x2468 local */\n      return \"minix v2\";\n    case S_MAGIC_MINIX_V2_30: /* 0x2478 local */\n      return \"minix v2 (30 char.)\";\n    case S_MAGIC_MINIX_V3: /* 0x4D5A local */\n      return \"minix3\";\n    case S_MAGIC_MQUEUE: /* 0x19800202 local */\n      return \"mqueue\";\n    case S_MAGIC_MSDOS: /* 0x4D44 local */\n      return \"msdos\";\n    case S_MAGIC_NCP: /* 0x564C remote */\n      return \"novell\";\n    case S_MAGIC_NFS: /* 0x6969 remote */\n      return \"nfs\";\n    case S_MAGIC_NFSD: /* 0x6E667364 remote */\n      return \"nfsd\";\n    case S_MAGIC_NILFS: /* 0x3434 local */\n      return \"nilfs\";\n    case S_MAGIC_NSFS: /* 0x6E736673 local */\n      return \"nsfs\";\n    case S_MAGIC_NTFS: /* 0x5346544E local */\n      return \"ntfs\";\n    case S_MAGIC_OPENPROM: /* 0x9FA1 local */\n      return \"openprom\";\n    case S_MAGIC_OCFS2: /* 0x7461636F remote */\n      return \"ocfs2\";\n    case S_MAGIC_OVERLAYFS: /* 0x794C7630 remote */\n      /* This may overlay remote file systems.\n         Also there have been issues reported with inotify and overlayfs,\n         so mark as \"remote\" so that polling is used.  */\n      return \"overlayfs\";\n    case S_MAGIC_PANFS: /* 0xAAD7AAEA remote */\n      return \"panfs\";\n    case S_MAGIC_PIPEFS: /* 0x50495045 remote */\n      /* FIXME: change syntax or add an optional attribute like \"inotify:no\".\n         pipefs and prlfs are labeled as \"remote\" so that tail always polls,\n         but these aren't really remote file system types.  */\n      return \"pipefs\";\n    case S_MAGIC_PPC_CMM: /* 0xC7571590 local */\n      return \"ppc-cmm-fs\";\n    case S_MAGIC_PRL_FS: /* 0x7C7C6673 remote */\n      return \"prl_fs\";\n    case S_MAGIC_PROC: /* 0x9FA0 local */\n      return \"proc\";\n    case S_MAGIC_PSTOREFS: /* 0x6165676C local */\n      return \"pstorefs\";\n    case S_MAGIC_QNX4: /* 0x002F local */\n      return \"qnx4\";\n    case S_MAGIC_QNX6: /* 0x68191122 local */\n      return \"qnx6\";\n    case S_MAGIC_RAMFS: /* 0x858458F6 local */\n      return \"ramfs\";\n    case S_MAGIC_RDTGROUP: /* 0x07655821 local */\n      return \"rdt\";\n    case S_MAGIC_REISERFS: /* 0x52654973 local */\n      return \"reiserfs\";\n    case S_MAGIC_ROMFS: /* 0x7275 local */\n      return \"romfs\";\n    case S_MAGIC_RPC_PIPEFS: /* 0x67596969 local */\n      return \"rpc_pipefs\";\n    case S_MAGIC_SDCARDFS: /* 0x5DCA2DF5 local */\n      return \"sdcardfs\";\n    case S_MAGIC_SECURITYFS: /* 0x73636673 local */\n      return \"securityfs\";\n    case S_MAGIC_SELINUX: /* 0xF97CFF8C local */\n      return \"selinux\";\n    case S_MAGIC_SMACK: /* 0x43415D53 local */\n      return \"smackfs\";\n    case S_MAGIC_SMB: /* 0x517B remote */\n      return \"smb\";\n    case S_MAGIC_SMB2: /* 0xFE534D42 remote */\n      return \"smb2\";\n    case S_MAGIC_SNFS: /* 0xBEEFDEAD remote */\n      return \"snfs\";\n    case S_MAGIC_SOCKFS: /* 0x534F434B local */\n      return \"sockfs\";\n    case S_MAGIC_SQUASHFS: /* 0x73717368 local */\n      return \"squashfs\";\n    case S_MAGIC_SYSFS: /* 0x62656572 local */\n      return \"sysfs\";\n    case S_MAGIC_SYSV2: /* 0x012FF7B6 local */\n      return \"sysv2\";\n    case S_MAGIC_SYSV4: /* 0x012FF7B5 local */\n      return \"sysv4\";\n    case S_MAGIC_TMPFS: /* 0x01021994 local */\n      return \"tmpfs\";\n    case S_MAGIC_TRACEFS: /* 0x74726163 local */\n      return \"tracefs\";\n    case S_MAGIC_UBIFS: /* 0x24051905 local */\n      return \"ubifs\";\n    case S_MAGIC_UDF: /* 0x15013346 local */\n      return \"udf\";\n    case S_MAGIC_UFS: /* 0x00011954 local */\n      return \"ufs\";\n    case S_MAGIC_UFS_BYTESWAPPED: /* 0x54190100 local */\n      return \"ufs\";\n    case S_MAGIC_USBDEVFS: /* 0x9FA2 local */\n      return \"usbdevfs\";\n    case S_MAGIC_V9FS: /* 0x01021997 local */\n      return \"v9fs\";\n    case S_MAGIC_VBOXSF: /* 0x786F4256 remote */\n      return \"vboxsf\";\n    case S_MAGIC_VMHGFS: /* 0xBACBACBC remote */\n      return \"vmhgfs\";\n    case S_MAGIC_VXFS: /* 0xA501FCF5 remote */\n      /* Veritas File System can run in single instance or clustered mode,\n         so mark as remote to cater for the latter case.  */\n      return \"vxfs\";\n    case S_MAGIC_VZFS: /* 0x565A4653 local */\n      return \"vzfs\";\n    case S_MAGIC_WSLFS: /* 0x53464846 local */\n      return \"wslfs\";\n    case S_MAGIC_XENFS: /* 0xABBA1974 local */\n      return \"xenfs\";\n    case S_MAGIC_XENIX: /* 0x012FF7B4 local */\n      return \"xenix\";\n    case S_MAGIC_XFS: /* 0x58465342 local */\n      return \"xfs\";\n    case S_MAGIC_XIAFS: /* 0x012FD16D local */\n      return \"xia\";\n    case S_MAGIC_Z3FOLD: /* 0x0033 local */\n      return \"z3fold\";\n    case S_MAGIC_ZFS: /* 0x2FC12FC1 local */\n      return \"zfs\";\n    case S_MAGIC_ZONEFS: /* 0x5A4F4653 local */\n      return \"zonefs\";\n    case S_MAGIC_ZSMALLOC: /* 0x58295829 local */\n      return \"zsmallocfs\";\n\n\n# elif __GNU__\n    case FSTYPE_UFS:\n      return \"ufs\";\n    case FSTYPE_NFS:\n      return \"nfs\";\n    case FSTYPE_GFS:\n      return \"gfs\";\n    case FSTYPE_LFS:\n      return \"lfs\";\n    case FSTYPE_SYSV:\n      return \"sysv\";\n    case FSTYPE_FTP:\n      return \"ftp\";\n    case FSTYPE_TAR:\n      return \"tar\";\n    case FSTYPE_AR:\n      return \"ar\";\n    case FSTYPE_CPIO:\n      return \"cpio\";\n    case FSTYPE_MSLOSS:\n      return \"msloss\";\n    case FSTYPE_CPM:\n      return \"cpm\";\n    case FSTYPE_HFS:\n      return \"hfs\";\n    case FSTYPE_DTFS:\n      return \"dtfs\";\n    case FSTYPE_GRFS:\n      return \"grfs\";\n    case FSTYPE_TERM:\n      return \"term\";\n    case FSTYPE_DEV:\n      return \"dev\";\n    case FSTYPE_PROC:\n      return \"proc\";\n    case FSTYPE_IFSOCK:\n      return \"ifsock\";\n    case FSTYPE_AFS:\n      return \"afs\";\n    case FSTYPE_DFS:\n      return \"dfs\";\n    case FSTYPE_PROC9:\n      return \"proc9\";\n    case FSTYPE_SOCKET:\n      return \"socket\";\n    case FSTYPE_MISC:\n      return \"misc\";\n    case FSTYPE_EXT2FS:\n      return \"ext2/ext3\";\n    case FSTYPE_HTTP:\n      return \"http\";\n    case FSTYPE_MEMFS:\n      return \"memfs\";\n    case FSTYPE_ISO9660:\n      return \"iso9660\";\n# endif\n    default:\n      {\n        unsigned long int type = statfsbuf->f_type;\n        static char buf[sizeof \"UNKNOWN (0x%lx)\" - 3\n                        + (sizeof type * CHAR_BIT + 3) / 4];\n        sprintf (buf, \"UNKNOWN (0x%lx)\", type);\n        return buf;\n      }\n    }\n#endif\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Actually print the sequence of numbers in the specified range, with the\n   given or default stepping and format.  */\n", "func_signal": "static void\nprint_numbers (char const *fmt, struct layout layout,\n               long double first, long double step, long double last)", "code": "{\n  bool out_of_range = (step < 0 ? first < last : last < first);\n\n  if (! out_of_range)\n    {\n      long double x = first;\n      long double i;\n\n      for (i = 1; ; i++)\n        {\n          long double x0 = x;\n          if (printf (fmt, x) < 0)\n            io_error ();\n          if (out_of_range)\n            break;\n          x = first + i * step;\n          out_of_range = (step < 0 ? x < last : last < x);\n\n          if (out_of_range)\n            {\n              /* If the number just past LAST prints as a value equal\n                 to LAST, and prints differently from the previous\n                 number, then print the number.  This avoids problems\n                 with rounding.  For example, with the x86 it causes\n                 \"seq 0 0.000001 0.000003\" to print 0.000003 instead\n                 of stopping at 0.000002.  */\n\n              bool print_extra_number = false;\n              long double x_val;\n              char *x_str;\n              int x_strlen;\n              if (locale_ok)\n                setlocale (LC_NUMERIC, \"C\");\n              x_strlen = asprintf (&x_str, fmt, x);\n              if (locale_ok)\n                setlocale (LC_NUMERIC, \"\");\n              if (x_strlen < 0)\n                xalloc_die ();\n              x_str[x_strlen - layout.suffix_len] = '\\0';\n\n              if (xstrtold (x_str + layout.prefix_len, NULL, &x_val, cl_strtold)\n                  && x_val == last)\n                {\n                  char *x0_str = NULL;\n                  int x0_strlen = asprintf (&x0_str, fmt, x0);\n                  if (x0_strlen < 0)\n                    xalloc_die ();\n                  x0_str[x0_strlen - layout.suffix_len] = '\\0';\n                  print_extra_number = !STREQ (x0_str, x_str);\n                  free (x0_str);\n                }\n\n              free (x_str);\n              if (! print_extra_number)\n                break;\n            }\n\n          if (fputs (separator, stdout) == EOF)\n            io_error ();\n        }\n\n      if (fputs (terminator, stdout) == EOF)\n        io_error ();\n    }\n}", "path": "coreutils/src/seq.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* If FORMAT is a valid printf format for a double argument, return\n   its long double equivalent, allocated from dynamic storage, and\n   store into *LAYOUT a description of the output layout; otherwise,\n   report an error and exit.  */\n", "func_signal": "static char const *\nlong_double_format (char const *fmt, struct layout *layout)", "code": "{\n  size_t i;\n  size_t prefix_len = 0;\n  size_t suffix_len = 0;\n  size_t length_modifier_offset;\n  bool has_L;\n\n  for (i = 0; ! (fmt[i] == '%' && fmt[i + 1] != '%'); i += (fmt[i] == '%') + 1)\n    {\n      if (!fmt[i])\n        die (EXIT_FAILURE, 0,\n             _(\"format %s has no %% directive\"), quote (fmt));\n      prefix_len++;\n    }\n\n  i++;\n  i += strspn (fmt + i, \"-+#0 '\");\n  i += strspn (fmt + i, \"0123456789\");\n  if (fmt[i] == '.')\n    {\n      i++;\n      i += strspn (fmt + i, \"0123456789\");\n    }\n\n  length_modifier_offset = i;\n  has_L = (fmt[i] == 'L');\n  i += has_L;\n  if (fmt[i] == '\\0')\n    die (EXIT_FAILURE, 0, _(\"format %s ends in %%\"), quote (fmt));\n  if (! strchr (\"efgaEFGA\", fmt[i]))\n    die (EXIT_FAILURE, 0,\n         _(\"format %s has unknown %%%c directive\"), quote (fmt), fmt[i]);\n\n  for (i++; ; i += (fmt[i] == '%') + 1)\n    if (fmt[i] == '%' && fmt[i + 1] != '%')\n      die (EXIT_FAILURE, 0, _(\"format %s has too many %% directives\"),\n           quote (fmt));\n    else if (fmt[i])\n      suffix_len++;\n    else\n      {\n        size_t format_size = i + 1;\n        char *ldfmt = xmalloc (format_size + 1);\n        memcpy (ldfmt, fmt, length_modifier_offset);\n        ldfmt[length_modifier_offset] = 'L';\n        strcpy (ldfmt + length_modifier_offset + 1,\n                fmt + length_modifier_offset + has_L);\n        layout->prefix_len = prefix_len;\n        layout->suffix_len = suffix_len;\n        return ldfmt;\n      }\n}", "path": "coreutils/src/seq.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* This will help compatibility with coreutils */\n", "func_signal": "int blake2s_stream( FILE *stream, void *resstream, size_t outbytes )", "code": "{\n  int ret = -1;\n  size_t sum, n;\n  blake2s_state S[1];\n  static const size_t buffer_length = 32768;\n  uint8_t *buffer = ( uint8_t * )malloc( buffer_length );\n\n  if( !buffer ) return -1;\n\n  blake2s_init( S, outbytes );\n\n  while( 1 )\n  {\n    sum = 0;\n\n    while( 1 )\n    {\n      n = fread( buffer + sum, 1, buffer_length - sum, stream );\n      sum += n;\n\n      if( buffer_length == sum )\n        break;\n\n      if( 0 == n )\n      {\n        if( ferror( stream ) )\n          goto cleanup_buffer;\n\n        goto final_process;\n      }\n\n      if( feof( stream ) )\n        goto final_process;\n    }\n\n    blake2s_update( S, buffer, buffer_length );\n  }\n\nfinal_process:;\n\n  if( sum > 0 ) blake2s_update( S, buffer, sum );\n\n  blake2s_final( S, resstream, outbytes );\n  ret = 0;\ncleanup_buffer:\n  free( buffer );\n  return ret;\n}", "path": "coreutils/src/blake2/b2sum.c", "commit_date": "2019-05-15 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Stat the file system and print what we find.  */\n", "func_signal": "static bool ATTRIBUTE_WARN_UNUSED_RESULT\ndo_statfs (char const *filename, char const *format)", "code": "{\n  STRUCT_STATVFS statfsbuf;\n\n  if (STREQ (filename, \"-\"))\n    {\n      error (0, 0, _(\"using %s to denote standard input does not work\"\n                     \" in file system mode\"), quoteaf (filename));\n      return false;\n    }\n\n  if (STATFS (filename, &statfsbuf) != 0)\n    {\n      error (0, errno, _(\"cannot read file system information for %s\"),\n             quoteaf (filename));\n      return false;\n    }\n\n  bool fail = print_it (format, -1, filename, print_statfs, &statfsbuf);\n  return ! fail;\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Change tabs to spaces, writing to stdout.\n   Read each file in 'file_list', in order.  */\n", "func_signal": "static void\nexpand (void)", "code": "{\n  /* Input stream.  */\n  FILE *fp = next_file (NULL);\n\n  if (!fp)\n    return;\n\n  while (true)\n    {\n      /* Input character, or EOF.  */\n      int c;\n\n      /* If true, perform translations.  */\n      bool convert = true;\n\n\n      /* The following variables have valid values only when CONVERT\n         is true:  */\n\n      /* Column of next input character.  */\n      uintmax_t column = 0;\n\n      /* Index in TAB_LIST of next tab stop to examine.  */\n      size_t tab_index = 0;\n\n\n      /* Convert a line of text.  */\n\n      do\n        {\n          while ((c = getc (fp)) < 0 && (fp = next_file (fp)))\n            continue;\n\n          if (convert)\n            {\n              if (c == '\\t')\n                {\n                  /* Column the next input tab stop is on.  */\n                  uintmax_t next_tab_column;\n                  bool last_tab IF_LINT (=0);\n\n                  next_tab_column = get_next_tab_column (column, &tab_index,\n                                                         &last_tab);\n\n                  if (last_tab)\n                    next_tab_column = column + 1;\n\n                  if (next_tab_column < column)\n                    die (EXIT_FAILURE, 0, _(\"input line is too long\"));\n\n                  while (++column < next_tab_column)\n                    if (putchar (' ') < 0)\n                      die (EXIT_FAILURE, errno, _(\"write error\"));\n\n                  c = ' ';\n                }\n              else if (c == '\\b')\n                {\n                  /* Go back one column, and force recalculation of the\n                     next tab stop.  */\n                  column -= !!column;\n                  tab_index -= !!tab_index;\n                }\n              else\n                {\n                  column++;\n                  if (!column)\n                    die (EXIT_FAILURE, 0, _(\"input line is too long\"));\n                }\n\n              convert &= convert_entire_line || !! isblank (c);\n            }\n\n          if (c < 0)\n            return;\n\n          if (putchar (c) < 0)\n            die (EXIT_FAILURE, errno, _(\"write error\"));\n        }\n      while (c != '\\n');\n    }\n}", "path": "coreutils/src/expand.c", "commit_date": "2020-01-01 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* The NUL-terminated string S0 of length S_LEN represents a valid\n   non-negative decimal integer.  Adjust the string and length so\n   that the pair describe the next-larger value.  */\n", "func_signal": "static void\nincr (char **s0, size_t *s_len)", "code": "{\n  char *s = *s0;\n  char *endp = s + *s_len - 1;\n\n  do\n    {\n      if ((*endp)++ < '9')\n        return;\n      *endp-- = '0';\n    }\n  while (endp >= s);\n  *--(*s0) = '1';\n  ++*s_len;\n}", "path": "coreutils/src/seq.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* stat the file and print what we find */\n", "func_signal": "static bool ATTRIBUTE_WARN_UNUSED_RESULT\ndo_stat (char const *filename, char const *format,\n         char const *format2)", "code": "{\n  int fd = STREQ (filename, \"-\") ? 0 : -1;\n  struct stat statbuf;\n  struct print_args pa;\n  pa.st = &statbuf;\n  pa.btime = (struct timespec) {-1, -1};\n\n  if (0 <= fd)\n    {\n      if (fstat (fd, &statbuf) != 0)\n        {\n          error (0, errno, _(\"cannot stat standard input\"));\n          return false;\n        }\n    }\n  /* We can't use the shorter\n     (follow_links?stat:lstat) (filename, &statbug)\n     since stat might be a function-like macro.  */\n  else if ((follow_links\n            ? stat (filename, &statbuf)\n            : lstat (filename, &statbuf)) != 0)\n    {\n      error (0, errno, _(\"cannot stat %s\"), quoteaf (filename));\n      return false;\n    }\n\n  if (S_ISBLK (statbuf.st_mode) || S_ISCHR (statbuf.st_mode))\n    format = format2;\n\n  bool fail = print_it (format, fd, filename, print_stat, &pa);\n  return ! fail;\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Return true if S consists of at least one digit and no non-digits.  */\n", "func_signal": "static bool _GL_ATTRIBUTE_PURE\nall_digits_p (char const *s)", "code": "{\n  size_t n = strlen (s);\n  return ISDIGIT (s[0]) && n == strspn (s, \"0123456789\");\n}", "path": "coreutils/src/seq.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Compare A and B (each a NUL-terminated digit string), with lengths\n   given by A_LEN and B_LEN.  Return +1 if A < B, -1 if B < A, else 0.  */\n", "func_signal": "static int\ncmp (char const *a, size_t a_len, char const *b, size_t b_len)", "code": "{\n  if (a_len < b_len)\n    return -1;\n  if (b_len < a_len)\n    return 1;\n  return (memcmp (a, b, a_len));\n}", "path": "coreutils/src/seq.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Print mount point.  Return zero upon success, nonzero upon failure.  */\n", "func_signal": "static bool ATTRIBUTE_WARN_UNUSED_RESULT\nout_mount_point (char const *filename, char *pformat, size_t prefix_len,\n                 const struct stat *statp)", "code": "{\n\n  char const *np = \"?\", *bp = NULL;\n  char *mp = NULL;\n  bool fail = true;\n\n  /* Look for bind mounts first.  Note we output the immediate alias,\n     rather than further resolving to a base device mount point.  */\n  if (follow_links || !S_ISLNK (statp->st_mode))\n    {\n      char *resolved = canonicalize_file_name (filename);\n      if (!resolved)\n        {\n          error (0, errno, _(\"failed to canonicalize %s\"), quoteaf (filename));\n          goto print_mount_point;\n        }\n      bp = find_bind_mount (resolved);\n      free (resolved);\n      if (bp)\n        {\n          fail = false;\n          goto print_mount_point;\n        }\n    }\n\n  /* If there is no direct bind mount, then navigate\n     back up the tree looking for a device change.\n     Note we don't detect if any of the directory components\n     are bind mounted to the same device, but that's OK\n     since we've not directly queried them.  */\n  if ((mp = find_mount_point (filename, statp)))\n    {\n      /* This dir might be bind mounted to another device,\n         so we resolve the bound source in that case also.  */\n      bp = find_bind_mount (mp);\n      fail = false;\n    }\n\nprint_mount_point:\n\n  out_string (pformat, prefix_len, bp ? bp : mp ? mp : np);\n  free (mp);\n  return fail;\n}", "path": "coreutils/src/stat.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* Print a row of 'kill -t' output.  NUM_WIDTH is the maximum signal\n   number width, and SIGNUM is the signal number to print.  The\n   maximum name width is NAME_WIDTH, and SIGNAME is the name to print.  */\n", "func_signal": "static void\nprint_table_row (int num_width, int signum,\n                 int name_width, char const *signame)", "code": "{\n  char const *description = strsignal (signum);\n  printf (\"%*d %-*s %s\\n\", num_width, signum, name_width, signame,\n          description ? description : \"?\");\n}", "path": "coreutils/src/kill.c", "commit_date": "2020-01-01 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "/* We ignore any errors as these hints are only advisory.\n * There is the chance one can pass invalid ADVICE, which will\n * not be indicated, but given the simplicity of the interface\n * this is unlikely.  Also not returning errors allows the\n * unconditional passing of descriptors to non standard files,\n * which will just be ignored if unsupported.  */\n", "func_signal": "int\nmain (void)", "code": "{\n  /* Valid.  */\n  fadvise (stdin, FADVISE_SEQUENTIAL);\n  fdadvise (fileno (stdin), 0, 0, FADVISE_RANDOM);\n\n  /* Ignored.  */\n  fadvise (NULL, FADVISE_RANDOM);\n\n  /* Invalid.  */\n  fdadvise (42, 0, 0, FADVISE_RANDOM);\n  /* Unfortunately C enums are not types.\n     One could hack type safety by wrapping in a struct,\n     but it's probably not worth the complexity in this case.  */\n  fadvise (stdin, FADVISE_SEQUENTIAL + FADVISE_RANDOM);\n  fadvise (stdin, 4242);\n\n  return 0;\n}", "path": "coreutils/gl/tests/test-fadvise.c", "commit_date": "2020-01-01 00:00:00", "repo_name": "coreutils/coreutils", "stars": 3941, "license": "gpl-3.0", "language": "c", "size": 45392}
{"docstring": "//\n// Computes the hash by processing the input four-bits at a time. It is assumed\n// that the hash input is a whole number of bytes (no partial byte-processing\n// needs to be done at the end).\n//\n", "func_signal": "uint32_t\nQuicToeplitzHashCompute(\n    _In_ const QUIC_TOEPLITZ_HASH* Toeplitz,\n    _In_reads_(HashInputLength)\n        const uint8_t* HashInput,\n    _In_ uint32_t HashInputLength,\n    _In_ uint32_t HashInputOffset\n    )", "code": "{\n    //\n    // BaseOffset is the first lookup table to be accessed.\n    //\n    uint32_t BaseOffset = HashInputOffset * NIBBLES_PER_BYTE;\n    uint32_t Result = 0;\n\n    QUIC_DBG_ASSERT(\n        (BaseOffset + HashInputLength * NIBBLES_PER_BYTE) <= QUIC_TOEPLITZ_LOOKUP_TABLE_COUNT);\n\n    for (uint32_t i = 0; i < HashInputLength; i++) {\n        Result ^= Toeplitz->LookupTableArray[BaseOffset].Table[(HashInput[i] >> 4) & 0xf];\n        BaseOffset++;\n        Result ^= Toeplitz->LookupTableArray[BaseOffset].Table[HashInput[i] & 0xf];\n        BaseOffset++;\n    }\n\n    return Result;\n}", "path": "msquic/src/platform/toeplitz.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Removes a source connection ID from the lookup table. Requires the\n// Lookup->RwLock to be exlusively held.\n//\n", "func_signal": "_IRQL_requires_max_(DISPATCH_LEVEL)\nvoid\nQuicLookupRemoveLocalCidInt(\n    _In_ QUIC_LOOKUP* Lookup,\n    _In_ QUIC_CID_HASH_ENTRY* SourceCid\n    )", "code": "{\n    QUIC_DBG_ASSERT(SourceCid->CID.IsInLookupTable);\n    QUIC_DBG_ASSERT(Lookup->CidCount != 0);\n    Lookup->CidCount--;\n\n#if QUIC_DEBUG_HASHTABLE_LOOKUP\n    QuicTraceLogVerbose(\n        LookupCidRemoved,\n        \"[look][%p] Remove Conn=%p\",\n        Lookup,\n        SourceCid->Connection);\n#endif\n\n    if (Lookup->PartitionCount == 0) {\n        QUIC_DBG_ASSERT(Lookup->SINGLE.Connection == SourceCid->Connection);\n        if (Lookup->CidCount == 0) {\n            //\n            // This was the last CID reference, so we can clear the connection\n            // pointer.\n            //\n            Lookup->SINGLE.Connection = NULL;\n        }\n    } else {\n        QUIC_DBG_ASSERT(SourceCid->CID.Length >= MsQuicLib.CidServerIdLength + MSQUIC_CID_PID_LENGTH);\n\n        //\n        // Remove the source connection ID from the multi-hash table.\n        //\n        QUIC_STATIC_ASSERT(MSQUIC_CID_PID_LENGTH == 2, \"The code below assumes 2 bytes\");\n        uint16_t PartitionIndex;\n        QuicCopyMemory(&PartitionIndex, SourceCid->CID.Data + MsQuicLib.CidServerIdLength, 2);\n        PartitionIndex &= MsQuicLib.PartitionMask;\n        PartitionIndex %= Lookup->PartitionCount;\n        QUIC_PARTITIONED_HASHTABLE* Table = &Lookup->HASH.Tables[PartitionIndex];\n        QuicDispatchRwLockAcquireExclusive(&Table->RwLock);\n        QuicHashtableRemove(&Table->Table, &SourceCid->Entry, NULL);\n        QuicDispatchRwLockReleaseExclusive(&Table->RwLock);\n    }\n}", "path": "msquic/src/core/lookup.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Processes a received STOP_SENDING frame's payload.\n//\n", "func_signal": "_IRQL_requires_max_(PASSIVE_LEVEL)\nvoid\nQuicStreamProcessStopSendingFrame(\n    _In_ QUIC_STREAM* Stream,\n    _In_ QUIC_VAR_INT ErrorCode\n    )", "code": "{\n    if (!Stream->Flags.LocalCloseAcked && !Stream->Flags.LocalCloseReset) {\n        //\n        // The STOP_SENDING frame only triggers a state change if we aren't\n        // completely closed gracefully (i.e. our close has been acknowledged)\n        // or if we have already been reset (abortive closure).\n        //\n        QuicTraceLogStreamInfo(\n            LocalCloseStopSending,\n            Stream,\n            \"Closed locally (stop sending)\");\n        Stream->Flags.ReceivedStopSending = TRUE;\n\n        QUIC_STREAM_EVENT Event;\n        Event.Type = QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED;\n        Event.PEER_RECEIVE_ABORTED.ErrorCode = ErrorCode;\n        QuicTraceLogStreamVerbose(\n            IndicatePeerReceiveAborted,\n            Stream,\n            \"Indicating QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED (0x%llX)\",\n            ErrorCode);\n        (void)QuicStreamIndicateEvent(Stream, &Event);\n\n        //\n        // The peer has requested that we stop sending. Close abortively.\n        //\n        QuicStreamSendShutdown(\n            Stream, FALSE, FALSE, QUIC_ERROR_NO_ERROR);\n    }\n}", "path": "msquic/src/core/stream_recv.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Writes STREAM frames into a packet buffer. The ExplicitDataLength flag\n// indicates the caller wants the stream to include the data length field\n// in the stream header explicitly because it will try to add more frames\n// afterwards.\n//\n", "func_signal": "_IRQL_requires_max_(PASSIVE_LEVEL)\nvoid\nQuicStreamWriteStreamFrames(\n    _In_ QUIC_STREAM* Stream,\n    _In_ BOOLEAN ExplicitDataLength,\n    _Inout_ QUIC_SENT_PACKET_METADATA* PacketMetadata,\n    _Inout_ uint16_t* BufferLength,\n    _Out_writes_bytes_(*BufferLength) uint8_t* Buffer\n    )", "code": "{\n    QUIC_SEND* Send = &Stream->Connection->Send;\n    uint16_t BytesWritten = 0;\n\n    //\n    // FUTURE: implicit data length when possible.\n    //\n    ExplicitDataLength = TRUE;\n\n    //\n    // Write frames until we've filled the provided space.\n    //\n\n    while (BytesWritten < *BufferLength &&\n        PacketMetadata->FrameCount < QUIC_MAX_FRAMES_PER_PACKET) {\n\n        //\n        // Find the bounds of this frame. Left is the offset of the first byte\n        // in the frame, and Right is the offset of the first byte AFTER the\n        // frame.\n        //\n        uint64_t Left;\n        uint64_t Right;\n\n        BOOLEAN Recovery;\n        if (RECOV_WINDOW_OPEN(Stream)) {\n            Left = Stream->RecoveryNextOffset;\n            Recovery = TRUE;\n        } else {\n            Left = Stream->NextSendOffset;\n            Recovery = FALSE;\n        }\n        Right = Left + *BufferLength - BytesWritten;\n\n        if (Recovery &&\n            Right > Stream->RecoveryEndOffset &&\n            Stream->RecoveryEndOffset != Stream->NextSendOffset) {\n            Right = Stream->RecoveryEndOffset;\n        }\n\n        //\n        // Find the first SACK after the selected offset.\n        //\n        QUIC_SUBRANGE* Sack;\n        if (Left == Stream->MaxSentLength) {\n            //\n            // Transmitting new bytes; no such SACK can exist.\n            //\n            Sack = NULL;\n        } else {\n            uint32_t i = 0;\n            while ((Sack = QuicRangeGetSafe(&Stream->SparseAckRanges, i++)) != NULL &&\n                Sack->Low < Left) {\n                QUIC_DBG_ASSERT(Sack->Low + Sack->Count <= Left);\n            }\n        }\n\n        if (Sack != NULL) {\n            if (Right > Sack->Low) {\n                Right = Sack->Low;\n            }\n        } else {\n            if (Right > Stream->QueuedSendOffset) {\n                Right = Stream->QueuedSendOffset;\n            }\n        }\n\n        //\n        // Stream flow control\n        //\n        if (Right > Stream->MaxAllowedSendOffset) {\n            Right = Stream->MaxAllowedSendOffset;\n        }\n\n        //\n        // Connection flow control\n        //\n        const uint64_t MaxConnFlowControlOffset =\n             Stream->MaxSentLength + (Send->PeerMaxData - Send->OrderedStreamBytesSent);\n        if (Right > MaxConnFlowControlOffset) {\n            Right = MaxConnFlowControlOffset;\n        }\n\n        //\n        // It's OK for Right and Left to be equal because there are cases where\n        // stream frames will be written with no payload (initial or FIN).\n        //\n        QUIC_DBG_ASSERT(Right >= Left);\n\n        uint16_t FrameBytes = *BufferLength - BytesWritten;\n        uint16_t FramePayloadBytes = (uint16_t)(Right - Left);\n\n        QuicStreamWriteOneFrame(\n            Stream,\n            ExplicitDataLength,\n            Left,\n            &FramePayloadBytes,\n            &FrameBytes,\n            Buffer + BytesWritten,\n            PacketMetadata);\n\n        BOOLEAN ExitLoop = FALSE;\n\n        //\n        // When FramePayloadBytes is returned as zero, an empty stream frame may\n        // still have been written (i.e. FramePayloadBytes might be 0 but\n        // FrameBytes is not).\n        //\n        BytesWritten += FrameBytes;\n        if (FramePayloadBytes == 0) {\n            ExitLoop = TRUE;\n        }\n\n        //\n        // Recalculate Right since FramePayloadBytes may have been reduced.\n        //\n        Right = Left + FramePayloadBytes;\n\n        QUIC_DBG_ASSERT(Right <= Stream->QueuedSendOffset);\n        if (Right == Stream->QueuedSendOffset) {\n            QuicStreamAddOutFlowBlockedReason(Stream, QUIC_FLOW_BLOCKED_APP);\n            ExitLoop = TRUE;\n        }\n\n        QUIC_DBG_ASSERT(Right <= Stream->MaxAllowedSendOffset);\n        if (Right == Stream->MaxAllowedSendOffset) {\n            if (QuicStreamAddOutFlowBlockedReason(\n                    Stream, QUIC_FLOW_BLOCKED_STREAM_FLOW_CONTROL)) {\n                QuicSendSetStreamSendFlag(\n                    &Stream->Connection->Send,\n                    Stream, QUIC_STREAM_SEND_FLAG_DATA_BLOCKED);\n            }\n            ExitLoop = TRUE;\n        }\n\n        QUIC_DBG_ASSERT(Right <= MaxConnFlowControlOffset);\n        if (Right == MaxConnFlowControlOffset) {\n            if (QuicConnAddOutFlowBlockedReason(\n                    Stream->Connection, QUIC_FLOW_BLOCKED_CONN_FLOW_CONTROL)) {\n                QuicSendSetSendFlag(\n                    &Stream->Connection->Send,\n                    QUIC_CONN_SEND_FLAG_DATA_BLOCKED);\n            }\n            ExitLoop = TRUE;\n        }\n\n        //\n        // Move the \"next\" offset (RecoveryNextOffset if we are sending recovery\n        // bytes or NextSendOffset otherwise) forward by the number of bytes\n        // we've written. If we wrote up to the edge of a SACK, skip past the\n        // SACK.\n        //\n\n        if (Recovery) {\n            QUIC_DBG_ASSERT(Stream->RecoveryNextOffset <= Right);\n            Stream->RecoveryNextOffset = Right;\n            if (Sack && Stream->RecoveryNextOffset == Sack->Low) {\n                Stream->RecoveryNextOffset += Sack->Count;\n            }\n        }\n\n        if (Stream->NextSendOffset < Right) {\n            Stream->NextSendOffset = Right;\n            if (Sack && Stream->NextSendOffset == Sack->Low) {\n                Stream->NextSendOffset += Sack->Count;\n            }\n        }\n\n        if (Stream->MaxSentLength < Right) {\n            Send->OrderedStreamBytesSent += Right - Stream->MaxSentLength;\n            QUIC_DBG_ASSERT(Send->OrderedStreamBytesSent <= Send->PeerMaxData);\n            Stream->MaxSentLength = Right;\n        }\n\n        QuicStreamValidateRecoveryState(Stream);\n\n        if (ExitLoop) {\n            break;\n        }\n    }\n\n    QuicStreamSendDumpState(Stream);\n\n    *BufferLength = BytesWritten;\n}", "path": "msquic/src/core/stream_send.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Initializes the state required for a Toeplitz hash computation. We\n// maintain per-nibble lookup tables, and we initialize them here.\n//\n", "func_signal": "void\nQuicToeplitzHashInitialize(\n    _Inout_ QUIC_TOEPLITZ_HASH* Toeplitz\n    )", "code": "{\n    //\n    // Our table based strategy works as follows. For each nibble of the\n    // hash input, there is a table of 16 32-bit values. This table can\n    // directly be looked up to find out what value needs to be XORed\n    // into the result based on the value of the nibble. Therefore, a\n    // 4 byte hash input will have 8 nibbles, and each of the nibbles\n    // has a separate lookup table. This lookup table is looked up\n    // based on the nibble value, the contents are XORed into the result\n    // and we then move to the next nibble of the input, and the next\n    // table.\n    //\n\n    //\n    // Initialize the Toeplitz->LookupTables.\n    //\n    for (uint32_t i = 0; i < QUIC_TOEPLITZ_LOOKUP_TABLE_COUNT; i++) {\n        //\n        // First construct the 32-bit word that is obtained after\n        // shifting the key left by i*4 bits. That goes into Word1\n        //\n        uint32_t StartByteOfKey = i / NIBBLES_PER_BYTE;\n\n        uint32_t Word1 = ((uint32_t)Toeplitz->HashKey[StartByteOfKey] << 24) +\n                         ((uint32_t)Toeplitz->HashKey[StartByteOfKey + 1] << 16) +\n                         ((uint32_t)Toeplitz->HashKey[StartByteOfKey + 2] << 8) +\n                          (uint32_t)Toeplitz->HashKey[StartByteOfKey + 3];\n\n        //\n        // However, we'll need the byte that succeeds Word1, because as we\n        // shift Word1 left, we need to bring in bits from the successor byte.\n        // The successor byte goes in Word2.\n        //\n        uint32_t Word2 = Toeplitz->HashKey[StartByteOfKey + 4];\n\n        uint32_t BaseShift = (i % NIBBLES_PER_BYTE) * BITS_PER_NIBBLE;\n\n        //\n        // Signature1 represents the value that needs to be XORed into\n        // the result if the LSB of the nibble is 1. Similarly, for\n        // the other Signature values.\n        //\n        uint32_t Signature1 = (Word1 << BaseShift) | (Word2 >> (8 * sizeof(uint8_t) - BaseShift));\n        BaseShift ++;\n        uint32_t Signature2 = (Word1 << BaseShift) | (Word2 >> (8 * sizeof(uint8_t) - BaseShift));\n        BaseShift ++;\n        uint32_t Signature3 = (Word1 << BaseShift) | (Word2 >> (8 * sizeof(uint8_t) - BaseShift));\n        BaseShift ++;\n        uint32_t Signature4 = (Word1 << BaseShift) | (Word2 >> (8 * sizeof(uint8_t) - BaseShift));\n\n        for (uint32_t j = 0; j < QUIC_TOEPLITZ_LOOKUP_TABLE_SIZE; j++) {\n\n            Toeplitz->LookupTableArray[i].Table[j] = 0;\n            if (j & 0x1) {\n                Toeplitz->LookupTableArray[i].Table[j] ^= Signature4;\n            }\n\n            if (j & 0x2) {\n                Toeplitz->LookupTableArray[i].Table[j] ^= Signature3;\n            }\n\n            if (j & 0x4) {\n                Toeplitz->LookupTableArray[i].Table[j] ^= Signature2;\n            }\n\n            if (j & 0x8) {\n                Toeplitz->LookupTableArray[i].Table[j] ^= Signature1;\n            }\n        }\n    }\n}", "path": "msquic/src/platform/toeplitz.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Rebalances the lookup tables to make sure they are optimal for the current\n// configuration of connections and listeners. Requires the RwLock to be held\n// exclusively.\n//\n", "func_signal": "_IRQL_requires_max_(DISPATCH_LEVEL)\nBOOLEAN\nQuicLookupRebalance(\n    _In_ QUIC_LOOKUP* Lookup,\n    _In_opt_ QUIC_CONNECTION* Connection\n    )", "code": "{\n    //\n    // Calculate the updated partition count.\n    //\n\n    uint16_t PartitionCount;\n    if (Lookup->MaximizePartitioning) {\n        PartitionCount = MsQuicLib.PartitionCount;\n\n    } else if (Lookup->PartitionCount > 0 ||\n               (Lookup->PartitionCount == 0 &&\n                Lookup->SINGLE.Connection != NULL &&\n                Lookup->SINGLE.Connection != Connection)) {\n        PartitionCount = 1;\n\n    } else {\n        PartitionCount = 0;\n    }\n\n    //\n    // Rebalance the binding if the partition count increased.\n    //\n\n    if (PartitionCount > Lookup->PartitionCount) {\n\n        uint16_t PreviousPartitionCount = Lookup->PartitionCount;\n        void* PreviousLookup = Lookup->LookupTable;\n        Lookup->LookupTable = NULL;\n\n        QUIC_DBG_ASSERT(PartitionCount != 0);\n\n        if (!QuicLookupCreateHashTable(Lookup, PartitionCount)) {\n            Lookup->LookupTable = PreviousLookup;\n            return FALSE;\n        }\n\n        //\n        // Move the CIDs to the new table.\n        //\n\n        if (PreviousPartitionCount == 0) {\n\n            //\n            // Only a single connection before. Enumerate all CIDs on the\n            // connection and reinsert them into the new table(s).\n            //\n\n            if (PreviousLookup != NULL) {\n                QUIC_SINGLE_LIST_ENTRY* Entry =\n                    ((QUIC_CONNECTION*)PreviousLookup)->SourceCids.Next;\n\n                while (Entry != NULL) {\n                    QUIC_CID_HASH_ENTRY *CID =\n                        QUIC_CONTAINING_RECORD(\n                            Entry,\n                            QUIC_CID_HASH_ENTRY,\n                            Link);\n                    (void)QuicLookupInsertLocalCid(\n                        Lookup,\n                        QuicHashSimple(CID->CID.Length, CID->CID.Data),\n                        CID,\n                        FALSE);\n                    Entry = Entry->Next;\n                }\n            }\n\n        } else {\n\n            //\n            // Changes the number of partitioned tables. Remove all the CIDs\n            // from the old tables and insert them into the new tables.\n            //\n\n            QUIC_PARTITIONED_HASHTABLE* PreviousTable = PreviousLookup;\n            for (uint16_t i = 0; i < PreviousPartitionCount; i++) {\n                QUIC_HASHTABLE_ENUMERATOR Enumerator;\n#pragma warning(push)\n#pragma warning(disable:6001)\n                QuicHashtableEnumerateBegin(&PreviousTable[i].Table, &Enumerator);\n#pragma warning(pop)\n                while (TRUE) {\n                    QUIC_HASHTABLE_ENTRY* Entry =\n                        QuicHashtableEnumerateNext(&PreviousTable[i].Table, &Enumerator);\n                    if (Entry == NULL) {\n                        QuicHashtableEnumerateEnd(&PreviousTable[i].Table, &Enumerator);\n                        break;\n                    }\n                    QuicHashtableRemove(&PreviousTable[i].Table, Entry, NULL);\n\n                    QUIC_CID_HASH_ENTRY *CID =\n                        QUIC_CONTAINING_RECORD(\n                            Entry,\n                            QUIC_CID_HASH_ENTRY,\n                            Entry);\n                    (void)QuicLookupInsertLocalCid(\n                        Lookup,\n                        QuicHashSimple(CID->CID.Length, CID->CID.Data),\n                        CID,\n                        FALSE);\n                }\n#pragma warning(push)\n#pragma warning(disable:6001)\n                QuicHashtableUninitialize(&PreviousTable[i].Table);\n#pragma warning(pop)\n            }\n            QUIC_FREE(PreviousTable, QUIC_POOL_LOOKUP_HASHTABLE);\n        }\n    }\n\n    return TRUE;\n}", "path": "msquic/src/core/lookup.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Socket context interface. It abstracts a (generally per-processor) UDP socket\n// and the corresponding logic/functionality like send and receive processing.\n//\n", "func_signal": "QUIC_STATUS\nQuicSocketContextInitialize(\n    _Inout_ QUIC_SOCKET_CONTEXT* SocketContext,\n    _In_ QUIC_DATAPATH_PROC_CONTEXT* ProcContext,\n    _In_ const QUIC_ADDR* LocalAddress,\n    _In_ const QUIC_ADDR* RemoteAddress\n    )", "code": "{\n    QUIC_STATUS Status = QUIC_STATUS_SUCCESS;\n    int Result = 0;\n    int Option = 0;\n    QUIC_ADDR MappedAddress = {0};\n    socklen_t AssignedLocalAddressLength = 0;\n\n    QUIC_DATAPATH_BINDING* Binding = SocketContext->Binding;\n\n    for (uint32_t i = 0; i < ARRAYSIZE(SocketContext->EventContexts); ++i) {\n        SocketContext->EventContexts[i] = i;\n    }\n\n    SocketContext->CleanupFd = eventfd(0, EFD_CLOEXEC);\n    if (SocketContext->CleanupFd == INVALID_SOCKET_FD) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"eventfd failed\");\n        goto Exit;\n    }\n\n    struct epoll_event EvtFdEpEvt = {\n        .events = EPOLLIN,\n        .data = {\n            .ptr = &SocketContext->EventContexts[QUIC_SOCK_EVENT_CLEANUP]\n        }\n    };\n\n    if (epoll_ctl(\n            ProcContext->EpollFd,\n            EPOLL_CTL_ADD,\n            SocketContext->CleanupFd,\n            &EvtFdEpEvt) != 0) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"epoll_ctl(EPOLL_CTL_ADD) failed\");\n        goto Exit;\n    }\n\n    //\n    // Create datagram socket.\n    //\n    SocketContext->SocketFd =\n        socket(\n            AF_INET6,\n            SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, // TODO check if SOCK_CLOEXEC is required?\n            IPPROTO_UDP);\n    if (SocketContext->SocketFd == INVALID_SOCKET_FD) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"socket failed\");\n        goto Exit;\n    }\n\n    //\n    // Set dual (IPv4 & IPv6) socket mode.\n    //\n    Option = FALSE;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            IPPROTO_IPV6,\n            IPV6_V6ONLY,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(IPV6_V6ONLY) failed\");\n        goto Exit;\n    }\n\n    //\n    // Set DON'T FRAG socket option.\n    //\n\n    //\n    // Windows: setsockopt IPPROTO_IP IP_DONTFRAGMENT TRUE.\n    // Linux: IP_DONTFRAGMENT option is not available. IPV6_MTU_DISCOVER is the\n    // apparent alternative.\n    // TODO: Verify this.\n    //\n    Option = IP_PMTUDISC_DO;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            IPPROTO_IP,\n            IP_MTU_DISCOVER,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(IP_MTU_DISCOVER) failed\");\n        goto Exit;\n    }\n\n    Option = TRUE;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            IPPROTO_IPV6,\n            IPV6_DONTFRAG,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(IPV6_DONTFRAG) failed\");\n        goto Exit;\n    }\n\n    //\n    // Set socket option to receive ancillary data about the incoming packets.\n    //\n\n    //\n    // Windows: setsockopt IPPROTO_IPV6 IPV6_PKTINFO TRUE.\n    // Android: Returns EINVAL. IPV6_PKTINFO option is not present in documentation.\n    // IPV6_RECVPKTINFO seems like is the alternative.\n    // TODO: Check if this works as expected?\n    //\n    Option = TRUE;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            IPPROTO_IPV6,\n            IPV6_RECVPKTINFO,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(IPV6_RECVPKTINFO) failed\");\n        goto Exit;\n    }\n\n    Option = TRUE;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            IPPROTO_IP,\n            IP_PKTINFO,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(IP_PKTINFO) failed\");\n        goto Exit;\n    }\n\n    //\n    // Set socket option to receive TOS (= DSCP + ECN) information from the\n    // incoming packet.\n    //\n    Option = TRUE;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            IPPROTO_IPV6,\n            IPV6_RECVTCLASS,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(IPV6_RECVTCLASS) failed\");\n        goto Exit;\n    }\n\n    Option = TRUE;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            IPPROTO_IP,\n            IP_RECVTOS,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(IP_RECVTOS) failed\");\n        goto Exit;\n    }\n\n    //\n    // The socket is shared by multiple QUIC endpoints, so increase the receive\n    // buffer size.\n    //\n    Option = INT32_MAX;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            SOL_SOCKET,\n            SO_RCVBUF,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(SO_RCVBUF) failed\");\n        goto Exit;\n    }\n\n    //\n    // The port is shared across processors.\n    //\n    Option = TRUE;\n    Result =\n        setsockopt(\n            SocketContext->SocketFd,\n            SOL_SOCKET,\n            SO_REUSEADDR,\n            (const void*)&Option,\n            sizeof(Option));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"setsockopt(SO_REUSEADDR) failed\");\n        goto Exit;\n    }\n\n    QuicCopyMemory(&MappedAddress, &Binding->LocalAddress, sizeof(MappedAddress));\n    if (MappedAddress.Ipv6.sin6_family == QUIC_ADDRESS_FAMILY_INET6) {\n        MappedAddress.Ipv6.sin6_family = AF_INET6;\n    }\n\n    Result =\n        bind(\n            SocketContext->SocketFd,\n            &MappedAddress.Ip,\n            sizeof(MappedAddress));\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"bind failed\");\n        goto Exit;\n    }\n\n    if (RemoteAddress != NULL) {\n        QuicZeroMemory(&MappedAddress, sizeof(MappedAddress));\n        QuicConvertToMappedV6(RemoteAddress, &MappedAddress);\n\n        if (MappedAddress.Ipv6.sin6_family == QUIC_ADDRESS_FAMILY_INET6) {\n            MappedAddress.Ipv6.sin6_family = AF_INET6;\n        }\n\n        Result =\n            connect(\n                SocketContext->SocketFd,\n                &MappedAddress.Ip,\n                sizeof(MappedAddress));\n\n        if (Result == SOCKET_ERROR) {\n            Status = errno;\n            QuicTraceEvent(\n                DatapathErrorStatus,\n                \"[ udp][%p] ERROR, %u, %s.\",\n                Binding,\n                Status,\n                \"connect failed\");\n            goto Exit;\n        }\n    }\n\n\n    //\n    // If no specific local port was indicated, then the stack just\n    // assigned this socket a port. We need to query it and use it for\n    // all the other sockets we are going to create.\n    //\n    AssignedLocalAddressLength = sizeof(Binding->LocalAddress);\n    Result =\n        getsockname(\n            SocketContext->SocketFd,\n            (struct sockaddr *)&Binding->LocalAddress,\n            &AssignedLocalAddressLength);\n    if (Result == SOCKET_ERROR) {\n        Status = errno;\n        QuicTraceEvent(\n            DatapathErrorStatus,\n            \"[ udp][%p] ERROR, %u, %s.\",\n            Binding,\n            Status,\n            \"getsockname failed\");\n        goto Exit;\n    }\n\n    if (LocalAddress && LocalAddress->Ipv4.sin_port != 0) {\n        QUIC_DBG_ASSERT(LocalAddress->Ipv4.sin_port == Binding->LocalAddress.Ipv4.sin_port);\n    }\n\n    if (Binding->LocalAddress.Ipv6.sin6_family == AF_INET6) {\n        Binding->LocalAddress.Ipv6.sin6_family = QUIC_ADDRESS_FAMILY_INET6;\n    }\n\nExit:\n\n    if (QUIC_FAILED(Status)) {\n        close(SocketContext->SocketFd);\n        SocketContext->SocketFd = INVALID_SOCKET_FD;\n    }\n\n    return Status;\n}", "path": "msquic/src/platform/datapath_linux.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Inserts a source connection ID into the lookup table. Requires the\n// Lookup->RwLock to be exlusively held.\n//\n", "func_signal": "_IRQL_requires_max_(DISPATCH_LEVEL)\nBOOLEAN\nQuicLookupInsertLocalCid(\n    _In_ QUIC_LOOKUP* Lookup,\n    _In_ uint32_t Hash,\n    _In_ QUIC_CID_HASH_ENTRY* SourceCid,\n    _In_ BOOLEAN UpdateRefCount\n    )", "code": "{\n    if (!QuicLookupRebalance(Lookup, SourceCid->Connection)) {\n        return FALSE;\n    }\n\n    if (Lookup->PartitionCount == 0) {\n        //\n        // Make sure the connection pointer is set.\n        //\n        if (Lookup->SINGLE.Connection == NULL) {\n            Lookup->SINGLE.Connection = SourceCid->Connection;\n        }\n\n    } else {\n        QUIC_DBG_ASSERT(SourceCid->CID.Length >= MsQuicLib.CidServerIdLength + MSQUIC_CID_PID_LENGTH);\n\n        //\n        // Insert the source connection ID into the hash table.\n        //\n        QUIC_STATIC_ASSERT(MSQUIC_CID_PID_LENGTH == 2, \"The code below assumes 2 bytes\");\n        uint16_t PartitionIndex;\n        QuicCopyMemory(&PartitionIndex, SourceCid->CID.Data + MsQuicLib.CidServerIdLength, 2);\n        PartitionIndex &= MsQuicLib.PartitionMask;\n        PartitionIndex %= Lookup->PartitionCount;\n        QUIC_PARTITIONED_HASHTABLE* Table = &Lookup->HASH.Tables[PartitionIndex];\n\n        QuicDispatchRwLockAcquireExclusive(&Table->RwLock);\n        QuicHashtableInsert(\n            &Table->Table,\n            &SourceCid->Entry,\n            Hash,\n            NULL);\n        QuicDispatchRwLockReleaseExclusive(&Table->RwLock);\n    }\n\n    if (UpdateRefCount) {\n        Lookup->CidCount++;\n        QuicConnAddRef(SourceCid->Connection, QUIC_CONN_REF_LOOKUP_TABLE);\n    }\n\n#if QUIC_DEBUG_HASHTABLE_LOOKUP\n    QuicTraceLogVerbose(\n        LookupCidInsert,\n        \"[look][%p] Insert Conn=%p Hash=%u\",\n        Lookup,\n        Connection,\n        Hash);\n#endif\n\n    SourceCid->CID.IsInLookupTable = TRUE;\n\n    return TRUE;\n}", "path": "msquic/src/core/lookup.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Uses the hash and destination connection ID to look up the connection in the\n// hash table. Returns the pointer to the connection if found; NULL otherwise.\n//\n", "func_signal": "_IRQL_requires_max_(DISPATCH_LEVEL)\nQUIC_CONNECTION*\nQuicHashLookupConnection(\n    _In_ QUIC_HASHTABLE* Table,\n    _In_reads_(Length)\n        const uint8_t* const DestCid,\n    _In_ uint8_t Length,\n    _In_ uint32_t Hash\n    )", "code": "{\n    QUIC_HASHTABLE_LOOKUP_CONTEXT Context;\n    QUIC_HASHTABLE_ENTRY* TableEntry =\n        QuicHashtableLookup(Table, Hash, &Context);\n\n    while (TableEntry != NULL) {\n        QUIC_CID_HASH_ENTRY* CIDEntry =\n            QUIC_CONTAINING_RECORD(TableEntry, QUIC_CID_HASH_ENTRY, Entry);\n\n        if (CIDEntry->CID.Length == Length &&\n            memcmp(DestCid, CIDEntry->CID.Data, Length) == 0) {\n            return CIDEntry->Connection;\n        }\n\n        TableEntry = QuicHashtableLookupNext(Table, &Context);\n    }\n\n    return NULL;\n}", "path": "msquic/src/core/lookup.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Returns TRUE if the stream has any data queued to be sent.\n//\n", "func_signal": "BOOLEAN\nQuicStreamHasPendingStreamData(\n    _In_ const QUIC_STREAM* Stream\n    )", "code": "{\n    return\n        RECOV_WINDOW_OPEN(Stream) ||\n        (Stream->NextSendOffset < Stream->QueuedSendOffset);\n}", "path": "msquic/src/core/stream_send.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Returns TRUE if the stream can send a STREAM frame immediately. This\n// function does not include any congestion control state checks.\n//\n", "func_signal": "BOOLEAN\nQuicStreamSendCanWriteDataFrames(\n    _In_ const QUIC_STREAM* Stream\n    )", "code": "{\n    QUIC_DBG_ASSERT(QuicStreamAllowedByPeer(Stream));\n    QUIC_DBG_ASSERT(HasStreamDataFrames(Stream->SendFlags));\n\n    if (Stream->SendFlags & QUIC_STREAM_SEND_FLAG_OPEN) {\n        //\n        // Flow control doesn't block opening a new stream.\n        //\n        return TRUE;\n    }\n\n    if (RECOV_WINDOW_OPEN(Stream)) {\n        //\n        // We have some bytes to recover. Since these bytes are being\n        // retransmitted, we can ignore flow control.\n        //\n        return TRUE;\n    }\n\n    if (Stream->NextSendOffset == Stream->QueuedSendOffset) {\n        //\n        // No unsent data. Can send only if a FIN is needed.\n        //\n        return !!(Stream->SendFlags & QUIC_STREAM_SEND_FLAG_FIN);\n    }\n\n    //\n    // Some unsent data. Can send only if flow control will allow.\n    //\n    QUIC_SEND* Send = &Stream->Connection->Send;\n    return\n        Stream->NextSendOffset < Stream->MaxAllowedSendOffset &&\n        Send->OrderedStreamBytesSent < Send->PeerMaxData;\n}", "path": "msquic/src/core/stream_send.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Returns TRUE if the Stream has any data that is allowed to be sent in 0-RTT\n// still in the queue.\n//\n", "func_signal": "BOOLEAN\nQuicStreamHasPending0RttData(\n    _In_ const QUIC_STREAM* Stream\n    )", "code": "{\n    return\n        Stream->Queued0Rtt > Stream->NextSendOffset ||\n        (Stream->NextSendOffset == Stream->QueuedSendOffset &&\n         (Stream->SendFlags & QUIC_STREAM_SEND_FLAG_FIN));\n}", "path": "msquic/src/core/stream_send.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Compares the input destination connection ID to all the source connection\n// IDs registered with the connection. Returns TRUE if it finds a match,\n// otherwise FALSE.\n//\n", "func_signal": "_IRQL_requires_max_(DISPATCH_LEVEL)\nBOOLEAN\nQuicCidMatchConnection(\n    _In_ const QUIC_CONNECTION* const Connection,\n    _In_reads_(Length)\n        const uint8_t* const DestCid,\n    _In_ uint8_t Length\n    )", "code": "{\n    for (QUIC_SINGLE_LIST_ENTRY* Link = Connection->SourceCids.Next;\n        Link != NULL;\n        Link = Link->Next) {\n\n        const QUIC_CID_HASH_ENTRY* const Entry =\n            QUIC_CONTAINING_RECORD(Link, const QUIC_CID_HASH_ENTRY, Link);\n\n        if (Length == Entry->CID.Length &&\n            (Length == 0 || memcmp(DestCid, Entry->CID.Data, Length) == 0)) {\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}", "path": "msquic/src/core/lookup.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Returns TRUE if the peer has indicated the stream ID is allowed to be used\n// yet.\n//\n", "func_signal": "BOOLEAN\nQuicStreamAllowedByPeer(\n    _In_ const QUIC_STREAM* Stream\n    )", "code": "{\n    uint64_t StreamType = Stream->ID & STREAM_ID_MASK;\n    uint64_t StreamCount = (Stream->ID >> 2) + 1;\n    const QUIC_STREAM_TYPE_INFO* Info =\n        &Stream->Connection->Streams.Types[StreamType];\n    return Info->MaxTotalStreamCount >= StreamCount;\n}", "path": "msquic/src/core/stream_send.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Generally, every time bytes are delivered to the application we update our max\n// data (stream and connection) values and queue an update to be sent to the\n// peer. It is done every time, because nearly always an ACK frame is also\n// ready to be sent out, so we might as well take advantage of that packet to\n// send this data as well. If we don't have an ACK ready to be sent out\n// immediately then we only update the values if we have reached the drain\n// limit.\n//\n", "func_signal": "_IRQL_requires_max_(PASSIVE_LEVEL)\nvoid\nQuicStreamOnBytesDelivered(\n    _In_ QUIC_STREAM* Stream,\n    _In_ uint64_t BytesDelivered\n    )", "code": "{\n    const uint64_t RecvBufferDrainThreshold =\n        Stream->RecvBuffer.VirtualBufferLength / QUIC_RECV_BUFFER_DRAIN_RATIO;\n\n    Stream->RecvWindowBytesDelivered += BytesDelivered;\n    Stream->Connection->Send.MaxData += BytesDelivered;\n\n    if (Stream->RecvWindowBytesDelivered >= RecvBufferDrainThreshold) {\n\n        uint32_t TimeNow = QuicTimeUs32();\n\n        //\n        // Limit stream FC window growth by the connection FC window size.\n        //\n        if (Stream->RecvBuffer.VirtualBufferLength <\n            Stream->Connection->Settings.ConnFlowControlWindow) {\n\n            uint32_t TimeThreshold = (uint32_t)\n                ((Stream->RecvWindowBytesDelivered * Stream->Connection->Paths[0].SmoothedRtt) / RecvBufferDrainThreshold);\n            if (QuicTimeDiff32(Stream->RecvWindowLastUpdate, TimeNow) <= TimeThreshold) {\n\n                //\n                // Buffer tuning:\n                //\n                // VirtualBufferLength limits the connection's throughput to:\n                //   R = VirtualBufferLength / RTT\n                //\n                // We've delivered data at an average rate of at least:\n                //   R / QUIC_RECV_BUFFER_DRAIN_RATIO\n                //\n                // Double VirtualBufferLength to make sure it doesn't limit\n                // throughput.\n                //\n                // Mainly people complain about flow control when it limits\n                // throughput. But if we grow the buffer limit and then the app\n                // stops receiving data, bytes will pile up in the buffer. We could\n                // add logic to shrink the buffer when the app absorb rate is too\n                // low.\n                //\n\n                QuicTraceLogStreamVerbose(\n                    IncreaseRxBuffer,\n                    Stream,\n                    \"Increasing max RX buffer size to %u (MinRtt=%u; TimeNow=%u; LastUpdate=%u)\",\n                    Stream->RecvBuffer.VirtualBufferLength * 2,\n                    Stream->Connection->Paths[0].MinRtt,\n                    TimeNow,\n                    Stream->RecvWindowLastUpdate);\n\n                QuicRecvBufferSetVirtualBufferLength(\n                    &Stream->RecvBuffer,\n                    Stream->RecvBuffer.VirtualBufferLength * 2);\n            }\n        }\n\n        Stream->RecvWindowLastUpdate = TimeNow;\n        Stream->RecvWindowBytesDelivered = 0;\n\n    } else if (!(Stream->Connection->Send.SendFlags & QUIC_CONN_SEND_FLAG_ACK)) {\n        //\n        // We haven't hit the drain limit AND we don't have any ACKs to send\n        // immediately, so we don't need to immediately update the max data\n        // values.\n        //\n        return;\n    }\n\n    //\n    // Advance MaxAllowedRecvOffset.\n    //\n\n    QuicTraceLogStreamVerbose(\n        UpdateFlowControl,\n        Stream,\n        \"Updating flow control window\");\n\n    QUIC_DBG_ASSERT(\n        Stream->RecvBuffer.BaseOffset + Stream->RecvBuffer.VirtualBufferLength >\n        Stream->MaxAllowedRecvOffset);\n\n    Stream->MaxAllowedRecvOffset =\n        Stream->RecvBuffer.BaseOffset + Stream->RecvBuffer.VirtualBufferLength;\n\n    QuicSendSetSendFlag(\n        &Stream->Connection->Send,\n        QUIC_CONN_SEND_FLAG_MAX_DATA);\n    QuicSendSetStreamSendFlag(\n        &Stream->Connection->Send,\n        Stream,\n        QUIC_STREAM_SEND_FLAG_MAX_DATA);\n}", "path": "msquic/src/core/stream_recv.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Processes a STREAM frame.\n//\n", "func_signal": "_IRQL_requires_max_(PASSIVE_LEVEL)\nQUIC_STATUS\nQuicStreamProcessStreamFrame(\n    _In_ QUIC_STREAM* Stream,\n    _In_ BOOLEAN EncryptedWith0Rtt,\n    _In_ const QUIC_STREAM_EX* Frame\n    )", "code": "{\n    QUIC_STATUS Status;\n    BOOLEAN ReadyToDeliver = FALSE;\n    uint64_t EndOffset = Frame->Offset + Frame->Length;\n\n    if (Stream->Flags.RemoteNotAllowed) {\n        QuicTraceEvent(\n            StreamError,\n            \"[strm][%p] ERROR, %s.\",\n            Stream,\n            \"Receive on unidirectional stream\");\n        Status = QUIC_STATUS_INVALID_STATE;\n        goto Error;\n    }\n\n    if (Stream->Flags.RemoteCloseFin ||\n        Stream->Flags.RemoteCloseReset ||\n        Stream->Flags.SentStopSending) {\n        //\n        // Ignore the data if we are already closed remotely. Likely means we received\n        // a copy of already processed data that was resent.\n        //\n        QuicTraceEvent(\n            StreamError,\n            \"[strm][%p] ERROR, %s.\",\n            Stream,\n            \"Receive after close\");\n        Status = QUIC_STATUS_SUCCESS;\n        goto Error;\n    }\n\n    if (Frame->Fin && Stream->RecvMaxLength != UINT64_MAX &&\n        EndOffset != Stream->RecvMaxLength) {\n        //\n        // FIN disagrees with previous FIN.\n        //\n        Status = QUIC_STATUS_INVALID_PARAMETER;\n        goto Error;\n    }\n\n    if (EndOffset > Stream->RecvMaxLength) {\n        //\n        // Frame goes past the FIN.\n        //\n        Status = QUIC_STATUS_INVALID_PARAMETER;\n        goto Error;\n    }\n\n    if (EndOffset > QUIC_VAR_INT_MAX) {\n        //\n        // Stream data cannot exceed VAR_INT_MAX because it's impossible\n        // to provide flow control credit for that data.\n        //\n        QuicConnTransportError(Stream->Connection, QUIC_ERROR_FLOW_CONTROL_ERROR);\n        Status = QUIC_STATUS_INVALID_PARAMETER;\n        goto Error;\n    }\n\n    if (Frame->Length == 0) {\n\n        Status = QUIC_STATUS_SUCCESS;\n\n    } else {\n\n        //\n        // This is initialized to inform QuicRecvBufferWrite of the\n        // max number of allowed bytes per connection flow control.\n        // On return from QuicRecvBufferWrite, this represents the\n        // actual number of bytes written.\n        //\n        uint64_t WriteLength =\n            Stream->Connection->Send.MaxData -\n            Stream->Connection->Send.OrderedStreamBytesReceived;\n\n        //\n        // Write any nonduplicate data to the receive buffer.\n        // QuicRecvBufferWrite will indicate if there is data to deliver.\n        //\n        Status =\n            QuicRecvBufferWrite(\n                &Stream->RecvBuffer,\n                Frame->Offset,\n                (uint16_t)Frame->Length,\n                Frame->Data,\n                &WriteLength,\n                &ReadyToDeliver);\n        if (QUIC_FAILED(Status)) {\n            goto Error;\n        }\n\n        //\n        // Keep track of the total ordered bytes received.\n        //\n        Stream->Connection->Send.OrderedStreamBytesReceived += WriteLength;\n        QUIC_DBG_ASSERT(Stream->Connection->Send.OrderedStreamBytesReceived < Stream->Connection->Send.MaxData);\n        QUIC_DBG_ASSERT(Stream->Connection->Send.OrderedStreamBytesReceived >= WriteLength);\n\n        if (QuicRecvBufferGetTotalLength(&Stream->RecvBuffer) == Stream->MaxAllowedRecvOffset) {\n            QuicTraceLogStreamVerbose(\n                FlowControlExhausted,\n                Stream,\n                \"Flow control window exhausted!\");\n        }\n\n        if (EncryptedWith0Rtt) {\n            //\n            // Keep track of the maximum length of the 0-RTT payload so that we\n            // can indicate that appropriately to the API client.\n            //\n            if (EndOffset > Stream->RecvMax0RttLength) {\n                Stream->RecvMax0RttLength = EndOffset;\n            }\n        }\n\n        Stream->Connection->Stats.Recv.TotalStreamBytes += Frame->Length;\n    }\n\n    if (Frame->Fin) {\n        Stream->RecvMaxLength = EndOffset;\n        if (Stream->RecvBuffer.BaseOffset == Stream->RecvMaxLength) {\n            //\n            // All data delivered. Deliver the FIN.\n            //\n            ReadyToDeliver = TRUE;\n        }\n    }\n\n    if (ReadyToDeliver) {\n        Stream->Flags.ReceiveDataPending = TRUE;\n        QuicStreamRecvQueueFlush(Stream);\n    }\n\n    QuicTraceLogStreamVerbose(\n        Receive,\n        Stream,\n        \"Received %hu bytes, offset=%llu Ready=%hhu\",\n        (uint16_t)Frame->Length,\n        Frame->Offset,\n        ReadyToDeliver);\n\nError:\n\n    if (Status == QUIC_STATUS_INVALID_PARAMETER) {\n        QuicTraceLogStreamWarning(\n            ReceiveTooBig,\n            Stream,\n            \"Tried to write beyond end of buffer!\");\n        QuicConnTransportError(Stream->Connection, QUIC_ERROR_FINAL_SIZE_ERROR);\n    } else if (Status == QUIC_STATUS_BUFFER_TOO_SMALL) {\n        QuicTraceLogStreamWarning(\n            ReceiveBeyondFlowControl,\n            Stream,\n            \"Tried to write beyond flow control limit!\");\n        QuicConnTransportError(Stream->Connection, QUIC_ERROR_FLOW_CONTROL_ERROR);\n    }\n\n    return Status;\n}", "path": "msquic/src/core/stream_recv.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Allocates and initializes a new partitioned hash table.\n//\n", "func_signal": "_IRQL_requires_max_(DISPATCH_LEVEL)\nBOOLEAN\nQuicLookupCreateHashTable(\n    _In_ QUIC_LOOKUP* Lookup,\n    _In_range_(>, 0) uint16_t PartitionCount\n    )", "code": "{\n    QUIC_DBG_ASSERT(Lookup->LookupTable == NULL);\n    QUIC_FRE_ASSERT(PartitionCount > 0);\n\n    Lookup->HASH.Tables =\n        QUIC_ALLOC_NONPAGED(\n            sizeof(QUIC_PARTITIONED_HASHTABLE) * PartitionCount,\n            QUIC_POOL_LOOKUP_HASHTABLE);\n\n    if (Lookup->HASH.Tables != NULL) {\n\n        uint16_t Cleanup = 0;\n        for (uint16_t i = 0; i < PartitionCount; i++) {\n            if (!QuicHashtableInitializeEx(&Lookup->HASH.Tables[i].Table, QUIC_HASH_MIN_SIZE)) {\n                Cleanup = i;\n                break;\n            }\n            QuicDispatchRwLockInitialize(&Lookup->HASH.Tables[i].RwLock);\n        }\n        if (Cleanup != 0) {\n            for (uint16_t i = 0; i < Cleanup; i++) {\n                QuicHashtableUninitialize(&Lookup->HASH.Tables[i].Table);\n            }\n            QUIC_FREE(Lookup->HASH.Tables, QUIC_POOL_LOOKUP_HASHTABLE);\n            Lookup->HASH.Tables = NULL;\n        } else {\n            Lookup->PartitionCount = PartitionCount;\n        }\n    }\n\n    return Lookup->HASH.Tables != NULL;\n}", "path": "msquic/src/core/lookup.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Datapath binding interface.\n//\n", "func_signal": "QUIC_STATUS\nQuicDataPathBindingCreate(\n    _In_ QUIC_DATAPATH* Datapath,\n    _In_opt_ const QUIC_ADDR* LocalAddress,\n    _In_opt_ const QUIC_ADDR* RemoteAddress,\n    _In_opt_ void* RecvCallbackContext,\n    _Out_ QUIC_DATAPATH_BINDING** NewBinding\n    )", "code": "{\n#ifdef QUIC_PLATFORM_DISPATCH_TABLE\n    return\n        PlatDispatch->DatapathBindingCreate(\n            Datapath,\n            LocalAddress,\n            RemoteAddress,\n            RecvCallbackContext,\n            NewBinding);\n#else\n    QUIC_STATUS Status = QUIC_STATUS_SUCCESS;\n\n    uint32_t SocketCount = Datapath->ProcCount; // TODO - Only use 1 for client (RemoteAddress != NULL) bindings?\n    size_t BindingLength =\n        sizeof(QUIC_DATAPATH_BINDING) +\n        SocketCount * sizeof(QUIC_SOCKET_CONTEXT);\n\n    QUIC_DATAPATH_BINDING* Binding =\n        (QUIC_DATAPATH_BINDING*)QUIC_ALLOC_PAGED(BindingLength, QUIC_POOL_DATAPATH_BINDING);\n    if (Binding == NULL) {\n        Status = QUIC_STATUS_OUT_OF_MEMORY;\n        QuicTraceEvent(\n            AllocFailure,\n            \"Allocation of '%s' failed. (%llu bytes)\",\n            \"QUIC_DATAPATH_BINDING\",\n            BindingLength);\n        goto Exit;\n    }\n\n    QuicTraceEvent(\n        DatapathCreated,\n        \"[ udp][%p] Created, local=%!ADDR!, remote=%!ADDR!\",\n        Binding,\n        CLOG_BYTEARRAY(LocalAddress ? sizeof(*LocalAddress) : 0, LocalAddress),\n        CLOG_BYTEARRAY(RemoteAddress ? sizeof(*RemoteAddress) : 0, RemoteAddress));\n\n    QuicZeroMemory(Binding, BindingLength);\n    Binding->Datapath = Datapath;\n    Binding->ClientContext = RecvCallbackContext;\n    Binding->Mtu = QUIC_MAX_MTU;\n    QuicRundownInitialize(&Binding->Rundown);\n    if (LocalAddress) {\n        QuicConvertToMappedV6(LocalAddress, &Binding->LocalAddress);\n    } else {\n        Binding->LocalAddress.Ip.sa_family = QUIC_ADDRESS_FAMILY_INET6;\n    }\n    for (uint32_t i = 0; i < SocketCount; i++) {\n        Binding->SocketContexts[i].Binding = Binding;\n        Binding->SocketContexts[i].SocketFd = INVALID_SOCKET_FD;\n        Binding->SocketContexts[i].RecvIov.iov_len =\n            Binding->Mtu - QUIC_MIN_IPV4_HEADER_SIZE - QUIC_UDP_HEADER_SIZE;\n        QuicListInitializeHead(&Binding->SocketContexts[i].PendingSendContextHead);\n        QuicRundownAcquire(&Binding->Rundown);\n    }\n\n    QuicRundownAcquire(&Datapath->BindingsRundown);\n\n    for (uint32_t i = 0; i < SocketCount; i++) {\n        Status =\n            QuicSocketContextInitialize(\n                &Binding->SocketContexts[i],\n                &Datapath->ProcContexts[i],\n                LocalAddress,\n                RemoteAddress);\n        if (QUIC_FAILED(Status)) {\n            goto Exit;\n        }\n    }\n\n    QuicConvertFromMappedV6(&Binding->LocalAddress, &Binding->LocalAddress);\n    Binding->LocalAddress.Ipv6.sin6_scope_id = 0;\n\n    if (RemoteAddress != NULL) {\n        Binding->RemoteAddress = *RemoteAddress;\n    } else {\n        Binding->RemoteAddress.Ipv4.sin_port = 0;\n    }\n\n    //\n    // Must set output pointer before starting receive path, as the receive path\n    // will try to use the output.\n    //\n    *NewBinding = Binding;\n\n    for (uint32_t i = 0; i < Binding->Datapath->ProcCount; i++) {\n        Status =\n            QuicSocketContextStartReceive(\n                &Binding->SocketContexts[i],\n                Datapath->ProcContexts[i].EpollFd);\n        if (QUIC_FAILED(Status)) {\n            goto Exit;\n        }\n    }\n\n    Status = QUIC_STATUS_SUCCESS;\n\nExit:\n\n    if (QUIC_FAILED(Status)) {\n        if (Binding != NULL) {\n            QuicTraceEvent(\n                DatapathDestroyed,\n                \"[ udp][%p] Destroyed\",\n                Binding);\n            // TODO - Clean up socket contexts\n            QuicRundownRelease(&Datapath->BindingsRundown);\n            QuicRundownUninitialize(&Binding->Rundown);\n            QUIC_FREE(Binding, QUIC_POOL_DATAPATH_BINDING);\n            Binding = NULL;\n        }\n    }\n\n    return Status;\n#endif\n}", "path": "msquic/src/platform/datapath_linux.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Requires the Lookup->RwLock to be exlusively held.\n//\n", "func_signal": "_IRQL_requires_max_(DISPATCH_LEVEL)\nBOOLEAN\nQuicLookupInsertRemoteHash(\n    _In_ QUIC_LOOKUP* Lookup,\n    _In_ uint32_t Hash,\n    _In_ QUIC_CONNECTION* Connection,\n    _In_ const QUIC_ADDR* const RemoteAddress,\n    _In_ uint8_t RemoteCidLength,\n    _In_reads_(RemoteCidLength)\n        const uint8_t* const RemoteCid,\n    _In_ BOOLEAN UpdateRefCount\n    )", "code": "{\n    QUIC_REMOTE_HASH_ENTRY* Entry =\n        QUIC_ALLOC_NONPAGED(\n            sizeof(QUIC_REMOTE_HASH_ENTRY) + RemoteCidLength,\n            QUIC_POOL_REMOTE_HASH);\n    if (Entry == NULL) {\n        return FALSE;\n    }\n\n    Entry->Connection = Connection;\n    Entry->RemoteAddress = *RemoteAddress;\n    Entry->RemoteCidLength = RemoteCidLength;\n    QuicCopyMemory(\n        Entry->RemoteCid,\n        RemoteCid,\n        RemoteCidLength);\n\n    QuicHashtableInsert(\n        &Lookup->RemoteHashTable,\n        &Entry->Entry,\n        Hash,\n        NULL);\n\n    Connection->RemoteHashEntry = Entry;\n\n    QuicLibraryOnHandshakeConnectionAdded();\n\n    if (UpdateRefCount) {\n        QuicConnAddRef(Connection, QUIC_CONN_REF_LOOKUP_TABLE);\n    }\n\n#if QUIC_DEBUG_HASHTABLE_LOOKUP\n    QuicTraceLogVerbose(\n        LookupRemoteHashInsert,\n        \"[look][%p] Insert Conn=%p RemoteHash=%u\",\n        Lookup,\n        Connection,\n        Hash);\n#endif\n\n    return TRUE;\n}", "path": "msquic/src/core/lookup.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "//\n// Processes a received RESET_STREAM frame's payload.\n//\n", "func_signal": "_IRQL_requires_max_(PASSIVE_LEVEL)\nvoid\nQuicStreamProcessResetFrame(\n    _In_ QUIC_STREAM* Stream,\n    _In_ uint64_t FinalSize,\n    _In_ QUIC_VAR_INT ErrorCode\n    )", "code": "{\n    //\n    // Make sure the stream is remotely closed if not already.\n    //\n    Stream->Flags.RemoteCloseReset = TRUE;\n\n    if (!Stream->Flags.RemoteCloseAcked) {\n        Stream->Flags.RemoteCloseAcked = TRUE;\n        Stream->Flags.ReceiveEnabled = FALSE;\n        Stream->Flags.ReceiveDataPending = FALSE;\n\n        uint64_t TotalRecvLength = QuicRecvBufferGetTotalLength(&Stream->RecvBuffer);\n        if (TotalRecvLength > FinalSize) {\n            //\n            // The peer indicated a final offset less than what they have\n            // already sent to us. Kill the connection.\n            //\n            QuicTraceLogStreamWarning(\n                ResetEarly,\n                Stream,\n                \"Tried to reset at earlier final size!\");\n            QuicConnTransportError(Stream->Connection, QUIC_ERROR_FINAL_SIZE_ERROR);\n            return;\n\n        }\n\n        if (TotalRecvLength < FinalSize) {\n            //\n            // The final offset is indicating that more data was sent than we\n            // have actually received. Make sure to update our flow control\n            // accounting so we stay in sync with the peer.\n            //\n\n            uint64_t FlowControlIncrease = FinalSize - TotalRecvLength;\n            Stream->Connection->Send.OrderedStreamBytesReceived += FlowControlIncrease;\n            if (Stream->Connection->Send.OrderedStreamBytesReceived < FlowControlIncrease ||\n                Stream->Connection->Send.OrderedStreamBytesReceived > Stream->Connection->Send.MaxData) {\n                //\n                // The peer indicated a final offset more than allowed. Kill the\n                // connection.\n                //\n                QuicTraceLogStreamWarning(\n                    ResetTooBig,\n                    Stream,\n                    \"Tried to reset with too big final size!\");\n                QuicConnTransportError(Stream->Connection, QUIC_ERROR_FINAL_SIZE_ERROR);\n                return;\n            }\n        }\n\n        QuicTraceEvent(\n            StreamRecvState,\n            \"[strm][%p] Recv State: %hhu\",\n            Stream,\n            QuicStreamRecvGetState(Stream));\n\n        if (!Stream->Flags.SentStopSending) {\n            QuicTraceLogStreamInfo(\n                RemoteCloseReset,\n                Stream,\n                \"Closed remotely (reset)\");\n\n            QUIC_STREAM_EVENT Event;\n            Event.Type = QUIC_STREAM_EVENT_PEER_SEND_ABORTED;\n            Event.PEER_SEND_ABORTED.ErrorCode = ErrorCode;\n            QuicTraceLogStreamVerbose(\n                IndicatePeerSendAbort,\n                Stream,\n                \"Indicating QUIC_STREAM_EVENT_PEER_SEND_ABORTED (0x%llX)\",\n                ErrorCode);\n            (void)QuicStreamIndicateEvent(Stream, &Event);\n        }\n\n        //\n        // Remove any flags we shouldn't be sending now that the receive\n        // direction is closed.\n        //\n        QuicSendClearStreamSendFlag(\n            &Stream->Connection->Send,\n            Stream,\n            QUIC_STREAM_SEND_FLAG_MAX_DATA | QUIC_STREAM_SEND_FLAG_RECV_ABORT);\n    }\n}", "path": "msquic/src/core/stream_recv.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "microsoft/msquic", "stars": 3776, "license": "mit", "language": "c", "size": 288790}
{"docstring": "// Can return NULL if the configuration head is inert\n", "func_signal": "static struct wlr_output_configuration_head_v1 *config_head_from_resource(\n\t\tstruct wl_resource *resource)", "code": "{\n\tassert(wl_resource_instance_of(resource,\n\t\t&zwlr_output_configuration_head_v1_interface, &config_head_impl));\n\treturn wl_resource_get_user_data(resource);\n}", "path": "wlroots/types/wlr_output_management_v1.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Compute state that has changed and sends it to all clients. Then writes the\n// new state to the head.\n", "func_signal": "static bool manager_update_head(struct wlr_output_manager_v1 *manager,\n\t\tstruct wlr_output_head_v1 *head,\n\t\tstruct wlr_output_head_v1_state *next)", "code": "{\n\tstruct wlr_output_head_v1_state *current = &head->state;\n\n\tuint32_t state = 0;\n\tif (current->enabled != next->enabled) {\n\t\tstate |= HEAD_STATE_ENABLED;\n\t}\n\tif (current->mode != next->mode) {\n\t\tstate |= HEAD_STATE_MODE;\n\t}\n\tif (current->custom_mode.width != next->custom_mode.width ||\n\t\t\tcurrent->custom_mode.height != next->custom_mode.height ||\n\t\t\tcurrent->custom_mode.refresh != next->custom_mode.refresh) {\n\t\tstate |= HEAD_STATE_MODE;\n\t}\n\tif (current->x != next->x || current->y != next->y) {\n\t\tstate |= HEAD_STATE_POSITION;\n\t}\n\tif (current->transform != next->transform) {\n\t\tstate |= HEAD_STATE_TRANSFORM;\n\t}\n\tif (current->scale != next->scale) {\n\t\tstate |= HEAD_STATE_SCALE;\n\t}\n\n\t// If  a mode was added to wlr_output.modes we need to add the new mode\n\t// to the wlr_output_head\n\tstruct wlr_output_mode *mode;\n\twl_list_for_each(mode, &head->state.output->modes, link) {\n\t\tbool found = false;\n\t\tstruct wl_resource *mode_resource;\n\t\twl_resource_for_each(mode_resource, &head->mode_resources) {\n\t\t\tif (mode_from_resource(mode_resource) == mode) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tstruct wl_resource *resource;\n\t\t\twl_resource_for_each(resource, &head->resources) {\n\t\t\t\thead_send_mode(head, resource, mode);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (state != 0) {\n\t\t*current = *next;\n\n\t\tstruct wl_resource *resource;\n\t\twl_resource_for_each(resource, &head->resources) {\n\t\t\thead_send_state(head, resource, state);\n\t\t}\n\t}\n\n\treturn state != 0;\n}", "path": "wlroots/types/wlr_output_management_v1.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// TODO: This looks wrong :/\n", "func_signal": "static void handle_tablet_tool_wheel(void *data,\n\t\tstruct zwp_tablet_tool_v2 *id,\n\t\twl_fixed_t degree, int clicks)", "code": "{\n\tstruct wlr_wl_tablet_tool *tool = data;\n\ttool->wheel_delta = wl_fixed_to_double(degree);\n}", "path": "wlroots/backend/wayland/tablet_v2.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// TODO: replace this with hash table?\n", "func_signal": "static struct wlr_xwayland_surface *lookup_surface(struct wlr_xwm *xwm,\n\t\txcb_window_t window_id)", "code": "{\n\tstruct wlr_xwayland_surface *surface;\n\twl_list_for_each(surface, &xwm->surfaces, link) {\n\t\tif (surface->window_id == window_id) {\n\t\t\treturn surface;\n\t\t}\n\t}\n\treturn NULL;\n}", "path": "wlroots/xwayland/xwm.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Returns NULL if the viewport is inert\n", "func_signal": "static struct wlr_viewport *viewport_from_resource(\n\t\tstruct wl_resource *resource)", "code": "{\n\tassert(wl_resource_instance_of(resource, &wp_viewport_interface,\n\t\t&viewport_impl));\n\treturn wl_resource_get_user_data(resource);\n}", "path": "wlroots/types/wlr_viewporter.c", "commit_date": "2020-06-17 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Sends new head state to a client.\n", "func_signal": "static void head_send_state(struct wlr_output_head_v1 *head,\n\t\tstruct wl_resource *head_resource, uint32_t state)", "code": "{\n\tstruct wl_client *client = wl_resource_get_client(head_resource);\n\n\tif (state & HEAD_STATE_ENABLED) {\n\t\tzwlr_output_head_v1_send_enabled(head_resource, head->state.enabled);\n\t\t// On enabling we send all current data since clients have not been\n\t\t// notified about potential data changes while the head was disabled.\n\t\tstate = HEAD_STATE_ALL;\n\t}\n\n\tif (!head->state.enabled) {\n\t\treturn;\n\t}\n\n\tif (state & HEAD_STATE_MODE) {\n\t\tassert(head->state.mode != NULL ||\n\t\t\twl_list_empty(&head->state.output->modes));\n\n\t\tbool found = false;\n\t\tstruct wl_resource *mode_resource;\n\t\twl_resource_for_each(mode_resource, &head->mode_resources) {\n\t\t\tif (wl_resource_get_client(mode_resource) == client &&\n\t\t\t\t\tmode_from_resource(mode_resource) == head->state.mode) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(found);\n\n\t\tif (head->state.mode == NULL) {\n\t\t\t// Fake a single output mode if output doesn't support modes\n\t\t\tstruct wlr_output_mode virtual_mode = {\n\t\t\t\t.width = head->state.custom_mode.width,\n\t\t\t\t.height = head->state.custom_mode.height,\n\t\t\t\t.refresh = head->state.custom_mode.refresh,\n\t\t\t};\n\t\t\tsend_mode_state(mode_resource, &virtual_mode);\n\t\t}\n\n\t\tzwlr_output_head_v1_send_current_mode(head_resource, mode_resource);\n\t}\n\n\tif (state & HEAD_STATE_POSITION) {\n\t\tzwlr_output_head_v1_send_position(head_resource,\n\t\t\thead->state.x, head->state.y);\n\t}\n\n\tif (state & HEAD_STATE_TRANSFORM) {\n\t\tzwlr_output_head_v1_send_transform(head_resource,\n\t\t\thead->state.transform);\n\t}\n\n\tif (state & HEAD_STATE_SCALE) {\n\t\tzwlr_output_head_v1_send_scale(head_resource,\n\t\t\twl_fixed_from_double(head->state.scale));\n\t}\n}", "path": "wlroots/types/wlr_output_management_v1.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "/* Tests if 'path' is KMS compatible by trying to open it.\n * It leaves the open device in *fd_out it it succeeds.\n */\n", "func_signal": "static struct wlr_device *open_if_kms(struct wlr_session *restrict session,\n\t\tconst char *restrict path)", "code": "{\n\tif (!path) {\n\t\treturn NULL;\n\t}\n\n\tstruct wlr_device *dev = wlr_session_open_file(session, path);\n\tif (!dev) {\n\t\treturn NULL;\n\t}\n\n\tdrmVersion *ver = drmGetVersion(dev->fd);\n\tif (!ver) {\n\t\tgoto out_dev;\n\t}\n\n\tdrmFreeVersion(ver);\n\treturn dev;\n\nout_dev:\n\twlr_session_close_file(session, dev);\n\treturn NULL;\n}", "path": "wlroots/backend/session/session.c", "commit_date": "2020-11-19 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// TODO use me to support 32 bit color somehow\n", "func_signal": "static void xwm_get_visual_and_colormap(struct wlr_xwm *xwm)", "code": "{\n\txcb_depth_iterator_t d_iter;\n\txcb_visualtype_iterator_t vt_iter;\n\txcb_visualtype_t *visualtype;\n\n\td_iter = xcb_screen_allowed_depths_iterator(xwm->screen);\n\tvisualtype = NULL;\n\twhile (d_iter.rem > 0) {\n\t\tif (d_iter.data->depth == 32) {\n\t\t\tvt_iter = xcb_depth_visuals_iterator(d_iter.data);\n\t\t\tvisualtype = vt_iter.data;\n\t\t\tbreak;\n\t\t}\n\n\t\txcb_depth_next(&d_iter);\n\t}\n\n\tif (visualtype == NULL) {\n\t\twlr_log(WLR_DEBUG, \"No 32 bit visualtype\\n\");\n\t\treturn;\n\t}\n\n\txwm->visual_id = visualtype->visual_id;\n\txwm->colormap = xcb_generate_id(xwm->xcb_conn);\n\txcb_create_colormap(xwm->xcb_conn,\n\t\tXCB_COLORMAP_ALLOC_NONE,\n\t\txwm->colormap,\n\t\txwm->screen->root,\n\t\txwm->visual_id);\n}", "path": "wlroots/xwayland/xwm.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "/* Tries to find the primary GPU by checking for the \"boot_vga\" attribute.\n * If it's not found, it returns the first valid GPU it finds.\n */\n", "func_signal": "size_t wlr_session_find_gpus(struct wlr_session *session,\n\t\tsize_t ret_len, struct wlr_device **ret)", "code": "{\n\tconst char *explicit = getenv(\"WLR_DRM_DEVICES\");\n\tif (explicit) {\n\t\treturn explicit_find_gpus(session, ret_len, ret, explicit);\n\t}\n\n\tstruct udev_enumerate *en = enumerate_drm_cards(session->udev);\n\tif (!en) {\n\t\treturn -1;\n\t}\n\n\tif (udev_enumerate_get_list_entry(en) == NULL) {\n\t\tudev_enumerate_unref(en);\n\t\twlr_log(WLR_INFO, \"Waiting for a DRM card device\");\n\n\t\tstruct find_gpus_add_handler handler = {0};\n\t\thandler.listener.notify = find_gpus_handle_add;\n\t\twl_signal_add(&session->events.add_drm_card, &handler.listener);\n\n\t\tuint64_t started_at = get_current_time_ms();\n\t\tuint64_t timeout = WAIT_GPU_TIMEOUT;\n\t\tstruct wl_event_loop *event_loop =\n\t\t\twl_display_get_event_loop(session->display);\n\t\twhile (!handler.added) {\n\t\t\tint ret = wl_event_loop_dispatch(event_loop, (int)timeout);\n\t\t\tif (ret < 0) {\n\t\t\t\twlr_log_errno(WLR_ERROR, \"Failed to wait for DRM card device: \"\n\t\t\t\t\t\"wl_event_loop_dispatch failed\");\n\t\t\t\tudev_enumerate_unref(en);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tuint64_t now = get_current_time_ms();\n\t\t\tif (now >= started_at + WAIT_GPU_TIMEOUT) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttimeout = started_at + WAIT_GPU_TIMEOUT - now;\n\t\t}\n\n\t\twl_list_remove(&handler.listener.link);\n\n\t\ten = enumerate_drm_cards(session->udev);\n\t\tif (!en) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tstruct udev_list_entry *entry;\n\tsize_t i = 0;\n\n\tudev_list_entry_foreach(entry, udev_enumerate_get_list_entry(en)) {\n\t\tif (i == ret_len) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbool is_boot_vga = false;\n\n\t\tconst char *path = udev_list_entry_get_name(entry);\n\t\tstruct udev_device *dev = udev_device_new_from_syspath(session->udev, path);\n\t\tif (!dev) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst char *seat = udev_device_get_property_value(dev, \"ID_SEAT\");\n\t\tif (!seat) {\n\t\t\tseat = \"seat0\";\n\t\t}\n\t\tif (session->seat[0] && strcmp(session->seat, seat) != 0) {\n\t\t\tudev_device_unref(dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// This is owned by 'dev', so we don't need to free it\n\t\tstruct udev_device *pci =\n\t\t\tudev_device_get_parent_with_subsystem_devtype(dev, \"pci\", NULL);\n\n\t\tif (pci) {\n\t\t\tconst char *id = udev_device_get_sysattr_value(pci, \"boot_vga\");\n\t\t\tif (id && strcmp(id, \"1\") == 0) {\n\t\t\t\tis_boot_vga = true;\n\t\t\t}\n\t\t}\n\n\t\tstruct wlr_device *wlr_dev =\n\t\t\topen_if_kms(session, udev_device_get_devnode(dev));\n\t\tif (!wlr_dev) {\n\t\t\tudev_device_unref(dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tudev_device_unref(dev);\n\n\t\tret[i] = wlr_dev;\n\t\tif (is_boot_vga) {\n\t\t\tstruct wlr_device *tmp = ret[0];\n\t\t\tret[0] = ret[i];\n\t\t\tret[i] = tmp;\n\t\t}\n\n\t\t++i;\n\t}\n\n\tudev_enumerate_unref(en);\n\n\treturn i;\n}", "path": "wlroots/backend/session/session.c", "commit_date": "2020-11-19 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Can return NULL if the head is inert\n", "func_signal": "static struct wlr_output_head_v1 *head_from_resource(\n\t\tstruct wl_resource *resource)", "code": "{\n\tassert(wl_resource_instance_of(resource,\n\t\t&zwlr_output_head_v1_interface, NULL));\n\treturn wl_resource_get_user_data(resource);\n}", "path": "wlroots/types/wlr_output_management_v1.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "/*\n * From libXcursor/src/file.c\n */\n", "func_signal": "static XcursorImage *\nXcursorImageCreate (int width, int height)", "code": "{\n    XcursorImage    *image;\n\n    if (width < 0 || height < 0)\n       return NULL;\n    if (width > XCURSOR_IMAGE_MAX_SIZE || height > XCURSOR_IMAGE_MAX_SIZE)\n       return NULL;\n\n    image = malloc (sizeof (XcursorImage) +\n\t\t    width * height * sizeof (XcursorPixel));\n    if (!image)\n\treturn NULL;\n    image->version = XCURSOR_IMAGE_VERSION;\n    image->pixels = (XcursorPixel *) (image + 1);\n    image->size = width > height ? width : height;\n    image->width = width;\n    image->height = height;\n    image->delay = 0;\n    return image;\n}", "path": "wlroots/xcursor/xcursor.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Finalizes a configuration. This prevents the same config from being used\n// multiple times.\n", "func_signal": "static void config_finalize(struct wlr_output_configuration_v1 *config)", "code": "{\n\tif (config->finalized) {\n\t\treturn;\n\t}\n\n\t// Destroy config head resources now, the client is forbidden to use them at\n\t// this point anyway\n\tstruct wlr_output_configuration_head_v1 *config_head, *tmp;\n\twl_list_for_each_safe(config_head, tmp, &config->heads, link) {\n\t\t// Resource is NULL if head has been disabled\n\t\tif (config_head->resource != NULL) {\n\t\t\twl_resource_set_user_data(config_head->resource, NULL);\n\t\t\twl_resource_destroy(config_head->resource);\n\t\t\tconfig_head->resource = NULL;\n\t\t}\n\t}\n\n\tconfig->finalized = true;\n}", "path": "wlroots/types/wlr_output_management_v1.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "/* This isn't in the listener, but keep the naming scheme around since the\n * other removed functions work like this, and pad sub-resources are just a bit\n * special */\n", "func_signal": "static void handle_tablet_pad_group_removed(\n\t\tstruct wlr_wl_tablet_pad_group *group)", "code": "{\n\n\t/* No need to remove the ::link on strips rings as long as we do *not*\n\t * wl_list_remove on the wl_groups ring/strip attributes here */\n\tstruct wlr_wl_tablet_pad_ring *ring, *tmp_ring;\n\twl_list_for_each_safe(ring, tmp_ring, &group->rings, link) {\n\t\tzwp_tablet_pad_ring_v2_destroy(ring->ring);\n\t\tfree(ring);\n\t}\n\n\tstruct wlr_wl_tablet_pad_strip *strip, *tmp_strip;\n\twl_list_for_each_safe(strip, tmp_strip, &group->strips, link) {\n\t\tzwp_tablet_pad_strip_v2_destroy(strip->strip);\n\t\tfree(strip);\n\t}\n\n\tzwp_tablet_pad_group_v2_destroy(group->pad_group);\n\n\t/* While I'm pretty sure we have control over this as well, it's\n\t * outside the scope of a single function, so better be safe than\n\t * sorry */\n\twl_list_remove(&group->group.link);\n\tfree(group);\n}", "path": "wlroots/backend/wayland/tablet_v2.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Destroys the config if serial is invalid\n", "func_signal": "static bool config_validate_serial(struct wlr_output_configuration_v1 *config)", "code": "{\n\tif (config->serial != config->manager->serial) {\n\t\twlr_log(WLR_DEBUG, \"Ignored configuration request: invalid serial\");\n\t\tzwlr_output_configuration_v1_send_cancelled(config->resource);\n\t\twlr_output_configuration_v1_destroy(config);\n\t\treturn false;\n\t}\n\treturn true;\n}", "path": "wlroots/types/wlr_output_management_v1.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// cancel operation\n", "func_signal": "static enum wlr_edges net_wm_edges_to_wlr(uint32_t net_wm_edges)", "code": "{\n\tenum wlr_edges edges = WLR_EDGE_NONE;\n\n\tswitch(net_wm_edges) {\n\tcase _NET_WM_MOVERESIZE_SIZE_TOPLEFT:\n\t\tedges = WLR_EDGE_TOP | WLR_EDGE_LEFT;\n\t\tbreak;\n\tcase _NET_WM_MOVERESIZE_SIZE_TOP:\n\t\tedges = WLR_EDGE_TOP;\n\t\tbreak;\n\tcase _NET_WM_MOVERESIZE_SIZE_TOPRIGHT:\n\t\tedges = WLR_EDGE_TOP | WLR_EDGE_RIGHT;\n\t\tbreak;\n\tcase _NET_WM_MOVERESIZE_SIZE_RIGHT:\n\t\tedges = WLR_EDGE_RIGHT;\n\t\tbreak;\n\tcase _NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT:\n\t\tedges = WLR_EDGE_BOTTOM | WLR_EDGE_RIGHT;\n\t\tbreak;\n\tcase _NET_WM_MOVERESIZE_SIZE_BOTTOM:\n\t\tedges = WLR_EDGE_BOTTOM;\n\t\tbreak;\n\tcase _NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT:\n\t\tedges = WLR_EDGE_BOTTOM | WLR_EDGE_LEFT;\n\t\tbreak;\n\tcase _NET_WM_MOVERESIZE_SIZE_LEFT:\n\t\tedges = WLR_EDGE_LEFT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn edges;\n}", "path": "wlroots/xwayland/xwm.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "/* return NULL when id == -1\n * exit if the given ID cannot be found in the list of toplevels */\n", "func_signal": "static struct toplevel_v1 *toplevel_by_id_or_bail(int32_t id)", "code": "{\n\tif (id == -1) {\n\t\treturn NULL;\n\t}\n\n\tstruct toplevel_v1 *toplevel;\n\twl_list_for_each(toplevel, &toplevel_list, link) {\n\t\tif (toplevel->id == (uint32_t)id) {\n\t\t\treturn toplevel;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"No toplevel with the given id: %d\\n\", id);\n\texit(EXIT_FAILURE);\n}", "path": "wlroots/examples/foreign-toplevel.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Equivalent to glOrtho(0, width, 0, height, 1, -1) with the transform applied\n", "func_signal": "void wlr_matrix_projection(float mat[static 9], int width, int height,\n\t\tenum wl_output_transform transform)", "code": "{\n\tmemset(mat, 0, sizeof(*mat) * 9);\n\n\tconst float *t = transforms[transform];\n\tfloat x = 2.0f / width;\n\tfloat y = 2.0f / height;\n\n\t// Rotation + reflection\n\tmat[0] = x * t[0];\n\tmat[1] = x * t[1];\n\tmat[3] = y * -t[3];\n\tmat[4] = y * -t[4];\n\n\t// Translation\n\tmat[2] = -copysign(1.0f, mat[0] + mat[1]);\n\tmat[5] = -copysign(1.0f, mat[3] + mat[4]);\n\n\t// Identity\n\tmat[8] = 1.0f;\n}", "path": "wlroots/types/wlr_matrix.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Can return NULL if the config has been used\n", "func_signal": "static struct wlr_output_configuration_v1 *config_from_resource(\n\t\tstruct wl_resource *resource)", "code": "{\n\tassert(wl_resource_instance_of(resource,\n\t\t&zwlr_output_configuration_v1_interface, &config_impl));\n\treturn wl_resource_get_user_data(resource);\n}", "path": "wlroots/types/wlr_output_management_v1.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "// Checks that the head is unconfigured (ie. no enable_head/disable_head request\n// has yet been sent for this head), if not sends a protocol error.\n", "func_signal": "static bool config_check_head_is_unconfigured(\n\t\tstruct wlr_output_configuration_v1 *config, struct wlr_output *output)", "code": "{\n\tstruct wlr_output_configuration_head_v1 *head;\n\twl_list_for_each(head, &config->heads, link) {\n\t\tif (head->state.output == output) {\n\t\t\twl_resource_post_error(config->resource,\n\t\t\t\tZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ALREADY_CONFIGURED_HEAD,\n\t\t\t\t\"head has already been configured\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "path": "wlroots/types/wlr_output_management_v1.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "/* Actual protocol foo */\n", "func_signal": "uint32_t wlr_send_tablet_v2_tablet_pad_enter(\n\t\tstruct wlr_tablet_v2_tablet_pad *pad,\n\t\tstruct wlr_tablet_v2_tablet *tablet,\n\t\tstruct wlr_surface *surface)", "code": "{\n\tstruct wl_client *client = wl_resource_get_client(surface->resource);\n\n\tstruct wlr_tablet_client_v2 *tablet_tmp;\n\tstruct wlr_tablet_client_v2 *tablet_client = NULL;\n\twl_list_for_each(tablet_tmp, &tablet->clients, tablet_link) {\n\t\tif (tablet_tmp->client == client) {\n\t\t\ttablet_client = tablet_tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Couldn't find the client binding for the surface's client. Either\n\t// the client didn't bind tablet_v2 at all, or not for the relevant\n\t// seat\n\tif (!tablet_client) {\n\t\treturn 0;\n\t}\n\n\tstruct wlr_tablet_pad_client_v2 *pad_tmp = NULL;\n\tstruct wlr_tablet_pad_client_v2 *pad_client = NULL;\n\twl_list_for_each(pad_tmp, &pad->clients, pad_link) {\n\t\tif (pad_tmp->client == client) {\n\t\t\tpad_client = pad_tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Couldn't find the client binding for the surface's client. Either\n\t// the client didn't bind tablet_v2 at all, or not for the relevant\n\t// seat\n\tif (!pad_client) {\n\t\treturn 0;\n\t}\n\n\tpad->current_client = pad_client;\n\n\tuint32_t serial = wlr_seat_client_next_serial(\n\t\tpad_client->seat->seat_client);\n\n\tzwp_tablet_pad_v2_send_enter(pad_client->resource, serial,\n\t\ttablet_client->resource, surface->resource);\n\n\tstruct timespec now;\n\tclock_gettime(CLOCK_MONOTONIC, &now);\n\tuint32_t time = now.tv_nsec / 1000;\n\n\tfor (size_t i = 0; i < pad->group_count; ++i) {\n\t\tif (pad_client->groups[i]) {\n\t\t\tzwp_tablet_pad_group_v2_send_mode_switch(\n\t\t\t\tpad_client->groups[i], time, serial, pad->groups[i]);\n\t\t}\n\t}\n\n\treturn serial;\n}", "path": "wlroots/types/tablet_v2/wlr_tablet_v2_pad.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "swaywm/wlroots", "stars": 2114, "license": "mit", "language": "c", "size": 8862}
{"docstring": "/*\n * Assume graph is already leveled.\n */\n", "func_signal": "static void\nfind_ud(opt_state_t *opt_state, struct block *root)", "code": "{\n\tint i, maxlevel;\n\tstruct block *p;\n\n\t/*\n\t * root->level is the highest level no found;\n\t * count down from there.\n\t */\n\tmaxlevel = root->level;\n\tfor (i = maxlevel; i >= 0; --i)\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\tcompute_local_ud(p);\n\t\t\tp->out_use = 0;\n\t\t}\n\n\tfor (i = 1; i <= maxlevel; ++i) {\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\tp->out_use |= JT(p)->in_use | JF(p)->in_use;\n\t\t\tp->in_use |= p->out_use &~ p->kill;\n\t\t}\n\t}\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Return the number of stmts in the flowgraph reachable by 'p'.\n * The nodes should be unmarked before calling.\n *\n * Note that \"stmts\" means \"instructions\", and that this includes\n *\n *\tside-effect statements in 'p' (slength(p->stmts));\n *\n *\tstatements in the true branch from 'p' (count_stmts(JT(p)));\n *\n *\tstatements in the false branch from 'p' (count_stmts(JF(p)));\n *\n *\tthe conditional jump itself (1);\n *\n *\tan extra long jump if the true branch requires it (p->longjt);\n *\n *\tan extra long jump if the false branch requires it (p->longjf).\n */\n", "func_signal": "static u_int\ncount_stmts(struct icode *ic, struct block *p)", "code": "{\n\tu_int n;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn 0;\n\tMark(ic, p);\n\tn = count_stmts(ic, JT(p)) + count_stmts(ic, JF(p));\n\treturn slength(p->stmts) + n + 1 + p->longjt + p->longjf;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Allocate memory.  All allocation is done before optimization\n * is begun.  A linear bound on the size of all data structures is computed\n * from the total number of blocks and/or statements.\n */\n", "func_signal": "static void\nopt_init(opt_state_t *opt_state, struct icode *ic)", "code": "{\n\tbpf_u_int32 *p;\n\tint i, n, max_stmts;\n\tu_int product;\n\tsize_t block_memsize, edge_memsize;\n\n\t/*\n\t * First, count the blocks, so we can malloc an array to map\n\t * block number to block.  Then, put the blocks into the array.\n\t */\n\tunMarkAll(ic);\n\tn = count_blocks(ic, ic->root);\n\topt_state->blocks = (struct block **)calloc(n, sizeof(*opt_state->blocks));\n\tif (opt_state->blocks == NULL)\n\t\topt_error(opt_state, \"malloc\");\n\tunMarkAll(ic);\n\topt_state->n_blocks = 0;\n\tnumber_blks_r(opt_state, ic, ic->root);\n\n\t/*\n\t * This \"should not happen\".\n\t */\n\tif (opt_state->n_blocks == 0)\n\t\topt_error(opt_state, \"filter has no instructions; please report this as a libpcap issue\");\n\n\topt_state->n_edges = 2 * opt_state->n_blocks;\n\tif ((opt_state->n_edges / 2) != opt_state->n_blocks) {\n\t\t/*\n\t\t * Overflow.\n\t\t */\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\topt_state->edges = (struct edge **)calloc(opt_state->n_edges, sizeof(*opt_state->edges));\n\tif (opt_state->edges == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\n\t/*\n\t * The number of levels is bounded by the number of nodes.\n\t */\n\topt_state->levels = (struct block **)calloc(opt_state->n_blocks, sizeof(*opt_state->levels));\n\tif (opt_state->levels == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\n\topt_state->edgewords = opt_state->n_edges / BITS_PER_WORD + 1;\n\topt_state->nodewords = opt_state->n_blocks / BITS_PER_WORD + 1;\n\n\t/*\n\t * Make sure opt_state->n_blocks * opt_state->nodewords fits\n\t * in a u_int; we use it as a u_int number-of-iterations\n\t * value.\n\t */\n\tproduct = opt_state->n_blocks * opt_state->nodewords;\n\tif ((product / opt_state->n_blocks) != opt_state->nodewords) {\n\t\t/*\n\t\t * XXX - just punt and don't try to optimize?\n\t\t * In practice, this is unlikely to happen with\n\t\t * a normal filter.\n\t\t */\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/*\n\t * Make sure the total memory required for that doesn't\n\t * overflow.\n\t */\n\tblock_memsize = (size_t)2 * product * sizeof(*opt_state->space);\n\tif ((block_memsize / product) != 2 * sizeof(*opt_state->space)) {\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/*\n\t * Make sure opt_state->n_edges * opt_state->edgewords fits\n\t * in a u_int; we use it as a u_int number-of-iterations\n\t * value.\n\t */\n\tproduct = opt_state->n_edges * opt_state->edgewords;\n\tif ((product / opt_state->n_edges) != opt_state->edgewords) {\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/*\n\t * Make sure the total memory required for that doesn't\n\t * overflow.\n\t */\n\tedge_memsize = (size_t)product * sizeof(*opt_state->space);\n\tif (edge_memsize / product != sizeof(*opt_state->space)) {\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/*\n\t * Make sure the total memory required for both of them dosn't\n\t * overflow.\n\t */\n\tif (block_memsize > SIZE_MAX - edge_memsize) {\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\n\t/* XXX */\n\topt_state->space = (bpf_u_int32 *)malloc(block_memsize + edge_memsize);\n\tif (opt_state->space == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\tp = opt_state->space;\n\topt_state->all_dom_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\topt_state->blocks[i]->dom = p;\n\t\tp += opt_state->nodewords;\n\t}\n\topt_state->all_closure_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\topt_state->blocks[i]->closure = p;\n\t\tp += opt_state->nodewords;\n\t}\n\topt_state->all_edge_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\tregister struct block *b = opt_state->blocks[i];\n\n\t\tb->et.edom = p;\n\t\tp += opt_state->edgewords;\n\t\tb->ef.edom = p;\n\t\tp += opt_state->edgewords;\n\t\tb->et.id = i;\n\t\topt_state->edges[i] = &b->et;\n\t\tb->ef.id = opt_state->n_blocks + i;\n\t\topt_state->edges[opt_state->n_blocks + i] = &b->ef;\n\t\tb->et.pred = b;\n\t\tb->ef.pred = b;\n\t}\n\tmax_stmts = 0;\n\tfor (i = 0; i < n; ++i)\n\t\tmax_stmts += slength(opt_state->blocks[i]->stmts) + 1;\n\t/*\n\t * We allocate at most 3 value numbers per statement,\n\t * so this is an upper bound on the number of valnodes\n\t * we'll need.\n\t */\n\topt_state->maxval = 3 * max_stmts;\n\topt_state->vmap = (struct vmapinfo *)calloc(opt_state->maxval, sizeof(*opt_state->vmap));\n\tif (opt_state->vmap == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\topt_state->vnode_base = (struct valnode *)calloc(opt_state->maxval, sizeof(*opt_state->vnode_base));\n\tif (opt_state->vnode_base == NULL) {\n\t\topt_error(opt_state, \"malloc\");\n\t}\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Compute the symbolic value of expression of 's', and update\n * anything it defines in the value table 'val'.  If 'alter' is true,\n * do various optimizations.  This code would be cleaner if symbolic\n * evaluation and code transformations weren't folded together.\n */\n", "func_signal": "static void\nopt_stmt(opt_state_t *opt_state, struct stmt *s, bpf_u_int32 val[], int alter)", "code": "{\n\tint op;\n\tbpf_u_int32 v;\n\n\tswitch (s->code) {\n\n\tcase BPF_LD|BPF_ABS|BPF_W:\n\tcase BPF_LD|BPF_ABS|BPF_H:\n\tcase BPF_LD|BPF_ABS|BPF_B:\n\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_IND|BPF_W:\n\tcase BPF_LD|BPF_IND|BPF_H:\n\tcase BPF_LD|BPF_IND|BPF_B:\n\t\tv = val[X_ATOM];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LD|BPF_ABS|BPF_SIZE(s->code);\n\t\t\ts->k += opt_state->vmap[v].const_val;\n\t\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t\topt_state->done = 0;\n\t\t}\n\t\telse\n\t\t\tv = F(opt_state, s->code, s->k, v);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_LEN:\n\t\tv = F(opt_state, s->code, 0L, 0L);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_IMM:\n\t\tv = K(s->k);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_IMM:\n\t\tv = K(s->k);\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MSH|BPF_B:\n\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_NEG:\n\t\tif (alter && opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t/*\n\t\t\t * Do this negation as unsigned arithmetic; that's\n\t\t\t * what modern BPF engines do, and it guarantees\n\t\t\t * that all possible values can be negated.  (Yeah,\n\t\t\t * negating 0x80000000, the minimum signed 32-bit\n\t\t\t * two's-complement value, results in 0x80000000,\n\t\t\t * so it's still negative, but we *should* be doing\n\t\t\t * all unsigned arithmetic here, to match what\n\t\t\t * modern BPF engines do.)\n\t\t\t *\n\t\t\t * Express it as 0U - (unsigned value) so that we\n\t\t\t * don't get compiler warnings about negating an\n\t\t\t * unsigned value and don't get UBSan warnings\n\t\t\t * about the result of negating 0x80000000 being\n\t\t\t * undefined.\n\t\t\t */\n\t\t\ts->k = 0U - opt_state->vmap[val[A_ATOM]].const_val;\n\t\t\tval[A_ATOM] = K(s->k);\n\t\t}\n\t\telse\n\t\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], 0L);\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_K:\n\tcase BPF_ALU|BPF_SUB|BPF_K:\n\tcase BPF_ALU|BPF_MUL|BPF_K:\n\tcase BPF_ALU|BPF_DIV|BPF_K:\n\tcase BPF_ALU|BPF_MOD|BPF_K:\n\tcase BPF_ALU|BPF_AND|BPF_K:\n\tcase BPF_ALU|BPF_OR|BPF_K:\n\tcase BPF_ALU|BPF_XOR|BPF_K:\n\tcase BPF_ALU|BPF_LSH|BPF_K:\n\tcase BPF_ALU|BPF_RSH|BPF_K:\n\t\top = BPF_OP(s->code);\n\t\tif (alter) {\n\t\t\tif (s->k == 0) {\n\t\t\t\t/*\n\t\t\t\t * Optimize operations where the constant\n\t\t\t\t * is zero.\n\t\t\t\t *\n\t\t\t\t * Don't optimize away \"sub #0\"\n\t\t\t\t * as it may be needed later to\n\t\t\t\t * fixup the generated math code.\n\t\t\t\t *\n\t\t\t\t * Fail if we're dividing by zero or taking\n\t\t\t\t * a modulus by zero.\n\t\t\t\t */\n\t\t\t\tif (op == BPF_ADD ||\n\t\t\t\t    op == BPF_LSH || op == BPF_RSH ||\n\t\t\t\t    op == BPF_OR || op == BPF_XOR) {\n\t\t\t\t\ts->code = NOP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op == BPF_MUL || op == BPF_AND) {\n\t\t\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op == BPF_DIV)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"division by zero\");\n\t\t\t\tif (op == BPF_MOD)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"modulus by zero\");\n\t\t\t}\n\t\t\tif (opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\t\tfold_op(opt_state, s, val[A_ATOM], K(s->k));\n\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], K(s->k));\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_X:\n\tcase BPF_ALU|BPF_SUB|BPF_X:\n\tcase BPF_ALU|BPF_MUL|BPF_X:\n\tcase BPF_ALU|BPF_DIV|BPF_X:\n\tcase BPF_ALU|BPF_MOD|BPF_X:\n\tcase BPF_ALU|BPF_AND|BPF_X:\n\tcase BPF_ALU|BPF_OR|BPF_X:\n\tcase BPF_ALU|BPF_XOR|BPF_X:\n\tcase BPF_ALU|BPF_LSH|BPF_X:\n\tcase BPF_ALU|BPF_RSH|BPF_X:\n\t\top = BPF_OP(s->code);\n\t\tif (alter && opt_state->vmap[val[X_ATOM]].is_const) {\n\t\t\tif (opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\t\tfold_op(opt_state, s, val[A_ATOM], val[X_ATOM]);\n\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts->code = BPF_ALU|BPF_K|op;\n\t\t\t\ts->k = opt_state->vmap[val[X_ATOM]].const_val;\n\t\t\t\tif ((op == BPF_LSH || op == BPF_RSH) &&\n\t\t\t\t    s->k > 31)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"shift by more than 31 bits\");\n\t\t\t\t/*\n\t\t\t\t * XXX - optimizer loop detection.\n\t\t\t\t */\n\t\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t\t\topt_state->done = 0;\n\t\t\t\tval[A_ATOM] =\n\t\t\t\t\tF(opt_state, s->code, val[A_ATOM], K(s->k));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Check if we're doing something to an accumulator\n\t\t * that is 0, and simplify.  This may not seem like\n\t\t * much of a simplification but it could open up further\n\t\t * optimizations.\n\t\t * XXX We could also check for mul by 1, etc.\n\t\t */\n\t\tif (alter && opt_state->vmap[val[A_ATOM]].is_const\n\t\t    && opt_state->vmap[val[A_ATOM]].const_val == 0) {\n\t\t\tif (op == BPF_ADD || op == BPF_OR || op == BPF_XOR) {\n\t\t\t\ts->code = BPF_MISC|BPF_TXA;\n\t\t\t\tvstore(s, &val[A_ATOM], val[X_ATOM], alter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (op == BPF_MUL || op == BPF_DIV || op == BPF_MOD ||\n\t\t\t\t op == BPF_AND || op == BPF_LSH || op == BPF_RSH) {\n\t\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t\ts->k = 0;\n\t\t\t\tvstore(s, &val[A_ATOM], K(s->k), alter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (op == BPF_NEG) {\n\t\t\t\ts->code = NOP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], val[X_ATOM]);\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TXA:\n\t\tvstore(s, &val[A_ATOM], val[X_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_MEM:\n\t\tv = val[s->k];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\ts->k = opt_state->vmap[v].const_val;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t\topt_state->done = 0;\n\t\t}\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TAX:\n\t\tvstore(s, &val[X_ATOM], val[A_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MEM:\n\t\tv = val[s->k];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LDX|BPF_IMM;\n\t\t\ts->k = opt_state->vmap[v].const_val;\n\t\t\t/*\n\t\t\t * XXX - optimizer loop detection.\n\t\t\t */\n\t\t\topt_state->non_branch_movement_performed = 1;\n\t\t\topt_state->done = 0;\n\t\t}\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_ST:\n\t\tvstore(s, &val[s->k], val[A_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_STX:\n\t\tvstore(s, &val[s->k], val[X_ATOM], alter);\n\t\tbreak;\n\t}\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Do a depth first search on the flow graph, numbering the\n * the basic blocks, and entering them into the 'blocks' array.`\n */\n", "func_signal": "static void\nnumber_blks_r(opt_state_t *opt_state, struct icode *ic, struct block *p)", "code": "{\n\tu_int n;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn;\n\n\tMark(ic, p);\n\tn = opt_state->n_blocks++;\n\tif (opt_state->n_blocks == 0) {\n\t\t/*\n\t\t * Overflow.\n\t\t */\n\t\topt_error(opt_state, \"filter is too complex to optimize\");\n\t}\n\tp->id = n;\n\topt_state->blocks[n] = p;\n\n\tnumber_blks_r(opt_state, ic, JT(p));\n\tnumber_blks_r(opt_state, ic, JF(p));\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * For iconv_to_fconv() errors.\n */\n", "func_signal": "static void PCAP_NORETURN\nconv_error(conv_state_t *conv_state, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t(void)vsnprintf(conv_state->errbuf,\n\t    PCAP_ERRBUF_SIZE, fmt, ap);\n\tva_end(ap);\n\tlongjmp(conv_state->top_ctx, 1);\n\t/* NOTREACHED */\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * For optimizer errors.\n */\n", "func_signal": "static void PCAP_NORETURN\nopt_error(opt_state_t *opt_state, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\n\tif (opt_state->errbuf != NULL) {\n\t\tva_start(ap, fmt);\n\t\t(void)vsnprintf(opt_state->errbuf,\n\t\t    PCAP_ERRBUF_SIZE, fmt, ap);\n\t\tva_end(ap);\n\t}\n\tlongjmp(opt_state->top_ctx, 1);\n\t/* NOTREACHED */\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Find dominator relationships.\n * Assumes graph has been leveled.\n */\n", "func_signal": "static void\nfind_dom(opt_state_t *opt_state, struct block *root)", "code": "{\n\tu_int i;\n\tint level;\n\tstruct block *b;\n\tbpf_u_int32 *x;\n\n\t/*\n\t * Initialize sets to contain all nodes.\n\t */\n\tx = opt_state->all_dom_sets;\n\t/*\n\t * In opt_init(), we've made sure the product doesn't overflow.\n\t */\n\ti = opt_state->n_blocks * opt_state->nodewords;\n\twhile (i != 0) {\n\t\t--i;\n\t\t*x++ = 0xFFFFFFFFU;\n\t}\n\t/* Root starts off empty. */\n\tfor (i = opt_state->nodewords; i != 0;) {\n\t\t--i;\n\t\troot->dom[i] = 0;\n\t}\n\n\t/* root->level is the highest level no found. */\n\tfor (level = root->level; level >= 0; --level) {\n\t\tfor (b = opt_state->levels[level]; b; b = b->link) {\n\t\t\tSET_INSERT(b->dom, b->id);\n\t\t\tif (JT(b) == 0)\n\t\t\t\tcontinue;\n\t\t\tSET_INTERSECT(JT(b)->dom, b->dom, opt_state->nodewords);\n\t\t\tSET_INTERSECT(JF(b)->dom, b->dom, opt_state->nodewords);\n\t\t}\n\t}\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * None of the above.\n * Use a perfect-hash-function-based function.\n */\n", "func_signal": "static u_int\nlowest_set_bit(int mask)", "code": "{\n\tunsigned int v = (unsigned int)mask;\n\n\tstatic const u_int MultiplyDeBruijnBitPosition[32] = {\n\t\t0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n\t\t31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9\n\t};\n\n\t/*\n\t * We strip off all but the lowermost set bit (v & ~v),\n\t * and perform a minimal perfect hash on it to look up the\n\t * number of low-order zero bits in a table.\n\t *\n\t * See:\n\t *\n\t *\thttp://7ooo.mooo.com/text/ComputingTrailingZerosHOWTO.pdf\n\t *\n\t *\thttp://supertech.csail.mit.edu/papers/debruijn.pdf\n\t */\n\treturn (MultiplyDeBruijnBitPosition[((v & -v) * 0x077CB531U) >> 27]);\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Because we really don't have an IR, this stuff is a little messy.\n *\n * This routine looks in the table of existing value number for a value\n * with generated from an operation with the specified opcode and\n * the specified values.  If it finds it, it returns its value number,\n * otherwise it makes a new entry in the table and returns the\n * value number of that entry.\n */\n", "func_signal": "static bpf_u_int32\nF(opt_state_t *opt_state, int code, bpf_u_int32 v0, bpf_u_int32 v1)", "code": "{\n\tu_int hash;\n\tbpf_u_int32 val;\n\tstruct valnode *p;\n\n\thash = (u_int)code ^ (v0 << 4) ^ (v1 << 8);\n\thash %= MODULUS;\n\n\tfor (p = opt_state->hashtbl[hash]; p; p = p->next)\n\t\tif (p->code == code && p->v0 == v0 && p->v1 == v1)\n\t\t\treturn p->val;\n\n\t/*\n\t * Not found.  Allocate a new value, and assign it a new\n\t * value number.\n\t *\n\t * opt_state->curval starts out as 0, which means VAL_UNKNOWN; we\n\t * increment it before using it as the new value number, which\n\t * means we never assign VAL_UNKNOWN.\n\t *\n\t * XXX - unless we overflow, but we probably won't have 2^32-1\n\t * values; we treat 32 bits as effectively infinite.\n\t */\n\tval = ++opt_state->curval;\n\tif (BPF_MODE(code) == BPF_IMM &&\n\t    (BPF_CLASS(code) == BPF_LD || BPF_CLASS(code) == BPF_LDX)) {\n\t\topt_state->vmap[val].const_val = v0;\n\t\topt_state->vmap[val].is_const = 1;\n\t}\n\tp = opt_state->next_vnode++;\n\tp->val = val;\n\tp->code = code;\n\tp->v0 = v0;\n\tp->v1 = v1;\n\tp->next = opt_state->hashtbl[hash];\n\topt_state->hashtbl[hash] = p;\n\n\treturn val;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * True iff the two stmt lists load the same value from the packet into\n * the accumulator.\n */\n", "func_signal": "static int\neq_slist(struct slist *x, struct slist *y)", "code": "{\n\tfor (;;) {\n\t\twhile (x && x->s.code == NOP)\n\t\t\tx = x->next;\n\t\twhile (y && y->s.code == NOP)\n\t\t\ty = y->next;\n\t\tif (x == 0)\n\t\t\treturn y == 0;\n\t\tif (y == 0)\n\t\t\treturn x == 0;\n\t\tif (x->s.code != y->s.code || x->s.k != y->s.k)\n\t\t\treturn 0;\n\t\tx = x->next;\n\t\ty = y->next;\n\t}\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Return the register number that is used by s.\n *\n * Returns ATOM_A if A is used, ATOM_X if X is used, AX_ATOM if both A and X\n * are used, the scratch memory location's number if a scratch memory\n * location is used (e.g., 0 for M[0]), or -1 if none of those are used.\n *\n * The implementation should probably change to an array access.\n */\n", "func_signal": "static int\natomuse(struct stmt *s)", "code": "{\n\tregister int c = s->code;\n\n\tif (c == NOP)\n\t\treturn -1;\n\n\tswitch (BPF_CLASS(c)) {\n\n\tcase BPF_RET:\n\t\treturn (BPF_RVAL(c) == BPF_A) ? A_ATOM :\n\t\t\t(BPF_RVAL(c) == BPF_X) ? X_ATOM : -1;\n\n\tcase BPF_LD:\n\tcase BPF_LDX:\n\t\t/*\n\t\t * As there are fewer than 2^31 memory locations,\n\t\t * s->k should be convertible to int without problems.\n\t\t */\n\t\treturn (BPF_MODE(c) == BPF_IND) ? X_ATOM :\n\t\t\t(BPF_MODE(c) == BPF_MEM) ? (int)s->k : -1;\n\n\tcase BPF_ST:\n\t\treturn A_ATOM;\n\n\tcase BPF_STX:\n\t\treturn X_ATOM;\n\n\tcase BPF_JMP:\n\tcase BPF_ALU:\n\t\tif (BPF_SRC(c) == BPF_X)\n\t\t\treturn AX_ATOM;\n\t\treturn A_ATOM;\n\n\tcase BPF_MISC:\n\t\treturn BPF_MISCOP(c) == BPF_TXA ? X_ATOM : A_ATOM;\n\t}\n\tabort();\n\t/* NOTREACHED */\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Given a block that is the successor of an edge, and an edge that\n * dominates that edge, return either a pointer to a child of that\n * block (a block to which that block jumps) if that block is a\n * candidate to replace the successor of the latter edge or NULL\n * if neither of the children of the first block are candidates.\n */\n", "func_signal": "static struct block *\nfold_edge(struct block *child, struct edge *ep)", "code": "{\n\tint sense;\n\tbpf_u_int32 aval0, aval1, oval0, oval1;\n\tint code = ep->code;\n\n\tif (code < 0) {\n\t\t/*\n\t\t * This edge is a \"branch if false\" edge.\n\t\t */\n\t\tcode = -code;\n\t\tsense = 0;\n\t} else {\n\t\t/*\n\t\t * This edge is a \"branch if true\" edge.\n\t\t */\n\t\tsense = 1;\n\t}\n\n\t/*\n\t * If the opcode for the branch at the end of the block we\n\t * were handed isn't the same as the opcode for the branch\n\t * to which the edge we were handed corresponds, the tests\n\t * for those branches aren't testing the same conditions,\n\t * so the blocks to which the first block branches aren't\n\t * candidates to replace the successor of the edge.\n\t */\n\tif (child->s.code != code)\n\t\treturn 0;\n\n\taval0 = child->val[A_ATOM];\n\toval0 = child->oval;\n\taval1 = ep->pred->val[A_ATOM];\n\toval1 = ep->pred->oval;\n\n\t/*\n\t * If the A register value on exit from the successor block\n\t * isn't the same as the A register value on exit from the\n\t * predecessor of the edge, the blocks to which the first\n\t * block branches aren't candidates to replace the successor\n\t * of the edge.\n\t */\n\tif (aval0 != aval1)\n\t\treturn 0;\n\n\tif (oval0 == oval1)\n\t\t/*\n\t\t * The operands of the branch instructions are\n\t\t * identical, so the branches are testing the\n\t\t * same condition, and the result is true if a true\n\t\t * branch was taken to get here, otherwise false.\n\t\t */\n\t\treturn sense ? JT(child) : JF(child);\n\n\tif (sense && code == (BPF_JMP|BPF_JEQ|BPF_K))\n\t\t/*\n\t\t * At this point, we only know the comparison if we\n\t\t * came down the true branch, and it was an equality\n\t\t * comparison with a constant.\n\t\t *\n\t\t * I.e., if we came down the true branch, and the branch\n\t\t * was an equality comparison with a constant, we know the\n\t\t * accumulator contains that constant.  If we came down\n\t\t * the false branch, or the comparison wasn't with a\n\t\t * constant, we don't know what was in the accumulator.\n\t\t *\n\t\t * We rely on the fact that distinct constants have distinct\n\t\t * value numbers.\n\t\t */\n\t\treturn JF(child);\n\n\treturn 0;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Optimize the filter code in its dag representation.\n * Return 0 on success, -1 on error.\n */\n", "func_signal": "int\nbpf_optimize(struct icode *ic, char *errbuf)", "code": "{\n\topt_state_t opt_state;\n\n\tmemset(&opt_state, 0, sizeof(opt_state));\n\topt_state.errbuf = errbuf;\n\topt_state.non_branch_movement_performed = 0;\n\tif (setjmp(opt_state.top_ctx)) {\n\t\topt_cleanup(&opt_state);\n\t\treturn -1;\n\t}\n\topt_init(&opt_state, ic);\n\topt_loop(&opt_state, ic, 0);\n\topt_loop(&opt_state, ic, 1);\n\tintern_blocks(&opt_state, ic);\n#ifdef BDEBUG\n\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\tprintf(\"after intern_blocks()\\n\");\n\t\topt_dump(&opt_state, ic);\n\t}\n#endif\n\topt_root(&ic->root);\n#ifdef BDEBUG\n\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\tprintf(\"after opt_root()\\n\");\n\t\topt_dump(&opt_state, ic);\n\t}\n#endif\n\topt_cleanup(&opt_state);\n\treturn 0;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Return the number of stmts in 's'.\n */\n", "func_signal": "static u_int\nslength(struct slist *s)", "code": "{\n\tu_int n = 0;\n\n\tfor (; s; s = s->next)\n\t\tif (s->s.code != NOP)\n\t\t\t++n;\n\treturn n;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Do constant-folding on binary operators.\n * (Unary operators are handled elsewhere.)\n */\n", "func_signal": "static void\nfold_op(opt_state_t *opt_state, struct stmt *s, bpf_u_int32 v0, bpf_u_int32 v1)", "code": "{\n\tbpf_u_int32 a, b;\n\n\ta = opt_state->vmap[v0].const_val;\n\tb = opt_state->vmap[v1].const_val;\n\n\tswitch (BPF_OP(s->code)) {\n\tcase BPF_ADD:\n\t\ta += b;\n\t\tbreak;\n\n\tcase BPF_SUB:\n\t\ta -= b;\n\t\tbreak;\n\n\tcase BPF_MUL:\n\t\ta *= b;\n\t\tbreak;\n\n\tcase BPF_DIV:\n\t\tif (b == 0)\n\t\t\topt_error(opt_state, \"division by zero\");\n\t\ta /= b;\n\t\tbreak;\n\n\tcase BPF_MOD:\n\t\tif (b == 0)\n\t\t\topt_error(opt_state, \"modulus by zero\");\n\t\ta %= b;\n\t\tbreak;\n\n\tcase BPF_AND:\n\t\ta &= b;\n\t\tbreak;\n\n\tcase BPF_OR:\n\t\ta |= b;\n\t\tbreak;\n\n\tcase BPF_XOR:\n\t\ta ^= b;\n\t\tbreak;\n\n\tcase BPF_LSH:\n\t\t/*\n\t\t * A left shift of more than the width of the type\n\t\t * is undefined in C; we'll just treat it as shifting\n\t\t * all the bits out.\n\t\t *\n\t\t * XXX - the BPF interpreter doesn't check for this,\n\t\t * so its behavior is dependent on the behavior of\n\t\t * the processor on which it's running.  There are\n\t\t * processors on which it shifts all the bits out\n\t\t * and processors on which it does no shift.\n\t\t */\n\t\tif (b < 32)\n\t\t\ta <<= b;\n\t\telse\n\t\t\ta = 0;\n\t\tbreak;\n\n\tcase BPF_RSH:\n\t\t/*\n\t\t * A right shift of more than the width of the type\n\t\t * is undefined in C; we'll just treat it as shifting\n\t\t * all the bits out.\n\t\t *\n\t\t * XXX - the BPF interpreter doesn't check for this,\n\t\t * so its behavior is dependent on the behavior of\n\t\t * the processor on which it's running.  There are\n\t\t * processors on which it shifts all the bits out\n\t\t * and processors on which it does no shift.\n\t\t */\n\t\tif (b < 32)\n\t\t\ta >>= b;\n\t\telse\n\t\t\ta = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\ts->k = a;\n\ts->code = BPF_LD|BPF_IMM;\n\t/*\n\t * XXX - optimizer loop detection.\n\t */\n\topt_state->non_branch_movement_performed = 1;\n\topt_state->done = 0;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Returns true if successful.  Returns false if a branch has\n * an offset that is too large.  If so, we have marked that\n * branch so that on a subsequent iteration, it will be treated\n * properly.\n */\n", "func_signal": "static int\nconvert_code_r(conv_state_t *conv_state, struct icode *ic, struct block *p)", "code": "{\n\tstruct bpf_insn *dst;\n\tstruct slist *src;\n\tu_int slen;\n\tu_int off;\n\tstruct slist **offset = NULL;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn (1);\n\tMark(ic, p);\n\n\tif (convert_code_r(conv_state, ic, JF(p)) == 0)\n\t\treturn (0);\n\tif (convert_code_r(conv_state, ic, JT(p)) == 0)\n\t\treturn (0);\n\n\tslen = slength(p->stmts);\n\tdst = conv_state->ftail -= (slen + 1 + p->longjt + p->longjf);\n\t\t/* inflate length by any extra jumps */\n\n\tp->offset = (int)(dst - conv_state->fstart);\n\n\t/* generate offset[] for convenience  */\n\tif (slen) {\n\t\toffset = (struct slist **)calloc(slen, sizeof(struct slist *));\n\t\tif (!offset) {\n\t\t\tconv_error(conv_state, \"not enough core\");\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t}\n\tsrc = p->stmts;\n\tfor (off = 0; off < slen && src; off++) {\n#if 0\n\t\tprintf(\"off=%d src=%x\\n\", off, src);\n#endif\n\t\toffset[off] = src;\n\t\tsrc = src->next;\n\t}\n\n\toff = 0;\n\tfor (src = p->stmts; src; src = src->next) {\n\t\tif (src->s.code == NOP)\n\t\t\tcontinue;\n\t\tdst->code = (u_short)src->s.code;\n\t\tdst->k = src->s.k;\n\n\t\t/* fill block-local relative jump */\n\t\tif (BPF_CLASS(src->s.code) != BPF_JMP || src->s.code == (BPF_JMP|BPF_JA)) {\n#if 0\n\t\t\tif (src->s.jt || src->s.jf) {\n\t\t\t\tfree(offset);\n\t\t\t\tconv_error(conv_state, \"illegal jmp destination\");\n\t\t\t\t/*NOTREACHED*/\n\t\t\t}\n#endif\n\t\t\tgoto filled;\n\t\t}\n\t\tif (off == slen - 2)\t/*???*/\n\t\t\tgoto filled;\n\n\t    {\n\t\tu_int i;\n\t\tint jt, jf;\n\t\tconst char ljerr[] = \"%s for block-local relative jump: off=%d\";\n\n#if 0\n\t\tprintf(\"code=%x off=%d %x %x\\n\", src->s.code,\n\t\t\toff, src->s.jt, src->s.jf);\n#endif\n\n\t\tif (!src->s.jt || !src->s.jf) {\n\t\t\tfree(offset);\n\t\t\tconv_error(conv_state, ljerr, \"no jmp destination\", off);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\n\t\tjt = jf = 0;\n\t\tfor (i = 0; i < slen; i++) {\n\t\t\tif (offset[i] == src->s.jt) {\n\t\t\t\tif (jt) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"multiple matches\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\n\t\t\t\tif (i - off - 1 >= 256) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"out-of-range jump\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tdst->jt = (u_char)(i - off - 1);\n\t\t\t\tjt++;\n\t\t\t}\n\t\t\tif (offset[i] == src->s.jf) {\n\t\t\t\tif (jf) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"multiple matches\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tif (i - off - 1 >= 256) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"out-of-range jump\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tdst->jf = (u_char)(i - off - 1);\n\t\t\t\tjf++;\n\t\t\t}\n\t\t}\n\t\tif (!jt || !jf) {\n\t\t\tfree(offset);\n\t\t\tconv_error(conv_state, ljerr, \"no destination found\", off);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t    }\nfilled:\n\t\t++dst;\n\t\t++off;\n\t}\n\tif (offset)\n\t\tfree(offset);\n\n#ifdef BDEBUG\n\tif (dst - conv_state->fstart < NBIDS)\n\t\tbids[dst - conv_state->fstart] = p->id + 1;\n#endif\n\tdst->code = (u_short)p->s.code;\n\tdst->k = p->s.k;\n\tif (JT(p)) {\n\t\t/* number of extra jumps inserted */\n\t\tu_char extrajmps = 0;\n\t\toff = JT(p)->offset - (p->offset + slen) - 1;\n\t\tif (off >= 256) {\n\t\t    /* offset too large for branch, must add a jump */\n\t\t    if (p->longjt == 0) {\n\t\t\t/* mark this instruction and retry */\n\t\t\tp->longjt++;\n\t\t\treturn(0);\n\t\t    }\n\t\t    dst->jt = extrajmps;\n\t\t    extrajmps++;\n\t\t    dst[extrajmps].code = BPF_JMP|BPF_JA;\n\t\t    dst[extrajmps].k = off - extrajmps;\n\t\t}\n\t\telse\n\t\t    dst->jt = (u_char)off;\n\t\toff = JF(p)->offset - (p->offset + slen) - 1;\n\t\tif (off >= 256) {\n\t\t    /* offset too large for branch, must add a jump */\n\t\t    if (p->longjf == 0) {\n\t\t\t/* mark this instruction and retry */\n\t\t\tp->longjf++;\n\t\t\treturn(0);\n\t\t    }\n\t\t    /* branch if F to following jump */\n\t\t    /* if two jumps are inserted, F goes to second one */\n\t\t    dst->jf = extrajmps;\n\t\t    extrajmps++;\n\t\t    dst[extrajmps].code = BPF_JMP|BPF_JA;\n\t\t    dst[extrajmps].k = off - extrajmps;\n\t\t}\n\t\telse\n\t\t    dst->jf = (u_char)off;\n\t}\n\treturn (1);\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Return the number of nodes reachable by 'p'.\n * All nodes should be initially unmarked.\n */\n", "func_signal": "static int\ncount_blocks(struct icode *ic, struct block *p)", "code": "{\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn 0;\n\tMark(ic, p);\n\treturn count_blocks(ic, JT(p)) + count_blocks(ic, JF(p)) + 1;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Return true if any register that is used on exit from 'succ', has\n * an exit value that is different from the corresponding exit value\n * from 'b'.\n */\n", "func_signal": "static int\nuse_conflict(struct block *b, struct block *succ)", "code": "{\n\tint atom;\n\tatomset use = succ->out_use;\n\n\tif (use == 0)\n\t\treturn 0;\n\n\tfor (atom = 0; atom < N_ATOMS; ++atom)\n\t\tif (ATOMELEM(use, atom))\n\t\t\tif (b->val[atom] != succ->val[atom])\n\t\t\t\treturn 1;\n\treturn 0;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * XXX - is this, and and_pullup(), what's described in section 6.1.2\n * \"Predicate Assertion Propagation\" in the BPF+ paper?\n *\n * Note that this looks at block dominators, not edge dominators.\n * Don't think so.\n *\n * \"A or B\" compiles into\n *\n *          A\n *       t / \\ f\n *        /   B\n *       / t / \\ f\n *      \\   /\n *       \\ /\n *        X\n *\n *\n */\n", "func_signal": "static void\nor_pullup(opt_state_t *opt_state, struct block *b)", "code": "{\n\tbpf_u_int32 val;\n\tint at_top;\n\tstruct block *pull;\n\tstruct block **diffp, **samep;\n\tstruct edge *ep;\n\n\tep = b->in_edges;\n\tif (ep == 0)\n\t\treturn;\n\n\t/*\n\t * Make sure each predecessor loads the same value.\n\t * XXX why?\n\t */\n\tval = ep->pred->val[A_ATOM];\n\tfor (ep = ep->next; ep != 0; ep = ep->next)\n\t\tif (val != ep->pred->val[A_ATOM])\n\t\t\treturn;\n\n\t/*\n\t * For the first edge in the list of edges coming into this block,\n\t * see whether the predecessor of that edge comes here via a true\n\t * branch or a false branch.\n\t */\n\tif (JT(b->in_edges->pred) == b)\n\t\tdiffp = &JT(b->in_edges->pred);\t/* jt */\n\telse\n\t\tdiffp = &JF(b->in_edges->pred);\t/* jf */\n\n\t/*\n\t * diffp is a pointer to a pointer to the block.\n\t *\n\t * Go down the false chain looking as far as you can,\n\t * making sure that each jump-compare is doing the\n\t * same as the original block.\n\t *\n\t * If you reach the bottom before you reach a\n\t * different jump-compare, just exit.  There's nothing\n\t * to do here.  XXX - no, this version is checking for\n\t * the value leaving the block; that's from the BPF+\n\t * pullup routine.\n\t */\n\tat_top = 1;\n\tfor (;;) {\n\t\t/*\n\t\t * Done if that's not going anywhere XXX\n\t\t */\n\t\tif (*diffp == 0)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Done if that predecessor blah blah blah isn't\n\t\t * going the same place we're going XXX\n\t\t *\n\t\t * Does the true edge of this block point to the same\n\t\t * location as the true edge of b?\n\t\t */\n\t\tif (JT(*diffp) != JT(b))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Done if this node isn't a dominator of that\n\t\t * node blah blah blah XXX\n\t\t *\n\t\t * Does b dominate diffp?\n\t\t */\n\t\tif (!SET_MEMBER((*diffp)->dom, b->id))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Break out of the loop if that node's value of A\n\t\t * isn't the value of A above XXX\n\t\t */\n\t\tif ((*diffp)->val[A_ATOM] != val)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get the JF for that node XXX\n\t\t * Go down the false path.\n\t\t */\n\t\tdiffp = &JF(*diffp);\n\t\tat_top = 0;\n\t}\n\n\t/*\n\t * Now that we've found a different jump-compare in a chain\n\t * below b, search further down until we find another\n\t * jump-compare that looks at the original value.  This\n\t * jump-compare should get pulled up.  XXX again we're\n\t * comparing values not jump-compares.\n\t */\n\tsamep = &JF(*diffp);\n\tfor (;;) {\n\t\t/*\n\t\t * Done if that's not going anywhere XXX\n\t\t */\n\t\tif (*samep == 0)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Done if that predecessor blah blah blah isn't\n\t\t * going the same place we're going XXX\n\t\t */\n\t\tif (JT(*samep) != JT(b))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Done if this node isn't a dominator of that\n\t\t * node blah blah blah XXX\n\t\t *\n\t\t * Does b dominate samep?\n\t\t */\n\t\tif (!SET_MEMBER((*samep)->dom, b->id))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Break out of the loop if that node's value of A\n\t\t * is the value of A above XXX\n\t\t */\n\t\tif ((*samep)->val[A_ATOM] == val)\n\t\t\tbreak;\n\n\t\t/* XXX Need to check that there are no data dependencies\n\t\t   between dp0 and dp1.  Currently, the code generator\n\t\t   will not produce such dependencies. */\n\t\tsamep = &JF(*samep);\n\t}\n#ifdef notdef\n\t/* XXX This doesn't cover everything. */\n\tfor (i = 0; i < N_ATOMS; ++i)\n\t\tif ((*samep)->val[i] != pred->val[i])\n\t\t\treturn;\n#endif\n\t/* Pull up the node. */\n\tpull = *samep;\n\t*samep = JF(pull);\n\tJF(pull) = *diffp;\n\n\t/*\n\t * At the top of the chain, each predecessor needs to point at the\n\t * pulled up node.  Inside the chain, there is only one predecessor\n\t * to worry about.\n\t */\n\tif (at_top) {\n\t\tfor (ep = b->in_edges; ep != 0; ep = ep->next) {\n\t\t\tif (JT(ep->pred) == b)\n\t\t\t\tJT(ep->pred) = pull;\n\t\t\telse\n\t\t\t\tJF(ep->pred) = pull;\n\t\t}\n\t}\n\telse\n\t\t*diffp = pull;\n\n\t/*\n\t * XXX - this is one of the operations that happens when the\n\t * optimizer gets into one of those infinite loops.\n\t */\n\topt_state->done = 0;\n}", "path": "libpcap/optimize.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "the-tcpdump-group/libpcap", "stars": 2474, "license": "other", "language": "c", "size": 18027}
{"docstring": "/*\n * Module initialization routine for Huffman entropy decoding.\n */\n", "func_signal": "GLOBAL(void)\njinit_huff_decoder (j_decompress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy;\n  int i;\n\n  entropy = (huff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(huff_entropy_decoder));\n  cinfo->entropy = &entropy->pub;\n  entropy->pub.start_pass = start_pass_huff_decoder;\n  entropy->pub.finish_pass = finish_pass_huff;\n\n  if (cinfo->progressive_mode) {\n    /* Create progression status table */\n    int *coef_bit_ptr, ci;\n    cinfo->coef_bits = (int (*)[DCTSIZE2])\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  cinfo->num_components*DCTSIZE2*SIZEOF(int));\n    coef_bit_ptr = & cinfo->coef_bits[0][0];\n    for (ci = 0; ci < cinfo->num_components; ci++)\n      for (i = 0; i < DCTSIZE2; i++)\n\t*coef_bit_ptr++ = -1;\n\n    /* Mark derived tables unallocated */\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\n      entropy->derived_tbls[i] = NULL;\n    }\n  } else {\n    /* Mark tables unallocated */\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\n      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;\n    }\n  }\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Finish up at the end of a Huffman-compressed scan.\n */\n", "func_signal": "METHODDEF(void)\nfinish_pass_huff (j_decompress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n\n  /* Throw away any unused bits remaining in bit buffer; */\n  /* include any full bytes in next_marker's count of discarded bytes */\n  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;\n  entropy->bitstate.bits_left = 0;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles Adobe-style CMYK->YCCK conversion,\n * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same\n * conversion as above, while passing K (black) unchanged.\n * We assume rgb_ycc_start has been called.\n */\n", "func_signal": "METHODDEF(void)\ncmyk_ycck_convert (j_compress_ptr cinfo,\n\t\t   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,\n\t\t   JDIMENSION output_row, int num_rows)", "code": "{\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\n  register INT32 * ctab = cconvert->rgb_ycc_tab;\n  register int r, g, b;\n  register JSAMPROW inptr;\n  register JSAMPROW outptr0, outptr1, outptr2, outptr3;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr0 = output_buf[0][output_row];\n    outptr1 = output_buf[1][output_row];\n    outptr2 = output_buf[2][output_row];\n    outptr3 = output_buf[3][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      r = MAXJSAMPLE - GETJSAMPLE(inptr[0]);\n      g = MAXJSAMPLE - GETJSAMPLE(inptr[1]);\n      b = MAXJSAMPLE - GETJSAMPLE(inptr[2]);\n      /* K passes through as-is */\n      outptr3[col] = inptr[3];\t/* don't need GETJSAMPLE here */\n      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations\n       * must be too; we do not need an explicit range-limiting operation.\n       * Hence the value being shifted is never negative, and we don't\n       * need the general RIGHT_SHIFT macro.\n       */\n      /* Y */\n      outptr0[col] = (JSAMPLE)\n\t\t((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\n\t\t >> SCALEBITS);\n      /* Cb */\n      outptr1[col] = (JSAMPLE)\n\t\t((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])\n\t\t >> SCALEBITS);\n      /* Cr */\n      outptr2[col] = (JSAMPLE)\n\t\t((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])\n\t\t >> SCALEBITS);\n      inptr += 4;\n    }\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Convert some rows of samples to the JPEG colorspace.\n * [R,G,B] to [R-G,G,B-G] conversion with modulo calculation\n * (forward reversible color transform).\n * This can be seen as an adaption of the general RGB->YCbCr\n * conversion equation with Kr = Kb = 0, while replacing the\n * normalization by modulo calculation.\n */\n", "func_signal": "METHODDEF(void)\nrgb_rgb1_convert (j_compress_ptr cinfo,\n\t\t  JSAMPARRAY input_buf, JSAMPIMAGE output_buf,\n\t\t  JDIMENSION output_row, int num_rows)", "code": "{\n  register int r, g, b;\n  register JSAMPROW inptr;\n  register JSAMPROW outptr0, outptr1, outptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr0 = output_buf[0][output_row];\n    outptr1 = output_buf[1][output_row];\n    outptr2 = output_buf[2][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      r = GETJSAMPLE(inptr[RGB_RED]);\n      g = GETJSAMPLE(inptr[RGB_GREEN]);\n      b = GETJSAMPLE(inptr[RGB_BLUE]);\n      /* Assume that MAXJSAMPLE+1 is a power of 2, so that the MOD\n       * (modulo) operator is equivalent to the bitmask operator AND.\n       */\n      outptr0[col] = (JSAMPLE) ((r - g + CENTERJSAMPLE) & MAXJSAMPLE);\n      outptr1[col] = (JSAMPLE) g;\n      outptr2[col] = (JSAMPLE) ((b - g + CENTERJSAMPLE) & MAXJSAMPLE);\n      inptr += RGB_PIXELSIZE;\n    }\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Check for a restart marker & resynchronize decoder.\n * Returns FALSE if must suspend.\n */\n", "func_signal": "LOCAL(boolean)\nprocess_restart (j_decompress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  int ci;\n\n  finish_pass_huff(cinfo);\n\n  /* Advance past the RSTn marker */\n  if (! (*cinfo->marker->read_restart_marker) (cinfo))\n    return FALSE;\n\n  /* Re-initialize DC predictions to 0 */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++)\n    entropy->saved.last_dc_val[ci] = 0;\n  /* Re-init EOB run count, too */\n  entropy->saved.EOBRUN = 0;\n\n  /* Reset restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n\n  /* Reset out-of-data flag, unless read_restart_marker left us smack up\n   * against a marker.  In that case we will end up treating the next data\n   * segment as empty, and we can avoid producing bogus output pixels by\n   * leaving the flag set.\n   */\n  if (cinfo->unread_marker == 0)\n    entropy->insufficient_data = FALSE;\n\n  return TRUE;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles grayscale output with no conversion.\n * The source can be either plain grayscale or YCC (since Y == gray).\n */\n", "func_signal": "METHODDEF(void)\ngrayscale_convert (j_compress_ptr cinfo,\n\t\t   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,\n\t\t   JDIMENSION output_row, int num_rows)", "code": "{\n  int instride = cinfo->input_components;\n  register JSAMPROW inptr;\n  register JSAMPROW outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr = output_buf[0][output_row++];\n    for (col = 0; col < num_cols; col++) {\n      outptr[col] = inptr[0];\t/* don't need GETJSAMPLE() here */\n      inptr += instride;\n    }\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * MCU decoding for DC successive approximation refinement scan.\n * Note: we assume such scans can be multi-component,\n * although the spec is not very clear on the point.\n */\n", "func_signal": "METHODDEF(boolean)\ndecode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{   \n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  int p1, blkn;\n  BITREAD_STATE_VARS;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (! process_restart(cinfo))\n\treturn FALSE;\n  }\n\n  /* Not worth the cycles to check insufficient_data here,\n   * since we will not change the data anyway if we read zeroes.\n   */\n\n  /* Load up working state */\n  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\n\n  p1 = 1 << cinfo->Al;\t\t/* 1 in the bit position being coded */\n\n  /* Outer loop handles each block in the MCU */\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    /* Encoded data is simply the next bit of the two's-complement DC value */\n    CHECK_BIT_BUFFER(br_state, 1, return FALSE);\n    if (GET_BITS(1))\n      MCU_data[blkn][0][0] |= p1;\n    /* Note: since we use |=, repeating the assignment later is safe */\n  }\n\n  /* Completed MCU, so update state */\n  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\n\n  /* Account for restart interval (no-op if not using restarts) */\n  entropy->restarts_to_go--;\n\n  return TRUE;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles RGB->grayscale conversion, which is the same\n * as the RGB->Y portion of RGB->YCbCr.\n * We assume rgb_ycc_start has been called (we only use the Y tables).\n */\n", "func_signal": "METHODDEF(void)\nrgb_gray_convert (j_compress_ptr cinfo,\n\t\t  JSAMPARRAY input_buf, JSAMPIMAGE output_buf,\n\t\t  JDIMENSION output_row, int num_rows)", "code": "{\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\n  register INT32 * ctab = cconvert->rgb_ycc_tab;\n  register int r, g, b;\n  register JSAMPROW inptr;\n  register JSAMPROW outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr = output_buf[0][output_row++];\n    for (col = 0; col < num_cols; col++) {\n      r = GETJSAMPLE(inptr[RGB_RED]);\n      g = GETJSAMPLE(inptr[RGB_GREEN]);\n      b = GETJSAMPLE(inptr[RGB_BLUE]);\n      /* Y */\n      outptr[col] = (JSAMPLE)\n\t\t((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\n\t\t >> SCALEBITS);\n      inptr += RGB_PIXELSIZE;\n    }\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Module initialization routine for input colorspace conversion.\n */\n", "func_signal": "GLOBAL(void)\njinit_color_converter (j_compress_ptr cinfo)", "code": "{\n  my_cconvert_ptr cconvert;\n\n  cconvert = (my_cconvert_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_color_converter));\n  cinfo->cconvert = &cconvert->pub;\n  /* set start_pass to null method until we find out differently */\n  cconvert->pub.start_pass = null_method;\n\n  /* Make sure input_components agrees with in_color_space */\n  switch (cinfo->in_color_space) {\n  case JCS_GRAYSCALE:\n    if (cinfo->input_components != 1)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n\n  case JCS_RGB:\n  case JCS_BG_RGB:\n    if (cinfo->input_components != RGB_PIXELSIZE)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n\n  case JCS_YCbCr:\n  case JCS_BG_YCC:\n    if (cinfo->input_components != 3)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n\n  case JCS_CMYK:\n  case JCS_YCCK:\n    if (cinfo->input_components != 4)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n\n  default:\t\t\t/* JCS_UNKNOWN can be anything */\n    if (cinfo->input_components < 1)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n  }\n\n  /* Support color transform only for RGB colorspaces */\n  if (cinfo->color_transform &&\n      cinfo->jpeg_color_space != JCS_RGB &&\n      cinfo->jpeg_color_space != JCS_BG_RGB)\n    ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n\n  /* Check num_components, set conversion method based on requested space */\n  switch (cinfo->jpeg_color_space) {\n  case JCS_GRAYSCALE:\n    if (cinfo->num_components != 1)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    switch (cinfo->in_color_space) {\n    case JCS_GRAYSCALE:\n    case JCS_YCbCr:\n    case JCS_BG_YCC:\n      cconvert->pub.color_convert = grayscale_convert;\n      break;\n    case JCS_RGB:\n      cconvert->pub.start_pass = rgb_ycc_start;\n      cconvert->pub.color_convert = rgb_gray_convert;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    }\n    break;\n\n  case JCS_RGB:\n  case JCS_BG_RGB:\n    if (cinfo->num_components != 3)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    if (cinfo->in_color_space == cinfo->jpeg_color_space) {\n      switch (cinfo->color_transform) {\n      case JCT_NONE:\n\tcconvert->pub.color_convert = rgb_convert;\n\tbreak;\n      case JCT_SUBTRACT_GREEN:\n\tcconvert->pub.color_convert = rgb_rgb1_convert;\n\tbreak;\n      default:\n\tERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n      }\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_YCbCr:\n    if (cinfo->num_components != 3)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    switch (cinfo->in_color_space) {\n    case JCS_RGB:\n      cconvert->pub.start_pass = rgb_ycc_start;\n      cconvert->pub.color_convert = rgb_ycc_convert;\n      break;\n    case JCS_YCbCr:\n      cconvert->pub.color_convert = null_convert;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    }\n    break;\n\n  case JCS_BG_YCC:\n    if (cinfo->num_components != 3)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    switch (cinfo->in_color_space) {\n    case JCS_RGB:\n      /* For conversion from normal RGB input to BG_YCC representation,\n       * the Cb/Cr values are first computed as usual, and then\n       * quantized further after DCT processing by a factor of\n       * 2 in reference to the nominal quantization factor.\n       */\n      /* need quantization scale by factor of 2 after DCT */\n      cinfo->comp_info[1].component_needed = TRUE;\n      cinfo->comp_info[2].component_needed = TRUE;\n      /* compute normal YCC first */\n      cconvert->pub.start_pass = rgb_ycc_start;\n      cconvert->pub.color_convert = rgb_ycc_convert;\n      break;\n    case JCS_YCbCr:\n      /* need quantization scale by factor of 2 after DCT */\n      cinfo->comp_info[1].component_needed = TRUE;\n      cinfo->comp_info[2].component_needed = TRUE;\n      /*FALLTHROUGH*/\n    case JCS_BG_YCC:\n      /* Pass through for BG_YCC input */\n      cconvert->pub.color_convert = null_convert;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    }\n    break;\n\n  case JCS_CMYK:\n    if (cinfo->num_components != 4)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    if (cinfo->in_color_space == JCS_CMYK)\n      cconvert->pub.color_convert = null_convert;\n    else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_YCCK:\n    if (cinfo->num_components != 4)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    switch (cinfo->in_color_space) {\n    case JCS_CMYK:\n      cconvert->pub.start_pass = rgb_ycc_start;\n      cconvert->pub.color_convert = cmyk_ycck_convert;\n      break;\n    case JCS_YCCK:\n      cconvert->pub.color_convert = null_convert;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    }\n    break;\n\n  default:\t\t\t/* allow null conversion of JCS_UNKNOWN */\n    if (cinfo->jpeg_color_space != cinfo->in_color_space ||\n\tcinfo->num_components != cinfo->input_components)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    cconvert->pub.color_convert = null_convert;\n    break;\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Decode one MCU's worth of Huffman-compressed coefficients,\n * full-size blocks.\n */\n", "func_signal": "METHODDEF(boolean)\ndecode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  int blkn;\n  BITREAD_STATE_VARS;\n  savable_state state;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (! process_restart(cinfo))\n\treturn FALSE;\n  }\n\n  /* If we've run out of data, just leave the MCU set to zeroes.\n   * This way, we return uniform gray for the remainder of the segment.\n   */\n  if (! entropy->insufficient_data) {\n\n    /* Load up working state */\n    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\n    ASSIGN_STATE(state, entropy->saved);\n\n    /* Outer loop handles each block in the MCU */\n\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n      JBLOCKROW block = MCU_data[blkn];\n      d_derived_tbl * htbl;\n      register int s, k, r;\n      int coef_limit, ci;\n\n      /* Decode a single block's worth of coefficients */\n\n      /* Section F.2.2.1: decode the DC coefficient difference */\n      htbl = entropy->dc_cur_tbls[blkn];\n      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);\n\n      htbl = entropy->ac_cur_tbls[blkn];\n      k = 1;\n      coef_limit = entropy->coef_limit[blkn];\n      if (coef_limit) {\n\t/* Convert DC difference to actual value, update last_dc_val */\n\tif (s) {\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t  r = GET_BITS(s);\n\t  s = HUFF_EXTEND(r, s);\n\t}\n\tci = cinfo->MCU_membership[blkn];\n\ts += state.last_dc_val[ci];\n\tstate.last_dc_val[ci] = s;\n\t/* Output the DC coefficient */\n\t(*block)[0] = (JCOEF) s;\n\n\t/* Section F.2.2.2: decode the AC coefficients */\n\t/* Since zeroes are skipped, output area must be cleared beforehand */\n\tfor (; k < coef_limit; k++) {\n\t  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);\n\n\t  r = s >> 4;\n\t  s &= 15;\n\n\t  if (s) {\n\t    k += r;\n\t    CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t    r = GET_BITS(s);\n\t    s = HUFF_EXTEND(r, s);\n\t    /* Output coefficient in natural (dezigzagged) order.\n\t     * Note: the extra entries in jpeg_natural_order[] will save us\n\t     * if k >= DCTSIZE2, which could happen if the data is corrupted.\n\t     */\n\t    (*block)[jpeg_natural_order[k]] = (JCOEF) s;\n\t  } else {\n\t    if (r != 15)\n\t      goto EndOfBlock;\n\t    k += 15;\n\t  }\n\t}\n      } else {\n\tif (s) {\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t  DROP_BITS(s);\n\t}\n      }\n\n      /* Section F.2.2.2: decode the AC coefficients */\n      /* In this path we just discard the values */\n      for (; k < DCTSIZE2; k++) {\n\tHUFF_DECODE(s, br_state, htbl, return FALSE, label3);\n\n\tr = s >> 4;\n\ts &= 15;\n\n\tif (s) {\n\t  k += r;\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t  DROP_BITS(s);\n\t} else {\n\t  if (r != 15)\n\t    break;\n\t  k += 15;\n\t}\n      }\n\n      EndOfBlock: ;\n    }\n\n    /* Completed MCU, so update state */\n    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\n    ASSIGN_STATE(entropy->saved, state);\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  entropy->restarts_to_go--;\n\n  return TRUE;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * MCU decoding for AC successive approximation refinement scan.\n */\n", "func_signal": "METHODDEF(boolean)\ndecode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{   \n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  register int s, k, r;\n  unsigned int EOBRUN;\n  int Se, p1, m1;\n  const int * natural_order;\n  JBLOCKROW block;\n  JCOEFPTR thiscoef;\n  BITREAD_STATE_VARS;\n  d_derived_tbl * tbl;\n  int num_newnz;\n  int newnz_pos[DCTSIZE2];\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (! process_restart(cinfo))\n\treturn FALSE;\n  }\n\n  /* If we've run out of data, don't modify the MCU.\n   */\n  if (! entropy->insufficient_data) {\n\n    Se = cinfo->Se;\n    p1 = 1 << cinfo->Al;\t/* 1 in the bit position being coded */\n    m1 = (-1) << cinfo->Al;\t/* -1 in the bit position being coded */\n    natural_order = cinfo->natural_order;\n\n    /* Load up working state */\n    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\n    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */\n\n    /* There is always only one block per MCU */\n    block = MCU_data[0];\n    tbl = entropy->ac_derived_tbl;\n\n    /* If we are forced to suspend, we must undo the assignments to any newly\n     * nonzero coefficients in the block, because otherwise we'd get confused\n     * next time about which coefficients were already nonzero.\n     * But we need not undo addition of bits to already-nonzero coefficients;\n     * instead, we can test the current bit to see if we already did it.\n     */\n    num_newnz = 0;\n\n    /* initialize coefficient loop counter to start of band */\n    k = cinfo->Ss;\n\n    if (EOBRUN == 0) {\n      do {\n\tHUFF_DECODE(s, br_state, tbl, goto undoit, label3);\n\tr = s >> 4;\n\ts &= 15;\n\tif (s) {\n\t  if (s != 1)\t\t/* size of new coef should always be 1 */\n\t    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);\n\t  CHECK_BIT_BUFFER(br_state, 1, goto undoit);\n\t  if (GET_BITS(1))\n\t    s = p1;\t\t/* newly nonzero coef is positive */\n\t  else\n\t    s = m1;\t\t/* newly nonzero coef is negative */\n\t} else {\n\t  if (r != 15) {\n\t    EOBRUN = 1 << r;\t/* EOBr, run length is 2^r + appended bits */\n\t    if (r) {\n\t      CHECK_BIT_BUFFER(br_state, r, goto undoit);\n\t      r = GET_BITS(r);\n\t      EOBRUN += r;\n\t    }\n\t    break;\t\t/* rest of block is handled by EOB logic */\n\t  }\n\t  /* note s = 0 for processing ZRL */\n\t}\n\t/* Advance over already-nonzero coefs and r still-zero coefs,\n\t * appending correction bits to the nonzeroes.  A correction bit is 1\n\t * if the absolute value of the coefficient must be increased.\n\t */\n\tdo {\n\t  thiscoef = *block + natural_order[k];\n\t  if (*thiscoef) {\n\t    CHECK_BIT_BUFFER(br_state, 1, goto undoit);\n\t    if (GET_BITS(1)) {\n\t      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */\n\t\tif (*thiscoef >= 0)\n\t\t  *thiscoef += p1;\n\t\telse\n\t\t  *thiscoef += m1;\n\t      }\n\t    }\n\t  } else {\n\t    if (--r < 0)\n\t      break;\t\t/* reached target zero coefficient */\n\t  }\n\t  k++;\n\t} while (k <= Se);\n\tif (s) {\n\t  int pos = natural_order[k];\n\t  /* Output newly nonzero coefficient */\n\t  (*block)[pos] = (JCOEF) s;\n\t  /* Remember its position in case we have to suspend */\n\t  newnz_pos[num_newnz++] = pos;\n\t}\n\tk++;\n      } while (k <= Se);\n    }\n\n    if (EOBRUN) {\n      /* Scan any remaining coefficient positions after the end-of-band\n       * (the last newly nonzero coefficient, if any).  Append a correction\n       * bit to each already-nonzero coefficient.  A correction bit is 1\n       * if the absolute value of the coefficient must be increased.\n       */\n      do {\n\tthiscoef = *block + natural_order[k];\n\tif (*thiscoef) {\n\t  CHECK_BIT_BUFFER(br_state, 1, goto undoit);\n\t  if (GET_BITS(1)) {\n\t    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */\n\t      if (*thiscoef >= 0)\n\t\t*thiscoef += p1;\n\t      else\n\t\t*thiscoef += m1;\n\t    }\n\t  }\n\t}\n\tk++;\n      } while (k <= Se);\n      /* Count one block completed in EOB run */\n      EOBRUN--;\n    }\n\n    /* Completed MCU, so update state */\n    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\n    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  entropy->restarts_to_go--;\n\n  return TRUE;\n\nundoit:\n  /* Re-zero any output coefficients that we made newly nonzero */\n  while (num_newnz)\n    (*block)[newnz_pos[--num_newnz]] = 0;\n\n  return FALSE;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Initialize for a Huffman-compressed scan.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_huff_decoder (j_decompress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  int ci, blkn, tbl, i;\n  jpeg_component_info * compptr;\n\n  if (cinfo->progressive_mode) {\n    /* Validate progressive scan parameters */\n    if (cinfo->Ss == 0) {\n      if (cinfo->Se != 0)\n\tgoto bad;\n    } else {\n      /* need not check Ss/Se < 0 since they came from unsigned bytes */\n      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)\n\tgoto bad;\n      /* AC scans may have only one component */\n      if (cinfo->comps_in_scan != 1)\n\tgoto bad;\n    }\n    if (cinfo->Ah != 0) {\n      /* Successive approximation refinement scan: must have Al = Ah-1. */\n      if (cinfo->Ah-1 != cinfo->Al)\n\tgoto bad;\n    }\n    if (cinfo->Al > 13) {\t/* need not check for < 0 */\n      /* Arguably the maximum Al value should be less than 13 for 8-bit precision,\n       * but the spec doesn't say so, and we try to be liberal about what we\n       * accept.  Note: large Al values could result in out-of-range DC\n       * coefficients during early scans, leading to bizarre displays due to\n       * overflows in the IDCT math.  But we won't crash.\n       */\n      bad:\n      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,\n\t       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);\n    }\n    /* Update progression status, and verify that scan order is legal.\n     * Note that inter-scan inconsistencies are treated as warnings\n     * not fatal errors ... not clear if this is right way to behave.\n     */\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;\n      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];\n      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */\n\tWARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);\n      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {\n\tint expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];\n\tif (cinfo->Ah != expected)\n\t  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);\n\tcoef_bit_ptr[coefi] = cinfo->Al;\n      }\n    }\n\n    /* Select MCU decoding routine */\n    if (cinfo->Ah == 0) {\n      if (cinfo->Ss == 0)\n\tentropy->pub.decode_mcu = decode_mcu_DC_first;\n      else\n\tentropy->pub.decode_mcu = decode_mcu_AC_first;\n    } else {\n      if (cinfo->Ss == 0)\n\tentropy->pub.decode_mcu = decode_mcu_DC_refine;\n      else\n\tentropy->pub.decode_mcu = decode_mcu_AC_refine;\n    }\n\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n      compptr = cinfo->cur_comp_info[ci];\n      /* Make sure requested tables are present, and compute derived tables.\n       * We may build same derived table more than once, but it's not expensive.\n       */\n      if (cinfo->Ss == 0) {\n\tif (cinfo->Ah == 0) {\t/* DC refinement needs no table */\n\t  tbl = compptr->dc_tbl_no;\n\t  jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,\n\t\t\t\t  & entropy->derived_tbls[tbl]);\n\t}\n      } else {\n\ttbl = compptr->ac_tbl_no;\n\tjpeg_make_d_derived_tbl(cinfo, FALSE, tbl,\n\t\t\t\t& entropy->derived_tbls[tbl]);\n\t/* remember the single active table */\n\tentropy->ac_derived_tbl = entropy->derived_tbls[tbl];\n      }\n      /* Initialize DC predictions to 0 */\n      entropy->saved.last_dc_val[ci] = 0;\n    }\n\n    /* Initialize private state variables */\n    entropy->saved.EOBRUN = 0;\n  } else {\n    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.\n     * This ought to be an error condition, but we make it a warning because\n     * there are some baseline files out there with all zeroes in these bytes.\n     */\n    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||\n\t((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&\n\tcinfo->Se != cinfo->lim_Se))\n      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);\n\n    /* Select MCU decoding routine */\n    /* We retain the hard-coded case for full-size blocks.\n     * This is not necessary, but it appears that this version is slightly\n     * more performant in the given implementation.\n     * With an improved implementation we would prefer a single optimized\n     * function.\n     */\n    if (cinfo->lim_Se != DCTSIZE2-1)\n      entropy->pub.decode_mcu = decode_mcu_sub;\n    else\n      entropy->pub.decode_mcu = decode_mcu;\n\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n      compptr = cinfo->cur_comp_info[ci];\n      /* Compute derived values for Huffman tables */\n      /* We may do this more than once for a table, but it's not expensive */\n      tbl = compptr->dc_tbl_no;\n      jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,\n\t\t\t      & entropy->dc_derived_tbls[tbl]);\n      if (cinfo->lim_Se) {\t/* AC needs no table when not present */\n\ttbl = compptr->ac_tbl_no;\n\tjpeg_make_d_derived_tbl(cinfo, FALSE, tbl,\n\t\t\t\t& entropy->ac_derived_tbls[tbl]);\n      }\n      /* Initialize DC predictions to 0 */\n      entropy->saved.last_dc_val[ci] = 0;\n    }\n\n    /* Precalculate decoding info for each block in an MCU of this scan */\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n      ci = cinfo->MCU_membership[blkn];\n      compptr = cinfo->cur_comp_info[ci];\n      /* Precalculate which table to use for each block */\n      entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];\n      entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];\n      /* Decide whether we really care about the coefficient values */\n      if (compptr->component_needed) {\n\tci = compptr->DCT_v_scaled_size;\n\ti = compptr->DCT_h_scaled_size;\n\tswitch (cinfo->lim_Se) {\n\tcase (1*1-1):\n\t  entropy->coef_limit[blkn] = 1;\n\t  break;\n\tcase (2*2-1):\n\t  if (ci <= 0 || ci > 2) ci = 2;\n\t  if (i <= 0 || i > 2) i = 2;\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];\n\t  break;\n\tcase (3*3-1):\n\t  if (ci <= 0 || ci > 3) ci = 3;\n\t  if (i <= 0 || i > 3) i = 3;\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];\n\t  break;\n\tcase (4*4-1):\n\t  if (ci <= 0 || ci > 4) ci = 4;\n\t  if (i <= 0 || i > 4) i = 4;\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order4[ci - 1][i - 1];\n\t  break;\n\tcase (5*5-1):\n\t  if (ci <= 0 || ci > 5) ci = 5;\n\t  if (i <= 0 || i > 5) i = 5;\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];\n\t  break;\n\tcase (6*6-1):\n\t  if (ci <= 0 || ci > 6) ci = 6;\n\t  if (i <= 0 || i > 6) i = 6;\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];\n\t  break;\n\tcase (7*7-1):\n\t  if (ci <= 0 || ci > 7) ci = 7;\n\t  if (i <= 0 || i > 7) i = 7;\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];\n\t  break;\n\tdefault:\n\t  if (ci <= 0 || ci > 8) ci = 8;\n\t  if (i <= 0 || i > 8) i = 8;\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];\n\t  break;\n\t}\n      } else {\n\tentropy->coef_limit[blkn] = 0;\n      }\n    }\n  }\n\n  /* Initialize bitread state variables */\n  entropy->bitstate.bits_left = 0;\n  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */\n  entropy->insufficient_data = FALSE;\n\n  /* Initialize restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * MCU decoding for DC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n", "func_signal": "METHODDEF(boolean)\ndecode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{   \n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  int Al = cinfo->Al;\n  register int s, r;\n  int blkn, ci;\n  JBLOCKROW block;\n  BITREAD_STATE_VARS;\n  savable_state state;\n  d_derived_tbl * tbl;\n  jpeg_component_info * compptr;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (! process_restart(cinfo))\n\treturn FALSE;\n  }\n\n  /* If we've run out of data, just leave the MCU set to zeroes.\n   * This way, we return uniform gray for the remainder of the segment.\n   */\n  if (! entropy->insufficient_data) {\n\n    /* Load up working state */\n    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\n    ASSIGN_STATE(state, entropy->saved);\n\n    /* Outer loop handles each block in the MCU */\n\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n      block = MCU_data[blkn];\n      ci = cinfo->MCU_membership[blkn];\n      compptr = cinfo->cur_comp_info[ci];\n      tbl = entropy->derived_tbls[compptr->dc_tbl_no];\n\n      /* Decode a single block's worth of coefficients */\n\n      /* Section F.2.2.1: decode the DC coefficient difference */\n      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);\n      if (s) {\n\tCHECK_BIT_BUFFER(br_state, s, return FALSE);\n\tr = GET_BITS(s);\n\ts = HUFF_EXTEND(r, s);\n      }\n\n      /* Convert DC difference to actual value, update last_dc_val */\n      s += state.last_dc_val[ci];\n      state.last_dc_val[ci] = s;\n      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */\n      (*block)[0] = (JCOEF) (s << Al);\n    }\n\n    /* Completed MCU, so update state */\n    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\n    ASSIGN_STATE(entropy->saved, state);\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  entropy->restarts_to_go--;\n\n  return TRUE;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles multi-component colorspaces without conversion.\n * We assume input_components == num_components.\n */\n", "func_signal": "METHODDEF(void)\nnull_convert (j_compress_ptr cinfo,\n\t      JSAMPARRAY input_buf, JSAMPIMAGE output_buf,\n\t      JDIMENSION output_row, int num_rows)", "code": "{\n  int ci;\n  register int nc = cinfo->num_components;\n  register JSAMPROW inptr;\n  register JSAMPROW outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    /* It seems fastest to make a separate pass for each component. */\n    for (ci = 0; ci < nc; ci++) {\n      inptr = input_buf[0] + ci;\n      outptr = output_buf[ci][output_row];\n      for (col = 0; col < num_cols; col++) {\n\t*outptr++ = *inptr;\t/* don't need GETJSAMPLE() here */\n\tinptr += nc;\n      }\n    }\n    input_buf++;\n    output_row++;\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Convert some rows of samples to the JPEG colorspace.\n *\n * Note that we change from the application's interleaved-pixel format\n * to our internal noninterleaved, one-plane-per-component format.\n * The input buffer is therefore three times as wide as the output buffer.\n *\n * A starting row offset is provided only for the output buffer.  The caller\n * can easily adjust the passed input_buf value to accommodate any row\n * offset required on that side.\n */\n", "func_signal": "METHODDEF(void)\nrgb_ycc_convert (j_compress_ptr cinfo,\n\t\t JSAMPARRAY input_buf, JSAMPIMAGE output_buf,\n\t\t JDIMENSION output_row, int num_rows)", "code": "{\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\n  register INT32 * ctab = cconvert->rgb_ycc_tab;\n  register int r, g, b;\n  register JSAMPROW inptr;\n  register JSAMPROW outptr0, outptr1, outptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr0 = output_buf[0][output_row];\n    outptr1 = output_buf[1][output_row];\n    outptr2 = output_buf[2][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      r = GETJSAMPLE(inptr[RGB_RED]);\n      g = GETJSAMPLE(inptr[RGB_GREEN]);\n      b = GETJSAMPLE(inptr[RGB_BLUE]);\n      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations\n       * must be too; we do not need an explicit range-limiting operation.\n       * Hence the value being shifted is never negative, and we don't\n       * need the general RIGHT_SHIFT macro.\n       */\n      /* Y */\n      outptr0[col] = (JSAMPLE)\n\t\t((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\n\t\t >> SCALEBITS);\n      /* Cb */\n      outptr1[col] = (JSAMPLE)\n\t\t((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])\n\t\t >> SCALEBITS);\n      /* Cr */\n      outptr2[col] = (JSAMPLE)\n\t\t((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])\n\t\t >> SCALEBITS);\n      inptr += RGB_PIXELSIZE;\n    }\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Decode one MCU's worth of Huffman-compressed coefficients,\n * partial blocks.\n */\n", "func_signal": "METHODDEF(boolean)\ndecode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  const int * natural_order;\n  int Se, blkn;\n  BITREAD_STATE_VARS;\n  savable_state state;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (! process_restart(cinfo))\n\treturn FALSE;\n  }\n\n  /* If we've run out of data, just leave the MCU set to zeroes.\n   * This way, we return uniform gray for the remainder of the segment.\n   */\n  if (! entropy->insufficient_data) {\n\n    natural_order = cinfo->natural_order;\n    Se = cinfo->lim_Se;\n\n    /* Load up working state */\n    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\n    ASSIGN_STATE(state, entropy->saved);\n\n    /* Outer loop handles each block in the MCU */\n\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n      JBLOCKROW block = MCU_data[blkn];\n      d_derived_tbl * htbl;\n      register int s, k, r;\n      int coef_limit, ci;\n\n      /* Decode a single block's worth of coefficients */\n\n      /* Section F.2.2.1: decode the DC coefficient difference */\n      htbl = entropy->dc_cur_tbls[blkn];\n      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);\n\n      htbl = entropy->ac_cur_tbls[blkn];\n      k = 1;\n      coef_limit = entropy->coef_limit[blkn];\n      if (coef_limit) {\n\t/* Convert DC difference to actual value, update last_dc_val */\n\tif (s) {\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t  r = GET_BITS(s);\n\t  s = HUFF_EXTEND(r, s);\n\t}\n\tci = cinfo->MCU_membership[blkn];\n\ts += state.last_dc_val[ci];\n\tstate.last_dc_val[ci] = s;\n\t/* Output the DC coefficient */\n\t(*block)[0] = (JCOEF) s;\n\n\t/* Section F.2.2.2: decode the AC coefficients */\n\t/* Since zeroes are skipped, output area must be cleared beforehand */\n\tfor (; k < coef_limit; k++) {\n\t  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);\n\n\t  r = s >> 4;\n\t  s &= 15;\n\n\t  if (s) {\n\t    k += r;\n\t    CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t    r = GET_BITS(s);\n\t    s = HUFF_EXTEND(r, s);\n\t    /* Output coefficient in natural (dezigzagged) order.\n\t     * Note: the extra entries in natural_order[] will save us\n\t     * if k > Se, which could happen if the data is corrupted.\n\t     */\n\t    (*block)[natural_order[k]] = (JCOEF) s;\n\t  } else {\n\t    if (r != 15)\n\t      goto EndOfBlock;\n\t    k += 15;\n\t  }\n\t}\n      } else {\n\tif (s) {\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t  DROP_BITS(s);\n\t}\n      }\n\n      /* Section F.2.2.2: decode the AC coefficients */\n      /* In this path we just discard the values */\n      for (; k <= Se; k++) {\n\tHUFF_DECODE(s, br_state, htbl, return FALSE, label3);\n\n\tr = s >> 4;\n\ts &= 15;\n\n\tif (s) {\n\t  k += r;\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t  DROP_BITS(s);\n\t} else {\n\t  if (r != 15)\n\t    break;\n\t  k += 15;\n\t}\n      }\n\n      EndOfBlock: ;\n    }\n\n    /* Completed MCU, so update state */\n    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\n    ASSIGN_STATE(entropy->saved, state);\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  entropy->restarts_to_go--;\n\n  return TRUE;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Convert some rows of samples to the JPEG colorspace.\n * No colorspace conversion, but change from interleaved\n * to separate-planes representation.\n */\n", "func_signal": "METHODDEF(void)\nrgb_convert (j_compress_ptr cinfo,\n\t     JSAMPARRAY input_buf, JSAMPIMAGE output_buf,\n\t     JDIMENSION output_row, int num_rows)", "code": "{\n  register JSAMPROW inptr;\n  register JSAMPROW outptr0, outptr1, outptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr0 = output_buf[0][output_row];\n    outptr1 = output_buf[1][output_row];\n    outptr2 = output_buf[2][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      /* We can dispense with GETJSAMPLE() here */\n      outptr0[col] = inptr[RGB_RED];\n      outptr1[col] = inptr[RGB_GREEN];\n      outptr2[col] = inptr[RGB_BLUE];\n      inptr += RGB_PIXELSIZE;\n    }\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Initialize for RGB->YCC colorspace conversion.\n */\n", "func_signal": "METHODDEF(void)\nrgb_ycc_start (j_compress_ptr cinfo)", "code": "{\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\n  INT32 * rgb_ycc_tab;\n  INT32 i;\n\n  /* Allocate and fill in the conversion tables. */\n  cconvert->rgb_ycc_tab = rgb_ycc_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(TABLE_SIZE * SIZEOF(INT32)));\n\n  for (i = 0; i <= MAXJSAMPLE; i++) {\n    rgb_ycc_tab[i+R_Y_OFF] = FIX(0.299) * i;\n    rgb_ycc_tab[i+G_Y_OFF] = FIX(0.587) * i;\n    rgb_ycc_tab[i+B_Y_OFF] = FIX(0.114) * i   + ONE_HALF;\n    rgb_ycc_tab[i+R_CB_OFF] = (-FIX(0.168735892)) * i;\n    rgb_ycc_tab[i+G_CB_OFF] = (-FIX(0.331264108)) * i;\n    /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.\n     * This ensures that the maximum output will round to MAXJSAMPLE\n     * not MAXJSAMPLE+1, and thus that we don't have to range-limit.\n     */\n    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.5) * i    + CBCR_OFFSET + ONE_HALF-1;\n/*  B=>Cb and R=>Cr tables are the same\n    rgb_ycc_tab[i+R_CR_OFF] = FIX(0.5) * i    + CBCR_OFFSET + ONE_HALF-1;\n*/\n    rgb_ycc_tab[i+G_CR_OFF] = (-FIX(0.418687589)) * i;\n    rgb_ycc_tab[i+B_CR_OFF] = (-FIX(0.081312411)) * i;\n  }\n}", "path": "lwip/src/lib/jpeg/jccolor.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * MCU decoding for AC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n", "func_signal": "METHODDEF(boolean)\ndecode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{   \n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  register int s, k, r;\n  unsigned int EOBRUN;\n  int Se, Al;\n  const int * natural_order;\n  JBLOCKROW block;\n  BITREAD_STATE_VARS;\n  d_derived_tbl * tbl;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (! process_restart(cinfo))\n\treturn FALSE;\n  }\n\n  /* If we've run out of data, just leave the MCU set to zeroes.\n   * This way, we return uniform gray for the remainder of the segment.\n   */\n  if (! entropy->insufficient_data) {\n\n    Se = cinfo->Se;\n    Al = cinfo->Al;\n    natural_order = cinfo->natural_order;\n\n    /* Load up working state.\n     * We can avoid loading/saving bitread state if in an EOB run.\n     */\n    EOBRUN = entropy->saved.EOBRUN;\t/* only part of saved state we need */\n\n    /* There is always only one block per MCU */\n\n    if (EOBRUN)\t\t\t/* if it's a band of zeroes... */\n      EOBRUN--;\t\t\t/* ...process it now (we do nothing) */\n    else {\n      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\n      block = MCU_data[0];\n      tbl = entropy->ac_derived_tbl;\n\n      for (k = cinfo->Ss; k <= Se; k++) {\n\tHUFF_DECODE(s, br_state, tbl, return FALSE, label2);\n\tr = s >> 4;\n\ts &= 15;\n\tif (s) {\n\t  k += r;\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\n\t  r = GET_BITS(s);\n\t  s = HUFF_EXTEND(r, s);\n\t  /* Scale and output coefficient in natural (dezigzagged) order */\n\t  (*block)[natural_order[k]] = (JCOEF) (s << Al);\n\t} else {\n\t  if (r != 15) {\t/* EOBr, run length is 2^r + appended bits */\n\t    if (r) {\t\t/* EOBr, r > 0 */\n\t      EOBRUN = 1 << r;\n\t      CHECK_BIT_BUFFER(br_state, r, return FALSE);\n\t      r = GET_BITS(r);\n\t      EOBRUN += r;\n\t      EOBRUN--;\t\t/* this band is processed at this moment */\n\t    }\n\t    break;\t\t/* force end-of-band */\n\t  }\n\t  k += 15;\t\t/* ZRL: skip 15 zeroes in band */\n\t}\n      }\n\n      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\n    }\n\n    /* Completed MCU, so update state */\n    entropy->saved.EOBRUN = EOBRUN;\t/* only part of saved state we need */\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  entropy->restarts_to_go--;\n\n  return TRUE;\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/*\n * Compute the derived values for a Huffman table.\n * This routine also performs some validation checks on the table.\n */\n", "func_signal": "LOCAL(void)\njpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,\n\t\t\t d_derived_tbl ** pdtbl)", "code": "{\n  JHUFF_TBL *htbl;\n  d_derived_tbl *dtbl;\n  int p, i, l, si, numsymbols;\n  int lookbits, ctr;\n  char huffsize[257];\n  unsigned int huffcode[257];\n  unsigned int code;\n\n  /* Note that huffsize[] and huffcode[] are filled in code-length order,\n   * paralleling the order of the symbols themselves in htbl->huffval[].\n   */\n\n  /* Find the input Huffman table */\n  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\n  htbl =\n    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];\n  if (htbl == NULL)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\n\n  /* Allocate a workspace if we haven't already done so. */\n  if (*pdtbl == NULL)\n    *pdtbl = (d_derived_tbl *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  SIZEOF(d_derived_tbl));\n  dtbl = *pdtbl;\n  dtbl->pub = htbl;\t\t/* fill in back link */\n  \n  /* Figure C.1: make table of Huffman code length for each symbol */\n\n  p = 0;\n  for (l = 1; l <= 16; l++) {\n    i = (int) htbl->bits[l];\n    if (i < 0 || p + i > 256)\t/* protect against table overrun */\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    while (i--)\n      huffsize[p++] = (char) l;\n  }\n  huffsize[p] = 0;\n  numsymbols = p;\n  \n  /* Figure C.2: generate the codes themselves */\n  /* We also validate that the counts represent a legal Huffman code tree. */\n  \n  code = 0;\n  si = huffsize[0];\n  p = 0;\n  while (huffsize[p]) {\n    while (((int) huffsize[p]) == si) {\n      huffcode[p++] = code;\n      code++;\n    }\n    /* code is now 1 more than the last code used for codelength si; but\n     * it must still fit in si bits, since no code is allowed to be all ones.\n     */\n    if (((INT32) code) >= (((INT32) 1) << si))\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    code <<= 1;\n    si++;\n  }\n\n  /* Figure F.15: generate decoding tables for bit-sequential decoding */\n\n  p = 0;\n  for (l = 1; l <= 16; l++) {\n    if (htbl->bits[l]) {\n      /* valoffset[l] = huffval[] index of 1st symbol of code length l,\n       * minus the minimum code of length l\n       */\n      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];\n      p += htbl->bits[l];\n      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */\n    } else {\n      dtbl->maxcode[l] = -1;\t/* -1 if no codes of this length */\n    }\n  }\n  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */\n\n  /* Compute lookahead tables to speed up decoding.\n   * First we set all the table entries to 0, indicating \"too long\";\n   * then we iterate through the Huffman codes that are short enough and\n   * fill in all the entries that correspond to bit sequences starting\n   * with that code.\n   */\n\n  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));\n\n  p = 0;\n  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {\n    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {\n      /* l = current code's length, p = its index in huffcode[] & huffval[]. */\n      /* Generate left-justified code followed by all possible bit sequences */\n      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);\n      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {\n\tdtbl->look_nbits[lookbits] = l;\n\tdtbl->look_sym[lookbits] = htbl->huffval[p];\n\tlookbits++;\n      }\n    }\n  }\n\n  /* Validate symbols as being reasonable.\n   * For AC tables, we make no check, but accept all byte values 0..255.\n   * For DC tables, we require the symbols to be in range 0..15.\n   * (Tighter bounds could be applied depending on the data depth and mode,\n   * but this is sufficient to ensure safe decoding.)\n   */\n  if (isDC) {\n    for (i = 0; i < numsymbols; i++) {\n      int sym = htbl->huffval[i];\n      if (sym < 0 || sym > 15)\n\tERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    }\n  }\n}", "path": "lwip/src/lib/jpeg/jdhuff.c", "commit_date": "2014-09-29 00:00:00", "repo_name": "EyalAr/lwip", "stars": 2362, "license": "mit", "language": "c", "size": 16788}
{"docstring": "/* Merge a table or struct into a table */\n", "func_signal": "static void janet_table_mergekv(JanetTable *table, const JanetKV *kvs, int32_t cap)", "code": "{\n    int32_t i;\n    for (i = 0; i < cap; i++) {\n        const JanetKV *kv = kvs + i;\n        if (!janet_checktype(kv->key, JANET_NIL)) {\n            janet_table_put(table, kv->key, kv->value);\n        }\n    }\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Get a value out of the table */\n", "func_signal": "Janet janet_table_get(JanetTable *t, Janet key)", "code": "{\n    JanetKV *bucket = janet_table_find(t, key);\n    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))\n        return bucket->value;\n    /* Check prototypes */\n    {\n        int i;\n        for (i = JANET_MAX_PROTO_DEPTH, t = t->proto; t && i; t = t->proto, --i) {\n            bucket = janet_table_find(t, key);\n            if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))\n                return bucket->value;\n        }\n    }\n    return janet_wrap_nil();\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Throw some kind of assembly error */\n", "func_signal": "static void janet_asm_error(JanetAssembler *a, const char *message)", "code": "{\n    a->errmessage = janet_formatc(\"%s, instruction %d\", message, a->errindex);\n    janet_asm_longjmp(a);\n}", "path": "janet/src/core/asm.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Parse a single argument to an instruction. Trims it as well as\n * try to convert arguments to bit patterns */\n", "func_signal": "static uint32_t doarg(\n    JanetAssembler *a,\n    enum JanetOpArgType argtype,\n    int nth,\n    int nbytes,\n    int hassign,\n    Janet x)", "code": "{\n    int32_t arg = doarg_1(a, argtype, x);\n    /* Calculate the min and max values that can be stored given\n     * nbytes, and whether or not the storage is signed */\n    int32_t max = (1 << ((nbytes << 3) - hassign)) - 1;\n    int32_t min = hassign ? -max - 1 : 0;\n    if (arg < min)\n        janet_asm_errorv(a, janet_formatc(\"instruction argument %v is too small, must be %d byte%s\",\n                                          x, nbytes, nbytes > 1 ? \"s\" : \"\"));\n    if (arg > max)\n        janet_asm_errorv(a, janet_formatc(\"instruction argument %v is too large, must be %d byte%s\",\n                                          x, nbytes, nbytes > 1 ? \"s\" : \"\"));\n    return ((uint32_t) arg) << (nth << 3);\n}", "path": "janet/src/core/asm.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Get a value out of the table, and record which prototype it was from. */\n", "func_signal": "Janet janet_table_get_ex(JanetTable *t, Janet key, JanetTable **which)", "code": "{\n    JanetKV *bucket = janet_table_find(t, key);\n    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {\n        *which = t;\n        return bucket->value;\n    }\n    /* Check prototypes */\n    {\n        int i;\n        for (i = JANET_MAX_PROTO_DEPTH, t = t->proto; t && i; t = t->proto, --i) {\n            bucket = janet_table_find(t, key);\n            if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {\n                *which = t;\n                return bucket->value;\n            }\n        }\n    }\n    return janet_wrap_nil();\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Parse an argument to an assembly instruction, and return the result as an\n * integer. This integer will need to be bounds checked. */\n", "func_signal": "static int32_t doarg_1(\n    JanetAssembler *a,\n    enum JanetOpArgType argtype,\n    Janet x)", "code": "{\n    int32_t ret = -1;\n    JanetTable *c;\n    switch (argtype) {\n        default:\n            c = NULL;\n            break;\n        case JANET_OAT_SLOT:\n            c = &a->slots;\n            break;\n        case JANET_OAT_ENVIRONMENT:\n            c = &a->envs;\n            break;\n        case JANET_OAT_LABEL:\n            c = &a->labels;\n            break;\n        case JANET_OAT_FUNCDEF:\n            c = &a->defs;\n            break;\n    }\n    switch (janet_type(x)) {\n        default:\n            goto error;\n            break;\n        case JANET_NUMBER: {\n            double y = janet_unwrap_number(x);\n            if (janet_checkintrange(y)) {\n                ret = (int32_t) y;\n            } else {\n                goto error;\n            }\n            break;\n        }\n        case JANET_TUPLE: {\n            const Janet *t = janet_unwrap_tuple(x);\n            if (argtype == JANET_OAT_TYPE) {\n                int32_t i = 0;\n                ret = 0;\n                for (i = 0; i < janet_tuple_length(t); i++) {\n                    ret |= doarg_1(a, JANET_OAT_SIMPLETYPE, t[i]);\n                }\n            } else {\n                goto error;\n            }\n            break;\n        }\n        case JANET_KEYWORD: {\n            if (NULL != c && argtype == JANET_OAT_LABEL) {\n                Janet result = janet_table_get(c, x);\n                if (janet_checktype(result, JANET_NUMBER)) {\n                    ret = janet_unwrap_integer(result) - a->bytecode_count;\n                } else {\n                    goto error;\n                }\n            } else if (argtype == JANET_OAT_TYPE || argtype == JANET_OAT_SIMPLETYPE) {\n                const TypeAlias *alias = janet_strbinsearch(\n                                             &type_aliases,\n                                             sizeof(type_aliases) / sizeof(TypeAlias),\n                                             sizeof(TypeAlias),\n                                             janet_unwrap_keyword(x));\n                if (alias) {\n                    ret = alias->mask;\n                } else {\n                    janet_asm_errorv(a, janet_formatc(\"unknown type %v\", x));\n                }\n            } else {\n                goto error;\n            }\n            break;\n        }\n        case JANET_SYMBOL: {\n            if (NULL != c) {\n                Janet result = janet_table_get(c, x);\n                if (janet_checktype(result, JANET_NUMBER)) {\n                    ret = (int32_t) janet_unwrap_number(result);\n                } else {\n                    janet_asm_errorv(a, janet_formatc(\"unknown name %v\", x));\n                }\n            } else {\n                goto error;\n            }\n            if (argtype == JANET_OAT_ENVIRONMENT && ret == -1) {\n                /* Add a new env */\n                ret = janet_asm_addenv(a, x);\n                if (ret < -1) {\n                    janet_asm_errorv(a, janet_formatc(\"unknown environment %v\", x));\n                }\n            }\n            break;\n        }\n    }\n    if (argtype == JANET_OAT_SLOT && ret >= a->def->slotcount)\n        a->def->slotcount = (int32_t) ret + 1;\n    return ret;\n\nerror:\n    janet_asm_errorv(a, janet_formatc(\"error parsing instruction argument %v\", x));\n    return 0;\n}", "path": "janet/src/core/asm.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Allocate an empty funcdef. This function may have added functionality\n * as commonalities between asm and compile arise. */\n", "func_signal": "JanetFuncDef *janet_funcdef_alloc(void)", "code": "{\n    JanetFuncDef *def = janet_gcalloc(JANET_MEMORY_FUNCDEF, sizeof(JanetFuncDef));\n    def->environments = NULL;\n    def->constants = NULL;\n    def->bytecode = NULL;\n    def->closure_bitset = NULL;\n    def->flags = 0;\n    def->slotcount = 0;\n    def->arity = 0;\n    def->min_arity = 0;\n    def->max_arity = INT32_MAX;\n    def->source = NULL;\n    def->sourcemap = NULL;\n    def->name = NULL;\n    def->defs = NULL;\n    def->defs_length = 0;\n    def->constants_length = 0;\n    def->bytecode_length = 0;\n    def->environments_length = 0;\n    return def;\n}", "path": "janet/src/core/bytecode.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* C Function for assembly */\n", "func_signal": "static Janet cfun_asm(int32_t argc, Janet *argv)", "code": "{\n    janet_fixarity(argc, 1);\n    JanetAssembleResult res;\n    res = janet_asm(argv[0], 0);\n    if (res.status != JANET_ASSEMBLE_OK) {\n        janet_panics(res.error);\n    }\n    return janet_wrap_function(janet_thunk(res.funcdef));\n}", "path": "janet/src/core/asm.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Create a new table */\n", "func_signal": "JanetTable *janet_table(int32_t capacity)", "code": "{\n    JanetTable *table = janet_gcalloc(JANET_MEMORY_TABLE, sizeof(JanetTable));\n    return janet_table_init_impl(table, capacity, 0);\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Convert table to struct */\n", "func_signal": "const JanetKV *janet_table_to_struct(JanetTable *t)", "code": "{\n    JanetKV *st = janet_struct_begin(t->count);\n    JanetKV *kv = t->data;\n    JanetKV *end = t->data + t->capacity;\n    while (kv < end) {\n        if (!janet_checktype(kv->key, JANET_NIL))\n            janet_struct_put(st, kv->key, kv->value);\n        kv++;\n    }\n    return janet_struct_end(st);\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Add a closure environment to the assembler. Sub funcdefs may need\n * to reference outer function environments, and may change the outer environment.\n * Returns the index of the environment in the assembler's environments, or -1\n * if not found. */\n", "func_signal": "static int32_t janet_asm_addenv(JanetAssembler *a, Janet envname)", "code": "{\n    Janet check;\n    JanetFuncDef *def = a->def;\n    int32_t envindex;\n    int32_t res;\n    if (janet_equals(a->name, envname)) {\n        return -1;\n    }\n    /* Check for memoized value */\n    check = janet_table_get(&a->envs, envname);\n    if (janet_checktype(check, JANET_NUMBER)) {\n        return (int32_t) janet_unwrap_number(check);\n    }\n    if (NULL == a->parent) return -2;\n    res = janet_asm_addenv(a->parent, envname);\n    if (res < -1) {\n        return res;\n    }\n    envindex = def->environments_length;\n    janet_table_put(&a->envs, envname, janet_wrap_number(envindex));\n    if (envindex >= a->environments_capacity) {\n        int32_t newcap = 2 * envindex;\n        def->environments = realloc(def->environments, newcap * sizeof(int32_t));\n        if (NULL == def->environments) {\n            JANET_OUT_OF_MEMORY;\n        }\n        a->environments_capacity = newcap;\n    }\n    def->environments[envindex] = (int32_t) res;\n    def->environments_length = envindex + 1;\n    return envindex;\n}", "path": "janet/src/core/asm.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Put a value into the object */\n", "func_signal": "void janet_table_put(JanetTable *t, Janet key, Janet value)", "code": "{\n    if (janet_checktype(key, JANET_NIL)) return;\n    if (janet_checktype(key, JANET_NUMBER) && isnan(janet_unwrap_number(key))) return;\n    if (janet_checktype(value, JANET_NIL)) {\n        janet_table_remove(t, key);\n    } else {\n        JanetKV *bucket = janet_table_find(t, key);\n        if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {\n            bucket->value = value;\n        } else {\n            if (NULL == bucket || 2 * (t->count + t->deleted + 1) > t->capacity) {\n                janet_table_rehash(t, janet_tablen(2 * t->count + 2));\n            }\n            bucket = janet_table_find(t, key);\n            if (janet_checktype(bucket->value, JANET_BOOLEAN))\n                --t->deleted;\n            bucket->key = key;\n            bucket->value = value;\n            ++t->count;\n        }\n    }\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Resize the dictionary table. */\n", "func_signal": "static void janet_table_rehash(JanetTable *t, int32_t size)", "code": "{\n    JanetKV *olddata = t->data;\n    JanetKV *newdata;\n    int islocal = t->gc.flags & JANET_TABLE_FLAG_STACK;\n    if (islocal) {\n        newdata = (JanetKV *) janet_memalloc_empty_local(size);\n    } else {\n        newdata = (JanetKV *) janet_memalloc_empty(size);\n        if (NULL == newdata) {\n            JANET_OUT_OF_MEMORY;\n        }\n    }\n    int32_t i, oldcapacity;\n    oldcapacity = t->capacity;\n    t->data = newdata;\n    t->capacity = size;\n    t->deleted = 0;\n    for (i = 0; i < oldcapacity; i++) {\n        JanetKV *kv = olddata + i;\n        if (!janet_checktype(kv->key, JANET_NIL)) {\n            JanetKV *newkv = janet_table_find(t, kv->key);\n            *newkv = *kv;\n        }\n    }\n    if (islocal) {\n        janet_sfree(olddata);\n    } else {\n        free(olddata);\n    }\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Get a value out of the table. Don't check prototype tables. */\n", "func_signal": "Janet janet_table_rawget(JanetTable *t, Janet key)", "code": "{\n    JanetKV *bucket = janet_table_find(t, key);\n    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))\n        return bucket->value;\n    else\n        return janet_wrap_nil();\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Clear a table */\n", "func_signal": "void janet_table_clear(JanetTable *t)", "code": "{\n    int32_t capacity = t->capacity;\n    JanetKV *data = t->data;\n    janet_memempty(data, capacity);\n    t->count = 0;\n    t->deleted = 0;\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Clone a table. */\n", "func_signal": "JanetTable *janet_table_clone(JanetTable *table)", "code": "{\n    JanetTable *newTable = janet_gcalloc(JANET_MEMORY_TABLE, sizeof(JanetTable));\n    newTable->count = table->count;\n    newTable->capacity = table->capacity;\n    newTable->deleted = table->deleted;\n    newTable->proto = table->proto;\n    newTable->data = malloc(newTable->capacity * sizeof(JanetKV));\n    if (NULL == newTable->data) {\n        JANET_OUT_OF_MEMORY;\n    }\n    memcpy(newTable->data, table->data, (size_t) table->capacity * sizeof(JanetKV));\n    return newTable;\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Create some constant sized tuples */\n", "func_signal": "static const Janet *tup1(Janet x)", "code": "{\n    Janet *tup = janet_tuple_begin(1);\n    tup[0] = x;\n    return janet_tuple_end(tup);\n}", "path": "janet/src/core/asm.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Create a simple closure from a funcdef */\n", "func_signal": "JanetFunction *janet_thunk(JanetFuncDef *def)", "code": "{\n    JanetFunction *func = janet_gcalloc(JANET_MEMORY_FUNCTION, sizeof(JanetFunction));\n    func->def = def;\n    janet_assert(def->environments_length == 0, \"tried to create thunk that needs upvalues\");\n    return func;\n}", "path": "janet/src/core/bytecode.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Remove an entry from the dictionary. Return the value that\n * was removed. */\n", "func_signal": "Janet janet_table_remove(JanetTable *t, Janet key)", "code": "{\n    JanetKV *bucket = janet_table_find(t, key);\n    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {\n        Janet ret = bucket->value;\n        t->count--;\n        t->deleted++;\n        bucket->key = janet_wrap_nil();\n        bucket->value = janet_wrap_false();\n        return ret;\n    } else {\n        return janet_wrap_nil();\n    }\n}", "path": "janet/src/core/table.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "/* Given an argument, convert it to the appropriate integer or symbol */\n", "func_signal": "Janet janet_asm_decode_instruction(uint32_t instr)", "code": "{\n    const JanetInstructionDef *def = janet_asm_reverse_lookup(instr);\n    Janet name;\n    if (NULL == def) {\n        return janet_wrap_integer((int32_t)instr);\n    }\n    name = janet_csymbolv(def->name);\n    const Janet *ret = NULL;\n#define oparg(shift, mask) ((instr >> ((shift) << 3)) & (mask))\n    switch (janet_instructions[def->opcode]) {\n        case JINT_0:\n            ret = tup1(name);\n            break;\n        case JINT_S:\n            ret = tup2(name, janet_wrap_integer(oparg(1, 0xFFFFFF)));\n            break;\n        case JINT_L:\n            ret = tup2(name, janet_wrap_integer((int32_t)instr >> 8));\n            break;\n        case JINT_SS:\n        case JINT_ST:\n        case JINT_SC:\n        case JINT_SU:\n        case JINT_SD:\n            ret = tup3(name,\n                       janet_wrap_integer(oparg(1, 0xFF)),\n                       janet_wrap_integer(oparg(2, 0xFFFF)));\n            break;\n        case JINT_SI:\n        case JINT_SL:\n            ret =  tup3(name,\n                        janet_wrap_integer(oparg(1, 0xFF)),\n                        janet_wrap_integer((int32_t)instr >> 16));\n            break;\n        case JINT_SSS:\n        case JINT_SES:\n        case JINT_SSU:\n            ret = tup4(name,\n                       janet_wrap_integer(oparg(1, 0xFF)),\n                       janet_wrap_integer(oparg(2, 0xFF)),\n                       janet_wrap_integer(oparg(3, 0xFF)));\n            break;\n        case JINT_SSI:\n            ret = tup4(name,\n                       janet_wrap_integer(oparg(1, 0xFF)),\n                       janet_wrap_integer(oparg(2, 0xFF)),\n                       janet_wrap_integer((int32_t)instr >> 24));\n            break;\n    }\n#undef oparg\n    if (ret) {\n        /* Check if break point set */\n        if (instr & 0x80) {\n            janet_tuple_flag(ret) |= JANET_TUPLE_FLAG_BRACKETCTOR;\n        }\n        return janet_wrap_tuple(ret);\n    }\n    return janet_wrap_nil();\n}", "path": "janet/src/core/asm.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "janet-lang/janet", "stars": 3264, "license": "mit", "language": "c", "size": 12804}
{"docstring": "// log errors...\n", "func_signal": "static void uwsgi_spnego_err(const char *func, OM_uint32 err_maj, OM_uint32 err_min)", "code": "{\n\n\tOM_uint32 ret;\n\tOM_uint32 min_stat;\n\tOM_uint32 msg_ctx = 0;\n\tgss_buffer_desc status_string;\n\n\tret = gss_display_status (&min_stat,\n                                       err_maj,\n                                       GSS_C_GSS_CODE,\n                                       GSS_C_NO_OID,\n                                       &msg_ctx,\n                                       &status_string);\n\n\tif (GSS_ERROR(ret)) return;\n\n\tuwsgi_log(\"[uwsgi-spnego] %s() error (major): %.*s\\n\", func, status_string.length, status_string.value);\n\n\tgss_release_buffer(&min_stat, &status_string);\n\t\n\tret = gss_display_status (&min_stat,\n                                       err_min,\n                                       GSS_C_MECH_CODE,\n                                       GSS_C_NULL_OID,\n                                       &msg_ctx,\n                                       &status_string);\n\n\tif (GSS_ERROR(ret)) return;\n\n\tif (status_string.length > 0) {\n        \tuwsgi_log(\"[uwsgi-spnego] %s() error (minor): %.*s\\n\",func, status_string.length, status_string.value);\n\t}\n\tif (status_string.value) {\n\t\tgss_release_buffer(&min_stat, &status_string);\n\t}\n\t\n}", "path": "uwsgi/plugins/router_spnego/router_spnego.c", "commit_date": "2015-07-23 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "/*\n\ninitialize all apps\n\n*/\n", "func_signal": "void uwsgi_init_all_apps()", "code": "{\n\n\tint i, j;\n\n\tuwsgi_hooks_run(uwsgi.hook_pre_app, \"pre app\", 1);\n\n\t// now run the pre-app scripts\n\tstruct uwsgi_string_list *usl = uwsgi.exec_pre_app;\n\twhile (usl) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (pre app)...\\n\", usl->value);\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t\tusl = usl->next;\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_pre_app) {\n                if (uwsgi_call_symbol(usl->value)) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n                }\n        }\n\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->init_apps) {\n\t\t\tuwsgi.p[i]->init_apps();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->init_apps) {\n\t\t\tuwsgi.gp[i]->init_apps();\n\t\t}\n\t}\n\n\tstruct uwsgi_string_list *app_mps = uwsgi.mounts;\n\twhile (app_mps) {\n\t\tchar *what = strchr(app_mps->value, '=');\n\t\tif (what) {\n\t\t\twhat[0] = 0;\n\t\t\twhat++;\n\t\t\tfor (j = 0; j < 256; j++) {\n\t\t\t\tif (uwsgi.p[j]->mount_app) {\n\t\t\t\t\tuwsgi_log(\"mounting %s on %s\\n\", what, app_mps->value[0] == 0 ? \"/\" : app_mps->value);\n\t\t\t\t\tif (uwsgi.p[j]->mount_app(app_mps->value[0] == 0 ? \"/\" : app_mps->value, what) != -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhat--;\n\t\t\twhat[0] = '=';\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"invalid mountpoint: %s\\n\", app_mps->value);\n\t\t\texit(1);\n\t\t}\n\t\tapp_mps = app_mps->next;\n\t}\n\n\t// no app initialized and virtualhosting enabled\n\tif (uwsgi_apps_cnt == 0 && uwsgi.numproc > 0 && !uwsgi.command_mode) {\n\t\tif (uwsgi.need_app) {\n\t\t\tif (!uwsgi.lazy)\n\t\t\t\tuwsgi_log(\"*** no app loaded. GAME OVER ***\\n\");\n\t\t\tif (uwsgi.lazy_apps) {\n\t\t\t\tif (uwsgi.master_process) {\n\t\t\t\t\tif (kill(uwsgi.workers[0].pid, SIGINT)) {\n\t\t\t\t\t\tuwsgi_error(\"kill()\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(UWSGI_FAILED_APP_CODE);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"*** no app loaded. going in full dynamic mode ***\\n\");\n\t\t}\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_post_app, \"post app\", 1);\n\n\tusl = uwsgi.exec_post_app;\n        while (usl) {\n                uwsgi_log(\"running \\\"%s\\\" (post app)...\\n\", usl->value);\n                int ret = uwsgi_run_command_and_wait(NULL, usl->value);\n                if (ret != 0) {\n                        uwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n                        exit(1);\n                }\n                usl = usl->next;\n        }\n\n\tuwsgi_foreach(usl, uwsgi.call_post_app) {\n                if (uwsgi_call_symbol(usl->value)) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n                }\n        }\n\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// Bernstein classic hash (this is not static as it is used by other areas)\n", "func_signal": "uint32_t djb33x_hash(char *key, uint64_t keylen)", "code": "{\n\n        register uint32_t hash = 5381;\n        uint64_t i;\n\n        for (i = 0; i < keylen; i++) {\n                hash = ((hash << 5) + hash) ^ key[i];\n        }\n\n        return hash;\n}", "path": "uwsgi/core/hash.c", "commit_date": "2017-09-02 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// taken from Torsten Foertsch AfterFork.xs\n", "func_signal": "void uwsgi_perl_post_fork()", "code": "{\n\n\tGV *tmpgv = gv_fetchpv(\"$\", TRUE, SVt_PV);\n\tif (tmpgv) {\n\t\tSvREADONLY_off(GvSV(tmpgv));\n\t\tsv_setiv(GvSV(tmpgv), (IV)getpid());\n\t\tSvREADONLY_on(GvSV(tmpgv));\n\t}\n\n\tstruct uwsgi_string_list *usl;\n\tuwsgi_foreach(usl, uperl.exec_post_fork) {\n\t\tSV *dollar_zero = get_sv(\"0\", GV_ADD);\n                sv_setsv(dollar_zero, newSVpv(usl->value, usl->len));\n\t\tuwsgi_perl_exec(usl->value);\n\t}\n\n\tif (uperl.postfork) {\n\t\tuwsgi_perl_run_hook(uperl.postfork);\n\t}\n}", "path": "uwsgi/plugins/psgi/psgi_plugin.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// brutally destroy\n", "func_signal": "void kill_them_all(int signum)", "code": "{\n\n\tif (uwsgi_instance_is_dying) return;\n\tuwsgi.status.brutally_destroying = 1;\n\n\t// unsubscribe if needed\n\tuwsgi_unsubscribe_all();\n\n\tuwsgi_log(\"SIGINT/SIGQUIT received...killing workers...\\n\");\n\n\tint i;\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n                if (uwsgi.workers[i].pid > 0) {\n                        uwsgi_curse(i, SIGINT);\n                }\n        }\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGINT);\n\t\t}\n\t}\n\n\tuwsgi_destroy_processes();\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// graceful reload\n", "func_signal": "void grace_them_all(int signum)", "code": "{\n\tif (uwsgi_instance_is_reloading || uwsgi_instance_is_dying)\n\t\treturn;\n\n\tint i;\n\n\tif (uwsgi.lazy) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tif (uwsgi.workers[i].pid > 0) {\n\t\t\t\tuwsgi_curse(i, SIGHUP);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\t\n\n\tuwsgi.status.gracefully_reloading = 1;\n\n\tuwsgi_destroy_processes();\n\n\tuwsgi_log(\"...gracefully killing workers...\\n\");\n\n#ifdef UWSGI_SSL\n\tuwsgi_legion_announce_death();\n#endif\n\n\tif (uwsgi.unsubscribe_on_graceful_reload) {\n\t\tuwsgi_unsubscribe_all();\n\t}\n\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\tif (uwsgi.workers[i].pid > 0) {\n\t\t\tuwsgi_curse(i, SIGHUP);\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGHUP);\n\t\t}\n\t}\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "/*\n\n\tadvanced (pluggable) hooks\n\n\tthey are executed before the other hooks, and can be extended by plugins\n\n\tif a plugin tries to register an hook with a name already available in the list, its function\n\twill be overridden\n\n*/\n", "func_signal": "struct uwsgi_hook *uwsgi_hook_by_name(char *name)", "code": "{\n\tstruct uwsgi_hook *uh = uwsgi.hooks;\n\twhile(uh) {\n\t\tif (!strcmp(uh->name, name)) {\n\t\t\treturn uh;\n\t\t}\n\t\tuh = uh->next;\n\t}\n\treturn NULL;\n}", "path": "uwsgi/core/hooks.c", "commit_date": "2017-03-25 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// Murmur2 hash Copyright (C) Austin Appleby\n// adapted from nginx\n", "func_signal": "static uint32_t murmur2_hash(char *key, uint64_t keylen)", "code": "{\n\n\tuint32_t  h, k;\n\tuint8_t *ukey = (uint8_t *) key;\n\th = 0 ^ keylen;\n\twhile (keylen >= 4) {\n        \tk  = ukey[0];\n        \tk |= ukey[1] << 8;\n        \tk |= ukey[2] << 16;\n        \tk |= ukey[3] << 24;\n\n        \tk *= 0x5bd1e995;\n        \tk ^= k >> 24;\n        \tk *= 0x5bd1e995;\n\n        \th *= 0x5bd1e995;\n        \th ^= k;\n\n        \tukey += 4;\n        \tkeylen -= 4;\n    \t}\n\n\tswitch (keylen) {\n\t\tcase 3:\n        \t\th ^= key[2] << 16;\n\t\t\t/* fallthrough */\n    \t\tcase 2:\n        \t\th ^= key[1] << 8;\n\t\t\t/* fallthrough */\n    \t\tcase 1:\n        \t\th ^= key[0];\n        \t\th *= 0x5bd1e995;\n    \t}\n\n\th ^= h >> 13;\n\th *= 0x5bd1e995;\n\th ^= h >> 15;\n\n\treturn h;\n}", "path": "uwsgi/core/hash.c", "commit_date": "2017-09-02 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "/*\nthis is a special hook, allowing the Emperor to enter a vassal\nnamespace and call hooks in its namespace context.\n*/\n", "func_signal": "void uwsgi_hooks_setns_run(struct uwsgi_string_list *l, pid_t pid, uid_t uid, gid_t gid)", "code": "{\n\tint (*u_setns) (int, int) = (int (*)(int, int)) dlsym(RTLD_DEFAULT, \"setns\");\n        if (!u_setns) {\n                uwsgi_log(\"your system misses setns() syscall !!!\\n\");\n\t\treturn;\n        }\n\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, l) {\n\t\t// fist of all fork() the current process\n\t\tpid_t new_pid = fork();\n\t\tif (new_pid > 0) {\n\t\t\t// wait for its death\n\t\t\tint status;\n\t\t\tif (waitpid(new_pid, &status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"uwsgi_hooks_setns_run()/waitpid()\");\n\t\t\t}\n\t\t}\n\t\telse if (new_pid == 0) {\n\t\t\t// from now on, freeing memory is useless\n\t\t\t// now split args to know which namespaces to join\n\t\t\tchar *action = strchr(usl->value, ' ');\n\t\t\tif (!action) {\n\t\t\t\tuwsgi_log(\"invalid setns hook syntax, must be \\\"namespaces_list action:...\\\"\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tchar *pidstr = uwsgi_num2str(pid);\n\t\t\tchar *uidstr = uwsgi_num2str(uid);\n\t\t\tchar *gidstr = uwsgi_num2str(gid);\n\n\t\t\tchar *namespaces = uwsgi_concat2n(usl->value, action-usl->value, \"\", 0);\n        \t\tchar *p, *ctx = NULL;\n        \t\tuwsgi_foreach_token(namespaces, \",\", p, ctx) {\n\t\t\t\tchar *procfile = uwsgi_concat4(\"/proc/\", pidstr, \"/ns/\", p);\n\t\t\t\tint fd = open(procfile, O_RDONLY);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\tuwsgi_error_open(procfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (u_setns(fd, 0) < 0){\n\t\t\t\t\tuwsgi_error(\"uwsgi_hooks_setns_run()/setns()\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tclose(fd);\n\t\t\t\tfree(procfile);\n                \t}\n\n\t\t\tif (setenv(\"UWSGI_VASSAL_PID\", pidstr, 1)) {\n\t\t\t\tuwsgi_error(\"uwsgi_hooks_setns_run()/setenv()\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (setenv(\"UWSGI_VASSAL_UID\", uidstr, 1)) {\n\t\t\t\tuwsgi_error(\"uwsgi_hooks_setns_run()/setenv()\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (setenv(\"UWSGI_VASSAL_GID\", gidstr, 1)) {\n\t\t\t\tuwsgi_error(\"uwsgi_hooks_setns_run()/setenv()\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// now run the action and then exit\n\t\t\taction++;\n\t\t\tchar *colon = strchr(action, ':');\n\t\t\tif (!colon) {\n\t\t\t\tuwsgi_log(\"invalid hook syntax must be action:arg\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*colon = 0;\n\t\t\tstruct uwsgi_hook *uh = uwsgi_hook_by_name(action);\n                \tif (!uh) {\n                        \tuwsgi_log(\"hook action not found: %s\\n\", action);\n                        \texit(1);\n                \t}\n                \t*colon = ':';\n\n                        uwsgi_log(\"running \\\"%s\\\" (setns)...\\n\", usl->value);\n                \texit(uh->func(colon+1));\n\t\t}\n\t\telse {\n\t\t\tuwsgi_error(\"uwsgi_hooks_setns_run()/fork()\");\n\t\t}\n\t}\n}", "path": "uwsgi/core/hooks.c", "commit_date": "2017-03-25 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// report CFLAGS used for compiling the server\n// use that values to build external plugins\n", "func_signal": "void uwsgi_opt_cflags(char *opt, char *filename, void *foobar)", "code": "{\n\tfprintf(stdout, \"%s\\n\", uwsgi_get_cflags());\n\texit(0);\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// in threading mode we need to use the cancel pthread subsystem\n", "func_signal": "void wait_for_threads()", "code": "{\n\tint i, ret;\n\n\t// on some platform thread cancellation is REALLY flaky\n\tif (uwsgi.no_threads_wait) return;\n\n\tint sudden_death = 0;\n\n\tpthread_mutex_lock(&uwsgi.six_feet_under_lock);\n\tfor (i = 1; i < uwsgi.threads; i++) {\n\t\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, pthread_self())) {\n\t\t\tif (pthread_cancel(uwsgi.workers[uwsgi.mywid].cores[i].thread_id)) {\n\t\t\t\tuwsgi_error(\"pthread_cancel()\\n\");\n\t\t\t\tsudden_death = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sudden_death)\n\t\tgoto end;\n\n\t// wait for thread termination\n\tfor (i = 1; i < uwsgi.threads; i++) {\n\t\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, pthread_self())) {\n\t\t\tret = pthread_join(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, NULL);\n\t\t\tif (ret) {\n\t\t\t\tuwsgi_log(\"pthread_join() = %d\\n\", ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t// cancel initial thread last since after pthread_cancel() and\n\t// pthread_join() is called on it, the whole process will appear to be\n\t// a zombie. although it won't eliminate process zombie time, but it\n\t// should minimize it.\n\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[0].thread_id, pthread_self())) {\n\t\tif (pthread_cancel(uwsgi.workers[uwsgi.mywid].cores[0].thread_id)) {\n\t\t\tuwsgi_error(\"pthread_cancel() on initial thread\\n\");\n\t\t\tgoto end;\n\t\t}\n\n\t\tret = pthread_join(uwsgi.workers[uwsgi.mywid].cores[0].thread_id, NULL);\n\t\tif (ret) {\n\t\t\tuwsgi_log(\"pthread_join() = %d on initial thread\\n\", ret);\n\t\t}\n\t}\n\nend:\n\n\tpthread_mutex_unlock(&uwsgi.six_feet_under_lock);\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// timespecs have nanoseconds resolution\n", "func_signal": "time_t uwsgi_monotonic_seconds()", "code": "{\n\tstruct timespec ts;\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\treturn ts.tv_sec;\n}", "path": "uwsgi/plugins/clock_monotonic/clock_monotonic.c", "commit_date": "2012-09-19 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "/*\n   yaml file must be read ALL into memory.\n   This memory must not be freed for all the server lifecycle\n   */\n", "func_signal": "void yaml_rstrip(char *line)", "code": "{\n\n\toff_t i;\n\n\tfor (i = strlen(line) - 1; i >= 0; i--) {\n\t\tif (line[i] == ' ' || line[i] == '\\t') {\n\t\t\tline[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n}", "path": "uwsgi/core/yaml.c", "commit_date": "2020-01-25 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "/*\n\nthis function builds the help output from the uwsgi.options structure\n\n*/\n", "func_signal": "void uwsgi_help(char *opt, char *val, void *none)", "code": "{\n\n\tsize_t max_size = 0;\n\n\tfprintf(stdout, \"Usage: %s [options...]\\n\", uwsgi.binary_path);\n\n\tstruct uwsgi_option *op = uwsgi.options;\n\twhile (op && op->name) {\n\t\tif (strlen(op->name) > max_size) {\n\t\t\tmax_size = strlen(op->name);\n\t\t}\n\t\top++;\n\t}\n\n\tmax_size++;\n\n\top = uwsgi.options;\n\twhile (op && op->name) {\n\t\tif (op->shortcut) {\n\t\t\tfprintf(stdout, \"    -%c|--%-*s %s\\n\", op->shortcut, (int) max_size - 3, op->name, op->help);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stdout, \"    --%-*s %s\\n\", (int) max_size, op->name, op->help);\n\t\t}\n\t\top++;\n\t}\n\n\texit(0);\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "/*\n\nwhat happens here ?\n\nwe transform the uwsgi_option structure to a struct option\nfor passing it to getopt_long\nA short options string is built.\n\nThis function could be called multiple times, so it will free previous areas\n\n*/\n", "func_signal": "void build_options()", "code": "{\n\n\tint options_count = 0;\n\tint pos = 0;\n\tint i;\n\t// first count the base options\n\n\tstruct uwsgi_option *op = uwsgi_base_options;\n\twhile (op->name) {\n\t\toptions_count++;\n\t\top++;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->options) {\n\t\t\toptions_count += uwsgi_count_options(uwsgi.p[i]->options);\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->options) {\n\t\t\toptions_count += uwsgi_count_options(uwsgi.gp[i]->options);\n\t\t}\n\t}\n\n\t// add custom options\n\tstruct uwsgi_custom_option *uco = uwsgi.custom_options;\n\twhile (uco) {\n\t\toptions_count++;\n\t\tuco = uco->next;\n\t}\n\n\tif (uwsgi.options)\n\t\tfree(uwsgi.options);\n\n\n\t// rebuild uwsgi.options area\n\tuwsgi.options = uwsgi_calloc(sizeof(struct uwsgi_option) * (options_count + 1));\n\n\top = uwsgi_base_options;\n\twhile (op->name) {\n\t\tmemcpy(&uwsgi.options[pos], op, sizeof(struct uwsgi_option));\n\t\tpos++;\n\t\top++;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->options) {\n\t\t\tint c = uwsgi_count_options(uwsgi.p[i]->options);\n\t\t\tmemcpy(&uwsgi.options[pos], uwsgi.p[i]->options, sizeof(struct uwsgi_option) * c);\n\t\t\tpos += c;\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->options) {\n\t\t\tint c = uwsgi_count_options(uwsgi.gp[i]->options);\n\t\t\tmemcpy(&uwsgi.options[pos], uwsgi.gp[i]->options, sizeof(struct uwsgi_option) * c);\n\t\t\tpos += c;\n\t\t}\n\t}\n\n\tuco = uwsgi.custom_options;\n        while (uco) {\n                uwsgi.options[pos].name = uco->name;\n                if (uco->has_args) {\n                        uwsgi.options[pos].type = required_argument;\n                }\n                else {\n                        uwsgi.options[pos].type = no_argument;\n                }\n                // custom options should be immediate\n                uwsgi.options[pos].flags = UWSGI_OPT_IMMEDIATE;\n                // help shows the option definition\n                uwsgi.options[pos].help = uco->value;\n                uwsgi.options[pos].data = uco;\n                uwsgi.options[pos].func = uwsgi_opt_custom;\n\n                pos++;\n                uco = uco->next;\n        }\n\n\n\tpos = 0;\n\n\tif (uwsgi.long_options)\n\t\tfree(uwsgi.long_options);\n\n\tuwsgi.long_options = uwsgi_calloc(sizeof(struct option) * (options_count + 1));\n\n\tif (uwsgi.short_options)\n\t\tfree(uwsgi.short_options);\n\n\tuwsgi.short_options = uwsgi_calloc((options_count * 3) + 1);\n\n\t// build long_options (this time with custom_options)\n\top = uwsgi.options;\n\twhile (op->name) {\n\t\tuwsgi.long_options[pos].name = op->name;\n\t\tuwsgi.long_options[pos].has_arg = op->type;\n\t\tuwsgi.long_options[pos].flag = 0;\n\t\t// add 1000 to avoid short_options collision\n\t\tuwsgi.long_options[pos].val = 1000 + pos;\n\t\tif (op->shortcut) {\n\t\t\tchar shortcut = (char) op->shortcut;\n\t\t\t// avoid duplicates in short_options\n\t\t\tif (!strchr(uwsgi.short_options, shortcut)) {\n\t\t\t\tstrncat(uwsgi.short_options, &shortcut, 1);\n\t\t\t\tif (op->type == optional_argument) {\n\t\t\t\t\tstrcat(uwsgi.short_options, \"::\");\n\t\t\t\t}\n\t\t\t\telse if (op->type == required_argument) {\n\t\t\t\t\tstrcat(uwsgi.short_options, \":\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\top++;\n\t\tpos++;\n\t}\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "/*\n\tnot atomic, avoid its use in multithreaded modes\n*/\n", "func_signal": "static uint32_t rr_hash(char *key, uint64_t keylen)", "code": "{\n\tstatic uint32_t rr = 0;\n\tuint32_t max_value = uwsgi_str_num(key, keylen);\n\tuint32_t ret = rr;\n\trr++;\n\tif (rr > max_value) {\n\t\trr = 0;\n\t}\n\treturn ret;\n}", "path": "uwsgi/core/hash.c", "commit_date": "2017-09-02 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// this lives in a worker thread and periodically scans for memory usage\n// when evil reloaders are in place\n", "func_signal": "void *mem_collector(void *foobar)", "code": "{\n\t// block all signals\n        sigset_t smask;\n        sigfillset(&smask);\n        pthread_sigmask(SIG_BLOCK, &smask, NULL);\n\tuwsgi_log_verbose(\"mem-collector thread started for worker %d\\n\", uwsgi.mywid);\n\tfor(;;) {\n\t\tsleep(uwsgi.mem_collector_freq);\n\t\tuint64_t rss = 0, vsz = 0;\n\t\tget_memusage(&rss, &vsz);\n\t\tuwsgi.workers[uwsgi.mywid].rss_size = rss;\n\t\tuwsgi.workers[uwsgi.mywid].vsz_size = vsz;\n\t}\n\treturn NULL;\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// action 0 is set, 1 is remove\n", "func_signal": "static void uwsgi_webdav_manage_prop_update(struct wsgi_request *wsgi_req, xmlNode *parent, xmlNode *response, char *filename, uint8_t action)", "code": "{\n\txmlNode *node;\n\t// search for \"prop\"\n\tfor (node = parent->children; node; node = node->next) {\n\t\tif (node->type == XML_ELEMENT_NODE) {\n\t\t\tif (node->ns && !strcmp((char *) node->ns->href, \"DAV:\")) {\n\t\t\t\tif (!strcmp((char *) node->name, \"prop\")) {\n\t\t\t\t\tuwsgi_webdav_do_prop_update(wsgi_req, node, response, filename, action);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "uwsgi/plugins/webdav/webdav.c", "commit_date": "2017-10-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// gracefully destroy\n", "func_signal": "void gracefully_kill_them_all(int signum)", "code": "{\n\n        if (uwsgi_instance_is_dying) return;\n        uwsgi.status.gracefully_destroying = 1;\n\n        // unsubscribe if needed\n        uwsgi_unsubscribe_all();\n\n        uwsgi_log_verbose(\"graceful shutdown triggered...\\n\");\n\n        int i;\n        for (i = 1; i <= uwsgi.numproc; i++) {\n                if (uwsgi.workers[i].pid > 0) {\n                        uwsgi.workers[i].shutdown_sockets = 1;\n                        uwsgi_curse(i, SIGHUP);\n                }\n        }\n        for (i = 0; i < uwsgi.mules_cnt; i++) {\n                if (uwsgi.mules[i].pid > 0) {\n                        uwsgi_curse_mule(i, SIGHUP);\n                }\n        }\n\n        uwsgi_destroy_processes();\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "// brutally reload\n", "func_signal": "void reap_them_all(int signum)", "code": "{\n\n\t// avoid race condition in lazy mode\n\tif (uwsgi_instance_is_reloading)\n\t\treturn;\n\n\tuwsgi.status.brutally_reloading = 1;\n\n\tif (!uwsgi.workers) return;\n\n\tuwsgi_destroy_processes();\n\n\tuwsgi_log(\"...brutally killing workers...\\n\");\n\n#ifdef UWSGI_SSL\n        uwsgi_legion_announce_death();\n#endif\n\n\t// unsubscribe if needed\n\tuwsgi_unsubscribe_all();\n\n\tint i;\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\tif (uwsgi.workers[i].pid > 0)\n\t\t\tuwsgi_curse(i, SIGTERM);\n\t}\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGTERM);\n\t\t}\n\t}\n}", "path": "uwsgi/core/uwsgi.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "unbit/uwsgi", "stars": 3388, "license": "other", "language": "c", "size": 30684}
{"docstring": "/**\n  * @brief  Unregister a WWDG Callback\n  *         WWDG Callback is redirected to the weak (surcharged) predefined callback\n  * @param  hwwdg WWDG handle\n  * @param  CallbackID ID of the callback to be registered\n  *         This parameter can be one of the following values:\n  *           @arg @ref HAL_WWDG_EWI_CB_ID Early WakeUp Interrupt Callback ID\n  *           @arg @ref HAL_WWDG_MSPINIT_CB_ID MspInit callback ID\n  * @retval status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_WWDG_UnRegisterCallback(WWDG_HandleTypeDef *hwwdg, HAL_WWDG_CallbackIDTypeDef CallbackID)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  switch (CallbackID)\n  {\n    case HAL_WWDG_EWI_CB_ID:\n      hwwdg->EwiCallback = HAL_WWDG_EarlyWakeupCallback;\n      break;\n\n    case HAL_WWDG_MSPINIT_CB_ID:\n      hwwdg->MspInitCallback = HAL_WWDG_MspInit;\n      break;\n\n    default:\n      status = HAL_ERROR;\n      break;\n  }\n\n  return status;\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_wwdg.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Aborts the DMA Transfer in Interrupt mode.\n  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains\n  *                 the configuration information for the specified DMA Stream.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)", "code": "{\n  if(hdma->State != HAL_DMA_STATE_BUSY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\n    return HAL_ERROR;\n  }\n  else\n  {\n    /* Set Abort State  */\n    hdma->State = HAL_DMA_STATE_ABORT;\n    \n    /* Disable the stream */\n    __HAL_DMA_DISABLE(hdma);\n  }\n\n  return HAL_OK;\n}", "path": "openmv/src/hal/stm32/f7/src/stm32f7xx_hal_dma.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Get configuration of a dedicated Exti line.\n  * @param  hexti Exti handle.\n  * @param  pExtiConfig Pointer on structure to store Exti configuration.\n  * @retval HAL Status.\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)", "code": "{\n  __IO uint32_t *regaddr;\n  uint32_t regval;\n  uint32_t linepos;\n  uint32_t maskline;\n  uint32_t offset;\n  uint32_t pcrlinepos;\n\n  /* Check null pointer */\n  if ((hexti == NULL) || (pExtiConfig == NULL))\n  {\n    return HAL_ERROR;\n  }\n\n  /* Check the parameter */\n  assert_param(IS_EXTI_LINE(hexti->Line));\n\n  /* Store handle line number to configuration structure */\n  pExtiConfig->Line = hexti->Line;\n\n  /* compute line register offset and line mask */\n  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\n  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);\n  maskline = (1UL << linepos);\n\n  /* 1] Get core mode : interrupt */\n  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));\n  regval = *regaddr;\n\n  pExtiConfig->Mode = EXTI_MODE_NONE;\n\n  /* Check if selected line is enable */\n  if ((regval & maskline) != 0x00U)\n  {\n    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;\n  }\n\n  /* Get event mode */\n  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));\n  regval = *regaddr;\n\n  /* Check if selected line is enable */\n  if ((regval & maskline) != 0x00U)\n  {\n    pExtiConfig->Mode |= EXTI_MODE_EVENT;\n  }\n#if defined (DUAL_CORE)\n  regaddr = (__IO uint32_t *)(&EXTI->C2IMR1 + (EXTI_MODE_OFFSET * offset));\n  regval = *regaddr;\n\n  /* Check if selected line is enable */\n  if ((regval & maskline) != 0x00U)\n  {\n    pExtiConfig->Mode = EXTI_MODE_CORE2_INTERRUPT;\n  }\n\n  /* Get event mode */\n  regaddr = (__IO uint32_t *)(&EXTI->C2EMR1 + (EXTI_MODE_OFFSET * offset));\n  regval = *regaddr;\n\n  /* Check if selected line is enable */\n  if ((regval & maskline) != 0x00U)\n  {\n    pExtiConfig->Mode |= EXTI_MODE_CORE2_EVENT;\n  }\n#endif /*DUAL_CORE*/\n\n  /* 2] Get trigger for configurable lines : rising */\n  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)\n  {\n    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));\n    regval = *regaddr;\n\n    /* Check if configuration of selected line is enable */\n    if ((regval & maskline) != 0x00U)\n    {\n      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;\n    }\n    else\n    {\n      pExtiConfig->Trigger = EXTI_TRIGGER_NONE;\n    }\n\n    /* Get falling configuration */\n    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));\n    regval = *regaddr;\n\n    /* Check if configuration of selected line is enable */\n    if ((regval & maskline) != 0x00U)\n    {\n      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;\n    }\n\n    /* Get Gpio port selection for gpio lines */\n    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)\n    {\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\n\n      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];\n      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3UL - (linepos & 0x03UL)))) >> 24U);\n    }\n    else\n    {\n      pExtiConfig->GPIOSel = 0x00U;\n    }\n  }\n  else\n  {\n    pExtiConfig->Trigger = EXTI_TRIGGER_NONE;\n    pExtiConfig->GPIOSel = 0x00U;\n  }\n\n  /* 3] Get D3 Pend Clear source */\n  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)\n  {\n    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));\n    if(((*regaddr) & linepos) == 0UL)\n    {\n      /* if PMR unset, then no pend clear source is used */\n      pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;\n    }\n    else\n    {\n      /* if wakeup target is any and PMR set, the read pend clear source from  D3PCRxL/H */\n      if(linepos < 16UL)\n      {\n        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));\n        pcrlinepos = 1UL << linepos;\n      }\n      else\n      {\n        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));\n        pcrlinepos = 1UL << (linepos - 16UL);\n      }\n\n      pExtiConfig->PendClearSource = 1UL + ((*regaddr & (pcrlinepos * pcrlinepos * 3UL)) / (pcrlinepos * pcrlinepos));\n    }\n  }\n  else\n  {\n    /* if line wakeup target is not any, then no pend clear source is used  */\n    pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;\n  }\n\n  return HAL_OK;\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_exti.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Register a User WWDG Callback\n  *         To be used instead of the weak (surcharged) predefined callback\n  * @param  hwwdg WWDG handle\n  * @param  CallbackID ID of the callback to be registered\n  *         This parameter can be one of the following values:\n  *           @arg @ref HAL_WWDG_EWI_CB_ID Early WakeUp Interrupt Callback ID\n  *           @arg @ref HAL_WWDG_MSPINIT_CB_ID MspInit callback ID\n  * @param  pCallback pointer to the Callback function\n  * @retval status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_WWDG_RegisterCallback(WWDG_HandleTypeDef *hwwdg, HAL_WWDG_CallbackIDTypeDef CallbackID, pWWDG_CallbackTypeDef pCallback)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  if (pCallback == NULL)\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    switch (CallbackID)\n    {\n      case HAL_WWDG_EWI_CB_ID:\n        hwwdg->EwiCallback = pCallback;\n        break;\n\n      case HAL_WWDG_MSPINIT_CB_ID:\n        hwwdg->MspInitCallback = pCallback;\n        break;\n\n      default:\n        status = HAL_ERROR;\n        break;\n    }\n  }\n\n  return status;\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_wwdg.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Aborts the DMA Transfer.\n  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains\n  *                 the configuration information for the specified DMA Stream.\n  *                   \n  * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is \n  *        effectively disabled is added. If a Stream is disabled \n  *        while a data transfer is ongoing, the current data will be transferred\n  *        and the Stream will be effectively disabled only after the transfer of\n  *        this single data is finished.  \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)", "code": "{\n  /* calculate DMA base and stream number */\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\n  \n  uint32_t tickstart = HAL_GetTick();\n  \n  if(hdma->State != HAL_DMA_STATE_BUSY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\n    \n    /* Process Unlocked */\n    __HAL_UNLOCK(hdma);\n    \n    return HAL_ERROR;\n  }\n  else\n  {\n    /* Disable all the transfer interrupts */\n    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);\n    hdma->Instance->FCR &= ~(DMA_IT_FE);\n    \n    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\n    {\n      hdma->Instance->CR  &= ~(DMA_IT_HT);\n    }\n    \n    /* Disable the stream */\n    __HAL_DMA_DISABLE(hdma);\n    \n    /* Check if the DMA Stream is effectively disabled */\n    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)\n    {\n      /* Check for the Timeout */\n      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\n      {\n        /* Update error code */\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\n        \n        /* Process Unlocked */\n        __HAL_UNLOCK(hdma);\n        \n        /* Change the DMA state */\n        hdma->State = HAL_DMA_STATE_TIMEOUT;\n        \n        return HAL_TIMEOUT;\n      }\n    }\n    \n    /* Clear all interrupt flags at correct offset within the register */\n    regs->IFCR = 0x3FU << hdma->StreamIndex;\n    \n    /* Process Unlocked */\n    __HAL_UNLOCK(hdma);\n    \n    /* Change the DMA state*/\n    hdma->State = HAL_DMA_STATE_READY;\n  }\n  return HAL_OK;\n}", "path": "openmv/src/hal/stm32/f7/src/stm32f7xx_hal_dma.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Start the DMA Transfer with interrupt enabled.\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\n  *                     the configuration information for the specified DMA Stream.  \n  * @param  SrcAddress The source memory Buffer address\n  * @param  DstAddress The destination memory Buffer address\n  * @param  DataLength The length of data to be transferred from source to destination\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  /* calculate DMA base and stream number */\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\n  \n  /* Check the parameters */\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n \n  /* Process locked */\n  __HAL_LOCK(hdma);\n  \n  if(HAL_DMA_STATE_READY == hdma->State)\n  {\n    /* Change DMA peripheral state */\n    hdma->State = HAL_DMA_STATE_BUSY;\n    \n    /* Initialize the error code */\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\n    \n    /* Configure the source, destination address and the data length */\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\n    \n    /* Clear all interrupt flags at correct offset within the register */\n    regs->IFCR = 0x3FU << hdma->StreamIndex;\n    \n    /* Enable Common interrupts*/\n    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;\n    hdma->Instance->FCR |= DMA_IT_FE;\n    \n    if(hdma->XferHalfCpltCallback != NULL)\n    {\n      hdma->Instance->CR  |= DMA_IT_HT;\n    }\n    \n    /* Enable the Peripheral */\n    __HAL_DMA_ENABLE(hdma);\n  }\n  else\n  {\n    /* Process unlocked */\n    __HAL_UNLOCK(hdma);\t  \n    \n    /* Return error status */\n    status = HAL_BUSY;\n  }\n  \n  return status;\n}", "path": "openmv/src/hal/stm32/f7/src/stm32f7xx_hal_dma.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Generate a software interrupt for a dedicated line.\n  * @param  hexti Exti handle.\n  * @retval None.\n  */\n", "func_signal": "void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)", "code": "{\n  __IO uint32_t *regaddr;\n  uint32_t maskline;\n  uint32_t offset;\n\n  /* Check parameters */\n  assert_param(IS_EXTI_LINE(hexti->Line));\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\n\n  /* compute line register offset and line mask */\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\n  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));\n\n  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));\n  *regaddr = maskline;\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_exti.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Register callback for a dedicated Exti line.\n  * @param  hexti Exti handle.\n  * @param  CallbackID User callback identifier.\n  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.\n  * @param  pPendingCbfn function pointer to be stored as callback.\n  * @retval HAL Status.\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  /* Check null pointer */\n  if (hexti == NULL)\n  {\n    return HAL_ERROR;\n  }\n\n  switch (CallbackID)\n  {\n    case  HAL_EXTI_COMMON_CB_ID:\n      hexti->PendingCallback = pPendingCbfn;\n      break;\n\n    default:\n      status = HAL_ERROR;\n      break;\n  }\n\n  return status;\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_exti.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Clear interrupt pending bit of a dedicated line.\n  * @param  hexti Exti handle.\n  * @param  Edge Specify which pending edge as to be clear.\n  *         This parameter can be one of the following values:\n  *           @arg @ref EXTI_TRIGGER_RISING_FALLING\n  *         This parameter is kept for compatibility with other series.\n  * @retval None.\n  */\n", "func_signal": "void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)", "code": "{\n  __IO uint32_t *regaddr;\n  uint32_t maskline;\n  uint32_t offset;\n\n  /* Check parameters */\n  assert_param(IS_EXTI_LINE(hexti->Line));\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\n  assert_param(IS_EXTI_PENDING_EDGE(Edge));\n\n  /* compute line register offset and line mask */\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\n  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));\n\n#if defined(DUAL_CORE)\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\n  {\n    /* Get pending register address */\n    regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\n  }\n  else /* Cortex-M4 */\n  {\n    /* Get pending register address */\n    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));\n  }\n#else\n  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\n#endif /* DUAL_CORE */\n\n  /* Clear Pending bit */\n  *regaddr =  maskline;\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_exti.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Get interrupt pending bit of a dedicated line.\n  * @param  hexti Exti handle.\n  * @param  Edge Specify which pending edge as to be checked.\n  *         This parameter can be one of the following values:\n  *           @arg @ref EXTI_TRIGGER_RISING_FALLING\n  *         This parameter is kept for compatibility with other series.\n  * @retval 1 if interrupt is pending else 0.\n  */\n", "func_signal": "uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)", "code": "{\n  __IO uint32_t *regaddr;\n  uint32_t regval;\n  uint32_t linepos;\n  uint32_t maskline;\n  uint32_t offset;\n\n  /* Check parameters */\n  assert_param(IS_EXTI_LINE(hexti->Line));\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\n  assert_param(IS_EXTI_PENDING_EDGE(Edge));\n\n  /* compute line register offset and line mask */\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\n  linepos = (hexti->Line & EXTI_PIN_MASK);\n  maskline = (1UL << linepos);\n\n#if defined(DUAL_CORE)\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\n  {\n    /* Get pending register address */\n    regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\n  }\n  else /* Cortex-M4 */\n  {\n    /* Get pending register address */\n    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));\n  }\n#else\n  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\n#endif /* DUAL_CORE */\n\n  /* return 1 if bit is set else 0 */\n  regval = ((*regaddr & maskline) >> linepos);\n  return regval;\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_exti.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Returns the DMA Stream base address depending on stream number\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\n  *                     the configuration information for the specified DMA Stream. \n  * @retval Stream base address\n  */\n", "func_signal": "uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)", "code": "{\n  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;\n  \n  /* lookup table for necessary bitshift of flags within status registers */\n  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};\n  hdma->StreamIndex = flagBitshiftOffset[stream_number];\n  \n  if (stream_number > 3U)\n  {\n    /* return pointer to HISR and HIFCR */\n    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);\n  }\n  else\n  {\n    /* return pointer to LISR and LIFCR */\n    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));\n  }\n  \n  return hdma->StreamBaseAddress;\n}", "path": "openmv/src/hal/stm32/f7/src/stm32f7xx_hal_dma.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Initialize the I2C registers according to the specified parameters in I2C_InitStruct.\n  * @param  I2Cx I2C Instance.\n  * @param  I2C_InitStruct pointer to a @ref LL_I2C_InitTypeDef structure.\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS  I2C registers are initialized\n  *          - ERROR  Not applicable\n  */\n", "func_signal": "uint32_t LL_I2C_Init(I2C_TypeDef *I2Cx, LL_I2C_InitTypeDef *I2C_InitStruct)", "code": "{\n  LL_RCC_ClocksTypeDef rcc_clocks;\n\n  /* Check the I2C Instance I2Cx */\n  assert_param(IS_I2C_ALL_INSTANCE(I2Cx));\n\n  /* Check the I2C parameters from I2C_InitStruct */\n  assert_param(IS_LL_I2C_PERIPHERAL_MODE(I2C_InitStruct->PeripheralMode));\n  assert_param(IS_LL_I2C_CLOCK_SPEED(I2C_InitStruct->ClockSpeed));\n  assert_param(IS_LL_I2C_DUTY_CYCLE(I2C_InitStruct->DutyCycle));\n#if  defined(I2C_FLTR_ANOFF)&&defined(I2C_FLTR_DNF)\n  assert_param(IS_LL_I2C_ANALOG_FILTER(I2C_InitStruct->AnalogFilter));\n  assert_param(IS_LL_I2C_DIGITAL_FILTER(I2C_InitStruct->DigitalFilter));\n#endif\n  assert_param(IS_LL_I2C_OWN_ADDRESS1(I2C_InitStruct->OwnAddress1));\n  assert_param(IS_LL_I2C_TYPE_ACKNOWLEDGE(I2C_InitStruct->TypeAcknowledge));\n  assert_param(IS_LL_I2C_OWN_ADDRSIZE(I2C_InitStruct->OwnAddrSize));\n\n  /* Disable the selected I2Cx Peripheral */\n  LL_I2C_Disable(I2Cx);\n\n  /* Retrieve Clock frequencies */\n  LL_RCC_GetSystemClocksFreq(&rcc_clocks);\n\n#if  defined(I2C_FLTR_ANOFF)&&defined(I2C_FLTR_DNF)\n  /*---------------------------- I2Cx FLTR Configuration -----------------------\n   * Configure the analog and digital noise filters with parameters :\n   * - AnalogFilter: I2C_FLTR_ANFOFF bit\n   * - DigitalFilter: I2C_FLTR_DNF[3:0] bits\n   */\n  LL_I2C_ConfigFilters(I2Cx, I2C_InitStruct->AnalogFilter, I2C_InitStruct->DigitalFilter);\n\n#endif\n  /*---------------------------- I2Cx SCL Clock Speed Configuration ------------\n   * Configure the SCL speed :\n   * - ClockSpeed: I2C_CR2_FREQ[5:0], I2C_TRISE_TRISE[5:0], I2C_CCR_FS,\n   *           and I2C_CCR_CCR[11:0] bits\n   * - DutyCycle: I2C_CCR_DUTY[7:0] bits\n   */\n  LL_I2C_ConfigSpeed(I2Cx, rcc_clocks.PCLK1_Frequency, I2C_InitStruct->ClockSpeed, I2C_InitStruct->DutyCycle);\n\n  /*---------------------------- I2Cx OAR1 Configuration -----------------------\n   * Disable, Configure and Enable I2Cx device own address 1 with parameters :\n   * - OwnAddress1:  I2C_OAR1_ADD[9:8], I2C_OAR1_ADD[7:1] and I2C_OAR1_ADD0 bits\n   * - OwnAddrSize:  I2C_OAR1_ADDMODE bit\n   */\n  LL_I2C_SetOwnAddress1(I2Cx, I2C_InitStruct->OwnAddress1, I2C_InitStruct->OwnAddrSize);\n\n  /*---------------------------- I2Cx MODE Configuration -----------------------\n  * Configure I2Cx peripheral mode with parameter :\n   * - PeripheralMode: I2C_CR1_SMBUS, I2C_CR1_SMBTYPE and I2C_CR1_ENARP bits\n   */\n  LL_I2C_SetMode(I2Cx, I2C_InitStruct->PeripheralMode);\n\n  /* Enable the selected I2Cx Peripheral */\n  LL_I2C_Enable(I2Cx);\n\n  /*---------------------------- I2Cx CR2 Configuration ------------------------\n   * Configure the ACKnowledge or Non ACKnowledge condition\n   * after the address receive match code or next received byte with parameter :\n   * - TypeAcknowledge: I2C_CR2_NACK bit\n   */\n  LL_I2C_AcknowledgeNextData(I2Cx, I2C_InitStruct->TypeAcknowledge);\n\n  return SUCCESS;\n}", "path": "openmv/src/hal/stm32/f4/src/stm32f4xx_ll_i2c.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Polling for transfer complete.\n  * @param  hdma          pointer to a DMA_HandleTypeDef structure that contains\n  *                        the configuration information for the specified DMA Stream.\n  * @param  CompleteLevel Specifies the DMA level complete.\n  * @note   The polling mode is kept in this version for legacy. it is recommanded to use the IT model instead.\n  *         This model could be used for debug purpose.\n  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). \n  * @param  Timeout       Timeout duration.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK; \n  uint32_t mask_cpltlevel;\n  uint32_t tickstart = HAL_GetTick(); \n  uint32_t tmpisr;\n  \n  /* calculate DMA base and stream number */\n  DMA_Base_Registers *regs;\n\n  if(HAL_DMA_STATE_BUSY != hdma->State)\n  {\n    /* No transfer ongoing */\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\n    __HAL_UNLOCK(hdma);\n    return HAL_ERROR;\n  }\n\n  /* Polling mode not supported in circular mode and double buffering mode */\n  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n    return HAL_ERROR;\n  }\n  \n  /* Get the level transfer complete flag */\n  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\n  {\n    /* Transfer Complete flag */\n    mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;\n  }\n  else\n  {\n    /* Half Transfer Complete flag */\n    mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;\n  }\n  \n  regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\n  tmpisr = regs->ISR;\n  \n  while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))\n  {\n    /* Check for the Timeout (Not applicable in circular mode)*/\n    if(Timeout != HAL_MAX_DELAY)\n    {\n      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))\n      {\n        /* Update error code */\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\n\n        /* Process Unlocked */\n        __HAL_UNLOCK(hdma);\n        \n        /* Change the DMA state */\n        hdma->State = HAL_DMA_STATE_READY;\n        \n        return HAL_TIMEOUT;\n      }\n    }\n\n    /* Get the ISR register value */\n    tmpisr = regs->ISR;\n\n    if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)\n    {\n      /* Update error code */\n      hdma->ErrorCode |= HAL_DMA_ERROR_TE;\n      \n      /* Clear the transfer error flag */\n      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;\n    }\n    \n    if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)\n    {\n      /* Update error code */\n      hdma->ErrorCode |= HAL_DMA_ERROR_FE;\n      \n      /* Clear the FIFO error flag */\n      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;\n    }\n    \n    if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)\n    {\n      /* Update error code */\n      hdma->ErrorCode |= HAL_DMA_ERROR_DME;\n      \n      /* Clear the Direct Mode error flag */\n      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;\n    }\n  }\n  \n  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)\n  {\n    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)\n    {\n      HAL_DMA_Abort(hdma);\n    \n      /* Clear the half transfer and transfer complete flags */\n      regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;\n    \n      /* Process Unlocked */\n      __HAL_UNLOCK(hdma);\n\n      /* Change the DMA state */\n      hdma->State= HAL_DMA_STATE_READY;\n\n      return HAL_ERROR;\n   }\n  }\n  \n  /* Get the level transfer complete flag */\n  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\n  {\n    /* Clear the half transfer and transfer complete flags */\n    regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;\n    \n    /* Process Unlocked */\n    __HAL_UNLOCK(hdma);\n\n    hdma->State = HAL_DMA_STATE_READY;\n  }\n  else\n  {\n    /* Clear the half transfer flag */\n    regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;\n  }\n  \n  return status;\n}", "path": "openmv/src/hal/stm32/f7/src/stm32f7xx_hal_dma.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/* CONF_PERIPH */\n", "func_signal": "sint8 nmi_get_otp_mac_address(uint8 *pu8MacAddr,  uint8 * pu8IsValid)", "code": "{\n\tsint8 ret;\n\tuint32\tu32RegValue;\n\tuint8\tmac[6];\n\ttstrGpRegs strgp = {0};\n\n\tret = nm_read_reg_with_ret(rNMI_GP_REG_2, &u32RegValue);\n\tif(ret != M2M_SUCCESS) goto _EXIT_ERR;\n\n\tret = nm_read_block(u32RegValue|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));\n\tif(ret != M2M_SUCCESS) goto _EXIT_ERR;\n\tu32RegValue = strgp.u32Mac_efuse_mib;\n\n\tif(!EFUSED_MAC(u32RegValue)) {\n\t\tM2M_DBG(\"Default MAC\\n\");\n\t\tm2m_memset(pu8MacAddr, 0, 6);\n\t\tgoto _EXIT_ERR;\n\t}\n\n\tM2M_DBG(\"OTP MAC\\n\");\n\tu32RegValue >>=16;\n\tret = nm_read_block(u32RegValue|0x30000, mac, 6);\n\tm2m_memcpy(pu8MacAddr,mac,6);\n\tif(pu8IsValid) *pu8IsValid = 1;\n\treturn ret;\n\n_EXIT_ERR:\n\tif(pu8IsValid) *pu8IsValid = 0;\n\treturn ret;\n}", "path": "openmv/src/drivers/winc1500/src/nmasic.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  DeInitializes the DMA peripheral \n  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains\n  *               the configuration information for the specified DMA Stream.  \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)", "code": "{\n  DMA_Base_Registers *regs;\n\n  /* Check the DMA peripheral state */\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  \n  /* Check the DMA peripheral state */\n  if(hdma->State == HAL_DMA_STATE_BUSY)\n  {\n    /* Return error status */\n    return HAL_BUSY;\n  }\n\n  /* Check the parameters */\n  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));\n\n  /* Disable the selected DMA Streamx */\n  __HAL_DMA_DISABLE(hdma);\n\n  /* Reset DMA Streamx control register */\n  hdma->Instance->CR   = 0U;\n\n  /* Reset DMA Streamx number of data to transfer register */\n  hdma->Instance->NDTR = 0U;\n\n  /* Reset DMA Streamx peripheral address register */\n  hdma->Instance->PAR  = 0U;\n\n  /* Reset DMA Streamx memory 0 address register */\n  hdma->Instance->M0AR = 0U;\n  \n  /* Reset DMA Streamx memory 1 address register */\n  hdma->Instance->M1AR = 0U;\n  \n  /* Reset DMA Streamx FIFO control register */\n  hdma->Instance->FCR  = (uint32_t)0x00000021U;\n  \n  /* Get DMA steam Base Address */  \n  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\n  \n  /* Clear all interrupt flags at correct offset within the register */\n  regs->IFCR = 0x3FU << hdma->StreamIndex;\n  \n  /* Clean all callbacks */\n  hdma->XferCpltCallback = NULL;\n  hdma->XferHalfCpltCallback = NULL;\n  hdma->XferM1CpltCallback = NULL;\n  hdma->XferM1HalfCpltCallback = NULL;\n  hdma->XferErrorCallback = NULL;\n  hdma->XferAbortCallback = NULL;  \n\n  /* Reset the error code */\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\n\n  /* Reset the DMA state */\n  hdma->State = HAL_DMA_STATE_RESET;\n\n  /* Release Lock */\n  __HAL_UNLOCK(hdma);\n\n  return HAL_OK;\n}", "path": "openmv/src/hal/stm32/f7/src/stm32f7xx_hal_dma.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Clear whole configuration of a dedicated Exti line.\n  * @param  hexti Exti handle.\n  * @retval HAL Status.\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)", "code": "{\n  __IO uint32_t *regaddr;\n  uint32_t regval;\n  uint32_t linepos;\n  uint32_t maskline;\n  uint32_t offset;\n  uint32_t pcrlinepos;\n\n  /* Check null pointer */\n  if (hexti == NULL)\n  {\n    return HAL_ERROR;\n  }\n\n  /* Check the parameter */\n  assert_param(IS_EXTI_LINE(hexti->Line));\n\n  /* compute line register offset and line mask */\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\n  linepos = (hexti->Line & EXTI_PIN_MASK);\n  maskline = (1UL << linepos);\n\n  /* 1] Clear interrupt mode */\n  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));\n  regval = (*regaddr & ~maskline);\n  *regaddr = regval;\n\n  /* 2] Clear event mode */\n  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));\n  regval = (*regaddr & ~maskline);\n  *regaddr = regval;\n\n#if defined (DUAL_CORE)\n    /* 1] Clear CM4 interrupt mode */\n  regaddr = (__IO uint32_t *)(&EXTI->C2IMR1 + (EXTI_MODE_OFFSET * offset));\n  regval = (*regaddr & ~maskline);\n  *regaddr = regval;\n\n  /* 2] Clear CM4 event mode */\n  regaddr = (__IO uint32_t *)(&EXTI->C2EMR1 + (EXTI_MODE_OFFSET * offset));\n  regval = (*regaddr & ~maskline);\n  *regaddr = regval;\n#endif /* DUAL_CORE */\n\n  /* 3] Clear triggers in case of configurable lines */\n  if ((hexti->Line & EXTI_CONFIG) != 0x00U)\n  {\n    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));\n    regval = (*regaddr & ~maskline);\n    *regaddr = regval;\n\n    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));\n    regval = (*regaddr & ~maskline);\n    *regaddr = regval;\n\n    /* Get Gpio port selection for gpio lines */\n    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)\n    {\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\n\n      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];\n      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));\n      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;\n    }\n  }\n\n  /* 4] Clear D3 Config lines */\n  if ((hexti->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)\n  {\n    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));\n    *regaddr = (*regaddr & ~maskline);\n\n    if(linepos < 16UL)\n    {\n      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));\n      pcrlinepos = 1UL << linepos;\n    }\n    else\n    {\n      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));\n      pcrlinepos = 1UL << (linepos - 16UL);\n    }\n\n    /*Clear D3 PendClear source */\n    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));\n  }\n\n  return HAL_OK;\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_exti.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Store line number as handle private field.\n  * @param  hexti Exti handle.\n  * @param  ExtiLine Exti line number.\n  *         This parameter can be from 0 to @ref EXTI_LINE_NB.\n  * @retval HAL Status.\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_EXTI_LINE(ExtiLine));\n\n  /* Check null pointer */\n  if (hexti == NULL)\n  {\n    return HAL_ERROR;\n  }\n  else\n  {\n    /* Store line number as handle private field */\n    hexti->Line = ExtiLine;\n\n    return HAL_OK;\n  }\n}", "path": "openmv/src/hal/stm32/h7/src/stm32h7xx_hal_exti.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Handles DMA interrupt request.\n  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains\n  *               the configuration information for the specified DMA Stream.  \n  * @retval None\n  */\n", "func_signal": "void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)", "code": "{\n  uint32_t tmpisr;\n  __IO uint32_t count = 0;\n  uint32_t timeout = SystemCoreClock / 9600;\n\n  /* calculate DMA base and stream number */\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\n\n  tmpisr = regs->ISR;\n\n  /* Transfer Error Interrupt management ***************************************/\n  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)\n  {\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)\n    {\n      /* Disable the transfer error interrupt */\n      hdma->Instance->CR  &= ~(DMA_IT_TE);\n      \n      /* Clear the transfer error flag */\n      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;\n      \n      /* Update error code */\n      hdma->ErrorCode |= HAL_DMA_ERROR_TE;\n    }\n  }\n  /* FIFO Error Interrupt management ******************************************/\n  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)\n  {\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)\n    {\n      /* Clear the FIFO error flag */\n      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;\n\n      /* Update error code */\n      hdma->ErrorCode |= HAL_DMA_ERROR_FE;\n    }\n  }\n  /* Direct Mode Error Interrupt management ***********************************/\n  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)\n  {\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)\n    {\n      /* Clear the direct mode error flag */\n      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;\n\n      /* Update error code */\n      hdma->ErrorCode |= HAL_DMA_ERROR_DME;\n    }\n  }\n  /* Half Transfer Complete Interrupt management ******************************/\n  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)\n  {\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)\n    {\n      /* Clear the half transfer complete flag */\n      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;\n      \n      /* Multi_Buffering mode enabled */\n      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)\n      {\n        /* Current memory buffer used is Memory 0 */\n        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)\n        {\n          if(hdma->XferHalfCpltCallback != NULL)\n          {\n            /* Half transfer callback */\n            hdma->XferHalfCpltCallback(hdma);\n          }\n        }\n        /* Current memory buffer used is Memory 1 */\n        else\n        {\n          if(hdma->XferM1HalfCpltCallback != NULL)\n          {\n            /* Half transfer callback */\n            hdma->XferM1HalfCpltCallback(hdma);\n          }\n        }\n      }\n      else\n      {\n        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */\n        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)\n        {\n          /* Disable the half transfer interrupt */\n          hdma->Instance->CR  &= ~(DMA_IT_HT);\n        }\n        \n        if(hdma->XferHalfCpltCallback != NULL)\n        {\n          /* Half transfer callback */\n          hdma->XferHalfCpltCallback(hdma);\n        }\n      }\n    }\n  }\n  /* Transfer Complete Interrupt management ***********************************/\n  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)\n  {\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)\n    {\n      /* Clear the transfer complete flag */\n      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;\n      \n      if(HAL_DMA_STATE_ABORT == hdma->State)\n      {\n        /* Disable all the transfer interrupts */\n        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);\n        hdma->Instance->FCR &= ~(DMA_IT_FE);\n        \n        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\n        {\n          hdma->Instance->CR  &= ~(DMA_IT_HT);\n        }\n\n        /* Clear all interrupt flags at correct offset within the register */\n        regs->IFCR = 0x3FU << hdma->StreamIndex;\n\n        /* Process Unlocked */\n        __HAL_UNLOCK(hdma);\n\n        /* Change the DMA state */\n        hdma->State = HAL_DMA_STATE_READY;\n\n        if(hdma->XferAbortCallback != NULL)\n        {\n          hdma->XferAbortCallback(hdma);\n        }\n        return;\n      }\n\n      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)\n      {\n        /* Current memory buffer used is Memory 0 */\n        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)\n        {\n          if(hdma->XferM1CpltCallback != NULL)\n          {\n            /* Transfer complete Callback for memory1 */\n            hdma->XferM1CpltCallback(hdma);\n          }\n        }\n        /* Current memory buffer used is Memory 1 */\n        else\n        {\n          if(hdma->XferCpltCallback != NULL)\n          {\n            /* Transfer complete Callback for memory0 */\n            hdma->XferCpltCallback(hdma);\n          }\n        }\n      }\n      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */\n      else\n      {\n        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)\n        {\n          /* Disable the transfer complete interrupt */\n          hdma->Instance->CR  &= ~(DMA_IT_TC);\n\n          /* Process Unlocked */\n          __HAL_UNLOCK(hdma);\n\n          /* Change the DMA state */\n          hdma->State = HAL_DMA_STATE_READY;\n        }\n\n        if(hdma->XferCpltCallback != NULL)\n        {\n          /* Transfer complete callback */\n          hdma->XferCpltCallback(hdma);\n        }\n      }\n    }\n  }\n  \n  /* manage error case */\n  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)\n  {\n    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)\n    {\n      hdma->State = HAL_DMA_STATE_ABORT;\n\n      /* Disable the stream */\n      __HAL_DMA_DISABLE(hdma);\n\n      do\n      {\n        if (++count > timeout)\n        {\n          break;\n        }\n      }\n      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);\n\n      /* Process Unlocked */\n      __HAL_UNLOCK(hdma);\n\n      /* Change the DMA state */\n      hdma->State = HAL_DMA_STATE_READY;\n    }\n\n    if(hdma->XferErrorCallback != NULL)\n    {\n      /* Transfer error callback */\n      hdma->XferErrorCallback(hdma);\n    }\n  }\n}", "path": "openmv/src/hal/stm32/f7/src/stm32f7xx_hal_dma.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Check compatibility between FIFO threshold level and size of the memory burst\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\n  *                     the configuration information for the specified DMA Stream. \n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n  uint32_t tmp = hdma->Init.FIFOThreshold;\n  \n  /* Memory Data size equal to Byte */\n  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)\n  {\n    switch (tmp)\n    {\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\n      {\n        status = HAL_ERROR;\n      }\n      break;\n    case DMA_FIFO_THRESHOLD_HALFFULL:\n      if (hdma->Init.MemBurst == DMA_MBURST_INC16)\n      {\n        status = HAL_ERROR;\n      }\n      break;\n    case DMA_FIFO_THRESHOLD_FULL:\n      break;\n    default:\n      break;\n    }\n  }\n  \n  /* Memory Data size equal to Half-Word */\n  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\n  {\n    switch (tmp)\n    {\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\n      status = HAL_ERROR;\n      break;\n    case DMA_FIFO_THRESHOLD_HALFFULL:\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\n      {\n        status = HAL_ERROR;\n      }\n      break;\n    case DMA_FIFO_THRESHOLD_FULL:\n      if (hdma->Init.MemBurst == DMA_MBURST_INC16)\n      {\n        status = HAL_ERROR;\n      }\n      break;   \n    default:\n      break;\n    }\n  }\n  \n  /* Memory Data size equal to Word */\n  else\n  {\n    switch (tmp)\n    {\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\n    case DMA_FIFO_THRESHOLD_HALFFULL:\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\n      status = HAL_ERROR;\n      break;\n    case DMA_FIFO_THRESHOLD_FULL:\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\n      {\n        status = HAL_ERROR;\n      }\n      break;\n    default:\n      break;\n    }\n  } \n  \n  return status; \n}", "path": "openmv/src/hal/stm32/f7/src/stm32f7xx_hal_dma.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "/**\n  * @brief  Set each @ref LL_I2C_InitTypeDef field to default value.\n  * @param  I2C_InitStruct Pointer to a @ref LL_I2C_InitTypeDef structure.\n  * @retval None\n  */\n", "func_signal": "void LL_I2C_StructInit(LL_I2C_InitTypeDef *I2C_InitStruct)", "code": "{\n  /* Set I2C_InitStruct fields to default values */\n  I2C_InitStruct->PeripheralMode  = LL_I2C_MODE_I2C;\n  I2C_InitStruct->ClockSpeed      = 5000U;\n  I2C_InitStruct->DutyCycle       = LL_I2C_DUTYCYCLE_2;\n#if  defined(I2C_FLTR_ANOFF)&&defined(I2C_FLTR_DNF)\n  I2C_InitStruct->AnalogFilter    = LL_I2C_ANALOGFILTER_ENABLE;\n  I2C_InitStruct->DigitalFilter   = 0U;\n#endif\n  I2C_InitStruct->OwnAddress1     = 0U;\n  I2C_InitStruct->TypeAcknowledge = LL_I2C_NACK;\n  I2C_InitStruct->OwnAddrSize     = LL_I2C_OWNADDRESS1_7BIT;\n}", "path": "openmv/src/hal/stm32/f4/src/stm32f4xx_ll_i2c.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "openmv/openmv", "stars": 2252, "license": "mit", "language": "c", "size": 415801}
{"docstring": "// ========================= All callback functions =======================================\n//\n", "func_signal": "static inline float add_uct_prior(ThreadInfo *info, float confidence, int n, int n_parent)", "code": "{\n  // For win rate, we need to put some DCNN prior. The prior will diminish when n is large, but remain strong when n is small.\n  // float online_prior = 1.0 - bl->data.opp_preds[i];\n  /*\n     float winning_rate_with_prior = (s->params.decision_mixture_ratio * confidence + s->params.online_prior_mixture_ratio * online_prior) / n + winning_rate;\n  // Put some noise to make things diverse a bit\n  float this_score = winning_rate_with_prior + C * sqrt(log_n_parent/ n) + 2 * thread_randf(info) * info->s->params.sigma;\n  */\n\n  TreeHandle *s = info->s;\n  float factor = s->params.use_old_uct ? 1.0 / n : sqrt(n_parent) / n;\n\n  // winning_rate_with_prior += (s->params.decision_mixture_ratio * bl->cnn_data.confidences[i] + s->params.online_prior_mixture_ratio * online_prior) / n;\n  float prior = s->params.decision_mixture_ratio * confidence * factor;\n\n  // Put some noise to make things diverse a bit\n  if (s->params.num_virtual_games == 0) {\n    float noise = 2 * thread_randf(info) * s->params.sigma;\n    if (s->params.use_sigma_over_n) prior += noise * factor;\n    else prior += noise;\n  }\n  return prior;\n}", "path": "darkforestGo/mctsv2/playout_callbacks.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// This function should be called when all threads are running.\n// It blocks the current threads until the condition is met from search threads.\n", "func_signal": "static void wait_search_complete(TreeHandle *s)", "code": "{\n  // Wait until the condition is met.\n  sem_wait(&s->sem_search_complete);\n  if (s->params.verbose >= V_INFO) {\n    const char *reason = NULL;\n    switch (s->flag_search_complete) {\n      case SC_NOT_YET:\n        reason = \"SC_NOT_YET\";\n        break;\n      case SC_TIME_OUT:\n        reason = \"SC_TIME_OUT\";\n        break;\n      case SC_DCNN_ROLLOUT_REACHED:\n        reason = \"SC_DCNN_ROLLOUT_REACHED\";\n        break;\n      case SC_TOTAL_ROLLOUT_REACHED:\n        reason = \"SC_TOTAL_ROLLOUT_REACHED\";\n        break;\n      case SC_NO_NEW_DCNN_EVAL:\n        reason = \"SC_NO_NEW_DCNN_EVAL\";\n        break;\n      case SC_SINGLE_MOVE_RETURN:\n        reason = \"SC_SINGLE_MOVE_RETURN\";\n        break;\n      case SC_NO_VALID_MOVE:\n        reason = \"SC_NO_VALID_MOVE\";\n        break;\n      case SC_TIME_LEFT_CLOSE:\n        reason = \"SC_TIME_LEFT_CLOSE\";\n        break;\n      case SC_TIME_HEURISTIC_STAGE1:\n        reason = \"SC_TIME_HEURISTIC_STAGE1\";\n        break;\n      case SC_TIME_HEURISTIC_STAGE2:\n        reason = \"SC_TIME_HEURISTIC_STAGE2\";\n        break;\n      case SC_TIME_HEURISTIC_STAGE3:\n        reason = \"SC_TIME_HEURISTIC_STAGE3\";\n        break;\n      case SC_TIME_HEURISTIC_STAGE4:\n        reason = \"SC_TIME_HEURISTIC_STAGE4\";\n        break;\n      default:\n        fprintf(stderr,\"Error! unknown flag_search_complete = %d\\n\", s->flag_search_complete);\n        error(\"\");\n    }\n\n    fprintf(stderr,\"Search Complete. Reason: %s\\n\", reason);\n  }\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// ============================ Visualization code ================================\n", "func_signal": "Coord pick_best(const TreeHandle *s, const TreeBlock *b, Stone player, float *highest_score, float *win_rate, TreeBlock **best_cursor)", "code": "{\n  // get the child_idx that is (1) not empty and (2) is most visited.\n  Coord best_m = M_PASS;\n  *highest_score = -1.0;\n\n  // Return the best move if the tree is empty.\n  if (b == TP_NULL || b->n == 0) return best_m;\n\n  for (int i = 0; i < b->n; ++i) {\n    Coord m = b->data.moves[i];\n\n    // If this is self-atari, skip this move!\n    // UPDATE: we trust the decision made by MCTS/CNN. Sometime a self atari is a good move.\n    // if (IsSelfAtari(&s->board, &ids, m, player)) continue;\n\n    int this_n = b->data.stats[i].total + 1;\n    float win = b->data.stats[i].black_win;\n    unsigned int n_parent = b->parent->data.stats[b->parent_offset].total;\n    if (player == S_WHITE) win = this_n - win;\n\n    if (this_n == 0) error(\"This_n cannot be zero!\");\n    float winning_rate = ( (float)win + 0.5 ) / this_n;\n\n    // Pick the most visited move.\n    // At the beginning of the game, the tree could be very flat, since no move is particularly good in search.\n    // So the move to be picked could be very random. In this case, we pick the move with the highest cnn_confidence.\n    // float score = this_n + s->params.decision_mixture_ratio * n_parent * b->cnn_data.confidences[i]; // * winning_rate;\n    float score = this_n;\n    /*\n    if (s->params.verbose >= V_DEBUG) {\n      fprintf(stderr,\"[%s]: n = %d, win = %d, winrate = %f, score = %f, cnn_conf = %f\\n\",\n          get_move_str(m, player), this_n, win, winning_rate, score, bl->cnn_data.confidences[cursor.i]);\n    }\n    */\n\n    if (score > *highest_score) {\n      *highest_score = score;\n      *win_rate = winning_rate;\n      best_m = m;\n      if (best_cursor != NULL) {\n        *best_cursor = b->children[i].child;\n      }\n    }\n  }\n  return best_m;\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Free the children of p->root, except for the child exception.\n// Connect the parent of bl with the exception child. If except == TP_NULL, remove all children.\n// Then we starts a few threads to free the tree (also free bl).\n", "func_signal": "void tree_simple_free_except(TreePool *p, TreeBlock *except)", "code": "{\n  TreeBlock *r = p->root->children[0].child;\n  if (r == TP_NULL) {\n    memset(&p->root->data.stats[0], 0, sizeof(Stat));\n    return;\n  }\n\n  // Free the nodes.\n  for (int i = 0; i < r->n; ++i) {\n      if (r->children[i].child != except) {\n        recursive_free(p, r->children[i].child);\n      }\n  }\n\n  // Reconnect. Note this is run in single thread, so order does not matter.\n  p->root->children[0].child = except;\n  if (except != TP_NULL) {\n    float black_win = 0.0;\n    int total = 0;\n    // In this case, we need to recompute the stats.\n    for (int i = 0; i < except->n; ++i) {\n      black_win += except->data.stats[i].black_win;\n      total += except->data.stats[i].total;\n    }\n    p->root->data.stats[0].black_win = black_win;\n    p->root->data.stats[0].total = total;\n\n    except->parent = p->root;\n    except->parent_offset = 0;\n  } else {\n    // Empty the child and reset the statistics.\n    RESET_BIT(p->root->expansion, 0);\n    memset(&p->root->data.stats[0], 0, sizeof(Stat));\n  }\n}", "path": "darkforestGo/mctsv2/tree.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Expand #2:\n//   return if other threads already have tokens and are expanding.\n", "func_signal": "int tree_simple_begin_expand_nowait(TreeBlock* parent, BlockOffset parent_offset, TreeBlock **child)", "code": "{\n  BlockBits expansion_before = __atomic_fetch_or(\n      &parent->expansion,\n      BIT(parent_offset),\n      __ATOMIC_ACQ_REL);\n\n  if (!TEST_BIT(expansion_before, parent_offset)) {\n    *child = NULL;\n    return EXPAND_STATUS_FIRST;  // we've got to do it\n  }\n\n  ChildInfo* cinfo = &parent->children[parent_offset];\n\n  // Wait if no one has done it yet.\n  if ((*child = __atomic_load_n(&cinfo->child, __ATOMIC_ACQUIRE)) == NULL) return EXPAND_STATUS_EXPANDING;\n  else return EXPAND_STATUS_DONE;\n}", "path": "darkforestGo/mctsv2/tree.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "/*\nstatic void show_all_moves(const Board *board, const AllMoves *all_moves) {\n  // Debug: dump all moves.\n  ShowBoard(board, SHOW_LAST_MOVE);\n  fprintf(stderr,\"\\n===========Potential moves ================:\\n\");\n  for (int i = 0; i < all_moves->num_moves; ++i) {\n    fprintf(stderr,\"%s \", get_move_str(all_moves->moves[i], board->_next_player));\n  }\n  fprintf(stderr,\"\\n===========End Potential moves================\\n\");\n  fflush(stdout);\n}\n*/\n", "func_signal": "static void show_all_cnn_moves(const TreeBlock *bl, Stone curr_player)", "code": "{\n  char buf[30];\n  fprintf(stderr,\"==== CNN Move for b = %lx, seq = %ld, status = %d ====\\n\", (uint64_t)bl, bl->cnn_data.seq, bl->cnn_data.evaluated);\n  for (int i = 0; i < bl->n; ++i) {\n      fprintf(stderr,\"%s [%f] \", get_move_str(bl->data.moves[i], curr_player, buf), bl->cnn_data.confidences[i]);\n  }\n  fprintf(stderr,\"\\n==== End CNN Move ==========\\n\");\n  fflush(stdout);\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Expand #1:\n//   wait if other threads already have token. return if this thread is the first.\n", "func_signal": "int tree_simple_begin_expand(TreeBlock* parent, BlockOffset parent_offset, TreeBlock **child)", "code": "{\n  BlockBits expansion_before = __atomic_fetch_or(\n      &parent->expansion,\n      BIT(parent_offset),\n      __ATOMIC_ACQ_REL);\n  if (!TEST_BIT(expansion_before, parent_offset)) {\n    *child = NULL;\n    return EXPAND_STATUS_FIRST;  // we've got to do it\n  }\n\n  ChildInfo* cinfo = &parent->children[parent_offset];\n  TreeBlock* c;\n\n  // Wait if no one has done it yet.\n  if ((c = __atomic_load_n(&cinfo->child, __ATOMIC_ACQUIRE)) == NULL) {\n    // We've got to wait.\n    for (;;) {\n      EventCountKey key = event_count_prepare(&cinfo->event_count);\n      if ((c = __atomic_load_n(&cinfo->child, __ATOMIC_ACQUIRE)) != NULL) {\n        event_count_cancel(&cinfo->event_count);\n        break;\n      }\n      event_count_wait(&cinfo->event_count, key);\n    }\n  }\n\n  *child = c;\n  return EXPAND_STATUS_DONE;\n}", "path": "darkforestGo/mctsv2/tree.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// =================================== Policy\n", "func_signal": "BOOL cnn_policy(ThreadInfo *info, TreeBlock *bl, const Board *board, BlockOffset *offset, TreeBlock **child_chosen)", "code": "{\n  TreeHandle *s = info->s;\n\n  if (bl->terminal_status != S_EMPTY) return FALSE;\n  char buf[30];\n\n  const float C = 1.4142;\n  // Find the node with highest noisy winrate score\n  float best_score = -1.0;\n\n  Stone player = board->_next_player;\n\n  for (int i = 0; i < bl->n; ++i) {\n    float black_win = ((float)bl->data.stats[i].black_win) + 0.5;\n    unsigned int n = bl->data.stats[i].total + 1;\n    unsigned int n_parent = bl->parent->data.stats[bl->parent_offset].total + 1;\n\n    float log_n_parent = log2((float)n_parent);\n    float winning_rate = ((float)black_win) / n;\n    if (player == S_WHITE) winning_rate = 1 - winning_rate;\n\n    // If there is rave open, add rave heuristic.\n    if (s->params.use_rave) {\n      float rave_winning_rate = ((float)bl->data.rave_stats[i].black_win + 0.5) / (bl->data.rave_stats[i].total + 1);\n      if (player == S_WHITE) rave_winning_rate = 1 - rave_winning_rate;\n\n      const float rave_k = 100;\n      const float beta = sqrt(rave_k / (n_parent + rave_k));\n      const float combined_winning_rate = winning_rate * (1 - beta) + rave_winning_rate * beta;\n      PRINT_DEBUG(\"[%d]: %s, win_rate = %f, rave_win_rate = %f, beta = %f, combined_win_rate = %f, n_parent = %d\\n\",\n        i, get_move_str(bl->data.moves[i], player, buf), winning_rate, rave_winning_rate, beta, combined_winning_rate, n_parent);\n\n      winning_rate = combined_winning_rate;\n    }\n\n    float this_score = winning_rate + add_uct_prior(info, bl->cnn_data.confidences[i], n, n_parent);\n\n    // For win rate, we need to put some DCNN prior. The prior will diminish when n is large, but remain strong when n is small.\n    // float winning_rate_with_prior = (s->params.decision_mixture_ratio * bl->cnn_data.confidences[i] + s->params.online_prior_mixture_ratio * online_prior) / n + winning_rate;\n    PRINT_DEBUG(\"[%d]: %s, score = %f, n = %d, n_parent = %d, winning_rate = %f, cnn = %f, score = %f\\n\",\n        i, get_move_str(bl->data.moves[i], player, buf), this_score, n, n_parent, winning_rate, bl->cnn_data.confidences[i], this_score);\n    //\n    if (this_score > best_score) {\n      best_score = this_score;\n      *offset = i;\n      *child_chosen = bl->children[i].child;\n    }\n  }\n  PRINT_DEBUG(\"Best score = %f, best index = %d, best move = %s\\n\", best_score, *offset, get_move_str(bl->data.moves[*offset], player, buf));\n  if (best_score < 0) {\n    // No node is selected.\n    return FALSE;\n  }\n  info->use_cnn ++;\n  return TRUE;\n}", "path": "darkforestGo/mctsv2/playout_callbacks.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Hybrid policy in async mode.\n// If BIT_CNN_RECEIVED is set, then we use cnn confidence.\n// If BIT_CNN_RECEIVED is not set, then we use fast rollout confidence. In this case, if BIT_CNN_SENT is not set, then after policy selection, we will resend the situation to DCNN server.\n", "func_signal": "BOOL async_policy(ThreadInfo *info, TreeBlock *bl, const Board *board, BlockOffset *offset, TreeBlock **child_chosen)", "code": "{\n  TreeHandle *s = info->s;\n\n  if (bl->terminal_status != S_EMPTY) return FALSE;\n  BOOL use_cnn_policy = cnn_data_get_evaluated_bit(&bl->cnn_data, BIT_CNN_RECEIVED);\n  char buf[30];\n\n  const float C = 1.4142;\n  // Find the node with highest noisy winrate score\n  float best_score = -1.0;\n  Stone player = board->_next_player;\n\n  PRINT_DEBUG(\"Async_policy. b = %lx, use_cnn_policy = %s, n = %d\\n\", (uint64_t)bl, STR_BOOL(use_cnn_policy), bl->n);\n  for (int i = 0; i < bl->n; ++i) {\n    float black_win = ((float)bl->data.stats[i].black_win) + 0.5;\n    unsigned int n = bl->data.stats[i].total + 1;\n    unsigned int n_parent = bl->parent->data.stats[bl->parent_offset].total + 1;\n\n    float log_n_parent = log2((float)n_parent);\n    float winning_rate = ((float)black_win) / n;\n    if (player == S_WHITE) winning_rate = 1 - winning_rate;\n\n    float confidence = use_cnn_policy ? bl->cnn_data.confidences[i] : bl->cnn_data.fast_confidences[i];\n    float this_score = winning_rate + add_uct_prior(info, confidence, n, n_parent);\n\n    PRINT_DEBUG(\"[%d]: %s, score = %f, n = %d, n_parent = %d, winning_rate = %f, conf = %f, winning_rate+prior = %f\\n\",\n        i, get_move_str(bl->data.moves[i], player, buf), this_score, n, n_parent, winning_rate, confidence, this_score);\n    //\n    // float this_score = winning_rate + bl->cnn_data.confidences[i] + thread_randf(info) * sigma;\n    // float this_score = winning_rate + thread_randf(info);\n    if (this_score > best_score) {\n      best_score = this_score;\n      *offset = i;\n      *child_chosen = bl->children[i].child;\n    }\n  }\n  PRINT_DEBUG(\"Best score = %f, best index = %d, best move = %s\\n\", best_score, *offset, get_move_str(bl->data.moves[*offset], player, buf));\n\n  if (! s->common_params->cpu_only) {\n    if (use_cnn_policy) {\n      info->use_cnn ++;\n    } else {\n      send_to_cnn(info, bl, board);\n    }\n  }\n  info->use_async ++;\n\n  if (best_score < 0) {\n    // No node is selected.\n    return FALSE;\n  }\n\n  return TRUE;\n}", "path": "darkforestGo/mctsv2/playout_callbacks.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// =============================================== Back propagation.\n", "func_signal": "void threaded_run_bp(ThreadInfo *info, float black_moku, Stone next_player, int end_ply, BOOL board_on_child, BlockOffset child_offset, TreeBlock *b)", "code": "{\n  TreeHandle *s = info->s;\n  TreePool *p = &s->p;\n\n  // Dynkomi is adjusted if the win rate is too high.\n  float komi = s->common_params->komi + s->common_variants->dynkomi;\n  float black_count_playout = sigmoid(black_moku - komi);\n  float black_count;\n\n  // If there is network that predicts moku, then we should combine the results.\n  if (b->has_score && s->params.use_cnn_final_score && end_ply >= s->params.min_ply_to_use_cnn_final_score) {\n    // Final score = final_mixture_ratio * win_rate_prediction + (1.0 - final_mixture_ratio) * playout_result.\n    float cnn_final_playout = sigmoid(b->score - komi);\n    black_count = s->params.final_mixture_ratio * cnn_final_playout + (1 - s->params.final_mixture_ratio) * black_count_playout;\n  } else {\n    black_count = black_count_playout;\n  }\n\n  // Rave moves encoded in the board.\n  int rave_moves[BOUND_COORD];\n  if (s->params.use_rave) memset(rave_moves, 0, sizeof(rave_moves));\n\n  TreeBlock *curr;\n  BlockOffset curr_offset;\n\n  if (board_on_child) {\n    curr = b;\n    curr_offset = child_offset;\n  } else {\n    curr = b->parent;\n    curr_offset = b->parent_offset;\n  }\n\n  // Backprop from b.\n  while (curr != NULL) {\n    Stat* stat = &curr->data.stats[curr_offset];\n\n    // Add total first, otherwise the winning rate might go over 1.\n    __sync_add_and_fetch(&stat->total, 1);\n    inc_atomic_float(&stat->black_win, black_count);\n    // stat->total += 1;\n    // stat->black_win += black_count;\n    // __sync_add_and_fetch(&stat->black_win, black_count);\n\n    // Then update rave, if rave mode is open\n    if (s->params.use_rave) {\n      // Update rave moves.\n      rave_moves[curr->data.moves[curr_offset]] = 1;\n\n      // Loop over existing moves.\n      for (int i = 0; i < curr->n; ++i) {\n        Coord m = curr->data.moves[i];\n        if (rave_moves[m]) {\n          Stat *rave_stat = &curr->data.rave_stats[i];\n          __sync_add_and_fetch(&rave_stat->total, 1);\n          inc_atomic_float(&rave_stat->black_win, black_count);\n          // __sync_add_and_fetch(&rave_stat->black_win, black_count);\n        }\n      }\n    }\n\n    curr_offset = curr->parent_offset;\n    curr = curr->parent;\n  }\n\n  if (s->params.use_online_model) {\n    // Update the online model.\n    Stone player = (board_on_child ? OPPONENT(next_player) : next_player);\n    update_online_model(info, player, b);\n  }\n}", "path": "darkforestGo/mctsv2/playout_callbacks.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Expand the leaf\n", "func_signal": "int expand_leaf(ThreadInfo* info, TreeBlock *parent, BlockOffset parent_offset, const Board* board, BOOL wait_until_expansion_finished, TreeBlock **c)", "code": "{\n  // expand the current tree.\n  TreeHandle *s = info->s;\n  TreePool *p = &s->p;\n\n  PRINT_DEBUG(\"New node. Parent id = %u, parent_offset = %u, expansion = %u, cnn.evaluated = %u\\n\",\n      ID(parent), parent_offset, (unsigned int)parent->expansion, (unsigned int)parent->cnn_data.evaluated);\n\n  int res = wait_until_expansion_finished ? tree_simple_begin_expand(parent, parent_offset, c) : tree_simple_begin_expand_nowait(parent, parent_offset, c);\n  switch (res) {\n    case EXPAND_STATUS_FIRST:\n      // We take the lead and set up the node\n      PRINT_DEBUG(\"We take the lead and set up the node: b2 = %u, b2_offset = %u, expansion = %u, cnn.evaluated = %u\\n\",\n          ID(parent), parent_offset, (unsigned int)parent->expansion, (unsigned int)parent->cnn_data.evaluated);\n\n      // fprintf(stderr,\"info = %lx, board = %lx, p = %lx, parent = %lx, parent_offset = %d\\n\", (uint64_t)info, (uint64_t)board, (uint64_t)p, (uint64_t)parent, parent_offset);\n      *c = tree_simple_g_alloc(p, (void *)info, (void *)board, thread_callback_blocks_init, parent, parent_offset);\n      if (*c == TP_NULL) {\n        fprintf(stderr,\"allocation error, output TP_NULL!\\n\");\n        error(\"\");\n      }\n      info->leaf_expanded ++;\n      PRINT_DEBUG(\"New leaf created!, leaf_expanded = %d\\n\", info->leaf_expanded);\n      return EXPAND_SUCCESS;\n\n    case EXPAND_STATUS_EXPANDING:\n      PRINT_DEBUG(\"Other threads is creating the leaf. b2 = %u, b2_offset = %u, expansion = %u, cnn.evaluated = %u\\n\",\n          ID(parent), parent_offset, (unsigned int)parent->expansion, (unsigned int)parent->cnn_data.evaluated);\n      return EXPAND_OTHER_EXPANDING;\n\n    case EXPAND_STATUS_DONE:\n      return EXPAND_OTHER_FIRST;\n  }\n  return EXPAND_FAILED;\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Debug code to detect any inconsistency.\n", "func_signal": "static void tree_simple_check_one_block(const TreeBlock *root, const TreeBlock *bl)", "code": "{\n  if (bl == TP_NULL) return;\n  // printf(\"Checking: \");\n  // tree_simple_show_block(p, b);\n  for (int i = 0; i < bl->n; ++i) {\n    BOOL has_child = bl->children[i].child != TP_NULL;\n    BOOL has_expansion = TEST_BIT(bl->expansion, i) != 0;\n    if (has_child != has_expansion) error(\"Block [%u] at %d: child = %d while expansion = %d\\n\", ID(bl), i, has_child, has_expansion);\n  }\n  BlockBits mask = (BIT(bl->n) - 1);\n  if (bl->expansion & ~mask) {\n    tree_simple_show_block(bl);\n    error(\"Block [%u] has nonzero expansion outside its size %d. Expansion = %u\\n\", ID(bl), bl->n, bl->expansion);\n  }\n  // Check the connection between its parents node and itself.\n  if (bl->parent == TP_NULL) {\n    if (bl != root) {\n      tree_simple_show_block(bl);\n      error(\"Except for p->root, no other node [%u] could have TP_NULL parent\", ID(bl));\n    }\n  } else {\n    // Check parents.\n    const TreeBlock *parent_slot =\n      bl->parent->children[bl->parent_offset].child;\n    if (parent_slot != bl) {\n      tree_simple_show_block(bl);\n      tree_simple_show_block(bl->parent);\n      error(\"The block [%u]'s parent[%u]' child pointer is zero!\", ID(bl), ID(bl->parent));\n    }\n\n    // Check the statistics, except if the parent is root.\n    float total_black_win = 0;\n    int total = 0;\n    for (int i = 0; i < bl->n; ++i) {\n      // printf(\"Child %d: black_win = %.2f, total = %d\\n\", bl->data.stats[i].black_win, bl->data.stats[i].total);\n      total_black_win += bl->data.stats[i].black_win;\n      total += bl->data.stats[i].total;\n    }\n\n    int recorded_total = bl->parent->data.stats[bl->parent_offset].total;\n    float recorded_black_win =  bl->parent->data.stats[bl->parent_offset].black_win;\n    if (total != recorded_total) {\n      error(\"Block %x [%u]: The computed total [%d] is different from recorded total [%d]!\", (uint64_t)bl, ID(bl), total, recorded_total);\n    }\n    if (total_black_win != recorded_black_win) {\n      error(\"Block %x [%u]: The computed total [%.2f] is different from recorded total [%.2f]!\", (uint64_t)bl, ID(bl), total_black_win, recorded_black_win);\n    }\n  }\n}", "path": "darkforestGo/mctsv2/tree.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// ====================== Main function ======================\n", "func_signal": "void tree_search_init_params(TreeParams *params)", "code": "{\n  memset(params, 0, sizeof(TreeParams));\n\n  // Set a few default parameters.\n  params->max_depth_default_policy = 100000;\n  params->verbose = V_INFO;\n  params->num_tree_thread = 16;\n  params->num_receiver = 4;\n  params->sigma = 0.05;\n  params->use_sigma_over_n = FALSE;\n  params->use_async = FALSE;\n  params->fast_rollout_max_move = 10;\n\n  // No time limit by default.\n  params->time_limit = 0;\n\n  params->num_rollout = 1000;\n  params->num_dcnn_per_move = 1000;\n  params->num_rollout_per_move = 1000;\n  params->min_rollout_peekable = 20000;\n\n  params->expand_n_thres = 0;\n\n  params->rcv_acc_percent_thres = 80;\n  params->rcv_max_num_move = 5;\n  params->rcv_min_num_move = 1;\n  params->decision_mixture_ratio = 0.0;\n\n  params->use_pondering = FALSE;\n  params->single_move_return = FALSE;\n  params->default_policy_choice = DP_PACHI;\n  // Only useful for v2.\n  params->default_policy_sample_topn = -1;\n  params->default_policy_temperature = 1.0;\n  params->life_and_death_mode = FALSE;\n  params->use_tsumego_dcnn = FALSE;\n\n  params->use_rave = FALSE;\n\n  params->use_online_model = FALSE;\n  params->online_model_alpha = 0.0;\n  params->online_prior_mixture_ratio = 0.0;\n  params->use_cnn_final_score = FALSE;\n  params->min_ply_to_use_cnn_final_score = 0;\n  params->final_mixture_ratio = 0.0;\n\n  params->num_virtual_games = 0;\n  params->percent_playout_in_expansion = 0;\n  params->num_playout_per_rollout = 1;\n  params->use_old_uct = FALSE;\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Basic functions to lock.\n", "func_signal": "static int block_all_threads(TreeHandle *s, BOOL print_and_reset_all_stats)", "code": "{\n  int res = THREAD_ALREADY_BLOCKED;\n\n  int blocking_number = __sync_fetch_and_add(&s->all_threads_blocking_count, 1);\n  if (blocking_number == 0) {\n    // Just block. wait until all threads done.\n    // If blocking_number > 0, then all the threads are already blocked. So don't wait.\n    // Whenever we update the board, trigger the semaphone.\n    // Wait until all threads are blocked.\n    sem_wait(&s->sem_all_threads_blocked);\n    // Block all the receivers as well\n    block_all_receivers(s);\n    res = THREAD_NEW_BLOCKED;\n    PRINT_INFO(\"Thread newly blocked!\\n\");\n  } else {\n    PRINT_INFO(\"Thread already blocked!\\n\");\n  }\n\n  if (! print_and_reset_all_stats || s->all_stats_cleared) return res;\n\n  // Reset and print all statistics\n  int cnn_send_infunc = 0;\n  int cnn_send_attempt = 0;\n  int cnn_send_success = 0;\n  int use_ucb = 0;\n  int use_cnn = 0;\n  int use_async = 0;\n  int max_depth = 0;\n  int leaf_expanded = 0;\n  int num_expand_failed = 0;\n  int num_policy_failed = 0;\n  int preempt_playout_count = 0;\n  for (int i = 0; i < s->params.num_tree_thread; ++i) {\n    ThreadInfo *info = &s->infos[i];\n    leaf_expanded += info->leaf_expanded;\n    num_expand_failed += info->num_expand_failed;\n    num_policy_failed += info->num_policy_failed;\n    cnn_send_infunc += info->cnn_send_infunc;\n    cnn_send_attempt += info->cnn_send_attempt;\n    cnn_send_success += info->cnn_send_success;\n    use_ucb += info->use_ucb;\n    use_cnn += info->use_cnn;\n    use_async += info->use_async;\n    preempt_playout_count += info->preempt_playout_count;\n    if (max_depth < info->max_depth) max_depth = info->max_depth;\n    /*\n       PRINT_INFO(\"Thread [%d]: #expanded = %d, #policy_failed = %d, #expand_failed = %d, infunc = %d, attempt = %d, success = %d, #ucb = %d, #cnn = %d, max_depth = %d\\n\",\n       i, info->leaf_expanded, info->num_policy_failed, info->num_expand_failed,\n       info->cnn_send_infunc, info->cnn_send_attempt, info->cnn_send_success,\n       info->use_ucb, info->use_cnn, info->max_depth);\n       */\n\n    info->leaf_expanded = 0;\n    info->num_expand_failed = 0;\n    info->num_policy_failed = 0;\n    info->cnn_send_infunc = 0;\n    info->cnn_send_attempt = 0;\n    info->cnn_send_success = 0;\n    info->use_ucb = 0;\n    info->use_cnn = 0;\n    info->use_async = 0;\n    info->max_depth = 0;\n    info->counter = 0;\n    info->preempt_playout_count = 0;\n  }\n\n  PRINT_INFO(\"Stats: leaf_expanded = %d, #policy_failed = %d, #expand_failed = %d, #preempt_playout_count = %d\\n\",\n      leaf_expanded, num_policy_failed, num_expand_failed, preempt_playout_count);\n  PRINT_INFO(\"Stats [Send] infunc = %d, attempt = %d, success = %d\\n\", cnn_send_infunc, cnn_send_attempt, cnn_send_success);\n  PRINT_INFO(\"Stats [Policy] use_ucb = %d, use_cnn = %d, use_async = %d\\n\", use_ucb, use_cnn, use_async);\n  fprintf(stderr,\"p->root->data.stats[0].total: %d, #rollout: %d, #cnn: %d, max_depth: %d\\n\", s->p.root->data.stats[0].total, s->rollout_count, s->dcnn_count, max_depth);\n\n  // Clear up the model.\n  if (s->params.use_online_model) {\n    fprintf(stderr,\"Online model average error = %f, count = %d\\n\", s->model_acc_err / s->model_count_err, s->model_count_err);\n    memset(s->model_weights, 0, sizeof(s->model_weights));\n    s->model_bias = 0;\n    s->model_acc_err = 0;\n    s->model_count_err = 0;\n  }\n\n  memset(s->move_scores_black, 0, sizeof(s->move_scores_black));\n  memset(s->move_scores_white, 0, sizeof(s->move_scores_white));\n\n  s->rollout_count = 0;\n  s->dcnn_count = 0;\n  s->prev_dcnn_count = 0;\n\n  // Check \"search complete semaphore\", clear it if necessary.\n  int sem_value;\n  sem_getvalue(&s->sem_search_complete, &sem_value);\n  fprintf(stderr,\"Semaphore value: %d\\n\", sem_value);\n  if (sem_value > 0) sem_wait(&s->sem_search_complete);\n  s->flag_search_complete = SC_NOT_YET;\n  s->all_stats_cleared = TRUE;\n\n  // All threads are blocked. Now do your stuff.\n  return res;\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Initialize tree pool\n", "func_signal": "void tree_simple_pool_init(TreePool *p)", "code": "{\n  p->root = (TreeBlock *)malloc(sizeof(TreeBlock));\n  if (p->root == NULL) {\n    error(\"Failed to malloc root!\\n\");\n  }\n  memset(p->root, 0, sizeof(TreeBlock));\n  // Root always have one child.\n  p->root->n = 1;\n\n  p->allocated = 1;\n  p->ever_allocated = 1;\n}", "path": "darkforestGo/mctsv2/tree.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Recursively print stuff\n", "func_signal": "void tree_simple_print_out_impl(FILE* fp, const TreeBlock *bl, int depth, FuncSimpleTreeVisitor visitor)", "code": "{\n  if (bl == TP_NULL) return;\n\n  char *spaces = (char *)malloc(depth + 1);\n  memset(spaces, ' ', depth);\n  spaces[depth] = 0;\n\n  // Visit the current node.\n  fprintf(fp, \"%s{\\n\", spaces);\n  visitor(fp, bl, depth);\n\n  int index = 0;\n  for (int i = 0; i < bl->n; ++i) {\n    if (bl->children[i].child == TP_NULL) continue;\n    if (index > 0) {\n      fprintf(fp, \",\\n\");\n    } else {\n      fprintf(fp, \",\\n%s\\\"children\\\": [\\n\", spaces);\n    }\n    tree_simple_print_out_impl(fp, bl->children[i].child, depth + 2, visitor);\n    index ++;\n  }\n  if (index > 0) fprintf(fp, \"\\n%s]\", spaces);\n  fprintf(fp, \"\\n%s}\", spaces);\n  free(spaces);\n  return;\n}", "path": "darkforestGo/mctsv2/tree.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Call from search threads to notify some condition is met.\n", "func_signal": "static BOOL send_search_complete(TreeHandle *s, int complete_reason)", "code": "{\n  BOOL sent = FALSE;\n  pthread_mutex_lock(&s->mutex_search_complete);\n  // Time to send the semaphore if it is not sent yet.\n  if (s->flag_search_complete == SC_NOT_YET) {\n    sem_post(&s->sem_search_complete);\n    sent = TRUE;\n    s->flag_search_complete = complete_reason;\n  }\n  pthread_mutex_unlock(&s->mutex_search_complete);\n  return sent;\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Leaf expansion.\n// ============================= Expansion Related ==================================\n", "func_signal": "static BOOL send_to_cnn(ThreadInfo *info, TreeBlock *b, const Board *board)", "code": "{\n  // Send the current player to CNN for evaluation.\n  // Check if someone else has sent it.\n  TreeHandle *s = info->s;\n  info->cnn_send_infunc ++;\n\n  // If BIT_CNN_TRY_SEND has been set to 1, then someone else is sending the board, then we return.\n  if (cnn_data_fetch_set_evaluated_bit(&b->cnn_data, BIT_CNN_TRY_SEND)) return FALSE;\n\n  // Otherwise we got the token and send.\n  if (b->cnn_data.seq == s->seq && cnn_data_get_evaluated_bit(&b->cnn_data, BIT_CNN_SENT)) {\n    PRINT_DEBUG(\"b = %lx (%u) is already sent to the server, do not send again!\\n\", (uint64_t)b, ID(b));\n    cnn_data_clear_evaluated_bit(&b->cnn_data, BIT_CNN_TRY_SEND);\n    return FALSE;\n  }\n\n  // If the sequence number is out-of-date, we just clear it.\n  if (b->cnn_data.seq != s->seq) cnn_data_clear_evaluated_bit(&b->cnn_data, BIT_CNN_SENT);\n\n  // Send the message.\n  MBoard mboard;\n  mboard.b = (uint64_t) b;\n  mboard.seq = s->seq;\n  CopyBoard(&mboard.board, board);\n\n/*  ShowBoard(&mboard.board, SHOW_LAST_MOVE);\n  if (info->cnn_send_infunc == 2) {\n    exit(0);\n  }\n*/\n  info->cnn_send_attempt ++;\n\n  b->cnn_data.seq = s->seq;\n  cnn_data_set_evaluated_bit(&b->cnn_data, BIT_CNN_SENT);\n\n  if (s->callbacks.callback_send_board(s->callbacks.context, info->ex_id, &mboard)) {\n    // Note that in asynchronized version, Ideally, setting BIT_CNN_SENT and ExLocalClientSendBoard should be in the critical region.\n    // Otherwise the board might get sent twice. But it should not harm too much.\n    // Save the sent sequence.\n    info->cnn_send_success ++;\n    // Clear the evaluation TRY_SEND bit so that other people can enter the critical session.\n    cnn_data_clear_evaluated_bit(&b->cnn_data, BIT_CNN_TRY_SEND);\n    return TRUE;\n  } else {\n    cnn_data_clear_evaluated_bit(&b->cnn_data, BIT_CNN_SENT);\n    // Release the token so that other thread can resend.\n    cnn_data_clear_evaluated_bit(&b->cnn_data, BIT_CNN_TRY_SEND);\n    return FALSE;\n  }\n}", "path": "darkforestGo/mctsv2/playout_callbacks.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// =================================== Main thread for Monte Carlo Tree Search ===============================\n", "func_signal": "void thread_callback_blocks_init(TreePool *p, TreeBlock *b, void *context, void *context2)", "code": "{\n  // fprintf(stderr,\"Before we do anything...\\n\");\n  // fflush(stdout);\n  ThreadInfo *info = (ThreadInfo *)context;\n  TreeHandle *s = info->s;\n\n  // fprintf(stderr,\"Pass the type conversion...info = %lx\\n\", (uint64_t)info);\n  if (info == NULL) error(\"ThreadInfo cannot be NULL!\");\n  // fflush(stdout);\n  // Set the board hash.\n  const Board *board = (const Board *)context2;\n  // Set the board hash.\n  // b->board_hash = board->hash;\n  // Call the expand function.\n  s->callback_expand(info, board, b);\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "// Return true if we need to exit the loop.\n", "func_signal": "static inline BOOL threaded_block_if_needed(void *ctx)", "code": "{\n  ThreadInfo *info = (ThreadInfo *)ctx;\n  TreeHandle *s = info->s;\n  TreePool *p = &s->p;\n\n  // If all_threads_blocking is true, block here until the tree is updated.\n  int blocking_number = __atomic_load_n(&s->all_threads_blocking_count, __ATOMIC_ACQUIRE);\n  if (blocking_number > 0) {\n    int count = __sync_add_and_fetch(&s->threads_count, 1);\n    if (count == 1) {\n      fprintf(stderr,\"First thread blocked at %lf\\n\", wallclock());\n    }\n    if (count == s->params.num_tree_thread) {\n      fprintf(stderr,\"Last thread blocked at %lf\\n\", wallclock());\n      sem_post(&s->sem_all_threads_blocked);\n    }\n    sem_wait(&s->sem_all_threads_unblocked);\n  }\n  if (s->search_done) return TRUE;\n  return FALSE;\n}", "path": "darkforestGo/mctsv2/tree_search.c", "commit_date": "2016-10-04 00:00:00", "repo_name": "facebookresearch/darkforestGo", "stars": 2104, "license": "other", "language": "c", "size": 607}
{"docstring": "/* Prints error reports to their various files:\n * + stderr: if -results_to_stderr, uses -callstack_style\n * + f_results: if using drsyms, uses -callstack_style\n * + f_global: for postprocessing, uses PRINT_FOR_POSTPROCESS\n * + logfile: if -thread_logs, uses PRINT_FOR_POSTPROCESS\n */\n", "func_signal": "static void\nprint_error_report(void *drcontext, char *buf, size_t bufsz, bool reporting,\n                   error_toprint_t *etp, stored_error_t *err,\n                   error_callstack_t *ecs)", "code": "{\n#ifdef USE_DRSYMS\n    /* First, if using drsyms, print the report with user's -callstack_style to\n     * f_results and stderr if -results_to_stderr.\n     */\n    if (reporting) {\n        bool potential = (err != NULL && err->potential);\n        print_error_to_buffer(buf, bufsz, etp, err, ecs, false/*for log*/);\n        report_error_from_buffer(potential ? f_potential : f_results, buf, false);\n        if (options.results_to_stderr && !potential) {\n            report_error_from_buffer(STDERR, buf, true);\n        }\n    }\n#endif\n\n    /* Next, print to the log to support postprocessing.  Only print suppressed\n     * errors if -log_suppressed_errors or at higher verbosity.\n     */\n    if (etp->errtype < ERROR_MAX_VAL\n        IF_DRSYMS(&& (reporting || options.log_suppressed_errors ||\n                      options.verbose >= 2))) {\n        print_error_to_buffer(buf, bufsz, etp, err, ecs, true/*for log*/);\n        report_error_from_buffer(f_global, buf, false);\n        if (options.thread_logs) {\n            report_error_from_buffer(LOGFILE_GET(drcontext), buf, false);\n        }\n    }\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* On Windows, \"msvcp*.dll\" is the C++ runtime library, and \"msvcr*.dll\" is\n * the C runtime library.  Note that \"msvcirt.dll\" is the IO stream library.\n * C runtime library names include \"msvcr71.dll\", \"msvcrt.dll\", \"msvcrt20.dll\".\n *\n * XXX i#1059: this routine is not very reliable for two reasons: first, there\n * can be multiple libc routines; second, the app can load a libc module after\n * startup.  We could switch to an interval tree that tracks load and unload\n * events for pc_is_in_libc() and try to get rid of assumptions that there's\n * just one libc.\n */\n", "func_signal": "app_pc\nget_libc_base(app_pc *libc_end_out OUT)", "code": "{\n    static app_pc libc_base, libc_end; /* cached values */\n    if (libc_base == NULL) {\n        dr_module_iterator_t *iter;\n        module_data_t *data;\n        iter = dr_module_iterator_start();\n        while (dr_module_iterator_hasnext(iter)) {\n            const char *modname;\n            data = dr_module_iterator_next(iter);\n            modname = dr_module_preferred_name(data);\n            if (modname != NULL) {\n                if (text_matches_pattern(modname,\n                                         IF_WINDOWS_ELSE(\"msvcr*\", \"libc.*\"),\n                                         FILESYS_CASELESS)) {\n#ifdef WINDOWS\n                    /* If we see both msvcrt.dll and MSVCRNN.dll (e.g., MSVCR80.dll),\n                     * we want the latter, as the former is only there b/c of a small\n                     * number of imports from the latter.\n                     */\n                    if (libc_base == NULL ||\n                        !text_matches_pattern(modname, \"msvcrt.dll\", true)) {\n#endif\n                        libc_base = data->start;\n                        libc_end = data->end;\n#ifdef WINDOWS\n                    }\n#endif\n                }\n            }\n            dr_free_module_data(data);\n#ifdef UNIX\n            /* Just take first, in unlikely case there are multiple */\n            if (libc_base != NULL)\n                break;\n#endif\n        }\n        dr_module_iterator_stop(iter);\n        LOG(2, \"libc is \"PFX\"-\"PFX\"\\n\", libc_base, libc_end);\n    }\n    if (libc_end_out != NULL)\n        *libc_end_out = libc_end;\n    return libc_base;\n}", "path": "drmemory/common/heap.c", "commit_date": "2019-03-17 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Walks the heap and calls the \"cb_region\" callback for each heap region or arena\n * and the \"cb_chunk\" callback for each malloc block.\n * For Windows, calls cb_heap for each heap (one heap can contain multiple regions).\n */\n", "func_signal": "void\nheap_iterator(void (*cb_region)(app_pc,app_pc _IF_WINDOWS(HANDLE)),\n              void (*cb_chunk)(app_pc,app_pc)\n              _IF_WINDOWS(void (*cb_heap)(HANDLE)))", "code": "{\n#ifdef WINDOWS\n    /* We have two choices: RtlEnumProcessHeaps or RtlGetProcessHeaps.\n     * The results are identical: the former invokes a callback while\n     * the latter requires a passed-in array.  I've also tried\n     * RtlQueryProcessDebugInformation() and it produces the same\n     * list of heaps.\n     */\n    uint cap_heaps = 10;\n    byte **heaps = global_alloc(cap_heaps*sizeof(*heaps), HEAPSTAT_MISC);\n    uint i;\n    uint num_heaps;\n    void *drcontext = dr_get_current_drcontext();\n\n    /* Make sure we swap to the app PEB, especially if we're invoked\n     * later on for -native_until_thread!\n     *\n     * XXX: we assume that the callbacks during this iterator we won't run any\n     * significant privlib code for which we'd want the private PEB:\n     * if that's not the case we'll have to swap back and forth around\n     * the callbacks.\n     */\n    bool was_app_state = dr_using_app_state(drcontext);\n    if (!was_app_state)\n        dr_switch_to_app_state_ex(drcontext, DR_STATE_PEB);\n\n    num_heaps = RtlGetProcessHeaps(cap_heaps, heaps);\n    LOG(2, \"walking %d heaps\\n\", num_heaps);\n    if (num_heaps > cap_heaps) {\n        global_free(heaps, cap_heaps*sizeof(*heaps), HEAPSTAT_MISC);\n        cap_heaps = num_heaps;\n        heaps = global_alloc(cap_heaps*sizeof(*heaps), HEAPSTAT_MISC);\n        num_heaps = RtlGetProcessHeaps(cap_heaps, heaps);\n        ASSERT(cap_heaps >= num_heaps, \"heap walk error\");\n    }\n    for (i = 0; i < num_heaps; i++) {\n        LOG(2, \"walking heap %d \"PFX\"\\n\", i, heaps[i]);\n# ifdef USE_DRSYMS\n        if (heaps[i] == (byte *) get_private_heap_handle()) {\n            LOG(2, \"skipping private heap \"PFX\"\\n\", heaps[i]);\n            continue;\n        }\n# endif\n        if (cb_heap != NULL)\n            cb_heap(heaps[i]);\n        if (cb_region == NULL && cb_chunk == NULL)\n            continue;\n        walk_individual_heap(heaps[i], cb_region, cb_chunk, NULL);\n    }\n    global_free(heaps, cap_heaps*sizeof(*heaps), HEAPSTAT_MISC);\n    if (!was_app_state)\n        dr_switch_to_dr_state_ex(drcontext, DR_STATE_PEB);\n#elif defined(LINUX)\n    /* Once we have early injection (PR 204554) we won't need this.\n     * For now we assume Lea's dlmalloc, the Linux glibc malloc that uses the\n     * \"boundary tag\" method with the size of a chunk at offset 4\n     * and the 2 lower bits of the size marking mmap and prev-in-use.\n     * FIXME: also support PHKmalloc (though mainly used in BSD libc).\n     */\n    app_pc cur_brk = get_brk(true/*pre-us*/);\n    app_pc heap_start, pc;\n    size_t sz;\n\n    heap_start = get_heap_start();\n    pc = heap_start;\n\n    LOG(1, \"\\nwalking heap from \"PFX\" to \"PFX\"\\n\", heap_start, cur_brk);\n    if (cb_region != NULL && cur_brk > heap_start)\n        cb_region(heap_start, cur_brk);\n    ASSERT(ALIGNED(cur_brk, MALLOC_CHUNK_ALIGNMENT) &&\n           ALIGNED(pc, MALLOC_CHUNK_ALIGNMENT), \"initial brk alignment is off\");\n    while (pc < cur_brk) {\n        app_pc user_start = pc + sizeof(sz)*2;\n        sz = *(size_t *)(pc + sizeof(sz));\n        ASSERT(sz > 0, \"invalid pre-existing heap block\");\n        if (sz == 0)\n            break; /* better than infinite loop */\n        /* mmapped heap chunks should be found by memory_walk().\n         * shouldn't show up in the heap here.  FIXME: we won't add to\n         * the malloc table though: but for now we'll wait until\n         * we hit such a scenario.  Not sure how to fix: try and\n         * guess whether mmap has a heap header I suppose.\n         */\n        ASSERT(!TEST(2, sz), \"mmap chunk shouldn't be in middle of heap\");\n        sz &= ~3;\n        LOG(3, \"  heap chunk \"PFX\"-\"PFX\"\\n\", pc, pc+sz);\n        if (POINTER_OVERFLOW_ON_ADD(pc, sz) || pc + sz >= cur_brk) {\n            /* malloc_usable_size() will crash trying to read next chunk's\n             * prev size field so just quit now\n             */\n            LOG(2, \"    == 'top' of heap\\n\\n\");\n            ASSERT(pc + sz == cur_brk, \"'top' of heap has unexpected size\");\n            break;\n        }\n        /* Whether this chunk is allocated or free is stored in the next\n         * chunk's size field.  Xref PR 474912.\n         */\n        ASSERT(pc + sz + sizeof(sz)*2 < cur_brk, \"'top' of heap missing!\");\n        if (TEST(1, *((size_t*)(pc + sz + sizeof(sz))))) {\n            /* In-use */\n            LOG(2, \"  heap in-use chunk \"PFX\"-\"PFX\"\\n\", pc, pc+sz + sizeof(sz));\n# ifdef DEBUG\n            if (libc_malloc_usable_size != NULL) {\n                size_t check_sz = libc_malloc_usable_size(user_start);\n                /* The prev_size of next chunk is really a usable footer\n                 * for this chunk\n                 */\n                ASSERT(check_sz - sizeof(sz) == (pc + sz - user_start),\n                       \"libc malloc doesn't match assumptions\");\n            }\n# endif\n            if (cb_chunk != NULL)\n                cb_chunk(user_start, pc + sz + sizeof(sz));\n        }\n        pc += sz;\n    }\n    if (cb_region != NULL && ld_so_data_base != NULL) {\n        /* i#1707: ld.so uses its own data segment for initial heap calls */\n        cb_region(ld_so_data_base, ld_so_data_end);\n    }\n#else /* MACOS */\n    /* XXX: switch to methods that don't invoke library routines */\n    vm_address_t *zones;\n    unsigned int num_zones, i;\n# ifdef DEBUG\n    malloc_statistics_t stats;\n# endif\n    enum_data_t data = {cb_region, cb_chunk};\n    kern_return_t kr = malloc_get_all_zones(mach_task_self(), 0, &zones, &num_zones);\n    if (kr != KERN_SUCCESS) {\n        ASSERT(false, \"malloc_get_all_zones failed\");\n        return;\n    }\n    for (i = 0; i < num_zones; i++) {\n        malloc_zone_t *zone = (malloc_zone_t *) zones[i];\n        LOG(2, \"heap zone %d: %p %s\\n\", i, zone, malloc_get_zone_name(zone));\n# ifdef DEBUG\n        malloc_zone_statistics(zone, &stats);\n        LOG(2, \"\\tblocks=%u, used=%zd, max used=%zd, reserved=%zd\\n\",\n            stats.blocks_in_use, stats.size_in_use, stats.max_size_in_use,\n            stats.size_allocated);\n# endif\n        kr = zone->introspect->enumerator\n            (mach_task_self(), (void *) &data, MALLOC_PTR_IN_USE_RANGE_TYPE,\n             (vm_address_t) zone, memory_reader, enum_cb);\n        if (kr != KERN_SUCCESS) {\n            ASSERT(false, \"malloc enumeration failed\");\n        }\n    }\n#endif /* WINDOWS */\n}", "path": "drmemory/common/heap.c", "commit_date": "2019-03-17 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Match a frame's module name against a suppression frame's module name.\n */\n", "func_signal": "static bool\nframe_matches_modname(const error_callstack_t *ecs, uint idx,\n                      const suppress_frame_t *supp)", "code": "{\n    ASSERT(supp != NULL && supp->is_module && supp->modname != NULL,\n           \"Must have a suppression with a modname!\");\n    return text_matches_pattern(symbolized_callstack_frame_modname(&ecs->scs, idx),\n                                supp->modname, FILESYS_CASELESS);\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* restores the values of all counts that are modified in report_leak() to their\n * values as recorded in the last report_leak_stats_checkpoint() call.\n */\n", "func_signal": "void\nreport_leak_stats_revert(void)", "code": "{\n    int set, i;\n    dr_mutex_lock(error_lock);\n    num_leaks_ignored = saved_leaks_ignored;\n    num_suppressed_leaks_user = saved_suppressed_leaks_user;\n    num_suppressed_leaks_default = saved_suppressed_leaks_default;\n    for (set = 0; set < ERROR_SET_NUM; set++) {\n        for (i = ERROR_LEAK; i <= ERROR_MAX_LEAK; i++) {\n            num_unique[set][i] = saved_unique[set][i];\n            num_total[set][i] = saved_total[set][i];\n            num_bytes_leaked[set][i] = saved_bytes_leaked[set][i];\n        }\n        num_total_leaks[set] = saved_total_leaks[set];\n    }\n    num_throttled_leaks = saved_throttled_leaks;\n    /* Clear leak error counts */\n    for (i = 0; i < HASHTABLE_SIZE(error_table.table_bits); i++) {\n        hash_entry_t *he;\n        for (he = error_table.table[i]; he != NULL; he = he->next) {\n            stored_error_t *err = (stored_error_t *) he->payload;\n            if (type_is_leak(err->errtype)) {\n                err->count = 0;\n            }\n        }\n    }\n    dr_mutex_unlock(error_lock);\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Returns true if we have a whole-module suppression of the same type covering\n * the app pc.  Updates the suppression usage counts if it does.\n */\n", "func_signal": "static bool\nreport_in_suppressed_module(uint type, app_loc_t *loc, const char *instruction)", "code": "{\n    suppress_spec_t *spec;\n    bool suppressed = false;\n    const char *preferred_name;\n\n    /* We don't handle leaks because they're not usually suppressed with a\n     * single module wildcard and we need to update the suppression with the\n     * number of bytes leaked.\n     */\n    if (type >= ERROR_LEAK)\n        return false;\n    if (loc->type != APP_LOC_PC || !loc->u.addr.valid)\n        return false;\n    /* Not worth checking for it if we don't have one of these suppressions. */\n    if (!have_module_wildcard)\n        return false;\n    preferred_name = module_lookup_preferred_name(loc->u.addr.pc);\n    if (preferred_name == NULL)\n        return false;\n\n    /* We could hook module load and maintain an rb interval tree of which\n     * regions were suppressed to avoid this extra supp_list iteration.\n     */\n    for (spec = supp_list[type]; spec != NULL; spec = spec->next) {\n        if (is_module_wildcard(spec) &&\n            text_matches_pattern(preferred_name, spec->frames[0].modname,\n                                 FILESYS_CASELESS) &&\n            (spec->instruction == NULL ||\n             text_matches_pattern(instruction, spec->instruction,\n                                  /*ignore_case=*/false))) {\n            suppressed = true;\n            dr_mutex_lock(error_lock);\n            if (spec->is_default)\n                num_suppressions_matched_default++;\n            else\n                num_suppressions_matched_user++;\n            /* spec->count_used is now a total and not unique (i#1527) which is good\n             * b/c we don't have the callstack here to check unique.\n             */\n            spec->count_used++;\n            dr_mutex_unlock(error_lock);\n            LOG(3, \"matched whole module suppression %s\\n\", spec->name);\n       }\n    }\n    return suppressed;\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Only initializes the errtype field */\n", "func_signal": "stored_error_t *\nstored_error_create(uint type)", "code": "{\n    stored_error_t *err = global_alloc(sizeof(*err), HEAPSTAT_REPORT);\n    memset(err, 0, sizeof(*err));\n    ASSERT(type < ERROR_MAX_VAL, \"invalid error type\");\n    err->errtype = type;\n    return err;\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* FIXME: have some report detail threshold or max log file size */\n", "func_signal": "void\nreport_malloc(app_pc start, app_pc end, const char *routine, dr_mcontext_t *mc)", "code": "{\n    DOLOG(3, {\n        void *drcontext = dr_get_current_drcontext();\n        tls_report_t *pt = (tls_report_t *) drmgr_get_tls_field(drcontext, tls_idx_report);\n        ssize_t len = 0;\n        size_t sofar = 0;\n        BUFPRINT(pt->errbuf, pt->errbufsz, sofar, len,\n                 \"%s \"PFX\"-\"PFX\"\\n\", routine, start, end);\n        print_callstack(pt->errbuf, pt->errbufsz, &sofar, mc, false/*no fps*/,\n                        NULL, 0, true, options.callstack_max_frames, NULL, NULL);\n        report_error_from_buffer(LOGFILE_GET(drcontext), pt->errbuf, false);\n    });\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Returns whether the error should be treated as a false positive */\n", "func_signal": "static bool\ncheck_src_whitelist(error_callstack_t *ecs, uint start)", "code": "{\n    uint i;\n    if (options.src_whitelist_frames > 0 && options.src_whitelist[0] != '\\0') {\n        for (i = 0; i < ecs->scs.num_frames && i < options.src_whitelist_frames; i++) {\n            char *file = symbolized_callstack_frame_file(&ecs->scs, start + i);\n            if (file != NULL && text_matches_any_pattern(file, options.src_whitelist,\n                                                         FILESYS_CASELESS))\n                return false; /* report as true positive */\n        }\n        /* if no frame matches whitelist, treat as false positive! */\n        return true;\n    }\n    return false;\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* DEBUG */\n", "func_signal": "void\nreport_child_thread(void *drcontext, thread_id_t child)", "code": "{\n    /* XXX: should these go to results.txt instead?  Will be mixed in\n     * w/ the errors, unless we cache their callstacks somewhere until\n     * the end.\n     */\n    if (options.show_threads || options.show_all_threads) {\n        tls_report_t *pt = (tls_report_t *) drmgr_get_tls_field(drcontext, tls_idx_report);\n        ssize_t len = 0;\n        size_t sofar = 0;\n\n        dr_mcontext_t mc; /* do not init whole thing: memset is expensive */\n        mc.size = sizeof(mc);\n        mc.flags = DR_MC_CONTROL|DR_MC_INTEGER; /* don't need xmm */\n        dr_get_mcontext(drcontext, &mc);\n\n        ASSERT(!options.perturb_only, \"-perturb_only should disable -show_threads\");\n\n        if (options.show_all_threads) {\n            BUFPRINT(pt->errbuf, pt->errbufsz, sofar, len,\n                     \"\\nNEW THREAD: child thread \"TIDFMT\" created by parent thread \"\n                     TIDFMT\" @\", child, dr_get_thread_id(drcontext));\n            print_timestamp_and_thread(pt->errbuf, pt->errbufsz, &sofar, false);\n            BUFPRINT(pt->errbuf, pt->errbufsz, sofar, len, \"\\n\");\n            print_callstack(pt->errbuf, pt->errbufsz, &sofar, &mc, false/*no fps*/,\n                            NULL, 0, false, options.callstack_max_frames, NULL, NULL);\n            BUFPRINT(pt->errbuf, pt->errbufsz, sofar, len, \"\\n\");\n            print_buffer(LOGFILE_GET(drcontext), pt->errbuf);\n        } else {\n            packed_callstack_t *pcs;\n            /* XXX DRi#640: despite DRi#442, pc is no good here: points at wow64\n             * do-syscall, so we pass NULL for app_loc_t and skip top frame\n             */\n            packed_callstack_record(&pcs, &mc, NULL, options.callstack_max_frames);\n            dr_mutex_lock(thread_table_lock);\n            hashtable_add(&thread_table, (void *)(ptr_int_t)child, (void *)pcs);\n            dr_mutex_unlock(thread_table_lock);\n        }\n    }\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* WINDOWS */\n", "func_signal": "static bool\nrb_iter_cb(rb_node_t *node, void *data)", "code": "{\n    heap_iter_t *iter = (heap_iter_t *) data;\n    heap_info_t *info;\n    byte *node_start;\n    size_t node_size;\n    ASSERT(iter != NULL, \"invalid iter param\");\n    rb_node_fields(node, &node_start, &node_size, (void **)&info);\n    return (*iter->iter_cb)(node_start, node_start + node_size, info->flags\n                            _IF_WINDOWS(info->heap), iter->cb_data);\n}", "path": "drmemory/common/heap.c", "commit_date": "2019-03-17 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* up to caller to lock f_results file */\n", "func_signal": "static void\nwrite_suppress_pattern(uint type, symbolized_callstack_t *scs, bool symbolic, uint id)", "code": "{\n    int i;\n    ASSERT(type >= 0 && type < ERROR_MAX_VAL, \"invalid error type\");\n    ASSERT(scs != NULL, \"invalid param\");\n\n    dr_fprintf(f_suppress, \"%s\"NL, suppress_name[type]);\n    dr_fprintf(f_suppress, \"name=Error #%d (update to meaningful name)\"NL, id);\n\n    for (i = 0; i < scs->num_frames; i++) {\n        if (symbolized_callstack_frame_is_module(scs, i)) {\n            if (symbolic) {\n                char *func = symbolized_callstack_frame_func(scs, i);\n                /* i#285: replace ? with * */\n                if (strcmp(func, \"?\") == 0)\n                    func = \"*\";\n                dr_fprintf(f_suppress, \"%s!%s\"NL,\n                           symbolized_callstack_frame_modname(scs, i), func);\n            } else {\n                dr_fprintf(f_suppress, \"<%s+%s>\"NL,\n                           symbolized_callstack_frame_modname(scs, i),\n                           symbolized_callstack_frame_modoffs(scs, i));\n            }\n        } else {\n            dr_fprintf(f_suppress, \"%s\"NL,\n                       symbolized_callstack_frame_func(scs, i));\n        }\n    }\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Returns whether this line is a prefix line before the callstack frames */\n", "func_signal": "static bool\nsuppress_spec_prefix_line(suppress_spec_t *spec, const char *cstack_start,\n                          const char *line_in, size_t line_len, int brace_line,\n                          const char *line, bool *skip OUT)", "code": "{\n    const char *c;\n    if (skip != NULL)\n        *skip = false;\n\n    /* look for top-level spec lines.  we could disallow once callstack starts\n     * but I'm not bothering.\n     */\n    if (brace_line == 1) {\n        /* Valgrind format: this is the name */\n        spec->name = drmem_strdup(line, HEAPSTAT_REPORT);\n        LOG(3, \"  suppression name=\\\"%s\\\"\\n\", spec->name);\n        return true;\n    } else if (brace_line == 2) {\n        /* Valgrind format: this is the error type.\n         * We don't have a perfect mapping here.\n         */\n        ASSERT(spec->type == -1, \"duplicate error types\");\n        /* Support \"Dr.Memory:<type>\" mixed format */\n        spec->type = get_suppress_type(line);\n        if (spec->type > -1) {\n            return true;\n        } else if (strstr(line, \"Memcheck:\") != line) {\n            /* Not a Memcheck type */\n            if (skip != NULL)\n                *skip = true;\n            return true;\n        } else if (strstr(line, \"Memcheck:Addr\") == line ||\n                   strcmp(line, \"Memcheck:Jump\") == 0) {\n            /* We ignore the {1,2,4,8,16} after Addr */\n            spec->type = ERROR_UNADDRESSABLE;\n            return true;\n        } else if (strstr(line, \"Memcheck:Value\") == line ||\n                   strcmp(line, \"Memcheck:Cond\") == 0) {\n            /* We ignore the {1,2,4,8,16} after Value */\n            spec->type = ERROR_UNDEFINED;\n            return true;\n        } else if (strcmp(line, \"Memcheck:Param\") == 0) {\n            /* XXX: is Param used for unaddr syscall params too? */\n            spec->type = ERROR_UNDEFINED;\n            spec->is_memcheck_syscall = true;\n            return true;\n        } else if (strcmp(line, \"Memcheck:Leak\") == 0) {\n            spec->type = ERROR_LEAK;\n            return true;\n        } else if (strcmp(line, \"Memcheck:Free\") == 0) {\n            spec->type = ERROR_INVALID_HEAP_ARG;\n            return true;\n        } else if (strcmp(line, \"Memcheck:Overlap\") == 0) {\n            /* XXX i#156: NYI: stick in warning list for now */\n            spec->type = ERROR_WARNING;\n            return true;\n        } else {\n            report_malformed_suppression(cstack_start, line_in + line_len,\n                                         \"Unknown Valgrind/Memcheck error type\");\n            ASSERT(false, \"should not reach here\");\n        }\n    }\n\n    /* Dr. Memory format, or instruction= added to Valgrind format */\n    c = strchr(line, '=');\n    if (c != NULL) {\n        if (strstr(line, \"name=\") == line) { /* we allow in Valgrind format */\n            spec->name = drmem_strndup(c + 1, line_len - (c + 1 - line), HEAPSTAT_REPORT);\n            LOG(3, \"  suppression name=\\\"%s\\\"\\n\", spec->name);\n            return true;\n        } else if (strstr(line, \"instruction=\") == line) {\n            if (spec->type == ERROR_UNADDRESSABLE || spec->type == ERROR_UNDEFINED ||\n                spec->type == ERROR_WARNING/*prefetch warning*/) {\n                spec->instruction = drmem_strndup(c + 1, line_len - (c + 1 - line),\n                                                  HEAPSTAT_REPORT);\n                LOG(3, \"  instruction=\\\"%s\\\"\\n\", spec->instruction);\n                return true;\n            } else {\n                report_malformed_suppression(cstack_start, line_in + line_len,\n                                             \"Only unaddressable accesses and \"\n                                             \"uninitialized reads can specify an \"\n                                             \"instruction= field\");\n                ASSERT(false, \"should not reach here\");\n            }\n        }\n    }\n    return false;\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Return true if the suppression has a single frame covering an entire module.\n * We can handle single frame expressions that match the current instruction.\n */\n", "func_signal": "static bool\nis_module_wildcard(suppress_spec_t *spec)", "code": "{\n    return (spec->num_frames == 1 &&\n            spec->instruction == NULL &&\n            spec->frames[0].is_module &&\n            spec->frames[0].func != NULL &&\n            spec->frames[0].func[0] == '*' &&\n            spec->frames[0].func[1] == '\\0');\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* PR 535568: report nearest mallocs and whether freed.\n * XXX PR 423750: provide this info on dups not just 1st unique.\n */\n", "func_signal": "static void\nreport_heap_info(IN error_toprint_t *etp, OUT char *buf, size_t bufsz, size_t *sofar,\n                 app_pc addr, size_t sz, bool invalid_heap_arg, bool for_log)", "code": "{\n    void *drcontext = dr_get_current_drcontext();\n    ssize_t len = 0;\n\n    if (etp->on_stack) {\n        /* If the offset is negative, we've messed up somewhere.  We do not want to\n         * report a negative offset (xref crbug.com/594614).  We still report the\n         * unaddr so someone will investigate and report an issue.\n         */\n        if (addr > etp->xsp) {\n            DO_ONCE({\n                WARN(\"WARNING: stack addressability messed up: stack-internal unaddr!\");\n            });\n        } else {\n            BUFPRINT(buf, bufsz, *sofar, len,\n                     \"%s\"PFX\" refers to %d byte(s) beyond the top of the stack \"PFX NL,\n                     INFO_PFX, addr, etp->xsp - addr, etp->xsp);\n        }\n    }\n\n    if (etp->next_start != NULL) {\n        if (etp->next_start - addr+sz < 8 && etp->next_start >= addr+sz) {\n            BUFPRINT(buf, bufsz, *sofar, len,\n                     \"%srefers to %d byte(s) before next malloc\"NL,\n                     INFO_PFX, etp->next_start - addr+sz-1);\n        }\n        if (!options.brief) {\n            BUFPRINT(buf, bufsz, *sofar, len,\n                     \"%snext higher malloc: \"PFX\"-\"PFX\"\"NL,\n                     INFO_PFX, etp->next_start, etp->next_start+etp->next_size);\n        }\n    }\n    if (etp->prev_end != NULL) {\n        if (addr - etp->prev_end < 8) {\n            BUFPRINT(buf, bufsz, *sofar, len,\n                     \"%srefers to %d byte(s) beyond last valid byte in prior malloc\"NL,\n                     /* I used to have +1 to avoid \"0 bytes\" but\n                      * I think that's more confusing then it helps\n                      */\n                     INFO_PFX, addr - etp->prev_end);\n        }\n        if (!options.brief) {\n            BUFPRINT(buf, bufsz, *sofar, len,\n                     \"%sprev lower malloc:  \"PFX\"-\"PFX\"\"NL, INFO_PFX,\n                     etp->prev_end-etp->prev_size, etp->prev_end);\n        }\n    }\n    if (!options.brief && etp->neighbor_pcs != NULL) {\n        symbolized_callstack_t scs;\n        BUFPRINT(buf, bufsz, *sofar, len, \"%sallocated here:\"NL, INFO_PFX);\n        /* to get var-align we need to convert to symbolized.\n         * if we remove var-align feature, should use direct\n         * packed_callstack_print and avoid this extra work\n         */\n        packed_callstack_to_symbolized(etp->neighbor_pcs, &scs);\n        symbolized_callstack_print(&scs, buf, bufsz, sofar,\n                                   info_cstack_pfx, for_log);\n        symbolized_callstack_free(&scs);\n    }\n\n    if (etp->free_start != NULL) {\n        /* Note that due to the finite size of the delayed\n         * free list (and realloc not on it: PR 493888) and\n         * new malloc entries replacing invalid we can't\n         * guarantee to identify use-after-free\n         */\n        app_pc end = etp->free_start + etp->free_size;\n        if (invalid_heap_arg && addr == etp->free_start) {\n            BUFPRINT(buf, bufsz, *sofar, len,\n                     \"%smemory was previously freed\", INFO_PFX);\n        } else if (addr < end && addr+sz >= etp->free_start) {\n            if (options.brief) {\n                BUFPRINT(buf, bufsz, *sofar, len, \"%srefers to \", INFO_PFX);\n                if (addr > etp->free_start) {\n                    BUFPRINT(buf, bufsz, *sofar, len, \"%d byte(s) into \",\n                             addr - etp->free_start);\n                }\n                BUFPRINT(buf, bufsz, *sofar, len, \"memory that was freed\");\n            } else {\n                BUFPRINT(buf, bufsz, *sofar, len,\n                         \"%s\"PFX\"-\"PFX\" overlaps memory \"PFX\"-\"PFX\" that was freed\",\n                         INFO_PFX, addr, addr+sz, etp->free_start, end);\n            }\n        } else {\n            /* Refers to padding or redzone, so an overflow/underflow and not\n             * really a \"use-after-freee\".\n             */\n            if (options.brief)\n                BUFPRINT(buf, bufsz, *sofar, len, \"%srefers to \", INFO_PFX);\n            else {\n                BUFPRINT(buf, bufsz, *sofar, len, \"%s\"PFX\"-\"PFX\" is \", INFO_PFX,\n                         addr, addr+sz);\n            }\n            if (addr < etp->free_start) {\n                BUFPRINT(buf, bufsz, *sofar, len, \"%d byte(s) before \",\n                         etp->free_start - addr);\n            } else {\n                ASSERT(addr >= end, \"check above should have caught this\");\n                /* XXX: not doing the +1: doesn't \"0 bytes beyond\" seem ok? */\n                BUFPRINT(buf, bufsz, *sofar, len, \"%d byte(s) beyond \", addr - end);\n            }\n            if (options.brief)\n                BUFPRINT(buf, bufsz, *sofar, len, \"memory that was freed\");\n            else {\n                BUFPRINT(buf, bufsz, *sofar, len, \"memory \"PFX\"-\"PFX\" that was freed\",\n                         etp->free_start, end);\n            }\n        }\n        if (etp->free_pcs != NULL) {\n            symbolized_callstack_t scs;\n            BUFPRINT(buf, bufsz, *sofar, len, \" here:\"NL);\n            /* Not ideal: see comment about using packed_callstack_print above */\n            packed_callstack_to_symbolized(etp->free_pcs, &scs);\n            symbolized_callstack_print(&scs, buf, bufsz, sofar, info_cstack_pfx,\n                                       for_log);\n            symbolized_callstack_free(&scs);\n        } else\n            BUFPRINT(buf, bufsz, *sofar, len, NL);\n    }\n    /* For wrapping, overlaps_delayed_free gives us a clone */\n    if (etp->free_pcs != NULL && !options.replace_malloc)\n        packed_callstack_free(etp->free_pcs);\n    if (!invalid_heap_arg && alloc_in_heap_routine(drcontext)) {\n        BUFPRINT(buf, bufsz, *sofar, len,\n                 \"%s<inside heap routine and may be false positive: please file a bug>\"NL,\n                 INFO_PFX);\n    }\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* converts a ,-separated string to null-separated w/ double null at end */\n", "func_signal": "static void\nconvert_commas_to_nulls(char *buf, size_t bufsz)", "code": "{\n    /* ensure double-null-terminated */\n    char *c = buf + strlen(buf) + 1;\n    if (c - buf >= bufsz - 1) {\n        ASSERT(false, \",-separated option string is too big\");\n        c -= 2; /* put 2nd null before orig null */\n    }\n    *c = '\\0';\n    /* convert from ,-separated to separate strings */\n    c = strchr(buf, ',');\n    while (c != NULL) {\n        *c = '\\0';\n        c = strchr(c + 1, ',');\n    }\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* pcs is only used for invalid heap args */\n", "func_signal": "static void\nreport_error(error_toprint_t *etp, dr_mcontext_t *mc, packed_callstack_t *pcs)", "code": "{\n    void *drcontext = dr_get_current_drcontext();\n    char fuzzer_buf[FUZZER_MSG_SZ];\n    stored_error_t *err;\n    bool reporting = false;\n    suppress_spec_t *spec;\n    error_callstack_t ecs;\n    char  *errbuf;\n    size_t errbufsz;\n\n#ifdef USE_DRSYMS\n    /* we do not want to use dbghelp at init time b/c that's too early so we\n     * only check symbols and give warnings if we end up reporting something\n     */\n    static bool reported_any_error;\n    if (!reported_any_error) {\n        report_symbol_advice();\n        reported_any_error = true;\n    }\n#endif\n\n    error_callstack_init(&ecs);\n    if (mc != NULL)\n        etp->xsp = (byte *) mc->xsp;\n\n    /* Our report_max throttling is post-dup-checking, to make the option\n     * useful (else if 1st error has 20K instances, won't see any others).\n     * Also, num_reported_errors doesn't count suppressed errors.\n     * If -log_suppressed_errors is on, suppressed errors are printed to the log\n     * until report_max is reached so they can fill it up.\n     * If perf of dup check or suppression matching is an issue\n     * we can add -report_all_max or something.\n     */\n    if (options.report_max >= 0 &&\n        /* We do combined-total throttling to avoid perf hit, at cost of throttling\n         * real errors if too many system-lib.\n         */\n        num_reported_errors[ERROR_NORMAL] + num_reported_errors[ERROR_POTENTIAL] >=\n        options.report_max) {\n        /* XXX: we can't split normal vs potential b/c we don't want to take\n         * the time to symbolize.  We still want a num_reported_errors split\n         * to report whether there are any.\n         */\n        num_throttled_errors++;\n        DO_ONCE({\n            NOTIFY(NL);\n            NOTIFY(\"Reached maximum error report limit (-report_max). \"\n                   \"No further errors will be reported.\"NL);\n            ELOGF(0, f_results, NL\"Reached maximum error report limit (-report_max). \"\n                  \"No further errors will be reported.\"NL);\n        });\n        goto report_error_done;\n    }\n\n    /* Disassemble the current instruction if its generally included in a report\n     * of this type.\n     */\n    if (etp->report_instruction &&\n        etp->loc != NULL && etp->loc->type == APP_LOC_PC) {\n        app_pc cur_pc = loc_to_pc(etp->loc);\n        if (cur_pc != NULL) {\n            /* We need to match old DR disasm style for compatibility */\n            IF_DEBUG(disassemble_set_syntax(DR_DISASM_NO_OPND_SIZE));\n            DR_TRY_EXCEPT(drcontext, {\n                int dis_len;\n                disassemble_to_buffer(drcontext, cur_pc, cur_pc, false/*!show pc*/,\n                                      false/*!show bytes*/, ecs.instruction,\n                                      BUFFER_SIZE_BYTES(ecs.instruction), &dis_len);\n                NULL_TERMINATE_BUFFER(ecs.instruction);\n                if (dis_len > 0) {\n                    /* XXX: should DR provide control over its newline?\n                     * We're not showing bytes, so the only one will be at the\n                     * end, which we fix up.\n                     */\n                    ASSERT(ecs.instruction[dis_len -1] == '\\n', \"missing newline\");\n                    while (dis_len > 0 &&\n                           (ecs.instruction[dis_len - 1] == '\\n' ||\n                            /* remove trailing space(s) too */\n                            ecs.instruction[dis_len - 1] == ' ')) {\n                        ecs.instruction[dis_len - 1] = '\\0';\n                        dis_len--;\n                    }\n                }\n            }, { /* EXCEPT */\n                /* nothing: just skip it */\n            });\n            /* Restore for our debugging logs */\n            IF_DEBUG(disassemble_set_syntax(0));\n        }\n    }\n\n    /* i#838: If we have a wildcard suppression covering this module for this\n     * error type, don't bother taking the stack trace, unless we need to log\n     * it.\n     */\n    if (have_module_wildcard IF_DRSYMS(&& !options.log_suppressed_errors)) {\n        if (report_in_suppressed_module(etp->errtype, etp->loc, ecs.instruction)) {\n            goto report_error_done;\n        }\n    }\n\n    err = record_error(etp->errtype, pcs, etp->loc, mc, false/*no lock */);\n    if (err->count > 1) {\n        if (err->suppressed) {\n            /* Suppression count is total, not unique callstacks (i#1527) */\n            err->suppress_spec->count_used++;\n            if (err->suppressed_by_default)\n                num_suppressions_matched_default++;\n            else\n                num_suppressions_matched_user++;\n        } else {\n            ASSERT(err->id != 0, \"duplicate should have id\");\n            /* We want -pause_at_un* to pause at dups so we consider it \"reporting\" */\n            reporting = true;\n        }\n        if (!options.show_duplicates) {\n            dr_mutex_unlock(error_lock);\n            goto report_error_done;\n        }\n    }\n    ASSERT(options.show_duplicates || err->id == 0, \"non-duplicate should not have id\");\n\n    /* for invalid heap arg, now that we always do our alloc pre-hook in the\n     * callee, the first frame is a retaddr and its line should thus be -1\n     * (except for -replace_malloc)\n     */\n    if (!options.replace_malloc && etp->errtype == ERROR_INVALID_HEAP_ARG)\n        packed_callstack_first_frame_retaddr(err->pcs);\n\n    /* Convert to symbolized so we can compare to suppressions */\n    packed_callstack_to_symbolized(err->pcs, &ecs.scs);\n\n    if (err->count == 1) {\n        reporting = !on_suppression_list(etp->errtype, &ecs, &spec);\n        if (!reporting) {\n            err->suppressed = true;\n            err->suppressed_by_default = spec->is_default;\n            err->suppress_spec = spec;\n            if (err->suppress_spec->is_default)\n                num_suppressions_matched_default++;\n            else\n                num_suppressions_matched_user++;\n            num_total[ERROR_NORMAL][etp->errtype]--;\n        } else if (error_is_likely_false_positive(&ecs, etp)) {\n            err->potential = true;\n            acquire_error_number(err);\n            /* Adjust counter set by record_error() */\n            num_total[ERROR_NORMAL][err->errtype]--;\n            num_total[ERROR_POTENTIAL][err->errtype]++;\n            LOG(2, \"Error starts with system libs => separating as 'potential' error\\n\");\n            /* We count toward the throttle threshold (we document this in -report_max\n             * and -report_leak_max docs).\n             */\n            num_reported_errors[ERROR_POTENTIAL]++;\n        } else {\n            acquire_error_number(err);\n            report_error_suppression(etp->errtype, &ecs, err->id);\n            num_reported_errors[ERROR_NORMAL]++;\n        }\n    }\n    dr_mutex_unlock(error_lock);\n\n    if (fuzzer_error_report(drcontext, fuzzer_buf, FUZZER_MSG_SZ, err->id) > 0)\n        etp->fuzzer_msg = fuzzer_buf;\n    else\n        etp->fuzzer_msg = NULL;\n\n    errbuf = report_alloc_buf(drcontext, &errbufsz);\n    print_error_report(drcontext, errbuf, errbufsz, reporting, etp, err, &ecs);\n    report_free_buf(drcontext, errbuf, errbufsz);\n\n report_error_done:\n    symbolized_callstack_free(&ecs.scs);\n#ifdef WINDOWS\n    /* don't create dumps for dup errors or potential errors */\n    if (TEST(error_mask[etp->errtype], options.dump_at_error_mask) &&\n        reporting && err->count == 1 && !err->potential) {\n        report_core_dump(etp, options.dump_at_error_mask, err->id, mc);\n    }\n#endif\n    if (reporting && !err->potential) { /* don't pause at a \"potential error\" */\n        if (etp->errtype == ERROR_UNADDRESSABLE && options.pause_at_unaddressable)\n            report_pause_at_error(etp, mc, \"pausing at unaddressable access error\");\n        else if (etp->errtype == ERROR_UNDEFINED && options.pause_at_uninitialized)\n            report_pause_at_error(etp, mc, \"pausing at uninitialized read error\");\n        else if (options.pause_at_error)\n            report_pause_at_error(etp, mc, \"pausing at error\");\n        else if (options.crash_at_error ||\n                 (options.crash_at_unaddressable &&\n                  etp->errtype == ERROR_UNADDRESSABLE)) {\n            NOTIFY(NL);\n            NOTIFY(\"TERMINATING PROCESS after first %serror found\"NL,\n                   options.crash_at_error ? \"\" : \"unaddressable \");\n            crash_process();\n            ASSERT_NOT_REACHED();\n        }\n    }\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Returns whether the error should be treated as a false positive */\n/* XXX: i#1454: add per-error blacklist callstack frame depth support */\n", "func_signal": "static bool\ncheck_blacklist_and_whitelist(error_callstack_t *ecs, uint start)", "code": "{\n    uint i;\n    /* We don't support combining black + white: for us, if white is set,\n     * we only report what's on white and ignore black.\n     * XXX: I'd report a usage error if user sets both, except\n     * currently the blacklist default is passed in from frontend\n     * (for ease of getting $SYSTEMROOT env var).\n     */\n    if (options.lib_whitelist_frames > 0 && options.lib_whitelist[0] != '\\0') {\n        for (i = 0; i < ecs->scs.num_frames && i < options.lib_whitelist_frames; i++) {\n            per_callstack_module_t *mod = (per_callstack_module_t *)\n                symbolized_callstack_frame_data(&ecs->scs, start + i);\n            if (mod != NULL && mod->on_whitelist)\n                /* report as true positive, unless not on -src_whitelist */\n                return check_src_whitelist(ecs, start);\n        }\n        /* if no frame matches whitelist, treat as false positive! */\n        return true;\n    }\n    if (options.src_whitelist_frames > 0 && options.src_whitelist[0] != '\\0')\n        return check_src_whitelist(ecs, start);\n    if (options.lib_blacklist_frames > 0 && options.lib_blacklist[0] != '\\0') {\n        for (i = 0; i < ecs->scs.num_frames && i < options.lib_blacklist_frames; i++) {\n            per_callstack_module_t *mod = (per_callstack_module_t *)\n                symbolized_callstack_frame_data(&ecs->scs, start + i);\n            if (mod == NULL || !mod->on_blacklist)\n                break;\n        }\n        /* if all frames match blacklist, treat as false positive! */\n        return (i > 0 && i >= options.lib_blacklist_frames);\n    }\n    return false;\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* PR 535568: report nearest mallocs and whether freed.\n * Stores results in etp fields which the caller must zero ahead of time.\n * The results are then printed in report_heap_info().\n * This two-part scheme allows putting heap info in the error title (i#1593).\n */\n", "func_signal": "static void\ngather_heap_info(INOUT error_toprint_t *etp, app_pc addr, size_t sz)", "code": "{\n    byte *start, *end;\n    ssize_t size;\n    bool found = false;\n\n    if (!is_in_heap_region(addr)) {\n        etp->on_heap = false;\n        if (etp->xsp != NULL) {\n            etp->stack_size = allocation_size(etp->xsp, &etp->stack_base);\n            if (addr >= etp->stack_base && addr+sz < etp->stack_base+etp->stack_size)\n                etp->on_stack = true;\n        }\n        return;\n    }\n    etp->on_heap = true;\n\n    /* I measured replacing the malloc hashtable with an interval tree\n     * and the cost is noticeable on heap-intensive benchmarks, so we\n     * instead use shadow values to find malloc boundaries\n     */\n    /* We don't walk more than PAGE_SIZE: FIXME: make larger? */\n    for (end = addr+sz; end != NULL && end < addr+sz + PAGE_SIZE; ) {\n        if (MAP_4B_TO_1B) {\n            /* granularity is 4 so don't report tail of dword of bad ref (i#622) */\n            end = (byte *)ALIGN_FORWARD(end, 4);\n        }\n        if (options.shadowing &&\n            !shadow_check_range(end, PAGE_SIZE, SHADOW_UNADDRESSABLE,\n                                &start, NULL, NULL)) {\n            LOG(3, \"report_heap_info: next addressable=\"PFX\"\\n\", start);\n            size = malloc_chunk_size((byte*)ALIGN_FORWARD(start, MALLOC_CHUNK_ALIGNMENT));\n            if (size <= -1) {\n                /* An earlier unaddr adjacent to real malloc could\n                 * have marked as addr so try align-8 forward as our\n                 * loop will miss that if all addr in between\n                 */\n                start = (byte*) ALIGN_FORWARD(start+1, MALLOC_CHUNK_ALIGNMENT);\n                size = malloc_chunk_size(start);\n            }\n            if (size > -1) {\n                found = true;\n                /* we don't have the malloc lock so races could result in\n                 * inaccurate adjacent malloc info: only print if accurate\n                 */\n                if (start >= addr+sz) {\n                    etp->next_start = start;\n                    etp->next_size = size;\n                }\n                break;\n            } /* else probably an earlier unaddr error, for which we marked\n               * the memory as addressable!\n               */\n            end = shadow_next_dword((byte *)ALIGN_FORWARD(start, 4),\n                                    addr+sz + PAGE_SIZE, SHADOW_UNADDRESSABLE);\n            /* end will be NULL on failure which we check in loop bounds */\n        } else\n            break;\n    }\n    /* If we can't find a higher malloc better to not print anything since we're\n     * using heuristics and could be wrong (if we had rbtree I'd print \"no higher\")\n     */\n    /* i#1145: we need an explicit check for 0-sized mallocs */\n    size = malloc_chunk_size((byte *)ALIGN_BACKWARD(addr, MALLOC_CHUNK_ALIGNMENT));\n    if (size > -1) {\n        found = true;\n        etp->prev_end = (byte *)ALIGN_BACKWARD(addr, MALLOC_CHUNK_ALIGNMENT) + size;\n        etp->prev_size = size;\n    }\n    for (start = addr; etp->prev_end == NULL && start > addr - PAGE_SIZE; ) {\n        if (options.shadowing &&\n            !shadow_check_range_backward(start, PAGE_SIZE,\n                                         SHADOW_UNADDRESSABLE, &end)) {\n            LOG(3, \"report_heap_info: prev addressable=\"PFX\"\\n\", end);\n            start = (byte *) ALIGN_BACKWARD(end, 4);\n            start = shadow_prev_dword(start, start - PAGE_SIZE, SHADOW_UNADDRESSABLE);\n            LOG(3, \"\\tfrom there, prev unaddressable=\"PFX\"\\n\", start);\n            if (start != NULL) {\n                start += 4; /* move to start of addressable */\n                size = malloc_chunk_size(start);\n                if (size <= -1) {\n                    /* An earlier unaddr adjacent to real malloc could\n                     * have marked as addr so try align-8 back as our\n                     * loop will miss that if all addr in between\n                     */\n                    start = (byte*) ALIGN_BACKWARD(start-1, MALLOC_CHUNK_ALIGNMENT);\n                    size = malloc_chunk_size(start);\n                }\n                if (size > -1) {\n                    found = true;\n                    /* we don't have the malloc lock so races could result in\n                     * inaccurate adjacent malloc info: only print if accurate\n                     */\n                    if (start + size <= addr) {\n                        etp->prev_end = start + size;\n                        etp->prev_size = size;\n                    }\n                    break;\n                } /* else probably an earlier unaddr error, for which we marked\n                   * the memory as addressable!\n                   */\n            }\n        } else\n            break;\n    }\n    /* in pattern mode, we walk the whole hashtable to find the region */\n    if (options.pattern != 0 && options.redzone_size > 0 &&\n        region_in_redzone(addr, sz, &etp->neighbor_pcs, &start, &end, NULL, NULL)) {\n        if (addr >= end)\n            etp->prev_end = end;\n        else\n            etp->next_start = start;\n        etp->prev_size = (end - start);\n    }\n\n    /* Look at both delay free list and at malloc entries marked\n     * invalid.  The latter will find frees beyond the limit of the\n     * delay list as well as free-by-realloc (xref i#69: we now\n     * replace realloc so realloc frees will be on the queue).\n     */\n    found = overlaps_delayed_free(addr, addr+sz, &start, &end, &etp->free_pcs,\n                                  /* While it would be nice to include\n                                   * free-list chunks, we don't want to report\n                                   * on a former redzone in a coalesced chunk,\n                                   * so we limit to delayed chunks.\n                                   */\n                                  true);\n    if (!found && etp->next_start != NULL) {\n        /* Heuristic: try 8-byte-aligned ptrs between here and valid mallocs */\n        for (start = (byte *) ALIGN_FORWARD(addr, MALLOC_CHUNK_ALIGNMENT);\n             start < addr+sz && start < etp->next_start;\n             start += MALLOC_CHUNK_ALIGNMENT) {\n            size = malloc_chunk_size_invalid_only(start);\n            if (size > -1) {\n                found = true;\n                end = start + size;\n                break;\n            }\n        }\n    }\n    if (!found && etp->prev_end != NULL) {\n        /* Heuristic: try 8-byte-aligned ptrs between here and valid mallocs */\n        for (start = (byte *) ALIGN_BACKWARD(addr, MALLOC_CHUNK_ALIGNMENT);\n             start > etp->prev_end; start -= MALLOC_CHUNK_ALIGNMENT) {\n            size = malloc_chunk_size_invalid_only(start);\n            if (size > -1) {\n                end = start + size;\n                if (end > addr)\n                    found = true;\n                break;\n            }\n        }\n    }\n    /* We can't assert anything about end vs addr as there could be a lot of\n     * padding on a realloc-shrunk object (i#1232).\n     */\n    ASSERT(!found || addr+sz >= start - options.redzone_size,\n           \"bug in delay free overlap calc\");\n    if (found) {\n        /* For the Note labels, we do want to mention overlap with freed redzones,\n         * but we try to avoid overlap with memalign pre-padding (i#94).\n         */\n        if (!options.delay_frees_stack || etp->free_pcs != NULL) {\n            etp->free_start = start;\n            etp->free_size = end - start;\n        }\n        /* Don't label an access to a freed redzone as a use-after-free, as\n         * it can easily be an underflow from an adjacent live malloc.\n         * We'll still list it as \"N bytes beyond memory that was freed\".\n         * We do want to include access to freed padding.\n         *\n         * Also don't label a free list entry without a callstack as a\n         * use-after-free, as it could be an artificial free from something\n         * like the pre-alloc padding for memalign (i#94).\n         * If !options.delay_frees_stack we label it anyway: better to properly\n         * label real use-after-free and have bad labeling for rare memalign\n         * underflow.\n         */\n        if (addr < (byte *) ALIGN_FORWARD(end, MALLOC_CHUNK_ALIGNMENT) &&\n            addr+sz >= etp->free_start &&\n            (!options.delay_frees_stack || etp->free_pcs != NULL))\n            etp->use_after_free = true;\n    }\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* Returns whether to keep the suppression, based on this frame */\n", "func_signal": "static bool\nsuppress_spec_add_frame(suppress_spec_t *spec, const char *cstack_start,\n                        const char *line_in, size_t line_len, int brace_line)", "code": "{\n    suppress_frame_t *frame;\n    IF_NOT_DRSYMS(bool has_symbols = false;)\n    const char *line;\n    bool skip_supp = false;\n\n    /* make a local copy that ends in \\0 so we can use strchr, etc. */\n    line = drmem_strndup(line_in, line_len, HEAPSTAT_REPORT);\n\n    if (suppress_spec_prefix_line(spec, cstack_start, line_in, line_len,\n                                  brace_line, line, &skip_supp))\n        goto add_frame_done;\n\n    spec->num_frames++;\n    if (spec->num_frames >= options.callstack_max_frames) {\n        /* we truncate suppression callstacks to match requested max */\n        DO_ONCE({\n            WARN(\"WARNING: requested max frames truncates suppression callstacks\\n\");\n        });\n        goto add_frame_done;\n    }\n\n    frame = global_alloc(sizeof(*frame), HEAPSTAT_REPORT);\n    memset(frame, 0, sizeof(*frame));\n\n    if (brace_line > -1) { /* Valgrind format */\n        if (strstr(line, \"fun:\") == line) {\n            /* Valgrind format fun:sym => *!sym */\n            /* FIXME i#282: Valgrind C++ symbols are mangled.  We need to note\n             * whether any suppression of a particular type has Valgrind\n             * suppressions, and if so, make both a mangled and unmangled version\n             * of the callstack.  We do not support mixed Valgrind and DrMem\n             * frames within one callstack.  If there are no wildcards in the\n             * frames, we could unmangle here (requires DRi#545).\n             */\n            IF_NOT_DRSYMS(has_symbols = true;)\n            frame->is_module = true;\n            frame->modname = drmem_strdup(\"*\", HEAPSTAT_REPORT);\n            frame->func = drmem_strdup(line + strlen(\"fun:\"), HEAPSTAT_REPORT);\n        } else if (strstr(line, \"obj:\") == line) {\n            /* Valgrind format obj:mod => mod!* */\n            IF_NOT_DRSYMS(has_symbols = true;)\n            frame->is_module = true;\n            frame->modname = drmem_strdup(line + strlen(\"obj:\"), HEAPSTAT_REPORT);\n            frame->func = drmem_strdup(\"*\", HEAPSTAT_REPORT);\n        } else if (strstr(line, \"...\") == line) {\n            frame->is_ellipsis = true;\n        } else if (strstr(line, \"*\") == line) {\n            frame->is_star = true;\n        } else if (spec->is_memcheck_syscall && spec->num_frames == 1) {\n            /* 1st frame of Memcheck:Param can be syscall name + args.\n             * Often has params which we don't want: \"epoll_ctl(epfd)\"\n             */\n            const char *stop = strchr(line, '(');\n            ASSERT(!frame->is_module, \"incorrect initialization\");\n            frame->func = drmem_strndup(line_in,\n                                        (stop != NULL) ? stop - line: line_len,\n                                        HEAPSTAT_REPORT);\n        } else {\n            report_malformed_suppression(cstack_start, line_in + line_len,\n                                         \"Unknown frame in Valgrind-style callstack\");\n            ASSERT(false, \"should not reach here\");\n        }\n    } else if (line[0] == '<' && strchr(line, '+') != NULL &&\n               /* we assume module doesn't have ! in its name */\n               strchr(line, '>') != NULL && strchr(line, '!') == NULL) {\n        const char *plus = strchr(line, '+');\n        frame->is_module = true;\n        frame->modname = drmem_strndup(line + 1/*skip '<'*/, plus - (line + 1),\n                                       HEAPSTAT_REPORT);\n        frame->modoffs = drmem_strndup(plus + 1, strchr(line, '>') - (plus + 1),\n                                       HEAPSTAT_REPORT);\n        if (strlen(frame->modoffs) < 3 ||\n            frame->modoffs[0] != '0' ||\n            frame->modoffs[1] != 'x') {\n            report_malformed_suppression(cstack_start, line_in + line_len,\n                                         INCORRECT_FRAME_MSG);\n            ASSERT(false, \"should not reach here\");\n        }\n    } else if (strchr(line, '!') != NULL && line[0] != '<') {\n        /* note that we can't exclude any + (\"operator+\") or < (templates) */\n        const char *bang = strchr(line, '!');\n        IF_NOT_DRSYMS(has_symbols = true;)\n        frame->is_module = true;\n        frame->modname = drmem_strndup(line, bang - line, HEAPSTAT_REPORT);\n        if (strstr(bang + 1, \"...\") == bang + 1) {\n            frame->is_ellipsis = true;\n        } else {\n            frame->func = drmem_strndup(bang + 1, line_len - (bang + 1 - line),\n                                        HEAPSTAT_REPORT);\n        }\n    } else if (strcmp(line, \"<not in a module>\") == 0) {\n        ASSERT(!frame->is_module, \"incorrect initialization\");\n        frame->func = drmem_strndup(line_in, line_len, HEAPSTAT_REPORT);\n    } else if (strcmp(line, \"...\") == 0) {\n        frame->is_ellipsis = true;\n    } else if (strcmp(line, \"*\") == 0) {\n        frame->is_star = true;\n    } else if (strstr(line, \"system call \") != NULL) {\n        ASSERT(!frame->is_module, \"incorrect initialization\");\n        frame->func = drmem_strndup(line_in, line_len, HEAPSTAT_REPORT);\n    } else {\n        report_malformed_suppression(cstack_start, line_in + line_len,\n                                     INCORRECT_FRAME_MSG);\n        ASSERT(false, \"should not reach here\");\n    }\n\n     DOLOG(3, {\n         suppress_frame_print(LOGFILE_LOOKUP(), frame, \"  added suppression frame\");\n     });\n\n    /* insert */\n    if (spec->last_frame != NULL)\n        spec->last_frame->next = frame;\n    spec->last_frame = frame;\n    if (spec->frames == NULL)\n        spec->frames = frame;\n\n add_frame_done:\n    global_free((byte *)line, strlen(line) + 1, HEAPSTAT_REPORT);\n    return !skip_supp && IF_DRSYMS_ELSE(true, !has_symbols);\n}", "path": "drmemory/drmemory/report.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "DynamoRIO/drmemory", "stars": 2309, "license": "other", "language": "c", "size": 8222}
{"docstring": "/* This function polls the clients using read() in order to receive new\n * messages from the net.\n *\n * The message is supposed to be separated by the next message by the\n * separator 'sep', that is a null-terminated C string.\n *\n * Every full message received is decoded and passed to the higher layers\n * calling the function 'handler'.\n *\n * The handelr returns 0 on success, or 1 to signal this function we\n * should close the connection with the client in case of non-recoverable\n * errors. */\n", "func_signal": "void modesReadFromClient(struct client *c, char *sep,\n                         int(*handler)(struct client *))", "code": "{\n    while(1) {\n        int left = MODES_CLIENT_BUF_SIZE - c->buflen;\n        int nread = read(c->fd, c->buf+c->buflen, left);\n        int fullmsg = 0;\n        int i;\n        char *p;\n\n        if (nread <= 0) {\n            if (nread == 0 || errno != EAGAIN) {\n                /* Error, or end of file. */\n                modesFreeClient(c->fd);\n            }\n            break; /* Serve next client. */\n        }\n        c->buflen += nread;\n\n        /* Always null-term so we are free to use strstr() */\n        c->buf[c->buflen] = '\\0';\n\n        /* If there is a complete message there must be the separator 'sep'\n         * in the buffer, note that we full-scan the buffer at every read\n         * for simplicity. */\n        while ((p = strstr(c->buf, sep)) != NULL) {\n            i = p - c->buf; /* Turn it as an index inside the buffer. */\n            c->buf[i] = '\\0'; /* Te handler expects null terminated strings. */\n            /* Call the function to process the message. It returns 1\n             * on error to signal we should close the client connection. */\n            if (handler(c)) {\n                modesFreeClient(c->fd);\n                return;\n            }\n            /* Move what's left at the start of the buffer. */\n            i += strlen(sep); /* The separator is part of the previous msg. */\n            memmove(c->buf,c->buf+i,c->buflen-i);\n            c->buflen -= i;\n            c->buf[c->buflen] = '\\0';\n            /* Maybe there are more messages inside the buffer.\n             * Start looping from the start again. */\n            fullmsg = 1;\n        }\n        /* If our buffer is full discard it, this is some badly\n         * formatted shit. */\n        if (c->buflen == MODES_CLIENT_BUF_SIZE) {\n            c->buflen = 0;\n            /* If there is garbage, read more to discard it ASAP. */\n            continue;\n        }\n        /* If no message was decoded process the next client, otherwise\n         * read more data from the same client. */\n        if (!fullmsg) break;\n    }\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* =============================== RTLSDR handling ========================== */\n", "func_signal": "void modesInitRTLSDR(void)", "code": "{\n    int j;\n    int device_count;\n    int ppm_error = 0;\n    char vendor[256], product[256], serial[256];\n\n    device_count = rtlsdr_get_device_count();\n    if (!device_count) {\n        fprintf(stderr, \"No supported RTLSDR devices found.\\n\");\n        exit(1);\n    }\n\n    fprintf(stderr, \"Found %d device(s):\\n\", device_count);\n    for (j = 0; j < device_count; j++) {\n        rtlsdr_get_device_usb_strings(j, vendor, product, serial);\n        fprintf(stderr, \"%d: %s, %s, SN: %s %s\\n\", j, vendor, product, serial,\n            (j == Modes.dev_index) ? \"(currently selected)\" : \"\");\n    }\n\n    if (rtlsdr_open(&Modes.dev, Modes.dev_index) < 0) {\n        fprintf(stderr, \"Error opening the RTLSDR device: %s\\n\",\n            strerror(errno));\n        exit(1);\n    }\n\n    /* Set gain, frequency, sample rate, and reset the device. */\n    rtlsdr_set_tuner_gain_mode(Modes.dev,\n        (Modes.gain == MODES_AUTO_GAIN) ? 0 : 1);\n    if (Modes.gain != MODES_AUTO_GAIN) {\n        if (Modes.gain == MODES_MAX_GAIN) {\n            /* Find the maximum gain available. */\n            int numgains;\n            int gains[100];\n\n            numgains = rtlsdr_get_tuner_gains(Modes.dev, gains);\n            Modes.gain = gains[numgains-1];\n            fprintf(stderr, \"Max available gain is: %.2f\\n\", Modes.gain/10.0);\n        }\n        rtlsdr_set_tuner_gain(Modes.dev, Modes.gain);\n        fprintf(stderr, \"Setting gain to: %.2f\\n\", Modes.gain/10.0);\n    } else {\n        fprintf(stderr, \"Using automatic gain control.\\n\");\n    }\n    rtlsdr_set_freq_correction(Modes.dev, ppm_error);\n    if (Modes.enable_agc) rtlsdr_set_agc_mode(Modes.dev, 1);\n    rtlsdr_set_center_freq(Modes.dev, Modes.freq);\n    rtlsdr_set_sample_rate(Modes.dev, MODES_DEFAULT_RATE);\n    rtlsdr_reset_buffer(Modes.dev);\n    fprintf(stderr, \"Gain reported by device: %.2f\\n\",\n        rtlsdr_get_tuner_gain(Modes.dev)/10.0);\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Show the currently captured interactive data on screen. */\n", "func_signal": "void interactiveShowData(void)", "code": "{\n    struct aircraft *a = Modes.aircrafts;\n    time_t now = time(NULL);\n    char progress[4];\n    int count = 0;\n\n    memset(progress,' ',3);\n    progress[time(NULL)%3] = '.';\n    progress[3] = '\\0';\n\n    printf(\"\\x1b[H\\x1b[2J\");    /* Clear the screen */\n    printf(\n\"Hex    Flight   Altitude  Speed   Lat       Lon       Track  Messages Seen %s\\n\"\n\"--------------------------------------------------------------------------------\\n\",\n        progress);\n\n    while(a && count < Modes.interactive_rows) {\n        int altitude = a->altitude, speed = a->speed;\n\n        /* Convert units to metric if --metric was specified. */\n        if (Modes.metric) {\n            altitude /= 3.2828;\n            speed *= 1.852;\n        }\n\n        printf(\"%-6s %-8s %-9d %-7d %-7.03f   %-7.03f   %-3d   %-9ld %d sec\\n\",\n            a->hexaddr, a->flight, altitude, speed,\n            a->lat, a->lon, a->track, a->messages,\n            (int)(now - a->seen));\n        a = a->next;\n        count++;\n    }\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Similar to fixSingleBitErrors() but try every possible two bit combination.\n * This is very slow and should be tried only against DF17 messages that\n * don't pass the checksum, and only in Aggressive Mode. */\n", "func_signal": "int fixTwoBitsErrors(unsigned char *msg, int bits)", "code": "{\n    int j, i;\n    unsigned char aux[MODES_LONG_MSG_BITS/8];\n\n    for (j = 0; j < bits; j++) {\n        int byte1 = j/8;\n        int bitmask1 = 1 << (7-(j%8));\n\n        /* Don't check the same pairs multiple times, so i starts from j+1 */\n        for (i = j+1; i < bits; i++) {\n            int byte2 = i/8;\n            int bitmask2 = 1 << (7-(i%8));\n            uint32_t crc1, crc2;\n\n            memcpy(aux,msg,bits/8);\n\n            aux[byte1] ^= bitmask1; /* Flip j-th bit. */\n            aux[byte2] ^= bitmask2; /* Flip i-th bit. */\n\n            crc1 = ((uint32_t)aux[(bits/8)-3] << 16) |\n                   ((uint32_t)aux[(bits/8)-2] << 8) |\n                    (uint32_t)aux[(bits/8)-1];\n            crc2 = modesChecksum(aux,bits);\n\n            if (crc1 == crc2) {\n                /* The error is fixed. Overwrite the original buffer with\n                 * the corrected sequence, and returns the error bit\n                 * position. */\n                memcpy(msg,aux,bits/8);\n                /* We return the two bits as a 16 bit integer by shifting\n                 * 'i' on the left. This is possible since 'i' will always\n                 * be non-zero because i starts from j+1. */\n                return j | (i<<8);\n            }\n        }\n    }\n    return -1;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Get an HTTP request header and write the response to the client.\n * Again here we assume that the socket buffer is enough without doing\n * any kind of userspace buffering.\n *\n * Returns 1 on error to signal the caller the client connection should\n * be closed. */\n", "func_signal": "int handleHTTPRequest(struct client *c)", "code": "{\n    char hdr[512];\n    int clen, hdrlen;\n    int httpver, keepalive;\n    char *p, *url, *content;\n    char *ctype;\n\n    if (Modes.debug & MODES_DEBUG_NET)\n        printf(\"\\nHTTP request: %s\\n\", c->buf);\n\n    /* Minimally parse the request. */\n    httpver = (strstr(c->buf, \"HTTP/1.1\") != NULL) ? 11 : 10;\n    if (httpver == 10) {\n        /* HTTP 1.0 defaults to close, unless otherwise specified. */\n        keepalive = strstr(c->buf, \"Connection: keep-alive\") != NULL;\n    } else if (httpver == 11) {\n        /* HTTP 1.1 defaults to keep-alive, unless close is specified. */\n        keepalive = strstr(c->buf, \"Connection: close\") == NULL;\n    }\n\n    /* Identify he URL. */\n    p = strchr(c->buf,' ');\n    if (!p) return 1; /* There should be the method and a space... */\n    url = ++p; /* Now this should point to the requested URL. */\n    p = strchr(p, ' ');\n    if (!p) return 1; /* There should be a space before HTTP/... */\n    *p = '\\0';\n\n    if (Modes.debug & MODES_DEBUG_NET) {\n        printf(\"\\nHTTP keep alive: %d\\n\", keepalive);\n        printf(\"HTTP requested URL: %s\\n\\n\", url);\n    }\n\n    /* Select the content to send, we have just two so far:\n     * \"/\" -> Our google map application.\n     * \"/data.json\" -> Our ajax request to update planes. */\n    if (strstr(url, \"/data.json\")) {\n        content = aircraftsToJson(&clen);\n        ctype = MODES_CONTENT_TYPE_JSON;\n    } else {\n        struct stat sbuf;\n        int fd = -1;\n\n        if (stat(\"gmap.html\",&sbuf) != -1 &&\n            (fd = open(\"gmap.html\",O_RDONLY)) != -1)\n        {\n            content = malloc(sbuf.st_size);\n            if (read(fd,content,sbuf.st_size) == -1) {\n                snprintf(content,sbuf.st_size,\"Error reading from file: %s\",\n                    strerror(errno));\n            }\n            clen = sbuf.st_size;\n        } else {\n            char buf[128];\n\n            clen = snprintf(buf,sizeof(buf),\"Error opening HTML file: %s\",\n                strerror(errno));\n            content = strdup(buf);\n        }\n        if (fd != -1) close(fd);\n        ctype = MODES_CONTENT_TYPE_HTML;\n    }\n\n    /* Create the header and send the reply. */\n    hdrlen = snprintf(hdr, sizeof(hdr),\n        \"HTTP/1.1 200 OK\\r\\n\"\n        \"Server: Dump1090\\r\\n\"\n        \"Content-Type: %s\\r\\n\"\n        \"Connection: %s\\r\\n\"\n        \"Content-Length: %d\\r\\n\"\n        \"Access-Control-Allow-Origin: *\\r\\n\"\n        \"\\r\\n\",\n        ctype,\n        keepalive ? \"keep-alive\" : \"close\",\n        clen);\n\n    if (Modes.debug & MODES_DEBUG_NET)\n        printf(\"HTTP Reply header:\\n%s\", hdr);\n\n    /* Send header and content. */\n    if (write(c->fd, hdr, hdrlen) != hdrlen ||\n        write(c->fd, content, clen) != clen)\n    {\n        free(content);\n        return 1;\n    }\n    free(content);\n    Modes.stat_http_requests++;\n    return !keepalive;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* When in interactive mode If we don't receive new nessages within\n * MODES_INTERACTIVE_TTL seconds we remove the aircraft from the list. */\n", "func_signal": "void interactiveRemoveStaleAircrafts(void)", "code": "{\n    struct aircraft *a = Modes.aircrafts;\n    struct aircraft *prev = NULL;\n    time_t now = time(NULL);\n\n    while(a) {\n        if ((now - a->seen) > Modes.interactive_ttl) {\n            struct aircraft *next = a->next;\n            /* Remove the element from the linked list, with care\n             * if we are removing the first element. */\n            free(a);\n            if (!prev)\n                Modes.aircrafts = next;\n            else\n                prev->next = next;\n            a = next;\n        } else {\n            prev = a;\n            a = a->next;\n        }\n    }\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Detect a Mode S messages inside the magnitude buffer pointed by 'm' and of\n * size 'mlen' bytes. Every detected Mode S message is convert it into a\n * stream of bits and passed to the function to display it. */\n", "func_signal": "void detectModeS(uint16_t *m, uint32_t mlen)", "code": "{\n    unsigned char bits[MODES_LONG_MSG_BITS];\n    unsigned char msg[MODES_LONG_MSG_BITS/2];\n    uint16_t aux[MODES_LONG_MSG_BITS*2];\n    uint32_t j;\n    int use_correction = 0;\n\n    /* The Mode S preamble is made of impulses of 0.5 microseconds at\n     * the following time offsets:\n     *\n     * 0   - 0.5 usec: first impulse.\n     * 1.0 - 1.5 usec: second impulse.\n     * 3.5 - 4   usec: third impulse.\n     * 4.5 - 5   usec: last impulse.\n     * \n     * Since we are sampling at 2 Mhz every sample in our magnitude vector\n     * is 0.5 usec, so the preamble will look like this, assuming there is\n     * an impulse at offset 0 in the array:\n     *\n     * 0   -----------------\n     * 1   -\n     * 2   ------------------\n     * 3   --\n     * 4   -\n     * 5   --\n     * 6   -\n     * 7   ------------------\n     * 8   --\n     * 9   -------------------\n     */\n    for (j = 0; j < mlen - MODES_FULL_LEN*2; j++) {\n        int low, high, delta, i, errors;\n        int good_message = 0;\n\n        if (use_correction) goto good_preamble; /* We already checked it. */\n\n        /* First check of relations between the first 10 samples\n         * representing a valid preamble. We don't even investigate further\n         * if this simple test is not passed. */\n        if (!(m[j] > m[j+1] &&\n            m[j+1] < m[j+2] &&\n            m[j+2] > m[j+3] &&\n            m[j+3] < m[j] &&\n            m[j+4] < m[j] &&\n            m[j+5] < m[j] &&\n            m[j+6] < m[j] &&\n            m[j+7] > m[j+8] &&\n            m[j+8] < m[j+9] &&\n            m[j+9] > m[j+6]))\n        {\n            if (Modes.debug & MODES_DEBUG_NOPREAMBLE &&\n                m[j] > MODES_DEBUG_NOPREAMBLE_LEVEL)\n                dumpRawMessage(\"Unexpected ratio among first 10 samples\",\n                    msg, m, j);\n            continue;\n        }\n\n        /* The samples between the two spikes must be < than the average\n         * of the high spikes level. We don't test bits too near to\n         * the high levels as signals can be out of phase so part of the\n         * energy can be in the near samples. */\n        high = (m[j]+m[j+2]+m[j+7]+m[j+9])/6;\n        if (m[j+4] >= high ||\n            m[j+5] >= high)\n        {\n            if (Modes.debug & MODES_DEBUG_NOPREAMBLE &&\n                m[j] > MODES_DEBUG_NOPREAMBLE_LEVEL)\n                dumpRawMessage(\n                    \"Too high level in samples between 3 and 6\",\n                    msg, m, j);\n            continue;\n        }\n\n        /* Similarly samples in the range 11-14 must be low, as it is the\n         * space between the preamble and real data. Again we don't test\n         * bits too near to high levels, see above. */\n        if (m[j+11] >= high ||\n            m[j+12] >= high ||\n            m[j+13] >= high ||\n            m[j+14] >= high)\n        {\n            if (Modes.debug & MODES_DEBUG_NOPREAMBLE &&\n                m[j] > MODES_DEBUG_NOPREAMBLE_LEVEL)\n                dumpRawMessage(\n                    \"Too high level in samples between 10 and 15\",\n                    msg, m, j);\n            continue;\n        }\n        Modes.stat_valid_preamble++;\n\ngood_preamble:\n        /* If the previous attempt with this message failed, retry using\n         * magnitude correction. */\n        if (use_correction) {\n            memcpy(aux,m+j+MODES_PREAMBLE_US*2,sizeof(aux));\n            if (j && detectOutOfPhase(m+j)) {\n                applyPhaseCorrection(m+j);\n                Modes.stat_out_of_phase++;\n            }\n            /* TODO ... apply other kind of corrections. */\n        }\n\n        /* Decode all the next 112 bits, regardless of the actual message\n         * size. We'll check the actual message type later. */\n        errors = 0;\n        for (i = 0; i < MODES_LONG_MSG_BITS*2; i += 2) {\n            low = m[j+i+MODES_PREAMBLE_US*2];\n            high = m[j+i+MODES_PREAMBLE_US*2+1];\n            delta = low-high;\n            if (delta < 0) delta = -delta;\n\n            if (i > 0 && delta < 256) {\n                bits[i/2] = bits[i/2-1];\n            } else if (low == high) {\n                /* Checking if two adiacent samples have the same magnitude\n                 * is an effective way to detect if it's just random noise\n                 * that was detected as a valid preamble. */\n                bits[i/2] = 2; /* error */\n                if (i < MODES_SHORT_MSG_BITS*2) errors++;\n            } else if (low > high) {\n                bits[i/2] = 1;\n            } else {\n                /* (low < high) for exclusion  */\n                bits[i/2] = 0;\n            }\n        }\n\n        /* Restore the original message if we used magnitude correction. */\n        if (use_correction)\n            memcpy(m+j+MODES_PREAMBLE_US*2,aux,sizeof(aux));\n\n        /* Pack bits into bytes */\n        for (i = 0; i < MODES_LONG_MSG_BITS; i += 8) {\n            msg[i/8] =\n                bits[i]<<7 | \n                bits[i+1]<<6 | \n                bits[i+2]<<5 | \n                bits[i+3]<<4 | \n                bits[i+4]<<3 | \n                bits[i+5]<<2 | \n                bits[i+6]<<1 | \n                bits[i+7];\n        }\n\n        int msgtype = msg[0]>>3;\n        int msglen = modesMessageLenByType(msgtype)/8;\n\n        /* Last check, high and low bits are different enough in magnitude\n         * to mark this as real message and not just noise? */\n        delta = 0;\n        for (i = 0; i < msglen*8*2; i += 2) {\n            delta += abs(m[j+i+MODES_PREAMBLE_US*2]-\n                         m[j+i+MODES_PREAMBLE_US*2+1]);\n        }\n        delta /= msglen*4;\n\n        /* Filter for an average delta of three is small enough to let almost\n         * every kind of message to pass, but high enough to filter some\n         * random noise. */\n        if (delta < 10*255) {\n            use_correction = 0;\n            continue;\n        }\n\n        /* If we reached this point, and error is zero, we are very likely\n         * with a Mode S message in our hands, but it may still be broken\n         * and CRC may not be correct. This is handled by the next layer. */\n        if (errors == 0 || (Modes.aggressive && errors < 3)) {\n            struct modesMessage mm;\n\n            /* Decode the received message and update statistics */\n            decodeModesMessage(&mm,msg);\n\n            /* Update statistics. */\n            if (mm.crcok || use_correction) {\n                if (errors == 0) Modes.stat_demodulated++;\n                if (mm.errorbit == -1) {\n                    if (mm.crcok)\n                        Modes.stat_goodcrc++;\n                    else\n                        Modes.stat_badcrc++;\n                } else {\n                    Modes.stat_badcrc++;\n                    Modes.stat_fixed++;\n                    if (mm.errorbit < MODES_LONG_MSG_BITS)\n                        Modes.stat_single_bit_fix++;\n                    else\n                        Modes.stat_two_bits_fix++;\n                }\n            }\n\n            /* Output debug mode info if needed. */\n            if (use_correction == 0) {\n                if (Modes.debug & MODES_DEBUG_DEMOD)\n                    dumpRawMessage(\"Demodulated with 0 errors\", msg, m, j);\n                else if (Modes.debug & MODES_DEBUG_BADCRC &&\n                         mm.msgtype == 17 &&\n                         (!mm.crcok || mm.errorbit != -1))\n                    dumpRawMessage(\"Decoded with bad CRC\", msg, m, j);\n                else if (Modes.debug & MODES_DEBUG_GOODCRC && mm.crcok &&\n                         mm.errorbit == -1)\n                    dumpRawMessage(\"Decoded with good CRC\", msg, m, j);\n            }\n\n            /* Skip this message if we are sure it's fine. */\n            if (mm.crcok) {\n                j += (MODES_PREAMBLE_US+(msglen*8))*2;\n                good_message = 1;\n                if (use_correction)\n                    mm.phase_corrected = 1;\n            }\n\n            /* Pass data to the next layer */\n            useModesMessage(&mm);\n        } else {\n            if (Modes.debug & MODES_DEBUG_DEMODERR && use_correction) {\n                printf(\"The following message has %d demod errors\\n\", errors);\n                dumpRawMessage(\"Demodulated with errors\", msg, m, j);\n            }\n        }\n\n        /* Retry with phase correction if possible. */\n        if (!good_message && !use_correction) {\n            j--;\n            use_correction = 1;\n        } else {\n            use_correction = 0;\n        }\n    }\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* If the message type has the checksum xored with the ICAO address, try to\n * brute force it using a list of recently seen ICAO addresses.\n *\n * Do this in a brute-force fashion by xoring the predicted CRC with\n * the address XOR checksum field in the message. This will recover the\n * address: if we found it in our cache, we can assume the message is ok.\n *\n * This function expects mm->msgtype and mm->msgbits to be correctly\n * populated by the caller.\n *\n * On success the correct ICAO address is stored in the modesMessage\n * structure in the aa3, aa2, and aa1 fiedls.\n *\n * If the function successfully recovers a message with a correct checksum\n * it returns 1. Otherwise 0 is returned. */\n", "func_signal": "int bruteForceAP(unsigned char *msg, struct modesMessage *mm)", "code": "{\n    unsigned char aux[MODES_LONG_MSG_BYTES];\n    int msgtype = mm->msgtype;\n    int msgbits = mm->msgbits;\n\n    if (msgtype == 0 ||         /* Short air surveillance */\n        msgtype == 4 ||         /* Surveillance, altitude reply */\n        msgtype == 5 ||         /* Surveillance, identity reply */\n        msgtype == 16 ||        /* Long Air-Air survillance */\n        msgtype == 20 ||        /* Comm-A, altitude request */\n        msgtype == 21 ||        /* Comm-A, identity request */\n        msgtype == 24)          /* Comm-C ELM */\n    {\n        uint32_t addr;\n        uint32_t crc;\n        int lastbyte = (msgbits/8)-1;\n\n        /* Work on a copy. */\n        memcpy(aux,msg,msgbits/8);\n\n        /* Compute the CRC of the message and XOR it with the AP field\n         * so that we recover the address, because:\n         *\n         * (ADDR xor CRC) xor CRC = ADDR. */\n        crc = modesChecksum(aux,msgbits);\n        aux[lastbyte] ^= crc & 0xff;\n        aux[lastbyte-1] ^= (crc >> 8) & 0xff;\n        aux[lastbyte-2] ^= (crc >> 16) & 0xff;\n        \n        /* If the obtained address exists in our cache we consider\n         * the message valid. */\n        addr = aux[lastbyte] | (aux[lastbyte-1] << 8) | (aux[lastbyte-2] << 16);\n        if (ICAOAddressWasRecentlySeen(addr)) {\n            mm->aa1 = aux[lastbyte-2];\n            mm->aa2 = aux[lastbyte-1];\n            mm->aa3 = aux[lastbyte];\n            return 1;\n        }\n    }\n    return 0;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* ================================ Main ==================================== */\n", "func_signal": "void showHelp(void)", "code": "{\n    printf(\n\"--device-index <index>   Select RTL device (default: 0).\\n\"\n\"--gain <db>              Set gain (default: max gain. Use -100 for auto-gain).\\n\"\n\"--enable-agc             Enable the Automatic Gain Control (default: off).\\n\"\n\"--freq <hz>              Set frequency (default: 1090 Mhz).\\n\"\n\"--ifile <filename>       Read data from file (use '-' for stdin).\\n\"\n\"--loop                   With --ifile, read the same file in a loop.\\n\"\n\"--interactive            Interactive mode refreshing data on screen.\\n\"\n\"--interactive-rows <num> Max number of rows in interactive mode (default: 15).\\n\"\n\"--interactive-ttl <sec>  Remove from list if idle for <sec> (default: 60).\\n\"\n\"--raw                    Show only messages hex values.\\n\"\n\"--net                    Enable networking.\\n\"\n\"--net-only               Enable just networking, no RTL device or file used.\\n\"\n\"--net-ro-port <port>     TCP listening port for raw output (default: 30002).\\n\"\n\"--net-ri-port <port>     TCP listening port for raw input (default: 30001).\\n\"\n\"--net-http-port <port>   HTTP server port (default: 8080).\\n\"\n\"--net-sbs-port <port>    TCP listening port for BaseStation format output (default: 30003).\\n\"\n\"--no-fix                 Disable single-bits error correction using CRC.\\n\"\n\"--no-crc-check           Disable messages with broken CRC (discouraged).\\n\"\n\"--aggressive             More CPU for more messages (two bits fixes, ...).\\n\"\n\"--stats                  With --ifile print stats at exit. No other output.\\n\"\n\"--onlyaddr               Show only ICAO addresses (testing purposes).\\n\"\n\"--metric                 Use metric units (meters, km/h, ...).\\n\"\n\"--snip <level>           Strip IQ file removing samples < level.\\n\"\n\"--debug <flags>          Debug mode (verbose), see README for details.\\n\"\n\"--help                   Show this help.\\n\"\n\"\\n\"\n\"Debug mode flags: d = Log frames decoded with errors\\n\"\n\"                  D = Log frames decoded with zero errors\\n\"\n\"                  c = Log frames with bad CRC\\n\"\n\"                  C = Log frames with good CRC\\n\"\n\"                  p = Log frames with bad preamble\\n\"\n\"                  n = Log network debugging info\\n\"\n\"                  j = Log frames to frames.js, loadable by debug.html.\\n\"\n    );\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* This is a wrapper for dumpMagnitudeVector() that also show the message\n * in hex format with an additional description.\n *\n * descr  is the additional message to show to describe the dump.\n * msg    points to the decoded message\n * m      is the original magnitude vector\n * offset is the offset where the message starts\n *\n * The function also produces the Javascript file used by debug.html to\n * display packets in a graphical format if the Javascript output was\n * enabled.\n */\n", "func_signal": "void dumpRawMessage(char *descr, unsigned char *msg,\n                    uint16_t *m, uint32_t offset)", "code": "{\n    int j;\n    int msgtype = msg[0]>>3;\n    int fixable = -1;\n\n    if (msgtype == 11 || msgtype == 17) {\n        int msgbits = (msgtype == 11) ? MODES_SHORT_MSG_BITS :\n                                        MODES_LONG_MSG_BITS;\n        fixable = fixSingleBitErrors(msg,msgbits);\n        if (fixable == -1)\n            fixable = fixTwoBitsErrors(msg,msgbits);\n    }\n\n    if (Modes.debug & MODES_DEBUG_JS) {\n        dumpRawMessageJS(descr, msg, m, offset, fixable);\n        return;\n    }\n\n    printf(\"\\n--- %s\\n    \", descr);\n    for (j = 0; j < MODES_LONG_MSG_BYTES; j++) {\n        printf(\"%02x\",msg[j]);\n        if (j == MODES_SHORT_MSG_BYTES-1) printf(\" ... \");\n    }\n    printf(\" (DF %d, Fixable: %d)\\n\", msgtype, fixable);\n    dumpMagnitudeVector(m,offset);\n    printf(\"---\\n\\n\");\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* We read data using a thread, so the main thread only handles decoding\n * without caring about data acquisition. */\n", "func_signal": "void *readerThreadEntryPoint(void *arg)", "code": "{\n    MODES_NOTUSED(arg);\n\n    if (Modes.filename == NULL) {\n        rtlsdr_read_async(Modes.dev, rtlsdrCallback, NULL,\n                              MODES_ASYNC_BUF_NUMBER,\n                              MODES_DATA_LEN);\n    } else {\n        readDataFromFile();\n    }\n    return NULL;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* =============================== Initialization =========================== */\n", "func_signal": "void modesInitConfig(void)", "code": "{\n    Modes.gain = MODES_MAX_GAIN;\n    Modes.dev_index = 0;\n    Modes.enable_agc = 0;\n    Modes.freq = MODES_DEFAULT_FREQ;\n    Modes.filename = NULL;\n    Modes.fix_errors = 1;\n    Modes.check_crc = 1;\n    Modes.raw = 0;\n    Modes.net = 0;\n    Modes.net_only = 0;\n    Modes.onlyaddr = 0;\n    Modes.debug = 0;\n    Modes.interactive = 0;\n    Modes.interactive_rows = MODES_INTERACTIVE_ROWS;\n    Modes.interactive_ttl = MODES_INTERACTIVE_TTL;\n    Modes.aggressive = 0;\n    Modes.interactive_rows = getTermRows();\n    Modes.loop = 0;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Networking \"stack\" initialization. */\n", "func_signal": "void modesInitNet(void)", "code": "{\n    int j;\n\n    memset(Modes.clients,0,sizeof(Modes.clients));\n    Modes.maxfd = -1;\n\n    for (j = 0; j < MODES_NET_SERVICES_NUM; j++) {\n        int s = anetTcpServer(Modes.aneterr, modesNetServices[j].port, NULL);\n        if (s == -1) {\n            fprintf(stderr, \"Error opening the listening port %d (%s): %s\\n\",\n                modesNetServices[j].port,\n                modesNetServices[j].descr,\n                strerror(errno));\n            exit(1);\n        }\n        anetNonBlock(Modes.aneterr, s);\n        *modesNetServices[j].socket = s;\n    }\n\n    signal(SIGPIPE, SIG_IGN);\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Decode the 13 bit AC altitude field (in DF 20 and others).\n * Returns the altitude, and set 'unit' to either MODES_UNIT_METERS\n * or MDOES_UNIT_FEETS. */\n", "func_signal": "int decodeAC13Field(unsigned char *msg, int *unit)", "code": "{\n    int m_bit = msg[3] & (1<<6);\n    int q_bit = msg[3] & (1<<4);\n\n    if (!m_bit) {\n        *unit = MODES_UNIT_FEET;\n        if (q_bit) {\n            /* N is the 11 bit integer resulting from the removal of bit\n             * Q and M */\n            int n = ((msg[2]&31)<<6) |\n                    ((msg[3]&0x80)>>2) |\n                    ((msg[3]&0x20)>>1) |\n                     (msg[3]&15);\n            /* The final altitude is due to the resulting number multiplied\n             * by 25, minus 1000. */\n            return n*25-1000;\n        } else {\n            /* TODO: Implement altitude where Q=0 and M=0 */\n        }\n    } else {\n        *unit = MODES_UNIT_METERS;\n        /* TODO: Implement altitude when meter unit is selected. */\n    }\n    return 0;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Send the specified message to all clients listening for a given service. */\n", "func_signal": "void modesSendAllClients(int service, void *msg, int len)", "code": "{\n    int j;\n    struct client *c;\n\n    for (j = 0; j <= Modes.maxfd; j++) {\n        c = Modes.clients[j];\n        if (c && c->service == service) {\n            int nwritten = write(j, msg, len);\n            if (nwritten != len) {\n                modesFreeClient(j);\n            }\n        }\n    }\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Always positive MOD operation, used for CPR decoding. */\n", "func_signal": "int cprModFunction(int a, int b)", "code": "{\n    int res = a % b;\n    if (res < 0) res += b;\n    return res;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* Receive new messages and populate the interactive mode with more info. */\n", "func_signal": "struct aircraft *interactiveReceiveData(struct modesMessage *mm)", "code": "{\n    uint32_t addr;\n    struct aircraft *a, *aux;\n\n    if (Modes.check_crc && mm->crcok == 0) return NULL;\n    addr = (mm->aa1 << 16) | (mm->aa2 << 8) | mm->aa3;\n\n    /* Loookup our aircraft or create a new one. */\n    a = interactiveFindAircraft(addr);\n    if (!a) {\n        a = interactiveCreateAircraft(addr);\n        a->next = Modes.aircrafts;\n        Modes.aircrafts = a;\n    } else {\n        /* If it is an already known aircraft, move it on head\n         * so we keep aircrafts ordered by received message time.\n         *\n         * However move it on head only if at least one second elapsed\n         * since the aircraft that is currently on head sent a message,\n         * othewise with multiple aircrafts at the same time we have an\n         * useless shuffle of positions on the screen. */\n        if (0 && Modes.aircrafts != a && (time(NULL) - a->seen) >= 1) {\n            aux = Modes.aircrafts;\n            while(aux->next != a) aux = aux->next;\n            /* Now we are a node before the aircraft to remove. */\n            aux->next = aux->next->next; /* removed. */\n            /* Add on head */\n            a->next = Modes.aircrafts;\n            Modes.aircrafts = a;\n        }\n    }\n\n    a->seen = time(NULL);\n    a->messages++;\n\n    if (mm->msgtype == 0 || mm->msgtype == 4 || mm->msgtype == 20) {\n        a->altitude = mm->altitude;\n    } else if (mm->msgtype == 17) {\n        if (mm->metype >= 1 && mm->metype <= 4) {\n            memcpy(a->flight, mm->flight, sizeof(a->flight));\n        } else if (mm->metype >= 9 && mm->metype <= 18) {\n            a->altitude = mm->altitude;\n            if (mm->fflag) {\n                a->odd_cprlat = mm->raw_latitude;\n                a->odd_cprlon = mm->raw_longitude;\n                a->odd_cprtime = mstime();\n            } else {\n                a->even_cprlat = mm->raw_latitude;\n                a->even_cprlon = mm->raw_longitude;\n                a->even_cprtime = mstime();\n            }\n            /* If the two data is less than 10 seconds apart, compute\n             * the position. */\n            if (abs(a->even_cprtime - a->odd_cprtime) <= 10000) {\n                decodeCPR(a);\n            }\n        } else if (mm->metype == 19) {\n            if (mm->mesub == 1 || mm->mesub == 2) {\n                a->speed = mm->velocity;\n                a->track = mm->heading;\n            }\n        }\n    }\n    return a;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* We use a thread reading data in background, while the main thread\n * handles decoding and visualization of data to the user.\n *\n * The reading thread calls the RTLSDR API to read data asynchronously, and\n * uses a callback to populate the data buffer.\n * A Mutex is used to avoid races with the decoding thread. */\n", "func_signal": "void rtlsdrCallback(unsigned char *buf, uint32_t len, void *ctx)", "code": "{\n    MODES_NOTUSED(ctx);\n\n    pthread_mutex_lock(&Modes.data_mutex);\n    if (len > MODES_DATA_LEN) len = MODES_DATA_LEN;\n    /* Move the last part of the previous buffer, that was not processed,\n     * on the start of the new buffer. */\n    memcpy(Modes.data, Modes.data+MODES_DATA_LEN, (MODES_FULL_LEN-1)*4);\n    /* Read the new data. */\n    memcpy(Modes.data+(MODES_FULL_LEN-1)*4, buf, len);\n    Modes.data_ready = 1;\n    /* Signal to the other thread that new data is ready */\n    pthread_cond_signal(&Modes.data_cond);\n    pthread_mutex_unlock(&Modes.data_mutex);\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* This function is used when \"net only\" mode is enabled to know when there\n * is at least a new client to serve. Note that the dump1090 networking model\n * is extremely trivial and a function takes care of handling all the clients\n * that have something to serve, without a proper event library, so the\n * function here returns as long as there is a single client ready, or\n * when the specified timeout in milliesconds elapsed, without specifying to\n * the caller what client requires to be served. */\n", "func_signal": "void modesWaitReadableClients(int timeout_ms)", "code": "{\n    struct timeval tv;\n    fd_set fds;\n    int j, maxfd = Modes.maxfd;\n\n    FD_ZERO(&fds);\n\n    /* Set client FDs */\n    for (j = 0; j <= Modes.maxfd; j++) {\n        if (Modes.clients[j]) FD_SET(j,&fds);\n    }\n\n    /* Set listening sockets to accept new clients ASAP. */\n    for (j = 0; j < MODES_NET_SERVICES_NUM; j++) {\n        int s = *modesNetServices[j].socket;\n        FD_SET(s,&fds);\n        if (s > maxfd) maxfd = s;\n    }\n\n    tv.tv_sec = timeout_ms/1000;\n    tv.tv_usec = (timeout_ms%1000)*1000;\n    /* We don't care why select returned here, timeout, error, or\n     * FDs ready are all conditions for which we just return. */\n    select(maxfd+1,&fds,NULL,NULL,&tv);\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/* This function decodes a string representing a Mode S message in\n * raw hex format like: *8D4B969699155600E87406F5B69F;\n * The string is supposed to be at the start of the client buffer\n * and null-terminated.\n * \n * The message is passed to the higher level layers, so it feeds\n * the selected screen output, the network output and so forth.\n * \n * If the message looks invalid is silently discarded.\n *\n * The function always returns 0 (success) to the caller as there is\n * no case where we want broken messages here to close the client\n * connection. */\n", "func_signal": "int decodeHexMessage(struct client *c)", "code": "{\n    char *hex = c->buf;\n    int l = strlen(hex), j;\n    unsigned char msg[MODES_LONG_MSG_BYTES];\n    struct modesMessage mm;\n\n    /* Remove spaces on the left and on the right. */\n    while(l && isspace(hex[l-1])) {\n        hex[l-1] = '\\0';\n        l--;\n    }\n    while(isspace(*hex)) {\n        hex++;\n        l--;\n    }\n\n    /* Turn the message into binary. */\n    if (l < 2 || hex[0] != '*' || hex[l-1] != ';') return 0;\n    hex++; l-=2; /* Skip * and ; */\n    if (l > MODES_LONG_MSG_BYTES*2) return 0; /* Too long message... broken. */\n    for (j = 0; j < l; j += 2) {\n        int high = hexDigitVal(hex[j]);\n        int low = hexDigitVal(hex[j+1]);\n\n        if (high == -1 || low == -1) return 0;\n        msg[j/2] = (high<<4) | low;\n    }\n    decodeModesMessage(&mm,msg);\n    useModesMessage(&mm);\n    return 0;\n}", "path": "dump1090/dump1090.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "antirez/dump1090", "stars": 2285, "license": "None", "language": "c", "size": 587}
{"docstring": "/**\n * @brief      Initialize vbat brown out detection\n *\n* @param[in]  brndetConfig: Pointer to a vbat brndet configuration structure\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_ConfigVbatBrndet(PMU_VbatBrndetConfig_Type* brndetConfig)", "code": "{\n  CHECK_PARAM(IS_PMU_VBAT_BRNDET_TRIG_TYPE(brndetConfig->brnTrigVolt));\n  CHECK_PARAM(IS_PMU_VBAT_BRNDET_HYST_TYPE(brndetConfig->brnHyst));\n  CHECK_PARAM(IS_PMU_VBAT_BRNDET_FILT_TYPE(brndetConfig->brnFilter));\n  \n  PMU->PMIP_BRNDET_VBAT.BF.BRNTRIG_VBAT_CNTL = brndetConfig->brnTrigVolt;\n  \n  PMU->PMIP_BRNDET_VBAT.BF.BRNHYST_VBAT_CNTL = brndetConfig->brnHyst;\n  \n  PMU->PMIP_BRNDET_VBAT.BF.BRNDET_VBAT_FILT = brndetConfig->brnFilter;\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Select ulpcomp operation mode --- single-ended / differential\n *\n* @param[in]  mode: select the mode\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_UlpcompModeSelect(PMU_UlpcompMode_Type ulpcompMode)", "code": "{\n  CHECK_PARAM(IS_PMU_ULPCOMP_MODE(ulpcompMode));\n  \n  PMU->PMIP_CMP_CTRL.BF.COMP_DIFF_EN = ulpcompMode;\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Enable/Disable vbat brndet interrupt\n *\n * @param[in]  state:  enable/disable\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_VbatBrndetIntCmd(FunctionalState state)", "code": "{\n  CHECK_PARAM(PARAM_FUNCTIONALSTATE(state));\n  \n  PMU->PMIP_BRN_INT_SEL.BF.PMIP_BRN_INT_SEL = ((state  == ENABLE)? 1 : 0);\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      MASK/UNMASK specified interrupt\n *\n * @param[in] wakeupSrc: wakeup source to be select\n *\n * @return    Return wakeup status\n *\n *******************************************************************************/\n", "func_signal": "void PMU_WakeupSrcIntMask(PMU_WakeupSource_Type wakeupSrc, IntMask_Type intMask)", "code": "{\n  CHECK_PARAM(IS_PMU_WAKEUP_SOURCE_TYPE(wakeupSrc));\n  CHECK_PARAM(IS_INTMASK(intMask));\n  \n  switch(wakeupSrc)\n  {\n  case PMU_WAKEUP_PIN0:\n    PMU->WAKEUP_MASK.BF.PIN0_WAKEUP_MASK = ((intMask == MASK)? 0 : 1);\n    break;\n    \n  case PMU_WAKEUP_PIN1:\n    PMU->WAKEUP_MASK.BF.PIN1_WAKEUP_MASK = ((intMask == MASK)? 0 : 1);\n    break;\n    \n  case PMU_WAKEUP_RTC:\n    PMU->WAKEUP_MASK.BF.RTC_WAKEUP_MASK = ((intMask == MASK)? 0 : 1);\n    break;\n    \n  case PMU_WAKEUP_ULPCOMP:\n    PMU->WAKEUP_MASK.BF.PMIP_COMP_WAKEUP_MASK = ((intMask == MASK)? 0 : 1);\n    break;\n    \n  case PMU_WAKEUP_WLAN:\n    PMU->WAKEUP_MASK.BF.WL_WAKEUP_MASK = ((intMask == MASK)? 0 : 1);\n    break;\n    \n  default:\n    break;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      wakeup source interrupt requeset clear\n *\n * @param[in]  wakeupSrc: wakeup source to be cleared\n *\n * @return     Return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_ClearWakeupSrcInt(PMU_WakeupSource_Type wakeupSrc)", "code": "{\n  CHECK_PARAM(IS_PMU_WAKEUP_SOURCE_TYPE(wakeupSrc));\n  \n  switch(wakeupSrc)\n  {\n    /* case pin0: GPIO22 interrupt */\n  case PMU_WAKEUP_PIN0:\n    PMU->WAKE_SRC_CLR.BF.CLR_PIN0_INT = 1;\n    break;\n  \n    /* case pin1: GPIO23 interrupt */\n  case PMU_WAKEUP_PIN1:\n    PMU->WAKE_SRC_CLR.BF.CLR_PIN1_INT = 1;\n    break;\n    \n    /* case WLAN interrupt */\n  case PMU_WAKEUP_WLAN:\n    PMU->WAKE_SRC_CLR.BF.CLR_WL_INT = 1;\n    break;\n    \n    /* case RTC interrupt */\n  case PMU_WAKEUP_RTC:\n    PMU->WAKE_SRC_CLR.BF.CLR_RTC_INT = 1;\n    break;\n    \n    /* case ULPCOMP interrupt */\n  case PMU_WAKEUP_ULPCOMP:\n    PMU->WAKE_SRC_CLR.BF.CLR_COMP_INT = 1;\n    break;\n  \n  /* default */\n  default:\n    break;  \n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Select ulpcomp hysteresis level\n *\n* @param[in]  hystType: select the hysteresis level\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_UlpcompHysteresisSel(PMU_UlpcompHyst_Type hystType)", "code": "{\n  CHECK_PARAM(IS_PMU_ULPCOMP_HYST_TYPE(hystType));\n  \n  PMU->PMIP_CMP_CTRL.BF.COMP_HYST = (hystType & 0x3);\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Get last wakeup status: which source caused the last wakeup\n *\n * @param[in] wakeupSrc: wakeup source to be select\n *\n * @return    Return wakeup status\n *\n *******************************************************************************/\n", "func_signal": "FlagStatus PMU_GetLastWakeupStatus(PMU_WakeupSource_Type wakeupSrc)", "code": "{\n  FlagStatus bitStatus = RESET;\n  \n  CHECK_PARAM(IS_PMU_WAKEUP_SOURCE_TYPE(wakeupSrc));\n  \n  switch(wakeupSrc)\n  {\n  case PMU_WAKEUP_PIN0:\n    bitStatus = (PMU->WAKEUP_STATUS.BF.PIN0_WAKEUP_STATUS? SET : RESET);\n    break;\n    \n  case PMU_WAKEUP_PIN1:\n    bitStatus = (PMU->WAKEUP_STATUS.BF.PIN1_WAKEUP_STATUS? SET : RESET);\n    break;\n    \n  case PMU_WAKEUP_WLAN:\n    bitStatus = (PMU->WAKEUP_STATUS.BF.WLINT_WAKEUP_STATUS? SET : RESET);\n    break;\n    \n  case PMU_WAKEUP_RTC:\n    bitStatus = (PMU->WAKEUP_STATUS.BF.RTC_WAKEUP_STATUS? SET : RESET);\n    break;\n    \n  case PMU_WAKEUP_ULPCOMP:\n    bitStatus = (PMU->WAKEUP_STATUS.BF.PMIP_COMP_WAKEUP_STATUS? SET : RESET);\n    break;\n    \n  default:\n    break;\n  }\n  \n  return bitStatus;\n  \n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Clear last reset cause\n *\n * @param[in]  resetCause: reset cause to be cleared\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_ClrLastResetCause(PMU_LastResetCause_Type resetCause)", "code": "{\n  switch(resetCause)\n  {\n  case PMU_BROWNOUT_VBAT:\n    PMU->LAST_RST_CLR.BF.BROWNOUT_VBAT_CLR = 1;\n    break;\n    \n  case PMU_CM3_SYSRESETREQ:\n    PMU->LAST_RST_CLR.BF.CM3_SYSRESETREQ_CLR = 1;\n    break;\n    \n  case PMU_CM3_LOCKUP:\n    PMU->LAST_RST_CLR.BF.CM3_LOCKUP_CLR = 1;\n    break;\n    \n  case PMU_WDTOUT:\n    PMU->LAST_RST_CLR.BF.WDT_RST_CLR = 1;\n    break;\n    \n  case PMU_RESETSRC_ALL:\n    PMU->LAST_RST_CLR.WORDVAL |= PMU_LAST_RST_CAUSE_ALL;\n    break;\n    \n  default:\n    break;    \n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Power on specified VDDIO domain\n *\n * @param[in]  domain: VDDIO domain to be awitched on\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_PowerOnVDDIO(PMU_VDDIODOMAIN_Type domain)", "code": "{\n  CHECK_PARAM(IS_PMU_VDDIO_DOMAIN_TYPE(domain));\n  \n  switch(domain)\n  {\n  case PMU_VDDIO_0:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO0_PDB = 1;\n    PMU->IO_PAD_PWR_CFG.BF.GPIO0_LOW_VDDB = 1;\n    break;\n    \n  case PMU_VDDIO_1:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO1_PDB = 1;\n    PMU->IO_PAD_PWR_CFG.BF.GPIO1_LOW_VDDB = 1;\n    break;\n    \n  case PMU_VDDIO_AON:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO_AON_PDB = 1;\n    PMU->IO_PAD_PWR_CFG.BF.GPIO_AON_LOW_VDDB = 1;\n    break;\n    \n  case PMU_VDDIO_2:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO2_PDB = 1;\n    PMU->IO_PAD_PWR_CFG.BF.GPIO2_LOW_VDDB = 1;\n    break;    \n    \n  case PMU_VDDIO_3:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO3_PDB = 1;\n    PMU->IO_PAD_PWR_CFG.BF.GPIO3_LOW_VDDB = 1;\n    break;    \n    \n  default:\n    break;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Set the pad of specified VDDIO domain to normal mode\n *\n * @param[in]  domain: VDDIO domain to be set to normal mode\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_PowerNormalVDDIO(PMU_VDDIODOMAIN_Type domain)", "code": "{\n  CHECK_PARAM(IS_PMU_VDDIO_DOMAIN_TYPE(domain));\n  \n  switch(domain)\n  {\n  case PMU_VDDIO_0:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO0_PDB = 1;\n    break;\n    \n  case PMU_VDDIO_1:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO1_PDB = 1;\n    break;\n    \n  case PMU_VDDIO_AON:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO_AON_PDB = 1;\n    break;\n    \n  case PMU_VDDIO_2:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO2_PDB = 1;\n    break;\n    \n  case PMU_VDDIO_3:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO3_PDB = 1;\n    break;    \n    \n  default:\n    break;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Select ulpcomp reference voltage for single-ended mode\n *\n* @param[in]  refVolType: select the reference voltage level\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_UlpcompRefVoltageSel(PMU_UlpcompRef_Type refVolType)", "code": "{\n  CHECK_PARAM(IS_PMU_ULPCOMP_REFVOLT_TYPE(refVolType));\n  \n  PMU->PMIP_CMP_CTRL.BF.COMP_REF_SEL = (refVolType & 0x7);\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Get ulpcomp ready status\n *\n * @param[in]  none\n *\n * @return status\n *\n *******************************************************************************/\n", "func_signal": "FlagStatus PMU_GetUlpcompStatus(void)", "code": "{\n  uint32_t rdyStatus = 0;\n  \n  rdyStatus = PMU->PMIP_CMP_CTRL.BF.COMP_RDY;\n  \n  if(rdyStatus)\n  {\n    return SET;\n  }\n  else\n  {\n    return RESET;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Power off specified VDDIO domain\n *\n * @param[in]  domain: VDDIO domain to be awitched on\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_PowerOffVDDIO(PMU_VDDIODOMAIN_Type domain)", "code": "{\n  CHECK_PARAM(IS_PMU_VDDIO_DOMAIN_TYPE(domain));\n  \n  switch(domain)\n  {\n  case PMU_VDDIO_0:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO0_LOW_VDDB = 0;\n    break;\n    \n  case PMU_VDDIO_1:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO1_LOW_VDDB = 0;\n    break;\n    \n  case PMU_VDDIO_AON:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO_AON_LOW_VDDB = 0;\n    break;\n    \n  case PMU_VDDIO_2:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO2_LOW_VDDB = 0;\n    break;    \n    \n  case PMU_VDDIO_3:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO3_LOW_VDDB = 0;\n    break;   \n    \n  default:\n    break;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      wakeup pin trigger type set\n *\n * @param[in]  wakeuppin: wakeup pin source\n * @param[in]  trigmode: trigger mode selector\n *\n * @return     Return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_ConfigWakeupPin(PMU_WakeupPin_Type wakeupPin, PMU_WakeupTriggerMode_Type trigmode)", "code": "{\n  CHECK_PARAM(IS_PMU_WAKEUP_PIN_TYPE(wakeupPin));\n  CHECK_PARAM(IS_PMU_WAKEUP_TRIGGER_MODE(trigmode));\n  \n  switch(wakeupPin)\n  {\n  /* case GPIO22 interrupt */\n  case PMU_GPIO22_INT:\n    PMU->WAKEUP_EDGE_DETECT.BF.WAKEUP0 = (trigmode & 0x1);\n    break;\n    \n  /* case GPIO23 interrupt */\n  case PMU_GPIO23_INT:\n    PMU->WAKEUP_EDGE_DETECT.BF.WAKEUP1 = (trigmode & 0x1);\n    break;\n \n  /* default */\n  default:\n    break;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Configure power domain level\n *\n * @param[in]  domain: VDDIO domain to be configured\n * @param[in]  level: VDDIO level\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_ConfigVDDIOLevel(PMU_VDDIODOMAIN_Type domain, PMU_VDDIOLEVEL_Type level)", "code": "{\n  CHECK_PARAM(IS_PMU_VDDIO_DOMAIN_TYPE(domain));\n  CHECK_PARAM(IS_PMU_VDDIO_LEVEL_TYPE(level));\n  \n  switch(domain)\n  {\n  case PMU_VDDIO_0:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO0_V18 = (level & 0x1);\n    PMU->IO_PAD_PWR_CFG.BF.GPIO0_V25 = ((level >> 1) & 0x1);\n    break;\n    \n  case PMU_VDDIO_1:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO1_V18 = (level & 0x1);\n    PMU->IO_PAD_PWR_CFG.BF.GPIO1_V25 = ((level >> 1) & 0x1);\n    break;\n    \n  case PMU_VDDIO_AON:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO_AON_V18 = (level & 0x1);\n    PMU->IO_PAD_PWR_CFG.BF.GPIO_AON_V25 = ((level >> 1) & 0x1);\n    break;\n    \n  case PMU_VDDIO_2:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO2_V18 = (level & 0x1);\n    PMU->IO_PAD_PWR_CFG.BF.GPIO2_V25 = ((level >> 1) & 0x1);\n    break;\n    \n  case PMU_VDDIO_3:\n    PMU->IO_PAD_PWR_CFG.BF.GPIO3_V18 = (level & 0x1);\n    PMU->IO_PAD_PWR_CFG.BF.GPIO3_V25 = ((level >> 1) & 0x1);\n    break;   \n    \n  default:\n    break;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Enable/Disable vbat brndet reset\n *\n * @param[in]  state:  enable/disable\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_VbatBrndetRstCmd(FunctionalState state)", "code": "{\n  CHECK_PARAM(PARAM_FUNCTIONALSTATE(state));\n  \n  PMU->PMIP_BRN_CFG.BF.BRNDET_VBAT_RST_EN = ((state  == ENABLE)? 1 : 0);\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/*@} end of group PMU_Public_Functions */\n/*@} end of group PMU_definitions */\n/*@} end of group MW300_Periph_Driver */\n", "func_signal": "__INTERRUPT__ void ExtPin0_IRQHandler()", "code": "{\n        /* counter upp interrupt */\n        if (intCbfArra[INT_EXTPIN0][0] != NULL) {\n                /* call the callback function */\n                intCbfArra[INT_EXTPIN0][0]();\n        }\n        PMU_ClearWakeupSrcInt(PMU_WAKEUP_PIN0);\n        NVIC_ClearPendingIRQ(ExtPin0_IRQn);\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Configure extra interrupt\n *\n * @param[in]  gpioPin: gpio pin to be configured\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_ConfigExtraInterrupt(PMU_EXTRAINT_Type gpioPin)", "code": "{\n  switch(gpioPin)\n  {\n  case PMU_INT34_GPIO_0:\n    PMU->EXT_SEL_REG0.BF.SEL_34 = 1;\n    break;\n    \n  case PMU_INT34_GPIO_1:\n    PMU->EXT_SEL_REG0.BF.SEL_34 = 0;\n    break;\n    \n  case PMU_INT35_GPIO_2:\n    PMU->EXT_SEL_REG0.BF.SEL_35 = 1;\n    break;\n    \n  case PMU_INT35_GPIO_3:\n    PMU->EXT_SEL_REG0.BF.SEL_35 = 0;\n    break;\n    \n  case PMU_INT36_GPIO_4:\n    PMU->EXT_SEL_REG0.BF.SEL_36 = 1;\n    break;\n    \n  case PMU_INT36_GPIO_5:\n    PMU->EXT_SEL_REG0.BF.SEL_36 = 0;\n    break;\n    \n  case PMU_INT37_GPIO_6:\n    PMU->EXT_SEL_REG0.BF.SEL_37 = 1;\n    break;\n    \n  case PMU_INT37_GPIO_7:\n    PMU->EXT_SEL_REG0.BF.SEL_37 = 0;\n    break; \n    \n  case PMU_INT38_GPIO_8:\n    PMU->EXT_SEL_REG0.BF.SEL_38 = 1;\n    break;\n    \n  case PMU_INT38_GPIO_9:\n    PMU->EXT_SEL_REG0.BF.SEL_38 = 0;\n    break; \n    \n  case PMU_INT39_GPIO_10:\n    PMU->EXT_SEL_REG0.BF.SEL_39 = 1;\n    break;\n    \n  case PMU_INT39_GPIO_11:\n    PMU->EXT_SEL_REG0.BF.SEL_39 = 0;\n    break;    \n   \n  case PMU_INT40_GPIO_12:\n    PMU->EXT_SEL_REG0.BF.SEL_40 = 1;\n    break;\n    \n  case PMU_INT40_GPIO_13:\n    PMU->EXT_SEL_REG0.BF.SEL_40 = 0;\n    break;     \n\n  case PMU_INT41_GPIO_14:\n    PMU->EXT_SEL_REG0.BF.SEL_41 = 1;\n    break;\n    \n  case PMU_INT41_GPIO_15:\n    PMU->EXT_SEL_REG0.BF.SEL_41 = 0;\n    break;\n\n  case PMU_INT42_GPIO_16:\n    PMU->EXT_SEL_REG0.BF.SEL_42 = 1;\n    break;\n    \n  case PMU_INT42_GPIO_17:\n    PMU->EXT_SEL_REG0.BF.SEL_42 = 0;\n    break;\n\n  case PMU_INT43_GPIO_18:\n    PMU->EXT_SEL_REG0.BF.SEL_43 = 1;\n    break;\n    \n  case PMU_INT43_GPIO_19:\n    PMU->EXT_SEL_REG0.BF.SEL_43 = 0;\n    break;       \n    \n  case PMU_INT44_GPIO_20:\n    PMU->EXT_SEL_REG0.BF.SEL_44 = 1;\n    break;\n    \n  case PMU_INT44_GPIO_21:\n    PMU->EXT_SEL_REG0.BF.SEL_44 = 0;\n    break;    \n    \n  case PMU_INT45_GPIO_22:\n    PMU->EXT_SEL_REG0.BF.SEL_45 = 1;\n    break;\n    \n  case PMU_INT45_GPIO_23:\n    PMU->EXT_SEL_REG0.BF.SEL_45 = 0;\n    break;\n    \n  case PMU_INT46_GPIO_24:\n    PMU->EXT_SEL_REG0.BF.SEL_46 = 1;\n    break;\n    \n  case PMU_INT46_GPIO_25:\n    PMU->EXT_SEL_REG0.BF.SEL_46 = 0;\n    break;    \n\n  case PMU_INT47_GPIO_26:\n    PMU->EXT_SEL_REG0.BF.SEL_47 = 1;\n    break;\n    \n  case PMU_INT47_GPIO_27:\n    PMU->EXT_SEL_REG0.BF.SEL_47 = 0;\n    break;\n\n  case PMU_INT48_GPIO_28:\n    PMU->EXT_SEL_REG0.BF.SEL_48 = 1;\n    break;\n    \n  case PMU_INT48_GPIO_29:\n    PMU->EXT_SEL_REG0.BF.SEL_48 = 0;\n    break;\n    \n  case PMU_INT49_GPIO_30:\n    PMU->EXT_SEL_REG0.BF.SEL_49 = 1;\n    break; \n    \n  case PMU_INT49_GPIO_31:\n    PMU->EXT_SEL_REG0.BF.SEL_49 = 0;\n    break;\n \n  case PMU_INT50_GPIO_32:\n    PMU->EXT_SEL_REG0.BF.SEL_50 = 1;\n    break;\n    \n  case PMU_INT50_GPIO_33:\n    PMU->EXT_SEL_REG0.BF.SEL_50 = 0;\n    break; \n    \n  case PMU_INT51_GPIO_34:\n    PMU->EXT_SEL_REG0.BF.SEL_51 = 1;\n    break;\n    \n  case PMU_INT51_GPIO_35:\n    PMU->EXT_SEL_REG0.BF.SEL_51 = 0;\n    break;\n    \n  case PMU_INT52_GPIO_36:\n    PMU->EXT_SEL_REG0.BF.SEL_52 = 1;\n    break;\n    \n  case PMU_INT52_GPIO_37:\n    PMU->EXT_SEL_REG0.BF.SEL_52 = 0;\n    break;\n    \n  case PMU_INT53_GPIO_38:\n    PMU->EXT_SEL_REG0.BF.SEL_53 = 1;\n    break;\n    \n  case PMU_INT53_GPIO_39:\n    PMU->EXT_SEL_REG0.BF.SEL_53 = 0;\n    break;\n    \n  case PMU_INT54_GPIO_40:\n    PMU->EXT_SEL_REG0.BF.SEL_54 = 1;\n    break;\n    \n  case PMU_INT54_GPIO_41:\n    PMU->EXT_SEL_REG0.BF.SEL_54 = 0;\n    break;\n    \n  case PMU_INT55_GPIO_42:\n    PMU->EXT_SEL_REG0.BF.SEL_55 = 1;\n    break;\n    \n  case PMU_INT55_GPIO_43:\n    PMU->EXT_SEL_REG0.BF.SEL_55 = 0;\n    break; \n    \n  case PMU_INT56_GPIO_44:\n    PMU->EXT_SEL_REG0.BF.SEL_56 = 1;\n    break;\n    \n  case PMU_INT56_GPIO_45:\n    PMU->EXT_SEL_REG0.BF.SEL_56 = 0;\n    break; \n    \n  case PMU_INT57_GPIO_46:\n    PMU->EXT_SEL_REG0.BF.SEL_57 = 1;\n    break;\n    \n  case PMU_INT57_GPIO_47:\n    PMU->EXT_SEL_REG0.BF.SEL_57 = 0;\n    break;\n    \n  case PMU_INT58_GPIO_48:\n    PMU->EXT_SEL_REG0.BF.SEL_58 = 1;\n    break;\n    \n  case PMU_INT58_GPIO_49:\n    PMU->EXT_SEL_REG0.BF.SEL_58 = 0;\n    break;\n\n  default:\n    break;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Enable/Disable vbat brndet\n *\n * @param[in]  state:  enable/disable\n *\n * @return none\n *\n *******************************************************************************/\n", "func_signal": "void PMU_VbatBrndetCmd(FunctionalState state)", "code": "{\n  CHECK_PARAM(PARAM_FUNCTIONALSTATE(state));\n  \n  PMU->PMIP_BRNDET_VBAT.BF.BRNDET_VBAT_EN = ((state  == ENABLE)? 1 : 0);\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "/**\n * @brief      Get vbat brndet ready status\n *\n * @param[in]  none\n *\n * @return status\n *\n *******************************************************************************/\n", "func_signal": "FlagStatus PMU_GetVbatBrndetStatus(void)", "code": "{\n  uint32_t rdyStatus = 0;\n  \n  rdyStatus = PMU->PMIP_BRNDET_VBAT.BF.BRNDET_VBAT_RDY;\n  \n  if(rdyStatus)\n  {\n    return SET;\n  }\n  else\n  {\n    return RESET;\n  }\n}", "path": "amazon-freertos/vendors/marvell/WMSDK/mw320/sdk/src/drivers/mw300/lowlevel/mw300_pmu.c", "commit_date": "2019-10-08 00:00:00", "repo_name": "aws/amazon-freertos", "stars": 2534, "license": "mit", "language": "c", "size": 288797}
{"docstring": "// map instruction name to public instruction ID\n", "func_signal": "arm64_reg AArch64_map_insn(const char *name)", "code": "{\n\t// NOTE: skip first NULL name in insn_name_maps\n\tint i = name2id(&insn_name_maps[1], ARR_SIZE(insn_name_maps) - 1, name);\n\n\tif (i == -1)\n\t\t// try again with 'special' insn that is not available in insn_name_maps\n\t\ti = name2id(alias_insn_name_maps, ARR_SIZE(alias_insn_name_maps), name);\n\n\treturn (i != -1)? i : ARM64_REG_INVALID;\n}", "path": "MachOView/capstone/arch/AArch64/AArch64Mapping.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "/// Prints the shift value with an immediate value.\n", "func_signal": "static void printRegImmShift(MCInst *MI, SStream *O, ARM_AM_ShiftOpc ShOpc, unsigned ShImm)", "code": "{\n\tif (ShOpc == ARM_AM_no_shift || (ShOpc == ARM_AM_lsl && !ShImm))\n\t\treturn;\n\tSStream_concat0(O, \", \");\n\n\t//assert (!(ShOpc == ARM_AM_ror && !ShImm) && \"Cannot have ror #0\");\n\tSStream_concat0(O, ARM_AM_getShiftOpcStr(ShOpc));\n\tif (MI->csh->detail) {\n\t\tif (MI->csh->doing_mem)\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].shift.type = (arm_shifter)ShOpc;\n\t\telse\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count - 1].shift.type = (arm_shifter)ShOpc;\n\t}\n\n\tif (ShOpc != ARM_AM_rrx) {\n\t\tSStream_concat0(O, \" \");\n\t\tSStream_concat(O, \"#%u\", translateShiftImm(ShImm));\n\t\tif (MI->csh->detail) {\n\t\t\tif (MI->csh->doing_mem)\n\t\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].shift.value = translateShiftImm(ShImm);\n\t\t\telse\n\t\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count - 1].shift.value = translateShiftImm(ShImm);\n\t\t}\n\t}\n}", "path": "MachOView/capstone/arch/ARM/ARMInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// given internal insn id, return public instruction info\n", "func_signal": "void AArch64_get_insn_id(cs_struct *h, cs_insn *insn, unsigned int id)", "code": "{\n\tint i = insn_find(insns, ARR_SIZE(insns), id, &h->insn_cache);\n\tif (i != 0) {\n\t\tinsn->id = insns[i].mapid;\n\n\t\tif (h->detail) {\n#ifndef CAPSTONE_DIET\n\t\t\tcs_struct handle;\n\t\t\thandle.detail = h->detail;\n\n\t\t\tmemcpy(insn->detail->regs_read, insns[i].regs_use, sizeof(insns[i].regs_use));\n\t\t\tinsn->detail->regs_read_count = (uint8_t)count_positive(insns[i].regs_use);\n\n\t\t\tmemcpy(insn->detail->regs_write, insns[i].regs_mod, sizeof(insns[i].regs_mod));\n\t\t\tinsn->detail->regs_write_count = (uint8_t)count_positive(insns[i].regs_mod);\n\n\t\t\tmemcpy(insn->detail->groups, insns[i].groups, sizeof(insns[i].groups));\n\t\t\tinsn->detail->groups_count = (uint8_t)count_positive(insns[i].groups);\n\n\t\t\tinsn->detail->arm64.update_flags = cs_reg_write((csh)&handle, insn, ARM64_REG_NZCV);\n\n\t\t\tif (insns[i].branch || insns[i].indirect_branch) {\n\t\t\t\t// this insn also belongs to JUMP group. add JUMP group\n\t\t\t\tinsn->detail->groups[insn->detail->groups_count] = ARM64_GRP_JUMP;\n\t\t\t\tinsn->detail->groups_count++;\n\t\t\t}\n#endif\n\t\t}\n\t}\n}", "path": "MachOView/capstone/arch/AArch64/AArch64Mapping.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "//===--------------------------------------------------------------------===//\n// Addressing Mode #3\n//===--------------------------------------------------------------------===//\n", "func_signal": "static void printAM3PreOrOffsetIndexOp(MCInst *MI, unsigned Op, SStream *O,\n\t\tbool AlwaysPrintImm0)", "code": "{\n\tMCOperand *MO1 = MCInst_getOperand(MI, Op);\n\tMCOperand *MO2 = MCInst_getOperand(MI, Op+1);\n\tMCOperand *MO3 = MCInst_getOperand(MI, Op+2);\n\tARM_AM_AddrOpc subtracted = getAM3Op((unsigned int)MCOperand_getImm(MO3));\n\tunsigned ImmOffs;\n\n\tSStream_concat0(O, \"[\");\n\tset_mem_access(MI, true);\n\tprintRegName(MI->csh, O, MCOperand_getReg(MO1));\n\tif (MI->csh->detail)\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].mem.base = MCOperand_getReg(MO1);\n\n\tif (MCOperand_getReg(MO2)) {\n\t\tSStream_concat0(O, \", \");\n\t\tSStream_concat0(O, ARM_AM_getAddrOpcStr(subtracted));\n\t\tprintRegName(MI->csh, O, MCOperand_getReg(MO2));\n\t\tif (MI->csh->detail) {\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].mem.index = MCOperand_getReg(MO2);\n\t\t\tif (subtracted) {\n\t\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].mem.scale = -1;\n\t\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].subtracted = true;\n\t\t\t}\n\t\t}\n\t\tSStream_concat0(O, \"]\");\n\t\tset_mem_access(MI, false);\n\t\treturn;\n\t}\n\n\t//If the op is sub we have to print the immediate even if it is 0\n\tImmOffs = getAM3Offset((unsigned int)MCOperand_getImm(MO3));\n\n\tif (AlwaysPrintImm0 || ImmOffs || (subtracted == ARM_AM_sub)) {\n\t\tif (ImmOffs > HEX_THRESHOLD)\n\t\t\tSStream_concat(O, \", #%s0x%x\", ARM_AM_getAddrOpcStr(subtracted), ImmOffs);\n\t\telse\n\t\t\tSStream_concat(O, \", #%s%u\", ARM_AM_getAddrOpcStr(subtracted), ImmOffs);\n\t}\n\n\tif (MI->csh->detail) {\n\t\tif (subtracted) {\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].mem.disp = (int)ImmOffs;\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].subtracted = true;\n\t\t} else\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].mem.disp = -(int)ImmOffs;\n\t}\n\n\tSStream_concat0(O, \"]\");\n\tset_mem_access(MI, false);\n}", "path": "MachOView/capstone/arch/ARM/ARMInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// local printOperand, without updating public operands\n", "func_signal": "static void _printOperand(MCInst *MI, unsigned OpNo, SStream *O)", "code": "{\n\tMCOperand *Op  = MCInst_getOperand(MI, OpNo);\n\tif (MCOperand_isReg(Op)) {\n\t\tprintRegName(O, MCOperand_getReg(Op));\n\t} else if (MCOperand_isImm(Op)) {\n\t\t// Print X86 immediates as signed values.\n\t\tint64_t imm = MCOperand_getImm(Op);\n\t\tif (imm < 0) {\n\t\t\tif (imm < -HEX_THRESHOLD)\n\t\t\t\tSStream_concat(O, \"$-0x%\"PRIx64, -imm);\n\t\t\telse\n\t\t\t\tSStream_concat(O, \"$-%\"PRIu64, -imm);\n\t\t} else {\n\t\t\tif (imm > HEX_THRESHOLD)\n\t\t\t\tSStream_concat(O, \"$0x%\"PRIx64, imm);\n\t\t\telse\n\t\t\t\tSStream_concat(O, \"$%\"PRIu64, imm);\n\t\t}\n\t}\n}", "path": "MachOView/capstone/arch/X86/X86ATTInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// dynamicly allocate memory to contain disasm insn\n// NOTE: caller must free() the allocated memory itself to avoid memory leaking\n", "func_signal": "CAPSTONE_EXPORT\nsize_t cs_disasm(csh ud, const uint8_t *buffer, size_t size, uint64_t offset, size_t count, cs_insn **insn)", "code": "{\n\tstruct cs_struct *handle;\n\tMCInst mci;\n\tuint16_t insn_size;\n\tsize_t c = 0, i;\n\tunsigned int f = 0;\t// index of the next instruction in the cache\n\tcs_insn *insn_cache;\t// cache contains disassembled instructions\n\tvoid *total = NULL;\n\tsize_t total_size = 0;\t// total size of output buffer containing all insns\n\tbool r;\n\tvoid *tmp;\n\tsize_t skipdata_bytes;\n\tuint64_t offset_org; // save all the original info of the buffer\n\tsize_t size_org;\n\tconst uint8_t *buffer_org;\n\tunsigned int cache_size = INSN_CACHE_SIZE;\n\tsize_t next_offset;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\tif (!handle) {\n\t\t// FIXME: how to handle this case:\n\t\t// handle->errnum = CS_ERR_HANDLE;\n\t\treturn 0;\n\t}\n\n\thandle->errnum = CS_ERR_OK;\n\n#ifdef CAPSTONE_USE_SYS_DYN_MEM\n\tif (count > 0 && count <= INSN_CACHE_SIZE)\n\t\tcache_size = (unsigned int) count;\n#endif\n\n\t// save the original offset for SKIPDATA\n\tbuffer_org = buffer;\n\toffset_org = offset;\n\tsize_org = size;\n\n\ttotal_size = sizeof(cs_insn) * cache_size;\n\ttotal = cs_mem_malloc(total_size);\n\tif (total == NULL) {\n\t\t// insufficient memory\n\t\thandle->errnum = CS_ERR_MEM;\n\t\treturn 0;\n\t}\n\n\tinsn_cache = total;\n\n\twhile (size > 0) {\n\t\tMCInst_Init(&mci);\n\t\tmci.csh = handle;\n\n\t\t// relative branches need to know the address & size of current insn\n\t\tmci.address = offset;\n\n\t\tif (handle->detail) {\n\t\t\t// allocate memory for @detail pointer\n\t\t\tinsn_cache->detail = cs_mem_malloc(sizeof(cs_detail));\n\t\t} else {\n\t\t\tinsn_cache->detail = NULL;\n\t\t}\n\n\t\t// save all the information for non-detailed mode\n\t\tmci.flat_insn = insn_cache;\n\t\tmci.flat_insn->address = offset;\n#ifdef CAPSTONE_DIET\n\t\t// zero out mnemonic & op_str\n\t\tmci.flat_insn->mnemonic[0] = '\\0';\n\t\tmci.flat_insn->op_str[0] = '\\0';\n#endif\n\n\t\tr = handle->disasm(ud, buffer, size, &mci, &insn_size, offset, handle->getinsn_info);\n\t\tif (r) {\n\t\t\tSStream ss;\n\t\t\tSStream_Init(&ss);\n\n\t\t\tmci.flat_insn->size = insn_size;\n\n\t\t\t// map internal instruction opcode to public insn ID\n\t\t\thandle->insn_id(handle, insn_cache, mci.Opcode);\n\n\t\t\thandle->printer(&mci, &ss, handle->printer_info);\n\n\t\t\tfill_insn(handle, insn_cache, ss.buffer, &mci, handle->post_printer, buffer);\n\n\t\t\tnext_offset = insn_size;\n\t\t} else\t{\n\t\t\t// encounter a broken instruction\n\n\t\t\t// free memory of @detail pointer\n\t\t\tif (handle->detail) {\n\t\t\t\tcs_mem_free(insn_cache->detail);\n\t\t\t}\n\n\t\t\t// if there is no request to skip data, or remaining data is too small,\n\t\t\t// then bail out\n\t\t\tif (!handle->skipdata || handle->skipdata_size > size)\n\t\t\t\tbreak;\n\n\t\t\tif (handle->skipdata_setup.callback) {\n\t\t\t\tskipdata_bytes = handle->skipdata_setup.callback(buffer_org, size_org,\n\t\t\t\t\t\t(size_t)(offset - offset_org), handle->skipdata_setup.user_data);\n\t\t\t\tif (skipdata_bytes > size)\n\t\t\t\t\t// remaining data is not enough\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!skipdata_bytes)\n\t\t\t\t\t// user requested not to skip data, so bail out\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tskipdata_bytes = handle->skipdata_size;\n\n\t\t\t// we have to skip some amount of data, depending on arch & mode\n\t\t\tinsn_cache->id = 0;\t// invalid ID for this \"data\" instruction\n\t\t\tinsn_cache->address = offset;\n\t\t\tinsn_cache->size = (uint16_t)skipdata_bytes;\n\t\t\tmemcpy(insn_cache->bytes, buffer, skipdata_bytes);\n\t\t\tstrncpy(insn_cache->mnemonic, handle->skipdata_setup.mnemonic,\n\t\t\t\t\tsizeof(insn_cache->mnemonic) - 1);\n\t\t\tskipdata_opstr(insn_cache->op_str, buffer, skipdata_bytes);\n\t\t\tinsn_cache->detail = NULL;\n\n\t\t\tnext_offset = skipdata_bytes;\n\t\t}\n\n\t\t// one more instruction entering the cache\n\t\tf++;\n\n\t\t// one more instruction disassembled\n\t\tc++;\n\t\tif (count > 0 && c == count)\n\t\t\t// already got requested number of instructions\n\t\t\tbreak;\n\n\t\tif (f == cache_size) {\n\t\t\t// full cache, so expand the cache to contain incoming insns\n\t\t\tcache_size = cache_size * 8 / 5; // * 1.6 ~ golden ratio\n\t\t\ttotal_size += (sizeof(cs_insn) * cache_size);\n\t\t\ttmp = cs_mem_realloc(total, total_size);\n\t\t\tif (tmp == NULL) {\t// insufficient memory\n\t\t\t\tif (handle->detail) {\n\t\t\t\t\tinsn_cache = (cs_insn *)total;\n\t\t\t\t\tfor (i = 0; i < c; i++, insn_cache++)\n\t\t\t\t\t\tcs_mem_free(insn_cache->detail);\n\t\t\t\t}\n\n\t\t\t\tcs_mem_free(total);\n\t\t\t\t*insn = NULL;\n\t\t\t\thandle->errnum = CS_ERR_MEM;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\ttotal = tmp;\n\t\t\t// continue to fill in the cache after the last instruction\n\t\t\tinsn_cache = (cs_insn *)((char *)total + sizeof(cs_insn) * c);\n\n\t\t\t// reset f back to 0, so we fill in the cache from begining\n\t\t\tf = 0;\n\t\t} else\n\t\t\tinsn_cache++;\n\n\t\tbuffer += next_offset;\n\t\tsize -= next_offset;\n\t\toffset += next_offset;\n\t}\n\n\tif (!c) {\n\t\t// we did not disassemble any instruction\n\t\tcs_mem_free(total);\n\t\ttotal = NULL;\n\t} else if (f != cache_size) {\n\t\t// total did not fully use the last cache, so downsize it\n\t\tvoid *tmp = cs_mem_realloc(total, total_size - (cache_size - f) * sizeof(*insn_cache));\n\t\tif (tmp == NULL) {\t// insufficient memory\n\t\t\t// free all detail pointers\n\t\t\tif (handle->detail) {\n\t\t\t\tinsn_cache = (cs_insn *)total;\n\t\t\t\tfor (i = 0; i < c; i++, insn_cache++)\n\t\t\t\t\tcs_mem_free(insn_cache->detail);\n\t\t\t}\n\n\t\t\tcs_mem_free(total);\n\t\t\t*insn = NULL;\n\n\t\t\thandle->errnum = CS_ERR_MEM;\n\t\t\treturn 0;\n\t\t}\n\n\t\ttotal = tmp;\n\t}\n\n\t*insn = total;\n\n\treturn c;\n}", "path": "MachOView/capstone/cs.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// SETEND BE/LE\n", "func_signal": "static void printSetendOperand(MCInst *MI, unsigned OpNum, SStream *O)", "code": "{\n\tMCOperand *Op = MCInst_getOperand(MI, OpNum);\n\tif (MCOperand_getImm(Op)) {\n\t\tSStream_concat0(O, \"be\");\n\t\tif (MI->csh->detail) {\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].type = ARM_OP_SETEND;\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].setend = ARM_SETEND_BE;\n\t\t\tMI->flat_insn->detail->arm.op_count++;\n\t\t}\n\t} else {\n\t\tSStream_concat0(O, \"le\");\n\t\tif (MI->csh->detail) {\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].type = ARM_OP_SETEND;\n\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].setend = ARM_SETEND_LE;\n\t\t\tMI->flat_insn->detail->arm.op_count++;\n\t\t}\n\t}\n}", "path": "MachOView/capstone/arch/ARM/ARMInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "/// printPCRelImm - This is used to print an immediate value that ends up\n/// being encoded as a pc-relative value (e.g. for jumps and calls).  These\n/// print slightly differently than normal immediates.  For example, a $ is not\n/// emitted.\n", "func_signal": "static void printPCRelImm(MCInst *MI, unsigned OpNo, SStream *O)", "code": "{\n\tMCOperand *Op = MCInst_getOperand(MI, OpNo);\n\tif (MCOperand_isImm(Op)) {\n\t\tint64_t imm = MCOperand_getImm(Op) + MI->flat_insn->size + MI->address;\n\t\tif (imm < 0) {\n\t\t\tSStream_concat(O, \"0x%\"PRIx64, imm);\n\t\t} else {\n\t\t\t// handle 16bit segment bound\n\t\t\tif (MI->csh->mode == CS_MODE_16 && imm > 0x100000)\n\t\t\t\timm -= 0x10000;\n\n\t\t\tif (imm > HEX_THRESHOLD)\n\t\t\t\tSStream_concat(O, \"0x%\"PRIx64, imm);\n\t\t\telse\n\t\t\t\tSStream_concat(O, \"%\"PRIu64, imm);\n\t\t}\n\t\tif (MI->csh->detail) {\n\t\t\tMI->flat_insn->detail->x86.operands[MI->flat_insn->detail->x86.op_count].type = X86_OP_IMM;\n\t\t\tMI->has_imm = true;\n\t\t\tMI->flat_insn->detail->x86.operands[MI->flat_insn->detail->x86.op_count].imm = imm;\n\t\t\tMI->flat_insn->detail->x86.op_count++;\n\t\t}\n\t}\n}", "path": "MachOView/capstone/arch/X86/X86ATTInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// TODO: test this\n", "func_signal": "static void printMandatoryPredicateOperand(MCInst *MI, unsigned OpNum, SStream *O)", "code": "{\n\tARMCC_CondCodes CC = (ARMCC_CondCodes)MCOperand_getImm(MCInst_getOperand(MI, OpNum));\n\tSStream_concat0(O, ARMCC_ARMCondCodeToString(CC));\n\tif (MI->csh->detail)\n\t\tMI->flat_insn->detail->arm.cc = CC + 1;\n}", "path": "MachOView/capstone/arch/ARM/ARMInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// we need this since Windows doesnt have snprintf()\n", "func_signal": "int cs_snprintf(char *buffer, size_t size, const char *fmt, ...)", "code": "{\n\tint ret;\n\n\tva_list ap;\n\tva_start(ap, fmt);\n\tret = cs_vsnprintf(buffer, size, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}", "path": "MachOView/capstone/utils.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// create a cache for fast id lookup\n", "func_signal": "static unsigned short *make_id2insn(insn_map *insns, unsigned int size)", "code": "{\n\t// NOTE: assume that the max id is always put at the end of insns array\n\tunsigned short max_id = insns[size - 1].id;\n\tunsigned short i;\n\n\tunsigned short *cache = (unsigned short *)cs_mem_malloc(sizeof(*cache) * (max_id + 1));\n\n\tfor (i = 1; i < size; i++)\n\t\tcache[insns[i].id] = i;\n\n\treturn cache;\n}", "path": "MachOView/capstone/utils.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// map internal raw vregister to 'public' register\n", "func_signal": "arm64_reg AArch64_map_vregister(unsigned int r)", "code": "{\n\t// for some reasons different Arm64 can map different register number to\n\t// the same register. this function handles the issue for exposing Mips\n\t// operands by mapping internal registers to 'public' register.\n\tunsigned int map[] = { 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, ARM64_REG_V0,\n\t\tARM64_REG_V1, ARM64_REG_V2, ARM64_REG_V3, ARM64_REG_V4, ARM64_REG_V5,\n\t\tARM64_REG_V6, ARM64_REG_V7, ARM64_REG_V8, ARM64_REG_V9, ARM64_REG_V10,\n\t\tARM64_REG_V11, ARM64_REG_V12, ARM64_REG_V13, ARM64_REG_V14, ARM64_REG_V15,\n\t\tARM64_REG_V16, ARM64_REG_V17, ARM64_REG_V18, ARM64_REG_V19, ARM64_REG_V20,\n\t\tARM64_REG_V21, ARM64_REG_V22, ARM64_REG_V23, ARM64_REG_V24, ARM64_REG_V25,\n\t\tARM64_REG_V26, ARM64_REG_V27, ARM64_REG_V28, ARM64_REG_V29, ARM64_REG_V30,\n\t\tARM64_REG_V31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, ARM64_REG_V0, ARM64_REG_V1,\n\t\tARM64_REG_V2, ARM64_REG_V3, ARM64_REG_V4, ARM64_REG_V5, ARM64_REG_V6,\n\t\tARM64_REG_V7, ARM64_REG_V8, ARM64_REG_V9, ARM64_REG_V10, ARM64_REG_V11,\n\t\tARM64_REG_V12, ARM64_REG_V13, ARM64_REG_V14, ARM64_REG_V15, ARM64_REG_V16,\n\t\tARM64_REG_V17, ARM64_REG_V18, ARM64_REG_V19, ARM64_REG_V20, ARM64_REG_V21,\n\t\tARM64_REG_V22, ARM64_REG_V23, ARM64_REG_V24, ARM64_REG_V25, ARM64_REG_V26,\n\t\tARM64_REG_V27, ARM64_REG_V28, ARM64_REG_V29, ARM64_REG_V30, ARM64_REG_V31,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, ARM64_REG_V0, ARM64_REG_V1, ARM64_REG_V2,\n\t\tARM64_REG_V3, ARM64_REG_V4, ARM64_REG_V5, ARM64_REG_V6, ARM64_REG_V7,\n\t\tARM64_REG_V8, ARM64_REG_V9, ARM64_REG_V10, ARM64_REG_V11, ARM64_REG_V12,\n\t\tARM64_REG_V13, ARM64_REG_V14, ARM64_REG_V15, ARM64_REG_V16, ARM64_REG_V17,\n\t\tARM64_REG_V18, ARM64_REG_V19, ARM64_REG_V20, ARM64_REG_V21, ARM64_REG_V22,\n\t\tARM64_REG_V23, ARM64_REG_V24, ARM64_REG_V25, ARM64_REG_V26, ARM64_REG_V27,\n\t\tARM64_REG_V28, ARM64_REG_V29, ARM64_REG_V30, ARM64_REG_V31, ARM64_REG_V0,\n\t\tARM64_REG_V1, ARM64_REG_V2, ARM64_REG_V3, ARM64_REG_V4, ARM64_REG_V5,\n\t\tARM64_REG_V6, ARM64_REG_V7, ARM64_REG_V8, ARM64_REG_V9, ARM64_REG_V10,\n\t\tARM64_REG_V11, ARM64_REG_V12, ARM64_REG_V13, ARM64_REG_V14, ARM64_REG_V15,\n\t\tARM64_REG_V16, ARM64_REG_V17, ARM64_REG_V18, ARM64_REG_V19, ARM64_REG_V20,\n\t\tARM64_REG_V21, ARM64_REG_V22, ARM64_REG_V23, ARM64_REG_V24, ARM64_REG_V25,\n\t\tARM64_REG_V26, ARM64_REG_V27, ARM64_REG_V28, ARM64_REG_V29, ARM64_REG_V30,\n\t\tARM64_REG_V31, ARM64_REG_V0, ARM64_REG_V1, ARM64_REG_V2, ARM64_REG_V3,\n\t\tARM64_REG_V4, ARM64_REG_V5, ARM64_REG_V6, ARM64_REG_V7, ARM64_REG_V8,\n\t\tARM64_REG_V9, ARM64_REG_V10, ARM64_REG_V11, ARM64_REG_V12, ARM64_REG_V13,\n\t\tARM64_REG_V14, ARM64_REG_V15, ARM64_REG_V16, ARM64_REG_V17, ARM64_REG_V18,\n\t\tARM64_REG_V19, ARM64_REG_V20, ARM64_REG_V21, ARM64_REG_V22, ARM64_REG_V23,\n\t\tARM64_REG_V24, ARM64_REG_V25, ARM64_REG_V26, ARM64_REG_V27, ARM64_REG_V28,\n\t\tARM64_REG_V29, ARM64_REG_V30, ARM64_REG_V31, ARM64_REG_V0, ARM64_REG_V1,\n\t\tARM64_REG_V2, ARM64_REG_V3, ARM64_REG_V4, ARM64_REG_V5, ARM64_REG_V6,\n\t\tARM64_REG_V7, ARM64_REG_V8, ARM64_REG_V9, ARM64_REG_V10, ARM64_REG_V11,\n\t\tARM64_REG_V12, ARM64_REG_V13, ARM64_REG_V14, ARM64_REG_V15, ARM64_REG_V16,\n\t\tARM64_REG_V17, ARM64_REG_V18, ARM64_REG_V19, ARM64_REG_V20, ARM64_REG_V21,\n\t\tARM64_REG_V22, ARM64_REG_V23, ARM64_REG_V24, ARM64_REG_V25, ARM64_REG_V26,\n\t\tARM64_REG_V27, ARM64_REG_V28, ARM64_REG_V29, ARM64_REG_V30, ARM64_REG_V31,\n\t\tARM64_REG_V0, ARM64_REG_V1, ARM64_REG_V2, ARM64_REG_V3, ARM64_REG_V4,\n\t\tARM64_REG_V5, ARM64_REG_V6, ARM64_REG_V7, ARM64_REG_V8, ARM64_REG_V9,\n\t\tARM64_REG_V10, ARM64_REG_V11, ARM64_REG_V12, ARM64_REG_V13, ARM64_REG_V14,\n\t\tARM64_REG_V15, ARM64_REG_V16, ARM64_REG_V17, ARM64_REG_V18, ARM64_REG_V19,\n\t\tARM64_REG_V20, ARM64_REG_V21, ARM64_REG_V22, ARM64_REG_V23, ARM64_REG_V24,\n\t\tARM64_REG_V25, ARM64_REG_V26, ARM64_REG_V27, ARM64_REG_V28, ARM64_REG_V29,\n\t\tARM64_REG_V30, ARM64_REG_V31, ARM64_REG_V0, ARM64_REG_V1, ARM64_REG_V2,\n\t\tARM64_REG_V3, ARM64_REG_V4, ARM64_REG_V5, ARM64_REG_V6, ARM64_REG_V7,\n\t\tARM64_REG_V8, ARM64_REG_V9, ARM64_REG_V10, ARM64_REG_V11, ARM64_REG_V12,\n\t\tARM64_REG_V13, ARM64_REG_V14, ARM64_REG_V15, ARM64_REG_V16, ARM64_REG_V17,\n\t\tARM64_REG_V18, ARM64_REG_V19, ARM64_REG_V20, ARM64_REG_V21, ARM64_REG_V22,\n\t\tARM64_REG_V23, ARM64_REG_V24, ARM64_REG_V25, ARM64_REG_V26, ARM64_REG_V27,\n\t\tARM64_REG_V28, ARM64_REG_V29, ARM64_REG_V30, ARM64_REG_V31, };\n\n\tif (r < ARR_SIZE(map))\n\t\treturn map[r];\n\n\t// cannot find this register\n\treturn 0;\n}", "path": "MachOView/capstone/arch/AArch64/AArch64Mapping.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "//===--------------------------------------------------------------------===//\n// Addressing Mode #2\n//===--------------------------------------------------------------------===//\n", "func_signal": "static void printAM2PreOrOffsetIndexOp(MCInst *MI, unsigned Op, SStream *O)", "code": "{\n\tMCOperand *MO1 = MCInst_getOperand(MI, Op);\n\tMCOperand *MO2 = MCInst_getOperand(MI, Op + 1);\n\tMCOperand *MO3 = MCInst_getOperand(MI, Op + 2);\n\tARM_AM_AddrOpc subtracted = getAM2Op((unsigned int)MCOperand_getImm(MO3));\n\n\tSStream_concat0(O, \"[\");\n\tset_mem_access(MI, true);\n\n\tprintRegName(MI->csh, O, MCOperand_getReg(MO1));\n\tif (MI->csh->detail) {\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].mem.base = MCOperand_getReg(MO1);\n\t}\n\n\tif (!MCOperand_getReg(MO2)) {\n\t\tunsigned tmp = getAM2Offset((unsigned int)MCOperand_getImm(MO3));\n\t\tif (tmp) { // Don't print +0.\n\t\t\tsubtracted = getAM2Op((unsigned int)MCOperand_getImm(MO3));\n\n\t\t\tSStream_concat0(O, \", \");\n\t\t\tif (tmp > HEX_THRESHOLD)\n\t\t\t\tSStream_concat(O, \"#%s0x%x\", ARM_AM_getAddrOpcStr(subtracted), tmp);\n\t\t\telse\n\t\t\t\tSStream_concat(O, \"#%s%u\", ARM_AM_getAddrOpcStr(subtracted), tmp);\n\t\t\tif (MI->csh->detail) {\n\t\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].shift.type = (arm_shifter)getAM2Op((unsigned int)MCOperand_getImm(MO3));\n\t\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].shift.value = tmp;\n\t\t\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].subtracted = subtracted == ARM_AM_sub;\n\t\t\t}\n\t\t}\n\t\tSStream_concat0(O, \"]\");\n\t\tset_mem_access(MI, false);\n\t\treturn;\n\t}\n\n\tSStream_concat0(O, \", \");\n\tSStream_concat0(O, ARM_AM_getAddrOpcStr(subtracted));\n\tprintRegName(MI->csh, O, MCOperand_getReg(MO2));\n\tif (MI->csh->detail) {\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].mem.index = MCOperand_getReg(MO2);\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].subtracted = subtracted == ARM_AM_sub;\n\t}\n\n\tprintRegImmShift(MI, O, getAM2ShiftOpc((unsigned int)MCOperand_getImm(MO3)),\n\t\t\tgetAM2Offset((unsigned int)MCOperand_getImm(MO3)));\n\tSStream_concat0(O, \"]\");\n\tset_mem_access(MI, false);\n}", "path": "MachOView/capstone/arch/ARM/ARMInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "/// translateShiftImm - Convert shift immediate from 0-31 to 1-32 for printing.\n///\n/// getSORegOffset returns an integer from 0-31, representing '32' as 0.\n", "func_signal": "static unsigned translateShiftImm(unsigned imm)", "code": "{\n\t// lsr #32 and asr #32 exist, but should be encoded as a 0.\n\t//assert((imm & ~0x1f) == 0 && \"Invalid shift encoding\");\n\tif (imm == 0)\n\t\treturn 32;\n\treturn imm;\n}", "path": "MachOView/capstone/arch/ARM/ARMInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// Constant shifts t2_so_reg is a 2-operand unit corresponding to the Thumb2\n// register with shift forms.\n// REG 0   0           - e.g. R5\n// REG IMM, SH_OPC     - e.g. R5, LSL #3\n", "func_signal": "static void printT2SOOperand(MCInst *MI, unsigned OpNum, SStream *O)", "code": "{\n\tMCOperand *MO1 = MCInst_getOperand(MI, OpNum);\n\tMCOperand *MO2 = MCInst_getOperand(MI, OpNum+1);\n\n\tunsigned Reg = MCOperand_getReg(MO1);\n\tprintRegName(MI->csh, O, Reg);\n\tif (MI->csh->detail) {\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].type = ARM_OP_REG;\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].reg = Reg;\n\t\tMI->flat_insn->detail->arm.op_count++;\n\t}\n\n\t// Print the shift opc.\n\t//assert(MO2.isImm() && \"Not a valid t2_so_reg value!\");\n\tprintRegImmShift(MI, O, ARM_AM_getSORegShOp((unsigned int)MCOperand_getImm(MO2)),\n\t\t\tgetSORegOffset((unsigned int)MCOperand_getImm(MO2)));\n}", "path": "MachOView/capstone/arch/ARM/ARMInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// count number of positive members in a list.\n// NOTE: list must be guaranteed to end in 0\n", "func_signal": "unsigned int count_positive(unsigned char *list)", "code": "{\n\tunsigned int c;\n\n\tfor (c = 0; list[c] > 0; c++);\n\n\treturn c;\n}", "path": "MachOView/capstone/utils.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// so_reg is a 4-operand unit corresponding to register forms of the A5.1\n// \"Addressing Mode 1 - Data-processing operands\" forms.  This includes:\n//    REG 0   0           - e.g. R5\n//    REG REG 0,SH_OPC    - e.g. R5, ROR R3\n//    REG 0   IMM,SH_OPC  - e.g. R5, LSL #3\n", "func_signal": "static void printSORegRegOperand(MCInst *MI, unsigned OpNum, SStream *O)", "code": "{\n\tMCOperand *MO1 = MCInst_getOperand(MI, OpNum);\n\tMCOperand *MO2 = MCInst_getOperand(MI, OpNum+1);\n\tMCOperand *MO3 = MCInst_getOperand(MI, OpNum+2);\n\tARM_AM_ShiftOpc ShOpc;\n\n\tprintRegName(MI->csh, O, MCOperand_getReg(MO1));\n\n\tif (MI->csh->detail) {\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].type = ARM_OP_REG;\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].reg = MCOperand_getReg(MO1);\n\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].shift.type = (MCOperand_getImm(MO3) & 7) + ARM_SFT_ASR_REG - 1;\n\t\tMI->flat_insn->detail->arm.op_count++;\n\t}\n\n\t// Print the shift opc.\n\tShOpc = ARM_AM_getSORegShOp((unsigned int)MCOperand_getImm(MO3));\n\tSStream_concat0(O, \", \");\n\tSStream_concat0(O, ARM_AM_getShiftOpcStr(ShOpc));\n\tif (ShOpc == ARM_AM_rrx)\n\t\treturn;\n\n\tSStream_concat0(O, \" \");\n\tprintRegName(MI->csh, O, MCOperand_getReg(MO2));\n\tif (MI->csh->detail)\n\t\tMI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count - 1].shift.value = MCOperand_getReg(MO2);\n\t//assert(ARM_AM_getSORegOffset(MO3.getImm()) == 0);\n}", "path": "MachOView/capstone/arch/ARM/ARMInstPrinter.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// fill insn with mnemonic & operands info\n", "func_signal": "static void fill_insn(struct cs_struct *handle, cs_insn *insn, char *buffer, MCInst *mci,\n\t\tPostPrinter_t postprinter, const uint8_t *code)", "code": "{\n#ifndef CAPSTONE_DIET\n\tchar *sp, *mnem;\n#endif\n\tunsigned int copy_size = MIN(sizeof(insn->bytes), insn->size);\n\n\t// fill the instruction bytes.\n\t// we might skip some redundant bytes in front in the case of X86\n\tmemcpy(insn->bytes, code + insn->size - copy_size, copy_size);\n\tinsn->size = copy_size;\n\n\t// alias instruction might have ID saved in OpcodePub\n\tif (MCInst_getOpcodePub(mci))\n\t\tinsn->id = MCInst_getOpcodePub(mci);\n\n\t// post printer handles some corner cases (hacky)\n\tif (postprinter)\n\t\tpostprinter((csh)handle, insn, buffer, mci);\n\n#ifndef CAPSTONE_DIET\n\t// fill in mnemonic & operands\n\t// find first space or tab\n\tsp = buffer;\n\tmnem = insn->mnemonic;\n\tfor (sp = buffer; *sp; sp++) {\n\t\tif (*sp == ' '|| *sp == '\\t')\n\t\t\tbreak;\n\t\tif (*sp == '|')\t// lock|rep prefix for x86\n\t\t\t*sp = ' ';\n\t\t// copy to @mnemonic\n\t\t*mnem = *sp;\n\t\tmnem++;\n\t}\n\n\t*mnem = '\\0';\n\n\t// copy @op_str\n\tif (*sp) {\n\t\t// find the next non-space char\n\t\tsp++;\n\t\tfor (; ((*sp == ' ') || (*sp == '\\t')); sp++);\n\t\tstrncpy(insn->op_str, sp, sizeof(insn->op_str) - 1);\n\t\tinsn->op_str[sizeof(insn->op_str) - 1] = '\\0';\n\t} else\n\t\tinsn->op_str[0] = '\\0';\n#endif\n}", "path": "MachOView/capstone/cs.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// iterator for instruction \"single-stepping\"\n", "func_signal": "CAPSTONE_EXPORT\nbool cs_disasm_iter(csh ud, const uint8_t **code, size_t *size,\n\t\tuint64_t *address, cs_insn *insn)", "code": "{\n\tstruct cs_struct *handle;\n\tuint16_t insn_size;\n\tMCInst mci;\n\tbool r;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\tif (!handle) {\n\t\treturn false;\n\t}\n\n\thandle->errnum = CS_ERR_OK;\n\n\tMCInst_Init(&mci);\n\tmci.csh = handle;\n\n\t// relative branches need to know the address & size of current insn\n\tmci.address = *address;\n\n\t// save all the information for non-detailed mode\n\tmci.flat_insn = insn;\n\tmci.flat_insn->address = *address;\n#ifdef CAPSTONE_DIET\n\t// zero out mnemonic & op_str\n\tmci.flat_insn->mnemonic[0] = '\\0';\n\tmci.flat_insn->op_str[0] = '\\0';\n#endif\n\n\tr = handle->disasm(ud, *code, *size, &mci, &insn_size, *address, handle->getinsn_info);\n\tif (r) {\n\t\tSStream ss;\n\t\tSStream_Init(&ss);\n\n\t\tmci.flat_insn->size = insn_size;\n\n\t\t// map internal instruction opcode to public insn ID\n\t\thandle->insn_id(handle, insn, mci.Opcode);\n\n\t\thandle->printer(&mci, &ss, handle->printer_info);\n\n\t\tfill_insn(handle, insn, ss.buffer, &mci, handle->post_printer, *code);\n\n\t\t*code += insn_size;\n\t\t*size -= insn_size;\n\t\t*address += insn_size;\n\t} else { \t// encounter a broken instruction\n\t\tsize_t skipdata_bytes;\n\n\t\t// if there is no request to skip data, or remaining data is too small,\n\t\t// then bail out\n\t\tif (!handle->skipdata || handle->skipdata_size > *size)\n\t\t\treturn false;\n\n\t\tif (handle->skipdata_setup.callback) {\n\t\t\tskipdata_bytes = handle->skipdata_setup.callback(*code, *size,\n\t\t\t\t\t0, handle->skipdata_setup.user_data);\n\t\t\tif (skipdata_bytes > *size)\n\t\t\t\t// remaining data is not enough\n\t\t\t\treturn false;\n\n\t\t\tif (!skipdata_bytes)\n\t\t\t\t// user requested not to skip data, so bail out\n\t\t\t\treturn false;\n\t\t} else\n\t\t\tskipdata_bytes = handle->skipdata_size;\n\n\t\t// we have to skip some amount of data, depending on arch & mode\n\t\tinsn->id = 0;\t// invalid ID for this \"data\" instruction\n\t\tinsn->address = *address;\n\t\tinsn->size = (uint16_t)skipdata_bytes;\n\t\tmemcpy(insn->bytes, *code, skipdata_bytes);\n\t\tstrncpy(insn->mnemonic, handle->skipdata_setup.mnemonic,\n\t\t\t\tsizeof(insn->mnemonic) - 1);\n\t\tskipdata_opstr(insn->op_str, *code, skipdata_bytes);\n\n\t\t*code += skipdata_bytes;\n\t\t*size -= skipdata_bytes;\n\t\t*address += skipdata_bytes;\n\t}\n\n\treturn true;\n}", "path": "MachOView/capstone/cs.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "// how many bytes will we skip when encountering data (CS_OPT_SKIPDATA)?\n// this very much depends on instruction alignment requirement of each arch.\n", "func_signal": "static uint8_t skipdata_size(cs_struct *handle)", "code": "{\n\tswitch(handle->arch) {\n\t\tdefault:\n\t\t\t// should never reach\n\t\t\treturn -1;\n\t\tcase CS_ARCH_ARM:\n\t\t\t// skip 2 bytes on Thumb mode.\n\t\t\tif (handle->mode & CS_MODE_THUMB)\n\t\t\t\treturn 2;\n\t\t\t// otherwise, skip 4 bytes\n\t\t\treturn 4;\n\t\tcase CS_ARCH_ARM64:\n\t\tcase CS_ARCH_MIPS:\n\t\tcase CS_ARCH_PPC:\n\t\tcase CS_ARCH_SPARC:\n\t\t\t// skip 4 bytes\n\t\t\treturn 4;\n\t\tcase CS_ARCH_SYSZ:\n\t\t\t// SystemZ instruction's length can be 2, 4 or 6 bytes,\n\t\t\t// so we just skip 2 bytes\n\t\t\treturn 2;\n\t\tcase CS_ARCH_X86:\n\t\t\t// X86 has no restriction on instruction alignment\n\t\t\treturn 1;\n\t\tcase CS_ARCH_XCORE:\n\t\t\t// XCore instruction's length can be 2 or 4 bytes,\n\t\t\t// so we just skip 2 bytes\n\t\t\treturn 2;\n\t}\n}", "path": "MachOView/capstone/cs.c", "commit_date": "2015-04-23 00:00:00", "repo_name": "gdbinit/MachOView", "stars": 2585, "license": "mit", "language": "c", "size": 13199}
{"docstring": "/*static ngx_inline void str_to_buf(ngx_buf_t *buf, ngx_str_t *str) {\n  buf->start = str->data;\n  buf->pos = str->data;\n  buf->end = str->data + str->len;\n  buf->last = buf->end;\n  buf->memory = 1;\n}\n*/\n", "func_signal": "static void es_ensure_headers_sent(full_subscriber_t *fsub)", "code": "{\n  static const ngx_str_t   content_type = ngx_string(\"text/event-stream; charset=utf-8\");\n  static const ngx_str_t   hello = ngx_string(\": hi\\n\\n\");\n  ngx_http_request_t             *r = fsub->sub.request;\n  ngx_http_core_loc_conf_t       *clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n  \n  nchan_buf_and_chain_t          *bc;\n  \n  if(!fsub->data.shook_hands) {\n    bc = nchan_bufchain_pool_reserve(fsub_bcp(fsub), 1);\n    clcf->chunked_transfer_encoding = 0;\n    \n    r->headers_out.content_type.len = content_type.len;\n    r->headers_out.content_type.data = content_type.data;\n    r->headers_out.content_length_n = -1;\n    //send headers\n    \n    nchan_cleverly_output_headers_only_for_later_response(r);\n    \n    //send a \":hi\" comment\n    ngx_init_set_membuf(&bc->buf, hello.data, hello.data + hello.len);\n    \n    bc->buf.last_buf = 0;\n    bc->buf.flush = 1;\n    \n    r->chunked = 0;\n    r->header_only = 0;\n    \n    nchan_output_filter(fsub->sub.request, &bc->chain);\n    \n    fsub->data.shook_hands = 1; \n  }\n}", "path": "nchan/src/subscribers/eventsource.c", "commit_date": "2020-03-17 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* Helper functions to push/shift callbacks */\n", "func_signal": "static int __redisPushCallback(redisCallbackList *list, redisCallback *source)", "code": "{\n    redisCallback *cb;\n\n    /* Copy callback from stack to heap */\n    cb = malloc(sizeof(*cb));\n    if (cb == NULL)\n        return REDIS_ERR_OOM;\n\n    if (source != NULL) {\n        memcpy(cb,source,sizeof(*cb));\n        cb->next = NULL;\n    }\n\n    /* Store callback in list */\n    if (list->head == NULL)\n        list->head = cb;\n    if (list->tail != NULL)\n        list->tail->next = cb;\n    list->tail = cb;\n    return REDIS_OK;\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/*static ngx_inline void *thing_prev(nchan_reuse_queue_t *rq, void *thing) {\n  return *thing_prev_ptr(rq, thing);\n}\n\n\nstatic void check_queue(nchan_reuse_queue_t *rq) {\n  void *cur;\n  for(cur = rq->first; cur != NULL; cur = thing_next(rq, cur)) {\n    if(thing_prev_ptr(rq, rq->first)) {\n      assert(thing_prev(rq, rq->first) != rq->first);\n    }\n    if(thing_next_ptr(rq, rq->first)) {\n      assert(thing_next(rq, rq->first) != rq->first);\n    }\n  }\n}\n*/\n", "func_signal": "ngx_int_t nchan_reuse_queue_flush(nchan_reuse_queue_t *rq)", "code": "{\n  void *pd = rq->pd;\n  void *thing, *next;\n  ngx_int_t     i=0;\n  next = rq->first;\n  while((thing = next) != NULL) {\n    i++;\n    next = thing_next(rq, thing);\n    if(rq->free) rq->free(pd, thing);\n  }\n  rq->reserve = rq->first;\n  rq->first = NULL;\n  rq->last = NULL;\n  return i;\n}", "path": "nchan/src/util/nchan_reuse_queue.c", "commit_date": "2016-05-12 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/////////// GROUPS ///////////\n", "func_signal": "ngx_int_t memstore_ipc_send_get_group(ngx_int_t dst, ngx_str_t *group_id)", "code": "{\n  ngx_str_t         *shm_id = str_shm_copy(group_id);\n  if(shm_id == NULL) {\n    nchan_log_ooshm_error(\"sending IPC get-group alert for group %V\", group_id);\n    return NGX_DECLINED;\n  }\n  DBG(\"send GET GROUP to %i %p %V\", dst, shm_id, shm_id);\n  ipc_cmd(get_group, dst, &shm_id);\n  return NGX_OK;\n}", "path": "nchan/src/store/memory/ipc-handlers.c", "commit_date": "2018-10-06 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "//for retrieving messages from unready buffers\n", "func_signal": "static ngx_int_t ipc_getmsg_proxy_callback(ngx_int_t code, nchan_msg_t *msg, getmessage_data_proxy_pd_t *ppd)", "code": "{\n  ppd->data.d.resp.getmsg_code = code;\n  ppd->data.d.resp.shm_msg = msg;\n  if(msg) {\n    assert(msg_reserve(msg, \"get_message_reply\") == NGX_OK);\n  }\n  ipc_cmd(get_message_reply, ppd->sender, &ppd->data);\n  ngx_free(ppd);\n  return NGX_OK;\n}", "path": "nchan/src/store/memory/ipc-handlers.c", "commit_date": "2018-10-06 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* Helper function to make the disconnect happen and clean up. */\n", "func_signal": "static void __redisAsyncDisconnect(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n\n    /* Make sure error is accessible if there is any */\n    __redisAsyncCopyError(ac);\n\n    if (ac->err == 0) {\n        /* For clean disconnects, there should be no pending callbacks. */\n        assert(__redisShiftCallback(&ac->replies,NULL) == REDIS_ERR);\n    } else {\n        /* Disconnection is caused by an error, make sure that pending\n         * callbacks cannot call new commands. */\n        c->flags |= REDIS_DISCONNECTING;\n    }\n\n    /* For non-clean disconnects, __redisAsyncFree() will execute pending\n     * callbacks with a NULL-reply. */\n    __redisAsyncFree(ac);\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* Sets a pointer to the first argument and its length starting at p. Returns\n * the number of bytes to skip to get to the following argument. */\n", "func_signal": "static const char *nextArgument(const char *start, const char **str, size_t *len)", "code": "{\n    const char *p = start;\n    if (p[0] != '$') {\n        p = strchr(p,'$');\n        if (p == NULL) return NULL;\n    }\n\n    *len = (int)strtol(p+1,NULL,10);\n    p = strchr(p,'\\r');\n    assert(p);\n    *str = p+2;\n    return p+2+(*len)+2;\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* We want the error field to be accessible directly instead of requiring\n * an indirection to the redisContext struct. */\n", "func_signal": "static void __redisAsyncCopyError(redisAsyncContext *ac)", "code": "{\n    if (!ac)\n        return;\n\n    redisContext *c = &(ac->c);\n    ac->err = c->err;\n    ac->errstr = c->errstr;\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* Free the async context. When this function is called from a callback,\n * control needs to be returned to redisProcessCallbacks() before actual\n * free'ing. To do so, a flag is set on the context which is picked up by\n * redisProcessCallbacks(). Otherwise, the context is immediately free'd. */\n", "func_signal": "void redisAsyncFree(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n    c->flags |= REDIS_FREEING;\n    if (!(c->flags & REDIS_IN_CALLBACK))\n        __redisAsyncFree(ac);\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* Tries to do a clean disconnect from Redis, meaning it stops new commands\n * from being issued, but tries to flush the output buffer and execute\n * callbacks for all remaining replies. When this function is called from a\n * callback, there might be more replies and we can safely defer disconnecting\n * to redisProcessCallbacks(). Otherwise, we can only disconnect immediately\n * when there are no pending callbacks. */\n", "func_signal": "void redisAsyncDisconnect(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n    c->flags |= REDIS_DISCONNECTING;\n    if (!(c->flags & REDIS_IN_CALLBACK) && ac->replies.head == NULL)\n        __redisAsyncDisconnect(ac);\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "//general request-output functions and the iraq and the asian countries and dated references and the, uh, such\n", "func_signal": "void nchan_flush_pending_output(ngx_http_request_t *r)", "code": "{\n  int                        rc;\n  ngx_event_t               *wev;\n  ngx_connection_t          *c;\n  ngx_http_core_loc_conf_t  *clcf;\n  \n  c = r->connection;\n  wev = c->write;\n  \n  //ngx_log_debug2(NGX_LOG_DEBUG_HTTP, wev->log, 0, \"http writer handler: \\\"%V?%V\\\"\", &r->uri, &r->args);\n\n  clcf = ngx_http_get_module_loc_conf(r->main, ngx_http_core_module);\n\n  if (wev->timedout) {\n    if (!wev->delayed) {\n      ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"request timed out\");\n      c->timedout = 1;\n      nchan_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n      return;\n    }\n    wev->timedout = 0;\n    wev->delayed = 0;\n\n    if (!wev->ready) {\n      ngx_add_timer(wev, clcf->send_timeout);\n      if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {\n        nchan_http_finalize_request(r, 0);\n      }\n      return;\n    }\n  }\n  \n  if (wev->delayed || r->aio) {\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, wev->log, 0, \"http writer delayed\");\n    if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {\n      nchan_http_finalize_request(r, 0);\n    }\n    return;\n  }\n  \n  rc = nchan_output_filter(r, NULL);\n\n  //ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0, \"http writer output filter: %d, \\\"%V?%V\\\"\", rc, &r->uri, &r->args);\n\n  if (rc == NGX_ERROR) {\n    nchan_http_finalize_request(r, rc);\n    return;\n  }\n\n  if (r->buffered || r->postponed || (r == r->main && c->buffered)) {\n    if (!wev->delayed) {\n      ngx_add_timer(wev, clcf->send_timeout);\n    }\n    if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {\n      nchan_http_finalize_request(r, 0);\n      return;\n    }\n  }\n  //ngx_log_debug2(NGX_LOG_DEBUG_HTTP, wev->log, 0, \"http writer done: \\\"%V?%V\\\"\", &r->uri, &r->args);\n  if(r->out == NULL) {\n    r->write_event_handler = ngx_http_request_empty_handler;\n  }\n}", "path": "nchan/src/util/nchan_output.c", "commit_date": "2018-09-08 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* Helper function to free the context. */\n", "func_signal": "static void __redisAsyncFree(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n    redisCallback cb;\n    dictIterator *it;\n    dictEntry *de;\n\n    /* Execute pending callbacks with NULL reply. */\n    while (__redisShiftCallback(&ac->replies,&cb) == REDIS_OK)\n        __redisRunCallback(ac,&cb,NULL);\n\n    /* Execute callbacks for invalid commands */\n    while (__redisShiftCallback(&ac->sub.invalid,&cb) == REDIS_OK)\n        __redisRunCallback(ac,&cb,NULL);\n\n    /* Run subscription callbacks callbacks with NULL reply */\n    it = dictGetIterator(ac->sub.channels);\n    while ((de = dictNext(it)) != NULL)\n        __redisRunCallback(ac,dictGetEntryVal(de),NULL);\n    dictReleaseIterator(it);\n    dictRelease(ac->sub.channels);\n\n    it = dictGetIterator(ac->sub.patterns);\n    while ((de = dictNext(it)) != NULL)\n        __redisRunCallback(ac,dictGetEntryVal(de),NULL);\n    dictReleaseIterator(it);\n    dictRelease(ac->sub.patterns);\n\n    /* Signal event lib to clean up */\n    _EL_CLEANUP(ac);\n\n    /* Execute disconnect callback. When redisAsyncFree() initiated destroying\n     * this context, the status will always be REDIS_OK. */\n    if (ac->onDisconnect && (c->flags & REDIS_CONNECTED)) {\n        if (c->flags & REDIS_FREEING) {\n            ac->onDisconnect(ac,REDIS_OK);\n        } else {\n            ac->onDisconnect(ac,(ac->err == 0) ? REDIS_OK : REDIS_ERR);\n        }\n    }\n\n    /* Cleanup self */\n    redisFree(c);\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* Internal helper function to detect socket status the first time a read or\n * write event fires. When connecting was not successful, the connect callback\n * is called with a REDIS_ERR status and the context is free'd. */\n", "func_signal": "static int __redisAsyncHandleConnect(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n\n    if (redisCheckSocketError(c) == REDIS_ERR) {\n        /* Try again later when connect(2) is still in progress. */\n        if (errno == EINPROGRESS)\n            return REDIS_OK;\n\n        if (ac->onConnect) ac->onConnect(ac,REDIS_ERR);\n        __redisAsyncDisconnect(ac);\n        return REDIS_ERR;\n    }\n\n    /* Mark context as connected. */\n    c->flags |= REDIS_CONNECTED;\n    if (ac->onConnect) ac->onConnect(ac,REDIS_OK);\n    return REDIS_OK;\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/*\nstatic ngx_int_t rbtree_validate_nodes_reachable(rbtree_seed_t *seed) {\n  ngx_int_t    i, max;\n  ngx_rbtree_node_t *cur, *match;\n  max = sizeof(seed->actives)/sizeof(cur);\n  \n  for(i=0; i<max; i++){\n    cur = seed->actives[i];\n    if(cur != NULL) {\n      match = rbtree_find_node(seed, seed->id(rbtree_data_from_node(cur)));\n      assert(match == cur);\n    }\n  }\n  return 1;\n}\n*/\n", "func_signal": "static ngx_rbtree_node_t * rbtree_find_node_generic(rbtree_seed_t *seed, void *id, uint32_t hash, ngx_rbtree_node_t **last_parent, ngx_int_t *last_compare)", "code": "{\n  ngx_rbtree_node_t              *root = seed->tree.root;\n  ngx_rbtree_node_t              *node = root;\n  ngx_rbtree_node_t              *sentinel = seed->tree.sentinel;\n  ngx_int_t                       rc;\n\n  while (node != sentinel) {\n    if (hash < node->key) {\n      node = node->left;\n      continue;\n    }\n    if (hash > node->key) {\n      node = node->right;\n      continue;\n    }\n\n    /* hash == node->key */\n    rc = seed->compare(id, seed->id(rbtree_data_from_node(node)));\n    if (rc == 0) {\n      return node;\n    }\n    node = (rc < 0) ? node->left : node->right;\n  }\n  /* not found */\n\n  return NULL;\n}", "path": "nchan/src/util/nchan_rbtree.c", "commit_date": "2016-08-27 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* Helper function for the redisAsyncCommand* family of functions. Writes a\n * formatted command to the output buffer and registers the provided callback\n * function with the context. */\n", "func_signal": "static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len)", "code": "{\n    redisContext *c = &(ac->c);\n    redisCallback cb;\n    int pvariant, hasnext;\n    const char *cstr, *astr;\n    size_t clen, alen;\n    const char *p;\n    sds sname;\n    int ret;\n\n    /* Don't accept new commands when the connection is about to be closed. */\n    if (c->flags & (REDIS_DISCONNECTING | REDIS_FREEING)) return REDIS_ERR;\n\n    /* Setup callback */\n    cb.fn = fn;\n    cb.privdata = privdata;\n\n    /* Find out which command will be appended. */\n    p = nextArgument(cmd,&cstr,&clen);\n    assert(p != NULL);\n    hasnext = (p[0] == '$');\n    pvariant = (tolower(cstr[0]) == 'p') ? 1 : 0;\n    cstr += pvariant;\n    clen -= pvariant;\n\n    if (hasnext && strncasecmp(cstr,\"subscribe\\r\\n\",11) == 0) {\n        c->flags |= REDIS_SUBSCRIBED;\n\n        /* Add every channel/pattern to the list of subscription callbacks. */\n        while ((p = nextArgument(p,&astr,&alen)) != NULL) {\n            sname = sdsnewlen(astr,alen);\n            if (pvariant)\n                ret = dictReplace(ac->sub.patterns,sname,&cb);\n            else\n                ret = dictReplace(ac->sub.channels,sname,&cb);\n\n            if (ret == 0) sdsfree(sname);\n        }\n    } else if (strncasecmp(cstr,\"unsubscribe\\r\\n\",13) == 0) {\n        /* It is only useful to call (P)UNSUBSCRIBE when the context is\n         * subscribed to one or more channels or patterns. */\n        if (!(c->flags & REDIS_SUBSCRIBED)) return REDIS_ERR;\n\n        /* (P)UNSUBSCRIBE does not have its own response: every channel or\n         * pattern that is unsubscribed will receive a message. This means we\n         * should not append a callback function for this command. */\n     } else if(strncasecmp(cstr,\"monitor\\r\\n\",9) == 0) {\n         /* Set monitor flag and push callback */\n         c->flags |= REDIS_MONITORING;\n         __redisPushCallback(&ac->replies,&cb);\n    } else {\n        if (c->flags & REDIS_SUBSCRIBED)\n            /* This will likely result in an error reply, but it needs to be\n             * received and passed to the callback. */\n            __redisPushCallback(&ac->sub.invalid,&cb);\n        else\n            __redisPushCallback(&ac->replies,&cb);\n    }\n\n    __redisAppendCommand(c,cmd,len);\n\n    /* Always schedule a write when the write buffer is non-empty */\n    _EL_ADD_WRITE(ac);\n\n    return REDIS_OK;\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/* This function should be called when the socket is readable.\n * It processes all replies that can be read and executes their callbacks.\n */\n", "func_signal": "void redisAsyncHandleRead(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n\n    if (!(c->flags & REDIS_CONNECTED)) {\n        /* Abort connect was not successful. */\n        if (__redisAsyncHandleConnect(ac) != REDIS_OK)\n            return;\n        /* Try again later when the context is still not connected. */\n        if (!(c->flags & REDIS_CONNECTED))\n            return;\n    }\n\n    if (redisBufferRead(c) == REDIS_ERR) {\n        __redisAsyncDisconnect(ac);\n    } else {\n        /* Always re-schedule reads */\n        _EL_ADD_READ(ac);\n        redisProcessCallbacks(ac);\n    }\n}", "path": "nchan/src/store/redis/hiredis/async.c", "commit_date": "2019-01-24 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "////////// PUBLISH_NOTICE ////////////////\n", "func_signal": "ngx_int_t memstore_ipc_send_publish_notice(ngx_int_t dst, ngx_str_t *chid, ngx_int_t notice_code, void *notice_data)", "code": "{\n  DBG(\"IPC: send publish notice to %i ch %V\", dst, chid);\n  publish_code_data_t  data = {str_shm_copy(chid), notice_code, notice_data, NULL, NULL};\n  if(data.shm_chid == NULL) {\n    nchan_log_ooshm_error(\"sending IPC notice alert for channel %V\", chid);\n    return NGX_DECLINED;\n  }\n  return ipc_cmd(publish_notice, dst, &data);\n}", "path": "nchan/src/store/memory/ipc-handlers.c", "commit_date": "2018-10-06 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "//shared memory\n", "func_signal": "shmem_t *shm_create(ngx_str_t *name, ngx_conf_t *cf, size_t shm_size, ngx_int_t (*init)(ngx_shm_zone_t *, void *), void *privdata)", "code": "{\n\n  ngx_shm_zone_t    *zone;\n  shmem_t           *shm;\n\n  shm_size = ngx_align(shm_size, ngx_pagesize);\n  if (shm_size < 8 * ngx_pagesize) {\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0, \"The push_max_reserved_memory value must be at least %udKiB\", (8 * ngx_pagesize) >> 10);\n    shm_size = 8 * ngx_pagesize;\n  }\n  /*\n  if(nchan_shm_zone && nchan_shm_zone->shm.size != shm_size) {\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0, \"Cannot change memory area size without restart, ignoring change\");\n  }\n  */\n  ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"Using %udKiB of shared memory for nchan\", shm_size >> 10);\n\n  shm = ngx_alloc(sizeof(*shm), ngx_cycle->log);\n  zone = ngx_shared_memory_add(cf, name, shm_size, &ngx_nchan_module);\n  if (zone == NULL || shm == NULL) {\n    return NULL;\n  }\n  shm->zone = zone;\n\n  zone->init = init;\n  zone->data = (void *) 1;\n  return shm;\n}", "path": "nchan/src/util/shmem.c", "commit_date": "2017-10-23 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "/*\nstatic void validate_stuff(nchan_bufchain_pool_t *bcp) {\n  nchan_bufchain_link_t      *cur;\n  nchan_file_link_t          *fcur;\n  int                         bcs=0, rbcs = 0, files=0, rfiles = 0;\n  for(cur = bcp->bc_head; cur != NULL; cur = cur->next) {\n    bcs++;\n  }\n  assert(bcs == bcp->bc_count);\n  for(cur = bcp->bc_recycle_head; cur != NULL; cur = cur->next) {\n    rbcs++;\n  }\n  assert(rbcs == bcp->bc_recycle_count);\n  for(fcur = bcp->file_head; fcur != NULL; fcur = fcur->next) {\n    files++;\n  }\n  assert(files == bcp->file_count);\n  for(fcur = bcp->file_recycle_head; fcur != NULL; fcur = fcur->next) {\n    rfiles++;\n  }\n  assert(rfiles == bcp->file_recycle_count);\n}\n*/\n", "func_signal": "nchan_buf_and_chain_t *nchan_bufchain_pool_reserve(nchan_bufchain_pool_t *bcp, ngx_int_t count)", "code": "{\n  nchan_bufchain_link_t      *cur = NULL, *last = NULL, *first = NULL;\n  nchan_bufchain_link_t      **rhead = &bcp->bc_recycle_head;\n  //validate_stuff(bcp);\n  if(count <= 0) {\n    return NULL;\n  }\n  while(count > 0) {\n    if(*rhead) {\n      cur = *rhead;\n      *rhead = cur->next;\n      bcp->bc_recycle_count --;\n    } else {\n      cur = ngx_palloc(bcp->pool, sizeof(*cur));\n      cur->bc.chain.buf = &cur->bc.buf;\n    }\n    if(!first) {\n      first = cur;\n    }\n    if(last) {\n      last->next = cur;\n      last->bc.chain.next = &cur->bc.chain;\n    }\n    last = cur;\n    count --;\n    bcp->bc_count++;\n  }\n  last->next = bcp->bc_head;\n  last->bc.chain.next=NULL;\n  bcp->bc_head = first;\n  DBG(\"%p bcs %i (rec. %i), files %i (rec. %i)\", bcp, bcp->bc_count, bcp->bc_recycle_count, bcp->file_count, bcp->file_recycle_count);\n  //validate_stuff(bcp);\n  return &first->bc;\n}", "path": "nchan/src/util/nchan_bufchainpool.c", "commit_date": "2018-08-15 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "//copypasta because these should only be used for debugging\n", "func_signal": "void *shm_locked_alloc(shmem_t *shm, size_t size, const char *label)", "code": "{\n  void         *p;\n#if (FAKESHARD || FAKE_SHMEM)\n  p = ngx_alloc(size, ngx_cycle->log);\n#else\n  #if nginx_version <= 1011006\n  p = nchan_slab_alloc_locked(SHPOOL(shm), size);\n  #else \n  p = ngx_slab_alloc_locked(SHPOOL(shm), size);\n  #endif\n#endif\n  if(p == NULL) {\n    ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, \"shpool alloc failed\");\n  }\n\n  #if (DEBUG_SHM_ALLOC == 1)\n  if (p != NULL) {\n    ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, \"shpool alloc addr %p size %ui label %s\", p, size, label == NULL ? \"none\" : label);\n  }\n  #endif\n  return p;\n}", "path": "nchan/src/util/shmem.c", "commit_date": "2017-10-23 00:00:00", "repo_name": "slact/nchan", "stars": 2972, "license": "other", "language": "c", "size": 8019}
{"docstring": "// emit OR16 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_or16(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4, int save_s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s3, d_or16);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s3);\n    }\n    IFX(X_ALL) {\n        ORRS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        ORR_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 15);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        if(save_s4) {PUSH(xSP, 1<<s4);}\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n        if(save_s4) {POP(xSP, 1<<s4);}\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit XOR32 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_xor32c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOV32(s3, c);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_xor32);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    if(c>=0 && c<256) {\n        IFX(X_ALL) {\n            XORS_IMM8(s1, s1, c);\n        } else {\n            XOR_IMM8(s1, s1, c);\n        }\n    } else {\n        IFX(X_PEND) {} else {MOV32(s3, c);}\n        IFX(X_ALL) {\n            XORS_REG_LSL_IMM5(s1, s1, s3, 0);\n        } else {\n            XOR_REG_LSL_IMM5(s1, s1, s3, 0);\n        }\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 31);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit AND8 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_and8(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4, int save_s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s3, d_and8);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s3);\n    }\n    IFX(X_ALL) {\n        ANDS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        AND_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 7);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        if(save_s4) {PUSH(xSP, 1<<s4);}\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n        if(save_s4) {POP(xSP, 1<<s4);}\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit XOR16 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_xor16(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4, int save_s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s3, d_xor16);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s3);\n    }\n    IFX(X_ALL) {\n        XORS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        XOR_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 15);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        if(save_s4) {PUSH(xSP, 1<<s4);}\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n        if(save_s4) {POP(xSP, 1<<s4);}\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit XOR8 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_xor8c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOV32(s3, c&0xff);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_xor8);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    IFX(X_ALL) {\n        XORS_IMM8(s1, s1, c);\n    } else {\n        XOR_IMM8(s1, s1, c);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 7);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit XOR8 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_xor8(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4, int save_s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s3, d_xor8);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s3);\n    }\n    IFX(X_ALL) {\n        XORS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        XOR_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 7);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        if(save_s4) {PUSH(xSP, 1<<s4);}\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n        if(save_s4) {POP(xSP, 1<<s4);}\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit OR16 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_or16c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOVW(s3, c);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_or16);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    if(c>=0 && c<256) {\n        IFX(X_ALL) {\n            ORRS_IMM8(s1, s1, c, 0);\n        } else {\n            ORR_IMM8(s1, s1, c, 0);\n        }\n    } else {\n        IFX(X_PEND) {} else {MOVW(s3, c);}\n        IFX(X_ALL) {\n            ORRS_REG_LSL_IMM5(s1, s1, s3, 0);\n        } else {\n            ORR_REG_LSL_IMM5(s1, s1, s3, 0);\n        }\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 15);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// SDL1 doesn't really used rw_ops->type, but box86 does, so set sensible value (from SDL2)....\n", "func_signal": "void EXPORT *my_SDL_RWFromConstMem(x86emu_t* emu, void* a, int b)", "code": "{\n    sdl1_my_t *my = (sdl1_my_t *)emu->context->sdl1lib->priv.w.p2;\n    SDL1_RWops_t* r = (SDL1_RWops_t*)my->SDL_RWFromConstMem(a, b);\n    RWSetType(r, 5);\n    return AddNativeRW(emu, r);\n}", "path": "box86/src/wrapped/wrappedsdl1.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit AND32 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_and32(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_and32);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    IFX(X_ALL) {\n        ANDS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        AND_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 31);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit OR8 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_or8(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4, int save_s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s3, d_or8);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s3);\n    }\n    IFX(X_ALL) {\n        ORRS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        ORR_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 7);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        if(save_s4) {PUSH(xSP, 1<<s4);}\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n        if(save_s4) {POP(xSP, 1<<s4);}\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit XOR32 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_xor32(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_xor32);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    IFX(X_ALL) {\n        XORS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        XOR_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 31);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit AND16 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_and16c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOVW(s3, c);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_and16);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    if(c>=0 && c<256) {\n        IFX(X_ALL) {\n            ANDS_IMM8(s1, s1, c);\n        } else {\n            AND_IMM8(s1, s1, c);\n        }\n    } else {\n        IFX(X_PEND) {} else {MOVW(s3, c);}\n        IFX(X_ALL) {\n            ANDS_REG_LSL_IMM5(s1, s1, s3, 0);\n        } else {\n            AND_REG_LSL_IMM5(s1, s1, s3, 0);\n        }\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 15);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit OR32 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_or32(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_or32);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    IFX(X_ALL) {\n        ORRS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        ORR_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 31);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// TODO: track the memory for those callback\n", "func_signal": "int EXPORT my_SDL_OpenAudio(x86emu_t* emu, void* d, void* o)", "code": "{\n    SDL_AudioSpec *desired = (SDL_AudioSpec*)d;\n    sdl1_my_t *my = (sdl1_my_t *)emu->context->sdl1lib->priv.w.p2;\n    // create a callback\n    void *fnc = (void*)desired->callback;\n    desired->callback = find_AudioCallback_Fct(desired->callback);\n    int ret = my->SDL_OpenAudio(desired, (SDL_AudioSpec*)o);\n    if (ret!=0) {\n        // error, clean the callback...\n        desired->callback = fnc;\n        return ret;\n    }\n    // put back stuff in place?\n    desired->callback = fnc;\n\n    return ret;\n}", "path": "box86/src/wrapped/wrappedsdl1.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit OR32 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_or32c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOV32(s3, c);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_or32);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    if(c>=0 && c<256) {\n        IFX(X_ALL) {\n            ORRS_IMM8(s1, s1, c, 0);\n        } else {\n            ORR_IMM8(s1, s1, c, 0);\n        }\n    } else {\n        IFX(X_PEND) {} else {MOV32(s3, c);}\n        IFX(X_ALL) {\n            ORRS_REG_LSL_IMM5(s1, s1, s3, 0);\n        } else {\n            ORR_REG_LSL_IMM5(s1, s1, s3, 0);\n        }\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 31);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit AND32 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_and32c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOV32(s3, c);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_and32);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    if(c>=0 && c<256) {\n        IFX(X_ALL) {\n            ANDS_IMM8(s1, s1, c);\n        } else {\n            AND_IMM8(s1, s1, c);\n        }\n    } else {\n        IFX(X_PEND) {} else {MOV32(s3, c);}\n        IFX(X_ALL) {\n            ANDS_REG_LSL_IMM5(s1, s1, s3, 0);\n        } else {\n            AND_REG_LSL_IMM5(s1, s1, s3, 0);\n        }\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 31);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit XOR16 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_xor16c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOVW(s3, c);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_xor16);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    if(c>=0 && c<256) {\n        IFX(X_ALL) {\n            XORS_IMM8(s1, s1, c);\n        } else {\n            XOR_IMM8(s1, s1, c);\n        }\n    } else {\n        IFX(X_PEND) {} else {MOVW(s3, c);}\n        IFX(X_ALL) {\n            XORS_REG_LSL_IMM5(s1, s1, s3, 0);\n        } else {\n            XOR_REG_LSL_IMM5(s1, s1, s3, 0);\n        }\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 15);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit OR8 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_or8c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOV32(s3, c&0xff);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_or8);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    IFX(X_ALL) {\n        ORRS_IMM8(s1, s1, c, 0);\n    } else {\n        ORR_IMM8(s1, s1, c, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 7);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit AND8 instruction, from s1 , constant c, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_and8c(dynarec_arm_t* dyn, int ninst, int s1, int32_t c, int s3, int s4)", "code": "{\n    IFX(X_PEND) {\n        MOV32(s3, c&0xff);\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s3, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s4, d_and8);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s4);\n    }\n    IFX(X_ALL) {\n        ANDS_IMM8(s1, s1, c);\n    } else {\n        AND_IMM8(s1, s1, c);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 7);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "// emit AND16 instruction, from s1 , s2, store result in s1 using s3 and s4 as scratch\n", "func_signal": "void emit_and16(dynarec_arm_t* dyn, int ninst, int s1, int s2, int s3, int s4, int save_s4)", "code": "{\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, op1));\n        STR_IMM9(s2, xEmu, offsetof(x86emu_t, op2));\n        SET_DF(s3, d_and16);\n    } else IFX(X_ALL) {\n        SET_DFNONE(s3);\n    }\n    IFX(X_ALL) {\n        ANDS_REG_LSL_IMM5(s1, s1, s2, 0);\n    } else {\n        AND_REG_LSL_IMM5(s1, s1, s2, 0);\n    }\n    IFX(X_PEND) {\n        STR_IMM9(s1, xEmu, offsetof(x86emu_t, res));\n    }\n    IFX(X_CF | X_AF) {\n        BIC_IMM8(xFlags, xFlags, (1<<F_CF)|(1<<F_AF), 0);\n    }\n    IFX(X_OF) {\n        BIC_IMM8(xFlags, xFlags, 0b10, 0x0b);\n    }\n    IFX(X_ZF) {\n        ORR_IMM8_COND(cEQ, xFlags, xFlags, 1<<F_ZF, 0);\n        BIC_IMM8_COND(cNE, xFlags, xFlags, 1<<F_ZF, 0);\n    }\n    IFX(X_SF) {\n        MOV_REG_LSR_IMM5(s3, s1, 15);\n        BFI(xFlags, s3, F_SF, 1);\n    }\n    IFX(X_PF) {\n        if(save_s4) {PUSH(xSP, 1<<s4);}\n        // PF: (((emu->x86emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)\n        AND_IMM8(s3, s1, 0xE0); // lsr 5 masking pre-applied\n        LDR_IMM9(s4, xEmu, offsetof(x86emu_t, x86emu_parity_tab));\n        LDR_REG_LSR_IMM5(s4, s4, s3, 5-2);   // x/32 and then *4 because array is integer\n        AND_IMM8(s3, s1, 31);\n        MVN_REG_LSR_REG(s4, s4, s3);\n        BFI(xFlags, s4, F_PF, 1);\n        if(save_s4) {POP(xSP, 1<<s4);}\n    }\n}", "path": "box86/src/dynarec/dynarec_arm_emit_logic.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ptitSeb/box86", "stars": 3012, "license": "mit", "language": "c", "size": 16771}
{"docstring": "/*\n * Set row format\n */\n", "func_signal": "void set_row(zend_string *range, double height, xls_resource_write_t *res, lxw_format *format)", "code": "{\n    char *rows = ZSTR_VAL(range);\n\n    if (strchr(rows, ':')) {\n        worksheet_set_rows(ROWS(rows), height, res, format);\n    } else {\n        int error = worksheet_set_row(res->worksheet, ROW(rows), height, format);\n\n        // Cells that have been placed cannot be modified using optimization mode\n        WORKSHEET_INDEX_OUT_OF_CHANGE_IN_OPTIMIZE_EXCEPTION(res, error)\n\n        // Worksheet row or column index out of range\n        WORKSHEET_INDEX_OUT_OF_CHANGE_EXCEPTION(error)\n    }\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Write the comment to the cell\n */\n", "func_signal": "void comment_writer(zend_string *comment, zend_long row, zend_long columns, xls_resource_write_t *res)", "code": "{\n    int error = worksheet_write_comment(res->worksheet, (lxw_row_t)row, (lxw_col_t)columns, ZSTR_VAL(comment));\n\n    WORKSHEET_WRITER_EXCEPTION(error);\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "//output start of row\n", "func_signal": "void write_row_start (xlsxiowriter handle, const char* rowattr)", "code": "{\n#ifndef NO_ROW_NUMBERS\n  handle->rownr++;\n#ifndef NO_COLUMN_NUMBERS\n  handle->colnr = 0;\n#endif\n#endif\n  if (handle->sheetopen) {\n    if (!handle->rowheight)\n      fprintf(handle->pipe_write, \"<row%s\" ROWNRTAG \">\", (rowattr ? rowattr : \"\") ROWNRPARAM(handle));\n    else\n      fprintf(handle->pipe_write, \"<row ht=\\\"%.6G\\\" customHeight=\\\"1\\\"%s\" ROWNRTAG \">\", CALCULATE_COLUMN_HEIGHT(handle->rowheight), (rowattr ? rowattr : \"\") ROWNRPARAM(handle));\n  } else {\n    if (!handle->rowheight)\n      append_data(&handle->buf, &handle->buflen, \"<row%s\" ROWNRTAG \">\", (rowattr ? rowattr : \"\") ROWNRPARAM(handle));\n    else\n      append_data(&handle->buf, &handle->buflen, \"<row ht=\\\"%.6G\\\" customHeight=\\\"1\\\"%s\" ROWNRTAG \">\",  CALCULATE_COLUMN_HEIGHT(handle->rowheight), (rowattr ? rowattr : \"\") ROWNRPARAM(handle));\n  }\n  handle->rowopen = 1;\n}", "path": "php-ext-xlswriter/library/libxlsxio/lib/xlsxio_write.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "//insert formatted data into a null-terminated buffer at the specified position and update the length counter\n", "func_signal": "int insert_data (char** pdata, size_t* pdatalen, size_t pos, const char* format, ...)", "code": "{\n  int len;\n  va_list args;\n  va_start(args, format);\n  len = vsnprintf(NULL, 0, format, args);\n  va_end(args);\n  if (len < 0)\n    return -1;\n  if ((*pdata = (char*)realloc(*pdata, *pdatalen + len + 1)) == NULL)\n    return -1;\n  if (pos > *pdatalen)\n    pos = *pdatalen;\n  if (pos < *pdatalen)\n    memmove(*pdata + pos + len, *pdata + pos, *pdatalen - pos + 1);\n  else\n    (*pdata)[pos + len] = 0;\n  va_start(args, format);\n  len = vsnprintf(*pdata + pos, len, format, args);\n  va_end(args);\n  *pdatalen += len;\n  return len;\n}", "path": "php-ext-xlswriter/library/libxlsxio/lib/xlsxio_write.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "//replace part of a string\n", "func_signal": "char* str_replace (char** s, size_t pos, size_t len, char* replacement)", "code": "{\n  if (!s || !*s)\n    return NULL;\n  size_t totallen = strlen(*s);\n  size_t replacementlen = strlen(replacement);\n  if (pos > totallen)\n    pos = totallen;\n  if (pos + len > totallen)\n    len = totallen - pos;\n  if (replacementlen > len)\n    if ((*s = (char*)realloc(*s, totallen - len + replacementlen + 1)) == NULL)\n      return NULL;\n  memmove(*s + pos + replacementlen, *s + pos + len, totallen - pos - len + 1);\n  memcpy(*s + pos, replacement, replacementlen);\n  return *s;\n}", "path": "php-ext-xlswriter/library/libxlsxio/lib/xlsxio_write.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "//add formatted data to a null-terminated buffer and update the length counter\n", "func_signal": "int append_data (char** pdata, size_t* pdatalen, const char* format, ...)", "code": "{\n  int len;\n  va_list args;\n  va_start(args, format);\n  len = vsnprintf(NULL, 0, format, args);\n  va_end(args);\n  if (len < 0)\n    return -1;\n  if ((*pdata = (char*)realloc(*pdata, *pdatalen + len + 1)) == NULL)\n    return -1;\n  va_start(args, format);\n  vsnprintf(*pdata + *pdatalen, len + 1, format, args);\n  va_end(args);\n  *pdatalen += len;\n  return len;\n}", "path": "php-ext-xlswriter/library/libxlsxio/lib/xlsxio_write.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Set the worksheet protection\n */\n", "func_signal": "void protection(xls_resource_write_t *res, zend_string *password)", "code": "{\n    if (password == NULL) {\n        worksheet_protect(res->worksheet, NULL, NULL);\n    } else {\n        worksheet_protect(res->worksheet, ZSTR_VAL(password), NULL);\n    }\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "//add formatted data to a null-terminated buffer and update the length counter\n", "func_signal": "int append_data (char** pdata, size_t* pdatalen, const char* format, ...)", "code": "{\n  int result;\n  va_list args;\n  va_start(args, format);\n  result = vappend_data(pdata, pdatalen, format, args);\n  va_end(args);\n  return result;\n}", "path": "php-ext-xlswriter/library/libxlsxio/lib/xlsxio_write.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * According to the zval type written to the file\n */\n", "func_signal": "void type_writer(zval *value, zend_long row, zend_long columns, xls_resource_write_t *res, zend_string *format, lxw_format *format_handle)", "code": "{\n    lxw_format *value_format = NULL;\n\n    lxw_col_t lxw_col = (lxw_col_t)columns;\n    lxw_row_t lxw_row = (lxw_row_t)row;\n\n    zend_uchar value_type = Z_TYPE_P(value);\n\n    if (value_type == IS_STRING) {\n        zend_string *_zs_value = zval_get_string(value);\n\n        int error = worksheet_write_string(res->worksheet, lxw_row, lxw_col, ZSTR_VAL(_zs_value), format_handle);\n\n        zend_string_release(_zs_value);\n        WORKSHEET_WRITER_EXCEPTION(error);\n        return;\n    }\n\n    if (value_type == IS_LONG) {\n        if (format != NULL && format_handle == NULL) {\n            value_format = workbook_add_format(res->workbook);\n\n            format_set_num_format(value_format, ZSTR_VAL(format));\n            WORKSHEET_WRITER_EXCEPTION(worksheet_write_number(res->worksheet, lxw_row, lxw_col, (double)zval_get_long(value), value_format));\n            return;\n        }\n\n        if (format == NULL && format_handle != NULL) {\n            WORKSHEET_WRITER_EXCEPTION(worksheet_write_number(res->worksheet, lxw_row, lxw_col, (double)zval_get_long(value), format_handle));\n            return;\n        }\n\n        if(format != NULL && format_handle != NULL) {\n            value_format = workbook_add_format(res->workbook);\n\n            format_copy(value_format, format_handle);\n            format_set_num_format(value_format, ZSTR_VAL(format));\n\n            WORKSHEET_WRITER_EXCEPTION(worksheet_write_number(res->worksheet, lxw_row, lxw_col, (double)zval_get_long(value), value_format));\n            return;\n        }\n\n        WORKSHEET_WRITER_EXCEPTION(worksheet_write_number(res->worksheet, lxw_row, lxw_col, (double)zval_get_long(value), NULL));\n    }\n\n    if (value_type == IS_DOUBLE) {\n        if (format != NULL && format_handle == NULL) {\n            value_format = workbook_add_format(res->workbook);\n            format_set_num_format(value_format, ZSTR_VAL(format));\n\n            WORKSHEET_WRITER_EXCEPTION(worksheet_write_number(res->worksheet, lxw_row, lxw_col, zval_get_double(value), value_format));\n            return;\n        }\n\n        if (format == NULL && format_handle != NULL) {\n            WORKSHEET_WRITER_EXCEPTION(worksheet_write_number(res->worksheet, lxw_row, lxw_col, zval_get_double(value), format_handle));\n            return;\n        }\n\n        if(format != NULL && format_handle != NULL) {\n            value_format = workbook_add_format(res->workbook);\n\n            format_copy(value_format, format_handle);\n            format_set_num_format(value_format, ZSTR_VAL(format));\n\n            WORKSHEET_WRITER_EXCEPTION(worksheet_write_number(res->worksheet, lxw_row, lxw_col, zval_get_double(value), value_format));\n            return;\n        }\n\n        WORKSHEET_WRITER_EXCEPTION(worksheet_write_number(res->worksheet, (lxw_row_t)row, (lxw_col_t)columns, zval_get_double(value), NULL));\n        return;\n    }\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/* Convert a chart range such as Sheet1!$A$1:$A$5 to a sheet name and row-col\n * dimensions, or vice-versa. This gives us the dimensions to read data back\n * from the worksheet.\n */\n", "func_signal": "STATIC void\n_populate_range_dimensions(lxw_workbook *self, lxw_series_range *range)", "code": "{\n\n    char formula[LXW_MAX_FORMULA_RANGE_LENGTH] = { 0 };\n    char *tmp_str;\n    char *sheetname;\n\n    /* If neither the range formula or sheetname is defined then this probably\n     * isn't a valid range.\n     */\n    if (!range->formula && !range->sheetname) {\n        range->ignore_cache = LXW_TRUE;\n        return;\n    }\n\n    /* If the sheetname is already defined it was already set via\n     * chart_series_set_categories() or  chart_series_set_values().\n     */\n    if (range->sheetname)\n        return;\n\n    /* Ignore non-contiguous range like (Sheet1!$A$1:$A$2,Sheet1!$A$4:$A$5) */\n    if (range->formula[0] == '(') {\n        range->ignore_cache = LXW_TRUE;\n        return;\n    }\n\n    /* Create a copy of the formula to modify and parse into parts. */\n    lxw_snprintf(formula, LXW_MAX_FORMULA_RANGE_LENGTH, \"%s\", range->formula);\n\n    /* Check for valid formula. TODO. This needs stronger validation. */\n    tmp_str = strchr(formula, '!');\n\n    if (tmp_str == NULL) {\n        range->ignore_cache = LXW_TRUE;\n        return;\n    }\n    else {\n        /* Split the formulas into sheetname and row-col data. */\n        *tmp_str = '\\0';\n        tmp_str++;\n        sheetname = formula;\n\n        /* Remove any worksheet quoting. */\n        if (sheetname[0] == '\\'')\n            sheetname++;\n        if (sheetname[strlen(sheetname) - 1] == '\\'')\n            sheetname[strlen(sheetname) - 1] = '\\0';\n\n        /* Check that the sheetname exists. */\n        if (!workbook_get_worksheet_by_name(self, sheetname)) {\n            LXW_WARN_FORMAT2(\"workbook_add_chart(): worksheet name '%s' \"\n                                     \"in chart formula '%s' doesn't exist.\",\n                             sheetname, range->formula);\n            range->ignore_cache = LXW_TRUE;\n            return;\n        }\n\n        range->sheetname = lxw_strdup(sheetname);\n        range->first_row = lxw_name_to_row(tmp_str);\n        range->first_col = lxw_name_to_col(tmp_str);\n\n        if (strchr(tmp_str, ':')) {\n            /* 2D range. */\n            range->last_row = lxw_name_to_row_2(tmp_str);\n            range->last_col = lxw_name_to_col_2(tmp_str);\n        }\n        else {\n            /* 1D range. */\n            range->last_row = range->first_row;\n            range->last_col = range->first_col;\n        }\n\n    }\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Write the image to the file\n */\n", "func_signal": "void image_writer(zval *value, zend_long row, zend_long columns, double width, double height, xls_resource_write_t *res)", "code": "{\n    lxw_image_options options = {.x_scale = width, .y_scale = height};\n\n    worksheet_insert_image_opt(res->worksheet, (lxw_row_t)row, (lxw_col_t)columns, ZSTR_VAL(zval_get_string(value)), &options);\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Populate the data cache of a chart data series by reading the data from the\n * relevant worksheet and adding it to the cached in the range object as a\n * list of points.\n *\n * Note, the data cache isn't strictly required by Excel but it helps if the\n * chart is embedded in another application such as PowerPoint and it also\n * helps with comparison testing.\n */\n", "func_signal": "STATIC void\n_populate_range_data_cache(lxw_workbook *self, lxw_series_range *range)", "code": "{\n    lxw_worksheet *worksheet;\n    lxw_row_t row_num;\n    lxw_col_t col_num;\n    lxw_row *row_obj;\n    lxw_cell *cell_obj;\n    struct lxw_series_data_point *data_point;\n    uint16_t num_data_points = 0;\n\n    /* If ignore_cache is set then don't try to populate the cache. This flag\n     * may be set manually, for testing, or due to a case where the cache\n     * can't be calculated.\n     */\n    if (range->ignore_cache)\n        return;\n\n    /* Currently we only handle 2D ranges so ensure either the rows or cols\n     * are the same.\n     */\n    if (range->first_row != range->last_row\n        && range->first_col != range->last_col) {\n        range->ignore_cache = LXW_TRUE;\n        return;\n    }\n\n    /* Check that the sheetname exists. */\n    worksheet = workbook_get_worksheet_by_name(self, range->sheetname);\n    if (!worksheet) {\n        LXW_WARN_FORMAT2(\"workbook_add_chart(): worksheet name '%s' \"\n                                 \"in chart formula '%s' doesn't exist.\",\n                         range->sheetname, range->formula);\n        range->ignore_cache = LXW_TRUE;\n        return;\n    }\n\n    /* We can't read the data when worksheet optimization is on. */\n    if (worksheet->optimize) {\n        range->ignore_cache = LXW_TRUE;\n        return;\n    }\n\n    /* Iterate through the worksheet data and populate the range cache. */\n    for (row_num = range->first_row; row_num <= range->last_row; row_num++) {\n        row_obj = lxw_worksheet_find_row(worksheet, row_num);\n\n        for (col_num = range->first_col; col_num <= range->last_col;\n             col_num++) {\n\n            data_point = calloc(1, sizeof(struct lxw_series_data_point));\n            if (!data_point) {\n                range->ignore_cache = LXW_TRUE;\n                return;\n            }\n\n#if defined(LXW_VERSION_ID) && LXW_VERSION_ID >= 93\n            cell_obj = lxw_worksheet_find_cell_in_row(row_obj, col_num);\n#else\n            cell_obj = lxw_worksheet_find_cell(row_obj, col_num);\n#endif\n\n            if (cell_obj) {\n                if (cell_obj->type == NUMBER_CELL) {\n                    data_point->number = cell_obj->u.number;\n                }\n\n                if (cell_obj->type == STRING_CELL) {\n                    data_point->string = lxw_strdup(cell_obj->sst_string);\n                    data_point->is_string = LXW_TRUE;\n                    range->has_string_cache = LXW_TRUE;\n                }\n            }\n            else {\n                data_point->no_data = LXW_TRUE;\n            }\n\n            STAILQ_INSERT_TAIL(range->data_cache, data_point, list_pointers);\n            num_data_points++;\n        }\n    }\n\n    range->num_data_points = num_data_points;\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "//fix string for use as XML data\n", "func_signal": "char* fix_xml_special_chars (char** s)", "code": "{\n\tint pos = 0;\n\twhile (*s && (*s)[pos]) {\n\t\tswitch ((*s)[pos]) {\n\t\t\tcase '&' :\n\t\t\t\tstr_replace(s, pos, 1, \"&amp;\");\n\t\t\t\tpos += 5;\n\t\t\t\tbreak;\n\t\t\tcase '\\\"' :\n\t\t\t\tstr_replace(s, pos, 1, \"&quot;\");\n\t\t\t\tpos += 6;\n\t\t\t\tbreak;\n\t\t\tcase '\\'' :\n\t\t\t\tstr_replace(s, pos, 1, \"&apos;\");\n\t\t\t\tpos += 6;\n\t\t\t\tbreak;\n\t\t\tcase '<' :\n\t\t\t\tstr_replace(s, pos, 1, \"&lt;\");\n\t\t\t\tpos += 4;\n\t\t\t\tbreak;\n\t\t\tcase '>' :\n\t\t\t\tstr_replace(s, pos, 1, \"&gt;\");\n\t\t\t\tpos += 4;\n\t\t\t\tbreak;\n\t\t\tcase '\\r' :\n\t\t\t\tstr_replace(s, pos, 1, \"\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn *s;\n}", "path": "php-ext-xlswriter/library/libxlsxio/lib/xlsxio_write.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/* Set the range dimensions and set the data cache.\n */\n", "func_signal": "STATIC void\n_populate_range(lxw_workbook *self, lxw_series_range *range)", "code": "{\n    _populate_range_dimensions(self, range);\n    _populate_range_data_cache(self, range);\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Write the datetime to the file\n */\n", "func_signal": "void datetime_writer(lxw_datetime *datetime, zend_long row, zend_long columns, zend_string *format, xls_resource_write_t *res, lxw_format *format_handle)", "code": "{\n    lxw_format *value_format = NULL;\n\n    if (format_handle != NULL) {\n        format_copy(value_format, format_handle);\n    }\n\n    value_format = workbook_add_format(res->workbook);\n    format_set_num_format(value_format, ZSTR_VAL(format));\n    worksheet_write_datetime(res->worksheet, (lxw_row_t)row, (lxw_col_t)columns, datetime, value_format);\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Iterate through the worksheets and store any defined names used for print\n * ranges or repeat rows/columns.\n */\n", "func_signal": "STATIC void\n_prepare_defined_names(lxw_workbook *self)", "code": "{\n    lxw_worksheet *worksheet;\n    char app_name[LXW_DEFINED_NAME_LENGTH];\n    char range[LXW_DEFINED_NAME_LENGTH];\n    char area[LXW_MAX_CELL_RANGE_LENGTH];\n    char first_col[8];\n    char last_col[8];\n\n    STAILQ_FOREACH(worksheet, self->worksheets, list_pointers) {\n\n        /*\n         * Check for autofilter settings and store them.\n         */\n        if (worksheet->autofilter.in_use) {\n\n            lxw_snprintf(app_name, LXW_DEFINED_NAME_LENGTH,\n                         \"%s!_FilterDatabase\", worksheet->quoted_name);\n\n            lxw_rowcol_to_range_abs(area,\n                                    worksheet->autofilter.first_row,\n                                    worksheet->autofilter.first_col,\n                                    worksheet->autofilter.last_row,\n                                    worksheet->autofilter.last_col);\n\n            lxw_snprintf(range, LXW_DEFINED_NAME_LENGTH, \"%s!%s\",\n                         worksheet->quoted_name, area);\n\n            /* Autofilters are the only defined name to set the hidden flag. */\n            _store_defined_name(self, \"_xlnm._FilterDatabase\", app_name, range, worksheet->index, LXW_TRUE);\n        }\n\n        /*\n         * Check for Print Area settings and store them.\n         */\n        if (worksheet->print_area.in_use) {\n\n            lxw_snprintf(app_name, LXW_DEFINED_NAME_LENGTH,\n                         \"%s!Print_Area\", worksheet->quoted_name);\n\n            /* Check for print area that is the max row range. */\n            if (worksheet->print_area.first_row == 0\n                && worksheet->print_area.last_row == LXW_ROW_MAX - 1) {\n\n                lxw_col_to_name(first_col,\n                                worksheet->print_area.first_col, LXW_FALSE);\n\n                lxw_col_to_name(last_col,\n                                worksheet->print_area.last_col, LXW_FALSE);\n\n                lxw_snprintf(area, LXW_MAX_CELL_RANGE_LENGTH - 1, \"$%s:$%s\",\n                             first_col, last_col);\n\n            }\n                /* Check for print area that is the max column range. */\n            else if (worksheet->print_area.first_col == 0\n                     && worksheet->print_area.last_col == LXW_COL_MAX - 1) {\n\n                lxw_snprintf(area, LXW_MAX_CELL_RANGE_LENGTH - 1, \"$%d:$%d\",\n                             worksheet->print_area.first_row + 1,\n                             worksheet->print_area.last_row + 1);\n\n            }\n            else {\n                lxw_rowcol_to_range_abs(area,\n                                        worksheet->print_area.first_row,\n                                        worksheet->print_area.first_col,\n                                        worksheet->print_area.last_row,\n                                        worksheet->print_area.last_col);\n            }\n\n            lxw_snprintf(range, LXW_DEFINED_NAME_LENGTH, \"%s!%s\",\n                         worksheet->quoted_name, area);\n\n            _store_defined_name(self, \"_xlnm.Print_Area\", app_name,\n                                range, worksheet->index, LXW_FALSE);\n        }\n\n        /*\n         * Check for repeat rows/cols. aka, Print Titles and store them.\n         */\n        if (worksheet->repeat_rows.in_use || worksheet->repeat_cols.in_use) {\n            if (worksheet->repeat_rows.in_use\n                && worksheet->repeat_cols.in_use) {\n                lxw_snprintf(app_name, LXW_DEFINED_NAME_LENGTH,\n                             \"%s!Print_Titles\", worksheet->quoted_name);\n\n                lxw_col_to_name(first_col,\n                                worksheet->repeat_cols.first_col, LXW_FALSE);\n\n                lxw_col_to_name(last_col,\n                                worksheet->repeat_cols.last_col, LXW_FALSE);\n\n                lxw_snprintf(range, LXW_DEFINED_NAME_LENGTH,\n                             \"%s!$%s:$%s,%s!$%d:$%d\",\n                             worksheet->quoted_name, first_col,\n                             last_col, worksheet->quoted_name,\n                             worksheet->repeat_rows.first_row + 1,\n                             worksheet->repeat_rows.last_row + 1);\n\n                _store_defined_name(self, \"_xlnm.Print_Titles\", app_name,\n                                    range, worksheet->index, LXW_FALSE);\n            }\n            else if (worksheet->repeat_rows.in_use) {\n\n                lxw_snprintf(app_name, LXW_DEFINED_NAME_LENGTH,\n                             \"%s!Print_Titles\", worksheet->quoted_name);\n\n                lxw_snprintf(range, LXW_DEFINED_NAME_LENGTH,\n                             \"%s!$%d:$%d\", worksheet->quoted_name,\n                             worksheet->repeat_rows.first_row + 1,\n                             worksheet->repeat_rows.last_row + 1);\n\n                _store_defined_name(self, \"_xlnm.Print_Titles\", app_name,\n                                    range, worksheet->index, LXW_FALSE);\n            }\n            else if (worksheet->repeat_cols.in_use) {\n                lxw_snprintf(app_name, LXW_DEFINED_NAME_LENGTH,\n                             \"%s!Print_Titles\", worksheet->quoted_name);\n\n                lxw_col_to_name(first_col,\n                                worksheet->repeat_cols.first_col, LXW_FALSE);\n\n                lxw_col_to_name(last_col,\n                                worksheet->repeat_cols.last_col, LXW_FALSE);\n\n                lxw_snprintf(range, LXW_DEFINED_NAME_LENGTH,\n                             \"%s!$%s:$%s\", worksheet->quoted_name,\n                             first_col, last_col);\n\n                _store_defined_name(self, \"_xlnm.Print_Titles\", app_name,\n                                    range, worksheet->index, LXW_FALSE);\n            }\n        }\n    }\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Merge cells.\n */\n", "func_signal": "void merge_cells(zend_string *range, zval *value, xls_resource_write_t *res, lxw_format *format)", "code": "{\n    char *_range = ZSTR_VAL(range);\n\n    int error = worksheet_merge_range(res->worksheet, RANGE(_range), \"\", format);\n\n    // Cells that have been placed cannot be modified using optimization mode\n    WORKSHEET_INDEX_OUT_OF_CHANGE_IN_OPTIMIZE_EXCEPTION(res, error)\n\n    // Worksheet row or column index out of range\n    WORKSHEET_INDEX_OUT_OF_CHANGE_EXCEPTION(error)\n\n    // writer merge cell\n    type_writer(value, lxw_name_to_row(_range), lxw_name_to_col(_range), res, NULL, format);\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Compare two defined_name structures.\n */\n", "func_signal": "static int\n_compare_defined_names(lxw_defined_name *a, lxw_defined_name *b)", "code": "{\n    int res = strcmp(a->normalised_name, b->normalised_name);\n\n    /* Primary comparison based on defined name. */\n    if (res)\n        return res;\n\n    /* Secondary comparison based on worksheet name. */\n    res = strcmp(a->normalised_sheetname, b->normalised_sheetname);\n\n    return res;\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Iterate through the worksheets and set up any chart or image drawings.\n */\n", "func_signal": "STATIC void\n_prepare_drawings(lxw_workbook *self)", "code": "{\n    lxw_worksheet *worksheet;\n    lxw_object_properties *image_options;\n    uint16_t chart_ref_id = 0;\n    uint16_t image_ref_id = 0;\n    uint16_t drawing_id = 0;\n\n    STAILQ_FOREACH(worksheet, self->worksheets, list_pointers) {\n\n        if (STAILQ_EMPTY(worksheet->image_props)\n            && STAILQ_EMPTY(worksheet->chart_data))\n            continue;\n\n        drawing_id++;\n\n        STAILQ_FOREACH(image_options, worksheet->chart_data, list_pointers) {\n            chart_ref_id++;\n            lxw_worksheet_prepare_chart(worksheet, chart_ref_id, drawing_id,\n                                        image_options, 0);\n            if (image_options->chart)\n                STAILQ_INSERT_TAIL(self->ordered_charts, image_options->chart,\n                                   ordered_list_pointers);\n        }\n\n        STAILQ_FOREACH(image_options, worksheet->image_props, list_pointers) {\n\n            if (image_options->image_type == LXW_IMAGE_PNG)\n                self->has_png = LXW_TRUE;\n\n            if (image_options->image_type == LXW_IMAGE_JPEG)\n                self->has_jpeg = LXW_TRUE;\n\n            if (image_options->image_type == LXW_IMAGE_BMP)\n                self->has_bmp = LXW_TRUE;\n\n            image_ref_id++;\n\n            lxw_worksheet_prepare_image(worksheet, image_ref_id, drawing_id,\n                                        image_options);\n        }\n    }\n\n    self->drawing_count = drawing_id;\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/*\n * Iterate through the worksheets and set up the VML objects.\n */\n", "func_signal": "STATIC void\n_prepare_vml(lxw_workbook *self)", "code": "{\n    lxw_worksheet *worksheet;\n    lxw_sheet *sheet;\n    uint32_t comment_id = 0;\n    uint32_t vml_drawing_id = 0;\n    uint32_t vml_data_id = 1;\n    uint32_t vml_shape_id = 1024;\n    uint32_t comment_count = 0;\n\n    STAILQ_FOREACH(sheet, self->sheets, list_pointers) {\n        if (sheet->is_chartsheet)\n            continue;\n        else\n            worksheet = sheet->u.worksheet;\n\n        if (!worksheet->has_vml && !worksheet->has_header_vml)\n            continue;\n\n        if (worksheet->has_vml) {\n            self->has_vml = LXW_TRUE;\n            if (worksheet->has_comments) {\n                self->comment_count += 1;\n                comment_id += 1;\n                self->has_comments = LXW_TRUE;\n            }\n\n            vml_drawing_id += 1;\n\n            comment_count = lxw_worksheet_prepare_vml_objects(worksheet,\n                                                              vml_data_id,\n                                                              vml_shape_id,\n                                                              vml_drawing_id,\n                                                              comment_id);\n\n            /* Each VML should start with a shape id incremented by 1024. */\n            vml_data_id += 1 * ((1024 + comment_count) / 1024);\n            vml_shape_id += 1024 * ((1024 + comment_count) / 1024);\n        }\n    }\n}", "path": "php-ext-xlswriter/kernel/write.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "viest/php-ext-xlswriter", "stars": 2182, "license": "bsd-2-clause", "language": "c", "size": 1356}
{"docstring": "/**\n * Bind a X pixmap to an OpenGL texture.\n */\n", "func_signal": "bool glx_bind_pixmap(session_t *ps, glx_texture_t **pptex, xcb_pixmap_t pixmap, int width,\n                     int height, bool repeat, const struct glx_fbconfig_info *fbcfg)", "code": "{\n\tif (ps->o.backend != BKEND_GLX && ps->o.backend != BKEND_XR_GLX_HYBRID)\n\t\treturn true;\n\n\tif (!pixmap) {\n\t\tlog_error(\"Binding to an empty pixmap %#010x. This can't work.\", pixmap);\n\t\treturn false;\n\t}\n\n\tassert(fbcfg);\n\tglx_texture_t *ptex = *pptex;\n\tbool need_release = true;\n\n\t// Release pixmap if parameters are inconsistent\n\tif (ptex && ptex->texture && ptex->pixmap != pixmap) {\n\t\tglx_release_pixmap(ps, ptex);\n\t}\n\n\t// Allocate structure\n\tif (!ptex) {\n\t\tstatic const glx_texture_t GLX_TEX_DEF = {\n\t\t    .texture = 0,\n\t\t    .glpixmap = 0,\n\t\t    .pixmap = 0,\n\t\t    .target = 0,\n\t\t    .width = 0,\n\t\t    .height = 0,\n\t\t    .y_inverted = false,\n\t\t};\n\n\t\tptex = cmalloc(glx_texture_t);\n\t\tmemcpy(ptex, &GLX_TEX_DEF, sizeof(glx_texture_t));\n\t\t*pptex = ptex;\n\t}\n\n\t// Create GLX pixmap\n\tint depth = 0;\n\tif (!ptex->glpixmap) {\n\t\tneed_release = false;\n\n\t\t// Retrieve pixmap parameters, if they aren't provided\n\t\tif (!width || !height) {\n\t\t\tauto r = xcb_get_geometry_reply(\n\t\t\t    ps->c, xcb_get_geometry(ps->c, pixmap), NULL);\n\t\t\tif (!r) {\n\t\t\t\tlog_error(\"Failed to query info of pixmap %#010x.\", pixmap);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r->depth > OPENGL_MAX_DEPTH) {\n\t\t\t\tlog_error(\"Requested depth %d higher than %d.\", depth,\n\t\t\t\t          OPENGL_MAX_DEPTH);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdepth = r->depth;\n\t\t\twidth = r->width;\n\t\t\theight = r->height;\n\t\t\tfree(r);\n\t\t}\n\n\t\t// Determine texture target, copied from compiz\n\t\t// The assumption we made here is the target never changes based on any\n\t\t// pixmap-specific parameters, and this may change in the future\n\t\tGLenum tex_tgt = 0;\n\t\tif (GLX_TEXTURE_2D_BIT_EXT & fbcfg->texture_tgts &&\n\t\t    ps->psglx->has_texture_non_power_of_two)\n\t\t\ttex_tgt = GLX_TEXTURE_2D_EXT;\n\t\telse if (GLX_TEXTURE_RECTANGLE_BIT_EXT & fbcfg->texture_tgts)\n\t\t\ttex_tgt = GLX_TEXTURE_RECTANGLE_EXT;\n\t\telse if (!(GLX_TEXTURE_2D_BIT_EXT & fbcfg->texture_tgts))\n\t\t\ttex_tgt = GLX_TEXTURE_RECTANGLE_EXT;\n\t\telse\n\t\t\ttex_tgt = GLX_TEXTURE_2D_EXT;\n\n\t\tlog_debug(\"depth %d, tgt %#x, rgba %d\", depth, tex_tgt,\n\t\t          (GLX_TEXTURE_FORMAT_RGBA_EXT == fbcfg->texture_fmt));\n\n\t\tGLint attrs[] = {\n\t\t    GLX_TEXTURE_FORMAT_EXT,\n\t\t    fbcfg->texture_fmt,\n\t\t    GLX_TEXTURE_TARGET_EXT,\n\t\t    (GLint)tex_tgt,\n\t\t    0,\n\t\t};\n\n\t\tptex->glpixmap = glXCreatePixmap(ps->dpy, fbcfg->cfg, pixmap, attrs);\n\t\tptex->pixmap = pixmap;\n\t\tptex->target =\n\t\t    (GLX_TEXTURE_2D_EXT == tex_tgt ? GL_TEXTURE_2D : GL_TEXTURE_RECTANGLE);\n\t\tptex->width = width;\n\t\tptex->height = height;\n\t\tptex->y_inverted = fbcfg->y_inverted;\n\t}\n\tif (!ptex->glpixmap) {\n\t\tlog_error(\"Failed to allocate GLX pixmap.\");\n\t\treturn false;\n\t}\n\n\tglEnable(ptex->target);\n\n\t// Create texture\n\tif (!ptex->texture) {\n\t\tneed_release = false;\n\n\t\tGLuint texture = 0;\n\t\tglGenTextures(1, &texture);\n\t\tglBindTexture(ptex->target, texture);\n\n\t\tglTexParameteri(ptex->target, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t\tglTexParameteri(ptex->target, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tif (repeat) {\n\t\t\tglTexParameteri(ptex->target, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\t\tglTexParameteri(ptex->target, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\t\t} else {\n\t\t\tglTexParameteri(ptex->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\t\tglTexParameteri(ptex->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t\t}\n\n\t\tglBindTexture(ptex->target, 0);\n\n\t\tptex->texture = texture;\n\t}\n\tif (!ptex->texture) {\n\t\tlog_error(\"Failed to allocate texture.\");\n\t\treturn false;\n\t}\n\n\tglBindTexture(ptex->target, ptex->texture);\n\n\t// The specification requires rebinding whenever the content changes...\n\t// We can't follow this, too slow.\n\tif (need_release)\n\t\tglXReleaseTexImageEXT(ps->dpy, ptex->glpixmap, GLX_FRONT_LEFT_EXT);\n\n\tglXBindTexImageEXT(ps->dpy, ptex->glpixmap, GLX_FRONT_LEFT_EXT, NULL);\n\n\t// Cleanup\n\tglBindTexture(ptex->target, 0);\n\tglDisable(ptex->target);\n\n\tgl_check_err();\n\n\treturn true;\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Initialize GLX rounded corners filter.\n */\n", "func_signal": "bool glx_init_rounded_corners(session_t *ps)", "code": "{\n\tchar *lc_numeric_old = strdup(setlocale(LC_NUMERIC, NULL));\n\t// Enforce LC_NUMERIC locale \"C\" here to make sure decimal point is sane\n\t// Thanks to hiciu for reporting.\n\tsetlocale(LC_NUMERIC, \"C\");\n\n\tstatic const char *FRAG_SHADER =\n\t    \"#version 110\\n\"\n\t    \"%s\"        // extensions\n\t    \"uniform float u_radius;\\n\"\n\t    \"uniform float u_borderw;\\n\"\n\t    \"uniform int u_is_focused;\\n\"\n\t    \"uniform vec2 u_texcoord;\\n\"\n\t    \"uniform vec2 u_texsize;\\n\"\n\t    \"uniform vec2 u_resolution;\\n\"\n\t    \"uniform %s tex_scr;\\n\"        // sampler2D | sampler2DRect\n\t    \"\\n\"\n\t    \"// https://www.shadertoy.com/view/ltS3zW\\n\"\n\t    \"float RectSDF(vec2 p, vec2 b, float r) {\\n\"\n\t    \"  vec2 d = abs(p) - b + vec2(r);\\n\"\n\t    \"  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\\n\"\n\t    \"}\\n\\n\"\n\t    \"// https://www.shadertoy.com/view/ldfSDj\\n\"\n\t    \"float udRoundBox( vec2 p, vec2 b, float r )\\n\"\n\t    \"{\\n\"\n\t    \"  return length(max(abs(p)-b+r,0.0))-r;\\n\"\n\t    \"}\\n\\n\"\n\t    \"void main()\\n\"\n\t    \"{\\n\"\n\t    \"  vec2 coord = vec2(u_texcoord.x, \"\n\t    \"u_resolution.y-u_texsize.y-u_texcoord.y);\\n\"\n\t    \"  vec4 u_v4SrcColor = %s(tex_scr, vec2(gl_TexCoord[0].st));\\n\"\n\t    \"  float u_fRadiusPx = u_radius;\\n\"\n\t    \"  float u_fHalfBorderThickness = 0.0;\\n\"\n\t    \"  vec4 u_v4BorderColor = vec4(1.0, 0.0, 0.0, 1.0);\\n\"\n\t    \"  vec4 u_v4FillColor = vec4(0.0, 0.0, 0.0, 0.0);\\n\"\n\t    \"  vec4 v4FromColor = u_v4BorderColor;\t//Always the border \"\n\t    \"color. If no border, this still should be set\\n\"\n\t    \"  vec4 v4ToColor = u_v4SrcColor;\t\t//Outside color is the \"\n\t    \"background texture\\n\"\n\t    \"\\n\"\n\t    \"  vec2 u_v2HalfShapeSizePx = u_texsize/2.0 - \"\n\t    \"vec2(u_fHalfBorderThickness);\\n\"\n\t    \"  vec2 v_v2CenteredPos = (gl_FragCoord.xy - u_texsize.xy / 2.0 - \"\n\t    \"coord);\\n\"\n\t    \"\\n\"\n\t    \"  float fDist = RectSDF(v_v2CenteredPos, u_v2HalfShapeSizePx, \"\n\t    \"u_fRadiusPx - u_fHalfBorderThickness);\\n\"\n\t    \"  if (u_fHalfBorderThickness > 0.0) {\\n\"\n\t    \"    if (fDist < 0.0) {\\n\"\n\t    \"      v4ToColor = u_v4FillColor;\\n\"\n\t    \"    }\\n\"\n\t    \"    fDist = abs(fDist) - u_fHalfBorderThickness;\\n\"\n\t    \"  } else {\\n\"\n\t    \"    v4FromColor = u_v4FillColor;\\n\"\n\t    \"  }\\n\"\n\t    \"  float fBlendAmount = clamp(fDist + 0.5, 0.0, 1.0);\\n\"\n\t    \"  vec4 c = mix(v4FromColor, v4ToColor, fBlendAmount);\\n\"\n\t    \"\\n\"\n\t    \"  // final color\\n\"\n\t    \"  gl_FragColor = c;\\n\"\n\t    \"\\n\"\n\t    \"}\\n\";\n\n\tconst bool use_texture_rect = !ps->psglx->has_texture_non_power_of_two;\n\tconst char *sampler_type = (use_texture_rect ? \"sampler2DRect\" : \"sampler2D\");\n\tconst char *texture_func = (use_texture_rect ? \"texture2DRect\" : \"texture2D\");\n\tchar *extension = NULL;\n\tif (use_texture_rect) {\n\t\tmstrextend(&extension, \"#extension GL_ARB_texture_rectangle : \"\n\t\t                       \"require\\n\");\n\t}\n\tif (!extension) {\n\t\textension = strdup(\"\");\n\t}\n\n\tbool success = false;\n\t// Build rounded corners shader\n\tauto ppass = ps->psglx->round_passes;\n\tauto len = strlen(FRAG_SHADER) + strlen(extension) + strlen(sampler_type) +\n\t           strlen(texture_func) + 1;\n\tchar *shader_str = ccalloc(len, char);\n\n\tsprintf(shader_str, FRAG_SHADER, extension, sampler_type, texture_func);\n\tassert(strlen(shader_str) < len);\n\n\tlog_debug(\"Generated rounded corners shader:\\n%s\\n\", shader_str);\n\n\tppass->frag_shader = gl_create_shader(GL_FRAGMENT_SHADER, shader_str);\n\tfree(shader_str);\n\n\tif (!ppass->frag_shader) {\n\t\tlog_error(\"Failed to create rounded corners fragment shader.\");\n\t\tgoto out;\n\t}\n\n\t// Build program\n\tppass->prog = gl_create_program(&ppass->frag_shader, 1);\n\tif (!ppass->prog) {\n\t\tlog_error(\"Failed to create GLSL program.\");\n\t\tgoto out;\n\t}\n\n\t// Get uniform addresses\n#define P_GET_UNIFM_LOC(name, target)                                                    \\\n\t{                                                                                \\\n\t\tppass->target = glGetUniformLocation(ppass->prog, name);                 \\\n\t\tif (ppass->target < 0) {                                                 \\\n\t\t\tlog_debug(\"Failed to get location of rounded corners uniform \"   \\\n\t\t\t          \"'\" name \"'. Might be troublesome.\");                  \\\n\t\t}                                                                        \\\n\t}\n\tP_GET_UNIFM_LOC(\"u_radius\", unifm_radius);\n\tP_GET_UNIFM_LOC(\"u_texcoord\", unifm_texcoord);\n\tP_GET_UNIFM_LOC(\"u_texsize\", unifm_texsize);\n\tP_GET_UNIFM_LOC(\"u_borderw\", unifm_borderw);\n\tP_GET_UNIFM_LOC(\"u_is_focused\", unifm_is_focused);\n\tP_GET_UNIFM_LOC(\"u_resolution\", unifm_resolution);\n#undef P_GET_UNIFM_LOC\n\n\tsuccess = true;\n\nout:\n\tfree(extension);\n\n\t// Restore LC_NUMERIC\n\tsetlocale(LC_NUMERIC, lc_numeric_old);\n\tfree(lc_numeric_old);\n\n\tgl_check_err();\n\n\treturn success;\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Load a GLSL main program from shader strings.\n */\n", "func_signal": "bool glx_load_prog_main(const char *vshader_str, const char *fshader_str,\n                        glx_prog_main_t *pprogram)", "code": "{\n\tassert(pprogram);\n\n\t// Build program\n\tpprogram->prog = gl_create_program_from_str(vshader_str, fshader_str);\n\tif (!pprogram->prog) {\n\t\tlog_error(\"Failed to create GLSL program.\");\n\t\treturn false;\n\t}\n\n\t// Get uniform addresses\n#define P_GET_UNIFM_LOC(name, target)                                                    \\\n\t{                                                                                \\\n\t\tpprogram->target = glGetUniformLocation(pprogram->prog, name);           \\\n\t\tif (pprogram->target < 0) {                                              \\\n\t\t\tlog_error(\"Failed to get location of uniform '\" name             \\\n\t\t\t          \"'. Might be troublesome.\");                           \\\n\t\t}                                                                        \\\n\t}\n\tP_GET_UNIFM_LOC(\"opacity\", unifm_opacity);\n\tP_GET_UNIFM_LOC(\"invert_color\", unifm_invert_color);\n\tP_GET_UNIFM_LOC(\"tex\", unifm_tex);\n\tP_GET_UNIFM_LOC(\"time\", unifm_time);\n#undef P_GET_UNIFM_LOC\n\n\tgl_check_err();\n\n\treturn true;\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * @brief Release binding of a texture.\n */\n", "func_signal": "void glx_release_pixmap(session_t *ps, glx_texture_t *ptex)", "code": "{\n\t// Release binding\n\tif (ptex->glpixmap && ptex->texture) {\n\t\tglBindTexture(ptex->target, ptex->texture);\n\t\tglXReleaseTexImageEXT(ps->dpy, ptex->glpixmap, GLX_FRONT_LEFT_EXT);\n\t\tglBindTexture(ptex->target, 0);\n\t}\n\n\t// Free GLX Pixmap\n\tif (ptex->glpixmap) {\n\t\tglXDestroyPixmap(ps->dpy, ptex->glpixmap);\n\t\tptex->glpixmap = 0;\n\t}\n\n\tgl_check_err();\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * @brief Render a region with texture data.\n */\n", "func_signal": "bool glx_render(session_t *ps, const glx_texture_t *ptex, int x, int y, int dx, int dy,\n                int width, int height, int z, double opacity, bool argb, bool neg,\n                const region_t *reg_tgt, const glx_prog_main_t *pprogram)", "code": "{\n\tif (!ptex || !ptex->texture) {\n\t\tlog_error(\"Missing texture.\");\n\t\treturn false;\n\t}\n\n\tconst bool has_prog = pprogram && pprogram->prog;\n\tbool dual_texture = false;\n\n\t// It's required by legacy versions of OpenGL to enable texture target\n\t// before specifying environment. Thanks to madsy for telling me.\n\tglEnable(ptex->target);\n\n\t// Enable blending if needed\n\tif (opacity < 1.0 || argb) {\n\n\t\tglEnable(GL_BLEND);\n\n\t\t// Needed for handling opacity of ARGB texture\n\t\tglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n\n\t\t// This is all weird, but X Render is using premultiplied ARGB format, and\n\t\t// we need to use those things to correct it. Thanks to derhass for help.\n\t\tglBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);\n\t\tglColor4d(opacity, opacity, opacity, opacity);\n\t}\n\n\tif (!has_prog) {\n\t\t// The default, fixed-function path\n\t\t// Color negation\n\t\tif (neg) {\n\t\t\t// Simple color negation\n\t\t\tif (!glIsEnabled(GL_BLEND)) {\n\t\t\t\tglEnable(GL_COLOR_LOGIC_OP);\n\t\t\t\tglLogicOp(GL_COPY_INVERTED);\n\t\t\t}\n\t\t\t// ARGB texture color negation\n\t\t\telse if (argb) {\n\t\t\t\tdual_texture = true;\n\n\t\t\t\t// Use two texture stages because the calculation is too\n\t\t\t\t// complicated, thanks to madsy for providing code Texture\n\t\t\t\t// stage 0\n\t\t\t\tglActiveTexture(GL_TEXTURE0);\n\n\t\t\t\t// Negation for premultiplied color: color = A - C\n\t\t\t\tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_SUBTRACT);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_ALPHA);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_TEXTURE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_COLOR);\n\n\t\t\t\t// Pass texture alpha through\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_REPLACE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);\n\n\t\t\t\t// Texture stage 1\n\t\t\t\tglActiveTexture(GL_TEXTURE1);\n\t\t\t\tglEnable(ptex->target);\n\t\t\t\tglBindTexture(ptex->target, ptex->texture);\n\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);\n\n\t\t\t\t// Modulation with constant factor\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PREVIOUS);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_PRIMARY_COLOR);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_ALPHA);\n\n\t\t\t\t// Modulation with constant factor\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_PREVIOUS);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);\n\n\t\t\t\tglActiveTexture(GL_TEXTURE0);\n\t\t\t}\n\t\t\t// RGB blend color negation\n\t\t\telse {\n\t\t\t\tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);\n\n\t\t\t\t// Modulation with constant factor\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB,\n\t\t\t\t          GL_ONE_MINUS_SRC_COLOR);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_PRIMARY_COLOR);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_COLOR);\n\n\t\t\t\t// Modulation with constant factor\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);\n\t\t\t\tglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Programmable path\n\t\tassert(pprogram->prog);\n\t\tglUseProgram(pprogram->prog);\n\t\tstruct timespec ts;\n\t\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\t\tif (pprogram->unifm_opacity >= 0)\n\t\t\tglUniform1f(pprogram->unifm_opacity, (float)opacity);\n\t\tif (pprogram->unifm_invert_color >= 0)\n\t\t\tglUniform1i(pprogram->unifm_invert_color, neg);\n\t\tif (pprogram->unifm_tex >= 0)\n\t\t\tglUniform1i(pprogram->unifm_tex, 0);\n\t\tif (pprogram->unifm_time >= 0)\n\t\t\tglUniform1f(pprogram->unifm_time, (float)ts.tv_sec * 1000.0f +\n\t\t\t                                      (float)ts.tv_nsec / 1.0e6f);\n\t}\n\n\t// log_trace(\"Draw: %d, %d, %d, %d -> %d, %d (%d, %d) z %d\", x, y, width, height,\n\t//          dx, dy, ptex->width, ptex->height, z);\n\n\t// Bind texture\n\tglBindTexture(ptex->target, ptex->texture);\n\tif (dual_texture) {\n\t\tglActiveTexture(GL_TEXTURE1);\n\t\tglBindTexture(ptex->target, ptex->texture);\n\t\tglActiveTexture(GL_TEXTURE0);\n\t}\n\n\t// Painting\n\t{\n\t\tP_PAINTREG_START(crect) {\n\t\t\t// texture-local coordinates\n\t\t\tauto rx = (GLfloat)(crect.x1 - dx + x);\n\t\t\tauto ry = (GLfloat)(crect.y1 - dy + y);\n\t\t\tauto rxe = rx + (GLfloat)(crect.x2 - crect.x1);\n\t\t\tauto rye = ry + (GLfloat)(crect.y2 - crect.y1);\n\t\t\t// Rectangle textures have [0-w] [0-h] while 2D texture has [0-1]\n\t\t\t// [0-1] Thanks to amonakov for pointing out!\n\t\t\tif (GL_TEXTURE_2D == ptex->target) {\n\t\t\t\trx = rx / (GLfloat)ptex->width;\n\t\t\t\try = ry / (GLfloat)ptex->height;\n\t\t\t\trxe = rxe / (GLfloat)ptex->width;\n\t\t\t\trye = rye / (GLfloat)ptex->height;\n\t\t\t}\n\n\t\t\t// coordinates for the texture in the target\n\t\t\tGLint rdx = crect.x1;\n\t\t\tGLint rdy = ps->root_height - crect.y1;\n\t\t\tGLint rdxe = rdx + (crect.x2 - crect.x1);\n\t\t\tGLint rdye = rdy - (crect.y2 - crect.y1);\n\n\t\t\t// Invert Y if needed, this may not work as expected, though. I\n\t\t\t// don't have such a FBConfig to test with.\n\t\t\tif (!ptex->y_inverted) {\n\t\t\t\try = 1.0f - ry;\n\t\t\t\trye = 1.0f - rye;\n\t\t\t}\n\n\t\t\t// log_trace(\"Rect %d: %f, %f, %f, %f -> %d, %d, %d, %d\", ri, rx,\n\t\t\t// ry, rxe, rye,\n\t\t\t//          rdx, rdy, rdxe, rdye);\n\n#define P_TEXCOORD(cx, cy)                                                               \\\n\t{                                                                                \\\n\t\tif (dual_texture) {                                                      \\\n\t\t\tglMultiTexCoord2f(GL_TEXTURE0, cx, cy);                          \\\n\t\t\tglMultiTexCoord2f(GL_TEXTURE1, cx, cy);                          \\\n\t\t} else                                                                   \\\n\t\t\tglTexCoord2f(cx, cy);                                            \\\n\t}\n\t\t\tP_TEXCOORD(rx, ry);\n\t\t\tglVertex3i(rdx, rdy, z);\n\n\t\t\tP_TEXCOORD(rxe, ry);\n\t\t\tglVertex3i(rdxe, rdy, z);\n\n\t\t\tP_TEXCOORD(rxe, rye);\n\t\t\tglVertex3i(rdxe, rdye, z);\n\n\t\t\tP_TEXCOORD(rx, rye);\n\t\t\tglVertex3i(rdx, rdye, z);\n\t\t}\n\t\tP_PAINTREG_END();\n\t}\n\n\t// Cleanup\n\tglBindTexture(ptex->target, 0);\n\tglColor4f(0.0f, 0.0f, 0.0f, 0.0f);\n\tglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\n\tglDisable(GL_BLEND);\n\tglDisable(GL_COLOR_LOGIC_OP);\n\tglDisable(ptex->target);\n\n\tif (dual_texture) {\n\t\tglActiveTexture(GL_TEXTURE1);\n\t\tglBindTexture(ptex->target, 0);\n\t\tglDisable(ptex->target);\n\t\tglActiveTexture(GL_TEXTURE0);\n\t}\n\n\tif (has_prog)\n\t\tglUseProgram(0);\n\n\tgl_check_err();\n\n\treturn true;\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Initialize GLX blur filter.\n */\n", "func_signal": "bool glx_init_blur(session_t *ps)", "code": "{\n\tassert(ps->o.blur_kernel_count > 0);\n\tassert(ps->o.blur_kerns);\n\tassert(ps->o.blur_kerns[0]);\n\n\t// Allocate PBO if more than one blur kernel is present\n\tif (ps->o.blur_kernel_count > 1) {\n\t\t// Try to generate a framebuffer\n\t\tGLuint fbo = 0;\n\t\tglGenFramebuffers(1, &fbo);\n\t\tif (!fbo) {\n\t\t\tlog_error(\"Failed to generate Framebuffer. Cannot do multi-pass \"\n\t\t\t          \"blur with GLX\"\n\t\t\t          \" backend.\");\n\t\t\treturn false;\n\t\t}\n\t\tglDeleteFramebuffers(1, &fbo);\n\t}\n\n\t{\n\t\tchar *lc_numeric_old = strdup(setlocale(LC_NUMERIC, NULL));\n\t\t// Enforce LC_NUMERIC locale \"C\" here to make sure decimal point is sane\n\t\t// Thanks to hiciu for reporting.\n\t\tsetlocale(LC_NUMERIC, \"C\");\n\n\t\tstatic const char *FRAG_SHADER_BLUR_PREFIX =\n\t\t    \"#version 110\\n\"\n\t\t    \"%s\"\n\t\t    \"uniform float offset_x;\\n\"\n\t\t    \"uniform float offset_y;\\n\"\n\t\t    \"uniform float factor_center;\\n\"\n\t\t    \"uniform %s tex_scr;\\n\"\n\t\t    \"\\n\"\n\t\t    \"void main() {\\n\"\n\t\t    \"  vec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\\n\";\n\t\tstatic const char *FRAG_SHADER_BLUR_ADD =\n\t\t    \"  sum += float(%.7g) * %s(tex_scr, vec2(gl_TexCoord[0].x + offset_x \"\n\t\t    \"* float(%d), gl_TexCoord[0].y + offset_y * float(%d)));\\n\";\n\t\tstatic const char *FRAG_SHADER_BLUR_SUFFIX =\n\t\t    \"  sum += %s(tex_scr, vec2(gl_TexCoord[0].x, gl_TexCoord[0].y)) * \"\n\t\t    \"factor_center;\\n\"\n\t\t    \"  gl_FragColor = sum / (factor_center + float(%.7g));\\n\"\n\t\t    \"}\\n\";\n\n\t\tconst bool use_texture_rect = !ps->psglx->has_texture_non_power_of_two;\n\t\tconst char *sampler_type = (use_texture_rect ? \"sampler2DRect\" : \"sampler2D\");\n\t\tconst char *texture_func = (use_texture_rect ? \"texture2DRect\" : \"texture2D\");\n\t\tconst char *shader_add = FRAG_SHADER_BLUR_ADD;\n\t\tchar *extension = NULL;\n\t\tif (use_texture_rect) {\n\t\t\tmstrextend(&extension, \"#extension GL_ARB_texture_rectangle : \"\n\t\t\t                       \"require\\n\");\n\t\t}\n\t\tif (!extension) {\n\t\t\textension = strdup(\"\");\n\t\t}\n\n\t\tfor (int i = 0; i < ps->o.blur_kernel_count; ++i) {\n\t\t\tauto kern = ps->o.blur_kerns[i];\n\t\t\tglx_blur_pass_t *ppass = &ps->psglx->blur_passes[i];\n\n\t\t\t// Build shader\n\t\t\tint width = kern->w, height = kern->h;\n\t\t\tint nele = width * height - 1;\n\t\t\tassert(nele >= 0);\n\t\t\tauto len =\n\t\t\t    strlen(FRAG_SHADER_BLUR_PREFIX) + strlen(sampler_type) +\n\t\t\t    strlen(extension) +\n\t\t\t    (strlen(shader_add) + strlen(texture_func) + 42) * (uint)nele +\n\t\t\t    strlen(FRAG_SHADER_BLUR_SUFFIX) + strlen(texture_func) + 12 + 1;\n\t\t\tchar *shader_str = ccalloc(len, char);\n\t\t\tchar *pc = shader_str;\n\t\t\tsprintf(pc, FRAG_SHADER_BLUR_PREFIX, extension, sampler_type);\n\t\t\tpc += strlen(pc);\n\t\t\tassert(strlen(shader_str) < len);\n\n\t\t\tdouble sum = 0.0;\n\t\t\tfor (int j = 0; j < height; ++j) {\n\t\t\t\tfor (int k = 0; k < width; ++k) {\n\t\t\t\t\tif (height / 2 == j && width / 2 == k)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble val = kern->data[j * width + k];\n\t\t\t\t\tif (val == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tsum += val;\n\t\t\t\t\tsprintf(pc, shader_add, val, texture_func,\n\t\t\t\t\t        k - width / 2, j - height / 2);\n\t\t\t\t\tpc += strlen(pc);\n\t\t\t\t\tassert(strlen(shader_str) < len);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsprintf(pc, FRAG_SHADER_BLUR_SUFFIX, texture_func, sum);\n\t\t\tassert(strlen(shader_str) < len);\n\t\t\tppass->frag_shader = gl_create_shader(GL_FRAGMENT_SHADER, shader_str);\n\t\t\tfree(shader_str);\n\n\t\t\tif (!ppass->frag_shader) {\n\t\t\t\tlog_error(\"Failed to create fragment shader %d.\", i);\n\t\t\t\tfree(extension);\n\t\t\t\tfree(lc_numeric_old);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Build program\n\t\t\tppass->prog = gl_create_program(&ppass->frag_shader, 1);\n\t\t\tif (!ppass->prog) {\n\t\t\t\tlog_error(\"Failed to create GLSL program.\");\n\t\t\t\tfree(extension);\n\t\t\t\tfree(lc_numeric_old);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Get uniform addresses\n#define P_GET_UNIFM_LOC(name, target)                                                    \\\n\t{                                                                                \\\n\t\tppass->target = glGetUniformLocation(ppass->prog, name);                 \\\n\t\tif (ppass->target < 0) {                                                 \\\n\t\t\tlog_error(\"Failed to get location of %d-th uniform '\" name       \\\n\t\t\t          \"'. Might be troublesome.\",                            \\\n\t\t\t          i);                                                    \\\n\t\t}                                                                        \\\n\t}\n\n\t\t\tP_GET_UNIFM_LOC(\"factor_center\", unifm_factor_center);\n\t\t\tP_GET_UNIFM_LOC(\"offset_x\", unifm_offset_x);\n\t\t\tP_GET_UNIFM_LOC(\"offset_y\", unifm_offset_y);\n\n#undef P_GET_UNIFM_LOC\n\t\t}\n\t\tfree(extension);\n\n\t\t// Restore LC_NUMERIC\n\t\tsetlocale(LC_NUMERIC, lc_numeric_old);\n\t\tfree(lc_numeric_old);\n\t}\n\n\tgl_check_err();\n\n\treturn true;\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/// Create a gaussian kernel with auto detected standard deviation. The choosen standard\n/// deviation tries to make sure the outer most pixels of the shadow are completely\n/// transparent, so the transition from shadow to the background is smooth.\n///\n/// @param[in] shadow_radius the radius of the shadow\n", "func_signal": "conv *gaussian_kernel_autodetect_deviation(int shadow_radius)", "code": "{\n\tassert(shadow_radius >= 0);\n\tint size = shadow_radius * 2 + 1;\n\n\tif (shadow_radius == 0) {\n\t\treturn gaussian_kernel(0, size);\n\t}\n\tdouble std = gaussian_kernel_std_for_size(shadow_radius, 1.0 / 256.0);\n\treturn gaussian_kernel(std, size);\n}", "path": "picom/src/kernel.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Allocate the space and join two strings.\n */\n", "func_signal": "char *mstrjoin(const char *src1, const char *src2)", "code": "{\n\tauto len1 = strlen(src1);\n\tauto len2 = strlen(src2);\n\tauto len = len1 + len2 + 1;\n\tauto str = ccalloc(len, char);\n\n\tstrncpy(str, src1, len1);\n\tstrncpy(str + len1, src2, len2);\n\tstr[len - 1] = '\\0';\n\n\treturn str;\n}", "path": "picom/src/string_utils.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Bind an OpenGL texture and fill it with pixel data from back buffer\n */\n", "func_signal": "bool glx_bind_texture(session_t *ps attr_unused, glx_texture_t **pptex, int x, int y,\n                      int width, int height)", "code": "{\n\tif (ps->o.backend != BKEND_GLX && ps->o.backend != BKEND_XR_GLX_HYBRID) {\n\t\treturn true;\n\t}\n\n\tglx_texture_t *ptex = *pptex;\n\n\t// log_trace(\"Copying xy(%d %d) wh(%d %d)\", x, y, width, height);\n\n\t// Release texture if parameters are inconsistent\n\tif (ptex && ptex->texture && (ptex->width != width || ptex->height != height)) {\n\t\tfree_texture(ps, &ptex);\n\t}\n\n\t// Allocate structure\n\tif (!ptex) {\n\t\tptex = ccalloc(1, glx_texture_t);\n\t\t*pptex = ptex;\n\n\t\tptex->width = width;\n\t\tptex->height = height;\n\t\tptex->target = GL_TEXTURE_RECTANGLE;\n\t\tif (ps->psglx->has_texture_non_power_of_two) {\n\t\t\tptex->target = GL_TEXTURE_2D;\n\t\t}\n\t}\n\n\t// Create texture\n\tif (!ptex->texture) {\n\t\tptex->texture = glx_gen_texture(ptex->target, width, height);\n\t}\n\tif (!ptex->texture) {\n\t\tlog_error(\"Failed to allocate texture.\");\n\t\treturn false;\n\t}\n\n\t// Read destination pixels into a texture\n\tglEnable(ptex->target);\n\tglBindTexture(ptex->target, ptex->texture);\n\tif (width > 0 && height > 0) {\n\t\tglx_copy_region_to_tex(ps, ptex->target, x, y, x, y, width, height);\n\t}\n\n\t// Cleanup\n\tglBindTexture(ptex->target, 0);\n\tglDisable(ptex->target);\n\n\tgl_check_err();\n\n\treturn true;\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/// Sum a region convolution kernel. Region is defined by a width x height rectangle whose\n/// top left corner is at (x, y)\n", "func_signal": "double sum_kernel(const conv *map, int x, int y, int width, int height)", "code": "{\n\tdouble ret = 0;\n\n\t// Compute sum of values which are \"in range\"\n\tint xstart = normalize_i_range(x, 0, map->w),\n\t    xend = normalize_i_range(width + x, 0, map->w);\n\tint ystart = normalize_i_range(y, 0, map->h),\n\t    yend = normalize_i_range(height + y, 0, map->h);\n\tassert(yend >= ystart && xend >= xstart);\n\n\tint d = map->w;\n\tif (map->rsum) {\n\t\t// See sum_kernel_preprocess\n\t\tdouble v1 = xstart ? map->rsum[(yend - 1) * d + xstart - 1] : 0;\n\t\tdouble v2 = ystart ? map->rsum[(ystart - 1) * d + xend - 1] : 0;\n\t\tdouble v3 = (xstart && ystart) ? map->rsum[(ystart - 1) * d + xstart - 1] : 0;\n\t\treturn map->rsum[(yend - 1) * d + xend - 1] - v1 - v2 + v3;\n\t}\n\n\tfor (int yi = ystart; yi < yend; yi++) {\n\t\tfor (int xi = xstart; xi < xend; xi++) {\n\t\t\tret += map->data[yi * d + xi];\n\t\t}\n\t}\n\n\treturn ret;\n}", "path": "picom/src/kernel.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/// Parse a floating point number of form (+|-)?[0-9]*(\\.[0-9]*)\n", "func_signal": "double strtod_simple(const char *src, const char **end)", "code": "{\n\tdouble neg = 1;\n\tif (*src == '-') {\n\t\tneg = -1;\n\t\tsrc++;\n\t} else if (*src == '+') {\n\t\tsrc++;\n\t}\n\n\tdouble ret = 0;\n\twhile (*src >= '0' && *src <= '9') {\n\t\tret = ret * 10 + (*src - '0');\n\t\tsrc++;\n\t}\n\n\tif (*src == '.') {\n\t\tdouble frac = 0, mult = 0.1;\n\t\tsrc++;\n\t\twhile (*src >= '0' && *src <= '9') {\n\t\t\tfrac += mult * (*src - '0');\n\t\t\tmult *= 0.1;\n\t\t\tsrc++;\n\t\t}\n\t\tret += frac;\n\t}\n\n\t*end = src;\n\treturn ret * neg;\n}", "path": "picom/src/string_utils.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/// preprocess kernels to make shadow generation faster\n/// shadow_sum[x*d+y] is the sum of the kernel from (0, 0) to (x, y), inclusive\n", "func_signal": "void sum_kernel_preprocess(conv *map)", "code": "{\n\tif (map->rsum) {\n\t\tfree(map->rsum);\n\t}\n\n\tauto sum = map->rsum = ccalloc(map->w * map->h, double);\n\tsum[0] = map->data[0];\n\n\tfor (int x = 1; x < map->w; x++) {\n\t\tsum[x] = sum[x - 1] + map->data[x];\n\t}\n\n\tconst int d = map->w;\n\tfor (int y = 1; y < map->h; y++) {\n\t\tsum[y * d] = sum[(y - 1) * d] + map->data[y * d];\n\t\tfor (int x = 1; x < map->w; x++) {\n\t\t\tdouble tmp = sum[(y - 1) * d + x] + sum[y * d + x - 1] -\n\t\t\t             sum[(y - 1) * d + x - 1];\n\t\t\tsum[y * d + x] = tmp + map->data[y * d + x];\n\t\t}\n\t}\n}", "path": "picom/src/kernel.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Destroy GLX related resources.\n */\n", "func_signal": "void glx_destroy(session_t *ps)", "code": "{\n\tif (!ps->psglx)\n\t\treturn;\n\n\t// Free all GLX resources of windows\n\twin_stack_foreach_managed(w, &ps->window_stack) {\n\t\tfree_win_res_glx(ps, w);\n\t}\n\n\t// Free GLSL shaders/programs\n\tfor (int i = 0; i < ps->o.blur_kernel_count; ++i) {\n\t\tglx_blur_pass_t *ppass = &ps->psglx->blur_passes[i];\n\t\tif (ppass->frag_shader) {\n\t\t\tglDeleteShader(ppass->frag_shader);\n\t\t}\n\t\tif (ppass->prog) {\n\t\t\tglDeleteProgram(ppass->prog);\n\t\t}\n\t}\n\tfree(ps->psglx->blur_passes);\n\n\tglx_round_pass_t *ppass = ps->psglx->round_passes;\n\tif (ppass->frag_shader) {\n\t\tglDeleteShader(ppass->frag_shader);\n\t}\n\tif (ppass->prog) {\n\t\tglDeleteProgram(ppass->prog);\n\t}\n\tfree(ps->psglx->round_passes);\n\n\tglx_free_prog_main(&ps->glx_prog_win);\n\n\tgl_check_err();\n\n\t// Destroy GLX context\n\tif (ps->psglx->context) {\n\t\tglXMakeCurrent(ps->dpy, None, NULL);\n\t\tglXDestroyContext(ps->dpy, ps->psglx->context);\n\t\tps->psglx->context = NULL;\n\t}\n\n\tfree(ps->psglx);\n\tps->psglx = NULL;\n\tps->argb_fbconfig = NULL;\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Callback to run on root window size change.\n */\n", "func_signal": "void glx_on_root_change(session_t *ps)", "code": "{\n\tglViewport(0, 0, ps->root_width, ps->root_height);\n\n\t// Initialize matrix, copied from dcompmgr\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tglOrtho(0, ps->root_width, 0, ps->root_height, -1000.0, 1000.0);\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Get a window's name from window ID.\n */\n", "func_signal": "static inline const char *ev_window_name(session_t *ps, xcb_window_t wid)", "code": "{\n\tchar *name = \"\";\n\tif (wid) {\n\t\tname = \"(Failed to get title)\";\n\t\tif (ps->root == wid) {\n\t\t\tname = \"(Root window)\";\n\t\t} else if (ps->overlay == wid) {\n\t\t\tname = \"(Overlay)\";\n\t\t} else {\n\t\t\tauto w = find_managed_win(ps, wid);\n\t\t\tif (!w) {\n\t\t\t\tw = find_toplevel(ps, wid);\n\t\t\t}\n\n\t\t\tif (w && w->name) {\n\t\t\t\tname = w->name;\n\t\t\t}\n\t\t}\n\t}\n\treturn name;\n}", "path": "picom/src/event.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Concatenate a string on heap with another string.\n */\n", "func_signal": "void mstrextend(char **psrc1, const char *src2)", "code": "{\n\tif (!*psrc1) {\n\t\t*psrc1 = strdup(src2);\n\t\treturn;\n\t}\n\n\tauto len1 = strlen(*psrc1);\n\tauto len2 = strlen(src2);\n\tauto len = len1 + len2 + 1;\n\t*psrc1 = crealloc(*psrc1, len);\n\n\tstrncpy(*psrc1 + len1, src2, len2);\n\t(*psrc1)[len - 1] = '\\0';\n}", "path": "picom/src/string_utils.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n * Initialize OpenGL.\n */\n", "func_signal": "bool glx_init(session_t *ps, bool need_render)", "code": "{\n\tbool success = false;\n\tXVisualInfo *pvis = NULL;\n\n\t// Check for GLX extension\n\tif (!ps->glx_exists) {\n\t\tlog_error(\"No GLX extension.\");\n\t\tgoto glx_init_end;\n\t}\n\n\t// Get XVisualInfo\n\tpvis = get_visualinfo_from_visual(ps, ps->vis);\n\tif (!pvis) {\n\t\tlog_error(\"Failed to acquire XVisualInfo for current visual.\");\n\t\tgoto glx_init_end;\n\t}\n\n\t// Ensure the visual is double-buffered\n\tif (need_render) {\n\t\tint value = 0;\n\t\tif (Success != glXGetConfig(ps->dpy, pvis, GLX_USE_GL, &value) || !value) {\n\t\t\tlog_error(\"Root visual is not a GL visual.\");\n\t\t\tgoto glx_init_end;\n\t\t}\n\n\t\tif (Success != glXGetConfig(ps->dpy, pvis, GLX_DOUBLEBUFFER, &value) || !value) {\n\t\t\tlog_error(\"Root visual is not a double buffered GL visual.\");\n\t\t\tgoto glx_init_end;\n\t\t}\n\t}\n\n\t// Ensure GLX_EXT_texture_from_pixmap exists\n\tif (need_render && !glxext.has_GLX_EXT_texture_from_pixmap)\n\t\tgoto glx_init_end;\n\n\t// Initialize GLX data structure\n\tif (!ps->psglx) {\n\t\tstatic const glx_session_t CGLX_SESSION_DEF = CGLX_SESSION_INIT;\n\t\tps->psglx = cmalloc(glx_session_t);\n\t\tmemcpy(ps->psglx, &CGLX_SESSION_DEF, sizeof(glx_session_t));\n\n\t\t// +1 for the zero terminator\n\t\tps->psglx->blur_passes = ccalloc(ps->o.blur_kernel_count, glx_blur_pass_t);\n\n\t\tfor (int i = 0; i < ps->o.blur_kernel_count; ++i) {\n\t\t\tglx_blur_pass_t *ppass = &ps->psglx->blur_passes[i];\n\t\t\tppass->unifm_factor_center = -1;\n\t\t\tppass->unifm_offset_x = -1;\n\t\t\tppass->unifm_offset_y = -1;\n\t\t}\n\n\t\tps->psglx->round_passes = ccalloc(1, glx_round_pass_t);\n\t\tglx_round_pass_t *ppass = ps->psglx->round_passes;\n\t\tppass->unifm_radius = -1;\n\t\tppass->unifm_texcoord = -1;\n\t\tppass->unifm_texsize = -1;\n\t\tppass->unifm_borderw = -1;\n\t\tppass->unifm_resolution = -1;\n\t}\n\n\tglx_session_t *psglx = ps->psglx;\n\n\tif (!psglx->context) {\n\t\t// Get GLX context\n#ifndef DEBUG_GLX_DEBUG_CONTEXT\n\t\tpsglx->context = glXCreateContext(ps->dpy, pvis, None, GL_TRUE);\n#else\n\t\t{\n\t\t\tGLXFBConfig fbconfig = get_fbconfig_from_visualinfo(ps, pvis);\n\t\t\tif (!fbconfig) {\n\t\t\t\tlog_error(\"Failed to get GLXFBConfig for root visual \"\n\t\t\t\t          \"%#lx.\",\n\t\t\t\t          pvis->visualid);\n\t\t\t\tgoto glx_init_end;\n\t\t\t}\n\n\t\t\tf_glXCreateContextAttribsARB p_glXCreateContextAttribsARB =\n\t\t\t    (f_glXCreateContextAttribsARB)glXGetProcAddress(\n\t\t\t        (const GLubyte *)\"glXCreateContextAttribsARB\");\n\t\t\tif (!p_glXCreateContextAttribsARB) {\n\t\t\t\tlog_error(\"Failed to get glXCreateContextAttribsARB().\");\n\t\t\t\tgoto glx_init_end;\n\t\t\t}\n\n\t\t\tstatic const int attrib_list[] = {\n\t\t\t    GLX_CONTEXT_FLAGS_ARB, GLX_CONTEXT_DEBUG_BIT_ARB, None};\n\t\t\tpsglx->context = p_glXCreateContextAttribsARB(\n\t\t\t    ps->dpy, fbconfig, NULL, GL_TRUE, attrib_list);\n\t\t}\n#endif\n\n\t\tif (!psglx->context) {\n\t\t\tlog_error(\"Failed to get GLX context.\");\n\t\t\tgoto glx_init_end;\n\t\t}\n\n\t\t// Attach GLX context\n\t\tif (!glXMakeCurrent(ps->dpy, get_tgt_window(ps), psglx->context)) {\n\t\t\tlog_error(\"Failed to attach GLX context.\");\n\t\t\tgoto glx_init_end;\n\t\t}\n\n#ifdef DEBUG_GLX_DEBUG_CONTEXT\n\t\t{\n\t\t\tf_DebugMessageCallback p_DebugMessageCallback =\n\t\t\t    (f_DebugMessageCallback)glXGetProcAddress(\n\t\t\t        (const GLubyte *)\"glDebugMessageCallback\");\n\t\t\tif (!p_DebugMessageCallback) {\n\t\t\t\tlog_error(\"Failed to get glDebugMessageCallback(0.\");\n\t\t\t\tgoto glx_init_end;\n\t\t\t}\n\t\t\tp_DebugMessageCallback(glx_debug_msg_callback, ps);\n\t\t}\n#endif\n\t}\n\n\t// Ensure we have a stencil buffer. X Fixes does not guarantee rectangles\n\t// in regions don't overlap, so we must use stencil buffer to make sure\n\t// we don't paint a region for more than one time, I think?\n\tif (need_render && !ps->o.glx_no_stencil) {\n\t\tGLint val = 0;\n\t\tglGetIntegerv(GL_STENCIL_BITS, &val);\n\t\tif (!val) {\n\t\t\tlog_error(\"Target window doesn't have stencil buffer.\");\n\t\t\tgoto glx_init_end;\n\t\t}\n\t}\n\n\t// Check GL_ARB_texture_non_power_of_two, requires a GLX context and\n\t// must precede FBConfig fetching\n\tif (need_render)\n\t\tpsglx->has_texture_non_power_of_two =\n\t\t    gl_has_extension(\"GL_ARB_texture_non_power_of_two\");\n\n\t// Render preparations\n\tif (need_render) {\n\t\tglx_on_root_change(ps);\n\n\t\tglDisable(GL_DEPTH_TEST);\n\t\tglDepthMask(GL_FALSE);\n\t\tglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\n\t\tglDisable(GL_BLEND);\n\n\t\tif (!ps->o.glx_no_stencil) {\n\t\t\t// Initialize stencil buffer\n\t\t\tglClear(GL_STENCIL_BUFFER_BIT);\n\t\t\tglDisable(GL_STENCIL_TEST);\n\t\t\tglStencilMask(0x1);\n\t\t\tglStencilFunc(GL_EQUAL, 0x1, 0x1);\n\t\t}\n\n\t\t// Clear screen\n\t\tglClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n\t\t// glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\t\t// glXSwapBuffers(ps->dpy, get_tgt_window(ps));\n\t}\n\n\tsuccess = true;\n\nglx_init_end:\n\tXFree(pvis);\n\n\tif (!success)\n\t\tglx_destroy(ps);\n\n\treturn success;\n}", "path": "picom/src/opengl.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/// Pick a suitable gaussian kernel radius for a given kernel size. The returned radius\n/// is the maximum possible radius (<= size*2) that satisfies no sum of the rows in\n/// the kernel are less than `row_limit` (up to certain precision).\n", "func_signal": "static inline double gaussian_kernel_std_for_size(int size, double row_limit)", "code": "{\n\tassert(size > 0);\n\tif (row_limit >= 1.0 / 2.0 / size) {\n\t\treturn size * 2;\n\t}\n\tdouble l = 0, r = size * 2;\n\twhile (r - l > 1e-2) {\n\t\tdouble mid = (l + r) / 2.0;\n\t\tdouble vmid = estimate_first_row_sum(size, mid);\n\t\tif (vmid > row_limit) {\n\t\t\tr = mid;\n\t\t} else {\n\t\t\tl = mid;\n\t\t}\n\t}\n\treturn (l + r) / 2.0;\n}", "path": "picom/src/kernel.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/// Estimate the element of the sum of the first row in a gaussian kernel with standard\n/// deviation `r` and size `size`,\n", "func_signal": "static inline double estimate_first_row_sum(double size, double r)", "code": "{\n\tdouble factor = erf(size / r / sqrt(2));\n\tdouble a = exp(-0.5 * size * size / (r * r)) / sqrt(2 * M_PI) / r;\n\treturn a / factor;\n}", "path": "picom/src/kernel.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/// Handle configure event of a regular window\n", "func_signal": "static void configure_win(session_t *ps, xcb_configure_notify_event_t *ce)", "code": "{\n\tauto w = find_win(ps, ce->window);\n\n\tif (!w) {\n\t\treturn;\n\t}\n\n\tif (!w->managed) {\n\t\trestack_above(ps, w, ce->above_sibling);\n\t\treturn;\n\t}\n\n\tauto mw = (struct managed_win *)w;\n\n\trestack_above(ps, w, ce->above_sibling);\n\n\t// We check against pending_g here, because there might have been multiple\n\t// configure notifies in this cycle, or the window could receive multiple updates\n\t// while it's unmapped.\n\tbool position_changed = mw->pending_g.x != ce->x || mw->pending_g.y != ce->y;\n\tbool size_changed = mw->pending_g.width != ce->width ||\n\t                    mw->pending_g.height != ce->height ||\n\t                    mw->pending_g.border_width != ce->border_width;\n\tif (position_changed || size_changed) {\n\t\t// Queue pending updates\n\t\twin_set_flags(mw, WIN_FLAGS_FACTOR_CHANGED);\n\t\t// TODO(yshui) don't set pending_updates if the window is not\n\t\t// visible/mapped\n\t\tps->pending_updates = true;\n\n\t\t// At least one of the following if's is true\n\t\tif (position_changed) {\n\t\t\tlog_trace(\"Window position changed, %dx%d -> %dx%d\", mw->g.x,\n\t\t\t          mw->g.y, ce->x, ce->y);\n\t\t\tmw->pending_g.x = ce->x;\n\t\t\tmw->pending_g.y = ce->y;\n\t\t\twin_set_flags(mw, WIN_FLAGS_POSITION_STALE);\n\t\t}\n\n\t\tif (size_changed) {\n\t\t\tlog_trace(\"Window size changed, %dx%d -> %dx%d\", mw->g.width,\n\t\t\t          mw->g.height, ce->width, ce->height);\n\t\t\tmw->pending_g.width = ce->width;\n\t\t\tmw->pending_g.height = ce->height;\n\t\t\tmw->pending_g.border_width = ce->border_width;\n\t\t\twin_set_flags(mw, WIN_FLAGS_SIZE_STALE);\n\t\t}\n\n\t\t// Recalculate which screen this window is on\n\t\twin_update_screen(ps->xinerama_nscrs, ps->xinerama_scr_regs, mw);\n\t}\n\n\t// override_redirect flag cannot be changed after window creation, as far\n\t// as I know, so there's no point to re-match windows here.\n\tmw->a.override_redirect = ce->override_redirect;\n}", "path": "picom/src/event.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "yshui/picom", "stars": 3760, "license": "other", "language": "c", "size": 6050}
{"docstring": "/**\n  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down\n  * @param  USBx : Selected device\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;\n  HAL_Delay(3U);\n  \n  return HAL_OK;  \n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  USB_ReadPacket : read a packet from the Tx FIFO associated \n  *         with the EP/channel\n  * @param  USBx : Selected device  \n  * @param  src : source pointer\n  * @param  ch_ep_num : endpoint or host channel number\n  * @param  len : Number of bytes to read\n  * @param  dma: USB dma enabled or disabled \n  *          This parameter can be one of these values:\n  *           0 : DMA feature not used \n  *           1 : DMA feature used  \n  * @retval pointer to destination buffer\n  */\n", "func_signal": "void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)", "code": "{\n  uint32_t i=0U;\n  uint32_t count32b = (len + 3U) / 4U;\n  \n  for ( i = 0U; i < count32b; i++, dest += 4U )\n  {\n    *(__packed uint32_t *)dest = USBx_DFIFO(0U);\n    \n  }\n  return ((void *)dest);\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  DFU_GetState\n  *         Handles the DFU GETSTATE request.\n  * @param  pdev: device instance\n  * @retval None\n  */\n", "func_signal": "static void DFU_GetState(USBD_HandleTypeDef *pdev)", "code": "{\n USBD_DFU_HandleTypeDef   *hdfu;\n \n hdfu = (USBD_DFU_HandleTypeDef*) pdev->pClassData;\n \n  /* Return the current state of the DFU interface */\n  USBD_CtlSendData (pdev, \n                    &hdfu->dev_state,\n                    1);  \n}", "path": "inav/lib/main/STM32F4/Middlewares/ST/STM32_USB_Device_Library/Class/DFU/Src/usbd_dfu.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  USB_DriveVbus : activate or de-activate vbus\n  * @param  state : VBUS state\n  *          This parameter can be one of these values:\n  *           0 : VBUS Active \n  *           1 : VBUS Inactive\n  * @retval HAL status\n*/\n", "func_signal": "HAL_StatusTypeDef USB_DriveVbus (USB_OTG_GlobalTypeDef *USBx, uint8_t state)", "code": "{\n  __IO uint32_t hprt0;\n\n  hprt0 = USBx_HPRT0;\n  hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\\\n                         USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );\n  \n  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))\n  {\n    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0); \n  }\n  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))\n  {\n    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0); \n  }\n  return HAL_OK; \n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  Halt a host channel\n  * @param  USBx : Selected device\n  * @param  hc_num : Host Channel number\n  *         This parameter can be a value from 1 to 15\n  * @retval HAL state\n  */\n", "func_signal": "HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num)", "code": "{\n  uint32_t count = 0U;\n  \n  /* Check for space in the request queue to issue the halt. */\n  if (((((USBx_HC(hc_num)->HCCHAR) & USB_OTG_HCCHAR_EPTYP) >> 18) == HCCHAR_CTRL) || (((((USBx_HC(hc_num)->HCCHAR) & \n  USB_OTG_HCCHAR_EPTYP) >> 18) == HCCHAR_BULK)))\n  {\n    USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;\n    \n    if ((USBx->HNPTXSTS & 0xFF0000U) == 0U)\n    {\n      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;\n      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  \n      do \n      {\n        if (++count > 1000U) \n        {\n          break;\n        }\n      } \n      while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     \n    }\n    else\n    {\n      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; \n    }\n  }\n  else\n  {\n    USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;\n    \n    if ((USBx_HOST->HPTXSTS & 0xFFFFU) == 0U)\n    {\n      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;\n      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  \n      do \n      {\n        if (++count > 1000U) \n        {\n          break;\n        }\n      } \n      while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     \n    }\n    else\n    {\n       USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; \n    }\n  }\n  \n  return HAL_OK;\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  Activate EP0 for Setup transactions\n  * @param  USBx : Selected device\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  /* Set the MPS of the IN EP based on the enumeration speed */\n  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;\n  \n  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)\n  {\n    USBx_INEP(0U)->DIEPCTL |= 3U;\n  }\n  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;\n\n  return HAL_OK;\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n* @brief  USBD_MSC_RegisterStorage\n* @param  fops: storage callback\n* @retval status\n*/\n", "func_signal": "uint8_t  USBD_DFU_RegisterMedia    (USBD_HandleTypeDef   *pdev, \n                                    USBD_DFU_MediaTypeDef *fops)", "code": "{\n  if(fops != NULL)\n  {\n    pdev->pUserData= fops;\n  }\n  return 0;\n}", "path": "inav/lib/main/STM32F4/Middlewares/ST/STM32_USB_Device_Library/Class/DFU/Src/usbd_dfu.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status\n  * @param  USBx : Selected device\n  * @retval HAL status\n  */\n", "func_signal": "uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  uint32_t v;\n  v  = USBx_DEVICE->DAINT;\n  v &= USBx_DEVICE->DAINTMSK;\n  return ((v & 0xFFFFU));\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  DFU_Upload\n  *         Handles the DFU UPLOAD request.\n  * @param  pdev: instance\n  * @param  req: pointer to the request structure\n  * @retval status\n  */\n", "func_signal": "static void DFU_Upload(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)", "code": "{\n USBD_DFU_HandleTypeDef   *hdfu;\n \n hdfu = (USBD_DFU_HandleTypeDef*) pdev->pClassData;\n \n  uint8_t *phaddr = NULL;\n  uint32_t addr = 0;\n  \n  /* Data setup request */\n  if (req->wLength > 0)\n  {\n    if ((hdfu->dev_state == DFU_STATE_IDLE) || (hdfu->dev_state == DFU_STATE_UPLOAD_IDLE))\n    {\n      /* Update the global length and block number */\n      hdfu->wblock_num = req->wValue;\n      hdfu->wlength = req->wLength;\n      \n      /* DFU Get Command */\n      if (hdfu->wblock_num == 0)  \n      {\n        /* Update the state machine */\n        hdfu->dev_state = (hdfu->wlength > 3)? DFU_STATE_IDLE:DFU_STATE_UPLOAD_IDLE;        \n    \n        hdfu->dev_status[1] = 0;\n        hdfu->dev_status[2] = 0;\n        hdfu->dev_status[3] = 0;\n        hdfu->dev_status[4] = hdfu->dev_state;       \n        \n        /* Store the values of all supported commands */\n        hdfu->buffer.d8[0] = DFU_CMD_GETCOMMANDS;\n        hdfu->buffer.d8[1] = DFU_CMD_SETADDRESSPOINTER;\n        hdfu->buffer.d8[2] = DFU_CMD_ERASE;\n        \n        /* Send the status data over EP0 */\n        USBD_CtlSendData (pdev,\n                          (uint8_t *)(&(hdfu->buffer.d8[0])),\n                          3);\n      }\n      else if (hdfu->wblock_num > 1)\n      {\n        hdfu->dev_state = DFU_STATE_UPLOAD_IDLE ;\n        \n        hdfu->dev_status[1] = 0;\n        hdfu->dev_status[2] = 0;\n        hdfu->dev_status[3] = 0;\n        hdfu->dev_status[4] = hdfu->dev_state;\n        \n        addr = ((hdfu->wblock_num - 2) * USBD_DFU_XFER_SIZE) + hdfu->data_ptr;  /* Change is Accelerated*/\n        \n        /* Return the physical address where data are stored */\n        phaddr =  ((USBD_DFU_MediaTypeDef *)pdev->pUserData)->Read((uint8_t *)addr, hdfu->buffer.d8, hdfu->wlength);  \n        \n        /* Send the status data over EP0 */\n        USBD_CtlSendData (pdev,\n                          phaddr,\n                          hdfu->wlength);\n      }\n      else  /* unsupported hdfu->wblock_num */\n      {\n        hdfu->dev_state = DFU_ERROR_STALLEDPKT;\n        \n        hdfu->dev_status[1] = 0;\n        hdfu->dev_status[2] = 0;\n        hdfu->dev_status[3] = 0;\n        hdfu->dev_status[4] = hdfu->dev_state;        \n        \n        /* Call the error management function (command will be nacked */\n        USBD_CtlError (pdev, req); \n      }\n    }\n    /* Unsupported state */\n    else\n    {\n      hdfu->wlength = 0;\n      hdfu->wblock_num = 0;   \n      /* Call the error management function (command will be nacked */\n      USBD_CtlError (pdev, req);\n    }\n  }\n  /* No Data setup request */\n  else\n  {\n    hdfu->dev_state = DFU_STATE_IDLE;\n     \n    hdfu->dev_status[1] = 0;\n    hdfu->dev_status[2] = 0;\n    hdfu->dev_status[3] = 0;\n    hdfu->dev_status[4] = hdfu->dev_state;\n  }\n}", "path": "inav/lib/main/STM32F4/Middlewares/ST/STM32_USB_Device_Library/Class/DFU/Src/usbd_dfu.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  DFU_GetStatus\n  *         Handles the DFU GETSTATUS request.\n  * @param  pdev: instance\n  * @retval status\n  */\n", "func_signal": "static void DFU_GetStatus(USBD_HandleTypeDef *pdev)", "code": "{\n USBD_DFU_HandleTypeDef   *hdfu;\n \n hdfu = (USBD_DFU_HandleTypeDef*) pdev->pClassData;\n \n  switch (hdfu->dev_state)\n  {\n  case   DFU_STATE_DNLOAD_SYNC:\n    if (hdfu->wlength != 0)\n    {\n      hdfu->dev_state = DFU_STATE_DNLOAD_BUSY;\n       \n      hdfu->dev_status[1] = 0;\n      hdfu->dev_status[2] = 0;\n      hdfu->dev_status[3] = 0;\n      hdfu->dev_status[4] = hdfu->dev_state;\n      \n      if ((hdfu->wblock_num == 0) && (hdfu->buffer.d8[0] == DFU_CMD_ERASE))\n      {\n        ((USBD_DFU_MediaTypeDef *)pdev->pUserData)->GetStatus(hdfu->data_ptr, DFU_MEDIA_ERASE, hdfu->dev_status);\n      }\n      else\n      {\n        ((USBD_DFU_MediaTypeDef *)pdev->pUserData)->GetStatus(hdfu->data_ptr, DFU_MEDIA_PROGRAM, hdfu->dev_status);\n      }\n    }\n    else  /* (hdfu->wlength==0)*/\n    {\n      hdfu->dev_state = DFU_STATE_DNLOAD_IDLE;\n\n      hdfu->dev_status[1] = 0;\n      hdfu->dev_status[2] = 0;\n      hdfu->dev_status[3] = 0;\n      hdfu->dev_status[4] = hdfu->dev_state;     \n    }\n    break;\n    \n  case   DFU_STATE_MANIFEST_SYNC :\n    if (hdfu->manif_state == DFU_MANIFEST_IN_PROGRESS)\n    {\n      hdfu->dev_state = DFU_STATE_MANIFEST;\n      \n      hdfu->dev_status[1] = 1;             /*bwPollTimeout = 1ms*/\n      hdfu->dev_status[2] = 0;\n      hdfu->dev_status[3] = 0;\n      hdfu->dev_status[4] = hdfu->dev_state;   \n    }\n    else if ((hdfu->manif_state == DFU_MANIFEST_COMPLETE) && \\\n      ((USBD_DFU_CfgDesc[(11 + (9 * USBD_DFU_MAX_ITF_NUM))]) & 0x04))\n    {\n      hdfu->dev_state = DFU_STATE_IDLE;\n      \n      hdfu->dev_status[1] = 0;\n      hdfu->dev_status[2] = 0;\n      hdfu->dev_status[3] = 0;\n      hdfu->dev_status[4] = hdfu->dev_state;      \n    }\n    break;\n    \n  default :\n    break;\n  }\n  \n  /* Send the status data over EP0 */\n  USBD_CtlSendData (pdev,\n                    (uint8_t *)(&(hdfu->dev_status[0])),\n                    6);\n}", "path": "inav/lib/main/STM32F4/Middlewares/ST/STM32_USB_Device_Library/Class/DFU/Src/usbd_dfu.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  DFU_Leave\n  *         Handles the sub-protocol DFU leave DFU mode request (leaves DFU mode\n  *         and resets device to jump to user loaded code).\n  * @param  pdev: device instance\n  * @retval None\n  */\n", "func_signal": "void DFU_Leave(USBD_HandleTypeDef *pdev)", "code": "{\n USBD_DFU_HandleTypeDef   *hdfu;\n \n hdfu = (USBD_DFU_HandleTypeDef*) pdev->pClassData;\n \n hdfu->manif_state = DFU_MANIFEST_COMPLETE;\n\n  if ((USBD_DFU_CfgDesc[(11 + (9 * USBD_DFU_MAX_ITF_NUM))]) & 0x04)\n  {\n    hdfu->dev_state = DFU_STATE_MANIFEST_SYNC;\n\n    hdfu->dev_status[1] = 0;\n    hdfu->dev_status[2] = 0;\n    hdfu->dev_status[3] = 0;\n    hdfu->dev_status[4] = hdfu->dev_state;       \n    return;\n  }\n  else\n  {\n    \n    hdfu->dev_state = DFU_STATE_MANIFEST_WAIT_RESET;\n    \n    hdfu->dev_status[1] = 0;\n    hdfu->dev_status[2] = 0;\n    hdfu->dev_status[3] = 0;\n    hdfu->dev_status[4] = hdfu->dev_state;     \n    \n    /* Disconnect the USB device */\n    USBD_Stop (pdev);\n\n    /* DeInitilialize the MAL(Media Access Layer) */\n    ((USBD_DFU_MediaTypeDef *)pdev->pUserData)->DeInit();\n    \n    /* Generate system reset to allow jumping to the user code */\n    NVIC_SystemReset();\n   \n    /* This instruction will not be reached (system reset) */\n    for(;;);\n  }  \n}", "path": "inav/lib/main/STM32F4/Middlewares/ST/STM32_USB_Device_Library/Class/DFU/Src/usbd_dfu.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  USB_EPStartXfer : setup and starts a transfer over an EP\n  * @param  USBx : Selected device\n  * @param  ep: pointer to endpoint structure\n  * @param  dma: USB dma enabled or disabled \n  *          This parameter can be one of these values:\n  *           0 : DMA feature not used \n  *           1 : DMA feature used  \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)", "code": "{\n  uint16_t pktcnt = 0U;\n  \n  /* IN endpoint */\n  if (ep->is_in == 1U)\n  {\n    /* Zero Length Packet? */\n    if (ep->xfer_len == 0U)\n    {\n      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); \n      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;\n      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); \n    }\n    else\n    {\n      /* Program the transfer size and packet count\n      * as follows: xfersize = N * maxpacket +\n      * short_packet pktcnt = N + (short_packet\n      * exist ? 1 : 0)\n      */\n      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);\n      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); \n      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;\n      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); \n      \n      if (ep->type == EP_TYPE_ISOC)\n      {\n        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); \n        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); \n      }       \n    }\n\n    if (dma == 1U)\n    {\n      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);\n    }\n    else\n    {\n      if (ep->type != EP_TYPE_ISOC)\n      {\n        /* Enable the Tx FIFO Empty Interrupt for this EP */\n        if (ep->xfer_len > 0U)\n        {\n          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;\n        }\n      }\n    }\n\n    if (ep->type == EP_TYPE_ISOC)\n    {\n      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)\n      {\n        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;\n      }\n      else\n      {\n        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;\n      }\n    } \n    \n    /* EP enable, IN data in FIFO */\n    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);\n    \n    if (ep->type == EP_TYPE_ISOC)\n    {\n      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   \n    }    \n  }\n  else /* OUT endpoint */\n  {\n    /* Program the transfer size and packet count as follows:\n    * pktcnt = N\n    * xfersize = N * maxpacket\n    */  \n    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); \n    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); \n\n    if (ep->xfer_len == 0U)\n    {\n      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);\n      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));\n    }\n    else\n    {\n      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; \n      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));\n      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));\n    }\n\n    if (dma == 1U)\n    {\n      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;\n    }\n    \n    if (ep->type == EP_TYPE_ISOC)\n    {\n      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)\n      {\n        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;\n      }\n      else\n      {\n        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;\n      }\n    }\n    /* EP enable */\n    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);\n  }\n  return HAL_OK;\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  Activate and configure a dedicated endpoint\n  * @param  USBx : Selected device\n  * @param  ep: pointer to endpoint structure\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)", "code": "{\n  static __IO uint32_t debug = 0U;\n  \n  /* Read DEPCTLn register */\n  if (ep->is_in == 1U)\n  {\n    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)\n    {\n      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\\\n        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); \n    } \n    \n    \n    debug  |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\\\n        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); \n    \n   USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));\n  }\n  else\n  {\n    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)\n    {\n      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\\\n        ((ep->num) << 22U) | (USB_OTG_DOEPCTL_USBAEP));\n      \n      debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0U)*USB_OTG_EP_REG_SIZE);\n      debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;\n      debug |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\\\n        ((ep->num) << 22U) | (USB_OTG_DOEPCTL_USBAEP)); \n    } \n    \n     USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);\n  }\n\n  return HAL_OK;\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  De-activate and de-initialize a dedicated endpoint\n  * @param  USBx : Selected device\n  * @param  ep: pointer to endpoint structure\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)", "code": "{\n  uint32_t count = 0U;\n  \n  /* Disable the IN endpoint */\n  if (ep->is_in == 1U)\n  {\n    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_USBAEP;  \n    \n    /* sets the NAK bit for the IN endpoint */\n    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;\n    \n    /* Disable IN endpoint */\n    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS;\n    \n    do\n    {\n      if (++count > 200000U)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n    \n    /*Wait for  EPDISD endpoint disabled interrupt*/ \n    while ((USBx_INEP(ep->num)->DIEPINT & USB_OTG_DIEPCTL_EPDIS) == USB_OTG_DIEPCTL_EPDIS);\n    \n    \n    /* Flush any data remaining in the TxFIFO */\n    USB_FlushTxFifo(USBx , 0x10U);\n    \n    /* Disable endpoint interrupts */\n    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   \n  \n  }\n  else /* Disable the OUT endpoint */\n  {\n    \n    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;  \n    \n    /* sets the NAK bit for the OUT endpoint */\n    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;\n    \n    /* Disable OUT endpoint */\n    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS;\n    \n    do\n    {\n      if (++count > 200000U)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n    \n    /*Wait for  EPDISD endpoint disabled interrupt*/ \n    while ((USBx_OUTEP(ep->num)->DOEPINT & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS);\n    \n    /* Set the \"Clear the Global OUT NAK bit\" to disable global OUT NAK mode */\n    USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;\n    \n    /* Disable endpoint interrupts */\n    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         \n  }\n  return HAL_OK;\n\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  Returns Device OUT EP Interrupt register\n  * @param  USBx : Selected device\n  * @param  epnum : endpoint number\n  *          This parameter can be a value from 0 to 15\n  * @retval Device OUT EP Interrupt register\n  */\n", "func_signal": "uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)", "code": "{\n  uint32_t v;\n  v  = USBx_OUTEP(epnum)->DOEPINT;\n  v &= USBx_DEVICE->DOEPMSK;\n  return v;\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  USB_GetDevSpeed :Return the  Dev Speed \n  * @param  USBx : Selected device\n  * @retval speed : device speed\n  *          This parameter can be one of these values:\n  *            @arg USB_OTG_SPEED_HIGH: High speed mode\n  *            @arg USB_OTG_SPEED_FULL: Full speed mode\n  *            @arg USB_OTG_SPEED_LOW: Low speed mode\n  */\n", "func_signal": "uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  uint8_t speed = 0U;\n  \n  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)\n  {\n    speed = USB_OTG_SPEED_HIGH;\n  }\n  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||\n           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))\n  {\n    speed = USB_OTG_SPEED_FULL;\n  }\n  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)\n  {\n    speed = USB_OTG_SPEED_LOW;\n  }\n  \n  return speed;\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  USB_StopDevice : Stop the usb device mode\n  * @param  USBx : Selected device\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)", "code": "{\n  uint32_t i;\n  \n  /* Clear Pending interrupt */\n  for (i = 0U; i < 15U ; i++)\n  {\n    USBx_INEP(i)->DIEPINT  = 0xFFU;\n    USBx_OUTEP(i)->DOEPINT  = 0xFFU;\n  }\n  USBx_DEVICE->DAINT = 0xFFFFFFFFU;\n  \n  /* Clear interrupt masks */\n  USBx_DEVICE->DIEPMSK  = 0U;\n  USBx_DEVICE->DOEPMSK  = 0U;\n  USBx_DEVICE->DAINTMSK = 0U;\n  \n  /* Flush the FIFO */\n  USB_FlushRxFifo(USBx);\n  USB_FlushTxFifo(USBx ,  0x10U);  \n  \n  return HAL_OK;\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  Initiate Do Ping protocol\n  * @param  USBx : Selected device\n  * @param  hc_num : Host Channel number\n  *         This parameter can be a value from 1 to 15\n  * @retval HAL state\n  */\n", "func_signal": "HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx , uint8_t ch_num)", "code": "{\n  uint8_t  num_packets = 1U;\n  uint32_t tmpreg = 0U;\n\n  USBx_HC(ch_num)->HCTSIZ = ((num_packets << 19U) & USB_OTG_HCTSIZ_PKTCNT) |\\\n                                USB_OTG_HCTSIZ_DOPING;\n  \n  /* Set host channel enable */\n  tmpreg = USBx_HC(ch_num)->HCCHAR;\n  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;\n  tmpreg |= USB_OTG_HCCHAR_CHENA;\n  USBx_HC(ch_num)->HCCHAR = tmpreg;\n  \n  return HAL_OK;  \n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  USB_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the \n  *         HCFG register on the PHY type and set the right frame interval\n  * @param  USBx : Selected device\n  * @param  freq : clock frequency\n  *          This parameter can be one of these values:\n  *           HCFG_48_MHZ : Full Speed 48 MHz Clock \n  *           HCFG_6_MHZ : Low Speed 6 MHz Clock \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq)", "code": "{\n  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);\n  USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);\n  \n  if (freq ==  HCFG_48_MHZ)\n  {\n    USBx_HOST->HFIR = 48000U;\n  }\n  else if (freq ==  HCFG_6_MHZ)\n  {\n    USBx_HOST->HFIR = 6000U;\n  } \n  return HAL_OK;  \n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/**\n  * @brief  USB_DevInit : Initializes the USB_OTG controller registers \n  *         for device mode\n  * @param  USBx : Selected device\n  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains\n  *         the configuration information for the specified USBx peripheral.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)", "code": "{\n  uint32_t i = 0U;\n\n  /*Activate VBUS Sensing B */\n#if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \\\n    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\n  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;\n  \n  if (cfg.vbus_sensing_enable == 0U)\n  {\n    /* Deactivate VBUS Sensing B */\n    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;\n    \n    /* B-peripheral session valid override enable*/ \n    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;\n    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;\n  }\n#else\n  if (cfg.vbus_sensing_enable == 0U)\n  {\n    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;\n  }\n  else\n  {\n    /* Enable VBUS */\n    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;\n  }\n#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx || STM32F413xx || STM32F423xx  */\n  \n  /* Restart the Phy Clock */\n  USBx_PCGCCTL = 0U;\n  \n  /* Device mode configuration */\n  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;\n  \n  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)\n  {\n    if(cfg.speed == USB_OTG_SPEED_HIGH)\n    {      \n      /* Set High speed phy */\n      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);\n    }\n    else \n    {\n      /* set High speed phy in Full speed mode */\n      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);\n    }\n  }\n  else\n  {\n    /* Set Full speed phy */\n    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);\n  }\n\n  /* Flush the FIFOs */\n  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */\n  USB_FlushRxFifo(USBx);\n  \n  /* Clear all pending Device Interrupts */\n  USBx_DEVICE->DIEPMSK = 0U;\n  USBx_DEVICE->DOEPMSK = 0U;\n  USBx_DEVICE->DAINT = 0xFFFFFFFFU;\n  USBx_DEVICE->DAINTMSK = 0U;\n  \n  for (i = 0U; i < cfg.dev_endpoints; i++)\n  {\n    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)\n    {\n      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);\n    }\n    else\n    {\n      USBx_INEP(i)->DIEPCTL = 0U;\n    }\n    \n    USBx_INEP(i)->DIEPTSIZ = 0U;\n    USBx_INEP(i)->DIEPINT  = 0xFFU;\n  }\n  \n  for (i = 0U; i < cfg.dev_endpoints; i++)\n  {\n    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)\n    {\n      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);\n    }\n    else\n    {\n      USBx_OUTEP(i)->DOEPCTL = 0U;\n    }\n    \n    USBx_OUTEP(i)->DOEPTSIZ = 0U;\n    USBx_OUTEP(i)->DOEPINT  = 0xFFU;\n  }\n  \n  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);\n  \n  if (cfg.dma_enable == 1U)\n  {\n    /*Set threshold parameters */\n    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);\n    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);\n    \n    i= USBx_DEVICE->DTHRCTL;\n  }\n  \n  /* Disable all interrupts. */\n  USBx->GINTMSK = 0U;\n  \n  /* Clear any pending interrupts */\n  USBx->GINTSTS = 0xBFFFFFFFU;\n\n  /* Enable the common interrupts */\n  if (cfg.dma_enable == DISABLE)\n  {\n    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; \n  }\n  \n  /* Enable interrupts matching to the Device mode ONLY */\n  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\\\n                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\\\n                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\\\n                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);\n  \n  if(cfg.Sof_enable)\n  {\n    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;\n  }\n\n  if (cfg.vbus_sensing_enable == ENABLE)\n  {\n    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); \n  }\n  \n  return HAL_OK;\n}", "path": "inav/lib/main/STM32F4/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c", "commit_date": "2017-09-28 00:00:00", "repo_name": "iNavFlight/inav", "stars": 2801, "license": "gpl-3.0", "language": "c", "size": 275019}
{"docstring": "/*\n * Parses a HTTP request for the Host: header\n *\n * Returns:\n *  >=0  - length of the hostname and updates *hostname\n *         caller is responsible for freeing *hostname\n *  -1   - Incomplete request\n *  -2   - No Host header included in this request\n *  -3   - Invalid hostname pointer\n *  -4   - malloc failure\n *  < -4 - Invalid HTTP request\n *\n */\n", "func_signal": "static int\nparse_http_header(const char* data, size_t data_len, char **hostname)", "code": "{\n    int result, i;\n\n    if (hostname == NULL)\n        return -3;\n\n    result = get_header(\"Host:\", data, data_len, hostname);\n    if (result < 0)\n        return result;\n\n    /*\n     *  if the user specifies the port in the request, it is included here.\n     *  Host: example.com:80\n     *  Host: [2001:db8::1]:8080\n     *  so we trim off port portion\n     */\n    for (i = result - 1; i >= 0; i--)\n        if ((*hostname)[i] == ':') {\n            (*hostname)[i] = '\\0';\n            result = i;\n            break;\n        } else if (!isdigit((*hostname)[i])) {\n            break;\n        }\n\n    return result;\n}", "path": "sniproxy/src/http.c", "commit_date": "2020-11-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/**\n * Raise file handle limit to reasonable level\n * At some point we should make this a config parameter\n */\n", "func_signal": "static void\nset_limits(rlim_t max_nofiles)", "code": "{\n    struct rlimit fd_limit = {\n        .rlim_cur = max_nofiles,\n        .rlim_max = max_nofiles,\n    };\n\n    int result = setrlimit(RLIMIT_NOFILE, &fd_limit);\n    if (result < 0)\n        warn(\"Failed to set file handle limit: %s\", strerror(errno));\n}", "path": "sniproxy/src/sniproxy.c", "commit_date": "2018-01-02 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Test is client socket is open\n *\n * Returns true iff the client socket is opened based on connection state.\n */\n", "func_signal": "static inline int\nclient_socket_open(const struct Connection *con)", "code": "{\n    return con->state == ACCEPTED ||\n        con->state == PARSED ||\n        con->state == RESOLVING ||\n        con->state == RESOLVED ||\n        con->state == CONNECTED ||\n        con->state == SERVER_CLOSED;\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Listener reference counting\n *\n * Since when reloading the configuration a listener with active connections\n * could be removed and connections require a reference to to the listener on\n * which they where received we need to allow listeners to linger outside the\n * listeners list in the active configuration, and free them when their last\n * connection closes.\n *\n * Accomplishing this with reference counting: membership in a Config listener\n * list counts as one as does each connection.\n */\n", "func_signal": "void\nlistener_ref_put(struct Listener *listener)", "code": "{\n    if (listener == NULL)\n        return;\n\n    assert(listener->reference_count > 0);\n    listener->reference_count--;\n    if (listener->reference_count == 0)\n        free_listener(listener);\n}", "path": "sniproxy/src/listener.c", "commit_date": "2018-12-07 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Setup a struct iovec iov[2] for a write to a buffer.\n * struct iovec *iov MUST be at least length 2.\n * returns the number of entries setup\n */\n", "func_signal": "static size_t\nsetup_write_iov(const struct Buffer *buffer, struct iovec *iov, size_t len)", "code": "{\n    size_t room = buffer_size(buffer) - buffer->len;\n\n    if (room == 0) /* trivial case: no room */\n        return 0;\n\n    size_t write_len = room;\n    /* Allow caller to specify maximum length */\n    if (len != 0)\n        write_len = MIN(room, len);\n\n    size_t start = (buffer->head + buffer->len) & buffer->size_mask;\n\n    if (start + write_len <= buffer_size(buffer)) {\n        iov[0].iov_base = buffer->buffer + start;\n        iov[0].iov_len = write_len;\n\n        /* assert iov are within bounds, non-zero length and non-overlapping */\n        assert(iov[0].iov_len > 0);\n        assert((char *)iov[0].iov_base >= buffer->buffer);\n        assert((char *)iov[0].iov_base + iov[0].iov_len <= buffer->buffer + buffer_size(buffer));\n\n        return 1;\n    } else {\n        iov[0].iov_base = buffer->buffer + start;\n        iov[0].iov_len = buffer_size(buffer) - start;\n        iov[1].iov_base = buffer->buffer;\n        iov[1].iov_len = write_len - iov[0].iov_len;\n\n        /* assert iov are within bounds, non-zero length and non-overlapping */\n        assert(iov[0].iov_len > 0);\n        assert((char *)iov[0].iov_base >= buffer->buffer);\n        assert((char *)iov[0].iov_base + iov[0].iov_len <= buffer->buffer + buffer_size(buffer));\n        assert(iov[1].iov_len > 0);\n        assert((char *)iov[1].iov_base >= buffer->buffer);\n        assert((char *)iov[1].iov_base + iov[1].iov_len <= (char *)iov[0].iov_base);\n\n        return 2;\n    }\n}", "path": "sniproxy/src/buffer.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/* Close server socket.\n * Caller must ensure that it has not been closed before.\n */\n", "func_signal": "static void\nclose_server_socket(struct Connection *con, struct ev_loop *loop)", "code": "{\n    assert(con->state != CLOSED\n            && con->state != SERVER_CLOSED);\n\n    ev_io_stop(loop, &con->server.watcher);\n\n    if (close(con->server.watcher.fd) < 0)\n        warn(\"close failed: %s\", strerror(errno));\n\n    /* next state depends on previous state */\n    if (con->state == CLIENT_CLOSED)\n        con->state = CLOSED;\n    else\n        con->state = SERVER_CLOSED;\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/* dumps a list of all connections for debugging */\n", "func_signal": "void\nprint_connections()", "code": "{\n    char filename[] = \"/tmp/sniproxy-connections-XXXXXX\";\n\n    int fd = mkstemp(filename);\n    if (fd < 0) {\n        warn(\"mkstemp failed: %s\", strerror(errno));\n        return;\n    }\n\n    FILE *temp = fdopen(fd, \"w\");\n    if (temp == NULL) {\n        warn(\"fdopen failed: %s\", strerror(errno));\n        return;\n    }\n\n    fprintf(temp, \"Running connections:\\n\");\n    struct Connection *iter;\n    TAILQ_FOREACH(iter, &connections, entries)\n        print_connection(temp, iter);\n\n    if (fclose(temp) < 0)\n        warn(\"fclose failed: %s\", strerror(errno));\n\n    notice(\"Dumped connections to %s\", filename);\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Insert an additional listener in to the sorted list of listeners\n */\n", "func_signal": "void\nadd_listener(struct Listener_head *listeners, struct Listener *listener)", "code": "{\n    assert(listeners != NULL);\n    assert(listener != NULL);\n    assert(listener->address != NULL);\n    listener_ref_get(listener);\n\n    if (SLIST_FIRST(listeners) == NULL ||\n            address_compare(listener->address, SLIST_FIRST(listeners)->address) < 0) {\n        SLIST_INSERT_HEAD(listeners, listener, entries);\n        return;\n    }\n\n    struct Listener *iter;\n    SLIST_FOREACH(iter, listeners, entries) {\n        if (SLIST_NEXT(iter, entries) == NULL ||\n                address_compare(listener->address, SLIST_NEXT(iter, entries)->address) < 0) {\n            SLIST_INSERT_AFTER(iter, listener, entries);\n            return;\n        }\n    }\n}", "path": "sniproxy/src/listener.c", "commit_date": "2018-12-07 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/* Close client socket.\n * Caller must ensure that it has not been closed before.\n */\n", "func_signal": "static void\nclose_client_socket(struct Connection *con, struct ev_loop *loop)", "code": "{\n    assert(con->state != CLOSED\n            && con->state != CLIENT_CLOSED);\n\n    ev_io_stop(loop, &con->client.watcher);\n\n    if (close(con->client.watcher.fd) < 0)\n        warn(\"close failed: %s\", strerror(errno));\n\n    if (con->state == RESOLVING) {\n        resolv_cancel(con->query_handle);\n        con->state = PARSED;\n    }\n\n    /* next state depends on previous state */\n    if (con->state == SERVER_CLOSED\n            || con->state == ACCEPTED\n            || con->state == PARSED\n            || con->state == RESOLVING\n            || con->state == RESOLVED)\n        con->state = CLOSED;\n    else\n        con->state = CLIENT_CLOSED;\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * next_token() returns the next token based on the current position of\n * configuration file advancing the position to immediately after the token.\n */\n", "func_signal": "enum Token\nnext_token(FILE *config, char *buffer, size_t buffer_len)", "code": "{\n    int ch;\n    int token_len;\n\n    while ((ch = getc(config)) != EOF) {\n        switch (ch) {\n            case ' ':\n                /* fall through */\n            case '\\t':\n                /* no op */\n                break;\n            case '#': /* comment */\n                chomp_line(config);\n                /* fall through */\n            case ';':\n                /* fall through */\n            case '\\n':\n                /* fall through */\n            case '\\r':\n                return TOKEN_EOL;\n            case '{':\n                return TOKEN_OBRACE;\n            case '}':\n                return TOKEN_CBRACE;\n            default:\n                /* Rewind one byte, so next_word() can fetch from\n                 * the beginning of the word */\n                fseek(config, -1, SEEK_CUR);\n\n                token_len = next_word(config, buffer, buffer_len);\n                if (token_len <= 0)\n                    return TOKEN_ERROR;\n\n                return TOKEN_WORD;\n        }\n    }\n    return TOKEN_END;\n}", "path": "sniproxy/src/cfg_tokenizer.c", "commit_date": "2013-11-14 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Initialize each listener.\n */\n", "func_signal": "void\ninit_listeners(struct Listener_head *listeners,\n        const struct Table_head *tables, struct ev_loop *loop)", "code": "{\n    struct Listener *iter;\n    char address[ADDRESS_BUFFER_SIZE];\n\n    SLIST_FOREACH(iter, listeners, entries) {\n        if (init_listener(iter, tables, loop) < 0) {\n            err(\"Failed to initialize listener %s\",\n                    display_address(iter->address, address, sizeof(address)));\n            exit(1);\n        }\n    }\n}", "path": "sniproxy/src/listener.c", "commit_date": "2018-12-07 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Main client callback: this is used by both the client and server watchers\n *\n * The logic is almost the same except for:\n *  + input buffer\n *  + output buffer\n *  + how to close the socket\n *\n */\n", "func_signal": "static void\nconnection_cb(struct ev_loop *loop, struct ev_io *w, int revents)", "code": "{\n    struct Connection *con = (struct Connection *)w->data;\n    int is_client = &con->client.watcher == w;\n    const char *socket_name =\n        is_client ? \"client\" : \"server\";\n    struct Buffer *input_buffer =\n        is_client ? con->client.buffer : con->server.buffer;\n    struct Buffer *output_buffer =\n        is_client ? con->server.buffer : con->client.buffer;\n    void (*close_socket)(struct Connection *, struct ev_loop *) =\n        is_client ? close_client_socket : close_server_socket;\n\n    /* Receive first in case the socket was closed */\n    if (revents & EV_READ && buffer_room(input_buffer)) {\n        ssize_t bytes_received = buffer_recv(input_buffer, w->fd, 0, loop);\n        if (bytes_received < 0 && !IS_TEMPORARY_SOCKERR(errno)) {\n            warn(\"recv(%s): %s, closing connection\",\n                    socket_name,\n                    strerror(errno));\n\n            close_socket(con, loop);\n            revents = 0; /* Clear revents so we don't try to send */\n        } else if (bytes_received == 0) { /* peer closed socket */\n            close_socket(con, loop);\n            revents = 0;\n        }\n    }\n\n    /* Transmit */\n    if (revents & EV_WRITE && buffer_len(output_buffer)) {\n        ssize_t bytes_transmitted = buffer_send(output_buffer, w->fd, 0, loop);\n        if (bytes_transmitted < 0 && !IS_TEMPORARY_SOCKERR(errno)) {\n            warn(\"send(%s): %s, closing connection\",\n                    socket_name,\n                    strerror(errno));\n\n            close_socket(con, loop);\n        }\n    }\n\n    /* Handle any state specific logic, note we may transition through several\n     * states during a single call */\n    if (is_client && con->state == ACCEPTED)\n        parse_client_request(con);\n    if (is_client && con->state == PARSED)\n        resolve_server_address(con, loop);\n    if (is_client && con->state == RESOLVED)\n        initiate_server_connect(con, loop);\n\n    /* Close other socket if we have flushed corresponding buffer */\n    if (con->state == SERVER_CLOSED && buffer_len(con->server.buffer) == 0)\n        close_client_socket(con, loop);\n    if (con->state == CLIENT_CLOSED && buffer_len(con->client.buffer) == 0)\n        close_server_socket(con, loop);\n\n    if (con->state == CLOSED) {\n        TAILQ_REMOVE(&connections, con, entries);\n\n        if (con->listener->access_log)\n            log_connection(con);\n\n        free_connection(con);\n        return;\n    }\n\n    reactivate_watchers(con, loop);\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Close and free all connections\n */\n", "func_signal": "void\nfree_connections(struct ev_loop *loop)", "code": "{\n    struct Connection *iter;\n    while ((iter = TAILQ_FIRST(&connections)) != NULL) {\n        TAILQ_REMOVE(&connections, iter, entries);\n        close_connection(iter, loop);\n        free_connection(iter);\n    }\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Test is server socket is open\n *\n * Returns true iff the server socket is opened based on connection state.\n */\n", "func_signal": "static inline int\nserver_socket_open(const struct Connection *con)", "code": "{\n    return con->state == CONNECTED ||\n        con->state == CLIENT_CLOSED;\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Allocate a new server address trying:\n *      1. lookup name in table for hostname or socket address\n *      2. lookup name in table for a wildcard address, then create a new\n *         address based on the request hostname (if valid)\n *      3. use the fallback address\n */\n", "func_signal": "struct LookupResult\nlistener_lookup_server_address(const struct Listener *listener,\n        const char *name, size_t name_len)", "code": "{\n    struct LookupResult table_result =\n        table_lookup_server_address(listener->table, name, name_len);\n\n    if (table_result.address == NULL) {\n        /* No match in table, use fallback address if present */\n        return (struct LookupResult){\n            .address = listener->fallback_address,\n            .use_proxy_header = listener->fallback_use_proxy_header\n        };\n    } else if (address_is_wildcard(table_result.address)) {\n        /* Wildcard table entry, create a new address from hostname */\n        struct Address *new_addr = new_address(name);\n        if (new_addr == NULL) {\n            warn(\"Invalid hostname %.*s in client request\",\n                    (int)name_len, name);\n\n            return (struct LookupResult){\n                .address = listener->fallback_address,\n                .use_proxy_header = listener->fallback_use_proxy_header\n            };\n        } else if (address_is_sockaddr(new_addr)) {\n            warn(\"Refusing to proxy to socket address literal %.*s in request\",\n                    (int)name_len, name);\n            free(new_addr);\n\n            return (struct LookupResult){\n                .address = listener->fallback_address,\n                .use_proxy_header = listener->fallback_use_proxy_header\n            };\n        }\n\n        /* We created a valid new_addr, use the port from wildcard address if\n         * present otherwise the listener */\n        address_set_port(new_addr, address_port(table_result.address) != 0 ?\n                                   address_port(table_result.address) :\n                                   address_port(listener->address));\n\n\n        return (struct LookupResult){\n            .address = new_addr,\n            .caller_free_address = 1,\n            .use_proxy_header = table_result.use_proxy_header\n        };\n    } else if (address_port(table_result.address) == 0) {\n        /* If the server port isn't specified return a new address using the\n         * port from the listen, this allows sharing table across listeners */\n        struct Address *new_addr = copy_address(table_result.address);\n\n        address_set_port(new_addr, address_port(listener->address));\n\n        return (struct LookupResult){\n            .address = new_addr,\n            .caller_free_address = 1,\n            .use_proxy_header = table_result.use_proxy_header\n        };\n    } else {\n        return table_result;\n    }\n}", "path": "sniproxy/src/listener.c", "commit_date": "2018-12-07 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/**\n * Accept a new incoming connection\n *\n * Returns 1 on success or 0 on error;\n */\n", "func_signal": "int\naccept_connection(struct Listener *listener, struct ev_loop *loop)", "code": "{\n    struct Connection *con = new_connection(loop);\n    if (con == NULL) {\n        err(\"new_connection failed\");\n        return 0;\n    }\n    con->listener = listener_ref_get(listener);\n\n#ifdef HAVE_ACCEPT4\n    int sockfd = accept4(listener->watcher.fd,\n                    (struct sockaddr *)&con->client.addr,\n                    &con->client.addr_len,\n                    SOCK_NONBLOCK);\n#else\n    int sockfd = accept(listener->watcher.fd,\n                    (struct sockaddr *)&con->client.addr,\n                    &con->client.addr_len);\n#endif\n    if (sockfd < 0) {\n        int saved_errno = errno;\n\n        warn(\"accept failed: %s\", strerror(errno));\n        free_connection(con);\n\n        errno = saved_errno;\n        return 0;\n    }\n\n#ifndef HAVE_ACCEPT4\n    int flags = fcntl(sockfd, F_GETFL, 0);\n    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n#endif\n\n    if (getsockname(sockfd, (struct sockaddr *)&con->client.local_addr,\n                &con->client.local_addr_len) != 0) {\n        int saved_errno = errno;\n\n        warn(\"getsockname failed: %s\", strerror(errno));\n        free_connection(con);\n\n        errno = saved_errno;\n        return 0;\n    }\n\n    /* Avoiding type-punned pointer warning */\n    struct ev_io *client_watcher = &con->client.watcher;\n    ev_io_init(client_watcher, connection_cb, sockfd, EV_READ);\n    con->client.watcher.data = con;\n    con->state = ACCEPTED;\n    con->established_timestamp = ev_now(loop);\n\n    TAILQ_INSERT_HEAD(&connections, con, entries);\n\n    ev_io_start(loop, client_watcher);\n\n    if (con->listener->table->use_proxy_header ||\n            con->listener->fallback_use_proxy_header)\n        insert_proxy_v1_header(con);\n\n    return 1;\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Coalesce a buffer into a single continuous region, optionally returning a\n * pointer to that region.\n *\n * Returns the size of the buffer contents\n */\n", "func_signal": "size_t\nbuffer_coalesce(struct Buffer *buffer, const void **dst)", "code": "{\n    size_t buffer_tail = (buffer->head + buffer->len) & buffer->size_mask;\n\n    if (buffer_tail <= buffer->head) {\n        /* buffer not wrapped */\n        if (dst != NULL)\n            *dst = &buffer->buffer[buffer->head];\n\n        return buffer->len;\n    } else {\n        /* buffer wrapped */\n        size_t len = buffer->len;\n        char *temp = malloc(len);\n        if (temp != NULL) {\n            buffer_pop(buffer, temp, len);\n            assert(buffer->len == 0);\n\n            buffer_push(buffer, temp, len);\n            assert(buffer->head == 0);\n            assert(buffer->len == len);\n\n            free(temp);\n        }\n\n        if (dst != NULL)\n            *dst = buffer->buffer;\n\n        return buffer->len;\n    }\n}", "path": "sniproxy/src/buffer.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Write data to file from buffer\n */\n", "func_signal": "ssize_t\nbuffer_write(struct Buffer *buffer, int fd)", "code": "{\n    struct iovec iov[2];\n    size_t iov_len = setup_read_iov(buffer, iov, 0);\n    ssize_t bytes = writev(fd, iov, iov_len);\n\n    if (bytes > 0)\n        advance_read_position(buffer, (size_t)bytes);\n\n    return bytes;\n}", "path": "sniproxy/src/buffer.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Free a connection and associated data\n *\n * Requires that no watchers remain active\n */\n", "func_signal": "static void\nfree_connection(struct Connection *con)", "code": "{\n    if (con == NULL)\n        return;\n\n    listener_ref_put(con->listener);\n    free_buffer(con->client.buffer);\n    free_buffer(con->server.buffer);\n    free((void *)con->hostname); /* cast away const'ness */\n    free(con);\n}", "path": "sniproxy/src/connection.c", "commit_date": "2018-12-08 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "/*\n * Copy contents of new_listener into existing listener\n */\n", "func_signal": "static void\nlistener_update(struct Listener *existing_listener, struct Listener *new_listener, const struct Table_head *tables)", "code": "{\n    assert(existing_listener != NULL);\n    assert(new_listener != NULL);\n    assert(address_compare(existing_listener->address, new_listener->address) == 0);\n\n    free(existing_listener->fallback_address);\n    existing_listener->fallback_address = new_listener->fallback_address;\n    new_listener->fallback_address = NULL;\n\n    free(existing_listener->source_address);\n    existing_listener->source_address = new_listener->source_address;\n    new_listener->source_address = NULL;\n\n    existing_listener->protocol = new_listener->protocol;\n\n    free(existing_listener->table_name);\n    existing_listener->table_name = new_listener->table_name;\n    new_listener->table_name = NULL;\n\n    logger_ref_put(existing_listener->access_log);\n    existing_listener->access_log = logger_ref_get(new_listener->access_log);\n\n    existing_listener->log_bad_requests = new_listener->log_bad_requests;\n\n    struct Table *new_table =\n            table_lookup(tables, existing_listener->table_name);\n\n    if (new_table != NULL) {\n        init_table(new_table);\n\n        table_ref_put(existing_listener->table);\n        existing_listener->table = table_ref_get(new_table);\n\n        table_ref_put(new_listener->table);\n        new_listener->table = NULL;\n    }\n}", "path": "sniproxy/src/listener.c", "commit_date": "2018-12-07 00:00:00", "repo_name": "dlundquist/sniproxy", "stars": 2448, "license": "bsd-2-clause", "language": "c", "size": 1107}
{"docstring": "// render stars\n", "func_signal": "static void stars_render(struct Sky *self, vec3s center, struct Texture tex)", "code": "{\n    if (self->state == DAY) {\n        return;\n    }\n\n    SRAND(0x57A125);\n\n    // compuet alpha: 1.0 during night, fade out/in during sunrise/sunset\n    const f32 a = self->state == NIGHT ? 1.0f :\n            (self->state == SUNRISE ?\n                lerpf(1.0f, 0.0f, self->sky_state_progress) :\n                lerpf(0.0f, 1.0f, self->sky_state_progress));\n\n    const f32 angle = (((f32) (self->world->ticks)) / TOTAL_DAY_TICKS) * TAU;\n\n    // TODO: do this via instanced rendering\n    for (size_t i = 0; i < 512; i++) {\n        const f32 angle_offset = radians((f32) RAND(0, 360)),\n            scale_offset = RAND(-1, 6) * 0.05f,\n            x_offset = RAND(-48, 48),\n            z_offset = RAND(-48, 48),\n            y_offset = RAND(-48, 48),\n            r_offset = RAND(-15, 0) / 100.0f,\n            g_offset = RAND(-15, 0) / 100.0f,\n            b_offset = RAND(-15, 0) / 100.0f;\n        \n        const u64 twinkle_rate = RAND(TICKRATE, TICKRATE * 2);\n        const f32\n            twinkle = RANDCHANCE(0.08) ?\n                (((f32) ((self->world->ticks + RAND(0, 100)) % twinkle_rate) / (f32) twinkle_rate) - 0.5f) * 0.25f :\n                0.0f;\n\n        mat4s m = glms_mat4_identity();\n        m = glms_translate(m, glms_vec3_add(center, (vec3s) {{ 0.0f, 0.0f, 0.0f }}));\n        m = glms_rotate(m, radians(-90.0f), (vec3s) {{ 0.0f, 1.0f, 0.0f }});\n        m = glms_rotate(m, angle + angle_offset, (vec3s) {{ 1.0f, -0.3f, 0.25f }});\n        m = glms_translate(m, (vec3s) {{ x_offset, y_offset, z_offset }});\n        m = glms_scale(m, (vec3s) {{ 0.4f + scale_offset, 0.4f + scale_offset, 0 }});\n\n        plane_render(\n            self, &tex,\n            (vec4s) {{\n                1.0f + r_offset,\n                1.0f + g_offset,\n                1.0f + b_offset,\n                a + twinkle\n            }}, m);\n    }\n}", "path": "minecraft-weekend/src/world/sky.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "//---------------------------------------------------------------------\n/** 4D float Perlin noise.\n */\n", "func_signal": "float noise4( float x, float y, float z, float w )", "code": "{\n    int ix0, iy0, iz0, iw0, ix1, iy1, iz1, iw1;\n    float fx0, fy0, fz0, fw0, fx1, fy1, fz1, fw1;\n    float s, t, r, q;\n    float nxyz0, nxyz1, nxy0, nxy1, nx0, nx1, n0, n1;\n\n    ix0 = FASTFLOOR( x ); // Integer part of x\n    iy0 = FASTFLOOR( y ); // Integer part of y\n    iz0 = FASTFLOOR( z ); // Integer part of y\n    iw0 = FASTFLOOR( w ); // Integer part of w\n    fx0 = x - ix0;        // Fractional part of x\n    fy0 = y - iy0;        // Fractional part of y\n    fz0 = z - iz0;        // Fractional part of z\n    fw0 = w - iw0;        // Fractional part of w\n    fx1 = fx0 - 1.0f;\n    fy1 = fy0 - 1.0f;\n    fz1 = fz0 - 1.0f;\n    fw1 = fw0 - 1.0f;\n    ix1 = ( ix0 + 1 ) & 0xff;  // Wrap to 0..255\n    iy1 = ( iy0 + 1 ) & 0xff;\n    iz1 = ( iz0 + 1 ) & 0xff;\n    iw1 = ( iw0 + 1 ) & 0xff;\n    ix0 = ix0 & 0xff;\n    iy0 = iy0 & 0xff;\n    iz0 = iz0 & 0xff;\n    iw0 = iw0 & 0xff;\n\n    q = FADE( fw0 );\n    r = FADE( fz0 );\n    t = FADE( fy0 );\n    s = FADE( fx0 );\n\n    nxyz0 = grad4(perm[ix0 + perm[iy0 + perm[iz0 + perm[iw0]]]], fx0, fy0, fz0, fw0);\n    nxyz1 = grad4(perm[ix0 + perm[iy0 + perm[iz0 + perm[iw1]]]], fx0, fy0, fz0, fw1);\n    nxy0 = LERP( q, nxyz0, nxyz1 );\n        \n    nxyz0 = grad4(perm[ix0 + perm[iy0 + perm[iz1 + perm[iw0]]]], fx0, fy0, fz1, fw0);\n    nxyz1 = grad4(perm[ix0 + perm[iy0 + perm[iz1 + perm[iw1]]]], fx0, fy0, fz1, fw1);\n    nxy1 = LERP( q, nxyz0, nxyz1 );\n        \n    nx0 = LERP ( r, nxy0, nxy1 );\n\n    nxyz0 = grad4(perm[ix0 + perm[iy1 + perm[iz0 + perm[iw0]]]], fx0, fy1, fz0, fw0);\n    nxyz1 = grad4(perm[ix0 + perm[iy1 + perm[iz0 + perm[iw1]]]], fx0, fy1, fz0, fw1);\n    nxy0 = LERP( q, nxyz0, nxyz1 );\n        \n    nxyz0 = grad4(perm[ix0 + perm[iy1 + perm[iz1 + perm[iw0]]]], fx0, fy1, fz1, fw0);\n    nxyz1 = grad4(perm[ix0 + perm[iy1 + perm[iz1 + perm[iw1]]]], fx0, fy1, fz1, fw1);\n    nxy1 = LERP( q, nxyz0, nxyz1 );\n\n    nx1 = LERP ( r, nxy0, nxy1 );\n\n    n0 = LERP( t, nx0, nx1 );\n\n    nxyz0 = grad4(perm[ix1 + perm[iy0 + perm[iz0 + perm[iw0]]]], fx1, fy0, fz0, fw0);\n    nxyz1 = grad4(perm[ix1 + perm[iy0 + perm[iz0 + perm[iw1]]]], fx1, fy0, fz0, fw1);\n    nxy0 = LERP( q, nxyz0, nxyz1 );\n        \n    nxyz0 = grad4(perm[ix1 + perm[iy0 + perm[iz1 + perm[iw0]]]], fx1, fy0, fz1, fw0);\n    nxyz1 = grad4(perm[ix1 + perm[iy0 + perm[iz1 + perm[iw1]]]], fx1, fy0, fz1, fw1);\n    nxy1 = LERP( q, nxyz0, nxyz1 );\n\n    nx0 = LERP ( r, nxy0, nxy1 );\n\n    nxyz0 = grad4(perm[ix1 + perm[iy1 + perm[iz0 + perm[iw0]]]], fx1, fy1, fz0, fw0);\n    nxyz1 = grad4(perm[ix1 + perm[iy1 + perm[iz0 + perm[iw1]]]], fx1, fy1, fz0, fw1);\n    nxy0 = LERP( q, nxyz0, nxyz1 );\n        \n    nxyz0 = grad4(perm[ix1 + perm[iy1 + perm[iz1 + perm[iw0]]]], fx1, fy1, fz1, fw0);\n    nxyz1 = grad4(perm[ix1 + perm[iy1 + perm[iz1 + perm[iw1]]]], fx1, fy1, fz1, fw1);\n    nxy1 = LERP( q, nxyz0, nxyz1 );\n\n    nx1 = LERP ( r, nxy0, nxy1 );\n\n    n1 = LERP( t, nx0, nx1 );\n\n    return 0.87f * ( LERP( s, n0, n1 ) );\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "//---------------------------------------------------------------------\n/** 1D float Perlin periodic noise, SL \"pnoise()\"\n */\n", "func_signal": "float pnoise1( float x, int px )", "code": "{\n    int ix0, ix1;\n    float fx0, fx1;\n    float s, n0, n1;\n\n    ix0 = FASTFLOOR( x ); // Integer part of x\n    fx0 = x - ix0;       // Fractional part of x\n    fx1 = fx0 - 1.0f;\n    ix1 = (( ix0 + 1 ) % px) & 0xff; // Wrap to 0..px-1 *and* wrap to 0..255\n    ix0 = ( ix0 % px ) & 0xff;      // (because px might be greater than 256)\n\n    s = FADE( fx0 );\n\n    n0 = grad1( perm[ ix0 ], fx0 );\n    n1 = grad1( perm[ ix1 ], fx1 );\n    return 0.188f * ( LERP( s, n0, n1 ) );\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// updates lighting at the specified position, propagating light around it\n", "func_signal": "void light_update(struct World *world, ivec3s pos)", "code": "{\n    struct LightQueue queue = { .size = 0 }; \n\n    // i is [0..4] instead of [0..3] so sunlight is propagated as well\n    for (size_t i = 0; i < 5; i++) {\n        u32 mask = 0xF << (i * 4), offset = i * 4;\n        bool sunlight = i == 4;\n        queue.size = 0;\n\n        for (enum Direction d = 0; d < 6; d++) {\n            ivec3s pos_n = glms_ivec3_add(pos, DIR2IVEC3S(d));\n\n            if (!BLOCKS[world_get_block(world, pos_n)].transparent) {\n                continue;\n            }\n\n            ENQUEUE(&queue, ((struct LightNode) { .pos = pos_n }));\n        }\n\n        // enqueue for sunlight if this block is above the heightmap\n        if (sunlight &&\n            pos.y > world_heightmap_get(world, (ivec2s) {{ pos.x, pos.z }})) {\n            world_set_sunlight(world, pos, LIGHT_MAX);\n            ENQUEUE(&queue, ((struct LightNode) { .pos = pos }));\n        }\n\n        add_propagate(world, &queue, mask, offset, sunlight ? SUNLIGHT : DEFAULT_LIGHT);\n    }\n}", "path": "minecraft-weekend/src/world/light.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// MUST be called before meshing\n", "func_signal": "void chunkmesh_prepare(struct ChunkMesh *self)", "code": "{\n    self->vertex_count = 0;\n\n    for (size_t i = 0; i <= BUFFER_TYPE_LAST; i++) {\n        buffer_prepare(&self->buffers[i]);\n    }\n}", "path": "minecraft-weekend/src/world/chunkmesh.c", "commit_date": "2020-05-08 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// MUST be called immediately after meshing AND sorting (before rendering)\n", "func_signal": "static void chunkmesh_finalize_indices(struct ChunkMesh *self)", "code": "{\n    assert(self->buffers[INDICES].data != NULL);\n    vbo_buffer(\n        self->ibo, self->buffers[INDICES].data, 0,\n        self->buffers[INDICES].count);\n\n    if (!self->flags.persist) {\n        free(self->buffers[INDICES].data);\n        self->buffers[INDICES].data = NULL;\n\n        free(self->buffers[FACES].data);\n        self->buffers[FACES].data = NULL;\n    }\n}", "path": "minecraft-weekend/src/world/chunkmesh.c", "commit_date": "2020-05-08 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "//---------------------------------------------------------------------\n/** 1D float Perlin noise, SL \"noise()\"\n */\n", "func_signal": "float noise1( float x )", "code": "{\n    int ix0, ix1;\n    float fx0, fx1;\n    float s, n0, n1;\n\n    ix0 = FASTFLOOR( x ); // Integer part of x\n    fx0 = x - ix0;       // Fractional part of x\n    fx1 = fx0 - 1.0f;\n    ix1 = ( ix0+1 ) & 0xff;\n    ix0 = ix0 & 0xff;    // Wrap to 0..255\n\n    s = FADE( fx0 );\n\n    n0 = grad1( perm[ ix0 ], fx0 );\n    n1 = grad1( perm[ ix1 ], fx1 );\n    return 0.188f * ( LERP( s, n0, n1 ) );\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// emits a single block face to the specified block mesh\n", "func_signal": "void blockmesh_face(struct ChunkMesh *mesh, struct BlockMeshParams params)", "code": "{\n    struct ChunkMeshBuffer\n        *data = &mesh->buffers[DATA],\n        *faces = &mesh->buffers[FACES],\n        *indices = &mesh->buffers[INDICES];\n    \n    // add this face into the face buffer if it's transparent\n    if (params.block->transparent) {\n        struct Face face = {\n            .indices_base = indices->elements,\n            .position = glms_vec3_add((vec3s) {{\n                FACE_CENTERS[(params.direction * 3) + 0],\n                FACE_CENTERS[(params.direction * 3) + 1],\n                FACE_CENTERS[(params.direction * 3) + 2]\n            }}, params.position)\n        };\n\n        memcpy(((struct Face *) faces->data) + faces->elements, &face, sizeof(struct Face));\n        faces->index += sizeof(struct Face);\n        faces->elements++;\n    }\n\n    // emit vertices\n    for (size_t i = 0; i < 4;  i++) {\n        const f32 *vertex = &CUBE_VERTICES[CUBE_INDICES[(params.direction * 6) + UNIQUE_INDICES[i]] * 3];\n        APPEND(f32, data, params.position.x + params.offset.x + (vertex[0] * params.size.x));\n        APPEND(f32, data, params.position.y + params.offset.y + (vertex[1] * params.size.y));\n        APPEND(f32, data, params.position.z + params.offset.z + (vertex[2] * params.size.z));\n        APPEND(f32, data, CUBE_UVS[(i * 2) + 0] ? params.uv_max.x : params.uv_min.x);\n        APPEND(f32, data, CUBE_UVS[(i * 2) + 1] ? params.uv_max.y : params.uv_min.y);\n\n        // use lighting data of this face's NEIGHBOR to light it if the block\n        // is not transparent. if it is transparent, use the current block's lighting\n        APPEND(u32, data,\n            MAKE_LIGHT_DATA(\n                params.direction,\n                chunk_data_to_light(params.block->transparent ? params.data : params.data_n)));\n    }\n\n    // emit indices\n    for (size_t i = 0; i < 6; i++) {\n        APPEND(u32, indices, mesh->vertex_count + FACE_INDICES[i]);\n    }\n\n    // emitted 4 more vertices, bump the vertex count\n    mesh->vertex_count += 4;\n}", "path": "minecraft-weekend/src/world/blockmesh.c", "commit_date": "2020-05-08 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// get colors for DAY or NIGHT\n", "func_signal": "static void colors_day_night(\n    enum SkyState state, vec4s *sun, vec4s *fog,\n    vec4s *sky, vec4s *void_, vec4s *cloud)", "code": "{\n    *sun = SUNLIGHT_COLORS[state];\n    *fog = SKY_COLORS[state][FOG_PLANE];\n    *sky = SKY_COLORS[state][SKY_PLANE];\n    *void_ = SKY_COLORS[state][VOID_PLANE];\n    *cloud = CLOUD_COLORS[state];\n}", "path": "minecraft-weekend/src/world/sky.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "//---------------------------------------------------------------------\n/** 3D float Perlin periodic noise.\n */\n", "func_signal": "float pnoise3( float x, float y, float z, int px, int py, int pz )", "code": "{\n    int ix0, iy0, ix1, iy1, iz0, iz1;\n    float fx0, fy0, fz0, fx1, fy1, fz1;\n    float s, t, r;\n    float nxy0, nxy1, nx0, nx1, n0, n1;\n\n    ix0 = FASTFLOOR( x ); // Integer part of x\n    iy0 = FASTFLOOR( y ); // Integer part of y\n    iz0 = FASTFLOOR( z ); // Integer part of z\n    fx0 = x - ix0;        // Fractional part of x\n    fy0 = y - iy0;        // Fractional part of y\n    fz0 = z - iz0;        // Fractional part of z\n    fx1 = fx0 - 1.0f;\n    fy1 = fy0 - 1.0f;\n    fz1 = fz0 - 1.0f;\n    ix1 = (( ix0 + 1 ) % px ) & 0xff; // Wrap to 0..px-1 and wrap to 0..255\n    iy1 = (( iy0 + 1 ) % py ) & 0xff; // Wrap to 0..py-1 and wrap to 0..255\n    iz1 = (( iz0 + 1 ) % pz ) & 0xff; // Wrap to 0..pz-1 and wrap to 0..255\n    ix0 = ( ix0 % px ) & 0xff;\n    iy0 = ( iy0 % py ) & 0xff;\n    iz0 = ( iz0 % pz ) & 0xff;\n    \n    r = FADE( fz0 );\n    t = FADE( fy0 );\n    s = FADE( fx0 );\n\n    nxy0 = grad3(perm[ix0 + perm[iy0 + perm[iz0]]], fx0, fy0, fz0);\n    nxy1 = grad3(perm[ix0 + perm[iy0 + perm[iz1]]], fx0, fy0, fz1);\n    nx0 = LERP( r, nxy0, nxy1 );\n\n    nxy0 = grad3(perm[ix0 + perm[iy1 + perm[iz0]]], fx0, fy1, fz0);\n    nxy1 = grad3(perm[ix0 + perm[iy1 + perm[iz1]]], fx0, fy1, fz1);\n    nx1 = LERP( r, nxy0, nxy1 );\n\n    n0 = LERP( t, nx0, nx1 );\n\n    nxy0 = grad3(perm[ix1 + perm[iy0 + perm[iz0]]], fx1, fy0, fz0);\n    nxy1 = grad3(perm[ix1 + perm[iy0 + perm[iz1]]], fx1, fy0, fz1);\n    nx0 = LERP( r, nxy0, nxy1 );\n\n    nxy0 = grad3(perm[ix1 + perm[iy1 + perm[iz0]]], fx1, fy1, fz0);\n    nxy1 = grad3(perm[ix1 + perm[iy1 + perm[iz1]]], fx1, fy1, fz1);\n    nx1 = LERP( r, nxy0, nxy1 );\n\n    n1 = LERP( t, nx0, nx1 );\n    \n    return 0.936f * ( LERP( s, n0, n1 ) );\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// renders a sky plane with the specified transformation parameters\n// assumes that the sky shader is already enabled and fog uniforms have been set\n", "func_signal": "static void plane_render(struct Sky *self, struct Texture *tex, vec4s color, mat4s m)", "code": "{\n    shader_uniform_mat4(state.renderer.shaders[SHADER_SKY], \"m\", m);\n    shader_uniform_vec4(state.renderer.shaders[SHADER_SKY], \"color\", color);\n\n    shader_uniform_int(state.renderer.shaders[SHADER_SKY], \"use_tex\", tex != NULL);\n    if (tex != NULL) {\n        shader_uniform_texture2D(state.renderer.shaders[SHADER_SKY], \"tex\", *tex, 0);\n    }\n\n    vao_attr(self->vao, self->vbo, 0, 3, GL_FLOAT, 0, 0);\n    vao_attr(self->vao, self->vbo, 1, 2, GL_FLOAT, 0, (3 * 4) * sizeof(f32));\n\n    vao_bind(self->vao);\n    vbo_bind(self->ibo);\n\n    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, (void *) 0);\n}", "path": "minecraft-weekend/src/world/sky.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "//---------------------------------------------------------------------\n/** 3D float Perlin noise.\n */\n", "func_signal": "float noise3( float x, float y, float z )", "code": "{\n    int ix0, iy0, ix1, iy1, iz0, iz1;\n    float fx0, fy0, fz0, fx1, fy1, fz1;\n    float s, t, r;\n    float nxy0, nxy1, nx0, nx1, n0, n1;\n\n    ix0 = FASTFLOOR( x ); // Integer part of x\n    iy0 = FASTFLOOR( y ); // Integer part of y\n    iz0 = FASTFLOOR( z ); // Integer part of z\n    fx0 = x - ix0;        // Fractional part of x\n    fy0 = y - iy0;        // Fractional part of y\n    fz0 = z - iz0;        // Fractional part of z\n    fx1 = fx0 - 1.0f;\n    fy1 = fy0 - 1.0f;\n    fz1 = fz0 - 1.0f;\n    ix1 = ( ix0 + 1 ) & 0xff; // Wrap to 0..255\n    iy1 = ( iy0 + 1 ) & 0xff;\n    iz1 = ( iz0 + 1 ) & 0xff;\n    ix0 = ix0 & 0xff;\n    iy0 = iy0 & 0xff;\n    iz0 = iz0 & 0xff;\n    \n    r = FADE( fz0 );\n    t = FADE( fy0 );\n    s = FADE( fx0 );\n\n    nxy0 = grad3(perm[ix0 + perm[iy0 + perm[iz0]]], fx0, fy0, fz0);\n    nxy1 = grad3(perm[ix0 + perm[iy0 + perm[iz1]]], fx0, fy0, fz1);\n    nx0 = LERP( r, nxy0, nxy1 );\n\n    nxy0 = grad3(perm[ix0 + perm[iy1 + perm[iz0]]], fx0, fy1, fz0);\n    nxy1 = grad3(perm[ix0 + perm[iy1 + perm[iz1]]], fx0, fy1, fz1);\n    nx1 = LERP( r, nxy0, nxy1 );\n\n    n0 = LERP( t, nx0, nx1 );\n\n    nxy0 = grad3(perm[ix1 + perm[iy0 + perm[iz0]]], fx1, fy0, fz0);\n    nxy1 = grad3(perm[ix1 + perm[iy0 + perm[iz1]]], fx1, fy0, fz1);\n    nx0 = LERP( r, nxy0, nxy1 );\n\n    nxy0 = grad3(perm[ix1 + perm[iy1 + perm[iz0]]], fx1, fy1, fz0);\n    nxy1 = grad3(perm[ix1 + perm[iy1 + perm[iz1]]], fx1, fy1, fz1);\n    nx1 = LERP( r, nxy0, nxy1 );\n\n    n1 = LERP( t, nx0, nx1 );\n    \n    return 0.936f * ( LERP( s, n0, n1 ) );\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "/*\n * Helper functions to compute gradients-dot-residualvectors (1D to 4D)\n * Note that these generate gradients of more than unit length. To make\n * a close match with the value range of classic Perlin noise, the final\n * noise values need to be rescaled. To match the RenderMan noise in a\n * statistical sense, the approximate scaling values (empirically\n * determined from test renderings) are:\n * 1D noise needs rescaling with 0.188\n * 2D noise needs rescaling with 0.507\n * 3D noise needs rescaling with 0.936\n * 4D noise needs rescaling with 0.87\n * Note that these noise functions are the most practical and useful\n * signed version of Perlin noise. To return values according to the\n * RenderMan specification from the SL noise() and pnoise() functions,\n * the noise values need to be scaled and offset to [0,1], like this:\n * float SLnoise = (noise3(x,y,z) + 1.0) * 0.5;\n */\n", "func_signal": "float grad1( int hash, float x )", "code": "{\n    int h = hash & 15;\n    float grad = 1.0 + (h & 7);  // Gradient value 1.0, 2.0, ..., 8.0\n    if (h&8) grad = -grad;         // and a random sign for the gradient\n    return ( grad * x );           // Multiply the gradient with the distance\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "//---------------------------------------------------------------------\n/** 4D float Perlin periodic noise.\n */\n", "func_signal": "float pnoise4( float x, float y, float z, float w,\n                            int px, int py, int pz, int pw )", "code": "{\n    int ix0, iy0, iz0, iw0, ix1, iy1, iz1, iw1;\n    float fx0, fy0, fz0, fw0, fx1, fy1, fz1, fw1;\n    float s, t, r, q;\n    float nxyz0, nxyz1, nxy0, nxy1, nx0, nx1, n0, n1;\n\n    ix0 = FASTFLOOR( x ); // Integer part of x\n    iy0 = FASTFLOOR( y ); // Integer part of y\n    iz0 = FASTFLOOR( z ); // Integer part of y\n    iw0 = FASTFLOOR( w ); // Integer part of w\n    fx0 = x - ix0;        // Fractional part of x\n    fy0 = y - iy0;        // Fractional part of y\n    fz0 = z - iz0;        // Fractional part of z\n    fw0 = w - iw0;        // Fractional part of w\n    fx1 = fx0 - 1.0f;\n    fy1 = fy0 - 1.0f;\n    fz1 = fz0 - 1.0f;\n    fw1 = fw0 - 1.0f;\n    ix1 = (( ix0 + 1 ) % px ) & 0xff;  // Wrap to 0..px-1 and wrap to 0..255\n    iy1 = (( iy0 + 1 ) % py ) & 0xff;  // Wrap to 0..py-1 and wrap to 0..255\n    iz1 = (( iz0 + 1 ) % pz ) & 0xff;  // Wrap to 0..pz-1 and wrap to 0..255\n    iw1 = (( iw0 + 1 ) % pw ) & 0xff;  // Wrap to 0..pw-1 and wrap to 0..255\n    ix0 = ( ix0 % px ) & 0xff;\n    iy0 = ( iy0 % py ) & 0xff;\n    iz0 = ( iz0 % pz ) & 0xff;\n    iw0 = ( iw0 % pw ) & 0xff;\n\n    q = FADE( fw0 );\n    r = FADE( fz0 );\n    t = FADE( fy0 );\n    s = FADE( fx0 );\n\n    nxyz0 = grad4(perm[ix0 + perm[iy0 + perm[iz0 + perm[iw0]]]], fx0, fy0, fz0, fw0);\n    nxyz1 = grad4(perm[ix0 + perm[iy0 + perm[iz0 + perm[iw1]]]], fx0, fy0, fz0, fw1);\n    nxy0 = LERP( q, nxyz0, nxyz1 );\n        \n    nxyz0 = grad4(perm[ix0 + perm[iy0 + perm[iz1 + perm[iw0]]]], fx0, fy0, fz1, fw0);\n    nxyz1 = grad4(perm[ix0 + perm[iy0 + perm[iz1 + perm[iw1]]]], fx0, fy0, fz1, fw1);\n    nxy1 = LERP( q, nxyz0, nxyz1 );\n        \n    nx0 = LERP ( r, nxy0, nxy1 );\n\n    nxyz0 = grad4(perm[ix0 + perm[iy1 + perm[iz0 + perm[iw0]]]], fx0, fy1, fz0, fw0);\n    nxyz1 = grad4(perm[ix0 + perm[iy1 + perm[iz0 + perm[iw1]]]], fx0, fy1, fz0, fw1);\n    nxy0 = LERP( q, nxyz0, nxyz1 );\n        \n    nxyz0 = grad4(perm[ix0 + perm[iy1 + perm[iz1 + perm[iw0]]]], fx0, fy1, fz1, fw0);\n    nxyz1 = grad4(perm[ix0 + perm[iy1 + perm[iz1 + perm[iw1]]]], fx0, fy1, fz1, fw1);\n    nxy1 = LERP( q, nxyz0, nxyz1 );\n\n    nx1 = LERP ( r, nxy0, nxy1 );\n\n    n0 = LERP( t, nx0, nx1 );\n\n    nxyz0 = grad4(perm[ix1 + perm[iy0 + perm[iz0 + perm[iw0]]]], fx1, fy0, fz0, fw0);\n    nxyz1 = grad4(perm[ix1 + perm[iy0 + perm[iz0 + perm[iw1]]]], fx1, fy0, fz0, fw1);\n    nxy0 = LERP( q, nxyz0, nxyz1 );\n        \n    nxyz0 = grad4(perm[ix1 + perm[iy0 + perm[iz1 + perm[iw0]]]], fx1, fy0, fz1, fw0);\n    nxyz1 = grad4(perm[ix1 + perm[iy0 + perm[iz1 + perm[iw1]]]], fx1, fy0, fz1, fw1);\n    nxy1 = LERP( q, nxyz0, nxyz1 );\n\n    nx0 = LERP ( r, nxy0, nxy1 );\n\n    nxyz0 = grad4(perm[ix1 + perm[iy1 + perm[iz0 + perm[iw0]]]], fx1, fy1, fz0, fw0);\n    nxyz1 = grad4(perm[ix1 + perm[iy1 + perm[iz0 + perm[iw1]]]], fx1, fy1, fz0, fw1);\n    nxy0 = LERP( q, nxyz0, nxyz1 );\n        \n    nxyz0 = grad4(perm[ix1 + perm[iy1 + perm[iz1 + perm[iw0]]]], fx1, fy1, fz1, fw0);\n    nxyz1 = grad4(perm[ix1 + perm[iy1 + perm[iz1 + perm[iw1]]]], fx1, fy1, fz1, fw1);\n    nxy1 = LERP( q, nxyz0, nxyz1 );\n\n    nx1 = LERP ( r, nxy0, nxy1 );\n\n    n1 = LERP( t, nx0, nx1 );\n\n    return 0.87f * ( LERP( s, n0, n1 ) );\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "//---------------------------------------------------------------------\n/** 2D float Perlin noise.\n */\n", "func_signal": "float noise2( float x, float y )", "code": "{\n    int ix0, iy0, ix1, iy1;\n    float fx0, fy0, fx1, fy1;\n    float s, t, nx0, nx1, n0, n1;\n\n    ix0 = FASTFLOOR( x ); // Integer part of x\n    iy0 = FASTFLOOR( y ); // Integer part of y\n    fx0 = x - ix0;        // Fractional part of x\n    fy0 = y - iy0;        // Fractional part of y\n    fx1 = fx0 - 1.0f;\n    fy1 = fy0 - 1.0f;\n    ix1 = (ix0 + 1) & 0xff;  // Wrap to 0..255\n    iy1 = (iy0 + 1) & 0xff;\n    ix0 = ix0 & 0xff;\n    iy0 = iy0 & 0xff;\n    \n    t = FADE( fy0 );\n    s = FADE( fx0 );\n\n    nx0 = grad2(perm[ix0 + perm[iy0]], fx0, fy0);\n    nx1 = grad2(perm[ix0 + perm[iy1]], fx0, fy1);\n    n0 = LERP( t, nx0, nx1 );\n\n    nx0 = grad2(perm[ix1 + perm[iy0]], fx1, fy0);\n    nx1 = grad2(perm[ix1 + perm[iy1]], fx1, fy1);\n    n1 = LERP(t, nx0, nx1);\n\n    return 0.507f * ( LERP( s, n0, n1 ) );\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// MUST be called immediately after meshing (before rendering)\n", "func_signal": "static void chunkmesh_finalize_data(struct ChunkMesh *self)", "code": "{\n    assert(self->buffers[DATA].data != NULL);\n    vbo_buffer(\n        self->vbo, self->buffers[DATA].data, 0,\n        self->buffers[DATA].count);\n\n    free(self->buffers[DATA].data);\n    self->buffers[DATA].data = NULL;\n}", "path": "minecraft-weekend/src/world/chunkmesh.c", "commit_date": "2020-05-08 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// get colors for a transition period, SUNRISE or SUNSET\n", "func_signal": "static void colors_transition(\n    struct Sky *self, enum SkyState state, enum SkyState from, enum SkyState to,\n    vec4s *sun, vec4s *fog, vec4s *sky, vec4s *void_, vec4s *cloud)", "code": "{\n    *sun = rgba_lerp(\n        SUNLIGHT_COLORS[from],\n        SUNLIGHT_COLORS[to],\n        self->sky_state_progress);\n    *fog = rgba_lerp3(\n        SKY_COLORS[from][FOG_PLANE],\n        SKY_COLORS[state][FOG_PLANE],\n        SKY_COLORS[to][FOG_PLANE],\n        self->sky_state_progress);\n    *sky = rgba_lerp(\n        SKY_COLORS[from][SKY_PLANE],\n        SKY_COLORS[to][SKY_PLANE],\n        self->sky_state_progress);\n    *void_ = rgba_lerp(\n        SKY_COLORS[from][VOID_PLANE],\n        SKY_COLORS[to][VOID_PLANE],\n        self->sky_state_progress);\n    *cloud = rgba_lerp(\n        CLOUD_COLORS[from],\n        CLOUD_COLORS[to],\n        self->sky_state_progress);\n}", "path": "minecraft-weekend/src/world/sky.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "//---------------------------------------------------------------------\n/** 2D float Perlin periodic noise.\n */\n", "func_signal": "float pnoise2( float x, float y, int px, int py )", "code": "{\n    int ix0, iy0, ix1, iy1;\n    float fx0, fy0, fx1, fy1;\n    float s, t, nx0, nx1, n0, n1;\n\n    ix0 = FASTFLOOR( x ); // Integer part of x\n    iy0 = FASTFLOOR( y ); // Integer part of y\n    fx0 = x - ix0;        // Fractional part of x\n    fy0 = y - iy0;        // Fractional part of y\n    fx1 = fx0 - 1.0f;\n    fy1 = fy0 - 1.0f;\n    ix1 = (( ix0 + 1 ) % px) & 0xff;  // Wrap to 0..px-1 and wrap to 0..255\n    iy1 = (( iy0 + 1 ) % py) & 0xff;  // Wrap to 0..py-1 and wrap to 0..255\n    ix0 = ( ix0 % px ) & 0xff;\n    iy0 = ( iy0 % py ) & 0xff;\n    \n    t = FADE( fy0 );\n    s = FADE( fx0 );\n\n    nx0 = grad2(perm[ix0 + perm[iy0]], fx0, fy0);\n    nx1 = grad2(perm[ix0 + perm[iy1]], fx0, fy1);\n    n0 = LERP( t, nx0, nx1 );\n\n    nx0 = grad2(perm[ix1 + perm[iy0]], fx1, fy0);\n    nx1 = grad2(perm[ix1 + perm[iy1]], fx1, fy1);\n    n1 = LERP(t, nx0, nx1);\n\n    return 0.507f * ( LERP( s, n0, n1 ) );\n}", "path": "minecraft-weekend/lib/noise/noise1234.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// returns a value in [0, 1] indicating the \"progress\" of the current day or night\n", "func_signal": "f32 get_day_night_progress(struct Sky *self)", "code": "{\n    const u64 day_ticks = (self->world->ticks % TOTAL_DAY_TICKS);\n    switch (get_day_night(self)) {\n        case DAY:\n            return ((f32) day_ticks) / ((f32) DAY_TICKS);\n        default:\n            return ((f32) (day_ticks - DAY_TICKS) / ((f32) NIGHT_TICKS));\n    }\n}", "path": "minecraft-weekend/src/world/sky.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "// returns a value in [0, 1] indicating the \"progress\" of the current sky state\n// (how far along it is in ticks)\n", "func_signal": "f32 get_sky_state_progress(struct Sky *self)", "code": "{\n    const f32 day_ticks = (f32) (self->world->ticks % TOTAL_DAY_TICKS);\n\n    switch (self->state) {\n        case SUNRISE:\n            return day_ticks <= HALF_SUN_CHANGE_TICKS ?\n                (0.5f + ((day_ticks / HALF_SUN_CHANGE_TICKS) * 0.5f)) :\n                (((day_ticks - (TOTAL_DAY_TICKS - HALF_SUN_CHANGE_TICKS)) / HALF_SUN_CHANGE_TICKS) * 0.5f);\n        case DAY:\n            return (day_ticks - HALF_SUN_CHANGE_TICKS) / DAY_TICKS;\n        case SUNSET:\n            return (day_ticks - (DAY_TICKS - HALF_SUN_CHANGE_TICKS)) / SUN_CHANGE_TICKS;\n        case NIGHT:\n            return (day_ticks - (DAY_TICKS + HALF_SUN_CHANGE_TICKS)) / NIGHT_TICKS;\n    }\n}", "path": "minecraft-weekend/src/world/sky.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "jdah/minecraft-weekend", "stars": 3678, "license": "mit", "language": "c", "size": 7820}
{"docstring": "/* compute r=B^(2*n)/a such as a*r < B^(2*n) < a*r + 2 with n >= 1. 'a'\n   has n limbs with a[n-1] >= B/2 and 'r' has n+1 limbs with r[n] = 1.\n   \n   See Modern Computer Arithmetic by Richard P. Brent and Paul\n   Zimmermann, algorithm 3.5 */\n", "func_signal": "int mp_recip(bf_context_t *s, limb_t *tabr, const limb_t *taba, limb_t n)", "code": "{\n    mp_size_t l, h, k, i;\n    limb_t *tabxh, *tabt, c, *tabu;\n    \n    if (n <= 2) {\n        /* return ceil(B^(2*n)/a) - 1 */\n        /* XXX: could avoid allocation */\n        tabu = bf_malloc(s, sizeof(limb_t) * (2 * n + 1));\n        tabt = bf_malloc(s, sizeof(limb_t) * (n + 2));\n        if (!tabt || !tabu)\n            goto fail;\n        for(i = 0; i < 2 * n; i++)\n            tabu[i] = 0;\n        tabu[2 * n] = 1;\n        if (mp_divnorm(s, tabt, tabu, 2 * n + 1, taba, n))\n            goto fail;\n        for(i = 0; i < n + 1; i++)\n            tabr[i] = tabt[i];\n        if (mp_scan_nz(tabu, n) == 0) {\n            /* only happens for a=B^n/2 */\n            mp_sub_ui(tabr, 1, n + 1);\n        }\n    } else {\n        l = (n - 1) / 2;\n        h = n - l;\n        /* n=2p  -> l=p-1, h = p + 1, k = p + 3\n           n=2p+1-> l=p,  h = p + 1; k = p + 2\n        */\n        tabt = bf_malloc(s, sizeof(limb_t) * (n + h + 1));\n        tabu = bf_malloc(s, sizeof(limb_t) * (n + 2 * h - l + 2));\n        if (!tabt || !tabu)\n            goto fail;\n        tabxh = tabr + l;\n        if (mp_recip(s, tabxh, taba + l, h))\n            goto fail;\n        if (mp_mul(s, tabt, taba, n, tabxh, h + 1)) /* n + h + 1 limbs */\n            goto fail;\n        while (tabt[n + h] != 0) {\n            mp_sub_ui(tabxh, 1, h + 1);\n            c = mp_sub(tabt, tabt, taba, n, 0);\n            mp_sub_ui(tabt + n, c, h + 1);\n        }\n        /* T = B^(n+h) - T */\n        mp_neg(tabt, tabt, n + h + 1, 0);\n        tabt[n + h]++;\n        if (mp_mul(s, tabu, tabt + l, n + h + 1 - l, tabxh, h + 1))\n            goto fail;\n        /* n + 2*h - l + 2 limbs */\n        k = 2 * h - l;\n        for(i = 0; i < l; i++)\n            tabr[i] = tabu[i + k];\n        mp_add(tabr + l, tabr + l, tabu + 2 * h, h, 0);\n    }\n    bf_free(s, tabt);\n    bf_free(s, tabu);\n    return 0;\n fail:\n    bf_free(s, tabt);\n    bf_free(s, tabu);\n    return -1;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* return the length of the decomposition (length <=\n   UNICODE_DECOMP_LEN_MAX) or 0 if no decomposition */\n", "func_signal": "static int unicode_decomp_char(uint32_t *res, uint32_t c, BOOL is_compat1)", "code": "{\n    uint32_t v, type, is_compat, code, len;\n    int idx_min, idx_max, idx;\n    \n    idx_min = 0;\n    idx_max = countof(unicode_decomp_table1) - 1;\n    while (idx_min <= idx_max) {\n        idx = (idx_max + idx_min) / 2;\n        v = unicode_decomp_table1[idx];\n        code = v >> (32 - 18);\n        len = (v >> (32 - 18 - 7)) & 0x7f;\n        //        printf(\"idx=%d code=%05x len=%d\\n\", idx, code, len);\n        if (c < code) {\n            idx_max = idx - 1;\n        } else if (c >= code + len) {\n            idx_min = idx + 1;\n        } else {\n            is_compat = v & 1;\n            if (is_compat1 < is_compat)\n                break;\n            type = (v >> (32 - 18 - 7 - 6)) & 0x3f;\n            return unicode_decomp_entry(res, c, idx, code, len, type);\n        }\n    }\n    return 0;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libunicode.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* taba[] = taba[] * b + l. 0 <= b, l <= base - 1. Return the high carry */\n", "func_signal": "limb_t mp_mul1_dec(limb_t *tabr, const limb_t *taba, mp_size_t n, \n                   limb_t b, limb_t l)", "code": "{\n    mp_size_t i;\n    limb_t t0, t1, r;\n\n    for(i = 0; i < n; i++) {\n        muldq(t1, t0, taba[i], b);\n        adddq(t1, t0, 0, l);\n        divdq_base(l, r, t1, t0);\n        tabr[i] = r;\n    }\n    return l;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* Full order: -0 < 0, NaN == NaN and NaN is larger than all other numbers */\n", "func_signal": "int bf_cmp_full(const bf_t *a, const bf_t *b)", "code": "{\n    int res;\n    \n    if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n        if (a->expn == b->expn)\n            res = 0;\n        else if (a->expn == BF_EXP_NAN)\n            res = 1;\n        else\n            res = -1;\n    } else if (a->sign != b->sign) {\n        res = 1 - 2 * a->sign;\n    } else {\n        res = bf_cmpu(a, b);\n        if (a->sign)\n            res = -res;\n    }\n    return res;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* compare the absolute value of 'a' and 'b'. Return < 0 if a < b, 0\n   if a = b and > 0 otherwise. */\n", "func_signal": "int bf_cmpu(const bf_t *a, const bf_t *b)", "code": "{\n    slimb_t i;\n    limb_t len, v1, v2;\n    \n    if (a->expn != b->expn) {\n        if (a->expn < b->expn)\n            return -1;\n        else\n            return 1;\n    }\n    len = bf_max(a->len, b->len);\n    for(i = len - 1; i >= 0; i--) {\n        v1 = get_limbz(a, a->len - len + i);\n        v2 = get_limbz(b, b->len - len + i);\n        if (v1 != v2) {\n            if (v1 < v2)\n                return -1;\n            else\n                return 1;\n        }\n    }\n    return 0;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* x and y finite and x > 0 */\n", "func_signal": "static int bf_pow_generic(bf_t *r, const bf_t *x, limb_t prec, void *opaque)", "code": "{\n    bf_context_t *s = r->ctx;\n    const bf_t *y = opaque;\n    bf_t T_s, *T = &T_s;\n    limb_t prec1;\n\n    bf_init(s, T);\n    /* XXX: proof for the added precision */\n    prec1 = prec + 32;\n    bf_log(T, x, prec1, BF_RNDF | BF_FLAG_EXT_EXP);\n    bf_mul(T, T, y, prec1, BF_RNDF | BF_FLAG_EXT_EXP);\n    if (bf_is_nan(T))\n        bf_set_nan(r);\n    else\n        bf_exp_internal(r, T, prec1, NULL); /* no overflow/underlow test needed */\n    bf_delete(T);\n    return BF_ST_INEXACT;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* compute 0 - op2 */\n", "func_signal": "static limb_t mp_neg(limb_t *res, const limb_t *op2, mp_size_t n, limb_t carry)", "code": "{\n    int i;\n    limb_t k, a, v, k1;\n    \n    k = carry;\n    for(i=0;i<n;i++) {\n        v = 0;\n        a = v - op2[i];\n        k1 = a > v;\n        v = a - k;\n        k = (v > a) | k1;\n        res[i] = v;\n    }\n    return k;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* round to prec1 bits assuming 'r' is non zero and finite. 'r' is\n   assumed to have length 'l' (1 <= l <= r->len). prec1 can be\n   BF_PREC_INF. BF_FLAG_SUBNORMAL is not supported. Cannot fail with\n   BF_ST_MEM_ERROR.\n */\n", "func_signal": "static int __bfdec_round(bfdec_t *r, limb_t prec1, bf_flags_t flags, limb_t l)", "code": "{\n    int shift, add_one, rnd_mode, ret;\n    slimb_t i, bit_pos, pos, e_min, e_max, e_range, prec;\n\n    /* XXX: align to IEEE 754 2008 for decimal numbers ? */\n    e_range = (limb_t)1 << (bf_get_exp_bits(flags) - 1);\n    e_min = -e_range + 3;\n    e_max = e_range;\n    \n    if (flags & BF_FLAG_RADPNT_PREC) {\n        /* 'prec' is the precision after the decimal point */\n        if (prec1 != BF_PREC_INF)\n            prec = r->expn + prec1;\n        else\n            prec = prec1;\n    } else if (unlikely(r->expn < e_min) && (flags & BF_FLAG_SUBNORMAL)) {\n        /* restrict the precision in case of potentially subnormal\n           result */\n        assert(prec1 != BF_PREC_INF);\n        prec = prec1 - (e_min - r->expn);\n    } else {\n        prec = prec1;\n    }\n    \n    /* round to prec bits */\n    rnd_mode = flags & BF_RND_MASK;\n    ret = 0;\n    add_one = bfdec_get_rnd_add(&ret, r, l, prec, rnd_mode);\n    \n    if (prec <= 0) {\n        if (add_one) {\n            bfdec_resize(r, 1); /* cannot fail because r is non zero */\n            r->tab[0] = BF_DEC_BASE / 10;\n            r->expn += 1 - prec;\n            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;\n            return ret;\n        } else {\n            goto underflow;\n        }\n    } else if (add_one) {\n        limb_t carry;\n        \n        /* add one starting at digit 'prec - 1' */\n        bit_pos = l * LIMB_DIGITS - 1 - (prec - 1);\n        pos = bit_pos / LIMB_DIGITS;\n        carry = mp_pow_dec[bit_pos % LIMB_DIGITS];\n        carry = mp_add_ui_dec(r->tab + pos, carry, l - pos);\n        if (carry) {\n            /* shift right by one digit */\n            mp_shr_dec(r->tab + pos, r->tab + pos, l - pos, 1, 1);\n            r->expn++;\n        }\n    }\n    \n    /* check underflow */\n    if (unlikely(r->expn < e_min)) {\n        if (flags & BF_FLAG_SUBNORMAL) {\n            /* if inexact, also set the underflow flag */\n            if (ret & BF_ST_INEXACT)\n                ret |= BF_ST_UNDERFLOW;\n        } else {\n        underflow:\n            bfdec_set_zero(r, r->sign);\n            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;\n            return ret;\n        }\n    }\n    \n    /* check overflow */\n    if (unlikely(r->expn > e_max)) {\n        bfdec_set_inf(r, r->sign);\n        ret |= BF_ST_OVERFLOW | BF_ST_INEXACT;\n        return ret;\n    }\n    \n    /* keep the bits starting at 'prec - 1' */\n    bit_pos = l * LIMB_DIGITS - 1 - (prec - 1);\n    i = floor_div(bit_pos, LIMB_DIGITS);\n    if (i >= 0) {\n        shift = smod(bit_pos, LIMB_DIGITS);\n        if (shift != 0) {\n            r->tab[i] = fast_shr_dec(r->tab[i], shift) *\n                mp_pow_dec[shift];\n        }\n    } else {\n        i = 0;\n    }\n    /* remove trailing zeros */\n    while (r->tab[i] == 0)\n        i++;\n    if (i > 0) {\n        l -= i;\n        memmove(r->tab, r->tab + i, l * sizeof(limb_t));\n    }\n    bfdec_resize(r, l); /* cannot fail */\n    return ret;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* Faster version used when the multiplier is constant. 0 <= a < 2^64,\n   0 <= b < m. Let r = a * b mod m. The return value is 'r' or 'r +\n   m'. */\n", "func_signal": "static inline limb_t mul_mod_fast3(limb_t a, limb_t b, \n                                     limb_t m, limb_t b_inv)", "code": "{\n    limb_t r, q;\n\n    q = ((dlimb_t)a * (dlimb_t)b_inv) >> LIMB_BITS;\n    r = a * b - q * m;\n    return r;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* From \"Division by Invariant Integers using Multiplication\" by\n   Torborn Granlund and Peter L. Montgomery */\n/* d must be != 0 */\n", "func_signal": "static inline __maybe_unused void fast_udiv_init(FastDivData *s, limb_t d)", "code": "{\n    int l;\n    limb_t q, r, m1;\n    if (d == 1)\n        l = 0;\n    else\n        l = 64 - clz64(d - 1);\n    divdq(q, r, ((limb_t)1 << l) - d, 0, d);\n    (void)r;\n    m1 = q + 1;\n    //    printf(\"d=%lu l=%d m1=0x%016lx\\n\", d, l, m1);\n    s->m1 = m1;\n    s->shift1 = l;\n    if (s->shift1 > 1)\n        s->shift1 = 1;\n    s->shift2 = l - 1;\n    if (s->shift2 < 0)\n        s->shift2 = 0;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2\n   if not found */\n", "func_signal": "int unicode_prop(CharRange *cr, const char *prop_name)", "code": "{\n    int prop_idx, ret;\n    \n    prop_idx = unicode_find_name(unicode_prop_name_table, prop_name);\n    if (prop_idx < 0)\n        return -2;\n    prop_idx += UNICODE_PROP_ASCII_Hex_Digit;\n\n    ret = 0;\n    switch(prop_idx) {\n    case UNICODE_PROP_ASCII:\n        if (cr_add_interval(cr, 0x00, 0x7f + 1))\n            return -1;\n        break;\n    case UNICODE_PROP_Any:\n        if (cr_add_interval(cr, 0x00000, 0x10ffff + 1))\n            return -1;\n        break;\n    case UNICODE_PROP_Assigned:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Cn),\n                               POP_INVERT,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Math:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Sm),\n                               POP_PROP, UNICODE_PROP_Other_Math,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Lowercase:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Ll),\n                               POP_PROP, UNICODE_PROP_Other_Lowercase,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Uppercase:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu),\n                               POP_PROP, UNICODE_PROP_Other_Uppercase,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Cased:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt),\n                               POP_PROP, UNICODE_PROP_Other_Uppercase,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_Lowercase,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Alphabetic:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),\n                               POP_PROP, UNICODE_PROP_Other_Uppercase,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_Lowercase,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_Alphabetic,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Grapheme_Base:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Cc) | M(Cf) | M(Cs) | M(Co) | M(Cn) | M(Zl) | M(Zp) | M(Me) | M(Mn),\n                               POP_PROP, UNICODE_PROP_Other_Grapheme_Extend,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Grapheme_Extend:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Me) | M(Mn),\n                               POP_PROP, UNICODE_PROP_Other_Grapheme_Extend,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_XID_Start:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),\n                               POP_PROP, UNICODE_PROP_Other_ID_Start,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Pattern_Syntax,\n                               POP_PROP, UNICODE_PROP_Pattern_White_Space,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_XID_Start1,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_INTER,\n                               POP_END);\n        break;\n    case UNICODE_PROP_XID_Continue:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl) |\n                               M(Mn) | M(Mc) | M(Nd) | M(Pc),\n                               POP_PROP, UNICODE_PROP_Other_ID_Start,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_ID_Continue,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Pattern_Syntax,\n                               POP_PROP, UNICODE_PROP_Pattern_White_Space,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_XID_Continue1,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_INTER,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Changes_When_Uppercased:\n        ret = unicode_case1(cr, CASE_U);\n        break;\n    case UNICODE_PROP_Changes_When_Lowercased:\n        ret = unicode_case1(cr, CASE_L);\n        break;\n    case UNICODE_PROP_Changes_When_Casemapped:\n        ret = unicode_case1(cr, CASE_U | CASE_L | CASE_F);\n        break;\n    case UNICODE_PROP_Changes_When_Titlecased:\n        ret = unicode_prop_ops(cr,\n                               POP_CASE, CASE_U,\n                               POP_PROP, UNICODE_PROP_Changes_When_Titlecased1,\n                               POP_XOR,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Changes_When_Casefolded:\n        ret = unicode_prop_ops(cr,\n                               POP_CASE, CASE_F,\n                               POP_PROP, UNICODE_PROP_Changes_When_Casefolded1,\n                               POP_XOR,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Changes_When_NFKC_Casefolded:\n        ret = unicode_prop_ops(cr,\n                               POP_CASE, CASE_F,\n                               POP_PROP, UNICODE_PROP_Changes_When_NFKC_Casefolded1,\n                               POP_XOR,\n                               POP_END);\n        break;\n#if 0\n    case UNICODE_PROP_ID_Start:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),\n                               POP_PROP, UNICODE_PROP_Other_ID_Start,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Pattern_Syntax,\n                               POP_PROP, UNICODE_PROP_Pattern_White_Space,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_INTER,\n                               POP_END);\n        break;\n    case UNICODE_PROP_ID_Continue:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl) |\n                               M(Mn) | M(Mc) | M(Nd) | M(Pc),\n                               POP_PROP, UNICODE_PROP_Other_ID_Start,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_ID_Continue,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Pattern_Syntax,\n                               POP_PROP, UNICODE_PROP_Pattern_White_Space,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_INTER,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Case_Ignorable:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Mn) | M(Cf) | M(Lm) | M(Sk),\n                               POP_PROP, UNICODE_PROP_Case_Ignorable1,\n                               POP_XOR,\n                               POP_END);\n        break;\n#else\n        /* we use the existing tables */\n    case UNICODE_PROP_ID_Continue:\n        ret = unicode_prop_ops(cr,\n                               POP_PROP, UNICODE_PROP_ID_Start,\n                               POP_PROP, UNICODE_PROP_ID_Continue1,\n                               POP_XOR,\n                               POP_END);\n        break;\n#endif\n    default:\n        if (prop_idx >= countof(unicode_prop_table))\n            return -2;\n        ret = unicode_prop1(cr, prop_idx);\n        break;\n    }\n    return ret;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libunicode.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2\n   if not found */\n", "func_signal": "int unicode_script(CharRange *cr,\n                   const char *script_name, BOOL is_ext)", "code": "{\n    int script_idx;\n    const uint8_t *p, *p_end;\n    uint32_t c, c1, b, n, v, v_len, i, type;\n    CharRange cr1_s, *cr1;\n    CharRange cr2_s, *cr2 = &cr2_s;\n    BOOL is_common;\n    \n    script_idx = unicode_find_name(unicode_script_name_table, script_name);\n    if (script_idx < 0)\n        return -2;\n    /* Note: we remove the \"Unknown\" Script */\n    script_idx += UNICODE_SCRIPT_Unknown + 1;\n        \n    is_common = (script_idx == UNICODE_SCRIPT_Common ||\n                 script_idx == UNICODE_SCRIPT_Inherited);\n    if (is_ext) {\n        cr1 = &cr1_s;\n        cr_init(cr1, cr->mem_opaque, cr->realloc_func);\n        cr_init(cr2, cr->mem_opaque, cr->realloc_func);\n    } else {\n        cr1 = cr;\n    }\n\n    p = unicode_script_table;\n    p_end = unicode_script_table + countof(unicode_script_table);\n    c = 0;\n    while (p < p_end) {\n        b = *p++;\n        type = b >> 7;\n        n = b & 0x7f;\n        if (n < 96) {\n        } else if (n < 112) {\n            n = (n - 96) << 8;\n            n |= *p++;\n            n += 96;\n        } else {\n            n = (n - 112) << 16;\n            n |= *p++ << 8;\n            n |= *p++;\n            n += 96 + (1 << 12);\n        }\n        if (type == 0)\n            v = 0;\n        else\n            v = *p++;\n        c1 = c + n + 1;\n        if (v == script_idx) {\n            if (cr_add_interval(cr1, c, c1))\n                goto fail;\n        }\n        c = c1;\n    }\n\n    if (is_ext) {\n        /* add the script extensions */\n        p = unicode_script_ext_table;\n        p_end = unicode_script_ext_table + countof(unicode_script_ext_table);\n        c = 0;\n        while (p < p_end) {\n            b = *p++;\n            if (b < 128) {\n                n = b;\n            } else if (b < 128 + 64) {\n                n = (b - 128) << 8;\n                n |= *p++;\n                n += 128;\n            } else {\n                n = (b - 128 - 64) << 16;\n                n |= *p++ << 8;\n                n |= *p++;\n                n += 128 + (1 << 14);\n            }\n            c1 = c + n + 1;\n            v_len = *p++;\n            if (is_common) {\n                if (v_len != 0) {\n                    if (cr_add_interval(cr2, c, c1))\n                        goto fail;\n                }\n            } else {\n                for(i = 0; i < v_len; i++) {\n                    if (p[i] == script_idx) {\n                        if (cr_add_interval(cr2, c, c1))\n                            goto fail;\n                        break;\n                    }\n                }\n            }\n            p += v_len;\n            c = c1;\n        }\n        if (is_common) {\n            /* remove all the characters with script extensions */\n            if (cr_invert(cr2))\n                goto fail;\n            if (cr_op(cr, cr1->points, cr1->len, cr2->points, cr2->len,\n                      CR_OP_INTER))\n                goto fail;\n        } else {\n            if (cr_op(cr, cr1->points, cr1->len, cr2->points, cr2->len,\n                      CR_OP_UNION))\n                goto fail;\n        }\n        cr_free(cr1);\n        cr_free(cr2);\n    }\n    return 0;\n fail:\n    if (is_ext) {\n        cr_free(cr1);\n        cr_free(cr2);\n    }\n    goto fail;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libunicode.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* a must be >= 0. 'P' is the wanted number of digits in radix\n   'radix'. 'r' is the mantissa represented as an integer. *pE\n   contains the exponent. Return != 0 if memory error. */\n", "func_signal": "static int bf_convert_to_radix(bf_t *r, slimb_t *pE,\n                               const bf_t *a, int radix,\n                               limb_t P, bf_rnd_t rnd_mode,\n                               BOOL is_fixed_exponent)", "code": "{\n    slimb_t E, e, prec, extra_bits, ziv_extra_bits, prec0;\n    bf_t B_s, *B = &B_s;\n    int e_sign, ret, res;\n    \n    if (a->len == 0) {\n        /* zero case */\n        *pE = 0;\n        return bf_set(r, a);\n    }\n\n    if (is_fixed_exponent) {\n        E = *pE;\n    } else {\n        /* compute the new exponent */\n        E = 1 + bf_mul_log2_radix(a->expn - 1, radix, TRUE, FALSE);\n    }\n    //    bf_print_str(\"a\", a);\n    //    printf(\"E=%ld P=%ld radix=%d\\n\", E, P, radix);\n    \n    for(;;) {\n        e = P - E;\n        e_sign = 0;\n        if (e < 0) {\n            e = -e;\n            e_sign = 1;\n        }\n        /* Note: precision for log2(radix) is not critical here */\n        prec0 = bf_mul_log2_radix(P, radix, FALSE, TRUE);\n        ziv_extra_bits = 16;\n        for(;;) {\n            prec = prec0 + ziv_extra_bits;\n            /* XXX: rigorous error analysis needed */\n            extra_bits = ceil_log2(e) * 2 + 1;\n            ret = bf_pow_ui_ui(r, radix, e, prec + extra_bits,\n                               BF_RNDN | BF_FLAG_EXT_EXP);\n            if (!e_sign)\n                ret |= bf_mul(r, r, a, prec + extra_bits,\n                              BF_RNDN | BF_FLAG_EXT_EXP);\n            else\n                ret |= bf_div(r, a, r, prec + extra_bits,\n                              BF_RNDN | BF_FLAG_EXT_EXP);\n            if (ret & BF_ST_MEM_ERROR)\n                return BF_ST_MEM_ERROR;\n            /* if the result is not exact, check that it can be safely\n               rounded to an integer */\n            if ((ret & BF_ST_INEXACT) &&\n                !bf_can_round(r, r->expn, rnd_mode, prec)) {\n                /* and more precision and retry */\n                ziv_extra_bits = ziv_extra_bits  + (ziv_extra_bits / 2);\n                continue;\n            } else {\n                ret = bf_rint(r, rnd_mode);\n                if (ret & BF_ST_MEM_ERROR)\n                    return BF_ST_MEM_ERROR;\n                break;\n            }\n        }\n        if (is_fixed_exponent)\n            break;\n        /* check that the result is < B^P */\n        /* XXX: do a fast approximate test first ? */\n        bf_init(r->ctx, B);\n        ret = bf_pow_ui_ui(B, radix, P, BF_PREC_INF, BF_RNDZ);\n        if (ret) {\n            bf_delete(B);\n            return ret;\n        }\n        res = bf_cmpu(r, B);\n        bf_delete(B);\n        if (res < 0)\n            break;\n        /* try a larger exponent */\n        E++;\n    }\n    *pE = E;\n    return 0;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* tabr[] = taba[] * b + l. Return the high carry */\n", "func_signal": "static limb_t mp_mul1(limb_t *tabr, const limb_t *taba, limb_t n, \n                      limb_t b, limb_t l)", "code": "{\n    limb_t i;\n    dlimb_t t;\n\n    for(i = 0; i < n; i++) {\n        t = (dlimb_t)taba[i] * (dlimb_t)b + l;\n        tabr[i] = t;\n        l = t >> LIMB_BITS;\n    }\n    return l;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* character range */\n", "func_signal": "static __maybe_unused void cr_dump(CharRange *cr)", "code": "{\n    int i;\n    for(i = 0; i < cr->len; i++)\n        printf(\"%d: 0x%04x\\n\", i, cr->points[i]);\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libunicode.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* compute log(2) with faithful rounding at precision 'prec' */\n", "func_signal": "static void bf_const_log2_internal(bf_t *T, limb_t prec)", "code": "{\n    limb_t w, N;\n    bf_t P_s, *P = &P_s;\n    bf_t Q_s, *Q = &Q_s;\n\n    w = prec + 15;\n    N = w / 3 + 1;\n    bf_init(T->ctx, P);\n    bf_init(T->ctx, Q);\n    bf_const_log2_rec(T, P, Q, 0, N, FALSE);\n    bf_div(T, T, Q, prec, BF_RNDN);\n    bf_delete(P);\n    bf_delete(Q);\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* return 0 or BF_ST_MEM_ERROR */\n", "func_signal": "int bf_set_ui(bf_t *r, uint64_t a)", "code": "{\n    r->sign = 0;\n    if (a == 0) {\n        r->expn = BF_EXP_ZERO;\n        bf_resize(r, 0); /* cannot fail */\n    } \n#if LIMB_BITS == 32\n    else if (a <= 0xffffffff)\n#else\n    else\n#endif\n    {\n        int shift;\n        if (bf_resize(r, 1))\n            goto fail;\n        shift = clz(a);\n        r->tab[0] = a << shift;\n        r->expn = LIMB_BITS - shift;\n    }\n#if LIMB_BITS == 32\n    else {\n        uint32_t a1, a0;\n        int shift;\n        if (bf_resize(r, 2))\n            goto fail;\n        a0 = a;\n        a1 = a >> 32;\n        shift = clz(a1);\n        r->tab[0] = a0 << shift;\n        r->tab[1] = (a1 << shift) | (a0 >> (LIMB_BITS - shift));\n        r->expn = 2 * LIMB_BITS - shift;\n    }\n#endif\n    return 0;\n fail:\n    bf_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* 'taba' has 2*n limbs with n >= 1 and taba[2*n-1] >= B/4. Return (s,\n   r) with s=floor(sqrt(a)) and r=a-s^2. 0 <= r <= 2 * s. tabs has n\n   limbs. r is returned in the lower n limbs of taba. Its r[n] is the\n   returned value of the function. */\n", "func_signal": "int mp_sqrtrem_dec(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n)", "code": "{\n    limb_t tmp_buf1[8];\n    limb_t *tmp_buf;\n    mp_size_t n2;\n    n2 = n / 2 + 1;\n    if (n2 <= countof(tmp_buf1)) {\n        tmp_buf = tmp_buf1;\n    } else {\n        tmp_buf = bf_malloc(s, sizeof(limb_t) * n2);\n        if (!tmp_buf)\n            return -1;\n    }\n    taba[n] = mp_sqrtrem_rec_dec(tabs, taba, n, tmp_buf);\n    if (tmp_buf != tmp_buf1)\n        bf_free(s, tmp_buf);\n    return 0;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* 'a' must be an integer if the is_dec = FALSE or if the radix is not\n   a power of two. A dot is added before the 'dot_pos' digit. dot_pos\n   = n_digits does not display the dot. 0 <= dot_pos <=\n   n_digits. n_digits >= 1. */\n", "func_signal": "static void output_digits(DynBuf *s, const bf_t *a1, int radix, limb_t n_digits,\n                          limb_t dot_pos, BOOL is_dec)", "code": "{\n    limb_t i, v, l;\n    slimb_t pos, pos_incr;\n    int digits_per_limb, buf_pos, radix_bits, first_buf_pos;\n    char buf[65];\n    bf_t a_s, *a;\n\n    if (is_dec) {\n        digits_per_limb = LIMB_DIGITS;\n        a = (bf_t *)a1;\n        radix_bits = 0;\n        pos = a->len;\n        pos_incr = 1;\n        first_buf_pos = 0;\n    } else if ((radix & (radix - 1)) == 0) {\n        a = (bf_t *)a1;\n        radix_bits = ceil_log2(radix);\n        digits_per_limb = LIMB_BITS / radix_bits;\n        pos_incr = digits_per_limb * radix_bits;\n        /* digits are aligned relative to the radix point */\n        pos = a->len * LIMB_BITS + smod(-a->expn, radix_bits);\n        first_buf_pos = 0;\n    } else {\n        limb_t n, radixl;\n\n        digits_per_limb = digits_per_limb_table[radix - 2];\n        radixl = get_limb_radix(radix);\n        a = &a_s;\n        bf_init(a1->ctx, a);\n        n = (n_digits + digits_per_limb - 1) / digits_per_limb;\n        if (bf_resize(a, n)) {\n            dbuf_set_error(s);\n            goto done;\n        }\n        if (bf_integer_to_radix(a, a1, radixl)) {\n            dbuf_set_error(s);\n            goto done;\n        }\n        radix_bits = 0;\n        pos = n;\n        pos_incr = 1;\n        first_buf_pos = pos * digits_per_limb - n_digits;\n    }\n    buf_pos = digits_per_limb;\n    i = 0;\n    while (i < n_digits) {\n        if (buf_pos == digits_per_limb) {\n            pos -= pos_incr;\n            if (radix_bits == 0) {\n                v = get_limbz(a, pos);\n                limb_to_a(buf, v, radix, digits_per_limb);\n            } else {\n                v = get_bits(a->tab, a->len, pos);\n                limb_to_a2(buf, v, radix_bits, digits_per_limb);\n            }\n            buf_pos = first_buf_pos;\n            first_buf_pos = 0;\n        }\n        if (i < dot_pos) {\n            l = dot_pos;\n        } else {\n            if (i == dot_pos)\n                dbuf_putc(s, '.');\n            l = n_digits;\n        }\n        l = bf_min(digits_per_limb - buf_pos, l - i);\n        dbuf_put(s, (uint8_t *)(buf + buf_pos), l);\n        buf_pos += l;\n        i += l;\n    }\n done:\n    if (a != a1)\n        bf_delete(a);\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/* x must be a finite non zero float. Return TRUE if there is a\n   floating point number r such as x=r^(2^n) and return this floating\n   point number 'r'. Otherwise return FALSE and r is undefined. */\n", "func_signal": "static BOOL check_exact_power2n(bf_t *r, const bf_t *x, slimb_t n)", "code": "{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    slimb_t e, i, er;\n    limb_t v;\n    \n    /* x = m*2^e with m odd integer */\n    e = bf_get_exp_min(x);\n    /* fast check on the exponent */\n    if (n > (LIMB_BITS - 1)) {\n        if (e != 0)\n            return FALSE;\n        er = 0;\n    } else {\n        if ((e & (((limb_t)1 << n) - 1)) != 0)\n            return FALSE;\n        er = e >> n;\n    }\n    /* every perfect odd square = 1 modulo 8 */\n    v = get_bits(x->tab, x->len, x->len * LIMB_BITS - x->expn + e);\n    if ((v & 7) != 1)\n        return FALSE;\n\n    bf_init(s, T);\n    bf_set(T, x);\n    T->expn -= e;\n    for(i = 0; i < n; i++) {\n        if (i != 0)\n            bf_set(T, r);\n        if (bf_sqrtrem(r, NULL, T) != 0)\n            return FALSE;\n    }\n    r->expn += er;\n    return TRUE;\n}", "path": "study/QuickJS/quickjs-2020-11-08-forxcode/libbf.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ming1016/study", "stars": 3849, "license": "None", "language": "c", "size": 429469}
{"docstring": "/***********************************************************************\n *              ReleaseStgMedium (OLE2.32)\n */\n", "func_signal": "VOID WINAPI ReleaseStgMedium16(STGMEDIUM16 *pmedium)", "code": "{\n    switch (pmedium->tymed)\n    {\n    case TYMED_HGLOBAL:\n    {\n        if ((pmedium->pUnkForRelease == 0) &&\n            (pmedium->u.hGlobal != 0))\n            GlobalFree16(pmedium->u.hGlobal);\n        break;\n    }\n    case TYMED_FILE:\n    {\n        if (pmedium->u.lpszFileName != 0)\n        {\n            if (pmedium->pUnkForRelease == 0)\n            {\n                DeleteFileA(MapSL(pmedium->u.lpszFileName));\n            }\n            FIXME(\"\\n\");\n            /*CoTaskMemFree(pmedium->u.lpszFileName);*/\n        }\n        break;\n    }\n    case TYMED_ISTREAM:\n    {\n        if (pmedium->u.pstm != 0)\n        {\n            IStream16_Release(pmedium->u.pstm);\n        }\n        break;\n    }\n    case TYMED_ISTORAGE:\n    {\n        if (pmedium->u.pstg != 0)\n        {\n            IStorage16_Release(pmedium->u.pstg);\n        }\n        break;\n    }\n    case TYMED_GDI:\n    {\n        if ((pmedium->pUnkForRelease == 0) &&\n            (pmedium->u.hGlobal != 0))\n            DeleteObject(HBITMAP_32(pmedium->u.hGlobal));\n        break;\n    }\n    case TYMED_MFPICT:\n    {\n        if ((pmedium->pUnkForRelease == 0) &&\n            (pmedium->u.hGlobal != 0))\n        {\n            LPMETAFILEPICT16 pMP = GlobalLock16(pmedium->u.hGlobal);\n            GlobalFree16(pMP->hMF);\n            GlobalUnlock16(pmedium->u.hGlobal);\n            GlobalFree16(pmedium->u.hGlobal);\n        }\n        break;\n    }\n    case TYMED_ENHMF:\n    {\n        FIXME(\"\\n\");\n    }\n    case TYMED_NULL:\n    default:\n        break;\n    }\n    pmedium->tymed = TYMED_NULL;\n\n    /*\n     * After cleaning up, the unknown is released\n     */\n    if (pmedium->pUnkForRelease != 0)\n    {\n        IUnknown16_Release(pmedium->pUnkForRelease);\n        pmedium->pUnkForRelease = 0;\n    }\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n * This method is part of the ILockBytes interface.\n *\n * See the documentation of ILockBytes for more info.\n */\n", "func_signal": "HRESULT CDECL HGLOBALLockBytesImpl16_Flush(ILockBytes16* iface)", "code": "{\n  TRACE(\"(%p)\\n\",iface);\n  return S_OK;\n}", "path": "winevdm/ole2/memlockbytes.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/***********************************************************************\n *    ReadClassStm (OLE2.20)\n */\n", "func_signal": "HRESULT WINAPI ReadClassStm16(SEGPTR stream, CLSID *clsid)", "code": "{\n    HANDLE16 hclsid, hread;\n    HRESULT hres;\n    DWORD args[4];\n\n    TRACE(\"(0x%x, %p)\\n\", stream, clsid);\n\n    if (!clsid)\n        return E_INVALIDARG16;\n\n    memset(clsid, 0, sizeof(*clsid));\n\n    if (!stream)\n        return E_INVALIDARG16;\n\n    args[0] = stream; /* iface */\n    args[1] = WOWGlobalAllocLock16( 0, sizeof(CLSID), &hclsid );\n    args[2] = sizeof(CLSID);\n    args[3] = WOWGlobalAllocLock16( 0, sizeof(ULONG), &hread );\n\n    if (WOWCallback16Ex(\n        GET_SEGPTR_METHOD_ADDR(IStream16, stream, Read),\n        WCB16_PASCAL,\n        4*sizeof(DWORD),\n        args,\n        (DWORD*)&hres))\n    {\n        ULONG readlen;\n\n        memcpy(&readlen, MapSL(args[3]), sizeof(readlen));\n        if (readlen == sizeof(CLSID))\n            memcpy(clsid, MapSL(args[1]), sizeof(CLSID));\n        else\n            hres = STG_E_READFAULT;\n\n        TRACE(\"clsid is %s\\n\", debugstr_guid(clsid));\n    }\n    else\n    {\n        ERR(\"CallTo16 IStream16::Read() failed, hres %x\\n\", hres);\n        hres = E_FAIL;\n    }\n    WOWGlobalUnlockFree16(args[1]);\n    WOWGlobalUnlockFree16(args[3]);\n\n    return hres;\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n *              OleDoAutoConvert        [OLE2.79]\n */\n", "func_signal": "HRESULT WINAPI OleDoAutoConvert16(LPSTORAGE pStg, LPCLSID pClsidNew)", "code": "{\n    FIXME(\"(%p,%p) : stub\\n\",pStg,pClsidNew);\n    return E_NOTIMPL;\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n * This is the constructor for the HGLOBALLockBytesImpl16 class.\n *\n * Params:\n *    hGlobal          - Handle that will support the stream. can be NULL.\n *    fDeleteOnRelease - Flag set to TRUE if the HGLOBAL16 will be released\n *                       when the IStream object is destroyed.\n */\n", "func_signal": "static HGLOBALLockBytesImpl16*\nHGLOBALLockBytesImpl16_Construct(HGLOBAL16 hGlobal,\n\t\t\t\t BOOL16 fDeleteOnRelease)", "code": "{\n  HGLOBALLockBytesImpl16* newLockBytes;\n\n  static ILockBytes16Vtbl vt16;\n\n\n  TRACE(\"(%x,%d)\\n\",hGlobal,fDeleteOnRelease);\n  newLockBytes = HeapAlloc(GetProcessHeap(), 0, sizeof(HGLOBALLockBytesImpl16));\n  if (newLockBytes == NULL)\n    return NULL;\n\n  /*\n   * Set up the virtual function table and reference count.\n   */\n  if (!msegvt16)\n  {\n      HMODULE16 hcomp = GetModuleHandle16(\"OLE2\");\n#define VTENT(x) vt16.x = (void*)GetProcAddress16(hcomp,\"HGLOBALLockBytesImpl16_\"#x);assert(vt16.x)\n      VTENT(QueryInterface);\n      VTENT(AddRef);\n      VTENT(Release);\n      VTENT(ReadAt);\n      VTENT(WriteAt);\n      VTENT(Flush);\n      VTENT(SetSize);\n      VTENT(LockRegion);\n      VTENT(UnlockRegion);\n      VTENT(Stat);\n#undef VTENT\n      msegvt16 = MapLS( &vt16 );\n  }\n  newLockBytes->ILockBytes16_iface.lpVtbl = (const ILockBytes16Vtbl*)msegvt16;\n  newLockBytes->ref = 0;\n  /*\n   * Initialize the support.\n   */\n  newLockBytes->supportHandle = hGlobal;\n  newLockBytes->deleteOnRelease = fDeleteOnRelease;\n\n  /*\n   * This method will allocate a handle if one is not supplied.\n   */\n  if (newLockBytes->supportHandle == 0)\n    newLockBytes->supportHandle = GlobalAlloc16(GMEM_MOVEABLE | GMEM_NODISCARD, 0);\n\n  /*\n   * Initialize the size of the array to the size of the handle.\n   */\n  newLockBytes->byteArraySize.u.HighPart = 0;\n  newLockBytes->byteArraySize.u.LowPart  = GlobalSize16(\n\t\t\t\t\t    newLockBytes->supportHandle);\n\n  return (HGLOBALLockBytesImpl16*)MapLS(newLockBytes);\n}", "path": "winevdm/ole2/memlockbytes.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/**********************************************************************\n *\t    DOSVM_Int26Handler\n *\n * Handler for int 26h (absolute disk write).\n */\n", "func_signal": "void WINAPI DOSVM_Int26Handler( CONTEXT *context )", "code": "{\n    WCHAR drivespec[] = {'A', ':', '\\\\', 0};\n    BYTE *dataptr = CTX_SEG_OFF_TO_LIN( context, context->SegDs, context->Ebx );\n    DWORD begin;\n    DWORD length;\n\n    drivespec[0] += AL_reg( context );\n\n    if (GetDriveTypeW( drivespec ) == DRIVE_NO_ROOT_DIR || \n        GetDriveTypeW( drivespec ) == DRIVE_UNKNOWN)\n    {\n        SET_CFLAG( context );\n        SET_AX( context, 0x0201 ); /* unknown unit */\n        return;\n    }\n\n    if (CX_reg( context ) == 0xffff)\n    {\n        begin   = *(DWORD *)dataptr;\n        length  = *(WORD *)(dataptr + 4);\n        dataptr = (BYTE *)CTX_SEG_OFF_TO_LIN( context,\n                                              *(WORD *)(dataptr + 8), \n                                              *(DWORD *)(dataptr + 6) );\n    }\n    else\n    {\n        begin  = DX_reg( context );\n        length = CX_reg( context );\n    }\n\n    DOSVM_RawWrite( AL_reg( context ), begin, length, dataptr, TRUE );\n    RESET_CFLAG( context );\n}", "path": "winevdm/krnl386/int26.c", "commit_date": "2015-09-22 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/***********************************************************************\n *           DllGetClassObject (OLE2.4)\n */\n", "func_signal": "HRESULT WINAPI DllGetClassObject16(REFCLSID rclsid, REFIID iid, LPVOID *ppv)", "code": "{\n  FIXME(\"(%s, %s, %p): stub\\n\", debugstr_guid(rclsid), debugstr_guid(iid), ppv);\n  return E_NOTIMPL;\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n * This is the destructor of the HGLOBALStreamImpl class.\n *\n * This method will clean-up all the resources used-up by the given\n * HGLOBALLockBytesImpl16 class. The pointer passed-in to this function will be\n * freed and will not be valid anymore.\n */\n", "func_signal": "static void HGLOBALLockBytesImpl16_Destroy(HGLOBALLockBytesImpl16* This)", "code": "{\n  TRACE(\"()\\n\");\n  /*\n   * Release the HGlobal if the constructor asked for that.\n   */\n  if (This->deleteOnRelease)\n  {\n    GlobalFree16(This->supportHandle);\n    This->supportHandle = 0;\n  }\n\n  /*\n   * Finally, free the memory used-up by the class.\n   */\n  HeapFree(GetProcessHeap(), 0, This);\n}", "path": "winevdm/ole2/memlockbytes.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n * This implements the IUnknown method Release for this\n * class\n */\n", "func_signal": "ULONG CDECL HGLOBALLockBytesImpl16_Release(ILockBytes16* iface)", "code": "{\n  HGLOBALLockBytesImpl16* const This = impl_from_ILockBytes16(iface);\n  ULONG ref;\n\n  TRACE(\"(%p)\\n\",This);\n\n  ref = InterlockedDecrement(&This->ref);\n\n  /*\n   * If the reference count goes down to 0, perform suicide.\n   */\n  if (ref==0)\n    HGLOBALLockBytesImpl16_Destroy(This);\n  return ref;\n}", "path": "winevdm/ole2/memlockbytes.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n *        CreateItemMoniker\t(OLE2.27)\n */\n", "func_signal": "HRESULT WINAPI CreateItemMoniker16(LPCOLESTR16 lpszDelim,LPCOLESTR16 lpszItem,SEGPTR* ppmk)", "code": "{\n    LPMONIKER pmk;\n    HRESULT result;\n    LPOLESTR wdelim = strdupAtoW(lpszDelim);\n    LPOLESTR witem = strdupAtoW(lpszItem);\n    TRACE(\"(%s,%s,%p)\\n\",lpszDelim,lpszItem,ppmk);\n    result = hresult32_16(CreateItemMoniker(wdelim, witem, &pmk));\n    HeapFree(GetProcessHeap(), 0, wdelim);\n    HeapFree(GetProcessHeap(), 0, witem);\n    *ppmk = iface32_16(&IID_IMoniker, pmk);\n    return result;\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n *              OleLoad        [OLE2.12]\n *\n * PARAMS\n *  pStg Segmented LPSTORAGE pointer.\n *  pClientSite Segmented LPOLECLIENTSITE pointer.\n */\n", "func_signal": "HRESULT WINAPI OleLoad16(\n    SEGPTR\t\tpStg,\n    REFIID            \triid,\n    SEGPTR\t\tpClientSite,\n    SEGPTR*\t\tppvObj)", "code": "{\n    HRESULT result;\n    LPVOID pvObj = NULL;\n    TRACE(\"(%08x,%s,%08x,%p)\\n\", pStg, debugstr_guid(riid), pClientSite, ppvObj);\n    result = hresult32_16(OleLoad((IStorage*)iface16_32(&IID_IStorage, pStg), riid, (IOleClientSite*)iface16_32(&IID_IOleClientSite, pClientSite), &pvObj));\n    *ppvObj = iface32_16(riid, pvObj);\n    return result;\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/***********************************************************************\n *    ReadClassStg (OLE2.18)\n *\n * This method reads the CLSID previously written to a storage object with\n * the WriteClassStg.\n *\n * PARAMS\n *  pstg    [I] Segmented LPSTORAGE pointer.\n *  pclsid  [O] Pointer to where the CLSID is written\n *\n * RETURNS\n *  Success: S_OK.\n *  Failure: HRESULT code.\n */\n", "func_signal": "HRESULT WINAPI ReadClassStg16(SEGPTR pstg, CLSID *pclsid)", "code": "{\n\tSTATSTG16 statstg;\n\tHANDLE16 hstatstg;\n\tHRESULT\thres;\n\tDWORD args[3];\n\n\tTRACE(\"(%x, %p)\\n\", pstg, pclsid);\n\n\tif (!pclsid)\n\t    return E_INVALIDARG16;\n\n\tmemset(pclsid, 0, sizeof(*pclsid));\n\n\tif (!pstg)\n\t    return E_INVALIDARG16;\n\n\t/*\n\t * read a STATSTG structure (contains the clsid) from the storage\n\t */\n\targs[0] = pstg; /* iface */\n\targs[1] = WOWGlobalAllocLock16( 0, sizeof(STATSTG16), &hstatstg );\n\targs[2] = STATFLAG_DEFAULT;\n\n\tif (!WOWCallback16Ex(\n\t    GET_SEGPTR_METHOD_ADDR(IStorage16, pstg, Stat),\n\t    WCB16_PASCAL,\n\t    3*sizeof(DWORD),\n\t    args,\n\t    (LPDWORD)&hres\n\t)) {\n\t    WOWGlobalUnlockFree16(args[1]);\n            ERR(\"CallTo16 IStorage16::Stat() failed, hres %x\\n\",hres);\n\t    return hres;\n\t}\n\tmemcpy(&statstg, MapSL(args[1]), sizeof(STATSTG16));\n\tWOWGlobalUnlockFree16(args[1]);\n\n\tif(SUCCEEDED(hres)) {\n\t\t*pclsid=statstg.clsid;\n\t\tTRACE(\"clsid is %s\\n\", debugstr_guid(&statstg.clsid));\n\t}\n\treturn hres;\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/***********************************************************************\n *           DOSVM_RawWrite\n *\n * Write raw sectors to a device.\n */\n", "func_signal": "BOOL DOSVM_RawWrite(BYTE drive, DWORD begin, DWORD nr_sect, BYTE *dataptr, BOOL fake_success)", "code": "{\n    WCHAR root[] = {'\\\\','\\\\','.','\\\\','A',':',0};\n    HANDLE h;\n    DWORD w;\n\n    TRACE( \"abs diskwrite, drive %d, sector %d, \"\n           \"count %d, buffer %p\\n\",\n           drive, begin, nr_sect, dataptr );\n\n    root[4] += drive;\n    h = CreateFileW(root, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING,\n                    0, NULL);\n    if (h != INVALID_HANDLE_VALUE)\n    {\n        SetFilePointer(h, begin * 512, NULL, SEEK_SET );\n        /* FIXME: check errors */\n        WriteFile( h, dataptr, nr_sect * 512, &w, NULL );\n        CloseHandle( h );\n    }\n    else if (!fake_success)\n        return FALSE;\n\n    return TRUE;\n}", "path": "winevdm/krnl386/int26.c", "commit_date": "2015-09-22 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/* OLE2DISP -> OLE2 -> STORAGE -> COMPOBJ */\n/* OLE2 depends on KERNEL GDI USER KEYBOARD SHELL COMPOBJ STORAGE */\n/* COMPOBJ depends on KERNEL USER KEYBOARD SHELL */\n/* STORAGE depends on KERNEL USER KEYBOARD COMPOBJ */\n/* OLE2DISP depends on KERNEL USER WIN87EM SHELL COMPOBJ OLE2 OLE2NLS */\n/* OLE2NLS denends on KERNEL USER */\n/* OLE2PROX depends on KERNEL COMPOBJ OLE2 */\n/* OLE2CONV depends on KERNEL GDI USER */\n", "func_signal": "BOOL WINAPI Ole2_LibMain(DWORD fdwReason, HINSTANCE hinstDLL, WORD ds,\n    WORD wHeapSize, DWORD dwReserved1, WORD wReserved2)", "code": "{\n    LoadLibrary16(\"STORAGE.DLL\");\n    LoadLibrary16(\"COMPOBJ.DLL\");\n    return TRUE;\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/***********************************************************************\n *    WriteClassStm (OLE2.21)\n */\n", "func_signal": "HRESULT WINAPI WriteClassStm16(SEGPTR pStm, REFCLSID rclsid)", "code": "{\n    TRACE(\"(%08x,%s)\\n\", pStm, debugstr_guid(rclsid));\n    return hresult32_16(WriteClassStm((IStream*)iface16_32(&IID_IStream, pStm), rclsid));\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/***********************************************************************\n *           OleInitialize       (OLE2.2)\n */\n", "func_signal": "HRESULT WINAPI OleInitialize16(SEGPTR pMalloc)", "code": "{\n    HMODULE comp = GetModuleHandleA(\"compobj.dll16\");\n    HRESULT ret;\n    if (!comp)\n    {\n        comp = LoadLibraryA(\"compobj.dll16\");\n    }\n    ret = ((HRESULT(WINAPI*)(SEGPTR))GetProcAddress(comp, \"CoInitialize16\"))(pMalloc);\n    if (ret != S_OK /* S_FALSE: already initialized */)\n        return ret;\n    return OleInitialize( NULL );\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n *\t\tOleUninitialize\t(OLE2.3)\n */\n", "func_signal": "void WINAPI OleUninitialize16(void)", "code": "{\n    HMODULE comp = GetModuleHandleA(\"compobj.dll16\");\n    HRESULT ret;\n    if (!comp)\n    {\n        comp = LoadLibraryA(\"compobj.dll16\");\n    }\n    ((void(WINAPI*)())GetProcAddress(comp, \"CoUninitialize16\"))();\n    OleUninitialize();\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/***********************************************************************\n *              GetConvertStg (OLE2.82)\n */\n", "func_signal": "HRESULT WINAPI GetConvertStg16(SEGPTR stg)", "code": "{\n    TRACE(\"(%08x)\\n\", stg);\n    return hresult32_16(GetConvertStg((IStorage*)iface16_32(&IID_IStorage, stg)));\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n * OleMetaFilePictFromIconAndLabel (OLE2.56)\n *\n * Returns a global memory handle to a metafile which contains the icon and\n * label given.\n * I guess the result of that should look somehow like desktop icons.\n * If no hIcon is given, we load the icon via lpszSourceFile and iIconIndex.\n * This code might be wrong at some places.\n */\n", "func_signal": "HGLOBAL16 WINAPI OleMetafilePictFromIconAndLabel16(\n\tHICON16 icon16,\n\tLPCOLESTR16 lpszLabel,\n\tLPCOLESTR16 lpszSourceFile,\n\tUINT16 iIconIndex\n)", "code": "{\n    METAFILEPICT *pict;\n    HGLOBAL hmf;\n    HGLOBAL16 hmf16;\n    LPWSTR label = NULL, source = NULL;\n    DWORD len;\n    HICON icon = convert_icon_to_32( icon16 );\n\n    if (lpszLabel)\n    {\n        len = MultiByteToWideChar( CP_ACP, 0, lpszLabel, -1, NULL, 0 );\n        label = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );\n        MultiByteToWideChar( CP_ACP, 0, lpszLabel, -1, label, len );\n    }\n    if (lpszSourceFile)\n    {\n        len = MultiByteToWideChar( CP_ACP, 0, lpszSourceFile, -1, NULL, 0 );\n        source = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );\n        MultiByteToWideChar( CP_ACP, 0, lpszSourceFile, -1, source, len );\n    }\n    hmf = OleMetafilePictFromIconAndLabel( icon, label, source, iIconIndex );\n    HeapFree( GetProcessHeap(), 0, label );\n    HeapFree( GetProcessHeap(), 0, source );\n    DestroyIcon( icon );\n\n    if (!hmf) return 0;\n    pict = GlobalLock( hmf );\n\n    hmf16 = GlobalAlloc16(0, sizeof(METAFILEPICT16));\n    if (hmf16)\n    {\n        METAFILEPICT16 *pict16 = GlobalLock16( hmf16 );\n        pict16->mm   = pict->mm;\n        pict16->xExt = pict->xExt;\n        pict16->yExt = pict->yExt;\n        len = GetMetaFileBitsEx( pict->hMF, 0, 0 );\n        pict16->hMF = GlobalAlloc16( GMEM_MOVEABLE, len );\n        GetMetaFileBitsEx( pict->hMF, len, GlobalLock16( pict16->hMF) );\n        GlobalUnlock16( pict16->hMF );\n        GlobalUnlock16( hmf16 );\n    }\n    DeleteMetaFile( pict->hMF );\n    GlobalUnlock( hmf );\n    GlobalFree( hmf );\n    return hmf16;\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/******************************************************************************\n *        OleSetMenuDescriptor (OLE2.41)\n *\n * PARAMS\n *  hOleMenu  FIXME: Should probably be an HOLEMENU16.\n */\n", "func_signal": "HRESULT WINAPI OleSetMenuDescriptor16(\n    HOLEMENU               hOleMenu,\n    HWND16                 hwndFrame,\n    HWND16                 hwndActiveObject,\n    LPOLEINPLACEFRAME        lpFrame,\n    LPOLEINPLACEACTIVEOBJECT lpActiveObject)", "code": "{\n    HOLEMENU hOleMenu32;\n    TRACE(\"(%p, %x, %x, %p, %p)\\n\", hOleMenu, hwndFrame, hwndActiveObject, lpFrame, lpActiveObject);\n    hOleMenu32 = HWND_32(hOleMenu); /* FIXME */\n    return hresult32_16(OleSetMenuDescriptor(hOleMenu32, HWND_32(hwndFrame), HWND_32(hwndActiveObject),\n        (IOleInPlaceFrame*)iface16_32(&IID_IOleInPlaceFrame, lpFrame),\n        (IOleInPlaceActiveObject*)iface16_32(&IID_IOleInPlaceActiveObject, lpActiveObject)));\n}", "path": "winevdm/ole2/ole2.c", "commit_date": "2019-04-10 00:00:00", "repo_name": "otya128/winevdm", "stars": 2368, "license": "gpl-2.0", "language": "c", "size": 10526}
{"docstring": "/**\n* @brief  USBD_DeInit \n*         Re-Initialize th device library\n* @param  pdev: device instance\n* @retval status: status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)", "code": "{\n  /* Set Default State */\n  pdev->dev_state  = USBD_STATE_DEFAULT;\n  \n  /* Free Class Resources */\n  pdev->pClass->DeInit(pdev, pdev->dev_config);  \n  \n    /* Stop the low level driver  */\n  USBD_LL_Stop(pdev); \n  \n  /* Initialize low level driver */\n  USBD_LL_DeInit(pdev);\n  \n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_LL_Reset \n*         Handle Reset event\n* @param  pdev: device instance\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)", "code": "{\n  /* Open EP0 OUT */\n  USBD_LL_OpenEP(pdev,\n              0x00,\n              USBD_EP_TYPE_CTRL,\n              USB_MAX_EP0_SIZE);\n  \n  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;\n  \n  /* Open EP0 IN */\n  USBD_LL_OpenEP(pdev,\n              0x80,\n              USBD_EP_TYPE_CTRL,\n              USB_MAX_EP0_SIZE);\n  \n  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;\n  /* Upon Reset call user call back */\n  pdev->dev_state = USBD_STATE_DEFAULT;\n  \n  if (pdev->pClassData) \n    pdev->pClass->DeInit(pdev, pdev->dev_config);  \n \n  \n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_SOF \n*         Handle SOF event\n* @param  pdev: device instance\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)", "code": "{\n  if(pdev->dev_state == USBD_STATE_CONFIGURED)\n  {\n    if(pdev->pClass->SOF != NULL)\n    {\n      pdev->pClass->SOF(pdev);\n    }\n  }\n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_LL_Reset \n*         Handle Reset event\n* @param  pdev: device instance\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)", "code": "{\n  pdev->dev_speed = speed;\n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n  * @brief Disables the WakeUp PINx functionality.\n  * @param WakeUpPinx Specifies the Power Wake-Up pin to disable.\n  *         This parameter can be values of :\n  *           @ref PWREx_WakeUp_Pins\n  * @retval None\n  */\n", "func_signal": "void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));\n  /* Disable the EWUPx pin */\n  CLEAR_BIT(PWR->CSR, WakeUpPinx);\n}", "path": "daytripper/firmware/code/others/old/tx_beforetss/Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_pwr.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_SetClassConfig \n*        Configure device and start the interface\n* @param  pdev: device instance\n* @param  cfgidx: configuration index\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)", "code": "{\n  USBD_StatusTypeDef   ret = USBD_FAIL;\n  \n  if(pdev->pClass != NULL)\n  {\n    /* Set configuration  and Start the Class*/\n    if(pdev->pClass->Init(pdev, cfgidx) == 0)\n    {\n      ret = USBD_OK;\n    }\n  }\n  return ret; \n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_SetupStage \n*         Handle the setup stage\n* @param  pdev: device instance\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)", "code": "{\n\n  USBD_ParseSetupRequest(&pdev->request, psetup);\n  \n  pdev->ep0_state = USBD_EP0_SETUP;\n  pdev->ep0_data_len = pdev->request.wLength;\n  \n  switch (pdev->request.bmRequest & 0x1F) \n  {\n  case USB_REQ_RECIPIENT_DEVICE:   \n    USBD_StdDevReq (pdev, &pdev->request);\n    break;\n    \n  case USB_REQ_RECIPIENT_INTERFACE:     \n    USBD_StdItfReq(pdev, &pdev->request);\n    break;\n    \n  case USB_REQ_RECIPIENT_ENDPOINT:        \n    USBD_StdEPReq(pdev, &pdev->request);   \n    break;\n    \n  default:           \n    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);\n    break;\n  }  \n  return USBD_OK;  \n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_Resume \n*         Handle Resume event\n* @param  pdev: device instance\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)", "code": "{\n  pdev->dev_state = pdev->dev_old_state;  \n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n  * @brief Enters Sleep mode.\n  * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.\n  * @param Regulator Specifies the regulator state in SLEEP mode.\n  *           On STM32F0 devices, this parameter is a dummy value and it is ignored\n  *           as regulator can't be modified in this mode. Parameter is kept for platform\n  *           compatibility.\n  * @param SLEEPEntry Specifies if SLEEP mode is entered with WFI or WFE instruction.\n  *           When WFI entry is used, tick interrupt have to be disabled if not desired as \n  *           the interrupt wake up source.\n  *           This parameter can be one of the following values:\n  *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction\n  *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction\n  * @retval None\n  */\n", "func_signal": "void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_PWR_REGULATOR(Regulator));\n  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));\n\n  /* Clear SLEEPDEEP bit of Cortex System Control Register */\n  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);\n\n  /* Select SLEEP mode entry -------------------------------------------------*/\n  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)\n  {\n    /* Request Wait For Interrupt */\n    __WFI();\n  }\n  else\n  {\n    /* Request Wait For Event */\n    __SEV();\n    __WFE();\n    __WFE();\n  }\n}", "path": "daytripper/firmware/code/others/old/tx_beforetss/Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_pwr.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n  * @brief This function de-Initializes common part of the HAL and stops the source\n  *        of time base.\n  * @note This function is optional.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DeInit(void)", "code": "{\n  /* Reset of all peripherals */\n  __HAL_RCC_APB1_FORCE_RESET();\n  __HAL_RCC_APB1_RELEASE_RESET();\n\n  __HAL_RCC_APB2_FORCE_RESET();\n  __HAL_RCC_APB2_RELEASE_RESET();\n\n  __HAL_RCC_AHB_FORCE_RESET();\n  __HAL_RCC_AHB_RELEASE_RESET();\n\n  /* De-Init the low level hardware */\n  HAL_MspDeInit();\n    \n  /* Return function status */\n  return HAL_OK;\n}", "path": "daytripper/firmware/code/others/old/range_test/usba_rx/Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_ClrClassConfig \n*         Clear current configuration\n* @param  pdev: device instance\n* @param  cfgidx: configuration index\n* @retval status: USBD_StatusTypeDef\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)", "code": "{\n  /* Clear configuration  and De-initialize the Class process*/\n  pdev->pClass->DeInit(pdev, cfgidx);  \n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_DataOutStage \n*         Handle data OUT stage\n* @param  pdev: device instance\n* @param  epnum: endpoint index\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)", "code": "{\n  USBD_EndpointTypeDef    *pep;\n  \n  if(epnum == 0) \n  {\n    pep = &pdev->ep_out[0];\n    \n    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)\n    {\n      if(pep->rem_length > pep->maxpacket)\n      {\n        pep->rem_length -=  pep->maxpacket;\n       \n        USBD_CtlContinueRx (pdev, \n                            pdata,\n                            MIN(pep->rem_length ,pep->maxpacket));\n      }\n      else\n      {\n        if((pdev->pClass->EP0_RxReady != NULL)&&\n           (pdev->dev_state == USBD_STATE_CONFIGURED))\n        {\n          pdev->pClass->EP0_RxReady(pdev); \n        }\n        USBD_CtlSendStatus(pdev);\n      }\n    }\n  }\n  else if((pdev->pClass->DataOut != NULL)&&\n          (pdev->dev_state == USBD_STATE_CONFIGURED))\n  {\n    pdev->pClass->DataOut(pdev, epnum); \n  }  \n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n  * @brief Enters STANDBY mode.\n  * @note  In Standby mode, all I/O pins are high impedance except for:\n  *          - Reset pad (still available)\n  *          - RTC alternate function pins if configured for tamper, time-stamp, RTC\n  *            Alarm out, or RTC clock calibration out.\n  *          - WKUP pins if enabled.\n  *            STM32F0x8 devices, the Stop mode is available, but it is \n  *            aningless to distinguish between voltage regulator in Low power \n  *            mode and voltage regulator in Run mode because the regulator \n  *            not used and the core is supplied directly from an external source.\n  *            Consequently, the Standby mode is not available on those devices.\n  * @retval None\n  */\n", "func_signal": "void HAL_PWR_EnterSTANDBYMode(void)", "code": "{\n  /* Select STANDBY mode */\n  PWR->CR |= (uint32_t)PWR_CR_PDDS;\n\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\n  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\n\n  /* This option is used to ensure that store operations are completed */\n#if defined ( __CC_ARM)\n  __force_stores();\n#endif\n  /* Request Wait For Interrupt */\n  __WFI();\n}", "path": "daytripper/firmware/code/others/old/tx_beforetss/Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_pwr.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_DataInStage \n*         Handle data in stage\n* @param  pdev: device instance\n* @param  epnum: endpoint index\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)", "code": "{\n  USBD_EndpointTypeDef    *pep;\n    \n  if(epnum == 0) \n  {\n    pep = &pdev->ep_in[0];\n    \n    if ( pdev->ep0_state == USBD_EP0_DATA_IN)\n    {\n      if(pep->rem_length > pep->maxpacket)\n      {\n        pep->rem_length -=  pep->maxpacket;\n        \n        USBD_CtlContinueSendData (pdev, \n                                  pdata, \n                                  pep->rem_length);\n        \n        /* Prepare endpoint for premature end of transfer */\n        USBD_LL_PrepareReceive (pdev,\n                                0,\n                                NULL,\n                                0);  \n      }\n      else\n      { /* last packet is MPS multiple, so send ZLP packet */\n        if((pep->total_length % pep->maxpacket == 0) &&\n           (pep->total_length >= pep->maxpacket) &&\n             (pep->total_length < pdev->ep0_data_len ))\n        {\n          \n          USBD_CtlContinueSendData(pdev , NULL, 0);\n          pdev->ep0_data_len = 0;\n          \n        /* Prepare endpoint for premature end of transfer */\n        USBD_LL_PrepareReceive (pdev,\n                                0,\n                                NULL,\n                                0);\n        }\n        else\n        {\n          if((pdev->pClass->EP0_TxSent != NULL)&&\n             (pdev->dev_state == USBD_STATE_CONFIGURED))\n          {\n            pdev->pClass->EP0_TxSent(pdev); \n          }          \n          USBD_CtlReceiveStatus(pdev);\n        }\n      }\n    }\n    if (pdev->dev_test_mode == 1)\n    {\n      USBD_RunTestMode(pdev); \n      pdev->dev_test_mode = 0;\n    }\n  }\n  else if((pdev->pClass->DataIn != NULL)&& \n          (pdev->dev_state == USBD_STATE_CONFIGURED))\n  {\n    pdev->pClass->DataIn(pdev, epnum); \n  }  \n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n  * @brief This function provides accurate delay (in milliseconds) based \n  *        on variable incremented.\n  * @note In the default implementation , SysTick timer is the source of time base.\n  *       It is used to generate interrupts at regular time intervals where uwTick\n  *       is incremented.\n  * @note ThiS function is declared as __weak to be overwritten in case of other\n  *       implementations in user file.\n  * @param Delay specifies the delay time length, in milliseconds.\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_Delay(__IO uint32_t Delay)", "code": "{\n  uint32_t tickstart = HAL_GetTick();\n  uint32_t wait = Delay;\n  \n  /* Add a period to guarantee minimum wait */\n  if (wait < HAL_MAX_DELAY)\n  {\n     wait++;\n  }\n  \n  while((HAL_GetTick() - tickstart) < wait)\n  {\n  }\n}", "path": "daytripper/firmware/code/others/old/range_test/usba_rx/Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_DevDisconnected \n*         Handle device disconnection event\n* @param  pdev: device instance\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)", "code": "{\n  /* Free Class Resources */\n  pdev->dev_state = USBD_STATE_DEFAULT;\n  pdev->pClass->DeInit(pdev, pdev->dev_config);  \n   \n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n* @brief  USBD_Suspend \n*         Handle Suspend event\n* @param  pdev: device instance\n* @retval status\n*/\n", "func_signal": "USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)", "code": "{\n  pdev->dev_old_state =  pdev->dev_state;\n  pdev->dev_state  = USBD_STATE_SUSPENDED;\n  return USBD_OK;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n  * @brief  USBD_RegisterClass \n  *         Link class driver to Device Core.\n  * @param  pDevice : Device Handle\n  * @param  pclass: Class handle\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)", "code": "{\n  USBD_StatusTypeDef   status = USBD_OK;\n  if(pclass != 0)\n  {\n    /* link the class to the USB Device handle */\n    pdev->pClass = pclass;\n    status = USBD_OK;\n  }\n  else\n  {\n    USBD_ErrLog(\"Invalid Class handle\");\n    status = USBD_FAIL; \n  }\n  \n  return status;\n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n  * @brief  USBD_Stop \n  *         Stop the USB Device Core.\n  * @param  pdev: Device Handle\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)", "code": "{\n  /* Free Class Resources */\n  pdev->pClass->DeInit(pdev, pdev->dev_config);  \n\n  /* Stop the low level driver  */\n  USBD_LL_Stop(pdev); \n  \n  return USBD_OK;  \n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n  * @brief  USBD_Start \n  *         Start the USB Device Core.\n  * @param  pdev: Device Handle\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)", "code": "{\n  \n  /* Start the low level driver  */\n  USBD_LL_Start(pdev); \n  \n  return USBD_OK;  \n}", "path": "daytripper/firmware/code/others/experimental/tx_eeprom_new_sensor/Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "dekuNukem/daytripper", "stars": 3633, "license": "mit", "language": "c", "size": 305344}
{"docstring": "/**\n * Convert the input data to a bit stream.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n */\n", "func_signal": "static int QRinput_createBitStream(QRinput *input, BitStream *bstream)", "code": "{\n\tQRinput_List *list;\n\tint bits, total = 0;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tbits = QRinput_encodeBitStream(list, bstream, input->version, input->mqr);\n\t\tif(bits < 0) return -1;\n\t\ttotal += bits;\n\t\tlist = list->next;\n\t}\n\n\treturn total;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Convert the number data and append to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n */\n", "func_signal": "static int QRinput_encodeModeNum(QRinput_List *entry, BitStream *bstream, int version, int mqr)", "code": "{\n\tint words, i, ret;\n\tunsigned int val;\n\n\tif(mqr) {\n\t\tif(version > 1) {\n\t\t\tret = BitStream_appendNum(bstream, (size_t)(version - 1), MQRSPEC_MODEID_NUM);\n\t\t\tif(ret < 0) return -1;\n\t\t}\n\t\tret = BitStream_appendNum(bstream, (size_t)MQRspec_lengthIndicator(QR_MODE_NUM, version), (unsigned int)entry->size);\n\t\tif(ret < 0) return -1;\n\t} else {\n\t\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_NUM);\n\t\tif(ret < 0) return -1;\n\n\t\tret = BitStream_appendNum(bstream, (size_t)QRspec_lengthIndicator(QR_MODE_NUM, version), (unsigned int)entry->size);\n\t\tif(ret < 0) return -1;\n\t}\n\n\twords = entry->size / 3;\n\tfor(i = 0; i < words; i++) {\n\t\tval  = (unsigned int)(entry->data[i*3  ] - '0') * 100;\n\t\tval += (unsigned int)(entry->data[i*3+1] - '0') * 10;\n\t\tval += (unsigned int)(entry->data[i*3+2] - '0');\n\n\t\tret = BitStream_appendNum(bstream, 10, val);\n\t\tif(ret < 0) return -1;\n\t}\n\n\tif(entry->size - words * 3 == 1) {\n\t\tval = (unsigned int)(entry->data[words*3] - '0');\n\t\tret = BitStream_appendNum(bstream, 4, val);\n\t\tif(ret < 0) return -1;\n\t} else if(entry->size - words * 3 == 2) {\n\t\tval  = (unsigned int)(entry->data[words*3  ] - '0') * 10;\n\t\tval += (unsigned int)(entry->data[words*3+1] - '0');\n\t\tret = BitStream_appendNum(bstream, 7, val);\n\t\tif(ret < 0) return -1;\n\t}\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\n", "func_signal": "static int QRinput_checkModeAn(int size, const char *data)", "code": "{\n\tint i;\n\n\tfor(i = 0; i < size; i++) {\n\t\tif(QRinput_lookAnTable(data[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Append padding bits for the input data - Micro QR Code version.\n * @param bstream Bitstream to be appended.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ERANGE input data is too large.\n * @throw ENOMEM unable to allocate memory.\n */\n", "func_signal": "static int QRinput_appendPaddingBitMQR(BitStream *bstream, QRinput *input)", "code": "{\n\tint bits, maxbits, words, maxwords, i, ret, termbits;\n\tint padlen;\n\n\tbits = (int)BitStream_size(bstream);\n\tmaxbits = MQRspec_getDataLengthBit(input->version, input->level);\n\tmaxwords = maxbits / 8;\n\n\tif(maxbits < bits) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\tif(maxbits == bits) {\n\t\treturn 0;\n\t}\n\n\ttermbits = input->version * 2 + 1;\n\n\tif(maxbits - bits <= termbits) {\n\t\treturn (int)BitStream_appendNum(bstream, (size_t)(maxbits - bits), 0);\n\t}\n\n\tbits += termbits;\n\n\twords = (bits + 7) / 8;\n\tif(maxbits - words * 8 > 0) {\n\t\ttermbits += words * 8 - bits;\n\t\tif(words == maxwords) termbits += maxbits - words * 8;\n\t} else {\n\t\ttermbits += words * 8 - bits;\n\t}\n\tret = (int)BitStream_appendNum(bstream, (size_t)termbits, 0);\n\tif(ret < 0) return ret;\n\n\tpadlen = maxwords - words;\n\tif(padlen > 0) {\n\t\tfor(i = 0; i < padlen; i++) {\n\t\t\tret = (int)BitStream_appendNum(bstream, 8, (i&1)?0x11:0xec);\n\t\t\tif(ret < 0) return ret;\n\t\t}\n\t\ttermbits = maxbits - maxwords * 8;\n\t\tif(termbits > 0) {\n\t\t\tret = (int)BitStream_appendNum(bstream, (size_t)termbits, 0);\n\t\t\tif(ret < 0) return ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Append padding bits for the input data.\n * @param bstream Bitstream to be appended.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ERANGE input data is too large.\n * @throw ENOMEM unable to allocate memory.\n */\n", "func_signal": "static int QRinput_appendPaddingBit(BitStream *bstream, QRinput *input)", "code": "{\n\tint bits, maxbits, words, maxwords, i, ret;\n\tint padlen;\n\n\tbits = (int)BitStream_size(bstream);\n\tmaxwords = QRspec_getDataLength(input->version, input->level);\n\tmaxbits = maxwords * 8;\n\n\tif(maxbits < bits) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\tif(maxbits == bits) {\n\t\treturn 0;\n\t}\n\n\tif(maxbits - bits <= 4) {\n\t\treturn (int)BitStream_appendNum(bstream, (size_t)(maxbits - bits), 0);\n\t}\n\n\twords = (bits + 4 + 7) / 8;\n\n\tret = (int)BitStream_appendNum(bstream, (size_t)(words * 8 - bits), 0);\n\tif(ret < 0) return ret;\n\n\tpadlen = maxwords - words;\n\tif(padlen > 0) {\n\t\tfor(i = 0; i < padlen; i++) {\n\t\t\tret = (int)BitStream_appendNum(bstream, 8, (i&1)?0x11:0xec);\n\t\t\tif(ret < 0) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\n", "func_signal": "STATIC_IN_RELEASE unsigned char MQRraw_getCode(MQRRawCode *raw)", "code": "{\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\tret = raw->datacode[raw->count];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\tret = raw->ecccode[raw->count - raw->dataLength];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}", "path": "libqrencode/qrencode.c", "commit_date": "2020-08-29 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Merge all bit streams in the input data.\n * @param input input data.\n * @return merged bit stream\n */\n", "func_signal": "STATIC_IN_RELEASE int QRinput_mergeBitStream(QRinput *input, BitStream *bstream)", "code": "{\n\tif(input->mqr) {\n\t\tif(QRinput_createBitStream(input, bstream) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif(input->fnc1) {\n\t\t\tif(QRinput_insertFNC1Header(input) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif(QRinput_convertData(input, bstream) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/* from the specification */\n", "func_signal": "static unsigned char *readStdin(int *length)", "code": "{\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = (unsigned char *)malloc(MAX_DATA_SIZE + 1);\n\tif(buffer == NULL) {\n\t\tfprintf(stderr, \"Memory allocation failed.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tret = fread(buffer, 1, MAX_DATA_SIZE, stdin);\n\tif(ret == 0) {\n\t\tfprintf(stderr, \"No input data.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif(feof(stdin) == 0) {\n\t\tfprintf(stderr, \"Input data is too large.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tbuffer[ret] = '\\0';\n\t*length = ret;\n\n\treturn buffer;\n}", "path": "libqrencode/tests/view_qrcode.c", "commit_date": "2017-10-05 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Estimate the length of the encoded bit stream on the current version.\n * @param entry\n * @param version version of the symbol\n * @param mqr\n * @return number of bits\n */\n", "func_signal": "static int QRinput_estimateBitStreamSizeOfEntry(QRinput_List *entry, int version, int mqr)", "code": "{\n\tint bits = 0;\n\tint l, m;\n\tint num;\n\n\tif(version == 0) version = 1;\n\n\tswitch(entry->mode) {\n\t\tcase QR_MODE_NUM:\n\t\t\tbits = QRinput_estimateBitsModeNum(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_AN:\n\t\t\tbits = QRinput_estimateBitsModeAn(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_8:\n\t\t\tbits = QRinput_estimateBitsMode8(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_KANJI:\n\t\t\tbits = QRinput_estimateBitsModeKanji(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_STRUCTURE:\n\t\t\treturn STRUCTURE_HEADER_SIZE;\n\t\tcase QR_MODE_ECI:\n\t\t\tbits = QRinput_estimateBitsModeECI(entry->data);\n\t\t\tbreak;\n\t\tcase QR_MODE_FNC1FIRST:\n\t\t\treturn MODE_INDICATOR_SIZE;\n\t\tcase QR_MODE_FNC1SECOND:\n\t\t\treturn MODE_INDICATOR_SIZE + 8;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\tif(mqr) {\n\t\tl = MQRspec_lengthIndicator(entry->mode, version);\n\t\tm = version - 1;\n\t\tbits += l + m;\n\t} else {\n\t\tl = QRspec_lengthIndicator(entry->mode, version);\n\t\tm = 1 << l;\n\t\tif(entry->mode == QR_MODE_KANJI) {\n\t\t\tnum = (entry->size/2 + m - 1) / m;\n\t\t} else {\n\t\t\tnum = (entry->size + m - 1) / m;\n\t\t}\n\n\t\tbits += num * (MODE_INDICATOR_SIZE + l);\n\t}\n\n\treturn bits;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\n", "func_signal": "static int QRinput_checkModeNum(int size, const char *data)", "code": "{\n\tint i;\n\n\tfor(i = 0; i < size; i++) {\n\t\tif(data[i] < '0' || data[i] > '9')\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Estimate the length of the encoded bit stream of alphabet-numeric data.\n * @param size\n * @return number of bits\n */\n", "func_signal": "int QRinput_estimateBitsModeAn(int size)", "code": "{\n\tint w;\n\tint bits;\n\n\tw = size / 2;\n\tbits = w * 11;\n\tif(size & 1) {\n\t\tbits += 6;\n\t}\n\n\treturn bits;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Estimate the length of the encoded bit stream of the data.\n * @param input input data\n * @param version version of the symbol\n * @return number of bits\n */\n", "func_signal": "STATIC_IN_RELEASE int QRinput_estimateBitStreamSize(QRinput *input, int version)", "code": "{\n\tQRinput_List *list;\n\tint bits = 0;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tbits += QRinput_estimateBitStreamSizeOfEntry(list, version, input->mqr);\n\t\tlist = list->next;\n\t}\n\n\treturn bits;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Estimate the length of the encoded bit stream of numeric data.\n * @param size\n * @return number of bits\n */\n", "func_signal": "int QRinput_estimateBitsModeNum(int size)", "code": "{\n\tint w;\n\tint bits;\n\n\tw = size / 3;\n\tbits = w * 10;\n\tswitch(size - w * 3) {\n\t\tcase 1:\n\t\t\tbits += 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbits += 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn bits;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Convert a structure symbol code and append to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid entry.\n */\n", "func_signal": "static int QRinput_encodeModeStructure(QRinput_List *entry, BitStream *bstream, int mqr)", "code": "{\n\tint ret;\n\n\tif(mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_STRUCTURE);\n\tif(ret < 0) return -1;\n\tret = BitStream_appendNum(bstream, 4, entry->data[1] - 1U);\n\tif(ret < 0) return -1;\n\tret = BitStream_appendNum(bstream, 4, entry->data[0] - 1U);\n\tif(ret < 0) return -1;\n\tret = BitStream_appendNum(bstream, 8, entry->data[2]);\n\tif(ret < 0) return -1;\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Convert the kanji data and append to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid version.\n */\n", "func_signal": "static int QRinput_encodeModeKanji(QRinput_List *entry, BitStream *bstream, int version, int mqr)", "code": "{\n\tint ret, i;\n\tunsigned int val, h;\n\n\tif(mqr) {\n\t\tif(version < 2) {\n\t\t\terrno = ERANGE;\n\t\t\treturn -1;\n\t\t}\n\t\tret = BitStream_appendNum(bstream, (size_t)(version - 1), MQRSPEC_MODEID_KANJI);\n\t\tif(ret < 0) return -1;\n\t\tret = BitStream_appendNum(bstream, (size_t)MQRspec_lengthIndicator(QR_MODE_KANJI, version), (unsigned int)entry->size/2);\n\t\tif(ret < 0) return -1;\n\t} else {\n\t\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_KANJI);\n\t\tif(ret < 0) return -1;\n\t\tret = BitStream_appendNum(bstream, (size_t)QRspec_lengthIndicator(QR_MODE_KANJI, version), (unsigned int)entry->size/2);\n\t\tif(ret < 0) return -1;\n\t}\n\n\tfor(i = 0; i < entry->size; i+=2) {\n\t\tval = ((unsigned int)entry->data[i] << 8) | entry->data[i+1];\n\t\tif(val <= 0x9ffc) {\n\t\t\tval -= 0x8140;\n\t\t} else {\n\t\t\tval -= 0xc140;\n\t\t}\n\t\th = (val >> 8) * 0xc0;\n\t\tval = (val & 0xff) + h;\n\n\t\tret = BitStream_appendNum(bstream, 13, val);\n\t\tif(ret < 0) return -1;\n\t}\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/******************************************************************************\n * Structured input data\n *****************************************************************************/\n", "func_signal": "static QRinput_InputList *QRinput_InputList_newEntry(QRinput *input)", "code": "{\n\tQRinput_InputList *entry;\n\n\tentry = (QRinput_InputList *)malloc(sizeof(QRinput_InputList));\n\tif(entry == NULL) return NULL;\n\n\tentry->input = input;\n\tentry->next = NULL;\n\n\treturn entry;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\n", "func_signal": "static int QRinput_checkModeKanji(int size, const unsigned char *data)", "code": "{\n\tint i;\n\tunsigned int val;\n\n\tif(size & 1)\n\t\treturn -1;\n\n\tfor(i = 0; i < size; i+=2) {\n\t\tval = ((unsigned int)data[i] << 8) | data[i+1];\n\t\tif(val < 0x8140 || (val > 0x9ffc && val < 0xe040) || val > 0xebbf) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Pack all bit streams padding bits into a byte array.\n * @param input input data.\n * @return padded merged byte stream\n */\n", "func_signal": "unsigned char *QRinput_getByteStream(QRinput *input)", "code": "{\n\tBitStream *bstream;\n\tunsigned char *array;\n\tint ret;\n\n\tbstream = BitStream_new();\n\tif(bstream == NULL) {\n\t\treturn NULL;\n\t}\n\n\tret = QRinput_getBitStream(input, bstream);\n\tif(ret < 0) {\n\t\tBitStream_free(bstream);\n\t\treturn NULL;\n\t}\n\tarray = BitStream_toByte(bstream);\n\tBitStream_free(bstream);\n\n\treturn array;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/**\n * Return required length in bytes for specified mode, version and bits.\n * @param mode\n * @param version\n * @param bits\n * @return required length of code words in bytes.\n */\n", "func_signal": "STATIC_IN_RELEASE int QRinput_lengthOfCode(QRencodeMode mode, int version, int bits)", "code": "{\n\tint payload, size, chunks, remain, maxsize;\n\n\tpayload = bits - 4 - QRspec_lengthIndicator(mode, version);\n\tswitch(mode) {\n\t\tcase QR_MODE_NUM:\n\t\t\tchunks = payload / 10;\n\t\t\tremain = payload - chunks * 10;\n\t\t\tsize = chunks * 3;\n\t\t\tif(remain >= 7) {\n\t\t\t\tsize += 2;\n\t\t\t} else if(remain >= 4) {\n\t\t\t\tsize += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QR_MODE_AN:\n\t\t\tchunks = payload / 11;\n\t\t\tremain = payload - chunks * 11;\n\t\t\tsize = chunks * 2;\n\t\t\tif(remain >= 6) size++;\n\t\t\tbreak;\n\t\tcase QR_MODE_8:\n\t\t\tsize = payload / 8;\n\t\t\tbreak;\n\t\tcase QR_MODE_KANJI:\n\t\t\tsize = (payload / 13) * 2;\n\t\t\tbreak;\n\t\tcase QR_MODE_STRUCTURE:\n\t\t\tsize = payload / 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t}\n\tmaxsize = QRspec_maximumWords(mode, version);\n\tif(size < 0) size = 0;\n\tif(maxsize > 0 && size > maxsize) size = maxsize;\n\n\treturn size;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/******************************************************************************\n * Entry of input data\n *****************************************************************************/\n", "func_signal": "static QRinput_List *QRinput_List_newEntry(QRencodeMode mode, int size, const unsigned char *data)", "code": "{\n\tQRinput_List *entry;\n\n\tif(QRinput_check(mode, size, data)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tentry = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(entry == NULL) return NULL;\n\n\tentry->mode = mode;\n\tentry->size = size;\n\tentry->data = NULL;\n\tif(size > 0) {\n\t\tentry->data = (unsigned char *)malloc((size_t)size);\n\t\tif(entry->data == NULL) {\n\t\t\tfree(entry);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(entry->data, data, (size_t)size);\n\t}\n\tentry->bstream = NULL;\n\tentry->next = NULL;\n\n\treturn entry;\n}", "path": "libqrencode/qrinput.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "fukuchi/libqrencode", "stars": 2395, "license": "lgpl-2.1", "language": "c", "size": 1758}
{"docstring": "/* parse address range */\n", "func_signal": "static int parse_range(char *str)", "code": "{\n\tchar *tok, *endp;\n\tint a0, ae;\n\tint j, cnt;\n\n\tcnt = 0;\n\tfor (tok = strtok(str, \",;\"); tok; tok = strtok(NULL, \",;\")) {\n\t\ta0 = ae = strtoul(tok, &endp, 0);\n\t\tif (endp <= tok)\n\t\t\terr(1, \"parsing range '%s'\", tok);\n\t\tif (*endp == '-') {\n\t\t\ttok = endp+1;\n\t\t\tae = strtoul(tok, &endp, 0);\n\t\t\tif (endp <= tok)\n\t\t\t\terr(1, \"parsing addr '%s'\", tok);\n\t\t\tif (ae < a0)\n\t\t\t\tae = a0;\n\t\t}\n\t\tfor (j = a0; j <= ae; ++j, ++cnt) {\n\t\t\tif (j == J1939_IDLE_ADDR)\n\t\t\t\tbreak;\n\t\t\taddr[j].flags |= F_USE;\n\t\t}\n\t}\n\treturn cnt;\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* lookup by name */\n", "func_signal": "static int lookup_name(uint64_t name)", "code": "{\n\tint j;\n\n\tfor (j = 0; j < J1939_IDLE_ADDR; ++j) {\n\t\tif (addr[j].name == name)\n\t\t\treturn j;\n\t}\n\treturn J1939_IDLE_ADDR;\n\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* number of bargraph elements */\n", "func_signal": "void print_usage(char *prg)", "code": "{\n\tfprintf(stderr, \"%s - ISO15765-2 protocol performance visualisation.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -x <addr>    (extended addressing mode)\\n\");\n\tfprintf(stderr, \"         -X <addr>    (extended addressing mode (rx addr))\\n\");\n\tfprintf(stderr, \"\\nCAN IDs and addresses are given and expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"\\n\");\n}", "path": "can-utils/isotpperf.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* substitute math.h function log10(value)+1 */\n", "func_signal": "unsigned int getdigits(unsigned int value)", "code": "{\n\tint  digits = 1;\n\n\twhile (value > 9) {\n\t\tdigits++;\n\t\tvalue /= 10;\n\t}\n\treturn digits;\n}", "path": "can-utils/isotpperf.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* real IO function */\n", "func_signal": "static int repeat_address(int sock, uint64_t name)", "code": "{\n\tint ret;\n\tuint8_t dat[8];\n\tstatic const struct sockaddr_can saddr = {\n\t\t.can_family = AF_CAN,\n\t\t.can_addr.j1939 = {\n\t\t\t.pgn = J1939_PGN_ADDRESS_CLAIMED,\n\t\t\t.addr = J1939_NO_ADDR,\n\t\t},\n\t};\n\n\tmemcpy(dat, &name, 8);\n\tif (!host_is_little_endian())\n\t\tbswap(dat, 8);\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- send(, %\" PRId64 \", 8, 0);\\n\", name);\n\tret = sendto(sock, dat, sizeof(dat), 0, (const struct sockaddr *)&saddr,\n\t\t     sizeof(saddr));\n\tif (must_warn(ret))\n\t\tfprintf(stderr, \"send address claim for 0x%02x\\n\", s.last_sa);\n\treturn ret;\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* signa handling */\n", "func_signal": "static void sighandler(int sig, siginfo_t *info, void *vp)", "code": "{\n\tswitch (sig) {\n\tcase SIGINT:\n\tcase SIGTERM:\n\t\ts.sig_term = 1;\n\t\tbreak;\n\tcase SIGALRM:\n\t\ts.sig_alrm = 1;\n\t\tbreak;\n\tcase SIGUSR1:\n\t\ts.sig_usr1 = 1;\n\t\tbreak;\n\t}\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* retrieve index */\n", "func_signal": "static int libj1939_ifindex(const char *str)", "code": "{\n\tconst struct if_nameindex *lp, *cached = saved;\n\tchar *endp;\n\tint ret;\n\n\tret = strtol(str, &endp, 0);\n\tif (!*endp)\n\t\t/* did some good parse */\n\t\treturn ret;\n\n\tfetch_names();\n\tfor (lp = saved; lp->if_index; ++lp) {\n\t\tif (!strcmp(lp->if_name, str))\n\t\t\treturn lp->if_index;\n\t}\n\tif (cached) {\n\t\tlibj1939_cleanup();\n\t\treturn libj1939_ifindex(str);\n\t}\n\treturn 0;\n}", "path": "can-utils/libj1939.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* cache file */\n", "func_signal": "static void save_cache(void)", "code": "{\n\tFILE *fp;\n\ttime_t t;\n\n\tif (!s.cachefile)\n\t\treturn;\n\tfp = fopen(s.cachefile, \"w\");\n\tif (!fp)\n\t\terr(1, \"fopen %s, w\", s.cachefile);\n\n\ttime(&t);\n\tfprintf(fp, \"# saved on %s\\n\", ctime(&t));\n\tfprintf(fp, \"\\n\");\n\tfprintf(fp, \"0x%02x\\n\", s.current_sa);\n\tfclose(fp);\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* for one line in the logfile */\n", "func_signal": "int main(void)", "code": "{\n\tchar buf[BUFSZ], timestamp[BUFSZ], device[BUFSZ], ascframe[BUFSZ];\n\tstruct canfd_frame cf;\n\tint mtu, maxdlen;\n\n\twhile (fgets(buf, BUFSZ-1, stdin)) {\n\t\tif (sscanf(buf, \"%s %s %s\", timestamp, device, ascframe) != 3)\n\t\t\treturn 1;\n\n\t\tmtu = parse_canframe(ascframe, &cf);\n\t\tif (mtu == CAN_MTU)\n\t\t\tmaxdlen = CAN_MAX_DLEN;\n\t\telse if (mtu == CANFD_MTU)\n\t\t\tmaxdlen = CANFD_MAX_DLEN;\n\t\telse {\n\t\t\tfprintf(stderr, \"read: incomplete CAN frame\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tsprint_long_canframe(ascframe, &cf,\n\t\t\t\t     (CANLIB_VIEW_INDENT_SFF | CANLIB_VIEW_ASCII),\n\t\t\t\t     maxdlen); /* with ASCII output */\n\n\t\tprintf(\"%s  %s  %s\\n\", timestamp, device, ascframe);\n\t}\n\n\treturn 0;\n}", "path": "can-utils/log2long.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/*\n * program\n */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tint ret, sock, opt;\n\tunsigned int j, len;\n\tstruct timeval tref, tdut, ttmp;\n\tstruct sockaddr_can src;\n\tstruct j1939_filter filt;\n\tint filter = 0;\n\tuint8_t priority, dst_addr;\n\tuint64_t dst_name;\n\tlong recvflags;\n\n\t/* argument parsing */\n\twhile ((opt = getopt_long(argc, argv, optstring, long_opts, NULL)) != -1)\n\t\tswitch (opt) {\n\t\tcase 'v':\n\t\t\t++s.verbose;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\ts.pkt_len = strtoul(optarg, 0, 0);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t++s.promisc;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (optarg) {\n\t\t\t\tif (!strchr(\"adzA\", optarg[0]))\n\t\t\t\t\terr(1, \"unknown time option '%c'\",\n\t\t\t\t\t    optarg[0]);\n\t\t\t\ts.time = optarg[0];\n\t\t\t} else {\n\t\t\t\ts.time = 'z';\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfputs(help_msg, stderr);\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\n\tif (argv[optind]) {\n\t\toptarg = argv[optind];\n\t\tret = libj1939_str2addr(optarg, 0, &s.addr);\n\t\tif (ret < 0) {\n\t\t\terr(0, \"bad URI %s\", optarg);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tbuf = malloc(s.pkt_len);\n\tif (!buf)\n\t\terr(1, \"malloc %u\", s.pkt_len);\n\n\t/* setup socket */\n\tsock = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n\tif (sock < 0)\n\t\terr(1, \"socket(can, dgram, j1939)\");\n\n\tmemset(&filt, 0, sizeof(filt));\n\tif (s.addr.can_addr.j1939.name) {\n\t\tfilt.name = s.addr.can_addr.j1939.name;\n\t\tfilt.name_mask = ~0ULL;\n\t\t++filter;\n\t}\n\tif (s.addr.can_addr.j1939.addr < 0xff) {\n\t\tfilt.addr = s.addr.can_addr.j1939.addr;\n\t\tfilt.addr_mask = ~0;\n\t\t++filter;\n\t}\n\tif (s.addr.can_addr.j1939.pgn <= J1939_PGN_MAX) {\n\t\tfilt.pgn = s.addr.can_addr.j1939.pgn;\n\t\tfilt.pgn_mask = ~0;\n\t\t++filter;\n\t}\n\tif (filter) {\n\t\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_FILTER, &filt, sizeof(filt));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt filter\");\n\t}\n\n\tif (s.promisc) {\n\t\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_PROMISC, &ival_1, sizeof(ival_1));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt promisc\");\n\t}\n\n\tif (s.time) {\n\t\tret = setsockopt(sock, SOL_SOCKET, SO_TIMESTAMP, &ival_1, sizeof(ival_1));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt timestamp\");\n\t}\n\tret = setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &s.pkt_len, sizeof(s.pkt_len));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt rcvbuf %u\", s.pkt_len);\n\n\t/* bind(): to default, only ifindex is used. */\n\tmemset(&src, 0, sizeof(src));\n\tsrc.can_ifindex = s.addr.can_ifindex;\n\tsrc.can_family = AF_CAN;\n\tsrc.can_addr.j1939.name = J1939_NO_NAME;\n\tsrc.can_addr.j1939.addr = J1939_NO_ADDR;\n\tsrc.can_addr.j1939.pgn = J1939_NO_PGN;\n\tret = bind(sock, (void *)&src, sizeof(src));\n\tif (ret < 0)\n\t\terr(1, \"bind(%s)\", argv[1]);\n\n\t/* these settings are static and can be held out of the hot path */\n\tiov.iov_base = &buf[0];\n\tmsg.msg_name = &src;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = &ctrlmsg;\n\n\tmemset(&tref, 0, sizeof(tref));\n\tif (s.verbose)\n\t\terr(0, \"listening\");\n\twhile (1) {\n\t\t/* these settings may be modified by recvmsg() */\n\t\tiov.iov_len = s.pkt_len;\n\t\tmsg.msg_namelen = sizeof(src);\n\t\tmsg.msg_controllen = sizeof(ctrlmsg);\n\t\tmsg.msg_flags = 0;\n\n\t\tret = recvmsg(sock, &msg, 0);\n\t\t//ret = recvfrom(buf, s.pkt_len, 0, (void *)&addr, &len);\n\t\tif (ret < 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase ENETDOWN:\n\t\t\t\terr(0, \"ifindex %i\", s.addr.can_ifindex);\n\t\t\t\tcontinue;\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\terr(1, \"recvmsg(ifindex %i)\", s.addr.can_ifindex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlen = ret;\n\t\trecvflags = 0;\n\t\tdst_addr = 0;\n\t\tpriority = 0;\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tswitch (cmsg->cmsg_level) {\n\t\t\tcase SOL_SOCKET:\n\t\t\t\tif (cmsg->cmsg_type == SCM_TIMESTAMP) {\n\t\t\t\t\tmemcpy(&tdut, CMSG_DATA(cmsg), sizeof(tdut));\n\t\t\t\t\trecvflags |= 1 << cmsg->cmsg_type;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SOL_CAN_J1939:\n\t\t\t\trecvflags |= 1 << cmsg->cmsg_type;\n\t\t\t\tif (cmsg->cmsg_type == SCM_J1939_DEST_ADDR)\n\t\t\t\t\tdst_addr = *CMSG_DATA(cmsg);\n\t\t\t\telse if (cmsg->cmsg_type == SCM_J1939_DEST_NAME)\n\t\t\t\t\tmemcpy(&dst_name, CMSG_DATA(cmsg), cmsg->cmsg_len - CMSG_LEN(0));\n\t\t\t\telse if (cmsg->cmsg_type == SCM_J1939_PRIO)\n\t\t\t\t\tpriority = *CMSG_DATA(cmsg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif (recvflags & (1 << SCM_TIMESTAMP)) {\n\t\t\tif ('z' == s.time) {\n\t\t\t\tif (!tref.tv_sec)\n\t\t\t\t\ttref = tdut;\n\t\t\t\ttimersub(&tdut, &tref, &ttmp);\n\t\t\t\ttdut = ttmp;\n\t\t\t\tgoto abs_time;\n\t\t\t} else if ('d' == s.time) {\n\t\t\t\ttimersub(&tdut, &tref, &ttmp);\n\t\t\t\ttref = tdut;\n\t\t\t\ttdut = ttmp;\n\t\t\t\tgoto abs_time;\n\t\t\t} else if ('a' == s.time) {\n\t\t\t\tabs_time:\n\t\t\t\tprintf(\"(%lu.%04lu)\", tdut.tv_sec, tdut.tv_usec / 100);\n\t\t\t} else if ('A' == s.time) {\n\t\t\t\tstruct tm tm;\n\t\t\t\ttm = *localtime(&tdut.tv_sec);\n\t\t\t\tprintf(\"(%04u%02u%02uT%02u%02u%02u.%04lu)\",\n\t\t\t\t\ttm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n\t\t\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec,\n\t\t\t\t\ttdut.tv_usec/100);\n\t\t\t}\n\t\t}\n\t\tprintf(\" %s \", libj1939_addr2str(&src));\n\t\tif (recvflags & (1 << SCM_J1939_DEST_NAME))\n\t\t\tprintf(\"%016llx \", (unsigned long long)dst_name);\n\t\telse if (recvflags & (1 << SCM_J1939_DEST_ADDR))\n\t\t\tprintf(\"%02x \", dst_addr);\n\t\telse\n\t\t\tprintf(\"- \");\n\t\tprintf(\"!%u \", priority);\n\n\t\tprintf(\"[%i%s]\", len, (msg.msg_flags & MSG_TRUNC) ? \"...\" : \"\");\n\t\tfor (j = 0; j < len; ) {\n\t\t\tunsigned int end = j + 4;\n\t\t\tif (end > len)\n\t\t\t\tend = len;\n\t\t\tprintf(\" \");\n\t\t\tfor (; j < end; ++j)\n\t\t\t\tprintf(\"%02x\", buf[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tfree(buf);\n\treturn 0;\n}", "path": "can-utils/j1939spy.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* copied from /usr/src/linux/include/linux/time.h ...\n * lhs < rhs:  return <0\n * lhs == rhs: return 0\n * lhs > rhs:  return >0\n */\n", "func_signal": "static inline int timeval_compare(struct timeval *lhs, struct timeval *rhs)", "code": "{\n\tif (lhs->tv_sec < rhs->tv_sec)\n\t\treturn -1;\n\tif (lhs->tv_sec > rhs->tv_sec)\n\t\treturn 1;\n\treturn lhs->tv_usec - rhs->tv_usec;\n}", "path": "can-utils/canplayer.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* dump status */\n", "func_signal": "static inline int addr_status_mine(int sa)", "code": "{\n\tif (sa == s.current_sa)\n\t\treturn '*';\n\tif (addr[sa].flags & F_USE)\n\t\treturn '+';\n\treturn '-';\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* byte swap functions */\n", "func_signal": "static inline int host_is_little_endian(void)", "code": "{\n\tstatic const uint16_t endian_test = 1;\n\treturn *(const uint8_t *)&endian_test;\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* retrieve name */\n", "func_signal": "static const char *libj1939_ifnam(int ifindex)", "code": "{\n\tconst struct if_nameindex *lp, *cached = saved;\n\n\tfetch_names();\n\n\tfor (lp = saved; lp->if_index; ++lp) {\n\t\tif (lp->if_index == (unsigned int)ifindex)\n\t\t\treturn lp->if_name;\n\t}\n\tif (cached) {\n\t\t/*\n\t\t * the list was not recent\n\t\t * iterate twice, but force a refresh now\n\t\t * recursion stops since the 'saved' pointer is cleaned\n\t\t */\n\t\tlibj1939_cleanup();\n\t\treturn libj1939_ifnam(ifindex);\n\t}\n\treturn NULL;\n}", "path": "can-utils/libj1939.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* read data from pty, send CAN frames to CAN socket and answer commands */\n", "func_signal": "int pty2can(int pty, int socket, struct can_filter *fi,\n\t    int *is_open, int *tstamp)", "code": "{\n\tint nbytes;\n\tchar cmd;\n\tstatic char buf[200];\n\tchar replybuf[10]; /* for answers to received commands */\n\tint ptr;\n\tstruct can_frame frame;\n\tint tmp, i;\n\tstatic int rxoffset = 0; /* points to the end of an received incomplete SLCAN message */\n\n\tnbytes = read(pty, &buf[rxoffset], sizeof(buf)-rxoffset-1);\n\tif (nbytes <= 0) {\n\t\t/* nbytes == 0 : no error but pty descriptor has been closed */\n\t\tif (nbytes < 0)\n\t\t\tperror(\"read pty\");\n\n\t\treturn 1;\n\t}\n\n\t/* reset incomplete message offset */\n\tnbytes += rxoffset;\n\trxoffset = 0;\n\nrx_restart:\n\t/* remove trailing '\\r' characters to be robust against some apps */\n\twhile (buf[0] == '\\r' && nbytes > 0) {\n\t\tfor (tmp = 0; tmp < nbytes; tmp++)\n\t\t\tbuf[tmp] = buf[tmp+1];\n\t\tnbytes--;\n\t}\n\n\tif (!nbytes)\n\t\treturn 0;\n\n\t/* check if we can detect a complete SLCAN message including '\\r' */\n\tfor (tmp = 0; tmp < nbytes; tmp++) {\n\t\tif (buf[tmp] == '\\r')\n\t\t\tbreak;\n\t}\n\n\t/* no '\\r' found in the message buffer? */\n\tif (tmp == nbytes) {\n\t\t/* save incomplete message */\n\t\trxoffset = nbytes;\n\n\t\t/* leave here and read from pty again */\n\t\treturn 0;\n\t}\n\n\tcmd = buf[0];\n\tbuf[nbytes] = 0;\n\n#ifdef DEBUG\n\tfor (tmp = 0; tmp < nbytes; tmp++)\n\t\tif (buf[tmp] == '\\r')\n\t\t\tputchar('@');\n\t\telse\n\t\t\tputchar(buf[tmp]);\n\tprintf(\"\\n\");\n#endif\n\n\t/* check for filter configuration commands */\n\tif (cmd == 'm' || cmd == 'M') {\n\t\tbuf[9] = 0; /* terminate filter string */\n\t\tptr = 9;\n#if 0\n\t\t/* the filter is no SocketCAN filter :-( */\n\n\t\t/* TODO: behave like a SJA1000 controller specific filter */\n\n\t\tif (cmd == 'm') {\n\t\t\tfi->can_id = strtoul(buf+1,NULL,16);\n\t\t\tfi->can_id &= CAN_EFF_MASK;\n\t\t} else {\n\t\t\tfi->can_mask = strtoul(buf+1,NULL,16);\n\t\t\tfi->can_mask &= CAN_EFF_MASK;\n\t\t}\n\n\t\tif (*is_open)\n\t\t\tsetsockopt(socket, SOL_CAN_RAW,\n\t\t\t\t   CAN_RAW_FILTER, fi,\n\t\t\t\t   sizeof(struct can_filter));\n#endif\n\t\tgoto rx_out_ack;\n\t}\n\n\n\t/* check for timestamp on/off command */\n\tif (cmd == 'Z') {\n\t\t*tstamp = buf[1] & 0x01;\n\t\tptr = 2;\n\t\tgoto rx_out_ack;\n\t}\n\n\t/* check for 'O'pen command */\n\tif (cmd == 'O') {\n\t\tsetsockopt(socket, SOL_CAN_RAW,\n\t\t\t   CAN_RAW_FILTER, fi,\n\t\t\t   sizeof(struct can_filter));\n\t\tptr = 1;\n\t\t*is_open = 1;\n\t\tgoto rx_out_ack;\n\t}\n\n\t/* check for 'C'lose command */\n\tif (cmd == 'C') {\n\t\tsetsockopt(socket, SOL_CAN_RAW, CAN_RAW_FILTER,\n\t\t\t   NULL, 0);\n\t\tptr = 1;\n\t\t*is_open = 0;\n\t\tgoto rx_out_ack;\n\t}\n\n\t/* check for 'V'ersion command */\n\tif (cmd == 'V') {\n\t\tsprintf(replybuf, \"V1013\\r\");\n\t\ttmp = strlen(replybuf);\n\t\tptr = 1;\n\t\tgoto rx_out;\n\t}\n\t/* check for 'v'ersion command */\n\tif (cmd == 'v') {\n\t\tsprintf(replybuf, \"v1014\\r\");\n\t\ttmp = strlen(replybuf);\n\t\tptr = 1;\n\t\tgoto rx_out;\n\t}\n\n\t/* check for serial 'N'umber command */\n\tif (cmd == 'N') {\n\t\tsprintf(replybuf, \"N4242\\r\");\n\t\ttmp = strlen(replybuf);\n\t\tptr = 1;\n\t\tgoto rx_out;\n\t}\n\n\t/* check for read status 'F'lags */\n\tif (cmd == 'F') {\n\t\tsprintf(replybuf, \"F00\\r\");\n\t\ttmp = strlen(replybuf);\n\t\tptr = 1;\n\t\tgoto rx_out;\n\t}\n\n\t/* correctly answer unsupported commands */\n\tif (cmd == 'U') {\n\t\tptr = 2;\n\t\tgoto rx_out_ack;\n\t}\n\tif (cmd == 'S') {\n\t\tptr = 2;\n\t\tgoto rx_out_ack;\n\t}\n\tif (cmd == 's') {\n\t\tptr = 5;\n\t\tgoto rx_out_ack;\n\t}\n\tif (cmd == 'P' || cmd == 'A') {\n\t\tptr = 1;\n\t\tgoto rx_out_nack;\n\t}\n\tif (cmd == 'X') {\n\t\tptr = 2;\n\t\tif (buf[1] & 0x01)\n\t\t\tgoto rx_out_ack;\n\t\telse\n\t\t\tgoto rx_out_nack;\n\t}\n\n\t/* catch unknown commands */\n\tif ((cmd != 't') && (cmd != 'T') &&\n\t    (cmd != 'r') && (cmd != 'R')) {\n\t\tptr = nbytes-1;\n\t\tgoto rx_out_nack;\n\t}\n\n\tif (cmd & 0x20) /* tiny chars 'r' 't' => SFF */\n\t\tptr = 4; /* dlc position tiiid */\n\telse\n\t\tptr = 9; /* dlc position Tiiiiiiiid */\n\n\tmemset(&frame.data, 0, 8); /* clear data[] */\n\n\tif ((cmd | 0x20) == 'r' && buf[ptr] != '0') {\n\n\t\t/* \n\t\t * RTR frame without dlc information!\n\t\t * This is against the SLCAN spec but sent\n\t\t * by a commercial CAN tool ... so we are\n\t\t * robust against this protocol violation.\n\t\t */\n\n\t\tframe.can_dlc = buf[ptr]; /* save following byte */\n\n\t\tbuf[ptr] = 0; /* terminate can_id string */\n\n\t\tframe.can_id = strtoul(buf+1, NULL, 16);\n\t\tframe.can_id |= CAN_RTR_FLAG;\n\n\t\tif (!(cmd & 0x20)) /* NO tiny chars => EFF */\n\t\t\tframe.can_id |= CAN_EFF_FLAG;\n\n\t\tbuf[ptr]  = frame.can_dlc; /* restore following byte */\n\t\tframe.can_dlc = 0;\n\t\tptr--; /* we have no dlc component in the violation case */\n\n\t} else {\n\n\t\tif (!(buf[ptr] >= '0' && buf[ptr] < '9'))\n\t\t\tgoto rx_out_nack;\n\n\t\tframe.can_dlc = buf[ptr] - '0'; /* get dlc from ASCII val */\n\n\t\tbuf[ptr] = 0; /* terminate can_id string */\n\n\t\tframe.can_id = strtoul(buf+1, NULL, 16);\n\n\t\tif (!(cmd & 0x20)) /* NO tiny chars => EFF */\n\t\t\tframe.can_id |= CAN_EFF_FLAG;\n\n\t\tif ((cmd | 0x20) == 'r') /* RTR frame */\n\t\t\tframe.can_id |= CAN_RTR_FLAG;\n\n\t\tfor (i = 0, ptr++; i < frame.can_dlc; i++) {\n\n\t\t\ttmp = asc2nibble(buf[ptr++]);\n\t\t\tif (tmp > 0x0F)\n\t\t\t\tgoto rx_out_nack;\n\t\t\tframe.data[i] = (tmp << 4);\n\t\t\ttmp = asc2nibble(buf[ptr++]);\n\t\t\tif (tmp > 0x0F)\n\t\t\t\tgoto rx_out_nack;\n\t\t\tframe.data[i] |= tmp;\n\t\t}\n\t\t/* point to last real data */\n\t\tif (frame.can_dlc)\n\t\t\tptr--;\n\t}\n\n\ttmp = write(socket, &frame, sizeof(frame));\n\tif (tmp != sizeof(frame)) {\n\t\tperror(\"write socket\");\n\t\treturn 1;\n\t}\n\nrx_out_ack:\n\treplybuf[0] = '\\r';\n\ttmp = 1;\n\tgoto rx_out;\nrx_out_nack:\n\treplybuf[0] = '\\a';\n\ttmp = 1;\nrx_out:\n\ttmp = write(pty, replybuf, tmp);\n\tif (tmp < 0) {\n\t\tperror(\"write pty replybuf\");\n\t\treturn 1;\n\t}\n\n\t/* check if there is another command in this buffer */\n\tif (nbytes > ptr+1) {\n\t\tfor (tmp = 0, ptr++; ptr+tmp < nbytes; tmp++)\n\t\t\tbuf[tmp] = buf[ptr+tmp];\n\t\tnbytes = tmp;\n\t\tgoto rx_restart;\n\t}\n\n\treturn 0;\n}", "path": "can-utils/slcanpty.c", "commit_date": "2020-06-29 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* rate-limiting for errors */\n", "func_signal": "static inline int must_warn(int ret)", "code": "{\n\tif (ret >= 0)\n\t\treturn 0;\n\tswitch (errno) {\n\tcase EINTR:\n\tcase ENOBUFS:\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/**\n * Update the crc value with new data.\n *\n * \\param crc      The current crc value.\n * \\param data     Pointer to a buffer of \\a data_len bytes.\n * \\param data_len Number of bytes in the \\a data buffer.\n * \\return         The updated crc value.\n *****************************************************************************/\n", "func_signal": "static crc_t crc_update_bytewise(crc_t crc, const unsigned char *data, size_t data_len)", "code": "{\n\tunsigned int tbl_idx;\n\n\twhile (data_len--) {\n\t\ttbl_idx = ((crc >> 7) ^ *data) & 0xff;\n\t\tcrc = (crc_table[tbl_idx] ^ (crc << 8)) & 0x7fff;\n\n\t\tdata++;\n\t}\n\treturn crc & 0x7fff;\n}", "path": "can-utils/canframelen.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* real policy */\n", "func_signal": "static int choose_new_sa(uint64_t name, int sa)", "code": "{\n\tint j, cnt;\n\n\t/* test current entry */\n\tif ((sa < J1939_IDLE_ADDR) && (addr[sa].flags & F_USE)) {\n\t\tj = sa;\n\t\tif (!addr[j].name || (addr[j].name == name) || (addr[j].name > name))\n\t\t\treturn j;\n\t}\n\t/* take first empty spot */\n\tfor (j = 0; j < J1939_IDLE_ADDR; ++j) {\n\t\tif (!(addr[j].flags & F_USE))\n\t\t\tcontinue;\n\t\tif (!addr[j].name || (addr[j].name == name))\n\t\t\treturn j;\n\t}\n\n\t/*\n\t * no empty spot found\n\t * take next (relative to @sa) spot that we can\n\t * successfully contest\n\t */\n\tj = sa + 1;\n\tfor (cnt = 0; cnt < J1939_IDLE_ADDR; ++j, ++cnt) {\n\t\tif (j >= J1939_IDLE_ADDR)\n\t\t\tj = 0;\n\t\tif (!(addr[j].flags & F_USE))\n\t\t\tcontinue;\n\t\tif (name < addr[j].name)\n\t\t\treturn j;\n\t}\n\treturn J1939_IDLE_ADDR;\n}", "path": "can-utils/j1939acd.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/**\n * Update the crc value with new data.\n *\n * \\param crc      The current crc value.\n * \\param data     Data value\n * \\param bits\t   The number of most significant bits in data used for CRC calculation\n * \\return         The updated crc value.\n *****************************************************************************/\n", "func_signal": "static crc_t crc_update_bitwise(crc_t crc, uint8_t data, size_t bits)", "code": "{\n\tuint8_t i;\n\tbool bit;\n\n\tfor (i = 0x80; bits--; i >>= 1) {\n\t\tbit = crc & 0x4000;\n\t\tif (data & i) {\n\t\t\tbit = !bit;\n\t\t}\n\t\tcrc <<= 1;\n\t\tif (bit) {\n\t\t\tcrc ^= 0x4599;\n\t\t}\n\t}\n\treturn crc & 0x7fff;\n}", "path": "can-utils/canframelen.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* read CAN frames from CAN interface and write it to the pty */\n", "func_signal": "int can2pty(int pty, int socket, int *tstamp)", "code": "{\n\tint nbytes;\n\tchar cmd;\n\tchar buf[SLC_MTU];\n\tint ptr;\n\tstruct can_frame frame;\n\tint i;\n\n\tnbytes = read(socket, &frame, sizeof(frame));\n\tif (nbytes != sizeof(frame)) {\n\t\tperror(\"read socket\");\n\t\treturn 1;\n\t}\n\n\t/* convert to slcan ASCII frame */\n\tif (frame.can_id & CAN_RTR_FLAG)\n\t\tcmd = 'R'; /* becomes 'r' in SFF format */\n\telse\n\t\tcmd = 'T'; /* becomes 't' in SFF format */\n\n\tif (frame.can_id & CAN_EFF_FLAG)\n\t\tsprintf(buf, \"%c%08X%d\", cmd,\n\t\t\tframe.can_id & CAN_EFF_MASK,\n\t\t\tframe.can_dlc);\n\telse\n\t\tsprintf(buf, \"%c%03X%d\", cmd | 0x20,\n\t\t\tframe.can_id & CAN_SFF_MASK,\n\t\t\tframe.can_dlc);\n\n\tptr = strlen(buf);\n\n\tfor (i = 0; i < frame.can_dlc; i++)\n\t\tsprintf(&buf[ptr + 2*i], \"%02X\",\n\t\t\tframe.data[i]);\n\n\tif (*tstamp) {\n\t\tstruct timeval tv;\n\n\t\tif (ioctl(socket, SIOCGSTAMP, &tv) < 0)\n\t\t\tperror(\"SIOCGSTAMP\");\n\n\t\tsprintf(&buf[ptr + 2*frame.can_dlc], \"%04lX\",\n\t\t\t(tv.tv_sec%60)*1000 + tv.tv_usec/1000);\n\t}\n\n\tstrcat(buf, \"\\r\"); /* add terminating character */\n\tnbytes = write(pty, buf, strlen(buf));\n\tif (nbytes < 0) {\n\t\tperror(\"write pty\");\n\t\treturn 1;\n\t}\n\tfflush(NULL);\n\n\treturn 0;\n}", "path": "can-utils/slcanpty.c", "commit_date": "2020-06-29 00:00:00", "repo_name": "linux-can/can-utils", "stars": 2161, "license": "None", "language": "c", "size": 1240}
{"docstring": "/* \n * See header file for description. \n */\n", "func_signal": "BaseType_t xPortStartScheduler( void )", "code": "{\n\t/* Start the timer that generates the tick ISR.  Interrupts are disabled\n\there already. */\n\tprvSetupTimerInterrupt();\n\t\n\t/* Start the first task. */\n    asm volatile (  \" movia r2, restore_sp_from_pxCurrentTCB        \\n\"\n                    \" jmp r2                                          \" );\n\n\t/* Should not get here! */\n\treturn 0;\n}", "path": "FreeRTOS-Kernel/portable/GCC/NiosII/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,\n                                     TaskFunction_t pxCode,\n                                     void * pvParameters )", "code": "{\n    /* Simulate the stack frame as it would be created by a context switch\n     * interrupt. */\n\n    /* Offset added to account for the way the MCU uses the stack on entry/exit\n     * of interrupts, and to ensure alignment. */\n    pxTopOfStack--;\n\n    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */\n    pxTopOfStack--;\n    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */\n    pxTopOfStack--;\n    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    /* LR */\n\n    /* Save code space by skipping register initialisation. */\n    pxTopOfStack -= 5;                            /* R12, R3, R2 and R1. */\n    *pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */\n\n    /* A save method is being used that requires each task to maintain its\n     * own exec return value. */\n    pxTopOfStack--;\n    *pxTopOfStack = portINITIAL_EXC_RETURN;\n\n    pxTopOfStack -= 8; /* R11, R10, R9, R8, R7, R6, R5 and R4. */\n\n    return pxTopOfStack;\n}", "path": "FreeRTOS-Kernel/portable/CCS/ARM_CM4F/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/* \n * See header file for description. \n */\n", "func_signal": "StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )", "code": "{\n\t/* \n\t\tPlace a few bytes of known values on the bottom of the stack.\n\t\tThis can be uncommented to provide useful stack markers when debugging.\n\n\t\t*pxTopOfStack = ( StackType_t ) 0x11;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = ( StackType_t ) 0x22;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = ( StackType_t ) 0x33;\n\t\tpxTopOfStack--;\n\t*/\n\n\n\n\t/* Setup the initial stack of the task.  The stack is set exactly as \n\texpected by the portRESTORE_CONTEXT() macro.  In this case the stack as\n\texpected by the HCS12 RTI instruction. */\n\n\n\t/* The address of the task function is placed in the stack byte at a time. */\n\t*pxTopOfStack = ( StackType_t ) *( ((StackType_t *) (&pxCode) ) + 1 );\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( StackType_t ) *( ((StackType_t *) (&pxCode) ) + 0 );\n\tpxTopOfStack--;\n\n\t/* Next are all the registers that form part of the task context. */\n\n\t/* Y register */\n\t*pxTopOfStack = ( StackType_t ) 0xff;\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( StackType_t ) 0xee;\n\tpxTopOfStack--;\n\n\t/* X register */\n\t*pxTopOfStack = ( StackType_t ) 0xdd;\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( StackType_t ) 0xcc;\n\tpxTopOfStack--;\n \n\t/* A register contains parameter high byte. */\n\t*pxTopOfStack = ( StackType_t ) *( ((StackType_t *) (&pvParameters) ) + 0 );\n\tpxTopOfStack--;\n\n\t/* B register contains parameter low byte. */\n\t*pxTopOfStack = ( StackType_t ) *( ((StackType_t *) (&pvParameters) ) + 1 );\n\tpxTopOfStack--;\n\n\t/* CCR: Note that when the task starts interrupts will be enabled since\n\t\"I\" bit of CCR is cleared */\n\t*pxTopOfStack = ( StackType_t ) 0x00;\n\tpxTopOfStack--;\n\t\n\t#ifdef BANKED_MODEL\n\t\t/* The page of the task. */\n\t\t*pxTopOfStack = ( StackType_t ) ( ( int ) pxCode );\n\t\tpxTopOfStack--;\n\t#endif\n\t\n\t/* Finally the critical nesting depth is initialised with 0 (not within\n\ta critical section). */\n\t*pxTopOfStack = ( StackType_t ) 0x00;\n\n\treturn pxTopOfStack;\n}", "path": "FreeRTOS-Kernel/portable/CodeWarrior/HCS12/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,\n                                     TaskFunction_t pxCode,\n                                     void * pvParameters )", "code": "{\n    /* Simulate the stack frame as it would be created by a context switch\n     * interrupt. */\n    pxTopOfStack--;                                   /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */\n    *pxTopOfStack = portINITIAL_XPSR;                 /* xPSR */\n    pxTopOfStack--;\n    *pxTopOfStack = ( StackType_t ) pxCode;           /* PC */\n    pxTopOfStack--;\n    *pxTopOfStack = ( StackType_t ) prvTaskExitError; /* LR */\n    pxTopOfStack -= 5;                                /* R12, R3, R2 and R1. */\n    *pxTopOfStack = ( StackType_t ) pvParameters;     /* R0 */\n    pxTopOfStack -= 8;                                /* R11..R4. */\n\n    return pxTopOfStack;\n}", "path": "FreeRTOS-Kernel/portable/IAR/ARM_CM0/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "BaseType_t xPortStartScheduler( void )", "code": "{\n    #if ( configASSERT_DEFINED == 1 )\n        {\n            volatile uint32_t ulOriginalPriority;\n            volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );\n            volatile uint8_t ucMaxPriorityValue;\n\n            /* Determine the maximum priority from which ISR safe FreeRTOS API\n             * functions can be called.  ISR safe functions are those that end in\n             * \"FromISR\".  FreeRTOS maintains separate thread and ISR API functions to\n             * ensure interrupt entry is as fast and simple as possible.\n             *\n             * Save the interrupt priority value that is about to be clobbered. */\n            ulOriginalPriority = *pucFirstUserPriorityRegister;\n\n            /* Determine the number of priority bits available.  First write to all\n             * possible bits. */\n            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;\n\n            /* Read the value back to see how many bits stuck. */\n            ucMaxPriorityValue = *pucFirstUserPriorityRegister;\n\n            /* Use the same mask on the maximum system call priority. */\n            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;\n\n            /* Calculate the maximum acceptable priority group value for the number\n             * of bits read back. */\n            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;\n\n            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )\n            {\n                ulMaxPRIGROUPValue--;\n                ucMaxPriorityValue <<= ( uint8_t ) 0x01;\n            }\n\n            #ifdef __NVIC_PRIO_BITS\n                {\n                    /* Check the CMSIS configuration that defines the number of\n                     * priority bits matches the number of priority bits actually queried\n                     * from the hardware. */\n                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );\n                }\n            #endif\n\n            #ifdef configPRIO_BITS\n                {\n                    /* Check the FreeRTOS configuration that defines the number of\n                     * priority bits matches the number of priority bits actually queried\n                     * from the hardware. */\n                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );\n                }\n            #endif\n\n            /* Shift the priority group value back to its position within the AIRCR\n             * register. */\n            ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;\n            ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;\n\n            /* Restore the clobbered interrupt priority register to its original\n             * value. */\n            *pucFirstUserPriorityRegister = ulOriginalPriority;\n        }\n    #endif /* conifgASSERT_DEFINED */\n\n    /* Make PendSV and SysTick the lowest priority interrupts. */\n    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;\n    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;\n\n    /* Start the timer that generates the tick ISR.  Interrupts are disabled\n     * here already. */\n    vPortSetupTimerInterrupt();\n\n    /* Initialise the critical nesting count ready for the first task. */\n    uxCriticalNesting = 0;\n\n    /* Ensure the VFP is enabled - it should be anyway. */\n    vPortEnableVFP();\n\n    /* Lazy save always. */\n    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;\n\n    /* Start the first task. */\n    vPortStartFirstTask();\n\n    /* Should not get here! */\n    return 0;\n}", "path": "FreeRTOS-Kernel/portable/CCS/ARM_CM4F/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/* \n * See header file for description. \n */\n", "func_signal": "StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )", "code": "{    \nStackType_t *pxFramePointer = pxTopOfStack - 1;\nStackType_t xGlobalPointer;\n\n    prvReadGp( &xGlobalPointer ); \n\n    /* End of stack marker. */\n    *pxTopOfStack = 0xdeadbeef;\n    pxTopOfStack--;\n    \n    *pxTopOfStack = ( StackType_t ) pxFramePointer; \n    pxTopOfStack--;\n    \n    *pxTopOfStack = xGlobalPointer; \n    \n    /* Space for R23 to R16. */\n    pxTopOfStack -= 9;\n\n    *pxTopOfStack = ( StackType_t ) pxCode; \n    pxTopOfStack--;\n\n    *pxTopOfStack = portINITIAL_ESTATUS; \n\n    /* Space for R15 to R5. */    \n    pxTopOfStack -= 12;\n    \n    *pxTopOfStack = ( StackType_t ) pvParameters; \n\n    /* Space for R3 to R1, muldiv and RA. */\n    pxTopOfStack -= 5;\n    \n    return pxTopOfStack;\n}", "path": "FreeRTOS-Kernel/portable/GCC/NiosII/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "BaseType_t xPortStartScheduler( void )", "code": "{\n    #if ( configASSERT_DEFINED == 1 )\n        {\n            volatile uint32_t ulOriginalPriority;\n            volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );\n            volatile uint8_t ucMaxPriorityValue;\n\n            /* Determine the maximum priority from which ISR safe FreeRTOS API\n             * functions can be called.  ISR safe functions are those that end in\n             * \"FromISR\".  FreeRTOS maintains separate thread and ISR API functions to\n             * ensure interrupt entry is as fast and simple as possible.\n             *\n             * Save the interrupt priority value that is about to be clobbered. */\n            ulOriginalPriority = *pucFirstUserPriorityRegister;\n\n            /* Determine the number of priority bits available.  First write to all\n             * possible bits. */\n            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;\n\n            /* Read the value back to see how many bits stuck. */\n            ucMaxPriorityValue = *pucFirstUserPriorityRegister;\n\n            /* Use the same mask on the maximum system call priority. */\n            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;\n\n            /* Calculate the maximum acceptable priority group value for the number\n             * of bits read back. */\n            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;\n\n            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )\n            {\n                ulMaxPRIGROUPValue--;\n                ucMaxPriorityValue <<= ( uint8_t ) 0x01;\n            }\n\n            #ifdef __NVIC_PRIO_BITS\n                {\n                    /* Check the CMSIS configuration that defines the number of\n                     * priority bits matches the number of priority bits actually queried\n                     * from the hardware. */\n                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );\n                }\n            #endif\n\n            #ifdef configPRIO_BITS\n                {\n                    /* Check the FreeRTOS configuration that defines the number of\n                     * priority bits matches the number of priority bits actually queried\n                     * from the hardware. */\n                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );\n                }\n            #endif\n\n            /* Shift the priority group value back to its position within the AIRCR\n             * register. */\n            ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;\n            ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;\n\n            /* Restore the clobbered interrupt priority register to its original\n             * value. */\n            *pucFirstUserPriorityRegister = ulOriginalPriority;\n        }\n    #endif /* conifgASSERT_DEFINED */\n\n    /* Make PendSV and SysTick the lowest priority interrupts. */\n    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;\n    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;\n\n    /* Start the timer that generates the tick ISR.  Interrupts are disabled\n     * here already. */\n    vPortSetupTimerInterrupt();\n\n    /* Initialise the critical nesting count ready for the first task. */\n    uxCriticalNesting = 0;\n\n    /* Start the first task. */\n    vPortStartFirstTask();\n\n    /* Should not get here! */\n    return 0;\n}", "path": "FreeRTOS-Kernel/portable/CCS/ARM_CM3/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "BaseType_t xPortStartScheduler( void )", "code": "{\n    /* Make PendSV and SysTick the lowest priority interrupts. */\n    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;\n    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;\n\n    /* Start the timer that generates the tick ISR.  Interrupts are disabled\n     * here already. */\n    vPortSetupTimerInterrupt();\n\n    /* Initialise the critical nesting count ready for the first task. */\n    uxCriticalNesting = 0;\n\n    /* Start the first task. */\n    vPortStartFirstTask();\n\n    /* Should not get here! */\n    return 0;\n}", "path": "FreeRTOS-Kernel/portable/IAR/ARM_CM0/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * Manual context switch forced by calling portYIELD().  This is the SWI\n * handler.\n */\n", "func_signal": "void interrupt vPortYield( void )", "code": "{\n\tportSAVE_CONTEXT();\n\tvTaskSwitchContext();\n\tportRESTORE_CONTEXT();\n}", "path": "FreeRTOS-Kernel/portable/CodeWarrior/HCS12/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * Low-level initialization routine called during startup, before the main\n * function.\n */\n", "func_signal": "int __low_level_init(void)", "code": "{\n\t#if configHEAP_INIT\n\t\t#pragma segment = \"HEAP\"\n\t\tBaseType_t *pxMem;\n\t#endif\n\n\t/* Enable exceptions. */\n\tENABLE_ALL_EXCEPTIONS();\n\n\t/* Initialize interrupt handling. */\n\tINTC_init_interrupts();\n\n\t#if configHEAP_INIT\n\t{\n\t\t/* Initialize the heap used by malloc. */\n\t\tfor( pxMem = __segment_begin( \"HEAP\" ); pxMem < ( BaseType_t * ) __segment_end( \"HEAP\" ); )\n\t\t{\n\t\t\t*pxMem++ = 0xA5A5A5A5;\n\t\t}\n\t}\n\t#endif\n\n\t/* Code section present if and only if the debug trace is activated. */\n\t#if configDBG\n\t{\n\t\tstatic const gpio_map_t DBG_USART_GPIO_MAP =\n\t\t{\n\t\t\t{ configDBG_USART_RX_PIN, configDBG_USART_RX_FUNCTION },\n\t\t\t{ configDBG_USART_TX_PIN, configDBG_USART_TX_FUNCTION }\n\t\t};\n\n\t\tstatic const usart_options_t DBG_USART_OPTIONS =\n\t\t{\n\t\t\t.baudrate = configDBG_USART_BAUDRATE,\n\t\t\t.charlength = 8,\n\t\t\t.paritytype = USART_NO_PARITY,\n\t\t\t.stopbits = USART_1_STOPBIT,\n\t\t\t.channelmode = USART_NORMAL_CHMODE\n\t\t};\n\n\t\t/* Initialize the USART used for the debug trace with the configured parameters. */\n\t\textern volatile avr32_usart_t *volatile stdio_usart_base;\n\t\tstdio_usart_base = configDBG_USART;\n\t\tgpio_enable_module( DBG_USART_GPIO_MAP,\n\t\t                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );\n\t\tusart_init_rs232(configDBG_USART, &DBG_USART_OPTIONS, configCPU_CLOCK_HZ);\n\t}\n\t#endif\n\n\t/* Request initialization of data segments. */\n\treturn 1;\n}", "path": "FreeRTOS-Kernel/portable/IAR/AVR32_UC3/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/* Added as there is no such function in FreeRTOS. */\n", "func_signal": "void *pvPortRealloc( void *pv, size_t xWantedSize )", "code": "{\nvoid *pvReturn;\n\n\tvTaskSuspendAll();\n\t{\n\t\tpvReturn = realloc( pv, xWantedSize );\n\t}\n\txTaskResumeAll();\n\n\treturn pvReturn;\n}", "path": "FreeRTOS-Kernel/portable/IAR/AVR32_UC3/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )", "code": "{\n\t/* Offset to end up on 8 byte boundary. */\n\tpxTopOfStack--;\n\n\t/* R0 is not included as it is the stack pointer. */\n\t*pxTopOfStack = 0x00;\n\tpxTopOfStack--;\n    *pxTopOfStack = 0x00;\n\tpxTopOfStack--;\n \t*pxTopOfStack = portINITIAL_PSW;\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( StackType_t ) pxCode;\n\n\t/* When debugging it can be useful if every register is set to a known\n\tvalue.  Otherwise code space can be saved by just setting the registers\n\tthat need to be set. */\n\t#ifdef USE_FULL_REGISTER_INITIALISATION\n\t{\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x12345678;\t/* r15. */\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0xaaaabbbb;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0xdddddddd;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0xcccccccc;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0xbbbbbbbb;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0xaaaaaaaa;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x99999999;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x88888888;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x77777777;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x66666666;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x55555555;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x44444444;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x33333333;\n\t\tpxTopOfStack--;\n\t\t*pxTopOfStack = 0x22222222;\n\t\tpxTopOfStack--;\n\t}\n\t#else\n\t{\n\t\t/* Leave space for the registers that will get popped from the stack\n\t\twhen the task first starts executing. */\n\t\tpxTopOfStack -= 15;\n\t}\n\t#endif\n\n\t*pxTopOfStack = ( StackType_t ) pvParameters; /* R1 */\n\tpxTopOfStack--;\n\t*pxTopOfStack = 0x12345678; /* Accumulator. */\n\tpxTopOfStack--;\n\t*pxTopOfStack = 0x87654321; /* Accumulator. */\n\n\treturn pxTopOfStack;\n}", "path": "FreeRTOS-Kernel/portable/IAR/RX100/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/** This function is a re-implementation of the Altera provided function.\n * The function is re-implemented to prevent it from enabling an interrupt\n * when it is registered. Interrupts should only be enabled after the FreeRTOS.org\n * kernel has its scheduler started so that contexts are saved and switched \n * correctly.\n */\n", "func_signal": "int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )", "code": "{\n\tint rc = -EINVAL;  \n\talt_irq_context status;\n\n\tif (id < ALT_NIRQ)\n\t{\n\t\t/* \n\t\t * interrupts are disabled while the handler tables are updated to ensure\n\t\t * that an interrupt doesn't occur while the tables are in an inconsistent\n\t\t * state.\n\t\t */\n\t\n\t\tstatus = alt_irq_disable_all ();\n\t\n\t\talt_irq[id].handler = handler;\n\t\talt_irq[id].context = context;\n\t\n\t\trc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);\n\t\n\t\t/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */\n\t}\n    \n\treturn rc; \n}", "path": "FreeRTOS-Kernel/portable/GCC/NiosII/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "// Naked.\n", "func_signal": "void SCALLYield( void )", "code": "{\n\t/* Save the context of the interrupted task. */\n\tportSAVE_CONTEXT_SCALL();\n\tvTaskSwitchContext();\n\tportRESTORE_CONTEXT_SCALL();\n}", "path": "FreeRTOS-Kernel/portable/IAR/AVR32_UC3/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/* This is a naked function. */\n", "func_signal": "static void vPortEnableVFP( void )", "code": "{\n    __asm volatile\n    (\n        \"\tldr.w r0, =0xE000ED88\t\t\\n\"/* The FPU enable bits are in the CPACR. */\n        \"\tldr r1, [r0]\t\t\t\t\\n\"\n        \"\t\t\t\t\t\t\t\t\\n\"\n        \"\torr r1, r1, #( 0xf << 20 )\t\\n\"/* Enable CP10 and CP11 coprocessors, then save back. */\n        \"\tstr r1, [r0]\t\t\t\t\\n\"\n        \"\tbx r14\t\t\t\t\t\t\\n\"\n        \"\t.ltorg\t\t\t\t\t\t\\n\"\n    );\n}", "path": "FreeRTOS-Kernel/portable/GCC/ARM_CM4F/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * Setup the systick timer to generate the tick interrupts at the required\n * frequency.\n */\n", "func_signal": "__weak void vPortSetupTimerInterrupt( void )", "code": "{\n    /* Calculate the constants required to configure the tick interrupt. */\n    #if ( configUSE_TICKLESS_IDLE == 1 )\n        {\n            ulTimerCountsForOneTick = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ );\n            xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;\n            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;\n        }\n    #endif /* configUSE_TICKLESS_IDLE */\n\n    /* Stop and reset the SysTick. */\n    portNVIC_SYSTICK_CTRL_REG = 0UL;\n    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;\n\n    /* Configure SysTick to interrupt at the requested rate. */\n    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;\n    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;\n}", "path": "FreeRTOS-Kernel/portable/IAR/ARM_CM0/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * Setup the systick timer to generate the tick interrupts at the required\n * frequency.\n */\n", "func_signal": "void prvSetupTimerInterrupt( void )", "code": "{\n\t/* Try to register the interrupt handler. */\n\tif ( -EINVAL == alt_irq_register( SYS_CLK_IRQ, 0x0, vPortSysTickHandler ) )\n\t{ \n\t\t/* Failed to install the Interrupt Handler. */\n\t\tasm( \"break\" );\n\t}\n\telse\n\t{\n\t\t/* Configure SysTick to interrupt at the requested rate. */\n\t\tIOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );\n\t\tIOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );\n\t\tIOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );\n\t\tIOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );\t\n\t} \n\n\t/* Clear any already pending interrupts generated by the Timer. */\n\tIOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );\n}", "path": "FreeRTOS-Kernel/portable/GCC/NiosII/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "BaseType_t xPortStartScheduler( void )", "code": "{\n    /* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.\n     * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\n    configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );\n\n    /* This port can be used on all revisions of the Cortex-M7 core other than\n     * the r0p1 parts.  r0p1 parts should use the port from the\n     * /source/portable/GCC/ARM_CM7/r0p1 directory. */\n    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );\n    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );\n\n    #if ( configASSERT_DEFINED == 1 )\n        {\n            volatile uint32_t ulOriginalPriority;\n            volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );\n            volatile uint8_t ucMaxPriorityValue;\n\n            /* Determine the maximum priority from which ISR safe FreeRTOS API\n             * functions can be called.  ISR safe functions are those that end in\n             * \"FromISR\".  FreeRTOS maintains separate thread and ISR API functions to\n             * ensure interrupt entry is as fast and simple as possible.\n             *\n             * Save the interrupt priority value that is about to be clobbered. */\n            ulOriginalPriority = *pucFirstUserPriorityRegister;\n\n            /* Determine the number of priority bits available.  First write to all\n             * possible bits. */\n            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;\n\n            /* Read the value back to see how many bits stuck. */\n            ucMaxPriorityValue = *pucFirstUserPriorityRegister;\n\n            /* Use the same mask on the maximum system call priority. */\n            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;\n\n            /* Calculate the maximum acceptable priority group value for the number\n             * of bits read back. */\n            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;\n\n            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )\n            {\n                ulMaxPRIGROUPValue--;\n                ucMaxPriorityValue <<= ( uint8_t ) 0x01;\n            }\n\n            #ifdef __NVIC_PRIO_BITS\n                {\n                    /* Check the CMSIS configuration that defines the number of\n                     * priority bits matches the number of priority bits actually queried\n                     * from the hardware. */\n                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );\n                }\n            #endif\n\n            #ifdef configPRIO_BITS\n                {\n                    /* Check the FreeRTOS configuration that defines the number of\n                     * priority bits matches the number of priority bits actually queried\n                     * from the hardware. */\n                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );\n                }\n            #endif\n\n            /* Shift the priority group value back to its position within the AIRCR\n             * register. */\n            ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;\n            ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;\n\n            /* Restore the clobbered interrupt priority register to its original\n             * value. */\n            *pucFirstUserPriorityRegister = ulOriginalPriority;\n        }\n    #endif /* conifgASSERT_DEFINED */\n\n    /* Make PendSV and SysTick the lowest priority interrupts. */\n    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;\n    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;\n\n    /* Start the timer that generates the tick ISR.  Interrupts are disabled\n     * here already. */\n    vPortSetupTimerInterrupt();\n\n    /* Initialise the critical nesting count ready for the first task. */\n    uxCriticalNesting = 0;\n\n    /* Ensure the VFP is enabled - it should be anyway. */\n    vPortEnableVFP();\n\n    /* Lazy save always. */\n    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;\n\n    /* Start the first task. */\n    prvPortStartFirstTask();\n\n    /* Should never get here as the tasks will now be executing!  Call the task\n     * exit error function to prevent compiler warnings about a static function\n     * not being called in the case that the application writer overrides this\n     * functionality by defining configTASK_RETURN_ADDRESS.  Call\n     * vTaskSwitchContext() so link time optimisation does not remove the\n     * symbol. */\n    vTaskSwitchContext();\n    prvTaskExitError();\n\n    /* Should not get here! */\n    return 0;\n}", "path": "FreeRTOS-Kernel/portable/GCC/ARM_CM4F/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * Initialise the stack of a task to look exactly as if a call to\n * portSAVE_CONTEXT had been called.\n *\n * See header file for description.\n */\n", "func_signal": "StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )", "code": "{\n\t/* Setup the initial stack of the task.  The stack is set exactly as\n\texpected by the portRESTORE_CONTEXT() macro. */\n\n\t/* When the task starts, it will expect to find the function parameter in R12. */\n\tpxTopOfStack--;\n\t*pxTopOfStack-- = ( StackType_t ) 0x08080808;\t\t\t\t\t/* R8 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x09090909;\t\t\t\t\t/* R9 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x0A0A0A0A;\t\t\t\t\t/* R10 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x0B0B0B0B;\t\t\t\t\t/* R11 */\n\t*pxTopOfStack-- = ( StackType_t ) pvParameters;\t\t\t\t\t/* R12 */\n\t*pxTopOfStack-- = ( StackType_t ) 0xDEADBEEF;\t\t\t\t\t/* R14/LR */\n\t*pxTopOfStack-- = ( StackType_t ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */\n\t*pxTopOfStack-- = ( StackType_t ) portINITIAL_SR;\t\t\t\t/* SR */\n\t*pxTopOfStack-- = ( StackType_t ) 0xFF0000FF;\t\t\t\t\t/* R0 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x01010101;\t\t\t\t\t/* R1 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x02020202;\t\t\t\t\t/* R2 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x03030303;\t\t\t\t\t/* R3 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x04040404;\t\t\t\t\t/* R4 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x05050505;\t\t\t\t\t/* R5 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x06060606;\t\t\t\t\t/* R6 */\n\t*pxTopOfStack-- = ( StackType_t ) 0x07070707;\t\t\t\t\t/* R7 */\n\t*pxTopOfStack = ( StackType_t ) portNO_CRITICAL_NESTING;\t\t\t/* ulCriticalNesting */\n\n\treturn pxTopOfStack;\n}", "path": "FreeRTOS-Kernel/portable/IAR/AVR32_UC3/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,\n                                     TaskFunction_t pxCode,\n                                     void * pvParameters )", "code": "{\n    /* Simulate the stack frame as it would be created by a context switch\n     * interrupt. */\n\n    /* Offset added to account for the way the MCU uses the stack on entry/exit\n     * of interrupts, and to ensure alignment. */\n    pxTopOfStack--;\n\n    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */\n    pxTopOfStack--;\n    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */\n    pxTopOfStack--;\n    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;             /* LR */\n\n    /* Save code space by skipping register initialisation. */\n    pxTopOfStack -= 5;                            /* R12, R3, R2 and R1. */\n    *pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */\n\n    /* A save method is being used that requires each task to maintain its\n     * own exec return value. */\n    pxTopOfStack--;\n    *pxTopOfStack = portINITIAL_EXC_RETURN;\n\n    pxTopOfStack -= 8; /* R11, R10, R9, R8, R7, R6, R5 and R4. */\n\n    return pxTopOfStack;\n}", "path": "FreeRTOS-Kernel/portable/GCC/ARM_CM4F/port.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "FreeRTOS/FreeRTOS-Kernel", "stars": 2210, "license": "mit", "language": "c", "size": 118292}
{"docstring": "// TCP tests.\n", "func_signal": "static int\ncheck_props_v4(nng_msg *msg)", "code": "{\n\tnng_pipe     p;\n\tsize_t       z;\n\tnng_sockaddr la;\n\tnng_sockaddr ra;\n\tbool         b;\n\n\tp = nng_msg_get_pipe(msg);\n\tSo(nng_pipe_id(p) > 0);\n\tSo(nng_pipe_getopt_sockaddr(p, NNG_OPT_LOCADDR, &la) == 0);\n\tSo(la.s_family == NNG_AF_INET);\n\tSo(la.s_in.sa_port == htons(trantest_port - 1));\n\tSo(la.s_in.sa_port != 0);\n\tSo(la.s_in.sa_addr == htonl(0x7f000001));\n\n\t// untyped\n\tz = sizeof(nng_sockaddr);\n\tSo(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == 0);\n\tSo(z == sizeof(ra));\n\tSo(ra.s_family == NNG_AF_INET);\n\tSo(ra.s_in.sa_port != 0);\n\tSo(ra.s_in.sa_addr == htonl(0x7f000001));\n\n\tSo(nng_pipe_getopt_size(p, NNG_OPT_REMADDR, &z) == NNG_EBADTYPE);\n\tz = 1;\n\tSo(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == NNG_EINVAL);\n\n\tSo(nng_pipe_getopt_bool(p, NNG_OPT_TCP_KEEPALIVE, &b) == 0);\n\tSo(b == false); // default\n\n\tSo(nng_pipe_getopt_bool(p, NNG_OPT_TCP_NODELAY, &b) == 0);\n\tSo(b == true); // default\n\n\treturn (0);\n}", "path": "nng/tests/tcp.c", "commit_date": "2020-11-19 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// nni_aio_stop cancels any outstanding operation, and waits for the\n// callback to complete, if still running.  It also marks the AIO as\n// stopped, preventing further calls to nni_aio_begin from succeeding.\n// To correctly tear down an AIO, call stop, and make sure any other\n// callers are not also stopped, before calling nni_aio_free to release\n// actual memory.\n", "func_signal": "void\nnni_aio_stop(nni_aio *aio)", "code": "{\n\tif (aio != NULL) {\n\t\tnni_aio_cancel_fn fn;\n\t\tvoid *            arg;\n\t\tnni_aio_expire_q *eq = aio->a_expire_q;\n\n\t\tnni_mtx_lock(&eq->eq_mtx);\n\t\tnni_list_node_remove(&aio->a_expire_node);\n\t\tfn                = aio->a_cancel_fn;\n\t\targ               = aio->a_cancel_arg;\n\t\taio->a_cancel_fn  = NULL;\n\t\taio->a_cancel_arg = NULL;\n\t\taio->a_stop       = true;\n\t\tnni_mtx_unlock(&eq->eq_mtx);\n\n\t\tif (fn != NULL) {\n\t\t\tfn(aio, arg, NNG_ECANCELED);\n\t\t}\n\n\t\tnni_aio_wait(aio);\n\t}\n}", "path": "nng/src/core/aio.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// nni_http_transact_conn sends a request to an HTTP server, and reads the\n// response.  It also attempts to read any associated data.  Note that\n// at present it can only read data that comes in normally, as support\n// for Chunked Transfer Encoding is missing.  Note that cancelling the aio\n// is generally fatal to the connection.\n", "func_signal": "void\nnni_http_transact_conn(\n    nni_http_conn *conn, nni_http_req *req, nni_http_res *res, nni_aio *aio)", "code": "{\n\thttp_txn *txn;\n\tint       rv;\n\n\tnni_initialize(&http_client_initializer);\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tif ((txn = NNI_ALLOC_STRUCT(txn)) == NULL) {\n\t\tnni_aio_finish_error(aio, NNG_ENOMEM);\n\t\treturn;\n\t}\n\tif ((rv = nni_aio_alloc(&txn->aio, http_txn_cb, txn)) != 0) {\n\t\tNNI_FREE_STRUCT(txn);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tnni_aio_list_init(&txn->aios);\n\ttxn->client = NULL;\n\ttxn->conn   = conn;\n\ttxn->req    = req;\n\ttxn->res    = res;\n\ttxn->state  = HTTP_SENDING;\n\n\tnni_mtx_lock(&http_txn_lk);\n\tif ((rv = nni_aio_schedule(aio, http_txn_cancel, txn)) != 0) {\n\t\tnni_mtx_unlock(&http_txn_lk);\n\t\tnni_aio_finish_error(aio, rv);\n\t\thttp_txn_fini(txn);\n\t\treturn;\n\t}\n\tnni_http_res_reset(txn->res);\n\tnni_list_append(&txn->aios, aio);\n\tnni_http_write_req(conn, req, txn->aio);\n\tnni_mtx_unlock(&http_txn_lk);\n}", "path": "nng/src/supplemental/http/http_client.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// nni_http_handler_fini just drops the reference count, only destroying\n// the handler if the reference drops to zero.\n", "func_signal": "void\nnni_http_handler_fini(nni_http_handler *h)", "code": "{\n\tif (nni_atomic_dec64_nv(&h->ref) != 0) {\n\t\treturn;\n\t}\n\tif (h->dtor != NULL) {\n\t\th->dtor(h->data);\n\t}\n\tnni_strfree(h->host);\n\tnni_strfree(h->uri);\n\tnni_strfree(h->method);\n\tNNI_FREE_STRUCT(h);\n}", "path": "nng/src/supplemental/http/http_server.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// REP server implemented via callbacks.\n", "func_signal": "static void\nrep_recv_cb(void *arg)", "code": "{\n\ttest_case *c = arg;\n\tint        rv;\n\n\tif ((rv = nng_aio_result(c->recv_aio)) != 0) {\n\t\terror(c, \"recv\", rv);\n\t\treturn;\n\t}\n\tc->nrecv++;\n\tnng_aio_set_msg(c->send_aio, nng_aio_get_msg(c->recv_aio));\n\tnng_aio_set_msg(c->recv_aio, NULL);\n\tnng_send_aio(c->socket, c->send_aio);\n}", "path": "nng/tests/reqstress.c", "commit_date": "2019-12-25 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// I/O provider related functions.\n", "func_signal": "static void\nnni_aio_finish_impl(\n    nni_aio *aio, int rv, size_t count, nni_msg *msg, bool sync)", "code": "{\n\tnni_aio_expire_q *eq = aio->a_expire_q;\n\n\tnni_mtx_lock(&eq->eq_mtx);\n\n\tnni_list_node_remove(&aio->a_expire_node);\n\taio->a_result     = rv;\n\taio->a_count      = count;\n\taio->a_cancel_fn  = NULL;\n\taio->a_cancel_arg = NULL;\n\tif (msg) {\n\t\taio->a_msg = msg;\n\t}\n\n\taio->a_expire = NNI_TIME_NEVER;\n\taio->a_sleep  = false;\n\tnni_mtx_unlock(&eq->eq_mtx);\n\n\tif (sync) {\n\t\tnni_task_exec(&aio->a_task);\n\t} else {\n\t\tnni_task_dispatch(&aio->a_task);\n\t}\n}", "path": "nng/src/core/aio.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// nni_plat_file_delete deletes the named file.\n", "func_signal": "int\nnni_plat_file_delete(const char *name)", "code": "{\n\tint rv;\n\tif (RemoveDirectory(name)) {\n\t\treturn (0);\n\t}\n\tif (DeleteFile(name)) {\n\t\treturn (0);\n\t}\n\tif ((rv = nni_win_error(GetLastError())) == NNG_ENOENT) {\n\t\treturn (0);\n\t}\n\treturn (rv);\n}", "path": "nng/src/platform/windows/win_file.c", "commit_date": "2018-10-12 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// This converts a Windows API error (from GetLastError()) to an\n// nng standard error code.\n", "func_signal": "int\nnni_win_error(int errnum)", "code": "{\n\tint i;\n\n\tif (errnum == 0) {\n\t\treturn (0);\n\t}\n\tfor (i = 0; nni_win_errnos[i].win_err != 0; i++) {\n\t\tif (errnum == nni_win_errnos[i].win_err) {\n\t\t\treturn (nni_win_errnos[i].nng_err);\n\t\t}\n\t}\n\t// Other system errno.\n\treturn (NNG_ESYSERR + errnum);\n}", "path": "nng/src/platform/windows/win_debug.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// Get a random address -- TCP, IP, whatever.\n", "func_signal": "char *\ngetaddr(char *buf)", "code": "{\n\tint i;\n\ti = rand() % NTEMPLATES;\n\n\tsnprintf(buf, NNG_MAXADDRLEN, templates[i], next_port++);\n\treturn (buf);\n}", "path": "nng/tests/reqstress.c", "commit_date": "2019-12-25 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// nni_plat_file_put writes the named file, with the provided data,\n// and the given size.  If the file already exists it is overwritten.\n// The permissions on the file should be limited to read and write\n// access by the entity running the application only.\n", "func_signal": "int\nnni_plat_file_put(const char *name, const void *data, size_t len)", "code": "{\n\tHANDLE h;\n\tint    rv = 0;\n\tDWORD  nwrite;\n\n\tif ((rv = nni_plat_make_parent_dirs(name)) != 0) {\n\t\treturn (rv);\n\t}\n\n\th = CreateFile(name, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,\n\t    FILE_ATTRIBUTE_NORMAL, NULL);\n\tif (h == INVALID_HANDLE_VALUE) {\n\t\treturn (nni_win_error(GetLastError()));\n\t}\n\n\tif (!WriteFile(h, data, (DWORD) len, &nwrite, NULL)) {\n\t\trv = nni_win_error(GetLastError());\n\t\t(void) DeleteFile(name);\n\t\tgoto done;\n\t}\n\t// These are regular files, synchronous operations.  If we got a\n\t// short write, then we should have gotten an error!\n\tNNI_ASSERT(nwrite == len);\n\ndone:\n\t(void) CloseHandle(h);\n\treturn (rv);\n}", "path": "nng/src/platform/windows/win_file.c", "commit_date": "2018-10-12 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// Symbols in this file are \"public\" versions of the HTTP API.\n// These are suitable for exposure to applications.\n", "func_signal": "int\nnng_http_req_alloc(nng_http_req **reqp, const nng_url *url)", "code": "{\n#ifdef NNG_SUPP_HTTP\n\tnni_init();\n\treturn (nni_http_req_alloc(reqp, url));\n#else\n\tNNI_ARG_UNUSED(reqp);\n\tNNI_ARG_UNUSED(url);\n\treturn (NNG_ENOTSUP);\n#endif\n}", "path": "nng/src/supplemental/http/http_public.c", "commit_date": "2020-11-16 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// NNG_ENABLE_STATS\n", "func_signal": "void\nnni_listener_bump_error(nni_listener *l, int err)", "code": "{\n#ifdef NNG_ENABLE_STATS\n\tswitch (err) {\n\tcase NNG_ECONNABORTED:\n\tcase NNG_ECONNRESET:\n\t\tnni_stat_inc(&l->st_disconnect, 1);\n\t\tbreak;\n\tcase NNG_ECANCELED:\n\t\tnni_stat_inc(&l->st_canceled, 1);\n\t\tbreak;\n\tcase NNG_ETIMEDOUT:\n\t\tnni_stat_inc(&l->st_timeout, 1);\n\t\tbreak;\n\tcase NNG_EPROTO:\n\t\tnni_stat_inc(&l->st_proto, 1);\n\t\tbreak;\n\tcase NNG_EPEERAUTH:\n\tcase NNG_ECRYPTO:\n\t\tnni_stat_inc(&l->st_auth, 1);\n\t\tbreak;\n\tcase NNG_ENOMEM:\n\t\tnni_stat_inc(&l->st_oom, 1);\n\t\tbreak;\n\tdefault:\n\t\tnni_stat_inc(&l->st_other, 1);\n\t\tbreak;\n\t}\n#endif\n}", "path": "nng/src/core/listener.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// nni_http_transact_simple does a single transaction, creating a connection\n// just for the purpose, and closing it when done.  (No connection caching.)\n// The reason we require a client to be created first is to deal with TLS\n// settings.  A single global client (per server) may be used.\n", "func_signal": "void\nnni_http_transact(nni_http_client *client, nni_http_req *req,\n    nni_http_res *res, nni_aio *aio)", "code": "{\n\thttp_txn *txn;\n\tint       rv;\n\n\tnni_initialize(&http_client_initializer);\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tif ((txn = NNI_ALLOC_STRUCT(txn)) == NULL) {\n\t\tnni_aio_finish_error(aio, NNG_ENOMEM);\n\t\treturn;\n\t}\n\tif ((rv = nni_aio_alloc(&txn->aio, http_txn_cb, txn)) != 0) {\n\t\tNNI_FREE_STRUCT(txn);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\n\tif ((rv = nni_http_req_set_header(req, \"Connection\", \"close\")) != 0) {\n\t\tnni_aio_finish_error(aio, rv);\n\t\thttp_txn_fini(txn);\n\t\treturn;\n\t}\n\n\tnni_aio_list_init(&txn->aios);\n\ttxn->client = client;\n\ttxn->conn   = NULL;\n\ttxn->req    = req;\n\ttxn->res    = res;\n\ttxn->state  = HTTP_CONNECTING;\n\n\tnni_mtx_lock(&http_txn_lk);\n\tif ((rv = nni_aio_schedule(aio, http_txn_cancel, txn)) != 0) {\n\t\tnni_mtx_unlock(&http_txn_lk);\n\t\tnni_aio_finish_error(aio, rv);\n\t\thttp_txn_fini(txn);\n\t\treturn;\n\t}\n\tnni_http_res_reset(txn->res);\n\tnni_list_append(&txn->aios, aio);\n\tnni_http_client_connect(client, txn->aio);\n\tnni_mtx_unlock(&http_txn_lk);\n}", "path": "nng/src/supplemental/http/http_client.c", "commit_date": "2020-12-12 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// nni_aio_abort is called by a consumer which guarantees that the aio\n// is still valid.\n", "func_signal": "void\nnni_aio_abort(nni_aio *aio, int rv)", "code": "{\n\tnni_aio_cancel_fn fn;\n\tvoid *            arg;\n\tnni_aio_expire_q *eq = aio->a_expire_q;\n\n\tnni_mtx_lock(&eq->eq_mtx);\n\tnni_list_node_remove(&aio->a_expire_node);\n\tfn                = aio->a_cancel_fn;\n\targ               = aio->a_cancel_arg;\n\taio->a_cancel_fn  = NULL;\n\taio->a_cancel_arg = NULL;\n\tnni_mtx_unlock(&eq->eq_mtx);\n\n\t// Stop any I/O at the provider level.\n\tif (fn != NULL) {\n\t\tfn(aio, arg, rv);\n\t}\n}", "path": "nng/src/core/aio.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// This function is not supported, but we keep it around to\n// satisfy link dependencies in old programs.  It has never done\n// anything useful.\n", "func_signal": "int\nnng_msg_getopt(nng_msg *msg, int opt, void *ptr, size_t *szp)", "code": "{\n\tNNI_ARG_UNUSED(msg);\n\tNNI_ARG_UNUSED(opt);\n\tNNI_ARG_UNUSED(ptr);\n\tNNI_ARG_UNUSED(szp);\n\treturn (NNG_ENOTSUP);\n}", "path": "nng/src/nng_legacy.c", "commit_date": "2020-11-16 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// nni_plat_file_get reads the entire named file, allocating storage\n// to receive the data and returning the data and the size in the\n// reference arguments.\n", "func_signal": "int\nnni_plat_file_get(const char *name, void **datap, size_t *lenp)", "code": "{\n\tint    rv = 0;\n\tvoid * data;\n\tDWORD  sz;\n\tDWORD  nread;\n\tHANDLE h;\n\n\th = CreateFile(name, GENERIC_READ, 0, NULL, OPEN_EXISTING,\n\t    FILE_ATTRIBUTE_NORMAL, NULL);\n\tif (h == INVALID_HANDLE_VALUE) {\n\t\treturn (nni_win_error(GetLastError()));\n\t}\n\t// We choose not to support extraordinarily large files (>4GB)\n\tif ((sz = GetFileSize(h, NULL)) == INVALID_FILE_SIZE) {\n\t\trv = nni_win_error(GetLastError());\n\t\tgoto done;\n\t}\n\tif (sz > 0) {\n\t\tif ((data = nni_alloc((size_t) sz)) == NULL) {\n\t\t\trv = NNG_ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tif (!ReadFile(h, data, sz, &nread, NULL)) {\n\t\t\trv = nni_win_error(GetLastError());\n\t\t\tnni_free(data, sz);\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tdata  = NULL;\n\t\tnread = 0;\n\t}\n\n\t// We can get a short read, indicating end of file.  We return\n\t// the actual number of bytes read.  The fact that the data buffer\n\t// is larger than this is ok, because our nni_free() routine just\n\t// uses HeapFree(), which doesn't need a matching size.\n\n\t*datap = data;\n\t*lenp  = (size_t) nread;\ndone:\n\t(void) CloseHandle(h);\n\treturn (rv);\n}", "path": "nng/src/platform/windows/win_file.c", "commit_date": "2018-10-12 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// Call with optidx set to 1 to start parsing.\n", "func_signal": "int\nnng_opts_parse(int argc, char *const *argv, const nng_optspec *opts, int *val,\n    char **optarg, int *optidx)", "code": "{\n\tconst nng_optspec *opt;\n\tint                matches;\n\tbool               shortopt;\n\tsize_t             l;\n\tchar *             arg;\n\tint                i;\n\n\tif ((i = *optidx) >= argc) {\n\t\treturn (-1);\n\t}\n\targ = argv[*optidx];\n\n\tif (arg[0] != '-') {\n\t\treturn (-1);\n\t}\n\tif (arg[1] == '\\0') {\n\t\t*optidx = i + 1;\n\t\treturn (-1);\n\t}\n\n\tif ((arg[0] == '-') && (arg[1] == '-')) {\n\t\targ += 2;\n\t\tshortopt = false;\n\t\tfor (l = 0; arg[l] != '\\0'; l++) {\n\t\t\tif ((arg[l] == '=') || (arg[l] == ':')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\targ++;\n\t\tshortopt = true;\n\t\tl        = 1;\n\t}\n\n\tmatches = 0;\n\topt     = NULL;\n\n\tfor (int x = 0; opts[x].o_val != 0; x++) {\n\n\t\tif (shortopt) {\n\t\t\tif (arg[0] == opts[x].o_short) {\n\t\t\t\tmatches = 1;\n\t\t\t\topt     = &opts[x];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((opts[x].o_name == NULL) ||\n\t\t    (strncmp(arg, opts[x].o_name, l) != 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmatches++;\n\t\topt = &opts[x];\n\n\t\tif (strlen(opts[x].o_name) == l) {\n\t\t\t// Perfect match.\n\t\t\tmatches = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (matches) {\n\tcase 1:\n\t\t// Exact match\n\t\tbreak;\n\tcase 0:\n\t\t// No such option\n\t\treturn (NNG_EINVAL);\n\t\tbreak;\n\tdefault:\n\t\t// Ambiguous (not match)\n\t\treturn (NNG_EAMBIGUOUS);\n\t\tbreak;\n\t}\n\n\tif (!opt->o_arg) {\n\t\t// No option clustering for short options yet.\n\t\tif (arg[l] != '\\0') {\n\t\t\treturn (NNG_EINVAL);\n\t\t}\n\t\t*val    = opt->o_val;\n\t\t*optidx = i + 1;\n\t\treturn (0);\n\t}\n\n\tif (arg[l] != '\\0') {\n\t\tif (shortopt) {\n\t\t\t*optarg = arg + l;\n\t\t} else {\n\t\t\t*optarg = arg + l + 1;\n\t\t}\n\t} else {\n\t\ti++;\n\t\tif (i >= argc) {\n\t\t\treturn (NNG_ENOARG);\n\t\t}\n\t\t*optarg = argv[i];\n\t}\n\t*optidx = ++i;\n\t*val    = opt->o_val;\n\n\treturn (0);\n}", "path": "nng/src/supplemental/util/options.c", "commit_date": "2018-12-23 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// XXX: REPLACE THIS WITH CODE USING THE URL FRAMEWORK.\n", "func_signal": "static char *\nhttp_uri_canonify(char *path)", "code": "{\n\tchar *tmp;\n\tchar *dst;\n\n\t// Chomp off query string.\n\tif ((tmp = strchr(path, '?')) != NULL) {\n\t\t*tmp = '\\0';\n\t}\n\t// If the URI was absolute, make it relative.\n\tif ((nni_strncasecmp(path, \"http://\", strlen(\"http://\")) == 0) ||\n\t    (nni_strncasecmp(path, \"https://\", strlen(\"https://\")) == 0)) {\n\t\t// Skip past the ://\n\t\tpath = strchr(path, ':');\n\t\tpath += 3;\n\n\t\t// scan for the end of the host, distinguished by a /\n\t\t// path delimiter.  There might not be one, in which\n\t\t// case the whole thing is the host and we assume the\n\t\t// path is just /.\n\t\tif ((path = strchr(path, '/')) == NULL) {\n\t\t\treturn (\"/\");\n\t\t}\n\t}\n\n\t// Now we have to unescape things.  Unescaping is a shrinking\n\t// operation (strictly), so this is safe.  This is just URL\n\t// decode. Note that paths with an embedded NUL are going to be\n\t// treated as though truncated.  Don't be that guy that sends\n\t// %00 in a URL.\n\t//\n\t// XXX: Normalizer needs to leave % encoded stuff in there if\n\t// the characters to which they refer are reserved.  See RFC 3986\n\t// section 6.2.2.\n\ttmp = path;\n\tdst = path;\n\twhile (*tmp != '\\0') {\n\t\tchar c;\n\t\tif ((c = *tmp) != '%') {\n\t\t\t*dst++ = c;\n\t\t\ttmp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isxdigit(tmp[1]) && isxdigit(tmp[2])) {\n\t\t\tc = http_hexval(tmp[1]);\n\t\t\tc *= 16;\n\t\t\tc += http_hexval(tmp[2]);\n\t\t\t*dst++ = c;\n\t\t\ttmp += 3;\n\t\t}\n\t\t// garbage in, garbage out\n\t\t*dst++ = c;\n\t\ttmp++;\n\t}\n\t*dst = '\\0';\n\n\treturn ((strlen(path) != 0) ? path : \"/\");\n}", "path": "nng/src/supplemental/http/http_server.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// File support.\n", "func_signal": "static char *\nnni_plat_find_pathsep(char *path)", "code": "{\n\tchar *p;\n\t// Legal path separators are \"\\\\\" and \"/\" under Windows.\n\t// This is sort of a poormans strchr, but with the two specific\n\t// separator characters instead.\n\tfor (p = path; *p != '\\0'; p++) {\n\t\tif ((*p == '/') || (*p == '\\\\')) {\n\t\t\treturn (p);\n\t\t}\n\t}\n\treturn (NULL);\n}", "path": "nng/src/platform/windows/win_file.c", "commit_date": "2018-10-12 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "// http_rd_buf attempts to satisfy the read from data in the buffer.\n", "func_signal": "static int\nhttp_rd_buf(nni_http_conn *conn, nni_aio *aio)", "code": "{\n\tsize_t   cnt = conn->rd_put - conn->rd_get;\n\tsize_t   n;\n\tuint8_t *rbuf = conn->rd_buf;\n\tint      rv;\n\tbool     raw = false;\n\tnni_iov *iov;\n\tunsigned nio;\n\n\trbuf += conn->rd_get;\n\n\tswitch (GET_RD_FLAVOR(aio)) {\n\tcase HTTP_RD_RAW:\n\t\traw = true; // FALLTHROUGH\n\tcase HTTP_RD_FULL:\n\t\tnni_aio_get_iov(aio, &nio, &iov);\n\t\twhile ((nio != 0) && (cnt != 0)) {\n\t\t\t// Pull up data from the buffer if possible.\n\t\t\tn = iov[0].iov_len;\n\t\t\tif (n > cnt) {\n\t\t\t\tn = cnt;\n\t\t\t}\n\t\t\tmemcpy(iov[0].iov_buf, rbuf, n);\n\t\t\tiov[0].iov_len -= n;\n\t\t\tNNI_INCPTR(iov[0].iov_buf, n);\n\t\t\tconn->rd_get += n;\n\t\t\trbuf += n;\n\t\t\tnni_aio_bump_count(aio, n);\n\t\t\tcnt -= n;\n\n\t\t\tif (iov[0].iov_len == 0) {\n\t\t\t\tnio--;\n\t\t\t\tiov = &iov[1];\n\t\t\t}\n\t\t}\n\n\t\tnni_aio_set_iov(aio, nio, iov);\n\n\t\tif ((nio == 0) || (raw && (nni_aio_count(aio) != 0))) {\n\t\t\t// Finished the read.  (We are finished if we either\n\t\t\t// got *all* the data, or we got *some* data for\n\t\t\t// a raw read.)\n\t\t\treturn (0);\n\t\t}\n\n\t\t// No more data left in the buffer, so use a physio.\n\t\t// (Note that we get here if we either have not completed\n\t\t// a full transaction on a FULL read, or were not even able\n\t\t// to get *any* data for a partial RAW read.)\n\t\tconn->rd_buffered = false;\n\t\tnni_aio_set_iov(conn->rd_aio, nio, iov);\n\t\tnng_stream_recv(conn->sock, conn->rd_aio);\n\t\treturn (NNG_EAGAIN);\n\n\tcase HTTP_RD_REQ:\n\t\trv = nni_http_req_parse(\n\t\t    nni_aio_get_prov_extra(aio, 1), rbuf, cnt, &n);\n\t\tconn->rd_get += n;\n\t\tif (conn->rd_get == conn->rd_put) {\n\t\t\tconn->rd_get = conn->rd_put = 0;\n\t\t}\n\t\tif (rv == NNG_EAGAIN) {\n\t\t\tnni_iov iov1;\n\t\t\tiov1.iov_buf      = conn->rd_buf + conn->rd_put;\n\t\t\tiov1.iov_len      = conn->rd_bufsz - conn->rd_put;\n\t\t\tconn->rd_buffered = true;\n\t\t\tnni_aio_set_iov(conn->rd_aio, 1, &iov1);\n\t\t\tnng_stream_recv(conn->sock, conn->rd_aio);\n\t\t}\n\t\treturn (rv);\n\n\tcase HTTP_RD_RES:\n\t\trv = nni_http_res_parse(\n\t\t    nni_aio_get_prov_extra(aio, 1), rbuf, cnt, &n);\n\t\tconn->rd_get += n;\n\t\tif (conn->rd_get == conn->rd_put) {\n\t\t\tconn->rd_get = conn->rd_put = 0;\n\t\t}\n\t\tif (rv == NNG_EAGAIN) {\n\t\t\tnni_iov iov1;\n\t\t\tiov1.iov_buf      = conn->rd_buf + conn->rd_put;\n\t\t\tiov1.iov_len      = conn->rd_bufsz - conn->rd_put;\n\t\t\tconn->rd_buffered = true;\n\t\t\tnni_aio_set_iov(conn->rd_aio, 1, &iov1);\n\t\t\tnng_stream_recv(conn->sock, conn->rd_aio);\n\t\t}\n\t\treturn (rv);\n\n\tcase HTTP_RD_CHUNK:\n\t\trv = nni_http_chunks_parse(\n\t\t    nni_aio_get_prov_extra(aio, 1), rbuf, cnt, &n);\n\t\tconn->rd_get += n;\n\t\tif (conn->rd_get == conn->rd_put) {\n\t\t\tconn->rd_get = conn->rd_put = 0;\n\t\t}\n\t\tif (rv == NNG_EAGAIN) {\n\t\t\tnni_iov iov1;\n\t\t\tiov1.iov_buf      = conn->rd_buf + conn->rd_put;\n\t\t\tiov1.iov_len      = conn->rd_bufsz - conn->rd_put;\n\t\t\tconn->rd_buffered = true;\n\t\t\tnni_aio_set_iov(conn->rd_aio, 1, &iov1);\n\t\t\tnng_stream_recv(conn->sock, conn->rd_aio);\n\t\t}\n\t\treturn (rv);\n\t}\n\treturn (NNG_EINVAL);\n}", "path": "nng/src/supplemental/http/http_conn.c", "commit_date": "2020-11-16 00:00:00", "repo_name": "nanomsg/nng", "stars": 3510, "license": "mit", "language": "c", "size": 14882}
{"docstring": "/* Token-bucket traffic policers are common (see \"An Internet-Wide Analysis of\n * Traffic Policing\", SIGCOMM 2016). BBR detects token-bucket policers and\n * explicitly models their policed rate, to reduce unnecessary losses. We\n * estimate that we're policed if we see 2 consecutive sampling intervals with\n * consistent throughput and high packet loss. If we think we're being policed,\n * set lt_bw to the \"long-term\" average delivery rate from those 2 intervals.\n */\n", "func_signal": "static void bbr_lt_bw_sampling(struct sock *sk, const struct rate_sample *rs)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu32 lost, delivered;\n\tu64 bw;\n\ts32 t;\n\n\tif (bbr->lt_use_bw) {\t/* already using long-term rate, lt_bw? */\n\t\tif (bbr->mode == BBR_PROBE_BW && bbr->round_start &&\n\t\t    ++bbr->lt_rtt_cnt >= bbr_lt_bw_max_rtts) {\n\t\t\tbbr_reset_lt_bw_sampling(sk);    /* stop using lt_bw */\n\t\t\tbbr_reset_probe_bw_mode(sk);  /* restart gain cycling */\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Wait for the first loss before sampling, to let the policer exhaust\n\t * its tokens and estimate the steady-state rate allowed by the policer.\n\t * Starting samples earlier includes bursts that over-estimate the bw.\n\t */\n\tif (!bbr->lt_is_sampling) {\n\t\tif (!rs->losses)\n\t\t\treturn;\n\t\tbbr_reset_lt_bw_sampling_interval(sk);\n\t\tbbr->lt_is_sampling = true;\n\t}\n\n\t/* To avoid underestimates, reset sampling if we run out of data. */\n\tif (rs->is_app_limited) {\n\t\tbbr_reset_lt_bw_sampling(sk);\n\t\treturn;\n\t}\n\n\tif (bbr->round_start)\n\t\tbbr->lt_rtt_cnt++;\t/* count round trips in this interval */\n\tif (bbr->lt_rtt_cnt < bbr_lt_intvl_min_rtts)\n\t\treturn;\t\t/* sampling interval needs to be longer */\n\tif (bbr->lt_rtt_cnt > 4 * bbr_lt_intvl_min_rtts) {\n\t\tbbr_reset_lt_bw_sampling(sk);  /* interval is too long */\n\t\treturn;\n\t}\n\n\t/* End sampling interval when a packet is lost, so we estimate the\n\t * policer tokens were exhausted. Stopping the sampling before the\n\t * tokens are exhausted under-estimates the policed rate.\n\t */\n\tif (!rs->losses)\n\t\treturn;\n\n\t/* Calculate packets lost and delivered in sampling interval. */\n\tlost = tp->lost - bbr->lt_last_lost;\n\tdelivered = tp->delivered - bbr->lt_last_delivered;\n\t/* Is loss rate (lost/delivered) >= lt_loss_thresh? If not, wait. */\n\tif (!delivered || (lost << BBR_SCALE) < bbr_lt_loss_thresh * delivered)\n\t\treturn;\n\n\t/* Find average delivery rate in this sampling interval. */\n\tt = (s32)(tp->delivered_mstamp.stamp_jiffies - bbr->lt_last_stamp);\n\tif (t < 1)\n\t\treturn;\t\t/* interval is less than one jiffy, so wait */\n\tt = jiffies_to_usecs(t);\n\t/* Interval long enough for jiffies_to_usecs() to return a bogus 0? */\n\tif (t < 1) {\n\t\tbbr_reset_lt_bw_sampling(sk);  /* interval too long; reset */\n\t\treturn;\n\t}\n\tbw = (u64)delivered * BW_UNIT;\n\tdo_div(bw, t);\n\tbbr_lt_bw_interval_done(sk, bw);\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Return rate in bytes per second, optionally with a gain.\n * The order here is chosen carefully to avoid overflow of u64. This should\n * work for input rates of up to 2.9Tbit/sec and gain of 2.89x.\n */\n", "func_signal": "static u64 bbr_rate_bytes_per_sec(struct sock *sk, u64 rate, int gain)", "code": "{\n\trate *= tcp_mss_to_mtu(sk, tcp_sk(sk)->mss_cache);\n\trate *= gain;\n\trate >>= BBR_SCALE;\n\trate *= USEC_PER_SEC;\n\treturn rate >> BW_SCALE;\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Gain cycling: cycle pacing gain to converge to fair share of available bw. */\n", "func_signal": "static void bbr_update_cycle_phase(struct sock *sk,\n\t\t\t\t   const struct rate_sample *rs)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tif ((bbr->mode == BBR_PROBE_BW) && !bbr->lt_use_bw &&\n\t    bbr_is_next_cycle_phase(sk, rs))\n\t\tbbr_advance_cycle_phase(sk);\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Return count of segments we want in the skbs we send, or 0 for default. */\n", "func_signal": "static u32 bbr_tso_segs_goal(struct sock *sk)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\treturn bbr->tso_segs_goal;\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Return the estimated bandwidth of the path, in pkts/uS << BW_SCALE. */\n", "func_signal": "static u32 bbr_bw(const struct sock *sk)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\treturn bbr->lt_use_bw ? bbr->lt_bw : bbr_max_bw(sk);\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Start a new long-term sampling interval. */\n", "func_signal": "static void bbr_reset_lt_bw_sampling_interval(struct sock *sk)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tbbr->lt_last_stamp = tp->delivered_mstamp.stamp_jiffies;\n\tbbr->lt_last_delivered = tp->delivered;\n\tbbr->lt_last_lost = tp->lost;\n\tbbr->lt_rtt_cnt = 0;\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Long-term bw sampling interval is done. Estimate whether we're policed. */\n", "func_signal": "static void bbr_lt_bw_interval_done(struct sock *sk, u32 bw)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu32 diff;\n\n\tif (bbr->lt_bw) {  /* do we have bw from a previous interval? */\n\t\t/* Is new bw close to the lt_bw from the previous interval? */\n\t\tdiff = abs(bw - bbr->lt_bw);\n\t\tif ((diff * BBR_UNIT <= bbr_lt_bw_ratio * bbr->lt_bw) ||\n\t\t    (bbr_rate_bytes_per_sec(sk, diff, BBR_UNIT) <=\n\t\t     bbr_lt_bw_diff)) {\n\t\t\t/* All criteria are met; estimate we're policed. */\n\t\t\tbbr->lt_bw = (bw + bbr->lt_bw) >> 1;  /* avg 2 intvls */\n\t\t\tbbr->lt_use_bw = 1;\n\t\t\tbbr->pacing_gain = BBR_UNIT;  /* try to avoid drops */\n\t\t\tbbr->lt_rtt_cnt = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tbbr->lt_bw = bw;\n\tbbr_reset_lt_bw_sampling_interval(sk);\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Pace using current bw estimate and a gain factor. In order to help drive the\n * network toward lower queues while maintaining high utilization and low\n * latency, the average pacing rate aims to be slightly (~1%) lower than the\n * estimated bandwidth. This is an important aspect of the design. In this\n * implementation this slightly lower pacing rate is achieved implicitly by not\n * including link-layer headers in the packet size used for the pacing rate.\n */\n", "func_signal": "static void bbr_set_pacing_rate(struct sock *sk, u32 bw, int gain)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu64 rate = bw;\n\n\trate = bbr_rate_bytes_per_sec(sk, rate, gain);\n\trate = min_t(u64, rate, sk->sk_max_pacing_rate);\n\tif (bbr->mode != BBR_STARTUP || rate > sk->sk_pacing_rate)\n\t\tsk->sk_pacing_rate = rate;\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Start a new long-term sampling interval. */\n", "func_signal": "static void bbr_reset_lt_bw_sampling_interval(struct sock *sk)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tbbr->lt_last_stamp = tp->delivered_mstamp.stamp_jiffies;\n\tbbr->lt_last_delivered = tp->delivered;\n\tbbr->lt_last_lost = tp->lost;\n\tbbr->lt_rtt_cnt = 0;\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Return count of segments we want in the skbs we send, or 0 for default. */\n", "func_signal": "static u32 bbr_tso_segs_goal(struct sock *sk)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\treturn bbr->tso_segs_goal;\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Entering loss recovery, so save cwnd for when we exit or undo recovery. */\n", "func_signal": "static u32 bbr_ssthresh(struct sock *sk)", "code": "{\n\tbbr_save_cwnd(sk);\n\treturn TCP_INFINITE_SSTHRESH;\t /* BBR does not use ssthresh */\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Pace using current bw estimate and a gain factor. In order to help drive the\n * network toward lower queues while maintaining high utilization and low\n * latency, the average pacing rate aims to be slightly (~1%) lower than the\n * estimated bandwidth. This is an important aspect of the design. In this\n * implementation this slightly lower pacing rate is achieved implicitly by not\n * including link-layer headers in the packet size used for the pacing rate.\n */\n", "func_signal": "static void bbr_set_pacing_rate(struct sock *sk, u32 bw, int gain)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu64 rate = bw;\n\n\trate = bbr_rate_bytes_per_sec(sk, rate, gain);\n\trate = min_t(u64, rate, sk->sk_max_pacing_rate);\n\tif (bbr->mode != BBR_STARTUP || rate > sk->sk_pacing_rate)\n\t\tsk->sk_pacing_rate = rate;\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Save \"last known good\" cwnd so we can restore it after losses or PROBE_RTT */\n", "func_signal": "static void bbr_save_cwnd(struct sock *sk)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tif (bbr->prev_ca_state < TCP_CA_Recovery && bbr->mode != BBR_PROBE_RTT)\n\t\tbbr->prior_cwnd = tp->snd_cwnd;  /* this cwnd is good enough */\n\telse  /* loss recovery or BBR_PROBE_RTT have temporarily cut cwnd */\n\t\tbbr->prior_cwnd = max(bbr->prior_cwnd, tp->snd_cwnd);\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Estimate when the pipe is full, using the change in delivery rate: BBR\n * estimates that STARTUP filled the pipe if the estimated bw hasn't changed by\n * at least bbr_full_bw_thresh (25%) after bbr_full_bw_cnt (3) non-app-limited\n * rounds. Why 3 rounds: 1: rwin autotuning grows the rwin, 2: we fill the\n * higher rwin, 3: we get higher delivery rate samples. Or transient\n * cross-traffic or radio noise can go away. CUBIC Hystart shares a similar\n * design goal, but uses delay and inter-ACK spacing instead of bandwidth.\n */\n", "func_signal": "static void bbr_check_full_bw_reached(struct sock *sk,\n\t\t\t\t      const struct rate_sample *rs)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu32 bw_thresh;\n\n\tif (bbr_full_bw_reached(sk) || !bbr->round_start || rs->is_app_limited)\n\t\treturn;\n\n\tbw_thresh = (u64)bbr->full_bw * bbr_full_bw_thresh >> BBR_SCALE;\n\tif (bbr_max_bw(sk) >= bw_thresh) {\n\t\tbbr->full_bw = bbr_max_bw(sk);\n\t\tbbr->full_bw_cnt = 0;\n\t\treturn;\n\t}\n\t++bbr->full_bw_cnt;\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* An optimization in BBR to reduce losses: On the first round of recovery, we\n * follow the packet conservation principle: send P packets per P packets acked.\n * After that, we slow-start and send at most 2*P packets per P packets acked.\n * After recovery finishes, or upon undo, we restore the cwnd we had when\n * recovery started (capped by the target cwnd based on estimated BDP).\n *\n * TODO(ycheng/ncardwell): implement a rate-based approach.\n */\n", "func_signal": "static bool bbr_set_cwnd_to_recover_or_restore(\n\tstruct sock *sk, const struct rate_sample *rs, u32 acked, u32 *new_cwnd)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu8 prev_state = bbr->prev_ca_state, state = inet_csk(sk)->icsk_ca_state;\n\tu32 cwnd = tp->snd_cwnd;\n\n\t/* An ACK for P pkts should release at most 2*P packets. We do this\n\t * in two steps. First, here we deduct the number of lost packets.\n\t * Then, in bbr_set_cwnd() we slow start up toward the target cwnd.\n\t */\n\tif (rs->losses > 0)\n\t\tcwnd = max_t(s32, cwnd - rs->losses, 1);\n\n\tif (state == TCP_CA_Recovery && prev_state != TCP_CA_Recovery) {\n\t\t/* Starting 1st round of Recovery, so do packet conservation. */\n\t\tbbr->packet_conservation = 1;\n\t\tbbr->next_rtt_delivered = tp->delivered;  /* start round now */\n\t\t/* Cut unused cwnd from app behavior, TSQ, or TSO deferral: */\n\t\tcwnd = tcp_packets_in_flight(tp) + acked;\n\t} else if (prev_state >= TCP_CA_Recovery && state < TCP_CA_Recovery) {\n\t\t/* Exiting loss recovery; restore cwnd saved before recovery. */\n\t\tbbr->restore_cwnd = 1;\n\t\tbbr->packet_conservation = 0;\n\t}\n\tbbr->prev_ca_state = state;\n\n\tif (bbr->restore_cwnd) {\n\t\t/* Restore cwnd after exiting loss recovery or PROBE_RTT. */\n\t\tcwnd = max(cwnd, bbr->prior_cwnd);\n\t\tbbr->restore_cwnd = 0;\n\t}\n\n\tif (bbr->packet_conservation) {\n\t\t*new_cwnd = max(cwnd, tcp_packets_in_flight(tp) + acked);\n\t\treturn true;\t/* yes, using packet conservation */\n\t}\n\t*new_cwnd = cwnd;\n\treturn false;\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Entering loss recovery, so save cwnd for when we exit or undo recovery. */\n", "func_signal": "static u32 bbr_ssthresh(struct sock *sk)", "code": "{\n\tbbr_save_cwnd(sk);\n\treturn TCP_INFINITE_SSTHRESH;\t /* BBR does not use ssthresh */\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* If pipe is probably full, drain the queue and then enter steady-state. */\n", "func_signal": "static void bbr_check_drain(struct sock *sk, const struct rate_sample *rs)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tif (bbr->mode == BBR_STARTUP && bbr_full_bw_reached(sk)) {\n\t\tbbr->mode = BBR_DRAIN;\t/* drain queue we created */\n\t\tbbr->pacing_gain = bbr_drain_gain;\t/* pace slow to drain */\n\t\tbbr->cwnd_gain = bbr_high_gain;\t/* maintain cwnd */\n\t}\t/* fall through to check if in-flight is already small: */\n\tif (bbr->mode == BBR_DRAIN &&\n\t    tcp_packets_in_flight(tcp_sk(sk)) <=\n\t    bbr_target_cwnd(sk, bbr_max_bw(sk), BBR_UNIT))\n\t\tbbr_reset_probe_bw_mode(sk);  /* we estimate queue is drained */\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Estimate the bandwidth based on how fast packets are delivered */\n", "func_signal": "static void bbr_update_bw(struct sock *sk, const struct rate_sample *rs)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu64 bw;\n\n\tbbr->round_start = 0;\n\tif (rs->delivered < 0 || rs->interval_us <= 0)\n\t\treturn; /* Not a valid observation */\n\n\t/* See if we've reached the next RTT */\n\tif (!before(rs->prior_delivered, bbr->next_rtt_delivered)) {\n\t\tbbr->next_rtt_delivered = tp->delivered;\n\t\tbbr->rtt_cnt++;\n\t\tbbr->round_start = 1;\n\t\tbbr->packet_conservation = 0;\n\t}\n\n\tbbr_lt_bw_sampling(sk, rs);\n\n\t/* Divide delivered by the interval to find a (lower bound) bottleneck\n\t * bandwidth sample. Delivered is in packets and interval_us in uS and\n\t * ratio will be <<1 for most connections. So delivered is first scaled.\n\t */\n\tbw = (u64)rs->delivered * BW_UNIT;\n\tdo_div(bw, rs->interval_us);\n\n\t/* If this sample is application-limited, it is likely to have a very\n\t * low delivered count that represents application behavior rather than\n\t * the available network rate. Such a sample could drag down estimated\n\t * bw, causing needless slow-down. Thus, to continue to send at the\n\t * last measured network rate, we filter out app-limited samples unless\n\t * they describe the path bw at least as well as our bw model.\n\t *\n\t * So the goal during app-limited phase is to proceed with the best\n\t * network rate no matter how long. We automatically leave this\n\t * phase when app writes faster than the network can deliver :)\n\t */\n\tif (!rs->is_app_limited || bw >= bbr_max_bw(sk)) {\n\t\t/* Incorporate new sample into our max bw filter. */\n\t\tminmax_running_max(&bbr->bw, bbr_bw_rtts, bbr->rtt_cnt, bw);\n\t}\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Return the windowed max recent bandwidth sample, in pkts/uS << BW_SCALE. */\n", "func_signal": "static u32 bbr_max_bw(const struct sock *sk)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\treturn minmax_get(&bbr->bw);\n}", "path": "Linux-NetSpeed/bbr/centos/tcp_nanqinlang.c", "commit_date": "2018-04-25 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/* Long-term bw sampling interval is done. Estimate whether we're policed. */\n", "func_signal": "static void bbr_lt_bw_interval_done(struct sock *sk, u32 bw)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu32 diff;\n\n\tif (bbr->lt_bw) {  /* do we have bw from a previous interval? */\n\t\t/* Is new bw close to the lt_bw from the previous interval? */\n\t\tdiff = abs(bw - bbr->lt_bw);\n\t\tif ((diff * BBR_UNIT <= bbr_lt_bw_ratio * bbr->lt_bw) ||\n\t\t    (bbr_rate_bytes_per_sec(sk, diff, BBR_UNIT) <=\n\t\t     bbr_lt_bw_diff)) {\n\t\t\t/* All criteria are met; estimate we're policed. */\n\t\t\tbbr->lt_bw = (bw + bbr->lt_bw) >> 1;  /* avg 2 intvls */\n\t\t\tbbr->lt_use_bw = 1;\n\t\t\tbbr->pacing_gain = BBR_UNIT;  /* try to avoid drops */\n\t\t\tbbr->lt_rtt_cnt = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tbbr->lt_bw = bw;\n\tbbr_reset_lt_bw_sampling_interval(sk);\n}", "path": "Linux-NetSpeed/bbr/tcp_tsunami.c", "commit_date": "2017-10-31 00:00:00", "repo_name": "Chikage0o0/Linux-NetSpeed", "stars": 3740, "license": "gpl-2.0", "language": "c", "size": 869624}
{"docstring": "/****************************************************\n * Wrappers for reentrant protocol-independent helpers\n ****************************************************/\n", "func_signal": "int Open_clientfd(char *hostname, char *port)", "code": "{\n    int rc;\n\n    if ((rc = open_clientfd(hostname, port)) < 0) \n\tunix_error(\"Open_clientfd error\");\n    return rc;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/***************************************\n * Wrappers for memory mapping functions\n ***************************************/\n", "func_signal": "void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)", "code": "{\n    void *ptr;\n\n    if ((ptr = mmap(addr, len, prot, flags, fd, offset)) == ((void *) -1))\n\tunix_error(\"mmap error\");\n    return(ptr);\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* $end kill */\n", "func_signal": "void Pause()", "code": "{\n    (void)pause();\n    return;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/*********************************\n * Wrappers for directory function\n *********************************/\n", "func_signal": "DIR *Opendir(const char *name)", "code": "{\n    DIR *dirp = opendir(name); \n\n    if (!dirp)\n        unix_error(\"opendir error\");\n    return dirp;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* \n * rio_readlineb - Robustly read a text line (buffered)\n */\n/* $begin rio_readlineb */\n", "func_signal": "ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)", "code": "{\n    int n, rc;\n    char c, *bufp = usrbuf;\n\n    for (n = 1; n < maxlen; n++) { \n        if ((rc = rio_read(rp, &c, 1)) == 1) {\n\t    *bufp++ = c;\n\t    if (c == '\\n') {\n                n++;\n     \t\tbreak;\n            }\n\t} else if (rc == 0) {\n\t    if (n == 1)\n\t\treturn 0; /* EOF, no data read */\n\t    else\n\t\tbreak;    /* EOF, some data was read */\n\t} else\n\t    return -1;\t  /* Error */\n    }\n    *bufp = 0;\n    return n-1;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* \n * rio_read - This is a wrapper for the Unix read() function that\n *    transfers min(n, rio_cnt) bytes from an internal buffer to a user\n *    buffer, where n is the number of bytes requested by the user and\n *    rio_cnt is the number of unread bytes in the internal buffer. On\n *    entry, rio_read() refills the internal buffer via a call to\n *    read() if the internal buffer is empty.\n */\n/* $begin rio_read */\n", "func_signal": "static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)", "code": "{\n    int cnt;\n\n    while (rp->rio_cnt <= 0) {  /* Refill if buf is empty */\n\trp->rio_cnt = read(rp->rio_fd, rp->rio_buf, \n\t\t\t   sizeof(rp->rio_buf));\n\tif (rp->rio_cnt < 0) {\n\t    if (errno != EINTR) /* Interrupted by sig handler return */\n\t\treturn -1;\n\t}\n\telse if (rp->rio_cnt == 0)  /* EOF */\n\t    return 0;\n\telse \n\t    rp->rio_bufptr = rp->rio_buf; /* Reset buffer ptr */\n    }\n\n    /* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */\n    cnt = n;          \n    if (rp->rio_cnt < n)   \n\tcnt = rp->rio_cnt;\n    memcpy(usrbuf, rp->rio_bufptr, cnt);\n    rp->rio_bufptr += cnt;\n    rp->rio_cnt -= cnt;\n    return cnt;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/*\n * rio_readn - Robustly read n bytes (unbuffered)\n */\n/* $begin rio_readn */\n", "func_signal": "ssize_t rio_readn(int fd, void *usrbuf, size_t n)", "code": "{\n    size_t nleft = n;\n    ssize_t nread;\n    char *bufp = usrbuf;\n\n    while (nleft > 0) {\n\tif ((nread = read(fd, bufp, nleft)) < 0) {\n\t    if (errno == EINTR) /* Interrupted by sig handler return */\n\t\tnread = 0;      /* and call read() again */\n\t    else\n\t\treturn -1;      /* errno set by read() */ \n\t} \n\telse if (nread == 0)\n\t    break;              /* EOF */\n\tnleft -= nread;\n\tbufp += nread;\n    }\n    return (n - nleft);         /* Return >= 0 */\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/******************************************\n * Wrappers for the Standard I/O functions.\n ******************************************/\n", "func_signal": "void Fclose(FILE *fp)", "code": "{\n    if (fclose(fp) != 0)\n\tunix_error(\"Fclose error\");\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/*\n * rio_readnb - Robustly read n bytes (buffered)\n */\n/* $begin rio_readnb */\n", "func_signal": "ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)", "code": "{\n    size_t nleft = n;\n    ssize_t nread;\n    char *bufp = usrbuf;\n    \n    while (nleft > 0) {\n\tif ((nread = rio_read(rp, bufp, nleft)) < 0) \n            return -1;          /* errno set by read() */ \n\telse if (nread == 0)\n\t    break;              /* EOF */\n\tnleft -= nread;\n\tbufp += nread;\n    }\n    return (n - nleft);         /* return >= 0 */\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* $begin sigaction */\n", "func_signal": "handler_t *Signal(int signum, handler_t *handler)", "code": "{\n    struct sigaction action, old_action;\n\n    action.sa_handler = handler;  \n    sigemptyset(&action.sa_mask); /* Block sigs of type being handled */\n    action.sa_flags = SA_RESTART; /* Restart syscalls if possible */\n\n    if (sigaction(signum, &action, &old_action) < 0)\n\tunix_error(\"Signal error\");\n    return (old_action.sa_handler);\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* $end wait */\n", "func_signal": "pid_t Waitpid(pid_t pid, int *iptr, int options)", "code": "{\n    pid_t retpid;\n\n    if ((retpid  = waitpid(pid, iptr, options)) < 0) \n\tunix_error(\"Waitpid error\");\n    return(retpid);\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/***************************************************\n * Wrappers for dynamic storage allocation functions\n ***************************************************/\n", "func_signal": "void *Malloc(size_t size)", "code": "{\n    void *p;\n\n    if ((p  = malloc(size)) == NULL)\n\tunix_error(\"Malloc error\");\n    return p;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/******************************** \n * Client/server helper functions\n ********************************/\n/*\n * open_clientfd - Open connection to server at <hostname, port> and\n *     return a socket descriptor ready for reading and writing. This\n *     function is reentrant and protocol-independent.\n *\n *     On error, returns: \n *       -2 for getaddrinfo error\n *       -1 with errno set for other errors.\n */\n/* $begin open_clientfd */\n", "func_signal": "int open_clientfd(char *hostname, char *port)", "code": "{\n    int clientfd, rc;\n    struct addrinfo hints, *listp, *p;\n\n    /* Get a list of potential server addresses */\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_socktype = SOCK_STREAM;  /* Open a connection */\n    hints.ai_flags = AI_NUMERICSERV;  /* ... using a numeric port arg. */\n    hints.ai_flags |= AI_ADDRCONFIG;  /* Recommended for connections */\n    if ((rc = getaddrinfo(hostname, port, &hints, &listp)) != 0) {\n        fprintf(stderr, \"getaddrinfo failed (%s:%s): %s\\n\", hostname, port, gai_strerror(rc));\n        return -2;\n    }\n  \n    /* Walk the list for one that we can successfully connect to */\n    for (p = listp; p; p = p->ai_next) {\n        /* Create a socket descriptor */\n        if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) \n            continue; /* Socket failed, try the next */\n\n        /* Connect to the server */\n        if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1) \n            break; /* Success */\n        if (close(clientfd) < 0) { /* Connect failed, try another */  //line:netp:openclientfd:closefd\n            fprintf(stderr, \"open_clientfd: close failed: %s\\n\", strerror(errno));\n            return -1;\n        } \n    } \n\n    /* Clean up */\n    freeaddrinfo(listp);\n    if (!p) /* All connects failed */\n        return -1;\n    else    /* The last connect succeeded */\n        return clientfd;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/*  \n * open_listenfd - Open and return a listening socket on port. This\n *     function is reentrant and protocol-independent.\n *\n *     On error, returns: \n *       -2 for getaddrinfo error\n *       -1 with errno set for other errors.\n */\n/* $begin open_listenfd */\n", "func_signal": "int open_listenfd(char *port)", "code": "{\n    struct addrinfo hints, *listp, *p;\n    int listenfd, rc, optval=1;\n\n    /* Get a list of potential server addresses */\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_socktype = SOCK_STREAM;             /* Accept connections */\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */\n    hints.ai_flags |= AI_NUMERICSERV;            /* ... using port number */\n    if ((rc = getaddrinfo(NULL, port, &hints, &listp)) != 0) {\n        fprintf(stderr, \"getaddrinfo failed (port %s): %s\\n\", port, gai_strerror(rc));\n        return -2;\n    }\n\n    /* Walk the list for one that we can bind to */\n    for (p = listp; p; p = p->ai_next) {\n        /* Create a socket descriptor */\n        if ((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) \n            continue;  /* Socket failed, try the next */\n\n        /* Eliminates \"Address already in use\" error from bind */\n        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    //line:netp:csapp:setsockopt\n                   (const void *)&optval , sizeof(int));\n\n        /* Bind the descriptor to the address */\n        if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)\n            break; /* Success */\n        if (close(listenfd) < 0) { /* Bind failed, try the next */\n            fprintf(stderr, \"open_listenfd close failed: %s\\n\", strerror(errno));\n            return -1;\n        }\n    }\n\n\n    /* Clean up */\n    freeaddrinfo(listp);\n    if (!p) /* No address worked */\n        return -1;\n\n    /* Make it a listening socket ready to accept connection requests */\n    if (listen(listenfd, LISTENQ) < 0) {\n        close(listenfd);\n\treturn -1;\n    }\n    return listenfd;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* $begin wait */\n", "func_signal": "pid_t Wait(int *status)", "code": "{\n    pid_t pid;\n\n    if ((pid  = wait(status)) < 0)\n\tunix_error(\"Wait error\");\n    return pid;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* $end forkwrapper */\n", "func_signal": "void Execve(const char *filename, char *const argv[], char *const envp[])", "code": "{\n    if (execve(filename, argv, envp) < 0)\n\tunix_error(\"Execve error\");\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* $begin forkwrapper */\n", "func_signal": "pid_t Fork(void)", "code": "{\n    pid_t pid;\n\n    if ((pid = fork()) < 0)\n\tunix_error(\"Fork error\");\n    return pid;\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* $begin sioprivate */\n/* sio_reverse - Reverse a string (from K&R) */\n", "func_signal": "static void sio_reverse(char s[])", "code": "{\n    int c, i, j;\n\n    for (i = 0, j = strlen(s)-1; i < j; i++, j--) {\n        c = s[i];\n        s[i] = s[j];\n        s[j] = c;\n    }\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/*******************************\n * Protocol-independent wrappers\n *******************************/\n/* $begin getaddrinfo */\n", "func_signal": "void Getaddrinfo(const char *node, const char *service, \n                 const struct addrinfo *hints, struct addrinfo **res)", "code": "{\n    int rc;\n\n    if ((rc = getaddrinfo(node, service, hints, res)) != 0) \n        gai_error(rc, \"Getaddrinfo error\");\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* sio_ltoa - Convert long to base b string (from K&R) */\n", "func_signal": "static void sio_ltoa(long v, char s[], int b)", "code": "{\n    int c, i = 0;\n    \n    do {  \n        s[i++] = ((c = (v % b)) < 10)  ?  c + '0' : c - 10 + 'a';\n    } while ((v /= b) > 0);\n    s[i] = '\\0';\n    sio_reverse(s);\n}", "path": "CSAPP-Labs/labs/proxylab/tiny/csapp.c", "commit_date": "2017-10-21 00:00:00", "repo_name": "Exely/CSAPP-Labs", "stars": 2270, "license": "None", "language": "c", "size": 4270}
{"docstring": "/* Have to reinvent the wheel, unfortunately, since pre_inject does not link\n * utils.c.  Only need this to be able to get the app name for the\n * display_verbose_message title, but that's nice to have.\n */\n", "func_signal": "static void\nnotcore_mutex_lock(int *thelock)", "code": "{\n    while (_InterlockedExchange((LONG *)thelock, 1) != 0) {\n        _mm_pause();\n    }\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* Returns the cached full path of the image with no qualifiers */\n", "func_signal": "const wchar_t *\nget_own_unqualified_name()", "code": "{\n    static wchar_t full_unqualified_name[MAXIMUM_PATH];\n\n    if (full_unqualified_name[0] == L'\\0') {\n        get_process_qualified_name(NULL, full_unqualified_name,\n                                   BUFFER_SIZE_ELEMENTS(full_unqualified_name),\n                                   UNQUALIFIED_FULL_NAME, REGISTRY_DEFAULT);\n        ASSERT(full_unqualified_name[0] != L'\\0');\n    }\n    return full_unqualified_name;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* Returns the cached full path of the image, including the command line qualifier when\n * necessary */\n", "func_signal": "const wchar_t *\nget_own_qualified_name()", "code": "{\n    static wchar_t full_qualified_name[MAXIMUM_PATH];\n\n    if (full_qualified_name[0] == L'\\0') {\n        get_process_qualified_name(NULL, full_qualified_name,\n                                   BUFFER_SIZE_ELEMENTS(full_qualified_name),\n                                   QUALIFIED_FULL_NAME, REGISTRY_DEFAULT);\n        ASSERT(full_qualified_name[0] != L'\\0');\n    }\n    return full_qualified_name;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* Description: If RUNUNDER_ONCE flag exists in the given mask, the RUNUNDER_ON\n *              flag for the registry value DYNAMORIO_RUNUNDER is cleared for\n *              the given process, so that the application won't start under\n *              DR during the next invocation.\n * Input:       process - handle of the process whose registry value should be\n *                        modified.\n *              rununder_mask - contains the process' DYNAMORIO_RUNUNDER mask.\n * Output:      None.\n * Return value:None.\n * Notes:       See case 3702.\n */\n", "func_signal": "void\ncheck_for_run_once(HANDLE process, int rununder_mask)", "code": "{\n#    ifdef PARAMS_IN_REGISTRY\n    int size;\n    char mask_string[MAX_RUNVALUE_LENGTH];\n\n    if (TEST(rununder_mask, RUNUNDER_ONCE)) {\n        rununder_mask &= ~RUNUNDER_ON;\n        size =\n            snprintf(mask_string, BUFFER_SIZE_ELEMENTS(mask_string), \"%d\", rununder_mask);\n        NULL_TERMINATE_BUFFER(mask_string);\n        ASSERT(size >= 0 && size < BUFFER_SIZE_ELEMENTS(mask_string) - 1);\n\n        /* All registry keys set up by our product are writable only by\n         * SYSTEM and Admin users.  If another user runs an executable with\n         * RUNUNDER_ONCE, the core won't turn of RUNUNDER_ON because registry\n         * write will fail.  This is an EV limitation: RUNUNDER_ONCE won't work\n         * for non privileged processes.  Will be fixed in 2.5.  See case 4249.\n         */\n        if (set_process_parameter(process, L_DYNAMORIO_VAR_RUNUNDER, mask_string) !=\n            SET_PARAMETER_SUCCESS) {\n            /* FIXME: Till 2.5 ASSERT_NOT_REACHED/display_error should actually\n             * be ASSERT_CURIOSITY.  Defining ASSERT_CURIOSITY for core,\n             * drinject.exe and drpreinject.dll is an ugly redefinition hack;\n             * better not do it just for case 4249.\n             */\n            display_error(\"Can't enforce RUNUNDER_ONCE.\");\n            ASSERT_NOT_REACHED();\n        }\n    }\n#    else\n    /* no support for RUNUNDER_ONCE for config files: use .1config32 instead */\n#    endif\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/*\n * this assumes it will be called on process initialization, when\n *  the PEB apparently uses offsets in the ProcessParameters block\n *  instead of direct pointers.\n * image name and cmdline combined into one call to reduce\n *  read process memory calls (whether this is actually true depends on\n *  usage)\n */\n", "func_signal": "void\nget_process_imgname_cmdline(HANDLE process_handle, wchar_t *image_name,\n                            int max_image_wchars, wchar_t *command_line,\n                            int max_cmdl_wchars)", "code": "{\n    size_t nbytes;\n    int res;\n    int len;\n    PEB peb;\n    LPVOID peb_base = get_peb(process_handle);\n    RTL_USER_PROCESS_PARAMETERS process_parameters;\n    void *param_location;\n    /* It is supposed to be at process_parameters.ImagePathName.Buffer */\n\n    /* Read process PEB */\n    res = nt_read_virtual_memory(process_handle, (LPVOID)peb_base, &peb, sizeof(peb),\n                                 &nbytes);\n    /* FIXME: is this always possible?\n       although we assume we can even do WriteProcessMemory for an explicit inject */\n    if (!res) {\n        display_error(\"Warning: could not read process memory!\");\n        if (image_name)\n            image_name[0] = L'\\0';\n        if (command_line)\n            command_line[0] = L'\\0';\n        return;\n    }\n\n    /* Follow on to process parameters */\n    res =\n        nt_read_virtual_memory(process_handle, (LPVOID)peb.ProcessParameters,\n                               &process_parameters, sizeof(process_parameters), &nbytes);\n\n    /* apparently {ImagePathName,CommandLine}.Buffer contains the offset\n     * from the beginning of the ProcessParameters structure during\n     * process init on os versions prior to Vista */\n\n    if (image_name) {\n        if (is_windows_version_vista_plus()) {\n            param_location = process_parameters.ImagePathName.Buffer;\n        } else {\n            param_location =\n                (void *)((ptr_uint_t)process_parameters.ImagePathName.Buffer +\n                         (ptr_uint_t)peb.ProcessParameters);\n        }\n\n        len = process_parameters.ImagePathName.Length;\n        if (len > 2 * (max_image_wchars - 1))\n            len = 2 * (max_image_wchars - 1);\n\n        /* Read the image file name in our memory too */\n        res = nt_read_virtual_memory(process_handle, (LPVOID)param_location, image_name,\n                                     len, &nbytes);\n        if (!res) {\n            len = 0;\n            display_warning(\"Warning: could not read image name from PEB\");\n        }\n        image_name[len / 2] = 0;\n    }\n\n    if (command_line) {\n        if (is_windows_version_vista_plus()) {\n            param_location = process_parameters.CommandLine.Buffer;\n        } else {\n            param_location = (void *)((ptr_uint_t)process_parameters.CommandLine.Buffer +\n                                      (ptr_uint_t)peb.ProcessParameters);\n        }\n\n        len = process_parameters.CommandLine.Length;\n        if (len > 2 * (max_cmdl_wchars - 1))\n            len = 2 * (max_cmdl_wchars - 1);\n\n        /* Read the image file name in our memory too */\n        res = nt_read_virtual_memory(process_handle, (LPVOID)param_location, command_line,\n                                     len, &nbytes);\n        if (!res) {\n            len = 0;\n            display_warning(\"Warning: could not read cmdline from PEB\");\n        }\n        command_line[len / 2] = 0;\n    }\n\n    return;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* Returns the cached short image name, including the command line qualifier when\n * necessary */\n", "func_signal": "const wchar_t *\nget_own_short_qualified_name()", "code": "{\n    static wchar_t short_qualified_name[MAXIMUM_PATH];\n\n    if (!short_qualified_name[0]) {\n        get_process_qualified_name(NULL, short_qualified_name,\n                                   BUFFER_SIZE_ELEMENTS(short_qualified_name),\n                                   QUALIFIED_SHORT_NAME, REGISTRY_DEFAULT);\n        ASSERT(short_qualified_name[0]);\n    }\n    return short_qualified_name;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* Description: Sets the value data for a value name that belongs to a given\n *              registry key.\n * Input:       keyname - fully qualified name of the registry key to\n *                        which valuename belongs to.\n *              valuename - name of the value for which the data is to be set.\n *              value - data that is to be set for valuename.\n * Output:      None.\n * Return value:SET_PARAMETER_SUCCESS if valuename is changed/created.\n *              SET_PARAMETER_FAILURE if keyname is invalid or if valuename\n *              can't be changed or created.\n * Notes:       If valuename doesn't exist, it will be created with value as\n *              data.  Implemented as part of case 3702.\n */\n", "func_signal": "static int\nset_registry_parameter(const wchar_t *keyname, const wchar_t *valuename,\n                       const char *value)", "code": "{\n    HANDLE hkey;\n    int size, res;\n\n    wchar_t wvalue[MAX_REGISTRY_PARAMETER];\n\n    size = _snwprintf(wvalue, BUFFER_SIZE_ELEMENTS(wvalue), L\"%S\", value);\n    NULL_TERMINATE_BUFFER(wvalue);\n    ASSERT(size >= 0 && size < BUFFER_SIZE_ELEMENTS(wvalue));\n\n    hkey = reg_open_key(keyname, KEY_SET_VALUE);\n    if (NULL != hkey) {\n        res = reg_set_key_value(hkey, valuename, wvalue);\n        if (res) {\n            /* Need to flush registry writes to disk, otherwise a\n             * power cycle will throw out the changes.  See case 4138.\n             */\n            reg_flush_key(hkey);\n            reg_close_key(hkey);\n            return SET_PARAMETER_SUCCESS;\n        }\n        reg_close_key(hkey);\n    }\n    return SET_PARAMETER_FAILURE;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* get parameter for current processes root app key (not qualified app key)\n * for ex. would get parameter from svchost.exe instead of svchost.exe-netsvc */\n", "func_signal": "int\nget_unqualified_parameter(const wchar_t *name, char *value, int maxlen)", "code": "{\n    return get_process_parameter_internal(NULL, name, value, maxlen, false /*!qual*/,\n                                          REGISTRY_DEFAULT);\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* look up RUNUNDER param.\n * if it's defined in app-specific key, check against RUNUNDER_ON\n *    if RUNUNDER_ON is set check against RUNUNDER_EXPLICIT\n *        if set return INJECT_TRUE|INJECT_EXPLICIT else return INJECT_TRUE\n *    if RUNUNDER_ON is not set return INJECT_EXCLUDED\n *\n * if no app-specific key, check global key against RUNUNDER_ALL\n *    if set return INJECT_TRUE else return INJECT_FALSE\n *\n * if no app-specific key and no global key return INJECT_FALSE\n *\n * if mask isn't NULL, the DYNAMORIO_RUNUNDER mask is returned in it.\n *\n * NOTE - if return INJECT_TRUE and !INJECT_EXPLICIT then preinjector should inject if\n *   systemwide_inject_enabled()\n */\n", "func_signal": "static inject_setting_mask_t\nsystemwide_should_inject_common(HANDLE process, int *mask, reg_platform_t whichreg,\n                                bool consider_1config)", "code": "{\n    char runvalue[MAX_RUNVALUE_LENGTH];\n#    ifdef PARAMS_IN_REGISTRY\n    int retval;\n#    endif\n    int rununder_mask, err;\n\n#    if VERBOSE\n    display_verbose_message(\"systemwide_should_inject\");\n#    endif\n\n#    ifdef PARAMS_IN_REGISTRY\n    /* get_process_parameter properly terminates short buffer */\n    err = get_process_parameter_internal(process, L_DYNAMORIO_VAR_RUNUNDER, runvalue,\n                                         sizeof(runvalue), true /*qual*/, whichreg);\n    if (IS_GET_PARAMETER_FAILURE(err))\n        return INJECT_FALSE;\n#    else\n    /* Instead of a new GET_PARAMETER_PID_SPECIFIC success value which would require\n     * changing several get_process_parameter callers who check specific return values,\n     * we add a new _ex() routine that allows excluding 1config files.\n     * For syswide we do NOT want to inject if there is a 1config file, to avoid\n     * double injection.\n     */\n    err = get_process_parameter_ex(process, DYNAMORIO_VAR_RUNUNDER, runvalue,\n                                   sizeof(runvalue), consider_1config);\n    if (IS_GET_PARAMETER_FAILURE(err))\n        return INJECT_FALSE;\n#    endif\n\n    rununder_mask = get_rununder_value(runvalue);\n    if (NULL != mask) {\n        if (IS_GET_PARAMETER_SUCCESS(err))\n            *mask = rununder_mask;\n        else\n            *mask = 0;\n    }\n\n    /* if there is no app-specific subkey, then we should compare\n       against runall */\n    if (err == GET_PARAMETER_NOAPPSPECIFIC) {\n        if (rununder_mask & RUNUNDER_ALL)\n            return INJECT_TRUE;\n        else\n            return INJECT_FALSE;\n    } else { /* err == GET_PARAMETER_SUCCESS */\n        if (!(rununder_mask & RUNUNDER_ON))\n            return INJECT_EXCLUDED;\n        else {\n            /* now there is the possibility of needing to use an alternate\n             *  injection technique. */\n\n            int inject_mask = INJECT_FALSE;\n\n            if (rununder_mask & RUNUNDER_EXPLICIT)\n                inject_mask |= INJECT_EXPLICIT;\n\n#    ifdef PARAMS_IN_REGISTRY /* config files don't support cmdline match */\n            if (rununder_mask & RUNUNDER_COMMANDLINE_MATCH) {\n\n                /* if the commandline matches, return INJECT_TRUE\n                 * if the commandline doesn't match and runall is on,\n                 *  return INJECT_TRUE\n                 * else return INJECT_FALSE */\n\n                if (check_commandline_match(process)) {\n                    inject_mask |= INJECT_TRUE;\n                } else {\n                    /* no match; check global runall */\n                    retval = get_registry_parameter(DYNAMORIO_REGISTRY_BASE,\n                                                    L_DYNAMORIO_VAR_RUNUNDER, runvalue,\n                                                    sizeof(runvalue), whichreg);\n                    if (IS_GET_PARAMETER_SUCCESS(retval)) {\n                        if (RUNUNDER_ALL == get_rununder_value(runvalue))\n                            inject_mask |= INJECT_TRUE;\n                    }\n                }\n\n                return inject_mask;\n\n            } else /* just normal injection */\n#    endif\n                return (inject_mask | INJECT_TRUE);\n        }\n    }\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* Description: Modifies the value name corresponding to a DR parameter.  This\n *              value name should belong to the registry key associated with the\n *              executable for the given process under DYNAMORIO_REGISTRY_BASE.\n * Input:       phandle - handle for the process whose registry value is to be\n *                        changed.\n *              name - value name for the corresponding DR parameter.\n *              value - value to which the registry parameter should be set to.\n * Output:      None.\n * Return value:SET_PARAMETER_SUCCESS if name is changed.\n *              SET_PARAMETER_FAILURE if not.\n * Notes:       If called with an incorrect parameter name, a value with that\n *              parameter name will be created in the registry for the current\n *              executable name under DYNAMORIO_REGISTRY_BASE.  Implemented as\n *              part of case 3702.\n */\n", "func_signal": "int\nset_process_parameter(HANDLE phandle, const wchar_t *name, const char *value)", "code": "{\n    wchar_t app_specific_base[MAXIMUM_PATH] = DYNAMORIO_REGISTRY_BASE L\"\\\\\";\n\n    /* Even though DYNAMORIO_REGISTRY_BASE is a constant, we need to null\n     * terminate because windows compiler doesn't complain or null terminate\n     * the array if the constant is longer than the array size!\n     */\n    NULL_TERMINATE_BUFFER(app_specific_base);\n\n    /* DYNAMORIO_REGISTRY_BASE is not user controlled, ASSERT only */\n    ASSERT(wcslen(app_specific_base) < BUFFER_SIZE_ELEMENTS(app_specific_base) - 1);\n\n    if (phandle == NULL) {\n        wcsncat(app_specific_base, get_own_short_qualified_name(),\n                BUFFER_ROOM_LEFT_W(app_specific_base));\n    } else {\n        /* instead of using another buffer for the temporary,\n           we just append to the current one */\n        get_process_qualified_name(phandle, app_specific_base + wcslen(app_specific_base),\n                                   BUFFER_ROOM_LEFT_W(app_specific_base),\n                                   QUALIFIED_SHORT_NAME,\n                                   false /*no cross-arch set needed yet*/);\n    }\n    NULL_TERMINATE_BUFFER(app_specific_base);\n    ASSERT(wcslen(app_specific_base) < BUFFER_SIZE_ELEMENTS(app_specific_base) - 1);\n\n    return set_registry_parameter(app_specific_base, name, value);\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* see comments at is_windows_version_nt() */\n", "func_signal": "static bool\nis_windows_version_vista_plus()", "code": "{\n    PEB *peb = get_own_peb();\n    /* we won't work on any other anyways */\n    ASSERT(peb->OSPlatformId == VER_PLATFORM_WIN32_NT);\n    return (peb->OSMajorVersion >= 6);\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* Returns the cached short image name with no qualifiers */\n", "func_signal": "const wchar_t *\nget_own_short_unqualified_name()", "code": "{\n    static wchar_t short_unqualified_name[MAXIMUM_PATH];\n\n    if (!short_unqualified_name[0]) {\n        get_process_qualified_name(NULL, short_unqualified_name,\n                                   BUFFER_SIZE_ELEMENTS(short_unqualified_name),\n                                   UNQUALIFIED_SHORT_NAME, REGISTRY_DEFAULT);\n        ASSERT(short_unqualified_name[0]);\n    }\n    return short_unqualified_name;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* get parameter for a different process */\n", "func_signal": "static int\nget_process_parameter_ex(HANDLE phandle, const char *name, char *value, int maxlen,\n                         bool consider_1config)", "code": "{\n    wchar_t short_unqual_name[MAXIMUM_PATH];\n    char appname[MAXIMUM_PATH];\n    bool app_specific, from_1config;\n    process_id_t pid;\n    if (phandle == NULL) {\n#            if !defined(NOT_DYNAMORIO_CORE) && !defined(NOT_DYNAMORIO_CORE_PROPER)\n        return d_r_get_parameter(name, value, maxlen);\n#            else\n        pid = process_id_from_handle(NT_CURRENT_PROCESS);\n#            endif\n    } else\n        pid = process_id_from_handle(phandle);\n    get_process_qualified_name(phandle, short_unqual_name,\n                               BUFFER_SIZE_ELEMENTS(short_unqual_name),\n                               UNQUALIFIED_SHORT_NAME, REGISTRY_DEFAULT);\n    NULL_TERMINATE_BUFFER(short_unqual_name);\n    snprintf(appname, BUFFER_SIZE_ELEMENTS(appname), \"%ls\", short_unqual_name);\n    NULL_TERMINATE_BUFFER(appname);\n    if (!get_config_val_other_app(appname, pid, DR_PLATFORM_DEFAULT, name, value, maxlen,\n                                  &app_specific, NULL, &from_1config) ||\n        (!consider_1config && from_1config))\n        return GET_PARAMETER_FAILURE;\n    if (!app_specific)\n        return GET_PARAMETER_NOAPPSPECIFIC;\n    return GET_PARAMETER_SUCCESS;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* We've replaced the registry w/ config files (i#265/PR 486139, i#85/PR 212034)\n * but when PARAMS_IN_REGISTRY is defined we support the old registry scheme\n */\n", "func_signal": "static int\nget_subkey_parameter(HANDLE process_handle, const wchar_t *uname, char *value, int maxlen,\n                     bool use_qualified, reg_platform_t whichreg)", "code": "{\n    int retval;\n    wchar_t app_specific_base[MAXIMUM_PATH] = DYNAMORIO_REGISTRY_BASE L\"\\\\\";\n    /* DYNAMORIO_REGISTRY_BASE is not user controlled, ASSERT only */\n    ASSERT(wcslen(app_specific_base) < BUFFER_SIZE_ELEMENTS(app_specific_base));\n\n    if (process_handle == NULL) {\n        wcsncat(app_specific_base,\n                use_qualified ? get_own_short_qualified_name()\n                              : get_own_short_unqualified_name(),\n                BUFFER_ROOM_LEFT_W(app_specific_base));\n    } else {\n        /* instead of using another buffer for the temporary,\n           we just append to the current one */\n        get_process_qualified_name(\n            process_handle, app_specific_base + wcslen(app_specific_base),\n            BUFFER_ROOM_LEFT_W(app_specific_base),\n            use_qualified ? QUALIFIED_SHORT_NAME : UNQUALIFIED_SHORT_NAME, whichreg);\n    }\n    NULL_TERMINATE_BUFFER(app_specific_base);\n\n    retval = get_registry_parameter(app_specific_base, uname, value, maxlen, whichreg);\n#        if VERBOSE\n    display_verbose_message(\"gskp: %ls -- %ls\\n\\\"%hs\\\"\", app_specific_base, uname,\n                            IS_GET_PARAMETER_SUCCESS(retval) ? value : \"\");\n#        endif\n\n    if (IS_GET_PARAMETER_FAILURE(retval)) {\n        HANDLE hkey = reg_open_key(app_specific_base, KEY_READ);\n        if (hkey == NULL) {\n            retval = GET_PARAMETER_NOAPPSPECIFIC;\n        }\n        reg_close_key(hkey);\n    }\n    return retval;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* returns pointer to last char of string that matches either c1 or c2\n * or NULL if can't find */\n", "func_signal": "const char *\ndouble_strrchr(const char *string, char c1, char c2)", "code": "{\n    const char *ret = NULL;\n    while (*string != '\\0') {\n        if (*string == c1 || *string == c2) {\n            ret = string;\n        }\n        string++;\n    }\n    return ret;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* get parameter for a different process */\n", "func_signal": "int\nget_process_parameter(HANDLE phandle, const wchar_t *name, char *value, int maxlen)", "code": "{\n    return get_process_parameter_internal(phandle, name, value, maxlen, true /*qual*/,\n                                          REGISTRY_DEFAULT);\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/*\n  We test the rununder_mask of a process and if it specifies that a\n  fully qualified name is needed we lookup at the fully qualified\n  location first.\n\n  See comments in get_commandline_qualifier() and case 1324 for a list\n  of executables which we further distinguish based on commandline.\n\n  If we hardcode only a few more entries we could then avoid this\n  buffer and registry access altogether, yet for generality sake\n  we'll do this.\n\n  FIXME[inefficiency]: The systemwide_should_inject() thus ends up\n     checking twice for RUNUNDERDR, but the OS is good at caching this.\n*/\n", "func_signal": "static uint\ncommandline_qualifier_needed(const wchar_t *process_short_name, reg_platform_t whichreg)", "code": "{\n    char runvalue[MAX_RUNVALUE_LENGTH];\n    uint ret_val = 0;\n    int res;\n\n    wchar_t app_specific_base[MAXIMUM_PATH] = DYNAMORIO_REGISTRY_BASE L\"\\\\\";\n    /* FIXME: this extra buffer has exactly the same contents as that\n       passed by get_subkey_parameter(,,QUALIFIED_SHORT_NAME) and in\n       fact have the same contents as we'll now prepare in a different buffer.\n       Other callers of get_process_qualified_name() do not have an\n       extra buffer information prepared. For now we'll allocate another buffer.\n     */\n\n    /* We now need to use direct registry access to get RUNUNDER flags */\n    wcsncat(app_specific_base, process_short_name, BUFFER_ROOM_LEFT_W(app_specific_base));\n    NULL_TERMINATE_BUFFER(app_specific_base);\n    res = get_registry_parameter(app_specific_base, L_DYNAMORIO_VAR_RUNUNDER, runvalue,\n                                 sizeof(runvalue), whichreg);\n    if (IS_GET_PARAMETER_SUCCESS(res)) {\n        ret_val = get_rununder_value(runvalue) &\n            (RUNUNDER_COMMANDLINE_DISPATCH | RUNUNDER_COMMANDLINE_NO_STRIP);\n    }\n\n    return ret_val;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* value is a buffer allocated by the caller to hold the\n * resulting value. If not successful leaves original buffer contents intact.\n *\n * The same parameter is looked up first in the application specific registry\n * subtree and then in the global registry tree.  We no longer look for\n * environment variables.\n */\n", "func_signal": "static int\nget_process_parameter_internal(HANDLE phandle, const wchar_t *name, char *value,\n                               int maxlen, bool use_qualified, reg_platform_t whichreg)", "code": "{\n    int err, err2;\n\n#        if VERBOSE\n    display_verbose_message(\"get_parameter:%ls\", name);\n#        endif VERBOSE\n\n    /* first check app specific options */\n    err = get_subkey_parameter(phandle, name, value, maxlen, use_qualified, whichreg);\n\n    if (err != GET_PARAMETER_SUCCESS) {\n        err2 = get_registry_parameter(DYNAMORIO_REGISTRY_BASE, name, value, maxlen,\n                                      whichreg);\n        if (IS_GET_PARAMETER_SUCCESS(err2)) {\n            /* if there's no app-specific but there is a global, return\n             * GET_PARAMETER_NOAPPSPECIFIC; otherwise, if there's a\n             * global, return success. */\n            if (err != GET_PARAMETER_NOAPPSPECIFIC)\n                err = GET_PARAMETER_SUCCESS;\n        } else if (err == GET_PARAMETER_BUF_TOO_SMALL ||\n                   err2 == GET_PARAMETER_BUF_TOO_SMALL) {\n            /* On error, buffer too small takes precedence. */\n            err = GET_PARAMETER_BUF_TOO_SMALL;\n        } else\n            err = GET_PARAMETER_FAILURE;\n    }\n    return err;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* shared utilities */\n/* unicode version of double_strrchr */\n", "func_signal": "const wchar_t *\ndouble_wcsrchr(const wchar_t *string, wchar_t c1, wchar_t c2)", "code": "{\n    const wchar_t *ret = NULL;\n    while (*string != L'\\0') {\n        if (*string == c1 || *string == c2) {\n            ret = string;\n        }\n        string++;\n    }\n    return ret;\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* get parameter for current process */\n", "func_signal": "int\nd_r_get_parameter(const wchar_t *name, char *value, int maxlen)", "code": "{\n    return get_process_parameter_internal(NULL, name, value, maxlen, true /*qual*/,\n                                          REGISTRY_DEFAULT);\n}", "path": "dynamorio/core/win32/inject_shared.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "DynamoRIO/dynamorio", "stars": 2486, "license": "other", "language": "c", "size": 113231}
{"docstring": "/* NR.OBSERVE key input1 [input2 input3 ... inputN] -> output [TRAIN|TEST] */\n", "func_signal": "int NRObserve_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    NRCollectThreads(ctx);\n\n    if (argc < 3) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    if (RedisModule_ModuleTypeGetType(key) != NRType)\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n\n    NRTypeObject *nr = RedisModule_ModuleTypeGetValue(key);\n    int ilen = INPUT_UNITS(nr->nn);\n    int olen = OUTPUT_UNITS(nr->nn);\n    int oargs = (nr->flags & NR_FLAG_CLASSIFIER) ? 1 : olen;\n    int target = NR_INSERT_NO_TARGET;\n\n    /* The last argument may specify the training target:\n     * testing or training dataset. */\n    if (!strcasecmp(RedisModule_StringPtrLen(argv[argc-1],NULL),\"train\")) {\n        target = NR_INSERT_TRAIN;\n        argc--;\n    } else if (!strcasecmp(RedisModule_StringPtrLen(argv[argc-1],NULL),\"test\")){\n        target = NR_INSERT_TEST;\n        argc--;\n    }\n\n    if (argc != oargs+ilen+3)\n        return RedisModule_ReplyWithError(ctx,\n            \"ERR number of arguments does not \"\n            \"match the number of inputs and outputs in the neural network\");\n\n    const char *sep = RedisModule_StringPtrLen(argv[ilen+2], NULL);\n    if (strcmp(sep,\"->\")) {\n        return RedisModule_ReplyWithError(ctx,\n            \"ERR no '->' separtor in the correct position between inputs and \"\n            \"outputs: are you sure your training data is correct?\");\n    }\n\n    float *inputs = RedisModule_Alloc(sizeof(float)*ilen);\n    float *outputs = RedisModule_Alloc(sizeof(float)*olen);\n\n    for(int j = 2; j < argc; j++) {\n        double val;\n        if (j == ilen+2) continue; /* -> separator. */\n        if (RedisModule_StringToDouble(argv[j],&val) != REDISMODULE_OK) {\n            RedisModule_Free(inputs);\n            RedisModule_Free(outputs);\n            return RedisModule_ReplyWithError(ctx,\n                \"ERR invalid neural network input: must be a valid float \"\n                \"precision floating point number\");\n        }\n        if (j < ilen+2) {\n            inputs[j-2] = val;\n        } else {\n            if (nr->flags & NR_FLAG_CLASSIFIER) {\n                int classid = val;\n                if (classid != val || val >= olen || val < 0) {\n                    RedisModule_Free(inputs);\n                    RedisModule_Free(outputs);\n                    return RedisModule_ReplyWithError(ctx,\n                        \"ERR classifier network output must be an integer \"\n                        \"in the range from 0 to outputs-1.\");\n                }\n                memset(outputs,0,sizeof(float)*olen);\n                outputs[classid] = 1;\n            } else {\n                outputs[j-ilen-3] = val;\n            }\n        }\n    }\n\n    NRTypeInsertData(nr,inputs,outputs,target);\n    RedisModule_Free(inputs);\n    RedisModule_Free(outputs);\n\n    RedisModule_ReplyWithArray(ctx,2);\n    RedisModule_ReplyWithLongLong(ctx, nr->dataset.len);\n    RedisModule_ReplyWithLongLong(ctx, nr->test.len);\n    return REDISMODULE_OK;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Create a network with the specified parameters. Note that the layers\n * must be specified from the output layer[0] to the input\n * layer[N]. Each element in the integer array 'layer' specify how many\n * units there are in the corresponding layer. */\n", "func_signal": "NRTypeObject *createNRTypeObject(int flags, int *layers, int numlayers, int dset_len, int test_len)", "code": "{\n    NRTypeObject *o;\n    o = RedisModule_Calloc(1,sizeof(*o));\n    o->id = NRNextId++;\n    o->flags = flags;\n    o->nn = AnnCreateNet(numlayers,layers);\n    o->dataset.maxlen = dset_len;\n    o->test.maxlen = test_len;\n    int ilen = INPUT_UNITS(o->nn);\n    int olen = OUTPUT_UNITS(o->nn);\n    o->inorm = RedisModule_Calloc(1,sizeof(float)*ilen);\n    o->onorm = RedisModule_Calloc(1,sizeof(float)*olen);\n    for (int j = 0; j < ilen; j++) o->inorm[j] = 1;\n    for (int j = 0; j < olen; j++) o->onorm[j] = 1;\n    return o;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* NR.RESET key -- Set random weights in the NN and clear training stats. */\n", "func_signal": "int NRReset_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    NRCollectThreads(ctx);\n\n    if (argc != 2) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    if (RedisModule_ModuleTypeGetType(key) != NRType)\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n\n    NRTypeObject *nr = RedisModule_ModuleTypeGetValue(key);\n\n    /* Change the ID so that if there is a training in progress it will\n     * not update the weights of this network. */\n    nr->id = NRNextId++;\n\n    /* Reset training stats. */\n    nr->training_total_steps = 0;\n    nr->training_total_ms = 0;\n    nr->training_max_cycles = 0;\n    nr->training_max_ms = 0;\n    nr->dataset_error = 0;\n    nr->test_error = 0;\n    nr->test_class_error = 0;\n\n    /* Set random weights in the neural network, which is\n     * \"untrain\" the network. */\n    AnnSetRandomWeights(nr->nn);\n\n    return RedisModule_ReplyWithSimpleString(ctx,\"OK\");\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* This function must be present on each Redis module. It is used in order to\n * register the commands into the Redis server. */\n", "func_signal": "int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    UNUSED(argv);\n    UNUSED(argc);\n\n    if (RedisModule_Init(ctx,\"neuralredis\",1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    RedisModuleTypeMethods tm = {\n        .version = REDISMODULE_TYPE_METHOD_VERSION,\n        .rdb_load = NRTypeRdbLoad,\n        .rdb_save = NRTypeRdbSave,\n        .aof_rewrite = NRTypeAofRewrite,\n        .free = NRTypeFree\n    };\n\n    NRType = RedisModule_CreateDataType(ctx,\"neural-NN\",NR_RDB_ENC_VER,&tm);\n    if (NRType == NULL) return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.create\",\n        NRCreate_RedisCommand,\"write deny-oom\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.run\",\n        NRRun_RedisCommand,\"readonly\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.class\",\n        NRClass_RedisCommand,\"readonly\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.observe\",\n        NRObserve_RedisCommand,\"write deny-oom\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.info\",\n        NRInfo_RedisCommand,\"readonly\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.train\",\n        NRTrain_RedisCommand,\"write\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.reset\",\n        NRReset_RedisCommand,\"write\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.threads\",\n        NRThreads_RedisCommand,\"\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"nr.getdata\",\n        NRGetdata_RedisCommand,\"readonly\",1,1,1) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    return REDISMODULE_OK;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* NR.THREADS */\n", "func_signal": "int NRThreads_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    NRCollectThreads(ctx);\n    UNUSED(argv);\n\n    if (argc != 1) return RedisModule_WrongArity(ctx);\n\n    pthread_mutex_lock(&NRPendingTrainingMutex);\n    RedisModule_ReplyWithArray(ctx,NRPendingTrainingCount);\n    for (int j = 0; j < NRPendingTrainingCount; j++) {\n        char buf[1024];\n        NRPendingTraining *pt = &NRTrainings[j];\n        const char *keyname = RedisModule_StringPtrLen(pt->key,NULL);\n        snprintf(buf,sizeof(buf),\"nn_id=%llu cycle=%d key=%s db=%d maxtime=%llu maxcycles=%llu trainerr=%f testerr=%f classerr=%f\",\n            (unsigned long long)pt->nr->id,\n            pt->curcycle,\n            keyname, pt->db_id,\n            (unsigned long long)pt->nr->training_max_ms,\n            (unsigned long long)pt->nr->training_max_cycles,\n            pt->dataset_error,\n            pt->test_error,\n            pt->class_error);\n        RedisModule_ReplyWithSimpleString(ctx,buf);\n    }\n    pthread_mutex_unlock(&NRPendingTrainingMutex);\n    return REDISMODULE_OK;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Free the specified dataset. */\n", "func_signal": "void NRDatasetFree(NRDataset *dset)", "code": "{\n    RedisModule_Free(dset->inputs);\n    RedisModule_Free(dset->outputs);\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* NR.TRAIN key [MAXCYCLES <count>] [MAXTIME <count>] [AUTOSTOP] */\n", "func_signal": "int NRTrain_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    NRCollectThreads(ctx);\n\n    if (argc < 2) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    if (RedisModule_ModuleTypeGetType(key) != NRType)\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n\n    NRTypeObject *nr = RedisModule_ModuleTypeGetValue(key);\n    if (nr->flags & NR_FLAG_TRAINING)\n        return RedisModule_ReplyWithError(ctx,\n            \"ERR neural network training already in progress\");\n\n    nr->training_max_cycles = 0;\n    nr->training_max_ms = 10000;\n    nr->flags &= ~(NR_FLAG_AUTO_STOP|NR_FLAG_BACKTRACK);\n\n    for (int j = 2; j < argc; j++) {\n        const char *o = RedisModule_StringPtrLen(argv[j], NULL);\n        long long v;\n        int lastarg = (j == argc-1);\n\n        if (!strcasecmp(o,\"autostop\")) {\n            nr->flags |= NR_FLAG_AUTO_STOP;\n        } else if (!strcasecmp(o,\"backtrack\")) {\n            nr->flags |= NR_FLAG_BACKTRACK;\n        } else if (!strcasecmp(o,\"maxcycles\") && !lastarg) {\n            if (RedisModule_StringToLongLong(argv[++j],&v) != REDISMODULE_OK) {\n                return RedisModule_ReplyWithError(ctx,\n                    \"ERR invalid number of cycles\");\n            }\n            nr->training_max_cycles = v;\n        } else if (!strcasecmp(o,\"maxtime\") && !lastarg) {\n            if (RedisModule_StringToLongLong(argv[++j],&v) != REDISMODULE_OK) {\n                return RedisModule_ReplyWithError(ctx,\n                    \"ERR invalid number of milliseconds of time\");\n            }\n            nr->training_max_ms = v;\n        } else {\n            return RedisModule_ReplyWithError(ctx,\n                \"ERR Syntax error in NR.TRAIN\");\n        }\n    }\n\n    /* Overfitting detection compares error rate in testing/training data,\n     * so does not work without entries in the testing dataset. */\n    if (nr->flags & NR_FLAG_AUTO_STOP && nr->test.len == 0) {\n        return RedisModule_ReplyWithError(ctx,\n            \"ERR Can't start training with AUTOSTOP option: \"\n            \"overfitting detection requires a non zero length testing dataset\");\n    }\n\n    if (NRStartTraining(ctx,argv[1],RedisModule_GetSelectedDb(ctx),nr) ==\n        REDISMODULE_ERR)\n    {\n        return RedisModule_ReplyWithError(ctx,\n            \"ERR Can't train the neural network: \"\n            \"too many NNs already training\");\n    } else {\n        return RedisModule_ReplyWithSimpleString(ctx,\"Training has started\");\n    }\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Load a neural network and its associated dataset from RDB. */\n", "func_signal": "void *NRTypeRdbLoad(RedisModuleIO *rdb, int encver)", "code": "{\n    /* As long as the module is not stable, we don't care about\n     * loading old versions of the encoding. */\n    if (encver != 2) {\n        RedisModule_LogIOError(rdb,\"warning\",\"Sorry the Neural Redis module only supports RDB files written with the encoding version %d. This file has encoding version %d, and was likely written by a previous version of this module that is now deprecated. Once the module will be stable we'll start supporting older versions of the encodings, in case we switch to newer encodings.\", NR_RDB_ENC_VER, encver);\n        return NULL;\n    }\n\n    /* Load the network layout. */\n    uint64_t numlayers = RedisModule_LoadUnsigned(rdb);\n    int *layers = RedisModule_Alloc(sizeof(int)*numlayers);\n    for (uint32_t j = 0; j < numlayers; j++)\n        layers[j] = RedisModule_LoadUnsigned(rdb);\n\n    /* Load flags and create the object. */\n    uint32_t flags = RedisModule_LoadUnsigned(rdb);\n    NRTypeObject *nr = createNRTypeObject(flags,layers,numlayers,0,0);\n    RedisModule_Free(layers);\n\n    /* Load and set the object metadata. */\n    nr->id = RedisModule_LoadUnsigned(rdb);\n    nr->training_total_steps = RedisModule_LoadUnsigned(rdb);\n    nr->training_total_ms = RedisModule_LoadUnsigned(rdb);\n    nr->training_max_cycles = RedisModule_LoadUnsigned(rdb);\n    nr->training_max_ms = RedisModule_LoadUnsigned(rdb);\n    nr->dataset_error = RedisModule_LoadFloat(rdb);\n    nr->test_error = RedisModule_LoadFloat(rdb);\n    nr->test_class_error = RedisModule_LoadFloat(rdb);\n\n    /* Load the neural network weights. */\n    for (int j = 1; j < LAYERS(nr->nn); j++) {\n        int weights = WEIGHTS(nr->nn,j);\n        for (int i = 0; i < weights; i++)\n            nr->nn->layer[j].weight[i] = RedisModule_LoadFloat(rdb);\n        for (int i = 0; i < weights; i++)\n            nr->nn->layer[j].delta[i] = RedisModule_LoadFloat(rdb);\n        for (int i = 0; i < weights; i++)\n            nr->nn->layer[j].pgradient[i] = RedisModule_LoadFloat(rdb);\n    }\n\n    /* Load the normalization vector. */\n    uint32_t ilen = INPUT_UNITS(nr->nn);\n    uint32_t olen = OUTPUT_UNITS(nr->nn);\n    for (uint32_t j = 0; j < ilen; j++)\n        nr->inorm[j] = RedisModule_LoadFloat(rdb);\n    for (uint32_t j = 0; j < olen; j++)\n        nr->onorm[j] = RedisModule_LoadFloat(rdb);\n\n    /* Load the dataset. */\n    NRTypeRdbLoadDataset(rdb,&nr->dataset,ilen,olen);\n    NRTypeRdbLoadDataset(rdb,&nr->test,ilen,olen);\n\n    return nr;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* NR.CREATE <key> <type> <inputs> [<hidden> ...] -> <outputs> [DATASET <items>]\n * [TEST <items>] [NORMALIZE] */\n", "func_signal": "int NRCreate_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    long long dset_size = 0, test_size = 0;\n    int layers[NR_MAX_LAYERS], num_layers = 0;\n    int flags = NR_FLAG_NONE;\n    RedisModule_AutoMemory(ctx);\n    NRCollectThreads(ctx);\n\n    if (argc < 6) return RedisModule_WrongArity(ctx);\n\n    const char *nntype = RedisModule_StringPtrLen(argv[2], NULL);\n    if (!strcasecmp(nntype,\"classifier\")) {\n        flags |= NR_FLAG_CLASSIFIER;\n    } else if (!strcasecmp(nntype,\"regressor\")) {\n        flags |= NR_FLAG_REGRESSOR;\n    } else {\n        return RedisModule_ReplyWithError(ctx,\n            \"ERR invalid neural network type. Must be \"\n            \"CLASSIFIER or REGRESSOR\");\n    }\n\n    /* Parse net layers definition. */\n    int j = 3, stop = 0;\n    while (j < argc) {\n        const char *u = RedisModule_StringPtrLen(argv[j], NULL);\n        long long units;\n\n        /* When we see -> the next layer is the final layer (output) layer. */\n        if (!strcmp(u,\"->\")) {\n            stop = 1;\n            j++;\n            continue;\n        }\n        if (RedisModule_StringToLongLong(argv[j],&units) != REDISMODULE_OK ||\n            units <= 0)\n        {\n            return RedisModule_ReplyWithError(ctx, \"ERR invalid units count\");\n        }\n        layers[num_layers++] = units;\n        j++;\n        if (stop) break;\n    }\n\n    /* Our NN library takes the definition of layers in the opposite\n     * order, swap the layers array. */\n    for (int i = 0; i < num_layers/2; i++) {\n        int t = layers[i];\n        layers[i] = layers[num_layers-1-i];\n        layers[num_layers-1-i] = t;\n    }\n\n    /* Parse the remaining options. */\n    for (; j < argc; j++) {\n        const char *o = RedisModule_StringPtrLen(argv[j], NULL);\n        long long v;\n        int lastarg = (j == argc-1);\n        if ((!strcasecmp(o,\"dataset\") ||\n             !strcasecmp(o,\"test\")) && !lastarg)\n        {\n            if ((RedisModule_StringToLongLong(argv[j+1],&v) != REDISMODULE_OK) ||\n                 v < 0)\n            {\n                return RedisModule_ReplyWithError(ctx,\n                    \"ERR invalid dataset size\");\n            }\n            if (!strcasecmp(o,\"dataset\"))\n                dset_size = v;\n            else\n                test_size = v;\n            j++;\n        } else if (!strcasecmp(o,\"normalize\")) {\n            flags |= NR_FLAG_NORMALIZE;\n        } else {\n            return RedisModule_ReplyWithError(ctx,\n                \"ERR Syntax error in NR.CREATE\");\n        }\n    }\n\n    /* Open the key, and check that's available. */\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    int type = RedisModule_KeyType(key);\n    if (type != REDISMODULE_KEYTYPE_EMPTY) {\n        return RedisModule_ReplyWithError(ctx,\"ERR the key name is busy\");\n    }\n\n    /* We can finally create our neural network. */\n    NRTypeObject *nr = createNRTypeObject(flags,layers,num_layers,\n                              dset_size,test_size);\n    RedisModule_ModuleTypeSetValue(key,NRType,nr);\n\n    RedisModule_ReplyWithLongLong(ctx,AnnCountWeights(nr->nn));\n    RedisModule_ReplicateVerbatim(ctx);\n    return REDISMODULE_OK;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Serialize a neural network object with its associated dataset\n * in RDB format. */\n", "func_signal": "void NRTypeRdbSave(RedisModuleIO *rdb, void *value)", "code": "{\n    NRTypeObject *nr = value;\n\n    /* Save the neural network layout. */\n    RedisModule_SaveUnsigned(rdb,LAYERS(nr->nn));\n    for (int j = 0; j < LAYERS(nr->nn); j++) {\n        int units = UNITS(nr->nn,j);\n        if (j != 0) units--; /* Don't count the bias unit. */\n        RedisModule_SaveUnsigned(rdb,units);\n    }\n\n    /* Save the object metadata. */\n    RedisModule_SaveUnsigned(rdb,nr->flags & NR_FLAG_TO_PRESIST);\n    RedisModule_SaveUnsigned(rdb,nr->id);\n    RedisModule_SaveUnsigned(rdb,nr->training_total_steps);\n    RedisModule_SaveUnsigned(rdb,nr->training_total_ms);\n    RedisModule_SaveUnsigned(rdb,nr->training_max_cycles);\n    RedisModule_SaveUnsigned(rdb,nr->training_max_ms);\n    RedisModule_SaveFloat(rdb,nr->dataset_error);\n    RedisModule_SaveFloat(rdb,nr->test_error);\n    RedisModule_SaveFloat(rdb,nr->test_class_error);\n\n    /* Save the neural network weights and biases. We start\n     * at layer 1 since the first layer are just outputs. */\n    for (int j = 1; j < LAYERS(nr->nn); j++) {\n        int weights = WEIGHTS(nr->nn,j);\n        for (int i = 0; i < weights; i++)\n            RedisModule_SaveFloat(rdb,nr->nn->layer[j].weight[i]);\n        for (int i = 0; i < weights; i++)\n            RedisModule_SaveFloat(rdb,nr->nn->layer[j].delta[i]);\n        for (int i = 0; i < weights; i++)\n            RedisModule_SaveFloat(rdb,nr->nn->layer[j].pgradient[i]);\n    }\n\n    /* Save the normalization vectors. */\n    uint32_t ilen = INPUT_UNITS(nr->nn);\n    uint32_t olen = OUTPUT_UNITS(nr->nn);\n    for (uint32_t j = 0; j < ilen; j++) RedisModule_SaveFloat(rdb,nr->inorm[j]);\n    for (uint32_t j = 0; j < olen; j++) RedisModule_SaveFloat(rdb,nr->onorm[j]);\n\n    /* Save the dataset. */\n    NRTypeRdbSaveDataset(rdb,&nr->dataset,ilen,olen);\n    NRTypeRdbSaveDataset(rdb,&nr->test,ilen,olen);\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Check if there are threads that terminated the NN training, and\n * collect the info they computed (that is the new NN). */\n", "func_signal": "int NRCollectThreads(RedisModuleCtx *ctx)", "code": "{\n    int collected = 0;\n    pthread_mutex_lock(&NRPendingTrainingMutex);\n    for (int j = 0; j < NRPendingTrainingCount; j++) {\n        NRPendingTraining *pt = &NRTrainings[j];\n        if (pt->in_progress == 0) {\n            /* Training terminated. Let's see if the key\n             * is still there and NN ID matches. */\n            int orig_id = RedisModule_GetSelectedDb(ctx);\n            if (orig_id != pt->db_id) RedisModule_SelectDb(ctx,pt->db_id);\n            RedisModuleKey *key = RedisModule_OpenKey(ctx,pt->key,\n                REDISMODULE_READ|REDISMODULE_WRITE);\n            if (RedisModule_ModuleTypeGetType(key) == NRType) {\n                NRTypeObject *nr = RedisModule_ModuleTypeGetValue(key);\n                if (nr->id == pt->nr->id) {\n                    NRTransferWeights(ctx,nr,pt->nr);\n                    nr->flags &= ~NR_FLAG_TRAINING;\n                }\n                RedisModule_FreeString(ctx,pt->key);\n                pt->key = NULL;\n                NRTypeReleaseObject(pt->nr);\n                NRPendingTrainingCount--;\n                memcpy(&NRTrainings[j],&NRTrainings[j+1],\n                    (NRPendingTrainingCount-j)*sizeof(NRTrainings[0]));\n            }\n            if (orig_id != pt->db_id) RedisModule_SelectDb(ctx,orig_id);\n            collected++;\n        }\n    }\n    pthread_mutex_unlock(&NRPendingTrainingMutex);\n    return collected;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Clone a neural network object, including the training and test dataset.\n * We use cloning in order to train in a different thread, and later\n * copy the weights back into the original NN.\n *\n * Note when 'newid' is 0, the copied object NN unique ID is the same as the\n * original as normally this is what we want, in order to later match the\n * trained network with the object stored at the specified key\n * in the pending traning structure.\n *\n * However if the copy is performed with other goals, 'newid' should\n * be set to non-zero in order to create a net with a different ID. */\n", "func_signal": "NRTypeObject *NRClone(NRTypeObject *o, int newid)", "code": "{\n    NRTypeObject *copy;\n    copy = RedisModule_Calloc(1,sizeof(*o));\n    *copy = *o;\n    if (newid) copy->id = NRNextId++;\n    copy->nn = AnnClone(o->nn);\n    copy->dataset = o->dataset;\n    copy->test = o->test;\n\n    int ilen = INPUT_UNITS(o->nn);\n    int olen = OUTPUT_UNITS(o->nn);\n    copy->dataset.inputs = RedisModule_Alloc(sizeof(float)*ilen*o->dataset.len);\n    copy->dataset.outputs = RedisModule_Alloc(sizeof(float)*olen*o->dataset.len);\n    copy->test.inputs = RedisModule_Alloc(sizeof(float)*ilen*o->test.len);\n    copy->test.outputs = RedisModule_Alloc(sizeof(float)*olen*o->test.len);\n    memcpy(copy->dataset.inputs,o->dataset.inputs,sizeof(float)*ilen*o->dataset.len);\n    memcpy(copy->dataset.outputs,o->dataset.outputs,sizeof(float)*olen*o->dataset.len);\n    memcpy(copy->test.inputs,o->test.inputs,sizeof(float)*ilen*o->test.len);\n    memcpy(copy->test.outputs,o->test.outputs,sizeof(float)*olen*o->test.len);\n\n    copy->inorm = RedisModule_Alloc(sizeof(float)*ilen);\n    copy->onorm = RedisModule_Alloc(sizeof(float)*olen);\n    memcpy(copy->inorm,o->inorm,sizeof(float)*ilen);\n    memcpy(copy->onorm,o->onorm,sizeof(float)*olen);\n    return copy;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* NR.INFO key */\n", "func_signal": "int NRInfo_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    char buf[128];\n\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    NRCollectThreads(ctx);\n\n    if (argc != 2) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1], REDISMODULE_READ);\n    if (RedisModule_ModuleTypeGetType(key) != NRType)\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n\n    NRTypeObject *nr = RedisModule_ModuleTypeGetValue(key);\n\n    int fields = 15;\n    if (nr->flags & NR_FLAG_CLASSIFIER) fields++;\n    RedisModule_ReplyWithArray(ctx,fields*2);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"id\");\n    RedisModule_ReplyWithLongLong(ctx,nr->id);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"type\");\n    RedisModule_ReplyWithSimpleString(ctx,\n        (nr->flags & NR_FLAG_CLASSIFIER) ? \"classifier\" : \"regressor\");\n\n    RedisModule_ReplyWithSimpleString(ctx,\"auto-normalization\");\n    RedisModule_ReplyWithLongLong(ctx,!!(nr->flags & NR_FLAG_NORMALIZE));\n\n    RedisModule_ReplyWithSimpleString(ctx,\"training\");\n    RedisModule_ReplyWithLongLong(ctx,!!(nr->flags & NR_FLAG_TRAINING));\n\n    RedisModule_ReplyWithSimpleString(ctx,\"layout\");\n    RedisModule_ReplyWithArray(ctx,LAYERS(nr->nn));\n    for (int i = LAYERS(nr->nn)-1; i >= 0; i--) {\n        int units = UNITS(nr->nn,i);\n        if (i != 0) units--; /* Don't count the bias unit. */\n        RedisModule_ReplyWithLongLong(ctx,units);\n    }\n\n    RedisModule_ReplyWithSimpleString(ctx,\"training-dataset-maxlen\");\n    RedisModule_ReplyWithLongLong(ctx,nr->dataset.maxlen);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"training-dataset-len\");\n    RedisModule_ReplyWithLongLong(ctx,nr->dataset.len);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"test-dataset-maxlen\");\n    RedisModule_ReplyWithLongLong(ctx,nr->test.maxlen);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"test-dataset-len\");\n    RedisModule_ReplyWithLongLong(ctx,nr->test.len);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"training-total-steps\");\n    RedisModule_ReplyWithLongLong(ctx,nr->training_total_steps);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"training-total-cycles\");\n    RedisModule_ReplyWithLongLong(ctx,\n            nr->dataset.len ?\n            (nr->training_total_steps / nr->dataset.len) : 0);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"training-total-seconds\");\n    {\n        snprintf(buf,sizeof(buf),\"%.02f\",(float)nr->training_total_ms/1000);\n        RedisModule_ReplyWithSimpleString(ctx,buf);\n    }\n\n    RedisModule_ReplyWithSimpleString(ctx,\"dataset-error\");\n    RedisModule_ReplyWithDouble(ctx,nr->dataset_error);\n\n    RedisModule_ReplyWithSimpleString(ctx,\"test-error\");\n    RedisModule_ReplyWithDouble(ctx,nr->test_error);\n\n    if (nr->flags & NR_FLAG_CLASSIFIER) {\n        RedisModule_ReplyWithSimpleString(ctx,\"classification-errors-perc\");\n        {\n            snprintf(buf,sizeof(buf),\"%.02f\",(float)nr->test_class_error);\n            RedisModule_ReplyWithSimpleString(ctx,buf);\n        }\n    }\n\n    RedisModule_ReplyWithSimpleString(ctx,\"overfitting-detected\");\n    RedisModule_ReplyWithSimpleString(ctx, (nr->flags & NR_FLAG_OF_DETECTED) ? \"yes\" : \"no\");\n\n    return REDISMODULE_OK;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Transfer the weights from the source to the destination NN.\n * This is used after the learning process finished in a different\n * thread in order to transfer the learning back to the orignal\n * NN. */\n", "func_signal": "void NRTransferWeights(RedisModuleCtx *ctx, NRTypeObject *dst, NRTypeObject *src)", "code": "{\n    if (dst->id != src->id) {\n        RedisModule_Log(ctx,\"warning\",\n            \"NSTransferWeight(): source and destination neural network IDs \"\n            \"don't match. This is unexpected, probably a bug inside the \"\n            \"module. Weights not transferred back to the origina NN.\");\n        return;\n    }\n\n    /* It would be faster to memcpy just the weight array for each layer,\n     * however this way we access the NN in a more abstract way, and should\n     * be fast enough in most cases. We can always optimized it later. */\n    AnnFree(dst->nn);\n    dst->nn = AnnClone(src->nn);\n    dst->training_total_steps = src->training_total_steps;\n    dst->training_total_ms = src->training_total_ms;\n    dst->dataset_error = src->dataset_error;\n    dst->test_error = src->test_error;\n    dst->test_class_error = src->test_class_error;\n    dst->flags |= src->flags & NR_FLAG_TO_TRANSFER;\n\n    int ilen = INPUT_UNITS(src->nn);\n    int olen = OUTPUT_UNITS(src->nn);\n    memcpy(dst->inorm,src->inorm,sizeof(float)*ilen);\n    memcpy(dst->onorm,src->onorm,sizeof(float)*olen);\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Start a background training in another thread. Return REDISMODULE_ERR if\n * there is no free slot for training, as we already reached the maximum of\n * networks we can train in parallel.\n *\n * The 'flags' argument specifies the additional NN flags to pass to the\n * training ruotine:\n *\n *  NR_FLAG_AUTO_STOP -- Automatically stop training on overtraining.\n *  NR_FLAG_BACKTRACK -- Save current NN state when overfitting is likely.\n */\n", "func_signal": "int NRStartTraining(RedisModuleCtx *ctx, RedisModuleString *key, int dbid, NRTypeObject *nr)", "code": "{\n    pthread_mutex_lock(&NRPendingTrainingMutex);\n    if (NRPendingTrainingCount == NR_PENDING_TRAINING_MAX_LEN) {\n        pthread_mutex_unlock(&NRPendingTrainingMutex);\n        return REDISMODULE_ERR;\n    }\n\n    /* Setup our trainig data. */\n    NRPendingTraining *pt = &NRTrainings[NRPendingTrainingCount];\n    pt->key = RedisModule_CreateStringFromString(ctx,key);\n    RedisModule_RetainString(ctx,pt->key);\n    pt->db_id = dbid;\n    pt->in_progress = 1;\n    pt->nr = NRClone(nr,0);\n    pt->dataset_error = 0;\n    pt->test_error = 0;\n    pt->class_error = 0;\n    pt->curcycle = 0;\n    if (pthread_create(&pt->tid,NULL,NRTrainingThreadMain,pt) != 0) {\n        RedisModule_Log(ctx,\"warning\",\"Unable to create a new pthread in NRStartTraining()\");\n        RedisModule_FreeString(ctx,pt->key);\n        pt->key = NULL;\n        NRTypeReleaseObject(pt->nr);\n        pthread_mutex_unlock(&NRPendingTrainingMutex);\n        return REDISMODULE_ERR;\n    }\n    NRPendingTrainingCount++;\n    nr->flags |= NR_FLAG_TRAINING;\n    nr->flags &= ~NR_FLAG_TO_TRANSFER;\n    pthread_mutex_unlock(&NRPendingTrainingMutex);\n    return REDISMODULE_OK;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* ========================== Low level object API ========================== */\n", "func_signal": "long long NRMilliseconds(void)", "code": "{\n    struct timeval tv;\n    long long ust;\n\n    gettimeofday(&tv, NULL);\n    ust = ((long long)tv.tv_sec)*1000000;\n    ust += tv.tv_usec;\n    return ust/1000;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Implements NR.RUN and NR.CLASS. */\n", "func_signal": "int NRGenericRun_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int output_class)", "code": "{\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    NRCollectThreads(ctx);\n\n    if (argc < 3) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1], REDISMODULE_READ);\n    if (RedisModule_ModuleTypeGetType(key) != NRType)\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n\n    NRTypeObject *nr = RedisModule_ModuleTypeGetValue(key);\n    if (output_class && !(nr->flags & NR_FLAG_CLASSIFIER))\n        return RedisModule_ReplyWithError(ctx,\n            \"ERR you can't call NR.CLASS with a regressor network. \"\n            \"Use this command with a classifier network\");\n\n\n    int ilen = INPUT_UNITS(nr->nn);\n    if (argc != ilen+2)\n        return RedisModule_ReplyWithError(ctx,\n            \"ERR number of arguments does not \"\n            \"match the number of inputs in the neural network\");\n\n    for(int j = 0; j < ilen; j++) {\n        double input;\n        if (RedisModule_StringToDouble(argv[j+2],&input) != REDISMODULE_OK)\n            return RedisModule_ReplyWithError(ctx,\n                \"ERR invalid neural network input: must be a valid float \"\n                \"precision floating point number\");\n        if (nr->flags & NR_FLAG_NORMALIZE) input /= nr->inorm[j];\n        INPUT_NODE(nr->nn,j) = input;\n    }\n\n    AnnSimulate(nr->nn);\n\n    /* Output the raw net output or the class ID if the network\n     * is a classifier and the command invoked was NR.CLASS. */\n    int olen = OUTPUT_UNITS(nr->nn);\n    if (output_class) {\n        float max = OUTPUT_NODE(nr->nn,0);\n        int max_class = 0;\n        for(int j = 1; j < olen; j++) {\n            float output = OUTPUT_NODE(nr->nn,j);\n            if (output > max) {\n                max = output;\n                max_class = j;\n            }\n        }\n        RedisModule_ReplyWithLongLong(ctx, max_class);\n    } else {\n        RedisModule_ReplyWithArray(ctx,olen);\n        for(int j = 0; j < olen; j++) {\n            float output = OUTPUT_NODE(nr->nn,j);\n            if (!(nr->flags & NR_FLAG_CLASSIFIER) &&\n                 (nr->flags & NR_FLAG_NORMALIZE))\n            {\n                output *= nr->onorm[j];\n            }\n            RedisModule_ReplyWithDouble(ctx, output);\n        }\n    }\n    return REDISMODULE_OK;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Threaded training entry point.\n *\n * To get some clue about overfitting algorithm behavior:\n * #define NR_TRAINING_DEBUG 1\n */\n", "func_signal": "void *NRTrainingThreadMain(void *arg)", "code": "{\n    NRPendingTraining *pt = arg;\n    NRTypeObject *nr = pt->nr;\n    int training_iterations = 1;\n    float train_error = 0;\n    float test_error = 0;\n    float class_error = 0;\n    float past_train_error = 1.0/0.0;\n    float past_test_error = 1.0/0.0;\n    int auto_stop = nr->flags & NR_FLAG_AUTO_STOP;\n    int backtrack = nr->flags & NR_FLAG_BACKTRACK;\n\n    uint64_t cycles = 0;\n    long long start = NRMilliseconds();\n    long long cycle_time;\n    int overfitting_count = 0;\n    int overfitting_limit = 5;\n    float best_test_error = 1.0/0.0;\n\n    nr->flags &= ~NR_FLAG_TO_TRANSFER;\n\n    /* If the network is auto normalized, we need to trasnform the inputs\n     * in a way that's acceptable for the NN. We just find the maximum\n     * absolute value, and divide for it, to get a -1,1 range. There\n     * are more advanced transformations that are usually performed that\n     * could be implemented in the future.\n     *\n     * Note that we compute the normalization vectors for all the inputs\n     * and outputs, however if the network is a classifier, flagged with\n     * (NR_FLAG_CLASSIFIER), no output normalization will be done since\n     * the data is already in 0/1 format. */\n    if ((nr->flags & NR_FLAG_NORMALIZE) && nr->dataset.len) {\n        int ilen = INPUT_UNITS(nr->nn);\n        int olen = OUTPUT_UNITS(nr->nn);\n        float *imax = nr->inorm;\n        float *omax = nr->onorm;\n        float *inputs = nr->dataset.inputs;\n        float *outputs = nr->dataset.outputs;\n        for (int i = 0; i < ilen; i++) imax[i] = 1;\n        for (int i = 0; i < olen; i++) omax[i] = 1;\n\n        /* Compute the max values vectors. */\n        for (uint32_t j = 0; j < nr->dataset.len; j++) {\n            for (int i = 0; i < ilen; i++)\n                if (fabs(inputs[i]) > imax[i]) imax[i] = fabs(inputs[i]);\n            for (int i = 0; i < olen; i++)\n                if (fabs(outputs[i]) > omax[i]) omax[i] = fabs(outputs[i]);\n            inputs += ilen;\n            outputs += olen;\n        }\n\n        /* Likely we are not seeing what will really be the true input/output\n         * maximum value, so we multiply the maximum values found by a constant.\n         * However if the max is exactly \"1\" we assume it's a classification\n         * input and don't alter it. */\n        for (int i = 0; i < ilen; i++) if (imax[i] != 1) imax[i] *= 1.2;\n        for (int i = 0; i < olen; i++) if (omax[i] != 1) omax[i] *= 1.2;\n\n        /* We can normalize the dataset directly: after the training it will\n         * be discarded anyway. */\n        inputs = nr->dataset.inputs;\n        outputs = nr->dataset.outputs;\n        for (uint32_t j = 0; j < nr->dataset.len; j++) {\n            for (int i = 0; i < ilen; i++) inputs[i] /= nr->inorm[i];\n            if (!(nr->flags & NR_FLAG_CLASSIFIER))\n                for (int i = 0; i < olen; i++) outputs[i] /= nr->onorm[i];\n            inputs += ilen;\n            outputs += olen;\n        }\n\n        inputs = nr->test.inputs;\n        outputs = nr->test.outputs;\n        for (uint32_t j = 0; j < nr->test.len; j++) {\n            for (int i = 0; i < ilen; i++) inputs[i] /= nr->inorm[i];\n            if (!(nr->flags & NR_FLAG_CLASSIFIER))\n                for (int i = 0; i < olen; i++) outputs[i] /= nr->onorm[i];\n            inputs += ilen;\n            outputs += olen;\n        }\n    }\n\n    struct Ann *saved = NULL;  /* Saved to recover on overfitting. */\n    float saved_error;          /* The test error of the saved NN. */\n    float saved_train_error;    /* The training dataset error of the saved NN */\n    float saved_class_error;    /* The % of classification errors of saved NN */\n\n    while(1) {\n        long long cycle_start = NRMilliseconds();\n\n        train_error = AnnTrain(nr->nn,\n                               nr->dataset.inputs,\n                               nr->dataset.outputs,\n                               0,\n                               training_iterations,\n                               nr->dataset.len,\n                               NN_ALGO_BPROP);\n        cycle_time = NRMilliseconds() - cycle_start;\n        nr->training_total_steps += nr->dataset.len*training_iterations;\n\n        /* Evaluate the error in the case of auto training, stop it\n         * once we see that the error in the traning set is decreasing\n         * while the one in the test set is not. */\n        if (auto_stop) {\n            AnnTestError(nr->nn,\n                         nr->test.inputs,\n                         nr->test.outputs,\n                         nr->test.len, &test_error, &class_error);\n\n            if (train_error < past_train_error &&\n                test_error > past_test_error)\n            {\n                overfitting_count++;\n                #ifdef NR_TRAINING_DEBUG\n                printf(\"+YCLE %lld: [%d] %f VS %f\\n\", (long long)cycles,\n                    overfitting_count, train_error, test_error);\n                #endif\n                if (overfitting_count == overfitting_limit) {\n                    nr->flags |= NR_FLAG_OF_DETECTED;\n                    break;\n                }\n            } else if (overfitting_count > 0) {\n                #ifdef NR_TRAINING_DEBUG\n                printf(\"-YCLE %lld: [%d] %f VS %f\\n\", (long long)cycles,\n                    overfitting_count, train_error, test_error);\n                #endif\n                overfitting_count--;\n            }\n\n            /* Save all the networks with a score better than the currently\n             * saved network. This can be a bit costly, but is safe: one\n             * cycle of training more and overfitting can ruin it all. */\n            if (backtrack && (saved == NULL || test_error < saved_error)) {\n                #ifdef NR_TRAINING_DEBUG\n                printf(\"SAVED! %f < %f\\n\", test_error, saved_error);\n                #endif\n                saved_error = test_error;\n                saved_train_error = train_error;\n                saved_class_error = class_error;\n                if (saved) AnnFree(saved);\n                saved = AnnClone(nr->nn);\n            }\n\n            /* Best network found? Reset the overfitting hints counter. */\n            if (test_error < best_test_error) {\n                overfitting_count = 0;\n                best_test_error = test_error;\n                #ifdef NR_TRAINING_DEBUG\n                printf(\"BEST! %lld: <%d> %f VS %f\\n\", (long long)cycles,\n                    overfitting_limit,train_error, test_error);\n                #endif\n            }\n\n           /* Also stop if the loss is zero in both datasets. */\n            if (train_error < 0.000000000000001 &&\n                test_error  < 0.000000000000001) break;\n        }\n\n        cycles++;\n        long long total_time = NRMilliseconds()-start;\n\n        /* Cycles and milliseconds stop conditions. */\n        if (nr->training_max_cycles && cycles == nr->training_max_cycles)\n            break;\n        if (nr->training_max_ms && total_time > (long long)nr->training_max_ms)\n            break;\n\n        /* If this is a long training, to do just a single training iteration\n         * for each cycle is not optimal: tune the number of iterations to\n         * at least take 100 milliseconds. */\n        if (total_time > 10000 && cycle_time < 100) training_iterations++;\n\n        past_train_error = train_error;\n        past_test_error = test_error;\n\n        /* Update stats for NR.THREADS to show progresses. */\n        pthread_mutex_lock(&NRPendingTrainingMutex);\n        pt->dataset_error = train_error;\n        pt->test_error = test_error;\n        if (nr->flags & NR_FLAG_CLASSIFIER) pt->class_error = class_error;\n        pt->curcycle = cycles;\n        pthread_mutex_unlock(&NRPendingTrainingMutex);\n    }\n\n    /* If auto stop is disabled, we still need to compute the test error\n     * in order to return this information to the main thread. */\n    if (!auto_stop) {\n        AnnTestError(nr->nn,\n                     nr->test.inputs,\n                     nr->test.outputs,\n                     nr->test.len, &test_error, &class_error);\n    }\n\n    /* If both autostop and backtracking are enabled, we may have\n     * a better network saved! */\n    if (auto_stop && backtrack) {\n        if (saved && saved_error < test_error) {\n            #ifdef NR_TRAINING_DEBUG\n            printf(\"BACKTRACK: Saved network used!\\n\");\n            #endif\n            AnnFree(nr->nn);\n            nr->nn = saved;\n            test_error = saved_error;\n            train_error = saved_train_error;\n            class_error = saved_class_error;\n        } else if (saved) {\n            AnnFree(saved);\n        }\n    }\n\n    if (nr->flags & NR_FLAG_CLASSIFIER) nr->test_class_error = class_error;\n    nr->dataset_error = train_error;\n    nr->test_error = test_error;\n    nr->training_total_ms += NRMilliseconds()-start;\n\n    /* Signal that the training process has finished, it's up to the main\n     * thread to cleanup this training slot, copying the weights to the\n     * original neural network and reclaiming memory for the copy we\n     * used to work. */\n    pthread_mutex_lock(&NRPendingTrainingMutex);\n    pt->in_progress = 0;\n    pthread_mutex_unlock(&NRPendingTrainingMutex);\n    return NULL;\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Helper for NRTypeRdbSave(): serialize a NRDataset dataset to RDB. */\n", "func_signal": "void NRTypeRdbSaveDataset(RedisModuleIO *rdb, NRDataset *ds, uint32_t ilen, uint32_t olen)", "code": "{\n    RedisModule_SaveUnsigned(rdb,ds->len);\n    RedisModule_SaveUnsigned(rdb,ds->maxlen);\n    for (uint32_t j = 0; j < ilen*ds->len; j++)\n        RedisModule_SaveFloat(rdb,ds->inputs[j]);\n    for (uint32_t j = 0; j < olen*ds->len; j++)\n        RedisModule_SaveFloat(rdb,ds->outputs[j]);\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Free a whole NN object. */\n", "func_signal": "void NRTypeReleaseObject(NRTypeObject *o)", "code": "{\n    AnnFree(o->nn);\n    NRDatasetFree(&o->dataset);\n    NRDatasetFree(&o->test);\n    RedisModule_Free(o->inorm);\n    RedisModule_Free(o->onorm);\n    RedisModule_Free(o);\n}", "path": "neural-redis/neuralredis.c", "commit_date": "2016-12-09 00:00:00", "repo_name": "antirez/neural-redis", "stars": 2217, "license": "bsd-3-clause", "language": "c", "size": 17078}
{"docstring": "/* Local function for setting up default handle\n * returns 0 on success */\n", "func_signal": "int wolfSSL_InitHandle()", "code": "{\n    char *sp_URI_value;\n    int ret;\n\n    sp_URI_value = wolfSSL_URI \"&_dom=adsp\";\n    ret = wolfSSL_open(sp_URI_value, &defaultHandle);\n    if (ret != 0) {\n        WOLFSSL_MSG(\"Unable to open aDSP?\");\n        return -1;\n    }\n    wolfSSL_SetHandleCb(default_handle_cb);\n    ret = wc_InitMutex(&handle_mutex);\n    if (ret != 0) {\n        WOLFSSL_MSG(\"Unable to init handle mutex\");\n        return -1;\n    }\n    return 0;\n}", "path": "wolfssl/wolfcrypt/src/wc_dsp.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* assumes queue is locked by caller */\n", "func_signal": "int wolfEventQueue_Remove(WOLF_EVENT_QUEUE* queue, WOLF_EVENT* event)", "code": "{\n    int ret = 0;\n\n    if (queue == NULL || event == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (event == queue->head && event == queue->tail) {\n        queue->head = NULL;\n        queue->tail = NULL;\n    }\n    else if (event == queue->head) {\n        queue->head = event->next;\n        queue->head->prev = NULL;\n    }\n    else if (event == queue->tail) {\n        queue->tail = event->prev;\n        queue->tail->next = NULL;\n    }\n    else {\n        WOLF_EVENT* next = event->next;\n        WOLF_EVENT* prev = event->prev;\n        next->prev = prev;\n        prev->next = next;\n    }\n    queue->count--;\n\n    return ret;\n}", "path": "wolfssl/wolfcrypt/src/wolfevent.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* internal function that closes default handle and frees mutex */\n", "func_signal": "void wolfSSL_CleanupHandle()", "code": "{\n    wolfSSL_close(defaultHandle);\n    wc_FreeMutex(&handle_mutex);\n}", "path": "wolfssl/wolfcrypt/src/wc_dsp.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* callback function for setting the default handle in single threaded\n * use cases */\n", "func_signal": "static int default_handle_cb(remote_handle64 *handle, int finished, void *ctx)", "code": "{\n    (void)ctx;\n    if (finished == WOLFSSL_HANDLE_DONE) {\n        if (wc_UnLockMutex(&handle_mutex) != 0) {\n            WOLFSSL_MSG(\"Unlock handle mutex failed\");\n            return -1;\n        }\n    }\n    else {\n        if (wc_LockMutex(&handle_mutex) != 0) {\n            WOLFSSL_MSG(\"Lock handle mutex failed\");\n            return -1;\n        }\n        *handle = defaultHandle;\n    }\n    return 0;\n}", "path": "wolfssl/wolfcrypt/src/wc_dsp.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* client task */\n", "func_signal": "void tls_smp_client_task()", "code": "{\n    int ret;\n    int sockfd;\n    int doPeerCheck;\n    int sendGet;\n    struct sockaddr_in servAddr;\n    char buff[256];\n    const char* ch = TLS_SMP_TARGET_HOST;\n    size_t len;\n    struct hostent *hp;\n    struct ip4_addr *ip4_addr;\n    const char sndMsg[] = \"GET /index.html HTTP/1.0\\r\\n\\r\\n\";\n\n    /* declare wolfSSL objects */\n    WOLFSSL_CTX *ctx;\n    WOLFSSL *ssl;\n\n    WOLFSSL_ENTER(\"tls_smp_client_task\");\n\n    doPeerCheck = 0;\n    sendGet = 0;\n\n#ifdef DEBUG_WOLFSSL\n    WOLFSSL_MSG(\"Debug ON\");\n    wolfSSL_Debugging_ON();\n    ShowCiphers();\n#endif\n    /* Initialize wolfSSL */\n    wolfSSL_Init();\n\n    /* Create a socket that uses an internet IPv4 address,\n     * Sets the socket to be stream based (TCP),\n     * 0 means choose the default protocol. */\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n        ESP_LOGE(TAG,\"ERROR: failed to create the socket\\n\");\n    }\n\n    ESP_LOGI(TAG, \"get target IP address\");\n\n    hp = gethostbyname(TLS_SMP_TARGET_HOST);\n    if (!hp) {\n         ESP_LOGE(TAG, \"Failed to get host name.\");\n         ip4_addr = NULL;\n    } else {\n\n         ip4_addr = (struct ip4_addr *)hp->h_addr;\n         ESP_LOGI(TAG, IPSTR, IP2STR(ip4_addr));\n    }\n    /* Create and initialize WOLFSSL_CTX */\n    if ((ctx = wolfSSL_CTX_new(wolfSSLv23_client_method())) == NULL) {\n        ESP_LOGE(TAG,\"ERROR: failed to create WOLFSSL_CTX\\n\");\n    }\n    WOLFSSL_MSG(\"Loading...cert\");\n    /* Load client certificates into WOLFSSL_CTX */\n    if ((ret = wolfSSL_CTX_load_verify_buffer(ctx, ca_cert_der_2048,\n        sizeof_ca_cert_der_2048, WOLFSSL_FILETYPE_ASN1)) != SSL_SUCCESS) {\n        ESP_LOGE(TAG,\"ERROR: failed to load %d, please check the file.\\n\",ret);\n    }\n    /* not peer check */\n    if( doPeerCheck == 0 ){\n        wolfSSL_CTX_set_verify(ctx, WOLFSSL_VERIFY_NONE, 0);\n    } else {\n        WOLFSSL_MSG(\"Loading... our cert\");\n        /* load our certificate */\n   \t    if ((ret = wolfSSL_CTX_use_certificate_chain_buffer_format(ctx, client_cert_der_2048,\n            sizeof_client_cert_der_2048, WOLFSSL_FILETYPE_ASN1)) != SSL_SUCCESS) {\n            ESP_LOGE(TAG,\"ERROR: failed to load chain %d, please check the file.\\n\",ret);\n        }\n\n        if ((ret = wolfSSL_CTX_use_PrivateKey_buffer(ctx, client_key_der_2048,\n            sizeof_client_key_der_2048, WOLFSSL_FILETYPE_ASN1))  != SSL_SUCCESS) {\n            wolfSSL_CTX_free(ctx); ctx = NULL;\n            ESP_LOGE(TAG,\"ERROR: failed to load key %d, please check the file.\\n\", ret);\n        }\n\n        wolfSSL_CTX_set_verify(ctx, WOLFSSL_VERIFY_PEER, 0);\n    }\n\n    /* Initialize the server address struct with zeros */\n    memset(&servAddr, 0, sizeof(servAddr));\n\n    /* Fill in the server address */\n    servAddr.sin_family = AF_INET;           /* using IPv4      */\n    servAddr.sin_port = htons(DEFAULT_PORT); /* on DEFAULT_PORT */\n\n    if(*ch >= '1' && *ch <= '9') {\n        /* Get the server IPv4 address from the command line call */\n        WOLFSSL_MSG(\"inet_pton\");\n        if ((ret = inet_pton(AF_INET, TLS_SMP_TARGET_HOST,\n                 &servAddr.sin_addr)) != 1) {\n            ESP_LOGE(TAG,\"ERROR: invalid address ret=%d\\n\", ret);\n        }\n    } else {\n        servAddr.sin_addr.s_addr = ip4_addr->addr;\n    }\n\n    /* Connect to the server */\n    sprintf(buff, \"Connecting to server....%s(port:%d)\", TLS_SMP_TARGET_HOST\n                                                      , DEFAULT_PORT);\n    WOLFSSL_MSG(buff);\n    printf(\"%s\\n\",buff);\n    if ((ret = connect(sockfd, (struct sockaddr *)&servAddr,\n                                    sizeof(servAddr))) == -1){\n        ESP_LOGE(TAG,\"ERROR: failed to connect ret=%d\\n\", ret);\n    }\n\n    WOLFSSL_MSG(\"Create a WOLFSSL object\");\n    /* Create a WOLFSSL object */\n    if ((ssl = wolfSSL_new(ctx)) == NULL) {\n        ESP_LOGE(TAG,\"ERROR: failed to create WOLFSSL object\\n\");\n    }\n\n    /* when using atecc608a on esp32-wroom-32se */\n#if defined(WOLFSSL_ESPWROOM32SE) && defined(HAVE_PK_CALLBACKS) \\\n                                  && defined(WOLFSSL_ATECC508A)\n    atcatls_set_callbacks(ctx);\n    /* when using custom slot-allocation */\n    #if defined(CUSTOM_SLOT_ALLOCATION)\n    my_atmel_slotInit();\n    atmel_set_slot_allocator(my_atmel_alloc, my_atmel_free);\n    #endif\n#endif\n\n    /* Attach wolfSSL to the socket */\n    wolfSSL_set_fd(ssl, sockfd);\n\n    WOLFSSL_MSG(\"Connect to wolfSSL on the server side\");\n    /* Connect to wolfSSL on the server side */\n    if (wolfSSL_connect(ssl) != SSL_SUCCESS) {\n        ESP_LOGE(TAG,\"ERROR: failed to connect to wolfSSL\\n\");\n    }\n\n    /* Get a message for the server from stdin */\n    WOLFSSL_MSG(\"Message for server: \");\n    memset(buff, 0, sizeof(buff));\n\n    if(sendGet){\n        printf(\"SSL connect ok, sending GET...\\n\");\n        len = XSTRLEN(sndMsg);\n        strncpy(buff, sndMsg, len);\n        buff[len] = '\\0';\n    } else {\n        sprintf(buff, \"message from esp32 tls client\\n\");\n        len = strnlen(buff, sizeof(buff));\n    }\n    /* Send the message to the server */\n    if (wolfSSL_write(ssl, buff, len) != len) {\n        ESP_LOGE(TAG,\"ERROR: failed to write\\n\");\n    }\n\n    /* Read the server data into our buff array */\n    memset(buff, 0, sizeof(buff));\n    if (wolfSSL_read(ssl, buff, sizeof(buff) - 1) == -1) {\n        ESP_LOGE(TAG,\"ERROR: failed to read\\n\");\n    }\n\n    /* Print to stdout any data the server sends */\n    printf(\"Server:\");\n    printf(\"%s\", buff);\n    /* Cleanup and return */\n    wolfSSL_free(ssl);     /* Free the wolfSSL object                  */\n    wolfSSL_CTX_free(ctx); /* Free the wolfSSL context object          */\n    wolfSSL_Cleanup();     /* Cleanup the wolfSSL environment          */\n    close(sockfd);         /* Close the connection to the server       */\n\n    vTaskDelete(NULL);\n\n    return;                /* Return reporting a success               */\n}", "path": "wolfssl/IDE/Espressif/ESP-IDF/examples/wolfssl_client/main/client-tls.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* free slot array       */\n", "func_signal": "void my_atmel_free(int slotId)", "code": "{\n    if(slotId >= 0 && slotId < ATECC_MAX_SLOT){\n        mSlotList[slotId] = ATECC_INVALID_SLOT;\n    }\n}", "path": "wolfssl/IDE/Espressif/ESP-IDF/examples/wolfssl_client/main/client-tls.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* initialize slot array */\n", "func_signal": "void my_atmel_slotInit()", "code": "{\n    int i;\n\n    for(i=0;i<ATECC_MAX_SLOT; i++) {\n        mSlotList[i] = ATECC_INVALID_SLOT;\n    }\n}", "path": "wolfssl/IDE/Espressif/ESP-IDF/examples/wolfssl_client/main/client-tls.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* Verify the signature values with the hash and public key.\n *   e = Truncate(hash, 256)\n *   u1 = e/s mod order\n *   u2 = r/s mod order\n *   r == (u1.G + u2.Q)->x mod order\n * Optimization: Leave point in projective form.\n *   (x, y, 1) == (x' / z'*z', y' / z'*z'*z', z' / z')\n *   (r + n*order).z'.z' mod prime == (u1.G + u2.Q)->x'\n * The hash is truncated to the first 256 bits.\n *\n * hash     Hash to sign.\n * hashLen  Length of the hash data.\n * rng      Random number generator.\n * priv     Private part of key - scalar.\n * rm       First part of result as an mp_int.\n * sm       Sirst part of result as an mp_int.\n * heap     Heap to use for allocation.\n * returns RNG failures, MEMORY_E when memory allocation fails and\n * MP_OKAY on success.\n */\n", "func_signal": "int sp_dsp_ecc_verify_256(remote_handle64 handleIn, const byte* hash, word32 hashLen, mp_int* pX,\n    mp_int* pY, mp_int* pZ, mp_int* r, mp_int* sm, int* res, void* heap)", "code": "{\n    int ret;\n    remote_handle64 handle = handleIn;\n\n#if 0\n    /* calling to alloc memory on the ION using these settings slowed the performance down slightly */\n    int32 *x = (int32*)rpcmem_alloc(RPCMEM_HEAP_ID_SYSTEM, RPCMEM_DEFAULT_FLAGS, 10*sizeof(int));\n    int32 *y = (int32*)rpcmem_alloc(RPCMEM_HEAP_ID_SYSTEM, RPCMEM_DEFAULT_FLAGS, 10*sizeof(int));\n    int32 *z = (int32*)rpcmem_alloc(RPCMEM_HEAP_ID_SYSTEM, RPCMEM_DEFAULT_FLAGS, 10*sizeof(int));\n    int32 *s = (int32*)rpcmem_alloc(RPCMEM_HEAP_ID_SYSTEM, RPCMEM_DEFAULT_FLAGS, 10*sizeof(int));\n    int32 *u1 = (int32*)rpcmem_alloc(RPCMEM_HEAP_ID_SYSTEM, RPCMEM_DEFAULT_FLAGS, 10*sizeof(int));\n    int32 *u2 = (int32*)rpcmem_alloc(RPCMEM_HEAP_ID_SYSTEM, RPCMEM_DEFAULT_FLAGS, 10*sizeof(int));\n#endif\n    int32 x[10] __attribute__((aligned(128)));\n    int32 y[10] __attribute__((aligned(128)));\n    int32 z[10] __attribute__((aligned(128)));\n    int32 s[10] __attribute__((aligned(128)));\n    int32 u1[10] __attribute__((aligned(128)));\n    int32 u2[10] __attribute__((aligned(128)));\n\n    if (hashLen > 32U) {\n        hashLen = 32U;\n    }\n\n    int_256_from_bin(u1, 10, hash, (int)hashLen);\n    int_256_from_mp(u2, 10, r);\n    int_256_from_mp(s, 10, sm);\n    int_256_from_mp(x, 10, pX);\n    int_256_from_mp(y, 10, pY);\n    int_256_from_mp(z, 10, pZ);\n\n    if (handle_function != NULL) {\n        handle_function(&handle, WOLFSSL_HANDLE_GET, NULL);\n    }\n\n    *res = 0;\n    ret = wolfSSL_DSP_ECC_Verify_256(handle, u1, 10, u2, 10, s, 10, x, 10, y, 10, z, 10, res);\n\n    if (handle_function != NULL) {\n        handle_function(&handle, WOLFSSL_HANDLE_DONE, NULL);\n    }\n#if 0\n    rpcmem_free(x);\n    rpcmem_free(y);\n    rpcmem_free(z);\n    rpcmem_free(s);\n    rpcmem_free(u1);\n    rpcmem_free(u2);\n#endif\n    return ret;\n}", "path": "wolfssl/wolfcrypt/src/wc_dsp.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* ARMv8 hardware acceleration Aarch32 */\n", "func_signal": "static WC_INLINE int Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)", "code": "{\n    word32 add;\n    word32 numBlocks;\n\n    /* only perform actions if a buffer is passed in */\n    if (len > 0) {\n        /* fill leftover buffer with data */\n        add = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);\n        XMEMCPY((byte*)(sha256->buffer) + sha256->buffLen, data, add);\n        sha256->buffLen += add;\n        data            += add;\n        len             -= add;\n\n        /* number of blocks in a row to complete */\n        numBlocks = (len + sha256->buffLen)/WC_SHA256_BLOCK_SIZE;\n\n        if (numBlocks > 0) {\n            word32* bufPt = sha256->buffer;\n            word32* digPt = sha256->digest;\n            /* get leftover amount after blocks */\n            add = (len + sha256->buffLen) - numBlocks * WC_SHA256_BLOCK_SIZE;\n            __asm__ volatile (\n            \"#load leftover data\\n\"\n            \"VLDM %[buffer]!, {q0-q3} \\n\"\n\n            \"#load current digest\\n\"\n            \"VLDM %[digest], {q12-q13} \\n\"\n            \"MOV r8, %[blocks] \\n\"\n            \"VREV32.8 q0, q0 \\n\"\n            \"VREV32.8 q1, q1 \\n\"\n            \"VREV32.8 q2, q2 \\n\"\n            \"VREV32.8 q3, q3 \\n\"\n            \"VLDM %[k]! ,{q5-q8} \\n\"\n            \"VLDM %[k]! ,{q9}\\n\"\n\n            \"VMOV.32 q14, q12 \\n\" /* store digest for add at the end */\n            \"VMOV.32 q15, q13 \\n\"\n\n            /* beginning of SHA256 block operation */\n            \"1:\\n\"\n\n            /* Round 1 */\n            \"VMOV.32 q4, q0           \\n\"\n            \"VADD.i32 q0, q0, q5      \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 2 */\n            \"SHA256SU0.32 q4, q1      \\n\"\n            \"VADD.i32 q0, q1, q6      \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q4, q2, q3  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 3 */\n            \"SHA256SU0.32 q1, q2      \\n\"\n            \"VADD.i32 q0, q2, q7      \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q1, q3, q4  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 4 */\n            \"SHA256SU0.32 q2, q3      \\n\"\n            \"VADD.i32 q0, q3, q8      \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q2, q4, q1  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 5 */\n            \"SHA256SU0.32 q3, q4      \\n\"\n            \"VADD.i32 q0, q4, q9      \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q3, q1, q2  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 6 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"SHA256SU0.32 q4, q1      \\n\"\n            \"VADD.i32 q0, q1, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q4, q2, q3  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 7 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"SHA256SU0.32 q1, q2      \\n\"\n            \"VADD.i32 q0, q2, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q1, q3, q4  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 8 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"SHA256SU0.32 q2, q3      \\n\"\n            \"VADD.i32 q0, q3, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q2, q4, q1  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 9 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"SHA256SU0.32 q3, q4      \\n\"\n            \"VADD.i32 q0, q4, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q3, q1, q2  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 10 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"SHA256SU0.32 q4, q1      \\n\"\n            \"VADD.i32 q0, q1, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q4, q2, q3  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 11 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"SHA256SU0.32 q1, q2      \\n\"\n            \"VADD.i32 q0, q2, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q1, q3, q4  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 12 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"SHA256SU0.32 q2, q3      \\n\"\n            \"VADD.i32 q0, q3, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q2, q4, q1  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 13 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"SHA256SU0.32 q3, q4      \\n\"\n            \"VADD.i32 q0, q4, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256SU1.32 q3, q1, q2  \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 14 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"VADD.i32 q0, q1, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 15 */\n            \"VLD1.32 {q10}, [%[k]]!   \\n\"\n            \"VADD.i32 q0, q2, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            /* Round 16 */\n            \"VLD1.32 {q10}, [%[k]]    \\n\"\n            \"SUB r8, r8, #1           \\n\"\n            \"VADD.i32 q0, q3, q10     \\n\"\n            \"VMOV.32 q11, q12         \\n\"\n            \"SHA256H.32 q12, q13, q0  \\n\"\n            \"SHA256H2.32 q13, q11, q0 \\n\"\n\n            \"#Add working vars back into digest state \\n\"\n            \"VADD.i32 q12, q12, q14 \\n\"\n            \"VADD.i32 q13, q13, q15 \\n\"\n\n            \"#check if more blocks should be done\\n\"\n            \"CMP r8, #0 \\n\"\n            \"BEQ 2f \\n\"\n\n            \"#load in message and schedule updates \\n\"\n            \"VLD1.32 {q0}, [%[dataIn]]!   \\n\"\n            \"VLD1.32 {q1}, [%[dataIn]]!   \\n\"\n            \"VLD1.32 {q2}, [%[dataIn]]!   \\n\"\n            \"VLD1.32 {q3}, [%[dataIn]]!   \\n\"\n\n            /* reset K pointer */\n            \"SUB %[k], %[k], #160 \\n\"\n            \"VREV32.8 q0, q0 \\n\"\n            \"VREV32.8 q1, q1 \\n\"\n            \"VREV32.8 q2, q2 \\n\"\n            \"VREV32.8 q3, q3 \\n\"\n            \"VMOV.32 q14, q12 \\n\"\n            \"VMOV.32 q15, q13 \\n\"\n            \"B 1b \\n\" /* do another block */\n\n            \"2:\\n\"\n            \"VST1.32 {q12, q13}, [%[out]] \\n\"\n\n            : [out] \"=r\" (digPt), \"=r\" (bufPt), \"=r\" (numBlocks),\n              \"=r\" (data)\n            : [k] \"r\" (K), [digest] \"0\" (digPt), [buffer] \"1\" (bufPt),\n              [blocks] \"2\" (numBlocks), [dataIn] \"3\" (data)\n            : \"cc\", \"memory\", \"q0\", \"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q6\", \"q7\",\n                              \"q8\",  \"q9\",  \"q10\", \"q11\", \"q12\", \"q13\", \"q14\",\n                              \"q15\", \"r8\"\n            );\n\n            AddLength(sha256, WC_SHA256_BLOCK_SIZE * numBlocks);\n\n            /* copy over any remaining data leftover */\n            XMEMCPY(sha256->buffer, data, add);\n            sha256->buffLen = add;\n        }\n    }\n\n    /* account for possibility of not used if len = 0 */\n    (void)add;\n    (void)numBlocks;\n\n    return 0;\n}", "path": "wolfssl/wolfcrypt/src/port/arm/armv8-sha256.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* Read big endian unsigned byte array into r.\n *\n * r  A single precision integer.\n * size  Maximum number of bytes to convert\n * a  Byte array.\n * n  Number of bytes in array to read.\n */\n", "func_signal": "static void int_256_from_bin(int32* r, int size, const byte* a, int n)", "code": "{\n    int i, j = 0;\n    word32 s = 0;\n\n    r[0] = 0;\n    for (i = n-1; i >= 0; i--) {\n        r[j] |= (((int32)a[i]) << s);\n        if (s >= 18U) {\n            r[j] &= 0x3ffffff;\n            s = 26U - s;\n            if (j + 1 >= size) {\n                break;\n            }\n            r[++j] = (int32)a[i] >> s;\n            s = 8U - s;\n        }\n        else {\n            s += 8U;\n        }\n    }\n\n    for (j++; j < size; j++) {\n        r[j] = 0;\n    }\n}", "path": "wolfssl/wolfcrypt/src/wc_dsp.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/*------------------------------------------------------------------------*/\n/* TLS CLIENT */\n/*------------------------------------------------------------------------*/\n", "func_signal": "static int CbIORecv(WOLFSSL *ssl, char *buf, int sz, void *ctx)", "code": "{\n    int ret = WOLFSSL_CBIO_ERR_GENERAL;\n\n    (void)ssl;\n    (void)ctx;\n\n    /* TODO: Exchange data over your own transport */\n    #warning TODO: Implement your own recv data transport\n#if 0\n    ret = usart_read_buffer_wait(&cdc_uart_module, buf, sz);\n    if (ret == STATUS_ERR_TIMEOUT)\n        return WOLFSSL_CBIO_ERR_WANT_READ;\n\n    return (ret == STATUS_OK) ? sz : WOLFSSL_CBIO_ERR_GENERAL;\n#else\n    return ret;\n#endif\n}", "path": "wolfssl/IDE/GCC-ARM/Source/tls_client.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* assumes queue is locked by caller */\n", "func_signal": "int wolfEventQueue_Add(WOLF_EVENT_QUEUE* queue, WOLF_EVENT* event)", "code": "{\n    if (queue == NULL || event == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    event->next = NULL; /* added to end */\n    event->prev = NULL;\n    if (queue->tail == NULL)  {\n        queue->head = event;\n    }\n    else {\n        queue->tail->next = event;\n        event->prev = queue->tail;\n    }\n    queue->tail = event;      /* add to the end either way */\n    queue->count++;\n\n    return 0;\n}", "path": "wolfssl/wolfcrypt/src/wolfevent.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* Convert an mp_int to an array of sp_digit.\n *\n * r  A single precision integer.\n * size  Maximum number of bytes to convert\n * a  A multi-precision integer.\n */\n", "func_signal": "static void int_256_from_mp(int32* r, int size, const mp_int* a)", "code": "{\n#if DIGIT_BIT == 26\n    int j;\n\n    XMEMCPY(r, a->dp, sizeof(int32) * a->used);\n\n    for (j = a->used; j < size; j++) {\n        r[j] = 0;\n    }\n#elif DIGIT_BIT > 26\n    int i, j = 0;\n    word32 s = 0;\n\n    r[0] = 0;\n    for (i = 0; i < a->used && j < size; i++) {\n        r[j] |= ((int32)a->dp[i] << s);\n        r[j] &= 0x3ffffff;\n        s = 26U - s;\n        if (j + 1 >= size) {\n            break;\n        }\n        /* lint allow cast of mismatch word32 and mp_digit */\n        r[++j] = (int32)(a->dp[i] >> s); /*lint !e9033*/\n        while ((s + 26U) <= (word32)DIGIT_BIT) {\n            s += 26U;\n            r[j] &= 0x3ffffff;\n            if (j + 1 >= size) {\n                break;\n            }\n            if (s < (word32)DIGIT_BIT) {\n                /* lint allow cast of mismatch word32 and mp_digit */\n                r[++j] = (int32)(a->dp[i] >> s); /*lint !e9033*/\n            }\n            else {\n                r[++j] = 0L;\n            }\n        }\n        s = (word32)DIGIT_BIT - s;\n    }\n\n    for (j++; j < size; j++) {\n        r[j] = 0;\n    }\n#else\n    int i, j = 0, s = 0;\n\n    r[0] = 0;\n    for (i = 0; i < a->used && j < size; i++) {\n        r[j] |= ((int32)a->dp[i]) << s;\n        if (s + DIGIT_BIT >= 26) {\n            r[j] &= 0x3ffffff;\n            if (j + 1 >= size) {\n                break;\n            }\n            s = 26 - s;\n            if (s == DIGIT_BIT) {\n                r[++j] = 0;\n                s = 0;\n            }\n            else {\n                r[++j] = a->dp[i] >> s;\n                s = DIGIT_BIT - s;\n            }\n        }\n        else {\n            s += DIGIT_BIT;\n        }\n    }\n\n    for (j++; j < size; j++) {\n        r[j] = 0;\n    }\n#endif\n}", "path": "wolfssl/wolfcrypt/src/wc_dsp.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* ARMv8 hardware acceleration */\n", "func_signal": "static WC_INLINE int Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)", "code": "{\n    word32 add;\n    word32 numBlocks;\n\n    /* only perform actions if a buffer is passed in */\n    if (len > 0) {\n        /* fill leftover buffer with data */\n        add = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);\n        XMEMCPY((byte*)(sha256->buffer) + sha256->buffLen, data, add);\n        sha256->buffLen += add;\n        data            += add;\n        len             -= add;\n\n        /* number of blocks in a row to complete */\n        numBlocks = (len + sha256->buffLen)/WC_SHA256_BLOCK_SIZE;\n\n        if (numBlocks > 0) {\n            word32* k = (word32*)K;\n\n            /* get leftover amount after blocks */\n            add = (len + sha256->buffLen) - numBlocks * WC_SHA256_BLOCK_SIZE;\n            __asm__ volatile (\n            \"#load leftover data\\n\"\n            \"LD1 {v0.2d-v3.2d}, %[buffer]   \\n\"\n\n            \"#load current digest\\n\"\n            \"LD1 {v12.2d-v13.2d}, %[digest] \\n\"\n            \"MOV w8, %w[blocks] \\n\"\n            \"REV32 v0.16b, v0.16b \\n\"\n            \"REV32 v1.16b, v1.16b \\n\"\n            \"REV32 v2.16b, v2.16b \\n\"\n            \"REV32 v3.16b, v3.16b \\n\"\n\n            \"#load K values in \\n\"\n            \"LD1 {v16.4s-v19.4s}, [%[k]], #64    \\n\"\n            \"LD1 {v20.4s-v23.4s}, [%[k]], #64    \\n\"\n            \"MOV v14.16b, v12.16b \\n\" /* store digest for add at the end */\n            \"MOV v15.16b, v13.16b \\n\"\n            \"LD1 {v24.4s-v27.4s}, [%[k]], #64    \\n\"\n            \"LD1 {v28.4s-v31.4s}, [%[k]], #64    \\n\"\n\n            /* beginning of SHA256 block operation */\n            \"1:\\n\"\n            /* Round 1 */\n            \"MOV v4.16b, v0.16b        \\n\"\n            \"ADD v0.4s, v0.4s, v16.4s  \\n\"\n            \"MOV v11.16b, v12.16b      \\n\"\n            \"SHA256H q12, q13, v0.4s   \\n\"\n            \"SHA256H2 q13, q11, v0.4s  \\n\"\n\n            /* Round 2 */\n            \"SHA256SU0 v4.4s, v1.4s        \\n\"\n            \"ADD v0.4s, v1.4s, v17.4s  \\n\"\n            \"MOV v11.16b, v12.16b      \\n\"\n            \"SHA256SU1 v4.4s, v2.4s, v3.4s \\n\"\n            \"SHA256H q12, q13, v0.4s   \\n\"\n            \"SHA256H2 q13, q11, v0.4s  \\n\"\n\n            /* Round 3 */\n            \"SHA256SU0 v1.4s, v2.4s        \\n\"\n            \"ADD v0.4s, v2.4s, v18.4s  \\n\"\n            \"MOV v11.16b, v12.16b      \\n\"\n            \"SHA256SU1 v1.4s, v3.4s, v4.4s \\n\"\n            \"SHA256H q12, q13, v0.4s   \\n\"\n            \"SHA256H2 q13, q11, v0.4s  \\n\"\n\n            /* Round 4 */\n            \"SHA256SU0 v2.4s, v3.4s        \\n\"\n            \"ADD v0.4s, v3.4s, v19.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v2.4s, v4.4s, v1.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 5 */\n            \"SHA256SU0 v3.4s, v4.4s        \\n\"\n            \"ADD v0.4s, v4.4s, v20.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v3.4s, v1.4s, v2.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 6 */\n            \"SHA256SU0 v4.4s, v1.4s        \\n\"\n            \"ADD v0.4s, v1.4s, v21.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v4.4s, v2.4s, v3.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 7 */\n            \"SHA256SU0 v1.4s, v2.4s        \\n\"\n            \"ADD v0.4s, v2.4s, v22.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v1.4s, v3.4s, v4.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 8 */\n            \"SHA256SU0 v2.4s, v3.4s        \\n\"\n            \"ADD v0.4s, v3.4s, v23.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v2.4s, v4.4s, v1.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 9 */\n            \"SHA256SU0 v3.4s, v4.4s        \\n\"\n            \"ADD v0.4s, v4.4s, v24.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v3.4s, v1.4s, v2.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 10 */\n            \"SHA256SU0 v4.4s, v1.4s        \\n\"\n            \"ADD v0.4s, v1.4s, v25.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v4.4s, v2.4s, v3.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 11 */\n            \"SHA256SU0 v1.4s, v2.4s        \\n\"\n            \"ADD v0.4s, v2.4s, v26.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v1.4s, v3.4s, v4.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 12 */\n            \"SHA256SU0 v2.4s, v3.4s        \\n\"\n            \"ADD v0.4s, v3.4s, v27.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v2.4s, v4.4s, v1.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 13 */\n            \"SHA256SU0 v3.4s, v4.4s        \\n\"\n            \"ADD v0.4s, v4.4s, v28.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256SU1 v3.4s, v1.4s, v2.4s \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 14 */\n            \"ADD v0.4s, v1.4s, v29.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 15 */\n            \"ADD v0.4s, v2.4s, v30.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            /* Round 16 */\n            \"ADD v0.4s, v3.4s, v31.4s      \\n\"\n            \"MOV v11.16b, v12.16b          \\n\"\n            \"SHA256H q12, q13, v0.4s       \\n\"\n            \"SHA256H2 q13, q11, v0.4s      \\n\"\n\n            \"#Add working vars back into digest state \\n\"\n            \"SUB w8, w8, #1    \\n\"\n            \"ADD v12.4s, v12.4s, v14.4s \\n\"\n            \"ADD v13.4s, v13.4s, v15.4s \\n\"\n\n            \"#check if more blocks should be done\\n\"\n            \"CBZ w8, 2f \\n\"\n\n            \"#load in message and schedule updates \\n\"\n            \"LD1 {v0.2d-v3.2d}, [%[dataIn]], #64   \\n\"\n            \"MOV v14.16b, v12.16b \\n\"\n            \"MOV v15.16b, v13.16b \\n\"\n            \"REV32 v0.16b, v0.16b \\n\"\n            \"REV32 v1.16b, v1.16b \\n\"\n            \"REV32 v2.16b, v2.16b \\n\"\n            \"REV32 v3.16b, v3.16b \\n\"\n            \"B 1b \\n\" /* do another block */\n\n            \"2:\\n\"\n            \"STP q12, q13, %[out] \\n\"\n\n            : [out] \"=m\" (sha256->digest), \"=m\" (sha256->buffer), \"=r\" (numBlocks),\n              \"=r\" (data), \"=r\" (k)\n            : [k] \"4\" (k), [digest] \"m\" (sha256->digest), [buffer] \"m\" (sha256->buffer),\n              [blocks] \"2\" (numBlocks), [dataIn] \"3\" (data)\n            : \"cc\", \"memory\", \"v0\", \"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\",\n                              \"v8\",  \"v9\",  \"v10\", \"v11\", \"v12\", \"v13\", \"v14\",\n                              \"v15\", \"v16\", \"v17\", \"v18\", \"v19\", \"v20\", \"v21\",\n                              \"v22\", \"v23\", \"v24\", \"v25\", \"v26\", \"v27\", \"v28\",\n                              \"v29\", \"v30\", \"v31\", \"w8\"\n            );\n\n            AddLength(sha256, WC_SHA256_BLOCK_SIZE * numBlocks);\n\n            /* copy over any remaining data leftover */\n            XMEMCPY(sha256->buffer, data, add);\n            sha256->buffLen = add;\n        }\n    }\n\n    /* account for possibility of not used if len = 0 */\n    (void)add;\n    (void)numBlocks;\n\n    return 0;\n}", "path": "wolfssl/wolfcrypt/src/port/arm/armv8-sha256.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* Set global callback for getting handle to use\n * return 0 on success */\n", "func_signal": "int wolfSSL_SetHandleCb(wolfSSL_DSP_Handle_cb in)", "code": "{\n    handle_function = in;\n    return 0;\n}", "path": "wolfssl/wolfcrypt/src/wc_dsp.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* allocate slot depending on slotType */\n", "func_signal": "int my_atmel_alloc(int slotType)", "code": "{\n    int i, slot = -1;\n\n    switch(slotType){\n        case ATMEL_SLOT_ENCKEY:\n            slot = 2;\n            break;\n        case ATMEL_SLOT_DEVICE:\n            slot = 0;\n            break;\n        case ATMEL_SLOT_ECDHE:\n            slot = 0;\n            break;\n        case ATMEL_SLOT_ECDHE_ENC:\n            slot = 4;\n            break;\n        case ATMEL_SLOT_ANY:\n            for(i=0;i<ATECC_MAX_SLOT;i++){\n                if(mSlotList[i] == ATECC_INVALID_SLOT){\n                    slot = i;\n                    break;\n                }\n            }\n    }\n\n    return slot;\n}", "path": "wolfssl/IDE/Espressif/ESP-IDF/examples/wolfssl_client/main/client-tls.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* FileSystem definitions             */\n", "func_signal": "static void init_filesystem (void)", "code": "{\n  int32_t retv;\n\n  retv = finit (\"M0:\");\n  if (retv == fsOK) {\n    retv = fmount (\"M0:\");\n    if (retv == fsOK) {\n      printf (\"Drive M0 ready!\\n\");\n    }\n    else {\n      printf (\"Drive M0 mount failed(%d)!\\n\", retv);\n    }\n  }\n  else {\n    printf (\"Drive M0 initialization failed!\\n\");\n  }\n}", "path": "wolfssl/IDE/MDK5-ARM/Projects/EchoClient/main.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* Used to assign a handle to an ecc_key structure.\n * returns 0 on success */\n", "func_signal": "int wc_ecc_set_handle(ecc_key* key, remote_handle64 handle)", "code": "{\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n    key->handle = handle;\n    return 0;\n}", "path": "wolfssl/wolfcrypt/src/wc_dsp.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* WOLFSSL_SCTP */\n", "func_signal": "int main()", "code": "{\n#ifdef WOLFSSL_SCTP\n    int sd = socket(PF_INET, SOCK_STREAM, IPPROTO_SCTP);\n\n    if (sd < 0)\n        perror(\"sctp socket error\");\n\n    struct sockaddr_in sa;\n    memset(&sa, 0, sizeof(sa));\n    sa.sin_family = AF_INET;\n    sa.sin_addr.s_addr = htonl(INADDR_ANY);\n    sa.sin_port = htons(12345);\n\n    int ret = bind(sd, (struct sockaddr*)&sa, sizeof(sa));\n    if (ret < 0)\n        perror(\"sctp bind error\");\n\n    listen(sd, 3);\n\n    int client_sd = accept(sd, NULL, NULL);\n    if (client_sd < 0)\n        perror(\"sctp accept error\");\n\n    const char* response = \"hi there\";\n    char buffer[80];\n\n    int got = (int)recv(client_sd, buffer, sizeof(buffer), 0);\n    if (got > 0) {\n        buffer[got] = 0;\n        printf(\"client said: %s\\n\", buffer);\n    }\n    send(client_sd, response, strlen(response), 0);\n\n\n    close(sd);\n#endif /* WOLFSSL_SCTP */\n    return 0;\n}", "path": "wolfssl/examples/sctp/sctp-server.c", "commit_date": "2020-02-19 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/* (!NO_RSA || HAVE_ECC) && !WC_NO_RNG */\n", "func_signal": "TEST_CASE(\"wolfssl aes test\"  , \"[wolfssl]\")", "code": "{\n    ESP_LOGI(TAG, \"aes test\");\n    TEST_ASSERT_EQUAL(0, aes_test());\n#ifdef WOLFSSL_AES_192\n    ESP_LOGI(TAG, \"aes_192 test\");\n    TEST_ASSERT_EQUAL(0, aes192_test());\n#endif\n#ifdef WOLFSSL_AES_256\n    ESP_LOGI(TAG, \"aes_256 test\");\n    TEST_ASSERT_EQUAL(0, aes256_test());\n#endif\n    ESP_LOGI(TAG, \"aes-gcm test\");\n    TEST_ASSERT_EQUAL(0, aesgcm_test());\n}", "path": "wolfssl/IDE/Espressif/ESP-IDF/test/test_wolfssl.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "wolfSSL/wolfssl", "stars": 2137, "license": "gpl-2.0", "language": "c", "size": 628084}
{"docstring": "/**\n  * @brief  Reset callback.\n  * @param  hpcd: PCD handle\n  * @retval None\n  */\n", "func_signal": "void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)", "code": "{\n  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, USBD_SPEED_FULL);\n  /* Reset Device */\n  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Opens an endpoint of the Low Level Driver.\n  * @param  pdev: Device handle\n  * @param  ep_addr: Endpoint Number\n  * @param  ep_type: Endpoint Type\n  * @param  ep_mps: Endpoint Max Packet Size\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev,\n                                  uint8_t ep_addr,\n                                  uint8_t ep_type,\n                                  uint16_t ep_mps)", "code": "{\n  // printf1(TAG_RED,\"LL_Open. ep: %x, %x\\r\\n\", ep_addr, ep_type);\n  HAL_PCD_EP_Open((PCD_HandleTypeDef*) pdev->pData,\n                  ep_addr,\n                  ep_mps,\n                  ep_type);\n\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Sets a Stall condition on an endpoint of the Low Level Driver.\n  * @param  pdev: Device handle\n  * @param  ep_addr: Endpoint Number\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)", "code": "{\n  HAL_PCD_EP_SetStall((PCD_HandleTypeDef*) pdev->pData, ep_addr);\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Assigns a USB address to the device.\n  * @param  pdev: Device handle\n  * @param  ep_addr: Endpoint Number\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)", "code": "{\n  HAL_PCD_SetAddress((PCD_HandleTypeDef*) pdev->pData, dev_addr);\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "// Locks solo flash from debugging.  Locks on next reboot.\n// This should be removed in next Solo release.\n", "func_signal": "void solo_lock_if_not_already()", "code": "{\n    uint8_t buf[2048];\n\n    memmove(buf, (uint8_t*)ATTESTATION_PAGE_ADDR, 2048);\n\n    ((flash_attestation_page *)buf)->device_settings |= SOLO_FLAG_LOCKED;\n\n    flash_erase_page(ATTESTATION_PAGE);\n\n    flash_write(ATTESTATION_PAGE_ADDR, buf, 2048);\n}", "path": "solo1/targets/stm32l432/src/device.c", "commit_date": "2020-03-25 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Transmits data over an endpoint.\n  * @param  pdev: Device handle\n  * @param  ep_addr: Endpoint Number\n  * @param  pbuf: Pointer to data to be sent\n  * @param  size: Data size\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev,\n                                    uint8_t ep_addr,\n                                    uint8_t *pbuf,\n                                    uint16_t size)", "code": "{\n  HAL_PCD_EP_Transmit((PCD_HandleTypeDef*) pdev->pData, ep_addr, pbuf, size);\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Returns Stall condition.\n  * @param  pdev: Device handle\n  * @param  ep_addr: Endpoint Number\n  * @retval Stall (1: Yes, 0: No)\n  */\n", "func_signal": "uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)", "code": "{\n  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;\n\n  if((ep_addr & 0x80) == 0x80)\n  {\n    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;\n  }\n  else\n  {\n    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;\n  }\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  De-Initializes the Low Level portion of the Device driver.\n  * @param  pdev: Device handle\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_DeInit(USBD_HandleTypeDef *pdev)", "code": "{\n  HAL_PCD_DeInit((PCD_HandleTypeDef*)pdev->pData);\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "// return 1 if hash is valid, 0 otherwise\n", "func_signal": "int check_pinhash(uint8_t * pinAuth, uint8_t * msg, uint8_t len)", "code": "{\n    uint8_t hmac[32];\n    crypto_sha256_hmac_init(PIN_TOKEN, PIN_TOKEN_SIZE, hmac);\n    crypto_sha256_update(msg, 8);\n    crypto_sha256_update(msg+ 8 + 16, len - 8 - 16);\n    crypto_sha256_hmac_final(PIN_TOKEN, PIN_TOKEN_SIZE, hmac);\n\n    return (memcmp(pinAuth, hmac, 16) == 0);\n}", "path": "solo1/fido2/extensions/wallet.c", "commit_date": "2019-08-20 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Stops the Low Level portion of the Device driver.\n  * @param  pdev: Device handle\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_Stop(USBD_HandleTypeDef *pdev)", "code": "{\n  HAL_PCD_Stop((PCD_HandleTypeDef*) pdev->pData);\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Clears a Stall condition on an endpoint of the Low Level Driver.\n  * @param  pdev: Device handle\n  * @param  ep_addr: Endpoint Number\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)", "code": "{\n  HAL_PCD_EP_ClrStall((PCD_HandleTypeDef*) pdev->pData, ep_addr);\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Initializes the PCD MSP.\n  * @param  hpcd: PCD handle\n  * @retval None\n  */\n", "func_signal": "void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)", "code": "{\n  SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USBFSEN);\n\n  if(hpcd->Init.low_power_enable == 1)\n  {\n    /* Enable EXTI Line 17 for USB wakeup */\n    __HAL_USB_WAKEUP_EXTI_ENABLE_IT();\n  }\n\n  /* Set USB FS Interrupt priority */\n  NVIC_SetPriority(USB_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0x0f, 0));\n\n  /* Enable USB FS Interrupt */\n  NVIC_EnableIRQ(USB_IRQn);\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Starts the Low Level portion of the Device driver.\n  * @param  pdev: Device handle\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)", "code": "{\n  HAL_PCD_Start((PCD_HandleTypeDef*)pdev->pData);\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Initialize the SPI registers according to the specified parameters in SPI_InitStruct.\n  * @note   As some bits in SPI configuration registers can only be written when the SPI is disabled (SPI_CR1_SPE bit =0),\n  *         SPI IP should be in disabled state prior calling this function. Otherwise, ERROR result will be returned.\n  * @param  SPIx SPI Instance\n  * @param  SPI_InitStruct pointer to a @ref LL_SPI_InitTypeDef structure\n  * @retval An ErrorStatus enumeration value. (Return always SUCCESS)\n  */\n", "func_signal": "ErrorStatus LL_SPI_Init(SPI_TypeDef *SPIx, LL_SPI_InitTypeDef *SPI_InitStruct)", "code": "{\n  ErrorStatus status = ERROR;\n\n  /* Check the SPI Instance SPIx*/\n  assert_param(IS_SPI_ALL_INSTANCE(SPIx));\n\n  /* Check the SPI parameters from SPI_InitStruct*/\n  assert_param(IS_LL_SPI_TRANSFER_DIRECTION(SPI_InitStruct->TransferDirection));\n  assert_param(IS_LL_SPI_MODE(SPI_InitStruct->Mode));\n  assert_param(IS_LL_SPI_DATAWIDTH(SPI_InitStruct->DataWidth));\n  assert_param(IS_LL_SPI_POLARITY(SPI_InitStruct->ClockPolarity));\n  assert_param(IS_LL_SPI_PHASE(SPI_InitStruct->ClockPhase));\n  assert_param(IS_LL_SPI_NSS(SPI_InitStruct->NSS));\n  assert_param(IS_LL_SPI_BAUDRATE(SPI_InitStruct->BaudRate));\n  assert_param(IS_LL_SPI_BITORDER(SPI_InitStruct->BitOrder));\n  assert_param(IS_LL_SPI_CRCCALCULATION(SPI_InitStruct->CRCCalculation));\n\n  if (LL_SPI_IsEnabled(SPIx) == 0x00000000U)\n  {\n    /*---------------------------- SPIx CR1 Configuration ------------------------\n     * Configure SPIx CR1 with parameters:\n     * - TransferDirection:  SPI_CR1_BIDIMODE, SPI_CR1_BIDIOE and SPI_CR1_RXONLY bits\n     * - Master/Slave Mode:  SPI_CR1_MSTR bit\n     * - ClockPolarity:      SPI_CR1_CPOL bit\n     * - ClockPhase:         SPI_CR1_CPHA bit\n     * - NSS management:     SPI_CR1_SSM bit\n     * - BaudRate prescaler: SPI_CR1_BR[2:0] bits\n     * - BitOrder:           SPI_CR1_LSBFIRST bit\n     * - CRCCalculation:     SPI_CR1_CRCEN bit\n     */\n    MODIFY_REG(SPIx->CR1,\n               SPI_CR1_CLEAR_MASK,\n               SPI_InitStruct->TransferDirection | SPI_InitStruct->Mode |\n               SPI_InitStruct->ClockPolarity | SPI_InitStruct->ClockPhase |\n               SPI_InitStruct->NSS | SPI_InitStruct->BaudRate |\n               SPI_InitStruct->BitOrder | SPI_InitStruct->CRCCalculation);\n\n    /*---------------------------- SPIx CR2 Configuration ------------------------\n     * Configure SPIx CR2 with parameters:\n     * - DataWidth:          DS[3:0] bits\n     * - NSS management:     SSOE bit\n     */\n    MODIFY_REG(SPIx->CR2,\n               SPI_CR2_DS | SPI_CR2_SSOE,\n               SPI_InitStruct->DataWidth | (SPI_InitStruct->NSS >> 16U));\n\n    /*---------------------------- SPIx CRCPR Configuration ----------------------\n     * Configure SPIx CRCPR with parameters:\n     * - CRCPoly:            CRCPOLY[15:0] bits\n     */\n    if (SPI_InitStruct->CRCCalculation == LL_SPI_CRCCALCULATION_ENABLE)\n    {\n      assert_param(IS_LL_SPI_CRC_POLYNOMIAL(SPI_InitStruct->CRCPoly));\n      LL_SPI_SetCRCPolynomial(SPIx, SPI_InitStruct->CRCPoly);\n    }\n    status = SUCCESS;\n  }\n\n  return status;\n}", "path": "solo1/targets/stm32l432/lib/stm32l4xx_ll_spi.c", "commit_date": "2019-01-06 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "// Interrupt on rising edge of button (button released)\n", "func_signal": "void EXTI0_IRQHandler(void)", "code": "{\n    EXTI->PR1 = EXTI->PR1;\n    if (is_physical_button_pressed == IS_BUTTON_PRESSED)\n    {\n        // Only allow 1 press per 25 ms.\n        if ((millis() - __last_button_bounce_time) > 25)\n        {\n            __last_button_press_time = millis();\n        }\n        __last_button_bounce_time = millis();\n    }\n}", "path": "solo1/targets/stm32l432/src/device.c", "commit_date": "2020-03-25 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "//  FIXME test version check function\n", "func_signal": "bool is_newer(const version_t* const newer, const version_t* const older)", "code": "{\n  return (newer->major > older->major) ||\n         (newer->major == older->major &&  newer->minor > older->minor) ||\n         (newer->major == older->major &&  newer->minor == older->minor &&  newer->patch >= older->patch);\n}", "path": "solo1/targets/stm32l432/bootloader/version_check.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  DataOut Stage callback.\n  * @param  hpcd: PCD handle\n  * @param  epnum: Endpoint Number\n  * @retval None\n  */\n// From host --> device\n", "func_signal": "void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)", "code": "{\n  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);\n  switch(epnum)\n  {\n      case HID_EPOUT_ADDR:\n        usb_hid_recieve_callback(epnum);\n      break;\n#ifdef ENABLE_CCID\n      case CCID_OUT_EP:\n        usb_ccid_recieve_callback((USBD_HandleTypeDef*)hpcd->pData, epnum);\n      break;\n#endif\n  }\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "// Returns 1 if this is a extension request.\n// Else 0 if nothing is done.\n", "func_signal": "int16_t extend_fido2(CredentialId * credid, uint8_t * output)", "code": "{\n    if (is_extension_request((uint8_t*)credid, sizeof(CredentialId)))\n    {\n        printf1(TAG_EXT,\"IS EXT REQ\\r\\n\");\n        output[0] = bridge_u2f_to_solo(output+1, (uint8_t*)credid, sizeof(CredentialId));\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "path": "solo1/fido2/extensions/extensions.c", "commit_date": "2019-04-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "// Timer6 overflow handler.  happens every ~90ms.\n", "func_signal": "void TIM6_DAC_IRQHandler(void)", "code": "{\n    // timer is only 16 bits, so roll it over here\n    TIM6->SR = 0;\n    __90_ms += 1;\n    if ((millis() - __last_update) > 90)\n    {\n        if (__device_status != CTAPHID_STATUS_IDLE)\n        {\n            ctaphid_update_status(__device_status);\n        }\n    }\n\n    edge_detect_touch_button();\n\n#ifndef IS_BOOTLOADER\n\t// NFC sending WTX if needs\n\tif (device_is_nfc() == NFC_IS_ACTIVE)\n\t{\n\t\tWTX_timer_exec();\n\t}\n#endif\n}", "path": "solo1/targets/stm32l432/src/device.c", "commit_date": "2020-03-25 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "/**\n  * @brief  Flushes an endpoint of the Low Level Driver.\n  * @param  pdev: Device handle\n  * @param  ep_addr: Endpoint Number\n  * @retval USBD Status\n  */\n", "func_signal": "USBD_StatusTypeDef USBD_LL_FlushEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)", "code": "{\n  HAL_PCD_EP_Flush((PCD_HandleTypeDef*) pdev->pData, ep_addr);\n  return USBD_OK;\n}", "path": "solo1/targets/stm32l432/lib/usbd/usbd_conf.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "solokeys/solo1", "stars": 2266, "license": "other", "language": "c", "size": 3442}
{"docstring": "//\u4ece\u4e32\u53e33 mini\u53d1\u9001\u7684\u6df1\u5ea6\u539f\u59cb\u6570\u636e \u5f97\u5230\u6df1\u5ea6\u6570\u636e\n", "func_signal": "void Get_Deep()", "code": "{\n\t\n\tif (Serial3.available() > 0)\n\t{\n\t\tif (Serial3.read() == '*')\n\t\t{\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif (Serial3.available() > 0)\n\t\t\t\t{\n\n\t\t\t\t\tbuff[i] = Serial3.read() - 48;  //ASCII\u7801\u8f6c\u5316\u6210\u76f8\u5e94\u5b57\u7b26/\u6570\u5b57\n\t\t\t\t}\n\t\t\t}\n\t\t\ttempread = buff[0] * 1000\n\t\t\t\t+ buff[1] * 100\n\t\t\t\t+ buff[2] * 10\n\t\t\t\t+ buff[3];\n\t\t\tif (tempread<1000 || tempread>2000)   //0\uff5e1000 \u6216 2000+\n\t\t\t\treading_cm = reading_cm_last;\n\t\t\telse\n\t\t\t{\n\t\t\t\treading_cm = tempread - 1000;\n\t\t\t\treading_cm_last = reading_cm;      \n\t\t\t\t//Serial.println(reading_cm);      ///\u4e32\u53e3\u53d1\u9001\u6570\u636e\n\t\t\t}\t\t\n\t\t}\n\t\tdelay(10);\n\t}  \n}", "path": "ShiYanLou/MCU/arduino/project/yuying.c", "commit_date": "2018-10-10 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//SSD1963 \n//pwm:\u023c,0~100.\u053d\u053d.\n", "func_signal": "void LCD_SSD_BackLightSet(u8 pwm)", "code": "{\t\n\tLCD_WR_REG(0xBE);\t//PWM\n\tLCD_WR_DATA(0x05);\t//1PWM\u01b5\n\tLCD_WR_DATA(pwm*2.55);//2PWM\u057c\u0571\n\tLCD_WR_DATA(0x01);\t//3C\n\tLCD_WR_DATA(0xFF);\t//4D\n\tLCD_WR_DATA(0x00);\t//5E\n\tLCD_WR_DATA(0x00);\t//6F\n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "// end isr\n", "func_signal": "void setup()", "code": "{\n\tSerial.begin(9600);                       //\u4e32\u53e30  \u4e0b\u8f7d\u53e3\n\tSerial3.begin(9600);                      //\u4e32\u53e33  gps\u53e3\n  Serial2.begin(9600);                      //\u4e32\u53e32  mini \u53e3 \u6df1\u5ea6\u6570\u636e\n  \n\tChannel3.attach(8);\n\tChannel4.attach(9);\n\tChannel5.attach(10);\n   // Timer2 \u521d\u59cb\u5316 2ms\u5b9a\u65f6\u4e2d\u65ad\n  TCCR2A = 0x02;                             // DISABLE PWM ON DIGITAL PINS 3 AND 11, AND GO INTO CTC MODE\n  TCCR2B = 0x06;                             // DON'T FORCE COMPARE, 256 PRESCALER \n  OCR2A = 0X7C;                              // SET THE TOP OF THE COUNT TO 124 FOR 500Hz SAMPLE RATE\n  TIMSK2 = 0x02;                             // ENABLE INTERRUPT ON MATCH BETWEEN TIMER2 AND OCR2A\n  //sei();                                   // \u4f7f\u80fd\u5b9a\u65f6\u5668\u4e2d\u65ad    \n//\u663e\u793a\u5668\u521d\u59cb\u5316\n  myOLED.OLED_Init();\n  myOLED.OLED_Clear();\n//\u663e\u793a\u521d\u59cb\u83dc\u5355\n manu_st();\n manu_dyn();\n\twhile (!(Serial& Serial3))              //\u4e32\u53e30\u30013\u6ca1\u6253\u5f00\u65f6\uff0c\u4e00\u76f4\u5faa\u73af\n\t{\n\t\t;\n\t}\n\treading_cm = 0;\n\tWire.begin(0x70);\t\t\t\t\t                // \ufffdWire.begin(address)  \u521d\u59cb\u5316wire\u5e93 \uff0c\u5e76\u4e14\u52a0\u5165\u5230I2C\u7f51\u7edc\uff0c \u4ece\u673a\n\tWire.onRequest(requestEvent);\t          \t//\ufffd\ufffd\u6ce8\u518c\u4e3b\u673a\u901a\u77e5\u4ece\u673a\u4e0a\u4f20\u6570\u636e\u7684\u4e8b\u4ef6\ufffd\n\n \n // \u5916\u90e8\u4e2d\u65adattachInterrupt()\n\tattachInterrupt(Key_Mode\t, Mode_Intpr, FALLING);  //attachInterrupt(interrupt, ISR, mode)            \u6a21\u5f0f\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\n\tattachInterrupt(Key_Arm\t\t, Arm_Intpr, FALLING);   //attachInterrupt(\u4e2d\u65ad\u53f7\uff0c\u4e2d\u65ad\u670d\u52a1\u51fd\u6570, \u4e2d\u65ad\u6a21\u5f0f)  \u89e3\u9501\u6a21\u5f0f\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\n\tattachInterrupt(Key_Up\t\t, Up_Intpr, FALLING);    //\u4e2d\u65ad\u670d\u52a1\u51fd\u6570,\u8fd9\u4e2a\u51fd\u6570\u5fc5\u987b\u6ca1\u6709\u53c2\u6570\u6ca1\u6709\u8fd4\u56de\u503c\uff1b    \u6cb9\u95e8\u589e\u52a0\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\n\tattachInterrupt(Key_Dowm\t, Dowm_Intpr, FALLING);  //                                                 \u6cb9\u95e8\u51cf\u5c11\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\n\n // MsTimer2::set(100,turnback);                     // \u4e2d\u65ad\u8bbe\u7f6e\u51fd\u6570\uff0c\u6bcf 5000ms \u8fdb\u5165\u4e00\u6b21\u4e2d\u65ad \n \n//mode:\u5b9a\u4e49\u4e2d\u65ad\u89e6\u53d1\u7c7b\u578b\uff0c\u6709\u56db\u79cd\u5f62\u5f0f\uff1a\n// LOW\uff1a\u4f4e\u7535\u5e73\u89e6\u53d1\uff1b\n// CHANGE\uff1a\u7535\u5e73\u53d8\u5316\u89e6\u53d1\uff1b\n// RISING \uff1a\u4e0a\u5347\u6cbf\u89e6\u53d1\uff08\u7531LOW\u53d8\u4e3aHIGH\uff09\uff1b\n// FALLING\uff1a\u4e0b\u964d\u6cbf\u89e6\u53d1\uff08\u7531HIGH\u53d8\u4e3aLOW\uff09\uff1b \n// Due\u677f\u5b50\u8fd8\u652f\u6301\u9ad8\u7535\u5e73\u89e6\u53d1\u3002\n//detachInterrupt(interrupt)\uff1b \u53ef\u4ee5\u5173\u6389\u4e2d\u65ad\n\n}", "path": "ShiYanLou/MCU/arduino/project/yuying.c", "commit_date": "2018-10-10 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//m^n\n//\u05b5:m^n\u03b7.\n", "func_signal": "u32 LCD_Pow(u8 m,u8 n)", "code": "{\n\tu32 result=1;\t \n\twhile(n--)result*=m;    \n\treturn result;\n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\u6cb9\u95e8\u589e\u52a0\u6309\u952e\u4e2d\u65ad\n", "func_signal": "void Up_Intpr()", "code": "{\n  delay(1000);\n  if(digitalRead(19)==0)\n  {\n\t//Serial.println(\"Interrupt Up 19\");\n\n\tThroat += 10;\n\tif (Throat < 121)\n\t{\n\t\tChannel3.write(Throat);\n\t}\n\telse\n\t{\n\t\tThroat = 120;\n\t\tChannel3.write(Throat);\n\t}\n\tdelay(100);\n //Serial.println(Throat);\n  }\n}", "path": "ShiYanLou/MCU/arduino/project/yuying.c", "commit_date": "2018-10-10 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\u03bb\u02bdPID\u3de8\n", "func_signal": "void POSITION_PID(ptCtrl ptCtrlCar, int CurrentSpeed)", "code": "{\n\t                         // \u05b5  -               \u05b5     -(10000 ~ 10000)   500\u05ea/ * 19 \n\tptCtrlCar->s16error[0] = ptCtrlCar->s16speedwant - (float) CurrentSpeed;\n\t\n\t//printf(\"ptCtrlCar->s16ErrorSum =  %f\\r\\n\",ptCtrlCar->s16ErrorSum);\t\t\n\tptCtrlCar->s16speedout = ptCtrlCar->s16speed_p*ptCtrlCar->s16error[0] \n\t\t\t\t\t\t\t+ ptCtrlCar->s16speed_d*(ptCtrlCar->s16error[0] - ptCtrlCar->s16error[1])\n\t\t\t\t\t\t\t+ ptCtrlCar->s16speed_i*ptCtrlCar->s16ErrorSum;\n\t\n\tptCtrlCar->s16error[1] = ptCtrlCar->s16error[0];//\u03f4\t\n\tptCtrlCar->s16error[2] = ptCtrlCar->s16error[1];//\u03f4\t\n\tptCtrlCar->s16ErrorSum += ptCtrlCar->s16error[0];\n\t\n\tabs_limit(&(ptCtrlCar->s16speedout), MAX_Carrent_out);//\u07b7\n\t\n}", "path": "ShiYanLou/MCU/stm32/STM32_Can_2_Serial/control.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//interrupt5 p18\u53e3 \u6cb9\u95e8\u51cf\u5c11\n//int Key_Low = 5;\n", "func_signal": "void vol_cur_acqu()", "code": "{\n   long int vale1=0,vale2=0,cur=0,val=0;\n    vale1 = analogRead(bet_voltage_pin); \n    vale2 = analogRead(bet_current_pin);\n     cur=500*vale1/335+1; \n     val=110*vale2/245;\n   // Serial.println(cur); \n   // Serial.println(val); \n    vol_integer = val/10;\n    vol_decimal = val%10;\n    cur_integer = cur/10;\n    cur_decimal = cur%10;\n    }\nvoid manu_st()\n{\n  //\u5217(0\uff5e),\u884c(0\uff5e),\u5b57\u7b26\u4e32(\u82f1\u6587),\u5b57\u4f53\u5927\u5c0f\n  myOLED.OLED_ShowString(0,1,\"SW:\",12);\n  myOLED.OLED_ShowString(65,1,\"MO:\",12);\n  myOLED.OLED_ShowString(0,2,\"TH:\",12);\n  myOLED.OLED_ShowString(65,2,\"HI:\",12);\n  myOLED.OLED_ShowString(0,3,\"VA:\",12);\n  myOLED.OLED_ShowString(65,3,\"CU:\",12);\n  myOLED.OLED_ShowString(0,4,\"LOCATION:\",12); \n  }\n\n  void manu_dyn()\n  {\n    if(Flag_Arm==0)\n       myOLED.OLED_ShowString(25,1,\"OFF\",12);\n   else\n   myOLED.OLED_ShowString(25,1,\"ON \",12);   \n     \n    if(Flag_Mode==0)\n        myOLED.OLED_ShowString(90,1,\"AUTO\",12);\n    else\n       myOLED.OLED_ShowString(90,1,\"HOLD\",12);\n       \n     myOLED.OLED_ShowString(25,2,\"   \",12);  \n     myOLED.OLED_Showint(25,2,Throat,12);\n    // myOLED.OLED_ShowNum(25,2,Throat,16);\n     \n     myOLED.OLED_ShowString(90,2,\"   \",12);  \n    myOLED.OLED_Showint(90,2,reading_cm,12);\n   \n    // vol_integer=11;\n     //vol_decimal=2;\n         myOLED.OLED_Showint(25,3,vol_integer,12);\n    myOLED.OLED_ShowString(40,3,\".\",12);\n    myOLED.OLED_Showint(45,3,vol_decimal,12);\n    \n    //cur_integer=50;\n    //cur_decimal=3;\n    myOLED.OLED_Showint(90,3,cur_integer,12);\n    myOLED.OLED_ShowString(106,3,\".\",12);\n    myOLED.OLED_Showint(111,3,cur_decimal,12);  \n   // myOLED.OLED_ShowString(25,3,\"(133,44)\",12); \n   myOLED.OLED_ShowString(65,3,\"CU:\",12);\n   myOLED.OLED_ShowString(0,4,\"LOCATION:\",12); \n  if(myGPS.read()&&(!myGPS.gpsAvailable()))\n  {\n    myOLED.OLED_ShowString(0,5,myGPS.gpsp[3],12);\n    myOLED.OLED_ShowString(0,6,myGPS.gpsp[4],12);\n  }\n  else    \n  {\n    myOLED.OLED_ShowString(0,6,\"GPS unavailable\",12);\n    myOLED.OLED_ShowString(0,5,\"GPS unavailable\",12);\n  }\n  }\n//2ms\u4e2d\u65ad\u5904\u7406\u51fd\u6570\nISR(TIMER2_COMPA_vect){                      // triggered when Timer2 counts to 124\naaa++;\nbbb++;\nccc++;\nif(aaa==time_5s)\n{\n   dir = 93;\n   Channel4.write(dir);  // \n  // Serial.println(dir); \n  //cli();                                     // \u5173\u95ed\u5b9a\u65f6\u5668\u4e2d\u65ad\n   aaa=0;\n  }\n\n //\u663e\u793a\u5237\u65b0\u6807\u5fd7\nif(bbb==time_disp)\n{ \n  dispay=true;\n  bbb=0; \n }\n//\u663e\u793a\u6e05\u5c4f\u6807\u5fd7\nif(ccc==time_10s)\n{\n  clear_flag =true;\n  ccc=0; \n }\n \n // sei();                                   // \u518d\u6b21\u4f7f\u80fd\u5b9a\u65f6\u5668\u4e2d\u65ad\uff0c\u5f00\u542f\u91c7\u96c6\n}", "path": "ShiYanLou/MCU/arduino/project/yuying.c", "commit_date": "2018-10-10 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\u00f9\u03bb\n//Xpos:\n//Ypos:\n", "func_signal": "void LCD_SetCursor(u16 Xpos, u16 Ypos)", "code": "{\t \n \tif(lcddev.id==0X9341||lcddev.id==0X5310)\n\t{\t\t    \n\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\tLCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF); \t\t\t \n\t\tLCD_WR_REG(lcddev.setycmd); \n\t\tLCD_WR_DATA(Ypos>>8);LCD_WR_DATA(Ypos&0XFF); \t\t\n\t}else if(lcddev.id==0X6804)\n\t{\n\t\tif(lcddev.dir==1)Xpos=lcddev.width-1-Xpos;//\u02b1\n\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\tLCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF); \n\t\tLCD_WR_REG(lcddev.setycmd); \n\t\tLCD_WR_DATA(Ypos>>8);LCD_WR_DATA(Ypos&0XFF); \n\t}else if(lcddev.id==0X1963)\n\t{  \t\t\t \t\t\n\t\tif(lcddev.dir==0)//x\u04aa\u4efb\n\t\t{\n\t\t\tXpos=lcddev.width-1-Xpos;\n\t\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\t\tLCD_WR_DATA(0);LCD_WR_DATA(0); \t\t\n\t\t\tLCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF);\t\t \t \n\t\t}else\n\t\t{\n\t\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\t\tLCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF); \t\t\n\t\t\tLCD_WR_DATA((lcddev.width-1)>>8);LCD_WR_DATA((lcddev.width-1)&0XFF);\t\t \t \t\t\t\n\t\t}\t\n\t\tLCD_WR_REG(lcddev.setycmd); \n\t\tLCD_WR_DATA(Ypos>>8);LCD_WR_DATA(Ypos&0XFF); \t\t\n\t\tLCD_WR_DATA((lcddev.height-1)>>8);LCD_WR_DATA((lcddev.height-1)&0XFF); \t\t\t \t\t\n\t\t\n\t}else if(lcddev.id==0X5510)\n\t{\n\t\tLCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(Xpos>>8); \t\t\n\t\tLCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(Xpos&0XFF);\t\t\t \n\t\tLCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(Ypos>>8);  \t\t\n\t\tLCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(Ypos&0XFF);\t\t\t\n\t}else\n\t{\n\t\tif(lcddev.dir==1)Xpos=lcddev.width-1-Xpos;//\u02b5\u01f5\u05eax,y\n\t\tLCD_WriteReg(lcddev.setxcmd, Xpos);\n\t\tLCD_WriteReg(lcddev.setycmd, Ypos);\n\t}\t \n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\n//x,y:\n//POINT_COLOR:\u02f5\u026b\n", "func_signal": "void LCD_DrawPoint(u16 x,u16 y)", "code": "{\n\tLCD_SetCursor(x,y);\t\t//\u00f9\u03bb \n\tLCD_WriteRAM_Prepare();\t//\u02bc\u0434GRAM\n\tLCD->LCD_RAM=POINT_COLOR; \n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\t  \n//(x1,y1),(x2,y2):\u03b5\u0136\u053d\n", "func_signal": "void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2)", "code": "{\n\tLCD_DrawLine(x1,y1,x2,y1);\n\tLCD_DrawLine(x1,y1,x1,y2);\n\tLCD_DrawLine(x1,y2,x2,y2);\n\tLCD_DrawLine(x2,y1,x2,y2);\n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\n//x1,y1:\n//x2,y2:\u0575  \n", "func_signal": "void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)", "code": "{\n\tu16 t; \n\tint xerr=0,yerr=0,delta_x,delta_y,distance; \n\tint incx,incy,uRow,uCol; \n\tdelta_x=x2-x1; // \n\tdelta_y=y2-y1; \n\tuRow=x1; \n\tuCol=y1; \n\tif(delta_x>0)incx=1; //\u00f5 \n\telse if(delta_x==0)incx=0;//\u05b1 \n\telse {incx=-1;delta_x=-delta_x;} \n\tif(delta_y>0)incy=1; \n\telse if(delta_y==0)incy=0;//\u02ee\u01bd \n\telse{incy=-1;delta_y=-delta_y;} \n\tif( delta_x>delta_y)distance=delta_x; //\u0461\u0221 \n\telse distance=delta_y; \n\tfor(t=0;t<=distance+1;t++ )// \n\t{  \n\t\tLCD_DrawPoint(uRow,uCol);// \n\t\txerr+=delta_x ; \n\t\tyerr+=delta_y ; \n\t\tif(xerr>distance) \n\t\t{ \n\t\t\txerr-=distance; \n\t\t\tuRow+=incx; \n\t\t} \n\t\tif(yerr>distance) \n\t\t{ \n\t\t\tyerr-=distance; \n\t\t\tuCol+=incy; \n\t\t} \n\t}  \n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\u02be,\u03bb\u03aa0,\u02be\n//x,y :\t \n//len :\u05b5\u03bb\n//size:\u0421\n//color:\u026b \n//num:\u05b5(0~4294967295);\t \n", "func_signal": "void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len,u8 size)", "code": "{         \t\n\tu8 t,temp;\n\tu8 enshow=0;\t\t\t\t\t\t   \n\tfor(t=0;t<len;t++)\n\t{\n\t\ttemp=(num/LCD_Pow(10,len-t-1))%10;\n\t\tif(enshow==0&&t<(len-1))\n\t\t{\n\t\t\tif(temp==0)\n\t\t\t{\n\t\t\t\tLCD_ShowChar(x+(size/2)*t,y,' ',size,0);\n\t\t\t\tcontinue;\n\t\t\t}else enshow=1; \n\t\t \t \n\t\t}\n\t \tLCD_ShowChar(x+(size/2)*t,y,temp+'0',size,0); \n\t}\n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//LCD\n//\u05b5:\u05b5\n", "func_signal": "u16 LCD_RD_DATA(void)", "code": "{\n\tvu16 ram;\t\t\t//\u05b9\u017b\n\tram=LCD->LCD_RAM;\t\n\treturn ram;\t \n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\u05b8\u03bb\u00fb\u04bb\u05b8\u0421\u0532\n//(x,y):\u0135\n//r    :\ubfb6\n", "func_signal": "void LCD_Draw_Circle(u16 x0,u16 y0,u8 r)", "code": "{\n\tint a,b;\n\tint di;\n\ta=0;b=r;\t  \n\tdi=3-(r<<1);             //\u0436\u00b8\u03bb\u00f5\u0131\u05be\n\twhile(a<=b)\n\t{\n\t\tLCD_DrawPoint(x0+a,y0-b);             //5\n \t\tLCD_DrawPoint(x0+b,y0-a);             //0           \n\t\tLCD_DrawPoint(x0+b,y0+a);             //4               \n\t\tLCD_DrawPoint(x0+a,y0+b);             //6 \n\t\tLCD_DrawPoint(x0-a,y0+b);             //1       \n \t\tLCD_DrawPoint(x0-b,y0+a);             \n\t\tLCD_DrawPoint(x0-a,y0-b);             //2             \n  \t\tLCD_DrawPoint(x0-b,y0-a);             //7     \t         \n\t\ta++;\n\t\t//\u02b9Bresenham\u3de8\u0532     \n\t\tif(di<0)di +=4*a+6;\t  \n\t\telse\n\t\t{\n\t\t\tdi+=10+4*(a-b);   \n\t\t\tb--;\n\t\t} \t\t\t\t\t\t    \n\t}\n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\u067b\n//x,y:\n//color:\u026b\n", "func_signal": "void LCD_Fast_DrawPoint(u16 x,u16 y,u16 color)", "code": "{\t   \n\tif(lcddev.id==0X9341||lcddev.id==0X5310)\n\t{\n\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\tLCD_WR_DATA(x>>8);LCD_WR_DATA(x&0XFF);  \t\t\t \n\t\tLCD_WR_REG(lcddev.setycmd); \n\t\tLCD_WR_DATA(y>>8);LCD_WR_DATA(y&0XFF); \t\t \t \n\t}else if(lcddev.id==0X5510)\n\t{\n\t\tLCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(x>>8);  \n\t\tLCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(x&0XFF);\t  \n\t\tLCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(y>>8);  \n\t\tLCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(y&0XFF); \n\t}else if(lcddev.id==0X1963)\n\t{\n\t\tif(lcddev.dir==0)x=lcddev.width-1-x;\n\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\tLCD_WR_DATA(x>>8);LCD_WR_DATA(x&0XFF); \t\t\n\t\tLCD_WR_DATA(x>>8);LCD_WR_DATA(x&0XFF); \t\t\n\t\tLCD_WR_REG(lcddev.setycmd); \n\t\tLCD_WR_DATA(y>>8);LCD_WR_DATA(y&0XFF); \t\t\n\t\tLCD_WR_DATA(y>>8);LCD_WR_DATA(y&0XFF); \t\t\n\t}else if(lcddev.id==0X6804)\n\t{\t\t    \n\t\tif(lcddev.dir==1)x=lcddev.width-1-x;//\u02b1\n\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\tLCD_WR_DATA(x>>8);LCD_WR_DATA(x&0XFF);\t\t\t \n\t\tLCD_WR_REG(lcddev.setycmd); \n\t\tLCD_WR_DATA(y>>8);LCD_WR_DATA(y&0XFF); \t\t\n\t}else\n\t{\n \t\tif(lcddev.dir==1)x=lcddev.width-1-x;//\u02b5\u01f5\u05eax,y\n\t\tLCD_WriteReg(lcddev.setxcmd,x);\n\t\tLCD_WriteReg(lcddev.setycmd,y);\n\t}\t\t\t \n\tLCD->LCD_REG=lcddev.wramcmd; \n\tLCD->LCD_RAM=color; \n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//LCD\u0631\u02be\n", "func_signal": "void LCD_DisplayOff(void)", "code": "{\t   \n\tif(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)LCD_WR_REG(0X28);\t//\u0631\u02be\n\telse if(lcddev.id==0X5510)LCD_WR_REG(0X2800);\t//\u0631\u02be\n\telse LCD_WriteReg(0X07,0x0);//\u0631\u02be \n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//LCD\u02be\n//dir:0,1,\n", "func_signal": "void LCD_Display_Dir(u8 dir)", "code": "{\n\tif(dir==0)\t\t\t//\n\t{\n\t\tlcddev.dir=0;\t//\n\t\tlcddev.width=240;\n\t\tlcddev.height=320;\n\t\tif(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310)\n\t\t{\n\t\t\tlcddev.wramcmd=0X2C;\n\t \t\tlcddev.setxcmd=0X2A;\n\t\t\tlcddev.setycmd=0X2B;  \t \n\t\t\tif(lcddev.id==0X6804||lcddev.id==0X5310)\n\t\t\t{\n\t\t\t\tlcddev.width=320;\n\t\t\t\tlcddev.height=480;\n\t\t\t}\n\t\t}else if(lcddev.id==0x5510)\n\t\t{\n\t\t\tlcddev.wramcmd=0X2C00;\n\t \t\tlcddev.setxcmd=0X2A00;\n\t\t\tlcddev.setycmd=0X2B00; \n\t\t\tlcddev.width=480;\n\t\t\tlcddev.height=800;\n\t\t}else if(lcddev.id==0X1963)\n\t\t{\n\t\t\tlcddev.wramcmd=0X2C;\t//\u0434GRAM\u05b8 \n\t\t\tlcddev.setxcmd=0X2B;\t//\u0434X\u05b8\n\t\t\tlcddev.setycmd=0X2A;\t//\u0434Y\u05b8\n\t\t\tlcddev.width=480;\t\t//\u00ff480\n\t\t\tlcddev.height=800;\t\t//\u00f8\u07f6800  \n\t\t}else\n\t\t{\n\t\t\tlcddev.wramcmd=0X22;\n\t \t\tlcddev.setxcmd=0X20;\n\t\t\tlcddev.setycmd=0X21;  \n\t\t}\n\t}else \t\t\t\t//\n\t{\t  \t\t\t\t\n\t\tlcddev.dir=1;\t//\n\t\tlcddev.width=320;\n\t\tlcddev.height=240;\n\t\tif(lcddev.id==0X9341||lcddev.id==0X5310)\n\t\t{\n\t\t\tlcddev.wramcmd=0X2C;\n\t \t\tlcddev.setxcmd=0X2A;\n\t\t\tlcddev.setycmd=0X2B;  \t \n\t\t}else if(lcddev.id==0X6804)\t \n\t\t{\n \t\t\tlcddev.wramcmd=0X2C;\n\t \t\tlcddev.setxcmd=0X2B;\n\t\t\tlcddev.setycmd=0X2A; \n\t\t}else if(lcddev.id==0x5510)\n\t\t{\n\t\t\tlcddev.wramcmd=0X2C00;\n\t \t\tlcddev.setxcmd=0X2A00;\n\t\t\tlcddev.setycmd=0X2B00; \n\t\t\tlcddev.width=800;\n\t\t\tlcddev.height=480;\n\t\t}else if(lcddev.id==0X1963)\n\t\t{\n\t\t\tlcddev.wramcmd=0X2C;\t//\u0434GRAM\u05b8 \n\t\t\tlcddev.setxcmd=0X2A;\t//\u0434X\u05b8\n\t\t\tlcddev.setycmd=0X2B;\t//\u0434Y\u05b8\n\t\t\tlcddev.width=800;\t\t//\u00ff800\n\t\t\tlcddev.height=480;\t\t//\u00f8\u07f6480  \n\t\t}else\n\t\t{\n\t\t\tlcddev.wramcmd=0X22;\n\t \t\tlcddev.setxcmd=0X21;\n\t\t\tlcddev.setycmd=0X20;  \n\t\t}\n\t\tif(lcddev.id==0X6804||lcddev.id==0X5310)\n\t\t{ \t \n\t\t\tlcddev.width=480;\n\t\t\tlcddev.height=320; \t\t\t\n\t\t}\n\t} \n\tLCD_Scan_Dir(DFT_SCAN_DIR);\t//\u012c\u0268\u8dfd\n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\u05b8\u03bb\u02be\u04bb\u05b7\n//x,y:\u02bc\n//num:\u04aa\u02be\u05b7:\" \"--->\"~\"\n//size:\u0421 12/16/24\n//mode:\u04f7\u02bd(1)\u01f7\u01f5\u04f7\u02bd(0)\n", "func_signal": "void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)", "code": "{  \t\t\t\t\t\t\t  \n    u8 temp,t1,t;\n\tu16 y0=y;\n\tu8 csize=(size/8+((size%8)?1:0))*(size/2);\t\t//\u00f5\u04bb\u05b7\u04e6\u057c\u05bd\t\n \tnum=num-' ';//\u00f5\u01ab\u01ba\u05b5ASCII\u05bf\u01f4\u04ff\u0578\u02bc\u0221\u0123-' '\u01f6\u04e6\u05b7\u05bf\u28e9\n\tfor(t=0;t<csize;t++)\n\t{   \n\t\tif(size==12)temp=asc2_1206[num][t]; \t \t//1206\n\t\telse if(size==16)temp=asc2_1608[num][t];\t//1608\n\t\telse if(size==24)temp=asc2_2412[num][t];\t//2412\n\t\telse return;\t\t\t\t\t\t\t\t//\u00fb\u0435\u05bf\n\t\tfor(t1=0;t1<8;t1++)\n\t\t{\t\t\t    \n\t\t\tif(temp&0x80)LCD_Fast_DrawPoint(x,y,POINT_COLOR);\n\t\t\telse if(mode==0)LCD_Fast_DrawPoint(x,y,BACK_COLOR);\n\t\t\ttemp<<=1;\n\t\t\ty++;\n\t\t\tif(y>=lcddev.height)return;\t\t//\n\t\t\tif((y-y0)==size)\n\t\t\t{\n\t\t\t\ty=y0;\n\t\t\t\tx++;\n\t\t\t\tif(x>=lcddev.width)return;\t//\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}  \t \n\t}  \t    \t   \t \t  \n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//LCD\u0536\u0268\u8dfd\n//\u05e2:\u073b\u0735\u02fa\u00f5\u04f0(9341/6804),\n//,\u04bb\u03aaL2R_U2D,\u03aa\u0268\u8dfd\u02bd,\u0735\u02be.\n//dir:0~7,8(\u5da8lcd.h)\n//9320/9325/9328/4531/4535/1505/b505/5408/9341/5310/5510/1963IC\u047e\u02b5\u02b2\t   \t   \n", "func_signal": "void LCD_Scan_Dir(u8 dir)", "code": "{\n\tu16 regval=0;\n\tu16 dirreg=0;\n\tu16 temp;  \n\tif((lcddev.dir==1&&lcddev.id!=0X6804&&lcddev.id!=0X1963)||(lcddev.dir==0&&lcddev.id==0X1963))//\u02b168041963\u0131\u0268\u8dfd\u02b11963\u0131\u4dfd\n\t{\t\t\t   \n\t\tswitch(dir)//\u05ea\n\t\t{\n\t\t\tcase 0:dir=6;break;\n\t\t\tcase 1:dir=7;break;\n\t\t\tcase 2:dir=4;break;\n\t\t\tcase 3:dir=5;break;\n\t\t\tcase 4:dir=1;break;\n\t\t\tcase 5:dir=0;break;\n\t\t\tcase 6:dir=3;break;\n\t\t\tcase 7:dir=2;break;\t     \n\t\t}\n\t} \n\tif(lcddev.id==0x9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X5510||lcddev.id==0X1963)//9341/6804/5310/5510/1963,\u2d26\n\t{\n\t\tswitch(dir)\n\t\t{\n\t\t\tcase L2R_U2D://,\u03f5\n\t\t\t\tregval|=(0<<7)|(0<<6)|(0<<5); \n\t\t\t\tbreak;\n\t\t\tcase L2R_D2U://,\u00b5\n\t\t\t\tregval|=(1<<7)|(0<<6)|(0<<5); \n\t\t\t\tbreak;\n\t\t\tcase R2L_U2D://\u04b5,\u03f5\n\t\t\t\tregval|=(0<<7)|(1<<6)|(0<<5); \n\t\t\t\tbreak;\n\t\t\tcase R2L_D2U://\u04b5,\u00b5\n\t\t\t\tregval|=(1<<7)|(1<<6)|(0<<5); \n\t\t\t\tbreak;\t \n\t\t\tcase U2D_L2R://\u03f5,\n\t\t\t\tregval|=(0<<7)|(0<<6)|(1<<5); \n\t\t\t\tbreak;\n\t\t\tcase U2D_R2L://\u03f5,\u04b5\n\t\t\t\tregval|=(0<<7)|(1<<6)|(1<<5); \n\t\t\t\tbreak;\n\t\t\tcase D2U_L2R://\u00b5,\n\t\t\t\tregval|=(1<<7)|(0<<6)|(1<<5); \n\t\t\t\tbreak;\n\t\t\tcase D2U_R2L://\u00b5,\u04b5\n\t\t\t\tregval|=(1<<7)|(1<<6)|(1<<5); \n\t\t\t\tbreak;\t \n\t\t}\n\t\tif(lcddev.id==0X5510)dirreg=0X3600;\n\t\telse dirreg=0X36;\n \t\tif((lcddev.id!=0X5310)&&(lcddev.id!=0X5510)&&(lcddev.id!=0X1963))regval|=0X08;//5310/5510/1963\u04aaBGR   \n\t\tif(lcddev.id==0X6804)regval|=0x02;//6804BIT69341\u0137\t   \n\t\tLCD_WriteReg(dirreg,regval);\n\t\tif(lcddev.id!=0X1963)//1963\uad26\n\t\t{\n\t\t\tif(regval&0X20)\n\t\t\t{\n\t\t\t\tif(lcddev.width<lcddev.height)//X,Y\n\t\t\t\t{\n\t\t\t\t\ttemp=lcddev.width;\n\t\t\t\t\tlcddev.width=lcddev.height;\n\t\t\t\t\tlcddev.height=temp;\n\t\t\t\t}\n\t\t\t}else  \n\t\t\t{\n\t\t\t\tif(lcddev.width>lcddev.height)//X,Y\n\t\t\t\t{\n\t\t\t\t\ttemp=lcddev.width;\n\t\t\t\t\tlcddev.width=lcddev.height;\n\t\t\t\t\tlcddev.height=temp;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t\tif(lcddev.id==0X5510)\n\t\t{\n\t\t\tLCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(0); \n\t\t\tLCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(0); \n\t\t\tLCD_WR_REG(lcddev.setxcmd+2);LCD_WR_DATA((lcddev.width-1)>>8); \n\t\t\tLCD_WR_REG(lcddev.setxcmd+3);LCD_WR_DATA((lcddev.width-1)&0XFF); \n\t\t\tLCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(0); \n\t\t\tLCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(0); \n\t\t\tLCD_WR_REG(lcddev.setycmd+2);LCD_WR_DATA((lcddev.height-1)>>8); \n\t\t\tLCD_WR_REG(lcddev.setycmd+3);LCD_WR_DATA((lcddev.height-1)&0XFF);\n\t\t}else\n\t\t{\n\t\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\t\tLCD_WR_DATA(0);LCD_WR_DATA(0);\n\t\t\tLCD_WR_DATA((lcddev.width-1)>>8);LCD_WR_DATA((lcddev.width-1)&0XFF);\n\t\t\tLCD_WR_REG(lcddev.setycmd); \n\t\t\tLCD_WR_DATA(0);LCD_WR_DATA(0);\n\t\t\tLCD_WR_DATA((lcddev.height-1)>>8);LCD_WR_DATA((lcddev.height-1)&0XFF);  \n\t\t}\n  \t}else \n\t{\n\t\tswitch(dir)\n\t\t{\n\t\t\tcase L2R_U2D://,\u03f5\n\t\t\t\tregval|=(1<<5)|(1<<4)|(0<<3); \n\t\t\t\tbreak;\n\t\t\tcase L2R_D2U://,\u00b5\n\t\t\t\tregval|=(0<<5)|(1<<4)|(0<<3); \n\t\t\t\tbreak;\n\t\t\tcase R2L_U2D://\u04b5,\u03f5\n\t\t\t\tregval|=(1<<5)|(0<<4)|(0<<3);\n\t\t\t\tbreak;\n\t\t\tcase R2L_D2U://\u04b5,\u00b5\n\t\t\t\tregval|=(0<<5)|(0<<4)|(0<<3); \n\t\t\t\tbreak;\t \n\t\t\tcase U2D_L2R://\u03f5,\n\t\t\t\tregval|=(1<<5)|(1<<4)|(1<<3); \n\t\t\t\tbreak;\n\t\t\tcase U2D_R2L://\u03f5,\u04b5\n\t\t\t\tregval|=(1<<5)|(0<<4)|(1<<3); \n\t\t\t\tbreak;\n\t\t\tcase D2U_L2R://\u00b5,\n\t\t\t\tregval|=(0<<5)|(1<<4)|(1<<3); \n\t\t\t\tbreak;\n\t\t\tcase D2U_R2L://\u00b5,\u04b5\n\t\t\t\tregval|=(0<<5)|(0<<4)|(1<<3); \n\t\t\t\tbreak;\t \n\t\t} \n\t\tdirreg=0X03;\n\t\tregval|=1<<12; \n\t\tLCD_WriteReg(dirreg,regval);\n\t}\n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "//\u00f4,\u0536\u00fb\uad7d\u03fd(sx,sy).\n//sx,sy:\u02bc(\u03fd)\n//width,height:\u06bf\u023a\u0378\u07f6,0!!\n//\u0421:width*height. \n", "func_signal": "void LCD_Set_Window(u16 sx,u16 sy,u16 width,u16 height)", "code": "{    \n\tu8 hsareg,heareg,vsareg,veareg;\n\tu16 hsaval,heaval,vsaval,veaval; \n\tu16 twidth,theight;\n\ttwidth=sx+width-1;\n\ttheight=sy+height-1;\n\tif(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X6804||(lcddev.dir==1&&lcddev.id==0X1963))\n\t{\n\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\tLCD_WR_DATA(sx>>8); \n\t\tLCD_WR_DATA(sx&0XFF);\t \n\t\tLCD_WR_DATA(twidth>>8); \n\t\tLCD_WR_DATA(twidth&0XFF);  \n\t\tLCD_WR_REG(lcddev.setycmd); \n\t\tLCD_WR_DATA(sy>>8); \n\t\tLCD_WR_DATA(sy&0XFF); \n\t\tLCD_WR_DATA(theight>>8); \n\t\tLCD_WR_DATA(theight&0XFF); \n\t}else if(lcddev.id==0X1963)//1963\u2d26\n\t{\n\t\tsx=lcddev.width-width-sx; \n\t\theight=sy+height-1; \n\t\tLCD_WR_REG(lcddev.setxcmd); \n\t\tLCD_WR_DATA(sx>>8); \n\t\tLCD_WR_DATA(sx&0XFF);\t \n\t\tLCD_WR_DATA((sx+width-1)>>8); \n\t\tLCD_WR_DATA((sx+width-1)&0XFF);  \n\t\tLCD_WR_REG(lcddev.setycmd); \n\t\tLCD_WR_DATA(sy>>8); \n\t\tLCD_WR_DATA(sy&0XFF); \n\t\tLCD_WR_DATA(height>>8); \n\t\tLCD_WR_DATA(height&0XFF); \t\t\n\t}else if(lcddev.id==0X5510)\n\t{\n\t\tLCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(sx>>8);  \n\t\tLCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(sx&0XFF);\t  \n\t\tLCD_WR_REG(lcddev.setxcmd+2);LCD_WR_DATA(twidth>>8);   \n\t\tLCD_WR_REG(lcddev.setxcmd+3);LCD_WR_DATA(twidth&0XFF);   \n\t\tLCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(sy>>8);   \n\t\tLCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(sy&0XFF);  \n\t\tLCD_WR_REG(lcddev.setycmd+2);LCD_WR_DATA(theight>>8);   \n\t\tLCD_WR_REG(lcddev.setycmd+3);LCD_WR_DATA(theight&0XFF);  \n\t}else\t//IC\n\t{\n\t\tif(lcddev.dir==1)//\n\t\t{\n\t\t\t//\u05b5\n\t\t\thsaval=sy;\t\t\t\t\n\t\t\theaval=theight;\n\t\t\tvsaval=lcddev.width-twidth-1;\n\t\t\tveaval=lcddev.width-sx-1;\t\t\t\t\n\t\t}else\n\t\t{ \n\t\t\thsaval=sx;\t\t\t\t\n\t\t\theaval=twidth;\n\t\t\tvsaval=sy;\n\t\t\tveaval=theight;\n\t\t} \n\t\thsareg=0X50;heareg=0X51;//\u02ee\u01bd\uda93\udc3f\u06bc\u0134\n\t\tvsareg=0X52;veareg=0X53;//\u05b1\uda93\udc3f\u06bc\u0134\t   \t\t\t\t\t\t\t  \n\t\t//\u00fc\u0134\u05b5\n\t\tLCD_WriteReg(hsareg,hsaval);\n\t\tLCD_WriteReg(heareg,heaval);\n\t\tLCD_WriteReg(vsareg,vsaval);\n\t\tLCD_WriteReg(veareg,veaval);\t\t\n\t\tLCD_SetCursor(sx,sy);\t//\u00f9\u03bb\n\t}\n}", "path": "ShiYanLou/MCU/stm32/motor_driver_no_Pid/lcd.c", "commit_date": "2018-06-19 00:00:00", "repo_name": "Ewenwan/ShiYanLou", "stars": 2645, "license": "None", "language": "c", "size": 228130}
{"docstring": "/*\n * This type is implemented using PositiveReal,\n * so here we adjust the DEF accordingly.\n */\n/*\n * This type is implemented using NativeEnumerated,\n * so here we adjust the DEF accordingly.\n */\n", "func_signal": "static int\nduration_23_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key)", "code": "{\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\t\n\tif(1 /* No applicable constraints whatsoever */) {\n\t\t/* Nothing is here. See below */\n\t}\n\t\n\treturn td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);\n}", "path": "tcpkali/asn1/Start.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * This type is implemented using PositiveReal,\n * so here we adjust the DEF accordingly.\n */\n", "func_signal": "static int\ndelaySend_24_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key)", "code": "{\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\t\n\tif(1 /* No applicable constraints whatsoever */) {\n\t\t/* Nothing is here. See below */\n\t}\n\t\n\treturn td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);\n}", "path": "tcpkali/asn1/Start.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * This type is implemented using PositiveReal,\n * so here we adjust the DEF accordingly.\n */\n", "func_signal": "static int\nmessageRate_28_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key)", "code": "{\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\t\n\tif(1 /* No applicable constraints whatsoever */) {\n\t\t/* Nothing is here. See below */\n\t}\n\t\n\treturn td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);\n}", "path": "tcpkali/asn1/Start.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * The following functions functions offer protection against -fshort-enums,\n * compatible with little- and big-endian machines.\n * If assertion is triggered, either disable -fshort-enums, or add an entry\n * here with the ->pres_size of your target stracture.\n * Unless the target structure is packed, the \".present\" member\n * is guaranteed to be aligned properly. ASN.1 compiler itself does not\n * produce packed code.\n */\n", "func_signal": "static unsigned\n_fetch_present_idx(const void *struct_ptr, unsigned pres_offset,\n                   unsigned pres_size)", "code": "{\n    const void *present_ptr;\n\tunsigned present;\n\n\tpresent_ptr = ((const char *)struct_ptr) + pres_offset;\n\n\tswitch(pres_size) {\n\tcase sizeof(int):\tpresent = *(const unsigned int *)present_ptr; break;\n\tcase sizeof(short):\tpresent = *(const unsigned short *)present_ptr; break;\n\tcase sizeof(char):\tpresent = *(const unsigned char *)present_ptr; break;\n\tdefault:\n\t\t/* ANSI C mandates enum to be equivalent to integer */\n\t\tassert(pres_size != sizeof(int));\n\t\treturn 0;\t/* If not aborted, pass back safe value */\n\t}\n\n\treturn present;\n}", "path": "tcpkali/asn1/constr_CHOICE.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * This type is implemented using PositiveReal,\n * so here we adjust the DEF accordingly.\n */\n", "func_signal": "static int\nchannelLifetime_16_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key)", "code": "{\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\t\n\tif(1 /* No applicable constraints whatsoever */) {\n\t\t/* Nothing is here. See below */\n\t}\n\t\n\treturn td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);\n}", "path": "tcpkali/asn1/Start.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Fetch the length determinant (X.696 08/2015, #8.6) into *len_r.\n * RETURN VALUES:\n *       0:     More data expected than bufptr contains.\n *      -1:     Fatal error deciphering length.\n *      >0:     Number of bytes used from bufptr.\n */\n", "func_signal": "ssize_t\noer_fetch_length(const void *bufptr, size_t size, size_t *len_r)", "code": "{\n    uint8_t first_byte;\n    size_t len_len;    /* Length of the length determinant */\n    const uint8_t *b;\n    const uint8_t *bend;\n    size_t len;\n\n    if(size == 0) {\n        *len_r = 0;\n        return 0;\n    }\n\n    first_byte = *(const uint8_t *)bufptr;\n    if((first_byte & 0x80) == 0) {   /* Short form */\n        *len_r = first_byte; /* 0..127 */\n        return 1;\n    }\n\n    len_len = (first_byte & 0x7f);\n    if((1 + len_len) > size) {\n        *len_r = 0;\n        return 0;\n    }\n\n    b = (const uint8_t *)bufptr + 1;\n    bend = b + len_len;\n\n    for(; b < bend && *b == 0; b++) {\n        /* Skip the leading 0-bytes */\n    }\n\n    if((bend - b) > (ssize_t)sizeof(size_t)) {\n        /* Length is not representable by the native size_t type */\n        *len_r = 0;\n        return -1;\n    }\n\n    for(len = 0; b < bend; b++) {\n        len = (len << 8) + *b;\n    }\n\n    if(len > RSIZE_MAX) { /* A bit of C11 validation */\n        *len_r = 0;\n        return -1;\n    }\n\n    *len_r = len;\n    assert(len_len + 1 == (size_t)(bend - (const uint8_t *)bufptr));\n    return len_len + 1;\n}", "path": "tcpkali/asn1/oer_support.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * This type is implemented using PositiveReal,\n * so here we adjust the DEF accordingly.\n */\n", "func_signal": "static int\nchannelBandwidthUpstream_17_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key)", "code": "{\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\t\n\tif(1 /* No applicable constraints whatsoever */) {\n\t\t/* Nothing is here. See below */\n\t}\n\t\n\treturn td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);\n}", "path": "tcpkali/asn1/Start.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * The decoder of the CHOICE type.\n */\n", "func_signal": "asn_dec_rval_t\nCHOICE_decode_ber(const asn_codec_ctx_t *opt_codec_ctx,\n                  const asn_TYPE_descriptor_t *td, void **struct_ptr,\n                  const void *ptr, size_t size, int tag_mode)", "code": "{\n    /*\n\t * Bring closer parts of structure description.\n\t */\n\tconst asn_CHOICE_specifics_t *specs =\n\t\t(const asn_CHOICE_specifics_t *)td->specifics;\n\tasn_TYPE_member_t *elements = td->elements;\n\n\t/*\n\t * Parts of the structure being constructed.\n\t */\n\tvoid *st = *struct_ptr;\t/* Target structure. */\n\tasn_struct_ctx_t *ctx;\t/* Decoder context */\n\n\tber_tlv_tag_t tlv_tag;\t/* T from TLV */\n\tssize_t tag_len;\t/* Length of TLV's T */\n\tasn_dec_rval_t rval;\t/* Return code from subparsers */\n\n\tssize_t consumed_myself = 0;\t/* Consumed bytes from ptr */\n\n\tASN_DEBUG(\"Decoding %s as CHOICE\", td->name);\n\n\t/*\n\t * Create the target structure if it is not present already.\n\t */\n\tif(st == 0) {\n\t\tst = *struct_ptr = CALLOC(1, specs->struct_size);\n\t\tif(st == 0) {\n\t\t\tRETURN(RC_FAIL);\n\t\t}\n\t}\n\n\t/*\n\t * Restore parsing context.\n\t */\n\tctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);\n\t\n\t/*\n\t * Start to parse where left previously\n\t */\n\tswitch(ctx->phase) {\n\tcase 0:\n\t\t/*\n\t\t * PHASE 0.\n\t\t * Check that the set of tags associated with given structure\n\t\t * perfectly fits our expectations.\n\t\t */\n\n\t\tif(tag_mode || td->tags_count) {\n\t\t\trval = ber_check_tags(opt_codec_ctx, td, ctx, ptr, size,\n\t\t\t\ttag_mode, -1, &ctx->left, 0);\n\t\t\tif(rval.code != RC_OK) {\n\t\t\t\tASN_DEBUG(\"%s tagging check failed: %d\",\n\t\t\t\t\ttd->name, rval.code);\n\t\t\t\treturn rval;\n\t\t\t}\n\n\t\t\tif(ctx->left >= 0) {\n\t\t\t\t/* ?Substracted below! */\n\t\t\t\tctx->left += rval.consumed;\n\t\t\t}\n\t\t\tADVANCE(rval.consumed);\n\t\t} else {\n\t\t\tctx->left = -1;\n\t\t}\n\n\t\tNEXT_PHASE(ctx);\n\n\t\tASN_DEBUG(\"Structure consumes %ld bytes, buffer %ld\",\n\t\t\t(long)ctx->left, (long)size);\n\n\t\t/* Fall through */\n\tcase 1:\n\t\t/*\n\t\t * Fetch the T from TLV.\n\t\t */\n\t\ttag_len = ber_fetch_tag(ptr, LEFT, &tlv_tag);\n\t\tASN_DEBUG(\"In %s CHOICE tag length %d\", td->name, (int)tag_len);\n\t\tswitch(tag_len) {\n\t\tcase 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);\n\t\t\t/* Fall through */\n\t\tcase -1: RETURN(RC_FAIL);\n\t\t}\n\n\t\tdo {\n\t\t\tconst asn_TYPE_tag2member_t *t2m;\n\t\t\tasn_TYPE_tag2member_t key;\n\n\t\t\tkey.el_tag = tlv_tag;\n\t\t\tt2m = (const asn_TYPE_tag2member_t *)bsearch(&key,\n\t\t\t\t\tspecs->tag2el, specs->tag2el_count,\n\t\t\t\t\tsizeof(specs->tag2el[0]), _search4tag);\n\t\t\tif(t2m) {\n\t\t\t\t/*\n\t\t\t\t * Found the element corresponding to the tag.\n\t\t\t\t */\n\t\t\t\tNEXT_PHASE(ctx);\n\t\t\t\tctx->step = t2m->el_no;\n\t\t\t\tbreak;\n\t\t\t} else if(specs->ext_start == -1) {\n\t\t\t\tASN_DEBUG(\"Unexpected tag %s \"\n\t\t\t\t\t\"in non-extensible CHOICE %s\",\n\t\t\t\t\tber_tlv_tag_string(tlv_tag), td->name);\n\t\t\t\tRETURN(RC_FAIL);\n\t\t\t} else {\n\t\t\t\t/* Skip this tag */\n\t\t\t\tssize_t skip;\n\n\t\t\t\tASN_DEBUG(\"Skipping unknown tag %s\",\n\t\t\t\t\tber_tlv_tag_string(tlv_tag));\n\n\t\t\t\tskip = ber_skip_length(opt_codec_ctx,\n\t\t\t\t\tBER_TLV_CONSTRUCTED(ptr),\n\t\t\t\t\t(const char *)ptr + tag_len,\n\t\t\t\t\tLEFT - tag_len);\n\n\t\t\t\tswitch(skip) {\n\t\t\t\tcase 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);\n\t\t\t\t\t/* Fall through */\n\t\t\t\tcase -1: RETURN(RC_FAIL);\n\t\t\t\t}\n\n\t\t\t\tADVANCE(skip + tag_len);\n\t\t\t\tRETURN(RC_OK);\n\t\t\t}\n\t\t} while(0);\n\n\tcase 2:\n\t\t/*\n\t\t * PHASE 2.\n\t\t * Read in the element.\n\t\t */\n\t    do {\n\t\tasn_TYPE_member_t *elm;/* CHOICE's element */\n\t\tvoid *memb_ptr;\t\t/* Pointer to the member */\n\t\tvoid **memb_ptr2;\t/* Pointer to that pointer */\n\n\t\telm = &elements[ctx->step];\n\n\t\t/*\n\t\t * Compute the position of the member inside a structure,\n\t\t * and also a type of containment (it may be contained\n\t\t * as pointer or using inline inclusion).\n\t\t */\n\t\tif(elm->flags & ATF_POINTER) {\n\t\t\t/* Member is a pointer to another structure */\n\t\t\tmemb_ptr2 = (void **)((char *)st + elm->memb_offset);\n\t\t} else {\n\t\t\t/*\n\t\t\t * A pointer to a pointer\n\t\t\t * holding the start of the structure\n\t\t\t */\n\t\t\tmemb_ptr = (char *)st + elm->memb_offset;\n\t\t\tmemb_ptr2 = &memb_ptr;\n\t\t}\n\t\t/* Set presence to be able to free it properly at any time */\n\t\t_set_present_idx(st, specs->pres_offset,\n\t\t\t\tspecs->pres_size, ctx->step + 1);\n\t\t/*\n\t\t * Invoke the member fetch routine according to member's type\n\t\t */\n\t\trval = elm->type->op->ber_decoder(opt_codec_ctx, elm->type,\n\t\t\t\tmemb_ptr2, ptr, LEFT, elm->tag_mode);\n\t\tswitch(rval.code) {\n\t\tcase RC_OK:\n\t\t\tbreak;\n\t\tcase RC_WMORE: /* More data expected */\n\t\t\tif(!SIZE_VIOLATION) {\n\t\t\t\tADVANCE(rval.consumed);\n\t\t\t\tRETURN(RC_WMORE);\n\t\t\t}\n\t\t\tRETURN(RC_FAIL);\n\t\tcase RC_FAIL: /* Fatal error */\n\t\t\tRETURN(rval.code);\n\t\t} /* switch(rval) */\n\t\t\n\t\tADVANCE(rval.consumed);\n\t  } while(0);\n\n\t\tNEXT_PHASE(ctx);\n\n\t\t/* Fall through */\n\tcase 3:\n\t\tASN_DEBUG(\"CHOICE %s Leftover: %ld, size = %ld, tm=%d, tc=%d\",\n\t\t\ttd->name, (long)ctx->left, (long)size,\n\t\t\ttag_mode, td->tags_count);\n\n\t\tif(ctx->left > 0) {\n\t\t\t/*\n\t\t\t * The type must be fully decoded\n\t\t\t * by the CHOICE member-specific decoder.\n\t\t\t */\n\t\t\tRETURN(RC_FAIL);\n\t\t}\n\n\t\tif(ctx->left == -1\n\t\t&& !(tag_mode || td->tags_count)) {\n\t\t\t/*\n\t\t\t * This is an untagged CHOICE.\n\t\t\t * It doesn't contain nothing\n\t\t\t * except for the member itself, including all its tags.\n\t\t\t * The decoding is completed.\n\t\t\t */\n\t\t\tNEXT_PHASE(ctx);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Read in the \"end of data chunks\"'s.\n\t\t */\n\t\twhile(ctx->left < 0) {\n\t\t\tssize_t tl;\n\n\t\t\ttl = ber_fetch_tag(ptr, LEFT, &tlv_tag);\n\t\t\tswitch(tl) {\n\t\t\tcase 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);\n\t\t\t\t/* Fall through */\n\t\t\tcase -1: RETURN(RC_FAIL);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Expected <0><0>...\n\t\t\t */\n\t\t\tif(((const uint8_t *)ptr)[0] == 0) {\n\t\t\t\tif(LEFT < 2) {\n\t\t\t\t\tif(SIZE_VIOLATION)\n\t\t\t\t\t\tRETURN(RC_FAIL);\n\t\t\t\t\telse\n\t\t\t\t\t\tRETURN(RC_WMORE);\n\t\t\t\t} else if(((const uint8_t *)ptr)[1] == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Correctly finished with <0><0>.\n\t\t\t\t\t */\n\t\t\t\t\tADVANCE(2);\n\t\t\t\t\tctx->left++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tASN_DEBUG(\"Unexpected continuation in %s\",\n\t\t\t\t\ttd->name);\n\t\t\t\tRETURN(RC_FAIL);\n\t\t\t}\n\n\t\t\t/* UNREACHABLE */\n\t\t}\n\n\t\tNEXT_PHASE(ctx);\n\tcase 4:\n\t\t/* No meaningful work here */\n\t\tbreak;\n\t}\n\t\n\tRETURN(RC_OK);\n}", "path": "tcpkali/asn1/constr_CHOICE.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Add another element into the set.\n */\n", "func_signal": "int\nasn_set_add(void *asn_set_of_x, void *ptr)", "code": "{\n\tasn_anonymous_set_ *as = _A_SET_FROM_VOID(asn_set_of_x);\n\n\tif(as == 0 || ptr == 0) {\n\t\terrno = EINVAL;\t\t/* Invalid arguments */\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Make sure there's enough space to insert an element.\n\t */\n\tif(as->count == as->size) {\n\t\tint _newsize = as->size ? (as->size << 1) : 4;\n\t\tvoid *_new_arr;\n\t\t_new_arr = REALLOC(as->array, _newsize * sizeof(as->array[0]));\n\t\tif(_new_arr) {\n\t\t\tas->array = (void **)_new_arr;\n\t\t\tas->size = _newsize;\n\t\t} else {\n\t\t\t/* ENOMEM */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tas->array[as->count++] = ptr;\n\n\treturn 0;\n}", "path": "tcpkali/asn1/asn_SET_OF.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Serialize OER length. Returns the number of bytes serialized\n * or -1 if a given callback returned with negative result.\n */\n", "func_signal": "ssize_t\noer_serialize_length(size_t length, asn_app_consume_bytes_f *cb,\n                     void *app_key)", "code": "{\n    uint8_t scratch[1 + sizeof(length)];\n    uint8_t *sp = scratch;\n    int littleEndian = 1;   /* Run-time detection */\n    const uint8_t *pstart;\n    const uint8_t *pend;\n    const uint8_t *p;\n    int add;\n\n    if(length <= 127) {\n        uint8_t b = length;\n        if(cb(&b, 1, app_key) < 0) {\n            return -1;\n        }\n        return 1;\n    }\n\n    if(*(char *)&littleEndian) {\n        pstart = (const uint8_t *)&length + sizeof(length) - 1;\n        pend = (const uint8_t *)&length;\n        add = -1;\n    } else {\n        pstart = (const uint8_t *)&length;\n        pend = pstart + sizeof(length);\n        add = 1;\n    }\n\n    for(p = pstart; p != pend; p += add) {\n        /* Skip leading zeros. */\n        if(*p) break;\n    }\n\n    for(sp = scratch + 1; ; p += add) {\n        *sp++ = *p;\n        if(p == pend) break;\n    }\n    assert((sp - scratch) - 1 <= 0x7f);\n    scratch[0] = 0x80 + ((sp - scratch) - 1);\n\n    if(cb(scratch, sp - scratch, app_key) < 0) {\n        return -1;\n    }\n\n    return sp - scratch;\n}", "path": "tcpkali/asn1/oer_support.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * This type is implemented using PositiveReal,\n * so here we adjust the DEF accordingly.\n */\n", "func_signal": "static int\nconnectTimeout_15_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key)", "code": "{\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\t\n\tif(1 /* No applicable constraints whatsoever */) {\n\t\t/* Nothing is here. See below */\n\t}\n\t\n\treturn td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);\n}", "path": "tcpkali/asn1/Start.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * This type is implemented using PositiveReal,\n * so here we adjust the DEF accordingly.\n */\n", "func_signal": "static int\nchannelBandwidthDownstream_18_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key)", "code": "{\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\t\n\tif(1 /* No applicable constraints whatsoever */) {\n\t\t/* Nothing is here. See below */\n\t}\n\t\n\treturn td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);\n}", "path": "tcpkali/asn1/Start.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Return the 1-based choice variant presence index.\n * Returns 0 in case of error.\n */\n", "func_signal": "unsigned\nCHOICE_variant_get_presence(const asn_TYPE_descriptor_t *td, const void *sptr)", "code": "{\n    const asn_CHOICE_specifics_t *specs =\n        (const asn_CHOICE_specifics_t *)td->specifics;\n    return _fetch_present_idx(sptr, specs->pres_offset, specs->pres_size);\n}", "path": "tcpkali/asn1/constr_CHOICE.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Encode as Canonical OER\n */\n", "func_signal": "asn_enc_rval_t\nREAL_encode_oer(const asn_TYPE_descriptor_t *td,\n                const asn_oer_constraints_t *constraints, const void *sptr,\n                asn_app_consume_bytes_f *cb, void *app_key)", "code": "{\n    const REAL_t *st = sptr;\n    asn_enc_rval_t er;\n    ssize_t len_len;\n\n    if(!st || !st->buf || !td)\n        ASN__ENCODE_FAILED;\n\n    if(!constraints) constraints = td->encoding_constraints.oer_constraints;\n    if(constraints && constraints->value.width != 0) {\n        /* If we're constrained to a narrow float/double representation, we\n         * shouldn't have ended up using REAL. Expecting NativeReal. */\n        ASN__ENCODE_FAILED;\n    }\n\n    /* Encode a fake REAL */\n    len_len = oer_serialize_length(st->size, cb, app_key);\n    if(len_len < 0 || cb(st->buf, st->size, app_key) < 0) {\n        ASN__ENCODE_FAILED;\n    } else {\n        er.encoded = len_len + st->size;\n        ASN__ENCODED_OK(er);\n    }\n}", "path": "tcpkali/asn1/REAL.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/* Slow-ish. Avoid using in performance-critical code. */\n", "func_signal": "ssize_t\ntregex_eval(tregex *re, char *buf, size_t size)", "code": "{\n    pcg32_random_t rng;\n    pcg32_srandom_r(&rng, random(), 0);\n    return tregex_eval_rng(re, buf, size, &rng);\n}", "path": "tcpkali/src/tcpkali_regex.c", "commit_date": "2017-10-17 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Sets or resets the 1-based choice variant presence index.\n * In case a previous index is not zero, the currently selected structure\n * member is freed and zeroed-out first.\n * Returns 0 on success and -1 on error.\n */\n", "func_signal": "int\nCHOICE_variant_set_presence(const asn_TYPE_descriptor_t *td, void *sptr,\n                            unsigned present)", "code": "{\n    const asn_CHOICE_specifics_t *specs =\n        (const asn_CHOICE_specifics_t *)td->specifics;\n    unsigned old_present;\n\n    if(!sptr) {\n        return -1;\n    }\n\n    if(present > td->elements_count)\n        return -1;\n\n    old_present =\n        _fetch_present_idx(sptr, specs->pres_offset, specs->pres_size);\n    if(present == old_present)\n        return 0;\n\n    if(old_present != 0) {\n        assert(old_present <= td->elements_count);\n        ASN_STRUCT_RESET(*td, sptr);\n    }\n\n    _set_present_idx(sptr, specs->pres_offset, specs->pres_size, present);\n\n    return 0;\n}", "path": "tcpkali/asn1/constr_CHOICE.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Decode the chunk of XML text encoding REAL.\n */\n", "func_signal": "static enum xer_pbd_rval\nREAL__xer_body_decode(const asn_TYPE_descriptor_t *td, void *sptr,\n                      const void *chunk_buf, size_t chunk_size)", "code": "{\n    REAL_t *st = (REAL_t *)sptr;\n\tdouble value;\n\tconst char *xerdata = (const char *)chunk_buf;\n\tchar *endptr = 0;\n\tchar *b;\n\n\t(void)td;\n\n\tif(!chunk_size) return XPBD_BROKEN_ENCODING;\n\n\t/*\n\t * Decode an XMLSpecialRealValue: <MINUS-INFINITY>, etc.\n\t */\n\tif(xerdata[0] == 0x3c /* '<' */) {\n\t\tsize_t i;\n\t\tfor(i = 0; i < sizeof(specialRealValue)\n\t\t\t\t/ sizeof(specialRealValue[0]); i++) {\n\t\t\tstruct specialRealValue_s *srv = &specialRealValue[i];\n\t\t\tdouble dv;\n\n\t\t\tif(srv->length != chunk_size\n\t\t\t|| memcmp(srv->string, chunk_buf, chunk_size))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * It could've been done using\n\t\t\t * (double)srv->dv / real_zero,\n\t\t\t * but it summons fp exception on some platforms.\n\t\t\t */\n\t\t\tswitch(srv->dv) {\n\t\t\tcase -1: dv = - INFINITY; break;\n\t\t\tcase 0: dv = NAN;\tbreak;\n\t\t\tcase 1: dv = INFINITY;\tbreak;\n\t\t\tdefault: return XPBD_SYSTEM_FAILURE;\n\t\t\t}\n\n\t\t\tif(asn_double2REAL(st, dv))\n\t\t\t\treturn XPBD_SYSTEM_FAILURE;\n\n\t\t\treturn XPBD_BODY_CONSUMED;\n\t\t}\n\t\tASN_DEBUG(\"Unknown XMLSpecialRealValue\");\n\t\treturn XPBD_BROKEN_ENCODING;\n\t}\n\n\t/*\n\t * Copy chunk into the nul-terminated string, and run strtod.\n\t */\n\tb = (char *)MALLOC(chunk_size + 1);\n\tif(!b) return XPBD_SYSTEM_FAILURE;\n\tmemcpy(b, chunk_buf, chunk_size);\n\tb[chunk_size] = 0;\t/* nul-terminate */\n\n\tvalue = strtod(b, &endptr);\n\tFREEMEM(b);\n\tif(endptr == b) return XPBD_BROKEN_ENCODING;\n\n\tif(asn_double2REAL(st, value))\n\t\treturn XPBD_SYSTEM_FAILURE;\n\n\treturn XPBD_BODY_CONSUMED;\n}", "path": "tcpkali/asn1/REAL.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Detect WebSocket handshake.\n * A high performance, but extremely naive and broken implementation.\n * Normally a well-behaving client (or proxy) will attempt to send a whole HTTP\n * request in a single TCP fragment. In some cases, a header-per-fragment\n * is also something that naive clients do.\n * This function does not support HTTP headers split between frames arbitrarily,\n * which is not too common in the high performance code anyway.\n * TODO: replace with an efficient but more correct parser.\n */\n", "func_signal": "http_detect_websocket_rval\nhttp_detect_websocket(const char *buf, size_t size, char *out_buf,\n                      size_t out_buf_sz, size_t *response_size)", "code": "{\n    const char *keyhdr = \"sec-websocket-key:\";\n    size_t keyhdr_size = sizeof(\"sec-websocket-key:\") - 1;\n\n    /*\n     * Ignore the GET/Version completely, search right for Sec-WebSocket-Key.\n     */\n    for(const char *bend = buf + size; buf < bend; buf++) {\n        if(*buf != '\\n') {\n            continue;\n        } else {\n            buf++;\n            size_t buf_remainder = (bend - buf);\n            if(buf_remainder < keyhdr_size) {\n                return HDW_TRUNCATED_INPUT;\n            }\n\n            if(strncasecmp(buf, keyhdr, keyhdr_size) == 0) {\n                const char *keyvalue = buf + keyhdr_size;\n                int extent = bend - keyvalue;\n                if(extent > 30) extent = 30;\n                const char *kvend = memchr(keyvalue, '\\n', extent);\n                if(kvend == 0) {\n                    return HDW_TRUNCATED_INPUT;\n                }\n                /* ltrim */\n                for(; keyvalue < kvend && *keyvalue == ' '; keyvalue++)\n                    ;\n                /* rtrim */\n                for(; kvend > keyvalue && (kvend[-1] == ' ' || kvend[-1] == '\\r'\n                                           || kvend[-1] == ' ');\n                    kvend--)\n                    ;\n                int kvsize = kvend - keyvalue;\n                if(kvsize < 1 || kvsize > 26 /* 26 is in RFC6455 */)\n                    return HDW_UNEXPECTED_ERROR;\n\n                char new_key[64];\n                char sha1_buf[20];\n                char base64_output[32];\n                size_t new_key_size;\n#define MAGIC \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n                memcpy(new_key, keyvalue, kvsize);\n                strcpy(new_key + kvsize, MAGIC);\n                new_key_size = kvsize + sizeof(MAGIC) - 1;\n\n                SHA1((void *)new_key, new_key_size, (unsigned char *)sha1_buf);\n                size_t base64_output_size = sizeof(base64_output);\n                *response_size = snprintf(\n                    out_buf, out_buf_sz,\n                    \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n                    \"Upgrade: websocket\\r\\n\"\n                    \"Connection: Upgrade\\r\\n\"\n                    \"Sec-WebSocket-Accept: %s\\r\\n\"\n                    \"\\r\\n\",\n                    libcows_base64_encode(sha1_buf, sizeof(sha1_buf),\n                                          base64_output, &base64_output_size));\n                assert(*response_size < out_buf_sz);\n\n                /* Write out WebSocket response */\n                /*\n                if(write(fd, out_buf, response_size) != response_size)\n                    return HDW_UNEXPECTED_ERROR;\n                */\n\n                return HDW_WEBSOCKET_DETECTED;\n            }\n        }\n    }\n\n    return HDW_NOT_ENOUGH_DATA;\n}", "path": "tcpkali/src/tcpkali_websocket.c", "commit_date": "2017-08-15 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/* ASN_DISABLE_PER_SUPPORT */\n", "func_signal": "asn_random_fill_result_t\nREAL_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,\n                       const asn_encoding_constraints_t *constraints,\n                       size_t max_length)", "code": "{\n    asn_random_fill_result_t result_ok = {ARFILL_OK, 1};\n    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};\n    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};\n    static const double values[] = {\n        0, -0.0, -1, 1, -M_E, M_E, -3.14, 3.14, -M_PI, M_PI, -255, 255,\n        /* 2^51 */\n        -2251799813685248.0, 2251799813685248.0,\n        /* 2^52 */\n        -4503599627370496.0, 4503599627370496.0,\n        /* 2^100 */\n        -1267650600228229401496703205376.0, 1267650600228229401496703205376.0,\n        -FLT_MIN, FLT_MIN,\n        -FLT_MAX, FLT_MAX,\n        -DBL_MIN, DBL_MIN,\n        -DBL_MAX, DBL_MAX,\n#ifdef  FLT_TRUE_MIN\n        -FLT_TRUE_MIN, FLT_TRUE_MIN,\n#endif\n#ifdef  DBL_TRUE_MIN\n        -DBL_TRUE_MIN, DBL_TRUE_MIN,\n#endif\n        INFINITY, -INFINITY, NAN};\n    REAL_t *st;\n    double d;\n\n    (void)constraints;\n\n    if(max_length == 0) return result_skipped;\n\n    d = values[asn_random_between(0, sizeof(values) / sizeof(values[0]) - 1)];\n\n    if(*sptr) {\n        st = *sptr;\n    } else {\n        st = (REAL_t*)(*sptr = CALLOC(1, sizeof(REAL_t)));\n        if(!st) {\n            return result_failed;\n        }\n    }\n\n    if(asn_double2REAL(st, d)) {\n        if(st == *sptr) {\n            ASN_STRUCT_RESET(*td, st);\n        } else {\n            ASN_STRUCT_FREE(*td, st);\n        }\n        return result_failed;\n    }\n\n    result_ok.length = st->size;\n    return result_ok;\n}", "path": "tcpkali/asn1/REAL.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/*\n * Free the contents of the set, do not free the set itself.\n */\n", "func_signal": "void\nasn_set_empty(void *asn_set_of_x)", "code": "{\n\tasn_anonymous_set_ *as = _A_SET_FROM_VOID(asn_set_of_x);\n\n\tif(as) {\n\t\tif(as->array) {\n\t\t\tif(as->free) {\n\t\t\t\twhile(as->count--)\n\t\t\t\t\tas->free(as->array[as->count]);\n\t\t\t}\n\t\t\tFREEMEM(as->array);\n\t\t\tas->array = 0;\n\t\t}\n\t\tas->count = 0;\n\t\tas->size = 0;\n\t}\n\n}", "path": "tcpkali/asn1/asn_SET_OF.c", "commit_date": "2017-10-30 00:00:00", "repo_name": "satori-com/tcpkali", "stars": 2272, "license": "other", "language": "c", "size": 1689}
{"docstring": "/* json_object_string */\n", "func_signal": "static int json_object_string_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                             int level, int flags)", "code": "{\n\tssize_t len = JC_STRING(jso)->len;\n\tprintbuf_strappend(pb, \"\\\"\");\n\tjson_escape_str(pb, get_string_component(jso), len < 0 ? -(ssize_t)len : len, flags);\n\tprintbuf_strappend(pb, \"\\\"\");\n\treturn 0;\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* helper for accessing the optimized string data component in json_object\n */\n", "func_signal": "static inline char *get_string_component_mutable(struct json_object *jso)", "code": "{\n\tif (JC_STRING_C(jso)->len < 0)\n\t{\n\t\t/* Due to json_object_set_string(), we might have a pointer */\n\t\treturn JC_STRING(jso)->c_string.pdata;\n\t}\n\treturn JC_STRING(jso)->c_string.idata;\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* make sure only lowercase forms are parsed in strict mode */\n", "func_signal": "static void test_case_parse()", "code": "{\n\tstruct json_tokener *tok;\n\tjson_object *new_obj;\n\n\ttok = json_tokener_new();\n\tjson_tokener_set_flags(tok, JSON_TOKENER_STRICT);\n\n\tnew_obj = json_tokener_parse_ex(tok, \"True\", 4);\n\tassert(new_obj == NULL);\n\n\tnew_obj = json_tokener_parse_ex(tok, \"False\", 5);\n\tassert(new_obj == NULL);\n\n\tnew_obj = json_tokener_parse_ex(tok, \"Null\", 4);\n\tassert(new_obj == NULL);\n\n\tprintf(\"OK\\n\");\n\n\tjson_tokener_free(tok);\n}", "path": "json-c/tests/test_charcase.c", "commit_date": "2020-04-03 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/*\n * The actual guts of json_object_deep_copy(), with a few additional args\n * needed so we can keep track of where we are within the object tree.\n *\n * Note: caller is responsible for freeing *dst if this fails and returns -1.\n */\n", "func_signal": "static int json_object_deep_copy_recursive(struct json_object *src, struct json_object *parent,\n                                           const char *key_in_parent, size_t index_in_parent,\n                                           struct json_object **dst,\n                                           json_c_shallow_copy_fn *shallow_copy)", "code": "{\n\tstruct json_object_iter iter;\n\tsize_t src_array_len, ii;\n\n\tint shallow_copy_rc = 0;\n\tshallow_copy_rc = shallow_copy(src, parent, key_in_parent, index_in_parent, dst);\n\t/* -1=error, 1=object created ok, 2=userdata set */\n\tif (shallow_copy_rc < 1)\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tassert(*dst != NULL);\n\n\tswitch (src->o_type)\n\t{\n\tcase json_type_object:\n\t\tjson_object_object_foreachC(src, iter)\n\t\t{\n\t\t\tstruct json_object *jso = NULL;\n\t\t\t/* This handles the `json_type_null` case */\n\t\t\tif (!iter.val)\n\t\t\t\tjso = NULL;\n\t\t\telse if (json_object_deep_copy_recursive(iter.val, src, iter.key, UINT_MAX, &jso,\n\t\t\t                                         shallow_copy) < 0)\n\t\t\t{\n\t\t\t\tjson_object_put(jso);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (json_object_object_add(*dst, iter.key, jso) < 0)\n\t\t\t{\n\t\t\t\tjson_object_put(jso);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase json_type_array:\n\t\tsrc_array_len = json_object_array_length(src);\n\t\tfor (ii = 0; ii < src_array_len; ii++)\n\t\t{\n\t\t\tstruct json_object *jso = NULL;\n\t\t\tstruct json_object *jso1 = json_object_array_get_idx(src, ii);\n\t\t\t/* This handles the `json_type_null` case */\n\t\t\tif (!jso1)\n\t\t\t\tjso = NULL;\n\t\t\telse if (json_object_deep_copy_recursive(jso1, src, NULL, ii, &jso,\n\t\t\t                                         shallow_copy) < 0)\n\t\t\t{\n\t\t\t\tjson_object_put(jso);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (json_object_array_add(*dst, jso) < 0)\n\t\t\t{\n\t\t\t\tjson_object_put(jso);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t\t/* else, nothing to do, shallow_copy already did. */\n\t}\n\n\tif (shallow_copy_rc != 2)\n\t\treturn json_object_copy_serializer_data(src, *dst);\n\n\treturn 0;\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* json_object_int */\n", "func_signal": "static int json_object_int_to_json_string(struct json_object *jso, struct printbuf *pb, int level,\n                                          int flags)", "code": "{\n\t/* room for 19 digits, the sign char, and a null term */\n\tchar sbuf[21];\n\tif (JC_INT(jso)->cint_type == json_object_int_type_int64)\n\t\tsnprintf(sbuf, sizeof(sbuf), \"%\" PRId64, JC_INT(jso)->cint.c_int64);\n\telse\n\t\tsnprintf(sbuf, sizeof(sbuf), \"%\" PRIu64, JC_INT(jso)->cint.c_uint64);\n\treturn printbuf_memappend(pb, sbuf, strlen(sbuf));\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/**\n * The default shallow copy implementation.  Simply creates a new object of the same\n * type but does *not* copy over _userdata nor retain any custom serializer.\n * If custom serializers are in use, json_object_deep_copy() must be passed a shallow copy\n * implementation that is aware of how to copy them.\n *\n * This always returns -1 or 1.  It will never return 2 since it does not copy the serializer.\n */\n", "func_signal": "int json_c_shallow_copy_default(json_object *src, json_object *parent, const char *key,\n                                size_t index, json_object **dst)", "code": "{\n\tswitch (src->o_type)\n\t{\n\tcase json_type_boolean: *dst = json_object_new_boolean(JC_BOOL(src)->c_boolean); break;\n\n\tcase json_type_double: *dst = json_object_new_double(JC_DOUBLE(src)->c_double); break;\n\n\tcase json_type_int:\n\t\tswitch (JC_INT(src)->cint_type)\n\t\t{\n\t\tcase json_object_int_type_int64:\n\t\t\t*dst = json_object_new_int64(JC_INT(src)->cint.c_int64);\n\t\t\tbreak;\n\t\tcase json_object_int_type_uint64:\n\t\t\t*dst = json_object_new_uint64(JC_INT(src)->cint.c_uint64);\n\t\t\tbreak;\n\t\tdefault: json_abort(\"invalid cint_type\");\n\t\t}\n\t\tbreak;\n\n\tcase json_type_string: *dst = json_object_new_string(get_string_component(src)); break;\n\n\tcase json_type_object: *dst = json_object_new_object(); break;\n\n\tcase json_type_array: *dst = json_object_new_array(); break;\n\n\tdefault: errno = EINVAL; return -1;\n\t}\n\n\tif (!*dst)\n\t{\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\t(*dst)->_to_json_string = src->_to_json_string;\n\t// _userdata and _user_delete are copied later\n\treturn 1;\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* type checking functions */\n", "func_signal": "int json_object_is_type(const struct json_object *jso, enum json_type type)", "code": "{\n\tif (!jso)\n\t\treturn (type == json_type_null);\n\treturn (jso->o_type == type);\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* extended conversion to string */\n", "func_signal": "const char *json_object_to_json_string_length(struct json_object *jso, int flags, size_t *length)", "code": "{\n\tconst char *r = NULL;\n\tsize_t s = 0;\n\n\tif (!jso)\n\t{\n\t\ts = 4;\n\t\tr = \"null\";\n\t}\n\telse if ((jso->_pb) || (jso->_pb = printbuf_new()))\n\t{\n\t\tprintbuf_reset(jso->_pb);\n\n\t\tif (jso->_to_json_string(jso, jso->_pb, 0, flags) >= 0)\n\t\t{\n\t\t\ts = (size_t)jso->_pb->bpos;\n\t\t\tr = jso->_pb->buf;\n\t\t}\n\t}\n\n\tif (length)\n\t\t*length = s;\n\treturn r;\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* a simple hash function similiar to what perl does for strings.\n * for good results, the string should not be excessivly large.\n */\n", "func_signal": "static unsigned long lh_perllike_str_hash(const void *k)", "code": "{\n\tconst char *rkey = (const char *)k;\n\tunsigned hashval = 1;\n\n\twhile (*rkey)\n\t\thashval = hashval * 33 + *rkey++;\n\n\treturn hashval;\n}", "path": "json-c/linkhash.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "//static inline int _array_list_put_idx(struct array_list *arr, size_t idx, void *data)\n", "func_signal": "int array_list_put_idx(struct array_list *arr, size_t idx, void *data)", "code": "{\n\tif (idx > SIZE_T_MAX - 1)\n\t\treturn -1;\n\tif (array_list_expand_internal(arr, idx + 1))\n\t\treturn -1;\n\tif (idx < arr->length && arr->array[idx])\n\t\tarr->free_fn(arr->array[idx]);\n\tarr->array[idx] = data;\n\tif (idx > arr->length)\n\t{\n\t\t/* Zero out the arraylist slots in between the old length\n\t\t   and the newly added entry so we know those entries are\n\t\t   empty.\n\t\t   e.g. when setting array[7] in an array that used to be \n\t\t   only 5 elements longs, array[5] and array[6] need to be\n\t\t   set to 0.\n\t\t */\n\t\tmemset(arr->array + arr->length, 0, (idx - arr->length) * sizeof(void *));\n\t}\n\tif (arr->length <= idx)\n\t\tarr->length = idx + 1;\n\treturn 0;\n}", "path": "json-c/arraylist.c", "commit_date": "2020-08-24 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* get_rdrand_seed - Visual Studio 2012 and above */\n", "func_signal": "static int get_rdrand_seed(void)", "code": "{\n\tDEBUG_SEED(\"get_rdrand_seed\");\n\tint r;\n\twhile (_rdrand32_step(&r) == 0)\n\t\t;\n\treturn r;\n}", "path": "json-c/random_seed.c", "commit_date": "2020-10-07 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* reference counting */\n", "func_signal": "struct json_object *json_object_get(struct json_object *jso)", "code": "{\n\tif (!jso)\n\t\treturn jso;\n\n\t// Don't overflow the refcounter.\n\tassert(jso->_ref_count < UINT32_MAX);\n\n#if defined(HAVE_ATOMIC_BUILTINS) && defined(ENABLE_THREADING)\n\t__sync_add_and_fetch(&jso->_ref_count, 1);\n#else\n\t++jso->_ref_count;\n#endif\n\n\treturn jso;\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* json_object_array */\n", "func_signal": "static int json_object_array_to_json_string(struct json_object *jso, struct printbuf *pb, int level,\n                                            int flags)", "code": "{\n\tint had_children = 0;\n\tsize_t ii;\n\n\tprintbuf_strappend(pb, \"[\");\n\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t\tprintbuf_strappend(pb, \"\\n\");\n\tfor (ii = 0; ii < json_object_array_length(jso); ii++)\n\t{\n\t\tstruct json_object *val;\n\t\tif (had_children)\n\t\t{\n\t\t\tprintbuf_strappend(pb, \",\");\n\t\t\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t\t\t\tprintbuf_strappend(pb, \"\\n\");\n\t\t}\n\t\thad_children = 1;\n\t\tif (flags & JSON_C_TO_STRING_SPACED && !(flags & JSON_C_TO_STRING_PRETTY))\n\t\t\tprintbuf_strappend(pb, \" \");\n\t\tindent(pb, level + 1, flags);\n\t\tval = json_object_array_get_idx(jso, ii);\n\t\tif (val == NULL)\n\t\t\tprintbuf_strappend(pb, \"null\");\n\t\telse if (val->_to_json_string(val, pb, level + 1, flags) < 0)\n\t\t\treturn -1;\n\t}\n\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t{\n\t\tif (had_children)\n\t\t\tprintbuf_strappend(pb, \"\\n\");\n\t\tindent(pb, level, flags);\n\t}\n\n\tif (flags & JSON_C_TO_STRING_SPACED && !(flags & JSON_C_TO_STRING_PRETTY))\n\t\treturn printbuf_strappend(pb, \" ]\");\n\treturn printbuf_strappend(pb, \"]\");\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* string escaping */\n", "func_signal": "static int json_escape_str(struct printbuf *pb, const char *str, size_t len, int flags)", "code": "{\n\tsize_t pos = 0, start_offset = 0;\n\tunsigned char c;\n\twhile (len--)\n\t{\n\t\tc = str[pos];\n\t\tswitch (c)\n\t\t{\n\t\tcase '\\b':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase '\\t':\n\t\tcase '\\f':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '/':\n\t\t\tif ((flags & JSON_C_TO_STRING_NOSLASHESCAPE) && c == '/')\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pos - start_offset > 0)\n\t\t\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\n\t\t\tif (c == '\\b')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\b\", 2);\n\t\t\telse if (c == '\\n')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\n\", 2);\n\t\t\telse if (c == '\\r')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\r\", 2);\n\t\t\telse if (c == '\\t')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\t\", 2);\n\t\t\telse if (c == '\\f')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\f\", 2);\n\t\t\telse if (c == '\"')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\\\\"\", 2);\n\t\t\telse if (c == '\\\\')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\\\\\\", 2);\n\t\t\telse if (c == '/')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\/\", 2);\n\n\t\t\tstart_offset = ++pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (c < ' ')\n\t\t\t{\n\t\t\t\tchar sbuf[7];\n\t\t\t\tif (pos - start_offset > 0)\n\t\t\t\t\tprintbuf_memappend(pb, str + start_offset,\n\t\t\t\t\t                   pos - start_offset);\n\t\t\t\tsnprintf(sbuf, sizeof(sbuf), \"\\\\u00%c%c\", json_hex_chars[c >> 4],\n\t\t\t\t         json_hex_chars[c & 0xf]);\n\t\t\t\tprintbuf_memappend_fast(pb, sbuf, (int)sizeof(sbuf) - 1);\n\t\t\t\tstart_offset = ++pos;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpos++;\n\t\t}\n\t}\n\tif (pos - start_offset > 0)\n\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\treturn 0;\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/**\n * JavaScript Object Notation (JSON) Pointer\n *   RFC 6901 - https://tools.ietf.org/html/rfc6901\n */\n", "func_signal": "static void string_replace_all_occurrences_with_char(char *s, const char *occur, char repl_char)", "code": "{\n\tint slen = strlen(s);\n\tint skip = strlen(occur) - 1; /* length of the occurrence, minus the char we're replacing */\n\tchar *p = s;\n\twhile ((p = strstr(p, occur)))\n\t{\n\t\t*p = repl_char;\n\t\tp++;\n\t\tslen -= skip;\n\t\tmemmove(p, (p + skip), slen - (p - s) + 1); /* includes null char too */\n\t}\n}", "path": "json-c/json_pointer.c", "commit_date": "2020-08-02 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* clang-format off */\n", "func_signal": "static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)", "code": "{\n\tuint32_t a,b,c; /* internal state */\n\tunion\n\t{\n\t\tconst void *ptr;\n\t\tsize_t i;\n\t} u; /* needed for Mac Powerbook G4 */\n\n\t/* Set up the internal state */\n\ta = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n\n\tu.ptr = key;\n\tif (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n\t\tconst uint32_t *k = (const uint32_t *)key; /* read 32-bit chunks */\n\n\t\t/*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n\t\twhile (length > 12)\n\t\t{\n\t\t\ta += k[0];\n\t\t\tb += k[1];\n\t\t\tc += k[2];\n\t\t\tmix(a,b,c);\n\t\t\tlength -= 12;\n\t\t\tk += 3;\n\t\t}\n\n\t\t/*----------------------------- handle the last (probably partial) block */\n\t\t/*\n\t\t * \"k[2]&0xffffff\" actually reads beyond the end of the string, but\n\t\t * then masks off the part it's not allowed to read.  Because the\n\t\t * string is aligned, the masked-off tail is in the same word as the\n\t\t * rest of the string.  Every machine with memory protection I've seen\n\t\t * does it on word boundaries, so is OK with this.  But VALGRIND will\n\t\t * still catch it and complain.  The masking trick does make the hash\n\t\t * noticably faster for short strings (like English words).\n\t\t * AddressSanitizer is similarly picky about overrunning\n\t\t * the buffer. (http://clang.llvm.org/docs/AddressSanitizer.html\n\t\t */\n#ifdef VALGRIND\n#define PRECISE_MEMORY_ACCESS 1\n#elif defined(__SANITIZE_ADDRESS__) /* GCC's ASAN */\n#define PRECISE_MEMORY_ACCESS 1\n#elif defined(__has_feature)\n#if __has_feature(address_sanitizer) /* Clang's ASAN */\n#define PRECISE_MEMORY_ACCESS 1\n#endif\n#endif\n#ifndef PRECISE_MEMORY_ACCESS\n\n\t\tswitch(length)\n\t\t{\n\t\tcase 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n\t\tcase 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n\t\tcase 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n\t\tcase 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n\t\tcase 8 : b+=k[1]; a+=k[0]; break;\n\t\tcase 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n\t\tcase 6 : b+=k[1]&0xffff; a+=k[0]; break;\n\t\tcase 5 : b+=k[1]&0xff; a+=k[0]; break;\n\t\tcase 4 : a+=k[0]; break;\n\t\tcase 3 : a+=k[0]&0xffffff; break;\n\t\tcase 2 : a+=k[0]&0xffff; break;\n\t\tcase 1 : a+=k[0]&0xff; break;\n\t\tcase 0 : return c; /* zero length strings require no mixing */\n\t\t}\n\n#else /* make valgrind happy */\n\n\t\tconst uint8_t  *k8 = (const uint8_t *)k;\n\t\tswitch(length)\n\t\t{\n\t\tcase 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n\t\tcase 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n\t\tcase 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n\t\tcase 9 : c+=k8[8];                   /* fall through */\n\t\tcase 8 : b+=k[1]; a+=k[0]; break;\n\t\tcase 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n\t\tcase 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n\t\tcase 5 : b+=k8[4];                   /* fall through */\n\t\tcase 4 : a+=k[0]; break;\n\t\tcase 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n\t\tcase 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n\t\tcase 1 : a+=k8[0]; break;\n\t\tcase 0 : return c;\n\t\t}\n\n#endif /* !valgrind */\n\n\t}\n\telse if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0))\n\t{\n\t\tconst uint16_t *k = (const uint16_t *)key; /* read 16-bit chunks */\n\t\tconst uint8_t  *k8;\n\n\t\t/*--------------- all but last block: aligned reads and different mixing */\n\t\twhile (length > 12)\n\t\t{\n\t\t\ta += k[0] + (((uint32_t)k[1])<<16);\n\t\t\tb += k[2] + (((uint32_t)k[3])<<16);\n\t\t\tc += k[4] + (((uint32_t)k[5])<<16);\n\t\t\tmix(a,b,c);\n\t\t\tlength -= 12;\n\t\t\tk += 6;\n\t\t}\n\n\t\t/*----------------------------- handle the last (probably partial) block */\n\t\tk8 = (const uint8_t *)k;\n\t\tswitch(length)\n\t\t{\n\t\tcase 12: c+=k[4]+(((uint32_t)k[5])<<16);\n\t\t\t b+=k[2]+(((uint32_t)k[3])<<16);\n\t\t\t a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n\t\tcase 10: c+=k[4];\n\t\t\t b+=k[2]+(((uint32_t)k[3])<<16);\n\t\t\t a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 9 : c+=k8[8];                      /* fall through */\n\t\tcase 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n\t\t\t a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n\t\tcase 6 : b+=k[2];\n\t\t\t a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 5 : b+=k8[4];                      /* fall through */\n\t\tcase 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n\t\tcase 2 : a+=k[0];\n\t\t\t break;\n\t\tcase 1 : a+=k8[0];\n\t\t\t break;\n\t\tcase 0 : return c;                     /* zero length requires no mixing */\n\t\t}\n\n\t}\n\telse\n\t{\n\t\t/* need to read the key one byte at a time */\n\t\tconst uint8_t *k = (const uint8_t *)key;\n\n\t\t/*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n\t\twhile (length > 12)\n\t\t{\n\t\t\ta += k[0];\n\t\t\ta += ((uint32_t)k[1])<<8;\n\t\t\ta += ((uint32_t)k[2])<<16;\n\t\t\ta += ((uint32_t)k[3])<<24;\n\t\t\tb += k[4];\n\t\t\tb += ((uint32_t)k[5])<<8;\n\t\t\tb += ((uint32_t)k[6])<<16;\n\t\t\tb += ((uint32_t)k[7])<<24;\n\t\t\tc += k[8];\n\t\t\tc += ((uint32_t)k[9])<<8;\n\t\t\tc += ((uint32_t)k[10])<<16;\n\t\t\tc += ((uint32_t)k[11])<<24;\n\t\t\tmix(a,b,c);\n\t\t\tlength -= 12;\n\t\t\tk += 12;\n\t\t}\n\n\t\t/*-------------------------------- last block: affect all 32 bits of (c) */\n\t\tswitch(length) /* all the case statements fall through */\n\t\t{\n\t\tcase 12: c+=((uint32_t)k[11])<<24; /* FALLTHRU */\n\t\tcase 11: c+=((uint32_t)k[10])<<16; /* FALLTHRU */\n\t\tcase 10: c+=((uint32_t)k[9])<<8; /* FALLTHRU */\n\t\tcase 9 : c+=k[8]; /* FALLTHRU */\n\t\tcase 8 : b+=((uint32_t)k[7])<<24; /* FALLTHRU */\n\t\tcase 7 : b+=((uint32_t)k[6])<<16; /* FALLTHRU */\n\t\tcase 6 : b+=((uint32_t)k[5])<<8; /* FALLTHRU */\n\t\tcase 5 : b+=k[4]; /* FALLTHRU */\n\t\tcase 4 : a+=((uint32_t)k[3])<<24; /* FALLTHRU */\n\t\tcase 3 : a+=((uint32_t)k[2])<<16; /* FALLTHRU */\n\t\tcase 2 : a+=((uint32_t)k[1])<<8; /* FALLTHRU */\n\t\tcase 1 : a+=k[0];\n\t\t\t break;\n\t\tcase 0 : return c;\n\t\t}\n\t}\n\n\tfinal(a,b,c);\n\treturn c;\n}", "path": "json-c/linkhash.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* json_object_boolean */\n", "func_signal": "static int json_object_boolean_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                              int level, int flags)", "code": "{\n\tif (JC_BOOL(jso)->c_boolean)\n\t\treturn printbuf_strappend(pb, \"true\");\n\treturn printbuf_strappend(pb, \"false\");\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* set a custom conversion to string */\n", "func_signal": "void json_object_set_serializer(json_object *jso, json_object_to_json_string_fn *to_string_func,\n                                void *userdata, json_object_delete_fn *user_delete)", "code": "{\n\tjson_object_set_userdata(jso, userdata, user_delete);\n\n\tif (to_string_func == NULL)\n\t{\n\t\t// Reset to the standard serialization function\n\t\tswitch (jso->o_type)\n\t\t{\n\t\tcase json_type_null: jso->_to_json_string = NULL; break;\n\t\tcase json_type_boolean:\n\t\t\tjso->_to_json_string = &json_object_boolean_to_json_string;\n\t\t\tbreak;\n\t\tcase json_type_double:\n\t\t\tjso->_to_json_string = &json_object_double_to_json_string_default;\n\t\t\tbreak;\n\t\tcase json_type_int: jso->_to_json_string = &json_object_int_to_json_string; break;\n\t\tcase json_type_object:\n\t\t\tjso->_to_json_string = &json_object_object_to_json_string;\n\t\t\tbreak;\n\t\tcase json_type_array:\n\t\t\tjso->_to_json_string = &json_object_array_to_json_string;\n\t\t\tbreak;\n\t\tcase json_type_string:\n\t\t\tjso->_to_json_string = &json_object_string_to_json_string;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tjso->_to_json_string = to_string_func;\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* clang-format off */\n", "func_signal": "static int get_rdrand_seed(void)", "code": "{\n\tDEBUG_SEED(\"get_rdrand_seed\");\n\tint _eax;\nretry:\n\t/* rdrand eax */\n\t__asm _emit 0x0F __asm _emit 0xC7 __asm _emit 0xF0\n\t__asm jnc retry\n\t__asm mov _eax, eax\n\treturn _eax;\n}", "path": "json-c/random_seed.c", "commit_date": "2020-10-07 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* generic object construction and destruction parts */\n", "func_signal": "static void json_object_generic_delete(struct json_object *jso)", "code": "{\n#ifdef REFCOUNT_DEBUG\n\tMC_DEBUG(\"json_object_delete_%s: %p\\n\", json_type_to_name(jso->o_type), jso);\n\tlh_table_delete(json_object_table, jso);\n#endif /* REFCOUNT_DEBUG */\n\tprintbuf_free(jso->_pb);\n\tfree(jso);\n}", "path": "json-c/json_object.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "json-c/json-c", "stars": 2843, "license": "other", "language": "c", "size": 4001}
{"docstring": "/* Copies and processes passed string up to supplied length.\nExample: \"\\u006Corem ipsum\" -> lorem ipsum */\n", "func_signal": "static char* process_string(const char *input, size_t len)", "code": "{\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = NULL, *output_ptr = NULL, *resized_output = NULL;\n    output = (char*)parson_malloc(initial_size);\n    if (output == NULL) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\0') && (size_t)(input_ptr - input) < len) {\n        if (*input_ptr == '\\\\') {\n            input_ptr++;\n            switch (*input_ptr) {\n                case '\\\"': *output_ptr = '\\\"'; break;\n                case '\\\\': *output_ptr = '\\\\'; break;\n                case '/':  *output_ptr = '/';  break;\n                case 'b':  *output_ptr = '\\b'; break;\n                case 'f':  *output_ptr = '\\f'; break;\n                case 'n':  *output_ptr = '\\n'; break;\n                case 'r':  *output_ptr = '\\r'; break;\n                case 't':  *output_ptr = '\\t'; break;\n                case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                default:\n                    goto error;\n            }\n        } else if ((unsigned char)*input_ptr < 0x20) {\n            goto error; /* 0x00-0x19 are invalid characters for json string (http://www.ietf.org/rfc/rfc4627.txt) */\n        } else {\n            *output_ptr = *input_ptr;\n        }\n        output_ptr++;\n        input_ptr++;\n    }\n    *output_ptr = '\\0';\n    /* resize to new length */\n    final_size = (size_t)(output_ptr-output) + 1;\n    /* todo: don't resize if final_size == initial_size */\n    resized_output = (char*)parson_malloc(final_size);\n    if (resized_output == NULL) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\nerror:\n    parson_free(output);\n    return NULL;\n}", "path": "libfreenect/fakenect/parson.c", "commit_date": "2017-11-22 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "// returns UINT16_MAX on error\n", "func_signal": "FN_INTERNAL uint16_t read_cmos_register(freenect_device *dev, uint16_t reg)", "code": "{\n\tfreenect_context *ctx = dev->parent;\n\tuint16_t replybuf[0x200];\n\tuint16_t cmdbuf[3];\n\n\tcmdbuf[0] = 1;\n\tcmdbuf[1] = reg & 0x7fff;\n\tcmdbuf[2] = 0;\n\n\tint res = send_cmd(dev, 0x95, cmdbuf, 6, replybuf, 6);\n\tif (res < 0)\n\t{\n\t\tFN_ERROR(\"read_cmos_register: send_cmd() returned %d\\n\", res);\n\t\treturn UINT16_MAX;\n\t}\n\n\tFN_DEBUG(\"read_cmos_register: 0x%04x => 0x%04x\\n\", reg, replybuf[2]);\n\treturn replybuf[2];\n}", "path": "libfreenect/src/flags.c", "commit_date": "2017-10-25 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/// camera -> world coordinate helper function\n", "func_signal": "void freenect_camera_to_world(freenect_device* dev, int cx, int cy, int wz, double* wx, double* wy)", "code": "{\n\tdouble ref_pix_size = dev->registration.zero_plane_info.reference_pixel_size;\n\tdouble ref_distance = dev->registration.zero_plane_info.reference_distance;\n\t// We multiply cx and cy by these factors because they come from a 640x480 image,\n\t// but the zero plane pixel size is for a 1280x1024 image.\n\t// However, the 640x480 image is produced by cropping the 1280x1024 image\n\t// to 1280x960 and then scaling by .5, so aspect ratio is maintained, and\n\t// we should simply multiply by two in each dimension.\n\tdouble factor = 2 * ref_pix_size * wz / ref_distance;\n\t*wx = (double)(cx - DEPTH_X_RES/2) * factor;\n\t*wy = (double)(cy - DEPTH_Y_RES/2) * factor;\n}", "path": "libfreenect/src/registration.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/// Allocate and fill registration tables\n/// This function should be called every time a new video (not depth!) mode is\n/// activated.\n", "func_signal": "FN_INTERNAL int freenect_init_registration(freenect_device* dev)", "code": "{\n\tfreenect_registration* reg = &(dev->registration);\n\n\t// Ensure that we free the previous tables before dropping the pointers, if there were any.\n\tfreenect_destroy_registration(&(dev->registration));\n\n\t// Allocate tables.\n\treg->raw_to_mm_shift    = (uint16_t*)malloc( sizeof(uint16_t) * DEPTH_MAX_RAW_VALUE );\n\treg->depth_to_rgb_shift = (int32_t*)malloc( sizeof( int32_t) * DEPTH_MAX_METRIC_VALUE );\n\treg->registration_table = (int32_t (*)[2])malloc( sizeof( int32_t) * DEPTH_X_RES * DEPTH_Y_RES * 2 );\n\n\t// Fill tables.\n\tcomplete_tables(reg);\n\n\treturn 0;\n}", "path": "libfreenect/src/registration.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "//Waiting for a client to connect\n", "func_signal": "void freenect_network_wait()", "code": "{\n\tint childlen;\n\tstruct sockaddr_in childaddr;\n\t\n\tchildlen = sizeof(childaddr);\n\n\tprintf(\"### Wait client\\n\");\n\t#ifdef _WIN32 //Wait for connection (Winsock)\n\t\tdata_client_socket = accept(data_socket, NULL, NULL);\n\t\tif (data_client_socket == INVALID_SOCKET) {\n\t\t\tif(!closing) printf(\"Error on accept() for data, exit data thread. %d\\n\", WSAGetLastError());\n\t\t\tclosesocket(data_socket);\n\t\t\tWSACleanup();\n\t\t}\n\t#else //Wait for connection (UNIX)\n\t\tdata_child = accept(s_data, (struct sockaddr *)&childaddr, (unsigned int *)&childlen);\n\t\tif ( data_child < 0 )\n\t\t{\n\t\t\tif(!closing) fprintf(stderr, \"Error on accept() for data, exit data thread.\\n\");\n\t\t}\n\t#endif\n\t\n\t//callback\n\tif(!closing) freenect_network_connected();\n}", "path": "libfreenect/wrappers/actionscript/server/freenect_network.c", "commit_date": "2011-07-19 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/* JSON Object API */\n", "func_signal": "JSON_Value * json_object_get_value(const JSON_Object *object, const char *name)", "code": "{\n    if (object == NULL || name == NULL) {\n        return NULL;\n    }\n    return json_object_nget_value(object, name, strlen(name));\n}", "path": "libfreenect/fakenect/parson.c", "commit_date": "2017-11-22 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "//Close network socket\n", "func_signal": "void freenect_network_close()", "code": "{\n\tclosing = 1;\n#ifdef _WIN32\n\tif ( data_socket != INVALID_SOCKET )\n\t\tclosesocket(data_socket);\n#else\n\tif ( s_data != -1 )\n\t\tclose(s_data), s_data = -1;\n#endif\n}", "path": "libfreenect/wrappers/actionscript/server/freenect_network.c", "commit_date": "2011-07-19 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/* Parser */\n", "func_signal": "static JSON_Status skip_quotes(const char **string)", "code": "{\n    if (**string != '\\\"') {\n        return JSONFailure;\n    }\n    SKIP_CHAR(string);\n    while (**string != '\\\"') {\n        if (**string == '\\0') {\n            return JSONFailure;\n        } else if (**string == '\\\\') {\n            SKIP_CHAR(string);\n            if (**string == '\\0') {\n                return JSONFailure;\n            }\n        }\n        SKIP_CHAR(string);\n    }\n    SKIP_CHAR(string);\n    return JSONSuccess;\n}", "path": "libfreenect/fakenect/parson.c", "commit_date": "2017-11-22 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/// RGB -> depth mapping function (inverse of default FREENECT_DEPTH_REGISTERED mapping)\n", "func_signal": "void freenect_map_rgb_to_depth(freenect_device* dev, uint16_t* depth_mm, uint8_t* rgb_raw, uint8_t* rgb_registered)", "code": "{\n\tuint32_t target_offset = dev->registration.reg_pad_info.start_lines * DEPTH_Y_RES;\n\tint x,y;\n\tint* map = (int*)malloc(DEPTH_Y_RES*DEPTH_X_RES* sizeof(int));\n\tunsigned short* zBuffer = (unsigned short*)malloc(DEPTH_Y_RES*DEPTH_X_RES* sizeof(unsigned short));\n\tmemset(zBuffer, DEPTH_NO_MM_VALUE, DEPTH_X_RES*DEPTH_Y_RES * sizeof(unsigned short));\n\n\tfor (y = 0; y < DEPTH_Y_RES; y++) for (x = 0; x < DEPTH_X_RES; x++) {\n\t\tuint32_t index = y * DEPTH_X_RES + x;\n\t\tuint32_t cx,cy,cindex;\n\n\t\tmap[index] = -1;\n\n\t\tint wz = depth_mm[index];\n\n\t\tif (wz == DEPTH_NO_MM_VALUE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// coordinates in rgb image corresponding to x,y in depth image\n\t\tcx = (dev->registration.registration_table[index][0] + dev->registration.depth_to_rgb_shift[wz]) / REG_X_VAL_SCALE;\n\t\tcy =  dev->registration.registration_table[index][1] - target_offset;\n\n\t\tif (cx >= DEPTH_X_RES) continue;\n\n\t\tcindex = cy*DEPTH_X_RES+cx;\n\t\tmap[index] = cindex;\n\n\t\tif (zBuffer[cindex] == DEPTH_NO_MM_VALUE || zBuffer[cindex] > wz) {\n\t\t\tzBuffer[cindex] = wz;\n\t\t}\n\t}\n\n\tfor (y = 0; y < DEPTH_Y_RES; y++) for (x = 0; x < DEPTH_X_RES; x++) {\n\t\tuint32_t index = y * DEPTH_X_RES + x;\n\t\tuint32_t cindex = map[index];\n\n\t\t// pixels without depth data or out of bounds are black\n\t\tif (cindex == -1) {\n\t\t\tindex *= 3;\n\t\t\trgb_registered[index+0] = 0;\n\t\t\trgb_registered[index+1] = 0;\n\t\t\trgb_registered[index+2] = 0;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tunsigned short currentDepth = depth_mm[index];\n\t\tunsigned short minDepth = zBuffer[cindex];\n\n\t\t// filters out pixels that are occluded\n\t\tif (currentDepth <= minDepth) {\n\t\t\tindex *= 3;\n\t\t\tcindex *= 3;\n\n\t\t\trgb_registered[index+0] = rgb_raw[cindex+0];\n\t\t\trgb_registered[index+1] = rgb_raw[cindex+1];\n\t\t\trgb_registered[index+2] = rgb_raw[cindex+2];\n\t\t}\n\t}\n\n\tfree(zBuffer);\n\tfree(map);\n}", "path": "libfreenect/src/registration.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/* JSON Value */\n", "func_signal": "static JSON_Value * json_value_init_string_no_copy(char *string)", "code": "{\n    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));\n    if (!new_value) {\n        return NULL;\n    }\n    new_value->parent = NULL;\n    new_value->type = JSONString;\n    new_value->value.string = string;\n    return new_value;\n}", "path": "libfreenect/fakenect/parson.c", "commit_date": "2017-11-22 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/// convert raw shift value to metric depth (in mm)\n", "func_signal": "static uint16_t freenect_raw_to_mm(uint16_t raw, freenect_registration* reg)", "code": "{\n\tfreenect_zero_plane_info* zpi = &(reg->zero_plane_info);\n\tdouble fixed_ref_x = ((raw - (parameter_coefficient * reg->const_shift / pixel_size_factor)) / parameter_coefficient) - S2D_CONST_OFFSET;\n\tdouble metric = fixed_ref_x * zpi->reference_pixel_size * pixel_size_factor;\n\treturn shift_scale * ((metric * zpi->reference_distance / (zpi->dcmos_emitter_dist - metric)) + zpi->reference_distance);\n}", "path": "libfreenect/src/registration.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "// create temporary x/y shift tables\n", "func_signal": "static void freenect_create_dxdy_tables(double* reg_x_table, double* reg_y_table, int32_t resolution_x, int32_t resolution_y, freenect_reg_info* regdata )", "code": "{\n\n\tint64_t AX6 = regdata->ax;\n\tint64_t BX6 = regdata->bx;\n\tint64_t CX2 = regdata->cx;\n\tint64_t DX2 = regdata->dx;\n\n\tint64_t AY6 = regdata->ay;\n\tint64_t BY6 = regdata->by;\n\tint64_t CY2 = regdata->cy;\n\tint64_t DY2 = regdata->dy;\n\n\t// don't merge the shift operations - necessary for proper 32-bit clamping of extracted values\n\tint64_t dX0 = (regdata->dx_start << 13) >> 4;\n\tint64_t dY0 = (regdata->dy_start << 13) >> 4;\n\n\tint64_t dXdX0 = (regdata->dxdx_start << 11) >> 3;\n\tint64_t dXdY0 = (regdata->dxdy_start << 11) >> 3;\n\tint64_t dYdX0 = (regdata->dydx_start << 11) >> 3;\n\tint64_t dYdY0 = (regdata->dydy_start << 11) >> 3;\n\n\tint64_t dXdXdX0 = (regdata->dxdxdx_start << 5) << 3;\n\tint64_t dYdXdX0 = (regdata->dydxdx_start << 5) << 3;\n\tint64_t dYdXdY0 = (regdata->dydxdy_start << 5) << 3;\n\tint64_t dXdXdY0 = (regdata->dxdxdy_start << 5) << 3;\n\tint64_t dYdYdX0 = (regdata->dydydx_start << 5) << 3;\n\tint64_t dYdYdY0 = (regdata->dydydy_start << 5) << 3;\n\n\tint32_t row,col,tOffs = 0;\n\n\tfor (row = 0 ; row < resolution_y ; row++) {\n\n\t\tdXdXdX0 += CX2;\n\n\t\tdXdX0   += dYdXdX0 >> 8;\n\t\tdYdXdX0 += DX2;\n\n\t\tdX0     += dYdX0 >> 6;\n\t\tdYdX0   += dYdYdX0 >> 8;\n\t\tdYdYdX0 += BX6;\n\n\t\tdXdXdY0 += CY2;\n\n\t\tdXdY0   += dYdXdY0 >> 8;\n\t\tdYdXdY0 += DY2;\n\n\t\tdY0     += dYdY0 >> 6;\n\t\tdYdY0   += dYdYdY0 >> 8;\n\t\tdYdYdY0 += BY6;\n\n\t\tint64_t coldXdXdY0 = dXdXdY0, coldXdY0 = dXdY0, coldY0 = dY0;\n\n\t\tint64_t coldXdXdX0 = dXdXdX0, coldXdX0 = dXdX0, coldX0 = dX0;\n\n\t\tfor (col = 0 ; col < resolution_x ; col++, tOffs++) {\n\t\t\treg_x_table[tOffs] = coldX0 * (1.0/(1<<17));\n\t\t\treg_y_table[tOffs] = coldY0 * (1.0/(1<<17));\n\n\t\t\tcoldX0     += coldXdX0 >> 6;\n\t\t\tcoldXdX0   += coldXdXdX0 >> 8;\n\t\t\tcoldXdXdX0 += AX6;\n\n\t\t\tcoldY0     += coldXdY0 >> 6;\n\t\t\tcoldXdY0   += coldXdXdY0 >> 8;\n\t\t\tcoldXdXdY0 += AY6;\n\t\t}\n\t}\n}", "path": "libfreenect/src/registration.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/* Parser API */\n", "func_signal": "JSON_Value * json_parse_file(const char *filename)", "code": "{\n    char *file_contents = read_file(filename);\n    JSON_Value *output_value = NULL;\n    if (file_contents == NULL) {\n        return NULL;\n    }\n    output_value = json_parse_string(file_contents);\n    parson_free(file_contents);\n    return output_value;\n}", "path": "libfreenect/fakenect/parson.c", "commit_date": "2017-11-22 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "//Init network\n", "func_signal": "int freenect_network_init(callback cb)", "code": "{\n\t#ifndef _WIN32 //Init server UNIX\n\t\tsignal(SIGPIPE, SIG_IGN);\n\t\tfreenect_network_initSocket(si_data, conf_port_data, &s_data); \n\t#else //Init server Winsock (Windows)\n\t\tWORD wVersionRequested;\n    \tWSADATA wsaData;\n    \tint err;\n\n    \twVersionRequested = MAKEWORD(2, 2);\n\n    \terr = WSAStartup(wVersionRequested, &wsaData);\n    \tif (err != 0) {\n        \tprintf(\"WSAStartup failed with error: %d\\n\", err);\n        \treturn 1;\n    \t}\n\t\tfreenect_network_initSocket(si_data, conf_port_data, &data_socket);\n\t#endif\n\tfreenect_network_connected = cb;\n\tfreenect_network_wait();\n\t\t\n\treturn 0;\n}", "path": "libfreenect/wrappers/actionscript/server/freenect_network.c", "commit_date": "2011-07-19 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "// returns UINT16_MAX on error\n", "func_signal": "FN_INTERNAL uint16_t read_register(freenect_device *dev, uint16_t reg)", "code": "{\n\tfreenect_context *ctx = dev->parent;\n\n\tuint16_t reply[2];\n\tuint16_t cmd = fn_le16(reg);\n\n\tint res = send_cmd(dev, 0x02, &cmd, 2, reply, 4);\n\tif (res < 0)\n\t{\n\t\tFN_ERROR(\"read_register: send_cmd() failed: %d\\n\", res);\n\t\treturn UINT16_MAX;\n\t}\n\tif (res != 4)\n\t\tFN_WARNING(\"read_register: send_cmd() returned %d [%04x %04x], 0000 expected\\n\", res, reply[0], reply[1]);\n\n\tFN_DEBUG(\"read_register: 0x%04x => 0x%04x\\n\", reg, reply[1]);\n\treturn reply[1];\n}", "path": "libfreenect/src/flags.c", "commit_date": "2017-10-25 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "// unrolled inner loop of the 11-bit unpacker\n", "func_signal": "static inline void unpack_8_pixels(uint8_t *raw, uint16_t *frame)", "code": "{\n\tuint16_t baseMask = 0x7FF;\n\n\tuint8_t r0  = *(raw+0);\n\tuint8_t r1  = *(raw+1);\n\tuint8_t r2  = *(raw+2);\n\tuint8_t r3  = *(raw+3);\n\tuint8_t r4  = *(raw+4);\n\tuint8_t r5  = *(raw+5);\n\tuint8_t r6  = *(raw+6);\n\tuint8_t r7  = *(raw+7);\n\tuint8_t r8  = *(raw+8);\n\tuint8_t r9  = *(raw+9);\n\tuint8_t r10 = *(raw+10);\n\n\tframe[0] =  (r0<<3)  | (r1>>5);\n\tframe[1] = ((r1<<6)  | (r2>>2) )           & baseMask;\n\tframe[2] = ((r2<<9)  | (r3<<1) | (r4>>7) ) & baseMask;\n\tframe[3] = ((r4<<4)  | (r5>>4) )           & baseMask;\n\tframe[4] = ((r5<<7)  | (r6>>1) )           & baseMask;\n\tframe[5] = ((r6<<10) | (r7<<2) | (r8>>6) ) & baseMask;\n\tframe[6] = ((r8<<5)  | (r9>>3) )           & baseMask;\n\tframe[7] = ((r9<<8)  | (r10)   )           & baseMask;\n}", "path": "libfreenect/src/registration.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "// This matrix comes from a combination of nicolas burrus's calibration post\n// and some python code I haven't documented yet.\n", "func_signal": "void LoadRGBMatrix()", "code": "{\n    float mat[16] = {\n        5.34866271e+02,   3.89654806e+00,   0.00000000e+00,   1.74704200e-02,\n        -4.70724694e+00,  -5.28843603e+02,   0.00000000e+00,  -1.22753400e-02,\n        -3.19670762e+02,  -2.60999685e+02,   0.00000000e+00,  -9.99772000e-01,\n        -6.98445586e+00,   3.31139785e+00,   0.00000000e+00,   1.09167360e-02\n    };\n    glMultMatrixf(mat);\n}", "path": "libfreenect/examples/glpclview.c", "commit_date": "2014-07-03 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/// fill the table of horizontal shift values for metric depth -> RGB conversion\n", "func_signal": "static void freenect_init_depth_to_rgb(int32_t* depth_to_rgb, freenect_zero_plane_info* zpi)", "code": "{\n\tuint32_t i,x_scale = DEPTH_SENSOR_X_RES / DEPTH_X_RES;\n\n\tdouble pixel_size = 1.0 / (zpi->reference_pixel_size * x_scale * S2D_PIXEL_CONST);\n\tdouble pixels_between_rgb_and_ir_cmos = zpi->dcmos_rcmos_dist * pixel_size * S2D_PIXEL_CONST;\n\tdouble reference_distance_in_pixels = zpi->reference_distance * pixel_size * S2D_PIXEL_CONST;\n\n\tmemset(depth_to_rgb, DEPTH_NO_MM_VALUE, DEPTH_MAX_METRIC_VALUE * sizeof(int32_t));\n\n\tfor (i = 0; i < DEPTH_MAX_METRIC_VALUE; i++) {\n\t\tdouble current_depth_in_pixels = i * pixel_size;\n\t\tdepth_to_rgb[i] = (( pixels_between_rgb_and_ir_cmos * (current_depth_in_pixels - reference_distance_in_pixels) / current_depth_in_pixels) + S2D_CONST_OFFSET) * REG_X_VAL_SCALE;\n\t}\n}", "path": "libfreenect/src/registration.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "// Same as freenect_apply_registration, but don't bother aligning to the RGB image\n", "func_signal": "FN_INTERNAL int freenect_apply_depth_to_mm(freenect_device* dev, uint8_t* input_packed, uint16_t* output_mm)", "code": "{\n\tfreenect_registration* reg = &(dev->registration);\n\tuint16_t unpack[8];\n\tuint32_t x,y,source_index = 8;\n\tfor (y = 0; y < DEPTH_Y_RES; y++) {\n\t\tfor (x = 0; x < DEPTH_X_RES; x++) {\n\t\t\t// get 8 pixels from the packed frame\n\t\t\tif (source_index == 8) {\n\t\t\t\tunpack_8_pixels( input_packed, unpack );\n\t\t\t\tsource_index = 0;\n\t\t\t\tinput_packed += 11;\n\t\t\t}\n\t\t\t// get the value at the current depth pixel, convert to millimeters\n\t\t\tuint16_t metric_depth = reg->raw_to_mm_shift[ unpack[source_index++] ];\n\t\t\toutput_mm[y * DEPTH_X_RES + x] = metric_depth < DEPTH_MAX_METRIC_VALUE ? metric_depth : DEPTH_MAX_METRIC_VALUE;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "libfreenect/src/registration.c", "commit_date": "2018-01-11 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/* Various */\n", "func_signal": "static char * parson_strndup(const char *string, size_t n)", "code": "{\n    char *output_string = (char*)parson_malloc(n + 1);\n    if (!output_string) {\n        return NULL;\n    }\n    output_string[n] = '\\0';\n    strncpy(output_string, string, n);\n    return output_string;\n}", "path": "libfreenect/fakenect/parson.c", "commit_date": "2017-11-22 00:00:00", "repo_name": "OpenKinect/libfreenect", "stars": 3501, "license": "None", "language": "c", "size": 2354}
{"docstring": "/* This is the core state machine that drives the client <-> upstream proxy.\n* We move through the initial handshake and authentication steps first and\n* end up (if all goes well) in the proxy state where we're just proxying\n* data between the client and upstream.\n*/\n", "func_signal": "static void tunnel_ssr_dispatcher(struct tunnel_ctx* tunnel, struct socket_ctx* socket)", "code": "{\n    struct client_ctx* ctx = (struct client_ctx*)tunnel->data;\n    struct server_env_t* env = ctx->env;\n    struct server_config* config = env->config;\n    struct socket_ctx* incoming = tunnel->incoming;\n    struct socket_ctx* outgoing = tunnel->outgoing;\n    const char* info = tunnel_stage_string(ctx->stage); (void)info;\n#if defined(__PRINT_INFO__)\n    if (tunnel_ssr_is_in_streaming(tunnel)) {\n        if (tunnel->in_streaming == false) {\n            tunnel->in_streaming = true;\n            pr_info(\"%s ...\", info);\n        }\n    } else {\n        pr_info(\"%s\", info);\n    }\n#endif\n    strncpy(tunnel->extra_info, info, 0x100 - 1);\n    ASSERT(config->over_tls_enable == false);\n    switch (ctx->stage) {\n    case tunnel_stage_handshake:\n        ASSERT(incoming->rdstate == socket_state_done);\n        incoming->rdstate = socket_state_stop;\n        do_handshake(tunnel);\n        break;\n    case tunnel_stage_handshake_replied:\n        ASSERT(incoming->wrstate == socket_state_done);\n        incoming->wrstate = socket_state_stop;\n        do_wait_client_app_s5_request(tunnel);\n        break;\n    case tunnel_stage_s5_request_from_client_app:\n        ASSERT(incoming->rdstate == socket_state_done);\n        incoming->rdstate = socket_state_stop;\n        do_parse_s5_request_from_client_app(tunnel);\n        break;\n    case tunnel_stage_s5_udp_accoc:\n        ASSERT(incoming->wrstate == socket_state_done);\n        incoming->wrstate = socket_state_stop;\n        tunnel->tunnel_shutdown(tunnel);\n        break;\n    case tunnel_stage_s5_response_done:\n        ASSERT(incoming->wrstate == socket_state_done);\n        incoming->wrstate = socket_state_stop;\n        socket_ctx_read(incoming, true);\n        ctx->stage = tunnel_stage_client_first_pkg;\n        break;\n    case tunnel_stage_client_first_pkg:\n        ASSERT(incoming->rdstate == socket_state_done);\n        incoming->rdstate = socket_state_stop;\n        do_common_connet_remote_server(tunnel);\n        break;\n    case tunnel_stage_resolve_ssr_server_host_done:\n        do_resolve_ssr_server_host_aftercare(tunnel);\n        break;\n    case tunnel_stage_connect_ssr_server_done:\n        do_ssr_send_auth_package_to_server(tunnel);\n        break;\n    case tunnel_stage_ssr_auth_sent:\n        ASSERT(outgoing->wrstate == socket_state_done);\n        outgoing->wrstate = socket_state_stop;\n        do_ssr_waiting_server_feedback(tunnel);\n        break;\n    case tunnel_stage_ssr_server_feedback_arrived:\n        ASSERT(outgoing->rdstate == socket_state_done);\n        outgoing->rdstate = socket_state_stop;\n        if (do_ssr_receipt_for_feedback(tunnel) == false) {\n            do_action_after_auth_server_success(tunnel);\n        }\n        break;\n    case tunnel_stage_ssr_receipt_to_server_sent:\n        ASSERT(outgoing->wrstate == socket_state_done);\n        outgoing->wrstate = socket_state_stop;\n        do_action_after_auth_server_success(tunnel);\n        break;\n    case tunnel_stage_auth_completion_done:\n        ASSERT(incoming->rdstate == socket_state_stop);\n        ASSERT(incoming->wrstate == socket_state_stop);\n        ASSERT(outgoing->rdstate == socket_state_stop);\n        ASSERT(outgoing->wrstate == socket_state_stop);\n        do_launch_streaming(tunnel);\n        break;\n    case tunnel_stage_streaming:\n        tunnel_ssr_client_streaming(tunnel, socket);\n        break;\n    case tunnel_stage_kill:\n        tunnel->tunnel_shutdown(tunnel);\n        break;\n    default:\n        UNREACHABLE();\n    }\n}", "path": "shadowsocksr-native/src/client/client.c", "commit_date": "2020-10-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "//\n// Maximum segment size\n// https://en.wikipedia.org/wiki/Maximum_segment_size\n//\n", "func_signal": "size_t get_fd_tcp_mss(uv_os_sock_t fd)", "code": "{\n#define NETWORK_MTU 1500\n#define SS_TCP_MSS (NETWORK_MTU - 40)\n\n    size_t tcp__mss = SS_TCP_MSS;\n\n    int mss = 0;\n    socklen_t len = sizeof(mss);\n\n    getsockopt(fd, IPPROTO_TCP, TCP_MAXSEG, (char*)&mss, &len);\n    if (50 < mss && mss <= NETWORK_MTU) {\n        tcp__mss = (size_t)mss;\n    }\n    return tcp__mss;\n}", "path": "shadowsocksr-native/src/tunnel.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/** Frees an allocated cache object\n *\n *  @param cache\n *  The cache object to free\n *\n *  @param keep_data\n *  Whether to free contained data or just delete references to it\n *\n *  @return EINVAL if cache is NULL, 0 otherwise\n */\n", "func_signal": "int\ncache_delete(struct cache *cache, int keep_data)", "code": "{\n    struct cache_entry *entry, *tmp;\n\n    if (!cache) {\n        return EINVAL;\n    }\n\n    if (keep_data) {\n        HASH_CLEAR(hh, cache->entries);\n    } else {\n        HASH_ITER(hh, cache->entries, entry, tmp){\n            HASH_DEL(cache->entries, entry);\n            if (entry->data != NULL) {\n                if (cache->free_cb) {\n                    cache->free_cb(entry->key, entry->data);\n                } else {\n                    safe_free(entry->data);\n                }\n            }\n            safe_free(entry->key);\n            safe_free(entry);\n        }\n    }\n\n    safe_free(cache);\n    return 0;\n}", "path": "shadowsocksr-native/src/cache.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/*\n * setuid() and setgid() for a specified user.\n */\n", "func_signal": "int\nrun_as(const char *user)", "code": "{\n#if !defined(__MINGW32__) && !defined(_WIN32)\n    if (user[0]) {\n        /* Convert user to a long integer if it is a non-negative number.\n         * -1 means it is a user name. */\n        long uid = -1;\n        if (ss_isnumeric(user)) {\n            errno = 0;\n            char *endptr;\n            uid = strtol(user, &endptr, 10);\n            if (errno || endptr == user)\n                uid = -1;\n        }\n\n#ifdef HAVE_GETPWNAM_R\n        struct passwd pwdbuf, *pwd;\n        memset(&pwdbuf, 0, sizeof(struct passwd));\n        size_t buflen;\n        int err;\n\n        for (buflen = 128;; buflen *= 2) {\n            char buf[buflen];  /* variable length array */\n\n            /* Note that we use getpwnam_r() instead of getpwnam(),\n             * which returns its result in a statically allocated buffer and\n             * cannot be considered thread safe. */\n            err = uid >= 0 ? getpwuid_r((uid_t)uid, &pwdbuf, buf, buflen, &pwd)\n                : getpwnam_r(user, &pwdbuf, buf, buflen, &pwd);\n\n            if (err == 0 && pwd) {\n                /* setgid first, because we may not be allowed to do it anymore after setuid */\n                if (setgid(pwd->pw_gid) != 0) {\n                    LOGE(\n                        \"Could not change group id to that of run_as user '%s': %s\",\n                        pwd->pw_name, strerror(errno));\n                    return 0;\n                }\n\n                if (initgroups(pwd->pw_name, pwd->pw_gid) == -1) {\n                    LOGE(\"Could not change supplementary groups for user '%s'.\", pwd->pw_name);\n                    return 0;\n                }\n\n                if (setuid(pwd->pw_uid) != 0) {\n                    LOGE(\n                        \"Could not change user id to that of run_as user '%s': %s\",\n                        pwd->pw_name, strerror(errno));\n                    return 0;\n                }\n                break;\n            } else if (err != ERANGE) {\n                if (err) {\n                    LOGE(\"run_as user '%s' could not be found: %s\", user,\n                            strerror(err));\n                } else {\n                    LOGE(\"run_as user '%s' could not be found.\", user);\n                }\n                return 0;\n            } else if (buflen >= 16 * 1024) {\n                /* If getpwnam_r() seems defective, call it quits rather than\n                 * keep on allocating ever larger buffers until we crash. */\n                LOGE(\n                    \"getpwnam_r() requires more than %u bytes of buffer space.\",\n                    (unsigned)buflen);\n                return 0;\n            }\n            /* Else try again with larger buffer. */\n        }\n#else\n        /* No getpwnam_r() :-(  We'll use getpwnam() and hope for the best. */\n        struct passwd *pwd;\n\n        if (!(pwd = uid >=0 ? getpwuid((uid_t)uid) : getpwnam(user))) {\n            LOGE(\"run_as user %s could not be found.\", user);\n            return 0;\n        }\n        /* setgid first, because we may not allowed to do it anymore after setuid */\n        if (setgid(pwd->pw_gid) != 0) {\n            LOGE(\"Could not change group id to that of run_as user '%s': %s\",\n                 pwd->pw_name, strerror(errno));\n            return 0;\n        }\n        if (initgroups(pwd->pw_name, (int)pwd->pw_gid) == -1) {\n            LOGE(\"Could not change supplementary groups for user '%s'.\", pwd->pw_name);\n            return 0;\n        }\n        if (setuid(pwd->pw_uid) != 0) {\n            LOGE(\"Could not change user id to that of run_as user '%s': %s\",\n                 pwd->pw_name, strerror(errno));\n            return 0;\n        }\n#endif\n    }\n\n#endif // __MINGW32__\n    return 1;\n}", "path": "shadowsocksr-native/src/ssrutils.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/** Inserts a given <key, value> pair into the cache\n *\n *  @param cache\n *  The cache object\n *\n *  @param key\n *  The key that identifies <value>\n *\n *  @param key_len\n *  The length of key\n *\n *  @param data\n *  Data associated with <key>\n *\n *  @return EINVAL if cache is NULL, ENOMEM if calloc fails, 0 otherwise\n */\n", "func_signal": "int\ncache_insert(struct cache *cache, char *key, size_t key_len, void *data)", "code": "{\n    struct cache_entry *entry     = NULL;\n    struct cache_entry *tmp_entry = NULL;\n\n    if (!cache) {\n        return EINVAL;\n    }\n\n    if ((entry = (struct cache_entry *) calloc(1, sizeof(*entry))) == NULL) {\n        return ENOMEM;\n    }\n\n    entry->key = (char *) calloc(key_len + 1, sizeof(char));\n    memcpy(entry->key, key, key_len);\n    entry->key[key_len] = 0;\n\n    entry->data = data;\n    entry->ts   = _ev_time();\n    HASH_ADD_KEYPTR(hh, cache->entries, entry->key, key_len, entry);\n\n    if (HASH_COUNT(cache->entries) >= cache->max_entries) {\n        HASH_ITER(hh, cache->entries, entry, tmp_entry){\n            HASH_DELETE(hh, cache->entries, entry);\n            if (entry->data != NULL) {\n                if (cache->free_cb) {\n                    cache->free_cb(entry->key, entry->data);\n                } else {\n                    safe_free(entry->data);\n                }\n            }\n            safe_free(entry->key);\n            safe_free(entry);\n            break;\n        }\n    }\n\n    return 0;\n}", "path": "shadowsocksr-native/src/cache.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/* Assumes that cx->outgoing.t.sa contains a valid AF_INET/AF_INET6 address. */\n", "func_signal": "static void do_connect_ssr_server(struct tunnel_ctx* tunnel)", "code": "{\n    struct client_ctx* ctx = (struct client_ctx*)tunnel->data;\n    struct server_config* config = ctx->env->config;\n    struct socket_ctx* incoming = tunnel->incoming;\n    struct socket_ctx* outgoing = tunnel->outgoing;\n    int err;\n\n    (void)config;\n    ASSERT(incoming->rdstate == socket_state_stop);\n    ASSERT(incoming->wrstate == socket_state_stop);\n    ASSERT(outgoing->rdstate == socket_state_stop);\n    ASSERT(outgoing->wrstate == socket_state_stop);\n\n    if (!can_access(tunnel, &outgoing->addr.addr)) {\n        pr_warn(\"connection not allowed by ruleset\");\n        /* Send a 'Connection not allowed by ruleset' reply. */\n        tunnel_socket_ctx_write(tunnel, incoming, \"\\5\\2\\0\\1\\0\\0\\0\\0\\0\\0\", 10);\n        ctx->stage = tunnel_stage_kill;\n        return;\n    }\n\n    err = socket_ctx_connect(outgoing);\n    if (err != 0) {\n        pr_err(\"connect error: %s\", uv_strerror(err));\n        tunnel->tunnel_shutdown(tunnel);\n        return;\n    }\n\n    ctx->stage = tunnel_stage_connect_ssr_server_done;\n}", "path": "shadowsocksr-native/src/client/client.c", "commit_date": "2020-10-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/* Assumes that c->t.sa contains a valid AF_INET or AF_INET6 address. */\n", "func_signal": "int socket_ctx_connect(struct socket_ctx* socket)", "code": "{\n    int result;\n    ASSERT(socket->addr.addr.sa_family == AF_INET || socket->addr.addr.sa_family == AF_INET6);\n    result = uv_tcp_connect(&socket->req.connect,\n        &socket->handle.tcp,\n        &socket->addr.addr,\n        uv_socket_connect_done_cb);\n    if (result == 0) {\n        socket_ctx_timer_start(socket);\n    }\n    return result;\n}", "path": "shadowsocksr-native/src/tunnel.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "//\n// ss:// BASE64-ENCODED-STRING-WITHOUT-PADDING(method:password@hostname:port) # remarks\n//\n", "func_signal": "struct server_config * decode_shadowsocks(const char *text)", "code": "{\n    struct server_config *config = NULL;\n    char *contents = NULL;\n    char *plain_text = NULL;\n\n    do {\n        size_t hdr_len;\n        char *remarks;\n        int len;\n        char *method;\n        char *password;\n        char *port;\n        char *hostname;\n        const char *t;\n\n        if (text == NULL || strlen(text)==0) {\n            break;\n        }\n        hdr_len = strlen(ss_header);\n        if (strncmp(text, ss_header, hdr_len) != 0) {\n            break;\n        }\n        text = text + hdr_len;\n        \n        contents = strdup(text);\n\n        remarks = strchr(contents, '#');\n        \n        if (remarks != NULL) {\n            *remarks++ = '\\0';\n        }\n\n        if (strcspn(contents, \"@:/?\") != strlen(contents)) {\n            // SS AEAD not support forever.\n            break;\n        }\n\n        len = (int) url_safe_base64_decode_len((unsigned char *)contents);\n        plain_text = (char *) calloc(len+1, sizeof(plain_text[0]));\n        url_safe_base64_decode((const unsigned char *)contents, (unsigned char *)plain_text);\n        \n        method = plain_text;\n\n        password = strchr(plain_text, ':');\n        if (password == NULL) {\n            break;\n        }\n        *password++ = '\\0';\n\n        port = strrchr(password, ':');\n        if (port == NULL) {\n            break;\n        }\n        *port++ = '\\0';\n        \n        hostname = strrchr(password, '@');\n        if (hostname == NULL) {\n            break;\n        }\n        *hostname++ = '\\0';\n\n        config = config_create();\n        string_safe_assign(&config->method, method);\n        string_safe_assign(&config->password, password);\n        string_safe_assign(&config->remote_host, hostname);\n        config->remote_port = atoi(port);\n        if (remarks) {\n            string_safe_assign(&config->remarks, remarks);\n        }\n\n        t = ssr_protocol_name_of_type(ssr_protocol_origin);\n        string_safe_assign(&config->protocol, t);\n        \n        t = ssr_obfs_name_of_type(ssr_obfs_plain);\n        string_safe_assign(&config->obfs, t);\n    } while (0);\n    \n    if (plain_text) {\n        free(plain_text);\n    }\n    \n    if (contents) {\n        free(contents);\n    }\n    \n    return config;\n}", "path": "shadowsocksr-native/src/ssr_qr_code.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/** Removes a cache entry\n *\n *  @param cache\n *  The cache object\n *\n *  @param key\n *  The key of the entry to remove\n *\n *  @param key_len\n *  The length of key\n *\n *  @return EINVAL if cache is NULL, 0 otherwise\n */\n", "func_signal": "int\ncache_remove(struct cache *cache, char *key, size_t key_len)", "code": "{\n    struct cache_entry *tmp;\n\n    if (!cache || !key) {\n        return EINVAL;\n    }\n\n    HASH_FIND(hh, cache->entries, key, key_len, tmp);\n\n    if (tmp) {\n        HASH_DEL(cache->entries, tmp);\n        if (tmp->data != NULL) {\n            if (cache->free_cb) {\n                cache->free_cb(tmp->key, tmp->data);\n            } else {\n                safe_free(tmp->data);\n            }\n        }\n        safe_free(tmp->key);\n        safe_free(tmp);\n    }\n\n    return 0;\n}", "path": "shadowsocksr-native/src/cache.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/** Checks if a given key is in the cache\n *\n *  @param cache\n *  The cache object\n *\n *  @param key\n *  The key to look-up\n *\n *  @param key_len\n *  The length of key\n *\n *  @param result\n *  Where to store the result if key is found.\n *\n *  A warning: Even though result is just a pointer,\n *  you have to call this function with a **ptr,\n *  otherwise this will blow up in your face.\n *\n *  @return EINVAL if cache is NULL, 0 otherwise\n */\n", "func_signal": "int\ncache_lookup(struct cache *cache, char *key, size_t key_len, void *result)", "code": "{\n    struct cache_entry *tmp = NULL;\n    char **dirty_hack       = result;\n\n    if (!cache || !key || !result) {\n        return EINVAL;\n    }\n\n    HASH_FIND(hh, cache->entries, key, key_len, tmp);\n    if (tmp) {\n        HASH_DELETE(hh, cache->entries, tmp);\n        tmp->ts = _ev_time();\n        HASH_ADD_KEYPTR(hh, cache->entries, tmp->key, key_len, tmp);\n        *dirty_hack = tmp->data;\n    } else {\n        *dirty_hack = result = NULL;\n    }\n\n    return 0;\n}", "path": "shadowsocksr-native/src/cache.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/** Clear old cache object\n *\n *  @param cache\n *  The cache object to clear\n *\n *  @param age\n *  Clear only objects older than the age (sec)\n *\n *  @return EINVAL if cache is NULL, 0 otherwise\n */\n", "func_signal": "int\ncache_clear(struct cache *cache, ev_tstamp age)", "code": "{\n    struct cache_entry *entry, *tmp;\n    ev_tstamp now;\n    if (!cache) {\n        return EINVAL;\n    }\n\n    now = _ev_time();\n\n    HASH_ITER(hh, cache->entries, entry, tmp){\n        if (now - entry->ts > age) {\n            HASH_DEL(cache->entries, entry);\n            if (entry->data != NULL) {\n                if (cache->free_cb) {\n                    cache->free_cb(entry->key, entry->data);\n                } else {\n                    safe_free(entry->data);\n                }\n            }\n            safe_free(entry->key);\n            safe_free(entry);\n        }\n    }\n\n    return 0;\n}", "path": "shadowsocksr-native/src/cache.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/** Creates a new cache object\n *\n *  @param dst\n *  Where the newly allocated cache object will be stored in\n *\n *  @param capacity\n *  The maximum number of elements this cache object can hold\n *\n *  @return EINVAL if dst is NULL, ENOMEM if calloc fails, 0 otherwise\n */\n", "func_signal": "int\ncache_create(struct cache **dst, size_t capacity,\n             void (*free_cb)(void *key, void *element))", "code": "{\n    struct cache *newObj = NULL;\n\n    if (!dst) {\n        return EINVAL;\n    }\n\n    if ((newObj = (struct cache *) calloc(1, sizeof(*newObj))) == NULL) {\n        return ENOMEM;\n    }\n\n    newObj->max_entries = capacity;\n    newObj->entries     = NULL;\n    newObj->free_cb     = free_cb;\n    *dst             = newObj;\n    return 0;\n}", "path": "shadowsocksr-native/src/cache.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/*\n                                * getopt --\n                                *      Parse argc/argv argument vector.\n                                */\n", "func_signal": "int getopt(int nargc, char * const nargv[], const char *ostr)", "code": "{\n    static char *place = EMSG;              /* option letter processing */\n    const char *oli;                              /* option letter list index */\n\n    if (optreset || !*place) {              /* update scanning pointer */\n        optreset = 0;\n        if (optind >= nargc || *(place = nargv[optind]) != '-') {\n            place = EMSG;\n            return (-1);\n        }\n        if (place[1] && *++place == '-') {      /* found \"--\" */\n            ++optind;\n            place = EMSG;\n            return (-1);\n        }\n    }                                       /* option letter okay? */\n    if ((optopt = (int)*place++) == (int)':' ||\n        !(oli = strchr(ostr, optopt))) {\n        /*\n        * if the user didn't specify '-' as an option,\n        * assume it means -1.\n        */\n        if (optopt == (int)'-')\n            return (-1);\n        if (!*place)\n            ++optind;\n        if (opterr && *ostr != ':')\n            (void)printf(\"illegal option -- %c\\n\", optopt);\n        return (BADCH);\n    }\n    if (*++oli != ':') {                    /* don't need argument */\n        optarg = NULL;\n        if (!*place)\n            ++optind;\n    } else {                                  /* need an argument */\n        if (*place)                     /* no white space */\n            optarg = place;\n        else if (nargc <= ++optind) {   /* no arg */\n            place = EMSG;\n            if (*ostr == ':')\n                return (BADARG);\n            if (opterr)\n                (void)printf(\"option requires an argument -- %c\\n\", optopt);\n            return (BADCH);\n        } else                            /* white space */\n            optarg = nargv[optind];\n        place = EMSG;\n        ++optind;\n    }\n    return (optopt);                        /* dump back option letter */\n}", "path": "shadowsocksr-native/win32/src/getopt.c", "commit_date": "2019-08-19 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "// __PRINT_INFO__\n", "func_signal": "struct socket_ctx* socket_context_create(uv_loop_t* loop, unsigned int idle_timeout)", "code": "{\n    struct socket_ctx* socket = (struct socket_ctx*)calloc(1, sizeof(*socket));\n    socket->result = 0;\n    socket->rdstate = socket_state_stop;\n    socket->wrstate = socket_state_stop;\n    socket->idle_timeout = idle_timeout;\n    VERIFY(0 == uv_timer_init(loop, &socket->timer_handle));\n    VERIFY(0 == uv_tcp_init(loop, &socket->handle.tcp));\n    socket_ctx_add_ref(socket);\n    return socket;\n}", "path": "shadowsocksr-native/src/tunnel.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/* \"protocol_param\":\"64#12345:breakwa11,233:breakwa11\", */\n", "func_signal": "void config_parse_protocol_param(struct server_config *config, const char *param)", "code": "{\n    char *p0 = strdup(param), *user_id = p0, *iter, *auth_key;\n    long int max_cli = 0;\n    iter = strchr(p0, '#');\n    if (iter) {\n        *iter = '\\0'; iter++;\n        p0 = strtrim(p0, trim_type_both, NULL);\n        max_cli = strtol(p0, NULL, 10);\n        user_id = iter;\n    }\n    config->max_client = (max_cli != 0) ? (unsigned int)max_cli : 64;\n\n    do {\n        iter = strchr(user_id, ',');\n        if (iter) {\n            *iter = '\\0'; iter++;\n        }\n\n        auth_key = strchr(user_id, ':');\n        if (auth_key) {\n            *auth_key = '\\0'; auth_key++;\n            user_id = strtrim(user_id, trim_type_both, NULL);\n            auth_key = strtrim(auth_key, trim_type_both, NULL);\n            config_add_user_id_with_auth_key(config, user_id, auth_key);\n        }\n\n        if (iter) {\n            user_id = iter;\n        }\n    } while (iter != NULL);\n\n    free(p0);\n}", "path": "shadowsocksr-native/src/ssr_executive.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "// insert shadowsocks header\n", "func_signal": "enum ssr_error tunnel_cipher_client_encrypt(struct tunnel_cipher_ctx *tc, struct buffer_t *buf)", "code": "{\n    int err;\n    struct obfs_t *obfs_plugin;\n    struct server_env_t *env = tc->env;\n    // SSR beg\n    struct obfs_t *protocol_plugin = tc->protocol;\n    size_t capacity;\n    buffer_realloc(buf, SSR_BUFF_SIZE);\n    capacity = buffer_get_capacity(buf);\n    if (protocol_plugin && protocol_plugin->client_pre_encrypt) {\n        size_t len = 0;\n        uint8_t *p = (uint8_t *) buffer_raw_clone(buf, &malloc, &len, &capacity);\n        len = (size_t) protocol_plugin->client_pre_encrypt(\n            tc->protocol, (char **)&p, (int)len, &capacity);\n        buffer_store(buf, p, len);\n        free(p);\n    }\n    err = ss_encrypt(env->cipher, buf, tc->e_ctx, SSR_BUFF_SIZE);\n    if (err != 0) {\n        return ssr_error_invalid_password;\n    }\n\n    obfs_plugin = tc->obfs;\n    if (obfs_plugin && obfs_plugin->client_encode) {\n        struct buffer_t* tmp = obfs_plugin->client_encode(obfs_plugin, buf);\n        buffer_replace(buf, tmp); buffer_release(tmp);\n    }\n    // SSR end\n    return ssr_ok;\n}", "path": "shadowsocksr-native/src/ssr_executive.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "//============================= tls1.2_ticket_fastauth ==================================\n", "func_signal": "struct obfs_t * tls12_ticket_fastauth_new_obfs(void)", "code": "{\n    struct obfs_t *obfs = tls12_ticket_auth_new_obfs();\n    ((struct tls12_ticket_auth_local_data*)obfs->l_data)->fastauth = true;\n    return obfs;\n}", "path": "shadowsocksr-native/src/obfs/tls1.2_ticket.c", "commit_date": "2020-05-25 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "// defined(__unix__) || defined(__linux__)\n", "func_signal": "int main(int argc, char * const argv[])", "code": "{\n    struct server_config *config = NULL;\n    int err = -1;\n    struct cmd_line_info *cmds = NULL;\n\n    #if (defined(__unix__) || defined(__linux__)) && !defined(__mips)\n    struct sigaction sa = { {&sighandler}, {{0}}, 0, NULL };\n    sigaction(SIGPIPE, &sa, NULL);\n    #endif // defined(__unix__) || defined(__linux__)\n\n    MEM_CHECK_BEGIN();\n    MEM_CHECK_BREAK_ALLOC(63);\n    MEM_CHECK_BREAK_ALLOC(64);\n    atexit(on_atexit);\n\n    do {\n        set_app_name(argv[0]);\n\n        cmds = cmd_line_info_create(argc, argv);\n\n        if (cmds == NULL) {\n            break;\n        }\n\n        if (cmds->help_flag) {\n            break;\n        }\n\n        if (cmds->cfg_file == NULL) {\n            string_safe_assign(&cmds->cfg_file, DEFAULT_CONF_PATH);\n        }\n\n        if ((config = parse_config_file(true, cmds->cfg_file)) == NULL) {\n            char* separ = NULL;\n            char* cfg_file = exe_file_path(&malloc);\n            if (cfg_file && ((separ = strrchr(cfg_file, PATH_SEPARATOR)))) {\n                ++separ;\n                strcpy(separ, CFG_JSON);\n                config = parse_config_file(true, cfg_file);\n            }\n            free(cfg_file);\n            if (config == NULL) {\n                break;\n            }\n        }\n\n        config_ssrot_revision(config);\n\n        config_parse_protocol_param(config, config->protocol_param);\n\n        if (config->method == NULL || config->password == NULL) {\n            break;\n        }\n\n        if (cmds->daemon_flag) {\n            char param[257] = { 0 };\n            sprintf(param, \"-c \\\"%s\\\"\", cmds->cfg_file);\n            daemon_wrapper(argv[0], param);\n        }\n\n        print_server_info(config);\n\n        ssr_server_run_loop(config, cmds->force_quit);\n\n        err = 0;\n    } while (0);\n\n    cmd_line_info_destroy(cmds);\n\n    config_release(config);\n\n    if (err != 0) {\n        svr_usage();\n    }\n    return 0;\n}", "path": "shadowsocksr-native/src/server/server.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "// =============================================================================\n// *\n// * SOCKS5 UDP Request / Response\n// * +----+------+------+----------+----------+----------+\n// * |RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |\n// * +----+------+------+----------+----------+----------+\n// * | 2  |  1   |  1   | Variable |    2     | Variable |\n// * +----+------+------+----------+----------+----------+\n// *\n", "func_signal": "const uint8_t * s5_parse_upd_package(const uint8_t *pkg, size_t len, struct socks5_address *dst_addr, size_t *frag_number, size_t *payload_len)", "code": "{\n    const uint8_t *result = NULL;\n    do {\n        const uint8_t *rsv, *frag, *address;\n        struct socks5_address dummy_addr = { {{0}}, 0, SOCKS5_ADDRTYPE_INVALID };\n        size_t offset;\n        if (pkg==NULL || len<10) {\n            break;\n        }\n        if (dst_addr == NULL) {\n            dst_addr = &dummy_addr;\n        }\n        rsv = pkg;\n        if ( *((uint16_t *)rsv) != 0) {\n            break;\n        }\n        frag = pkg + sizeof(uint16_t);\n        if (frag_number) {\n            *frag_number = (size_t)(*frag);\n        }\n        offset = sizeof(uint16_t) + sizeof(uint8_t);\n        address = pkg + offset;\n        if (socks5_address_parse(address, len - offset, dst_addr) == false) {\n            break;\n        }\n\n        offset += socks5_address_size(dst_addr);\n\n        result = pkg + offset;\n        if (payload_len) {\n            *payload_len = len - offset;\n        }\n    } while (false);\n    return result;\n}", "path": "shadowsocksr-native/src/client/s5.c", "commit_date": "2020-06-25 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "//\n// Since the obfuscation operation in SSRoT is redundant, we remove it.\n//\n", "func_signal": "void config_ssrot_revision(struct server_config* config)", "code": "{\n    if (config == NULL) {\n        return;\n    }\n    if (config->over_tls_enable) {\n        string_safe_assign(&config->obfs, ssr_obfs_name_of_type(ssr_obfs_plain));\n        // don't support protocol recently.\n        string_safe_assign(&config->protocol, ssr_protocol_name_of_type(ssr_protocol_origin));\n    } else {\n        // support UDP in SSRoT only.\n        config->udp = false;\n    }\n}", "path": "shadowsocksr-native/src/ssr_executive.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "ShadowsocksR-Live/shadowsocksr-native", "stars": 2724, "license": "gpl-3.0", "language": "c", "size": 4764}
{"docstring": "/* return v / 2^26, using only shifts and adds.\n *\n * On entry: v can take any value. */\n", "func_signal": "static limb div_by_2_26(const limb v)", "code": "{\n  /* High word of v; no shift needed. */\n  const px_dword highword = (px_dword) (((px_uint64) v) >> 32);\n  /* Set to all 1s if v was negative; else set to 0s. */\n  const px_int32 sign = ((px_int32) highword) >> 31;\n  /* Set to 0x3ffffff if v was negative; else set to 0. */\n  const px_int32 roundoff = ((px_dword) sign) >> 6;\n  /* Should return v / (1<<26) */\n  return (v + roundoff) >> 26;\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "//-------------------------------------------Lexer----------------------------------\n", "func_signal": "px_bool PX_LexerIsCharNumeric(px_char chr)", "code": "{\n\tif (chr>=('0')&&chr<=('9'))\n\t{\n\t\treturn PX_TRUE;\n\t}\n\treturn PX_FALSE;\n}", "path": "PainterEngine/kernel/PX_Lexer.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "//-------------------------------------------Comment----------------------------------\n", "func_signal": "px_char * PX_LexerIsCommentStart(px_lexer *lexer,const px_char ch[])", "code": "{\n\tpx_int i=0;\n\tfor (i=0;i<lexer->CommentCount;i++)\n\t{\n\t\tif(PX_memequ(ch,lexer->Comment[i].CommentBegin,PX_strlen(lexer->Comment[i].CommentBegin)))\n\t\t\treturn lexer->Comment[i].CommentBegin;\n\t}\n\treturn PX_NULL;\n}", "path": "PainterEngine/kernel/PX_Lexer.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* A helpful wrapper around fproduct: output = in * in2.\n *\n * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.\n *\n * output must be distinct to both inputs. The output is reduced degree\n * (indeed, one need only provide storage for 10 limbs) and |output[i]| < 2^26. */\n", "func_signal": "static void\nfmul(limb *output, const limb *in, const limb *in2)", "code": "{\n  limb t[19];\n  fproduct(t, in, in2);\n  /* |t[i]| < 14*2^54 */\n  freduce_degree(t);\n  freduce_coefficients(t);\n  /* |t[i]| < 2^26 */\n  PX_memcpy(output, t, sizeof(limb) * 10);\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "//--------------------------------------------Delimiter--------------------------------\n", "func_signal": "px_uint PX_LexerRegisterDelimiter(px_lexer *lexer,px_char Delimiter)", "code": "{\n\tpx_int i;\n\tif (lexer->DelimiterCount<PX_LEXER_CA_DELIMITER_MAX_COUNT)\n\t{\n\t\tfor (i=0;i<lexer->DelimiterCount;i++)\n\t\t{\n\t\t\tif (lexer->Delimiter[i]==Delimiter)\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tlexer->Delimiter[lexer->DelimiterCount++]=Delimiter;\n\t\treturn lexer->DelimiterCount-1;\n\t}\n\treturn -1;\n}", "path": "PainterEngine/kernel/PX_Lexer.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Take a fully reduced polynomial form number and contract it into a\n * little-endian, 32-byte array.\n *\n * On entry: |input_limbs[i]| < 2^26 */\n", "func_signal": "static void\nfcontract(px_byte *output, limb *input_limbs)", "code": "{\n  px_int i;\n  px_int j;\n  px_int32 input[10];\n  px_int32 mask;\n\n  /* |input_limbs[i]| < 2^26, so it's valid to convert to an s32. */\n  for (i = 0; i < 10; i++) {\n    input[i] = (px_int32)input_limbs[i];\n  }\n\n  for (j = 0; j < 2; ++j) {\n    for (i = 0; i < 9; ++i) {\n      if ((i & 1) == 1) {\n        /* This calculation is a time-invariant way to make input[i]\n         * non-negative by borrowing from the next-larger limb. */\n        const px_int32 mask = input[i] >> 31;\n        const px_int32 carry = -((input[i] & mask) >> 25);\n        input[i] = input[i] + (carry << 25);\n        input[i+1] = input[i+1] - carry;\n      } else {\n        const px_int32 mask = input[i] >> 31;\n        const px_int32 carry = -((input[i] & mask) >> 26);\n        input[i] = input[i] + (carry << 26);\n        input[i+1] = input[i+1] - carry;\n      }\n    }\n\n    /* There's no greater limb for input[9] to borrow from, but we can multiply\n     * by 19 and borrow from input[0], which is valid mod 2^255-19. */\n    {\n      const px_int32 mask = input[9] >> 31;\n      const px_int32 carry = -((input[9] & mask) >> 25);\n      input[9] = input[9] + (carry << 25);\n      input[0] = input[0] - (carry * 19);\n    }\n\n    /* After the first iteration, input[1..9] are non-negative and fit within\n     * 25 or 26 bits, depending on position. However, input[0] may be\n     * negative. */\n  }\n\n  /* The first borrow-propagation pass above ended with every limb\n     except (possibly) input[0] non-negative.\n\n     If input[0] was negative after the first pass, then it was because of a\n     carry from input[9]. On entry, input[9] < 2^26 so the carry was, at most,\n     one, since (2**26-1) >> 25 = 1. Thus input[0] >= -19.\n\n     In the second pass, each limb is decreased by at most one. Thus the second\n     borrow-propagation pass could only have wrapped around to decrease\n     input[0] again if the first pass left input[0] negative *and* input[1]\n     through input[9] were all zero.  In that case, input[1] is now 2^25 - 1,\n     and this last borrow-propagation step will leave input[1] non-negative. */\n  {\n    const px_int32 mask = input[0] >> 31;\n    const px_int32 carry = -((input[0] & mask) >> 26);\n    input[0] = input[0] + (carry << 26);\n    input[1] = input[1] - carry;\n  }\n\n  /* All input[i] are now non-negative. However, there might be values between\n   * 2^25 and 2^26 in a limb which is, nominally, 25 bits wide. */\n  for (j = 0; j < 2; j++) {\n    for (i = 0; i < 9; i++) {\n      if ((i & 1) == 1) {\n        const px_int32 carry = input[i] >> 25;\n        input[i] &= 0x1ffffff;\n        input[i+1] += carry;\n      } else {\n        const px_int32 carry = input[i] >> 26;\n        input[i] &= 0x3ffffff;\n        input[i+1] += carry;\n      }\n    }\n\n    {\n      const px_int32 carry = input[9] >> 25;\n      input[9] &= 0x1ffffff;\n      input[0] += 19*carry;\n    }\n  }\n\n  /* If the first carry-chain pass, just above, ended up with a carry from\n   * input[9], and that caused input[0] to be out-of-bounds, then input[0] was\n   * < 2^26 + 2*19, because the carry was, at most, two.\n   *\n   * If the second pass carried from input[9] again then input[0] is < 2*19 and\n   * the input[9] -> input[0] carry didn't push input[0] out of bounds. */\n\n  /* It still remains the case that input might be between 2^255-19 and 2^255.\n   * In this case, input[1..9] must take their maximum value and input[0] must\n   * be >= (2^255-19) & 0x3ffffff, which is 0x3ffffed. */\n  mask = s32_gte(input[0], 0x3ffffed);\n  for (i = 1; i < 10; i++) {\n    if ((i & 1) == 1) {\n      mask &= s32_eq(input[i], 0x1ffffff);\n    } else {\n      mask &= s32_eq(input[i], 0x3ffffff);\n    }\n  }\n\n  /* mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus\n   * this conditionally subtracts 2^255-19. */\n  input[0] -= mask & 0x3ffffed;\n\n  for (i = 1; i < 10; i++) {\n    if ((i & 1) == 1) {\n      input[i] -= mask & 0x1ffffff;\n    } else {\n      input[i] -= mask & 0x3ffffff;\n    }\n  }\n\n  input[1] <<= 2;\n  input[2] <<= 3;\n  input[3] <<= 5;\n  input[4] <<= 6;\n  input[6] <<= 1;\n  input[7] <<= 3;\n  input[8] <<= 4;\n  input[9] <<= 6;\n#define F(i, s) \\\n  output[s+0] |=  input[i] & 0xff; \\\n  output[s+1]  = (input[i] >> 8) & 0xff; \\\n  output[s+2]  = (input[i] >> 16) & 0xff; \\\n  output[s+3]  = (input[i] >> 24) & 0xff;\n  output[0] = 0;\n  output[16] = 0;\n  F(0,0);\n  F(1,3);\n  F(2,6);\n  F(3,9);\n  F(4,12);\n  F(5,16);\n  F(6,19);\n  F(7,22);\n  F(8,25);\n  F(9,28);\n#undef F\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Find the difference of two numbers: output = in - output\n * (note the order of the arguments!). */\n", "func_signal": "static void fdifference(limb *output, const limb *in)", "code": "{\n  unsigned i;\n  for (i = 0; i < 10; ++i) {\n    output[i] = in[i] - output[i];\n  }\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* fsquare sets output = in^2.\n *\n * On entry: The |in| argument is in reduced coefficients form and |in[i]| <\n * 2^27.\n *\n * On exit: The |output| argument is in reduced coefficients form (indeed, one\n * need only provide storage for 10 limbs) and |out[i]| < 2^26. */\n", "func_signal": "static void\nfsquare(limb *output, const limb *in)", "code": "{\n  limb t[19];\n  fsquare_inner(t, in);\n  /* |t[i]| < 14*2^54 because the largest product of two limbs will be <\n   * 2^(27+27) and fsquare_inner adds together, at most, 14 of those\n   * products. */\n  freduce_degree(t);\n  freduce_coefficients(t);\n  /* |t[i]| < 2^26 */\n  PX_memcpy(output, t, sizeof(limb) * 10);\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Reduce all coefficients of the short form input so that |x| < 2^26.\n *\n * On entry: |output[i]| < 280*2^54 */\n", "func_signal": "static void freduce_coefficients(limb *output)", "code": "{\n  unsigned i;\n\n  output[10] = 0;\n\n  for (i = 0; i < 10; i += 2) {\n    limb over = div_by_2_26(output[i]);\n    /* The entry condition (that |output[i]| < 280*2^54) means that over is, at\n     * most, 280*2^28 in the first iteration of this loop. This is added to the\n     * next limb and we can approximate the resulting bound of that limb by\n     * 281*2^54. */\n    output[i] -= over << 26;\n    output[i+1] += over;\n\n    /* For the first iteration, |output[i+1]| < 281*2^54, thus |over| <\n     * 281*2^29. When this is added to the next limb, the resulting bound can\n     * be approximated as 281*2^54.\n     *\n     * For subsequent iterations of the loop, 281*2^54 remains a conservative\n     * bound and no overflow occurs. */\n    over = div_by_2_25(output[i+1]);\n    output[i+1] -= over << 25;\n    output[i+2] += over;\n  }\n  /* Now |output[10]| < 281*2^29 and all other coefficients are reduced. */\n  output[0] += output[10] << 4;\n  output[0] += output[10] << 1;\n  output[0] += output[10];\n\n  output[10] = 0;\n\n  /* Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29\n   * So |over| will be no more than 2^16. */\n  {\n    limb over = div_by_2_26(output[0]);\n    output[0] -= over << 26;\n    output[1] += over;\n  }\n\n  /* Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The\n   * bound on |output[1]| is sufficient to meet our needs. */\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Multiply two numbers: output = in2 * in\n *\n * output must be distinct to both inputs. The inputs are reduced coefficient\n * form, the output is not.\n *\n * output[x] <= 14 * the largest product of the input limbs. */\n", "func_signal": "static void fproduct(limb *output, const limb *in2, const limb *in)", "code": "{\n  output[0] =       ((limb) ((px_int32) in2[0])) * ((px_int32) in[0]);\n  output[1] =       ((limb) ((px_int32) in2[0])) * ((px_int32) in[1]) +\n                    ((limb) ((px_int32) in2[1])) * ((px_int32) in[0]);\n  output[2] =  2 *  ((limb) ((px_int32) in2[1])) * ((px_int32) in[1]) +\n                    ((limb) ((px_int32) in2[0])) * ((px_int32) in[2]) +\n                    ((limb) ((px_int32) in2[2])) * ((px_int32) in[0]);\n  output[3] =       ((limb) ((px_int32) in2[1])) * ((px_int32) in[2]) +\n                    ((limb) ((px_int32) in2[2])) * ((px_int32) in[1]) +\n                    ((limb) ((px_int32) in2[0])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[3])) * ((px_int32) in[0]);\n  output[4] =       ((limb) ((px_int32) in2[2])) * ((px_int32) in[2]) +\n               2 * (((limb) ((px_int32) in2[1])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[3])) * ((px_int32) in[1])) +\n                    ((limb) ((px_int32) in2[0])) * ((px_int32) in[4]) +\n                    ((limb) ((px_int32) in2[4])) * ((px_int32) in[0]);\n  output[5] =       ((limb) ((px_int32) in2[2])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[3])) * ((px_int32) in[2]) +\n                    ((limb) ((px_int32) in2[1])) * ((px_int32) in[4]) +\n                    ((limb) ((px_int32) in2[4])) * ((px_int32) in[1]) +\n                    ((limb) ((px_int32) in2[0])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[5])) * ((px_int32) in[0]);\n  output[6] =  2 * (((limb) ((px_int32) in2[3])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[1])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[5])) * ((px_int32) in[1])) +\n                    ((limb) ((px_int32) in2[2])) * ((px_int32) in[4]) +\n                    ((limb) ((px_int32) in2[4])) * ((px_int32) in[2]) +\n                    ((limb) ((px_int32) in2[0])) * ((px_int32) in[6]) +\n                    ((limb) ((px_int32) in2[6])) * ((px_int32) in[0]);\n  output[7] =       ((limb) ((px_int32) in2[3])) * ((px_int32) in[4]) +\n                    ((limb) ((px_int32) in2[4])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[2])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[5])) * ((px_int32) in[2]) +\n                    ((limb) ((px_int32) in2[1])) * ((px_int32) in[6]) +\n                    ((limb) ((px_int32) in2[6])) * ((px_int32) in[1]) +\n                    ((limb) ((px_int32) in2[0])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[7])) * ((px_int32) in[0]);\n  output[8] =       ((limb) ((px_int32) in2[4])) * ((px_int32) in[4]) +\n               2 * (((limb) ((px_int32) in2[3])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[5])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[1])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[7])) * ((px_int32) in[1])) +\n                    ((limb) ((px_int32) in2[2])) * ((px_int32) in[6]) +\n                    ((limb) ((px_int32) in2[6])) * ((px_int32) in[2]) +\n                    ((limb) ((px_int32) in2[0])) * ((px_int32) in[8]) +\n                    ((limb) ((px_int32) in2[8])) * ((px_int32) in[0]);\n  output[9] =       ((limb) ((px_int32) in2[4])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[5])) * ((px_int32) in[4]) +\n                    ((limb) ((px_int32) in2[3])) * ((px_int32) in[6]) +\n                    ((limb) ((px_int32) in2[6])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[2])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[7])) * ((px_int32) in[2]) +\n                    ((limb) ((px_int32) in2[1])) * ((px_int32) in[8]) +\n                    ((limb) ((px_int32) in2[8])) * ((px_int32) in[1]) +\n                    ((limb) ((px_int32) in2[0])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[0]);\n  output[10] = 2 * (((limb) ((px_int32) in2[5])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[3])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[7])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[1])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[1])) +\n                    ((limb) ((px_int32) in2[4])) * ((px_int32) in[6]) +\n                    ((limb) ((px_int32) in2[6])) * ((px_int32) in[4]) +\n                    ((limb) ((px_int32) in2[2])) * ((px_int32) in[8]) +\n                    ((limb) ((px_int32) in2[8])) * ((px_int32) in[2]);\n  output[11] =      ((limb) ((px_int32) in2[5])) * ((px_int32) in[6]) +\n                    ((limb) ((px_int32) in2[6])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[4])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[7])) * ((px_int32) in[4]) +\n                    ((limb) ((px_int32) in2[3])) * ((px_int32) in[8]) +\n                    ((limb) ((px_int32) in2[8])) * ((px_int32) in[3]) +\n                    ((limb) ((px_int32) in2[2])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[2]);\n  output[12] =      ((limb) ((px_int32) in2[6])) * ((px_int32) in[6]) +\n               2 * (((limb) ((px_int32) in2[5])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[7])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[3])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[3])) +\n                    ((limb) ((px_int32) in2[4])) * ((px_int32) in[8]) +\n                    ((limb) ((px_int32) in2[8])) * ((px_int32) in[4]);\n  output[13] =      ((limb) ((px_int32) in2[6])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[7])) * ((px_int32) in[6]) +\n                    ((limb) ((px_int32) in2[5])) * ((px_int32) in[8]) +\n                    ((limb) ((px_int32) in2[8])) * ((px_int32) in[5]) +\n                    ((limb) ((px_int32) in2[4])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[4]);\n  output[14] = 2 * (((limb) ((px_int32) in2[7])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[5])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[5])) +\n                    ((limb) ((px_int32) in2[6])) * ((px_int32) in[8]) +\n                    ((limb) ((px_int32) in2[8])) * ((px_int32) in[6]);\n  output[15] =      ((limb) ((px_int32) in2[7])) * ((px_int32) in[8]) +\n                    ((limb) ((px_int32) in2[8])) * ((px_int32) in[7]) +\n                    ((limb) ((px_int32) in2[6])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[6]);\n  output[16] =      ((limb) ((px_int32) in2[8])) * ((px_int32) in[8]) +\n               2 * (((limb) ((px_int32) in2[7])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[7]));\n  output[17] =      ((limb) ((px_int32) in2[8])) * ((px_int32) in[9]) +\n                    ((limb) ((px_int32) in2[9])) * ((px_int32) in[8]);\n  output[18] = 2 *  ((limb) ((px_int32) in2[9])) * ((px_int32) in[9]);\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "// -----------------------------------------------------------------------------\n// Shamelessly copied from djb's code\n// -----------------------------------------------------------------------------\n", "func_signal": "static void\ncrecip(limb *out, const limb *z)", "code": "{\n  limb z2[10];\n  limb z9[10];\n  limb z11[10];\n  limb z2_5_0[10];\n  limb z2_10_0[10];\n  limb z2_20_0[10];\n  limb z2_50_0[10];\n  limb z2_100_0[10];\n  limb t0[10];\n  limb t1[10];\n  px_int i;\n\n  /* 2 */ fsquare(z2,z);\n  /* 4 */ fsquare(t1,z2);\n  /* 8 */ fsquare(t0,t1);\n  /* 9 */ fmul(z9,t0,z);\n  /* 11 */ fmul(z11,z9,z2);\n  /* 22 */ fsquare(t0,z11);\n  /* 2^5 - 2^0 = 31 */ fmul(z2_5_0,t0,z9);\n\n  /* 2^6 - 2^1 */ fsquare(t0,z2_5_0);\n  /* 2^7 - 2^2 */ fsquare(t1,t0);\n  /* 2^8 - 2^3 */ fsquare(t0,t1);\n  /* 2^9 - 2^4 */ fsquare(t1,t0);\n  /* 2^10 - 2^5 */ fsquare(t0,t1);\n  /* 2^10 - 2^0 */ fmul(z2_10_0,t0,z2_5_0);\n\n  /* 2^11 - 2^1 */ fsquare(t0,z2_10_0);\n  /* 2^12 - 2^2 */ fsquare(t1,t0);\n  /* 2^20 - 2^10 */ for (i = 2;i < 10;i += 2) { fsquare(t0,t1); fsquare(t1,t0); }\n  /* 2^20 - 2^0 */ fmul(z2_20_0,t1,z2_10_0);\n\n  /* 2^21 - 2^1 */ fsquare(t0,z2_20_0);\n  /* 2^22 - 2^2 */ fsquare(t1,t0);\n  /* 2^40 - 2^20 */ for (i = 2;i < 20;i += 2) { fsquare(t0,t1); fsquare(t1,t0); }\n  /* 2^40 - 2^0 */ fmul(t0,t1,z2_20_0);\n\n  /* 2^41 - 2^1 */ fsquare(t1,t0);\n  /* 2^42 - 2^2 */ fsquare(t0,t1);\n  /* 2^50 - 2^10 */ for (i = 2;i < 10;i += 2) { fsquare(t1,t0); fsquare(t0,t1); }\n  /* 2^50 - 2^0 */ fmul(z2_50_0,t0,z2_10_0);\n\n  /* 2^51 - 2^1 */ fsquare(t0,z2_50_0);\n  /* 2^52 - 2^2 */ fsquare(t1,t0);\n  /* 2^100 - 2^50 */ for (i = 2;i < 50;i += 2) { fsquare(t0,t1); fsquare(t1,t0); }\n  /* 2^100 - 2^0 */ fmul(z2_100_0,t1,z2_50_0);\n\n  /* 2^101 - 2^1 */ fsquare(t1,z2_100_0);\n  /* 2^102 - 2^2 */ fsquare(t0,t1);\n  /* 2^200 - 2^100 */ for (i = 2;i < 100;i += 2) { fsquare(t1,t0); fsquare(t0,t1); }\n  /* 2^200 - 2^0 */ fmul(t1,t0,z2_100_0);\n\n  /* 2^201 - 2^1 */ fsquare(t0,t1);\n  /* 2^202 - 2^2 */ fsquare(t1,t0);\n  /* 2^250 - 2^50 */ for (i = 2;i < 50;i += 2) { fsquare(t0,t1); fsquare(t1,t0); }\n  /* 2^250 - 2^0 */ fmul(t0,t1,z2_50_0);\n\n  /* 2^251 - 2^1 */ fsquare(t1,t0);\n  /* 2^252 - 2^2 */ fsquare(t0,t1);\n  /* 2^253 - 2^3 */ fsquare(t1,t0);\n  /* 2^254 - 2^4 */ fsquare(t0,t1);\n  /* 2^255 - 2^5 */ fsquare(t1,t0);\n  /* 2^255 - 21 */ fmul(out,t1,z11);\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  TransformFunction\n//\n//  Compress 512-bits\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "static\nvoid\n    TransformFunction\n    (\n        PX_Sha256Context*      Context,\n        px_uchar const*      Buffer\n    )", "code": "{\n    px_uint32    S[8];\n    px_uint32    W[64];\n    px_uint32    t0;\n    px_uint32    t1;\n    px_uint32    t;\n    int         i;\n\n    // Copy state into S\n    for( i=0; i<8; i++ )\n    {\n        S[i] = Context->state[i];\n    }\n\n    // Copy the state into 512-bits into W[0..15]\n    for( i=0; i<16; i++ )\n    {\n        LOAD32H( W[i], Buffer + (4*i) );\n    }\n\n    // Fill W[16..63]\n    for( i=16; i<64; i++ )\n    {\n        W[i] = Gamma1( W[i-2]) + W[i-7] + Gamma0( W[i-15] ) + W[i-16];\n    }\n\n    // Compress\n    for( i=0; i<64; i++ )\n    {\n        Sha256Round( S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i );\n        t = S[7];\n        S[7] = S[6];\n        S[6] = S[5];\n        S[5] = S[4];\n        S[4] = S[3];\n        S[3] = S[2];\n        S[2] = S[1];\n        S[1] = S[0];\n        S[0] = t;\n    }\n\n    // Feedback\n    for( i=0; i<8; i++ )\n    {\n        Context->state[i] = Context->state[i] + S[i];\n    }\n}", "path": "PainterEngine/core/PX_Sha256.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* s32_eq returns 0xffffffff iff a == b and zero otherwise. */\n", "func_signal": "static px_int32 s32_eq(px_int32 a, px_int32 b)", "code": "{\n  a = ~(a ^ b);\n  a &= a << 16;\n  a &= a << 8;\n  a &= a << 4;\n  a &= a << 2;\n  a &= a << 1;\n  return a >> 31;\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Calculates nQ where Q is the x-coordinate of a point on the curve\n *\n *   resultx/resultz: the x coordinate of the resulting curve point (short form)\n *   n: a little endian, 32-byte number\n *   q: a point of the curve (short form) */\n", "func_signal": "static void\ncmult(limb *resultx, limb *resultz, const px_byte *n, const limb *q)", "code": "{\n  limb a[19] = {0}, b[19] = {1}, c[19] = {1}, d[19] = {0};\n  limb *nqpqx = a, *nqpqz = b, *nqx = c, *nqz = d, *t;\n  limb e[19] = {0}, f[19] = {1}, g[19] = {0}, h[19] = {1};\n  limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;\n\n  unsigned i, j;\n\n  PX_memcpy(nqpqx, (void *)q, sizeof(limb) * 10);\n\n  for (i = 0; i < 32; ++i) {\n    px_byte byte = n[31 - i];\n    for (j = 0; j < 8; ++j) {\n      const limb bit = byte >> 7;\n\n      swap_conditional(nqx, nqpqx, bit);\n      swap_conditional(nqz, nqpqz, bit);\n      fmonty(nqx2, nqz2,\n             nqpqx2, nqpqz2,\n             nqx, nqz,\n             nqpqx, nqpqz,\n             q);\n      swap_conditional(nqx2, nqpqx2, bit);\n      swap_conditional(nqz2, nqpqz2, bit);\n\n      t = nqx;\n      nqx = nqx2;\n      nqx2 = t;\n      t = nqz;\n      nqz = nqz2;\n      nqz2 = t;\n      t = nqpqx;\n      nqpqx = nqpqx2;\n      nqpqx2 = t;\n      t = nqpqz;\n      nqpqz = nqpqz2;\n      nqpqz2 = t;\n\n      byte <<= 1;\n    }\n  }\n\n  PX_memcpy(resultx, nqx, sizeof(limb) * 10);\n  PX_memcpy(resultz, nqz, sizeof(limb) * 10);\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Conditionally swap two reduced-form limb arrays if 'iswap' is 1, but leave\n * them unchanged if 'iswap' is 0.  Runs in data-invariant time to avoid\n * side-channel attacks.\n *\n * NOTE that this function requires that 'iswap' be 1 or 0; other values give\n * wrong results.  Also, the two limb arrays must be in reduced-coefficient,\n * reduced-degree form: the values in a[10..19] or b[10..19] aren't swapped,\n * and all all values in a[0..9],b[0..9] must have magnitude less than\n * INT32_MAX. */\n", "func_signal": "static void\nswap_conditional(limb a[19], limb b[19], limb iswap)", "code": "{\n  unsigned i;\n  const px_int32 swap = (px_int32) -iswap;\n\n  for (i = 0; i < 10; ++i) {\n    const px_int32 x = swap & ( ((px_int32)a[i]) ^ ((px_int32)b[i]) );\n    a[i] = ((px_int32)a[i]) ^ x;\n    b[i] = ((px_int32)b[i]) ^ x;\n  }\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "//--------------------------------------------Spacer-----------------------------------\n", "func_signal": "px_void PX_LexerRegisterSpacer(px_lexer *lexer,px_char Spacer)", "code": "{\n\tpx_int i;\n\tif (lexer->SpacerCount<PX_LEXER_CA_SPACER_MAX_COUNT)\n\t{\n\t\tfor (i=0;i<lexer->SpacerCount;i++)\n\t\t{\n\t\t\tif (lexer->Spacer[i]==Spacer)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlexer->Spacer[lexer->SpacerCount++]=Spacer;\n\t}\n}", "path": "PainterEngine/kernel/PX_Lexer.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* s32_gte returns 0xffffffff if a >= b and zero otherwise, where a and b are\n * both non-negative. */\n", "func_signal": "static px_int32 s32_gte(px_int32 a, px_int32 b)", "code": "{\n  a -= b;\n  /* a >= 0 iff a >= b. */\n  return ~(a >> 31);\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Reduce a long form to a short form by taking the input mod 2^255 - 19.\n *\n * On entry: |output[i]| < 14*2^54\n * On exit: |output[0..8]| < 280*2^54 */\n", "func_signal": "static void freduce_degree(limb *output)", "code": "{\n  /* Each of these shifts and adds ends up multiplying the value by 19.\n   *\n   * For output[0..8], the absolute entry value is < 14*2^54 and we add, at\n   * most, 19*14*2^54 thus, on exit, |output[0..8]| < 280*2^54. */\n  output[8] += output[18] << 4;\n  output[8] += output[18] << 1;\n  output[8] += output[18];\n  output[7] += output[17] << 4;\n  output[7] += output[17] << 1;\n  output[7] += output[17];\n  output[6] += output[16] << 4;\n  output[6] += output[16] << 1;\n  output[6] += output[16];\n  output[5] += output[15] << 4;\n  output[5] += output[15] << 1;\n  output[5] += output[15];\n  output[4] += output[14] << 4;\n  output[4] += output[14] << 1;\n  output[4] += output[14];\n  output[3] += output[13] << 4;\n  output[3] += output[13] << 1;\n  output[3] += output[13];\n  output[2] += output[12] << 4;\n  output[2] += output[12] << 1;\n  output[2] += output[12];\n  output[1] += output[11] << 4;\n  output[1] += output[11] << 1;\n  output[1] += output[11];\n  output[0] += output[10] << 4;\n  output[0] += output[10] << 1;\n  output[0] += output[10];\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Multiply a number by a scalar: output = in * scalar */\n", "func_signal": "static void fscalar_product(limb *output, const limb *in, const limb scalar)", "code": "{\n  unsigned i;\n  for (i = 0; i < 10; ++i) {\n    output[i] = in[i] * scalar;\n  }\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* return v / (2^25), using only shifts and adds.\n *\n * On entry: v can take any value. */\n", "func_signal": "static limb div_by_2_25(const limb v)", "code": "{\n  /* High word of v; no shift needed*/\n  const px_dword highword = (px_dword) (((px_uint64) v) >> 32);\n  /* Set to all 1s if v was negative; else set to 0s. */\n  const px_int32 sign = ((px_int32) highword) >> 31;\n  /* Set to 0x1ffffff if v was negative; else set to 0. */\n  const px_int32 roundoff = ((px_dword) sign) >> 7;\n  /* Should return v / (1<<25) */\n  return (v + roundoff) >> 25;\n}", "path": "PainterEngine/core/PX_curve25519.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "matrixcascade/PainterEngine", "stars": 2187, "license": "mit", "language": "c", "size": 31848}
{"docstring": "/* Packet parsing helpers.\n *\n * Each helper parses a packet header, including doing bounds checking, and\n * returns the type of its contents if successful, and -1 otherwise.\n *\n * For Ethernet and IP headers, the content type is the type of the payload\n * (h_proto for Ethernet, nexthdr for IPv6), for ICMP it is the ICMP type field.\n * All return values are in host byte order.\n */\n", "func_signal": "static __always_inline int parse_ethhdr(struct hdr_cursor *nh,\n\t\t\t\t\tvoid *data_end,\n\t\t\t\t\tstruct ethhdr **ethhdr)", "code": "{\n\tstruct ethhdr *eth = nh->pos;\n\tint hdrsize = sizeof(*eth);\n\n\t/* Byte-count bounds check; check if current pointer + size of header\n\t * is after data_end.\n\t */\n\tif (nh->pos + 1 > data_end)\n\t\treturn -1;\n\n\tnh->pos += hdrsize;\n\t*ethhdr = eth;\n\n\treturn eth->h_proto; /* network-byte-order */\n}", "path": "xdp-tutorial/packet01-parsing/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Assignment 4: Complete this router program */\n", "func_signal": "SEC(\"xdp_router\")\nint xdp_router_func(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct bpf_fib_lookup fib_params = {};\n\tstruct ethhdr *eth = data;\n\tstruct ipv6hdr *ip6h;\n\tstruct iphdr *iph;\n\t__u16 h_proto;\n\t__u64 nh_off;\n\tint rc;\n\tint action = XDP_PASS;\n\n\tnh_off = sizeof(*eth);\n\tif (data + nh_off > data_end) {\n\t\taction = XDP_DROP;\n\t\tgoto out;\n\t}\n\n\th_proto = eth->h_proto;\n\tif (h_proto == bpf_htons(ETH_P_IP)) {\n\t\tiph = data + nh_off;\n\n\t\tif (iph + 1 > data_end) {\n\t\t\taction = XDP_DROP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (iph->ttl <= 1)\n\t\t\tgoto out;\n\n\t\t/* Assignment 4: fill the fib_params structure for the AF_INET case */\n\t} else if (h_proto == bpf_htons(ETH_P_IPV6)) {\n\t\t/* These pointers can be used to assign structures instead of executing memcpy: */\n\t\t/* struct in6_addr *src = (struct in6_addr *) fib_params.ipv6_src; */\n\t\t/* struct in6_addr *dst = (struct in6_addr *) fib_params.ipv6_dst; */\n\n\t\tip6h = data + nh_off;\n\t\tif (ip6h + 1 > data_end) {\n\t\t\taction = XDP_DROP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ip6h->hop_limit <= 1)\n\t\t\tgoto out;\n\n\t\t/* Assignment 4: fill the fib_params structure for the AF_INET6 case */\n\t} else {\n\t\tgoto out;\n\t}\n\n\tfib_params.ifindex = ctx->ingress_ifindex;\n\n\trc = bpf_fib_lookup(ctx, &fib_params, sizeof(fib_params), 0);\n\tswitch (rc) {\n\tcase BPF_FIB_LKUP_RET_SUCCESS:         /* lookup successful */\n\t\tif (h_proto == bpf_htons(ETH_P_IP))\n\t\t\tip_decrease_ttl(iph);\n\t\telse if (h_proto == bpf_htons(ETH_P_IPV6))\n\t\t\tip6h->hop_limit--;\n\n\t\t/* Assignment 4: fill in the eth destination and source\n\t\t * addresses and call the bpf_redirect_map function */\n\t\t/* memcpy(eth->h_dest, ???, ETH_ALEN); */\n\t\t/* memcpy(eth->h_source, ???, ETH_ALEN); */\n\t\t/* action = bpf_redirect_map(&tx_port, ???, 0); */\n\t\tbreak;\n\tcase BPF_FIB_LKUP_RET_BLACKHOLE:    /* dest is blackholed; can be dropped */\n\tcase BPF_FIB_LKUP_RET_UNREACHABLE:  /* dest is unreachable; can be dropped */\n\tcase BPF_FIB_LKUP_RET_PROHIBIT:     /* dest not allowed; can be dropped */\n\t\taction = XDP_DROP;\n\t\tbreak;\n\tcase BPF_FIB_LKUP_RET_NOT_FWDED:    /* packet is not forwarded */\n\tcase BPF_FIB_LKUP_RET_FWD_DISABLED: /* fwding is not enabled on ingress */\n\tcase BPF_FIB_LKUP_RET_UNSUPP_LWT:   /* fwd requires encapsulation */\n\tcase BPF_FIB_LKUP_RET_NO_NEIGH:     /* no neighbor entry for nh */\n\tcase BPF_FIB_LKUP_RET_FRAG_NEEDED:  /* fragmentation required to fwd */\n\t\t/* PASS */\n\t\tbreak;\n\t}\n\nout:\n\treturn xdp_stats_record_action(ctx, action);\n}", "path": "xdp-tutorial/packet03-redirecting/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* BPF_MAP_TYPE_ARRAY */\n", "func_signal": "void map_get_value_array(int fd, __u32 key, struct datarec *value)", "code": "{\n\tif ((bpf_map_lookup_elem(fd, &key, value)) != 0) {\n\t\tfprintf(stderr,\n\t\t\t\"ERR: bpf_map_lookup_elem failed key:0x%X\\n\", key);\n\t}\n}", "path": "xdp-tutorial/basic04-pinning-maps/xdp_stats.c", "commit_date": "2019-08-01 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/*\n * This BPF-prog will drop all packets, but pass verifier checks.\n *\n * General idea: Use packet length to find and access last byte.\n */\n", "func_signal": "SEC(\"xdp_fail1\")\nint _xdp_fail1(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tunsigned char *ptr;\n\tvoid *pos;\n\n\tunsigned int offset = data_end - data;\n\n\tpos = data;\n\toffset &= 0x7FFF; /* Bound/limit max value to help verifier */\n\n\tpos += offset;\n\n\t/* Below +1 will cause all packet to be dropped, as it will be\n\t * longer than packet length (just calc as offset).\n\t */\n\tif (pos + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\tptr = pos;\n\tif (*ptr == 0xFF)\n\t\treturn XDP_ABORTED;\n\n\treturn XDP_PASS;\n}", "path": "xdp-tutorial/experiment01-tailgrow/xdp_prog_kern3.c", "commit_date": "2020-05-07 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* BPF_MAP_TYPE_PERCPU_ARRAY */\n", "func_signal": "void map_get_value_percpu_array(int fd, __u32 key, struct datarec *value)", "code": "{\n\t/* For percpu maps, userspace gets a value per possible CPU */\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tstruct datarec values[nr_cpus];\n\t__u64 sum_bytes = 0;\n\t__u64 sum_pkts = 0;\n\tint i;\n\n\tif ((bpf_map_lookup_elem(fd, &key, values)) != 0) {\n\t\tfprintf(stderr,\n\t\t\t\"ERR: bpf_map_lookup_elem failed key:0x%X\\n\", key);\n\t\treturn;\n\t}\n\n\t/* Sum values from each CPU */\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tsum_pkts  += values[i].rx_packets;\n\t\tsum_bytes += values[i].rx_bytes;\n\t}\n\tvalue->rx_packets = sum_pkts;\n\tvalue->rx_bytes   = sum_bytes;\n}", "path": "xdp-tutorial/basic-solutions/xdp_stats.c", "commit_date": "2020-06-06 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Solution to the parsing exercise in lesson packet01. Handles VLANs and legacy\n * IP (via the helpers in parsing_helpers.h).\n */\n", "func_signal": "SEC(\"xdp_packet_parser\")\nint  xdp_parser_func(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\n\t/* Default action XDP_PASS, imply everything we couldn't parse, or that\n\t * we don't want to deal with, we just pass up the stack and let the\n\t * kernel deal with it.\n\t */\n\t__u32 action = XDP_PASS; /* Default action */\n\n\t/* These keep track of the next header type and iterator pointer */\n\tstruct hdr_cursor nh;\n\tint nh_type;\n\tnh.pos = data;\n\n\tstruct ethhdr *eth;\n\n\t/* Packet parsing in steps: Get each header one at a time, aborting if\n\t * parsing fails. Each helper function does sanity checking (is the\n\t * header type in the packet correct?), and bounds checking.\n\t */\n\tnh_type = parse_ethhdr(&nh, data_end, &eth);\n\n\tif (nh_type == bpf_htons(ETH_P_IPV6)) {\n\t\tstruct ipv6hdr *ip6h;\n\t\tstruct icmp6hdr *icmp6h;\n\n\t\tnh_type = parse_ip6hdr(&nh, data_end, &ip6h);\n\t\tif (nh_type != IPPROTO_ICMPV6)\n\t\t\tgoto out;\n\n\t\tnh_type = parse_icmp6hdr(&nh, data_end, &icmp6h);\n\t\tif (nh_type != ICMPV6_ECHO_REQUEST)\n\t\t\tgoto out;\n\n\t\tif (bpf_ntohs(icmp6h->icmp6_sequence) % 2 == 0)\n\t\t\taction = XDP_DROP;\n\n\t} else if (nh_type == bpf_htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph;\n\t\tstruct icmphdr *icmph;\n\n\t\tnh_type = parse_iphdr(&nh, data_end, &iph);\n\t\tif (nh_type != IPPROTO_ICMP)\n\t\t\tgoto out;\n\n\t\tnh_type = parse_icmphdr(&nh, data_end, &icmph);\n\t\tif (nh_type != ICMP_ECHO)\n\t\t\tgoto out;\n\n\t\tif (bpf_ntohs(icmph->un.echo.sequence) % 2 == 0)\n\t\t\taction = XDP_DROP;\n\t}\n out:\n\treturn xdp_stats_record_action(ctx, action);\n}", "path": "xdp-tutorial/packet02-rewriting/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Assignment 3: Implement and use this */\n/*static __always_inline int parse_icmp6hdr(struct hdr_cursor *nh,\n\t\t\t\t\t  void *data_end,\n\t\t\t\t\t  struct icmp6hdr **icmp6hdr)\n{\n}*/\n", "func_signal": "SEC(\"xdp_packet_parser\")\nint  xdp_parser_func(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct ethhdr *eth;\n\n\t/* Default action XDP_PASS, imply everything we couldn't parse, or that\n\t * we don't want to deal with, we just pass up the stack and let the\n\t * kernel deal with it.\n\t */\n\t__u32 action = XDP_PASS; /* Default action */\n\n        /* These keep track of the next header type and iterator pointer */\n\tstruct hdr_cursor nh;\n\tint nh_type;\n\n\t/* Start next header cursor position at data start */\n\tnh.pos = data;\n\n\t/* Packet parsing in steps: Get each header one at a time, aborting if\n\t * parsing fails. Each helper function does sanity checking (is the\n\t * header type in the packet correct?), and bounds checking.\n\t */\n\tnh_type = parse_ethhdr(&nh, data_end, &eth);\n\tif (nh_type != bpf_htons(ETH_P_IPV6))\n\t\tgoto out;\n\n\t/* Assignment additions go below here */\n\n\taction = XDP_DROP;\nout:\n\treturn xdp_stats_record_action(ctx, action); /* read via xdp_stats */\n}", "path": "xdp-tutorial/packet01-parsing/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* to u64 in host order */\n", "func_signal": "static inline __u64 ether_addr_to_u64(const __u8 *addr)", "code": "{\n\t__u64 u = 0;\n\tint i;\n\n\tfor (i = ETH_ALEN; i >= 0; i--)\n\t\tu = u << 8 | addr[i];\n\treturn u;\n}", "path": "xdp-tutorial/tracing03-xdp-debug-print/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Assignment 3: nothing to do here, patch the xdp_prog_user.c program */\n", "func_signal": "SEC(\"xdp_redirect_map\")\nint xdp_redirect_map_func(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct hdr_cursor nh;\n\tstruct ethhdr *eth;\n\tint eth_type;\n\tint action = XDP_PASS;\n\tunsigned char *dst;\n\n\t/* These keep track of the next header type and iterator pointer */\n\tnh.pos = data;\n\n\t/* Parse Ethernet and IP/IPv6 headers */\n\teth_type = parse_ethhdr(&nh, data_end, &eth);\n\tif (eth_type == -1)\n\t\tgoto out;\n\n\t/* Do we know where to redirect this packet? */\n\tdst = bpf_map_lookup_elem(&redirect_params, eth->h_source);\n\tif (!dst)\n\t\tgoto out;\n\n\t/* Set a proper destination address */\n\tmemcpy(eth->h_dest, dst, ETH_ALEN);\n\taction = bpf_redirect_map(&tx_port, 0, 0);\n\nout:\n\treturn xdp_stats_record_action(ctx, action);\n}", "path": "xdp-tutorial/packet03-redirecting/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Pops the outermost VLAN tag off the packet. Returns the popped VLAN ID on\n * success or -1 on failure.\n */\n", "func_signal": "static __always_inline int vlan_tag_pop(struct xdp_md *ctx, struct ethhdr *eth)", "code": "{\n\t/*\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tstruct ethhdr eth_cpy;\n\tstruct vlan_hdr *vlh;\n\t__be16 h_proto;\n\t*/\n\tint vlid = -1;\n\n\t/* Check if there is a vlan tag to pop */\n\n\t/* Still need to do bounds checking */\n\n\t/* Save vlan ID for returning, h_proto for updating Ethernet header */\n\n\t/* Make a copy of the outer Ethernet header before we cut it off */\n\n\t/* Actually adjust the head pointer */\n\n\t/* Need to re-evaluate data *and* data_end and do new bounds checking\n\t * after adjusting head\n\t */\n\n\t/* Copy back the old Ethernet header and update the proto type */\n\n\n\treturn vlid;\n}", "path": "xdp-tutorial/packet02-rewriting/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* BPF_MAP_TYPE_ARRAY */\n", "func_signal": "void map_get_value_array(int fd, __u32 key, struct datarec *value)", "code": "{\n\tif ((bpf_map_lookup_elem(fd, &key, value)) != 0) {\n\t\tfprintf(stderr,\n\t\t\t\"ERR: bpf_map_lookup_elem failed key:0x%X\\n\", key);\n\t}\n}", "path": "xdp-tutorial/basic-solutions/xdp_stats.c", "commit_date": "2020-06-06 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Notice, parse_ethhdr() will skip VLAN tags, by advancing nh->pos and returns\n * next header EtherType, BUT the ethhdr pointer supplied still points to the\n * Ethernet header. Thus, caller can look at eth->h_proto to see if this was a\n * VLAN tagged packet.\n */\n", "func_signal": "static __always_inline int parse_ethhdr(struct hdr_cursor *nh, void *data_end,\n\t\t\t\t\tstruct ethhdr **ethhdr)", "code": "{\n\tstruct ethhdr *eth = nh->pos;\n\tint hdrsize = sizeof(*eth);\n\tstruct vlan_hdr *vlh;\n\t__u16 h_proto;\n\tint i;\n\n\t/* Byte-count bounds check; check if current pointer + size of header\n\t * is after data_end.\n\t */\n\tif (nh->pos + hdrsize > data_end)\n\t\treturn -1;\n\n\tnh->pos += hdrsize;\n\t*ethhdr = eth;\n\tvlh = nh->pos;\n\th_proto = eth->h_proto;\n\n\t/* Use loop unrolling to avoid the verifier restriction on loops;\n\t * support up to VLAN_MAX_DEPTH layers of VLAN encapsulation.\n\t */\n\t#pragma unroll\n\tfor (i = 0; i < VLAN_MAX_DEPTH; i++) {\n\t\tif (!proto_is_vlan(h_proto))\n\t\t\tbreak;\n\n\t\tif (vlh + 1 > data_end)\n\t\t\tbreak;\n\n\t\th_proto = vlh->h_vlan_encapsulated_proto;\n\t\tvlh++;\n\t}\n\n\tnh->pos = vlh;\n\treturn h_proto; /* network-byte-order */\n}", "path": "xdp-tutorial/packet-solutions/xdp_vlan01_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Assignment 2 */\n", "func_signal": "SEC(\"xdp_redirect\")\nint xdp_redirect_func(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct hdr_cursor nh;\n\tstruct ethhdr *eth;\n\tint eth_type;\n\tint action = XDP_PASS;\n\t/* unsigned char dst[ETH_ALEN] = {} */\t/* Assignment 2: fill in with the MAC address of the left inner interface */\n\t/* unsigned ifindex = 0; */\t\t/* Assignment 2: fill in with the ifindex of the left interface */\n\n\t/* These keep track of the next header type and iterator pointer */\n\tnh.pos = data;\n\n\t/* Parse Ethernet and IP/IPv6 headers */\n\teth_type = parse_ethhdr(&nh, data_end, &eth);\n\tif (eth_type == -1)\n\t\tgoto out;\n\n\t/* Assignment 2: set a proper destination address and call the\n\t * bpf_redirect() with proper parameters, action = bpf_redirect(...) */\n\nout:\n\treturn xdp_stats_record_action(ctx, action);\n}", "path": "xdp-tutorial/packet03-redirecting/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* For benchmarking tail grow overhead (does a memset)*/\n", "func_signal": "SEC(\"xdp_tailgrow_tx\")\nint tailgrow_tx(struct xdp_md *ctx)", "code": "{\n\tint offset;\n\n\toffset = 32;\n\tbpf_xdp_adjust_tail(ctx, offset);\n\treturn xdp_stats_record_action(ctx, XDP_TX);\n}", "path": "xdp-tutorial/experiment01-tailgrow/xdp_prog_kern.c", "commit_date": "2020-05-05 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Implement packet03/assignment-1 in this section */\n", "func_signal": "SEC(\"xdp_icmp_echo\")\nint xdp_icmp_echo_func(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct hdr_cursor nh;\n\tstruct ethhdr *eth;\n\tint eth_type;\n\tint ip_type;\n\tint icmp_type;\n\tstruct iphdr *iphdr;\n\tstruct ipv6hdr *ipv6hdr;\n\t__u16 echo_reply;\n\tstruct icmphdr_common *icmphdr;\n\t__u32 action = XDP_PASS;\n\n\t/* These keep track of the next header type and iterator pointer */\n\tnh.pos = data;\n\n\t/* Parse Ethernet and IP/IPv6 headers */\n\teth_type = parse_ethhdr(&nh, data_end, &eth);\n\tif (eth_type == bpf_htons(ETH_P_IP)) {\n\t\tip_type = parse_iphdr(&nh, data_end, &iphdr);\n\t\tif (ip_type != IPPROTO_ICMP)\n\t\t\tgoto out;\n\t} else if (eth_type == bpf_htons(ETH_P_IPV6)) {\n\t\tip_type = parse_ip6hdr(&nh, data_end, &ipv6hdr);\n\t\tif (ip_type != IPPROTO_ICMPV6)\n\t\t\tgoto out;\n\t} else {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We are using a special parser here which returns a stucture\n\t * containing the \"protocol-independent\" part of an ICMP or ICMPv6\n\t * header.  For purposes of this Assignment we are not interested in\n\t * the rest of the structure.\n\t */\n\ticmp_type = parse_icmphdr_common(&nh, data_end, &icmphdr);\n\tif (eth_type == bpf_htons(ETH_P_IP) && icmp_type == ICMP_ECHO) {\n\t\t/* Swap IP source and destination */\n\t\tswap_src_dst_ipv4(iphdr);\n\t\techo_reply = ICMP_ECHOREPLY;\n\t} else if (eth_type == bpf_htons(ETH_P_IPV6)\n\t\t   && icmp_type == ICMPV6_ECHO_REQUEST) {\n\t\t/* Swap IPv6 source and destination */\n\t\tswap_src_dst_ipv6(ipv6hdr);\n\t\techo_reply = ICMPV6_ECHO_REPLY;\n\t} else {\n\t\tgoto out;\n\t}\n\n\t/* Swap Ethernet source and destination */\n\tswap_src_dst_mac(eth);\n\n\t/* Assignment 1: patch the packet and update the checksum. You can use\n\t * the echo_reply variable defined above to fix the ICMP Type field. */\n\n\taction = XDP_TX;\n\nout:\n\treturn xdp_stats_record_action(ctx, action);\n}", "path": "xdp-tutorial/packet03-redirecting/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* VLAN swapper; will pop outermost VLAN tag if it exists, otherwise push a new\n * one with ID 1. Use this for assignments 2 and 3.\n */\n", "func_signal": "SEC(\"xdp_vlan_swap\")\nint xdp_vlan_swap_func(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\n\t/* These keep track of the next header type and iterator pointer */\n\tstruct hdr_cursor nh;\n\tint nh_type;\n\tnh.pos = data;\n\n\tstruct ethhdr *eth;\n\tnh_type = parse_ethhdr(&nh, data_end, &eth);\n\tif (nh_type < 0)\n\t\treturn XDP_PASS;\n\n\t/* Assignment 2 and 3 will implement these. For now they do nothing */\n\tif (proto_is_vlan(eth->h_proto))\n\t\tvlan_tag_pop(ctx, eth);\n\telse\n\t\tvlan_tag_push(ctx, eth, 1);\n\n\treturn XDP_PASS;\n}", "path": "xdp-tutorial/packet02-rewriting/xdp_prog_kern.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* Pointer swap trick */\n", "func_signal": "static inline void swap(struct stats_record **a, struct stats_record **b)", "code": "{\n\tstruct stats_record *tmp;\n\n\ttmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}", "path": "xdp-tutorial/tracing02-xdp-monitor/trace_load_and_stats.c", "commit_date": "2019-05-26 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* BPF_MAP_TYPE_PERCPU_ARRAY */\n", "func_signal": "void map_get_value_percpu_array(int fd, __u32 key, struct datarec *value)", "code": "{\n\t/* For percpu maps, userspace gets a value per possible CPU */\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tstruct datarec values[nr_cpus];\n\t__u64 sum_bytes = 0;\n\t__u64 sum_pkts = 0;\n\tint i;\n\n\tif ((bpf_map_lookup_elem(fd, &key, values)) != 0) {\n\t\tfprintf(stderr,\n\t\t\t\"ERR: bpf_map_lookup_elem failed key:0x%X\\n\", key);\n\t\treturn;\n\t}\n\n\t/* Sum values from each CPU */\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tsum_pkts  += values[i].rx_packets;\n\t\tsum_bytes += values[i].rx_bytes;\n\t}\n\tvalue->rx_packets = sum_pkts;\n\tvalue->rx_bytes   = sum_bytes;\n}", "path": "xdp-tutorial/basic04-pinning-maps/xdp_stats.c", "commit_date": "2019-08-01 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/* moved to parsing_helpers.h */\n/* Based on parse_ethhdr() */\n", "func_signal": "static __always_inline int __parse_ethhdr_vlan(struct hdr_cursor *nh,\n\t\t\t\t\t       void *data_end,\n\t\t\t\t\t       struct ethhdr **ethhdr,\n\t\t\t\t\t       struct collect_vlans *vlans)", "code": "{\n\tstruct ethhdr *eth = nh->pos;\n\tint hdrsize = sizeof(*eth);\n\tstruct vlan_hdr *vlh;\n\t__u16 h_proto;\n\tint i;\n\n\t/* Byte-count bounds check; check if current pointer + size of header\n\t * is after data_end.\n\t */\n\tif (nh->pos + hdrsize > data_end)\n\t\treturn -1;\n\n\tnh->pos += hdrsize;\n\t*ethhdr = eth;\n\tvlh = nh->pos;\n\th_proto = eth->h_proto;\n\n\t/* Use loop unrolling to avoid the verifier restriction on loops;\n\t * support up to VLAN_MAX_DEPTH layers of VLAN encapsulation.\n\t */\n\t#pragma unroll\n\tfor (i = 0; i < VLAN_MAX_DEPTH; i++) {\n\t\tif (!proto_is_vlan(h_proto))\n\t\t\tbreak;\n\n\t\tif (vlh + 1 > data_end)\n\t\t\tbreak;\n\n\t\th_proto = vlh->h_vlan_encapsulated_proto;\n\t\tif (vlans) {\n\t\t\tvlans->id[i] =\n\t\t\t\tbpf_ntohs(vlh->h_vlan_TCI) & VLAN_VID_MASK;\n\t\t}\n\t\tvlh++;\n\t}\n\n\tnh->pos = vlh;\n\treturn h_proto; /* network-byte-order */\n}", "path": "xdp-tutorial/packet-solutions/xdp_vlan02_kern.c", "commit_date": "2020-11-15 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/*\n * This BPF-prog will FAIL, due to verifier rejecting it.\n *\n * General idea: Use data_end point to access last (2nd-last) byte in\n * packet.  That is not allowed by verifier, as pointer arithmetic on\n * pkt_end is prohibited.\n */\n", "func_signal": "SEC(\"xdp_fail2\")\nint _xdp_fail2(struct xdp_md *ctx)", "code": "{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvolatile unsigned char *ptr;\n\tvolatile void *pos;\n\n\tpos = data_end;\n\n#pragma clang optimize off\n\tif (pos - 1 > data_end)\n\t\tgoto out;\n#pragma clang optimize on\n\n\t/* Verifier fails with: \"pointer arithmetic on pkt_end prohibited\"\n\t */\n\tptr = pos - 2;\n\tif (*ptr == 0xFF)\n\t\treturn XDP_ABORTED;\nout:\n\treturn XDP_PASS;\n}", "path": "xdp-tutorial/experiment01-tailgrow/xdp_prog_fail2.c", "commit_date": "2020-05-05 00:00:00", "repo_name": "xdp-project/xdp-tutorial", "stars": 2167, "license": "None", "language": "c", "size": 657}
{"docstring": "/**\n * \\brief TODO Document getstring()\n *\n * \\param[in] r0\n * \\param[in] c0\n * \\param[in] rn\n * \\param[in] cn\n * \\param[in] fd\n *\n * \\return none\n */\n", "func_signal": "void getstring(int r0, int c0, int rn, int cn, FILE * fd)", "code": "{\n    struct ent    **pp;\n    int        r, c;\n\n    for (r = r0; r <= rn; r++) {\n        for (c = c0, pp = ATBL(tbl, r, c); c <= cn; pp++, c++) {\n            *line = '\\0';\n            if (*pp && (*pp)->label)\n                sprintf(line, \"%s\", (*pp)->label);\n            sc_value(\"%s\", line);\n            if (brokenpipe) {\n                linelim = -1;\n                return;\n            }\n        }\n    }\n    linelim = -1;\n}", "path": "sc-im/src/pipe.c", "commit_date": "2018-05-31 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/* this function asks user for input from stdin.\n * should be non blocking and should\n * return -1 when no key was press\n * return 0 when key was press.\n * it receives * wint_t as a parameter.\n * when a valid key is press, its value its then updated in that wint_t variable.\n */\n", "func_signal": "int ui_getch(wint_t * wd)", "code": "{\n    char c;\n    int i=0;\n    nonblock(NB_ENABLE);\n    while (!i) {\n        usleep(1);\n        i=kbhit();\n        if (i!=0) {\n            c = fgetc(stdin);\n            //printf(\"\\n you hit %c. \\n\",c);\n            nonblock(NB_DISABLE);\n            *wd = (wint_t) c;\n            return 0;\n        }\n    }\n    return -1;\n}", "path": "sc-im/examples/ui_example/tui.c", "commit_date": "2017-05-02 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief TODO Document atocol()\n *\n * \\details Given a token string starting with a symbolid column name and\n * its valid length, convert column namd (\"A\"-\"Z\" or \"AA\"-\"ZZ\") to a\n * column number (0-N). Never mind if the column number is illegal\n * (too high). The procedure's name and function are the inverse of coltoa().\n *\n * \\details Case-insensitivity is done crudely, but ignoring the 040 bit.\n *\n * \\return none\n */\n", "func_signal": "int atocol(char *string, int len)", "code": "{\n    register int col;\n\n    col = (toupper(string[0])) - 'A';\n\n    if (len == 2)        /* has second char */\n        col = ((col + 1) * 26) + ((toupper(string[1])) - 'A');\n\n    return (col);\n}", "path": "sc-im/src/lex.c", "commit_date": "2019-09-08 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief TODO Document replace_maps()\n *\n * \\param[in] b\n *\n * \\return r\n */\n", "func_signal": "int replace_maps (struct block * b)", "code": "{\n    int r = 0;\n\n    if (++mapdepth == 1000) {\n        sc_error(\"recursive mapping\");\n        flush_buf(b);\n        mapdepth = 0;\n        return 0;\n    }\n\n    // Traverse session mappings\n    map * m = maps;\n    while (m != NULL) {\n        // Check if a mapping already exists in 'b' buffer\n        int pos = block_in_block(b, m->in);\n        if (pos != -1 && m->mode == curmode) {\n\n            // Replace m->in with m->out in 'b' list\n            if (replace_block_in_block(b, m->in, m->out) == -1) {\n                sc_error(\"error replacing maps\");\n                return -1;\n            }\n            r = 1;\n            break;\n        }\n        m = m->psig;\n    }\n\n    if (r && m->recursive) replace_maps(b);  // recursive mapping here!\n    return r;\n}", "path": "sc-im/src/maps.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/* this function asks user for input from stdin.\n * should be blocking and should\n * return -1 when ESC was pressed\n * return 0 otherwise.\n * it receives * wint_t as a parameter.\n * when a valid key is press, its value its then updated in that wint_t variable.\n */\n", "func_signal": "int ui_getch_b(wint_t * wd)", "code": "{\n    printf(\"calling uigetch_b\\n\");\n\n    char c;\n    int i=0;\n    nonblock(NB_DISABLE);\n    while (!i) {\n        usleep(1);\n        i=kbhit();\n        if (i!=0) {\n            c = fgetc(stdin);\n            if (c == 27) {\n                nonblock(NB_ENABLE);\n                return -1;\n            }\n            printf(\"you hit %d %c\\n\", c, c);\n            *wd = (wint_t) c;\n            nonblock(NB_ENABLE);\n            return 0;\n        }\n    }\n    nonblock(NB_ENABLE);\n    return -1;\n}", "path": "sc-im/examples/ui_example/tui.c", "commit_date": "2017-05-02 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief TODO Document get_hlist_from_history()\n *\n * \\param[in] h\n * \\param[in] pos\n * \n * \\return none\n */\n", "func_signal": "struct hlist * get_hlist_from_history(struct history * h, int pos)", "code": "{\n    if (h->len <= - pos) return NULL;\n    int i;\n    struct hlist * nl = h->list;\n\n    for (i=0; i<-pos; i++) {\n        nl = nl->pnext;\n    }\n    return nl;\n}", "path": "sc-im/src/history.c", "commit_date": "2019-06-16 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "// Save mapping's details in a char*\n/**\n * \\brief Save mapping's details in a char*\n *\n * \\param[in] salida\n *\n * \\return none\n */\n", "func_signal": "void get_mappings(char * salida)", "code": "{\n   salida[0]='\\0';\n   if (maps == NULL) return;\n   char min[MAXMAPITEM] = \"\";\n   char mout[MAXMAPITEM] = \"\";\n   char nore[5] = \"\";\n\n   char mode = '\\0';\n   int i = 0;\n   map * m = maps;\n\n   while (m != NULL) {\n       i++;\n       nore[0] = '\\0';\n       switch (m->mode) {\n            case NORMAL_MODE:\n                mode = 'n';\n                break;\n\n            case INSERT_MODE:\n                mode = 'i';\n                break;\n       }\n       get_mapstr_buf(m->in, min);\n       get_mapstr_buf(m->out, mout);\n       if (!m->recursive) strcpy(nore, \"nore\");\n       sprintf(salida + strlen(salida), \"%3d + %c%smap \\\"%s\\\" = \\\"%s\\\"\\n\", i, mode, nore, min, mout);\n       m = m->psig;\n   }\n   return;\n}", "path": "sc-im/src/maps.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "// FIXME - pass fd is not neccesary?\n/**\n * \\brief TODO Document getnum()\n *\n * \\param[in] r0\n * \\param[in] c0\n * \\param[in] rn\n * \\param[in] cn\n * \\param[in[ df\n *\n * \\return none\n */\n", "func_signal": "void getnum(int r0, int c0, int rn, int cn, FILE * fd)", "code": "{\n    struct ent ** pp;\n    struct ent * p;\n    int r, c;\n\n    for (r = r0; r <= rn; r++) {\n        for (c = c0, pp = ATBL(tbl, r, c); c <= cn; pp++, c++) {\n            *line = '\\0';\n            p = *pp;\n            if (p) {\n                if (p->cellerror) {\n                    sprintf(line, \"%s\", (*pp)->cellerror == CELLERROR ?  \"ERROR\" : \"INVALID\");\n                } else if (p->flags & is_valid) {\n                    sprintf(line, \"%.15g\", p->v);\n                }\n            }\n            sc_value(\"%s\", line);\n            if (brokenpipe) {\n                linelim = -1;\n                return;\n            }\n\n        }\n    }\n    linelim = -1;\n}", "path": "sc-im/src/pipe.c", "commit_date": "2018-05-31 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "// Welcome screen\n", "func_signal": "void ui_do_welcome()", "code": "{\n    printf(\"welcome screen\\n\");\n    return;\n}", "path": "sc-im/examples/ui_example/tui.c", "commit_date": "2017-05-02 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief TODO <brief function description>\n *\n * \\details Find a history element and move it. Starts from POS\n * pos=0 first element, pos=-1 second element. Returns 1 if moved,\n * 0 otherwise\n *\n * \\param[in] h\n * \\param[in] item\n * \\param[in] pos\n *\n * \\returns: 1 if moved; 0 otherwise\n */\n", "func_signal": "int move_item_from_history_by_str(struct history * h, wchar_t * item, int pos)", "code": "{\n    if (h->len - 1 < -pos || pos == 0 || ! wcslen(item)) return 0; // Move the first element is not allowed\n    struct hlist * nl = h->list;\n    if (nl != NULL && !wcscmp(item, nl->line)) return 1;\n    struct hlist * n_ant = NULL;\n    int i;\n\n    for (i=0; i<-pos; i++) {\n        n_ant = nl;\n        nl = nl->pnext;\n    }\n    for (i=-pos; i < h->len ; i++) {\n        if (wcscmp(item, nl->line) == 0) break;\n        n_ant = nl;\n        nl = nl->pnext;\n    }\n    if (i >= h->len) return 0;\n    n_ant->pnext = nl->pnext;\n    if (nl->pnext != NULL) nl->pnext->pant = n_ant;\n\n    nl->pant = NULL;\n    nl->pnext = h->list;\n    h->list->pant = nl;\n    h->list = nl;\n\n    return 1;\n}", "path": "sc-im/src/history.c", "commit_date": "2019-06-16 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief TODO Document load_history\n *\n * \\details Read the specified history file from the user's home directory\n * and load it into the specified history struct.\n *\n * \\param[in] h\n * \\param[in] mode\n *\n * returns: none\n */\n", "func_signal": "void load_history(struct history * h, wchar_t mode)", "code": "{\n    char infofile[PATHLEN];\n    wchar_t linea[FBUFLEN];\n    int c;\n    char * home;\n    FILE * f;\n\n    if ((home = getenv(\"HOME\"))) {\n        sprintf(infofile, \"%s/%s/%s\", home,HISTORY_DIR,HISTORY_FILE);\n        if ((c = open(infofile, O_RDONLY)) > -1) {\n            close(c);\n            f = fopen(infofile, \"r\");\n            if (f == NULL) return;\n            while ( feof(f) == 0 ) {\n                if (!fgetws(linea, sizeof(linea) / sizeof(*linea), f)) break;\n                int s = wcslen(linea)-1;\n                del_range_wchars(linea, s, s);\n\n                if (linea[0] == mode && mode == L':') {\n                    del_range_wchars(linea, 0, 0);\n                    add(h, linea);\n                } else if (mode != L':' && (linea[0] == L'=' || linea[0] == L'<' || linea[0] == L'>' || linea[0] == L'\\\\')) {\n                    add(h, linea);\n                }\n            }\n            fclose(f);\n        }\n    }\n\n    return;\n}", "path": "sc-im/src/history.c", "commit_date": "2019-06-16 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief Remove history element\n *\n * \\return 0 first element; -1 second element\n */\n", "func_signal": "void del_item_from_history(struct history * h, int pos)", "code": "{\n    if (h->len - 1 < -pos) return;\n\n    struct hlist * nl = h->list;\n    struct hlist * n_ant = NULL;\n    int i;\n\n    if (pos == 0) {\n        h->list = nl->pnext;\n        if (nl->pnext != NULL) nl->pnext->pant = NULL;\n    } else {\n        for (i=0; i<-pos; i++) {\n            n_ant = nl;\n            nl = nl->pnext;\n        }\n        n_ant->pnext = nl->pnext;\n        if (nl->pnext != NULL) nl->pnext->pant = n_ant;\n    }\n    free(nl->line);\n    free(nl);\n    h->len--;\n\n    return;\n}", "path": "sc-im/src/history.c", "commit_date": "2019-06-16 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief TODO Document getexp()\n *\n * \\param[in] r0\n * \\param[in] c0\n * \\param[in] rn\n * \\param[in] cn\n * \\param[in] fd\n *\n * \\return none\n */\n", "func_signal": "void getexp(int r0, int c0, int rn, int cn, FILE * fd)", "code": "{\n    struct ent    **pp;\n    struct ent    *p;\n    int        r, c;\n\n    for (r = r0; r <= rn; r++) {\n        for (c = c0, pp = ATBL(tbl, r, c); c <= cn; pp++, c++) {\n            *line = '\\0';\n            p = *pp;\n            if (p && p->expr) {\n                linelim = 0;\n                decompile(p->expr, 0);    /* set line to expr */\n                line[linelim] = '\\0';\n                if (*line == '?')\n                    *line = '\\0';\n            }\n            sc_value(\"%s\", line);\n            if (brokenpipe) {\n                linelim = -1;\n                return;\n            }\n        }\n    }\n    linelim = -1;\n}", "path": "sc-im/src/pipe.c", "commit_date": "2018-05-31 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "// error routine for yacc (gram.y)\n", "func_signal": "void yyerror(char * err)", "code": "{\n    printf(\"%s: %.*s<=%s\\n\", err, linelim, line, line + linelim);\n    return;\n}", "path": "sc-im/examples/ui_example/tui.c", "commit_date": "2017-05-02 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * @brief Save history to file\n *\n * \\return 0 on success; -1 otherwise\n */\n", "func_signal": "int save_history(struct history * h, char * mode)", "code": "{\n    char infofile [PATHLEN];\n    char * home;\n    FILE * f;\n    int i;\n    struct hlist * nl = h->list;\n    if ((home = getenv(\"HOME\"))) {\n        char history_dir[PATHLEN];\n        sprintf(history_dir, \"%s/%s\", home,HISTORY_DIR);\n        mkdir(history_dir,0777);\n        sprintf(infofile, \"%s/%s/%s\", home,HISTORY_DIR,HISTORY_FILE);\n        f = fopen(infofile, mode);\n        if (f == NULL) return 0;\n        // Go to the end\n        for (i=1; i < h->len; i++) {\n            nl = nl->pnext;\n        }\n        // Traverse list back to front, so the history is saved in chronological order\n        for (i=0; i < h->len; i++) {\n            if (! strcmp(mode, \"w\")) fwprintf(f, L\":\"); // mode 'w' means we are saving the command mode history\n            fwprintf(f, L\"%ls\\n\", nl->line);\n            nl = nl->pant;\n        }\n        fclose(f);\n        return 1;\n    }\n    return 0;\n}", "path": "sc-im/src/history.c", "commit_date": "2019-06-16 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief Remove mappings and free corresponding memory\n *\n * \\return none\n */\n", "func_signal": "void del_maps ()", "code": "{\n    map * m = maps;\n    map * e = m;\n    while (m != NULL) {\n        e = m->psig;\n        erase_buf(m->out);\n        erase_buf(m->in);\n        free(m);\n        m = e;\n    }\n    return;\n}", "path": "sc-im/src/maps.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "// function that refreshes grid of screen\n// if header flag is set, the first column of screen gets refreshed\n", "func_signal": "void ui_update(int header)", "code": "{\n    printf(\"update\\n\");\n    printf(\"value of current cell: %d %d %f\\n\", currow, curcol, lookat(currow, curcol)->v);\n    return;\n}", "path": "sc-im/examples/ui_example/tui.c", "commit_date": "2017-05-02 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief Ammend a mapping to the curren session\n *\n * \\param[in] in\n * \\param[in] out\n * \\param[in] mode\n * \\param[in] recursive\n *\n * \\return none\n */\n", "func_signal": "void add_map(char * in, char * out, int mode, short recursive)", "code": "{\n    map * m;\n\n    // If the mapping already exists, replace its content, saving it position\n    int exists = exists_map(in, mode);\n    if (exists == -1) {\n        m = (map *) malloc (sizeof(map));\n    } else {\n        m = maps;\n        while (exists--) m = m->psig;\n        erase_buf(m->in);\n        erase_buf(m->out);\n        exists = TRUE;\n    }\n\n    m->out = (struct block *) get_mapbuf_str(out);\n    m->in = (struct block *) get_mapbuf_str(in);\n    m->mode = mode;\n    m->recursive = recursive;\n\n    if (exists == TRUE) return; // in case a map was updated and not created!\n\n// Insert at the beginning\n//    m->psig = maps == NULL ? NULL : maps;\n//    maps = m;\n\n    // Insert at the end\n    m->psig= NULL;\n\n    if (maps == NULL) maps = m;\n    else\n        ((map *) get_last_map())->psig = m;\n\n    len_maps++;\n\n    return;\n}", "path": "sc-im/src/maps.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief TODO Document getformat()\n *\n * \\param[in] col\n * \\param[in] df\n *\n * \\return none\n */\n", "func_signal": "void getformat(int col, FILE * fd)", "code": "{\n    sprintf(line, \"%d %d %d\\n\", fwidth[col], precision[col], realfmt[col]);\n    //write(fd, line, strlen(line));\n    sc_value(\"%s\", line);\n    linelim = -1;\n}", "path": "sc-im/src/pipe.c", "commit_date": "2018-05-31 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/**\n * \\brief Create list of blocks based on map strings\n *\n * \\param[in] str\n *\n * \\return buffer\n */\n", "func_signal": "struct block * get_mapbuf_str (char * str)", "code": "{\n    struct block * buffer = create_buf();\n    unsigned short l = strlen(str);\n    unsigned short i, j;\n    unsigned short is_specialkey = 0;\n    char sk[MAXSC+1];\n    sk[0] = '\\0';\n\n    for (i=0; i<l; i++) {\n\n        // Add special keys\n        if (str[i] == '<') {\n           is_specialkey = 1;\n\n        } else if (str[i] == '>') {\n           is_specialkey = 0;\n           if (! strcasecmp(sk, \"CR\"))                                  // CR - ENTER key\n               addto_buf(buffer, OKEY_ENTER);\n           else if (! strcasecmp(sk, \"TAB\"))                            // TAB\n               addto_buf(buffer, OKEY_TAB);\n           else if (! strcasecmp(sk, \"LEFT\"))                           // LEFT\n               addto_buf(buffer, OKEY_LEFT);\n           else if (! strcasecmp(sk, \"RIGHT\"))                          // RIGHT\n               addto_buf(buffer, OKEY_RIGHT);\n           else if (! strcasecmp(sk, \"DOWN\"))                           // DOWN\n               addto_buf(buffer, OKEY_DOWN);\n           else if (! strcasecmp(sk, \"UP\"))                             // UP\n               addto_buf(buffer, OKEY_UP);\n           else if (! strcasecmp(sk, \"DEL\"))                            // DEL\n               addto_buf(buffer, OKEY_DEL);\n           else if (! strcasecmp(sk, \"BS\"))                             // BS\n               addto_buf(buffer, OKEY_BS);\n           else if (! strcasecmp(sk, \"HOME\"))                           // HOME\n               addto_buf(buffer, OKEY_HOME);\n           else if (! strcasecmp(sk, \"END\"))                            // END\n               addto_buf(buffer, OKEY_END);\n           else if (! strcasecmp(sk, \"PGDOWN\"))                         // PGDOWN\n               addto_buf(buffer, OKEY_PGDOWN);\n           else if (! strcasecmp(sk, \"PGUP\"))                           // PGUP\n               addto_buf(buffer, OKEY_PGUP);\n           else if (! strncmp(sk, \"C-\", 2) && strlen(sk) == 3       // C-X\n                    && ( (sk[2] > 64 && sk[2] < 91) || (sk[2] > 96 && sk[2] < 123)) )\n               addto_buf(buffer, ctl(tolower(sk[2])));\n\n           sk[0]='\\0';\n\n        } else if (is_specialkey && strlen(sk) < MAXSC-1) {\n           add_char(sk, str[i], strlen(sk));\n\n        // Add some other characters\n        } else {\n           addto_buf(buffer, (int) str[i]);\n        }\n    }\n\n    // If the buffer lacks the trailing '>', insert it\n    if (is_specialkey && i == l) {\n        j = strlen(sk);\n        addto_buf(buffer, '<');\n        for (i=0; i<j; i++) addto_buf(buffer, (int) str[l-j+i]);\n    }\n    return buffer;\n}", "path": "sc-im/src/maps.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "andmarti1424/sc-im", "stars": 4018, "license": "other", "language": "c", "size": 5754}
{"docstring": "/* this default dictionary does not provide good contexts... */\n", "func_signal": "static void dict_set_default(void)", "code": "{\n    lzo_uint d = 0;\n    unsigned i, j;\n\n    dict.len = 16 * 256;\n    if (dict.len > dict.alloc_len)\n        dict.len = dict.alloc_len;\n\n    lzo_memset(dict.ptr, 0, dict.len);\n\n    for (i = 0; i < 256; i++)\n        for (j = 0; j < 16; j++) {\n            if (d >= dict.len)\n                goto done;\n            dict.ptr[d++] = (unsigned char) i;\n        }\n\ndone:\n    dict.adler = lzo_adler32(1, dict.ptr, dict.len);\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// LZO1A compress public entry point.\n************************************************************************/\n", "func_signal": "LZO_PUBLIC(int)\nlzo1a_compress ( const lzo_bytep in , lzo_uint  in_len,\n                       lzo_bytep out, lzo_uintp out_len,\n                       lzo_voidp wrkmem )", "code": "{\n    int r = LZO_E_OK;\n\n\n#if (LZO_COLLECT_STATS)\n    lzo_memset(lzo_stats,0,sizeof(*lzo_stats));\n    lzo_stats->rbits  = RBITS;\n    lzo_stats->clevel = CLEVEL;\n    lzo_stats->dbits  = DBITS;\n    lzo_stats->lbits  = LBITS;\n    lzo_stats->min_match_short = MIN_MATCH_SHORT;\n    lzo_stats->max_match_short = MAX_MATCH_SHORT;\n    lzo_stats->min_match_long  = MIN_MATCH_LONG;\n    lzo_stats->max_match_long  = MAX_MATCH_LONG;\n    lzo_stats->min_offset      = MIN_OFFSET;\n    lzo_stats->max_offset      = MAX_OFFSET;\n    lzo_stats->r0min  = R0MIN;\n    lzo_stats->r0fast = R0FAST;\n    lzo_stats->r0max  = R0MAX;\n    lzo_stats->in_len = in_len;\n#endif\n\n\n    /* don't try to compress a block that's too short */\n    if (in_len == 0)\n        *out_len = 0;\n    else if (in_len <= MIN_MATCH_LONG + DVAL_LEN + 1)\n    {\n#if defined(LZO_RETURN_IF_NOT_COMPRESSIBLE)\n        r = LZO_E_NOT_COMPRESSIBLE;\n#else\n        *out_len = pd(store_run(out,in,in_len), out);\n#endif\n    }\n    else\n        r = do_compress(in,in_len,out,out_len,wrkmem);\n\n\n#if (LZO_COLLECT_STATS)\n    lzo_stats->short_matches -= lzo_stats->r1_matches;\n    lzo_stats->short_match[MIN_MATCH] -= lzo_stats->r1_matches;\n    lzo_stats->out_len = *out_len;\n#endif\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1a.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*************************************************************************\n// compress and decompress a file\n**************************************************************************/\n", "func_signal": "static __lzo_noinline\nint process_file ( const compress_t *c, lzo_decompress_t decompress,\n                   const char *method_name,\n                   const char *file_name,\n                   long t_loops, long c_loops, long d_loops )", "code": "{\n    long t_i;\n    unsigned long blocks = 0;\n    unsigned long compressed_len = 0;\n    double t_time = 0, c_time = 0, d_time = 0;\n    lzo_pclock_t t_start, t_stop, x_start, x_stop;\n    FILE *fp_dump = NULL;\n\n    if (opt_dump_compressed_data)\n        fp_dump = fopen(opt_dump_compressed_data,\"wb\");\n\n/* process the file */\n\n    lzo_pclock_flush_cpu_cache(&pch, 0);\n    lzo_pclock_read(&pch, &t_start);\n    for (t_i = 0; t_i < t_loops; t_i++)\n    {\n        lzo_uint len, c_len, c_len_max, d_len = 0;\n        const lzo_bytep d = file_data.ptr;\n\n        len = file_data.len;\n        c_len = 0;\n        blocks = 0;\n\n        /* process blocks */\n        if (len > 0 || opt_try_to_compress_0_bytes) do\n        {\n            lzo_uint bl;\n            long c_i;\n            int r;\n            unsigned char random_byte = (unsigned char) file_data.len;\n#if 1 && defined(CLOCKS_PER_SEC)\n            random_byte = (unsigned char) (random_byte ^ clock());\n#endif\n            blocks++;\n\n            bl = len > opt_block_size ? opt_block_size : len;\n            /* update lengths for memchecker_xxx() */\n            block_c.len = bl + get_max_compression_expansion(c->id, bl);\n            block_d.len = bl + get_max_decompression_overrun(c->id, bl);\n#if defined(__LZO_CHECKER)\n            /* malloc a block of the exact size to detect any overrun */\n            assert(block_c.alloc_ptr == NULL);\n            assert(block_d.alloc_ptr == NULL);\n            mb_alloc(&block_c, block_c.len);\n            mb_alloc(&block_d, block_d.len);\n#endif\n            assert(block_c.len <= block_c.saved_len);\n            assert(block_d.len <= block_d.saved_len);\n\n            memchecker_init(&block_c, block_c.len, random_byte);\n            memchecker_init(&block_d, block_d.len, random_byte);\n\n        /* compress the block */\n            c_len = c_len_max = 0;\n            lzo_pclock_flush_cpu_cache(&pch, 0);\n            lzo_pclock_read(&pch, &x_start);\n            for (r = 0, c_i = 0; c_i < c_loops; c_i++)\n            {\n                c_len = block_c.len;\n                r = call_compressor(c, d, bl, block_c.ptr, &c_len);\n                if (r != 0)\n                    break;\n                if (c_len > c_len_max)\n                    c_len_max = c_len;\n                if (c_len > block_c.len)\n                    goto compress_overrun;\n            }\n            lzo_pclock_read(&pch, &x_stop);\n            c_time += lzo_pclock_get_elapsed(&pch, &x_start, &x_stop);\n            if (r != 0)\n            {\n                printf(\"  compression failed in block %lu (%d) (%lu %lu)\\n\",\n                       blocks, r, (unsigned long)c_len, (unsigned long)bl);\n                return EXIT_LZO_ERROR;\n            }\n            if (memchecker_check(&block_c, block_c.len, random_byte) != 0)\n            {\ncompress_overrun:\n                printf(\"  compression overwrite error in block %lu \"\n                       \"(%lu %lu %lu %lu)\\n\",\n                       blocks, (unsigned long)c_len, (unsigned long)d_len, (unsigned long)bl, (unsigned long)block_c.len);\n                return EXIT_LZO_ERROR;\n            }\n\n        /* optimize the compressed block */\n            if (c_len < bl && opt_optimize_compressed_data)\n            {\n                d_len = bl;\n                r = call_optimizer(c, block_c.ptr, c_len, block_d.ptr, &d_len);\n                if (r != 0 || d_len != bl)\n                {\n                    printf(\"  optimization failed in block %lu (%d) \"\n                           \"(%lu %lu %lu)\\n\", blocks, r,\n                           (unsigned long)c_len, (unsigned long)d_len, (unsigned long)bl);\n                    return EXIT_LZO_ERROR;\n                }\n                if (memchecker_check(&block_c, block_c.len, random_byte) != 0 ||\n                    memchecker_check(&block_d, block_d.len, random_byte) != 0)\n                {\n                    printf(\"  optimize overwrite error in block %lu \"\n                           \"(%lu %lu %lu %lu)\\n\",\n                           blocks, (unsigned long)c_len, (unsigned long)d_len, (unsigned long)bl, (unsigned long)block_c.len);\n                    return EXIT_LZO_ERROR;\n                }\n            }\n\n            /* dump compressed data to disk */\n            if (fp_dump)\n            {\n                lzo_uint l = (lzo_uint) lzo_fwrite(fp_dump, block_c.ptr, c_len);\n                if (l != c_len || fflush(fp_dump) != 0) {\n                    /* write error */\n                    (void) fclose(fp_dump); fp_dump = NULL;\n                }\n            }\n\n        /* decompress the block and verify */\n            lzo_pclock_flush_cpu_cache(&pch, 0);\n            lzo_pclock_read(&pch, &x_start);\n            for (r = 0, c_i = 0; c_i < d_loops; c_i++)\n            {\n                d_len = bl;\n                r = call_decompressor(c, decompress, block_c.ptr, c_len, block_d.ptr, &d_len);\n                if (r != 0 || d_len != bl)\n                    break;\n            }\n            lzo_pclock_read(&pch, &x_stop);\n            d_time += lzo_pclock_get_elapsed(&pch, &x_start, &x_stop);\n            if (r != 0)\n            {\n                printf(\"  decompression failed in block %lu (%d) \"\n                       \"(%lu %lu %lu)\\n\", blocks, r,\n                       (unsigned long)c_len, (unsigned long)d_len, (unsigned long)bl);\n                return EXIT_LZO_ERROR;\n            }\n            if (d_len != bl)\n            {\n                printf(\"  decompression size error in block %lu (%lu %lu %lu)\\n\",\n                       blocks, (unsigned long)c_len, (unsigned long)d_len, (unsigned long)bl);\n                return EXIT_LZO_ERROR;\n            }\n            if (is_compressor(c))\n            {\n                if (lzo_memcmp(d, block_d.ptr, bl) != 0)\n                {\n                    lzo_uint x = 0;\n                    while (x < bl && block_d.ptr[x] == d[x])\n                        x++;\n                    printf(\"  decompression data error in block %lu at offset \"\n                           \"%lu (%lu %lu)\\n\", blocks, (unsigned long)x,\n                           (unsigned long)c_len, (unsigned long)d_len);\n                    if (opt_compute_adler32)\n                        printf(\"      checksum: 0x%08lx 0x%08lx\\n\",\n                               (unsigned long)adler_in, (unsigned long)adler_out);\n#if 0\n                    printf(\"Orig:  \");\n                    r = (x >= 10) ? -10 : 0 - (int) x;\n                    for (j = r; j <= 10 && x + j < bl; j++)\n                        printf(\" %02x\", (int)d[x+j]);\n                    printf(\"\\nDecomp:\");\n                    for (j = r; j <= 10 && x + j < bl; j++)\n                        printf(\" %02x\", (int)block_d.ptr[x+j]);\n                    printf(\"\\n\");\n#endif\n                    return EXIT_LZO_ERROR;\n                }\n                if ((opt_compute_adler32 && adler_in != adler_out) ||\n                    (opt_compute_crc32 && crc_in != crc_out))\n                {\n                    printf(\"  checksum error in block %lu (%lu %lu)\\n\",\n                           blocks, (unsigned long)c_len, (unsigned long)d_len);\n                    printf(\"      adler32: 0x%08lx 0x%08lx\\n\",\n                           (unsigned long)adler_in, (unsigned long)adler_out);\n                    printf(\"      crc32: 0x%08lx 0x%08lx\\n\",\n                           (unsigned long)crc_in, (unsigned long)crc_out);\n                    return EXIT_LZO_ERROR;\n                }\n            }\n\n            if (memchecker_check(&block_d, block_d.len, random_byte) != 0)\n            {\n                printf(\"  decompression overwrite error in block %lu \"\n                       \"(%lu %lu %lu %lu)\\n\",\n                       blocks, (unsigned long)c_len, (unsigned long)d_len,\n                       (unsigned long)bl, (unsigned long)block_d.len);\n                return EXIT_LZO_ERROR;\n            }\n\n#if defined(__LZO_CHECKER)\n            /* free in reverse order of allocations */\n            mb_free(&block_d);\n            mb_free(&block_c);\n#endif\n\n            d += bl;\n            len -= bl;\n            compressed_len += (unsigned long) c_len_max;\n        }\n        while (len > 0);\n    }\n    lzo_pclock_read(&pch, &t_stop);\n    t_time += lzo_pclock_get_elapsed(&pch, &t_start, &t_stop);\n\n    if (fp_dump) {\n        (void) fclose(fp_dump); fp_dump = NULL;\n    }\n    opt_dump_compressed_data = NULL;    /* only dump the first file */\n\n    print_stats(method_name, file_name,\n                t_loops, c_loops, d_loops,\n                t_time, c_time, d_time,\n                compressed_len, (unsigned long) file_data.len, blocks);\n    if (total_method_name != c->name) {\n        total_method_name = c->name;\n        total_method_names += 1;\n    }\n\n    return EXIT_OK;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*************************************************************************\n// usage\n**************************************************************************/\n", "func_signal": "static\nvoid usage ( const char *name, int exit_code, lzo_bool show_methods )", "code": "{\n    FILE *fp;\n    int i;\n\n    fp = stdout;\n\n    fflush(stdout); fflush(stderr);\n\n    fprintf(fp,\"Usage: %s [option..] file...\\n\", name);\n    fprintf(fp,\"\\n\");\n    fprintf(fp,\"Options:\\n\");\n    fprintf(fp,\"  -m#     compression method\\n\");\n    fprintf(fp,\"  -b#     set input block size (default %lu, max %lu)\\n\",\n            (unsigned long) opt_block_size, (unsigned long) opt_max_data_len);\n    fprintf(fp,\"  -n#     number of compression/decompression runs\\n\");\n    fprintf(fp,\"  -c#     number of compression runs\\n\");\n    fprintf(fp,\"  -d#     number of decompression runs\\n\");\n    fprintf(fp,\"  -S      use safe decompressor (if available)\\n\");\n    fprintf(fp,\"  -A      use assembler decompressor (if available)\\n\");\n    fprintf(fp,\"  -F      use fast assembler decompressor (if available)\\n\");\n    fprintf(fp,\"  -O      optimize compressed data (if available)\\n\");\n    fprintf(fp,\"  -s DIR  process Calgary Corpus test suite in directory `DIR'\\n\");\n    fprintf(fp,\"  -@      read list of files to compress from stdin\\n\");\n    fprintf(fp,\"  -q      be quiet\\n\");\n    fprintf(fp,\"  -Q      be very quiet\\n\");\n    fprintf(fp,\"  -v      be verbose\\n\");\n    fprintf(fp,\"  -L      display software license\\n\");\n\n    if (show_methods)\n    {\n#if defined(__LZOLIB_PCLOCK_CH_INCLUDED)\n        lzo_pclock_t t_dummy;\n        lzo_pclock_read(&pch, &t_dummy);\n        (void) lzo_pclock_get_elapsed(&pch, &t_dummy, &t_dummy);\n        fprintf(fp,\"\\nAll timings are recorded using pclock mode %d %s.\\n\", pch.mode, pch.name);\n#endif\n        fprintf(fp,\"\\n\\n\");\n        fprintf(fp,\"The following compression methods are available:\\n\");\n        fprintf(fp,\"\\n\");\n        fprintf(fp,\"  usage   name           memory          available extras\\n\");\n        fprintf(fp,\"  -----   ----           ------          ----------------\\n\");\n\n        for (i = 0; i <= M_LAST_COMPRESSOR; i++)\n        {\n            const compress_t *c;\n            c = find_method_by_id(i);\n            if (c)\n            {\n                char n[16];\n                const char *sep = \"          \";\n                unsigned long m = c->mem_compress;\n\n                sprintf(n,\"-m%d\",i);\n                fprintf(fp,\"  %-6s  %-13s\",n,c->name);\n#if 1\n                fprintf(fp,\"%9lu\", m);\n#else\n                m = (m + 1023) / 1024;\n                fprintf(fp,\"%6lu KiB\", m);\n#endif\n\n                if (c->decompress_safe)\n                    { fprintf(fp, \"%s%s\", sep, \"safe\"); sep = \", \"; }\n                if (c->decompress_asm)\n                    { fprintf(fp, \"%s%s\", sep, \"asm\"); sep = \", \"; }\n                if (c->decompress_asm_safe)\n                    { fprintf(fp, \"%s%s\", sep, \"asm+safe\"); sep = \", \"; }\n                if (c->decompress_asm_fast)\n                    { fprintf(fp, \"%s%s\", sep, \"fastasm\"); sep = \", \"; }\n                if (c->decompress_asm_fast_safe)\n                    { fprintf(fp, \"%s%s\", sep, \"fastasm+safe\"); sep = \", \"; }\n                if (c->optimize)\n                    { fprintf(fp, \"%s%s\", sep, \"optimize\"); /*sep = \", \";*/ }\n                fprintf(fp, \"\\n\");\n            }\n        }\n    }\n    else\n    {\n        fprintf(fp,\"\\n\");\n        fprintf(fp,\"Type '%s -m' to list all available methods.\\n\", name);\n    }\n\n    fflush(fp);\n    if (exit_code < 0)\n        exit_code = EXIT_USAGE;\n    exit(exit_code);\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*************************************************************************\n// optimize a block\n**************************************************************************/\n", "func_signal": "static\nint call_optimizer   ( const compress_t *c,\n                             lzo_bytep src, lzo_uint  src_len,\n                             lzo_bytep dst, lzo_uintp dst_len )", "code": "{\n    if (c && c->optimize && block_w.len >= c->mem_decompress)\n        return c->optimize(src,src_len,dst,dst_len,block_w.ptr);\n    return 0;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// LZO1 compress a block of data.\n//\n// Could be translated into assembly code without too much effort.\n//\n// I apologize for the spaghetti code, but it really helps the optimizer.\n************************************************************************/\n", "func_signal": "static int\ndo_compress    ( const lzo_bytep in , lzo_uint  in_len,\n                       lzo_bytep out, lzo_uintp out_len,\n                       lzo_voidp wrkmem )", "code": "{\n    const lzo_bytep ip;\n#if defined(__LZO_HASH_INCREMENTAL)\n    lzo_xint dv;\n#endif\n    lzo_bytep op;\n    const lzo_bytep m_pos;\n    const lzo_bytep const ip_end = in+in_len - DVAL_LEN - MIN_MATCH_LONG;\n    const lzo_bytep const in_end = in+in_len - DVAL_LEN;\n    const lzo_bytep ii;\n    lzo_dict_p const dict = (lzo_dict_p) wrkmem;\n\n#if !defined(NDEBUG)\n    const lzo_bytep m_pos_sav;\n#endif\n\n    op = out;\n    ip = in;\n    ii = ip;                /* point to start of literal run */\n    if (in_len <= MIN_MATCH_LONG + DVAL_LEN + 1)\n        goto the_end;\n\n    /* init dictionary */\n#if (LZO_DETERMINISTIC)\n    BZERO8_PTR(wrkmem,sizeof(lzo_dict_t),D_SIZE);\n#endif\n\n    DVAL_FIRST(dv,ip);\n    UPDATE_D(dict,0,dv,ip,in);\n    ip++;\n    DVAL_NEXT(dv,ip);\n\n    do {\n        LZO_DEFINE_UNINITIALIZED_VAR(lzo_uint, m_off, 0);\n        lzo_uint dindex;\n\n        DINDEX1(dindex,ip);\n        GINDEX(m_pos,m_off,dict,dindex,in);\n        if (LZO_CHECK_MPOS(m_pos,m_off,in,ip,MAX_OFFSET))\n            goto literal;\n        if (m_pos[0] == ip[0] && m_pos[1] == ip[1] && m_pos[2] == ip[2])\n            goto match;\n        DINDEX2(dindex,ip);\n        GINDEX(m_pos,m_off,dict,dindex,in);\n        if (LZO_CHECK_MPOS(m_pos,m_off,in,ip,MAX_OFFSET))\n            goto literal;\n        if (m_pos[0] == ip[0] && m_pos[1] == ip[1] && m_pos[2] == ip[2])\n            goto match;\n        goto literal;\n\n\nliteral:\n        UPDATE_I(dict,0,dindex,ip,in);\n        if (++ip >= ip_end)\n            break;\n        continue;\n\nmatch:\n        UPDATE_I(dict,0,dindex,ip,in);\n#if !defined(NDEBUG) && (LZO_DICT_USE_PTR)\n        m_pos_sav = m_pos;\n#endif\n        m_pos += 3;\n        {\n    /* we have found a match (of at least length 3) */\n#if !defined(NDEBUG) && !(LZO_DICT_USE_PTR)\n            assert((m_pos_sav = ip - m_off) == (m_pos - 3));\n#endif\n            /* 1) store the current literal run */\n            if (pd(ip,ii) > 0)\n            {\n                lzo_uint t = pd(ip,ii);\n#if 1\n                /* OPTIMIZED: inline the copying of a short run */\n                if (t < R0MIN)\n                {\n                    *op++ = LZO_BYTE(t);\n                    MEMCPY_DS(op, ii, t);\n                }\n                else\n#endif\n                    op = store_run(op,ii,t);\n            }\n\n            /* 2a) compute match len */\n            ii = ip;        /* point to start of current match */\n\n            /* we already matched MIN_MATCH bytes,\n             * m_pos also already advanced MIN_MATCH bytes */\n            ip += MIN_MATCH;\n            assert(m_pos < ip);\n\n            /* try to match another MIN_MATCH_LONG - MIN_MATCH bytes\n             * to see if we get a long match */\n\n#define PS  *m_pos++ != *ip++\n\n#if (MIN_MATCH_LONG - MIN_MATCH == 2)                   /* MBITS == 2 */\n            if (PS || PS)\n#elif (MIN_MATCH_LONG - MIN_MATCH == 6)                 /* MBITS == 3 */\n            if (PS || PS || PS || PS || PS || PS)\n#elif (MIN_MATCH_LONG - MIN_MATCH == 14)                /* MBITS == 4 */\n            if (PS || PS || PS || PS || PS || PS || PS ||\n                PS || PS || PS || PS || PS || PS || PS)\n#elif (MIN_MATCH_LONG - MIN_MATCH == 30)                /* MBITS == 5 */\n            if (PS || PS || PS || PS || PS || PS || PS || PS ||\n                PS || PS || PS || PS || PS || PS || PS || PS ||\n                PS || PS || PS || PS || PS || PS || PS || PS ||\n                PS || PS || PS || PS || PS || PS)\n#else\n#  error \"MBITS not yet implemented\"\n#endif\n            {\n                lzo_uint m_len;\n\n            /* 2b) code a short match */\n                    assert(pd(ip,m_pos) == m_off);\n                --ip;   /* ran one too far, point back to non-match */\n                m_len = pd(ip, ii);\n                    assert(m_len >= MIN_MATCH_SHORT);\n                    assert(m_len <= MAX_MATCH_SHORT);\n                    assert(m_off > 0);\n                    assert(m_off <= MAX_OFFSET);\n                    assert(ii-m_off == m_pos_sav);\n                    assert(lzo_memcmp(m_pos_sav,ii,m_len) == 0);\n                --m_off;\n                /* code short match len + low offset bits */\n                *op++ = LZO_BYTE(((m_len - THRESHOLD) << OBITS) |\n                                 (m_off & OMASK));\n                /* code high offset bits */\n                *op++ = LZO_BYTE(m_off >> OBITS);\n\n\n            /* 2c) Insert phrases (beginning with ii+1) into the dictionary. */\n\n#define SI      /* nothing */\n#define DI      ++ii; DVAL_NEXT(dv,ii); UPDATE_D(dict,0,dv,ii,in);\n#define XI      assert(ii < ip); ii = ip; DVAL_FIRST(dv,(ip));\n\n#if (CLEVEL == 9) || (CLEVEL >= 7 && MBITS <= 4) || (CLEVEL >= 5 && MBITS <= 3)\n            /* Insert the whole match (ii+1)..(ip-1) into dictionary.  */\n                ++ii;\n                do {\n                    DVAL_NEXT(dv,ii);\n                    UPDATE_D(dict,0,dv,ii,in);\n                } while (++ii < ip);\n                DVAL_NEXT(dv,ii);\n                assert(ii == ip);\n                DVAL_ASSERT(dv,ip);\n#elif (CLEVEL >= 3)\n                SI   DI DI   XI\n#elif (CLEVEL >= 2)\n                SI   DI      XI\n#else\n                             XI\n#endif\n\n            }\n            else\n            {\n            /* we've found a long match - see how far we can still go */\n                const lzo_bytep end;\n                lzo_uint m_len;\n\n                assert(ip <= in_end);\n                assert(ii == ip - MIN_MATCH_LONG);\n\n                if (pd(in_end,ip) <= (MAX_MATCH_LONG - MIN_MATCH_LONG))\n                    end = in_end;\n                else\n                {\n                    end = ip + (MAX_MATCH_LONG - MIN_MATCH_LONG);\n                    assert(end < in_end);\n                }\n\n                while (ip < end && *m_pos == *ip)\n                    { m_pos++; ip++; }\n                assert(ip <= in_end);\n\n            /* 2b) code the long match */\n                m_len = pd(ip, ii);\n                    assert(m_len >= MIN_MATCH_LONG);\n                    assert(m_len <= MAX_MATCH_LONG);\n                    assert(m_off > 0);\n                    assert(m_off <= MAX_OFFSET);\n                    assert(ii-m_off == m_pos_sav);\n                    assert(lzo_memcmp(m_pos_sav,ii,m_len) == 0);\n                    assert(pd(ip,m_pos) == m_off);\n                --m_off;\n                /* code long match flag + low offset bits */\n                *op++ = LZO_BYTE(((MSIZE - 1) << OBITS) | (m_off & OMASK));\n                /* code high offset bits */\n                *op++ = LZO_BYTE(m_off >> OBITS);\n                /* code match len */\n                *op++ = LZO_BYTE(m_len - MIN_MATCH_LONG);\n\n\n            /* 2c) Insert phrases (beginning with ii+1) into the dictionary. */\n#if (CLEVEL == 9)\n            /* Insert the whole match (ii+1)..(ip-1) into dictionary.  */\n            /* This is not recommended because it is slow. */\n                ++ii;\n                do {\n                    DVAL_NEXT(dv,ii);\n                    UPDATE_D(dict,0,dv,ii,in);\n                } while (++ii < ip);\n                DVAL_NEXT(dv,ii);\n                assert(ii == ip);\n                DVAL_ASSERT(dv,ip);\n#elif (CLEVEL >= 8)\n                SI   DI DI DI DI DI DI DI DI   XI\n#elif (CLEVEL >= 7)\n                SI   DI DI DI DI DI DI DI      XI\n#elif (CLEVEL >= 6)\n                SI   DI DI DI DI DI DI         XI\n#elif (CLEVEL >= 5)\n                SI   DI DI DI DI               XI\n#elif (CLEVEL >= 4)\n                SI   DI DI DI                  XI\n#elif (CLEVEL >= 3)\n                SI   DI DI                     XI\n#elif (CLEVEL >= 2)\n                SI   DI                        XI\n#else\n                                               XI\n#endif\n            }\n\n            /* ii now points to the start of next literal run */\n            assert(ii == ip);\n        }\n    } while (ip < ip_end);\n\n\n\nthe_end:\n    assert(ip <= in_end);\n\n\n#if defined(LZO_RETURN_IF_NOT_COMPRESSIBLE)\n    /* return -1 if op == out to indicate that we\n     * couldn't compress and didn't copy anything.\n     */\n    if (op == out)\n    {\n        *out_len = 0;\n        return LZO_E_NOT_COMPRESSIBLE;\n    }\n#endif\n\n\n    /* store the final literal run */\n    if (pd(in_end+DVAL_LEN,ii) > 0)\n        op = store_run(op,ii,pd(in_end+DVAL_LEN,ii));\n\n    *out_len = pd(op, out);\n    return 0;               /* compression went ok */\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// compression internal entry point.\n************************************************************************/\n", "func_signal": "LZO_LOCAL_IMPL(int)\n_lzo1b_do_compress   ( const lzo_bytep in,  lzo_uint  in_len,\n                             lzo_bytep out, lzo_uintp out_len,\n                             lzo_voidp wrkmem,\n                             lzo_compress_t func )", "code": "{\n    int r;\n#if defined(LZO_TEST_COMPRESS_OVERRUN)\n    lzo_uint avail_out = *out_len;\n#endif\n\n\n#if (LZO_COLLECT_STATS)\n    _lzo1b_stats_init(lzo_stats);\n    lzo_stats->in_len = in_len;\n#endif\n\n\n    /* don't try to compress a block that's too short */\n    if (in_len == 0)\n    {\n        *out_len = 0;\n        r = LZO_E_OK;\n    }\n    else if (in_len <= MIN_LOOKAHEAD + 1)\n    {\n#if defined(LZO_RETURN_IF_NOT_COMPRESSIBLE)\n        *out_len = 0;\n        r = LZO_E_NOT_COMPRESSIBLE;\n#else\n        *out_len = pd(STORE_RUN(out,in,in_len), out);\n        r = (*out_len > in_len) ? LZO_E_OK : LZO_E_ERROR;\n#endif\n    }\n    else\n        r = func(in,in_len,out,out_len,wrkmem);\n\n\n#if defined(LZO_EOF_CODE)\n#if defined(LZO_TEST_COMPRESS_OVERRUN)\n    if (r == LZO_E_OK && avail_out - *out_len < 3)\n        r = LZO_E_COMPRESS_OVERRUN;\n#endif\n    if (r == LZO_E_OK)\n    {\n        lzo_bytep op = out + *out_len;\n        op[0] = M3_MARKER | 1;\n        op[1] = 0;\n        op[2] = 0;\n        *out_len += 3;\n    }\n#endif\n\n\n#if (LZO_COLLECT_STATS)\n    lzo_stats->out_len = *out_len;\n    lzo_stats->match_bytes =\n       1 * lzo_stats->m1_matches + 2 * lzo_stats->m2_matches +\n       3 * lzo_stats->m3_matches + 4 * lzo_stats->m4_matches;\n    _lzo1b_stats_calc(lzo_stats);\n#endif\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1b_cc.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*************************************************************************\n// check that memory gets accessed within bounds\n**************************************************************************/\n", "func_signal": "static void memchecker_init ( mblock_t *mb, lzo_uint l, unsigned char random_byte )", "code": "{\n    lzo_uint i;\n    lzo_uint len = (lzo_uint) l;\n    lzo_bytep p;\n\n    assert(len <= mb->len);\n\n    /* bottom */\n    p = mb->ptr;\n    for (i = 0; i < 16 && p > mb->alloc_ptr; i++)\n        *--p = random_byte++;\n    /* top */\n    p = mb->ptr + len;\n    for (i = 0; i < 16 && p < mb->alloc_ptr + mb->alloc_len; i++)\n        *p++ = random_byte++;\n#if 0 || defined(LZO_DEBUG)\n    /* fill in garbage */\n    p = mb->ptr;\n    random_byte |= 1;\n    for (i = 0; i < len; i++, random_byte += 2)\n        *p++ = random_byte;\n#endif\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// public entry point\n************************************************************************/\n", "func_signal": "LZO_PUBLIC(int)\nlzo1f_1_compress ( const lzo_bytep in , lzo_uint  in_len,\n                         lzo_bytep out, lzo_uintp out_len,\n                         lzo_voidp wrkmem )", "code": "{\n    lzo_bytep op = out;\n    int r = LZO_E_OK;\n\n    if (in_len == 0)\n        *out_len = 0;\n    else if (in_len <= 10)\n    {\n        *op++ = LZO_BYTE(in_len);\n        do *op++ = *in++; while (--in_len > 0);\n        *out_len = pd(op, out);\n    }\n    else\n        r = do_compress(in,in_len,out,out_len,wrkmem);\n\n    if (r == LZO_E_OK)\n    {\n        op = out + *out_len;\n        op[0] = M3_MARKER | 1;\n        op[1] = 0;\n        op[2] = 0;\n        *out_len += 3;\n    }\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1f_1.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*************************************************************************\n// compress a block\n**************************************************************************/\n", "func_signal": "static\nint call_compressor   ( const compress_t *c,\n                        const lzo_bytep src, lzo_uint  src_len,\n                              lzo_bytep dst, lzo_uintp dst_len )", "code": "{\n    int r = -100;\n\n    if (c && c->compress && block_w.len >= c->mem_compress)\n    {\n        unsigned char random_byte = (unsigned char) src_len;\n        memchecker_init(&block_w, c->mem_compress, random_byte);\n        if (opt_clear_wrkmem)\n            lzo_memset(block_w.ptr, 0, c->mem_compress);\n\n        if (opt_dict && c->compress_dict)\n            r = c->compress_dict(src,src_len,dst,dst_len,block_w.ptr,dict.ptr,dict.len);\n        else\n            r = c->compress(src,src_len,dst,dst_len,block_w.ptr);\n\n        if (memchecker_check(&block_w, c->mem_compress, random_byte) != 0)\n            printf(\"WARNING: wrkmem overwrite error (compress) !!!\\n\");\n    }\n\n    if (r == 0 && opt_compute_adler32)\n    {\n        lzo_uint32_t adler;\n        adler = lzo_adler32(0, NULL, 0);\n        adler = lzo_adler32(adler, src, src_len);\n        adler_in = adler;\n    }\n    if (r == 0 && opt_compute_crc32)\n    {\n        lzo_uint32_t crc;\n        crc = lzo_crc32(0, NULL, 0);\n        crc = lzo_crc32(crc, src, src_len);\n        crc_in = crc;\n    }\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// compression internal entry point.\n************************************************************************/\n", "func_signal": "LZO_LOCAL_IMPL(int)\n_lzo1c_do_compress ( const lzo_bytep in,  lzo_uint  in_len,\n                           lzo_bytep out, lzo_uintp out_len,\n                           lzo_voidp wrkmem,\n                           lzo_compress_t func )", "code": "{\n    int r;\n#if defined(LZO_TEST_COMPRESS_OVERRUN)\n    lzo_uint avail_out = *out_len;\n#endif\n\n\n#if (LZO_COLLECT_STATS)\n    _lzo1c_stats_init(lzo_stats);\n    lzo_stats->in_len = in_len;\n#endif\n\n\n    /* don't try to compress a block that's too short */\n    if (in_len == 0)\n    {\n        *out_len = 0;\n        r = LZO_E_OK;\n    }\n    else if (in_len <= MIN_LOOKAHEAD + 1)\n    {\n#if defined(LZO_RETURN_IF_NOT_COMPRESSIBLE)\n        *out_len = 0;\n        r = LZO_E_NOT_COMPRESSIBLE;\n#else\n        *out_len = pd(STORE_RUN(out,in,in_len), out);\n        r = (*out_len > in_len) ? LZO_E_OK : LZO_E_ERROR;\n#endif\n    }\n    else\n        r = func(in,in_len,out,out_len,wrkmem);\n\n\n#if defined(LZO_EOF_CODE)\n#if defined(LZO_TEST_COMPRESS_OVERRUN)\n    if (r == LZO_E_OK && avail_out - *out_len < 3)\n        r = LZO_E_COMPRESS_OVERRUN;\n#endif\n    if (r == LZO_E_OK)\n    {\n        lzo_bytep op = out + *out_len;\n        op[0] = M3_MARKER | 1;\n        op[1] = 0;\n        op[2] = 0;\n        *out_len += 3;\n    }\n#endif\n\n\n#if (LZO_COLLECT_STATS)\n    lzo_stats->out_len = *out_len;\n    lzo_stats->match_bytes =\n       1 * lzo_stats->m1_matches + 2 * lzo_stats->m2_matches +\n       3 * lzo_stats->m3_matches + 4 * lzo_stats->m4_matches;\n    _lzo1c_stats_calc(lzo_stats);\n#endif\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1c_cc.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// LZO1A decompress a block of data.\n//\n// Could be easily translated into assembly code.\n************************************************************************/\n", "func_signal": "LZO_PUBLIC(int)\nlzo1a_decompress ( const lzo_bytep in , lzo_uint  in_len,\n                         lzo_bytep out, lzo_uintp out_len,\n                         lzo_voidp wrkmem )", "code": "{\n    lzo_bytep op;\n    const lzo_bytep ip;\n    lzo_uint t;\n    const lzo_bytep m_pos;\n    const lzo_bytep const ip_end = in + in_len;\n\n    LZO_UNUSED(wrkmem);\n\n    op = out;\n    ip = in;\n    while (ip < ip_end)\n    {\n        t = *ip++;      /* get marker */\n        LZO_STATS(lzo_stats->marker[t]++);\n\n        if (t == 0)             /* a R0 literal run */\n        {\n            t = *ip++;\n            if (t >= R0FAST - R0MIN)            /* a long R0 run */\n            {\n                t -= R0FAST - R0MIN;\n                if (t == 0)\n                    t = R0FAST;\n                else\n                {\n#if 0\n                    t = 256u << ((unsigned) t);\n#else\n                    /* help the optimizer */\n                    lzo_uint tt = 256;\n                    do tt <<= 1; while (--t > 0);\n                    t = tt;\n#endif\n                }\n                MEMCPY8_DS(op,ip,t);\n                continue;\n            }\n            t += R0MIN;\n            goto literal;\n        }\n        else if (t < R0MIN)     /* a short literal run */\n        {\nliteral:\n            MEMCPY_DS(op,ip,t);\n\n        /* after a literal a match must follow */\n            while (ip < ip_end)\n            {\n                t = *ip++;          /* get R1 marker */\n                if (t >= R0MIN)\n                    goto match;\n\n            /* R1 match - a context sensitive 3 byte match + 1 byte literal */\n                assert((t & OMASK) == t);\n                m_pos = op - MIN_OFFSET;\n                m_pos -= t | (((lzo_uint) *ip++) << OBITS);\n                assert(m_pos >= out); assert(m_pos < op);\n                *op++ = m_pos[0];\n                *op++ = m_pos[1];\n                *op++ = m_pos[2];\n                *op++ = *ip++;\n            }\n        }\n        else                    /* a match */\n        {\nmatch:\n            /* get match offset */\n            m_pos = op - MIN_OFFSET;\n            m_pos -= (t & OMASK) | (((lzo_uint) *ip++) << OBITS);\n            assert(m_pos >= out); assert(m_pos < op);\n\n            /* get match len */\n            if (t < ((MSIZE - 1) << OBITS))         /* a short match */\n            {\n                t >>= OBITS;\n                *op++ = *m_pos++;\n                *op++ = *m_pos++;\n                MEMCPY_DS(op,m_pos,t);\n            }\n            else                                     /* a long match */\n            {\n#if (LBITS < 8)\n                t = (MIN_MATCH_LONG - THRESHOLD) + ((lzo_uint)(*ip++) & LMASK);\n#else\n                t = (MIN_MATCH_LONG - THRESHOLD) + (lzo_uint)(*ip++);\n#endif\n                *op++ = *m_pos++;\n                *op++ = *m_pos++;\n                MEMCPY_DS(op,m_pos,t);\n#if (LBITS < 8)\n                /* a very short literal following a long match */\n                t = ip[-1] >> LBITS;\n                if (t) do\n                    *op++ = *ip++;\n                while (--t);\n#endif\n            }\n        }\n    }\n\n    *out_len = pd(op, out);\n\n    /* the next line is the only check in the decompressor */\n    return (ip == ip_end ? LZO_E_OK :\n           (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1a.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// compress public entry point.\n************************************************************************/\n", "func_signal": "LZO_PUBLIC(int)\nlzo1_compress ( const lzo_bytep in , lzo_uint  in_len,\n                      lzo_bytep out, lzo_uintp out_len,\n                      lzo_voidp wrkmem )", "code": "{\n    int r = LZO_E_OK;\n\n    /* don't try to compress a block that's too short */\n    if (in_len == 0)\n        *out_len = 0;\n    else if (in_len <= MIN_MATCH_LONG + DVAL_LEN + 1)\n    {\n#if defined(LZO_RETURN_IF_NOT_COMPRESSIBLE)\n        r = LZO_E_NOT_COMPRESSIBLE;\n#else\n        *out_len = pd(store_run(out,in,in_len), out);\n#endif\n    }\n    else\n        r = do_compress(in,in_len,out,out_len,wrkmem);\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// compression internal entry point.\n************************************************************************/\n", "func_signal": "static int\n_lzo1_do_compress ( const lzo_bytep in,  lzo_uint  in_len,\n                          lzo_bytep out, lzo_uintp out_len,\n                          lzo_voidp wrkmem,\n                          lzo_compress_t func )", "code": "{\n    int r;\n\n    /* don't try to compress a block that's too short */\n    if (in_len == 0)\n    {\n        *out_len = 0;\n        r = LZO_E_OK;\n    }\n    else if (in_len <= MIN_LOOKAHEAD + 1)\n    {\n#if defined(LZO_RETURN_IF_NOT_COMPRESSIBLE)\n        *out_len = 0;\n        r = LZO_E_NOT_COMPRESSIBLE;\n#else\n        *out_len = pd(STORE_RUN(out,in,in_len), out);\n        r = (*out_len > in_len) ? LZO_E_OK : LZO_E_ERROR;\n#endif\n    }\n    else\n        r = func(in,in_len,out,out_len,wrkmem);\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1_99.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*************************************************************************\n// dictionary support\n**************************************************************************/\n", "func_signal": "static void dict_alloc(lzo_uint max_dict_len)", "code": "{\n    lzo_uint l = 0xbfff;    /* MAX_DICT_LEN */\n    if (max_dict_len > 0 && l > max_dict_len)\n        l = max_dict_len;\n    mb_alloc(&dict, l);\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*************************************************************************\n// decompress a block\n**************************************************************************/\n", "func_signal": "static\nint call_decompressor ( const compress_t *c, lzo_decompress_t d,\n                        const lzo_bytep src, lzo_uint  src_len,\n                              lzo_bytep dst, lzo_uintp dst_len )", "code": "{\n    int r = -100;\n\n    if (c && d && block_w.len >= c->mem_decompress)\n    {\n        unsigned char random_byte = (unsigned char) src_len;\n        memchecker_init(&block_w, c->mem_decompress, random_byte);\n        if (opt_clear_wrkmem)\n            lzo_memset(block_w.ptr, 0, c->mem_decompress);\n\n        if (opt_dict && c->decompress_dict_safe)\n            r = c->decompress_dict_safe(src,src_len,dst,dst_len,block_w.ptr,dict.ptr,dict.len);\n        else\n            r = d(src,src_len,dst,dst_len,block_w.ptr);\n\n        if (memchecker_check(&block_w, c->mem_decompress, random_byte) != 0)\n            printf(\"WARNING: wrkmem overwrite error (decompress) !!!\\n\");\n    }\n\n    if (r == 0 && opt_compute_adler32)\n        adler_out = lzo_adler32(1, dst, *dst_len);\n    if (r == 0 && opt_compute_crc32)\n        crc_out = lzo_crc32(0, dst, *dst_len);\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// compression internal entry point.\n************************************************************************/\n", "func_signal": "static int\n_lzo1a_do_compress ( const lzo_bytep in,  lzo_uint  in_len,\n                           lzo_bytep out, lzo_uintp out_len,\n                           lzo_voidp wrkmem,\n                           lzo_compress_t func )", "code": "{\n    int r;\n\n    /* don't try to compress a block that's too short */\n    if (in_len == 0)\n    {\n        *out_len = 0;\n        r = LZO_E_OK;\n    }\n    else if (in_len <= MIN_LOOKAHEAD + 1)\n    {\n#if defined(LZO_RETURN_IF_NOT_COMPRESSIBLE)\n        *out_len = 0;\n        r = LZO_E_NOT_COMPRESSIBLE;\n#else\n        *out_len = pd(STORE_RUN(out,in,in_len), out);\n        r = (*out_len > in_len) ? LZO_E_OK : LZO_E_ERROR;\n#endif\n    }\n    else\n        r = func(in,in_len,out,out_len,wrkmem);\n\n    return r;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1a_99.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// compress a block of data.\n************************************************************************/\n", "func_signal": "static __lzo_noinline\nint do_compress          ( const lzo_bytep in , lzo_uint  in_len,\n                                 lzo_bytep out, lzo_uintp out_len,\n                                 lzo_voidp wrkmem )", "code": "{\n    const lzo_bytep ip;\n    lzo_bytep op;\n    const lzo_bytep const in_end = in + in_len;\n    const lzo_bytep const ip_end = in + in_len - 9;\n    const lzo_bytep ii;\n    lzo_dict_p const dict = (lzo_dict_p) wrkmem;\n\n    op = out;\n    ip = in;\n    ii = ip;\n\n    ip++;\n    for (;;)\n    {\n        const lzo_bytep m_pos;\n        LZO_DEFINE_UNINITIALIZED_VAR(lzo_uint, m_off, 0);\n        lzo_uint m_len;\n        lzo_uint dindex;\n        lzo_uint lit;\n\n        DINDEX1(dindex,ip);\n        GINDEX(m_pos,m_off,dict,dindex,in);\n        if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M3_MAX_OFFSET))\n            goto literal;\n#if 1\n        if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])\n            goto try_match;\n        DINDEX2(dindex,ip);\n#endif\n        GINDEX(m_pos,m_off,dict,dindex,in);\n        if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M3_MAX_OFFSET))\n            goto literal;\n        if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])\n            goto try_match;\n        goto literal;\n\n\ntry_match:\n#if 0 && (LZO_OPT_UNALIGNED16)\n        if (UA_GET_NE16(m_pos) != UA_GET_NE16(ip))\n#else\n        if (m_pos[0] != ip[0] || m_pos[1] != ip[1])\n#endif\n        {\n        }\n        else\n        {\n            if (m_pos[2] == ip[2])\n            {\n                m_pos += 3;\n#if 0\n                if (m_off <= M2_MAX_OFFSET)\n                    goto match;\n                if (lit <= 3)\n                    goto match;\n                if (lit == 3)           /* better compression, but slower */\n                {\n                    assert(op - 2 > out); op[-2] |= LZO_BYTE(3);\n                    *op++ = *ii++; *op++ = *ii++; *op++ = *ii++;\n                    goto code_match;\n                }\n                if (*m_pos == ip[3])\n#endif\n                    goto match;\n            }\n        }\n\n\n    /* a literal */\nliteral:\n        UPDATE_I(dict,0,dindex,ip,in);\n        if (++ip >= ip_end)\n            break;\n        continue;\n\n\n    /* a match */\nmatch:\n        UPDATE_I(dict,0,dindex,ip,in);\n        /* store current literal run */\n        lit = pd(ip,ii);\n        if (lit > 0)\n        {\n            lzo_uint t = lit;\n\n            if (t < 4 && op > out)\n                op[-2] = LZO_BYTE(op[-2] | t);\n            else if (t <= 31)\n                *op++ = LZO_BYTE(t);\n            else\n            {\n                lzo_uint tt = t - 31;\n\n                *op++ = 0;\n                while (tt > 255)\n                {\n                    tt -= 255;\n                    UA_SET1(op, 0);\n                    op++;\n                }\n                assert(tt > 0);\n                *op++ = LZO_BYTE(tt);\n            }\n            do *op++ = *ii++; while (--t > 0);\n        }\n        assert(ii == ip);\n\n\n        /* code the match */\n        ip += 3;\n        if (*m_pos++ != *ip++ || *m_pos++ != *ip++ || *m_pos++ != *ip++ ||\n            *m_pos++ != *ip++ || *m_pos++ != *ip++ || *m_pos++ != *ip++)\n        {\n            --ip;\n            m_len = pd(ip, ii);\n            assert(m_len >= 3); assert(m_len <= 8);\n\n            if (m_off <= M2_MAX_OFFSET)\n            {\n                m_off -= 1;\n                *op++ = LZO_BYTE(((m_len - 2) << 5) | ((m_off & 7) << 2));\n                *op++ = LZO_BYTE(m_off >> 3);\n            }\n            else if (m_len == 3 && m_off <= 2*M2_MAX_OFFSET && lit > 0)\n            {\n                m_off -= 1;\n                /* m_off -= M2_MAX_OFFSET; */\n                *op++ = LZO_BYTE(((m_off & 7) << 2));\n                *op++ = LZO_BYTE(m_off >> 3);\n            }\n            else\n            {\n                *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));\n                *op++ = LZO_BYTE((m_off & 63) << 2);\n                *op++ = LZO_BYTE(m_off >> 6);\n            }\n        }\n        else\n        {\n            {\n                const lzo_bytep end;\n                end = in_end;\n                while (ip < end && *m_pos == *ip)\n                    { m_pos++; ip++; }\n                m_len = pd(ip, ii);\n            }\n            assert(m_len >= 3);\n\n            if (m_len <= 33)\n                *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));\n            else\n            {\n                m_len -= 33;\n                *op++ = M3_MARKER | 0;\n                while (m_len > 255)\n                {\n                    m_len -= 255;\n                    UA_SET1(op, 0);\n                    op++;\n                }\n                assert(m_len > 0);\n                *op++ = LZO_BYTE(m_len);\n            }\n            *op++ = LZO_BYTE((m_off & 63) << 2);\n            *op++ = LZO_BYTE(m_off >> 6);\n        }\n\n        ii = ip;\n        if (ip >= ip_end)\n            break;\n    }\n\n\n    /* store final literal run */\n    if (pd(in_end,ii) > 0)\n    {\n        lzo_uint t = pd(in_end,ii);\n\n        if (t < 4 && op > out)\n            op[-2] = LZO_BYTE(op[-2] | t);\n        else if (t <= 31)\n            *op++ = LZO_BYTE(t);\n        else\n        {\n            lzo_uint tt = t - 31;\n\n            *op++ = 0;\n            while (tt > 255)\n            {\n                tt -= 255;\n                UA_SET1(op, 0);\n                op++;\n            }\n            assert(tt > 0);\n            *op++ = LZO_BYTE(tt);\n        }\n        UA_COPYN(op, ii, t);\n        op += t;\n    }\n\n    *out_len = pd(op, out);\n    return LZO_E_OK;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1f_1.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/***********************************************************************\n// LZO1 decompress a block of data.\n//\n// Could be easily translated into assembly code.\n************************************************************************/\n", "func_signal": "LZO_PUBLIC(int)\nlzo1_decompress  ( const lzo_bytep in , lzo_uint  in_len,\n                         lzo_bytep out, lzo_uintp out_len,\n                         lzo_voidp wrkmem )", "code": "{\n    lzo_bytep op;\n    const lzo_bytep ip;\n    const lzo_bytep const ip_end = in + in_len;\n    lzo_uint t;\n\n    LZO_UNUSED(wrkmem);\n\n    op = out;\n    ip = in;\n    while (ip < ip_end)\n    {\n        t = *ip++;  /* get marker */\n\n        if (t < R0MIN)          /* a literal run */\n        {\n            if (t == 0)             /* a R0 literal run */\n            {\n                t = *ip++;\n                if (t >= R0FAST - R0MIN)            /* a long R0 run */\n                {\n                    t -= R0FAST - R0MIN;\n                    if (t == 0)\n                        t = R0FAST;\n                    else\n                    {\n#if 0\n                        t = 256u << ((unsigned) t);\n#else\n                        /* help the optimizer */\n                        lzo_uint tt = 256;\n                        do tt <<= 1; while (--t > 0);\n                        t = tt;\n#endif\n                    }\n                    MEMCPY8_DS(op,ip,t);\n                    continue;\n                }\n                t += R0MIN;\n            }\n            MEMCPY_DS(op,ip,t);\n        }\n        else                    /* a match */\n        {\n            lzo_uint tt;\n            /* get match offset */\n            const lzo_bytep m_pos = op - 1;\n            m_pos -= (lzo_uint)(t & OMASK) | (((lzo_uint) *ip++) << OBITS);\n\n            /* get match len */\n            if (t >= ((MSIZE - 1) << OBITS))                /* all m-bits set */\n                tt = (MIN_MATCH_LONG - THRESHOLD) + *ip++;  /* a long match */\n            else\n                tt = t >> OBITS;                            /* a short match */\n\n            assert(m_pos >= out);\n            assert(m_pos <  op);\n            /* a half unrolled loop */\n            *op++ = *m_pos++;\n            *op++ = *m_pos++;\n            MEMCPY_DS(op,m_pos,tt);\n        }\n    }\n\n    *out_len = pd(op, out);\n\n    /* the next line is the only check in the decompressor ! */\n    return (ip == ip_end ? LZO_E_OK :\n           (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/src/lzo1.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*************************************************************************\n// method info\n**************************************************************************/\n", "func_signal": "static\nlzo_decompress_t get_decomp_info ( const compress_t *c, const char **nn )", "code": "{\n    lzo_decompress_t d = 0;\n    const char *n = NULL;\n\n    /* safe has priority over asm/fast */\n    if (!d && opt_use_safe_decompressor && opt_use_asm_fast_decompressor)\n    {\n        d = c->decompress_asm_fast_safe;\n        n = \" [fs]\";\n    }\n    if (!d && opt_use_safe_decompressor && opt_use_asm_decompressor)\n    {\n        d = c->decompress_asm_safe;\n        n = \" [as]\";\n    }\n    if (!d && opt_use_safe_decompressor)\n    {\n        d = c->decompress_safe;\n        n = \" [s]\";\n    }\n    if (!d && opt_use_asm_fast_decompressor)\n    {\n        d = c->decompress_asm_fast;\n        n = \" [f]\";\n    }\n    if (!d && opt_use_asm_decompressor)\n    {\n        d = c->decompress_asm;\n        n = \" [a]\";\n    }\n    if (!d)\n    {\n        d = c->decompress;\n        n = \"\";\n    }\n    if (!d)\n        n = \"(null)\";\n\n    if (opt_dict && c->decompress_dict_safe)\n        n = \"\";\n\n    if (nn)\n        *nn = n;\n    return d;\n}", "path": "ics-openvpn/main/src/main/cpp/lzo/lzotest/lzotest.c", "commit_date": "2017-12-27 00:00:00", "repo_name": "schwabe/ics-openvpn", "stars": 3122, "license": "None", "language": "c", "size": 54558}
{"docstring": "/*  \n *  main\n *\n *  Description:\n *      This is the entry point for the program\n *\n *  Parameters:\n *      argc: [in]\n *          This is the count of arguments in the argv array\n *      argv: [in]\n *          This is an array of filenames for which to compute message\n *          digests\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:\n *\n */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n   SHA1Context sha;                /* SHA-1 context                 */\n   FILE        *fp;                /* File pointer for reading files*/\n   char        c;                  /* Character read from file      */\n   int         i;                  /* Counter                       */\n   int         reading_stdin;      /* Are we reading standard in?   */\n   int         read_stdin = 0;     /* Have we read stdin?           */\n\n   /*\n    *  Check the program arguments and print usage information if -?\n    *  or --help is passed as the first argument.\n    */\n   if (argc > 1 && (!strcmp(argv[1],\"-?\") ||\n            !strcmp(argv[1],\"--help\")))\n   {\n      usage();\n      return 1;\n   }\n\n   /*\n    *  For each filename passed in on the command line, calculate the\n    *  SHA-1 value and display it.\n    */\n   for(i = 0; i < argc; i++)\n   {\n      /*\n       *  We start the counter at 0 to guarantee entry into the for\n       *  loop. So if 'i' is zero, we will increment it now.  If there\n       *  is no argv[1], we will use STDIN below.\n       */\n      if (i == 0)\n         i++;\n\n      if (argc == 1 || !strcmp(argv[i],\"-\"))\n      {\n#ifdef WIN32\n         setmode(fileno(stdin), _O_BINARY);\n#endif\n         fp = stdin;\n         reading_stdin = 1;\n      }\n      else\n      {\n         if (!(fp = fopen(argv[i],\"rb\")))\n         {\n            fprintf(stderr,\n                  \"sha: unable to open file %s\\n\",\n                  argv[i]);\n            return 2;\n         }\n         reading_stdin = 0;\n      }\n\n      /*\n       *  We do not want to read STDIN multiple times\n       */\n      if (reading_stdin)\n      {\n         if (read_stdin)\n            continue;\n\n         read_stdin = 1;\n      }\n\n      /*\n       *  Reset the SHA-1 context and process input\n       */\n      SHA1Reset(&sha);\n\n      c = fgetc(fp);\n      while(!feof(fp))\n      {\n         SHA1Input(&sha, &c, 1);\n         c = fgetc(fp);\n      }\n\n      if (!reading_stdin)\n         fclose(fp);\n\n      if (!SHA1Result(&sha))\n      {\n         fprintf(stderr,\n               \"sha: could not compute message digest for %s\\n\",\n               reading_stdin?\"STDIN\":argv[i]);\n      }\n      else\n      {\n         printf( \"%08X %08X %08X %08X %08X - %s\\n\",\n               sha.Message_Digest[0],\n               sha.Message_Digest[1],\n               sha.Message_Digest[2],\n               sha.Message_Digest[3],\n               sha.Message_Digest[4],\n               reading_stdin?\"STDIN\":argv[i]);\n      }\n   }\n\n   return 0;\n}", "path": "desmume/desmume/src/libretro-common/utils/sha1.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*\n** __gc tag method: calls library's `ll_unloadlib' function with the lib\n** handle\n*/\n", "func_signal": "static int gctm (lua_State *L)", "code": "{\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}", "path": "desmume/desmume/src/frontend/cocoa/lua/loadlib.c", "commit_date": "2017-10-19 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/**\n * convert_s16_to_float_init_simd:\n *\n * Sets up function pointers for conversion\n * functions based on CPU features.\n **/\n", "func_signal": "void convert_s16_to_float_init_simd(void)", "code": "{\n   unsigned cpu = cpu_features_get();\n\n   (void)cpu;\n#if defined(__ARM_NEON__) && !defined(VITA)\n   convert_s16_to_float_arm = (cpu & RETRO_SIMD_NEON) ?\n      convert_s16_to_float_neon : convert_s16_to_float_C;\n#endif\n}", "path": "desmume/desmume/src/libretro-common/conversion/s16_to_float.c", "commit_date": "2016-11-24 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/* Pretty much strncasecmp. */\n", "func_signal": "static int casencmp(const char *a, const char *b, size_t n)", "code": "{\n   size_t i;\n\n   for (i = 0; i < n; i++)\n   {\n      int a_lower = tolower(a[i]);\n      int b_lower = tolower(b[i]);\n      if (a_lower != b_lower)\n         return a_lower - b_lower;\n   }\n\n   return 0;\n}", "path": "desmume/desmume/src/libretro-common/compat/compat_strcasestr.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/**\n * scaler_ctx_scale:\n * @ctx          : pointer to scaler context object.\n * @output       : pointer to output image.\n * @input        : pointer to input image.\n *\n * Scales an input image to an output image.\n **/\n", "func_signal": "void scaler_ctx_scale(struct scaler_ctx *ctx,\n      void *output, const void *input)", "code": "{\n   const void *input_frame = input;\n   void *output_frame      = output;\n   int input_stride        = ctx->in_stride;\n   int output_stride       = ctx->out_stride;\n\n   if (ctx->unscaled)\n   {\n      /* Just perform straight pixel conversion. */\n      ctx->direct_pixconv(output, input,\n            ctx->out_width, ctx->out_height,\n            ctx->out_stride, ctx->in_stride);\n      return;\n   }\n\n   if (ctx->in_fmt != SCALER_FMT_ARGB8888)\n   {\n      ctx->in_pixconv(ctx->input.frame, input,\n            ctx->in_width, ctx->in_height,\n            ctx->input.stride, ctx->in_stride);\n\n      input_frame       = ctx->input.frame;\n      input_stride      = ctx->input.stride;\n   }\n\n   if (ctx->out_fmt != SCALER_FMT_ARGB8888)\n   {\n      output_frame  = ctx->output.frame;\n      output_stride = ctx->output.stride;\n   }\n\n   if (ctx->scaler_special)\n   {\n      /* Take some special, and (hopefully) more optimized path. */\n      ctx->scaler_special(ctx, output_frame, input_frame,\n            ctx->out_width, ctx->out_height,\n            ctx->in_width, ctx->in_height,\n            output_stride, input_stride);\n   }\n   else\n   {\n      /* Take generic filter path. */\n      if (ctx->scaler_horiz)\n         ctx->scaler_horiz(ctx, input_frame, input_stride);\n      if (ctx->scaler_vert)\n         ctx->scaler_vert (ctx, output, output_stride);\n   }\n\n   if (ctx->out_fmt != SCALER_FMT_ARGB8888)\n      ctx->out_pixconv(output, ctx->output.frame,\n            ctx->out_width, ctx->out_height,\n            ctx->out_stride, ctx->output.stride);\n}", "path": "desmume/desmume/src/libretro-common/gfx/scaler/scaler.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/**\n * convert_s16_to_float_altivec:\n * @out               : output buffer\n * @in                : input buffer\n * @samples           : size of samples to be converted\n * @gain              : gain applied (e.g. audio volume)\n *\n * Converts from signed integer 16-bit\n * to floating point.\n *\n * AltiVec implementation callback function.\n **/\n", "func_signal": "void convert_s16_to_float_altivec(float *out,\n      const int16_t *in, size_t samples, float gain)", "code": "{\n   size_t samples_in = samples;\n\n   /* Unaligned loads/store is a bit expensive, so we \n    * optimize for the good path (very likely). */\n   if (((uintptr_t)out & 15) + ((uintptr_t)in & 15) == 0)\n   {\n      size_t i;\n      const vector float gain_vec = { gain, gain , gain, gain };\n      const vector float zero_vec = { 0.0f, 0.0f, 0.0f, 0.0f};\n\n      for (i = 0; i + 8 <= samples; i += 8, in += 8, out += 8)\n      {\n         vector signed short input = vec_ld(0, in);\n         vector signed int hi      = vec_unpackh(input);\n         vector signed int lo      = vec_unpackl(input);\n         vector float out_hi       = vec_madd(vec_ctf(hi, 15), gain_vec, zero_vec);\n         vector float out_lo       = vec_madd(vec_ctf(lo, 15), gain_vec, zero_vec);\n\n         vec_st(out_hi,  0, out);\n         vec_st(out_lo, 16, out);\n      }\n\n      samples_in -= i;\n   }\n   convert_s16_to_float_C(out, in, samples_in, gain);\n}", "path": "desmume/desmume/src/libretro-common/conversion/s16_to_float.c", "commit_date": "2016-11-24 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*\nSRes SzReadTime(const CObjectVector<CBuf> &dataVector,\n    CObjectVector<CSzFileItem> &files, UInt64 type)\n{\n  CBoolVector boolVector;\n  RINOK(ReadBoolVector2(files.Size(), boolVector))\n\n  CStreamSwitch streamSwitch;\n  RINOK(streamSwitch.Set(this, &dataVector));\n\n  for (int i = 0; i < files.Size(); i++)\n  {\n    CSzFileItem &file = files[i];\n    CArchiveFileTime fileTime;\n    bool defined = boolVector[i];\n    if (defined)\n    {\n      UInt32 low, high;\n      RINOK(SzReadUInt32(low));\n      RINOK(SzReadUInt32(high));\n      fileTime.dwLowDateTime = low;\n      fileTime.dwHighDateTime = high;\n    }\n    switch(type)\n    {\n      case k7zIdCTime: file.IsCTimeDefined = defined; if (defined) file.CTime = fileTime; break;\n      case k7zIdATime: file.IsATimeDefined = defined; if (defined) file.ATime = fileTime; break;\n      case k7zIdMTime: file.IsMTimeDefined = defined; if (defined) file.MTime = fileTime; break;\n    }\n  }\n  return SZ_OK;\n}\n*/\n", "func_signal": "static int TestSignatureCandidate(Byte *testBytes)", "code": "{\n  size_t i;\n  for (i = 0; i < k7zSignatureSize; i++)\n    if (testBytes[i] != k7zSignature[i])\n      return 0;\n  return 1;\n}", "path": "desmume/desmume/src/frontend/windows/File_Extractor/7z_C/7zIn.c", "commit_date": "2016-11-24 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*\n** check whether list has any jump that do not produce a value\n** (or produce an inverted value)\n*/\n", "func_signal": "static int need_value (FuncState *fs, int list)", "code": "{\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}", "path": "desmume/desmume/src/frontend/cocoa/lua/lcode.c", "commit_date": "2017-10-19 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*\n** returns current `pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\n", "func_signal": "int luaK_getlabel (FuncState *fs)", "code": "{\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}", "path": "desmume/desmume/src/frontend/cocoa/lua/lcode.c", "commit_date": "2017-10-19 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/**\n * convert_s16_to_float_SSE2:\n * @out               : output buffer\n * @in                : input buffer\n * @samples           : size of samples to be converted\n * @gain              : gain applied (e.g. audio volume)\n *\n * Converts from signed integer 16-bit\n * to floating point.\n *\n * SSE2 implementation callback function.\n **/\n", "func_signal": "void convert_s16_to_float_SSE2(float *out,\n      const int16_t *in, size_t samples, float gain)", "code": "{\n   size_t i;\n   float fgain   = gain / UINT32_C(0x80000000);\n   __m128 factor = _mm_set1_ps(fgain);\n\n   for (i = 0; i + 8 <= samples; i += 8, in += 8, out += 8)\n   {\n      __m128i input    = _mm_loadu_si128((const __m128i *)in);\n      __m128i regs_l   = _mm_unpacklo_epi16(_mm_setzero_si128(), input);\n      __m128i regs_r   = _mm_unpackhi_epi16(_mm_setzero_si128(), input);\n      __m128 output_l  = _mm_mul_ps(_mm_cvtepi32_ps(regs_l), factor);\n      __m128 output_r  = _mm_mul_ps(_mm_cvtepi32_ps(regs_r), factor);\n\n      _mm_storeu_ps(out + 0, output_l);\n      _mm_storeu_ps(out + 4, output_r);\n   }\n\n   convert_s16_to_float_C(out, in, samples - i, gain);\n}", "path": "desmume/desmume/src/libretro-common/conversion/s16_to_float.c", "commit_date": "2016-11-24 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*  \n *  SHA1ProcessMessageBlock\n *\n *  Description:\n *      This function will process the next 512 bits of the message\n *      stored in the Message_Block array.\n *\n *  Parameters:\n *      None.\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:\n *      Many of the variable names in the SHAContext, especially the\n *      single character names, were used because those were the names\n *      used in the publication.\n *         \n *\n */\n", "func_signal": "void SHA1ProcessMessageBlock(SHA1Context *context)", "code": "{\n   const unsigned K[] =            /* Constants defined in SHA-1   */      \n   {\n      0x5A827999,\n      0x6ED9EBA1,\n      0x8F1BBCDC,\n      0xCA62C1D6\n   };\n   int         t;                  /* Loop counter                 */\n   unsigned    temp;               /* Temporary word value         */\n   unsigned    W[80];              /* Word sequence                */\n   unsigned    A, B, C, D, E;      /* Word buffers                 */\n\n   /*\n    *  Initialize the first 16 words in the array W\n    */\n   for(t = 0; t < 16; t++)\n   {\n      W[t] = ((unsigned) context->Message_Block[t * 4]) << 24;\n      W[t] |= ((unsigned) context->Message_Block[t * 4 + 1]) << 16;\n      W[t] |= ((unsigned) context->Message_Block[t * 4 + 2]) << 8;\n      W[t] |= ((unsigned) context->Message_Block[t * 4 + 3]);\n   }\n\n   for(t = 16; t < 80; t++)\n   {\n      W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);\n   }\n\n   A = context->Message_Digest[0];\n   B = context->Message_Digest[1];\n   C = context->Message_Digest[2];\n   D = context->Message_Digest[3];\n   E = context->Message_Digest[4];\n\n   for(t = 0; t < 20; t++)\n   {\n      temp =  SHA1CircularShift(5,A) +\n         ((B & C) | ((~B) & D)) + E + W[t] + K[0];\n      temp &= 0xFFFFFFFF;\n      E = D;\n      D = C;\n      C = SHA1CircularShift(30,B);\n      B = A;\n      A = temp;\n   }\n\n   for(t = 20; t < 40; t++)\n   {\n      temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];\n      temp &= 0xFFFFFFFF;\n      E = D;\n      D = C;\n      C = SHA1CircularShift(30,B);\n      B = A;\n      A = temp;\n   }\n\n   for(t = 40; t < 60; t++)\n   {\n      temp = SHA1CircularShift(5,A) +\n         ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];\n      temp &= 0xFFFFFFFF;\n      E = D;\n      D = C;\n      C = SHA1CircularShift(30,B);\n      B = A;\n      A = temp;\n   }\n\n   for(t = 60; t < 80; t++)\n   {\n      temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];\n      temp &= 0xFFFFFFFF;\n      E = D;\n      D = C;\n      C = SHA1CircularShift(30,B);\n      B = A;\n      A = temp;\n   }\n\n   context->Message_Digest[0] =\n      (context->Message_Digest[0] + A) & 0xFFFFFFFF;\n   context->Message_Digest[1] =\n      (context->Message_Digest[1] + B) & 0xFFFFFFFF;\n   context->Message_Digest[2] =\n      (context->Message_Digest[2] + C) & 0xFFFFFFFF;\n   context->Message_Digest[3] =\n      (context->Message_Digest[3] + D) & 0xFFFFFFFF;\n   context->Message_Digest[4] =\n      (context->Message_Digest[4] + E) & 0xFFFFFFFF;\n\n   context->Message_Block_Index = 0;\n}", "path": "desmume/desmume/src/libretro-common/utils/sha1.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*  \n *  SHA1Input\n *\n *  Description:\n *      This function accepts an array of octets as the next portion of\n *      the message.\n *\n *  Parameters:\n *      context: [in/out]\n *          The SHA-1 context to update\n *      message_array: [in]\n *          An array of characters representing the next portion of the\n *          message.\n *      length: [in]\n *          The length of the message in message_array\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:\n *\n */\n", "func_signal": "void SHA1Input(     SHA1Context         *context,\n                    const unsigned char *message_array,\n                    unsigned            length)", "code": "{\n   if (!length)\n      return;\n\n   if (context->Computed || context->Corrupted)\n   {\n      context->Corrupted = 1;\n      return;\n   }\n\n   while(length-- && !context->Corrupted)\n   {\n      context->Message_Block[context->Message_Block_Index++] =\n         (*message_array & 0xFF);\n\n      context->Length_Low += 8;\n      /* Force it to 32 bits */\n      context->Length_Low &= 0xFFFFFFFF;\n      if (context->Length_Low == 0)\n      {\n         context->Length_High++;\n         /* Force it to 32 bits */\n         context->Length_High &= 0xFFFFFFFF;\n         if (context->Length_High == 0)\n         {\n            /* Message is too long */\n            context->Corrupted = 1;\n         }\n      }\n\n      if (context->Message_Block_Index == 64)\n         SHA1ProcessMessageBlock(context);\n\n      message_array++;\n   }\n}", "path": "desmume/desmume/src/libretro-common/utils/sha1.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*  \n *  SHA1PadMessage\n *\n *  Description:\n *      According to the standard, the message must be padded to an even\n *      512 bits.  The first padding bit must be a '1'.  The last 64\n *      bits represent the length of the original message.  All bits in\n *      between should be 0.  This function will pad the message\n *      according to those rules by filling the Message_Block array\n *      accordingly.  It will also call SHA1ProcessMessageBlock()\n *      appropriately.  When it returns, it can be assumed that the\n *      message digest has been computed.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to pad\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:\n *\n */\n", "func_signal": "void SHA1PadMessage(SHA1Context *context)", "code": "{\n   /*\n    *  Check to see if the current message block is too small to hold\n    *  the initial padding bits and length.  If so, we will pad the\n    *  block, process it, and then continue padding into a second\n    *  block.\n    */\n   if (context->Message_Block_Index > 55)\n   {\n      context->Message_Block[context->Message_Block_Index++] = 0x80;\n      while(context->Message_Block_Index < 64)\n         context->Message_Block[context->Message_Block_Index++] = 0;\n\n      SHA1ProcessMessageBlock(context);\n\n      while(context->Message_Block_Index < 56)\n         context->Message_Block[context->Message_Block_Index++] = 0;\n   }\n   else\n   {\n      context->Message_Block[context->Message_Block_Index++] = 0x80;\n      while(context->Message_Block_Index < 56)\n         context->Message_Block[context->Message_Block_Index++] = 0;\n   }\n\n   /*\n    *  Store the message length as the last 8 octets\n    */\n   context->Message_Block[56] = (context->Length_High >> 24) & 0xFF;\n   context->Message_Block[57] = (context->Length_High >> 16) & 0xFF;\n   context->Message_Block[58] = (context->Length_High >> 8) & 0xFF;\n   context->Message_Block[59] = (context->Length_High) & 0xFF;\n   context->Message_Block[60] = (context->Length_Low >> 24) & 0xFF;\n   context->Message_Block[61] = (context->Length_Low >> 16) & 0xFF;\n   context->Message_Block[62] = (context->Length_Low >> 8) & 0xFF;\n   context->Message_Block[63] = (context->Length_Low) & 0xFF;\n\n   SHA1ProcessMessageBlock(context);\n}", "path": "desmume/desmume/src/libretro-common/utils/sha1.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/**\n * set_direct_pix_conv:\n * @ctx          : pointer to scaler context object.\n *\n * Bind a pixel converter callback function to the 'direct_pixconv' function pointer\n * of the scaler context object.\n *\n * Returns: true if a pixel converter function callback could be bound, false if not.\n * If false, the function callback 'direct_pixconv' is still unbound.\n **/\n", "func_signal": "static bool set_direct_pix_conv(struct scaler_ctx *ctx)", "code": "{\n   if (ctx->in_fmt == ctx->out_fmt)\n   {\n      ctx->direct_pixconv = conv_copy;\n      return true;\n   }\n\n   switch (ctx->in_fmt)\n   {\n      case SCALER_FMT_0RGB1555:\n         switch (ctx->out_fmt)\n         {\n            case SCALER_FMT_ARGB8888:\n               ctx->direct_pixconv = conv_0rgb1555_argb8888;\n               break;\n            case SCALER_FMT_RGB565:\n               ctx->direct_pixconv = conv_0rgb1555_rgb565;\n               break;\n            case SCALER_FMT_BGR24:\n               ctx->direct_pixconv = conv_0rgb1555_bgr24;\n               break;\n            default:\n               break;\n         }\n         break;\n      case SCALER_FMT_RGB565:\n         switch (ctx->out_fmt)\n         {\n            case SCALER_FMT_ARGB8888:\n               ctx->direct_pixconv = conv_rgb565_argb8888;\n               break;\n            case SCALER_FMT_BGR24:\n               ctx->direct_pixconv = conv_rgb565_bgr24;\n               break;\n            case SCALER_FMT_0RGB1555:\n               ctx->direct_pixconv = conv_rgb565_0rgb1555;\n               break;\n            default:\n               break;\n         }\n         break;\n      case SCALER_FMT_BGR24:\n         switch (ctx->out_fmt)\n         {\n            case SCALER_FMT_ARGB8888:\n               ctx->direct_pixconv = conv_bgr24_argb8888;\n               break;\n            default:\n               break;\n         }\n         break;\n      case SCALER_FMT_ARGB8888:\n         switch (ctx->out_fmt)\n         {\n            case SCALER_FMT_0RGB1555:\n               ctx->direct_pixconv = conv_argb8888_0rgb1555;\n               break;\n            case SCALER_FMT_BGR24:\n               ctx->direct_pixconv = conv_argb8888_bgr24;\n               break;\n            case SCALER_FMT_ABGR8888:\n               ctx->direct_pixconv = conv_argb8888_abgr8888;\n               break;\n            case SCALER_FMT_RGBA4444:\n               ctx->direct_pixconv = conv_argb8888_rgba4444;\n               break;\n            default:\n               break;\n         }\n         break;\n      case SCALER_FMT_YUYV:\n         switch (ctx->out_fmt)\n         {\n            case SCALER_FMT_ARGB8888:\n               ctx->direct_pixconv = conv_yuyv_argb8888;\n               break;\n            default:\n               break;\n         }\n         break;\n      case SCALER_FMT_RGBA4444:\n         switch (ctx->out_fmt)\n         {\n            case SCALER_FMT_ARGB8888:\n               ctx->direct_pixconv = conv_rgba4444_argb8888;\n               break;\n            case SCALER_FMT_RGB565:\n               ctx->direct_pixconv = conv_rgba4444_rgb565;\n               break;\n            default:\n               break;\n         }\n         break;\n      case SCALER_FMT_ABGR8888:\n         /* FIXME/TODO */\n         break;\n   }\n\n   if (!ctx->direct_pixconv)\n      return false;\n\n   return true;\n}", "path": "desmume/desmume/src/libretro-common/gfx/scaler/scaler.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*  \n *  SHA1Result\n *\n *  Description:\n *      This function will return the 160-bit message digest into the\n *      Message_Digest array within the SHA1Context provided\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to use to calculate the SHA-1 hash.\n *\n *  Returns:\n *      1 if successful, 0 if it failed.\n *\n *  Comments:\n *\n */\n", "func_signal": "int SHA1Result(SHA1Context *context)", "code": "{\n   if (context->Corrupted)\n      return 0;\n\n   if (!context->Computed)\n   {\n      SHA1PadMessage(context);\n      context->Computed = 1;\n   }\n\n   return 1;\n}", "path": "desmume/desmume/src/libretro-common/utils/sha1.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/**\n * scaler_free:\n * @ptr          : pointer to scaler object.\n *\n * Frees a scaler object.\n **/\n", "func_signal": "void scaler_free(void *ptr)", "code": "{\n   if (ptr)\n      free(ptr);\n}", "path": "desmume/desmume/src/libretro-common/gfx/scaler/scaler.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/*  \n *  usage\n *\n *  Description:\n *      This function will display program usage information to the\n *      user.\n *\n *  Parameters:\n *      None.\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:\n *\n */\n", "func_signal": "void usage(void)", "code": "{\n   printf(\"usage: sha <file> [<file> ...]\\n\");\n   printf(\"\\tThis program will display the message digest\\n\");\n   printf(\"\\tfor files using the Secure Hashing Algorithm (SHA-1).\\n\");\n}", "path": "desmume/desmume/src/libretro-common/utils/sha1.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/**\n * scaler_alloc:\n * @elem_size    : size of the elements to be used.\n * @siz          : size of the image that the scaler needs to handle.\n *\n * Allocate and returns a scaler object.\n *\n * Returns: pointer to a scaler object of type 'void *' on success,\n * NULL in case of error. Has to be freed manually.\n **/\n", "func_signal": "void *scaler_alloc(size_t elem_size, size_t size)", "code": "{\n   void *ptr = calloc(elem_size, size);\n   if (!ptr)\n      return NULL;\n   return ptr;\n}", "path": "desmume/desmume/src/libretro-common/gfx/scaler/scaler.c", "commit_date": "2016-03-21 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/**\n * convert_s16_to_float_C:\n * @out               : output buffer\n * @in                : input buffer\n * @samples           : size of samples to be converted\n * @gain              : gain applied (.e.g. audio volume)\n *\n * Converts from signed integer 16-bit\n * to floating point.\n *\n * C implementation callback function.\n **/\n", "func_signal": "void convert_s16_to_float_C(float *out,\n      const int16_t *in, size_t samples, float gain)", "code": "{\n   size_t i;\n   gain = gain / 0x8000;\n   for (i = 0; i < samples; i++)\n      out[i] = (float)in[i] * gain; \n}", "path": "desmume/desmume/src/libretro-common/conversion/s16_to_float.c", "commit_date": "2016-11-24 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "/* ---------- MtThread ---------- */\n", "func_signal": "void CMtThread_Construct(CMtThread *p, CMtCoder *mtCoder)", "code": "{\n  p->mtCoder = mtCoder;\n  p->outBuf = 0;\n  p->inBuf = 0;\n  Event_Construct(&p->canRead);\n  Event_Construct(&p->canWrite);\n  LoopThread_Construct(&p->thread);\n}", "path": "desmume/desmume/src/frontend/windows/File_Extractor/7z_C/MtCoder.c", "commit_date": "2016-11-24 00:00:00", "repo_name": "TASEmulators/desmume", "stars": 2640, "license": "gpl-2.0", "language": "c", "size": 97551}
{"docstring": "// Saves a tinn to disk.\n", "func_signal": "void xtsave(const Tinn t, const char* const path)", "code": "{\n    FILE* const file = fopen(path, \"w\");\n    // Save header.\n    fprintf(file, \"%d %d %d\\n\", t.nips, t.nhid, t.nops);\n    // Save biases and weights.\n    for(int i = 0; i < t.nb; i++) fprintf(file, \"%f\\n\", (double) t.b[i]);\n    for(int i = 0; i < t.nw; i++) fprintf(file, \"%f\\n\", (double) t.w[i]);\n    fclose(file);\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Performs forward propagation.\n", "func_signal": "static void fprop(const Tinn t, const float* const in)", "code": "{\n    // Calculate hidden layer neuron values.\n    for(int i = 0; i < t.nhid; i++)\n    {\n        float sum = 0.0f;\n        for(int j = 0; j < t.nips; j++)\n            sum += in[j] * t.w[i * t.nips + j];\n        t.h[i] = act(sum + t.b[0]);\n    }\n    // Calculate output layer neuron values.\n    for(int i = 0; i < t.nops; i++)\n    {\n        float sum = 0.0f;\n        for(int j = 0; j < t.nhid; j++)\n            sum += t.h[j] * t.x[i * t.nhid + j];\n        t.o[i] = act(sum + t.b[1]);\n    }\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Gets one row of inputs and outputs from a string.\n", "func_signal": "static void parse(const Data data, char* line, const int row)", "code": "{\n    const int cols = data.nips + data.nops;\n    for(int col = 0; col < cols; col++)\n    {\n        const float val = atof(strtok(col == 0 ? line : NULL, \" \"));\n        if(col < data.nips)\n            data.in[row][col] = val;\n        else\n            data.tg[row][col - data.nips] = val;\n    }\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Constructs a tinn with number of inputs, number of hidden neurons, and number of outputs\n", "func_signal": "Tinn xtbuild(const int nips, const int nhid, const int nops)", "code": "{\n    Tinn t;\n    // Tinn only supports one hidden layer so there are two biases.\n    t.nb = 2;\n    t.nw = nhid * (nips + nops);\n    t.w = (float*) calloc(t.nw, sizeof(*t.w));\n    t.x = t.w + nhid * nips;\n    t.b = (float*) calloc(t.nb, sizeof(*t.b));\n    t.h = (float*) calloc(nhid, sizeof(*t.h));\n    t.o = (float*) calloc(nops, sizeof(*t.o));\n    t.nips = nips;\n    t.nhid = nhid;\n    t.nops = nops;\n    wbrand(t);\n    return t;\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Prints an array of floats. Useful for printing predictions.\n", "func_signal": "void xtprint(const float* arr, const int size)", "code": "{\n    for(int i = 0; i < size; i++)\n        printf(\"%f \", (double) arr[i]);\n    printf(\"\\n\");\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// New data object.\n", "func_signal": "static Data ndata(const int nips, const int nops, const int rows)", "code": "{\n    const Data data = {\n        new2d(rows, nips), new2d(rows, nops), nips, nops, rows\n    };\n    return data;\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Frees a data object from the heap.\n", "func_signal": "static void dfree(const Data d)", "code": "{\n    for(int row = 0; row < d.rows; row++)\n    {\n        free(d.in[row]);\n        free(d.tg[row]);\n    }\n    free(d.in);\n    free(d.tg);\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Randomly shuffles a data object.\n", "func_signal": "static void shuffle(const Data d)", "code": "{\n    for(int a = 0; a < d.rows; a++)\n    {\n        const int b = rand() % d.rows;\n        float* ot = d.tg[a];\n        float* it = d.in[a];\n        // Swap output.\n        d.tg[a] = d.tg[b];\n        d.tg[b] = ot;\n        // Swap input.\n        d.in[a] = d.in[b];\n        d.in[b] = it;\n    }\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Reads a line from a file.\n", "func_signal": "static char* readln(FILE* const file)", "code": "{\n    int ch = EOF;\n    int reads = 0;\n    int size = 128;\n    char* line = (char*) malloc((size) * sizeof(char));\n    while((ch = getc(file)) != '\\n' && ch != EOF)\n    {\n        line[reads++] = ch;\n        if(reads + 1 == size)\n            line = (char*) realloc((line), (size *= 2) * sizeof(char));\n    }\n    line[reads] = '\\0';\n    return line;\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Randomizes tinn weights and biases.\n", "func_signal": "static void wbrand(const Tinn t)", "code": "{\n    for(int i = 0; i < t.nw; i++) t.w[i] = frand() - 0.5f;\n    for(int i = 0; i < t.nb; i++) t.b[i] = frand() - 0.5f;\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Returns the number of lines in a file.\n", "func_signal": "static int lns(FILE* const file)", "code": "{\n    int ch = EOF;\n    int lines = 0;\n    int pc = '\\n';\n    while((ch = getc(file)) != EOF)\n    {\n        if(ch == '\\n')\n            lines++;\n        pc = ch;\n    }\n    if(pc != '\\n')\n        lines++;\n    rewind(file);\n    return lines;\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Parses file from path getting all inputs and outputs for the neural network. Returns data object.\n", "func_signal": "static Data build(const char* path, const int nips, const int nops)", "code": "{\n    FILE* file = fopen(path, \"r\");\n    if(file == NULL)\n    {\n        printf(\"Could not open %s\\n\", path);\n        printf(\"Get it from the machine learning database: \");\n        printf(\"wget http://archive.ics.uci.edu/ml/machine-learning-databases/semeion/semeion.data\\n\");\n        exit(1);\n    }\n    const int rows = lns(file);\n    Data data = ndata(nips, nops, rows);\n    for(int row = 0; row < rows; row++)\n    {\n        char* line = readln(file);\n        parse(data, line, row);\n        free(line);\n    }\n    fclose(file);\n    return data;\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Frees object from heap.\n", "func_signal": "void xtfree(const Tinn t)", "code": "{\n    free(t.w);\n    free(t.b);\n    free(t.h);\n    free(t.o);\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Computes total error of target to output.\n", "func_signal": "static float toterr(const float* const tg, const float* const o, const int size)", "code": "{\n    float sum = 0.0f;\n    for(int i = 0; i < size; i++)\n        sum += err(tg[i], o[i]);\n    return sum;\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Performs back propagation.\n", "func_signal": "static void bprop(const Tinn t, const float* const in, const float* const tg, float rate)", "code": "{\n    for(int i = 0; i < t.nhid; i++)\n    {\n        float sum = 0.0f;\n        // Calculate total error change with respect to output.\n        for(int j = 0; j < t.nops; j++)\n        {\n            const float a = pderr(t.o[j], tg[j]);\n            const float b = pdact(t.o[j]);\n            sum += a * b * t.x[j * t.nhid + i];\n            // Correct weights in hidden to output layer.\n            t.x[j * t.nhid + i] -= rate * a * b * t.h[i];\n        }\n        // Correct weights in input to hidden layer.\n        for(int j = 0; j < t.nips; j++)\n            t.w[i * t.nips + j] -= rate * sum * pdact(t.h[i]) * in[j];\n    }\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Returns an output prediction given an input.\n", "func_signal": "float* xtpredict(const Tinn t, const float* const in)", "code": "{\n    fprop(t, in);\n    return t.o;\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// New 2D array of floats.\n", "func_signal": "static float** new2d(const int rows, const int cols)", "code": "{\n    float** row = (float**) malloc((rows) * sizeof(float*));\n    for(int r = 0; r < rows; r++)\n        row[r] = (float*) malloc((cols) * sizeof(float));\n    return row;\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Loads a tinn from disk.\n", "func_signal": "Tinn xtload(const char* const path)", "code": "{\n    FILE* const file = fopen(path, \"r\");\n    int nips = 0;\n    int nhid = 0;\n    int nops = 0;\n    // Load header.\n    fscanf(file, \"%d %d %d\\n\", &nips, &nhid, &nops);\n    // Build a new tinn.\n    const Tinn t = xtbuild(nips, nhid, nops);\n    // Load bias and weights.\n    for(int i = 0; i < t.nb; i++) fscanf(file, \"%f\\n\", &t.b[i]);\n    for(int i = 0; i < t.nw; i++) fscanf(file, \"%f\\n\", &t.w[i]);\n    fclose(file);\n    return t;\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Trains a tinn with an input and target output with a learning rate. Returns target to output error.\n", "func_signal": "float xttrain(const Tinn t, const float* const in, const float* const tg, float rate)", "code": "{\n    fprop(t, in);\n    bprop(t, in, tg, rate);\n    return toterr(tg, t.o, t.nops);\n}", "path": "tinn/Tinn.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// Learns and predicts hand written digits with 98% accuracy.\n", "func_signal": "int main()", "code": "{\n    // Tinn does not seed the random number generator.\n    srand(time(0));\n    // Input and output size is harded coded here as machine learning\n    // repositories usually don't include the input and output size in the data itself.\n    const int nips = 256;\n    const int nops = 10;\n    // Hyper Parameters.\n    // Learning rate is annealed and thus not constant.\n    // It can be fine tuned along with the number of hidden layers.\n    // Feel free to modify the anneal rate.\n    // The number of iterations can be changed for stronger training.\n    float rate = 1.0f;\n    const int nhid = 28;\n    const float anneal = 0.99f;\n    const int iterations = 128;\n    // Load the training set.\n    const Data data = build(\"semeion.data\", nips, nops);\n    // Train, baby, train.\n    const Tinn tinn = xtbuild(nips, nhid, nops);\n    for(int i = 0; i < iterations; i++)\n    {\n        shuffle(data);\n        float error = 0.0f;\n        for(int j = 0; j < data.rows; j++)\n        {\n            const float* const in = data.in[j];\n            const float* const tg = data.tg[j];\n            error += xttrain(tinn, in, tg, rate);\n        }\n        printf(\"error %.12f :: learning rate %f\\n\",\n            (double) error / data.rows,\n            (double) rate);\n        rate *= anneal;\n    }\n    // This is how you save the neural network to disk.\n    xtsave(tinn, \"saved.tinn\");\n    xtfree(tinn);\n    // This is how you load the neural network from disk.\n    const Tinn loaded = xtload(\"saved.tinn\");\n    // Now we do a prediction with the neural network we loaded from disk.\n    // Ideally, we would also load a testing set to make the prediction with,\n    // but for the sake of brevity here we just reuse the training set from earlier.\n    // One data set is picked at random (zero index of input and target arrays is enough\n    // as they were both shuffled earlier).\n    const float* const in = data.in[0];\n    const float* const tg = data.tg[0];\n    const float* const pd = xtpredict(loaded, in);\n    // Prints target.\n    xtprint(tg, data.nops);\n    // Prints prediction.\n    xtprint(pd, data.nops);\n    // All done. Let's clean up.\n    xtfree(loaded);\n    dfree(data);\n    return 0;\n}", "path": "tinn/test.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "glouw/tinn", "stars": 2062, "license": "mit", "language": "c", "size": 70}
{"docstring": "// MbedTLS doesn't support SRP6a with SHA512 so we have to do this on foot\n", "func_signal": "static void\n        Calc_x(uint8_t x[SHA512_BYTES],\n               const uint8_t salt[SRP_SALT_BYTES],\n               const uint8_t* user,\n               size_t user_len,\n               const uint8_t* pass,\n               size_t pass_len)", "code": "{\n    mbedtls_sha512_context ctx;\n\n    sha512_init(&ctx);\n    sha512_update(&ctx, user, user_len);\n    sha512_update(&ctx, (const uint8_t*) \":\", 1);\n    sha512_update(&ctx, pass, pass_len);\n    sha512_final(&ctx, x);\n\n    sha512_init(&ctx);\n    sha512_update(&ctx, salt, SRP_SALT_BYTES);\n    sha512_update(&ctx, x, SHA512_BYTES);\n    sha512_final(&ctx, x);\n}", "path": "HomeKitADK/PAL/Crypto/MbedTLS/HAPMbedTLS.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Reports the completion of a pairing procedure.\n *\n * @param      server_              Accessory server.\n * @param      session_             Session.\n * @param      pairingProcedureType Pairing procedure type.\n */\n", "func_signal": "static void HAPSessionCompletePairingProcedure(\n        HAPAccessoryServerRef* server_,\n        HAPSessionRef* session_,\n        HAPPairingProcedureType pairingProcedureType)", "code": "{\n    HAPPrecondition(server_);\n    HAPAccessoryServer* server = (HAPAccessoryServer*) server_;\n    HAPPrecondition(session_);\n    HAPSession* session = (HAPSession*) session_;\n\n    switch (session->transportType) {\n        case kHAPTransportType_IP: {\n            HAPAssert(server->transports.ip);\n            return;\n        }\n        case kHAPTransportType_BLE: {\n            HAPAssert(server->transports.ble);\n            HAPNonnull(server->transports.ble)\n                    ->session.didCompletePairingProcedure(server_, session_, pairingProcedureType);\n            return;\n        }\n    }\n    HAPFatalError();\n}", "path": "HomeKitADK/HAP/HAPSession.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Handles a set of characteristic write requests.\n *\n * @param      session              IP session descriptor.\n * @param      contexts             Request contexts.\n * @param      numContexts          Length of @p contexts.\n * @param      dataBuffer           Buffer for values of type data, string or TLV8.\n * @param      timedWrite           Whether the request was a valid Execute Write Request or a regular Write Request.\n *\n * @return 0                        If all writes could be handled successfully.\n * @return -1                       Otherwise (Multi-Status).\n */\n", "func_signal": "HAP_RESULT_USE_CHECK\nstatic int handle_characteristic_write_requests(\n        HAPIPSessionDescriptor* session,\n        HAPIPWriteContextRef* contexts,\n        size_t numContexts,\n        HAPIPByteBuffer* dataBuffer,\n        bool timedWrite)", "code": "{\n    HAPPrecondition(session);\n    HAPPrecondition(session->server);\n    HAPAccessoryServer* server = (HAPAccessoryServer*) session->server;\n    HAPPrecondition(session->securitySession.type == kHAPIPSecuritySessionType_HAP);\n    HAPPrecondition(session->securitySession.isOpen);\n    HAPPrecondition(session->securitySession.isSecured || kHAPIPAccessoryServer_SessionSecurityDisabled);\n    HAPPrecondition(!HAPSessionIsTransient(&session->securitySession._.hap));\n    HAPPrecondition(contexts);\n    HAPPrecondition(dataBuffer);\n\n    int r = 0;\n\n    for (size_t i = 0; i < numContexts; i++) {\n        HAPIPWriteContext* writeContext = (HAPIPWriteContext*) &contexts[i];\n        const HAPCharacteristic* characteristic;\n        const HAPService* service;\n        const HAPAccessory* accessory;\n        get_db_ctx(session->server, writeContext->aid, writeContext->iid, &characteristic, &service, &accessory);\n        if (characteristic) {\n            HAPAssert(service);\n            HAPAssert(accessory);\n            server->ip.characteristicWriteRequestContext.ipSession = NULL;\n            for (size_t j = 0; j < server->ip.storage->numSessions; j++) {\n                HAPIPSession* ipSession = &server->ip.storage->sessions[j];\n                HAPIPSessionDescriptor* t = (HAPIPSessionDescriptor*) &ipSession->descriptor;\n                if (t->server && (t == session)) {\n                    HAPAssert(!server->ip.characteristicWriteRequestContext.ipSession);\n                    server->ip.characteristicWriteRequestContext.ipSession = ipSession;\n                }\n            }\n            HAPAssert(server->ip.characteristicWriteRequestContext.ipSession);\n            server->ip.characteristicWriteRequestContext.characteristic = characteristic;\n            server->ip.characteristicWriteRequestContext.service = service;\n            server->ip.characteristicWriteRequestContext.accessory = accessory;\n            const HAPBaseCharacteristic* baseCharacteristic = characteristic;\n            if ((writeContext->type != kHAPIPWriteValueType_None) &&\n                baseCharacteristic->properties.requiresTimedWrite && !timedWrite) {\n                // If the accessory receives a standard write request on a characteristic which requires timed write,\n                // the accessory must respond with HAP status error code -70410 (HAPIPStatusErrorCodeInvalidWrite).\n                // See HomeKit Accessory Protocol Specification R14\n                // Section 6.7.2.4 Timed Write Procedures\n                HAPLogCharacteristic(\n                        &logObject,\n                        characteristic,\n                        service,\n                        accessory,\n                        \"Rejected write: Only timed writes are supported.\");\n                writeContext->status = kHAPIPAccessoryServerStatusCode_InvalidValueInWrite;\n            } else {\n                handle_characteristic_write_request(\n                        session, characteristic, service, accessory, &contexts[i], dataBuffer);\n            }\n            server->ip.characteristicWriteRequestContext.ipSession = NULL;\n            server->ip.characteristicWriteRequestContext.characteristic = NULL;\n            server->ip.characteristicWriteRequestContext.service = NULL;\n            server->ip.characteristicWriteRequestContext.accessory = NULL;\n        } else {\n            writeContext->status = kHAPIPAccessoryServerStatusCode_ResourceDoesNotExist;\n        }\n        if ((r == 0) && (writeContext->status != kHAPIPAccessoryServerStatusCode_Success)) {\n            r = -1;\n        }\n        if ((r == 0) && writeContext->response) {\n            r = -1;\n        }\n    }\n\n    return r;\n}", "path": "HomeKitADK/HAP/HAPIPAccessoryServer.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * HAP-BLE procedure type.\n */\n", "func_signal": "HAP_ENUM_BEGIN(uint8_t, HAPBLEProcedureType)", "code": "{ /**\n                                                * Full-featured procedure.\n                                                *\n                                                * - Associated type: HAPBLEProcedureRef\n                                                */\n                                               kHAPBLEProcedureType_Full = 1,\n\n                                               /**\n                                                * Fallback procedure.\n                                                *\n                                                * - Associated type: HAPBLEFallbackProcedure\n                                                */\n                                               kHAPBLEProcedureType_Fallback\n}", "path": "HomeKitADK/HAP/HAPBLEPeripheralManager.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/*\n    Assumptions: pre-computed q, q->Z=1\n    Cost: 7M + 7add\n    Return: P = P + Q\n*/\n", "func_signal": "void edp_AddAffinePoint(Ext_POINT* p, const PA_POINT* q)", "code": "{\n    U_WORD a[K_WORDS], b[K_WORDS], c[K_WORDS], d[K_WORDS], e[K_WORDS];\n    ecp_SubReduce(a, p->y, p->x); /* A = (Y1-X1)*(Y2-X2) */\n    ecp_MulReduce(a, a, q->YmX);\n    ecp_AddReduce(b, p->y, p->x); /* B = (Y1+X1)*(Y2+X2) */\n    ecp_MulReduce(b, b, q->YpX);\n    ecp_MulReduce(c, p->t, q->T2d); /* C = T1*2d*T2 */\n    ecp_AddReduce(d, p->z, p->z);   /* D = Z1*2*Z2 (Z2=1)*/\n    ecp_SubReduce(e, b, a);         /* E = B-A */\n    ecp_AddReduce(b, b, a);         /* H = B+A */\n    ecp_SubReduce(a, d, c);         /* F = D-C */\n    ecp_AddReduce(d, d, c);         /* G = D+C */\n\n    ecp_MulReduce(p->x, e, a); /* E*F */\n    ecp_MulReduce(p->y, b, d); /* H*G */\n    ecp_MulReduce(p->t, e, b); /* E*H */\n    ecp_MulReduce(p->z, d, a); /* G*F */\n}", "path": "HomeKitADK/PAL/Crypto/MbedTLS/Ed25519/ed25519_sign.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Aborts all fallback HAP-BLE procedures.\n *\n * @param      server_              Accessory server.\n */\n", "func_signal": "static void AbortAllFallbackProcedures(HAPAccessoryServerRef* server_)", "code": "{\n    HAPPrecondition(server_);\n    HAPAccessoryServer* server = (HAPAccessoryServer*) server_;\n\n    HAPLogDebug(&logObject, \"%s\", __func__);\n\n    for (size_t i = 0; i < server->ble.storage->numGATTTableElements; i++) {\n        HAPBLEGATTTableElement* gattAttribute = (HAPBLEGATTTableElement*) &server->ble.storage->gattTableElements[i];\n\n        if (!gattAttribute->accessory) {\n            break;\n        }\n\n        if (gattAttribute->connectionState.fallbackProcedure.timer) {\n            const HAPAccessory* accessory = gattAttribute->accessory;\n            HAPAssert(gattAttribute->service);\n            HAPAssert(gattAttribute->characteristic);\n            const HAPBaseCharacteristic* characteristic = gattAttribute->characteristic;\n\n            HAPLogCharacteristicInfo(&logObject, characteristic, service, accessory, \"Aborting fallback procedure.\");\n\n#if !DEBUG_DISABLE_TIMEOUTS\n            HAPPlatformTimerDeregister(gattAttribute->connectionState.fallbackProcedure.timer);\n#endif\n\n            HAPRawBufferZero(\n                    &gattAttribute->connectionState.fallbackProcedure,\n                    sizeof gattAttribute->connectionState.fallbackProcedure);\n        }\n    }\n}", "path": "HomeKitADK/HAP/HAPBLEPeripheralManager.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Resets the state of HAP Events.\n *\n * @param      server_              Accessory server.\n */\n", "func_signal": "static void ResetEventState(HAPAccessoryServerRef* server_)", "code": "{\n    HAPPrecondition(server_);\n    HAPAccessoryServer* server = (HAPAccessoryServer*) server_;\n\n    HAPLogDebug(&logObject, \"%s\", __func__);\n\n    for (size_t i = 0; i < server->ble.storage->numGATTTableElements; i++) {\n        HAPBLEGATTTableElement* gattAttribute = (HAPBLEGATTTableElement*) &server->ble.storage->gattTableElements[i];\n\n        if (!gattAttribute->accessory) {\n            break;\n        }\n\n        gattAttribute->connectionState.centralSubscribed = false;\n        gattAttribute->connectionState.pendingEvent = false;\n    }\n}", "path": "HomeKitADK/HAP/HAPBLEPeripheralManager.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/*\n    Reference: http://eprint.iacr.org/2008/522\n    Cost: 7M + 7add\n    Return: R = P + BasePoint\n*/\n", "func_signal": "void edp_AddBasePoint(Ext_POINT* p)", "code": "{\n    U_WORD a[K_WORDS], b[K_WORDS], c[K_WORDS], d[K_WORDS], e[K_WORDS];\n\n    ecp_SubReduce(a, p->y, p->x); /* A = (Y1-X1)*(Y2-X2) */\n    ecp_MulReduce(a, a, _w_base_folding8[1].YmX);\n    ecp_AddReduce(b, p->y, p->x); /* B = (Y1+X1)*(Y2+X2) */\n    ecp_MulReduce(b, b, _w_base_folding8[1].YpX);\n    ecp_MulReduce(c, p->t, _w_base_folding8[1].T2d); /* C = T1*2d*T2 */\n    ecp_AddReduce(d, p->z, p->z);                    /* D = 2*Z1 */\n    ecp_SubReduce(e, b, a);                          /* E = B-A */\n    ecp_AddReduce(b, b, a);                          /* H = B+A */\n    ecp_SubReduce(a, d, c);                          /* F = D-C */\n    ecp_AddReduce(d, d, c);                          /* G = D+C */\n\n    ecp_MulReduce(p->x, e, a); /* E*F */\n    ecp_MulReduce(p->y, b, d); /* H*G */\n    ecp_MulReduce(p->t, e, b); /* E*H */\n    ecp_MulReduce(p->z, d, a); /* G*F */\n}", "path": "HomeKitADK/PAL/Crypto/MbedTLS/Ed25519/ed25519_sign.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/*\n    Reference: http://eprint.iacr.org/2008/522\n    Cost: 4M + 4S + 7add\n    Return: P = 2*P\n*/\n", "func_signal": "void edp_DoublePoint(Ext_POINT* p)", "code": "{\n    U_WORD a[K_WORDS], b[K_WORDS], c[K_WORDS], d[K_WORDS], e[K_WORDS];\n\n    ecp_SqrReduce(a, p->x); /* A = X1^2 */\n    ecp_SqrReduce(b, p->y); /* B = Y1^2 */\n    ecp_SqrReduce(c, p->z); /* C = 2*Z1^2 */\n    ecp_AddReduce(c, c, c);\n    ecp_SubReduce(d, _w_maxP, a); /* D = -A */\n\n    ecp_SubReduce(a, d, b);       /* H = D-B */\n    ecp_AddReduce(d, d, b);       /* G = D+B */\n    ecp_SubReduce(b, d, c);       /* F = G-C */\n    ecp_AddReduce(e, p->x, p->y); /* E = (X1+Y1)^2-A-B = (X1+Y1)^2+H */\n    ecp_SqrReduce(e, e);\n    ecp_AddReduce(e, e, a);\n\n    ecp_MulReduce(p->x, e, b); /* E*F */\n    ecp_MulReduce(p->y, a, d); /* H*G */\n    ecp_MulReduce(p->z, d, b); /* G*F */\n    ecp_MulReduce(p->t, e, a); /* E*H */\n}", "path": "HomeKitADK/PAL/Crypto/MbedTLS/Ed25519/ed25519_sign.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Either simply passes State handling to app, or processes Factory Reset\n */\n", "func_signal": "void HandleUpdatedState(HAPAccessoryServerRef* _Nonnull server, void* _Nullable context)", "code": "{\n    if (HAPAccessoryServerGetState(server) == kHAPAccessoryServerState_Idle && requestedFactoryReset) {\n        HAPPrecondition(server);\n\n        HAPError err;\n\n        HAPLogInfo(&kHAPLog_Default, \"A factory reset has been requested.\");\n\n        // Purge app state.\n        err = HAPPlatformKeyValueStorePurgeDomain(&platform.keyValueStore, ((HAPPlatformKeyValueStoreDomain) 0x00));\n        if (err) {\n            HAPAssert(err == kHAPError_Unknown);\n            HAPFatalError();\n        }\n\n        // Reset HomeKit state.\n        err = HAPRestoreFactorySettings(&platform.keyValueStore);\n        if (err) {\n            HAPAssert(err == kHAPError_Unknown);\n            HAPFatalError();\n        }\n\n        // Restore platform specific factory settings.\n        RestorePlatformFactorySettings();\n\n        // De-initialize App.\n        AppRelease();\n\n        requestedFactoryReset = false;\n\n        // Re-initialize App.\n        AppCreate(server, &platform.keyValueStore);\n\n        // Restart accessory server.\n        AppAccessoryServerStart();\n        return;\n    } else if (HAPAccessoryServerGetState(server) == kHAPAccessoryServerState_Idle && clearPairings) {\n        HAPError err;\n        err = HAPRemoveAllPairings(&platform.keyValueStore);\n        if (err) {\n            HAPAssert(err == kHAPError_Unknown);\n            HAPFatalError();\n        }\n        AppAccessoryServerStart();\n    } else {\n        AccessoryServerHandleUpdatedState(server, context);\n    }\n}", "path": "HomeKitADK/Applications/Main.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Converts a characteristic read request error to the corresponding HAP status code.\n *\n * @param      error                Read request error.\n *\n * @return HAP read request status code.\n *\n * @see HomeKit Accessory Protocol Specification R14\n *      Table 6-11 HAP Status Codes\n */\n", "func_signal": "static int32_t ConvertCharacteristicReadErrorToStatusCode(HAPError error)", "code": "{\n    switch (error) {\n        case kHAPError_None: {\n            return kHAPIPAccessoryServerStatusCode_Success;\n        }\n        case kHAPError_Unknown: {\n            return kHAPIPAccessoryServerStatusCode_UnableToPerformOperation;\n        }\n        case kHAPError_InvalidState: {\n            return kHAPIPAccessoryServerStatusCode_UnableToPerformOperation;\n        }\n        case kHAPError_InvalidData: {\n            HAPFatalError();\n        }\n        case kHAPError_OutOfResources: {\n            return kHAPIPAccessoryServerStatusCode_OutOfResources;\n        }\n        case kHAPError_NotAuthorized: {\n            return kHAPIPAccessoryServerStatusCode_InsufficientAuthorization;\n        }\n        case kHAPError_Busy: {\n            return kHAPIPAccessoryServerStatusCode_ResourceIsBusy;\n        }\n    }\n    HAPFatalError();\n}", "path": "HomeKitADK/HAP/HAPIPAccessoryServer.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Prepares starting the accessory server.\n *\n * @param      server_              Accessory server.\n * @param      primaryAccessory     Primary accessory to host.\n * @param      bridgedAccessories   NULL-terminated array of bridged accessories for a bridge accessory. NULL otherwise.\n */\n", "func_signal": "static void HAPAccessoryServerPrepareStart(\n        HAPAccessoryServerRef* server_,\n        const HAPAccessory* primaryAccessory,\n        const HAPAccessory* _Nullable const* _Nullable bridgedAccessories)", "code": "{\n    HAPPrecondition(server_);\n    HAPAccessoryServer* server = (HAPAccessoryServer*) server_;\n    HAPPrecondition(server->state == kHAPAccessoryServerState_Idle);\n    HAPPrecondition(!server->primaryAccessory);\n    HAPPrecondition(!server->ip.bridgedAccessories);\n    HAPPrecondition(primaryAccessory);\n\n    HAPError err;\n\n    HAPLogInfo(&logObject, \"Accessory server starting.\");\n    server->state = kHAPAccessoryServerState_Running;\n    HAPAccessoryServerDelegateScheduleHandleUpdatedState(server_);\n\n    // Reset state.\n    if (server->transports.ip) {\n        HAPNonnull(server->transports.ip)->prepareStart(server_);\n    }\n    if (server->transports.ble) {\n        HAPNonnull(server->transports.ble)->prepareStart(server_);\n    }\n\n    // Firmware version check.\n    {\n        // Read firmware version.\n        HAPAssert(primaryAccessory->firmwareVersion);\n        uint32_t major;\n        uint32_t minor;\n        uint32_t revision;\n        err = ParseVersionString(primaryAccessory->firmwareVersion, &major, &minor, &revision);\n        if (err) {\n            HAPAssert(err == kHAPError_InvalidData);\n            HAPFatalError();\n        }\n        HAPLogInfo(\n                &logObject,\n                \"Firmware version: %lu.%lu.%lu\",\n                (unsigned long) major,\n                (unsigned long) minor,\n                (unsigned long) revision);\n\n        // Check for configuration change.\n        HAPPrecondition(server->platform.keyValueStore);\n        uint8_t bytes[3 * 4];\n        bool found;\n        size_t numBytes;\n        err = HAPPlatformKeyValueStoreGet(\n                server->platform.keyValueStore,\n                kHAPKeyValueStoreDomain_Configuration,\n                kHAPKeyValueStoreKey_Configuration_FirmwareVersion,\n                bytes,\n                sizeof bytes,\n                &numBytes,\n                &found);\n        if (err) {\n            HAPAssert(err == kHAPError_Unknown);\n            HAPFatalError();\n        }\n        bool saveVersion = false;\n        if (found) {\n            if (numBytes != sizeof bytes) {\n                HAPLogError(\n                        &logObject,\n                        \"Key-value store corrupted - unexpected length for firmware revision: %lu.\",\n                        (unsigned long) numBytes);\n                HAPFatalError();\n            }\n            uint32_t previousMajor = HAPReadLittleUInt32(&bytes[0]);\n            uint32_t previousMinor = HAPReadLittleUInt32(&bytes[4]);\n            uint32_t previousRevision = HAPReadLittleUInt32(&bytes[8]);\n            if (major != previousMajor || minor != previousMinor || revision != previousRevision) {\n                if (major < previousMajor || (major == previousMajor && minor < previousMinor) ||\n                    (major == previousMajor && minor == previousMinor && revision < previousRevision)) {\n                    HAPLogError(\n                            &logObject,\n                            \"[%lu.%lu.%lu > %lu.%lu.%lu] Firmware must not be downgraded! Not starting \"\n                            \"HAPAccessoryServer.\",\n                            (unsigned long) previousMajor,\n                            (unsigned long) previousMinor,\n                            (unsigned long) previousRevision,\n                            (unsigned long) major,\n                            (unsigned long) minor,\n                            (unsigned long) revision);\n                    server->state = kHAPAccessoryServerState_Idle;\n                    return;\n                }\n\n                HAPLogInfo(\n                        &logObject,\n                        \"[%lu.%lu.%lu > %lu.%lu.%lu] Performing post firmware update tasks.\",\n                        (unsigned long) previousMajor,\n                        (unsigned long) previousMinor,\n                        (unsigned long) previousRevision,\n                        (unsigned long) major,\n                        (unsigned long) minor,\n                        (unsigned long) revision);\n                err = HAPHandleFirmwareUpdate(server_);\n                if (err) {\n                    HAPAssert(err == kHAPError_Unknown);\n                    HAPFatalError();\n                }\n                saveVersion = true;\n            }\n        } else {\n            HAPLogInfo(\n                    &logObject,\n                    \"[%lu.%lu.%lu] Storing initial firmware version.\",\n                    (unsigned long) major,\n                    (unsigned long) minor,\n                    (unsigned long) revision);\n            saveVersion = true;\n        }\n        if (saveVersion) {\n            HAPWriteLittleUInt32(&bytes[0], major);\n            HAPWriteLittleUInt32(&bytes[4], minor);\n            HAPWriteLittleUInt32(&bytes[8], revision);\n            err = HAPPlatformKeyValueStoreSet(\n                    server->platform.keyValueStore,\n                    kHAPKeyValueStoreDomain_Configuration,\n                    kHAPKeyValueStoreKey_Configuration_FirmwareVersion,\n                    bytes,\n                    sizeof bytes);\n            if (err) {\n                HAPAssert(err == kHAPError_Unknown);\n                HAPFatalError();\n            }\n        }\n    }\n\n    // Register accessory.\n    HAPLogDebug(&logObject, \"Registering accessories.\");\n    server->primaryAccessory = primaryAccessory;\n    server->ip.bridgedAccessories = bridgedAccessories;\n\n    // Load LTSK.\n    HAPLogDebug(&logObject, \"Loading accessory identity.\");\n    HAPAccessoryServerLoadLTSK(server->platform.keyValueStore, &server->identity.ed_LTSK);\n    HAP_ed25519_public_key(server->identity.ed_LTPK, server->identity.ed_LTSK.bytes);\n\n    // Cleanup pairings.\n    err = HAPAccessoryServerCleanupPairings(server_);\n    if (err) {\n        HAPAssert(err == kHAPError_Unknown);\n        HAPLogError(&logObject, \"Cleanup pairings failed.\");\n        HAPFatalError();\n    }\n\n    if (server->transports.ble) {\n        HAPNonnull(server->transports.ble)->start(server_);\n    }\n\n    // Update setup payload.\n    HAPAccessorySetupInfoHandleAccessoryServerStart(server_);\n\n    // Update advertising state.\n    HAPAccessoryServerUpdateAdvertisingData(server_);\n}", "path": "HomeKitADK/HAP/HAPAccessoryServer.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Parses a version string where each element is capped at 2^32-1.\n *\n * @param      version              Version string.\n * @param[out] major                Major version number.\n * @param[out] minor                Minor version number.\n * @param[out] revision             Revision version number.\n *\n * @return kHAPError_None           If successful.\n * @return kHAPError_InvalidData    If the version string is malformed.\n */\n", "func_signal": "HAP_RESULT_USE_CHECK\nstatic HAPError ParseVersionString(const char* version, uint32_t* major, uint32_t* minor, uint32_t* revision)", "code": "{\n    HAPPrecondition(version);\n    HAPPrecondition(major);\n    HAPPrecondition(minor);\n    HAPPrecondition(revision);\n\n    *major = 0;\n    *minor = 0;\n    *revision = 0;\n\n    // Read numbers.\n    uint32_t* numbers[3] = { major, minor, revision };\n    size_t i = 0;\n    bool first = true;\n    for (const char* c = version; *c; c++) {\n        if (!first && *c == '.') {\n            // Advance to next number.\n            if (i >= 2) {\n                HAPLog(&logObject, \"Invalid version string: %s.\", version);\n                return kHAPError_InvalidData;\n            }\n            i++;\n            first = true;\n            continue;\n        }\n        first = false;\n\n        // Add digit.\n        if (*c < '0' || *c > '9') {\n            HAPLog(&logObject, \"Invalid version string: %s.\", version);\n            return kHAPError_InvalidData;\n        }\n        if (*numbers[i] > UINT32_MAX / 10) {\n            HAPLog(&logObject, \"Invalid version string: %s.\", version);\n            return kHAPError_InvalidData;\n        }\n        (*numbers[i]) *= 10;\n        if (*numbers[i] > UINT32_MAX - (uint32_t)(*c - '0')) {\n            HAPLog(&logObject, \"Invalid version string: %s.\", version);\n            return kHAPError_InvalidData;\n        }\n        (*numbers[i]) += (uint32_t)(*c - '0');\n    }\n    if (first) {\n        HAPLog(&logObject, \"Invalid version string: %s.\", version);\n        return kHAPError_InvalidData;\n    }\n\n    return kHAPError_None;\n}", "path": "HomeKitADK/HAP/HAPAccessoryServer.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Deinitialize global platform objects.\n */\n", "func_signal": "static void DeinitializePlatform()", "code": "{\n#if HAVE_MFI_HW_AUTH\n    // Apple Authentication Coprocessor provider.\n    HAPPlatformMFiHWAuthRelease(&platform.mfiHWAuth);\n#endif\n\n#if IP\n    // TCP stream manager.\n    HAPPlatformTCPStreamManagerRelease(&platform.tcpStreamManager);\n#endif\n\n    AppDeinitialize();\n\n    // Run loop.\n    HAPPlatformRunLoopRelease();\n}", "path": "HomeKitADK/Applications/Main.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Reports the start of a pairing procedure.\n *\n * @param      server_              Accessory server.\n * @param      session_             Session.\n * @param      pairingProcedureType Pairing procedure type.\n */\n", "func_signal": "static void HAPSessionStartPairingProcedure(\n        HAPAccessoryServerRef* server_,\n        HAPSessionRef* session_,\n        HAPPairingProcedureType pairingProcedureType)", "code": "{\n    HAPPrecondition(server_);\n    HAPAccessoryServer* server = (HAPAccessoryServer*) server_;\n    HAPPrecondition(session_);\n    HAPSession* session = (HAPSession*) session_;\n\n    switch (session->transportType) {\n        case kHAPTransportType_IP: {\n            HAPAssert(server->transports.ip);\n            return;\n        }\n        case kHAPTransportType_BLE: {\n            HAPAssert(server->transports.ble);\n            HAPNonnull(server->transports.ble)\n                    ->session.didStartPairingProcedure(server_, session_, pairingProcedureType);\n            return;\n        }\n    }\n    HAPFatalError();\n}", "path": "HomeKitADK/HAP/HAPSession.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Status flags.\n *\n * @see HomeKit Accessory Protocol Specification R14\n *      Table 6-8 Bonjour TXT Status Flags\n *\n * @see HomeKit Accessory Protocol Specification R14\n *      Section 7.4.2.1.2 Manufacturer Data\n */\n", "func_signal": "HAP_ENUM_BEGIN(uint8_t, HAPAccessoryServerStatusFlags)", "code": "{\n    /** Accessory has not been paired with any controllers. */\n    kHAPAccessoryServerStatusFlags_NotPaired = 1 << 0,\n\n    /**\n     * A problem has been detected on the accessory.\n     *\n     * - Used by accessories supporting HAP over IP (Ethernet / Wi-Fi) only.\n     */\n    kHAPAccessoryServerStatusFlags_ProblemDetected = 1 << 2\n}", "path": "HomeKitADK/HAP/HAPAccessoryServer.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Run loop state.\n */\n", "func_signal": "HAP_ENUM_BEGIN(uint8_t, HAPPlatformRunLoopState)", "code": "{ /**\n                                                    * Idle.\n                                                    */\n                                                   kHAPPlatformRunLoopState_Idle,\n\n                                                   /**\n                                                    * Running.\n                                                    */\n                                                   kHAPPlatformRunLoopState_Running,\n\n                                                   /**\n                                                    * Stopping.\n                                                    */\n                                                   kHAPPlatformRunLoopState_Stopping\n}", "path": "HomeKitADK/PAL/POSIX/HAPPlatformRunLoop.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Gets the HAP-BLE procedure for a GATT attribute.\n *\n * @param      server_              Accessory server.\n * @param      session_             The session over which the request has been received.\n * @param      gattAttribute        The GATT attribute that is accessed.\n * @param[out] procedureType        Type of the attached procedure.\n * @param[out] procedure            HAP-BLE procedure.\n *\n * @return kHAPError_None           If successful.\n * @return kHAPError_InvalidState   If no procedure can be fetched at this time.\n */\n", "func_signal": "HAP_PWT_HAPBLEProcedureType(5, 4) HAP_RESULT_USE_CHECK static HAPError GetProcedure(\n        HAPAccessoryServerRef* server_,\n        HAPSessionRef* session_,\n        HAPBLEGATTTableElement* gattAttribute,\n        HAPBLEProcedureType* procedureType,\n        void* _Nonnull* _Nonnull procedure)", "code": "{\n    HAPPrecondition(server_);\n    HAPAccessoryServer* server = (HAPAccessoryServer*) server_;\n    HAPPrecondition(server->platform.ble.blePeripheralManager);\n    HAPPlatformBLEPeripheralManagerRef blePeripheralManager = server->platform.ble.blePeripheralManager;\n    HAPPrecondition(session_);\n    HAPSession* session = (HAPSession*) session_;\n    HAPPrecondition(gattAttribute);\n    HAPPrecondition(gattAttribute->characteristic);\n    const HAPBaseCharacteristic* characteristic = gattAttribute->characteristic;\n    HAPPrecondition(gattAttribute->service);\n    HAPPrecondition(gattAttribute->accessory);\n    const HAPAccessory* accessory = gattAttribute->accessory;\n    HAPPrecondition(procedureType);\n    HAPPrecondition(procedure);\n\n    // For now, we only support 1 concurrent full-featured procedure.\n    HAPPrecondition(server->ble.storage->procedures);\n    HAPPrecondition(server->ble.storage->procedures);\n    HAPPrecondition(server->ble.storage->numProcedures >= 1);\n    HAPBLEProcedureRef* fullProcedure = &server->ble.storage->procedures[0];\n\n    // Every characteristic supports a fallback procedure.\n    HAPBLEFallbackProcedure* fallbackProcedure = &gattAttribute->connectionState.fallbackProcedure;\n\n    // If session is terminal, no more requests may be accepted.\n    if (HAPBLESessionIsTerminal(&session->_.ble)) {\n        HAPLogCharacteristic(&logObject, characteristic, service, accessory, \"Rejecting request: Session is terminal.\");\n        HAPPlatformBLEPeripheralManagerCancelCentralConnection(\n                blePeripheralManager, server->ble.connection.connectionHandle);\n        return kHAPError_InvalidState;\n    }\n\n    // An accessory must cancel any pending procedures when a new HAP secure session starts getting established.\n    // See HomeKit Accessory Protocol Specification R14\n    // Section 7.3.1 HAP Transactions and Procedures\n    if (HAPBLECharacteristicDropsSecuritySession(characteristic)) {\n        HAPLogCharacteristicDebug(\n                &logObject,\n                characteristic,\n                service,\n                accessory,\n                \"Aborting fallback procedure (%s).\",\n                \"Characteristic drops security session\");\n        AbortAllFallbackProcedures(server_);\n    }\n\n    // Check if already attached to the same characteristic (fallback procedure).\n    if (gattAttribute->connectionState.fallbackProcedure.timer) {\n        *procedureType = kHAPBLEProcedureType_Fallback;\n        *procedure = fallbackProcedure;\n        return kHAPError_None;\n    }\n\n    // Check if already attached to the same characteristic (full procedure).\n    if (server->ble.connection.procedureAttached) {\n        const HAPBaseCharacteristic* attachedCharacteristic = HAPBLEProcedureGetAttachedCharacteristic(fullProcedure);\n        HAPAssert(attachedCharacteristic);\n\n        if (attachedCharacteristic == characteristic) {\n            *procedureType = kHAPBLEProcedureType_Full;\n            *procedure = fullProcedure;\n            return kHAPError_None;\n        }\n    }\n\n    // Unsolicited read request.\n    // 12. Accessory must reject GATT Read Requests on a HAP characteristic if it was not preceded by an\n    // GATT Write Request with the same transaction ID at most 10 seconds prior.\n    // See HomeKit Accessory Protocol Specification R14\n    // Section 7.5 Testing Bluetooth LE Accessories\n    return kHAPError_InvalidState;\n}", "path": "HomeKitADK/HAP/HAPBLEPeripheralManager.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Converts a characteristic write request error to the corresponding HAP status code.\n *\n * @param      error                Write request error.\n *\n * @return HAP write request status code.\n *\n * @see HomeKit Accessory Protocol Specification R14\n *      Table 6-11 HAP Status Codes\n */\n", "func_signal": "static int32_t ConvertCharacteristicWriteErrorToStatusCode(HAPError error)", "code": "{\n    switch (error) {\n        case kHAPError_None: {\n            return kHAPIPAccessoryServerStatusCode_Success;\n        }\n        case kHAPError_Unknown: {\n            return kHAPIPAccessoryServerStatusCode_UnableToPerformOperation;\n        }\n        case kHAPError_InvalidState: {\n            return kHAPIPAccessoryServerStatusCode_UnableToPerformOperation;\n        }\n        case kHAPError_InvalidData: {\n            return kHAPIPAccessoryServerStatusCode_InvalidValueInWrite;\n        }\n        case kHAPError_OutOfResources: {\n            return kHAPIPAccessoryServerStatusCode_OutOfResources;\n        }\n        case kHAPError_NotAuthorized: {\n            return kHAPIPAccessoryServerStatusCode_InsufficientAuthorization;\n        }\n        case kHAPError_Busy: {\n            return kHAPIPAccessoryServerStatusCode_ResourceIsBusy;\n        }\n    }\n    HAPFatalError();\n}", "path": "HomeKitADK/HAP/HAPIPAccessoryServer.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "/**\n * Continues sending of pending HAP event notifications.\n *\n * @param      server_              Accessory server.\n */\n", "func_signal": "static void SendPendingEventNotifications(HAPAccessoryServerRef* server_)", "code": "{\n    HAPPrecondition(server_);\n    HAPAccessoryServer* server = (HAPAccessoryServer*) server_;\n    HAPPrecondition(server->platform.ble.blePeripheralManager);\n    HAPPlatformBLEPeripheralManagerRef blePeripheralManager = server->platform.ble.blePeripheralManager;\n    HAPPrecondition(server->ble.connection.connected);\n    HAPPrecondition(server->ble.storage->session);\n    HAPSessionRef* session = server->ble.storage->session;\n\n    HAPError err;\n\n    for (size_t i = 0; i < server->ble.storage->numGATTTableElements; i++) {\n        HAPBLEGATTTableElement* gattAttribute = (HAPBLEGATTTableElement*) &server->ble.storage->gattTableElements[i];\n        const HAPBaseCharacteristic* characteristic = gattAttribute->characteristic;\n        const HAPService* service = gattAttribute->service;\n        const HAPAccessory* accessory = gattAttribute->accessory;\n        if (!accessory) {\n            break;\n        }\n        HAPAssert(service);\n        if (!characteristic) {\n            continue;\n        }\n        if (!characteristic->properties.supportsEventNotification) {\n            HAPAssert(!gattAttribute->connectionState.centralSubscribed);\n            HAPAssert(!gattAttribute->connectionState.pendingEvent);\n            continue;\n        }\n        if (characteristic->iid > UINT16_MAX) {\n            HAPLogCharacteristicError(\n                    &logObject,\n                    characteristic,\n                    service,\n                    accessory,\n                    \"Not sending Handle Value Indication because characteristic instance ID is not supported.\");\n            continue;\n        }\n        HAPAssert(gattAttribute->valueHandle);\n        HAPAssert(gattAttribute->cccDescriptorHandle);\n        HAPAssert(gattAttribute->iidHandle);\n\n        if (!gattAttribute->connectionState.centralSubscribed) {\n            continue;\n        }\n        if (!gattAttribute->connectionState.pendingEvent) {\n            continue;\n        }\n        if (!HAPSessionIsSecured(session)) {\n            HAPLogCharacteristicInfo(\n                    &logObject,\n                    characteristic,\n                    service,\n                    accessory,\n                    \"Not sending Handle Value Indication because the session is not secured.\");\n            return;\n        }\n        if (HAPSessionIsTransient(session)) {\n            HAPLogCharacteristicInfo(\n                    &logObject,\n                    characteristic,\n                    service,\n                    accessory,\n                    \"Not sending Handle Value Indication because the session is transient.\");\n            return;\n        }\n        if (HAPCharacteristicReadRequiresAdminPermissions(characteristic) && !HAPSessionControllerIsAdmin(session)) {\n            HAPLogCharacteristicInfo(\n                    &logObject,\n                    characteristic,\n                    service,\n                    accessory,\n                    \"Not sending Handle Value Indication because event notification values will only be delivered to \"\n                    \"controllers with admin permissions.\");\n            continue;\n        }\n\n        err = HAPPlatformBLEPeripheralManagerSendHandleValueIndication(\n                blePeripheralManager,\n                server->ble.connection.connectionHandle,\n                gattAttribute->valueHandle,\n                /* bytes: */ NULL,\n                /* numBytes: */ 0);\n        if (err == kHAPError_InvalidState) {\n            HAPLogCharacteristicInfo(\n                    &logObject,\n                    characteristic,\n                    service,\n                    accessory,\n                    \"Delayed event sending until ready to update subscribers.\");\n            return;\n        } else if (err) {\n            HAPAssert(err == kHAPError_OutOfResources);\n            HAPFatalError();\n        }\n        gattAttribute->connectionState.pendingEvent = false;\n        HAPLogCharacteristicInfo(&logObject, characteristic, service, accessory, \"Sent event.\");\n\n        err = HAPBLEAccessoryServerDidSendEventNotification(server_, characteristic, service, accessory);\n        if (err) {\n            HAPAssert(err == kHAPError_Unknown);\n            HAPFatalError();\n        }\n    }\n}", "path": "HomeKitADK/HAP/HAPBLEPeripheralManager.c", "commit_date": "2019-12-18 00:00:00", "repo_name": "apple/HomeKitADK", "stars": 2521, "license": "apache-2.0", "language": "c", "size": 655}
{"docstring": "//static void aubio_timestretch_warmup (aubio_timestretch_t * p);\n", "func_signal": "aubio_timestretch_t *\nnew_aubio_timestretch (const char_t * mode, smpl_t stretchratio, uint_t hopsize,\n    uint_t samplerate)", "code": "{\n  aubio_timestretch_t *p = AUBIO_NEW (aubio_timestretch_t);\n  p->hopsize = hopsize;\n  p->pitchscale = 1.;\n\n  if ((sint_t)hopsize <= 0) {\n    AUBIO_ERR(\"timestretch: hopsize should be > 0, got %d\\n\", hopsize);\n    goto beach;\n  }\n\n  if ((sint_t)samplerate <= 0) {\n    AUBIO_ERR(\"timestretch: samplerate should be > 0, got %d\\n\", samplerate);\n    goto beach;\n  }\n\n  if (stretchratio <= MAX_STRETCH_RATIO && stretchratio >= MIN_STRETCH_RATIO) {\n    p->stretchratio = stretchratio;\n  } else {\n    AUBIO_ERR(\"timestretch: stretchratio should be in the range [%.3f, %.3f], got %f\\n\",\n        MIN_STRETCH_RATIO, MAX_STRETCH_RATIO, stretchratio);\n    goto beach;\n  }\n\n  p->rboptions = aubio_get_rubberband_opts(mode);\n  if (p->rboptions < 0) {\n    AUBIO_ERR(\"timestretch: unknown time stretching method %s\\n\", mode);\n    goto beach;\n  }\n\n  p->rb = rubberband_new(samplerate, 1, p->rboptions, p->stretchratio, p->pitchscale);\n  if (!p->rb) goto beach;\n\n  p->samplerate = samplerate;\n\n  //aubio_timestretch_warmup(p);\n\n  return p;\n\nbeach:\n  del_aubio_timestretch(p);\n  return NULL;\n}", "path": "aubio/src/effects/timestretch_rubberband.c", "commit_date": "2018-12-07 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* execute tempo detection function on iput buffer */\n", "func_signal": "void aubio_tempo_do(aubio_tempo_t *o, const fvec_t * input, fvec_t * tempo)", "code": "{\n  uint_t i;\n  uint_t winlen = o->winlen;\n  uint_t step   = o->step;\n  fvec_t * thresholded;\n  aubio_pvoc_do (o->pv, input, o->fftgrain);\n  aubio_specdesc_do (o->od, o->fftgrain, o->of);\n  /*if (usedoubled) {\n    aubio_specdesc_do(o2,fftgrain, onset2);\n    onset->data[0] *= onset2->data[0];\n  }*/\n  /* execute every overlap_size*step */\n  if (o->blockpos == (signed)step -1 ) {\n    /* check dfframe */\n    aubio_beattracking_do(o->bt,o->dfframe,o->out);\n    /* rotate dfframe */\n    for (i = 0 ; i < winlen - step; i++ )\n      o->dfframe->data[i] = o->dfframe->data[i+step];\n    for (i = winlen - step ; i < winlen; i++ )\n      o->dfframe->data[i] = 0.;\n    o->blockpos = -1;\n  }\n  o->blockpos++;\n  aubio_peakpicker_do (o->pp, o->of, o->onset);\n  // store onset detection function in second sample of vector\n  //tempo->data[1] = o->onset->data[0];\n  thresholded = aubio_peakpicker_get_thresholded_input(o->pp);\n  o->dfframe->data[winlen - step + o->blockpos] = thresholded->data[0];\n  /* end of second level loop */\n  tempo->data[0] = 0; /* reset tactus */\n  //i=0;\n  for (i = 1; i < o->out->data[0]; i++ ) {\n    /* if current frame is a predicted tactus */\n    if (o->blockpos == FLOOR(o->out->data[i])) {\n      tempo->data[0] = o->out->data[i] - FLOOR(o->out->data[i]); /* set tactus */\n      /* test for silence */\n      if (aubio_silence_detection(input, o->silence)==1) {\n        tempo->data[0] = 0; // unset beat if silent\n      }\n      o->last_beat = o->total_frames + (uint_t)ROUND(tempo->data[0] * o->hop_size);\n      o->last_tatum = o->last_beat;\n    }\n  }\n  o->total_frames += o->hop_size;\n  return;\n}", "path": "aubio/src/tempo/tempo.c", "commit_date": "2018-11-24 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* function Py_source_do */\n", "func_signal": "static PyObject *\nPy_source_do(Py_source * self, PyObject * args)", "code": "{\n  PyObject *outputs;\n  uint_t read;\n  read = 0;\n\n  Py_INCREF(self->read_to);\n  if (!PyAubio_ArrayToCFvec(self->read_to, &(self->c_read_to))) {\n    return NULL;\n  }\n  /* compute _do function */\n  aubio_source_do (self->o, &(self->c_read_to), &read);\n\n  if (PyErr_Occurred() != NULL) {\n    return NULL;\n  }\n\n  outputs = PyTuple_New(2);\n  PyTuple_SetItem( outputs, 0, self->read_to );\n  PyTuple_SetItem( outputs, 1, (PyObject *)PyLong_FromLong(read));\n  return outputs;\n}", "path": "aubio/python/ext/py-source.c", "commit_date": "2018-12-23 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/** append new note candidate to the note_buffer and return filtered value. we\n * need to copy the input array as fvec_median destroy its input data.*/\n", "func_signal": "static void\nnote_append (fvec_t * note_buffer, smpl_t curnote)", "code": "{\n  uint_t i = 0;\n  for (i = 0; i < note_buffer->length - 1; i++) {\n    note_buffer->data[i] = note_buffer->data[i + 1];\n  }\n  //note_buffer->data[note_buffer->length - 1] = ROUND(10.*curnote)/10.;\n  note_buffer->data[note_buffer->length - 1] = ROUND(AUBIO_DEFAULT_CENT_PRECISION*curnote);\n  return;\n}", "path": "aubio/src/notes/notes.c", "commit_date": "2018-11-28 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* perform function */\n", "func_signal": "OSStatus\naubio_audio_unit_process(void *closure, AudioUnitRenderActionFlags * action_flags,\n    const AudioTimeStamp * time_stamp, UNUSED UInt32 bus_number, UInt32 inNumber_frames,\n    AudioBufferList * input_output)", "code": "{\n  UInt32 b; int err = 0;\n  aubio_audio_unit_t *o = (aubio_audio_unit_t *)closure;\n  AudioUnit thisUnit = o->audio_unit;\n\n  if (o->input_enabled) {\n    err = AudioUnitRender(thisUnit, action_flags, time_stamp, 1,\n        inNumber_frames, input_output);\n    if (err) {\n      AUBIO_ERR(\"audio_unit: error performing AudioUnitRender (%d)\\n\", err);\n      return err;\n    }\n  }\n\n  // get the number of frames from the audio buffer list, NOT inNumber_frames\n  UInt32 number_frames = input_output->mBuffers[0].mDataByteSize/ sizeof(SInt16) / 2;\n\n  // FIXME find out why this happens\n  if (number_frames < 10) {\n    AUBIO_ERR(\"audio_unit: got number_frames %d\\n\", (int)number_frames);\n    return -1;\n  }\n\n  if (o->total_frames >= (signed)number_frames) {\n\n    SInt16 *data;\n    if (o->au_ios_start + number_frames > AU_IOS_MAX_FRAMES) {\n      // start reminder samples writing at reminder\n      int reminder = AU_IOS_MAX_FRAMES - o->au_ios_start;\n      int starter = (o->au_ios_start + number_frames) - AU_IOS_MAX_FRAMES;\n      for (b = 0; b < input_output->mNumberBuffers; b++) {\n        data = (SInt16 *)(input_output->mBuffers[b].mData);\n        /* copy microphone output to input buffer */\n        memcpy (o->au_ios_inbuf + o->au_ios_start * 2, data, reminder * 2 * sizeof(SInt16));\n        memcpy (o->au_ios_inbuf, data + reminder * 2, starter * 2 * sizeof(SInt16));\n        /* silence data before copying from output */\n        //memset (data, 0, input_output->mBuffers[b].mDataByteSize);\n        /* copy output buffer to speakers */\n        memcpy (data, o->au_ios_outbuf + o->au_ios_start * 2, reminder * 2 * sizeof(SInt16));\n        memcpy (data + reminder * 2, o->au_ios_outbuf, starter * 2 * sizeof(SInt16));\n      }\n    } else {\n      for (b = 0; b < input_output->mNumberBuffers; b++) {\n        data = (SInt16 *)(input_output->mBuffers[b].mData);\n        /* copy microphone samples to au_ios_inbuf */\n        memcpy(o->au_ios_inbuf + o->au_ios_start * 2, data, number_frames * 2 * sizeof(SInt16));\n        /* silence data before copying from output */\n        //memset (data, 0, input_output->mBuffers[b].mDataByteSize);\n        /* copy output buffer to speakers */\n        memcpy(data, o->au_ios_outbuf + o->au_ios_start * 2, number_frames * 2 * sizeof(SInt16));\n      }\n    }\n    o->au_ios_start += number_frames;\n    o->au_ios_start %= AU_IOS_MAX_FRAMES;\n    o->total_frames -= number_frames;\n\n#if 1\n  } else {\n    if (o->total_frames > 0) o->dio_error = 1;\n    for (b = 0; b < input_output->mNumberBuffers; b++) {\n      memset (input_output->mBuffers[b].mData, 0,\n          input_output->mBuffers[b].mDataByteSize);\n    }\n    //total_frames = 0;\n#endif\n  }\n\n  // now call callback\n  while ( o->total_frames < (signed)number_frames ) {\n    //AUBIO_DBG (\"audio_unit: total_frames = %d, number_frames = %d, o->au_ios_start = %d, o->au_ios_end = %d\",\n    //    o->total_frames, number_frames, o->au_ios_start, o->au_ios_end);\n    aubio_audio_unit_blocking(o);\n  }\n\n  return err;\n}", "path": "aubio/src/io/audio_unit.c", "commit_date": "2016-12-11 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* memory management */\n", "func_signal": "static aubio_jack_t *\naubio_jack_alloc (uint_t ichan, uint_t ochan,\n    uint_t imidichan, uint_t omidichan)", "code": "{\n  aubio_jack_t *jack_setup = AUBIO_NEW (aubio_jack_t);\n  jack_setup->ichan = ichan;\n  jack_setup->ochan = ochan;\n  jack_setup->imidichan = imidichan;\n  jack_setup->omidichan = omidichan;\n  jack_setup->oports = AUBIO_ARRAY (jack_port_t *, ichan + imidichan);\n  jack_setup->iports = AUBIO_ARRAY (jack_port_t *, ochan + omidichan);\n  jack_setup->ibufs = AUBIO_ARRAY (jack_sample_t *, ichan);\n  jack_setup->obufs = AUBIO_ARRAY (jack_sample_t *, ochan);\n#ifdef AUBIO_JACK_NEEDS_CONVERSION\n  /* allocate arrays for data conversion */\n  jack_setup->sibufs = AUBIO_ARRAY (smpl_t *, ichan);\n  uint_t i;\n  for (i = 0; i < ichan; i++) {\n    jack_setup->sibufs[i] = AUBIO_ARRAY (smpl_t, AUBIO_JACK_MAX_FRAMES);\n  }\n  jack_setup->sobufs = AUBIO_ARRAY (smpl_t *, ochan);\n  for (i = 0; i < ochan; i++) {\n    jack_setup->sobufs[i] = AUBIO_ARRAY (smpl_t, AUBIO_JACK_MAX_FRAMES);\n  }\n#endif\n  return jack_setup;\n}", "path": "aubio/examples/jackio.c", "commit_date": "2016-04-24 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "// create a new matrix and fill it with i * 1. + j * .1, where i is the row,\n// and j the column.\n", "func_signal": "void assert_fmat_all_equal(fmat_t *mat, smpl_t scalar)", "code": "{\n  uint_t i, j;\n  for ( i = 0; i < mat->height; i++ ) {\n    for ( j = 0; j < mat->length; j++ ) {\n      assert(mat->data[i][j] == scalar);\n    }\n  }\n}", "path": "aubio/tests/src/test-fmat.c", "commit_date": "2018-12-21 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* cumulative mean normalized difference function */\n", "func_signal": "void\naubio_pitchyin_getcum (fvec_t * yin)", "code": "{\n  uint_t tau;\n  smpl_t tmp = 0.;\n  yin->data[0] = 1.;\n  //AUBIO_DBG(\"%f\\t\",yin->data[0]);\n  for (tau = 1; tau < yin->length; tau++) {\n    tmp += yin->data[tau];\n    yin->data[tau] *= tau / tmp;\n    //AUBIO_DBG(\"%f\\t\",yin->data[tau]);\n  }\n  //AUBIO_DBG(\"\\n\");\n}", "path": "aubio/src/pitch/pitchyin.c", "commit_date": "2018-11-28 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* all the above in one */\n", "func_signal": "void\naubio_pitchyin_do (aubio_pitchyin_t * o, const fvec_t * input, fvec_t * out)", "code": "{\n  const smpl_t tol = o->tol;\n  fvec_t* yin = o->yin;\n  const smpl_t *input_data = input->data;\n  const uint_t length = yin->length;\n  smpl_t *yin_data = yin->data;\n  uint_t j, tau;\n  sint_t period;\n  smpl_t tmp, tmp2 = 0.;\n\n  yin_data[0] = 1.;\n  for (tau = 1; tau < length; tau++) {\n    yin_data[tau] = 0.;\n    for (j = 0; j < length; j++) {\n      tmp = input_data[j] - input_data[j + tau];\n      yin_data[tau] += SQR (tmp);\n    }\n    tmp2 += yin_data[tau];\n    if (tmp2 != 0) {\n      yin->data[tau] *= tau / tmp2;\n    } else {\n      yin->data[tau] = 1.;\n    }\n    period = tau - 3;\n    if (tau > 4 && (yin_data[period] < tol) &&\n        (yin_data[period] < yin_data[period + 1])) {\n      o->peak_pos = (uint_t)period;\n      out->data[0] = fvec_quadratic_peak_pos (yin, o->peak_pos);\n      return;\n    }\n  }\n  o->peak_pos = (uint_t)fvec_min_elem (yin);\n  out->data[0] = fvec_quadratic_peak_pos (yin, o->peak_pos);\n}", "path": "aubio/src/pitch/pitchyin.c", "commit_date": "2018-11-28 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* outputs the difference function */\n", "func_signal": "void\naubio_pitchyin_diff (fvec_t * input, fvec_t * yin)", "code": "{\n  uint_t j, tau;\n  smpl_t tmp;\n  for (tau = 0; tau < yin->length; tau++) {\n    yin->data[tau] = 0.;\n  }\n  for (tau = 1; tau < yin->length; tau++) {\n    for (j = 0; j < yin->length; j++) {\n      tmp = input->data[j] - input->data[j + tau];\n      yin->data[tau] += SQR (tmp);\n    }\n  }\n}", "path": "aubio/src/pitch/pitchyin.c", "commit_date": "2018-11-28 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* all the above in one */\n", "func_signal": "void\naubio_pitchyinfast_do (aubio_pitchyinfast_t * o, const fvec_t * input, fvec_t * out)", "code": "{\n  const smpl_t tol = o->tol;\n  fvec_t* yin = o->yin;\n  const uint_t length = yin->length;\n  uint_t B = o->tmpdata->length;\n  uint_t W = o->yin->length; // B / 2\n  fvec_t tmp_slice, kernel_ptr;\n  uint_t tau;\n  sint_t period;\n  smpl_t tmp2 = 0.;\n\n  // compute r_t(0) + r_t+tau(0)\n  {\n    fvec_t *squares = o->tmpdata;\n    fvec_weighted_copy(input, input, squares);\n#if 0\n    for (tau = 0; tau < W; tau++) {\n      tmp_slice.data = squares->data + tau;\n      tmp_slice.length = W;\n      o->sqdiff->data[tau] = fvec_sum(&tmp_slice);\n    }\n#else\n    tmp_slice.data = squares->data;\n    tmp_slice.length = W;\n    o->sqdiff->data[0] = fvec_sum(&tmp_slice);\n    for (tau = 1; tau < W; tau++) {\n      o->sqdiff->data[tau] = o->sqdiff->data[tau-1];\n      o->sqdiff->data[tau] -= squares->data[tau-1];\n      o->sqdiff->data[tau] += squares->data[W+tau-1];\n    }\n#endif\n    fvec_add(o->sqdiff, o->sqdiff->data[0]);\n  }\n  // compute r_t(tau) = -2.*ifft(fft(samples)*fft(samples[W-1::-1]))\n  {\n    fvec_t *compmul = o->tmpdata;\n    fvec_t *rt_of_tau = o->samples_fft;\n    aubio_fft_do_complex(o->fft, input, o->samples_fft);\n    // build kernel, take a copy of first half of samples\n    tmp_slice.data = input->data;\n    tmp_slice.length = W;\n    kernel_ptr.data = o->kernel->data + 1;\n    kernel_ptr.length = W;\n    fvec_copy(&tmp_slice, &kernel_ptr);\n    // reverse them\n    fvec_rev(&kernel_ptr);\n    // compute fft(kernel)\n    aubio_fft_do_complex(o->fft, o->kernel, o->kernel_fft);\n    // compute complex product\n    compmul->data[0]  = o->kernel_fft->data[0] * o->samples_fft->data[0];\n    for (tau = 1; tau < W; tau++) {\n      compmul->data[tau]    = o->kernel_fft->data[tau] * o->samples_fft->data[tau];\n      compmul->data[tau]   -= o->kernel_fft->data[B-tau] * o->samples_fft->data[B-tau];\n    }\n    compmul->data[W]    = o->kernel_fft->data[W] * o->samples_fft->data[W];\n    for (tau = 1; tau < W; tau++) {\n      compmul->data[B-tau]  = o->kernel_fft->data[B-tau] * o->samples_fft->data[tau];\n      compmul->data[B-tau] += o->kernel_fft->data[tau] * o->samples_fft->data[B-tau];\n    }\n    // compute inverse fft\n    aubio_fft_rdo_complex(o->fft, compmul, rt_of_tau);\n    // compute square difference r_t(tau) = sqdiff - 2 * r_t_tau[W-1:-1]\n    for (tau = 0; tau < W; tau++) {\n      yin->data[tau] = o->sqdiff->data[tau] - 2. * rt_of_tau->data[tau+W];\n    }\n  }\n\n  // now build yin and look for first minimum\n  fvec_zeros(out);\n  yin->data[0] = 1.;\n  for (tau = 1; tau < length; tau++) {\n    tmp2 += yin->data[tau];\n    if (tmp2 != 0) {\n      yin->data[tau] *= tau / tmp2;\n    } else {\n      yin->data[tau] = 1.;\n    }\n    period = tau - 3;\n    if (tau > 4 && (yin->data[period] < tol) &&\n        (yin->data[period] < yin->data[period + 1])) {\n      o->peak_pos = (uint_t)period;\n      out->data[0] = fvec_quadratic_peak_pos (yin, o->peak_pos);\n      return;\n    }\n  }\n  // use global minimum \n  o->peak_pos = (uint_t)fvec_min_elem (yin);\n  out->data[0] = fvec_quadratic_peak_pos (yin, o->peak_pos);\n}", "path": "aubio/src/pitch/pitchyinfast.c", "commit_date": "2018-11-28 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* route change listeners */\n", "func_signal": "void\naudio_unit_route_change_listener(void *closure, AudioSessionPropertyID inID,\n    UInt32 dataSize, const void *inData)", "code": "{\n\n  UNUSED aubio_audio_unit_t *o = (aubio_audio_unit_t *)closure;\n  UNUSED UInt32 size = dataSize;\n  if (inID == kAudioSessionProperty_AudioRouteChange) {\n\n    // OSStatus err = 0;\n    //AudioUnit audio_unit = o->audio_unit;\n\n    if (o->verbose) {\n      // show route change reason\n      audio_unit_get_route_change_reason((CFDictionaryRef)inData);\n    }\n\n    // check current audio route, changing it to prevent feedback as needed\n    audio_unit_check_audio_route(o);\n\n    if (o->verbose) {\n      // print some info about the current settings\n      aubio_audio_unit_get_info(o);\n    }\n\n  }\n\n}", "path": "aubio/src/io/audio_unit.c", "commit_date": "2016-12-11 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* interruption listeners */\n", "func_signal": "void audio_unit_interruption_listener(void *closure, UInt32 inInterruptionState)", "code": "{\n  OSStatus err = 0;\n  aubio_audio_unit_t *o = (aubio_audio_unit_t *) closure;\n  AudioUnit this_unit = o->audio_unit;\n\n  if (inInterruptionState == kAudioSessionEndInterruption) {\n    AUBIO_WRN(\"audio_unit: session interruption ended\\n\");\n    err = AudioSessionSetActive(true);\n    if (err) {\n      AUBIO_ERR(\"audio_unit: could not make session active after interruption (%d)\\n\", (int)err);\n      goto fail;\n    }\n    err = AudioOutputUnitStart(this_unit);\n    if (err) {\n      AUBIO_ERR(\"audio_unit: failed starting unit (%d)\\n\", (int)err);\n      goto fail;\n    }\n  }\n  if (inInterruptionState == kAudioSessionBeginInterruption) {\n    AUBIO_WRN(\"audio_unit: session interruption started\\n\");\n    err = AudioOutputUnitStop(this_unit);\n    if (err) {\n      AUBIO_ERR(\"audio_unit: could not stop unit at interruption (%d)\\n\", (int)err);\n      goto fail;\n    }\n    err = AudioSessionSetActive(false);\n    if (err) {\n      AUBIO_ERR(\"audio_unit: could not make session inactive after interruption (%d)\\n\", (int)err);\n      goto fail;\n    }\n  }\nfail:\n  return;\n}", "path": "aubio/src/io/audio_unit.c", "commit_date": "2016-12-11 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* delete object */\n", "func_signal": "uint_t del_aubio_audio_unit(aubio_audio_unit_t *o)", "code": "{\n  int err = 0;\n  err = aubio_audio_unit_stop(o);\n  if (o->au_ios_inbuf) free(o->au_ios_inbuf);\n  o->au_ios_inbuf = NULL;\n  if (o->au_ios_outbuf) free(o->au_ios_outbuf);\n  o->au_ios_outbuf = NULL;\n  del_fmat (o->input_frames);\n  del_fmat (o->output_frames);\n  o->audio_unit = NULL;\n  return (int)err;\n}", "path": "aubio/src/io/audio_unit.c", "commit_date": "2016-12-11 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* jack callback functions */\n", "func_signal": "static void\naubio_jack_shutdown (void *arg UNUSED)", "code": "{\n  AUBIO_ERR (\"jack shutdown\\n\");\n  AUBIO_QUIT (AUBIO_OK);\n}", "path": "aubio/examples/jackio.c", "commit_date": "2016-04-24 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/**\n * Object creation/deletion calls\n */\n", "func_signal": "aubio_hist_t * new_aubio_hist (smpl_t flow, smpl_t fhig, uint_t nelems)", "code": "{\n  aubio_hist_t * s = AUBIO_NEW(aubio_hist_t);\n  smpl_t step = (fhig-flow)/(smpl_t)(nelems);\n  smpl_t accum = step;\n  uint_t i;\n  if ((sint_t)nelems <= 0) {\n    AUBIO_FREE(s);\n    return NULL;\n  }\n  s->nelems = nelems;\n  s->hist = new_fvec(nelems);\n  s->cent = new_fvec(nelems);\n\n  /* use scale to map flow/fhig -> 0/nelems */\n  s->scaler = new_aubio_scale(flow,fhig,0,nelems);\n  /* calculate centers now once */\n  s->cent->data[0] = flow + 0.5 * step;\n  for (i=1; i < s->nelems; i++, accum+=step )\n    s->cent->data[i] = s->cent->data[0] + accum;\n\n  return s;\n}", "path": "aubio/src/utils/hist.c", "commit_date": "2018-12-06 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* function Py_source_do_multi */\n", "func_signal": "static PyObject *\nPy_source_do_multi(Py_source * self, PyObject * args)", "code": "{\n  PyObject *outputs;\n  uint_t read;\n  read = 0;\n\n  Py_INCREF(self->mread_to);\n  if (!PyAubio_ArrayToCFmat(self->mread_to,  &(self->c_mread_to))) {\n    return NULL;\n  }\n  /* compute _do function */\n  aubio_source_do_multi (self->o, &(self->c_mread_to), &read);\n\n  if (PyErr_Occurred() != NULL) {\n    return NULL;\n  }\n\n  outputs = PyTuple_New(2);\n  PyTuple_SetItem( outputs, 0, self->mread_to);\n  PyTuple_SetItem( outputs, 1, (PyObject *)PyLong_FromLong(read));\n  return outputs;\n}", "path": "aubio/python/ext/py-source.c", "commit_date": "2018-12-23 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* HAVE_FLAC */\n", "func_signal": "aubio_sink_t * new_aubio_sink(const char_t * uri, uint_t samplerate)", "code": "{\n  aubio_sink_t * s = AUBIO_NEW(aubio_sink_t);\n\n#ifdef HAVE_VORBISENC\n  // check if this uri could be for us\n  if (aubio_str_path_has_extension(uri, \"ogg\")) {\n    s->sink = (void *)new_aubio_sink_vorbis(uri, samplerate);\n    if (s->sink) {\n      s->s_do = (aubio_sink_do_t)(aubio_sink_vorbis_do);\n      s->s_do_multi = (aubio_sink_do_multi_t)(aubio_sink_vorbis_do_multi);\n      s->s_preset_samplerate = (aubio_sink_preset_samplerate_t)(aubio_sink_vorbis_preset_samplerate);\n      s->s_preset_channels = (aubio_sink_preset_channels_t)(aubio_sink_vorbis_preset_channels);\n      s->s_get_samplerate = (aubio_sink_get_samplerate_t)(aubio_sink_vorbis_get_samplerate);\n      s->s_get_channels = (aubio_sink_get_channels_t)(aubio_sink_vorbis_get_channels);\n      s->s_close = (aubio_sink_close_t)(aubio_sink_vorbis_close);\n      s->s_del = (del_aubio_sink_t)(del_aubio_sink_vorbis);\n      return s;\n    }\n  }\n#endif /* HAVE_VORBISENC */\n\n#ifdef HAVE_FLAC\n  // check if this uri could be for us\n  if (aubio_str_path_has_extension(uri, \"flac\")) {\n    s->sink = (void *)new_aubio_sink_flac(uri, samplerate);\n    if (s->sink) {\n      s->s_do = (aubio_sink_do_t)(aubio_sink_flac_do);\n      s->s_do_multi = (aubio_sink_do_multi_t)(aubio_sink_flac_do_multi);\n      s->s_preset_samplerate = (aubio_sink_preset_samplerate_t)(aubio_sink_flac_preset_samplerate);\n      s->s_preset_channels = (aubio_sink_preset_channels_t)(aubio_sink_flac_preset_channels);\n      s->s_get_samplerate = (aubio_sink_get_samplerate_t)(aubio_sink_flac_get_samplerate);\n      s->s_get_channels = (aubio_sink_get_channels_t)(aubio_sink_flac_get_channels);\n      s->s_close = (aubio_sink_close_t)(aubio_sink_flac_close);\n      s->s_del = (del_aubio_sink_t)(del_aubio_sink_flac);\n      return s;\n    }\n  }\n#endif /* HAVE_FLAC */\n\n#ifdef HAVE_SINK_APPLE_AUDIO\n  s->sink = (void *)new_aubio_sink_apple_audio(uri, samplerate);\n  if (s->sink) {\n    s->s_do = (aubio_sink_do_t)(aubio_sink_apple_audio_do);\n    s->s_do_multi = (aubio_sink_do_multi_t)(aubio_sink_apple_audio_do_multi);\n    s->s_preset_samplerate = (aubio_sink_preset_samplerate_t)(aubio_sink_apple_audio_preset_samplerate);\n    s->s_preset_channels = (aubio_sink_preset_channels_t)(aubio_sink_apple_audio_preset_channels);\n    s->s_get_samplerate = (aubio_sink_get_samplerate_t)(aubio_sink_apple_audio_get_samplerate);\n    s->s_get_channels = (aubio_sink_get_channels_t)(aubio_sink_apple_audio_get_channels);\n    s->s_close = (aubio_sink_close_t)(aubio_sink_apple_audio_close);\n    s->s_del = (del_aubio_sink_t)(del_aubio_sink_apple_audio);\n    return s;\n  }\n#endif /* HAVE_SINK_APPLE_AUDIO */\n#ifdef HAVE_SNDFILE\n  s->sink = (void *)new_aubio_sink_sndfile(uri, samplerate);\n  if (s->sink) {\n    s->s_do = (aubio_sink_do_t)(aubio_sink_sndfile_do);\n    s->s_do_multi = (aubio_sink_do_multi_t)(aubio_sink_sndfile_do_multi);\n    s->s_preset_samplerate = (aubio_sink_preset_samplerate_t)(aubio_sink_sndfile_preset_samplerate);\n    s->s_preset_channels = (aubio_sink_preset_channels_t)(aubio_sink_sndfile_preset_channels);\n    s->s_get_samplerate = (aubio_sink_get_samplerate_t)(aubio_sink_sndfile_get_samplerate);\n    s->s_get_channels = (aubio_sink_get_channels_t)(aubio_sink_sndfile_get_channels);\n    s->s_close = (aubio_sink_close_t)(aubio_sink_sndfile_close);\n    s->s_del = (del_aubio_sink_t)(del_aubio_sink_sndfile);\n    return s;\n  }\n#endif /* HAVE_SNDFILE */\n#ifdef HAVE_WAVWRITE\n  s->sink = (void *)new_aubio_sink_wavwrite(uri, samplerate);\n  if (s->sink) {\n    s->s_do = (aubio_sink_do_t)(aubio_sink_wavwrite_do);\n    s->s_do_multi = (aubio_sink_do_multi_t)(aubio_sink_wavwrite_do_multi);\n    s->s_preset_samplerate = (aubio_sink_preset_samplerate_t)(aubio_sink_wavwrite_preset_samplerate);\n    s->s_preset_channels = (aubio_sink_preset_channels_t)(aubio_sink_wavwrite_preset_channels);\n    s->s_get_samplerate = (aubio_sink_get_samplerate_t)(aubio_sink_wavwrite_get_samplerate);\n    s->s_get_channels = (aubio_sink_get_channels_t)(aubio_sink_wavwrite_get_channels);\n    s->s_close = (aubio_sink_close_t)(aubio_sink_wavwrite_close);\n    s->s_del = (del_aubio_sink_t)(del_aubio_sink_wavwrite);\n    return s;\n  }\n#endif /* HAVE_WAVWRITE */\n#if !defined(HAVE_WAVWRITE) && \\\n  !defined(HAVE_SNDFILE) && \\\n  !defined(HAVE_SINK_APPLE_AUDIO) && \\\n  !defined(HAVE_VORBISENC) && \\\n  !defined(HAVE_FLAC)\n  AUBIO_ERROR(\"sink: failed creating '%s' at %dHz (no sink built-in)\\n\", uri, samplerate);\n#endif\n  del_aubio_sink(s);\n  return NULL;\n}", "path": "aubio/src/io/sink.c", "commit_date": "2019-03-31 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* The rough way: reset memory of filter between each run to avoid end effects. */\n", "func_signal": "void\naubio_filter_do_filtfilt (aubio_filter_t * f, fvec_t * in, fvec_t * tmp)", "code": "{\n  uint_t j;\n  uint_t length = in->length;\n  /* apply filtering */\n  aubio_filter_do (f, in);\n  aubio_filter_do_reset (f);\n  /* mirror */\n  for (j = 0; j < length; j++)\n    tmp->data[length - j - 1] = in->data[j];\n  /* apply filtering on mirrored */\n  aubio_filter_do (f, tmp);\n  aubio_filter_do_reset (f);\n  /* invert back */\n  for (j = 0; j < length; j++)\n    in->data[j] = tmp->data[length - j - 1];\n}", "path": "aubio/src/temporal/filter.c", "commit_date": "2016-04-21 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* Allocate memory for an tempo detection */\n", "func_signal": "aubio_tempo_t * new_aubio_tempo (const char_t * tempo_mode,\n    uint_t buf_size, uint_t hop_size, uint_t samplerate)", "code": "{\n  aubio_tempo_t * o = AUBIO_NEW(aubio_tempo_t);\n  char_t specdesc_func[PATH_MAX];\n  o->samplerate = samplerate;\n  // check parameters are valid\n  if ((sint_t)hop_size < 1) {\n    AUBIO_ERR(\"tempo: got hop size %d, but can not be < 1\\n\", hop_size);\n    goto beach;\n  } else if ((sint_t)buf_size < 2) {\n    AUBIO_ERR(\"tempo: got window size %d, but can not be < 2\\n\", buf_size);\n    goto beach;\n  } else if (buf_size < hop_size) {\n    AUBIO_ERR(\"tempo: hop size (%d) is larger than window size (%d)\\n\", buf_size, hop_size);\n    goto beach;\n  } else if ((sint_t)samplerate < 1) {\n    AUBIO_ERR(\"tempo: samplerate (%d) can not be < 1\\n\", samplerate);\n    goto beach;\n  }\n\n  /* length of observations, worth about 6 seconds */\n  o->winlen = aubio_next_power_of_two(5.8 * samplerate / hop_size);\n  if (o->winlen < 4) o->winlen = 4;\n  o->step = o->winlen/4;\n  o->blockpos = 0;\n  o->threshold = 0.3;\n  o->silence = -90.;\n  o->total_frames = 0;\n  o->last_beat = 0;\n  o->delay = 0;\n  o->hop_size = hop_size;\n  o->dfframe  = new_fvec(o->winlen);\n  o->fftgrain = new_cvec(buf_size);\n  o->out      = new_fvec(o->step);\n  o->pv       = new_aubio_pvoc(buf_size, hop_size);\n  o->pp       = new_aubio_peakpicker();\n  aubio_peakpicker_set_threshold (o->pp, o->threshold);\n  if ( strcmp(tempo_mode, \"default\") == 0 ) {\n    strncpy(specdesc_func, \"specflux\", PATH_MAX - 1);\n  } else {\n    strncpy(specdesc_func, tempo_mode, PATH_MAX - 1);\n    specdesc_func[PATH_MAX - 1] = '\\0';\n  }\n  o->od       = new_aubio_specdesc(specdesc_func,buf_size);\n  o->of       = new_fvec(1);\n  o->bt       = new_aubio_beattracking(o->winlen, o->hop_size, o->samplerate);\n  o->onset    = new_fvec(1);\n  /*if (usedoubled)    {\n    o2 = new_aubio_specdesc(type_onset2,buffer_size);\n    onset2 = new_fvec(1);\n  }*/\n  if (!o->dfframe || !o->fftgrain || !o->out || !o->pv ||\n      !o->pp || !o->od || !o->of || !o->bt || !o->onset) {\n    AUBIO_ERR(\"tempo: failed creating tempo object\\n\");\n    goto beach;\n  }\n  o->last_tatum = 0;\n  o->tatum_signature = 4;\n  return o;\n\nbeach:\n  del_aubio_tempo(o);\n  return NULL;\n}", "path": "aubio/src/tempo/tempo.c", "commit_date": "2018-11-24 00:00:00", "repo_name": "aubio/aubio", "stars": 3123, "license": "gpl-3.0", "language": "c", "size": 11803}
{"docstring": "/* This little function scans through a compiled pattern until it finds an\ninstance of OP_RECURSE.\n\nArguments:\n  code        points to start of expression\n  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode\n\nReturns:      pointer to the opcode for OP_RECURSE, or NULL if not found\n*/\n", "func_signal": "static const pcre_uchar *\nfind_recurse(const pcre_uchar *code, BOOL utf)", "code": "{\nfor (;;)\n  {\n  register pcre_uchar c = *code;\n  if (c == OP_END) return NULL;\n  if (c == OP_RECURSE) return code;\n\n  /* XCLASS is used for classes that cannot be represented just by a bit\n  map. This includes negated single high-valued characters. The length in\n  the table is zero; the actual length is stored in the compiled code. */\n\n  if (c == OP_XCLASS) code += GET(code, 1);\n\n  /* Otherwise, we can get the item's length from the table, except that for\n  repeated character types, we have to test for \\p and \\P, which have an extra\n  two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we\n  must add in its length. */\n\n  else\n    {\n    switch(c)\n      {\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      case OP_TYPEPOSQUERY:\n      if (code[1] == OP_PROP || code[1] == OP_NOTPROP) code += 2;\n      break;\n\n      case OP_TYPEPOSUPTO:\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      if (code[1 + IMM2_SIZE] == OP_PROP || code[1 + IMM2_SIZE] == OP_NOTPROP)\n        code += 2;\n      break;\n\n      case OP_MARK:\n      case OP_PRUNE_ARG:\n      case OP_SKIP_ARG:\n      case OP_THEN_ARG:\n      code += code[1];\n      break;\n      }\n\n    /* Add in the fixed length from the table */\n\n    code += PRIV(OP_lengths)[c];\n\n    /* In UTF-8 mode, opcodes that are followed by a character may be followed\n    by a multi-byte character. The length in the table is a minimum, so we have\n    to arrange to skip the extra bytes. */\n\n#if defined SUPPORT_UTF && !defined COMPILE_PCRE32\n    if (utf) switch(c)\n      {\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      case OP_EXACT:\n      case OP_EXACTI:\n      case OP_NOTEXACT:\n      case OP_NOTEXACTI:\n      case OP_UPTO:\n      case OP_UPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTUPTOI:\n      case OP_MINUPTO:\n      case OP_MINUPTOI:\n      case OP_NOTMINUPTO:\n      case OP_NOTMINUPTOI:\n      case OP_POSUPTO:\n      case OP_POSUPTOI:\n      case OP_NOTPOSUPTO:\n      case OP_NOTPOSUPTOI:\n      case OP_STAR:\n      case OP_STARI:\n      case OP_NOTSTAR:\n      case OP_NOTSTARI:\n      case OP_MINSTAR:\n      case OP_MINSTARI:\n      case OP_NOTMINSTAR:\n      case OP_NOTMINSTARI:\n      case OP_POSSTAR:\n      case OP_POSSTARI:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSSTARI:\n      case OP_PLUS:\n      case OP_PLUSI:\n      case OP_NOTPLUS:\n      case OP_NOTPLUSI:\n      case OP_MINPLUS:\n      case OP_MINPLUSI:\n      case OP_NOTMINPLUS:\n      case OP_NOTMINPLUSI:\n      case OP_POSPLUS:\n      case OP_POSPLUSI:\n      case OP_NOTPOSPLUS:\n      case OP_NOTPOSPLUSI:\n      case OP_QUERY:\n      case OP_QUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTQUERYI:\n      case OP_MINQUERY:\n      case OP_MINQUERYI:\n      case OP_NOTMINQUERY:\n      case OP_NOTMINQUERYI:\n      case OP_POSQUERY:\n      case OP_POSQUERYI:\n      case OP_NOTPOSQUERY:\n      case OP_NOTPOSQUERYI:\n      if (HAS_EXTRALEN(code[-1])) code += GET_EXTRALEN(code[-1]);\n      break;\n      }\n#else\n    (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif\n    }\n  }\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* Checks whether the base and the current opcode have a common character, in\nwhich case the base cannot be possessified.\n\nArguments:\n  code        points to the byte code\n  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode\n  cd          static compile data\n  base_list   the data list of the base opcode\n\nReturns:      TRUE if the auto-possessification is possible\n*/\n", "func_signal": "static BOOL\ncompare_opcodes(const pcre_uchar *code, BOOL utf, const compile_data *cd,\n  const pcre_uint32 *base_list, const pcre_uchar *base_end, int *rec_limit)", "code": "{\npcre_uchar c;\npcre_uint32 list[8];\nconst pcre_uint32 *chr_ptr;\nconst pcre_uint32 *ochr_ptr;\nconst pcre_uint32 *list_ptr;\nconst pcre_uchar *next_code;\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\nconst pcre_uchar *xclass_flags;\n#endif\nconst pcre_uint8 *class_bitset;\nconst pcre_uint8 *set1, *set2, *set_end;\npcre_uint32 chr;\nBOOL accepted, invert_bits;\nBOOL entered_a_group = FALSE;\n\nif (*rec_limit == 0) return FALSE;\n--(*rec_limit);\n\n/* Note: the base_list[1] contains whether the current opcode has greedy\n(represented by a non-zero value) quantifier. This is a different from\nother character type lists, which stores here that the character iterator\nmatches to an empty string (also represented by a non-zero value). */\n\nfor(;;)\n  {\n  /* All operations move the code pointer forward.\n  Therefore infinite recursions are not possible. */\n\n  c = *code;\n\n  /* Skip over callouts */\n\n  if (c == OP_CALLOUT)\n    {\n    code += PRIV(OP_lengths)[c];\n    continue;\n    }\n\n  if (c == OP_ALT)\n    {\n    do code += GET(code, 1); while (*code == OP_ALT);\n    c = *code;\n    }\n\n  switch(c)\n    {\n    case OP_END:\n    case OP_KETRPOS:\n    /* TRUE only in greedy case. The non-greedy case could be replaced by\n    an OP_EXACT, but it is probably not worth it. (And note that OP_EXACT\n    uses more memory, which we cannot get at this stage.) */\n\n    return base_list[1] != 0;\n\n    case OP_KET:\n    /* If the bracket is capturing, and referenced by an OP_RECURSE, or\n    it is an atomic sub-pattern (assert, once, etc.) the non-greedy case\n    cannot be converted to a possessive form. */\n\n    if (base_list[1] == 0) return FALSE;\n\n    switch(*(code - GET(code, 1)))\n      {\n      case OP_ASSERT:\n      case OP_ASSERT_NOT:\n      case OP_ASSERTBACK:\n      case OP_ASSERTBACK_NOT:\n      case OP_ONCE:\n      case OP_ONCE_NC:\n      /* Atomic sub-patterns and assertions can always auto-possessify their\n      last iterator. However, if the group was entered as a result of checking\n      a previous iterator, this is not possible. */\n\n      return !entered_a_group;\n      }\n\n    code += PRIV(OP_lengths)[c];\n    continue;\n\n    case OP_ONCE:\n    case OP_ONCE_NC:\n    case OP_BRA:\n    case OP_CBRA:\n    next_code = code + GET(code, 1);\n    code += PRIV(OP_lengths)[c];\n\n    while (*next_code == OP_ALT)\n      {\n      if (!compare_opcodes(code, utf, cd, base_list, base_end, rec_limit))\n        return FALSE;\n      code = next_code + 1 + LINK_SIZE;\n      next_code += GET(next_code, 1);\n      }\n\n    entered_a_group = TRUE;\n    continue;\n\n    case OP_BRAZERO:\n    case OP_BRAMINZERO:\n\n    next_code = code + 1;\n    if (*next_code != OP_BRA && *next_code != OP_CBRA\n        && *next_code != OP_ONCE && *next_code != OP_ONCE_NC) return FALSE;\n\n    do next_code += GET(next_code, 1); while (*next_code == OP_ALT);\n\n    /* The bracket content will be checked by the\n    OP_BRA/OP_CBRA case above. */\n    next_code += 1 + LINK_SIZE;\n    if (!compare_opcodes(next_code, utf, cd, base_list, base_end, rec_limit))\n      return FALSE;\n\n    code += PRIV(OP_lengths)[c];\n    continue;\n\n    default:\n    break;\n    }\n\n  /* Check for a supported opcode, and load its properties. */\n\n  code = get_chr_property_list(code, utf, cd->fcc, list);\n  if (code == NULL) return FALSE;    /* Unsupported */\n\n  /* If either opcode is a small character list, set pointers for comparing\n  characters from that list with another list, or with a property. */\n\n  if (base_list[0] == OP_CHAR)\n    {\n    chr_ptr = base_list + 2;\n    list_ptr = list;\n    }\n  else if (list[0] == OP_CHAR)\n    {\n    chr_ptr = list + 2;\n    list_ptr = base_list;\n    }\n\n  /* Character bitsets can also be compared to certain opcodes. */\n\n  else if (base_list[0] == OP_CLASS || list[0] == OP_CLASS\n#ifdef COMPILE_PCRE8\n      /* In 8 bit, non-UTF mode, OP_CLASS and OP_NCLASS are the same. */\n      || (!utf && (base_list[0] == OP_NCLASS || list[0] == OP_NCLASS))\n#endif\n      )\n    {\n#ifdef COMPILE_PCRE8\n    if (base_list[0] == OP_CLASS || (!utf && base_list[0] == OP_NCLASS))\n#else\n    if (base_list[0] == OP_CLASS)\n#endif\n      {\n      set1 = (pcre_uint8 *)(base_end - base_list[2]);\n      list_ptr = list;\n      }\n    else\n      {\n      set1 = (pcre_uint8 *)(code - list[2]);\n      list_ptr = base_list;\n      }\n\n    invert_bits = FALSE;\n    switch(list_ptr[0])\n      {\n      case OP_CLASS:\n      case OP_NCLASS:\n      set2 = (pcre_uint8 *)\n        ((list_ptr == list ? code : base_end) - list_ptr[2]);\n      break;\n\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n      case OP_XCLASS:\n      xclass_flags = (list_ptr == list ? code : base_end) - list_ptr[2] + LINK_SIZE;\n      if ((*xclass_flags & XCL_HASPROP) != 0) return FALSE;\n      if ((*xclass_flags & XCL_MAP) == 0)\n        {\n        /* No bits are set for characters < 256. */\n        if (list[1] == 0) return TRUE;\n        /* Might be an empty repeat. */\n        continue;\n        }\n      set2 = (pcre_uint8 *)(xclass_flags + 1);\n      break;\n#endif\n\n      case OP_NOT_DIGIT:\n      invert_bits = TRUE;\n      /* Fall through */\n      case OP_DIGIT:\n      set2 = (pcre_uint8 *)(cd->cbits + cbit_digit);\n      break;\n\n      case OP_NOT_WHITESPACE:\n      invert_bits = TRUE;\n      /* Fall through */\n      case OP_WHITESPACE:\n      set2 = (pcre_uint8 *)(cd->cbits + cbit_space);\n      break;\n\n      case OP_NOT_WORDCHAR:\n      invert_bits = TRUE;\n      /* Fall through */\n      case OP_WORDCHAR:\n      set2 = (pcre_uint8 *)(cd->cbits + cbit_word);\n      break;\n\n      default:\n      return FALSE;\n      }\n\n    /* Because the sets are unaligned, we need\n    to perform byte comparison here. */\n    set_end = set1 + 32;\n    if (invert_bits)\n      {\n      do\n        {\n        if ((*set1++ & ~(*set2++)) != 0) return FALSE;\n        }\n      while (set1 < set_end);\n      }\n    else\n      {\n      do\n        {\n        if ((*set1++ & *set2++) != 0) return FALSE;\n        }\n      while (set1 < set_end);\n      }\n\n    if (list[1] == 0) return TRUE;\n    /* Might be an empty repeat. */\n    continue;\n    }\n\n  /* Some property combinations also acceptable. Unicode property opcodes are\n  processed specially; the rest can be handled with a lookup table. */\n\n  else\n    {\n    pcre_uint32 leftop, rightop;\n\n    leftop = base_list[0];\n    rightop = list[0];\n\n#ifdef SUPPORT_UCP\n    accepted = FALSE; /* Always set in non-unicode case. */\n    if (leftop == OP_PROP || leftop == OP_NOTPROP)\n      {\n      if (rightop == OP_EOD)\n        accepted = TRUE;\n      else if (rightop == OP_PROP || rightop == OP_NOTPROP)\n        {\n        int n;\n        const pcre_uint8 *p;\n        BOOL same = leftop == rightop;\n        BOOL lisprop = leftop == OP_PROP;\n        BOOL risprop = rightop == OP_PROP;\n        BOOL bothprop = lisprop && risprop;\n\n        /* There's a table that specifies how each combination is to be\n        processed:\n          0   Always return FALSE (never auto-possessify)\n          1   Character groups are distinct (possessify if both are OP_PROP)\n          2   Check character categories in the same group (general or particular)\n          3   Return TRUE if the two opcodes are not the same\n          ... see comments below\n        */\n\n        n = propposstab[base_list[2]][list[2]];\n        switch(n)\n          {\n          case 0: break;\n          case 1: accepted = bothprop; break;\n          case 2: accepted = (base_list[3] == list[3]) != same; break;\n          case 3: accepted = !same; break;\n\n          case 4:  /* Left general category, right particular category */\n          accepted = risprop && catposstab[base_list[3]][list[3]] == same;\n          break;\n\n          case 5:  /* Right general category, left particular category */\n          accepted = lisprop && catposstab[list[3]][base_list[3]] == same;\n          break;\n\n          /* This code is logically tricky. Think hard before fiddling with it.\n          The posspropstab table has four entries per row. Each row relates to\n          one of PCRE's special properties such as ALNUM or SPACE or WORD.\n          Only WORD actually needs all four entries, but using repeats for the\n          others means they can all use the same code below.\n\n          The first two entries in each row are Unicode general categories, and\n          apply always, because all the characters they include are part of the\n          PCRE character set. The third and fourth entries are a general and a\n          particular category, respectively, that include one or more relevant\n          characters. One or the other is used, depending on whether the check\n          is for a general or a particular category. However, in both cases the\n          category contains more characters than the specials that are defined\n          for the property being tested against. Therefore, it cannot be used\n          in a NOTPROP case.\n\n          Example: the row for WORD contains ucp_L, ucp_N, ucp_P, ucp_Po.\n          Underscore is covered by ucp_P or ucp_Po. */\n\n          case 6:  /* Left alphanum vs right general category */\n          case 7:  /* Left space vs right general category */\n          case 8:  /* Left word vs right general category */\n          p = posspropstab[n-6];\n          accepted = risprop && lisprop ==\n            (list[3] != p[0] &&\n             list[3] != p[1] &&\n            (list[3] != p[2] || !lisprop));\n          break;\n\n          case 9:   /* Right alphanum vs left general category */\n          case 10:  /* Right space vs left general category */\n          case 11:  /* Right word vs left general category */\n          p = posspropstab[n-9];\n          accepted = lisprop && risprop ==\n            (base_list[3] != p[0] &&\n             base_list[3] != p[1] &&\n            (base_list[3] != p[2] || !risprop));\n          break;\n\n          case 12:  /* Left alphanum vs right particular category */\n          case 13:  /* Left space vs right particular category */\n          case 14:  /* Left word vs right particular category */\n          p = posspropstab[n-12];\n          accepted = risprop && lisprop ==\n            (catposstab[p[0]][list[3]] &&\n             catposstab[p[1]][list[3]] &&\n            (list[3] != p[3] || !lisprop));\n          break;\n\n          case 15:  /* Right alphanum vs left particular category */\n          case 16:  /* Right space vs left particular category */\n          case 17:  /* Right word vs left particular category */\n          p = posspropstab[n-15];\n          accepted = lisprop && risprop ==\n            (catposstab[p[0]][base_list[3]] &&\n             catposstab[p[1]][base_list[3]] &&\n            (base_list[3] != p[3] || !risprop));\n          break;\n          }\n        }\n      }\n\n    else\n#endif  /* SUPPORT_UCP */\n\n    accepted = leftop >= FIRST_AUTOTAB_OP && leftop <= LAST_AUTOTAB_LEFT_OP &&\n           rightop >= FIRST_AUTOTAB_OP && rightop <= LAST_AUTOTAB_RIGHT_OP &&\n           autoposstab[leftop - FIRST_AUTOTAB_OP][rightop - FIRST_AUTOTAB_OP];\n\n    if (!accepted) return FALSE;\n\n    if (list[1] == 0) return TRUE;\n    /* Might be an empty repeat. */\n    continue;\n    }\n\n  /* Control reaches here only if one of the items is a small character list.\n  All characters are checked against the other side. */\n\n  do\n    {\n    chr = *chr_ptr;\n\n    switch(list_ptr[0])\n      {\n      case OP_CHAR:\n      ochr_ptr = list_ptr + 2;\n      do\n        {\n        if (chr == *ochr_ptr) return FALSE;\n        ochr_ptr++;\n        }\n      while(*ochr_ptr != NOTACHAR);\n      break;\n\n      case OP_NOT:\n      ochr_ptr = list_ptr + 2;\n      do\n        {\n        if (chr == *ochr_ptr)\n          break;\n        ochr_ptr++;\n        }\n      while(*ochr_ptr != NOTACHAR);\n      if (*ochr_ptr == NOTACHAR) return FALSE;   /* Not found */\n      break;\n\n      /* Note that OP_DIGIT etc. are generated only when PCRE_UCP is *not*\n      set. When it is set, \\d etc. are converted into OP_(NOT_)PROP codes. */\n\n      case OP_DIGIT:\n      if (chr < 256 && (cd->ctypes[chr] & ctype_digit) != 0) return FALSE;\n      break;\n\n      case OP_NOT_DIGIT:\n      if (chr > 255 || (cd->ctypes[chr] & ctype_digit) == 0) return FALSE;\n      break;\n\n      case OP_WHITESPACE:\n      if (chr < 256 && (cd->ctypes[chr] & ctype_space) != 0) return FALSE;\n      break;\n\n      case OP_NOT_WHITESPACE:\n      if (chr > 255 || (cd->ctypes[chr] & ctype_space) == 0) return FALSE;\n      break;\n\n      case OP_WORDCHAR:\n      if (chr < 255 && (cd->ctypes[chr] & ctype_word) != 0) return FALSE;\n      break;\n\n      case OP_NOT_WORDCHAR:\n      if (chr > 255 || (cd->ctypes[chr] & ctype_word) == 0) return FALSE;\n      break;\n\n      case OP_HSPACE:\n      switch(chr)\n        {\n        HSPACE_CASES: return FALSE;\n        default: break;\n        }\n      break;\n\n      case OP_NOT_HSPACE:\n      switch(chr)\n        {\n        HSPACE_CASES: break;\n        default: return FALSE;\n        }\n      break;\n\n      case OP_ANYNL:\n      case OP_VSPACE:\n      switch(chr)\n        {\n        VSPACE_CASES: return FALSE;\n        default: break;\n        }\n      break;\n\n      case OP_NOT_VSPACE:\n      switch(chr)\n        {\n        VSPACE_CASES: break;\n        default: return FALSE;\n        }\n      break;\n\n      case OP_DOLL:\n      case OP_EODN:\n      switch (chr)\n        {\n        case CHAR_CR:\n        case CHAR_LF:\n        case CHAR_VT:\n        case CHAR_FF:\n        case CHAR_NEL:\n#ifndef EBCDIC\n        case 0x2028:\n        case 0x2029:\n#endif  /* Not EBCDIC */\n        return FALSE;\n        }\n      break;\n\n      case OP_EOD:    /* Can always possessify before \\z */\n      break;\n\n#ifdef SUPPORT_UCP\n      case OP_PROP:\n      case OP_NOTPROP:\n      if (!check_char_prop(chr, list_ptr[2], list_ptr[3],\n            list_ptr[0] == OP_NOTPROP))\n        return FALSE;\n      break;\n#endif\n\n      case OP_NCLASS:\n      if (chr > 255) return FALSE;\n      /* Fall through */\n\n      case OP_CLASS:\n      if (chr > 255) break;\n      class_bitset = (pcre_uint8 *)\n        ((list_ptr == list ? code : base_end) - list_ptr[2]);\n      if ((class_bitset[chr >> 3] & (1 << (chr & 7))) != 0) return FALSE;\n      break;\n\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n      case OP_XCLASS:\n      if (PRIV(xclass)(chr, (list_ptr == list ? code : base_end) -\n          list_ptr[2] + LINK_SIZE, utf)) return FALSE;\n      break;\n#endif\n\n      default:\n      return FALSE;\n      }\n\n    chr_ptr++;\n    }\n  while(*chr_ptr != NOTACHAR);\n\n  /* At least one character must be matched from this opcode. */\n\n  if (list[1] == 0) return TRUE;\n  }\n\n/* Control never reaches here. There used to be a fail-save return FALSE; here,\nbut some compilers complain about an unreachable statement. */\n\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function is called to check the name given in a POSIX-style class entry\nsuch as [:alnum:].\n\nArguments:\n  ptr        points to the first letter\n  len        the length of the name\n\nReturns:     a value representing the name, or -1 if unknown\n*/\n", "func_signal": "static int\ncheck_posix_name(const pcre_uchar *ptr, int len)", "code": "{\nconst char *pn = posix_names;\nregister int yield = 0;\nwhile (posix_name_lengths[yield] != 0)\n  {\n  if (len == posix_name_lengths[yield] &&\n    STRNCMP_UC_C8(ptr, pn, (unsigned int)len) == 0) return yield;\n  pn += posix_name_lengths[yield] + 1;\n  yield++;\n  }\nreturn -1;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function is called when the PCRE_AUTO_CALLOUT option is set, to insert\ncallout points before each pattern item.\n\nArguments:\n  code           current code pointer\n  ptr            current pattern pointer\n  cd             pointers to tables etc\n\nReturns:         new code pointer\n*/\n", "func_signal": "static pcre_uchar *\nauto_callout(pcre_uchar *code, const pcre_uchar *ptr, compile_data *cd)", "code": "{\n*code++ = OP_CALLOUT;\n*code++ = 255;\nPUT(code, 0, (int)(ptr - cd->start_pattern));  /* Pattern offset */\nPUT(code, LINK_SIZE, 0);                       /* Default length */\nreturn code + 2 * LINK_SIZE;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This is called by several functions that scan a compiled expression looking\nfor a fixed first character, or an anchoring op code etc. It skips over things\nthat do not influence this. For some calls, it makes sense to skip negative\nforward and all backward assertions, and also the \\b assertion; for others it\ndoes not.\n\nArguments:\n  code         pointer to the start of the group\n  skipassert   TRUE if certain assertions are to be skipped\n\nReturns:       pointer to the first significant opcode\n*/\n", "func_signal": "static const pcre_uchar*\nfirst_significant_code(const pcre_uchar *code, BOOL skipassert)", "code": "{\nfor (;;)\n  {\n  switch ((int)*code)\n    {\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    if (!skipassert) return code;\n    do code += GET(code, 1); while (*code == OP_ALT);\n    code += PRIV(OP_lengths)[*code];\n    break;\n\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_WORD_BOUNDARY:\n    if (!skipassert) return code;\n    /* Fall through */\n\n    case OP_CALLOUT:\n    case OP_CREF:\n    case OP_DNCREF:\n    case OP_RREF:\n    case OP_DNRREF:\n    case OP_DEF:\n    code += PRIV(OP_lengths)[*code];\n    break;\n\n    default:\n    return code;\n    }\n  }\n/* Control never reaches here */\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* Replaces single character iterations with their possessive alternatives\nif appropriate. This function modifies the compiled opcode!\n\nArguments:\n  code        points to start of the byte code\n  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode\n  cd          static compile data\n\nReturns:      nothing\n*/\n", "func_signal": "static void\nauto_possessify(pcre_uchar *code, BOOL utf, const compile_data *cd)", "code": "{\nregister pcre_uchar c;\nconst pcre_uchar *end;\npcre_uchar *repeat_opcode;\npcre_uint32 list[8];\nint rec_limit;\n\nfor (;;)\n  {\n  c = *code;\n\n  /* When a pattern with bad UTF-8 encoding is compiled with NO_UTF_CHECK,\n  it may compile without complaining, but may get into a loop here if the code\n  pointer points to a bad value. This is, of course a documentated possibility,\n  when NO_UTF_CHECK is set, so it isn't a bug, but we can detect this case and\n  just give up on this optimization. */\n\n  if (c >= OP_TABLE_LENGTH) return;\n\n  if (c >= OP_STAR && c <= OP_TYPEPOSUPTO)\n    {\n    c -= get_repeat_base(c) - OP_STAR;\n    end = (c <= OP_MINUPTO) ?\n      get_chr_property_list(code, utf, cd->fcc, list) : NULL;\n    list[1] = c == OP_STAR || c == OP_PLUS || c == OP_QUERY || c == OP_UPTO;\n\n    rec_limit = 1000;\n    if (end != NULL && compare_opcodes(end, utf, cd, list, end, &rec_limit))\n      {\n      switch(c)\n        {\n        case OP_STAR:\n        *code += OP_POSSTAR - OP_STAR;\n        break;\n\n        case OP_MINSTAR:\n        *code += OP_POSSTAR - OP_MINSTAR;\n        break;\n\n        case OP_PLUS:\n        *code += OP_POSPLUS - OP_PLUS;\n        break;\n\n        case OP_MINPLUS:\n        *code += OP_POSPLUS - OP_MINPLUS;\n        break;\n\n        case OP_QUERY:\n        *code += OP_POSQUERY - OP_QUERY;\n        break;\n\n        case OP_MINQUERY:\n        *code += OP_POSQUERY - OP_MINQUERY;\n        break;\n\n        case OP_UPTO:\n        *code += OP_POSUPTO - OP_UPTO;\n        break;\n\n        case OP_MINUPTO:\n        *code += OP_POSUPTO - OP_MINUPTO;\n        break;\n        }\n      }\n    c = *code;\n    }\n  else if (c == OP_CLASS || c == OP_NCLASS || c == OP_XCLASS)\n    {\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n    if (c == OP_XCLASS)\n      repeat_opcode = code + GET(code, 1);\n    else\n#endif\n      repeat_opcode = code + 1 + (32 / sizeof(pcre_uchar));\n\n    c = *repeat_opcode;\n    if (c >= OP_CRSTAR && c <= OP_CRMINRANGE)\n      {\n      /* end must not be NULL. */\n      end = get_chr_property_list(code, utf, cd->fcc, list);\n\n      list[1] = (c & 1) == 0;\n\n      rec_limit = 1000;\n      if (compare_opcodes(end, utf, cd, list, end, &rec_limit))\n        {\n        switch (c)\n          {\n          case OP_CRSTAR:\n          case OP_CRMINSTAR:\n          *repeat_opcode = OP_CRPOSSTAR;\n          break;\n\n          case OP_CRPLUS:\n          case OP_CRMINPLUS:\n          *repeat_opcode = OP_CRPOSPLUS;\n          break;\n\n          case OP_CRQUERY:\n          case OP_CRMINQUERY:\n          *repeat_opcode = OP_CRPOSQUERY;\n          break;\n\n          case OP_CRRANGE:\n          case OP_CRMINRANGE:\n          *repeat_opcode = OP_CRPOSRANGE;\n          break;\n          }\n        }\n      }\n    c = *code;\n    }\n\n  switch(c)\n    {\n    case OP_END:\n    return;\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    if (code[1] == OP_PROP || code[1] == OP_NOTPROP) code += 2;\n    break;\n\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSUPTO:\n    if (code[1 + IMM2_SIZE] == OP_PROP || code[1 + IMM2_SIZE] == OP_NOTPROP)\n      code += 2;\n    break;\n\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n    case OP_XCLASS:\n    code += GET(code, 1);\n    break;\n#endif\n\n    case OP_MARK:\n    case OP_PRUNE_ARG:\n    case OP_SKIP_ARG:\n    case OP_THEN_ARG:\n    code += code[1];\n    break;\n    }\n\n  /* Add in the fixed length from the table */\n\n  code += PRIV(OP_lengths)[c];\n\n  /* In UTF-8 mode, opcodes that are followed by a character may be followed by\n  a multi-byte character. The length in the table is a minimum, so we have to\n  arrange to skip the extra bytes. */\n\n#if defined SUPPORT_UTF && !defined COMPILE_PCRE32\n  if (utf) switch(c)\n    {\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    if (HAS_EXTRALEN(code[-1])) code += GET_EXTRALEN(code[-1]);\n    break;\n    }\n#else\n  (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif\n  }\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function is called to check for left recursive calls. We want to check\nthe current branch of the current pattern to see if it could match the empty\nstring. If it could, we must look outwards for branches at other levels,\nstopping when we pass beyond the bracket which is the subject of the recursion.\nThis function is called only during the real compile, not during the\npre-compile.\n\nArguments:\n  code        points to start of the recursion\n  endcode     points to where to stop (current RECURSE item)\n  bcptr       points to the chain of current (unclosed) branch starts\n  utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode\n  cd          pointers to tables etc\n\nReturns:      TRUE if what is matched could be empty\n*/\n", "func_signal": "static BOOL\ncould_be_empty(const pcre_uchar *code, const pcre_uchar *endcode,\n  branch_chain *bcptr, BOOL utf, compile_data *cd)", "code": "{\nwhile (bcptr != NULL && bcptr->current_branch >= code)\n  {\n  if (!could_be_empty_branch(bcptr->current_branch, endcode, utf, cd, NULL))\n    return FALSE;\n  bcptr = bcptr->outer;\n  }\nreturn TRUE;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function packages up the logic of adding a character or range of\ncharacters to a class. The character values in the arguments will be within the\nvalid values for the current mode (8-bit, 16-bit, UTF, etc). This function is\nmutually recursive with the function immediately below.\n\nArguments:\n  classbits     the bit map for characters < 256\n  uchardptr     points to the pointer for extra data\n  options       the options word\n  cd            contains pointers to tables etc.\n  start         start of range character\n  end           end of range character\n\nReturns:        the number of < 256 characters added\n                the pointer to extra data is updated\n*/\n", "func_signal": "static int\nadd_to_class(pcre_uint8 *classbits, pcre_uchar **uchardptr, int options,\n  compile_data *cd, pcre_uint32 start, pcre_uint32 end)", "code": "{\npcre_uint32 c;\npcre_uint32 classbits_end = (end <= 0xff ? end : 0xff);\nint n8 = 0;\n\n/* If caseless matching is required, scan the range and process alternate\ncases. In Unicode, there are 8-bit characters that have alternate cases that\nare greater than 255 and vice-versa. Sometimes we can just extend the original\nrange. */\n\nif ((options & PCRE_CASELESS) != 0)\n  {\n#ifdef SUPPORT_UCP\n  if ((options & PCRE_UTF8) != 0)\n    {\n    int rc;\n    pcre_uint32 oc, od;\n\n    options &= ~PCRE_CASELESS;   /* Remove for recursive calls */\n    c = start;\n\n    while ((rc = get_othercase_range(&c, end, &oc, &od)) >= 0)\n      {\n      /* Handle a single character that has more than one other case. */\n\n      if (rc > 0) n8 += add_list_to_class(classbits, uchardptr, options, cd,\n        PRIV(ucd_caseless_sets) + rc, oc);\n\n      /* Do nothing if the other case range is within the original range. */\n\n      else if (oc >= start && od <= end) continue;\n\n      /* Extend the original range if there is overlap, noting that if oc < c, we\n      can't have od > end because a subrange is always shorter than the basic\n      range. Otherwise, use a recursive call to add the additional range. */\n\n      else if (oc < start && od >= start - 1) start = oc; /* Extend downwards */\n      else if (od > end && oc <= end + 1)\n        {\n        end = od;       /* Extend upwards */\n        if (end > classbits_end) classbits_end = (end <= 0xff ? end : 0xff);\n        }\n      else n8 += add_to_class(classbits, uchardptr, options, cd, oc, od);\n      }\n    }\n  else\n#endif  /* SUPPORT_UCP */\n\n  /* Not UTF-mode, or no UCP */\n\n  for (c = start; c <= classbits_end; c++)\n    {\n    SETBIT(classbits, cd->fcc[c]);\n    n8++;\n    }\n  }\n\n/* Now handle the original range. Adjust the final value according to the bit\nlength - this means that the same lists of (e.g.) horizontal spaces can be used\nin all cases. */\n\n#if defined COMPILE_PCRE8\n#ifdef SUPPORT_UTF\n  if ((options & PCRE_UTF8) == 0)\n#endif\n  if (end > 0xff) end = 0xff;\n\n#elif defined COMPILE_PCRE16\n#ifdef SUPPORT_UTF\n  if ((options & PCRE_UTF16) == 0)\n#endif\n  if (end > 0xffff) end = 0xffff;\n\n#endif /* COMPILE_PCRE[8|16] */\n\n/* Use the bitmap for characters < 256. Otherwise use extra data.*/\n\nfor (c = start; c <= classbits_end; c++)\n  {\n  /* Regardless of start, c will always be <= 255. */\n  SETBIT(classbits, c);\n  n8++;\n  }\n\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\nif (start <= 0xff) start = 0xff + 1;\n\nif (end >= start)\n  {\n  pcre_uchar *uchardata = *uchardptr;\n#ifdef SUPPORT_UTF\n  if ((options & PCRE_UTF8) != 0)  /* All UTFs use the same flag bit */\n    {\n    if (start < end)\n      {\n      *uchardata++ = XCL_RANGE;\n      uchardata += PRIV(ord2utf)(start, uchardata);\n      uchardata += PRIV(ord2utf)(end, uchardata);\n      }\n    else if (start == end)\n      {\n      *uchardata++ = XCL_SINGLE;\n      uchardata += PRIV(ord2utf)(start, uchardata);\n      }\n    }\n  else\n#endif  /* SUPPORT_UTF */\n\n  /* Without UTF support, character values are constrained by the bit length,\n  and can only be > 256 for 16-bit and 32-bit libraries. */\n\n#ifdef COMPILE_PCRE8\n    {}\n#else\n  if (start < end)\n    {\n    *uchardata++ = XCL_RANGE;\n    *uchardata++ = start;\n    *uchardata++ = end;\n    }\n  else if (start == end)\n    {\n    *uchardata++ = XCL_SINGLE;\n    *uchardata++ = start;\n    }\n#endif\n\n  *uchardptr = uchardata;   /* Updata extra data pointer */\n  }\n#endif /* SUPPORT_UTF || !COMPILE_PCRE8 */\n\nreturn n8;    /* Number of 8-bit characters */\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function is used for adding the complement of a list of horizontal or\nvertical whitespace to a class. The list must be in order.\n\nArguments:\n  classbits     the bit map for characters < 256\n  uchardptr     points to the pointer for extra data\n  options       the options word\n  cd            contains pointers to tables etc.\n  p             points to row of 32-bit values, terminated by NOTACHAR\n\nReturns:        the number of < 256 characters added\n                the pointer to extra data is updated\n*/\n", "func_signal": "static int\nadd_not_list_to_class(pcre_uint8 *classbits, pcre_uchar **uchardptr,\n  int options, compile_data *cd, const pcre_uint32 *p)", "code": "{\nBOOL utf = (options & PCRE_UTF8) != 0;\nint n8 = 0;\nif (p[0] > 0)\n  n8 += add_to_class(classbits, uchardptr, options, cd, 0, p[0] - 1);\nwhile (p[0] < NOTACHAR)\n  {\n  while (p[1] == p[0] + 1) p++;\n  n8 += add_to_class(classbits, uchardptr, options, cd, p[0] + 1,\n    (p[1] == NOTACHAR) ? (utf ? 0x10ffffu : 0xffffffffu) : p[1] - 1);\n  p++;\n  }\nreturn n8;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function scans through a branch of a compiled pattern to see whether it\ncan match the empty string or not. It is called from could_be_empty()\nbelow and from compile_branch() when checking for an unlimited repeat of a\ngroup that can match nothing. Note that first_significant_code() skips over\nbackward and negative forward assertions when its final argument is TRUE. If we\nhit an unclosed bracket, we return \"empty\" - this means we've struck an inner\nbracket whose current branch will already have been scanned.\n\nArguments:\n  code        points to start of search\n  endcode     points to where to stop\n  utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode\n  cd          contains pointers to tables etc.\n  recurses    chain of recurse_check to catch mutual recursion\n\nReturns:      TRUE if what is matched could be empty\n*/\n", "func_signal": "static BOOL\ncould_be_empty_branch(const pcre_uchar *code, const pcre_uchar *endcode,\n  BOOL utf, compile_data *cd, recurse_check *recurses)", "code": "{\nregister pcre_uchar c;\nrecurse_check this_recurse;\n\nfor (code = first_significant_code(code + PRIV(OP_lengths)[*code], TRUE);\n     code < endcode;\n     code = first_significant_code(code + PRIV(OP_lengths)[c], TRUE))\n  {\n  const pcre_uchar *ccode;\n\n  c = *code;\n\n  /* Skip over forward assertions; the other assertions are skipped by\n  first_significant_code() with a TRUE final argument. */\n\n  if (c == OP_ASSERT)\n    {\n    do code += GET(code, 1); while (*code == OP_ALT);\n    c = *code;\n    continue;\n    }\n\n  /* For a recursion/subroutine call, if its end has been reached, which\n  implies a backward reference subroutine call, we can scan it. If it's a\n  forward reference subroutine call, we can't. To detect forward reference\n  we have to scan up the list that is kept in the workspace. This function is\n  called only when doing the real compile, not during the pre-compile that\n  measures the size of the compiled pattern. */\n\n  if (c == OP_RECURSE)\n    {\n    const pcre_uchar *scode = cd->start_code + GET(code, 1);\n    const pcre_uchar *endgroup = scode;\n    BOOL empty_branch;\n\n    /* Test for forward reference or uncompleted reference. This is disabled\n    when called to scan a completed pattern by setting cd->start_workspace to\n    NULL. */\n\n    if (cd->start_workspace != NULL)\n      {\n      const pcre_uchar *tcode;\n      for (tcode = cd->start_workspace; tcode < cd->hwm; tcode += LINK_SIZE)\n        if ((int)GET(tcode, 0) == (int)(code + 1 - cd->start_code)) return TRUE;\n      if (GET(scode, 1) == 0) return TRUE;    /* Unclosed */\n      }\n\n    /* If the reference is to a completed group, we need to detect whether this\n    is a recursive call, as otherwise there will be an infinite loop. If it is\n    a recursion, just skip over it. Simple recursions are easily detected. For\n    mutual recursions we keep a chain on the stack. */\n\n    do endgroup += GET(endgroup, 1); while (*endgroup == OP_ALT);\n    if (code >= scode && code <= endgroup) continue;  /* Simple recursion */\n    else\n      {\n      recurse_check *r = recurses;\n      for (r = recurses; r != NULL; r = r->prev)\n        if (r->group == scode) break;\n      if (r != NULL) continue;   /* Mutual recursion */\n      }\n\n    /* Completed reference; scan the referenced group, remembering it on the\n    stack chain to detect mutual recursions. */\n\n    empty_branch = FALSE;\n    this_recurse.prev = recurses;\n    this_recurse.group = scode;\n\n    do\n      {\n      if (could_be_empty_branch(scode, endcode, utf, cd, &this_recurse))\n        {\n        empty_branch = TRUE;\n        break;\n        }\n      scode += GET(scode, 1);\n      }\n    while (*scode == OP_ALT);\n\n    if (!empty_branch) return FALSE;  /* All branches are non-empty */\n    continue;\n    }\n\n  /* Groups with zero repeats can of course be empty; skip them. */\n\n  if (c == OP_BRAZERO || c == OP_BRAMINZERO || c == OP_SKIPZERO ||\n      c == OP_BRAPOSZERO)\n    {\n    code += PRIV(OP_lengths)[c];\n    do code += GET(code, 1); while (*code == OP_ALT);\n    c = *code;\n    continue;\n    }\n\n  /* A nested group that is already marked as \"could be empty\" can just be\n  skipped. */\n\n  if (c == OP_SBRA  || c == OP_SBRAPOS ||\n      c == OP_SCBRA || c == OP_SCBRAPOS)\n    {\n    do code += GET(code, 1); while (*code == OP_ALT);\n    c = *code;\n    continue;\n    }\n\n  /* For other groups, scan the branches. */\n\n  if (c == OP_BRA  || c == OP_BRAPOS ||\n      c == OP_CBRA || c == OP_CBRAPOS ||\n      c == OP_ONCE || c == OP_ONCE_NC ||\n      c == OP_COND || c == OP_SCOND)\n    {\n    BOOL empty_branch;\n    if (GET(code, 1) == 0) return TRUE;    /* Hit unclosed bracket */\n\n    /* If a conditional group has only one branch, there is a second, implied,\n    empty branch, so just skip over the conditional, because it could be empty.\n    Otherwise, scan the individual branches of the group. */\n\n    if (c == OP_COND && code[GET(code, 1)] != OP_ALT)\n      code += GET(code, 1);\n    else\n      {\n      empty_branch = FALSE;\n      do\n        {\n        if (!empty_branch && could_be_empty_branch(code, endcode, utf, cd,\n          recurses)) empty_branch = TRUE;\n        code += GET(code, 1);\n        }\n      while (*code == OP_ALT);\n      if (!empty_branch) return FALSE;   /* All branches are non-empty */\n      }\n\n    c = *code;\n    continue;\n    }\n\n  /* Handle the other opcodes */\n\n  switch (c)\n    {\n    /* Check for quantifiers after a class. XCLASS is used for classes that\n    cannot be represented just by a bit map. This includes negated single\n    high-valued characters. The length in PRIV(OP_lengths)[] is zero; the\n    actual length is stored in the compiled code, so we must update \"code\"\n    here. */\n\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n    case OP_XCLASS:\n    ccode = code += GET(code, 1);\n    goto CHECK_CLASS_REPEAT;\n#endif\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    ccode = code + PRIV(OP_lengths)[OP_CLASS];\n\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n    CHECK_CLASS_REPEAT:\n#endif\n\n    switch (*ccode)\n      {\n      case OP_CRSTAR:            /* These could be empty; continue */\n      case OP_CRMINSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSSTAR:\n      case OP_CRPOSQUERY:\n      break;\n\n      default:                   /* Non-repeat => class must match */\n      case OP_CRPLUS:            /* These repeats aren't empty */\n      case OP_CRMINPLUS:\n      case OP_CRPOSPLUS:\n      return FALSE;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      if (GET2(ccode, 1) > 0) return FALSE;  /* Minimum > 0 */\n      break;\n      }\n    break;\n\n    /* Opcodes that must match a character */\n\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n\n    case OP_PROP:\n    case OP_NOTPROP:\n    case OP_ANYNL:\n\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n\n    case OP_PLUS:\n    case OP_PLUSI:\n    case OP_MINPLUS:\n    case OP_MINPLUSI:\n\n    case OP_NOTPLUS:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUS:\n    case OP_NOTMINPLUSI:\n\n    case OP_POSPLUS:\n    case OP_POSPLUSI:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSPLUSI:\n\n    case OP_EXACT:\n    case OP_EXACTI:\n    case OP_NOTEXACT:\n    case OP_NOTEXACTI:\n\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEEXACT:\n\n    return FALSE;\n\n    /* These are going to continue, as they may be empty, but we have to\n    fudge the length for the \\p and \\P cases. */\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEPOSQUERY:\n    if (code[1] == OP_PROP || code[1] == OP_NOTPROP) code += 2;\n    break;\n\n    /* Same for these */\n\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEPOSUPTO:\n    if (code[1 + IMM2_SIZE] == OP_PROP || code[1 + IMM2_SIZE] == OP_NOTPROP)\n      code += 2;\n    break;\n\n    /* End of branch */\n\n    case OP_KET:\n    case OP_KETRMAX:\n    case OP_KETRMIN:\n    case OP_KETRPOS:\n    case OP_ALT:\n    return TRUE;\n\n    /* In UTF-8 mode, STAR, MINSTAR, POSSTAR, QUERY, MINQUERY, POSQUERY, UPTO,\n    MINUPTO, and POSUPTO and their caseless and negative versions may be\n    followed by a multibyte character. */\n\n#if defined SUPPORT_UTF && !defined COMPILE_PCRE32\n    case OP_STAR:\n    case OP_STARI:\n    case OP_NOTSTAR:\n    case OP_NOTSTARI:\n\n    case OP_MINSTAR:\n    case OP_MINSTARI:\n    case OP_NOTMINSTAR:\n    case OP_NOTMINSTARI:\n\n    case OP_POSSTAR:\n    case OP_POSSTARI:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSSTARI:\n\n    case OP_QUERY:\n    case OP_QUERYI:\n    case OP_NOTQUERY:\n    case OP_NOTQUERYI:\n\n    case OP_MINQUERY:\n    case OP_MINQUERYI:\n    case OP_NOTMINQUERY:\n    case OP_NOTMINQUERYI:\n\n    case OP_POSQUERY:\n    case OP_POSQUERYI:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSQUERYI:\n\n    if (utf && HAS_EXTRALEN(code[1])) code += GET_EXTRALEN(code[1]);\n    break;\n\n    case OP_UPTO:\n    case OP_UPTOI:\n    case OP_NOTUPTO:\n    case OP_NOTUPTOI:\n\n    case OP_MINUPTO:\n    case OP_MINUPTOI:\n    case OP_NOTMINUPTO:\n    case OP_NOTMINUPTOI:\n\n    case OP_POSUPTO:\n    case OP_POSUPTOI:\n    case OP_NOTPOSUPTO:\n    case OP_NOTPOSUPTOI:\n\n    if (utf && HAS_EXTRALEN(code[1 + IMM2_SIZE])) code += GET_EXTRALEN(code[1 + IMM2_SIZE]);\n    break;\n#endif\n\n    /* MARK, and PRUNE/SKIP/THEN with an argument must skip over the argument\n    string. */\n\n    case OP_MARK:\n    case OP_PRUNE_ARG:\n    case OP_SKIP_ARG:\n    case OP_THEN_ARG:\n    code += code[1];\n    break;\n\n    /* None of the remaining opcodes are required to match a character. */\n\n    default:\n    break;\n    }\n  }\n\nreturn TRUE;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function is called to match a character against an extended class that\nmight contain values > 255 and/or Unicode properties.\n\nArguments:\n  c           the character\n  data        points to the flag byte of the XCLASS data\n\nReturns:      TRUE if character matches, else FALSE\n*/\n", "func_signal": "BOOL\nPRIV(xclass)(pcre_uint32 c, const pcre_uchar *data, BOOL utf)", "code": "{\npcre_uchar t;\nBOOL negated = (*data & XCL_NOT) != 0;\n\n(void)utf;\n#ifdef COMPILE_PCRE8\n/* In 8 bit mode, this must always be TRUE. Help the compiler to know that. */\nutf = TRUE;\n#endif\n\n/* Character values < 256 are matched against a bitmap, if one is present. If\nnot, we still carry on, because there may be ranges that start below 256 in the\nadditional data. */\n\nif (c < 256)\n  {\n  if ((*data & XCL_HASPROP) == 0)\n    {\n    if ((*data & XCL_MAP) == 0) return negated;\n    return (((pcre_uint8 *)(data + 1))[c/8] & (1 << (c&7))) != 0;\n    }\n  if ((*data & XCL_MAP) != 0 &&\n    (((pcre_uint8 *)(data + 1))[c/8] & (1 << (c&7))) != 0)\n    return !negated; /* char found */\n  }\n\n/* First skip the bit map if present. Then match against the list of Unicode\nproperties or large chars or ranges that end with a large char. We won't ever\nencounter XCL_PROP or XCL_NOTPROP when UCP support is not compiled. */\n\nif ((*data++ & XCL_MAP) != 0) data += 32 / sizeof(pcre_uchar);\n\nwhile ((t = *data++) != XCL_END)\n  {\n  pcre_uint32 x, y;\n  if (t == XCL_SINGLE)\n    {\n#ifdef SUPPORT_UTF\n    if (utf)\n      {\n      GETCHARINC(x, data); /* macro generates multiple statements */\n      }\n    else\n#endif\n      x = *data++;\n    if (c == x) return !negated;\n    }\n  else if (t == XCL_RANGE)\n    {\n#ifdef SUPPORT_UTF\n    if (utf)\n      {\n      GETCHARINC(x, data); /* macro generates multiple statements */\n      GETCHARINC(y, data); /* macro generates multiple statements */\n      }\n    else\n#endif\n      {\n      x = *data++;\n      y = *data++;\n      }\n    if (c >= x && c <= y) return !negated;\n    }\n\n#ifdef SUPPORT_UCP\n  else  /* XCL_PROP & XCL_NOTPROP */\n    {\n    const ucd_record *prop = GET_UCD(c);\n    BOOL isprop = t == XCL_PROP;\n\n    switch(*data)\n      {\n      case PT_ANY:\n      if (isprop) return !negated;\n      break;\n\n      case PT_LAMP:\n      if ((prop->chartype == ucp_Lu || prop->chartype == ucp_Ll ||\n           prop->chartype == ucp_Lt) == isprop) return !negated;\n      break;\n\n      case PT_GC:\n      if ((data[1] == PRIV(ucp_gentype)[prop->chartype]) == isprop)\n        return !negated;\n      break;\n\n      case PT_PC:\n      if ((data[1] == prop->chartype) == isprop) return !negated;\n      break;\n\n      case PT_SC:\n      if ((data[1] == prop->script) == isprop) return !negated;\n      break;\n\n      case PT_ALNUM:\n      if ((PRIV(ucp_gentype)[prop->chartype] == ucp_L ||\n           PRIV(ucp_gentype)[prop->chartype] == ucp_N) == isprop)\n        return !negated;\n      break;\n\n      /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n      which means that Perl space and POSIX space are now identical. PCRE\n      was changed at release 8.34. */\n\n      case PT_SPACE:    /* Perl space */\n      case PT_PXSPACE:  /* POSIX space */\n      switch(c)\n        {\n        HSPACE_CASES:\n        VSPACE_CASES:\n        if (isprop) return !negated;\n        break;\n\n        default:\n        if ((PRIV(ucp_gentype)[prop->chartype] == ucp_Z) == isprop)\n          return !negated;\n        break;\n        }\n      break;\n\n      case PT_WORD:\n      if ((PRIV(ucp_gentype)[prop->chartype] == ucp_L ||\n           PRIV(ucp_gentype)[prop->chartype] == ucp_N || c == CHAR_UNDERSCORE)\n             == isprop)\n        return !negated;\n      break;\n\n      case PT_UCNC:\n      if (c < 0xa0)\n        {\n        if ((c == CHAR_DOLLAR_SIGN || c == CHAR_COMMERCIAL_AT ||\n             c == CHAR_GRAVE_ACCENT) == isprop)\n          return !negated;\n        }\n      else\n        {\n        if ((c < 0xd800 || c > 0xdfff) == isprop)\n          return !negated;\n        }\n      break;\n\n      /* The following three properties can occur only in an XCLASS, as there\n      is no \\p or \\P coding for them. */\n\n      /* Graphic character. Implement this as not Z (space or separator) and\n      not C (other), except for Cf (format) with a few exceptions. This seems\n      to be what Perl does. The exceptional characters are:\n\n      U+061C           Arabic Letter Mark\n      U+180E           Mongolian Vowel Separator\n      U+2066 - U+2069  Various \"isolate\"s\n      */\n\n      case PT_PXGRAPH:\n      if ((PRIV(ucp_gentype)[prop->chartype] != ucp_Z &&\n            (PRIV(ucp_gentype)[prop->chartype] != ucp_C ||\n              (prop->chartype == ucp_Cf &&\n                c != 0x061c && c != 0x180e && (c < 0x2066 || c > 0x2069))\n         )) == isprop)\n        return !negated;\n      break;\n\n      /* Printable character: same as graphic, with the addition of Zs, i.e.\n      not Zl and not Zp, and U+180E. */\n\n      case PT_PXPRINT:\n      if ((prop->chartype != ucp_Zl &&\n           prop->chartype != ucp_Zp &&\n            (PRIV(ucp_gentype)[prop->chartype] != ucp_C ||\n              (prop->chartype == ucp_Cf &&\n                c != 0x061c && (c < 0x2066 || c > 0x2069))\n         )) == isprop)\n        return !negated;\n      break;\n\n      /* Punctuation: all Unicode punctuation, plus ASCII characters that\n      Unicode treats as symbols rather than punctuation, for Perl\n      compatibility (these are $+<=>^`|~). */\n\n      case PT_PXPUNCT:\n      if ((PRIV(ucp_gentype)[prop->chartype] == ucp_P ||\n            (c < 128 && PRIV(ucp_gentype)[prop->chartype] == ucp_S)) == isprop)\n        return !negated;\n      break;\n\n      /* This should never occur, but compilers may mutter if there is no\n      default. */\n\n      default:\n      return FALSE;\n      }\n\n    data += 2;\n    }\n#endif  /* SUPPORT_UCP */\n  }\n\nreturn negated;   /* char did not match */\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_xclass.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function is called during the second compiling phase, if the number of\nforward references fills the existing workspace, which is originally a block on\nthe stack. A larger block is obtained from malloc() unless the ultimate limit\nhas been reached or the increase will be rather small.\n\nArgument: pointer to the compile data block\nReturns:  0 if all went well, else an error number\n*/\n", "func_signal": "static int\nexpand_workspace(compile_data *cd)", "code": "{\npcre_uchar *newspace;\nint newsize = cd->workspace_size * 2;\n\nif (newsize > COMPILE_WORK_SIZE_MAX) newsize = COMPILE_WORK_SIZE_MAX;\nif (cd->workspace_size >= COMPILE_WORK_SIZE_MAX ||\n    newsize - cd->workspace_size < WORK_SIZE_SAFETY_MARGIN)\n return ERR72;\n\nnewspace = (PUBL(malloc))(IN_UCHARS(newsize));\nif (newspace == NULL) return ERR21;\nmemcpy(newspace, cd->start_workspace, cd->workspace_size * sizeof(pcre_uchar));\ncd->hwm = (pcre_uchar *)newspace + (cd->hwm - cd->start_workspace);\nif (cd->workspace_size > COMPILE_WORK_SIZE)\n  (PUBL(free))((void *)cd->start_workspace);\ncd->start_workspace = newspace;\ncd->workspace_size = newsize;\nreturn 0;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* Checks whether the code points to an opcode that can take part in auto-\npossessification, and if so, fills a list with its properties.\n\nArguments:\n  code        points to start of expression\n  utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode\n  fcc         points to case-flipping table\n  list        points to output list\n              list[0] will be filled with the opcode\n              list[1] will be non-zero if this opcode\n                can match an empty character string\n              list[2..7] depends on the opcode\n\nReturns:      points to the start of the next opcode if *code is accepted\n              NULL if *code is not accepted\n*/\n", "func_signal": "static const pcre_uchar *\nget_chr_property_list(const pcre_uchar *code, BOOL utf,\n  const pcre_uint8 *fcc, pcre_uint32 *list)", "code": "{\npcre_uchar c = *code;\npcre_uchar base;\nconst pcre_uchar *end;\npcre_uint32 chr;\n\n#ifdef SUPPORT_UCP\npcre_uint32 *clist_dest;\nconst pcre_uint32 *clist_src;\n#else\nutf = utf;  /* Suppress \"unused parameter\" compiler warning */\n#endif\n\nlist[0] = c;\nlist[1] = FALSE;\ncode++;\n\nif (c >= OP_STAR && c <= OP_TYPEPOSUPTO)\n  {\n  base = get_repeat_base(c);\n  c -= (base - OP_STAR);\n\n  if (c == OP_UPTO || c == OP_MINUPTO || c == OP_EXACT || c == OP_POSUPTO)\n    code += IMM2_SIZE;\n\n  list[1] = (c != OP_PLUS && c != OP_MINPLUS && c != OP_EXACT && c != OP_POSPLUS);\n\n  switch(base)\n    {\n    case OP_STAR:\n    list[0] = OP_CHAR;\n    break;\n\n    case OP_STARI:\n    list[0] = OP_CHARI;\n    break;\n\n    case OP_NOTSTAR:\n    list[0] = OP_NOT;\n    break;\n\n    case OP_NOTSTARI:\n    list[0] = OP_NOTI;\n    break;\n\n    case OP_TYPESTAR:\n    list[0] = *code;\n    code++;\n    break;\n    }\n  c = list[0];\n  }\n\nswitch(c)\n  {\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  case OP_ANY:\n  case OP_ALLANY:\n  case OP_ANYNL:\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  case OP_EXTUNI:\n  case OP_EODN:\n  case OP_EOD:\n  case OP_DOLL:\n  case OP_DOLLM:\n  return code;\n\n  case OP_CHAR:\n  case OP_NOT:\n  GETCHARINCTEST(chr, code);\n  list[2] = chr;\n  list[3] = NOTACHAR;\n  return code;\n\n  case OP_CHARI:\n  case OP_NOTI:\n  list[0] = (c == OP_CHARI) ? OP_CHAR : OP_NOT;\n  GETCHARINCTEST(chr, code);\n  list[2] = chr;\n\n#ifdef SUPPORT_UCP\n  if (chr < 128 || (chr < 256 && !utf))\n    list[3] = fcc[chr];\n  else\n    list[3] = UCD_OTHERCASE(chr);\n#elif defined SUPPORT_UTF || !defined COMPILE_PCRE8\n  list[3] = (chr < 256) ? fcc[chr] : chr;\n#else\n  list[3] = fcc[chr];\n#endif\n\n  /* The othercase might be the same value. */\n\n  if (chr == list[3])\n    list[3] = NOTACHAR;\n  else\n    list[4] = NOTACHAR;\n  return code;\n\n#ifdef SUPPORT_UCP\n  case OP_PROP:\n  case OP_NOTPROP:\n  if (code[0] != PT_CLIST)\n    {\n    list[2] = code[0];\n    list[3] = code[1];\n    return code + 2;\n    }\n\n  /* Convert only if we have enough space. */\n\n  clist_src = PRIV(ucd_caseless_sets) + code[1];\n  clist_dest = list + 2;\n  code += 2;\n\n  do {\n     if (clist_dest >= list + 8)\n       {\n       /* Early return if there is not enough space. This should never\n       happen, since all clists are shorter than 5 character now. */\n       list[2] = code[0];\n       list[3] = code[1];\n       return code;\n       }\n     *clist_dest++ = *clist_src;\n     }\n  while(*clist_src++ != NOTACHAR);\n\n  /* All characters are stored. The terminating NOTACHAR\n  is copied form the clist itself. */\n\n  list[0] = (c == OP_PROP) ? OP_CHAR : OP_NOT;\n  return code;\n#endif\n\n  case OP_NCLASS:\n  case OP_CLASS:\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n  case OP_XCLASS:\n  if (c == OP_XCLASS)\n    end = code + GET(code, 0) - 1;\n  else\n#endif\n    end = code + 32 / sizeof(pcre_uchar);\n\n  switch(*end)\n    {\n    case OP_CRSTAR:\n    case OP_CRMINSTAR:\n    case OP_CRQUERY:\n    case OP_CRMINQUERY:\n    case OP_CRPOSSTAR:\n    case OP_CRPOSQUERY:\n    list[1] = TRUE;\n    end++;\n    break;\n\n    case OP_CRPLUS:\n    case OP_CRMINPLUS:\n    case OP_CRPOSPLUS:\n    end++;\n    break;\n\n    case OP_CRRANGE:\n    case OP_CRMINRANGE:\n    case OP_CRPOSRANGE:\n    list[1] = (GET2(end, 1) == 0);\n    end += 1 + 2 * IMM2_SIZE;\n    break;\n    }\n  list[2] = (pcre_uint32)(end - code);\n  return end;\n  }\nreturn NULL;    /* Opcode not accepted */\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* Returns the base opcode for repeated single character type opcodes. If the\nopcode is not a repeated character type, it returns with the original value.\n\nArguments:  c opcode\nReturns:    base opcode for the type\n*/\n", "func_signal": "static pcre_uchar\nget_repeat_base(pcre_uchar c)", "code": "{\nreturn (c > OP_TYPEPOSUPTO)? c :\n       (c >= OP_TYPESTAR)?   OP_TYPESTAR :\n       (c >= OP_NOTSTARI)?   OP_NOTSTARI :\n       (c >= OP_NOTSTAR)?    OP_NOTSTAR :\n       (c >= OP_STARI)?      OP_STARI :\n                             OP_STAR;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function is called between compiling passes to add an entry to the\nname/number table, maintaining alphabetical order. Checking for permitted\nand forbidden duplicates has already been done.\n\nArguments:\n  cd           the compile data block\n  name         the name to add\n  length       the length of the name\n  groupno      the group number\n\nReturns:       nothing\n*/\n", "func_signal": "static void\nadd_name(compile_data *cd, const pcre_uchar *name, int length,\n  unsigned int groupno)", "code": "{\nint i;\npcre_uchar *slot = cd->name_table;\n\nfor (i = 0; i < cd->names_found; i++)\n  {\n  int crc = memcmp(name, slot+IMM2_SIZE, IN_UCHARS(length));\n  if (crc == 0 && slot[IMM2_SIZE+length] != 0)\n    crc = -1; /* Current name is a substring */\n\n  /* Make space in the table and break the loop for an earlier name. For a\n  duplicate or later name, carry on. We do this for duplicates so that in the\n  simple case (when ?(| is not used) they are in order of their numbers. In all\n  cases they are in the order in which they appear in the pattern. */\n\n  if (crc < 0)\n    {\n    memmove(slot + cd->name_entry_size, slot,\n      IN_UCHARS((cd->names_found - i) * cd->name_entry_size));\n    break;\n    }\n\n  /* Continue the loop for a later or duplicate name */\n\n  slot += cd->name_entry_size;\n  }\n\nPUT2(slot, 0, groupno);\nmemcpy(slot + IMM2_SIZE, name, IN_UCHARS(length));\nslot[IMM2_SIZE + length] = 0;\ncd->names_found++;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This function is called after \\P or \\p has been encountered, provided that\nPCRE is compiled with support for Unicode properties. On entry, ptrptr is\npointing at the P or p. On exit, it is pointing at the final character of the\nescape sequence.\n\nArgument:\n  ptrptr         points to the pattern position pointer\n  negptr         points to a boolean that is set TRUE for negation else FALSE\n  ptypeptr       points to an unsigned int that is set to the type value\n  pdataptr       points to an unsigned int that is set to the detailed property value\n  errorcodeptr   points to the error code variable\n\nReturns:         TRUE if the type value was found, or FALSE for an invalid type\n*/\n", "func_signal": "static BOOL\nget_ucp(const pcre_uchar **ptrptr, BOOL *negptr, unsigned int *ptypeptr,\n  unsigned int *pdataptr, int *errorcodeptr)", "code": "{\npcre_uchar c;\nint i, bot, top;\nconst pcre_uchar *ptr = *ptrptr;\npcre_uchar name[32];\n\nc = *(++ptr);\nif (c == CHAR_NULL) goto ERROR_RETURN;\n\n*negptr = FALSE;\n\n/* \\P or \\p can be followed by a name in {}, optionally preceded by ^ for\nnegation. */\n\nif (c == CHAR_LEFT_CURLY_BRACKET)\n  {\n  if (ptr[1] == CHAR_CIRCUMFLEX_ACCENT)\n    {\n    *negptr = TRUE;\n    ptr++;\n    }\n  for (i = 0; i < (int)(sizeof(name) / sizeof(pcre_uchar)) - 1; i++)\n    {\n    c = *(++ptr);\n    if (c == CHAR_NULL) goto ERROR_RETURN;\n    if (c == CHAR_RIGHT_CURLY_BRACKET) break;\n    name[i] = c;\n    }\n  if (c != CHAR_RIGHT_CURLY_BRACKET) goto ERROR_RETURN;\n  name[i] = 0;\n  }\n\n/* Otherwise there is just one following character */\n\nelse\n  {\n  name[0] = c;\n  name[1] = 0;\n  }\n\n*ptrptr = ptr;\n\n/* Search for a recognized property name using binary chop */\n\nbot = 0;\ntop = PRIV(utt_size);\n\nwhile (bot < top)\n  {\n  int r;\n  i = (bot + top) >> 1;\n  r = STRCMP_UC_C8(name, PRIV(utt_names) + PRIV(utt)[i].name_offset);\n  if (r == 0)\n    {\n    *ptypeptr = PRIV(utt)[i].type;\n    *pdataptr = PRIV(utt)[i].value;\n    return TRUE;\n    }\n  if (r > 0) bot = i + 1; else top = i;\n  }\n\n*errorcodeptr = ERR47;\n*ptrptr = ptr;\nreturn FALSE;\n\nERROR_RETURN:\n*errorcodeptr = ERR46;\n*ptrptr = ptr;\nreturn FALSE;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* This little function scans through a compiled pattern until it finds a\ncapturing bracket with the given number, or, if the number is negative, an\ninstance of OP_REVERSE for a lookbehind. The function is global in the C sense\nso that it can be called from pcre_study() when finding the minimum matching\nlength.\n\nArguments:\n  code        points to start of expression\n  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode\n  number      the required bracket number or negative to find a lookbehind\n\nReturns:      pointer to the opcode for the bracket, or NULL if not found\n*/\n", "func_signal": "const pcre_uchar *\nPRIV(find_bracket)(const pcre_uchar *code, BOOL utf, int number)", "code": "{\nfor (;;)\n  {\n  register pcre_uchar c = *code;\n\n  if (c == OP_END) return NULL;\n\n  /* XCLASS is used for classes that cannot be represented just by a bit\n  map. This includes negated single high-valued characters. The length in\n  the table is zero; the actual length is stored in the compiled code. */\n\n  if (c == OP_XCLASS) code += GET(code, 1);\n\n  /* Handle recursion */\n\n  else if (c == OP_REVERSE)\n    {\n    if (number < 0) return (pcre_uchar *)code;\n    code += PRIV(OP_lengths)[c];\n    }\n\n  /* Handle capturing bracket */\n\n  else if (c == OP_CBRA || c == OP_SCBRA ||\n           c == OP_CBRAPOS || c == OP_SCBRAPOS)\n    {\n    int n = (int)GET2(code, 1+LINK_SIZE);\n    if (n == number) return (pcre_uchar *)code;\n    code += PRIV(OP_lengths)[c];\n    }\n\n  /* Otherwise, we can get the item's length from the table, except that for\n  repeated character types, we have to test for \\p and \\P, which have an extra\n  two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we\n  must add in its length. */\n\n  else\n    {\n    switch(c)\n      {\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      case OP_TYPEPOSQUERY:\n      if (code[1] == OP_PROP || code[1] == OP_NOTPROP) code += 2;\n      break;\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      case OP_TYPEPOSUPTO:\n      if (code[1 + IMM2_SIZE] == OP_PROP || code[1 + IMM2_SIZE] == OP_NOTPROP)\n        code += 2;\n      break;\n\n      case OP_MARK:\n      case OP_PRUNE_ARG:\n      case OP_SKIP_ARG:\n      case OP_THEN_ARG:\n      code += code[1];\n      break;\n      }\n\n    /* Add in the fixed length from the table */\n\n    code += PRIV(OP_lengths)[c];\n\n  /* In UTF-8 mode, opcodes that are followed by a character may be followed by\n  a multi-byte character. The length in the table is a minimum, so we have to\n  arrange to skip the extra bytes. */\n\n#if defined SUPPORT_UTF && !defined COMPILE_PCRE32\n    if (utf) switch(c)\n      {\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      case OP_EXACT:\n      case OP_EXACTI:\n      case OP_NOTEXACT:\n      case OP_NOTEXACTI:\n      case OP_UPTO:\n      case OP_UPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTUPTOI:\n      case OP_MINUPTO:\n      case OP_MINUPTOI:\n      case OP_NOTMINUPTO:\n      case OP_NOTMINUPTOI:\n      case OP_POSUPTO:\n      case OP_POSUPTOI:\n      case OP_NOTPOSUPTO:\n      case OP_NOTPOSUPTOI:\n      case OP_STAR:\n      case OP_STARI:\n      case OP_NOTSTAR:\n      case OP_NOTSTARI:\n      case OP_MINSTAR:\n      case OP_MINSTARI:\n      case OP_NOTMINSTAR:\n      case OP_NOTMINSTARI:\n      case OP_POSSTAR:\n      case OP_POSSTARI:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSSTARI:\n      case OP_PLUS:\n      case OP_PLUSI:\n      case OP_NOTPLUS:\n      case OP_NOTPLUSI:\n      case OP_MINPLUS:\n      case OP_MINPLUSI:\n      case OP_NOTMINPLUS:\n      case OP_NOTMINPLUSI:\n      case OP_POSPLUS:\n      case OP_POSPLUSI:\n      case OP_NOTPOSPLUS:\n      case OP_NOTPOSPLUSI:\n      case OP_QUERY:\n      case OP_QUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTQUERYI:\n      case OP_MINQUERY:\n      case OP_MINQUERYI:\n      case OP_NOTMINQUERY:\n      case OP_NOTMINQUERYI:\n      case OP_POSQUERY:\n      case OP_POSQUERYI:\n      case OP_NOTPOSQUERY:\n      case OP_NOTPOSQUERYI:\n      if (HAS_EXTRALEN(code[-1])) code += GET_EXTRALEN(code[-1]);\n      break;\n      }\n#else\n    (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif\n    }\n  }\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* A callout item contains the length of the next item in the pattern, which\nwe can't fill in till after we have reached the relevant point. This is used\nfor both automatic and manual callouts.\n\nArguments:\n  previous_callout   points to previous callout item\n  ptr                current pattern pointer\n  cd                 pointers to tables etc\n\nReturns:             nothing\n*/\n", "func_signal": "static void\ncomplete_callout(pcre_uchar *previous_callout, const pcre_uchar *ptr, compile_data *cd)", "code": "{\nint length = (int)(ptr - cd->start_pattern - GET(previous_callout, 2));\nPUT(previous_callout, 2 + LINK_SIZE, length);\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* The error texts are now all in one long string, to save on relocations. As\nsome of the text is of unknown length, we can't use a table of offsets.\nInstead, just count through the strings. This is not a performance issue\nbecause it happens only when there has been a compilation error.\n\nArgument:   the error number\nReturns:    pointer to the error string\n*/\n", "func_signal": "static const char *\nfind_error_text(int n)", "code": "{\nconst char *s = error_texts;\nfor (; n > 0; n--)\n  {\n  while (*s++ != CHAR_NULL) {};\n  if (*s == CHAR_NULL) return \"Error text not found (please report)\";\n  }\nreturn s;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* During compilation, the \"first char\" settings from forward assertions are\ndiscarded, because they can cause conflicts with actual literals that follow.\nHowever, if we end up without a first char setting for an unanchored pattern,\nit is worth scanning the regex to see if there is an initial asserted first\nchar. If all branches start with the same asserted char, or with a\nnon-conditional bracket all of whose alternatives start with the same asserted\nchar (recurse ad lib), then we return that char, with the flags set to zero or\nREQ_CASELESS; otherwise return zero with REQ_NONE in the flags.\n\nArguments:\n  code       points to start of expression (the bracket)\n  flags      points to the first char flags, or to REQ_NONE\n  inassert   TRUE if in an assertion\n\nReturns:     the fixed first char, or 0 with REQ_NONE in flags\n*/\n", "func_signal": "static pcre_uint32\nfind_firstassertedchar(const pcre_uchar *code, pcre_int32 *flags,\n  BOOL inassert)", "code": "{\nregister pcre_uint32 c = 0;\nint cflags = REQ_NONE;\n\n*flags = REQ_NONE;\ndo {\n   pcre_uint32 d;\n   int dflags;\n   int xl = (*code == OP_CBRA || *code == OP_SCBRA ||\n             *code == OP_CBRAPOS || *code == OP_SCBRAPOS)? IMM2_SIZE:0;\n   const pcre_uchar *scode = first_significant_code(code + 1+LINK_SIZE + xl,\n     TRUE);\n   register pcre_uchar op = *scode;\n\n   switch(op)\n     {\n     default:\n     return 0;\n\n     case OP_BRA:\n     case OP_BRAPOS:\n     case OP_CBRA:\n     case OP_SCBRA:\n     case OP_CBRAPOS:\n     case OP_SCBRAPOS:\n     case OP_ASSERT:\n     case OP_ONCE:\n     case OP_ONCE_NC:\n     d = find_firstassertedchar(scode, &dflags, op == OP_ASSERT);\n     if (dflags < 0)\n       return 0;\n     if (cflags < 0) { c = d; cflags = dflags; } else if (c != d || cflags != dflags) return 0;\n     break;\n\n     case OP_EXACT:\n     scode += IMM2_SIZE;\n     /* Fall through */\n\n     case OP_CHAR:\n     case OP_PLUS:\n     case OP_MINPLUS:\n     case OP_POSPLUS:\n     if (!inassert) return 0;\n     if (cflags < 0) { c = scode[1]; cflags = 0; }\n       else if (c != scode[1]) return 0;\n     break;\n\n     case OP_EXACTI:\n     scode += IMM2_SIZE;\n     /* Fall through */\n\n     case OP_CHARI:\n     case OP_PLUSI:\n     case OP_MINPLUSI:\n     case OP_POSPLUSI:\n     if (!inassert) return 0;\n     if (cflags < 0) { c = scode[1]; cflags = REQ_CASELESS; }\n       else if (c != scode[1]) return 0;\n     break;\n     }\n\n   code += GET(code, 1);\n   }\nwhile (*code == OP_ALT);\n\n*flags = cflags;\nreturn c;\n}", "path": "3proxy/src/plugins/PCREPlugin/pcre_compile.c", "commit_date": "2016-12-23 00:00:00", "repo_name": "3proxy/3proxy", "stars": 3470, "license": "other", "language": "c", "size": 2393}
{"docstring": "/* Free the history, but does not reset it. Only used when we have to\n * exit() to avoid memory leaks are reported by valgrind & co. */\n", "func_signal": "static void freeHistory(void)", "code": "{\n    if (history) {\n        int j;\n\n        for (j = 0; j < history_len; j++)\n            free(history[j]);\n        free(history);\n    }\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* This function is the core of the line editing capability of linenoise.\n * It expects 'fd' to be already in \"raw mode\" so that every key pressed\n * will be returned ASAP to read().\n *\n * The resulting string is put into 'buf' when the user type enter, or\n * when ctrl+d is typed.\n *\n * The function returns the length of the current buffer. */\n", "func_signal": "static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt)", "code": "{\n    struct linenoiseState l;\n\n    /* Populate the linenoise state that we pass to functions implementing\n     * specific editing functionalities. */\n    l.ifd = stdin_fd;\n    l.ofd = stdout_fd;\n    l.buf = buf;\n    l.buflen = buflen;\n    l.prompt = prompt;\n    l.plen = strlen(prompt);\n    l.oldpos = l.pos = 0;\n    l.len = 0;\n    l.cols = getColumns(stdin_fd, stdout_fd);\n    l.maxrows = 0;\n    l.history_index = 0;\n\n    /* Buffer starts empty. */\n    l.buf[0] = '\\0';\n    l.buflen--; /* Make sure there is always space for the nulterm */\n\n    /* The latest history entry is always our current buffer, that\n     * initially is just an empty string. */\n    linenoiseHistoryAdd(\"\");\n\n    if (write(l.ofd,prompt,l.plen) == -1) return -1;\n    while(1) {\n        char c;\n        int nread;\n        char seq[3];\n\n        nread = read(l.ifd,&c,1);\n        if (nread <= 0) return l.len;\n\n        /* Only autocomplete when the callback is set. It returns < 0 when\n         * there was an error reading from fd. Otherwise it will return the\n         * character that should be handled next. */\n        if (c == 9 && completionCallback != NULL) {\n            c = completeLine(&l);\n            /* Return on errors */\n            if (c < 0) return l.len;\n            /* Read next character when 0 */\n            if (c == 0) continue;\n        }\n\n        switch(c) {\n        case ENTER:    /* enter */\n            history_len--;\n            free(history[history_len]);\n            if (mlmode) linenoiseEditMoveEnd(&l);\n            if (hintsCallback) {\n                /* Force a refresh without hints to leave the previous\n                 * line as the user typed it after a newline. */\n                linenoiseHintsCallback *hc = hintsCallback;\n                hintsCallback = NULL;\n                refreshLine(&l);\n                hintsCallback = hc;\n            }\n            return (int)l.len;\n        case CTRL_C:     /* ctrl-c */\n            errno = EAGAIN;\n            return -1;\n        case BACKSPACE:   /* backspace */\n        case 8:     /* ctrl-h */\n            linenoiseEditBackspace(&l);\n            break;\n        case CTRL_D:     /* ctrl-d, remove char at right of cursor, or if the\n                            line is empty, act as end-of-file. */\n            if (l.len > 0) {\n                linenoiseEditDelete(&l);\n            } else {\n                history_len--;\n                free(history[history_len]);\n                return -1;\n            }\n            break;\n        case CTRL_T:    /* ctrl-t, swaps current character with previous. */\n            if (l.pos > 0 && l.pos < l.len) {\n                int aux = buf[l.pos-1];\n                buf[l.pos-1] = buf[l.pos];\n                buf[l.pos] = aux;\n                if (l.pos != l.len-1) l.pos++;\n                refreshLine(&l);\n            }\n            break;\n        case CTRL_B:     /* ctrl-b */\n            linenoiseEditMoveLeft(&l);\n            break;\n        case CTRL_F:     /* ctrl-f */\n            linenoiseEditMoveRight(&l);\n            break;\n        case CTRL_P:    /* ctrl-p */\n            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);\n            break;\n        case CTRL_N:    /* ctrl-n */\n            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);\n            break;\n        case ESC:    /* escape sequence */\n            /* Read the next two bytes representing the escape sequence.\n             * Use two calls to handle slow terminals returning the two\n             * chars at different times. */\n            if (read(l.ifd,seq,1) == -1) break;\n            if (read(l.ifd,seq+1,1) == -1) break;\n\n            /* ESC [ sequences. */\n            if (seq[0] == '[') {\n                if (seq[1] >= '0' && seq[1] <= '9') {\n                    /* Extended escape, read additional byte. */\n                    if (read(l.ifd,seq+2,1) == -1) break;\n                    if (seq[2] == '~') {\n                        switch(seq[1]) {\n                        case '3': /* Delete key. */\n                            linenoiseEditDelete(&l);\n                            break;\n                        }\n                    }\n                } else {\n                    switch(seq[1]) {\n                    case 'A': /* Up */\n                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);\n                        break;\n                    case 'B': /* Down */\n                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);\n                        break;\n                    case 'C': /* Right */\n                        linenoiseEditMoveRight(&l);\n                        break;\n                    case 'D': /* Left */\n                        linenoiseEditMoveLeft(&l);\n                        break;\n                    case 'H': /* Home */\n                        linenoiseEditMoveHome(&l);\n                        break;\n                    case 'F': /* End*/\n                        linenoiseEditMoveEnd(&l);\n                        break;\n                    }\n                }\n            }\n\n            /* ESC O sequences. */\n            else if (seq[0] == 'O') {\n                switch(seq[1]) {\n                case 'H': /* Home */\n                    linenoiseEditMoveHome(&l);\n                    break;\n                case 'F': /* End*/\n                    linenoiseEditMoveEnd(&l);\n                    break;\n                }\n            }\n            break;\n        default:\n            if (linenoiseEditInsert(&l,c)) return -1;\n            break;\n        case CTRL_U: /* Ctrl+u, delete the whole line. */\n            buf[0] = '\\0';\n            l.pos = l.len = 0;\n            refreshLine(&l);\n            break;\n        case CTRL_K: /* Ctrl+k, delete from current to end of line. */\n            buf[l.pos] = '\\0';\n            l.len = l.pos;\n            refreshLine(&l);\n            break;\n        case CTRL_A: /* Ctrl+a, go to the start of the line */\n            linenoiseEditMoveHome(&l);\n            break;\n        case CTRL_E: /* ctrl+e, go to the end of the line */\n            linenoiseEditMoveEnd(&l);\n            break;\n        case CTRL_L: /* ctrl+l, clear screen */\n            linenoiseClearScreen();\n            refreshLine(&l);\n            break;\n        case CTRL_W: /* ctrl+w, delete previous word */\n            linenoiseEditDeletePrevWord(&l);\n            break;\n        }\n    }\n    return l.len;\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* This special mode is used by linenoise in order to print scan codes\n * on screen for debugging / development purposes. It is implemented\n * by the linenoise_example program using the --keycodes option. */\n", "func_signal": "void linenoisePrintKeyCodes(void)", "code": "{\n    char quit[4];\n\n    printf(\"Linenoise key codes debugging mode.\\n\"\n            \"Press keys to see scan codes. Type 'quit' at any time to exit.\\n\");\n    if (enableRawMode(STDIN_FILENO) == -1) return;\n    memset(quit,' ',4);\n    while(1) {\n        char c;\n        int nread;\n\n        nread = read(STDIN_FILENO,&c,1);\n        if (nread <= 0) continue;\n        memmove(quit,quit+1,sizeof(quit)-1); /* shift string to left. */\n        quit[sizeof(quit)-1] = c; /* Insert current char on the right. */\n        if (memcmp(quit,\"quit\",sizeof(quit)) == 0) break;\n\n        printf(\"'%c' %02x (%d) (type quit to exit)\\n\",\n            isprint(c) ? c : '?', (int)c, (int)c);\n        printf(\"\\r\"); /* Go left edge manually, we are in raw mode. */\n        fflush(stdout);\n    }\n    disableRawMode(STDIN_FILENO);\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* This is an helper function for linenoiseEdit() and is called when the\n * user types the <tab> key in order to complete the string currently in the\n * input.\n *\n * The state of the editing is encapsulated into the pointed linenoiseState\n * structure as described in the structure definition. */\n", "func_signal": "static int completeLine(struct linenoiseState *ls)", "code": "{\n    linenoiseCompletions lc = { 0, NULL };\n    int nread, nwritten;\n    char c = 0;\n\n    completionCallback(ls->buf,&lc);\n    if (lc.len == 0) {\n        linenoiseBeep();\n    } else {\n        size_t stop = 0, i = 0;\n\n        while(!stop) {\n            /* Show completion or original buffer */\n            if (i < lc.len) {\n                struct linenoiseState saved = *ls;\n\n                ls->len = ls->pos = strlen(lc.cvec[i]);\n                ls->buf = lc.cvec[i];\n                refreshLine(ls);\n                ls->len = saved.len;\n                ls->pos = saved.pos;\n                ls->buf = saved.buf;\n            } else {\n                refreshLine(ls);\n            }\n\n            nread = read(ls->ifd,&c,1);\n            if (nread <= 0) {\n                freeCompletions(&lc);\n                return -1;\n            }\n\n            switch(c) {\n                case 9: /* tab */\n                    i = (i+1) % (lc.len+1);\n                    if (i == lc.len) linenoiseBeep();\n                    break;\n                case 27: /* escape */\n                    /* Re-show original buffer */\n                    if (i < lc.len) refreshLine(ls);\n                    stop = 1;\n                    break;\n                default:\n                    /* Update buffer and return */\n                    if (i < lc.len) {\n                        nwritten = snprintf(ls->buf,ls->buflen,\"%s\",lc.cvec[i]);\n                        ls->len = ls->pos = nwritten;\n                    }\n                    stop = 1;\n                    break;\n            }\n        }\n    }\n\n    freeCompletions(&lc);\n    return c; /* Return last read character */\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Calls the two low level functions refreshSingleLine() or\n * refreshMultiLine() according to the selected mode. */\n", "func_signal": "static void refreshLine(struct linenoiseState *l)", "code": "{\n    if (mlmode)\n        refreshMultiLine(l);\n    else\n        refreshSingleLine(l);\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Move cursor on the left. */\n", "func_signal": "void linenoiseEditMoveLeft(struct linenoiseState *l)", "code": "{\n    if (l->pos > 0) {\n        l->pos--;\n        refreshLine(l);\n    }\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Backspace implementation. */\n", "func_signal": "void linenoiseEditBackspace(struct linenoiseState *l)", "code": "{\n    if (l->pos > 0 && l->len > 0) {\n        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);\n        l->pos--;\n        l->len--;\n        l->buf[l->len] = '\\0';\n        refreshLine(l);\n    }\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Beep, used for completion when there is nothing to complete or when all\n * the choices were already shown. */\n", "func_signal": "static void linenoiseBeep(void)", "code": "{\n    fprintf(stderr, \"\\x7\");\n    fflush(stderr);\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Delete the previosu word, maintaining the cursor at the start of the\n * current word. */\n", "func_signal": "void linenoiseEditDeletePrevWord(struct linenoiseState *l)", "code": "{\n    size_t old_pos = l->pos;\n    size_t diff;\n\n    while (l->pos > 0 && l->buf[l->pos-1] == ' ')\n        l->pos--;\n    while (l->pos > 0 && l->buf[l->pos-1] != ' ')\n        l->pos--;\n    diff = old_pos - l->pos;\n    memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);\n    l->len -= diff;\n    refreshLine(l);\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Raw mode: 1960 magic shit. */\n", "func_signal": "static int enableRawMode(int fd)", "code": "{\n    struct termios raw;\n\n    if (!isatty(STDIN_FILENO)) goto fatal;\n    if (!atexit_registered) {\n        atexit(linenoiseAtExit);\n        atexit_registered = 1;\n    }\n    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;\n\n    raw = orig_termios;  /* modify the original mode */\n    /* input modes: no break, no CR to NL, no parity check, no strip char,\n     * no start/stop output control. */\n    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n    /* output modes - disable post processing */\n    raw.c_oflag &= ~(OPOST);\n    /* control modes - set 8 bit chars */\n    raw.c_cflag |= (CS8);\n    /* local modes - choing off, canonical off, no extended functions,\n     * no signal chars (^Z,^C) */\n    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n    /* control chars - set return condition: min number of bytes and timer.\n     * We want read to return every single byte, without timeout. */\n    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n\n    /* put terminal in raw mode after flushing */\n    if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;\n    rawmode = 1;\n    return 0;\n\nfatal:\n    errno = ENOTTY;\n    return -1;\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Move cursor on the right. */\n", "func_signal": "void linenoiseEditMoveRight(struct linenoiseState *l)", "code": "{\n    if (l->pos != l->len) {\n        l->pos++;\n        refreshLine(l);\n    }\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Move cursor to the start of the line. */\n", "func_signal": "void linenoiseEditMoveHome(struct linenoiseState *l)", "code": "{\n    if (l->pos != 0) {\n        l->pos = 0;\n        refreshLine(l);\n    }\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Multi line low level line refresh.\n *\n * Rewrite the currently edited line accordingly to the buffer content,\n * cursor position, and number of columns of the terminal. */\n", "func_signal": "static void refreshMultiLine(struct linenoiseState *l)", "code": "{\n    char seq[64];\n    int plen = strlen(l->prompt);\n    int rows = (plen+l->len+l->cols-1)/l->cols; /* rows used by current buf. */\n    int rpos = (plen+l->oldpos+l->cols)/l->cols; /* cursor relative row. */\n    int rpos2; /* rpos after refresh. */\n    int col; /* colum position, zero-based. */\n    int old_rows = l->maxrows;\n    int fd = l->ofd, j;\n    struct abuf ab;\n\n    /* Update maxrows if needed. */\n    if (rows > (int)l->maxrows) l->maxrows = rows;\n\n    /* First step: clear all the lines used before. To do so start by\n     * going to the last row. */\n    abInit(&ab);\n    if (old_rows-rpos > 0) {\n        lndebug(\"go down %d\", old_rows-rpos);\n        snprintf(seq,64,\"\\x1b[%dB\", old_rows-rpos);\n        abAppend(&ab,seq,strlen(seq));\n    }\n\n    /* Now for every row clear it, go up. */\n    for (j = 0; j < old_rows-1; j++) {\n        lndebug(\"clear+up\");\n        snprintf(seq,64,\"\\r\\x1b[0K\\x1b[1A\");\n        abAppend(&ab,seq,strlen(seq));\n    }\n\n    /* Clean the top line. */\n    lndebug(\"clear\");\n    snprintf(seq,64,\"\\r\\x1b[0K\");\n    abAppend(&ab,seq,strlen(seq));\n\n    /* Write the prompt and the current buffer content */\n    abAppend(&ab,l->prompt,strlen(l->prompt));\n    if (maskmode == 1) {\n        unsigned int i;\n        for (i = 0; i < l->len; i++) abAppend(&ab,\"*\",1);\n    } else {\n        abAppend(&ab,l->buf,l->len);\n    }\n\n    /* Show hits if any. */\n    refreshShowHints(&ab,l,plen);\n\n    /* If we are at the very end of the screen with our prompt, we need to\n     * emit a newline and move the prompt to the first column. */\n    if (l->pos &&\n        l->pos == l->len &&\n        (l->pos+plen) % l->cols == 0)\n    {\n        lndebug(\"<newline>\");\n        abAppend(&ab,\"\\n\",1);\n        snprintf(seq,64,\"\\r\");\n        abAppend(&ab,seq,strlen(seq));\n        rows++;\n        if (rows > (int)l->maxrows) l->maxrows = rows;\n    }\n\n    /* Move cursor to right position. */\n    rpos2 = (plen+l->pos+l->cols)/l->cols; /* current cursor relative row. */\n    lndebug(\"rpos2 %d\", rpos2);\n\n    /* Go up till we reach the expected positon. */\n    if (rows-rpos2 > 0) {\n        lndebug(\"go-up %d\", rows-rpos2);\n        snprintf(seq,64,\"\\x1b[%dA\", rows-rpos2);\n        abAppend(&ab,seq,strlen(seq));\n    }\n\n    /* Set column. */\n    col = (plen+(int)l->pos) % (int)l->cols;\n    lndebug(\"set col %d\", 1+col);\n    if (col)\n        snprintf(seq,64,\"\\r\\x1b[%dC\", col);\n    else\n        snprintf(seq,64,\"\\r\");\n    abAppend(&ab,seq,strlen(seq));\n\n    lndebug(\"\\n\");\n    l->oldpos = l->pos;\n\n    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */\n    abFree(&ab);\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Use the ESC [6n escape sequence to query the horizontal cursor position\n * and return it. On error -1 is returned, on success the position of the\n * cursor. */\n", "func_signal": "static int getCursorPosition(int ifd, int ofd)", "code": "{\n    char buf[32];\n    int cols, rows;\n    unsigned int i = 0;\n\n    /* Report cursor location */\n    if (write(ofd, \"\\x1b[6n\", 4) != 4) return -1;\n\n    /* Read the response: ESC [ rows ; cols R */\n    while (i < sizeof(buf)-1) {\n        if (read(ifd,buf+i,1) != 1) break;\n        if (buf[i] == 'R') break;\n        i++;\n    }\n    buf[i] = '\\0';\n\n    /* Parse it. */\n    if (buf[0] != ESC || buf[1] != '[') return -1;\n    if (sscanf(buf+2,\"%d;%d\",&rows,&cols) != 2) return -1;\n    return cols;\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Insert the character 'c' at cursor current position.\n *\n * On error writing to the terminal -1 is returned, otherwise 0. */\n", "func_signal": "int linenoiseEditInsert(struct linenoiseState *l, char c)", "code": "{\n    if (l->len < l->buflen) {\n        if (l->len == l->pos) {\n            l->buf[l->pos] = c;\n            l->pos++;\n            l->len++;\n            l->buf[l->len] = '\\0';\n            if ((!mlmode && l->plen+l->len < l->cols && !hintsCallback)) {\n                /* Avoid a full update of the line in the\n                 * trivial case. */\n                char d = (maskmode==1) ? '*' : c;\n                if (write(l->ofd,&d,1) == -1) return -1;\n            } else {\n                refreshLine(l);\n            }\n        } else {\n            memmove(l->buf+l->pos+1,l->buf+l->pos,l->len-l->pos);\n            l->buf[l->pos] = c;\n            l->len++;\n            l->pos++;\n            l->buf[l->len] = '\\0';\n            refreshLine(l);\n        }\n    }\n    return 0;\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* This is the API call to add a new entry in the linenoise history.\n * It uses a fixed array of char pointers that are shifted (memmoved)\n * when the history max length is reached in order to remove the older\n * entry and make room for the new one, so it is not exactly suitable for huge\n * histories, but will work well for a few hundred of entries.\n *\n * Using a circular buffer is smarter, but a bit more complex to handle. */\n", "func_signal": "int linenoiseHistoryAdd(const char *line)", "code": "{\n    char *linecopy;\n\n    if (history_max_len == 0) return 0;\n\n    /* Initialization on first call. */\n    if (history == NULL) {\n        history = malloc(sizeof(char*)*history_max_len);\n        if (history == NULL) return 0;\n        memset(history,0,(sizeof(char*)*history_max_len));\n    }\n\n    /* Don't add duplicated lines. */\n    if (history_len && !strcmp(history[history_len-1], line)) return 0;\n\n    /* Add an heap allocated copy of the line in the history.\n     * If we reached the max length, remove the older line. */\n    linecopy = strdup(line);\n    if (!linecopy) return 0;\n    if (history_len == history_max_len) {\n        free(history[0]);\n        memmove(history,history+1,sizeof(char*)*(history_max_len-1));\n        history_len--;\n    }\n    history[history_len] = linecopy;\n    history_len++;\n    return 1;\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* At exit we'll try to fix the terminal to the initial conditions. */\n", "func_signal": "static void linenoiseAtExit(void)", "code": "{\n    disableRawMode(STDIN_FILENO);\n    freeHistory();\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Try to get the number of columns in the current terminal, or assume 80\n * if it fails. */\n", "func_signal": "static int getColumns(int ifd, int ofd)", "code": "{\n    struct winsize ws;\n\n    if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {\n        /* ioctl() failed. Try to query the terminal itself. */\n        int start, cols;\n\n        /* Get the initial position so we can restore it later. */\n        start = getCursorPosition(ifd,ofd);\n        if (start == -1) goto failed;\n\n        /* Go to right margin and get position. */\n        if (write(ofd,\"\\x1b[999C\",6) != 6) goto failed;\n        cols = getCursorPosition(ifd,ofd);\n        if (cols == -1) goto failed;\n\n        /* Restore position. */\n        if (cols > start) {\n            char seq[32];\n            snprintf(seq,32,\"\\x1b[%dD\",cols-start);\n            if (write(ofd,seq,strlen(seq)) == -1) {\n                /* Can't recover... */\n            }\n        }\n        return cols;\n    } else {\n        return ws.ws_col;\n    }\n\nfailed:\n    return 80;\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Set the maximum length for the history. This function can be called even\n * if there is already some history, the function will make sure to retain\n * just the latest 'len' elements if the new history length value is smaller\n * than the amount of items already inside the history. */\n", "func_signal": "int linenoiseHistorySetMaxLen(int len)", "code": "{\n    char **new;\n\n    if (len < 1) return 0;\n    if (history) {\n        int tocopy = history_len;\n\n        new = malloc(sizeof(char*)*len);\n        if (new == NULL) return 0;\n\n        /* If we can't copy everything, free the elements we'll not use. */\n        if (len < tocopy) {\n            int j;\n\n            for (j = 0; j < tocopy-len; j++) free(history[j]);\n            tocopy = len;\n        }\n        memset(new,0,sizeof(char*)*len);\n        memcpy(new,history+(history_len-tocopy), sizeof(char*)*tocopy);\n        free(history);\n        history = new;\n    }\n    history_max_len = len;\n    if (history_len > history_max_len)\n        history_len = history_max_len;\n    return 1;\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/* Free a list of completion option populated by linenoiseAddCompletion(). */\n", "func_signal": "static void freeCompletions(linenoiseCompletions *lc)", "code": "{\n    size_t i;\n    for (i = 0; i < lc->len; i++)\n        free(lc->cvec[i]);\n    if (lc->cvec != NULL)\n        free(lc->cvec);\n}", "path": "linenoise/linenoise.c", "commit_date": "2020-03-12 00:00:00", "repo_name": "antirez/linenoise", "stars": 3495, "license": "bsd-2-clause", "language": "c", "size": 146}
{"docstring": "/*\n * Use rte_ticketlock_trylock() to trylock a ticketlock object,\n * If it could not lock the object successfully, it would\n * return immediately and the variable of \"count\" would be\n * increased by one per times. the value of \"count\" could be\n * checked as the result later.\n */\n", "func_signal": "static int\ntest_ticketlock_try(__rte_unused void *arg)", "code": "{\n\tif (rte_ticketlock_trylock(&tl_try) == 0) {\n\t\trte_ticketlock_lock(&tl);\n\t\tcount++;\n\t\trte_ticketlock_unlock(&tl);\n\t}\n\n\treturn 0;\n}", "path": "dpdk/app/test/test_ticketlock.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/* alloc cqe and prepare rqe */\n", "func_signal": "int hinic_setup_rx_resources(struct hinic_rxq *rxq)", "code": "{\n\tu64 rx_info_sz;\n\tint err, pkts;\n\n\trx_info_sz = rxq->q_depth * sizeof(*rxq->rx_info);\n\trxq->rx_info = rte_zmalloc_socket(\"rx_info\", rx_info_sz,\n\t\t\t\tRTE_CACHE_LINE_SIZE, rxq->socket_id);\n\tif (!rxq->rx_info)\n\t\treturn -ENOMEM;\n\n\terr = hinic_rx_alloc_cqe(rxq, rxq->socket_id);\n\tif (err) {\n\t\tPMD_DRV_LOG(ERR, \"Allocate rx cqe failed\");\n\t\tgoto rx_cqe_err;\n\t}\n\n\tpkts = hinic_rx_fill_wqe(rxq);\n\tif (pkts != rxq->q_depth) {\n\t\tPMD_DRV_LOG(ERR, \"Fill rx wqe failed\");\n\t\terr = -ENOMEM;\n\t\tgoto rx_fill_err;\n\t}\n\n\treturn 0;\n\nrx_fill_err:\n\thinic_rx_free_cqe(rxq);\n\nrx_cqe_err:\n\trte_free(rxq->rx_info);\n\trxq->rx_info = NULL;\n\n\treturn err;\n}", "path": "dpdk/drivers/net/hinic/hinic_pmd_rx.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * Set up environment to talk with a vhost kernel backend.\n *\n * @return\n *   - (-1) if fail to set up;\n *   - (>=0) if successful.\n */\n", "func_signal": "static int\nvhost_kernel_setup(struct virtio_user_dev *dev)", "code": "{\n\tint vhostfd;\n\tuint32_t i;\n\n\tget_vhost_kernel_max_regions();\n\n\tfor (i = 0; i < dev->max_queue_pairs; ++i) {\n\t\tvhostfd = open(dev->path, O_RDWR);\n\t\tif (vhostfd < 0) {\n\t\t\tPMD_DRV_LOG(ERR, \"fail to open %s, %s\",\n\t\t\t\t    dev->path, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\tdev->vhostfds[i] = vhostfd;\n\t}\n\n\treturn 0;\n}", "path": "dpdk/drivers/net/virtio/virtio_user/vhost_kernel.c", "commit_date": "2020-01-17 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_get_api_version() - Get Data Path I/O API version\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @major_ver:\tMajor version of data path i/o API\n * @minor_ver:\tMinor version of data path i/o API\n *\n * Return:  '0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_get_api_version(struct fsl_mc_io *mc_io,\n\t\t\t uint32_t cmd_flags,\n\t\t\t uint16_t *major_ver,\n\t\t\t uint16_t *minor_ver)", "code": "{\n\tstruct dpio_rsp_get_api_version *rsp_params;\n\tstruct mc_command cmd = { 0 };\n\tint err;\n\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_API_VERSION,\n\t\t\t\t\tcmd_flags,\n\t\t\t\t\t0);\n\n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\trsp_params = (struct dpio_rsp_get_api_version *)cmd.params;\n\t*major_ver = le16_to_cpu(rsp_params->major);\n\t*minor_ver = le16_to_cpu(rsp_params->minor);\n\n\treturn 0;\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_enable() - Enable the DPIO, allow I/O portal operations.\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\tToken of DPIO object\n *\n * Return:\t'0' on Success; Error code otherwise\n */\n", "func_signal": "int dpio_enable(struct fsl_mc_io *mc_io,\n\t\tuint32_t cmd_flags,\n\t\tuint16_t token)", "code": "{\n\tstruct mc_command cmd = { 0 };\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_ENABLE,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\n\t/* send command to mc*/\n\treturn mc_send_command(mc_io, &cmd);\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_destroy() - Destroy the DPIO object and release all its resources.\n * @mc_io:\tPointer to MC portal's I/O object\n * @dprc_token: Parent container token; '0' for default container\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @object_id:\tThe object id; it must be a valid id within the container that\n *\t\tcreated this object;\n *\n * The function accepts the authentication token of the parent container that\n * created the object (not the one that currently owns the object). The object\n * is searched within parent using the provided 'object_id'.\n * All tokens to the object must be closed before calling destroy.\n *\n * Return:\t'0' on Success; Error code otherwise\n */\n", "func_signal": "int dpio_destroy(struct fsl_mc_io *mc_io,\n\t\t uint16_t dprc_token,\n\t\t uint32_t cmd_flags,\n\t\t uint32_t object_id)", "code": "{\n\tstruct dpio_cmd_destroy *cmd_params;\n\tstruct mc_command cmd = { 0 };\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_DESTROY,\n\t\t\tcmd_flags,\n\t\t\tdprc_token);\n\n\t/* set object id to destroy */\n\tcmd_params = (struct dpio_cmd_destroy *)cmd.params;\n\tcmd_params->dpio_id = cpu_to_le32(object_id);\n\n\t/* send command to mc*/\n\treturn mc_send_command(mc_io, &cmd);\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_is_enabled() - Check if the DPIO is enabled.\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\tToken of DPIO object\n * @en:\t\tReturns '1' if object is enabled; '0' otherwise\n *\n * Return:\t'0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_is_enabled(struct fsl_mc_io *mc_io,\n\t\t    uint32_t cmd_flags,\n\t\t    uint16_t token,\n\t\t    int *en)", "code": "{\n\tstruct dpio_rsp_is_enabled *rsp_params;\n\tstruct mc_command cmd = { 0 };\n\tint err;\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_IS_ENABLED, cmd_flags,\n\t\t\t\t\t  token);\n\n\t/* send command to mc*/\n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t/* retrieve response parameters */\n\trsp_params = (struct dpio_rsp_is_enabled *)cmd.params;\n\t*en = dpio_get_field(rsp_params->en, ENABLE);\n\n\treturn 0;\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_set_stashing_destination() - Set the stashing destination.\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\tToken of DPIO object\n * @sdest:\tStashing destination value\n *\n * Return:\t'0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_set_stashing_destination(struct fsl_mc_io *mc_io,\n\t\t\t\t  uint32_t cmd_flags,\n\t\t\t\t  uint16_t token,\n\t\t\t\t  uint8_t sdest)", "code": "{\n\tstruct dpio_stashing_dest *cmd_params;\n\tstruct mc_command cmd = { 0 };\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_SET_STASHING_DEST,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\tcmd_params = (struct dpio_stashing_dest *)cmd.params;\n\tcmd_params->sdest = sdest;\n\n\t/* send command to mc*/\n\treturn mc_send_command(mc_io, &cmd);\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_close() - Close the control session of the object\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\tToken of DPIO object\n *\n * Return:\t'0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_close(struct fsl_mc_io *mc_io,\n\t       uint32_t cmd_flags,\n\t       uint16_t token)", "code": "{\n\tstruct mc_command cmd = { 0 };\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_CLOSE,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\n\t/* send command to mc*/\n\treturn mc_send_command(mc_io, &cmd);\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_get_attributes() - Retrieve DPIO attributes\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\tToken of DPIO object\n * @attr:\tReturned object's attributes\n *\n * Return:\t'0' on Success; Error code otherwise\n */\n", "func_signal": "int dpio_get_attributes(struct fsl_mc_io *mc_io,\n\t\t\tuint32_t cmd_flags,\n\t\t\tuint16_t token,\n\t\t\tstruct dpio_attr *attr)", "code": "{\n\tstruct dpio_rsp_get_attr *rsp_params;\n\tstruct mc_command cmd = { 0 };\n\tint err;\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_ATTR,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\n\t/* send command to mc*/\n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t/* retrieve response parameters */\n\trsp_params = (struct dpio_rsp_get_attr *)cmd.params;\n\tattr->id = le32_to_cpu(rsp_params->id);\n\tattr->qbman_portal_id = le16_to_cpu(rsp_params->qbman_portal_id);\n\tattr->num_priorities = rsp_params->num_priorities;\n\tattr->qbman_portal_ce_offset =\n\t\t\t\tle64_to_cpu(rsp_params->qbman_portal_ce_offset);\n\tattr->qbman_portal_ci_offset =\n\t\t\t\tle64_to_cpu(rsp_params->qbman_portal_ci_offset);\n\tattr->qbman_version = le32_to_cpu(rsp_params->qbman_version);\n\tattr->clk = le32_to_cpu(rsp_params->clk);\n\tattr->channel_mode = dpio_get_field(rsp_params->channel_mode,\n\t\t\t\t\t    ATTR_CHANNEL_MODE);\n\n\treturn 0;\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n *  Create pool of OP types RTE_BBDEV_OP_NONE, RTE_BBDEV_OP_TURBO_DEC and\n *  RTE_BBDEV_OP_TURBO_ENC and check that only ops of that type can be\n *  allocated\n */\n", "func_signal": "static int\ntest_bbdev_op_type(void)", "code": "{\n\tstruct rte_mempool *mp_dec;\n\n\tconst unsigned int OPS_COUNT = 32;\n\tstruct rte_bbdev_dec_op *dec_ops_arr[OPS_COUNT];\n\tstruct rte_bbdev_enc_op *enc_ops_arr[OPS_COUNT];\n\n\tconst char *pool_dec = \"Test_op_dec\";\n\n\t/* Valid pool configuration */\n\tuint32_t num_elements = 256;\n\tuint32_t cache_size = 128;\n\n\t/* mempool type : RTE_BBDEV_OP_TURBO_DEC */\n\tmp_dec = rte_bbdev_op_pool_create(pool_dec,\n\t\t\tRTE_BBDEV_OP_TURBO_DEC, num_elements, cache_size, 0);\n\tTEST_ASSERT(mp_dec != NULL, \"Failed to create %s mempool\", pool_dec);\n\n\tTEST_ASSERT(rte_bbdev_dec_op_alloc_bulk(mp_dec, dec_ops_arr, 1) == 0,\n\t\t\t\"Failed test for rte_bbdev_op_alloc_bulk TURBO_DEC: \"\n\t\t\t\"OPs type: RTE_BBDEV_OP_TURBO_DEC\");\n\n\tTEST_ASSERT(rte_bbdev_enc_op_alloc_bulk(mp_dec, enc_ops_arr, 1) != 0,\n\t\t\t\"Failed test for rte_bbdev_op_alloc_bulk TURBO_DEC: \"\n\t\t\t\"OPs type: RTE_BBDEV_OP_TURBO_ENC\");\n\n\trte_mempool_free(mp_dec);\n\n\treturn TEST_SUCCESS;\n}", "path": "dpdk/app/test-bbdev/test_bbdev.c", "commit_date": "2019-07-05 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/*\n * Test rte_eal_get_lcore_state() in addition to ticketlocks\n * as we have \"waiting\" then \"running\" lcores.\n */\n", "func_signal": "static int\ntest_ticketlock(void)", "code": "{\n\tint ret = 0;\n\tint i;\n\n\t/* worker cores should be waiting: print it */\n\tRTE_LCORE_FOREACH_WORKER(i) {\n\t\tprintf(\"lcore %d state: %d\\n\", i,\n\t\t       (int) rte_eal_get_lcore_state(i));\n\t}\n\n\trte_ticketlock_init(&tl);\n\trte_ticketlock_init(&tl_try);\n\trte_ticketlock_recursive_init(&tlr);\n\tRTE_LCORE_FOREACH_WORKER(i) {\n\t\trte_ticketlock_init(&tl_tab[i]);\n\t}\n\n\trte_ticketlock_lock(&tl);\n\n\tRTE_LCORE_FOREACH_WORKER(i) {\n\t\trte_ticketlock_lock(&tl_tab[i]);\n\t\trte_eal_remote_launch(test_ticketlock_per_core, NULL, i);\n\t}\n\n\t/* worker cores should be busy: print it */\n\tRTE_LCORE_FOREACH_WORKER(i) {\n\t\tprintf(\"lcore %d state: %d\\n\", i,\n\t\t       (int) rte_eal_get_lcore_state(i));\n\t}\n\trte_ticketlock_unlock(&tl);\n\n\tRTE_LCORE_FOREACH_WORKER(i) {\n\t\trte_ticketlock_unlock(&tl_tab[i]);\n\t\trte_delay_ms(10);\n\t}\n\n\trte_eal_mp_wait_lcore();\n\n\trte_ticketlock_recursive_lock(&tlr);\n\n\t/*\n\t * Try to acquire a lock that we already own\n\t */\n\tif (!rte_ticketlock_recursive_trylock(&tlr)) {\n\t\tprintf(\"rte_ticketlock_recursive_trylock failed on a lock that \"\n\t\t       \"we already own\\n\");\n\t\tret = -1;\n\t} else\n\t\trte_ticketlock_recursive_unlock(&tlr);\n\n\tRTE_LCORE_FOREACH_WORKER(i) {\n\t\trte_eal_remote_launch(test_ticketlock_recursive_per_core,\n\t\t\t\t\tNULL, i);\n\t}\n\trte_ticketlock_recursive_unlock(&tlr);\n\trte_eal_mp_wait_lcore();\n\n\t/*\n\t * Test if it could return immediately from try-locking a locked object.\n\t * Here it will lock the ticketlock object first, then launch all the\n\t * worker lcores to trylock the same ticketlock object.\n\t * All the worker lcores should give up try-locking a locked object and\n\t * return immediately, and then increase the \"count\" initialized with\n\t * zero by one per times.\n\t * We can check if the \"count\" is finally equal to the number of all\n\t * worker lcores to see if the behavior of try-locking a locked\n\t * ticketlock object is correct.\n\t */\n\tif (rte_ticketlock_trylock(&tl_try) == 0)\n\t\treturn -1;\n\n\tcount = 0;\n\tRTE_LCORE_FOREACH_WORKER(i) {\n\t\trte_eal_remote_launch(test_ticketlock_try, NULL, i);\n\t}\n\trte_eal_mp_wait_lcore();\n\trte_ticketlock_unlock(&tl_try);\n\tif (rte_ticketlock_is_locked(&tl)) {\n\t\tprintf(\"ticketlock is locked but it should not be\\n\");\n\t\treturn -1;\n\t}\n\trte_ticketlock_lock(&tl);\n\tif (count != (rte_lcore_count() - 1))\n\t\tret = -1;\n\n\trte_ticketlock_unlock(&tl);\n\n\t/*\n\t * Test if it can trylock recursively.\n\t * Use rte_ticketlock_recursive_trylock() to check if it can lock\n\t * a ticketlock object recursively. Here it will try to lock a\n\t * ticketlock object twice.\n\t */\n\tif (rte_ticketlock_recursive_trylock(&tlr) == 0) {\n\t\tprintf(\"It failed to do the first ticketlock_recursive_trylock \"\n\t\t\t   \"but it should able to do\\n\");\n\t\treturn -1;\n\t}\n\tif (rte_ticketlock_recursive_trylock(&tlr) == 0) {\n\t\tprintf(\"It failed to do the second ticketlock_recursive_trylock \"\n\t\t\t   \"but it should able to do\\n\");\n\t\treturn -1;\n\t}\n\trte_ticketlock_recursive_unlock(&tlr);\n\trte_ticketlock_recursive_unlock(&tlr);\n\n\tif (test_ticketlock_perf() < 0)\n\t\treturn -1;\n\n\treturn ret;\n}", "path": "dpdk/app/test/test_ticketlock.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_get_stashing_destination() - Get the stashing destination..\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\tToken of DPIO object\n * @sdest:\tReturns the stashing destination value\n *\n * Return:\t'0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_get_stashing_destination(struct fsl_mc_io *mc_io,\n\t\t\t\t  uint32_t cmd_flags,\n\t\t\t\t  uint16_t token,\n\t\t\t\t  uint8_t *sdest)", "code": "{\n\tstruct dpio_stashing_dest *rsp_params;\n\tstruct mc_command cmd = { 0 };\n\tint err;\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_STASHING_DEST,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\n\t/* send command to mc*/\n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t/* retrieve response parameters */\n\trsp_params = (struct dpio_stashing_dest *)cmd.params;\n\t*sdest = rsp_params->sdest;\n\n\treturn 0;\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_add_static_dequeue_channel() - Add a static dequeue channel.\n * @mc_io:\t\tPointer to MC portal's I/O object\n * @cmd_flags:\t\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\t\tToken of DPIO object\n * @dpcon_id:\t\tDPCON object ID\n * @channel_index:\tReturned channel index to be used in qbman API\n *\n * Return:\t'0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_add_static_dequeue_channel(struct fsl_mc_io *mc_io,\n\t\t\t\t    uint32_t cmd_flags,\n\t\t\t\t    uint16_t token,\n\t\t\t\t    int dpcon_id,\n\t\t\t\t    uint8_t *channel_index)", "code": "{\n\tstruct dpio_rsp_add_static_dequeue_channel *rsp_params;\n\tstruct dpio_cmd_static_dequeue_channel *cmd_params;\n\tstruct mc_command cmd = { 0 };\n\tint err;\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_ADD_STATIC_DEQUEUE_CHANNEL,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\tcmd_params = (struct dpio_cmd_static_dequeue_channel *)cmd.params;\n\tcmd_params->dpcon_id = cpu_to_le32(dpcon_id);\n\n\t/* send command to mc*/\n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t/* retrieve response parameters */\n\trsp_params = (struct dpio_rsp_add_static_dequeue_channel *)cmd.params;\n\t*channel_index = rsp_params->channel_index;\n\n\treturn 0;\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_remove_static_dequeue_channel() - Remove a static dequeue channel.\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\tToken of DPIO object\n * @dpcon_id:\tDPCON object ID\n *\n * Return:\t'0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_remove_static_dequeue_channel(struct fsl_mc_io *mc_io,\n\t\t\t\t       uint32_t cmd_flags,\n\t\t\t\t       uint16_t token,\n\t\t\t\t       int dpcon_id)", "code": "{\n\tstruct dpio_cmd_static_dequeue_channel *cmd_params;\n\tstruct mc_command cmd = { 0 };\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(\n\t\t\t\tDPIO_CMDID_REMOVE_STATIC_DEQUEUE_CHANNEL,\n\t\t\t\tcmd_flags,\n\t\t\t\ttoken);\n\tcmd_params = (struct dpio_cmd_static_dequeue_channel *)cmd.params;\n\tcmd_params->dpcon_id = cpu_to_le32(dpcon_id);\n\n\t/* send command to mc*/\n\treturn mc_send_command(mc_io, &cmd);\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_open() - Open a control session for the specified object\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @dpio_id:\tDPIO unique ID\n * @token:\tReturned token; use in subsequent API calls\n *\n * This function can be used to open a control session for an\n * already created object; an object may have been declared in\n * the DPL or by calling the dpio_create() function.\n * This function returns a unique authentication token,\n * associated with the specific object ID and any MC portals\n * assigned to the parent container; this token must be used in\n * all subsequent commands for this specific object.\n *\n * Return:\t'0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_open(struct fsl_mc_io *mc_io,\n\t      uint32_t cmd_flags,\n\t      int dpio_id,\n\t      uint16_t *token)", "code": "{\n\tstruct dpio_cmd_open *cmd_params;\n\tstruct mc_command cmd = { 0 };\n\tint err;\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_OPEN,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  0);\n\tcmd_params = (struct dpio_cmd_open *)cmd.params;\n\tcmd_params->dpio_id = cpu_to_le32(dpio_id);\n\n\t/* send command to mc*/\n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t/* retrieve response parameters */\n\t*token = mc_cmd_hdr_read_token(&cmd);\n\n\treturn 0;\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * hinic_setup_num_qps - determine num_qps from rss_tmpl_id\n * @nic_dev: pointer to the private ethernet device\n * Return: 0 on Success, error code otherwise.\n **/\n", "func_signal": "static int hinic_setup_num_qps(struct hinic_nic_dev *nic_dev)", "code": "{\n\tint err, i;\n\n\tif (!(nic_dev->flags & ETH_MQ_RX_RSS_FLAG)) {\n\t\tnic_dev->flags &= ~ETH_MQ_RX_RSS_FLAG;\n\t\tnic_dev->num_rss = 0;\n\t\tif (nic_dev->num_rq > 1) {\n\t\t\t/* get rss template id */\n\t\t\terr = hinic_rss_template_alloc(nic_dev->hwdev,\n\t\t\t\t\t\t       &nic_dev->rss_tmpl_idx);\n\t\t\tif (err) {\n\t\t\t\tPMD_DRV_LOG(WARNING, \"Alloc rss template failed\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tnic_dev->flags |= ETH_MQ_RX_RSS_FLAG;\n\t\t\tfor (i = 0; i < nic_dev->num_rq; i++)\n\t\t\t\thinic_add_rq_to_rx_queue_list(nic_dev, i);\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "dpdk/drivers/net/hinic/hinic_pmd_rx.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/* By default, vhost kernel module allows 64 regions, but DPDK may\n * have much more memory regions. Below function will treat each\n * contiguous memory space reserved by DPDK as one region.\n */\n", "func_signal": "static struct vhost_memory_kernel *\nprepare_vhost_memory_kernel(void)", "code": "{\n\tstruct vhost_memory_kernel *vm;\n\n\tvm = malloc(sizeof(struct vhost_memory_kernel) +\n\t\t\tmax_regions *\n\t\t\tsizeof(struct vhost_memory_region));\n\tif (!vm)\n\t\treturn NULL;\n\n\tvm->nregions = 0;\n\tvm->padding = 0;\n\n\t/*\n\t * The memory lock has already been taken by memory subsystem\n\t * or virtio_user_start_device().\n\t */\n\tif (rte_memseg_list_walk_thread_unsafe(add_memseg_list, vm) < 0) {\n\t\tfree(vm);\n\t\treturn NULL;\n\t}\n\n\treturn vm;\n}", "path": "dpdk/drivers/net/virtio/virtio_user/vhost_kernel.c", "commit_date": "2020-01-17 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/**\n * dpio_reset() - Reset the DPIO, returns the object to initial state.\n * @mc_io:\tPointer to MC portal's I/O object\n * @cmd_flags:\tCommand flags; one or more of 'MC_CMD_FLAG_'\n * @token:\tToken of DPIO object\n *\n * Return:\t'0' on Success; Error code otherwise.\n */\n", "func_signal": "int dpio_reset(struct fsl_mc_io *mc_io,\n\t       uint32_t cmd_flags,\n\t       uint16_t token)", "code": "{\n\tstruct mc_command cmd = { 0 };\n\n\t/* prepare command */\n\tcmd.header = mc_encode_cmd_header(DPIO_CMDID_RESET,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\n\t/* send command to mc*/\n\treturn mc_send_command(mc_io, &cmd);\n}", "path": "dpdk/drivers/bus/fslmc/mc/dpio.c", "commit_date": "2018-10-16 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/* dummy function to do \"work\" */\n", "func_signal": "static int32_t service_func(void *args)", "code": "{\n\tRTE_SET_USED(args);\n\trte_delay_us(2000);\n\treturn 0;\n}", "path": "dpdk/examples/service_cores/main.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "DPDK/dpdk", "stars": 2962, "license": "None", "language": "c", "size": 111737}
{"docstring": "/*\n * Deliver timer events. Requests are sorted: we can stop when we\n * reach the future or the list end. Allow the application to update\n * the timer queue while it is being called back. To this end, we\n * repeatedly pop the first request off the timer queue before\n * delivering the event to the application.\n */\n", "func_signal": "void event_timer_trigger_thr(EVENT_THR *event)", "code": "{\n\tACL_EVENT *eventp = &event->event;\n\tACL_EVENT_TIMER *timer;\n\tACL_RING_ITER iter;\n\tACL_RING *ring;\n\tACL_EVENT_NOTIFY_TIME timer_fn;\n\tvoid *timer_arg;\n\n\tSET_TIME(eventp->present);\n\n\tTHREAD_LOCK(&event->tm_mutex);\n\n\tacl_ring_foreach(iter, &eventp->timer_head) {\n\t\ttimer = RING_TO_TIMER(iter.ptr);\n\t\tif (timer->when > eventp->present) {\n\t\t\tbreak;\n\t\t}\n\n\t\tacl_ring_prepend(&eventp->timers, &timer->tmp);\n\t}\n\n\tTHREAD_UNLOCK(&event->tm_mutex);\n\n\twhile ((ring = acl_ring_pop_head(&eventp->timers)) != NULL) {\n\t\ttimer     = TMP_TO_TIMER(ring);\n\t\ttimer_fn  = timer->callback;\n\t\ttimer_arg = timer->context;\n\n\t\tif (timer->delay > 0 && timer->keep) {\n\t\t\ttimer->ncount++;\n\t\t\teventp->timer_request(eventp, timer->callback,\n\t\t\t\ttimer->context, timer->delay, timer->keep);\n\t\t} else {\n\t\t\tacl_ring_detach(&timer->ring);  /* first this */\n\t\t\tacl_myfree(timer);\n\t\t}\n\n\t\ttimer_fn(ACL_EVENT_TIME, eventp, timer_arg);\n\t}\n}", "path": "acl/lib_acl/src/event/events_timer_thr.c", "commit_date": "2020-08-13 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* acl_ring_append - insert entry after ring head */\n", "func_signal": "void acl_ring_append(ACL_RING *ring, ACL_RING *entry)", "code": "{\n\tif (ring == NULL || entry == NULL)\n\t\treturn;\n\tentry->succ      = ring->succ;\n\tentry->pred      = ring;\n\tentry->parent    = ring->parent;\n\tring->succ->pred = entry;\n\tring->succ       = entry;\n\tring->parent->len++;\n}", "path": "acl/lib_acl/src/stdlib/common/acl_ring.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* acl_ring_size - the entry number in the ring */\n", "func_signal": "int acl_ring_size(const ACL_RING *ring)", "code": "{\n\tif (ring == NULL)\n\t\treturn -1;\n\n\treturn ring->len;\n}", "path": "acl/lib_acl/src/stdlib/common/acl_ring.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* acl_ring_pop_head - pop ring's head entry out from ring */\n", "func_signal": "ACL_RING *acl_ring_pop_head(ACL_RING *ring)", "code": "{\n\tACL_RING   *succ;\n\n\tif (ring == NULL)\n\t\treturn NULL;\n\n\tsucc = ring->succ;\n\tif (succ == ring)\n\t\treturn NULL;\n\n\tacl_ring_detach(succ);\n\n\treturn succ;\n}", "path": "acl/lib_acl/src/stdlib/common/acl_ring.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* attr_vscan0 - receive attribute list from stream */\n", "func_signal": "int     attr_vscan0(ACL_VSTREAM *fp, int flags, va_list ap)", "code": "{\n    const char *myname = \"attr_scan0\";\n    static __thread ACL_VSTRING *str_buf = 0;\n    static __thread ACL_VSTRING *name_buf = 0;\n    int     wanted_type = -1;\n    char   *wanted_name = 0;\n    unsigned int *number;\n    unsigned long *long_number;\n    ACL_VSTRING *string;\n    ACL_HTABLE *hash_table = 0;\n    int     ch;\n    int     conversions;\n    ATTR_SCAN_SLAVE_FN scan_fn;\n    void   *scan_arg;\n\n    /*\n     * Sanity check.\n     */\n    if (flags & ~ATTR_FLAG_ALL)\n\tacl_msg_panic(\"%s: bad flags: 0x%x\", myname, flags);\n\n    /*\n     * EOF check.\n     */\n    if ((ch = ACL_VSTREAM_GETC(fp)) == ACL_VSTREAM_EOF)\n\treturn (0);\n    acl_vstream_ungetc(fp, ch);\n\n    /*\n     * Initialize.\n     */\n    if (str_buf == 0) {\n\tstr_buf = acl_vstring_alloc(10);\n\tname_buf = acl_vstring_alloc(10);\n\tacl_pthread_atexit_add(str_buf, free_vstring);\n\tacl_pthread_atexit_add(name_buf, free_vstring);\n    }\n\n    /*\n     * Iterate over all (type, name, value) triples.\n     */\n    for (conversions = 0; /* void */ ; conversions++) {\n\n\t/*\n\t * Determine the next attribute type and attribute name on the\n\t * caller's wish list.\n\t * \n\t * If we're reading into a hash table, we already know that the\n\t * attribute value is string-valued, and we get the attribute name\n\t * from the input stream instead. This is secure only when the\n\t * resulting table is queried with known to be good attribute names.\n\t */\n\tif (wanted_type != ATTR_TYPE_HASH) {\n\t    wanted_type = va_arg(ap, int);\n\t    if (wanted_type == ATTR_TYPE_END) {\n\t\tif ((flags & ATTR_FLAG_MORE) != 0)\n\t\t    return (conversions);\n\t\twanted_name = \"(list terminator)\";\n\t    } else if (wanted_type == ATTR_TYPE_HASH) {\n\t\twanted_name = \"(any attribute name or list terminator)\";\n\t\thash_table = va_arg(ap, ACL_HTABLE *);\n\t\tif (va_arg(ap, int) != ATTR_TYPE_END)\n\t\t    acl_msg_panic(\"%s: ATTR_TYPE_HASH not followed by ATTR_TYPE_END\",\n\t\t\t      myname);\n\t    } else if (wanted_type != ATTR_TYPE_FUNC) {\n\t\twanted_name = va_arg(ap, char *);\n\t    }\n\t}\n\n\t/*\n\t * Locate the next attribute of interest in the input stream.\n\t */\n\twhile (wanted_type != ATTR_TYPE_FUNC) {\n\n\t    /*\n\t     * Get the name of the next attribute. Hitting EOF is always bad.\n\t     * Hitting the end-of-input early is OK if the caller is prepared\n\t     * to deal with missing inputs.\n\t     */\n\t    if (acl_msg_verbose)\n\t\tacl_msg_info(\"%s: wanted attribute: %s\",\n\t\t\t ACL_VSTREAM_PATH(fp), wanted_name);\n\t    if ((ch = attr_scan0_string(fp, name_buf,\n\t\t\t\t    \"input attribute name\")) < 0)\n\t\treturn (-1);\n\t    if (LEN(name_buf) == 0) {\n\t\tif (wanted_type == ATTR_TYPE_END\n\t\t    || wanted_type == ATTR_TYPE_HASH)\n\t\t    return (conversions);\n\t\tif ((flags & ATTR_FLAG_MISSING) != 0)\n\t\t    acl_msg_warn(\"%s: missing attribute %s in input from %s\",\n\t\t\t     myname, wanted_name, ACL_VSTREAM_PATH(fp));\n\t\treturn (conversions);\n\t    }\n\n\t    /*\n\t     * See if the caller asks for this attribute.\n\t     */\n\t    if (wanted_type == ATTR_TYPE_HASH\n\t\t|| (wanted_type != ATTR_TYPE_END\n\t\t    && strcmp(wanted_name, STR(name_buf)) == 0))\n\t\tbreak;\n\t    if ((flags & ATTR_FLAG_EXTRA) != 0) {\n\t\tacl_msg_warn(\"%s: unexpected attribute %s from %s (expecting: %s)\",\n\t\t\t myname, STR(name_buf), ACL_VSTREAM_PATH(fp), wanted_name);\n\t\treturn (conversions);\n\t    }\n\n\t    /*\n\t     * Skip over this attribute. The caller does not ask for it.\n\t     */\n\t    (void) attr_scan0_string(fp, str_buf, \"input attribute value\");\n\t}\n\n\t/*\n\t * Do the requested conversion.\n\t */\n\tswitch (wanted_type) {\n\tcase ATTR_TYPE_INT:\n\t    number = va_arg(ap, unsigned int *);\n\t    if ((ch = attr_scan0_number(fp, number, str_buf, \"input attribute value\")) < 0)\n\t\treturn (-1);\n\t    break;\n\tcase ATTR_TYPE_LONG:\n\t    long_number = va_arg(ap, unsigned long *);\n\t    if ((ch = attr_scan0_long_number(fp, long_number, str_buf, \"input attribute value\")) < 0)\n\t\treturn (-1);\n\t    break;\n\tcase ATTR_TYPE_STR:\n\t    string = va_arg(ap, ACL_VSTRING *);\n\t    if ((ch = attr_scan0_string(fp, string, \"input attribute value\")) < 0)\n\t\treturn (-1);\n\t    break;\n\tcase ATTR_TYPE_DATA:\n\t    string = va_arg(ap, ACL_VSTRING *);\n\t    if ((ch = attr_scan0_data(fp, string, \"input attribute value\")) < 0)\n\t\treturn (-1);\n\t    break;\n\tcase ATTR_TYPE_FUNC:\n\t    scan_fn = va_arg(ap, ATTR_SCAN_SLAVE_FN);\n\t    scan_arg = va_arg(ap, void *);\n\t    if (scan_fn(attr_scan0, fp, flags | ATTR_FLAG_MORE, scan_arg) < 0)\n\t\treturn (-1);\n\t    break;\n\tcase ATTR_TYPE_HASH:\n\t    if ((ch = attr_scan0_string(fp, str_buf,\n\t\t\t\t\t\"input attribute value\")) < 0)\n\t\treturn (-1);\n\t    if (acl_htable_locate(hash_table, STR(name_buf)) != 0) {\n\t\tif ((flags & ATTR_FLAG_EXTRA) != 0) {\n\t\t    acl_msg_warn(\"%s: duplicate attribute %s in input from %s\",\n\t\t\t     myname, STR(name_buf), ACL_VSTREAM_PATH(fp));\n\t\t    return (conversions);\n\t\t}\n\t    } else if (acl_htable_used(hash_table) >= ATTR_HASH_LIMIT) {\n\t\tacl_msg_warn(\"%s: attribute count exceeds limit %d in input from %s\",\n\t\t\t myname, ATTR_HASH_LIMIT, ACL_VSTREAM_PATH(fp));\n\t\treturn (conversions);\n\t    } else {\n\t\tacl_htable_enter(hash_table, STR(name_buf),\n\t\t\t     acl_mystrdup(STR(str_buf)));\n\t    }\n\t    break;\n\tdefault:\n\t    acl_msg_panic(\"%s: unknown type code: %d\", myname, wanted_type);\n\t}\n    }\n}", "path": "acl/lib_tls/attr/attr_scan0.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* attr_scan0 - read attribute list from stream */\n", "func_signal": "int     attr_scan0(ACL_VSTREAM *fp, int flags,...)", "code": "{\n    va_list ap;\n    int     ret;\n\n    va_start(ap, flags);\n    ret = attr_vscan0(fp, flags, ap);\n    va_end(ap);\n    return (ret);\n}", "path": "acl/lib_tls/attr/attr_scan0.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* attr_scan0_string - pull a string from the input stream */\n", "func_signal": "static int attr_scan0_string(ACL_VSTREAM *fp, ACL_VSTRING *plain_buf, const char *context)", "code": "{\n    const char *myname = \"attr_scan0_string\";\n    int     ch;\n\n    if ((ch = acl_vstring_gets_null(plain_buf, fp)) == ACL_VSTREAM_EOF) {\n\tacl_msg_warn(\"%s: %s on %s while reading %s\",\n\t\t myname, acl_vstream_ftimeout(fp) ? \"timeout\" : \"premature end-of-input\",\n\t\t ACL_VSTREAM_PATH(fp), context);\n\treturn (-1);\n    }\n    if (ch != 0) {\n\tacl_msg_warn(\"%s: unexpected end-of-input from %s while reading %s\",\n\t\t myname, ACL_VSTREAM_PATH(fp), context);\n\treturn (-1);\n    }\n    if (acl_msg_verbose)\n\tacl_msg_info(\"%s: %s: %s\", myname, context, *STR(plain_buf) ? STR(plain_buf) : \"(end)\");\n    return (ch);\n}", "path": "acl/lib_tls/attr/attr_scan0.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* acl_ring_detach - remove entry from ring */\n", "func_signal": "void acl_ring_detach(ACL_RING *entry)", "code": "{\n\tACL_RING   *succ;\n\tACL_RING   *pred;\n\n\tif (entry == NULL || entry->parent == entry)\n\t\treturn;\n\tsucc = entry->succ;\n\tpred = entry->pred;\n\tif (succ == NULL || pred == NULL)\n\t\treturn;\n\tpred->succ = succ;\n\tsucc->pred = pred;\n\n\tentry->parent->len--;\n\n\tentry->succ = entry->pred = entry;\n\tentry->parent = entry;\n\tentry->len = 0;\n}", "path": "acl/lib_acl/src/stdlib/common/acl_ring.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* attr_scan0_data - pull a data blob from the input stream */\n", "func_signal": "static int attr_scan0_data(ACL_VSTREAM *fp, ACL_VSTRING *str_buf,\n\t\t\t           const char *context)", "code": "{\n    const char *myname = \"attr_scan0_data\";\n    static __thread ACL_VSTRING *base64_buf = 0;\n    int     ch;\n\n    if (base64_buf == 0) {\n\tbase64_buf = acl_vstring_alloc(10);\n\tacl_pthread_atexit_add(base64_buf, free_vstring);\n    }\n    if ((ch = attr_scan0_string(fp, base64_buf, context)) < 0)\n\treturn (-1);\n    if (acl_vstring_base64_decode(str_buf, STR(base64_buf), (int) LEN(base64_buf)) == 0) {\n\tacl_msg_warn(\"%s: malformed base64 data from %s while reading %s: %.100s\",\n\t\t myname, ACL_VSTREAM_PATH(fp), context, STR(base64_buf));\n\treturn (-1);\n    }\n    return (ch);\n}", "path": "acl/lib_tls/attr/attr_scan0.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* acl_ring_prepend - insert new entry before ring head */\n", "func_signal": "void acl_ring_prepend(ACL_RING *ring, ACL_RING *entry)", "code": "{\n\tif (ring == NULL || entry == NULL)\n\t\treturn;\n\tentry->pred      = ring->pred;\n\tentry->succ      = ring;\n\tentry->parent    = ring->parent;\n\tring->pred->succ = entry;\n\tring->pred       = entry;\n\tring->parent->len++;\n}", "path": "acl/lib_acl/src/stdlib/common/acl_ring.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* acl_ring_init - initialize ring head */\n", "func_signal": "void acl_ring_init(ACL_RING *ring)", "code": "{\n\tif (ring == NULL)\n\t\treturn;\n\tring->pred   = ring->succ = ring;\n\tring->parent = ring;\n\tring->len    = 0;\n}", "path": "acl/lib_acl/src/stdlib/common/acl_ring.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* DNS\u046f\u07f3\u07f3\u0337IO\u03e2\u03aa\u07f3\u0336\u04aa\u04bb\u03e2\u03e2\u04aa */\n", "func_signal": "static void reply_lookup_msg(DNS_CTX *dns_ctx, DNS_SERVER *dns)", "code": "{\n\tconst char *myname = \"reply_lookup_msg\";\n\n\t/*  */\n\tacl_pthread_mutex_lock(&dns->lock);\n\n\t/* \u07f3\u0337DNS\u046f\u03e2 */\n\tif (MSG_SEND(dns_ctx->mio, DNS_MSG_LOOKUP_RESULT, dns_ctx, sizeof(DNS_CTX)) < 0) {\n\t\tacl_msg_error(\"%s: send msg error, domain(%s)\", myname, dns_ctx->domain_key);\n\t}\n\n\t/*  */\n\tacl_pthread_mutex_unlock(&dns->lock);\n\n\t/* \u0377 msg_lookup \u06b4 */\n\tacl_myfree(dns_ctx);\n}", "path": "acl/app/jaws/global/dns_server.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* \u07f3\u03e2: \u07f3\u0368\u02faDNS\u07f3\u033dDNS\u046f */\n", "func_signal": "static int msg_lookup(int msg_type acl_unused, ACL_MSGIO *mio,\n\t\t  const ACL_MSGIO_INFO *info, void *arg)", "code": "{\n\tDNS_CTX *dns_ctx;\n\n\tdns_ctx = (DNS_CTX *) acl_mycalloc(1, sizeof(DNS_CTX));\n\tmemcpy(dns_ctx, acl_vstring_str(info->body.buf),\n\t\tACL_VSTRING_LEN(info->body.buf));\n\n\t/* DNS */\n\tdns_ctx->dns = (DNS_SERVER *) arg;\n\t/* \u03e2\u07f3\u0333\u0435\u0132\u046f\u07f3\u0368\u02fe\u03e2\u0368\u05aa\n\t * \u07f3\u0439DNS\u0132\u046f \n\t */\n\tdns_ctx->mio = mio;\n\n\t/* \u07f3\u033d\u02bdDNS\u046f */\n#ifdef USE_THREAD_POOL\n\tacl_pthread_pool_add(dns_ctx->dns->wq, lookup_thread, dns_ctx);\n#else\n\tlookup_thread(dns_ctx);\n#endif\n\n\treturn (1);\n}", "path": "acl/app/jaws/global/dns_server.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* attr_scan0_number - pull a number from the input stream */\n", "func_signal": "static int attr_scan0_number(ACL_VSTREAM *fp, unsigned *ptr,\n\tACL_VSTRING *str_buf, const char *context)", "code": "{\n    const char *myname = \"attr_scan0_number\";\n    char    junk = 0;\n    int     ch;\n\n    if ((ch = attr_scan0_string(fp, str_buf, context)) < 0)\n\treturn (-1);\n    if (sscanf(STR(str_buf), \"%u%c\", ptr, &junk) != 1 || junk != 0) {\n\tacl_msg_warn(\"%s: malformed numerical data from %s while reading %s: %.100s\",\n\t\t myname, ACL_VSTREAM_PATH(fp), context, STR(str_buf));\n\treturn (-1);\n    }\n    return (ch);\n}", "path": "acl/lib_tls/attr/attr_scan0.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* event_timer_cancel_thr - cancel timer */\n", "func_signal": "acl_int64 event_timer_cancel_thr(ACL_EVENT *eventp,\n\tACL_EVENT_NOTIFY_TIME callback, void *context)", "code": "{\n\tEVENT_THR *event_thr = (EVENT_THR *) eventp;\n\tACL_RING_ITER iter;\n\tACL_EVENT_TIMER *timer;\n\tacl_int64  time_left = -1;\n\n\tTHREAD_LOCK(&event_thr->tm_mutex);\n\n\t/*\n\t * See if they are canceling an existing timer request. Do not complain\n\t * when the request is not found. It might have been canceled from some\n\t * other thread.\n\t */\n\n\tSET_TIME(eventp->present);\n\n\tacl_ring_foreach(iter, &eventp->timer_head) {\n\t\ttimer = RING_TO_TIMER(iter.ptr);\n\t\tif (timer->callback == callback && timer->context == context) {\n\t\t\tif ((time_left = timer->when - eventp->present) < 0) {\n\t\t\t\ttime_left = 0;\n\t\t\t}\n\t\t\tacl_ring_detach(&timer->ring);\n\t\t\tacl_ring_detach(&timer->tmp);\n\t\t\tacl_myfree(timer);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tTHREAD_UNLOCK(&event_thr->tm_mutex);\n\n\treturn (time_left);\n}", "path": "acl/lib_acl/src/event/events_timer_thr.c", "commit_date": "2020-08-13 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* event_timer_request_thr - (re)set timer */\n", "func_signal": "acl_int64 event_timer_request_thr(ACL_EVENT *eventp,\n\tACL_EVENT_NOTIFY_TIME callback, void *context,\n\tacl_int64 delay, int keep acl_unused)", "code": "{\n\tconst char *myname = \"event_timer_request_thr\";\n\tEVENT_THR *event_thr = (EVENT_THR *) eventp;\n\tACL_RING_ITER iter;\n\tACL_EVENT_TIMER *timer = NULL;\n\n\tif (delay < 0 || delay >= 4294963950LL)\n\t\tacl_msg_panic(\"%s: invalid delay: %lld\", myname, delay);\n\n\tTHREAD_LOCK(&event_thr->tm_mutex);\n\n\t/*\n\t * Make sure we schedule this event at the right time.\n\t */\n\tSET_TIME(eventp->present);\n\n\t/*\n\t * See if they are resetting an existing timer request. If so, take the\n\t * request away from the timer queue so that it can be inserted at the\n\t * right place.\n\t */\n\tacl_ring_foreach(iter, &eventp->timer_head) {\n\t\ttimer = RING_TO_TIMER(iter.ptr);\n\t\tif (timer->callback == callback && timer->context == context) {\n\t\t\ttimer->when = eventp->present + delay;\n\t\t\tacl_ring_detach(iter.ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If not found, schedule a new timer request.\n\t */\n\tif (iter.ptr == &eventp->timer_head) {\n\t\ttimer = (ACL_EVENT_TIMER *) acl_mymalloc(sizeof(ACL_EVENT_TIMER));\n\t\tif (timer == NULL) {\n\t\t\tacl_msg_panic(\"%s: can't mymalloc for timer\", myname);\n\t\t}\n\t\ttimer->when       = eventp->present + delay;\n\t\ttimer->delay      = delay;\n\t\ttimer->callback   = callback;\n\t\ttimer->context    = context;\n\t\ttimer->event_type = ACL_EVENT_TIME;\n\t\tacl_ring_init(&timer->tmp);\n\t}\n\n\t/*\n\t * Insert the request at the right place. Timer requests are kept sorted\n\t * to reduce lookup overhead in the event loop.\n\t */\n\tacl_ring_foreach(iter, &eventp->timer_head) {\n\t\tif (timer->when < RING_TO_TIMER(iter.ptr)->when) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tacl_ring_prepend(iter.ptr, &timer->ring);\n\tTHREAD_UNLOCK(&event_thr->tm_mutex);\n\treturn timer->when;\n}", "path": "acl/lib_acl/src/event/events_timer_thr.c", "commit_date": "2020-08-13 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* attr_scan0_long_number - pull a number from the input stream */\n", "func_signal": "static int attr_scan0_long_number(ACL_VSTREAM *fp, unsigned long *ptr,\n\tACL_VSTRING *str_buf, const char *context)", "code": "{\n    const char *myname = \"attr_scan0_long_number\";\n    char    junk = 0;\n    int     ch;\n\n    if ((ch = attr_scan0_string(fp, str_buf, context)) < 0)\n\treturn (-1);\n    if (sscanf(STR(str_buf), \"%lu%c\", ptr, &junk) != 1 || junk != 0) {\n\tacl_msg_warn(\"%s: malformed numerical data from %s while reading %s: %.100s\",\n\t\t myname, ACL_VSTREAM_PATH(fp), context, STR(str_buf));\n\treturn (-1);\n    }\n    return (ch);\n}", "path": "acl/lib_tls/attr/attr_scan0.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* acl_ring_pop_tail - pop ring's tail entry out from ring */\n", "func_signal": "ACL_RING *acl_ring_pop_tail(ACL_RING *ring)", "code": "{\n\tACL_RING   *pred;\n\n\tif (ring == NULL)\n\t\treturn NULL;\n\n\tpred = ring->pred;\n\tif (pred == ring)\n\t\treturn NULL;\n\n\tacl_ring_detach(pred);\n\n\treturn pred;\n}", "path": "acl/lib_acl/src/stdlib/common/acl_ring.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* \u0631DNS\u046f */\n", "func_signal": "void dns_server_close(DNS_SERVER *dns)", "code": "{\n\tacl_msgio_close(dns->listener);\n\tacl_pthread_pool_destroy(dns->wq);\n\tacl_myfree(dns);\n}", "path": "acl/app/jaws/global/dns_server.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* doze - sleep a while */\n", "func_signal": "void acl_doze(unsigned delay)", "code": "{\n#ifdef\tACL_UNIX\n\tstruct timeval tv;\n\n\ttv.tv_sec = delay / 1000;\n\ttv.tv_usec = (suseconds_t) (delay - tv.tv_sec * 1000) * 1000;\n\twhile (select(0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &tv) < 0) {\n\t\tif (acl_last_error() != ACL_EINTR) {\n\t\t\tchar tbuf[256];\n\t\t\tacl_msg_fatal(\"doze: select: %s\",\n\t\t\t\tacl_last_strerror(tbuf, sizeof(tbuf)));\n\t\t}\n\t}\n#elif\tdefined(ACL_WINDOWS)\n\tSleep(delay);\n#else\n#error \"unknown OS\"\n#endif\n}", "path": "acl/lib_acl/src/stdlib/iostuff/acl_doze.c", "commit_date": "2019-07-28 00:00:00", "repo_name": "acl-dev/acl", "stars": 2731, "license": "lgpl-3.0", "language": "c", "size": 122691}
{"docstring": "/* Do basic preparations - persistent fds, filenames, etc. */\n", "func_signal": "static void set_up_environment(void)", "code": "{\n\n    if (sinkhole_stds) {\n        devnul_handle = CreateFile(\n            \"nul\",\n            GENERIC_READ | GENERIC_WRITE,\n            FILE_SHARE_READ | FILE_SHARE_WRITE,\n            NULL,\n            OPEN_EXISTING,\n            0,\n            NULL\n        );\n\n        if (devnul_handle == INVALID_HANDLE_VALUE) {\n            PFATAL(\"Unable to open the nul device.\");\n        }\n    }\n\n    if (!prog_in) {\n\n        u8* use_dir = getenv(\"TMP\");\n        prog_in = alloc_printf(\"%s\\\\.afl-analyze-temp-%u\", use_dir, GetCurrentProcessId());\n\n    }\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* Write output file. */\n", "func_signal": "static void write_to_file(u8* path, u8* mem, u32 len)", "code": "{\n\n  s32 ret;\n\n  _unlink(path); /* Ignore errors */\n  ret = _open(path, O_RDWR | O_CREAT | O_EXCL | O_BINARY, 0600);\n\n  if (ret < 0) PFATAL(\"Unable to create '%s'\", path);\n\n  ck_write(ret, mem, len, path);\n\n  _lseek(ret, 0, SEEK_SET);\n  _close(ret);\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "// function that was used to build the lookup tables for the packet decoder\n", "func_signal": "void build_luts()", "code": "{\n\tfor (int i = 0; i<256; i++) {\n\t\topc_lut[i] = ppt_invalid;\n\t}\n\n\tfor (int i = 0; i<256; i++) {\n\t\text_lut[i] = ppt_invalid;\n\t}\n\n\tfor (int i = 0; i<256; i++) {\n\t\topc_size_lut[i] = 0;\n\t\text_size_lut[i] = 0;\n\t}\n\n\t//ext packets\n\topc_lut[pt_opc_ext] = PPT_EXT;\n\topc_size_lut[pt_opc_ext] = 1; // not really important\n\n\t\t\t\t\t\t\t\t  //pad packet\n\topc_lut[pt_opc_pad] = ppt_pad;\n\topc_size_lut[pt_opc_pad] = 1;\n\n\t//tip packet\n\tfor (int i = 0; i<8; i++) {\n\t\tunsigned char opcode = (unsigned char)((i << 5) + 0xd);\n\n\t\tif (i == 0) {\n\t\t\topc_lut[opcode] = ppt_tip;\n\t\t\topc_size_lut[opcode] = 1;\n\t\t}\n\t\telse if (i == 1) {\n\t\t\topc_lut[opcode] = ppt_tip;\n\t\t\topc_size_lut[opcode] = 1 + 2;\n\t\t}\n\t\telse if (i == 2) {\n\t\t\topc_lut[opcode] = ppt_tip;\n\t\t\topc_size_lut[opcode] = 1 + 4;\n\t\t}\n\t\telse if ((i == 3) || (i == 4)) {\n\t\t\topc_lut[opcode] = ppt_tip;\n\t\t\topc_size_lut[opcode] = 1 + 6;\n\t\t}\n\t\telse if (i == 6) {\n\t\t\topc_lut[opcode] = ppt_tip;\n\t\t\topc_size_lut[opcode] = 1 + 8;\n\t\t}\n\t}\n\n\t//tip.pge packet\n\tfor (int i = 0; i<8; i++) {\n\t\tunsigned char opcode = (unsigned char)((i << 5) + 0x11);\n\n\t\tif (i == 0) {\n\t\t\topc_lut[opcode] = ppt_tip_pge;\n\t\t\topc_size_lut[opcode] = 1;\n\t\t}\n\t\telse if (i == 1) {\n\t\t\topc_lut[opcode] = ppt_tip_pge;\n\t\t\topc_size_lut[opcode] = 1 + 2;\n\t\t}\n\t\telse if (i == 2) {\n\t\t\topc_lut[opcode] = ppt_tip_pge;\n\t\t\topc_size_lut[opcode] = 1 + 4;\n\t\t}\n\t\telse if ((i == 3) || (i == 4)) {\n\t\t\topc_lut[opcode] = ppt_tip_pge;\n\t\t\topc_size_lut[opcode] = 1 + 6;\n\t\t}\n\t\telse if (i == 6) {\n\t\t\topc_lut[opcode] = ppt_tip_pge;\n\t\t\topc_size_lut[opcode] = 1 + 8;\n\t\t}\n\t}\n\n\t//tip.pgd packet\n\tfor (int i = 0; i<8; i++) {\n\t\tunsigned char opcode = (unsigned char)((i << 5) + 0x1);\n\n\t\tif (i == 0) {\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\n\t\t\topc_size_lut[opcode] = 1;\n\t\t}\n\t\telse if (i == 1) {\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\n\t\t\topc_size_lut[opcode] = 1 + 2;\n\t\t}\n\t\telse if (i == 2) {\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\n\t\t\topc_size_lut[opcode] = 1 + 4;\n\t\t}\n\t\telse if ((i == 3) || (i == 4)) {\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\n\t\t\topc_size_lut[opcode] = 1 + 6;\n\t\t}\n\t\telse if (i == 6) {\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\n\t\t\topc_size_lut[opcode] = 1 + 8;\n\t\t}\n\t}\n\n\t//fup packet\n\tfor (int i = 0; i<8; i++) {\n\t\tunsigned char opcode = (unsigned char)((i << 5) + 0x1d);\n\n\t\tif (i == 0) {\n\t\t\topc_lut[opcode] = ppt_fup;\n\t\t\topc_size_lut[opcode] = 1;\n\t\t}\n\t\telse if (i == 1) {\n\t\t\topc_lut[opcode] = ppt_fup;\n\t\t\topc_size_lut[opcode] = 1 + 2;\n\t\t}\n\t\telse if (i == 2) {\n\t\t\topc_lut[opcode] = ppt_fup;\n\t\t\topc_size_lut[opcode] = 1 + 4;\n\t\t}\n\t\telse if ((i == 3) || (i == 4)) {\n\t\t\topc_lut[opcode] = ppt_fup;\n\t\t\topc_size_lut[opcode] = 1 + 6;\n\t\t}\n\t\telse if (i == 6) {\n\t\t\topc_lut[opcode] = ppt_fup;\n\t\t\topc_size_lut[opcode] = 1 + 8;\n\t\t}\n\t}\n\n\t//mode packet\n\topc_lut[pt_opc_mode] = ppt_mode;\n\topc_size_lut[pt_opc_mode] = 2;\n\n\t//tsc packet\n\topc_lut[pt_opc_tsc] = ppt_tsc;\n\topc_size_lut[pt_opc_tsc] = 8;\n\n\t//mtc packet\n\topc_lut[pt_opc_mtc] = ppt_mtc;\n\topc_size_lut[pt_opc_mtc] = 2;\n\n\t//cyc packet\n\tfor (int i = 0; i<64; i++) {\n\t\tunsigned char opcode = (unsigned char)((i << 2) + 0x3);\n\t\topc_lut[opcode] = ppt_cyc;\n\t\topc_size_lut[opcode] = 1;\n\t}\n\n\t//tnt packets\n\tfor (int i = 1; i <= 6; i++) {\n\t\tfor (int bits = 0; bits<(1 << i); bits++) {\n\t\t\tunsigned char opcode = (unsigned char)((1 << (i + 1)) + (bits << 1));\n\t\t\topc_lut[opcode] = ppt_tnt_8;\n\t\t\topc_size_lut[opcode] = 1;\n\t\t}\n\t}\n\n\t//////extensions///////\n\n\t//psb packet\n\text_lut[pt_ext_psb] = ppt_psb;\n\text_size_lut[pt_ext_psb] = 16;\n\n\t//long tnt packet\n\text_lut[pt_ext_tnt_64] = ppt_tnt_64;\n\text_size_lut[pt_ext_tnt_64] = 8;\n\n\t//pip packet\n\text_lut[pt_ext_pip] = ppt_pip;\n\text_size_lut[pt_ext_pip] = 8;\n\n\t//ovf packet\n\text_lut[pt_ext_ovf] = ppt_ovf;\n\text_size_lut[pt_ext_ovf] = 2;\n\n\t//psbend packet\n\text_lut[pt_ext_psbend] = ppt_psbend;\n\text_size_lut[pt_ext_psbend] = 2;\n\n\t//cbr packet\n\text_lut[pt_ext_cbr] = ppt_cbr;\n\text_size_lut[pt_ext_cbr] = 4;\n\n\t//tma packet\n\text_lut[pt_ext_tma] = ppt_tma;\n\text_size_lut[pt_ext_tma] = 8;\n\n\t//stop packet\n\text_lut[pt_ext_stop] = ppt_stop;\n\text_size_lut[pt_ext_stop] = 2;\n\n\t//vmcs packet\n\text_lut[pt_ext_vmcs] = ppt_vmcs;\n\text_size_lut[pt_ext_vmcs] = 8;\n\n\t//exstop packet\n\text_lut[pt_ext_exstop] = ppt_exstop;\n\text_size_lut[pt_ext_exstop] = 2;\n\n\t//exstop-ip packet\n\text_lut[pt_ext_exstop_ip] = ppt_exstop;\n\text_size_lut[pt_ext_exstop_ip] = 2;\n\n\t//mwait packet\n\text_lut[pt_ext_mwait] = ppt_mwait;\n\text_size_lut[pt_ext_mwait] = 10;\n\n\t//pwre packet\n\text_lut[pt_ext_pwre] = ppt_pwre;\n\text_size_lut[pt_ext_pwre] = 4;\n\n\t//pwrx packet\n\text_lut[pt_ext_pwrx] = ppt_pwrx;\n\text_size_lut[pt_ext_pwrx] = 8;\n\n\t//ptw packet\n\tfor (int i = 0; i<2; i++) {\n\t\tfor (int j = 0; j<2; j++) {\n\t\t\tunsigned char opcode = (unsigned char)((i << 7) + (j << 5) + 0x12);\n\t\t\text_lut[opcode] = ppt_ptw;\n\t\t\tif (j == 0) {\n\t\t\t\text_size_lut[opcode] = 6;\n\t\t\t}\n\t\t\telse if (j == 1) {\n\t\t\t\text_size_lut[opcode] = 10;\n\t\t\t}\n\t\t}\n\t}\n\n\t//ext2\n\text_lut[pt_ext_ext2] = PPT_EXT;\n\text_size_lut[pt_ext_ext2] = 1; // not really important\n\n\tdump_lut(opc_lut, \"opc_lut\");\n\tdump_lut(ext_lut, \"ext_lut\");\n\tdump_lut(opc_size_lut, \"opc_size_lut\");\n\tdump_lut(ext_size_lut, \"ext_size_lut\");\n}", "path": "winafl/ptdecode.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* Main entry point */\n", "func_signal": "int main(int argc, char** argv)", "code": "{\n\n  s32 opt;\n  u8  mem_limit_given = 0, timeout_given = 0, qemu_mode = 0;\n  char** use_argv;\n\n  doc_path = \"docs\";\n\n#ifdef USE_COLOR\n  enable_ansi_console();\n#endif\n\n  SAYF(cCYA \"afl-analyze for Windows \" cBRI VERSION cRST \" by <l4ys.tw@gmail.com>\\n\");\n  SAYF(\"Based on WinAFL \" cBRI VERSION cRST \" by <ifratric@google.com>\\n\");\n  SAYF(\"Based on AFL \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n  \n  while ((opt = getopt(argc,argv,\"+i:f:m:t:D:eQY\")) > 0)\n\n    switch (opt) {\n\n      case 'D': /* dynamorio dir */\n\n        if(dynamorio_dir) FATAL(\"Multiple -D options not supported\");\n        dynamorio_dir = optarg;\n        break;\n\n      case 'i':\n\n        if (in_file) FATAL(\"Multiple -i options not supported\");\n        in_file = optarg;\n        break;\n\n      case 'f':\n\n        if (prog_in) FATAL(\"Multiple -f options not supported\");\n        use_stdin = 0;\n        prog_in   = optarg;\n        break;\n\n      case 'e':\n\n        if (edges_only) FATAL(\"Multiple -e options not supported\");\n        edges_only = 1;\n        break;\n\n      case 'm': {\n\n          u8 suffix = 'M';\n\n          if (mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if (!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if (sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if (mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n        }\n\n        break;\n\n      case 't':\n\n        if (timeout_given) FATAL(\"Multiple -t options not supported\");\n        timeout_given = 1;\n\n        exec_tmout = atoi(optarg);\n\n        if (exec_tmout < 10 || optarg[0] == '-')\n          FATAL(\"Dangerously low value of -t\");\n\n        break;\n\n      case 'Q':\n\n        FATAL(\"QEMU mode not supported on Windows\");\n        break;\n        \n      case 'Y':\n\n        if (dynamorio_dir) FATAL(\"Dynamic-instrumentation (DRIO) is uncompatible with static-instrumentation\");\n        drioless = 1;\n\n        break;\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if (!in_file) usage(argv[0]);\n  if(!drioless) {\n    if(optind == argc || !dynamorio_dir) usage(argv[0]);\n  }\n\n  extract_client_params(argc, argv);\n  optind++;\n\n  if (getenv(\"AFL_NO_SINKHOLE\")) sinkhole_stds = 0;\n  \n  use_hex_offsets = !!getenv(\"AFL_ANALYZE_HEX\");\n\n  setup_shm();\n  setup_watchdog_timer();\n  setup_signal_handlers();\n\n  set_up_environment();\n\n  find_binary(argv[optind]);\n  detect_file_args(argv + optind);\n\n  use_argv = argv + optind;\n\n  SAYF(\"\\n\");\n  read_initial_file();\n\n  ACTF(\"Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...\",\n       mem_limit, exec_tmout, edges_only ? \", edges only\" : \"\");\n\n  run_target(use_argv, in_data, in_len, 1);\n\n  if (child_timed_out)\n    FATAL(\"Target binary times out (adjusting -t may help).\");\n\n  if (!anything_set()) FATAL(\"No instrumentation detected.\");\n\n  analyze(use_argv);\n\n  OKF(\"We're done here. Have a nice day!\\n\");\n\n  exit(0);\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* Get rid of shared memory and temp files (atexit handler). */\n", "func_signal": "static void remove_shm(void)", "code": "{\n\n  UnmapViewOfFile(trace_bits);\n  CloseHandle(shm_handle);\n  if (prog_in) _unlink(prog_in); /* Ignore errors */\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "// sign extend\n", "func_signal": "inline static uint64_t sext(uint64_t val, uint8_t sign)", "code": "{\n\tuint64_t signbit, mask;\n\n\tsignbit = 1ull << (sign - 1);\n\tmask = ~0ull << sign;\n\n\treturn val & signbit ? val | mask : val & ~mask;\n}", "path": "winafl/ptdecode.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "// sets the node as the least recently used\n", "func_signal": "void cache_node_touch(tracelet_cache_node *node)", "code": "{\n\t// printf(\"accessing %p in cache\\n\", node);\n\n\tif (!node->lru_prev) return; //already at the beginning\n\telse node->lru_prev->lru_next = node->lru_next;\n\n\tif (node->lru_next) node->lru_next->lru_prev = node->lru_prev;\n\telse tracelet_cache.lru_last = node->lru_prev;\n\n\tnode->lru_prev = NULL;\n\tnode->lru_next = tracelet_cache.lru_first;\n\tif (node->lru_next) node->lru_next->lru_prev = node;\n\ttracelet_cache.lru_first = node;\n}", "path": "winafl/ptdecode.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* Execute target application. Returns exec checksum, or 0 if program\n   times out. */\n", "func_signal": "static u32 run_target(char** argv, u8* mem, u32 len, u8 first_run)", "code": "{\n\n  int status = 0;\n  char command[] = \"F\";\n  DWORD num_read;\n  char result = 0;\n  u32 cksum;\n\n  memset(trace_bits, 0, MAP_SIZE);\n  MemoryBarrier();\n\n  write_to_file(prog_in, mem, len);\n\n  if (!is_child_running()) {\n      destroy_target_process(0);\n      create_target_process(argv);\n  }\n\n  child_timed_out = 0;\n  memset(trace_bits, 0, MAP_SIZE);\n  MemoryBarrier();\n\n  //TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN\n  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n  if (result == 'K')\n  {\n      //a workaround for first cycle\n      ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n  }\n  if (result != 'P')\n  {\n      FATAL(\"Unexpected result from pipe! expected 'P', instead received '%c'\\n\", result);\n  }\n  //END OF TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN\n  WriteFile(\n      pipe_handle,  // handle to pipe\n      command,      // buffer to write from\n      1,            // number of bytes to write\n      &num_read,    // number of bytes written\n      NULL);        // not overlapped I/O\n\n  watchdog_timeout_time = get_cur_time() + exec_tmout;\n\n  if (exec_tmout) {\n      watchdog_enabled = 1;\n  }\n\n  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n\n  if (exec_tmout) {\n      watchdog_enabled = 0;\n  }\n\n  MemoryBarrier();\n\n  /* Clean up bitmap, analyze exit condition, etc. */\n\n  classify_counts(trace_bits);\n  total_execs++;\n\n  destroy_target_process(2000);\n\n  if (stop_soon) {\n    SAYF(cRST cLRD \"\\n+++ Analysis aborted by user +++\\n\" cRST);\n    exit(1);\n  }\n\n  /* Always discard inputs that time out. */\n\n  if (child_timed_out) {\n\n    exec_hangs++;\n    return 0;\n\n  }\n\n  cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n  /* We don't actually care if the target is crashing or not,\n     except that when it does, the checksum should be different. */\n\n  cksum ^= 0xffffffff;\n\n  if (first_run) orig_cksum = cksum;\n\n  return cksum;\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "// constructs the cache node from the decoder state, tracelet etc\n// and adds it to the cache\n", "func_signal": "static inline void add_cache_node(\n\tuint8_t *tracelet, size_t tracelet_size, uint64_t hash,\n\tdecoder_state *state_before, decoder_state *state_after,\n\tstruct pt_retstack *retstack_before, struct pt_retstack *retstack_after,\n\tint stack_added, int stack_removed,\n\tstruct coverage_cache_t *coverage_cache)", "code": "{\n\tstack_removed = -stack_removed;\n\tstack_added += stack_removed;\n\n\tif (stack_removed > (pt_retstack_size + 1)) stack_removed = (pt_retstack_size + 1);\n\n\tif (stack_added < 0) stack_added = 0;\n\tif (stack_added >(pt_retstack_size + 1)) stack_added = (pt_retstack_size + 1);\n\n\tsize_t node_size = sizeof(tracelet_cache_node) +\n\t\tstack_removed * sizeof(uint64_t) + stack_added * sizeof(uint64_t) +\n\t\tcoverage_cache->size * sizeof(uint32_t) + coverage_cache->size * sizeof(uint8_t) +\n\t\ttracelet_size;\n\n\ttracelet_cache_node *cache_node = (tracelet_cache_node *)malloc(node_size);\n\n\tcache_node->size = node_size;\n\tcache_node->hash = hash;\n\n\tuint8_t* ptr = (uint8_t*)cache_node + sizeof(tracelet_cache_node);\n\tcache_node->stack_prev = (uint64_t *)ptr;\n\tcache_node->stack_removed = stack_removed;\n\tptr += stack_removed * sizeof(uint64_t);\n\tcache_node->stack_next = (uint64_t *)ptr;\n\tcache_node->stack_added = stack_added;\n\tptr += stack_added * sizeof(uint64_t);\n\tcache_node->map_offsets = (uint32_t *)ptr;\n\tptr += coverage_cache->size * sizeof(uint32_t);\n\tcache_node->map_updates = ptr;\n\tcache_node->map_update_size = coverage_cache->size;\n\tptr += coverage_cache->size * sizeof(uint8_t);\n\tcache_node->tracelet = ptr;\n\tcache_node->tracelet_size = (uint32_t)tracelet_size;\n\n\tuint8_t top;\n\ttop = retstack_before->top;\n\tfor (int i = 0; i < stack_removed; i++) {\n\t\ttop = (!top ? pt_retstack_size : top - 1);\n\t\tcache_node->stack_prev[i] = retstack_before->stack[top];\n\t}\n\n\ttop = retstack_after->top;\n\tfor (int i = 0; i < stack_added; i++) {\n\t\ttop = (!top ? pt_retstack_size : top - 1);\n\t\tcache_node->stack_next[stack_added - i - 1] = retstack_after->stack[top];\n\t}\n\n\tmemcpy(cache_node->map_offsets, coverage_cache->map_offsets, coverage_cache->size * sizeof(uint32_t));\n\tmemcpy(cache_node->map_updates, coverage_cache->counters, coverage_cache->size * sizeof(uint8_t));\n\n\tmemcpy(cache_node->tracelet, tracelet, tracelet_size);\n\n\tcache_node->state_prev = *state_before;\n\tcache_node->state_next = *state_after;\n\n\tcache_node_add(cache_node);\n}", "path": "winafl/ptdecode.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "// looks up if we already have the tracelet in cache and if so update\n// the state and coverage from the cache entry\n", "func_signal": "inline static bool process_tracelet_from_cache(uint64_t hash,\n\tdecoder_state *state, unsigned char *tracelet, \n\tsize_t tracelet_size, struct pt_retstack *retstack,\n\tint coverage_kind)", "code": "{\n\n\ttracelet_cache_node *cache_node = cache_find_node(hash, state, tracelet, tracelet_size, retstack);\n\n\tif (!cache_node) return false;\n\n\t// mark the node as least recently used\n\tcache_node_touch(cache_node);\n\n\t// update state from cache\n\t*state = cache_node->state_next;\n\n\t// update stack if needed\n\tif (cache_node->stack_removed || cache_node->stack_added) {\n\t\tuint8_t top, bottom;\n\t\ttop = retstack->top;\n\t\tbottom = retstack->bottom;\n\n\t\tfor (uint32_t i = 0; i < cache_node->stack_removed; i++) {\n\t\t\ttop = (!top ? pt_retstack_size : top - 1);\n\t\t}\n\n\t\tfor (uint32_t i = 0; i < cache_node->stack_added; i++) {\n\t\t\tretstack->stack[top] = cache_node->stack_next[i];\n\t\t\ttop = (top == pt_retstack_size ? 0 : top + 1);\n\t\t\tif (bottom == top) bottom = (bottom == pt_retstack_size ? 0 : bottom + 1);\n\t\t}\n\n\t\tretstack->top = top;\n\t\tretstack->bottom = bottom;\n\t}\n\n\t// update trace_bits\n\tswitch (coverage_kind) {\n\tcase COVERAGE_BB:\n\t\tfor (uint32_t i = 0; i < cache_node->map_update_size; i++) {\n\t\t\ttrace_bits[cache_node->map_offsets[i]] += cache_node->map_updates[i];\n\t\t}\n\t\tbreak;\n\tcase COVERAGE_EDGE:\n\t\tif (cache_node->map_update_size) {\n\t\t\ttrace_bits[(cache_node->map_offsets[0] ^ previous_offset) % MAP_SIZE]++;\n\t\t\tfor (uint32_t i = 1; i < cache_node->map_update_size - 1; i++) {\n\t\t\t\ttrace_bits[cache_node->map_offsets[i]] += cache_node->map_updates[i];\n\t\t\t}\n\t\t\tprevious_offset = cache_node->map_offsets[cache_node->map_update_size - 1];\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn true;\n}", "path": "winafl/ptdecode.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "//quoting on Windows is weird\n", "func_signal": "size_t ArgvQuote(char *in, char *out)", "code": "{\n\tint needs_quoting = 0;\n\tsize_t size = 0;\n\tchar *p = in;\n\tsize_t i;\n\n\t//check if quoting is necessary\n\tif (strchr(in, ' ')) needs_quoting = 1;\n\tif (strchr(in, '\\\"')) needs_quoting = 1;\n\tif (strchr(in, '\\t')) needs_quoting = 1;\n\tif (strchr(in, '\\n')) needs_quoting = 1;\n\tif (strchr(in, '\\v')) needs_quoting = 1;\n\tif (!needs_quoting) {\n\t\tsize = strlen(in);\n\t\tif (out) memcpy(out, in, size);\n\t\treturn size;\n\t}\n\n\tif (out) out[size] = '\\\"';\n\tsize++;\n\n\twhile (*p) {\n\t\tsize_t num_backslashes = 0;\n\t\twhile ((*p) && (*p == '\\\\')) {\n\t\t\tp++;\n\t\t\tnum_backslashes++;\n\t\t}\n\n\t\tif (*p == 0) {\n\t\t\tfor (i = 0; i < (num_backslashes * 2); i++) {\n\t\t\t\tif (out) out[size] = '\\\\';\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\telse if (*p == '\\\"') {\n\t\t\tfor (i = 0; i < (num_backslashes * 2 + 1); i++) {\n\t\t\t\tif (out) out[size] = '\\\\';\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tif (out) out[size] = *p;\n\t\t\tsize++;\n\t\t}\n\t\telse {\n\t\t\tfor (i = 0; i < num_backslashes; i++) {\n\t\t\t\tif (out) out[size] = '\\\\';\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tif (out) out[size] = *p;\n\t\t\tsize++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\tif (out) out[size] = '\\\"';\n\tsize++;\n\n\treturn size;\n}", "path": "winafl/winaflpt-debug.c", "commit_date": "2019-02-04 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* Show the legend */\n", "func_signal": "static void show_legend(void)", "code": "{\n\n  SAYF(\"    \" cLGR bgGRA \" 01 \" cRST \" - no-op block              \"\n              cBLK bgLGN \" 01 \" cRST \" - suspected length field\\n\"\n       \"    \" cBRI bgGRA \" 01 \" cRST \" - superficial content      \"\n              cBLK bgYEL \" 01 \" cRST \" - suspected cksum or magic int\\n\"\n       \"    \" cBLK bgCYA \" 01 \" cRST \" - critical stream          \"\n              cBLK bgLRD \" 01 \" cRST \" - suspected checksummed block\\n\"\n       \"    \" cBLK bgMGN \" 01 \" cRST \" - \\\"magic value\\\" section\\n\\n\");\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "// checks if the IP address is in one of the modules we are interested in\n// and updates the coverage_cache datastructure\n", "func_signal": "inline static int update_coverage_cache(struct coverage_cache_t *coverage_cache,\n\tuint64_t next_ip, int coverage_kind)", "code": "{\n\n\tuint32_t offset;\n\n\tif (next_ip < current_range->start) {\n\t\tdo {\n\t\t\tcurrent_range--;\n\t\t} while (next_ip < current_range->start);\n\t}\n\telse if (next_ip > current_range->end) {\n\t\tdo {\n\t\t\tcurrent_range++;\n\t\t} while (next_ip > current_range->end);\n\t}\n\n\tif (!current_range->collect) return 0;\n\n\t// printf(\"ip: %p\\n\", (void*)next_ip);\n\n\toffset = (uint32_t)(next_ip - current_range->start);\n\n\tswitch (coverage_kind) {\n\tcase COVERAGE_BB:\n\t\ttracelet_coverage_add_bb(coverage_cache, offset);\n\t\tbreak;\n\tcase COVERAGE_EDGE:\n\t\ttracelet_coverage_add_edge(coverage_cache, offset);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}", "path": "winafl/ptdecode.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "//quoting on Windows is weird\n", "func_signal": "size_t ArgvQuote(char *in, char *out)", "code": "{\n  int needs_quoting = 0;\n  size_t size = 0;\n  char *p = in;\n  size_t i;\n\n  //check if quoting is necessary\n  if(strchr(in, ' ')) needs_quoting = 1;\n  if(strchr(in, '\\\"')) needs_quoting = 1;\n  if(strchr(in, '\\t')) needs_quoting = 1;\n  if(strchr(in, '\\n')) needs_quoting = 1;\n  if(strchr(in, '\\v')) needs_quoting = 1;\n  if(!needs_quoting) {\n    size = strlen(in);\n    if(out) memcpy(out, in, size);\n    return size;\n  }\n\n  if(out) out[size] = '\\\"';\n  size++;\n\n  while(*p) {\n    size_t num_backslashes = 0;\n    while((*p) && (*p == '\\\\')) {\n      p++;\n      num_backslashes++;\n    }\n\n    if(*p == 0) {\n      for(i = 0; i < (num_backslashes*2); i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      break;\n    } else if(*p == '\\\"') {\n      for(i = 0; i < (num_backslashes*2 + 1); i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      if(out) out[size] = *p;\n      size++;\n    } else {\n      for(i = 0; i < num_backslashes; i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      if(out) out[size] = *p;\n      size++;\n    }\n\n    p++;\n  }\n\n  if(out) out[size] = '\\\"';\n  size++;\n\n  return size;\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* Helper function to display a human-readable character. */\n", "func_signal": "static void show_char(u8 val)", "code": "{\n\n  if (val <= 32 || val >= 127)\n    SAYF(\"#%02x\", val);\n  else\n    SAYF(\" %c \", val);\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* Configure shared memory. */\n", "func_signal": "static void setup_shm(void)", "code": "{\n\n  char* shm_str = NULL;\n  unsigned int seeds[2];\n  u64 name_seed;\n  u8 attempts = 0;\n\n  while(attempts < 5) {\n    if(fuzzer_id == NULL) {\n      // If it is null, it means we have to generate a random seed to name the instance\n      rand_s(&seeds[0]);\n      rand_s(&seeds[1]);\n      name_seed = ((u64)seeds[0] << 32) | seeds[1];\n      fuzzer_id = (char *)alloc_printf(\"%I64x\", name_seed);\n    }\n\n    shm_str = (char *)alloc_printf(\"afl_shm_%s\", fuzzer_id);\n\n    shm_handle = CreateFileMapping(\n                   INVALID_HANDLE_VALUE,    // use paging file\n                   NULL,                    // default security\n                   PAGE_READWRITE,          // read/write access\n                   0,                       // maximum object size (high-order DWORD)\n                   MAP_SIZE,                // maximum object size (low-order DWORD)\n                   (char *)shm_str);        // name of mapping object\n\n    if(shm_handle == NULL) {\n      if(GetLastError() == ERROR_ALREADY_EXISTS) {\n        // We need another attempt to find a unique section name\n        attempts++;\n        ck_free(shm_str);\n        ck_free(fuzzer_id);\n        fuzzer_id = NULL;\n        continue;\n      }\n      else {\n        PFATAL(\"CreateFileMapping failed\");\n      }\n    }\n\n    // We found a section name that works!\n    break;\n  }\n\n  if(attempts == 5) {\n    FATAL(\"Could not find a section name.\\n\");\n  }\n\n  atexit(remove_shm);\n\n  ck_free(shm_str);\n\n  trace_bits = (u8 *)MapViewOfFile(\n    shm_handle,          // handle to map object\n    FILE_MAP_ALL_ACCESS, // read/write permission\n    0,\n    0,\n    MAP_SIZE\n  );\n\n  if (!trace_bits) PFATAL(\"MapViewOfFile() failed\");\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "// checks if the IP address is in one of the modules we are interested in\n// and updates the coverage map\n", "func_signal": "inline static int update_coverage_map(uint64_t next_ip, int coverage_kind)", "code": "{\n\tuint32_t offset;\n\n\tif (next_ip < current_range->start) {\n\t\tdo {\n\t\t\tcurrent_range--;\n\t\t} while (next_ip < current_range->start);\n\t} else if (next_ip > current_range->end) {\n\t\tdo {\n\t\t\tcurrent_range++;\n\t\t} while (next_ip > current_range->end);\n\t}\n\n\tif (!current_range->collect) return 0;\n\n\t// printf(\"ip: %p\\n\", (void*)next_ip);\n\n\toffset = (uint32_t)(next_ip - current_range->start);\n\n\tswitch (coverage_kind) {\n\tcase COVERAGE_BB:\n\t\ttrace_bits[offset % MAP_SIZE]++;\n\t\tbreak;\n\tcase COVERAGE_EDGE:\n\t\ttrace_bits[(offset ^ previous_offset) % MAP_SIZE]++;\n\t\tprevious_offset = offset >> 1;\n\tbreak;\n\t}\n\n\treturn 1;\n}", "path": "winafl/ptdecode.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* Display usage hints. */\n", "func_signal": "static void usage(u8* argv0)", "code": "{\n\n  SAYF(\"\\n%s [ options ] -- [instrumentation options] -- \\\\path\\\\to\\\\target_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -i file       - input test case to be analyzed by the tool\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -f file       - input file read by the tested program (stdin)\\n\"\n       \"  -t msec       - timeout for each run (%u ms)\\n\"\n       \"  -m megs       - memory limit for child process (%u MB)\\n\"\n\n       \"Analysis settings:\\n\\n\"\n\n       \"  -e            - look for edge coverage only, ignore hit counts\\n\\n\"\n\n       \"For additional tips, please consult %s/README.\\n\\n\",\n\n       argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);\n\n  exit(1);\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "// returns the type of the first packet or ppt_invalid\n", "func_signal": "int get_next_tracelet(unsigned char **data, size_t *size,\n\tunsigned char **tracelet_data, size_t *tracelet_size)", "code": "{\n\tunsigned char opcode;\n\tunsigned char opcodesize;\n\tunsigned char previous_opcode = ppt_invalid;\n\tint ret = ppt_tnt_8;\n\n\twhile (*size) {\n\n\t\tif (!get_next_opcode(data, size, &opcode, &opcodesize))\n\t\t\treturn ppt_invalid;\n\n\t\tif (opcode == ppt_invalid) return ppt_invalid;\n\n\t\t// printf(\"packet type: %d\\n\", opcode);\n\n\t\tswitch (opcode) {\n\t\tcase ppt_tnt_8:\n\t\tcase ppt_tnt_64:\n\t\t\t// merge tiny tracelets\n\t\t\tif (*tracelet_size > MIN_TRACELET_SIZE) {\n\t\t\t\t// always cut before tnt preceeded by non-tnt\n\t\t\t\tif (previous_opcode != ppt_invalid &&\n\t\t\t\t\tprevious_opcode != ppt_tnt_8 &&\n\t\t\t\t\tprevious_opcode != ppt_tnt_64)\n\t\t\t\t{\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\t// cut very long streams of tnt packets\n\t\t\t\tif (*tracelet_size > MAX_TRACELET_SIZE) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(*tracelet_data, *data, opcodesize);\n\t\t\t*tracelet_data += opcodesize;\n\t\t\t*tracelet_size += opcodesize;\n\t\t\t*size -= opcodesize;\n\t\t\t*data += opcodesize;\n\t\t\tprevious_opcode = opcode;\n\t\t\tbreak;\n\t\tcase ppt_psb:\n\t\t\t// let the caller know there is a psb in this tracelet\n\t\t\tret = ppt_psb;\n\t\tcase ppt_psbend:\n\t\tcase ppt_fup:\n\t\tcase ppt_tip:\n\t\tcase ppt_tip_pge:\n\t\tcase ppt_tip_pgd:\n\t\tcase ppt_ovf:\n\t\tcase ppt_mode:\n\t\t\t// just copy these packets\n\t\t\tmemcpy(*tracelet_data, *data, opcodesize);\n\t\t\t*tracelet_data += opcodesize;\n\t\t\t*tracelet_size += opcodesize;\n\t\t\t*size -= opcodesize;\n\t\t\t*data += opcodesize;\n\t\t\tprevious_opcode = opcode;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// skip over all other packets\n\t\t\t*size -= opcodesize;\n\t\t\t*data += opcodesize;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}", "path": "winafl/ptdecode.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/* See if any bytes are set in the bitmap. */\n", "func_signal": "static inline u8 anything_set(void)", "code": "{\n\n  u32* ptr = (u32*)trace_bits;\n  u32  i   = (MAP_SIZE >> 2);\n\n  while (i--) if (*(ptr++)) return 1;\n\n  return 0;\n\n}", "path": "winafl/afl-analyze.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "googleprojectzero/winafl", "stars": 2210, "license": "apache-2.0", "language": "c", "size": 5442}
{"docstring": "/**\n * @brief exist_cache Check a key is exist in memcached.\n *\n * @param thr_arg The arg of thread.\n * @param key The string of the key.\n *\n * @return 1 for yes and -1 for no.\n */\n", "func_signal": "int exist_cache(thr_arg_t *thr_arg, const char *key)", "code": "{\n    int rst = -1;\n    if (settings.cache_on == false)\n        return rst;\n    if (thr_arg->cache_conn == NULL)\n        return rst;\n\n    memcached_st *memc = thr_arg->cache_conn;\n    memcached_return rc;\n\n    size_t valueLen = 0;\n    uint32_t flags;\n    char *value = memcached_get(memc, key, strlen(key), &valueLen, &flags, &rc);\n    //rc = memcached_exist(memc, key, strlen(key));\n\n    if (rc == MEMCACHED_SUCCESS) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Key[%s] Exist.\", key);\n        rst = 1;\n    } else if (rc == MEMCACHED_CONNECTION_FAILURE) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Conn Failed!\");\n        //retry_cache(thr_arg);\n    } else {\n        const char *str_rc = memcached_strerror(memc, rc);\n        LOG_PRINT(LOG_DEBUG, \"Cache Result: %s\", str_rc);\n    }\n    free(value);\n\n    return rst;\n}", "path": "zimg/src/zcache.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Render a value to text. */\n", "func_signal": "static char *print_value(cJSON *item,int depth,int fmt)", "code": "{\n\tchar *out=0;\n\tif (!item) return 0;\n\tswitch ((item->type)&255)\n\t{\n\t\tcase cJSON_NULL:\tout=cJSON_strdup(\"null\");\tbreak;\n\t\tcase cJSON_False:\tout=cJSON_strdup(\"false\");break;\n\t\tcase cJSON_True:\tout=cJSON_strdup(\"true\"); break;\n\t\tcase cJSON_Number:\tout=print_number(item);break;\n\t\tcase cJSON_String:\tout=print_string(item);break;\n\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt);break;\n\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt);break;\n\t}\n\treturn out;\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Get Array size/item / object item. */\n", "func_signal": "int    cJSON_GetArraySize(cJSON *array)", "code": "{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}\ncJSON *cJSON_GetArrayItem(cJSON *array,int item)\t\t\t\t{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}\ncJSON *cJSON_GetObjectItem(cJSON *object,const char *string)\t{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}\n\n/* Utility for array list handling. */\nstatic void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}\n/* Utility for handling references. */\nstatic cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}\n\n/* Add item to array/object. */\nvoid   cJSON_AddItemToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}\nvoid   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}\nvoid\tcJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON_AddItemToArray(array,create_reference(item));}\nvoid\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)\t{cJSON_AddItemToObject(object,string,create_reference(item));}\n\ncJSON *cJSON_DetachItemFromArray(cJSON *array,int which)\t\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;\n\tif (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}\nvoid   cJSON_DeleteItemFromArray(cJSON *array,int which)\t\t\t{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}\ncJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}\nvoid   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}\n\n/* Replace array/object items with new ones. */\nvoid   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;\n\tnewitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;\n\tif (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}\nvoid   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}\n\n/* Create basic types: */\ncJSON *cJSON_CreateNull(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}\ncJSON *cJSON_CreateTrue(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}\ncJSON *cJSON_CreateFalse(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}\ncJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\ncJSON *cJSON_CreateNumber(double num)\t\t\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}\ncJSON *cJSON_CreateString(const char *string)\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}\ncJSON *cJSON_CreateArray(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}\ncJSON *cJSON_CreateObject(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}\n\n/* Create Arrays: */\ncJSON *cJSON_CreateIntArray(const int *numbers,int count)\t\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateDoubleArray(const double *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateStringArray(const char **strings,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n\n/* Duplication */\ncJSON *cJSON_Duplicate(cJSON *item,int recurse)\n{\n\tcJSON *newitem,*cptr,*nptr=0,*newchild;\n\t/* Bail on bad ptr */\n\tif (!item) return 0;\n\t/* Create new item */\n\tnewitem=cJSON_New_Item();\n\tif (!newitem) return 0;\n\t/* Copy over all vars */\n\tnewitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;\n\tif (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}\n\tif (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}\n\t/* If non-recursive, then we're done! */\n\tif (!recurse) return newitem;\n\t/* Walk the ->next chain for the child. */\n\tcptr=item->child;\n\twhile (cptr)\n\t{\n\t\tnewchild=cJSON_Duplicate(cptr,1);\t\t/* Duplicate (with recurse) each item in the ->next chain */\n\t\tif (!newchild) {cJSON_Delete(newitem);return 0;}\n\t\tif (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\t/* If newitem->child already set, then crosswire ->prev and ->next and move on */\n\t\telse\t\t{newitem->child=newchild;nptr=newchild;}\t\t\t\t\t/* Set newitem->child and move to it */\n\t\tcptr=cptr->next;\n\t}\n\treturn newitem;\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/**\n * @brief set_cache Set a key with the value input.\n *\n * @param memc The connection to beansdb.\n * @param key The key you want to set a new value.\n * @param value The value of the key.\n *\n * @return 1 for success and -1 for fail.\n */\n", "func_signal": "int set_cache(memcached_st *memc, const char *key, const char *value)", "code": "{\n    int rst = -1;\n    if (memc == NULL)\n        return rst;\n\n    memcached_return rc;\n\n    rc = memcached_set(memc, key, strlen(key), value, strlen(value), 0, 0);\n\n    if (rc == MEMCACHED_SUCCESS) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Set Successfully. Key[%s] Value: %s\", key, value);\n        rst = 1;\n    } else if (rc == MEMCACHED_CONNECTION_FAILURE) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Connection Failed!\");\n    } else {\n        LOG_PRINT(LOG_DEBUG, \"Cache Set(Key: %s Value: %s) Failed!\", key, value);\n        const char *str_rc = memcached_strerror(memc, rc);\n        LOG_PRINT(LOG_DEBUG, \"Cache Result: %s\", str_rc);\n        rst = -1;\n    }\n\n    return rst;\n}", "path": "zimg/src/zcache.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/**\n * @brief set_cache_bin Set a new BINARY value of a key.\n *\n * @param thr_arg The arg of thread.\n * @param key The key.\n * @param value A char * buffer you want to set.\n * @param len The length of the buffer above,\n *\n * @return  1 for success and -1 for fial.\n */\n", "func_signal": "int set_cache_bin(thr_arg_t *thr_arg, const char *key, const char *value, const size_t len)", "code": "{\n    int rst = -1;\n    if (settings.cache_on == false)\n        return rst;\n    if (thr_arg->cache_conn == NULL)\n        return rst;\n\n    memcached_st *memc = thr_arg->cache_conn;\n    memcached_return rc;\n\n    rc = memcached_set(memc, key, strlen(key), value, len, 0, 0);\n\n    if (rc == MEMCACHED_SUCCESS) {\n        LOG_PRINT(LOG_DEBUG, \"Binary Cache Set Successfully. Key[%s] Len: %d.\", key, len);\n        rst = 1;\n    } else if (rc == MEMCACHED_CONNECTION_FAILURE) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Conn Failed!\");\n        //retry_cache(thr_arg);\n    } else {\n        LOG_PRINT(LOG_DEBUG, \"Binary Cache Set Key[%s] Failed!\", key);\n        const char *str_rc = memcached_strerror(memc, rc);\n        LOG_PRINT(LOG_DEBUG, \"Cache Result: %s\", str_rc);\n        rst = -1;\n    }\n\n    return rst;\n}", "path": "zimg/src/zcache.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Render the cstring provided to an escaped version that can be printed. */\n", "func_signal": "static char *print_string_ptr(const char *str)", "code": "{\n\tconst char *ptr;char *ptr2,*out;int len=0;unsigned char token;\n\t\n\tif (!str) return cJSON_strdup(\"\");\n\tptr=str;while ((token=*ptr) && ++len) {if (strchr(\"\\\"\\\\\\b\\f\\n\\r\\t\",token)) len++; else if (token<32) len+=5;ptr++;}\n\t\n\tout=(char*)cJSON_malloc(len+3);\n\tif (!out) return 0;\n\n\tptr2=out;ptr=str;\n\t*ptr2++='\\\"';\n\twhile (*ptr)\n\t{\n\t\tif ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\t*ptr2++='\\\\';\n\t\t\tswitch (token=*ptr++)\n\t\t\t{\n\t\t\t\tcase '\\\\':\t*ptr2++='\\\\';\tbreak;\n\t\t\t\tcase '\\\"':\t*ptr2++='\\\"';\tbreak;\n\t\t\t\tcase '\\b':\t*ptr2++='b';\tbreak;\n\t\t\t\tcase '\\f':\t*ptr2++='f';\tbreak;\n\t\t\t\tcase '\\n':\t*ptr2++='n';\tbreak;\n\t\t\t\tcase '\\r':\t*ptr2++='r';\tbreak;\n\t\t\t\tcase '\\t':\t*ptr2++='t';\tbreak;\n\t\t\t\tdefault: sprintf(ptr2,\"u%04x\",token);ptr2+=5;\tbreak;\t/* escape and print */\n\t\t\t}\n\t\t}\n\t}\n\t*ptr2++='\\\"';*ptr2++=0;\n\treturn out;\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Render an object to text. */\n", "func_signal": "static char *print_object(cJSON *item,int depth,int fmt)", "code": "{\n\tchar **entries=0,**names=0;\n\tchar *out=0,*ptr,*ret,*str;int len=7,i=0,j;\n\tcJSON *child=item->child;\n\tint numentries=0,fail=0;\n\t/* Count the number of entries. */\n\twhile (child) numentries++,child=child->next;\n\t/* Explicitly handle empty object case */\n\tif (!numentries)\n\t{\n\t\tout=(char*)cJSON_malloc(fmt?depth+4:3);\n\t\tif (!out)\treturn 0;\n\t\tptr=out;*ptr++='{';\n\t\tif (fmt) {*ptr++='\\n';for (i=0;i<depth-1;i++) *ptr++='\\t';}\n\t\t*ptr++='}';*ptr++=0;\n\t\treturn out;\n\t}\n\t/* Allocate space for the names and the objects */\n\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\tif (!entries) return 0;\n\tnames=(char**)cJSON_malloc(numentries*sizeof(char*));\n\tif (!names) {cJSON_free(entries);return 0;}\n\tmemset(entries,0,sizeof(char*)*numentries);\n\tmemset(names,0,sizeof(char*)*numentries);\n\n\t/* Collect all the results into our arrays: */\n\tchild=item->child;depth++;if (fmt) len+=depth;\n\twhile (child)\n\t{\n\t\tnames[i]=str=print_string_ptr(child->string);\n\t\tentries[i++]=ret=print_value(child,depth,fmt);\n\t\tif (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;\n\t\tchild=child->next;\n\t}\n\t\n\t/* Try to allocate the output string */\n\tif (!fail) out=(char*)cJSON_malloc(len);\n\tif (!out) fail=1;\n\n\t/* Handle failure */\n\tif (fail)\n\t{\n\t\tfor (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}\n\t\tcJSON_free(names);cJSON_free(entries);\n\t\treturn 0;\n\t}\n\t\n\t/* Compose the output: */\n\t*out='{';ptr=out+1;if (fmt)*ptr++='\\n';*ptr=0;\n\tfor (i=0;i<numentries;i++)\n\t{\n\t\tif (fmt) for (j=0;j<depth;j++) *ptr++='\\t';\n\t\tstrcpy(ptr,names[i]);ptr+=strlen(names[i]);\n\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n\t\tstrcpy(ptr,entries[i]);ptr+=strlen(entries[i]);\n\t\tif (i!=numentries-1) *ptr++=',';\n\t\tif (fmt) *ptr++='\\n';*ptr=0;\n\t\tcJSON_free(names[i]);cJSON_free(entries[i]);\n\t}\n\t\n\tcJSON_free(names);cJSON_free(entries);\n\tif (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';\n\t*ptr++='}';*ptr++=0;\n\treturn out;\t\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Invote print_string_ptr (which is useful) on an item. */\n", "func_signal": "static char *print_string(cJSON *item)", "code": "{return print_string_ptr(item->valuestring);}\n\n/* Predeclare these prototypes. */\nstatic const char *parse_value(cJSON *item,const char *value);\nstatic char *print_value(cJSON *item,int depth,int fmt);\nstatic const char *parse_array(cJSON *item,const char *value);\nstatic char *print_array(cJSON *item,int depth,int fmt);\nstatic const char *parse_object(cJSON *item,const char *value);\nstatic char *print_object(cJSON *item,int depth,int fmt);\n\n/* Utility to jump whitespace and cr/lf */\nstatic const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}\n\n/* Parse an object - create a new root, and populate. */\ncJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n{\n\tconst char *end=0;\n\tcJSON *c=cJSON_New_Item();\n\tep=0;\n\tif (!c) return 0;       /* memory fail */\n\n\tend=parse_value(c,skip(value));\n\tif (!end)\t{cJSON_Delete(c);return 0;}\t/* parse failure. ep is set. */\n\n\t/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n\tif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}\n\tif (return_parse_end) *return_parse_end=end;\n\treturn c;\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/**\n * @brief admin_img the function to deal with admin reqeust for disk mode\n *\n * @param req the evhtp request\n * @param md5 the file md5\n * @param t admin type\n *\n * @return 1 for OK, 2 for 404 not found and -1 for fail\n */\n", "func_signal": "int admin_img(evhtp_request_t *req, thr_arg_t *thr_arg, char *md5, int t)", "code": "{\n    int result = -1;\n\n    LOG_PRINT(LOG_DEBUG, \"amdin_img() start processing admin request...\");\n    char whole_path[512];\n    int lvl1 = str_hash(md5);\n    int lvl2 = str_hash(md5 + 3);\n    snprintf(whole_path, 512, \"%s/%d/%d/%s\", settings.img_path, lvl1, lvl2, md5);\n    LOG_PRINT(LOG_DEBUG, \"whole_path: %s\", whole_path);\n\n    if (is_dir(whole_path) == -1) {\n        LOG_PRINT(LOG_DEBUG, \"path: %s is not exist!\", whole_path);\n        return 2;\n    }\n\n    if (t == 1) {\n        if (delete_file(whole_path) != -1) {\n            result = 1;\n            evbuffer_add_printf(req->buffer_out,\n                                \"<html><body><h1>Admin Command Successful!</h1> \\\n                <p>MD5: %s</p> \\\n                <p>Command Type: %d</p> \\\n                </body></html>\",\n                                md5, t);\n            evhtp_headers_add_header(req->headers_out, evhtp_header_new(\"Content-Type\", \"text/html\", 0, 0));\n        }\n    }\n    return result;\n}", "path": "zimg/src/zimg.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/**\n * @brief find_cache_bin Find a key's BINARY value.\n *\n * @param thr_arg The arg of thread.\n * @param key The key you want to find.\n * @param value_ptr It will be alloc and contains the binary value.\n * @param len It will change to the length of the value.\n *\n * @return 1 for success and -1 for fail.\n */\n", "func_signal": "int find_cache_bin(thr_arg_t *thr_arg, const char *key, char **value_ptr, size_t *len)", "code": "{\n    int rst = -1;\n    if (settings.cache_on == false)\n        return rst;\n    if (thr_arg->cache_conn == NULL) {\n        LOG_PRINT(LOG_DEBUG, \"thr_arg->cache_conn nil.\");\n        return rst;\n    }\n\n    uint32_t flags;\n    memcached_st *memc = thr_arg->cache_conn;\n    memcached_return rc;\n\n    *value_ptr = memcached_get(memc, key, strlen(key), len, &flags, &rc);\n\n    if (rc == MEMCACHED_SUCCESS) {\n        LOG_PRINT(LOG_DEBUG, \"Binary Cache Find Key[%s], Len: %d.\", key, *len);\n        rst = 1;\n    } else if (rc == MEMCACHED_CONNECTION_FAILURE) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Conn Failed!\");\n        //retry_cache(thr_arg);\n    } else if (rc == MEMCACHED_NOTFOUND) {\n        LOG_PRINT(LOG_DEBUG, \"Binary Cache Key[%s] Not Find!\", key);\n        rst = -1;\n    } else {\n        const char *str_rc = memcached_strerror(memc, rc);\n        LOG_PRINT(LOG_DEBUG, \"Cache Result: %s\", str_rc);\n    }\n\n    //memcached_free(memc);\n    return rst;\n}", "path": "zimg/src/zcache.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Internal constructor. */\n", "func_signal": "static cJSON *cJSON_New_Item(void)", "code": "{\n\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n\tif (node) memset(node,0,sizeof(cJSON));\n\treturn node;\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Delete a cJSON structure. */\n", "func_signal": "void cJSON_Delete(cJSON *c)", "code": "{\n\tcJSON *next;\n\twhile (c)\n\t{\n\t\tnext=c->next;\n\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n\t\tif (c->string) cJSON_free(c->string);\n\t\tcJSON_free(c);\n\t\tc=next;\n\t}\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Render the number nicely from the given item into a string. */\n", "func_signal": "static char *print_number(cJSON *item)", "code": "{\n\tchar *str;\n\tdouble d=item->valuedouble;\n\tif (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)\n\t{\n\t\tstr=(char*)cJSON_malloc(21);\t/* 2^64+1 can be represented in 21 chars. */\n\t\tif (str) sprintf(str,\"%d\",item->valueint);\n\t}\n\telse\n\t{\n\t\tstr=(char*)cJSON_malloc(64);\t/* This is a nice tradeoff. */\n\t\tif (str)\n\t\t{\n\t\t\tif (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,\"%.0f\",d);\n\t\t\telse if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)\t\t\tsprintf(str,\"%e\",d);\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\tsprintf(str,\"%f\",d);\n\t\t}\n\t}\n\treturn str;\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Render an array to text */\n", "func_signal": "static char *print_array(cJSON *item,int depth,int fmt)", "code": "{\n\tchar **entries;\n\tchar *out=0,*ptr,*ret;int len=5;\n\tcJSON *child=item->child;\n\tint numentries=0,i=0,fail=0;\n\t\n\t/* How many entries in the array? */\n\twhile (child) numentries++,child=child->next;\n\t/* Explicitly handle numentries==0 */\n\tif (!numentries)\n\t{\n\t\tout=(char*)cJSON_malloc(3);\n\t\tif (out) strcpy(out,\"[]\");\n\t\treturn out;\n\t}\n\t/* Allocate an array to hold the values for each */\n\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\tif (!entries) return 0;\n\tmemset(entries,0,numentries*sizeof(char*));\n\t/* Retrieve all the results: */\n\tchild=item->child;\n\twhile (child && !fail)\n\t{\n\t\tret=print_value(child,depth+1,fmt);\n\t\tentries[i++]=ret;\n\t\tif (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;\n\t\tchild=child->next;\n\t}\n\t\n\t/* If we didn't fail, try to malloc the output string */\n\tif (!fail) out=(char*)cJSON_malloc(len);\n\t/* If that fails, we fail. */\n\tif (!out) fail=1;\n\n\t/* Handle failure. */\n\tif (fail)\n\t{\n\t\tfor (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);\n\t\tcJSON_free(entries);\n\t\treturn 0;\n\t}\n\t\n\t/* Compose the output array. */\n\t*out='[';\n\tptr=out+1;*ptr=0;\n\tfor (i=0;i<numentries;i++)\n\t{\n\t\tstrcpy(ptr,entries[i]);ptr+=strlen(entries[i]);\n\t\tif (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}\n\t\tcJSON_free(entries[i]);\n\t}\n\tcJSON_free(entries);\n\t*ptr++=']';*ptr++=0;\n\treturn out;\t\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/**\n * @brief find_cache Connect to a memcached server and find a key's value.\n *\n * @param memc The connection to beansdb.\n * @param key The string of the key you want to find.\n * @param value It contains the string of the key's value.\n *\n * @return 1 for success and -1 for fail.\n */\n", "func_signal": "int find_cache(memcached_st *memc, const char *key, char *value)", "code": "{\n    int rst = -1;\n    if (memc == NULL)\n        return rst;\n\n    size_t valueLen;\n    uint32_t flags;\n    memcached_return rc;\n\n    char *pvalue = memcached_get(memc, key, strlen(key), &valueLen, &flags, &rc);\n\n    if (rc == MEMCACHED_SUCCESS) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Find Key[%s] Value: %s\", key, pvalue);\n        str_lcpy(value, pvalue, sizeof(value));\n        free(pvalue);\n        rst = 1;\n    } else if (rc == MEMCACHED_NOTFOUND) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Key[%s] Not Find!\", key);\n        rst = -1;\n    } else {\n        const char *str_rc = memcached_strerror(memc, rc);\n        LOG_PRINT(LOG_DEBUG, \"Cache Result: %s\", str_rc);\n    }\n\n    return rst;\n}", "path": "zimg/src/zcache.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Parse the input text to generate a number, and populate the result into item. */\n", "func_signal": "static const char *parse_number(cJSON *item,const char *num)", "code": "{\n\tdouble n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n\n\tif (*num=='-') sign=-1,num++;\t/* Has sign? */\n\tif (*num=='0') num++;\t\t\t/* is zero */\n\tif (*num>='1' && *num<='9')\tdo\tn=(n*10.0)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t/* Number? */\n\tif (*num=='.' && num[1]>='0' && num[1]<='9') {num++;\t\tdo\tn=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}\t/* Fractional part? */\n\tif (*num=='e' || *num=='E')\t\t/* Exponent? */\n\t{\tnum++;if (*num=='+') num++;\telse if (*num=='-') signsubscale=-1,num++;\t\t/* With sign? */\n\t\twhile (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');\t/* Number? */\n\t}\n\n\tn=sign*n*pow(10.0,(scale+subscale*signsubscale));\t/* number = +/- number.fraction * 10^+/- exponent */\n\t\n\titem->valuedouble=n;\n\titem->valueint=(int)n;\n\titem->type=cJSON_Number;\n\treturn num;\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/**\n * @brief del_cache This function delete a key and its value in memcached.\n *\n * @param thr_arg The arg of thread.\n * @param key The key.\n *\n * @return  1 for success and -1 for fail.\n */\n", "func_signal": "int del_cache(thr_arg_t *thr_arg, const char *key)", "code": "{\n    int rst = -1;\n    if (settings.cache_on == false)\n        return rst;\n    if (thr_arg->cache_conn == NULL)\n        return rst;\n\n    memcached_st *memc = thr_arg->cache_conn;\n    memcached_return rc;\n\n    rc = memcached_delete(memc, key, strlen(key), 0);\n\n    if (rc == MEMCACHED_SUCCESS) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Key[%s] Delete Successfully.\", key);\n        rst = 1;\n    } else if (rc == MEMCACHED_CONNECTION_FAILURE) {\n        LOG_PRINT(LOG_DEBUG, \"Cache Conn Failed!\");\n        //retry_cache(thr_arg);\n    } else {\n        LOG_PRINT(LOG_DEBUG, \"Cache Key[%s] Delete Failed!\", key);\n        const char *str_rc = memcached_strerror(memc, rc);\n        LOG_PRINT(LOG_DEBUG, \"Cache Result: %s\", str_rc);\n        rst = -1;\n    }\n\n    return rst;\n}", "path": "zimg/src/zcache.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/**\n * @brief info_img the function of getting info of a image\n *\n * @param md5 the md5 of image\n * @param request the evhtp request\n *\n * @return 1 for OK and -1 for fail\n */\n", "func_signal": "int info_img(evhtp_request_t *request, thr_arg_t *thr_arg, char *md5)", "code": "{\n    int result = -1;\n\n    LOG_PRINT(LOG_DEBUG, \"info_img() start processing info request...\");\n    MagickWand *im = NULL;\n    char whole_path[512];\n    int lvl1 = str_hash(md5);\n    int lvl2 = str_hash(md5 + 3);\n    snprintf(whole_path, 512, \"%s/%d/%d/%s\", settings.img_path, lvl1, lvl2, md5);\n    LOG_PRINT(LOG_DEBUG, \"whole_path: %s\", whole_path);\n\n    if (is_dir(whole_path) == -1) {\n        result = 0;\n        LOG_PRINT(LOG_DEBUG, \"Image %s is not existed!\", md5);\n        goto err;\n    }\n\n    char orig_path[512];\n    snprintf(orig_path, 512, \"%s/0*0\", whole_path);\n    LOG_PRINT(LOG_DEBUG, \"0rig File Path: %s\", orig_path);\n\n    im = NewMagickWand();\n    if (im == NULL) goto err;\n    int ret = -1;\n\n    ret = MagickReadImage(im, orig_path);\n    if (ret != MagickTrue) {\n        LOG_PRINT(LOG_DEBUG, \"Open Original Image From Disk Failed!\");\n        goto err;\n    }\n\n    add_info(im, request);\n    result = 1;\n\nerr:\n    if (im != NULL)\n        DestroyMagickWand(im);\n    return result;\n}", "path": "zimg/src/zimg.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/**\n * @brief get_img get image from disk mode through the request\n *\n * @param req the zimg request\n * @param request the evhtp request\n *\n * @return 1 for OK, 2 for 304 needn't response buffer and -1 for failed\n */\n", "func_signal": "int get_img(zimg_req_t *req, evhtp_request_t *request)", "code": "{\n    int result = -1;\n    char rsp_cache_key[CACHE_KEY_SIZE];\n    int fd = -1;\n    struct stat f_stat;\n    char *buff = NULL;\n    char *orig_buff = NULL;\n    MagickWand *im = NULL;\n    size_t len = 0;\n    bool to_save = true;\n\n    LOG_PRINT(LOG_DEBUG, \"get_img() start processing zimg request...\");\n\n    int lvl1 = str_hash(req->md5);\n    int lvl2 = str_hash(req->md5 + 3);\n\n    char whole_path[512];\n    snprintf(whole_path, 512, \"%s/%d/%d/%s\", settings.img_path, lvl1, lvl2, req->md5);\n    LOG_PRINT(LOG_DEBUG, \"whole_path: %s\", whole_path);\n\n    if (is_dir(whole_path) == -1) {\n        LOG_PRINT(LOG_DEBUG, \"Image %s is not existed!\", req->md5);\n        goto err;\n    }\n\n    if (settings.script_on == 1 && req->type != NULL)\n        snprintf(rsp_cache_key, CACHE_KEY_SIZE, \"%s:%s\", req->md5, req->type);\n    else {\n        if (req->proportion == 0 && req->width == 0 && req->height == 0)\n            str_lcpy(rsp_cache_key, req->md5, CACHE_KEY_SIZE);\n        else\n            gen_key(rsp_cache_key, req->md5, 9, req->width, req->height, req->proportion, req->gray, req->x, req->y, req->rotate, req->quality, req->fmt);\n    }\n\n    if (find_cache_bin(req->thr_arg, rsp_cache_key, &buff, &len) == 1) {\n        LOG_PRINT(LOG_DEBUG, \"Hit Cache[Key: %s].\", rsp_cache_key);\n        to_save = false;\n        goto done;\n    }\n    LOG_PRINT(LOG_DEBUG, \"Start to Find the Image...\");\n\n    char orig_path[512];\n    snprintf(orig_path, 512, \"%s/0*0\", whole_path);\n    LOG_PRINT(LOG_DEBUG, \"0rig File Path: %s\", orig_path);\n\n    char rsp_path[512];\n    if (settings.script_on == 1 && req->type != NULL)\n        snprintf(rsp_path, 512, \"%s/t_%s\", whole_path, req->type);\n    else {\n        char name[128];\n        snprintf(name, 128, \"%d*%d_p%d_g%d_%d*%d_r%d_q%d.%s\", req->width, req->height,\n                 req->proportion,\n                 req->gray,\n                 req->x, req->y,\n                 req->rotate,\n                 req->quality,\n                 req->fmt);\n\n        if (req->width == 0 && req->height == 0 && req->proportion == 0) {\n            LOG_PRINT(LOG_DEBUG, \"Return original image.\");\n            strncpy(rsp_path, orig_path, 512);\n        } else {\n            snprintf(rsp_path, 512, \"%s/%s\", whole_path, name);\n        }\n    }\n    LOG_PRINT(LOG_DEBUG, \"Got the rsp_path: %s\", rsp_path);\n\n    if ((fd = open(rsp_path, O_RDONLY)) == -1) {\n        im = NewMagickWand();\n        if (im == NULL) goto err;\n\n        int ret;\n        if (find_cache_bin(req->thr_arg, req->md5, &orig_buff, &len) == 1) {\n            LOG_PRINT(LOG_DEBUG, \"Hit Orignal Image Cache[Key: %s].\", req->md5);\n\n            ret = MagickReadImageBlob(im, (const unsigned char *)orig_buff, len);\n            if (ret != MagickTrue) {\n                LOG_PRINT(LOG_DEBUG, \"Open Original Image From Blob Failed! Begin to Open it From Disk.\");\n                del_cache(req->thr_arg, req->md5);\n                ret = MagickReadImage(im, orig_path);\n                if (ret != MagickTrue) {\n                    LOG_PRINT(LOG_DEBUG, \"Open Original Image From Disk Failed!\");\n                    goto err;\n                } else {\n                    MagickSizeType size;\n                    MagickGetImageLength(im, &size);\n                    LOG_PRINT(LOG_DEBUG, \"image size = %d\", size);\n                    if (size < CACHE_MAX_SIZE) {\n                        MagickResetIterator(im);\n                        char *new_buff = (char *)MagickGetImageBlob(im, &len);\n                        if (new_buff == NULL) {\n                            LOG_PRINT(LOG_DEBUG, \"Webimg Get Original Blob Failed!\");\n                            goto err;\n                        }\n                        set_cache_bin(req->thr_arg, req->md5, new_buff, len);\n                        free(new_buff);\n                    }\n                }\n            }\n        } else {\n            LOG_PRINT(LOG_DEBUG, \"Not Hit Original Image Cache. Begin to Open it.\");\n            ret = MagickReadImage(im, orig_path);\n            if (ret != MagickTrue) {\n                LOG_PRINT(LOG_DEBUG, \"Open Original Image From Disk Failed! %d != %d\", ret, MagickTrue);\n                LOG_PRINT(LOG_DEBUG, \"Open Original Image From Disk Failed!\");\n                goto err;\n            } else {\n                MagickSizeType size;\n                MagickGetImageLength(im, &size);\n                LOG_PRINT(LOG_DEBUG, \"image size = %d\", size);\n                if (size < CACHE_MAX_SIZE) {\n                    MagickResetIterator(im);\n                    char *new_buff = (char *)MagickGetImageBlob(im, &len);\n                    if (new_buff == NULL) {\n                        LOG_PRINT(LOG_DEBUG, \"Webimg Get Original Blob Failed!\");\n                        goto err;\n                    }\n                    set_cache_bin(req->thr_arg, req->md5, new_buff, len);\n                    free(new_buff);\n                }\n            }\n        }\n\n        if (settings.script_on == 1 && req->type != NULL)\n            ret = lua_convert(im, req);\n        else\n            ret = convert(im, req);\n        if (ret == -1) goto err;\n        if (ret == 0) to_save = false;\n\n        buff = (char *)MagickGetImageBlob(im, &len);\n        if (buff == NULL) {\n            LOG_PRINT(LOG_DEBUG, \"Webimg Get Blob Failed!\");\n            goto err;\n        }\n    } else {\n        to_save = false;\n        fstat(fd, &f_stat);\n        size_t rlen = 0;\n        len = f_stat.st_size;\n        if (len <= 0) {\n            LOG_PRINT(LOG_DEBUG, \"File[%s] is Empty.\", rsp_path);\n            goto err;\n        }\n        if ((buff = (char *)malloc(len)) == NULL) {\n            LOG_PRINT(LOG_DEBUG, \"buff Malloc Failed!\");\n            goto err;\n        }\n        LOG_PRINT(LOG_DEBUG, \"img_size = %d\", len);\n        if ((rlen = read(fd, buff, len)) == -1) {\n            LOG_PRINT(LOG_DEBUG, \"File[%s] Read Failed: %s\", rsp_path, strerror(errno));\n            goto err;\n        } else if (rlen < len) {\n            LOG_PRINT(LOG_DEBUG, \"File[%s] Read Not Compeletly.\", rsp_path);\n            goto err;\n        }\n    }\n\n    //LOG_PRINT(LOG_INFO, \"New Image[%s]\", rsp_path);\n    int save_new = 0;\n    if (to_save == true) {\n        if (req->sv == 1 || settings.save_new == 1 || (settings.save_new == 2 && req->type != NULL)) {\n            save_new = 1;\n        }\n    }\n\n    if (save_new == 1) {\n        LOG_PRINT(LOG_DEBUG, \"Image[%s] is Not Existed. Begin to Save it.\", rsp_path);\n        if (new_img(buff, len, rsp_path) == -1) {\n            LOG_PRINT(LOG_DEBUG, \"New Image[%s] Save Failed!\", rsp_path);\n            LOG_PRINT(LOG_WARNING, \"fail save %s\", rsp_path);\n        }\n    } else\n        LOG_PRINT(LOG_DEBUG, \"Image [%s] Needn't to Storage.\", rsp_path);\n\n    if (len < CACHE_MAX_SIZE) {\n        set_cache_bin(req->thr_arg, rsp_cache_key, buff, len);\n    }\n\ndone:\n    if (settings.etag == 1) {\n        result = zimg_etag_set(request, buff, len);\n        if (result == 2)\n            goto err;\n    }\n    result = evbuffer_add(request->buffer_out, buff, len);\n    if (result != -1) {\n        result = 1;\n    }\n\nerr:\n    if (fd != -1)\n        close(fd);\n    if (im != NULL)\n        DestroyMagickWand(im);\n    free(buff);\n    free(orig_buff);\n    return result;\n}", "path": "zimg/src/zimg.c", "commit_date": "2017-05-11 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/* Build an array from input text. */\n", "func_signal": "static const char *parse_array(cJSON *item,const char *value)", "code": "{\n\tcJSON *child;\n\tif (*value!='[')\t{ep=value;return 0;}\t/* not an array! */\n\n\titem->type=cJSON_Array;\n\tvalue=skip(value+1);\n\tif (*value==']') return value+1;\t/* empty array. */\n\n\titem->child=child=cJSON_New_Item();\n\tif (!item->child) return 0;\t\t /* memory fail */\n\tvalue=skip(parse_value(child,skip(value)));\t/* skip any spacing, get the value. */\n\tif (!value) return 0;\n\n\twhile (*value==',')\n\t{\n\t\tcJSON *new_item;\n\t\tif (!(new_item=cJSON_New_Item())) return 0; \t/* memory fail */\n\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n\t\tvalue=skip(parse_value(child,skip(value+1)));\n\t\tif (!value) return 0;\t/* memory fail */\n\t}\n\n\tif (*value==']') return value+1;\t/* end of array */\n\tep=value;return 0;\t/* malformed. */\n}", "path": "zimg/deps/cjson/cJSON.c", "commit_date": "2014-09-02 00:00:00", "repo_name": "buaazp/zimg", "stars": 2685, "license": "bsd-3-clause", "language": "c", "size": 55620}
{"docstring": "/*\n * Iterate through tests array and run mmap_flags_test\n */\n", "func_signal": "static void all_mmap_flags_tests(void)", "code": "{\n    int i;\n\n    for (i = 0; i < NR_MMAP_TESTS; i++) {\n        char str[64];\n        void * mmap_addr;\n        unsigned long size;\n\n        if (tests[i].flags & MAP_FIXED)\n            mmap_addr = (void *)round_up_page(landing_pad); \n        else\n            mmap_addr = NULL;\n\n        if (tests[i].flags & MAP_ANONYMOUS)\n            size = PAGESIZE;\n        else\n            size = 0;\n\n        mmap_flags_to_str(str, 64, tests[i].flags);\n        printf(\"  performing mmap_flag_test(%s)...\\n\", str);\n        mmap_flags_test(tests[i].filename, mmap_addr, size, tests[i].flags);\n    }\n}", "path": "nanos/test/runtime/mmap.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Send NDIS version 2 config packet containing MTU.\n *\n * Not valid for NDIS version 1.\n */\n", "func_signal": "static int\nhv_nv_send_ndis_config(struct hv_device *device, uint32_t mtu)", "code": "{\n    netvsc_dev *net_dev;\n    nvsp_msg *init_pkt;\n    int ret;\n\n    net_dev = hv_nv_get_outbound_net_device(device);\n    if (!net_dev)\n        return (-ENODEV);\n\n    /*\n     * Set up configuration packet, write MTU\n     * Indicate we are capable of handling VLAN tags\n     */\n    init_pkt = &net_dev->channel_init_packet;\n    zero(init_pkt, sizeof(nvsp_msg));\n    init_pkt->hdr.msg_type = nvsp_msg_2_type_send_ndis_config;\n    init_pkt->msgs.vers_2_msgs.send_ndis_config.mtu = mtu;\n    init_pkt->\n        msgs.vers_2_msgs.send_ndis_config.capabilities.u1.u2.ieee8021q\n        = 1;\n\n    /* Send the configuration packet */\n    ret = vmbus_chan_send(device->channel,\n        VMBUS_CHANPKT_TYPE_INBAND, 0,\n        init_pkt, sizeof(nvsp_msg), (uint64_t)init_pkt);\n    if (ret != 0)\n        return (-EINVAL);\n\n    return (0);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Test correctness of virtual memory space tracking.\n *\n * This function allocates NR_MMAPS different mmap regions. It allocates them\n * in several chunks at a time. In between chunks of allocations, it frees\n * some of the mmaps to attempt to create holes in the address space, before\n * moving on to more allocations\n */\n", "func_signal": "static void sparse_anon_mmap_test(void)", "code": "{\n    mmap_t * mmaps;\n    int i, j, nr_freed, nr_to_free;\n\n    mmaps = malloc(sizeof(mmap_t) * __mmap_NR_MMAPS);\n    if (mmaps == NULL) {\n        perror(\"malloc\");\n        exit(EXIT_FAILURE);\n    }\n\n    nr_freed = 0;\n    for (i = 0; i < __mmap_NR_MMAPS/__mmap_ALLOC_AT_A_TIME; i++)  {\n        for (j = 0; j < __mmap_ALLOC_AT_A_TIME; j++) {\n            unsigned long size = gen_random_size();\n            void * addr = mmap(\n                NULL, \n                size, \n                PROT_READ | PROT_WRITE,\n                MAP_PRIVATE | MAP_ANONYMOUS, \n                -1, 0\n            );\n\n            if (addr == MAP_FAILED) {\n                perror(\"mmap failed\");\n                exit(EXIT_FAILURE);\n            }\n\n            mmaps[i*__mmap_ALLOC_AT_A_TIME + j].addr = addr;\n            mmaps[i*__mmap_ALLOC_AT_A_TIME + j].size = size;\n        }\n\n        /* free some but not all of them */\n        nr_to_free = rand() % (\n            ((i+1) * __mmap_ALLOC_AT_A_TIME)\n            - nr_freed\n        );\n\n        for (j = 0; j < nr_to_free && (nr_freed+j) < __mmap_NR_MMAPS; j++)\n            do_munmap(mmaps[nr_freed + j].addr, mmaps[nr_freed + j].size); \n\n        nr_freed += nr_to_free;\n    }\n\n    /* free whatever's left */\n    while (nr_freed < __mmap_NR_MMAPS) {\n        do_munmap(mmaps[nr_freed].addr, mmaps[nr_freed].size); \n        nr_freed++;\n    }\n\n    free(mmaps);\n}", "path": "nanos/test/runtime/mmap.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC on send completion\n */\n", "func_signal": "static void\nhv_nv_on_send_completion(struct hv_device *device, struct vmbus_chanpkt_hdr *pkt)", "code": "{\n    netvsc_dev *net_dev;\n    nvsp_msg *nvsp_msg_pkt;\n    netvsc_packet *net_vsc_pkt;\n\n    net_dev = hv_nv_get_inbound_net_device(device);\n    if (!net_dev) {\n        return;\n    }\n\n    nvsp_msg_pkt =\n        (nvsp_msg *)((unsigned long)pkt + (pkt->cph_hlen << 3));\n\n    if (nvsp_msg_pkt->hdr.msg_type == nvsp_msg_type_init_complete\n        || nvsp_msg_pkt->hdr.msg_type\n            == nvsp_msg_1_type_send_rx_buf_complete\n        || nvsp_msg_pkt->hdr.msg_type\n            == nvsp_msg_1_type_send_send_buf_complete) {\n        /* Copy the response back */\n        runtime_memcpy(&net_dev->channel_init_packet, nvsp_msg_pkt,\n            sizeof(nvsp_msg));\n        net_dev->channel_init_wait_flag = false;\n    } else if (nvsp_msg_pkt->hdr.msg_type ==\n                   nvsp_msg_1_type_send_rndis_pkt_complete) {\n        /* Get the send context */\n        net_vsc_pkt =\n            (netvsc_packet *)(unsigned long)pkt->cph_xactid;\n\n        /* Notify the layer above us */\n        net_vsc_pkt->compl.send.on_send_completion(\n            net_vsc_pkt->compl.send.send_completion_context);\n\n        atomic_subtract32(&net_dev->num_outstanding_sends, 1);\n    }\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC connect to VSP\n */\n", "func_signal": "static int\nhv_nv_connect_to_vsp(struct hv_device *device)", "code": "{\n    netvsc_dev *net_dev;\n    nvsp_msg *init_pkt;\n    uint32_t nvsp_vers;\n    uint32_t ndis_version;\n    int ret = 0;\n    hn_softc_t *sc = device->device;\n    struct netif *ifp = sc->netif;\n\n    net_dev = hv_nv_get_outbound_net_device(device);\n\n    /*\n     * Negotiate the NVSP version.  Try NVSP v2 first.\n     */\n    nvsp_vers = NVSP_PROTOCOL_VERSION_2;\n    ret = hv_nv_negotiate_nvsp_protocol(device, net_dev, nvsp_vers);\n    if (ret != 0) {\n        /* NVSP v2 failed, try NVSP v1 */\n        nvsp_vers = NVSP_PROTOCOL_VERSION_1;\n        ret = hv_nv_negotiate_nvsp_protocol(device, net_dev, nvsp_vers);\n        if (ret != 0) {\n            /* NVSP v1 failed, return bad status */\n            return (ret);\n        }\n    }\n    net_dev->nvsp_version = nvsp_vers;\n\n    netvsc_debug(\"NVSP protocol: %d\", net_dev->nvsp_version);\n    /*\n     * Set the MTU if supported by this NVSP protocol version\n     * This needs to be right after the NVSP init message per Haiyang\n     */\n    if (nvsp_vers >= NVSP_PROTOCOL_VERSION_2)\n        ret = hv_nv_send_ndis_config(device, ifp->mtu);\n\n    /*\n     * Send the NDIS version\n     */\n    init_pkt = &net_dev->channel_init_packet;\n\n    runtime_memset((u8 *)init_pkt, 0, sizeof(nvsp_msg));\n\n    /*\n     * Updated to version 5.1, minimum, for VLAN per Haiyang\n     */\n    ndis_version = NDIS_VERSION;\n\n    init_pkt->hdr.msg_type = nvsp_msg_1_type_send_ndis_vers;\n    init_pkt->msgs.vers_1_msgs.send_ndis_vers.ndis_major_vers =\n        (ndis_version & 0xFFFF0000) >> 16;\n    init_pkt->msgs.vers_1_msgs.send_ndis_vers.ndis_minor_vers =\n        ndis_version & 0xFFFF;\n\n    /* Send the init request */\n\n    ret = vmbus_chan_send(device->channel,\n        VMBUS_CHANPKT_TYPE_INBAND, 0,\n        init_pkt, sizeof(nvsp_msg), (uint64_t)init_pkt);\n    if (ret != 0) {\n        goto cleanup;\n    }\n    /*\n     * TODO:  BUGBUG - We have to wait for the above msg since the netvsp\n     * uses KMCL which acknowledges packet (completion packet) \n     * since our Vmbus always set the\n     * HV_VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED flag\n     */\n    /* sema_wait(&NetVscChannel->channel_init_sema); */\n\n    /* Post the big receive buffer to NetVSP */\n    ret = hv_nv_init_rx_buffer_with_net_vsp(device);\n    if (ret == 0)\n        ret = hv_nv_init_send_buffer_with_net_vsp(device);\n\ncleanup:\n    return (ret);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * generate a permutation of the numbers in range 0 to nr_indices-1\n */\n", "func_signal": "static void permute(int * permutation, int nr_indices)", "code": "{\n    int i, j, temp;\n\n    for (i = 0; i < nr_indices; i++) \n        permutation[i] = i; \n\n    for (i = nr_indices - 1; i>= 0; --i) {\n        j = rand() % (i + 1);\n\n        temp = permutation[i];\n        permutation[i] = permutation[j];\n        permutation[j] = temp;\n    }    \n}", "path": "nanos/test/runtime/mmap.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC send receive completion\n */\n", "func_signal": "static void\nhv_nv_send_receive_completion(struct hv_device *device, uint64_t tid)", "code": "{\n    nvsp_msg rx_comp_msg;\n    int retries = 0;\n    int ret = 0;\n\n    rx_comp_msg.hdr.msg_type = nvsp_msg_1_type_send_rndis_pkt_complete;\n\n    /* Pass in the status */\n    rx_comp_msg.msgs.vers_1_msgs.send_rndis_pkt_complete.status =\n        nvsp_status_success;\n\nretry_send_cmplt:\n    /* Send the completion */\n    ret = vmbus_chan_send(device->channel,\n        VMBUS_CHANPKT_TYPE_COMP, 0,\n        &rx_comp_msg, sizeof(nvsp_msg), tid);\n    if (ret == 0) {\n        /* success */\n        /* no-op */\n    } else if (ret == EAGAIN) {\n        /* no more room... wait a bit and attempt to retry 3 times */\n        retries++;\n\n        if (retries < 4) {\n            kernel_delay(100);\n            goto retry_send_cmplt;\n        }\n    }\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Attempt to negotiate the caller-specified NVSP version\n *\n * For NVSP v2, Server 2008 R2 does not set\n * init_pkt->msgs.init_msgs.init_compl.negotiated_prot_vers\n * to the negotiated version, so we cannot rely on that.\n */\n", "func_signal": "static int\nhv_nv_negotiate_nvsp_protocol(struct hv_device *device, netvsc_dev *net_dev,\n                  uint32_t nvsp_ver)", "code": "{\n    nvsp_msg *init_pkt;\n    int ret;\n\n    init_pkt = &net_dev->channel_init_packet;\n    zero(init_pkt, sizeof(nvsp_msg));\n    init_pkt->hdr.msg_type = nvsp_msg_type_init;\n\n    /*\n     * Specify parameter as the only acceptable protocol version\n     */\n    init_pkt->msgs.init_msgs.init.p1.protocol_version = nvsp_ver;\n    init_pkt->msgs.init_msgs.init.protocol_version_2 = nvsp_ver;\n\n    hv_nv_prepare_wait_for_channel_message(net_dev);\n    /* Send the init request */\n    ret = vmbus_chan_send(device->channel,\n        VMBUS_CHANPKT_TYPE_INBAND,\n        VMBUS_CHANPKT_FLAG_RC,\n        init_pkt, sizeof(nvsp_msg), (uint64_t)init_pkt);\n    if (ret != 0)\n        return (-1);\n\n    hv_nv_wait_for_channel_message(net_dev);\n\n    if (init_pkt->msgs.init_msgs.init_compl.status != nvsp_status_success)\n        return (EINVAL);\n\n    return (0);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC on receive completion\n *\n * Send a receive completion packet to RNDIS device (ie NetVsp)\n */\n", "func_signal": "void\nhv_nv_on_receive_completion(void *context)", "code": "{\n    netvsc_packet *packet = (netvsc_packet *)context;\n    struct hv_device *device = (struct hv_device *)packet->device;\n    netvsc_dev    *net_dev;\n    uint64_t       tid = 0;\n    boolean_t send_rx_completion = false;\n\n    /*\n     * Even though it seems logical to do a hv_nv_get_outbound_net_device()\n     * here to send out receive completion, we are using\n     * hv_nv_get_inbound_net_device() since we may have disabled\n     * outbound traffic already.\n     */\n    net_dev = hv_nv_get_inbound_net_device(device);\n    if (net_dev == NULL)\n        return;\n\n    /* Overloading use of the lock. */\n    u64 flags = spin_lock_irq(&net_dev->rx_pkt_list_lock);\n\n    packet->xfer_page_pkt->count--;\n\n    /*\n     * Last one in the line that represent 1 xfer page packet.\n     * Return the xfer page packet itself to the free list.\n     */\n    if (packet->xfer_page_pkt->count == 0) {\n        send_rx_completion = true;\n        tid = packet->compl.rx.rx_completion_tid;\n        list_push_back(&net_dev->myrx_packet_list,\n                       &((netvsc_packet *)(packet->xfer_page_pkt))->mylist_entry);\n    }\n\n    /* Put the packet back on the free list */\n    list_push_back(&net_dev->myrx_packet_list, &packet->mylist_entry);\n    spin_unlock_irq(&net_dev->rx_pkt_list_lock, flags);\n\n    /* Send a receive completion for the xfer page packet */\n    if (send_rx_completion)\n        hv_nv_send_receive_completion(device, tid);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Try to mmap a non-executable file with exec access\n * Checks that mmap fails and sets errno to EACCES\n */\n", "func_signal": "static void check_exec_perm_test(void)", "code": "{\n    int fd;\n    const size_t maplen = 1;\n    void *addr;\n\n    fd = open(\"new_file_noexec\", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n    if (fd < 0) {\n        perror(\"new file open\");\n        exit(EXIT_FAILURE);\n    }\n    addr = mmap(NULL, maplen, PROT_EXEC, MAP_PRIVATE, fd, 0);\n    if (addr != MAP_FAILED) {\n        fprintf(stderr, \"%s: could mmap non-executable file with exec access\\n\",\n            __func__);\n        exit(EXIT_FAILURE);\n    } else if (errno != EACCES) {\n        handle_err(\"exec-mmap non-executable file: unexpected error\");\n    }\n    if (close(fd) < 0) {\n        perror(\"new file close\");\n        exit(EXIT_FAILURE);\n    }\n}", "path": "nanos/test/runtime/mmap.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC initialize receive buffer with net VSP\n * \n * Net VSP:  Network virtual services client, also known as the\n *     Hyper-V extensible switch and the synthetic data path.\n */\n", "func_signal": "static int\nhv_nv_init_rx_buffer_with_net_vsp(struct hv_device *device)", "code": "{\n    hn_softc_t *sc = device->device;\n    netvsc_dev *net_dev;\n    nvsp_msg *init_pkt;\n    int ret = 0;\n\n    net_dev = hv_nv_get_outbound_net_device(device);\n    if (!net_dev) {\n        return (ENODEV);\n    }\n\n    net_dev->rx_buf = allocate_zero(sc->contiguous, net_dev->rx_buf_size);\n    assert(net_dev->rx_buf != INVALID_ADDRESS);\n    assert((u64)net_dev->rx_buf == pad((u64)net_dev->rx_buf, PAGESIZE));\n\n    bus_addr_t rx_buf_paddr = physical_from_virtual(net_dev->rx_buf);\n    assert(rx_buf_paddr != INVALID_PHYSICAL);\n    /*\n     * Establish the GPADL handle for this buffer on this channel.\n     * Note:  This call uses the vmbus connection rather than the\n     * channel to establish the gpadl handle. \n     * GPADL:  Guest physical address descriptor list.\n     */\n    vmbus_chan_gpadl_connect(\n        device->channel, rx_buf_paddr,\n        net_dev->rx_buf_size, &net_dev->rx_buf_gpadl_handle);\n\n    /* sema_wait(&ext->channel_init_sema); KYS CHECK */\n\n    /* Notify the NetVsp of the gpadl handle */\n    init_pkt = &net_dev->channel_init_packet;\n\n    runtime_memset((u8 *)init_pkt, 0, sizeof(nvsp_msg));\n\n    init_pkt->hdr.msg_type = nvsp_msg_1_type_send_rx_buf;\n    init_pkt->msgs.vers_1_msgs.send_rx_buf.gpadl_handle =\n        net_dev->rx_buf_gpadl_handle;\n    init_pkt->msgs.vers_1_msgs.send_rx_buf.id =\n        NETVSC_RECEIVE_BUFFER_ID;\n\n    /* Send the gpadl notification request */\n\n    hv_nv_prepare_wait_for_channel_message(net_dev);\n    ret = vmbus_chan_send(device->channel,\n        VMBUS_CHANPKT_TYPE_INBAND, VMBUS_CHANPKT_FLAG_RC,\n        init_pkt, sizeof(nvsp_msg), (uint64_t)init_pkt);\n    if (ret != 0) {\n        goto cleanup;\n    }\n\n    hv_nv_wait_for_channel_message(net_dev);\n\n    /* Check the response */\n    if (init_pkt->msgs.vers_1_msgs.send_rx_buf_complete.status\n        != nvsp_status_success) {\n        ret = EINVAL;\n        goto cleanup;\n    }\n\n    net_dev->rx_section_count =\n        init_pkt->msgs.vers_1_msgs.send_rx_buf_complete.num_sections;\n\n    net_dev->rx_sections = allocate(sc->general, (net_dev->rx_section_count *\n        sizeof(nvsp_1_rx_buf_section)));\n    assert(net_dev->rx_sections != INVALID_ADDRESS);\n\n    runtime_memcpy(net_dev->rx_sections,\n        init_pkt->msgs.vers_1_msgs.send_rx_buf_complete.sections,\n        net_dev->rx_section_count * sizeof(nvsp_1_rx_buf_section));\n\n\n    /*\n     * For first release, there should only be 1 section that represents\n     * the entire receive buffer\n     */\n    if (net_dev->rx_section_count != 1\n        || net_dev->rx_sections->offset != 0) {\n        ret = EINVAL;\n        goto cleanup;\n    }\n\n    goto exit;\n\ncleanup:\n    hv_nv_destroy_rx_buffer(net_dev);\n\nexit:\n    return (ret);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC on send\n * Sends a packet on the specified Hyper-V device.\n * Returns 0 on success, non-zero on failure.\n */\n", "func_signal": "int\nhv_nv_on_send(struct hv_device *device, netvsc_packet *pkt)", "code": "{\n    netvsc_dev *net_dev;\n    nvsp_msg send_msg;\n    int ret;\n\n    net_dev = hv_nv_get_outbound_net_device(device);\n    if (!net_dev)\n        return (ENODEV);\n\n    send_msg.hdr.msg_type = nvsp_msg_1_type_send_rndis_pkt;\n    if (pkt->is_data_pkt) {\n        /* 0 is RMC_DATA */\n        send_msg.msgs.vers_1_msgs.send_rndis_pkt.chan_type = 0;\n    } else {\n        /* 1 is RMC_CONTROL */\n        send_msg.msgs.vers_1_msgs.send_rndis_pkt.chan_type = 1;\n    }\n\n    /* Not using send buffer section */\n    send_msg.msgs.vers_1_msgs.send_rndis_pkt.send_buf_section_idx =\n        0xFFFFFFFF;\n    send_msg.msgs.vers_1_msgs.send_rndis_pkt.send_buf_section_size = 0;\n\n    if (pkt->page_buf_count) {\n        ret = vmbus_chan_send_sglist(device->channel,\n            pkt->page_buffers, pkt->page_buf_count,\n            &send_msg, sizeof(nvsp_msg), (uint64_t)pkt);\n    } else {\n        ret = vmbus_chan_send(device->channel,\n            VMBUS_CHANPKT_TYPE_INBAND, VMBUS_CHANPKT_FLAG_RC,\n            &send_msg, sizeof(nvsp_msg), (uint64_t)pkt);\n    }\n\n    /* Record outstanding send only if send_packet() succeeded */\n    if (ret == 0)\n        atomic_add32(&net_dev->num_outstanding_sends, 1);\n\n    return (ret);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC initialize send buffer with net VSP\n */\n", "func_signal": "static int\nhv_nv_init_send_buffer_with_net_vsp(struct hv_device *device)", "code": "{\n    hn_softc_t *sc = device->device;\n    netvsc_dev *net_dev;\n    nvsp_msg *init_pkt;\n    int ret = 0;\n\n    net_dev = hv_nv_get_outbound_net_device(device);\n    if (!net_dev) {\n        return (ENODEV);\n    }\n\n    net_dev->send_buf = allocate_zero(sc->contiguous, net_dev->send_buf_size);\n    assert(net_dev->send_buf != INVALID_ADDRESS);\n    assert((u64)net_dev->send_buf == pad((u64)net_dev->send_buf, PAGESIZE));\n\n    bus_addr_t send_buf_paddr = physical_from_virtual(net_dev->send_buf);\n    assert(send_buf_paddr != INVALID_PHYSICAL);\n    /*\n     * Establish the gpadl handle for this buffer on this channel.\n     * Note:  This call uses the vmbus connection rather than the\n     * channel to establish the gpadl handle. \n     */\n    vmbus_chan_gpadl_connect(device->channel,\n        send_buf_paddr, net_dev->send_buf_size,\n        &net_dev->send_buf_gpadl_handle);\n\n    /* Notify the NetVsp of the gpadl handle */\n\n    init_pkt = &net_dev->channel_init_packet;\n\n    zero(init_pkt, sizeof(nvsp_msg));\n\n    init_pkt->hdr.msg_type = nvsp_msg_1_type_send_send_buf;\n    init_pkt->msgs.vers_1_msgs.send_rx_buf.gpadl_handle =\n        net_dev->send_buf_gpadl_handle;\n    init_pkt->msgs.vers_1_msgs.send_rx_buf.id =\n        NETVSC_SEND_BUFFER_ID;\n\n    /* Send the gpadl notification request */\n\n    hv_nv_prepare_wait_for_channel_message(net_dev);\n    ret = vmbus_chan_send(device->channel,\n        VMBUS_CHANPKT_TYPE_INBAND,\n        VMBUS_CHANPKT_FLAG_RC,\n        init_pkt, sizeof(nvsp_msg), (uint64_t)init_pkt);\n    if (ret != 0) {\n        goto cleanup;\n    }\n\n    hv_nv_wait_for_channel_message(net_dev);\n\n    /* Check the response */\n    if (init_pkt->msgs.vers_1_msgs.send_send_buf_complete.status\n        != nvsp_status_success) {\n        ret = EINVAL;\n        goto cleanup;\n    }\n\n    net_dev->send_section_size =\n        init_pkt->msgs.vers_1_msgs.send_send_buf_complete.section_size;\n\n    goto exit;\n\ncleanup:\n    hv_nv_destroy_send_buffer(net_dev);\n\nexit:\n    return (ret);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC on device add\n * \n * Callback when the device belonging to this driver is added\n */\n", "func_signal": "netvsc_dev *\nhv_nv_on_device_add(struct hv_device *device, void *additional_info)", "code": "{\n    netvsc_dev *net_dev;\n    netvsc_packet *packet;\n\n    net_dev = hv_nv_alloc_net_device(device);\n    assert(net_dev != INVALID_ADDRESS);\n\n    /* Initialize the NetVSC channel extension */\n    net_dev->rx_buf_size = NETVSC_RECEIVE_BUFFER_SIZE;\n    spin_lock_init(&net_dev->rx_pkt_list_lock);\n\n    net_dev->send_buf_size = NETVSC_SEND_BUFFER_SIZE;\n\n    list_init(&net_dev->myrx_packet_list);\n\n    /* \n     * malloc a sufficient number of netvsc_packet buffers to hold\n     * a packet list.  Add them to the netvsc device packet queue.\n     */\n    for (int i=0; i < NETVSC_RECEIVE_PACKETLIST_COUNT; i++) {\n        packet = allocate_zero(device->device->general,\n            sizeof(netvsc_packet) + (NETVSC_RECEIVE_SG_COUNT * sizeof(struct vmbus_gpa_range)));\n        assert(packet != INVALID_ADDRESS);\n        list_push_back(&net_dev->myrx_packet_list, &packet->mylist_entry);\n    }\n\n    /*\n     * Open the channel\n     */\n    vmbus_chan_open(device->channel,\n        NETVSC_DEVICE_RING_BUFFER_SIZE, NETVSC_DEVICE_RING_BUFFER_SIZE,\n        NULL, 0, hv_nv_on_channel_callback, device, runqueue);\n    /*\n     * Connect with the NetVsp\n     */\n    int ret = hv_nv_connect_to_vsp(device);\n    assert(ret == 0);\n\n    netvsc_debug(\"CONNECTED TO VSP!\");\n    return (net_dev);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * mmap and munmap a new file with appropriate permissions\n */\n", "func_signal": "static void mmap_newfile_test(void)", "code": "{\n    int fd;\n    const size_t maplen = 1;\n    void *addr;\n\n    fd = open(\"new_file\", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n    if (fd < 0) {\n        perror(\"new file open\");\n        exit(EXIT_FAILURE);\n    }\n    addr = mmap(NULL, maplen, PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (addr == MAP_FAILED) {\n        perror(\"new file  mmap\");\n        exit(EXIT_FAILURE);\n    }\n    if (munmap(addr, maplen) < 0) {\n        perror(\"new file  munmap\");\n        exit(EXIT_FAILURE);\n    }\n    if (close(fd) < 0) {\n        perror(\"new file close\");\n        exit(EXIT_FAILURE);\n    }\n}", "path": "nanos/test/runtime/mmap.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC destroy send buffer\n */\n", "func_signal": "static int\nhv_nv_destroy_send_buffer(netvsc_dev *net_dev)", "code": "{\n    hn_softc_t *sc = net_dev->dev->device;\n    nvsp_msg *revoke_pkt;\n    int ret = 0;\n\n    /*\n     * If we got a section count, it means we received a\n     * send_rx_buf_complete msg \n     * (ie sent nvsp_msg_1_type_send_rx_buf msg) therefore,\n     * we need to send a revoke msg here\n     */\n    if (net_dev->send_section_size) {\n        /* Send the revoke send buffer */\n        revoke_pkt = &net_dev->revoke_packet;\n        runtime_memset((u8 *)revoke_pkt, 0, sizeof(nvsp_msg));\n\n        revoke_pkt->hdr.msg_type =\n            nvsp_msg_1_type_revoke_send_buf;\n        revoke_pkt->msgs.vers_1_msgs.revoke_send_buf.id =\n            NETVSC_SEND_BUFFER_ID;\n\n        ret = vmbus_chan_send(net_dev->dev->channel,\n            VMBUS_CHANPKT_TYPE_INBAND, 0,\n            revoke_pkt, sizeof(nvsp_msg), (uint64_t)revoke_pkt);\n        /*\n         * If we failed here, we might as well return and have a leak \n         * rather than continue and a bugchk\n         */\n        if (ret != 0) {\n            return (ret);\n        }\n    }\n\n    /* Tear down the gpadl on the vsp end */\n    if (net_dev->send_buf_gpadl_handle) {\n        vmbus_chan_gpadl_disconnect(net_dev->dev->channel,\n            net_dev->send_buf_gpadl_handle);\n\n        net_dev->send_buf_gpadl_handle = 0;\n    }\n\n    if (net_dev->send_buf) {\n        /* Free up the receive buffer */\n        deallocate(sc->contiguous, net_dev->send_buf, net_dev->send_buf_size);\n        net_dev->send_buf = NULL;\n    }\n\n    return (ret);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC destroy receive buffer\n */\n", "func_signal": "static int\nhv_nv_destroy_rx_buffer(netvsc_dev *net_dev)", "code": "{\n    hn_softc_t *sc = net_dev->dev->device;\n    nvsp_msg *revoke_pkt;\n    int ret = 0;\n\n    /*\n     * If we got a section count, it means we received a\n     * send_rx_buf_complete msg \n     * (ie sent nvsp_msg_1_type_send_rx_buf msg) therefore,\n     * we need to send a revoke msg here\n     */\n    if (net_dev->rx_section_count) {\n        /* Send the revoke receive buffer */\n        revoke_pkt = &net_dev->revoke_packet;\n        zero(revoke_pkt, sizeof(nvsp_msg));\n\n        revoke_pkt->hdr.msg_type = nvsp_msg_1_type_revoke_rx_buf;\n        revoke_pkt->msgs.vers_1_msgs.revoke_rx_buf.id =\n            NETVSC_RECEIVE_BUFFER_ID;\n\n        ret = vmbus_chan_send(net_dev->dev->channel,\n            VMBUS_CHANPKT_TYPE_INBAND, 0,\n            revoke_pkt, sizeof(nvsp_msg), (uint64_t)revoke_pkt);\n\n        /*\n         * If we failed here, we might as well return and have a leak \n         * rather than continue and a bugchk\n         */\n        if (ret != 0) {\n            return (ret);\n        }\n    }\n\n    /* Tear down the gpadl on the vsp end */\n    if (net_dev->rx_buf_gpadl_handle) {\n        vmbus_chan_gpadl_disconnect(net_dev->dev->channel,\n            net_dev->rx_buf_gpadl_handle);\n        /*\n         * If we failed here, we might as well return and have a leak \n         * rather than continue and a bugchk\n         */\n        if (ret != 0) {\n            return (ret);\n        }\n        net_dev->rx_buf_gpadl_handle = 0;\n    }\n\n    if (net_dev->rx_buf) {\n        /* Free up the receive buffer */\n        deallocate(sc->contiguous, net_dev->rx_buf, net_dev->rx_buf_size);\n        net_dev->rx_buf = NULL;\n    }\n\n    if (net_dev->rx_sections) {\n        deallocate(sc->general, net_dev->rx_sections, (net_dev->rx_section_count *\n                                                       sizeof(nvsp_1_rx_buf_section)));\n        net_dev->rx_sections = NULL;\n        net_dev->rx_section_count = 0;\n    }\n\n    return (ret);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * XXX: currently, mincore never returns -ENOMEM, but it does\n * set the vector entries to 0 for non-mapped memory\n */\n", "func_signal": "static void __mincore(void * addr, unsigned long length, uint8_t * vec, \n        uint8_t * expected)", "code": "{\n    int ret;\n\n    ret = mincore(addr, length, vec);\n    if (ret) {\n        perror(\"mincore failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (!check_mincore_vec(vec, expected, (length >> PAGELOG))) {\n        fprintf(stderr, \"mincore did not set vector entries correctly\\n\");\n        exit(EXIT_FAILURE);\n    }\n}", "path": "nanos/test/runtime/mmap.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/* \n * munmap the range in several independent 2MB calls to munmap\n * to test the kernel's heap management code\n */\n", "func_signal": "static void chunked_munmap(void * addr, unsigned long size)", "code": "{\n    int * permutation, i;\n    int nr_pages = size >> PAGELOG;\n\n    permutation = malloc(sizeof(int) * nr_pages);\n    if (permutation == NULL) {\n        perror(\"malloc\");\n        exit(EXIT_FAILURE);\n    }\n    permute(permutation, nr_pages);\n\n    for (i = 0; i < nr_pages; i++) {\n        void * unmap_at = addr + (permutation[i] << PAGELOG);\n        __munmap(unmap_at, PAGESIZE);\n    }\n\n    free(permutation);\n}", "path": "nanos/test/runtime/mmap.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "/*\n * Net VSC on channel callback\n */\n", "func_signal": "static void\nhv_nv_on_channel_callback(struct vmbus_channel *context, void *hv_device)", "code": "{\n    /* Fixme:  Magic number */\n    const int net_pkt_size = 2048;\n    struct hv_device *device = (struct hv_device *)hv_device;\n    netvsc_dev *net_dev;\n    int     bufferlen = net_pkt_size;\n    int     ret = 0;\n\n    uint8_t *buffer = allocate(device->device->general, net_pkt_size * sizeof(uint8_t));\n    assert(buffer != INVALID_ADDRESS);\n\n    net_dev = hv_nv_get_inbound_net_device(device);\n    assert(net_dev != NULL);\n\n    do {\n        struct vmbus_chanpkt_hdr *desc = (struct vmbus_chanpkt_hdr *)buffer;\n        int bytes_rxed = bufferlen;\n        ret = vmbus_chan_recv_pkt(device->channel,\n            desc, &bytes_rxed);\n        if (ret == ENOBUFS) {\n            /* Handle large packet */\n            deallocate(device->device->general, buffer, bufferlen);\n            buffer = allocate(device->device->general, bytes_rxed);\n            if (buffer == INVALID_ADDRESS) {\n                break;\n            }\n            bufferlen = bytes_rxed;\n            continue;\n        } else if (ret == EAGAIN) {\n            /* No more channel packets; done! */\n            break;\n        }\n        assert(ret == 0);\n        switch (desc->cph_type) {\n        case VMBUS_CHANPKT_TYPE_COMP:\n            hv_nv_on_send_completion(device, desc);\n            break;\n        case VMBUS_CHANPKT_TYPE_RXBUF:\n            hv_nv_on_receive(device, desc);\n            break;\n        default:\n            break;\n        }\n    } while (1);\n    deallocate(device->device->general, buffer, bufferlen);\n}", "path": "nanos/src/hyperv/netvsc/hv_net_vsc.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nanovms/nanos", "stars": 2162, "license": "apache-2.0", "language": "c", "size": 9856}
{"docstring": "// \u4ee5\u56fe\u5f62\u5316\u5f62\u5f0f\u8f93\u51fa\u5f53\u524d\u7ed3\u6784\n", "func_signal": "void PrintTree(CSTree T)", "code": "{\n    \n    // \u9047\u5230\u7a7a\u6811\u5219\u65e0\u9700\u7ee7\u7eed\u8ba1\u7b97\n    if(TreeEmpty(T)) {\n        printf(\"\\n\");\n        return;\n    }\n    \n    Print(T, 0);\n    \n    printf(\"\\n\");\n}", "path": "Data-Structure/CLion/ExerciseBook/07.32/CSTree.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u5224\u65ad\u5e8f\u5217s\u662f\u5426\u4e3a\u56de\u6587\u5e8f\u5217\n * \u7a7a\u4e32\u4e5f\u88ab\u89c6\u4e3a\u56de\u6587\u5e8f\u5217\n */\n", "func_signal": "Status Algo_3_31(char* s)", "code": "{\n    int len;\n    int i;\n    int m, n;   // \u56de\u6587\u4e32\u524d\u534a\u6bb5\u7684\u7ed3\u5c3e\u4e0b\u6807\u548c\u540e\u534a\u6bb5\u7684\u5f00\u59cb\u4e0b\u6807\n    SqStack S;\n    SElemType e;\n    \n    len = (int) strlen(s);\n    \n    if(len == 0 || s[len - 1] != '@') {\n        return FALSE;\n    }\n    \n    // \u7a7a\u4e32\u88ab\u8ba4\u4e3a\u662f\u56de\u6587\u5e8f\u5217\n    if(len == 1) {\n        return TRUE;\n    }\n    \n    if(len % 2 == 0) {\n        m = (len - 2) / 2 - 1;\n        n = m + 2;\n    } else {\n        m = (len - 2) / 2;\n        n = m + 1;\n    }\n    \n    InitStack(&S);\n    \n    // \u5148\u628a\u56de\u6587\u4e32\u524d\u534a\u6bb5\u5165\u6808\n    for(i = 0; i <= m; i++) {\n        Push(&S, s[i]);\n    }\n    \n    // \u53d6\u51fa\u56de\u6587\u4e32\u524d\u534a\u6bb5\uff0c\u4e0e\u5b57\u7b26\u4e32\u5e8f\u5217\u540e\u534a\u6bb5\u6bd4\u5bf9\n    for(i = n; i <= len - 2; i++) {\n        if(!StackEmpty(S)) {\n            Pop(&S, &e);\n        } else {\n            break;\n        }\n        \n        if(s[i] != e) {\n            return ERROR;\n        }\n    }\n    \n    // \u5b8c\u7f8e\u7684\u72b6\u6001\u5e94\u8be5\u662f\u6808\u6b63\u597d\u4e3a\u7a7a\uff0c\u4e14i\u4e3alen-1\n    if(!(StackEmpty(S) && i == len - 1)) {\n        return ERROR;\n    }\n    \n    return OK;\n}", "path": "Data-Structure/CLion/ExerciseBook/03.31/03.31.c", "commit_date": "2019-11-04 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u63d2\u5165\u8fb9/\u5f27<v, w>\n *\n * \u5982\u679c\u5f53\u524d\u56fe/\u7f51\u662f\u65e0\u5411\u7684\uff0c\u5219\u63d2\u5165\u4e00\u6761\u5f27\u9700\u8981\u589e\u52a0\u4e24\u4e2a\u9876\u70b9\u5173\u7cfb\uff0c\u4f46\u5f27\u7684\u6570\u91cf\u53ea\u589e\u4e00\u3002\n * \u5bf9\u4e8e\u56fe/\u7f51\u6765\u8bf4\uff0c\u53ef\u4ee5\u5728\u53ef\u53d8\u53c2\u6570\u4e2d\u5217\u51fa\u8fb9/\u5f27\u7684\u9644\u52a0\u4fe1\u606f\u3002\n *\n * \u6ce8\uff1a\u6b64\u5904\u63a5\u6536\u7684\u53c2\u6570\u4e0eMGraph\u6709\u4e9b\u4e0d\u4e00\u6837\uff1a\u7f51\u7684\u9644\u52a0\u4fe1\u606f\u4e2d\u5305\u542b\u4e86\u5404\u6761\u8fb9/\u5f27\u7684\u6743\u503c\u3002\n */\n", "func_signal": "Status InsertArc(ALGraph* G, VertexType v, VertexType w, ...)", "code": "{\n    int tail, head, k, count;\n    ArcNode* r;\n    ArcNode* pre;\n    Boolean overlay = FALSE;    // \u662f\u5426\u4e3a\u8986\u76d6\u6dfb\u52a0\n    InfoType* info = NULL;      // \u8fb9/\u5f27\u7684\u9644\u52a0\u4fe1\u606f\n    va_list ap;\n    \n    tail = LocateVex(*G, v); // \u83b7\u53d6\u9876\u70b9v\u5728\u9876\u70b9\u96c6\u4e2d\u7684\u4f4d\u7f6e\n    if(tail == -1) {\n        return ERROR;  // \u6307\u5b9a\u7684\u9876\u70b9\u4e0d\u5b58\u5728\n    }\n    \n    head = LocateVex(*G, w); // \u83b7\u53d6\u9876\u70b9w\u5728\u9876\u70b9\u96c6\u4e2d\u7684\u4f4d\u7f6e\n    if(head == -1) {\n        return ERROR;  // \u6307\u5b9a\u7684\u9876\u70b9\u4e0d\u5b58\u5728\n    }\n    \n    // \u62d2\u7edd\u73af\n    if(tail == head) {\n        return ERROR;\n    }\n    \n    // \u5982\u679c\u8fb9/\u5f27\u4e0a\u5b58\u5728\u9644\u52a0\u4fe1\u606f\n    if(IncInfo) {\n        va_start(ap, w);                // \u5728w\u540e\u67e5\u8be2\u9996\u4e2a\u53ef\u53d8\u53c2\u6570\n        info = va_arg(ap, InfoType*);   // \u83b7\u53d6\u9644\u52a0\u4fe1\u606f\n        va_end(ap);\n    }\n    \n    /* \u63a5\u4e0b\u6765\uff0c\u9700\u8981\u67e5\u627e\u5408\u9002\u7684\u63d2\u5165\u4f4d\u7f6e */\n    \n    for(count = 0; count < 2; count++) {\n        pre = NULL;\n        // \u6307\u5411\u4ee5tail\u4e3a\u5c3e\u7684\u9996\u6761\u8fb9/\u5f27\n        r = G->vertices[tail].firstarc;\n        while(r != NULL && r->adjvex < head) {\n            pre = r;\n            r = r->nextarc;\n        }\n        \n        // \u9047\u5230\u4e86\u76f8\u540c\u4f4d\u7f6e\u7684\u7ed3\u70b9\n        if(r != NULL && r->adjvex == head) {\n            r->info = info; // \u590d\u7528\u8be5\u7ed3\u70b9\n            overlay = TRUE; // \u53d1\u751f\u4e86\u8986\u76d6\n        } else {\n            if(pre == NULL) {\n                G->vertices[tail].firstarc = newArcNodePtr(head, r, info);\n            } else {\n                pre->nextarc = newArcNodePtr(head, r, info);\n            }\n        }\n        \n        // \u5982\u679c\u5f53\u524d\u56fe/\u7f51\u662f\u65e0\u5411\u7684\uff0c\u9700\u8981\u8003\u8651\u5bf9\u79f0\u6027\n        if((G->kind == UDG || G->kind == UDN) && tail != head) {\n            // \u98a0\u5012i\u548cj\n            k = tail;\n            tail = head;\n            head = k;\n        } else {\n            break;  // \u5982\u679c\u662f\u6709\u5411\u7684\uff0c\u53ef\u4ee5\u7ed3\u675f\u4e86\n        }\n    }\n    \n    // \u5728\u975e\u8986\u76d6\u7684\u60c5\u5f62\u4e0b\uff0c\u624d\u8003\u8651\u66f4\u65b0\u8fb9/\u5f27\u7684\u6570\u91cf\n    if(!overlay) {\n        (*G).arcnum++;  // \u4e0d\u8bba\u6709\u5411\u65e0\u5411\uff0c\u8fb9/\u5f27\u6570\u53ea\u589e\u4e00\n    }\n    \n    return OK;\n}", "path": "Data-Structure/CLion/ExerciseBook/07.36-07.37/ALGraph.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "// \u521d\u59cb\u5316\uff1a\u6784\u9020\u4e00\u4e2a\u503c\u4e3as\u7684\u4e32t\n", "func_signal": "void StrAssign(StringType* t, const char* s)", "code": "{\n    if(s == NULL) {\n        *t = \"\";\n    }\n    \n    *t = (char*) malloc((strlen(s) + 1) * sizeof(char));\n    \n    strcpy(*t, s);\n}", "path": "Data-Structure/CLion/ExerciseBook/04.12/String.c", "commit_date": "2019-11-12 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u51fa\u6808\n *\n * \u5c06\u6808\u9876\u5143\u7d20\u5f39\u51fa\uff0c\u5e76\u7528e\u63a5\u6536\u3002\n */\n", "func_signal": "Status Pop(SqStack* S, SElemType* e)", "code": "{\n    if(S == NULL || (*S).base == NULL) {\n        return ERROR;\n    }\n    \n    if((*S).top == (*S).base) {\n        return ERROR;\n    }\n    \n    // \u51fa\u6808\u6808\u9876\u6307\u9488\u5148\u9012\u51cf\uff0c\u518d\u8d4b\u503c\n    *e = *(--(*S).top);\n    \n    return OK;\n}", "path": "Data-Structure/CLion/CourseBook/0305_Expression/SqStack.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "// \u63d2\u5165\uff1a\u5728s\u7684pos\u5904\u63d2\u5165t\n", "func_signal": "Status StrInsert(StringType* s, int pos, StringType t)", "code": "{\n    StringType r;\n    StringType s1, s2;\n    \n    if(pos < 1 || pos > StrLength(*s) + 1) {\n        return ERROR;\n    }\n    \n    r = (StringType) malloc((strlen(*s) + strlen(t) + 1) * sizeof(char));\n    r[0] = '\\0';\n    \n    // \u5982\u679c\u5f85\u63d2\u5165\u7684\u4e32\u4e3a\u7a7a\uff0c\u5219\u63d0\u524d\u8fd4\u56de\n    if(StrLength(t) == 0) {\n        return OK;\n    }\n    \n    s1 = SubString(*s, 1, pos - 1);\n    s2 = SubString(*s, pos, (int) strlen(*s) - pos + 1);\n    \n    strcat(r, s1);\n    strcat(r, t);\n    strcat(r, s2);\n    \n    *s = r;\n    \n    return OK;\n}", "path": "Data-Structure/CLion/ExerciseBook/04.12/String.c", "commit_date": "2019-11-12 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "// \u8054\u63a5\uff1a\u8fd4\u56de\u7531s\u4e0et\u8054\u63a5\u540e\u7684\u4e32\n", "func_signal": "StringType Concat(StringType s, StringType t)", "code": "{\n    StringType r;\n    \n    if(s == NULL) {\n        s = \"\";\n    }\n    \n    if(t == NULL) {\n        t = \"\";\n    }\n    \n    r = (char*) malloc((strlen(s) + strlen(t) + 1) * sizeof(char));\n    r[0] = '\\0';\n    \n    strcat(r, s);\n    strcat(r, t);\n    \n    return r;\n}", "path": "Data-Structure/CLion/ExerciseBook/04.12/String.c", "commit_date": "2019-11-12 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u521b\u5efa\n *\n *\u3010\u5907\u6ce8\u3011\n *\n * \u6559\u6750\u4e2d\u9ed8\u8ba4\u4ece\u63a7\u5236\u53f0\u8bfb\u53d6\u6570\u636e\u3002\n * \u8fd9\u91cc\u4e3a\u4e86\u65b9\u4fbf\u6d4b\u8bd5\uff0c\u907f\u514d\u6bcf\u6b21\u8fd0\u884c\u90fd\u624b\u52a8\u8f93\u5165\u6570\u636e\uff0c\n * \u56e0\u800c\u5141\u8bb8\u9009\u62e9\u4ece\u9884\u8bbe\u7684\u6587\u4ef6path\u4e2d\u8bfb\u53d6\u6d4b\u8bd5\u6570\u636e\u3002\n *\n * \u5982\u679c\u9700\u8981\u4ece\u63a7\u5236\u53f0\u8bfb\u53d6\u6570\u636e\uff0c\u5219path\u4e3aNULL\uff0c\u6216path[kind]\u4e3a\"\"\u3002\n * \u5982\u679c\u9700\u8981\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6570\u636e\uff0c\u5219\u9700\u8981\u5728path\u4e2d\u586b\u5199\u6587\u4ef6\u540d\u4fe1\u606f\u3002\n */\n", "func_signal": "Status CreateGraph(ALGraph* G, char* path[])", "code": "{\n    int readFromConsole;    // \u662f\u5426\u4ece\u63a7\u5236\u53f0\u8bfb\u53d6\u6570\u636e\n    int kind;\n    Status flag;\n    \n    // \u2605\u2605\u2605\u6b64\u5904\u56fa\u5b9a\u4e3a\u6709\u5411\u56fe\n    kind = 0;\n    \n    // \u5982\u679c\u6ca1\u6709\u6587\u4ef6\u8def\u5f84\u4fe1\u606f\uff0c\u5219\u4ece\u63a7\u5236\u53f0\u8bfb\u53d6\u8f93\u5165\n    readFromConsole = (path == NULL) || strcmp(path[kind], \"\") == 0;\n    \n    // \u9700\u8981\u4ece\u6587\u4ef6\u8bfb\u53d6\n    if(readFromConsole) {\n        (*G).kind = kind;   // \u8bb0\u5f55\u56fe/\u7f51\u7684\u7c7b\u578b\n    } else {\n        // \u6253\u5f00\u6587\u4ef6\uff0c\u51c6\u5907\u8bfb\u53d6\u6d4b\u8bd5\u6570\u636e\n        fp = fopen(path[kind], \"r\");\n        if(fp == NULL) {\n            return ERROR;\n        }\n        \n        // \u5f55\u5165\u56fe\u7684\u7c7b\u578b\n        ReadData(fp, \"%d\", &((*G).kind));\n    }\n    \n    // \u968f\u673a\u521b\u5efa\u6709\u5411\u56fe/\u7f51\u6216\u65e0\u5411\u56fe/\u7f51\u7684\u4e00\u79cd\n    switch((*G).kind) {\n        case DG:\n            flag = CreateDG(G);\n            break;\n        default:\n            flag = ERROR;\n            break;\n    }\n    \n    if(fp != NULL) {\n        fclose(fp);\n        fp = NULL;\n    }\n    \n    return flag;\n}", "path": "Data-Structure/CLion/ExerciseBook/07.36-07.37/ALGraph.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u5224\u7a7a\n *\n * \u5224\u65ad\u987a\u5e8f\u6808\u4e2d\u662f\u5426\u5305\u542b\u6709\u6548\u6570\u636e\u3002\n *\n * \u8fd4\u56de\u503c\uff1a\n * TRUE : \u987a\u5e8f\u6808\u4e3a\u7a7a\n * FALSE: \u987a\u5e8f\u6808\u4e0d\u4e3a\u7a7a\n */\n", "func_signal": "Status StackEmpty(SqStack S)", "code": "{\n    if(S.top == S.base) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}", "path": "Data-Structure/CLion/CourseBook/0305_Expression/SqStack.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "// \u5220\u9664\uff1a\u4eces\u7684pos\u4f4d\u7f6e\u8d77\uff0c\u5220\u9664len\u4e2a\u5b57\u7b26\n", "func_signal": "Status StrDelete(StringType* s, int pos, int len)", "code": "{\n    StringType r;\n    \n    if(pos < 1 || pos + len - 1 > StrLength(*s) || len < 0) {\n        return ERROR;\n    }\n    \n    // \u5982\u679c\u5f85\u5220\u9664\u7684\u957f\u5ea6\u4e3a0\uff0c\u5219\u63d0\u524d\u8fd4\u56de\n    if(len == 0) {\n        return OK;\n    }\n    \n    r = (StringType) malloc((StrLength(*s) - len + 1) * sizeof(char));\n    strncpy(r, *s, pos - 1);\n    strcpy(r + pos - 1, *s + pos + len - 1);\n    \n    *s = r;\n    \n    return OK;\n}", "path": "Data-Structure/CLion/ExerciseBook/04.12/String.c", "commit_date": "2019-11-12 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "//**\u25b206 \u6811\u548c\u4e8c\u53c9\u6811**//\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n    List A;\n    \n    printf(\"\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 CreatePowerSet \\n\");\n    {\n        printf(\"\u2588 \u521b\u5efa\u96c6\u5408 A ...\\n\");\n        CreatePowerSet(&A, \"TestData_A.txt\");\n    }\n    PressEnterToContinue(debug);\n    \n    \n    printf(\"\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 PrintPowerSet \\n\");\n    {\n        printf(\"\u2588 \u8f93\u51fa\u96c6\u5408 A = \");\n        PrintPowerSet(A);\n    }\n    PressEnterToContinue(debug);\n    \n    \n    printf(\"\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 GetPowerSet \\n\");\n    {\n        LinkList B;\n        \n        printf(\"\u2588 \u8ba1\u7b97\u96c6\u5408\u7684\u5e42\u96c6...\\n\");\n        \n        printf(\"\u2588 \u521b\u5efa\u96c6\u5408 B \u4e34\u65f6\u5b58\u50a8\u5e42\u96c6\u5143\u7d20...\\n\");\n        InitList(&B);\n        \n        printf(\"\u2588 \u4f9d\u6b21\u8f93\u51fa\u6c42\u53d6\u7684\u5e42\u96c6\u4e2d\u7684\u5404\u5b50\u96c6...\\n\");\n        GetPowerSet(1, A, B);\n    }\n    PressEnterToContinue(debug);\n    \n    return OK;\n}", "path": "Data-Structure/CLion/CourseBook/0610_PowerSet/PowerSet-main.c", "commit_date": "2020-02-14 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "// \u6c42\u5b50\u4e32\uff1a\u4eces\u7684start\u4f4d\u7f6e\u8d77\uff0c\u622a\u53d6len\u4e2a\u5b57\u7b26\u540e\u8fd4\u56de\n", "func_signal": "StringType SubString(StringType s, int start, int len)", "code": "{\n    int n;\n    char* sub;\n    \n    n = (int) strlen(s);\n    \n    if(start < 1 || start > n || start + len - 1 > n || len < 0) {\n        return \"\";\n    }\n    \n    sub = (char*) malloc((len + 1) * sizeof(char));\n    strncpy(sub, s + start - 1, len);\n    sub[len] = '\\0';\n    \n    return sub;\n}", "path": "Data-Structure/CLion/ExerciseBook/04.12/String.c", "commit_date": "2019-11-12 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u6784\u9020\u6709\u5411\u56fe\n */\n", "func_signal": "static Status CreateDG(ALGraph* G)", "code": "{\n    int i, k;\n    int vexnum, arcnum;\n    VertexType v1, v2;\n    InfoType* info = NULL;\n    \n    (*G).vexnum = (*G).arcnum = 0;\n    \n    if(fp == NULL) {\n        printf(\"\u8bf7\u8f93\u5165\u6709\u5411\u56fe\u7684\u9876\u70b9\u6570\uff1a\");\n        scanf(\"%d\", &vexnum);\n        printf(\"\u8bf7\u8f93\u5165\u6709\u5411\u56fe\u7684\u5f27\u6570\uff1a\");\n        scanf(\"%d\", &arcnum);\n        printf(\"\u8be5\u6709\u5411\u56fe\u7684\u5f27\u4e0a\u662f\u5426\u5305\u542b\u5176\u4ed6\u9644\u52a0\u4fe1\u606f(0-\u4e0d\u5305\u542b\u25021-\u5305\u542b)\uff1a\");\n        scanf(\"%d\", &IncInfo);\n        \n        // \u5f55\u5165\u9876\u70b9\u96c6\n        printf(\"\u8bf7\u5f55\u5165 %d \u4e2a\u9876\u70b9\uff0c\u4e0d\u540c\u9876\u70b9\u4e4b\u95f4\u7528\u7a7a\u683c\u9694\u5f00\uff1a\", vexnum);\n        for(i = 0; i < vexnum; i++) {\n            // \u8df3\u8fc7\u7a7a\u767d\uff0c\u5bfb\u627e\u4e0b\u4e00\u4e2a\"\u53ef\u8bfb\"\u7b26\u53f7\n            skipBlank(stdin);\n            scanf(\"%c\", &((*G).vertices[i].data));\n            (*G).vertices[i].firstarc = NULL;\n            (*G).vexnum++;\n        }\n    } else {\n        ReadData(fp, \"%d\", &vexnum);    // \u5f55\u5165\u9876\u70b9\u6570\n        ReadData(fp, \"%d\", &arcnum);    // \u5f55\u5165\u5f27\u6570\n        ReadData(fp, \"%d\", &IncInfo);   // \u5224\u65ad\u5f27\u4e0a\u662f\u5426\u5305\u542b\u9644\u52a0\u4fe1\u606f\n        \n        // \u5f55\u5165\u9876\u70b9\u96c6\n        for(i = 0; i < vexnum; i++) {\n            // \u8df3\u8fc7\u7a7a\u767d\uff0c\u5bfb\u627e\u4e0b\u4e00\u4e2a\"\u53ef\u8bfb\"\u7b26\u53f7\n            skipBlank(fp);\n            ReadData(fp, \"%c\", &((*G).vertices[i].data));\n            (*G).vertices[i].firstarc = NULL;\n            (*G).vexnum++;\n        }\n    }\n    \n    // \u4ec5\u5728\u63a7\u5236\u53f0\u5f55\u5165\u4fe1\u606f\u65f6\u8f93\u51fa\u6b64\u63d0\u793a\n    if(fp == NULL && arcnum != 0) {\n        printf(\"\u8bf7\u4e3a\u6709\u5411\u56fe\u4f9d\u6b21\u5f55\u5165 %d \u6761\u5f27\u7684\u4fe1\u606f\uff0c\u9876\u70b9\u4e4b\u95f4\u7528\u7a7a\u683c\u9694\u5f00\uff1a\\n\", arcnum);\n    }\n    \n    // \u5f55\u5165\u5f27\u7684\u4fe1\u606f\n    for(k = 0; k < arcnum; k++) {\n        if(fp == NULL) {\n            printf(\"\u7b2c %2d \u6761\u5f27\uff1a\", k + 1);\n            skipBlank(stdin);   // \u8df3\u8fc7\u7a7a\u767d\uff0c\u5bfb\u627e\u4e0b\u4e00\u4e2a\u53ef\u8bfb\u7b26\u53f7\n            scanf(\"%c\", &v1);\n            skipBlank(stdin);   // \u8df3\u8fc7\u7a7a\u767d\uff0c\u5bfb\u627e\u4e0b\u4e00\u4e2a\u53ef\u8bfb\u7b26\u53f7\n            scanf(\"%c\", &v2);\n        } else {\n            // \u8df3\u8fc7\u7a7a\u767d\uff0c\u5bfb\u627e\u4e0b\u4e00\u4e2a\u53ef\u8bfb\u7b26\u53f7\n            skipBlank(fp);\n            ReadData(fp, \"%c%c\", &v1, &v2);\n        }\n        \n        // \u5982\u679c\u9700\u8981\u5f55\u5165\u5f27\u7684\u5176\u4ed6\u9644\u52a0\u4fe1\u606f\n        if(IncInfo) {\n            // \u6700\u540e\u5f55\u5165\u9644\u52a0\u4fe1\u606f\n            Input(*G, &info);\n        }\n        \n        // \u63d2\u5165\u5f27<v1, v2>\n        InsertArc(G, v1, v2, info);\n    }\n    \n    // \u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6570\u636e\u65f6\uff0c\u6700\u540e\u5176\u5b9e\u5e94\u5f53\u5224\u65ad\u4e00\u4e0b\u662f\u5426\u8bfb\u5230\u4e86\u8db3\u591f\u7684\u4fe1\u606f\n    return OK;\n}", "path": "Data-Structure/CLion/ExerciseBook/07.36-07.37/ALGraph.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u521d\u59cb\u5316\n *\n * \u6784\u9020\u7a7a\u6811\u3002\n */\n", "func_signal": "Status InitTree(CSTree* T)", "code": "{\n    if(T == NULL) {\n        return ERROR;\n    }\n    \n    *T = NULL;\n    \n    return OK;\n}", "path": "Data-Structure/CLion/ExerciseBook/07.32/CSTree.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u4ee5\u56fe\u5f62\u5316\u5f62\u5f0f\u8f93\u51fa\u5f53\u524d\u7ed3\u6784\n */\n", "func_signal": "void PrintGraph(ALGraph G)", "code": "{\n    int i;\n    ArcNode* p;\n    \n    if(G.vexnum == 0) {\n        printf(\"\u7a7a\u56fe\uff0c\u65e0\u9700\u6253\u5370\uff01\\n\");\n        return;\n    }\n    \n    printf(\"\u5f53\u524d\u56fe/\u7f51\u5305\u542b %2d \u4e2a\u9876\u70b9\uff0c %2d \u6761\u8fb9/\u5f27...\\n\", G.vexnum, G.arcnum);\n    \n    for(i = 0; i < G.vexnum; i++) {\n        printf(\"%c ===> \", G.vertices[i].data);\n        \n        p = G.vertices[i].firstarc;\n        while(p != NULL) {\n            if(IncInfo == 0) {\n                printf(\"%c \", G.vertices[p->adjvex].data);\n                \n                // \u5bf9\u4e8e\u7f51\uff0c\u4f1a\u4ece\u5176\u9644\u52a0\u4fe1\u606f\u4e2d\u83b7\u53d6\u5230\u6743\u503c\n            } else {\n                printf(\"%c[%2d] \", G.vertices[p->adjvex].data, p->info->weight);\n            }\n            \n            p = p->nextarc;\n            \n            if(p != NULL) {\n                printf(\"- \");\n            }\n        }\n        \n        printf(\"\\n\");\n    }\n}", "path": "Data-Structure/CLion/ExerciseBook/07.36-07.37/ALGraph.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u53d6\u503c\n *\n * \u83b7\u53d6\u64cd\u4f5c\u7b26\u6808\u7684\u6808\u9876\u5143\u7d20\u3002\n *\n *\u3010\u6ce8\u3011\n * \u8be5\u64cd\u4f5c\u7684\u5b9e\u73b0\u4e0e\u4f20\u7edf\u7684\u987a\u5e8f\u6808\u7684\u53d6\u503c\u64cd\u4f5c\u6709\u4e9b\u4e0d\u540c\uff0c\u4f46\u6838\u5fc3\u4f5c\u7528\u4e00\u81f4\n */\n", "func_signal": "SElemType GetTop(SqStack S)", "code": "{\n    SElemType e;\n    \n    if(S.base == NULL || S.top == S.base) {\n        return '\\0';\n    }\n    \n    // \u4e0d\u4f1a\u6539\u53d8\u6808\u4e2d\u5143\u7d20\n    e = *(S.top - 1);\n    \n    return e;\n}", "path": "Data-Structure/CLion/CourseBook/0305_Expression/SqStack.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u6784\u9020\u4e00\u4e2a\u8fb9/\u5f27\u7ed3\u70b9(\u4ec5\u9650\u5185\u90e8\u4f7f\u7528)\n */\n", "func_signal": "static ArcNode* newArcNodePtr(int adjvex, ArcNode* nextarc, InfoType* info)", "code": "{\n    ArcNode* p = (ArcNode*) malloc(sizeof(ArcNode));\n    if(!p) {\n        exit(OVERFLOW);\n    }\n    \n    p->adjvex = adjvex;\n    \n    p->nextarc = nextarc;\n    \n    p->info = info;\n    \n    return p;\n}", "path": "Data-Structure/CLion/ExerciseBook/07.36-07.37/ALGraph.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u67e5\u627e\n *\n * \u8fd4\u56de\u9876\u70b9u\u5728\u56fe/\u7f51\u4e2d\u7684\u4f4d\u7f6e\n */\n", "func_signal": "int LocateVex(ALGraph G, VertexType u)", "code": "{\n    int i;\n    \n    for(i = 0; i < G.vexnum; i++) {\n        if(G.vertices[i].data == u) {\n            return i;\n        }\n    }\n    \n    return -1;\n}", "path": "Data-Structure/CLion/ExerciseBook/07.36-07.37/ALGraph.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * \u521d\u59cb\u5316\n *\n * \u6784\u9020\u4e00\u4e2a\u7a7a\u6808\u3002\u521d\u59cb\u5316\u6210\u529f\u5219\u8fd4\u56deOK\uff0c\u5426\u5219\u8fd4\u56deERROR\u3002\n */\n", "func_signal": "Status InitStack(SqStack* S)", "code": "{\n    if(S == NULL) {\n        return ERROR;\n    }\n    \n    (*S).base = (SElemType*) malloc(STACK_INIT_SIZE * sizeof(SElemType));\n    if((*S).base == NULL) {\n        exit(OVERFLOW);\n    }\n    \n    (*S).top = (*S).base;\n    (*S).stacksize = STACK_INIT_SIZE;\n    \n    return OK;\n}", "path": "Data-Structure/CLion/CourseBook/0305_Expression/SqStack.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "// \u67e5\u627e\uff1a\u4eces\u7684pos\u4f4d\u7f6e\u8d77\u67e5\u627et\uff0c\u5982\u679c\u627e\u5230\uff0c\u8fd4\u56de\u5176\u4f4d\u7f6e\n", "func_signal": "int Index(StringType s, StringType t, int pos)", "code": "{\n    int m, n, i;\n    StringType sub;\n    \n    // \u5931\u8d25\u60c5\u5f62\u63d0\u524d\u5904\u7406\n    if(pos < 1 || pos > StrLength(s) || StrLength(t) == 0) {\n        return 0;\n    }\n    \n    n = StrLength(s);\n    m = StrLength(t);\n    i = pos;\n    \n    // \u4fdd\u8bc1\u957f\u5ea6\u4e0d\u8d8a\u754c\n    while(i <= n - m + 1) {\n        // \u83b7\u53d6S[i, i+m-1]\n        sub = SubString(s, i, m);\n        \n        // \u5982\u679c\u5b50\u4e32\u4e0e\u6a21\u5f0f\u4e32\u4e0d\u5339\u914d\uff0c\u5219\u9700\u8981\u7ee7\u7eed\u63a8\u8fdb\n        if(StrCompare(sub, t) != 0) {\n            ++i;\n        } else {\n            return i;\n        }\n    }\n    \n    return 0;\n}", "path": "Data-Structure/CLion/ExerciseBook/04.12/String.c", "commit_date": "2019-11-12 00:00:00", "repo_name": "kangjianwei/Data-Structure", "stars": 3349, "license": "None", "language": "c", "size": 21857}
{"docstring": "/*\n * formboundary() creates a suitable boundary string and returns an allocated\n * one.\n */\n", "func_signal": "static char *formboundary(struct Curl_easy *data)", "code": "{\n  /* 24 dashes and 16 hexadecimal digits makes 64 bit (18446744073709551615)\n     combinations */\n  unsigned int rnd[2];\n  CURLcode result = Curl_rand(data, &rnd[0], 2);\n  if(result)\n    return NULL;\n\n  return aprintf(\"------------------------%08x%08x\", rnd[0], rnd[1]);\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * Curl_formpostheader() returns the first line of the formpost, the\n * request-header part (which is not part of the request-body like the rest of\n * the post).\n */\n", "func_signal": "char *Curl_formpostheader(void *formp, size_t *len)", "code": "{\n  char *header;\n  struct Form *form=(struct Form *)formp;\n\n  if(!form->data)\n    return NULL; /* nothing, ERROR! */\n\n  header = form->data->line;\n  *len = form->data->length;\n\n  form->data = form->data->next; /* advance */\n\n  return header;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/***************************************************************************\n *\n * AddHttpPost()\n *\n * Adds a HttpPost structure to the list, if parent_post is given becomes\n * a subpost of parent_post instead of a direct list element.\n *\n * Returns newly allocated HttpPost on success and NULL if malloc failed.\n *\n ***************************************************************************/\n", "func_signal": "static struct curl_httppost *\nAddHttpPost(char *name, size_t namelength,\n            char *value, curl_off_t contentslength,\n            char *buffer, size_t bufferlength,\n            char *contenttype,\n            long flags,\n            struct curl_slist *contentHeader,\n            char *showfilename, char *userp,\n            struct curl_httppost *parent_post,\n            struct curl_httppost **httppost,\n            struct curl_httppost **last_post)", "code": "{\n  struct curl_httppost *post;\n  post = calloc(1, sizeof(struct curl_httppost));\n  if(post) {\n    post->name = name;\n    post->namelength = (long)(name?(namelength?namelength:strlen(name)):0);\n    post->contents = value;\n    post->contentlen = contentslength;\n    post->buffer = buffer;\n    post->bufferlength = (long)bufferlength;\n    post->contenttype = contenttype;\n    post->contentheader = contentHeader;\n    post->showfilename = showfilename;\n    post->userp = userp,\n    post->flags = flags | CURL_HTTPPOST_LARGE;\n  }\n  else\n    return NULL;\n\n  if(parent_post) {\n    /* now, point our 'more' to the original 'more' */\n    post->more = parent_post->more;\n\n    /* then move the original 'more' to point to ourselves */\n    parent_post->more = post;\n  }\n  else {\n    /* make the previous point to this */\n    if(*last_post)\n      (*last_post)->next = post;\n    else\n      (*httppost) = post;\n\n    (*last_post) = post;\n  }\n  return post;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * Curl_getformdata() converts a linked list of \"meta data\" into a complete\n * (possibly huge) multipart formdata. The input list is in 'post', while the\n * output resulting linked lists gets stored in '*finalform'. *sizep will get\n * the total size of the whole POST.\n * A multipart/form_data content-type is built, unless a custom content-type\n * is passed in 'custom_content_type'.\n *\n * This function will not do a failf() for the potential memory failures but\n * should for all other errors it spots. Just note that this function MAY get\n * a NULL pointer in the 'data' argument.\n */\n", "func_signal": "CURLcode Curl_getformdata(struct Curl_easy *data,\n                          struct FormData **finalform,\n                          struct curl_httppost *post,\n                          const char *custom_content_type,\n                          curl_off_t *sizep)", "code": "{\n  struct FormData *form = NULL;\n  struct FormData *firstform;\n  struct curl_httppost *file;\n  CURLcode result = CURLE_OK;\n\n  curl_off_t size = 0; /* support potentially ENORMOUS formposts */\n  char *boundary;\n  char *fileboundary = NULL;\n  struct curl_slist *curList;\n\n  *finalform = NULL; /* default form is empty */\n\n  if(!post)\n    return result; /* no input => no output! */\n\n  boundary = formboundary(data);\n  if(!boundary)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Make the first line of the output */\n  result = AddFormDataf(&form, NULL,\n                        \"%s; boundary=%s\\r\\n\",\n                        custom_content_type?custom_content_type:\n                        \"Content-Type: multipart/form-data\",\n                        boundary);\n\n  if(result) {\n    free(boundary);\n    return result;\n  }\n  /* we DO NOT include that line in the total size of the POST, since it'll be\n     part of the header! */\n\n  firstform = form;\n\n  do {\n\n    if(size) {\n      result = AddFormDataf(&form, &size, \"\\r\\n\");\n      if(result)\n        break;\n    }\n\n    /* boundary */\n    result = AddFormDataf(&form, &size, \"--%s\\r\\n\", boundary);\n    if(result)\n      break;\n\n    /* Maybe later this should be disabled when a custom_content_type is\n       passed, since Content-Disposition is not meaningful for all multipart\n       types.\n    */\n    result = AddFormDataf(&form, &size,\n                          \"Content-Disposition: form-data; name=\\\"\");\n    if(result)\n      break;\n\n    result = AddFormData(&form, FORM_DATA, post->name, post->namelength,\n                         &size);\n    if(result)\n      break;\n\n    result = AddFormDataf(&form, &size, \"\\\"\");\n    if(result)\n      break;\n\n    if(post->more) {\n      /* If used, this is a link to more file names, we must then do\n         the magic to include several files with the same field name */\n\n      free(fileboundary);\n      fileboundary = formboundary(data);\n      if(!fileboundary) {\n        result = CURLE_OUT_OF_MEMORY;\n        break;\n      }\n\n      result = AddFormDataf(&form, &size,\n                            \"\\r\\nContent-Type: multipart/mixed;\"\n                            \" boundary=%s\\r\\n\",\n                            fileboundary);\n      if(result)\n        break;\n    }\n\n    file = post;\n\n    do {\n\n      /* If 'showfilename' is set, that is a faked name passed on to us\n         to use to in the formpost. If that is not set, the actually used\n         local file name should be added. */\n\n      if(post->more) {\n        /* if multiple-file */\n        result = AddFormDataf(&form, &size,\n                              \"\\r\\n--%s\\r\\nContent-Disposition: \"\n                              \"attachment\",\n                              fileboundary);\n        if(result)\n          break;\n        result = formdata_add_filename(file, &form, &size);\n        if(result)\n          break;\n      }\n      else if(post->flags & (HTTPPOST_FILENAME|HTTPPOST_BUFFER|\n                             HTTPPOST_CALLBACK)) {\n        /* it should be noted that for the HTTPPOST_FILENAME and\n           HTTPPOST_CALLBACK cases the ->showfilename struct member is always\n           assigned at this point */\n        if(post->showfilename || (post->flags & HTTPPOST_FILENAME)) {\n          result = formdata_add_filename(post, &form, &size);\n        }\n\n        if(result)\n          break;\n      }\n\n      if(file->contenttype) {\n        /* we have a specified type */\n        result = AddFormDataf(&form, &size,\n                              \"\\r\\nContent-Type: %s\",\n                              file->contenttype);\n        if(result)\n          break;\n      }\n\n      curList = file->contentheader;\n      while(curList) {\n        /* Process the additional headers specified for this form */\n        result = AddFormDataf(&form, &size, \"\\r\\n%s\", curList->data);\n        if(result)\n          break;\n        curList = curList->next;\n      }\n      if(result)\n        break;\n\n      result = AddFormDataf(&form, &size, \"\\r\\n\\r\\n\");\n      if(result)\n        break;\n\n      if((post->flags & HTTPPOST_FILENAME) ||\n         (post->flags & HTTPPOST_READFILE)) {\n        /* we should include the contents from the specified file */\n        FILE *fileread;\n\n        fileread = !strcmp(\"-\", file->contents)?\n          stdin:fopen(file->contents, \"rb\"); /* binary read for win32  */\n\n        /*\n         * VMS: This only allows for stream files on VMS.  Stream files are\n         * OK, as are FIXED & VAR files WITHOUT implied CC For implied CC,\n         * every record needs to have a \\n appended & 1 added to SIZE\n         */\n\n        if(fileread) {\n          if(fileread != stdin) {\n            /* close the file */\n            fclose(fileread);\n            /* add the file name only - for later reading from this */\n            result = AddFormData(&form, FORM_FILE, file->contents, 0, &size);\n          }\n          else {\n            /* When uploading from stdin, we can't know the size of the file,\n             * thus must read the full file as before. We *could* use chunked\n             * transfer-encoding, but that only works for HTTP 1.1 and we\n             * can't be sure we work with such a server.\n             */\n            size_t nread;\n            char buffer[512];\n            while((nread = fread(buffer, 1, sizeof(buffer), fileread)) != 0) {\n              result = AddFormData(&form, FORM_CONTENT, buffer, nread, &size);\n              if(result || feof(fileread) || ferror(fileread))\n                break;\n            }\n          }\n        }\n        else {\n          if(data)\n            failf(data, \"couldn't open file \\\"%s\\\"\", file->contents);\n          *finalform = NULL;\n          result = CURLE_READ_ERROR;\n        }\n      }\n      else if(post->flags & HTTPPOST_BUFFER)\n        /* include contents of buffer */\n        result = AddFormData(&form, FORM_CONTENT, post->buffer,\n                             post->bufferlength, &size);\n      else if(post->flags & HTTPPOST_CALLBACK)\n        /* the contents should be read with the callback and the size is set\n           with the contentslength */\n        result = AddFormData(&form, FORM_CALLBACK, post->userp,\n                             post->flags&CURL_HTTPPOST_LARGE?\n                             post->contentlen:post->contentslength, &size);\n      else\n        /* include the contents we got */\n        result = AddFormData(&form, FORM_CONTENT, post->contents,\n                             post->flags&CURL_HTTPPOST_LARGE?\n                             post->contentlen:post->contentslength, &size);\n      file = file->more;\n    } while(file && !result); /* for each specified file for this field */\n\n    if(result)\n      break;\n\n    if(post->more) {\n      /* this was a multiple-file inclusion, make a termination file\n         boundary: */\n      result = AddFormDataf(&form, &size,\n                           \"\\r\\n--%s--\",\n                           fileboundary);\n      if(result)\n        break;\n    }\n    post = post->next;\n  } while(post); /* for each field */\n\n  /* end-boundary for everything */\n  if(!result)\n    result = AddFormDataf(&form, &size, \"\\r\\n--%s--\\r\\n\", boundary);\n\n  if(result) {\n    Curl_formclean(&firstform);\n    free(fileboundary);\n    free(boundary);\n    return result;\n  }\n\n  *sizep = size;\n\n  free(fileboundary);\n  free(boundary);\n\n  *finalform = firstform;\n\n  return result;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/* CURL_DISABLE_HTTP */\n", "func_signal": "CURLFORMcode curl_formadd(struct curl_httppost **httppost,\n                          struct curl_httppost **last_post,\n                          ...)", "code": "{\n  (void)httppost;\n  (void)last_post;\n  return CURL_FORMADD_DISABLED;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/* _zip_dirent_write(zde, fp, flags, error):\n   Writes zip directory entry zde to file fp.\n\n   If flags & ZIP_EF_LOCAL, it writes a local header instead of a central\n   directory entry.  If flags & ZIP_EF_FORCE_ZIP64, a ZIP64 extra field is written, even if not needed.\n\n   Returns 0 if successful, 1 if successful and wrote ZIP64 extra field. On error, error is filled in and -1 is\n   returned.\n*/\n", "func_signal": "int\n_zip_dirent_write(struct zip_dirent *de, FILE *fp, zip_flags_t flags, struct zip_error *error)", "code": "{\n    unsigned short dostime, dosdate;\n    enum zip_encoding_type com_enc, name_enc;\n    struct zip_extra_field *ef;\n    zip_uint8_t ef_zip64[24], *ef_zip64_p;\n    int is_zip64;\n    int is_really_zip64;\n\n    ef = NULL;\n\n    is_zip64 = 0;\n\n    fwrite((flags & ZIP_FL_LOCAL) ? LOCAL_MAGIC : CENTRAL_MAGIC, 1, 4, fp);\n\n    name_enc = _zip_guess_encoding(de->filename, ZIP_ENCODING_UNKNOWN);\n    com_enc = _zip_guess_encoding(de->comment, ZIP_ENCODING_UNKNOWN);\n\n    if ((name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_ASCII) ||\n\t(name_enc == ZIP_ENCODING_ASCII && com_enc == ZIP_ENCODING_UTF8_KNOWN) ||\n\t(name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_UTF8_KNOWN))\n\tde->bitflags |= ZIP_GPBF_ENCODING_UTF_8;\n    else {\n\tde->bitflags &= ~ZIP_GPBF_ENCODING_UTF_8;\n\tif (name_enc == ZIP_ENCODING_UTF8_KNOWN) {\n\t    ef = _zip_ef_utf8(ZIP_EF_UTF_8_NAME, de->filename, error);\n\t    if (ef == NULL)\n\t\treturn -1;\n\t}\n\tif ((flags & ZIP_FL_LOCAL) == 0 && com_enc == ZIP_ENCODING_UTF8_KNOWN){\n\t    struct zip_extra_field *ef2 = _zip_ef_utf8(ZIP_EF_UTF_8_COMMENT, de->comment, error);\n\t    if (ef2 == NULL) {\n\t\t_zip_ef_free(ef);\n\t\treturn -1;\n\t    }\n\t    ef2->next = ef;\n\t    ef = ef2;\n\t}\n    }\n\n    ef_zip64_p = ef_zip64;\n    if (flags & ZIP_FL_LOCAL) {\n\tif ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX) {\n\t    _zip_poke8(de->uncomp_size, &ef_zip64_p);\n\t    _zip_poke8(de->comp_size, &ef_zip64_p);\n\t}\n    }\n    else {\n\tif ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX || de->offset > ZIP_UINT32_MAX) {\n\t    if (de->comp_size >= ZIP_UINT32_MAX)\n\t\t_zip_poke8(de->comp_size, &ef_zip64_p);\n\t    if (de->uncomp_size >= ZIP_UINT32_MAX)\n\t\t_zip_poke8(de->uncomp_size, &ef_zip64_p);\n\t    if (de->offset >= ZIP_UINT32_MAX)\n\t\t_zip_poke8(de->offset, &ef_zip64_p);\n\t}\n    }\n\n    if (ef_zip64_p != ef_zip64) {\n\tstruct zip_extra_field *ef64 = _zip_ef_new(ZIP_EF_ZIP64, (zip_uint16_t)(ef_zip64_p-ef_zip64), ef_zip64, ZIP_EF_BOTH);\n\tef64->next = ef;\n\tef = ef64;\n\tis_zip64 = 1;\n    }\n\n    if ((flags & (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64)) == (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64))\n\tis_really_zip64 = _zip_dirent_needs_zip64(de, flags);\n    else\n\tis_really_zip64 = is_zip64;\n    \n    if ((flags & ZIP_FL_LOCAL) == 0)\n\t_zip_write2(is_really_zip64 ? 45 : de->version_madeby, fp);\n    _zip_write2(is_really_zip64 ? 45 : de->version_needed, fp);\n    _zip_write2(de->bitflags&0xfff9, fp); /* clear compression method specific flags */\n    _zip_write2((zip_uint16_t)de->comp_method, fp); /* TODO: can it be ZIP_CM_DEFAULT? */\n\n    _zip_u2d_time(de->last_mod, &dostime, &dosdate);\n    _zip_write2(dostime, fp);\n    _zip_write2(dosdate, fp);\n\n    _zip_write4(de->crc, fp);\n    if (de->comp_size < ZIP_UINT32_MAX)\n\t_zip_write4((zip_uint32_t)de->comp_size, fp);\n    else\n\t_zip_write4(ZIP_UINT32_MAX, fp);\n    if (de->uncomp_size < ZIP_UINT32_MAX)\n\t_zip_write4((zip_uint32_t)de->uncomp_size, fp);\n    else\n\t_zip_write4(ZIP_UINT32_MAX, fp);\n\n    _zip_write2(_zip_string_length(de->filename), fp);\n    _zip_write2(_zip_ef_size(de->extra_fields, flags) + _zip_ef_size(ef, ZIP_EF_BOTH), fp);\n    \n    if ((flags & ZIP_FL_LOCAL) == 0) {\n\t_zip_write2(_zip_string_length(de->comment), fp);\n\t_zip_write2((zip_uint16_t)de->disk_number, fp);\n\t_zip_write2(de->int_attrib, fp);\n\t_zip_write4(de->ext_attrib, fp);\n\tif (de->offset < ZIP_UINT32_MAX)\n\t    _zip_write4((zip_uint32_t)de->offset, fp);\n\telse\n\t    _zip_write4(ZIP_UINT32_MAX, fp);\n    }\n\n    if (de->filename)\n\t_zip_string_write(de->filename, fp);\n\n    if (ef)\n\t_zip_ef_write(ef, ZIP_EF_BOTH, fp);\n    if (de->extra_fields)\n\t_zip_ef_write(de->extra_fields, flags, fp);\n\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n\tif (de->comment)\n\t    _zip_string_write(de->comment, fp);\n    }\n\n    _zip_ef_free(ef);\n\n    if (ferror(fp)) {\n\t_zip_error_set(error, ZIP_ER_WRITE, errno);\n\treturn -1;\n    }\n\n    return is_zip64;\n}", "path": "premake-core/contrib/libzip/zip_dirent.c", "commit_date": "2015-04-14 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/***************************************************************************\n *\n * AddFormInfo()\n *\n * Adds a FormInfo structure to the list presented by parent_form_info.\n *\n * Returns newly allocated FormInfo on success and NULL if malloc failed/\n * parent_form_info is NULL.\n *\n ***************************************************************************/\n", "func_signal": "static FormInfo * AddFormInfo(char *value,\n                              char *contenttype,\n                              FormInfo *parent_form_info)", "code": "{\n  FormInfo *form_info;\n  form_info = calloc(1, sizeof(struct FormInfo));\n  if(form_info) {\n    if(value)\n      form_info->value = value;\n    if(contenttype)\n      form_info->contenttype = contenttype;\n    form_info->flags = HTTPPOST_FILENAME;\n  }\n  else\n    return NULL;\n\n  if(parent_form_info) {\n    /* now, point our 'more' to the original 'more' */\n    form_info->more = parent_form_info->more;\n\n    /* then move the original 'more' to point to ourselves */\n    parent_form_info->more = form_info;\n  }\n\n  return form_info;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * Curl_formclean() is used from http.c, this cleans a built FormData linked\n * list\n */\n", "func_signal": "void Curl_formclean(struct FormData **form_ptr)", "code": "{\n  struct FormData *next, *form;\n\n  form = *form_ptr;\n  if(!form)\n    return;\n\n  do {\n    next=form->next;  /* the following form line */\n    if(form->type <= FORM_CONTENT)\n      free(form->line); /* free the line */\n    free(form);       /* free the struct */\n    form = next;\n  } while(form); /* continue */\n\n  *form_ptr = NULL;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/* _zip_dirent_read(zde, fp, bufp, left, localp, error):\n   Fills the zip directory entry zde.\n\n   If bufp is non-NULL, data is taken from there and bufp is advanced\n   by the amount of data used; otherwise data is read from fp as needed.\n   \n   if leftp is non-NULL, no more bytes than specified by it are used,\n   and *leftp is reduced by the number of bytes used.\n\n   If local != 0, it reads a local header instead of a central\n   directory entry.\n\n   Returns 0 if successful. On error, error is filled in and -1 is\n   returned.\n\n   TODO: leftp and file position undefined on error.\n*/\n", "func_signal": "int\n_zip_dirent_read(struct zip_dirent *zde, FILE *fp,\n\t\t const unsigned char **bufp, zip_uint64_t *leftp, int local,\n\t\t struct zip_error *error)", "code": "{\n    unsigned char buf[CDENTRYSIZE];\n    const unsigned char *cur;\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    if (local)\n\tsize = LENTRYSIZE;\n    else\n\tsize = CDENTRYSIZE;\n\n    if (leftp && (*leftp < size)) {\n\t_zip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn -1;\n    }\n\n    if (bufp) {\n\t/* use data from buffer */\n\tcur = *bufp;\n    }\n    else {\n\t/* read entry from disk */\n\tif ((fread(buf, 1, size, fp)<size)) {\n\t    _zip_error_set(error, ZIP_ER_READ, errno);\n\t    return -1;\n\t}\n\tcur = buf;\n    }\n\n    if (memcmp(cur, (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\t_zip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn -1;\n    }\n    cur += 4;\n\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_read2(&cur);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_read2(&cur);\n    zde->bitflags = _zip_read2(&cur);\n    zde->comp_method = _zip_read2(&cur);\n    \n    /* convert to time_t */\n    dostime = _zip_read2(&cur);\n    dosdate = _zip_read2(&cur);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n    \n    zde->crc = _zip_read4(&cur);\n    zde->comp_size = _zip_read4(&cur);\n    zde->uncomp_size = _zip_read4(&cur);\n    \n    filename_len = _zip_read2(&cur);\n    ef_len = _zip_read2(&cur);\n    \n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_read2(&cur);\n\tzde->disk_number = _zip_read2(&cur);\n\tzde->int_attrib = _zip_read2(&cur);\n\tzde->ext_attrib = _zip_read4(&cur);\n\tzde->offset = _zip_read4(&cur);\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    size += filename_len+ef_len+comment_len;\n\n    if (leftp && (*leftp < size)) {\n\t_zip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn -1;\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(bufp ? &cur : NULL, fp, filename_len, 1, error);\n\tif (!zde->filename)\n\t    return -1;\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\t_zip_error_set(error, ZIP_ER_INCONS, 0);\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(bufp ? &cur : NULL, fp, ef_len, 0, error);\n\n\tif (ef == NULL)\n\t    return -1;\n\tif ((zde->extra_fields=_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error)) == NULL) {\n\t    free(ef);\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(bufp ? &cur : NULL, fp, comment_len, 0, error);\n\tif (!zde->comment)\n\t    return -1;\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\t_zip_error_set(error, ZIP_ER_INCONS, 0);\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len, needed_len;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n\tif (ef == NULL)\n\t    return -1;\n\n\n\tif (local)\n\t    needed_len = 16;\n\telse\n\t    needed_len = ((zde->uncomp_size == ZIP_UINT32_MAX) + (zde->comp_size == ZIP_UINT32_MAX) + (zde->offset == ZIP_UINT32_MAX)) * 8\n\t\t+ (zde->disk_number == ZIP_UINT16_MAX) * 4;\n\n\tif (got_len != needed_len) {\n\t    _zip_error_set(error, ZIP_ER_INCONS, 0);\n\t    return -1;\n\t}\n\t\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_read8(&ef);\n\telse if (local)\n\t    ef += 8;\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_read8(&ef);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_read8(&ef);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_read4(&ef);\n\t}\n    }\n    \n    if (!local) {\n        if (zde->offset > ZIP_OFF_MAX) {\n            _zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n            return -1;\n        }\n    }\n    \n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    if (bufp)\n      *bufp = cur;\n    if (leftp)\n\t*leftp -= size;\n\n    return 0;\n}", "path": "premake-core/contrib/libzip/zip_dirent.c", "commit_date": "2015-04-14 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/* _zip_dirent_torrent_normalize(de);\n   Set values suitable for torrentzip.\n*/\n", "func_signal": "void\n_zip_dirent_torrent_normalize(struct zip_dirent *de)", "code": "{\n    static struct tm torrenttime;\n    static time_t last_mod = 0;\n\n    if (last_mod == 0) {\n#ifdef HAVE_STRUCT_TM_TM_ZONE\n\ttime_t now;\n\tstruct tm *l;\n#endif\n\n\ttorrenttime.tm_sec = 0;\n\ttorrenttime.tm_min = 32;\n\ttorrenttime.tm_hour = 23;\n\ttorrenttime.tm_mday = 24;\n\ttorrenttime.tm_mon = 11;\n\ttorrenttime.tm_year = 96;\n\ttorrenttime.tm_wday = 0;\n\ttorrenttime.tm_yday = 0;\n\ttorrenttime.tm_isdst = 0;\n\n#ifdef HAVE_STRUCT_TM_TM_ZONE\n\ttime(&now);\n\tl = localtime(&now);\n\ttorrenttime.tm_gmtoff = l->tm_gmtoff;\n\ttorrenttime.tm_zone = l->tm_zone;\n#endif\n\n\tlast_mod = mktime(&torrenttime);\n    }\n    \n    de->version_madeby = 0;\n    de->version_needed = 20; /* 2.0 */\n    de->bitflags = 2; /* maximum compression */\n    de->comp_method = ZIP_CM_DEFLATE;\n    de->last_mod = last_mod;\n\n    de->disk_number = 0;\n    de->int_attrib = 0;\n    de->ext_attrib = 0;\n\n    _zip_ef_free(de->extra_fields);\n    de->extra_fields = NULL;\n    _zip_string_free(de->comment);\n    de->comment = NULL;\n}", "path": "premake-core/contrib/libzip/zip_dirent.c", "commit_date": "2015-04-14 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * AddFormDataf() adds printf()-style formatted data to the formdata chain.\n */\n", "func_signal": "static CURLcode AddFormDataf(struct FormData **formp,\n                             curl_off_t *size,\n                             const char *fmt, ...)", "code": "{\n  char *s;\n  CURLcode result;\n  va_list ap;\n  va_start(ap, fmt);\n  s = curl_mvaprintf(fmt, ap);\n  va_end(ap);\n\n  if(!s)\n    return CURLE_OUT_OF_MEMORY;\n\n  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);\n  if(result)\n    free(s);\n\n  return result;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * Curl_FormReader() is the fread() emulation function that will be used to\n * deliver the formdata to the transfer loop and then sent away to the peer.\n */\n", "func_signal": "size_t Curl_FormReader(char *buffer,\n                       size_t size,\n                       size_t nitems,\n                       FILE *mydata)", "code": "{\n  struct Form *form;\n  size_t wantedsize;\n  size_t gotsize = 0;\n\n  form=(struct Form *)mydata;\n\n  wantedsize = size * nitems;\n\n  if(!form->data)\n    return 0; /* nothing, error, empty */\n\n  if((form->data->type == FORM_FILE) ||\n     (form->data->type == FORM_CALLBACK)) {\n    gotsize = readfromfile(form, buffer, wantedsize);\n\n    if(gotsize)\n      /* If positive or -1, return. If zero, continue! */\n      return gotsize;\n  }\n  do {\n\n    if((form->data->length - form->sent) > wantedsize - gotsize) {\n\n      memcpy(buffer + gotsize, form->data->line + form->sent,\n             wantedsize - gotsize);\n\n      form->sent += wantedsize-gotsize;\n\n      return wantedsize;\n    }\n\n    memcpy(buffer+gotsize,\n           form->data->line + form->sent,\n           (form->data->length - form->sent) );\n    gotsize += form->data->length - form->sent;\n\n    form->sent = 0;\n\n    form->data = form->data->next; /* advance */\n\n  } while(form->data && (form->data->type < FORM_CALLBACK));\n  /* If we got an empty line and we have more data, we proceed to the next\n     line immediately to avoid returning zero before we've reached the end. */\n\n  return gotsize;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * AddFormData() adds a chunk of data to the FormData linked list.\n *\n * size is incremented by the chunk length, unless it is NULL\n */\n", "func_signal": "static CURLcode AddFormData(struct FormData **formp,\n                            enum formtype type,\n                            const void *line,\n                            curl_off_t length,\n                            curl_off_t *size)", "code": "{\n  struct FormData *newform;\n  char *alloc2 = NULL;\n  CURLcode result = CURLE_OK;\n  if(length < 0 || (size && *size < 0))\n    return CURLE_BAD_FUNCTION_ARGUMENT;\n\n  newform = malloc(sizeof(struct FormData));\n  if(!newform)\n    return CURLE_OUT_OF_MEMORY;\n  newform->next = NULL;\n\n  if(type <= FORM_CONTENT) {\n    /* we make it easier for plain strings: */\n    if(!length)\n      length = strlen((char *)line);\n#if (SIZEOF_SIZE_T < CURL_SIZEOF_CURL_OFF_T)\n    else if(length >= (curl_off_t)(size_t)-1) {\n      result = CURLE_BAD_FUNCTION_ARGUMENT;\n      goto error;\n    }\n#endif\n    if(type != FORM_DATAMEM) {\n      newform->line = malloc((size_t)length+1);\n      if(!newform->line) {\n        result = CURLE_OUT_OF_MEMORY;\n        goto error;\n      }\n      alloc2 = newform->line;\n      memcpy(newform->line, line, (size_t)length);\n\n      /* zero terminate for easier debugging */\n      newform->line[(size_t)length]=0;\n    }\n    else {\n      newform->line = (char *)line;\n      type = FORM_DATA; /* in all other aspects this is just FORM_DATA */\n    }\n    newform->length = (size_t)length;\n  }\n  else\n    /* For callbacks and files we don't have any actual data so we just keep a\n       pointer to whatever this points to */\n    newform->line = (char *)line;\n\n  newform->type = type;\n\n  if(size) {\n    if(type != FORM_FILE)\n      /* for static content as well as callback data we add the size given\n         as input argument */\n      *size += length;\n    else {\n      /* Since this is a file to be uploaded here, add the size of the actual\n         file */\n      if(strcmp(\"-\", newform->line)) {\n        struct_stat file;\n        if(!stat(newform->line, &file) && !S_ISDIR(file.st_mode))\n          *size += filesize(newform->line, file);\n        else {\n          result = CURLE_BAD_FUNCTION_ARGUMENT;\n          goto error;\n        }\n      }\n    }\n  }\n\n  if(*formp) {\n    (*formp)->next = newform;\n    *formp = newform;\n  }\n  else\n    *formp = newform;\n\n  return CURLE_OK;\n  error:\n  if(newform)\n    free(newform);\n  if(alloc2)\n    free(alloc2);\n  return result;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * readfromfile()\n *\n * The read callback that this function may use can return a value larger than\n * 'size' (which then this function returns) that indicates a problem and it\n * must be properly dealt with\n */\n", "func_signal": "static size_t readfromfile(struct Form *form, char *buffer,\n                           size_t size)", "code": "{\n  size_t nread;\n  bool callback = (form->data->type == FORM_CALLBACK)?TRUE:FALSE;\n\n  if(callback) {\n    if(form->fread_func == ZERO_NULL)\n      return 0;\n    else\n      nread = form->fread_func(buffer, 1, size, form->data->line);\n  }\n  else {\n    if(!form->fp) {\n      /* this file hasn't yet been opened */\n      form->fp = fopen_read(form->data->line, \"rb\"); /* b is for binary */\n      if(!form->fp)\n        return (size_t)-1; /* failure */\n    }\n    nread = fread(buffer, 1, size, form->fp);\n  }\n  if(!nread) {\n    /* this is the last chunk from the file, move on */\n    if(form->fp) {\n      fclose(form->fp);\n      form->fp = NULL;\n    }\n    form->data = form->data->next;\n  }\n\n  return nread;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * Curl_FormInit() inits the struct 'form' points to with the 'formdata'\n * and resets the 'sent' counter.\n */\n", "func_signal": "int Curl_FormInit(struct Form *form, struct FormData *formdata)", "code": "{\n  if(!formdata)\n    return 1; /* error */\n\n  form->data = formdata;\n  form->sent = 0;\n  form->fp = NULL;\n  form->fread_func = ZERO_NULL;\n\n  return 0;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * curl_formget()\n * Serialize a curl_httppost struct.\n * Returns 0 on success.\n *\n * @unittest: 1308\n */\n", "func_signal": "int curl_formget(struct curl_httppost *form, void *arg,\n                 curl_formget_callback append)", "code": "{\n  CURLcode result;\n  curl_off_t size;\n  struct FormData *data, *ptr;\n\n  result = Curl_getformdata(NULL, &data, form, NULL, &size);\n  if(result)\n    return (int)result;\n\n  for(ptr = data; ptr; ptr = ptr->next) {\n    if((ptr->type == FORM_FILE) || (ptr->type == FORM_CALLBACK)) {\n      char buffer[8192];\n      size_t nread;\n      struct Form temp;\n\n      Curl_FormInit(&temp, ptr);\n\n      do {\n        nread = readfromfile(&temp, buffer, sizeof(buffer));\n        if((nread == (size_t) -1) ||\n           (nread > sizeof(buffer)) ||\n           (nread != append(arg, buffer, nread))) {\n          if(temp.fp)\n            fclose(temp.fp);\n          Curl_formclean(&data);\n          return -1;\n        }\n      } while(nread);\n    }\n    else {\n      if(ptr->length != append(arg, ptr->line, ptr->length)) {\n        Curl_formclean(&data);\n        return -1;\n      }\n    }\n  }\n  Curl_formclean(&data);\n  return 0;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n *\n *  VmsSpecialSize checks to see if the stat st_size can be trusted and\n *  if not to call a routine to get the correct size.\n *\n */\n", "func_signal": "static curl_off_t VmsSpecialSize(const char *name,\n                                 const struct_stat *stat_buf)", "code": "{\n  switch(stat_buf->st_fab_rfm) {\n  case FAB$C_VAR:\n  case FAB$C_VFC:\n    return VmsRealFileSize(name, stat_buf);\n    break;\n  default:\n    return stat_buf->st_size;\n  }\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/***************************************************************************\n *\n * ContentTypeForFilename()\n *\n * Provides content type for filename if one of the known types (else\n * (either the prevtype or the default is returned).\n *\n * Returns some valid contenttype for filename.\n *\n ***************************************************************************/\n", "func_signal": "static const char *ContentTypeForFilename(const char *filename,\n                                          const char *prevtype)", "code": "{\n  const char *contenttype = NULL;\n  unsigned int i;\n  /*\n   * No type was specified, we scan through a few well-known\n   * extensions and pick the first we match!\n   */\n  struct ContentType {\n    const char *extension;\n    const char *type;\n  };\n  static const struct ContentType ctts[]={\n    {\".gif\",  \"image/gif\"},\n    {\".jpg\",  \"image/jpeg\"},\n    {\".jpeg\", \"image/jpeg\"},\n    {\".txt\",  \"text/plain\"},\n    {\".html\", \"text/html\"},\n    {\".xml\", \"application/xml\"}\n  };\n\n  if(prevtype)\n    /* default to the previously set/used! */\n    contenttype = prevtype;\n  else\n    contenttype = HTTPPOST_CONTENTTYPE_DEFAULT;\n\n  if(filename) { /* in case a NULL was passed in */\n    for(i=0; i<sizeof(ctts)/sizeof(ctts[0]); i++) {\n      if(strlen(filename) >= strlen(ctts[i].extension)) {\n        if(strcasecompare(filename +\n                          strlen(filename) - strlen(ctts[i].extension),\n                          ctts[i].extension)) {\n          contenttype = ctts[i].type;\n          break;\n        }\n      }\n    }\n  }\n  /* we have a contenttype by now */\n  return contenttype;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * get_vms_file_size does what it takes to get the real size of the file\n *\n * For fixed files, find out the size of the EOF block and adjust.\n *\n * For all others, have to read the entire file in, discarding the contents.\n * Most posted text files will be small, and binary files like zlib archives\n * and CD/DVD images should be either a STREAM_LF format or a fixed format.\n *\n */\n", "func_signal": "curl_off_t VmsRealFileSize(const char *name,\n                           const struct_stat *stat_buf)", "code": "{\n  char buffer[8192];\n  curl_off_t count;\n  int ret_stat;\n  FILE * file;\n\n  file = fopen(name, FOPEN_READTEXT); /* VMS */\n  if(file == NULL)\n    return 0;\n\n  count = 0;\n  ret_stat = 1;\n  while(ret_stat > 0) {\n    ret_stat = fread(buffer, 1, sizeof(buffer), file);\n    if(ret_stat != 0)\n      count += ret_stat;\n  }\n  fclose(file);\n\n  return count;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n  (Quote from The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004\n  Edition)\n\n  The basename() function shall take the pathname pointed to by path and\n  return a pointer to the final component of the pathname, deleting any\n  trailing '/' characters.\n\n  If the string pointed to by path consists entirely of the '/' character,\n  basename() shall return a pointer to the string \"/\". If the string pointed\n  to by path is exactly \"//\", it is implementation-defined whether '/' or \"//\"\n  is returned.\n\n  If path is a null pointer or points to an empty string, basename() shall\n  return a pointer to the string \".\".\n\n  The basename() function may modify the string pointed to by path, and may\n  return a pointer to static storage that may then be overwritten by a\n  subsequent call to basename().\n\n  The basename() function need not be reentrant. A function that is not\n  required to be reentrant is not required to be thread-safe.\n\n*/\n", "func_signal": "static char *Curl_basename(char *path)", "code": "{\n  /* Ignore all the details above for now and make a quick and simple\n     implementaion here */\n  char *s1;\n  char *s2;\n\n  s1=strrchr(path, '/');\n  s2=strrchr(path, '\\\\');\n\n  if(s1 && s2) {\n    path = (s1 > s2? s1 : s2)+1;\n  }\n  else if(s1)\n    path = s1 + 1;\n  else if(s2)\n    path = s2 + 1;\n\n  return path;\n}", "path": "premake-core/contrib/curl/lib/formdata.c", "commit_date": "2017-04-11 00:00:00", "repo_name": "premake/premake-core", "stars": 3022, "license": "bsd-3-clause", "language": "c", "size": 32198}
{"docstring": "/*\n * Setup callback.\n */\n", "func_signal": "static int\narchive_compressor_bzip2_open(struct archive_write_filter *f)", "code": "{\n\tstruct private_data *data = (struct private_data *)f->data;\n\tint ret;\n\n\tif (data->compressed == NULL) {\n\t\tsize_t bs = 65536, bpb;\n\t\tif (f->archive->magic == ARCHIVE_WRITE_MAGIC) {\n\t\t\t/* Buffer size should be a multiple number of the of bytes\n\t\t\t * per block for performance. */\n\t\t\tbpb = archive_write_get_bytes_per_block(f->archive);\n\t\t\tif (bpb > bs)\n\t\t\t\tbs = bpb;\n\t\t\telse if (bpb != 0)\n\t\t\t\tbs -= bs % bpb;\n\t\t}\n\t\tdata->compressed_buffer_size = bs;\n\t\tdata->compressed\n\t\t    = (char *)malloc(data->compressed_buffer_size);\n\t\tif (data->compressed == NULL) {\n\t\t\tarchive_set_error(f->archive, ENOMEM,\n\t\t\t    \"Can't allocate data for compression buffer\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\tmemset(&data->stream, 0, sizeof(data->stream));\n\tdata->stream.next_out = data->compressed;\n\tdata->stream.avail_out = data->compressed_buffer_size;\n\tf->write = archive_compressor_bzip2_write;\n\n\t/* Initialize compression library */\n\tret = BZ2_bzCompressInit(&(data->stream),\n\t    data->compression_level, 0, 30);\n\tif (ret == BZ_OK) {\n\t\tf->data = data;\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* Library setup failed: clean up. */\n\tarchive_set_error(f->archive, ARCHIVE_ERRNO_MISC,\n\t    \"Internal error initializing compression library\");\n\n\t/* Override the error message if we know what really went wrong. */\n\tswitch (ret) {\n\tcase BZ_PARAM_ERROR:\n\t\tarchive_set_error(f->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Internal error initializing compression library: \"\n\t\t    \"invalid setup parameter\");\n\t\tbreak;\n\tcase BZ_MEM_ERROR:\n\t\tarchive_set_error(f->archive, ENOMEM,\n\t\t    \"Internal error initializing compression library: \"\n\t\t    \"out of memory\");\n\t\tbreak;\n\tcase BZ_CONFIG_ERROR:\n\t\tarchive_set_error(f->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Internal error initializing compression library: \"\n\t\t    \"mis-compiled library\");\n\t\tbreak;\n\t}\n\n\treturn (ARCHIVE_FATAL);\n\n}", "path": "libarchive/libarchive/archive_write_add_filter_bzip2.c", "commit_date": "2019-12-06 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Prompt for a new name for this entry.  Returns a pointer to the\n * new name or NULL if the entry should not be copied.  This\n * implements the semantics defined in POSIX.1-1996, which specifies\n * that an input of '.' means the name should be unchanged.  GNU cpio\n * treats '.' as a literal new name.\n */\n", "func_signal": "static const char *\ncpio_rename(const char *name)", "code": "{\n\tstatic char buff[1024];\n\tFILE *t;\n\tchar *p, *ret;\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\tFILE *to;\n\n\tt = fopen(\"CONIN$\", \"r\");\n\tif (t == NULL)\n\t\treturn (name);\n\tto = fopen(\"CONOUT$\", \"w\");\n\tif (to == NULL) {\n\t\tfclose(t);\n\t\treturn (name);\n\t}\n\tfprintf(to, \"%s (Enter/./(new name))? \", name);\n\tfclose(to);\n#else\n\tt = fopen(\"/dev/tty\", \"r+\");\n\tif (t == NULL)\n\t\treturn (name);\n\tfprintf(t, \"%s (Enter/./(new name))? \", name);\n\tfflush(t);\n#endif\n\n\tp = fgets(buff, sizeof(buff), t);\n\tfclose(t);\n\tif (p == NULL)\n\t\t/* End-of-file is a blank line. */\n\t\treturn (NULL);\n\n\twhile (*p == ' ' || *p == '\\t')\n\t\t++p;\n\tif (*p == '\\n' || *p == '\\0')\n\t\t/* Empty line. */\n\t\treturn (NULL);\n\tif (*p == '.' && p[1] == '\\n')\n\t\t/* Single period preserves original name. */\n\t\treturn (name);\n\tret = p;\n\t/* Trim the final newline. */\n\twhile (*p != '\\0' && *p != '\\n')\n\t\t++p;\n\t/* Overwrite the final \\n with a null character. */\n\t*p = '\\0';\n\treturn (ret);\n}", "path": "libarchive/cpio/cpio.c", "commit_date": "2020-03-02 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Exits if there's a fatal error.  Returns ARCHIVE_OK\n * if everything is kosher.\n */\n", "func_signal": "static int\nextract_data(struct archive *ar, struct archive *aw)", "code": "{\n\tint r;\n\tsize_t size;\n\tconst void *block;\n\tint64_t offset;\n\n\tfor (;;) {\n\t\tr = archive_read_data_block(ar, &block, &size, &offset);\n\t\tif (r == ARCHIVE_EOF)\n\t\t\treturn (ARCHIVE_OK);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tlafe_warnc(archive_errno(ar),\n\t\t\t    \"%s\", archive_error_string(ar));\n\t\t\texit(1);\n\t\t}\n\t\tr = (int)archive_write_data_block(aw, block, size, offset);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tlafe_warnc(archive_errno(aw),\n\t\t\t    \"%s\", archive_error_string(aw));\n\t\t\treturn (r);\n\t\t}\n\t}\n}", "path": "libarchive/cpio/cpio.c", "commit_date": "2020-03-02 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Create an entry starting from a wide-character Unicode pathname,\n * read it back into \"C\" locale, which doesn't support the name.\n * TODO: Figure out the \"right\" behavior here.\n */\n", "func_signal": "static void\ntest_pax_filename_encoding_3(void)", "code": "{\n\twchar_t badname[] = L\"xxxAyyyBzzz\";\n\tconst char badname_utf8[] = \"xxx\\xE1\\x88\\xB4yyy\\xE5\\x99\\xB8zzz\";\n\tstruct archive *a;\n\tstruct archive_entry *entry;\n\tchar buff[65536];\n\tsize_t used;\n\n\tbadname[3] = 0x1234;\n\tbadname[7] = 0x5678;\n\n\t/* If it doesn't exist, just warn and return. */\n\tif (NULL == setlocale(LC_ALL, \"C\")) {\n\t\tskipping(\"Can't set \\\"C\\\" locale, so can't exercise \"\n\t\t    \"certain character-conversion failures\");\n\t\treturn;\n\t}\n\n\t/* If wctomb is broken, warn and return. */\n\tif (wctomb(buff, 0x1234) > 0) {\n\t\tskipping(\"Cannot test conversion failures because \\\"C\\\" \"\n\t\t    \"locale on this system has no invalid characters.\");\n\t\treturn;\n\t}\n\n\t/* If wctomb is broken, warn and return. */\n\tif (wctomb(buff, 0x1234) > 0) {\n\t\tskipping(\"Cannot test conversion failures because \\\"C\\\" \"\n\t\t    \"locale on this system has no invalid characters.\");\n\t\treturn;\n\t}\n\n\t/* Skip test if archive_entry_update_pathname_utf8() is broken. */\n\t/* In particular, this is currently broken on Win32 because\n\t * setlocale() does not set the default encoding for CP_ACP. */\n\tentry = archive_entry_new();\n\tif (archive_entry_update_pathname_utf8(entry, badname_utf8)) {\n\t\tarchive_entry_free(entry);\n\t\tskipping(\"Cannot test conversion failures.\");\n\t\treturn;\n\t}\n\tarchive_entry_free(entry);\n\n\tassert((a = archive_write_new()) != NULL);\n\tassertEqualIntA(a, 0, archive_write_set_format_pax(a));\n\tassertEqualIntA(a, 0, archive_write_add_filter_none(a));\n\tassertEqualIntA(a, 0, archive_write_set_bytes_per_block(a, 0));\n\tassertEqualInt(0,\n\t    archive_write_open_memory(a, buff, sizeof(buff), &used));\n\n\tassert((entry = archive_entry_new()) != NULL);\n\t/* Set pathname to non-convertible wide value. */\n\tarchive_entry_copy_pathname_w(entry, badname);\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\n\tassert((entry = archive_entry_new()) != NULL);\n\tarchive_entry_copy_pathname_w(entry, L\"abc\");\n\t/* Set gname to non-convertible wide value. */\n\tarchive_entry_copy_gname_w(entry, badname);\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\n\tassert((entry = archive_entry_new()) != NULL);\n\tarchive_entry_copy_pathname_w(entry, L\"abc\");\n\t/* Set uname to non-convertible wide value. */\n\tarchive_entry_copy_uname_w(entry, badname);\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\n\tassert((entry = archive_entry_new()) != NULL);\n\tarchive_entry_copy_pathname_w(entry, L\"abc\");\n\t/* Set hardlink to non-convertible wide value. */\n\tarchive_entry_copy_hardlink_w(entry, badname);\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\n\tassert((entry = archive_entry_new()) != NULL);\n\tarchive_entry_copy_pathname_w(entry, L\"abc\");\n\t/* Set symlink to non-convertible wide value. */\n\tarchive_entry_copy_symlink_w(entry, badname);\n\tarchive_entry_set_filetype(entry, AE_IFLNK);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\n\tassertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n\n\t/*\n\t * Now read the entries back.\n\t */\n\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualInt(0, archive_read_support_format_tar(a));\n\tassertEqualInt(0, archive_read_open_memory(a, buff, used));\n\n\tfailure(\"A non-convertible pathname should cause a warning.\");\n\tassertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &entry));\n\tassertEqualWString(badname, archive_entry_pathname_w(entry));\n\tfailure(\"If native locale can't convert, we should get UTF-8 back.\");\n\tassertEqualString(badname_utf8, archive_entry_pathname(entry));\n\n\tfailure(\"A non-convertible gname should cause a warning.\");\n\tassertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &entry));\n\tassertEqualWString(badname, archive_entry_gname_w(entry));\n\tfailure(\"If native locale can't convert, we should get UTF-8 back.\");\n\tassertEqualString(badname_utf8, archive_entry_gname(entry));\n\n\tfailure(\"A non-convertible uname should cause a warning.\");\n\tassertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &entry));\n\tassertEqualWString(badname, archive_entry_uname_w(entry));\n\tfailure(\"If native locale can't convert, we should get UTF-8 back.\");\n\tassertEqualString(badname_utf8, archive_entry_uname(entry));\n\n\tfailure(\"A non-convertible hardlink should cause a warning.\");\n\tassertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &entry));\n\tassertEqualWString(badname, archive_entry_hardlink_w(entry));\n\tfailure(\"If native locale can't convert, we should get UTF-8 back.\");\n\tassertEqualString(badname_utf8, archive_entry_hardlink(entry));\n\n\tfailure(\"A non-convertible symlink should cause a warning.\");\n\tassertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &entry));\n\tassertEqualWString(badname, archive_entry_symlink_w(entry));\n\tassertEqualWString(NULL, archive_entry_hardlink_w(entry));\n\tfailure(\"If native locale can't convert, we should get UTF-8 back.\");\n\tassertEqualString(badname_utf8, archive_entry_symlink(entry));\n\n\tassertEqualInt(ARCHIVE_EOF, archive_read_next_header(a, &entry));\n\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}", "path": "libarchive/libarchive/test/test_pax_filename_encoding.c", "commit_date": "2016-12-08 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Unpack the archive in a new dir.\n */\n", "func_signal": "static void\nunpack(const char *dirname, const char *option)", "code": "{\n\tint r;\n\n\tassertMakeDir(dirname, 0755);\n\tassertChdir(dirname);\n\textract_reference_file(\"test_option_f.cpio\");\n\tr = systemf(\"%s -i %s < test_option_f.cpio > copy-no-a.out 2>copy-no-a.err\", testprog, option);\n\tassertEqualInt(0, r);\n\tassertChdir(\"..\");\n}", "path": "libarchive/cpio/test/test_option_f.c", "commit_date": "2009-08-03 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Pax format writer only accepts both BINARY and UTF-8.\n * If other character-set name is specified, you will get ARCHIVE_FAILED.\n */\n", "func_signal": "DEFINE_TEST(test_pax_filename_encoding_KOI8R_CP1251)", "code": "{\n  \tstruct archive *a;\n\n\tif (NULL == setlocale(LC_ALL, \"ru_RU.KOI8-R\")) {\n\t\tskipping(\"KOI8-R locale not available on this system.\");\n\t\treturn;\n\t}\n\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\t/* pax format writer only accepts both BINARY and UTF-8. */\n\tassertEqualInt(ARCHIVE_FAILED,\n\t    archive_write_set_options(a, \"hdrcharset=CP1251\"));\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n}", "path": "libarchive/libarchive/test/test_pax_filename_encoding.c", "commit_date": "2016-12-08 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Set the locale and write a pathname containing invalid characters.\n * This should work; the underlying implementation should automatically\n * fall back to storing the pathname in binary.\n */\n", "func_signal": "static void\ntest_pax_filename_encoding_2(void)", "code": "{\n\tchar filename[] = \"abc\\314\\214mno\\374xyz\";\n\tstruct archive *a;\n\tstruct archive_entry *entry;\n\tchar buff[65536];\n\tchar longname[] = \"abc\\314\\214mno\\374xyz\"\n\t    \"/abc\\314\\214mno\\374xyz/abcdefghijklmnopqrstuvwxyz\"\n\t    \"/abc\\314\\214mno\\374xyz/abcdefghijklmnopqrstuvwxyz\"\n\t    \"/abc\\314\\214mno\\374xyz/abcdefghijklmnopqrstuvwxyz\"\n\t    \"/abc\\314\\214mno\\374xyz/abcdefghijklmnopqrstuvwxyz\"\n\t    \"/abc\\314\\214mno\\374xyz/abcdefghijklmnopqrstuvwxyz\"\n\t    \"/abc\\314\\214mno\\374xyz/abcdefghijklmnopqrstuvwxyz\"\n\t    ;\n\tsize_t used;\n\n\t/*\n\t * We need a starting locale which has invalid sequences.\n\t * en_US.UTF-8 seems to be commonly supported.\n\t */\n\t/* If it doesn't exist, just warn and return. */\n\tif (NULL == setlocale(LC_ALL, \"en_US.UTF-8\")) {\n\t\tskipping(\"invalid encoding tests require a suitable locale;\"\n\t\t    \" en_US.UTF-8 not available on this system\");\n\t\treturn;\n\t}\n\n\tassert((a = archive_write_new()) != NULL);\n\tassertEqualIntA(a, 0, archive_write_set_format_pax(a));\n\tassertEqualIntA(a, 0, archive_write_add_filter_none(a));\n\tassertEqualIntA(a, 0, archive_write_set_bytes_per_block(a, 0));\n\tassertEqualInt(0,\n\t    archive_write_open_memory(a, buff, sizeof(buff), &used));\n\n\tassert((entry = archive_entry_new()) != NULL);\n\t/* Set pathname, gname, uname, hardlink to nonconvertible values. */\n\tarchive_entry_copy_pathname(entry, filename);\n\tarchive_entry_copy_gname(entry, filename);\n\tarchive_entry_copy_uname(entry, filename);\n\tarchive_entry_copy_hardlink(entry, filename);\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tfailure(\"This should generate a warning for nonconvertible names.\");\n\tassertEqualInt(ARCHIVE_WARN, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\n\tassert((entry = archive_entry_new()) != NULL);\n\t/* Set path, gname, uname, and symlink to nonconvertible values. */\n\tarchive_entry_copy_pathname(entry, filename);\n\tarchive_entry_copy_gname(entry, filename);\n\tarchive_entry_copy_uname(entry, filename);\n\tarchive_entry_copy_symlink(entry, filename);\n\tarchive_entry_set_filetype(entry, AE_IFLNK);\n\tfailure(\"This should generate a warning for nonconvertible names.\");\n\tassertEqualInt(ARCHIVE_WARN, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\n\tassert((entry = archive_entry_new()) != NULL);\n\t/* Set pathname to a very long nonconvertible value. */\n\tarchive_entry_copy_pathname(entry, longname);\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tfailure(\"This should generate a warning for nonconvertible names.\");\n\tassertEqualInt(ARCHIVE_WARN, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\n\tassertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n\n\t/*\n\t * Now read the entries back.\n\t */\n\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualInt(0, archive_read_support_format_tar(a));\n\tassertEqualInt(0, archive_read_open_memory(a, buff, used));\n\n\tassertEqualInt(0, archive_read_next_header(a, &entry));\n\tassertEqualString(filename, archive_entry_pathname(entry));\n\tassertEqualString(filename, archive_entry_gname(entry));\n\tassertEqualString(filename, archive_entry_uname(entry));\n\tassertEqualString(filename, archive_entry_hardlink(entry));\n\n\tassertEqualInt(0, archive_read_next_header(a, &entry));\n\tassertEqualString(filename, archive_entry_pathname(entry));\n\tassertEqualString(filename, archive_entry_gname(entry));\n\tassertEqualString(filename, archive_entry_uname(entry));\n\tassertEqualString(filename, archive_entry_symlink(entry));\n\n\tassertEqualInt(0, archive_read_next_header(a, &entry));\n\tassertEqualString(longname, archive_entry_pathname(entry));\n\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}", "path": "libarchive/libarchive/test/test_pax_filename_encoding.c", "commit_date": "2016-12-08 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Verify that KOI8-R filenames are correctly translated to Unicode and UTF-8.\n */\n", "func_signal": "DEFINE_TEST(test_pax_filename_encoding_KOI8R)", "code": "{\n  \tstruct archive *a;\n  \tstruct archive_entry *entry;\n\tchar buff[4096];\n\tsize_t used;\n\n\tif (NULL == setlocale(LC_ALL, \"ru_RU.KOI8-R\")) {\n\t\tskipping(\"KOI8-R locale not available on this system.\");\n\t\treturn;\n\t}\n\n\t/* Check if the platform completely supports the string conversion. */\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\tif (archive_write_set_options(a, \"hdrcharset=UTF-8\") != ARCHIVE_OK) {\n\t\tskipping(\"This system cannot convert character-set\"\n\t\t    \" from KOI8-R to UTF-8.\");\n\t\tarchive_write_free(a);\n\t\treturn;\n\t}\n\tarchive_write_free(a);\n\n\t/* Re-create a write archive object since filenames should be written\n\t * in UTF-8 by default. */\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\tassertEqualInt(ARCHIVE_OK,\n\t    archive_write_open_memory(a, buff, sizeof(buff), &used));\n\n\tentry = archive_entry_new2(a);\n\tarchive_entry_set_pathname(entry, \"\\xD0\\xD2\\xC9\");\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tarchive_entry_set_size(entry, 0);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n\n\t/* Above three characters in KOI8-R should translate to the following\n\t * three characters (two bytes each) in UTF-8. */\n\tassertEqualMem(buff + 512, \"15 path=\\xD0\\xBF\\xD1\\x80\\xD0\\xB8\\x0A\", 15);\n}", "path": "libarchive/libarchive/test/test_pax_filename_encoding.c", "commit_date": "2016-12-08 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Add a bzip2 compression filter to this write handle.\n */\n", "func_signal": "int\narchive_write_add_filter_bzip2(struct archive *_a)", "code": "{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n\tstruct private_data *data;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_add_filter_bzip2\");\n\n\tdata = calloc(1, sizeof(*data));\n\tif (data == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tdata->compression_level = 9; /* default */\n\n\tf->data = data;\n\tf->options = &archive_compressor_bzip2_options;\n\tf->close = &archive_compressor_bzip2_close;\n\tf->free = &archive_compressor_bzip2_free;\n\tf->open = &archive_compressor_bzip2_open;\n\tf->code = ARCHIVE_FILTER_BZIP2;\n\tf->name = \"bzip2\";\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\treturn (ARCHIVE_OK);\n#else\n\tdata->pdata = __archive_write_program_allocate(\"bzip2\");\n\tif (data->pdata == NULL) {\n\t\tfree(data);\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tdata->compression_level = 0;\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t    \"Using external bzip2 program\");\n\treturn (ARCHIVE_WARN);\n#endif\n}", "path": "libarchive/libarchive/archive_write_add_filter_bzip2.c", "commit_date": "2019-12-06 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Lookup uname/gname from uid/gid, return NULL if no match.\n */\n", "func_signal": "static const char *\nlookup_name(struct cpio *cpio, struct name_cache **name_cache_variable,\n    int (*lookup_fn)(struct cpio *, const char **, id_t), id_t id)", "code": "{\n\tchar asnum[16];\n\tstruct name_cache\t*cache;\n\tconst char *name;\n\tint slot;\n\n\n\tif (*name_cache_variable == NULL) {\n\t\t*name_cache_variable = calloc(1, sizeof(struct name_cache));\n\t\tif (*name_cache_variable == NULL)\n\t\t\tlafe_errc(1, ENOMEM, \"No more memory\");\n\t\t(*name_cache_variable)->size = name_cache_size;\n\t}\n\n\tcache = *name_cache_variable;\n\tcache->probes++;\n\n\tslot = id % cache->size;\n\tif (cache->cache[slot].name != NULL) {\n\t\tif (cache->cache[slot].id == id) {\n\t\t\tcache->hits++;\n\t\t\treturn (cache->cache[slot].name);\n\t\t}\n\t\tfree(cache->cache[slot].name);\n\t\tcache->cache[slot].name = NULL;\n\t}\n\n\tif (lookup_fn(cpio, &name, id)) {\n\t\t/* If lookup failed, format it as a number. */\n\t\tsnprintf(asnum, sizeof(asnum), \"%u\", (unsigned)id);\n\t\tname = asnum;\n\t}\n\n\tcache->cache[slot].name = strdup(name);\n\tif (cache->cache[slot].name != NULL) {\n\t\tcache->cache[slot].id = id;\n\t\treturn (cache->cache[slot].name);\n\t}\n\n\t/*\n\t * Conveniently, NULL marks an empty slot, so\n\t * if the strdup() fails, we've just failed to\n\t * cache it.  No recovery necessary.\n\t */\n\treturn (NULL);\n}", "path": "libarchive/cpio/cpio.c", "commit_date": "2020-03-02 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Verify that CP1251 filenames are correctly translated to Unicode and UTF-8.\n */\n", "func_signal": "DEFINE_TEST(test_pax_filename_encoding_CP1251)", "code": "{\n  \tstruct archive *a;\n  \tstruct archive_entry *entry;\n\tchar buff[4096];\n\tsize_t used;\n\n\tif (NULL == setlocale(LC_ALL, \"Russian_Russia\") &&\n\t    NULL == setlocale(LC_ALL, \"ru_RU.CP1251\")) {\n\t\tskipping(\"KOI8-R locale not available on this system.\");\n\t\treturn;\n\t}\n\n\t/* Check if the platform completely supports the string conversion. */\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\tif (archive_write_set_options(a, \"hdrcharset=UTF-8\") != ARCHIVE_OK) {\n\t\tskipping(\"This system cannot convert character-set\"\n\t\t    \" from KOI8-R to UTF-8.\");\n\t\tarchive_write_free(a);\n\t\treturn;\n\t}\n\tarchive_write_free(a);\n\n\t/* Re-create a write archive object since filenames should be written\n\t * in UTF-8 by default. */\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\tassertEqualInt(ARCHIVE_OK,\n\t    archive_write_open_memory(a, buff, sizeof(buff), &used));\n\n\tentry = archive_entry_new2(a);\n\tarchive_entry_set_pathname(entry, \"\\xef\\xf0\\xe8\");\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tarchive_entry_set_size(entry, 0);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n\n\t/* Above three characters in KOI8-R should translate to the following\n\t * three characters (two bytes each) in UTF-8. */\n\tassertEqualMem(buff + 512, \"15 path=\\xD0\\xBF\\xD1\\x80\\xD0\\xB8\\x0A\", 15);\n}", "path": "libarchive/libarchive/test/test_pax_filename_encoding.c", "commit_date": "2016-12-08 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Read a manually-created archive that has filenames that are\n * stored in binary instead of UTF-8 and verify that we get\n * the right filename returned and that we get a warning only\n * if the header isn't marked as binary.\n */\n", "func_signal": "static void\ntest_pax_filename_encoding_1(void)", "code": "{\n\tstatic const char testname[] = \"test_pax_filename_encoding.tar\";\n\t/*\n\t * \\314\\214 is a valid 2-byte UTF-8 sequence.\n\t * \\374 is invalid in UTF-8.\n\t */\n\tchar filename[] = \"abc\\314\\214mno\\374xyz\";\n\tstruct archive *a;\n\tstruct archive_entry *entry;\n\n\t/*\n\t * Read an archive that has non-UTF8 pax filenames in it.\n\t */\n\textract_reference_file(testname);\n\ta = archive_read_new();\n\tassertEqualInt(ARCHIVE_OK, archive_read_support_format_tar(a));\n\tassertEqualInt(ARCHIVE_OK, archive_read_support_filter_all(a));\n\tassertEqualInt(ARCHIVE_OK,\n\t    archive_read_open_filename(a, testname, 10240));\n\t/*\n\t * First entry in this test archive has an invalid UTF-8 sequence\n\t * in it, but the header is not marked as hdrcharset=BINARY, so that\n\t * requires a warning.\n\t */\n\tfailure(\"Invalid UTF8 in a pax archive pathname should cause a warning\");\n\tassertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &entry));\n\tassertEqualString(filename, archive_entry_pathname(entry));\n\t/*\n\t * Second entry is identical except that it does have\n\t * hdrcharset=BINARY, so no warning should be generated.\n\t */\n\tfailure(\"A pathname with hdrcharset=BINARY can have invalid UTF8\\n\"\n\t    \" characters in it without generating a warning\");\n\tassertEqualInt(ARCHIVE_OK, archive_read_next_header(a, &entry));\n\tassertEqualString(filename, archive_entry_pathname(entry));\n\tarchive_read_free(a);\n}", "path": "libarchive/libarchive/test/test_pax_filename_encoding.c", "commit_date": "2016-12-08 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Verify that EUC-JP filenames are correctly translated to Unicode and UTF-8.\n */\n", "func_signal": "DEFINE_TEST(test_pax_filename_encoding_EUCJP)", "code": "{\n  \tstruct archive *a;\n  \tstruct archive_entry *entry;\n\tchar buff[4096];\n\tsize_t used;\n\n\tif (NULL == setlocale(LC_ALL, \"ja_JP.eucJP\")) {\n\t\tskipping(\"eucJP locale not available on this system.\");\n\t\treturn;\n\t}\n\n\t/* Check if the platform completely supports the string conversion. */\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\tif (archive_write_set_options(a, \"hdrcharset=UTF-8\") != ARCHIVE_OK) {\n\t\tskipping(\"This system cannot convert character-set\"\n\t\t    \" from eucJP to UTF-8.\");\n\t\tarchive_write_free(a);\n\t\treturn;\n\t}\n\tarchive_write_free(a);\n\n\t/* Re-create a write archive object since filenames should be written\n\t * in UTF-8 by default. */\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\tassertEqualInt(ARCHIVE_OK,\n\t    archive_write_open_memory(a, buff, sizeof(buff), &used));\n\n\tentry = archive_entry_new2(a);\n\tarchive_entry_set_pathname(entry, \"\\xC9\\xBD.txt\");\n\t/* Check the Unicode version. */\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tarchive_entry_set_size(entry, 0);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n\n\t/* Check UTF-8 version. */\n\tassertEqualMem(buff + 512, \"16 path=\\xE8\\xA1\\xA8.txt\\x0A\", 16);\n\n}", "path": "libarchive/libarchive/test/test_pax_filename_encoding.c", "commit_date": "2016-12-08 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * It would be nice to just use printf() for formatting large numbers,\n * but the compatibility problems are a big headache.  Hence the\n * following simple utility function.\n */\n", "func_signal": "const char *\ncpio_i64toa(int64_t n0)", "code": "{\n\t/* 2^64 =~ 1.8 * 10^19, so 20 decimal digits suffice.\n\t * We also need 1 byte for '-' and 1 for '\\0'.\n\t */\n\tstatic char buff[22];\n\tint64_t n = n0 < 0 ? -n0 : n0;\n\tchar *p = buff + sizeof(buff);\n\n\t*--p = '\\0';\n\tdo {\n\t\t*--p = '0' + (int)(n % 10);\n\t\tn /= 10;\n\t} while (n > 0);\n\tif (n0 < 0)\n\t\t*--p = '-';\n\treturn p;\n}", "path": "libarchive/cpio/cpio.c", "commit_date": "2020-03-02 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Write data to the compressed stream.\n *\n * Returns ARCHIVE_OK if all data written, error otherwise.\n */\n", "func_signal": "static int\narchive_compressor_bzip2_write(struct archive_write_filter *f,\n    const void *buff, size_t length)", "code": "{\n\tstruct private_data *data = (struct private_data *)f->data;\n\n\t/* Update statistics */\n\tdata->total_in += length;\n\n\t/* Compress input data to output buffer */\n\tSET_NEXT_IN(data, buff);\n\tdata->stream.avail_in = length;\n\tif (drive_compressor(f, data, 0))\n\t\treturn (ARCHIVE_FATAL);\n\treturn (ARCHIVE_OK);\n}", "path": "libarchive/libarchive/archive_write_add_filter_bzip2.c", "commit_date": "2019-12-06 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Utility function to push input data through compressor, writing\n * full output blocks as necessary.\n *\n * Note that this handles both the regular write case (finishing ==\n * false) and the end-of-archive case (finishing == true).\n */\n", "func_signal": "static int\ndrive_compressor(struct archive_write_filter *f,\n    struct private_data *data, int finishing)", "code": "{\n\tint ret;\n\n\tfor (;;) {\n\t\tif (data->stream.avail_out == 0) {\n\t\t\tret = __archive_write_filter(f->next_filter,\n\t\t\t    data->compressed,\n\t\t\t    data->compressed_buffer_size);\n\t\t\tif (ret != ARCHIVE_OK) {\n\t\t\t\t/* TODO: Handle this write failure */\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tdata->stream.next_out = data->compressed;\n\t\t\tdata->stream.avail_out = data->compressed_buffer_size;\n\t\t}\n\n\t\t/* If there's nothing to do, we're done. */\n\t\tif (!finishing && data->stream.avail_in == 0)\n\t\t\treturn (ARCHIVE_OK);\n\n\t\tret = BZ2_bzCompress(&(data->stream),\n\t\t    finishing ? BZ_FINISH : BZ_RUN);\n\n\t\tswitch (ret) {\n\t\tcase BZ_RUN_OK:\n\t\t\t/* In non-finishing case, did compressor\n\t\t\t * consume everything? */\n\t\t\tif (!finishing && data->stream.avail_in == 0)\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\tbreak;\n\t\tcase BZ_FINISH_OK:  /* Finishing: There's more work to do */\n\t\t\tbreak;\n\t\tcase BZ_STREAM_END: /* Finishing: all done */\n\t\t\t/* Only occurs in finishing case */\n\t\t\treturn (ARCHIVE_OK);\n\t\tdefault:\n\t\t\t/* Any other return value indicates an error */\n\t\t\tarchive_set_error(f->archive,\n\t\t\t    ARCHIVE_ERRNO_PROGRAMMER,\n\t\t\t    \"Bzip2 compression failed;\"\n\t\t\t    \" BZ2_bzCompress() returned %d\",\n\t\t\t    ret);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n}", "path": "libarchive/libarchive/archive_write_add_filter_bzip2.c", "commit_date": "2019-12-06 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Verify that CP932/SJIS filenames are correctly translated to Unicode and UTF-8.\n */\n", "func_signal": "DEFINE_TEST(test_pax_filename_encoding_CP932)", "code": "{\n  \tstruct archive *a;\n  \tstruct archive_entry *entry;\n\tchar buff[4096];\n\tsize_t used;\n\n\tif (NULL == setlocale(LC_ALL, \"Japanese_Japan\") &&\n\t    NULL == setlocale(LC_ALL, \"ja_JP.SJIS\")) {\n\t\tskipping(\"eucJP locale not available on this system.\");\n\t\treturn;\n\t}\n\n\t/* Check if the platform completely supports the string conversion. */\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\tif (archive_write_set_options(a, \"hdrcharset=UTF-8\") != ARCHIVE_OK) {\n\t\tskipping(\"This system cannot convert character-set\"\n\t\t    \" from CP932/SJIS to UTF-8.\");\n\t\tarchive_write_free(a);\n\t\treturn;\n\t}\n\tarchive_write_free(a);\n\n\t/* Re-create a write archive object since filenames should be written\n\t * in UTF-8 by default. */\n\ta = archive_write_new();\n\tassertEqualInt(ARCHIVE_OK, archive_write_set_format_pax(a));\n\tassertEqualInt(ARCHIVE_OK,\n\t    archive_write_open_memory(a, buff, sizeof(buff), &used));\n\n\tentry = archive_entry_new2(a);\n\tarchive_entry_set_pathname(entry, \"\\x95\\x5C.txt\");\n\t/* Check the Unicode version. */\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tarchive_entry_set_size(entry, 0);\n\tassertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));\n\tarchive_entry_free(entry);\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n\n\t/* Check UTF-8 version. */\n\tassertEqualMem(buff + 512, \"16 path=\\xE8\\xA1\\xA8.txt\\x0A\", 16);\n\n}", "path": "libarchive/libarchive/test/test_pax_filename_encoding.c", "commit_date": "2016-12-08 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * This is used by both out mode (to copy objects from disk into\n * an archive) and pass mode (to copy objects from disk to\n * an archive_write_disk \"archive\").\n */\n", "func_signal": "static int\nfile_to_archive(struct cpio *cpio, const char *srcpath)", "code": "{\n\tconst char *destpath;\n\tstruct archive_entry *entry, *spare;\n\tsize_t len;\n\tint r;\n\n\t/*\n\t * Create an archive_entry describing the source file.\n\t *\n\t */\n\tentry = archive_entry_new();\n\tif (entry == NULL)\n\t\tlafe_errc(1, 0, \"Couldn't allocate entry\");\n\tarchive_entry_copy_sourcepath(entry, srcpath);\n\tr = archive_read_disk_entry_from_file(cpio->archive_read_disk,\n\t    entry, -1, NULL);\n\tif (r < ARCHIVE_FAILED)\n\t\tlafe_errc(1, 0, \"%s\",\n\t\t    archive_error_string(cpio->archive_read_disk));\n\tif (r < ARCHIVE_OK)\n\t\tlafe_warnc(0, \"%s\",\n\t\t    archive_error_string(cpio->archive_read_disk));\n\tif (r <= ARCHIVE_FAILED) {\n\t\tarchive_entry_free(entry);\n\t\tcpio->return_value = 1;\n\t\treturn (r);\n\t}\n\n\tif (cpio->uid_override >= 0) {\n\t\tarchive_entry_set_uid(entry, cpio->uid_override);\n\t\tarchive_entry_set_uname(entry, cpio->uname_override);\n\t}\n\tif (cpio->gid_override >= 0) {\n\t\tarchive_entry_set_gid(entry, cpio->gid_override);\n\t\tarchive_entry_set_gname(entry, cpio->gname_override);\n\t}\n\n\t/*\n\t * Generate a destination path for this entry.\n\t * \"destination path\" is the name to which it will be copied in\n\t * pass mode or the name that will go into the archive in\n\t * output mode.\n\t */\n\tdestpath = srcpath;\n\tif (cpio->destdir) {\n\t\tlen = cpio->destdir_len + strlen(srcpath) + 8;\n\t\tif (len >= cpio->pass_destpath_alloc) {\n\t\t\twhile (len >= cpio->pass_destpath_alloc) {\n\t\t\t\tcpio->pass_destpath_alloc += 512;\n\t\t\t\tcpio->pass_destpath_alloc *= 2;\n\t\t\t}\n\t\t\tfree(cpio->pass_destpath);\n\t\t\tcpio->pass_destpath = malloc(cpio->pass_destpath_alloc);\n\t\t\tif (cpio->pass_destpath == NULL)\n\t\t\t\tlafe_errc(1, ENOMEM,\n\t\t\t\t    \"Can't allocate path buffer\");\n\t\t}\n\t\tstrcpy(cpio->pass_destpath, cpio->destdir);\n\t\tstrcat(cpio->pass_destpath, remove_leading_slash(srcpath));\n\t\tdestpath = cpio->pass_destpath;\n\t}\n\tif (cpio->option_rename)\n\t\tdestpath = cpio_rename(destpath);\n\tif (destpath == NULL) {\n\t\tarchive_entry_free(entry);\n\t\treturn (0);\n\t}\n\tarchive_entry_copy_pathname(entry, destpath);\n\n\t/*\n\t * If we're trying to preserve hardlinks, match them here.\n\t */\n\tspare = NULL;\n\tif (cpio->linkresolver != NULL\n\t    && archive_entry_filetype(entry) != AE_IFDIR) {\n\t\tarchive_entry_linkify(cpio->linkresolver, &entry, &spare);\n\t}\n\n\tif (entry != NULL) {\n\t\tr = entry_to_archive(cpio, entry);\n\t\tarchive_entry_free(entry);\n\t\tif (spare != NULL) {\n\t\t\tif (r == 0)\n\t\t\t\tr = entry_to_archive(cpio, spare);\n\t\t\tarchive_entry_free(spare);\n\t\t}\n\t}\n\treturn (r);\n}", "path": "libarchive/cpio/cpio.c", "commit_date": "2020-03-02 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Finish the compression.\n */\n", "func_signal": "static int\narchive_compressor_bzip2_close(struct archive_write_filter *f)", "code": "{\n\tstruct private_data *data = (struct private_data *)f->data;\n\tint ret;\n\n\t/* Finish compression cycle. */\n\tret = drive_compressor(f, data, 1);\n\tif (ret == ARCHIVE_OK) {\n\t\t/* Write the last block */\n\t\tret = __archive_write_filter(f->next_filter,\n\t\t    data->compressed,\n\t\t    data->compressed_buffer_size - data->stream.avail_out);\n\t}\n\n\tswitch (BZ2_bzCompressEnd(&(data->stream))) {\n\tcase BZ_OK:\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(f->archive, ARCHIVE_ERRNO_PROGRAMMER,\n\t\t    \"Failed to clean up compressor\");\n\t\tret = ARCHIVE_FATAL;\n\t}\n\treturn ret;\n}", "path": "libarchive/libarchive/archive_write_add_filter_bzip2.c", "commit_date": "2019-12-06 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/*\n * Display information about the current file.\n *\n * The format here roughly duplicates the output of 'ls -l'.\n * This is based on SUSv2, where 'tar tv' is documented as\n * listing additional information in an \"unspecified format,\"\n * and 'pax -l' is documented as using the same format as 'ls -l'.\n */\n", "func_signal": "static void\nlist_item_verbose(struct cpio *cpio, struct archive_entry *entry)", "code": "{\n\tchar\t\t\t size[32];\n\tchar\t\t\t date[32];\n\tchar\t\t\t uids[16], gids[16];\n\tconst char \t\t*uname, *gname;\n\tFILE\t\t\t*out = stdout;\n\tconst char\t\t*fmt;\n\ttime_t\t\t\t mtime;\n\tstatic time_t\t\t now;\n\tstruct tm\t\t*ltime;\n#if defined(HAVE_LOCALTIME_R) || defined(HAVE__LOCALTIME64_S)\n\tstruct tm\t\ttmbuf;\n#endif\n#if defined(HAVE__LOCALTIME64_S)\n\terrno_t\t\t\tterr;\n\t__time64_t\t\ttmptime;\n#endif\n\n\tif (!now)\n\t\ttime(&now);\n\n\tif (cpio->option_numeric_uid_gid) {\n\t\t/* Format numeric uid/gid for display. */\n\t\tstrcpy(uids, cpio_i64toa(archive_entry_uid(entry)));\n\t\tuname = uids;\n\t\tstrcpy(gids, cpio_i64toa(archive_entry_gid(entry)));\n\t\tgname = gids;\n\t} else {\n\t\t/* Use uname if it's present, else lookup name from uid. */\n\t\tuname = archive_entry_uname(entry);\n\t\tif (uname == NULL)\n\t\t\tuname = lookup_uname(cpio, (uid_t)archive_entry_uid(entry));\n\t\t/* Use gname if it's present, else lookup name from gid. */\n\t\tgname = archive_entry_gname(entry);\n\t\tif (gname == NULL)\n\t\t\tgname = lookup_gname(cpio, (uid_t)archive_entry_gid(entry));\n\t}\n\n\t/* Print device number or file size. */\n\tif (archive_entry_filetype(entry) == AE_IFCHR\n\t    || archive_entry_filetype(entry) == AE_IFBLK) {\n\t\tsnprintf(size, sizeof(size), \"%lu,%lu\",\n\t\t    (unsigned long)archive_entry_rdevmajor(entry),\n\t\t    (unsigned long)archive_entry_rdevminor(entry));\n\t} else {\n\t\tstrcpy(size, cpio_i64toa(archive_entry_size(entry)));\n\t}\n\n\t/* Format the time using 'ls -l' conventions. */\n\tmtime = archive_entry_mtime(entry);\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/* Windows' strftime function does not support %e format. */\n\tif (mtime - now > 365*86400/2\n\t\t|| mtime - now < -365*86400/2)\n\t\tfmt = cpio->day_first ? \"%d %b  %Y\" : \"%b %d  %Y\";\n\telse\n\t\tfmt = cpio->day_first ? \"%d %b %H:%M\" : \"%b %d %H:%M\";\n#else\n\tif (mtime - now > 365*86400/2\n\t\t|| mtime - now < -365*86400/2)\n\t\tfmt = cpio->day_first ? \"%e %b  %Y\" : \"%b %e  %Y\";\n\telse\n\t\tfmt = cpio->day_first ? \"%e %b %H:%M\" : \"%b %e %H:%M\";\n#endif\n#if defined(HAVE_LOCALTIME_R)\n\tltime = localtime_r(&mtime, &tmbuf);\n#elif defined(HAVE__LOCALTIME64_S)\n\ttmptime = mtime;\n\tterr = _localtime64_s(&tmbuf, &tmptime);\n\tif (terr)\n\t\tltime = NULL;\n\telse\n\t\tltime = &tmbuf;\n#else\n\tltime = localtime(&mtime);\n#endif\n\tstrftime(date, sizeof(date), fmt, ltime);\n\n\tfprintf(out, \"%s%3d %-8s %-8s %8s %12s %s\",\n\t    archive_entry_strmode(entry),\n\t    archive_entry_nlink(entry),\n\t    uname, gname, size, date,\n\t    archive_entry_pathname(entry));\n\n\t/* Extra information for links. */\n\tif (archive_entry_hardlink(entry)) /* Hard link */\n\t\tfprintf(out, \" link to %s\", archive_entry_hardlink(entry));\n\telse if (archive_entry_symlink(entry)) /* Symbolic link */\n\t\tfprintf(out, \" -> %s\", archive_entry_symlink(entry));\n\tfprintf(out, \"\\n\");\n}", "path": "libarchive/cpio/cpio.c", "commit_date": "2020-03-02 00:00:00", "repo_name": "libarchive/libarchive", "stars": 2761, "license": "other", "language": "c", "size": 28758}
{"docstring": "/* Return the length of a separator optionally enclosed by whitespaces, 0 otherwise */\n", "func_signal": "static size_t json_parse_sep(const char *str, char sep)", "code": "{\n\tsize_t len = 0;\n\n\twhile (isspace(*str))\n\t\tstr++, len++;\n\n\tif (*str != sep)\n\t\treturn 0;\n\n\tstr++;\n\tlen++;\n\n\twhile (isspace(*str))\n\t\tstr++, len++;\n\n\treturn len;\n}", "path": "i3blocks/json.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Return the number of UTF-8 bytes on success, 0 if it is invalid */\n", "func_signal": "static size_t json_parse_codepoint(const char *str, char *buf, size_t size)", "code": "{\n\tuint16_t codepoint = 0;\n\tchar utf8[3];\n\tsize_t len;\n\tint hex;\n\tchar c;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tc = str[i];\n\n\t\tif (!isxdigit(c))\n\t\t\treturn 0;\n\n\t\tif (c >= '0' && c <= '9')\n\t\t\thex = c - '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\thex = c - 'a' + 10;\n\t\telse\n\t\t\thex = c - 'A' + 10;\n\n\t\tcodepoint |= hex << (12 - i * 4);\n\t}\n\n\t/* Support Only a single surrogate at the moment */\n\tif (codepoint <= 0x7f) {\n\t\tlen = 1;\n\t\tutf8[0] = codepoint;\n\t} else if (codepoint <= 0x7ff) {\n\t\tlen = 2;\n\t\tutf8[0] = 0xc0 | (codepoint >> 6);\n\t\tutf8[1] = 0x80 | (codepoint & 0x3f);\n\t} else {\n\t\tlen = 3;\n\t\tutf8[0] = (0xe0 | (codepoint >> 12));\n\t\tutf8[1] = (0x80 | ((codepoint >> 6) & 0x3f));\n\t\tutf8[2] = (0x80 | (codepoint & 0x3f));\n\t}\n\n\tif (buf) {\n\t\tif (size < len)\n\t\t\treturn 0;\n\n\t\tmemcpy(buf, utf8, len);\n\t}\n\n\treturn len;\n}", "path": "i3blocks/json.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Read a line including the newline character and return its positive length */\n", "func_signal": "static ssize_t line_gets(int fd, char *buf, size_t size)", "code": "{\n\tsize_t len = 0;\n\tint err;\n\n\tfor (;;) {\n\t\tif (len == size)\n\t\t\treturn -ENOSPC;\n\n\t\terr = line_getc(fd, buf + len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (buf[len++] == '\\n')\n\t\t\tbreak;\n\t}\n\n\t/* at least 1 */\n\treturn len;\n}", "path": "i3blocks/line.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Delete the key-value pair after a given pair */\n", "func_signal": "static void map_delete(struct pair *prev)", "code": "{\n\tstruct pair *pair = prev->next;\n\n\tprev->next = pair->next;\n\tmap_unpair(pair);\n}", "path": "i3blocks/map.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Return the length of the parsed non scalar (with open/close delimiter), 0 if it is invalid */\n", "func_signal": "static size_t json_parse_nested_struct(const char *str, char open, char close,\n\t\t\t\t       char *buf, size_t size)", "code": "{\n\tconst char *end = str;\n\tsize_t len;\n\tint nested;\n\n\tif (*str != open)\n\t\treturn 0;\n\n\tnested = 1;\n\twhile (nested) {\n\t\t++end;\n\n\t\t/* control character or end-of-line? */\n\t\tif (iscntrl(*end) || *end == '\\0')\n\t\t\treturn 0;\n\n\t\tif (*end == open)\n\t\t\tnested++;\n\t\telse if (*end == close)\n\t\t\tnested--;\n\t}\n\n\tlen = ++end - str;\n\tif (!len)\n\t\treturn 0;\n\n\tif (buf) {\n\t\tif (size <= len)\n\t\t\treturn 0;\n\n\t\tstrncpy(buf, str, len);\n\t\tbuf[len] = '\\0';\n\t}\n\n\treturn len;\n}", "path": "i3blocks/json.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Return the length of the parsed literal, 0 if it is invalid */\n", "func_signal": "static size_t json_parse_literal(const char *str, const char *literal,\n\t\t\t\t char *buf, size_t size)", "code": "{\n\tconst size_t len = strlen(literal);\n\n\tif (strncmp(str, literal, len) != 0)\n\t\treturn 0;\n\n\tif (buf) {\n\t\tstrncpy(buf, literal, size);\n\t\tif (buf[size - 1] != '\\0')\n\t\t\treturn 0;\n\t}\n\n\treturn len;\n}", "path": "i3blocks/json.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Insert a key-value pair after a given pair */\n", "func_signal": "static int map_insert(struct pair *prev, const char *key, const char *value)", "code": "{\n\tstruct pair *pair;\n\n\tpair = map_pair(key, value);\n\tif (!pair)\n\t\treturn -ENOMEM;\n\n\tpair->next = prev->next;\n\tprev->next = pair;\n\n\treturn 0;\n}", "path": "i3blocks/map.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Enable signal-driven I/O, formerly known as asynchronous I/O */\n", "func_signal": "int sys_async(int fd, int sig)", "code": "{\n\tpid_t pid;\n\tint flags;\n\tint err;\n\n\terr = sys_getfl(fd, &flags);\n\tif (err)\n\t\treturn err;\n\n\tif (sig) {\n    \t\tpid = getpid();\n\t\tflags |= (O_ASYNC | O_NONBLOCK);\n\t} else {\n    \t\tpid = 0;\n\t\tflags &= ~(O_ASYNC | O_NONBLOCK);\n\t}\n\n\t/* Establish a handler for the signal */\n\terr = sys_setsig(fd, sig);\n\tif (err)\n\t\treturn err;\n\n\t/* Set calling process as owner, that is to receive the signal */\n\terr = sys_setown(fd, pid);\n\tif (err)\n\t\treturn err;\n\n\t/* Enable/disable nonblocking I/O and signal-driven I/O */\n\treturn sys_setfl(fd, flags);\n}", "path": "i3blocks/sys.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Return the length of the parsed string, 0 if it is invalid */\n", "func_signal": "static size_t json_parse_string(const char *str, char *buf, size_t size)", "code": "{\n\tconst char *end = str;\n\tsize_t len;\n\tchar c;\n\n\tif (*end != '\"')\n\t\treturn 0;\n\n\tdo {\n\t\tlen = 0;\n\n\t\tswitch (*++end) {\n\t\tcase '\\0':\n\t\t\treturn 0;\n\t\tcase '\"':\n\t\t\tc = '\\0';\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tswitch (*++end) {\n\t\t\tcase '\"':\n\t\t\t\tc = '\"';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tc = '\\\\';\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tc = '/';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tc = '\\f';\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tc = '\\r';\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tlen = json_parse_codepoint(++end, buf, size);\n\t\t\t\tif (!len)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tend += 3; /* jump to last hex digit */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (iscntrl(*end))\n\t\t\t\treturn 0;\n\n\t\t\tc = *end;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf) {\n\t\t\tif (!len) {\n\t\t\t\tif (size < 1)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t*buf = c;\n\t\t\t\tlen = 1;\n\t\t\t}\n\n\t\t\tbuf += len;\n\t\t\tsize -= len;\n\t\t}\n\t} while (c);\n\n\treturn ++end - str;\n}", "path": "i3blocks/json.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Read up to size bytes and store the positive count on success */\n", "func_signal": "int sys_read(int fd, void *buf, size_t size, size_t *count)", "code": "{\n\tssize_t rc;\n\n\trc = read(fd, buf, size);\n\tif (rc == -1) {\n\t\tsys_errno(\"read(%d, %ld)\", fd, size);\n\t\trc = -errno;\n\t\tif (rc == -EWOULDBLOCK)\n\t\t\trc = -EAGAIN;\n\t\treturn rc;\n\t}\n\n\t/* End of file or pipe */\n\tif (rc == 0)\n\t\treturn -EAGAIN;\n\n\tif (count)\n\t\t*count = rc;\n\n\treturn 0;\n}", "path": "i3blocks/sys.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Read a line excluding the newline character */\n", "func_signal": "static int line_parse(int fd, line_cb_t *cb, size_t num, void *data)", "code": "{\n\tchar buf[BUFSIZ];\n\tssize_t len;\n\tint err;\n\n\tlen = line_gets(fd, buf, sizeof(buf));\n\tif (len < 0)\n\t\treturn len;\n\n\t/* replace newline with terminating null byte */\n\tbuf[len - 1] = '\\0';\n\n\tdebug(\"&%d:%.3d: %s\", fd, num, buf);\n\n\tif (cb) {\n\t\terr = cb(buf, num, data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}", "path": "i3blocks/line.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Return previous pair if key is found, last pair otherwise */\n", "func_signal": "static struct pair *map_prev(const struct map *map, const char *key)", "code": "{\n\tstruct pair *prev = map_head(map);\n\tstruct pair *next = prev->next;\n\n\twhile (next) {\n\t\tif (strcmp(next->key, key) == 0)\n\t\t\tbreak;\n\n\t\tprev = next;\n\t\tnext = next->next;\n\t}\n\n\treturn prev;\n}", "path": "i3blocks/map.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* A value can be a string, number, object, array, true, false, or null */\n", "func_signal": "static size_t json_parse_value(const char *str, char *buf, size_t size)", "code": "{\n\tsize_t len;\n\n\tlen = json_parse_string(str, buf, size);\n\tif (len)\n\t\treturn len;\n\n\tlen = json_parse_number(str, buf, size);\n\tif (len)\n\t\treturn len;\n\n\tlen = json_parse_nested_object(str, buf, size);\n\tif (len)\n\t\treturn len;\n\n\tlen = json_parse_nested_array(str, buf, size);\n\tif (len)\n\t\treturn len;\n\n\tlen = json_parse_literal(str, \"true\", buf, size);\n\tif (len)\n\t\treturn len;\n\n\tlen = json_parse_literal(str, \"false\", buf, size);\n\tif (len)\n\t\treturn len;\n\n\tlen = json_parse_literal(str, \"null\", buf, size);\n\tif (len)\n\t\treturn len;\n\n\treturn 0;\n}", "path": "i3blocks/json.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Destroy a new key-value pair */\n", "func_signal": "void map_unpair(struct pair *pair)", "code": "{\n\tmap_reassign(pair, NULL);\n\tfree(pair->key);\n\tfree(pair);\n}", "path": "i3blocks/map.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Update the value of a pair */\n", "func_signal": "static int map_reassign(struct pair *pair, const char *value)", "code": "{\n\tfree(pair->value);\n\tpair->value = NULL;\n\n\tif (value) {\n\t\tpair->value = strdup(value);\n\t\tif (!pair->value)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "path": "i3blocks/map.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Return the length of the parsed number, 0 if it is invalid */\n", "func_signal": "static size_t json_parse_number(const char *str, char *buf, size_t size)", "code": "{\n\tsize_t len;\n\tchar *end;\n\n\tstrtoul(str, &end, 10);\n\n\tlen = end - str;\n\tif (!len)\n\t\treturn 0;\n\n\tif (buf) {\n\t\tif (size <= len)\n\t\t\treturn 0;\n\n\t\tstrncpy(buf, str, len);\n\t\tbuf[len] = '\\0';\n\t}\n\n\treturn len;\n}", "path": "i3blocks/json.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Read up to count lines excluding their newline character */\n", "func_signal": "int line_read(int fd, size_t count, line_cb_t *cb, void *data)", "code": "{\n\tsize_t lines = 0;\n\tint err;\n\n\twhile (count--) {\n\t\terr = line_parse(fd, cb, lines++, data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}", "path": "i3blocks/line.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Push data to forked process through the open stdin pipe */\n", "func_signal": "static int block_send(struct block *block)", "code": "{\n\tconst char *button = block_get(block, \"button\");\n\n\tif (!button) {\n\t\tblock_error(block, \"no click data to send\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!block_is_spawned(block)) {\n\t\tblock_error(block, \"persistent block not spawned\");\n\t\treturn 0;\n\t}\n\n\tif (block->format == FORMAT_JSON)\n\t\treturn block_send_json(block);\n\n\tdprintf(block->in[1], \"%s\\n\", button);\n\n\treturn 0;\n}", "path": "i3blocks/block.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Parse an inline [\"name\"][\\s+:\\s+][value] name-value pair */\n", "func_signal": "static size_t json_parse_pair(const char *str, char *name, size_t namesiz,\n\t\t\t      char *val, size_t valsiz)", "code": "{\n\tsize_t pair_len = 0;\n\tsize_t len;\n\n\tlen = json_parse_string(str, name, namesiz);\n\tif (!len)\n\t\treturn 0;\n\n\tpair_len += len;\n\tstr += len;\n\n\tlen = json_parse_sep(str, ':');\n\tif (!len)\n\t\treturn 0;\n\n\tpair_len += len;\n\tstr += len;\n\n\tlen = json_parse_value(str, val, valsiz);\n\tif (!len)\n\t\treturn 0;\n\n\tpair_len += len;\n\n\treturn pair_len;\n}", "path": "i3blocks/json.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/* Create a new key-value pair */\n", "func_signal": "static struct pair *map_pair(const char *key, const char *value)", "code": "{\n\tstruct pair *pair;\n\tint err;\n\n\tpair = calloc(1, sizeof(struct pair));\n\tif (!pair)\n\t\treturn NULL;\n\n\tpair->key = strdup(key);\n\tif (!pair->key) {\n\t\tfree(pair);\n\t\treturn NULL;\n\t}\n\n\terr = map_reassign(pair, value);\n\tif (err) {\n\t\tfree(pair->key);\n\t\tfree(pair);\n\t\treturn NULL;\n\t}\n\n\treturn pair;\n}", "path": "i3blocks/map.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "vivien/i3blocks", "stars": 2226, "license": "gpl-3.0", "language": "c", "size": 504}
{"docstring": "/*\n * streams_to_meta\n *\n * Scans the pipeline_query catalog table and reads the FROM clause of\n * every active query to determine which streams each query is reading\n * from and what the TupleDesc is for each stream, based on the supertype\n * of all casts for each stream column.\n *\n * A mapping from stream name to this metadata is returned.\n */\n", "func_signal": "static HTAB *\nstreams_to_meta(Relation pipeline_query)", "code": "{\n\tHeapScanDesc scandesc;\n\tHASHCTL ctl;\n\tHTAB *targets;\n\tStreamTargetsEntry *entry;\n\tHeapTuple tup;\n\n\tMemSet(&ctl, 0, sizeof(ctl));\n\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(StreamTargetsEntry);\n\tctl.hash = oid_hash;\n\n\ttargets = hash_create(\"streams_to_targets_and_desc\", 32, &ctl, HASH_ELEM | HASH_FUNCTION);\n\tscandesc = heap_beginscan_catalog(pipeline_query, 0, NULL);\n\n\twhile ((tup = heap_getnext(scandesc, ForwardScanDirection)) != NULL)\n\t{\n\t\tForm_pipeline_query row = (Form_pipeline_query) GETSTRUCT(tup);\n\t\tbool found;\n\n\t\tentry = (StreamTargetsEntry *) hash_search(targets, &row->streamrelid, HASH_ENTER, &found);\n\n\t\tif (!found)\n\t\t{\n\t\t\tHASHCTL colsctl;\n\n\t\t\tMemSet(&colsctl, 0, sizeof(ctl));\n\t\t\tcolsctl.keysize = NAMEDATALEN;\n\t\t\tcolsctl.entrysize = sizeof(StreamColumnsEntry);\n\n\t\t\tentry->queries = NULL;\n\t\t}\n\n\t\tif (row->active)\n\t\t\tentry->queries = bms_add_member(entry->queries, row->id);\n\t}\n\n\theap_endscan(scandesc);\n\n\treturn targets;\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * GetStreamReaders\n *\n * Gets a bitmap indexed by continuous query id that represents which\n * queries are reading from the given stream.\n */\n", "func_signal": "Bitmapset *\nGetAllStreamReaders(Oid relid)", "code": "{\n\tHeapTuple tup = PipelineCatalogLookup(PIPELINESTREAMRELID, 1, ObjectIdGetDatum(relid));\n\tbool isnull;\n\tDatum raw;\n\tbytea *bytes;\n\tint nbytes;\n\tint nwords;\n\tBitmapset *result;\n\n\tif (!HeapTupleIsValid(tup))\n\t\treturn NULL;\n\n\traw = PipelineCatalogGetAttr(PIPELINESTREAMRELID, tup, Anum_pipeline_stream_queries, &isnull);\n\n\tif (isnull)\n\t\treturn NULL;\n\n\tbytes = (bytea *) DatumGetPointer(PG_DETOAST_DATUM(raw));\n\tnbytes = VARSIZE(bytes) - VARHDRSZ;\n\tnwords = nbytes / sizeof(bitmapword);\n\n\tresult = palloc0(BITMAPSET_SIZE(nwords));\n\tresult->nwords = nwords;\n\n\tmemcpy(result->words, VARDATA(bytes), nbytes);\n\n\treturn result;\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * send_microbatch\n */\n", "func_signal": "static bool\nsend_microbatch(uint64_t recv_id, char *batch, int len)", "code": "{\n\tpzmq_connect(recv_id);\n\treturn pzmq_send(recv_id, batch, len, false);\n}", "path": "pipelinedb/src/queue.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * has_pipeline_stream_row\n */\n", "func_signal": "static bool\nhas_pipeline_stream_row(Oid relid)", "code": "{\n\tHeapTuple tup = PipelineCatalogLookup(PIPELINESTREAMRELID, 1, relid);\n\n\tif (!HeapTupleIsValid(tup))\n\t\treturn false;\n\n\treturn true;\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * ipc_tuple_reader_pull\n */\n", "func_signal": "ipc_tuple_reader_batch *\nipc_tuple_reader_pull(void)", "code": "{\n\tTimestampTz start = GetCurrentTimestamp();\n\tMemoryContext old;\n\tlong secs;\n\tint usecs;\n\tint ntups = 0;\n\tint nbytes = 0;\n\tBitmapset *queries = NULL;\n\tList *flush_acks = NIL;\n\n\tAssert(my_reader->batches == NIL);\n\n\told = MemoryContextSwitchTo(my_reader->cxt);\n\n\tmy_rbatch.has_acks = false;\n\n\twhile (true)\n\t{\n\t\tint len;\n\t\tchar *buf;\n\t\tmicrobatch_t *mb;\n\t\tint timeout;\n\n\t\tif (ntups >= continuous_query_batch_size || nbytes >= MAX_MICROBATCH_SIZE)\n\t\t\tbreak;\n\n\t\tTimestampDifference(start, GetCurrentTimestamp(), &secs, &usecs);\n\t\ttimeout = continuous_query_max_wait - (secs * 1000 + usecs / 1000);\n\t\tif (timeout <= 0)\n\t\t\tbreak;\n\n\t\tbuf = pzmq_recv(&len, timeout);\n\t\tif (!buf)\n\t\t\tcontinue;\n\n\t\tmb = microbatch_unpack(buf, len);\n\t\tntups += mb->ntups;\n\t\tnbytes += len;\n\n\t\t/*\n\t\t * If this is a FlushTuple microbatch, don't add it to the list of microbatches to\n\t\t * process, just accumulate the ack so we can broadcast it later on.\n\t\t */\n\t\tif (mb->type == FlushTuple)\n\t\t{\n\t\t\ttagged_ref_t *ref;\n#ifdef USE_ASSERT_CHECKING\n\t\t\tmicrobatch_ack_t *ack;\n#endif\n\n\t\t\tAssert(list_length(mb->acks) == 1);\n\n\t\t\tref = linitial(mb->acks);\n\t\t\tif (!microbatch_ack_ref_is_valid(ref))\n\t\t\t\tcontinue;\n#ifdef USE_ASSERT_CHECKING\n\t\t\tack = (microbatch_ack_t *) ref->ptr;\n\t\t\tAssert(microbatch_ack_get_level(ack) == STREAM_INSERT_FLUSH);\n#endif\n\n\t\t\tflush_acks = lappend(flush_acks, ref);\n\t\t\tmy_rbatch.has_acks = true;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tmy_reader->batches = lappend(my_reader->batches, mb);\n\n\t\tqueries = bms_union(queries, mb->queries);\n\n\t\t/*\n\t\t * Hot path for STREAM_INSERT_SYNCHRONOUS_RECEIVE inserts. If we're receiving a microbatch from the insert process\n\t\t * (we are a worker and microbatch has a single ack of level STREAM_INSERT_SYNCHRONOUS_RECEIVE), mark it as read\n\t\t * and don't pass the ack downstream.\n\t\t */\n\t\tif (list_length(mb->acks) == 1 && IsContQueryWorkerProcess())\n\t\t{\n\t\t\ttagged_ref_t *ref = linitial(mb->acks);\n\t\t\tmicrobatch_ack_t *ack = (microbatch_ack_t *) ref->ptr;\n\n\t\t\tif (microbatch_ack_ref_is_valid(ref) && microbatch_ack_get_level(ack) == STREAM_INSERT_SYNCHRONOUS_RECEIVE)\n\t\t\t{\n\t\t\t\tmicrobatch_ack_increment_wrecv(ack, mb->ntups);\n\n\t\t\t\t/*\n\t\t\t\t * Set the acks for this microbatch to be NIL so that we don't pass them around to\n\t\t\t\t * downstream processes.\n\t\t\t\t */\n\t\t\t\tmb->acks = NIL;\n\t\t\t}\n\t\t}\n\n\t\tmy_rbatch.has_acks |= list_length(mb->acks) > 0;\n\t}\n\n\tMemoryContextSwitchTo(old);\n\n\tmy_rbatch.ntups = ntups;\n\tmy_rbatch.nbytes = nbytes;\n\tmy_rbatch.queries = queries;\n\tmy_rbatch.sync_acks = NIL;\n\tmy_rbatch.flush_acks = flush_acks;\n\n\tmy_reader->flush_acks = flush_acks;\n\n\treturn &my_rbatch;\n}", "path": "pipelinedb/src/reader.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * ipc_tuple_reader_destroy\n */\n", "func_signal": "void\nipc_tuple_reader_destroy(void)", "code": "{\n\tipc_tuple_reader_ack();\n\tipc_tuple_reader_reset();\n\n\tMemoryContextDelete(my_reader->cxt);\n\tmy_reader->cxt = NULL;\n}", "path": "pipelinedb/src/reader.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * mark_nonexistent_streams\n */\n", "func_signal": "static void\nmark_nonexistent_streams(Relation pipeline_stream, List *keys)", "code": "{\n\tHeapScanDesc scandesc;\n\tHeapTuple tup;\n\n\t/* delete from the catalog any streams that aren't in the given list */\n\tscandesc = heap_beginscan_catalog(pipeline_stream, 0, NULL);\n\twhile ((tup = heap_getnext(scandesc, ForwardScanDirection)) != NULL)\n\t{\n\t\tListCell *lc;\n\t\tbool found = false;\n\t\tForm_pipeline_stream row = (Form_pipeline_stream) GETSTRUCT(tup);\n\n\t\tforeach(lc, keys)\n\t\t{\n\t\t\tOid relid = lfirst_oid(lc);\n\n\t\t\tif (relid == row->relid)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t{\n\t\t\tDatum values[Natts_pipeline_stream];\n\t\t\tbool nulls[Natts_pipeline_stream];\n\t\t\tbool replaces[Natts_pipeline_stream];\n\t\t\tHeapTuple newtup;\n\t\t\tbool isnull;\n\n\t\t\tPipelineCatalogGetAttr(PIPELINESTREAMRELID, tup, Anum_pipeline_stream_queries, &isnull);\n\n\t\t\t/* If queries is already NULL, this is a noop */\n\t\t\tif (isnull)\n\t\t\t\tcontinue;\n\n\t\t\tMemSet(nulls, false, Natts_pipeline_stream);\n\t\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\t\treplaces[Anum_pipeline_stream_queries - 1] = true;\n\t\t\tnulls[Anum_pipeline_stream_queries - 1] = true;\n\n\t\t\tnewtup = heap_modify_tuple(tup, pipeline_stream->rd_att,\n\t\t\t\t\tvalues, nulls, replaces);\n\n\t\t\tPipelineCatalogTupleUpdate(pipeline_stream, &newtup->t_self, newtup);\n\t\t\tCommandCounterIncrement();\n\t\t}\n\t}\n\n\theap_endscan(scandesc);\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * read_from_next_batch\n */\n", "func_signal": "static inline ipc_tuple *\nread_from_next_batch(Oid query_id)", "code": "{\n\tmy_rscan.batch = lnext(my_rscan.batch);\n\tmy_rscan.tup_idx = -1;\n\treturn ipc_tuple_reader_next(query_id);\n}", "path": "pipelinedb/src/reader.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * retry_pending\n */\n", "func_signal": "static int\nretry_pending(Size *memory_freed)", "code": "{\n\tSize freed = 0;\n\tHASH_SEQ_STATUS iter;\n\tpending_microbatch_t *entry;\n\tList *to_delete = NIL;\n\tListCell *lc;\n\tint count = 0;\n\n\tAssert(pending);\n\n\tif (!hash_get_num_entries(pending))\n\t\treturn 0;\n\n\thash_seq_init(&iter, pending);\n\n\twhile ((entry = (pending_microbatch_t *) hash_seq_search(&iter)) != NULL)\n\t{\n\t\tif (send_microbatch(entry->recv_id, entry->batch, entry->len))\n\t\t\tto_delete = lappend(to_delete, entry);\n\t\tcount++;\n\t}\n\n\tforeach(lc, to_delete)\n\t{\n\t\tpending_microbatch_t *entry = (pending_microbatch_t *) lfirst(lc);\n\t\tbool found;\n\n\t\tpfree(entry->buf);\n\t\thash_search(pending, &entry->batch, HASH_REMOVE, &found);\n\t\tAssert(found);\n\n\t\tfreed += PENDING_MICROBATCH_SIZE(entry);\n\t\tcount--;\n\t}\n\n\tlist_free(to_delete);\n\t*memory_freed -= freed;\n\n\treturn count;\n}", "path": "pipelinedb/src/queue.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * peek_microbatch\n */\n", "func_signal": "static char *\npeek_microbatch(char *buf, uint64 *recv_id, int *len)", "code": "{\n\tchar *result;\n\n\t/* The message header is the destination recv_id */\n\tAssert(recv_id);\n\tmemcpy(recv_id, buf, sizeof(uint64));\n\n\tresult = buf + sizeof(uint64);\n\t*len -= sizeof(uint64);\n\n\treturn result;\n}", "path": "pipelinedb/src/queue.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * RangeVarIsStream\n */\n", "func_signal": "bool\nRangeVarIsStream(RangeVar *rv, bool missing_ok)", "code": "{\n\tOid relid;\n\n\t/* Ignore cross-database references */\n\tif (rv->catalogname && pg_strcasecmp(rv->catalogname, get_database_name(MyDatabaseId)) != 0)\n\t\treturn false;\n\n\trelid = RangeVarGetRelid(rv, NoLock, missing_ok);\n\tif (!OidIsValid(relid))\n\t\treturn false;\n\n\tif (get_rel_relkind(relid) != RELKIND_FOREIGN_TABLE)\n\t\treturn false;\n\n\treturn has_pipeline_stream_row(relid);\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * ipc_tuple_reader_rewind\n */\n", "func_signal": "void\nipc_tuple_reader_rewind(void)", "code": "{\n\tMemSet(&my_rscan, 0, sizeof(ipc_tuple_reader_scan));\n\tmy_rscan.tup_idx = -1;\n\tmy_rbatch.sync_acks = NIL;\n}", "path": "pipelinedb/src/reader.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * GetLocalStreamReaders\n */\n", "func_signal": "Bitmapset *\nGetLocalStreamReaders(Oid relid)", "code": "{\n\tBitmapset *readers = GetAllStreamReaders(relid);\n\n\tif (stream_targets && strlen(stream_targets) && readers)\n\t{\n\t\tBitmapset *local_readers = NULL;\n\t\tHeapTuple tuple;\n\t\tForm_pipeline_query row;\n\t\tchar *targets = pstrdup(stream_targets);\n\t\tList *streams;\n\t\tListCell *lc;\n\n\t\tif (!SplitIdentifierString(targets, ',', &streams))\n\t\t{\n\t\t\t/* syntax error in stream_targets */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"stream_targets\\\"\")));\n\t\t}\n\n\t\tforeach(lc, streams)\n\t\t{\n\t\t\tchar *view_name = (char *) lfirst(lc);\n\t\t\tRangeVar *rv;\n\t\t\tList *name = NIL;\n\t\t\tint i = 0;\n\n\t\t\t/* deconstruct possible qualifiers */\n\t\t\twhile (++i)\n\t\t\t{\n\t\t\t\tDatum qual_split = PointerGetDatum(cstring_to_text(\".\"));\n\t\t\t\tDatum view_datum = PointerGetDatum(cstring_to_text(view_name));\n\t\t\t\tDatum quals_datum = DirectFunctionCall3(split_text, view_datum, qual_split, Int32GetDatum(i));\n\t\t\t\tchar *qual = text_to_cstring((const text *) DatumGetPointer(quals_datum));\n\n\t\t\t\tif (!strlen(qual))\n\t\t\t\t\tbreak;\n\n\t\t\t\tname = lappend(name, makeString(qual));\n\t\t\t}\n\n\t\t\trv = makeRangeVarFromNameList(name);\n\t\t\ttuple = GetPipelineQueryTuple(rv);\n\n\t\t\tif (!HeapTupleIsValid(tuple))\n\t\t\t\telog(ERROR, \"continuous view \\\"%s\\\" does not exist\", view_name);\n\n\t\t\trow = (Form_pipeline_query) GETSTRUCT(tuple);\n\t\t\tlocal_readers = bms_add_member(local_readers, row->id);\n\n\t\t}\n\n\t\treaders = bms_intersect(readers, local_readers);\n\t\tbms_free(local_readers);\n\t\tpfree(targets);\n\t\tlist_free(streams);\n\t}\n\n\treturn readers;\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * transformCreateStreamStmt\n */\n", "func_signal": "void\ntransformCreateStreamStmt(CreateForeignTableStmt *stmt)", "code": "{\n\tListCell *lc;\n\tbool saw_atime = false;\n\n\tvalidate_stream_constraints((CreateStmt *) stmt);\n\n\tforeach(lc, stmt->base.tableElts)\n\t{\n\t\tColumnDef *coldef = (ColumnDef *) lfirst(lc);\n\n\t\tif (pg_strcasecmp(coldef->colname, ARRIVAL_TIMESTAMP) == 0)\n\t\t{\n\t\t\tOid typ;\n\t\t\tint typmod;\n\n\t\t\ttypenameTypeIdAndMod(NULL, coldef->typeName, &typ, &typmod);\n\n\t\t\t/*\n\t\t\t * HACK(usmanm): If arrival_timestamp is the last column and has the correct type, then let it slide. This\n\t\t\t * it for making CREATE STREAM ... (LIKE ...) and pg_dump/pg_restore to work. Should be fixed by #1616.\n\t\t\t */\n\t\t\tif (!lnext(lc) && typ == TIMESTAMPTZOID)\n\t\t\t\tsaw_atime = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_COLUMN),\n\t\t\t\t\t\t errmsg(\"column name \\\"%s\\\" conflicts with a system column name\",\n\t\t\t\t\t\t\t\tARRIVAL_TIMESTAMP)));\n\t\t}\n\t}\n\n\tif (!saw_atime)\n\t{\n\t\tColumnDef *coldef;\n\t\tTypeName *typename;\n\n\t\ttypename = makeNode(TypeName);\n\t\ttypename->typeOid = TIMESTAMPTZOID;\n\t\ttypename->typemod = -1;\n\n\t\tcoldef = makeNode(ColumnDef);\n\t\tcoldef->colname = ARRIVAL_TIMESTAMP;\n\t\tcoldef->inhcount = 0;\n\t\tcoldef->is_local = true;\n\t\tcoldef->is_not_null = false;\n\t\tcoldef->raw_default = NULL;\n\t\tcoldef->cooked_default = NULL;\n\t\tcoldef->constraints = NIL;\n\t\tcoldef->typeName = typename;\n\n\t\tstmt->base.tableElts = lappend(stmt->base.tableElts, coldef);\n\t}\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * RelidIsOutputStream\n */\n", "func_signal": "bool\nRelidIsOutputStream(Oid relid)", "code": "{\n\tHeapTuple tup = PipelineCatalogLookup(PIPELINEQUERYOSRELID, 1, ObjectIdGetDatum(relid));\n\n\treturn HeapTupleIsValid(tup);\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * SyncPipelineStream\n */\n", "func_signal": "void\nSyncPipelineStream(void)", "code": "{\n\tHeapTuple tup;\n\tRelation pipeline_stream;\n\tHeapScanDesc scan_desc;\n\n\tif (pg_class_aclcheck(GetPipelineStreamOid(), GetUserId(), ACL_DELETE) != ACLCHECK_OK)\n\t\treturn;\n\n\tpipeline_stream = OpenPipelineStream(NoLock);\n\tscan_desc = heap_beginscan_catalog(pipeline_stream, 0, NULL);\n\n\twhile ((tup = heap_getnext(scan_desc, ForwardScanDirection)) != NULL)\n\t{\n\t\tForm_pipeline_stream row = (Form_pipeline_stream) GETSTRUCT(tup);\n\t\tif (!get_rel_name(row->relid))\n\t\t{\n\t\t\tPipelineCatalogTupleDelete(pipeline_stream, &tup->t_self);\n\t\t\tPurgeDeadStreamStats(row->relid);\n\t\t}\n\t}\n\n\theap_endscan(scan_desc);\n\theap_close(pipeline_stream, NoLock);\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * ipc_tuple_reader_reset\n */\n", "func_signal": "void\nipc_tuple_reader_reset(void)", "code": "{\n\tMemoryContextReset(my_reader->cxt);\n\tmy_reader->batches = NIL;\n\tmy_reader->flush_acks = NIL;\n\tipc_tuple_reader_rewind();\n}", "path": "pipelinedb/src/reader.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * ipc_tuple_reader_ack\n */\n", "func_signal": "void\nipc_tuple_reader_ack(void)", "code": "{\n\tListCell *lc;\n\n\tforeach(lc, my_reader->batches)\n\t{\n\t\tmicrobatch_t *mb = lfirst(lc);\n\t\tmicrobatch_acks_check_and_exec(mb->acks, microbatch_ack_increment_acks, mb->ntups);\n\t}\n\n\tmicrobatch_acks_check_and_exec(my_reader->flush_acks, microbatch_ack_increment_acks, 1);\n}", "path": "pipelinedb/src/reader.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * CreatePipelineStreamCatalogEntry\n */\n", "func_signal": "void\nCreatePipelineStreamEntry(CreateForeignTableStmt *stmt, Oid relid)", "code": "{\n\tRelation ps = OpenPipelineStream(RowExclusiveLock);\n\tDatum values[Natts_pipeline_stream];\n\tbool nulls[Natts_pipeline_stream];\n\tHeapTuple tup;\n\tObjectAddress referenced;\n\tObjectAddress dependent;\n\n\t/*\n\t * The stream will depend on its corresponding pipelinedb.stream catalog row\n\t */\n\tdependent.classId = RelationRelationId;\n\tdependent.objectId = relid;\n\tdependent.objectSubId = 0;\n\n\treferenced.classId = RelationRelationId;\n\treferenced.objectId = GetPipelineStreamOid();\n\treferenced.objectSubId = 0;\n\n\trecordDependencyOn(&dependent, &referenced, DEPENDENCY_NORMAL);\n\n\t/*\n\t * This stream will CQs reading from it so it depends on pipelinedb.cont_query\n\t */\n\tdependent.classId = RelationRelationId;\n\tdependent.objectId = relid;\n\tdependent.objectSubId = 0;\n\n\treferenced.classId = RelationRelationId;\n\treferenced.objectId = GetPipelineQueryOid();\n\treferenced.objectSubId = 0;\n\n\trecordDependencyOn(&dependent, &referenced, DEPENDENCY_NORMAL);\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[Anum_pipeline_stream_relid - 1] = ObjectIdGetDatum(relid);\n\tnulls[Anum_pipeline_stream_queries - 1] = true;\n\n\ttup = heap_form_tuple(RelationGetDescr(ps), values, nulls);\n\n\tPipelineCatalogTupleInsert(ps, tup);\n\tCommandCounterIncrement();\n\n\tClosePipelineStream(ps, NoLock);\n}", "path": "pipelinedb/src/pipeline_stream.c", "commit_date": "2018-10-29 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/*\n * ipc_tuple_reader_init\n */\n", "func_signal": "void\nipc_tuple_reader_init(void)", "code": "{\n\tMemoryContext cxt;\n\tMemoryContext old;\n\tipc_tuple_reader *reader;\n\n\told = MemoryContextSwitchTo(TopMemoryContext);\n\n\tcxt = AllocSetContextCreate(TopMemoryContext, \"ipc_tuple_reader MemoryContext\",\n\t\t\tALLOCSET_DEFAULT_MINSIZE,\n\t\t\tALLOCSET_DEFAULT_INITSIZE,\n\t\t\tALLOCSET_DEFAULT_MAXSIZE);\n\n\treader = palloc0(sizeof(ipc_tuple_reader));\n\treader->cxt = cxt;\n\n\tMemoryContextSwitchTo(old);\n\n\tmy_reader = reader;\n}", "path": "pipelinedb/src/reader.c", "commit_date": "2018-10-23 00:00:00", "repo_name": "pipelinedb/pipelinedb", "stars": 2604, "license": "apache-2.0", "language": "c", "size": 48997}
{"docstring": "/***********************************************************************\n*\n*  Message Output\n*\n***********************************************************************/\n", "func_signal": "void\nlame_report_def(const char *format, va_list args)", "code": "{\n    (void) vfprintf(stderr, format, args);\n    fflush(stderr); /* an debug function should flush immediately */\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/***********************************************************************\n*\n*  Global Function Definitions\n*\n***********************************************************************/\n/*empty and close mallocs in gfc */\n", "func_signal": "void\nfree_id3tag(lame_internal_flags * const gfc)", "code": "{\n    if (gfc->tag_spec.title != 0) {\n        free(gfc->tag_spec.title);\n        gfc->tag_spec.title = 0;\n    }\n    if (gfc->tag_spec.artist != 0) {\n        free(gfc->tag_spec.artist);\n        gfc->tag_spec.artist = 0;\n    }\n    if (gfc->tag_spec.album != 0) {\n        free(gfc->tag_spec.album);\n        gfc->tag_spec.album = 0;\n    }\n    if (gfc->tag_spec.comment != 0) {\n        free(gfc->tag_spec.comment);\n        gfc->tag_spec.comment = 0;\n    }\n\n    if (gfc->tag_spec.albumart != 0) {\n        free(gfc->tag_spec.albumart);\n        gfc->tag_spec.albumart = 0;\n        gfc->tag_spec.albumart_size = 0;\n        gfc->tag_spec.albumart_mimetype = MIMETYPE_NONE;\n    }\n    if (gfc->tag_spec.v2_head != 0) {\n        FrameDataNode *node = gfc->tag_spec.v2_head;\n        do {\n            void   *p = node->dsc.ptr.b;\n            void   *q = node->txt.ptr.b;\n            void   *r = node;\n            node = node->nxt;\n            free(p);\n            free(q);\n            free(r);\n        } while (node != 0);\n        gfc->tag_spec.v2_head = 0;\n        gfc->tag_spec.v2_tail = 0;\n    }\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* resampling via FIR filter, blackman window */\n", "func_signal": "inline static FLOAT\nblackman(FLOAT x, FLOAT fcn, int l)", "code": "{\n    /* This algorithm from:\n       SIGNAL PROCESSING ALGORITHMS IN FORTRAN AND C\n       S.D. Stearns and R.A. David, Prentice-Hall, 1992\n     */\n    FLOAT   bkwn, x2;\n    FLOAT const wcn = (PI * fcn);\n\n    x /= l;\n    if (x < 0)\n        x = 0;\n    if (x > 1)\n        x = 1;\n    x2 = x - .5;\n\n    bkwn = 0.42 - 0.5 * cos(2 * x * PI) + 0.08 * cos(4 * x * PI);\n    if (fabs(x2) < 1e-9)\n        return wcn / PI;\n    else\n        return (bkwn * sin(l * wcn * x2) / (PI * l * x2));\n\n\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* copy in new samples from in_buffer into mfbuf, with resampling\n   if necessary.  n_in = number of samples from the input buffer that\n   were used.  n_out = number of samples copied into mfbuf  */\n", "func_signal": "void\nfill_buffer(lame_internal_flags * gfc,\n            sample_t * const mfbuf[2], sample_t const * const in_buffer[2], int nsamples, int *n_in, int *n_out)", "code": "{\n    SessionConfig_t const *const cfg = &gfc->cfg;\n    int     mf_size = gfc->sv_enc.mf_size;\n    int     framesize = 576 * cfg->mode_gr;\n    int     nout, ch = 0;\n    int     nch = cfg->channels_out;\n\n    /* copy in new samples into mfbuf, with resampling if necessary */\n    if (isResamplingNecessary(cfg)) {\n        do {\n            nout =\n                fill_buffer_resample(gfc, &mfbuf[ch][mf_size],\n                                     framesize, in_buffer[ch], nsamples, n_in, ch);\n        } while (++ch < nch);\n        *n_out = nout;\n    }\n    else {\n        nout = Min(framesize, nsamples);\n        do {\n            memcpy(&mfbuf[ch][mf_size], &in_buffer[ch][0], nout * sizeof(mfbuf[0][0]));\n        } while (++ch < nch);\n        *n_out = nout;\n        *n_in = nout;\n    }\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/****************************************************************************\n * Jonathan Dee 2001/08/31\n *\n * PutLameVBR: Write LAME info: mini version + info on various switches used\n * Paramters:\n *                              pbtStreamBuffer : pointer to output buffer\n *                              id3v2size               : size of id3v2 tag in bytes\n *                              crc                             : computation of crc-16 of Lame Tag so far (starting at frame sync)\n *\n ****************************************************************************\n*/\n", "func_signal": "static int\nPutLameVBR(lame_global_flags const *gfp, size_t nMusicLength, uint8_t * pbtStreamBuffer, uint16_t crc)", "code": "{\n    lame_internal_flags const *gfc = gfp->internal_flags;\n    SessionConfig_t const *const cfg = &gfc->cfg;\n\n    int     nBytesWritten = 0;\n    int     i;\n\n    int     enc_delay = gfc->ov_enc.encoder_delay; /* encoder delay */\n    int     enc_padding = gfc->ov_enc.encoder_padding; /* encoder padding  */\n\n    /*recall: cfg->vbr_q is for example set by the switch -V  */\n    /*   gfp->quality by -q, -h, -f, etc */\n\n    int     nQuality = (100 - 10 * gfp->VBR_q - gfp->quality);\n\n\n    /*\n    NOTE:\n            Even though the specification for the LAME VBR tag\n            did explicitly mention other encoders than LAME,\n            many SW/HW decoder seem to be able to make use of\n            this tag only, if the encoder version starts with LAME.\n            To be compatible with such decoders, ANY encoder will\n            be forced to write a fake LAME version string!\n            As a result, the encoder version info becomes worthless.\n    */\n    const char *szVersion = get_lame_tag_encoder_short_version();\n    uint8_t nVBR;\n    uint8_t nRevision = 0x00;\n    uint8_t nRevMethod;\n    uint8_t vbr_type_translator[] = { 1, 5, 3, 2, 4, 0, 3 }; /*numbering different in vbr_mode vs. Lame tag */\n\n    uint8_t nLowpass =\n        (((cfg->lowpassfreq / 100.0) + .5) > 255 ? 255 : (cfg->lowpassfreq / 100.0) + .5);\n\n    uint32_t nPeakSignalAmplitude = 0;\n\n    uint16_t nRadioReplayGain = 0;\n    uint16_t nAudiophileReplayGain = 0;\n\n    uint8_t nNoiseShaping = cfg->noise_shaping;\n    uint8_t nStereoMode = 0;\n    int     bNonOptimal = 0;\n    uint8_t nSourceFreq = 0;\n    uint8_t nMisc = 0;\n    uint16_t nMusicCRC = 0;\n\n    /*psy model type: Gpsycho or NsPsytune */\n    unsigned char bExpNPsyTune = 1; /* only NsPsytune */\n    unsigned char bSafeJoint = (cfg->use_safe_joint_stereo) != 0;\n\n    unsigned char bNoGapMore = 0;\n    unsigned char bNoGapPrevious = 0;\n\n    int     nNoGapCount = gfp->nogap_total;\n    int     nNoGapCurr = gfp->nogap_current;\n\n\n    uint8_t nAthType = cfg->ATHtype; /*4 bits. */\n\n    uint8_t nFlags = 0;\n\n    /* if ABR, {store bitrate <=255} else { store \"-b\"} */\n    int     nABRBitrate;\n    switch (cfg->vbr) {\n    case vbr_abr:{\n            nABRBitrate = cfg->vbr_avg_bitrate_kbps;\n            break;\n        }\n    case vbr_off:{\n            nABRBitrate = cfg->avg_bitrate;\n            break;\n        }\n    default:{          /*vbr modes */\n            nABRBitrate = bitrate_table[cfg->version][cfg->vbr_min_bitrate_index];;\n        }\n    }\n\n\n    /*revision and vbr method */\n    if (cfg->vbr < sizeof(vbr_type_translator))\n        nVBR = vbr_type_translator[cfg->vbr];\n    else\n        nVBR = 0x00;    /*unknown. */\n\n    nRevMethod = 0x10 * nRevision + nVBR;\n\n\n    /* ReplayGain */\n    if (cfg->findReplayGain) {\n        int     RadioGain = gfc->ov_rpg.RadioGain;\n        if (RadioGain > 0x1FE)\n            RadioGain = 0x1FE;\n        if (RadioGain < -0x1FE)\n            RadioGain = -0x1FE;\n\n        nRadioReplayGain = 0x2000; /* set name code */\n        nRadioReplayGain |= 0xC00; /* set originator code to `determined automatically' */\n\n        if (RadioGain >= 0)\n            nRadioReplayGain |= RadioGain; /* set gain adjustment */\n        else {\n            nRadioReplayGain |= 0x200; /* set the sign bit */\n            nRadioReplayGain |= -RadioGain; /* set gain adjustment */\n        }\n    }\n\n    /* peak sample */\n    if (cfg->findPeakSample)\n        nPeakSignalAmplitude =\n            abs((int) ((((FLOAT) gfc->ov_rpg.PeakSample) / 32767.0) * pow(2, 23) + .5));\n\n    /*nogap */\n    if (nNoGapCount != -1) {\n        if (nNoGapCurr > 0)\n            bNoGapPrevious = 1;\n\n        if (nNoGapCurr < nNoGapCount - 1)\n            bNoGapMore = 1;\n    }\n\n    /*flags */\n\n    nFlags = nAthType + (bExpNPsyTune << 4)\n        + (bSafeJoint << 5)\n        + (bNoGapMore << 6)\n        + (bNoGapPrevious << 7);\n\n\n    if (nQuality < 0)\n        nQuality = 0;\n\n    /*stereo mode field... a bit ugly. */\n\n    switch (cfg->mode) {\n    case MONO:\n        nStereoMode = 0;\n        break;\n    case STEREO:\n        nStereoMode = 1;\n        break;\n    case DUAL_CHANNEL:\n        nStereoMode = 2;\n        break;\n    case JOINT_STEREO:\n        if (cfg->force_ms)\n            nStereoMode = 4;\n        else\n            nStereoMode = 3;\n        break;\n    case NOT_SET:\n        /* FALLTHROUGH */\n    default:\n        nStereoMode = 7;\n        break;\n    }\n\n    /*Intensity stereo : nStereoMode = 6. IS is not implemented */\n\n    if (cfg->samplerate_in <= 32000)\n        nSourceFreq = 0x00;\n    else if (cfg->samplerate_in == 48000)\n        nSourceFreq = 0x02;\n    else if (cfg->samplerate_in > 48000)\n        nSourceFreq = 0x03;\n    else\n        nSourceFreq = 0x01; /*default is 44100Hz. */\n\n\n    /*Check if the user overrided the default LAME behaviour with some nasty options */\n\n    if (cfg->short_blocks == short_block_forced || cfg->short_blocks == short_block_dispensed || ((cfg->lowpassfreq == -1) && (cfg->highpassfreq == -1)) || /* \"-k\" */\n        (cfg->disable_reservoir && cfg->avg_bitrate < 320) ||\n        cfg->noATH || cfg->ATHonly || (nAthType == 0) || cfg->samplerate_in <= 32000)\n        bNonOptimal = 1;\n\n    nMisc = nNoiseShaping + (nStereoMode << 2)\n        + (bNonOptimal << 5)\n        + (nSourceFreq << 6);\n\n\n    nMusicCRC = gfc->nMusicCRC;\n\n\n    /*Write all this information into the stream */\n    CreateI4(&pbtStreamBuffer[nBytesWritten], nQuality);\n    nBytesWritten += 4;\n\n    strncpy((char *) &pbtStreamBuffer[nBytesWritten], szVersion, 9);\n    nBytesWritten += 9;\n\n    pbtStreamBuffer[nBytesWritten] = nRevMethod;\n    nBytesWritten++;\n\n    pbtStreamBuffer[nBytesWritten] = nLowpass;\n    nBytesWritten++;\n\n    CreateI4(&pbtStreamBuffer[nBytesWritten], nPeakSignalAmplitude);\n    nBytesWritten += 4;\n\n    CreateI2(&pbtStreamBuffer[nBytesWritten], nRadioReplayGain);\n    nBytesWritten += 2;\n\n    CreateI2(&pbtStreamBuffer[nBytesWritten], nAudiophileReplayGain);\n    nBytesWritten += 2;\n\n    pbtStreamBuffer[nBytesWritten] = nFlags;\n    nBytesWritten++;\n\n    if (nABRBitrate >= 255)\n        pbtStreamBuffer[nBytesWritten] = 0xFF;\n    else\n        pbtStreamBuffer[nBytesWritten] = nABRBitrate;\n    nBytesWritten++;\n\n    pbtStreamBuffer[nBytesWritten] = enc_delay >> 4; /* works for win32, does it for unix? */\n    pbtStreamBuffer[nBytesWritten + 1] = (enc_delay << 4) + (enc_padding >> 8);\n    pbtStreamBuffer[nBytesWritten + 2] = enc_padding;\n\n    nBytesWritten += 3;\n\n    pbtStreamBuffer[nBytesWritten] = nMisc;\n    nBytesWritten++;\n\n\n    pbtStreamBuffer[nBytesWritten++] = 0; /*unused in rev0 */\n\n    CreateI2(&pbtStreamBuffer[nBytesWritten], cfg->preset);\n    nBytesWritten += 2;\n\n    CreateI4(&pbtStreamBuffer[nBytesWritten], (int) nMusicLength);\n    nBytesWritten += 4;\n\n    CreateI2(&pbtStreamBuffer[nBytesWritten], nMusicCRC);\n    nBytesWritten += 2;\n\n    /*Calculate tag CRC.... must be done here, since it includes\n     *previous information*/\n\n    for (i = 0; i < nBytesWritten; i++)\n        crc = CRC_update_lookup(pbtStreamBuffer[i], crc);\n\n    CreateI2(&pbtStreamBuffer[nBytesWritten], crc);\n    nBytesWritten += 2;\n\n    return nBytesWritten;\n}", "path": "OBS/lame/libmp3lame/VbrTag.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* fast CRC-16 computation - uses table crc16_lookup 8*/\n", "func_signal": "static uint16_t\nCRC_update_lookup(uint16_t value, uint16_t crc)", "code": "{\n    uint16_t tmp;\n    tmp = crc ^ value;\n    crc = (crc >> 8) ^ crc16_lookup[tmp & 0xff];\n    return crc;\n}", "path": "OBS/lame/libmp3lame/VbrTag.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/*those ATH formulas are returning\ntheir minimum value for input = -1*/\n", "func_signal": "static  FLOAT\nATHformula_GB(FLOAT f, FLOAT value, FLOAT f_min, FLOAT f_max)", "code": "{\n    /* from Painter & Spanias\n       modified by Gabriel Bouvigne to better fit the reality\n       ath =    3.640 * pow(f,-0.8)\n       - 6.800 * exp(-0.6*pow(f-3.4,2.0))\n       + 6.000 * exp(-0.15*pow(f-8.7,2.0))\n       + 0.6* 0.001 * pow(f,4.0);\n\n\n       In the past LAME was using the Painter &Spanias formula.\n       But we had some recurrent problems with HF content.\n       We measured real ATH values, and found the older formula\n       to be inacurate in the higher part. So we made this new\n       formula and this solved most of HF problematic testcases.\n       The tradeoff is that in VBR mode it increases a lot the\n       bitrate. */\n\n\n/*this curve can be udjusted according to the VBR scale:\nit adjusts from something close to Painter & Spanias\non V9 up to Bouvigne's formula for V0. This way the VBR\nbitrate is more balanced according to the -V value.*/\n\n    FLOAT   ath;\n\n    /* the following Hack allows to ask for the lowest value */\n    if (f < -.3)\n        f = 3410;\n\n    f /= 1000;          /* convert to khz */\n    f = Max(f_min, f);\n    f = Min(f_max, f);\n\n    ath = 3.640 * pow(f, -0.8)\n        - 6.800 * exp(-0.6 * pow(f - 3.4, 2.0))\n        + 6.000 * exp(-0.15 * pow(f - 8.7, 2.0))\n        + (0.6 + 0.04 * value) * 0.001 * pow(f, 4.0);\n    return ath;\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* convert samp freq in Hz to index */\n", "func_signal": "int\nSmpFrqIndex(int sample_freq, int *const version)", "code": "{\n    switch (sample_freq) {\n    case 44100:\n        *version = 1;\n        return 0;\n    case 48000:\n        *version = 1;\n        return 1;\n    case 32000:\n        *version = 1;\n        return 2;\n    case 22050:\n        *version = 0;\n        return 0;\n    case 24000:\n        *version = 0;\n        return 1;\n    case 16000:\n        *version = 0;\n        return 2;\n    case 11025:\n        *version = 0;\n        return 0;\n    case 12000:\n        *version = 0;\n        return 1;\n    case 8000:\n        *version = 0;\n        return 2;\n    default:\n        *version = 0;\n        return -1;\n    }\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/*-------------------------------------------------------------*/\n/* Same as GetVbrTag below, but only checks for the Xing tag.\n   requires buf to contain only 40 bytes */\n/*-------------------------------------------------------------*/\n", "func_signal": "int\nCheckVbrTag(unsigned char *buf)", "code": "{\n    int     h_id, h_mode;\n\n    /* get selected MPEG header data */\n    h_id = (buf[1] >> 3) & 1;\n    h_mode = (buf[3] >> 6) & 3;\n\n    /*  determine offset of header */\n    if (h_id) {\n        /* mpeg1 */\n        if (h_mode != 3)\n            buf += (32 + 4);\n        else\n            buf += (17 + 4);\n    }\n    else {\n        /* mpeg2 */\n        if (h_mode != 3)\n            buf += (17 + 4);\n        else\n            buf += (9 + 4);\n    }\n\n    return IsVbrTag(buf);\n}", "path": "OBS/lame/libmp3lame/VbrTag.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/*\n *\n * User-callable function to allocate all necessary storage space for the fft.\n *\n * The return value is a contiguous block of memory, allocated with malloc.  As such,\n * It can be freed with free(), rather than a kiss_fft-specific function.\n * */\n", "func_signal": "kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem )", "code": "{\n    kiss_fft_cfg st=NULL;\n    size_t memneeded = sizeof(struct kiss_fft_state)\n        + sizeof(kiss_fft_cpx)*(nfft-1); /* twiddle factors*/\n\n    if ( lenmem==NULL ) {\n        st = ( kiss_fft_cfg)malloc( memneeded );\n    }else{\n        if (*lenmem >= memneeded)\n            st = (kiss_fft_cfg)mem;\n        *lenmem = memneeded;\n    }\n    if (st) {\n        int i;\n        const double pi=3.14159265358979323846264338327;\n        const double phase0 = -2.0 * pi / (double)( nfft );\n\n        st->nfft=nfft;\n        st->inverse = inverse_fft;\n\n        for (i=0;i<nfft;++i) {\n            double phase = phase0 * i;\n            if (st->inverse)\n                phase *= -1;\n            kf_cexp(st->twiddles+i, phase );\n        }\n\n        kf_factor(nfft,st->factors);\n    }\n    return st;\n}", "path": "OBS/libfaac/kiss_fft/kiss_fft.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/***********************************************************************\n *\n * PutVbrTag: Write final VBR tag to the file\n * Paramters:\n *                              lpszFileName: filename of MP3 bit stream\n *                              nVbrScale       : encoder quality indicator (0..100)\n ****************************************************************************\n */\n", "func_signal": "int\nPutVbrTag(lame_global_flags const *gfp, FILE * fpStream)", "code": "{\n    lame_internal_flags *gfc = gfp->internal_flags;\n\n    long    lFileSize;\n    long    id3v2TagSize;\n    size_t  nbytes;\n    uint8_t buffer[MAXFRAMESIZE];\n\n    if (gfc->VBR_seek_table.pos <= 0)\n        return -1;\n\n    /* Seek to end of file */\n    fseek(fpStream, 0, SEEK_END);\n\n    /* Get file size */\n    lFileSize = ftell(fpStream);\n\n    /* Abort if file has zero length. Yes, it can happen :) */\n    if (lFileSize == 0)\n        return -1;\n\n    /*\n     * The VBR tag may NOT be located at the beginning of the stream.\n     * If an ID3 version 2 tag was added, then it must be skipped to write\n     * the VBR tag data.\n     */\n\n    id3v2TagSize = skipId3v2(fpStream);\n\n    if (id3v2TagSize < 0) {\n        return id3v2TagSize;\n    }\n\n    /*Seek to the beginning of the stream */\n    fseek(fpStream, id3v2TagSize, SEEK_SET);\n\n    nbytes = lame_get_lametag_frame(gfp, buffer, sizeof(buffer));\n    if (nbytes > sizeof(buffer)) {\n        return -1;\n    }\n\n    if (nbytes < 1) {\n        return 0;\n    }\n\n    /* Put it all to disk again */\n    if (fwrite(buffer, nbytes, 1, fpStream) != 1) {\n        return -1;\n    }\n\n    return 0;           /* success */\n}", "path": "OBS/lame/libmp3lame/VbrTag.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/*  facbuf is populated by p1,m1,p2,m2, ...\n    where \n    p[i] * m[i] = m[i-1]\n    m0 = n                  */\n", "func_signal": "static \nvoid kf_factor(int n,int * facbuf)", "code": "{\n    int p=4;\n    double floor_sqrt;\n    floor_sqrt = floor( sqrt((double)n) );\n\n    /*factor out powers of 4, powers of 2, then any remaining primes */\n    do {\n        while (n % p) {\n            switch (p) {\n                case 4: p = 2; break;\n                case 2: p = 3; break;\n                default: p += 2; break;\n            }\n            if (p > floor_sqrt)\n                p = n;          /* no more factors, skip to end */\n        }\n        n /= p;\n        *facbuf++ = p;\n        *facbuf++ = n;\n    } while (n > 1);\n}", "path": "OBS/libfaac/kiss_fft/kiss_fft.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* Do psychoacoustical analysis */\n", "func_signal": "static void PsyCalculate(ChannelInfo * channelInfo, GlobalPsyInfo * gpsyInfo,\n\t\t\t PsyInfo * psyInfo, int *cb_width_long, int\n\t\t\t num_cb_long, int *cb_width_short,\n\t\t\t int num_cb_short, unsigned int numChannels)", "code": "{\n  unsigned int channel;\n\n  for (channel = 0; channel < numChannels; channel++)\n  {\n    if (channelInfo[channel].present)\n    {\n\n      if (channelInfo[channel].cpe &&\n\t  channelInfo[channel].ch_is_left)\n      {\t\t\t\t/* CPE */\n\n\tint leftChan = channel;\n\tint rightChan = channelInfo[channel].paired_ch;\n\n\tPsyCheckShort(&psyInfo[leftChan]);\n\tPsyCheckShort(&psyInfo[rightChan]);\n      }\n      else if (!channelInfo[channel].cpe &&\n\t       channelInfo[channel].lfe)\n      {\t\t\t\t/* LFE */\n        // Only set block type and it should be OK\n\tpsyInfo[channel].block_type = ONLY_LONG_WINDOW;\n      }\n      else if (!channelInfo[channel].cpe)\n      {\t\t\t\t/* SCE */\n\tPsyCheckShort(&psyInfo[channel]);\n      }\n    }\n  }\n}", "path": "OBS/libfaac/psychkni.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* Used to find table index when\n * we need bitrate-based values\n * determined using tables\n *\n * bitrate in kbps\n *\n * Gabriel Bouvigne 2002-11-03\n */\n", "func_signal": "int\nnearestBitrateFullIndex(uint16_t bitrate)", "code": "{\n    /* borrowed from DM abr presets */\n\n    const int full_bitrate_table[] =\n        { 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320 };\n\n\n    int     lower_range = 0, lower_range_kbps = 0, upper_range = 0, upper_range_kbps = 0;\n\n\n    int     b;\n\n\n    /* We assume specified bitrate will be 320kbps */\n    upper_range_kbps = full_bitrate_table[16];\n    upper_range = 16;\n    lower_range_kbps = full_bitrate_table[16];\n    lower_range = 16;\n\n    /* Determine which significant bitrates the value specified falls between,\n     * if loop ends without breaking then we were correct above that the value was 320\n     */\n    for (b = 0; b < 16; b++) {\n        if ((Max(bitrate, full_bitrate_table[b + 1])) != bitrate) {\n            upper_range_kbps = full_bitrate_table[b + 1];\n            upper_range = b + 1;\n            lower_range_kbps = full_bitrate_table[b];\n            lower_range = (b);\n            break;      /* We found upper range */\n        }\n    }\n\n    /* Determine which range the value specified is closer to */\n    if ((upper_range_kbps - bitrate) > (bitrate - lower_range_kbps)) {\n        return lower_range;\n    }\n    return upper_range;\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/***********************************************************************\n *  Robert Hegemann 2001-01-17\n ***********************************************************************/\n", "func_signal": "static void\naddVbr(VBR_seek_info_t * v, int bitrate)", "code": "{\n    int     i;\n\n    v->nVbrNumFrames++;\n    v->sum += bitrate;\n    v->seen++;\n\n    if (v->seen < v->want) {\n        return;\n    }\n\n    if (v->pos < v->size) {\n        v->bag[v->pos] = v->sum;\n        v->pos++;\n        v->seen = 0;\n    }\n    if (v->pos == v->size) {\n        for (i = 1; i < v->size; i += 2) {\n            v->bag[i / 2] = v->bag[i];\n        }\n        v->want *= 2;\n        v->pos /= 2;\n    }\n}", "path": "OBS/lame/libmp3lame/VbrTag.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* see for example \"Zwicker: Psychoakustik, 1982; ISBN 3-540-11401-7 */\n", "func_signal": "FLOAT\nfreq2bark(FLOAT freq)", "code": "{\n    /* input: freq in hz  output: barks */\n    if (freq < 0)\n        freq = 0;\n    freq = freq * 0.001;\n    return 13.0 * atan(.76 * freq) + 3.5 * atan(freq * freq / (7.5 * 7.5));\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* see for example \"Zwicker: Psychoakustik, 1982; ISBN 3-540-11401-7 */\n", "func_signal": "FLOAT\nfreq2cbw(FLOAT freq)", "code": "{\n    /* input: freq in hz  output: critical band width */\n    freq = freq * 0.001;\n    return 25 + 75 * pow(1 + 1.4 * (freq * freq), 0.69);\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* map frequency to a valid MP3 sample frequency\n *\n * Robert Hegemann 2000-07-01\n */\n", "func_signal": "int\nmap2MP3Frequency(int freq)", "code": "{\n    if (freq <= 8000)\n        return 8000;\n    if (freq <= 11025)\n        return 11025;\n    if (freq <= 12000)\n        return 12000;\n    if (freq <= 16000)\n        return 16000;\n    if (freq <= 22050)\n        return 22050;\n    if (freq <= 24000)\n        return 24000;\n    if (freq <= 32000)\n        return 32000;\n    if (freq <= 44100)\n        return 44100;\n\n    return 48000;\n}", "path": "OBS/lame/libmp3lame/util.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* perform the butterfly for one stage of a mixed radix FFT */\n", "func_signal": "static void kf_bfly_generic(\n        kiss_fft_cpx * Fout,\n        const size_t fstride,\n        const kiss_fft_cfg st,\n        int m,\n        int p\n        )", "code": "{\n    int u,k,q1,q;\n    kiss_fft_cpx * twiddles = st->twiddles;\n    kiss_fft_cpx t;\n    int Norig = st->nfft;\n    \n    kiss_fft_cpx *scratchbuf=(kiss_fft_cpx *)malloc( sizeof(kiss_fft_cpx) * p );\n\n    for ( u=0; u<m; ++u ) {\n        k=u;\n        for ( q1=0 ; q1<p ; ++q1 ) {\n            scratchbuf[q1] = Fout[ k  ];\n            C_FIXDIV(scratchbuf[q1],p);\n            k += m;\n        }\n\n        k=u;\n        for ( q1=0 ; q1<p ; ++q1 ) {\n            int twidx=0;\n            Fout[ k ] = scratchbuf[0];\n            for (q=1;q<p;++q ) {\n                twidx += fstride * k;\n                if (twidx>=Norig) twidx-=Norig;\n                C_MUL(t,scratchbuf[q] , twiddles[twidx] );\n                C_ADDTO( Fout[ k ] ,t);\n            }\n            k += m;\n        }\n    }\n\n    free( scratchbuf );\n}", "path": "OBS/libfaac/kiss_fft/kiss_fft.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/* check for magic strings*/\n", "func_signal": "static int\nIsVbrTag(const unsigned char *buf)", "code": "{\n    int     isTag0, isTag1;\n\n    isTag0 = ((buf[0] == VBRTag0[0]) && (buf[1] == VBRTag0[1]) && (buf[2] == VBRTag0[2])\n              && (buf[3] == VBRTag0[3]));\n    isTag1 = ((buf[0] == VBRTag1[0]) && (buf[1] == VBRTag1[1]) && (buf[2] == VBRTag1[2])\n              && (buf[3] == VBRTag1[3]));\n\n    return (isTag0 || isTag1);\n}", "path": "OBS/lame/libmp3lame/VbrTag.c", "commit_date": "2012-08-31 00:00:00", "repo_name": "jp9000/OBS", "stars": 3390, "license": "gpl-2.0", "language": "c", "size": 50128}
{"docstring": "/**\n * @brief       Writes data to the USB FIFO\n * @param       fifoNum\n *              USB Endpoint FIFO to write\n * @param       numBytes\n *              Number of bytes to write to the FIFO\n * @param       dat\n *              Pointer to buffer hoding data to write to the FIFO\n * @param       txPacket\n *              If TRUE, the packet will be sent immediately after loading the\n *              FIFO\n *              If FALSE, the packet will be stored in the FIFO and the\n *              transmission must be started at a later time\n ******************************************************************************/\n", "func_signal": "void USB_WriteFIFO(uint8_t fifoNum, uint8_t numBytes, uint8_t *dat, bool txPacket)", "code": "{\n  USB_EnableWriteFIFO(fifoNum);\n\n  // Convert generic pointer to memory-specific pointer and call the\n  // the corresponding memory-specific function, if possible.\n  // The memory-specific functions are much faster than the generic functions.\n#ifdef SI_GPTR\n\n  switch (((SI_GEN_PTR_t *)&dat)->gptr.memtype)\n  {\n    case SI_GPTR_MTYPE_IDATA:\n      USB_WriteFIFO_Idata(numBytes, dat);\n      break;\n\n    // For some compilers, IDATA and DATA are treated the same.\n    // Only call the USB_WriteFIFO_Data() if the compiler differentiates between\n    // DATA and IDATA.\n#if (SI_GPTR_MTYPE_DATA != SI_GPTR_MTYPE_IDATA)\n    case SI_GPTR_MTYPE_DATA:\n      USB_WriteFIFO_Data(numBytes, dat);\n      break;\n#endif\n\n    case SI_GPTR_MTYPE_XDATA:\n      USB_WriteFIFO_Xdata(numBytes, dat);\n      break;\n\n    // For some compilers, XDATA and PDATA are treated the same.\n    // Only call the USB_WriteFIFO_Pdata() if the compiler differentiates\n    // between XDATA and PDATA.\n#if (SI_GPTR_MTYPE_PDATA != SI_GPTR_MTYPE_XDATA)\n    case SI_GPTR_MTYPE_PDATA:\n      USB_WriteFIFO_Pdata(numBytes, dat);\n      break;\n#endif\n\n    case SI_GPTR_MTYPE_CODE:\n      USB_WriteFIFO_Code(numBytes, dat);\n      break;\n\n    default:\n      break;\n  }\n\n#else\n  USB_WriteFIFO_Generic(numBytes, dat);\n#endif  // #ifdef SI_GPTR\n\n  USB_DisableWriteFIFO(fifoNum);\n\n  if ((txPacket == true) && (fifoNum > 0))\n  {\n    USB_SetIndex(fifoNum);\n    USB_EpnSetInPacketReady();\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Writes data held in DRAM to the USB FIFO\n * @details     The FIFO to write must be set before calling the function with\n *              @ref USB_EnableWriteFIFO().\n * @param       numBytes\n *              Number of bytes to write to the FIFO\n * @param       dat\n *              Pointer to DATA buffer to hold data read from the FIFO\n ******************************************************************************/\n", "func_signal": "static void USB_WriteFIFO_Data(uint8_t numBytes, SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_DATA))", "code": "{\n  while (numBytes--)\n  {\n    USB_SetFIFOByte(*dat);\n    dat++;\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Handle Endpoint 2 IN transfer interrupt\n * @note        This function takes no parameters, but it uses the EP2IN status\n *              variables stored in @ref myUsbDevice.ep2in.\n ******************************************************************************/\n", "func_signal": "void handleUsbIn2Int(void)", "code": "{\n  uint8_t xferred;\n  bool callback;\n\n  USB_SetIndex(2);\n\n  if (USB_EpnInGetSentStall())\n  {\n    USB_EpnInClearSentStall();\n  }\n  else if (myUsbDevice.ep2in.state == D_EP_TRANSMITTING)\n  {\n    xferred = (myUsbDevice.ep2in.remaining > SLAB_USB_EP2IN_MAX_PACKET_SIZE)\n              ? SLAB_USB_EP2IN_MAX_PACKET_SIZE : myUsbDevice.ep2in.remaining;\n    myUsbDevice.ep2in.remaining -= xferred;\n    myUsbDevice.ep2in.buf += xferred;\n\n    callback = myUsbDevice.ep2in.misc.bits.callback;\n\n    // Load more data\n    if (myUsbDevice.ep2in.remaining > 0)\n    {\n      USB_WriteFIFO(2,\n                    (myUsbDevice.ep2in.remaining > SLAB_USB_EP2IN_MAX_PACKET_SIZE)\n                      ? SLAB_USB_EP2IN_MAX_PACKET_SIZE\n                      : myUsbDevice.ep2in.remaining,\n                    myUsbDevice.ep2in.buf,\n                    true);\n    }\n    else\n    {\n      myUsbDevice.ep2in.misc.bits.callback = false;\n      myUsbDevice.ep2in.state = D_EP_IDLE;\n    }\n\n    if (callback == true)\n    {\n      USBD_XferCompleteCb(EP2IN, USB_STATUS_OK, xferred, myUsbDevice.ep2in.remaining);\n    }\n\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Reads data from the USB FIFO to a buffer in XRAM\n * @param       numBytes\n *              Number of bytes to read from the FIFO\n * @param       dat\n *              Pointer to XDATA buffer to hold data read from the FIFO\n * @param       fifoNum\n *              USB FIFO to read\n ******************************************************************************/\n", "func_signal": "static void USB_ReadFIFO_Xdata(uint8_t numBytes, SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_XDATA), uint8_t fifoNum)", "code": "{\n  while (--numBytes)\n  {\n    USB_GetFIFOByte(*dat);\n    dat++;\n  }\n  USB_GetLastFIFOByte(*dat, fifoNum);\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Reads data from the USB FIFO to a buffer in generic memory space\n * @param       numBytes\n *              Number of bytes to read from the FIFO\n * @param       dat\n *              Pointer to generic buffer to hold data read from the FIFO\n * @param       fifoNum\n *              USB FIFO to read\n ******************************************************************************/\n", "func_signal": "static void USB_ReadFIFO_Generic(uint8_t numBytes, uint8_t *dat, uint8_t fifoNum)", "code": "{\n  while (--numBytes)\n  {\n    USB_GetFIFOByte(*dat);\n    dat++;\n  }\n  USB_GetLastFIFOByte(*dat, fifoNum);\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Handle Endpoint 2 OUT transfer interrupt\n * @note        This function takes no parameters, but it uses the EP2OUT status\n *              variables stored in @ref myUsbDevice.ep2out.\n ******************************************************************************/\n", "func_signal": "void handleUsbOut2Int(void)", "code": "{\n  uint8_t count;\n\n  USB_Status_TypeDef status;\n  bool xferComplete = false;\n\n  USB_SetIndex(2);\n\n  if (USB_EpnOutGetSentStall())\n  {\n    USB_EpnOutClearSentStall();\n  }\n  else if (USB_EpnGetOutPacketReady())\n  {\n    count = USB_EpOutGetCount();\n\n    // If USBD_Read() has not been called, return an error\n    if (myUsbDevice.ep2out.state != D_EP_RECEIVING)\n    {\n      myUsbDevice.ep2out.misc.bits.outPacketPending = true;\n      status = USB_STATUS_EP_ERROR;\n    }\n    // Check for overrun of user buffer\n    else if (myUsbDevice.ep2out.remaining < count)\n    {\n      myUsbDevice.ep2out.state = D_EP_IDLE;\n      myUsbDevice.ep2out.misc.bits.outPacketPending = true;\n      status = USB_STATUS_EP_RX_BUFFER_OVERRUN;\n    }\n    else\n    {\n      USB_ReadFIFO(2, count, myUsbDevice.ep2out.buf);\n\n      myUsbDevice.ep2out.misc.bits.outPacketPending = false;\n      myUsbDevice.ep2out.remaining -= count;\n      myUsbDevice.ep2out.buf += count;\n\n      if ((myUsbDevice.ep2out.remaining == 0) || (count != SLAB_USB_EP2OUT_MAX_PACKET_SIZE))\n      {\n        myUsbDevice.ep2out.state = D_EP_IDLE;\n        xferComplete = true;\n      }\n\n      status = USB_STATUS_OK;\n      USB_EpnClearOutPacketReady();\n    }\n    if (myUsbDevice.ep2out.misc.bits.callback == true)\n    {\n      if (xferComplete == true)\n      {\n        myUsbDevice.ep2out.misc.bits.callback = false;\n      }\n\n      USBD_XferCompleteCb(EP2OUT, status, count, myUsbDevice.ep2out.remaining);\n    }\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Handle Endpoint 3 IN transfer interrupt\n * @details     Endpoint 3 IN is the only IN endpoint that supports isochronous\n *              transfers.\n * @note        This function takes no parameters, but it uses the EP3IN status\n *              variables stored in @ref myUsbDevice.ep3in.\n ******************************************************************************/\n", "func_signal": "void handleUsbIn3Int(void)", "code": "{\n#if SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_ISOC\n  uint16_t xferred, nextIdx;\n#else\n  uint8_t xferred;\n  bool callback;\n#endif\n\n  USB_SetIndex(3);\n\n  if (USB_EpnInGetSentStall())\n  {\n    USB_EpnInClearSentStall();\n  }\n  else if (myUsbDevice.ep3in.state == D_EP_TRANSMITTING)\n  {\n#if  ((SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_BULK) || (SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_INTR))\n    xferred = (myUsbDevice.ep3in.remaining > SLAB_USB_EP3IN_MAX_PACKET_SIZE)\n              ? SLAB_USB_EP3IN_MAX_PACKET_SIZE : myUsbDevice.ep3in.remaining;\n    myUsbDevice.ep3in.remaining -= xferred;\n    myUsbDevice.ep3in.buf += xferred;\n#endif\n\n#if  ((SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_BULK) || (SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_INTR))\n\n    callback = myUsbDevice.ep3in.misc.bits.callback;\n\n#elif (SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_ISOC)\n    if (myUsbDevice.ep3in.misc.bits.callback == true)\n    {\n      // In Isochronous mode, the meaning of the USBD_XferCompleteCb parameters changes:\n      //   xferred is ignored\n      //   remaining is the current index into the circular buffer\n      //   the return value is the number of bytes to transmit in the next packet\n      xferred = USBD_XferCompleteCb(EP3IN, USB_STATUS_OK, 0, myUsbDevice.ep3inIsoIdx);\n      if (xferred == 0)\n      {\n        myUsbDevice.ep3in.misc.bits.inPacketPending = true;\n        return;\n      }\n    }\n#endif\n    // Load more data\n#if  ((SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_BULK) || (SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_INTR))\n    if (myUsbDevice.ep3in.remaining > 0)\n    {\n      USB_WriteFIFO(3,\n                    (myUsbDevice.ep3in.remaining > SLAB_USB_EP3IN_MAX_PACKET_SIZE)\n                      ? SLAB_USB_EP3IN_MAX_PACKET_SIZE\n                      : myUsbDevice.ep3in.remaining,\n                    myUsbDevice.ep3in.buf,\n                    true);\n    }\n    else\n    {\n      myUsbDevice.ep3in.misc.bits.callback = false;\n      myUsbDevice.ep3in.state = D_EP_IDLE;\n    }\n\n    if (callback == true)\n    {\n      USBD_XferCompleteCb(EP3IN, USB_STATUS_OK, xferred, myUsbDevice.ep3in.remaining);\n    }\n#elif (SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_ISOC)\n    nextIdx = xferred + myUsbDevice.ep3inIsoIdx;\n    myUsbDevice.ep3in.misc.bits.inPacketPending = false;\n\n    // Check if the next index is past the end of the circular buffer.\n    // If so, break the write up into two calls to USB_WriteFIFOIso()\n    if (nextIdx > myUsbDevice.ep3in.remaining)\n    {\n      USB_WriteFIFOIso(3, myUsbDevice.ep3in.remaining - myUsbDevice.ep3inIsoIdx, &myUsbDevice.ep3in.buf[myUsbDevice.ep3inIsoIdx]);\n      myUsbDevice.ep3inIsoIdx = nextIdx - myUsbDevice.ep3in.remaining;\n      USB_WriteFIFOIso(3, myUsbDevice.ep3inIsoIdx, myUsbDevice.ep3in.buf);\n    }\n    else\n    {\n      USB_WriteFIFOIso(3, xferred, &myUsbDevice.ep3in.buf[myUsbDevice.ep3inIsoIdx]);\n      myUsbDevice.ep3inIsoIdx = nextIdx;\n    }\n#endif // ( ( SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_BULK ) || ( SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_INTR ) )\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Writes data held in XRAM to the USB FIFO\n * @details     The FIFO to write must be set before calling the function with\n *              @ref USB_EnableWriteFIFO().\n * @param       numBytes\n *              Number of bytes to write to the FIFO\n * @param       dat\n *              Pointer to XDATA buffer holding data to write to the FIFO\n ******************************************************************************/\n", "func_signal": "static void USB_WriteFIFO_Xdata(uint8_t numBytes, SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_XDATA))", "code": "{\n  while (numBytes--)\n  {\n    USB_SetFIFOByte(*dat);\n    dat++;\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Handle Endpoint 1 IN transfer interrupt\n * @note        This function takes no parameters, but it uses the EP1IN status\n *              variables stored in @ref myUsbDevice.ep1in.\n ******************************************************************************/\n", "func_signal": "void handleUsbIn1Int(void)", "code": "{\n  uint8_t xferred;\n  bool callback;\n\n  USB_SetIndex(1);\n\n  if (USB_EpnInGetSentStall())\n  {\n    USB_EpnInClearSentStall();\n  }\n  else if (myUsbDevice.ep1in.state == D_EP_TRANSMITTING)\n  {\n    xferred = (myUsbDevice.ep1in.remaining > SLAB_USB_EP1IN_MAX_PACKET_SIZE)\n              ? SLAB_USB_EP1IN_MAX_PACKET_SIZE : myUsbDevice.ep1in.remaining;\n    myUsbDevice.ep1in.remaining -= xferred;\n    myUsbDevice.ep1in.buf += xferred;\n\n    callback = myUsbDevice.ep1in.misc.bits.callback;\n\n    // Load more data\n    if (myUsbDevice.ep1in.remaining > 0)\n    {\n      USB_WriteFIFO(1,\n                    (myUsbDevice.ep1in.remaining > SLAB_USB_EP1IN_MAX_PACKET_SIZE)\n                      ? SLAB_USB_EP1IN_MAX_PACKET_SIZE\n                      : myUsbDevice.ep1in.remaining,\n                    myUsbDevice.ep1in.buf,\n                    true);\n    }\n    else\n    {\n      myUsbDevice.ep1in.misc.bits.callback = false;\n      myUsbDevice.ep1in.state = D_EP_IDLE;\n    }\n\n    if (callback == true)\n    {\n      USBD_XferCompleteCb(EP1IN, USB_STATUS_OK, xferred, myUsbDevice.ep1in.remaining);\n    }\n\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "// ----------------------------------------------------------------------------\n// If Isochronous mode is enabled and the max packet size is greater than 255,\n// break the FIFO reads up into multiple reads of 255 or less bytes.\n// ----------------------------------------------------------------------------\n", "func_signal": "void USB_ReadFIFOIso(uint8_t fifoNum, uint16_t numBytes, uint8_t *dat)", "code": "{\n  uint8_t numBytesRead;\n\n  // USB_ReadFIFO() accepts a maximum of 255 bytes. If the number of bytes to\n  // send is greated than 255, call USB_ReadFIFO() multiple times.\n  while (numBytes > 0)\n  {\n    numBytesRead = (numBytes > 255) ? 255 : numBytes;\n    USB_ReadFIFO(fifoNum, numBytesRead, dat);\n    numBytes -= numBytesRead;\n    dat += numBytesRead;\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Writes data held in generic memory space to the USB FIFO\n * @details     The FIFO to write must be set before calling the function with\n *              @ref USB_EnableWriteFIFO().\n * @param       numBytes\n *              Number of bytes to write to the FIFO\n * @param       dat\n *              Pointer to generic buffer holding data to write to the FIFO\n ******************************************************************************/\n", "func_signal": "static void USB_WriteFIFO_Generic(uint8_t numBytes, uint8_t *dat)", "code": "{\n  while (numBytes--)\n  {\n    USB_SetFIFOByte(*dat);\n    dat++;\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Handle Endpoint 3 OUT transfer interrupt\n * @details     Endpoint 3 OUT is the only OUT endpoint that supports\n *              isochronous transfers.\n * @note        This function takes no parameters, but it uses the EP3OUT status\n *              variables stored in @ref myUsbDevice.ep3out.\n ******************************************************************************/\n", "func_signal": "void handleUsbOut3Int(void)", "code": "{\n#if (SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_ISOC)\n  uint16_t nextIdx;\n#if (SLAB_USB_EP3OUT_MAX_PACKET_SIZE > 255)\n  uint16_t count;\n#else\n  uint8_t count;\n#endif // ( SLAB_USB_EP3OUT_MAX_PACKET_SIZE > 255 )\n#else\n  uint8_t count;\n#endif // ( SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_ISOC )\n\n  USB_Status_TypeDef status;\n  bool xferComplete = false;\n\n  USB_SetIndex(3);\n\n  if (USB_EpnOutGetSentStall())\n  {\n    USB_EpnOutClearSentStall();\n  }\n  else if (USB_EpnGetOutPacketReady())\n  {\n    count = USB_EpOutGetCount();\n\n    // If USBD_Read() has not been called, return an error\n    if (myUsbDevice.ep3out.state != D_EP_RECEIVING)\n    {\n      myUsbDevice.ep3out.misc.bits.outPacketPending = true;\n      status = USB_STATUS_EP_ERROR;\n    }\n#if  ((SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_BULK) || (SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_INTR))\n    // Check for overrun of user buffer\n    else if (myUsbDevice.ep3out.remaining < count)\n    {\n      myUsbDevice.ep3out.state = D_EP_IDLE;\n      myUsbDevice.ep3out.misc.bits.outPacketPending = true;\n      status = USB_STATUS_EP_RX_BUFFER_OVERRUN;\n    }\n#endif\n    else\n    {\n#if  ((SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_BULK) || (SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_INTR))\n      USB_ReadFIFO(3, count, myUsbDevice.ep3out.buf);\n\n      myUsbDevice.ep3out.remaining -= count;\n      myUsbDevice.ep3out.buf += count;\n\n      if ((myUsbDevice.ep3out.remaining == 0) || (count != SLAB_USB_EP3OUT_MAX_PACKET_SIZE))\n      {\n        myUsbDevice.ep3out.state = D_EP_IDLE;\n        xferComplete = true;\n      }\n#elif (SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_ISOC)\n      nextIdx = count + myUsbDevice.ep3outIsoIdx;\n\n      // In isochronous mode, a circular buffer is used to hold the data\n      // If the next index into the circular buffer passes the end of the\n      // buffer, make two calls to USB_ReadFIFOIso()\n      if (nextIdx > myUsbDevice.ep3out.remaining)\n      {\n        USB_ReadFIFOIso(3, myUsbDevice.ep3out.remaining - myUsbDevice.ep3outIsoIdx, &myUsbDevice.ep3out.buf[myUsbDevice.ep3outIsoIdx]);\n        myUsbDevice.ep3outIsoIdx = nextIdx - myUsbDevice.ep3out.remaining;\n        USB_ReadFIFOIso(3, myUsbDevice.ep3outIsoIdx, myUsbDevice.ep3out.buf);\n      }\n      else\n      {\n        USB_ReadFIFOIso(3, count, &myUsbDevice.ep3out.buf[myUsbDevice.ep3outIsoIdx]);\n        myUsbDevice.ep3outIsoIdx = nextIdx;\n      }\n#endif // ( ( SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_BULK ) || ( SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_INTR ) )\n\n      myUsbDevice.ep3out.misc.bits.outPacketPending = false;\n      status = USB_STATUS_OK;\n      USB_EpnClearOutPacketReady();\n    }\n    if (myUsbDevice.ep3out.misc.bits.callback == true)\n    {\n      if (xferComplete == true)\n      {\n        myUsbDevice.ep3out.misc.bits.callback = false;\n      }\n\n#if  ((SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_BULK) || (SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_INTR))\n      USBD_XferCompleteCb(EP3OUT, status, count, myUsbDevice.ep3out.remaining);\n#elif (SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_ISOC)\n\n      // In Isochronous mode, the meaning of the USBD_XferCompleteCb parameters changes:\n      //   xferred is the number of bytes received in the last packet\n      //   remaining is the current index into the circular buffer\n      USBD_XferCompleteCb(EP3OUT, status, count, myUsbDevice.ep3outIsoIdx);\n#endif\n    }\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Writes data held in paged XRAM to the USB FIFO\n * @details     The FIFO to write must be set before calling the function with\n *              @ref USB_EnableWriteFIFO().\n * @param       numBytes\n *              Number of bytes to write to the FIFO\n * @param       dat\n *              Pointer to PDATA buffer holding data to write to the FIFO\n ******************************************************************************/\n", "func_signal": "static void USB_WriteFIFO_Pdata(uint8_t numBytes, SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_PDATA))", "code": "{\n  while (numBytes--)\n  {\n    USB_SetFIFOByte(*dat);\n    dat++;\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Reads data from the USB FIFO to a buffer in IRAM\n * @param       numBytes\n *              Number of bytes to read from the FIFO\n * @param       dat\n *              Pointer to IDATA buffer to hold data read from the FIFO\n * @param       fifoNum\n *              USB FIFO to read\n ******************************************************************************/\n", "func_signal": "static void USB_ReadFIFO_Idata(uint8_t numBytes, SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_IDATA), uint8_t fifoNum)", "code": "{\n  while (--numBytes)\n  {\n    USB_GetFIFOByte(*dat);\n    dat++;\n  }\n  USB_GetLastFIFOByte(*dat, fifoNum);\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Writes data held in IRAM to the USB FIFO\n * @details     The FIFO to write must be set before calling the function with\n *              @ref USB_EnableWriteFIFO().\n * @param       numBytes\n *              Number of bytes to write to the FIFO\n * @param       dat\n *              Pointer to IDATA buffer holding data to write to the FIFO\n ******************************************************************************/\n", "func_signal": "static void USB_WriteFIFO_Idata(uint8_t numBytes, SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_IDATA))", "code": "{\n  while (numBytes--)\n  {\n    USB_SetFIFOByte(*dat);\n    dat++;\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Reads data from the USB FIFO\n * @param       fifoNum\n *              USB Endpoint FIFO to read\n * @param       numBytes\n *              Number of bytes to read from the FIFO\n * @param       dat\n *              Pointer to buffer to hold data read from the FIFO\n ******************************************************************************/\n", "func_signal": "void USB_ReadFIFO(uint8_t fifoNum, uint8_t numBytes, uint8_t *dat)", "code": "{\n  if (numBytes > 0)\n  {\n    USB_EnableReadFIFO(fifoNum);\n\n    // Convert generic pointer to memory-specific pointer and call the\n    // the corresponding memory-specific function, if possible.\n    // The memory-specific functions are much faster than the generic functions.\n#ifdef SI_GPTR\n\n    switch (((SI_GEN_PTR_t *)&dat)->gptr.memtype)\n    {\n      case SI_GPTR_MTYPE_IDATA:\n        USB_ReadFIFO_Idata(numBytes, dat, fifoNum);\n        break;\n\n      // For some compilers, IDATA and DATA are treated the same.\n      // Only call the USB_ReadFIFO_Data() if the compiler differentiates\n      // between DATA and IDATA.\n#if (SI_GPTR_MTYPE_DATA != SI_GPTR_MTYPE_IDATA)\n      case SI_GPTR_MTYPE_DATA:\n        USB_ReadFIFO_Data(numBytes, dat, fifoNum);\n        break;\n#endif\n\n      case SI_GPTR_MTYPE_XDATA:\n        USB_ReadFIFO_Xdata(numBytes, dat, fifoNum);\n        break;\n\n      // For some compilers, XDATA and PDATA are treated the same.\n      // Only call the USB_ReadFIFO_Pdata() if the compiler differentiates\n      // between XDATA and PDATA.\n#if (SI_GPTR_MTYPE_PDATA != SI_GPTR_MTYPE_XDATA)\n      case SI_GPTR_MTYPE_PDATA:\n        USB_ReadFIFO_Pdata(numBytes, dat, fifoNum);\n        break;\n#endif\n\n      default:\n        break;\n    }\n\n#else\n    USB_ReadFIFO_Generic(numBytes, dat, fifoNum);\n#endif  // #ifdef SI_GPTR\n\n    USB_DisableReadFIFO(fifoNum);\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Reads data from the USB FIFO to a buffer in DRAM\n * @param       numBytes\n *              Number of bytes to read from the FIFO\n * @param       dat\n *              Pointer to DATA buffer to hold data read from the FIFO\n * @param       fifoNum\n *              USB FIFO to read\n ******************************************************************************/\n", "func_signal": "static void USB_ReadFIFO_Data(uint8_t numBytes, SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_DATA), uint8_t fifoNum)", "code": "{\n  while (--numBytes)\n  {\n    USB_GetFIFOByte(*dat);\n    dat++;\n  }\n  USB_GetLastFIFOByte(*dat, fifoNum);\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Handle Endpoint 1 OUT transfer interrupt\n * @note        This function takes no parameters, but it uses the EP1OUT status\n *              variables stored in @ref myUsbDevice.ep1out.\n ******************************************************************************/\n", "func_signal": "void handleUsbOut1Int(void)", "code": "{\n  uint8_t count;\n\n  USB_Status_TypeDef status;\n  bool xferComplete = false;\n\n  USB_SetIndex(1);\n\n  if (USB_EpnOutGetSentStall())\n  {\n    USB_EpnOutClearSentStall();\n  }\n  else if (USB_EpnGetOutPacketReady())\n  {\n    count = USB_EpOutGetCount();\n\n    // If USBD_Read() has not been called, return an error\n    if (myUsbDevice.ep1out.state != D_EP_RECEIVING)\n    {\n      myUsbDevice.ep1out.misc.bits.outPacketPending = true;\n      status = USB_STATUS_EP_ERROR;\n    }\n    // Check for overrun of user buffer\n    else if (myUsbDevice.ep1out.remaining < count)\n    {\n      myUsbDevice.ep1out.state = D_EP_IDLE;\n      myUsbDevice.ep1out.misc.bits.outPacketPending = true;\n      status = USB_STATUS_EP_RX_BUFFER_OVERRUN;\n    }\n    else\n    {\n      USB_ReadFIFO(1, count, myUsbDevice.ep1out.buf);\n\n      myUsbDevice.ep1out.misc.bits.outPacketPending = false;\n      myUsbDevice.ep1out.remaining -= count;\n      myUsbDevice.ep1out.buf += count;\n\n      if ((myUsbDevice.ep1out.remaining == 0) || (count != SLAB_USB_EP1OUT_MAX_PACKET_SIZE))\n      {\n        myUsbDevice.ep1out.state = D_EP_IDLE;\n        xferComplete = true;\n      }\n      status = USB_STATUS_OK;\n      USB_EpnClearOutPacketReady();\n    }\n    if (myUsbDevice.ep1out.misc.bits.callback == true)\n    {\n      if (xferComplete == true)\n      {\n        myUsbDevice.ep1out.misc.bits.callback = false;\n      }\n      USBD_XferCompleteCb(EP1OUT, status, count, myUsbDevice.ep1out.remaining);\n    }\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n * @brief       Writes data held in code space to the USB FIFO\n * @details     The FIFO to write must be set before calling the function with\n *              @ref USB_EnableWriteFIFO().\n * @param       numBytes\n *              Number of bytes to write to the FIFO\n * @param       dat\n *              Pointer to CODE buffer holding data to write to the FIFO\n ******************************************************************************/\n", "func_signal": "static void USB_WriteFIFO_Code(uint8_t numBytes, SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_CODE))", "code": "{\n  while (numBytes--)\n  {\n    USB_SetFIFOByte(*dat);\n    dat++;\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "// ----------------------------------------------------------------------------\n// If Isochronous mode is enabled and the max packet size is greater than 255,\n// break the FIFO writes up into multiple writes of 255 or less bytes.\n// ----------------------------------------------------------------------------\n", "func_signal": "void USB_WriteFIFOIso(uint8_t fifoNum, uint16_t numBytes, uint8_t *dat)", "code": "{\n  uint8_t numBytesWrite;\n\n  // USB_WriteFIFO() accepts a maximum of 255 bytes. If the number of bytes to\n  // send is greated than 255, call USB_WriteFIFO() multiple times.\n  while (numBytes > 0)\n  {\n    numBytesWrite = (numBytes > 255) ? 255 : numBytes;\n    numBytes -= numBytesWrite;\n    USB_WriteFIFO(fifoNum, numBytesWrite, dat, (numBytes == 0));\n    dat += numBytesWrite;\n  }\n}", "path": "u2f-zero/firmware/lib/efm8_usb/src/efm8_usbdep.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "conorpp/u2f-zero", "stars": 2395, "license": "other", "language": "c", "size": 1853}
{"docstring": "/**\n  * @brief  Sets the vector table location and Offset.\n  * @param  NVIC_VectTab: specifies if the vector table is in RAM or FLASH memory.\n  *   This parameter can be one of the following values:\n  *     @arg NVIC_VectTab_RAM\n  *     @arg NVIC_VectTab_FLASH\n  * @param  Offset: Vector Table base offset field. This value must be a multiple \n  *         of 0x200.\n  * @retval None\n  */\n", "func_signal": "void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)", "code": "{ \n  /* Check the parameters */\n  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));\n  assert_param(IS_NVIC_OFFSET(Offset));  \n   \n  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nexpr_shift -> expr_additive\n\t| expr_shift '<<' expr_additive\n\t| expr_shift '>>' expr_additive\n*/\n", "func_signal": "static struct finsh_node* proc_shift_expr(struct finsh_parser* self)", "code": "{\n\tenum finsh_token_type token;\n\tstruct finsh_node* add;\n\tstruct finsh_node* add_new;\n\n\tadd = proc_additive_expr(self);\n\n\tnext_token(token, &(self->token));\n\twhile ( token == finsh_token_type_shl || token == finsh_token_type_shr)\n\t{\n\t\tadd_new = proc_additive_expr(self);\n\t\tif (add_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);\n\t\telse\n\t\t{\n\t\t\tswitch (token)\n\t\t\t{\n\t\t\tcase finsh_token_type_shl:\n\t\t\t\tadd = make_sys_node(FINSH_NODE_SYS_SHL, add, add_new);\n\t\t\t\tbreak;\n\t\t\tcase finsh_token_type_shr:\n\t\t\t\tadd = make_sys_node(FINSH_NODE_SYS_SHR, add, add_new);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfinsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnext_token(token, &(self->token));\n\t}\n\n\tfinsh_token_replay(&(self->token));\n\treturn add;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nstart -> statement_expr | decl_variable\n*/\n", "func_signal": "void finsh_parser_run(struct finsh_parser* self, const u_char* string)", "code": "{\n\tenum finsh_token_type token;\n\tstruct finsh_node *node;\n\n    node = NULL;\n\n\t/* init parser */\n\tself->parser_string = (u_char*)string;\n\n\t/* init token */\n\tfinsh_token_init(&(self->token), self->parser_string);\n\n\t/* get next token */\n\tnext_token(token, &(self->token));\n\twhile (token != finsh_token_type_eof && token != finsh_token_type_bad)\n\t{\n\t\tswitch (token)\n\t\t{\n        case finsh_token_type_identifier:\n            /* process expr_statement */\n            finsh_token_replay(&(self->token));\n\n\t\t\tif (self->root != NULL)\n\t\t\t{\n\t\t\t\tfinsh_node_sibling(node) = proc_expr_statement(self);\n\t\t\t\tif (finsh_node_sibling(node) != NULL)\n\t\t\t\t\tnode = finsh_node_sibling(node);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n            \tnode = proc_expr_statement(self);\n\t\t\t\tself->root = node;\n\t\t\t}\n            break;\n\n\t\tdefault:\n            if (is_base_type(token) || token == finsh_token_type_unsigned)\n            {\n            \t/* variable decl */\n            \tfinsh_token_replay(&(self->token));\n\n\t\t\t\tif (self->root != NULL)\n\t\t\t\t{\n\t\t\t\t\tfinsh_node_sibling(node) = proc_variable_decl(self);\n\t\t\t\t\tif (finsh_node_sibling(node) != NULL)\n\t\t\t\t\t\tnode = finsh_node_sibling(node);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode = proc_variable_decl(self);\n\t\t\t\t\tself->root = node;\n\t\t\t\t}\n            }\n            else\n            {\n            \t/* process expr_statement */\n                finsh_token_replay(&(self->token));\n\n\t\t\t\tif (self->root != NULL)\n\t\t\t\t{\n                    finsh_node_sibling(node) = proc_expr_statement(self);\n\t\t\t\t\tif (finsh_node_sibling(node) != NULL)\n\t\t\t\t\t\tnode = finsh_node_sibling(node);\n\t\t\t\t\telse next_token(token, &(self->token));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode = proc_expr_statement(self);\n\t\t\t\t\tself->root = node;\n\t\t\t\t}\n            }\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no root found, break out */\n\t\tif (self->root == NULL) break;\n\n        /* get next token */\n\t\tnext_token(token, &(self->token));\n\t}\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nidentifier -> IDENTIFIER\n*/\n", "func_signal": "static int proc_identifier(struct finsh_parser* self, char* id)", "code": "{\n\tenum finsh_token_type token;\n\n\tmatch_token(token, &(self->token), finsh_token_type_identifier);\n\n\tstrncpy(id, (char*)self->token.string, FINSH_NAME_MAX);\n\n\treturn 0;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n  * @brief  Checks whether the specified IWDG flag is set or not.\n  * @param  IWDG_FLAG: specifies the flag to check.\n  *   This parameter can be one of the following values:\n  *     @arg IWDG_FLAG_PVU: Prescaler Value Update on going\n  *     @arg IWDG_FLAG_RVU: Reload Value Update on going\n  * @retval The new state of IWDG_FLAG (SET or RESET).\n  */\n", "func_signal": "FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_IWDG_FLAG(IWDG_FLAG));\n  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)\n  {\n    bitstatus = SET;\n  }\n  else\n  {\n    bitstatus = RESET;\n  }\n  /* Return the flag status */\n  return bitstatus;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n  * @brief  Sets IWDG Prescaler value.\n  * @param  IWDG_Prescaler: specifies the IWDG Prescaler value.\n  *   This parameter can be one of the following values:\n  *     @arg IWDG_Prescaler_4: IWDG prescaler set to 4\n  *     @arg IWDG_Prescaler_8: IWDG prescaler set to 8\n  *     @arg IWDG_Prescaler_16: IWDG prescaler set to 16\n  *     @arg IWDG_Prescaler_32: IWDG prescaler set to 32\n  *     @arg IWDG_Prescaler_64: IWDG prescaler set to 64\n  *     @arg IWDG_Prescaler_128: IWDG prescaler set to 128\n  *     @arg IWDG_Prescaler_256: IWDG prescaler set to 256\n  * @retval None\n  */\n", "func_signal": "void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));\n  IWDG->PR = IWDG_Prescaler;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n  * @brief  Sets the WWDG window value.\n  * @param  WindowValue: specifies the window value to be compared to the downcounter.\n  *   This parameter value must be lower than 0x80.\n  * @retval None\n  */\n", "func_signal": "void WWDG_SetWindowValue(uint8_t WindowValue)", "code": "{\n  __IO uint32_t tmpreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));\n  /* Clear W[6:0] bits */\n\n  tmpreg = WWDG->CFR & CFR_W_Mask;\n\n  /* Set W[6:0] bits according to WindowValue value */\n  tmpreg |= WindowValue & (uint32_t) BIT_Mask;\n\n  /* Store the new value */\n  WWDG->CFR = tmpreg;\n}", "path": "EasyLogger/demo/non_os/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c", "commit_date": "2015-07-31 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n  * @brief  Initializes the NVIC peripheral according to the specified\n  *         parameters in the NVIC_InitStruct.\n  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains\n  *         the configuration information for the specified NVIC peripheral.\n  * @retval None\n  */\n", "func_signal": "void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)", "code": "{\n  uint32_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;\n  \n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  \n  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));\n    \n  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)\n  {\n    /* Compute the Corresponding IRQ Priority --------------------------------*/    \n    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;\n    tmppre = (0x4 - tmppriority);\n    tmpsub = tmpsub >> tmppriority;\n\n    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;\n    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;\n    tmppriority = tmppriority << 0x04;\n        \n    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;\n    \n    /* Enable the Selected IRQ Channels --------------------------------------*/\n    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =\n      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);\n  }\n  else\n  {\n    /* Disable the Selected IRQ Channels -------------------------------------*/\n    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =\n      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);\n  }\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nexpr_postfix -> expr_primary\n\t| expr_postfix INC\n\t| expr_postfix DEC\n\t| expr_postfix '(' param_list ')'\n*/\n", "func_signal": "static struct finsh_node* proc_postfix_expr(struct finsh_parser* self)", "code": "{\n\tenum finsh_token_type token;\n\tstruct finsh_node* postfix;\n\n\tpostfix = proc_primary_expr(self);\n\n\tnext_token(token, &(self->token));\n\twhile ( token == finsh_token_type_inc \t||\n\t\ttoken == finsh_token_type_dec \t\t||\n\t\ttoken == finsh_token_type_left_paren )\n\t{\n\t\tswitch (token)\n\t\t{\n\t\tcase finsh_token_type_inc :/* '++' */\n\t\t\tpostfix = make_sys_node(FINSH_NODE_SYS_INC, postfix, NULL);\n\t\t\tbreak;\n\n\t\tcase finsh_token_type_dec :/* '--' */\n\t\t\tpostfix = make_sys_node(FINSH_NODE_SYS_DEC, postfix, NULL);\n\t\t\tbreak;\n\n\t\tcase finsh_token_type_left_paren :/* '(' */\n\t\t\t{\n\t\t\t\tstruct finsh_node* param_list;\n\n\t\t\t\tparam_list = NULL;\n\t\t\t\tnext_token(token, &(self->token));\n\t\t\t\tif (token != finsh_token_type_right_paren)\n\t\t\t\t{\n\t\t\t\t\tfinsh_token_replay(&(self->token));\n\t\t\t\t\tparam_list = proc_param_list(self);\n\n\t\t\t\t\tmatch_token(token, &(self->token), finsh_token_type_right_paren);\n\t\t\t\t}\n\n\t\t\t\tpostfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tnext_token(token, &(self->token));\n\t}\n\n\tfinsh_token_replay(&(self->token));\n\treturn postfix;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\n20050921, add '*' and '&'\nexpr_unary -> expr_postfix\n\t| ADD expr_cast\n\t| INC expr_cast\n\t| SUB expr_cast\n\t| DEC expr_cast\n\t| '~' expr_cast\n\t| '*' expr_cast\n\t| '&' expr_cast\n*/\n", "func_signal": "static struct finsh_node* proc_unary_expr(struct finsh_parser* self)", "code": "{\n\tenum finsh_token_type token;\n\tstruct finsh_node *cast;\n\n\tnext_token(token, &(self->token));\n\tswitch (token)\n\t{\n\tcase finsh_token_type_add: /* + */\n\t\tcast = proc_cast_expr(self);\n\t\treturn cast;\n\n\tcase finsh_token_type_inc: /* ++ */\n\t\tcast = proc_cast_expr(self);\n\t\treturn make_sys_node(FINSH_NODE_SYS_PREINC, cast, NULL);\n\n\tcase finsh_token_type_sub: /* - */\n\t\tcast = proc_cast_expr(self);\n\t\treturn make_sys_node(FINSH_NODE_SYS_SUB, finsh_node_new_long(0), cast);\n\n\tcase finsh_token_type_dec: /* -- */\n\t\tcast = proc_cast_expr(self);\n\t\treturn make_sys_node(FINSH_NODE_SYS_PREDEC, cast, NULL);\n\n\tcase finsh_token_type_bitwise: /* ~ */\n\t\tcast = proc_cast_expr(self);\n\t\treturn make_sys_node(FINSH_NODE_SYS_BITWISE, cast, NULL);\n\n    case finsh_token_type_mul: /* * */\n        cast = proc_cast_expr(self);\n        return make_sys_node(FINSH_NODE_SYS_GETVALUE, cast, NULL);\n\n    case finsh_token_type_and: /* & */\n        cast = proc_cast_expr(self);\n        return make_sys_node(FINSH_NODE_SYS_GETADDR, cast, NULL);\n\n\tdefault:\n\t\tfinsh_token_replay(&(self->token));\n\t\treturn proc_postfix_expr(self);\n\t}\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nexpr_inclusive_or -> expr_exclusive_or\n\t| expr_inclusive_or '|' expr_exclusive_or\n*/\n", "func_signal": "static struct finsh_node* proc_inclusive_or_expr(struct finsh_parser* self)", "code": "{\n\tenum finsh_token_type token;\n\tstruct finsh_node* xor;\n\tstruct finsh_node* xor_new;\n\n\txor = proc_exclusive_or_expr(self);\n\n\tnext_token(token, &(self->token));\n\twhile ( token == finsh_token_type_or )\n\t{\n\t\txor_new = proc_exclusive_or_expr(self);\n\n\t\tif (xor_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);\n\t\telse xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);\n\n\t\tnext_token(token, &(self->token));\n\t}\n\n\tfinsh_token_replay(&(self->token));\n\treturn xor;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n  * @brief  Enables WWDG and load the counter value.                  \n  * @param  Counter: specifies the watchdog counter value.\n  *   This parameter must be a number between 0x40 and 0x7F.\n  * @retval None\n  */\n", "func_signal": "void WWDG_Enable(uint8_t Counter)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_WWDG_COUNTER(Counter));\n  WWDG->CR = CR_WDGA_Set | Counter;\n}", "path": "EasyLogger/demo/non_os/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c", "commit_date": "2015-07-31 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nstatement_expr -> ';'\n\t| expr ';'\n*/\n", "func_signal": "static struct finsh_node* proc_expr_statement(struct finsh_parser* self)", "code": "{\n\tenum finsh_token_type token;\n\tstruct finsh_node* expr;\n\n\texpr = NULL;\n\tnext_token(token, &(self->token));\n\tif ( token != finsh_token_type_semicolon )\n\t{\n\t\tfinsh_token_replay(&(self->token));\n\t\texpr = proc_expr(self);\n\n\t\tmatch_token(token, &(self->token), finsh_token_type_semicolon);\n\t}\n\n\treturn expr;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n  * @brief  Selects the condition for the system to enter low power mode.\n  * @param  LowPowerMode: Specifies the new mode for the system to enter low power mode.\n  *   This parameter can be one of the following values:\n  *     @arg NVIC_LP_SEVONPEND\n  *     @arg NVIC_LP_SLEEPDEEP\n  *     @arg NVIC_LP_SLEEPONEXIT\n  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_NVIC_LP(LowPowerMode));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));  \n  \n  if (NewState != DISABLE)\n  {\n    SCB->SCR |= LowPowerMode;\n  }\n  else\n  {\n    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);\n  }\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nmake a new node as following tree:\nnew_node\n|\nnode1__\n       \\\n       node2\n*/\n", "func_signal": "static struct finsh_node* make_sys_node(u_char type, struct finsh_node* node1, struct finsh_node* node2)", "code": "{\n\tstruct finsh_node* node;\n\n\tnode = finsh_node_allocate(type);\n\n\tif ((node1 != NULL) && (node != NULL))\n\t{\n\t\tfinsh_node_child(node) = node1;\n\t\tfinsh_node_sibling(node1) = node2;\n\t}\n\telse finsh_error_set(FINSH_ERROR_NULL_NODE);\n\n\treturn node;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nexpr_assign -> expr_inclusive_or\n\t| expr_unary ASSIGN expr_assign\n*/\n", "func_signal": "static struct finsh_node* proc_assign_expr(struct finsh_parser* self)", "code": "{\n\tenum finsh_token_type token;\n\tstruct finsh_node* or;\n\tstruct finsh_node* assign;\n\n\tor = proc_inclusive_or_expr(self);\n\n\tnext_token(token, &(self->token));\n\n\tif (token == finsh_token_type_assign)\n\t{\n\t\tassign = proc_assign_expr(self);\n\n\t\treturn make_sys_node(FINSH_NODE_SYS_ASSIGN, or, assign);\n\t}\n\telse finsh_token_replay(&(self->token));\n\n\treturn or;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\nexpr_primary -> literal\n\t| '(' expr ')'\n\t| identifier\n*/\n", "func_signal": "static struct finsh_node* proc_primary_expr(struct finsh_parser* self)", "code": "{\n\tenum finsh_token_type token;\n\tstruct finsh_node* expr;\n\n\tnext_token(token, &(self->token));\n\tswitch ( token )\n\t{\n\tcase finsh_token_type_identifier:\n\t\t{\n\t\t\tchar id[FINSH_NAME_MAX + 1];\n\n\t\t\tfinsh_token_replay(&(self->token));\n\t\t\tproc_identifier(self, id);\n\t\t\treturn finsh_node_new_id(id);\n\t\t}\n\n\tcase finsh_token_type_left_paren:\n\t\texpr = proc_expr(self);\n\t\tmatch_token(token, &(self->token), finsh_token_type_right_paren);\n\t\treturn expr;\n\n\tcase finsh_token_type_value_int:\n\t\treturn finsh_node_new_int(self->token.value.int_value);\n\n\tcase finsh_token_type_value_long:\n\t\treturn finsh_node_new_long(self->token.value.long_value);\n\n\tcase finsh_token_type_value_char:\n\t\treturn finsh_node_new_char(self->token.value.char_value);\n\n\tcase finsh_token_type_value_string:\n\t\treturn finsh_node_new_string((char*)self->token.string);\n\n\tcase finsh_token_type_value_null:\n\t\treturn finsh_node_new_ptr(NULL);\n\n\tdefault:\n\t\tfinsh_error_set(FINSH_ERROR_INVALID_TOKEN);\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/components/finsh/finsh_parser.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/*\n * The initialized memory pool will be:\n * +-----------------------------------+--------------------------+\n * | whole freed memory block          | Used Memory Block Tailer |\n * +-----------------------------------+--------------------------+\n *\n * block_list --> whole freed memory block\n *\n * The length of Used Memory Block Tailer is 0,\n * which is prevents block merging across list\n */\n", "func_signal": "rt_err_t rt_memheap_init(struct rt_memheap *memheap,\n                         const char        *name,\n                         void              *start_addr,\n                         rt_uint32_t        size)", "code": "{\n    struct rt_memheap_item *item;\n\n    RT_ASSERT(memheap != RT_NULL);\n\n    /* initialize pool object */\n    rt_object_init(&(memheap->parent), RT_Object_Class_MemHeap, name);\n\n    memheap->start_addr     = start_addr;\n    memheap->pool_size      = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);\n    memheap->available_size = memheap->pool_size - (2 * RT_MEMHEAP_SIZE);\n    memheap->max_used_size  = memheap->pool_size - memheap->available_size;\n\n    /* initialize the free list header */\n    item            = &(memheap->free_header);\n    item->magic     = RT_MEMHEAP_MAGIC;\n    item->pool_ptr  = memheap;\n    item->next      = RT_NULL;\n    item->prev      = RT_NULL;\n    item->next_free = item;\n    item->prev_free = item;\n\n    /* set the free list to free list header */\n    memheap->free_list = item;\n\n    /* initialize the first big memory block */\n    item            = (struct rt_memheap_item *)start_addr;\n    item->magic     = RT_MEMHEAP_MAGIC;\n    item->pool_ptr  = memheap;\n    item->next      = RT_NULL;\n    item->prev      = RT_NULL;\n    item->next_free = item;\n    item->prev_free = item;\n\n    item->next = (struct rt_memheap_item *)\n        ((rt_uint8_t *)item + memheap->available_size + RT_MEMHEAP_SIZE);\n    item->prev = item->next;\n\n    /* block list header */\n    memheap->block_list = item;\n\n    /* place the big memory block to free list */\n    item->next_free = memheap->free_list->next_free;\n    item->prev_free = memheap->free_list;\n    memheap->free_list->next_free->prev_free = item;\n    memheap->free_list->next_free            = item;\n\n    /* move to the end of memory pool to build a small tailer block,\n     * which prevents block merging\n     */\n    item = item->next;\n    /* it's a used memory block */\n    item->magic     = RT_MEMHEAP_MAGIC | RT_MEMHEAP_USED;\n    item->pool_ptr  = memheap;\n    item->next      = (struct rt_memheap_item *)start_addr;\n    item->prev      = (struct rt_memheap_item *)start_addr;\n    /* not in free list */\n    item->next_free = item->prev_free = RT_NULL;\n\n    /* initialize semaphore lock */\n    rt_sem_init(&(memheap->lock), name, 1, RT_IPC_FLAG_FIFO);\n\n    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,\n                 (\"memory heap: start addr 0x%08x, size %d, free list header 0x%08x\\n\",\n                  start_addr, size, &(memheap->free_header)));\n\n    return RT_EOK;\n}", "path": "EasyLogger/demo/os/rt-thread/stm32f10x/RT-Thread-1.2.2/src/memheap.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n  * @brief  Sets the WWDG counter value.\n  * @param  Counter: specifies the watchdog counter value.\n  *   This parameter must be a number between 0x40 and 0x7F.\n  * @retval None\n  */\n", "func_signal": "void WWDG_SetCounter(uint8_t Counter)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_WWDG_COUNTER(Counter));\n  /* Write to T[6:0] bits to configure the counter value, no need to do\n     a read-modify-write; writing a 0 to WDGA bit does nothing */\n  WWDG->CR = Counter & BIT_Mask;\n}", "path": "EasyLogger/demo/non_os/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c", "commit_date": "2015-07-31 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n * EasyLogger demo\n */\n", "func_signal": "void test_elog(void)", "code": "{\n    uint8_t buf[256]= {0};\n    int i = 0;\n\n    for (i = 0; i < sizeof(buf); i++)\n    {\n        buf[i] = i;\n    }\n    while(true) {\n        /* test log output for all level */\n        log_a(\"Hello EasyLogger!\");\n        log_e(\"Hello EasyLogger!\");\n        log_w(\"Hello EasyLogger!\");\n        log_i(\"Hello EasyLogger!\");\n        log_d(\"Hello EasyLogger!\");\n        log_v(\"Hello EasyLogger!\");\n//        elog_raw(\"Hello EasyLogger!\");\n        elog_hexdump(\"test\", 16, buf, sizeof(buf));\n        sleep(5);\n    }\n}", "path": "EasyLogger/demo/os/linux/main.c", "commit_date": "2019-11-30 00:00:00", "repo_name": "armink/EasyLogger", "stars": 3394, "license": "mit", "language": "c", "size": 3668}
{"docstring": "/**\n  * @brief  Decryption mode.\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module\n  * @param  Input: Pointer to the input buffer (ciphertext )\n  * @param  Size: Length of the plaintext buffer in word.\n  * @param  Output: Pointer to the output buffer(plaintext)\n  * @param  Timeout: Specify Timeout value\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_CRYP_Decrypt(CRYP_HandleTypeDef *hcryp, uint32_t *Input, uint16_t Size, uint32_t *Output, uint32_t Timeout)", "code": "{\n  HAL_StatusTypeDef status;\n  uint32_t algo;\n\n  if(hcryp->State == HAL_CRYP_STATE_READY)\n  {\n    /* Change state Busy */\n    hcryp->State = HAL_CRYP_STATE_BUSY;\n\n    /* Process locked */\n    __HAL_LOCK(hcryp);\n\n    /*  Reset CrypInCount, CrypOutCount and Initialize pCrypInBuffPtr, pCrypOutBuffPtr and Size parameters*/\n    hcryp->CrypInCount = 0U;\n    hcryp->CrypOutCount = 0U;\n    hcryp->pCrypInBuffPtr = Input;\n    hcryp->pCrypOutBuffPtr = Output;\n\n    /*  Calculate Size parameter in Byte*/\n    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)\n    {\n      hcryp->Size = Size * 4U;\n    }\n    else\n    {\n      hcryp->Size = Size;\n    }\n\n    /* Set Decryption operating mode*/\n    MODIFY_REG(hcryp->Instance->CR, CRYP_CR_ALGODIR, CRYP_OPERATINGMODE_DECRYPT);\n\n    /* algo get algorithm selected */\n    algo = hcryp->Instance->CR & CRYP_CR_ALGOMODE;\n\n    switch(algo)\n    {\n    case CRYP_DES_ECB:\n    case CRYP_DES_CBC:\n    case CRYP_TDES_ECB:\n    case CRYP_TDES_CBC:\n\n      /*Set Key */\n      hcryp->Instance->K1LR = *(uint32_t*)(hcryp->Init.pKey);\n      hcryp->Instance->K1RR = *(uint32_t*)(hcryp->Init.pKey+1);\n      if ((hcryp->Init.Algorithm == CRYP_TDES_ECB) || (hcryp->Init.Algorithm == CRYP_TDES_CBC))\n      {\n        hcryp->Instance->K2LR = *(uint32_t*)(hcryp->Init.pKey+2);\n        hcryp->Instance->K2RR = *(uint32_t*)(hcryp->Init.pKey+3);\n        hcryp->Instance->K3LR = *(uint32_t*)(hcryp->Init.pKey+4);\n        hcryp->Instance->K3RR = *(uint32_t*)(hcryp->Init.pKey+5);\n      }\n\n      /*Set Initialization Vector (IV)*/\n      if ((hcryp->Init.Algorithm == CRYP_DES_CBC) || (hcryp->Init.Algorithm == CRYP_TDES_CBC))\n      {\n        hcryp->Instance->IV0LR = *(uint32_t*)(hcryp->Init.pInitVect);\n        hcryp->Instance->IV0RR = *(uint32_t*)(hcryp->Init.pInitVect+1);\n      }\n\n      /* Flush FIFO */\n      HAL_CRYP_FIFO_FLUSH(hcryp);\n\n      /* Set the phase */\n      hcryp->Phase = CRYP_PHASE_PROCESS;\n\n      /* Start DES/TDES decryption process */\n      status = CRYP_TDES_Process(hcryp, Timeout);\n\n      break;\n\n    case CRYP_AES_ECB:\n    case CRYP_AES_CBC:\n    case CRYP_AES_CTR:\n\n      /* AES decryption */\n      status = CRYP_AES_Decrypt(hcryp, Timeout);\n      break;\n\n    default:\n      hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;\n      status = HAL_ERROR;\n      break;\n    }\n\n    if (status == HAL_OK)\n    {\n      /* Change the CRYP peripheral state */\n      hcryp->State = HAL_CRYP_STATE_READY;\n\n      /* Process unlocked */\n      __HAL_UNLOCK(hcryp);\n    }\n  }\n  else\n  {\n    /* Process unlocked */\n    __HAL_UNLOCK(hcryp);\n\n    /* Busy error code field */\n    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;\n    status = HAL_ERROR;\n  }\n\n  /* Return function status */\n  return status;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Encryption in interrupt mode.\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module\n  * @param  Input: Pointer to the input buffer (plaintext)\n  * @param  Size: Length of the plaintext buffer in word\n  * @param  Output: Pointer to the output buffer(ciphertext)\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_CRYP_Encrypt_IT(CRYP_HandleTypeDef *hcryp, uint32_t *Input, uint16_t Size, uint32_t *Output)", "code": "{\n  uint32_t algo;\n  HAL_StatusTypeDef status;\n\n  if(hcryp->State == HAL_CRYP_STATE_READY)\n  {\n    /* Change state Busy */\n    hcryp->State = HAL_CRYP_STATE_BUSY;\n\n    /* Process locked */\n    __HAL_LOCK(hcryp);\n\n    /*  Reset CrypInCount, CrypOutCount and Initialize pCrypInBuffPtr, pCrypOutBuffPtr and Size parameters*/\n    hcryp->CrypInCount = 0U;\n    hcryp->CrypOutCount = 0U;\n    hcryp->pCrypInBuffPtr = Input;\n    hcryp->pCrypOutBuffPtr = Output;\n\n    /*  Calculate Size parameter in Byte*/\n    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)\n    {\n      hcryp->Size = Size * 4U;\n    }\n    else\n    {\n      hcryp->Size = Size;\n    }\n\n    /* Set encryption operating mode*/\n    MODIFY_REG(hcryp->Instance->CR, CRYP_CR_ALGODIR, CRYP_OPERATINGMODE_ENCRYPT);\n\n    /* algo get algorithm selected */\n    algo = (hcryp->Instance->CR & CRYP_CR_ALGOMODE);\n\n    switch(algo)\n    {\n    case CRYP_DES_ECB:\n    case CRYP_DES_CBC:\n    case CRYP_TDES_ECB:\n    case CRYP_TDES_CBC:\n\n      /*Set Key */\n      hcryp->Instance->K1LR = *(uint32_t*)(hcryp->Init.pKey);\n      hcryp->Instance->K1RR = *(uint32_t*)(hcryp->Init.pKey+1);\n      if ((hcryp->Init.Algorithm == CRYP_TDES_ECB) || (hcryp->Init.Algorithm == CRYP_TDES_CBC))\n      {\n        hcryp->Instance->K2LR = *(uint32_t*)(hcryp->Init.pKey+2);\n        hcryp->Instance->K2RR = *(uint32_t*)(hcryp->Init.pKey+3);\n        hcryp->Instance->K3LR = *(uint32_t*)(hcryp->Init.pKey+4);\n        hcryp->Instance->K3RR = *(uint32_t*)(hcryp->Init.pKey+5);\n      }\n      /* Set the Initialization Vector*/\n      if ((hcryp->Init.Algorithm == CRYP_DES_CBC) || (hcryp->Init.Algorithm == CRYP_TDES_CBC))\n      {\n        hcryp->Instance->IV0LR = *(uint32_t*)(hcryp->Init.pInitVect);\n        hcryp->Instance->IV0RR = *(uint32_t*)(hcryp->Init.pInitVect+1);\n      }\n\n      /* Flush FIFO */\n      HAL_CRYP_FIFO_FLUSH(hcryp);\n\n      /* Set the phase */\n      hcryp->Phase = CRYP_PHASE_PROCESS;\n\n      /* Enable interrupts */\n      __HAL_CRYP_ENABLE_IT(hcryp, CRYP_IT_INI | CRYP_IT_OUTI);\n\n      /* Enable CRYP to start DES/TDES process*/\n      __HAL_CRYP_ENABLE(hcryp);\n\n      status = HAL_OK;\n      break;\n\n    case CRYP_AES_ECB:\n    case CRYP_AES_CBC:\n    case CRYP_AES_CTR:\n\n      status = CRYP_AES_Encrypt_IT(hcryp);\n      break;\n\n    default:\n      hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;\n      status =  HAL_ERROR;\n      break;\n    }\n  }\n  else\n  {\n    /* Busy error code field */\n    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;\n    status =  HAL_ERROR;\n  }\n\n  /* Return function status */\n  return status ;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Decryption in ECB/CBC & CTR mode with AES Standard using interrupt mode\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module\n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef CRYP_AES_Decrypt_IT(CRYP_HandleTypeDef *hcryp)", "code": "{\n  __IO uint32_t count = 0U;\n\n  /*  Key preparation for ECB/CBC */\n  if (hcryp->Init.Algorithm != CRYP_AES_CTR)\n  {\n    /* change ALGOMODE to key preparation for decryption*/\n    MODIFY_REG(hcryp->Instance->CR, CRYP_CR_ALGOMODE, CRYP_CR_ALGOMODE_AES_KEY );\n\n    /*  Set the Key*/\n    CRYP_SetKey(hcryp, hcryp->Init.KeySize);\n\n    /* Enable CRYP */\n    __HAL_CRYP_ENABLE(hcryp);\n\n    /* Wait for BUSY flag to be raised */\n    count = CRYP_TIMEOUT_KEYPREPARATION;\n    do\n    {\n      count-- ;\n      if(count == 0U)\n      {\n        /* Change state */\n        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;\n        hcryp->State = HAL_CRYP_STATE_READY;\n\n        /* Process unlocked */\n        __HAL_UNLOCK(hcryp);\n        return HAL_ERROR;\n      }\n    }\n    while(HAL_IS_BIT_SET(hcryp->Instance->SR, CRYP_FLAG_BUSY));\n\n    /* Turn back to ALGOMODE of the configuration */\n    MODIFY_REG(hcryp->Instance->CR, CRYP_CR_ALGOMODE, hcryp->Init.Algorithm );\n  }\n  else  /*Algorithm CTR */\n  {\n    /*  Set the Key*/\n    CRYP_SetKey(hcryp, hcryp->Init.KeySize);\n  }\n\n  /* Set IV */\n  if (hcryp->Init.Algorithm != CRYP_AES_ECB)\n  {\n    /* Set the Initialization Vector*/\n    hcryp->Instance->IV0LR = *(uint32_t*)(hcryp->Init.pInitVect);\n    hcryp->Instance->IV0RR = *(uint32_t*)(hcryp->Init.pInitVect+1);\n    hcryp->Instance->IV1LR = *(uint32_t*)(hcryp->Init.pInitVect+2);\n    hcryp->Instance->IV1RR = *(uint32_t*)(hcryp->Init.pInitVect+3);\n  }\n  /* Set the phase */\n  hcryp->Phase = CRYP_PHASE_PROCESS;\n  if(hcryp->Size != 0U)\n  {\n    /* Enable interrupts */\n    __HAL_CRYP_ENABLE_IT(hcryp, CRYP_IT_INI | CRYP_IT_OUTI);\n\n    /* Enable CRYP */\n    __HAL_CRYP_ENABLE(hcryp);\n  }\n  else\n  {\n    /* Process locked */\n    __HAL_UNLOCK(hcryp);\n\n    /* Change the CRYP state */\n    hcryp->State = HAL_CRYP_STATE_READY;\n  }\n  /* Return function status */\n  return HAL_OK;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/* itoa:  convert n to characters in s */\n", "func_signal": "extern void itoa(int n, char s[])", "code": "{\n  int i, sign ;\n\n  if ((sign = n) < 0) {  /* record sign */\n    n = -n;          /* make n positive */\n  }\n\n  i = 0;\n  do {\n    /* generate digits in reverse order */\n    s[i++] = n % 10 + '0';   /* get next digit */\n  } while ((n /= 10) > 0) ;     /* delete it */\n\n  if (sign < 0) {\n    s[i++] = '-';\n  }\n\n  s[i] = '\\0';\n\n  reverse(s) ;\n}", "path": "Arduino_Core_STM32/cores/arduino/itoa.c", "commit_date": "2019-02-13 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Encryption in ECB/CBC & CTR mode with AES Standard using interrupt mode\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module\n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef CRYP_AES_Encrypt_IT(CRYP_HandleTypeDef *hcryp)", "code": "{\n\n  /*  Set the Key*/\n  CRYP_SetKey(hcryp, hcryp->Init.KeySize);\n\n  if (hcryp->Init.Algorithm != CRYP_AES_ECB)\n  {\n    /* Set the Initialization Vector*/\n    hcryp->Instance->IV0LR = *(uint32_t*)(hcryp->Init.pInitVect);\n    hcryp->Instance->IV0RR = *(uint32_t*)(hcryp->Init.pInitVect+1);\n    hcryp->Instance->IV1LR = *(uint32_t*)(hcryp->Init.pInitVect+2);\n    hcryp->Instance->IV1RR = *(uint32_t*)(hcryp->Init.pInitVect+3);\n  }\n  /* Set the phase */\n  hcryp->Phase = CRYP_PHASE_PROCESS;\n\n  if(hcryp->Size != 0U)\n  {\n    /* Enable interrupts */\n    __HAL_CRYP_ENABLE_IT(hcryp, CRYP_IT_INI | CRYP_IT_OUTI);\n\n    /* Enable CRYP */\n    __HAL_CRYP_ENABLE(hcryp);\n  }\n  else\n  {\n    /* Change the CRYP state */\n    hcryp->State = HAL_CRYP_STATE_READY;\n\n    /* Process unlocked */\n    __HAL_UNLOCK(hcryp);\n  }\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  DMA CRYP output data process complete callback.\n  * @param  hdma: DMA handle\n  * @retval None\n  */\n", "func_signal": "static void CRYP_DMAOutCplt(DMA_HandleTypeDef *hdma)", "code": "{\n  CRYP_HandleTypeDef* hcryp = (CRYP_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;\n\n\n  /* Disable the DMA transfer for output FIFO */\n  hcryp->Instance->DMACR &= (uint32_t)(~CRYP_DMACR_DOEN);\n\n  /* Change the CRYP state to ready */\n  hcryp->State = HAL_CRYP_STATE_READY;\n\n  /* Process unlocked */\n  __HAL_UNLOCK(hcryp);\n\n    /* Disable CRYP */\n  __HAL_CRYP_DISABLE(hcryp);\n  \n  \n  /* Call output data transfer complete callback */\n#if (USE_HAL_CRYP_REGISTER_CALLBACKS == 1)\n  /*Call registered Output complete callback*/\n  hcryp->OutCpltCallback(hcryp);\n#else\n  /*Call legacy weak Output complete callback*/\n  HAL_CRYP_OutCpltCallback(hcryp);\n#endif /* USE_HAL_CRYP_REGISTER_CALLBACKS */\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Process Data: Write Input data in polling mode and used in AES functions.\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module\n  * @param  Timeout: Specify Timeout value\n  * @retval None\n  */\n", "func_signal": "static void CRYP_AES_ProcessData(CRYP_HandleTypeDef *hcryp, uint32_t Timeout)", "code": "{\n\n  uint32_t temp;  /* Temporary CrypOutBuff */\n  uint16_t incount;  /* Temporary CrypInCount Value */\n  uint16_t outcount;  /* Temporary CrypOutCount Value */\n  \n  /*Temporary CrypOutCount Value*/\n  incount = hcryp->CrypInCount; \n\n  if(((hcryp->Instance->SR & CRYP_FLAG_IFNF ) != 0x0U) && (incount < ((hcryp->Size)/4U)))\n  {\n    /* Write the input block in the IN FIFO */\n    hcryp->Instance->DIN  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount );\n    hcryp->CrypInCount++;\n    hcryp->Instance->DIN  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount );\n    hcryp->CrypInCount++;\n    hcryp->Instance->DIN  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount );\n    hcryp->CrypInCount++;\n    hcryp->Instance->DIN  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount );\n    hcryp->CrypInCount++;\n  }\n\n  /* Wait for OFNE flag to be raised */\n  if(CRYP_WaitOnOFNEFlag(hcryp, Timeout) != HAL_OK)\n  {\n    /* Disable the CRYP peripheral clock */\n    __HAL_CRYP_DISABLE(hcryp);\n\n    /* Change state & error code*/\n    hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;\n    hcryp->State = HAL_CRYP_STATE_READY;\n\n    /* Process unlocked */\n    __HAL_UNLOCK(hcryp);\n#if (USE_HAL_CRYP_REGISTER_CALLBACKS == 1)\n    /*Call registered error callback*/\n    hcryp->ErrorCallback(hcryp);\n#else\n    /*Call legacy weak error callback*/\n    HAL_CRYP_ErrorCallback(hcryp);\n#endif /* USE_HAL_CRYP_REGISTER_CALLBACKS */\n  }\n  /*Temporary CrypOutCount Value*/\n  outcount = hcryp->CrypOutCount;\n\n  if(((hcryp->Instance->SR & CRYP_FLAG_OFNE ) != 0x0U) && (outcount < ((hcryp->Size)/4U)))\n  {\n    /* Read the output block from the Output FIFO and put them in temporary buffer then get CrypOutBuff from temporary buffer  */\n    temp  = hcryp->Instance->DOUT;\n    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp;\n    hcryp->CrypOutCount++;\n    temp  = hcryp->Instance->DOUT;\n    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp;\n    hcryp->CrypOutCount++;\n    temp  = hcryp->Instance->DOUT;\n    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp;\n    hcryp->CrypOutCount++;\n    temp  = hcryp->Instance->DOUT;\n    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp;\n    hcryp->CrypOutCount++;\n  }\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief Set each @ref LL_USART_InitTypeDef field to default value.\n  * @param USART_InitStruct pointer to a @ref LL_USART_InitTypeDef structure\n  *                         whose fields will be set to default values.\n  * @retval None\n  */\n", "func_signal": "void LL_USART_StructInit(LL_USART_InitTypeDef *USART_InitStruct)", "code": "{\n  /* Set USART_InitStruct fields to default values */\n  USART_InitStruct->PrescalerValue      = LL_USART_PRESCALER_DIV1;\n  USART_InitStruct->BaudRate            = 9600U;\n  USART_InitStruct->DataWidth           = LL_USART_DATAWIDTH_8B;\n  USART_InitStruct->StopBits            = LL_USART_STOPBITS_1;\n  USART_InitStruct->Parity              = LL_USART_PARITY_NONE ;\n  USART_InitStruct->TransferDirection   = LL_USART_DIRECTION_TX_RX;\n  USART_InitStruct->HardwareFlowControl = LL_USART_HWCONTROL_NONE;\n  USART_InitStruct->OverSampling        = LL_USART_OVERSAMPLING_16;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_ll_usart.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Encryption in ECB/CBC & CTR Algorithm with AES Standard\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure\n  * @param  Timeout: specify Timeout value\n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef CRYP_AES_Encrypt(CRYP_HandleTypeDef *hcryp, uint32_t Timeout)", "code": "{\n  uint16_t outcount;  /* Temporary CrypOutCount Value */\n\n  /*  Set the Key*/\n  CRYP_SetKey(hcryp, hcryp->Init.KeySize);\n\n  if (hcryp->Init.Algorithm != CRYP_AES_ECB)\n  {\n    /* Set the Initialization Vector*/\n    hcryp->Instance->IV0LR = *(uint32_t*)(hcryp->Init.pInitVect);\n    hcryp->Instance->IV0RR = *(uint32_t*)(hcryp->Init.pInitVect+1);\n    hcryp->Instance->IV1LR = *(uint32_t*)(hcryp->Init.pInitVect+2);\n    hcryp->Instance->IV1RR = *(uint32_t*)(hcryp->Init.pInitVect+3);\n  }\n\n  /* Set the phase */\n  hcryp->Phase = CRYP_PHASE_PROCESS;\n\n  /* Enable CRYP */\n  __HAL_CRYP_ENABLE(hcryp);\n   /*Temporary CrypOutCount Value*/\n  outcount = hcryp->CrypOutCount;\n  \n  while((hcryp->CrypInCount < (hcryp->Size/4U)) && (outcount < (hcryp->Size/4U)))\n  {\n    /* Write plain Ddta and get cipher data */\n    CRYP_AES_ProcessData(hcryp,Timeout);\n    /*Temporary CrypOutCount Value*/\n    outcount = hcryp->CrypOutCount;\n  }\n\n  /* Disable CRYP */\n  __HAL_CRYP_DISABLE(hcryp);\n\n  /* Change the CRYP state */\n  hcryp->State = HAL_CRYP_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Initialize USART Clock related settings according to the\n  *         specified parameters in the USART_ClockInitStruct.\n  * @note   As some bits in USART configuration registers can only be written when the USART is disabled (USART_CR1_UE bit =0),\n  *         USART Peripheral should be in disabled state prior calling this function. Otherwise, ERROR result will be returned.\n  * @param  USARTx USART Instance\n  * @param  USART_ClockInitStruct pointer to a @ref LL_USART_ClockInitTypeDef structure\n  *         that contains the Clock configuration information for the specified USART peripheral.\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS: USART registers related to Clock settings are initialized according to USART_ClockInitStruct content\n  *          - ERROR: Problem occurred during USART Registers initialization\n  */\n", "func_signal": "ErrorStatus LL_USART_ClockInit(USART_TypeDef *USARTx, LL_USART_ClockInitTypeDef *USART_ClockInitStruct)", "code": "{\n  ErrorStatus status = SUCCESS;\n\n  /* Check USART Instance and Clock signal output parameters */\n  assert_param(IS_UART_INSTANCE(USARTx));\n  assert_param(IS_LL_USART_CLOCKOUTPUT(USART_ClockInitStruct->ClockOutput));\n\n  /* USART needs to be in disabled state, in order to be able to configure some bits in\n     CRx registers */\n  if (LL_USART_IsEnabled(USARTx) == 0U)\n  {\n    /*---------------------------- USART CR2 Configuration -----------------------*/\n    /* If Clock signal has to be output */\n    if (USART_ClockInitStruct->ClockOutput == LL_USART_CLOCK_DISABLE)\n    {\n      /* Deactivate Clock signal delivery :\n       * - Disable Clock Output:        USART_CR2_CLKEN cleared\n       */\n      LL_USART_DisableSCLKOutput(USARTx);\n    }\n    else\n    {\n      /* Ensure USART instance is USART capable */\n      assert_param(IS_USART_INSTANCE(USARTx));\n\n      /* Check clock related parameters */\n      assert_param(IS_LL_USART_CLOCKPOLARITY(USART_ClockInitStruct->ClockPolarity));\n      assert_param(IS_LL_USART_CLOCKPHASE(USART_ClockInitStruct->ClockPhase));\n      assert_param(IS_LL_USART_LASTBITCLKOUTPUT(USART_ClockInitStruct->LastBitClockPulse));\n\n      /*---------------------------- USART CR2 Configuration -----------------------\n       * Configure USARTx CR2 (Clock signal related bits) with parameters:\n       * - Enable Clock Output:         USART_CR2_CLKEN set\n       * - Clock Polarity:              USART_CR2_CPOL bit according to USART_ClockInitStruct->ClockPolarity value\n       * - Clock Phase:                 USART_CR2_CPHA bit according to USART_ClockInitStruct->ClockPhase value\n       * - Last Bit Clock Pulse Output: USART_CR2_LBCL bit according to USART_ClockInitStruct->LastBitClockPulse value.\n       */\n      MODIFY_REG(USARTx->CR2,\n                 USART_CR2_CLKEN | USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL,\n                 USART_CR2_CLKEN | USART_ClockInitStruct->ClockPolarity |\n                 USART_ClockInitStruct->ClockPhase | USART_ClockInitStruct->LastBitClockPulse);\n    }\n  }\n  /* Else (USART not in Disabled state => return ERROR */\n  else\n  {\n    status = ERROR;\n  }\n\n  return (status);\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_ll_usart.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Decryption in ECB/CBC & CTR mode with AES Standard using DMA mode\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module\n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef CRYP_AES_Decrypt_DMA(CRYP_HandleTypeDef *hcryp)", "code": "{\n  __IO uint32_t count = 0U;\n\n  /*  Key preparation for ECB/CBC */\n  if (hcryp->Init.Algorithm != CRYP_AES_CTR)\n  {\n    /* change ALGOMODE to key preparation for decryption*/\n    MODIFY_REG(hcryp->Instance->CR, CRYP_CR_ALGOMODE, CRYP_CR_ALGOMODE_AES_KEY );\n\n    /*  Set the Key*/\n    CRYP_SetKey(hcryp, hcryp->Init.KeySize);\n\n    /* Enable CRYP */\n    __HAL_CRYP_ENABLE(hcryp);\n\n    /* Wait for BUSY flag to be raised */\n    count = CRYP_TIMEOUT_KEYPREPARATION;\n    do\n    {\n      count-- ;\n      if(count == 0U)\n      {\n        /* Disable the CRYP peripheral clock */\n        __HAL_CRYP_DISABLE(hcryp);\n\n        /* Change state */\n        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;\n        hcryp->State = HAL_CRYP_STATE_READY;\n\n        /* Process unlocked */\n        __HAL_UNLOCK(hcryp);\n        return HAL_ERROR;\n      }\n    }\n    while(HAL_IS_BIT_SET(hcryp->Instance->SR, CRYP_FLAG_BUSY));\n\n    /* Turn back to ALGOMODE of the configuration */\n    MODIFY_REG(hcryp->Instance->CR, CRYP_CR_ALGOMODE, hcryp->Init.Algorithm );\n  }\n  else  /*Algorithm CTR */\n  {\n    /*  Set the Key*/\n    CRYP_SetKey(hcryp, hcryp->Init.KeySize);\n  }\n\n  if (hcryp->Init.Algorithm != CRYP_AES_ECB)\n  {\n    /* Set the Initialization Vector*/\n    hcryp->Instance->IV0LR = *(uint32_t*)(hcryp->Init.pInitVect);\n    hcryp->Instance->IV0RR = *(uint32_t*)(hcryp->Init.pInitVect+1);\n    hcryp->Instance->IV1LR = *(uint32_t*)(hcryp->Init.pInitVect+2);\n    hcryp->Instance->IV1RR = *(uint32_t*)(hcryp->Init.pInitVect+3);\n  }\n  /* Set the phase */\n  hcryp->Phase = CRYP_PHASE_PROCESS;\n\n  if(hcryp->Size != 0U)\n  {\n    /* Set the input and output addresses and start DMA transfer */\n    CRYP_SetDMAConfig(hcryp, (uint32_t)( hcryp->pCrypInBuffPtr), (hcryp->Size/4U), (uint32_t)(hcryp->pCrypOutBuffPtr));\n  }\n  else\n  {\n    /* Process unlocked */\n    __HAL_UNLOCK(hcryp);\n\n    /* Change the CRYP state */\n    hcryp->State = HAL_CRYP_STATE_READY;\n  }\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Handle CRYP hardware block Timeout when waiting for OFNE flag to be raised.\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module.\n  * @param  Timeout: Timeout duration.\n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef CRYP_WaitOnOFNEFlag(const CRYP_HandleTypeDef  *hcryp, uint32_t Timeout)", "code": "{\n  uint32_t tickstart;\n\n  /* Get timeout */\n  tickstart = HAL_GetTick();\n\n  while(HAL_IS_BIT_CLR(hcryp->Instance->SR, CRYP_FLAG_OFNE))\n  {\n    /* Check for the Timeout */\n    if(Timeout != HAL_MAX_DELAY)\n    {\n      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))\n      {\n        return HAL_ERROR;\n      }\n    }\n  }\n  return HAL_OK;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Initialize USART registers according to the specified\n  *         parameters in USART_InitStruct.\n  * @note   As some bits in USART configuration registers can only be written when the USART is disabled (USART_CR1_UE bit =0),\n  *         USART Peripheral should be in disabled state prior calling this function. Otherwise, ERROR result will be returned.\n  * @note   Baud rate value stored in USART_InitStruct BaudRate field, should be valid (different from 0).\n  * @param  USARTx USART Instance\n  * @param  USART_InitStruct pointer to a LL_USART_InitTypeDef structure\n  *         that contains the configuration information for the specified USART peripheral.\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content\n  *          - ERROR: Problem occurred during USART Registers initialization\n  */\n", "func_signal": "ErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)", "code": "{\n  ErrorStatus status = ERROR;\n  uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;\n\n  /* Check the parameters */\n  assert_param(IS_UART_INSTANCE(USARTx));\n  assert_param(IS_LL_USART_PRESCALER(USART_InitStruct->PrescalerValue));\n  assert_param(IS_LL_USART_BAUDRATE(USART_InitStruct->BaudRate));\n  assert_param(IS_LL_USART_DATAWIDTH(USART_InitStruct->DataWidth));\n  assert_param(IS_LL_USART_STOPBITS(USART_InitStruct->StopBits));\n  assert_param(IS_LL_USART_PARITY(USART_InitStruct->Parity));\n  assert_param(IS_LL_USART_DIRECTION(USART_InitStruct->TransferDirection));\n  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));\n  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));\n\n  /* USART needs to be in disabled state, in order to be able to configure some bits in\n     CRx registers */\n  if (LL_USART_IsEnabled(USARTx) == 0U)\n  {\n    /*---------------------------- USART CR1 Configuration ---------------------\n     * Configure USARTx CR1 (USART Word Length, Parity, Mode and Oversampling bits) with parameters:\n     * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value\n     * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value\n     * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value\n     * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.\n     */\n    MODIFY_REG(USARTx->CR1,\n               (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |\n                USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),\n               (USART_InitStruct->DataWidth | USART_InitStruct->Parity |\n                USART_InitStruct->TransferDirection | USART_InitStruct->OverSampling));\n\n    /*---------------------------- USART CR2 Configuration ---------------------\n     * Configure USARTx CR2 (Stop bits) with parameters:\n     * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.\n     * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().\n     */\n    LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);\n\n    /*---------------------------- USART CR3 Configuration ---------------------\n     * Configure USARTx CR3 (Hardware Flow Control) with parameters:\n     * - HardwareFlowControl: USART_CR3_RTSE, USART_CR3_CTSE bits according to USART_InitStruct->HardwareFlowControl value.\n     */\n    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);\n\n    /*---------------------------- USART BRR Configuration ---------------------\n     * Retrieve Clock frequency used for USART Peripheral\n     */\n    if (USARTx == USART1)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);\n    }\n    else if (USARTx == USART2)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);\n    }\n    else if (USARTx == USART3)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);\n    }\n    else if (USARTx == UART4)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);\n    }\n    else if (USARTx == UART5)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);\n    }\n    else if (USARTx == USART6)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);\n    }\n    else if (USARTx == UART7)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);\n    }\n    else if (USARTx == UART8)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);\n    }\n#if defined(UART9)\n    else if (USARTx == UART9)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);\n    }\n#endif /* UART9 */\n#if defined(USART10)\n    else if (USARTx == USART10)\n    {\n      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);\n    }\n#endif /* USART10 */\n    else\n    {\n      /* Nothing to do, as error code is already assigned to ERROR value */\n    }\n\n    /* Configure the USART Baud Rate :\n       - prescaler value is required\n       - valid baud rate value (different from 0) is required\n       - Peripheral clock as returned by RCC service, should be valid (different from 0).\n    */\n    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)\n        && (USART_InitStruct->BaudRate != 0U))\n    {\n      status = SUCCESS;\n      LL_USART_SetBaudRate(USARTx,\n                           periphclk,\n                           USART_InitStruct->PrescalerValue,\n                           USART_InitStruct->OverSampling,\n                           USART_InitStruct->BaudRate);\n\n      /* Check BRR is greater than or equal to 16d */\n      assert_param(IS_LL_USART_BRR_MIN(USARTx->BRR));\n\n      /* Check BRR is lower than or equal to 0xFFFF */\n      assert_param(IS_LL_USART_BRR_MAX(USARTx->BRR));\n    }\n\n    /*---------------------------- USART PRESC Configuration -----------------------\n     * Configure USARTx PRESC (Prescaler) with parameters:\n     * - PrescalerValue: USART_PRESC_PRESCALER bits according to USART_InitStruct->PrescalerValue value.\n     */\n    LL_USART_SetPrescaler(USARTx, USART_InitStruct->PrescalerValue);\n  }\n  /* Endif (=> USART not in Disabled state => return ERROR) */\n\n  return (status);\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_ll_usart.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Handle CRYP hardware block Timeout when waiting for BUSY flag to be raised.\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module.\n  * @param  Timeout: Timeout duration.\n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef CRYP_WaitOnBUSYFlag(const CRYP_HandleTypeDef *hcryp, uint32_t Timeout)", "code": "{\n  uint32_t tickstart;\n\n  /* Get timeout */\n  tickstart = HAL_GetTick();\n\n  while(HAL_IS_BIT_SET(hcryp->Instance->SR, CRYP_FLAG_BUSY))\n  {\n    /* Check for the Timeout */\n    if(Timeout != HAL_MAX_DELAY)\n    {\n      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))\n      {\n        return HAL_ERROR;\n      }\n    }\n  }\n  return HAL_OK;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Decryption in DMA mode.\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module\n  * @param  Input: Pointer to the input buffer (ciphertext )\n  * @param  Size: Length of the plaintext buffer in word\n  * @param  Output: Pointer to the output buffer(plaintext)\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_CRYP_Decrypt_DMA(CRYP_HandleTypeDef *hcryp, uint32_t *Input, uint16_t Size, uint32_t *Output)", "code": "{\n  uint32_t algo;\n  HAL_StatusTypeDef status = HAL_OK;\n\n  if(hcryp->State == HAL_CRYP_STATE_READY)\n  {\n    /* Change state Busy */\n    hcryp->State = HAL_CRYP_STATE_BUSY;\n\n    /* Process locked */\n    __HAL_LOCK(hcryp);\n\n    /*  Reset CrypInCount, CrypOutCount and Initialize pCrypInBuffPtr, pCrypOutBuffPtr and Size parameters*/\n    hcryp->CrypInCount = 0U;\n    hcryp->CrypOutCount = 0U;\n    hcryp->pCrypInBuffPtr = Input;\n    hcryp->pCrypOutBuffPtr = Output;\n\n    /*  Calculate Size parameter in Byte*/\n    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)\n    {\n      hcryp->Size = Size * 4U;\n    }\n    else\n    {\n      hcryp->Size = Size;\n    }\n\n    /* Set decryption operating mode*/\n    MODIFY_REG(hcryp->Instance->CR, CRYP_CR_ALGODIR, CRYP_OPERATINGMODE_DECRYPT);\n\n    /* algo get algorithm selected */\n    algo = hcryp->Instance->CR & CRYP_CR_ALGOMODE;\n\n    switch(algo)\n    {\n    case CRYP_DES_ECB:\n    case CRYP_DES_CBC:\n    case CRYP_TDES_ECB:\n    case CRYP_TDES_CBC:\n\n      /*Set Key */\n      hcryp->Instance->K1LR = *(uint32_t*)(hcryp->Init.pKey);\n      hcryp->Instance->K1RR = *(uint32_t*)(hcryp->Init.pKey+1);\n      if ((hcryp->Init.Algorithm == CRYP_TDES_ECB) || (hcryp->Init.Algorithm == CRYP_TDES_CBC))\n      {\n        hcryp->Instance->K2LR = *(uint32_t*)(hcryp->Init.pKey+2);\n        hcryp->Instance->K2RR = *(uint32_t*)(hcryp->Init.pKey+3);\n        hcryp->Instance->K3LR = *(uint32_t*)(hcryp->Init.pKey+4);\n        hcryp->Instance->K3RR = *(uint32_t*)(hcryp->Init.pKey+5);\n      }\n\n      /* Set the Initialization Vector*/\n      if ((hcryp->Init.Algorithm == CRYP_DES_CBC) || (hcryp->Init.Algorithm == CRYP_TDES_CBC))\n      {\n        hcryp->Instance->IV0LR = *(uint32_t*)(hcryp->Init.pInitVect);\n        hcryp->Instance->IV0RR = *(uint32_t*)(hcryp->Init.pInitVect+1);\n      }\n\n      /* Flush FIFO */\n      HAL_CRYP_FIFO_FLUSH(hcryp);\n\n      /* Set the phase */\n      hcryp->Phase = CRYP_PHASE_PROCESS;\n\n      /* Start DMA process transfer for DES/TDES */\n      CRYP_SetDMAConfig(hcryp, (uint32_t)( hcryp->pCrypInBuffPtr), (hcryp->Size/4U), (uint32_t)(hcryp->pCrypOutBuffPtr));\n      break;\n\n    case CRYP_AES_ECB:\n    case CRYP_AES_CBC:\n    case CRYP_AES_CTR:\n\n      /* AES decryption */\n      status = CRYP_AES_Decrypt_DMA(hcryp);\n      break;\n\n    default:\n      hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;\n      status =  HAL_ERROR;\n      break;\n    }\n  }\n  else\n  {\n    /* Busy error code field */\n    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;\n    status = HAL_ERROR;\n  }\n\n  /* Return function status */\n  return status;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  DMA CRYP communication error callback.\n  * @param  hdma: DMA handle\n  * @retval None\n  */\n", "func_signal": "static void CRYP_DMAError(DMA_HandleTypeDef *hdma)", "code": "{\n  CRYP_HandleTypeDef* hcryp = (CRYP_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;\n\n  /* Change the CRYP peripheral state */\n  hcryp->State= HAL_CRYP_STATE_READY;\n\n  /* DMA error code field */\n  hcryp->ErrorCode |= HAL_CRYP_ERROR_DMA;\n\n  /* Call error callback */\n#if (USE_HAL_CRYP_REGISTER_CALLBACKS == 1)\n  /*Call registered error callback*/\n  hcryp->ErrorCallback(hcryp);\n#else\n  /*Call legacy weak error callback*/\n  HAL_CRYP_ErrorCallback(hcryp);\n#endif /* USE_HAL_CRYP_REGISTER_CALLBACKS */\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Decryption in itnterrupt mode.\n  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains\n  *         the configuration information for CRYP module\n  * @param  Input: Pointer to the input buffer (ciphertext )\n  * @param  Size: Length of the plaintext buffer in word.\n  * @param  Output: Pointer to the output buffer(plaintext)\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_CRYP_Decrypt_IT(CRYP_HandleTypeDef *hcryp, uint32_t *Input, uint16_t Size, uint32_t *Output)", "code": "{\n  uint32_t algo;\n  HAL_StatusTypeDef status = HAL_OK;\n\n  if(hcryp->State == HAL_CRYP_STATE_READY)\n  {\n    /* Change state Busy */\n    hcryp->State = HAL_CRYP_STATE_BUSY;\n\n    /* Process locked */\n    __HAL_LOCK(hcryp);\n\n    /*  Reset CrypInCount, CrypOutCount and Initialize pCrypInBuffPtr, pCrypOutBuffPtr and Size parameters*/\n    hcryp->CrypInCount = 0U;\n    hcryp->CrypOutCount = 0U;\n    hcryp->pCrypInBuffPtr = Input;\n    hcryp->pCrypOutBuffPtr = Output;\n\n    /*  Calculate Size parameter in Byte*/\n    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)\n    {\n      hcryp->Size = Size * 4U;\n    }\n    else\n    {\n      hcryp->Size = Size;\n    }\n\n    /* Set decryption operating mode*/\n    MODIFY_REG(hcryp->Instance->CR, CRYP_CR_ALGODIR,CRYP_OPERATINGMODE_DECRYPT);\n\n    /* algo get algorithm selected */\n    algo = hcryp->Instance->CR & CRYP_CR_ALGOMODE;\n\n    switch(algo)\n    {\n    case CRYP_DES_ECB:\n    case CRYP_DES_CBC:\n    case CRYP_TDES_ECB:\n    case CRYP_TDES_CBC:\n\n      /*Set Key */\n      hcryp->Instance->K1LR = *(uint32_t*)(hcryp->Init.pKey);\n      hcryp->Instance->K1RR = *(uint32_t*)(hcryp->Init.pKey+1);\n      if ((hcryp->Init.Algorithm == CRYP_TDES_ECB) || (hcryp->Init.Algorithm == CRYP_TDES_CBC))\n      {\n        hcryp->Instance->K2LR = *(uint32_t*)(hcryp->Init.pKey+2);\n        hcryp->Instance->K2RR = *(uint32_t*)(hcryp->Init.pKey+3);\n        hcryp->Instance->K3LR = *(uint32_t*)(hcryp->Init.pKey+4);\n        hcryp->Instance->K3RR = *(uint32_t*)(hcryp->Init.pKey+5);\n      }\n\n      /* Set the Initialization Vector*/\n      if ((hcryp->Init.Algorithm == CRYP_DES_CBC) || (hcryp->Init.Algorithm == CRYP_TDES_CBC))\n      {\n        hcryp->Instance->IV0LR = *(uint32_t*)(hcryp->Init.pInitVect);\n        hcryp->Instance->IV0RR = *(uint32_t*)(hcryp->Init.pInitVect+1);\n      }\n      /* Flush FIFO */\n      HAL_CRYP_FIFO_FLUSH(hcryp);\n\n      /* Set the phase */\n      hcryp->Phase = CRYP_PHASE_PROCESS;\n\n      /* Enable interrupts */\n      __HAL_CRYP_ENABLE_IT(hcryp, CRYP_IT_INI | CRYP_IT_OUTI);\n\n      /* Enable CRYP and start DES/TDES process*/\n      __HAL_CRYP_ENABLE(hcryp);\n\n      break;\n\n    case CRYP_AES_ECB:\n    case CRYP_AES_CBC:\n    case CRYP_AES_CTR:\n\n      /* AES decryption */\n      status = CRYP_AES_Decrypt_IT(hcryp);\n      break;\n\n    default:\n      hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;\n      status = HAL_ERROR;\n      break;\n    }\n  }\n  else\n  {\n    /* Busy error code field */\n    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;\n    status = HAL_ERROR;\n  }\n\n  /* Return function status */\n  return status;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Unregister an CRYP Callback\n  *         CRYP callabck is redirected to the weak predefined callback\n  * @param hcryp cryp handle\n  * @param CallbackID ID of the callback to be unregistered\n  *        This parameter can be one of the following values:\n  *          @arg @ref HAL_CRYP_INPUT_COMPLETE_CB_ID Input FIFO transfer completed callback ID\n  *          @arg @ref HAL_CRYP_OUTPUT_COMPLETE_CB_ID Output FIFO transfer completed callback ID\n  *          @arg @ref HAL_CRYP_ERROR_CB_ID Rx Half Error callback ID\n  *          @arg @ref HAL_CRYP_MSPINIT_CB_ID MspInit callback ID\n  *          @arg @ref HAL_CRYP_MSPDEINIT_CB_ID MspDeInit callback ID\n  * @retval status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_CRYP_UnRegisterCallback(CRYP_HandleTypeDef *hcryp, HAL_CRYP_CallbackIDTypeDef CallbackID)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  /* Process locked */\n  __HAL_LOCK(hcryp);\n\n  if(hcryp->State == HAL_CRYP_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n    case HAL_CRYP_INPUT_COMPLETE_CB_ID :\n      hcryp->InCpltCallback = HAL_CRYP_InCpltCallback;  /* Legacy weak  InCpltCallback  */\n      break;\n\n    case HAL_CRYP_OUTPUT_COMPLETE_CB_ID :\n      hcryp->OutCpltCallback = HAL_CRYP_OutCpltCallback;         /* Legacy weak OutCpltCallback       */\n      break;\n\n    case HAL_CRYP_ERROR_CB_ID :\n      hcryp->ErrorCallback = HAL_CRYP_ErrorCallback;           /* Legacy weak ErrorCallback        */\n      break;\n\n    case HAL_CRYP_MSPINIT_CB_ID :\n      hcryp->MspInitCallback = HAL_CRYP_MspInit;\n      break;\n\n    case HAL_CRYP_MSPDEINIT_CB_ID :\n      hcryp->MspDeInitCallback = HAL_CRYP_MspDeInit;\n      break;\n\n    default :\n      /* Update the error code */\n      hcryp->ErrorCode |= HAL_CRYP_ERROR_INVALID_CALLBACK;\n      /* Return error status */\n      status =  HAL_ERROR;\n      break;\n    }\n  }\n  else if(hcryp->State == HAL_CRYP_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n    case HAL_CRYP_MSPINIT_CB_ID :\n      hcryp->MspInitCallback = HAL_CRYP_MspInit;\n      break;\n\n    case HAL_CRYP_MSPDEINIT_CB_ID :\n      hcryp->MspDeInitCallback = HAL_CRYP_MspDeInit;\n      break;\n\n    default :\n      /* Update the error code */\n      hcryp->ErrorCode |= HAL_CRYP_ERROR_INVALID_CALLBACK;\n      /* Return error status */\n      status =  HAL_ERROR;\n      break;\n    }\n  }\n  else\n  {\n    /* Update the error code */\n    hcryp->ErrorCode |= HAL_CRYP_ERROR_INVALID_CALLBACK;\n    /* Return error status */\n    status =  HAL_ERROR;\n  }\n\n  /* Release Lock */\n  __HAL_UNLOCK(hcryp);\n\n  return status;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  Register a User CRYP Callback\n  *         To be used instead of the weak predefined callback\n  * @param hcryp cryp handle\n  * @param CallbackID ID of the callback to be registered\n  *        This parameter can be one of the following values:\n  *          @arg @ref HAL_CRYP_INPUT_COMPLETE_CB_ID Input FIFO transfer completed callback ID\n  *          @arg @ref HAL_CRYP_OUTPUT_COMPLETE_CB_ID Output FIFO transfer completed callback ID\n  *          @arg @ref HAL_CRYP_ERROR_CB_ID Rx Half Error callback ID\n  *          @arg @ref HAL_CRYP_MSPINIT_CB_ID MspInit callback ID\n  *          @arg @ref HAL_CRYP_MSPDEINIT_CB_ID MspDeInit callback ID\n  * @param pCallback pointer to the Callback function\n  * @retval status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_CRYP_RegisterCallback(CRYP_HandleTypeDef *hcryp, HAL_CRYP_CallbackIDTypeDef CallbackID, pCRYP_CallbackTypeDef pCallback)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  if(pCallback == NULL)\n  {\n    /* Update the error code */\n    hcryp->ErrorCode |= HAL_CRYP_ERROR_INVALID_CALLBACK;\n\n    return HAL_ERROR;\n  }\n  /* Process locked */\n  __HAL_LOCK(hcryp);\n\n  if(hcryp->State == HAL_CRYP_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n    case HAL_CRYP_INPUT_COMPLETE_CB_ID :\n      hcryp->InCpltCallback = pCallback;\n      break;\n\n    case HAL_CRYP_OUTPUT_COMPLETE_CB_ID :\n      hcryp->OutCpltCallback = pCallback;\n      break;\n\n    case HAL_CRYP_ERROR_CB_ID :\n      hcryp->ErrorCallback = pCallback;\n      break;\n\n    case HAL_CRYP_MSPINIT_CB_ID :\n      hcryp->MspInitCallback = pCallback;\n      break;\n\n    case HAL_CRYP_MSPDEINIT_CB_ID :\n      hcryp->MspDeInitCallback = pCallback;\n      break;\n\n    default :\n      /* Update the error code */\n      hcryp->ErrorCode |= HAL_CRYP_ERROR_INVALID_CALLBACK;\n      /* Return error status */\n      status =  HAL_ERROR;\n      break;\n    }\n  }\n  else if(hcryp->State == HAL_CRYP_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n    case HAL_CRYP_MSPINIT_CB_ID :\n      hcryp->MspInitCallback = pCallback;\n      break;\n\n    case HAL_CRYP_MSPDEINIT_CB_ID :\n      hcryp->MspDeInitCallback = pCallback;\n      break;\n\n    default :\n      /* Update the error code */\n      hcryp->ErrorCode |= HAL_CRYP_ERROR_INVALID_CALLBACK;\n      /* Return error status */\n      status =  HAL_ERROR;\n      break;\n    }\n  }\n  else\n  {\n    /* Update the error code */\n    hcryp->ErrorCode |= HAL_CRYP_ERROR_INVALID_CALLBACK;\n    /* Return error status */\n    status =  HAL_ERROR;\n  }\n\n  /* Release Lock */\n  __HAL_UNLOCK(hcryp);\n\n  return status;\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/**\n  * @brief  DMA CRYP input data process complete callback.\n  * @param  hdma: DMA handle\n  * @retval None\n  */\n", "func_signal": "static void CRYP_DMAInCplt(DMA_HandleTypeDef *hdma)", "code": "{\n  CRYP_HandleTypeDef* hcryp = (CRYP_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;\n\n  /* Disable the DMA transfer for input FIFO request by resetting the DIEN bit\n  in the DMACR register */\n  hcryp->Instance->DMACR &= (uint32_t)(~CRYP_DMACR_DIEN);\n\n  /* Call input data transfer complete callback */\n#if (USE_HAL_CRYP_REGISTER_CALLBACKS == 1)\n        /*Call registered Input complete callback*/\n        hcryp->InCpltCallback(hcryp);\n#else\n        /*Call legacy weak Input complete callback*/\n        HAL_CRYP_InCpltCallback(hcryp);\n#endif /* USE_HAL_CRYP_REGISTER_CALLBACKS */\n}", "path": "Arduino_Core_STM32/system/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cryp.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "stm32duino/Arduino_Core_STM32", "stars": 2575, "license": "other", "language": "c", "size": 108962}
{"docstring": "/// <summary>\n/// Delete Arbitrary Read Write Helper Object in NonPagedPoolNx\n/// </summary>\n/// <param name=\"HelperObjectIo\">The pointer to ARW_HELPER_OBJECT_IO structure</param>\n/// <returns>INT</returns>\n", "func_signal": "NTSTATUS\nDeleteArbitraryReadWriteHelperObjecNonPagedPoolNx(\n    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo\n)", "code": "{\n    PVOID HelperObjectAddress = NULL;\n    INT Index = STATUS_INVALID_INDEX;\n    NTSTATUS Status = STATUS_SUCCESS;\n\n    __try\n    {\n        //\n        // Verify if the buffer resides in user mode\n        //\n\n        ProbeForRead(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));\n\n        //\n        // Make a local copy of the data structure to avoid race conditions\n        //\n\n        HelperObjectAddress = HelperObjectIo->HelperObjectAddress;\n\n        DbgPrint(\"[+] HelperObjectIo->HelperObjectAddress: 0x%p\\n\", HelperObjectAddress);\n\n        //\n        // Get index by pointer\n        //\n\n        Index = GetIndexFromPointer(HelperObjectAddress);\n\n        if (Index == STATUS_INVALID_INDEX)\n        {\n            //\n            // Failed to find index from pointer\n            //\n\n            DbgPrint(\"[-] Unable to find index from pointer: 0x%p\\n\", HelperObjectAddress);\n\n            Status = STATUS_INVALID_INDEX;\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] Index: 0x%X Pointer: 0x%p\\n\", Index, HelperObjectAddress);\n        }\n\n        if (g_ARWHelperObjectNonPagedPoolNx[Index]->Name)\n        {\n            //\n            // Free the pool memory for name buffer\n            //\n\n            ExFreePoolWithTag(g_ARWHelperObjectNonPagedPoolNx[Index]->Name, POOL_TAG);\n        }\n\n        //\n        // Free up the object at index\n        //\n\n        ExFreePoolWithTag(g_ARWHelperObjectNonPagedPoolNx[Index], POOL_TAG);\n\n        //\n        // Set to NULL to avoid dangling pointer\n        //\n\n        g_ARWHelperObjectNonPagedPoolNx[Index] = NULL;\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Double Fetch Ioctl Handler\n/// </summary>\n/// <param name=\"Irp\">The pointer to IRP</param>\n/// <param name=\"IrpSp\">The pointer to IO_STACK_LOCATION structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nDoubleFetchIoctlHandler(\n    _In_ PIRP Irp,\n    _In_ PIO_STACK_LOCATION IrpSp\n)", "code": "{\n    PDOUBLE_FETCH UserDoubleFetch = NULL;\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n\n    UNREFERENCED_PARAMETER(Irp);\n    PAGED_CODE();\n\n    UserDoubleFetch = (PDOUBLE_FETCH)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;\n\n    if (UserDoubleFetch)\n    {\n        Status = TriggerDoubleFetch(UserDoubleFetch);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/DoubleFetch.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Memory Disclosure NonPagedPoolNx Ioctl Handler\n/// </summary>\n/// <param name=\"Irp\">The pointer to IRP</param>\n/// <param name=\"IrpSp\">The pointer to IO_STACK_LOCATION structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nMemoryDisclosureNonPagedPoolNxIoctlHandler(\n    _In_ PIRP Irp,\n    _In_ PIO_STACK_LOCATION IrpSp\n)", "code": "{\n    SIZE_T Size = 0;\n    PVOID UserOutputBuffer = NULL;\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n\n    UNREFERENCED_PARAMETER(Irp);\n    PAGED_CODE();\n\n    UserOutputBuffer = Irp->UserBuffer;\n    Size = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;\n\n    if (UserOutputBuffer)\n    {\n        Status = TriggerMemoryDisclosureNonPagedPoolNx(UserOutputBuffer, Size);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/MemoryDisclosureNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Memory Disclosure NonPagedPool Ioctl Handler\n/// </summary>\n/// <param name=\"Irp\">The pointer to IRP</param>\n/// <param name=\"IrpSp\">The pointer to IO_STACK_LOCATION structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nMemoryDisclosureNonPagedPoolIoctlHandler(\n    _In_ PIRP Irp,\n    _In_ PIO_STACK_LOCATION IrpSp\n)", "code": "{\n    SIZE_T Size = 0;\n    PVOID UserOutputBuffer = NULL;\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n\n    UNREFERENCED_PARAMETER(Irp);\n    PAGED_CODE();\n\n    UserOutputBuffer = Irp->UserBuffer;\n    Size = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;\n\n    if (UserOutputBuffer)\n    {\n        Status = TriggerMemoryDisclosureNonPagedPool(UserOutputBuffer, Size);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/MemoryDisclosureNonPagedPool.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Create Arbitrary Read Write Helper Object in NonPagedPoolNx\n/// </summary>\n/// <param name=\"HelperObjectIo\">The pointer to ARW_HELPER_OBJECT_IO structure</param>\n/// <returns>INT</returns>\n", "func_signal": "NTSTATUS\nCreateArbitraryReadWriteHelperObjectNonPagedPoolNx(\n    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo\n)", "code": "{\n    PVOID Name = NULL;\n    SIZE_T Length = 0;\n    NTSTATUS Status = STATUS_SUCCESS;\n    INT FreeIndex = STATUS_INVALID_INDEX;\n    PARW_HELPER_OBJECT_NON_PAGED_POOL_NX ARWHelperObject = NULL;\n\n    __try\n    {\n        //\n        // Verify if the buffer resides in user mode\n        //\n\n        ProbeForRead(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));\n\n        //\n        // Make a local copy of the data structure to avoid race conditions\n        //\n\n        Length = HelperObjectIo->Length;\n\n        DbgPrint(\"[+] Name Length: 0x%X\\n\", Length);\n\n        //\n        // Get a free index\n        //\n\n        FreeIndex = GetFreeIndex();\n\n        if (FreeIndex == STATUS_INVALID_INDEX)\n        {\n            //\n            // Failed to get a free index\n            //\n\n            Status = STATUS_INVALID_INDEX;\n            DbgPrint(\"[-] Unable to find FreeIndex: 0x%X\\n\", Status);\n\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] FreeIndex: 0x%X\\n\", FreeIndex);\n        }\n\n        DbgPrint(\"[+] Allocating Pool chunk for ARWHelperObject\\n\");\n\n        //\n        // Allocate Pool chunk for ARWHelperObject\n        //\n\n        ARWHelperObject = (PARW_HELPER_OBJECT_NON_PAGED_POOL_NX)ExAllocatePoolWithTag(\n            NonPagedPoolNx,\n            sizeof(ARW_HELPER_OBJECT_NON_PAGED_POOL_NX),\n            POOL_TAG\n        );\n\n        if (!ARWHelperObject)\n        {\n            //\n            // Unable to allocate Pool chunk for ARWHelperObject\n            //\n\n            DbgPrint(\"[-] Unable to allocate Pool chunk for ARWHelperObject\\n\");\n\n            Status = STATUS_NO_MEMORY;\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] ARWHelperObject Pool Tag: %s\\n\", STRINGIFY(POOL_TAG));\n            DbgPrint(\"[+] ARWHelperObject Pool Type: %s\\n\", STRINGIFY(NonPagedPoolNx));\n            DbgPrint(\"[+] ARWHelperObject Pool Size: 0x%X\\n\", sizeof(ARW_HELPER_OBJECT_NON_PAGED_POOL_NX));\n            DbgPrint(\"[+] ARWHelperObject Pool Chunk: 0x%p\\n\", ARWHelperObject);\n        }\n\n        DbgPrint(\"[+] Allocating Pool chunk for Name\\n\");\n\n        //\n        // Allocate Pool chunk for Name\n        //\n\n        Name = ExAllocatePoolWithTag(NonPagedPoolNx, Length, POOL_TAG);\n\n        if (!Name)\n        {\n            //\n            // Unable to allocate Pool chunk for Name\n            //\n\n            DbgPrint(\"[-] Unable to allocate Pool chunk for Name\\n\");\n\n            Status = STATUS_NO_MEMORY;\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] Name Pool Tag: %s\\n\", STRINGIFY(POOL_TAG));\n            DbgPrint(\"[+] Name Pool Type: %s\\n\", STRINGIFY(NonPagedPoolNx));\n            DbgPrint(\"[+] Name Pool Size: 0x%X\\n\", Length);\n            DbgPrint(\"[+] Name Pool Chunk: 0x%p\\n\", Name);\n        }\n\n        //\n        // Initialize the kernel buffer\n        //\n\n        RtlFillMemory(Name, (SIZE_T)Length, 0);\n\n        //\n        // Initialize the kernel structure\n        //\n\n        ARWHelperObject->Name = Name;\n        ARWHelperObject->Length = Length;\n\n        DbgPrint(\"[+] ARWHelperObject->Name: 0x%p\\n\", ARWHelperObject->Name);\n        DbgPrint(\"[+] ARWHelperObject->Length: 0x%X\\n\", ARWHelperObject->Length);\n\n        g_ARWHelperObjectNonPagedPoolNx[FreeIndex] = ARWHelperObject;\n\n        //\n        // Verify if the buffer resides in user mode\n        //\n\n        ProbeForWrite(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));\n\n        //\n        // Write the object address to user mode for book keeping\n        //\n\n        HelperObjectIo->HelperObjectAddress = ARWHelperObject;\n\n        DbgPrint(\"[+] HelperObjectIo->HelperObjectAddress: 0x%p\\n\", HelperObjectIo->HelperObjectAddress);\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Trigger the Arbitrary Write Vulnerability\n/// </summary>\n/// <param name=\"UserWriteWhatWhere\">The pointer to WRITE_WHAT_WHERE structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nTriggerArbitraryWrite(\n    _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere\n)", "code": "{\n    PULONG_PTR What = NULL;\n    PULONG_PTR Where = NULL;\n    NTSTATUS Status = STATUS_SUCCESS;\n\n    PAGED_CODE();\n\n    __try\n    {\n        //\n        // Verify if the buffer resides in user mode\n        //\n\n        ProbeForRead((PVOID)UserWriteWhatWhere, sizeof(WRITE_WHAT_WHERE), (ULONG)__alignof(UCHAR));\n\n        What = UserWriteWhatWhere->What;\n        Where = UserWriteWhatWhere->Where;\n\n        DbgPrint(\"[+] UserWriteWhatWhere: 0x%p\\n\", UserWriteWhatWhere);\n        DbgPrint(\"[+] WRITE_WHAT_WHERE Size: 0x%X\\n\", sizeof(WRITE_WHAT_WHERE));\n        DbgPrint(\"[+] UserWriteWhatWhere->What: 0x%p\\n\", What);\n        DbgPrint(\"[+] UserWriteWhatWhere->Where: 0x%p\\n\", Where);\n\n#ifdef SECURE\n        //\n        // Secure Note: This is secure because the developer is properly validating if address\n        // pointed by 'Where' and 'What' value resides in User mode by calling ProbeForRead()/\n        // ProbeForWrite() routine before performing the write operation\n        //\n\n        ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR));\n        ProbeForWrite((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR));\n\n        *(Where) = *(What);\n#else\n        DbgPrint(\"[+] Triggering Arbitrary Write\\n\");\n\n        //\n        // Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability\n        // because the developer is writing the value pointed by 'What' to memory location\n        // pointed by 'Where' without properly validating if the values pointed by 'Where'\n        // and 'What' resides in User mode\n        //\n\n        *(Where) = *(What);\n#endif\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    //\n    // There is one more hidden vulnerability. Find it out.\n    //\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryWrite.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/**\n * @param[in] io user space buffer\n * @return status code\n */\n", "func_signal": "int uninitialized_memory_stack_ioctl_handler(struct hevd_io *io)", "code": "{\n    size_t size = 0;\n    void *user_buffer = NULL;\n    int status = -EINVAL;\n\n    user_buffer = io->input_buffer;\n    size = io->input_buffer_length;\n\n    if (user_buffer)\n    {\n        status = trigger_uninitialized_memory_stack(user_buffer, size);\n    }\n\n    return status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Linux/UninitializedMemoryStack.c", "commit_date": "2019-11-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Trigger the Memory Disclosure in NonPagedPool Vulnerability\n/// </summary>\n/// <param name=\"UserOutputBuffer\">The pointer to user mode output buffer</param>\n/// <param name=\"Size\">Size of the user mode buffer</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nTriggerMemoryDisclosureNonPagedPool(\n    _In_ PVOID UserOutputBuffer,\n    _In_ SIZE_T Size\n)", "code": "{\n    PVOID KernelBuffer = NULL;\n    NTSTATUS Status = STATUS_SUCCESS;\n\n    PAGED_CODE();\n\n    __try\n    {\n        DbgPrint(\"[+] Allocating Pool chunk\\n\");\n\n        //\n        // Allocate Pool chunk\n        //\n\n        KernelBuffer = ExAllocatePoolWithTag(\n            NonPagedPool,\n            (SIZE_T)POOL_BUFFER_SIZE,\n            (ULONG)POOL_TAG\n        );\n\n        if (!KernelBuffer)\n        {\n            //\n            // Unable to allocate Pool chunk\n            //\n\n            DbgPrint(\"[-] Unable to allocate Pool chunk\\n\");\n\n            Status = STATUS_NO_MEMORY;\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] Pool Tag: %s\\n\", STRINGIFY(POOL_TAG));\n            DbgPrint(\"[+] Pool Type: %s\\n\", STRINGIFY(NonPagedPool));\n            DbgPrint(\"[+] Pool Size: 0x%X\\n\", (SIZE_T)POOL_BUFFER_SIZE);\n            DbgPrint(\"[+] Pool Chunk: 0x%p\\n\", KernelBuffer);\n        }\n\n        //\n        // Work on the kernel buffer\n        //\n\n        RtlFillMemory(KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE, 0x41);\n\n        //\n        // After working on the kernel buffer, it's time to give\n        // the output to the user\n        //\n\n        //\n        // Verify if the output buffer resides in user mode\n        //\n\n        ProbeForWrite(UserOutputBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR));\n\n        DbgPrint(\"[+] UserOutputBuffer: 0x%p\\n\", UserOutputBuffer);\n        DbgPrint(\"[+] UserOutputBuffer Size: 0x%X\\n\", Size);\n        DbgPrint(\"[+] KernelBuffer: 0x%p\\n\", KernelBuffer);\n        DbgPrint(\"[+] KernelBuffer Size: 0x%X\\n\", (SIZE_T)POOL_BUFFER_SIZE);\n\n#ifdef SECURE\n        //\n        // Secure Note: This is secure because the developer is passing a size\n        // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy().\n        // Hence, there will be no out of bound read of kernel mode memory\n        //\n\n        RtlCopyMemory(UserOutputBuffer, KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE);\n#else\n        DbgPrint(\"[+] Triggering Memory Disclosure in NonPagedPool\\n\");\n\n        //\n        // Vulnerability Note: This is a vanilla memory disclosure vulnerability\n        // because the developer is passing the user supplied value directly to\n        // RtlCopyMemory()/memcpy() without validating if the size is greater or\n        // equal to the size of the allocated Pool chunk which will result in reading\n        // more data from kernel mode and passing to user mode memory which causes memory\n        // disclosure vulnerability\n        //\n\n        RtlCopyMemory(UserOutputBuffer, KernelBuffer, Size);\n#endif\n\n        if (KernelBuffer)\n        {\n            DbgPrint(\"[+] Freeing Pool chunk\\n\");\n            DbgPrint(\"[+] Pool Tag: %s\\n\", STRINGIFY(POOL_TAG));\n            DbgPrint(\"[+] Pool Chunk: 0x%p\\n\", KernelBuffer);\n\n            //\n            // Free the allocated Pool chunk\n            //\n\n            ExFreePoolWithTag(KernelBuffer, (ULONG)POOL_TAG);\n            KernelBuffer = NULL;\n        }\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/MemoryDisclosureNonPagedPool.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Trigger the Double Fetch Vulnerability\n/// </summary>\n/// <param name=\"UserDoubleFetch\">The pointer to user mode buffer</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "__declspec(safebuffers)\nNTSTATUS\nTriggerDoubleFetch(\n    _In_ PDOUBLE_FETCH UserDoubleFetch\n)", "code": "{\n    NTSTATUS Status = STATUS_SUCCESS;\n    ULONG KernelBuffer[BUFFER_SIZE] = { 0 };\n\n#ifdef SECURE\n    PVOID UserBuffer = NULL;\n    SIZE_T UserBufferSize = 0;\n#endif\n\n    PAGED_CODE();\n\n    __try\n    {\n        //\n        // Verify if the buffer resides in user mode\n        //\n\n        ProbeForRead(UserDoubleFetch, sizeof(DOUBLE_FETCH), (ULONG)__alignof(UCHAR));\n\n        DbgPrint(\"[+] UserDoubleFetch: 0x%p\\n\", UserDoubleFetch);\n        DbgPrint(\"[+] KernelBuffer: 0x%p\\n\", &KernelBuffer);\n        DbgPrint(\"[+] KernelBuffer Size: 0x%X\\n\", sizeof(KernelBuffer));\n\n#ifdef SECURE\n        UserBuffer = UserDoubleFetch->Buffer;\n        UserBufferSize = UserDoubleFetch->Size;\n\n        DbgPrint(\"[+] UserDoubleFetch->Buffer: 0x%p\\n\", UserBuffer);\n        DbgPrint(\"[+] UserDoubleFetch->Size: 0x%X\\n\", UserBufferSize);\n\n        if (UserBufferSize > sizeof(KernelBuffer))\n        {\n            DbgPrint(\"[-] Invalid Buffer Size: 0x%X\\n\", UserBufferSize);\n\n            Status = STATUS_INVALID_PARAMETER;\n            return Status;\n        }\n\n        //\n        // Secure Note: This is secure because the developer is fetching\n        // 'UserDoubleFetch->Buffer' and 'UserDoubleFetch->Size' from user\n        // mode just once and storing it in a temporary variable. Later, this\n        // stored values are passed to RtlCopyMemory()/memcpy(). Hence, there\n        // will be no race condition\n        //\n\n        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserBufferSize);\n#else\n        DbgPrint(\"[+] UserDoubleFetch->Buffer: 0x%p\\n\", UserDoubleFetch->Buffer);\n        DbgPrint(\"[+] UserDoubleFetch->Size: 0x%X\\n\", UserDoubleFetch->Size);\n\n        if (UserDoubleFetch->Size > sizeof(KernelBuffer))\n        {\n            DbgPrint(\"[-] Invalid Buffer Size: 0x%X\\n\", UserDoubleFetch->Size);\n\n            Status = STATUS_INVALID_PARAMETER;\n            return Status;\n        }\n\n        DbgPrint(\"[+] Triggering Double Fetch\\n\");\n\n        //\n        // Vulnerability Note: This is a vanilla Double Fetch vulnerability because the\n        // developer is fetching 'UserDoubleFetch->Buffer' and 'UserDoubleFetch->Size'\n        // from user mode twice and the double fetched values are passed to RtlCopyMemory()/memcpy().\n        // This creates a race condition and the size check could be bypassed which will later\n        // cause stack based buffer overflow\n        //\n\n        RtlCopyMemory((PVOID)KernelBuffer, UserDoubleFetch->Buffer, UserDoubleFetch->Size);\n#endif\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/DoubleFetch.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Get Arbitrary Read Write Helper Object Name Ioctl Handler\n/// </summary>\n/// <param name=\"Irp\">The pointer to IRP</param>\n/// <param name=\"IrpSp\">The pointer to IO_STACK_LOCATION structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nGetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler(\n    _In_ PIRP Irp,\n    _In_ PIO_STACK_LOCATION IrpSp\n)", "code": "{\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n    PARW_HELPER_OBJECT_IO HelperObjectIo = NULL;\n\n    UNREFERENCED_PARAMETER(Irp);\n    PAGED_CODE();\n\n    HelperObjectIo = (PARW_HELPER_OBJECT_IO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;\n\n    if (HelperObjectIo)\n    {\n        Status = GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(HelperObjectIo);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Trigger the Memory Disclosure in NonPagedPoolNx Vulnerability\n/// </summary>\n/// <param name=\"UserOutputBuffer\">The pointer to user mode output buffer</param>\n/// <param name=\"Size\">Size of the user mode buffer</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nTriggerMemoryDisclosureNonPagedPoolNx(\n    _In_ PVOID UserOutputBuffer,\n    _In_ SIZE_T Size\n)", "code": "{\n    PVOID KernelBuffer = NULL;\n    NTSTATUS Status = STATUS_SUCCESS;\n\n    PAGED_CODE();\n\n    __try\n    {\n        DbgPrint(\"[+] Allocating Pool chunk\\n\");\n\n        //\n        // Allocate Pool chunk\n        //\n\n        KernelBuffer = ExAllocatePoolWithTag(\n            NonPagedPoolNx,\n            (SIZE_T)POOL_BUFFER_SIZE,\n            (ULONG)POOL_TAG\n        );\n\n        if (!KernelBuffer)\n        {\n            //\n            // Unable to allocate Pool chunk\n            //\n            DbgPrint(\"[-] Unable to allocate Pool chunk\\n\");\n\n            Status = STATUS_NO_MEMORY;\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] Pool Tag: %s\\n\", STRINGIFY(POOL_TAG));\n            DbgPrint(\"[+] Pool Type: %s\\n\", STRINGIFY(NonPagedPoolNx));\n            DbgPrint(\"[+] Pool Size: 0x%X\\n\", (SIZE_T)POOL_BUFFER_SIZE);\n            DbgPrint(\"[+] Pool Chunk: 0x%p\\n\", KernelBuffer);\n        }\n\n        //\n        // Work on the kernel buffer\n        //\n\n        RtlFillMemory(KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE, 0x41);\n\n        //\n        // After working on the kernel buffer, it's time to give\n        // the output to the user\n        //\n\n        //\n        // Verify if the output buffer resides in user mode\n        //\n\n        ProbeForWrite(UserOutputBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR));\n\n        DbgPrint(\"[+] UserOutputBuffer: 0x%p\\n\", UserOutputBuffer);\n        DbgPrint(\"[+] UserOutputBuffer Size: 0x%X\\n\", Size);\n        DbgPrint(\"[+] KernelBuffer: 0x%p\\n\", KernelBuffer);\n        DbgPrint(\"[+] KernelBuffer Size: 0x%X\\n\", (SIZE_T)POOL_BUFFER_SIZE);\n\n#ifdef SECURE\n        //\n        // Secure Note: This is secure because the developer is passing a size\n        // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy().\n        // Hence, there will be no out of bound read of kernel mode memory\n        //\n\n        RtlCopyMemory(UserOutputBuffer, KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE);\n#else\n        DbgPrint(\"[+] Triggering Memory Disclosure in NonPagedPoolNx\\n\");\n\n        //\n        // Vulnerability Note: This is a vanilla memory disclosure vulnerability\n        // because the developer is passing the user supplied value directly to\n        // RtlCopyMemory()/memcpy() without validating if the size is greater or\n        // equal to the size of the allocated Pool chunk which will result in reading\n        // more data from kernel mode and passing to user mode memory which causes memory\n        // disclosure vulnerability\n        //\n\n        RtlCopyMemory(UserOutputBuffer, KernelBuffer, Size);\n#endif\n\n        if (KernelBuffer)\n        {\n            DbgPrint(\"[+] Freeing Pool chunk\\n\");\n            DbgPrint(\"[+] Pool Tag: %s\\n\", STRINGIFY(POOL_TAG));\n            DbgPrint(\"[+] Pool Chunk: 0x%p\\n\", KernelBuffer);\n\n            //\n            // Free the allocated Pool chunk\n            //\n\n            ExFreePoolWithTag(KernelBuffer, (ULONG)POOL_TAG);\n            KernelBuffer = NULL;\n        }\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/MemoryDisclosureNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Get Arbitrary Read Write Helper Object Name in NonPagedPoolNx\n/// </summary>\n/// <param name=\"HelperObjectIo\">The pointer to ARW_HELPER_OBJECT_IO structure</param>\n/// <returns>INT</returns>\n", "func_signal": "NTSTATUS\nGetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(\n    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo\n)", "code": "{\n    PVOID Name = NULL;\n    PVOID HelperObjectAddress = NULL;\n    INT Index = STATUS_INVALID_INDEX;\n    NTSTATUS Status = STATUS_SUCCESS;\n\n    __try\n    {\n        //\n        // Verify if the buffer resides in user mode\n        //\n\n        ProbeForRead(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));\n\n        //\n        // Make a local copy of the data structure to avoid race conditions\n        //\n\n        Name = HelperObjectIo->Name;\n        HelperObjectAddress = HelperObjectIo->HelperObjectAddress;\n\n        DbgPrint(\"[+] HelperObjectIo->Name: 0x%p\\n\", Name);\n        DbgPrint(\"[+] HelperObjectIo->HelperObjectAddress: 0x%p\\n\", HelperObjectAddress);\n\n        //\n        // Get index by pointer\n        //\n\n        Index = GetIndexFromPointer(HelperObjectAddress);\n\n        if (Index == STATUS_INVALID_INDEX)\n        {\n            //\n            // Failed to find index from pointer\n            //\n\n            DbgPrint(\"[-] Unable to find index from pointer: 0x%p\\n\", HelperObjectAddress);\n\n            Status = STATUS_INVALID_INDEX;\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] Index: 0x%X Pointer: 0x%p\\n\", Index, HelperObjectAddress);\n        }\n\n        if (g_ARWHelperObjectNonPagedPoolNx[Index]->Name && g_ARWHelperObjectNonPagedPoolNx[Index]->Length)\n        {\n            //\n            // Verify if the buffer resides in user mode\n            //\n\n            ProbeForWrite(\n                Name,\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Length,\n                (ULONG)__alignof(UCHAR)\n            );\n\n            //\n            // Copy the name from object name buffer to user buffer\n            //\n\n            DbgPrint(\n                \"[+] Copying src: 0x%p dst: 0x%p len: 0x%X\\n\",\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Name,\n                Name,\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Length\n            );\n\n            RtlCopyMemory(\n                Name,\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Name,\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Length\n            );\n        }\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Trigger the Write NULL Vulnerability\n/// </summary>\n/// <param name=\"UserBuffer\">The pointer to user mode buffer</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nTriggerWriteNULL(\n    _In_ PVOID UserBuffer\n)", "code": "{\n    NTSTATUS Status = STATUS_SUCCESS;\n\n    PAGED_CODE();\n\n    __try\n    {\n        //\n        // Verify if the buffer resides in user mode\n        //\n\n        ProbeForRead(UserBuffer, sizeof(PVOID), (ULONG)__alignof(PVOID));\n\n        //\n        // Grab the user pointer to nullify to avoid race condition\n        //\n\n        PVOID UserPointerToNullify = *(PVOID *)UserBuffer;\n\n        DbgPrint(\"[+] UserBuffer: 0x%p\\n\", UserBuffer);\n        DbgPrint(\"[+] UserPointerToNullify: 0x%p\\n\", UserPointerToNullify);\n\n#ifdef SECURE\n\n        //\n        // Secure Note: This is secure because the developer is properly validating if \n        // '*(UserBuffer)' resides in User mode by calling ProbeForWrite() routine before\n        // performing the write operation\n        //\n\n        ProbeForWrite(UserPointerToNullify, sizeof(PVOID), (ULONG)__alignof(PVOID));\n\n        *(PVOID *)UserPointerToNullify = NULL;\n#else\n        DbgPrint(\"[+] Triggering Arbitrary NULL Write\\n\");\n\n        //\n        // Vulnerability Note: This is a vanilla Arbitrary NULL Write vulnerability\n        // because the developer is writing NULL to the memory pointed by '*(UserBuffer)'\n        // without properly validating if it resides in User mode\n        //\n\n        *(PVOID *)UserPointerToNullify = NULL;\n#endif\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/WriteNULL.c", "commit_date": "2020-08-13 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Create Arbitrary Read Write Helper Object Ioctl Handler\n/// </summary>\n/// <param name=\"Irp\">The pointer to IRP</param>\n/// <param name=\"IrpSp\">The pointer to IO_STACK_LOCATION structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nCreateArbitraryReadWriteHelperObjectNonPagedPoolNxIoctlHandler(\n    _In_ PIRP Irp,\n    _In_ PIO_STACK_LOCATION IrpSp\n)", "code": "{\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n    PARW_HELPER_OBJECT_IO HelperObjectIo = NULL;\n\n    UNREFERENCED_PARAMETER(Irp);\n    PAGED_CODE();\n\n    HelperObjectIo = (PARW_HELPER_OBJECT_IO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;\n\n    if (HelperObjectIo)\n    {\n        Status = CreateArbitraryReadWriteHelperObjectNonPagedPoolNx(HelperObjectIo);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/**\n * @param[in] user_buffer the pointer to user mode buffer\n * @param[in] size size of the user mode buffer\n * @return status code\n */\n", "func_signal": "int trigger_uninitialized_memory_stack(void *user_buffer, size_t size)", "code": "{\n    unsigned long UserValue = 0;\n    unsigned long MagicValue = 0xBAD0B0B0;\n    int status = STATUS_SUCCESS;\n\n#ifdef SECURE\n    //\n    // Secure Note: This is secure because the developer is properly initializing\n    // UNINITIALIZED_MEMORY_STACK to NULL and checks for NULL pointer before calling\n    // the callback\n    //\n\n    UNINITIALIZED_MEMORY_STACK UninitializedMemory = { 0 };\n#else\n    //\n    // Vulnerability Note: This is a vanilla Uninitialized Memory in Stack vulnerability\n    // because the developer is not initializing 'UNINITIALIZED_MEMORY_STACK' structure\n    // before calling the callback when 'MagicValue' does not match 'UserValue'\n    //\n\n    UNINITIALIZED_MEMORY_STACK UninitializedMemory;\n#endif\n\n    if(copy_from_user(&UserValue, user_buffer, sizeof(UserValue))) {\n        ERR(\"Failed to copy UserValue from user space\\n\");\n\n        status = -EINVAL;\n        return status;\n    }\n\n    INFO(\"[+] UserValue: [0x%p] [0x%zX]\\n\", &UserValue, UserValue);\n    INFO(\"[+] UninitializedMemory Address: 0x%p\\n\", &UninitializedMemory);\n\n    if (UserValue == MagicValue) {\n        UninitializedMemory.Value = UserValue;\n        UninitializedMemory.Callback = &UninitializedMemoryStackObjectCallback;\n    }\n\n#ifndef SECURE\n    INFO(\"[+] Triggering Uninitialized Memory in Stack\\n\");\n#endif\n\n    if (UninitializedMemory.Callback) {\n        UninitializedMemory.Callback();\n    }\n\n    return status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Linux/UninitializedMemoryStack.c", "commit_date": "2019-11-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Delete Arbitrary Read Write Helper Object Ioctl Handler\n/// </summary>\n/// <param name=\"Irp\">The pointer to IRP</param>\n/// <param name=\"IrpSp\">The pointer to IO_STACK_LOCATION structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nDeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler(\n    _In_ PIRP Irp,\n    _In_ PIO_STACK_LOCATION IrpSp\n)", "code": "{\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n    PARW_HELPER_OBJECT_IO HelperObjectIo = NULL;\n\n    UNREFERENCED_PARAMETER(Irp);\n    PAGED_CODE();\n\n    HelperObjectIo = (PARW_HELPER_OBJECT_IO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;\n\n    if (HelperObjectIo)\n    {\n        Status = DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx(HelperObjectIo);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Arbitrary Write Ioctl Handler\n/// </summary>\n/// <param name=\"Irp\">The pointer to IRP</param>\n/// <param name=\"IrpSp\">The pointer to IO_STACK_LOCATION structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nArbitraryWriteIoctlHandler(\n    _In_ PIRP Irp,\n    _In_ PIO_STACK_LOCATION IrpSp\n)", "code": "{\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n    PWRITE_WHAT_WHERE UserWriteWhatWhere = NULL;\n\n    UNREFERENCED_PARAMETER(Irp);\n    PAGED_CODE();\n\n    UserWriteWhatWhere = (PWRITE_WHAT_WHERE)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;\n\n    if (UserWriteWhatWhere)\n    {\n        Status = TriggerArbitraryWrite(UserWriteWhatWhere);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryWrite.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Get Index in g_ARWHelperObjectNonPagedPoolNx From Pointer \n/// </summary>\n/// <param name=\"Pointer\">Pointer</param>\n/// <returns>INT</returns>\n", "func_signal": "INT\nGetIndexFromPointer(\n    _In_ PVOID Pointer\n)", "code": "{\n    INT i = 0;\n    INT FreeIndex = STATUS_INVALID_INDEX;\n\n    if (!Pointer)\n    {\n        return FreeIndex;\n    }\n\n    for (i = 0; i < MAX_OBJECT_COUNT; i++)\n    {\n        if (g_ARWHelperObjectNonPagedPoolNx[i] == Pointer)\n        {\n            FreeIndex = i;\n            break;\n        }\n    }\n\n    return FreeIndex;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Write NULL Ioctl Handler\n/// </summary>\n/// <param name=\"Irp\">The pointer to IRP</param>\n/// <param name=\"IrpSp\">The pointer to IO_STACK_LOCATION structure</param>\n/// <returns>NTSTATUS</returns>\n", "func_signal": "NTSTATUS\nWriteNULLIoctlHandler(\n    _In_ PIRP Irp,\n    _In_ PIO_STACK_LOCATION IrpSp\n)", "code": "{\n    PVOID UserBuffer = NULL;\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n\n    UNREFERENCED_PARAMETER(Irp);\n    PAGED_CODE();\n\n    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;\n\n    if (UserBuffer)\n    {\n        Status = TriggerWriteNULL(UserBuffer);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/WriteNULL.c", "commit_date": "2020-08-13 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "/// <summary>\n/// Set Arbitrary Read Write Helper Object Name in NonPagedPoolNx\n/// </summary>\n/// <param name=\"HelperObjectIo\">The pointer to ARW_HELPER_OBJECT_IO structure</param>\n/// <returns>INT</returns>\n", "func_signal": "NTSTATUS\nSetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(\n    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo\n)", "code": "{\n    PVOID Name = NULL;\n    PVOID HelperObjectAddress = NULL;\n    INT Index = STATUS_INVALID_INDEX;\n    NTSTATUS Status = STATUS_SUCCESS;\n\n    __try\n    {\n        //\n        // Verify if the buffer resides in user mode\n        //\n\n        ProbeForRead(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));\n\n        //\n        // Make a local copy of the data structure to avoid race conditions\n        //\n\n        Name = HelperObjectIo->Name;\n        HelperObjectAddress = HelperObjectIo->HelperObjectAddress;\n\n        DbgPrint(\"[+] HelperObjectIo->Name: 0x%p\\n\", Name);\n        DbgPrint(\"[+] HelperObjectIo->HelperObjectAddress: 0x%p\\n\", HelperObjectAddress);\n\n        //\n        // Get index by pointer\n        //\n\n        Index = GetIndexFromPointer(HelperObjectAddress);\n\n        if (Index == STATUS_INVALID_INDEX)\n        {\n            //\n            // Failed to find index from pointer\n            //\n\n            DbgPrint(\"[-] Unable to find index from pointer: 0x%p\\n\", HelperObjectAddress);\n\n            Status = STATUS_INVALID_INDEX;\n            return Status;\n        }\n        else\n        {\n            DbgPrint(\"[+] Index: 0x%X Pointer: 0x%p\\n\", Index, HelperObjectAddress);\n        }\n\n        if (Name && g_ARWHelperObjectNonPagedPoolNx[Index]->Length)\n        {\n            //\n            // Verify if the buffer resides in user mode\n            //\n\n            ProbeForRead(\n                Name,\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Length,\n                (ULONG)__alignof(UCHAR)\n            );\n\n            //\n            // Copy the name from user buffer to kernel object name buffer\n            //\n\n            DbgPrint(\n                \"[+] Copying src: 0x%p dst: 0x%p len: 0x%X\\n\",\n                Name,\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Name,\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Length\n            );\n\n            RtlCopyMemory(\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Name,\n                Name,\n                g_ARWHelperObjectNonPagedPoolNx[Index]->Length\n            );\n        }\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        Status = GetExceptionCode();\n        DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status);\n    }\n\n    return Status;\n}", "path": "HackSysExtremeVulnerableDriver/Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c", "commit_date": "2019-10-17 00:00:00", "repo_name": "hacksysteam/HackSysExtremeVulnerableDriver", "stars": 2282, "license": "gpl-3.0", "language": "c", "size": 1835}
{"docstring": "// 8.8.11 Movie Fragment Random Access Offset Box (p75)\n", "func_signal": "static int mov_read_mfro(struct mov_t* mov, const struct mov_box_t* box)", "code": "{\n\t(void)box;\n\tmov_buffer_r32(&mov->io); /* version & flags */\n\tmov_buffer_r32(&mov->io); /* size */\n\treturn mov_buffer_error(&mov->io);\n}", "path": "media-server/libmov/source/mov-reader.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "/// @return >0-ok, <=0-error\n", "func_signal": "int aac_from_sdp_mpeg4_config(struct mpeg4_aac_t* aac, struct sdp_a_fmtp_mpeg4_t* fmtp)", "code": "{\n\tint n;\n\tuint8_t buf[128];\n\n\tn = (int)strlen(fmtp->config);\n\tif ((n + 3) / 4 * 3 > sizeof(buf))\n\t\treturn -1;\n\n\tn = (int)base64_decode(buf, fmtp->config, n);\n\treturn mpeg4_aac_audio_specific_config_load(buf, n, aac);\n}", "path": "media-server/librtsp/source/sdp/sdp-fmtp-load.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// 8.3.1 Track Box (p31)\n// Box Type : 'trak' \n// Container : Movie Box('moov') \n// Mandatory : Yes \n// Quantity : One or more\n", "func_signal": "static int mov_read_trak(struct mov_t* mov, const struct mov_box_t* box)", "code": "{\n\tint r;\n\n    mov->track = NULL;\n\tr = mov_reader_box(mov, box);\n\tif (0 == r)\n\t{\n        mov->track->tfdt_dts = 0;\n        if (mov->track->sample_count > 0)\n        {\n            mov_apply_stco(mov->track);\n            mov_apply_elst(mov->track);\n            mov_apply_stts(mov->track);\n            mov_apply_ctts(mov->track);\n\t\t\tmov_apply_stss(mov->track);\n\n            mov->track->tfdt_dts = mov->track->samples[mov->track->sample_count - 1].dts;\n        }\n\t}\n\n\treturn r;\n}", "path": "media-server/libmov/source/mov-reader.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "/// h264_is_new_access_unit H.264 new access unit(frame)\n/// @return 1-new access, 0-not a new access\n", "func_signal": "int h264_is_new_access_unit(const uint8_t* nalu, size_t bytes)", "code": "{\n    enum { NAL_NIDR = 1, NAL_PARTITION_A = 2, NAL_IDR = 5, NAL_SEI = 6, NAL_SPS = 7, NAL_PPS = 8, NAL_AUD = 9, };\n    \n    uint8_t nal_type;\n    \n    if(bytes < 2)\n        return 0;\n    \n    nal_type = nalu[0] & 0x1f;\n    \n    // 7.4.1.2.3 Order of NAL units and coded pictures and association to access units\n    if(NAL_AUD == nal_type || NAL_SPS == nal_type || NAL_PPS == nal_type || NAL_SEI == nal_type || (14 <= nal_type && nal_type <= 18))\n        return 1;\n    \n    // 7.4.1.2.4 Detection of the first VCL NAL unit of a primary coded picture\n    if(NAL_NIDR == nal_type || NAL_PARTITION_A == nal_type || NAL_IDR == nal_type)\n    {\n        // Live555 H264or5VideoStreamParser::parse\n        // The high-order bit of the byte after the \"nal_unit_header\" tells us whether it's\n        // the start of a new 'access unit' (and thus the current NAL unit ends an 'access unit'):\n        return (nalu[1] & 0x80) ? 1 : 0; // first_mb_in_slice\n    }\n    \n    return 0;\n}", "path": "media-server/libflv/source/mpeg4-annexbtomp4.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// RFC3261 17.1.3 Matching Responses to Client Transactions (p132)\n", "func_signal": "static struct sip_uac_transaction_t* sip_uac_find_transaction(struct list_head* transactions, struct sip_message_t* reply)", "code": "{\n\tconst struct cstring_t *p, *p2;\n\tstruct list_head *pos, *next;\n\tstruct sip_uac_transaction_t* t;\n\n\tp = sip_vias_top_branch(&reply->vias);\n\tif (!p) return NULL;\n\tassert(cstrprefix(p, SIP_BRANCH_PREFIX));\n\n\tlist_for_each_safe(pos, next, transactions)\n\t{\n\t\tt = list_entry(pos, struct sip_uac_transaction_t, link);\n\n\t\t// 1. via branch parameter\n\t\tp2 = sip_vias_top_branch(&t->req->vias);\n\t\tif (!p2 || 0 == cstreq(p, p2))\n\t\t\tcontinue;\n\t\tassert(cstrprefix(p2, SIP_BRANCH_PREFIX));\n\t\t\n\t\t// 2. cseq method parameter\n\t\t// The method is needed since a CANCEL request constitutes a\n\t\t// different transaction, but shares the same value of the branch parameter.\n\t\tassert(reply->cseq.id == t->req->cseq.id);\n\t\tif (!cstreq(&reply->cseq.method, &t->req->cseq.method))\n\t\t\tcontinue;\n\n\t\t//// 3. to tag\n\t\t//p = sip_params_find_string(&reply->to.params, \"tag\");\n\t\t//p2 = sip_params_find_string(&t->msg->to.params, \"tag\");\n\t\t//if (p2 && (!p || !cstreq(p, p2)))\n\t\t//\tcontinue;\n\n\t\tsip_uac_transaction_addref(t); // add ref\n\t\tassert(t->ref >= 2);\n\t\treturn t;\n\t}\n\n\treturn NULL;\n}", "path": "media-server/libsip/src/uac/sip-uac.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "///@param[in] h264 H.264 byte stream format data(A set of NAL units)\n", "func_signal": "void mpeg4_h264_annexb_nalu(const void* h264, int bytes, void (*handler)(void* param, const uint8_t* nalu, int bytes), void* param)", "code": "{\n\tptrdiff_t n;\n\tconst uint8_t* p, *next, *end;\n\n\tend = (const uint8_t*)h264 + bytes;\n\tp = h264_startcode((const uint8_t*)h264, bytes);\n\n\twhile (p)\n\t{\n\t\tnext = h264_startcode(p, (int)(end - p));\n\t\tif (next)\n\t\t{\n\t\t\tn = next - p - 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tn = end - p;\n\t\t}\n\n\t\twhile (n > 0 && 0 == p[n - 1]) n--; // filter tailing zero\n\n\t\tassert(n > 0);\n\t\tif (n > 0)\n\t\t{\n\t\t\thandler(param, p, (int)n);\n\t\t}\n\n\t\tp = next;\n\t}\n}", "path": "media-server/libflv/source/mpeg4-annexbtomp4.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "/*\naligned(8) class TrackHeaderBox extends FullBox('tkhd', version, flags){ \n\tif (version==1) { \n\t\tunsigned int(64) creation_time; \n\t\tunsigned int(64) modification_time; \n\t\tunsigned int(32) track_ID; \n\t\tconst unsigned int(32) reserved = 0; \n\t\tunsigned int(64) duration; \n\t} else { // version==0 \n\t\tunsigned int(32) creation_time; \n\t\tunsigned int(32) modification_time;\n\t\tunsigned int(32) track_ID; \n\t\tconst unsigned int(32) reserved = 0; \n\t\tunsigned int(32) duration; \n\t} \n\tconst unsigned int(32)[2] reserved = 0; \n\ttemplate int(16) layer = 0; \n\ttemplate int(16) alternate_group = 0; \n\ttemplate int(16) volume = {if track_is_audio 0x0100 else 0}; \n\tconst unsigned int(16) reserved = 0; \n\ttemplate int(32)[9] matrix= { 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 }; // unity matrix \n\tunsigned int(32) width; \n\tunsigned int(32) height; \n}\n*/\n", "func_signal": "int mov_read_tkhd(struct mov_t* mov, const struct mov_box_t* box)", "code": "{\n\tint i;\n    uint8_t version;\n    uint32_t flags;\n    uint64_t creation_time;\n    uint64_t modification_time;\n    uint64_t duration;\n    uint32_t track_ID;\n\tstruct mov_tkhd_t* tkhd;\n    struct mov_track_t* track;\n\n\tversion = mov_buffer_r8(&mov->io);\n\tflags = mov_buffer_r24(&mov->io);\n\n\tif (1 == version)\n\t{\n\t\tcreation_time = mov_buffer_r64(&mov->io);\n\t\tmodification_time = mov_buffer_r64(&mov->io);\n\t\ttrack_ID = mov_buffer_r32(&mov->io);\n\t\t/*reserved = */mov_buffer_r32(&mov->io);\n\t\tduration = mov_buffer_r64(&mov->io);\n\t}\n\telse\n\t{\n\t\tassert(0 == version);\n\t\tcreation_time = mov_buffer_r32(&mov->io);\n\t\tmodification_time = mov_buffer_r32(&mov->io);\n\t\ttrack_ID = mov_buffer_r32(&mov->io);\n\t\t/*reserved = */mov_buffer_r32(&mov->io);\n\t\tduration = mov_buffer_r32(&mov->io);\n\t}\n    mov_buffer_skip(&mov->io, 8); // const unsigned int(32)[2] reserved = 0;\n\n    track = mov_fetch_track(mov, track_ID);\n    if (NULL == track) return -1;\n\n    mov->track = track;\n    tkhd = &mov->track->tkhd;\n\ttkhd->version = version;\n    tkhd->flags = flags;\n    tkhd->duration = duration;\n    tkhd->creation_time = creation_time;\n    tkhd->modification_time = modification_time;\n\n\ttkhd->layer = (int16_t)mov_buffer_r16(&mov->io);\n\ttkhd->alternate_group = (int16_t)mov_buffer_r16(&mov->io);\n\ttkhd->volume = (int16_t)mov_buffer_r16(&mov->io);\n\tmov_buffer_skip(&mov->io, 2); // const unsigned int(16) reserved = 0;\n\tfor (i = 0; i < 9; i++)\n\t\ttkhd->matrix[i] = mov_buffer_r32(&mov->io);\n\ttkhd->width = mov_buffer_r32(&mov->io);\n\ttkhd->height = mov_buffer_r32(&mov->io);\n\n\t(void)box;\n\treturn 0;\n}", "path": "media-server/libmov/source/mov-tkhd.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "/// @return >0-ok, <=0-error\n", "func_signal": "int aac_from_sdp_latm_config(struct mpeg4_aac_t* aac, struct sdp_a_fmtp_mpeg4_t* fmtp)", "code": "{\n\tint n;\n\tuint8_t buf[128];\n\n\tn = (int)strlen(fmtp->config);\n\tif (n / 2 > sizeof(buf))\n\t\treturn -1;\n\n\tn = (int)base16_decode(buf, fmtp->config, n);\n\treturn mpeg4_aac_stream_mux_config_load(buf, n, aac);\n}", "path": "media-server/librtsp/source/sdp/sdp-fmtp-load.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "/*\n 0               1               2               3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     PayloadHdr (Type=49)      |    FU header  |  DONL (cond)  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n|  DONL (cond)  |                                               |\n|-+-+-+-+-+-+-+-+                                               |\n|                           FU payload                          |\n|                                                               |\n|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               :    ...OPTIONAL RTP padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n+---------------+\n|0|1|2|3|4|5|6|7|\n+-+-+-+-+-+-+-+-+\n|S|E|   FuType  |\n+---------------+\n*/\n", "func_signal": "static int rtp_h265_unpack_fu(struct rtp_decode_h265_t *unpacker, const uint8_t* ptr, int bytes, uint32_t timestamp)", "code": "{\n\tint r, n;\n\tuint8_t fuheader;\n\n\tr = 0;\n\tn = 1 /*FU header*/ + (unpacker->using_donl_field ? 4 : 2);\n\tif (bytes < n || unpacker->size + bytes - n > RTP_PAYLOAD_MAX_SIZE)\n\t{\n\t\tassert(0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unpacker->size + bytes - n + 2 /*NALU*/ > unpacker->capacity)\n\t{\n\t\tvoid* p = NULL;\n\t\tint size = unpacker->size + bytes + 2;\n\t\tsize += size / 4 > 128000 ? size / 4 : 128000;\n\t\tp = realloc(unpacker->ptr, size);\n\t\tif (!p)\n\t\t{\n\t\t\t// set packet lost flag\n\t\t\tunpacker->flags = RTP_PAYLOAD_FLAG_PACKET_LOST;\n\t\t\tunpacker->size = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tunpacker->ptr = (uint8_t*)p;\n\t\tunpacker->capacity = size;\n\t}\n\n\tfuheader = ptr[2];\n\tif (FU_START(fuheader))\n\t{\n#if 0\n\t\tif (unpacker->size > 0)\n\t\t{\n\t\t\tunpacker->flags |= RTP_PAYLOAD_FLAG_PACKET_CORRUPT;\n\t\t\tunpacker->handler.packet(unpacker->cbparam, unpacker->ptr, unpacker->size, unpacker->timestamp, unpacker->flags);\n\t\t\tunpacker->flags = 0;\n\t\t\tunpacker->size = 0; // reset\n\t\t}\n#endif\n\n\t\tassert(unpacker->capacity > 2);\n\t\tunpacker->size = 2; // NAL unit type byte\n\t\tunpacker->ptr[0] = (FU_NAL(fuheader) << 1) | (ptr[0] & 0x81); // replace NAL Unit Type Bits\n\t\tunpacker->ptr[1] = ptr[1];\n\t\tassert(H265_TYPE(unpacker->ptr[0]) >= 0 && H265_TYPE(unpacker->ptr[0]) <= 63);\n\t}\n\telse\n\t{\n\t\tif (0 == unpacker->size)\n\t\t{\n\t\t\tunpacker->flags = RTP_PAYLOAD_FLAG_PACKET_LOST;\n\t\t\treturn 0; // packet discard\n\t\t}\n\t\tassert(unpacker->size > 0);\n\t}\n\n\tunpacker->timestamp = timestamp;\n\tif (bytes > n)\n\t{\n\t\tassert(unpacker->capacity >= unpacker->size + bytes - n);\n\t\tmemmove(unpacker->ptr + unpacker->size, ptr + n, bytes - n);\n\t\tunpacker->size += bytes - n;\n\t}\n\n\tif (FU_END(fuheader))\n\t{\n\t\tr = unpacker->handler.packet(unpacker->cbparam, unpacker->ptr, unpacker->size, timestamp, unpacker->flags);\n\t\tunpacker->flags = 0;\n\t\tunpacker->size = 0;\n\t}\n\n\treturn 0 == r ? 1 : r; // packet handled\n}", "path": "media-server/librtp/payload/rtp-h265-unpack.c", "commit_date": "2020-10-31 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// 8.6.6 Edit List Box (p53)\n", "func_signal": "int mov_read_elst(struct mov_t* mov, const struct mov_box_t* box)", "code": "{\n\tuint32_t i, entry_count;\n\tuint32_t version;\n\tstruct mov_track_t* track = mov->track;\n\n\tversion = mov_buffer_r8(&mov->io); /* version */\n\tmov_buffer_r24(&mov->io); /* flags */\n\tentry_count = mov_buffer_r32(&mov->io);\n\n\tassert(0 == track->elst_count && NULL == track->elst);\n\tif (track->elst_count < entry_count)\n\t{\n\t\tvoid* p = realloc(track->elst, sizeof(struct mov_elst_t) * entry_count);\n\t\tif (NULL == p) return ENOMEM;\n\t\ttrack->elst = (struct mov_elst_t*)p;\n\t}\n\ttrack->elst_count = entry_count;\n\n\tfor (i = 0; i < entry_count; i++)\n\t{\n\t\tif (1 == version)\n\t\t{\n\t\t\ttrack->elst[i].segment_duration = mov_buffer_r64(&mov->io);\n\t\t\ttrack->elst[i].media_time = (int64_t)mov_buffer_r64(&mov->io);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(0 == version);\n\t\t\ttrack->elst[i].segment_duration = mov_buffer_r32(&mov->io);\n\t\t\ttrack->elst[i].media_time = (int32_t)mov_buffer_r32(&mov->io);\n\t\t}\n\t\ttrack->elst[i].media_rate_integer = (int16_t)mov_buffer_r16(&mov->io);\n\t\ttrack->elst[i].media_rate_fraction = (int16_t)mov_buffer_r16(&mov->io);\n\t}\n\n\t(void)box;\n\treturn mov_buffer_error(&mov->io);\n}", "path": "media-server/libmov/source/mov-elst.c", "commit_date": "2020-03-07 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// ISO/IEC 14496-14:2003(E) 5.6 Sample Description Boxes (p15)\n", "func_signal": "int mov_read_esds(struct mov_t* mov, const struct mov_box_t* box)", "code": "{\n\tmov_buffer_r8(&mov->io); /* version */\n\tmov_buffer_r24(&mov->io); /* flags */\n\treturn mp4_read_tag(mov, box->size - 4);\n}", "path": "media-server/libmov/source/mov-esds.c", "commit_date": "2020-04-25 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "/// @return >0-ok, other-error\n", "func_signal": "int mpeg4_avc_from_fmtp(struct mpeg4_avc_t* avc, const struct sdp_a_fmtp_h264_t* fmtp)", "code": "{\n\tuint8_t t;\n\tint n, off;\n\tconst char* p, * next;\n\n\tmemset(avc, 0, sizeof(*avc));\n\tavc->nalu = 4;\n\tif (3 != sscanf(fmtp->profile_level_id, \"%2hhx%2hhx%2hhx\", &avc->profile, &avc->compatibility, &avc->level))\n\t\treturn -1;\n\n\toff = 0;\n\tp = fmtp->sprop_parameter_sets;\n\twhile (p)\n\t{\n\t\tnext = strchr(p, ',');\n\t\tn = next ? (int)(next - p) : (int)strlen(p);\n\t\tif (off + (n + 3) / 4 * 3 > sizeof(avc->data))\n\t\t\treturn -1; // don't have enough space\n\n\t\tn = (int)base64_decode(avc->data + off, p, n);\n\t\tt = avc->data[off] & 0x1f;\n\t\tif (7 == t)\n\t\t{\n\t\t\tavc->sps[avc->nb_sps].data = avc->data + off;\n\t\t\tavc->sps[avc->nb_sps].bytes = (uint16_t)n;\n\t\t\t++avc->nb_sps;\n\t\t\toff += n;\n\t\t}\n\t\telse if (8 == t)\n\t\t{\n\t\t\tavc->pps[avc->nb_pps].data = avc->data + off;\n\t\t\tavc->pps[avc->nb_pps].bytes = (uint16_t)n;\n\t\t\t++avc->nb_pps;\n\t\t\toff += n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(0);\n\t\t}\n\n\t\tp = next ? next + 1 : NULL;\n\t}\n\n\treturn 0;\n}", "path": "media-server/librtsp/source/sdp/sdp-fmtp-load.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// ISO/IEC 14496-1:2010(E) 7.2.6.7 DecoderSpecificInfo (p51)\n/*\nabstract class DecoderSpecificInfo extends BaseDescriptor : bit(8)\n\ttag=DecSpecificInfoTag\n{\n\t// empty. To be filled by classes extending this class.\n}\n*/\n", "func_signal": "static int mp4_read_decoder_specific_info(struct mov_t* mov, int len)", "code": "{\n\tstruct mov_track_t* track = mov->track;\n\tstruct mov_sample_entry_t* entry = track->stsd.current;\n\tif (entry->extra_data_size < len)\n\t{\n\t\tvoid* p = realloc(entry->extra_data, len);\n\t\tif (NULL == p) return ENOMEM;\n\t\tentry->extra_data = p;\n\t}\n\n\tmov_buffer_read(&mov->io, entry->extra_data, len);\n\tentry->extra_data_size = len;\n\treturn mov_buffer_error(&mov->io);\n}", "path": "media-server/libmov/source/mov-esds.c", "commit_date": "2020-04-25 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// 8.1.1 Media Data Box (p28)\n", "func_signal": "static int mov_read_mdat(struct mov_t* mov, const struct mov_box_t* box)", "code": "{\n\tmov_buffer_skip(&mov->io, box->size);\n\treturn mov_buffer_error(&mov->io);\n}", "path": "media-server/libmov/source/mov-reader.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// 8.1.2 Free Space Box (p28)\n", "func_signal": "static int mov_read_free(struct mov_t* mov, const struct mov_box_t* box)", "code": "{\n\t// Container: File or other box\n\tmov_buffer_skip(&mov->io, box->size);\n\treturn mov_buffer_error(&mov->io);\n}", "path": "media-server/libmov/source/mov-reader.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// Alice <sip:alice@atlanta.com>;tag=1928301774\n", "func_signal": "int sip_contact_write(const struct sip_contact_t* c, char* data, const char* end)", "code": "{\n\tint n;\n\tchar* p;\n\tconst char* quote;\n\n\tp = data;\n\tif (cstrvalid(&c->nickname) && p < end)\n\t{\n\t\tquote = sip_nickname_check(&c->nickname) ? \"\" : \"\\\"\";\n\t\tp += snprintf(p, end - p, \"%s%.*s%s \", quote, (int)c->nickname.n, c->nickname.p, quote);\n\t}\n\n\tif (0 == cstrcmp(&c->uri.host, \"*\"))\n\t{\n\t\tif (p < end) *p++ = '*';\n\t}\n\telse\n\t{\n\t\tif (p < end) *p++ = '<';\n\t\tn = sip_uri_write(&c->uri, p, end);\n\t\tif (n < 0) return n;\n\t\tp += n;\n\t\tif (p < end) *p++ = '>';\n\t}\n\n\tif (sip_params_count(&c->params) > 0)\n\t{\n\t\tif (p < end) *p++ = ';';\n\t\tn = sip_params_write(&c->params, p, end, ';');\n\t\tif (n < 0) return n;\n\t\tp += n;\n\t}\n\t\n\tif (p < end) *p = '\\0';\n\treturn (int)(p - data);\n}", "path": "media-server/libsip/src/header/sip-header-contact.c", "commit_date": "2020-03-07 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "/*\nGASpecificConfig (samplingFrequencyIndex, channelConfiguration, audioObjectType)\n{\n\tframeLengthFlag;\t\t\t\t\t\t\t\t\t\t\t1 bslbf\n\tdependsOnCoreCoder;\t\t\t\t\t\t\t\t\t\t\t1 bslbf\n\tif (dependsOnCoreCoder) {\n\t\tcoreCoderDelay;\t\t\t\t\t\t\t\t\t\t\t14 uimsbf\n\t}\n\textensionFlag;\t\t\t\t\t\t\t\t\t\t\t\t1 bslbf\n\tif (! channelConfiguration) {\n\t\tprogram_config_element ();\n\t}\n\tif ((audioObjectType == 6) || (audioObjectType == 20)) {\n\t\tlayerNr;\t\t\t\t\t\t\t\t\t\t\t\t3 uimsbf\n\t}\n\tif (extensionFlag) {\n\t\tif (audioObjectType == 22) {\n\t\t\tnumOfSubFrame;\t\t\t\t\t\t\t\t\t\t5 bslbf\n\t\t\tlayer_length;\t\t\t\t\t\t\t\t\t\t11 bslbf\n\t\t}\n\t\tif (audioObjectType == 17 || audioObjectType == 19 || audioObjectType == 20 || audioObjectType == 23) {\n\t\t\taacSectionDataResilienceFlag;\t\t\t\t\t\t1 bslbf\n\t\t\taacScalefactorDataResilienceFlag;\t\t\t\t\t1 bslbf\n\t\t\taacSpectralDataResilienceFlag;\t\t\t\t\t\t1 bslbf\n\t\t}\n\t\textensionFlag3;\t\t\t\t\t\t\t\t\t\t\t1 bslbf\n\t\tif (extensionFlag3) {\n\t\t\t// tbd in version 3\n\t\t}\n\t}\n}\n*/\n", "func_signal": "static int mpeg4_aac_ga_specific_config_load(struct mpeg4_bits_t* bits, struct mpeg4_aac_t* aac)", "code": "{\n\tint extensionFlag;\n\tstruct mpeg4_bits_t pce;\n\n\tmpeg4_bits_read(bits); // frameLengthFlag\n\tif (mpeg4_bits_read(bits)) // dependsOnCoreCoder\n\t\tmpeg4_bits_read_uint16(bits, 14); // coreCoderDelay\n\textensionFlag = mpeg4_bits_read(bits); // extensionFlag\n\n\tif (0 == aac->channel_configuration)\n\t{\n\t\tmpeg4_bits_init(&pce, aac->pce, sizeof(aac->pce));\n\t\taac->npce = mpeg4_aac_pce_load(bits, aac, &pce); // update channel count\n\t}\n\n\tif (6 == aac->profile || 20 == aac->profile)\n\t\tmpeg4_bits_read_uint8(bits, 3); // layerNr\n\n\tif (extensionFlag)\n\t{\n\t\tif (22 == aac->profile)\n\t\t{\n\t\t\tmpeg4_bits_read_uint8(bits, 5); // numOfSubFrame\n\t\t\tmpeg4_bits_read_uint16(bits, 11); // layer_length\n\t\t}\n\n\t\tif (17 == aac->profile || 19 == aac->profile || 20 == aac->profile || 23 == aac->profile)\n\t\t{\n\t\t\tmpeg4_bits_read(bits); // aacSectionDataResilienceFlag\n\t\t\tmpeg4_bits_read(bits); // aacScalefactorDataResilienceFlag\n\t\t\tmpeg4_bits_read(bits); // aacSpectralDataResilienceFlag\n\t\t}\n\n\t\tif (mpeg4_bits_read(bits)) // extensionFlag3\n\t\t{\n\t\t\t// tbd in version 3\n\t\t\tassert(0);\n\t\t}\n\t}\n\n\treturn mpeg4_bits_error(bits);\n}", "path": "media-server/libflv/source/mpeg4-aac-asc.c", "commit_date": "2020-08-15 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// ISO/IEC 14496-1:2010(E) 7.2.6.6 DecoderConfigDescriptor (p48)\n/*\nclass DecoderConfigDescriptor extends BaseDescriptor : bit(8) tag=DecoderConfigDescrTag {\n\tbit(8) objectTypeIndication;\n\tbit(6) streamType;\n\tbit(1) upStream;\n\tconst bit(1) reserved=1;\n\tbit(24) bufferSizeDB;\n\tbit(32) maxBitrate;\n\tbit(32) avgBitrate;\n\tDecoderSpecificInfo decSpecificInfo[0 .. 1];\n\tprofileLevelIndicationIndexDescriptor profileLevelIndicationIndexDescr[0..255];\n}\n*/\n", "func_signal": "static int mp4_read_decoder_config_descriptor(struct mov_t* mov, int len)", "code": "{\n\tstruct mov_sample_entry_t* entry = mov->track->stsd.current;\n\tentry->object_type_indication = (uint8_t)mov_buffer_r8(&mov->io); /* objectTypeIndication */\n\tentry->stream_type = (uint8_t)mov_buffer_r8(&mov->io) >> 2; /* stream type */\n\t/*uint32_t bufferSizeDB = */mov_buffer_r24(&mov->io); /* buffer size db */\n\t/*uint32_t max_rate = */mov_buffer_r32(&mov->io); /* max bit-rate */\n\t/*uint32_t bit_rate = */mov_buffer_r32(&mov->io); /* avg bit-rate */\n\treturn mp4_read_tag(mov, (uint64_t)len - 13); // mp4_read_decoder_specific_info\n}", "path": "media-server/libmov/source/mov-esds.c", "commit_date": "2020-04-25 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// ISO/IEC 14496-1:2010(E) 7.2.6.5 ES_Descriptor (p47)\n/*\nclass ES_Descriptor extends BaseDescriptor : bit(8) tag=ES_DescrTag {\n\tbit(16) ES_ID;\n\tbit(1) streamDependenceFlag;\n\tbit(1) URL_Flag;\n\tbit(1) OCRstreamFlag;\n\tbit(5) streamPriority;\n\tif (streamDependenceFlag)\n\t\tbit(16) dependsOn_ES_ID;\n\tif (URL_Flag) {\n\t\tbit(8) URLlength;\n\t\tbit(8) URLstring[URLlength];\n\t}\n\tif (OCRstreamFlag)\n\t\tbit(16) OCR_ES_Id;\n\tDecoderConfigDescriptor decConfigDescr;\n\tif (ODProfileLevelIndication==0x01) //no SL extension.\n\t{\n\t\tSLConfigDescriptor slConfigDescr;\n\t}\n\telse // SL extension is possible.\n\t{\n\t\tSLConfigDescriptor slConfigDescr;\n\t}\n\tIPI_DescrPointer ipiPtr[0 .. 1];\n\tIP_IdentificationDataSet ipIDS[0 .. 255];\n\tIPMP_DescriptorPointer ipmpDescrPtr[0 .. 255];\n\tLanguageDescriptor langDescr[0 .. 255];\n\tQoS_Descriptor qosDescr[0 .. 1];\n\tRegistrationDescriptor regDescr[0 .. 1];\n\tExtensionDescriptor extDescr[0 .. 255];\n}\n*/\n", "func_signal": "static int mp4_read_es_descriptor(struct mov_t* mov, uint64_t bytes)", "code": "{\n\tuint64_t p1, p2;\n\tp1 = mov_buffer_tell(&mov->io);\n\t/*uint32_t ES_ID = */mov_buffer_r16(&mov->io);\n\tuint32_t flags = mov_buffer_r8(&mov->io);\n\tif (flags & 0x80) //streamDependenceFlag\n\t\tmov_buffer_r16(&mov->io);\n\tif (flags & 0x40) { //URL_Flag\n\t\tuint32_t n = mov_buffer_r8(&mov->io);\n\t\tmov_buffer_skip(&mov->io, n);\n\t}\n\n\tif (flags & 0x20) //OCRstreamFlag\n\t\tmov_buffer_r16(&mov->io);\n\n\tp2 = mov_buffer_tell(&mov->io);\n\treturn mp4_read_tag(mov, bytes - (p2 - p1));\n}", "path": "media-server/libmov/source/mov-esds.c", "commit_date": "2020-04-25 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "// ISO/IEC 14496-1:2010(E) 7.2.2.2 BaseDescriptor (p32)\n// ISO/IEC 14496-1:2010(E) 8.3.3 Expandable classes (p116)\n/*\nabstract aligned(8) expandable(2^28-1) class BaseDescriptor : bit(8) tag=0 {\n\t// empty. To be filled by classes extending this class.\n}\n\nint sizeOfInstance = 0;\nbit(1) nextByte;\nbit(7) sizeOfInstance;\nwhile(nextByte) {\n\tbit(1) nextByte;\n\tbit(7) sizeByte;\n\tsizeOfInstance = sizeOfInstance<<7 | sizeByte;\n}\n*/\n", "func_signal": "static int mov_read_base_descr(struct mov_t* mov, int bytes, int* tag,  int* len)", "code": "{\n\tint i;\n\tuint32_t c;\n\n\t*tag = mov_buffer_r8(&mov->io);\n\t*len = 0;\n\tc = 0x80;\n\tfor (i = 0; i < 4 && i + 1 < bytes && 0 != (c & 0x80); i++)\n\t{\n\t\tc = mov_buffer_r8(&mov->io);\n\t\t*len = (*len << 7) | (c & 0x7F);\n\t\t//if (0 == (c & 0x80))\n\t\t//\tbreak;\n\t}\n\treturn 1 + i;\n}", "path": "media-server/libmov/source/mov-esds.c", "commit_date": "2020-04-25 00:00:00", "repo_name": "ireader/media-server", "stars": 2873, "license": "mit", "language": "c", "size": 3804}
{"docstring": "/* shared by H264, AAC and VORBIS */\n", "func_signal": "static int\ntvh_extradata_open(TVHContext *self, AVDictionary **opts)", "code": "{\n    size_t extradata_size = 0;\n\n    if (!(extradata_size = pktbuf_len(self->input_gh))) {\n        return AVERROR(EAGAIN);\n    }\n    if (extradata_size >= TVH_INPUT_BUFFER_MAX_SIZE) {\n        tvh_context_log(self, LOG_ERR, \"extradata too big\");\n        return AVERROR(EOVERFLOW);\n    }\n    if (self->iavctx->extradata) {\n        tvh_context_log(self, LOG_ERR, \"extradata already set!\");\n        return AVERROR(EALREADY);\n    }\n    if (!(self->iavctx->extradata =\n              av_mallocz(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE))) {\n        tvh_context_log(self, LOG_ERR, \"failed to alloc extradata\");\n        return AVERROR(ENOMEM);\n    }\n    memcpy(self->iavctx->extradata, pktbuf_ptr(self->input_gh), extradata_size);\n    self->iavctx->extradata_size = extradata_size;\n    return 0;\n}", "path": "tvheadend/src/transcoding/transcode/helpers.c", "commit_date": "2018-03-23 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n * Demux again data from one mpeg-ts stream.\n * Might be used for hardware descramblers.\n */\n", "func_signal": "void\nmpegts_input_postdemux\n  ( mpegts_input_t *mi, mpegts_mux_t *mm, uint8_t *tsb, int len )", "code": "{\n  uint16_t pid;\n  int llen, type = 0;\n  mpegts_pid_t *mp;\n  mpegts_pid_sub_t *mps;\n  service_t *s;\n  elementary_stream_t *st;\n  mpegts_mux_instance_t *mmi;\n\n  tvh_mutex_lock(&mi->mi_output_lock);\n  if (mm == NULL || (mmi = mm->mm_active) == NULL)\n    goto unlock;\n\n  assert(mm == mmi->mmi_mux);\n\n  /* Process */\n  assert((len % 188) == 0);\n  while (len > 0) {\n\n    /*\n     * mask\n     *  0 - 0xFF - sync word 0x47\n     *  1 - 0x80 - transport error\n     *  1 - 0x1F - pid high\n     *  2 - 0xFF - pid low\n     *  3 - 0xC0 - scrambled\n     *  3 - 0x10 - CC check\n     */\n    llen = mpegts_word_count(tsb, len, 0xFF9FFFD0);\n\n    pid = (tsb[1] << 8) | tsb[2];\n\n    pid &= 0x1FFF;\n\n    /* Ignore NULL packets */\n    if (pid == 0x1FFF)\n      goto done;\n\n    /* Find PID */\n    if ((mp = mpegts_mux_find_pid(mm, pid, 0))) {\n\n      type = mp->mp_type;\n\n      if (type & MPS_NOPOSTDEMUX)\n        goto done;\n\n      /* Stream service data */\n      if (type & MPS_SERVICE) {\n        LIST_FOREACH(mps, &mp->mp_svc_subs, mps_svcraw_link) {\n          s = mps->mps_owner;\n          tvh_mutex_lock(&s->s_stream_mutex);\n          st = elementary_stream_find(&s->s_components, pid);\n          ts_recv_packet0((mpegts_service_t*)s, st, tsb, llen);\n          tvh_mutex_unlock(&s->s_stream_mutex);\n        }\n      } else\n      /* Stream table data */\n      if (type & MPS_STREAM) {\n        LIST_FOREACH(s, &mm->mm_transports, s_active_link) {\n          if (s->s_type != STYPE_STD) continue;\n          tvh_mutex_lock(&s->s_stream_mutex);\n          ts_recv_packet0((mpegts_service_t*)s, NULL, tsb, llen);\n          tvh_mutex_unlock(&s->s_stream_mutex);\n        }\n      }\n\n    }\n\ndone:\n    tsb += llen;\n    len -= llen;\n  }\nunlock:\n  tvh_mutex_unlock(&mi->mi_output_lock);\n}", "path": "tvheadend/src/input/mpegts/mpegts_input.c", "commit_date": "2019-03-20 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/**\n * Add a new DVB table\n */\n", "func_signal": "mpegts_table_t *\nmpegts_table_add\n  ( mpegts_mux_t *mm, int tableid, int mask,\n    mpegts_table_callback_t callback, void *opaque,\n    const char *name, int subsys, int flags, int pid, int weight )", "code": "{\n  mpegts_table_t *mt;\n  int subscribe = 1;\n  char buf[64];\n\n  /* Check for existing */\n  tvh_mutex_lock(&mm->mm_tables_lock);\n  mpegts_table_consistency_check(mm);\n  LIST_FOREACH(mt, &mm->mm_tables, mt_link) {\n    if (mt->mt_opaque != opaque)\n      continue;\n    if (mt->mt_pid < 0) {\n      if (strcmp(mt->mt_name, name))\n        continue;\n      mt->mt_callback   = callback;\n      mt->mt_pid        = pid;\n      mt->mt_weight     = weight;\n      mt->mt_table      = tableid;\n      mm->mm_open_table(mm, mt, 1);\n    } else if (pid >= 0) {\n      if (mt->mt_pid != pid)\n        continue;\n      if (mt->mt_table != tableid)\n        continue;\n      if (mt->mt_callback != callback)\n        continue;\n    } else {\n      if (strcmp(mt->mt_name, name))\n        continue;\n      if (!(flags & MT_SKIPSUBS) && !mt->mt_subscribed)\n        mm->mm_open_table(mm, mt, 1);\n    }\n    mpegts_table_consistency_check(mm);\n    tvh_mutex_unlock(&mm->mm_tables_lock);\n    return mt;\n  }\n  tvhtrace(LS_MPEGTS, \"table: mux %p add %s %02X/%02X (%d) pid %04X (%d)\",\n           mm, name, tableid, mask, tableid, pid, pid);\n\n  /* Create */\n  mt = calloc(1, sizeof(mpegts_table_t));\n  mt->mt_arefcount  = 1;\n  mt->mt_name       = strdup(name);\n  mt->mt_subsys     = subsys;\n  mt->mt_callback   = callback;\n  mt->mt_opaque     = opaque;\n  mt->mt_pid        = pid;\n  mt->mt_weight     = weight;\n  mt->mt_flags      = flags & ~(MT_SKIPSUBS|MT_SCANSUBS);\n  mt->mt_table      = tableid;\n  mt->mt_mask       = mask;\n  mt->mt_mux        = mm;\n  mt->mt_sect.ps_cc = -1;\n  mt->mt_sect.ps_table = tableid;\n  mt->mt_sect.ps_mask = mask;\n  snprintf(buf, sizeof(buf), \"%s %p\", mt->mt_name, mt);\n  tprofile_init(&mt->mt_profile, buf);\n\n  /* Open table */\n  if (pid < 0) {\n    subscribe = 0;\n  } else if (flags & MT_SKIPSUBS) {\n    subscribe = 0;\n  } else if (flags & MT_SCANSUBS) {\n    if (mm->mm_scan_state == MM_SCAN_STATE_IDLE)\n      subscribe = 0;\n  }\n  mm->mm_open_table(mm, mt, subscribe);\n  mpegts_table_consistency_check(mm);\n  tvh_mutex_unlock(&mm->mm_tables_lock);\n  return mt;\n}", "path": "tvheadend/src/input/mpegts/mpegts_table.c", "commit_date": "2018-11-27 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n * Inputs\n */\n", "func_signal": "static int\napi_mpegts_input_network_list\n  ( access_t *perm, void *opaque, const char *op, htsmsg_t *args, htsmsg_t **resp )", "code": "{\n  int i, err = EINVAL;\n  const char *uuid;\n  mpegts_input_t *mi;\n  mpegts_network_t *mn;\n  idnode_set_t *is;\n  char ubuf[UUID_HEX_SIZE];\n  extern const idclass_t mpegts_input_class;\n\n  if (!(uuid = htsmsg_get_str(args, \"uuid\")))\n    return EINVAL;\n\n  tvh_mutex_lock(&global_lock);\n\n  mi = mpegts_input_find(uuid);\n  if (!mi)\n    goto exit;\n\n  htsmsg_t     *l  = htsmsg_create_list();\n  if ((is = mi->mi_network_list(mi))) {\n    for (i = 0; i < is->is_count; i++) {\n      char buf[256];\n      mn = (mpegts_network_t*)is->is_array[i];\n      mn->mn_display_name(mn, buf, sizeof(buf));\n      htsmsg_add_msg(l, NULL, htsmsg_create_key_val(idnode_uuid_as_str(&mn->mn_id, ubuf), buf));\n    }\n    idnode_set_free(is);\n  }\n  err   = 0;\n  *resp = htsmsg_create_map();\n  htsmsg_add_msg(*resp, \"entries\", l);\n\nexit:\n  tvh_mutex_unlock(&global_lock);\n\n  return err;\n}", "path": "tvheadend/src/api/api_mpegts.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/* **************************************************************************\n * Status monitoring\n * *************************************************************************/\n", "func_signal": "void\nmpegts_input_status_timer ( void *p )", "code": "{\n  tvh_input_stream_t st;\n  mpegts_input_t *mi = p;\n  mpegts_mux_instance_t *mmi;\n  htsmsg_t *e;\n  int64_t subs = 0;\n\n  tvh_mutex_lock(&mi->mi_output_lock);\n  LIST_FOREACH(mmi, &mi->mi_mux_active, mmi_active_link) {\n    memset(&st, 0, sizeof(st));\n    mpegts_input_stream_status(mmi, &st);\n    e = tvh_input_stream_create_msg(&st);\n    htsmsg_add_u32(e, \"update\", 1);\n    notify_by_msg(\"input_status\", e, 0);\n    subs += st.subs_count;\n    tvh_input_stream_destroy(&st);\n  }\n  tvh_mutex_unlock(&mi->mi_output_lock);\n  mtimer_arm_rel(&mi->mi_status_timer, mpegts_input_status_timer, mi, sec2mono(1));\n  mpegts_input_dbus_notify(mi, subs);\n}", "path": "tvheadend/src/input/mpegts/mpegts_input.c", "commit_date": "2019-03-20 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/* **************************************************************************\n * Class methods\n * *************************************************************************/\n", "func_signal": "int\nmpegts_input_is_enabled\n  ( mpegts_input_t *mi, mpegts_mux_t *mm, int flags, int weight )", "code": "{\n  if ((flags & SUBSCRIPTION_EPG) != 0 && !mi->mi_ota_epg)\n    return MI_IS_ENABLED_NEVER;\n  if ((flags & SUBSCRIPTION_USERSCAN) == 0) {\n    if ((flags & SUBSCRIPTION_INITSCAN) != 0 && !mi->mi_initscan)\n      return MI_IS_ENABLED_NEVER;\n    if ((flags & SUBSCRIPTION_IDLESCAN) != 0 && !mi->mi_idlescan)\n      return MI_IS_ENABLED_NEVER;\n  }\n  return mi->mi_enabled ? MI_IS_ENABLED_OK : MI_IS_ENABLED_NEVER;\n}", "path": "tvheadend/src/input/mpegts/mpegts_input.c", "commit_date": "2019-03-20 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n * Networks\n */\n", "func_signal": "static void\napi_mpegts_network_grid\n  ( access_t *perm, idnode_set_t *ins, api_idnode_grid_conf_t *conf, htsmsg_t *args )", "code": "{\n  mpegts_network_t *mn;\n\n  LIST_FOREACH(mn, &mpegts_network_all, mn_global_link) {\n    idnode_set_add(ins, (idnode_t*)mn, &conf->filter, perm->aa_lang_ui);\n  }\n}", "path": "tvheadend/src/api/api_mpegts.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n *  Discovery thread\n */\n", "func_signal": "static void *\nupnp_thread( void *aux )", "code": "{\n  char *bindaddr = aux;\n  tvhpoll_t *poll = tvhpoll_create(2);\n  tvhpoll_event_t ev[2];\n  upnp_data_t *data;\n  udp_connection_t *multicast = NULL, *unicast = NULL;\n  udp_connection_t *conn;\n  unsigned char buf[16384];\n  upnp_service_t *us;\n  struct sockaddr_storage ip;\n  socklen_t iplen;\n  size_t size;\n  int r, delay_ms;\n\n  multicast = udp_bind(LS_UPNP, \"upnp_thread_multicast\",\n                       \"239.255.255.250\", 1900, NULL,\n                       NULL, 32*1024, 32*1024);\n  if (multicast == NULL || multicast == UDP_FATAL_ERROR)\n    goto error;\n  unicast = udp_bind(LS_UPNP, \"upnp_thread_unicast\", bindaddr, 0, NULL,\n                     NULL, 32*1024, 32*1024);\n  if (unicast == NULL || unicast == UDP_FATAL_ERROR)\n    goto error;\n\n  tvhpoll_event(ev+0, multicast->fd, TVHPOLL_IN, multicast);\n  tvhpoll_event(ev+1, unicast->fd, TVHPOLL_IN, unicast);\n  tvhpoll_add(poll, ev, 2);\n\n  delay_ms = 0;\n\n  while (atomic_get(&upnp_running) && multicast->fd >= 0) {\n    r = tvhpoll_wait(poll, ev, 2, delay_ms ?: 1000);\n    if (r == 0) /* timeout */\n      delay_ms = 0;\n\n    while (r-- > 0) {\n      if ((ev[r].events & TVHPOLL_IN) != 0) {\n        conn = ev[r].ptr;\n        iplen = sizeof(ip);\n        size = recvfrom(conn->fd, buf, sizeof(buf), 0,\n                                           (struct sockaddr *)&ip, &iplen);\n        if (size > 0 && tvhtrace_enabled()) {\n          char tbuf[256];\n          inet_ntop(ip.ss_family, IP_IN_ADDR(ip), tbuf, sizeof(tbuf));\n          tvhtrace(LS_UPNP, \"%s - received data from %s:%hu [size=%zi]\",\n                   conn == multicast ? \"multicast\" : \"unicast\",\n                   tbuf, (unsigned short) ntohs(IP_PORT(ip)), size);\n          tvhlog_hexdump(LS_UPNP, buf, size);\n        }\n        /* TODO: a filter */\n        TAILQ_FOREACH(us, &upnp_services, us_link)\n          us->us_received(buf, size, conn, &ip);\n      }\n    }\n\n    while (delay_ms == 0) {\n      tvh_mutex_lock(&upnp_lock);\n      data = TAILQ_FIRST(&upnp_data_write);\n      if (data) {\n        delay_ms = data->delay_ms;\n        data->delay_ms = 0;\n        if (!delay_ms) {\n          TAILQ_REMOVE(&upnp_data_write, data, data_link);\n        } else {\n          data = NULL;\n        }\n      }\n      tvh_mutex_unlock(&upnp_lock);\n      if (data == NULL)\n        break;\n      upnp_dump_data(data);\n      udp_write_queue(data->from_multicast ? multicast : unicast,\n                      &data->queue, &data->storage);\n      htsbuf_queue_flush(&data->queue);\n      free(data);\n      delay_ms = 0;\n    }\n  }\n\n  /* flush the write queue (byebye messages) */\n  while (1) {\n    tvh_mutex_lock(&upnp_lock);\n    data = TAILQ_FIRST(&upnp_data_write);\n    if (data)\n      TAILQ_REMOVE(&upnp_data_write, data, data_link);\n    tvh_mutex_unlock(&upnp_lock);\n    if (data == NULL)\n      break;\n    tvh_safe_usleep((long)data->delay_ms * 1000);\n    upnp_dump_data(data);\n    udp_write_queue(unicast, &data->queue, &data->storage);\n    htsbuf_queue_flush(&data->queue);\n    free(data);\n  }\n\nerror:\n  atomic_set(&upnp_running, 0);\n  tvhpoll_destroy(poll);\n  udp_close(unicast);\n  udp_close(multicast);\n  return NULL;\n}", "path": "tvheadend/src/upnp.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/**\n *  Initialize\n */\n", "func_signal": "void\nesfilter_init(void)", "code": "{\n  htsmsg_t *c, *e;\n  htsmsg_field_t *f;\n  int i;\n\n  for (i = 0; i <= ESF_CLASS_LAST; i++) {\n    TAILQ_INIT(&esfilters[i]);\n    if (esfilter_classes[i])\n      idclass_register(esfilter_classes[i]);\n  }\n\n  if (!(c = hts_settings_load(\"esfilter\")))\n    return;\n  HTSMSG_FOREACH(f, c) {\n    if (!(e = htsmsg_field_get_map(f)))\n      continue;\n    esfilter_create(-1, htsmsg_field_name(f), e, 0);\n  }\n  htsmsg_destroy(c);\n\n  for (i = 0; i <= ESF_CLASS_LAST; i++)\n    esfilter_reindex(i);\n}", "path": "tvheadend/src/esfilter.c", "commit_date": "2018-11-27 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n * Create / delete\n */\n", "func_signal": "static void\nesfilter_reindex(esfilter_class_t cls)", "code": "{\n  esfilter_t *esf;\n  int i = 1;\n\n  TAILQ_FOREACH(esf, &esfilters[cls], esf_link)\n    esf->esf_save = 0;\n  TAILQ_FOREACH(esf, &esfilters[cls], esf_link) {\n    if (esf->esf_index != i) {\n      esf->esf_index = i;\n      esf->esf_save = 1;\n    }\n    i++;\n  }\n  TAILQ_FOREACH(esf, &esfilters[cls], esf_link)\n    if (esf->esf_save) {\n      esf->esf_save = 0;\n      idnode_changed(&esf->esf_id);\n    }\n}", "path": "tvheadend/src/esfilter.c", "commit_date": "2018-11-27 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/**\n * Determine table type\n */\n", "func_signal": "int\nmpegts_table_type ( mpegts_table_t *mt )", "code": "{\n  int type = 0;\n  if (mt->mt_flags & MT_FAST) type |= MPS_FTABLE;\n  if (mt->mt_flags & MT_SLOW) type |= MPS_TABLE;\n  if (mt->mt_flags & MT_RECORD) type |= MPS_STREAM;\n  if ((type & (MPS_FTABLE | MPS_TABLE)) == 0) type |= MPS_TABLE;\n  return type;\n}", "path": "tvheadend/src/input/mpegts/mpegts_table.c", "commit_date": "2018-11-27 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n * This routine is called from two places\n * a) start a new service\n * b) restart a running service with possible caid changes\n */\n", "func_signal": "static void\ndvbcam_service_start(caclient_t *cac, service_t *t)", "code": "{\n  dvbcam_t *dc = (dvbcam_t *)cac;\n  dvbcam_active_service_t *as;\n  dvbcam_active_cam_t *ac = NULL;\n  th_descrambler_t *td;\n  elementary_stream_t *st;\n  th_descrambler_runtime_t *dr;\n  caid_t *c = NULL;\n  char buf[128];\n  int i, j;\n#if ENABLE_DDCI\n  mpegts_input_t *mi;\n  mpegts_mux_t *mm;\n  mpegts_apids_t ecm_pids;\n  mpegts_apids_t ecm_to_open;\n  mpegts_apids_t ecm_to_close;\n  linuxdvb_transport_t *lcat;\n#endif\n\n  if (!cac->cac_enabled)\n    return;\n\n  tvhtrace(LS_DVBCAM, \"start service %p\", t);\n\n#if ENABLE_DDCI\n  mpegts_pid_init(&ecm_pids);\n  mpegts_pid_init(&ecm_to_open);\n  mpegts_pid_init(&ecm_to_close);\n#endif\n\n  tvh_mutex_lock(&t->s_stream_mutex);\n  tvh_mutex_lock(&dvbcam_mutex);\n\n  /* is there already a CAM associated to the service? */\n  TAILQ_FOREACH(as, &dvbcam_active_services, global_link) {\n    if (as->td_service == t) {\n      ac = as->ac;\n      goto update_pid;\n    }\n  }\n\n  /*\n   * FIXME: Service limit for DDCI.\n   *        This might be removed or implemented differently in case of\n   *        MCD/MTD. VDR asks the CAM with a query if the CAM can decode another\n   *        PID.\n   *        Note: A CAM has decoding slots, which are used up by each PID which\n   *              gets decoded. This are Audio, Video, Teletext, ..., depending\n   *              of the decoded program this can be more or less PIDs,\n   *              resulting in more or less occupied CAM decoding slots. So the\n   *              simple limit approach might not work or some decoding slots\n   *              remain unused.\n   */\n\n  /* check all or filtered elementary streams for CAIDs and find CAM */\n  for (i = 0; i < ARRAY_SIZE(dc->caid_list); i++) {\n    if (dc->caid_list[0]) {\n      if (dc->caid_list[i] == 0)\n        break;\n    } else {\n      if (i > 0)\n        break;\n    }\n    TAILQ_FOREACH(st, &t->s_components.set_all, es_link) {\n      if (st->es_type != SCT_CA) continue;\n      LIST_FOREACH(c, &st->es_caids, link) {\n        if (!c->use) continue;\n        if (t->s_dvb_forcecaid && t->s_dvb_forcecaid != c->caid) continue;\n        if (dc->caid_list[0] && dc->caid_list[i] != c->caid) continue;\n        TAILQ_FOREACH(ac, &dvbcam_active_cams, global_link) {\n          if (dvbcam_ca_lookup(ac,\n                               ((mpegts_service_t *)t)->s_dvb_active_input,\n                               c->caid)) {\n            /* limit the concurrent service decoders per CAM */\n            if (dc->limit > 0 && ac->allocated_programs >= dc->limit)\n              continue;\n#if ENABLE_DDCI\n            lcat = ac->ca->lca_transport;\n            if (lcat->lddci && linuxdvb_ddci_do_not_assign(lcat->lddci, t,\n                                                           dc->multi))\n              continue;\n#endif\n            tvhtrace(LS_DVBCAM, \"%s/%p: match CAID %04X PID %d (%04X)\",\n                                ac->ca->lca_name, t, c->caid, c->pid, c->pid);\n            goto end_of_search_for_cam;\n          }\n        }\n      }\n    }\n  }\n\nend_of_search_for_cam:\n  if (ac == NULL)\n    goto end;\n\n  if ((as = calloc(1, sizeof(*as))) == NULL)\n    goto end;\n\n  ac->allocated_programs++;\n\n  as->ac = ac;\n\n  if (dc->caid_select == DVBCAM_SEL_FIRST ||\n      t->s_dvb_forcecaid) {\n    as->caid_list[0] = c->caid;\n    as->caid_list[1] = 0;\n    tvhtrace(LS_DVBCAM, \"%s/%p: first CAID %04X selected\",\n                        ac->ca->lca_name, t, as->caid_list[0]);\n  } else {\n    for (i = j = 0; i < ARRAY_SIZE(dc->caid_list); i++) {\n      if (dc->caid_list[0]) {\n        if (dc->caid_list[i] == 0)\n          break;\n      } else {\n        if (i > 0)\n          break;\n      }\n      TAILQ_FOREACH(st, &t->s_components.set_filter, es_link) {\n        if (st->es_type != SCT_CA) continue;\n        LIST_FOREACH(c, &st->es_caids, link) {\n          if (i >= ARRAY_SIZE(as->caid_list)) {\n            tvherror(LS_DVBCAM, \"%s/%p: CAID service list overflow\",\n                                ac->ca->lca_name, t);\n            break;\n          }\n          if (!c->use) continue;\n          if (dc->caid_list[0] && c->caid != dc->caid_list[i]) continue;\n          if (!dvbcam_ca_lookup(ac,\n                                ((mpegts_service_t *)t)->s_dvb_active_input,\n                                c->caid)) continue;\n          if (dc->caid_select != DVBCAM_SEL_LAST)\n            tvhtrace(LS_DVBCAM, \"%s/%p: add CAID %04X to selection\",\n                                ac->ca->lca_name, t, c->caid);\n          as->caid_list[j++] = c->caid;\n        }\n      }\n    }\n    if (j < ARRAY_SIZE(as->caid_list))\n      as->caid_list[j] = 0;\n    if (dc->caid_select == DVBCAM_SEL_LAST && j > 0) {\n      as->caid_list[0] = as->caid_list[j-1];\n      as->caid_list[1] = 0;\n      tvhtrace(LS_DVBCAM, \"%s/%p: last CAID %04X selected\",\n                          ac->ca->lca_name, t, as->caid_list[0]);\n    }\n  }\n\n  mpegts_pid_init(&as->ecm_pids);\n  mpegts_pid_init(&as->cat_pids);\n\n  td = (th_descrambler_t *)as;\n  snprintf(buf, sizeof(buf), \"dvbcam-%i-%i-%04X\",\n           ac->ca->lca_adapnum, ac->ca->lca_slotnum, (int)as->caid_list[0]);\n  td->td_nicename = strdup(buf);\n  td->td_service = t;\n  td->td_stop = dvbcam_service_destroy;\n  dr = t->s_descramble;\n  dr->dr_descrambler = td;\n  dr->dr_descramble = descrambler_pass;\n#if ENABLE_DDCI\n  lcat = ac->ca->lca_transport;\n  if (lcat->lddci) {\n    /* assign the service to the DD CI CAM */\n    linuxdvb_ddci_assign(lcat->lddci, t);\n    dr->dr_descramble = dvbcam_descramble_ddci;\n    as->lddci = lcat->lddci;\n  }\n#endif\n  descrambler_change_keystate(td, DS_READY, 0);\n\n  LIST_INSERT_HEAD(&t->s_descramblers, td, td_service_link);\n\n  LIST_INSERT_HEAD(&dc->services, as, dvbcam_link);\n  TAILQ_INSERT_TAIL(&dvbcam_active_services, as, global_link);\n\nupdate_pid:\n#if ENABLE_DDCI\n  /* open selected ECM PIDs */\n  TAILQ_FOREACH(st, &t->s_components.set_all, es_link) {\n    if (st->es_type != SCT_CA) continue;\n    LIST_FOREACH(c, &st->es_caids, link) {\n      if (!c->use) continue;\n      if (dvbcam_service_check_caid(as, c->caid)) {\n        mpegts_pid_add(&ecm_pids, st->es_pid, 0);\n        tvhtrace(LS_DVBCAM, \"%s/%p: add ECM PID %d (%04X) for CAID %04X\",\n                            ac->ca->lca_name, t, st->es_pid, st->es_pid, c->caid);\n      }\n    }\n  }\n  mpegts_pid_compare(&ecm_pids, &as->ecm_pids, &ecm_to_open, &ecm_to_close);\n  mpegts_pid_copy(&as->ecm_pids, &ecm_pids);\n#endif\n\n  tvh_mutex_unlock(&dvbcam_mutex);\n  tvh_mutex_unlock(&t->s_stream_mutex);\n\n#if ENABLE_DDCI\n  if (as && as->lddci) {\n    mm = ((mpegts_service_t *)t)->s_dvb_mux;\n    mi = mm->mm_active ? mm->mm_active->mmi_input : NULL;\n    if (mi) {\n      tvh_mutex_lock(&mi->mi_output_lock);\n      tvh_mutex_lock(&t->s_stream_mutex);\n      mpegts_input_open_pid(mi, mm, DVB_CAT_PID, MPS_SERVICE | MPS_NOPOSTDEMUX,\n                            MPS_WEIGHT_CAT, t, 0);\n      ((mpegts_service_t *)t)->s_cat_opened = 1;\n      for (i = 0; i < ecm_to_open.count; i++)\n        mpegts_input_open_pid(mi, mm, ecm_to_open.pids[i].pid, MPS_SERVICE,\n                             MPS_WEIGHT_CA, t, 0);\n      for (i = 0; i < ecm_to_close.count; i++)\n        mpegts_input_close_pid(mi, mm, ecm_to_close.pids[i].pid, MPS_SERVICE, t);\n      tvh_mutex_unlock(&t->s_stream_mutex);\n      tvh_mutex_unlock(&mi->mi_output_lock);\n      mpegts_mux_update_pids(mm);\n    }\n  }\n  mpegts_pid_done(&ecm_to_close);\n  mpegts_pid_done(&ecm_to_open);\n  mpegts_pid_done(&ecm_pids);\n#endif\n  return;\n\nend:\n  tvh_mutex_unlock(&dvbcam_mutex);\n  tvh_mutex_unlock(&t->s_stream_mutex);\n}", "path": "tvheadend/src/descrambler/dvbcam.c", "commit_date": "2018-11-27 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n *  Fire up UPnP server\n */\n", "func_signal": "void\nupnp_server_init(const char *bindaddr)", "code": "{\n  int r;\n\n  memset(&upnp_ipv4_multicast, 0, sizeof(upnp_ipv4_multicast));\n  upnp_ipv4_multicast.ss_family       = AF_INET;\n  IP_AS_V4(upnp_ipv4_multicast, port) = htons(1900);\n  r = inet_pton(AF_INET, \"239.255.255.250\", &IP_AS_V4(upnp_ipv4_multicast, addr));\n  assert(r);\n\n  tvh_mutex_init(&upnp_lock, NULL);\n  TAILQ_INIT(&upnp_data_write);\n  TAILQ_INIT(&upnp_services);\n  atomic_set(&upnp_running, 1);\n  tvh_thread_create(&upnp_tid, NULL, upnp_thread, (char *)bindaddr, \"upnp\");\n}", "path": "tvheadend/src/upnp.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n * Mux scheduler\n */\n", "func_signal": "static void\napi_mpegts_mux_sched_grid\n  ( access_t *perm, idnode_set_t *ins, api_idnode_grid_conf_t *conf, htsmsg_t *args )", "code": "{\n  mpegts_mux_sched_t *mms;\n  LIST_FOREACH(mms, &mpegts_mux_sched_all, mms_link)\n    idnode_set_add(ins, (idnode_t*)mms, &conf->filter, perm->aa_lang_ui);\n}", "path": "tvheadend/src/api/api_mpegts.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/**\n * Find a table\n */\n", "func_signal": "mpegts_table_t *mpegts_table_find\n  ( mpegts_mux_t *mm, const char *name, void *opaque )", "code": "{\n  mpegts_table_t *mt;\n\n  tvh_mutex_lock(&mm->mm_tables_lock);\n  mpegts_table_consistency_check(mm);\n  LIST_FOREACH(mt, &mm->mm_tables, mt_link) {\n    if (mt->mt_opaque != opaque)\n      continue;\n    if (strcmp(mt->mt_name, name))\n      continue;\n    mpegts_table_consistency_check(mm);\n    break;\n  }\n  tvh_mutex_unlock(&mm->mm_tables_lock);\n  return mt;\n}", "path": "tvheadend/src/input/mpegts/mpegts_table.c", "commit_date": "2018-11-27 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n * Muxes\n */\n", "func_signal": "static void\napi_mpegts_mux_grid\n  ( access_t *perm, idnode_set_t *ins, api_idnode_grid_conf_t *conf, htsmsg_t *args )", "code": "{\n  mpegts_network_t *mn;\n  mpegts_mux_t *mm;\n  int hide = 1;\n  const char *s = htsmsg_get_str(args, \"hidemode\");\n  if (s) {\n    if (!strcmp(s, \"all\"))\n      hide = 2;\n    else if (!strcmp(s, \"none\"))\n      hide = 0;\n  }\n\n  LIST_FOREACH(mn, &mpegts_network_all, mn_global_link) {\n    if (hide && !mn->mn_enabled) continue;\n    LIST_FOREACH(mm, &mn->mn_muxes, mm_network_link) {\n      if (hide == 2 && !mm->mm_is_enabled(mm)) continue;\n      idnode_set_add(ins, (idnode_t*)mm, &conf->filter, perm->aa_lang_ui);\n    }\n  }\n}", "path": "tvheadend/src/api/api_mpegts.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/* **************************************************************************\n * Data processing\n * *************************************************************************/\n", "func_signal": "static void mpegts_input_analyze_table_queue ( mpegts_input_t *mi )", "code": "{\n  mpegts_table_feed_t *mtf;\n  uint32_t sizes[8192];\n  uint16_t counters[8192];\n  uint16_t pid;\n\n  memset(&sizes, 0, sizeof(sizes));\n  memset(&counters, 0, sizeof(counters));\n  TAILQ_FOREACH(mtf, &mi->mi_table_queue, mtf_link) {\n    const uint8_t *tsb = mtf->mtf_tsb;\n    pid = ((tsb[1] & 0x1f) << 8) | tsb[2];\n    sizes[pid] += mtf->mtf_len;\n    counters[pid]++;\n  }\n  for (pid = 0; pid < 8192; pid++)\n    if (counters[pid])\n      tvhtrace(LS_MPEGTS, \"table queue pid=%04X (%d) cnt %u len %u\", pid, pid, counters[pid], sizes[pid]);\n}", "path": "tvheadend/src/input/mpegts/mpegts_input.c", "commit_date": "2019-03-20 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/*\n * Class functions\n */\n", "func_signal": "static htsmsg_t *\nesfilter_class_save(idnode_t *self, char *filename, size_t fsize)", "code": "{\n  htsmsg_t *c = htsmsg_create_map();\n  char ubuf[UUID_HEX_SIZE];\n  idnode_save(self, c);\n  if (filename)\n    snprintf(filename, fsize, \"esfilter/%s\", idnode_uuid_as_str(self, ubuf));\n  return c;\n}", "path": "tvheadend/src/esfilter.c", "commit_date": "2018-11-27 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/* **************************************************************************\n * Class definition\n * *************************************************************************/\n", "func_signal": "static void\nmpegts_input_class_get_title\n  ( idnode_t *in, const char *lang, char *dst, size_t dstsize )", "code": "{\n  mpegts_input_t *mi = (mpegts_input_t*)in;\n  mi->mi_display_name(mi, dst, dstsize);\n}", "path": "tvheadend/src/input/mpegts/mpegts_input.c", "commit_date": "2019-03-20 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/* MPEG2VIDEO */\n", "func_signal": "static int\ntvh_mpeg2video_meta(TVHContext *self, AVPacket *avpkt, th_pkt_t *pkt)", "code": "{\n    const uint8_t *data = avpkt->data;\n    size_t size = 12; // header size\n\n    if ((avpkt->flags & AV_PKT_FLAG_KEY)) {\n        // sequence header\n        if (avpkt->size < size || RB32(data) != 0x000001b3) { // SEQ_START_CODE\n            tvh_context_log(self, LOG_ERR,\n                \"MPEG2 header: missing sequence header\");\n            return -1;\n        }\n        // load intra quantiser matrix\n        if (data[size-1] & 0x02) {\n            if (avpkt->size < size + 64) {\n                tvh_context_log(self, LOG_ERR,\n                    \"MPEG2 header: missing load intra quantiser matrix\");\n                return -1;\n            }\n            size += 64;\n        }\n        // load non-intra quantiser matrix\n        if (data[size-1] & 0x01) {\n            if (avpkt->size < size + 64) {\n                tvh_context_log(self, LOG_ERR,\n                    \"MPEG2 header: missing load non-intra quantiser matrix\");\n                return -1;\n            }\n            size += 64;\n        }\n        // sequence extension\n        if (avpkt->size < size + 10 || RB32(data + size) != 0x000001b5) { // EXT_START_CODE\n            tvh_context_log(self, LOG_ERR,\n                \"MPEG2 header: missing sequence extension\");\n            return -1;\n        }\n        size += 10;\n        // sequence display extension\n        if (RB32(data + size) == 0x000001b5) { // EXT_START_CODE\n            if (avpkt->size < size + 12) {\n                tvh_context_log(self, LOG_ERR,\n                    \"MPEG2 header: missing sequence display extension\");\n                return -1;\n            }\n            size += 12;\n        }\n        // group of pictures\n        if (avpkt->size < size + 8 || RB32(data + size) != 0x000001b8) { // GOP_START_CODE\n            tvh_context_log(self, LOG_ERR,\n                \"MPEG2 header: missing group of pictures\");\n            return -1;\n        }\n        size += 8;\n        if (!(pkt->pkt_meta = pktbuf_alloc(data, size))) {\n            return -1;\n        }\n        return 0;\n    }\n    return 1;\n}", "path": "tvheadend/src/transcoding/transcode/helpers.c", "commit_date": "2018-03-23 00:00:00", "repo_name": "tvheadend/tvheadend", "stars": 2656, "license": "other", "language": "c", "size": 63658}
{"docstring": "/* a rank-0 HC2R rdft2 problem is just a copy from cr to r0,\n   so we can use a rank-0 rdft plan */\n", "func_signal": "static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)", "code": "{\n     const P *ego = (const P *) ego_;\n     plan_rdft *cldcpy = (plan_rdft *) ego->cldcpy;\n     UNUSED(ci);\n     UNUSED(r1);\n     cldcpy->apply((plan *) cldcpy, cr, r0);\n}", "path": "fftw3/rdft/rank0-rdft2.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* like cpy2d_pair, but read input contiguously if possible */\n", "func_signal": "void X(cpy2d_pair_ci)(R *I0, R *I1, R *O0, R *O1,\n\t\t      INT n0, INT is0, INT os0,\n\t\t      INT n1, INT is1, INT os1)", "code": "{\n     if (IABS(is0) < IABS(is1))\t/* inner loop is for n0 */\n\t  X(cpy2d_pair) (I0, I1, O0, O1, n0, is0, os0, n1, is1, os1);\n     else\n\t  X(cpy2d_pair) (I0, I1, O0, O1, n1, is1, os1, n0, is0, os0);\n}", "path": "fftw3/kernel/cpy2d-pair.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* C = A + B */\n", "func_signal": "void aadd(C *c, C *a, C *b, int n)", "code": "{\n     int i;\n\n     for (i = 0; i < n; ++i) {\n\t  c_re(c[i]) = c_re(a[i]) + c_re(b[i]);\n\t  c_im(c[i]) = c_im(a[i]) + c_im(b[i]);\n     }\n}", "path": "fftw3/libbench2/verify-lib.c", "commit_date": "2016-06-05 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* B = rotate left A (complex) */\n", "func_signal": "void arol(C *b, C *a, int n, int nb, int na)", "code": "{\n     int i, ib, ia;\n\n     for (ib = 0; ib < nb; ++ib) {\n\t  for (i = 0; i < n - 1; ++i)\n\t       for (ia = 0; ia < na; ++ia) {\n\t\t    C *pb = b + (ib * n + i) * na + ia;\n\t\t    C *pa = a + (ib * n + i + 1) * na + ia;\n\t\t    c_re(*pb) = c_re(*pa);\n\t\t    c_im(*pb) = c_im(*pa);\n\t       }\n\n\t  for (ia = 0; ia < na; ++ia) {\n\t       C *pb = b + (ib * n + n - 1) * na + ia;\n\t       C *pa = a + ib * n * na + ia;\n\t       c_re(*pb) = c_re(*pa);\n\t       c_im(*pb) = c_im(*pa);\n\t  }\n     }\n}", "path": "fftw3/libbench2/verify-lib.c", "commit_date": "2016-06-05 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* ro10 is same as re10, but with i <-> n - 1 - i in the output and\n   the sign of the odd input elements flipped. */\n", "func_signal": "static void apply_ro10(const plan *ego_, R *I, R *O)", "code": "{\n     const P *ego = (const P *) ego_;\n     INT is = ego->is, os = ego->os;\n     INT i, n = ego->n;\n     INT iv, vl = ego->vl;\n     INT ivs = ego->ivs, ovs = ego->ovs;\n     R *W = ego->td->W;\n     R *buf;\n\n     buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);\n\n     for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {\n\t  buf[0] = I[0];\n\t  for (i = 1; i < n - i; ++i) {\n\t       E u, v;\n\t       INT k = i + i;\n\t       u = -I[is * (k - 1)];\n\t       v = I[is * k];\n\t       buf[n - i] = u;\n\t       buf[i] = v;\n\t  }\n\t  if (i == n - i) {\n\t       buf[i] = -I[is * (n - 1)];\n\t  }\n\t  \n\t  {\n\t       plan_rdft *cld = (plan_rdft *) ego->cld;\n\t       cld->apply((plan *) cld, buf, buf);\n\t  }\n\t  \n\t  O[os * (n - 1)] = K(2.0) * buf[0];\n\t  for (i = 1; i < n - i; ++i) {\n\t       E a, b, wa, wb;\n\t       a = K(2.0) * buf[i];\n\t       b = K(2.0) * buf[n - i];\n\t       wa = W[2*i];\n\t       wb = W[2*i + 1];\n\t       O[os * (n - 1 - i)] = wa * a + wb * b;\n\t       O[os * (i - 1)] = wb * a - wa * b;\n\t  }\n\t  if (i == n - i) {\n\t       O[os * (i - 1)] = K(2.0) * buf[i] * W[2*i];\n\t  }\n     }\n\n     X(ifree)(buf);\n}", "path": "fftw3/reodft/reodft010e-r2hc.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* guru interface: requires care in alignment etcetera. */\n", "func_signal": "void X(execute_dft)(const X(plan) p, C *in, C *out)", "code": "{\n     plan_dft *pln = (plan_dft *) p->pln;\n     if (p->sign == FFT_SIGN)\n\t  pln->apply((plan *) pln, in[0], in[0]+1, out[0], out[0]+1);\n     else\n\t  pln->apply((plan *) pln, in[0]+1, in[0], out[0]+1, out[0]);\n}", "path": "fftw3/api/execute-dft.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* Make a copy of the size tensor, with the same dimensions, but with\n   the strides corresponding to a \"packed\" row-major array with the\n   given stride. */\n", "func_signal": "bench_tensor *verify_pack(const bench_tensor *sz, int s)", "code": "{\n     bench_tensor *x = tensor_copy(sz);\n     if (BENCH_FINITE_RNK(x->rnk) && x->rnk > 0) {\n\t  int i;\n\t  x->dims[x->rnk - 1].is = s;\n\t  x->dims[x->rnk - 1].os = s;\n\t  for (i = x->rnk - 1; i > 0; --i) {\n\t       x->dims[i - 1].is = x->dims[i].is * x->dims[i].n;\n\t       x->dims[i - 1].os = x->dims[i].os * x->dims[i].n;\n\t  }\n     }\n     return x;\n}", "path": "fftw3/libbench2/verify-lib.c", "commit_date": "2016-06-05 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* in-place r2hc rank-0: set imaginary parts of output to 0 */\n", "func_signal": "static void apply_r2hc_inplace(const plan *ego_, R *r0, R *r1, R *cr, R *ci)", "code": "{\n     const P *ego = (const P *) ego_;\n     INT i, vl = ego->vl;\n     INT ovs = ego->ovs;\n\n     UNUSED(r0); UNUSED(r1); UNUSED(cr);\n\n     for (i = 4; i <= vl; i += 4) {\n\t  *ci = K(0.0); ci += ovs;\n\t  *ci = K(0.0); ci += ovs;\n\t  *ci = K(0.0); ci += ovs;\n\t  *ci = K(0.0); ci += ovs;\n     }\n     for (; i < vl + 4; ++i) {\n\t  *ci = K(0.0); ci += ovs;\n     }\n}", "path": "fftw3/rdft/rank0-rdft2.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* use the apply() operation for DFT problems */\n", "func_signal": "void X(dft_solve)(const plan *ego_, const problem *p_)", "code": "{\n     const plan_dft *ego = (const plan_dft *) ego_;\n     const problem_dft *p = (const problem_dft *) p_;\n     ego->apply(ego_, \n\t\tUNTAINT(p->ri), UNTAINT(p->ii), \n\t\tUNTAINT(p->ro), UNTAINT(p->io));\n}", "path": "fftw3/dft/solve.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* like cpy2d_pair, but write output contiguously if possible */\n", "func_signal": "void X(cpy2d_pair_co)(R *I0, R *I1, R *O0, R *O1,\n\t\t      INT n0, INT is0, INT os0,\n\t\t      INT n1, INT is1, INT os1)", "code": "{\n     if (IABS(os0) < IABS(os1))\t/* inner loop is for n0 */\n\t  X(cpy2d_pair) (I0, I1, O0, O1, n0, is0, os0, n1, is1, os1);\n     else\n\t  X(cpy2d_pair) (I0, I1, O0, O1, n1, is1, os1, n0, is0, os0);\n}", "path": "fftw3/kernel/cpy2d-pair.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/*\n * Utility functions:\n */\n", "func_signal": "static double dabs(double x)", "code": "{ return (x < 0.0) ? -x : x; }\nstatic double dmin(double x, double y) { return (x < y) ? x : y; }\nstatic double norm2(double x, double y) { return dmax(dabs(x), dabs(y)); }\n\ndouble dmax(double x, double y) { return (x > y) ? x : y; }\n\nstatic double aerror(C *a, C *b, int n)\n{\n     if (n > 0) {\n\t  /* compute the relative Linf error */\n\t  double e = 0.0, mag = 0.0;\n\t  int i;\n\n\t  for (i = 0; i < n; ++i) {\n\t       e = dmax(e, norm2(c_re(a[i]) - c_re(b[i]),\n\t\t\t\t c_im(a[i]) - c_im(b[i])));\n\t       mag = dmax(mag, \n\t\t\t  dmin(norm2(c_re(a[i]), c_im(a[i])),\n\t\t\t       norm2(c_re(b[i]), c_im(b[i]))));\n\t  }\n\t  e /= mag;\n\n#ifdef HAVE_ISNAN\n\t  BENCH_ASSERT(!isnan(e));\n#endif\n\t  return e;\n     } else\n\t  return 0.0;\n}", "path": "fftw3/libbench2/verify-lib.c", "commit_date": "2016-06-05 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* constructor */\n", "func_signal": "static solver *mksolver(void)", "code": "{\n     static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };\n     S *slv = MKSOLVER(S, &sadt);\n     return &(slv->super);\n}", "path": "fftw3/reodft/reodft010e-r2hc.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* make array real */\n", "func_signal": "void mkreal(C *A, int n)", "code": "{\n     int i;\n\n     for (i = 0; i < n; ++i) {\n          c_im(A[i]) = 0.0;\n     }\n}", "path": "fftw3/libbench2/verify-lib.c", "commit_date": "2016-06-05 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* Like really_pickdim, but only returns 1 if no previous \"buddy\"\n   which_dim in the buddies list would give the same dim. */\n", "func_signal": "int X(pickdim)(int which_dim, const int *buddies, size_t nbuddies,\n\t       const tensor *sz, int oop, int *dp)", "code": "{\n     size_t i;\n     int d1;\n\n     if (!really_pickdim(which_dim, sz, oop, dp))\n          return 0;\n\n     /* check whether some buddy solver would produce the same dim.\n        If so, consider this solver unapplicable and let the buddy\n        take care of it.  The smallest-indexed buddy is applicable. */\n     for (i = 0; i < nbuddies; ++i) {\n          if (buddies[i] == which_dim)\n               break;  /* found self */\n          if (really_pickdim(buddies[i], sz, oop, &d1) && *dp == d1)\n               return 0; /* found equivalent buddy */\n     }\n     return 1;\n}", "path": "fftw3/kernel/pickdim.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* Given a solver which_dim, a vector sz, and whether or not the\n   transform is out-of-place, return the actual dimension index that\n   it corresponds to.  The basic idea here is that we return the\n   which_dim'th valid dimension, starting from the end if\n   which_dim < 0. */\n", "func_signal": "static int really_pickdim(int which_dim, const tensor *sz, int oop, int *dp)", "code": "{\n     int i;\n     int count_ok = 0;\n     if (which_dim > 0) {\n          for (i = 0; i < sz->rnk; ++i) {\n               if (oop || sz->dims[i].is == sz->dims[i].os)\n                    if (++count_ok == which_dim) {\n                         *dp = i;\n                         return 1;\n                    }\n          }\n     }\n     else if (which_dim < 0) {\n          for (i = sz->rnk - 1; i >= 0; --i) {\n               if (oop || sz->dims[i].is == sz->dims[i].os)\n                    if (++count_ok == -which_dim) {\n                         *dp = i;\n                         return 1;\n                    }\n          }\n     }\n     else { /* zero: pick the middle, if valid */\n\t  i = (sz->rnk - 1) / 2;\n\t  if (i >= 0 && (oop || sz->dims[i].is == sz->dims[i].os)) {\n\t       *dp = i;\n\t       return 1;\n\t  }\n     }\n     return 0;\n}", "path": "fftw3/kernel/pickdim.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* make array hermitian */\n", "func_signal": "void mkhermitian(C *A, int rank, const bench_iodim *dim, int stride)", "code": "{\n     if (rank == 0)\n          c_im(*A) = 0.0;\n     else {\n          int i, n0 = dim[rank - 1].n, s = stride;\n          rank -= 1;\n\t  stride *= n0;\n          mkhermitian(A, rank, dim, stride);\n          for (i = 1; 2*i < n0; ++i)\n               assign_conj(A + (n0 - i) * s, A + i * s, rank, dim, stride);\n          if (2*i == n0)\n               mkhermitian(A + i * s, rank, dim, stride);\n     }\n}", "path": "fftw3/libbench2/verify-lib.c", "commit_date": "2016-06-05 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* ro01 is same as re01, but with i <-> n - 1 - i in the input and\n   the sign of the odd output elements flipped. */\n", "func_signal": "static void apply_ro01(const plan *ego_, R *I, R *O)", "code": "{\n     const P *ego = (const P *) ego_;\n     INT is = ego->is, os = ego->os;\n     INT i, n = ego->n;\n     INT iv, vl = ego->vl;\n     INT ivs = ego->ivs, ovs = ego->ovs;\n     R *W = ego->td->W;\n     R *buf;\n\n     buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);\n\n     for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {\n\t  buf[0] = I[is * (n - 1)];\n\t  for (i = 1; i < n - i; ++i) {\n\t       E a, b, apb, amb, wa, wb;\n\t       a = I[is * (n - 1 - i)];\n\t       b = I[is * (i - 1)];\n\t       apb = a + b;\n\t       amb = a - b;\n\t       wa = W[2*i];\n\t       wb = W[2*i+1];\n\t       buf[i] = wa * amb + wb * apb; \n\t       buf[n - i] = wa * apb - wb * amb; \n\t  }\n\t  if (i == n - i) {\n\t       buf[i] = K(2.0) * I[is * (i - 1)] * W[2*i];\n\t  }\n\t  \n\t  {\n\t       plan_rdft *cld = (plan_rdft *) ego->cld;\n\t       cld->apply((plan *) cld, buf, buf);\n\t  }\n\t  \n\t  O[0] = buf[0];\n\t  for (i = 1; i < n - i; ++i) {\n\t       E a, b;\n\t       INT k;\n\t       a = buf[i];\n\t       b = buf[n - i];\n\t       k = i + i;\n\t       O[os * (k - 1)] = b - a;\n\t       O[os * k] = a + b;\n\t  }\n\t  if (i == n - i) {\n\t       O[os * (n - 1)] = -buf[i];\n\t  }\n     }\n\n     X(ifree)(buf);\n}", "path": "fftw3/reodft/reodft010e-r2hc.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* Same as X(mkproblem_dft), but also destroy input tensors. */\n", "func_signal": "problem *X(mkproblem_dft_d)(tensor *sz, tensor *vecsz,\n\t\t\t    R *ri, R *ii, R *ro, R *io)", "code": "{\n     problem *p = X(mkproblem_dft)(sz, vecsz, ri, ii, ro, io);\n     X(tensor_destroy2)(vecsz, sz);\n     return p;\n}", "path": "fftw3/dft/problem.c", "commit_date": "2017-09-20 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/*\n * Implementation of the FFT tester described in\n *\n * Funda Ergn. Testing multivariate linear functions: Overcoming the\n * generator bottleneck. In Proceedings of the Twenty-Seventh Annual\n * ACM Symposium on the Theory of Computing, pages 407-416, Las Vegas,\n * Nevada, 29 May--1 June 1995.\n *\n * Also: F. Ergun, S. R. Kumar, and D. Sivakumar, \"Self-testing without\n * the generator bottleneck,\" SIAM J. on Computing 29 (5), 1630-51 (2000).\n */\n", "func_signal": "static double impulse0(dofft_closure *k,\n\t\t       int n, int vecn, \n\t\t       C *inA, C *inB, C *inC,\n\t\t       C *outA, C *outB, C *outC,\n\t\t       C *tmp, int rounds, double tol)", "code": "{\n     int N = n * vecn;\n     double e = 0.0;\n     int j;\n\n     k->apply(k, inA, tmp);\n     e = dmax(e, acmp(tmp, outA, N, \"impulse 1\", tol));\n\n     for (j = 0; j < rounds; ++j) {\n\t  arand(inB, N);\n\t  asub(inC, inA, inB, N);\n\t  k->apply(k, inB, outB);\n\t  k->apply(k, inC, outC);\n\t  aadd(tmp, outB, outC, N);\n\t  e = dmax(e, acmp(tmp, outA, N, \"impulse\", tol));\n     }\n     return e;\n}", "path": "fftw3/libbench2/verify-lib.c", "commit_date": "2016-06-05 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/* C = A - B */\n", "func_signal": "void asub(C *c, C *a, C *b, int n)", "code": "{\n     int i;\n\n     for (i = 0; i < n; ++i) {\n\t  c_re(c[i]) = c_re(a[i]) - c_re(b[i]);\n\t  c_im(c[i]) = c_im(a[i]) - c_im(b[i]);\n     }\n}", "path": "fftw3/libbench2/verify-lib.c", "commit_date": "2016-06-05 00:00:00", "repo_name": "FFTW/fftw3", "stars": 2555, "license": "gpl-2.0", "language": "c", "size": 11674}
{"docstring": "/*\n * Find an extent with size [min_size, max_size) to satisfy the alignment\n * requirement.  For each size, try only the first extent in the heap.\n */\n", "func_signal": "static extent_t *\nextents_fit_alignment(extents_t *extents, size_t min_size, size_t max_size,\n    size_t alignment)", "code": "{\n        pszind_t pind = sz_psz2ind(extent_size_quantize_ceil(min_size));\n        pszind_t pind_max = sz_psz2ind(extent_size_quantize_ceil(max_size));\n\n\tfor (pszind_t i = (pszind_t)bitmap_ffu(extents->bitmap,\n\t    &extents_bitmap_info, (size_t)pind); i < pind_max; i =\n\t    (pszind_t)bitmap_ffu(extents->bitmap, &extents_bitmap_info,\n\t    (size_t)i+1)) {\n\t\tassert(i < NPSIZES);\n\t\tassert(!extent_heap_empty(&extents->heaps[i]));\n\t\textent_t *extent = extent_heap_first(&extents->heaps[i]);\n\t\tuintptr_t base = (uintptr_t)extent_base_get(extent);\n\t\tsize_t candidate_size = extent_size_get(extent);\n\t\tassert(candidate_size >= min_size);\n\n\t\tuintptr_t next_align = ALIGNMENT_CEILING((uintptr_t)base,\n\t\t    PAGE_CEILING(alignment));\n\t\tif (base > next_align || base + candidate_size <= next_align) {\n\t\t\t/* Overflow or not crossing the next alignment. */\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize_t leadsize = next_align - base;\n\t\tif (candidate_size - leadsize >= min_size) {\n\t\t\treturn extent;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * This fulfills the indicated allocation request out of the given extent (which\n * the caller should have ensured was big enough).  If there's any unused space\n * before or after the resulting allocation, that space is given its own extent\n * and put back into extents.\n */\n", "func_signal": "static extent_t *\nextent_recycle_split(tsdn_t *tsdn, arena_t *arena,\n    extent_hooks_t **r_extent_hooks, rtree_ctx_t *rtree_ctx, extents_t *extents,\n    void *new_addr, size_t size, size_t pad, size_t alignment, bool slab,\n    szind_t szind, extent_t *extent, bool growing_retained)", "code": "{\n\textent_t *lead;\n\textent_t *trail;\n\textent_t *to_leak;\n\textent_t *to_salvage;\n\n\textent_split_interior_result_t result = extent_split_interior(\n\t    tsdn, arena, r_extent_hooks, rtree_ctx, &extent, &lead, &trail,\n\t    &to_leak, &to_salvage, new_addr, size, pad, alignment, slab, szind,\n\t    growing_retained);\n\n\tif (result == extent_split_interior_ok) {\n\t\tif (lead != NULL) {\n\t\t\textent_deactivate(tsdn, arena, extents, lead);\n\t\t}\n\t\tif (trail != NULL) {\n\t\t\textent_deactivate(tsdn, arena, extents, trail);\n\t\t}\n\t\treturn extent;\n\t} else {\n\t\t/*\n\t\t * We should have picked an extent that was large enough to\n\t\t * fulfill our allocation request.\n\t\t */\n\t\tassert(result == extent_split_interior_error);\n\t\tif (to_salvage != NULL) {\n\t\t\textent_deregister(tsdn, to_salvage);\n\t\t}\n\t\tif (to_leak != NULL) {\n\t\t\tvoid *leak = extent_base_get(to_leak);\n\t\t\textent_deregister_no_gdump_sub(tsdn, to_leak);\n\t\t\textents_leak(tsdn, arena, r_extent_hooks, extents,\n\t\t\t    to_leak, growing_retained);\n\t\t\tassert(extent_lock_from_addr(tsdn, rtree_ctx, leak)\n\t\t\t    == NULL);\n\t\t}\n\t\treturn NULL;\n\t}\n\tunreachable();\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * If virtual memory is retained, create increasingly larger extents from which\n * to split requested extents in order to limit the total number of disjoint\n * virtual memory ranges retained by each arena.\n */\n", "func_signal": "static extent_t *\nextent_grow_retained(tsdn_t *tsdn, arena_t *arena,\n    extent_hooks_t **r_extent_hooks, size_t size, size_t pad, size_t alignment,\n    bool slab, szind_t szind, bool *zero, bool *commit)", "code": "{\n\tmalloc_mutex_assert_owner(tsdn, &arena->extent_grow_mtx);\n\tassert(pad == 0 || !slab);\n\tassert(!*zero || !slab);\n\n\tsize_t esize = size + pad;\n\tsize_t alloc_size_min = esize + PAGE_CEILING(alignment) - PAGE;\n\t/* Beware size_t wrap-around. */\n\tif (alloc_size_min < esize) {\n\t\tgoto label_err;\n\t}\n\t/*\n\t * Find the next extent size in the series that would be large enough to\n\t * satisfy this request.\n\t */\n\tpszind_t egn_skip = 0;\n\tsize_t alloc_size = sz_pind2sz(arena->extent_grow_next + egn_skip);\n\twhile (alloc_size < alloc_size_min) {\n\t\tegn_skip++;\n\t\tif (arena->extent_grow_next + egn_skip == NPSIZES) {\n\t\t\t/* Outside legal range. */\n\t\t\tgoto label_err;\n\t\t}\n\t\tassert(arena->extent_grow_next + egn_skip < NPSIZES);\n\t\talloc_size = sz_pind2sz(arena->extent_grow_next + egn_skip);\n\t}\n\n\textent_t *extent = extent_alloc(tsdn, arena);\n\tif (extent == NULL) {\n\t\tgoto label_err;\n\t}\n\tbool zeroed = false;\n\tbool committed = false;\n\n\tvoid *ptr;\n\tif (*r_extent_hooks == &extent_hooks_default) {\n\t\tptr = extent_alloc_default_impl(tsdn, arena, NULL,\n\t\t    alloc_size, PAGE, &zeroed, &committed);\n\t} else {\n\t\textent_hook_pre_reentrancy(tsdn, arena);\n\t\tptr = (*r_extent_hooks)->alloc(*r_extent_hooks, NULL,\n\t\t    alloc_size, PAGE, &zeroed, &committed,\n\t\t    arena_ind_get(arena));\n\t\textent_hook_post_reentrancy(tsdn);\n\t}\n\n\textent_init(extent, arena, ptr, alloc_size, false, NSIZES,\n\t    arena_extent_sn_next(arena), extent_state_active, zeroed,\n\t    committed, true);\n\tif (ptr == NULL) {\n\t\textent_dalloc(tsdn, arena, extent);\n\t\tgoto label_err;\n\t}\n\n\tif (extent_register_no_gdump_add(tsdn, extent)) {\n\t\textents_leak(tsdn, arena, r_extent_hooks,\n\t\t    &arena->extents_retained, extent, true);\n\t\tgoto label_err;\n\t}\n\n\tif (extent_zeroed_get(extent) && extent_committed_get(extent)) {\n\t\t*zero = true;\n\t}\n\tif (extent_committed_get(extent)) {\n\t\t*commit = true;\n\t}\n\n\trtree_ctx_t rtree_ctx_fallback;\n\trtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);\n\n\textent_t *lead;\n\textent_t *trail;\n\textent_t *to_leak;\n\textent_t *to_salvage;\n\textent_split_interior_result_t result = extent_split_interior(\n\t    tsdn, arena, r_extent_hooks, rtree_ctx, &extent, &lead, &trail,\n\t    &to_leak, &to_salvage, NULL, size, pad, alignment, slab, szind,\n\t    true);\n\n\tif (result == extent_split_interior_ok) {\n\t\tif (lead != NULL) {\n\t\t\textent_record(tsdn, arena, r_extent_hooks,\n\t\t\t    &arena->extents_retained, lead, true);\n\t\t}\n\t\tif (trail != NULL) {\n\t\t\textent_record(tsdn, arena, r_extent_hooks,\n\t\t\t    &arena->extents_retained, trail, true);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We should have allocated a sufficiently large extent; the\n\t\t * cant_alloc case should not occur.\n\t\t */\n\t\tassert(result == extent_split_interior_error);\n\t\tif (to_salvage != NULL) {\n\t\t\tif (config_prof) {\n\t\t\t\textent_gdump_add(tsdn, to_salvage);\n\t\t\t}\n\t\t\textent_record(tsdn, arena, r_extent_hooks,\n\t\t\t    &arena->extents_retained, to_salvage, true);\n\t\t}\n\t\tif (to_leak != NULL) {\n\t\t\textent_deregister_no_gdump_sub(tsdn, to_leak);\n\t\t\textents_leak(tsdn, arena, r_extent_hooks,\n\t\t\t    &arena->extents_retained, to_leak, true);\n\t\t}\n\t\tgoto label_err;\n\t}\n\n\tif (*commit && !extent_committed_get(extent)) {\n\t\tif (extent_commit_impl(tsdn, arena, r_extent_hooks, extent, 0,\n\t\t    extent_size_get(extent), true)) {\n\t\t\textent_record(tsdn, arena, r_extent_hooks,\n\t\t\t    &arena->extents_retained, extent, true);\n\t\t\tgoto label_err;\n\t\t}\n\t\textent_zeroed_set(extent, true);\n\t}\n\n\t/*\n\t * Increment extent_grow_next if doing so wouldn't exceed the allowed\n\t * range.\n\t */\n\tif (arena->extent_grow_next + egn_skip + 1 <=\n\t    arena->retain_grow_limit) {\n\t\tarena->extent_grow_next += egn_skip + 1;\n\t} else {\n\t\tarena->extent_grow_next = arena->retain_grow_limit;\n\t}\n\t/* All opportunities for failure are past. */\n\tmalloc_mutex_unlock(tsdn, &arena->extent_grow_mtx);\n\n\tif (config_prof) {\n\t\t/* Adjust gdump stats now that extent is final size. */\n\t\textent_gdump_add(tsdn, extent);\n\t}\n\tif (pad != 0) {\n\t\textent_addr_randomize(tsdn, extent, alignment);\n\t}\n\tif (slab) {\n\t\trtree_ctx_t rtree_ctx_fallback;\n\t\trtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,\n\t\t    &rtree_ctx_fallback);\n\n\t\textent_slab_set(extent, true);\n\t\textent_interior_register(tsdn, rtree_ctx, extent, szind);\n\t}\n\tif (*zero && !extent_zeroed_get(extent)) {\n\t\tvoid *addr = extent_base_get(extent);\n\t\tsize_t size = extent_size_get(extent);\n\t\tif (pages_purge_forced(addr, size)) {\n\t\t\tmemset(addr, 0, size);\n\t\t}\n\t}\n\n\treturn extent;\nlabel_err:\n\tmalloc_mutex_unlock(tsdn, &arena->extent_grow_mtx);\n\treturn NULL;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Removes all pointers to the given extent from the global rtree.\n */\n", "func_signal": "static void\nextent_deregister_impl(tsdn_t *tsdn, extent_t *extent, bool gdump)", "code": "{\n\trtree_ctx_t rtree_ctx_fallback;\n\trtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);\n\trtree_leaf_elm_t *elm_a, *elm_b;\n\textent_rtree_leaf_elms_lookup(tsdn, rtree_ctx, extent, true, false,\n\t    &elm_a, &elm_b);\n\n\textent_lock(tsdn, extent);\n\n\textent_rtree_write_acquired(tsdn, elm_a, elm_b, NULL, NSIZES, false);\n\tif (extent_slab_get(extent)) {\n\t\textent_interior_deregister(tsdn, rtree_ctx, extent);\n\t\textent_slab_set(extent, false);\n\t}\n\n\textent_unlock(tsdn, extent);\n\n\tif (config_prof && gdump) {\n\t\textent_gdump_sub(tsdn, extent);\n\t}\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Tries to find and remove an extent from extents that can be used for the\n * given allocation request.\n */\n", "func_signal": "static extent_t *\nextent_recycle_extract(tsdn_t *tsdn, arena_t *arena,\n    extent_hooks_t **r_extent_hooks, rtree_ctx_t *rtree_ctx, extents_t *extents,\n    void *new_addr, size_t size, size_t pad, size_t alignment, bool slab,\n    bool growing_retained)", "code": "{\n\twitness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),\n\t    WITNESS_RANK_CORE, growing_retained ? 1 : 0);\n\tassert(alignment > 0);\n\tif (config_debug && new_addr != NULL) {\n\t\t/*\n\t\t * Non-NULL new_addr has two use cases:\n\t\t *\n\t\t *   1) Recycle a known-extant extent, e.g. during purging.\n\t\t *   2) Perform in-place expanding reallocation.\n\t\t *\n\t\t * Regardless of use case, new_addr must either refer to a\n\t\t * non-existing extent, or to the base of an extant extent,\n\t\t * since only active slabs support interior lookups (which of\n\t\t * course cannot be recycled).\n\t\t */\n\t\tassert(PAGE_ADDR2BASE(new_addr) == new_addr);\n\t\tassert(pad == 0);\n\t\tassert(alignment <= PAGE);\n\t}\n\n\tsize_t esize = size + pad;\n\tmalloc_mutex_lock(tsdn, &extents->mtx);\n\textent_hooks_assure_initialized(arena, r_extent_hooks);\n\textent_t *extent;\n\tif (new_addr != NULL) {\n\t\textent = extent_lock_from_addr(tsdn, rtree_ctx, new_addr);\n\t\tif (extent != NULL) {\n\t\t\t/*\n\t\t\t * We might null-out extent to report an error, but we\n\t\t\t * still need to unlock the associated mutex after.\n\t\t\t */\n\t\t\textent_t *unlock_extent = extent;\n\t\t\tassert(extent_base_get(extent) == new_addr);\n\t\t\tif (extent_arena_get(extent) != arena ||\n\t\t\t    extent_size_get(extent) < esize ||\n\t\t\t    extent_state_get(extent) !=\n\t\t\t    extents_state_get(extents)) {\n\t\t\t\textent = NULL;\n\t\t\t}\n\t\t\textent_unlock(tsdn, unlock_extent);\n\t\t}\n\t} else {\n\t\textent = extents_fit_locked(tsdn, arena, extents, esize,\n\t\t    alignment);\n\t}\n\tif (extent == NULL) {\n\t\tmalloc_mutex_unlock(tsdn, &extents->mtx);\n\t\treturn NULL;\n\t}\n\n\textent_activate_locked(tsdn, arena, extents, extent);\n\tmalloc_mutex_unlock(tsdn, &extents->mtx);\n\n\treturn extent;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Returns a pool-locked extent_t * if there's one associated with the given\n * address, and NULL otherwise.\n */\n", "func_signal": "static extent_t *\nextent_lock_from_addr(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx, void *addr)", "code": "{\n\textent_t *ret = NULL;\n\trtree_leaf_elm_t *elm = rtree_leaf_elm_lookup(tsdn, &extents_rtree,\n\t    rtree_ctx, (uintptr_t)addr, false, false);\n\tif (elm == NULL) {\n\t\treturn NULL;\n\t}\n\tlock_result_t lock_result;\n\tdo {\n\t\tlock_result = extent_rtree_leaf_elm_try_lock(tsdn, elm, &ret);\n\t} while (lock_result == lock_result_failure);\n\treturn ret;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/* Generate pairing heap functions. */\n", "func_signal": "ph_gen(, extent_heap_, extent_heap_t, extent_t, ph_link, extent_snad_comp)\n\nbool\nextents_init(tsdn_t *tsdn, extents_t *extents, extent_state_t state,\n    bool delay_coalesce)", "code": "{\n\tif (malloc_mutex_init(&extents->mtx, \"extents\", WITNESS_RANK_EXTENTS,\n\t    malloc_mutex_rank_exclusive)) {\n\t\treturn true;\n\t}\n\tfor (unsigned i = 0; i < NPSIZES+1; i++) {\n\t\textent_heap_new(&extents->heaps[i]);\n\t}\n\tbitmap_init(extents->bitmap, &extents_bitmap_info, true);\n\textent_list_init(&extents->lru);\n\tatomic_store_zu(&extents->npages, 0, ATOMIC_RELAXED);\n\textents->state = state;\n\textents->delay_coalesce = delay_coalesce;\n\treturn false;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Tries to satisfy the given allocation request by reusing one of the extents\n * in the given extents_t.\n */\n", "func_signal": "static extent_t *\nextent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,\n    extents_t *extents, void *new_addr, size_t size, size_t pad,\n    size_t alignment, bool slab, szind_t szind, bool *zero, bool *commit,\n    bool growing_retained)", "code": "{\n\twitness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),\n\t    WITNESS_RANK_CORE, growing_retained ? 1 : 0);\n\tassert(new_addr == NULL || !slab);\n\tassert(pad == 0 || !slab);\n\tassert(!*zero || !slab);\n\n\trtree_ctx_t rtree_ctx_fallback;\n\trtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);\n\n\textent_t *extent = extent_recycle_extract(tsdn, arena, r_extent_hooks,\n\t    rtree_ctx, extents, new_addr, size, pad, alignment, slab,\n\t    growing_retained);\n\tif (extent == NULL) {\n\t\treturn NULL;\n\t}\n\n\textent = extent_recycle_split(tsdn, arena, r_extent_hooks, rtree_ctx,\n\t    extents, new_addr, size, pad, alignment, slab, szind, extent,\n\t    growing_retained);\n\tif (extent == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (*commit && !extent_committed_get(extent)) {\n\t\tif (extent_commit_impl(tsdn, arena, r_extent_hooks, extent,\n\t\t    0, extent_size_get(extent), growing_retained)) {\n\t\t\textent_record(tsdn, arena, r_extent_hooks, extents,\n\t\t\t    extent, growing_retained);\n\t\t\treturn NULL;\n\t\t}\n\t\textent_zeroed_set(extent, true);\n\t}\n\n\tif (extent_committed_get(extent)) {\n\t\t*commit = true;\n\t}\n\tif (extent_zeroed_get(extent)) {\n\t\t*zero = true;\n\t}\n\n\tif (pad != 0) {\n\t\textent_addr_randomize(tsdn, extent, alignment);\n\t}\n\tassert(extent_state_get(extent) == extent_state_active);\n\tif (slab) {\n\t\textent_slab_set(extent, slab);\n\t\textent_interior_register(tsdn, rtree_ctx, extent, szind);\n\t}\n\n\tif (*zero) {\n\t\tvoid *addr = extent_base_get(extent);\n\t\tsize_t size = extent_size_get(extent);\n\t\tif (!extent_zeroed_get(extent)) {\n\t\t\tif (pages_purge_forced(addr, size)) {\n\t\t\t\tmemset(addr, 0, size);\n\t\t\t}\n\t\t} else if (config_debug) {\n\t\t\tsize_t *p = (size_t *)(uintptr_t)addr;\n\t\t\tfor (size_t i = 0; i < size / sizeof(size_t); i++) {\n\t\t\t\tassert(p[i] == 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn extent;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * If the caller specifies (!*zero), it is still possible to receive zeroed\n * memory, in which case *zero is toggled to true.  arena_extent_alloc() takes\n * advantage of this to avoid demanding zeroed extents, but taking advantage of\n * them if they are returned.\n */\n", "func_signal": "static void *\nextent_alloc_core(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,\n    size_t alignment, bool *zero, bool *commit, dss_prec_t dss_prec)", "code": "{\n\tvoid *ret;\n\n\tassert(size != 0);\n\tassert(alignment != 0);\n\n\t/* \"primary\" dss. */\n\tif (have_dss && dss_prec == dss_prec_primary && (ret =\n\t    extent_alloc_dss(tsdn, arena, new_addr, size, alignment, zero,\n\t    commit)) != NULL) {\n\t\treturn ret;\n\t}\n\t/* mmap. */\n\tif ((ret = extent_alloc_mmap(new_addr, size, alignment, zero, commit))\n\t    != NULL) {\n\t\treturn ret;\n\t}\n\t/* \"secondary\" dss. */\n\tif (have_dss && dss_prec == dss_prec_secondary && (ret =\n\t    extent_alloc_dss(tsdn, arena, new_addr, size, alignment, zero,\n\t    commit)) != NULL) {\n\t\treturn ret;\n\t}\n\n\t/* All strategies for allocation failed. */\n\treturn NULL;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/* Check if we need to signal the background thread early. */\n", "func_signal": "void\nbackground_thread_interval_check(tsdn_t *tsdn, arena_t *arena,\n    arena_decay_t *decay, size_t npages_new)", "code": "{\n\tbackground_thread_info_t *info = arena_background_thread_info_get(\n\t    arena);\n\tif (malloc_mutex_trylock(tsdn, &info->mtx)) {\n\t\t/*\n\t\t * Background thread may hold the mutex for a long period of\n\t\t * time.  We'd like to avoid the variance on application\n\t\t * threads.  So keep this non-blocking, and leave the work to a\n\t\t * future epoch.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (info->state != background_thread_started) {\n\t\tgoto label_done;\n\t}\n\tif (malloc_mutex_trylock(tsdn, &decay->mtx)) {\n\t\tgoto label_done;\n\t}\n\n\tssize_t decay_time = atomic_load_zd(&decay->time_ms, ATOMIC_RELAXED);\n\tif (decay_time <= 0) {\n\t\t/* Purging is eagerly done or disabled currently. */\n\t\tgoto label_done_unlock2;\n\t}\n\tuint64_t decay_interval_ns = nstime_ns(&decay->interval);\n\tassert(decay_interval_ns > 0);\n\n\tnstime_t diff;\n\tnstime_init(&diff, background_thread_wakeup_time_get(info));\n\tif (nstime_compare(&diff, &decay->epoch) <= 0) {\n\t\tgoto label_done_unlock2;\n\t}\n\tnstime_subtract(&diff, &decay->epoch);\n\tif (nstime_ns(&diff) < BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\tgoto label_done_unlock2;\n\t}\n\n\tif (npages_new > 0) {\n\t\tsize_t n_epoch = (size_t)(nstime_ns(&diff) / decay_interval_ns);\n\t\t/*\n\t\t * Compute how many new pages we would need to purge by the next\n\t\t * wakeup, which is used to determine if we should signal the\n\t\t * background thread.\n\t\t */\n\t\tuint64_t npurge_new;\n\t\tif (n_epoch >= SMOOTHSTEP_NSTEPS) {\n\t\t\tnpurge_new = npages_new;\n\t\t} else {\n\t\t\tuint64_t h_steps_max = h_steps[SMOOTHSTEP_NSTEPS - 1];\n\t\t\tassert(h_steps_max >=\n\t\t\t    h_steps[SMOOTHSTEP_NSTEPS - 1 - n_epoch]);\n\t\t\tnpurge_new = npages_new * (h_steps_max -\n\t\t\t    h_steps[SMOOTHSTEP_NSTEPS - 1 - n_epoch]);\n\t\t\tnpurge_new >>= SMOOTHSTEP_BFP;\n\t\t}\n\t\tinfo->npages_to_purge_new += npurge_new;\n\t}\n\n\tbool should_signal;\n\tif (info->npages_to_purge_new > BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\tshould_signal = true;\n\t} else if (unlikely(background_thread_indefinite_sleep(info)) &&\n\t    (extents_npages_get(&arena->extents_dirty) > 0 ||\n\t    extents_npages_get(&arena->extents_muzzy) > 0 ||\n\t    info->npages_to_purge_new > 0)) {\n\t\tshould_signal = true;\n\t} else {\n\t\tshould_signal = false;\n\t}\n\n\tif (should_signal) {\n\t\tinfo->npages_to_purge_new = 0;\n\t\tpthread_cond_signal(&info->cond);\n\t}\nlabel_done_unlock2:\n\tmalloc_mutex_unlock(tsdn, &decay->mtx);\nlabel_done:\n\tmalloc_mutex_unlock(tsdn, &info->mtx);\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/background_thread.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Removes all pointers to the given extent from the global rtree indices for\n * its interior.  This is relevant for slab extents, for which we need to do\n * metadata lookups at places other than the head of the extent.  We deregister\n * on the interior, then, when an extent moves from being an active slab to an\n * inactive state.\n */\n", "func_signal": "static void\nextent_interior_deregister(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,\n    extent_t *extent)", "code": "{\n\tsize_t i;\n\n\tassert(extent_slab_get(extent));\n\n\tfor (i = 1; i < (extent_size_get(extent) >> LG_PAGE) - 1; i++) {\n\t\trtree_clear(tsdn, &extents_rtree, rtree_ctx,\n\t\t    (uintptr_t)extent_base_get(extent) + (uintptr_t)(i <<\n\t\t    LG_PAGE));\n\t}\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Forwards all writes to the passed-in buf_v (which should be cast from a\n * buf_descriptor_t *).\n */\n", "func_signal": "static void\nforwarding_cb(void *buf_descriptor_v, const char *str)", "code": "{\n\tbuf_descriptor_t *buf_descriptor = (buf_descriptor_t *)buf_descriptor_v;\n\n\tif (print_raw) {\n\t\tmalloc_printf(\"%s\", str);\n\t}\n\tif (print_escaped) {\n\t\tconst char *it = str;\n\t\twhile (*it != '\\0') {\n\t\t\tif (!buf_descriptor->mid_quote) {\n\t\t\t\tmalloc_printf(\"\\\"\");\n\t\t\t\tbuf_descriptor->mid_quote = true;\n\t\t\t}\n\t\t\tswitch (*it) {\n\t\t\tcase '\\\\':\n\t\t\t\tmalloc_printf(\"\\\\\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\"':\n\t\t\t\tmalloc_printf(\"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tmalloc_printf(\"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tmalloc_printf(\"\\\\n\\\"\\n\");\n\t\t\t\tbuf_descriptor->mid_quote = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmalloc_printf(\"%c\", *it);\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t}\n\n\tsize_t written = malloc_snprintf(buf_descriptor->buf,\n\t    buf_descriptor->len, \"%s\", str);\n\tassert_zu_eq(written, strlen(str), \"Buffer overflow!\");\n\tbuf_descriptor->buf += written;\n\tbuf_descriptor->len -= written;\n\tassert_zu_gt(buf_descriptor->len, 0, \"Buffer out of space!\");\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/test/unit/emitter.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * When lazy lock is enabled, we need to make sure setting isthreaded before\n * taking any background_thread locks.  This is called early in ctl (instead of\n * wait for the pthread_create calls to trigger) because the mutex is required\n * before creating background threads.\n */\n", "func_signal": "void\nbackground_thread_ctl_init(tsdn_t *tsdn)", "code": "{\n\tmalloc_mutex_assert_not_owner(tsdn, &background_thread_lock);\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\tpthread_create_fptr_init();\n\tpthread_create_wrapper_init();\n#endif\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/background_thread.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/* Create a new background thread if needed. */\n", "func_signal": "bool\nbackground_thread_create(tsd_t *tsd, unsigned arena_ind)", "code": "{\n\tassert(have_background_thread);\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\n\t/* We create at most NCPUs threads. */\n\tsize_t thread_ind = arena_ind % max_background_threads;\n\tbackground_thread_info_t *info = &background_thread_info[thread_ind];\n\n\tbool need_new_thread;\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\tneed_new_thread = background_thread_enabled() &&\n\t    (info->state == background_thread_stopped);\n\tif (need_new_thread) {\n\t\tbackground_thread_init(tsd, info);\n\t}\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\tif (!need_new_thread) {\n\t\treturn false;\n\t}\n\tif (arena_ind != 0) {\n\t\t/* Threads are created asynchronously by Thread 0. */\n\t\tbackground_thread_info_t *t0 = &background_thread_info[0];\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &t0->mtx);\n\t\tassert(t0->state == background_thread_started);\n\t\tpthread_cond_signal(&t0->cond);\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &t0->mtx);\n\n\t\treturn false;\n\t}\n\n\tpre_reentrancy(tsd, NULL);\n\t/*\n\t * To avoid complications (besides reentrancy), create internal\n\t * background threads with the underlying pthread_create.\n\t */\n\tint err = background_thread_create_signals_masked(&info->thread, NULL,\n\t    background_thread_entry, (void *)thread_ind);\n\tpost_reentrancy(tsd);\n\n\tif (err != 0) {\n\t\tmalloc_printf(\"<jemalloc>: arena 0 background thread creation \"\n\t\t    \"failed (%d)\\n\", err);\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\tinfo->state = background_thread_stopped;\n\t\tn_background_threads--;\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/background_thread.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Do first-fit extent selection, i.e. select the oldest/lowest extent that is\n * large enough.\n */\n", "func_signal": "static extent_t *\nextents_first_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,\n    size_t size)", "code": "{\n\textent_t *ret = NULL;\n\n\tpszind_t pind = sz_psz2ind(extent_size_quantize_ceil(size));\n\tfor (pszind_t i = (pszind_t)bitmap_ffu(extents->bitmap,\n\t    &extents_bitmap_info, (size_t)pind); i < NPSIZES+1; i =\n\t    (pszind_t)bitmap_ffu(extents->bitmap, &extents_bitmap_info,\n\t    (size_t)i+1)) {\n\t\tassert(!extent_heap_empty(&extents->heaps[i]));\n\t\textent_t *extent = extent_heap_first(&extents->heaps[i]);\n\t\tassert(extent_size_get(extent) >= size);\n\t\tif (ret == NULL || extent_snad_comp(extent, ret) < 0) {\n\t\t\tret = extent;\n\t\t}\n\t\tif (i == NPSIZES) {\n\t\t\tbreak;\n\t\t}\n\t\tassert(i < NPSIZES);\n\t}\n\n\treturn ret;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/* defined(JEMALLOC_BACKGROUND_THREAD) */\n", "func_signal": "bool\nbackground_thread_boot0(void)", "code": "{\n\tif (!have_background_thread && opt_background_thread) {\n\t\tmalloc_printf(\"<jemalloc>: option background_thread currently \"\n\t\t    \"supports pthread only\\n\");\n\t\treturn true;\n\t}\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\tif ((config_lazy_lock || opt_background_thread) &&\n\t    pthread_create_fptr_init()) {\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/background_thread.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/* Compute purge interval for background threads. */\n", "func_signal": "static uint64_t\narena_decay_compute_purge_interval(tsdn_t *tsdn, arena_t *arena)", "code": "{\n\tuint64_t i1, i2;\n\ti1 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_dirty,\n\t    &arena->extents_dirty);\n\tif (i1 == BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\treturn i1;\n\t}\n\ti2 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_muzzy,\n\t    &arena->extents_muzzy);\n\n\treturn i1 < i2 ? i1 : i2;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/background_thread.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Accepts the extent to split, and the characteristics of each side of the\n * split.  The 'a' parameters go with the 'lead' of the resulting pair of\n * extents (the lower addressed portion of the split), and the 'b' parameters go\n * with the trail (the higher addressed portion).  This makes 'extent' the lead,\n * and returns the trail (except in case of error).\n */\n", "func_signal": "static extent_t *\nextent_split_impl(tsdn_t *tsdn, arena_t *arena,\n    extent_hooks_t **r_extent_hooks, extent_t *extent, size_t size_a,\n    szind_t szind_a, bool slab_a, size_t size_b, szind_t szind_b, bool slab_b,\n    bool growing_retained)", "code": "{\n\tassert(extent_size_get(extent) == size_a + size_b);\n\twitness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),\n\t    WITNESS_RANK_CORE, growing_retained ? 1 : 0);\n\n\textent_hooks_assure_initialized(arena, r_extent_hooks);\n\n\tif ((*r_extent_hooks)->split == NULL) {\n\t\treturn NULL;\n\t}\n\n\textent_t *trail = extent_alloc(tsdn, arena);\n\tif (trail == NULL) {\n\t\tgoto label_error_a;\n\t}\n\n\textent_init(trail, arena, (void *)((uintptr_t)extent_base_get(extent) +\n\t    size_a), size_b, slab_b, szind_b, extent_sn_get(extent),\n\t    extent_state_get(extent), extent_zeroed_get(extent),\n\t    extent_committed_get(extent), extent_dumpable_get(extent));\n\n\trtree_ctx_t rtree_ctx_fallback;\n\trtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);\n\trtree_leaf_elm_t *lead_elm_a, *lead_elm_b;\n\t{\n\t\textent_t lead;\n\n\t\textent_init(&lead, arena, extent_addr_get(extent), size_a,\n\t\t    slab_a, szind_a, extent_sn_get(extent),\n\t\t    extent_state_get(extent), extent_zeroed_get(extent),\n\t\t    extent_committed_get(extent), extent_dumpable_get(extent));\n\n\t\textent_rtree_leaf_elms_lookup(tsdn, rtree_ctx, &lead, false,\n\t\t    true, &lead_elm_a, &lead_elm_b);\n\t}\n\trtree_leaf_elm_t *trail_elm_a, *trail_elm_b;\n\textent_rtree_leaf_elms_lookup(tsdn, rtree_ctx, trail, false, true,\n\t    &trail_elm_a, &trail_elm_b);\n\n\tif (lead_elm_a == NULL || lead_elm_b == NULL || trail_elm_a == NULL\n\t    || trail_elm_b == NULL) {\n\t\tgoto label_error_b;\n\t}\n\n\textent_lock2(tsdn, extent, trail);\n\n\tif (*r_extent_hooks != &extent_hooks_default) {\n\t\textent_hook_pre_reentrancy(tsdn, arena);\n\t}\n\tbool err = (*r_extent_hooks)->split(*r_extent_hooks, extent_base_get(extent),\n\t    size_a + size_b, size_a, size_b, extent_committed_get(extent),\n\t    arena_ind_get(arena));\n\tif (*r_extent_hooks != &extent_hooks_default) {\n\t\textent_hook_post_reentrancy(tsdn);\n\t}\n\tif (err) {\n\t\tgoto label_error_c;\n\t}\n\n\textent_size_set(extent, size_a);\n\textent_szind_set(extent, szind_a);\n\n\textent_rtree_write_acquired(tsdn, lead_elm_a, lead_elm_b, extent,\n\t    szind_a, slab_a);\n\textent_rtree_write_acquired(tsdn, trail_elm_a, trail_elm_b, trail,\n\t    szind_b, slab_b);\n\n\textent_unlock2(tsdn, extent, trail);\n\n\treturn trail;\nlabel_error_c:\n\textent_unlock2(tsdn, extent, trail);\nlabel_error_b:\n\textent_dalloc(tsdn, arena, trail);\nlabel_error_a:\n\treturn NULL;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * Does the metadata management portions of putting an unused extent into the\n * given extents_t (coalesces, deregisters slab interiors, the heap operations).\n */\n", "func_signal": "static void\nextent_record(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,\n    extents_t *extents, extent_t *extent, bool growing_retained)", "code": "{\n\trtree_ctx_t rtree_ctx_fallback;\n\trtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);\n\n\tassert((extents_state_get(extents) != extent_state_dirty &&\n\t    extents_state_get(extents) != extent_state_muzzy) ||\n\t    !extent_zeroed_get(extent));\n\n\tmalloc_mutex_lock(tsdn, &extents->mtx);\n\textent_hooks_assure_initialized(arena, r_extent_hooks);\n\n\textent_szind_set(extent, NSIZES);\n\tif (extent_slab_get(extent)) {\n\t\textent_interior_deregister(tsdn, rtree_ctx, extent);\n\t\textent_slab_set(extent, false);\n\t}\n\n\tassert(rtree_extent_read(tsdn, &extents_rtree, rtree_ctx,\n\t    (uintptr_t)extent_base_get(extent), true) == extent);\n\n\tif (!extents->delay_coalesce) {\n\t\textent = extent_try_coalesce(tsdn, arena, r_extent_hooks,\n\t\t    rtree_ctx, extents, extent, NULL, growing_retained);\n\t} else if (extent_size_get(extent) >= LARGE_MINCLASS) {\n\t\t/* Always coalesce large extents eagerly. */\n\t\tbool coalesced;\n\t\tsize_t prev_size;\n\t\tdo {\n\t\t\tprev_size = extent_size_get(extent);\n\t\t\tassert(extent_state_get(extent) == extent_state_active);\n\t\t\textent = extent_try_coalesce(tsdn, arena,\n\t\t\t    r_extent_hooks, rtree_ctx, extents, extent,\n\t\t\t    &coalesced, growing_retained);\n\t\t} while (coalesced &&\n\t\t    extent_size_get(extent) >= prev_size + LARGE_MINCLASS);\n\t}\n\textent_deactivate_locked(tsdn, arena, extents, extent);\n\n\tmalloc_mutex_unlock(tsdn, &extents->mtx);\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/* Do any-best-fit extent selection, i.e. select any extent that best fits. */\n", "func_signal": "static extent_t *\nextents_best_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,\n    size_t size)", "code": "{\n\tpszind_t pind = sz_psz2ind(extent_size_quantize_ceil(size));\n\tpszind_t i = (pszind_t)bitmap_ffu(extents->bitmap, &extents_bitmap_info,\n\t    (size_t)pind);\n\tif (i < NPSIZES+1) {\n\t\t/*\n\t\t * In order to reduce fragmentation, avoid reusing and splitting\n\t\t * large extents for much smaller sizes.\n\t\t */\n\t\tif ((sz_pind2sz(i) >> opt_lg_extent_max_active_fit) > size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tassert(!extent_heap_empty(&extents->heaps[i]));\n\t\textent_t *extent = extent_heap_first(&extents->heaps[i]);\n\t\tassert(extent_size_get(extent) >= size);\n\t\treturn extent;\n\t}\n\n\treturn NULL;\n}", "path": "bytehound/jemallocator/jemalloc-sys/jemalloc/src/extent.c", "commit_date": "2019-05-17 00:00:00", "repo_name": "koute/bytehound", "stars": 3822, "license": "other", "language": "c", "size": 16615}
{"docstring": "/*\n * PollForTasks calls poll() for the sockets of all tasks. It checks for\n * read or write events based on the pollingStatus of the task.\n */\n", "func_signal": "static void\nPollForTasks(List *taskList)", "code": "{\n\tTimestampTz currentTime = 0;\n\tTimestampTz nextEventTime = 0;\n\tint pollTimeout = 0;\n\tlong waitSeconds = 0;\n\tint waitMicros = 0;\n\tCronTask **polledTasks = NULL;\n\tstruct pollfd *pollFDs = NULL;\n\tint pollResult = 0;\n\n\tint taskIndex = 0;\n\tint taskCount = list_length(taskList);\n\tint activeTaskCount = 0;\n\tListCell *taskCell = NULL;\n\n\tpolledTasks = (CronTask **) palloc0(taskCount * sizeof(CronTask));\n\tpollFDs = (struct pollfd *) palloc0(taskCount * sizeof(struct pollfd));\n\n\tcurrentTime = GetCurrentTimestamp();\n\n\t/*\n\t * At the latest, wake up when the next minute starts.\n\t */\n\tnextEventTime = TimestampMinuteEnd(currentTime);\n\n\tforeach(taskCell, taskList)\n\t{\n\t\tCronTask *task = (CronTask *) lfirst(taskCell);\n\t\tPostgresPollingStatusType pollingStatus = task->pollingStatus;\n\t\tstruct pollfd *pollFileDescriptor = &pollFDs[activeTaskCount];\n\n\t\tif (activeTaskCount >= MaxRunningTasks)\n\t\t{\n\t\t\t/* already polling the maximum number of tasks */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (task->state == CRON_TASK_ERROR || task->state == CRON_TASK_DONE ||\n\t\t\tCanStartTask(task))\n\t\t{\n\t\t\t/* there is work to be done, don't wait */\n\t\t\tpfree(polledTasks);\n\t\t\tpfree(pollFDs);\n\t\t\treturn;\n\t\t}\n\n\t\tif (task->state == CRON_TASK_WAITING && task->pendingRunCount == 0)\n\t\t{\n\t\t\t/* don't poll idle tasks */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (task->state == CRON_TASK_CONNECTING ||\n\t\t\ttask->state == CRON_TASK_SENDING)\n\t\t{\n\t\t\t/*\n\t\t\t * We need to wake up when a timeout expires.\n\t\t\t * Take the minimum of nextEventTime and task->startDeadline.\n\t\t\t */\n\t\t\tif (TimestampDifferenceExceeds(task->startDeadline, nextEventTime, 0))\n\t\t\t{\n\t\t\t\tnextEventTime = task->startDeadline;\n\t\t\t}\n\t\t}\n\n\t\t/* we plan to poll this task */\n\t\tpollFileDescriptor = &pollFDs[activeTaskCount];\n\t\tpolledTasks[activeTaskCount] = task;\n\n\t\tif (task->state == CRON_TASK_CONNECTING ||\n\t\t\ttask->state == CRON_TASK_SENDING ||\n\t\t\ttask->state == CRON_TASK_BGW_RUNNING ||\n\t\t\ttask->state == CRON_TASK_RUNNING)\n\t\t{\n\t\t\tPGconn *connection = task->connection;\n\t\t\tint pollEventMask = 0;\n\n\t\t\t/*\n\t\t\t * Set the appropriate mask for poll, based on the current polling\n\t\t\t * status of the task, controlled by ManageCronTask.\n\t\t\t */\n\n\t\t\tif (pollingStatus == PGRES_POLLING_READING)\n\t\t\t{\n\t\t\t\tpollEventMask = POLLERR | POLLIN;\n\t\t\t}\n\t\t\telse if (pollingStatus == PGRES_POLLING_WRITING)\n\t\t\t{\n\t\t\t\tpollEventMask = POLLERR | POLLOUT;\n\t\t\t}\n\n\t\t\tpollFileDescriptor->fd = PQsocket(connection);\n\t\t\tpollFileDescriptor->events = pollEventMask;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Task is not running.\n\t\t\t */\n\n\t\t\tpollFileDescriptor->fd = -1;\n\t\t\tpollFileDescriptor->events = 0;\n\t\t}\n\n\t\tpollFileDescriptor->revents = 0;\n\n\t\tactiveTaskCount++;\n\t}\n\n\t/*\n\t * Find the first time-based event, which is either the start of a new\n\t * minute or a timeout.\n\t */\n\tTimestampDifference(currentTime, nextEventTime, &waitSeconds, &waitMicros);\n\n\tpollTimeout = waitSeconds * 1000 + waitMicros / 1000;\n\tif (pollTimeout <= 0)\n\t{\n\t\tpfree(polledTasks);\n\t\tpfree(pollFDs);\n\t\treturn;\n\t}\n\telse if (pollTimeout > MaxWait)\n\t{\n\t\t/*\n\t\t * We never wait more than 1 second, this gives us a chance to react\n\t\t * to external events like a TERM signal and job changes.\n\t\t */\n\n\t\tpollTimeout = MaxWait;\n\t}\n\n\tif (activeTaskCount == 0)\n\t{\n\t\t/* turns out there's nothing to do, just wait for something to happen */\n\t\tWaitForLatch(pollTimeout);\n\n\t\tpfree(polledTasks);\n\t\tpfree(pollFDs);\n\t\treturn;\n\t}\n\n\tpollResult = poll(pollFDs, activeTaskCount, pollTimeout);\n\tif (pollResult < 0)\n\t{\n\t\t/*\n\t\t * This typically happens in case of a signal, though we should\n\t\t * probably check errno in case something bad happened.\n\t\t */\n\n\t\tpfree(polledTasks);\n\t\tpfree(pollFDs);\n\t\treturn;\n\t}\n\n\tfor (taskIndex = 0; taskIndex < activeTaskCount; taskIndex++)\n\t{\n\t\tCronTask *task = polledTasks[taskIndex];\n\t\tstruct pollfd *pollFileDescriptor = &pollFDs[taskIndex];\n\n\t\ttask->isSocketReady = pollFileDescriptor->revents &\n\t\t\t\t\t\t\t  pollFileDescriptor->events;\n\t}\n\n\tpfree(polledTasks);\n\tpfree(pollFDs);\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * TimestampMinuteEnd returns the timestamp at the start of the\n * current minute for the given time.\n */\n", "func_signal": "static TimestampTz\nTimestampMinuteStart(TimestampTz time)", "code": "{\n\tTimestampTz result = 0;\n\n#ifdef HAVE_INT64_TIMESTAMP\n\tresult = time - time % 60000000;\n#else\n\tresult = (long) time - (long) time % 60;\n#endif\n\n\treturn result;\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * Execute given SQL string without SPI or a libpq session.\n */\n", "func_signal": "static void\nExecuteSqlString(const char *sql)", "code": "{\n\tList *raw_parsetree_list;\n\tListCell *lc1;\n\tbool isTopLevel;\n\tint commands_remaining;\n\tMemoryContext parsecontext;\n\tMemoryContext oldcontext;\n\n\t/*\n\t * Parse the SQL string into a list of raw parse trees.\n\t *\n\t * Because we allow statements that perform internal transaction control,\n\t * we can't do this in TopTransactionContext; the parse trees might get\n\t * blown away before we're done executing them.\n\t */\n\tparsecontext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t \"pg_cron parse/plan\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_MINSIZE,\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_INITSIZE,\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_MAXSIZE);\n\toldcontext = MemoryContextSwitchTo(parsecontext);\n\traw_parsetree_list = pg_parse_query(sql);\n\tcommands_remaining = list_length(raw_parsetree_list);\n\tisTopLevel = commands_remaining == 1;\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * Do parse analysis, rule rewrite, planning, and execution for each raw\n\t * parsetree.  We must fully execute each query before beginning parse\n\t * analysis on the next one, since there may be interdependencies.\n\t */\n\tforeach(lc1, raw_parsetree_list)\n\t{\n\t\t#if PG_VERSION_NUM < 100000\n\t\t\tNode *parsetree = (Node *) lfirst(lc1);\n\t\t#else\n\t\t\tRawStmt *parsetree = (RawStmt *)  lfirst(lc1);\n\t\t#endif\n\n\t\t#if PG_VERSION_NUM < 130000\n\t\t\tconst char *commandTag;\n\t\t\tchar completionTag[COMPLETION_TAG_BUFSIZE];\n\t\t#else\n\t\t\tCommandTag commandTag;\n\t\t\tQueryCompletion qc;\n\t\t#endif\n\n\t\tList *querytree_list;\n\t\tList *plantree_list;\n\t\tbool snapshot_set = false;\n\t\tPortal portal;\n\t\tDestReceiver *receiver;\n\t\tint16 format = 1;\n\n\t\t/*\n\t\t * We don't allow transaction-control commands like COMMIT and ABORT\n\t\t * here.  The entire SQL statement is executed as a single transaction\n\t\t * which commits if no errors are encountered.\n\t\t */\n\t\tif (IsA(parsetree, TransactionStmt))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"transaction control statements are not allowed in pg_cron\")));\n\n\t\t/*\n\t\t * Get the command name for use in status display (it also becomes the\n\t\t * default completion tag, down inside PortalRun).  Set ps_status and\n\t\t * do any special start-of-SQL-command processing needed by the\n\t\t * destination.\n\t\t */\n\t\t#if PG_VERSION_NUM < 100000\n\t\t\tcommandTag = CreateCommandTag(parsetree);\n\t\t#else\n\t\t\tcommandTag = CreateCommandTag(parsetree->stmt);\n\t\t#endif\n\n\n\t\t#if PG_VERSION_NUM < 130000\n\t\t\tset_ps_display(commandTag, false);\n\t\t#else\n\t\t\tset_ps_display(GetCommandTagName(commandTag));\n\t\t#endif\n\n\t\tBeginCommand(commandTag, DestNone);\n\n\t\t/* Set up a snapshot if parse analysis/planning will need one. */\n\t\tif (analyze_requires_snapshot(parsetree))\n\t\t{\n\t\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\t\tsnapshot_set = true;\n\t\t}\n\n\t\t/*\n\t\t * OK to analyze, rewrite, and plan this query.\n\t\t *\n\t\t * As with parsing, we need to make sure this data outlives the\n\t\t * transaction, because of the possibility that the statement might\n\t\t * perform internal transaction control.\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(parsecontext);\n\t\t#if PG_VERSION_NUM >= 100000\n\t\t\tquerytree_list = pg_analyze_and_rewrite(parsetree, sql, NULL, 0,NULL);\n\t\t#else\n\t\t\tquerytree_list = pg_analyze_and_rewrite(parsetree, sql, NULL, 0);\n\t\t#endif\n\n\t\t#if PG_VERSION_NUM < 130000\n\t\t\tplantree_list = pg_plan_queries(querytree_list, 0, NULL);\n\t\t#else\n\t\t\tplantree_list = pg_plan_queries(querytree_list, sql, 0, NULL);\n\t\t#endif\n\n\t\t/* Done with the snapshot used for parsing/planning */\n\t\tif (snapshot_set)\n\t\t\tPopActiveSnapshot();\n\n\t\t/* If we got a cancel signal in analysis or planning, quit */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t/*\n\t\t * Execute the query using the unnamed portal.\n\t\t */\n\t\tportal = CreatePortal(\"\", true, true);\n\t\t/* Don't display the portal in pg_cursors */\n\t\tportal->visible = false;\n\t\tPortalDefineQuery(portal, NULL, sql, commandTag, plantree_list, NULL);\n\t\tPortalStart(portal, NULL, 0, InvalidSnapshot);\n\t\tPortalSetResultFormat(portal, 1, &format);\t\t/* binary format */\n\n\t\t--commands_remaining;\n\t\treceiver = CreateDestReceiver(DestNone);\n\n\t\t/*\n\t\t * Only once the portal and destreceiver have been established can\n\t\t * we return to the transaction context.  All that stuff needs to\n\t\t * survive an internal commit inside PortalRun!\n\t\t */\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t/* Here's where we actually execute the command. */\n\t\t#if PG_VERSION_NUM < 100000\n\t\t\t(void) PortalRun(portal, FETCH_ALL, isTopLevel, receiver, receiver, completionTag);\n\t\t#elif PG_VERSION_NUM < 130000\n\t\t\t(void) PortalRun(portal, FETCH_ALL, isTopLevel,true, receiver, receiver, completionTag);\n\t\t#else\n\t\t\t(void) PortalRun(portal, FETCH_ALL, isTopLevel, true, receiver, receiver, &qc);\n\t\t#endif\n\n\t\t/* Clean up the receiver. */\n\t\t(*receiver->rDestroy) (receiver);\n\n\t\t/*\n\t\t * Send a CommandComplete message even if we suppressed the query\n\t\t * results.  The user backend will report these in the absence of\n\t\t * any true query results.\n\t\t */\n\t\t#if PG_VERSION_NUM < 130000\n\t\t\tEndCommand(completionTag, DestRemote);\n\t\t#else\n\t\t\tEndCommand(&qc, DestRemote, false);\n\t\t#endif\n\n\t\t/* Clean up the portal. */\n\t\tPortalDrop(portal, false);\n\t}\n\n\t/* Be sure to advance the command counter after the last script command */\n\tCommandCounterIncrement();\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * WaitForLatch waits for the given number of milliseconds unless a signal\n * is received or postmaster shuts down.\n */\n", "func_signal": "static void\nWaitForLatch(int timeoutMs)", "code": "{\n\tint rc = 0;\n\tint waitFlags = WL_LATCH_SET | WL_POSTMASTER_DEATH | WL_TIMEOUT;\n\n\t/* nothing to do, wait for new jobs */\n#if (PG_VERSION_NUM >= 100000)\n\trc = WaitLatch(MyLatch, waitFlags, timeoutMs, PG_WAIT_EXTENSION);\n#else\n\trc = WaitLatch(MyLatch, waitFlags, timeoutMs);\n#endif\n\n\tResetLatch(MyLatch);\n\n\tif (rc & WL_POSTMASTER_DEATH)\n\t{\n\t\t/* postmaster died and we should bail out immediately */\n\t\tproc_exit(1);\n\t}\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * ShouldRunTask returns whether a job should run in the current\n * minute according to its schedule.\n */\n", "func_signal": "static bool\nShouldRunTask(entry *schedule, TimestampTz currentTime, bool doWild,\n\t\t\t  bool doNonWild)", "code": "{\n\ttime_t currentTime_t = timestamptz_to_time_t(currentTime);\n\tstruct tm *tm = gmtime(&currentTime_t);\n\n\tint minute = tm->tm_min -FIRST_MINUTE;\n\tint hour = tm->tm_hour -FIRST_HOUR;\n\tint dayOfMonth = tm->tm_mday -FIRST_DOM;\n\tint month = tm->tm_mon +1 -FIRST_MONTH;\n\tint dayOfWeek = tm->tm_wday -FIRST_DOW;\n\n\tif (bit_test(schedule->minute, minute) &&\n\t    bit_test(schedule->hour, hour) &&\n\t    bit_test(schedule->month, month) &&\n\t    ( ((schedule->flags & DOM_STAR) || (schedule->flags & DOW_STAR))\n\t      ? (bit_test(schedule->dow,dayOfWeek) && bit_test(schedule->dom,dayOfMonth))\n\t      : (bit_test(schedule->dow,dayOfWeek) || bit_test(schedule->dom,dayOfMonth)))) {\n\t\tif ((doNonWild && !(schedule->flags & (MIN_STAR|HR_STAR)))\n\t\t    || (doWild && (schedule->flags & (MIN_STAR|HR_STAR))))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * pg_cron_cmdTuples -\n *      mainly copy/pasted from PQcmdTuples\n *      If the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return\n *      a string containing the number of inserted/affected tuples. If not,\n *      return \"\".\n *\n *      XXX: this should probably return an int\n */\n", "func_signal": "static char *\npg_cron_cmdTuples(char *msg)", "code": "{\n        char       *p,\n                           *c;\n\n        if (!msg)\n                return \"\";\n\n        if (strncmp(msg, \"INSERT \", 7) == 0)\n        {\n                p = msg + 7;\n                /* INSERT: skip oid and space */\n                while (*p && *p != ' ')\n                        p++;\n                if (*p == 0)\n                        goto interpret_error;   /* no space? */\n                p++;\n        }\n        else if (strncmp(msg, \"SELECT \", 7) == 0 ||\n                         strncmp(msg, \"DELETE \", 7) == 0 ||\n                         strncmp(msg, \"UPDATE \", 7) == 0)\n                p = msg + 7;\n        else if (strncmp(msg, \"FETCH \", 6) == 0)\n                p = msg + 6;\n        else if (strncmp(msg, \"MOVE \", 5) == 0 ||\n                         strncmp(msg, \"COPY \", 5) == 0)\n                p = msg + 5;\n        else\n                return \"\";\n\n        /* check that we have an integer (at least one digit, nothing else) */\n        for (c = p; *c; c++)\n        {\n                if (!isdigit((unsigned char) *c))\n                        goto interpret_error;\n        }\n        if (c == p)\n                goto interpret_error;\n\n        return p;\n\ninterpret_error:\n\tereport(LOG, (errmsg(\"could not interpret result from server: %s\", msg)));\n        return \"\";\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * Signal handler for SIGTERM\n *\t\tSet a flag to let the main loop to terminate, and set our latch to wake\n *\t\tit up.\n */\n", "func_signal": "static void\npg_cron_sigterm(SIGNAL_ARGS)", "code": "{\n\tgot_sigterm = true;\n\n\tif (MyProc != NULL)\n\t{\n\t\tSetLatch(&MyProc->procLatch);\n\t}\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * CanStartTask determines whether a task is ready to be started because\n * it has pending runs and we are running less than MaxRunningTasks.\n */\n", "func_signal": "static bool\nCanStartTask(CronTask *task)", "code": "{\n\treturn task->state == CRON_TASK_WAITING && task->pendingRunCount > 0 &&\n\t\t   RunningTaskCount < MaxRunningTasks;\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * WaitForCronTasks blocks waiting for any active task for at most\n * 1 second.\n */\n", "func_signal": "static void\nWaitForCronTasks(List *taskList)", "code": "{\n\tint taskCount = list_length(taskList);\n\n\tif (taskCount > 0)\n\t{\n\t\tPollForTasks(taskList);\n\t}\n\telse\n\t{\n\t\tWaitForLatch(MaxWait);\n\t}\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * Signal handler for SIGTERM for background workers\n * \t\tWhen we receive a SIGTERM, we set InterruptPending and ProcDiePending\n * \t\tjust like a normal backend.  The next CHECK_FOR_INTERRUPTS() will do the\n * \t\tright thing.\n */\n", "func_signal": "static void\npg_cron_background_worker_sigterm(SIGNAL_ARGS)", "code": "{\n\tint save_errno = errno;\n\n\tif (MyProc)\n\t\tSetLatch(&MyProc->procLatch);\n\n\tif (!proc_exit_inprogress)\n\t{\n\t\tInterruptPending = true;\n\t\tProcDiePending = true;\n\t}\n\n\terrno = save_errno;\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * TimestampMinuteEnd returns the timestamp at the start of the\n * next minute from the given time.\n */\n", "func_signal": "static TimestampTz\nTimestampMinuteEnd(TimestampTz time)", "code": "{\n\tTimestampTz result = TimestampMinuteStart(time);\n\n#ifdef HAVE_INT64_TIMESTAMP\n\tresult += 60000000;\n#else\n\tresult += 60;\n#endif\n\n\treturn result;\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * If a task has hit it's startup deadline, set an appropriate error state on\n * the task and return true. Note that this should only be called after a task\n * has already been launched.\n */\n", "func_signal": "static bool\njobStartupTimeout(CronTask *task, TimestampTz currentTime)", "code": "{\n    Assert(task->state == CRON_TASK_CONNECTING || \\\n            task->state == CRON_TASK_SENDING || \\\n            task->state == CRON_TASK_BGW_START);\n\n    if (TimestampDifferenceExceeds(task->startDeadline, currentTime, 0))\n    {\n        task->errorMessage = \"job startup timeout\";\n        task->pollingStatus = 0;\n        task->state = CRON_TASK_ERROR;\n        return true;\n    }\n    else\n        return false;\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * PgCronLauncherMain is the main entry-point for the background worker\n * that performs tasks.\n */\n", "func_signal": "void\nPgCronLauncherMain(Datum arg)", "code": "{\n\tMemoryContext CronLoopContext = NULL;\n\tstruct rlimit limit;\n\n\t/* Establish signal handlers before unblocking signals. */\n\tpqsignal(SIGHUP, pg_cron_sighup);\n\tpqsignal(SIGINT, SIG_IGN);\n\tpqsignal(SIGTERM, pg_cron_sigterm);\n\n\t/* We're now ready to receive signals */\n\tBackgroundWorkerUnblockSignals();\n\n\t/* Connect to our database */\n#if (PG_VERSION_NUM < 110000)\n\tBackgroundWorkerInitializeConnection(CronTableDatabaseName, NULL);\n#else\n\tBackgroundWorkerInitializeConnection(CronTableDatabaseName, NULL, 0);\n#endif\n\n\t/* Make pg_cron recognisable in pg_stat_activity */\n\tpgstat_report_appname(\"pg_cron scheduler\");\n\n\t/*\n\t * Mark anything that was in progress before the database restarted as\n\t * failed.\n\t */\n\tMarkPendingRunsAsFailed();\n\n\t/* Determine how many tasks we can run concurrently */\n\tif (MaxConnections < MaxRunningTasks)\n\t{\n\t\tMaxRunningTasks = MaxConnections;\n\t}\n\n\tif (max_files_per_process < MaxRunningTasks)\n\t{\n\t\tMaxRunningTasks = max_files_per_process;\n\t}\n\n\tif (getrlimit(RLIMIT_NOFILE, &limit) != 0 &&\n\t\tlimit.rlim_cur < (uint32) MaxRunningTasks)\n\t{\n\t\tMaxRunningTasks = limit.rlim_cur;\n\t}\n\n\tif (UseBackgroundWorkers && max_worker_processes - 1 < MaxRunningTasks)\n\t{\n\t\tMaxRunningTasks = max_worker_processes - 1;\n\t}\n\n\tif (MaxRunningTasks <= 0)\n\t{\n\t\tMaxRunningTasks = 1;\n\t}\n\n\n\tCronLoopContext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"pg_cron loop context\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_MINSIZE,\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_INITSIZE,\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_MAXSIZE);\n\tInitializeJobMetadataCache();\n\tInitializeTaskStateHash();\n\n\tereport(LOG, (errmsg(\"pg_cron scheduler started\")));\n\n\tMemoryContextSwitchTo(CronLoopContext);\n\n\twhile (!got_sigterm)\n\t{\n\t\tList *taskList = NIL;\n\t\tTimestampTz currentTime = 0;\n\n\t\tAcceptInvalidationMessages();\n\n\t\tif (!CronJobCacheValid)\n\t\t{\n\t\t\tRefreshTaskHash();\n\t\t}\n\n\t\ttaskList = CurrentTaskList();\n\t\tcurrentTime = GetCurrentTimestamp();\n\n\t\tStartAllPendingRuns(taskList, currentTime);\n\n\t\tWaitForCronTasks(taskList);\n\t\tManageCronTasks(taskList, currentTime);\n\n\t\tMemoryContextReset(CronLoopContext);\n\t}\n\n\tereport(LOG, (errmsg(\"pg_cron scheduler shutting down\")));\n\n\tproc_exit(0);\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * MinutesPassed returns the number of minutes between startTime and\n * stopTime rounded down to the closest integer.\n */\n", "func_signal": "static int\nMinutesPassed(TimestampTz startTime, TimestampTz stopTime)", "code": "{\n\tint microsPassed = 0;\n\tlong secondsPassed = 0;\n\tint minutesPassed = 0;\n\n\tTimestampDifference(startTime, stopTime,\n\t\t\t\t\t\t&secondsPassed, &microsPassed);\n\n\tminutesPassed = secondsPassed / 60;\n\n\treturn minutesPassed;\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * ManageCronTasks proceeds the state machines of the given list of tasks.\n */\n", "func_signal": "static void\nManageCronTasks(List *taskList, TimestampTz currentTime)", "code": "{\n\tListCell *taskCell = NULL;\n\n\tforeach(taskCell, taskList)\n\t{\n\t\tCronTask *task = (CronTask *) lfirst(taskCell);\n\n\t\tManageCronTask(task, currentTime);\n\t}\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * ManageCronTask implements the cron task state machine.\n */\n", "func_signal": "static void\nManageCronTask(CronTask *task, TimestampTz currentTime)", "code": "{\n\tCronTaskState checkState = task->state;\n\tint64 jobId = task->jobId;\n\tCronJob *cronJob = GetCronJob(jobId);\n\tPGconn *connection = task->connection;\n\tConnStatusType connectionStatus = CONNECTION_BAD;\n\tTimestampTz start_time;\n\n\tswitch (checkState)\n\t{\n\t\tcase CRON_TASK_WAITING:\n\t\t{\n\t\t\t/* check if job has been removed */\n\t\t\tif (!task->isActive)\n\t\t\t{\n\t\t\t\t/* remove task as well */\n\t\t\t\tRemoveTask(jobId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!CanStartTask(task))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttask->pendingRunCount -= 1;\n\t\t\tif (UseBackgroundWorkers)\n\t\t\t\ttask->state = CRON_TASK_BGW_START;\n\t\t\telse\n\t\t\t\ttask->state = CRON_TASK_START;\n\n\t\t\tRunningTaskCount++;\n\n\t\t\t/* Add new entry to audit table. */\n\t\t\ttask->runId = NextRunId();\n\t\t\tif (CronLogRun)\n\t\t\t\tInsertJobRunDetail(task->runId, &cronJob->jobId,\n\t\t\t\t\t\t\t\t\t\tcronJob->database,\n\t\t\t\t\t\t\t\t\t\tcronJob->userName,\n\t\t\t\t\t\t\t\t\t\tcronJob->command, GetCronStatus(CRON_STATUS_STARTING));\n\t\t}\n\n\t\tcase CRON_TASK_START:\n\t\t{\n\t\t\t/* as there is no break at the end of the previous case\n\t\t\t * to not add an extra second, then do another check here\n\t\t\t */\n\t\t\tif (!UseBackgroundWorkers)\n\t\t\t{\n\t\t\t\tconst char *clientEncoding = GetDatabaseEncodingName();\n\t\t\t\tchar nodePortString[12];\n\t\t\t\tTimestampTz startDeadline = 0;\n\n\t\t\t\tconst char *keywordArray[] = {\n\t\t\t\t\t\"host\",\n\t\t\t\t\t\"port\",\n\t\t\t\t\t\"fallback_application_name\",\n\t\t\t\t\t\"client_encoding\",\n\t\t\t\t\t\"dbname\",\n\t\t\t\t\t\"user\",\n\t\t\t\t\tNULL\n\t\t\t\t\t};\n\t\t\t\tconst char *valueArray[] = {\n\t\t\t\t\tcronJob->nodeName,\n\t\t\t\t\tnodePortString,\n\t\t\t\t\t\"pg_cron\",\n\t\t\t\t\tclientEncoding,\n\t\t\t\t\tcronJob->database,\n\t\t\t\t\tcronJob->userName,\n\t\t\t\t\tNULL\n\t\t\t\t};\n\t\t\t\tsprintf(nodePortString, \"%d\", cronJob->nodePort);\n\n\t\t\t\tAssert(sizeof(keywordArray) == sizeof(valueArray));\n\n\t\t\t\tif (CronLogStatement)\n\t\t\t\t{\n\t\t\t\t\tchar *command = cronJob->command;\n\n\t\t\t\t\tereport(LOG, (errmsg(\"cron job \" INT64_FORMAT \" %s: %s\",\n\t\t\t\t\t\t\t\t\t jobId, GetCronStatus(CRON_STATUS_STARTING), command)));\n\t\t\t\t}\n\n\t\t\t\tconnection = PQconnectStartParams(keywordArray, valueArray, false);\n\t\t\t\tPQsetnonblocking(connection, 1);\n\n\t\t\t\tconnectionStatus = PQstatus(connection);\n\t\t\t\tif (connectionStatus == CONNECTION_BAD)\n\t\t\t\t{\n\t\t\t\t\t/* make sure we call PQfinish on the connection */\n\t\t\t\t\ttask->connection = connection;\n\n\t\t\t\t\ttask->errorMessage = \"connection failed\";\n\t\t\t\t\ttask->pollingStatus = 0;\n\t\t\t\t\ttask->state = CRON_TASK_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tstartDeadline = TimestampTzPlusMilliseconds(currentTime,\n\t\t\t\t\t\t\t\t\t\t\tCronTaskStartTimeout);\n\n\t\t\t\ttask->startDeadline = startDeadline;\n\t\t\t\ttask->connection = connection;\n\t\t\t\ttask->pollingStatus = PGRES_POLLING_WRITING;\n\t\t\t\ttask->state = CRON_TASK_CONNECTING;\n\n\t\t\t\tif (CronLogRun)\n\t\t\t\t\tUpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_CONNECTING), NULL, NULL, NULL);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcase CRON_TASK_BGW_START:\n\t\t{\n\n\t\t\tBackgroundWorker worker;\n\t\t\tpid_t pid;\n\t\t\tshm_toc_estimator e;\n\t\t\tshm_toc *toc;\n\t\t\tchar *database;\n\t\t\tchar *username;\n\t\t\tchar *command;\n\t\t\tMemoryContext oldcontext;\n\t\t\tshm_mq *mq;\n\t\t\tSize segsize;\n\t\t\tBackgroundWorkerHandle *handle;\n\t\t\tBgwHandleStatus status;\n\t\t\tbool registered;\n\t\t\tTimestampTz startDeadline = 0;\n\n\t\t\t/* break in the previous case has not been reached\n\t\t\t * checking just for extra precaution\n\t\t\t */\n\t\t\tAssert(UseBackgroundWorkers);\n\t\t\t#if PG_VERSION_NUM < 100000\n\t\t\t\tAssert(CurrentResourceOwner == NULL);\n\t\t\t\tCurrentResourceOwner = ResourceOwnerCreate(NULL, \"pg_cron_worker\");\n\t\t\t#endif\n\n\t\t\t#define QUEUE_SIZE ((Size) 65536)\n\n\t\t\t/*\n\t\t\t * Create the shared memory that we will pass to the background\n\t\t\t * worker process.  We use DSM_CREATE_NULL_IF_MAXSEGMENTS so that we\n\t\t\t * do not ERROR here.  This way, we can mark the job as failed and\n\t\t\t * keep the launcher process running normally.\n\t\t\t */\n\t\t\tshm_toc_initialize_estimator(&e);\n\t\t\tshm_toc_estimate_chunk(&e, strlen(cronJob->database) + 1);\n\t\t\tshm_toc_estimate_chunk(&e, strlen(cronJob->userName) + 1);\n\t\t\tshm_toc_estimate_chunk(&e, strlen(cronJob->command) + 1);\n\t\t\tshm_toc_estimate_chunk(&e, QUEUE_SIZE);\n\t\t\tshm_toc_estimate_keys(&e, PG_CRON_NKEYS);\n\t\t\tsegsize = shm_toc_estimate(&e);\n\n\t\t\ttask->seg = dsm_create(segsize, DSM_CREATE_NULL_IF_MAXSEGMENTS);\n\t\t\tif (task->seg == NULL)\n\t\t\t{\n\t\t\t\ttask->state = CRON_TASK_ERROR;\n\t\t\t\ttask->errorMessage = \"unable to create a DSM segment; more \"\n\t\t\t\t\t\t\t\t\"details may be available in the server log\";\n\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t(errmsg(\"max number of DSM segments may has been reached\")));\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttoc = shm_toc_create(PG_CRON_MAGIC, dsm_segment_address(task->seg), segsize);\n\n\t\t\tdatabase = shm_toc_allocate(toc, strlen(cronJob->database) + 1);\n\t\t\tstrcpy(database, cronJob->database);\n\t\t\tshm_toc_insert(toc, PG_CRON_KEY_DATABASE, database);\n\n\t\t\tusername = shm_toc_allocate(toc, strlen(cronJob->userName) + 1);\n\t\t\tstrcpy(username, cronJob->userName);\n\t\t\tshm_toc_insert(toc, PG_CRON_KEY_USERNAME, username);\n\n\t\t\tcommand = shm_toc_allocate(toc, strlen(cronJob->command) + 1);\n\t\t\tstrcpy(command, cronJob->command);\n\t\t\tshm_toc_insert(toc, PG_CRON_KEY_COMMAND, command);\n\n\t\t\tmq = shm_mq_create(shm_toc_allocate(toc, QUEUE_SIZE), QUEUE_SIZE);\n\t\t\tshm_toc_insert(toc, PG_CRON_KEY_QUEUE, mq);\n\t\t\tshm_mq_set_receiver(mq, MyProc);\n\n\t\t\t/*\n\t\t\t * Attach the queue before launching a worker, so that we'll automatically\n\t\t\t * detach the queue if we error out.  (Otherwise, the worker might sit\n\t\t\t * there trying to write the queue long after we've gone away.)\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\t\t\tshm_mq_attach(mq, task->seg, NULL);\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t\t/*\n\t\t\t * Prepare the background worker.\n\t\t\t *\n\t\t\t */\n\t\t\tmemset(&worker, 0, sizeof(BackgroundWorker));\n\t\t\tworker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;\n\t\t\tworker.bgw_start_time = BgWorkerStart_ConsistentState;\n\t\t\tworker.bgw_restart_time = BGW_NEVER_RESTART;\n\t\t\tsprintf(worker.bgw_library_name, \"pg_cron\");\n\t\t\tsprintf(worker.bgw_function_name, \"CronBackgroundWorker\");\n#if (PG_VERSION_NUM >= 110000)\n\t\t\tsnprintf(worker.bgw_type, BGW_MAXLEN, \"pg_cron\");\n#endif\n\t\t\tsnprintf(worker.bgw_name, BGW_MAXLEN, \"pg_cron worker\");\n\t\t\tworker.bgw_main_arg = UInt32GetDatum(dsm_segment_handle(task->seg));\n\t\t\tworker.bgw_notify_pid = MyProcPid;\n\n\t\t\t/*\n\t\t\t * Start the worker process.\n\t\t\t */\n\t\t\tif (CronLogStatement)\n\t\t\t{\n\t\t\t\tereport(LOG, (errmsg(\"cron job \" INT64_FORMAT \" %s: %s\",\n\t\t\t\t\t\t\t\t\t\t jobId, GetCronStatus(CRON_STATUS_STARTING), command)));\n\t\t\t}\n\n\t\t\t/* If no no background worker slots are currently available\n\t\t\t * let's try until we reach jobStartupTimeout\n\t\t\t */\n\t\t\tstartDeadline = TimestampTzPlusMilliseconds(currentTime,\n\t\t\t\t\t\t\t\t\t\tCronTaskStartTimeout);\n\t\t\ttask->startDeadline = startDeadline;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tregistered = RegisterDynamicBackgroundWorker(&worker, &handle);\n\t\t\t}\n\t\t\twhile (!registered && !jobStartupTimeout(task, GetCurrentTimestamp()));\n\n\t\t\tif (!registered)\n\t\t\t{\n\t\t\t\tdsm_detach(task->seg);\n\t\t\t\ttask->seg = NULL;\n\t\t\t\ttask->state = CRON_TASK_ERROR;\n\t\t\t\ttask->errorMessage = \"could not start background process; more \"\n\t\t\t\t\t\t\t\t\t \"details may be available in the server log\";\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t\terrmsg(\"out of background worker slots\"),\n\t\t\t\t\terrhint(\"You might need to increase max_worker_processes.\")));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttask->startDeadline = 0;\n\t\t\ttask->handle = *handle;\n\t\t\tstatus = WaitForBackgroundWorkerStartup(&task->handle, &pid);\n\t\t\tif (status != BGWH_STARTED && status != BGWH_STOPPED)\n\t\t\t{\n\t\t\t\tdsm_detach(task->seg);\n\t\t\t\ttask->seg = NULL;\n\t\t\t\ttask->state = CRON_TASK_ERROR;\n\t\t\t\ttask->errorMessage = \"could not start background process; more \"\n\t\t\t\t\t\t\t\t\t \"details may be available in the server log\";\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstart_time = GetCurrentTimestamp();\n\n\t\t\tif (CronLogRun)\n\t\t\t\tUpdateJobRunDetail(task->runId, &pid, GetCronStatus(CRON_STATUS_RUNNING), NULL, &start_time, NULL);\n\n\t\t\ttask->state = CRON_TASK_BGW_RUNNING;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CRON_TASK_CONNECTING:\n\t\t{\n\t\t\tPostgresPollingStatusType pollingStatus = 0;\n\n\t\t\tAssert(!UseBackgroundWorkers);\n\n\t\t\t/* check if job has been removed */\n\t\t\tif (jobCanceled(task))\n\t\t\t\tbreak;\n\n\t\t\t/* check if timeout has been reached */\n\t\t\tif (jobStartupTimeout(task, currentTime))\n\t\t\t\tbreak;\n\n\t\t\t/* check if connection is still alive */\n\t\t\tconnectionStatus = PQstatus(connection);\n\t\t\tif (connectionStatus == CONNECTION_BAD)\n\t\t\t{\n\t\t\t\ttask->errorMessage = \"connection failed\";\n\t\t\t\ttask->pollingStatus = 0;\n\t\t\t\ttask->state = CRON_TASK_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* check if socket is ready to send */\n\t\t\tif (!task->isSocketReady)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* check whether a connection has been established */\n\t\t\tpollingStatus = PQconnectPoll(connection);\n\t\t\tif (pollingStatus == PGRES_POLLING_OK)\n\t\t\t{\n\t\t\t\tpid_t pid;\n\t\t\t\t/* wait for socket to be ready to send a query */\n\t\t\t\ttask->pollingStatus = PGRES_POLLING_WRITING;\n\n\t\t\t\ttask->state = CRON_TASK_SENDING;\n\n\t\t\t\tpid = (pid_t) PQbackendPID(connection);\n\t\t\t\tif (CronLogRun)\n\t\t\t\t\tUpdateJobRunDetail(task->runId, &pid, GetCronStatus(CRON_STATUS_SENDING), NULL, NULL, NULL);\n\t\t\t}\n\t\t\telse if (pollingStatus == PGRES_POLLING_FAILED)\n\t\t\t{\n\t\t\t\ttask->errorMessage = \"connection failed\";\n\t\t\t\ttask->pollingStatus = 0;\n\t\t\t\ttask->state = CRON_TASK_ERROR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Connection is still being established.\n\t\t\t\t *\n\t\t\t\t * On the next WaitForTasks round, we wait for reading or writing\n\t\t\t\t * based on the status returned by PQconnectPoll, see:\n\t\t\t\t * https://www.postgresql.org/docs/9.5/static/libpq-connect.html\n\t\t\t\t */\n\t\t\t\ttask->pollingStatus = pollingStatus;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CRON_TASK_SENDING:\n\t\t{\n\t\t\tchar *command = cronJob->command;\n\t\t\tint sendResult = 0;\n\n\t\t\tAssert(!UseBackgroundWorkers);\n\n\t\t\t/* check if job has been removed */\n\t\t\tif (jobCanceled(task))\n\t\t\t\tbreak;\n\n\t\t\t/* check if timeout has been reached */\n\t\t\tif (jobStartupTimeout(task, currentTime))\n\t\t\t\tbreak;\n\n\t\t\t/* check if socket is ready to send */\n\t\t\tif (!task->isSocketReady)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* check if connection is still alive */\n\t\t\tconnectionStatus = PQstatus(connection);\n\t\t\tif (connectionStatus == CONNECTION_BAD)\n\t\t\t{\n\t\t\t\ttask->errorMessage = \"connection lost\";\n\t\t\t\ttask->pollingStatus = 0;\n\t\t\t\ttask->state = CRON_TASK_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsendResult = PQsendQuery(connection, command);\n\t\t\tif (sendResult == 1)\n\t\t\t{\n\t\t\t\t/* wait for socket to be ready to receive results */\n\t\t\t\ttask->pollingStatus = PGRES_POLLING_READING;\n\n\t\t\t\t/* command is underway, stop using timeout */\n\t\t\t\ttask->startDeadline = 0;\n\t\t\t\ttask->state = CRON_TASK_RUNNING;\n\n\t\t\t\tstart_time = GetCurrentTimestamp();\n\t\t\t\tif (CronLogRun)\n\t\t\t\t\tUpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_RUNNING), NULL, &start_time, NULL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not yet ready to send */\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CRON_TASK_RUNNING:\n\t\t{\n\t\t\tint connectionBusy = 0;\n\t\t\tPGresult *result = NULL;\n\t\t\tAssert(!UseBackgroundWorkers);\n\n\t\t\t/* check if job has been removed */\n\t\t\tif (jobCanceled(task))\n\t\t\t\tbreak;\n\n\t\t\t/* check if connection is still alive */\n\t\t\tconnectionStatus = PQstatus(connection);\n\t\t\tif (connectionStatus == CONNECTION_BAD)\n\t\t\t{\n\t\t\t\ttask->errorMessage = \"connection lost\";\n\t\t\t\ttask->pollingStatus = 0;\n\t\t\t\ttask->state = CRON_TASK_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* check if socket is ready to send */\n\t\t\tif (!task->isSocketReady)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPQconsumeInput(connection);\n\n\t\t\tconnectionBusy = PQisBusy(connection);\n\t\t\tif (connectionBusy)\n\t\t\t{\n\t\t\t\t/* still waiting for results */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile ((result = PQgetResult(connection)) != NULL)\n\t\t\t{\n\t\t\t\tGetTaskFeedback(result, task);\n\t\t\t}\n\n\t\t\tPQfinish(connection);\n\n\t\t\ttask->connection = NULL;\n\t\t\ttask->pollingStatus = 0;\n\t\t\ttask->isSocketReady = false;\n\n\t\t\ttask->state = CRON_TASK_DONE;\n\t\t\tRunningTaskCount--;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CRON_TASK_BGW_RUNNING:\n\t\t{\n\t\t\tpid_t pid;\n\t\t\tshm_mq_handle *responseq;\n\t\t\tshm_mq *mq;\n\t\t\tshm_toc *toc;\n\n\t\t\tAssert(UseBackgroundWorkers);\n\t\t\t/* check if job has been removed */\n\t\t\tif (jobCanceled(task))\n\t\t\t{\n\t\t\t\tTerminateBackgroundWorker(&task->handle);\n\t\t\t\tWaitForBackgroundWorkerShutdown(&task->handle);\n\t\t\t\tdsm_detach(task->seg);\n\t\t\t\ttask->seg = NULL;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* still waiting for job to complete */\n\t\t\tif (GetBackgroundWorkerPid(&task->handle, &pid) != BGWH_STOPPED)\n\t\t\t\tbreak;\n\n\t\t\ttoc = shm_toc_attach(PG_CRON_MAGIC, dsm_segment_address(task->seg));\n\t\t\t#if PG_VERSION_NUM < 100000\n\t\t\t\tmq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE);\n\t\t\t#else\n\t\t\t\tmq = shm_toc_lookup(toc, PG_CRON_KEY_QUEUE, false);\n\t\t\t#endif\n\t\t\tresponseq = shm_mq_attach(mq, task->seg, NULL);\n\t\t\tGetBgwTaskFeedback(responseq, task);\n\n\t\t\ttask->state = CRON_TASK_DONE;\n\t\t\tdsm_detach(task->seg);\n\t\t\ttask->seg = NULL;\n\t\t\tRunningTaskCount--;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CRON_TASK_ERROR:\n\t\t{\n\t\t\tif (connection != NULL)\n\t\t\t{\n\t\t\t\tPQfinish(connection);\n\t\t\t\ttask->connection = NULL;\n\t\t\t}\n\n\t\t\tif (!task->isActive)\n\t\t\t{\n\t\t\t\tRemoveTask(jobId);\n\t\t\t}\n\n\t\t\tif (task->errorMessage != NULL)\n\t\t\t{\n\t\t\t\tif (CronLogRun)\n\t\t\t\t\tUpdateJobRunDetail(task->runId, NULL, GetCronStatus(CRON_STATUS_FAILED), task->errorMessage, NULL, NULL);\n\n\t\t\t\tereport(LOG, (errmsg(\"cron job \" INT64_FORMAT \" %s\",\n\t\t\t\t\t\t\t\t\t jobId, task->errorMessage)));\n\n\n\t\t\t\tif (task->freeErrorMessage)\n\t\t\t\t{\n\t\t\t\t\tfree(task->errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tereport(LOG, (errmsg(\"cron job \" INT64_FORMAT \" %s\", jobId, GetCronStatus(CRON_STATUS_FAILED))));\n\t\t\t}\n\n\t\t\ttask->startDeadline = 0;\n\t\t\ttask->isSocketReady = false;\n\t\t\ttask->state = CRON_TASK_DONE;\n\n\t\t\tRunningTaskCount--;\n\n\t\t\t/* fall through to CRON_TASK_DONE */\n\t\t}\n\n\t\tcase CRON_TASK_DONE:\n\t\tdefault:\n\t\t{\n\t\t\tint currentPendingRunCount = task->pendingRunCount;\n\n\t\t\tInitializeCronTask(task, jobId);\n\n\t\t\t/*\n\t\t\t * We keep the number of runs that should have started while\n\t\t\t * the task was still running. If >0, this will trigger another\n\t\t\t * run immediately.\n\t\t\t */\n\t\t\ttask->pendingRunCount = currentPendingRunCount;\n\t\t}\n\t}\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * Signal handler for SIGHUP\n *\t\tSet a flag to tell the main loop to reload the cron jobs.\n */\n", "func_signal": "static void\npg_cron_sighup(SIGNAL_ARGS)", "code": "{\n\tCronJobCacheValid = false;\n\n\tif (MyProc != NULL)\n\t{\n\t\tSetLatch(&MyProc->procLatch);\n\t}\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/* return NULL if eof or syntax error occurs;\n * otherwise return a pointer to a new entry.\n *\n * Note: This function is a modified version of load_entry in Vixie\n * cron. It only parses the schedule part of a cron entry and uses\n * an in-memry buffer.\n */\n", "func_signal": "entry *\nparse_cron_entry(char *schedule)", "code": "{\n\t/* this function reads one crontab entry -- the next -- from a file.\n\t * it skips any leading blank lines, ignores comments, and returns\n\t * EOF if for any reason the entry can't be read and parsed.\n\t *\n\t * the entry is also parsed here.\n\t *\n\t * syntax:\n\t *   user crontab:\n\t *\tminutes hours doms months dows cmd\\n\n\t *   system crontab (/etc/crontab):\n\t *\tminutes hours doms months dows USERNAME cmd\\n\n\t */\n\n\tecode_e\tecode = e_none;\n\tentry *e = (entry *) calloc(sizeof(entry), sizeof(char));\n\tint\tch = 0;\n\tchar cmd[MAX_COMMAND];\n\tfile_buffer buffer = {{},0,0,{},0};\n\tFILE *file = (FILE *) &buffer;\n\n\tint scheduleLength = strlen(schedule);\n\tif (scheduleLength >= MAX_FILE_BUFFER_LENGTH)\n\t{\n\t\tch = EOF;\n\t\tecode = e_cmd_len;\n\t\tgoto eof;\n\t}\n\n\tstrcpy(buffer.data, schedule);\n\tbuffer.length = scheduleLength;\n\tbuffer.pointer = 0;\n\n\tDebug(DPARS, (\"load_entry()...about to eat comments\\n\"))\n\n\tskip_comments(file);\n\n\tch = get_char(file);\n\tif (ch == EOF)\n\t{\n\t\tfree_entry(e);\n\t\treturn NULL;\n\t}\n\n\t/* ch is now the first useful character of a useful line.\n\t * it may be an @special or it may be the first character\n\t * of a list of minutes.\n\t */\n\n\tif (ch == '@') {\n\t\t/* all of these should be flagged and load-limited; i.e.,\n\t\t * instead of @hourly meaning \"0 * * * *\" it should mean\n\t\t * \"close to the front of every hour but not 'til the\n\t\t * system load is low\".  Problems are: how do you know\n\t\t * what \"low\" means? (save me from /etc/cron.conf!) and:\n\t\t * how to guarantee low variance (how low is low?), which\n\t\t * means how to we run roughly every hour -- seems like\n\t\t * we need to keep a history or let the first hour set\n\t\t * the schedule, which means we aren't load-limited\n\t\t * anymore.  too much for my overloaded brain. (vix, jan90)\n\t\t * HINT\n\t\t */\n\t\tch = get_string(cmd, MAX_COMMAND, file, \" \\t\\n\");\n\t\tif (!strcmp(\"reboot\", cmd) || !strcmp(\"restart\", cmd)) {\n\t\t\te->flags |= WHEN_REBOOT;\n\t\t} else if (!strcmp(\"yearly\", cmd) || !strcmp(\"annually\", cmd)){\n\t\t\tbit_set(e->minute, 0);\n\t\t\tbit_set(e->hour, 0);\n\t\t\tbit_set(e->dom, 0);\n\t\t\tbit_set(e->month, 0);\n\t\t\tbit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));\n                        e->flags |= DOW_STAR;\n\t\t} else if (!strcmp(\"monthly\", cmd)) {\n\t\t\tbit_set(e->minute, 0);\n\t\t\tbit_set(e->hour, 0);\n\t\t\tbit_set(e->dom, 0);\n\t\t\tbit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));\n\t\t\tbit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));\n                        e->flags |= DOW_STAR;\n\t\t} else if (!strcmp(\"weekly\", cmd)) {\n\t\t\tbit_set(e->minute, 0);\n\t\t\tbit_set(e->hour, 0);\n\t\t\tbit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));\n\t\t\te->flags |= DOM_STAR;\n\t\t\tbit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));\n\t\t\tbit_nset(e->dow, 0,0);\n\t\t} else if (!strcmp(\"daily\", cmd) || !strcmp(\"midnight\", cmd)) {\n\t\t\tbit_set(e->minute, 0);\n\t\t\tbit_set(e->hour, 0);\n\t\t\tbit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));\n\t\t\tbit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));\n\t\t\tbit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));\n\t\t} else if (!strcmp(\"hourly\", cmd)) {\n\t\t\tbit_set(e->minute, 0);\n\t\t\tbit_nset(e->hour, 0, (LAST_HOUR-FIRST_HOUR+1));\n\t\t\tbit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));\n\t\t\tbit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));\n\t\t\tbit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));\n\t\t\te->flags |= HR_STAR;\n\t\t} else {\n\t\t\tecode = e_timespec;\n\t\t\tgoto eof;\n\t\t}\n\t} else {\n\t\tDebug(DPARS, (\"load_entry()...about to parse numerics\\n\"))\n\n\t\tif (ch == '*')\n\t\t\te->flags |= MIN_STAR;\n\t\tch = get_list(e->minute, FIRST_MINUTE, LAST_MINUTE,\n\t\t\t      PPC_NULL, ch, file);\n\t\tif (ch == EOF) {\n\t\t\tecode = e_minute;\n\t\t\tgoto eof;\n\t\t}\n\n\t\t/* hours\n\t\t */\n\n\t\tif (ch == '*')\n\t\t\te->flags |= HR_STAR;\n\t\tch = get_list(e->hour, FIRST_HOUR, LAST_HOUR,\n\t\t\t      PPC_NULL, ch, file);\n\t\tif (ch == EOF) {\n\t\t\tecode = e_hour;\n\t\t\tgoto eof;\n\t\t}\n\n\t\t/* DOM (days of month)\n\t\t */\n\n\t\tif (ch == '*')\n\t\t\te->flags |= DOM_STAR;\n\t\tch = get_list(e->dom, FIRST_DOM, LAST_DOM,\n\t\t\t      PPC_NULL, ch, file);\n\t\tif (ch == EOF) {\n\t\t\tecode = e_dom;\n\t\t\tgoto eof;\n\t\t}\n\n\t\t/* month\n\t\t */\n\n\t\tch = get_list(e->month, FIRST_MONTH, LAST_MONTH,\n\t\t\t      MonthNames, ch, file);\n\t\tif (ch == EOF) {\n\t\t\tecode = e_month;\n\t\t\tgoto eof;\n\t\t}\n\n\t\t/* DOW (days of week)\n\t\t */\n\n\t\tif (ch == '*')\n\t\t\te->flags |= DOW_STAR;\n\t\tch = get_list(e->dow, FIRST_DOW, LAST_DOW,\n\t\t\t      DowNames, ch, file);\n\t\tif (ch == EOF) {\n\t\t\tecode = e_month;\n\t\t\tgoto eof;\n\t\t}\n\t}\n\n\t/* make sundays equivalent */\n\tif (bit_test(e->dow, 0) || bit_test(e->dow, 7)) {\n\t\tbit_set(e->dow, 0);\n\t\tbit_set(e->dow, 7);\n\t}\n\n\t/* success, fini, return pointer to the entry we just created...\n\t */\n\treturn e;\n\n eof:\n\telog(LOG, \"failed to parse entry %d\", ecode);\n\tfree_entry(e);\n\twhile (ch != EOF && ch != '\\n')\n\t\tch = get_char(file);\n\treturn NULL;\n}", "path": "pg_cron/src/entry.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * If a task is not marked as active, set an appropriate error state on the task\n * and return true. Note that this should only be called after a task has\n * already been launched.\n */\n", "func_signal": "static bool\njobCanceled(CronTask *task)", "code": "{\n    Assert(task->state == CRON_TASK_CONNECTING || \\\n            task->state == CRON_TASK_SENDING || \\\n            task->state == CRON_TASK_BGW_RUNNING || \\\n            task->state == CRON_TASK_RUNNING);\n\n    if (task->isActive)\n        return false;\n    else\n    {\n        /* Use the American spelling for consistency with PG code. */\n        task->errorMessage = \"job canceled\";\n        task->state = CRON_TASK_ERROR;\n\n        /*\n         * Technically, pollingStatus is only used by when UseBackgroundWorkers\n         * is false, but no damage in setting it in both cases.\n         */\n        task->pollingStatus = 0;\n        return true;\n    }\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/*\n * _PG_init gets called when the extension is loaded.\n */\n", "func_signal": "void\n_PG_init(void)", "code": "{\n\tBackgroundWorker worker;\n\n\tif (IsBinaryUpgrade)\n\t{\n\t\treturn;\n\t}\n\n\tif (!process_shared_preload_libraries_in_progress)\n\t{\n\t\tereport(ERROR, (errmsg(\"pg_cron can only be loaded via shared_preload_libraries\"),\n\t\t\t\t\t\terrhint(\"Add pg_cron to the shared_preload_libraries \"\n\t\t\t\t\t\t\t\t\"configuration variable in postgresql.conf.\")));\n\t}\n\n\tDefineCustomStringVariable(\n\t\t\"cron.database_name\",\n\t\tgettext_noop(\"Database in which pg_cron metadata is kept.\"),\n\t\tNULL,\n\t\t&CronTableDatabaseName,\n\t\t\"postgres\",\n\t\tPGC_POSTMASTER,\n\t\tGUC_SUPERUSER_ONLY,\n\t\tNULL, NULL, NULL);\n\n\tDefineCustomBoolVariable(\n\t\t\"cron.log_statement\",\n\t\tgettext_noop(\"Log all cron statements prior to execution.\"),\n\t\tNULL,\n\t\t&CronLogStatement,\n\t\ttrue,\n\t\tPGC_POSTMASTER,\n\t\tGUC_SUPERUSER_ONLY,\n\t\tNULL, NULL, NULL);\n\n\tDefineCustomBoolVariable(\n\t\t\"cron.log_run\",\n\t\tgettext_noop(\"Log all jobs runs into the job_run_details table\"),\n\t\tNULL,\n\t\t&CronLogRun,\n\t\ttrue,\n\t\tPGC_POSTMASTER,\n\t\tGUC_SUPERUSER_ONLY,\n\t\tNULL, NULL, NULL);\n\n\tDefineCustomStringVariable(\n\t\t\"cron.host\",\n\t\tgettext_noop(\"Hostname to connect to postgres.\"),\n\t\tgettext_noop(\"This setting has no effect when background workers are used.\"),\n\t\t&CronHost,\n\t\t\"localhost\",\n\t\tPGC_POSTMASTER,\n\t\tGUC_SUPERUSER_ONLY,\n\t\tNULL, NULL, NULL);\n\n\tDefineCustomBoolVariable(\n\t\t\"cron.use_background_workers\",\n\t\tgettext_noop(\"Use background workers instead of client sessions.\"),\n\t\tNULL,\n\t\t&UseBackgroundWorkers,\n\t\tfalse,\n\t\tPGC_POSTMASTER,\n\t\tGUC_SUPERUSER_ONLY,\n\t\tNULL, NULL, NULL);\n\n\tif (!UseBackgroundWorkers)\n\t\tDefineCustomIntVariable(\n\t\t\t\"cron.max_running_jobs\",\n\t\t\tgettext_noop(\"Maximum number of jobs that can run concurrently.\"),\n\t\t\tNULL,\n\t\t\t&MaxRunningTasks,\n\t\t\t32,\n\t\t\t0,\n\t\t\tMaxConnections,\n\t\t\tPGC_POSTMASTER,\n\t\t\tGUC_SUPERUSER_ONLY,\n\t\t\tNULL, NULL, NULL);\n\telse\n\t\tDefineCustomIntVariable(\n\t\t\t\"cron.max_running_jobs\",\n\t\t\tgettext_noop(\"Maximum number of jobs that can run concurrently.\"),\n\t\t\tNULL,\n\t\t\t&MaxRunningTasks,\n\t\t\t5,\n\t\t\t0,\n\t\t\tmax_worker_processes - 1,\n\t\t\tPGC_POSTMASTER,\n\t\t\tGUC_SUPERUSER_ONLY,\n\t\t\tNULL, NULL, NULL);\n\n\t/* set up common data for all our workers */\n\tworker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;\n\tworker.bgw_start_time = BgWorkerStart_RecoveryFinished;\n\tworker.bgw_restart_time = 1;\n#if (PG_VERSION_NUM < 100000)\n\tworker.bgw_main = PgCronLauncherMain;\n#endif\n\tworker.bgw_main_arg = Int32GetDatum(0);\n\tworker.bgw_notify_pid = 0;\n\tsprintf(worker.bgw_library_name, \"pg_cron\");\n\tsprintf(worker.bgw_function_name, \"PgCronLauncherMain\");\n\tsnprintf(worker.bgw_name, BGW_MAXLEN, \"pg_cron launcher\");\n#if (PG_VERSION_NUM >= 110000)\n\tsnprintf(worker.bgw_type, BGW_MAXLEN, \"pg_cron launcher\");\n#endif\n\n\tRegisterBackgroundWorker(&worker);\n}", "path": "pg_cron/src/pg_cron.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "citusdata/pg_cron", "stars": 2458, "license": "postgresql", "language": "c", "size": 305}
{"docstring": "/**\n * Callback for toggling D-Bus watch status.\n */\n", "func_signal": "static void\ncdbus_callback_watch_toggled(DBusWatch *watch, void *data)", "code": "{\n  if (dbus_watch_get_enabled(watch)) {\n    cdbus_callback_add_watch(watch, data);\n  }\n  else {\n    cdbus_callback_remove_watch(watch, data);\n  }\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Callback for toggling a D-Bus timeout.\n */\n", "func_signal": "static void\ncdbus_callback_timeout_toggled(DBusTimeout *timeout, void *data)", "code": "{\n  timeout_t *ptmout = dbus_timeout_get_data(timeout);\n\n  assert(ptmout);\n  if (ptmout) {\n    ptmout->enabled = dbus_timeout_get_enabled(timeout);\n    // Refresh interval as libdbus doc says: \"Whenever a timeout is toggled,\n    // its interval may change.\"\n    ptmout->interval = dbus_timeout_get_interval(timeout);\n  }\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Callback to append an cdbus_enum_t argument to a message.\n */\n", "func_signal": "static bool\ncdbus_apdarg_enum(session_t *ps, DBusMessage *msg, const void *data)", "code": "{\n  assert(data);\n  if (!dbus_message_append_args(msg, CDBUS_TYPE_ENUM, data,\n        DBUS_TYPE_INVALID)) {\n    printf_errf(\"(): Failed to append argument.\");\n    return false;\n  }\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Process a opts_set D-Bus request.\n */\n", "func_signal": "static bool\ncdbus_process_opts_set(session_t *ps, DBusMessage *msg)", "code": "{\n  const char *target = NULL;\n\n  if (!cdbus_msg_get_arg(msg, 0, DBUS_TYPE_STRING, &target))\n    return false;\n\n#define cdbus_m_opts_set_do(tgt, type, real_type) \\\n  if (!strcmp(MSTR(tgt), target)) { \\\n    real_type val; \\\n    if (!cdbus_msg_get_arg(msg, 1, type, &val)) \\\n      return false; \\\n    ps->o.tgt = val; \\\n    goto cdbus_process_opts_set_success; \\\n  }\n\n  // fade_delta\n  if (!strcmp(\"fade_delta\", target)) {\n    int32_t val = 0.0;\n    if (!cdbus_msg_get_arg(msg, 1, DBUS_TYPE_INT32, &val))\n      return false;\n    ps->o.fade_delta = max_i(val, 1);\n    goto cdbus_process_opts_set_success;\n  }\n\n  // fade_in_step\n  if (!strcmp(\"fade_in_step\", target)) {\n    double val = 0.0;\n    if (!cdbus_msg_get_arg(msg, 1, DBUS_TYPE_DOUBLE, &val))\n      return false;\n    ps->o.fade_in_step = normalize_d(val) * OPAQUE;\n    goto cdbus_process_opts_set_success;\n  }\n\n  // fade_out_step\n  if (!strcmp(\"fade_out_step\", target)) {\n    double val = 0.0;\n    if (!cdbus_msg_get_arg(msg, 1, DBUS_TYPE_DOUBLE, &val))\n      return false;\n    ps->o.fade_out_step = normalize_d(val) * OPAQUE;\n    goto cdbus_process_opts_set_success;\n  }\n\n  // no_fading_openclose\n  if (!strcmp(\"no_fading_openclose\", target)) {\n    dbus_bool_t val = FALSE;\n    if (!cdbus_msg_get_arg(msg, 1, DBUS_TYPE_BOOLEAN, &val))\n      return false;\n    opts_set_no_fading_openclose(ps, val);\n    goto cdbus_process_opts_set_success;\n  }\n\n  // unredir_if_possible\n  if (!strcmp(\"unredir_if_possible\", target)) {\n    dbus_bool_t val = FALSE;\n    if (!cdbus_msg_get_arg(msg, 1, DBUS_TYPE_BOOLEAN, &val))\n      return false;\n    if (ps->o.unredir_if_possible != val) {\n      ps->o.unredir_if_possible = val;\n      ps->ev_received = true;\n    }\n    goto cdbus_process_opts_set_success;\n  }\n\n  // clear_shadow\n  if (!strcmp(\"clear_shadow\", target)) {\n    dbus_bool_t val = FALSE;\n    if (!cdbus_msg_get_arg(msg, 1, DBUS_TYPE_BOOLEAN, &val))\n      return false;\n    if (ps->o.clear_shadow != val) {\n      ps->o.clear_shadow = val;\n      force_repaint(ps);\n    }\n    goto cdbus_process_opts_set_success;\n  }\n\n  // track_focus\n  if (!strcmp(\"track_focus\", target)) {\n    dbus_bool_t val = FALSE;\n    if (!cdbus_msg_get_arg(msg, 1, DBUS_TYPE_BOOLEAN, &val))\n      return false;\n    // You could enable this option, but never turn if off\n    if (val) {\n      opts_init_track_focus(ps);\n    }\n    goto cdbus_process_opts_set_success;\n  }\n\n  // vsync\n  if (!strcmp(\"vsync\", target)) {\n    const char * val = NULL;\n    if (!cdbus_msg_get_arg(msg, 1, DBUS_TYPE_STRING, &val))\n      return false;\n    vsync_deinit(ps);\n    if (!parse_vsync(ps, val)) {\n      printf_errf(\"(): \" CDBUS_ERROR_BADARG_S, 1, \"Value invalid.\");\n      cdbus_reply_err(ps, msg, CDBUS_ERROR_BADARG, CDBUS_ERROR_BADARG_S, 1, \"Value invalid.\");\n    }\n    else if (!vsync_init(ps)) {\n      printf_errf(\"(): \" CDBUS_ERROR_CUSTOM_S, \"Failed to initialize specified VSync method.\");\n      cdbus_reply_err(ps, msg, CDBUS_ERROR_CUSTOM, CDBUS_ERROR_CUSTOM_S, \"Failed to initialize specified VSync method.\");\n    }\n    else\n      goto cdbus_process_opts_set_success;\n    return true;\n  }\n\n  // redirected_force\n  if (!strcmp(\"redirected_force\", target)) {\n    cdbus_enum_t val = UNSET;\n    if (!cdbus_msg_get_arg(msg, 1, CDBUS_TYPE_ENUM, &val))\n      return false;\n    ps->o.redirected_force = val;\n    force_repaint(ps);\n    goto cdbus_process_opts_set_success;\n  }\n\n  // stoppaint_force\n  cdbus_m_opts_set_do(stoppaint_force, CDBUS_TYPE_ENUM, cdbus_enum_t);\n\n#undef cdbus_m_opts_set_do\n\n  printf_errf(\"(): \" CDBUS_ERROR_BADTGT_S, target);\n  cdbus_reply_err(ps, msg, CDBUS_ERROR_BADTGT, CDBUS_ERROR_BADTGT_S, target);\n\n  return true;\n\ncdbus_process_opts_set_success:\n  if (!dbus_message_get_no_reply(msg))\n    cdbus_reply_bool(ps, msg, true);\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Process a find_win D-Bus request.\n */\n", "func_signal": "static bool\ncdbus_process_find_win(session_t *ps, DBusMessage *msg)", "code": "{\n  const char *target = NULL;\n\n  if (!cdbus_msg_get_arg(msg, 0, DBUS_TYPE_STRING, &target))\n    return false;\n\n  Window wid = None;\n\n  // Find window by client window\n  if (!strcmp(\"client\", target)) {\n    cdbus_window_t client = None;\n    if (!cdbus_msg_get_arg(msg, 1, CDBUS_TYPE_WINDOW, &client))\n      return false;\n    win *w = find_toplevel(ps, client);\n    if (w)\n      wid = w->id;\n  }\n  // Find focused window\n  else if (!strcmp(\"focused\", target)) {\n    win *w = find_focused(ps);\n    if (w)\n      wid = w->id;\n  }\n  else {\n    printf_errf(\"(): \" CDBUS_ERROR_BADTGT_S, target);\n    cdbus_reply_err(ps, msg, CDBUS_ERROR_BADTGT, CDBUS_ERROR_BADTGT_S, target);\n\n    return true;\n  }\n\n  cdbus_reply_wid(ps, msg, wid);\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Callback to append a string argument to a message.\n */\n", "func_signal": "static bool\ncdbus_apdarg_string(session_t *ps, DBusMessage *msg, const void *data)", "code": "{\n  const char *str = data;\n  if (!str)\n    str = \"\";\n\n  if (!dbus_message_append_args(msg, DBUS_TYPE_STRING, &str,\n        DBUS_TYPE_INVALID)) {\n    printf_errf(\"(): Failed to append argument.\");\n    return false;\n  }\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Initialize D-Bus connection.\n */\n", "func_signal": "bool\ncdbus_init(session_t *ps)", "code": "{\n  DBusError err = { };\n\n  // Initialize\n  dbus_error_init(&err);\n\n  // Connect to D-Bus\n  // Use dbus_bus_get_private() so we can fully recycle it ourselves\n  ps->dbus_conn = dbus_bus_get_private(DBUS_BUS_SESSION, &err);\n  if (dbus_error_is_set(&err)) {\n    printf_errf(\"(): D-Bus connection failed (%s).\", err.message);\n    dbus_error_free(&err);\n    return false;\n  }\n\n  if (!ps->dbus_conn) {\n    printf_errf(\"(): D-Bus connection failed for unknown reason.\");\n    return false;\n  }\n\n  // Avoid exiting on disconnect\n  dbus_connection_set_exit_on_disconnect(ps->dbus_conn, false);\n\n  // Request service name\n  {\n    // Build service name\n    char *service = mstrjoin3(CDBUS_SERVICE_NAME, \".\", ps->o.display_repr);\n    ps->dbus_service = service;\n\n    // Request for the name\n    int ret = dbus_bus_request_name(ps->dbus_conn, service,\n        DBUS_NAME_FLAG_DO_NOT_QUEUE, &err);\n\n    if (dbus_error_is_set(&err)) {\n      printf_errf(\"(): Failed to obtain D-Bus name (%s).\", err.message);\n      dbus_error_free(&err);\n    }\n\n    if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret\n        && DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER != ret) {\n      printf_errf(\"(): Failed to become the primary owner of requested \"\n          \"D-Bus name (%d).\", ret);\n    }\n  }\n\n\n  // Add watch handlers\n  if (!dbus_connection_set_watch_functions(ps->dbus_conn,\n        cdbus_callback_add_watch, cdbus_callback_remove_watch,\n        cdbus_callback_watch_toggled, ps, NULL)) {\n    printf_errf(\"(): Failed to add D-Bus watch functions.\");\n    return false;\n  }\n\n  // Add timeout handlers\n  if (!dbus_connection_set_timeout_functions(ps->dbus_conn,\n        cdbus_callback_add_timeout, cdbus_callback_remove_timeout,\n        cdbus_callback_timeout_toggled, ps, NULL)) {\n    printf_errf(\"(): Failed to add D-Bus timeout functions.\");\n    return false;\n  }\n\n  // Add match\n  dbus_bus_add_match(ps->dbus_conn,\n      \"type='method_call',interface='\" CDBUS_INTERFACE_NAME \"'\", &err);\n  if (dbus_error_is_set(&err)) {\n    printf_errf(\"(): Failed to add D-Bus match.\");\n    dbus_error_free(&err);\n    return false;\n  }\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Callback to append a double argument to a message.\n */\n", "func_signal": "static bool\ncdbus_apdarg_double(session_t *ps, DBusMessage *msg, const void *data)", "code": "{\n  if (!dbus_message_append_args(msg, DBUS_TYPE_DOUBLE, data,\n        DBUS_TYPE_INVALID)) {\n    printf_errf(\"(): Failed to append argument.\");\n    return false;\n  }\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Destroy D-Bus connection.\n */\n", "func_signal": "void\ncdbus_destroy(session_t *ps)", "code": "{\n  if (ps->dbus_conn) {\n    // Release DBus name firstly\n    if (ps->dbus_service) {\n      DBusError err = { };\n      dbus_error_init(&err);\n\n      dbus_bus_release_name(ps->dbus_conn, ps->dbus_service, &err);\n      if (dbus_error_is_set(&err)) {\n        printf_errf(\"(): Failed to release DBus name (%s).\",\n            err.message);\n        dbus_error_free(&err);\n      }\n    }\n\n    // Close and unref the connection\n    dbus_connection_close(ps->dbus_conn);\n    dbus_connection_unref(ps->dbus_conn);\n  }\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Send a D-Bus reply.\n *\n * @param ps current session\n * @param srcmsg original message\n * @param func a function that modifies the built message, to, for example,\n *        add an argument\n * @param data data pointer to pass to the function\n */\n", "func_signal": "static bool\ncdbus_reply(session_t *ps, DBusMessage *srcmsg,\n    bool (*func)(session_t *ps, DBusMessage *msg, const void *data),\n    const void *data)", "code": "{\n  DBusMessage* msg = NULL;\n\n  // Create a reply\n  msg = dbus_message_new_method_return(srcmsg);\n  if (!msg) {\n    printf_errf(\"(): Failed to create D-Bus reply.\");\n    return false;\n  }\n\n  // Append arguments onto message\n  if (func && !func(ps, msg, data)) {\n    dbus_message_unref(msg);\n    return false;\n  }\n\n  // Send the message and flush the connection\n  if (!dbus_connection_send(ps->dbus_conn, msg, NULL)) {\n    printf_errf(\"(): Failed to send D-Bus reply.\");\n    dbus_message_unref(msg);\n    return false;\n  }\n  dbus_connection_flush(ps->dbus_conn);\n\n  // Free the message\n  dbus_message_unref(msg);\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Process a win_set D-Bus request.\n */\n", "func_signal": "static bool\ncdbus_process_win_set(session_t *ps, DBusMessage *msg)", "code": "{\n  cdbus_window_t wid = None;\n  const char *target = NULL;\n  DBusError err = { };\n\n  if (!dbus_message_get_args(msg, &err,\n        CDBUS_TYPE_WINDOW, &wid,\n        DBUS_TYPE_STRING, &target,\n        DBUS_TYPE_INVALID)) {\n    printf_errf(\"(): Failed to parse argument of \\\"win_set\\\" (%s).\",\n        err.message);\n    dbus_error_free(&err);\n    return false;\n  }\n\n  win *w = find_win(ps, wid);\n\n  if (!w) {\n    printf_errf(\"(): Window %#010x not found.\", wid);\n    cdbus_reply_err(ps, msg, CDBUS_ERROR_BADWIN, CDBUS_ERROR_BADWIN_S, wid);\n    return true;\n  }\n\n#define cdbus_m_win_set_do(tgt, type, real_type) \\\n  if (!strcmp(MSTR(tgt), target)) { \\\n    real_type val; \\\n    if (!cdbus_msg_get_arg(msg, 2, type, &val)) \\\n      return false; \\\n    w->tgt = val; \\\n    goto cdbus_process_win_set_success; \\\n  }\n\n  if (!strcmp(\"shadow_force\", target)) {\n    cdbus_enum_t val = UNSET;\n    if (!cdbus_msg_get_arg(msg, 2, CDBUS_TYPE_ENUM, &val))\n      return false;\n    win_set_shadow_force(ps, w, val);\n    goto cdbus_process_win_set_success;\n  }\n\n  if (!strcmp(\"fade_force\", target)) {\n    cdbus_enum_t val = UNSET;\n    if (!cdbus_msg_get_arg(msg, 2, CDBUS_TYPE_ENUM, &val))\n      return false;\n    win_set_fade_force(ps, w, val);\n    goto cdbus_process_win_set_success;\n  }\n\n  if (!strcmp(\"focused_force\", target)) {\n    cdbus_enum_t val = UNSET;\n    if (!cdbus_msg_get_arg(msg, 2, CDBUS_TYPE_ENUM, &val))\n      return false;\n    win_set_focused_force(ps, w, val);\n    goto cdbus_process_win_set_success;\n  }\n\n  if (!strcmp(\"invert_color_force\", target)) {\n    cdbus_enum_t val = UNSET;\n    if (!cdbus_msg_get_arg(msg, 2, CDBUS_TYPE_ENUM, &val))\n      return false;\n    win_set_invert_color_force(ps, w, val);\n    goto cdbus_process_win_set_success;\n  }\n#undef cdbus_m_win_set_do\n\n  printf_errf(\"(): \" CDBUS_ERROR_BADTGT_S, target);\n  cdbus_reply_err(ps, msg, CDBUS_ERROR_BADTGT, CDBUS_ERROR_BADTGT_S, target);\n\n  return true;\n\ncdbus_process_win_set_success:\n  if (!dbus_message_get_no_reply(msg))\n    cdbus_reply_bool(ps, msg, true);\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Get n-th argument of a D-Bus message.\n *\n * @param count the position of the argument to get, starting from 0\n * @param type libdbus type number of the type\n * @param pdest pointer to the target\n * @return true if successful, false otherwise.\n */\n", "func_signal": "static bool\ncdbus_msg_get_arg(DBusMessage *msg, int count, const int type, void *pdest)", "code": "{\n  assert(count >= 0);\n\n  DBusMessageIter iter = { };\n  if (!dbus_message_iter_init(msg, &iter)) {\n    printf_errf(\"(): Message has no argument.\");\n    return false;\n  }\n\n  {\n    const int oldcount = count;\n    while (count) {\n      if (!dbus_message_iter_next(&iter)) {\n        printf_errf(\"(): Failed to find argument %d.\", oldcount);\n        return false;\n      }\n      --count;\n    }\n  }\n\n  if (type != dbus_message_iter_get_arg_type(&iter)) {\n    printf_errf(\"(): Argument has incorrect type.\");\n    return false;\n  }\n\n  dbus_message_iter_get_basic(&iter, pdest);\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Send a D-Bus signal.\n *\n * @param ps current session\n * @param name signal name\n * @param func a function that modifies the built message, to, for example,\n *        add an argument\n * @param data data pointer to pass to the function\n */\n", "func_signal": "static bool\ncdbus_signal(session_t *ps, const char *name,\n    bool (*func)(session_t *ps, DBusMessage *msg, const void *data),\n    const void *data)", "code": "{\n  DBusMessage* msg = NULL;\n\n  // Create a signal\n  msg = dbus_message_new_signal(CDBUS_OBJECT_NAME, CDBUS_INTERFACE_NAME,\n      name);\n  if (!msg) {\n    printf_errf(\"(): Failed to create D-Bus signal.\");\n    return false;\n  }\n\n  // Append arguments onto message\n  if (func && !func(ps, msg, data)) {\n    dbus_message_unref(msg);\n    return false;\n  }\n\n  // Send the message and flush the connection\n  if (!dbus_connection_send(ps->dbus_conn, msg, NULL)) {\n    printf_errf(\"(): Failed to send D-Bus signal.\");\n    dbus_message_unref(msg);\n    return false;\n  }\n  dbus_connection_flush(ps->dbus_conn);\n\n  // Free the message\n  dbus_message_unref(msg);\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Process a opts_get D-Bus request.\n */\n", "func_signal": "static bool\ncdbus_process_opts_get(session_t *ps, DBusMessage *msg)", "code": "{\n  const char *target = NULL;\n\n  if (!cdbus_msg_get_arg(msg, 0, DBUS_TYPE_STRING, &target))\n    return false;\n\n#define cdbus_m_opts_get_do(tgt, apdarg_func) \\\n  if (!strcmp(MSTR(tgt), target)) { \\\n    apdarg_func(ps, msg, ps->o.tgt); \\\n    return true; \\\n  }\n\n  // version\n  if (!strcmp(\"version\", target)) {\n    cdbus_reply_string(ps, msg, COMPTON_VERSION);\n    return true;\n  }\n\n  // pid\n  if (!strcmp(\"pid\", target)) {\n    cdbus_reply_int32(ps, msg, getpid());\n    return true;\n  }\n\n  // display\n  if (!strcmp(\"display\", target)) {\n    cdbus_reply_string(ps, msg, DisplayString(ps->dpy));\n    return true;\n  }\n\n  cdbus_m_opts_get_do(config_file, cdbus_reply_string);\n  cdbus_m_opts_get_do(display_repr, cdbus_reply_string);\n  cdbus_m_opts_get_do(write_pid_path, cdbus_reply_string);\n  cdbus_m_opts_get_do(mark_wmwin_focused, cdbus_reply_bool);\n  cdbus_m_opts_get_do(mark_ovredir_focused, cdbus_reply_bool);\n  cdbus_m_opts_get_do(fork_after_register, cdbus_reply_bool);\n  cdbus_m_opts_get_do(detect_rounded_corners, cdbus_reply_bool);\n  cdbus_m_opts_get_do(paint_on_overlay, cdbus_reply_bool);\n  // paint_on_overlay_id: Get ID of the X composite overlay window\n  if (!strcmp(\"paint_on_overlay_id\", target)) {\n    cdbus_reply_uint32(ps, msg, ps->overlay);\n    return true;\n  }\n  cdbus_m_opts_get_do(unredir_if_possible, cdbus_reply_bool);\n  cdbus_m_opts_get_do(unredir_if_possible_delay, cdbus_reply_int32);\n  cdbus_m_opts_get_do(redirected_force, cdbus_reply_enum);\n  cdbus_m_opts_get_do(stoppaint_force, cdbus_reply_enum);\n  cdbus_m_opts_get_do(logpath, cdbus_reply_string);\n  cdbus_m_opts_get_do(synchronize, cdbus_reply_bool);\n\n  cdbus_m_opts_get_do(refresh_rate, cdbus_reply_int32);\n  cdbus_m_opts_get_do(sw_opti, cdbus_reply_bool);\n  if (!strcmp(\"vsync\", target)) {\n    assert(ps->o.vsync < sizeof(VSYNC_STRS) / sizeof(VSYNC_STRS[0]));\n    cdbus_reply_string(ps, msg, VSYNC_STRS[ps->o.vsync]);\n    return true;\n  }\n  if (!strcmp(\"backend\", target)) {\n    assert(ps->o.backend < sizeof(BACKEND_STRS) / sizeof(BACKEND_STRS[0]));\n    cdbus_reply_string(ps, msg, BACKEND_STRS[ps->o.backend]);\n    return true;\n  }\n  cdbus_m_opts_get_do(dbe, cdbus_reply_bool);\n  cdbus_m_opts_get_do(vsync_aggressive, cdbus_reply_bool);\n\n  cdbus_m_opts_get_do(shadow_red, cdbus_reply_double);\n  cdbus_m_opts_get_do(shadow_green, cdbus_reply_double);\n  cdbus_m_opts_get_do(shadow_blue, cdbus_reply_double);\n  cdbus_m_opts_get_do(shadow_radius, cdbus_reply_int32);\n  cdbus_m_opts_get_do(shadow_offset_x, cdbus_reply_int32);\n  cdbus_m_opts_get_do(shadow_offset_y, cdbus_reply_int32);\n  cdbus_m_opts_get_do(shadow_opacity, cdbus_reply_double);\n  cdbus_m_opts_get_do(clear_shadow, cdbus_reply_bool);\n  cdbus_m_opts_get_do(xinerama_shadow_crop, cdbus_reply_bool);\n\n  cdbus_m_opts_get_do(fade_delta, cdbus_reply_int32);\n  cdbus_m_opts_get_do(fade_in_step, cdbus_reply_int32);\n  cdbus_m_opts_get_do(fade_out_step, cdbus_reply_int32);\n  cdbus_m_opts_get_do(no_fading_openclose, cdbus_reply_bool);\n\n  cdbus_m_opts_get_do(blur_background, cdbus_reply_bool);\n  cdbus_m_opts_get_do(blur_background_frame, cdbus_reply_bool);\n  cdbus_m_opts_get_do(blur_background_fixed, cdbus_reply_bool);\n\n  cdbus_m_opts_get_do(inactive_dim, cdbus_reply_double);\n  cdbus_m_opts_get_do(inactive_dim_fixed, cdbus_reply_bool);\n\n  cdbus_m_opts_get_do(use_ewmh_active_win, cdbus_reply_bool);\n  cdbus_m_opts_get_do(detect_transient, cdbus_reply_bool);\n  cdbus_m_opts_get_do(detect_client_leader, cdbus_reply_bool);\n\n#ifdef CONFIG_VSYNC_OPENGL\n  cdbus_m_opts_get_do(glx_no_stencil, cdbus_reply_bool);\n  cdbus_m_opts_get_do(glx_copy_from_front, cdbus_reply_bool);\n  cdbus_m_opts_get_do(glx_use_copysubbuffermesa, cdbus_reply_bool);\n  cdbus_m_opts_get_do(glx_no_rebind_pixmap, cdbus_reply_bool);\n  cdbus_m_opts_get_do(glx_swap_method, cdbus_reply_int32);\n#endif\n\n  cdbus_m_opts_get_do(track_focus, cdbus_reply_bool);\n  cdbus_m_opts_get_do(track_wdata, cdbus_reply_bool);\n  cdbus_m_opts_get_do(track_leader, cdbus_reply_bool);\n#undef cdbus_m_opts_get_do\n\n  printf_errf(\"(): \" CDBUS_ERROR_BADTGT_S, target);\n  cdbus_reply_err(ps, msg, CDBUS_ERROR_BADTGT, CDBUS_ERROR_BADTGT_S, target);\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Send a D-Bus error reply.\n *\n * @param ps current session\n * @param msg the new error DBusMessage\n */\n", "func_signal": "static bool\ncdbus_reply_errm(session_t *ps, DBusMessage *msg)", "code": "{\n  if (!msg) {\n    printf_errf(\"(): Failed to create D-Bus reply.\");\n    return false;\n  }\n\n  // Send the message and flush the connection\n  if (!dbus_connection_send(ps->dbus_conn, msg, NULL)) {\n    printf_errf(\"(): Failed to send D-Bus reply.\");\n    dbus_message_unref(msg);\n    return false;\n  }\n  dbus_connection_flush(ps->dbus_conn);\n\n  // Free the message\n  dbus_message_unref(msg);\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Callback for removing D-Bus watch.\n */\n", "func_signal": "static void\ncdbus_callback_remove_watch(DBusWatch *watch, void *data)", "code": "{\n  session_t *ps = data;\n\n  fds_drop(ps, dbus_watch_get_unix_fd(watch),\n      cdbus_get_watch_cond(watch));\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Callback for removing D-Bus timeout.\n */\n", "func_signal": "static void\ncdbus_callback_remove_timeout(DBusTimeout *timeout, void *data)", "code": "{\n  session_t *ps = data;\n\n  timeout_t *ptmout = dbus_timeout_get_data(timeout);\n  assert(ptmout);\n  if (ptmout)\n    timeout_drop(ps, ptmout);\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Callback to append an uint32 argument to a message.\n */\n", "func_signal": "static bool\ncdbus_apdarg_uint32(session_t *ps, DBusMessage *msg, const void *data)", "code": "{\n  if (!dbus_message_append_args(msg, DBUS_TYPE_UINT32, data,\n        DBUS_TYPE_INVALID)) {\n    printf_errf(\"(): Failed to append argument.\");\n    return false;\n  }\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Process a list_win D-Bus request.\n */\n", "func_signal": "static bool\ncdbus_process_list_win(session_t *ps, DBusMessage *msg)", "code": "{\n  cdbus_reply(ps, msg, cdbus_apdarg_wids, NULL);\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/**\n * Process a win_get D-Bus request.\n */\n", "func_signal": "static bool\ncdbus_process_win_get(session_t *ps, DBusMessage *msg)", "code": "{\n  cdbus_window_t wid = None;\n  const char *target = NULL;\n  DBusError err = { };\n\n  if (!dbus_message_get_args(msg, &err,\n        CDBUS_TYPE_WINDOW, &wid,\n        DBUS_TYPE_STRING, &target,\n        DBUS_TYPE_INVALID)) {\n    printf_errf(\"(): Failed to parse argument of \\\"win_get\\\" (%s).\",\n        err.message);\n    dbus_error_free(&err);\n    return false;\n  }\n\n  win *w = find_win(ps, wid);\n\n  if (!w) {\n    printf_errf(\"(): Window %#010x not found.\", wid);\n    cdbus_reply_err(ps, msg, CDBUS_ERROR_BADWIN, CDBUS_ERROR_BADWIN_S, wid);\n    return true;\n  }\n\n#define cdbus_m_win_get_do(tgt, apdarg_func) \\\n  if (!strcmp(MSTR(tgt), target)) { \\\n    apdarg_func(ps, msg, w->tgt); \\\n    return true; \\\n  }\n\n  cdbus_m_win_get_do(id, cdbus_reply_wid);\n\n  // next\n  if (!strcmp(\"next\", target)) {\n    cdbus_reply_wid(ps, msg, (w->next ? w->next->id: 0));\n    return true;\n  }\n\n  // map_state\n  if (!strcmp(\"map_state\", target)) {\n    cdbus_reply_bool(ps, msg, w->a.map_state);\n    return true;\n  }\n\n  cdbus_m_win_get_do(mode, cdbus_reply_enum);\n  cdbus_m_win_get_do(client_win, cdbus_reply_wid);\n  cdbus_m_win_get_do(damaged, cdbus_reply_bool);\n  cdbus_m_win_get_do(destroyed, cdbus_reply_bool);\n  cdbus_m_win_get_do(window_type, cdbus_reply_enum);\n  cdbus_m_win_get_do(wmwin, cdbus_reply_bool);\n  cdbus_m_win_get_do(leader, cdbus_reply_wid);\n  // focused_real\n  if (!strcmp(\"focused_real\", target)) {\n    cdbus_reply_bool(ps, msg, win_is_focused_real(ps, w));\n    return true;\n  }\n  cdbus_m_win_get_do(fade_force, cdbus_reply_enum);\n  cdbus_m_win_get_do(shadow_force, cdbus_reply_enum);\n  cdbus_m_win_get_do(focused_force, cdbus_reply_enum);\n  cdbus_m_win_get_do(invert_color_force, cdbus_reply_enum);\n  cdbus_m_win_get_do(name, cdbus_reply_string);\n  cdbus_m_win_get_do(class_instance, cdbus_reply_string);\n  cdbus_m_win_get_do(class_general, cdbus_reply_string);\n  cdbus_m_win_get_do(role, cdbus_reply_string);\n\n  cdbus_m_win_get_do(opacity, cdbus_reply_uint32);\n  cdbus_m_win_get_do(opacity_tgt, cdbus_reply_uint32);\n  cdbus_m_win_get_do(opacity_prop, cdbus_reply_uint32);\n  cdbus_m_win_get_do(opacity_prop_client, cdbus_reply_uint32);\n  cdbus_m_win_get_do(opacity_set, cdbus_reply_uint32);\n\n  cdbus_m_win_get_do(frame_opacity, cdbus_reply_double);\n  if (!strcmp(\"left_width\", target)) {\n    cdbus_reply_uint32(ps, msg, w->frame_extents.left);\n    return true;\n  }\n  if (!strcmp(\"right_width\", target)) {\n    cdbus_reply_uint32(ps, msg, w->frame_extents.right);\n    return true;\n  }\n  if (!strcmp(\"top_width\", target)) {\n    cdbus_reply_uint32(ps, msg, w->frame_extents.top);\n    return true;\n  }\n  if (!strcmp(\"bottom_width\", target)) {\n    cdbus_reply_uint32(ps, msg, w->frame_extents.bottom);\n    return true;\n  }\n\n  cdbus_m_win_get_do(shadow, cdbus_reply_bool);\n  cdbus_m_win_get_do(fade, cdbus_reply_bool);\n  cdbus_m_win_get_do(invert_color, cdbus_reply_bool);\n  cdbus_m_win_get_do(blur_background, cdbus_reply_bool);\n#undef cdbus_m_win_get_do\n\n  printf_errf(\"(): \" CDBUS_ERROR_BADTGT_S, target);\n  cdbus_reply_err(ps, msg, CDBUS_ERROR_BADTGT, CDBUS_ERROR_BADTGT_S, target);\n\n  return true;\n}", "path": "compton/src/dbus.c", "commit_date": "2015-09-06 00:00:00", "repo_name": "chjj/compton", "stars": 2225, "license": "other", "language": "c", "size": 1215}
{"docstring": "/* return [path, errorcode] */\n", "func_signal": "static JSValue js_os_readlink(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)", "code": "{\n    const char *path;\n    char buf[PATH_MAX];\n    int err;\n    ssize_t res;\n    \n    path = JS_ToCString(ctx, argv[0]);\n    if (!path)\n        return JS_EXCEPTION;\n    res = readlink(path, buf, sizeof(buf) - 1);\n    if (res < 0) {\n        buf[0] = '\\0';\n        err = errno;\n    } else {\n        buf[res] = '\\0';\n        err = 0;\n    }\n    JS_FreeCString(ctx, path);\n    return make_string_error(ctx, buf, err);\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* pipe() -> [read_fd, write_fd] or null if error */\n", "func_signal": "static JSValue js_os_pipe(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv)", "code": "{\n    int pipe_fds[2], ret;\n    JSValue obj;\n    \n    ret = pipe(pipe_fds);\n    if (ret < 0)\n        return JS_NULL;\n    obj = JS_NewArray(ctx);\n    if (JS_IsException(obj))\n        return obj;\n    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, pipe_fds[0]),\n                                 JS_PROP_C_W_E);\n    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, pipe_fds[1]),\n                                 JS_PROP_C_W_E);\n    return obj;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* return [cwd, errorcode] */\n", "func_signal": "static JSValue js_os_getcwd(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)", "code": "{\n    char buf[PATH_MAX];\n    int err;\n    \n    if (!getcwd(buf, sizeof(buf))) {\n        buf[0] = '\\0';\n        err = errno;\n    } else {\n        err = 0;\n    }\n    return make_string_error(ctx, buf, err);\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* dup2(fd) */\n", "func_signal": "static JSValue js_os_dup2(JSContext *ctx, JSValueConst this_val,\n                         int argc, JSValueConst *argv)", "code": "{\n    int fd, fd2, ret;\n    \n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &fd2, argv[1]))\n        return JS_EXCEPTION;\n    ret = js_get_errno(dup2(fd, fd2));\n    return JS_NewInt32(ctx, ret);\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* return 1 if a message was handled, 0 if no message */\n", "func_signal": "static int handle_posted_message(JSRuntime *rt, JSContext *ctx,\n                                 JSWorkerMessageHandler *port)", "code": "{\n    JSWorkerMessagePipe *ps = port->recv_pipe;\n    int ret;\n    struct list_head *el;\n    JSWorkerMessage *msg;\n    JSValue obj, data_obj, func, retval;\n    \n    pthread_mutex_lock(&ps->mutex);\n    if (!list_empty(&ps->msg_queue)) {\n        el = ps->msg_queue.next;\n        msg = list_entry(el, JSWorkerMessage, link);\n\n        /* remove the message from the queue */\n        list_del(&msg->link);\n\n        if (list_empty(&ps->msg_queue)) {\n            uint8_t buf[16];\n            int ret;\n            for(;;) {\n                ret = read(ps->read_fd, buf, sizeof(buf));\n                if (ret >= 0)\n                    break;\n                if (errno != EAGAIN && errno != EINTR)\n                    break;\n            }\n        }\n\n        pthread_mutex_unlock(&ps->mutex);\n\n        data_obj = JS_ReadObject(ctx, msg->data, msg->data_len,\n                                 JS_READ_OBJ_SAB | JS_READ_OBJ_REFERENCE);\n\n        js_free_message(msg);\n        \n        if (JS_IsException(data_obj))\n            goto fail;\n        obj = JS_NewObject(ctx);\n        if (JS_IsException(obj)) {\n            JS_FreeValue(ctx, data_obj);\n            goto fail;\n        }\n        JS_DefinePropertyValueStr(ctx, obj, \"data\", data_obj, JS_PROP_C_W_E);\n\n        /* 'func' might be destroyed when calling itself (if it frees the\n           handler), so must take extra care */\n        func = JS_DupValue(ctx, port->on_message_func);\n        retval = JS_Call(ctx, func, JS_UNDEFINED, 1, (JSValueConst *)&obj);\n        JS_FreeValue(ctx, obj);\n        JS_FreeValue(ctx, func);\n        if (JS_IsException(retval)) {\n        fail:\n            js_std_dump_error(ctx);\n        } else {\n            JS_FreeValue(ctx, retval);\n        }\n        ret = 1;\n    } else {\n        pthread_mutex_unlock(&ps->mutex);\n        ret = 0;\n    }\n    return ret;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* !_WIN32 */\n", "func_signal": "static JSValue js_os_remove(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)", "code": "{\n    const char *filename;\n    int ret;\n    \n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        return JS_EXCEPTION;\n    ret = js_get_errno(remove(filename));\n    JS_FreeCString(ctx, filename);\n    return JS_NewInt32(ctx, ret);\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* shared array buffer allocator */\n", "func_signal": "static void *js_sab_alloc(void *opaque, size_t size)", "code": "{\n    JSSABHeader *sab;\n    sab = malloc(sizeof(JSSABHeader) + size);\n    if (!sab)\n        return NULL;\n    sab->ref_count = 1;\n    return sab->buf;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* run a test when called by test262-harness+eshost */\n", "func_signal": "int run_test262_harness_test(const char *filename, BOOL is_module)", "code": "{\n    JSRuntime *rt;\n    JSContext *ctx;\n    char *buf;\n    size_t buf_len;\n    int eval_flags, ret_code, ret;\n    JSValue res_val;\n    BOOL can_block;\n    \n    outfile = stdout; /* for js_print */\n\n    rt = JS_NewRuntime();\n    if (rt == NULL) {\n        fatal(1, \"JS_NewRuntime failure\");\n    }        \n    ctx = JS_NewContext(rt);\n    if (ctx == NULL) {\n        JS_FreeRuntime(rt);\n        fatal(1, \"JS_NewContext failure\");\n    }\n    JS_SetRuntimeInfo(rt, filename);\n\n    can_block = TRUE;\n    JS_SetCanBlock(rt, can_block);\n    \n    /* loader for ES6 modules */\n    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader_test, NULL);\n        \n    add_helpers(ctx);\n\n    buf = load_file(filename, &buf_len);\n\n    if (is_module) {\n      eval_flags = JS_EVAL_TYPE_MODULE;\n    } else {\n      eval_flags = JS_EVAL_TYPE_GLOBAL;\n    }\n    res_val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);\n    ret_code = 0;\n    if (JS_IsException(res_val)) {\n       js_std_dump_error(ctx);\n       ret_code = 1;\n    } else {\n        JS_FreeValue(ctx, res_val);\n        for(;;) {\n            JSContext *ctx1;\n            ret = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);\n            if (ret < 0) {\n\t      js_std_dump_error(ctx1);\n\t      ret_code = 1;\n            } else if (ret == 0) {\n\t      break;\n            }\n        }\n    }\n    free(buf);\n#ifdef CONFIG_AGENT\n    js_agent_free(ctx);\n#endif\n    JS_FreeContext(ctx);\n    JS_FreeRuntime(rt);\n    return ret_code;\n}", "path": "QuickJS/run-test262.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* return [obj, errcode] */\n", "func_signal": "static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv, int is_lstat)", "code": "{\n    const char *path;\n    int err, res;\n    struct stat st;\n    JSValue obj;\n\n    path = JS_ToCString(ctx, argv[0]);\n    if (!path)\n        return JS_EXCEPTION;\n#if defined(_WIN32)\n    res = stat(path, &st);\n#else\n    if (is_lstat)\n        res = lstat(path, &st);\n    else\n        res = stat(path, &st);\n#endif\n    JS_FreeCString(ctx, path);\n    if (res < 0) {\n        err = errno;\n        obj = JS_NULL;\n    } else {\n        err = 0;\n        obj = JS_NewObject(ctx);\n        if (JS_IsException(obj))\n            return JS_EXCEPTION;\n        JS_DefinePropertyValueStr(ctx, obj, \"dev\",\n                                  JS_NewInt64(ctx, st.st_dev),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"ino\",\n                                  JS_NewInt64(ctx, st.st_ino),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"mode\",\n                                  JS_NewInt32(ctx, st.st_mode),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"nlink\",\n                                  JS_NewInt64(ctx, st.st_nlink),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"uid\",\n                                  JS_NewInt64(ctx, st.st_uid),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"gid\",\n                                  JS_NewInt64(ctx, st.st_gid),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"rdev\",\n                                  JS_NewInt64(ctx, st.st_rdev),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"size\",\n                                  JS_NewInt64(ctx, st.st_size),\n                                  JS_PROP_C_W_E);\n#if !defined(_WIN32)\n        JS_DefinePropertyValueStr(ctx, obj, \"blocks\",\n                                  JS_NewInt64(ctx, st.st_blocks),\n                                  JS_PROP_C_W_E);\n#endif\n#if defined(_WIN32)\n        JS_DefinePropertyValueStr(ctx, obj, \"atime\",\n                                  JS_NewInt64(ctx, (int64_t)st.st_atime * 1000),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"mtime\",\n                                  JS_NewInt64(ctx, (int64_t)st.st_mtime * 1000),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"ctime\",\n                                  JS_NewInt64(ctx, (int64_t)st.st_ctime * 1000),\n                                  JS_PROP_C_W_E);\n#elif defined(__APPLE__)\n        JS_DefinePropertyValueStr(ctx, obj, \"atime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atimespec)),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"mtime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtimespec)),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"ctime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctimespec)),\n                                  JS_PROP_C_W_E);\n#else\n        JS_DefinePropertyValueStr(ctx, obj, \"atime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atim)),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"mtime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtim)),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"ctime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctim)),\n                                  JS_PROP_C_W_E);\n#endif\n    }\n    return make_obj_error(ctx, obj, err);\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* main loop which calls the user JS callbacks */\n", "func_signal": "void js_std_loop(JSContext *ctx)", "code": "{\n    JSContext *ctx1;\n    int err;\n\n    for(;;) {\n        /* execute the pending jobs */\n        for(;;) {\n            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);\n            if (err <= 0) {\n                if (err < 0) {\n                    js_std_dump_error(ctx1);\n                }\n                break;\n            }\n        }\n\n        if (!os_poll_func || os_poll_func(ctx))\n            break;\n    }\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* execvpe is not available on non GNU systems */\n", "func_signal": "static int my_execvpe(const char *filename, char **argv, char **envp)", "code": "{\n    char *path, *p, *p_next, *p1;\n    char buf[PATH_MAX];\n    size_t filename_len, path_len;\n    BOOL eacces_error;\n    \n    filename_len = strlen(filename);\n    if (filename_len == 0) {\n        errno = ENOENT;\n        return -1;\n    }\n    if (strchr(filename, '/'))\n        return execve(filename, argv, envp);\n    \n    path = getenv(\"PATH\");\n    if (!path)\n        path = (char *)\"/bin:/usr/bin\";\n    eacces_error = FALSE;\n    p = path;\n    for(p = path; p != NULL; p = p_next) {\n        p1 = strchr(p, ':');\n        if (!p1) {\n            p_next = NULL;\n            path_len = strlen(p);\n        } else {\n            p_next = p1 + 1;\n            path_len = p1 - p;\n        }\n        /* path too long */\n        if ((path_len + 1 + filename_len + 1) > PATH_MAX)\n            continue;\n        memcpy(buf, p, path_len);\n        buf[path_len] = '/';\n        memcpy(buf + path_len + 1, filename, filename_len);\n        buf[path_len + 1 + filename_len] = '\\0';\n        \n        execve(buf, argv, envp);\n\n        switch(errno) {\n        case EACCES:\n            eacces_error = TRUE;\n            break;\n        case ENOENT:\n        case ENOTDIR:\n            break;\n        default:\n            return -1;\n        }\n    }\n    if (eacces_error)\n        errno = EACCES;\n    return -1;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* waitpid(pid, block) -> [pid, status] */\n", "func_signal": "static JSValue js_os_waitpid(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)", "code": "{\n    int pid, status, options, ret;\n    JSValue obj;\n    \n    if (JS_ToInt32(ctx, &pid, argv[0]))\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &options, argv[1]))\n        return JS_EXCEPTION;\n\n    ret = waitpid(pid, &status, options);\n    if (ret < 0) {\n        ret = -errno;\n        status = 0;\n    }\n\n    obj = JS_NewArray(ctx);\n    if (JS_IsException(obj))\n        return obj;\n    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ret),\n                                 JS_PROP_C_W_E);\n    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, status),\n                                 JS_PROP_C_W_E);\n    return obj;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* USE_WORKER */\n", "func_signal": "void js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt))", "code": "{\n#ifdef USE_WORKER\n    js_worker_new_context_func = func;\n#endif\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* _WIN32 */\n", "func_signal": "static JSValue js_std_setenv(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)", "code": "{\n    const char *name, *value;\n    name = JS_ToCString(ctx, argv[0]);\n    if (!name)\n        return JS_EXCEPTION;\n    value = JS_ToCString(ctx, argv[1]);\n    if (!value) {\n        JS_FreeCString(ctx, name);\n        return JS_EXCEPTION;\n    }\n    setenv(name, value, TRUE);\n    JS_FreeCString(ctx, name);\n    JS_FreeCString(ctx, value);\n    return JS_UNDEFINED;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* find js files from the directory tree and sort the list */\n", "func_signal": "static void enumerate_tests(const char *path)", "code": "{\n    namelist_t *lp = &test_list;\n    int start = lp->count;\n    ftw(path, add_test_file, 100);\n    qsort(lp->array + start, lp->count - start, sizeof(*lp->array),\n          namelist_cmp_indirect);\n}", "path": "QuickJS/run-test262.c", "commit_date": "2020-09-08 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* XXX: could use less memory and go faster */\n", "func_signal": "static JSValue js_std_file_readAsString(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)", "code": "{\n    FILE *f = js_std_file_get(ctx, this_val);\n    int c;\n    DynBuf dbuf;\n    JSValue obj;\n    uint64_t max_size64;\n    size_t max_size;\n    JSValueConst max_size_val;\n    \n    if (!f)\n        return JS_EXCEPTION;\n\n    if (argc >= 1)\n        max_size_val = argv[0];\n    else\n        max_size_val = JS_UNDEFINED;\n    max_size = (size_t)-1;\n    if (!JS_IsUndefined(max_size_val)) {\n        if (JS_ToIndex(ctx, &max_size64, max_size_val))\n            return JS_EXCEPTION;\n        if (max_size64 < max_size)\n            max_size = max_size64;\n    }\n\n    js_std_dbuf_init(ctx, &dbuf);\n    while (max_size != 0) {\n        c = fgetc(f);\n        if (c == EOF)\n            break;\n        if (dbuf_putc(&dbuf, c)) {\n            dbuf_free(&dbuf);\n            return JS_EXCEPTION;\n        }\n        max_size--;\n    }\n    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);\n    dbuf_free(&dbuf);\n    return obj;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* load a file as a UTF-8 encoded string */\n", "func_signal": "static JSValue js_std_loadFile(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)", "code": "{\n    uint8_t *buf;\n    const char *filename;\n    JSValue ret;\n    size_t buf_len;\n    \n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        return JS_EXCEPTION;\n    buf = js_load_file(ctx, &buf_len, filename);\n    JS_FreeCString(ctx, filename);\n    if (!buf)\n        return JS_NULL;\n    ret = JS_NewStringLen(ctx, (char *)buf, buf_len);\n    js_free(ctx, buf);\n    return ret;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* sleep(delay_ms) */\n", "func_signal": "static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv)", "code": "{\n    int64_t delay;\n    struct timespec ts;\n    int ret;\n    \n    if (JS_ToInt64(ctx, &delay, argv[0]))\n        return JS_EXCEPTION;\n    ts.tv_sec = delay / 1000;\n    ts.tv_nsec = (delay % 1000) * 1000000;\n    ret = js_get_errno(nanosleep(&ts, NULL));\n    return JS_NewInt32(ctx, ret);\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* dup(fd) */\n", "func_signal": "static JSValue js_os_dup(JSContext *ctx, JSValueConst this_val,\n                         int argc, JSValueConst *argv)", "code": "{\n    int fd, ret;\n    \n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    ret = js_get_errno(dup(fd));\n    return JS_NewInt32(ctx, ret);\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/* XXX: could use less memory and go faster */\n", "func_signal": "static JSValue js_std_file_getline(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)", "code": "{\n    FILE *f = js_std_file_get(ctx, this_val);\n    int c;\n    DynBuf dbuf;\n    JSValue obj;\n    \n    if (!f)\n        return JS_EXCEPTION;\n\n    js_std_dbuf_init(ctx, &dbuf);\n    for(;;) {\n        c = fgetc(f);\n        if (c == EOF) {\n            if (dbuf.size == 0) {\n                /* EOF */\n                dbuf_free(&dbuf);\n                return JS_NULL;\n            } else {\n                break;\n            }\n        }\n        if (c == '\\n')\n            break;\n        if (dbuf_putc(&dbuf, c)) {\n            dbuf_free(&dbuf);\n            return JS_ThrowOutOfMemory(ctx);\n        }\n    }\n    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);\n    dbuf_free(&dbuf);\n    return obj;\n}", "path": "QuickJS/quickjs-libc.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "quickjs-zh/QuickJS", "stars": 2959, "license": "other", "language": "c", "size": 2941}
{"docstring": "/*\n * Functions\n */\n", "func_signal": "static void wg_reset_buffer(struct wg_callback *cb)", "code": "{\n  memset(cb->send_buf, 0, sizeof(cb->send_buf));\n  cb->send_buf_free = sizeof(cb->send_buf);\n  cb->send_buf_fill = 0;\n  cb->send_buf_init_time = cdtime();\n}", "path": "collectd/src/write_graphite.c", "commit_date": "2019-07-12 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* void *rrd_queue_thread */\n", "func_signal": "static int rrd_queue_enqueue(const char *filename, rrd_queue_t **head,\n                             rrd_queue_t **tail)", "code": "{\n  rrd_queue_t *queue_entry;\n\n  queue_entry = malloc(sizeof(*queue_entry));\n  if (queue_entry == NULL)\n    return -1;\n\n  queue_entry->filename = strdup(filename);\n  if (queue_entry->filename == NULL) {\n    free(queue_entry);\n    return -1;\n  }\n\n  queue_entry->next = NULL;\n\n  pthread_mutex_lock(&queue_lock);\n\n  if (*tail == NULL)\n    *head = queue_entry;\n  else\n    (*tail)->next = queue_entry;\n  *tail = queue_entry;\n\n  pthread_cond_signal(&queue_cond);\n  pthread_mutex_unlock(&queue_lock);\n\n  return 0;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* wg_force_reconnect_check closes cb->sock_fd when it was open for longer\n * than cb->reconnect_interval. Must hold cb->send_lock when calling. */\n", "func_signal": "static void wg_force_reconnect_check(struct wg_callback *cb)", "code": "{\n  cdtime_t now;\n\n  if (cb->reconnect_interval == 0)\n    return;\n\n  /* check if address changes if addr_timeout */\n  now = cdtime();\n  if ((now - cb->last_reconnect_time) < cb->reconnect_interval)\n    return;\n\n  /* here we should close connection on next */\n  close(cb->sock_fd);\n  cb->sock_fd = -1;\n  cb->last_reconnect_time = now;\n  cb->reconnect_interval_reached = true;\n\n  INFO(\"write_graphite plugin: Connection closed after %.3f seconds.\",\n       CDTIME_T_TO_DOUBLE(now - cb->last_reconnect_time));\n}", "path": "collectd/src/write_graphite.c", "commit_date": "2019-07-12 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int rrd_config */\n", "func_signal": "static int rrd_shutdown(void)", "code": "{\n  pthread_mutex_lock(&cache_lock);\n  rrd_cache_flush(0);\n  pthread_mutex_unlock(&cache_lock);\n\n  pthread_mutex_lock(&queue_lock);\n  do_shutdown = 1;\n  pthread_cond_signal(&queue_cond);\n  pthread_mutex_unlock(&queue_lock);\n\n  if ((queue_thread_running != 0) &&\n      ((queue_head != NULL) || (flushq_head != NULL))) {\n    INFO(\"rrdtool plugin: Shutting down the queue thread. \"\n         \"This may take a while.\");\n  } else if (queue_thread_running != 0) {\n    INFO(\"rrdtool plugin: Shutting down the queue thread.\");\n  }\n\n  /* Wait for all the values to be written to disk before returning. */\n  if (queue_thread_running != 0) {\n    pthread_join(queue_thread, NULL);\n    memset(&queue_thread, 0, sizeof(queue_thread));\n    queue_thread_running = 0;\n    DEBUG(\"rrdtool plugin: queue_thread exited.\");\n  }\n\n  rrd_cache_destroy();\n\n  return 0;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int rrd_cache_flush_identifier */\n", "func_signal": "static int64_t rrd_get_random_variation(void)", "code": "{\n  if (random_timeout == 0)\n    return 0;\n\n  return (int64_t)cdrand_range(-random_timeout, random_timeout);\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* NOTE: You must hold cb->send_lock when calling this function! */\n", "func_signal": "static int wg_flush_nolock(cdtime_t timeout, struct wg_callback *cb)", "code": "{\n  int status;\n\n  DEBUG(\"write_graphite plugin: wg_flush_nolock: timeout = %.3f; \"\n        \"send_buf_fill = %\" PRIsz \";\",\n        (double)timeout, cb->send_buf_fill);\n\n  /* timeout == 0  => flush unconditionally */\n  if (timeout > 0) {\n    cdtime_t now;\n\n    now = cdtime();\n    if ((cb->send_buf_init_time + timeout) > now)\n      return 0;\n  }\n\n  if (cb->send_buf_fill == 0) {\n    cb->send_buf_init_time = cdtime();\n    return 0;\n  }\n\n  status = wg_send_buffer(cb);\n  wg_reset_buffer(cb);\n\n  return status;\n}", "path": "collectd/src/write_graphite.c", "commit_date": "2019-07-12 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/*\n * NAME\n *   str_list_to_nums\n *\n * DESCRIPTION\n *   Converts string of characters representing list of numbers into array of\n *   numbers. Allowed formats are:\n *     0,1,2,3\n *     0-10,20-18\n *     1,3,5-8,10,0x10-12\n *\n *   Numbers can be in decimal or hexadecimal format.\n *\n * PARAMETERS\n *   `s'         String representing list of unsigned numbers.\n *   `nums'      Array to put converted numeric values into.\n *   `nums_len'  Maximum number of elements that nums can accommodate.\n *\n * RETURN VALUE\n *    Number of elements placed into nums.\n */\n", "func_signal": "static size_t str_list_to_nums(char *s, unsigned *nums, size_t nums_len)", "code": "{\n  char *saveptr = NULL;\n  char *token;\n  size_t idx = 0;\n\n  while ((token = strtok_r(s, \",\", &saveptr))) {\n    char *pos;\n    unsigned start, end = 0;\n    s = NULL;\n\n    while (isspace(*token))\n      token++;\n    if (*token == '\\0')\n      continue;\n\n    pos = strchr(token, '-');\n    if (pos) {\n      *pos = '\\0';\n    }\n\n    if (str_to_uint(token, &start))\n      return 0;\n\n    if (pos) {\n      if (str_to_uint(pos + 1, &end))\n        return 0;\n    } else {\n      end = start;\n    }\n\n    if (start > end) {\n      unsigned swap = start;\n      start = end;\n      end = swap;\n    }\n\n    for (unsigned i = start; i <= end; i++) {\n      if (is_in_list(i, nums, idx))\n        continue;\n      if (idx >= nums_len) {\n        WARNING(UTIL_NAME \": exceeded the cores number limit: %\" PRIsz,\n                nums_len);\n        return idx;\n      }\n      nums[idx] = i;\n      idx++;\n    }\n  }\n  return idx;\n}", "path": "collectd/src/utils/config_cores/config_cores.c", "commit_date": "2019-05-13 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* void *us_handle_client */\n", "func_signal": "static void *us_server_thread(void __attribute__((unused)) * arg)", "code": "{\n  int status;\n  int *remote_fd;\n  pthread_t th;\n\n  if (us_open_socket() != 0)\n    pthread_exit((void *)1);\n\n  while (loop != 0) {\n    DEBUG(\"unixsock plugin: Calling accept..\");\n    status = accept(sock_fd, NULL, NULL);\n    if (status < 0) {\n\n      if (errno == EINTR)\n        continue;\n\n      ERROR(\"unixsock plugin: accept failed: %s\", STRERRNO);\n      close(sock_fd);\n      sock_fd = -1;\n      pthread_exit((void *)1);\n    }\n\n    remote_fd = malloc(sizeof(*remote_fd));\n    if (remote_fd == NULL) {\n      WARNING(\"unixsock plugin: malloc failed: %s\", STRERRNO);\n      close(status);\n      continue;\n    }\n    *remote_fd = status;\n\n    DEBUG(\"Spawning child to handle connection on fd #%i\", *remote_fd);\n\n    status = plugin_thread_create(&th, us_handle_client, (void *)remote_fd,\n                                  \"unixsock conn\");\n    if (status == 0) {\n      pthread_detach(th);\n    } else {\n      WARNING(\"unixsock plugin: pthread_create failed: %s\", STRERRNO);\n      close(*remote_fd);\n      free(remote_fd);\n      continue;\n    }\n  } /* while (loop) */\n\n  close(sock_fd);\n  sock_fd = -1;\n\n  status = unlink((sock_file != NULL) ? sock_file : US_DEFAULT_PATH);\n  if (status != 0) {\n    NOTICE(\"unixsock plugin: unlink (%s) failed: %s\",\n           (sock_file != NULL) ? sock_file : US_DEFAULT_PATH, STRERRNO);\n  }\n\n  return (void *)0;\n}", "path": "collectd/src/unixsock.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int64_t rrd_get_random_variation */\n", "func_signal": "static int rrd_cache_insert(const char *filename, const char *value,\n                            cdtime_t value_time)", "code": "{\n  rrd_cache_t *rc = NULL;\n  int new_rc = 0;\n  char **values_new;\n\n  pthread_mutex_lock(&cache_lock);\n\n  /* This shouldn't happen, but it did happen at least once, so we'll be\n   * careful. */\n  if (cache == NULL) {\n    pthread_mutex_unlock(&cache_lock);\n    WARNING(\"rrdtool plugin: cache == NULL.\");\n    return -1;\n  }\n\n  int status = c_avl_get(cache, filename, (void *)&rc);\n  if ((status != 0) || (rc == NULL)) {\n    rc = malloc(sizeof(*rc));\n    if (rc == NULL) {\n      ERROR(\"rrdtool plugin: malloc failed: %s\", STRERRNO);\n      pthread_mutex_unlock(&cache_lock);\n      return -1;\n    }\n    rc->values_num = 0;\n    rc->values = NULL;\n    rc->first_value = 0;\n    rc->last_value = 0;\n    rc->random_variation = rrd_get_random_variation();\n    rc->flags = FLAG_NONE;\n    new_rc = 1;\n  }\n\n  assert(value_time > 0); /* plugin_dispatch() ensures this. */\n  if (rc->last_value >= value_time) {\n    pthread_mutex_unlock(&cache_lock);\n    DEBUG(\"rrdtool plugin: (rc->last_value = %\" PRIu64 \") \"\n          \">= (value_time = %\" PRIu64 \")\",\n          rc->last_value, value_time);\n    return -1;\n  }\n\n  values_new =\n      realloc((void *)rc->values, (rc->values_num + 1) * sizeof(char *));\n  if (values_new == NULL) {\n    void *cache_key = NULL;\n\n    c_avl_remove(cache, filename, &cache_key, NULL);\n    pthread_mutex_unlock(&cache_lock);\n\n    ERROR(\"rrdtool plugin: realloc failed: %s\", STRERRNO);\n\n    sfree(cache_key);\n    sfree(rc->values);\n    sfree(rc);\n    return -1;\n  }\n  rc->values = values_new;\n\n  rc->values[rc->values_num] = strdup(value);\n  if (rc->values[rc->values_num] != NULL)\n    rc->values_num++;\n\n  if (rc->values_num == 1)\n    rc->first_value = value_time;\n  rc->last_value = value_time;\n\n  /* Insert if this is the first value */\n  if (new_rc == 1) {\n    void *cache_key = strdup(filename);\n\n    if (cache_key == NULL) {\n      pthread_mutex_unlock(&cache_lock);\n\n      ERROR(\"rrdtool plugin: strdup failed: %s\", STRERRNO);\n\n      sfree(rc->values[0]);\n      sfree(rc->values);\n      sfree(rc);\n      return -1;\n    }\n\n    c_avl_insert(cache, cache_key, rc);\n  }\n\n  DEBUG(\"rrdtool plugin: rrd_cache_insert: file = %s; \"\n        \"values_num = %i; age = %.3f;\",\n        filename, rc->values_num,\n        CDTIME_T_TO_DOUBLE(rc->last_value - rc->first_value));\n\n  if ((rc->last_value - rc->first_value) >=\n      (cache_timeout + rc->random_variation)) {\n    /* XXX: If you need to lock both, cache_lock and queue_lock, at\n     * the same time, ALWAYS lock `cache_lock' first! */\n    if (rc->flags == FLAG_NONE) {\n      int status;\n\n      status = rrd_queue_enqueue(filename, &queue_head, &queue_tail);\n      if (status == 0)\n        rc->flags = FLAG_QUEUED;\n\n      rc->random_variation = rrd_get_random_variation();\n    } else {\n      DEBUG(\"rrdtool plugin: `%s' is already queued.\", filename);\n    }\n  }\n\n  if ((cache_timeout > 0) &&\n      ((cdtime() - cache_flush_last) > cache_flush_timeout))\n    rrd_cache_flush(cache_timeout + random_timeout);\n\n  pthread_mutex_unlock(&cache_lock);\n\n  return 0;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int ubi_read */\n", "func_signal": "void module_register(void)", "code": "{\n  plugin_register_config(PLUGIN_NAME, ubi_config, config_keys, config_keys_num);\n  plugin_register_read(PLUGIN_NAME, ubi_read);\n}", "path": "collectd/src/ubi.c", "commit_date": "2020-06-24 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int rrd_write */\n", "func_signal": "static int rrd_flush(cdtime_t timeout, const char *identifier,\n                     __attribute__((unused)) user_data_t *user_data)", "code": "{\n  pthread_mutex_lock(&cache_lock);\n\n  if (cache == NULL) {\n    pthread_mutex_unlock(&cache_lock);\n    return 0;\n  }\n\n  rrd_cache_flush_identifier(timeout, identifier);\n\n  pthread_mutex_unlock(&cache_lock);\n  return 0;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int value_list_to_string */\n", "func_signal": "static int value_list_to_filename(char *buffer, size_t buffer_size,\n                                  value_list_t const *vl)", "code": "{\n  char const suffix[] = \".rrd\";\n  int status;\n  size_t len;\n\n  if (datadir != NULL) {\n    size_t datadir_len = strlen(datadir) + 1;\n\n    if (datadir_len >= buffer_size)\n      return ENOMEM;\n\n    sstrncpy(buffer, datadir, buffer_size);\n    buffer[datadir_len - 1] = '/';\n    buffer[datadir_len] = 0;\n\n    buffer += datadir_len;\n    buffer_size -= datadir_len;\n  }\n\n  status = FORMAT_VL(buffer, buffer_size, vl);\n  if (status != 0)\n    return status;\n\n  len = strlen(buffer);\n  assert(len < buffer_size);\n  buffer += len;\n  buffer_size -= len;\n\n  if (buffer_size <= sizeof(suffix))\n    return ENOMEM;\n\n  memcpy(buffer, suffix, sizeof(suffix));\n  return 0;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int wg_write_messages */\n", "func_signal": "static int wg_write(const data_set_t *ds, const value_list_t *vl,\n                    user_data_t *user_data)", "code": "{\n  struct wg_callback *cb;\n  int status;\n\n  if (user_data == NULL)\n    return EINVAL;\n\n  cb = user_data->data;\n\n  status = wg_write_messages(ds, vl, cb);\n\n  return status;\n}", "path": "collectd/src/write_graphite.c", "commit_date": "2019-07-12 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* !HAVE_THREADSAFE_LIBRRD */\n", "func_signal": "static int srrd_update(char *filename, char *template, int argc,\n                       const char **argv)", "code": "{\n  int status;\n\n  int new_argc;\n  char **new_argv;\n\n  assert(template == NULL);\n\n  new_argc = 2 + argc;\n  new_argv = malloc((new_argc + 1) * sizeof(*new_argv));\n  if (new_argv == NULL) {\n    ERROR(\"rrdtool plugin: malloc failed.\");\n    return -1;\n  }\n\n  new_argv[0] = \"update\";\n  new_argv[1] = filename;\n\n  memcpy(new_argv + 2, argv, argc * sizeof(char *));\n  new_argv[new_argc] = NULL;\n\n  pthread_mutex_lock(&librrd_lock);\n  optind = 0; /* bug in librrd? */\n  rrd_clear_error();\n\n  status = rrd_update(new_argc, new_argv);\n  pthread_mutex_unlock(&librrd_lock);\n\n  if (status != 0) {\n    WARNING(\"rrdtool plugin: rrd_update_r failed: %s: %s\", filename,\n            rrd_get_error());\n  }\n\n  sfree(new_argv);\n\n  return status;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* void ubi_submit */\n", "func_signal": "static int ubi_read_dev_attr(const char *dev_name, const char *attr)", "code": "{\n  FILE *f;\n  int val;\n  char\n      str[sizeof(SYS_PATH) + strlen(dev_name) + sizeof(\"/\") + strlen(attr) + 1];\n  int n;\n\n  snprintf(str, sizeof(str), SYS_PATH \"%s/%s\", dev_name, attr);\n\n  if ((f = fopen(str, \"r\")) == NULL) {\n    ERROR(PLUGIN_NAME \": cannot open [%s]\", str);\n    return -1;\n  }\n\n  n = fscanf(f, \"%d\", &val);\n  fclose(f);\n\n  if (n != 1) {\n    ERROR(PLUGIN_NAME \" : did not find an integer in %s\", str);\n    return -1;\n  }\n\n  ubi_submit(dev_name, attr, (gauge_t)val);\n\n  return 0;\n}", "path": "collectd/src/ubi.c", "commit_date": "2020-06-24 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int us_config */\n", "func_signal": "static int us_init(void)", "code": "{\n  static int have_init;\n\n  int status;\n\n  /* Initialize only once. */\n  if (have_init != 0)\n    return 0;\n  have_init = 1;\n\n  loop = 1;\n\n  status = plugin_thread_create(&listen_thread, us_server_thread, NULL,\n                                \"unixsock listen\");\n  if (status != 0) {\n    ERROR(\"unixsock plugin: pthread_create failed: %s\", STRERRNO);\n    return -1;\n  }\n\n  return 0;\n}", "path": "collectd/src/unixsock.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* XXX: You must hold \"cache_lock\" when calling this function! */\n", "func_signal": "static void rrd_cache_flush(cdtime_t timeout)", "code": "{\n  rrd_cache_t *rc;\n  cdtime_t now;\n\n  char **keys = NULL;\n  int keys_num = 0;\n\n  char *key;\n  c_avl_iterator_t *iter;\n\n  DEBUG(\"rrdtool plugin: Flushing cache, timeout = %.3f\",\n        CDTIME_T_TO_DOUBLE(timeout));\n\n  now = cdtime();\n\n  /* Build a list of entries to be flushed */\n  iter = c_avl_get_iterator(cache);\n  while (c_avl_iterator_next(iter, (void *)&key, (void *)&rc) == 0) {\n    if (rc->flags != FLAG_NONE)\n      continue;\n    /* timeout == 0  =>  flush everything */\n    else if ((timeout != 0) && ((now - rc->first_value) < timeout))\n      continue;\n    else if (rc->values_num > 0) {\n      int status;\n\n      status = rrd_queue_enqueue(key, &queue_head, &queue_tail);\n      if (status == 0)\n        rc->flags = FLAG_QUEUED;\n    } else /* ancient and no values -> waste of memory */\n    {\n      char **tmp = realloc(keys, (keys_num + 1) * sizeof(char *));\n      if (tmp == NULL) {\n        ERROR(\"rrdtool plugin: realloc failed: %s\", STRERRNO);\n        c_avl_iterator_destroy(iter);\n        sfree(keys);\n        return;\n      }\n      keys = tmp;\n      keys[keys_num] = key;\n      keys_num++;\n    }\n  } /* while (c_avl_iterator_next) */\n  c_avl_iterator_destroy(iter);\n\n  for (int i = 0; i < keys_num; i++) {\n    if (c_avl_remove(cache, keys[i], (void *)&key, (void *)&rc) != 0) {\n      DEBUG(\"rrdtool plugin: c_avl_remove (%s) failed.\", keys[i]);\n      continue;\n    }\n\n    assert(rc->values == NULL);\n    assert(rc->values_num == 0);\n\n    sfree(rc);\n    sfree(key);\n    keys[i] = NULL;\n  } /* for (i = 0..keys_num) */\n\n  sfree(keys);\n\n  cache_flush_last = now;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int value_list_to_filename */\n", "func_signal": "static void *rrd_queue_thread(void __attribute__((unused)) * data)", "code": "{\n  struct timeval tv_next_update;\n  struct timeval tv_now;\n\n  gettimeofday(&tv_next_update, /* timezone = */ NULL);\n\n  while (42) {\n    rrd_queue_t *queue_entry;\n    rrd_cache_t *cache_entry;\n    char **values;\n    int values_num;\n    int status;\n\n    values = NULL;\n    values_num = 0;\n\n    pthread_mutex_lock(&queue_lock);\n    /* Wait for values to arrive */\n    while (42) {\n      struct timespec ts_wait;\n\n      while ((flushq_head == NULL) && (queue_head == NULL) &&\n             (do_shutdown == 0))\n        pthread_cond_wait(&queue_cond, &queue_lock);\n\n      if ((flushq_head == NULL) && (queue_head == NULL))\n        break;\n\n      /* Don't delay if there's something to flush */\n      if (flushq_head != NULL)\n        break;\n\n      /* Don't delay if we're shutting down */\n      if (do_shutdown != 0)\n        break;\n\n      /* Don't delay if no delay was configured. */\n      if (write_rate <= 0.0)\n        break;\n\n      gettimeofday(&tv_now, /* timezone = */ NULL);\n      status = timeval_cmp(tv_next_update, tv_now, NULL);\n      /* We're good to go */\n      if (status <= 0)\n        break;\n\n      /* We're supposed to wait a bit with this update, so we'll\n       * wait for the next addition to the queue or to the end of\n       * the wait period - whichever comes first. */\n      ts_wait.tv_sec = tv_next_update.tv_sec;\n      ts_wait.tv_nsec = 1000 * tv_next_update.tv_usec;\n\n      status = pthread_cond_timedwait(&queue_cond, &queue_lock, &ts_wait);\n      if (status == ETIMEDOUT)\n        break;\n    } /* while (42) */\n\n    /* XXX: If you need to lock both, cache_lock and queue_lock, at\n     * the same time, ALWAYS lock `cache_lock' first! */\n\n    /* We're in the shutdown phase */\n    if ((flushq_head == NULL) && (queue_head == NULL)) {\n      pthread_mutex_unlock(&queue_lock);\n      break;\n    }\n\n    if (flushq_head != NULL) {\n      /* Dequeue the first flush entry */\n      queue_entry = flushq_head;\n      if (flushq_head == flushq_tail)\n        flushq_head = flushq_tail = NULL;\n      else\n        flushq_head = flushq_head->next;\n    } else /* if (queue_head != NULL) */\n    {\n      /* Dequeue the first regular entry */\n      queue_entry = queue_head;\n      if (queue_head == queue_tail)\n        queue_head = queue_tail = NULL;\n      else\n        queue_head = queue_head->next;\n    }\n\n    /* Unlock the queue again */\n    pthread_mutex_unlock(&queue_lock);\n\n    /* We now need the cache lock so the entry isn't updated while\n     * we make a copy of its values */\n    pthread_mutex_lock(&cache_lock);\n\n    status = c_avl_get(cache, queue_entry->filename, (void *)&cache_entry);\n\n    if (status == 0) {\n      values = cache_entry->values;\n      values_num = cache_entry->values_num;\n\n      cache_entry->values = NULL;\n      cache_entry->values_num = 0;\n      cache_entry->flags = FLAG_NONE;\n    }\n\n    pthread_mutex_unlock(&cache_lock);\n\n    if (status != 0) {\n      sfree(queue_entry->filename);\n      sfree(queue_entry);\n      continue;\n    }\n\n    /* Update `tv_next_update' */\n    if (write_rate > 0.0) {\n      gettimeofday(&tv_now, /* timezone = */ NULL);\n      tv_next_update.tv_sec = tv_now.tv_sec;\n      tv_next_update.tv_usec =\n          tv_now.tv_usec + ((suseconds_t)(1000000 * write_rate));\n      while (tv_next_update.tv_usec > 1000000) {\n        tv_next_update.tv_sec++;\n        tv_next_update.tv_usec -= 1000000;\n      }\n    }\n\n    /* Write the values to the RRD-file */\n    srrd_update(queue_entry->filename, NULL, values_num, (const char **)values);\n    DEBUG(\"rrdtool plugin: queue thread: Wrote %i value%s to %s\", values_num,\n          (values_num == 1) ? \"\" : \"s\", queue_entry->filename);\n\n    for (int i = 0; i < values_num; i++) {\n      sfree(values[i]);\n    }\n    sfree(values);\n    sfree(queue_entry->filename);\n    sfree(queue_entry);\n  } /* while (42) */\n\n  pthread_exit((void *)0);\n  return (void *)0;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int rrd_queue_enqueue */\n", "func_signal": "static int rrd_queue_dequeue(const char *filename, rrd_queue_t **head,\n                             rrd_queue_t **tail)", "code": "{\n  rrd_queue_t *this;\n  rrd_queue_t *prev;\n\n  pthread_mutex_lock(&queue_lock);\n\n  prev = NULL;\n  this = *head;\n\n  while (this != NULL) {\n    if (strcmp(this->filename, filename) == 0)\n      break;\n\n    prev = this;\n    this = this->next;\n  }\n\n  if (this == NULL) {\n    pthread_mutex_unlock(&queue_lock);\n    return -1;\n  }\n\n  if (prev == NULL)\n    *head = this->next;\n  else\n    prev->next = this->next;\n\n  if (this->next == NULL)\n    *tail = prev;\n\n  pthread_mutex_unlock(&queue_lock);\n\n  sfree(this->filename);\n  sfree(this);\n\n  return 0;\n}", "path": "collectd/src/rrdtool.c", "commit_date": "2019-10-03 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* int ubi_config */\n", "func_signal": "static void ubi_submit(const char *dev_name, const char *type, gauge_t value)", "code": "{\n  value_list_t vl = VALUE_LIST_INIT;\n\n  if (ignorelist_match(ignorelist, dev_name) != 0)\n    return;\n\n  vl.values = &(value_t){.gauge = value};\n  vl.values_len = 1;\n  sstrncpy(vl.plugin, PLUGIN_NAME, sizeof(vl.plugin));\n  sstrncpy(vl.type_instance, dev_name, sizeof(vl.type_instance));\n  sstrncpy(vl.type, type, sizeof(vl.type));\n\n  plugin_dispatch_values(&vl);\n}", "path": "collectd/src/ubi.c", "commit_date": "2020-06-24 00:00:00", "repo_name": "collectd/collectd", "stars": 2955, "license": "other", "language": "c", "size": 28927}
{"docstring": "/* Part of the infamous wget-like interface. Just put it in a function\n\tbecause I need it quite often.. */\n", "func_signal": "void\nprint_commas(off_t bytes_done)", "code": "{\n\tint i, j;\n\n\tprintf(\"       \");\n\tj = (bytes_done / 1024) % 50;\n\tif (j == 0)\n\t\tj = 50;\n\tfor (i = 0; i < j; i++) {\n\t\tif ((i % 10) == 0)\n\t\t\tputchar(' ');\n\t\tputchar(',');\n\t}\n}", "path": "axel/src/text.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Simple... */\n", "func_signal": "void\nconn_disconnect(conn_t *conn)", "code": "{\n\tif (PROTO_IS_FTP(conn->proto) && !conn->proxy)\n\t\tftp_disconnect(conn->ftp);\n\telse\n\t\thttp_disconnect(conn->http);\n\tconn->tcp = NULL;\n\tconn->enabled = false;\n}", "path": "axel/src/conn.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Read status from server. Should handle multi-line replies correctly.\n   Multi-line replies suck... */\n", "func_signal": "int\nftp_wait(ftp_t *conn)", "code": "{\n\tint size = MAX_STRING, r = 0, complete, i, j;\n\tchar *s;\n\n\t{\n\t\tvoid *new_msg = realloc(conn->message, size);\n\t\tif (!new_msg)\n\t\t\treturn -1;\n\t\tconn->message = new_msg;\n\t}\n\tdo {\n\t\tdo {\n\t\t\tr += i = tcp_read(&conn->tcp, conn->message + r, 1);\n\t\t\tif (i <= 0) {\n\t\t\t\tfprintf(stderr, _(\"Connection gone.\\n\"));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((r + 10) >= size) {\n\t\t\t\tsize += MAX_STRING;\n\t\t\t\tvoid *new_msg = realloc(conn->message, size);\n\t\t\t\tif (!new_msg)\n\t\t\t\t\treturn -1;\n\t\t\t\tconn->message = new_msg;\n\t\t\t}\n\t\t}\n\t\twhile (conn->message[r - 1] != '\\n');\n\t\tconn->message[r] = 0;\n\t\tsscanf(conn->message, \"%i\", &conn->status);\n\t\tif (conn->message[3] == ' ')\n\t\t\tcomplete = 1;\n\t\telse\n\t\t\tcomplete = 0;\n\n\t\tfor (i = 0; conn->message[i]; i++)\n\t\t\tif (conn->message[i] == '\\n') {\n\t\t\t\tif (complete == 1) {\n\t\t\t\t\tcomplete = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (conn->message[i + 4] == ' ') {\n\t\t\t\t\tj = -1;\n\t\t\t\t\tsscanf(&conn->message[i + 1], \"%3i\",\n\t\t\t\t\t       &j);\n\t\t\t\t\tif (j == conn->status)\n\t\t\t\t\t\tcomplete = 1;\n\t\t\t\t}\n\t\t\t}\n\t}\n\twhile (complete != 2);\n\n#ifndef NDEBUG\n\tfprintf(stderr, \"fd(%i)-->%s\", conn->tcp.fd, conn->message);\n#endif\n\n\tint k = strcspn(conn->message, \"\\r\\n\");\n\tconn->message[k] = 0;\n\tconn->message = realloc(conn->message, k + 1);\n\treturn conn->status;\n}", "path": "axel/src/ftp.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/*\n * Check if the given hostname is ipv6 literal\n * Returns 1 if true and 0 if false\n */\n", "func_signal": "int is_ipv6_addr(const char *hostname)", "code": "{\n\tchar buf[16]; /* Max buff size needed for inet_pton() */\n\n\treturn hostname && 1 == inet_pton(AF_INET6, hostname, buf);\n}", "path": "axel/src/tcp.c", "commit_date": "2020-03-28 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/**\n * Setup the connection.\n *\n * Must be called with the conn_t lock held.\n */\n", "func_signal": "int\nconn_setup(conn_t *conn)", "code": "{\n\tif (conn->ftp->tcp.fd <= 0 && conn->http->tcp.fd <= 0)\n\t\tif (!conn_init(conn))\n\t\t\treturn 0;\n\n\tif (PROTO_IS_FTP(conn->proto) && !conn->proxy) {\n\t\t/* Set up data connnection */\n\t\tif (!ftp_data(conn->ftp, conn->conf->io_timeout))\n\t\t\treturn 0;\n\t\tconn->tcp = &conn->ftp->data_tcp;\n\n\t\tif (conn->currentbyte) {\n\t\t\tftp_command(conn->ftp, \"REST %jd\", conn->currentbyte);\n\t\t\tif (ftp_wait(conn->ftp) / 100 != 3 &&\n\t\t\t    conn->ftp->status / 100 != 2)\n\t\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tchar s[MAX_STRING * 2];\n\t\tint i;\n\n\t\tsnprintf(s, sizeof(s), \"%s%s\", conn->dir, conn->file);\n\t\tconn->http->firstbyte =\n\t\t\tconn->supported ? conn->currentbyte : -1;\n\t\tconn->http->lastbyte = conn->lastbyte;\n\n\t\tabuf_setup(conn->http->request, 2048);\n\t\thttp_get(conn->http, s);\n\t\tfor (i = 0; i < conn->conf->add_header_count; i++)\n\t\t\thttp_addheader(conn->http, \"%s\",\n\t\t\t\t       conn->conf->add_header[i]);\n\t}\n\treturn 1;\n}", "path": "axel/src/conn.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Generate a nice URL string. */\n", "func_signal": "char *\nconn_url(char *dst, size_t len, conn_t *conn)", "code": "{\n\tconst char *prefix = \"\", *postfix = \"\";\n\n\tconst char *scheme = scheme_from_proto(conn->proto);\n\n\tsize_t scheme_len = strlcpy(dst, scheme, len);\n\tif (scheme_len > len)\n\t\treturn NULL;\n\n\tlen -= scheme_len;\n\n\tchar *p = dst + scheme_len;\n\n\tif (*conn->user != 0 && strcmp(conn->user, \"anonymous\") != 0) {\n\t\tint plen = snprintf(p, len, \"%s:%s@\", conn->user, conn->pass);\n\t\tif (plen < 0)\n\t\t\treturn NULL;\n\t\tlen -= plen;\n\t\tp += plen;\n\t}\n\n\tif (is_ipv6_addr(conn->host)) {\n\t\tprefix = \"[\";\n\t\tpostfix = \"]\";\n\t}\n\n\tint plen;\n\tplen = snprintf(p, len, \"%s%s%s:%i%s%s\", prefix, conn->host, postfix,\n\t\t\tconn->port, conn->dir, conn->file);\n\n\treturn plen < 0 ? NULL : dst;\n}", "path": "axel/src/conn.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Open a data connection. Only Passive mode supported yet, easier.. */\n", "func_signal": "int\nftp_data(ftp_t *conn, unsigned io_timeout)", "code": "{\n\tint i, info[6];\n\tchar host[MAX_STRING];\n\n\t/* Already done? */\n\tif (conn->data_tcp.fd > 0)\n\t\treturn 0;\n\n/*\tif (conn->ftp_mode == FTP_PASSIVE)\n\t{\n*/\n\tftp_command(conn, \"PASV\");\n\tif (ftp_wait(conn) / 100 != 2)\n\t\treturn 0;\n\t*host = 0;\n\tfor (i = 0; conn->message[i]; i++) {\n\t\tif (sscanf(&conn->message[i], \"%i,%i,%i,%i,%i,%i\",\n\t\t\t   &info[0], &info[1], &info[2], &info[3],\n\t\t\t   &info[4], &info[5]) == 6) {\n\t\t\tsnprintf(host, sizeof(host), \"%i.%i.%i.%i\",\n\t\t\t\t info[0], info[1], info[2], info[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!*host) {\n\t\tfprintf(stderr,\n\t\t\t_(\"Error opening passive data connection.\\n\"));\n\t\treturn 0;\n\t}\n\tif (tcp_connect(&conn->data_tcp, host, info[4] * 256 + info[5],\n\t\t\tPROTO_IS_SECURE(conn->proto), conn->local_if,\n\t\t\tio_timeout) == -1)\n\t\treturn 0;\n\n\treturn 1;\n/*\t}\n\telse\n\t{\n\t\tfprintf(stderr, _(\"Active FTP not implemented yet.\\n\"));\n\t\treturn 0;\n\t} */\n}", "path": "axel/src/ftp.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* SIGINT/SIGTERM handler */\n", "func_signal": "RETSIGTYPE\nstop(int signal)", "code": "{\n\t(void)signal;\n\trun = 0;\n}", "path": "axel/src/text.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Convert a number of seconds to a human-readable form */\n", "func_signal": "char *\ntime_human(char *dst, size_t len, unsigned int value)", "code": "{\n\tunsigned int hh, mm, ss;\n\n\tss = value % 60;\n\tmm = value / 60 % 60;\n\thh = value / 3600;\n\n\tint ret;\n\tif (hh)\n\t\tret = snprintf(dst, len, _(\"%i:%02i:%02i hour(s)\"), hh, mm, ss);\n\telse if (mm)\n\t\tret = snprintf(dst, len, _(\"%i:%02i minute(s)\"), mm, ss);\n\telse\n\t\tret = snprintf(dst, len, _(\"%i second(s)\"), ss);\n\n\treturn ret < 0 ? NULL : dst;\n}", "path": "axel/src/text.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* __GNUC__ */\n", "func_signal": "static int\naxel_fscanf(FILE *fp, const char *format, ...)", "code": "{\n\tva_list params;\n\tint ret;\n\n\tva_start(params, format);\n\tret = vfscanf(fp, format, params);\n\tva_end(params);\n\n\tret = !(ret == EOF && ferror(fp));\n\tif (!ret) {\n\t\tfprintf(stderr, _(\"I/O error while reading config file: %s\\n\"),\n\t\t\tstrerror(errno));\n\t}\n\n\treturn ret;\n}", "path": "axel/src/conf.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/**\n * The infamous wget-like 'interface'.. ;)\n */\n", "func_signal": "static\nvoid\nprint_progress(off_t cur, off_t prev, off_t total, double kbps)", "code": "{\n\tprev /= 1024;\n\tcur /= 1024;\n\n\tbool print_speed = prev > 0;\n\tfor (off_t i = prev; i < cur; i++) {\n\t\tif (i % 50 == 0) {\n\t\t\tif (print_speed)\n\t\t\t\tprintf(\"  [%6.1fKB/s]\", kbps);\n\n\t\t\tif (total == LLONG_MAX)\n\t\t\t\tprintf(\"\\n[ N/A]  \");\n\t\t\telse\n\t\t\t\tprintf(\"\\n[%3jd%%]  \",\n\t\t\t\t       min(100U, 102400 * i / total));\n\t\t} else if (i % 10 == 0) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tputchar('.');\n\t}\n}", "path": "axel/src/text.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Print any message in the axel structure */\n", "func_signal": "void\nprint_messages(axel_t *axel)", "code": "{\n\tmessage_t *m;\n\n\tif (!axel)\n\t\treturn;\n\n\twhile ((m = axel->message)) {\n\t\tprintf(\"%s\\n\", m->text);\n\t\taxel->message = m->next;\n\t\tfree(m);\n\t}\n}", "path": "axel/src/text.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/**\n * Convert an URL to a conn_t structure.\n */\n", "func_signal": "int\nconn_set(conn_t *conn, const char *set_url)", "code": "{\n\tchar url[MAX_STRING];\n\tchar *i, *j;\n\n\t/* protocol:// */\n\tif ((i = strstr(set_url, \"://\")) == NULL) {\n\t\tconn->proto = PROTO_DEFAULT;\n\t\tconn->port = PROTO_DEFAULT_PORT;\n\t\tstrlcpy(url, set_url, sizeof(url));\n\t} else {\n\t\tint proto_len = i - set_url;\n\t\tif (strncmp(set_url, \"ftp\", proto_len) == 0) {\n\t\t\tconn->proto = PROTO_FTP;\n\t\t\tconn->port = PROTO_FTP_PORT;\n\t\t} else if (strncmp(set_url, \"http\", proto_len) == 0) {\n\t\t\tconn->proto = PROTO_HTTP;\n\t\t\tconn->port = PROTO_HTTP_PORT;\n\t\t} else if (strncmp(set_url, \"ftps\", proto_len) == 0) {\n\t\t\tconn->proto = PROTO_FTPS;\n\t\t\tconn->port = PROTO_FTPS_PORT;\n\t\t} else if (strncmp(set_url, \"https\", proto_len) == 0) {\n\t\t\tconn->proto = PROTO_HTTPS;\n\t\t\tconn->port = PROTO_HTTPS_PORT;\n\t\t} else {\n\t\t\tfprintf(stderr, _(\"Unsupported protocol\\n\"));\n\t\t\treturn 0;\n\t\t}\n#ifndef HAVE_SSL\n               if (PROTO_IS_SECURE(conn->proto)) {\n                       fprintf(stderr,\n                               _(\"Secure protocol is not supported\\n\"));\n                       return 0;\n               }\n#endif\n\t\tstrlcpy(url, i + 3, sizeof(url));\n\t}\n\n\t/* Split */\n\tif ((i = strchr(url, '/')) == NULL) {\n\t\tstrcpy(conn->dir, \"/\");\n\t} else {\n\t\t*i = 0;\n\t\tsnprintf(conn->dir, MAX_STRING, \"/%s\", i + 1);\n\t\tif (conn->proto == PROTO_HTTP || conn->proto == PROTO_HTTPS)\n\t\t\thttp_encode(conn->dir, sizeof(conn->dir));\n\t}\n\tj = strchr(conn->dir, '?');\n\tif (j != NULL)\n\t\t*j = 0;\n\ti = strrchr(conn->dir, '/');\n\tif (i != NULL)\n\t\t*i = 0;\n\n\tif (j != NULL)\n\t\t*j = '?';\n\tif (i == NULL) {\n\t\tstrlcpy(conn->file, conn->dir, sizeof(conn->file));\n\t\tstrcpy(conn->dir, \"/\");\n\t} else {\n\t\tstrlcpy(conn->file, i + 1, sizeof(conn->file));\n\t\tstrlcat(conn->dir, \"/\", sizeof(conn->dir));\n\t}\n\n\t/* Check for username in host field */\n\t// FIXME: optimize\n\tif (strrchr(url, '@') != NULL) {\n\t\tstrlcpy(conn->user, url, sizeof(conn->user));\n\t\ti = strrchr(conn->user, '@');\n\t\t*i = 0;\n\t\tstrlcpy(url, i + 1, sizeof(url));\n\t\t*conn->pass = 0;\n\t} else {\n\t\t/* If not: Fill in defaults */\n\t\tif (PROTO_IS_FTP(conn->proto)) {\n\t\t\t/* Dash the password: Save traffic by trying\n\t\t\t   to avoid multi-line responses */\n\t\t\tstrcpy(conn->user, \"anonymous\");\n\t\t\tstrcpy(conn->pass, \"mailto:axel@axel.project\");\n\t\t} else {\n\t\t\t*conn->user = *conn->pass = 0;\n\t\t}\n\t}\n\n\t/* Password? */\n\tif ((i = strchr(conn->user, ':')) != NULL) {\n\t\t*i = 0;\n\t\tstrlcpy(conn->pass, i + 1, sizeof(conn->pass));\n\t}\n\n\t// Look for IPv6 literal hostname\n\tif (*url == '[') {\n\t\tstrlcpy(conn->host, url + 1, sizeof(conn->host));\n\t\tif ((i = strrchr(conn->host, ']')) != NULL) {\n\t\t\t*i++ = 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tstrlcpy(conn->host, url, sizeof(conn->host));\n\t\ti = conn->host;\n\t\twhile (*i && *i != ':') {\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* Port number? */\n\tif (*i == ':') {\n\t\t*i = 0;\n\t\tsscanf(i + 1, \"%i\", &conn->port);\n\t\ti = conn->host;\n\t}\n\n\treturn conn->port > 0;\n}", "path": "axel/src/conn.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Get file size. Should work with all reasonable servers now */\n", "func_signal": "off_t\nftp_size(ftp_t *conn, char *file, int maxredir, unsigned io_timeout)", "code": "{\n\toff_t i, j, size = MAX_STRING;\n\tchar *reply, *s, fn[MAX_STRING];\n\n\t/* Try the SIZE command first, if possible */\n\tif (!strchr(file, '*') && !strchr(file, '?')) {\n\t\tftp_command(conn, \"SIZE %s\", file);\n\t\tif (ftp_wait(conn) / 100 == 2) {\n\t\t\tsscanf(conn->message, \"%*i %jd\", &i);\n\t\t\treturn i;\n\t\t} else if (conn->status / 10 != 50) {\n\t\t\tfprintf(stderr, _(\"File not found.\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (maxredir == 0) {\n\t\tfprintf(stderr, _(\"Too many redirects.\\n\"));\n\t\treturn -1;\n\t}\n\n\tif (!ftp_data(conn, io_timeout))\n\t\treturn -1;\n\n\tftp_command(conn, \"LIST %s\", file);\n\tif (ftp_wait(conn) / 100 != 1)\n\t\treturn -1;\n\n\t/* Read reply from the server. */\n\treply = calloc(1, size);\n\tif (!reply)\n\t\treturn -1;\n\n\t*reply = '\\n';\n\ti = 1;\n\twhile ((j = tcp_read(&conn->data_tcp, reply + i, size - i - 3)) > 0) {\n\t\ti += j;\n\t\treply[i] = 0;\n\t\tif (size - i <= 10) {\n\t\t\tsize *= 2;\n\t\t\tchar *tmp = realloc(reply, size);\n\t\t\tif (!tmp) {\n\t\t\t\tfree(reply);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treply = tmp;\n\t\t\tmemset(reply + size / 2, 0, size / 2);\n\t\t}\n\t}\n\ttcp_close(&conn->data_tcp);\n\n\tif (ftp_wait(conn) / 100 != 2) {\n\t\tfree(reply);\n\t\treturn -1;\n\t}\n#ifndef NDEBUG\n\tfprintf(stderr, \"%s\", reply);\n#endif\n\n\t/* Count the number of probably legal matches: Files&Links only */\n\tj = 0;\n\tfor (i = 1; reply[i] && reply[i + 1]; i++)\n\t\tif (reply[i] == '-' || reply[i] == 'l')\n\t\t\tj++;\n\t\telse\n\t\t\twhile (reply[i] != '\\n' && reply[i])\n\t\t\t\ti++;\n\n\t/* No match or more than one match */\n\tif (j != 1) {\n\t\tif (j == 0)\n\t\t\tfprintf(stderr, _(\"File not found.\\n\"));\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Multiple matches for this URL.\\n\"));\n\t\tfree(reply);\n\t\treturn -1;\n\t}\n\n\t/* Symlink handling */\n\tif ((s = strstr(reply, \"\\nl\")) != NULL) {\n\t\t/* Get the real filename */\n\t\tsscanf(s, \"%*s %*i %*s %*s %*i %*s %*i %*s %100s\", fn);\n\t\t// FIXME: replace by strlcpy\n\t\tstrcpy(file, fn);\n\n\t\t/* Get size of the file linked to */\n\t\tstrlcpy(fn, strstr(s, \"->\") + 3, sizeof(fn));\n\t\tfn[sizeof(fn) - 1] = '\\0';\n\t\tfree(reply);\n\t\tif ((reply = strchr(fn, '\\r')) != NULL)\n\t\t\t*reply = 0;\n\t\tif ((reply = strchr(fn, '\\n')) != NULL)\n\t\t\t*reply = 0;\n\t\treturn ftp_size(conn, fn, maxredir - 1, io_timeout);\n\t}\n\t/* Normal file, so read the size! And read filename because of\n\t   possible wildcards. */\n\telse {\n\t\ts = strstr(reply, \"\\n-\");\n\t\ti = sscanf(s, \"%*s %*i %*s %*s %jd %*s %*i %*s %100s\", &size,\n\t\t\t   fn);\n\t\tif (i < 2) {\n\t\t\ti = sscanf(s, \"%*s %*i %jd %*i %*s %*i %*i %100s\",\n\t\t\t\t   &size, fn);\n\t\t\tif (i < 2) {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\t\t// FIXME: replace by strlcpy\n\t\tstrcpy(file, fn);\n\n\t\tfree(reply);\n\t\treturn size;\n\t}\n}", "path": "axel/src/ftp.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Convert a number of bytes to a human-readable form */\n", "func_signal": "char *\naxel_size_human(char *dst, size_t len, size_t value)", "code": "{\n\tdouble fval = (double)value;\n\tconst char * const oname[] = {\n\t\t\"\", _(\"Kilo\"), _(\"Mega\"), _(\"Giga\"), _(\"Tera\"),\n\t};\n\tconst unsigned int order = min(sizeof(oname) / sizeof(oname[0]) - 1,\n\t\t\t\t       log2i(fval) / 10);\n\n\tfval /= (double)(1 << order * 10);\n\tint ret = snprintf(dst, len, _(\"%g %sbyte(s)\"), fval, oname[order]);\n\treturn ret < 0 ? NULL : dst;\n}", "path": "axel/src/text.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Send a command to the server */\n", "func_signal": "int\nftp_command(ftp_t *conn, const char *format, ...)", "code": "{\n\tva_list params;\n\tchar cmd[MAX_STRING];\n\n\tva_start(params, format);\n\tvsnprintf(cmd, sizeof(cmd) - 3, format, params);\n\tstrlcat(cmd, \"\\r\\n\", sizeof(cmd));\n\tva_end(params);\n\n#ifndef NDEBUG\n\tfprintf(stderr, \"fd(%i)<--%s\", conn->tcp.fd, cmd);\n#endif\n\n\tif (tcp_write(&conn->tcp, cmd, strlen(cmd)) != (ssize_t)strlen(cmd)) {\n\t\tfprintf(stderr, _(\"Error writing command %s\\n\"), cmd);\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}", "path": "axel/src/ftp.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Get a TCP connection */\n", "func_signal": "int\ntcp_connect(tcp_t *tcp, char *hostname, int port, int secure, char *local_if,\n\t    unsigned io_timeout)", "code": "{\n\tstruct sockaddr_in local_addr;\n\tchar portstr[10];\n\tstruct addrinfo ai_hints;\n\tstruct addrinfo *gai_results, *gai_result;\n\tint ret;\n\tint sock_fd = -1;\n\n\tmemset(&local_addr, 0, sizeof(local_addr));\n\tif (local_if) {\n\t\tif (!*local_if || tcp->ai_family != AF_INET) {\n\t\t\tlocal_if = NULL;\n\t\t} else {\n\t\t\tlocal_addr.sin_family = AF_INET;\n\t\t\tlocal_addr.sin_port = 0;\n\t\t\tlocal_addr.sin_addr.s_addr = inet_addr(local_if);\n\t\t}\n\t}\n\n\tsnprintf(portstr, sizeof(portstr), \"%d\", port);\n\n\tmemset(&ai_hints, 0, sizeof(ai_hints));\n\tai_hints.ai_family = tcp->ai_family;\n\tai_hints.ai_socktype = SOCK_STREAM;\n\tai_hints.ai_flags = AI_ADDRCONFIG;\n\tai_hints.ai_protocol = 0;\n\n\tret = getaddrinfo(hostname, portstr, &ai_hints, &gai_results);\n\tif (ret != 0) {\n\t\ttcp_error(hostname, port, gai_strerror(ret));\n\t\treturn -1;\n\t}\n\n\tgai_result = gai_results;\n\tdo {\n\t\tint tcp_fastopen = -1;\n\n\t\tif (sock_fd != -1) {\n\t\t\tclose(sock_fd);\n\t\t\tsock_fd = -1;\n\t\t}\n\t\tsock_fd = socket(gai_result->ai_family,\n\t\t\t\t gai_result->ai_socktype,\n\t\t\t\t gai_result->ai_protocol);\n\t\tif (sock_fd == -1)\n\t\t\tcontinue;\n\n\t\tif (local_if && gai_result->ai_family == AF_INET) {\n\t\t\tbind(sock_fd, (struct sockaddr *)&local_addr,\n\t\t\t     sizeof(local_addr));\n\t\t\t/* FIXME report errors */\n\t\t}\n\n\t\tif (TCP_FASTOPEN_CONNECT) {\n\t\t\ttcp_fastopen = setsockopt(sock_fd, IPPROTO_TCP,\n\t\t\t\t\t\t  TCP_FASTOPEN_CONNECT,\n\t\t\t\t\t\t  NULL, 0);\n\t\t} else if (io_timeout) {\n\t\t\t/* Set O_NONBLOCK so we can timeout */\n\t\t\tfcntl(sock_fd, F_SETFL, O_NONBLOCK);\n\t\t}\n\t\tret = connect(sock_fd, gai_result->ai_addr,\n\t\t\t      gai_result->ai_addrlen);\n\n\t\t/* Already connected maybe? */\n\t\tif (ret != -1)\n\t\t\tbreak;\n\n\t\tif (errno != EINPROGRESS)\n\t\t\tcontinue;\n\n\t\t/* With TFO we must assume success */\n\t\tif (tcp_fastopen != -1)\n\t\t\tbreak;\n\n\t\t/* Wait for the connection */\n\t\tfd_set fdset;\n\t\tFD_ZERO(&fdset);\n\t\tFD_SET(sock_fd, &fdset);\n\t\tstruct timeval tout = { .tv_sec  = io_timeout };\n\t\tret = select(sock_fd + 1, NULL, &fdset, NULL, &tout);\n\t\t/* Success? */\n\t\tif (ret != -1)\n\t\t\tbreak;\n\t} while ((gai_result = gai_result->ai_next));\n\n\tfreeaddrinfo(gai_results);\n\n\tif (sock_fd == -1) {\n\t\ttcp_error(hostname, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tfcntl(sock_fd, F_SETFL, 0);\n\n#ifdef HAVE_SSL\n\tif (secure) {\n\t\ttcp->ssl = ssl_connect(sock_fd, hostname);\n\t\tif (tcp->ssl == NULL) {\n\t\t\tclose(sock_fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\t\t\t\t/* HAVE_SSL */\n\ttcp->fd = sock_fd;\n\n\t/* Set I/O timeout */\n\tstruct timeval tout = { .tv_sec  = io_timeout };\n\tsetsockopt(sock_fd, SOL_SOCKET, SO_RCVTIMEO, &tout, sizeof(tout));\n\tsetsockopt(sock_fd, SOL_SOCKET, SO_SNDTIMEO, &tout, sizeof(tout));\n\n\treturn 1;\n}", "path": "axel/src/tcp.c", "commit_date": "2020-03-28 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/**\n * Hostname matching according to RFC-6125 section 6.4.3.\n *\n * For simplicity, at most one wildcard is supported, on the leftmost label\n * only.\n *\n * Hostname must be normalized and ASCII-only.\n *\n * @returns Negative on malformed input, Zero if matched, non-zero otherwise.\n */\n", "func_signal": "int\ndn_match(const char *hostname, const char *pat, size_t pat_len)", "code": "{\n\t/* The pattern is partitioned at the first wildcard or dot */\n\tconst size_t left = strcspn(pat, \".*\");\n\n\t/* We can't match an IDN against a wildcard */\n\tconst char ace_prefix[4] = \"xn--\";\n\tif (pat[left] == '*' && !strncasecmp(hostname, ace_prefix, 4))\n\t\treturn DN_NEQ;\n\n\t/* Compare left-side partition */\n\tif (strncasecmp(hostname, pat, left))\n\t\treturn DN_NEQ;\n\n\thostname += left;\n\tpat += left;\n\tpat_len -= left;\n\n\t/* Wildcard? */\n\tsize_t right = 0;\n\tif (*pat == '*') {\n\t\t--pat_len;\n\t\tright = strcspn(++pat, \".\");\n\t\tconst size_t rem = strcspn(hostname, \".\");\n\t\t/* Shorter label in hostname? */\n\t\tif (right > rem)\n\t\t\treturn DN_NEQ;\n\t\t/* Skip the longest match and adjust pat_len */\n\t\thostname += rem - right;\n\t}\n\n\t/* Check premature end of pattern (malformed certificate) */\n\tif (pat_len == right - strlen(pat + right))\n\t\treturn DN_MATCH_MALFORMED;\n\n\t/* Compare right-side partition */\n\treturn !!strcasecmp(hostname, pat);\n}", "path": "axel/src/dn-match.c", "commit_date": "2020-04-06 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Get file size and other information */\n", "func_signal": "int\nconn_info(conn_t *conn)", "code": "{\n\t/* It's all a bit messed up.. But it works. */\n\tif (PROTO_IS_FTP(conn->proto) && !conn->proxy) {\n\t\treturn conn_info_ftp(conn);\n\t}\n\n\tchar s[1005];\n\tlong long int i = 0;\n\n\tdo {\n\t\tconst char *t;\n\n\t\tconn->supported = true;\n\t\tconn->currentbyte = 0;\n\t\tpthread_mutex_lock(&conn->lock);\n\t\tif (!conn_setup(conn))\n\t\t\treturn 0;\n\t\tpthread_mutex_unlock(&conn->lock);\n\t\tconn_exec(conn);\n\t\tconn_disconnect(conn);\n\n\t\thttp_filename(conn->http, conn->output_filename);\n\n\t\t/* Code 3xx == redirect */\n\t\tif (conn->http->status / 100 != 3)\n\t\t\tbreak;\n\t\tif ((t = http_header(conn->http, \"location:\")) == NULL)\n\t\t\treturn 0;\n\t\tsscanf(t, \"%1000s\", s);\n\t\tif (s[0] == '/') {\n\t\t\tabuf_printf(conn->http->headers, \"%s%s:%i%s\",\n\t\t\t\t    scheme_from_proto(conn->proto),\n\t\t\t\t    conn->host, conn->port, s);\n\t\t\tstrlcpy(s, conn->http->headers->p, sizeof(s));\n\t\t} else if (strstr(s, \"://\") == NULL) {\n\t\t\tconn_url(conn->http->headers->p,\n\t\t\t\t conn->http->headers->len,\n\t\t\t\t conn);\n\t\t\tstrlcat(conn->http->headers->p, s,\n\t\t\t\tconn->http->headers->len);\n\t\t\tstrlcpy(s, conn->http->headers->p, sizeof(s));\n\t\t}\n\n\t\tif (!conn_set(conn, s)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* check if the download has been redirected to FTP and\n\t\t * report it back to the caller */\n\t\tif (PROTO_IS_FTP(conn->proto) && !conn->proxy) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (++i >= conn->conf->max_redirect) {\n\t\t\tfprintf(stderr, _(\"Too many redirects.\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t} while (conn->http->status / 100 == 3);\n\n\t/* Check for non-recoverable errors */\n\tif (conn->http->status != 416 && conn->http->status / 100 != 2)\n\t\treturn 0;\n\n\tconn->size = http_size_from_range(conn->http);\n\t/* We assume partial requests are supported if a Content-Range\n\t * header is present.\n\t */\n\tconn->supported = conn->http->status == 206 || conn->size > 0;\n\n\tif (conn->size <= 0) {\n\t\t/* Sanity check */\n\t\tswitch (conn->http->status) {\n\t\tcase 200: /* OK -> unsupported */\n\t\tcase 416: /* Range Not Satisfiable -> broken? */\n\t\t\tconn->supported = false;\n\t\tcase 206: /* Partial Content */\n\t\t\tbreak;\n\t\tdefault: /* unexpected */\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* If Content-Range is missing or disagrees with Content-Length, it's a\n\t * server bug; we take the larger and hope for the best.\n\t */\n\tconn->size = max(conn->size, http_size(conn->http));\n\tif (conn->size <= 0) {\n\t\tconn->size = LLONG_MAX;\n\t\tconn->supported = false;\n\t}\n\treturn 1;\n}", "path": "axel/src/conn.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Change current working directory */\n", "func_signal": "int\nftp_cwd(ftp_t *conn, char *cwd)", "code": "{\n\t/* Necessary at all? */\n\tif (strncmp(conn->cwd, cwd, MAX_STRING) == 0)\n\t\treturn 1;\n\n\tftp_command(conn, \"CWD %s\", cwd);\n\tif (ftp_wait(conn) / 100 != 2) {\n\t\tfprintf(stderr, _(\"Can't change directory to %s\\n\"), cwd);\n\t\treturn 0;\n\t}\n\n\tstrlcpy(conn->cwd, cwd, sizeof(conn->cwd));\n\n\treturn 1;\n}", "path": "axel/src/ftp.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "axel-download-accelerator/axel", "stars": 2762, "license": "gpl-2.0", "language": "c", "size": 1552}
{"docstring": "/* Resolve a given path (except the last component), output the real path\n * dirpath must be an absolute path without a tailing slash\n * Returns the length of realpath, or errno\n */\n", "func_signal": "static int resolve_path(const char *dirpath, const char *pathname, char *realpath, int *symlink_remain)", "code": "{\n\tchar target[PATH_MAX];\n\tchar *realpath_start = realpath;\n\t/* ENOENT when pathname is empty (according to Linux) */\n\tif (*pathname == 0)\n\t\treturn -L_ENOENT;\n\t/* CAUTION: dirpath can be aliased with realpath */\n\tif (*pathname == '/')\n\t{\n\t\t/* Absolute */\n\t\tpathname++;\n\t}\n\telse\n\t{\n\t\t/* Relative: Copy dirpath */\n\t\tif (realpath == dirpath)\n\t\t{\n\t\t\t/* Whoa, not even need to copy anything */\n\t\t\trealpath += strlen(dirpath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (*dirpath)\n\t\t\t\t*realpath++ = *dirpath++;\n\t\t}\n\t\tif (realpath > realpath_start && realpath[-1] == '/')\n\t\t\trealpath--;\n\t}\n\twhile (*pathname)\n\t{\n\t\tif (pathname[0] == '/')\n\t\t\tpathname++;\n\t\telse if (pathname[0] == '.' && pathname[1] == '/')\n\t\t\tpathname += 2;\n\t\telse if (pathname[0] == '.' && pathname[1] == '.' && pathname[2] == '/')\n\t\t{\n\t\t\tpathname += 3;\n\t\t\t/* Remove last component if exists */\n\t\t\tif (realpath > realpath_start)\n\t\t\t\tfor (realpath--; *realpath != '/'; realpath--);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*realpath++ = '/';\n\t\t\t/* Append current component */\n\t\t\twhile (*pathname && *pathname != '/')\n\t\t\t\t*realpath++ = *pathname++;\n\t\t\tif (*pathname == '/')\n\t\t\t{\n\t\t\t\tpathname++;\n\t\t\t\t/* Resolve component */\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\tstruct mount_point mp;\n\t\t\t\t\tchar *subpath;\n\t\t\t\t\t*realpath = 0;\n\t\t\t\t\tif (!find_mountpoint(realpath_start, &mp, &subpath))\n\t\t\t\t\t\treturn -L_ENOTDIR;\n\t\t\t\t\tstruct file_system *fs = mp.fs;\n\t\t\t\t\tif (!fs->open)\n\t\t\t\t\t\treturn -L_ENOTDIR;\n\t\t\t\t\tint r = fs->open(&mp, subpath, O_PATH | O_DIRECTORY, 0, 0, NULL, target, PATH_MAX);\n\t\t\t\t\tif (r < 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\telse if (r == 0) /* It is a regular file, go forward */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse if (r == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* It is a symlink */\n\t\t\t\t\t\tif ((*symlink_remain)-- == 0)\n\t\t\t\t\t\t\treturn -L_ELOOP;\n\t\t\t\t\t\t/* We resolve the symlink target using a recursive call */\n\t\t\t\t\t\t/* Remove basename */\n\t\t\t\t\t\tfor (realpath--; *realpath != '/'; realpath--);\n\t\t\t\t\t\t*realpath = 0;\n\t\t\t\t\t\tr = resolve_path(realpath_start, target, realpath_start, symlink_remain);\n\t\t\t\t\t\tif (r < 0)\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\trealpath = realpath_start + r;\n\t\t\t\t\t\tif (realpath > realpath_start && realpath[-1] == '/')\n\t\t\t\t\t\t\trealpath--;\n\t\t\t\t\t\t/* The last component is not resolved by the recursive call, solve it now */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Done */\n\t\t\t\t/* Normalize last component if it is \".\" or \"..\" */\n\t\t\t\tif (realpath[-1] == '.' && realpath[-2] == '/')\n\t\t\t\t{\n\t\t\t\t\trealpath -= 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (realpath[-1] == '.' && realpath[-2] == '.' && realpath[-3] == '/')\n\t\t\t\t{\n\t\t\t\t\t/* Remove last component if exists */\n\t\t\t\t\trealpath -= 3;\n\t\t\t\t\tif (realpath - 1 > realpath_start)\n\t\t\t\t\t\tfor (realpath--; *realpath != '/'; realpath--);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (realpath == realpath_start)\n\t\t*realpath++ = '/'; /* Return \"/\" instead of empty string */\n\t*realpath = 0;\n\treturn realpath - realpath_start;\n}", "path": "flinux/src/syscall/vfs.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Find and return an unused register in an instruction, which can be used to hold temporary values */\n", "func_signal": "static int find_unused_register(struct instruction_t *ins)", "code": "{\n\t/* Calculate used registers in this instruction */\n\tint used_regs = 0;\n\tused_regs |= get_implicit_register_usage(ins->desc->op1, ins->opcode);\n\tused_regs |= get_implicit_register_usage(ins->desc->op2, ins->opcode);\n\tused_regs |= get_implicit_register_usage(ins->desc->op3, ins->opcode);\n\tif ((ins->desc->handler_type & HANDLER_NORMAL) == HANDLER_NORMAL)\n\t{\n\t\t/* Additional register usage */\n\t\tused_regs |= ins->desc->handler_type;\n\t}\n\tif (ins->has_modrm)\n\t{\n\t\tif (ins->r != -1)\n\t\t\tused_regs |= REG_MASK(ins->r);\n\t\tif (ins->rm.base != -1)\n\t\t\tused_regs |= REG_MASK(ins->rm.base);\n\t\tif (ins->rm.index != -1)\n\t\t\tused_regs |= REG_MASK(ins->rm.index);\n\t}\n\tif (ins->rep_prefix)\n\t\tused_regs |= REG_CX;\n#define TEST_REG(r) do { if ((used_regs & REG_MASK(r)) == 0) return r; } while (0)\n\t/* We really don't want to use esp or ebp as a temporary register */\n\tTEST_REG(EAX);\n\tTEST_REG(ECX);\n\tTEST_REG(EDX);\n\tTEST_REG(EBX);\n\tTEST_REG(ESI);\n\tTEST_REG(EDI);\n#undef TEST_REG\n\tlog_error(\"find_unused_register: No usable register found. There must be a bug in our implementation.\");\n\t__debugbreak();\n\treturn 0;\n}", "path": "flinux/src/dbt/x86.c", "commit_date": "2015-10-10 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Segment register format:\n * 15    3  2   0\n * [Index|TI|RPL]\n * TI: GDT = 0, LDT = 1\n * RPL: Ring 3\n */\n", "func_signal": "int tls_set_thread_area(struct user_desc *u_info)", "code": "{\n\tlog_info(\"set_thread_area(%p): entry=%d, base=%p, limit=%p\", u_info, u_info->entry_number, u_info->base_addr, u_info->limit);\n\tint ret = 0;\n\tAcquireSRWLockExclusive(&tls->rw_lock);\n\tif (u_info->entry_number == -1)\n\t{\n\t\tif (tls->entry_count == MAX_TLS_ENTRIES)\n\t\t\tret = -L_ESRCH;\n\t\telse\n\t\t{\n\t\t\tint slot = TlsAlloc();\n\t\t\ttls->entries[tls->entry_count] = slot;\n\t\t\tu_info->entry_number = tls->entry_count;\n\t\t\tlog_info(\"allocated entry %d (slot %d), fs offset 0x%x\", tls->entry_count, slot, tls_slot_to_offset(u_info->entry_number));\n\t\t\ttls->entry_count++;\n\t\t\tTlsSetValue(slot, (LPVOID)u_info->base_addr);\n\t\t}\n\t}\n\telse\n\t\tTlsSetValue(tls->entries[u_info->entry_number], (LPVOID)u_info->base_addr);\n\tReleaseSRWLockExclusive(&tls->rw_lock);\n\treturn ret;\n}", "path": "flinux/src/syscall/tls.c", "commit_date": "2015-09-11 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Release a file, only used on raw file handles not created by sys_open() */\n", "func_signal": "void vfs_release(struct file *f)", "code": "{\n\tif (InterlockedDecrement(&f->ref) == 0)\n\t\tf->op_vtable->close(f);\n}", "path": "flinux/src/syscall/vfs.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Get file handle to a fd */\n", "func_signal": "struct file *vfs_get(int fd)", "code": "{\n\tif (fd < 0 || fd >= MAX_FD_COUNT)\n\t\treturn NULL;\n\tAcquireSRWLockShared(&vfs->rw_lock);\n\tstruct file *f = vfs->filed[fd].fd;\n\tif (f)\n\t\tvfs_ref(f);\n\tReleaseSRWLockShared(&vfs->rw_lock);\n\treturn f;\n}", "path": "flinux/src/syscall/vfs.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Caller ensures the input is correct */\n", "func_signal": "static int translate_socket_addr_to_linux(struct sockaddr_storage *addr, int addrlen)", "code": "{\n\tswitch (addr->ss_family)\n\t{\n\tcase AF_INET6:\n\t\taddr->ss_family = LINUX_AF_INET6;\n\t\tbreak;\n\t}\n\treturn addrlen;\n}", "path": "flinux/src/fs/socket.c", "commit_date": "2016-02-26 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Reports current ready state\n * If one event in error_report_events has potential error code, the last WSA error code is set to that\n */\n", "func_signal": "static int socket_update_events_unsafe(struct socket_file *f, int error_report_events)", "code": "{\n\tWSANETWORKEVENTS events;\n\tWSAEnumNetworkEvents(f->socket, f->event_handle, &events);\n\tint e = 0;\n\tif (events.lNetworkEvents & FD_READ)\n\t\te |= FD_READ;\n\tif (events.lNetworkEvents & FD_WRITE)\n\t\te |= FD_WRITE;\n\tif (events.lNetworkEvents & FD_CONNECT)\n\t{\n\t\te |= FD_CONNECT;\n\t\tf->shared->connect_error = events.iErrorCode[FD_CONNECT_BIT];\n\t}\n\tif (events.lNetworkEvents & FD_ACCEPT)\n\t\te |= FD_ACCEPT;\n\tif (events.lNetworkEvents & FD_CLOSE)\n\t\te |= FD_CLOSE;\n\tint original = InterlockedOr(&f->shared->events, e);\n\tif (error_report_events & f->shared->events & FD_CONNECT)\n\t{\n\t\tWSASetLastError(f->shared->connect_error);\n\t\tf->shared->connect_error = 0;\n\t\tInterlockedAnd(&f->shared->events, ~FD_CONNECT);\n\t}\n\treturn original | e;\n}", "path": "flinux/src/fs/socket.c", "commit_date": "2016-02-26 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Internal mount function. Caller should have vfs_mount_write_mutex acquired. */\n", "func_signal": "static int vfs_mount_unsafe(int fs_id, bool is_system, const WCHAR *win_path, const char *mount_path)", "code": "{\n\tlog_assert(*mount_path == '/');\n\t/* Find an empty slot */\n\tfor (int i = 1; i < MAX_MOUNT_POINTS; i++)\n\t\tif (!vfs_shared->mounts[i].used)\n\t\t{\n\t\t\t/* Initialize mount struct */\n\t\t\tvfs_shared->mounts[i].used = true;\n\t\t\tvfs_shared->mounts[i].is_system = is_system;\n\t\t\tvfs_shared->mounts[i].fs_id = fs_id;\n\t\t\tvfs_shared->mounts[i].key = InterlockedIncrement(&vfs_shared->max_key);\n\t\t\tif (win_path == NULL)\n\t\t\t{\n\t\t\t\tvfs_shared->mounts[i].win_path_len = 0;\n\t\t\t\tvfs_shared->mounts[i].win_path[0] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvfs_shared->mounts[i].win_path_len = wcslen(win_path);\n\t\t\t\twcscpy(vfs_shared->mounts[i].win_path, win_path);\n\t\t\t}\n\t\t\tvfs_shared->mounts[i].mountpoint_len = strlen(mount_path);\n\t\t\tstrcpy(vfs_shared->mounts[i].mountpoint, mount_path);\n\t\t\t\n\t\t\t/* We have to keep mount points sorted by their POSIX paths in descending order.\n\t\t\t * Hence \"/home\" will be tested before \"/\" on path resolving.\n\t\t\t */\n\t\t\t/* Find the position to insert this mount point */\n\t\t\tint prev = 0, cur = vfs_shared->mp_first;\n\t\t\twhile (cur)\n\t\t\t{\n\t\t\t\tint r = strcmp(vfs_shared->mounts[i].mountpoint, vfs_shared->mounts[cur].mountpoint);\n\t\t\t\tif (r == 0)\n\t\t\t\t{\n\t\t\t\t\tlog_error(\"Mounting to existing mount point \\\"%s\\\" not supported yet.\",\n\t\t\t\t\t\tvfs_shared->mounts[i].mountpoint);\n\t\t\t\t\tprocess_exit(1, 0);\n\t\t\t\t}\n\t\t\t\tif (r > 0)\n\t\t\t\t{\n\t\t\t\t\t/* Insert before current mount point */\n\t\t\t\t\t/* `next' is volatile, and in MSVC volatile means release ordering */\n\t\t\t\t\tvfs_shared->mounts[i].next = cur;\n\t\t\t\t\tif (prev == 0)\n\t\t\t\t\t\tvfs_shared->mp_first = i;\n\t\t\t\t\telse\n\t\t\t\t\t\tvfs_shared->mounts[prev].next = i;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tprev = cur;\n\t\t\t\tcur = vfs_shared->mounts[cur].next;\n\t\t\t}\n\t\t\t/* It is less than any of existing mount points, insert after the last one */\n\t\t\t/* `next' is volatile, and in MSVC volatile means release ordering */\n\t\t\tvfs_shared->mounts[i].next = 0;\n\t\t\tif (prev == 0)\n\t\t\t\tvfs_shared->mp_first = i;\n\t\t\telse\n\t\t\t\tvfs_shared->mounts[prev].next = i;\n\t\t\treturn i;\n\t\t}\n\treturn 0;\n}", "path": "flinux/src/syscall/vfs.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* CAUTION\n * We do not save x87/MMX/SSE/AVX states across a translation request\n * Thus we have to ensure these get unchanged during the translation\n * All Windows system calls cannot be used as they reset XMM registers to 0 upon return\n * To use these functions for debugging, wraps them in dbt_save_simd_state() and\n * dbt_restore_simd_state(). This including log_*() functions.\n */\n/* If context is given, dbt_translate() ignores pc and fix up context to user context\n * Otherwise, it translates a new basic block at pc and returns NULL\n * Caller ensures EIP is inside dbt code cache\n */\n", "func_signal": "static struct dbt_block *dbt_translate(size_t pc, struct syscall_context *context)", "code": "{\n\tstruct dbt_block *block;\n\tif (context)\n\t{\n\t\tif (dbt_sieve_dispatch_fixup(context))\n\t\t\treturn NULL;\n\t\tif (context->eip >= (DWORD)dbt->end)\n\t\t{\n\t\t\tif (dbt_sieve_fixup(context))\n\t\t\t\treturn NULL;\n\t\t\tif (dbt_direct_trampoline_fixup(context))\n\t\t\t\treturn NULL;\n\t\t\tif (dbt_direct_call_trampoline_fixup(context))\n\t\t\t\treturn NULL;\n\t\t\tlog_error(\"Address %p: Unknown trampoline type.\", pc);\n\t\t\t__debugbreak();\n\t\t}\n\t\t/* Not in a trampoline */\n\t\tstruct dbt_block probe;\n\t\tprobe.start = (uint8_t *)context->eip;\n\t\tstruct rb_node *node = rb_upper_bound(&dbt->cache_tree, &probe.cache_tree, cache_tree_cmp);\n\t\tif (node == NULL)\n\t\t{\n\t\t\tlog_error(\"Address %p: Block not found.\", pc);\n\t\t\t__debugbreak();\n\t\t}\n\t\tblock = rb_entry(node, struct dbt_block, cache_tree);\n\t\tpc = block->pc;\n\t}\n\telse\n\t{\n\t\tblock = alloc_block();\n\t\tif (!block) /* The cache is full */\n\t\t{\n\t\t\tif (cmdline_flags->dbt_trace)\n\t\t\t{\n\t\t\t\tdbt_save_simd_state();\n\t\t\t\tlog_debug(\"dbt cache is full, flushing code cache... (current pc = %p)\", pc);\n\t\t\t\tdbt_restore_simd_state();\n\t\t\t}\n\t\t\tdbt_flush();\n\t\t\tblock = alloc_block(); /* We won't fail again */\n\t\t}\n\t\tblock->pc = pc;\n\t\tblock->start = (uint8_t *)ALIGN_TO(dbt->out, DBT_OUT_ALIGN);\n\t\trb_add(&dbt->tree, &block->tree, tree_cmp);\n\t\trb_add(&dbt->cache_tree, &block->cache_tree, cache_tree_cmp);\n\t}\n\t\n\tif (cmdline_flags->dbt_trace)\n\t{\n\t\tdbt_save_simd_state();\n\t\tlog_debug(\"dbt_translate: id: %d, pc: %p, translated pc: %p, end: %p\", dbt->blocks_count, block->pc, block->start, dbt->end);\n\t\tdbt_restore_simd_state();\n\t}\n\n\tuint8_t *code = (uint8_t *)pc;\n\tuint8_t *out = block->start;\n\tfor (;;)\n\t{\n\t\tDWORD current_ip = (DWORD)code;\n\t\tif (context && context->eip == (DWORD)out)\n\t\t{\n\t\t\t/* The best case: we're at the begin of an instruction */\n\t\t\tcontext->eip = current_ip;\n\t\t\tgoto end_block;\n\t\t}\n\t\tif (dbt->end - out < DBT_BLOCK_MAXSIZE)\n\t\t{\n\t\t\t/* No enough space for code generation, emit a temporary trampoline and give up */\n\t\t\tsize_t patch_addr = (size_t)out + 1;\n\t\t\tgen_jmp(&out, dbt_get_direct_trampoline((size_t)code, patch_addr));\n\t\t\tgoto end_block;\n\t\t}\n\t\tstruct instruction_t ins;\n\t\tins.rep_prefix = 0;\n\t\tins.segment_prefix = 0;\n\t\tins.opsize_prefix = false;\n\t\tins.lock_prefix = false;\n\t\t/* Handle prefixes. According to x86 doc, they can appear in any order */\n\t\tfor (;;)\n\t\t{\n\t\t\tins.opcode = parse_byte(&code);\n\t\t\t/* TODO: Can we migrate this switch to a table driven approach? */\n\t\t\t/* TODO: Detect invalid multiple segment prefixes */\n\t\t\tswitch (ins.opcode)\n\t\t\t{\n\t\t\tcase 0xF0: /* LOCK */\n\t\t\t\tins.lock_prefix = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 0xF2: /* REPNE/REPNZ */\n\t\t\t\tins.rep_prefix = 0xF2;\n\t\t\t\tbreak;\n\n\t\t\tcase 0xF3: /* REP/REPE/REPZ */\n\t\t\t\tins.rep_prefix = 0xF3;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2E: /* CS segment override*/\n\t\t\t\tins.segment_prefix = 0x2E;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x36: /* SS segment override */\n\t\t\t\tins.segment_prefix = 0x36;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x3E: /* DS segment override */\n\t\t\t\tins.segment_prefix = 0x3E;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x26: /* ES segment override */\n\t\t\t\tins.segment_prefix = 0x26;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x64: /* FS segment override */\n\t\t\t\tlog_error(\"FS segment override not supported.\");\n\t\t\t\t__debugbreak();\n\t\t\t\tbreak;\n\n\t\t\tcase 0x65: /* GS segment override */\n\t\t\t\tins.segment_prefix = 0x65;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x66: /* Operand size prefix */\n\t\t\t\tins.opsize_prefix = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x67: /* Address size prefix */\n\t\t\t\tlog_error(\"Address size prefix not supported.\");\n\t\t\t\t__debugbreak();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto done_prefix;\n\t\t\t}\n\t\t}\n\ndone_prefix:\n\n\t\t/* Extract instruction descriptor */\n\t\tins.escape_0x0f = false;\n\t\tins.escape_byte2 = 0;\n\n\t\tif (ins.opcode == 0x0F)\n\t\t{\n\t\t\tins.escape_0x0f = true;\n\t\t\tins.opcode = parse_byte(&code);\n\t\t\tif (ins.opcode == 0x38)\n\t\t\t{\n\t\t\t\tins.escape_byte2 = 0x38;\n\t\t\t\tins.opcode = parse_byte(&code);\n\t\t\t\tins.desc = &three_byte_inst_0x38[ins.opcode];\n\t\t\t}\n\t\t\telse if (ins.opcode == 0x3A)\n\t\t\t{\n\t\t\t\tins.escape_byte2 = 0x3A;\n\t\t\t\tins.opcode = parse_byte(&code);\n\t\t\t\tins.desc = &three_byte_inst_0x3A[ins.opcode];\n\t\t\t}\n\t\t\telse\n\t\t\t\tins.desc = &two_byte_inst[ins.opcode];\n\t\t}\n\t\telse\n\t\t\tins.desc = &one_byte_inst[ins.opcode];\n\n\t\t/* Follow extension tables */\n\t\tins.has_modrm = false;\n\t\twhile (ins.desc->type <= INST_TYPE_MAX)\n\t\t{\n\t\t\tswitch (ins.desc->type)\n\t\t\t{\n\t\t\tcase INST_TYPE_UNKNOWN: log_error(\"Unknown opcode.\"); dbt_log_opcode(&ins); __debugbreak(); break;\n\t\t\tcase INST_TYPE_INVALID: log_error(\"Invalid opcode.\"); dbt_log_opcode(&ins); __debugbreak(); break;\n\t\t\tcase INST_TYPE_UNSUPPORTED: log_error(\"Unsupported opcode.\"); dbt_log_opcode(&ins); __debugbreak(); break;\n\n\t\t\tcase INST_TYPE_MANDATORY:\n\t\t\t{\n\t\t\t\tif (!ins.escape_0x0f)\n\t\t\t\t{\n\t\t\t\t\tlog_error(\"Invalid opcode.\");\n\t\t\t\t\t__debugbreak();\n\t\t\t\t}\n\t\t\t\tif (ins.opsize_prefix)\n\t\t\t\t\tins.desc = &ins.desc->extension_table[MANDATORY_0x66];\n\t\t\t\telse if (ins.rep_prefix == 0xF3)\n\t\t\t\t\tins.desc = &ins.desc->extension_table[MANDATORY_0xF3];\n\t\t\t\telse if (ins.rep_prefix == 0xF2)\n\t\t\t\t\tins.desc = &ins.desc->extension_table[MANDATORY_0xF2];\n\t\t\t\telse\n\t\t\t\t\tins.desc = &ins.desc->extension_table[MANDATORY_NONE];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase INST_TYPE_EXTENSION:\n\t\t\t{\n\t\t\t\tif (!ins.has_modrm)\n\t\t\t\t{\n\t\t\t\t\tparse_modrm(&code, &ins.r, &ins.rm);\n\t\t\t\t\tins.has_modrm = true;\n\t\t\t\t}\n\t\t\t\tins.desc = &ins.desc->extension_table[ins.r];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase INST_TYPE_MODRM_MOD:\n\t\t\t{\n\t\t\t\tif (!ins.has_modrm)\n\t\t\t\t{\n\t\t\t\t\tparse_modrm(&code, &ins.r, &ins.rm);\n\t\t\t\t\tins.has_modrm = true;\n\t\t\t\t}\n\t\t\t\tif (modrm_rm_is_r(ins.rm))\n\t\t\t\t\tins.desc = &ins.desc->extension_table[MODRM_MOD_R];\n\t\t\t\telse\n\t\t\t\t\tins.desc = &ins.desc->extension_table[MODRM_MOD_M];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* ins.desc now points to the correct instruction description */\n\t\tif (!ins.has_modrm)\n\t\t{\n\t\t\t/* Do we need modrm? */\n\t\t\tif (FROM_MODRM(ins.desc->op1) || FROM_MODRM(ins.desc->op2) || FROM_MODRM(ins.desc->op3))\n\t\t\t{\n\t\t\t\tparse_modrm(&code, &ins.r, &ins.rm);\n\t\t\t\tins.has_modrm = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Calculate number of immediate bytes */\n\t\tins.imm_bytes = get_imm_bytes(ins.desc->op1, ins.opsize_prefix, false)\n\t\t\t+ get_imm_bytes(ins.desc->op2, ins.opsize_prefix, false)\n\t\t\t+ get_imm_bytes(ins.desc->op3, ins.opsize_prefix, false);\n\n\t\tuint8_t handler_type = ins.desc->handler_type;\n\t\tif ((handler_type & HANDLER_NORMAL) == HANDLER_NORMAL)\n\t\t\thandler_type = HANDLER_NORMAL;\n\n\t\t/* Translate instruction */\n\t\tswitch (handler_type)\n\t\t{\n\t\tcase HANDLER_X87:\n\t\t{\n\t\t\t/* A very simplistic way to handle x87 escape opcode */\n\t\t\tuint8_t modrm = *code; /* Peek potential ModR/M byte */\n\t\t\tif (GET_MODRM_MOD(modrm) == 3) /* A non-operand opcode */\n\t\t\t{\n\t\t\t\t/* TODO: Do we need to handle prefixes here? */\n\t\t\t\tcode++;\n\t\t\t\tgen_byte(&out, ins.opcode);\n\t\t\t\tgen_byte(&out, modrm);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* An escape opcode with ModR/M, properly parse ModR/M */\n\t\t\tins.has_modrm = true;\n\t\t\tparse_modrm(&code, &ins.r, &ins.rm);\n\t\t\t/* Fall through */\n\t\t}\n\t\tcase HANDLER_NORMAL:\n\t\t{\n\t\t\tif (ins.segment_prefix == PREFIX_GS && ins.has_modrm && modrm_rm_is_m(ins.rm)\n\t\t\t\t&& !(!ins.escape_0x0f && ins.opcode == 0x8D)) /* LEA */\n\t\t\t{\n\t\t\t\t/* Instruction with effective gs segment override */\n\t\t\t\tint temp_reg = find_unused_register(&ins);\n\t\t\t\t/* mov fs:[scratch], temp_reg */\n\t\t\t\tgen_fs_prefix(&out);\n\t\t\t\tgen_mov_rm_r_32(&out, modrm_rm_disp(dbt_global->tls_scratch_offset), temp_reg);\n\n\t\t\t\t/* mov temp_reg, fs:[gs_addr] */\n\t\t\t\tgen_fs_prefix(&out);\n\t\t\t\tgen_mov_r_rm_32(&out, temp_reg, modrm_rm_disp(dbt_global->tls_gs_addr_offset));\n\t\t\t\tif (ins.rm.base != -1)\n\t\t\t\t{\n\t\t\t\t\t/* lea temp_reg, [temp_reg + rm.base] */\n\t\t\t\t\tgen_lea(&out, temp_reg, modrm_rm_mscale(temp_reg, ins.rm.base, 0, 0));\n\t\t\t\t}\n\t\t\t\t/* Replace rm.base with temp_reg */\n\t\t\t\tins.rm.base = temp_reg;\n\t\t\t\tif (context && context->eip <= (DWORD)out)\n\t\t\t\t{\n\t\t\t\t\t/* The instruction is not yet executed, rollback */\n\t\t\t\t\tset_context_register(context, temp_reg, __readfsdword(dbt_global->tls_scratch_offset));\n\t\t\t\t\tcontext->eip = current_ip;\n\t\t\t\t\tgoto end_block;\n\t\t\t\t}\n\n\t\t\t\t/* Copy instruction */\n\t\t\t\tdbt_copy_instruction(&out, &code, &ins);\n\t\t\t\tif (context && context->eip == (DWORD)out)\n\t\t\t\t{\n\t\t\t\t\t/* The instruction is already executed, commit */\n\t\t\t\t\tset_context_register(context, temp_reg, __readfsdword(dbt_global->tls_scratch_offset));\n\t\t\t\t\tcontext->eip = (DWORD)code;\n\t\t\t\t\tgoto end_block;\n\t\t\t\t}\n\n\t\t\t\t/* mov temp_reg, fs:[scratch] */\n\t\t\t\tgen_fs_prefix(&out);\n\t\t\t\tgen_mov_r_rm_32(&out, temp_reg, modrm_rm_disp(dbt_global->tls_scratch_offset));\n\t\t\t}\n\t\t\telse /* If nothing special, directly copy instruction */\n\t\t\t\tdbt_copy_instruction(&out, &code, &ins);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase HANDLER_PRIVILEGED:\n\t\t{\n\t\t\t/* We have to support translate privileged opcodes because e.g. glibc uses HLT as\n\t\t\t * a backup program terminator. */\n\t\t\tdbt_copy_instruction(&out, &code, &ins);\n\t\t\t/* The instructions following it won't be executed and could be crap so we stop here */\n\t\t\tgoto end_block;\n\t\t}\n\n\t\tcase HANDLER_MOV_MOFFSET:\n\t\t{\n\t\t\tif (ins.segment_prefix == PREFIX_GS)\n\t\t\t{\n\t\t\t\t/* mov moffs with effective gs segment override */\n\t\t\t\tint temp_reg = find_unused_register(&ins);\n\t\t\t\t/* mov fs:[scratch], temp_reg */\n\t\t\t\tgen_fs_prefix(&out);\n\t\t\t\tgen_mov_rm_r_32(&out, modrm_rm_disp(dbt_global->tls_scratch_offset), temp_reg);\n\n\t\t\t\t/* mov temp_reg, fs:[gs_addr] */\n\t\t\t\tgen_fs_prefix(&out);\n\t\t\t\tgen_mov_r_rm_32(&out, temp_reg, modrm_rm_disp(dbt_global->tls_gs_addr_offset));\n\t\t\t\tif (context && context->eip <= (DWORD)out)\n\t\t\t\t{\n\t\t\t\t\tset_context_register(context, temp_reg, __readfsdword(dbt_global->tls_scratch_offset));\n\t\t\t\t\tcontext->eip = current_ip;\n\t\t\t\t\tgoto end_block;\n\t\t\t\t}\n\n\t\t\t\t/* Generate patched instruction */\n\t\t\t\tif (ins.lock_prefix)\n\t\t\t\t\tgen_byte(&out, 0xF0);\n\t\t\t\tif (ins.opsize_prefix)\n\t\t\t\t\tgen_byte(&out, ins.opsize_prefix);\n\t\t\t\tif (ins.opcode == 0xA0) /* mov al, fs:moffs8 */\n\t\t\t\t\tgen_byte(&out, 0x8A);\n\t\t\t\telse if (ins.opcode == 0xA1) /* mov ?ax, moffs? */\n\t\t\t\t\tgen_byte(&out, 0x8B);\n\t\t\t\telse if (ins.opcode == 0xA2) /* mov moffs8, al */\n\t\t\t\t\tgen_byte(&out, 0x88);\n\t\t\t\telse /* if (ins.opcode ==0xA3) mov moffs?, ?ax */\n\t\t\t\t\tgen_byte(&out, 0x89);\n\t\t\t\tuint32_t disp = parse_moffset(&code, ins.imm_bytes);\n\t\t\t\tgen_modrm_sib(&out, 0, modrm_rm_mreg(temp_reg, disp));\n\t\t\t\tif (context && context->eip == (DWORD)out)\n\t\t\t\t{\n\t\t\t\t\tset_context_register(context, temp_reg, __readfsdword(dbt_global->tls_scratch_offset));\n\t\t\t\t\tcontext->eip = (DWORD)code;\n\t\t\t\t\tgoto end_block;\n\t\t\t\t}\n\n\t\t\t\t/* mov temp_reg, fs:[scratch] */\n\t\t\t\tgen_fs_prefix(&out);\n\t\t\t\tgen_mov_r_rm_32(&out, temp_reg, modrm_rm_disp(dbt_global->tls_scratch_offset));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Directly copy instruction */\n\t\t\tdbt_copy_instruction(&out, &code, &ins);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase HANDLER_CALL_DIRECT:\n\t\t{\n\t\t\tint32_t rel = parse_rel(&code, ins.imm_bytes);\n\t\t\tsize_t dest = (size_t)code + rel;\n\t\t\tgen_push_imm32(&out, (size_t)code);\n\t\t\tgen_mov_rm_imm32(&out, modrm_rm_disp((int32_t)&dbt->return_cache[RETURN_CACHE_HASH((size_t)code)]), 0);\n\t\t\tif (cmdline_flags->dbt_trace_all) /* Do not do any optimizations */\n\t\t\t\t*(size_t*)(out - 4) = (size_t)dbt->return_fallback_trampoline;\n\t\t\telse\n\t\t\t\t*(size_t*)(out - 4) = (size_t)out + 5;\n\t\t\tif (context && context->eip <= (DWORD)out)\n\t\t\t{\n\t\t\t\tcontext->esp += 4;\n\t\t\t\tcontext->eip = current_ip;\n\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\tif (context)\n\t\t\t\tout += 5;\n\t\t\telse\n\t\t\t\tgen_call(&out, dbt_get_direct_call_trampoline(dest));\n\t\t\tif (dbt_gen_call_postamble(&out, (size_t)code, context))\n\t\t\t\tgoto end_block;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase HANDLER_CALL_INDIRECT:\n\t\t{\n\t\t\t/* TODO: Bad codegen for `call esp', although should never be used in practice */\n\t\t\tgen_push_imm32(&out, (size_t)code);\n\t\t\tif (context && context->eip == (DWORD)out)\n\t\t\t{\n\t\t\t\tcontext->esp += 4;\n\t\t\t\tcontext->eip = current_ip;\n\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\tif (ins.rm.base == ESP) /* ESP-related address */\n\t\t\t\tins.rm.disp += ESP;\n\n\t\t\tif (ins.segment_prefix == PREFIX_GS && ins.has_modrm && modrm_rm_is_m(ins.rm))\n\t\t\t{\n\t\t\t\t/* call with effective gs segment override */\n\t\t\t\tint temp_reg = find_unused_register(&ins);\n\t\t\t\tif (dbt_gen_push_gs_rm(&out, temp_reg, ins.rm, current_ip, context))\n\t\t\t\t{\n\t\t\t\t\tcontext->esp += 4;\n\t\t\t\t\tgoto end_block;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (ins.segment_prefix && ins.segment_prefix != PREFIX_GS)\n\t\t\t\t\tgen_byte(&out, ins.segment_prefix);\n\t\t\t\tgen_push_rm(&out, ins.rm);\n\t\t\t}\n\t\t\tgen_mov_rm_imm32(&out, modrm_rm_disp((int32_t)&dbt->return_cache[RETURN_CACHE_HASH((size_t)code)]), 0);\n\t\t\tif (cmdline_flags->dbt_trace_all) /* Do not do any optimizations */\n\t\t\t\t*(size_t*)(out - 4) = (size_t)dbt->return_fallback_trampoline;\n\t\t\telse\n\t\t\t\t*(size_t*)(out - 4) = (size_t)out + 5;\n\t\t\tif (context && context->eip <= (DWORD)out)\n\t\t\t{\n\t\t\t\tcontext->esp += 8;\n\t\t\t\tcontext->eip = current_ip;\n\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\tgen_call(&out, dbt->sieve_indirect_call_dispatch_trampoline);\n\t\t\tif (dbt_gen_call_postamble(&out, (size_t)code, context))\n\t\t\t\tgoto end_block;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase HANDLER_RET:\n\t\t{\n\t\t\tdbt_gen_ret_trampoline(&out, context);\n\t\t\tgoto end_block;\n\t\t}\n\n\t\tcase HANDLER_RETN:\n\t\t{\n\t\t\tint count = parse_word(&code);\n\t\t\t/* pop [esp - 4 + count] */\n\t\t\t/* esp increases before pop operation */\n\t\t\tstruct modrm_rm_t rm = modrm_rm_mreg(4, count - 4);\n\t\t\tgen_pop_rm(&out, rm);\n\t\t\tif (context && context->eip == (DWORD)out)\n\t\t\t{\n\t\t\t\tcontext->esp = context->esp - 4 + count;\n\t\t\t\tcontext->eip = *(DWORD *)(context->esp - 4);\n\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\t/* lea esp, [esp - 4 + count] */\n\t\t\tgen_lea(&out, 4, rm);\n\t\t\tdbt_gen_ret_trampoline(&out, context);\n\t\t\tgoto end_block;\n\t\t}\n\n\t\tcase HANDLER_JMP_DIRECT:\n\t\t{\n\t\t\tint32_t rel = parse_rel(&code, ins.imm_bytes);\n\t\t\tsize_t dest = (size_t)code + rel;\n\t\t\tif (context)\n\t\t\t\tout += 5;\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize_t patch_addr = (size_t)out + 1;\n\t\t\t\tgen_jmp(&out, dbt_get_direct_trampoline(dest, patch_addr));\n\t\t\t}\n\t\t\tgoto end_block;\n\t\t}\n\n\t\tcase HANDLER_JMP_INDIRECT:\n\t\t{\n\t\t\tif (ins.segment_prefix == PREFIX_GS && ins.has_modrm && modrm_rm_is_m(ins.rm))\n\t\t\t{\n\t\t\t\t/* jmp with effective gs segment override */\n\t\t\t\tint temp_reg = find_unused_register(&ins);\n\t\t\t\tif (dbt_gen_push_gs_rm(&out, temp_reg, ins.rm, current_ip, context))\n\t\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (ins.segment_prefix && ins.segment_prefix != PREFIX_GS)\n\t\t\t\t\tgen_byte(&out, ins.segment_prefix);\n\t\t\t\tgen_push_rm(&out, ins.rm);\n\t\t\t}\n\t\t\tif (context && context->eip == (DWORD)out)\n\t\t\t{\n\t\t\t\tcontext->eip = current_ip;\n\t\t\t\tcontext->esp += 4;\n\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\tgen_jmp(&out, dbt->sieve_dispatch_trampoline);\n\t\t\tgoto end_block;\n\t\t}\n\n\t\tcase HANDLER_JCC:\n\t\t{\n\t\t\tint cond = ins.opcode & 0x0F;\n\t\t\tint32_t rel = parse_rel(&code, ins.imm_bytes);\n\t\t\tsize_t dest0 = (size_t)code + rel; /* Branch taken */\n\t\t\tsize_t dest1 = (size_t)code; /* Branch not taken */\n\t\t\tif (context)\n\t\t\t\tout += 6;\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize_t patch_addr0 = (size_t)out + 2;\n\t\t\t\tgen_jcc(&out, cond, (size_t)dbt_get_direct_trampoline(dest0, patch_addr0));\n\t\t\t}\n\t\t\tif (context && context->eip == (DWORD)out)\n\t\t\t{\n\t\t\t\tcontext->eip = current_ip;\n\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\tif (context)\n\t\t\t\tout += 5;\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize_t patch_addr1 = (size_t)out + 1;\n\t\t\t\tgen_jmp(&out, dbt_get_direct_trampoline(dest1, patch_addr1));\n\t\t\t}\n\t\t\tgoto end_block;\n\t\t}\n\n\t\tcase HANDLER_JCC_REL8:\n\t\t{\n\t\t\tint32_t rel = parse_rel(&code, ins.imm_bytes);\n\t\t\tsize_t dest0 = (size_t)code + rel; /* Branch taken */\n\t\t\tsize_t dest1 = (size_t)code; /* Branch not taken */\n\t\t\t/* LOOP, LOOPE, LOOPNE, JCXZ, JECXZ, JRCXZ */\n\t\t\t/* op $+2 */\n\t\t\tgen_byte(&out, ins.opcode);\n\t\t\tgen_byte(&out, 2); /* sizeof(jmp rel8) */\n\t\t\t/* jmp $+5 */\n\t\t\tgen_byte(&out, 0xEB);\n\t\t\tgen_byte(&out, 5); /* sizeof(jmp rel32) */\n\t\t\tif (context)\n\t\t\t\tout += 5;\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize_t patch_addr0 = (size_t)out + 1;\n\t\t\t\tgen_jmp(&out, dbt_get_direct_trampoline(dest0, patch_addr0));\n\t\t\t}\n\t\t\tif (context && context->eip <= (DWORD)out)\n\t\t\t{\n\t\t\t\tcontext->eip = current_ip;\n\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\tif (context)\n\t\t\t\tout += 5;\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize_t patch_addr1 = (size_t)out + 1;\n\t\t\t\tgen_jmp(&out, dbt_get_direct_trampoline(dest1, patch_addr1));\n\t\t\t}\n\t\t\tgoto end_block;\n\t\t}\n\n\t\tcase HANDLER_INT:\n\t\t{\n\t\t\tuint8_t id = parse_byte(&code);\n\t\t\tif (id != 0x80)\n\t\t\t{\n\t\t\t\tlog_error(\"INT 0x%x not supported.\", id);\n\t\t\t\t__debugbreak();\n\t\t\t}\n\t\t\tgen_push_imm32(&out, (size_t)code);\n\t\t\tif (context && context->eip == (DWORD)out)\n\t\t\t{\n\t\t\t\tcontext->esp += 4;\n\t\t\t\tcontext->eip = current_ip;\n\t\t\t\tgoto end_block;\n\t\t\t}\n\t\t\tgen_jmp(&out, &syscall_handler);\n\t\t\tgoto end_block;\n\t\t}\n\n\t\tcase HANDLER_MOV_FROM_SEG:\n\t\t{\n\t\t\tif (ins.r != 5) /* GS */\n\t\t\t{\n\t\t\t\tlog_error(\"mov from segment selectors other than GS not supported.\");\n\t\t\t\t__debugbreak();\n\t\t\t}\n\t\t\tint temp_reg = find_unused_register(&ins);\n\t\t\t/* mov fs:[scratch], temp_reg */\n\t\t\tgen_fs_prefix(&out);\n\t\t\tgen_mov_rm_r_32(&out, modrm_rm_disp(dbt_global->tls_scratch_offset), temp_reg);\n\n\t\t\t/* mov temp_reg, fs:[gs] */\n\t\t\tgen_fs_prefix(&out);\n\t\t\tgen_mov_r_rm_32(&out, temp_reg, modrm_rm_disp(dbt_global->tls_gs_offset));\n\t\t\tif (context && context->eip <= (DWORD)out)\n\t\t\t{\n\t\t\t\t/* The instruction is not yet executed, rollback */\n\t\t\t\tcontext->eip = current_ip;\n\t\t\t\tset_context_register(context, temp_reg, __readfsdword(dbt_global->tls_scratch_offset));\n\t\t\t\tgoto end_block;\n\t\t\t}\n\n\t\t\t/* mov |rm|, temp_reg */\n\t\t\tgen_mov_rm_r_32(&out, ins.rm, temp_reg);\n\t\t\tif (context && context->eip == (DWORD)out)\n\t\t\t{\n\t\t\t\t/* The instruction is already executed, commit */\n\t\t\t\tcontext->eip = (DWORD)code;\n\t\t\t\tset_context_register(context, temp_reg, __readfsdword(dbt_global->tls_scratch_offset));\n\t\t\t\tgoto end_block;\n\t\t\t}\n\n\t\t\t/* mov temp_reg, fs:[scratch] */\n\t\t\tgen_fs_prefix(&out);\n\t\t\tgen_mov_r_rm_32(&out, temp_reg, modrm_rm_disp(dbt_global->tls_scratch_offset));\n\t\t\tbreak;\n\t\t}\n\n\t\tcase HANDLER_MOV_TO_SEG:\n\t\t{\n\t\t\t/* TODO: Fix context */\n\t\t\tif (ins.r != 5) /* GS */\n\t\t\t{\n\t\t\t\tlog_error(\"mov to segment selector other than GS not supported.\");\n\t\t\t\t__debugbreak();\n\t\t\t}\n\t\t\tint temp_reg = find_unused_register(&ins);\n\t\t\t/* mov fs:[scratch], temp_reg */\n\t\t\tgen_fs_prefix(&out);\n\t\t\tgen_mov_rm_r_32(&out, modrm_rm_disp(dbt_global->tls_scratch_offset), temp_reg);\n\n\t\t\t/* mov temp_reg, |rm| */\n\t\t\tgen_mov_r_rm_32(&out, temp_reg, ins.rm);\n\n\t\t\t/* This is very ugly and inefficient, but anyway this instruction should not be used very often */\n\t\t\tgen_pushfd(&out);\n\n\t\t\t/* mov fs:[gs], temp_reg */\n\t\t\tgen_fs_prefix(&out);\n\t\t\tgen_mov_rm_r_32(&out, modrm_rm_disp(dbt_global->tls_gs_offset), temp_reg);\n\n\t\t\t/* call tls_user_entry_to_offset() to get the offset */\n\t\t\tgen_shr_rm_32(&out, modrm_rm_reg(temp_reg), 3);\n\t\t\tgen_push_rm(&out, modrm_rm_reg(0));\n\t\t\tgen_push_rm(&out, modrm_rm_reg(1));\n\t\t\tgen_push_rm(&out, modrm_rm_reg(2));\n\t\t\tgen_push_rm(&out, modrm_rm_reg(temp_reg));\n\t\t\tgen_call(&out, &tls_user_entry_to_offset);\n\n\t\t\t/* mov temp_reg, fs:eax */\n\t\t\tgen_fs_prefix(&out);\n\t\t\tgen_mov_r_rm_32(&out, temp_reg, modrm_rm_mreg(0, 0));\n\t\t\t/* mov fs:[gs_addr], temp_reg */\n\t\t\tgen_fs_prefix(&out);\n\t\t\tgen_mov_rm_r_32(&out, modrm_rm_disp(dbt_global->tls_gs_addr_offset), temp_reg);\n\n\t\t\t/* Clean up */\n\t\t\tgen_lea(&out, 4, modrm_rm_mreg(4, 4));\n\t\t\tgen_pop_rm(&out, modrm_rm_reg(2));\n\t\t\tgen_pop_rm(&out, modrm_rm_reg(1));\n\t\t\tgen_pop_rm(&out, modrm_rm_reg(0));\n\n\t\t\tgen_popfd(&out);\n\n\t\t\t/* mov temp_reg, fs:[scratch] */\n\t\t\tgen_fs_prefix(&out);\n\t\t\tgen_mov_r_rm_32(&out, temp_reg, modrm_rm_disp(dbt_global->tls_scratch_offset));\n\t\t\tbreak;\n\t\t}\n\n\t\tcase HANDLER_CPUID:\n\t\t{\n\t\t\t/* TODO: Fix context */\n\t\t\tgen_call(&out, &dbt_cpuid_internal);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tcontinue;\n\n\tend_block:\n\t\tbreak;\n\t}\n\tif (!context)\n\t\tdbt->out = out;\n\treturn block;\n}", "path": "flinux/src/dbt/x86.c", "commit_date": "2015-10-10 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Caller ensures process rw lock is acquired (shared) */\n/* FIXME: Using shared lock here is incorrect */\n", "func_signal": "static pid_t process_wait(pid_t pid, int *status, int options, struct rusage *rusage)", "code": "{\n\tif (options & WUNTRACED)\n\t\tlog_error(\"Unhandled option WUNTRACED\");\n\tif (options & WCONTINUED)\n\t\tlog_error(\"Unhandled option WCONTINUED\");\n\tif (rusage)\n\t\tlog_error(\"rusage not supported.\");\n\tstruct child_process *proc = NULL;\n\tif (pid > 0)\n\t{\n\t\tslist_iterate_safe(&process->child_list, prev, cur)\n\t\t{\n\t\t\tstruct child_process *p = slist_entry(cur, struct child_process, list);\n\t\t\tif (p->pid == pid)\n\t\t\t{\n\t\t\t\tproc = p;\n\t\t\t\tif (options & WNOHANG)\n\t\t\t\t{\n\t\t\t\t\tif (!proc->terminated)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_warning(\"Child not terminated yet.\");\n\t\t\t\t\t\treturn -L_ECHILD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDWORD result = signal_wait(1, &proc->hProcess, INFINITE);\n\t\t\t\t\tif (result == WAIT_INTERRUPTED)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_warning(\"Interrupted by signal.\");\n\t\t\t\t\t\treturn -L_EINTR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Decrement semaphore */\n\t\t\t\tWaitForSingleObject(signal_get_process_wait_semaphore(), INFINITE);\n\t\t\t\t/* Remove from child list */\n\t\t\t\tslist_remove(prev, cur);\n\t\t\t\tslist_add(&process->child_freelist, cur);\n\t\t\t\tprocess->child_count--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (proc == NULL)\n\t\t{\n\t\t\tlog_warning(\"pid %d is not a child.\", pid);\n\t\t\treturn -L_ECHILD;\n\t\t}\n\t}\n\telse if (pid == -1)\n\t{\n\t\tif (process->child_count == 0)\n\t\t{\n\t\t\tlog_warning(\"No children.\");\n\t\t\treturn -L_ECHILD;\n\t\t}\n\t\tif (!(options & WNOHANG))\n\t\t{\n\t\t\tHANDLE sem = signal_get_process_wait_semaphore();\n\t\t\tDWORD result = signal_wait(1, &sem, INFINITE);\n\t\t\tif (result == WAIT_INTERRUPTED)\n\t\t\t\treturn -L_EINTR;\n\t\t}\n\t\t/* Find the terminated child */\n\t\tslist_iterate_safe(&process->child_list, prev, cur)\n\t\t{\n\t\t\tstruct child_process *p = slist_entry(cur, struct child_process, list);\n\t\t\tif (p->terminated)\n\t\t\t{\n\t\t\t\tif (options & WNOHANG)\n\t\t\t\t{\n\t\t\t\t\t/* Decrement semaphore */\n\t\t\t\t\tWaitForSingleObject(signal_get_process_wait_semaphore(), INFINITE);\n\t\t\t\t}\n\t\t\t\tproc = p;\n\t\t\t\t/* Remove from child list */\n\t\t\t\tslist_remove(prev, cur);\n\t\t\t\tslist_add(&process->child_freelist, cur);\n\t\t\t\tprocess->child_count--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (proc == NULL) /* WNOHANG and no unwaited child */\n\t\t\treturn -L_ECHILD;\n\t}\n\telse\n\t{\n\t\tlog_error(\"pid unhandled.\");\n\t\treturn -L_EINVAL;\n\t}\n\tpid = proc->pid;\n\tprocess_lock_shared();\n\tint exit_code, exit_signal;\n\tif (process_shared->processes[pid].status == PROCESS_RUNNING)\n\t{\n\t\tDWORD code;\n\t\t/* The process died abnormally */\n\t\tGetExitCodeProcess(proc->hProcess, &code);\n\t\texit_code = code;\n\t\texit_signal = 0;\n\t}\n\telse if (process_shared->processes[pid].status == PROCESS_ZOMBIE)\n\t{\n\t\t/* The process died normally */\n\t\texit_code = process_shared->processes[pid].exit_code;\n\t\texit_signal = process_shared->processes[pid].exit_signal;\n\t}\n\telse\n\t{\n\t\tlog_error(\"Invalid process status: %d (pid: %d)\", process_shared->processes[pid].status, pid);\n\t\tprocess_exit(1, 0);\n\t}\n\tprocess_shared->processes[pid].status = PROCESS_NOTEXIST;\n\tprocess_unlock_shared();\n\tlog_info(\"pid: %d exit code: %d exit signal: %d\", pid, exit_code, exit_signal);\n\tif (status)\n\t{\n\t\tif (exit_signal)\n\t\t\t*status = W_STOPCODE(exit_signal);\n\t\telse\n\t\t\t*status = W_EXITCODE(exit_code, 0);\n\t}\n\tCloseHandle(proc->hProcess);\n\treturn pid;\n}", "path": "flinux/src/syscall/process.c", "commit_date": "2015-10-27 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Handler for control sequencie introducer, \"ESC [\" */\n", "func_signal": "static void control_escape_csi(char ch)", "code": "{\n\tswitch (ch)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t\tconsole->params[console->param_count] = 10 * console->params[console->param_count] + (ch - '0');\n\t\tbreak;\n\n\tcase ';':\n\t\tif (console->param_count + 1 == CONSOLE_MAX_PARAMS)\n\t\t\tlog_error(\"Too many console parameters.\");\n\t\telse\n\t\t\tconsole->param_count++;\n\t\tbreak;\n\n\tcase 'A': /* CUU */\n\t\tmove_up(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'B': /* CUD */\n\tcase 'e': /* VPR */\n\t\tmove_down(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'C': /* CUF */\n\tcase 'a': /* HPR */\n\t\tmove_right(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'D': /* CUB */\n\t\tmove_left(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'd': /* VPA */\n\t{\n\t\tint y = console->params[0]? console->params[0]: 1;\n\t\tif (y > console->height)\n\t\t\ty = console->height;\n\t\tset_pos(console->x, y - 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\t}\n\n\tcase 'G': /* CHA */\n\tcase '`': /* HPA */\n\t{\n\t\tint x = console->params[0] ? console->params[0] : 1;\n\t\tif (x > console->width)\n\t\t\tx = console->width;\n\t\tset_pos(x - 1, console->y);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\t}\n\n\tcase 'H':\n\tcase 'f':\n\t\t/* Zero or one both represents the first row/column */\n\t\tif (console->params[0] > 0)\n\t\t\tconsole->params[0]--;\n\t\tif (console->params[1] > 0)\n\t\t\tconsole->params[1]--;\n\t\tif (console->origin_mode)\n\t\t\tset_pos(console->params[1], console->scroll_top + console->params[0]);\n\t\telse\n\t\t\tset_pos(console->params[1], console->params[0]);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'h':\n\t\tif (console->csi_prefix == '?')\n\t\t\tfor (int i = 0; i <= console->param_count; i++)\n\t\t\t\tchange_private_mode(console->params[i], 1);\n\t\telse\n\t\t\tfor (int i = 0; i <= console->param_count; i++)\n\t\t\t\tchange_mode(console->params[i], 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'J':\n\t\terase_screen(console->params[0]);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'K':\n\t\terase_line(console->params[0]);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'l':\n\t\tif (console->csi_prefix == '?')\n\t\t\tfor (int i = 0; i <= console->param_count; i++)\n\t\t\t\tchange_private_mode(console->params[i], 0);\n\t\telse\n\t\t\tfor (int i = 0; i <= console->param_count; i++)\n\t\t\t\tchange_mode(console->params[i], 0);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'L': /* IL */\n\t\tinsert_line(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'M': /* DL */\n\t\tdelete_line(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase '@': /* ICH */\n\t\tinsert_character(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'P': /* DCH */\n\t\tdelete_character(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'c':\n\t\tif (console->csi_prefix == '>') /* DA2 */\n\t\t{\n\t\t\tif (console->params[0] == 0)\n\t\t\t\tconsole_add_input(\"\\x1B[>61;95;0c\", 11);\n\t\t\telse\n\t\t\t\tlog_warning(\"DA2 parameter is not zero.\");\n\t\t}\n\t\telse /* DA1 */\n\t\t{\n\t\t\tif (console->params[0] == 0)\n\t\t\t\tlog_error(\"DA1 not supported.\");\n\t\t\telse\n\t\t\t\tlog_warning(\"DA1 parameter is not zero.\");\n\t\t}\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'm':\n\t\tfor (int i = 0; i <= console->param_count; i++)\n\t\t{\n\t\t\tswitch (console->params[i])\n\t\t\t{\n\t\t\tcase 0: /* Reset */\n\t\t\t\tconsole->bright = 0;\n\t\t\t\tconsole->reverse = 0;\n\t\t\t\tconsole->foreground = 7;\n\t\t\t\tconsole->background = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tconsole->bright = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tconsole->bright = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tconsole->reverse = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 27:\n\t\t\t\tconsole->reverse = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 30:\n\t\t\tcase 31:\n\t\t\tcase 32:\n\t\t\tcase 33:\n\t\t\tcase 34:\n\t\t\tcase 35:\n\t\t\tcase 36:\n\t\t\tcase 37:\n\t\t\t\tconsole->foreground = console->params[i] - 30;\n\t\t\t\tbreak;\n\t\t\tcase 39:\n\t\t\t\tconsole->foreground = 7; /* White */\n\t\t\t\tbreak;\n\n\t\t\tcase 40:\n\t\t\tcase 41:\n\t\t\tcase 42:\n\t\t\tcase 43:\n\t\t\tcase 44:\n\t\t\tcase 45:\n\t\t\tcase 46:\n\t\t\tcase 47:\n\t\t\t\tconsole->background = console->params[i] - 40;\n\t\t\t\tbreak;\n\t\t\tcase 49:\n\t\t\t\tconsole->background = 0; /* Black */\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlog_error(\"Unknown console attribute: %d\", console->params[i]);\n\t\t\t}\n\t\t}\n\t\t/* Set updated text attribute */\n\t\tSetConsoleTextAttribute(console->out, get_text_attribute(console));\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'r':\n\t\tif (console->params[0] == 0)\n\t\t\tconsole->params[0] = 1;\n\t\tif (console->params[1] == 0)\n\t\t\tconsole->params[1] = console->height;\n\t\tconsole->scroll_full_screen = (console->params[0] == 1 && console->params[1] == console->height);\n\t\tconsole->scroll_top = console->params[0] - 1;\n\t\tconsole->scroll_bottom = console->params[1] - 1;\n\t\tset_pos(0, 0);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase 'S': /* SU */\n\t\tscroll_up(console->params[0]? console->params[0]: 1);\n\t\tconsole->processor = NULL;\n\t\tbreak;\n\n\tcase '?':\n\t\tconsole->csi_prefix = '?';\n\t\tbreak;\n\n\tcase '>':\n\t\tconsole->csi_prefix = '?';\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(\"control_escape_csi(): Unhandled character %c\", ch);\n\t\tconsole->processor = NULL;\n\t}\n}", "path": "flinux/src/fs/console.c", "commit_date": "2015-10-10 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Handler for operating system commands, \"ESC ]\" */\n", "func_signal": "static void control_escape_osc(char ch)", "code": "{\n\tif (console->string_len == -1)\n\t{\n\t\tif (ch == ';')\n\t\t{\n\t\t\tconsole->string_len = 0;\n\t\t\treturn;\n\t\t}\n\t\telse if (ch >= '0' && ch <= '9')\n\t\t{\n\t\t\tconsole->params[0] = console->params[0] * 10 + (ch - '0');\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (ch == 7) /* BEL, marks the end */\n\t{\n\t\tif (console->params[0] == 0 || console->params[0] == 2) /* Change window title (and icon name) */\n\t\t{\n\t\t\tWCHAR title[MAX_STRING + 1];\n\t\t\tint r = utf8_to_utf16(console->string_buffer, console->string_len, title, MAX_STRING + 1);\n\t\t\tif (r < 0)\n\t\t\t{\n\t\t\t\tlog_error(\"Invalid UTF-8 sequence.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttitle[r] = 0;\n\t\t\tSetConsoleTitleW(title);\n\t\t\tconsole->processor = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconsole->string_buffer[console->string_len++] = ch;\n\t\treturn;\n\t}\n\tlog_error(\"control_escape_osc(): Unhandled character %c\", ch);\n\tconsole->processor = NULL;\n}", "path": "flinux/src/fs/console.c", "commit_date": "2015-10-10 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Allocate a new process/thread, return pid. Caller ensures shared_mutex is acquired. */\n", "func_signal": "static pid_t process_shared_alloc()", "code": "{\n\t/* Note that pid starts from 1, but initial value of last_allocated_process is zero */\n\tfor (int i = 1; i < MAX_PROCESS_COUNT; i++)\n\t{\n\t\tpid_t cur = process_shared->last_allocated_process + i;\n\t\tif (cur >= MAX_PROCESS_COUNT)\n\t\t\tcur -= MAX_PROCESS_COUNT - 1;\n\t\tif (process_shared->processes[cur].status == PROCESS_NOTEXIST)\n\t\t{\n\t\t\tprocess_shared->last_allocated_process = cur;\n\t\t\treturn cur;\n\t\t}\n\t}\n\tlog_error(\"Process table exhausted.\");\n\t__debugbreak();\n\treturn 0;\n}", "path": "flinux/src/syscall/process.c", "commit_date": "2015-10-27 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Close a file descriptor fd */\n", "func_signal": "static void vfs_close(int fd)", "code": "{\n\tstruct file *f = vfs->filed[fd].fd;\n\tvfs_release(f);\n\tvfs->filed[fd].fd = NULL;\n\tvfs->filed[fd].cloexec = 0;\n}", "path": "flinux/src/syscall/vfs.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Free a thread structure and add it to freelist in process_data */\n", "func_signal": "static void thread_free(struct thread *thread)", "code": "{\n\tlist_remove(&process->thread_list, &thread->list);\n\tlist_add(&process->thread_freelist, &thread->list);\n\tInterlockedDecrement(&process->thread_count);\n}", "path": "flinux/src/syscall/process.c", "commit_date": "2015-10-27 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Get file handle to a fd (caller locks vfs, either exclusive or shared is okay) */\n", "func_signal": "static struct file *vfs_get_internal(int fd)", "code": "{\n\tif (fd < 0 || fd >= MAX_FD_COUNT)\n\t\treturn NULL;\n\tstruct file *f = vfs->filed[fd].fd;\n\tif (f)\n\t\tvfs_ref(f);\n\treturn f;\n}", "path": "flinux/src/syscall/vfs.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Helpers for constructing modrm_rm_t structure */\n", "func_signal": "static struct modrm_rm_t __forceinline modrm_rm_reg(int r)", "code": "{\n\tstruct modrm_rm_t rm;\n\trm.base = r;\n\trm.index = -1;\n\trm.scale = 0;\n\trm.disp = 0;\n\trm.flags = MODRM_PURE_REGISTER;\n\treturn rm;\n}", "path": "flinux/src/dbt/x86.c", "commit_date": "2015-10-10 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Allocate a new thread structure in process_data */\n", "func_signal": "static struct thread *thread_alloc()", "code": "{\n\tstruct list_node *node = list_head(&process->thread_freelist);\n\tif (node)\n\t{\n\t\tlist_remove(&process->thread_freelist, node);\n\t\tlist_add(&process->thread_list, node);\n\t\tInterlockedIncrement(&process->thread_count);\n\t\treturn list_entry(node, struct thread, list);\n\t}\n\tlog_error(\"Too many threads for current process.\");\n\t__debugbreak();\n\treturn NULL;\n}", "path": "flinux/src/syscall/process.c", "commit_date": "2015-10-27 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* resolve_path(), *at() version */\n", "func_signal": "int resolve_pathat(int dirfd, const char *pathname, char *realpath, int *symlink_remain)", "code": "{\n\tchar dirpath[PATH_MAX];\n\tif (pathname[0] != '/')\n\t{\n\t\tstruct file *f = dirfd == AT_FDCWD? vfs->cwd: vfs_get_internal(dirfd);\n\t\tif (!f)\n\t\t\treturn -L_EBADF;\n\t\tf->op_vtable->getpath(f, dirpath);\n\t\tif (dirfd != AT_FDCWD)\n\t\t\tvfs_release(f);\n\t}\n\treturn resolve_path(dirpath, pathname, realpath, symlink_remain);\n}", "path": "flinux/src/syscall/vfs.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/* Set register in context structure to specified value */\n", "func_signal": "static void set_context_register(struct syscall_context *context, int reg, DWORD value)", "code": "{\n\tswitch (reg)\n\t{\n\tcase EAX: context->eax = value; break;\n\tcase ECX: context->ecx = value; break;\n\tcase EDX: context->edx = value; break;\n\tcase EBX: context->ebx = value; break;\n\tcase ESP: context->esp = value; break;\n\tcase EBP: context->ebp = value; break;\n\tcase ESI: context->esi = value; break;\n\tcase EDI: context->edi = value; break;\n\t}\n}", "path": "flinux/src/dbt/x86.c", "commit_date": "2015-10-10 00:00:00", "repo_name": "wishstudio/flinux", "stars": 3588, "license": "gpl-3.0", "language": "c", "size": 1708}
{"docstring": "/*****************************************************************************\n * TEST SUITE                                                                *\n ****************************************************************************/\n", "func_signal": "Suite *suite(void)", "code": "{\n\tSuite *s = suite_create(\"Pack slurmdb_event_cond_t\");\n\tTCase *tc_core = tcase_create(\"Pack slurmdb_event_cond_t\");\n\ttcase_add_test(tc_core, invalid_protocol);\n\ttcase_add_test(tc_core, pack_current_event_cond);\n\ttcase_add_test(tc_core, pack_last_event_cond);\n\ttcase_add_test(tc_core, pack_min_event_cond);\n\tsuite_add_tcase(s, tc_core);\n\treturn s;\n}", "path": "slurm/testsuite/slurm_unit/common/slurmdb_pack/pack_event_cond-test.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/* returns the number of item deleted from the hash table */\n", "func_signal": "static int test_delete_helper()", "code": "{\n\txhash_t* ht = g_ht;\n\tint ret = 0;\n\tint i;\n\tchar buffer[255];\n\tfor (i = 0; i < g_hashableslen; ++i) {\n\t\tsnprintf(buffer, sizeof(buffer), \"%d\", i);\n\t\tif (xhash_get_str(ht, buffer) != (g_hashables + i)) {\n\t\t\t++ret;\n\t\t}\n\t}\n\treturn ret;\n}", "path": "slurm/testsuite/slurm_unit/common/xhash-test.c", "commit_date": "2020-01-09 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/* shutdown the slurmctld_state_save thread */\n", "func_signal": "extern void shutdown_state_save(void)", "code": "{\n\tslurm_mutex_lock(&state_save_lock);\n\trun_save_thread = false;\n\tslurm_cond_broadcast(&state_save_cond);\n\tslurm_mutex_unlock(&state_save_lock);\n}", "path": "slurm/src/slurmctld/state_save.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*\n * NOTE: This function is called after slurmstepd spawns all user tasks.\n * Since the slurmstepd was placed in the job container when the container\n * was created and all of it's spawned tasks are placed into the container\n * when forked, all we need to do is remove the slurmstepd from the container\n * (once) at this time.\n */\n", "func_signal": "int proctrack_p_add(stepd_step_rec_t *job, pid_t pid)", "code": "{\n#ifdef HAVE_NATIVE_CRAY\n\tchar fname[64];\n\tint fd;\n\tuint32_t jobid;\n#endif\n\tint count = 0;\n\n\tDEF_TIMERS;\n\tSTART_TIMER;\n\ntry_again:\n\t/*\n\t * If we aren't forked (pid was added in the job_create() call) this is\n\t * the time to add the pid to the job container.\n\t */\n\tif (!proctrack_forked &&\n\t    job_attachpid(pid, job->cont_id) == (jid_t) -1) {\n\t\tif (errno == EINVAL && (count < 1)) {\n\t\t\tjid_t jid;\n\t\t\tif (proctrack_p_has_pid(job->cont_id, pid)) {\n\t\t\t\tdebug(\"%s: Trying to add pid (%d) again to the same container, ignoring.\",\n\t\t\t\t      __func__, pid);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\n\t\t\tif ((jid = job_detachpid(pid)) != (jid_t) -1) {\n\t\t\t\terror(\"%s: Pid %d was attached to container %\"PRIu64\" incorrectly.  Moving to correct (%\"PRIu64\").\",\n\t\t\t\t      __func__, pid, jid, job->cont_id);\n\t\t\t\tcount++;\n\t\t\t\tgoto try_again;\n\t\t\t} else {\n\t\t\t\terror(\"%s: Couldn't detach pid %d from container: %m\",\n\t\t\t\t      __func__, pid);\n\t\t\t\treturn SLURM_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\terror(\"Failed to attach pid %d to job container: %m\",\n\t\t\t      pid);\n\t\t\treturn SLURM_ERROR;\n\t\t}\n\t}\n\t_end_container_thread();\n\n#ifdef HAVE_NATIVE_CRAY\n\t// Set apid for this pid\n\tif (job->het_job_id && (job->het_job_id != NO_VAL))\n\t\tjobid = job->het_job_id;\n\telse\n\t\tjobid = job->step_id.job_id;\n\tif (job_setapid(pid, SLURM_ID_HASH(jobid,\n\t\t\t\t\t   job->step_id.step_id)) == -1) {\n\t\terror(\"Failed to set pid %d apid: %m\", pid);\n\t\treturn SLURM_ERROR;\n\t}\n\n\t// Explicitly mark pid as an application (/proc/<pid>/task_is_app)\n\tsnprintf(fname, sizeof(fname), \"/proc/%d/task_is_app\", pid);\n\tfd = open(fname, O_WRONLY);\n\tif (fd == -1) {\n\t\terror(\"Failed to open %s: %m\", fname);\n\t\treturn SLURM_ERROR;\n\t}\n\tif (write(fd, \"1\", 1) < 1) {\n\t\terror(\"Failed to write to %s: %m\", fname);\n\t\tTEMP_FAILURE_RETRY(close(fd));\n\t\treturn SLURM_ERROR;\n\t}\n\tTEMP_FAILURE_RETRY(close(fd));\n#endif\n\tEND_TIMER;\n\tif (slurm_conf.debug_flags & DEBUG_FLAG_TIME_CRAY)\n\t\tINFO_LINE(\"call took: %s\", TIME_STR);\n\n\treturn SLURM_SUCCESS;\n}", "path": "slurm/src/plugins/proctrack/cray_aries/proctrack_cray_aries.c", "commit_date": "2020-06-18 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*****************************************************************************\n * TEST RUNNER                                                               *\n ****************************************************************************/\n", "func_signal": "int main(void)", "code": "{\n\tint number_failed;\n\tSRunner *sr = srunner_create(suite());\n\n\t//srunner_set_fork_status(sr, CK_NOFORK);\n\n\tsrunner_run_all(sr, CK_VERBOSE);\n\t//srunner_run_all(sr, CK_NORMAL);\n\tnumber_failed = srunner_ntests_failed(sr);\n\tsrunner_free(sr);\n\n\treturn (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "path": "slurm/testsuite/slurm_unit/common/slurmdb_pack/pack_event_cond-test.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/* Queue saving of front_end state information */\n", "func_signal": "extern void schedule_front_end_save(void)", "code": "{\n\tslurm_mutex_lock(&state_save_lock);\n\tsave_front_end++;\n\tslurm_cond_broadcast(&state_save_cond);\n\tslurm_mutex_unlock(&state_save_lock);\n}", "path": "slurm/src/slurmctld/state_save.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*\n * slurm_load_burst_buffer_stat - issue RPC to get burst buffer status\n * IN argc - count of status request options\n * IN argv - status request options\n * OUT status_resp - status response, memory must be released using xfree()\n * RET 0 or a slurm error code\n */\n", "func_signal": "extern int slurm_load_burst_buffer_stat(int argc, char **argv,\n\t\t\t\t\tchar **status_resp)", "code": "{\n\tint rc;\n\tslurm_msg_t req_msg;\n\tslurm_msg_t resp_msg;\n\tbb_status_req_msg_t status_req_msg;\n\tbb_status_resp_msg_t *status_resp_msg;\n\n\tslurm_msg_t_init(&req_msg);\n\tslurm_msg_t_init(&resp_msg);\n\tstatus_req_msg.argc = argc;\n\tstatus_req_msg.argv = argv;\n\treq_msg.msg_type = REQUEST_BURST_BUFFER_STATUS;\n\treq_msg.data     = &status_req_msg;\n\n\tif (slurm_send_recv_controller_msg(&req_msg, &resp_msg,\n\t\t\t\t\t   working_cluster_rec) < 0)\n\t\treturn SLURM_ERROR;\n\n\tswitch (resp_msg.msg_type) {\n\tcase RESPONSE_BURST_BUFFER_STATUS:\n\t\tstatus_resp_msg = (bb_status_resp_msg_t *) resp_msg.data;\n\t\t*status_resp = status_resp_msg->status_resp;\n\t\tstatus_resp_msg->status_resp = NULL;\n\t\tbreak;\n\tcase RESPONSE_SLURM_RC:\n\t\trc = ((return_code_msg_t *) resp_msg.data)->return_code;\n\t\tslurm_free_return_code_msg(resp_msg.data);\n\t\tif (rc)\n\t\t\tslurm_seterrno_ret(rc);\n\t\t*status_resp = NULL;\n\t\tbreak;\n\tdefault:\n\t\tslurm_seterrno_ret(SLURM_UNEXPECTED_MSG_ERROR);\n\t\tbreak;\n\t}\n\n\treturn SLURM_SUCCESS;\n}", "path": "slurm/src/api/burst_buffer_info.c", "commit_date": "2018-09-28 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*****************************************************************************\n * TEST RUNNER                                                               *\n ****************************************************************************/\n", "func_signal": "int main(void)", "code": "{\n    int number_failed;\n    SRunner *sr = srunner_create(xhash_suite());\n\n    srunner_run_all(sr, CK_NORMAL);\n    number_failed = srunner_ntests_failed(sr);\n    srunner_free(sr);\n\n    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "path": "slurm/testsuite/slurm_unit/common/xhash-test.c", "commit_date": "2020-01-09 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*\n * slurm_load_burst_buffer_info - issue RPC to get slurm all burst buffer plugin\n *\tinformation\n * OUT burst_buffer_info_msg_pptr - place to store a burst buffer configuration\n *\tpointer\n * RET 0 or a slurm error code\n * NOTE: free the response using slurm_free_burst_buffer_info_msg\n */\n", "func_signal": "extern int slurm_load_burst_buffer_info(burst_buffer_info_msg_t **\n\t\t\t\t\tburst_buffer_info_msg_pptr)", "code": "{\n\tint rc;\n\tslurm_msg_t req_msg;\n\tslurm_msg_t resp_msg;\n\n\tslurm_msg_t_init(&req_msg);\n\tslurm_msg_t_init(&resp_msg);\n\treq_msg.msg_type = REQUEST_BURST_BUFFER_INFO;\n\treq_msg.data     = NULL;\n\n\tif (slurm_send_recv_controller_msg(&req_msg, &resp_msg,\n\t\t\t\t\t   working_cluster_rec) < 0)\n\t\treturn SLURM_ERROR;\n\n\tswitch (resp_msg.msg_type) {\n\tcase RESPONSE_BURST_BUFFER_INFO:\n\t\t*burst_buffer_info_msg_pptr = (burst_buffer_info_msg_t *)\n\t\t\t\t\t      resp_msg.data;\n\t\tbreak;\n\tcase RESPONSE_SLURM_RC:\n\t\trc = ((return_code_msg_t *) resp_msg.data)->return_code;\n\t\tslurm_free_return_code_msg(resp_msg.data);\n\t\tif (rc)\n\t\t\tslurm_seterrno_ret(rc);\n\t\t*burst_buffer_info_msg_pptr = NULL;\n\t\tbreak;\n\tdefault:\n\t\tslurm_seterrno_ret(SLURM_UNEXPECTED_MSG_ERROR);\n\t\tbreak;\n\t}\n\n\treturn SLURM_SUCCESS;\n}", "path": "slurm/src/api/burst_buffer_info.c", "commit_date": "2018-09-28 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/* Queue saving of reservation state information */\n", "func_signal": "extern void schedule_resv_save(void)", "code": "{\n\tslurm_mutex_lock(&state_save_lock);\n\tsave_resv++;\n\tslurm_cond_broadcast(&state_save_cond);\n\tslurm_mutex_unlock(&state_save_lock);\n}", "path": "slurm/src/slurmctld/state_save.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/* Queue saving of job state information */\n", "func_signal": "extern void schedule_job_save(void)", "code": "{\n\tslurm_mutex_lock(&state_save_lock);\n\tsave_jobs++;\n\tslurm_cond_broadcast(&state_save_cond);\n\tslurm_mutex_unlock(&state_save_lock);\n}", "path": "slurm/src/slurmctld/state_save.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/* Queue saving of trigger state information */\n", "func_signal": "extern void schedule_trigger_save(void)", "code": "{\n\tslurm_mutex_lock(&state_save_lock);\n\tsave_triggers++;\n\tslurm_cond_broadcast(&state_save_cond);\n\tslurm_mutex_unlock(&state_save_lock);\n}", "path": "slurm/src/slurmctld/state_save.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*\n * slurm_print_burst_buffer_info_msg - output information about burst buffers\n *\tbased upon message as loaded using slurm_load_burst_buffer\n * IN out - file to write to\n * IN info_ptr - burst_buffer information message pointer\n * IN one_liner - print as a single line if true\n * IN verbose - higher values to log additional details\n */\n", "func_signal": "extern void slurm_print_burst_buffer_info_msg(FILE *out,\n\t\t burst_buffer_info_msg_t *info_ptr, int one_liner,\n\t\t int verbose)", "code": "{\n\tint i;\n\tburst_buffer_info_t *burst_buffer_ptr;\n\n\tif (info_ptr->record_count == 0) {\n\t\terror(\"No burst buffer information available\");\n\t\treturn;\n\t}\n\n\tfor (i = 0, burst_buffer_ptr = info_ptr->burst_buffer_array;\n\t     i < info_ptr->record_count; i++, burst_buffer_ptr++) {\n\t\tslurm_print_burst_buffer_record(out, burst_buffer_ptr,\n\t\t\t\t\t\tone_liner, verbose);\n\t}\n}", "path": "slurm/src/api/burst_buffer_info.c", "commit_date": "2018-09-28 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/* Queue saving of node state information */\n", "func_signal": "extern void schedule_node_save(void)", "code": "{\n\tslurm_mutex_lock(&state_save_lock);\n\tsave_nodes++;\n\tslurm_cond_broadcast(&state_save_cond);\n\tslurm_mutex_unlock(&state_save_lock);\n}", "path": "slurm/src/slurmctld/state_save.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*\n * Run as pthread to keep saving slurmctld state information as needed,\n * Use schedule_job_save(),  schedule_node_save(), and schedule_part_save()\n * to queue state save of each data structure\n * no_data IN - unused\n * RET - NULL\n */\n", "func_signal": "extern void *slurmctld_state_save(void *no_data)", "code": "{\n\ttime_t last_save = 0, now;\n\tdouble save_delay;\n\tbool run_save;\n\tint save_count;\n\n#if HAVE_SYS_PRCTL_H\n\tif (prctl(PR_SET_NAME, \"sstate\", NULL, NULL, NULL) < 0) {\n\t\terror(\"%s: cannot set my name to %s %m\", __func__, \"sstate\");\n\t}\n#endif\n\n\tif (test_config)\t/* Should be redundant, but just to be safe */\n\t\treturn NULL;\n\n\twhile (1) {\n\t\t/* wait for work to perform */\n\t\tslurm_mutex_lock(&state_save_lock);\n\t\twhile (1) {\n\t\t\tsave_count = save_jobs + save_nodes + save_parts +\n\t\t\t\t     save_front_end + save_resv +\n\t\t\t\t     save_triggers;\n\t\t\tnow = time(NULL);\n\t\t\tsave_delay = difftime(now, last_save);\n\t\t\tif (save_count &&\n\t\t\t    (!run_save_thread ||\n\t\t\t     (save_delay >= SAVE_MAX_WAIT))) {\n\t\t\t\tlast_save = now;\n\t\t\t\tbreak;\t\t/* do the work */\n\t\t\t} else if (!run_save_thread) {\n\t\t\t\trun_save_thread = true;\n\t\t\t\tslurm_mutex_unlock(&state_save_lock);\n\t\t\t\treturn NULL;\t/* shutdown */\n\t\t\t} else if (save_count) { /* wait for a timeout */\n\t\t\t\tstruct timespec ts = {0, 0};\n\t\t\t\tts.tv_sec = now + 1;\n\t\t\t\tslurm_cond_timedwait(&state_save_cond,\n\t\t\t\t\t  \t     &state_save_lock, &ts);\n\t\t\t} else {\t\t/* wait for more work */\n\t\t\t\tslurm_cond_wait(&state_save_cond,\n\t\t\t\t\t  \t&state_save_lock);\n\t\t\t}\n\t\t}\n\n\t\t/* save front_end node info if necessary */\n\t\trun_save = false;\n\t\t/* slurm_mutex_lock(&state_save_lock); done above */\n\t\tif (save_front_end) {\n\t\t\trun_save = true;\n\t\t\tsave_front_end = 0;\n\t\t}\n\t\tslurm_mutex_unlock(&state_save_lock);\n\t\tif (run_save)\n\t\t\t(void)dump_all_front_end_state();\n\n\t\t/* save job info if necessary */\n\t\trun_save = false;\n\t\tslurm_mutex_lock(&state_save_lock);\n\t\tif (save_jobs) {\n\t\t\trun_save = true;\n\t\t\tsave_jobs = 0;\n\t\t}\n\t\tslurm_mutex_unlock(&state_save_lock);\n\t\tif (run_save)\n\t\t\t(void)dump_all_job_state();\n\n\t\t/* save node info if necessary */\n\t\trun_save = false;\n\t\tslurm_mutex_lock(&state_save_lock);\n\t\tif (save_nodes) {\n\t\t\trun_save = true;\n\t\t\tsave_nodes = 0;\n\t\t}\n\t\tslurm_mutex_unlock(&state_save_lock);\n\t\tif (run_save)\n\t\t\t(void)dump_all_node_state();\n\n\t\t/* save partition info if necessary */\n\t\trun_save = false;\n\t\tslurm_mutex_lock(&state_save_lock);\n\t\tif (save_parts) {\n\t\t\trun_save = true;\n\t\t\tsave_parts = 0;\n\t\t}\n\t\tslurm_mutex_unlock(&state_save_lock);\n\t\tif (run_save)\n\t\t\t(void)dump_all_part_state();\n\n\t\t/* save reservation info if necessary */\n\t\trun_save = false;\n\t\tslurm_mutex_lock(&state_save_lock);\n\t\tif (save_resv) {\n\t\t\trun_save = true;\n\t\t\tsave_resv = 0;\n\t\t}\n\t\tslurm_mutex_unlock(&state_save_lock);\n\t\tif (run_save)\n\t\t\t(void)dump_all_resv_state();\n\n\t\t/* save trigger info if necessary */\n\t\trun_save = false;\n\t\tslurm_mutex_lock(&state_save_lock);\n\t\tif (save_triggers) {\n\t\t\trun_save = true;\n\t\t\tsave_triggers = 0;\n\t\t}\n\t\tslurm_mutex_unlock(&state_save_lock);\n\t\tif (run_save)\n\t\t\t(void)trigger_state_save();\n\t}\n}", "path": "slurm/src/slurmctld/state_save.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*\n * init() is called when the plugin is loaded, before any other functions\n * are called.  Put global initialization here.\n */\n", "func_signal": "extern int init(void)", "code": "{\n\tdebug(\"%s loaded\", plugin_name);\n\treturn SLURM_SUCCESS;\n}", "path": "slurm/src/plugins/proctrack/cray_aries/proctrack_cray_aries.c", "commit_date": "2020-06-18 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*\n * slurm_print_burst_buffer_record - output information about a specific Slurm\n *\tburst_buffer record based upon message as loaded using\n *\tslurm_load_burst_buffer_info()\n * IN out - file to write to\n * IN burst_buffer_ptr - an individual burst buffer record pointer\n * IN one_liner - print as a single line if not zero\n * IN verbose - higher values to log additional details\n * RET out - char * containing formatted output (must be freed after call)\n *\t   NULL is returned on failure.\n */\n", "func_signal": "extern void slurm_print_burst_buffer_record(FILE *out,\n\t\tburst_buffer_info_t *burst_buffer_ptr, int one_liner,\n\t\tint verbose)", "code": "{\n\tchar f_sz_buf[32], g_sz_buf[32], t_sz_buf[32], u_sz_buf[32];\n\tchar *out_buf = NULL;\n\tchar *line_end = (one_liner) ? \" \" : \"\\n  \";\n\tuint64_t free_space;\n\tburst_buffer_resv_t *bb_resv_ptr;\n\tburst_buffer_use_t  *bb_use_ptr;\n\tint i;\n\n\t/****** Line ******/\n\tfree_space = burst_buffer_ptr->total_space -\n\t\t     burst_buffer_ptr->unfree_space;\n\t_get_size_str(f_sz_buf, sizeof(f_sz_buf), free_space);\n\t_get_size_str(g_sz_buf, sizeof(g_sz_buf),\n\t\t      burst_buffer_ptr->granularity);\n\t_get_size_str(t_sz_buf, sizeof(t_sz_buf),\n\t\t      burst_buffer_ptr->total_space);\n\t_get_size_str(u_sz_buf, sizeof(u_sz_buf),\n\t\t      burst_buffer_ptr->used_space);\n\txstrfmtcat(out_buf, \"Name=%s DefaultPool=%s Granularity=%s TotalSpace=%s FreeSpace=%s UsedSpace=%s\",\n\t\t   burst_buffer_ptr->name, burst_buffer_ptr->default_pool,\n\t\t   g_sz_buf, t_sz_buf, f_sz_buf, u_sz_buf);\n\n\t/****** Line (optional) ******/\n\t/* Alternate pool information */\n\tfor (i = 0; i < burst_buffer_ptr->pool_cnt; i++) {\n\t\txstrcat(out_buf, line_end);\n\t\tfree_space = burst_buffer_ptr->pool_ptr[i].total_space -\n\t\t\t     burst_buffer_ptr->pool_ptr[i].unfree_space;\n\t\t_get_size_str(f_sz_buf, sizeof(f_sz_buf), free_space);\n\t\t_get_size_str(g_sz_buf, sizeof(g_sz_buf),\n\t\t\t      burst_buffer_ptr->pool_ptr[i].granularity);\n\t\t_get_size_str(t_sz_buf, sizeof(t_sz_buf),\n\t\t\t      burst_buffer_ptr->pool_ptr[i].total_space);\n\t\t_get_size_str(u_sz_buf, sizeof(u_sz_buf),\n\t\t\t      burst_buffer_ptr->pool_ptr[i].used_space);\n\t\txstrfmtcat(out_buf, \"AltPoolName[%d]=%s Granularity=%s TotalSpace=%s FreeSpace=%s UsedSpace=%s\",\n\t\t\t   i, burst_buffer_ptr->pool_ptr[i].name,\n\t\t\t   g_sz_buf, t_sz_buf, f_sz_buf, u_sz_buf);\n\t}\n\n\t/****** Line ******/\n\txstrcat(out_buf, line_end);\n\txstrfmtcat(out_buf, \"Flags=%s\",\n\t\t   slurm_bb_flags2str(burst_buffer_ptr->flags));\n\n\t/****** Line ******/\n\txstrcat(out_buf, line_end);\n\txstrfmtcat(out_buf, \"StageInTimeout=%u StageOutTimeout=%u ValidateTimeout=%u OtherTimeout=%u\",\n\t\t   burst_buffer_ptr->stage_in_timeout,\n\t\t   burst_buffer_ptr->stage_out_timeout,\n\t\t   burst_buffer_ptr->validate_timeout,\n\t\t   burst_buffer_ptr->other_timeout);\n\n\t/****** Line (optional) ******/\n\tif (burst_buffer_ptr->allow_users) {\n\t\txstrcat(out_buf, line_end);\n\t\txstrfmtcat(out_buf, \"AllowUsers=%s\",\n\t\t\t   burst_buffer_ptr->allow_users);\n\t} else if (burst_buffer_ptr->deny_users) {\n\t\txstrcat(out_buf, line_end);\n\t\txstrfmtcat(out_buf, \"DenyUsers=%s\",\n\t\t\t   burst_buffer_ptr->deny_users);\n\t}\n\n\t/****** Line (optional) ******/\n\tif (burst_buffer_ptr->create_buffer) {\n\t\txstrcat(out_buf, line_end);\n\t\txstrfmtcat(out_buf, \"CreateBuffer=%s\",\n\t\t\t   burst_buffer_ptr->create_buffer);\n\t}\n\n\t/****** Line (optional) ******/\n\tif (burst_buffer_ptr->destroy_buffer) {\n\t\txstrcat(out_buf, line_end);\n\t\txstrfmtcat(out_buf, \"DestroyBuffer=%s\",\n\t\t\t   burst_buffer_ptr->destroy_buffer);\n\t}\n\n\t/****** Line ******/\n\txstrcat(out_buf, line_end);\n\txstrfmtcat(out_buf, \"GetSysState=%s\",\n\t\t   burst_buffer_ptr->get_sys_state);\n\n\t/****** Line ******/\n\txstrcat(out_buf, line_end);\n\txstrfmtcat(out_buf, \"GetSysStatus=%s\",\n\t\t   burst_buffer_ptr->get_sys_status);\n\n\t/****** Line (optional) ******/\n\tif (burst_buffer_ptr->start_stage_in) {\n\t\txstrcat(out_buf, line_end);\n\t\txstrfmtcat(out_buf, \"StartStageIn=%s\",\n\t\t\t   burst_buffer_ptr->start_stage_in);\n\t}\n\n\t/****** Line ******/\n\tif (burst_buffer_ptr->start_stage_out) {\n\t\txstrcat(out_buf, line_end);\n\t\txstrfmtcat(out_buf, \"StartStageIn=%s\",\n\t\t\t   burst_buffer_ptr->start_stage_out);\n\t}\n\n\t/****** Line (optional) ******/\n\tif (burst_buffer_ptr->stop_stage_in) {\n\t\txstrcat(out_buf, line_end);\n\t\txstrfmtcat(out_buf, \"StopStageIn=%s\",\n\t\t\t   burst_buffer_ptr->stop_stage_in);\n\t}\n\n\t/****** Line (optional) ******/\n\tif (burst_buffer_ptr->stop_stage_out) {\n\t\txstrcat(out_buf, line_end);\n\t\txstrfmtcat(out_buf, \"StopStageIn=%s\",\n\t\t\t   burst_buffer_ptr->stop_stage_out);\n\t}\n\n\txstrcat(out_buf, \"\\n\");\n\tfprintf(out, \"%s\", out_buf);\n\txfree(out_buf);\n\n\t/****** Lines (optional) ******/\n\tif (burst_buffer_ptr->buffer_count)\n\t\tfprintf(out, \"  Allocated Buffers:\\n\");\n\tfor (i = 0, bb_resv_ptr = burst_buffer_ptr->burst_buffer_resv_ptr;\n\t     i < burst_buffer_ptr->buffer_count; i++, bb_resv_ptr++) {\n\t\t _print_burst_buffer_resv(out, bb_resv_ptr, one_liner, verbose);\n\t}\n\n\t/****** Lines (optional) ******/\n\tif (burst_buffer_ptr->use_count)\n\t\tfprintf(out, \"  Per User Buffer Use:\\n\");\n\tfor (i = 0, bb_use_ptr = burst_buffer_ptr->burst_buffer_use_ptr;\n\t     i < burst_buffer_ptr->use_count; i++, bb_use_ptr++) {\n\t\t _print_burst_buffer_use(out, bb_use_ptr, one_liner);\n\t}\n}", "path": "slurm/src/api/burst_buffer_info.c", "commit_date": "2018-09-28 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*****************************************************************************\n * UNIT TESTS                                                                *\n ****************************************************************************/\n", "func_signal": "START_TEST(test_init_free)", "code": "{\n\txhash_t* ht = NULL;\n\n\tmark_point();\n\n\t/* invalid case */\n\tht = xhash_init(NULL, NULL);\n\tfail_unless(ht == NULL, \"allocated table without identifying function\");\n\n\t/* alloc and free */\n\tht = xhash_init(hashable_identify, NULL);\n\tfail_unless(ht != NULL, \"hash table was not allocated\");\n\txhash_free(ht);\n}", "path": "slurm/testsuite/slurm_unit/common/xhash-test.c", "commit_date": "2020-01-09 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/* Queue saving of partition state information */\n", "func_signal": "extern void schedule_part_save(void)", "code": "{\n\tslurm_mutex_lock(&state_save_lock);\n\tsave_parts++;\n\tslurm_cond_broadcast(&state_save_cond);\n\tslurm_mutex_unlock(&state_save_lock);\n}", "path": "slurm/src/slurmctld/state_save.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*****************************************************************************\n * TEST SUITE                                                                *\n ****************************************************************************/\n", "func_signal": "Suite *xhash_suite(void)", "code": "{\n\tSuite *s = suite_create(\"xhash\");\n\tTCase *tc_core = tcase_create(\"Core\");\n\ttcase_add_checked_fixture(tc_core, setup, teardown);\n\ttcase_add_test(tc_core, test_init_free);\n\ttcase_add_test(tc_core, test_add);\n\ttcase_add_test(tc_core, test_find);\n\ttcase_add_test(tc_core, test_delete);\n\ttcase_add_test(tc_core, test_count);\n\ttcase_add_test(tc_core, test_walk);\n\tsuite_add_tcase(s, tc_core);\n\treturn s;\n}", "path": "slurm/testsuite/slurm_unit/common/xhash-test.c", "commit_date": "2020-01-09 00:00:00", "repo_name": "SchedMD/slurm", "stars": 2245, "license": "other", "language": "c", "size": 312712}
{"docstring": "/*\n * Parse text into a JSON object. If text is valid JSON, returns a\n * json_t structure, otherwise prints and error and returns null.\n */\n", "func_signal": "json_t *load_json(const char *text)", "code": "{\n    json_t *root;\n    json_error_t error;\n\n    root = json_loads(text, 0, &error);\n\n    if (root) {\n        return root;\n    } else {\n        fprintf(stderr, \"json error on line %d: %s\\n\", error.line, error.text);\n        return (json_t *)0;\n    }\n}", "path": "jansson/examples/simple_parse.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** lexical analyzer ***/\n", "func_signal": "static void stream_init(stream_t *stream, get_func get, void *data)", "code": "{\n    stream->get = get;\n    stream->data = data;\n    stream->buffer[0] = '\\0';\n    stream->buffer_pos = 0;\n\n    stream->state = STREAM_STATE_OK;\n    stream->line = 1;\n    stream->column = 0;\n    stream->position = 0;\n}", "path": "jansson/src/load.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/* returns 0 on success, -1 if key was not found */\n", "func_signal": "static int hashtable_do_del(hashtable_t *hashtable, const char *key, size_t key_len,\n                            size_t hash)", "code": "{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n\n    index = hash & hashmask(hashtable->order);\n    bucket = &hashtable->buckets[index];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, key_len, hash);\n    if (!pair)\n        return -1;\n\n    if (&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n\n    else if (&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n\n    else if (&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n\n    list_remove(&pair->list);\n    list_remove(&pair->ordered_list);\n    json_decref(pair->value);\n\n    jsonp_free(pair);\n    hashtable->size--;\n\n    return 0;\n}", "path": "jansson/src/hashtable.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*\n * Print a prompt and return (by reference) a null-terminated line of\n * text.  Returns NULL on eof or some error.\n */\n", "func_signal": "char *read_line(char *line, int max_chars)", "code": "{\n    printf(\"Type some JSON > \");\n    fflush(stdout);\n    return fgets(line, max_chars, stdin);\n}", "path": "jansson/examples/simple_parse.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/* Return the offset of the first newline in text or the length of\n   text if there's no newline */\n", "func_signal": "static int newline_offset(const char *text)", "code": "{\n    const char *newline = strchr(text, '\\n');\n    if (!newline)\n        return strlen(text);\n    else\n        return (int)(newline - text);\n}", "path": "jansson/doc/github_commits.c", "commit_date": "2019-10-21 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** error reporting ***/\n", "func_signal": "static void error_set(json_error_t *error, const lex_t *lex, enum json_error_code code,\n                      const char *msg, ...)", "code": "{\n    va_list ap;\n    char msg_text[JSON_ERROR_TEXT_LENGTH];\n    char msg_with_context[JSON_ERROR_TEXT_LENGTH];\n\n    int line = -1, col = -1;\n    size_t pos = 0;\n    const char *result = msg_text;\n\n    if (!error)\n        return;\n\n    va_start(ap, msg);\n    vsnprintf(msg_text, JSON_ERROR_TEXT_LENGTH, msg, ap);\n    msg_text[JSON_ERROR_TEXT_LENGTH - 1] = '\\0';\n    va_end(ap);\n\n    if (lex) {\n        const char *saved_text = strbuffer_value(&lex->saved_text);\n\n        line = lex->stream.line;\n        col = lex->stream.column;\n        pos = lex->stream.position;\n\n        if (saved_text && saved_text[0]) {\n            if (lex->saved_text.length <= 20) {\n                snprintf(msg_with_context, JSON_ERROR_TEXT_LENGTH, \"%s near '%s'\",\n                         msg_text, saved_text);\n                msg_with_context[JSON_ERROR_TEXT_LENGTH - 1] = '\\0';\n                result = msg_with_context;\n            }\n        } else {\n            if (code == json_error_invalid_syntax) {\n                /* More specific error code for premature end of file. */\n                code = json_error_premature_end_of_input;\n            }\n            if (lex->stream.state == STREAM_STATE_ERROR) {\n                /* No context for UTF-8 decoding errors */\n                result = msg_text;\n            } else {\n                snprintf(msg_with_context, JSON_ERROR_TEXT_LENGTH, \"%s near end of file\",\n                         msg_text);\n                msg_with_context[JSON_ERROR_TEXT_LENGTH - 1] = '\\0';\n                result = msg_with_context;\n            }\n        }\n    }\n\n    jsonp_error_set(error, line, col, pos, code, \"%s\", result);\n}", "path": "jansson/src/load.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/* helpers */\n", "func_signal": "static void create_and_free_complex_object()", "code": "{\n    json_t *obj;\n\n    obj = json_pack(\"{s:i,s:n,s:b,s:b,s:{s:s},s:[i,i,i]}\", \"foo\", 42, \"bar\", \"baz\", 1,\n                    \"qux\", 0, \"alice\", \"bar\", \"baz\", \"bob\", 9, 8, 7);\n\n    json_decref(obj);\n}", "path": "jansson/test/suites/api/test_memory_funcs.c", "commit_date": "2019-10-21 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** equality ***/\n", "func_signal": "int json_equal(const json_t *json1, const json_t *json2)", "code": "{\n    if (!json1 || !json2)\n        return 0;\n\n    if (json_typeof(json1) != json_typeof(json2))\n        return 0;\n\n    /* this covers true, false and null as they are singletons */\n    if (json1 == json2)\n        return 1;\n\n    switch (json_typeof(json1)) {\n        case JSON_OBJECT:\n            return json_object_equal(json1, json2);\n        case JSON_ARRAY:\n            return json_array_equal(json1, json2);\n        case JSON_STRING:\n            return json_string_equal(json1, json2);\n        case JSON_INTEGER:\n            return json_integer_equal(json1, json2);\n        case JSON_REAL:\n            return json_real_equal(json1, json2);\n        default:\n            return 0;\n    }\n}", "path": "jansson/src/value.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/* assumes that str points to 'u' plus at least 4 valid hex digits */\n", "func_signal": "static int32_t decode_unicode_escape(const char *str)", "code": "{\n    int i;\n    int32_t value = 0;\n\n    assert(str[0] == 'u');\n\n    for (i = 1; i <= 4; i++) {\n        char c = str[i];\n        value <<= 4;\n        if (l_isdigit(c))\n            value += c - '0';\n        else if (l_islower(c))\n            value += c - 'a' + 10;\n        else if (l_isupper(c))\n            value += c - 'A' + 10;\n        else\n            return -1;\n    }\n\n    return value;\n}", "path": "jansson/src/load.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "// INFINITY\n", "func_signal": "static void test_bad_args(void)", "code": "{\n    json_t *txt = json_string(\"test\");\n\n    if (json_integer_value(NULL) != 0)\n        fail(\"json_integer_value did not return 0 for non-integer\");\n    if (json_integer_value(txt) != 0)\n        fail(\"json_integer_value did not return 0 for non-integer\");\n\n    if (!json_integer_set(NULL, 0))\n        fail(\"json_integer_set did not return error for non-integer\");\n    if (!json_integer_set(txt, 0))\n        fail(\"json_integer_set did not return error for non-integer\");\n\n    if (json_real_value(NULL) != 0.0)\n        fail(\"json_real_value did not return 0.0 for non-real\");\n    if (json_real_value(txt) != 0.0)\n        fail(\"json_real_value did not return 0.0 for non-real\");\n\n    if (!json_real_set(NULL, 0.0))\n        fail(\"json_real_set did not return error for non-real\");\n    if (!json_real_set(txt, 0.0))\n        fail(\"json_real_set did not return error for non-real\");\n\n    if (json_number_value(NULL) != 0.0)\n        fail(\"json_number_value did not return 0.0 for non-numeric\");\n    if (json_number_value(txt) != 0.0)\n        fail(\"json_number_value did not return 0.0 for non-numeric\");\n\n    if (txt->refcount != 1)\n        fail(\"unexpected reference count for txt\");\n\n    json_decref(txt);\n}", "path": "jansson/test/suites/api/test_number.c", "commit_date": "2019-10-21 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** number ***/\n", "func_signal": "double json_number_value(const json_t *json)", "code": "{\n    if (json_is_integer(json))\n        return (double)json_integer_value(json);\n    else if (json_is_real(json))\n        return json_real_value(json);\n    else\n        return 0.0;\n}", "path": "jansson/src/value.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** copying ***/\n", "func_signal": "json_t *json_copy(json_t *json)", "code": "{\n    if (!json)\n        return NULL;\n\n    switch (json_typeof(json)) {\n        case JSON_OBJECT:\n            return json_object_copy(json);\n        case JSON_ARRAY:\n            return json_array_copy(json);\n        case JSON_STRING:\n            return json_string_copy(json);\n        case JSON_INTEGER:\n            return json_integer_copy(json);\n        case JSON_REAL:\n            return json_real_copy(json);\n        case JSON_TRUE:\n        case JSON_FALSE:\n        case JSON_NULL:\n            return json;\n        default:\n            return NULL;\n    }\n}", "path": "jansson/src/value.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** integer ***/\n", "func_signal": "json_t *json_integer(json_int_t value)", "code": "{\n    json_integer_t *integer = jsonp_malloc(sizeof(json_integer_t));\n    if (!integer)\n        return NULL;\n    json_init(&integer->json, JSON_INTEGER);\n\n    integer->value = value;\n    return &integer->json;\n}", "path": "jansson/src/value.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/* Call the simple functions not covered by other tests of the public API */\n", "func_signal": "static void run_tests()", "code": "{\n    json_t *value;\n\n    value = json_boolean(1);\n    if (!json_is_true(value))\n        fail(\"json_boolean(1) failed\");\n    json_decref(value);\n\n    value = json_boolean(-123);\n    if (!json_is_true(value))\n        fail(\"json_boolean(-123) failed\");\n    json_decref(value);\n\n    value = json_boolean(0);\n    if (!json_is_false(value))\n        fail(\"json_boolean(0) failed\");\n    if (json_boolean_value(value) != 0)\n        fail(\"json_boolean_value failed\");\n    json_decref(value);\n\n    value = json_integer(1);\n    if (json_typeof(value) != JSON_INTEGER)\n        fail(\"json_typeof failed\");\n\n    if (json_is_object(value))\n        fail(\"json_is_object failed\");\n\n    if (json_is_array(value))\n        fail(\"json_is_array failed\");\n\n    if (json_is_string(value))\n        fail(\"json_is_string failed\");\n\n    if (!json_is_integer(value))\n        fail(\"json_is_integer failed\");\n\n    if (json_is_real(value))\n        fail(\"json_is_real failed\");\n\n    if (!json_is_number(value))\n        fail(\"json_is_number failed\");\n\n    if (json_is_true(value))\n        fail(\"json_is_true failed\");\n\n    if (json_is_false(value))\n        fail(\"json_is_false failed\");\n\n    if (json_is_boolean(value))\n        fail(\"json_is_boolean failed\");\n\n    if (json_is_null(value))\n        fail(\"json_is_null failed\");\n\n    json_decref(value);\n\n    value = json_string(\"foo\");\n    if (!value)\n        fail(\"json_string failed\");\n    if (strcmp(json_string_value(value), \"foo\"))\n        fail(\"invalid string value\");\n    if (json_string_length(value) != 3)\n        fail(\"invalid string length\");\n\n    if (json_string_set(value, \"barr\"))\n        fail(\"json_string_set failed\");\n    if (strcmp(json_string_value(value), \"barr\"))\n        fail(\"invalid string value\");\n    if (json_string_length(value) != 4)\n        fail(\"invalid string length\");\n\n    if (json_string_setn(value, \"hi\\0ho\", 5))\n        fail(\"json_string_set failed\");\n    if (memcmp(json_string_value(value), \"hi\\0ho\\0\", 6))\n        fail(\"invalid string value\");\n    if (json_string_length(value) != 5)\n        fail(\"invalid string length\");\n\n    json_decref(value);\n\n    value = json_string(NULL);\n    if (value)\n        fail(\"json_string(NULL) failed\");\n\n    /* invalid UTF-8  */\n    value = json_string(\"a\\xefz\");\n    if (value)\n        fail(\"json_string(<invalid utf-8>) failed\");\n\n    value = json_string_nocheck(\"foo\");\n    if (!value)\n        fail(\"json_string_nocheck failed\");\n    if (strcmp(json_string_value(value), \"foo\"))\n        fail(\"invalid string value\");\n    if (json_string_length(value) != 3)\n        fail(\"invalid string length\");\n\n    if (json_string_set_nocheck(value, \"barr\"))\n        fail(\"json_string_set_nocheck failed\");\n    if (strcmp(json_string_value(value), \"barr\"))\n        fail(\"invalid string value\");\n    if (json_string_length(value) != 4)\n        fail(\"invalid string length\");\n\n    if (json_string_setn_nocheck(value, \"hi\\0ho\", 5))\n        fail(\"json_string_set failed\");\n    if (memcmp(json_string_value(value), \"hi\\0ho\\0\", 6))\n        fail(\"invalid string value\");\n    if (json_string_length(value) != 5)\n        fail(\"invalid string length\");\n\n    json_decref(value);\n\n    /* invalid UTF-8 */\n    value = json_string_nocheck(\"qu\\xff\");\n    if (!value)\n        fail(\"json_string_nocheck failed\");\n    if (strcmp(json_string_value(value), \"qu\\xff\"))\n        fail(\"invalid string value\");\n    if (json_string_length(value) != 3)\n        fail(\"invalid string length\");\n\n    if (json_string_set_nocheck(value, \"\\xfd\\xfe\\xff\"))\n        fail(\"json_string_set_nocheck failed\");\n    if (strcmp(json_string_value(value), \"\\xfd\\xfe\\xff\"))\n        fail(\"invalid string value\");\n    if (json_string_length(value) != 3)\n        fail(\"invalid string length\");\n\n    json_decref(value);\n\n    value = json_integer(123);\n    if (!value)\n        fail(\"json_integer failed\");\n    if (json_integer_value(value) != 123)\n        fail(\"invalid integer value\");\n    if (json_number_value(value) != 123.0)\n        fail(\"invalid number value\");\n\n    if (json_integer_set(value, 321))\n        fail(\"json_integer_set failed\");\n    if (json_integer_value(value) != 321)\n        fail(\"invalid integer value\");\n    if (json_number_value(value) != 321.0)\n        fail(\"invalid number value\");\n\n    json_decref(value);\n\n    value = json_real(123.123);\n    if (!value)\n        fail(\"json_real failed\");\n    if (json_real_value(value) != 123.123)\n        fail(\"invalid integer value\");\n    if (json_number_value(value) != 123.123)\n        fail(\"invalid number value\");\n\n    if (json_real_set(value, 321.321))\n        fail(\"json_real_set failed\");\n    if (json_real_value(value) != 321.321)\n        fail(\"invalid real value\");\n    if (json_number_value(value) != 321.321)\n        fail(\"invalid number value\");\n\n    json_decref(value);\n\n    value = json_true();\n    if (!value)\n        fail(\"json_true failed\");\n    json_decref(value);\n\n    value = json_false();\n    if (!value)\n        fail(\"json_false failed\");\n    json_decref(value);\n\n    value = json_null();\n    if (!value)\n        fail(\"json_null failed\");\n    json_decref(value);\n\n    /* Test reference counting on singletons (true, false, null) */\n    value = json_true();\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting true works incorrectly\");\n    json_decref(value);\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting true works incorrectly\");\n    json_incref(value);\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting true works incorrectly\");\n\n    value = json_false();\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting false works incorrectly\");\n    json_decref(value);\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting false works incorrectly\");\n    json_incref(value);\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting false works incorrectly\");\n\n    value = json_null();\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting null works incorrectly\");\n    json_decref(value);\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting null works incorrectly\");\n    json_incref(value);\n    if (value->refcount != (size_t)-1)\n        fail(\"refcounting null works incorrectly\");\n\n#ifdef json_auto_t\n    value = json_string(\"foo\");\n    {\n        json_auto_t *test = json_incref(value);\n        /* Use test so GCC doesn't complain it is unused. */\n        if (!json_is_string(test))\n            fail(\"value type check failed\");\n    }\n    if (value->refcount != 1)\n        fail(\"automatic decrement failed\");\n    json_decref(value);\n#endif\n\n    test_bad_args();\n}", "path": "jansson/test/suites/api/test_simple.c", "commit_date": "2019-10-21 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** simple values ***/\n", "func_signal": "json_t *json_true(void)", "code": "{\n    static json_t the_true = {JSON_TRUE, (size_t)-1};\n    return &the_true;\n}", "path": "jansson/src/value.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*\n  Test the secure memory functions code given in the API reference\n  documentation, but by using plain memset instead of\n  guaranteed_memset().\n*/\n", "func_signal": "static void *secure_malloc(size_t size)", "code": "{\n    /* Store the memory area size in the beginning of the block */\n    void *ptr = malloc(size + 8);\n    *((size_t *)ptr) = size;\n    return (char *)ptr + 8;\n}", "path": "jansson/test/suites/api/test_memory_funcs.c", "commit_date": "2019-10-21 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*\n  - This code assumes that the decimal separator is exactly one\n    character.\n\n  - If setlocale() is called by another thread between the call to\n    localeconv() and the call to sprintf() or strtod(), the result may\n    be wrong. setlocale() is not thread-safe and should not be used\n    this way. Multi-threaded programs should use uselocale() instead.\n*/\n", "func_signal": "static void to_locale(strbuffer_t *strbuffer)", "code": "{\n    const char *point;\n    char *pos;\n\n    point = localeconv()->decimal_point;\n    if (*point == '.') {\n        /* No conversion needed */\n        return;\n    }\n\n    pos = strchr(strbuffer->value, '.');\n    if (pos)\n        *pos = *point;\n}", "path": "jansson/src/strconv.c", "commit_date": "2019-10-21 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/* ours will be set to 1 if jsonp_free() must be called for the result\n   afterwards */\n", "func_signal": "static char *read_string(scanner_t *s, va_list *ap, const char *purpose, size_t *out_len,\n                         int *ours, int optional)", "code": "{\n    char t;\n    strbuffer_t strbuff;\n    const char *str;\n    size_t length;\n\n    next_token(s);\n    t = token(s);\n    prev_token(s);\n\n    *ours = 0;\n    if (t != '#' && t != '%' && t != '+') {\n        /* Optimize the simple case */\n        str = va_arg(*ap, const char *);\n\n        if (!str) {\n            if (!optional) {\n                set_error(s, \"<args>\", json_error_null_value, \"NULL %s\", purpose);\n                s->has_error = 1;\n            }\n            return NULL;\n        }\n\n        length = strlen(str);\n\n        if (!utf8_check_string(str, length)) {\n            set_error(s, \"<args>\", json_error_invalid_utf8, \"Invalid UTF-8 %s\", purpose);\n            s->has_error = 1;\n            return NULL;\n        }\n\n        *out_len = length;\n        return (char *)str;\n    } else if (optional) {\n        set_error(s, \"<format>\", json_error_invalid_format,\n                  \"Cannot use '%c' on optional strings\", t);\n        s->has_error = 1;\n\n        return NULL;\n    }\n\n    if (strbuffer_init(&strbuff)) {\n        set_error(s, \"<internal>\", json_error_out_of_memory, \"Out of memory\");\n        s->has_error = 1;\n    }\n\n    while (1) {\n        str = va_arg(*ap, const char *);\n        if (!str) {\n            set_error(s, \"<args>\", json_error_null_value, \"NULL %s\", purpose);\n            s->has_error = 1;\n        }\n\n        next_token(s);\n\n        if (token(s) == '#') {\n            length = va_arg(*ap, int);\n        } else if (token(s) == '%') {\n            length = va_arg(*ap, size_t);\n        } else {\n            prev_token(s);\n            length = s->has_error ? 0 : strlen(str);\n        }\n\n        if (!s->has_error && strbuffer_append_bytes(&strbuff, str, length) == -1) {\n            set_error(s, \"<internal>\", json_error_out_of_memory, \"Out of memory\");\n            s->has_error = 1;\n        }\n\n        next_token(s);\n        if (token(s) != '+') {\n            prev_token(s);\n            break;\n        }\n    }\n\n    if (s->has_error) {\n        strbuffer_close(&strbuff);\n        return NULL;\n    }\n\n    if (!utf8_check_string(strbuff.value, strbuff.length)) {\n        set_error(s, \"<args>\", json_error_invalid_utf8, \"Invalid UTF-8 %s\", purpose);\n        strbuffer_close(&strbuff);\n        s->has_error = 1;\n        return NULL;\n    }\n\n    *out_len = strbuff.length;\n    *ours = 1;\n    return strbuffer_steal_value(&strbuff);\n}", "path": "jansson/src/pack_unpack.c", "commit_date": "2020-08-12 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** string ***/\n", "func_signal": "static json_t *string_create(const char *value, size_t len, int own)", "code": "{\n    char *v;\n    json_string_t *string;\n\n    if (!value)\n        return NULL;\n\n    if (own)\n        v = (char *)value;\n    else {\n        v = jsonp_strndup(value, len);\n        if (!v)\n            return NULL;\n    }\n\n    string = jsonp_malloc(sizeof(json_string_t));\n    if (!string) {\n        jsonp_free(v);\n        return NULL;\n    }\n    json_init(&string->json, JSON_STRING);\n    string->value = v;\n    string->length = len;\n\n    return &string->json;\n}", "path": "jansson/src/value.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*** deletion ***/\n", "func_signal": "void json_delete(json_t *json)", "code": "{\n    if (!json)\n        return;\n\n    switch (json_typeof(json)) {\n        case JSON_OBJECT:\n            json_delete_object(json_to_object(json));\n            break;\n        case JSON_ARRAY:\n            json_delete_array(json_to_array(json));\n            break;\n        case JSON_STRING:\n            json_delete_string(json_to_string(json));\n            break;\n        case JSON_INTEGER:\n            json_delete_integer(json_to_integer(json));\n            break;\n        case JSON_REAL:\n            json_delete_real(json_to_real(json));\n            break;\n        default:\n            return;\n    }\n\n    /* json_delete is not called for true, false or null */\n}", "path": "jansson/src/value.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "akheron/jansson", "stars": 2954, "license": "mit", "language": "c", "size": 1789}
{"docstring": "/*\n * Allocate a new float object with the given `val`.\n */\n", "func_signal": "luna_object_t *\nluna_float_new(float val)", "code": "{\n  luna_object_t *self = alloc_object(LUNA_TYPE_FLOAT);\n  if (unlikely(!self)) return NULL;\n  self->value.as_float = val;\n  return self;\n}", "path": "luna/src/object.c", "commit_date": "2016-03-07 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a new id node with the given `val`.\n */\n", "func_signal": "luna_id_node_t *\nluna_id_node_new(const char *val, int lineno)", "code": "{\n  luna_id_node_t *self = malloc(sizeof(luna_id_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_ID;\n  self->base.lineno = lineno;\n  self->val = val;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a new string node with the given `val`.\n */\n", "func_signal": "luna_string_node_t *\nluna_string_node_new(const char *val, int lineno)", "code": "{\n  luna_string_node_t *self = malloc(sizeof(luna_string_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_STRING;\n  self->base.lineno = lineno;\n  self->val = val;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a binary `op` node with `left` and `right` nodes.\n */\n", "func_signal": "luna_binary_op_node_t *\nluna_binary_op_node_new(luna_token op, luna_node_t *left, luna_node_t *right, int lineno)", "code": "{\n  luna_binary_op_node_t *self = malloc(sizeof(luna_binary_op_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_BINARY_OP;\n  self->base.lineno = lineno;\n  self->op = op;\n  self->left = left;\n  self->right = right;\n  self->let = 0;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a new type noe with the given `name`.\n */\n", "func_signal": "luna_type_node_t *\nluna_type_node_new(const char *name, int lineno)", "code": "{\n  luna_type_node_t *self = malloc(sizeof(luna_type_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_TYPE;\n  self->base.lineno = lineno;\n  self->name = name;\n  self->fields = luna_vec_new();\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Initialize lexer with the given `source` and `filename`.\n */\n", "func_signal": "void\nluna_lexer_init(luna_lexer_t *self, char *source, const char *filename)", "code": "{\n  self->error = NULL;\n  self->source = source;\n  self->filename = filename;\n  self->lineno = 1;\n  self->offset = 0;\n}", "path": "luna/src/lexer.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Set hash `key` to `val`.\n */\n", "func_signal": "inline void\nluna_hash_set(khash_t(value) *self, char *key, luna_object_t *val)", "code": "{\n  int ret;\n  khiter_t k = kh_put(value, self, key, &ret);\n  kh_value(self, k) = val;\n}", "path": "luna/src/hash.c", "commit_date": "2013-03-30 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize slot access node with `left` and `right`.\n */\n", "func_signal": "luna_slot_node_t *\nluna_slot_node_new(luna_node_t *left, luna_node_t *right, int lineno)", "code": "{\n  luna_slot_node_t *self = malloc(sizeof(luna_slot_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_SLOT;\n  self->base.lineno = lineno;\n  self->left = left;\n  self->right = right;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Allocate a new bool object with the given `val`.\n */\n", "func_signal": "luna_object_t *\nluna_bool_new(bool val)", "code": "{\n  luna_object_t *self = alloc_object(LUNA_TYPE_BOOL);\n  if (unlikely(!self)) return NULL;\n  self->value.as_int = val;\n  return self;\n}", "path": "luna/src/object.c", "commit_date": "2016-03-07 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a new return node with the given `expr`.\n */\n", "func_signal": "luna_return_node_t *\nluna_return_node_new(luna_node_t *expr, int lineno)", "code": "{\n  luna_return_node_t *self = malloc(sizeof(luna_return_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_RETURN;\n  self->base.lineno = lineno;\n  self->expr = expr;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Remove hash `key`.\n */\n", "func_signal": "void\nluna_hash_remove(khash_t(value) *self, char *key)", "code": "{\n  khiter_t k = kh_get(value, self, key);\n  kh_del(value, self, k);\n}", "path": "luna/src/hash.c", "commit_date": "2013-03-30 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Allocate an initialize a new object of the given `type`.\n */\n", "func_signal": "static luna_object_t *\nalloc_object(luna_object type)", "code": "{\n  luna_object_t *self = malloc(sizeof(luna_object_t));\n  if (unlikely(!self)) return NULL;\n  self->type = type;\n  return self;\n}", "path": "luna/src/object.c", "commit_date": "2016-03-07 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Scan string hex literal, returning -1 on invalid digits.\n */\n", "func_signal": "static int\nhex_literal(luna_lexer_t *self)", "code": "{\n  int a = hex(next);\n  int b = hex(next);\n  if (a > -1 && b > -1) return a << 4 | b;\n  error(\"string hex literal \\\\x contains invalid digits\");\n  return -1;\n}", "path": "luna/src/lexer.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Get hash `key`, or NULL.\n */\n", "func_signal": "inline luna_object_t *\nluna_hash_get(khash_t(value) *self, char *key)", "code": "{\n  khiter_t k = kh_get(value, self, key);\n  return k == kh_end(self) ? NULL : kh_value(self, k);\n}", "path": "luna/src/hash.c", "commit_date": "2013-03-30 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a new int node with the given `val`.\n */\n", "func_signal": "luna_int_node_t *\nluna_int_node_new(int val, int lineno)", "code": "{\n  luna_int_node_t *self = malloc(sizeof(luna_int_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_INT;\n  self->base.lineno = lineno;\n  self->val = val;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a new args node.\n */\n", "func_signal": "luna_args_node_t *\nluna_args_node_new(int lineno)", "code": "{\n  luna_args_node_t *self = malloc(sizeof(luna_args_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_ARGS;\n  self->base.lineno = lineno;\n  self->vec = luna_vec_new();\n  self->hash = luna_hash_new();\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc a luna value and assign the given `node`.\n */\n", "func_signal": "luna_object_t *\nluna_node(luna_node_t *node)", "code": "{\n  luna_object_t *self = malloc(sizeof(luna_object_t));\n  if (unlikely(!self)) return NULL;\n  self->type = LUNA_TYPE_NODE;\n  self->value.as_pointer = node;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a new hash node.\n */\n", "func_signal": "luna_hash_pair_node_t *\nluna_hash_pair_node_new(int lineno)", "code": "{\n  luna_hash_pair_node_t *self = malloc(sizeof(luna_hash_pair_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_HASH_PAIR;\n  self->base.lineno = lineno;\n  self->key = NULL;\n  self->val = NULL;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Print `self` to stdout.\n */\n", "func_signal": "void\nluna_object_inspect(luna_object_t *self)", "code": "{\n  switch (self->type) {\n    case LUNA_TYPE_FLOAT:\n      printf(\"%2f\\n\", self->value.as_float);\n      break;\n    case LUNA_TYPE_INT:\n      printf(\"%d\\n\", self->value.as_int);\n      break;\n\tcase LUNA_TYPE_BOOL:\n\t  printf(\"%s\\n\", self->value.as_int ? \"true\" : \"false\");\n\t  break;\n\tcase LUNA_TYPE_STRING:\n\t  printf(\"%s\\n\", (char *)self->value.as_pointer);\n\t  break;\n    default:\n      assert(0 && \"unhandled\");\n  }\n}", "path": "luna/src/object.c", "commit_date": "2016-03-07 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "/*\n * Alloc and initialize a new while loop node, negated for \"until\",\n * otherwise \"while\", with required `expr` and `block`.\n */\n", "func_signal": "luna_while_node_t *\nluna_while_node_new(int negate, luna_node_t *expr, luna_block_node_t *block, int lineno)", "code": "{\n  luna_while_node_t *self = malloc(sizeof(luna_while_node_t));\n  if (unlikely(!self)) return NULL;\n  self->base.type = LUNA_NODE_WHILE;\n  self->base.lineno = lineno;\n  self->negate = negate;\n  self->expr = expr;\n  self->block = block;\n  return self;\n}", "path": "luna/src/ast.c", "commit_date": "2016-03-11 00:00:00", "repo_name": "tj/luna", "stars": 2449, "license": "None", "language": "c", "size": 1035}
{"docstring": "// Sends data through raw socket.\n", "func_signal": "static int send_packet(uint8_t broadcast)", "code": "{\n  struct sockaddr_ll dest_sll;\n  dhcp_raw_t packet;\n  unsigned padding;\n  int fd, result = -1;\n  uint8_t bmacaddr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n  memset(&packet, 0, sizeof(dhcp_raw_t));\n  memcpy(&packet.dhcp, &gstate.send.send_pkt, sizeof(dhcp_msg_t));\n\n  if ((fd = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP))) < 0) {\n    dbg(\"SEND : socket failed\\n\");\n    return -1;\n  }\n  memset(&dest_sll, 0, sizeof(dest_sll));\n  dest_sll.sll_family = AF_PACKET;\n  dest_sll.sll_protocol = htons(ETH_P_IP);\n  dest_sll.sll_ifindex = gconfig.ifindex;\n  dest_sll.sll_halen = 6;\n  memcpy(dest_sll.sll_addr, (broadcast)?bmacaddr:gstate.rcvd.rcvd_pkt.chaddr , 6);\n\n  if (bind(fd, (struct sockaddr *) &dest_sll, sizeof(dest_sll)) < 0) {\n    dbg(\"SEND : bind failed\\n\");\n    close(fd);\n    return -1;\n  }\n  padding = 308 - 1 - dhcp_opt_size(gstate.send.send_pkt.options);\n  packet.iph.protocol = IPPROTO_UDP;\n  packet.iph.saddr = gconfig.server_nip;\n  packet.iph.daddr = (broadcast || (gstate.rcvd.rcvd_pkt.ciaddr == 0))?\n    INADDR_BROADCAST : gstate.rcvd.rcvd_pkt.ciaddr;\n  packet.udph.source = htons(gconfig.port);//SERVER_PORT\n  packet.udph.dest = gstate.client_port; //CLIENT_PORT\n  packet.udph.len = htons(sizeof(dhcp_raw_t) - sizeof(struct iphdr) - padding);\n  packet.iph.tot_len = packet.udph.len;\n  packet.udph.check = dhcp_checksum(&packet, sizeof(dhcp_raw_t) - padding);\n  packet.iph.tot_len = htons(sizeof(dhcp_raw_t) - padding);\n  packet.iph.ihl = sizeof(packet.iph) >> 2;\n  packet.iph.version = IPVERSION;\n  packet.iph.ttl = IPDEFTTL;\n  packet.iph.check = dhcp_checksum(&packet.iph, sizeof(packet.iph));\n\n  result = sendto(fd, &packet, sizeof(dhcp_raw_t) - padding, 0,\n      (struct sockaddr *) &dest_sll, sizeof(dest_sll));\n\n  dbg(\"sendto %d\\n\", result);\n  close(fd);\n  if (result < 0) dbg(\"PACKET send error\\n\");\n  return result;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Parses the server config file and updates the global server config accordingly.\n", "func_signal": "static int parse_server_config(char *config_file, struct config_keyword *confkey)", "code": "{\n  FILE *fs = NULL;\n  char *confline_temp = NULL,*confline = NULL, *tk = NULL, *tokens[2] = {NULL, NULL};\n  int len, linelen, tcount, count, size = ARRAY_LEN(keywords);\n\n  for (count = 0; count < size; count++)\n    if (confkey[count].handler)\n      confkey[count].handler(confkey[count].def, confkey[count].var);\n\n  if (!(fs = fopen(config_file, \"r\"))) perror_msg(\"%s\", config_file);\n  for (len = 0, linelen = 0; fs;) {\n    len = getline(&confline_temp, (size_t*) &linelen, fs);\n    confline = confline_temp;\n    if (len <= 0) break;\n    for (; *confline == ' '; confline++, len--);\n    if ((confline[0] == '#') || (confline[0] == '\\n')) goto free_conf_continue;\n    tk = strchr(confline, '#');\n    if (tk) {\n      for (; *(tk-1)==' ' || *(tk-1)=='\\t'; tk--);\n      *tk = '\\0';\n    }\n    tk = strchr(confline, '\\n');\n    if (tk) {\n      for (; *(tk-1)==' ' || *(tk-1)=='\\t'; tk--);\n      *tk = '\\0';\n    }\n    for (tcount=0, tk=strtok(confline, \" \\t\"); tk && (tcount < 2);\n        tcount++, tk=strtok(NULL,(tcount==1)?\"\":\" \\t\")) {\n      while ((*tk == '\\t') || (*tk == ' ')) tk++;\n      tokens[tcount] = xstrdup(tk);\n    }\n    if (tcount<=1) goto free_tk0_continue;\n    for (count = 0; count < size; count++) {\n      if (!strcmp(confkey[count].keyword,tokens[0])) {\n        dbg(\"got config : %15s : \", confkey[count].keyword);\n        if (confkey[count].handler(tokens[1], confkey[count].var) == 0)\n          dbg(\"%s \\n\", tokens[1]);\n        break;\n      }\n    }\n    if (tokens[1]) { free(tokens[1]); tokens[1] = NULL; }\nfree_tk0_continue:\n    if (tokens[0]) { free(tokens[0]); tokens[0] = NULL; }\nfree_conf_continue:\n    free(confline_temp);\n    confline_temp = NULL;\n  }\n  if (fs) fclose(fs);\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Returns lease time for client.\n", "func_signal": "static uint32_t get_lease(uint32_t req_exp)", "code": "{\n  uint32_t now = time(NULL);\n  req_exp = req_exp - now;\n  if(addr_version == AF_INET6) {\n    if ((req_exp <= 0) || req_exp > gconfig.pref_lifetime ||\n        req_exp > gconfig.valid_lifetime) {\n      if ((gconfig.pref_lifetime > gconfig.valid_lifetime)) {\n        error_msg(\"The valid lifetime must be greater than the preferred lifetime, \\\n            setting to valid lifetime %u\", gconfig.valid_lifetime);\n        return gconfig.valid_lifetime;\n      }\n      return gconfig.pref_lifetime;\n    }\n  } else {\n    if ((req_exp <= 0) || (req_exp > gconfig.max_lease_sec))\n      return gconfig.max_lease_sec;\n\n    if (req_exp < gconfig.min_lease_sec)\n      return gconfig.min_lease_sec;\n  }\n\n  return req_exp;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// add ip assigned_nip to dynamic lease.\n", "func_signal": "static int addip_to_lease(uint32_t assigned_nip, uint8_t mac[6], uint32_t *req_exp, char *hostname, uint8_t update)", "code": "{\n  dyn_lease *dls;\n  struct arg_list *listdls = gstate.dleases;\n  uint32_t now = time(NULL);\n\n  while (listdls) {\n    if (!memcmp(((dyn_lease*) listdls->arg)->lease_mac, mac, 6)) {\n      if (update) *req_exp = get_lease(*req_exp + ((dyn_lease*) listdls->arg)->expires);\n      ((dyn_lease*) listdls->arg)->expires = *req_exp + now;\n      return 0;\n    }\n    listdls = listdls->next;\n  }\n\n  dls = xzalloc(sizeof(dyn_lease));\n  memcpy(dls->lease_mac, mac, 6);\n  dls->lease_nip = assigned_nip;\n  if (hostname) memcpy(dls->hostname, hostname, 20);\n\n  if (update) *req_exp = get_lease(*req_exp + now);\n  dls->expires = *req_exp + now;\n\n  listdls = xzalloc(sizeof(struct arg_list));\n  listdls->next = gstate.dleases;\n  listdls->arg = (char*)dls;\n  gstate.dleases = listdls;\n\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// signal setup for SIGUSR1 SIGTERM\n", "func_signal": "static int setup_signal()", "code": "{\n  if (pipe((int *)&sigfd) < 0) {\n    dbg(\"signal pipe failed\\n\");\n    return -1;\n  }\n  fcntl(sigfd.wr , F_SETFD, FD_CLOEXEC);\n  fcntl(sigfd.rd , F_SETFD, FD_CLOEXEC);\n  int flags = fcntl(sigfd.wr, F_GETFL);\n  fcntl(sigfd.wr, F_SETFL, flags | O_NONBLOCK);\n  signal(SIGUSR1, signal_handler);\n  signal(SIGTERM, signal_handler);\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Update max lease time from options.\n", "func_signal": "static void set_maxlease(void)", "code": "{\n  int count, size = ARRAY_LEN(options_list);\n  for (count = 0; count < size; count++)\n    if (options_list[count].val && options_list[count].code == (DHCP_OPT_LEASE_TIME)) {\n      gconfig.max_lease_sec = *((uint32_t*)options_list[count].val);\n      break;\n    }\n  if (!gconfig.max_lease_sec) gconfig.max_lease_sec = (60*60*24*10);// DEFAULT_LEASE_TIME;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// String to dhcp option conversion\n", "func_signal": "static int strtoopt(const char *str, void *var)", "code": "{\n  char *option, *valstr, *grp, *tp;\n  uint32_t optcode = 0, inf = infomode, convtmp, mask, nip, router;\n  uint16_t flag = 0;\n  int count, size = ARRAY_LEN(options_list);\n\n  if (!*str) return 0;\n  if (!(option = strtok((char*)str, \" \\t=\"))) return -1;\n\n  infomode = LOG_SILENT;\n  strtou32(option, (uint32_t*)&optcode);\n  infomode = inf;\n\n  if (optcode > 0 && optcode < 256) { // raw option\n    for (count = 0; count < size; count++) {\n      if ((options_list[count].code & 0X00FF) == optcode) {\n        flag = (options_list[count].code & 0XFF00);\n        break;\n      }\n    }\n  } else { //string option\n    for (count = 0; count < size; count++) {\n      if (!strncmp(options_list[count].key, option, strlen(options_list[count].key))) {\n        flag = (options_list[count].code & 0XFF00);\n        optcode = (options_list[count].code & 0X00FF);\n        break;\n      }\n    }\n  }\n  if (count == size) {\n    infomsg(inf, \"config : Obsolete OR Unknown Option : %s\", option);\n    return -1;\n  }\n\n  if (!flag || !optcode) return -1;\n\n  if (!(valstr = strtok(NULL, \" \\t\"))) {\n    dbg(\"config : option %s has no value defined.\\n\", option);\n    return -1;\n  }\n  dbg(\" value : %-20s : \", valstr);\n  switch (flag) {\n  case DHCP_NUM32:\n    options_list[count].len = sizeof(uint32_t);\n    options_list[count].val = xmalloc(sizeof(uint32_t));\n    strtou32(valstr, &convtmp);\n    memcpy(options_list[count].val, &convtmp, sizeof(uint32_t));\n    break;\n  case DHCP_NUM16:\n    options_list[count].len = sizeof(uint16_t);\n    options_list[count].val = xmalloc(sizeof(uint16_t));\n    strtou32(valstr, &convtmp);\n    memcpy(options_list[count].val, &convtmp, sizeof(uint16_t));\n    break;\n  case DHCP_NUM8:\n    options_list[count].len = sizeof(uint8_t);\n    options_list[count].val = xmalloc(sizeof(uint8_t));\n    strtou32(valstr, &convtmp);\n    memcpy(options_list[count].val, &convtmp, sizeof(uint8_t));\n    break;\n  case DHCP_IP:\n    options_list[count].len = sizeof(uint32_t);\n    options_list[count].val = xmalloc(sizeof(uint32_t));\n    striptovar(valstr, options_list[count].val);\n    break;\n  case DHCP_STRING:\n    options_list[count].len = strlen(valstr);\n    options_list[count].val = strdup(valstr);\n    break;\n  case DHCP_IPLIST:\n    while(valstr){\n      options_list[count].val = xrealloc(options_list[count].val, options_list[count].len + sizeof(uint32_t));\n      striptovar(valstr, ((uint8_t*)options_list[count].val)+options_list[count].len);\n      options_list[count].len += sizeof(uint32_t);\n      valstr = strtok(NULL,\" \\t\");\n    }\n    break;\n  case DHCP_IPPLST:\n    break;\n  case DHCP_STCRTS:\n    /* Option binary format:\n     * mask [one byte, 0..32]\n     * ip [0..4 bytes depending on mask]\n     * router [4 bytes]\n     * may be repeated\n     * staticroutes 10.0.0.0/8 10.127.0.1, 10.11.12.0/24 10.11.12.1\n     */\n    grp = strtok(valstr, \",\");;\n    while(grp){\n      while(*grp == ' ' || *grp == '\\t') grp++;\n      tp = strchr(grp, '/');\n      if (!tp) error_exit(\"wrong formatted static route option\");\n      *tp = '\\0';\n      mask = strtol(++tp, &tp, 10);\n      if (striptovar(grp, (uint8_t*)&nip)<0) error_exit(\"wrong formatted static route option\");\n      while(*tp == ' ' || *tp == '\\t' || *tp == '-') tp++;\n      if (striptovar(tp, (uint8_t*)&router)<0) error_exit(\"wrong formatted static route option\");\n      options_list[count].val = xrealloc(options_list[count].val, options_list[count].len + 1 + mask/8 + 4);\n      memcpy(((uint8_t*)options_list[count].val)+options_list[count].len, &mask, 1);\n      options_list[count].len += 1;\n      memcpy(((uint8_t*)options_list[count].val)+options_list[count].len, &nip, mask/8);\n      options_list[count].len += mask/8;\n      memcpy(((uint8_t*)options_list[count].val)+options_list[count].len, &router, 4);\n      options_list[count].len += 4;\n      tp = NULL;\n      grp = strtok(NULL, \",\");\n    }\n    break;\n  }\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Sets values of req param in dhcp offer packet.\n", "func_signal": "static uint8_t* set_reqparam(uint8_t *optptr, uint8_t *list)", "code": "{\n  uint8_t reqcode;\n  int count, size = ARRAY_LEN(options_list);\n\n  while (*list) {\n    reqcode = *list++;\n    for (count = 0; count < size; count++) {\n      if ((options_list[count].code & 0X00FF)==reqcode) {\n        if (!(options_list[count].len) || !(options_list[count].val)) break;\n        for (; *optptr && *optptr!=DHCP_OPT_END; optptr+=optptr[1]+2);\n        *optptr++ = (uint8_t) (options_list[count].code & 0x00FF);\n        *optptr++ = (uint8_t) options_list[count].len;\n        memcpy(optptr, options_list[count].val, options_list[count].len);\n        optptr += options_list[count].len;\n        *optptr = DHCP_OPT_END;\n        break;\n      }\n    }\n  }\n  return optptr;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// String STR to UINT32 conversion strored in VAR\n", "func_signal": "static int strtou32(const char *str, void *var)", "code": "{\n  char *endptr = NULL;\n  int base = 10;\n  errno=0;\n  *((uint32_t*)(var)) = 0;\n  if (str[0]=='0' && (str[1]=='x' || str[1]=='X')) {\n    base = 16;\n    str+=2;\n  }\n\n  long ret_val = strtol(str, &endptr, base);\n  if (errno) infomsg(infomode, \"config : Invalid num %s\",str);\n  else if (endptr && (*endptr!='\\0'||endptr == str))\n      infomsg(infomode, \"config : Not a valid num %s\",str);\n  else *((uint32_t*)(var)) = (uint32_t)ret_val;\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// IP String STR to binary data.\n", "func_signal": "static int striptovar(const char *str, void *var)", "code": "{\n  *((uint32_t*)(var)) = 0;\n  if(!str) {\n    error_msg(\"config : NULL address string \\n\");\n    return -1;\n  }\n  if((inet_pton(AF_INET6, str, var)<=0) && (inet_pton(AF_INET, str, var)<=0)) {\n    error_msg(\"config : wrong address %s \\n\", str);\n    return -1;\n  }\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Sets a option value in dhcp packet's option field\n", "func_signal": "static uint8_t* set_optval(uint8_t *optptr, uint16_t opt, void *var, size_t len)", "code": "{\n  while (*optptr != DHCP_OPT_END) optptr++;\n  *optptr++ = (uint8_t)(opt & 0x00FF);\n  *optptr++ = (uint8_t) len;\n  memcpy(optptr, var, len);\n  optptr += len;\n  *optptr = DHCP_OPT_END;\n  return optptr;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// returns a IP from static, dynamic leases or free ip pool, 0 otherwise.\n", "func_signal": "static uint32_t getip_from_pool(uint32_t req_nip, uint8_t mac[6], uint32_t *req_exp, char *hostname)", "code": "{\n  uint32_t nip = 0;\n  static_lease *sls = gstate.leases.sleases;\n  struct arg_list *listdls = gstate.dleases, *tmp = NULL;\n\n  if (req_nip && (!verifyip_in_lease(req_nip, mac))) nip = req_nip;\n\n  if (!nip) {\n    while (listdls) {\n      if (!memcmp(((dyn_lease*)listdls->arg)->lease_mac, mac, 6)) {\n        nip = ((dyn_lease*)listdls->arg)->lease_nip;\n        if (tmp) tmp->next = listdls->next;\n        else gstate.dleases = listdls->next;\n        free(listdls->arg);\n        free(listdls);\n        if (verifyip_in_lease(nip, mac) < 0) nip = 0;\n        break;\n      }\n      tmp = listdls;\n      listdls = listdls->next;\n    }\n  }\n  if (!nip) {\n    while (sls) {\n      if (memcmp(sls->mac, mac, 6) == 0) {\n        nip = sls->nip;\n        break;\n      }\n      sls = sls->next;\n    }\n  }\n  if (!nip) {\n    for (nip = htonl(gconfig.start_ip); ntohl(nip) <= gconfig.end_ip; ) {\n      if (!verifyip_in_lease(nip, mac)) break;\n      nip = ntohl(nip);\n      nip = htonl(++nip);\n    }\n    if (ntohl(nip) > gconfig.end_ip) {\n      nip = 0;\n      infomsg(infomode, \"can't find free IP in IP Pool.\");\n    }\n  }\n  if (nip) addip_to_lease(nip, mac, req_exp, hostname, 1);\n  return nip;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "/*\n * Writes self PID in file PATH\n * FIXME: libc implementation only writes in /var/run\n * this is more generic as some implemenation may provide\n * arguments to write in specific file. as dhcpd does.\n */\n", "func_signal": "static void write_pid(char *path)", "code": "{\n  int pidfile = open(path, O_CREAT | O_WRONLY | O_TRUNC, 0666);\n  if (pidfile > 0) {\n    char pidbuf[12];\n\n    sprintf(pidbuf, \"%u\", (unsigned)getpid());\n    write(pidfile, pidbuf, strlen(pidbuf));\n    close(pidfile);\n  }\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Retrives Requested Parameter list from dhcp req packet.\n", "func_signal": "static uint8_t get_reqparam(uint8_t **list)", "code": "{\n  uint8_t len, *optptr;\n  if(*list) free(*list);\n  for (optptr = gstate.rcvd.rcvd_pkt.options;\n      *optptr && *optptr!=((DHCP_OPT_PARAM_REQ) & 0x00FF); optptr+=optptr[1]+2);\n  len = *++optptr;\n  *list = xzalloc(len+1);\n  memcpy(*list, ++optptr, len);\n  return len;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Generic signal handler real handling is done in main funcrion.\n", "func_signal": "static void signal_handler(int sig)", "code": "{\n  unsigned char ch = sig;\n  if (write(sigfd.wr, &ch, 1) != 1) dbg(\"can't send signal\\n\");\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// copy string STR in variable VAR\n", "func_signal": "static int strinvar(const char *str, void *var)", "code": "{\n  char **dest = var;\n  if (*dest) free(*dest);\n  *dest = strdup(str);\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// calculates checksum for dhcp messeges.\n", "func_signal": "static uint16_t dhcp_checksum(void *addr, int count)", "code": "{\n  int32_t sum = 0;\n  uint16_t tmp = 0, *source = (uint16_t *)addr;\n\n  while (count > 1)  {\n    sum += *source++;\n    count -= 2;\n  }\n  if (count > 0) {\n    *(uint8_t*)&tmp = *(uint8_t*)source;\n    sum += tmp;\n  }\n  while (sum >> 16) sum = (sum & 0xffff) + (sum >> 16);\n  return ~sum;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Verify ip NIP in current leases ( assigned or not)\n", "func_signal": "static int verifyip_in_lease(uint32_t nip, uint8_t mac[6])", "code": "{\n  static_lease *sls;\n  struct arg_list *listdls;\n\n  for (listdls = gstate.dleases; listdls; listdls = listdls->next) {\n    if (((dyn_lease*) listdls->arg)->lease_nip == nip) {\n      if (((int32_t)(((dyn_lease*) listdls->arg)->expires) - time(NULL)) < 0)\n        return 0;\n      return -1;\n    }\n    if (!memcmp(((dyn_lease*) listdls->arg)->lease_mac, mac, 6)) return -1;\n  }\n  for (sls = gstate.leases.sleases; sls; sls = sls->next)\n    if (sls->nip == nip) return -2;\n\n  if ((ntohl(nip) < gconfig.start_ip) || (ntohl(nip) > gconfig.end_ip))\n    return -3;\n\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// Reads Static leases from STR and updates inner structures.\n", "func_signal": "static int get_staticlease(const char *str, void *var)", "code": "{\n  struct static_lease_s *sltmp;\n  char *tkmac, *tkip;\n  int count;\n\n  if (!*str) return 0;\n\n  if (!(tkmac = strtok((char*)str, \" \\t\"))) {\n    infomsg(infomode, \"config : static lease : mac not found\");\n    return 0;\n  }\n  if (!(tkip = strtok(NULL, \" \\t\"))) {\n    infomsg(infomode, \"config : static lease : no ip bind to mac %s\", tkmac);\n    return 0;\n  }\n  sltmp = xzalloc(sizeof(struct static_lease_s));\n  for (count = 0; count < 6; count++, tkmac++) {\n    errno = 0;\n    sltmp->mac[count] = strtol(tkmac, &tkmac, 16);\n    if (sltmp->mac[count]>255 || sltmp->mac[count]<0 || (*tkmac && *tkmac!=':') || errno) {\n      infomsg(infomode, \"config : static lease : mac address wrong format\");\n      free(sltmp);\n      return 0;\n    }\n  }\n  striptovar(tkip, &sltmp->nip);\n  sltmp->next = gstate.leases.sleases;\n  gstate.leases.sleases = sltmp;\n\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "// opens UDP socket for listen\n", "func_signal": "static int open_listensock(void)", "code": "{\n  struct sockaddr_in addr;\n  struct ifreq ifr;\n\n  if (gstate.listensock > 0) close(gstate.listensock);\n\n  dbg(\"Opening listen socket on *:%d %s\\n\", gconfig.port, gconfig.interface);\n  gstate.listensock = xsocket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);\n  setsockopt(gstate.listensock, SOL_SOCKET, SO_REUSEADDR, &constone, sizeof(constone));\n  if (setsockopt(gstate.listensock, SOL_SOCKET, SO_BROADCAST, &constone, sizeof(constone)) == -1) {\n    error_msg(\"failed to receive brodcast packets.\\n\");\n    close(gstate.listensock);\n    return -1;\n  }\n  memset(&ifr, 0, sizeof(ifr));\n  xstrncpy(ifr.ifr_name, gconfig.interface, IFNAMSIZ);\n  setsockopt(gstate.listensock, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr));\n\n  memset(&addr, 0, sizeof(addr));\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(gconfig.port); //SERVER_PORT\n  addr.sin_addr.s_addr = INADDR_ANY ;\n\n  if (bind(gstate.listensock, (struct sockaddr *) &addr, sizeof(addr))) {\n    close(gstate.listensock);\n    perror_exit(\"bind failed\");\n  }\n  dbg(\"OPEN : success\\n\");\n  return 0;\n}", "path": "toybox/toys/pending/dhcpd.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "landley/toybox", "stars": 2184, "license": "0bsd", "language": "c", "size": 13201}
{"docstring": "/*\n * Finally, the module stuff\n */\n", "func_signal": "int scullp_init(void)", "code": "{\n\tint result, i;\n\tdev_t dev = MKDEV(scullp_major, 0);\n\t\n\t/*\n\t * Register your major, and accept a dynamic number.\n\t */\n\tif (scullp_major)\n\t\tresult = register_chrdev_region(dev, scullp_devs, \"scullp\");\n\telse {\n\t\tresult = alloc_chrdev_region(&dev, 0, scullp_devs, \"scullp\");\n\t\tscullp_major = MAJOR(dev);\n\t}\n\tif (result < 0)\n\t\treturn result;\n\n\t\n\t/* \n\t * allocate the devices -- we can't have them static, as the number\n\t * can be specified at load time\n\t */\n\tscullp_devices = kmalloc(scullp_devs*sizeof (struct scullp_dev), GFP_KERNEL);\n\tif (!scullp_devices) {\n\t\tresult = -ENOMEM;\n\t\tgoto fail_malloc;\n\t}\n\tmemset(scullp_devices, 0, scullp_devs*sizeof (struct scullp_dev));\n\tfor (i = 0; i < scullp_devs; i++) {\n\t\tscullp_devices[i].order = scullp_order;\n\t\tscullp_devices[i].qset = scullp_qset;\n\t\tmutex_init(&scullp_devices[i].mutex);\n\t\tscullp_setup_cdev(scullp_devices + i, i);\n\t}\n\n\n#ifdef SCULLP_USE_PROC /* only when available */\n\tproc_create(\"scullpmem\", 0, NULL, proc_ops_wrapper(&scullp_proc_ops, scullp_pops));\n#endif\n\treturn 0; /* succeed */\n\n  fail_malloc:\n\tunregister_chrdev_region(dev, scullp_devs);\n\treturn result;\n}", "path": "ldd3/scullp/main.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Follow the list \n */\n", "func_signal": "struct scullp_dev *scullp_follow(struct scullp_dev *dev, int n)", "code": "{\n\twhile (n--) {\n\t\tif (!dev->next) {\n\t\t\tdev->next = kmalloc(sizeof(struct scullp_dev), GFP_KERNEL);\n\t\t\tmemset(dev->next, 0, sizeof(struct scullp_dev));\n\t\t}\n\t\tdev = dev->next;\n\t\tcontinue;\n\t}\n\treturn dev;\n}", "path": "ldd3/scullp/main.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/* then,  the interrupt-related device */\n", "func_signal": "ssize_t short_i_read (struct file *filp, char __user *buf, size_t count, loff_t *f_pos)", "code": "{\n\tint count0;\n\tDEFINE_WAIT(wait);\n\n\twhile (short_head == short_tail) {\n\t\tprepare_to_wait(&short_queue, &wait, TASK_INTERRUPTIBLE);\n\t\tif (short_head == short_tail)\n\t\t\tschedule();\n\t\tfinish_wait(&short_queue, &wait);\n\t\tif (signal_pending (current))  /* a signal arrived */\n\t\t\treturn -ERESTARTSYS; /* tell the fs layer to handle it */\n\t} \n\t/* count0 is the number of readable data bytes */\n\tcount0 = short_head - short_tail;\n\tif (count0 < 0) /* wrapped */\n\t\tcount0 = short_buffer + PAGE_SIZE - short_tail;\n\tif (count0 < count) count = count0;\n\n\tif (copy_to_user(buf, (char *)short_tail, count))\n\t\treturn -EFAULT;\n\tshort_incr_bp (&short_tail, count);\n\treturn count;\n}", "path": "ldd3/short/short.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * The ioctl() implementation\n */\n", "func_signal": "long scullp_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)", "code": "{\n\n\tint err = 0, ret = 0, tmp;\n\n\t/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */\n\tif (_IOC_TYPE(cmd) != SCULLP_IOC_MAGIC) return -ENOTTY;\n\tif (_IOC_NR(cmd) > SCULLP_IOC_MAXNR) return -ENOTTY;\n\n\t/*\n\t * the type is a bitmask, and VERIFY_WRITE catches R/W\n\t * transfers. Note that the type is user-oriented, while\n\t * verify_area is kernel-oriented, so the concept of \"read\" and\n\t * \"write\" is reversed\n\t */\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\terr = !access_ok_wrapper(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));\n\telse if (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\terr =  !access_ok_wrapper(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));\n\tif (err)\n\t\treturn -EFAULT;\n\n\tswitch(cmd) {\n\n\tcase SCULLP_IOCRESET:\n\t\tscullp_qset = SCULLP_QSET;\n\t\tscullp_order = SCULLP_ORDER;\n\t\tbreak;\n\n\tcase SCULLP_IOCSORDER: /* Set: arg points to the value */\n\t\tret = __get_user(scullp_order, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLP_IOCTORDER: /* Tell: arg is the value */\n\t\tscullp_order = arg;\n\t\tbreak;\n\n\tcase SCULLP_IOCGORDER: /* Get: arg is pointer to result */\n\t\tret = __put_user (scullp_order, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLP_IOCQORDER: /* Query: return it (it's positive) */\n\t\treturn scullp_order;\n\n\tcase SCULLP_IOCXORDER: /* eXchange: use arg as pointer */\n\t\ttmp = scullp_order;\n\t\tret = __get_user(scullp_order, (int __user *) arg);\n\t\tif (ret == 0)\n\t\t\tret = __put_user(tmp, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLP_IOCHORDER: /* sHift: like Tell + Query */\n\t\ttmp = scullp_order;\n\t\tscullp_order = arg;\n\t\treturn tmp;\n\n\tcase SCULLP_IOCSQSET:\n\t\tret = __get_user(scullp_qset, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLP_IOCTQSET:\n\t\tscullp_qset = arg;\n\t\tbreak;\n\n\tcase SCULLP_IOCGQSET:\n\t\tret = __put_user(scullp_qset, (int __user *)arg);\n\t\tbreak;\n\n\tcase SCULLP_IOCQQSET:\n\t\treturn scullp_qset;\n\n\tcase SCULLP_IOCXQSET:\n\t\ttmp = scullp_qset;\n\t\tret = __get_user(scullp_qset, (int __user *)arg);\n\t\tif (ret == 0)\n\t\t\tret = __put_user(tmp, (int __user *)arg);\n\t\tbreak;\n\n\tcase SCULLP_IOCHQSET:\n\t\ttmp = scullp_qset;\n\t\tscullp_qset = arg;\n\t\treturn tmp;\n\n\tdefault:  /* redundant, as cmd was checked against MAXNR */\n\t\treturn -ENOTTY;\n\t}\n\n\treturn ret;\n}", "path": "ldd3/scullp/main.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/* detect the the device if the region is still free */\n", "func_signal": "static int skull_detect(unsigned int port, unsigned int range)", "code": "{\n    int err;\n\n    if ((err = check_region(port,range)) < 0) return err; /* busy */\n    if (skull_probe_hw(port,range) != 0) return -ENODEV;  /* not found */\n    request_region(port,range,\"skull\");                   /* \"Can't fail\" */\n    return 0;\n}", "path": "ldd3/skull/skull_init.c", "commit_date": "2010-11-27 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/* FIXME: Do we need this here??  It be ugly  */\n", "func_signal": "int scullp_read_procmem(struct seq_file *m, void *v)", "code": "{\n\tint i, j, order, qset;\n\tint limit = m->size - 80; /* Don't print more than this */\n\tstruct scullp_dev *d;\n\n\tfor(i = 0; i < scullp_devs; i++) {\n\t\td = &scullp_devices[i];\n\t\tif (mutex_lock_interruptible (&d->mutex))\n\t\t\treturn -ERESTARTSYS;\n\t\tqset = d->qset;  /* retrieve the features of each device */\n\t\torder = d->order;\n\t\tseq_printf(m,\"\\nDevice %i: qset %i, order %i, sz %li\\n\",\n\t\t\t\ti, qset, order, (long)(d->size));\n\t\tfor (; d; d = d->next) { /* scan the list */\n\t\t\tseq_printf(m,\"  item at %p, qset at %p\\n\",d,d->data);\n\t\t\tif (m->count > limit)\n\t\t\t\tgoto out;\n\t\t\tif (d->data && !d->next) /* dump only the last item - save space */\n\t\t\t\tfor (j = 0; j < qset; j++) {\n\t\t\t\t\tif (d->data[j])\n\t\t\t\t\t\tseq_printf(m,\"    % 4i:%8p\\n\",j,d->data[j]);\n\t\t\t\t\tif (m->count > limit)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t  out:\n\t\tmutex_unlock (&scullp_devices[i].mutex);\n\t\tif (m->count > limit)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}", "path": "ldd3/scullp/main.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Do the printing; return non-zero if the task should be rescheduled.\n */\n", "func_signal": "static int jiq_print(struct clientdata *data)", "code": "{\n\tint len = data->len;\n\tstruct seq_file *m = data->m;\n\tunsigned long j = jiffies;\n\n\tif (len > LIMIT) {\n\t\twake_up_interruptible(&jiq_wait);\n\t\treturn 0;\n\t}\n\n\tif (len == 0) {\n\t\tseq_puts(m, \"    time  delta preempt   pid cpu command\\n\");\n\t\tlen = m->count;\n\t} else {\n\t\tlen = 0;\n\t}\n\n\t/* intr_count is only exported since 1.3.5,\n\t   but 1.99.4 is needed anyways */\n\tseq_printf(m, \"%9li  %4li     %3i %5i %3i %s\\n\",\n\t\t\tj, j - data->jiffies,\n\t\t\tpreempt_count(), current->pid, smp_processor_id(),\n\t\t\tcurrent->comm);\n\tlen += m->count;\n\n\tdata->len += len;\n\tdata->jiffies = j;\n\treturn 1;\n}", "path": "ldd3/misc-modules/jiq.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * The devices with low minor numbers write/read burst of data to/from\n * specific I/O ports (by default the parallel ones).\n * \n * The device with 128 as minor number returns ascii strings telling\n * when interrupts have been received. Writing to the device toggles\n * 00/FF on the parallel data lines. If there is a loopback wire, this\n * generates interrupts.  \n */\n", "func_signal": "int short_open (struct inode *inode, struct file *filp)", "code": "{\n\textern struct file_operations short_i_fops;\n\n\tif (iminor (inode) & 0x80)\n\t\tfilp->f_op = &short_i_fops; /* the interrupt-driven node */\n\treturn 0;\n}", "path": "ldd3/short/short.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Atomicly increment an index into short_buffer\n */\n", "func_signal": "static inline void short_incr_bp(volatile unsigned long *index, int delta)", "code": "{\n\tunsigned long new = *index + delta;\n\tbarrier();  /* Don't optimize these two together */\n\t*index = (new >= (short_buffer + PAGE_SIZE)) ? short_buffer : new;\n}", "path": "ldd3/short/short.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Data management: read and write\n */\n", "func_signal": "ssize_t scullp_read (struct file *filp, char __user *buf, size_t count,\n                loff_t *f_pos)", "code": "{\n\tstruct scullp_dev *dev = filp->private_data; /* the first listitem */\n\tstruct scullp_dev *dptr;\n\tint quantum = PAGE_SIZE << dev->order;\n\tint qset = dev->qset;\n\tint itemsize = quantum * qset; /* how many bytes in the listitem */\n\tint item, s_pos, q_pos, rest;\n\tssize_t retval = 0;\n\n\tif (mutex_lock_interruptible(&dev->mutex))\n\t\treturn -ERESTARTSYS;\n\tif (*f_pos > dev->size) \n\t\tgoto nothing;\n\tif (*f_pos + count > dev->size)\n\t\tcount = dev->size - *f_pos;\n\t/* find listitem, qset index, and offset in the quantum */\n\titem = ((long) *f_pos) / itemsize;\n\trest = ((long) *f_pos) % itemsize;\n\ts_pos = rest / quantum; q_pos = rest % quantum;\n\n    \t/* follow the list up to the right position (defined elsewhere) */\n\tdptr = scullp_follow(dev, item);\n\n\tif (!dptr->data)\n\t\tgoto nothing; /* don't fill holes */\n\tif (!dptr->data[s_pos])\n\t\tgoto nothing;\n\tif (count > quantum - q_pos)\n\t\tcount = quantum - q_pos; /* read only up to the end of this quantum */\n\n\tif (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {\n\t\tretval = -EFAULT;\n\t\tgoto nothing;\n\t}\n\tmutex_unlock(&dev->mutex);\n\n\t*f_pos += count;\n\treturn count;\n\n  nothing:\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}", "path": "ldd3/scullp/main.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Call jiq_print from a tasklet\n */\n", "func_signal": "static void jiq_print_tasklet(unsigned long ptr)", "code": "{\n\tstruct clientdata *data = (struct clientdata *)ptr;\n\tif (jiq_print(data))\n\t\ttasklet_schedule(&data->jiq_tasklet);\n}", "path": "ldd3/misc-modules/jiq.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * the init/clean material\n */\n", "func_signal": "static int jiq_init(void)", "code": "{\n\t/* this line is in jiq_init() */\n\tINIT_WORK(&jiq_data.jiq_work, jiq_print_wq);\n\tINIT_DELAYED_WORK(&jiq_data.jiq_delayed_work, jiq_print_wq_delayed);\n\ttasklet_init(&jiq_data.jiq_tasklet, jiq_print_tasklet,\n\t    (unsigned long)&jiq_data);\n\n\tproc_create(\"jiqwq\", 0, NULL,\n\t    proc_ops_wrapper(&jiq_read_wq_fops, jiq_read_wq_pops));\n\tproc_create(\"jiqwqdelay\", 0, NULL,\n\t    proc_ops_wrapper(&jiq_read_wq_delayed_fops, jiq_read_wq_delayed_pops));\n\tproc_create(\"jitimer\", 0, NULL,\n\t    proc_ops_wrapper(&jiq_read_run_timer_fops, jiq_read_run_timer_pops));\n\tproc_create(\"jiqtasklet\", 0, NULL,\n\t    proc_ops_wrapper(&jiq_read_tasklet_fops, jiq_read_tasklet_pops));\n\n\treturn 0; /* succeed */\n}", "path": "ldd3/misc-modules/jiq.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Tasklet top half\n */\n", "func_signal": "irqreturn_t short_tl_interrupt(int irq, void *dev_id)", "code": "{\n\tktime_get_real_ts64((struct timespec64 *) tv_head); /* cast to stop 'volatile' warning */\n\tshort_incr_tv(&tv_head);\n\ttasklet_schedule(&short_tasklet);\n\tshort_wq_count++; /* record that an interrupt arrived */\n\treturn IRQ_HANDLED;\n}", "path": "ldd3/short/short.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Increment a circular buffer pointer in a way that nobody sees\n * an intermediate value.\n */\n", "func_signal": "static inline void short_incr_tv(volatile struct timespec64 **tvp)", "code": "{\n\tif (*tvp == (tv_data + NR_TIMEVAL - 1))\n\t\t*tvp = tv_data;\t /* Wrap */\n\telse\n\t\t(*tvp)++;\n}", "path": "ldd3/short/short.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Call jiq_print from a work queue\n */\n", "func_signal": "static void jiq_print_wq(struct work_struct *work)", "code": "{\n\tstruct clientdata *data = container_of(work,\n\t\t\t\t\tstruct clientdata, jiq_work);\n\n\tif (!jiq_print(data))\n\t\treturn;\n\n\tschedule_work(&jiq_data.jiq_work);\n}", "path": "ldd3/misc-modules/jiq.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * Open and close\n */\n", "func_signal": "int scullp_open (struct inode *inode, struct file *filp)", "code": "{\n\tstruct scullp_dev *dev; /* device information */\n\n\t/*  Find the device */\n\tdev = container_of(inode->i_cdev, struct scullp_dev, cdev);\n\n    \t/* now trim to 0 the length of the device if open was write-only */\n\tif ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {\n\t\tif (mutex_lock_interruptible(&dev->mutex))\n\t\t\treturn -ERESTARTSYS;\n\t\tscullp_trim(dev); /* ignore errors */\n\t\tmutex_unlock(&dev->mutex);\n\t}\n\n\t/* and use filp->private_data to point to the device data */\n\tfilp->private_data = dev;\n\n\treturn 0;          /* success */\n}", "path": "ldd3/scullp/main.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * This one, instead, tests out the timers.\n */\n", "func_signal": "static void jiq_timedout(struct timer_list *t)", "code": "{\n\tstruct clientdata *data = from_timer(data, t, jiq_timer);\n\tjiq_print(data);            /* print a line */\n\twake_up_interruptible(&jiq_wait);  /* awake the process */\n}", "path": "ldd3/misc-modules/jiq.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/*\n * The \"extended\" operations\n */\n", "func_signal": "loff_t scullp_llseek (struct file *filp, loff_t off, int whence)", "code": "{\n\tstruct scullp_dev *dev = filp->private_data;\n\tlong newpos;\n\n\tswitch(whence) {\n\tcase 0: /* SEEK_SET */\n\t\tnewpos = off;\n\t\tbreak;\n\n\tcase 1: /* SEEK_CUR */\n\t\tnewpos = filp->f_pos + off;\n\t\tbreak;\n\n\tcase 2: /* SEEK_END */\n\t\tnewpos = dev->size + off;\n\t\tbreak;\n\n\tdefault: /* can't happen */\n\t\treturn -EINVAL;\n\t}\n\tif (newpos<0) return -EINVAL;\n\tfilp->f_pos = newpos;\n\treturn newpos;\n}", "path": "ldd3/scullp/main.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/* have three symbols to export */\n", "func_signal": "void skull_fn1(void)", "code": "{}\nstatic void skull_fn2(void){}\n       int  skull_variable;\n\nEXPORT_SYMBOL (skull_fn1);\nEXPORT_SYMBOL (skull_fn2);\nEXPORT_SYMBOL (skull_variable);\n\n\n/* perform hardware autodetection */\nint skull_probe_hw(unsigned int port, unsigned int range)\n{\n   /* do smart probing here */\n   return -1; /* not found  :-) */\n}", "path": "ldd3/skull/skull_init.c", "commit_date": "2010-11-27 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
{"docstring": "/* Finally, init and cleanup */\n", "func_signal": "int short_init(void)", "code": "{\n\tint result;\n\n\t/*\n\t * first, sort out the base/short_base ambiguity: we'd better\n\t * use short_base in the code, for clarity, but allow setting\n\t * just \"base\" at load time. Same for \"irq\".\n\t */\n\tshort_base = base;\n\tshort_irq = irq;\n\n\t/* Get our needed resources. */\n\tif (!use_mem) {\n\t\tif (! request_region(short_base, SHORT_NR_PORTS, \"short\")) {\n\t\t\tprintk(KERN_INFO \"short: can't get I/O port address 0x%lx\\n\",\n\t\t\t\t\tshort_base);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t} else {\n\t\tif (! request_mem_region(short_base, SHORT_NR_PORTS, \"short\")) {\n\t\t\tprintk(KERN_INFO \"short: can't get I/O mem address 0x%lx\\n\",\n\t\t\t\t\tshort_base);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/* also, ioremap it */\n\t\tshort_base = (unsigned long) ioremap(short_base, SHORT_NR_PORTS);\n\t\t/* Hmm... we should check the return value */\n\t}\n\t/* Here we register our device - should not fail thereafter */\n\tresult = register_chrdev(major, \"short\", &short_fops);\n\tif (result < 0) {\n\t\tprintk(KERN_INFO \"short: can't get major number\\n\");\n\t\trelease_region(short_base,SHORT_NR_PORTS);  /* FIXME - use-mem case? */\n\t\treturn result;\n\t}\n\tif (major == 0) major = result; /* dynamic */\n\n\tshort_buffer = __get_free_pages(GFP_KERNEL,0); /* never fails */  /* FIXME */\n\tshort_head = short_tail = short_buffer;\n\n\t/*\n\t * Fill the workqueue structure, used for the bottom half handler.\n\t * The cast is there to prevent warnings about the type of the\n\t * (unused) argument.\n\t */\n\t/* this line is in short_init() */\n\tINIT_WORK(&short_wq, (void (*)(struct work_struct *)) short_do_tasklet);\n\n\t/*\n\t * Now we deal with the interrupt: either kernel-based\n\t * autodetection, DIY detection or default number\n\t */\n\n\tif (short_irq < 0 && probe == 1)\n\t\tshort_kernelprobe();\n\n\tif (short_irq < 0 && probe == 2)\n\t\tshort_selfprobe();\n\n\tif (short_irq < 0) /* not yet specified: force the default on */\n\t\tswitch(short_base) {\n\t\t    case 0x378: short_irq = 7; break;\n\t\t    case 0x278: short_irq = 2; break;\n\t\t    case 0x3bc: short_irq = 5; break;\n\t\t}\n\n\t/*\n\t * If shared has been specified, installed the shared handler\n\t * instead of the normal one. Do it first, before a -EBUSY will\n\t * force short_irq to -1.\n\t */\n\tif (short_irq >= 0 && share > 0) {\n\t\tresult = request_irq(short_irq, short_sh_interrupt,\n\t\t\t\t     IRQF_SHARED,\"short\",\n\t\t\t\tshort_sh_interrupt);\n\t\tif (result) {\n\t\t\tprintk(KERN_INFO \"short: can't get assigned irq %i\\n\", short_irq);\n\t\t\tshort_irq = -1;\n\t\t}\n\t\telse { /* actually enable it -- assume this *is* a parallel port */\n\t\t\toutb(0x10, short_base+2);\n\t\t}\n\t\treturn 0; /* the rest of the function only installs handlers */\n\t}\n\n\tif (short_irq >= 0) {\n\t\tresult = request_irq(short_irq, short_interrupt,\n\t\t\t\t     0, \"short\", NULL);\n\t\tif (result) {\n\t\t\tprintk(KERN_INFO \"short: can't get assigned irq %i\\n\",\n\t\t\t\t\tshort_irq);\n\t\t\tshort_irq = -1;\n\t\t}\n\t\telse { /* actually enable it -- assume this *is* a parallel port */\n\t\t\toutb(0x10,short_base+2);\n\t\t}\n\t}\n\n\t/*\n\t * Ok, now change the interrupt handler if using top/bottom halves\n\t * has been requested\n\t */\n\tif (short_irq >= 0 && (wq + tasklet) > 0) {\n\t\tfree_irq(short_irq,NULL);\n\t\tresult = request_irq(short_irq,\n\t\t\t\ttasklet ? short_tl_interrupt :\n\t\t\t\tshort_wq_interrupt,\n\t\t\t\t0, \"short-bh\", NULL);\n\t\tif (result) {\n\t\t\tprintk(KERN_INFO \"short-bh: can't get assigned irq %i\\n\",\n\t\t\t\t\tshort_irq);\n\t\t\tshort_irq = -1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "ldd3/short/short.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "martinezjavier/ldd3", "stars": 2234, "license": "other", "language": "c", "size": 363}
